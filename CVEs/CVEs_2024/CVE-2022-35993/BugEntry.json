{"buggy_code": ["/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// Ops for operating with sets. They are not checked in\n// to TensorFlow because we would first like to demonstrate successful\n// end-to-end use of these ops in eval and polish the api a bit like taking two\n// SparseTensor rather than on edense and one sparse.\n\n#define EIGEN_USE_THREADS\n\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <utility>\n#include <vector>\n\n#include \"absl/container/btree_set.h\"\n#include \"absl/container/flat_hash_set.h\"\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_util.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/lib/core/status.h\"\n#include \"tensorflow/core/platform/env.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/util/sparse/sparse_tensor.h\"\n\nnamespace tensorflow {\n\nusing ShapeArray = sparse::SparseTensor::ShapeArray;\nusing VarDimArray = sparse::SparseTensor::VarDimArray;\n\n// Validate rank >= 2.\nvoid CheckRankAtLeast2(OpKernelContext* ctx, const TensorShape& shape) {\n  const auto rank = shape.dims();\n  OP_REQUIRES(ctx, rank >= 2,\n              errors::InvalidArgument(\"Invalid rank \", rank, \".\"));\n}\n\n// Return group shape, which is the 1st n-1 dimensions of shape.\nStatus GroupShape(const VarDimArray& input_shape, ShapeArray* grouped_shape) {\n  if (input_shape.size() < 2) {\n    // TODO(irving): Why can't 2 be 1 here?\n    return errors::InvalidArgument(\"Shape [\", absl::StrJoin(input_shape, \",\"),\n                                   \"] has rank \", input_shape.size(), \" < 2\");\n  }\n  // grouped_shape is input_shape[:-1]\n  *grouped_shape = ShapeArray(input_shape.begin(), input_shape.end() - 1);\n  return OkStatus();\n}\n\n// Build `SparseTensor` from indices, values, and shape in inputs\n// [base_index, base_index + 3), and validate its rank and indices.\nStatus SparseTensorFromContext(OpKernelContext* ctx, const int32_t base_index,\n                               const bool validate_indices,\n                               sparse::SparseTensor* tensor) {\n  // Assume row-major order.\n  TensorShape shape;\n  TF_RETURN_IF_ERROR(TensorShape::BuildTensorShape(\n      ctx->input(base_index + 2).vec<int64_t>(), &shape));\n  CheckRankAtLeast2(ctx, shape);\n  std::vector<int64_t> order(shape.dims());\n  std::iota(order.begin(), order.end(), 0);\n\n  Status status = sparse::SparseTensor::Create(\n      ctx->input(base_index), ctx->input(base_index + 1), shape, order, tensor);\n\n  if (!validate_indices || !status.ok()) return status;\n  return tensor->IndicesValid();\n}\n\n// TODO(ptucker): CheckGroup is just a sanity check on the result of\n// SparseTensor.group, consider removing.\n// `sparse_tensor_shape` is the shape of the `SparseTensor` from which group\n// was created, and is used to sanity check the indices in `group'.\ntemplate <typename T>\nvoid CheckGroup(OpKernelContext* ctx, const sparse::Group& group,\n                const VarDimArray& sparse_tensor_shape) {\n  const auto& indices = group.indices();\n  const auto& values = group.values<T>();\n\n  // Sanity check: group is non-empty, and indices and values are same size.\n  const auto num_values = values.dimension(0);\n  OP_REQUIRES(ctx, indices.size() > 0, errors::Internal(\"Empty group.\"));\n  OP_REQUIRES(\n      ctx, indices.dimension(0) == num_values,\n      errors::Internal(\"shape[0] of group indices \", indices.dimension(0),\n                       \" != values \", num_values, \".\"));\n\n  // Sanity check: valid indices.\n  const auto group_rank = indices.dimension(1);\n  const auto expected_rank = sparse_tensor_shape.size();\n  OP_REQUIRES(ctx, expected_rank == group_rank,\n              errors::Internal(\"Rank expected \", expected_rank, \", got \",\n                               group_rank, \".\"));\n  for (int32_t j = 0; j < expected_rank; ++j) {\n    const auto dim_size = sparse_tensor_shape[j];\n    OP_REQUIRES(\n        ctx, dim_size > 0,\n        errors::Internal(\"Invalid dim_size[\", j, \"] = \", dim_size, \".\"));\n    for (int64_t i = 0; i < num_values; ++i) {\n      const auto index = indices(i, j);\n      OP_REQUIRES(ctx, dim_size > index,\n                  errors::Internal(\"indices[\", i, \", \", j, \"] expected < \",\n                                   dim_size, \", got \", index, \".\"));\n    }\n  }\n}\n\n// This lets us calculate the row-major index into flattened output.\nconst ShapeArray Strides(const VarDimArray& shape) {\n  ShapeArray result(shape.size());\n  int64_t product = 1;\n  for (int i = shape.size() - 1; i >= 0; --i) {\n    result[i] = product;\n    product *= shape[i];\n  }\n  return result;\n}\n\n// TODO(ptucker): If memory becomes an issue, consider a 2-pass approach to\n// eliminate the intermediate `values` data structure - iterate once to\n// determine `num_values`, allocate output tensors, then write results directly\n// to output tensors.\n\n// TODO(ptucker): Consider sharding work across multiple threads. See\n// SparseCrossOp for an example.\n\n// Output `SparseTensor` of shape `output_shape`. `sets` contains pairs of\n// group indices (i.e., values for all but the last dimension of `output_shape`)\n// and set values, each of which will occupy the last dimension of\n// `output_shape`. `sets` should be sorted in ascending order by group indices.\ntemplate <typename T>\nvoid OutputSparseTensor(\n    OpKernelContext* ctx, const TensorShape& output_shape,\n    const int64_t num_values,\n    const std::vector<std::pair<std::vector<int64_t>, absl::btree_set<T>>>&\n        sets) {\n  // Allocate 3 output tensors for sparse data.\n  Tensor *out_indices_t, *out_values_t, *out_shape_t;\n  OP_REQUIRES_OK(ctx, ctx->allocate_output(\n                          0, TensorShape({num_values, output_shape.dims()}),\n                          &out_indices_t));\n  OP_REQUIRES_OK(\n      ctx, ctx->allocate_output(1, TensorShape({num_values}), &out_values_t));\n  OP_REQUIRES_OK(ctx, ctx->allocate_output(\n                          2, TensorShape({output_shape.dims()}), &out_shape_t));\n  auto out_indices_mat = out_indices_t->matrix<int64_t>();\n  auto out_values_flat = out_values_t->vec<T>();\n\n  // For each set, write its indices and values to output tensors.\n  int64_t value_index = 0;\n  for (auto it = sets.begin(); it != sets.end(); ++it) {\n    const auto& group_indices = it->first;\n    OP_REQUIRES(\n        ctx, group_indices.size() == output_shape.dims() - 1,\n        errors::Internal(\"Invalid number of indices \", group_indices.size(),\n                         \", expected \", output_shape.dims() - 1, \".\"));\n    const auto& set = it->second;\n\n    // For each set item, write its indices and value to output tensors.\n    int64_t group_value_index = 0;\n    for (auto value = set.begin(); value != set.end();\n         ++value, ++value_index, ++group_value_index) {\n      // First n-1 dimensions are the group, last dimension is the position in\n      // the set.\n      for (int32_t i = 0; i < group_indices.size(); ++i) {\n        out_indices_mat(value_index, i) = group_indices[i];\n      }\n      out_indices_mat(value_index, group_indices.size()) = group_value_index;\n\n      out_values_flat(value_index) = *value;\n    }\n  }\n\n  // Write output shape.\n  auto out_shape_flat = out_shape_t->vec<int64_t>();\n  for (int32_t i = 0; i < output_shape.dims(); ++i) {\n    out_shape_flat(i) = output_shape.dim_size(i);\n  }\n}\n\nbool ValidateIndicesFromContext(OpKernelConstruction* ctx) {\n  bool result;\n  if (ctx->GetAttr(\"validate_indices\", &result).ok()) {\n    return result;\n  }\n  return true;\n}\n\n// Populate `result` set from group in `tensor`. \"Group\" is defined by\n// `group_indices`, which are values for the first n-1 dimensions of\n// `input_tensor`. `input_strides` is provided to avoid recalculating it\n// multiple times, and is used to calculate the flat index into `input_tensor`\n// values.\ntemplate <typename T>\nvoid PopulateFromDenseGroup(OpKernelContext* ctx, const Tensor& input_tensor,\n                            const VarDimArray& input_strides,\n                            const std::vector<int64_t>& group_indices,\n                            absl::flat_hash_set<T>* result) {\n  OP_REQUIRES(ctx, group_indices.size() == input_strides.size() - 1,\n              errors::Internal(\"group_indices.size \", group_indices.size(),\n                               \", !=  input_strides.size-1 \",\n                               input_strides.size() - 1, \".\"));\n  result->clear();\n  auto input_flat = input_tensor.flat<T>();\n  const auto start = std::inner_product(\n      group_indices.begin(), group_indices.end(), input_strides.begin(), 0LL);\n  const TensorShape& input_shape = input_tensor.shape();\n  const auto end = start + input_shape.dim_size(input_shape.dims() - 1);\n  for (int64_t i = start; i < end; ++i) {\n    result->insert(input_flat(i));\n  }\n}\n\n// Populate `result` set from `group`. `sparse_tensor_shape` is the shape of the\n// `SparseTensor` from which group was created, and is used to sanity check the\n// indices in `group'.\ntemplate <typename T>\nvoid PopulateFromSparseGroup(OpKernelContext* ctx, const sparse::Group& group,\n                             const VarDimArray& sparse_tensor_shape,\n                             absl::flat_hash_set<T>* result) {\n  CheckGroup<T>(ctx, group, sparse_tensor_shape);\n  result->clear();\n  const auto& group_values = group.values<T>();\n  for (int64_t i = 0; i < group_values.size(); ++i) {\n    result->insert(group_values(i));\n  }\n}\n\ntemplate <typename T>\nclass SetSizeOp : public OpKernel {\n public:\n  explicit SetSizeOp(OpKernelConstruction* ctx)\n      : OpKernel(ctx), validate_indices_(ValidateIndicesFromContext(ctx)) {}\n\n  void Compute(OpKernelContext* ctx) override;\n\n private:\n  const bool validate_indices_;\n};\n\ntemplate <typename T>\nvoid SetSizeOp<T>::Compute(OpKernelContext* ctx) {\n  sparse::SparseTensor set_st;\n  OP_REQUIRES_OK(ctx,\n                 SparseTensorFromContext(ctx, 0, validate_indices_, &set_st));\n\n  // Output shape is same as input except for last dimension, which reduces\n  // to the set size of values along that dimension.\n  ShapeArray output_shape;\n  OP_REQUIRES_OK(ctx, GroupShape(set_st.shape(), &output_shape));\n  const auto output_strides = Strides(output_shape);\n\n  TensorShape output_shape_ts;\n  OP_REQUIRES_OK(ctx,\n                 TensorShapeUtils::MakeShape(output_shape, &output_shape_ts));\n  Tensor* out_t;\n  OP_REQUIRES_OK(ctx, ctx->allocate_output(0, output_shape_ts, &out_t));\n  auto out = out_t->flat<int32>();\n  out.device(ctx->eigen_cpu_device()) = out.constant(static_cast<int32>(0.0));\n\n  // Group by all but last dimension, create a set of group values, and add set\n  // size to output.\n  VarDimArray group_ix = set_st.order().subspan(0, set_st.order().size() - 1);\n  absl::flat_hash_set<T> group_set;\n  for (const auto& group : set_st.group(group_ix)) {\n    PopulateFromSparseGroup<T>(ctx, group, set_st.shape(), &group_set);\n\n    const auto group_key = group.group();\n    const auto output_index = std::inner_product(\n        group_key.begin(), group_key.end(), output_strides.begin(), 0LL);\n    out(output_index) = group_set.size();\n  }\n}\n\n#define _SET_SIZE_REGISTER_KERNEL_BUILDER(T)                     \\\n  REGISTER_KERNEL_BUILDER(                                       \\\n      Name(\"SetSize\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      SetSizeOp<T>);\n_SET_SIZE_REGISTER_KERNEL_BUILDER(int8);\n_SET_SIZE_REGISTER_KERNEL_BUILDER(int16);\n_SET_SIZE_REGISTER_KERNEL_BUILDER(int32);\n_SET_SIZE_REGISTER_KERNEL_BUILDER(int64_t);\n_SET_SIZE_REGISTER_KERNEL_BUILDER(uint8);\n_SET_SIZE_REGISTER_KERNEL_BUILDER(uint16);\n_SET_SIZE_REGISTER_KERNEL_BUILDER(tstring);\n#undef _SET_SIZE_REGISTER_KERNEL_BUILDER\n\nenum InputTypes {\n  DENSE_DENSE = 0,\n  DENSE_SPARSE = 1,\n  SPARSE_SPARSE = 2,\n};\n\nenum SetOperation { A_MINUS_B = 0, B_MINUS_A = 1, INTERSECTION = 2, UNION = 3 };\n\nSetOperation SetOperationFromContext(OpKernelConstruction* ctx) {\n  string set_operation_str;\n  if (!ctx->GetAttr(\"set_operation\", &set_operation_str).ok()) {\n    ctx->CtxFailure(errors::InvalidArgument(\"Missing set_operation.\"));\n  } else {\n    std::transform(set_operation_str.begin(), set_operation_str.end(),\n                   set_operation_str.begin(), ::tolower);\n    if (\"a-b\" == set_operation_str) {\n      return A_MINUS_B;\n    }\n    if (\"b-a\" == set_operation_str) {\n      return B_MINUS_A;\n    }\n    if (\"intersection\" == set_operation_str) {\n      return INTERSECTION;\n    }\n    if (\"union\" != set_operation_str) {\n      ctx->CtxFailure(errors::InvalidArgument(\"Invalid set_operation \",\n                                              set_operation_str, \".\"));\n    }\n  }\n  // NOTE: This is not the default, this function fails if no 'set_operation'\n  // attribute is provided.\n  return UNION;\n}\n\n// Abstract base class for performing set operations across the last dimension\n// of 2 input tensors.\ntemplate <typename T>\nclass SetOperationOp : public OpKernel {\n public:\n  SetOperationOp(OpKernelConstruction* ctx, InputTypes input_types)\n      : OpKernel(ctx),\n        set_operation_(SetOperationFromContext(ctx)),\n        validate_indices_(ValidateIndicesFromContext(ctx)),\n        input_types_(input_types) {}\n\n  void Compute(OpKernelContext* ctx) override;\n\n private:\n  void ApplySetOperation(const absl::flat_hash_set<T>& set1,\n                         const absl::flat_hash_set<T>& set2,\n                         absl::btree_set<T>* result) const;\n  void ComputeDenseToDense(OpKernelContext* ctx) const;\n  void ComputeDenseToSparse(OpKernelContext* ctx) const;\n  void ComputeSparseToSparse(OpKernelContext* ctx) const;\n  const SetOperation set_operation_;\n  const bool validate_indices_;\n  const InputTypes input_types_;\n};\n\ntemplate <typename T>\nvoid SetDifference(const absl::flat_hash_set<T>& set1,\n                   const absl::flat_hash_set<T>& set2,\n                   absl::btree_set<T>* result) {\n  for (const T& elem : set1) {\n    if (!set2.contains(elem)) result->insert(elem);\n  }\n}\n\ntemplate <typename T>\nvoid SetIntersection(const absl::flat_hash_set<T>& set1,\n                     const absl::flat_hash_set<T>& set2,\n                     absl::btree_set<T>* result) {\n  if (set1.size() <= set2.size()) {\n    for (const T& elem : set1) {\n      if (set2.contains(elem)) result->insert(elem);\n    }\n  } else {\n    for (const T& elem : set2) {\n      if (set1.contains(elem)) result->insert(elem);\n    }\n  }\n}\n\ntemplate <typename T>\nvoid SetUnion(const absl::flat_hash_set<T>& set1,\n              const absl::flat_hash_set<T>& set2, absl::btree_set<T>* result) {\n  result->insert(set1.begin(), set1.end());\n  result->insert(set2.begin(), set2.end());\n}\n\ntemplate <typename T>\nvoid SetOperationOp<T>::ApplySetOperation(const absl::flat_hash_set<T>& set1,\n                                          const absl::flat_hash_set<T>& set2,\n                                          absl::btree_set<T>* result) const {\n  switch (set_operation_) {\n    case A_MINUS_B:\n      SetDifference<T>(set1, set2, result);\n      break;\n    case B_MINUS_A:\n      SetDifference<T>(set2, set1, result);\n      break;\n    case INTERSECTION:\n      SetIntersection<T>(set1, set2, result);\n      break;\n    case UNION:\n      SetUnion<T>(set1, set2, result);\n      break;\n  }\n}\n\n// Validate shapes have the same dimensions.\nStatus CheckShapesMatch(VarDimArray shape1, VarDimArray shape2) {\n  if (shape1 != shape2) {\n    return errors::InvalidArgument(\"Mismatched shapes [\",\n                                   absl::StrJoin(shape1, \",\"), \"] vs [\",\n                                   absl::StrJoin(shape2, \",\"), \"]\");\n  }\n  return OkStatus();\n}\n\n// Validate ranks are the same, and all but last dimension are the same.\n// Return GroupShape.\nStatus GroupShapeFromInputs(VarDimArray shape1, VarDimArray shape2,\n                            ShapeArray* group_shape) {\n  ShapeArray group_shape_1;\n  TF_RETURN_IF_ERROR(GroupShape(shape1, &group_shape_1));\n  ShapeArray group_shape_2;\n  TF_RETURN_IF_ERROR(GroupShape(shape2, &group_shape_2));\n  TF_RETURN_IF_ERROR(CheckShapesMatch(group_shape_1, group_shape_2));\n  *group_shape = group_shape_1;\n  return OkStatus();\n}\n\n// Split `flat_group_index` into separate dimensions based on `group_shape`.\nvoid PopulateGroupIndices(const int64_t flat_group_index,\n                          VarDimArray group_shape,\n                          std::vector<int64_t>* group_indices) {\n  group_indices->clear();\n  int64_t running_flat_group_index = flat_group_index;\n  for (int group_dim_index = group_shape.size() - 1; group_dim_index >= 0;\n       --group_dim_index) {\n    const auto group_dim = group_shape[group_dim_index];\n    group_indices->insert(group_indices->begin(),\n                          running_flat_group_index % group_dim);\n    running_flat_group_index /= group_dim;\n  }\n}\n\nShapeArray TensorShapeToArray(const TensorShape& t) {\n  ShapeArray vec(t.dims());\n  for (int i = 0; i < t.dims(); ++i) vec[i] = t.dim_size(i);\n  return vec;\n}\n\n// `ctx` contains set1 and set2 dense tensors.\n// Iterate over groups in set1 and set2, applying `ApplySetOperation` to each,\n// and outputting the result `SparseTensor`. A \"group\" is a collection of values\n// with the same first n-1 dimensions in set1 and set2.\ntemplate <typename T>\nvoid SetOperationOp<T>::ComputeDenseToDense(OpKernelContext* ctx) const {\n  const Tensor& set1_t = ctx->input(0);\n  const Tensor& set2_t = ctx->input(1);\n  // The following should stay in sync with `_dense_to_dense_shape` shape\n  // assertions in python/ops/set_ops.py, and `SetShapeFn` for\n  // `DenseToDenseSetOperation` in ops/set_ops.cc.\n  ShapeArray group_shape;\n  const auto shape1 = TensorShapeToArray(set1_t.shape());\n  const auto shape2 = TensorShapeToArray(set2_t.shape());\n  OP_REQUIRES_OK(ctx, GroupShapeFromInputs(shape1, shape2, &group_shape));\n\n  const auto set1_strides = Strides(shape1);\n  const auto set2_strides = Strides(shape2);\n\n  std::vector<std::pair<std::vector<int64_t>, absl::btree_set<T>>> group_sets;\n  int64_t num_result_values = 0;\n  int64_t max_set_size = 0;\n\n  absl::flat_hash_set<T> set1_group_set;\n  absl::flat_hash_set<T> set2_group_set;\n  std::vector<int64_t> group_indices;\n  int64_t num_elements;\n  OP_REQUIRES_OK(ctx,\n                 TensorShapeUtils::NumElements(group_shape, &num_elements));\n  for (int64_t flat_group_index = 0; flat_group_index < num_elements;\n       ++flat_group_index) {\n    PopulateGroupIndices(flat_group_index, group_shape, &group_indices);\n    PopulateFromDenseGroup<T>(ctx, set1_t, set1_strides, group_indices,\n                              &set1_group_set);\n    PopulateFromDenseGroup<T>(ctx, set2_t, set2_strides, group_indices,\n                              &set2_group_set);\n\n    absl::btree_set<T> group_set;\n    ApplySetOperation(set1_group_set, set2_group_set, &group_set);\n    if (!group_set.empty()) {\n      const auto set_size = group_set.size();\n      if (set_size > max_set_size) {\n        max_set_size = set_size;\n      }\n      num_result_values += set_size;\n      group_sets.push_back({group_indices, std::move(group_set)});\n    }\n  }\n\n  TensorShape output_shape;\n  OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape(group_shape, &output_shape));\n  output_shape.AddDim(max_set_size);\n  OutputSparseTensor<T>(ctx, output_shape, num_result_values, group_sets);\n}\n\n// `ctx` contains dense set1 and sparse set2 tensors.\n// Iterate over groups in set1 and set2, applying `ApplySetOperation` to each,\n// and outputing the result `SparseTensor`. A \"group\" is a collection of values\n// with the same first n-1 dimensions in set1 and set2.\ntemplate <typename T>\nvoid SetOperationOp<T>::ComputeDenseToSparse(OpKernelContext* ctx) const {\n  const Tensor& set1_t = ctx->input(0);\n  sparse::SparseTensor set2_st;\n  OP_REQUIRES_OK(ctx,\n                 SparseTensorFromContext(ctx, 1, validate_indices_, &set2_st));\n  // The following should stay in sync with `_dense_to_sparse_shape` shape\n  // assertions in python/ops/set_ops.py, and `SetShapeFn` for\n  // `DenseToSparseSetOperation` in ops/set_ops.cc.\n  ShapeArray group_shape;\n  OP_REQUIRES_OK(ctx, GroupShapeFromInputs(TensorShapeToArray(set1_t.shape()),\n                                           set2_st.shape(), &group_shape));\n\n  const ShapeArray set1_strides = Strides(TensorShapeToArray(set1_t.shape()));\n\n  std::vector<std::pair<std::vector<int64_t>, absl::btree_set<T>>> group_sets;\n  int64_t num_result_values = 0;\n  int64_t max_set_size = 0;\n\n  absl::flat_hash_set<T> set1_group_set;\n  absl::flat_hash_set<T> set2_group_set;\n  auto set2_grouper =\n      set2_st.group(set2_st.order().subspan(0, set2_st.order().size() - 1));\n  auto set2_group_it = set2_grouper.begin();\n  std::vector<int64_t> group_indices;\n  int64_t num_elements;\n  OP_REQUIRES_OK(ctx,\n                 TensorShapeUtils::NumElements(group_shape, &num_elements));\n  for (int64_t flat_group_index = 0; flat_group_index < num_elements;\n       ++flat_group_index) {\n    PopulateGroupIndices(flat_group_index, group_shape, &group_indices);\n\n    // Get values from set1.\n    PopulateFromDenseGroup<T>(ctx, set1_t, set1_strides, group_indices,\n                              &set1_group_set);\n\n    // Get values from set2, if applicable.\n    set2_group_set.clear();\n    if (set2_group_it != set2_grouper.end()) {\n      const auto& group = *set2_group_it;\n      const auto set2_group_indices = group.group();\n      OP_REQUIRES(\n          ctx, set2_group_indices.size() == group_indices.size(),\n          errors::InvalidArgument(\"Invalid number of group indices \",\n                                  set2_group_indices.size(), \", expected \",\n                                  group_indices.size(), \".\"));\n      bool group_match = true;\n      for (int32_t i = 0; group_match && (i < set2_group_indices.size()); ++i) {\n        if (set2_group_indices[i] != group_indices[i]) {\n          group_match = false;\n        }\n      }\n      if (group_match) {\n        PopulateFromSparseGroup<T>(ctx, group, set2_st.shape(),\n                                   &set2_group_set);\n        ++set2_group_it;\n      }\n    }\n\n    absl::btree_set<T> group_set;\n    ApplySetOperation(set1_group_set, set2_group_set, &group_set);\n    if (!group_set.empty()) {\n      const auto set_size = group_set.size();\n      if (set_size > max_set_size) {\n        max_set_size = set_size;\n      }\n      num_result_values += set_size;\n      group_sets.push_back({group_indices, std::move(group_set)});\n    }\n  }\n\n  TensorShape output_shape;\n  OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape(group_shape, &output_shape));\n  output_shape.AddDim(max_set_size);\n  OutputSparseTensor<T>(ctx, output_shape, num_result_values, group_sets);\n}\n\n// This is used to determine which group iterator is less than the other, based\n// on row-major ordering of indices.\n// An empty index list indicates end of iteration, which is interpreted as \"max\"\n// for the purposes of comparison; i.e., non-empty < empty.\n// Return 0 if both groups are empty, or both non-empty with the same values.\n// Return <0 if set1 <= set2, or set2 is empty.\n// Return >0 if set2 <= set1, or set1 is empty.\nvoid CompareGroups(OpKernelContext* ctx,\n                   const std::vector<int64_t>& set1_group_indices,\n                   const std::vector<int64_t>& set2_group_indices,\n                   int64_t* result) {\n  if (set1_group_indices.empty()) {\n    *result = set2_group_indices.empty() ? 0 : 1;\n    return;\n  }\n  if (set2_group_indices.empty()) {\n    *result = set1_group_indices.empty() ? 0 : -1;\n    return;\n  }\n  OP_REQUIRES(ctx, set1_group_indices.size() == set2_group_indices.size(),\n              errors::InvalidArgument(\"Mismatched group dims \",\n                                      set1_group_indices.size(), \" vs \",\n                                      set2_group_indices.size(), \".\"));\n  for (int32_t i = 0; i < set1_group_indices.size(); ++i) {\n    *result = set1_group_indices[i] - set2_group_indices[i];\n    if (*result != 0) {\n      return;\n    }\n  }\n}\n\n// `ctx` contains set1 and set2 sparse tensors.\n// Iterate over groups in set1 and set2, applying `ApplySetOperation` to each,\n// and outputing the result `SparseTensor`. A \"group\" is a collection of values\n// with the same first n-1 dimensions in set1 and set2.\ntemplate <typename T>\nvoid SetOperationOp<T>::ComputeSparseToSparse(OpKernelContext* ctx) const {\n  sparse::SparseTensor set1_st;\n  OP_REQUIRES_OK(ctx,\n                 SparseTensorFromContext(ctx, 0, validate_indices_, &set1_st));\n\n  sparse::SparseTensor set2_st;\n  OP_REQUIRES_OK(ctx,\n                 SparseTensorFromContext(ctx, 3, validate_indices_, &set2_st));\n\n  // The following should stay in sync with `_sparse_to_sparse_shape` shape\n  // assertions in python/ops/set_ops.py, and `SetShapeFn` for\n  // `SparseToSparseSetOperation` in ops/set_ops.cc.\n  ShapeArray group_shape;\n  OP_REQUIRES_OK(ctx, GroupShapeFromInputs(set1_st.shape(), set2_st.shape(),\n                                           &group_shape));\n\n  std::vector<std::pair<std::vector<int64_t>, absl::btree_set<T>>> group_sets;\n  int64_t num_result_values = 0;\n  int64_t max_set_size = 0;\n\n  absl::flat_hash_set<T> set1_group_set;\n  absl::flat_hash_set<T> set2_group_set;\n  auto set1_grouper =\n      set1_st.group(set1_st.order().subspan(0, set1_st.order().size() - 1));\n  auto set1_group_it = set1_grouper.begin();\n  auto set2_grouper =\n      set2_st.group(set2_st.order().subspan(0, set2_st.order().size() - 1));\n  auto set2_group_it = set2_grouper.begin();\n\n  // Empty indices vector represents iteration end in `CompareGroups`.\n  const std::vector<int64_t> group_iter_end;\n  // Group by rows, and iterate over rows of both sets in parallel, creating a\n  // set for each row.\n  while ((set1_group_it != set1_grouper.end()) ||\n         (set2_group_it != set2_grouper.end())) {\n    const std::vector<int64_t>& set1_group_indices =\n        (set1_group_it == set1_grouper.end()) ? group_iter_end\n                                              : (*set1_group_it).group();\n    const std::vector<int64_t>& set2_group_indices =\n        (set2_group_it == set2_grouper.end()) ? group_iter_end\n                                              : (*set2_group_it).group();\n\n    int64_t compare_groups;\n    CompareGroups(ctx, set1_group_indices, set2_group_indices, &compare_groups);\n    const std::vector<int64_t>* group_indices = nullptr;\n\n    // Get values from set1, if applicable.\n    set1_group_set.clear();\n    if (compare_groups <= 0) {\n      PopulateFromSparseGroup<T>(ctx, *set1_group_it, set1_st.shape(),\n                                 &set1_group_set);\n      ++set1_group_it;\n      group_indices = &set1_group_indices;\n    }\n\n    // Get values from set2, if applicable.\n    set2_group_set.clear();\n    if (compare_groups >= 0) {\n      PopulateFromSparseGroup<T>(ctx, *set2_group_it, set2_st.shape(),\n                                 &set2_group_set);\n      ++set2_group_it;\n      group_indices = &set2_group_indices;\n    }\n\n    absl::btree_set<T> group_set;\n    ApplySetOperation(set1_group_set, set2_group_set, &group_set);\n    if (!group_set.empty()) {\n      const auto set_size = group_set.size();\n      if (set_size > max_set_size) {\n        max_set_size = set_size;\n      }\n      num_result_values += set_size;\n      group_sets.push_back({*group_indices, std::move(group_set)});\n    }\n  }\n\n  TensorShape output_shape;\n  OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape(group_shape, &output_shape));\n  output_shape.AddDim(max_set_size);\n  OutputSparseTensor<T>(ctx, output_shape, num_result_values, group_sets);\n}\n\n// Given set1 of shape [b, n1] and data_2 of shape [b, n2], populate result\n// sparse tensor with [b, n3] values, where each row `i` contains the result of\n// the set operation on elements from set1[i] and set2[i]. `n3` is the number\n// of elements in that result row.\ntemplate <typename T>\nvoid SetOperationOp<T>::Compute(OpKernelContext* ctx) {\n  switch (input_types_) {\n    case DENSE_DENSE:\n      ComputeDenseToDense(ctx);\n      break;\n    case DENSE_SPARSE:\n      ComputeDenseToSparse(ctx);\n      break;\n    case SPARSE_SPARSE:\n      ComputeSparseToSparse(ctx);\n      break;\n  }\n}\n\ntemplate <typename T>\nclass DenseToDenseSetOperationOp : public SetOperationOp<T> {\n public:\n  explicit DenseToDenseSetOperationOp(OpKernelConstruction* ctx)\n      : SetOperationOp<T>(ctx, DENSE_DENSE) {}\n};\n\n#define _DENSE_TO_DENSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(T) \\\n  REGISTER_KERNEL_BUILDER(Name(\"DenseToDenseSetOperation\")       \\\n                              .Device(DEVICE_CPU)                \\\n                              .TypeConstraint<T>(\"T\"),           \\\n                          DenseToDenseSetOperationOp<T>);\n_DENSE_TO_DENSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int8);\n_DENSE_TO_DENSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int16);\n_DENSE_TO_DENSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int32);\n_DENSE_TO_DENSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int64_t);\n_DENSE_TO_DENSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(uint8);\n_DENSE_TO_DENSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(uint16);\n_DENSE_TO_DENSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(tstring);\n#undef _DENSE_TO_DENSE_SET_OPERATION_REGISTER_KERNEL_BUILDER\n\ntemplate <typename T>\nclass DenseToSparseSetOperationOp : public SetOperationOp<T> {\n public:\n  explicit DenseToSparseSetOperationOp(OpKernelConstruction* ctx)\n      : SetOperationOp<T>(ctx, DENSE_SPARSE) {}\n};\n\n#define _DENSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(T) \\\n  REGISTER_KERNEL_BUILDER(Name(\"DenseToSparseSetOperation\")       \\\n                              .Device(DEVICE_CPU)                 \\\n                              .TypeConstraint<T>(\"T\"),            \\\n                          DenseToSparseSetOperationOp<T>);\n_DENSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int8);\n_DENSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int16);\n_DENSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int32);\n_DENSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int64_t);\n_DENSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(uint8);\n_DENSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(uint16);\n_DENSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(tstring);\n#undef _DENSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER\n\ntemplate <typename T>\nclass SparseToSparseSetOperationOp : public SetOperationOp<T> {\n public:\n  explicit SparseToSparseSetOperationOp(OpKernelConstruction* ctx)\n      : SetOperationOp<T>(ctx, SPARSE_SPARSE) {}\n};\n\n#define _SPARSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(T) \\\n  REGISTER_KERNEL_BUILDER(Name(\"SparseToSparseSetOperation\")       \\\n                              .Device(DEVICE_CPU)                  \\\n                              .TypeConstraint<T>(\"T\"),             \\\n                          SparseToSparseSetOperationOp<T>);\n_SPARSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int8);\n_SPARSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int16);\n_SPARSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int32);\n_SPARSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int64_t);\n_SPARSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(uint8);\n_SPARSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(uint16);\n_SPARSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(tstring);\n#undef _SPARSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER\n\n}  // namespace tensorflow\n", "# Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for set_ops.\"\"\"\n\nfrom absl.testing import parameterized\nimport numpy as np\n\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors_impl\nfrom tensorflow.python.framework import sparse_tensor as sparse_tensor_lib\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import sets\nfrom tensorflow.python.ops import sparse_ops\nfrom tensorflow.python.platform import googletest\n\n_DTYPES = set([\n    dtypes.int8, dtypes.int16, dtypes.int32, dtypes.int64, dtypes.uint8,\n    dtypes.uint16, dtypes.string\n])\n\n\ndef _values(values, dtype):\n  return np.array(\n      values,\n      dtype=(np.str_ if (dtype == dtypes.string) else dtype.as_numpy_dtype))\n\n\ndef _constant(values, dtype):\n  return constant_op.constant(_values(values, dtype), dtype=dtype)\n\n\ndef _dense_to_sparse(dense, dtype):\n  indices = []\n  values = []\n  max_row_len = 0\n  for row in dense:\n    max_row_len = max(max_row_len, len(row))\n  shape = [len(dense), max_row_len]\n  row_ix = 0\n  for row in dense:\n    col_ix = 0\n    for cell in row:\n      indices.append([row_ix, col_ix])\n      values.append(str(cell) if dtype == dtypes.string else cell)\n      col_ix += 1\n    row_ix += 1\n  return sparse_tensor_lib.SparseTensor(\n      constant_op.constant(indices, dtypes.int64),\n      constant_op.constant(values, dtype),\n      constant_op.constant(shape, dtypes.int64))\n\n\nclass SetOpsTest(test_util.TensorFlowTestCase, parameterized.TestCase):\n\n  @test_util.run_deprecated_v1\n  def test_set_size_2d(self):\n    for dtype in _DTYPES:\n      self._test_set_size_2d(dtype)\n\n  def _test_set_size_2d(self, dtype):\n    self.assertAllEqual([1], self._set_size(_dense_to_sparse([[1]], dtype)))\n    self.assertAllEqual([2, 1],\n                        self._set_size(_dense_to_sparse([[1, 9], [1]], dtype)))\n    self.assertAllEqual(\n        [3, 0], self._set_size(_dense_to_sparse([[1, 9, 2], []], dtype)))\n    self.assertAllEqual(\n        [0, 3], self._set_size(_dense_to_sparse([[], [1, 9, 2]], dtype)))\n\n  @test_util.run_deprecated_v1\n  def test_set_size_duplicates_2d(self):\n    for dtype in _DTYPES:\n      self._test_set_size_duplicates_2d(dtype)\n\n  def _test_set_size_duplicates_2d(self, dtype):\n    self.assertAllEqual(\n        [1], self._set_size(_dense_to_sparse([[1, 1, 1, 1, 1, 1]], dtype)))\n    self.assertAllEqual([2, 7, 3, 0, 1],\n                        self._set_size(\n                            _dense_to_sparse([[1, 9], [\n                                6, 7, 8, 8, 6, 7, 5, 3, 3, 0, 6, 6, 9, 0, 0, 0\n                            ], [999, 1, -1000], [], [-1]], dtype)))\n\n  @test_util.run_deprecated_v1\n  def test_set_size_3d(self):\n    for dtype in _DTYPES:\n      self._test_set_size_3d(dtype)\n\n  def test_set_size_3d_invalid_indices(self):\n    for dtype in _DTYPES:\n      self._test_set_size_3d(dtype, invalid_indices=True)\n\n  def _test_set_size_3d(self, dtype, invalid_indices=False):\n    if invalid_indices:\n      indices = constant_op.constant([\n          [0, 1, 0], [0, 1, 1],             # 0,1\n          [1, 0, 0],                        # 1,0\n          [1, 1, 0], [1, 1, 1], [1, 1, 2],  # 1,1\n          [0, 0, 0], [0, 0, 2],             # 0,0\n                                            # 2,0\n          [2, 1, 1]                         # 2,1\n      ], dtypes.int64)\n    else:\n      indices = constant_op.constant([\n          [0, 0, 0], [0, 0, 2],             # 0,0\n          [0, 1, 0], [0, 1, 1],             # 0,1\n          [1, 0, 0],                        # 1,0\n          [1, 1, 0], [1, 1, 1], [1, 1, 2],  # 1,1\n                                            # 2,0\n          [2, 1, 1]                         # 2,1\n      ], dtypes.int64)\n\n    sp = sparse_tensor_lib.SparseTensor(\n        indices,\n        _constant([\n            1, 9,     # 0,0\n            3, 3,     # 0,1\n            1,        # 1,0\n            9, 7, 8,  # 1,1\n                      # 2,0\n            5         # 2,1\n        ], dtype),\n        constant_op.constant([3, 2, 3], dtypes.int64))\n\n    if invalid_indices:\n      with self.assertRaisesRegex(errors_impl.OpError, \"out of order\"):\n        self._set_size(sp)\n    else:\n      self.assertAllEqual([\n          [2,   # 0,0\n           1],  # 0,1\n          [1,   # 1,0\n           3],  # 1,1\n          [0,   # 2,0\n           1]   # 2,1\n      ], self._set_size(sp))\n\n  def _set_size(self, sparse_data):\n    # Validate that we get the same results with or without `validate_indices`.\n    ops = [\n        sets.set_size(sparse_data, validate_indices=True),\n        sets.set_size(sparse_data, validate_indices=False)\n    ]\n    for op in ops:\n      self.assertEqual(None, op.get_shape().dims)\n      self.assertEqual(dtypes.int32, op.dtype)\n    with self.cached_session() as sess:\n      results = self.evaluate(ops)\n    self.assertAllEqual(results[0], results[1])\n    return results[0]\n\n  @test_util.run_deprecated_v1\n  def test_set_intersection_multirow_2d(self):\n    for dtype in _DTYPES:\n      self._test_set_intersection_multirow_2d(dtype)\n\n  def _test_set_intersection_multirow_2d(self, dtype):\n    a_values = [[9, 1, 5], [2, 4, 3]]\n    b_values = [[1, 9], [1]]\n    expected_indices = [[0, 0], [0, 1]]\n    expected_values = _values([1, 9], dtype)\n    expected_shape = [2, 2]\n    expected_counts = [2, 0]\n\n    # Dense to sparse.\n    a = _constant(a_values, dtype=dtype)\n    sp_b = _dense_to_sparse(b_values, dtype=dtype)\n    intersection = self._set_intersection(a, sp_b)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        intersection,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts, self._set_intersection_count(a, sp_b))\n\n    # Sparse to sparse.\n    sp_a = _dense_to_sparse(a_values, dtype=dtype)\n    intersection = self._set_intersection(sp_a, sp_b)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        intersection,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_intersection_count(sp_a, sp_b))\n\n  @test_util.run_deprecated_v1\n  def test_dense_set_intersection_multirow_2d(self):\n    for dtype in _DTYPES:\n      self._test_dense_set_intersection_multirow_2d(dtype)\n\n  def _test_dense_set_intersection_multirow_2d(self, dtype):\n    a_values = [[9, 1, 5], [2, 4, 3]]\n    b_values = [[1, 9], [1, 5]]\n    expected_indices = [[0, 0], [0, 1]]\n    expected_values = _values([1, 9], dtype)\n    expected_shape = [2, 2]\n    expected_counts = [2, 0]\n\n    # Dense to dense.\n    a = _constant(a_values, dtype)\n    b = _constant(b_values, dtype)\n    intersection = self._set_intersection(a, b)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        intersection,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts, self._set_intersection_count(a, b))\n\n  @test_util.run_deprecated_v1\n  def test_set_intersection_duplicates_2d(self):\n    for dtype in _DTYPES:\n      self._test_set_intersection_duplicates_2d(dtype)\n\n  def _test_set_intersection_duplicates_2d(self, dtype):\n    a_values = [[1, 1, 3]]\n    b_values = [[1]]\n    expected_indices = [[0, 0]]\n    expected_values = _values([1], dtype)\n    expected_shape = [1, 1]\n    expected_counts = [1]\n\n    # Dense to dense.\n    a = _constant(a_values, dtype=dtype)\n    b = _constant(b_values, dtype=dtype)\n    intersection = self._set_intersection(a, b)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        intersection,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts, self._set_intersection_count(a, b))\n\n    # Dense to sparse.\n    sp_b = _dense_to_sparse(b_values, dtype=dtype)\n    intersection = self._set_intersection(a, sp_b)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        intersection,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts, self._set_intersection_count(a, sp_b))\n\n    # Sparse to sparse.\n    sp_a = _dense_to_sparse(a_values, dtype=dtype)\n    intersection = self._set_intersection(sp_a, sp_b)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        intersection,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_intersection_count(sp_a, sp_b))\n\n  @test_util.run_deprecated_v1\n  def test_set_intersection_3d(self):\n    for dtype in _DTYPES:\n      self._test_set_intersection_3d(dtype=dtype)\n\n  def test_set_intersection_3d_invalid_indices(self):\n    for dtype in _DTYPES:\n      self._test_set_intersection_3d(dtype=dtype, invalid_indices=True)\n\n  def _test_set_intersection_3d(self, dtype, invalid_indices=False):\n    if invalid_indices:\n      indices = constant_op.constant(\n          [\n              [0, 1, 0],\n              [0, 1, 1],  # 0,1\n              [1, 0, 0],  # 1,0\n              [1, 1, 0],\n              [1, 1, 1],\n              [1, 1, 2],  # 1,1\n              [0, 0, 0],\n              [0, 0, 2],  # 0,0\n              # 2,0\n              [2, 1, 1]  # 2,1\n              # 3,*\n          ],\n          dtypes.int64)\n    else:\n      indices = constant_op.constant(\n          [\n              [0, 0, 0],\n              [0, 0, 2],  # 0,0\n              [0, 1, 0],\n              [0, 1, 1],  # 0,1\n              [1, 0, 0],  # 1,0\n              [1, 1, 0],\n              [1, 1, 1],\n              [1, 1, 2],  # 1,1\n              # 2,0\n              [2, 1, 1]  # 2,1\n              # 3,*\n          ],\n          dtypes.int64)\n    sp_a = sparse_tensor_lib.SparseTensor(\n        indices,\n        _constant(\n            [\n                1,\n                9,  # 0,0\n                3,\n                3,  # 0,1\n                1,  # 1,0\n                9,\n                7,\n                8,  # 1,1\n                # 2,0\n                5  # 2,1\n                # 3,*\n            ],\n            dtype),\n        constant_op.constant([4, 2, 3], dtypes.int64))\n    sp_b = sparse_tensor_lib.SparseTensor(\n        constant_op.constant(\n            [\n                [0, 0, 0],\n                [0, 0, 3],  # 0,0\n                # 0,1\n                [1, 0, 0],  # 1,0\n                [1, 1, 0],\n                [1, 1, 1],  # 1,1\n                [2, 0, 1],  # 2,0\n                [2, 1, 1],  # 2,1\n                [3, 0, 0],  # 3,0\n                [3, 1, 0]  # 3,1\n            ],\n            dtypes.int64),\n        _constant(\n            [\n                1,\n                3,  # 0,0\n                # 0,1\n                3,  # 1,0\n                7,\n                8,  # 1,1\n                2,  # 2,0\n                5,  # 2,1\n                4,  # 3,0\n                4  # 3,1\n            ],\n            dtype),\n        constant_op.constant([4, 2, 4], dtypes.int64))\n\n    if invalid_indices:\n      with self.assertRaisesRegex(errors_impl.OpError, \"out of order\"):\n        self._set_intersection(sp_a, sp_b)\n    else:\n      expected_indices = [\n          [0, 0, 0],  # 0,0\n          # 0,1\n          # 1,0\n          [1, 1, 0],\n          [1, 1, 1],  # 1,1\n          # 2,0\n          [2, 1, 0],  # 2,1\n          # 3,*\n      ]\n      expected_values = _values(\n          [\n              1,  # 0,0\n              # 0,1\n              # 1,0\n              7,\n              8,  # 1,1\n              # 2,0\n              5,  # 2,1\n              # 3,*\n          ],\n          dtype)\n      expected_shape = [4, 2, 2]\n      expected_counts = [\n          [\n              1,  # 0,0\n              0  # 0,1\n          ],\n          [\n              0,  # 1,0\n              2  # 1,1\n          ],\n          [\n              0,  # 2,0\n              1  # 2,1\n          ],\n          [\n              0,  # 3,0\n              0  # 3,1\n          ]\n      ]\n\n      # Sparse to sparse.\n      intersection = self._set_intersection(sp_a, sp_b)\n      self._assert_set_operation(\n          expected_indices,\n          expected_values,\n          expected_shape,\n          intersection,\n          dtype=dtype)\n      self.assertAllEqual(expected_counts,\n                          self._set_intersection_count(sp_a, sp_b))\n\n      # NOTE: sparse_to_dense doesn't support uint8 and uint16.\n      if dtype not in [dtypes.uint8, dtypes.uint16]:\n        # Dense to sparse.\n        a = math_ops.cast(\n            sparse_ops.sparse_to_dense(\n                sp_a.indices,\n                sp_a.dense_shape,\n                sp_a.values,\n                default_value=\"-1\" if dtype == dtypes.string else -1),\n            dtype=dtype)\n        intersection = self._set_intersection(a, sp_b)\n        self._assert_set_operation(\n            expected_indices,\n            expected_values,\n            expected_shape,\n            intersection,\n            dtype=dtype)\n        self.assertAllEqual(expected_counts,\n                            self._set_intersection_count(a, sp_b))\n\n        # Dense to dense.\n        b = math_ops.cast(\n            sparse_ops.sparse_to_dense(\n                sp_b.indices,\n                sp_b.dense_shape,\n                sp_b.values,\n                default_value=\"-2\" if dtype == dtypes.string else -2),\n            dtype=dtype)\n        intersection = self._set_intersection(a, b)\n        self._assert_set_operation(\n            expected_indices,\n            expected_values,\n            expected_shape,\n            intersection,\n            dtype=dtype)\n        self.assertAllEqual(expected_counts, self._set_intersection_count(a, b))\n\n  def _assert_static_shapes(self, input_tensor, result_sparse_tensor):\n    if isinstance(input_tensor, sparse_tensor_lib.SparseTensor):\n      sparse_shape_dims = input_tensor.dense_shape.get_shape().dims\n      if sparse_shape_dims is None:\n        expected_rank = None\n      else:\n        expected_rank = sparse_shape_dims[0].value\n    else:\n      expected_rank = input_tensor.get_shape().ndims\n    self.assertAllEqual((None, expected_rank),\n                        result_sparse_tensor.indices.get_shape().as_list())\n    self.assertAllEqual((None,),\n                        result_sparse_tensor.values.get_shape().as_list())\n    self.assertAllEqual((expected_rank,),\n                        result_sparse_tensor.dense_shape.get_shape().as_list())\n\n  def _run_equivalent_set_ops(self, ops):\n    \"\"\"Assert all ops return the same shapes, and return 1st result.\"\"\"\n    # Collect shapes and results for all ops, and assert static shapes match.\n    dynamic_indices_shape_ops = []\n    dynamic_values_shape_ops = []\n    static_indices_shape = None\n    static_values_shape = None\n    with self.cached_session() as sess:\n      for op in ops:\n        if static_indices_shape is None:\n          static_indices_shape = op.indices.get_shape()\n        else:\n          self.assertAllEqual(\n              static_indices_shape.as_list(), op.indices.get_shape().as_list())\n        if static_values_shape is None:\n          static_values_shape = op.values.get_shape()\n        else:\n          self.assertAllEqual(\n              static_values_shape.as_list(), op.values.get_shape().as_list())\n        dynamic_indices_shape_ops.append(array_ops.shape(op.indices))\n        dynamic_values_shape_ops.append(array_ops.shape(op.values))\n      results = sess.run(\n          list(ops) + dynamic_indices_shape_ops + dynamic_values_shape_ops)\n      op_count = len(ops)\n      op_results = results[0:op_count]\n      dynamic_indices_shapes = results[op_count:2 * op_count]\n      dynamic_values_shapes = results[2 * op_count:3 * op_count]\n\n    # Assert static and dynamic tensor shapes, and result shapes, are all\n    # consistent.\n    static_indices_shape.assert_is_compatible_with(dynamic_indices_shapes[0])\n    static_values_shape.assert_is_compatible_with(dynamic_values_shapes[0])\n    self.assertAllEqual(dynamic_indices_shapes[0], op_results[0].indices.shape)\n    self.assertAllEqual(dynamic_values_shapes[0], op_results[0].values.shape)\n\n    # Assert dynamic shapes and values are the same for all ops.\n    for i in range(1, len(ops)):\n      self.assertAllEqual(dynamic_indices_shapes[0], dynamic_indices_shapes[i])\n      self.assertAllEqual(dynamic_values_shapes[0], dynamic_values_shapes[i])\n      self.assertAllEqual(op_results[0].indices, op_results[i].indices)\n      self.assertAllEqual(op_results[0].values, op_results[i].values)\n      self.assertAllEqual(op_results[0].dense_shape, op_results[i].dense_shape)\n\n    return op_results[0]\n\n  def _set_intersection(self, a, b):\n    # Validate that we get the same results with or without `validate_indices`,\n    # and with a & b swapped.\n    ops = (\n        sets.set_intersection(\n            a, b, validate_indices=True),\n        sets.set_intersection(\n            a, b, validate_indices=False),\n        sets.set_intersection(\n            b, a, validate_indices=True),\n        sets.set_intersection(\n            b, a, validate_indices=False),)\n    for op in ops:\n      self._assert_static_shapes(a, op)\n    return self._run_equivalent_set_ops(ops)\n\n  def _set_intersection_count(self, a, b):\n    op = sets.set_size(sets.set_intersection(a, b))\n    with self.cached_session() as sess:\n      return self.evaluate(op)\n\n  @test_util.run_deprecated_v1\n  def test_set_difference_multirow_2d(self):\n    for dtype in _DTYPES:\n      self._test_set_difference_multirow_2d(dtype)\n\n  def _test_set_difference_multirow_2d(self, dtype):\n    a_values = [[1, 1, 1], [1, 5, 9], [4, 5, 3], [5, 5, 1]]\n    b_values = [[], [1, 2], [1, 2, 2], []]\n\n    # a - b.\n    expected_indices = [[0, 0], [1, 0], [1, 1], [2, 0], [2, 1], [2, 2], [3, 0],\n                        [3, 1]]\n    expected_values = _values([1, 5, 9, 3, 4, 5, 1, 5], dtype)\n    expected_shape = [4, 3]\n    expected_counts = [1, 2, 3, 2]\n\n    # Dense to sparse.\n    a = _constant(a_values, dtype=dtype)\n    sp_b = _dense_to_sparse(b_values, dtype=dtype)\n    difference = self._set_difference(a, sp_b, True)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(a, sp_b, True))\n\n    # Sparse to sparse.\n    sp_a = _dense_to_sparse(a_values, dtype=dtype)\n    difference = self._set_difference(sp_a, sp_b, True)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(sp_a, sp_b, True))\n\n    # b - a.\n    expected_indices = [[1, 0], [2, 0], [2, 1]]\n    expected_values = _values([2, 1, 2], dtype)\n    expected_shape = [4, 2]\n    expected_counts = [0, 1, 2, 0]\n\n    # Dense to sparse.\n    difference = self._set_difference(a, sp_b, False)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(a, sp_b, False))\n\n    # Sparse to sparse.\n    difference = self._set_difference(sp_a, sp_b, False)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(sp_a, sp_b, False))\n\n  @test_util.run_deprecated_v1\n  def test_dense_set_difference_multirow_2d(self):\n    for dtype in _DTYPES:\n      self._test_dense_set_difference_multirow_2d(dtype)\n\n  def _test_dense_set_difference_multirow_2d(self, dtype):\n    a_values = [[1, 5, 9], [4, 5, 3]]\n    b_values = [[1, 2, 6], [1, 2, 2]]\n\n    # a - b.\n    expected_indices = [[0, 0], [0, 1], [1, 0], [1, 1], [1, 2]]\n    expected_values = _values([5, 9, 3, 4, 5], dtype)\n    expected_shape = [2, 3]\n    expected_counts = [2, 3]\n\n    # Dense to dense.\n    a = _constant(a_values, dtype=dtype)\n    b = _constant(b_values, dtype=dtype)\n    difference = self._set_difference(a, b, True)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts, self._set_difference_count(a, b, True))\n\n    # b - a.\n    expected_indices = [[0, 0], [0, 1], [1, 0], [1, 1]]\n    expected_values = _values([2, 6, 1, 2], dtype)\n    expected_shape = [2, 2]\n    expected_counts = [2, 2]\n\n    # Dense to dense.\n    difference = self._set_difference(a, b, False)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(a, b, False))\n\n  @test_util.run_deprecated_v1\n  def test_sparse_set_difference_multirow_2d(self):\n    for dtype in _DTYPES:\n      self._test_sparse_set_difference_multirow_2d(dtype)\n\n  def _test_sparse_set_difference_multirow_2d(self, dtype):\n    sp_a = _dense_to_sparse(\n        [[], [1, 5, 9], [4, 5, 3, 3, 4, 5], [5, 1]], dtype=dtype)\n    sp_b = _dense_to_sparse([[], [1, 2], [1, 2, 2], []], dtype=dtype)\n\n    # a - b.\n    expected_indices = [[1, 0], [1, 1], [2, 0], [2, 1], [2, 2], [3, 0], [3, 1]]\n    expected_values = _values([5, 9, 3, 4, 5, 1, 5], dtype)\n    expected_shape = [4, 3]\n    expected_counts = [0, 2, 3, 2]\n\n    difference = self._set_difference(sp_a, sp_b, True)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(sp_a, sp_b, True))\n\n    # b - a.\n    expected_indices = [[1, 0], [2, 0], [2, 1]]\n    expected_values = _values([2, 1, 2], dtype)\n    expected_shape = [4, 2]\n    expected_counts = [0, 1, 2, 0]\n\n    difference = self._set_difference(sp_a, sp_b, False)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(sp_a, sp_b, False))\n\n  @test_util.run_deprecated_v1\n  def test_set_difference_duplicates_2d(self):\n    for dtype in _DTYPES:\n      self._test_set_difference_duplicates_2d(dtype)\n\n  def _test_set_difference_duplicates_2d(self, dtype):\n    a_values = [[1, 1, 3]]\n    b_values = [[1, 2, 2]]\n\n    # a - b.\n    expected_indices = [[0, 0]]\n    expected_values = _values([3], dtype)\n    expected_shape = [1, 1]\n    expected_counts = [1]\n\n    # Dense to sparse.\n    a = _constant(a_values, dtype=dtype)\n    sp_b = _dense_to_sparse(b_values, dtype=dtype)\n    difference = self._set_difference(a, sp_b, True)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(a, sp_b, True))\n\n    # Sparse to sparse.\n    sp_a = _dense_to_sparse(a_values, dtype=dtype)\n    difference = self._set_difference(sp_a, sp_b, True)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(a, sp_b, True))\n\n    # b - a.\n    expected_indices = [[0, 0]]\n    expected_values = _values([2], dtype)\n    expected_shape = [1, 1]\n    expected_counts = [1]\n\n    # Dense to sparse.\n    difference = self._set_difference(a, sp_b, False)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(a, sp_b, False))\n\n    # Sparse to sparse.\n    difference = self._set_difference(sp_a, sp_b, False)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(a, sp_b, False))\n\n  @test_util.run_deprecated_v1\n  def test_sparse_set_difference_3d(self):\n    for dtype in _DTYPES:\n      self._test_sparse_set_difference_3d(dtype)\n\n  def test_sparse_set_difference_3d_invalid_indices(self):\n    for dtype in _DTYPES:\n      self._test_sparse_set_difference_3d(dtype, invalid_indices=True)\n\n  def _test_sparse_set_difference_3d(self, dtype, invalid_indices=False):\n    if invalid_indices:\n      indices = constant_op.constant(\n          [\n              [0, 1, 0],\n              [0, 1, 1],  # 0,1\n              [1, 0, 0],  # 1,0\n              [1, 1, 0],\n              [1, 1, 1],\n              [1, 1, 2],  # 1,1\n              [0, 0, 0],\n              [0, 0, 2],  # 0,0\n              # 2,0\n              [2, 1, 1]  # 2,1\n              # 3,*\n          ],\n          dtypes.int64)\n    else:\n      indices = constant_op.constant(\n          [\n              [0, 0, 0],\n              [0, 0, 2],  # 0,0\n              [0, 1, 0],\n              [0, 1, 1],  # 0,1\n              [1, 0, 0],  # 1,0\n              [1, 1, 0],\n              [1, 1, 1],\n              [1, 1, 2],  # 1,1\n              # 2,0\n              [2, 1, 1]  # 2,1\n              # 3,*\n          ],\n          dtypes.int64)\n    sp_a = sparse_tensor_lib.SparseTensor(\n        indices,\n        _constant(\n            [\n                1,\n                9,  # 0,0\n                3,\n                3,  # 0,1\n                1,  # 1,0\n                9,\n                7,\n                8,  # 1,1\n                # 2,0\n                5  # 2,1\n                # 3,*\n            ],\n            dtype),\n        constant_op.constant([4, 2, 3], dtypes.int64))\n    sp_b = sparse_tensor_lib.SparseTensor(\n        constant_op.constant(\n            [\n                [0, 0, 0],\n                [0, 0, 3],  # 0,0\n                # 0,1\n                [1, 0, 0],  # 1,0\n                [1, 1, 0],\n                [1, 1, 1],  # 1,1\n                [2, 0, 1],  # 2,0\n                [2, 1, 1],  # 2,1\n                [3, 0, 0],  # 3,0\n                [3, 1, 0]  # 3,1\n            ],\n            dtypes.int64),\n        _constant(\n            [\n                1,\n                3,  # 0,0\n                # 0,1\n                3,  # 1,0\n                7,\n                8,  # 1,1\n                2,  # 2,0\n                5,  # 2,1\n                4,  # 3,0\n                4  # 3,1\n            ],\n            dtype),\n        constant_op.constant([4, 2, 4], dtypes.int64))\n\n    if invalid_indices:\n      with self.assertRaisesRegex(errors_impl.OpError, \"out of order\"):\n        self._set_difference(sp_a, sp_b, False)\n      with self.assertRaisesRegex(errors_impl.OpError, \"out of order\"):\n        self._set_difference(sp_a, sp_b, True)\n    else:\n      # a-b\n      expected_indices = [\n          [0, 0, 0],  # 0,0\n          [0, 1, 0],  # 0,1\n          [1, 0, 0],  # 1,0\n          [1, 1, 0],  # 1,1\n          # 2,*\n          # 3,*\n      ]\n      expected_values = _values(\n          [\n              9,  # 0,0\n              3,  # 0,1\n              1,  # 1,0\n              9,  # 1,1\n              # 2,*\n              # 3,*\n          ],\n          dtype)\n      expected_shape = [4, 2, 1]\n      expected_counts = [\n          [\n              1,  # 0,0\n              1  # 0,1\n          ],\n          [\n              1,  # 1,0\n              1  # 1,1\n          ],\n          [\n              0,  # 2,0\n              0  # 2,1\n          ],\n          [\n              0,  # 3,0\n              0  # 3,1\n          ]\n      ]\n\n      difference = self._set_difference(sp_a, sp_b, True)\n      self._assert_set_operation(\n          expected_indices,\n          expected_values,\n          expected_shape,\n          difference,\n          dtype=dtype)\n      self.assertAllEqual(expected_counts,\n                          self._set_difference_count(sp_a, sp_b))\n\n      # b-a\n      expected_indices = [\n          [0, 0, 0],  # 0,0\n          # 0,1\n          [1, 0, 0],  # 1,0\n          # 1,1\n          [2, 0, 0],  # 2,0\n          # 2,1\n          [3, 0, 0],  # 3,0\n          [3, 1, 0]  # 3,1\n      ]\n      expected_values = _values(\n          [\n              3,  # 0,0\n              # 0,1\n              3,  # 1,0\n              # 1,1\n              2,  # 2,0\n              # 2,1\n              4,  # 3,0\n              4,  # 3,1\n          ],\n          dtype)\n      expected_shape = [4, 2, 1]\n      expected_counts = [\n          [\n              1,  # 0,0\n              0  # 0,1\n          ],\n          [\n              1,  # 1,0\n              0  # 1,1\n          ],\n          [\n              1,  # 2,0\n              0  # 2,1\n          ],\n          [\n              1,  # 3,0\n              1  # 3,1\n          ]\n      ]\n\n      difference = self._set_difference(sp_a, sp_b, False)\n      self._assert_set_operation(\n          expected_indices,\n          expected_values,\n          expected_shape,\n          difference,\n          dtype=dtype)\n      self.assertAllEqual(expected_counts,\n                          self._set_difference_count(sp_a, sp_b, False))\n\n  def _set_difference(self, a, b, aminusb=True):\n    # Validate that we get the same results with or without `validate_indices`,\n    # and with a & b swapped.\n    ops = (\n        sets.set_difference(\n            a, b, aminusb=aminusb, validate_indices=True),\n        sets.set_difference(\n            a, b, aminusb=aminusb, validate_indices=False),\n        sets.set_difference(\n            b, a, aminusb=not aminusb, validate_indices=True),\n        sets.set_difference(\n            b, a, aminusb=not aminusb, validate_indices=False),)\n    for op in ops:\n      self._assert_static_shapes(a, op)\n    return self._run_equivalent_set_ops(ops)\n\n  def _set_difference_count(self, a, b, aminusb=True):\n    op = sets.set_size(sets.set_difference(a, b, aminusb))\n    with self.cached_session() as sess:\n      return self.evaluate(op)\n\n  @test_util.run_deprecated_v1\n  def test_set_union_multirow_2d(self):\n    for dtype in _DTYPES:\n      self._test_set_union_multirow_2d(dtype)\n\n  def _test_set_union_multirow_2d(self, dtype):\n    a_values = [[9, 1, 5], [2, 4, 3]]\n    b_values = [[1, 9], [1]]\n    expected_indices = [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [1, 3]]\n    expected_values = _values([1, 5, 9, 1, 2, 3, 4], dtype)\n    expected_shape = [2, 4]\n    expected_counts = [3, 4]\n\n    # Dense to sparse.\n    a = _constant(a_values, dtype=dtype)\n    sp_b = _dense_to_sparse(b_values, dtype=dtype)\n    union = self._set_union(a, sp_b)\n    self._assert_set_operation(\n        expected_indices, expected_values, expected_shape, union, dtype=dtype)\n    self.assertAllEqual(expected_counts, self._set_union_count(a, sp_b))\n\n    # Sparse to sparse.\n    sp_a = _dense_to_sparse(a_values, dtype=dtype)\n    union = self._set_union(sp_a, sp_b)\n    self._assert_set_operation(\n        expected_indices, expected_values, expected_shape, union, dtype=dtype)\n    self.assertAllEqual(expected_counts, self._set_union_count(sp_a, sp_b))\n\n  @test_util.run_deprecated_v1\n  def test_dense_set_union_multirow_2d(self):\n    for dtype in _DTYPES:\n      self._test_dense_set_union_multirow_2d(dtype)\n\n  def _test_dense_set_union_multirow_2d(self, dtype):\n    a_values = [[9, 1, 5], [2, 4, 3]]\n    b_values = [[1, 9], [1, 2]]\n    expected_indices = [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [1, 3]]\n    expected_values = _values([1, 5, 9, 1, 2, 3, 4], dtype)\n    expected_shape = [2, 4]\n    expected_counts = [3, 4]\n\n    # Dense to dense.\n    a = _constant(a_values, dtype=dtype)\n    b = _constant(b_values, dtype=dtype)\n    union = self._set_union(a, b)\n    self._assert_set_operation(\n        expected_indices, expected_values, expected_shape, union, dtype=dtype)\n    self.assertAllEqual(expected_counts, self._set_union_count(a, b))\n\n  @test_util.run_deprecated_v1\n  def test_set_union_duplicates_2d(self):\n    for dtype in _DTYPES:\n      self._test_set_union_duplicates_2d(dtype)\n\n  def _test_set_union_duplicates_2d(self, dtype):\n    a_values = [[1, 1, 3]]\n    b_values = [[1]]\n    expected_indices = [[0, 0], [0, 1]]\n    expected_values = _values([1, 3], dtype)\n    expected_shape = [1, 2]\n\n    # Dense to sparse.\n    a = _constant(a_values, dtype=dtype)\n    sp_b = _dense_to_sparse(b_values, dtype=dtype)\n    union = self._set_union(a, sp_b)\n    self._assert_set_operation(\n        expected_indices, expected_values, expected_shape, union, dtype=dtype)\n    self.assertAllEqual([2], self._set_union_count(a, sp_b))\n\n    # Sparse to sparse.\n    sp_a = _dense_to_sparse(a_values, dtype=dtype)\n    union = self._set_union(sp_a, sp_b)\n    self._assert_set_operation(\n        expected_indices, expected_values, expected_shape, union, dtype=dtype)\n    self.assertAllEqual([2], self._set_union_count(sp_a, sp_b))\n\n  @test_util.run_deprecated_v1\n  def test_sparse_set_union_3d(self):\n    for dtype in _DTYPES:\n      self._test_sparse_set_union_3d(dtype)\n\n  def test_sparse_set_union_3d_invalid_indices(self):\n    for dtype in _DTYPES:\n      self._test_sparse_set_union_3d(dtype, invalid_indices=True)\n\n  def _test_sparse_set_union_3d(self, dtype, invalid_indices=False):\n    if invalid_indices:\n      indices = constant_op.constant(\n          [\n              [0, 1, 0],\n              [0, 1, 1],  # 0,1\n              [1, 0, 0],  # 1,0\n              [0, 0, 0],\n              [0, 0, 2],  # 0,0\n              [1, 1, 0],\n              [1, 1, 1],\n              [1, 1, 2],  # 1,1\n              # 2,0\n              [2, 1, 1]  # 2,1\n              # 3,*\n          ],\n          dtypes.int64)\n    else:\n      indices = constant_op.constant(\n          [\n              [0, 0, 0],\n              [0, 0, 2],  # 0,0\n              [0, 1, 0],\n              [0, 1, 1],  # 0,1\n              [1, 0, 0],  # 1,0\n              [1, 1, 0],\n              [1, 1, 1],\n              [1, 1, 2],  # 1,1\n              # 2,0\n              [2, 1, 1]  # 2,1\n              # 3,*\n          ],\n          dtypes.int64)\n    sp_a = sparse_tensor_lib.SparseTensor(\n        indices,\n        _constant(\n            [\n                1,\n                9,  # 0,0\n                3,\n                3,  # 0,1\n                1,  # 1,0\n                9,\n                7,\n                8,  # 1,1\n                # 2,0\n                5  # 2,1\n                # 3,*\n            ],\n            dtype),\n        constant_op.constant([4, 2, 3], dtypes.int64))\n    sp_b = sparse_tensor_lib.SparseTensor(\n        constant_op.constant(\n            [\n                [0, 0, 0],\n                [0, 0, 3],  # 0,0\n                # 0,1\n                [1, 0, 0],  # 1,0\n                [1, 1, 0],\n                [1, 1, 1],  # 1,1\n                [2, 0, 1],  # 2,0\n                [2, 1, 1],  # 2,1\n                [3, 0, 0],  # 3,0\n                [3, 1, 0]  # 3,1\n            ],\n            dtypes.int64),\n        _constant(\n            [\n                1,\n                3,  # 0,0\n                # 0,1\n                3,  # 1,0\n                7,\n                8,  # 1,1\n                2,  # 2,0\n                5,  # 2,1\n                4,  # 3,0\n                4  # 3,1\n            ],\n            dtype),\n        constant_op.constant([4, 2, 4], dtypes.int64))\n\n    if invalid_indices:\n      with self.assertRaisesRegex(errors_impl.OpError, \"out of order\"):\n        self._set_union(sp_a, sp_b)\n    else:\n      expected_indices = [\n          [0, 0, 0],\n          [0, 0, 1],\n          [0, 0, 2],  # 0,0\n          [0, 1, 0],  # 0,1\n          [1, 0, 0],\n          [1, 0, 1],  # 1,0\n          [1, 1, 0],\n          [1, 1, 1],\n          [1, 1, 2],  # 1,1\n          [2, 0, 0],  # 2,0\n          [2, 1, 0],  # 2,1\n          [3, 0, 0],  # 3,0\n          [3, 1, 0],  # 3,1\n      ]\n      expected_values = _values(\n          [\n              1,\n              3,\n              9,  # 0,0\n              3,  # 0,1\n              1,\n              3,  # 1,0\n              7,\n              8,\n              9,  # 1,1\n              2,  # 2,0\n              5,  # 2,1\n              4,  # 3,0\n              4,  # 3,1\n          ],\n          dtype)\n      expected_shape = [4, 2, 3]\n      expected_counts = [\n          [\n              3,  # 0,0\n              1  # 0,1\n          ],\n          [\n              2,  # 1,0\n              3  # 1,1\n          ],\n          [\n              1,  # 2,0\n              1  # 2,1\n          ],\n          [\n              1,  # 3,0\n              1  # 3,1\n          ]\n      ]\n\n      intersection = self._set_union(sp_a, sp_b)\n      self._assert_set_operation(\n          expected_indices,\n          expected_values,\n          expected_shape,\n          intersection,\n          dtype=dtype)\n      self.assertAllEqual(expected_counts, self._set_union_count(sp_a, sp_b))\n\n  def _set_union(self, a, b):\n    # Validate that we get the same results with or without `validate_indices`,\n    # and with a & b swapped.\n    ops = (\n        sets.set_union(\n            a, b, validate_indices=True),\n        sets.set_union(\n            a, b, validate_indices=False),\n        sets.set_union(\n            b, a, validate_indices=True),\n        sets.set_union(\n            b, a, validate_indices=False),)\n    for op in ops:\n      self._assert_static_shapes(a, op)\n    return self._run_equivalent_set_ops(ops)\n\n  def _set_union_count(self, a, b):\n    op = sets.set_size(sets.set_union(a, b))\n    with self.cached_session() as sess:\n      return self.evaluate(op)\n\n  def _assert_set_operation(self, expected_indices, expected_values,\n                            expected_shape, sparse_tensor_value, dtype):\n    self.assertAllEqual(expected_indices, sparse_tensor_value.indices)\n    self.assertAllEqual(len(expected_indices), len(expected_values))\n    self.assertAllEqual(len(expected_values), len(sparse_tensor_value.values))\n    expected_set = set()\n    actual_set = set()\n    last_indices = None\n    for indices, expected_value, actual_value in zip(\n        expected_indices, expected_values, sparse_tensor_value.values):\n      if dtype == dtypes.string:\n        actual_value = actual_value.decode(\"utf-8\")\n      if last_indices and (last_indices[:-1] != indices[:-1]):\n        self.assertEqual(\n            expected_set, actual_set,\n            \"Expected %s, got %s, at %s.\" % (expected_set, actual_set, indices))\n        expected_set.clear()\n        actual_set.clear()\n      expected_set.add(expected_value)\n      actual_set.add(actual_value)\n      last_indices = indices\n    self.assertEqual(\n        expected_set, actual_set, \"Expected %s, got %s, at %s.\" %\n        (expected_set, actual_set, last_indices))\n    self.assertAllEqual(expected_shape, sparse_tensor_value.dense_shape)\n\n  @parameterized.parameters(*_DTYPES)\n  def test_set_union_output_is_sorted(self, dtype):\n    # We don't use any numbers >= 10 so that lexicographical order agrees with\n    # numeric order in this test, for the type dtype == tf.string.\n\n    # [3 7 5 3 1]\n    # [2 6 5 4]\n    # []\n    # [9 8]\n    sp_a = sparse_tensor_lib.SparseTensor(\n        indices=constant_op.constant(\n            [[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [1, 0], [1, 1], [1, 2],\n             [1, 3], [3, 0], [3, 1]],\n            dtype=dtypes.int64),\n        values=_constant([3, 7, 5, 3, 1, 2, 6, 5, 4, 9, 8], dtype),\n        dense_shape=constant_op.constant([4, 5], dtype=dtypes.int64))\n\n    # [9 7]\n    # [5 2 0]\n    # [6]\n    # []\n    sp_b = sparse_tensor_lib.SparseTensor(\n        indices=constant_op.constant(\n            [[0, 0], [0, 1], [1, 0], [1, 1], [1, 2], [2, 0]],\n            dtype=dtypes.int64),\n        values=_constant([9, 7, 5, 2, 0, 6], dtype),\n        dense_shape=constant_op.constant([4, 3], dtype=dtypes.int64))\n    # The union should be\n    # [1 3 5 7 9]\n    # [0 2 4 5 6]\n    # [6]\n    # [8 9]\n    result = sets.set_union(sp_a, sp_b)\n    self.assertAllEqual(result.dense_shape, [4, 5])\n    self.assertAllEqual(result.indices,\n                        [[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [1, 0], [1, 1],\n                         [1, 2], [1, 3], [1, 4], [2, 0], [3, 0], [3, 1]])\n    self.assertAllEqual(\n        result.values,\n        _constant([1, 3, 5, 7, 9, 0, 2, 4, 5, 6, 6, 8, 9], dtype))\n\n\nif __name__ == \"__main__\":\n  googletest.main()\n"], "fixing_code": ["/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// Ops for operating with sets. They are not checked in\n// to TensorFlow because we would first like to demonstrate successful\n// end-to-end use of these ops in eval and polish the api a bit like taking two\n// SparseTensor rather than on edense and one sparse.\n\n#define EIGEN_USE_THREADS\n\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <utility>\n#include <vector>\n\n#include \"absl/container/btree_set.h\"\n#include \"absl/container/flat_hash_set.h\"\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_util.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/lib/core/status.h\"\n#include \"tensorflow/core/platform/env.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/util/sparse/sparse_tensor.h\"\n\nnamespace tensorflow {\n\nusing ShapeArray = sparse::SparseTensor::ShapeArray;\nusing VarDimArray = sparse::SparseTensor::VarDimArray;\n\n// Validate rank >= 2.\nvoid CheckRankAtLeast2(OpKernelContext* ctx, const TensorShape& shape) {\n  const auto rank = shape.dims();\n  OP_REQUIRES(ctx, rank >= 2,\n              errors::InvalidArgument(\"Invalid rank \", rank, \".\"));\n}\n\n// Return group shape, which is the 1st n-1 dimensions of shape.\nStatus GroupShape(const VarDimArray& input_shape, ShapeArray* grouped_shape) {\n  if (input_shape.size() < 2) {\n    // TODO(irving): Why can't 2 be 1 here?\n    return errors::InvalidArgument(\"Shape [\", absl::StrJoin(input_shape, \",\"),\n                                   \"] has rank \", input_shape.size(), \" < 2\");\n  }\n  // grouped_shape is input_shape[:-1]\n  *grouped_shape = ShapeArray(input_shape.begin(), input_shape.end() - 1);\n  return OkStatus();\n}\n\n// Build `SparseTensor` from indices, values, and shape in inputs\n// [base_index, base_index + 3), and validate its rank and indices.\nStatus SparseTensorFromContext(OpKernelContext* ctx, const int32_t base_index,\n                               const bool validate_indices,\n                               sparse::SparseTensor* tensor) {\n  // Assume row-major order.\n  TensorShape shape;\n  const Tensor& shape_tensor = ctx->input(base_index + 2);\n  if (shape_tensor.dims() != 1) {\n    return errors::InvalidArgument(\"Shape must be a 1D tensor.\");\n  }\n  TF_RETURN_IF_ERROR(\n      TensorShape::BuildTensorShape(shape_tensor.vec<int64_t>(), &shape));\n  CheckRankAtLeast2(ctx, shape);\n  std::vector<int64_t> order(shape.dims());\n  std::iota(order.begin(), order.end(), 0);\n\n  Status status = sparse::SparseTensor::Create(\n      ctx->input(base_index), ctx->input(base_index + 1), shape, order, tensor);\n\n  if (!validate_indices || !status.ok()) return status;\n  return tensor->IndicesValid();\n}\n\n// TODO(ptucker): CheckGroup is just a sanity check on the result of\n// SparseTensor.group, consider removing.\n// `sparse_tensor_shape` is the shape of the `SparseTensor` from which group\n// was created, and is used to sanity check the indices in `group'.\ntemplate <typename T>\nvoid CheckGroup(OpKernelContext* ctx, const sparse::Group& group,\n                const VarDimArray& sparse_tensor_shape) {\n  const auto& indices = group.indices();\n  const auto& values = group.values<T>();\n\n  // Sanity check: group is non-empty, and indices and values are same size.\n  const auto num_values = values.dimension(0);\n  OP_REQUIRES(ctx, indices.size() > 0, errors::Internal(\"Empty group.\"));\n  OP_REQUIRES(\n      ctx, indices.dimension(0) == num_values,\n      errors::Internal(\"shape[0] of group indices \", indices.dimension(0),\n                       \" != values \", num_values, \".\"));\n\n  // Sanity check: valid indices.\n  const auto group_rank = indices.dimension(1);\n  const auto expected_rank = sparse_tensor_shape.size();\n  OP_REQUIRES(ctx, expected_rank == group_rank,\n              errors::Internal(\"Rank expected \", expected_rank, \", got \",\n                               group_rank, \".\"));\n  for (int32_t j = 0; j < expected_rank; ++j) {\n    const auto dim_size = sparse_tensor_shape[j];\n    OP_REQUIRES(\n        ctx, dim_size > 0,\n        errors::Internal(\"Invalid dim_size[\", j, \"] = \", dim_size, \".\"));\n    for (int64_t i = 0; i < num_values; ++i) {\n      const auto index = indices(i, j);\n      OP_REQUIRES(ctx, dim_size > index,\n                  errors::Internal(\"indices[\", i, \", \", j, \"] expected < \",\n                                   dim_size, \", got \", index, \".\"));\n    }\n  }\n}\n\n// This lets us calculate the row-major index into flattened output.\nconst ShapeArray Strides(const VarDimArray& shape) {\n  ShapeArray result(shape.size());\n  int64_t product = 1;\n  for (int i = shape.size() - 1; i >= 0; --i) {\n    result[i] = product;\n    product *= shape[i];\n  }\n  return result;\n}\n\n// TODO(ptucker): If memory becomes an issue, consider a 2-pass approach to\n// eliminate the intermediate `values` data structure - iterate once to\n// determine `num_values`, allocate output tensors, then write results directly\n// to output tensors.\n\n// TODO(ptucker): Consider sharding work across multiple threads. See\n// SparseCrossOp for an example.\n\n// Output `SparseTensor` of shape `output_shape`. `sets` contains pairs of\n// group indices (i.e., values for all but the last dimension of `output_shape`)\n// and set values, each of which will occupy the last dimension of\n// `output_shape`. `sets` should be sorted in ascending order by group indices.\ntemplate <typename T>\nvoid OutputSparseTensor(\n    OpKernelContext* ctx, const TensorShape& output_shape,\n    const int64_t num_values,\n    const std::vector<std::pair<std::vector<int64_t>, absl::btree_set<T>>>&\n        sets) {\n  // Allocate 3 output tensors for sparse data.\n  Tensor *out_indices_t, *out_values_t, *out_shape_t;\n  OP_REQUIRES_OK(ctx, ctx->allocate_output(\n                          0, TensorShape({num_values, output_shape.dims()}),\n                          &out_indices_t));\n  OP_REQUIRES_OK(\n      ctx, ctx->allocate_output(1, TensorShape({num_values}), &out_values_t));\n  OP_REQUIRES_OK(ctx, ctx->allocate_output(\n                          2, TensorShape({output_shape.dims()}), &out_shape_t));\n  auto out_indices_mat = out_indices_t->matrix<int64_t>();\n  auto out_values_flat = out_values_t->vec<T>();\n\n  // For each set, write its indices and values to output tensors.\n  int64_t value_index = 0;\n  for (auto it = sets.begin(); it != sets.end(); ++it) {\n    const auto& group_indices = it->first;\n    OP_REQUIRES(\n        ctx, group_indices.size() == output_shape.dims() - 1,\n        errors::Internal(\"Invalid number of indices \", group_indices.size(),\n                         \", expected \", output_shape.dims() - 1, \".\"));\n    const auto& set = it->second;\n\n    // For each set item, write its indices and value to output tensors.\n    int64_t group_value_index = 0;\n    for (auto value = set.begin(); value != set.end();\n         ++value, ++value_index, ++group_value_index) {\n      // First n-1 dimensions are the group, last dimension is the position in\n      // the set.\n      for (int32_t i = 0; i < group_indices.size(); ++i) {\n        out_indices_mat(value_index, i) = group_indices[i];\n      }\n      out_indices_mat(value_index, group_indices.size()) = group_value_index;\n\n      out_values_flat(value_index) = *value;\n    }\n  }\n\n  // Write output shape.\n  auto out_shape_flat = out_shape_t->vec<int64_t>();\n  for (int32_t i = 0; i < output_shape.dims(); ++i) {\n    out_shape_flat(i) = output_shape.dim_size(i);\n  }\n}\n\nbool ValidateIndicesFromContext(OpKernelConstruction* ctx) {\n  bool result;\n  if (ctx->GetAttr(\"validate_indices\", &result).ok()) {\n    return result;\n  }\n  return true;\n}\n\n// Populate `result` set from group in `tensor`. \"Group\" is defined by\n// `group_indices`, which are values for the first n-1 dimensions of\n// `input_tensor`. `input_strides` is provided to avoid recalculating it\n// multiple times, and is used to calculate the flat index into `input_tensor`\n// values.\ntemplate <typename T>\nvoid PopulateFromDenseGroup(OpKernelContext* ctx, const Tensor& input_tensor,\n                            const VarDimArray& input_strides,\n                            const std::vector<int64_t>& group_indices,\n                            absl::flat_hash_set<T>* result) {\n  OP_REQUIRES(ctx, group_indices.size() == input_strides.size() - 1,\n              errors::Internal(\"group_indices.size \", group_indices.size(),\n                               \", !=  input_strides.size-1 \",\n                               input_strides.size() - 1, \".\"));\n  result->clear();\n  auto input_flat = input_tensor.flat<T>();\n  const auto start = std::inner_product(\n      group_indices.begin(), group_indices.end(), input_strides.begin(), 0LL);\n  const TensorShape& input_shape = input_tensor.shape();\n  const auto end = start + input_shape.dim_size(input_shape.dims() - 1);\n  for (int64_t i = start; i < end; ++i) {\n    result->insert(input_flat(i));\n  }\n}\n\n// Populate `result` set from `group`. `sparse_tensor_shape` is the shape of the\n// `SparseTensor` from which group was created, and is used to sanity check the\n// indices in `group'.\ntemplate <typename T>\nvoid PopulateFromSparseGroup(OpKernelContext* ctx, const sparse::Group& group,\n                             const VarDimArray& sparse_tensor_shape,\n                             absl::flat_hash_set<T>* result) {\n  CheckGroup<T>(ctx, group, sparse_tensor_shape);\n  result->clear();\n  const auto& group_values = group.values<T>();\n  for (int64_t i = 0; i < group_values.size(); ++i) {\n    result->insert(group_values(i));\n  }\n}\n\ntemplate <typename T>\nclass SetSizeOp : public OpKernel {\n public:\n  explicit SetSizeOp(OpKernelConstruction* ctx)\n      : OpKernel(ctx), validate_indices_(ValidateIndicesFromContext(ctx)) {}\n\n  void Compute(OpKernelContext* ctx) override;\n\n private:\n  const bool validate_indices_;\n};\n\ntemplate <typename T>\nvoid SetSizeOp<T>::Compute(OpKernelContext* ctx) {\n  sparse::SparseTensor set_st;\n  OP_REQUIRES_OK(ctx,\n                 SparseTensorFromContext(ctx, 0, validate_indices_, &set_st));\n\n  // Output shape is same as input except for last dimension, which reduces\n  // to the set size of values along that dimension.\n  ShapeArray output_shape;\n  OP_REQUIRES_OK(ctx, GroupShape(set_st.shape(), &output_shape));\n  const auto output_strides = Strides(output_shape);\n\n  TensorShape output_shape_ts;\n  OP_REQUIRES_OK(ctx,\n                 TensorShapeUtils::MakeShape(output_shape, &output_shape_ts));\n  Tensor* out_t;\n  OP_REQUIRES_OK(ctx, ctx->allocate_output(0, output_shape_ts, &out_t));\n  auto out = out_t->flat<int32>();\n  out.device(ctx->eigen_cpu_device()) = out.constant(static_cast<int32>(0.0));\n\n  // Group by all but last dimension, create a set of group values, and add set\n  // size to output.\n  VarDimArray group_ix = set_st.order().subspan(0, set_st.order().size() - 1);\n  absl::flat_hash_set<T> group_set;\n  for (const auto& group : set_st.group(group_ix)) {\n    PopulateFromSparseGroup<T>(ctx, group, set_st.shape(), &group_set);\n\n    const auto group_key = group.group();\n    const auto output_index = std::inner_product(\n        group_key.begin(), group_key.end(), output_strides.begin(), 0LL);\n    out(output_index) = group_set.size();\n  }\n}\n\n#define _SET_SIZE_REGISTER_KERNEL_BUILDER(T)                     \\\n  REGISTER_KERNEL_BUILDER(                                       \\\n      Name(\"SetSize\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      SetSizeOp<T>);\n_SET_SIZE_REGISTER_KERNEL_BUILDER(int8);\n_SET_SIZE_REGISTER_KERNEL_BUILDER(int16);\n_SET_SIZE_REGISTER_KERNEL_BUILDER(int32);\n_SET_SIZE_REGISTER_KERNEL_BUILDER(int64_t);\n_SET_SIZE_REGISTER_KERNEL_BUILDER(uint8);\n_SET_SIZE_REGISTER_KERNEL_BUILDER(uint16);\n_SET_SIZE_REGISTER_KERNEL_BUILDER(tstring);\n#undef _SET_SIZE_REGISTER_KERNEL_BUILDER\n\nenum InputTypes {\n  DENSE_DENSE = 0,\n  DENSE_SPARSE = 1,\n  SPARSE_SPARSE = 2,\n};\n\nenum SetOperation { A_MINUS_B = 0, B_MINUS_A = 1, INTERSECTION = 2, UNION = 3 };\n\nSetOperation SetOperationFromContext(OpKernelConstruction* ctx) {\n  string set_operation_str;\n  if (!ctx->GetAttr(\"set_operation\", &set_operation_str).ok()) {\n    ctx->CtxFailure(errors::InvalidArgument(\"Missing set_operation.\"));\n  } else {\n    std::transform(set_operation_str.begin(), set_operation_str.end(),\n                   set_operation_str.begin(), ::tolower);\n    if (\"a-b\" == set_operation_str) {\n      return A_MINUS_B;\n    }\n    if (\"b-a\" == set_operation_str) {\n      return B_MINUS_A;\n    }\n    if (\"intersection\" == set_operation_str) {\n      return INTERSECTION;\n    }\n    if (\"union\" != set_operation_str) {\n      ctx->CtxFailure(errors::InvalidArgument(\"Invalid set_operation \",\n                                              set_operation_str, \".\"));\n    }\n  }\n  // NOTE: This is not the default, this function fails if no 'set_operation'\n  // attribute is provided.\n  return UNION;\n}\n\n// Abstract base class for performing set operations across the last dimension\n// of 2 input tensors.\ntemplate <typename T>\nclass SetOperationOp : public OpKernel {\n public:\n  SetOperationOp(OpKernelConstruction* ctx, InputTypes input_types)\n      : OpKernel(ctx),\n        set_operation_(SetOperationFromContext(ctx)),\n        validate_indices_(ValidateIndicesFromContext(ctx)),\n        input_types_(input_types) {}\n\n  void Compute(OpKernelContext* ctx) override;\n\n private:\n  void ApplySetOperation(const absl::flat_hash_set<T>& set1,\n                         const absl::flat_hash_set<T>& set2,\n                         absl::btree_set<T>* result) const;\n  void ComputeDenseToDense(OpKernelContext* ctx) const;\n  void ComputeDenseToSparse(OpKernelContext* ctx) const;\n  void ComputeSparseToSparse(OpKernelContext* ctx) const;\n  const SetOperation set_operation_;\n  const bool validate_indices_;\n  const InputTypes input_types_;\n};\n\ntemplate <typename T>\nvoid SetDifference(const absl::flat_hash_set<T>& set1,\n                   const absl::flat_hash_set<T>& set2,\n                   absl::btree_set<T>* result) {\n  for (const T& elem : set1) {\n    if (!set2.contains(elem)) result->insert(elem);\n  }\n}\n\ntemplate <typename T>\nvoid SetIntersection(const absl::flat_hash_set<T>& set1,\n                     const absl::flat_hash_set<T>& set2,\n                     absl::btree_set<T>* result) {\n  if (set1.size() <= set2.size()) {\n    for (const T& elem : set1) {\n      if (set2.contains(elem)) result->insert(elem);\n    }\n  } else {\n    for (const T& elem : set2) {\n      if (set1.contains(elem)) result->insert(elem);\n    }\n  }\n}\n\ntemplate <typename T>\nvoid SetUnion(const absl::flat_hash_set<T>& set1,\n              const absl::flat_hash_set<T>& set2, absl::btree_set<T>* result) {\n  result->insert(set1.begin(), set1.end());\n  result->insert(set2.begin(), set2.end());\n}\n\ntemplate <typename T>\nvoid SetOperationOp<T>::ApplySetOperation(const absl::flat_hash_set<T>& set1,\n                                          const absl::flat_hash_set<T>& set2,\n                                          absl::btree_set<T>* result) const {\n  switch (set_operation_) {\n    case A_MINUS_B:\n      SetDifference<T>(set1, set2, result);\n      break;\n    case B_MINUS_A:\n      SetDifference<T>(set2, set1, result);\n      break;\n    case INTERSECTION:\n      SetIntersection<T>(set1, set2, result);\n      break;\n    case UNION:\n      SetUnion<T>(set1, set2, result);\n      break;\n  }\n}\n\n// Validate shapes have the same dimensions.\nStatus CheckShapesMatch(VarDimArray shape1, VarDimArray shape2) {\n  if (shape1 != shape2) {\n    return errors::InvalidArgument(\"Mismatched shapes [\",\n                                   absl::StrJoin(shape1, \",\"), \"] vs [\",\n                                   absl::StrJoin(shape2, \",\"), \"]\");\n  }\n  return OkStatus();\n}\n\n// Validate ranks are the same, and all but last dimension are the same.\n// Return GroupShape.\nStatus GroupShapeFromInputs(VarDimArray shape1, VarDimArray shape2,\n                            ShapeArray* group_shape) {\n  ShapeArray group_shape_1;\n  TF_RETURN_IF_ERROR(GroupShape(shape1, &group_shape_1));\n  ShapeArray group_shape_2;\n  TF_RETURN_IF_ERROR(GroupShape(shape2, &group_shape_2));\n  TF_RETURN_IF_ERROR(CheckShapesMatch(group_shape_1, group_shape_2));\n  *group_shape = group_shape_1;\n  return OkStatus();\n}\n\n// Split `flat_group_index` into separate dimensions based on `group_shape`.\nvoid PopulateGroupIndices(const int64_t flat_group_index,\n                          VarDimArray group_shape,\n                          std::vector<int64_t>* group_indices) {\n  group_indices->clear();\n  int64_t running_flat_group_index = flat_group_index;\n  for (int group_dim_index = group_shape.size() - 1; group_dim_index >= 0;\n       --group_dim_index) {\n    const auto group_dim = group_shape[group_dim_index];\n    group_indices->insert(group_indices->begin(),\n                          running_flat_group_index % group_dim);\n    running_flat_group_index /= group_dim;\n  }\n}\n\nShapeArray TensorShapeToArray(const TensorShape& t) {\n  ShapeArray vec(t.dims());\n  for (int i = 0; i < t.dims(); ++i) vec[i] = t.dim_size(i);\n  return vec;\n}\n\n// `ctx` contains set1 and set2 dense tensors.\n// Iterate over groups in set1 and set2, applying `ApplySetOperation` to each,\n// and outputting the result `SparseTensor`. A \"group\" is a collection of values\n// with the same first n-1 dimensions in set1 and set2.\ntemplate <typename T>\nvoid SetOperationOp<T>::ComputeDenseToDense(OpKernelContext* ctx) const {\n  const Tensor& set1_t = ctx->input(0);\n  const Tensor& set2_t = ctx->input(1);\n  // The following should stay in sync with `_dense_to_dense_shape` shape\n  // assertions in python/ops/set_ops.py, and `SetShapeFn` for\n  // `DenseToDenseSetOperation` in ops/set_ops.cc.\n  ShapeArray group_shape;\n  const auto shape1 = TensorShapeToArray(set1_t.shape());\n  const auto shape2 = TensorShapeToArray(set2_t.shape());\n  OP_REQUIRES_OK(ctx, GroupShapeFromInputs(shape1, shape2, &group_shape));\n\n  const auto set1_strides = Strides(shape1);\n  const auto set2_strides = Strides(shape2);\n\n  std::vector<std::pair<std::vector<int64_t>, absl::btree_set<T>>> group_sets;\n  int64_t num_result_values = 0;\n  int64_t max_set_size = 0;\n\n  absl::flat_hash_set<T> set1_group_set;\n  absl::flat_hash_set<T> set2_group_set;\n  std::vector<int64_t> group_indices;\n  int64_t num_elements;\n  OP_REQUIRES_OK(ctx,\n                 TensorShapeUtils::NumElements(group_shape, &num_elements));\n  for (int64_t flat_group_index = 0; flat_group_index < num_elements;\n       ++flat_group_index) {\n    PopulateGroupIndices(flat_group_index, group_shape, &group_indices);\n    PopulateFromDenseGroup<T>(ctx, set1_t, set1_strides, group_indices,\n                              &set1_group_set);\n    PopulateFromDenseGroup<T>(ctx, set2_t, set2_strides, group_indices,\n                              &set2_group_set);\n\n    absl::btree_set<T> group_set;\n    ApplySetOperation(set1_group_set, set2_group_set, &group_set);\n    if (!group_set.empty()) {\n      const auto set_size = group_set.size();\n      if (set_size > max_set_size) {\n        max_set_size = set_size;\n      }\n      num_result_values += set_size;\n      group_sets.push_back({group_indices, std::move(group_set)});\n    }\n  }\n\n  TensorShape output_shape;\n  OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape(group_shape, &output_shape));\n  output_shape.AddDim(max_set_size);\n  OutputSparseTensor<T>(ctx, output_shape, num_result_values, group_sets);\n}\n\n// `ctx` contains dense set1 and sparse set2 tensors.\n// Iterate over groups in set1 and set2, applying `ApplySetOperation` to each,\n// and outputing the result `SparseTensor`. A \"group\" is a collection of values\n// with the same first n-1 dimensions in set1 and set2.\ntemplate <typename T>\nvoid SetOperationOp<T>::ComputeDenseToSparse(OpKernelContext* ctx) const {\n  const Tensor& set1_t = ctx->input(0);\n  sparse::SparseTensor set2_st;\n  OP_REQUIRES_OK(ctx,\n                 SparseTensorFromContext(ctx, 1, validate_indices_, &set2_st));\n  // The following should stay in sync with `_dense_to_sparse_shape` shape\n  // assertions in python/ops/set_ops.py, and `SetShapeFn` for\n  // `DenseToSparseSetOperation` in ops/set_ops.cc.\n  ShapeArray group_shape;\n  OP_REQUIRES_OK(ctx, GroupShapeFromInputs(TensorShapeToArray(set1_t.shape()),\n                                           set2_st.shape(), &group_shape));\n\n  const ShapeArray set1_strides = Strides(TensorShapeToArray(set1_t.shape()));\n\n  std::vector<std::pair<std::vector<int64_t>, absl::btree_set<T>>> group_sets;\n  int64_t num_result_values = 0;\n  int64_t max_set_size = 0;\n\n  absl::flat_hash_set<T> set1_group_set;\n  absl::flat_hash_set<T> set2_group_set;\n  auto set2_grouper =\n      set2_st.group(set2_st.order().subspan(0, set2_st.order().size() - 1));\n  auto set2_group_it = set2_grouper.begin();\n  std::vector<int64_t> group_indices;\n  int64_t num_elements;\n  OP_REQUIRES_OK(ctx,\n                 TensorShapeUtils::NumElements(group_shape, &num_elements));\n  for (int64_t flat_group_index = 0; flat_group_index < num_elements;\n       ++flat_group_index) {\n    PopulateGroupIndices(flat_group_index, group_shape, &group_indices);\n\n    // Get values from set1.\n    PopulateFromDenseGroup<T>(ctx, set1_t, set1_strides, group_indices,\n                              &set1_group_set);\n\n    // Get values from set2, if applicable.\n    set2_group_set.clear();\n    if (set2_group_it != set2_grouper.end()) {\n      const auto& group = *set2_group_it;\n      const auto set2_group_indices = group.group();\n      OP_REQUIRES(\n          ctx, set2_group_indices.size() == group_indices.size(),\n          errors::InvalidArgument(\"Invalid number of group indices \",\n                                  set2_group_indices.size(), \", expected \",\n                                  group_indices.size(), \".\"));\n      bool group_match = true;\n      for (int32_t i = 0; group_match && (i < set2_group_indices.size()); ++i) {\n        if (set2_group_indices[i] != group_indices[i]) {\n          group_match = false;\n        }\n      }\n      if (group_match) {\n        PopulateFromSparseGroup<T>(ctx, group, set2_st.shape(),\n                                   &set2_group_set);\n        ++set2_group_it;\n      }\n    }\n\n    absl::btree_set<T> group_set;\n    ApplySetOperation(set1_group_set, set2_group_set, &group_set);\n    if (!group_set.empty()) {\n      const auto set_size = group_set.size();\n      if (set_size > max_set_size) {\n        max_set_size = set_size;\n      }\n      num_result_values += set_size;\n      group_sets.push_back({group_indices, std::move(group_set)});\n    }\n  }\n\n  TensorShape output_shape;\n  OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape(group_shape, &output_shape));\n  output_shape.AddDim(max_set_size);\n  OutputSparseTensor<T>(ctx, output_shape, num_result_values, group_sets);\n}\n\n// This is used to determine which group iterator is less than the other, based\n// on row-major ordering of indices.\n// An empty index list indicates end of iteration, which is interpreted as \"max\"\n// for the purposes of comparison; i.e., non-empty < empty.\n// Return 0 if both groups are empty, or both non-empty with the same values.\n// Return <0 if set1 <= set2, or set2 is empty.\n// Return >0 if set2 <= set1, or set1 is empty.\nvoid CompareGroups(OpKernelContext* ctx,\n                   const std::vector<int64_t>& set1_group_indices,\n                   const std::vector<int64_t>& set2_group_indices,\n                   int64_t* result) {\n  if (set1_group_indices.empty()) {\n    *result = set2_group_indices.empty() ? 0 : 1;\n    return;\n  }\n  if (set2_group_indices.empty()) {\n    *result = set1_group_indices.empty() ? 0 : -1;\n    return;\n  }\n  OP_REQUIRES(ctx, set1_group_indices.size() == set2_group_indices.size(),\n              errors::InvalidArgument(\"Mismatched group dims \",\n                                      set1_group_indices.size(), \" vs \",\n                                      set2_group_indices.size(), \".\"));\n  for (int32_t i = 0; i < set1_group_indices.size(); ++i) {\n    *result = set1_group_indices[i] - set2_group_indices[i];\n    if (*result != 0) {\n      return;\n    }\n  }\n}\n\n// `ctx` contains set1 and set2 sparse tensors.\n// Iterate over groups in set1 and set2, applying `ApplySetOperation` to each,\n// and outputing the result `SparseTensor`. A \"group\" is a collection of values\n// with the same first n-1 dimensions in set1 and set2.\ntemplate <typename T>\nvoid SetOperationOp<T>::ComputeSparseToSparse(OpKernelContext* ctx) const {\n  sparse::SparseTensor set1_st;\n  OP_REQUIRES_OK(ctx,\n                 SparseTensorFromContext(ctx, 0, validate_indices_, &set1_st));\n\n  sparse::SparseTensor set2_st;\n  OP_REQUIRES_OK(ctx,\n                 SparseTensorFromContext(ctx, 3, validate_indices_, &set2_st));\n\n  // The following should stay in sync with `_sparse_to_sparse_shape` shape\n  // assertions in python/ops/set_ops.py, and `SetShapeFn` for\n  // `SparseToSparseSetOperation` in ops/set_ops.cc.\n  ShapeArray group_shape;\n  OP_REQUIRES_OK(ctx, GroupShapeFromInputs(set1_st.shape(), set2_st.shape(),\n                                           &group_shape));\n\n  std::vector<std::pair<std::vector<int64_t>, absl::btree_set<T>>> group_sets;\n  int64_t num_result_values = 0;\n  int64_t max_set_size = 0;\n\n  absl::flat_hash_set<T> set1_group_set;\n  absl::flat_hash_set<T> set2_group_set;\n  auto set1_grouper =\n      set1_st.group(set1_st.order().subspan(0, set1_st.order().size() - 1));\n  auto set1_group_it = set1_grouper.begin();\n  auto set2_grouper =\n      set2_st.group(set2_st.order().subspan(0, set2_st.order().size() - 1));\n  auto set2_group_it = set2_grouper.begin();\n\n  // Empty indices vector represents iteration end in `CompareGroups`.\n  const std::vector<int64_t> group_iter_end;\n  // Group by rows, and iterate over rows of both sets in parallel, creating a\n  // set for each row.\n  while ((set1_group_it != set1_grouper.end()) ||\n         (set2_group_it != set2_grouper.end())) {\n    const std::vector<int64_t>& set1_group_indices =\n        (set1_group_it == set1_grouper.end()) ? group_iter_end\n                                              : (*set1_group_it).group();\n    const std::vector<int64_t>& set2_group_indices =\n        (set2_group_it == set2_grouper.end()) ? group_iter_end\n                                              : (*set2_group_it).group();\n\n    int64_t compare_groups;\n    CompareGroups(ctx, set1_group_indices, set2_group_indices, &compare_groups);\n    const std::vector<int64_t>* group_indices = nullptr;\n\n    // Get values from set1, if applicable.\n    set1_group_set.clear();\n    if (compare_groups <= 0) {\n      PopulateFromSparseGroup<T>(ctx, *set1_group_it, set1_st.shape(),\n                                 &set1_group_set);\n      ++set1_group_it;\n      group_indices = &set1_group_indices;\n    }\n\n    // Get values from set2, if applicable.\n    set2_group_set.clear();\n    if (compare_groups >= 0) {\n      PopulateFromSparseGroup<T>(ctx, *set2_group_it, set2_st.shape(),\n                                 &set2_group_set);\n      ++set2_group_it;\n      group_indices = &set2_group_indices;\n    }\n\n    absl::btree_set<T> group_set;\n    ApplySetOperation(set1_group_set, set2_group_set, &group_set);\n    if (!group_set.empty()) {\n      const auto set_size = group_set.size();\n      if (set_size > max_set_size) {\n        max_set_size = set_size;\n      }\n      num_result_values += set_size;\n      group_sets.push_back({*group_indices, std::move(group_set)});\n    }\n  }\n\n  TensorShape output_shape;\n  OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape(group_shape, &output_shape));\n  output_shape.AddDim(max_set_size);\n  OutputSparseTensor<T>(ctx, output_shape, num_result_values, group_sets);\n}\n\n// Given set1 of shape [b, n1] and data_2 of shape [b, n2], populate result\n// sparse tensor with [b, n3] values, where each row `i` contains the result of\n// the set operation on elements from set1[i] and set2[i]. `n3` is the number\n// of elements in that result row.\ntemplate <typename T>\nvoid SetOperationOp<T>::Compute(OpKernelContext* ctx) {\n  switch (input_types_) {\n    case DENSE_DENSE:\n      ComputeDenseToDense(ctx);\n      break;\n    case DENSE_SPARSE:\n      ComputeDenseToSparse(ctx);\n      break;\n    case SPARSE_SPARSE:\n      ComputeSparseToSparse(ctx);\n      break;\n  }\n}\n\ntemplate <typename T>\nclass DenseToDenseSetOperationOp : public SetOperationOp<T> {\n public:\n  explicit DenseToDenseSetOperationOp(OpKernelConstruction* ctx)\n      : SetOperationOp<T>(ctx, DENSE_DENSE) {}\n};\n\n#define _DENSE_TO_DENSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(T) \\\n  REGISTER_KERNEL_BUILDER(Name(\"DenseToDenseSetOperation\")       \\\n                              .Device(DEVICE_CPU)                \\\n                              .TypeConstraint<T>(\"T\"),           \\\n                          DenseToDenseSetOperationOp<T>);\n_DENSE_TO_DENSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int8);\n_DENSE_TO_DENSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int16);\n_DENSE_TO_DENSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int32);\n_DENSE_TO_DENSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int64_t);\n_DENSE_TO_DENSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(uint8);\n_DENSE_TO_DENSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(uint16);\n_DENSE_TO_DENSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(tstring);\n#undef _DENSE_TO_DENSE_SET_OPERATION_REGISTER_KERNEL_BUILDER\n\ntemplate <typename T>\nclass DenseToSparseSetOperationOp : public SetOperationOp<T> {\n public:\n  explicit DenseToSparseSetOperationOp(OpKernelConstruction* ctx)\n      : SetOperationOp<T>(ctx, DENSE_SPARSE) {}\n};\n\n#define _DENSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(T) \\\n  REGISTER_KERNEL_BUILDER(Name(\"DenseToSparseSetOperation\")       \\\n                              .Device(DEVICE_CPU)                 \\\n                              .TypeConstraint<T>(\"T\"),            \\\n                          DenseToSparseSetOperationOp<T>);\n_DENSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int8);\n_DENSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int16);\n_DENSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int32);\n_DENSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int64_t);\n_DENSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(uint8);\n_DENSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(uint16);\n_DENSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(tstring);\n#undef _DENSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER\n\ntemplate <typename T>\nclass SparseToSparseSetOperationOp : public SetOperationOp<T> {\n public:\n  explicit SparseToSparseSetOperationOp(OpKernelConstruction* ctx)\n      : SetOperationOp<T>(ctx, SPARSE_SPARSE) {}\n};\n\n#define _SPARSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(T) \\\n  REGISTER_KERNEL_BUILDER(Name(\"SparseToSparseSetOperation\")       \\\n                              .Device(DEVICE_CPU)                  \\\n                              .TypeConstraint<T>(\"T\"),             \\\n                          SparseToSparseSetOperationOp<T>);\n_SPARSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int8);\n_SPARSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int16);\n_SPARSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int32);\n_SPARSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int64_t);\n_SPARSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(uint8);\n_SPARSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(uint16);\n_SPARSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(tstring);\n#undef _SPARSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER\n\n}  // namespace tensorflow\n", "# Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for set_ops.\"\"\"\n\nfrom absl.testing import parameterized\nimport numpy as np\n\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors_impl\nfrom tensorflow.python.framework import sparse_tensor as sparse_tensor_lib\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import gen_set_ops\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import sets\nfrom tensorflow.python.ops import sparse_ops\nfrom tensorflow.python.platform import googletest\n\n_DTYPES = set([\n    dtypes.int8, dtypes.int16, dtypes.int32, dtypes.int64, dtypes.uint8,\n    dtypes.uint16, dtypes.string\n])\n\n\ndef _values(values, dtype):\n  return np.array(\n      values,\n      dtype=(np.str_ if (dtype == dtypes.string) else dtype.as_numpy_dtype))\n\n\ndef _constant(values, dtype):\n  return constant_op.constant(_values(values, dtype), dtype=dtype)\n\n\ndef _dense_to_sparse(dense, dtype):\n  indices = []\n  values = []\n  max_row_len = 0\n  for row in dense:\n    max_row_len = max(max_row_len, len(row))\n  shape = [len(dense), max_row_len]\n  row_ix = 0\n  for row in dense:\n    col_ix = 0\n    for cell in row:\n      indices.append([row_ix, col_ix])\n      values.append(str(cell) if dtype == dtypes.string else cell)\n      col_ix += 1\n    row_ix += 1\n  return sparse_tensor_lib.SparseTensor(\n      constant_op.constant(indices, dtypes.int64),\n      constant_op.constant(values, dtype),\n      constant_op.constant(shape, dtypes.int64))\n\n\nclass SetOpsTest(test_util.TensorFlowTestCase, parameterized.TestCase):\n\n  @test_util.run_deprecated_v1\n  def test_set_size_2d(self):\n    for dtype in _DTYPES:\n      self._test_set_size_2d(dtype)\n\n  def _test_set_size_2d(self, dtype):\n    self.assertAllEqual([1], self._set_size(_dense_to_sparse([[1]], dtype)))\n    self.assertAllEqual([2, 1],\n                        self._set_size(_dense_to_sparse([[1, 9], [1]], dtype)))\n    self.assertAllEqual(\n        [3, 0], self._set_size(_dense_to_sparse([[1, 9, 2], []], dtype)))\n    self.assertAllEqual(\n        [0, 3], self._set_size(_dense_to_sparse([[], [1, 9, 2]], dtype)))\n\n  @test_util.run_deprecated_v1\n  def test_set_size_duplicates_2d(self):\n    for dtype in _DTYPES:\n      self._test_set_size_duplicates_2d(dtype)\n\n  def _test_set_size_duplicates_2d(self, dtype):\n    self.assertAllEqual(\n        [1], self._set_size(_dense_to_sparse([[1, 1, 1, 1, 1, 1]], dtype)))\n    self.assertAllEqual([2, 7, 3, 0, 1],\n                        self._set_size(\n                            _dense_to_sparse([[1, 9], [\n                                6, 7, 8, 8, 6, 7, 5, 3, 3, 0, 6, 6, 9, 0, 0, 0\n                            ], [999, 1, -1000], [], [-1]], dtype)))\n\n  @test_util.run_deprecated_v1\n  def test_set_size_3d(self):\n    for dtype in _DTYPES:\n      self._test_set_size_3d(dtype)\n\n  def test_set_size_3d_invalid_indices(self):\n    for dtype in _DTYPES:\n      self._test_set_size_3d(dtype, invalid_indices=True)\n\n  def _test_set_size_3d(self, dtype, invalid_indices=False):\n    if invalid_indices:\n      indices = constant_op.constant([\n          [0, 1, 0], [0, 1, 1],             # 0,1\n          [1, 0, 0],                        # 1,0\n          [1, 1, 0], [1, 1, 1], [1, 1, 2],  # 1,1\n          [0, 0, 0], [0, 0, 2],             # 0,0\n                                            # 2,0\n          [2, 1, 1]                         # 2,1\n      ], dtypes.int64)\n    else:\n      indices = constant_op.constant([\n          [0, 0, 0], [0, 0, 2],             # 0,0\n          [0, 1, 0], [0, 1, 1],             # 0,1\n          [1, 0, 0],                        # 1,0\n          [1, 1, 0], [1, 1, 1], [1, 1, 2],  # 1,1\n                                            # 2,0\n          [2, 1, 1]                         # 2,1\n      ], dtypes.int64)\n\n    sp = sparse_tensor_lib.SparseTensor(\n        indices,\n        _constant([\n            1, 9,     # 0,0\n            3, 3,     # 0,1\n            1,        # 1,0\n            9, 7, 8,  # 1,1\n                      # 2,0\n            5         # 2,1\n        ], dtype),\n        constant_op.constant([3, 2, 3], dtypes.int64))\n\n    if invalid_indices:\n      with self.assertRaisesRegex(errors_impl.OpError, \"out of order\"):\n        self._set_size(sp)\n    else:\n      self.assertAllEqual([\n          [2,   # 0,0\n           1],  # 0,1\n          [1,   # 1,0\n           3],  # 1,1\n          [0,   # 2,0\n           1]   # 2,1\n      ], self._set_size(sp))\n\n  def _set_size(self, sparse_data):\n    # Validate that we get the same results with or without `validate_indices`.\n    ops = [\n        sets.set_size(sparse_data, validate_indices=True),\n        sets.set_size(sparse_data, validate_indices=False)\n    ]\n    for op in ops:\n      self.assertEqual(None, op.get_shape().dims)\n      self.assertEqual(dtypes.int32, op.dtype)\n    with self.cached_session() as sess:\n      results = self.evaluate(ops)\n    self.assertAllEqual(results[0], results[1])\n    return results[0]\n\n  @test_util.run_deprecated_v1\n  def test_set_intersection_multirow_2d(self):\n    for dtype in _DTYPES:\n      self._test_set_intersection_multirow_2d(dtype)\n\n  def _test_set_intersection_multirow_2d(self, dtype):\n    a_values = [[9, 1, 5], [2, 4, 3]]\n    b_values = [[1, 9], [1]]\n    expected_indices = [[0, 0], [0, 1]]\n    expected_values = _values([1, 9], dtype)\n    expected_shape = [2, 2]\n    expected_counts = [2, 0]\n\n    # Dense to sparse.\n    a = _constant(a_values, dtype=dtype)\n    sp_b = _dense_to_sparse(b_values, dtype=dtype)\n    intersection = self._set_intersection(a, sp_b)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        intersection,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts, self._set_intersection_count(a, sp_b))\n\n    # Sparse to sparse.\n    sp_a = _dense_to_sparse(a_values, dtype=dtype)\n    intersection = self._set_intersection(sp_a, sp_b)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        intersection,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_intersection_count(sp_a, sp_b))\n\n  @test_util.run_deprecated_v1\n  def test_dense_set_intersection_multirow_2d(self):\n    for dtype in _DTYPES:\n      self._test_dense_set_intersection_multirow_2d(dtype)\n\n  def _test_dense_set_intersection_multirow_2d(self, dtype):\n    a_values = [[9, 1, 5], [2, 4, 3]]\n    b_values = [[1, 9], [1, 5]]\n    expected_indices = [[0, 0], [0, 1]]\n    expected_values = _values([1, 9], dtype)\n    expected_shape = [2, 2]\n    expected_counts = [2, 0]\n\n    # Dense to dense.\n    a = _constant(a_values, dtype)\n    b = _constant(b_values, dtype)\n    intersection = self._set_intersection(a, b)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        intersection,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts, self._set_intersection_count(a, b))\n\n  @test_util.run_deprecated_v1\n  def test_set_intersection_duplicates_2d(self):\n    for dtype in _DTYPES:\n      self._test_set_intersection_duplicates_2d(dtype)\n\n  def _test_set_intersection_duplicates_2d(self, dtype):\n    a_values = [[1, 1, 3]]\n    b_values = [[1]]\n    expected_indices = [[0, 0]]\n    expected_values = _values([1], dtype)\n    expected_shape = [1, 1]\n    expected_counts = [1]\n\n    # Dense to dense.\n    a = _constant(a_values, dtype=dtype)\n    b = _constant(b_values, dtype=dtype)\n    intersection = self._set_intersection(a, b)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        intersection,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts, self._set_intersection_count(a, b))\n\n    # Dense to sparse.\n    sp_b = _dense_to_sparse(b_values, dtype=dtype)\n    intersection = self._set_intersection(a, sp_b)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        intersection,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts, self._set_intersection_count(a, sp_b))\n\n    # Sparse to sparse.\n    sp_a = _dense_to_sparse(a_values, dtype=dtype)\n    intersection = self._set_intersection(sp_a, sp_b)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        intersection,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_intersection_count(sp_a, sp_b))\n\n  @test_util.run_deprecated_v1\n  def test_set_intersection_3d(self):\n    for dtype in _DTYPES:\n      self._test_set_intersection_3d(dtype=dtype)\n\n  def test_set_intersection_3d_invalid_indices(self):\n    for dtype in _DTYPES:\n      self._test_set_intersection_3d(dtype=dtype, invalid_indices=True)\n\n  def _test_set_intersection_3d(self, dtype, invalid_indices=False):\n    if invalid_indices:\n      indices = constant_op.constant(\n          [\n              [0, 1, 0],\n              [0, 1, 1],  # 0,1\n              [1, 0, 0],  # 1,0\n              [1, 1, 0],\n              [1, 1, 1],\n              [1, 1, 2],  # 1,1\n              [0, 0, 0],\n              [0, 0, 2],  # 0,0\n              # 2,0\n              [2, 1, 1]  # 2,1\n              # 3,*\n          ],\n          dtypes.int64)\n    else:\n      indices = constant_op.constant(\n          [\n              [0, 0, 0],\n              [0, 0, 2],  # 0,0\n              [0, 1, 0],\n              [0, 1, 1],  # 0,1\n              [1, 0, 0],  # 1,0\n              [1, 1, 0],\n              [1, 1, 1],\n              [1, 1, 2],  # 1,1\n              # 2,0\n              [2, 1, 1]  # 2,1\n              # 3,*\n          ],\n          dtypes.int64)\n    sp_a = sparse_tensor_lib.SparseTensor(\n        indices,\n        _constant(\n            [\n                1,\n                9,  # 0,0\n                3,\n                3,  # 0,1\n                1,  # 1,0\n                9,\n                7,\n                8,  # 1,1\n                # 2,0\n                5  # 2,1\n                # 3,*\n            ],\n            dtype),\n        constant_op.constant([4, 2, 3], dtypes.int64))\n    sp_b = sparse_tensor_lib.SparseTensor(\n        constant_op.constant(\n            [\n                [0, 0, 0],\n                [0, 0, 3],  # 0,0\n                # 0,1\n                [1, 0, 0],  # 1,0\n                [1, 1, 0],\n                [1, 1, 1],  # 1,1\n                [2, 0, 1],  # 2,0\n                [2, 1, 1],  # 2,1\n                [3, 0, 0],  # 3,0\n                [3, 1, 0]  # 3,1\n            ],\n            dtypes.int64),\n        _constant(\n            [\n                1,\n                3,  # 0,0\n                # 0,1\n                3,  # 1,0\n                7,\n                8,  # 1,1\n                2,  # 2,0\n                5,  # 2,1\n                4,  # 3,0\n                4  # 3,1\n            ],\n            dtype),\n        constant_op.constant([4, 2, 4], dtypes.int64))\n\n    if invalid_indices:\n      with self.assertRaisesRegex(errors_impl.OpError, \"out of order\"):\n        self._set_intersection(sp_a, sp_b)\n    else:\n      expected_indices = [\n          [0, 0, 0],  # 0,0\n          # 0,1\n          # 1,0\n          [1, 1, 0],\n          [1, 1, 1],  # 1,1\n          # 2,0\n          [2, 1, 0],  # 2,1\n          # 3,*\n      ]\n      expected_values = _values(\n          [\n              1,  # 0,0\n              # 0,1\n              # 1,0\n              7,\n              8,  # 1,1\n              # 2,0\n              5,  # 2,1\n              # 3,*\n          ],\n          dtype)\n      expected_shape = [4, 2, 2]\n      expected_counts = [\n          [\n              1,  # 0,0\n              0  # 0,1\n          ],\n          [\n              0,  # 1,0\n              2  # 1,1\n          ],\n          [\n              0,  # 2,0\n              1  # 2,1\n          ],\n          [\n              0,  # 3,0\n              0  # 3,1\n          ]\n      ]\n\n      # Sparse to sparse.\n      intersection = self._set_intersection(sp_a, sp_b)\n      self._assert_set_operation(\n          expected_indices,\n          expected_values,\n          expected_shape,\n          intersection,\n          dtype=dtype)\n      self.assertAllEqual(expected_counts,\n                          self._set_intersection_count(sp_a, sp_b))\n\n      # NOTE: sparse_to_dense doesn't support uint8 and uint16.\n      if dtype not in [dtypes.uint8, dtypes.uint16]:\n        # Dense to sparse.\n        a = math_ops.cast(\n            sparse_ops.sparse_to_dense(\n                sp_a.indices,\n                sp_a.dense_shape,\n                sp_a.values,\n                default_value=\"-1\" if dtype == dtypes.string else -1),\n            dtype=dtype)\n        intersection = self._set_intersection(a, sp_b)\n        self._assert_set_operation(\n            expected_indices,\n            expected_values,\n            expected_shape,\n            intersection,\n            dtype=dtype)\n        self.assertAllEqual(expected_counts,\n                            self._set_intersection_count(a, sp_b))\n\n        # Dense to dense.\n        b = math_ops.cast(\n            sparse_ops.sparse_to_dense(\n                sp_b.indices,\n                sp_b.dense_shape,\n                sp_b.values,\n                default_value=\"-2\" if dtype == dtypes.string else -2),\n            dtype=dtype)\n        intersection = self._set_intersection(a, b)\n        self._assert_set_operation(\n            expected_indices,\n            expected_values,\n            expected_shape,\n            intersection,\n            dtype=dtype)\n        self.assertAllEqual(expected_counts, self._set_intersection_count(a, b))\n\n  def _assert_static_shapes(self, input_tensor, result_sparse_tensor):\n    if isinstance(input_tensor, sparse_tensor_lib.SparseTensor):\n      sparse_shape_dims = input_tensor.dense_shape.get_shape().dims\n      if sparse_shape_dims is None:\n        expected_rank = None\n      else:\n        expected_rank = sparse_shape_dims[0].value\n    else:\n      expected_rank = input_tensor.get_shape().ndims\n    self.assertAllEqual((None, expected_rank),\n                        result_sparse_tensor.indices.get_shape().as_list())\n    self.assertAllEqual((None,),\n                        result_sparse_tensor.values.get_shape().as_list())\n    self.assertAllEqual((expected_rank,),\n                        result_sparse_tensor.dense_shape.get_shape().as_list())\n\n  def _run_equivalent_set_ops(self, ops):\n    \"\"\"Assert all ops return the same shapes, and return 1st result.\"\"\"\n    # Collect shapes and results for all ops, and assert static shapes match.\n    dynamic_indices_shape_ops = []\n    dynamic_values_shape_ops = []\n    static_indices_shape = None\n    static_values_shape = None\n    with self.cached_session() as sess:\n      for op in ops:\n        if static_indices_shape is None:\n          static_indices_shape = op.indices.get_shape()\n        else:\n          self.assertAllEqual(\n              static_indices_shape.as_list(), op.indices.get_shape().as_list())\n        if static_values_shape is None:\n          static_values_shape = op.values.get_shape()\n        else:\n          self.assertAllEqual(\n              static_values_shape.as_list(), op.values.get_shape().as_list())\n        dynamic_indices_shape_ops.append(array_ops.shape(op.indices))\n        dynamic_values_shape_ops.append(array_ops.shape(op.values))\n      results = sess.run(\n          list(ops) + dynamic_indices_shape_ops + dynamic_values_shape_ops)\n      op_count = len(ops)\n      op_results = results[0:op_count]\n      dynamic_indices_shapes = results[op_count:2 * op_count]\n      dynamic_values_shapes = results[2 * op_count:3 * op_count]\n\n    # Assert static and dynamic tensor shapes, and result shapes, are all\n    # consistent.\n    static_indices_shape.assert_is_compatible_with(dynamic_indices_shapes[0])\n    static_values_shape.assert_is_compatible_with(dynamic_values_shapes[0])\n    self.assertAllEqual(dynamic_indices_shapes[0], op_results[0].indices.shape)\n    self.assertAllEqual(dynamic_values_shapes[0], op_results[0].values.shape)\n\n    # Assert dynamic shapes and values are the same for all ops.\n    for i in range(1, len(ops)):\n      self.assertAllEqual(dynamic_indices_shapes[0], dynamic_indices_shapes[i])\n      self.assertAllEqual(dynamic_values_shapes[0], dynamic_values_shapes[i])\n      self.assertAllEqual(op_results[0].indices, op_results[i].indices)\n      self.assertAllEqual(op_results[0].values, op_results[i].values)\n      self.assertAllEqual(op_results[0].dense_shape, op_results[i].dense_shape)\n\n    return op_results[0]\n\n  def _set_intersection(self, a, b):\n    # Validate that we get the same results with or without `validate_indices`,\n    # and with a & b swapped.\n    ops = (\n        sets.set_intersection(\n            a, b, validate_indices=True),\n        sets.set_intersection(\n            a, b, validate_indices=False),\n        sets.set_intersection(\n            b, a, validate_indices=True),\n        sets.set_intersection(\n            b, a, validate_indices=False),)\n    for op in ops:\n      self._assert_static_shapes(a, op)\n    return self._run_equivalent_set_ops(ops)\n\n  def _set_intersection_count(self, a, b):\n    op = sets.set_size(sets.set_intersection(a, b))\n    with self.cached_session() as sess:\n      return self.evaluate(op)\n\n  @test_util.run_deprecated_v1\n  def test_set_difference_multirow_2d(self):\n    for dtype in _DTYPES:\n      self._test_set_difference_multirow_2d(dtype)\n\n  def _test_set_difference_multirow_2d(self, dtype):\n    a_values = [[1, 1, 1], [1, 5, 9], [4, 5, 3], [5, 5, 1]]\n    b_values = [[], [1, 2], [1, 2, 2], []]\n\n    # a - b.\n    expected_indices = [[0, 0], [1, 0], [1, 1], [2, 0], [2, 1], [2, 2], [3, 0],\n                        [3, 1]]\n    expected_values = _values([1, 5, 9, 3, 4, 5, 1, 5], dtype)\n    expected_shape = [4, 3]\n    expected_counts = [1, 2, 3, 2]\n\n    # Dense to sparse.\n    a = _constant(a_values, dtype=dtype)\n    sp_b = _dense_to_sparse(b_values, dtype=dtype)\n    difference = self._set_difference(a, sp_b, True)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(a, sp_b, True))\n\n    # Sparse to sparse.\n    sp_a = _dense_to_sparse(a_values, dtype=dtype)\n    difference = self._set_difference(sp_a, sp_b, True)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(sp_a, sp_b, True))\n\n    # b - a.\n    expected_indices = [[1, 0], [2, 0], [2, 1]]\n    expected_values = _values([2, 1, 2], dtype)\n    expected_shape = [4, 2]\n    expected_counts = [0, 1, 2, 0]\n\n    # Dense to sparse.\n    difference = self._set_difference(a, sp_b, False)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(a, sp_b, False))\n\n    # Sparse to sparse.\n    difference = self._set_difference(sp_a, sp_b, False)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(sp_a, sp_b, False))\n\n  @test_util.run_deprecated_v1\n  def test_dense_set_difference_multirow_2d(self):\n    for dtype in _DTYPES:\n      self._test_dense_set_difference_multirow_2d(dtype)\n\n  def _test_dense_set_difference_multirow_2d(self, dtype):\n    a_values = [[1, 5, 9], [4, 5, 3]]\n    b_values = [[1, 2, 6], [1, 2, 2]]\n\n    # a - b.\n    expected_indices = [[0, 0], [0, 1], [1, 0], [1, 1], [1, 2]]\n    expected_values = _values([5, 9, 3, 4, 5], dtype)\n    expected_shape = [2, 3]\n    expected_counts = [2, 3]\n\n    # Dense to dense.\n    a = _constant(a_values, dtype=dtype)\n    b = _constant(b_values, dtype=dtype)\n    difference = self._set_difference(a, b, True)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts, self._set_difference_count(a, b, True))\n\n    # b - a.\n    expected_indices = [[0, 0], [0, 1], [1, 0], [1, 1]]\n    expected_values = _values([2, 6, 1, 2], dtype)\n    expected_shape = [2, 2]\n    expected_counts = [2, 2]\n\n    # Dense to dense.\n    difference = self._set_difference(a, b, False)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(a, b, False))\n\n  @test_util.run_deprecated_v1\n  def test_sparse_set_difference_multirow_2d(self):\n    for dtype in _DTYPES:\n      self._test_sparse_set_difference_multirow_2d(dtype)\n\n  def _test_sparse_set_difference_multirow_2d(self, dtype):\n    sp_a = _dense_to_sparse(\n        [[], [1, 5, 9], [4, 5, 3, 3, 4, 5], [5, 1]], dtype=dtype)\n    sp_b = _dense_to_sparse([[], [1, 2], [1, 2, 2], []], dtype=dtype)\n\n    # a - b.\n    expected_indices = [[1, 0], [1, 1], [2, 0], [2, 1], [2, 2], [3, 0], [3, 1]]\n    expected_values = _values([5, 9, 3, 4, 5, 1, 5], dtype)\n    expected_shape = [4, 3]\n    expected_counts = [0, 2, 3, 2]\n\n    difference = self._set_difference(sp_a, sp_b, True)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(sp_a, sp_b, True))\n\n    # b - a.\n    expected_indices = [[1, 0], [2, 0], [2, 1]]\n    expected_values = _values([2, 1, 2], dtype)\n    expected_shape = [4, 2]\n    expected_counts = [0, 1, 2, 0]\n\n    difference = self._set_difference(sp_a, sp_b, False)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(sp_a, sp_b, False))\n\n  @test_util.run_deprecated_v1\n  def test_set_difference_duplicates_2d(self):\n    for dtype in _DTYPES:\n      self._test_set_difference_duplicates_2d(dtype)\n\n  def _test_set_difference_duplicates_2d(self, dtype):\n    a_values = [[1, 1, 3]]\n    b_values = [[1, 2, 2]]\n\n    # a - b.\n    expected_indices = [[0, 0]]\n    expected_values = _values([3], dtype)\n    expected_shape = [1, 1]\n    expected_counts = [1]\n\n    # Dense to sparse.\n    a = _constant(a_values, dtype=dtype)\n    sp_b = _dense_to_sparse(b_values, dtype=dtype)\n    difference = self._set_difference(a, sp_b, True)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(a, sp_b, True))\n\n    # Sparse to sparse.\n    sp_a = _dense_to_sparse(a_values, dtype=dtype)\n    difference = self._set_difference(sp_a, sp_b, True)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(a, sp_b, True))\n\n    # b - a.\n    expected_indices = [[0, 0]]\n    expected_values = _values([2], dtype)\n    expected_shape = [1, 1]\n    expected_counts = [1]\n\n    # Dense to sparse.\n    difference = self._set_difference(a, sp_b, False)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(a, sp_b, False))\n\n    # Sparse to sparse.\n    difference = self._set_difference(sp_a, sp_b, False)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(a, sp_b, False))\n\n  @test_util.run_deprecated_v1\n  def test_sparse_set_difference_3d(self):\n    for dtype in _DTYPES:\n      self._test_sparse_set_difference_3d(dtype)\n\n  def test_sparse_set_difference_3d_invalid_indices(self):\n    for dtype in _DTYPES:\n      self._test_sparse_set_difference_3d(dtype, invalid_indices=True)\n\n  def _test_sparse_set_difference_3d(self, dtype, invalid_indices=False):\n    if invalid_indices:\n      indices = constant_op.constant(\n          [\n              [0, 1, 0],\n              [0, 1, 1],  # 0,1\n              [1, 0, 0],  # 1,0\n              [1, 1, 0],\n              [1, 1, 1],\n              [1, 1, 2],  # 1,1\n              [0, 0, 0],\n              [0, 0, 2],  # 0,0\n              # 2,0\n              [2, 1, 1]  # 2,1\n              # 3,*\n          ],\n          dtypes.int64)\n    else:\n      indices = constant_op.constant(\n          [\n              [0, 0, 0],\n              [0, 0, 2],  # 0,0\n              [0, 1, 0],\n              [0, 1, 1],  # 0,1\n              [1, 0, 0],  # 1,0\n              [1, 1, 0],\n              [1, 1, 1],\n              [1, 1, 2],  # 1,1\n              # 2,0\n              [2, 1, 1]  # 2,1\n              # 3,*\n          ],\n          dtypes.int64)\n    sp_a = sparse_tensor_lib.SparseTensor(\n        indices,\n        _constant(\n            [\n                1,\n                9,  # 0,0\n                3,\n                3,  # 0,1\n                1,  # 1,0\n                9,\n                7,\n                8,  # 1,1\n                # 2,0\n                5  # 2,1\n                # 3,*\n            ],\n            dtype),\n        constant_op.constant([4, 2, 3], dtypes.int64))\n    sp_b = sparse_tensor_lib.SparseTensor(\n        constant_op.constant(\n            [\n                [0, 0, 0],\n                [0, 0, 3],  # 0,0\n                # 0,1\n                [1, 0, 0],  # 1,0\n                [1, 1, 0],\n                [1, 1, 1],  # 1,1\n                [2, 0, 1],  # 2,0\n                [2, 1, 1],  # 2,1\n                [3, 0, 0],  # 3,0\n                [3, 1, 0]  # 3,1\n            ],\n            dtypes.int64),\n        _constant(\n            [\n                1,\n                3,  # 0,0\n                # 0,1\n                3,  # 1,0\n                7,\n                8,  # 1,1\n                2,  # 2,0\n                5,  # 2,1\n                4,  # 3,0\n                4  # 3,1\n            ],\n            dtype),\n        constant_op.constant([4, 2, 4], dtypes.int64))\n\n    if invalid_indices:\n      with self.assertRaisesRegex(errors_impl.OpError, \"out of order\"):\n        self._set_difference(sp_a, sp_b, False)\n      with self.assertRaisesRegex(errors_impl.OpError, \"out of order\"):\n        self._set_difference(sp_a, sp_b, True)\n    else:\n      # a-b\n      expected_indices = [\n          [0, 0, 0],  # 0,0\n          [0, 1, 0],  # 0,1\n          [1, 0, 0],  # 1,0\n          [1, 1, 0],  # 1,1\n          # 2,*\n          # 3,*\n      ]\n      expected_values = _values(\n          [\n              9,  # 0,0\n              3,  # 0,1\n              1,  # 1,0\n              9,  # 1,1\n              # 2,*\n              # 3,*\n          ],\n          dtype)\n      expected_shape = [4, 2, 1]\n      expected_counts = [\n          [\n              1,  # 0,0\n              1  # 0,1\n          ],\n          [\n              1,  # 1,0\n              1  # 1,1\n          ],\n          [\n              0,  # 2,0\n              0  # 2,1\n          ],\n          [\n              0,  # 3,0\n              0  # 3,1\n          ]\n      ]\n\n      difference = self._set_difference(sp_a, sp_b, True)\n      self._assert_set_operation(\n          expected_indices,\n          expected_values,\n          expected_shape,\n          difference,\n          dtype=dtype)\n      self.assertAllEqual(expected_counts,\n                          self._set_difference_count(sp_a, sp_b))\n\n      # b-a\n      expected_indices = [\n          [0, 0, 0],  # 0,0\n          # 0,1\n          [1, 0, 0],  # 1,0\n          # 1,1\n          [2, 0, 0],  # 2,0\n          # 2,1\n          [3, 0, 0],  # 3,0\n          [3, 1, 0]  # 3,1\n      ]\n      expected_values = _values(\n          [\n              3,  # 0,0\n              # 0,1\n              3,  # 1,0\n              # 1,1\n              2,  # 2,0\n              # 2,1\n              4,  # 3,0\n              4,  # 3,1\n          ],\n          dtype)\n      expected_shape = [4, 2, 1]\n      expected_counts = [\n          [\n              1,  # 0,0\n              0  # 0,1\n          ],\n          [\n              1,  # 1,0\n              0  # 1,1\n          ],\n          [\n              1,  # 2,0\n              0  # 2,1\n          ],\n          [\n              1,  # 3,0\n              1  # 3,1\n          ]\n      ]\n\n      difference = self._set_difference(sp_a, sp_b, False)\n      self._assert_set_operation(\n          expected_indices,\n          expected_values,\n          expected_shape,\n          difference,\n          dtype=dtype)\n      self.assertAllEqual(expected_counts,\n                          self._set_difference_count(sp_a, sp_b, False))\n\n  def _set_difference(self, a, b, aminusb=True):\n    # Validate that we get the same results with or without `validate_indices`,\n    # and with a & b swapped.\n    ops = (\n        sets.set_difference(\n            a, b, aminusb=aminusb, validate_indices=True),\n        sets.set_difference(\n            a, b, aminusb=aminusb, validate_indices=False),\n        sets.set_difference(\n            b, a, aminusb=not aminusb, validate_indices=True),\n        sets.set_difference(\n            b, a, aminusb=not aminusb, validate_indices=False),)\n    for op in ops:\n      self._assert_static_shapes(a, op)\n    return self._run_equivalent_set_ops(ops)\n\n  def _set_difference_count(self, a, b, aminusb=True):\n    op = sets.set_size(sets.set_difference(a, b, aminusb))\n    with self.cached_session() as sess:\n      return self.evaluate(op)\n\n  @test_util.run_deprecated_v1\n  def test_set_union_multirow_2d(self):\n    for dtype in _DTYPES:\n      self._test_set_union_multirow_2d(dtype)\n\n  def _test_set_union_multirow_2d(self, dtype):\n    a_values = [[9, 1, 5], [2, 4, 3]]\n    b_values = [[1, 9], [1]]\n    expected_indices = [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [1, 3]]\n    expected_values = _values([1, 5, 9, 1, 2, 3, 4], dtype)\n    expected_shape = [2, 4]\n    expected_counts = [3, 4]\n\n    # Dense to sparse.\n    a = _constant(a_values, dtype=dtype)\n    sp_b = _dense_to_sparse(b_values, dtype=dtype)\n    union = self._set_union(a, sp_b)\n    self._assert_set_operation(\n        expected_indices, expected_values, expected_shape, union, dtype=dtype)\n    self.assertAllEqual(expected_counts, self._set_union_count(a, sp_b))\n\n    # Sparse to sparse.\n    sp_a = _dense_to_sparse(a_values, dtype=dtype)\n    union = self._set_union(sp_a, sp_b)\n    self._assert_set_operation(\n        expected_indices, expected_values, expected_shape, union, dtype=dtype)\n    self.assertAllEqual(expected_counts, self._set_union_count(sp_a, sp_b))\n\n  @test_util.run_deprecated_v1\n  def test_dense_set_union_multirow_2d(self):\n    for dtype in _DTYPES:\n      self._test_dense_set_union_multirow_2d(dtype)\n\n  def _test_dense_set_union_multirow_2d(self, dtype):\n    a_values = [[9, 1, 5], [2, 4, 3]]\n    b_values = [[1, 9], [1, 2]]\n    expected_indices = [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [1, 3]]\n    expected_values = _values([1, 5, 9, 1, 2, 3, 4], dtype)\n    expected_shape = [2, 4]\n    expected_counts = [3, 4]\n\n    # Dense to dense.\n    a = _constant(a_values, dtype=dtype)\n    b = _constant(b_values, dtype=dtype)\n    union = self._set_union(a, b)\n    self._assert_set_operation(\n        expected_indices, expected_values, expected_shape, union, dtype=dtype)\n    self.assertAllEqual(expected_counts, self._set_union_count(a, b))\n\n  @test_util.run_deprecated_v1\n  def test_set_union_duplicates_2d(self):\n    for dtype in _DTYPES:\n      self._test_set_union_duplicates_2d(dtype)\n\n  def _test_set_union_duplicates_2d(self, dtype):\n    a_values = [[1, 1, 3]]\n    b_values = [[1]]\n    expected_indices = [[0, 0], [0, 1]]\n    expected_values = _values([1, 3], dtype)\n    expected_shape = [1, 2]\n\n    # Dense to sparse.\n    a = _constant(a_values, dtype=dtype)\n    sp_b = _dense_to_sparse(b_values, dtype=dtype)\n    union = self._set_union(a, sp_b)\n    self._assert_set_operation(\n        expected_indices, expected_values, expected_shape, union, dtype=dtype)\n    self.assertAllEqual([2], self._set_union_count(a, sp_b))\n\n    # Sparse to sparse.\n    sp_a = _dense_to_sparse(a_values, dtype=dtype)\n    union = self._set_union(sp_a, sp_b)\n    self._assert_set_operation(\n        expected_indices, expected_values, expected_shape, union, dtype=dtype)\n    self.assertAllEqual([2], self._set_union_count(sp_a, sp_b))\n\n  @test_util.run_deprecated_v1\n  def test_sparse_set_union_3d(self):\n    for dtype in _DTYPES:\n      self._test_sparse_set_union_3d(dtype)\n\n  def test_sparse_set_union_3d_invalid_indices(self):\n    for dtype in _DTYPES:\n      self._test_sparse_set_union_3d(dtype, invalid_indices=True)\n\n  def _test_sparse_set_union_3d(self, dtype, invalid_indices=False):\n    if invalid_indices:\n      indices = constant_op.constant(\n          [\n              [0, 1, 0],\n              [0, 1, 1],  # 0,1\n              [1, 0, 0],  # 1,0\n              [0, 0, 0],\n              [0, 0, 2],  # 0,0\n              [1, 1, 0],\n              [1, 1, 1],\n              [1, 1, 2],  # 1,1\n              # 2,0\n              [2, 1, 1]  # 2,1\n              # 3,*\n          ],\n          dtypes.int64)\n    else:\n      indices = constant_op.constant(\n          [\n              [0, 0, 0],\n              [0, 0, 2],  # 0,0\n              [0, 1, 0],\n              [0, 1, 1],  # 0,1\n              [1, 0, 0],  # 1,0\n              [1, 1, 0],\n              [1, 1, 1],\n              [1, 1, 2],  # 1,1\n              # 2,0\n              [2, 1, 1]  # 2,1\n              # 3,*\n          ],\n          dtypes.int64)\n    sp_a = sparse_tensor_lib.SparseTensor(\n        indices,\n        _constant(\n            [\n                1,\n                9,  # 0,0\n                3,\n                3,  # 0,1\n                1,  # 1,0\n                9,\n                7,\n                8,  # 1,1\n                # 2,0\n                5  # 2,1\n                # 3,*\n            ],\n            dtype),\n        constant_op.constant([4, 2, 3], dtypes.int64))\n    sp_b = sparse_tensor_lib.SparseTensor(\n        constant_op.constant(\n            [\n                [0, 0, 0],\n                [0, 0, 3],  # 0,0\n                # 0,1\n                [1, 0, 0],  # 1,0\n                [1, 1, 0],\n                [1, 1, 1],  # 1,1\n                [2, 0, 1],  # 2,0\n                [2, 1, 1],  # 2,1\n                [3, 0, 0],  # 3,0\n                [3, 1, 0]  # 3,1\n            ],\n            dtypes.int64),\n        _constant(\n            [\n                1,\n                3,  # 0,0\n                # 0,1\n                3,  # 1,0\n                7,\n                8,  # 1,1\n                2,  # 2,0\n                5,  # 2,1\n                4,  # 3,0\n                4  # 3,1\n            ],\n            dtype),\n        constant_op.constant([4, 2, 4], dtypes.int64))\n\n    if invalid_indices:\n      with self.assertRaisesRegex(errors_impl.OpError, \"out of order\"):\n        self._set_union(sp_a, sp_b)\n    else:\n      expected_indices = [\n          [0, 0, 0],\n          [0, 0, 1],\n          [0, 0, 2],  # 0,0\n          [0, 1, 0],  # 0,1\n          [1, 0, 0],\n          [1, 0, 1],  # 1,0\n          [1, 1, 0],\n          [1, 1, 1],\n          [1, 1, 2],  # 1,1\n          [2, 0, 0],  # 2,0\n          [2, 1, 0],  # 2,1\n          [3, 0, 0],  # 3,0\n          [3, 1, 0],  # 3,1\n      ]\n      expected_values = _values(\n          [\n              1,\n              3,\n              9,  # 0,0\n              3,  # 0,1\n              1,\n              3,  # 1,0\n              7,\n              8,\n              9,  # 1,1\n              2,  # 2,0\n              5,  # 2,1\n              4,  # 3,0\n              4,  # 3,1\n          ],\n          dtype)\n      expected_shape = [4, 2, 3]\n      expected_counts = [\n          [\n              3,  # 0,0\n              1  # 0,1\n          ],\n          [\n              2,  # 1,0\n              3  # 1,1\n          ],\n          [\n              1,  # 2,0\n              1  # 2,1\n          ],\n          [\n              1,  # 3,0\n              1  # 3,1\n          ]\n      ]\n\n      intersection = self._set_union(sp_a, sp_b)\n      self._assert_set_operation(\n          expected_indices,\n          expected_values,\n          expected_shape,\n          intersection,\n          dtype=dtype)\n      self.assertAllEqual(expected_counts, self._set_union_count(sp_a, sp_b))\n\n  def _set_union(self, a, b):\n    # Validate that we get the same results with or without `validate_indices`,\n    # and with a & b swapped.\n    ops = (\n        sets.set_union(\n            a, b, validate_indices=True),\n        sets.set_union(\n            a, b, validate_indices=False),\n        sets.set_union(\n            b, a, validate_indices=True),\n        sets.set_union(\n            b, a, validate_indices=False),)\n    for op in ops:\n      self._assert_static_shapes(a, op)\n    return self._run_equivalent_set_ops(ops)\n\n  def _set_union_count(self, a, b):\n    op = sets.set_size(sets.set_union(a, b))\n    with self.cached_session() as sess:\n      return self.evaluate(op)\n\n  def _assert_set_operation(self, expected_indices, expected_values,\n                            expected_shape, sparse_tensor_value, dtype):\n    self.assertAllEqual(expected_indices, sparse_tensor_value.indices)\n    self.assertAllEqual(len(expected_indices), len(expected_values))\n    self.assertAllEqual(len(expected_values), len(sparse_tensor_value.values))\n    expected_set = set()\n    actual_set = set()\n    last_indices = None\n    for indices, expected_value, actual_value in zip(\n        expected_indices, expected_values, sparse_tensor_value.values):\n      if dtype == dtypes.string:\n        actual_value = actual_value.decode(\"utf-8\")\n      if last_indices and (last_indices[:-1] != indices[:-1]):\n        self.assertEqual(\n            expected_set, actual_set,\n            \"Expected %s, got %s, at %s.\" % (expected_set, actual_set, indices))\n        expected_set.clear()\n        actual_set.clear()\n      expected_set.add(expected_value)\n      actual_set.add(actual_value)\n      last_indices = indices\n    self.assertEqual(\n        expected_set, actual_set, \"Expected %s, got %s, at %s.\" %\n        (expected_set, actual_set, last_indices))\n    self.assertAllEqual(expected_shape, sparse_tensor_value.dense_shape)\n\n  @parameterized.parameters(*_DTYPES)\n  def test_set_union_output_is_sorted(self, dtype):\n    # We don't use any numbers >= 10 so that lexicographical order agrees with\n    # numeric order in this test, for the type dtype == tf.string.\n\n    # [3 7 5 3 1]\n    # [2 6 5 4]\n    # []\n    # [9 8]\n    sp_a = sparse_tensor_lib.SparseTensor(\n        indices=constant_op.constant(\n            [[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [1, 0], [1, 1], [1, 2],\n             [1, 3], [3, 0], [3, 1]],\n            dtype=dtypes.int64),\n        values=_constant([3, 7, 5, 3, 1, 2, 6, 5, 4, 9, 8], dtype),\n        dense_shape=constant_op.constant([4, 5], dtype=dtypes.int64))\n\n    # [9 7]\n    # [5 2 0]\n    # [6]\n    # []\n    sp_b = sparse_tensor_lib.SparseTensor(\n        indices=constant_op.constant(\n            [[0, 0], [0, 1], [1, 0], [1, 1], [1, 2], [2, 0]],\n            dtype=dtypes.int64),\n        values=_constant([9, 7, 5, 2, 0, 6], dtype),\n        dense_shape=constant_op.constant([4, 3], dtype=dtypes.int64))\n    # The union should be\n    # [1 3 5 7 9]\n    # [0 2 4 5 6]\n    # [6]\n    # [8 9]\n    result = sets.set_union(sp_a, sp_b)\n    self.assertAllEqual(result.dense_shape, [4, 5])\n    self.assertAllEqual(result.indices,\n                        [[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [1, 0], [1, 1],\n                         [1, 2], [1, 3], [1, 4], [2, 0], [3, 0], [3, 1]])\n    self.assertAllEqual(\n        result.values,\n        _constant([1, 3, 5, 7, 9, 0, 2, 4, 5, 6, 6, 8, 9], dtype))\n\n  def test_raw_ops_setsize_invalid_shape(self):\n    with self.assertRaisesRegex(errors_impl.InvalidArgumentError,\n                                \"Shape must be a 1D tensor\"):\n      invalid_shape = 1\n      self.evaluate(\n          gen_set_ops.set_size(\n              set_indices=1,\n              set_values=[1, 1],\n              set_shape=invalid_shape,\n              validate_indices=True,\n              name=\"\"))\n\n\nif __name__ == \"__main__\":\n  googletest.main()\n"], "filenames": ["tensorflow/core/kernels/set_kernels.cc", "tensorflow/python/kernel_tests/math_ops/sets_test.py"], "buggy_code_start_loc": [73, 25], "buggy_code_end_loc": [75, 1305], "fixing_code_start_loc": [73, 26], "fixing_code_end_loc": [79, 1319], "type": "CWE-617", "message": "TensorFlow is an open source platform for machine learning. When `SetSize` receives an input `set_shape` that is not a 1D tensor, it gives a `CHECK` fails that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit cf70b79d2662c0d3c6af74583641e345fc939467. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-35993", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-16T23:15:10.227", "lastModified": "2022-09-20T14:50:30.400", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an open source platform for machine learning. When `SetSize` receives an input `set_shape` that is not a 1D tensor, it gives a `CHECK` fails that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit cf70b79d2662c0d3c6af74583641e345fc939467. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto para el aprendizaje autom\u00e1tico. Cuando \"SetSize\" recibe una entrada \"set_shape\" que no es un tensor 1D, da un fallo de \"CHECK\" que puede ser usado para desencadenar un ataque de denegaci\u00f3n de servicio. Hemos parcheado el problema en el commit de GitHub cf70b79d2662c0d3c6af74583641e345fc939467. La correcci\u00f3n ser\u00e1 incluida en TensorFlow versi\u00f3n 2.10.0. Tambi\u00e9n seleccionaremos este compromiso en TensorFlow versi\u00f3n 2.9.1, TensorFlow versi\u00f3n 2.8.1, y TensorFlow versi\u00f3n 2.7.2, ya que estos tambi\u00e9n est\u00e1n afectados y todav\u00eda est\u00e1n en el rango admitido. No se presentan mitigaciones conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-617"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.7.2", "matchCriteriaId": "C6622D95-1C86-45C5-AB55-E6EEEA0996DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.8.0", "versionEndExcluding": "2.8.1", "matchCriteriaId": "0F9D273D-02DC-441E-AA91-EAC8DEAA4B44"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.9.0", "versionEndExcluding": "2.9.1", "matchCriteriaId": "FE4F8A81-6CC2-4F7F-9602-C170FDD926E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc0:*:*:*:*:*:*", "matchCriteriaId": "1DBFBCE2-0A01-4575-BE45-6775ABFB8B28"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc1:*:*:*:*:*:*", "matchCriteriaId": "89806CF9-E423-4CA6-A01A-8175C260CB24"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc2:*:*:*:*:*:*", "matchCriteriaId": "F2B80690-A257-4E16-BD27-9AE045BC56ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc3:*:*:*:*:*:*", "matchCriteriaId": "F335F9A4-5AB8-4E53-BC18-E01F7C653E5E"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/cf70b79d2662c0d3c6af74583641e345fc939467", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-wq6q-6m32-9rv9", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/cf70b79d2662c0d3c6af74583641e345fc939467"}}