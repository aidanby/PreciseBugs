{"buggy_code": ["/******************************************************************************\n *\n * This file is provided under a dual BSD/GPLv2 license.  When using or\n * redistributing this file, you may do so under either license.\n *\n * GPL LICENSE SUMMARY\n *\n * Copyright(c) 2008 - 2014 Intel Corporation. All rights reserved.\n * Copyright(c) 2013 - 2015 Intel Mobile Communications GmbH\n * Copyright(c) 2015 - 2017 Intel Deutschland GmbH\n * Copyright(c) 2018 - 2019 Intel Corporation\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * The full GNU General Public License is included in this distribution\n * in the file called COPYING.\n *\n * Contact Information:\n *  Intel Linux Wireless <linuxwifi@intel.com>\n * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497\n *\n * BSD LICENSE\n *\n * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.\n * Copyright(c) 2013 - 2015 Intel Mobile Communications GmbH\n * Copyright(c) 2015 - 2017 Intel Deutschland GmbH\n * Copyright(c) 2018 - 2019 Intel Corporation\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *  * Neither the name Intel Corporation nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *****************************************************************************/\n#include <linux/devcoredump.h>\n#include \"iwl-drv.h\"\n#include \"runtime.h\"\n#include \"dbg.h\"\n#include \"debugfs.h\"\n#include \"iwl-io.h\"\n#include \"iwl-prph.h\"\n#include \"iwl-csr.h\"\n\n/**\n * struct iwl_fw_dump_ptrs - set of pointers needed for the fw-error-dump\n *\n * @fwrt_ptr: pointer to the buffer coming from fwrt\n * @trans_ptr: pointer to struct %iwl_trans_dump_data which contains the\n *\ttransport's data.\n * @trans_len: length of the valid data in trans_ptr\n * @fwrt_len: length of the valid data in fwrt_ptr\n */\nstruct iwl_fw_dump_ptrs {\n\tstruct iwl_trans_dump_data *trans_ptr;\n\tvoid *fwrt_ptr;\n\tu32 fwrt_len;\n};\n\n#define RADIO_REG_MAX_READ 0x2ad\nstatic void iwl_read_radio_regs(struct iwl_fw_runtime *fwrt,\n\t\t\t\tstruct iwl_fw_error_dump_data **dump_data)\n{\n\tu8 *pos = (void *)(*dump_data)->data;\n\tunsigned long flags;\n\tint i;\n\n\tIWL_DEBUG_INFO(fwrt, \"WRT radio registers dump\\n\");\n\n\tif (!iwl_trans_grab_nic_access(fwrt->trans, &flags))\n\t\treturn;\n\n\t(*dump_data)->type = cpu_to_le32(IWL_FW_ERROR_DUMP_RADIO_REG);\n\t(*dump_data)->len = cpu_to_le32(RADIO_REG_MAX_READ);\n\n\tfor (i = 0; i < RADIO_REG_MAX_READ; i++) {\n\t\tu32 rd_cmd = RADIO_RSP_RD_CMD;\n\n\t\trd_cmd |= i << RADIO_RSP_ADDR_POS;\n\t\tiwl_write_prph_no_grab(fwrt->trans, RSP_RADIO_CMD, rd_cmd);\n\t\t*pos = (u8)iwl_read_prph_no_grab(fwrt->trans, RSP_RADIO_RDDAT);\n\n\t\tpos++;\n\t}\n\n\t*dump_data = iwl_fw_error_next_data(*dump_data);\n\n\tiwl_trans_release_nic_access(fwrt->trans, &flags);\n}\n\nstatic void iwl_fwrt_dump_rxf(struct iwl_fw_runtime *fwrt,\n\t\t\t      struct iwl_fw_error_dump_data **dump_data,\n\t\t\t      int size, u32 offset, int fifo_num)\n{\n\tstruct iwl_fw_error_dump_fifo *fifo_hdr;\n\tu32 *fifo_data;\n\tu32 fifo_len;\n\tint i;\n\n\tfifo_hdr = (void *)(*dump_data)->data;\n\tfifo_data = (void *)fifo_hdr->data;\n\tfifo_len = size;\n\n\t/* No need to try to read the data if the length is 0 */\n\tif (fifo_len == 0)\n\t\treturn;\n\n\t/* Add a TLV for the RXF */\n\t(*dump_data)->type = cpu_to_le32(IWL_FW_ERROR_DUMP_RXF);\n\t(*dump_data)->len = cpu_to_le32(fifo_len + sizeof(*fifo_hdr));\n\n\tfifo_hdr->fifo_num = cpu_to_le32(fifo_num);\n\tfifo_hdr->available_bytes =\n\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\tRXF_RD_D_SPACE + offset));\n\tfifo_hdr->wr_ptr =\n\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\tRXF_RD_WR_PTR + offset));\n\tfifo_hdr->rd_ptr =\n\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\tRXF_RD_RD_PTR + offset));\n\tfifo_hdr->fence_ptr =\n\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\tRXF_RD_FENCE_PTR + offset));\n\tfifo_hdr->fence_mode =\n\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\tRXF_SET_FENCE_MODE + offset));\n\n\t/* Lock fence */\n\tiwl_trans_write_prph(fwrt->trans, RXF_SET_FENCE_MODE + offset, 0x1);\n\t/* Set fence pointer to the same place like WR pointer */\n\tiwl_trans_write_prph(fwrt->trans, RXF_LD_WR2FENCE + offset, 0x1);\n\t/* Set fence offset */\n\tiwl_trans_write_prph(fwrt->trans,\n\t\t\t     RXF_LD_FENCE_OFFSET_ADDR + offset, 0x0);\n\n\t/* Read FIFO */\n\tfifo_len /= sizeof(u32); /* Size in DWORDS */\n\tfor (i = 0; i < fifo_len; i++)\n\t\tfifo_data[i] = iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\t RXF_FIFO_RD_FENCE_INC +\n\t\t\t\t\t\t offset);\n\t*dump_data = iwl_fw_error_next_data(*dump_data);\n}\n\nstatic void iwl_fwrt_dump_txf(struct iwl_fw_runtime *fwrt,\n\t\t\t      struct iwl_fw_error_dump_data **dump_data,\n\t\t\t      int size, u32 offset, int fifo_num)\n{\n\tstruct iwl_fw_error_dump_fifo *fifo_hdr;\n\tu32 *fifo_data;\n\tu32 fifo_len;\n\tint i;\n\n\tfifo_hdr = (void *)(*dump_data)->data;\n\tfifo_data = (void *)fifo_hdr->data;\n\tfifo_len = size;\n\n\t/* No need to try to read the data if the length is 0 */\n\tif (fifo_len == 0)\n\t\treturn;\n\n\t/* Add a TLV for the FIFO */\n\t(*dump_data)->type = cpu_to_le32(IWL_FW_ERROR_DUMP_TXF);\n\t(*dump_data)->len = cpu_to_le32(fifo_len + sizeof(*fifo_hdr));\n\n\tfifo_hdr->fifo_num = cpu_to_le32(fifo_num);\n\tfifo_hdr->available_bytes =\n\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\tTXF_FIFO_ITEM_CNT + offset));\n\tfifo_hdr->wr_ptr =\n\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\tTXF_WR_PTR + offset));\n\tfifo_hdr->rd_ptr =\n\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\tTXF_RD_PTR + offset));\n\tfifo_hdr->fence_ptr =\n\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\tTXF_FENCE_PTR + offset));\n\tfifo_hdr->fence_mode =\n\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\tTXF_LOCK_FENCE + offset));\n\n\t/* Set the TXF_READ_MODIFY_ADDR to TXF_WR_PTR */\n\tiwl_trans_write_prph(fwrt->trans, TXF_READ_MODIFY_ADDR + offset,\n\t\t\t     TXF_WR_PTR + offset);\n\n\t/* Dummy-read to advance the read pointer to the head */\n\tiwl_trans_read_prph(fwrt->trans, TXF_READ_MODIFY_DATA + offset);\n\n\t/* Read FIFO */\n\tfifo_len /= sizeof(u32); /* Size in DWORDS */\n\tfor (i = 0; i < fifo_len; i++)\n\t\tfifo_data[i] = iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\t  TXF_READ_MODIFY_DATA +\n\t\t\t\t\t\t  offset);\n\t*dump_data = iwl_fw_error_next_data(*dump_data);\n}\n\nstatic void iwl_fw_dump_rxf(struct iwl_fw_runtime *fwrt,\n\t\t\t    struct iwl_fw_error_dump_data **dump_data)\n{\n\tstruct iwl_fwrt_shared_mem_cfg *cfg = &fwrt->smem_cfg;\n\tunsigned long flags;\n\n\tIWL_DEBUG_INFO(fwrt, \"WRT RX FIFO dump\\n\");\n\n\tif (!iwl_trans_grab_nic_access(fwrt->trans, &flags))\n\t\treturn;\n\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_RXF)) {\n\t\t/* Pull RXF1 */\n\t\tiwl_fwrt_dump_rxf(fwrt, dump_data,\n\t\t\t\t  cfg->lmac[0].rxfifo1_size, 0, 0);\n\t\t/* Pull RXF2 */\n\t\tiwl_fwrt_dump_rxf(fwrt, dump_data, cfg->rxfifo2_size,\n\t\t\t\t  RXF_DIFF_FROM_PREV +\n\t\t\t\t  fwrt->trans->trans_cfg->umac_prph_offset, 1);\n\t\t/* Pull LMAC2 RXF1 */\n\t\tif (fwrt->smem_cfg.num_lmacs > 1)\n\t\t\tiwl_fwrt_dump_rxf(fwrt, dump_data,\n\t\t\t\t\t  cfg->lmac[1].rxfifo1_size,\n\t\t\t\t\t  LMAC2_PRPH_OFFSET, 2);\n\t}\n\n\tiwl_trans_release_nic_access(fwrt->trans, &flags);\n}\n\nstatic void iwl_fw_dump_txf(struct iwl_fw_runtime *fwrt,\n\t\t\t    struct iwl_fw_error_dump_data **dump_data)\n{\n\tstruct iwl_fw_error_dump_fifo *fifo_hdr;\n\tstruct iwl_fwrt_shared_mem_cfg *cfg = &fwrt->smem_cfg;\n\tu32 *fifo_data;\n\tu32 fifo_len;\n\tunsigned long flags;\n\tint i, j;\n\n\tIWL_DEBUG_INFO(fwrt, \"WRT TX FIFO dump\\n\");\n\n\tif (!iwl_trans_grab_nic_access(fwrt->trans, &flags))\n\t\treturn;\n\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_TXF)) {\n\t\t/* Pull TXF data from LMAC1 */\n\t\tfor (i = 0; i < fwrt->smem_cfg.num_txfifo_entries; i++) {\n\t\t\t/* Mark the number of TXF we're pulling now */\n\t\t\tiwl_trans_write_prph(fwrt->trans, TXF_LARC_NUM, i);\n\t\t\tiwl_fwrt_dump_txf(fwrt, dump_data,\n\t\t\t\t\t  cfg->lmac[0].txfifo_size[i], 0, i);\n\t\t}\n\n\t\t/* Pull TXF data from LMAC2 */\n\t\tif (fwrt->smem_cfg.num_lmacs > 1) {\n\t\t\tfor (i = 0; i < fwrt->smem_cfg.num_txfifo_entries;\n\t\t\t     i++) {\n\t\t\t\t/* Mark the number of TXF we're pulling now */\n\t\t\t\tiwl_trans_write_prph(fwrt->trans,\n\t\t\t\t\t\t     TXF_LARC_NUM +\n\t\t\t\t\t\t     LMAC2_PRPH_OFFSET, i);\n\t\t\t\tiwl_fwrt_dump_txf(fwrt, dump_data,\n\t\t\t\t\t\t  cfg->lmac[1].txfifo_size[i],\n\t\t\t\t\t\t  LMAC2_PRPH_OFFSET,\n\t\t\t\t\t\t  i + cfg->num_txfifo_entries);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_INTERNAL_TXF) &&\n\t    fw_has_capa(&fwrt->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_EXTEND_SHARED_MEM_CFG)) {\n\t\t/* Pull UMAC internal TXF data from all TXFs */\n\t\tfor (i = 0;\n\t\t     i < ARRAY_SIZE(fwrt->smem_cfg.internal_txfifo_size);\n\t\t     i++) {\n\t\t\tfifo_hdr = (void *)(*dump_data)->data;\n\t\t\tfifo_data = (void *)fifo_hdr->data;\n\t\t\tfifo_len = fwrt->smem_cfg.internal_txfifo_size[i];\n\n\t\t\t/* No need to try to read the data if the length is 0 */\n\t\t\tif (fifo_len == 0)\n\t\t\t\tcontinue;\n\n\t\t\t/* Add a TLV for the internal FIFOs */\n\t\t\t(*dump_data)->type =\n\t\t\t\tcpu_to_le32(IWL_FW_ERROR_DUMP_INTERNAL_TXF);\n\t\t\t(*dump_data)->len =\n\t\t\t\tcpu_to_le32(fifo_len + sizeof(*fifo_hdr));\n\n\t\t\tfifo_hdr->fifo_num = cpu_to_le32(i);\n\n\t\t\t/* Mark the number of TXF we're pulling now */\n\t\t\tiwl_trans_write_prph(fwrt->trans, TXF_CPU2_NUM, i +\n\t\t\t\tfwrt->smem_cfg.num_txfifo_entries);\n\n\t\t\tfifo_hdr->available_bytes =\n\t\t\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\t\t\tTXF_CPU2_FIFO_ITEM_CNT));\n\t\t\tfifo_hdr->wr_ptr =\n\t\t\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\t\t\tTXF_CPU2_WR_PTR));\n\t\t\tfifo_hdr->rd_ptr =\n\t\t\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\t\t\tTXF_CPU2_RD_PTR));\n\t\t\tfifo_hdr->fence_ptr =\n\t\t\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\t\t\tTXF_CPU2_FENCE_PTR));\n\t\t\tfifo_hdr->fence_mode =\n\t\t\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\t\t\tTXF_CPU2_LOCK_FENCE));\n\n\t\t\t/* Set TXF_CPU2_READ_MODIFY_ADDR to TXF_CPU2_WR_PTR */\n\t\t\tiwl_trans_write_prph(fwrt->trans,\n\t\t\t\t\t     TXF_CPU2_READ_MODIFY_ADDR,\n\t\t\t\t\t     TXF_CPU2_WR_PTR);\n\n\t\t\t/* Dummy-read to advance the read pointer to head */\n\t\t\tiwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t    TXF_CPU2_READ_MODIFY_DATA);\n\n\t\t\t/* Read FIFO */\n\t\t\tfifo_len /= sizeof(u32); /* Size in DWORDS */\n\t\t\tfor (j = 0; j < fifo_len; j++)\n\t\t\t\tfifo_data[j] =\n\t\t\t\t\tiwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\t\t    TXF_CPU2_READ_MODIFY_DATA);\n\t\t\t*dump_data = iwl_fw_error_next_data(*dump_data);\n\t\t}\n\t}\n\n\tiwl_trans_release_nic_access(fwrt->trans, &flags);\n}\n\n#define IWL8260_ICCM_OFFSET\t\t0x44000 /* Only for B-step */\n#define IWL8260_ICCM_LEN\t\t0xC000 /* Only for B-step */\n\nstruct iwl_prph_range {\n\tu32 start, end;\n};\n\nstatic const struct iwl_prph_range iwl_prph_dump_addr_comm[] = {\n\t{ .start = 0x00a00000, .end = 0x00a00000 },\n\t{ .start = 0x00a0000c, .end = 0x00a00024 },\n\t{ .start = 0x00a0002c, .end = 0x00a0003c },\n\t{ .start = 0x00a00410, .end = 0x00a00418 },\n\t{ .start = 0x00a00420, .end = 0x00a00420 },\n\t{ .start = 0x00a00428, .end = 0x00a00428 },\n\t{ .start = 0x00a00430, .end = 0x00a0043c },\n\t{ .start = 0x00a00444, .end = 0x00a00444 },\n\t{ .start = 0x00a004c0, .end = 0x00a004cc },\n\t{ .start = 0x00a004d8, .end = 0x00a004d8 },\n\t{ .start = 0x00a004e0, .end = 0x00a004f0 },\n\t{ .start = 0x00a00840, .end = 0x00a00840 },\n\t{ .start = 0x00a00850, .end = 0x00a00858 },\n\t{ .start = 0x00a01004, .end = 0x00a01008 },\n\t{ .start = 0x00a01010, .end = 0x00a01010 },\n\t{ .start = 0x00a01018, .end = 0x00a01018 },\n\t{ .start = 0x00a01024, .end = 0x00a01024 },\n\t{ .start = 0x00a0102c, .end = 0x00a01034 },\n\t{ .start = 0x00a0103c, .end = 0x00a01040 },\n\t{ .start = 0x00a01048, .end = 0x00a01094 },\n\t{ .start = 0x00a01c00, .end = 0x00a01c20 },\n\t{ .start = 0x00a01c58, .end = 0x00a01c58 },\n\t{ .start = 0x00a01c7c, .end = 0x00a01c7c },\n\t{ .start = 0x00a01c28, .end = 0x00a01c54 },\n\t{ .start = 0x00a01c5c, .end = 0x00a01c5c },\n\t{ .start = 0x00a01c60, .end = 0x00a01cdc },\n\t{ .start = 0x00a01ce0, .end = 0x00a01d0c },\n\t{ .start = 0x00a01d18, .end = 0x00a01d20 },\n\t{ .start = 0x00a01d2c, .end = 0x00a01d30 },\n\t{ .start = 0x00a01d40, .end = 0x00a01d5c },\n\t{ .start = 0x00a01d80, .end = 0x00a01d80 },\n\t{ .start = 0x00a01d98, .end = 0x00a01d9c },\n\t{ .start = 0x00a01da8, .end = 0x00a01da8 },\n\t{ .start = 0x00a01db8, .end = 0x00a01df4 },\n\t{ .start = 0x00a01dc0, .end = 0x00a01dfc },\n\t{ .start = 0x00a01e00, .end = 0x00a01e2c },\n\t{ .start = 0x00a01e40, .end = 0x00a01e60 },\n\t{ .start = 0x00a01e68, .end = 0x00a01e6c },\n\t{ .start = 0x00a01e74, .end = 0x00a01e74 },\n\t{ .start = 0x00a01e84, .end = 0x00a01e90 },\n\t{ .start = 0x00a01e9c, .end = 0x00a01ec4 },\n\t{ .start = 0x00a01ed0, .end = 0x00a01ee0 },\n\t{ .start = 0x00a01f00, .end = 0x00a01f1c },\n\t{ .start = 0x00a01f44, .end = 0x00a01ffc },\n\t{ .start = 0x00a02000, .end = 0x00a02048 },\n\t{ .start = 0x00a02068, .end = 0x00a020f0 },\n\t{ .start = 0x00a02100, .end = 0x00a02118 },\n\t{ .start = 0x00a02140, .end = 0x00a0214c },\n\t{ .start = 0x00a02168, .end = 0x00a0218c },\n\t{ .start = 0x00a021c0, .end = 0x00a021c0 },\n\t{ .start = 0x00a02400, .end = 0x00a02410 },\n\t{ .start = 0x00a02418, .end = 0x00a02420 },\n\t{ .start = 0x00a02428, .end = 0x00a0242c },\n\t{ .start = 0x00a02434, .end = 0x00a02434 },\n\t{ .start = 0x00a02440, .end = 0x00a02460 },\n\t{ .start = 0x00a02468, .end = 0x00a024b0 },\n\t{ .start = 0x00a024c8, .end = 0x00a024cc },\n\t{ .start = 0x00a02500, .end = 0x00a02504 },\n\t{ .start = 0x00a0250c, .end = 0x00a02510 },\n\t{ .start = 0x00a02540, .end = 0x00a02554 },\n\t{ .start = 0x00a02580, .end = 0x00a025f4 },\n\t{ .start = 0x00a02600, .end = 0x00a0260c },\n\t{ .start = 0x00a02648, .end = 0x00a02650 },\n\t{ .start = 0x00a02680, .end = 0x00a02680 },\n\t{ .start = 0x00a026c0, .end = 0x00a026d0 },\n\t{ .start = 0x00a02700, .end = 0x00a0270c },\n\t{ .start = 0x00a02804, .end = 0x00a02804 },\n\t{ .start = 0x00a02818, .end = 0x00a0281c },\n\t{ .start = 0x00a02c00, .end = 0x00a02db4 },\n\t{ .start = 0x00a02df4, .end = 0x00a02fb0 },\n\t{ .start = 0x00a03000, .end = 0x00a03014 },\n\t{ .start = 0x00a0301c, .end = 0x00a0302c },\n\t{ .start = 0x00a03034, .end = 0x00a03038 },\n\t{ .start = 0x00a03040, .end = 0x00a03048 },\n\t{ .start = 0x00a03060, .end = 0x00a03068 },\n\t{ .start = 0x00a03070, .end = 0x00a03074 },\n\t{ .start = 0x00a0307c, .end = 0x00a0307c },\n\t{ .start = 0x00a03080, .end = 0x00a03084 },\n\t{ .start = 0x00a0308c, .end = 0x00a03090 },\n\t{ .start = 0x00a03098, .end = 0x00a03098 },\n\t{ .start = 0x00a030a0, .end = 0x00a030a0 },\n\t{ .start = 0x00a030a8, .end = 0x00a030b4 },\n\t{ .start = 0x00a030bc, .end = 0x00a030bc },\n\t{ .start = 0x00a030c0, .end = 0x00a0312c },\n\t{ .start = 0x00a03c00, .end = 0x00a03c5c },\n\t{ .start = 0x00a04400, .end = 0x00a04454 },\n\t{ .start = 0x00a04460, .end = 0x00a04474 },\n\t{ .start = 0x00a044c0, .end = 0x00a044ec },\n\t{ .start = 0x00a04500, .end = 0x00a04504 },\n\t{ .start = 0x00a04510, .end = 0x00a04538 },\n\t{ .start = 0x00a04540, .end = 0x00a04548 },\n\t{ .start = 0x00a04560, .end = 0x00a0457c },\n\t{ .start = 0x00a04590, .end = 0x00a04598 },\n\t{ .start = 0x00a045c0, .end = 0x00a045f4 },\n};\n\nstatic const struct iwl_prph_range iwl_prph_dump_addr_9000[] = {\n\t{ .start = 0x00a05c00, .end = 0x00a05c18 },\n\t{ .start = 0x00a05400, .end = 0x00a056e8 },\n\t{ .start = 0x00a08000, .end = 0x00a098bc },\n\t{ .start = 0x00a02400, .end = 0x00a02758 },\n\t{ .start = 0x00a04764, .end = 0x00a0476c },\n\t{ .start = 0x00a04770, .end = 0x00a04774 },\n\t{ .start = 0x00a04620, .end = 0x00a04624 },\n};\n\nstatic const struct iwl_prph_range iwl_prph_dump_addr_22000[] = {\n\t{ .start = 0x00a00000, .end = 0x00a00000 },\n\t{ .start = 0x00a0000c, .end = 0x00a00024 },\n\t{ .start = 0x00a0002c, .end = 0x00a00034 },\n\t{ .start = 0x00a0003c, .end = 0x00a0003c },\n\t{ .start = 0x00a00410, .end = 0x00a00418 },\n\t{ .start = 0x00a00420, .end = 0x00a00420 },\n\t{ .start = 0x00a00428, .end = 0x00a00428 },\n\t{ .start = 0x00a00430, .end = 0x00a0043c },\n\t{ .start = 0x00a00444, .end = 0x00a00444 },\n\t{ .start = 0x00a00840, .end = 0x00a00840 },\n\t{ .start = 0x00a00850, .end = 0x00a00858 },\n\t{ .start = 0x00a01004, .end = 0x00a01008 },\n\t{ .start = 0x00a01010, .end = 0x00a01010 },\n\t{ .start = 0x00a01018, .end = 0x00a01018 },\n\t{ .start = 0x00a01024, .end = 0x00a01024 },\n\t{ .start = 0x00a0102c, .end = 0x00a01034 },\n\t{ .start = 0x00a0103c, .end = 0x00a01040 },\n\t{ .start = 0x00a01048, .end = 0x00a01050 },\n\t{ .start = 0x00a01058, .end = 0x00a01058 },\n\t{ .start = 0x00a01060, .end = 0x00a01070 },\n\t{ .start = 0x00a0108c, .end = 0x00a0108c },\n\t{ .start = 0x00a01c20, .end = 0x00a01c28 },\n\t{ .start = 0x00a01d10, .end = 0x00a01d10 },\n\t{ .start = 0x00a01e28, .end = 0x00a01e2c },\n\t{ .start = 0x00a01e60, .end = 0x00a01e60 },\n\t{ .start = 0x00a01e80, .end = 0x00a01e80 },\n\t{ .start = 0x00a01ea0, .end = 0x00a01ea0 },\n\t{ .start = 0x00a02000, .end = 0x00a0201c },\n\t{ .start = 0x00a02024, .end = 0x00a02024 },\n\t{ .start = 0x00a02040, .end = 0x00a02048 },\n\t{ .start = 0x00a020c0, .end = 0x00a020e0 },\n\t{ .start = 0x00a02400, .end = 0x00a02404 },\n\t{ .start = 0x00a0240c, .end = 0x00a02414 },\n\t{ .start = 0x00a0241c, .end = 0x00a0243c },\n\t{ .start = 0x00a02448, .end = 0x00a024bc },\n\t{ .start = 0x00a024c4, .end = 0x00a024cc },\n\t{ .start = 0x00a02508, .end = 0x00a02508 },\n\t{ .start = 0x00a02510, .end = 0x00a02514 },\n\t{ .start = 0x00a0251c, .end = 0x00a0251c },\n\t{ .start = 0x00a0252c, .end = 0x00a0255c },\n\t{ .start = 0x00a02564, .end = 0x00a025a0 },\n\t{ .start = 0x00a025a8, .end = 0x00a025b4 },\n\t{ .start = 0x00a025c0, .end = 0x00a025c0 },\n\t{ .start = 0x00a025e8, .end = 0x00a025f4 },\n\t{ .start = 0x00a02c08, .end = 0x00a02c18 },\n\t{ .start = 0x00a02c2c, .end = 0x00a02c38 },\n\t{ .start = 0x00a02c68, .end = 0x00a02c78 },\n\t{ .start = 0x00a03000, .end = 0x00a03000 },\n\t{ .start = 0x00a03010, .end = 0x00a03014 },\n\t{ .start = 0x00a0301c, .end = 0x00a0302c },\n\t{ .start = 0x00a03034, .end = 0x00a03038 },\n\t{ .start = 0x00a03040, .end = 0x00a03044 },\n\t{ .start = 0x00a03060, .end = 0x00a03068 },\n\t{ .start = 0x00a03070, .end = 0x00a03070 },\n\t{ .start = 0x00a0307c, .end = 0x00a03084 },\n\t{ .start = 0x00a0308c, .end = 0x00a03090 },\n\t{ .start = 0x00a03098, .end = 0x00a03098 },\n\t{ .start = 0x00a030a0, .end = 0x00a030a0 },\n\t{ .start = 0x00a030a8, .end = 0x00a030b4 },\n\t{ .start = 0x00a030bc, .end = 0x00a030c0 },\n\t{ .start = 0x00a030c8, .end = 0x00a030f4 },\n\t{ .start = 0x00a03100, .end = 0x00a0312c },\n\t{ .start = 0x00a03c00, .end = 0x00a03c5c },\n\t{ .start = 0x00a04400, .end = 0x00a04454 },\n\t{ .start = 0x00a04460, .end = 0x00a04474 },\n\t{ .start = 0x00a044c0, .end = 0x00a044ec },\n\t{ .start = 0x00a04500, .end = 0x00a04504 },\n\t{ .start = 0x00a04510, .end = 0x00a04538 },\n\t{ .start = 0x00a04540, .end = 0x00a04548 },\n\t{ .start = 0x00a04560, .end = 0x00a04560 },\n\t{ .start = 0x00a04570, .end = 0x00a0457c },\n\t{ .start = 0x00a04590, .end = 0x00a04590 },\n\t{ .start = 0x00a04598, .end = 0x00a04598 },\n\t{ .start = 0x00a045c0, .end = 0x00a045f4 },\n\t{ .start = 0x00a05c18, .end = 0x00a05c1c },\n\t{ .start = 0x00a0c000, .end = 0x00a0c018 },\n\t{ .start = 0x00a0c020, .end = 0x00a0c028 },\n\t{ .start = 0x00a0c038, .end = 0x00a0c094 },\n\t{ .start = 0x00a0c0c0, .end = 0x00a0c104 },\n\t{ .start = 0x00a0c10c, .end = 0x00a0c118 },\n\t{ .start = 0x00a0c150, .end = 0x00a0c174 },\n\t{ .start = 0x00a0c17c, .end = 0x00a0c188 },\n\t{ .start = 0x00a0c190, .end = 0x00a0c198 },\n\t{ .start = 0x00a0c1a0, .end = 0x00a0c1a8 },\n\t{ .start = 0x00a0c1b0, .end = 0x00a0c1b8 },\n};\n\nstatic const struct iwl_prph_range iwl_prph_dump_addr_ax210[] = {\n\t{ .start = 0x00d03c00, .end = 0x00d03c64 },\n\t{ .start = 0x00d05c18, .end = 0x00d05c1c },\n\t{ .start = 0x00d0c000, .end = 0x00d0c174 },\n};\n\nstatic void iwl_read_prph_block(struct iwl_trans *trans, u32 start,\n\t\t\t\tu32 len_bytes, __le32 *data)\n{\n\tu32 i;\n\n\tfor (i = 0; i < len_bytes; i += 4)\n\t\t*data++ = cpu_to_le32(iwl_read_prph_no_grab(trans, start + i));\n}\n\nstatic void iwl_dump_prph(struct iwl_fw_runtime *fwrt,\n\t\t\t  const struct iwl_prph_range *iwl_prph_dump_addr,\n\t\t\t  u32 range_len, void *ptr)\n{\n\tstruct iwl_fw_error_dump_prph *prph;\n\tstruct iwl_trans *trans = fwrt->trans;\n\tstruct iwl_fw_error_dump_data **data =\n\t\t(struct iwl_fw_error_dump_data **)ptr;\n\tunsigned long flags;\n\tu32 i;\n\n\tif (!data)\n\t\treturn;\n\n\tIWL_DEBUG_INFO(trans, \"WRT PRPH dump\\n\");\n\n\tif (!iwl_trans_grab_nic_access(trans, &flags))\n\t\treturn;\n\n\tfor (i = 0; i < range_len; i++) {\n\t\t/* The range includes both boundaries */\n\t\tint num_bytes_in_chunk = iwl_prph_dump_addr[i].end -\n\t\t\t iwl_prph_dump_addr[i].start + 4;\n\n\t\t(*data)->type = cpu_to_le32(IWL_FW_ERROR_DUMP_PRPH);\n\t\t(*data)->len = cpu_to_le32(sizeof(*prph) +\n\t\t\t\t\tnum_bytes_in_chunk);\n\t\tprph = (void *)(*data)->data;\n\t\tprph->prph_start = cpu_to_le32(iwl_prph_dump_addr[i].start);\n\n\t\tiwl_read_prph_block(trans, iwl_prph_dump_addr[i].start,\n\t\t\t\t    /* our range is inclusive, hence + 4 */\n\t\t\t\t    iwl_prph_dump_addr[i].end -\n\t\t\t\t    iwl_prph_dump_addr[i].start + 4,\n\t\t\t\t    (void *)prph->data);\n\n\t\t*data = iwl_fw_error_next_data(*data);\n\t}\n\n\tiwl_trans_release_nic_access(trans, &flags);\n}\n\n/*\n * alloc_sgtable - allocates scallerlist table in the given size,\n * fills it with pages and returns it\n * @size: the size (in bytes) of the table\n*/\nstatic struct scatterlist *alloc_sgtable(int size)\n{\n\tint alloc_size, nents, i;\n\tstruct page *new_page;\n\tstruct scatterlist *iter;\n\tstruct scatterlist *table;\n\n\tnents = DIV_ROUND_UP(size, PAGE_SIZE);\n\ttable = kcalloc(nents, sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\treturn NULL;\n\tsg_init_table(table, nents);\n\titer = table;\n\tfor_each_sg(table, iter, sg_nents(table), i) {\n\t\tnew_page = alloc_page(GFP_KERNEL);\n\t\tif (!new_page) {\n\t\t\t/* release all previous allocated pages in the table */\n\t\t\titer = table;\n\t\t\tfor_each_sg(table, iter, sg_nents(table), i) {\n\t\t\t\tnew_page = sg_page(iter);\n\t\t\t\tif (new_page)\n\t\t\t\t\t__free_page(new_page);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\talloc_size = min_t(int, size, PAGE_SIZE);\n\t\tsize -= PAGE_SIZE;\n\t\tsg_set_page(iter, new_page, alloc_size, 0);\n\t}\n\treturn table;\n}\n\nstatic void iwl_fw_get_prph_len(struct iwl_fw_runtime *fwrt,\n\t\t\t\tconst struct iwl_prph_range *iwl_prph_dump_addr,\n\t\t\t\tu32 range_len, void *ptr)\n{\n\tu32 *prph_len = (u32 *)ptr;\n\tint i, num_bytes_in_chunk;\n\n\tif (!prph_len)\n\t\treturn;\n\n\tfor (i = 0; i < range_len; i++) {\n\t\t/* The range includes both boundaries */\n\t\tnum_bytes_in_chunk =\n\t\t\tiwl_prph_dump_addr[i].end -\n\t\t\tiwl_prph_dump_addr[i].start + 4;\n\n\t\t*prph_len += sizeof(struct iwl_fw_error_dump_data) +\n\t\t\tsizeof(struct iwl_fw_error_dump_prph) +\n\t\t\tnum_bytes_in_chunk;\n\t}\n}\n\nstatic void iwl_fw_prph_handler(struct iwl_fw_runtime *fwrt, void *ptr,\n\t\t\t\tvoid (*handler)(struct iwl_fw_runtime *,\n\t\t\t\t\t\tconst struct iwl_prph_range *,\n\t\t\t\t\t\tu32, void *))\n{\n\tu32 range_len;\n\n\tif (fwrt->trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_AX210) {\n\t\trange_len = ARRAY_SIZE(iwl_prph_dump_addr_ax210);\n\t\thandler(fwrt, iwl_prph_dump_addr_ax210, range_len, ptr);\n\t} else if (fwrt->trans->trans_cfg->device_family >=\n\t\t   IWL_DEVICE_FAMILY_22000) {\n\t\trange_len = ARRAY_SIZE(iwl_prph_dump_addr_22000);\n\t\thandler(fwrt, iwl_prph_dump_addr_22000, range_len, ptr);\n\t} else {\n\t\trange_len = ARRAY_SIZE(iwl_prph_dump_addr_comm);\n\t\thandler(fwrt, iwl_prph_dump_addr_comm, range_len, ptr);\n\n\t\tif (fwrt->trans->trans_cfg->mq_rx_supported) {\n\t\t\trange_len = ARRAY_SIZE(iwl_prph_dump_addr_9000);\n\t\t\thandler(fwrt, iwl_prph_dump_addr_9000, range_len, ptr);\n\t\t}\n\t}\n}\n\nstatic void iwl_fw_dump_mem(struct iwl_fw_runtime *fwrt,\n\t\t\t    struct iwl_fw_error_dump_data **dump_data,\n\t\t\t    u32 len, u32 ofs, u32 type)\n{\n\tstruct iwl_fw_error_dump_mem *dump_mem;\n\n\tif (!len)\n\t\treturn;\n\n\t(*dump_data)->type = cpu_to_le32(IWL_FW_ERROR_DUMP_MEM);\n\t(*dump_data)->len = cpu_to_le32(len + sizeof(*dump_mem));\n\tdump_mem = (void *)(*dump_data)->data;\n\tdump_mem->type = cpu_to_le32(type);\n\tdump_mem->offset = cpu_to_le32(ofs);\n\tiwl_trans_read_mem_bytes(fwrt->trans, ofs, dump_mem->data, len);\n\t*dump_data = iwl_fw_error_next_data(*dump_data);\n\n\tIWL_DEBUG_INFO(fwrt, \"WRT memory dump. Type=%u\\n\", dump_mem->type);\n}\n\n#define ADD_LEN(len, item_len, const_len) \\\n\tdo {size_t item = item_len; len += (!!item) * const_len + item; } \\\n\twhile (0)\n\nstatic int iwl_fw_rxf_len(struct iwl_fw_runtime *fwrt,\n\t\t\t  struct iwl_fwrt_shared_mem_cfg *mem_cfg)\n{\n\tsize_t hdr_len = sizeof(struct iwl_fw_error_dump_data) +\n\t\t\t sizeof(struct iwl_fw_error_dump_fifo);\n\tu32 fifo_len = 0;\n\tint i;\n\n\tif (!iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_RXF))\n\t\treturn 0;\n\n\t/* Count RXF2 size */\n\tADD_LEN(fifo_len, mem_cfg->rxfifo2_size, hdr_len);\n\n\t/* Count RXF1 sizes */\n\tif (WARN_ON(mem_cfg->num_lmacs > MAX_NUM_LMAC))\n\t\tmem_cfg->num_lmacs = MAX_NUM_LMAC;\n\n\tfor (i = 0; i < mem_cfg->num_lmacs; i++)\n\t\tADD_LEN(fifo_len, mem_cfg->lmac[i].rxfifo1_size, hdr_len);\n\n\treturn fifo_len;\n}\n\nstatic int iwl_fw_txf_len(struct iwl_fw_runtime *fwrt,\n\t\t\t  struct iwl_fwrt_shared_mem_cfg *mem_cfg)\n{\n\tsize_t hdr_len = sizeof(struct iwl_fw_error_dump_data) +\n\t\t\t sizeof(struct iwl_fw_error_dump_fifo);\n\tu32 fifo_len = 0;\n\tint i;\n\n\tif (!iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_TXF))\n\t\tgoto dump_internal_txf;\n\n\t/* Count TXF sizes */\n\tif (WARN_ON(mem_cfg->num_lmacs > MAX_NUM_LMAC))\n\t\tmem_cfg->num_lmacs = MAX_NUM_LMAC;\n\n\tfor (i = 0; i < mem_cfg->num_lmacs; i++) {\n\t\tint j;\n\n\t\tfor (j = 0; j < mem_cfg->num_txfifo_entries; j++)\n\t\t\tADD_LEN(fifo_len, mem_cfg->lmac[i].txfifo_size[j],\n\t\t\t\thdr_len);\n\t}\n\ndump_internal_txf:\n\tif (!(iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_INTERNAL_TXF) &&\n\t      fw_has_capa(&fwrt->fw->ucode_capa,\n\t\t\t  IWL_UCODE_TLV_CAPA_EXTEND_SHARED_MEM_CFG)))\n\t\tgoto out;\n\n\tfor (i = 0; i < ARRAY_SIZE(mem_cfg->internal_txfifo_size); i++)\n\t\tADD_LEN(fifo_len, mem_cfg->internal_txfifo_size[i], hdr_len);\n\nout:\n\treturn fifo_len;\n}\n\nstatic void iwl_dump_paging(struct iwl_fw_runtime *fwrt,\n\t\t\t    struct iwl_fw_error_dump_data **data)\n{\n\tint i;\n\n\tIWL_DEBUG_INFO(fwrt, \"WRT paging dump\\n\");\n\tfor (i = 1; i < fwrt->num_of_paging_blk + 1; i++) {\n\t\tstruct iwl_fw_error_dump_paging *paging;\n\t\tstruct page *pages =\n\t\t\tfwrt->fw_paging_db[i].fw_paging_block;\n\t\tdma_addr_t addr = fwrt->fw_paging_db[i].fw_paging_phys;\n\n\t\t(*data)->type = cpu_to_le32(IWL_FW_ERROR_DUMP_PAGING);\n\t\t(*data)->len = cpu_to_le32(sizeof(*paging) +\n\t\t\t\t\t     PAGING_BLOCK_SIZE);\n\t\tpaging =  (void *)(*data)->data;\n\t\tpaging->index = cpu_to_le32(i);\n\t\tdma_sync_single_for_cpu(fwrt->trans->dev, addr,\n\t\t\t\t\tPAGING_BLOCK_SIZE,\n\t\t\t\t\tDMA_BIDIRECTIONAL);\n\t\tmemcpy(paging->data, page_address(pages),\n\t\t       PAGING_BLOCK_SIZE);\n\t\tdma_sync_single_for_device(fwrt->trans->dev, addr,\n\t\t\t\t\t   PAGING_BLOCK_SIZE,\n\t\t\t\t\t   DMA_BIDIRECTIONAL);\n\t\t(*data) = iwl_fw_error_next_data(*data);\n\t}\n}\n\nstatic struct iwl_fw_error_dump_file *\niwl_fw_error_dump_file(struct iwl_fw_runtime *fwrt,\n\t\t       struct iwl_fw_dump_ptrs *fw_error_dump)\n{\n\tstruct iwl_fw_error_dump_file *dump_file;\n\tstruct iwl_fw_error_dump_data *dump_data;\n\tstruct iwl_fw_error_dump_info *dump_info;\n\tstruct iwl_fw_error_dump_smem_cfg *dump_smem_cfg;\n\tstruct iwl_fw_error_dump_trigger_desc *dump_trig;\n\tu32 sram_len, sram_ofs;\n\tconst struct iwl_fw_dbg_mem_seg_tlv *fw_mem = fwrt->fw->dbg.mem_tlv;\n\tstruct iwl_fwrt_shared_mem_cfg *mem_cfg = &fwrt->smem_cfg;\n\tu32 file_len, fifo_len = 0, prph_len = 0, radio_len = 0;\n\tu32 smem_len = fwrt->fw->dbg.n_mem_tlv ? 0 : fwrt->trans->cfg->smem_len;\n\tu32 sram2_len = fwrt->fw->dbg.n_mem_tlv ?\n\t\t\t\t0 : fwrt->trans->cfg->dccm2_len;\n\tint i;\n\n\t/* SRAM - include stack CCM if driver knows the values for it */\n\tif (!fwrt->trans->cfg->dccm_offset || !fwrt->trans->cfg->dccm_len) {\n\t\tconst struct fw_img *img;\n\n\t\tif (fwrt->cur_fw_img >= IWL_UCODE_TYPE_MAX)\n\t\t\treturn NULL;\n\t\timg = &fwrt->fw->img[fwrt->cur_fw_img];\n\t\tsram_ofs = img->sec[IWL_UCODE_SECTION_DATA].offset;\n\t\tsram_len = img->sec[IWL_UCODE_SECTION_DATA].len;\n\t} else {\n\t\tsram_ofs = fwrt->trans->cfg->dccm_offset;\n\t\tsram_len = fwrt->trans->cfg->dccm_len;\n\t}\n\n\t/* reading RXF/TXF sizes */\n\tif (test_bit(STATUS_FW_ERROR, &fwrt->trans->status)) {\n\t\tfifo_len = iwl_fw_rxf_len(fwrt, mem_cfg);\n\t\tfifo_len += iwl_fw_txf_len(fwrt, mem_cfg);\n\n\t\t/* Make room for PRPH registers */\n\t\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_PRPH))\n\t\t\tiwl_fw_prph_handler(fwrt, &prph_len,\n\t\t\t\t\t    iwl_fw_get_prph_len);\n\n\t\tif (fwrt->trans->trans_cfg->device_family ==\n\t\t    IWL_DEVICE_FAMILY_7000 &&\n\t\t    iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_RADIO_REG))\n\t\t\tradio_len = sizeof(*dump_data) + RADIO_REG_MAX_READ;\n\t}\n\n\tfile_len = sizeof(*dump_file) + fifo_len + prph_len + radio_len;\n\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_DEV_FW_INFO))\n\t\tfile_len += sizeof(*dump_data) + sizeof(*dump_info);\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_MEM_CFG))\n\t\tfile_len += sizeof(*dump_data) + sizeof(*dump_smem_cfg);\n\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_MEM)) {\n\t\tsize_t hdr_len = sizeof(*dump_data) +\n\t\t\t\t sizeof(struct iwl_fw_error_dump_mem);\n\n\t\t/* Dump SRAM only if no mem_tlvs */\n\t\tif (!fwrt->fw->dbg.n_mem_tlv)\n\t\t\tADD_LEN(file_len, sram_len, hdr_len);\n\n\t\t/* Make room for all mem types that exist */\n\t\tADD_LEN(file_len, smem_len, hdr_len);\n\t\tADD_LEN(file_len, sram2_len, hdr_len);\n\n\t\tfor (i = 0; i < fwrt->fw->dbg.n_mem_tlv; i++)\n\t\t\tADD_LEN(file_len, le32_to_cpu(fw_mem[i].len), hdr_len);\n\t}\n\n\t/* Make room for fw's virtual image pages, if it exists */\n\tif (iwl_fw_dbg_is_paging_enabled(fwrt))\n\t\tfile_len += fwrt->num_of_paging_blk *\n\t\t\t(sizeof(*dump_data) +\n\t\t\t sizeof(struct iwl_fw_error_dump_paging) +\n\t\t\t PAGING_BLOCK_SIZE);\n\n\tif (iwl_fw_dbg_is_d3_debug_enabled(fwrt) && fwrt->dump.d3_debug_data) {\n\t\tfile_len += sizeof(*dump_data) +\n\t\t\tfwrt->trans->cfg->d3_debug_data_length * 2;\n\t}\n\n\t/* If we only want a monitor dump, reset the file length */\n\tif (fwrt->dump.monitor_only) {\n\t\tfile_len = sizeof(*dump_file) + sizeof(*dump_data) * 2 +\n\t\t\t   sizeof(*dump_info) + sizeof(*dump_smem_cfg);\n\t}\n\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_ERROR_INFO) &&\n\t    fwrt->dump.desc)\n\t\tfile_len += sizeof(*dump_data) + sizeof(*dump_trig) +\n\t\t\t    fwrt->dump.desc->len;\n\n\tdump_file = vzalloc(file_len);\n\tif (!dump_file)\n\t\treturn NULL;\n\n\tfw_error_dump->fwrt_ptr = dump_file;\n\n\tdump_file->barker = cpu_to_le32(IWL_FW_ERROR_DUMP_BARKER);\n\tdump_data = (void *)dump_file->data;\n\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_DEV_FW_INFO)) {\n\t\tdump_data->type = cpu_to_le32(IWL_FW_ERROR_DUMP_DEV_FW_INFO);\n\t\tdump_data->len = cpu_to_le32(sizeof(*dump_info));\n\t\tdump_info = (void *)dump_data->data;\n\t\tdump_info->hw_type =\n\t\t\tcpu_to_le32(CSR_HW_REV_TYPE(fwrt->trans->hw_rev));\n\t\tdump_info->hw_step =\n\t\t\tcpu_to_le32(CSR_HW_REV_STEP(fwrt->trans->hw_rev));\n\t\tmemcpy(dump_info->fw_human_readable, fwrt->fw->human_readable,\n\t\t       sizeof(dump_info->fw_human_readable));\n\t\tstrncpy(dump_info->dev_human_readable, fwrt->trans->cfg->name,\n\t\t\tsizeof(dump_info->dev_human_readable) - 1);\n\t\tstrncpy(dump_info->bus_human_readable, fwrt->dev->bus->name,\n\t\t\tsizeof(dump_info->bus_human_readable) - 1);\n\t\tdump_info->num_of_lmacs = fwrt->smem_cfg.num_lmacs;\n\t\tdump_info->lmac_err_id[0] =\n\t\t\tcpu_to_le32(fwrt->dump.lmac_err_id[0]);\n\t\tif (fwrt->smem_cfg.num_lmacs > 1)\n\t\t\tdump_info->lmac_err_id[1] =\n\t\t\t\tcpu_to_le32(fwrt->dump.lmac_err_id[1]);\n\t\tdump_info->umac_err_id = cpu_to_le32(fwrt->dump.umac_err_id);\n\n\t\tdump_data = iwl_fw_error_next_data(dump_data);\n\t}\n\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_MEM_CFG)) {\n\t\t/* Dump shared memory configuration */\n\t\tdump_data->type = cpu_to_le32(IWL_FW_ERROR_DUMP_MEM_CFG);\n\t\tdump_data->len = cpu_to_le32(sizeof(*dump_smem_cfg));\n\t\tdump_smem_cfg = (void *)dump_data->data;\n\t\tdump_smem_cfg->num_lmacs = cpu_to_le32(mem_cfg->num_lmacs);\n\t\tdump_smem_cfg->num_txfifo_entries =\n\t\t\tcpu_to_le32(mem_cfg->num_txfifo_entries);\n\t\tfor (i = 0; i < MAX_NUM_LMAC; i++) {\n\t\t\tint j;\n\t\t\tu32 *txf_size = mem_cfg->lmac[i].txfifo_size;\n\n\t\t\tfor (j = 0; j < TX_FIFO_MAX_NUM; j++)\n\t\t\t\tdump_smem_cfg->lmac[i].txfifo_size[j] =\n\t\t\t\t\tcpu_to_le32(txf_size[j]);\n\t\t\tdump_smem_cfg->lmac[i].rxfifo1_size =\n\t\t\t\tcpu_to_le32(mem_cfg->lmac[i].rxfifo1_size);\n\t\t}\n\t\tdump_smem_cfg->rxfifo2_size =\n\t\t\tcpu_to_le32(mem_cfg->rxfifo2_size);\n\t\tdump_smem_cfg->internal_txfifo_addr =\n\t\t\tcpu_to_le32(mem_cfg->internal_txfifo_addr);\n\t\tfor (i = 0; i < TX_FIFO_INTERNAL_MAX_NUM; i++) {\n\t\t\tdump_smem_cfg->internal_txfifo_size[i] =\n\t\t\t\tcpu_to_le32(mem_cfg->internal_txfifo_size[i]);\n\t\t}\n\n\t\tdump_data = iwl_fw_error_next_data(dump_data);\n\t}\n\n\t/* We only dump the FIFOs if the FW is in error state */\n\tif (fifo_len) {\n\t\tiwl_fw_dump_rxf(fwrt, &dump_data);\n\t\tiwl_fw_dump_txf(fwrt, &dump_data);\n\t}\n\n\tif (radio_len)\n\t\tiwl_read_radio_regs(fwrt, &dump_data);\n\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_ERROR_INFO) &&\n\t    fwrt->dump.desc) {\n\t\tdump_data->type = cpu_to_le32(IWL_FW_ERROR_DUMP_ERROR_INFO);\n\t\tdump_data->len = cpu_to_le32(sizeof(*dump_trig) +\n\t\t\t\t\t     fwrt->dump.desc->len);\n\t\tdump_trig = (void *)dump_data->data;\n\t\tmemcpy(dump_trig, &fwrt->dump.desc->trig_desc,\n\t\t       sizeof(*dump_trig) + fwrt->dump.desc->len);\n\n\t\tdump_data = iwl_fw_error_next_data(dump_data);\n\t}\n\n\t/* In case we only want monitor dump, skip to dump trasport data */\n\tif (fwrt->dump.monitor_only)\n\t\tgoto out;\n\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_MEM)) {\n\t\tconst struct iwl_fw_dbg_mem_seg_tlv *fw_dbg_mem =\n\t\t\tfwrt->fw->dbg.mem_tlv;\n\n\t\tif (!fwrt->fw->dbg.n_mem_tlv)\n\t\t\tiwl_fw_dump_mem(fwrt, &dump_data, sram_len, sram_ofs,\n\t\t\t\t\tIWL_FW_ERROR_DUMP_MEM_SRAM);\n\n\t\tfor (i = 0; i < fwrt->fw->dbg.n_mem_tlv; i++) {\n\t\t\tu32 len = le32_to_cpu(fw_dbg_mem[i].len);\n\t\t\tu32 ofs = le32_to_cpu(fw_dbg_mem[i].ofs);\n\n\t\t\tiwl_fw_dump_mem(fwrt, &dump_data, len, ofs,\n\t\t\t\t\tle32_to_cpu(fw_dbg_mem[i].data_type));\n\t\t}\n\n\t\tiwl_fw_dump_mem(fwrt, &dump_data, smem_len,\n\t\t\t\tfwrt->trans->cfg->smem_offset,\n\t\t\t\tIWL_FW_ERROR_DUMP_MEM_SMEM);\n\n\t\tiwl_fw_dump_mem(fwrt, &dump_data, sram2_len,\n\t\t\t\tfwrt->trans->cfg->dccm2_offset,\n\t\t\t\tIWL_FW_ERROR_DUMP_MEM_SRAM);\n\t}\n\n\tif (iwl_fw_dbg_is_d3_debug_enabled(fwrt) && fwrt->dump.d3_debug_data) {\n\t\tu32 addr = fwrt->trans->cfg->d3_debug_data_base_addr;\n\t\tsize_t data_size = fwrt->trans->cfg->d3_debug_data_length;\n\n\t\tdump_data->type = cpu_to_le32(IWL_FW_ERROR_DUMP_D3_DEBUG_DATA);\n\t\tdump_data->len = cpu_to_le32(data_size * 2);\n\n\t\tmemcpy(dump_data->data, fwrt->dump.d3_debug_data, data_size);\n\n\t\tkfree(fwrt->dump.d3_debug_data);\n\t\tfwrt->dump.d3_debug_data = NULL;\n\n\t\tiwl_trans_read_mem_bytes(fwrt->trans, addr,\n\t\t\t\t\t dump_data->data + data_size,\n\t\t\t\t\t data_size);\n\n\t\tdump_data = iwl_fw_error_next_data(dump_data);\n\t}\n\n\t/* Dump fw's virtual image */\n\tif (iwl_fw_dbg_is_paging_enabled(fwrt))\n\t\tiwl_dump_paging(fwrt, &dump_data);\n\n\tif (prph_len)\n\t\tiwl_fw_prph_handler(fwrt, &dump_data, iwl_dump_prph);\n\nout:\n\tdump_file->file_len = cpu_to_le32(file_len);\n\treturn dump_file;\n}\n\nstatic int iwl_dump_ini_prph_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t\t  struct iwl_fw_ini_region_cfg *reg,\n\t\t\t\t  void *range_ptr, int idx)\n{\n\tstruct iwl_fw_ini_error_dump_range *range = range_ptr;\n\t__le32 *val = range->data;\n\tu32 prph_val;\n\tu32 addr = le32_to_cpu(reg->start_addr[idx]) + le32_to_cpu(reg->offset);\n\tint i;\n\n\trange->internal_base_addr = cpu_to_le32(addr);\n\trange->range_data_size = reg->internal.range_data_size;\n\tfor (i = 0; i < le32_to_cpu(reg->internal.range_data_size); i += 4) {\n\t\tprph_val = iwl_read_prph(fwrt->trans, addr + i);\n\t\tif (prph_val == 0x5a5a5a5a)\n\t\t\treturn -EBUSY;\n\t\t*val++ = cpu_to_le32(prph_val);\n\t}\n\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstatic int iwl_dump_ini_csr_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t\t struct iwl_fw_ini_region_cfg *reg,\n\t\t\t\t void *range_ptr, int idx)\n{\n\tstruct iwl_fw_ini_error_dump_range *range = range_ptr;\n\t__le32 *val = range->data;\n\tu32 addr = le32_to_cpu(reg->start_addr[idx]) + le32_to_cpu(reg->offset);\n\tint i;\n\n\trange->internal_base_addr = cpu_to_le32(addr);\n\trange->range_data_size = reg->internal.range_data_size;\n\tfor (i = 0; i < le32_to_cpu(reg->internal.range_data_size); i += 4)\n\t\t*val++ = cpu_to_le32(iwl_trans_read32(fwrt->trans, addr + i));\n\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstatic int iwl_dump_ini_dev_mem_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t\t     struct iwl_fw_ini_region_cfg *reg,\n\t\t\t\t     void *range_ptr, int idx)\n{\n\tstruct iwl_fw_ini_error_dump_range *range = range_ptr;\n\tu32 addr = le32_to_cpu(reg->start_addr[idx]) + le32_to_cpu(reg->offset);\n\n\trange->internal_base_addr = cpu_to_le32(addr);\n\trange->range_data_size = reg->internal.range_data_size;\n\tiwl_trans_read_mem_bytes(fwrt->trans, addr, range->data,\n\t\t\t\t le32_to_cpu(reg->internal.range_data_size));\n\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstatic int _iwl_dump_ini_paging_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t\t     struct iwl_fw_ini_region_cfg *reg,\n\t\t\t\t     void *range_ptr, int idx)\n{\n\t/* increase idx by 1 since the pages are from 1 to\n\t * fwrt->num_of_paging_blk + 1\n\t */\n\tstruct page *page = fwrt->fw_paging_db[++idx].fw_paging_block;\n\tstruct iwl_fw_ini_error_dump_range *range = range_ptr;\n\tdma_addr_t addr = fwrt->fw_paging_db[idx].fw_paging_phys;\n\tu32 page_size = fwrt->fw_paging_db[idx].fw_paging_size;\n\n\trange->page_num = cpu_to_le32(idx);\n\trange->range_data_size = cpu_to_le32(page_size);\n\tdma_sync_single_for_cpu(fwrt->trans->dev, addr,\tpage_size,\n\t\t\t\tDMA_BIDIRECTIONAL);\n\tmemcpy(range->data, page_address(page), page_size);\n\tdma_sync_single_for_device(fwrt->trans->dev, addr, page_size,\n\t\t\t\t   DMA_BIDIRECTIONAL);\n\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstatic int iwl_dump_ini_paging_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t\t    struct iwl_fw_ini_region_cfg *reg,\n\t\t\t\t    void *range_ptr, int idx)\n{\n\tstruct iwl_fw_ini_error_dump_range *range;\n\tu32 page_size;\n\n\tif (!fwrt->trans->trans_cfg->gen2)\n\t\treturn _iwl_dump_ini_paging_iter(fwrt, reg, range_ptr, idx);\n\n\trange = range_ptr;\n\tpage_size = fwrt->trans->init_dram.paging[idx].size;\n\n\trange->page_num = cpu_to_le32(idx);\n\trange->range_data_size = cpu_to_le32(page_size);\n\tmemcpy(range->data, fwrt->trans->init_dram.paging[idx].block,\n\t       page_size);\n\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstatic int\niwl_dump_ini_mon_dram_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t   struct iwl_fw_ini_region_cfg *reg, void *range_ptr,\n\t\t\t   int idx)\n{\n\tstruct iwl_fw_ini_error_dump_range *range = range_ptr;\n\tu32 start_addr = iwl_read_umac_prph(fwrt->trans,\n\t\t\t\t\t    MON_BUFF_BASE_ADDR_VER2);\n\n\tif (start_addr == 0x5a5a5a5a)\n\t\treturn -EBUSY;\n\n\trange->dram_base_addr = cpu_to_le64(start_addr);\n\trange->range_data_size = cpu_to_le32(fwrt->trans->dbg.fw_mon[idx].size);\n\n\tmemcpy(range->data, fwrt->trans->dbg.fw_mon[idx].block,\n\t       fwrt->trans->dbg.fw_mon[idx].size);\n\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstatic bool iwl_ini_txf_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t     struct iwl_fw_ini_region_cfg *reg, int idx)\n{\n\tstruct iwl_txf_iter_data *iter = &fwrt->dump.txf_iter_data;\n\tstruct iwl_fwrt_shared_mem_cfg *cfg = &fwrt->smem_cfg;\n\tint txf_num = cfg->num_txfifo_entries;\n\tint int_txf_num = ARRAY_SIZE(cfg->internal_txfifo_size);\n\tu32 lmac_bitmap = le32_to_cpu(reg->fifos.fid1);\n\n\tif (!idx) {\n\t\tif (le32_to_cpu(reg->offset) &&\n\t\t    WARN_ONCE(cfg->num_lmacs == 1,\n\t\t\t      \"Invalid lmac offset: 0x%x\\n\",\n\t\t\t      le32_to_cpu(reg->offset)))\n\t\t\treturn false;\n\n\t\titer->internal_txf = 0;\n\t\titer->fifo_size = 0;\n\t\titer->fifo = -1;\n\t\tif (le32_to_cpu(reg->offset))\n\t\t\titer->lmac = 1;\n\t\telse\n\t\t\titer->lmac = 0;\n\t}\n\n\tif (!iter->internal_txf)\n\t\tfor (iter->fifo++; iter->fifo < txf_num; iter->fifo++) {\n\t\t\titer->fifo_size =\n\t\t\t\tcfg->lmac[iter->lmac].txfifo_size[iter->fifo];\n\t\t\tif (iter->fifo_size && (lmac_bitmap & BIT(iter->fifo)))\n\t\t\t\treturn true;\n\t\t}\n\n\titer->internal_txf = 1;\n\n\tif (!fw_has_capa(&fwrt->fw->ucode_capa,\n\t\t\t IWL_UCODE_TLV_CAPA_EXTEND_SHARED_MEM_CFG))\n\t\treturn false;\n\n\tfor (iter->fifo++; iter->fifo < int_txf_num + txf_num; iter->fifo++) {\n\t\titer->fifo_size =\n\t\t\tcfg->internal_txfifo_size[iter->fifo - txf_num];\n\t\tif (iter->fifo_size && (lmac_bitmap & BIT(iter->fifo)))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int iwl_dump_ini_txf_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t\t struct iwl_fw_ini_region_cfg *reg,\n\t\t\t\t void *range_ptr, int idx)\n{\n\tstruct iwl_fw_ini_error_dump_range *range = range_ptr;\n\tstruct iwl_txf_iter_data *iter = &fwrt->dump.txf_iter_data;\n\tstruct iwl_fw_ini_error_dump_register *reg_dump = (void *)range->data;\n\tu32 offs = le32_to_cpu(reg->offset), addr;\n\tu32 registers_size =\n\t\tle32_to_cpu(reg->fifos.num_of_registers) * sizeof(*reg_dump);\n\t__le32 *data;\n\tunsigned long flags;\n\tint i;\n\n\tif (!iwl_ini_txf_iter(fwrt, reg, idx))\n\t\treturn -EIO;\n\n\tif (!iwl_trans_grab_nic_access(fwrt->trans, &flags))\n\t\treturn -EBUSY;\n\n\trange->fifo_hdr.fifo_num = cpu_to_le32(iter->fifo);\n\trange->fifo_hdr.num_of_registers = reg->fifos.num_of_registers;\n\trange->range_data_size = cpu_to_le32(iter->fifo_size + registers_size);\n\n\tiwl_write_prph_no_grab(fwrt->trans, TXF_LARC_NUM + offs, iter->fifo);\n\n\t/*\n\t * read txf registers. for each register, write to the dump the\n\t * register address and its value\n\t */\n\tfor (i = 0; i < le32_to_cpu(reg->fifos.num_of_registers); i++) {\n\t\taddr = le32_to_cpu(reg->start_addr[i]) + offs;\n\n\t\treg_dump->addr = cpu_to_le32(addr);\n\t\treg_dump->data = cpu_to_le32(iwl_read_prph_no_grab(fwrt->trans,\n\t\t\t\t\t\t\t\t   addr));\n\n\t\treg_dump++;\n\t}\n\n\tif (reg->fifos.header_only) {\n\t\trange->range_data_size = cpu_to_le32(registers_size);\n\t\tgoto out;\n\t}\n\n\t/* Set the TXF_READ_MODIFY_ADDR to TXF_WR_PTR */\n\tiwl_write_prph_no_grab(fwrt->trans, TXF_READ_MODIFY_ADDR + offs,\n\t\t\t       TXF_WR_PTR + offs);\n\n\t/* Dummy-read to advance the read pointer to the head */\n\tiwl_read_prph_no_grab(fwrt->trans, TXF_READ_MODIFY_DATA + offs);\n\n\t/* Read FIFO */\n\taddr = TXF_READ_MODIFY_DATA + offs;\n\tdata = (void *)reg_dump;\n\tfor (i = 0; i < iter->fifo_size; i += sizeof(*data))\n\t\t*data++ = cpu_to_le32(iwl_read_prph_no_grab(fwrt->trans, addr));\n\nout:\n\tiwl_trans_release_nic_access(fwrt->trans, &flags);\n\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstruct iwl_ini_rxf_data {\n\tu32 fifo_num;\n\tu32 size;\n\tu32 offset;\n};\n\nstatic void iwl_ini_get_rxf_data(struct iwl_fw_runtime *fwrt,\n\t\t\t\t struct iwl_fw_ini_region_cfg *reg,\n\t\t\t\t struct iwl_ini_rxf_data *data)\n{\n\tu32 fid1 = le32_to_cpu(reg->fifos.fid1);\n\tu32 fid2 = le32_to_cpu(reg->fifos.fid2);\n\tu32 fifo_idx;\n\n\tif (!data)\n\t\treturn;\n\n\tmemset(data, 0, sizeof(*data));\n\n\tif (WARN_ON_ONCE((fid1 && fid2) || (!fid1 && !fid2)))\n\t\treturn;\n\n\tfifo_idx = ffs(fid1) - 1;\n\tif (fid1 && !WARN_ON_ONCE((~BIT(fifo_idx) & fid1) ||\n\t\t\t\t  fifo_idx >= MAX_NUM_LMAC)) {\n\t\tdata->size = fwrt->smem_cfg.lmac[fifo_idx].rxfifo1_size;\n\t\tdata->fifo_num = fifo_idx;\n\t\treturn;\n\t}\n\n\tfifo_idx = ffs(fid2) - 1;\n\tif (fid2 && !WARN_ON_ONCE(fifo_idx != 0)) {\n\t\tdata->size = fwrt->smem_cfg.rxfifo2_size;\n\t\tdata->offset = RXF_DIFF_FROM_PREV;\n\t\t/* use bit 31 to distinguish between umac and lmac rxf while\n\t\t * parsing the dump\n\t\t */\n\t\tdata->fifo_num = fifo_idx | IWL_RXF_UMAC_BIT;\n\t\treturn;\n\t}\n}\n\nstatic int iwl_dump_ini_rxf_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t\t struct iwl_fw_ini_region_cfg *reg,\n\t\t\t\t void *range_ptr, int idx)\n{\n\tstruct iwl_fw_ini_error_dump_range *range = range_ptr;\n\tstruct iwl_ini_rxf_data rxf_data;\n\tstruct iwl_fw_ini_error_dump_register *reg_dump = (void *)range->data;\n\tu32 offs = le32_to_cpu(reg->offset), addr;\n\tu32 registers_size =\n\t\tle32_to_cpu(reg->fifos.num_of_registers) * sizeof(*reg_dump);\n\t__le32 *data;\n\tunsigned long flags;\n\tint i;\n\n\tiwl_ini_get_rxf_data(fwrt, reg, &rxf_data);\n\tif (!rxf_data.size)\n\t\treturn -EIO;\n\n\tif (!iwl_trans_grab_nic_access(fwrt->trans, &flags))\n\t\treturn -EBUSY;\n\n\trange->fifo_hdr.fifo_num = cpu_to_le32(rxf_data.fifo_num);\n\trange->fifo_hdr.num_of_registers = reg->fifos.num_of_registers;\n\trange->range_data_size = cpu_to_le32(rxf_data.size + registers_size);\n\n\t/*\n\t * read rxf registers. for each register, write to the dump the\n\t * register address and its value\n\t */\n\tfor (i = 0; i < le32_to_cpu(reg->fifos.num_of_registers); i++) {\n\t\taddr = le32_to_cpu(reg->start_addr[i]) + offs;\n\n\t\treg_dump->addr = cpu_to_le32(addr);\n\t\treg_dump->data = cpu_to_le32(iwl_read_prph_no_grab(fwrt->trans,\n\t\t\t\t\t\t\t\t   addr));\n\n\t\treg_dump++;\n\t}\n\n\tif (reg->fifos.header_only) {\n\t\trange->range_data_size = cpu_to_le32(registers_size);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * region register have absolute value so apply rxf offset after\n\t * reading the registers\n\t */\n\toffs += rxf_data.offset;\n\n\t/* Lock fence */\n\tiwl_write_prph_no_grab(fwrt->trans, RXF_SET_FENCE_MODE + offs, 0x1);\n\t/* Set fence pointer to the same place like WR pointer */\n\tiwl_write_prph_no_grab(fwrt->trans, RXF_LD_WR2FENCE + offs, 0x1);\n\t/* Set fence offset */\n\tiwl_write_prph_no_grab(fwrt->trans, RXF_LD_FENCE_OFFSET_ADDR + offs,\n\t\t\t       0x0);\n\n\t/* Read FIFO */\n\taddr =  RXF_FIFO_RD_FENCE_INC + offs;\n\tdata = (void *)reg_dump;\n\tfor (i = 0; i < rxf_data.size; i += sizeof(*data))\n\t\t*data++ = cpu_to_le32(iwl_read_prph_no_grab(fwrt->trans, addr));\n\nout:\n\tiwl_trans_release_nic_access(fwrt->trans, &flags);\n\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstatic void *iwl_dump_ini_mem_fill_header(struct iwl_fw_runtime *fwrt,\n\t\t\t\t\t  struct iwl_fw_ini_region_cfg *reg,\n\t\t\t\t\t  void *data)\n{\n\tstruct iwl_fw_ini_error_dump *dump = data;\n\n\tdump->header.version = cpu_to_le32(IWL_INI_DUMP_VER);\n\n\treturn dump->ranges;\n}\n\nstatic void\n*iwl_dump_ini_mon_fill_header(struct iwl_fw_runtime *fwrt,\n\t\t\t      struct iwl_fw_ini_region_cfg *reg,\n\t\t\t      struct iwl_fw_ini_monitor_dump *data,\n\t\t\t      u32 write_ptr_addr, u32 write_ptr_msk,\n\t\t\t      u32 cycle_cnt_addr, u32 cycle_cnt_msk)\n{\n\tu32 write_ptr, cycle_cnt;\n\tunsigned long flags;\n\n\tif (!iwl_trans_grab_nic_access(fwrt->trans, &flags)) {\n\t\tIWL_ERR(fwrt, \"Failed to get monitor header\\n\");\n\t\treturn NULL;\n\t}\n\n\twrite_ptr = iwl_read_prph_no_grab(fwrt->trans, write_ptr_addr);\n\tcycle_cnt = iwl_read_prph_no_grab(fwrt->trans, cycle_cnt_addr);\n\n\tiwl_trans_release_nic_access(fwrt->trans, &flags);\n\n\tdata->header.version = cpu_to_le32(IWL_INI_DUMP_VER);\n\tdata->write_ptr = cpu_to_le32(write_ptr & write_ptr_msk);\n\tdata->cycle_cnt = cpu_to_le32(cycle_cnt & cycle_cnt_msk);\n\n\treturn data->ranges;\n}\n\nstatic void\n*iwl_dump_ini_mon_dram_fill_header(struct iwl_fw_runtime *fwrt,\n\t\t\t\t   struct iwl_fw_ini_region_cfg *reg,\n\t\t\t\t   void *data)\n{\n\tstruct iwl_fw_ini_monitor_dump *mon_dump = (void *)data;\n\tu32 write_ptr_addr, write_ptr_msk, cycle_cnt_addr, cycle_cnt_msk;\n\n\tswitch (fwrt->trans->trans_cfg->device_family) {\n\tcase IWL_DEVICE_FAMILY_9000:\n\tcase IWL_DEVICE_FAMILY_22000:\n\t\twrite_ptr_addr = MON_BUFF_WRPTR_VER2;\n\t\twrite_ptr_msk = -1;\n\t\tcycle_cnt_addr = MON_BUFF_CYCLE_CNT_VER2;\n\t\tcycle_cnt_msk = -1;\n\t\tbreak;\n\tdefault:\n\t\tIWL_ERR(fwrt, \"Unsupported device family %d\\n\",\n\t\t\tfwrt->trans->trans_cfg->device_family);\n\t\treturn NULL;\n\t}\n\n\treturn iwl_dump_ini_mon_fill_header(fwrt, reg, mon_dump, write_ptr_addr,\n\t\t\t\t\t    write_ptr_msk, cycle_cnt_addr,\n\t\t\t\t\t    cycle_cnt_msk);\n}\n\nstatic void\n*iwl_dump_ini_mon_smem_fill_header(struct iwl_fw_runtime *fwrt,\n\t\t\t\t   struct iwl_fw_ini_region_cfg *reg,\n\t\t\t\t   void *data)\n{\n\tstruct iwl_fw_ini_monitor_dump *mon_dump = (void *)data;\n\tconst struct iwl_cfg *cfg = fwrt->trans->cfg;\n\n\tif (fwrt->trans->trans_cfg->device_family != IWL_DEVICE_FAMILY_9000 &&\n\t    fwrt->trans->trans_cfg->device_family != IWL_DEVICE_FAMILY_22000) {\n\t\tIWL_ERR(fwrt, \"Unsupported device family %d\\n\",\n\t\t\tfwrt->trans->trans_cfg->device_family);\n\t\treturn NULL;\n\t}\n\n\treturn iwl_dump_ini_mon_fill_header(fwrt, reg, mon_dump,\n\t\t\t\t\t    cfg->fw_mon_smem_write_ptr_addr,\n\t\t\t\t\t    cfg->fw_mon_smem_write_ptr_msk,\n\t\t\t\t\t    cfg->fw_mon_smem_cycle_cnt_ptr_addr,\n\t\t\t\t\t    cfg->fw_mon_smem_cycle_cnt_ptr_msk);\n\n}\n\nstatic u32 iwl_dump_ini_mem_ranges(struct iwl_fw_runtime *fwrt,\n\t\t\t\t   struct iwl_fw_ini_region_cfg *reg)\n{\n\treturn le32_to_cpu(reg->internal.num_of_ranges);\n}\n\nstatic u32 iwl_dump_ini_paging_ranges(struct iwl_fw_runtime *fwrt,\n\t\t\t\t      struct iwl_fw_ini_region_cfg *reg)\n{\n\tif (fwrt->trans->trans_cfg->gen2)\n\t\treturn fwrt->trans->init_dram.paging_cnt;\n\n\treturn fwrt->num_of_paging_blk;\n}\n\nstatic u32 iwl_dump_ini_mon_dram_ranges(struct iwl_fw_runtime *fwrt,\n\t\t\t\t\tstruct iwl_fw_ini_region_cfg *reg)\n{\n\treturn 1;\n}\n\nstatic u32 iwl_dump_ini_txf_ranges(struct iwl_fw_runtime *fwrt,\n\t\t\t\t   struct iwl_fw_ini_region_cfg *reg)\n{\n\tu32 num_of_fifos = 0;\n\n\twhile (iwl_ini_txf_iter(fwrt, reg, num_of_fifos))\n\t\tnum_of_fifos++;\n\n\treturn num_of_fifos;\n}\n\nstatic u32 iwl_dump_ini_rxf_ranges(struct iwl_fw_runtime *fwrt,\n\t\t\t\t   struct iwl_fw_ini_region_cfg *reg)\n{\n\t/* Each Rx fifo needs a different offset and therefore, it's\n\t * region can contain only one fifo, i.e. 1 memory range.\n\t */\n\treturn 1;\n}\n\nstatic u32 iwl_dump_ini_mem_get_size(struct iwl_fw_runtime *fwrt,\n\t\t\t\t     struct iwl_fw_ini_region_cfg *reg)\n{\n\treturn sizeof(struct iwl_fw_ini_error_dump) +\n\t\tiwl_dump_ini_mem_ranges(fwrt, reg) *\n\t\t(sizeof(struct iwl_fw_ini_error_dump_range) +\n\t\t le32_to_cpu(reg->internal.range_data_size));\n}\n\nstatic u32 iwl_dump_ini_paging_get_size(struct iwl_fw_runtime *fwrt,\n\t\t\t\t\tstruct iwl_fw_ini_region_cfg *reg)\n{\n\tint i;\n\tu32 range_header_len = sizeof(struct iwl_fw_ini_error_dump_range);\n\tu32 size = sizeof(struct iwl_fw_ini_error_dump);\n\n\tif (fwrt->trans->trans_cfg->gen2) {\n\t\tfor (i = 0; i < iwl_dump_ini_paging_ranges(fwrt, reg); i++)\n\t\t\tsize += range_header_len +\n\t\t\t\tfwrt->trans->init_dram.paging[i].size;\n\t} else {\n\t\tfor (i = 1; i <= iwl_dump_ini_paging_ranges(fwrt, reg); i++)\n\t\t\tsize += range_header_len +\n\t\t\t\tfwrt->fw_paging_db[i].fw_paging_size;\n\t}\n\n\treturn size;\n}\n\nstatic u32 iwl_dump_ini_mon_dram_get_size(struct iwl_fw_runtime *fwrt,\n\t\t\t\t\t  struct iwl_fw_ini_region_cfg *reg)\n{\n\tu32 size = sizeof(struct iwl_fw_ini_monitor_dump) +\n\t\tsizeof(struct iwl_fw_ini_error_dump_range);\n\n\tif (fwrt->trans->dbg.num_blocks)\n\t\tsize += fwrt->trans->dbg.fw_mon[0].size;\n\n\treturn size;\n}\n\nstatic u32 iwl_dump_ini_mon_smem_get_size(struct iwl_fw_runtime *fwrt,\n\t\t\t\t\t  struct iwl_fw_ini_region_cfg *reg)\n{\n\treturn sizeof(struct iwl_fw_ini_monitor_dump) +\n\t\tiwl_dump_ini_mem_ranges(fwrt, reg) *\n\t\t(sizeof(struct iwl_fw_ini_error_dump_range) +\n\t\t le32_to_cpu(reg->internal.range_data_size));\n}\n\nstatic u32 iwl_dump_ini_txf_get_size(struct iwl_fw_runtime *fwrt,\n\t\t\t\t     struct iwl_fw_ini_region_cfg *reg)\n{\n\tstruct iwl_txf_iter_data *iter = &fwrt->dump.txf_iter_data;\n\tu32 size = 0;\n\tu32 fifo_hdr = sizeof(struct iwl_fw_ini_error_dump_range) +\n\t\tle32_to_cpu(reg->fifos.num_of_registers) *\n\t\tsizeof(struct iwl_fw_ini_error_dump_register);\n\n\twhile (iwl_ini_txf_iter(fwrt, reg, size)) {\n\t\tsize += fifo_hdr;\n\t\tif (!reg->fifos.header_only)\n\t\t\tsize += iter->fifo_size;\n\t}\n\n\tif (size)\n\t\tsize += sizeof(struct iwl_fw_ini_error_dump);\n\n\treturn size;\n}\n\nstatic u32 iwl_dump_ini_rxf_get_size(struct iwl_fw_runtime *fwrt,\n\t\t\t\t     struct iwl_fw_ini_region_cfg *reg)\n{\n\tstruct iwl_ini_rxf_data rx_data;\n\tu32 size = sizeof(struct iwl_fw_ini_error_dump) +\n\t\tsizeof(struct iwl_fw_ini_error_dump_range) +\n\t\tle32_to_cpu(reg->fifos.num_of_registers) *\n\t\tsizeof(struct iwl_fw_ini_error_dump_register);\n\n\tif (reg->fifos.header_only)\n\t\treturn size;\n\n\tiwl_ini_get_rxf_data(fwrt, reg, &rx_data);\n\tsize += rx_data.size;\n\n\treturn size;\n}\n\n/**\n * struct iwl_dump_ini_mem_ops - ini memory dump operations\n * @get_num_of_ranges: returns the number of memory ranges in the region.\n * @get_size: returns the total size of the region.\n * @fill_mem_hdr: fills region type specific headers and returns pointer to\n *\tthe first range or NULL if failed to fill headers.\n * @fill_range: copies a given memory range into the dump.\n *\tReturns the size of the range or negative error value otherwise.\n */\nstruct iwl_dump_ini_mem_ops {\n\tu32 (*get_num_of_ranges)(struct iwl_fw_runtime *fwrt,\n\t\t\t\t struct iwl_fw_ini_region_cfg *reg);\n\tu32 (*get_size)(struct iwl_fw_runtime *fwrt,\n\t\t\tstruct iwl_fw_ini_region_cfg *reg);\n\tvoid *(*fill_mem_hdr)(struct iwl_fw_runtime *fwrt,\n\t\t\t      struct iwl_fw_ini_region_cfg *reg, void *data);\n\tint (*fill_range)(struct iwl_fw_runtime *fwrt,\n\t\t\t  struct iwl_fw_ini_region_cfg *reg, void *range,\n\t\t\t  int idx);\n};\n\n/**\n * iwl_dump_ini_mem\n *\n * Creates a dump tlv and copy a memory region into it.\n * Returns the size of the current dump tlv or 0 if failed\n *\n * @fwrt: fw runtime struct\n * @list: list to add the dump tlv to\n * @reg: memory region\n * @ops: memory dump operations\n */\nstatic u32 iwl_dump_ini_mem(struct iwl_fw_runtime *fwrt, struct list_head *list,\n\t\t\t    struct iwl_fw_ini_region_cfg *reg,\n\t\t\t    const struct iwl_dump_ini_mem_ops *ops)\n{\n\tstruct iwl_fw_ini_dump_entry *entry;\n\tstruct iwl_fw_error_dump_data *tlv;\n\tstruct iwl_fw_ini_error_dump_header *header;\n\tu32 num_of_ranges, i, type = le32_to_cpu(reg->region_type), size;\n\tvoid *range;\n\n\tif (!ops->get_num_of_ranges || !ops->get_size || !ops->fill_mem_hdr ||\n\t    !ops->fill_range)\n\t\treturn 0;\n\n\tsize = ops->get_size(fwrt, reg);\n\tif (!size)\n\t\treturn 0;\n\n\tentry = kmalloc(sizeof(*entry) + sizeof(*tlv) + size, GFP_KERNEL);\n\tif (!entry)\n\t\treturn 0;\n\n\tentry->size = sizeof(*tlv) + size;\n\n\ttlv = (void *)entry->data;\n\ttlv->type = cpu_to_le32(type);\n\ttlv->len = cpu_to_le32(size);\n\n\tIWL_DEBUG_FW(fwrt, \"WRT: Collecting region: id=%d, type=%d\\n\",\n\t\t     le32_to_cpu(reg->region_id), type);\n\n\tnum_of_ranges = ops->get_num_of_ranges(fwrt, reg);\n\n\theader = (void *)tlv->data;\n\theader->region_id = reg->region_id;\n\theader->num_of_ranges = cpu_to_le32(num_of_ranges);\n\theader->name_len = cpu_to_le32(min_t(int, IWL_FW_INI_MAX_NAME,\n\t\t\t\t\t     le32_to_cpu(reg->name_len)));\n\tmemcpy(header->name, reg->name, le32_to_cpu(header->name_len));\n\n\trange = ops->fill_mem_hdr(fwrt, reg, header);\n\tif (!range) {\n\t\tIWL_ERR(fwrt,\n\t\t\t\"WRT: Failed to fill region header: id=%d, type=%d\\n\",\n\t\t\tle32_to_cpu(reg->region_id), type);\n\t\tgoto out_err;\n\t}\n\n\tfor (i = 0; i < num_of_ranges; i++) {\n\t\tint range_size = ops->fill_range(fwrt, reg, range, i);\n\n\t\tif (range_size < 0) {\n\t\t\tIWL_ERR(fwrt,\n\t\t\t\t\"WRT: Failed to dump region: id=%d, type=%d\\n\",\n\t\t\t\tle32_to_cpu(reg->region_id), type);\n\t\t\tgoto out_err;\n\t\t}\n\t\trange = range + range_size;\n\t}\n\n\tlist_add_tail(&entry->list, list);\n\n\treturn entry->size;\n\nout_err:\n\tkfree(entry);\n\n\treturn 0;\n}\n\nstatic u32 iwl_dump_ini_info(struct iwl_fw_runtime *fwrt,\n\t\t\t     struct iwl_fw_ini_trigger *trigger,\n\t\t\t     struct list_head *list)\n{\n\tstruct iwl_fw_ini_dump_entry *entry;\n\tstruct iwl_fw_error_dump_data *tlv;\n\tstruct iwl_fw_ini_dump_info *dump;\n\tu32 reg_ids_size = le32_to_cpu(trigger->num_regions) * sizeof(__le32);\n\tu32 size = sizeof(*tlv) + sizeof(*dump) + reg_ids_size;\n\n\tentry = kmalloc(sizeof(*entry) + size, GFP_KERNEL);\n\tif (!entry)\n\t\treturn 0;\n\n\tentry->size = size;\n\n\ttlv = (void *)entry->data;\n\ttlv->type = cpu_to_le32(IWL_INI_DUMP_INFO_TYPE);\n\ttlv->len = cpu_to_le32(sizeof(*dump) + reg_ids_size);\n\n\tdump = (void *)tlv->data;\n\n\tdump->version = cpu_to_le32(IWL_INI_DUMP_VER);\n\tdump->trigger_id = trigger->trigger_id;\n\tdump->is_external_cfg =\n\t\tcpu_to_le32(fwrt->trans->dbg.external_ini_cfg);\n\n\tdump->ver_type = cpu_to_le32(fwrt->dump.fw_ver.type);\n\tdump->ver_subtype = cpu_to_le32(fwrt->dump.fw_ver.subtype);\n\n\tdump->hw_step = cpu_to_le32(CSR_HW_REV_STEP(fwrt->trans->hw_rev));\n\tdump->hw_type = cpu_to_le32(CSR_HW_REV_TYPE(fwrt->trans->hw_rev));\n\n\tdump->rf_id_flavor =\n\t\tcpu_to_le32(CSR_HW_RFID_FLAVOR(fwrt->trans->hw_rf_id));\n\tdump->rf_id_dash = cpu_to_le32(CSR_HW_RFID_DASH(fwrt->trans->hw_rf_id));\n\tdump->rf_id_step = cpu_to_le32(CSR_HW_RFID_STEP(fwrt->trans->hw_rf_id));\n\tdump->rf_id_type = cpu_to_le32(CSR_HW_RFID_TYPE(fwrt->trans->hw_rf_id));\n\n\tdump->lmac_major = cpu_to_le32(fwrt->dump.fw_ver.lmac_major);\n\tdump->lmac_minor = cpu_to_le32(fwrt->dump.fw_ver.lmac_minor);\n\tdump->umac_major = cpu_to_le32(fwrt->dump.fw_ver.umac_major);\n\tdump->umac_minor = cpu_to_le32(fwrt->dump.fw_ver.umac_minor);\n\n\tdump->build_tag_len = cpu_to_le32(sizeof(dump->build_tag));\n\tmemcpy(dump->build_tag, fwrt->fw->human_readable,\n\t       sizeof(dump->build_tag));\n\n\tdump->img_name_len = cpu_to_le32(sizeof(dump->img_name));\n\tmemcpy(dump->img_name, fwrt->dump.img_name, sizeof(dump->img_name));\n\n\tdump->internal_dbg_cfg_name_len =\n\t\tcpu_to_le32(sizeof(dump->internal_dbg_cfg_name));\n\tmemcpy(dump->internal_dbg_cfg_name, fwrt->dump.internal_dbg_cfg_name,\n\t       sizeof(dump->internal_dbg_cfg_name));\n\n\tdump->external_dbg_cfg_name_len =\n\t\tcpu_to_le32(sizeof(dump->external_dbg_cfg_name));\n\n\tmemcpy(dump->external_dbg_cfg_name, fwrt->dump.external_dbg_cfg_name,\n\t       sizeof(dump->external_dbg_cfg_name));\n\n\tdump->regions_num = trigger->num_regions;\n\tmemcpy(dump->region_ids, trigger->data, reg_ids_size);\n\n\t/* add dump info TLV to the beginning of the list since it needs to be\n\t * the first TLV in the dump\n\t */\n\tlist_add(&entry->list, list);\n\n\treturn entry->size;\n}\n\nstatic const struct iwl_dump_ini_mem_ops iwl_dump_ini_region_ops[] = {\n\t[IWL_FW_INI_REGION_INVALID] = {},\n\t[IWL_FW_INI_REGION_DEVICE_MEMORY] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_mem_ranges,\n\t\t.get_size = iwl_dump_ini_mem_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_mem_fill_header,\n\t\t.fill_range = iwl_dump_ini_dev_mem_iter,\n\t},\n\t[IWL_FW_INI_REGION_PERIPHERY_MAC] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_mem_ranges,\n\t\t.get_size = iwl_dump_ini_mem_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_mem_fill_header,\n\t\t.fill_range = iwl_dump_ini_prph_iter,\n\t},\n\t[IWL_FW_INI_REGION_PERIPHERY_PHY] = {},\n\t[IWL_FW_INI_REGION_PERIPHERY_AUX] = {},\n\t[IWL_FW_INI_REGION_DRAM_BUFFER] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_mon_dram_ranges,\n\t\t.get_size = iwl_dump_ini_mon_dram_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_mon_dram_fill_header,\n\t\t.fill_range = iwl_dump_ini_mon_dram_iter,\n\t},\n\t[IWL_FW_INI_REGION_DRAM_IMR] = {},\n\t[IWL_FW_INI_REGION_INTERNAL_BUFFER] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_mem_ranges,\n\t\t.get_size = iwl_dump_ini_mon_smem_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_mon_smem_fill_header,\n\t\t.fill_range = iwl_dump_ini_dev_mem_iter,\n\t},\n\t[IWL_FW_INI_REGION_TXF] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_txf_ranges,\n\t\t.get_size = iwl_dump_ini_txf_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_mem_fill_header,\n\t\t.fill_range = iwl_dump_ini_txf_iter,\n\t},\n\t[IWL_FW_INI_REGION_RXF] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_rxf_ranges,\n\t\t.get_size = iwl_dump_ini_rxf_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_mem_fill_header,\n\t\t.fill_range = iwl_dump_ini_rxf_iter,\n\t},\n\t[IWL_FW_INI_REGION_PAGING] = {\n\t\t.fill_mem_hdr = iwl_dump_ini_mem_fill_header,\n\t\t.get_num_of_ranges = iwl_dump_ini_paging_ranges,\n\t\t.get_size = iwl_dump_ini_paging_get_size,\n\t\t.fill_range = iwl_dump_ini_paging_iter,\n\t},\n\t[IWL_FW_INI_REGION_CSR] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_mem_ranges,\n\t\t.get_size = iwl_dump_ini_mem_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_mem_fill_header,\n\t\t.fill_range = iwl_dump_ini_csr_iter,\n\t},\n\t[IWL_FW_INI_REGION_NOTIFICATION] = {},\n\t[IWL_FW_INI_REGION_DHC] = {},\n\t[IWL_FW_INI_REGION_LMAC_ERROR_TABLE] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_mem_ranges,\n\t\t.get_size = iwl_dump_ini_mem_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_mem_fill_header,\n\t\t.fill_range = iwl_dump_ini_dev_mem_iter,\n\t},\n\t[IWL_FW_INI_REGION_UMAC_ERROR_TABLE] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_mem_ranges,\n\t\t.get_size = iwl_dump_ini_mem_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_mem_fill_header,\n\t\t.fill_range = iwl_dump_ini_dev_mem_iter,\n\t},\n};\n\nstatic u32 iwl_dump_ini_trigger(struct iwl_fw_runtime *fwrt,\n\t\t\t\tstruct iwl_fw_ini_trigger *trigger,\n\t\t\t\tstruct list_head *list)\n{\n\tint i;\n\tu32 size = 0;\n\n\tfor (i = 0; i < le32_to_cpu(trigger->num_regions); i++) {\n\t\tu32 reg_id = le32_to_cpu(trigger->data[i]), reg_type;\n\t\tstruct iwl_fw_ini_region_cfg *reg;\n\n\t\tif (WARN_ON(reg_id >= ARRAY_SIZE(fwrt->dump.active_regs)))\n\t\t\tcontinue;\n\n\t\treg = fwrt->dump.active_regs[reg_id];\n\t\tif (!reg) {\n\t\t\tIWL_WARN(fwrt,\n\t\t\t\t \"WRT: Unassigned region id %d, skipping\\n\",\n\t\t\t\t reg_id);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* currently the driver supports always on domain only */\n\t\tif (le32_to_cpu(reg->domain) != IWL_FW_INI_DBG_DOMAIN_ALWAYS_ON)\n\t\t\tcontinue;\n\n\t\treg_type = le32_to_cpu(reg->region_type);\n\t\tif (reg_type >= ARRAY_SIZE(iwl_dump_ini_region_ops))\n\t\t\tcontinue;\n\n\t\tsize += iwl_dump_ini_mem(fwrt, list, reg,\n\t\t\t\t\t &iwl_dump_ini_region_ops[reg_type]);\n\t}\n\n\tif (size)\n\t\tsize += iwl_dump_ini_info(fwrt, trigger, list);\n\n\treturn size;\n}\n\nstatic u32 iwl_dump_ini_file_gen(struct iwl_fw_runtime *fwrt,\n\t\t\t\t enum iwl_fw_ini_trigger_id trig_id,\n\t\t\t\t struct list_head *list)\n{\n\tstruct iwl_fw_ini_dump_entry *entry;\n\tstruct iwl_fw_ini_dump_file_hdr *hdr;\n\tstruct iwl_fw_ini_trigger *trigger;\n\tu32 size;\n\n\tif (!iwl_fw_ini_trigger_on(fwrt, trig_id))\n\t\treturn 0;\n\n\ttrigger = fwrt->dump.active_trigs[trig_id].trig;\n\tif (!trigger || !le32_to_cpu(trigger->num_regions))\n\t\treturn 0;\n\n\tentry = kmalloc(sizeof(*entry) + sizeof(*hdr), GFP_KERNEL);\n\tif (!entry)\n\t\treturn 0;\n\n\tentry->size = sizeof(*hdr);\n\n\tsize = iwl_dump_ini_trigger(fwrt, trigger, list);\n\tif (!size) {\n\t\tkfree(entry);\n\t\treturn 0;\n\t}\n\n\thdr = (void *)entry->data;\n\thdr->barker = cpu_to_le32(IWL_FW_INI_ERROR_DUMP_BARKER);\n\thdr->file_len = cpu_to_le32(size + entry->size);\n\n\tlist_add(&entry->list, list);\n\n\treturn le32_to_cpu(hdr->file_len);\n}\n\nstatic void iwl_fw_error_dump(struct iwl_fw_runtime *fwrt)\n{\n\tstruct iwl_fw_dump_ptrs fw_error_dump = {};\n\tstruct iwl_fw_error_dump_file *dump_file;\n\tstruct scatterlist *sg_dump_data;\n\tu32 file_len;\n\tu32 dump_mask = fwrt->fw->dbg.dump_mask;\n\n\tdump_file = iwl_fw_error_dump_file(fwrt, &fw_error_dump);\n\tif (!dump_file)\n\t\tgoto out;\n\n\tif (fwrt->dump.monitor_only)\n\t\tdump_mask &= IWL_FW_ERROR_DUMP_FW_MONITOR;\n\n\tfw_error_dump.trans_ptr = iwl_trans_dump_data(fwrt->trans, dump_mask);\n\tfile_len = le32_to_cpu(dump_file->file_len);\n\tfw_error_dump.fwrt_len = file_len;\n\n\tif (fw_error_dump.trans_ptr) {\n\t\tfile_len += fw_error_dump.trans_ptr->len;\n\t\tdump_file->file_len = cpu_to_le32(file_len);\n\t}\n\n\tsg_dump_data = alloc_sgtable(file_len);\n\tif (sg_dump_data) {\n\t\tsg_pcopy_from_buffer(sg_dump_data,\n\t\t\t\t     sg_nents(sg_dump_data),\n\t\t\t\t     fw_error_dump.fwrt_ptr,\n\t\t\t\t     fw_error_dump.fwrt_len, 0);\n\t\tif (fw_error_dump.trans_ptr)\n\t\t\tsg_pcopy_from_buffer(sg_dump_data,\n\t\t\t\t\t     sg_nents(sg_dump_data),\n\t\t\t\t\t     fw_error_dump.trans_ptr->data,\n\t\t\t\t\t     fw_error_dump.trans_ptr->len,\n\t\t\t\t\t     fw_error_dump.fwrt_len);\n\t\tdev_coredumpsg(fwrt->trans->dev, sg_dump_data, file_len,\n\t\t\t       GFP_KERNEL);\n\t}\n\tvfree(fw_error_dump.fwrt_ptr);\n\tvfree(fw_error_dump.trans_ptr);\n\nout:\n\tiwl_fw_free_dump_desc(fwrt);\n}\n\nstatic void iwl_dump_ini_list_free(struct list_head *list)\n{\n\twhile (!list_empty(list)) {\n\t\tstruct iwl_fw_ini_dump_entry *entry =\n\t\t\tlist_entry(list->next, typeof(*entry), list);\n\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n}\n\nstatic void iwl_fw_error_ini_dump(struct iwl_fw_runtime *fwrt, u8 wk_idx)\n{\n\tenum iwl_fw_ini_trigger_id trig_id = fwrt->dump.wks[wk_idx].ini_trig_id;\n\tstruct list_head dump_list = LIST_HEAD_INIT(dump_list);\n\tstruct scatterlist *sg_dump_data;\n\tu32 file_len;\n\n\tfile_len = iwl_dump_ini_file_gen(fwrt, trig_id, &dump_list);\n\tif (!file_len)\n\t\tgoto out;\n\n\tsg_dump_data = alloc_sgtable(file_len);\n\tif (sg_dump_data) {\n\t\tstruct iwl_fw_ini_dump_entry *entry;\n\t\tint sg_entries = sg_nents(sg_dump_data);\n\t\tu32 offs = 0;\n\n\t\tlist_for_each_entry(entry, &dump_list, list) {\n\t\t\tsg_pcopy_from_buffer(sg_dump_data, sg_entries,\n\t\t\t\t\t     entry->data, entry->size, offs);\n\t\t\toffs += entry->size;\n\t\t}\n\t\tdev_coredumpsg(fwrt->trans->dev, sg_dump_data, file_len,\n\t\t\t       GFP_KERNEL);\n\t}\n\tiwl_dump_ini_list_free(&dump_list);\n\nout:\n\tfwrt->dump.wks[wk_idx].ini_trig_id = IWL_FW_TRIGGER_ID_INVALID;\n}\n\nconst struct iwl_fw_dump_desc iwl_dump_desc_assert = {\n\t.trig_desc = {\n\t\t.type = cpu_to_le32(FW_DBG_TRIGGER_FW_ASSERT),\n\t},\n};\nIWL_EXPORT_SYMBOL(iwl_dump_desc_assert);\n\nint iwl_fw_dbg_collect_desc(struct iwl_fw_runtime *fwrt,\n\t\t\t    const struct iwl_fw_dump_desc *desc,\n\t\t\t    bool monitor_only,\n\t\t\t    unsigned int delay)\n{\n\tu32 trig_type = le32_to_cpu(desc->trig_desc.type);\n\tint ret;\n\n\tif (iwl_trans_dbg_ini_valid(fwrt->trans)) {\n\t\tret = iwl_fw_dbg_ini_collect(fwrt, trig_type);\n\t\tif (!ret)\n\t\t\tiwl_fw_free_dump_desc(fwrt);\n\n\t\treturn ret;\n\t}\n\n\t/* use wks[0] since dump flow prior to ini does not need to support\n\t * consecutive triggers collection\n\t */\n\tif (test_and_set_bit(fwrt->dump.wks[0].idx, &fwrt->dump.active_wks))\n\t\treturn -EBUSY;\n\n\tif (WARN_ON(fwrt->dump.desc))\n\t\tiwl_fw_free_dump_desc(fwrt);\n\n\tIWL_WARN(fwrt, \"Collecting data: trigger %d fired.\\n\",\n\t\t le32_to_cpu(desc->trig_desc.type));\n\n\tfwrt->dump.desc = desc;\n\tfwrt->dump.monitor_only = monitor_only;\n\n\tschedule_delayed_work(&fwrt->dump.wks[0].wk, usecs_to_jiffies(delay));\n\n\treturn 0;\n}\nIWL_EXPORT_SYMBOL(iwl_fw_dbg_collect_desc);\n\nint iwl_fw_dbg_error_collect(struct iwl_fw_runtime *fwrt,\n\t\t\t     enum iwl_fw_dbg_trigger trig_type)\n{\n\tint ret;\n\tstruct iwl_fw_dump_desc *iwl_dump_error_desc;\n\n\tif (!test_bit(STATUS_DEVICE_ENABLED, &fwrt->trans->status))\n\t\treturn -EIO;\n\n\tiwl_dump_error_desc = kmalloc(sizeof(*iwl_dump_error_desc), GFP_KERNEL);\n\tif (!iwl_dump_error_desc)\n\t\treturn -ENOMEM;\n\n\tiwl_dump_error_desc->trig_desc.type = cpu_to_le32(trig_type);\n\tiwl_dump_error_desc->len = 0;\n\n\tret = iwl_fw_dbg_collect_desc(fwrt, iwl_dump_error_desc, false, 0);\n\tif (ret)\n\t\tkfree(iwl_dump_error_desc);\n\telse\n\t\tiwl_trans_sync_nmi(fwrt->trans);\n\n\treturn ret;\n}\nIWL_EXPORT_SYMBOL(iwl_fw_dbg_error_collect);\n\nint iwl_fw_dbg_collect(struct iwl_fw_runtime *fwrt,\n\t\t       enum iwl_fw_dbg_trigger trig,\n\t\t       const char *str, size_t len,\n\t\t       struct iwl_fw_dbg_trigger_tlv *trigger)\n{\n\tstruct iwl_fw_dump_desc *desc;\n\tunsigned int delay = 0;\n\tbool monitor_only = false;\n\n\tif (trigger) {\n\t\tu16 occurrences = le16_to_cpu(trigger->occurrences) - 1;\n\n\t\tif (!le16_to_cpu(trigger->occurrences))\n\t\t\treturn 0;\n\n\t\tif (trigger->flags & IWL_FW_DBG_FORCE_RESTART) {\n\t\t\tIWL_WARN(fwrt, \"Force restart: trigger %d fired.\\n\",\n\t\t\t\t trig);\n\t\t\tiwl_force_nmi(fwrt->trans);\n\t\t\treturn 0;\n\t\t}\n\n\t\ttrigger->occurrences = cpu_to_le16(occurrences);\n\t\tmonitor_only = trigger->mode & IWL_FW_DBG_TRIGGER_MONITOR_ONLY;\n\n\t\t/* convert msec to usec */\n\t\tdelay = le32_to_cpu(trigger->stop_delay) * USEC_PER_MSEC;\n\t}\n\n\tdesc = kzalloc(sizeof(*desc) + len, GFP_ATOMIC);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\n\tdesc->len = len;\n\tdesc->trig_desc.type = cpu_to_le32(trig);\n\tmemcpy(desc->trig_desc.data, str, len);\n\n\treturn iwl_fw_dbg_collect_desc(fwrt, desc, monitor_only, delay);\n}\nIWL_EXPORT_SYMBOL(iwl_fw_dbg_collect);\n\nint _iwl_fw_dbg_ini_collect(struct iwl_fw_runtime *fwrt,\n\t\t\t    enum iwl_fw_ini_trigger_id id)\n{\n\tstruct iwl_fw_ini_active_triggers *active;\n\tu32 occur, delay;\n\tunsigned long idx;\n\n\tif (WARN_ON(!iwl_fw_ini_trigger_on(fwrt, id)))\n\t\treturn -EINVAL;\n\n\tif (!iwl_fw_ini_trigger_on(fwrt, id)) {\n\t\tIWL_WARN(fwrt, \"WRT: Trigger %d is not active, aborting dump\\n\",\n\t\t\t id);\n\t\treturn -EINVAL;\n\t}\n\n\tactive = &fwrt->dump.active_trigs[id];\n\tdelay = le32_to_cpu(active->trig->dump_delay);\n\toccur = le32_to_cpu(active->trig->occurrences);\n\tif (!occur)\n\t\treturn 0;\n\n\tactive->trig->occurrences = cpu_to_le32(--occur);\n\n\tif (le32_to_cpu(active->trig->force_restart)) {\n\t\tIWL_WARN(fwrt, \"WRT: Force restart: trigger %d fired.\\n\", id);\n\t\tiwl_force_nmi(fwrt->trans);\n\t\treturn 0;\n\t}\n\n\t/* Check there is an available worker.\n\t * ffz return value is undefined if no zero exists,\n\t * so check against ~0UL first.\n\t */\n\tif (fwrt->dump.active_wks == ~0UL)\n\t\treturn -EBUSY;\n\n\tidx = ffz(fwrt->dump.active_wks);\n\n\tif (idx >= IWL_FW_RUNTIME_DUMP_WK_NUM ||\n\t    test_and_set_bit(fwrt->dump.wks[idx].idx, &fwrt->dump.active_wks))\n\t\treturn -EBUSY;\n\n\tfwrt->dump.wks[idx].ini_trig_id = id;\n\n\tIWL_WARN(fwrt, \"WRT: Collecting data: ini trigger %d fired.\\n\", id);\n\n\tschedule_delayed_work(&fwrt->dump.wks[idx].wk, usecs_to_jiffies(delay));\n\n\treturn 0;\n}\nIWL_EXPORT_SYMBOL(_iwl_fw_dbg_ini_collect);\n\nint iwl_fw_dbg_ini_collect(struct iwl_fw_runtime *fwrt, u32 legacy_trigger_id)\n{\n\tint id;\n\n\tswitch (legacy_trigger_id) {\n\tcase FW_DBG_TRIGGER_FW_ASSERT:\n\tcase FW_DBG_TRIGGER_ALIVE_TIMEOUT:\n\tcase FW_DBG_TRIGGER_DRIVER:\n\t\tid = IWL_FW_TRIGGER_ID_FW_ASSERT;\n\t\tbreak;\n\tcase FW_DBG_TRIGGER_USER:\n\t\tid = IWL_FW_TRIGGER_ID_USER_TRIGGER;\n\t\tbreak;\n\tdefault:\n\t\treturn -EIO;\n\t}\n\n\treturn _iwl_fw_dbg_ini_collect(fwrt, id);\n}\nIWL_EXPORT_SYMBOL(iwl_fw_dbg_ini_collect);\n\nint iwl_fw_dbg_collect_trig(struct iwl_fw_runtime *fwrt,\n\t\t\t    struct iwl_fw_dbg_trigger_tlv *trigger,\n\t\t\t    const char *fmt, ...)\n{\n\tint ret, len = 0;\n\tchar buf[64];\n\n\tif (fmt) {\n\t\tva_list ap;\n\n\t\tbuf[sizeof(buf) - 1] = '\\0';\n\n\t\tva_start(ap, fmt);\n\t\tvsnprintf(buf, sizeof(buf), fmt, ap);\n\t\tva_end(ap);\n\n\t\t/* check for truncation */\n\t\tif (WARN_ON_ONCE(buf[sizeof(buf) - 1]))\n\t\t\tbuf[sizeof(buf) - 1] = '\\0';\n\n\t\tlen = strlen(buf) + 1;\n\t}\n\n\tret = iwl_fw_dbg_collect(fwrt, le32_to_cpu(trigger->id), buf, len,\n\t\t\t\t trigger);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\nIWL_EXPORT_SYMBOL(iwl_fw_dbg_collect_trig);\n\nint iwl_fw_start_dbg_conf(struct iwl_fw_runtime *fwrt, u8 conf_id)\n{\n\tu8 *ptr;\n\tint ret;\n\tint i;\n\n\tif (WARN_ONCE(conf_id >= ARRAY_SIZE(fwrt->fw->dbg.conf_tlv),\n\t\t      \"Invalid configuration %d\\n\", conf_id))\n\t\treturn -EINVAL;\n\n\t/* EARLY START - firmware's configuration is hard coded */\n\tif ((!fwrt->fw->dbg.conf_tlv[conf_id] ||\n\t     !fwrt->fw->dbg.conf_tlv[conf_id]->num_of_hcmds) &&\n\t    conf_id == FW_DBG_START_FROM_ALIVE)\n\t\treturn 0;\n\n\tif (!fwrt->fw->dbg.conf_tlv[conf_id])\n\t\treturn -EINVAL;\n\n\tif (fwrt->dump.conf != FW_DBG_INVALID)\n\t\tIWL_WARN(fwrt, \"FW already configured (%d) - re-configuring\\n\",\n\t\t\t fwrt->dump.conf);\n\n\t/* Send all HCMDs for configuring the FW debug */\n\tptr = (void *)&fwrt->fw->dbg.conf_tlv[conf_id]->hcmd;\n\tfor (i = 0; i < fwrt->fw->dbg.conf_tlv[conf_id]->num_of_hcmds; i++) {\n\t\tstruct iwl_fw_dbg_conf_hcmd *cmd = (void *)ptr;\n\t\tstruct iwl_host_cmd hcmd = {\n\t\t\t.id = cmd->id,\n\t\t\t.len = { le16_to_cpu(cmd->len), },\n\t\t\t.data = { cmd->data, },\n\t\t};\n\n\t\tret = iwl_trans_send_cmd(fwrt->trans, &hcmd);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tptr += sizeof(*cmd);\n\t\tptr += le16_to_cpu(cmd->len);\n\t}\n\n\tfwrt->dump.conf = conf_id;\n\n\treturn 0;\n}\nIWL_EXPORT_SYMBOL(iwl_fw_start_dbg_conf);\n\n/* this function assumes dump_start was called beforehand and dump_end will be\n * called afterwards\n */\nstatic void iwl_fw_dbg_collect_sync(struct iwl_fw_runtime *fwrt, u8 wk_idx)\n{\n\tstruct iwl_fw_dbg_params params = {0};\n\n\tif (!test_bit(wk_idx, &fwrt->dump.active_wks))\n\t\treturn;\n\n\tif (fwrt->ops && fwrt->ops->fw_running &&\n\t    !fwrt->ops->fw_running(fwrt->ops_ctx)) {\n\t\tIWL_ERR(fwrt, \"Firmware not running - cannot dump error\\n\");\n\t\tiwl_fw_free_dump_desc(fwrt);\n\t\tgoto out;\n\t}\n\n\t/* there's no point in fw dump if the bus is dead */\n\tif (test_bit(STATUS_TRANS_DEAD, &fwrt->trans->status)) {\n\t\tIWL_ERR(fwrt, \"Skip fw error dump since bus is dead\\n\");\n\t\tgoto out;\n\t}\n\n\tif (iwl_fw_dbg_stop_restart_recording(fwrt, &params, true)) {\n\t\tIWL_ERR(fwrt, \"Failed to stop DBGC recording, aborting dump\\n\");\n\t\tgoto out;\n\t}\n\n\tIWL_DEBUG_FW_INFO(fwrt, \"WRT: Data collection start\\n\");\n\tif (iwl_trans_dbg_ini_valid(fwrt->trans))\n\t\tiwl_fw_error_ini_dump(fwrt, wk_idx);\n\telse\n\t\tiwl_fw_error_dump(fwrt);\n\tIWL_DEBUG_FW_INFO(fwrt, \"WRT: Data collection done\\n\");\n\n\tiwl_fw_dbg_stop_restart_recording(fwrt, &params, false);\n\nout:\n\tclear_bit(wk_idx, &fwrt->dump.active_wks);\n}\n\nvoid iwl_fw_error_dump_wk(struct work_struct *work)\n{\n\tstruct iwl_fw_runtime *fwrt;\n\ttypeof(fwrt->dump.wks[0]) *wks;\n\n\twks = container_of(work, typeof(fwrt->dump.wks[0]), wk.work);\n\tfwrt = container_of(wks, struct iwl_fw_runtime, dump.wks[wks->idx]);\n\n\t/* assumes the op mode mutex is locked in dump_start since\n\t * iwl_fw_dbg_collect_sync can't run in parallel\n\t */\n\tif (fwrt->ops && fwrt->ops->dump_start &&\n\t    fwrt->ops->dump_start(fwrt->ops_ctx))\n\t\treturn;\n\n\tiwl_fw_dbg_collect_sync(fwrt, wks->idx);\n\n\tif (fwrt->ops && fwrt->ops->dump_end)\n\t\tfwrt->ops->dump_end(fwrt->ops_ctx);\n}\n\nvoid iwl_fw_dbg_read_d3_debug_data(struct iwl_fw_runtime *fwrt)\n{\n\tconst struct iwl_cfg *cfg = fwrt->trans->cfg;\n\n\tif (!iwl_fw_dbg_is_d3_debug_enabled(fwrt))\n\t\treturn;\n\n\tif (!fwrt->dump.d3_debug_data) {\n\t\tfwrt->dump.d3_debug_data = kmalloc(cfg->d3_debug_data_length,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!fwrt->dump.d3_debug_data) {\n\t\t\tIWL_ERR(fwrt,\n\t\t\t\t\"failed to allocate memory for D3 debug data\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* if the buffer holds previous debug data it is overwritten */\n\tiwl_trans_read_mem_bytes(fwrt->trans, cfg->d3_debug_data_base_addr,\n\t\t\t\t fwrt->dump.d3_debug_data,\n\t\t\t\t cfg->d3_debug_data_length);\n}\nIWL_EXPORT_SYMBOL(iwl_fw_dbg_read_d3_debug_data);\n\nvoid iwl_fw_dbg_stop_sync(struct iwl_fw_runtime *fwrt)\n{\n\tint i;\n\n\tiwl_dbg_tlv_del_timers(fwrt->trans);\n\tfor (i = 0; i < IWL_FW_RUNTIME_DUMP_WK_NUM; i++)\n\t\tiwl_fw_dbg_collect_sync(fwrt, i);\n\n\tiwl_fw_dbg_stop_restart_recording(fwrt, NULL, true);\n}\nIWL_EXPORT_SYMBOL(iwl_fw_dbg_stop_sync);\n\n#define FSEQ_REG(x) { .addr = (x), .str = #x, }\n\nvoid iwl_fw_error_print_fseq_regs(struct iwl_fw_runtime *fwrt)\n{\n\tstruct iwl_trans *trans = fwrt->trans;\n\tunsigned long flags;\n\tint i;\n\tstruct {\n\t\tu32 addr;\n\t\tconst char *str;\n\t} fseq_regs[] = {\n\t\tFSEQ_REG(FSEQ_ERROR_CODE),\n\t\tFSEQ_REG(FSEQ_TOP_INIT_VERSION),\n\t\tFSEQ_REG(FSEQ_CNVIO_INIT_VERSION),\n\t\tFSEQ_REG(FSEQ_OTP_VERSION),\n\t\tFSEQ_REG(FSEQ_TOP_CONTENT_VERSION),\n\t\tFSEQ_REG(FSEQ_ALIVE_TOKEN),\n\t\tFSEQ_REG(FSEQ_CNVI_ID),\n\t\tFSEQ_REG(FSEQ_CNVR_ID),\n\t\tFSEQ_REG(CNVI_AUX_MISC_CHIP),\n\t\tFSEQ_REG(CNVR_AUX_MISC_CHIP),\n\t\tFSEQ_REG(CNVR_SCU_SD_REGS_SD_REG_DIG_DCDC_VTRIM),\n\t\tFSEQ_REG(CNVR_SCU_SD_REGS_SD_REG_ACTIVE_VDIG_MIRROR),\n\t};\n\n\tif (!iwl_trans_grab_nic_access(trans, &flags))\n\t\treturn;\n\n\tIWL_ERR(fwrt, \"Fseq Registers:\\n\");\n\n\tfor (i = 0; i < ARRAY_SIZE(fseq_regs); i++)\n\t\tIWL_ERR(fwrt, \"0x%08X | %s\\n\",\n\t\t\tiwl_read_prph_no_grab(trans, fseq_regs[i].addr),\n\t\t\tfseq_regs[i].str);\n\n\tiwl_trans_release_nic_access(trans, &flags);\n}\nIWL_EXPORT_SYMBOL(iwl_fw_error_print_fseq_regs);\n\nstatic int iwl_fw_dbg_suspend_resume_hcmd(struct iwl_trans *trans, bool suspend)\n{\n\tstruct iwl_dbg_suspend_resume_cmd cmd = {\n\t\t.operation = suspend ?\n\t\t\tcpu_to_le32(DBGC_SUSPEND_CMD) :\n\t\t\tcpu_to_le32(DBGC_RESUME_CMD),\n\t};\n\tstruct iwl_host_cmd hcmd = {\n\t\t.id = WIDE_ID(DEBUG_GROUP, DBGC_SUSPEND_RESUME),\n\t\t.data[0] = &cmd,\n\t\t.len[0] = sizeof(cmd),\n\t};\n\n\treturn iwl_trans_send_cmd(trans, &hcmd);\n}\n\nstatic void iwl_fw_dbg_stop_recording(struct iwl_trans *trans,\n\t\t\t\t      struct iwl_fw_dbg_params *params)\n{\n\tif (trans->trans_cfg->device_family == IWL_DEVICE_FAMILY_7000) {\n\t\tiwl_set_bits_prph(trans, MON_BUFF_SAMPLE_CTL, 0x100);\n\t\treturn;\n\t}\n\n\tif (params) {\n\t\tparams->in_sample = iwl_read_umac_prph(trans, DBGC_IN_SAMPLE);\n\t\tparams->out_ctrl = iwl_read_umac_prph(trans, DBGC_OUT_CTRL);\n\t}\n\n\tiwl_write_umac_prph(trans, DBGC_IN_SAMPLE, 0);\n\t/* wait for the DBGC to finish writing the internal buffer to DRAM to\n\t * avoid halting the HW while writing\n\t */\n\tusleep_range(700, 1000);\n\tiwl_write_umac_prph(trans, DBGC_OUT_CTRL, 0);\n}\n\nstatic int iwl_fw_dbg_restart_recording(struct iwl_trans *trans,\n\t\t\t\t\tstruct iwl_fw_dbg_params *params)\n{\n\tif (!params)\n\t\treturn -EIO;\n\n\tif (trans->trans_cfg->device_family == IWL_DEVICE_FAMILY_7000) {\n\t\tiwl_clear_bits_prph(trans, MON_BUFF_SAMPLE_CTL, 0x100);\n\t\tiwl_clear_bits_prph(trans, MON_BUFF_SAMPLE_CTL, 0x1);\n\t\tiwl_set_bits_prph(trans, MON_BUFF_SAMPLE_CTL, 0x1);\n\t} else {\n\t\tiwl_write_umac_prph(trans, DBGC_IN_SAMPLE, params->in_sample);\n\t\tiwl_write_umac_prph(trans, DBGC_OUT_CTRL, params->out_ctrl);\n\t}\n\n\treturn 0;\n}\n\nint iwl_fw_dbg_stop_restart_recording(struct iwl_fw_runtime *fwrt,\n\t\t\t\t      struct iwl_fw_dbg_params *params,\n\t\t\t\t      bool stop)\n{\n\tint ret = 0;\n\n\t/* if the FW crashed or not debug monitor cfg was given, there is\n\t * no point in changing the recording state\n\t */\n\tif (test_bit(STATUS_FW_ERROR, &fwrt->trans->status) ||\n\t    (!fwrt->trans->dbg.dest_tlv &&\n\t     fwrt->trans->dbg.ini_dest == IWL_FW_INI_LOCATION_INVALID))\n\t\treturn 0;\n\n\tif (fw_has_capa(&fwrt->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_DBG_SUSPEND_RESUME_CMD_SUPP))\n\t\tret = iwl_fw_dbg_suspend_resume_hcmd(fwrt->trans, stop);\n\telse if (stop)\n\t\tiwl_fw_dbg_stop_recording(fwrt->trans, params);\n\telse\n\t\tret = iwl_fw_dbg_restart_recording(fwrt->trans, params);\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tif (!ret) {\n\t\tif (stop)\n\t\t\tfwrt->trans->dbg.rec_on = false;\n\t\telse\n\t\t\tiwl_fw_set_dbg_rec_on(fwrt);\n\t}\n#endif\n\n\treturn ret;\n}\nIWL_EXPORT_SYMBOL(iwl_fw_dbg_stop_restart_recording);\n"], "fixing_code": ["/******************************************************************************\n *\n * This file is provided under a dual BSD/GPLv2 license.  When using or\n * redistributing this file, you may do so under either license.\n *\n * GPL LICENSE SUMMARY\n *\n * Copyright(c) 2008 - 2014 Intel Corporation. All rights reserved.\n * Copyright(c) 2013 - 2015 Intel Mobile Communications GmbH\n * Copyright(c) 2015 - 2017 Intel Deutschland GmbH\n * Copyright(c) 2018 - 2019 Intel Corporation\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * The full GNU General Public License is included in this distribution\n * in the file called COPYING.\n *\n * Contact Information:\n *  Intel Linux Wireless <linuxwifi@intel.com>\n * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497\n *\n * BSD LICENSE\n *\n * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.\n * Copyright(c) 2013 - 2015 Intel Mobile Communications GmbH\n * Copyright(c) 2015 - 2017 Intel Deutschland GmbH\n * Copyright(c) 2018 - 2019 Intel Corporation\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *  * Neither the name Intel Corporation nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *****************************************************************************/\n#include <linux/devcoredump.h>\n#include \"iwl-drv.h\"\n#include \"runtime.h\"\n#include \"dbg.h\"\n#include \"debugfs.h\"\n#include \"iwl-io.h\"\n#include \"iwl-prph.h\"\n#include \"iwl-csr.h\"\n\n/**\n * struct iwl_fw_dump_ptrs - set of pointers needed for the fw-error-dump\n *\n * @fwrt_ptr: pointer to the buffer coming from fwrt\n * @trans_ptr: pointer to struct %iwl_trans_dump_data which contains the\n *\ttransport's data.\n * @trans_len: length of the valid data in trans_ptr\n * @fwrt_len: length of the valid data in fwrt_ptr\n */\nstruct iwl_fw_dump_ptrs {\n\tstruct iwl_trans_dump_data *trans_ptr;\n\tvoid *fwrt_ptr;\n\tu32 fwrt_len;\n};\n\n#define RADIO_REG_MAX_READ 0x2ad\nstatic void iwl_read_radio_regs(struct iwl_fw_runtime *fwrt,\n\t\t\t\tstruct iwl_fw_error_dump_data **dump_data)\n{\n\tu8 *pos = (void *)(*dump_data)->data;\n\tunsigned long flags;\n\tint i;\n\n\tIWL_DEBUG_INFO(fwrt, \"WRT radio registers dump\\n\");\n\n\tif (!iwl_trans_grab_nic_access(fwrt->trans, &flags))\n\t\treturn;\n\n\t(*dump_data)->type = cpu_to_le32(IWL_FW_ERROR_DUMP_RADIO_REG);\n\t(*dump_data)->len = cpu_to_le32(RADIO_REG_MAX_READ);\n\n\tfor (i = 0; i < RADIO_REG_MAX_READ; i++) {\n\t\tu32 rd_cmd = RADIO_RSP_RD_CMD;\n\n\t\trd_cmd |= i << RADIO_RSP_ADDR_POS;\n\t\tiwl_write_prph_no_grab(fwrt->trans, RSP_RADIO_CMD, rd_cmd);\n\t\t*pos = (u8)iwl_read_prph_no_grab(fwrt->trans, RSP_RADIO_RDDAT);\n\n\t\tpos++;\n\t}\n\n\t*dump_data = iwl_fw_error_next_data(*dump_data);\n\n\tiwl_trans_release_nic_access(fwrt->trans, &flags);\n}\n\nstatic void iwl_fwrt_dump_rxf(struct iwl_fw_runtime *fwrt,\n\t\t\t      struct iwl_fw_error_dump_data **dump_data,\n\t\t\t      int size, u32 offset, int fifo_num)\n{\n\tstruct iwl_fw_error_dump_fifo *fifo_hdr;\n\tu32 *fifo_data;\n\tu32 fifo_len;\n\tint i;\n\n\tfifo_hdr = (void *)(*dump_data)->data;\n\tfifo_data = (void *)fifo_hdr->data;\n\tfifo_len = size;\n\n\t/* No need to try to read the data if the length is 0 */\n\tif (fifo_len == 0)\n\t\treturn;\n\n\t/* Add a TLV for the RXF */\n\t(*dump_data)->type = cpu_to_le32(IWL_FW_ERROR_DUMP_RXF);\n\t(*dump_data)->len = cpu_to_le32(fifo_len + sizeof(*fifo_hdr));\n\n\tfifo_hdr->fifo_num = cpu_to_le32(fifo_num);\n\tfifo_hdr->available_bytes =\n\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\tRXF_RD_D_SPACE + offset));\n\tfifo_hdr->wr_ptr =\n\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\tRXF_RD_WR_PTR + offset));\n\tfifo_hdr->rd_ptr =\n\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\tRXF_RD_RD_PTR + offset));\n\tfifo_hdr->fence_ptr =\n\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\tRXF_RD_FENCE_PTR + offset));\n\tfifo_hdr->fence_mode =\n\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\tRXF_SET_FENCE_MODE + offset));\n\n\t/* Lock fence */\n\tiwl_trans_write_prph(fwrt->trans, RXF_SET_FENCE_MODE + offset, 0x1);\n\t/* Set fence pointer to the same place like WR pointer */\n\tiwl_trans_write_prph(fwrt->trans, RXF_LD_WR2FENCE + offset, 0x1);\n\t/* Set fence offset */\n\tiwl_trans_write_prph(fwrt->trans,\n\t\t\t     RXF_LD_FENCE_OFFSET_ADDR + offset, 0x0);\n\n\t/* Read FIFO */\n\tfifo_len /= sizeof(u32); /* Size in DWORDS */\n\tfor (i = 0; i < fifo_len; i++)\n\t\tfifo_data[i] = iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\t RXF_FIFO_RD_FENCE_INC +\n\t\t\t\t\t\t offset);\n\t*dump_data = iwl_fw_error_next_data(*dump_data);\n}\n\nstatic void iwl_fwrt_dump_txf(struct iwl_fw_runtime *fwrt,\n\t\t\t      struct iwl_fw_error_dump_data **dump_data,\n\t\t\t      int size, u32 offset, int fifo_num)\n{\n\tstruct iwl_fw_error_dump_fifo *fifo_hdr;\n\tu32 *fifo_data;\n\tu32 fifo_len;\n\tint i;\n\n\tfifo_hdr = (void *)(*dump_data)->data;\n\tfifo_data = (void *)fifo_hdr->data;\n\tfifo_len = size;\n\n\t/* No need to try to read the data if the length is 0 */\n\tif (fifo_len == 0)\n\t\treturn;\n\n\t/* Add a TLV for the FIFO */\n\t(*dump_data)->type = cpu_to_le32(IWL_FW_ERROR_DUMP_TXF);\n\t(*dump_data)->len = cpu_to_le32(fifo_len + sizeof(*fifo_hdr));\n\n\tfifo_hdr->fifo_num = cpu_to_le32(fifo_num);\n\tfifo_hdr->available_bytes =\n\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\tTXF_FIFO_ITEM_CNT + offset));\n\tfifo_hdr->wr_ptr =\n\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\tTXF_WR_PTR + offset));\n\tfifo_hdr->rd_ptr =\n\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\tTXF_RD_PTR + offset));\n\tfifo_hdr->fence_ptr =\n\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\tTXF_FENCE_PTR + offset));\n\tfifo_hdr->fence_mode =\n\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\tTXF_LOCK_FENCE + offset));\n\n\t/* Set the TXF_READ_MODIFY_ADDR to TXF_WR_PTR */\n\tiwl_trans_write_prph(fwrt->trans, TXF_READ_MODIFY_ADDR + offset,\n\t\t\t     TXF_WR_PTR + offset);\n\n\t/* Dummy-read to advance the read pointer to the head */\n\tiwl_trans_read_prph(fwrt->trans, TXF_READ_MODIFY_DATA + offset);\n\n\t/* Read FIFO */\n\tfifo_len /= sizeof(u32); /* Size in DWORDS */\n\tfor (i = 0; i < fifo_len; i++)\n\t\tfifo_data[i] = iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\t  TXF_READ_MODIFY_DATA +\n\t\t\t\t\t\t  offset);\n\t*dump_data = iwl_fw_error_next_data(*dump_data);\n}\n\nstatic void iwl_fw_dump_rxf(struct iwl_fw_runtime *fwrt,\n\t\t\t    struct iwl_fw_error_dump_data **dump_data)\n{\n\tstruct iwl_fwrt_shared_mem_cfg *cfg = &fwrt->smem_cfg;\n\tunsigned long flags;\n\n\tIWL_DEBUG_INFO(fwrt, \"WRT RX FIFO dump\\n\");\n\n\tif (!iwl_trans_grab_nic_access(fwrt->trans, &flags))\n\t\treturn;\n\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_RXF)) {\n\t\t/* Pull RXF1 */\n\t\tiwl_fwrt_dump_rxf(fwrt, dump_data,\n\t\t\t\t  cfg->lmac[0].rxfifo1_size, 0, 0);\n\t\t/* Pull RXF2 */\n\t\tiwl_fwrt_dump_rxf(fwrt, dump_data, cfg->rxfifo2_size,\n\t\t\t\t  RXF_DIFF_FROM_PREV +\n\t\t\t\t  fwrt->trans->trans_cfg->umac_prph_offset, 1);\n\t\t/* Pull LMAC2 RXF1 */\n\t\tif (fwrt->smem_cfg.num_lmacs > 1)\n\t\t\tiwl_fwrt_dump_rxf(fwrt, dump_data,\n\t\t\t\t\t  cfg->lmac[1].rxfifo1_size,\n\t\t\t\t\t  LMAC2_PRPH_OFFSET, 2);\n\t}\n\n\tiwl_trans_release_nic_access(fwrt->trans, &flags);\n}\n\nstatic void iwl_fw_dump_txf(struct iwl_fw_runtime *fwrt,\n\t\t\t    struct iwl_fw_error_dump_data **dump_data)\n{\n\tstruct iwl_fw_error_dump_fifo *fifo_hdr;\n\tstruct iwl_fwrt_shared_mem_cfg *cfg = &fwrt->smem_cfg;\n\tu32 *fifo_data;\n\tu32 fifo_len;\n\tunsigned long flags;\n\tint i, j;\n\n\tIWL_DEBUG_INFO(fwrt, \"WRT TX FIFO dump\\n\");\n\n\tif (!iwl_trans_grab_nic_access(fwrt->trans, &flags))\n\t\treturn;\n\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_TXF)) {\n\t\t/* Pull TXF data from LMAC1 */\n\t\tfor (i = 0; i < fwrt->smem_cfg.num_txfifo_entries; i++) {\n\t\t\t/* Mark the number of TXF we're pulling now */\n\t\t\tiwl_trans_write_prph(fwrt->trans, TXF_LARC_NUM, i);\n\t\t\tiwl_fwrt_dump_txf(fwrt, dump_data,\n\t\t\t\t\t  cfg->lmac[0].txfifo_size[i], 0, i);\n\t\t}\n\n\t\t/* Pull TXF data from LMAC2 */\n\t\tif (fwrt->smem_cfg.num_lmacs > 1) {\n\t\t\tfor (i = 0; i < fwrt->smem_cfg.num_txfifo_entries;\n\t\t\t     i++) {\n\t\t\t\t/* Mark the number of TXF we're pulling now */\n\t\t\t\tiwl_trans_write_prph(fwrt->trans,\n\t\t\t\t\t\t     TXF_LARC_NUM +\n\t\t\t\t\t\t     LMAC2_PRPH_OFFSET, i);\n\t\t\t\tiwl_fwrt_dump_txf(fwrt, dump_data,\n\t\t\t\t\t\t  cfg->lmac[1].txfifo_size[i],\n\t\t\t\t\t\t  LMAC2_PRPH_OFFSET,\n\t\t\t\t\t\t  i + cfg->num_txfifo_entries);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_INTERNAL_TXF) &&\n\t    fw_has_capa(&fwrt->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_EXTEND_SHARED_MEM_CFG)) {\n\t\t/* Pull UMAC internal TXF data from all TXFs */\n\t\tfor (i = 0;\n\t\t     i < ARRAY_SIZE(fwrt->smem_cfg.internal_txfifo_size);\n\t\t     i++) {\n\t\t\tfifo_hdr = (void *)(*dump_data)->data;\n\t\t\tfifo_data = (void *)fifo_hdr->data;\n\t\t\tfifo_len = fwrt->smem_cfg.internal_txfifo_size[i];\n\n\t\t\t/* No need to try to read the data if the length is 0 */\n\t\t\tif (fifo_len == 0)\n\t\t\t\tcontinue;\n\n\t\t\t/* Add a TLV for the internal FIFOs */\n\t\t\t(*dump_data)->type =\n\t\t\t\tcpu_to_le32(IWL_FW_ERROR_DUMP_INTERNAL_TXF);\n\t\t\t(*dump_data)->len =\n\t\t\t\tcpu_to_le32(fifo_len + sizeof(*fifo_hdr));\n\n\t\t\tfifo_hdr->fifo_num = cpu_to_le32(i);\n\n\t\t\t/* Mark the number of TXF we're pulling now */\n\t\t\tiwl_trans_write_prph(fwrt->trans, TXF_CPU2_NUM, i +\n\t\t\t\tfwrt->smem_cfg.num_txfifo_entries);\n\n\t\t\tfifo_hdr->available_bytes =\n\t\t\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\t\t\tTXF_CPU2_FIFO_ITEM_CNT));\n\t\t\tfifo_hdr->wr_ptr =\n\t\t\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\t\t\tTXF_CPU2_WR_PTR));\n\t\t\tfifo_hdr->rd_ptr =\n\t\t\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\t\t\tTXF_CPU2_RD_PTR));\n\t\t\tfifo_hdr->fence_ptr =\n\t\t\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\t\t\tTXF_CPU2_FENCE_PTR));\n\t\t\tfifo_hdr->fence_mode =\n\t\t\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\t\t\tTXF_CPU2_LOCK_FENCE));\n\n\t\t\t/* Set TXF_CPU2_READ_MODIFY_ADDR to TXF_CPU2_WR_PTR */\n\t\t\tiwl_trans_write_prph(fwrt->trans,\n\t\t\t\t\t     TXF_CPU2_READ_MODIFY_ADDR,\n\t\t\t\t\t     TXF_CPU2_WR_PTR);\n\n\t\t\t/* Dummy-read to advance the read pointer to head */\n\t\t\tiwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t    TXF_CPU2_READ_MODIFY_DATA);\n\n\t\t\t/* Read FIFO */\n\t\t\tfifo_len /= sizeof(u32); /* Size in DWORDS */\n\t\t\tfor (j = 0; j < fifo_len; j++)\n\t\t\t\tfifo_data[j] =\n\t\t\t\t\tiwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\t\t    TXF_CPU2_READ_MODIFY_DATA);\n\t\t\t*dump_data = iwl_fw_error_next_data(*dump_data);\n\t\t}\n\t}\n\n\tiwl_trans_release_nic_access(fwrt->trans, &flags);\n}\n\n#define IWL8260_ICCM_OFFSET\t\t0x44000 /* Only for B-step */\n#define IWL8260_ICCM_LEN\t\t0xC000 /* Only for B-step */\n\nstruct iwl_prph_range {\n\tu32 start, end;\n};\n\nstatic const struct iwl_prph_range iwl_prph_dump_addr_comm[] = {\n\t{ .start = 0x00a00000, .end = 0x00a00000 },\n\t{ .start = 0x00a0000c, .end = 0x00a00024 },\n\t{ .start = 0x00a0002c, .end = 0x00a0003c },\n\t{ .start = 0x00a00410, .end = 0x00a00418 },\n\t{ .start = 0x00a00420, .end = 0x00a00420 },\n\t{ .start = 0x00a00428, .end = 0x00a00428 },\n\t{ .start = 0x00a00430, .end = 0x00a0043c },\n\t{ .start = 0x00a00444, .end = 0x00a00444 },\n\t{ .start = 0x00a004c0, .end = 0x00a004cc },\n\t{ .start = 0x00a004d8, .end = 0x00a004d8 },\n\t{ .start = 0x00a004e0, .end = 0x00a004f0 },\n\t{ .start = 0x00a00840, .end = 0x00a00840 },\n\t{ .start = 0x00a00850, .end = 0x00a00858 },\n\t{ .start = 0x00a01004, .end = 0x00a01008 },\n\t{ .start = 0x00a01010, .end = 0x00a01010 },\n\t{ .start = 0x00a01018, .end = 0x00a01018 },\n\t{ .start = 0x00a01024, .end = 0x00a01024 },\n\t{ .start = 0x00a0102c, .end = 0x00a01034 },\n\t{ .start = 0x00a0103c, .end = 0x00a01040 },\n\t{ .start = 0x00a01048, .end = 0x00a01094 },\n\t{ .start = 0x00a01c00, .end = 0x00a01c20 },\n\t{ .start = 0x00a01c58, .end = 0x00a01c58 },\n\t{ .start = 0x00a01c7c, .end = 0x00a01c7c },\n\t{ .start = 0x00a01c28, .end = 0x00a01c54 },\n\t{ .start = 0x00a01c5c, .end = 0x00a01c5c },\n\t{ .start = 0x00a01c60, .end = 0x00a01cdc },\n\t{ .start = 0x00a01ce0, .end = 0x00a01d0c },\n\t{ .start = 0x00a01d18, .end = 0x00a01d20 },\n\t{ .start = 0x00a01d2c, .end = 0x00a01d30 },\n\t{ .start = 0x00a01d40, .end = 0x00a01d5c },\n\t{ .start = 0x00a01d80, .end = 0x00a01d80 },\n\t{ .start = 0x00a01d98, .end = 0x00a01d9c },\n\t{ .start = 0x00a01da8, .end = 0x00a01da8 },\n\t{ .start = 0x00a01db8, .end = 0x00a01df4 },\n\t{ .start = 0x00a01dc0, .end = 0x00a01dfc },\n\t{ .start = 0x00a01e00, .end = 0x00a01e2c },\n\t{ .start = 0x00a01e40, .end = 0x00a01e60 },\n\t{ .start = 0x00a01e68, .end = 0x00a01e6c },\n\t{ .start = 0x00a01e74, .end = 0x00a01e74 },\n\t{ .start = 0x00a01e84, .end = 0x00a01e90 },\n\t{ .start = 0x00a01e9c, .end = 0x00a01ec4 },\n\t{ .start = 0x00a01ed0, .end = 0x00a01ee0 },\n\t{ .start = 0x00a01f00, .end = 0x00a01f1c },\n\t{ .start = 0x00a01f44, .end = 0x00a01ffc },\n\t{ .start = 0x00a02000, .end = 0x00a02048 },\n\t{ .start = 0x00a02068, .end = 0x00a020f0 },\n\t{ .start = 0x00a02100, .end = 0x00a02118 },\n\t{ .start = 0x00a02140, .end = 0x00a0214c },\n\t{ .start = 0x00a02168, .end = 0x00a0218c },\n\t{ .start = 0x00a021c0, .end = 0x00a021c0 },\n\t{ .start = 0x00a02400, .end = 0x00a02410 },\n\t{ .start = 0x00a02418, .end = 0x00a02420 },\n\t{ .start = 0x00a02428, .end = 0x00a0242c },\n\t{ .start = 0x00a02434, .end = 0x00a02434 },\n\t{ .start = 0x00a02440, .end = 0x00a02460 },\n\t{ .start = 0x00a02468, .end = 0x00a024b0 },\n\t{ .start = 0x00a024c8, .end = 0x00a024cc },\n\t{ .start = 0x00a02500, .end = 0x00a02504 },\n\t{ .start = 0x00a0250c, .end = 0x00a02510 },\n\t{ .start = 0x00a02540, .end = 0x00a02554 },\n\t{ .start = 0x00a02580, .end = 0x00a025f4 },\n\t{ .start = 0x00a02600, .end = 0x00a0260c },\n\t{ .start = 0x00a02648, .end = 0x00a02650 },\n\t{ .start = 0x00a02680, .end = 0x00a02680 },\n\t{ .start = 0x00a026c0, .end = 0x00a026d0 },\n\t{ .start = 0x00a02700, .end = 0x00a0270c },\n\t{ .start = 0x00a02804, .end = 0x00a02804 },\n\t{ .start = 0x00a02818, .end = 0x00a0281c },\n\t{ .start = 0x00a02c00, .end = 0x00a02db4 },\n\t{ .start = 0x00a02df4, .end = 0x00a02fb0 },\n\t{ .start = 0x00a03000, .end = 0x00a03014 },\n\t{ .start = 0x00a0301c, .end = 0x00a0302c },\n\t{ .start = 0x00a03034, .end = 0x00a03038 },\n\t{ .start = 0x00a03040, .end = 0x00a03048 },\n\t{ .start = 0x00a03060, .end = 0x00a03068 },\n\t{ .start = 0x00a03070, .end = 0x00a03074 },\n\t{ .start = 0x00a0307c, .end = 0x00a0307c },\n\t{ .start = 0x00a03080, .end = 0x00a03084 },\n\t{ .start = 0x00a0308c, .end = 0x00a03090 },\n\t{ .start = 0x00a03098, .end = 0x00a03098 },\n\t{ .start = 0x00a030a0, .end = 0x00a030a0 },\n\t{ .start = 0x00a030a8, .end = 0x00a030b4 },\n\t{ .start = 0x00a030bc, .end = 0x00a030bc },\n\t{ .start = 0x00a030c0, .end = 0x00a0312c },\n\t{ .start = 0x00a03c00, .end = 0x00a03c5c },\n\t{ .start = 0x00a04400, .end = 0x00a04454 },\n\t{ .start = 0x00a04460, .end = 0x00a04474 },\n\t{ .start = 0x00a044c0, .end = 0x00a044ec },\n\t{ .start = 0x00a04500, .end = 0x00a04504 },\n\t{ .start = 0x00a04510, .end = 0x00a04538 },\n\t{ .start = 0x00a04540, .end = 0x00a04548 },\n\t{ .start = 0x00a04560, .end = 0x00a0457c },\n\t{ .start = 0x00a04590, .end = 0x00a04598 },\n\t{ .start = 0x00a045c0, .end = 0x00a045f4 },\n};\n\nstatic const struct iwl_prph_range iwl_prph_dump_addr_9000[] = {\n\t{ .start = 0x00a05c00, .end = 0x00a05c18 },\n\t{ .start = 0x00a05400, .end = 0x00a056e8 },\n\t{ .start = 0x00a08000, .end = 0x00a098bc },\n\t{ .start = 0x00a02400, .end = 0x00a02758 },\n\t{ .start = 0x00a04764, .end = 0x00a0476c },\n\t{ .start = 0x00a04770, .end = 0x00a04774 },\n\t{ .start = 0x00a04620, .end = 0x00a04624 },\n};\n\nstatic const struct iwl_prph_range iwl_prph_dump_addr_22000[] = {\n\t{ .start = 0x00a00000, .end = 0x00a00000 },\n\t{ .start = 0x00a0000c, .end = 0x00a00024 },\n\t{ .start = 0x00a0002c, .end = 0x00a00034 },\n\t{ .start = 0x00a0003c, .end = 0x00a0003c },\n\t{ .start = 0x00a00410, .end = 0x00a00418 },\n\t{ .start = 0x00a00420, .end = 0x00a00420 },\n\t{ .start = 0x00a00428, .end = 0x00a00428 },\n\t{ .start = 0x00a00430, .end = 0x00a0043c },\n\t{ .start = 0x00a00444, .end = 0x00a00444 },\n\t{ .start = 0x00a00840, .end = 0x00a00840 },\n\t{ .start = 0x00a00850, .end = 0x00a00858 },\n\t{ .start = 0x00a01004, .end = 0x00a01008 },\n\t{ .start = 0x00a01010, .end = 0x00a01010 },\n\t{ .start = 0x00a01018, .end = 0x00a01018 },\n\t{ .start = 0x00a01024, .end = 0x00a01024 },\n\t{ .start = 0x00a0102c, .end = 0x00a01034 },\n\t{ .start = 0x00a0103c, .end = 0x00a01040 },\n\t{ .start = 0x00a01048, .end = 0x00a01050 },\n\t{ .start = 0x00a01058, .end = 0x00a01058 },\n\t{ .start = 0x00a01060, .end = 0x00a01070 },\n\t{ .start = 0x00a0108c, .end = 0x00a0108c },\n\t{ .start = 0x00a01c20, .end = 0x00a01c28 },\n\t{ .start = 0x00a01d10, .end = 0x00a01d10 },\n\t{ .start = 0x00a01e28, .end = 0x00a01e2c },\n\t{ .start = 0x00a01e60, .end = 0x00a01e60 },\n\t{ .start = 0x00a01e80, .end = 0x00a01e80 },\n\t{ .start = 0x00a01ea0, .end = 0x00a01ea0 },\n\t{ .start = 0x00a02000, .end = 0x00a0201c },\n\t{ .start = 0x00a02024, .end = 0x00a02024 },\n\t{ .start = 0x00a02040, .end = 0x00a02048 },\n\t{ .start = 0x00a020c0, .end = 0x00a020e0 },\n\t{ .start = 0x00a02400, .end = 0x00a02404 },\n\t{ .start = 0x00a0240c, .end = 0x00a02414 },\n\t{ .start = 0x00a0241c, .end = 0x00a0243c },\n\t{ .start = 0x00a02448, .end = 0x00a024bc },\n\t{ .start = 0x00a024c4, .end = 0x00a024cc },\n\t{ .start = 0x00a02508, .end = 0x00a02508 },\n\t{ .start = 0x00a02510, .end = 0x00a02514 },\n\t{ .start = 0x00a0251c, .end = 0x00a0251c },\n\t{ .start = 0x00a0252c, .end = 0x00a0255c },\n\t{ .start = 0x00a02564, .end = 0x00a025a0 },\n\t{ .start = 0x00a025a8, .end = 0x00a025b4 },\n\t{ .start = 0x00a025c0, .end = 0x00a025c0 },\n\t{ .start = 0x00a025e8, .end = 0x00a025f4 },\n\t{ .start = 0x00a02c08, .end = 0x00a02c18 },\n\t{ .start = 0x00a02c2c, .end = 0x00a02c38 },\n\t{ .start = 0x00a02c68, .end = 0x00a02c78 },\n\t{ .start = 0x00a03000, .end = 0x00a03000 },\n\t{ .start = 0x00a03010, .end = 0x00a03014 },\n\t{ .start = 0x00a0301c, .end = 0x00a0302c },\n\t{ .start = 0x00a03034, .end = 0x00a03038 },\n\t{ .start = 0x00a03040, .end = 0x00a03044 },\n\t{ .start = 0x00a03060, .end = 0x00a03068 },\n\t{ .start = 0x00a03070, .end = 0x00a03070 },\n\t{ .start = 0x00a0307c, .end = 0x00a03084 },\n\t{ .start = 0x00a0308c, .end = 0x00a03090 },\n\t{ .start = 0x00a03098, .end = 0x00a03098 },\n\t{ .start = 0x00a030a0, .end = 0x00a030a0 },\n\t{ .start = 0x00a030a8, .end = 0x00a030b4 },\n\t{ .start = 0x00a030bc, .end = 0x00a030c0 },\n\t{ .start = 0x00a030c8, .end = 0x00a030f4 },\n\t{ .start = 0x00a03100, .end = 0x00a0312c },\n\t{ .start = 0x00a03c00, .end = 0x00a03c5c },\n\t{ .start = 0x00a04400, .end = 0x00a04454 },\n\t{ .start = 0x00a04460, .end = 0x00a04474 },\n\t{ .start = 0x00a044c0, .end = 0x00a044ec },\n\t{ .start = 0x00a04500, .end = 0x00a04504 },\n\t{ .start = 0x00a04510, .end = 0x00a04538 },\n\t{ .start = 0x00a04540, .end = 0x00a04548 },\n\t{ .start = 0x00a04560, .end = 0x00a04560 },\n\t{ .start = 0x00a04570, .end = 0x00a0457c },\n\t{ .start = 0x00a04590, .end = 0x00a04590 },\n\t{ .start = 0x00a04598, .end = 0x00a04598 },\n\t{ .start = 0x00a045c0, .end = 0x00a045f4 },\n\t{ .start = 0x00a05c18, .end = 0x00a05c1c },\n\t{ .start = 0x00a0c000, .end = 0x00a0c018 },\n\t{ .start = 0x00a0c020, .end = 0x00a0c028 },\n\t{ .start = 0x00a0c038, .end = 0x00a0c094 },\n\t{ .start = 0x00a0c0c0, .end = 0x00a0c104 },\n\t{ .start = 0x00a0c10c, .end = 0x00a0c118 },\n\t{ .start = 0x00a0c150, .end = 0x00a0c174 },\n\t{ .start = 0x00a0c17c, .end = 0x00a0c188 },\n\t{ .start = 0x00a0c190, .end = 0x00a0c198 },\n\t{ .start = 0x00a0c1a0, .end = 0x00a0c1a8 },\n\t{ .start = 0x00a0c1b0, .end = 0x00a0c1b8 },\n};\n\nstatic const struct iwl_prph_range iwl_prph_dump_addr_ax210[] = {\n\t{ .start = 0x00d03c00, .end = 0x00d03c64 },\n\t{ .start = 0x00d05c18, .end = 0x00d05c1c },\n\t{ .start = 0x00d0c000, .end = 0x00d0c174 },\n};\n\nstatic void iwl_read_prph_block(struct iwl_trans *trans, u32 start,\n\t\t\t\tu32 len_bytes, __le32 *data)\n{\n\tu32 i;\n\n\tfor (i = 0; i < len_bytes; i += 4)\n\t\t*data++ = cpu_to_le32(iwl_read_prph_no_grab(trans, start + i));\n}\n\nstatic void iwl_dump_prph(struct iwl_fw_runtime *fwrt,\n\t\t\t  const struct iwl_prph_range *iwl_prph_dump_addr,\n\t\t\t  u32 range_len, void *ptr)\n{\n\tstruct iwl_fw_error_dump_prph *prph;\n\tstruct iwl_trans *trans = fwrt->trans;\n\tstruct iwl_fw_error_dump_data **data =\n\t\t(struct iwl_fw_error_dump_data **)ptr;\n\tunsigned long flags;\n\tu32 i;\n\n\tif (!data)\n\t\treturn;\n\n\tIWL_DEBUG_INFO(trans, \"WRT PRPH dump\\n\");\n\n\tif (!iwl_trans_grab_nic_access(trans, &flags))\n\t\treturn;\n\n\tfor (i = 0; i < range_len; i++) {\n\t\t/* The range includes both boundaries */\n\t\tint num_bytes_in_chunk = iwl_prph_dump_addr[i].end -\n\t\t\t iwl_prph_dump_addr[i].start + 4;\n\n\t\t(*data)->type = cpu_to_le32(IWL_FW_ERROR_DUMP_PRPH);\n\t\t(*data)->len = cpu_to_le32(sizeof(*prph) +\n\t\t\t\t\tnum_bytes_in_chunk);\n\t\tprph = (void *)(*data)->data;\n\t\tprph->prph_start = cpu_to_le32(iwl_prph_dump_addr[i].start);\n\n\t\tiwl_read_prph_block(trans, iwl_prph_dump_addr[i].start,\n\t\t\t\t    /* our range is inclusive, hence + 4 */\n\t\t\t\t    iwl_prph_dump_addr[i].end -\n\t\t\t\t    iwl_prph_dump_addr[i].start + 4,\n\t\t\t\t    (void *)prph->data);\n\n\t\t*data = iwl_fw_error_next_data(*data);\n\t}\n\n\tiwl_trans_release_nic_access(trans, &flags);\n}\n\n/*\n * alloc_sgtable - allocates scallerlist table in the given size,\n * fills it with pages and returns it\n * @size: the size (in bytes) of the table\n*/\nstatic struct scatterlist *alloc_sgtable(int size)\n{\n\tint alloc_size, nents, i;\n\tstruct page *new_page;\n\tstruct scatterlist *iter;\n\tstruct scatterlist *table;\n\n\tnents = DIV_ROUND_UP(size, PAGE_SIZE);\n\ttable = kcalloc(nents, sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\treturn NULL;\n\tsg_init_table(table, nents);\n\titer = table;\n\tfor_each_sg(table, iter, sg_nents(table), i) {\n\t\tnew_page = alloc_page(GFP_KERNEL);\n\t\tif (!new_page) {\n\t\t\t/* release all previous allocated pages in the table */\n\t\t\titer = table;\n\t\t\tfor_each_sg(table, iter, sg_nents(table), i) {\n\t\t\t\tnew_page = sg_page(iter);\n\t\t\t\tif (new_page)\n\t\t\t\t\t__free_page(new_page);\n\t\t\t}\n\t\t\tkfree(table);\n\t\t\treturn NULL;\n\t\t}\n\t\talloc_size = min_t(int, size, PAGE_SIZE);\n\t\tsize -= PAGE_SIZE;\n\t\tsg_set_page(iter, new_page, alloc_size, 0);\n\t}\n\treturn table;\n}\n\nstatic void iwl_fw_get_prph_len(struct iwl_fw_runtime *fwrt,\n\t\t\t\tconst struct iwl_prph_range *iwl_prph_dump_addr,\n\t\t\t\tu32 range_len, void *ptr)\n{\n\tu32 *prph_len = (u32 *)ptr;\n\tint i, num_bytes_in_chunk;\n\n\tif (!prph_len)\n\t\treturn;\n\n\tfor (i = 0; i < range_len; i++) {\n\t\t/* The range includes both boundaries */\n\t\tnum_bytes_in_chunk =\n\t\t\tiwl_prph_dump_addr[i].end -\n\t\t\tiwl_prph_dump_addr[i].start + 4;\n\n\t\t*prph_len += sizeof(struct iwl_fw_error_dump_data) +\n\t\t\tsizeof(struct iwl_fw_error_dump_prph) +\n\t\t\tnum_bytes_in_chunk;\n\t}\n}\n\nstatic void iwl_fw_prph_handler(struct iwl_fw_runtime *fwrt, void *ptr,\n\t\t\t\tvoid (*handler)(struct iwl_fw_runtime *,\n\t\t\t\t\t\tconst struct iwl_prph_range *,\n\t\t\t\t\t\tu32, void *))\n{\n\tu32 range_len;\n\n\tif (fwrt->trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_AX210) {\n\t\trange_len = ARRAY_SIZE(iwl_prph_dump_addr_ax210);\n\t\thandler(fwrt, iwl_prph_dump_addr_ax210, range_len, ptr);\n\t} else if (fwrt->trans->trans_cfg->device_family >=\n\t\t   IWL_DEVICE_FAMILY_22000) {\n\t\trange_len = ARRAY_SIZE(iwl_prph_dump_addr_22000);\n\t\thandler(fwrt, iwl_prph_dump_addr_22000, range_len, ptr);\n\t} else {\n\t\trange_len = ARRAY_SIZE(iwl_prph_dump_addr_comm);\n\t\thandler(fwrt, iwl_prph_dump_addr_comm, range_len, ptr);\n\n\t\tif (fwrt->trans->trans_cfg->mq_rx_supported) {\n\t\t\trange_len = ARRAY_SIZE(iwl_prph_dump_addr_9000);\n\t\t\thandler(fwrt, iwl_prph_dump_addr_9000, range_len, ptr);\n\t\t}\n\t}\n}\n\nstatic void iwl_fw_dump_mem(struct iwl_fw_runtime *fwrt,\n\t\t\t    struct iwl_fw_error_dump_data **dump_data,\n\t\t\t    u32 len, u32 ofs, u32 type)\n{\n\tstruct iwl_fw_error_dump_mem *dump_mem;\n\n\tif (!len)\n\t\treturn;\n\n\t(*dump_data)->type = cpu_to_le32(IWL_FW_ERROR_DUMP_MEM);\n\t(*dump_data)->len = cpu_to_le32(len + sizeof(*dump_mem));\n\tdump_mem = (void *)(*dump_data)->data;\n\tdump_mem->type = cpu_to_le32(type);\n\tdump_mem->offset = cpu_to_le32(ofs);\n\tiwl_trans_read_mem_bytes(fwrt->trans, ofs, dump_mem->data, len);\n\t*dump_data = iwl_fw_error_next_data(*dump_data);\n\n\tIWL_DEBUG_INFO(fwrt, \"WRT memory dump. Type=%u\\n\", dump_mem->type);\n}\n\n#define ADD_LEN(len, item_len, const_len) \\\n\tdo {size_t item = item_len; len += (!!item) * const_len + item; } \\\n\twhile (0)\n\nstatic int iwl_fw_rxf_len(struct iwl_fw_runtime *fwrt,\n\t\t\t  struct iwl_fwrt_shared_mem_cfg *mem_cfg)\n{\n\tsize_t hdr_len = sizeof(struct iwl_fw_error_dump_data) +\n\t\t\t sizeof(struct iwl_fw_error_dump_fifo);\n\tu32 fifo_len = 0;\n\tint i;\n\n\tif (!iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_RXF))\n\t\treturn 0;\n\n\t/* Count RXF2 size */\n\tADD_LEN(fifo_len, mem_cfg->rxfifo2_size, hdr_len);\n\n\t/* Count RXF1 sizes */\n\tif (WARN_ON(mem_cfg->num_lmacs > MAX_NUM_LMAC))\n\t\tmem_cfg->num_lmacs = MAX_NUM_LMAC;\n\n\tfor (i = 0; i < mem_cfg->num_lmacs; i++)\n\t\tADD_LEN(fifo_len, mem_cfg->lmac[i].rxfifo1_size, hdr_len);\n\n\treturn fifo_len;\n}\n\nstatic int iwl_fw_txf_len(struct iwl_fw_runtime *fwrt,\n\t\t\t  struct iwl_fwrt_shared_mem_cfg *mem_cfg)\n{\n\tsize_t hdr_len = sizeof(struct iwl_fw_error_dump_data) +\n\t\t\t sizeof(struct iwl_fw_error_dump_fifo);\n\tu32 fifo_len = 0;\n\tint i;\n\n\tif (!iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_TXF))\n\t\tgoto dump_internal_txf;\n\n\t/* Count TXF sizes */\n\tif (WARN_ON(mem_cfg->num_lmacs > MAX_NUM_LMAC))\n\t\tmem_cfg->num_lmacs = MAX_NUM_LMAC;\n\n\tfor (i = 0; i < mem_cfg->num_lmacs; i++) {\n\t\tint j;\n\n\t\tfor (j = 0; j < mem_cfg->num_txfifo_entries; j++)\n\t\t\tADD_LEN(fifo_len, mem_cfg->lmac[i].txfifo_size[j],\n\t\t\t\thdr_len);\n\t}\n\ndump_internal_txf:\n\tif (!(iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_INTERNAL_TXF) &&\n\t      fw_has_capa(&fwrt->fw->ucode_capa,\n\t\t\t  IWL_UCODE_TLV_CAPA_EXTEND_SHARED_MEM_CFG)))\n\t\tgoto out;\n\n\tfor (i = 0; i < ARRAY_SIZE(mem_cfg->internal_txfifo_size); i++)\n\t\tADD_LEN(fifo_len, mem_cfg->internal_txfifo_size[i], hdr_len);\n\nout:\n\treturn fifo_len;\n}\n\nstatic void iwl_dump_paging(struct iwl_fw_runtime *fwrt,\n\t\t\t    struct iwl_fw_error_dump_data **data)\n{\n\tint i;\n\n\tIWL_DEBUG_INFO(fwrt, \"WRT paging dump\\n\");\n\tfor (i = 1; i < fwrt->num_of_paging_blk + 1; i++) {\n\t\tstruct iwl_fw_error_dump_paging *paging;\n\t\tstruct page *pages =\n\t\t\tfwrt->fw_paging_db[i].fw_paging_block;\n\t\tdma_addr_t addr = fwrt->fw_paging_db[i].fw_paging_phys;\n\n\t\t(*data)->type = cpu_to_le32(IWL_FW_ERROR_DUMP_PAGING);\n\t\t(*data)->len = cpu_to_le32(sizeof(*paging) +\n\t\t\t\t\t     PAGING_BLOCK_SIZE);\n\t\tpaging =  (void *)(*data)->data;\n\t\tpaging->index = cpu_to_le32(i);\n\t\tdma_sync_single_for_cpu(fwrt->trans->dev, addr,\n\t\t\t\t\tPAGING_BLOCK_SIZE,\n\t\t\t\t\tDMA_BIDIRECTIONAL);\n\t\tmemcpy(paging->data, page_address(pages),\n\t\t       PAGING_BLOCK_SIZE);\n\t\tdma_sync_single_for_device(fwrt->trans->dev, addr,\n\t\t\t\t\t   PAGING_BLOCK_SIZE,\n\t\t\t\t\t   DMA_BIDIRECTIONAL);\n\t\t(*data) = iwl_fw_error_next_data(*data);\n\t}\n}\n\nstatic struct iwl_fw_error_dump_file *\niwl_fw_error_dump_file(struct iwl_fw_runtime *fwrt,\n\t\t       struct iwl_fw_dump_ptrs *fw_error_dump)\n{\n\tstruct iwl_fw_error_dump_file *dump_file;\n\tstruct iwl_fw_error_dump_data *dump_data;\n\tstruct iwl_fw_error_dump_info *dump_info;\n\tstruct iwl_fw_error_dump_smem_cfg *dump_smem_cfg;\n\tstruct iwl_fw_error_dump_trigger_desc *dump_trig;\n\tu32 sram_len, sram_ofs;\n\tconst struct iwl_fw_dbg_mem_seg_tlv *fw_mem = fwrt->fw->dbg.mem_tlv;\n\tstruct iwl_fwrt_shared_mem_cfg *mem_cfg = &fwrt->smem_cfg;\n\tu32 file_len, fifo_len = 0, prph_len = 0, radio_len = 0;\n\tu32 smem_len = fwrt->fw->dbg.n_mem_tlv ? 0 : fwrt->trans->cfg->smem_len;\n\tu32 sram2_len = fwrt->fw->dbg.n_mem_tlv ?\n\t\t\t\t0 : fwrt->trans->cfg->dccm2_len;\n\tint i;\n\n\t/* SRAM - include stack CCM if driver knows the values for it */\n\tif (!fwrt->trans->cfg->dccm_offset || !fwrt->trans->cfg->dccm_len) {\n\t\tconst struct fw_img *img;\n\n\t\tif (fwrt->cur_fw_img >= IWL_UCODE_TYPE_MAX)\n\t\t\treturn NULL;\n\t\timg = &fwrt->fw->img[fwrt->cur_fw_img];\n\t\tsram_ofs = img->sec[IWL_UCODE_SECTION_DATA].offset;\n\t\tsram_len = img->sec[IWL_UCODE_SECTION_DATA].len;\n\t} else {\n\t\tsram_ofs = fwrt->trans->cfg->dccm_offset;\n\t\tsram_len = fwrt->trans->cfg->dccm_len;\n\t}\n\n\t/* reading RXF/TXF sizes */\n\tif (test_bit(STATUS_FW_ERROR, &fwrt->trans->status)) {\n\t\tfifo_len = iwl_fw_rxf_len(fwrt, mem_cfg);\n\t\tfifo_len += iwl_fw_txf_len(fwrt, mem_cfg);\n\n\t\t/* Make room for PRPH registers */\n\t\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_PRPH))\n\t\t\tiwl_fw_prph_handler(fwrt, &prph_len,\n\t\t\t\t\t    iwl_fw_get_prph_len);\n\n\t\tif (fwrt->trans->trans_cfg->device_family ==\n\t\t    IWL_DEVICE_FAMILY_7000 &&\n\t\t    iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_RADIO_REG))\n\t\t\tradio_len = sizeof(*dump_data) + RADIO_REG_MAX_READ;\n\t}\n\n\tfile_len = sizeof(*dump_file) + fifo_len + prph_len + radio_len;\n\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_DEV_FW_INFO))\n\t\tfile_len += sizeof(*dump_data) + sizeof(*dump_info);\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_MEM_CFG))\n\t\tfile_len += sizeof(*dump_data) + sizeof(*dump_smem_cfg);\n\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_MEM)) {\n\t\tsize_t hdr_len = sizeof(*dump_data) +\n\t\t\t\t sizeof(struct iwl_fw_error_dump_mem);\n\n\t\t/* Dump SRAM only if no mem_tlvs */\n\t\tif (!fwrt->fw->dbg.n_mem_tlv)\n\t\t\tADD_LEN(file_len, sram_len, hdr_len);\n\n\t\t/* Make room for all mem types that exist */\n\t\tADD_LEN(file_len, smem_len, hdr_len);\n\t\tADD_LEN(file_len, sram2_len, hdr_len);\n\n\t\tfor (i = 0; i < fwrt->fw->dbg.n_mem_tlv; i++)\n\t\t\tADD_LEN(file_len, le32_to_cpu(fw_mem[i].len), hdr_len);\n\t}\n\n\t/* Make room for fw's virtual image pages, if it exists */\n\tif (iwl_fw_dbg_is_paging_enabled(fwrt))\n\t\tfile_len += fwrt->num_of_paging_blk *\n\t\t\t(sizeof(*dump_data) +\n\t\t\t sizeof(struct iwl_fw_error_dump_paging) +\n\t\t\t PAGING_BLOCK_SIZE);\n\n\tif (iwl_fw_dbg_is_d3_debug_enabled(fwrt) && fwrt->dump.d3_debug_data) {\n\t\tfile_len += sizeof(*dump_data) +\n\t\t\tfwrt->trans->cfg->d3_debug_data_length * 2;\n\t}\n\n\t/* If we only want a monitor dump, reset the file length */\n\tif (fwrt->dump.monitor_only) {\n\t\tfile_len = sizeof(*dump_file) + sizeof(*dump_data) * 2 +\n\t\t\t   sizeof(*dump_info) + sizeof(*dump_smem_cfg);\n\t}\n\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_ERROR_INFO) &&\n\t    fwrt->dump.desc)\n\t\tfile_len += sizeof(*dump_data) + sizeof(*dump_trig) +\n\t\t\t    fwrt->dump.desc->len;\n\n\tdump_file = vzalloc(file_len);\n\tif (!dump_file)\n\t\treturn NULL;\n\n\tfw_error_dump->fwrt_ptr = dump_file;\n\n\tdump_file->barker = cpu_to_le32(IWL_FW_ERROR_DUMP_BARKER);\n\tdump_data = (void *)dump_file->data;\n\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_DEV_FW_INFO)) {\n\t\tdump_data->type = cpu_to_le32(IWL_FW_ERROR_DUMP_DEV_FW_INFO);\n\t\tdump_data->len = cpu_to_le32(sizeof(*dump_info));\n\t\tdump_info = (void *)dump_data->data;\n\t\tdump_info->hw_type =\n\t\t\tcpu_to_le32(CSR_HW_REV_TYPE(fwrt->trans->hw_rev));\n\t\tdump_info->hw_step =\n\t\t\tcpu_to_le32(CSR_HW_REV_STEP(fwrt->trans->hw_rev));\n\t\tmemcpy(dump_info->fw_human_readable, fwrt->fw->human_readable,\n\t\t       sizeof(dump_info->fw_human_readable));\n\t\tstrncpy(dump_info->dev_human_readable, fwrt->trans->cfg->name,\n\t\t\tsizeof(dump_info->dev_human_readable) - 1);\n\t\tstrncpy(dump_info->bus_human_readable, fwrt->dev->bus->name,\n\t\t\tsizeof(dump_info->bus_human_readable) - 1);\n\t\tdump_info->num_of_lmacs = fwrt->smem_cfg.num_lmacs;\n\t\tdump_info->lmac_err_id[0] =\n\t\t\tcpu_to_le32(fwrt->dump.lmac_err_id[0]);\n\t\tif (fwrt->smem_cfg.num_lmacs > 1)\n\t\t\tdump_info->lmac_err_id[1] =\n\t\t\t\tcpu_to_le32(fwrt->dump.lmac_err_id[1]);\n\t\tdump_info->umac_err_id = cpu_to_le32(fwrt->dump.umac_err_id);\n\n\t\tdump_data = iwl_fw_error_next_data(dump_data);\n\t}\n\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_MEM_CFG)) {\n\t\t/* Dump shared memory configuration */\n\t\tdump_data->type = cpu_to_le32(IWL_FW_ERROR_DUMP_MEM_CFG);\n\t\tdump_data->len = cpu_to_le32(sizeof(*dump_smem_cfg));\n\t\tdump_smem_cfg = (void *)dump_data->data;\n\t\tdump_smem_cfg->num_lmacs = cpu_to_le32(mem_cfg->num_lmacs);\n\t\tdump_smem_cfg->num_txfifo_entries =\n\t\t\tcpu_to_le32(mem_cfg->num_txfifo_entries);\n\t\tfor (i = 0; i < MAX_NUM_LMAC; i++) {\n\t\t\tint j;\n\t\t\tu32 *txf_size = mem_cfg->lmac[i].txfifo_size;\n\n\t\t\tfor (j = 0; j < TX_FIFO_MAX_NUM; j++)\n\t\t\t\tdump_smem_cfg->lmac[i].txfifo_size[j] =\n\t\t\t\t\tcpu_to_le32(txf_size[j]);\n\t\t\tdump_smem_cfg->lmac[i].rxfifo1_size =\n\t\t\t\tcpu_to_le32(mem_cfg->lmac[i].rxfifo1_size);\n\t\t}\n\t\tdump_smem_cfg->rxfifo2_size =\n\t\t\tcpu_to_le32(mem_cfg->rxfifo2_size);\n\t\tdump_smem_cfg->internal_txfifo_addr =\n\t\t\tcpu_to_le32(mem_cfg->internal_txfifo_addr);\n\t\tfor (i = 0; i < TX_FIFO_INTERNAL_MAX_NUM; i++) {\n\t\t\tdump_smem_cfg->internal_txfifo_size[i] =\n\t\t\t\tcpu_to_le32(mem_cfg->internal_txfifo_size[i]);\n\t\t}\n\n\t\tdump_data = iwl_fw_error_next_data(dump_data);\n\t}\n\n\t/* We only dump the FIFOs if the FW is in error state */\n\tif (fifo_len) {\n\t\tiwl_fw_dump_rxf(fwrt, &dump_data);\n\t\tiwl_fw_dump_txf(fwrt, &dump_data);\n\t}\n\n\tif (radio_len)\n\t\tiwl_read_radio_regs(fwrt, &dump_data);\n\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_ERROR_INFO) &&\n\t    fwrt->dump.desc) {\n\t\tdump_data->type = cpu_to_le32(IWL_FW_ERROR_DUMP_ERROR_INFO);\n\t\tdump_data->len = cpu_to_le32(sizeof(*dump_trig) +\n\t\t\t\t\t     fwrt->dump.desc->len);\n\t\tdump_trig = (void *)dump_data->data;\n\t\tmemcpy(dump_trig, &fwrt->dump.desc->trig_desc,\n\t\t       sizeof(*dump_trig) + fwrt->dump.desc->len);\n\n\t\tdump_data = iwl_fw_error_next_data(dump_data);\n\t}\n\n\t/* In case we only want monitor dump, skip to dump trasport data */\n\tif (fwrt->dump.monitor_only)\n\t\tgoto out;\n\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_MEM)) {\n\t\tconst struct iwl_fw_dbg_mem_seg_tlv *fw_dbg_mem =\n\t\t\tfwrt->fw->dbg.mem_tlv;\n\n\t\tif (!fwrt->fw->dbg.n_mem_tlv)\n\t\t\tiwl_fw_dump_mem(fwrt, &dump_data, sram_len, sram_ofs,\n\t\t\t\t\tIWL_FW_ERROR_DUMP_MEM_SRAM);\n\n\t\tfor (i = 0; i < fwrt->fw->dbg.n_mem_tlv; i++) {\n\t\t\tu32 len = le32_to_cpu(fw_dbg_mem[i].len);\n\t\t\tu32 ofs = le32_to_cpu(fw_dbg_mem[i].ofs);\n\n\t\t\tiwl_fw_dump_mem(fwrt, &dump_data, len, ofs,\n\t\t\t\t\tle32_to_cpu(fw_dbg_mem[i].data_type));\n\t\t}\n\n\t\tiwl_fw_dump_mem(fwrt, &dump_data, smem_len,\n\t\t\t\tfwrt->trans->cfg->smem_offset,\n\t\t\t\tIWL_FW_ERROR_DUMP_MEM_SMEM);\n\n\t\tiwl_fw_dump_mem(fwrt, &dump_data, sram2_len,\n\t\t\t\tfwrt->trans->cfg->dccm2_offset,\n\t\t\t\tIWL_FW_ERROR_DUMP_MEM_SRAM);\n\t}\n\n\tif (iwl_fw_dbg_is_d3_debug_enabled(fwrt) && fwrt->dump.d3_debug_data) {\n\t\tu32 addr = fwrt->trans->cfg->d3_debug_data_base_addr;\n\t\tsize_t data_size = fwrt->trans->cfg->d3_debug_data_length;\n\n\t\tdump_data->type = cpu_to_le32(IWL_FW_ERROR_DUMP_D3_DEBUG_DATA);\n\t\tdump_data->len = cpu_to_le32(data_size * 2);\n\n\t\tmemcpy(dump_data->data, fwrt->dump.d3_debug_data, data_size);\n\n\t\tkfree(fwrt->dump.d3_debug_data);\n\t\tfwrt->dump.d3_debug_data = NULL;\n\n\t\tiwl_trans_read_mem_bytes(fwrt->trans, addr,\n\t\t\t\t\t dump_data->data + data_size,\n\t\t\t\t\t data_size);\n\n\t\tdump_data = iwl_fw_error_next_data(dump_data);\n\t}\n\n\t/* Dump fw's virtual image */\n\tif (iwl_fw_dbg_is_paging_enabled(fwrt))\n\t\tiwl_dump_paging(fwrt, &dump_data);\n\n\tif (prph_len)\n\t\tiwl_fw_prph_handler(fwrt, &dump_data, iwl_dump_prph);\n\nout:\n\tdump_file->file_len = cpu_to_le32(file_len);\n\treturn dump_file;\n}\n\nstatic int iwl_dump_ini_prph_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t\t  struct iwl_fw_ini_region_cfg *reg,\n\t\t\t\t  void *range_ptr, int idx)\n{\n\tstruct iwl_fw_ini_error_dump_range *range = range_ptr;\n\t__le32 *val = range->data;\n\tu32 prph_val;\n\tu32 addr = le32_to_cpu(reg->start_addr[idx]) + le32_to_cpu(reg->offset);\n\tint i;\n\n\trange->internal_base_addr = cpu_to_le32(addr);\n\trange->range_data_size = reg->internal.range_data_size;\n\tfor (i = 0; i < le32_to_cpu(reg->internal.range_data_size); i += 4) {\n\t\tprph_val = iwl_read_prph(fwrt->trans, addr + i);\n\t\tif (prph_val == 0x5a5a5a5a)\n\t\t\treturn -EBUSY;\n\t\t*val++ = cpu_to_le32(prph_val);\n\t}\n\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstatic int iwl_dump_ini_csr_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t\t struct iwl_fw_ini_region_cfg *reg,\n\t\t\t\t void *range_ptr, int idx)\n{\n\tstruct iwl_fw_ini_error_dump_range *range = range_ptr;\n\t__le32 *val = range->data;\n\tu32 addr = le32_to_cpu(reg->start_addr[idx]) + le32_to_cpu(reg->offset);\n\tint i;\n\n\trange->internal_base_addr = cpu_to_le32(addr);\n\trange->range_data_size = reg->internal.range_data_size;\n\tfor (i = 0; i < le32_to_cpu(reg->internal.range_data_size); i += 4)\n\t\t*val++ = cpu_to_le32(iwl_trans_read32(fwrt->trans, addr + i));\n\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstatic int iwl_dump_ini_dev_mem_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t\t     struct iwl_fw_ini_region_cfg *reg,\n\t\t\t\t     void *range_ptr, int idx)\n{\n\tstruct iwl_fw_ini_error_dump_range *range = range_ptr;\n\tu32 addr = le32_to_cpu(reg->start_addr[idx]) + le32_to_cpu(reg->offset);\n\n\trange->internal_base_addr = cpu_to_le32(addr);\n\trange->range_data_size = reg->internal.range_data_size;\n\tiwl_trans_read_mem_bytes(fwrt->trans, addr, range->data,\n\t\t\t\t le32_to_cpu(reg->internal.range_data_size));\n\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstatic int _iwl_dump_ini_paging_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t\t     struct iwl_fw_ini_region_cfg *reg,\n\t\t\t\t     void *range_ptr, int idx)\n{\n\t/* increase idx by 1 since the pages are from 1 to\n\t * fwrt->num_of_paging_blk + 1\n\t */\n\tstruct page *page = fwrt->fw_paging_db[++idx].fw_paging_block;\n\tstruct iwl_fw_ini_error_dump_range *range = range_ptr;\n\tdma_addr_t addr = fwrt->fw_paging_db[idx].fw_paging_phys;\n\tu32 page_size = fwrt->fw_paging_db[idx].fw_paging_size;\n\n\trange->page_num = cpu_to_le32(idx);\n\trange->range_data_size = cpu_to_le32(page_size);\n\tdma_sync_single_for_cpu(fwrt->trans->dev, addr,\tpage_size,\n\t\t\t\tDMA_BIDIRECTIONAL);\n\tmemcpy(range->data, page_address(page), page_size);\n\tdma_sync_single_for_device(fwrt->trans->dev, addr, page_size,\n\t\t\t\t   DMA_BIDIRECTIONAL);\n\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstatic int iwl_dump_ini_paging_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t\t    struct iwl_fw_ini_region_cfg *reg,\n\t\t\t\t    void *range_ptr, int idx)\n{\n\tstruct iwl_fw_ini_error_dump_range *range;\n\tu32 page_size;\n\n\tif (!fwrt->trans->trans_cfg->gen2)\n\t\treturn _iwl_dump_ini_paging_iter(fwrt, reg, range_ptr, idx);\n\n\trange = range_ptr;\n\tpage_size = fwrt->trans->init_dram.paging[idx].size;\n\n\trange->page_num = cpu_to_le32(idx);\n\trange->range_data_size = cpu_to_le32(page_size);\n\tmemcpy(range->data, fwrt->trans->init_dram.paging[idx].block,\n\t       page_size);\n\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstatic int\niwl_dump_ini_mon_dram_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t   struct iwl_fw_ini_region_cfg *reg, void *range_ptr,\n\t\t\t   int idx)\n{\n\tstruct iwl_fw_ini_error_dump_range *range = range_ptr;\n\tu32 start_addr = iwl_read_umac_prph(fwrt->trans,\n\t\t\t\t\t    MON_BUFF_BASE_ADDR_VER2);\n\n\tif (start_addr == 0x5a5a5a5a)\n\t\treturn -EBUSY;\n\n\trange->dram_base_addr = cpu_to_le64(start_addr);\n\trange->range_data_size = cpu_to_le32(fwrt->trans->dbg.fw_mon[idx].size);\n\n\tmemcpy(range->data, fwrt->trans->dbg.fw_mon[idx].block,\n\t       fwrt->trans->dbg.fw_mon[idx].size);\n\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstatic bool iwl_ini_txf_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t     struct iwl_fw_ini_region_cfg *reg, int idx)\n{\n\tstruct iwl_txf_iter_data *iter = &fwrt->dump.txf_iter_data;\n\tstruct iwl_fwrt_shared_mem_cfg *cfg = &fwrt->smem_cfg;\n\tint txf_num = cfg->num_txfifo_entries;\n\tint int_txf_num = ARRAY_SIZE(cfg->internal_txfifo_size);\n\tu32 lmac_bitmap = le32_to_cpu(reg->fifos.fid1);\n\n\tif (!idx) {\n\t\tif (le32_to_cpu(reg->offset) &&\n\t\t    WARN_ONCE(cfg->num_lmacs == 1,\n\t\t\t      \"Invalid lmac offset: 0x%x\\n\",\n\t\t\t      le32_to_cpu(reg->offset)))\n\t\t\treturn false;\n\n\t\titer->internal_txf = 0;\n\t\titer->fifo_size = 0;\n\t\titer->fifo = -1;\n\t\tif (le32_to_cpu(reg->offset))\n\t\t\titer->lmac = 1;\n\t\telse\n\t\t\titer->lmac = 0;\n\t}\n\n\tif (!iter->internal_txf)\n\t\tfor (iter->fifo++; iter->fifo < txf_num; iter->fifo++) {\n\t\t\titer->fifo_size =\n\t\t\t\tcfg->lmac[iter->lmac].txfifo_size[iter->fifo];\n\t\t\tif (iter->fifo_size && (lmac_bitmap & BIT(iter->fifo)))\n\t\t\t\treturn true;\n\t\t}\n\n\titer->internal_txf = 1;\n\n\tif (!fw_has_capa(&fwrt->fw->ucode_capa,\n\t\t\t IWL_UCODE_TLV_CAPA_EXTEND_SHARED_MEM_CFG))\n\t\treturn false;\n\n\tfor (iter->fifo++; iter->fifo < int_txf_num + txf_num; iter->fifo++) {\n\t\titer->fifo_size =\n\t\t\tcfg->internal_txfifo_size[iter->fifo - txf_num];\n\t\tif (iter->fifo_size && (lmac_bitmap & BIT(iter->fifo)))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int iwl_dump_ini_txf_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t\t struct iwl_fw_ini_region_cfg *reg,\n\t\t\t\t void *range_ptr, int idx)\n{\n\tstruct iwl_fw_ini_error_dump_range *range = range_ptr;\n\tstruct iwl_txf_iter_data *iter = &fwrt->dump.txf_iter_data;\n\tstruct iwl_fw_ini_error_dump_register *reg_dump = (void *)range->data;\n\tu32 offs = le32_to_cpu(reg->offset), addr;\n\tu32 registers_size =\n\t\tle32_to_cpu(reg->fifos.num_of_registers) * sizeof(*reg_dump);\n\t__le32 *data;\n\tunsigned long flags;\n\tint i;\n\n\tif (!iwl_ini_txf_iter(fwrt, reg, idx))\n\t\treturn -EIO;\n\n\tif (!iwl_trans_grab_nic_access(fwrt->trans, &flags))\n\t\treturn -EBUSY;\n\n\trange->fifo_hdr.fifo_num = cpu_to_le32(iter->fifo);\n\trange->fifo_hdr.num_of_registers = reg->fifos.num_of_registers;\n\trange->range_data_size = cpu_to_le32(iter->fifo_size + registers_size);\n\n\tiwl_write_prph_no_grab(fwrt->trans, TXF_LARC_NUM + offs, iter->fifo);\n\n\t/*\n\t * read txf registers. for each register, write to the dump the\n\t * register address and its value\n\t */\n\tfor (i = 0; i < le32_to_cpu(reg->fifos.num_of_registers); i++) {\n\t\taddr = le32_to_cpu(reg->start_addr[i]) + offs;\n\n\t\treg_dump->addr = cpu_to_le32(addr);\n\t\treg_dump->data = cpu_to_le32(iwl_read_prph_no_grab(fwrt->trans,\n\t\t\t\t\t\t\t\t   addr));\n\n\t\treg_dump++;\n\t}\n\n\tif (reg->fifos.header_only) {\n\t\trange->range_data_size = cpu_to_le32(registers_size);\n\t\tgoto out;\n\t}\n\n\t/* Set the TXF_READ_MODIFY_ADDR to TXF_WR_PTR */\n\tiwl_write_prph_no_grab(fwrt->trans, TXF_READ_MODIFY_ADDR + offs,\n\t\t\t       TXF_WR_PTR + offs);\n\n\t/* Dummy-read to advance the read pointer to the head */\n\tiwl_read_prph_no_grab(fwrt->trans, TXF_READ_MODIFY_DATA + offs);\n\n\t/* Read FIFO */\n\taddr = TXF_READ_MODIFY_DATA + offs;\n\tdata = (void *)reg_dump;\n\tfor (i = 0; i < iter->fifo_size; i += sizeof(*data))\n\t\t*data++ = cpu_to_le32(iwl_read_prph_no_grab(fwrt->trans, addr));\n\nout:\n\tiwl_trans_release_nic_access(fwrt->trans, &flags);\n\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstruct iwl_ini_rxf_data {\n\tu32 fifo_num;\n\tu32 size;\n\tu32 offset;\n};\n\nstatic void iwl_ini_get_rxf_data(struct iwl_fw_runtime *fwrt,\n\t\t\t\t struct iwl_fw_ini_region_cfg *reg,\n\t\t\t\t struct iwl_ini_rxf_data *data)\n{\n\tu32 fid1 = le32_to_cpu(reg->fifos.fid1);\n\tu32 fid2 = le32_to_cpu(reg->fifos.fid2);\n\tu32 fifo_idx;\n\n\tif (!data)\n\t\treturn;\n\n\tmemset(data, 0, sizeof(*data));\n\n\tif (WARN_ON_ONCE((fid1 && fid2) || (!fid1 && !fid2)))\n\t\treturn;\n\n\tfifo_idx = ffs(fid1) - 1;\n\tif (fid1 && !WARN_ON_ONCE((~BIT(fifo_idx) & fid1) ||\n\t\t\t\t  fifo_idx >= MAX_NUM_LMAC)) {\n\t\tdata->size = fwrt->smem_cfg.lmac[fifo_idx].rxfifo1_size;\n\t\tdata->fifo_num = fifo_idx;\n\t\treturn;\n\t}\n\n\tfifo_idx = ffs(fid2) - 1;\n\tif (fid2 && !WARN_ON_ONCE(fifo_idx != 0)) {\n\t\tdata->size = fwrt->smem_cfg.rxfifo2_size;\n\t\tdata->offset = RXF_DIFF_FROM_PREV;\n\t\t/* use bit 31 to distinguish between umac and lmac rxf while\n\t\t * parsing the dump\n\t\t */\n\t\tdata->fifo_num = fifo_idx | IWL_RXF_UMAC_BIT;\n\t\treturn;\n\t}\n}\n\nstatic int iwl_dump_ini_rxf_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t\t struct iwl_fw_ini_region_cfg *reg,\n\t\t\t\t void *range_ptr, int idx)\n{\n\tstruct iwl_fw_ini_error_dump_range *range = range_ptr;\n\tstruct iwl_ini_rxf_data rxf_data;\n\tstruct iwl_fw_ini_error_dump_register *reg_dump = (void *)range->data;\n\tu32 offs = le32_to_cpu(reg->offset), addr;\n\tu32 registers_size =\n\t\tle32_to_cpu(reg->fifos.num_of_registers) * sizeof(*reg_dump);\n\t__le32 *data;\n\tunsigned long flags;\n\tint i;\n\n\tiwl_ini_get_rxf_data(fwrt, reg, &rxf_data);\n\tif (!rxf_data.size)\n\t\treturn -EIO;\n\n\tif (!iwl_trans_grab_nic_access(fwrt->trans, &flags))\n\t\treturn -EBUSY;\n\n\trange->fifo_hdr.fifo_num = cpu_to_le32(rxf_data.fifo_num);\n\trange->fifo_hdr.num_of_registers = reg->fifos.num_of_registers;\n\trange->range_data_size = cpu_to_le32(rxf_data.size + registers_size);\n\n\t/*\n\t * read rxf registers. for each register, write to the dump the\n\t * register address and its value\n\t */\n\tfor (i = 0; i < le32_to_cpu(reg->fifos.num_of_registers); i++) {\n\t\taddr = le32_to_cpu(reg->start_addr[i]) + offs;\n\n\t\treg_dump->addr = cpu_to_le32(addr);\n\t\treg_dump->data = cpu_to_le32(iwl_read_prph_no_grab(fwrt->trans,\n\t\t\t\t\t\t\t\t   addr));\n\n\t\treg_dump++;\n\t}\n\n\tif (reg->fifos.header_only) {\n\t\trange->range_data_size = cpu_to_le32(registers_size);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * region register have absolute value so apply rxf offset after\n\t * reading the registers\n\t */\n\toffs += rxf_data.offset;\n\n\t/* Lock fence */\n\tiwl_write_prph_no_grab(fwrt->trans, RXF_SET_FENCE_MODE + offs, 0x1);\n\t/* Set fence pointer to the same place like WR pointer */\n\tiwl_write_prph_no_grab(fwrt->trans, RXF_LD_WR2FENCE + offs, 0x1);\n\t/* Set fence offset */\n\tiwl_write_prph_no_grab(fwrt->trans, RXF_LD_FENCE_OFFSET_ADDR + offs,\n\t\t\t       0x0);\n\n\t/* Read FIFO */\n\taddr =  RXF_FIFO_RD_FENCE_INC + offs;\n\tdata = (void *)reg_dump;\n\tfor (i = 0; i < rxf_data.size; i += sizeof(*data))\n\t\t*data++ = cpu_to_le32(iwl_read_prph_no_grab(fwrt->trans, addr));\n\nout:\n\tiwl_trans_release_nic_access(fwrt->trans, &flags);\n\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstatic void *iwl_dump_ini_mem_fill_header(struct iwl_fw_runtime *fwrt,\n\t\t\t\t\t  struct iwl_fw_ini_region_cfg *reg,\n\t\t\t\t\t  void *data)\n{\n\tstruct iwl_fw_ini_error_dump *dump = data;\n\n\tdump->header.version = cpu_to_le32(IWL_INI_DUMP_VER);\n\n\treturn dump->ranges;\n}\n\nstatic void\n*iwl_dump_ini_mon_fill_header(struct iwl_fw_runtime *fwrt,\n\t\t\t      struct iwl_fw_ini_region_cfg *reg,\n\t\t\t      struct iwl_fw_ini_monitor_dump *data,\n\t\t\t      u32 write_ptr_addr, u32 write_ptr_msk,\n\t\t\t      u32 cycle_cnt_addr, u32 cycle_cnt_msk)\n{\n\tu32 write_ptr, cycle_cnt;\n\tunsigned long flags;\n\n\tif (!iwl_trans_grab_nic_access(fwrt->trans, &flags)) {\n\t\tIWL_ERR(fwrt, \"Failed to get monitor header\\n\");\n\t\treturn NULL;\n\t}\n\n\twrite_ptr = iwl_read_prph_no_grab(fwrt->trans, write_ptr_addr);\n\tcycle_cnt = iwl_read_prph_no_grab(fwrt->trans, cycle_cnt_addr);\n\n\tiwl_trans_release_nic_access(fwrt->trans, &flags);\n\n\tdata->header.version = cpu_to_le32(IWL_INI_DUMP_VER);\n\tdata->write_ptr = cpu_to_le32(write_ptr & write_ptr_msk);\n\tdata->cycle_cnt = cpu_to_le32(cycle_cnt & cycle_cnt_msk);\n\n\treturn data->ranges;\n}\n\nstatic void\n*iwl_dump_ini_mon_dram_fill_header(struct iwl_fw_runtime *fwrt,\n\t\t\t\t   struct iwl_fw_ini_region_cfg *reg,\n\t\t\t\t   void *data)\n{\n\tstruct iwl_fw_ini_monitor_dump *mon_dump = (void *)data;\n\tu32 write_ptr_addr, write_ptr_msk, cycle_cnt_addr, cycle_cnt_msk;\n\n\tswitch (fwrt->trans->trans_cfg->device_family) {\n\tcase IWL_DEVICE_FAMILY_9000:\n\tcase IWL_DEVICE_FAMILY_22000:\n\t\twrite_ptr_addr = MON_BUFF_WRPTR_VER2;\n\t\twrite_ptr_msk = -1;\n\t\tcycle_cnt_addr = MON_BUFF_CYCLE_CNT_VER2;\n\t\tcycle_cnt_msk = -1;\n\t\tbreak;\n\tdefault:\n\t\tIWL_ERR(fwrt, \"Unsupported device family %d\\n\",\n\t\t\tfwrt->trans->trans_cfg->device_family);\n\t\treturn NULL;\n\t}\n\n\treturn iwl_dump_ini_mon_fill_header(fwrt, reg, mon_dump, write_ptr_addr,\n\t\t\t\t\t    write_ptr_msk, cycle_cnt_addr,\n\t\t\t\t\t    cycle_cnt_msk);\n}\n\nstatic void\n*iwl_dump_ini_mon_smem_fill_header(struct iwl_fw_runtime *fwrt,\n\t\t\t\t   struct iwl_fw_ini_region_cfg *reg,\n\t\t\t\t   void *data)\n{\n\tstruct iwl_fw_ini_monitor_dump *mon_dump = (void *)data;\n\tconst struct iwl_cfg *cfg = fwrt->trans->cfg;\n\n\tif (fwrt->trans->trans_cfg->device_family != IWL_DEVICE_FAMILY_9000 &&\n\t    fwrt->trans->trans_cfg->device_family != IWL_DEVICE_FAMILY_22000) {\n\t\tIWL_ERR(fwrt, \"Unsupported device family %d\\n\",\n\t\t\tfwrt->trans->trans_cfg->device_family);\n\t\treturn NULL;\n\t}\n\n\treturn iwl_dump_ini_mon_fill_header(fwrt, reg, mon_dump,\n\t\t\t\t\t    cfg->fw_mon_smem_write_ptr_addr,\n\t\t\t\t\t    cfg->fw_mon_smem_write_ptr_msk,\n\t\t\t\t\t    cfg->fw_mon_smem_cycle_cnt_ptr_addr,\n\t\t\t\t\t    cfg->fw_mon_smem_cycle_cnt_ptr_msk);\n\n}\n\nstatic u32 iwl_dump_ini_mem_ranges(struct iwl_fw_runtime *fwrt,\n\t\t\t\t   struct iwl_fw_ini_region_cfg *reg)\n{\n\treturn le32_to_cpu(reg->internal.num_of_ranges);\n}\n\nstatic u32 iwl_dump_ini_paging_ranges(struct iwl_fw_runtime *fwrt,\n\t\t\t\t      struct iwl_fw_ini_region_cfg *reg)\n{\n\tif (fwrt->trans->trans_cfg->gen2)\n\t\treturn fwrt->trans->init_dram.paging_cnt;\n\n\treturn fwrt->num_of_paging_blk;\n}\n\nstatic u32 iwl_dump_ini_mon_dram_ranges(struct iwl_fw_runtime *fwrt,\n\t\t\t\t\tstruct iwl_fw_ini_region_cfg *reg)\n{\n\treturn 1;\n}\n\nstatic u32 iwl_dump_ini_txf_ranges(struct iwl_fw_runtime *fwrt,\n\t\t\t\t   struct iwl_fw_ini_region_cfg *reg)\n{\n\tu32 num_of_fifos = 0;\n\n\twhile (iwl_ini_txf_iter(fwrt, reg, num_of_fifos))\n\t\tnum_of_fifos++;\n\n\treturn num_of_fifos;\n}\n\nstatic u32 iwl_dump_ini_rxf_ranges(struct iwl_fw_runtime *fwrt,\n\t\t\t\t   struct iwl_fw_ini_region_cfg *reg)\n{\n\t/* Each Rx fifo needs a different offset and therefore, it's\n\t * region can contain only one fifo, i.e. 1 memory range.\n\t */\n\treturn 1;\n}\n\nstatic u32 iwl_dump_ini_mem_get_size(struct iwl_fw_runtime *fwrt,\n\t\t\t\t     struct iwl_fw_ini_region_cfg *reg)\n{\n\treturn sizeof(struct iwl_fw_ini_error_dump) +\n\t\tiwl_dump_ini_mem_ranges(fwrt, reg) *\n\t\t(sizeof(struct iwl_fw_ini_error_dump_range) +\n\t\t le32_to_cpu(reg->internal.range_data_size));\n}\n\nstatic u32 iwl_dump_ini_paging_get_size(struct iwl_fw_runtime *fwrt,\n\t\t\t\t\tstruct iwl_fw_ini_region_cfg *reg)\n{\n\tint i;\n\tu32 range_header_len = sizeof(struct iwl_fw_ini_error_dump_range);\n\tu32 size = sizeof(struct iwl_fw_ini_error_dump);\n\n\tif (fwrt->trans->trans_cfg->gen2) {\n\t\tfor (i = 0; i < iwl_dump_ini_paging_ranges(fwrt, reg); i++)\n\t\t\tsize += range_header_len +\n\t\t\t\tfwrt->trans->init_dram.paging[i].size;\n\t} else {\n\t\tfor (i = 1; i <= iwl_dump_ini_paging_ranges(fwrt, reg); i++)\n\t\t\tsize += range_header_len +\n\t\t\t\tfwrt->fw_paging_db[i].fw_paging_size;\n\t}\n\n\treturn size;\n}\n\nstatic u32 iwl_dump_ini_mon_dram_get_size(struct iwl_fw_runtime *fwrt,\n\t\t\t\t\t  struct iwl_fw_ini_region_cfg *reg)\n{\n\tu32 size = sizeof(struct iwl_fw_ini_monitor_dump) +\n\t\tsizeof(struct iwl_fw_ini_error_dump_range);\n\n\tif (fwrt->trans->dbg.num_blocks)\n\t\tsize += fwrt->trans->dbg.fw_mon[0].size;\n\n\treturn size;\n}\n\nstatic u32 iwl_dump_ini_mon_smem_get_size(struct iwl_fw_runtime *fwrt,\n\t\t\t\t\t  struct iwl_fw_ini_region_cfg *reg)\n{\n\treturn sizeof(struct iwl_fw_ini_monitor_dump) +\n\t\tiwl_dump_ini_mem_ranges(fwrt, reg) *\n\t\t(sizeof(struct iwl_fw_ini_error_dump_range) +\n\t\t le32_to_cpu(reg->internal.range_data_size));\n}\n\nstatic u32 iwl_dump_ini_txf_get_size(struct iwl_fw_runtime *fwrt,\n\t\t\t\t     struct iwl_fw_ini_region_cfg *reg)\n{\n\tstruct iwl_txf_iter_data *iter = &fwrt->dump.txf_iter_data;\n\tu32 size = 0;\n\tu32 fifo_hdr = sizeof(struct iwl_fw_ini_error_dump_range) +\n\t\tle32_to_cpu(reg->fifos.num_of_registers) *\n\t\tsizeof(struct iwl_fw_ini_error_dump_register);\n\n\twhile (iwl_ini_txf_iter(fwrt, reg, size)) {\n\t\tsize += fifo_hdr;\n\t\tif (!reg->fifos.header_only)\n\t\t\tsize += iter->fifo_size;\n\t}\n\n\tif (size)\n\t\tsize += sizeof(struct iwl_fw_ini_error_dump);\n\n\treturn size;\n}\n\nstatic u32 iwl_dump_ini_rxf_get_size(struct iwl_fw_runtime *fwrt,\n\t\t\t\t     struct iwl_fw_ini_region_cfg *reg)\n{\n\tstruct iwl_ini_rxf_data rx_data;\n\tu32 size = sizeof(struct iwl_fw_ini_error_dump) +\n\t\tsizeof(struct iwl_fw_ini_error_dump_range) +\n\t\tle32_to_cpu(reg->fifos.num_of_registers) *\n\t\tsizeof(struct iwl_fw_ini_error_dump_register);\n\n\tif (reg->fifos.header_only)\n\t\treturn size;\n\n\tiwl_ini_get_rxf_data(fwrt, reg, &rx_data);\n\tsize += rx_data.size;\n\n\treturn size;\n}\n\n/**\n * struct iwl_dump_ini_mem_ops - ini memory dump operations\n * @get_num_of_ranges: returns the number of memory ranges in the region.\n * @get_size: returns the total size of the region.\n * @fill_mem_hdr: fills region type specific headers and returns pointer to\n *\tthe first range or NULL if failed to fill headers.\n * @fill_range: copies a given memory range into the dump.\n *\tReturns the size of the range or negative error value otherwise.\n */\nstruct iwl_dump_ini_mem_ops {\n\tu32 (*get_num_of_ranges)(struct iwl_fw_runtime *fwrt,\n\t\t\t\t struct iwl_fw_ini_region_cfg *reg);\n\tu32 (*get_size)(struct iwl_fw_runtime *fwrt,\n\t\t\tstruct iwl_fw_ini_region_cfg *reg);\n\tvoid *(*fill_mem_hdr)(struct iwl_fw_runtime *fwrt,\n\t\t\t      struct iwl_fw_ini_region_cfg *reg, void *data);\n\tint (*fill_range)(struct iwl_fw_runtime *fwrt,\n\t\t\t  struct iwl_fw_ini_region_cfg *reg, void *range,\n\t\t\t  int idx);\n};\n\n/**\n * iwl_dump_ini_mem\n *\n * Creates a dump tlv and copy a memory region into it.\n * Returns the size of the current dump tlv or 0 if failed\n *\n * @fwrt: fw runtime struct\n * @list: list to add the dump tlv to\n * @reg: memory region\n * @ops: memory dump operations\n */\nstatic u32 iwl_dump_ini_mem(struct iwl_fw_runtime *fwrt, struct list_head *list,\n\t\t\t    struct iwl_fw_ini_region_cfg *reg,\n\t\t\t    const struct iwl_dump_ini_mem_ops *ops)\n{\n\tstruct iwl_fw_ini_dump_entry *entry;\n\tstruct iwl_fw_error_dump_data *tlv;\n\tstruct iwl_fw_ini_error_dump_header *header;\n\tu32 num_of_ranges, i, type = le32_to_cpu(reg->region_type), size;\n\tvoid *range;\n\n\tif (!ops->get_num_of_ranges || !ops->get_size || !ops->fill_mem_hdr ||\n\t    !ops->fill_range)\n\t\treturn 0;\n\n\tsize = ops->get_size(fwrt, reg);\n\tif (!size)\n\t\treturn 0;\n\n\tentry = kmalloc(sizeof(*entry) + sizeof(*tlv) + size, GFP_KERNEL);\n\tif (!entry)\n\t\treturn 0;\n\n\tentry->size = sizeof(*tlv) + size;\n\n\ttlv = (void *)entry->data;\n\ttlv->type = cpu_to_le32(type);\n\ttlv->len = cpu_to_le32(size);\n\n\tIWL_DEBUG_FW(fwrt, \"WRT: Collecting region: id=%d, type=%d\\n\",\n\t\t     le32_to_cpu(reg->region_id), type);\n\n\tnum_of_ranges = ops->get_num_of_ranges(fwrt, reg);\n\n\theader = (void *)tlv->data;\n\theader->region_id = reg->region_id;\n\theader->num_of_ranges = cpu_to_le32(num_of_ranges);\n\theader->name_len = cpu_to_le32(min_t(int, IWL_FW_INI_MAX_NAME,\n\t\t\t\t\t     le32_to_cpu(reg->name_len)));\n\tmemcpy(header->name, reg->name, le32_to_cpu(header->name_len));\n\n\trange = ops->fill_mem_hdr(fwrt, reg, header);\n\tif (!range) {\n\t\tIWL_ERR(fwrt,\n\t\t\t\"WRT: Failed to fill region header: id=%d, type=%d\\n\",\n\t\t\tle32_to_cpu(reg->region_id), type);\n\t\tgoto out_err;\n\t}\n\n\tfor (i = 0; i < num_of_ranges; i++) {\n\t\tint range_size = ops->fill_range(fwrt, reg, range, i);\n\n\t\tif (range_size < 0) {\n\t\t\tIWL_ERR(fwrt,\n\t\t\t\t\"WRT: Failed to dump region: id=%d, type=%d\\n\",\n\t\t\t\tle32_to_cpu(reg->region_id), type);\n\t\t\tgoto out_err;\n\t\t}\n\t\trange = range + range_size;\n\t}\n\n\tlist_add_tail(&entry->list, list);\n\n\treturn entry->size;\n\nout_err:\n\tkfree(entry);\n\n\treturn 0;\n}\n\nstatic u32 iwl_dump_ini_info(struct iwl_fw_runtime *fwrt,\n\t\t\t     struct iwl_fw_ini_trigger *trigger,\n\t\t\t     struct list_head *list)\n{\n\tstruct iwl_fw_ini_dump_entry *entry;\n\tstruct iwl_fw_error_dump_data *tlv;\n\tstruct iwl_fw_ini_dump_info *dump;\n\tu32 reg_ids_size = le32_to_cpu(trigger->num_regions) * sizeof(__le32);\n\tu32 size = sizeof(*tlv) + sizeof(*dump) + reg_ids_size;\n\n\tentry = kmalloc(sizeof(*entry) + size, GFP_KERNEL);\n\tif (!entry)\n\t\treturn 0;\n\n\tentry->size = size;\n\n\ttlv = (void *)entry->data;\n\ttlv->type = cpu_to_le32(IWL_INI_DUMP_INFO_TYPE);\n\ttlv->len = cpu_to_le32(sizeof(*dump) + reg_ids_size);\n\n\tdump = (void *)tlv->data;\n\n\tdump->version = cpu_to_le32(IWL_INI_DUMP_VER);\n\tdump->trigger_id = trigger->trigger_id;\n\tdump->is_external_cfg =\n\t\tcpu_to_le32(fwrt->trans->dbg.external_ini_cfg);\n\n\tdump->ver_type = cpu_to_le32(fwrt->dump.fw_ver.type);\n\tdump->ver_subtype = cpu_to_le32(fwrt->dump.fw_ver.subtype);\n\n\tdump->hw_step = cpu_to_le32(CSR_HW_REV_STEP(fwrt->trans->hw_rev));\n\tdump->hw_type = cpu_to_le32(CSR_HW_REV_TYPE(fwrt->trans->hw_rev));\n\n\tdump->rf_id_flavor =\n\t\tcpu_to_le32(CSR_HW_RFID_FLAVOR(fwrt->trans->hw_rf_id));\n\tdump->rf_id_dash = cpu_to_le32(CSR_HW_RFID_DASH(fwrt->trans->hw_rf_id));\n\tdump->rf_id_step = cpu_to_le32(CSR_HW_RFID_STEP(fwrt->trans->hw_rf_id));\n\tdump->rf_id_type = cpu_to_le32(CSR_HW_RFID_TYPE(fwrt->trans->hw_rf_id));\n\n\tdump->lmac_major = cpu_to_le32(fwrt->dump.fw_ver.lmac_major);\n\tdump->lmac_minor = cpu_to_le32(fwrt->dump.fw_ver.lmac_minor);\n\tdump->umac_major = cpu_to_le32(fwrt->dump.fw_ver.umac_major);\n\tdump->umac_minor = cpu_to_le32(fwrt->dump.fw_ver.umac_minor);\n\n\tdump->build_tag_len = cpu_to_le32(sizeof(dump->build_tag));\n\tmemcpy(dump->build_tag, fwrt->fw->human_readable,\n\t       sizeof(dump->build_tag));\n\n\tdump->img_name_len = cpu_to_le32(sizeof(dump->img_name));\n\tmemcpy(dump->img_name, fwrt->dump.img_name, sizeof(dump->img_name));\n\n\tdump->internal_dbg_cfg_name_len =\n\t\tcpu_to_le32(sizeof(dump->internal_dbg_cfg_name));\n\tmemcpy(dump->internal_dbg_cfg_name, fwrt->dump.internal_dbg_cfg_name,\n\t       sizeof(dump->internal_dbg_cfg_name));\n\n\tdump->external_dbg_cfg_name_len =\n\t\tcpu_to_le32(sizeof(dump->external_dbg_cfg_name));\n\n\tmemcpy(dump->external_dbg_cfg_name, fwrt->dump.external_dbg_cfg_name,\n\t       sizeof(dump->external_dbg_cfg_name));\n\n\tdump->regions_num = trigger->num_regions;\n\tmemcpy(dump->region_ids, trigger->data, reg_ids_size);\n\n\t/* add dump info TLV to the beginning of the list since it needs to be\n\t * the first TLV in the dump\n\t */\n\tlist_add(&entry->list, list);\n\n\treturn entry->size;\n}\n\nstatic const struct iwl_dump_ini_mem_ops iwl_dump_ini_region_ops[] = {\n\t[IWL_FW_INI_REGION_INVALID] = {},\n\t[IWL_FW_INI_REGION_DEVICE_MEMORY] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_mem_ranges,\n\t\t.get_size = iwl_dump_ini_mem_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_mem_fill_header,\n\t\t.fill_range = iwl_dump_ini_dev_mem_iter,\n\t},\n\t[IWL_FW_INI_REGION_PERIPHERY_MAC] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_mem_ranges,\n\t\t.get_size = iwl_dump_ini_mem_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_mem_fill_header,\n\t\t.fill_range = iwl_dump_ini_prph_iter,\n\t},\n\t[IWL_FW_INI_REGION_PERIPHERY_PHY] = {},\n\t[IWL_FW_INI_REGION_PERIPHERY_AUX] = {},\n\t[IWL_FW_INI_REGION_DRAM_BUFFER] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_mon_dram_ranges,\n\t\t.get_size = iwl_dump_ini_mon_dram_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_mon_dram_fill_header,\n\t\t.fill_range = iwl_dump_ini_mon_dram_iter,\n\t},\n\t[IWL_FW_INI_REGION_DRAM_IMR] = {},\n\t[IWL_FW_INI_REGION_INTERNAL_BUFFER] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_mem_ranges,\n\t\t.get_size = iwl_dump_ini_mon_smem_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_mon_smem_fill_header,\n\t\t.fill_range = iwl_dump_ini_dev_mem_iter,\n\t},\n\t[IWL_FW_INI_REGION_TXF] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_txf_ranges,\n\t\t.get_size = iwl_dump_ini_txf_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_mem_fill_header,\n\t\t.fill_range = iwl_dump_ini_txf_iter,\n\t},\n\t[IWL_FW_INI_REGION_RXF] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_rxf_ranges,\n\t\t.get_size = iwl_dump_ini_rxf_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_mem_fill_header,\n\t\t.fill_range = iwl_dump_ini_rxf_iter,\n\t},\n\t[IWL_FW_INI_REGION_PAGING] = {\n\t\t.fill_mem_hdr = iwl_dump_ini_mem_fill_header,\n\t\t.get_num_of_ranges = iwl_dump_ini_paging_ranges,\n\t\t.get_size = iwl_dump_ini_paging_get_size,\n\t\t.fill_range = iwl_dump_ini_paging_iter,\n\t},\n\t[IWL_FW_INI_REGION_CSR] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_mem_ranges,\n\t\t.get_size = iwl_dump_ini_mem_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_mem_fill_header,\n\t\t.fill_range = iwl_dump_ini_csr_iter,\n\t},\n\t[IWL_FW_INI_REGION_NOTIFICATION] = {},\n\t[IWL_FW_INI_REGION_DHC] = {},\n\t[IWL_FW_INI_REGION_LMAC_ERROR_TABLE] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_mem_ranges,\n\t\t.get_size = iwl_dump_ini_mem_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_mem_fill_header,\n\t\t.fill_range = iwl_dump_ini_dev_mem_iter,\n\t},\n\t[IWL_FW_INI_REGION_UMAC_ERROR_TABLE] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_mem_ranges,\n\t\t.get_size = iwl_dump_ini_mem_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_mem_fill_header,\n\t\t.fill_range = iwl_dump_ini_dev_mem_iter,\n\t},\n};\n\nstatic u32 iwl_dump_ini_trigger(struct iwl_fw_runtime *fwrt,\n\t\t\t\tstruct iwl_fw_ini_trigger *trigger,\n\t\t\t\tstruct list_head *list)\n{\n\tint i;\n\tu32 size = 0;\n\n\tfor (i = 0; i < le32_to_cpu(trigger->num_regions); i++) {\n\t\tu32 reg_id = le32_to_cpu(trigger->data[i]), reg_type;\n\t\tstruct iwl_fw_ini_region_cfg *reg;\n\n\t\tif (WARN_ON(reg_id >= ARRAY_SIZE(fwrt->dump.active_regs)))\n\t\t\tcontinue;\n\n\t\treg = fwrt->dump.active_regs[reg_id];\n\t\tif (!reg) {\n\t\t\tIWL_WARN(fwrt,\n\t\t\t\t \"WRT: Unassigned region id %d, skipping\\n\",\n\t\t\t\t reg_id);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* currently the driver supports always on domain only */\n\t\tif (le32_to_cpu(reg->domain) != IWL_FW_INI_DBG_DOMAIN_ALWAYS_ON)\n\t\t\tcontinue;\n\n\t\treg_type = le32_to_cpu(reg->region_type);\n\t\tif (reg_type >= ARRAY_SIZE(iwl_dump_ini_region_ops))\n\t\t\tcontinue;\n\n\t\tsize += iwl_dump_ini_mem(fwrt, list, reg,\n\t\t\t\t\t &iwl_dump_ini_region_ops[reg_type]);\n\t}\n\n\tif (size)\n\t\tsize += iwl_dump_ini_info(fwrt, trigger, list);\n\n\treturn size;\n}\n\nstatic u32 iwl_dump_ini_file_gen(struct iwl_fw_runtime *fwrt,\n\t\t\t\t enum iwl_fw_ini_trigger_id trig_id,\n\t\t\t\t struct list_head *list)\n{\n\tstruct iwl_fw_ini_dump_entry *entry;\n\tstruct iwl_fw_ini_dump_file_hdr *hdr;\n\tstruct iwl_fw_ini_trigger *trigger;\n\tu32 size;\n\n\tif (!iwl_fw_ini_trigger_on(fwrt, trig_id))\n\t\treturn 0;\n\n\ttrigger = fwrt->dump.active_trigs[trig_id].trig;\n\tif (!trigger || !le32_to_cpu(trigger->num_regions))\n\t\treturn 0;\n\n\tentry = kmalloc(sizeof(*entry) + sizeof(*hdr), GFP_KERNEL);\n\tif (!entry)\n\t\treturn 0;\n\n\tentry->size = sizeof(*hdr);\n\n\tsize = iwl_dump_ini_trigger(fwrt, trigger, list);\n\tif (!size) {\n\t\tkfree(entry);\n\t\treturn 0;\n\t}\n\n\thdr = (void *)entry->data;\n\thdr->barker = cpu_to_le32(IWL_FW_INI_ERROR_DUMP_BARKER);\n\thdr->file_len = cpu_to_le32(size + entry->size);\n\n\tlist_add(&entry->list, list);\n\n\treturn le32_to_cpu(hdr->file_len);\n}\n\nstatic void iwl_fw_error_dump(struct iwl_fw_runtime *fwrt)\n{\n\tstruct iwl_fw_dump_ptrs fw_error_dump = {};\n\tstruct iwl_fw_error_dump_file *dump_file;\n\tstruct scatterlist *sg_dump_data;\n\tu32 file_len;\n\tu32 dump_mask = fwrt->fw->dbg.dump_mask;\n\n\tdump_file = iwl_fw_error_dump_file(fwrt, &fw_error_dump);\n\tif (!dump_file)\n\t\tgoto out;\n\n\tif (fwrt->dump.monitor_only)\n\t\tdump_mask &= IWL_FW_ERROR_DUMP_FW_MONITOR;\n\n\tfw_error_dump.trans_ptr = iwl_trans_dump_data(fwrt->trans, dump_mask);\n\tfile_len = le32_to_cpu(dump_file->file_len);\n\tfw_error_dump.fwrt_len = file_len;\n\n\tif (fw_error_dump.trans_ptr) {\n\t\tfile_len += fw_error_dump.trans_ptr->len;\n\t\tdump_file->file_len = cpu_to_le32(file_len);\n\t}\n\n\tsg_dump_data = alloc_sgtable(file_len);\n\tif (sg_dump_data) {\n\t\tsg_pcopy_from_buffer(sg_dump_data,\n\t\t\t\t     sg_nents(sg_dump_data),\n\t\t\t\t     fw_error_dump.fwrt_ptr,\n\t\t\t\t     fw_error_dump.fwrt_len, 0);\n\t\tif (fw_error_dump.trans_ptr)\n\t\t\tsg_pcopy_from_buffer(sg_dump_data,\n\t\t\t\t\t     sg_nents(sg_dump_data),\n\t\t\t\t\t     fw_error_dump.trans_ptr->data,\n\t\t\t\t\t     fw_error_dump.trans_ptr->len,\n\t\t\t\t\t     fw_error_dump.fwrt_len);\n\t\tdev_coredumpsg(fwrt->trans->dev, sg_dump_data, file_len,\n\t\t\t       GFP_KERNEL);\n\t}\n\tvfree(fw_error_dump.fwrt_ptr);\n\tvfree(fw_error_dump.trans_ptr);\n\nout:\n\tiwl_fw_free_dump_desc(fwrt);\n}\n\nstatic void iwl_dump_ini_list_free(struct list_head *list)\n{\n\twhile (!list_empty(list)) {\n\t\tstruct iwl_fw_ini_dump_entry *entry =\n\t\t\tlist_entry(list->next, typeof(*entry), list);\n\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n}\n\nstatic void iwl_fw_error_ini_dump(struct iwl_fw_runtime *fwrt, u8 wk_idx)\n{\n\tenum iwl_fw_ini_trigger_id trig_id = fwrt->dump.wks[wk_idx].ini_trig_id;\n\tstruct list_head dump_list = LIST_HEAD_INIT(dump_list);\n\tstruct scatterlist *sg_dump_data;\n\tu32 file_len;\n\n\tfile_len = iwl_dump_ini_file_gen(fwrt, trig_id, &dump_list);\n\tif (!file_len)\n\t\tgoto out;\n\n\tsg_dump_data = alloc_sgtable(file_len);\n\tif (sg_dump_data) {\n\t\tstruct iwl_fw_ini_dump_entry *entry;\n\t\tint sg_entries = sg_nents(sg_dump_data);\n\t\tu32 offs = 0;\n\n\t\tlist_for_each_entry(entry, &dump_list, list) {\n\t\t\tsg_pcopy_from_buffer(sg_dump_data, sg_entries,\n\t\t\t\t\t     entry->data, entry->size, offs);\n\t\t\toffs += entry->size;\n\t\t}\n\t\tdev_coredumpsg(fwrt->trans->dev, sg_dump_data, file_len,\n\t\t\t       GFP_KERNEL);\n\t}\n\tiwl_dump_ini_list_free(&dump_list);\n\nout:\n\tfwrt->dump.wks[wk_idx].ini_trig_id = IWL_FW_TRIGGER_ID_INVALID;\n}\n\nconst struct iwl_fw_dump_desc iwl_dump_desc_assert = {\n\t.trig_desc = {\n\t\t.type = cpu_to_le32(FW_DBG_TRIGGER_FW_ASSERT),\n\t},\n};\nIWL_EXPORT_SYMBOL(iwl_dump_desc_assert);\n\nint iwl_fw_dbg_collect_desc(struct iwl_fw_runtime *fwrt,\n\t\t\t    const struct iwl_fw_dump_desc *desc,\n\t\t\t    bool monitor_only,\n\t\t\t    unsigned int delay)\n{\n\tu32 trig_type = le32_to_cpu(desc->trig_desc.type);\n\tint ret;\n\n\tif (iwl_trans_dbg_ini_valid(fwrt->trans)) {\n\t\tret = iwl_fw_dbg_ini_collect(fwrt, trig_type);\n\t\tif (!ret)\n\t\t\tiwl_fw_free_dump_desc(fwrt);\n\n\t\treturn ret;\n\t}\n\n\t/* use wks[0] since dump flow prior to ini does not need to support\n\t * consecutive triggers collection\n\t */\n\tif (test_and_set_bit(fwrt->dump.wks[0].idx, &fwrt->dump.active_wks))\n\t\treturn -EBUSY;\n\n\tif (WARN_ON(fwrt->dump.desc))\n\t\tiwl_fw_free_dump_desc(fwrt);\n\n\tIWL_WARN(fwrt, \"Collecting data: trigger %d fired.\\n\",\n\t\t le32_to_cpu(desc->trig_desc.type));\n\n\tfwrt->dump.desc = desc;\n\tfwrt->dump.monitor_only = monitor_only;\n\n\tschedule_delayed_work(&fwrt->dump.wks[0].wk, usecs_to_jiffies(delay));\n\n\treturn 0;\n}\nIWL_EXPORT_SYMBOL(iwl_fw_dbg_collect_desc);\n\nint iwl_fw_dbg_error_collect(struct iwl_fw_runtime *fwrt,\n\t\t\t     enum iwl_fw_dbg_trigger trig_type)\n{\n\tint ret;\n\tstruct iwl_fw_dump_desc *iwl_dump_error_desc;\n\n\tif (!test_bit(STATUS_DEVICE_ENABLED, &fwrt->trans->status))\n\t\treturn -EIO;\n\n\tiwl_dump_error_desc = kmalloc(sizeof(*iwl_dump_error_desc), GFP_KERNEL);\n\tif (!iwl_dump_error_desc)\n\t\treturn -ENOMEM;\n\n\tiwl_dump_error_desc->trig_desc.type = cpu_to_le32(trig_type);\n\tiwl_dump_error_desc->len = 0;\n\n\tret = iwl_fw_dbg_collect_desc(fwrt, iwl_dump_error_desc, false, 0);\n\tif (ret)\n\t\tkfree(iwl_dump_error_desc);\n\telse\n\t\tiwl_trans_sync_nmi(fwrt->trans);\n\n\treturn ret;\n}\nIWL_EXPORT_SYMBOL(iwl_fw_dbg_error_collect);\n\nint iwl_fw_dbg_collect(struct iwl_fw_runtime *fwrt,\n\t\t       enum iwl_fw_dbg_trigger trig,\n\t\t       const char *str, size_t len,\n\t\t       struct iwl_fw_dbg_trigger_tlv *trigger)\n{\n\tstruct iwl_fw_dump_desc *desc;\n\tunsigned int delay = 0;\n\tbool monitor_only = false;\n\n\tif (trigger) {\n\t\tu16 occurrences = le16_to_cpu(trigger->occurrences) - 1;\n\n\t\tif (!le16_to_cpu(trigger->occurrences))\n\t\t\treturn 0;\n\n\t\tif (trigger->flags & IWL_FW_DBG_FORCE_RESTART) {\n\t\t\tIWL_WARN(fwrt, \"Force restart: trigger %d fired.\\n\",\n\t\t\t\t trig);\n\t\t\tiwl_force_nmi(fwrt->trans);\n\t\t\treturn 0;\n\t\t}\n\n\t\ttrigger->occurrences = cpu_to_le16(occurrences);\n\t\tmonitor_only = trigger->mode & IWL_FW_DBG_TRIGGER_MONITOR_ONLY;\n\n\t\t/* convert msec to usec */\n\t\tdelay = le32_to_cpu(trigger->stop_delay) * USEC_PER_MSEC;\n\t}\n\n\tdesc = kzalloc(sizeof(*desc) + len, GFP_ATOMIC);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\n\tdesc->len = len;\n\tdesc->trig_desc.type = cpu_to_le32(trig);\n\tmemcpy(desc->trig_desc.data, str, len);\n\n\treturn iwl_fw_dbg_collect_desc(fwrt, desc, monitor_only, delay);\n}\nIWL_EXPORT_SYMBOL(iwl_fw_dbg_collect);\n\nint _iwl_fw_dbg_ini_collect(struct iwl_fw_runtime *fwrt,\n\t\t\t    enum iwl_fw_ini_trigger_id id)\n{\n\tstruct iwl_fw_ini_active_triggers *active;\n\tu32 occur, delay;\n\tunsigned long idx;\n\n\tif (WARN_ON(!iwl_fw_ini_trigger_on(fwrt, id)))\n\t\treturn -EINVAL;\n\n\tif (!iwl_fw_ini_trigger_on(fwrt, id)) {\n\t\tIWL_WARN(fwrt, \"WRT: Trigger %d is not active, aborting dump\\n\",\n\t\t\t id);\n\t\treturn -EINVAL;\n\t}\n\n\tactive = &fwrt->dump.active_trigs[id];\n\tdelay = le32_to_cpu(active->trig->dump_delay);\n\toccur = le32_to_cpu(active->trig->occurrences);\n\tif (!occur)\n\t\treturn 0;\n\n\tactive->trig->occurrences = cpu_to_le32(--occur);\n\n\tif (le32_to_cpu(active->trig->force_restart)) {\n\t\tIWL_WARN(fwrt, \"WRT: Force restart: trigger %d fired.\\n\", id);\n\t\tiwl_force_nmi(fwrt->trans);\n\t\treturn 0;\n\t}\n\n\t/* Check there is an available worker.\n\t * ffz return value is undefined if no zero exists,\n\t * so check against ~0UL first.\n\t */\n\tif (fwrt->dump.active_wks == ~0UL)\n\t\treturn -EBUSY;\n\n\tidx = ffz(fwrt->dump.active_wks);\n\n\tif (idx >= IWL_FW_RUNTIME_DUMP_WK_NUM ||\n\t    test_and_set_bit(fwrt->dump.wks[idx].idx, &fwrt->dump.active_wks))\n\t\treturn -EBUSY;\n\n\tfwrt->dump.wks[idx].ini_trig_id = id;\n\n\tIWL_WARN(fwrt, \"WRT: Collecting data: ini trigger %d fired.\\n\", id);\n\n\tschedule_delayed_work(&fwrt->dump.wks[idx].wk, usecs_to_jiffies(delay));\n\n\treturn 0;\n}\nIWL_EXPORT_SYMBOL(_iwl_fw_dbg_ini_collect);\n\nint iwl_fw_dbg_ini_collect(struct iwl_fw_runtime *fwrt, u32 legacy_trigger_id)\n{\n\tint id;\n\n\tswitch (legacy_trigger_id) {\n\tcase FW_DBG_TRIGGER_FW_ASSERT:\n\tcase FW_DBG_TRIGGER_ALIVE_TIMEOUT:\n\tcase FW_DBG_TRIGGER_DRIVER:\n\t\tid = IWL_FW_TRIGGER_ID_FW_ASSERT;\n\t\tbreak;\n\tcase FW_DBG_TRIGGER_USER:\n\t\tid = IWL_FW_TRIGGER_ID_USER_TRIGGER;\n\t\tbreak;\n\tdefault:\n\t\treturn -EIO;\n\t}\n\n\treturn _iwl_fw_dbg_ini_collect(fwrt, id);\n}\nIWL_EXPORT_SYMBOL(iwl_fw_dbg_ini_collect);\n\nint iwl_fw_dbg_collect_trig(struct iwl_fw_runtime *fwrt,\n\t\t\t    struct iwl_fw_dbg_trigger_tlv *trigger,\n\t\t\t    const char *fmt, ...)\n{\n\tint ret, len = 0;\n\tchar buf[64];\n\n\tif (fmt) {\n\t\tva_list ap;\n\n\t\tbuf[sizeof(buf) - 1] = '\\0';\n\n\t\tva_start(ap, fmt);\n\t\tvsnprintf(buf, sizeof(buf), fmt, ap);\n\t\tva_end(ap);\n\n\t\t/* check for truncation */\n\t\tif (WARN_ON_ONCE(buf[sizeof(buf) - 1]))\n\t\t\tbuf[sizeof(buf) - 1] = '\\0';\n\n\t\tlen = strlen(buf) + 1;\n\t}\n\n\tret = iwl_fw_dbg_collect(fwrt, le32_to_cpu(trigger->id), buf, len,\n\t\t\t\t trigger);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\nIWL_EXPORT_SYMBOL(iwl_fw_dbg_collect_trig);\n\nint iwl_fw_start_dbg_conf(struct iwl_fw_runtime *fwrt, u8 conf_id)\n{\n\tu8 *ptr;\n\tint ret;\n\tint i;\n\n\tif (WARN_ONCE(conf_id >= ARRAY_SIZE(fwrt->fw->dbg.conf_tlv),\n\t\t      \"Invalid configuration %d\\n\", conf_id))\n\t\treturn -EINVAL;\n\n\t/* EARLY START - firmware's configuration is hard coded */\n\tif ((!fwrt->fw->dbg.conf_tlv[conf_id] ||\n\t     !fwrt->fw->dbg.conf_tlv[conf_id]->num_of_hcmds) &&\n\t    conf_id == FW_DBG_START_FROM_ALIVE)\n\t\treturn 0;\n\n\tif (!fwrt->fw->dbg.conf_tlv[conf_id])\n\t\treturn -EINVAL;\n\n\tif (fwrt->dump.conf != FW_DBG_INVALID)\n\t\tIWL_WARN(fwrt, \"FW already configured (%d) - re-configuring\\n\",\n\t\t\t fwrt->dump.conf);\n\n\t/* Send all HCMDs for configuring the FW debug */\n\tptr = (void *)&fwrt->fw->dbg.conf_tlv[conf_id]->hcmd;\n\tfor (i = 0; i < fwrt->fw->dbg.conf_tlv[conf_id]->num_of_hcmds; i++) {\n\t\tstruct iwl_fw_dbg_conf_hcmd *cmd = (void *)ptr;\n\t\tstruct iwl_host_cmd hcmd = {\n\t\t\t.id = cmd->id,\n\t\t\t.len = { le16_to_cpu(cmd->len), },\n\t\t\t.data = { cmd->data, },\n\t\t};\n\n\t\tret = iwl_trans_send_cmd(fwrt->trans, &hcmd);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tptr += sizeof(*cmd);\n\t\tptr += le16_to_cpu(cmd->len);\n\t}\n\n\tfwrt->dump.conf = conf_id;\n\n\treturn 0;\n}\nIWL_EXPORT_SYMBOL(iwl_fw_start_dbg_conf);\n\n/* this function assumes dump_start was called beforehand and dump_end will be\n * called afterwards\n */\nstatic void iwl_fw_dbg_collect_sync(struct iwl_fw_runtime *fwrt, u8 wk_idx)\n{\n\tstruct iwl_fw_dbg_params params = {0};\n\n\tif (!test_bit(wk_idx, &fwrt->dump.active_wks))\n\t\treturn;\n\n\tif (fwrt->ops && fwrt->ops->fw_running &&\n\t    !fwrt->ops->fw_running(fwrt->ops_ctx)) {\n\t\tIWL_ERR(fwrt, \"Firmware not running - cannot dump error\\n\");\n\t\tiwl_fw_free_dump_desc(fwrt);\n\t\tgoto out;\n\t}\n\n\t/* there's no point in fw dump if the bus is dead */\n\tif (test_bit(STATUS_TRANS_DEAD, &fwrt->trans->status)) {\n\t\tIWL_ERR(fwrt, \"Skip fw error dump since bus is dead\\n\");\n\t\tgoto out;\n\t}\n\n\tif (iwl_fw_dbg_stop_restart_recording(fwrt, &params, true)) {\n\t\tIWL_ERR(fwrt, \"Failed to stop DBGC recording, aborting dump\\n\");\n\t\tgoto out;\n\t}\n\n\tIWL_DEBUG_FW_INFO(fwrt, \"WRT: Data collection start\\n\");\n\tif (iwl_trans_dbg_ini_valid(fwrt->trans))\n\t\tiwl_fw_error_ini_dump(fwrt, wk_idx);\n\telse\n\t\tiwl_fw_error_dump(fwrt);\n\tIWL_DEBUG_FW_INFO(fwrt, \"WRT: Data collection done\\n\");\n\n\tiwl_fw_dbg_stop_restart_recording(fwrt, &params, false);\n\nout:\n\tclear_bit(wk_idx, &fwrt->dump.active_wks);\n}\n\nvoid iwl_fw_error_dump_wk(struct work_struct *work)\n{\n\tstruct iwl_fw_runtime *fwrt;\n\ttypeof(fwrt->dump.wks[0]) *wks;\n\n\twks = container_of(work, typeof(fwrt->dump.wks[0]), wk.work);\n\tfwrt = container_of(wks, struct iwl_fw_runtime, dump.wks[wks->idx]);\n\n\t/* assumes the op mode mutex is locked in dump_start since\n\t * iwl_fw_dbg_collect_sync can't run in parallel\n\t */\n\tif (fwrt->ops && fwrt->ops->dump_start &&\n\t    fwrt->ops->dump_start(fwrt->ops_ctx))\n\t\treturn;\n\n\tiwl_fw_dbg_collect_sync(fwrt, wks->idx);\n\n\tif (fwrt->ops && fwrt->ops->dump_end)\n\t\tfwrt->ops->dump_end(fwrt->ops_ctx);\n}\n\nvoid iwl_fw_dbg_read_d3_debug_data(struct iwl_fw_runtime *fwrt)\n{\n\tconst struct iwl_cfg *cfg = fwrt->trans->cfg;\n\n\tif (!iwl_fw_dbg_is_d3_debug_enabled(fwrt))\n\t\treturn;\n\n\tif (!fwrt->dump.d3_debug_data) {\n\t\tfwrt->dump.d3_debug_data = kmalloc(cfg->d3_debug_data_length,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!fwrt->dump.d3_debug_data) {\n\t\t\tIWL_ERR(fwrt,\n\t\t\t\t\"failed to allocate memory for D3 debug data\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* if the buffer holds previous debug data it is overwritten */\n\tiwl_trans_read_mem_bytes(fwrt->trans, cfg->d3_debug_data_base_addr,\n\t\t\t\t fwrt->dump.d3_debug_data,\n\t\t\t\t cfg->d3_debug_data_length);\n}\nIWL_EXPORT_SYMBOL(iwl_fw_dbg_read_d3_debug_data);\n\nvoid iwl_fw_dbg_stop_sync(struct iwl_fw_runtime *fwrt)\n{\n\tint i;\n\n\tiwl_dbg_tlv_del_timers(fwrt->trans);\n\tfor (i = 0; i < IWL_FW_RUNTIME_DUMP_WK_NUM; i++)\n\t\tiwl_fw_dbg_collect_sync(fwrt, i);\n\n\tiwl_fw_dbg_stop_restart_recording(fwrt, NULL, true);\n}\nIWL_EXPORT_SYMBOL(iwl_fw_dbg_stop_sync);\n\n#define FSEQ_REG(x) { .addr = (x), .str = #x, }\n\nvoid iwl_fw_error_print_fseq_regs(struct iwl_fw_runtime *fwrt)\n{\n\tstruct iwl_trans *trans = fwrt->trans;\n\tunsigned long flags;\n\tint i;\n\tstruct {\n\t\tu32 addr;\n\t\tconst char *str;\n\t} fseq_regs[] = {\n\t\tFSEQ_REG(FSEQ_ERROR_CODE),\n\t\tFSEQ_REG(FSEQ_TOP_INIT_VERSION),\n\t\tFSEQ_REG(FSEQ_CNVIO_INIT_VERSION),\n\t\tFSEQ_REG(FSEQ_OTP_VERSION),\n\t\tFSEQ_REG(FSEQ_TOP_CONTENT_VERSION),\n\t\tFSEQ_REG(FSEQ_ALIVE_TOKEN),\n\t\tFSEQ_REG(FSEQ_CNVI_ID),\n\t\tFSEQ_REG(FSEQ_CNVR_ID),\n\t\tFSEQ_REG(CNVI_AUX_MISC_CHIP),\n\t\tFSEQ_REG(CNVR_AUX_MISC_CHIP),\n\t\tFSEQ_REG(CNVR_SCU_SD_REGS_SD_REG_DIG_DCDC_VTRIM),\n\t\tFSEQ_REG(CNVR_SCU_SD_REGS_SD_REG_ACTIVE_VDIG_MIRROR),\n\t};\n\n\tif (!iwl_trans_grab_nic_access(trans, &flags))\n\t\treturn;\n\n\tIWL_ERR(fwrt, \"Fseq Registers:\\n\");\n\n\tfor (i = 0; i < ARRAY_SIZE(fseq_regs); i++)\n\t\tIWL_ERR(fwrt, \"0x%08X | %s\\n\",\n\t\t\tiwl_read_prph_no_grab(trans, fseq_regs[i].addr),\n\t\t\tfseq_regs[i].str);\n\n\tiwl_trans_release_nic_access(trans, &flags);\n}\nIWL_EXPORT_SYMBOL(iwl_fw_error_print_fseq_regs);\n\nstatic int iwl_fw_dbg_suspend_resume_hcmd(struct iwl_trans *trans, bool suspend)\n{\n\tstruct iwl_dbg_suspend_resume_cmd cmd = {\n\t\t.operation = suspend ?\n\t\t\tcpu_to_le32(DBGC_SUSPEND_CMD) :\n\t\t\tcpu_to_le32(DBGC_RESUME_CMD),\n\t};\n\tstruct iwl_host_cmd hcmd = {\n\t\t.id = WIDE_ID(DEBUG_GROUP, DBGC_SUSPEND_RESUME),\n\t\t.data[0] = &cmd,\n\t\t.len[0] = sizeof(cmd),\n\t};\n\n\treturn iwl_trans_send_cmd(trans, &hcmd);\n}\n\nstatic void iwl_fw_dbg_stop_recording(struct iwl_trans *trans,\n\t\t\t\t      struct iwl_fw_dbg_params *params)\n{\n\tif (trans->trans_cfg->device_family == IWL_DEVICE_FAMILY_7000) {\n\t\tiwl_set_bits_prph(trans, MON_BUFF_SAMPLE_CTL, 0x100);\n\t\treturn;\n\t}\n\n\tif (params) {\n\t\tparams->in_sample = iwl_read_umac_prph(trans, DBGC_IN_SAMPLE);\n\t\tparams->out_ctrl = iwl_read_umac_prph(trans, DBGC_OUT_CTRL);\n\t}\n\n\tiwl_write_umac_prph(trans, DBGC_IN_SAMPLE, 0);\n\t/* wait for the DBGC to finish writing the internal buffer to DRAM to\n\t * avoid halting the HW while writing\n\t */\n\tusleep_range(700, 1000);\n\tiwl_write_umac_prph(trans, DBGC_OUT_CTRL, 0);\n}\n\nstatic int iwl_fw_dbg_restart_recording(struct iwl_trans *trans,\n\t\t\t\t\tstruct iwl_fw_dbg_params *params)\n{\n\tif (!params)\n\t\treturn -EIO;\n\n\tif (trans->trans_cfg->device_family == IWL_DEVICE_FAMILY_7000) {\n\t\tiwl_clear_bits_prph(trans, MON_BUFF_SAMPLE_CTL, 0x100);\n\t\tiwl_clear_bits_prph(trans, MON_BUFF_SAMPLE_CTL, 0x1);\n\t\tiwl_set_bits_prph(trans, MON_BUFF_SAMPLE_CTL, 0x1);\n\t} else {\n\t\tiwl_write_umac_prph(trans, DBGC_IN_SAMPLE, params->in_sample);\n\t\tiwl_write_umac_prph(trans, DBGC_OUT_CTRL, params->out_ctrl);\n\t}\n\n\treturn 0;\n}\n\nint iwl_fw_dbg_stop_restart_recording(struct iwl_fw_runtime *fwrt,\n\t\t\t\t      struct iwl_fw_dbg_params *params,\n\t\t\t\t      bool stop)\n{\n\tint ret = 0;\n\n\t/* if the FW crashed or not debug monitor cfg was given, there is\n\t * no point in changing the recording state\n\t */\n\tif (test_bit(STATUS_FW_ERROR, &fwrt->trans->status) ||\n\t    (!fwrt->trans->dbg.dest_tlv &&\n\t     fwrt->trans->dbg.ini_dest == IWL_FW_INI_LOCATION_INVALID))\n\t\treturn 0;\n\n\tif (fw_has_capa(&fwrt->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_DBG_SUSPEND_RESUME_CMD_SUPP))\n\t\tret = iwl_fw_dbg_suspend_resume_hcmd(fwrt->trans, stop);\n\telse if (stop)\n\t\tiwl_fw_dbg_stop_recording(fwrt->trans, params);\n\telse\n\t\tret = iwl_fw_dbg_restart_recording(fwrt->trans, params);\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tif (!ret) {\n\t\tif (stop)\n\t\t\tfwrt->trans->dbg.rec_on = false;\n\t\telse\n\t\t\tiwl_fw_set_dbg_rec_on(fwrt);\n\t}\n#endif\n\n\treturn ret;\n}\nIWL_EXPORT_SYMBOL(iwl_fw_dbg_stop_restart_recording);\n"], "filenames": ["drivers/net/wireless/intel/iwlwifi/fw/dbg.c"], "buggy_code_start_loc": [648], "buggy_code_end_loc": [648], "fixing_code_start_loc": [649], "fixing_code_end_loc": [650], "type": "CWE-401", "message": "A memory leak in the alloc_sgtable() function in drivers/net/wireless/intel/iwlwifi/fw/dbg.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering alloc_page() failures, aka CID-b4b814fec1a5.", "other": {"cve": {"id": "CVE-2019-19058", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-18T06:15:12.200", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A memory leak in the alloc_sgtable() function in drivers/net/wireless/intel/iwlwifi/fw/dbg.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering alloc_page() failures, aka CID-b4b814fec1a5."}, {"lang": "es", "value": "Una p\u00e9rdida de memoria en la funci\u00f3n alloc_sgtable() en el archivo drivers/net/wireless/intel/iwlwifi/fw/dbg.c en el kernel de Linux versiones hasta la versi\u00f3n  5.3.11, permite a atacantes causar una denegaci\u00f3n de servicio (consumo de memoria) al desencadenar fallos de la funci\u00f3n alloc_page() , tambi\u00e9n se conoce como CID-b4b814fec1a5."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.7}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.3.11", "matchCriteriaId": "EB2904AC-AD7A-498D-8619-CBB421E9165D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-12/msg00029.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/b4b814fec1a5a849383f7b3886b654a13abbda7d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/O3PSDE6PTOTVBK2YTKB2TFQP2SUBVSNF/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PY7LJMSPAGRIKABJPDKQDTXYW3L5RX2T/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191205-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4300-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4301-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4302-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/b4b814fec1a5a849383f7b3886b654a13abbda7d"}}