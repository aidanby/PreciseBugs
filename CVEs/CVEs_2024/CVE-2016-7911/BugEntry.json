{"buggy_code": ["/*\n * fs/ioprio.c\n *\n * Copyright (C) 2004 Jens Axboe <axboe@kernel.dk>\n *\n * Helper functions for setting/querying io priorities of processes. The\n * system calls closely mimmick getpriority/setpriority, see the man page for\n * those. The prio argument is a composite of prio class and prio data, where\n * the data argument has meaning within that class. The standard scheduling\n * classes have 8 distinct prio levels, with 0 being the highest prio and 7\n * being the lowest.\n *\n * IOW, setting BE scheduling class with prio 2 is done ala:\n *\n * unsigned int prio = (IOPRIO_CLASS_BE << IOPRIO_CLASS_SHIFT) | 2;\n *\n * ioprio_set(PRIO_PROCESS, pid, prio);\n *\n * See also Documentation/block/ioprio.txt\n *\n */\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/ioprio.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/pid_namespace.h>\n\nint set_task_ioprio(struct task_struct *task, int ioprio)\n{\n\tint err;\n\tstruct io_context *ioc;\n\tconst struct cred *cred = current_cred(), *tcred;\n\n\trcu_read_lock();\n\ttcred = __task_cred(task);\n\tif (!uid_eq(tcred->uid, cred->euid) &&\n\t    !uid_eq(tcred->uid, cred->uid) && !capable(CAP_SYS_NICE)) {\n\t\trcu_read_unlock();\n\t\treturn -EPERM;\n\t}\n\trcu_read_unlock();\n\n\terr = security_task_setioprio(task, ioprio);\n\tif (err)\n\t\treturn err;\n\n\tioc = get_task_io_context(task, GFP_ATOMIC, NUMA_NO_NODE);\n\tif (ioc) {\n\t\tioc->ioprio = ioprio;\n\t\tput_io_context(ioc);\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(set_task_ioprio);\n\nSYSCALL_DEFINE3(ioprio_set, int, which, int, who, int, ioprio)\n{\n\tint class = IOPRIO_PRIO_CLASS(ioprio);\n\tint data = IOPRIO_PRIO_DATA(ioprio);\n\tstruct task_struct *p, *g;\n\tstruct user_struct *user;\n\tstruct pid *pgrp;\n\tkuid_t uid;\n\tint ret;\n\n\tswitch (class) {\n\t\tcase IOPRIO_CLASS_RT:\n\t\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\t\treturn -EPERM;\n\t\t\t/* fall through, rt has prio field too */\n\t\tcase IOPRIO_CLASS_BE:\n\t\t\tif (data >= IOPRIO_BE_NR || data < 0)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tbreak;\n\t\tcase IOPRIO_CLASS_IDLE:\n\t\t\tbreak;\n\t\tcase IOPRIO_CLASS_NONE:\n\t\t\tif (data)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\tret = -ESRCH;\n\trcu_read_lock();\n\tswitch (which) {\n\t\tcase IOPRIO_WHO_PROCESS:\n\t\t\tif (!who)\n\t\t\t\tp = current;\n\t\t\telse\n\t\t\t\tp = find_task_by_vpid(who);\n\t\t\tif (p)\n\t\t\t\tret = set_task_ioprio(p, ioprio);\n\t\t\tbreak;\n\t\tcase IOPRIO_WHO_PGRP:\n\t\t\tif (!who)\n\t\t\t\tpgrp = task_pgrp(current);\n\t\t\telse\n\t\t\t\tpgrp = find_vpid(who);\n\t\t\tdo_each_pid_thread(pgrp, PIDTYPE_PGID, p) {\n\t\t\t\tret = set_task_ioprio(p, ioprio);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t} while_each_pid_thread(pgrp, PIDTYPE_PGID, p);\n\t\t\tbreak;\n\t\tcase IOPRIO_WHO_USER:\n\t\t\tuid = make_kuid(current_user_ns(), who);\n\t\t\tif (!uid_valid(uid))\n\t\t\t\tbreak;\n\t\t\tif (!who)\n\t\t\t\tuser = current_user();\n\t\t\telse\n\t\t\t\tuser = find_user(uid);\n\n\t\t\tif (!user)\n\t\t\t\tbreak;\n\n\t\t\tdo_each_thread(g, p) {\n\t\t\t\tif (!uid_eq(task_uid(p), uid) ||\n\t\t\t\t    !task_pid_vnr(p))\n\t\t\t\t\tcontinue;\n\t\t\t\tret = set_task_ioprio(p, ioprio);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto free_uid;\n\t\t\t} while_each_thread(g, p);\nfree_uid:\n\t\t\tif (who)\n\t\t\t\tfree_uid(user);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic int get_task_ioprio(struct task_struct *p)\n{\n\tint ret;\n\n\tret = security_task_getioprio(p);\n\tif (ret)\n\t\tgoto out;\n\tret = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, IOPRIO_NORM);\n\tif (p->io_context)\n\t\tret = p->io_context->ioprio;\nout:\n\treturn ret;\n}\n\nint ioprio_best(unsigned short aprio, unsigned short bprio)\n{\n\tunsigned short aclass;\n\tunsigned short bclass;\n\n\tif (!ioprio_valid(aprio))\n\t\taprio = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_BE, IOPRIO_NORM);\n\tif (!ioprio_valid(bprio))\n\t\tbprio = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_BE, IOPRIO_NORM);\n\n\taclass = IOPRIO_PRIO_CLASS(aprio);\n\tbclass = IOPRIO_PRIO_CLASS(bprio);\n\tif (aclass == bclass)\n\t\treturn min(aprio, bprio);\n\tif (aclass > bclass)\n\t\treturn bprio;\n\telse\n\t\treturn aprio;\n}\n\nSYSCALL_DEFINE2(ioprio_get, int, which, int, who)\n{\n\tstruct task_struct *g, *p;\n\tstruct user_struct *user;\n\tstruct pid *pgrp;\n\tkuid_t uid;\n\tint ret = -ESRCH;\n\tint tmpio;\n\n\trcu_read_lock();\n\tswitch (which) {\n\t\tcase IOPRIO_WHO_PROCESS:\n\t\t\tif (!who)\n\t\t\t\tp = current;\n\t\t\telse\n\t\t\t\tp = find_task_by_vpid(who);\n\t\t\tif (p)\n\t\t\t\tret = get_task_ioprio(p);\n\t\t\tbreak;\n\t\tcase IOPRIO_WHO_PGRP:\n\t\t\tif (!who)\n\t\t\t\tpgrp = task_pgrp(current);\n\t\t\telse\n\t\t\t\tpgrp = find_vpid(who);\n\t\t\tdo_each_pid_thread(pgrp, PIDTYPE_PGID, p) {\n\t\t\t\ttmpio = get_task_ioprio(p);\n\t\t\t\tif (tmpio < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ret == -ESRCH)\n\t\t\t\t\tret = tmpio;\n\t\t\t\telse\n\t\t\t\t\tret = ioprio_best(ret, tmpio);\n\t\t\t} while_each_pid_thread(pgrp, PIDTYPE_PGID, p);\n\t\t\tbreak;\n\t\tcase IOPRIO_WHO_USER:\n\t\t\tuid = make_kuid(current_user_ns(), who);\n\t\t\tif (!who)\n\t\t\t\tuser = current_user();\n\t\t\telse\n\t\t\t\tuser = find_user(uid);\n\n\t\t\tif (!user)\n\t\t\t\tbreak;\n\n\t\t\tdo_each_thread(g, p) {\n\t\t\t\tif (!uid_eq(task_uid(p), user->uid) ||\n\t\t\t\t    !task_pid_vnr(p))\n\t\t\t\t\tcontinue;\n\t\t\t\ttmpio = get_task_ioprio(p);\n\t\t\t\tif (tmpio < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ret == -ESRCH)\n\t\t\t\t\tret = tmpio;\n\t\t\t\telse\n\t\t\t\t\tret = ioprio_best(ret, tmpio);\n\t\t\t} while_each_thread(g, p);\n\n\t\t\tif (who)\n\t\t\t\tfree_uid(user);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}\n"], "fixing_code": ["/*\n * fs/ioprio.c\n *\n * Copyright (C) 2004 Jens Axboe <axboe@kernel.dk>\n *\n * Helper functions for setting/querying io priorities of processes. The\n * system calls closely mimmick getpriority/setpriority, see the man page for\n * those. The prio argument is a composite of prio class and prio data, where\n * the data argument has meaning within that class. The standard scheduling\n * classes have 8 distinct prio levels, with 0 being the highest prio and 7\n * being the lowest.\n *\n * IOW, setting BE scheduling class with prio 2 is done ala:\n *\n * unsigned int prio = (IOPRIO_CLASS_BE << IOPRIO_CLASS_SHIFT) | 2;\n *\n * ioprio_set(PRIO_PROCESS, pid, prio);\n *\n * See also Documentation/block/ioprio.txt\n *\n */\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/ioprio.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/pid_namespace.h>\n\nint set_task_ioprio(struct task_struct *task, int ioprio)\n{\n\tint err;\n\tstruct io_context *ioc;\n\tconst struct cred *cred = current_cred(), *tcred;\n\n\trcu_read_lock();\n\ttcred = __task_cred(task);\n\tif (!uid_eq(tcred->uid, cred->euid) &&\n\t    !uid_eq(tcred->uid, cred->uid) && !capable(CAP_SYS_NICE)) {\n\t\trcu_read_unlock();\n\t\treturn -EPERM;\n\t}\n\trcu_read_unlock();\n\n\terr = security_task_setioprio(task, ioprio);\n\tif (err)\n\t\treturn err;\n\n\tioc = get_task_io_context(task, GFP_ATOMIC, NUMA_NO_NODE);\n\tif (ioc) {\n\t\tioc->ioprio = ioprio;\n\t\tput_io_context(ioc);\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(set_task_ioprio);\n\nSYSCALL_DEFINE3(ioprio_set, int, which, int, who, int, ioprio)\n{\n\tint class = IOPRIO_PRIO_CLASS(ioprio);\n\tint data = IOPRIO_PRIO_DATA(ioprio);\n\tstruct task_struct *p, *g;\n\tstruct user_struct *user;\n\tstruct pid *pgrp;\n\tkuid_t uid;\n\tint ret;\n\n\tswitch (class) {\n\t\tcase IOPRIO_CLASS_RT:\n\t\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\t\treturn -EPERM;\n\t\t\t/* fall through, rt has prio field too */\n\t\tcase IOPRIO_CLASS_BE:\n\t\t\tif (data >= IOPRIO_BE_NR || data < 0)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tbreak;\n\t\tcase IOPRIO_CLASS_IDLE:\n\t\t\tbreak;\n\t\tcase IOPRIO_CLASS_NONE:\n\t\t\tif (data)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\tret = -ESRCH;\n\trcu_read_lock();\n\tswitch (which) {\n\t\tcase IOPRIO_WHO_PROCESS:\n\t\t\tif (!who)\n\t\t\t\tp = current;\n\t\t\telse\n\t\t\t\tp = find_task_by_vpid(who);\n\t\t\tif (p)\n\t\t\t\tret = set_task_ioprio(p, ioprio);\n\t\t\tbreak;\n\t\tcase IOPRIO_WHO_PGRP:\n\t\t\tif (!who)\n\t\t\t\tpgrp = task_pgrp(current);\n\t\t\telse\n\t\t\t\tpgrp = find_vpid(who);\n\t\t\tdo_each_pid_thread(pgrp, PIDTYPE_PGID, p) {\n\t\t\t\tret = set_task_ioprio(p, ioprio);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t} while_each_pid_thread(pgrp, PIDTYPE_PGID, p);\n\t\t\tbreak;\n\t\tcase IOPRIO_WHO_USER:\n\t\t\tuid = make_kuid(current_user_ns(), who);\n\t\t\tif (!uid_valid(uid))\n\t\t\t\tbreak;\n\t\t\tif (!who)\n\t\t\t\tuser = current_user();\n\t\t\telse\n\t\t\t\tuser = find_user(uid);\n\n\t\t\tif (!user)\n\t\t\t\tbreak;\n\n\t\t\tdo_each_thread(g, p) {\n\t\t\t\tif (!uid_eq(task_uid(p), uid) ||\n\t\t\t\t    !task_pid_vnr(p))\n\t\t\t\t\tcontinue;\n\t\t\t\tret = set_task_ioprio(p, ioprio);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto free_uid;\n\t\t\t} while_each_thread(g, p);\nfree_uid:\n\t\t\tif (who)\n\t\t\t\tfree_uid(user);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic int get_task_ioprio(struct task_struct *p)\n{\n\tint ret;\n\n\tret = security_task_getioprio(p);\n\tif (ret)\n\t\tgoto out;\n\tret = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, IOPRIO_NORM);\n\ttask_lock(p);\n\tif (p->io_context)\n\t\tret = p->io_context->ioprio;\n\ttask_unlock(p);\nout:\n\treturn ret;\n}\n\nint ioprio_best(unsigned short aprio, unsigned short bprio)\n{\n\tunsigned short aclass;\n\tunsigned short bclass;\n\n\tif (!ioprio_valid(aprio))\n\t\taprio = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_BE, IOPRIO_NORM);\n\tif (!ioprio_valid(bprio))\n\t\tbprio = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_BE, IOPRIO_NORM);\n\n\taclass = IOPRIO_PRIO_CLASS(aprio);\n\tbclass = IOPRIO_PRIO_CLASS(bprio);\n\tif (aclass == bclass)\n\t\treturn min(aprio, bprio);\n\tif (aclass > bclass)\n\t\treturn bprio;\n\telse\n\t\treturn aprio;\n}\n\nSYSCALL_DEFINE2(ioprio_get, int, which, int, who)\n{\n\tstruct task_struct *g, *p;\n\tstruct user_struct *user;\n\tstruct pid *pgrp;\n\tkuid_t uid;\n\tint ret = -ESRCH;\n\tint tmpio;\n\n\trcu_read_lock();\n\tswitch (which) {\n\t\tcase IOPRIO_WHO_PROCESS:\n\t\t\tif (!who)\n\t\t\t\tp = current;\n\t\t\telse\n\t\t\t\tp = find_task_by_vpid(who);\n\t\t\tif (p)\n\t\t\t\tret = get_task_ioprio(p);\n\t\t\tbreak;\n\t\tcase IOPRIO_WHO_PGRP:\n\t\t\tif (!who)\n\t\t\t\tpgrp = task_pgrp(current);\n\t\t\telse\n\t\t\t\tpgrp = find_vpid(who);\n\t\t\tdo_each_pid_thread(pgrp, PIDTYPE_PGID, p) {\n\t\t\t\ttmpio = get_task_ioprio(p);\n\t\t\t\tif (tmpio < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ret == -ESRCH)\n\t\t\t\t\tret = tmpio;\n\t\t\t\telse\n\t\t\t\t\tret = ioprio_best(ret, tmpio);\n\t\t\t} while_each_pid_thread(pgrp, PIDTYPE_PGID, p);\n\t\t\tbreak;\n\t\tcase IOPRIO_WHO_USER:\n\t\t\tuid = make_kuid(current_user_ns(), who);\n\t\t\tif (!who)\n\t\t\t\tuser = current_user();\n\t\t\telse\n\t\t\t\tuser = find_user(uid);\n\n\t\t\tif (!user)\n\t\t\t\tbreak;\n\n\t\t\tdo_each_thread(g, p) {\n\t\t\t\tif (!uid_eq(task_uid(p), user->uid) ||\n\t\t\t\t    !task_pid_vnr(p))\n\t\t\t\t\tcontinue;\n\t\t\t\ttmpio = get_task_ioprio(p);\n\t\t\t\tif (tmpio < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ret == -ESRCH)\n\t\t\t\t\tret = tmpio;\n\t\t\t\telse\n\t\t\t\t\tret = ioprio_best(ret, tmpio);\n\t\t\t} while_each_thread(g, p);\n\n\t\t\tif (who)\n\t\t\t\tfree_uid(user);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}\n"], "filenames": ["block/ioprio.c"], "buggy_code_start_loc": [152], "buggy_code_end_loc": [154], "fixing_code_start_loc": [153], "fixing_code_end_loc": [157], "type": "CWE-362", "message": "Race condition in the get_task_ioprio function in block/ioprio.c in the Linux kernel before 4.6.6 allows local users to gain privileges or cause a denial of service (use-after-free) via a crafted ioprio_get system call.", "other": {"cve": {"id": "CVE-2016-7911", "sourceIdentifier": "security@android.com", "published": "2016-11-16T05:59:06.123", "lastModified": "2023-01-19T16:05:34.957", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Race condition in the get_task_ioprio function in block/ioprio.c in the Linux kernel before 4.6.6 allows local users to gain privileges or cause a denial of service (use-after-free) via a crafted ioprio_get system call."}, {"lang": "es", "value": "Condici\u00f3n de carrera en la funci\u00f3n get_task_ioprio en block/ioprio.c en el kernel de Linux en versiones anteriores a 4.6.6 permite a usuarios locales obtener privilegios o provocar una denegaci\u00f3n de servicio (uso posterior a la llamada) mediante una llamada manipulada al sistema ioprio_get."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 9.3}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}, {"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.2.85", "matchCriteriaId": "9A5A178A-A60C-4053-AEE0-5164430206AD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.3", "versionEndExcluding": "3.10.107", "matchCriteriaId": "314F9C88-C8E1-46EF-8119-538C824ED137"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.11", "versionEndExcluding": "3.12.70", "matchCriteriaId": "62D40056-DC08-4609-8FAB-B6D924994367"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.13", "versionEndExcluding": "3.16.37", "matchCriteriaId": "8BD9039D-5837-4376-90C1-051602A3FF94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.17", "versionEndExcluding": "3.18.38", "matchCriteriaId": "44C32BE1-42DD-4F72-90F4-F8A6B7EB37AB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.19", "versionEndExcluding": "4.1.29", "matchCriteriaId": "D565E1E2-F6AE-4BCA-A75B-13F07CDF127B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.2", "versionEndExcluding": "4.4.17", "matchCriteriaId": "C85C5813-E28F-42B8-9B2F-1BDA4EF1196C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.6.6", "matchCriteriaId": "7B51847F-AD59-4497-B936-C821CFB42C2F"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=8ba8682107ee2ca3347354e018865d8e1967c5f4", "source": "security@android.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://source.android.com/security/bulletin/2016-11-01.html", "source": "security@android.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.6.6", "source": "security@android.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/94135", "source": "security@android.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/8ba8682107ee2ca3347354e018865d8e1967c5f4", "source": "security@android.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/8ba8682107ee2ca3347354e018865d8e1967c5f4"}}