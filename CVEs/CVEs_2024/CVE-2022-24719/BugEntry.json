{"buggy_code": ["//. # Fluture Node\n//.\n//. FP-style HTTP and streaming utils for Node based on [Fluture][].\n//.\n//. Skip to the [Http section](#http) for the main code example.\n//.\n//. ## Usage\n//.\n//. ```console\n//. $ npm install --save fluture fluture-node\n//. ```\n//.\n//. On Node 12 and up, this module can be loaded directly with `import` or\n//. `require`. On Node versions below 12, `require` or the [esm][]-loader can\n//. be used.\n//.\n//. ## API\n\nimport http from 'http';\nimport https from 'https';\nimport qs from 'querystring';\nimport {Readable, pipeline} from 'stream';\nimport {isDeepStrictEqual} from 'util';\nimport {lookup} from 'dns';\n\nimport {\n  Future,\n  attempt,\n  chain,\n  encase,\n  map,\n  mapRej,\n  pap,\n  reject,\n  resolve,\n} from 'fluture/index.js';\n\nconst hasProp = k => o => Object.prototype.hasOwnProperty.call (o, k);\n\n//. ### EventEmitter\n\n//# once :: String -> EventEmitter -> Future Error a\n//.\n//. Resolve a Future with the first event emitted over\n//. the given event emitter under the given event name.\n//.\n//. When the Future is cancelled, it removes any trace of\n//. itself from the event emitter.\n//.\n//. ```js\n//. > const emitter = new EventEmitter ();\n//. > setTimeout (() => emitter.emit ('answer', 42), 100);\n//. > once ('answer') (emitter);\n//. Future.of (42);\n//. ```\nexport const once = event => emitter => Future ((rej, res) => {\n  const removeListeners = () => {\n    emitter.removeListener ('error', onError);\n    emitter.removeListener (event, onEvent);\n  };\n  const onError = x => {\n    removeListeners ();\n    rej (x);\n  };\n  const onEvent = x => {\n    removeListeners ();\n    res (x);\n  };\n  emitter.once ('error', onError);\n  emitter.once (event, onEvent);\n  return removeListeners;\n});\n\n//. ### Buffer\n\n//# encode :: Charset -> Buffer -> Future Error String\n//.\n//. Given an encoding and a [Buffer][], returns a Future of the result of\n//. encoding said buffer using the given encoding. The Future will reject\n//. with an Error if the encoding is unknown.\n//.\n//. ```js\n//. > encode ('utf8') (Buffer.from ('Hello world!'));\n//. 'Hello world!'\n//. ```\nexport const encode = encoding => buffer => (\n  mapRej (e => new Error (e.message))\n         (attempt (() => buffer.toString (encoding)))\n);\n\n//. ### Stream\n\n//# streamOf :: Buffer -> Future a (Readable Buffer)\n//.\n//. Given a [Buffer][], returns a Future of a [Readable][] stream which will\n//. emit the given Buffer before ending.\n//.\n//. The stream is wrapped in a Future because creation of a stream causes\n//. side-effects if it's not consumed in time, making it safer to pass it\n//. around wrapped in a Future.\nexport const streamOf = encase (buf => new Readable ({\n  highWaterMark: buf.byteLength,\n  read: function() {\n    if (this._pushed || this.push (buf)) { this.push (null); }\n    this._pushed = true;\n  },\n}));\n\n//# emptyStream :: Future a (Readable Buffer)\n//.\n//. A [Readable][] stream which ends after emiting zero bytes. Can be useful\n//. as an empty [`Request`](#Request) body, for example.\nexport const emptyStream = streamOf (Buffer.alloc (0));\n\n//# buffer :: Readable a -> Future Error (Array a)\n//.\n//. Buffer all data on a [Readable][] stream into a Future of an Array.\n//.\n//. When the Future is cancelled, it removes any trace of\n//. itself from the Stream.\n//.\n//. ```js\n//. > const stream = new Readable ({read: () => {}});\n//. > setTimeout (() => {\n//. .   stream.push ('hello');\n//. .   stream.push ('world');\n//. .   stream.push (null);\n//. . }, 100);\n//. > buffer (stream);\n//. Future.of ([Buffer.from ('hello'), Buffer.from ('world')]);\n//. ```\nexport const buffer = stream => Future ((rej, res) => {\n  const chunks = [];\n  const removeListeners = () => {\n    stream.removeListener ('data', onData);\n    stream.removeListener ('error', rej);\n    stream.removeListener ('end', onEnd);\n  };\n  const onData = d => chunks.push (d);\n  const onEnd = () => {\n    removeListeners ();\n    res (chunks);\n  };\n  const onError = e => {\n    removeListeners ();\n    rej (e);\n  };\n  stream.on ('data', onData);\n  stream.once ('error', onError);\n  stream.once ('end', onEnd);\n  return removeListeners;\n});\n\n//# bufferString :: Charset -> Readable Buffer -> Future Error String\n//.\n//. A version of [`buffer`](#buffer) specialized in Strings.\n//.\n//. Takes a charset and a [Readable][] stream of [Buffer][]s, and returns\n//. a Future containing a String with the fully buffered and encoded result.\nexport const bufferString = charset => stream => (\n  chain (encode (charset)) (map (Buffer.concat) (buffer (stream)))\n);\n\n//. ### Event Loop\n\n//# instant :: b -> Future a b\n//.\n//. Resolves a Future with the given value in the next tick,\n//. using [`process.nextTick`][]. The scheduled job cannot be\n//. cancelled and will run before any other jobs, effectively\n//. blocking the event loop until it's completed.\n//.\n//. ```js\n//. > instant ('noodles')\n//. Future.of ('noodles')\n//. ```\nexport const instant = x => Future ((rej, res) => {\n  process.nextTick (res, x);\n  return () => {};\n});\n\n//# immediate :: b -> Future a b\n//.\n//. Resolves a Future with the given value in the next tick,\n//. using [`setImmediate`][]. This job will run as soon as all\n//. other jobs are completed. When the Future is cancelled, the\n//. job is unscheduled.\n//.\n//. ```js\n//. > immediate ('results')\n//. Future.of ('results')\n//. ```\nexport const immediate = x => Future ((rej, res) => {\n  const job = setImmediate (res, x);\n  return () => { clearImmediate (job); };\n});\n\n//. ### Http\n//.\n//. The functions below are to be used in compositions such as the one shown\n//. below, in order to cover a wide variety of HTTP-related use cases.\n//.\n//. ```js\n//. import {reject, map, chain, encase, fork} from 'fluture';\n//. import {retrieve,\n//.         matchStatus,\n//.         followRedirects,\n//.         autoBufferResponse,\n//.         responseToError} from 'fluture-node';\n//.\n//. const json = res => (\n//.   chain (encase (JSON.parse)) (autoBufferResponse (res))\n//. );\n//.\n//. const notFound = res => (\n//.   chain (({message}) => reject (new Error (message))) (json (res))\n//. );\n//.\n//. retrieve ('https://api.github.com/users/Avaq') ({'User-Agent': 'Avaq'})\n//. .pipe (chain (followRedirects (20)))\n//. .pipe (chain (matchStatus (responseToError) ({200: json, 404: notFound})))\n//. .pipe (map (avaq => avaq.name))\n//. .pipe (fork (console.error) (console.log));\n//. ```\n//.\n//. The example above will either:\n//.\n//. 1. log `\"Aldwin Vlasblom\"` to the terminal if nothing weird happens; or\n//. 2. Report a 404 error using the message returned from the server; or\n//. 3. log an error to the console if:\n//.     * a network error occurs;\n//.     * the response code is not what we expect; or\n//.     * the JSON is malformed.\n//.\n//. Note that we were in control of the following:\n//.\n//. - How redirects are followed: We use [`followRedirects`](#followRedirects)\n//.   with a maxmum of 20 redirects, but we could have used a different\n//.   redirection function using [`followRedirectsWith`](#followRedirectsWith)\n//.   with the [`aggressiveRedirectionPolicy`](#aggressiveRedirectionPolicy) or\n//.   even a fully custom policy.\n//.\n//. - How an unexpected status was treated: We passed in a handler to\n//.   [`matchStatus`](#matchStatus).\n//.   We used [`responseToError`](#responseToError), conviently provided by\n//.   this library, but we could have used a custom mechanism.\n//.\n//. - How responses with expected status codes are treated:\n//.   The [`matchStatus`](#matchStatus) function lets us provide a handler\n//.   based on the status code of the response. Each handler has full control\n//.   over the response.\n//.\n//. - How the response body is buffered and decoded: Our `json` function uses\n//.   [`autoBufferResponse`](#autoBufferResponse) to buffer and decode the\n//.   response according to the mime type provided in the headers. However, we\n//.   could have used lower level functions, such as\n//.   [`bufferResponse`](#bufferResponse) or even just [`buffer`](#buffer).\n//.\n//. - How the response body is parsed: We used [`Fluture.encase`][] with\n//.   [`JSON.parse`][] to parse JSON with a safe failure path. However, we\n//.   could have used a more refined approach to parsing the JSON, for\n//.   example by using [`S.parseJson`][].\n//.\n//. The goal is to give you as much control over HTTP requests and responses\n//. as possible, while still keeping boilerplate low by leveraging function\n//. composition.\n//.\n//. This contrasts with many of the popular HTTP client libraries out there,\n//. which either make decisions for you, taking away control in an attempt to\n//. provide a smoother usage experience, or which take complicated structures\n//. of interacting options to attempt to cater to as many cases as possible.\n\n//    defaultCharset :: String\nconst defaultCharset = 'utf8';\n\n//    defaultContentType :: String\nconst defaultContentType = 'text/plain; charset=' + defaultCharset;\n\n//    charsetRegex :: RegExp\nconst charsetRegex = /\\bcharset=([^;\\s]+)/;\n\n//    mimeTypes :: StrMap Mimetype\nconst mimeTypes = {\n  form: 'application/x-www-form-urlencoded; charset=utf8',\n  json: 'application/json; charset=utf8',\n};\n\n//    getRequestModule :: String -> Future Error Module\nconst getRequestModule = protocol => {\n  switch (protocol) {\n  case 'https:': return resolve (https);\n  case 'http:': return resolve (http);\n  default: return reject (new Error (`Unsupported protocol '${protocol}'`));\n  }\n};\n\n//# Request :: Object -> Url -> Future Error (Readable Buffer) -> Request\n//.\n//. Constructs a value of type Request to be used as an argument for\n//. functions such as [`sendRequest`](#sendRequest).\n//.\n//. Takes the following arguments:\n//.\n//. 1. An Object containing any [http options][] except: `auth`, `host`,\n//.    `hostname`, `path`, `port`, and `protocol`; because they are part of\n//.    the URL, and `signal`; because Fluture handles the cancellation.\n//. 2. A String containing the request URL.\n//. 3. A Future of a [Readable][] stream of [Buffer][]s to be used as the\n//.    request body. Note that the Future must produce a brand new Stream\n//.    every time it is forked, or if it can't, it is expected to reject\n//.    with a value of type Error.\n//.\n//. See [`sendRequest`](#sendRequest) for a usage example.\nexport const Request = options => url => body => ({options, url, body});\n\n//# Request.options :: Request -> Object\n//.\n//. Get the options out of a Request.\nRequest.options = ({options}) => options;\n\n//# Request.url :: Request -> Url\n//.\n//. Get the url out of a Request.\nRequest.url = ({url}) => url;\n\n//# Request.body :: Request -> Future Error (Readable Buffer)\n//.\n//. Get the body out of a Request.\nRequest.body = ({body}) => body;\n\n//# Response :: Request -> IncomingMessage -> Response\n//.\n//. Constructs a value of type Response. These values are typically created\n//. for you by functions such as [`sendRequest`](#sendRequest).\n//. Takes the following arguments:\n//.\n//. 1. A [Request](#Request).\n//. 2. An [IncomingMessage][] assumed to belong to the Request.\nexport const Response = request => message => ({request, message});\n\n//# Response.request :: Response -> Request\n//.\n//. Get the request out of a Response.\nResponse.request = ({request}) => request;\n\n//# Response.message :: Response -> IncomingMessage\n//.\n//. Get the message out of a Response.\nResponse.message = ({message}) => message;\n\n// cleanRequestOptions :: Request -> Object\nexport const cleanRequestOptions = request => {\n  const options = Request.options (request);\n  return {\n    agent: options.agent,\n    createConnection: options.createConnection,\n    defaultPort: options.defaultPort || (\n      options.agent && options.agent.defaultPort\n    ),\n    family: options.family,\n    headers: options.headers || {},\n    insecureHTTPParser: options.insecureHTTPParser === true,\n    localAddress: options.localAddress,\n    lookup: options.lookup || lookup,\n    maxHeaderSize: options.maxHeaderSize || 16384,\n    method: (options.method || 'GET').toUpperCase (),\n    setHost: options.setHost !== false,\n    socketPath: options.socketPath,\n    timeout: options.timeout,\n  };\n};\n\n//# sendRequest :: Request -> Future Error Response\n//.\n//. This is the \"lowest level\" function for making HTTP requests. It does not\n//. handle buffering, encoding, content negotiation, or anything really.\n//. For most use cases, you can use one of the more specialized functions:\n//.\n//. * [`send`](#send): Make a generic HTTP request.\n//. * [`retrieve`](#retrieve): Make a GET request.\n//.\n//. Given a [Request](#Request), returns a Future which makes an HTTP request\n//. and resolves with the resulting [Response](#Response).\n//. If the Future is cancelled, the request is aborted.\n//.\n//. ```js\n//. import {attempt} from 'fluture';\n//. import {createReadStream} from 'fs';\n//.\n//. const BinaryPostRequest = Request ({\n//.   method: 'POST',\n//.   headers: {'Transfer-Encoding': 'chunked'},\n//. });\n//.\n//. const eventualBody = attempt (() => createReadStream ('./data.bin'));\n//.\n//. sendRequest (BinaryPostRequest ('https://example.com') (eventualBody));\n//. ```\n//.\n//. If you want to use this function to transfer a stream of data, don't forget\n//. to set the Transfer-Encoding header to \"chunked\".\nexport const sendRequest = request => {\n  const location = new URL (Request.url (request));\n  const makeRequest = lib => stream => Future ((rej, res) => {\n    const req = lib.request (location, cleanRequestOptions (request));\n    const onResponse = response => res (Response (request) (response));\n    req.once ('response', onResponse);\n    pipeline (stream, req, e => e && rej (e));\n    return () => {\n      req.removeListener ('response', onResponse);\n      req.abort ();\n    };\n  });\n  return (\n    getRequestModule (location.protocol)\n    .pipe (map (makeRequest))\n    .pipe (pap (Request.body (request)))\n    .pipe (chain (x => x))\n  );\n};\n\n//# retrieve :: Url -> StrMap String -> Future Error Response\n//.\n//. A version of [`sendRequest`](#sendRequest) specialized in the `GET` method.\n//.\n//. Given a URL and a StrMap of request headers, returns a Future which\n//. makes a GET requests to the given resource.\n//.\n//. ```js\n//. retrieve ('https://api.github.com/users/Avaq') ({'User-Agent': 'Avaq'})\n//. ```\nexport const retrieve = url => headers => (\n  sendRequest (Request ({headers}) (url) (emptyStream))\n);\n\n//# send :: Mimetype -> Method -> Url -> StrMap String -> Buffer -> Future Error Response\n//.\n//. A version of [`sendRequest`](#sendRequest) for sending arbitrary data to\n//. a server. There's also more specific versions for sending common types of\n//. data:\n//.\n//. * [`sendJson`](#sendJson) sends JSON stringified data.\n//. * [`sendForm`](#sendForm) sends form encoded data.\n//.\n//. Given a MIME type, a request method, a URL, a StrMap of headers, and\n//. finally a Buffer, returns a Future which will send the Buffer to the\n//. server at the given URL using the given request method, telling it the\n//. buffer contains data of the given MIME type.\n//.\n//. This function will always send the Content-Type and Content-Length headers,\n//. alongside the provided headers. Manually provoding either of these headers\n//. override those generated by this function.\nexport const send = mime => method => url => extraHeaders => buf => {\n  const headers = Object.assign ({\n    'Content-Type': mime,\n    'Content-Length': buf.byteLength,\n  }, extraHeaders);\n  return sendRequest (Request ({method, headers}) (url) (streamOf (buf)));\n};\n\n//# sendJson :: Method -> String -> StrMap String -> JsonValue -> Future Error Response\n//.\n//. A version of [`send`](#send) specialized in sending JSON.\n//.\n//. Given a request method, a URL, a StrMap of headers and a JavaScript plain\n//. object, returns a Future which sends the object to the server at the\n//. given URL after JSON-encoding it.\n//.\n//. ```js\n//. sendJson ('PUT')\n//.          ('https://example.com/users/bob')\n//.          ({Authorization: 'Bearer asd123'})\n//.          ({name: 'Bob', email: 'bob@example.com'});\n//. ```\nexport const sendJson = method => url => headers => json => {\n  const buf = Buffer.from (JSON.stringify (json));\n  return send (mimeTypes.json) (method) (url) (headers) (buf);\n};\n\n//# sendForm :: Method -> String -> StrMap String -> JsonValue -> Future Error Response\n//.\n//. A version of [`send`](#send) specialized in sending form data.\n//.\n//. Given a request method, a URL, a StrMap of headers and a JavaScript plain\n//. object, returns a Future which sends the object to the server at the\n//. given URL after www-form-urlencoding it.\n//.\n//. ```js\n//. sendForm ('POST')\n//.          ('https://example.com/users/create')\n//.          ({})\n//.          ({name: 'Bob', email: 'bob@example.com'});\n//. ```\nexport const sendForm = method => url => headers => form => {\n  const buf = Buffer.from (qs.stringify (form));\n  return send (mimeTypes.form) (method) (url) (headers) (buf);\n};\n\n//# matchStatus :: (Response -> a) -> StrMap (Response -> a) -> Response -> a\n//.\n//. Transform a [`Response`](#Response) based on its status code.\n//.\n//. ```js\n//. import {chain} from 'fluture';\n//.\n//. const processResponse = matchStatus (responseToError) ({\n//.   200: autoBufferResponse,\n//. });\n//.\n//. chain (processResponse) (retreive ('https://example.com'));\n//. ```\n//.\n//. This is kind of like a `switch` statement on the status code of the\n//. Response message. Or, if you will, a pattern match against the\n//. Response type if you imagine it being tagged via the status code.\n//.\n//. The first argument is the \"default\" case, and the second argument is a\n//. map of status codes to functions that should have the same type as the\n//. first argument.\n//.\n//. The resulting function `Response -> a` has the same signature as the input\n//. functions, meaning you can use `matchStatus` *again* to \"extend\" the\n//. pattern by passing the old pattern as the \"default\" case for the new one:\n//.\n//. ```js\n//. import {reject} from 'fluture';\n//.\n//. matchStatus (processResponse) ({\n//.   404: () => reject (new Error ('Example not found!')),\n//. });\n//. ```\nexport const matchStatus = f => fs => res => {\n  const {statusCode} = Response.message (res);\n  return (hasProp (statusCode) (fs) ? fs[statusCode] : f) (res);\n};\n\n// mergeUrls :: (Url, Any) -> String\nconst mergeUrls = (base, input) => (\n  typeof input === 'string' ?\n  new URL (input, base).href :\n  base\n);\n\n// sameHost :: (Url, Url) -> Boolean\nconst sameHost = (parent, child) => {\n  const p = new URL (parent);\n  const c = new URL (child);\n  return p.host === c.host || c.host.endsWith ('.' + p.host);\n};\n\n// overHeaders :: (Request, Array2 String String -> Array2 String String)\n//             -> Request\nconst overHeaders = (request, f) => {\n  const options = cleanRequestOptions (request);\n  const headers = Object.fromEntries (f (Object.entries (options.headers)));\n  return Request (Object.assign ({}, Request.options (request), {headers}))\n                 (Request.url (request))\n                 (Request.body (request));\n};\n\n// confidentialHeaders :: Array String\nconst confidentialHeaders = [\n  'authorization',\n  'cookie',\n];\n\n//# redirectAnyRequest :: Response -> Request\n//.\n//. A redirection strategy that simply reissues the original Request to the\n//. Location specified in the given Response.\n//.\n//. If the new location is on an external host, then any confidential headers\n//. (such as the cookie header) will be dropped from the new request.\n//.\n//. Used in the [`defaultRedirectionPolicy`](#defaultRedirectionPolicy) and\n//. the [`aggressiveRedirectionPolicy`](#aggressiveRedirectionPolicy).\nexport const redirectAnyRequest = response => {\n  const {headers: {location}} = Response.message (response);\n  const original = Response.request (response);\n  const oldUrl = Request.url (original);\n  const newUrl = mergeUrls (oldUrl, location);\n  const request = Request (Request.options (original))\n                          (newUrl)\n                          (Request.body (original));\n\n  return sameHost (oldUrl, newUrl) ? request : overHeaders (request, xs => (\n    xs.filter (([name]) => !confidentialHeaders.includes (name.toLowerCase ()))\n  ));\n};\n\n//# redirectIfGetMethod :: Response -> Request\n//.\n//. A redirection strategy that simply reissues the original Request to the\n//. Location specified in the given Response, but only if the original request\n//. was using the GET method.\n//.\n//. If the new location is on an external host, then any confidential headers\n//. (such as the cookie header) will be dropped from the new request.\n//.\n//. Used in [`followRedirectsStrict`](#followRedirectsStrict).\nexport const redirectIfGetMethod = response => {\n  const {method} = cleanRequestOptions (Response.request (response));\n  return (\n    method === 'GET' ?\n    redirectAnyRequest (response) :\n    Response.request (response)\n  );\n};\n\n//# redirectUsingGetMethod :: Response -> Request\n//.\n//. A redirection strategy that sends a new GET request based on the original\n//. request to the Location specified in the given Response. If the response\n//. does not contain a valid location, the request is not redirected.\n//.\n//. The original request method and body are discarded, but other options\n//. are preserved. If the new location is on an external host, then any\n//. confidential headers (such as the cookie header) will be dropped from the\n//. new request.\n//.\n//. Used in the [`defaultRedirectionPolicy`](#defaultRedirectionPolicy) and\n//. the [`aggressiveRedirectionPolicy`](#aggressiveRedirectionPolicy).\nexport const redirectUsingGetMethod = response => {\n  const original = Response.request (response);\n  const options = Object.assign ({}, Request.options (original), {\n    method: 'GET',\n  });\n  const request = Request (options) (Request.url (original)) (emptyStream);\n  return redirectAnyRequest (Response (request) (Response.message (response)));\n};\n\n// See https://developer.mozilla.org/docs/Web/HTTP/Headers#Conditionals\nconst conditionHeaders = [\n  'if-match',\n  'if-modified-since',\n  'if-none-match',\n  'if-unmodified-since',\n];\n\n//# retryWithoutCondition :: Response -> Request\n//.\n//. A redirection strategy that removes any caching headers if present and\n//. retries the request, or does nothing if no caching headers were present\n//. on the original request.\n//.\n//. Used in the [`defaultRedirectionPolicy`](#defaultRedirectionPolicy).\nexport const retryWithoutCondition = response => {\n  const original = Response.request (response);\n  const {method} = cleanRequestOptions (original);\n  const request = overHeaders (original, xs => xs.filter (([name]) => (\n    !(conditionHeaders.includes (name.toLowerCase ()))\n  )));\n  return method === 'GET' ? request : original;\n};\n\n//# defaultRedirectionPolicy :: Response -> Request\n//.\n//. Carefully follows redirects in strict accordance with\n//. [RFC2616 Section 10.3][].\n//.\n//. Redirections with status codes 301, 302, and 307 are only followed if the\n//. original request used the GET method, and redirects with status code 304\n//. are left alone for a caching layer to deal with.\n//.\n//. This redirection policy is used by default in the\n//. [`followRedirects`](#followRedirects) function. You can extend it, using\n//. [`matchStatus`](#matchStatus) to create a custom redirection policy, as\n//. shown in the example:\n//.\n//. See also [`aggressiveRedirectionPolicy`](#aggressiveRedirectionPolicy).\n//.\n//. ```js\n//. const redirectToBestOption = () => {\n//.   // Somehow figure out which URL to redirect to.\n//. };\n//.\n//. const myRedirectionPolicy = matchStatus (defaultRedirectionPolicy) ({\n//.   300: redirectToBestOption,\n//.   301: redirectUsingGetMethod,\n//. });\n//.\n//. retrieve ('https://example.com') ({})\n//. .pipe (chain (followRedirectsWith (myRedirectionPolicy) (10)))\n//. ```\nexport const defaultRedirectionPolicy = matchStatus (Response.request) ({\n  301: redirectIfGetMethod,\n  302: redirectIfGetMethod,\n  303: redirectUsingGetMethod,\n  305: redirectAnyRequest,\n  307: redirectIfGetMethod,\n});\n\n//# aggressiveRedirectionPolicy :: Response -> Request\n//.\n//. Aggressively follows redirects in mild violation of\n//. [RFC2616 Section 10.3][]. In particular, anywhere that a redirection\n//. should be interrupted for user confirmation or caching, this policy\n//. follows the redirection nonetheless.\n//.\n//. Redirections with status codes 301, 302, and 307 are always followed\n//. without user intervention, and redirects with status code 304 are\n//. retried without conditions if the original request had any conditional\n//. headers.\n//.\n//. See also [`defaultRedirectionPolicy`](defaultRedirectionPolicy).\n//.\n//. ```js\n//. retrieve ('https://example.com') ({})\n//. .pipe (chain (followRedirectsWith (aggressiveRedirectionPolicy) (10)))\n//. ```\nexport const aggressiveRedirectionPolicy = matchStatus (Response.request) ({\n  301: redirectAnyRequest,\n  302: redirectAnyRequest,\n  303: redirectUsingGetMethod,\n  304: retryWithoutCondition,\n  305: redirectAnyRequest,\n  307: redirectAnyRequest,\n});\n\n// requestsEquivalent :: Request -> Request -> Boolean\nconst requestsEquivalent = left => right => (\n  isDeepStrictEqual (\n    cleanRequestOptions (left),\n    cleanRequestOptions (right)\n  ) &&\n  Request.url (left) === Request.url (right) &&\n  Request.body (left) === Request.body (right)\n);\n\n//# followRedirectsWith :: (Response -> Request) -> Number -> Response -> Future Error Response\n//.\n//. Given a function that take a Response and produces a new Request, and a\n//. \"maximum\" number, recursively keeps resolving new requests until a request\n//. is encountered that was seen before, or the maximum number is reached.\n//.\n//. See [`followRedirects`](#followRedirects) for an out-of-the-box redirect-\n//. follower. See [`aggressiveRedirectionPolicy`](#aggressiveRedirectionPolicy)\n//. and [`defaultRedirectionPolicy`](defaultRedirectionPolicy) for\n//. additional usage examples.\nexport const followRedirectsWith = strategy => _max => _response => {\n  const seen = [];\n  const followUp = max => response => {\n    if (max < 1) {\n      return resolve (response);\n    }\n    seen.push (Response.request (response));\n    const nextRequest = strategy (response);\n    for (let i = seen.length - 1; i >= 0; i -= 1) {\n      if (requestsEquivalent (seen[i]) (nextRequest)) {\n        return resolve (response);\n      }\n    }\n    return (\n      sendRequest (nextRequest)\n      .pipe (mapRej (e => new Error ('After redirect: ' + e.message)))\n      .pipe (chain (followUp (max - 1)))\n    );\n  };\n  return followUp (_max) (_response);\n};\n\n//# followRedirects :: Number -> Response -> Future Error Response\n//.\n//. Given the maximum numbers of redirections, follows redirects according to\n//. the [default redirection policy](#defaultRedirectionPolicy).\n//.\n//. See the [Http section](#http) for a usage example.\nexport const followRedirects = followRedirectsWith (defaultRedirectionPolicy);\n\n//# acceptStatus :: Number -> Response -> Future Response Response\n//.\n//. This function \"tags\" a [Response](#Response) based on a given status code.\n//. If the response status matches the given status code, the returned Future\n//. will resolve. If it doesn't, the returned Future will reject.\n//.\n//. See also [`matchStatus`](#matchStatus), which will probably be more useful\n//. in most cases.\n//.\n//. The idea is that you can compose this function with one that returns a\n//. Response, and reject any responses that don't meet the expected status\n//. code.\n//.\n//. In combination with [`responseToError`](#responseToError), you can then\n//. flatten it back into the outer Future. The usage example under the\n//. [Http](#http) section shows this.\nexport const acceptStatus = code => matchStatus (reject) ({[code]: resolve});\n\n//# bufferMessage :: Charset -> IncomingMessage -> Future Error String\n//.\n//. A version of [`buffer`](#buffer) specialized in [IncomingMessage][]s.\n//.\n//. See also [`bufferResponse`](#bufferResponse) and\n//. [`autoBufferMessage`](#autoBufferMessage).\n//.\n//. Given a charset and an IncomingMessage, returns a Future with the buffered,\n//. encoded, message body.\nexport const bufferMessage = charset => message => (\n  mapRej (e => new Error ('Failed to buffer response: ' + e.message))\n         (bufferString (charset) (message))\n);\n\n//# bufferResponse :: Charset -> Response -> Future Error String\n//.\n//. A composition of [`Response.message`](#Response.message) and\n//. [`bufferMessage`](#bufferMessage) for your convenience.\n//.\n//. See also [autoBufferResponse](#autoBufferResponse).\nexport const bufferResponse = charset => response => (\n  bufferMessage (charset) (Response.message (response))\n);\n\n//# autoBufferMessage :: IncomingMessage -> Future Error String\n//.\n//. Given an IncomingMessage, buffers and decodes the message body using the\n//. charset provided in the message headers. Falls back to UTF-8 if the\n//. charset was not provided.\n//.\n//. Returns a Future with the buffered, encoded, message body.\n//.\n//. See also [bufferMessage](#bufferMessage).\nexport const autoBufferMessage = message => {\n  const contentType = message.headers['content-type'] || defaultContentType;\n  const parsed = charsetRegex.exec (contentType);\n  const charset = parsed == null ? defaultCharset : parsed[1];\n  return bufferMessage (charset) (message);\n};\n\n//# autoBufferResponse :: Response -> Future Error String\n//.\n//. A composition of [`Response.message`](#Response.message) and\n//. [`autoBufferMessage`](#autoBufferMessage) for your convenience.\n//.\n//. See also [bufferResponse](#bufferResponse).\nexport const autoBufferResponse = response => (\n  autoBufferMessage (Response.message (response))\n);\n\n//# responseToError :: Response -> Future Error a\n//.\n//. Given a [Response](#Response), returns a *rejected* Future of an instance\n//. of Error with a message based on the content of the response.\nexport const responseToError = response => {\n  const message = Response.message (response);\n  return autoBufferMessage (message)\n  .pipe (chain (body => reject (new Error (\n    `Unexpected ${message.statusMessage} (${message.statusCode}) response. ` +\n    `Response body:\\n\\n${body.split ('\\n').map (x => `  ${x}`).join ('\\n')}`\n  ))));\n};\n\n//. [`process.nextTick`]: https://nodejs.org/api/process.html#process_process_nexttick_callback_args\n//. [`setImmediate`]: https://nodejs.org/api/timers.html#timers_setimmediate_callback_args\n//. [`S.parseJson`]: https://sanctuary.js.org/#parseJson\n//. [`Fluture.encase`]: https://github.com/fluture-js/Fluture#encase\n//. [`JSON.parse`]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse\n\n//. [Buffer]: https://nodejs.org/api/buffer.html#buffer_class_buffer\n//. [Fluture]: https://github.com/fluture-js/Fluture\n//. [http options]: https://nodejs.org/api/http.html#http_http_request_url_options_callback\n//. [IncomingMessage]: https://nodejs.org/api/http.html#http_class_http_incomingmessage\n//. [Readable]: https://nodejs.org/api/stream.html#stream_class_stream_readable\n\n//. [RFC2616 Section 10.3]: https://tools.ietf.org/html/rfc2616#section-10.3\n//. [esm]: https://github.com/standard-things/esm\n", "import {EventEmitter} from 'events';\nimport * as fl from 'fluture';\nimport test from 'oletus';\nimport {Readable} from 'stream';\nimport {equivalence, equality as eq} from 'fluture/test/assertions.js';\nimport {withTestServer} from './server.js';\nimport {lookup} from 'dns';\n\nimport * as fn from '../index.js';\n\nconst assertResolves = a => b => equivalence (a) (fl.resolve (b));\nconst assertRejects = a => b => equivalence (a) (fl.reject (b));\n\nconst noop = () => {};\n\ntest ('once', () => {\n  const ee1 = new EventEmitter ();\n\n  const cancel = fl.value (noop) (fn.once ('test') (ee1));\n  eq (ee1.listenerCount ('test')) (1);\n  eq (ee1.listenerCount ('error')) (1);\n\n  cancel ();\n  eq (ee1.listenerCount ('test')) (0);\n  eq (ee1.listenerCount ('error')) (0);\n\n  const ee2 = new EventEmitter ();\n  const ee3 = new EventEmitter ();\n\n  setTimeout (() => {\n    ee2.emit ('test', 42);\n    ee3.emit ('error', 42);\n  }, 10);\n\n  return Promise.all ([\n    assertResolves (fn.once ('test') (ee2)) (42),\n    assertRejects (fn.once ('test') (ee3)) (42),\n  ]);\n});\n\ntest ('encode', () => Promise.all ([\n  assertRejects (fn.encode ('lalalala') (Buffer.from ('hello')))\n                (new Error ('Unknown encoding: lalalala')),\n  assertResolves (fn.encode ('utf8') (Buffer.from ('hello'))) ('hello'),\n  assertResolves (fn.encode ('hex') (Buffer.from ('hello'))) ('68656c6c6f'),\n]));\n\ntest ('streamOf', () => {\n  const eventualStream = fn.streamOf (Buffer.from ('hello'));\n  return new Promise ((res, rej) => {\n    fl.fork (e => rej (new Error ('The future rejected: ' + String (e))))\n            (stream => {\n              stream.on ('end', res);\n              stream.on ('data', data => {\n                try {\n                  eq (data) (Buffer.from ('hello'));\n                } catch (e) {\n                  rej (e);\n                }\n              });\n            })\n            (eventualStream);\n    setTimeout (rej, 20, new Error ('No data on the stream'));\n  });\n});\n\ntest ('emptyStream', () => new Promise ((res, rej) => {\n  fl.fork (e => rej (new Error ('The Future rejected: ' + String (e))))\n          (stream => {\n            stream.on ('data', data => {\n              rej (new Error ('The stream emitted data: ' + String (data)));\n            });\n            stream.on ('end', res);\n          })\n          (fn.emptyStream);\n}));\n\ntest ('buffer', () => {\n  const s1 = new Readable ({read: noop});\n  const s2 = new Readable ({read: noop});\n\n  const b1 = Buffer.from ('hello');\n  const b2 = Buffer.from ('world');\n\n  s1.push (b1);\n\n  setTimeout (() => {\n    s1.push (b2);\n    s1.push (null);\n    s2.emit ('error', 42);\n  }, 10);\n\n  return Promise.all ([\n    assertResolves (fn.buffer (s1)) ([b1, b2]),\n    assertRejects (fn.buffer (s2)) (42),\n  ]);\n});\n\ntest ('bufferString', () => Promise.all ([\n  assertResolves (fl.chain (fn.bufferString ('utf8')) (fn.streamOf (Buffer.from ('hello'))))\n                 ('hello'),\n  assertResolves (fl.chain (fn.bufferString ('hex')) (fn.streamOf (Buffer.from ('hello'))))\n                 ('68656c6c6f'),\n]));\n\ntest ('instant', () => (\n  assertResolves (fn.instant ('noodles')) ('noodles')\n));\n\ntest ('immediate', () => {\n  fl.value (eq ('should not run')) (fn.immediate ('did run')) ();\n  return assertResolves (fn.immediate ('results')) ('results');\n});\n\nconst getRequest = fn.Request ({}) ('https://example.com') (fn.emptyStream);\n\nconst postRequest = fn.Request ({method: 'POST'}) ('https://example.com') (fn.streamOf (Buffer.from ('test')));\n\nconst responseHeaders = {\n  'connection': 'close',\n  'content-type': 'text/plain',\n  'date': 'now',\n  'transfer-encoding': 'chunked',\n};\n\nconst mockResponse = ({code = 200, message = 'OK', headers = responseHeaders, request = getRequest, body = Buffer.from ('hello')}) => fl.map (stream => {\n  stream.headers = headers;\n  stream.statusCode = code;\n  stream.statusMessage = message;\n  return fn.Response (request) (stream);\n}) (fn.streamOf (body));\n\nconst getResponse = code => location => mockResponse ({\n  code: code,\n  headers: Object.assign ({}, responseHeaders, {location}),\n  request: getRequest,\n});\n\nconst postResponse = code => location => mockResponse ({\n  code: code,\n  headers: Object.assign ({}, responseHeaders, {location}),\n  request: postRequest,\n});\n\nconst sendMockRequest = eventualBody => withTestServer (({url}) => (\n  fn.sendRequest (fn.Request ({headers: {\n    'Connection': 'close',\n    'Transfer-Encoding': 'chunked',\n  }}) (`${url}/echo`) (eventualBody))\n));\n\ntest ('Request', () => {\n  const options = {};\n  const url = 'https://example.com';\n  const body = fn.emptyStream;\n  const request = fn.Request (options) (`${url}/echo`) (body);\n  eq (fn.Request.options (request)) (options);\n  eq (fn.Request.url (request)) (`${url}/echo`);\n  eq (fn.Request.body (request)) (body);\n});\n\ntest ('Response', () => {\n  const message = fn.emptyStream;\n  const response = fn.Response (getRequest) (message);\n  eq (fn.Response.request (response)) (getRequest);\n  eq (fn.Response.message (response)) (message);\n});\n\ntest ('cleanRequestOptions', () => {\n  const req = o => fn.Request (o) ('https://example.com') (fn.emptyStream);\n  eq (fn.cleanRequestOptions (req ({}))) ({\n    agent: undefined,\n    createConnection: undefined,\n    defaultPort: undefined,\n    family: undefined,\n    headers: {},\n    insecureHTTPParser: false,\n    localAddress: undefined,\n    lookup: lookup,\n    maxHeaderSize: 16384,\n    method: 'GET',\n    setHost: true,\n    socketPath: undefined,\n    timeout: undefined,\n  });\n  eq (fn.cleanRequestOptions (req ({agent: {defaultPort: 42}}))) ({\n    agent: {defaultPort: 42},\n    createConnection: undefined,\n    defaultPort: 42,\n    family: undefined,\n    headers: {},\n    insecureHTTPParser: false,\n    localAddress: undefined,\n    lookup: lookup,\n    maxHeaderSize: 16384,\n    method: 'GET',\n    setHost: true,\n    socketPath: undefined,\n    timeout: undefined,\n  });\n});\n\ntest ('bufferResponse', () => Promise.all ([\n  assertResolves (fl.chain (fn.bufferResponse ('utf8')) (sendMockRequest (fn.emptyStream)))\n                 ('GET/'),\n  assertResolves (fl.chain (fn.bufferResponse ('utf8')) (sendMockRequest (fn.streamOf (Buffer.from ('hello')))))\n                 ('GET/hello'),\n]));\n\nconst thenBuffer = fl.bichain (res => fl.swap (fn.bufferResponse ('utf8') (res)))\n                              (fn.bufferResponse ('utf8'));\n\ntest ('sendRequest', () => Promise.all ([\n  assertRejects (fn.sendRequest (fn.Request ({}) ('https://localhost') (fn.emptyStream)))\n                (Object.assign (new Error ('connect ECONNREFUSED 127.0.0.1:443'), {\n                  address: '127.0.0.1',\n                  code: 'ECONNREFUSED',\n                  errno: -111,\n                  port: 443,\n                  syscall: 'connect',\n                })),\n  assertRejects (fn.sendRequest (fn.Request ({}) ('ftp://localhost') (fn.emptyStream)))\n                (new Error (\"Unsupported protocol 'ftp:'\")),\n  assertResolves (thenBuffer (sendMockRequest (fn.emptyStream)))\n                 ('GET/'),\n  assertResolves (thenBuffer (sendMockRequest (fn.streamOf (Buffer.from ('hello')))))\n                 ('GET/hello'),\n]));\n\ntest ('request cancellation', () => new Promise ((res, rej) => {\n  const cancel = fl.fork (rej)\n                         (rej)\n                         (fn.sendRequest (fn.Request ({}) ('https://localhost') (fn.emptyStream)));\n  cancel ();\n  setTimeout (res, 1000);\n}));\n\ntest ('retrieve', () => Promise.all ([\n  assertResolves (withTestServer (({url}) => thenBuffer (fn.retrieve (`${url}/echo`) ({}))))\n                 ('GET/'),\n]));\n\ntest ('send', () => Promise.all ([\n  assertResolves (withTestServer (({url}) => thenBuffer (fn.send ('text/plain') ('POST') (`${url}/echo`) ({}) (Buffer.from ('hello')))))\n                 ('POST/hello'),\n]));\n\ntest ('sendJson', () => Promise.all ([\n  assertResolves (withTestServer (({url}) => thenBuffer (fn.sendJson ('POST') (`${url}/echo`) ({}) ({message: 'hello'}))))\n                 ('POST/{\"message\":\"hello\"}'),\n]));\n\ntest ('sendForm', () => Promise.all ([\n  assertResolves (withTestServer (({url}) => thenBuffer (fn.sendForm ('POST') (`${url}/echo`) ({}) ({message: 'hello'}))))\n                 ('POST/message=hello'),\n]));\n\ntest ('redirectAnyRequest', () => Promise.all ([\n  assertResolves (fl.map (fn.redirectAnyRequest) (mockResponse ({})))\n                 (getRequest),\n  assertResolves (fl.map (fn.redirectAnyRequest) (getResponse (301) ('ftp://xxx')))\n                 (fn.Request ({headers: {}}) ('ftp://xxx/') (fn.emptyStream)),\n  assertResolves (fl.map (fn.redirectAnyRequest) (getResponse (301) ('/echo')))\n                 (fn.Request ({}) ('https://example.com/echo') (fn.emptyStream)),\n  assertResolves (fl.map (fn.redirectAnyRequest) (postResponse (301) ('/echo')))\n                 (fn.Request ({method: 'POST'}) ('https://example.com/echo') (fn.streamOf (Buffer.from ('test')))),\n  assertResolves (fl.map (fn.redirectAnyRequest)\n                         (mockResponse ({code: 301,\n                                         headers: {location: 'https://example.com/path'},\n                                         request: fn.Request ({headers: {cookie: 'yum'}}) ('https://example.com') (fn.emptyStream)})))\n                 (fn.Request ({headers: {cookie: 'yum'}}) ('https://example.com/path') (fn.emptyStream)),\n  assertResolves (fl.map (fn.redirectAnyRequest)\n                         (mockResponse ({code: 301,\n                                         headers: {location: 'https://sub.example.com/'},\n                                         request: fn.Request ({headers: {cookie: 'yum'}}) ('https://example.com') (fn.emptyStream)})))\n                 (fn.Request ({headers: {cookie: 'yum'}}) ('https://sub.example.com/') (fn.emptyStream)),\n  assertResolves (fl.map (fn.redirectAnyRequest)\n                         (mockResponse ({code: 301,\n                                         headers: {location: 'https://bigsub.example.com/'},\n                                         request: fn.Request ({headers: {cookie: 'yum'}}) ('https://example.com') (fn.emptyStream)})))\n                 (fn.Request ({headers: {cookie: 'yum'}}) ('https://bigsub.example.com/') (fn.emptyStream)),\n  assertResolves (fl.map (fn.redirectAnyRequest)\n                         (mockResponse ({code: 301,\n                                         headers: {location: 'https://elsewhere.com/'},\n                                         request: fn.Request ({headers: {cookie: 'yum'}}) ('https://example.com') (fn.emptyStream)})))\n                 (fn.Request ({headers: {}}) ('https://elsewhere.com/') (fn.emptyStream)),\n]));\n\ntest ('redirectIfGetMethod', () => Promise.all ([\n  assertResolves (fl.map (fn.redirectIfGetMethod) (mockResponse ({})))\n                 (getRequest),\n  assertResolves (fl.map (fn.redirectIfGetMethod) (getResponse (301) ('ftp://xxx')))\n                 (fn.Request ({headers: {}}) ('ftp://xxx/') (fn.emptyStream)),\n  assertResolves (fl.map (fn.redirectIfGetMethod) (getResponse (301) ('/echo')))\n                 (fn.Request ({}) ('https://example.com/echo') (fn.emptyStream)),\n  assertResolves (fl.map (fn.redirectIfGetMethod) (postResponse (301) ('/echo')))\n                 (postRequest),\n]));\n\ntest ('redirectUsingGetMethod', () => Promise.all ([\n  assertResolves (fl.map (fn.redirectUsingGetMethod) (mockResponse ({})))\n                 (fn.Request ({method: 'GET'}) ('https://example.com') (fn.emptyStream)),\n  assertResolves (fl.map (fn.redirectUsingGetMethod) (getResponse (301) ('ftp://xxx')))\n                 (fn.Request ({method: 'GET', headers: {}}) ('ftp://xxx/') (fn.emptyStream)),\n  assertResolves (fl.map (fn.redirectUsingGetMethod) (getResponse (200) ('/echo')))\n                 (fn.Request ({method: 'GET'}) ('https://example.com/echo') (fn.emptyStream)),\n  assertResolves (fl.map (fn.redirectUsingGetMethod) (postResponse (200) ('/echo')))\n                 (fn.Request ({method: 'GET'}) ('https://example.com/echo') (fn.emptyStream)),\n]));\n\ntest ('retryWithoutCondition', () => Promise.all ([\n  assertResolves (fl.map (fn.retryWithoutCondition) (mockResponse ({})))\n                 (fn.Request ({headers: {}}) ('https://example.com') (fn.emptyStream)),\n  assertResolves (fl.map (fn.retryWithoutCondition) (getResponse (301) ('ftp://xxx')))\n                 (fn.Request ({headers: {}}) ('https://example.com') (fn.emptyStream)),\n  assertResolves (fl.map (fn.retryWithoutCondition) (getResponse (200) ('/echo')))\n                 (fn.Request ({headers: {}}) ('https://example.com') (fn.emptyStream)),\n  assertResolves (fl.map (fn.retryWithoutCondition) (postResponse (200) ('/echo')))\n                 (fn.Request ({method: 'POST'}) ('https://example.com') (fn.streamOf (Buffer.from ('test')))),\n  assertResolves (fl.map (fn.retryWithoutCondition) (mockResponse ({request: fn.Request ({headers: {'If-None-Match': 'abc123'}}) ('https://example.com') (fn.emptyStream), body: Buffer.from ('test')})))\n                 (fn.Request ({headers: {}}) ('https://example.com') (fn.emptyStream)),\n  assertResolves (fl.map (fn.retryWithoutCondition) (mockResponse ({request: fn.Request ({method: 'POST', headers: {'If-None-Match': 'abc123'}}) ('https://example.com') (fn.streamOf (Buffer.from ('hello'))), body: Buffer.from ('test')})))\n                 (fn.Request ({method: 'POST', headers: {'If-None-Match': 'abc123'}}) ('https://example.com') (fn.streamOf (Buffer.from ('hello')))),\n]));\n\ntest ('followRedirectsWith', () => Promise.all ([\n  assertResolves (thenBuffer (withTestServer (({url}) => fl.chain (fn.followRedirectsWith (_ => fn.Request ({}) (`${url}/echo`) (fn.emptyStream)) (1)) (mockResponse ({})))))\n                 ('GET/'),\n  assertResolves (thenBuffer (withTestServer (({url}) => fl.chain (fn.followRedirectsWith (_ => fn.Request ({}) (`${url}/echo`) (fn.emptyStream)) (0)) (mockResponse ({})))))\n                 ('hello'),\n]));\n\ntest ('followRedirects', () => Promise.all ([\n  assertResolves (fl.chain (fn.bufferResponse ('utf8')) (fl.chain (fn.followRedirects (1)) (mockResponse ({}))))\n                 ('hello'),\n  assertResolves (withTestServer (({url}) => fl.chain (fn.bufferResponse ('utf8')) (fl.chain (fn.followRedirects (1)) (getResponse (301) (`${url}/echo`)))))\n                 ('GET/'),\n  assertResolves (withTestServer (({url}) => fl.chain (fn.bufferResponse ('utf8')) (fl.chain (fn.followRedirects (1)) (getResponse (302) (`${url}/echo`)))))\n                 ('GET/'),\n  assertResolves (withTestServer (({url}) => fl.chain (fn.bufferResponse ('utf8')) (fl.chain (fn.followRedirects (1)) (getResponse (303) (`${url}/echo`)))))\n                 ('GET/'),\n  assertResolves (withTestServer (({url}) => fl.chain (fn.bufferResponse ('utf8')) (fl.chain (fn.followRedirects (1)) (getResponse (304) (`${url}/echo`)))))\n                 ('hello'),\n  assertResolves (withTestServer (({url}) => fl.chain (fn.bufferResponse ('utf8')) (fl.chain (fn.followRedirects (1)) (getResponse (305) (`${url}/echo`)))))\n                 ('GET/'),\n  assertResolves (withTestServer (({url}) => fl.chain (fn.bufferResponse ('utf8')) (fl.chain (fn.followRedirects (1)) (getResponse (307) (`${url}/echo`)))))\n                 ('GET/'),\n  assertResolves (withTestServer (({url}) => fl.chain (fn.bufferResponse ('utf8')) (fl.chain (fn.followRedirects (1)) (postResponse (301) (`${url}/echo`)))))\n                 ('hello'),\n  assertResolves (withTestServer (({url}) => fl.chain (fn.bufferResponse ('utf8')) (fl.chain (fn.followRedirects (1)) (postResponse (302) (`${url}/echo`)))))\n                 ('hello'),\n  assertResolves (withTestServer (({url}) => fl.chain (fn.bufferResponse ('utf8')) (fl.chain (fn.followRedirects (1)) (postResponse (303) (`${url}/echo`)))))\n                 ('GET/'),\n  assertResolves (withTestServer (({url}) => fl.chain (fn.bufferResponse ('utf8')) (fl.chain (fn.followRedirects (1)) (postResponse (304) (`${url}/echo`)))))\n                 ('hello'),\n  assertResolves (withTestServer (({url}) => fl.chain (fn.bufferResponse ('utf8')) (fl.chain (fn.followRedirects (1)) (postResponse (305) (`${url}/echo`)))))\n                 ('POST/test'),\n  assertResolves (withTestServer (({url}) => fl.chain (fn.bufferResponse ('utf8')) (fl.chain (fn.followRedirects (1)) (postResponse (307) (`${url}/echo`)))))\n                 ('hello'),\n]));\n\ntest ('autoBufferResponse', () => Promise.all ([\n  assertRejects (fl.chain (fn.autoBufferResponse) (mockResponse ({headers: {'content-type': 'text/plain; charset=lalalala'}})))\n                (new Error ('Failed to buffer response: Unknown encoding: lalalala')),\n  assertResolves (fl.chain (fn.autoBufferResponse) (sendMockRequest (fn.emptyStream)))\n                 ('GET/'),\n  assertResolves (fl.chain (fn.autoBufferResponse) (sendMockRequest (fn.streamOf (Buffer.from ('hello')))))\n                 ('GET/hello'),\n  assertResolves (fl.chain (fn.autoBufferResponse) (mockResponse ({})))\n                 ('hello'),\n  assertResolves (fl.chain (fn.autoBufferResponse) (mockResponse ({headers: {}})))\n                 ('hello'),\n  assertResolves (fl.chain (fn.autoBufferResponse) (mockResponse ({headers: {'content-type': 'text/plain; charset=hex'}})))\n                 ('68656c6c6f'),\n]));\n\nconst respond200 = mockResponse ({});\n\ntest ('matchStatus', () => Promise.all ([\n  assertResolves (fl.map (fn.matchStatus (() => 'else') ({200: () => '200', 201: () => '201'})) (mockResponse ({code: 400}))) ('else'),\n  assertResolves (fl.map (fn.matchStatus (() => 'else') ({200: () => '200', 201: () => '201'})) (mockResponse ({code: 200}))) ('200'),\n  assertResolves (fl.map (fn.matchStatus (() => 'else') ({200: () => '200', 201: () => '201'})) (mockResponse ({code: 201}))) ('201'),\n]));\n\ntest ('acceptStatus', () => Promise.all ([\n  assertResolves (fl.map (thenBuffer) (fl.map (fn.acceptStatus (200)) (respond200)))\n                 (fl.resolve ('hello')),\n  assertResolves (fl.map (thenBuffer) (fl.map (fn.acceptStatus (201)) (respond200)))\n                 (fl.reject ('hello')),\n]));\n\ntest ('responseToError', () => (\n  assertRejects (fl.chain (fn.responseToError) (mockResponse ({\n    code: 500,\n    message: 'Internal Server Error',\n    headers: responseHeaders,\n    body: Buffer.from ('Dear user,\\n\\nEverything broke down.\\nWe are sorry.'),\n  }))) (new Error (\n    'Unexpected Internal Server Error (500) response. Response body:\\n' +\n    '\\n' +\n    '  Dear user,\\n' +\n    '  \\n' +\n    '  Everything broke down.\\n' +\n    '  We are sorry.'\n  ))\n));\n\ntest ('HTTP Integration', () => {\n  const notFound = res => (\n    fl.chain (message => fl.reject (new Error (message))) (fn.autoBufferResponse (res))\n  );\n\n  const showResponse = res => (\n    fl.map (body => `${(fn.Response.message (res)).statusCode}: ${body}`)\n           (fn.autoBufferResponse (res))\n  );\n\n  const responseHandler = res => (\n    fn.followRedirects (20) (res)\n    .pipe (fl.chain (fn.matchStatus (fn.responseToError) ({200: showResponse, 404: notFound})))\n  );\n\n  const runTest = f => withTestServer (({url}) => fl.chain (responseHandler) (f (url)));\n\n  return Promise.all ([\n    assertResolves (runTest (url => fn.retrieve (`${url}/redirect`) ({})))\n                   ('200: GET/'),\n    assertRejects (runTest (url => fn.sendJson ('POST') (`${url}/redirect`) ({}) ('hello')))\n                  (new Error ('Unexpected Moved Permanently (301) response. Response body:\\n\\n  ')),\n    assertResolves (runTest (url => fn.sendJson ('POST') (`${url}/redirect-post`) ({}) ('hello')))\n                   ('200: POST/\"hello\"'),\n    assertRejects (runTest (url => fn.retrieve (`${url}/self-redirect`) ({})))\n                  (new Error ('Unexpected Moved Permanently (301) response. Response body:\\n\\n  ')),\n    assertRejects (runTest (url => fn.retrieve (`${url}/redirect-loop-a`) ({})))\n                  (new Error ('Unexpected Moved Permanently (301) response. Response body:\\n\\n  ')),\n  ]);\n});\n"], "fixing_code": ["//. # Fluture Node\n//.\n//. FP-style HTTP and streaming utils for Node based on [Fluture][].\n//.\n//. Skip to the [Http section](#http) for the main code example.\n//.\n//. ## Usage\n//.\n//. ```console\n//. $ npm install --save fluture fluture-node\n//. ```\n//.\n//. On Node 12 and up, this module can be loaded directly with `import` or\n//. `require`. On Node versions below 12, `require` or the [esm][]-loader can\n//. be used.\n//.\n//. ## API\n\nimport http from 'http';\nimport https from 'https';\nimport qs from 'querystring';\nimport {Readable, pipeline} from 'stream';\nimport {isDeepStrictEqual} from 'util';\nimport {lookup} from 'dns';\n\nimport {\n  Future,\n  attempt,\n  chain,\n  encase,\n  map,\n  mapRej,\n  pap,\n  reject,\n  resolve,\n} from 'fluture/index.js';\n\nconst hasProp = k => o => Object.prototype.hasOwnProperty.call (o, k);\n\n//. ### EventEmitter\n\n//# once :: String -> EventEmitter -> Future Error a\n//.\n//. Resolve a Future with the first event emitted over\n//. the given event emitter under the given event name.\n//.\n//. When the Future is cancelled, it removes any trace of\n//. itself from the event emitter.\n//.\n//. ```js\n//. > const emitter = new EventEmitter ();\n//. > setTimeout (() => emitter.emit ('answer', 42), 100);\n//. > once ('answer') (emitter);\n//. Future.of (42);\n//. ```\nexport const once = event => emitter => Future ((rej, res) => {\n  const removeListeners = () => {\n    emitter.removeListener ('error', onError);\n    emitter.removeListener (event, onEvent);\n  };\n  const onError = x => {\n    removeListeners ();\n    rej (x);\n  };\n  const onEvent = x => {\n    removeListeners ();\n    res (x);\n  };\n  emitter.once ('error', onError);\n  emitter.once (event, onEvent);\n  return removeListeners;\n});\n\n//. ### Buffer\n\n//# encode :: Charset -> Buffer -> Future Error String\n//.\n//. Given an encoding and a [Buffer][], returns a Future of the result of\n//. encoding said buffer using the given encoding. The Future will reject\n//. with an Error if the encoding is unknown.\n//.\n//. ```js\n//. > encode ('utf8') (Buffer.from ('Hello world!'));\n//. 'Hello world!'\n//. ```\nexport const encode = encoding => buffer => (\n  mapRej (e => new Error (e.message))\n         (attempt (() => buffer.toString (encoding)))\n);\n\n//. ### Stream\n\n//# streamOf :: Buffer -> Future a (Readable Buffer)\n//.\n//. Given a [Buffer][], returns a Future of a [Readable][] stream which will\n//. emit the given Buffer before ending.\n//.\n//. The stream is wrapped in a Future because creation of a stream causes\n//. side-effects if it's not consumed in time, making it safer to pass it\n//. around wrapped in a Future.\nexport const streamOf = encase (buf => new Readable ({\n  highWaterMark: buf.byteLength,\n  read: function() {\n    if (this._pushed || this.push (buf)) { this.push (null); }\n    this._pushed = true;\n  },\n}));\n\n//# emptyStream :: Future a (Readable Buffer)\n//.\n//. A [Readable][] stream which ends after emiting zero bytes. Can be useful\n//. as an empty [`Request`](#Request) body, for example.\nexport const emptyStream = streamOf (Buffer.alloc (0));\n\n//# buffer :: Readable a -> Future Error (Array a)\n//.\n//. Buffer all data on a [Readable][] stream into a Future of an Array.\n//.\n//. When the Future is cancelled, it removes any trace of\n//. itself from the Stream.\n//.\n//. ```js\n//. > const stream = new Readable ({read: () => {}});\n//. > setTimeout (() => {\n//. .   stream.push ('hello');\n//. .   stream.push ('world');\n//. .   stream.push (null);\n//. . }, 100);\n//. > buffer (stream);\n//. Future.of ([Buffer.from ('hello'), Buffer.from ('world')]);\n//. ```\nexport const buffer = stream => Future ((rej, res) => {\n  const chunks = [];\n  const removeListeners = () => {\n    stream.removeListener ('data', onData);\n    stream.removeListener ('error', rej);\n    stream.removeListener ('end', onEnd);\n  };\n  const onData = d => chunks.push (d);\n  const onEnd = () => {\n    removeListeners ();\n    res (chunks);\n  };\n  const onError = e => {\n    removeListeners ();\n    rej (e);\n  };\n  stream.on ('data', onData);\n  stream.once ('error', onError);\n  stream.once ('end', onEnd);\n  return removeListeners;\n});\n\n//# bufferString :: Charset -> Readable Buffer -> Future Error String\n//.\n//. A version of [`buffer`](#buffer) specialized in Strings.\n//.\n//. Takes a charset and a [Readable][] stream of [Buffer][]s, and returns\n//. a Future containing a String with the fully buffered and encoded result.\nexport const bufferString = charset => stream => (\n  chain (encode (charset)) (map (Buffer.concat) (buffer (stream)))\n);\n\n//. ### Event Loop\n\n//# instant :: b -> Future a b\n//.\n//. Resolves a Future with the given value in the next tick,\n//. using [`process.nextTick`][]. The scheduled job cannot be\n//. cancelled and will run before any other jobs, effectively\n//. blocking the event loop until it's completed.\n//.\n//. ```js\n//. > instant ('noodles')\n//. Future.of ('noodles')\n//. ```\nexport const instant = x => Future ((rej, res) => {\n  process.nextTick (res, x);\n  return () => {};\n});\n\n//# immediate :: b -> Future a b\n//.\n//. Resolves a Future with the given value in the next tick,\n//. using [`setImmediate`][]. This job will run as soon as all\n//. other jobs are completed. When the Future is cancelled, the\n//. job is unscheduled.\n//.\n//. ```js\n//. > immediate ('results')\n//. Future.of ('results')\n//. ```\nexport const immediate = x => Future ((rej, res) => {\n  const job = setImmediate (res, x);\n  return () => { clearImmediate (job); };\n});\n\n//. ### Http\n//.\n//. The functions below are to be used in compositions such as the one shown\n//. below, in order to cover a wide variety of HTTP-related use cases.\n//.\n//. ```js\n//. import {reject, map, chain, encase, fork} from 'fluture';\n//. import {retrieve,\n//.         matchStatus,\n//.         followRedirects,\n//.         autoBufferResponse,\n//.         responseToError} from 'fluture-node';\n//.\n//. const json = res => (\n//.   chain (encase (JSON.parse)) (autoBufferResponse (res))\n//. );\n//.\n//. const notFound = res => (\n//.   chain (({message}) => reject (new Error (message))) (json (res))\n//. );\n//.\n//. retrieve ('https://api.github.com/users/Avaq') ({'User-Agent': 'Avaq'})\n//. .pipe (chain (followRedirects (20)))\n//. .pipe (chain (matchStatus (responseToError) ({200: json, 404: notFound})))\n//. .pipe (map (avaq => avaq.name))\n//. .pipe (fork (console.error) (console.log));\n//. ```\n//.\n//. The example above will either:\n//.\n//. 1. log `\"Aldwin Vlasblom\"` to the terminal if nothing weird happens; or\n//. 2. Report a 404 error using the message returned from the server; or\n//. 3. log an error to the console if:\n//.     * a network error occurs;\n//.     * the response code is not what we expect; or\n//.     * the JSON is malformed.\n//.\n//. Note that we were in control of the following:\n//.\n//. - How redirects are followed: We use [`followRedirects`](#followRedirects)\n//.   with a maxmum of 20 redirects, but we could have used a different\n//.   redirection function using [`followRedirectsWith`](#followRedirectsWith)\n//.   with the [`aggressiveRedirectionPolicy`](#aggressiveRedirectionPolicy) or\n//.   even a fully custom policy.\n//.\n//. - How an unexpected status was treated: We passed in a handler to\n//.   [`matchStatus`](#matchStatus).\n//.   We used [`responseToError`](#responseToError), conviently provided by\n//.   this library, but we could have used a custom mechanism.\n//.\n//. - How responses with expected status codes are treated:\n//.   The [`matchStatus`](#matchStatus) function lets us provide a handler\n//.   based on the status code of the response. Each handler has full control\n//.   over the response.\n//.\n//. - How the response body is buffered and decoded: Our `json` function uses\n//.   [`autoBufferResponse`](#autoBufferResponse) to buffer and decode the\n//.   response according to the mime type provided in the headers. However, we\n//.   could have used lower level functions, such as\n//.   [`bufferResponse`](#bufferResponse) or even just [`buffer`](#buffer).\n//.\n//. - How the response body is parsed: We used [`Fluture.encase`][] with\n//.   [`JSON.parse`][] to parse JSON with a safe failure path. However, we\n//.   could have used a more refined approach to parsing the JSON, for\n//.   example by using [`S.parseJson`][].\n//.\n//. The goal is to give you as much control over HTTP requests and responses\n//. as possible, while still keeping boilerplate low by leveraging function\n//. composition.\n//.\n//. This contrasts with many of the popular HTTP client libraries out there,\n//. which either make decisions for you, taking away control in an attempt to\n//. provide a smoother usage experience, or which take complicated structures\n//. of interacting options to attempt to cater to as many cases as possible.\n\n//    defaultCharset :: String\nconst defaultCharset = 'utf8';\n\n//    defaultContentType :: String\nconst defaultContentType = 'text/plain; charset=' + defaultCharset;\n\n//    charsetRegex :: RegExp\nconst charsetRegex = /\\bcharset=([^;\\s]+)/;\n\n//    mimeTypes :: StrMap Mimetype\nconst mimeTypes = {\n  form: 'application/x-www-form-urlencoded; charset=utf8',\n  json: 'application/json; charset=utf8',\n};\n\n//    getRequestModule :: String -> Future Error Module\nconst getRequestModule = protocol => {\n  switch (protocol) {\n  case 'https:': return resolve (https);\n  case 'http:': return resolve (http);\n  default: return reject (new Error (`Unsupported protocol '${protocol}'`));\n  }\n};\n\n//# Request :: Object -> Url -> Future Error (Readable Buffer) -> Request\n//.\n//. Constructs a value of type Request to be used as an argument for\n//. functions such as [`sendRequest`](#sendRequest).\n//.\n//. Takes the following arguments:\n//.\n//. 1. An Object containing any [http options][] except: `auth`, `host`,\n//.    `hostname`, `path`, `port`, and `protocol`; because they are part of\n//.    the URL, and `signal`; because Fluture handles the cancellation.\n//. 2. A String containing the request URL.\n//. 3. A Future of a [Readable][] stream of [Buffer][]s to be used as the\n//.    request body. Note that the Future must produce a brand new Stream\n//.    every time it is forked, or if it can't, it is expected to reject\n//.    with a value of type Error.\n//.\n//. See [`sendRequest`](#sendRequest) for a usage example.\nexport const Request = options => url => body => ({options, url, body});\n\n//# Request.options :: Request -> Object\n//.\n//. Get the options out of a Request.\nRequest.options = ({options}) => options;\n\n//# Request.url :: Request -> Url\n//.\n//. Get the url out of a Request.\nRequest.url = ({url}) => url;\n\n//# Request.body :: Request -> Future Error (Readable Buffer)\n//.\n//. Get the body out of a Request.\nRequest.body = ({body}) => body;\n\n//# Response :: Request -> IncomingMessage -> Response\n//.\n//. Constructs a value of type Response. These values are typically created\n//. for you by functions such as [`sendRequest`](#sendRequest).\n//. Takes the following arguments:\n//.\n//. 1. A [Request](#Request).\n//. 2. An [IncomingMessage][] assumed to belong to the Request.\nexport const Response = request => message => ({request, message});\n\n//# Response.request :: Response -> Request\n//.\n//. Get the request out of a Response.\nResponse.request = ({request}) => request;\n\n//# Response.message :: Response -> IncomingMessage\n//.\n//. Get the message out of a Response.\nResponse.message = ({message}) => message;\n\n// cleanRequestOptions :: Request -> Object\nexport const cleanRequestOptions = request => {\n  const options = Request.options (request);\n  return {\n    agent: options.agent,\n    createConnection: options.createConnection,\n    defaultPort: options.defaultPort || (\n      options.agent && options.agent.defaultPort\n    ),\n    family: options.family,\n    headers: options.headers || {},\n    insecureHTTPParser: options.insecureHTTPParser === true,\n    localAddress: options.localAddress,\n    lookup: options.lookup || lookup,\n    maxHeaderSize: options.maxHeaderSize || 16384,\n    method: (options.method || 'GET').toUpperCase (),\n    setHost: options.setHost !== false,\n    socketPath: options.socketPath,\n    timeout: options.timeout,\n  };\n};\n\n//# sendRequest :: Request -> Future Error Response\n//.\n//. This is the \"lowest level\" function for making HTTP requests. It does not\n//. handle buffering, encoding, content negotiation, or anything really.\n//. For most use cases, you can use one of the more specialized functions:\n//.\n//. * [`send`](#send): Make a generic HTTP request.\n//. * [`retrieve`](#retrieve): Make a GET request.\n//.\n//. Given a [Request](#Request), returns a Future which makes an HTTP request\n//. and resolves with the resulting [Response](#Response).\n//. If the Future is cancelled, the request is aborted.\n//.\n//. ```js\n//. import {attempt} from 'fluture';\n//. import {createReadStream} from 'fs';\n//.\n//. const BinaryPostRequest = Request ({\n//.   method: 'POST',\n//.   headers: {'Transfer-Encoding': 'chunked'},\n//. });\n//.\n//. const eventualBody = attempt (() => createReadStream ('./data.bin'));\n//.\n//. sendRequest (BinaryPostRequest ('https://example.com') (eventualBody));\n//. ```\n//.\n//. If you want to use this function to transfer a stream of data, don't forget\n//. to set the Transfer-Encoding header to \"chunked\".\nexport const sendRequest = request => {\n  const location = new URL (Request.url (request));\n  const makeRequest = lib => stream => Future ((rej, res) => {\n    const req = lib.request (location, cleanRequestOptions (request));\n    const onResponse = response => res (Response (request) (response));\n    req.once ('response', onResponse);\n    pipeline (stream, req, e => e && rej (e));\n    return () => {\n      req.removeListener ('response', onResponse);\n      req.abort ();\n    };\n  });\n  return (\n    getRequestModule (location.protocol)\n    .pipe (map (makeRequest))\n    .pipe (pap (Request.body (request)))\n    .pipe (chain (x => x))\n  );\n};\n\n//# retrieve :: Url -> StrMap String -> Future Error Response\n//.\n//. A version of [`sendRequest`](#sendRequest) specialized in the `GET` method.\n//.\n//. Given a URL and a StrMap of request headers, returns a Future which\n//. makes a GET requests to the given resource.\n//.\n//. ```js\n//. retrieve ('https://api.github.com/users/Avaq') ({'User-Agent': 'Avaq'})\n//. ```\nexport const retrieve = url => headers => (\n  sendRequest (Request ({headers}) (url) (emptyStream))\n);\n\n//# send :: Mimetype -> Method -> Url -> StrMap String -> Buffer -> Future Error Response\n//.\n//. A version of [`sendRequest`](#sendRequest) for sending arbitrary data to\n//. a server. There's also more specific versions for sending common types of\n//. data:\n//.\n//. * [`sendJson`](#sendJson) sends JSON stringified data.\n//. * [`sendForm`](#sendForm) sends form encoded data.\n//.\n//. Given a MIME type, a request method, a URL, a StrMap of headers, and\n//. finally a Buffer, returns a Future which will send the Buffer to the\n//. server at the given URL using the given request method, telling it the\n//. buffer contains data of the given MIME type.\n//.\n//. This function will always send the Content-Type and Content-Length headers,\n//. alongside the provided headers. Manually provoding either of these headers\n//. override those generated by this function.\nexport const send = mime => method => url => extraHeaders => buf => {\n  const headers = Object.assign ({\n    'Content-Type': mime,\n    'Content-Length': buf.byteLength,\n  }, extraHeaders);\n  return sendRequest (Request ({method, headers}) (url) (streamOf (buf)));\n};\n\n//# sendJson :: Method -> String -> StrMap String -> JsonValue -> Future Error Response\n//.\n//. A version of [`send`](#send) specialized in sending JSON.\n//.\n//. Given a request method, a URL, a StrMap of headers and a JavaScript plain\n//. object, returns a Future which sends the object to the server at the\n//. given URL after JSON-encoding it.\n//.\n//. ```js\n//. sendJson ('PUT')\n//.          ('https://example.com/users/bob')\n//.          ({Authorization: 'Bearer asd123'})\n//.          ({name: 'Bob', email: 'bob@example.com'});\n//. ```\nexport const sendJson = method => url => headers => json => {\n  const buf = Buffer.from (JSON.stringify (json));\n  return send (mimeTypes.json) (method) (url) (headers) (buf);\n};\n\n//# sendForm :: Method -> String -> StrMap String -> JsonValue -> Future Error Response\n//.\n//. A version of [`send`](#send) specialized in sending form data.\n//.\n//. Given a request method, a URL, a StrMap of headers and a JavaScript plain\n//. object, returns a Future which sends the object to the server at the\n//. given URL after www-form-urlencoding it.\n//.\n//. ```js\n//. sendForm ('POST')\n//.          ('https://example.com/users/create')\n//.          ({})\n//.          ({name: 'Bob', email: 'bob@example.com'});\n//. ```\nexport const sendForm = method => url => headers => form => {\n  const buf = Buffer.from (qs.stringify (form));\n  return send (mimeTypes.form) (method) (url) (headers) (buf);\n};\n\n//# matchStatus :: (Response -> a) -> StrMap (Response -> a) -> Response -> a\n//.\n//. Transform a [`Response`](#Response) based on its status code.\n//.\n//. ```js\n//. import {chain} from 'fluture';\n//.\n//. const processResponse = matchStatus (responseToError) ({\n//.   200: autoBufferResponse,\n//. });\n//.\n//. chain (processResponse) (retreive ('https://example.com'));\n//. ```\n//.\n//. This is kind of like a `switch` statement on the status code of the\n//. Response message. Or, if you will, a pattern match against the\n//. Response type if you imagine it being tagged via the status code.\n//.\n//. The first argument is the \"default\" case, and the second argument is a\n//. map of status codes to functions that should have the same type as the\n//. first argument.\n//.\n//. The resulting function `Response -> a` has the same signature as the input\n//. functions, meaning you can use `matchStatus` *again* to \"extend\" the\n//. pattern by passing the old pattern as the \"default\" case for the new one:\n//.\n//. ```js\n//. import {reject} from 'fluture';\n//.\n//. matchStatus (processResponse) ({\n//.   404: () => reject (new Error ('Example not found!')),\n//. });\n//. ```\nexport const matchStatus = f => fs => res => {\n  const {statusCode} = Response.message (res);\n  return (hasProp (statusCode) (fs) ? fs[statusCode] : f) (res);\n};\n\n// mergeUrls :: (Url, Any) -> String\nconst mergeUrls = (base, input) => (\n  typeof input === 'string' ?\n  new URL (input, base).href :\n  base\n);\n\n// sameOrigin :: (Url, Url) -> Boolean\nconst sameOrigin = (parent, child) => {\n  const p = new URL (parent);\n  const c = new URL (child);\n  return (p.protocol === c.protocol || c.protocol === 'https:') &&\n         (p.host === c.host || c.host.endsWith ('.' + p.host));\n};\n\n// overHeaders :: (Request, Array2 String String -> Array2 String String)\n//             -> Request\nconst overHeaders = (request, f) => {\n  const options = cleanRequestOptions (request);\n  const headers = Object.fromEntries (f (Object.entries (options.headers)));\n  return Request (Object.assign ({}, Request.options (request), {headers}))\n                 (Request.url (request))\n                 (Request.body (request));\n};\n\n// confidentialHeaders :: Array String\nconst confidentialHeaders = [\n  'authorization',\n  'cookie',\n];\n\n//# redirectAnyRequest :: Response -> Request\n//.\n//. A redirection strategy that simply reissues the original Request to the\n//. Location specified in the given Response.\n//.\n//. If the new location is on an external host, then any confidential headers\n//. (such as the cookie header) will be dropped from the new request.\n//.\n//. Used in the [`defaultRedirectionPolicy`](#defaultRedirectionPolicy) and\n//. the [`aggressiveRedirectionPolicy`](#aggressiveRedirectionPolicy).\nexport const redirectAnyRequest = response => {\n  const {headers: {location}} = Response.message (response);\n  const original = Response.request (response);\n  const oldUrl = Request.url (original);\n  const newUrl = mergeUrls (oldUrl, location);\n  const request = Request (Request.options (original))\n                          (newUrl)\n                          (Request.body (original));\n\n  return sameOrigin (oldUrl, newUrl) ? request : overHeaders (request, xs => (\n    xs.filter (([name]) => !confidentialHeaders.includes (name.toLowerCase ()))\n  ));\n};\n\n//# redirectIfGetMethod :: Response -> Request\n//.\n//. A redirection strategy that simply reissues the original Request to the\n//. Location specified in the given Response, but only if the original request\n//. was using the GET method.\n//.\n//. If the new location is on an external host, then any confidential headers\n//. (such as the cookie header) will be dropped from the new request.\n//.\n//. Used in [`followRedirectsStrict`](#followRedirectsStrict).\nexport const redirectIfGetMethod = response => {\n  const {method} = cleanRequestOptions (Response.request (response));\n  return (\n    method === 'GET' ?\n    redirectAnyRequest (response) :\n    Response.request (response)\n  );\n};\n\n//# redirectUsingGetMethod :: Response -> Request\n//.\n//. A redirection strategy that sends a new GET request based on the original\n//. request to the Location specified in the given Response. If the response\n//. does not contain a valid location, the request is not redirected.\n//.\n//. The original request method and body are discarded, but other options\n//. are preserved. If the new location is on an external host, then any\n//. confidential headers (such as the cookie header) will be dropped from the\n//. new request.\n//.\n//. Used in the [`defaultRedirectionPolicy`](#defaultRedirectionPolicy) and\n//. the [`aggressiveRedirectionPolicy`](#aggressiveRedirectionPolicy).\nexport const redirectUsingGetMethod = response => {\n  const original = Response.request (response);\n  const options = Object.assign ({}, Request.options (original), {\n    method: 'GET',\n  });\n  const request = Request (options) (Request.url (original)) (emptyStream);\n  return redirectAnyRequest (Response (request) (Response.message (response)));\n};\n\n// See https://developer.mozilla.org/docs/Web/HTTP/Headers#Conditionals\nconst conditionHeaders = [\n  'if-match',\n  'if-modified-since',\n  'if-none-match',\n  'if-unmodified-since',\n];\n\n//# retryWithoutCondition :: Response -> Request\n//.\n//. A redirection strategy that removes any caching headers if present and\n//. retries the request, or does nothing if no caching headers were present\n//. on the original request.\n//.\n//. Used in the [`defaultRedirectionPolicy`](#defaultRedirectionPolicy).\nexport const retryWithoutCondition = response => {\n  const original = Response.request (response);\n  const {method} = cleanRequestOptions (original);\n  const request = overHeaders (original, xs => xs.filter (([name]) => (\n    !(conditionHeaders.includes (name.toLowerCase ()))\n  )));\n  return method === 'GET' ? request : original;\n};\n\n//# defaultRedirectionPolicy :: Response -> Request\n//.\n//. Carefully follows redirects in strict accordance with\n//. [RFC2616 Section 10.3][].\n//.\n//. Redirections with status codes 301, 302, and 307 are only followed if the\n//. original request used the GET method, and redirects with status code 304\n//. are left alone for a caching layer to deal with.\n//.\n//. This redirection policy is used by default in the\n//. [`followRedirects`](#followRedirects) function. You can extend it, using\n//. [`matchStatus`](#matchStatus) to create a custom redirection policy, as\n//. shown in the example:\n//.\n//. See also [`aggressiveRedirectionPolicy`](#aggressiveRedirectionPolicy).\n//.\n//. ```js\n//. const redirectToBestOption = () => {\n//.   // Somehow figure out which URL to redirect to.\n//. };\n//.\n//. const myRedirectionPolicy = matchStatus (defaultRedirectionPolicy) ({\n//.   300: redirectToBestOption,\n//.   301: redirectUsingGetMethod,\n//. });\n//.\n//. retrieve ('https://example.com') ({})\n//. .pipe (chain (followRedirectsWith (myRedirectionPolicy) (10)))\n//. ```\nexport const defaultRedirectionPolicy = matchStatus (Response.request) ({\n  301: redirectIfGetMethod,\n  302: redirectIfGetMethod,\n  303: redirectUsingGetMethod,\n  305: redirectAnyRequest,\n  307: redirectIfGetMethod,\n});\n\n//# aggressiveRedirectionPolicy :: Response -> Request\n//.\n//. Aggressively follows redirects in mild violation of\n//. [RFC2616 Section 10.3][]. In particular, anywhere that a redirection\n//. should be interrupted for user confirmation or caching, this policy\n//. follows the redirection nonetheless.\n//.\n//. Redirections with status codes 301, 302, and 307 are always followed\n//. without user intervention, and redirects with status code 304 are\n//. retried without conditions if the original request had any conditional\n//. headers.\n//.\n//. See also [`defaultRedirectionPolicy`](defaultRedirectionPolicy).\n//.\n//. ```js\n//. retrieve ('https://example.com') ({})\n//. .pipe (chain (followRedirectsWith (aggressiveRedirectionPolicy) (10)))\n//. ```\nexport const aggressiveRedirectionPolicy = matchStatus (Response.request) ({\n  301: redirectAnyRequest,\n  302: redirectAnyRequest,\n  303: redirectUsingGetMethod,\n  304: retryWithoutCondition,\n  305: redirectAnyRequest,\n  307: redirectAnyRequest,\n});\n\n// requestsEquivalent :: Request -> Request -> Boolean\nconst requestsEquivalent = left => right => (\n  isDeepStrictEqual (\n    cleanRequestOptions (left),\n    cleanRequestOptions (right)\n  ) &&\n  Request.url (left) === Request.url (right) &&\n  Request.body (left) === Request.body (right)\n);\n\n//# followRedirectsWith :: (Response -> Request) -> Number -> Response -> Future Error Response\n//.\n//. Given a function that take a Response and produces a new Request, and a\n//. \"maximum\" number, recursively keeps resolving new requests until a request\n//. is encountered that was seen before, or the maximum number is reached.\n//.\n//. See [`followRedirects`](#followRedirects) for an out-of-the-box redirect-\n//. follower. See [`aggressiveRedirectionPolicy`](#aggressiveRedirectionPolicy)\n//. and [`defaultRedirectionPolicy`](defaultRedirectionPolicy) for\n//. additional usage examples.\nexport const followRedirectsWith = strategy => _max => _response => {\n  const seen = [];\n  const followUp = max => response => {\n    if (max < 1) {\n      return resolve (response);\n    }\n    seen.push (Response.request (response));\n    const nextRequest = strategy (response);\n    for (let i = seen.length - 1; i >= 0; i -= 1) {\n      if (requestsEquivalent (seen[i]) (nextRequest)) {\n        return resolve (response);\n      }\n    }\n    return (\n      sendRequest (nextRequest)\n      .pipe (mapRej (e => new Error ('After redirect: ' + e.message)))\n      .pipe (chain (followUp (max - 1)))\n    );\n  };\n  return followUp (_max) (_response);\n};\n\n//# followRedirects :: Number -> Response -> Future Error Response\n//.\n//. Given the maximum numbers of redirections, follows redirects according to\n//. the [default redirection policy](#defaultRedirectionPolicy).\n//.\n//. See the [Http section](#http) for a usage example.\nexport const followRedirects = followRedirectsWith (defaultRedirectionPolicy);\n\n//# acceptStatus :: Number -> Response -> Future Response Response\n//.\n//. This function \"tags\" a [Response](#Response) based on a given status code.\n//. If the response status matches the given status code, the returned Future\n//. will resolve. If it doesn't, the returned Future will reject.\n//.\n//. See also [`matchStatus`](#matchStatus), which will probably be more useful\n//. in most cases.\n//.\n//. The idea is that you can compose this function with one that returns a\n//. Response, and reject any responses that don't meet the expected status\n//. code.\n//.\n//. In combination with [`responseToError`](#responseToError), you can then\n//. flatten it back into the outer Future. The usage example under the\n//. [Http](#http) section shows this.\nexport const acceptStatus = code => matchStatus (reject) ({[code]: resolve});\n\n//# bufferMessage :: Charset -> IncomingMessage -> Future Error String\n//.\n//. A version of [`buffer`](#buffer) specialized in [IncomingMessage][]s.\n//.\n//. See also [`bufferResponse`](#bufferResponse) and\n//. [`autoBufferMessage`](#autoBufferMessage).\n//.\n//. Given a charset and an IncomingMessage, returns a Future with the buffered,\n//. encoded, message body.\nexport const bufferMessage = charset => message => (\n  mapRej (e => new Error ('Failed to buffer response: ' + e.message))\n         (bufferString (charset) (message))\n);\n\n//# bufferResponse :: Charset -> Response -> Future Error String\n//.\n//. A composition of [`Response.message`](#Response.message) and\n//. [`bufferMessage`](#bufferMessage) for your convenience.\n//.\n//. See also [autoBufferResponse](#autoBufferResponse).\nexport const bufferResponse = charset => response => (\n  bufferMessage (charset) (Response.message (response))\n);\n\n//# autoBufferMessage :: IncomingMessage -> Future Error String\n//.\n//. Given an IncomingMessage, buffers and decodes the message body using the\n//. charset provided in the message headers. Falls back to UTF-8 if the\n//. charset was not provided.\n//.\n//. Returns a Future with the buffered, encoded, message body.\n//.\n//. See also [bufferMessage](#bufferMessage).\nexport const autoBufferMessage = message => {\n  const contentType = message.headers['content-type'] || defaultContentType;\n  const parsed = charsetRegex.exec (contentType);\n  const charset = parsed == null ? defaultCharset : parsed[1];\n  return bufferMessage (charset) (message);\n};\n\n//# autoBufferResponse :: Response -> Future Error String\n//.\n//. A composition of [`Response.message`](#Response.message) and\n//. [`autoBufferMessage`](#autoBufferMessage) for your convenience.\n//.\n//. See also [bufferResponse](#bufferResponse).\nexport const autoBufferResponse = response => (\n  autoBufferMessage (Response.message (response))\n);\n\n//# responseToError :: Response -> Future Error a\n//.\n//. Given a [Response](#Response), returns a *rejected* Future of an instance\n//. of Error with a message based on the content of the response.\nexport const responseToError = response => {\n  const message = Response.message (response);\n  return autoBufferMessage (message)\n  .pipe (chain (body => reject (new Error (\n    `Unexpected ${message.statusMessage} (${message.statusCode}) response. ` +\n    `Response body:\\n\\n${body.split ('\\n').map (x => `  ${x}`).join ('\\n')}`\n  ))));\n};\n\n//. [`process.nextTick`]: https://nodejs.org/api/process.html#process_process_nexttick_callback_args\n//. [`setImmediate`]: https://nodejs.org/api/timers.html#timers_setimmediate_callback_args\n//. [`S.parseJson`]: https://sanctuary.js.org/#parseJson\n//. [`Fluture.encase`]: https://github.com/fluture-js/Fluture#encase\n//. [`JSON.parse`]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse\n\n//. [Buffer]: https://nodejs.org/api/buffer.html#buffer_class_buffer\n//. [Fluture]: https://github.com/fluture-js/Fluture\n//. [http options]: https://nodejs.org/api/http.html#http_http_request_url_options_callback\n//. [IncomingMessage]: https://nodejs.org/api/http.html#http_class_http_incomingmessage\n//. [Readable]: https://nodejs.org/api/stream.html#stream_class_stream_readable\n\n//. [RFC2616 Section 10.3]: https://tools.ietf.org/html/rfc2616#section-10.3\n//. [esm]: https://github.com/standard-things/esm\n", "import {EventEmitter} from 'events';\nimport * as fl from 'fluture';\nimport test from 'oletus';\nimport {Readable} from 'stream';\nimport {equivalence, equality as eq} from 'fluture/test/assertions.js';\nimport {withTestServer} from './server.js';\nimport {lookup} from 'dns';\n\nimport * as fn from '../index.js';\n\nconst assertResolves = a => b => equivalence (a) (fl.resolve (b));\nconst assertRejects = a => b => equivalence (a) (fl.reject (b));\n\nconst noop = () => {};\n\ntest ('once', () => {\n  const ee1 = new EventEmitter ();\n\n  const cancel = fl.value (noop) (fn.once ('test') (ee1));\n  eq (ee1.listenerCount ('test')) (1);\n  eq (ee1.listenerCount ('error')) (1);\n\n  cancel ();\n  eq (ee1.listenerCount ('test')) (0);\n  eq (ee1.listenerCount ('error')) (0);\n\n  const ee2 = new EventEmitter ();\n  const ee3 = new EventEmitter ();\n\n  setTimeout (() => {\n    ee2.emit ('test', 42);\n    ee3.emit ('error', 42);\n  }, 10);\n\n  return Promise.all ([\n    assertResolves (fn.once ('test') (ee2)) (42),\n    assertRejects (fn.once ('test') (ee3)) (42),\n  ]);\n});\n\ntest ('encode', () => Promise.all ([\n  assertRejects (fn.encode ('lalalala') (Buffer.from ('hello')))\n                (new Error ('Unknown encoding: lalalala')),\n  assertResolves (fn.encode ('utf8') (Buffer.from ('hello'))) ('hello'),\n  assertResolves (fn.encode ('hex') (Buffer.from ('hello'))) ('68656c6c6f'),\n]));\n\ntest ('streamOf', () => {\n  const eventualStream = fn.streamOf (Buffer.from ('hello'));\n  return new Promise ((res, rej) => {\n    fl.fork (e => rej (new Error ('The future rejected: ' + String (e))))\n            (stream => {\n              stream.on ('end', res);\n              stream.on ('data', data => {\n                try {\n                  eq (data) (Buffer.from ('hello'));\n                } catch (e) {\n                  rej (e);\n                }\n              });\n            })\n            (eventualStream);\n    setTimeout (rej, 20, new Error ('No data on the stream'));\n  });\n});\n\ntest ('emptyStream', () => new Promise ((res, rej) => {\n  fl.fork (e => rej (new Error ('The Future rejected: ' + String (e))))\n          (stream => {\n            stream.on ('data', data => {\n              rej (new Error ('The stream emitted data: ' + String (data)));\n            });\n            stream.on ('end', res);\n          })\n          (fn.emptyStream);\n}));\n\ntest ('buffer', () => {\n  const s1 = new Readable ({read: noop});\n  const s2 = new Readable ({read: noop});\n\n  const b1 = Buffer.from ('hello');\n  const b2 = Buffer.from ('world');\n\n  s1.push (b1);\n\n  setTimeout (() => {\n    s1.push (b2);\n    s1.push (null);\n    s2.emit ('error', 42);\n  }, 10);\n\n  return Promise.all ([\n    assertResolves (fn.buffer (s1)) ([b1, b2]),\n    assertRejects (fn.buffer (s2)) (42),\n  ]);\n});\n\ntest ('bufferString', () => Promise.all ([\n  assertResolves (fl.chain (fn.bufferString ('utf8')) (fn.streamOf (Buffer.from ('hello'))))\n                 ('hello'),\n  assertResolves (fl.chain (fn.bufferString ('hex')) (fn.streamOf (Buffer.from ('hello'))))\n                 ('68656c6c6f'),\n]));\n\ntest ('instant', () => (\n  assertResolves (fn.instant ('noodles')) ('noodles')\n));\n\ntest ('immediate', () => {\n  fl.value (eq ('should not run')) (fn.immediate ('did run')) ();\n  return assertResolves (fn.immediate ('results')) ('results');\n});\n\nconst getRequest = fn.Request ({}) ('https://example.com') (fn.emptyStream);\n\nconst postRequest = fn.Request ({method: 'POST'}) ('https://example.com') (fn.streamOf (Buffer.from ('test')));\n\nconst responseHeaders = {\n  'connection': 'close',\n  'content-type': 'text/plain',\n  'date': 'now',\n  'transfer-encoding': 'chunked',\n};\n\nconst mockResponse = ({code = 200, message = 'OK', headers = responseHeaders, request = getRequest, body = Buffer.from ('hello')}) => fl.map (stream => {\n  stream.headers = headers;\n  stream.statusCode = code;\n  stream.statusMessage = message;\n  return fn.Response (request) (stream);\n}) (fn.streamOf (body));\n\nconst getResponse = code => location => mockResponse ({\n  code: code,\n  headers: Object.assign ({}, responseHeaders, {location}),\n  request: getRequest,\n});\n\nconst postResponse = code => location => mockResponse ({\n  code: code,\n  headers: Object.assign ({}, responseHeaders, {location}),\n  request: postRequest,\n});\n\nconst sendMockRequest = eventualBody => withTestServer (({url}) => (\n  fn.sendRequest (fn.Request ({headers: {\n    'Connection': 'close',\n    'Transfer-Encoding': 'chunked',\n  }}) (`${url}/echo`) (eventualBody))\n));\n\ntest ('Request', () => {\n  const options = {};\n  const url = 'https://example.com';\n  const body = fn.emptyStream;\n  const request = fn.Request (options) (`${url}/echo`) (body);\n  eq (fn.Request.options (request)) (options);\n  eq (fn.Request.url (request)) (`${url}/echo`);\n  eq (fn.Request.body (request)) (body);\n});\n\ntest ('Response', () => {\n  const message = fn.emptyStream;\n  const response = fn.Response (getRequest) (message);\n  eq (fn.Response.request (response)) (getRequest);\n  eq (fn.Response.message (response)) (message);\n});\n\ntest ('cleanRequestOptions', () => {\n  const req = o => fn.Request (o) ('https://example.com') (fn.emptyStream);\n  eq (fn.cleanRequestOptions (req ({}))) ({\n    agent: undefined,\n    createConnection: undefined,\n    defaultPort: undefined,\n    family: undefined,\n    headers: {},\n    insecureHTTPParser: false,\n    localAddress: undefined,\n    lookup: lookup,\n    maxHeaderSize: 16384,\n    method: 'GET',\n    setHost: true,\n    socketPath: undefined,\n    timeout: undefined,\n  });\n  eq (fn.cleanRequestOptions (req ({agent: {defaultPort: 42}}))) ({\n    agent: {defaultPort: 42},\n    createConnection: undefined,\n    defaultPort: 42,\n    family: undefined,\n    headers: {},\n    insecureHTTPParser: false,\n    localAddress: undefined,\n    lookup: lookup,\n    maxHeaderSize: 16384,\n    method: 'GET',\n    setHost: true,\n    socketPath: undefined,\n    timeout: undefined,\n  });\n});\n\ntest ('bufferResponse', () => Promise.all ([\n  assertResolves (fl.chain (fn.bufferResponse ('utf8')) (sendMockRequest (fn.emptyStream)))\n                 ('GET/'),\n  assertResolves (fl.chain (fn.bufferResponse ('utf8')) (sendMockRequest (fn.streamOf (Buffer.from ('hello')))))\n                 ('GET/hello'),\n]));\n\nconst thenBuffer = fl.bichain (res => fl.swap (fn.bufferResponse ('utf8') (res)))\n                              (fn.bufferResponse ('utf8'));\n\ntest ('sendRequest', () => Promise.all ([\n  assertRejects (fn.sendRequest (fn.Request ({}) ('https://localhost') (fn.emptyStream)))\n                (Object.assign (new Error ('connect ECONNREFUSED 127.0.0.1:443'), {\n                  address: '127.0.0.1',\n                  code: 'ECONNREFUSED',\n                  errno: -111,\n                  port: 443,\n                  syscall: 'connect',\n                })),\n  assertRejects (fn.sendRequest (fn.Request ({}) ('ftp://localhost') (fn.emptyStream)))\n                (new Error (\"Unsupported protocol 'ftp:'\")),\n  assertResolves (thenBuffer (sendMockRequest (fn.emptyStream)))\n                 ('GET/'),\n  assertResolves (thenBuffer (sendMockRequest (fn.streamOf (Buffer.from ('hello')))))\n                 ('GET/hello'),\n]));\n\ntest ('request cancellation', () => new Promise ((res, rej) => {\n  const cancel = fl.fork (rej)\n                         (rej)\n                         (fn.sendRequest (fn.Request ({}) ('https://localhost') (fn.emptyStream)));\n  cancel ();\n  setTimeout (res, 1000);\n}));\n\ntest ('retrieve', () => Promise.all ([\n  assertResolves (withTestServer (({url}) => thenBuffer (fn.retrieve (`${url}/echo`) ({}))))\n                 ('GET/'),\n]));\n\ntest ('send', () => Promise.all ([\n  assertResolves (withTestServer (({url}) => thenBuffer (fn.send ('text/plain') ('POST') (`${url}/echo`) ({}) (Buffer.from ('hello')))))\n                 ('POST/hello'),\n]));\n\ntest ('sendJson', () => Promise.all ([\n  assertResolves (withTestServer (({url}) => thenBuffer (fn.sendJson ('POST') (`${url}/echo`) ({}) ({message: 'hello'}))))\n                 ('POST/{\"message\":\"hello\"}'),\n]));\n\ntest ('sendForm', () => Promise.all ([\n  assertResolves (withTestServer (({url}) => thenBuffer (fn.sendForm ('POST') (`${url}/echo`) ({}) ({message: 'hello'}))))\n                 ('POST/message=hello'),\n]));\n\ntest ('redirectAnyRequest', () => Promise.all ([\n  assertResolves (fl.map (fn.redirectAnyRequest) (mockResponse ({})))\n                 (getRequest),\n  assertResolves (fl.map (fn.redirectAnyRequest) (getResponse (301) ('ftp://xxx')))\n                 (fn.Request ({headers: {}}) ('ftp://xxx/') (fn.emptyStream)),\n  assertResolves (fl.map (fn.redirectAnyRequest) (getResponse (301) ('/echo')))\n                 (fn.Request ({}) ('https://example.com/echo') (fn.emptyStream)),\n  assertResolves (fl.map (fn.redirectAnyRequest) (postResponse (301) ('/echo')))\n                 (fn.Request ({method: 'POST'}) ('https://example.com/echo') (fn.streamOf (Buffer.from ('test')))),\n  assertResolves (fl.map (fn.redirectAnyRequest)\n                         (mockResponse ({code: 301,\n                                         headers: {location: 'https://example.com/path'},\n                                         request: fn.Request ({headers: {cookie: 'yum'}}) ('https://example.com') (fn.emptyStream)})))\n                 (fn.Request ({headers: {cookie: 'yum'}}) ('https://example.com/path') (fn.emptyStream)),\n  assertResolves (fl.map (fn.redirectAnyRequest)\n                         (mockResponse ({code: 301,\n                                         headers: {location: 'https://sub.example.com/'},\n                                         request: fn.Request ({headers: {cookie: 'yum'}}) ('https://example.com') (fn.emptyStream)})))\n                 (fn.Request ({headers: {cookie: 'yum'}}) ('https://sub.example.com/') (fn.emptyStream)),\n  assertResolves (fl.map (fn.redirectAnyRequest)\n                         (mockResponse ({code: 301,\n                                         headers: {location: 'https://bigsub.example.com/'},\n                                         request: fn.Request ({headers: {cookie: 'yum'}}) ('https://example.com') (fn.emptyStream)})))\n                 (fn.Request ({headers: {cookie: 'yum'}}) ('https://bigsub.example.com/') (fn.emptyStream)),\n  assertResolves (fl.map (fn.redirectAnyRequest)\n                         (mockResponse ({code: 301,\n                                         headers: {location: 'https://elsewhere.com/'},\n                                         request: fn.Request ({headers: {cookie: 'yum'}}) ('https://example.com') (fn.emptyStream)})))\n                 (fn.Request ({headers: {}}) ('https://elsewhere.com/') (fn.emptyStream)),\n  assertResolves (fl.map (fn.redirectAnyRequest)\n                         (mockResponse ({code: 301,\n                                         headers: {location: 'http://example.com/'},\n                                         request: fn.Request ({headers: {cookie: 'yum'}}) ('https://example.com') (fn.emptyStream)})))\n                 (fn.Request ({headers: {}}) ('http://example.com/') (fn.emptyStream)),\n]));\n\ntest ('redirectIfGetMethod', () => Promise.all ([\n  assertResolves (fl.map (fn.redirectIfGetMethod) (mockResponse ({})))\n                 (getRequest),\n  assertResolves (fl.map (fn.redirectIfGetMethod) (getResponse (301) ('ftp://xxx')))\n                 (fn.Request ({headers: {}}) ('ftp://xxx/') (fn.emptyStream)),\n  assertResolves (fl.map (fn.redirectIfGetMethod) (getResponse (301) ('/echo')))\n                 (fn.Request ({}) ('https://example.com/echo') (fn.emptyStream)),\n  assertResolves (fl.map (fn.redirectIfGetMethod) (postResponse (301) ('/echo')))\n                 (postRequest),\n]));\n\ntest ('redirectUsingGetMethod', () => Promise.all ([\n  assertResolves (fl.map (fn.redirectUsingGetMethod) (mockResponse ({})))\n                 (fn.Request ({method: 'GET'}) ('https://example.com') (fn.emptyStream)),\n  assertResolves (fl.map (fn.redirectUsingGetMethod) (getResponse (301) ('ftp://xxx')))\n                 (fn.Request ({method: 'GET', headers: {}}) ('ftp://xxx/') (fn.emptyStream)),\n  assertResolves (fl.map (fn.redirectUsingGetMethod) (getResponse (200) ('/echo')))\n                 (fn.Request ({method: 'GET'}) ('https://example.com/echo') (fn.emptyStream)),\n  assertResolves (fl.map (fn.redirectUsingGetMethod) (postResponse (200) ('/echo')))\n                 (fn.Request ({method: 'GET'}) ('https://example.com/echo') (fn.emptyStream)),\n]));\n\ntest ('retryWithoutCondition', () => Promise.all ([\n  assertResolves (fl.map (fn.retryWithoutCondition) (mockResponse ({})))\n                 (fn.Request ({headers: {}}) ('https://example.com') (fn.emptyStream)),\n  assertResolves (fl.map (fn.retryWithoutCondition) (getResponse (301) ('ftp://xxx')))\n                 (fn.Request ({headers: {}}) ('https://example.com') (fn.emptyStream)),\n  assertResolves (fl.map (fn.retryWithoutCondition) (getResponse (200) ('/echo')))\n                 (fn.Request ({headers: {}}) ('https://example.com') (fn.emptyStream)),\n  assertResolves (fl.map (fn.retryWithoutCondition) (postResponse (200) ('/echo')))\n                 (fn.Request ({method: 'POST'}) ('https://example.com') (fn.streamOf (Buffer.from ('test')))),\n  assertResolves (fl.map (fn.retryWithoutCondition) (mockResponse ({request: fn.Request ({headers: {'If-None-Match': 'abc123'}}) ('https://example.com') (fn.emptyStream), body: Buffer.from ('test')})))\n                 (fn.Request ({headers: {}}) ('https://example.com') (fn.emptyStream)),\n  assertResolves (fl.map (fn.retryWithoutCondition) (mockResponse ({request: fn.Request ({method: 'POST', headers: {'If-None-Match': 'abc123'}}) ('https://example.com') (fn.streamOf (Buffer.from ('hello'))), body: Buffer.from ('test')})))\n                 (fn.Request ({method: 'POST', headers: {'If-None-Match': 'abc123'}}) ('https://example.com') (fn.streamOf (Buffer.from ('hello')))),\n]));\n\ntest ('followRedirectsWith', () => Promise.all ([\n  assertResolves (thenBuffer (withTestServer (({url}) => fl.chain (fn.followRedirectsWith (_ => fn.Request ({}) (`${url}/echo`) (fn.emptyStream)) (1)) (mockResponse ({})))))\n                 ('GET/'),\n  assertResolves (thenBuffer (withTestServer (({url}) => fl.chain (fn.followRedirectsWith (_ => fn.Request ({}) (`${url}/echo`) (fn.emptyStream)) (0)) (mockResponse ({})))))\n                 ('hello'),\n]));\n\ntest ('followRedirects', () => Promise.all ([\n  assertResolves (fl.chain (fn.bufferResponse ('utf8')) (fl.chain (fn.followRedirects (1)) (mockResponse ({}))))\n                 ('hello'),\n  assertResolves (withTestServer (({url}) => fl.chain (fn.bufferResponse ('utf8')) (fl.chain (fn.followRedirects (1)) (getResponse (301) (`${url}/echo`)))))\n                 ('GET/'),\n  assertResolves (withTestServer (({url}) => fl.chain (fn.bufferResponse ('utf8')) (fl.chain (fn.followRedirects (1)) (getResponse (302) (`${url}/echo`)))))\n                 ('GET/'),\n  assertResolves (withTestServer (({url}) => fl.chain (fn.bufferResponse ('utf8')) (fl.chain (fn.followRedirects (1)) (getResponse (303) (`${url}/echo`)))))\n                 ('GET/'),\n  assertResolves (withTestServer (({url}) => fl.chain (fn.bufferResponse ('utf8')) (fl.chain (fn.followRedirects (1)) (getResponse (304) (`${url}/echo`)))))\n                 ('hello'),\n  assertResolves (withTestServer (({url}) => fl.chain (fn.bufferResponse ('utf8')) (fl.chain (fn.followRedirects (1)) (getResponse (305) (`${url}/echo`)))))\n                 ('GET/'),\n  assertResolves (withTestServer (({url}) => fl.chain (fn.bufferResponse ('utf8')) (fl.chain (fn.followRedirects (1)) (getResponse (307) (`${url}/echo`)))))\n                 ('GET/'),\n  assertResolves (withTestServer (({url}) => fl.chain (fn.bufferResponse ('utf8')) (fl.chain (fn.followRedirects (1)) (postResponse (301) (`${url}/echo`)))))\n                 ('hello'),\n  assertResolves (withTestServer (({url}) => fl.chain (fn.bufferResponse ('utf8')) (fl.chain (fn.followRedirects (1)) (postResponse (302) (`${url}/echo`)))))\n                 ('hello'),\n  assertResolves (withTestServer (({url}) => fl.chain (fn.bufferResponse ('utf8')) (fl.chain (fn.followRedirects (1)) (postResponse (303) (`${url}/echo`)))))\n                 ('GET/'),\n  assertResolves (withTestServer (({url}) => fl.chain (fn.bufferResponse ('utf8')) (fl.chain (fn.followRedirects (1)) (postResponse (304) (`${url}/echo`)))))\n                 ('hello'),\n  assertResolves (withTestServer (({url}) => fl.chain (fn.bufferResponse ('utf8')) (fl.chain (fn.followRedirects (1)) (postResponse (305) (`${url}/echo`)))))\n                 ('POST/test'),\n  assertResolves (withTestServer (({url}) => fl.chain (fn.bufferResponse ('utf8')) (fl.chain (fn.followRedirects (1)) (postResponse (307) (`${url}/echo`)))))\n                 ('hello'),\n]));\n\ntest ('autoBufferResponse', () => Promise.all ([\n  assertRejects (fl.chain (fn.autoBufferResponse) (mockResponse ({headers: {'content-type': 'text/plain; charset=lalalala'}})))\n                (new Error ('Failed to buffer response: Unknown encoding: lalalala')),\n  assertResolves (fl.chain (fn.autoBufferResponse) (sendMockRequest (fn.emptyStream)))\n                 ('GET/'),\n  assertResolves (fl.chain (fn.autoBufferResponse) (sendMockRequest (fn.streamOf (Buffer.from ('hello')))))\n                 ('GET/hello'),\n  assertResolves (fl.chain (fn.autoBufferResponse) (mockResponse ({})))\n                 ('hello'),\n  assertResolves (fl.chain (fn.autoBufferResponse) (mockResponse ({headers: {}})))\n                 ('hello'),\n  assertResolves (fl.chain (fn.autoBufferResponse) (mockResponse ({headers: {'content-type': 'text/plain; charset=hex'}})))\n                 ('68656c6c6f'),\n]));\n\nconst respond200 = mockResponse ({});\n\ntest ('matchStatus', () => Promise.all ([\n  assertResolves (fl.map (fn.matchStatus (() => 'else') ({200: () => '200', 201: () => '201'})) (mockResponse ({code: 400}))) ('else'),\n  assertResolves (fl.map (fn.matchStatus (() => 'else') ({200: () => '200', 201: () => '201'})) (mockResponse ({code: 200}))) ('200'),\n  assertResolves (fl.map (fn.matchStatus (() => 'else') ({200: () => '200', 201: () => '201'})) (mockResponse ({code: 201}))) ('201'),\n]));\n\ntest ('acceptStatus', () => Promise.all ([\n  assertResolves (fl.map (thenBuffer) (fl.map (fn.acceptStatus (200)) (respond200)))\n                 (fl.resolve ('hello')),\n  assertResolves (fl.map (thenBuffer) (fl.map (fn.acceptStatus (201)) (respond200)))\n                 (fl.reject ('hello')),\n]));\n\ntest ('responseToError', () => (\n  assertRejects (fl.chain (fn.responseToError) (mockResponse ({\n    code: 500,\n    message: 'Internal Server Error',\n    headers: responseHeaders,\n    body: Buffer.from ('Dear user,\\n\\nEverything broke down.\\nWe are sorry.'),\n  }))) (new Error (\n    'Unexpected Internal Server Error (500) response. Response body:\\n' +\n    '\\n' +\n    '  Dear user,\\n' +\n    '  \\n' +\n    '  Everything broke down.\\n' +\n    '  We are sorry.'\n  ))\n));\n\ntest ('HTTP Integration', () => {\n  const notFound = res => (\n    fl.chain (message => fl.reject (new Error (message))) (fn.autoBufferResponse (res))\n  );\n\n  const showResponse = res => (\n    fl.map (body => `${(fn.Response.message (res)).statusCode}: ${body}`)\n           (fn.autoBufferResponse (res))\n  );\n\n  const responseHandler = res => (\n    fn.followRedirects (20) (res)\n    .pipe (fl.chain (fn.matchStatus (fn.responseToError) ({200: showResponse, 404: notFound})))\n  );\n\n  const runTest = f => withTestServer (({url}) => fl.chain (responseHandler) (f (url)));\n\n  return Promise.all ([\n    assertResolves (runTest (url => fn.retrieve (`${url}/redirect`) ({})))\n                   ('200: GET/'),\n    assertRejects (runTest (url => fn.sendJson ('POST') (`${url}/redirect`) ({}) ('hello')))\n                  (new Error ('Unexpected Moved Permanently (301) response. Response body:\\n\\n  ')),\n    assertResolves (runTest (url => fn.sendJson ('POST') (`${url}/redirect-post`) ({}) ('hello')))\n                   ('200: POST/\"hello\"'),\n    assertRejects (runTest (url => fn.retrieve (`${url}/self-redirect`) ({})))\n                  (new Error ('Unexpected Moved Permanently (301) response. Response body:\\n\\n  ')),\n    assertRejects (runTest (url => fn.retrieve (`${url}/redirect-loop-a`) ({})))\n                  (new Error ('Unexpected Moved Permanently (301) response. Response body:\\n\\n  ')),\n  ]);\n});\n"], "filenames": ["index.js", "test/index.js"], "buggy_code_start_loc": [544, 286], "buggy_code_end_loc": [587, 286], "fixing_code_start_loc": [544, 287], "fixing_code_end_loc": [588, 292], "type": "CWE-601", "message": "Fluture-Node is a FP-style HTTP and streaming utils for Node based on Fluture. Using `followRedirects` or `followRedirectsWith` with any of the redirection strategies built into fluture-node 4.0.0 or 4.0.1, paired with a request that includes confidential headers such as Authorization or Cookie, exposes you to a vulnerability where, if the destination server were to redirect the request to a server on a third-party domain, or the same domain over unencrypted HTTP, the headers would be included in the follow-up request and be exposed to the third party, or potential http traffic sniffing. The redirection strategies made available in version 4.0.2 automatically redact confidential headers when a redirect is followed across to another origin. A workaround has been identified by using a custom redirection strategy via the `followRedirectsWith` function. The custom strategy can be based on the new strategies available in fluture-node@4.0.2.", "other": {"cve": {"id": "CVE-2022-24719", "sourceIdentifier": "security-advisories@github.com", "published": "2022-03-01T21:15:07.923", "lastModified": "2022-03-14T18:46:35.930", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Fluture-Node is a FP-style HTTP and streaming utils for Node based on Fluture. Using `followRedirects` or `followRedirectsWith` with any of the redirection strategies built into fluture-node 4.0.0 or 4.0.1, paired with a request that includes confidential headers such as Authorization or Cookie, exposes you to a vulnerability where, if the destination server were to redirect the request to a server on a third-party domain, or the same domain over unencrypted HTTP, the headers would be included in the follow-up request and be exposed to the third party, or potential http traffic sniffing. The redirection strategies made available in version 4.0.2 automatically redact confidential headers when a redirect is followed across to another origin. A workaround has been identified by using a custom redirection strategy via the `followRedirectsWith` function. The custom strategy can be based on the new strategies available in fluture-node@4.0.2."}, {"lang": "es", "value": "Fluture-Node es una utilidad HTTP y de streaming de estilo FP para Node basada en Fluture. Usando \"followRedirects\" o \"followRedirectsWith\" con cualquiera de las estrategias de redireccionamiento incorporadas en fluture-node versiones 4.0.0 o 4.0. 1, junto con una petici\u00f3n que incluya encabezados confidenciales como Authorization o Cookie, le expone a una vulnerabilidad en la que, si el servidor de destino redirigiera la petici\u00f3n a un servidor en un dominio de terceros, o al mismo dominio a trav\u00e9s de HTTP sin cifrar, los encabezados podr\u00edan ser incluidos en la petici\u00f3n de seguimiento y quedar\u00edan expuestas a terceros, o a un potencial husmeo del tr\u00e1fico http. Las estrategias de redireccionamiento disponibles en la versi\u00f3n 4.0.2 redactan autom\u00e1ticamente los encabezados confidenciales cuando es seguido un redireccionamiento a otro origen. Se ha identificado una medida de mitigaci\u00f3n mediante el uso de una estrategia de redireccionamiento personalizada por medio de la funci\u00f3n \"followRedirectsWith\". La estrategia personalizada puede basarse en las nuevas estrategias disponibles en fluture-node@4.0.2."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:H/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.6, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-359"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fluture-node_project:fluture-node:4.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "45C6924D-F90A-4129-AF75-420DF6FB9A5F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fluture-node_project:fluture-node:4.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "7C01C43F-7542-4990-8644-E70043810F16"}]}]}], "references": [{"url": "https://github.com/fluture-js/fluture-node/commit/0c99bc511533d48be17dc6bfe641f7d0aeb34d77", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/fluture-js/fluture-node/commit/125e4474f910c1507f8ec3232848626fbc0f55c4", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/fluture-js/fluture-node/security/advisories/GHSA-32x6-qvw6-mxj4", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/psf/requests/pull/4718", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/fluture-js/fluture-node/commit/0c99bc511533d48be17dc6bfe641f7d0aeb34d77"}}