{"buggy_code": ["/* Key garbage collector\n *\n * Copyright (C) 2009-2011 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public Licence\n * as published by the Free Software Foundation; either version\n * 2 of the Licence, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <keys/keyring-type.h>\n#include \"internal.h\"\n\n/*\n * Delay between key revocation/expiry in seconds\n */\nunsigned key_gc_delay = 5 * 60;\n\n/*\n * Reaper for unused keys.\n */\nstatic void key_garbage_collector(struct work_struct *work);\nDECLARE_WORK(key_gc_work, key_garbage_collector);\n\n/*\n * Reaper for links from keyrings to dead keys.\n */\nstatic void key_gc_timer_func(unsigned long);\nstatic DEFINE_TIMER(key_gc_timer, key_gc_timer_func, 0, 0);\n\nstatic time_t key_gc_next_run = LONG_MAX;\nstatic struct key_type *key_gc_dead_keytype;\n\nstatic unsigned long key_gc_flags;\n#define KEY_GC_KEY_EXPIRED\t0\t/* A key expired and needs unlinking */\n#define KEY_GC_REAP_KEYTYPE\t1\t/* A keytype is being unregistered */\n#define KEY_GC_REAPING_KEYTYPE\t2\t/* Cleared when keytype reaped */\n\n\n/*\n * Any key whose type gets unregistered will be re-typed to this if it can't be\n * immediately unlinked.\n */\nstruct key_type key_type_dead = {\n\t.name = \"dead\",\n};\n\n/*\n * Schedule a garbage collection run.\n * - time precision isn't particularly important\n */\nvoid key_schedule_gc(time_t gc_at)\n{\n\tunsigned long expires;\n\ttime_t now = current_kernel_time().tv_sec;\n\n\tkenter(\"%ld\", gc_at - now);\n\n\tif (gc_at <= now || test_bit(KEY_GC_REAP_KEYTYPE, &key_gc_flags)) {\n\t\tkdebug(\"IMMEDIATE\");\n\t\tschedule_work(&key_gc_work);\n\t} else if (gc_at < key_gc_next_run) {\n\t\tkdebug(\"DEFERRED\");\n\t\tkey_gc_next_run = gc_at;\n\t\texpires = jiffies + (gc_at - now) * HZ;\n\t\tmod_timer(&key_gc_timer, expires);\n\t}\n}\n\n/*\n * Schedule a dead links collection run.\n */\nvoid key_schedule_gc_links(void)\n{\n\tset_bit(KEY_GC_KEY_EXPIRED, &key_gc_flags);\n\tschedule_work(&key_gc_work);\n}\n\n/*\n * Some key's cleanup time was met after it expired, so we need to get the\n * reaper to go through a cycle finding expired keys.\n */\nstatic void key_gc_timer_func(unsigned long data)\n{\n\tkenter(\"\");\n\tkey_gc_next_run = LONG_MAX;\n\tkey_schedule_gc_links();\n}\n\n/*\n * Reap keys of dead type.\n *\n * We use three flags to make sure we see three complete cycles of the garbage\n * collector: the first to mark keys of that type as being dead, the second to\n * collect dead links and the third to clean up the dead keys.  We have to be\n * careful as there may already be a cycle in progress.\n *\n * The caller must be holding key_types_sem.\n */\nvoid key_gc_keytype(struct key_type *ktype)\n{\n\tkenter(\"%s\", ktype->name);\n\n\tkey_gc_dead_keytype = ktype;\n\tset_bit(KEY_GC_REAPING_KEYTYPE, &key_gc_flags);\n\tsmp_mb();\n\tset_bit(KEY_GC_REAP_KEYTYPE, &key_gc_flags);\n\n\tkdebug(\"schedule\");\n\tschedule_work(&key_gc_work);\n\n\tkdebug(\"sleep\");\n\twait_on_bit(&key_gc_flags, KEY_GC_REAPING_KEYTYPE,\n\t\t    TASK_UNINTERRUPTIBLE);\n\n\tkey_gc_dead_keytype = NULL;\n\tkleave(\"\");\n}\n\n/*\n * Garbage collect a list of unreferenced, detached keys\n */\nstatic noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\n\t\tsecurity_key_free(key);\n\n\t\t/* deal with the user's key tracking and quota */\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\t\tatomic_dec(&key->user->nikeys);\n\n\t\tkey_user_put(key->user);\n\n\t\t/* now throw away the key memory */\n\t\tif (key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\n\t\tkfree(key->description);\n\n#ifdef KEY_DEBUGGING\n\t\tkey->magic = KEY_DEBUG_MAGIC_X;\n#endif\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}\n\n/*\n * Garbage collector for unused keys.\n *\n * This is done in process context so that we don't have to disable interrupts\n * all over the place.  key_put() schedules this rather than trying to do the\n * cleanup itself, which means key_put() doesn't have to sleep.\n */\nstatic void key_garbage_collector(struct work_struct *work)\n{\n\tstatic LIST_HEAD(graveyard);\n\tstatic u8 gc_state;\t\t/* Internal persistent state */\n#define KEY_GC_REAP_AGAIN\t0x01\t/* - Need another cycle */\n#define KEY_GC_REAPING_LINKS\t0x02\t/* - We need to reap links */\n#define KEY_GC_SET_TIMER\t0x04\t/* - We need to restart the timer */\n#define KEY_GC_REAPING_DEAD_1\t0x10\t/* - We need to mark dead keys */\n#define KEY_GC_REAPING_DEAD_2\t0x20\t/* - We need to reap dead key links */\n#define KEY_GC_REAPING_DEAD_3\t0x40\t/* - We need to reap dead keys */\n#define KEY_GC_FOUND_DEAD_KEY\t0x80\t/* - We found at least one dead key */\n\n\tstruct rb_node *cursor;\n\tstruct key *key;\n\ttime_t new_timer, limit;\n\n\tkenter(\"[%lx,%x]\", key_gc_flags, gc_state);\n\n\tlimit = current_kernel_time().tv_sec;\n\tif (limit > key_gc_delay)\n\t\tlimit -= key_gc_delay;\n\telse\n\t\tlimit = key_gc_delay;\n\n\t/* Work out what we're going to be doing in this pass */\n\tgc_state &= KEY_GC_REAPING_DEAD_1 | KEY_GC_REAPING_DEAD_2;\n\tgc_state <<= 1;\n\tif (test_and_clear_bit(KEY_GC_KEY_EXPIRED, &key_gc_flags))\n\t\tgc_state |= KEY_GC_REAPING_LINKS | KEY_GC_SET_TIMER;\n\n\tif (test_and_clear_bit(KEY_GC_REAP_KEYTYPE, &key_gc_flags))\n\t\tgc_state |= KEY_GC_REAPING_DEAD_1;\n\tkdebug(\"new pass %x\", gc_state);\n\n\tnew_timer = LONG_MAX;\n\n\t/* As only this function is permitted to remove things from the key\n\t * serial tree, if cursor is non-NULL then it will always point to a\n\t * valid node in the tree - even if lock got dropped.\n\t */\n\tspin_lock(&key_serial_lock);\n\tcursor = rb_first(&key_serial_tree);\n\ncontinue_scanning:\n\twhile (cursor) {\n\t\tkey = rb_entry(cursor, struct key, serial_node);\n\t\tcursor = rb_next(cursor);\n\n\t\tif (atomic_read(&key->usage) == 0)\n\t\t\tgoto found_unreferenced_key;\n\n\t\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_1)) {\n\t\t\tif (key->type == key_gc_dead_keytype) {\n\t\t\t\tgc_state |= KEY_GC_FOUND_DEAD_KEY;\n\t\t\t\tset_bit(KEY_FLAG_DEAD, &key->flags);\n\t\t\t\tkey->perm = 0;\n\t\t\t\tgoto skip_dead_key;\n\t\t\t}\n\t\t}\n\n\t\tif (gc_state & KEY_GC_SET_TIMER) {\n\t\t\tif (key->expiry > limit && key->expiry < new_timer) {\n\t\t\t\tkdebug(\"will expire %x in %ld\",\n\t\t\t\t       key_serial(key), key->expiry - limit);\n\t\t\t\tnew_timer = key->expiry;\n\t\t\t}\n\t\t}\n\n\t\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_2))\n\t\t\tif (key->type == key_gc_dead_keytype)\n\t\t\t\tgc_state |= KEY_GC_FOUND_DEAD_KEY;\n\n\t\tif ((gc_state & KEY_GC_REAPING_LINKS) ||\n\t\t    unlikely(gc_state & KEY_GC_REAPING_DEAD_2)) {\n\t\t\tif (key->type == &key_type_keyring)\n\t\t\t\tgoto found_keyring;\n\t\t}\n\n\t\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_3))\n\t\t\tif (key->type == key_gc_dead_keytype)\n\t\t\t\tgoto destroy_dead_key;\n\n\tskip_dead_key:\n\t\tif (spin_is_contended(&key_serial_lock) || need_resched())\n\t\t\tgoto contended;\n\t}\n\ncontended:\n\tspin_unlock(&key_serial_lock);\n\nmaybe_resched:\n\tif (cursor) {\n\t\tcond_resched();\n\t\tspin_lock(&key_serial_lock);\n\t\tgoto continue_scanning;\n\t}\n\n\t/* We've completed the pass.  Set the timer if we need to and queue a\n\t * new cycle if necessary.  We keep executing cycles until we find one\n\t * where we didn't reap any keys.\n\t */\n\tkdebug(\"pass complete\");\n\n\tif (gc_state & KEY_GC_SET_TIMER && new_timer != (time_t)LONG_MAX) {\n\t\tnew_timer += key_gc_delay;\n\t\tkey_schedule_gc(new_timer);\n\t}\n\n\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_2) ||\n\t    !list_empty(&graveyard)) {\n\t\t/* Make sure that all pending keyring payload destructions are\n\t\t * fulfilled and that people aren't now looking at dead or\n\t\t * dying keys that they don't have a reference upon or a link\n\t\t * to.\n\t\t */\n\t\tkdebug(\"gc sync\");\n\t\tsynchronize_rcu();\n\t}\n\n\tif (!list_empty(&graveyard)) {\n\t\tkdebug(\"gc keys\");\n\t\tkey_gc_unused_keys(&graveyard);\n\t}\n\n\tif (unlikely(gc_state & (KEY_GC_REAPING_DEAD_1 |\n\t\t\t\t KEY_GC_REAPING_DEAD_2))) {\n\t\tif (!(gc_state & KEY_GC_FOUND_DEAD_KEY)) {\n\t\t\t/* No remaining dead keys: short circuit the remaining\n\t\t\t * keytype reap cycles.\n\t\t\t */\n\t\t\tkdebug(\"dead short\");\n\t\t\tgc_state &= ~(KEY_GC_REAPING_DEAD_1 | KEY_GC_REAPING_DEAD_2);\n\t\t\tgc_state |= KEY_GC_REAPING_DEAD_3;\n\t\t} else {\n\t\t\tgc_state |= KEY_GC_REAP_AGAIN;\n\t\t}\n\t}\n\n\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_3)) {\n\t\tkdebug(\"dead wake\");\n\t\tsmp_mb();\n\t\tclear_bit(KEY_GC_REAPING_KEYTYPE, &key_gc_flags);\n\t\twake_up_bit(&key_gc_flags, KEY_GC_REAPING_KEYTYPE);\n\t}\n\n\tif (gc_state & KEY_GC_REAP_AGAIN)\n\t\tschedule_work(&key_gc_work);\n\tkleave(\" [end %x]\", gc_state);\n\treturn;\n\n\t/* We found an unreferenced key - once we've removed it from the tree,\n\t * we can safely drop the lock.\n\t */\nfound_unreferenced_key:\n\tkdebug(\"unrefd key %d\", key->serial);\n\trb_erase(&key->serial_node, &key_serial_tree);\n\tspin_unlock(&key_serial_lock);\n\n\tlist_add_tail(&key->graveyard_link, &graveyard);\n\tgc_state |= KEY_GC_REAP_AGAIN;\n\tgoto maybe_resched;\n\n\t/* We found a keyring and we need to check the payload for links to\n\t * dead or expired keys.  We don't flag another reap immediately as we\n\t * have to wait for the old payload to be destroyed by RCU before we\n\t * can reap the keys to which it refers.\n\t */\nfound_keyring:\n\tspin_unlock(&key_serial_lock);\n\tkeyring_gc(key, limit);\n\tgoto maybe_resched;\n\n\t/* We found a dead key that is still referenced.  Reset its type and\n\t * destroy its payload with its semaphore held.\n\t */\ndestroy_dead_key:\n\tspin_unlock(&key_serial_lock);\n\tkdebug(\"destroy key %d\", key->serial);\n\tdown_write(&key->sem);\n\tkey->type = &key_type_dead;\n\tif (key_gc_dead_keytype->destroy)\n\t\tkey_gc_dead_keytype->destroy(key);\n\tmemset(&key->payload, KEY_DESTROY, sizeof(key->payload));\n\tup_write(&key->sem);\n\tgoto maybe_resched;\n}\n"], "fixing_code": ["/* Key garbage collector\n *\n * Copyright (C) 2009-2011 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public Licence\n * as published by the Free Software Foundation; either version\n * 2 of the Licence, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <keys/keyring-type.h>\n#include \"internal.h\"\n\n/*\n * Delay between key revocation/expiry in seconds\n */\nunsigned key_gc_delay = 5 * 60;\n\n/*\n * Reaper for unused keys.\n */\nstatic void key_garbage_collector(struct work_struct *work);\nDECLARE_WORK(key_gc_work, key_garbage_collector);\n\n/*\n * Reaper for links from keyrings to dead keys.\n */\nstatic void key_gc_timer_func(unsigned long);\nstatic DEFINE_TIMER(key_gc_timer, key_gc_timer_func, 0, 0);\n\nstatic time_t key_gc_next_run = LONG_MAX;\nstatic struct key_type *key_gc_dead_keytype;\n\nstatic unsigned long key_gc_flags;\n#define KEY_GC_KEY_EXPIRED\t0\t/* A key expired and needs unlinking */\n#define KEY_GC_REAP_KEYTYPE\t1\t/* A keytype is being unregistered */\n#define KEY_GC_REAPING_KEYTYPE\t2\t/* Cleared when keytype reaped */\n\n\n/*\n * Any key whose type gets unregistered will be re-typed to this if it can't be\n * immediately unlinked.\n */\nstruct key_type key_type_dead = {\n\t.name = \"dead\",\n};\n\n/*\n * Schedule a garbage collection run.\n * - time precision isn't particularly important\n */\nvoid key_schedule_gc(time_t gc_at)\n{\n\tunsigned long expires;\n\ttime_t now = current_kernel_time().tv_sec;\n\n\tkenter(\"%ld\", gc_at - now);\n\n\tif (gc_at <= now || test_bit(KEY_GC_REAP_KEYTYPE, &key_gc_flags)) {\n\t\tkdebug(\"IMMEDIATE\");\n\t\tschedule_work(&key_gc_work);\n\t} else if (gc_at < key_gc_next_run) {\n\t\tkdebug(\"DEFERRED\");\n\t\tkey_gc_next_run = gc_at;\n\t\texpires = jiffies + (gc_at - now) * HZ;\n\t\tmod_timer(&key_gc_timer, expires);\n\t}\n}\n\n/*\n * Schedule a dead links collection run.\n */\nvoid key_schedule_gc_links(void)\n{\n\tset_bit(KEY_GC_KEY_EXPIRED, &key_gc_flags);\n\tschedule_work(&key_gc_work);\n}\n\n/*\n * Some key's cleanup time was met after it expired, so we need to get the\n * reaper to go through a cycle finding expired keys.\n */\nstatic void key_gc_timer_func(unsigned long data)\n{\n\tkenter(\"\");\n\tkey_gc_next_run = LONG_MAX;\n\tkey_schedule_gc_links();\n}\n\n/*\n * Reap keys of dead type.\n *\n * We use three flags to make sure we see three complete cycles of the garbage\n * collector: the first to mark keys of that type as being dead, the second to\n * collect dead links and the third to clean up the dead keys.  We have to be\n * careful as there may already be a cycle in progress.\n *\n * The caller must be holding key_types_sem.\n */\nvoid key_gc_keytype(struct key_type *ktype)\n{\n\tkenter(\"%s\", ktype->name);\n\n\tkey_gc_dead_keytype = ktype;\n\tset_bit(KEY_GC_REAPING_KEYTYPE, &key_gc_flags);\n\tsmp_mb();\n\tset_bit(KEY_GC_REAP_KEYTYPE, &key_gc_flags);\n\n\tkdebug(\"schedule\");\n\tschedule_work(&key_gc_work);\n\n\tkdebug(\"sleep\");\n\twait_on_bit(&key_gc_flags, KEY_GC_REAPING_KEYTYPE,\n\t\t    TASK_UNINTERRUPTIBLE);\n\n\tkey_gc_dead_keytype = NULL;\n\tkleave(\"\");\n}\n\n/*\n * Garbage collect a list of unreferenced, detached keys\n */\nstatic noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\n\t\tsecurity_key_free(key);\n\n\t\t/* deal with the user's key tracking and quota */\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\t\tatomic_dec(&key->user->nikeys);\n\n\t\t/* now throw away the key memory */\n\t\tif (key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\n\t\tkey_user_put(key->user);\n\n\t\tkfree(key->description);\n\n#ifdef KEY_DEBUGGING\n\t\tkey->magic = KEY_DEBUG_MAGIC_X;\n#endif\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}\n\n/*\n * Garbage collector for unused keys.\n *\n * This is done in process context so that we don't have to disable interrupts\n * all over the place.  key_put() schedules this rather than trying to do the\n * cleanup itself, which means key_put() doesn't have to sleep.\n */\nstatic void key_garbage_collector(struct work_struct *work)\n{\n\tstatic LIST_HEAD(graveyard);\n\tstatic u8 gc_state;\t\t/* Internal persistent state */\n#define KEY_GC_REAP_AGAIN\t0x01\t/* - Need another cycle */\n#define KEY_GC_REAPING_LINKS\t0x02\t/* - We need to reap links */\n#define KEY_GC_SET_TIMER\t0x04\t/* - We need to restart the timer */\n#define KEY_GC_REAPING_DEAD_1\t0x10\t/* - We need to mark dead keys */\n#define KEY_GC_REAPING_DEAD_2\t0x20\t/* - We need to reap dead key links */\n#define KEY_GC_REAPING_DEAD_3\t0x40\t/* - We need to reap dead keys */\n#define KEY_GC_FOUND_DEAD_KEY\t0x80\t/* - We found at least one dead key */\n\n\tstruct rb_node *cursor;\n\tstruct key *key;\n\ttime_t new_timer, limit;\n\n\tkenter(\"[%lx,%x]\", key_gc_flags, gc_state);\n\n\tlimit = current_kernel_time().tv_sec;\n\tif (limit > key_gc_delay)\n\t\tlimit -= key_gc_delay;\n\telse\n\t\tlimit = key_gc_delay;\n\n\t/* Work out what we're going to be doing in this pass */\n\tgc_state &= KEY_GC_REAPING_DEAD_1 | KEY_GC_REAPING_DEAD_2;\n\tgc_state <<= 1;\n\tif (test_and_clear_bit(KEY_GC_KEY_EXPIRED, &key_gc_flags))\n\t\tgc_state |= KEY_GC_REAPING_LINKS | KEY_GC_SET_TIMER;\n\n\tif (test_and_clear_bit(KEY_GC_REAP_KEYTYPE, &key_gc_flags))\n\t\tgc_state |= KEY_GC_REAPING_DEAD_1;\n\tkdebug(\"new pass %x\", gc_state);\n\n\tnew_timer = LONG_MAX;\n\n\t/* As only this function is permitted to remove things from the key\n\t * serial tree, if cursor is non-NULL then it will always point to a\n\t * valid node in the tree - even if lock got dropped.\n\t */\n\tspin_lock(&key_serial_lock);\n\tcursor = rb_first(&key_serial_tree);\n\ncontinue_scanning:\n\twhile (cursor) {\n\t\tkey = rb_entry(cursor, struct key, serial_node);\n\t\tcursor = rb_next(cursor);\n\n\t\tif (atomic_read(&key->usage) == 0)\n\t\t\tgoto found_unreferenced_key;\n\n\t\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_1)) {\n\t\t\tif (key->type == key_gc_dead_keytype) {\n\t\t\t\tgc_state |= KEY_GC_FOUND_DEAD_KEY;\n\t\t\t\tset_bit(KEY_FLAG_DEAD, &key->flags);\n\t\t\t\tkey->perm = 0;\n\t\t\t\tgoto skip_dead_key;\n\t\t\t}\n\t\t}\n\n\t\tif (gc_state & KEY_GC_SET_TIMER) {\n\t\t\tif (key->expiry > limit && key->expiry < new_timer) {\n\t\t\t\tkdebug(\"will expire %x in %ld\",\n\t\t\t\t       key_serial(key), key->expiry - limit);\n\t\t\t\tnew_timer = key->expiry;\n\t\t\t}\n\t\t}\n\n\t\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_2))\n\t\t\tif (key->type == key_gc_dead_keytype)\n\t\t\t\tgc_state |= KEY_GC_FOUND_DEAD_KEY;\n\n\t\tif ((gc_state & KEY_GC_REAPING_LINKS) ||\n\t\t    unlikely(gc_state & KEY_GC_REAPING_DEAD_2)) {\n\t\t\tif (key->type == &key_type_keyring)\n\t\t\t\tgoto found_keyring;\n\t\t}\n\n\t\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_3))\n\t\t\tif (key->type == key_gc_dead_keytype)\n\t\t\t\tgoto destroy_dead_key;\n\n\tskip_dead_key:\n\t\tif (spin_is_contended(&key_serial_lock) || need_resched())\n\t\t\tgoto contended;\n\t}\n\ncontended:\n\tspin_unlock(&key_serial_lock);\n\nmaybe_resched:\n\tif (cursor) {\n\t\tcond_resched();\n\t\tspin_lock(&key_serial_lock);\n\t\tgoto continue_scanning;\n\t}\n\n\t/* We've completed the pass.  Set the timer if we need to and queue a\n\t * new cycle if necessary.  We keep executing cycles until we find one\n\t * where we didn't reap any keys.\n\t */\n\tkdebug(\"pass complete\");\n\n\tif (gc_state & KEY_GC_SET_TIMER && new_timer != (time_t)LONG_MAX) {\n\t\tnew_timer += key_gc_delay;\n\t\tkey_schedule_gc(new_timer);\n\t}\n\n\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_2) ||\n\t    !list_empty(&graveyard)) {\n\t\t/* Make sure that all pending keyring payload destructions are\n\t\t * fulfilled and that people aren't now looking at dead or\n\t\t * dying keys that they don't have a reference upon or a link\n\t\t * to.\n\t\t */\n\t\tkdebug(\"gc sync\");\n\t\tsynchronize_rcu();\n\t}\n\n\tif (!list_empty(&graveyard)) {\n\t\tkdebug(\"gc keys\");\n\t\tkey_gc_unused_keys(&graveyard);\n\t}\n\n\tif (unlikely(gc_state & (KEY_GC_REAPING_DEAD_1 |\n\t\t\t\t KEY_GC_REAPING_DEAD_2))) {\n\t\tif (!(gc_state & KEY_GC_FOUND_DEAD_KEY)) {\n\t\t\t/* No remaining dead keys: short circuit the remaining\n\t\t\t * keytype reap cycles.\n\t\t\t */\n\t\t\tkdebug(\"dead short\");\n\t\t\tgc_state &= ~(KEY_GC_REAPING_DEAD_1 | KEY_GC_REAPING_DEAD_2);\n\t\t\tgc_state |= KEY_GC_REAPING_DEAD_3;\n\t\t} else {\n\t\t\tgc_state |= KEY_GC_REAP_AGAIN;\n\t\t}\n\t}\n\n\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_3)) {\n\t\tkdebug(\"dead wake\");\n\t\tsmp_mb();\n\t\tclear_bit(KEY_GC_REAPING_KEYTYPE, &key_gc_flags);\n\t\twake_up_bit(&key_gc_flags, KEY_GC_REAPING_KEYTYPE);\n\t}\n\n\tif (gc_state & KEY_GC_REAP_AGAIN)\n\t\tschedule_work(&key_gc_work);\n\tkleave(\" [end %x]\", gc_state);\n\treturn;\n\n\t/* We found an unreferenced key - once we've removed it from the tree,\n\t * we can safely drop the lock.\n\t */\nfound_unreferenced_key:\n\tkdebug(\"unrefd key %d\", key->serial);\n\trb_erase(&key->serial_node, &key_serial_tree);\n\tspin_unlock(&key_serial_lock);\n\n\tlist_add_tail(&key->graveyard_link, &graveyard);\n\tgc_state |= KEY_GC_REAP_AGAIN;\n\tgoto maybe_resched;\n\n\t/* We found a keyring and we need to check the payload for links to\n\t * dead or expired keys.  We don't flag another reap immediately as we\n\t * have to wait for the old payload to be destroyed by RCU before we\n\t * can reap the keys to which it refers.\n\t */\nfound_keyring:\n\tspin_unlock(&key_serial_lock);\n\tkeyring_gc(key, limit);\n\tgoto maybe_resched;\n\n\t/* We found a dead key that is still referenced.  Reset its type and\n\t * destroy its payload with its semaphore held.\n\t */\ndestroy_dead_key:\n\tspin_unlock(&key_serial_lock);\n\tkdebug(\"destroy key %d\", key->serial);\n\tdown_write(&key->sem);\n\tkey->type = &key_type_dead;\n\tif (key_gc_dead_keytype->destroy)\n\t\tkey_gc_dead_keytype->destroy(key);\n\tmemset(&key->payload, KEY_DESTROY, sizeof(key->payload));\n\tup_write(&key->sem);\n\tgoto maybe_resched;\n}\n"], "filenames": ["security/keys/gc.c"], "buggy_code_start_loc": [151], "buggy_code_end_loc": [155], "fixing_code_start_loc": [150], "fixing_code_end_loc": [156], "type": "CWE-362", "message": "Race condition in the key_gc_unused_keys function in security/keys/gc.c in the Linux kernel through 3.18.2 allows local users to cause a denial of service (memory corruption or panic) or possibly have unspecified other impact via keyctl commands that trigger access to a key structure member during garbage collection of a key.", "other": {"cve": {"id": "CVE-2014-9529", "sourceIdentifier": "cve@mitre.org", "published": "2015-01-09T21:59:00.050", "lastModified": "2020-05-21T17:41:56.260", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Race condition in the key_gc_unused_keys function in security/keys/gc.c in the Linux kernel through 3.18.2 allows local users to cause a denial of service (memory corruption or panic) or possibly have unspecified other impact via keyctl commands that trigger access to a key structure member during garbage collection of a key."}, {"lang": "es", "value": "Condici\u00f3n de carrera en la funci\u00f3n key_gc_unused_keys en security/keys/gc.c en el kernel de Linux hasta 3.18.2 permite a usuarios locales causar una denegaci\u00f3n de servicio (corrupci\u00f3n de memoria o p\u00e1nico) o posiblemente tener otro impacto no especificado a trav\u00e9s de comandos keyctl que provocan el acceso a un miembro de la estructura clave durante la recogida de basura de una clave."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.18.2", "matchCriteriaId": "6BEF22F9-77C0-4CCB-92B9-8F09C220BFB8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "EE249E1B-A1FD-4E08-AA71-A0E1F10FFE97"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "9BBCD86A-E6C7-4444-9D74-F861084090F0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:6.6:*:*:*:*:*:*:*", "matchCriteriaId": "16E6D998-B41D-4B49-9E00-8336D2E40A4A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "98381E61-F082-4302-B51F-5648884F998B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "D99A687E-EAE6-417E-A88E-D0082BC194CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B353CE99-D57C-465B-AAB0-73EF581127D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "7431ABC1-9252-419E-8CC1-311B41360078"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:6.6:*:*:*:*:*:*:*", "matchCriteriaId": "C18E3368-8980-45D2-AD3F-5BF385ABA693"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.1:*:*:*:*:*:*:*", "matchCriteriaId": "0E8CD4EF-DC90-40BB-A721-6EC087507906"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.2:*:*:*:*:*:*:*", "matchCriteriaId": "44B067C7-735E-43C9-9188-7E1522A02491"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "A8442C20-41F9-47FD-9A12-E724D3A31FD7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "9EC0D196-F7B8-4BDD-9050-779F7A7FBEE4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.5:*:*:*:*:*:*:*", "matchCriteriaId": "A4E9DD8A-A68B-4A69-8B01-BFF92A2020A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "BF77CDCF-B9C9-427D-B2BF-36650FB2148C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "21690BAC-2129-4A33-9B48-1F3BF30072A9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:6.6:*:*:*:*:*:*:*", "matchCriteriaId": "13E02156-E748-4820-B76F-7074793837E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "24C0F4E1-C52C-41E0-9F14-F83ADD5CC7ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B76AA310-FEC7-497F-AF04-C3EC1E76C4CC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "17F256A9-D3B9-4C72-B013-4EFD878BFEA8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "E5ED5807-55B7-47C5-97A6-03233F4FBC3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.1:*:*:*:*:*:*:*", "matchCriteriaId": "A10BC294-9196-425F-9FB0-B1625465B47F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:20:*:*:*:*:*:*:*", "matchCriteriaId": "FF47C9F0-D8DA-4B55-89EB-9B2C9383ADB9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:21:*:*:*:*:*:*:*", "matchCriteriaId": "56BDB5A0-0839-4A20-A003-B8CD56F48171"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:10.04:*:*:*:lts:*:*:*", "matchCriteriaId": "5D37DF0F-F863-45AC-853A-3E04F9FEC7CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B6B7CAD7-9D4E-4FDB-88E3-1E583210A01F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.10:*:*:*:*:*:*:*", "matchCriteriaId": "49A63F39-30BE-443F-AF10-6245587D3359"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=a3a8784454692dd72e5d5d34dcdab17b4420e74c", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-January/147864.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-January/147973.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-04/msg00009.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-0864.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-1137.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-1138.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2015/dsa-3128", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.mandriva.com/security/advisories?name=MDVSA-2015:058", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2015/01/06/10", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/71880", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1036763", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.ubuntu.com/usn/USN-2511-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2512-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2513-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2514-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2515-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2516-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2517-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2518-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1179813", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/99641", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/a3a8784454692dd72e5d5d34dcdab17b4420e74c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/a3a8784454692dd72e5d5d34dcdab17b4420e74c"}}