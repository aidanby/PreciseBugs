{"buggy_code": ["defmodule Phoenix.Socket.Transport do\n  @moduledoc \"\"\"\n  Outlines the Socket <-> Transport communication.\n\n  This module specifies a behaviour that all sockets must implement.\n  `Phoenix.Socket` is just one possible implementation of a socket\n  that multiplexes events over multiple channels. Developers can\n  implement their own sockets as long as they implement the behaviour\n  outlined here.\n\n  Developers interested in implementing custom transports must invoke\n  the socket API defined in this module. This module also provides\n  many conveniences that invokes the underlying socket API to make\n  it easier to build custom transports.\n\n  ## Booting sockets\n\n  Whenever your endpoint starts, it will automatically invoke the\n  `child_spec/1` on each listed socket and start that specification\n  under the endpoint supervisor.\n\n  Since the socket supervision tree is started by the endpoint,\n  any custom transport must be started after the endpoint in a\n  supervision tree.\n\n  ## Operating sockets\n\n  Sockets are operated by a transport. When a transport is defined,\n  it usually receives a socket module and the module will be invoked\n  when certain events happen at the transport level.\n\n  Whenever the transport receives a new connection, it should invoke\n  the `c:connect/1` callback with a map of metadata. Different sockets\n  may require different metadata.\n\n  If the connection is accepted, the transport can move the connection\n  to another process, if so desires, or keep using the same process. The\n  process responsible for managing the socket should then call `c:init/1`.\n\n  For each message received from the client, the transport must call\n  `c:handle_in/2` on the socket. For each informational message the\n  transport receives, it should call `c:handle_info/2` on the socket.\n\n  Transports can optionally implement `c:handle_control/2` for handling\n  control frames such as `:ping` and `:pong`.\n\n  On termination, `c:terminate/2` must be called. A special atom with\n  reason `:closed` can be used to specify that the client terminated\n  the connection.\n\n  ## Example\n\n  Here is a simple echo socket implementation:\n\n      defmodule EchoSocket do\n        @behaviour Phoenix.Socket.Transport\n\n        def child_spec(opts) do\n          # We won't spawn any process, so let's return a dummy task\n          %{id: __MODULE__, start: {Task, :start_link, [fn -> :ok end]}, restart: :transient}\n        end\n\n        def connect(state) do\n          # Callback to retrieve relevant data from the connection.\n          # The map contains options, params, transport and endpoint keys.\n          {:ok, state}\n        end\n\n        def init(state) do\n          # Now we are effectively inside the process that maintains the socket.\n          {:ok, state}\n        end\n\n        def handle_in({text, _opts}, state) do\n          {:reply, :ok, {:text, text}, state}\n        end\n\n        def handle_info(_, state) do\n          {:ok, state}\n        end\n\n        def terminate(_reason, _state) do\n          :ok\n        end\n      end\n\n  It can be mounted in your endpoint like any other socket:\n\n      socket \"/socket\", EchoSocket, websocket: true, longpoll: true\n\n  You can now interact with the socket under `/socket/websocket`\n  and `/socket/longpoll`.\n\n  ## Security\n\n  This module also provides functions to enable a secure environment\n  on transports that, at some point, have access to a `Plug.Conn`.\n\n  The functionality provided by this module helps in performing \"origin\"\n  header checks and ensuring only SSL connections are allowed.\n  \"\"\"\n\n  @type state :: term()\n\n  @doc \"\"\"\n  Returns a child specification for socket management.\n\n  This is invoked only once per socket regardless of\n  the number of transports and should be responsible\n  for setting up any process structure used exclusively\n  by the socket regardless of transports.\n\n  Each socket connection is started by the transport\n  and the process that controls the socket likely\n  belongs to the transport. However, some sockets spawn\n  new processes, such as `Phoenix.Socket` which spawns\n  channels, and this gives the ability to start a\n  supervision tree associated to the socket.\n\n  It receives the socket options from the endpoint,\n  for example:\n\n      socket \"/my_app\", MyApp.Socket, shutdown: 5000\n\n  means `child_spec([shutdown: 5000])` will be invoked.\n  \"\"\"\n  @callback child_spec(keyword) :: :supervisor.child_spec\n\n  @doc \"\"\"\n  Connects to the socket.\n\n  The transport passes a map of metadata and the socket\n  returns `{:ok, state}` or `:error`. The state must be\n  stored by the transport and returned in all future\n  operations.\n\n  This function is used for authorization purposes and it\n  may be invoked outside of the process that effectively\n  runs the socket.\n\n  In the default `Phoenix.Socket` implementation, the\n  metadata expects the following keys:\n\n    * `:endpoint` - the application endpoint\n    * `:transport` - the transport name\n    * `:params` - the connection parameters\n    * `:options` - a keyword list of transport options, often\n      given by developers when configuring the transport.\n      It must include a `:serializer` field with the list of\n      serializers and their requirements\n\n  \"\"\"\n  @callback connect(transport_info :: map) :: {:ok, state} | :error\n\n  @doc \"\"\"\n  Initializes the socket state.\n\n  This must be executed from the process that will effectively\n  operate the socket.\n  \"\"\"\n  @callback init(state) :: {:ok, state}\n\n  @doc \"\"\"\n  Handles incoming socket messages.\n\n  The message is represented as `{payload, options}`. It must\n  return one of:\n\n    * `{:ok, state}` - continues the socket with no reply\n    * `{:reply, status, reply, state}` - continues the socket with reply\n    * `{:stop, reason, state}` - stops the socket\n\n  The `reply` is a tuple contain an `opcode` atom and a message that can\n  be any term. The built-in websocket transport supports both `:text` and\n  `:binary` opcode and the message must be always iodata. Long polling only\n  supports text opcode.\n  \"\"\"\n  @callback handle_in({message :: term, opts :: keyword}, state) ::\n              {:ok, state}\n              | {:reply, :ok | :error, {opcode :: atom, message :: term}, state}\n              | {:stop, reason :: term, state}\n\n  @doc \"\"\"\n  Handles incoming control frames.\n\n  The message is represented as `{payload, options}`. It must\n  return one of:\n\n    * `{:ok, state}` - continues the socket with no reply\n    * `{:reply, status, reply, state}` - continues the socket with reply\n    * `{:stop, reason, state}` - stops the socket\n\n  Control frames only supported when using websockets.\n\n  The `options` contains an `opcode` key, this will be either `:ping` or\n  `:pong`.\n\n  If a control frame doesn't have a payload, then the payload value\n  will be `nil`.\n  \"\"\"\n  @callback handle_control({message :: term, opts :: keyword}, state) ::\n              {:ok, state}\n              | {:reply, :ok | :error, {opcode :: atom, message :: term}, state}\n              | {:stop, reason :: term, state}\n\n  @doc \"\"\"\n  Handles info messages.\n\n  The message is a term. It must return one of:\n\n    * `{:ok, state}` - continues the socket with no reply\n    * `{:push, reply, state}` - continues the socket with reply\n    * `{:stop, reason, state}` - stops the socket\n\n  The `reply` is a tuple contain an `opcode` atom and a message that can\n  be any term. The built-in websocket transport supports both `:text` and\n  `:binary` opcode and the message must be always iodata. Long polling only\n  supports text opcode.\n  \"\"\"\n  @callback handle_info(message :: term, state) ::\n              {:ok, state}\n              | {:push, {opcode :: atom, message :: term}, state}\n              | {:stop, reason :: term, state}\n\n  @doc \"\"\"\n  Invoked on termination.\n\n  If `reason` is `:closed`, it means the client closed the socket. This is\n  considered a `:normal` exit signal, so linked process will not automatically\n  exit. See `Process.exit/2` for more details on exit signals.\n  \"\"\"\n  @callback terminate(reason :: term, state) :: :ok\n\n  @optional_callbacks handle_control: 2\n\n  require Logger\n\n  @doc false\n  def load_config(true, module),\n    do: module.default_config()\n\n  def load_config(config, module),\n    do: module.default_config() |> Keyword.merge(config) |> load_config()\n\n  @doc false\n  def load_config(config) do\n    {connect_info, config} = Keyword.pop(config, :connect_info, [])\n\n    connect_info =\n      Enum.map(connect_info, fn\n        key when key in [:peer_data, :trace_context_headers, :uri, :user_agent, :x_headers] ->\n          key\n\n        {:session, session} ->\n          {:session, init_session(session)}\n\n        {_, _} = pair ->\n          pair\n\n        other ->\n          raise ArgumentError,\n                \":connect_info keys are expected to be one of :peer_data, :trace_context_headers, :x_headers, :uri, or {:session, config}, \" <>\n                  \"optionally followed by custom keyword pairs, got: #{inspect(other)}\"\n      end)\n\n    [connect_info: connect_info] ++ config\n  end\n\n  defp init_session(session_config) when is_list(session_config) do\n    key = Keyword.fetch!(session_config, :key)\n    store = Plug.Session.Store.get(Keyword.fetch!(session_config, :store))\n    init = store.init(Keyword.drop(session_config, [:store, :key]))\n    {key, store, init}\n  end\n\n  defp init_session({_, _, _} = mfa)  do\n    {:mfa, mfa}\n  end\n\n  @doc \"\"\"\n  Runs the code reloader if enabled.\n  \"\"\"\n  def code_reload(conn, endpoint, opts) do\n    reload? = Keyword.get(opts, :code_reloader, endpoint.config(:code_reloader))\n    reload? && Phoenix.CodeReloader.reload(endpoint)\n    conn\n  end\n\n  @doc \"\"\"\n  Forces SSL in the socket connection.\n\n  Uses the endpoint configuration to decide so. It is a\n  noop if the connection has been halted.\n  \"\"\"\n  def force_ssl(%{halted: true} = conn, _socket, _endpoint, _opts) do\n    conn\n  end\n\n  def force_ssl(conn, socket, endpoint, opts) do\n    if force_ssl = force_ssl_config(socket, endpoint, opts) do\n      Plug.SSL.call(conn, force_ssl)\n    else\n      conn\n    end\n  end\n\n  defp force_ssl_config(socket, endpoint, opts) do\n    Phoenix.Config.cache(endpoint, {:force_ssl, socket}, fn _ ->\n      opts =\n        if force_ssl = Keyword.get(opts, :force_ssl, endpoint.config(:force_ssl)) do\n          force_ssl\n          |> Keyword.put_new(:host, {endpoint, :host, []})\n          |> Plug.SSL.init()\n        end\n      {:cache, opts}\n    end)\n  end\n\n  @doc \"\"\"\n  Logs the transport request.\n\n  Available for transports that generate a connection.\n  \"\"\"\n  def transport_log(conn, level) do\n    if level do\n      Plug.Logger.call(conn, Plug.Logger.init(log: level))\n    else\n      conn\n    end\n  end\n\n  @doc \"\"\"\n  Checks the origin request header against the list of allowed origins.\n\n  Should be called by transports before connecting when appropriate.\n  If the origin header matches the allowed origins, no origin header was\n  sent or no origin was configured, it will return the given connection.\n\n  Otherwise a 403 Forbidden response will be sent and the connection halted.\n  It is a noop if the connection has been halted.\n  \"\"\"\n  def check_origin(conn, handler, endpoint, opts, sender \\\\ &Plug.Conn.send_resp/1)\n\n  def check_origin(%Plug.Conn{halted: true} = conn, _handler, _endpoint, _opts, _sender),\n    do: conn\n\n  def check_origin(conn, handler, endpoint, opts, sender) do\n    import Plug.Conn\n    origin       = conn |> get_req_header(\"origin\") |> List.first()\n    check_origin = check_origin_config(handler, endpoint, opts)\n\n    cond do\n      is_nil(origin) or check_origin == false ->\n        conn\n\n      origin_allowed?(check_origin, URI.parse(origin), endpoint, conn) ->\n        conn\n\n      true ->\n        Logger.error \"\"\"\n        Could not check origin for Phoenix.Socket transport.\n\n        Origin of the request: #{origin}\n\n        This happens when you are attempting a socket connection to\n        a different host than the one configured in your config/\n        files. For example, in development the host is configured\n        to \"localhost\" but you may be trying to access it from\n        \"127.0.0.1\". To fix this issue, you may either:\n\n          1. update [url: [host: ...]] to your actual host in the\n             config file for your current environment (recommended)\n\n          2. pass the :check_origin option when configuring your\n             endpoint or when configuring the transport in your\n             UserSocket module, explicitly outlining which origins\n             are allowed:\n\n                check_origin: [\"https://example.com\",\n                               \"//another.com:888\", \"//other.com\"]\n\n        \"\"\"\n        resp(conn, :forbidden, \"\")\n        |> sender.()\n        |> halt()\n    end\n  end\n\n  @doc \"\"\"\n  Checks the Websocket subprotocols request header against the allowed subprotocols.\n\n  Should be called by transports before connecting when appropriate.\n  If the sec-websocket-protocol header matches the allowed subprotocols,\n  it will put sec-websocket-protocol response header and return the given connection.\n  If no sec-websocket-protocol header was sent it will return the given connection.\n\n  Otherwise a 403 Forbidden response will be sent and the connection halted.\n  It is a noop if the connection has been halted.\n  \"\"\"\n  def check_subprotocols(conn, subprotocols)\n\n  def check_subprotocols(%Plug.Conn{halted: true} = conn, _subprotocols), do: conn\n  def check_subprotocols(conn, nil), do: conn\n\n  def check_subprotocols(conn, subprotocols) when is_list(subprotocols) do\n    case Plug.Conn.get_req_header(conn, \"sec-websocket-protocol\") do\n      [] ->\n        conn\n\n      [subprotocols_header | _] ->\n        request_subprotocols = subprotocols_header |> Plug.Conn.Utils.list()\n        subprotocol = Enum.find(subprotocols, fn elem -> Enum.find(request_subprotocols, &(&1 == elem)) end)\n\n        if subprotocol do\n          Plug.Conn.put_resp_header(conn, \"sec-websocket-protocol\", subprotocol)\n        else\n          subprotocols_error_response(conn, subprotocols)\n        end\n    end\n  end\n\n  def check_subprotocols(conn, subprotocols), do: subprotocols_error_response(conn, subprotocols)\n\n  @doc \"\"\"\n  Extracts connection information from `conn` and returns a map.\n\n  Keys are retrieved from the optional transport option `:connect_info`.\n  This functionality is transport specific. Please refer to your transports'\n  documentation for more information.\n\n  The supported keys are:\n\n    * `:peer_data` - the result of `Plug.Conn.get_peer_data/1`\n\n    * `:trace_context_headers` - a list of all trace context headers\n\n    * `:x_headers` - a list of all request headers that have an \"x-\" prefix\n\n    * `:uri` - a `%URI{}` derived from the conn\n\n    * `:user_agent` - the value of the \"user-agent\" request header\n\n  \"\"\"\n  def connect_info(conn, endpoint, keys) do\n    for key <- keys, into: %{} do\n      case key do\n        :peer_data ->\n          {:peer_data, Plug.Conn.get_peer_data(conn)}\n\n        :trace_context_headers ->\n          {:trace_context_headers, fetch_trace_context_headers(conn)}\n\n        :x_headers ->\n          {:x_headers, fetch_x_headers(conn)}\n\n        :uri ->\n          {:uri, fetch_uri(conn)}\n\n        :user_agent ->\n          {:user_agent, fetch_user_agent(conn)}\n\n        {:session, session} ->\n          {:session, connect_session(conn, endpoint, session)}\n\n        {key, val} ->\n          {key, val}\n      end\n    end\n  end\n\n  defp connect_session(conn, endpoint, {key, store, store_config}) do\n    conn = Plug.Conn.fetch_cookies(conn)\n\n    with csrf_token when is_binary(csrf_token) <- conn.params[\"_csrf_token\"],\n         cookie when is_binary(cookie) <- conn.cookies[key],\n         conn = put_in(conn.secret_key_base, endpoint.config(:secret_key_base)),\n         {_, session} <- store.get(conn, cookie, store_config),\n         csrf_state when is_binary(csrf_state) <- Plug.CSRFProtection.dump_state_from_session(session[\"_csrf_token\"]),\n         true <- Plug.CSRFProtection.valid_state_and_csrf_token?(csrf_state, csrf_token) do\n      session\n    else\n      _ -> nil\n    end\n  end\n\n  defp connect_session(conn, endpoint, {:mfa, {module, function, args}}) do\n    case apply(module, function, args) do\n      session_config when is_list(session_config) ->\n        connect_session(conn, endpoint, init_session(session_config))\n\n      other ->\n        raise ArgumentError,\n          \"the MFA given to `session_config` must return a keyword list, got: #{inspect other}\"\n    end\n  end\n\n  defp subprotocols_error_response(conn, subprotocols) do\n    import Plug.Conn\n    request_headers = get_req_header(conn, \"sec-websocket-protocol\")\n\n    Logger.error \"\"\"\n    Could not check Websocket subprotocols for Phoenix.Socket transport.\n\n    Subprotocols of the request: #{inspect(request_headers)}\n    Configured supported subprotocols: #{inspect(subprotocols)}\n\n    This happens when you are attempting a socket connection to\n    a different subprotocols than the one configured in your endpoint\n    or when you incorrectly configured supported subprotocols.\n\n    To fix this issue, you may either:\n\n      1. update websocket: [subprotocols: [..]] to your actual subprotocols\n         in your endpoint socket configuration.\n\n      2. check the correctness of the `sec-websocket-protocol` request header\n         sent from the client.\n\n      3. remove `websocket` option from your endpoint socket configuration\n         if you don't use Websocket subprotocols.\n    \"\"\"\n\n    resp(conn, :forbidden, \"\")\n    |> send_resp()\n    |> halt()\n  end\n\n  defp fetch_x_headers(conn) do\n    for {header, _} = pair <- conn.req_headers,\n        String.starts_with?(header, \"x-\"),\n        do: pair\n  end\n\n  defp fetch_trace_context_headers(conn) do\n    for {header, _} = pair <- conn.req_headers,\n      header in [\"traceparent\", \"tracestate\"],\n      do: pair\n  end\n\n  defp fetch_uri(conn) do\n    %URI{\n      scheme: to_string(conn.scheme),\n      query: conn.query_string,\n      port: conn.port,\n      host: conn.host,\n      authority: conn.host,\n      path: conn.request_path\n    }\n  end\n\n  defp fetch_user_agent(conn) do\n    with {_, value} <- List.keyfind(conn.req_headers, \"user-agent\", 0) do\n      value\n    end\n  end\n\n  defp check_origin_config(handler, endpoint, opts) do\n    Phoenix.Config.cache(endpoint, {:check_origin, handler}, fn _ ->\n      check_origin =\n        case Keyword.get(opts, :check_origin, endpoint.config(:check_origin)) do\n          origins when is_list(origins) ->\n            Enum.map(origins, &parse_origin/1)\n\n          boolean when is_boolean(boolean) ->\n            boolean\n\n          {module, function, arguments} ->\n            {module, function, arguments}\n\n          :conn ->\n            :conn\n\n          invalid ->\n            raise ArgumentError, \":check_origin expects a boolean, list of hosts, :conn, or MFA tuple, got: #{inspect(invalid)}\"\n        end\n\n      {:cache, check_origin}\n    end)\n  end\n\n  defp parse_origin(origin) do\n    case URI.parse(origin) do\n      %{host: nil} ->\n        raise ArgumentError,\n          \"invalid :check_origin option: #{inspect origin}. \" <>\n          \"Expected an origin with a host that is parsable by URI.parse/1. For example: \" <>\n          \"[\\\"https://example.com\\\", \\\"//another.com:888\\\", \\\"//other.com\\\"]\"\n\n      %{scheme: scheme, port: port, host: host} ->\n        {scheme, host, port}\n    end\n  end\n\n  defp origin_allowed?({module, function, arguments}, uri, _endpoint, _conn),\n    do: apply(module, function, [uri | arguments])\n\n  defp origin_allowed?(:conn, uri, _endpoint, %Plug.Conn{} = conn) do\n    uri.host == conn.host and\n      uri.scheme == Atom.to_string(conn.scheme) and\n      uri.port == conn.port\n  end\n\n  defp origin_allowed?(_check_origin, %{host: nil}, _endpoint, _conn),\n    do: false\n  defp origin_allowed?(true, uri, endpoint, _conn),\n    do: compare?(uri.host, host_to_binary(endpoint.config(:url)[:host]))\n  defp origin_allowed?(check_origin, uri, _endpoint, _conn) when is_list(check_origin),\n    do: origin_allowed?(uri, check_origin)\n\n  defp origin_allowed?(uri, allowed_origins) do\n    %{scheme: origin_scheme, host: origin_host, port: origin_port} = uri\n\n    Enum.any?(allowed_origins, fn {allowed_scheme, allowed_host, allowed_port} ->\n      compare?(origin_scheme, allowed_scheme) and\n      compare?(origin_port, allowed_port) and\n      compare_host?(origin_host, allowed_host)\n    end)\n  end\n\n  defp compare?(request_val, allowed_val) do\n    is_nil(allowed_val) or request_val == allowed_val\n  end\n\n  defp compare_host?(_request_host, nil),\n    do: true\n  defp compare_host?(request_host, \"*.\" <> allowed_host),\n    do: String.ends_with?(request_host, allowed_host)\n  defp compare_host?(request_host, allowed_host),\n    do: request_host == allowed_host\n\n  # TODO: Remove this once {:system, env_var} deprecation is removed\n  defp host_to_binary({:system, env_var}), do: host_to_binary(System.get_env(env_var))\n  defp host_to_binary(host), do: host\nend\n", "defmodule Phoenix.Socket.TransportTest do\n  use ExUnit.Case, async: true\n  use RouterHelper\n\n  import ExUnit.CaptureLog\n\n  alias Phoenix.Socket.Transport\n\n  @secret_key_base String.duplicate(\"abcdefgh\", 8)\n\n  Application.put_env :phoenix, __MODULE__.Endpoint,\n    force_ssl: [],\n    url: [host: \"host.com\"],\n    check_origin: [\"//endpoint.com\"],\n    secret_key_base: @secret_key_base\n\n  defmodule Endpoint do\n    use Phoenix.Endpoint, otp_app: :phoenix\n\n    @session_config [\n      store: :cookie,\n      key: \"_hello_key\",\n      signing_salt: \"change_me\"\n    ]\n\n    def session_config, do: @session_config\n\n    plug Plug.Session, @session_config\n    plug :fetch_session\n    plug Plug.CSRFProtection\n    plug :put_session\n\n    defp put_session(conn, _) do\n      conn\n      |> put_session(:from_session, \"123\")\n      |> send_resp(200, Plug.CSRFProtection.get_csrf_token())\n    end\n  end\n\n  setup_all do\n    Endpoint.start_link()\n    :ok\n  end\n\n  setup do\n    Logger.disable(self())\n  end\n\n  ## Check origin\n\n  describe \"check_origin/4\" do\n    defp check_origin(%Plug.Conn{} = conn, origin, opts) do\n      conn = put_req_header(conn, \"origin\", origin)\n      Transport.check_origin(conn, make_ref(), Endpoint, opts)\n    end\n\n    defp check_origin(origin, opts), do: check_origin(conn(:get, \"/\"), origin, opts)\n\n    test \"does not check origin if disabled\" do\n      refute check_origin(\"/\", check_origin: false).halted\n    end\n\n    test \"checks origin against host\" do\n      refute check_origin(\"https://host.com/\", check_origin: true).halted\n      conn = check_origin(\"https://another.com/\", check_origin: true)\n      assert conn.halted\n      assert conn.status == 403\n    end\n\n    test \"checks origin from endpoint config\" do\n      refute check_origin(\"https://endpoint.com/\", []).halted\n      conn = check_origin(\"https://another.com/\", [])\n      assert conn.halted\n      assert conn.status == 403\n    end\n\n    test \"can get the host from system variables\" do\n      refute check_origin(\"https://host.com\", check_origin: true).halted\n    end\n\n    test \"wildcard subdomains\" do\n      origins = [\"https://*.ex.com\", \"http://*.ex.com\"]\n\n      conn = check_origin(\"http://org1.ex.com\", check_origin: origins)\n      refute conn.halted\n      conn = check_origin(\"https://org1.ex.com\", check_origin: origins)\n      refute conn.halted\n    end\n\n    test \"nested wildcard subdomains\" do\n      origins = [\"http://*.foo.example.com\"]\n\n      conn = check_origin(\"http://org1.foo.example.com\", check_origin: origins)\n      refute conn.halted\n\n      conn = check_origin(\"http://org1.bar.example.com\", check_origin: origins)\n      assert conn.halted\n      assert conn.status == 403\n    end\n\n    test \"subdomains do not match without a wildcard\" do\n      conn = check_origin(\"http://org1.ex.com\", check_origin: [\"//ex.com\"])\n      assert conn.halted\n    end\n\n    test \"halts invalid URIs when check origin is configured\" do\n      Logger.enable(self())\n      origins = [\"//example.com\", \"http://scheme.com\", \"//port.com:81\"]\n\n      logs =\n        capture_log(fn ->\n          for config <- [origins, true] do\n            assert check_origin(\"file://\", check_origin: config).halted\n            assert check_origin(\"null\", check_origin: config).halted\n            assert check_origin(\"\", check_origin: config).halted\n          end\n        end)\n\n      assert logs =~ \"Origin of the request: file://\"\n      assert logs =~ \"Origin of the request: null\"\n    end\n\n    def invalid_allowed?(%URI{host: nil}), do: true\n    def invalid_allowed?(%URI{host: \"\"}), do: true\n\n    test \"allows custom MFA check to handle invalid host\" do\n      mfa = {__MODULE__, :invalid_allowed?, []}\n\n      refute check_origin(\"file://\", check_origin: mfa).halted\n      refute check_origin(\"null\", check_origin: mfa).halted\n      refute check_origin(\"\", check_origin: mfa).halted\n    end\n\n    test \"checks origin against :conn\" do\n      conn = %Plug.Conn{conn(:get, \"/\") | host: \"example.com\", scheme: :http, port: 80}\n      refute check_origin(conn, \"http://example.com\", check_origin: :conn).halted\n\n      assert check_origin(conn, \"https://example.com\", check_origin: :conn).halted\n      assert check_origin(conn, \"ws://example.com\", check_origin: :conn).halted\n      assert check_origin(conn, \"wss://example.com\", check_origin: :conn).halted\n      assert check_origin(conn, \"http://www.example.com\", check_origin: :conn).halted\n      assert check_origin(conn, \"http://www.another.com\", check_origin: :conn).halted\n\n      conn = %Plug.Conn{conn(:get, \"/\") | host: \"example.com\", scheme: :https, port: 443}\n      refute check_origin(conn, \"https://example.com\", check_origin: :conn).halted\n      assert check_origin(conn, \"http://example.com\", check_origin: :conn).halted\n      assert check_origin(conn, \"https://example.com:4000\", check_origin: :conn).halted\n    end\n\n    test \"does not halt invalid URIs when check_origin is disabled\" do\n      refute check_origin(\"file://\", check_origin: false).halted\n      refute check_origin(\"null\", check_origin: false).halted\n      refute check_origin(\"\", check_origin: false).halted\n    end\n\n    test \"checks the origin of requests against allowed origins\" do\n      origins = [\"//example.com\", \"http://scheme.com\", \"//port.com:81\"]\n\n      # not allowed host\n      conn = check_origin(\"http://notallowed.com/\", check_origin: origins)\n      assert conn.halted\n      assert conn.status == 403\n\n      # Only host match\n      refute check_origin(\"http://example.com/\", check_origin: origins).halted\n      refute check_origin(\"https://example.com/\", check_origin: origins).halted\n\n      # Scheme + host match (checks port due to scheme)\n      refute check_origin(\"http://scheme.com/\", check_origin: origins).halted\n\n      conn = check_origin(\"https://scheme.com/\", check_origin: origins)\n      assert conn.halted\n      assert conn.status == 403\n\n      conn = check_origin(\"http://scheme.com:8080/\", check_origin: origins)\n      assert conn.halted\n      assert conn.status == 403\n\n      # Scheme + host + port match\n      refute check_origin(\"http://port.com:81/\", check_origin: origins).halted\n\n      conn = check_origin(\"http://port.com:82/\", check_origin: origins)\n      assert conn.halted\n      assert conn.status == 403\n    end\n\n    def check_origin_callback(%URI{host: \"example.com\"}), do: true\n    def check_origin_callback(%URI{host: _}), do: false\n\n    test \"checks the origin of requests against an MFA\" do\n      # callback without additional arguments\n      mfa = {__MODULE__, :check_origin_callback, []}\n\n      # a not allowed host\n      conn = check_origin(\"http://notallowed.com/\", check_origin: mfa)\n      assert conn.halted\n      assert conn.status == 403\n\n      # an allowed host\n      refute check_origin(\"http://example.com/\", check_origin: mfa).halted\n    end\n\n    def check_origin_additional(%URI{host: allowed}, allowed), do: true\n    def check_origin_additional(%URI{host: _}, _allowed), do: false\n\n    test \"checks the origin of requests against an MFA, passing additional arguments\" do\n      # callback with additional argument\n      mfa = {__MODULE__, :check_origin_additional, [\"host.com\"]}\n\n      # a not allowed host\n      conn = check_origin(\"http://notallowed.com/\", check_origin: mfa)\n      assert conn.halted\n      assert conn.status == 403\n\n      # an allowed host\n      refute check_origin(\"https://host.com/\", check_origin: mfa).halted\n    end\n  end\n\n  ## Check subprotocols\n\n  describe \"check_subprotocols/2\" do\n    defp check_subprotocols(expected, passed) do\n      conn = conn(:get, \"/\") |> put_req_header(\"sec-websocket-protocol\", Enum.join(passed, \", \"))\n      Transport.check_subprotocols(conn, expected)\n    end\n\n    test \"does not check subprotocols if not passed expected\" do\n      refute check_subprotocols(nil, [\"sip\"]).halted\n    end\n\n    test \"does not check subprotocols if conn is halted\" do\n      halted_conn = conn(:get, \"/\") |> halt()\n      conn = Transport.check_subprotocols(halted_conn, [\"sip\"])\n      assert conn == halted_conn\n    end\n\n    test \"returns first matched subprotocol\" do\n      conn = check_subprotocols([\"sip\", \"mqtt\"], [\"sip\", \"mqtt\"])\n      refute conn.halted\n      assert get_resp_header(conn, \"sec-websocket-protocol\") == [\"sip\"]\n    end\n\n    test \"halt if expected and passed subprotocols don't match\" do\n      conn = check_subprotocols([\"sip\"], [\"mqtt\"])\n      assert conn.halted\n      assert conn.status == 403\n    end\n\n    test \"halt if expected subprotocols passed in the wrong format\" do\n      conn = check_subprotocols(\"sip\", [\"mqtt\"])\n      assert conn.halted\n      assert conn.status == 403\n    end\n  end\n\n  describe \"force_ssl/4\" do\n    test \"forces SSL\" do\n      # Halts\n      conn = Transport.force_ssl(conn(:get, \"http://foo.com/\"), make_ref(), Endpoint, [])\n      assert conn.halted\n      assert get_resp_header(conn, \"location\") == [\"https://host.com/\"]\n\n      # Disabled\n      conn = Transport.force_ssl(conn(:get, \"http://foo.com/\"), make_ref(), Endpoint, force_ssl: false)\n      refute conn.halted\n\n      # No-op when already halted\n      conn = Transport.force_ssl(conn(:get, \"http://foo.com/\") |> halt(), make_ref(), Endpoint, [])\n      assert conn.halted\n      assert get_resp_header(conn, \"location\") == []\n\n      # Valid\n      conn = Transport.force_ssl(conn(:get, \"https://foo.com/\"), make_ref(), Endpoint, [])\n      refute conn.halted\n    end\n  end\n\n  describe \"connect_info/3\" do\n    defp load_connect_info(connect_info) do\n      [connect_info: connect_info] = Transport.load_config(connect_info: connect_info)\n      connect_info\n    end\n\n    test \"loads the session from MFA\" do\n      conn = conn(:get, \"https://foo.com/\") |> Endpoint.call([])\n      csrf_token = conn.resp_body\n      session_cookie = conn.cookies[\"_hello_key\"]\n\n      connect_info = load_connect_info(session: {Endpoint, :session_config, []})\n\n      assert %{session: %{\"from_session\" => \"123\"}} =\n               conn(:get, \"https://foo.com/\", _csrf_token: csrf_token)\n               |> put_req_cookie(\"_hello_key\", session_cookie)\n               |> fetch_query_params()\n               |> Transport.connect_info(Endpoint, connect_info)\n    end\n  end\nend\n"], "fixing_code": ["defmodule Phoenix.Socket.Transport do\n  @moduledoc \"\"\"\n  Outlines the Socket <-> Transport communication.\n\n  This module specifies a behaviour that all sockets must implement.\n  `Phoenix.Socket` is just one possible implementation of a socket\n  that multiplexes events over multiple channels. Developers can\n  implement their own sockets as long as they implement the behaviour\n  outlined here.\n\n  Developers interested in implementing custom transports must invoke\n  the socket API defined in this module. This module also provides\n  many conveniences that invokes the underlying socket API to make\n  it easier to build custom transports.\n\n  ## Booting sockets\n\n  Whenever your endpoint starts, it will automatically invoke the\n  `child_spec/1` on each listed socket and start that specification\n  under the endpoint supervisor.\n\n  Since the socket supervision tree is started by the endpoint,\n  any custom transport must be started after the endpoint in a\n  supervision tree.\n\n  ## Operating sockets\n\n  Sockets are operated by a transport. When a transport is defined,\n  it usually receives a socket module and the module will be invoked\n  when certain events happen at the transport level.\n\n  Whenever the transport receives a new connection, it should invoke\n  the `c:connect/1` callback with a map of metadata. Different sockets\n  may require different metadata.\n\n  If the connection is accepted, the transport can move the connection\n  to another process, if so desires, or keep using the same process. The\n  process responsible for managing the socket should then call `c:init/1`.\n\n  For each message received from the client, the transport must call\n  `c:handle_in/2` on the socket. For each informational message the\n  transport receives, it should call `c:handle_info/2` on the socket.\n\n  Transports can optionally implement `c:handle_control/2` for handling\n  control frames such as `:ping` and `:pong`.\n\n  On termination, `c:terminate/2` must be called. A special atom with\n  reason `:closed` can be used to specify that the client terminated\n  the connection.\n\n  ## Example\n\n  Here is a simple echo socket implementation:\n\n      defmodule EchoSocket do\n        @behaviour Phoenix.Socket.Transport\n\n        def child_spec(opts) do\n          # We won't spawn any process, so let's return a dummy task\n          %{id: __MODULE__, start: {Task, :start_link, [fn -> :ok end]}, restart: :transient}\n        end\n\n        def connect(state) do\n          # Callback to retrieve relevant data from the connection.\n          # The map contains options, params, transport and endpoint keys.\n          {:ok, state}\n        end\n\n        def init(state) do\n          # Now we are effectively inside the process that maintains the socket.\n          {:ok, state}\n        end\n\n        def handle_in({text, _opts}, state) do\n          {:reply, :ok, {:text, text}, state}\n        end\n\n        def handle_info(_, state) do\n          {:ok, state}\n        end\n\n        def terminate(_reason, _state) do\n          :ok\n        end\n      end\n\n  It can be mounted in your endpoint like any other socket:\n\n      socket \"/socket\", EchoSocket, websocket: true, longpoll: true\n\n  You can now interact with the socket under `/socket/websocket`\n  and `/socket/longpoll`.\n\n  ## Security\n\n  This module also provides functions to enable a secure environment\n  on transports that, at some point, have access to a `Plug.Conn`.\n\n  The functionality provided by this module helps in performing \"origin\"\n  header checks and ensuring only SSL connections are allowed.\n  \"\"\"\n\n  @type state :: term()\n\n  @doc \"\"\"\n  Returns a child specification for socket management.\n\n  This is invoked only once per socket regardless of\n  the number of transports and should be responsible\n  for setting up any process structure used exclusively\n  by the socket regardless of transports.\n\n  Each socket connection is started by the transport\n  and the process that controls the socket likely\n  belongs to the transport. However, some sockets spawn\n  new processes, such as `Phoenix.Socket` which spawns\n  channels, and this gives the ability to start a\n  supervision tree associated to the socket.\n\n  It receives the socket options from the endpoint,\n  for example:\n\n      socket \"/my_app\", MyApp.Socket, shutdown: 5000\n\n  means `child_spec([shutdown: 5000])` will be invoked.\n  \"\"\"\n  @callback child_spec(keyword) :: :supervisor.child_spec\n\n  @doc \"\"\"\n  Connects to the socket.\n\n  The transport passes a map of metadata and the socket\n  returns `{:ok, state}` or `:error`. The state must be\n  stored by the transport and returned in all future\n  operations.\n\n  This function is used for authorization purposes and it\n  may be invoked outside of the process that effectively\n  runs the socket.\n\n  In the default `Phoenix.Socket` implementation, the\n  metadata expects the following keys:\n\n    * `:endpoint` - the application endpoint\n    * `:transport` - the transport name\n    * `:params` - the connection parameters\n    * `:options` - a keyword list of transport options, often\n      given by developers when configuring the transport.\n      It must include a `:serializer` field with the list of\n      serializers and their requirements\n\n  \"\"\"\n  @callback connect(transport_info :: map) :: {:ok, state} | :error\n\n  @doc \"\"\"\n  Initializes the socket state.\n\n  This must be executed from the process that will effectively\n  operate the socket.\n  \"\"\"\n  @callback init(state) :: {:ok, state}\n\n  @doc \"\"\"\n  Handles incoming socket messages.\n\n  The message is represented as `{payload, options}`. It must\n  return one of:\n\n    * `{:ok, state}` - continues the socket with no reply\n    * `{:reply, status, reply, state}` - continues the socket with reply\n    * `{:stop, reason, state}` - stops the socket\n\n  The `reply` is a tuple contain an `opcode` atom and a message that can\n  be any term. The built-in websocket transport supports both `:text` and\n  `:binary` opcode and the message must be always iodata. Long polling only\n  supports text opcode.\n  \"\"\"\n  @callback handle_in({message :: term, opts :: keyword}, state) ::\n              {:ok, state}\n              | {:reply, :ok | :error, {opcode :: atom, message :: term}, state}\n              | {:stop, reason :: term, state}\n\n  @doc \"\"\"\n  Handles incoming control frames.\n\n  The message is represented as `{payload, options}`. It must\n  return one of:\n\n    * `{:ok, state}` - continues the socket with no reply\n    * `{:reply, status, reply, state}` - continues the socket with reply\n    * `{:stop, reason, state}` - stops the socket\n\n  Control frames only supported when using websockets.\n\n  The `options` contains an `opcode` key, this will be either `:ping` or\n  `:pong`.\n\n  If a control frame doesn't have a payload, then the payload value\n  will be `nil`.\n  \"\"\"\n  @callback handle_control({message :: term, opts :: keyword}, state) ::\n              {:ok, state}\n              | {:reply, :ok | :error, {opcode :: atom, message :: term}, state}\n              | {:stop, reason :: term, state}\n\n  @doc \"\"\"\n  Handles info messages.\n\n  The message is a term. It must return one of:\n\n    * `{:ok, state}` - continues the socket with no reply\n    * `{:push, reply, state}` - continues the socket with reply\n    * `{:stop, reason, state}` - stops the socket\n\n  The `reply` is a tuple contain an `opcode` atom and a message that can\n  be any term. The built-in websocket transport supports both `:text` and\n  `:binary` opcode and the message must be always iodata. Long polling only\n  supports text opcode.\n  \"\"\"\n  @callback handle_info(message :: term, state) ::\n              {:ok, state}\n              | {:push, {opcode :: atom, message :: term}, state}\n              | {:stop, reason :: term, state}\n\n  @doc \"\"\"\n  Invoked on termination.\n\n  If `reason` is `:closed`, it means the client closed the socket. This is\n  considered a `:normal` exit signal, so linked process will not automatically\n  exit. See `Process.exit/2` for more details on exit signals.\n  \"\"\"\n  @callback terminate(reason :: term, state) :: :ok\n\n  @optional_callbacks handle_control: 2\n\n  require Logger\n\n  @doc false\n  def load_config(true, module),\n    do: module.default_config()\n\n  def load_config(config, module),\n    do: module.default_config() |> Keyword.merge(config) |> load_config()\n\n  @doc false\n  def load_config(config) do\n    {connect_info, config} = Keyword.pop(config, :connect_info, [])\n\n    connect_info =\n      Enum.map(connect_info, fn\n        key when key in [:peer_data, :trace_context_headers, :uri, :user_agent, :x_headers] ->\n          key\n\n        {:session, session} ->\n          {:session, init_session(session)}\n\n        {_, _} = pair ->\n          pair\n\n        other ->\n          raise ArgumentError,\n                \":connect_info keys are expected to be one of :peer_data, :trace_context_headers, :x_headers, :uri, or {:session, config}, \" <>\n                  \"optionally followed by custom keyword pairs, got: #{inspect(other)}\"\n      end)\n\n    [connect_info: connect_info] ++ config\n  end\n\n  defp init_session(session_config) when is_list(session_config) do\n    key = Keyword.fetch!(session_config, :key)\n    store = Plug.Session.Store.get(Keyword.fetch!(session_config, :store))\n    init = store.init(Keyword.drop(session_config, [:store, :key]))\n    {key, store, init}\n  end\n\n  defp init_session({_, _, _} = mfa)  do\n    {:mfa, mfa}\n  end\n\n  @doc \"\"\"\n  Runs the code reloader if enabled.\n  \"\"\"\n  def code_reload(conn, endpoint, opts) do\n    reload? = Keyword.get(opts, :code_reloader, endpoint.config(:code_reloader))\n    reload? && Phoenix.CodeReloader.reload(endpoint)\n    conn\n  end\n\n  @doc \"\"\"\n  Forces SSL in the socket connection.\n\n  Uses the endpoint configuration to decide so. It is a\n  noop if the connection has been halted.\n  \"\"\"\n  def force_ssl(%{halted: true} = conn, _socket, _endpoint, _opts) do\n    conn\n  end\n\n  def force_ssl(conn, socket, endpoint, opts) do\n    if force_ssl = force_ssl_config(socket, endpoint, opts) do\n      Plug.SSL.call(conn, force_ssl)\n    else\n      conn\n    end\n  end\n\n  defp force_ssl_config(socket, endpoint, opts) do\n    Phoenix.Config.cache(endpoint, {:force_ssl, socket}, fn _ ->\n      opts =\n        if force_ssl = Keyword.get(opts, :force_ssl, endpoint.config(:force_ssl)) do\n          force_ssl\n          |> Keyword.put_new(:host, {endpoint, :host, []})\n          |> Plug.SSL.init()\n        end\n      {:cache, opts}\n    end)\n  end\n\n  @doc \"\"\"\n  Logs the transport request.\n\n  Available for transports that generate a connection.\n  \"\"\"\n  def transport_log(conn, level) do\n    if level do\n      Plug.Logger.call(conn, Plug.Logger.init(log: level))\n    else\n      conn\n    end\n  end\n\n  @doc \"\"\"\n  Checks the origin request header against the list of allowed origins.\n\n  Should be called by transports before connecting when appropriate.\n  If the origin header matches the allowed origins, no origin header was\n  sent or no origin was configured, it will return the given connection.\n\n  Otherwise a 403 Forbidden response will be sent and the connection halted.\n  It is a noop if the connection has been halted.\n  \"\"\"\n  def check_origin(conn, handler, endpoint, opts, sender \\\\ &Plug.Conn.send_resp/1)\n\n  def check_origin(%Plug.Conn{halted: true} = conn, _handler, _endpoint, _opts, _sender),\n    do: conn\n\n  def check_origin(conn, handler, endpoint, opts, sender) do\n    import Plug.Conn\n    origin       = conn |> get_req_header(\"origin\") |> List.first()\n    check_origin = check_origin_config(handler, endpoint, opts)\n\n    cond do\n      is_nil(origin) or check_origin == false ->\n        conn\n\n      origin_allowed?(check_origin, URI.parse(origin), endpoint, conn) ->\n        conn\n\n      true ->\n        Logger.error \"\"\"\n        Could not check origin for Phoenix.Socket transport.\n\n        Origin of the request: #{origin}\n\n        This happens when you are attempting a socket connection to\n        a different host than the one configured in your config/\n        files. For example, in development the host is configured\n        to \"localhost\" but you may be trying to access it from\n        \"127.0.0.1\". To fix this issue, you may either:\n\n          1. update [url: [host: ...]] to your actual host in the\n             config file for your current environment (recommended)\n\n          2. pass the :check_origin option when configuring your\n             endpoint or when configuring the transport in your\n             UserSocket module, explicitly outlining which origins\n             are allowed:\n\n                check_origin: [\"https://example.com\",\n                               \"//another.com:888\", \"//other.com\"]\n\n        \"\"\"\n        resp(conn, :forbidden, \"\")\n        |> sender.()\n        |> halt()\n    end\n  end\n\n  @doc \"\"\"\n  Checks the Websocket subprotocols request header against the allowed subprotocols.\n\n  Should be called by transports before connecting when appropriate.\n  If the sec-websocket-protocol header matches the allowed subprotocols,\n  it will put sec-websocket-protocol response header and return the given connection.\n  If no sec-websocket-protocol header was sent it will return the given connection.\n\n  Otherwise a 403 Forbidden response will be sent and the connection halted.\n  It is a noop if the connection has been halted.\n  \"\"\"\n  def check_subprotocols(conn, subprotocols)\n\n  def check_subprotocols(%Plug.Conn{halted: true} = conn, _subprotocols), do: conn\n  def check_subprotocols(conn, nil), do: conn\n\n  def check_subprotocols(conn, subprotocols) when is_list(subprotocols) do\n    case Plug.Conn.get_req_header(conn, \"sec-websocket-protocol\") do\n      [] ->\n        conn\n\n      [subprotocols_header | _] ->\n        request_subprotocols = subprotocols_header |> Plug.Conn.Utils.list()\n        subprotocol = Enum.find(subprotocols, fn elem -> Enum.find(request_subprotocols, &(&1 == elem)) end)\n\n        if subprotocol do\n          Plug.Conn.put_resp_header(conn, \"sec-websocket-protocol\", subprotocol)\n        else\n          subprotocols_error_response(conn, subprotocols)\n        end\n    end\n  end\n\n  def check_subprotocols(conn, subprotocols), do: subprotocols_error_response(conn, subprotocols)\n\n  @doc \"\"\"\n  Extracts connection information from `conn` and returns a map.\n\n  Keys are retrieved from the optional transport option `:connect_info`.\n  This functionality is transport specific. Please refer to your transports'\n  documentation for more information.\n\n  The supported keys are:\n\n    * `:peer_data` - the result of `Plug.Conn.get_peer_data/1`\n\n    * `:trace_context_headers` - a list of all trace context headers\n\n    * `:x_headers` - a list of all request headers that have an \"x-\" prefix\n\n    * `:uri` - a `%URI{}` derived from the conn\n\n    * `:user_agent` - the value of the \"user-agent\" request header\n\n  \"\"\"\n  def connect_info(conn, endpoint, keys) do\n    for key <- keys, into: %{} do\n      case key do\n        :peer_data ->\n          {:peer_data, Plug.Conn.get_peer_data(conn)}\n\n        :trace_context_headers ->\n          {:trace_context_headers, fetch_trace_context_headers(conn)}\n\n        :x_headers ->\n          {:x_headers, fetch_x_headers(conn)}\n\n        :uri ->\n          {:uri, fetch_uri(conn)}\n\n        :user_agent ->\n          {:user_agent, fetch_user_agent(conn)}\n\n        {:session, session} ->\n          {:session, connect_session(conn, endpoint, session)}\n\n        {key, val} ->\n          {key, val}\n      end\n    end\n  end\n\n  defp connect_session(conn, endpoint, {key, store, store_config}) do\n    conn = Plug.Conn.fetch_cookies(conn)\n\n    with csrf_token when is_binary(csrf_token) <- conn.params[\"_csrf_token\"],\n         cookie when is_binary(cookie) <- conn.cookies[key],\n         conn = put_in(conn.secret_key_base, endpoint.config(:secret_key_base)),\n         {_, session} <- store.get(conn, cookie, store_config),\n         csrf_state when is_binary(csrf_state) <- Plug.CSRFProtection.dump_state_from_session(session[\"_csrf_token\"]),\n         true <- Plug.CSRFProtection.valid_state_and_csrf_token?(csrf_state, csrf_token) do\n      session\n    else\n      _ -> nil\n    end\n  end\n\n  defp connect_session(conn, endpoint, {:mfa, {module, function, args}}) do\n    case apply(module, function, args) do\n      session_config when is_list(session_config) ->\n        connect_session(conn, endpoint, init_session(session_config))\n\n      other ->\n        raise ArgumentError,\n          \"the MFA given to `session_config` must return a keyword list, got: #{inspect other}\"\n    end\n  end\n\n  defp subprotocols_error_response(conn, subprotocols) do\n    import Plug.Conn\n    request_headers = get_req_header(conn, \"sec-websocket-protocol\")\n\n    Logger.error \"\"\"\n    Could not check Websocket subprotocols for Phoenix.Socket transport.\n\n    Subprotocols of the request: #{inspect(request_headers)}\n    Configured supported subprotocols: #{inspect(subprotocols)}\n\n    This happens when you are attempting a socket connection to\n    a different subprotocols than the one configured in your endpoint\n    or when you incorrectly configured supported subprotocols.\n\n    To fix this issue, you may either:\n\n      1. update websocket: [subprotocols: [..]] to your actual subprotocols\n         in your endpoint socket configuration.\n\n      2. check the correctness of the `sec-websocket-protocol` request header\n         sent from the client.\n\n      3. remove `websocket` option from your endpoint socket configuration\n         if you don't use Websocket subprotocols.\n    \"\"\"\n\n    resp(conn, :forbidden, \"\")\n    |> send_resp()\n    |> halt()\n  end\n\n  defp fetch_x_headers(conn) do\n    for {header, _} = pair <- conn.req_headers,\n        String.starts_with?(header, \"x-\"),\n        do: pair\n  end\n\n  defp fetch_trace_context_headers(conn) do\n    for {header, _} = pair <- conn.req_headers,\n      header in [\"traceparent\", \"tracestate\"],\n      do: pair\n  end\n\n  defp fetch_uri(conn) do\n    %URI{\n      scheme: to_string(conn.scheme),\n      query: conn.query_string,\n      port: conn.port,\n      host: conn.host,\n      authority: conn.host,\n      path: conn.request_path\n    }\n  end\n\n  defp fetch_user_agent(conn) do\n    with {_, value} <- List.keyfind(conn.req_headers, \"user-agent\", 0) do\n      value\n    end\n  end\n\n  defp check_origin_config(handler, endpoint, opts) do\n    Phoenix.Config.cache(endpoint, {:check_origin, handler}, fn _ ->\n      check_origin =\n        case Keyword.get(opts, :check_origin, endpoint.config(:check_origin)) do\n          origins when is_list(origins) ->\n            Enum.map(origins, &parse_origin/1)\n\n          boolean when is_boolean(boolean) ->\n            boolean\n\n          {module, function, arguments} ->\n            {module, function, arguments}\n\n          :conn ->\n            :conn\n\n          invalid ->\n            raise ArgumentError, \":check_origin expects a boolean, list of hosts, :conn, or MFA tuple, got: #{inspect(invalid)}\"\n        end\n\n      {:cache, check_origin}\n    end)\n  end\n\n  defp parse_origin(origin) do\n    case URI.parse(origin) do\n      %{host: nil} ->\n        raise ArgumentError,\n          \"invalid :check_origin option: #{inspect origin}. \" <>\n          \"Expected an origin with a host that is parsable by URI.parse/1. For example: \" <>\n          \"[\\\"https://example.com\\\", \\\"//another.com:888\\\", \\\"//other.com\\\"]\"\n\n      %{scheme: scheme, port: port, host: host} ->\n        {scheme, host, port}\n    end\n  end\n\n  defp origin_allowed?({module, function, arguments}, uri, _endpoint, _conn),\n    do: apply(module, function, [uri | arguments])\n\n  defp origin_allowed?(:conn, uri, _endpoint, %Plug.Conn{} = conn) do\n    uri.host == conn.host and\n      uri.scheme == Atom.to_string(conn.scheme) and\n      uri.port == conn.port\n  end\n\n  defp origin_allowed?(_check_origin, %{host: nil}, _endpoint, _conn),\n    do: false\n  defp origin_allowed?(true, uri, endpoint, _conn),\n    do: compare?(uri.host, host_to_binary(endpoint.config(:url)[:host]))\n  defp origin_allowed?(check_origin, uri, _endpoint, _conn) when is_list(check_origin),\n    do: origin_allowed?(uri, check_origin)\n\n  defp origin_allowed?(uri, allowed_origins) do\n    %{scheme: origin_scheme, host: origin_host, port: origin_port} = uri\n\n    Enum.any?(allowed_origins, fn {allowed_scheme, allowed_host, allowed_port} ->\n      compare?(origin_scheme, allowed_scheme) and\n      compare?(origin_port, allowed_port) and\n      compare_host?(origin_host, allowed_host)\n    end)\n  end\n\n  defp compare?(request_val, allowed_val) do\n    is_nil(allowed_val) or request_val == allowed_val\n  end\n\n  defp compare_host?(_request_host, nil),\n    do: true\n  defp compare_host?(request_host, \"*.\" <> allowed_host),\n    do: request_host == allowed_host or String.ends_with?(request_host, \".\" <> allowed_host)\n  defp compare_host?(request_host, allowed_host),\n    do: request_host == allowed_host\n\n  # TODO: Remove this once {:system, env_var} deprecation is removed\n  defp host_to_binary({:system, env_var}), do: host_to_binary(System.get_env(env_var))\n  defp host_to_binary(host), do: host\nend\n", "defmodule Phoenix.Socket.TransportTest do\n  use ExUnit.Case, async: true\n  use RouterHelper\n\n  import ExUnit.CaptureLog\n\n  alias Phoenix.Socket.Transport\n\n  @secret_key_base String.duplicate(\"abcdefgh\", 8)\n\n  Application.put_env :phoenix, __MODULE__.Endpoint,\n    force_ssl: [],\n    url: [host: \"host.com\"],\n    check_origin: [\"//endpoint.com\"],\n    secret_key_base: @secret_key_base\n\n  defmodule Endpoint do\n    use Phoenix.Endpoint, otp_app: :phoenix\n\n    @session_config [\n      store: :cookie,\n      key: \"_hello_key\",\n      signing_salt: \"change_me\"\n    ]\n\n    def session_config, do: @session_config\n\n    plug Plug.Session, @session_config\n    plug :fetch_session\n    plug Plug.CSRFProtection\n    plug :put_session\n\n    defp put_session(conn, _) do\n      conn\n      |> put_session(:from_session, \"123\")\n      |> send_resp(200, Plug.CSRFProtection.get_csrf_token())\n    end\n  end\n\n  setup_all do\n    Endpoint.start_link()\n    :ok\n  end\n\n  setup do\n    Logger.disable(self())\n  end\n\n  ## Check origin\n\n  describe \"check_origin/4\" do\n    defp check_origin(%Plug.Conn{} = conn, origin, opts) do\n      conn = put_req_header(conn, \"origin\", origin)\n      Transport.check_origin(conn, make_ref(), Endpoint, opts)\n    end\n\n    defp check_origin(origin, opts), do: check_origin(conn(:get, \"/\"), origin, opts)\n\n    test \"does not check origin if disabled\" do\n      refute check_origin(\"/\", check_origin: false).halted\n    end\n\n    test \"checks origin against host\" do\n      refute check_origin(\"https://host.com/\", check_origin: true).halted\n      conn = check_origin(\"https://another.com/\", check_origin: true)\n      assert conn.halted\n      assert conn.status == 403\n    end\n\n    test \"checks origin from endpoint config\" do\n      refute check_origin(\"https://endpoint.com/\", []).halted\n      conn = check_origin(\"https://another.com/\", [])\n      assert conn.halted\n      assert conn.status == 403\n    end\n\n    test \"can get the host from system variables\" do\n      refute check_origin(\"https://host.com\", check_origin: true).halted\n    end\n\n    test \"wildcard subdomains\" do\n      origins = [\"https://*.ex.com\", \"http://*.ex.com\"]\n\n      conn = check_origin(\"http://org1.ex.com\", check_origin: origins)\n      refute conn.halted\n      conn = check_origin(\"https://org1.ex.com\", check_origin: origins)\n      refute conn.halted\n\n      conn = check_origin(\"https://ex.com\", check_origin: origins)\n      refute conn.halted\n\n      conn = check_origin(\"https://org1.prefix-ex.com\", check_origin: origins)\n      assert conn.halted\n    end\n\n    test \"nested wildcard subdomains\" do\n      origins = [\"http://*.foo.example.com\"]\n\n      conn = check_origin(\"http://org1.foo.example.com\", check_origin: origins)\n      refute conn.halted\n\n      conn = check_origin(\"http://foo.example.com\", check_origin: origins)\n      refute conn.halted\n\n      conn = check_origin(\"http://bad.example.com\", check_origin: origins)\n      assert conn.halted\n\n      conn = check_origin(\"http://org1.prefix-foo.example.com\", check_origin: origins)\n      assert conn.halted\n\n      conn = check_origin(\"http://org1.bar.example.com\", check_origin: origins)\n      assert conn.halted\n      assert conn.status == 403\n    end\n\n    test \"subdomains do not match without a wildcard\" do\n      conn = check_origin(\"http://org1.ex.com\", check_origin: [\"//ex.com\"])\n      assert conn.halted\n    end\n\n    test \"halts invalid URIs when check origin is configured\" do\n      Logger.enable(self())\n      origins = [\"//example.com\", \"http://scheme.com\", \"//port.com:81\"]\n\n      logs =\n        capture_log(fn ->\n          for config <- [origins, true] do\n            assert check_origin(\"file://\", check_origin: config).halted\n            assert check_origin(\"null\", check_origin: config).halted\n            assert check_origin(\"\", check_origin: config).halted\n          end\n        end)\n\n      assert logs =~ \"Origin of the request: file://\"\n      assert logs =~ \"Origin of the request: null\"\n    end\n\n    def invalid_allowed?(%URI{host: nil}), do: true\n    def invalid_allowed?(%URI{host: \"\"}), do: true\n\n    test \"allows custom MFA check to handle invalid host\" do\n      mfa = {__MODULE__, :invalid_allowed?, []}\n\n      refute check_origin(\"file://\", check_origin: mfa).halted\n      refute check_origin(\"null\", check_origin: mfa).halted\n      refute check_origin(\"\", check_origin: mfa).halted\n    end\n\n    test \"checks origin against :conn\" do\n      conn = %Plug.Conn{conn(:get, \"/\") | host: \"example.com\", scheme: :http, port: 80}\n      refute check_origin(conn, \"http://example.com\", check_origin: :conn).halted\n\n      assert check_origin(conn, \"https://example.com\", check_origin: :conn).halted\n      assert check_origin(conn, \"ws://example.com\", check_origin: :conn).halted\n      assert check_origin(conn, \"wss://example.com\", check_origin: :conn).halted\n      assert check_origin(conn, \"http://www.example.com\", check_origin: :conn).halted\n      assert check_origin(conn, \"http://www.another.com\", check_origin: :conn).halted\n\n      conn = %Plug.Conn{conn(:get, \"/\") | host: \"example.com\", scheme: :https, port: 443}\n      refute check_origin(conn, \"https://example.com\", check_origin: :conn).halted\n      assert check_origin(conn, \"http://example.com\", check_origin: :conn).halted\n      assert check_origin(conn, \"https://example.com:4000\", check_origin: :conn).halted\n    end\n\n    test \"does not halt invalid URIs when check_origin is disabled\" do\n      refute check_origin(\"file://\", check_origin: false).halted\n      refute check_origin(\"null\", check_origin: false).halted\n      refute check_origin(\"\", check_origin: false).halted\n    end\n\n    test \"checks the origin of requests against allowed origins\" do\n      origins = [\"//example.com\", \"http://scheme.com\", \"//port.com:81\"]\n\n      # not allowed host\n      conn = check_origin(\"http://notallowed.com/\", check_origin: origins)\n      assert conn.halted\n      assert conn.status == 403\n\n      # Only host match\n      refute check_origin(\"http://example.com/\", check_origin: origins).halted\n      refute check_origin(\"https://example.com/\", check_origin: origins).halted\n\n      # Scheme + host match (checks port due to scheme)\n      refute check_origin(\"http://scheme.com/\", check_origin: origins).halted\n\n      conn = check_origin(\"https://scheme.com/\", check_origin: origins)\n      assert conn.halted\n      assert conn.status == 403\n\n      conn = check_origin(\"http://scheme.com:8080/\", check_origin: origins)\n      assert conn.halted\n      assert conn.status == 403\n\n      # Scheme + host + port match\n      refute check_origin(\"http://port.com:81/\", check_origin: origins).halted\n\n      conn = check_origin(\"http://port.com:82/\", check_origin: origins)\n      assert conn.halted\n      assert conn.status == 403\n    end\n\n    def check_origin_callback(%URI{host: \"example.com\"}), do: true\n    def check_origin_callback(%URI{host: _}), do: false\n\n    test \"checks the origin of requests against an MFA\" do\n      # callback without additional arguments\n      mfa = {__MODULE__, :check_origin_callback, []}\n\n      # a not allowed host\n      conn = check_origin(\"http://notallowed.com/\", check_origin: mfa)\n      assert conn.halted\n      assert conn.status == 403\n\n      # an allowed host\n      refute check_origin(\"http://example.com/\", check_origin: mfa).halted\n    end\n\n    def check_origin_additional(%URI{host: allowed}, allowed), do: true\n    def check_origin_additional(%URI{host: _}, _allowed), do: false\n\n    test \"checks the origin of requests against an MFA, passing additional arguments\" do\n      # callback with additional argument\n      mfa = {__MODULE__, :check_origin_additional, [\"host.com\"]}\n\n      # a not allowed host\n      conn = check_origin(\"http://notallowed.com/\", check_origin: mfa)\n      assert conn.halted\n      assert conn.status == 403\n\n      # an allowed host\n      refute check_origin(\"https://host.com/\", check_origin: mfa).halted\n    end\n  end\n\n  ## Check subprotocols\n\n  describe \"check_subprotocols/2\" do\n    defp check_subprotocols(expected, passed) do\n      conn = conn(:get, \"/\") |> put_req_header(\"sec-websocket-protocol\", Enum.join(passed, \", \"))\n      Transport.check_subprotocols(conn, expected)\n    end\n\n    test \"does not check subprotocols if not passed expected\" do\n      refute check_subprotocols(nil, [\"sip\"]).halted\n    end\n\n    test \"does not check subprotocols if conn is halted\" do\n      halted_conn = conn(:get, \"/\") |> halt()\n      conn = Transport.check_subprotocols(halted_conn, [\"sip\"])\n      assert conn == halted_conn\n    end\n\n    test \"returns first matched subprotocol\" do\n      conn = check_subprotocols([\"sip\", \"mqtt\"], [\"sip\", \"mqtt\"])\n      refute conn.halted\n      assert get_resp_header(conn, \"sec-websocket-protocol\") == [\"sip\"]\n    end\n\n    test \"halt if expected and passed subprotocols don't match\" do\n      conn = check_subprotocols([\"sip\"], [\"mqtt\"])\n      assert conn.halted\n      assert conn.status == 403\n    end\n\n    test \"halt if expected subprotocols passed in the wrong format\" do\n      conn = check_subprotocols(\"sip\", [\"mqtt\"])\n      assert conn.halted\n      assert conn.status == 403\n    end\n  end\n\n  describe \"force_ssl/4\" do\n    test \"forces SSL\" do\n      # Halts\n      conn = Transport.force_ssl(conn(:get, \"http://foo.com/\"), make_ref(), Endpoint, [])\n      assert conn.halted\n      assert get_resp_header(conn, \"location\") == [\"https://host.com/\"]\n\n      # Disabled\n      conn = Transport.force_ssl(conn(:get, \"http://foo.com/\"), make_ref(), Endpoint, force_ssl: false)\n      refute conn.halted\n\n      # No-op when already halted\n      conn = Transport.force_ssl(conn(:get, \"http://foo.com/\") |> halt(), make_ref(), Endpoint, [])\n      assert conn.halted\n      assert get_resp_header(conn, \"location\") == []\n\n      # Valid\n      conn = Transport.force_ssl(conn(:get, \"https://foo.com/\"), make_ref(), Endpoint, [])\n      refute conn.halted\n    end\n  end\n\n  describe \"connect_info/3\" do\n    defp load_connect_info(connect_info) do\n      [connect_info: connect_info] = Transport.load_config(connect_info: connect_info)\n      connect_info\n    end\n\n    test \"loads the session from MFA\" do\n      conn = conn(:get, \"https://foo.com/\") |> Endpoint.call([])\n      csrf_token = conn.resp_body\n      session_cookie = conn.cookies[\"_hello_key\"]\n\n      connect_info = load_connect_info(session: {Endpoint, :session_config, []})\n\n      assert %{session: %{\"from_session\" => \"123\"}} =\n               conn(:get, \"https://foo.com/\", _csrf_token: csrf_token)\n               |> put_req_cookie(\"_hello_key\", session_cookie)\n               |> fetch_query_params()\n               |> Transport.connect_info(Endpoint, connect_info)\n    end\n  end\nend\n"], "filenames": ["lib/phoenix/socket/transport.ex", "test/phoenix/socket/transport_test.exs"], "buggy_code_start_loc": [627, 87], "buggy_code_end_loc": [628, 94], "fixing_code_start_loc": [627, 88], "fixing_code_end_loc": [628, 110], "type": "NVD-CWE-Other", "message": "socket/transport.ex in Phoenix before 1.6.14 mishandles check_origin wildcarding. NOTE: LiveView applications are unaffected by default because of the presence of a LiveView CSRF token.", "other": {"cve": {"id": "CVE-2022-42975", "sourceIdentifier": "cve@mitre.org", "published": "2022-10-17T06:15:08.740", "lastModified": "2022-10-20T14:12:10.597", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "socket/transport.ex in Phoenix before 1.6.14 mishandles check_origin wildcarding. NOTE: LiveView applications are unaffected by default because of the presence of a LiveView CSRF token."}, {"lang": "es", "value": "El archivo socket/transport.ex en Phoenix versiones anteriores a 1.6.14, maneja inapropiadamente el comod\u00edn check_origin. NOTA: Las aplicaciones LiveView no est\u00e1n afectadas por defecto debido a la presencia de un token LiveView CSRF"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:phoenixframework:phoenix:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.6.14", "matchCriteriaId": "3B4737AB-52F2-471C-AA48-07DD6BD27A0D"}]}]}], "references": [{"url": "https://github.com/phoenixframework/phoenix/commit/6e7185b33a59e0b1d1c0b4223adf340a73e963ae", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/phoenixframework/phoenix/commit/6e7185b33a59e0b1d1c0b4223adf340a73e963ae"}}