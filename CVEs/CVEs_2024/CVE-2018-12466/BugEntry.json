{"buggy_code": ["class BsRequestActionSubmit < BsRequestAction\n  #### Includes and extends\n  include BsRequestAction::Differ\n\n  #### Constants\n\n  #### Self config\n  def self.sti_name\n    :submit\n  end\n\n  #### Attributes\n  #### Associations macros (Belongs to, Has one, Has many)\n  #### Callbacks macros: before_save, after_save, etc.\n  #### Scopes (first the default_scope macro if is used)\n  #### Validations macros\n  #### Class methods using self. (public and then private)\n  #### To define class methods as private use private_class_method\n  #### private\n\n  #### Instance methods (public and then protected/private)\n  def is_submit?\n    true\n  end\n\n  def execute_accept(opts)\n    # create package unless it exists already\n    target_project = Project.get_by_name(self.target_project)\n    if target_package\n      target_package = target_project.packages.find_by_name(self.target_package)\n    else\n      target_package = target_project.packages.find_by_name(source_package)\n    end\n\n    relink_source = false\n    unless target_package\n      # check for target project attributes\n      initialize_devel_package = target_project.find_attribute('OBS', 'InitializeDevelPackage')\n      # create package in database\n      linked_package = target_project.find_package(self.target_package)\n      if linked_package\n        # exists via project links\n        opts = { request: bs_request }\n        opts[:makeoriginolder] = true if makeoriginolder\n        instantiate_container(target_project, linked_package.update_instance, opts)\n        target_package = target_project.packages.find_by_name(linked_package.name)\n      else\n        # check the permissions again, because the target_package could\n        # have been deleted after the previous check_action_permission! call\n        check_action_permission!(skip_source: true) if initialize_devel_package\n        # new package, base container on source container\n        newxml = Xmlhash.parse(Backend::Api::Sources::Package.meta(source_project, source_package))\n        newxml['name'] = self.target_package\n        newxml['devel'] = nil\n        target_package = target_project.packages.new(name: newxml['name'])\n        target_package.update_from_xml(newxml)\n        target_package.flags.destroy_all\n        target_package.remove_all_persons\n        target_package.remove_all_groups\n        if initialize_devel_package\n          target_package.develpackage = Package.find_by_project_and_name(source_project, source_package)\n          relink_source = true\n        end\n        target_package.store(comment: \"submit request #{bs_request.number}\", request: bs_request)\n      end\n    end\n\n    cp_params = {\n      noservice:      1,\n      requestid:      bs_request.number,\n      comment:        bs_request.description,\n      withacceptinfo: 1\n    }\n    cp_params[:orev] = source_rev if source_rev\n    cp_params[:dontupdatesource] = 1 if sourceupdate == 'noupdate'\n    unless updatelink\n      cp_params[:expand] = 1\n      cp_params[:keeplink] = 1\n    end\n    response = Backend::Api::Sources::Package.copy(self.target_project, self.target_package,\n                                                   source_project, source_package, User.current.login, cp_params)\n    result = Xmlhash.parse(response)\n\n    set_acceptinfo(result['acceptinfo'])\n\n    target_package.sources_changed\n\n    # cleanup source project\n    if relink_source && !(sourceupdate == 'noupdate')\n      # source package got used as devel package, link it to the target\n      # re-create it via branch , but keep current content...\n      options = { comment: \"initialized devel package after accepting #{bs_request.number}\",\n        requestid: bs_request.number, keepcontent: 1, noservice: 1 }\n      Backend::Api::Sources::Package.branch(self.target_project, self.target_package, source_project, source_package, User.current.login, options)\n    elsif sourceupdate == 'cleanup'\n      source_cleanup\n    end\n\n    return unless self.target_package == '_product'\n\n    Project.find_by_name!(self.target_project).update_product_autopackages\n  end\n\n  def check_action_permission!(skip_source = nil)\n    super(skip_source)\n    # only perform the following check, if we are called from\n    # BsRequest.permission_check_change_state! (that is, if\n    # skip_source is set to true). Always executing this check\n    # would be a regression, because this code is also executed\n    # if a new request is created (which could fail if User.current\n    # cannot modify the source_package).\n    return unless skip_source\n    target_project = Project.get_by_name(self.target_project)\n    return unless target_project && target_project.is_a?(Project)\n    target_package = target_project.packages.find_by_name(self.target_package)\n    initialize_devel_package = target_project.find_attribute('OBS', 'InitializeDevelPackage')\n    return if target_package || !initialize_devel_package\n    source_package = Package.get_by_project_and_name(source_project, self.source_package)\n    return if !source_package || User.current.can_modify?(source_package)\n    msg = 'No permission to initialize the source package as a devel package'\n    raise PostRequestNoPermission, msg\n  end\n\n  #### Alias of methods\nend\n\n# == Schema Information\n#\n# Table name: bs_request_actions\n#\n#  id                    :integer          not null, primary key\n#  bs_request_id         :integer          indexed, indexed => [target_package_id], indexed => [target_project_id]\n#  type                  :string(255)\n#  target_project        :string(255)      indexed\n#  target_package        :string(255)      indexed\n#  target_releaseproject :string(255)\n#  source_project        :string(255)      indexed\n#  source_package        :string(255)      indexed\n#  source_rev            :string(255)\n#  sourceupdate          :string(255)\n#  updatelink            :boolean          default(FALSE)\n#  person_name           :string(255)\n#  group_name            :string(255)\n#  role                  :string(255)\n#  created_at            :datetime\n#  target_repository     :string(255)\n#  makeoriginolder       :boolean          default(FALSE)\n#  target_package_id     :integer          indexed => [bs_request_id], indexed\n#  target_project_id     :integer          indexed => [bs_request_id], indexed\n#\n# Indexes\n#\n#  bs_request_id                                                    (bs_request_id)\n#  index_bs_request_actions_on_bs_request_id_and_target_package_id  (bs_request_id,target_package_id)\n#  index_bs_request_actions_on_bs_request_id_and_target_project_id  (bs_request_id,target_project_id)\n#  index_bs_request_actions_on_source_package                       (source_package)\n#  index_bs_request_actions_on_source_project                       (source_project)\n#  index_bs_request_actions_on_target_package                       (target_package)\n#  index_bs_request_actions_on_target_package_id                    (target_package_id)\n#  index_bs_request_actions_on_target_project                       (target_project)\n#  index_bs_request_actions_on_target_project_id                    (target_project_id)\n#\n# Foreign Keys\n#\n#  bs_request_actions_ibfk_1  (bs_request_id => bs_requests.id)\n#\n"], "fixing_code": ["class BsRequestActionSubmit < BsRequestAction\n  #### Includes and extends\n  include BsRequestAction::Differ\n\n  #### Constants\n\n  #### Self config\n  def self.sti_name\n    :submit\n  end\n\n  #### Attributes\n  #### Associations macros (Belongs to, Has one, Has many)\n  #### Callbacks macros: before_save, after_save, etc.\n  #### Scopes (first the default_scope macro if is used)\n  #### Validations macros\n  #### Class methods using self. (public and then private)\n  #### To define class methods as private use private_class_method\n  #### private\n\n  #### Instance methods (public and then protected/private)\n  def is_submit?\n    true\n  end\n\n  def execute_accept(opts)\n    # create package unless it exists already\n    target_project = Project.get_by_name(self.target_project)\n    if target_package\n      target_package = target_project.packages.find_by_name(self.target_package)\n    else\n      target_package = target_project.packages.find_by_name(source_package)\n    end\n\n    relink_source = false\n    unless target_package\n      # check for target project attributes\n      initialize_devel_package = target_project.find_attribute('OBS', 'InitializeDevelPackage')\n      # create package in database\n      linked_package = target_project.find_package(self.target_package)\n      if linked_package\n        # exists via project links\n        opts = { request: bs_request }\n        opts[:makeoriginolder] = true if makeoriginolder\n        instantiate_container(target_project, linked_package.update_instance, opts)\n        target_package = target_project.packages.find_by_name(linked_package.name)\n      else\n        # check the permissions again, because the target_package could\n        # have been deleted after the previous check_action_permission! call\n        check_action_permission!(skip_source: true) if initialize_devel_package\n        # new package, base container on source container\n        newxml = Xmlhash.parse(Backend::Api::Sources::Package.meta(source_project, source_package))\n        newxml['name'] = self.target_package\n        newxml['devel'] = nil\n        target_package = target_project.packages.new(name: newxml['name'])\n        target_package.update_from_xml(newxml)\n        target_package.flags.destroy_all\n        target_package.remove_all_persons\n        target_package.remove_all_groups\n        if initialize_devel_package\n          target_package.develpackage = Package.find_by_project_and_name(source_project, source_package)\n          relink_source = true\n        end\n        target_package.store(comment: \"submit request #{bs_request.number}\", request: bs_request)\n      end\n    end\n\n    cp_params = {\n      noservice:      1,\n      requestid:      bs_request.number,\n      comment:        bs_request.description,\n      withacceptinfo: 1\n    }\n    cp_params[:orev] = source_rev if source_rev\n    cp_params[:dontupdatesource] = 1 if sourceupdate == 'noupdate'\n    unless updatelink\n      cp_params[:expand] = 1\n      cp_params[:keeplink] = 1\n    end\n    response = Backend::Api::Sources::Package.copy(self.target_project, self.target_package,\n                                                   source_project, source_package, User.current.login, cp_params)\n    result = Xmlhash.parse(response)\n\n    set_acceptinfo(result['acceptinfo'])\n\n    target_package.sources_changed\n\n    # cleanup source project\n    if relink_source && !(sourceupdate == 'noupdate')\n      # source package got used as devel package, link it to the target\n      # re-create it via branch , but keep current content...\n      options = { comment: \"initialized devel package after accepting #{bs_request.number}\",\n        requestid: bs_request.number, keepcontent: 1, noservice: 1 }\n      Backend::Api::Sources::Package.branch(self.target_project, self.target_package, source_project, source_package, User.current.login, options)\n    elsif sourceupdate == 'cleanup'\n      source_cleanup\n    end\n\n    return unless self.target_package == '_product'\n\n    Project.find_by_name!(self.target_project).update_product_autopackages\n  end\n\n  def check_action_permission!(skip_source = nil)\n    super(skip_source)\n    # only perform the following check, if we are called from\n    # BsRequest.permission_check_change_state! (that is, if\n    # skip_source is set to true). Always executing this check\n    # would be a regression, because this code is also executed\n    # if a new request is created (which could fail if User.current\n    # cannot modify the source_package).\n    return unless skip_source\n    target_project = Project.get_by_name(self.target_project)\n    return unless target_project && target_project.is_a?(Project)\n    target_package = target_project.packages.find_by_name(self.target_package)\n    initialize_devel_package = target_project.find_attribute('OBS', 'InitializeDevelPackage')\n    return if target_package || !initialize_devel_package\n    opts = { follow_project_links: false }\n    source_package = Package.get_by_project_and_name!(source_project,\n                                                      self.source_package,\n                                                      opts)\n    return if User.current.can_modify?(source_package)\n    msg = 'No permission to initialize the source package as a devel package'\n    raise PostRequestNoPermission, msg\n  end\n\n  #### Alias of methods\nend\n\n# == Schema Information\n#\n# Table name: bs_request_actions\n#\n#  id                    :integer          not null, primary key\n#  bs_request_id         :integer          indexed, indexed => [target_package_id], indexed => [target_project_id]\n#  type                  :string(255)\n#  target_project        :string(255)      indexed\n#  target_package        :string(255)      indexed\n#  target_releaseproject :string(255)\n#  source_project        :string(255)      indexed\n#  source_package        :string(255)      indexed\n#  source_rev            :string(255)\n#  sourceupdate          :string(255)\n#  updatelink            :boolean          default(FALSE)\n#  person_name           :string(255)\n#  group_name            :string(255)\n#  role                  :string(255)\n#  created_at            :datetime\n#  target_repository     :string(255)\n#  makeoriginolder       :boolean          default(FALSE)\n#  target_package_id     :integer          indexed => [bs_request_id], indexed\n#  target_project_id     :integer          indexed => [bs_request_id], indexed\n#\n# Indexes\n#\n#  bs_request_id                                                    (bs_request_id)\n#  index_bs_request_actions_on_bs_request_id_and_target_package_id  (bs_request_id,target_package_id)\n#  index_bs_request_actions_on_bs_request_id_and_target_project_id  (bs_request_id,target_project_id)\n#  index_bs_request_actions_on_source_package                       (source_package)\n#  index_bs_request_actions_on_source_project                       (source_project)\n#  index_bs_request_actions_on_target_package                       (target_package)\n#  index_bs_request_actions_on_target_package_id                    (target_package_id)\n#  index_bs_request_actions_on_target_project                       (target_project)\n#  index_bs_request_actions_on_target_project_id                    (target_project_id)\n#\n# Foreign Keys\n#\n#  bs_request_actions_ibfk_1  (bs_request_id => bs_requests.id)\n#\n"], "filenames": ["src/api/app/models/bs_request_action_submit.rb"], "buggy_code_start_loc": [118], "buggy_code_end_loc": [120], "fixing_code_start_loc": [118], "fixing_code_end_loc": [123], "type": "CWE-732", "message": "openSUSE openbuildservice before 9.2.4 allowed authenticated users to delete packages on specific projects with project links.", "other": {"cve": {"id": "CVE-2018-12466", "sourceIdentifier": "meissner@suse.de", "published": "2018-08-01T15:29:00.283", "lastModified": "2019-10-09T23:33:59.153", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "openSUSE openbuildservice before 9.2.4 allowed authenticated users to delete packages on specific projects with project links."}, {"lang": "es", "value": "CVE-2018-12466\topenSUSE openbuildservice en versiones anteriores a la 9.2.4 permit\u00eda que usuarios autenticados eliminasen paquetes en proyectos espec\u00edficos con enlaces de proyecto."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "meissner@suse.de", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:L/UI:R/S:U/C:N/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 4.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-732"}]}, {"source": "meissner@suse.de", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-285"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensuse:open_build_service:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.2.4", "matchCriteriaId": "C211AE32-6577-4FBB-960B-29330C964E15"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/104958", "source": "meissner@suse.de", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.suse.com/show_bug.cgi?id=CVE-2018-12466", "source": "meissner@suse.de", "tags": ["Exploit", "Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/openSUSE/open-build-service/commit/f57b660f49f830006766a8d4abc3b4af6e178063", "source": "meissner@suse.de", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openSUSE/open-build-service/commit/f57b660f49f830006766a8d4abc3b4af6e178063"}}