{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * indent.c: Indentation related functions\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_VARTABS) || defined(PROTO)\n\n/*\n * Set the integer values corresponding to the string setting of 'vartabstop'.\n * \"array\" will be set, caller must free it if needed.\n * Return FAIL for an error.\n */\n    int\ntabstop_set(char_u *var, int **array)\n{\n    int\t    valcount = 1;\n    int\t    t;\n    char_u  *cp;\n\n    if (var[0] == NUL || (var[0] == '0' && var[1] == NUL))\n    {\n\t*array = NULL;\n\treturn OK;\n    }\n\n    for (cp = var; *cp != NUL; ++cp)\n    {\n\tif (cp == var || cp[-1] == ',')\n\t{\n\t    char_u *end;\n\n\t    if (strtol((char *)cp, (char **)&end, 10) <= 0)\n\t    {\n\t\tif (cp != end)\n\t\t    emsg(_(e_argument_must_be_positive));\n\t\telse\n\t\t    semsg(_(e_invalid_argument_str), cp);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\tif (VIM_ISDIGIT(*cp))\n\t    continue;\n\tif (cp[0] == ',' && cp > var && cp[-1] != ',' && cp[1] != NUL)\n\t{\n\t    ++valcount;\n\t    continue;\n\t}\n\tsemsg(_(e_invalid_argument_str), var);\n\treturn FAIL;\n    }\n\n    *array = ALLOC_MULT(int, valcount + 1);\n    if (*array == NULL)\n\treturn FAIL;\n    (*array)[0] = valcount;\n\n    t = 1;\n    for (cp = var; *cp != NUL;)\n    {\n\tint n = atoi((char *)cp);\n\n\t// Catch negative values, overflow and ridiculous big values.\n\tif (n < 0 || n > 9999)\n\t{\n\t    semsg(_(e_invalid_argument_str), cp);\n\t    vim_free(*array);\n\t    *array = NULL;\n\t    return FAIL;\n\t}\n\t(*array)[t++] = n;\n\twhile (*cp != NUL && *cp != ',')\n\t    ++cp;\n\tif (*cp != NUL)\n\t    ++cp;\n    }\n\n    return OK;\n}\n\n/*\n * Calculate the number of screen spaces a tab will occupy.\n * If \"vts\" is set then the tab widths are taken from that array,\n * otherwise the value of ts is used.\n */\n    int\ntabstop_padding(colnr_T col, int ts_arg, int *vts)\n{\n    int\t\tts = ts_arg == 0 ? 8 : ts_arg;\n    int\t\ttabcount;\n    colnr_T\ttabcol = 0;\n    int\t\tt;\n    int\t\tpadding = 0;\n\n    if (vts == NULL || vts[0] == 0)\n\treturn ts - (col % ts);\n\n    tabcount = vts[0];\n\n    for (t = 1; t <= tabcount; ++t)\n    {\n\ttabcol += vts[t];\n\tif (tabcol > col)\n\t{\n\t    padding = (int)(tabcol - col);\n\t    break;\n\t}\n    }\n    if (t > tabcount)\n\tpadding = vts[tabcount] - (int)((col - tabcol) % vts[tabcount]);\n\n    return padding;\n}\n\n/*\n * Find the size of the tab that covers a particular column.\n */\n    int\ntabstop_at(colnr_T col, int ts, int *vts)\n{\n    int\t\ttabcount;\n    colnr_T\ttabcol = 0;\n    int\t\tt;\n    int\t\ttab_size = 0;\n\n    if (vts == 0 || vts[0] == 0)\n\treturn ts;\n\n    tabcount = vts[0];\n    for (t = 1; t <= tabcount; ++t)\n    {\n\ttabcol += vts[t];\n\tif (tabcol > col)\n\t{\n\t    tab_size = vts[t];\n\t    break;\n\t}\n    }\n    if (t > tabcount)\n\ttab_size = vts[tabcount];\n\n    return tab_size;\n}\n\n/*\n * Find the column on which a tab starts.\n */\n    colnr_T\ntabstop_start(colnr_T col, int ts, int *vts)\n{\n    int\t\ttabcount;\n    colnr_T\ttabcol = 0;\n    int\t\tt;\n    int         excess;\n\n    if (vts == NULL || vts[0] == 0)\n\treturn (col / ts) * ts;\n\n    tabcount = vts[0];\n    for (t = 1; t <= tabcount; ++t)\n    {\n\ttabcol += vts[t];\n\tif (tabcol > col)\n\t    return tabcol - vts[t];\n    }\n\n    excess = tabcol % vts[tabcount];\n    return excess + ((col - excess) / vts[tabcount]) * vts[tabcount];\n}\n\n/*\n * Find the number of tabs and spaces necessary to get from one column\n * to another.\n */\n    void\ntabstop_fromto(\n\tcolnr_T start_col,\n\tcolnr_T end_col,\n\tint\tts_arg,\n\tint\t*vts,\n\tint\t*ntabs,\n\tint\t*nspcs)\n{\n    int\t\tspaces = end_col - start_col;\n    colnr_T\ttabcol = 0;\n    int\t\tpadding = 0;\n    int\t\ttabcount;\n    int\t\tt;\n    int\t\tts = ts_arg == 0 ? curbuf->b_p_ts : ts_arg;\n\n    if (vts == NULL || vts[0] == 0)\n    {\n\tint tabs = 0;\n\tint initspc = 0;\n\n\tinitspc = ts - (start_col % ts);\n\tif (spaces >= initspc)\n\t{\n\t    spaces -= initspc;\n\t    tabs++;\n\t}\n\ttabs += spaces / ts;\n\tspaces -= (spaces / ts) * ts;\n\n\t*ntabs = tabs;\n\t*nspcs = spaces;\n\treturn;\n    }\n\n    // Find the padding needed to reach the next tabstop.\n    tabcount = vts[0];\n    for (t = 1; t <= tabcount; ++t)\n    {\n\ttabcol += vts[t];\n\tif (tabcol > start_col)\n\t{\n\t    padding = (int)(tabcol - start_col);\n\t    break;\n\t}\n    }\n    if (t > tabcount)\n\tpadding = vts[tabcount] - (int)((start_col - tabcol) % vts[tabcount]);\n\n    // If the space needed is less than the padding no tabs can be used.\n    if (spaces < padding)\n    {\n\t*ntabs = 0;\n\t*nspcs = spaces;\n\treturn;\n    }\n\n    *ntabs = 1;\n    spaces -= padding;\n\n    // At least one tab has been used. See if any more will fit.\n    while (spaces != 0 && ++t <= tabcount)\n    {\n\tpadding = vts[t];\n\tif (spaces < padding)\n\t{\n\t    *nspcs = spaces;\n\t    return;\n\t}\n\t++*ntabs;\n\tspaces -= padding;\n    }\n\n    *ntabs += spaces / vts[tabcount];\n    *nspcs =  spaces % vts[tabcount];\n}\n\n/*\n * See if two tabstop arrays contain the same values.\n */\n    static int\ntabstop_eq(int *ts1, int *ts2)\n{\n    int\t\tt;\n\n    if ((ts1 == 0 && ts2) || (ts1 && ts2 == 0))\n\treturn FALSE;\n    if (ts1 == ts2)\n\treturn TRUE;\n    if (ts1[0] != ts2[0])\n\treturn FALSE;\n\n    for (t = 1; t <= ts1[0]; ++t)\n\tif (ts1[t] != ts2[t])\n\t    return FALSE;\n\n    return TRUE;\n}\n\n# if defined(FEAT_BEVAL) || defined(PROTO)\n/*\n * Copy a tabstop array, allocating space for the new array.\n */\n    int *\ntabstop_copy(int *oldts)\n{\n    int\t\t*newts;\n    int\t\tt;\n\n    if (oldts == NULL)\n\treturn NULL;\n    newts = ALLOC_MULT(int, oldts[0] + 1);\n    if (newts != NULL)\n\tfor (t = 0; t <= oldts[0]; ++t)\n\t    newts[t] = oldts[t];\n    return newts;\n}\n# endif\n\n/*\n * Return a count of the number of tabstops.\n */\n    int\ntabstop_count(int *ts)\n{\n    return ts != NULL ? ts[0] : 0;\n}\n\n/*\n * Return the first tabstop, or 8 if there are no tabstops defined.\n */\n    int\ntabstop_first(int *ts)\n{\n    return ts != NULL ? ts[1] : 8;\n}\n\n#endif\n\n/*\n * Return the effective shiftwidth value for current buffer, using the\n * 'tabstop' value when 'shiftwidth' is zero.\n */\n    long\nget_sw_value(buf_T *buf)\n{\n    return get_sw_value_col(buf, 0);\n}\n\n/*\n * Idem, using \"pos\".\n */\n    static long\nget_sw_value_pos(buf_T *buf, pos_T *pos)\n{\n    pos_T save_cursor = curwin->w_cursor;\n    long sw_value;\n\n    curwin->w_cursor = *pos;\n    sw_value = get_sw_value_col(buf, get_nolist_virtcol());\n    curwin->w_cursor = save_cursor;\n    return sw_value;\n}\n\n/*\n * Idem, using the first non-black in the current line.\n */\n    long\nget_sw_value_indent(buf_T *buf)\n{\n    pos_T pos = curwin->w_cursor;\n\n    pos.col = getwhitecols_curline();\n    return get_sw_value_pos(buf, &pos);\n}\n\n/*\n * Idem, using virtual column \"col\".\n */\n    long\nget_sw_value_col(buf_T *buf, colnr_T col UNUSED)\n{\n    return buf->b_p_sw ? buf->b_p_sw :\n#ifdef FEAT_VARTABS\n\ttabstop_at(col, buf->b_p_ts, buf->b_p_vts_array);\n#else\n\tbuf->b_p_ts;\n#endif\n}\n\n/*\n * Return the effective softtabstop value for the current buffer, using the\n * 'shiftwidth' value when 'softtabstop' is negative.\n */\n    long\nget_sts_value(void)\n{\n    return curbuf->b_p_sts < 0 ? get_sw_value(curbuf) : curbuf->b_p_sts;\n}\n\n/*\n * Count the size (in window cells) of the indent in the current line.\n */\n    int\nget_indent(void)\n{\n#ifdef FEAT_VARTABS\n    return get_indent_str_vtab(ml_get_curline(), (int)curbuf->b_p_ts,\n\t\t\t\t\t\t curbuf->b_p_vts_array, FALSE);\n#else\n    return get_indent_str(ml_get_curline(), (int)curbuf->b_p_ts, FALSE);\n#endif\n}\n\n/*\n * Count the size (in window cells) of the indent in line \"lnum\".\n */\n    int\nget_indent_lnum(linenr_T lnum)\n{\n#ifdef FEAT_VARTABS\n    return get_indent_str_vtab(ml_get(lnum), (int)curbuf->b_p_ts,\n\t\t\t\t\t\t curbuf->b_p_vts_array, FALSE);\n#else\n    return get_indent_str(ml_get(lnum), (int)curbuf->b_p_ts, FALSE);\n#endif\n}\n\n#if defined(FEAT_FOLDING) || defined(PROTO)\n/*\n * Count the size (in window cells) of the indent in line \"lnum\" of buffer\n * \"buf\".\n */\n    int\nget_indent_buf(buf_T *buf, linenr_T lnum)\n{\n# ifdef FEAT_VARTABS\n    return get_indent_str_vtab(ml_get_buf(buf, lnum, FALSE),\n\t\t\t       (int)curbuf->b_p_ts, buf->b_p_vts_array, FALSE);\n# else\n    return get_indent_str(ml_get_buf(buf, lnum, FALSE), (int)buf->b_p_ts, FALSE);\n# endif\n}\n#endif\n\n/*\n * count the size (in window cells) of the indent in line \"ptr\", with\n * 'tabstop' at \"ts\"\n */\n    int\nget_indent_str(\n    char_u\t*ptr,\n    int\t\tts,\n    int\t\tlist) // if TRUE, count only screen size for tabs\n{\n    int\t\tcount = 0;\n\n    for ( ; *ptr; ++ptr)\n    {\n\tif (*ptr == TAB)\n\t{\n\t    if (!list || curwin->w_lcs_chars.tab1)\n\t\t// count a tab for what it is worth\n\t\tcount += ts - (count % ts);\n\t    else\n\t\t// In list mode, when tab is not set, count screen char width\n\t\t// for Tab, displays: ^I\n\t\tcount += ptr2cells(ptr);\n\t}\n\telse if (*ptr == ' ')\n\t    ++count;\t\t// count a space for one\n\telse\n\t    break;\n    }\n    return count;\n}\n\n#ifdef FEAT_VARTABS\n/*\n * Count the size (in window cells) of the indent in line \"ptr\", using\n * variable tabstops.\n * if \"list\" is TRUE, count only screen size for tabs.\n */\n    int\nget_indent_str_vtab(char_u *ptr, int ts, int *vts, int list)\n{\n    int\t\tcount = 0;\n\n    for ( ; *ptr; ++ptr)\n    {\n\tif (*ptr == TAB)    // count a tab for what it is worth\n\t{\n\t    if (!list || curwin->w_lcs_chars.tab1)\n\t\tcount += tabstop_padding(count, ts, vts);\n\t    else\n\t\t// In list mode, when tab is not set, count screen char width\n\t\t// for Tab, displays: ^I\n\t\tcount += ptr2cells(ptr);\n\t}\n\telse if (*ptr == ' ')\n\t    ++count;\t\t// count a space for one\n\telse\n\t    break;\n    }\n    return count;\n}\n#endif\n\n/*\n * Set the indent of the current line.\n * Leaves the cursor on the first non-blank in the line.\n * Caller must take care of undo.\n * \"flags\":\n *\tSIN_CHANGED:\tcall changed_bytes() if the line was changed.\n *\tSIN_INSERT:\tinsert the indent in front of the line.\n *\tSIN_UNDO:\tsave line for undo before changing it.\n * Returns TRUE if the line was changed.\n */\n    int\nset_indent(\n    int\t\tsize,\t\t    // measured in spaces\n    int\t\tflags)\n{\n    char_u\t*p;\n    char_u\t*newline;\n    char_u\t*oldline;\n    char_u\t*s;\n    int\t\ttodo;\n    int\t\tind_len;\t    // measured in characters\n    int\t\tline_len;\n    int\t\tdoit = FALSE;\n    int\t\tind_done = 0;\t    // measured in spaces\n#ifdef FEAT_VARTABS\n    int\t\tind_col = 0;\n#endif\n    int\t\ttab_pad;\n    int\t\tretval = FALSE;\n    int\t\torig_char_len = -1; // number of initial whitespace chars when\n\t\t\t\t    // 'et' and 'pi' are both set\n\n    // First check if there is anything to do and compute the number of\n    // characters needed for the indent.\n    todo = size;\n    ind_len = 0;\n    p = oldline = ml_get_curline();\n\n    // Calculate the buffer size for the new indent, and check to see if it\n    // isn't already set\n\n    // if 'expandtab' isn't set: use TABs; if both 'expandtab' and\n    // 'preserveindent' are set count the number of characters at the\n    // beginning of the line to be copied\n    if (!curbuf->b_p_et || (!(flags & SIN_INSERT) && curbuf->b_p_pi))\n    {\n\t// If 'preserveindent' is set then reuse as much as possible of\n\t// the existing indent structure for the new indent\n\tif (!(flags & SIN_INSERT) && curbuf->b_p_pi)\n\t{\n\t    ind_done = 0;\n\n\t    // count as many characters as we can use\n\t    while (todo > 0 && VIM_ISWHITE(*p))\n\t    {\n\t\tif (*p == TAB)\n\t\t{\n#ifdef FEAT_VARTABS\n\t\t    tab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,\n\t\t\t\t\t\t\tcurbuf->b_p_vts_array);\n#else\n\t\t    tab_pad = (int)curbuf->b_p_ts\n\t\t\t\t\t   - (ind_done % (int)curbuf->b_p_ts);\n#endif\n\t\t    // stop if this tab will overshoot the target\n\t\t    if (todo < tab_pad)\n\t\t\tbreak;\n\t\t    todo -= tab_pad;\n\t\t    ++ind_len;\n\t\t    ind_done += tab_pad;\n\t\t}\n\t\telse\n\t\t{\n\t\t    --todo;\n\t\t    ++ind_len;\n\t\t    ++ind_done;\n\t\t}\n\t\t++p;\n\t    }\n\n#ifdef FEAT_VARTABS\n\t    // These diverge from this point.\n\t    ind_col = ind_done;\n#endif\n\t    // Set initial number of whitespace chars to copy if we are\n\t    // preserving indent but expandtab is set\n\t    if (curbuf->b_p_et)\n\t\torig_char_len = ind_len;\n\n\t    // Fill to next tabstop with a tab, if possible\n#ifdef FEAT_VARTABS\n\t    tab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,\n\t\t\t\t\t\tcurbuf->b_p_vts_array);\n#else\n\t    tab_pad = (int)curbuf->b_p_ts - (ind_done % (int)curbuf->b_p_ts);\n#endif\n\t    if (todo >= tab_pad && orig_char_len == -1)\n\t    {\n\t\tdoit = TRUE;\n\t\ttodo -= tab_pad;\n\t\t++ind_len;\n\t\t// ind_done += tab_pad;\n#ifdef FEAT_VARTABS\n\t\tind_col += tab_pad;\n#endif\n\t    }\n\t}\n\n\t// count tabs required for indent\n#ifdef FEAT_VARTABS\n\tfor (;;)\n\t{\n\t    tab_pad = tabstop_padding(ind_col, curbuf->b_p_ts,\n\t\t\t\t\t\t\tcurbuf->b_p_vts_array);\n\t    if (todo < tab_pad)\n\t\tbreak;\n\t    if (*p != TAB)\n\t\tdoit = TRUE;\n\t    else\n\t\t++p;\n\t    todo -= tab_pad;\n\t    ++ind_len;\n\t    ind_col += tab_pad;\n\t}\n#else\n\twhile (todo >= (int)curbuf->b_p_ts)\n\t{\n\t    if (*p != TAB)\n\t\tdoit = TRUE;\n\t    else\n\t\t++p;\n\t    todo -= (int)curbuf->b_p_ts;\n\t    ++ind_len;\n\t    // ind_done += (int)curbuf->b_p_ts;\n\t}\n#endif\n    }\n    // count spaces required for indent\n    while (todo > 0)\n    {\n\tif (*p != ' ')\n\t    doit = TRUE;\n\telse\n\t    ++p;\n\t--todo;\n\t++ind_len;\n\t// ++ind_done;\n    }\n\n    // Return if the indent is OK already.\n    if (!doit && !VIM_ISWHITE(*p) && !(flags & SIN_INSERT))\n\treturn FALSE;\n\n    // Allocate memory for the new line.\n    if (flags & SIN_INSERT)\n\tp = oldline;\n    else\n\tp = skipwhite(p);\n    line_len = (int)STRLEN(p) + 1;\n\n    // If 'preserveindent' and 'expandtab' are both set keep the original\n    // characters and allocate accordingly.  We will fill the rest with spaces\n    // after the if (!curbuf->b_p_et) below.\n    if (orig_char_len != -1)\n    {\n\tnewline = alloc(orig_char_len + size - ind_done + line_len);\n\tif (newline == NULL)\n\t    return FALSE;\n\ttodo = size - ind_done;\n\tind_len = orig_char_len + todo;    // Set total length of indent in\n\t\t\t\t\t   // characters, which may have been\n\t\t\t\t\t   // undercounted until now\n\tp = oldline;\n\ts = newline;\n\twhile (orig_char_len > 0)\n\t{\n\t    *s++ = *p++;\n\t    orig_char_len--;\n\t}\n\n\t// Skip over any additional white space (useful when newindent is less\n\t// than old)\n\twhile (VIM_ISWHITE(*p))\n\t    ++p;\n\n    }\n    else\n    {\n\ttodo = size;\n\tnewline = alloc(ind_len + line_len);\n\tif (newline == NULL)\n\t    return FALSE;\n\ts = newline;\n    }\n\n    // Put the characters in the new line.\n    // if 'expandtab' isn't set: use TABs\n    if (!curbuf->b_p_et)\n    {\n\t// If 'preserveindent' is set then reuse as much as possible of\n\t// the existing indent structure for the new indent\n\tif (!(flags & SIN_INSERT) && curbuf->b_p_pi)\n\t{\n\t    p = oldline;\n\t    ind_done = 0;\n\n\t    while (todo > 0 && VIM_ISWHITE(*p))\n\t    {\n\t\tif (*p == TAB)\n\t\t{\n#ifdef FEAT_VARTABS\n\t\t    tab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,\n\t\t\t\t\t\t\tcurbuf->b_p_vts_array);\n#else\n\t\t    tab_pad = (int)curbuf->b_p_ts\n\t\t\t\t\t   - (ind_done % (int)curbuf->b_p_ts);\n#endif\n\t\t    // stop if this tab will overshoot the target\n\t\t    if (todo < tab_pad)\n\t\t\tbreak;\n\t\t    todo -= tab_pad;\n\t\t    ind_done += tab_pad;\n\t\t}\n\t\telse\n\t\t{\n\t\t    --todo;\n\t\t    ++ind_done;\n\t\t}\n\t\t*s++ = *p++;\n\t    }\n\n\t    // Fill to next tabstop with a tab, if possible\n#ifdef FEAT_VARTABS\n\t    tab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,\n\t\t\t\t\t\tcurbuf->b_p_vts_array);\n#else\n\t    tab_pad = (int)curbuf->b_p_ts - (ind_done % (int)curbuf->b_p_ts);\n#endif\n\t    if (todo >= tab_pad)\n\t    {\n\t\t*s++ = TAB;\n\t\ttodo -= tab_pad;\n#ifdef FEAT_VARTABS\n\t\tind_done += tab_pad;\n#endif\n\t    }\n\n\t    p = skipwhite(p);\n\t}\n\n#ifdef FEAT_VARTABS\n\tfor (;;)\n\t{\n\t    tab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,\n\t\t\t\t\t\t\tcurbuf->b_p_vts_array);\n\t    if (todo < tab_pad)\n\t\tbreak;\n\t    *s++ = TAB;\n\t    todo -= tab_pad;\n\t    ind_done += tab_pad;\n\t}\n#else\n\twhile (todo >= (int)curbuf->b_p_ts)\n\t{\n\t    *s++ = TAB;\n\t    todo -= (int)curbuf->b_p_ts;\n\t}\n#endif\n    }\n    while (todo > 0)\n    {\n\t*s++ = ' ';\n\t--todo;\n    }\n    mch_memmove(s, p, (size_t)line_len);\n\n    // Replace the line (unless undo fails).\n    if (!(flags & SIN_UNDO) || u_savesub(curwin->w_cursor.lnum) == OK)\n    {\n\tcolnr_T old_offset = (colnr_T)(p - oldline);\n\tcolnr_T new_offset = (colnr_T)(s - newline);\n\n\t// this may free \"newline\"\n\tml_replace(curwin->w_cursor.lnum, newline, FALSE);\n\tif (flags & SIN_CHANGED)\n\t    changed_bytes(curwin->w_cursor.lnum, 0);\n\n\t// Correct saved cursor position if it is in this line.\n\tif (saved_cursor.lnum == curwin->w_cursor.lnum)\n\t{\n\t    if (saved_cursor.col >= old_offset)\n\t\t// cursor was after the indent, adjust for the number of\n\t\t// bytes added/removed\n\t\tsaved_cursor.col += ind_len - old_offset;\n\t    else if (saved_cursor.col >= new_offset)\n\t\t// cursor was in the indent, and is now after it, put it back\n\t\t// at the start of the indent (replacing spaces with TAB)\n\t\tsaved_cursor.col = new_offset;\n\t}\n#ifdef FEAT_PROP_POPUP\n\t{\n\t    int added = ind_len - old_offset;\n\n\t    // When increasing indent this behaves like spaces were inserted at\n\t    // the old indent, when decreasing indent it behaves like spaces\n\t    // were deleted at the new indent.\n\t    adjust_prop_columns(curwin->w_cursor.lnum,\n\t\t\t  added > 0 ? old_offset : (colnr_T)ind_len, added, 0);\n\t}\n#endif\n\tretval = TRUE;\n    }\n    else\n\tvim_free(newline);\n\n    curwin->w_cursor.col = ind_len;\n    return retval;\n}\n\n/*\n * Return the indent of the current line after a number.  Return -1 if no\n * number was found.  Used for 'n' in 'formatoptions': numbered list.\n * Since a pattern is used it can actually handle more than numbers.\n */\n    int\nget_number_indent(linenr_T lnum)\n{\n    colnr_T\tcol;\n    pos_T\tpos;\n\n    regmatch_T\tregmatch;\n    int\t\tlead_len = 0;\t// length of comment leader\n\n    if (lnum > curbuf->b_ml.ml_line_count)\n\treturn -1;\n    pos.lnum = 0;\n\n    // In format_lines() (i.e. not insert mode), fo+=q is needed too...\n    if ((State & INSERT) || has_format_option(FO_Q_COMS))\n\tlead_len = get_leader_len(ml_get(lnum), NULL, FALSE, TRUE);\n\n    regmatch.regprog = vim_regcomp(curbuf->b_p_flp, RE_MAGIC);\n    if (regmatch.regprog != NULL)\n    {\n\tregmatch.rm_ic = FALSE;\n\n\t// vim_regexec() expects a pointer to a line.  This lets us\n\t// start matching for the flp beyond any comment leader...\n\tif (vim_regexec(&regmatch, ml_get(lnum) + lead_len, (colnr_T)0))\n\t{\n\t    pos.lnum = lnum;\n\t    pos.col = (colnr_T)(*regmatch.endp - ml_get(lnum));\n\t    pos.coladd = 0;\n\t}\n\tvim_regfree(regmatch.regprog);\n    }\n\n    if (pos.lnum == 0 || *ml_get_pos(&pos) == NUL)\n\treturn -1;\n    getvcol(curwin, &pos, &col, NULL, NULL);\n    return (int)col;\n}\n\n#if defined(FEAT_LINEBREAK) || defined(PROTO)\n/*\n * This is called when 'breakindentopt' is changed and when a window is\n * initialized.\n */\n    int\nbriopt_check(win_T *wp)\n{\n    char_u\t*p;\n    int\t\tbri_shift = 0;\n    long\tbri_min = 20;\n    int\t\tbri_sbr = FALSE;\n    int\t\tbri_list = 0;\n\n    p = wp->w_p_briopt;\n    while (*p != NUL)\n    {\n\tif (STRNCMP(p, \"shift:\", 6) == 0\n\t\t && ((p[6] == '-' && VIM_ISDIGIT(p[7])) || VIM_ISDIGIT(p[6])))\n\t{\n\t    p += 6;\n\t    bri_shift = getdigits(&p);\n\t}\n\telse if (STRNCMP(p, \"min:\", 4) == 0 && VIM_ISDIGIT(p[4]))\n\t{\n\t    p += 4;\n\t    bri_min = getdigits(&p);\n\t}\n\telse if (STRNCMP(p, \"sbr\", 3) == 0)\n\t{\n\t    p += 3;\n\t    bri_sbr = TRUE;\n\t}\n\telse if (STRNCMP(p, \"list:\", 5) == 0)\n\t{\n\t    p += 5;\n\t    bri_list = getdigits(&p);\n\t}\n\tif (*p != ',' && *p != NUL)\n\t    return FAIL;\n\tif (*p == ',')\n\t    ++p;\n    }\n\n    wp->w_briopt_shift = bri_shift;\n    wp->w_briopt_min   = bri_min;\n    wp->w_briopt_sbr   = bri_sbr;\n    wp->w_briopt_list  = bri_list;\n\n    return OK;\n}\n\n/*\n * Return appropriate space number for breakindent, taking influencing\n * parameters into account. Window must be specified, since it is not\n * necessarily always the current one.\n */\n    int\nget_breakindent_win(\n    win_T\t*wp,\n    char_u\t*line) // start of the line\n{\n    static int\t    prev_indent = 0;\t// cached indent value\n    static long\t    prev_ts     = 0L;\t// cached tabstop value\n    static char_u   *prev_line = NULL;\t// cached pointer to line\n    static varnumber_T prev_tick = 0;   // changedtick of cached value\n# ifdef FEAT_VARTABS\n    static int      *prev_vts = NULL;   // cached vartabs values\n# endif\n    static int      prev_list = 0;\t// cached list value\n    static int      prev_listopt = 0;\t// cached w_p_briopt_list value\n    // cached formatlistpat value\n    static char_u   *prev_flp = NULL;\n    int\t\t    bri = 0;\n    // window width minus window margin space, i.e. what rests for text\n    const int\t    eff_wwidth = wp->w_width\n\t\t\t    - ((wp->w_p_nu || wp->w_p_rnu)\n\t\t\t\t&& (vim_strchr(p_cpo, CPO_NUMCOL) == NULL)\n\t\t\t\t\t\t? number_width(wp) + 1 : 0);\n\n    // used cached indent, unless\n    // - line pointer changed\n    // - 'tabstop' changed\n    // - 'briopt_list changed' changed or\n    // - 'formatlistpattern' changed\n    if (prev_line != line || prev_ts != wp->w_buffer->b_p_ts\n\t    || prev_tick != CHANGEDTICK(wp->w_buffer)\n\t    || prev_listopt != wp->w_briopt_list\n\t    || (prev_flp == NULL\n\t\t|| (STRCMP(prev_flp, get_flp_value(wp->w_buffer)) != 0))\n# ifdef FEAT_VARTABS\n\t    || prev_vts != wp->w_buffer->b_p_vts_array\n# endif\n\t)\n    {\n\tprev_line = line;\n\tprev_ts = wp->w_buffer->b_p_ts;\n\tprev_tick = CHANGEDTICK(wp->w_buffer);\n# ifdef FEAT_VARTABS\n\tprev_vts = wp->w_buffer->b_p_vts_array;\n\tprev_indent = get_indent_str_vtab(line,\n\t\t\t\t     (int)wp->w_buffer->b_p_ts,\n\t\t\t\t    wp->w_buffer->b_p_vts_array, wp->w_p_list);\n# else\n\tprev_indent = get_indent_str(line,\n\t\t\t\t     (int)wp->w_buffer->b_p_ts, wp->w_p_list);\n# endif\n\tprev_listopt = wp->w_briopt_list;\n\tprev_list = 0;\n\tvim_free(prev_flp);\n\tprev_flp = vim_strsave(get_flp_value(wp->w_buffer));\n\t// add additional indent for numbered lists\n\tif (wp->w_briopt_list != 0)\n\t{\n\t    regmatch_T\t    regmatch;\n\n\t    regmatch.regprog = vim_regcomp(prev_flp,\n\t\t\t\t   RE_MAGIC + RE_STRING + RE_AUTO + RE_STRICT);\n\n\t    if (regmatch.regprog != NULL)\n\t    {\n\t\tregmatch.rm_ic = FALSE;\n\t\tif (vim_regexec(&regmatch, line, 0))\n\t\t{\n\t\t    if (wp->w_briopt_list > 0)\n\t\t\tprev_list = wp->w_briopt_list;\n\t\t    else\n\t\t\tprev_list = (*regmatch.endp - *regmatch.startp);\n\t\t}\n\t\tvim_regfree(regmatch.regprog);\n\t    }\n\t}\n    }\n    bri = prev_indent + wp->w_briopt_shift;\n\n    // Add offset for number column, if 'n' is in 'cpoptions'\n    bri += win_col_off2(wp);\n\n    // add additional indent for numbered lists\n    if (wp->w_briopt_list != 0)\n    {\n\tif (wp->w_briopt_list > 0)\n\t    bri += prev_list;\n\telse\n\t    bri = prev_list;\n    }\n\n    // indent minus the length of the showbreak string\n    if (wp->w_briopt_sbr)\n\tbri -= vim_strsize(get_showbreak_value(wp));\n\n\n    // never indent past left window margin\n    if (bri < 0)\n\tbri = 0;\n\n    // always leave at least bri_min characters on the left,\n    // if text width is sufficient\n    else if (bri > eff_wwidth - wp->w_briopt_min)\n\tbri = (eff_wwidth - wp->w_briopt_min < 0)\n\t\t\t\t\t   ? 0 : eff_wwidth - wp->w_briopt_min;\n\n    return bri;\n}\n#endif\n\n/*\n * When extra == 0: Return TRUE if the cursor is before or on the first\n *\t\t    non-blank in the line.\n * When extra == 1: Return TRUE if the cursor is before the first non-blank in\n *\t\t    the line.\n */\n    int\ninindent(int extra)\n{\n    char_u\t*ptr;\n    colnr_T\tcol;\n\n    for (col = 0, ptr = ml_get_curline(); VIM_ISWHITE(*ptr); ++col)\n\t++ptr;\n    if (col >= curwin->w_cursor.col + extra)\n\treturn TRUE;\n    else\n\treturn FALSE;\n}\n\n#if defined(FEAT_LISP) || defined(FEAT_CINDENT) || defined(PROTO)\n/*\n * op_reindent - handle reindenting a block of lines.\n */\n    void\nop_reindent(oparg_T *oap, int (*how)(void))\n{\n    long\ti;\n    char_u\t*l;\n    int\t\tamount;\n    linenr_T\tfirst_changed = 0;\n    linenr_T\tlast_changed = 0;\n    linenr_T\tstart_lnum = curwin->w_cursor.lnum;\n\n    // Don't even try when 'modifiable' is off.\n    if (!curbuf->b_p_ma)\n    {\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\treturn;\n    }\n\n    for (i = oap->line_count; --i >= 0 && !got_int; )\n    {\n\t// it's a slow thing to do, so give feedback so there's no worry that\n\t// the computer's just hung.\n\n\tif (i > 1\n\t\t&& (i % 50 == 0 || i == oap->line_count - 1)\n\t\t&& oap->line_count > p_report)\n\t    smsg(_(\"%ld lines to indent... \"), i);\n\n\t// Be vi-compatible: For lisp indenting the first line is not\n\t// indented, unless there is only one line.\n# ifdef FEAT_LISP\n\tif (i != oap->line_count - 1 || oap->line_count == 1\n\t\t\t\t\t\t    || how != get_lisp_indent)\n# endif\n\t{\n\t    l = skipwhite(ml_get_curline());\n\t    if (*l == NUL)\t\t    // empty or blank line\n\t\tamount = 0;\n\t    else\n\t\tamount = how();\t\t    // get the indent for this line\n\n\t    if (amount >= 0 && set_indent(amount, SIN_UNDO))\n\t    {\n\t\t// did change the indent, call changed_lines() later\n\t\tif (first_changed == 0)\n\t\t    first_changed = curwin->w_cursor.lnum;\n\t\tlast_changed = curwin->w_cursor.lnum;\n\t    }\n\t}\n\t++curwin->w_cursor.lnum;\n\tcurwin->w_cursor.col = 0;  // make sure it's valid\n    }\n\n    // put cursor on first non-blank of indented line\n    curwin->w_cursor.lnum = start_lnum;\n    beginline(BL_SOL | BL_FIX);\n\n    // Mark changed lines so that they will be redrawn.  When Visual\n    // highlighting was present, need to continue until the last line.  When\n    // there is no change still need to remove the Visual highlighting.\n    if (last_changed != 0)\n\tchanged_lines(first_changed, 0,\n\t\toap->is_VIsual ? start_lnum + oap->line_count :\n\t\tlast_changed + 1, 0L);\n    else if (oap->is_VIsual)\n\tredraw_curbuf_later(INVERTED);\n\n    if (oap->line_count > p_report)\n    {\n\ti = oap->line_count - (i + 1);\n\tsmsg(NGETTEXT(\"%ld line indented \",\n\t\t\t\t\t\t \"%ld lines indented \", i), i);\n    }\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// set '[ and '] marks\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end = oap->end;\n    }\n}\n#endif // defined(FEAT_LISP) || defined(FEAT_CINDENT)\n\n#if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT) || defined(PROTO)\n/*\n * Return TRUE if lines starting with '#' should be left aligned.\n */\n    int\npreprocs_left(void)\n{\n    return\n# ifdef FEAT_SMARTINDENT\n#  ifdef FEAT_CINDENT\n\t(curbuf->b_p_si && !curbuf->b_p_cin) ||\n#  else\n\tcurbuf->b_p_si\n#  endif\n# endif\n# ifdef FEAT_CINDENT\n\t(curbuf->b_p_cin && in_cinkeys('#', ' ', TRUE)\n\t\t\t\t\t   && curbuf->b_ind_hash_comment == 0)\n# endif\n\t;\n}\n#endif\n\n#ifdef FEAT_SMARTINDENT\n/*\n * Try to do some very smart auto-indenting.\n * Used when inserting a \"normal\" character.\n */\n    void\nins_try_si(int c)\n{\n    pos_T\t*pos, old_pos;\n    char_u\t*ptr;\n    int\t\ti;\n    int\t\ttemp;\n\n    // do some very smart indenting when entering '{' or '}'\n    if (((did_si || can_si_back) && c == '{') || (can_si && c == '}'))\n    {\n\t// for '}' set indent equal to indent of line containing matching '{'\n\tif (c == '}' && (pos = findmatch(NULL, '{')) != NULL)\n\t{\n\t    old_pos = curwin->w_cursor;\n\t    // If the matching '{' has a ')' immediately before it (ignoring\n\t    // white-space), then line up with the start of the line\n\t    // containing the matching '(' if there is one.  This handles the\n\t    // case where an \"if (..\\n..) {\" statement continues over multiple\n\t    // lines -- webb\n\t    ptr = ml_get(pos->lnum);\n\t    i = pos->col;\n\t    if (i > 0)\t\t// skip blanks before '{'\n\t\twhile (--i > 0 && VIM_ISWHITE(ptr[i]))\n\t\t    ;\n\t    curwin->w_cursor.lnum = pos->lnum;\n\t    curwin->w_cursor.col = i;\n\t    if (ptr[i] == ')' && (pos = findmatch(NULL, '(')) != NULL)\n\t\tcurwin->w_cursor = *pos;\n\t    i = get_indent();\n\t    curwin->w_cursor = old_pos;\n\t    if (State & VREPLACE_FLAG)\n\t\tchange_indent(INDENT_SET, i, FALSE, NUL, TRUE);\n\t    else\n\t\t(void)set_indent(i, SIN_CHANGED);\n\t}\n\telse if (curwin->w_cursor.col > 0)\n\t{\n\t    // when inserting '{' after \"O\" reduce indent, but not\n\t    // more than indent of previous line\n\t    temp = TRUE;\n\t    if (c == '{' && can_si_back && curwin->w_cursor.lnum > 1)\n\t    {\n\t\told_pos = curwin->w_cursor;\n\t\ti = get_indent();\n\t\twhile (curwin->w_cursor.lnum > 1)\n\t\t{\n\t\t    ptr = skipwhite(ml_get(--(curwin->w_cursor.lnum)));\n\n\t\t    // ignore empty lines and lines starting with '#'.\n\t\t    if (*ptr != '#' && *ptr != NUL)\n\t\t\tbreak;\n\t\t}\n\t\tif (get_indent() >= i)\n\t\t    temp = FALSE;\n\t\tcurwin->w_cursor = old_pos;\n\t    }\n\t    if (temp)\n\t\tshift_line(TRUE, FALSE, 1, TRUE);\n\t}\n    }\n\n    // set indent of '#' always to 0\n    if (curwin->w_cursor.col > 0 && can_si && c == '#')\n    {\n\t// remember current indent for next line\n\told_indent = get_indent();\n\t(void)set_indent(0, SIN_CHANGED);\n    }\n\n    // Adjust ai_col, the char at this position can be deleted.\n    if (ai_col > curwin->w_cursor.col)\n\tai_col = curwin->w_cursor.col;\n}\n#endif\n\n/*\n * Insert an indent (for <Tab> or CTRL-T) or delete an indent (for CTRL-D).\n * Keep the cursor on the same character.\n * type == INDENT_INC\tincrease indent (for CTRL-T or <Tab>)\n * type == INDENT_DEC\tdecrease indent (for CTRL-D)\n * type == INDENT_SET\tset indent to \"amount\"\n * if round is TRUE, round the indent to 'shiftwidth' (only with _INC and _Dec).\n */\n    void\nchange_indent(\n    int\t\ttype,\n    int\t\tamount,\n    int\t\tround,\n    int\t\treplaced,\t// replaced character, put on replace stack\n    int\t\tcall_changed_bytes)\t// call changed_bytes()\n{\n    int\t\tvcol;\n    int\t\tlast_vcol;\n    int\t\tinsstart_less;\t\t// reduction for Insstart.col\n    int\t\tnew_cursor_col;\n    int\t\ti;\n    char_u\t*ptr;\n    int\t\tsave_p_list;\n    int\t\tstart_col;\n    colnr_T\tvc;\n    colnr_T\torig_col = 0;\t\t// init for GCC\n    char_u\t*new_line, *orig_line = NULL;\t// init for GCC\n\n    // VREPLACE mode needs to know what the line was like before changing\n    if (State & VREPLACE_FLAG)\n    {\n\torig_line = vim_strsave(ml_get_curline());  // Deal with NULL below\n\torig_col = curwin->w_cursor.col;\n    }\n\n    // for the following tricks we don't want list mode\n    save_p_list = curwin->w_p_list;\n    curwin->w_p_list = FALSE;\n    vc = getvcol_nolist(&curwin->w_cursor);\n    vcol = vc;\n\n    // For Replace mode we need to fix the replace stack later, which is only\n    // possible when the cursor is in the indent.  Remember the number of\n    // characters before the cursor if it's possible.\n    start_col = curwin->w_cursor.col;\n\n    // determine offset from first non-blank\n    new_cursor_col = curwin->w_cursor.col;\n    beginline(BL_WHITE);\n    new_cursor_col -= curwin->w_cursor.col;\n\n    insstart_less = curwin->w_cursor.col;\n\n    // If the cursor is in the indent, compute how many screen columns the\n    // cursor is to the left of the first non-blank.\n    if (new_cursor_col < 0)\n\tvcol = get_indent() - vcol;\n\n    if (new_cursor_col > 0)\t    // can't fix replace stack\n\tstart_col = -1;\n\n    // Set the new indent.  The cursor will be put on the first non-blank.\n    if (type == INDENT_SET)\n\t(void)set_indent(amount, call_changed_bytes ? SIN_CHANGED : 0);\n    else\n    {\n\tint\tsave_State = State;\n\n\t// Avoid being called recursively.\n\tif (State & VREPLACE_FLAG)\n\t    State = INSERT;\n\tshift_line(type == INDENT_DEC, round, 1, call_changed_bytes);\n\tState = save_State;\n    }\n    insstart_less -= curwin->w_cursor.col;\n\n    // Try to put cursor on same character.\n    // If the cursor is at or after the first non-blank in the line,\n    // compute the cursor column relative to the column of the first\n    // non-blank character.\n    // If we are not in insert mode, leave the cursor on the first non-blank.\n    // If the cursor is before the first non-blank, position it relative\n    // to the first non-blank, counted in screen columns.\n    if (new_cursor_col >= 0)\n    {\n\t// When changing the indent while the cursor is touching it, reset\n\t// Insstart_col to 0.\n\tif (new_cursor_col == 0)\n\t    insstart_less = MAXCOL;\n\tnew_cursor_col += curwin->w_cursor.col;\n    }\n    else if (!(State & INSERT))\n\tnew_cursor_col = curwin->w_cursor.col;\n    else\n    {\n\t// Compute the screen column where the cursor should be.\n\tvcol = get_indent() - vcol;\n\tcurwin->w_virtcol = (colnr_T)((vcol < 0) ? 0 : vcol);\n\n\t// Advance the cursor until we reach the right screen column.\n\tvcol = last_vcol = 0;\n\tnew_cursor_col = -1;\n\tptr = ml_get_curline();\n\twhile (vcol <= (int)curwin->w_virtcol)\n\t{\n\t    last_vcol = vcol;\n\t    if (has_mbyte && new_cursor_col >= 0)\n\t\tnew_cursor_col += (*mb_ptr2len)(ptr + new_cursor_col);\n\t    else\n\t\t++new_cursor_col;\n\t    vcol += lbr_chartabsize(ptr, ptr + new_cursor_col, (colnr_T)vcol);\n\t}\n\tvcol = last_vcol;\n\n\t// May need to insert spaces to be able to position the cursor on\n\t// the right screen column.\n\tif (vcol != (int)curwin->w_virtcol)\n\t{\n\t    curwin->w_cursor.col = (colnr_T)new_cursor_col;\n\t    i = (int)curwin->w_virtcol - vcol;\n\t    ptr = alloc(i + 1);\n\t    if (ptr != NULL)\n\t    {\n\t\tnew_cursor_col += i;\n\t\tptr[i] = NUL;\n\t\twhile (--i >= 0)\n\t\t    ptr[i] = ' ';\n\t\tins_str(ptr);\n\t\tvim_free(ptr);\n\t    }\n\t}\n\n\t// When changing the indent while the cursor is in it, reset\n\t// Insstart_col to 0.\n\tinsstart_less = MAXCOL;\n    }\n\n    curwin->w_p_list = save_p_list;\n\n    if (new_cursor_col <= 0)\n\tcurwin->w_cursor.col = 0;\n    else\n\tcurwin->w_cursor.col = (colnr_T)new_cursor_col;\n    curwin->w_set_curswant = TRUE;\n    changed_cline_bef_curs();\n\n    // May have to adjust the start of the insert.\n    if (State & INSERT)\n    {\n\tif (curwin->w_cursor.lnum == Insstart.lnum && Insstart.col != 0)\n\t{\n\t    if ((int)Insstart.col <= insstart_less)\n\t\tInsstart.col = 0;\n\t    else\n\t\tInsstart.col -= insstart_less;\n\t}\n\tif ((int)ai_col <= insstart_less)\n\t    ai_col = 0;\n\telse\n\t    ai_col -= insstart_less;\n    }\n\n    // For REPLACE mode, may have to fix the replace stack, if it's possible.\n    // If the number of characters before the cursor decreased, need to pop a\n    // few characters from the replace stack.\n    // If the number of characters before the cursor increased, need to push a\n    // few NULs onto the replace stack.\n    if (REPLACE_NORMAL(State) && start_col >= 0)\n    {\n\twhile (start_col > (int)curwin->w_cursor.col)\n\t{\n\t    replace_join(0);\t    // remove a NUL from the replace stack\n\t    --start_col;\n\t}\n\twhile (start_col < (int)curwin->w_cursor.col || replaced)\n\t{\n\t    replace_push(NUL);\n\t    if (replaced)\n\t    {\n\t\treplace_push(replaced);\n\t\treplaced = NUL;\n\t    }\n\t    ++start_col;\n\t}\n    }\n\n    // For VREPLACE mode, we also have to fix the replace stack.  In this case\n    // it is always possible because we backspace over the whole line and then\n    // put it back again the way we wanted it.\n    if (State & VREPLACE_FLAG)\n    {\n\t// If orig_line didn't allocate, just return.  At least we did the job,\n\t// even if you can't backspace.\n\tif (orig_line == NULL)\n\t    return;\n\n\t// Save new line\n\tnew_line = vim_strsave(ml_get_curline());\n\tif (new_line == NULL)\n\t    return;\n\n\t// We only put back the new line up to the cursor\n\tnew_line[curwin->w_cursor.col] = NUL;\n\n\t// Put back original line\n\tml_replace(curwin->w_cursor.lnum, orig_line, FALSE);\n\tcurwin->w_cursor.col = orig_col;\n\n\t// Backspace from cursor to start of line\n\tbackspace_until_column(0);\n\n\t// Insert new stuff into line again\n\tins_bytes(new_line);\n\n\tvim_free(new_line);\n    }\n}\n\n/*\n * Copy the indent from ptr to the current line (and fill to size)\n * Leaves the cursor on the first non-blank in the line.\n * Returns TRUE if the line was changed.\n */\n    int\ncopy_indent(int size, char_u *src)\n{\n    char_u\t*p = NULL;\n    char_u\t*line = NULL;\n    char_u\t*s;\n    int\t\ttodo;\n    int\t\tind_len;\n    int\t\tline_len = 0;\n    int\t\ttab_pad;\n    int\t\tind_done;\n    int\t\tround;\n#ifdef FEAT_VARTABS\n    int\t\tind_col;\n#endif\n\n    // Round 1: compute the number of characters needed for the indent\n    // Round 2: copy the characters.\n    for (round = 1; round <= 2; ++round)\n    {\n\ttodo = size;\n\tind_len = 0;\n\tind_done = 0;\n#ifdef FEAT_VARTABS\n\tind_col = 0;\n#endif\n\ts = src;\n\n\t// Count/copy the usable portion of the source line\n\twhile (todo > 0 && VIM_ISWHITE(*s))\n\t{\n\t    if (*s == TAB)\n\t    {\n#ifdef FEAT_VARTABS\n\t\ttab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,\n\t\t\t\t\t\t\tcurbuf->b_p_vts_array);\n#else\n\t\ttab_pad = (int)curbuf->b_p_ts\n\t\t\t\t\t   - (ind_done % (int)curbuf->b_p_ts);\n#endif\n\t\t// Stop if this tab will overshoot the target\n\t\tif (todo < tab_pad)\n\t\t    break;\n\t\ttodo -= tab_pad;\n\t\tind_done += tab_pad;\n#ifdef FEAT_VARTABS\n\t\tind_col += tab_pad;\n#endif\n\t    }\n\t    else\n\t    {\n\t\t--todo;\n\t\t++ind_done;\n#ifdef FEAT_VARTABS\n\t\t++ind_col;\n#endif\n\t    }\n\t    ++ind_len;\n\t    if (p != NULL)\n\t\t*p++ = *s;\n\t    ++s;\n\t}\n\n\t// Fill to next tabstop with a tab, if possible\n#ifdef FEAT_VARTABS\n\ttab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,\n\t\t\t\t\t\t\tcurbuf->b_p_vts_array);\n#else\n\ttab_pad = (int)curbuf->b_p_ts - (ind_done % (int)curbuf->b_p_ts);\n#endif\n\tif (todo >= tab_pad && !curbuf->b_p_et)\n\t{\n\t    todo -= tab_pad;\n\t    ++ind_len;\n#ifdef FEAT_VARTABS\n\t    ind_col += tab_pad;\n#endif\n\t    if (p != NULL)\n\t\t*p++ = TAB;\n\t}\n\n\t// Add tabs required for indent\n\tif (!curbuf->b_p_et)\n\t{\n#ifdef FEAT_VARTABS\n\t    for (;;)\n\t    {\n\t\ttab_pad = tabstop_padding(ind_col, curbuf->b_p_ts,\n\t\t\t\t\t\t\tcurbuf->b_p_vts_array);\n\t\tif (todo < tab_pad)\n\t\t    break;\n\t\ttodo -= tab_pad;\n\t\t++ind_len;\n\t\tind_col += tab_pad;\n\t\tif (p != NULL)\n\t\t    *p++ = TAB;\n\t    }\n#else\n\t    while (todo >= (int)curbuf->b_p_ts)\n\t    {\n\t\ttodo -= (int)curbuf->b_p_ts;\n\t\t++ind_len;\n\t\tif (p != NULL)\n\t\t    *p++ = TAB;\n\t    }\n#endif\n\t}\n\n\t// Count/add spaces required for indent\n\twhile (todo > 0)\n\t{\n\t    --todo;\n\t    ++ind_len;\n\t    if (p != NULL)\n\t\t*p++ = ' ';\n\t}\n\n\tif (p == NULL)\n\t{\n\t    // Allocate memory for the result: the copied indent, new indent\n\t    // and the rest of the line.\n\t    line_len = (int)STRLEN(ml_get_curline()) + 1;\n\t    line = alloc(ind_len + line_len);\n\t    if (line == NULL)\n\t\treturn FALSE;\n\t    p = line;\n\t}\n    }\n\n    // Append the original line\n    mch_memmove(p, ml_get_curline(), (size_t)line_len);\n\n    // Replace the line\n    ml_replace(curwin->w_cursor.lnum, line, FALSE);\n\n    // Put the cursor after the indent.\n    curwin->w_cursor.col = ind_len;\n    return TRUE;\n}\n\n/*\n * \":retab\".\n */\n    void\nex_retab(exarg_T *eap)\n{\n    linenr_T\tlnum;\n    int\t\tgot_tab = FALSE;\n    long\tnum_spaces = 0;\n    long\tnum_tabs;\n    long\tlen;\n    long\tcol;\n    long\tvcol;\n    long\tstart_col = 0;\t\t// For start of white-space string\n    long\tstart_vcol = 0;\t\t// For start of white-space string\n    long\told_len;\n    char_u\t*ptr;\n    char_u\t*new_line = (char_u *)1; // init to non-NULL\n    int\t\tdid_undo;\t\t// called u_save for current line\n#ifdef FEAT_VARTABS\n    int\t\t*new_vts_array = NULL;\n    char_u\t*new_ts_str;\t\t// string value of tab argument\n#else\n    int\t\ttemp;\n    int\t\tnew_ts;\n#endif\n    int\t\tsave_list;\n    linenr_T\tfirst_line = 0;\t\t// first changed line\n    linenr_T\tlast_line = 0;\t\t// last changed line\n\n    save_list = curwin->w_p_list;\n    curwin->w_p_list = 0;\t    // don't want list mode here\n\n#ifdef FEAT_VARTABS\n    new_ts_str = eap->arg;\n    if (tabstop_set(eap->arg, &new_vts_array) == FAIL)\n\treturn;\n    while (vim_isdigit(*(eap->arg)) || *(eap->arg) == ',')\n\t++(eap->arg);\n\n    // This ensures that either new_vts_array and new_ts_str are freshly\n    // allocated, or new_vts_array points to an existing array and new_ts_str\n    // is null.\n    if (new_vts_array == NULL)\n    {\n\tnew_vts_array = curbuf->b_p_vts_array;\n\tnew_ts_str = NULL;\n    }\n    else\n\tnew_ts_str = vim_strnsave(new_ts_str, eap->arg - new_ts_str);\n#else\n    ptr = eap->arg;\n    new_ts = getdigits(&ptr);\n    if (new_ts < 0 && *eap->arg == '-')\n    {\n\temsg(_(e_argument_must_be_positive));\n\treturn;\n    }\n    if (new_ts < 0 || new_ts > 9999)\n    {\n\tsemsg(_(e_invalid_argument_str), eap->arg);\n\treturn;\n    }\n    if (new_ts == 0)\n\tnew_ts = curbuf->b_p_ts;\n#endif\n    for (lnum = eap->line1; !got_int && lnum <= eap->line2; ++lnum)\n    {\n\tptr = ml_get(lnum);\n\tcol = 0;\n\tvcol = 0;\n\tdid_undo = FALSE;\n\tfor (;;)\n\t{\n\t    if (VIM_ISWHITE(ptr[col]))\n\t    {\n\t\tif (!got_tab && num_spaces == 0)\n\t\t{\n\t\t    // First consecutive white-space\n\t\t    start_vcol = vcol;\n\t\t    start_col = col;\n\t\t}\n\t\tif (ptr[col] == ' ')\n\t\t    num_spaces++;\n\t\telse\n\t\t    got_tab = TRUE;\n\t    }\n\t    else\n\t    {\n\t\tif (got_tab || (eap->forceit && num_spaces > 1))\n\t\t{\n\t\t    // Retabulate this string of white-space\n\n\t\t    // len is virtual length of white string\n\t\t    len = num_spaces = vcol - start_vcol;\n\t\t    num_tabs = 0;\n\t\t    if (!curbuf->b_p_et)\n\t\t    {\n#ifdef FEAT_VARTABS\n\t\t\tint t, s;\n\n\t\t\ttabstop_fromto(start_vcol, vcol,\n\t\t\t\t\tcurbuf->b_p_ts, new_vts_array, &t, &s);\n\t\t\tnum_tabs = t;\n\t\t\tnum_spaces = s;\n#else\n\t\t\ttemp = new_ts - (start_vcol % new_ts);\n\t\t\tif (num_spaces >= temp)\n\t\t\t{\n\t\t\t    num_spaces -= temp;\n\t\t\t    num_tabs++;\n\t\t\t}\n\t\t\tnum_tabs += num_spaces / new_ts;\n\t\t\tnum_spaces -= (num_spaces / new_ts) * new_ts;\n#endif\n\t\t    }\n\t\t    if (curbuf->b_p_et || got_tab ||\n\t\t\t\t\t(num_spaces + num_tabs < len))\n\t\t    {\n\t\t\tif (did_undo == FALSE)\n\t\t\t{\n\t\t\t    did_undo = TRUE;\n\t\t\t    if (u_save((linenr_T)(lnum - 1),\n\t\t\t\t\t\t(linenr_T)(lnum + 1)) == FAIL)\n\t\t\t    {\n\t\t\t\tnew_line = NULL;\t// flag out-of-memory\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\n\t\t\t// len is actual number of white characters used\n\t\t\tlen = num_spaces + num_tabs;\n\t\t\told_len = (long)STRLEN(ptr);\n\t\t\tnew_line = alloc(old_len - col + start_col + len + 1);\n\t\t\tif (new_line == NULL)\n\t\t\t    break;\n\t\t\tif (start_col > 0)\n\t\t\t    mch_memmove(new_line, ptr, (size_t)start_col);\n\t\t\tmch_memmove(new_line + start_col + len,\n\t\t\t\t      ptr + col, (size_t)(old_len - col + 1));\n\t\t\tptr = new_line + start_col;\n\t\t\tfor (col = 0; col < len; col++)\n\t\t\t    ptr[col] = (col < num_tabs) ? '\\t' : ' ';\n\t\t\tif (ml_replace(lnum, new_line, FALSE) == OK)\n\t\t\t    // \"new_line\" may have been copied\n\t\t\t    new_line = curbuf->b_ml.ml_line_ptr;\n\t\t\tif (first_line == 0)\n\t\t\t    first_line = lnum;\n\t\t\tlast_line = lnum;\n\t\t\tptr = new_line;\n\t\t\tcol = start_col + len;\n\t\t    }\n\t\t}\n\t\tgot_tab = FALSE;\n\t\tnum_spaces = 0;\n\t    }\n\t    if (ptr[col] == NUL)\n\t\tbreak;\n\t    vcol += chartabsize(ptr + col, (colnr_T)vcol);\n\t    if (has_mbyte)\n\t\tcol += (*mb_ptr2len)(ptr + col);\n\t    else\n\t\t++col;\n\t}\n\tif (new_line == NULL)\t\t    // out of memory\n\t    break;\n\tline_breakcheck();\n    }\n    if (got_int)\n\temsg(_(e_interrupted));\n\n#ifdef FEAT_VARTABS\n    // If a single value was given then it can be considered equal to\n    // either the value of 'tabstop' or the value of 'vartabstop'.\n    if (tabstop_count(curbuf->b_p_vts_array) == 0\n\t&& tabstop_count(new_vts_array) == 1\n\t&& curbuf->b_p_ts == tabstop_first(new_vts_array))\n\t; // not changed\n    else if (tabstop_count(curbuf->b_p_vts_array) > 0\n        && tabstop_eq(curbuf->b_p_vts_array, new_vts_array))\n\t; // not changed\n    else\n\tredraw_curbuf_later(NOT_VALID);\n#else\n    if (curbuf->b_p_ts != new_ts)\n\tredraw_curbuf_later(NOT_VALID);\n#endif\n    if (first_line != 0)\n\tchanged_lines(first_line, 0, last_line + 1, 0L);\n\n    curwin->w_p_list = save_list;\t// restore 'list'\n\n#ifdef FEAT_VARTABS\n    if (new_ts_str != NULL)\t\t// set the new tabstop\n    {\n\t// If 'vartabstop' is in use or if the value given to retab has more\n\t// than one tabstop then update 'vartabstop'.\n\tint *old_vts_ary = curbuf->b_p_vts_array;\n\n\tif (tabstop_count(old_vts_ary) > 0 || tabstop_count(new_vts_array) > 1)\n\t{\n\t    set_string_option_direct((char_u *)\"vts\", -1, new_ts_str,\n\t\t\t\t\t\t\tOPT_FREE|OPT_LOCAL, 0);\n\t    curbuf->b_p_vts_array = new_vts_array;\n\t    vim_free(old_vts_ary);\n\t}\n\telse\n\t{\n\t    // 'vartabstop' wasn't in use and a single value was given to\n\t    // retab then update 'tabstop'.\n\t    curbuf->b_p_ts = tabstop_first(new_vts_array);\n\t    vim_free(new_vts_array);\n\t}\n\tvim_free(new_ts_str);\n    }\n#else\n    curbuf->b_p_ts = new_ts;\n#endif\n    coladvance(curwin->w_curswant);\n\n    u_clearline();\n}\n\n#if (defined(FEAT_CINDENT) && defined(FEAT_EVAL)) || defined(PROTO)\n/*\n * Get indent level from 'indentexpr'.\n */\n    int\nget_expr_indent(void)\n{\n    int\t\tindent = -1;\n    char_u\t*inde_copy;\n    pos_T\tsave_pos;\n    colnr_T\tsave_curswant;\n    int\t\tsave_set_curswant;\n    int\t\tsave_State;\n    int\t\tuse_sandbox = was_set_insecurely((char_u *)\"indentexpr\",\n\t\t\t\t\t\t\t\t   OPT_LOCAL);\n    sctx_T\tsave_sctx = current_sctx;\n\n    // Save and restore cursor position and curswant, in case it was changed\n    // via :normal commands\n    save_pos = curwin->w_cursor;\n    save_curswant = curwin->w_curswant;\n    save_set_curswant = curwin->w_set_curswant;\n    set_vim_var_nr(VV_LNUM, curwin->w_cursor.lnum);\n    if (use_sandbox)\n\t++sandbox;\n    ++textwinlock;\n    current_sctx = curbuf->b_p_script_ctx[BV_INDE];\n\n    // Need to make a copy, the 'indentexpr' option could be changed while\n    // evaluating it.\n    inde_copy = vim_strsave(curbuf->b_p_inde);\n    if (inde_copy != NULL)\n    {\n\tindent = (int)eval_to_number(inde_copy);\n\tvim_free(inde_copy);\n    }\n\n    if (use_sandbox)\n\t--sandbox;\n    --textwinlock;\n    current_sctx = save_sctx;\n\n    // Restore the cursor position so that 'indentexpr' doesn't need to.\n    // Pretend to be in Insert mode, allow cursor past end of line for \"o\"\n    // command.\n    save_State = State;\n    State = INSERT;\n    curwin->w_cursor = save_pos;\n    curwin->w_curswant = save_curswant;\n    curwin->w_set_curswant = save_set_curswant;\n    check_cursor();\n    State = save_State;\n\n    // Reset did_throw, unless 'debug' has \"throw\" and inside a try/catch.\n    if (did_throw && (vim_strchr(p_debug, 't') == NULL || trylevel == 0))\n    {\n\thandle_did_throw();\n\tdid_throw = FALSE;\n    }\n\n    // If there is an error, just keep the current indent.\n    if (indent < 0)\n\tindent = get_indent();\n\n    return indent;\n}\n#endif\n\n#if defined(FEAT_LISP) || defined(PROTO)\n\n    static int\nlisp_match(char_u *p)\n{\n    char_u\tbuf[LSIZE];\n    int\t\tlen;\n    char_u\t*word = *curbuf->b_p_lw != NUL ? curbuf->b_p_lw : p_lispwords;\n\n    while (*word != NUL)\n    {\n\t(void)copy_option_part(&word, buf, LSIZE, \",\");\n\tlen = (int)STRLEN(buf);\n\tif (STRNCMP(buf, p, len) == 0 && p[len] == ' ')\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * When 'p' is present in 'cpoptions, a Vi compatible method is used.\n * The incompatible newer method is quite a bit better at indenting\n * code in lisp-like languages than the traditional one; it's still\n * mostly heuristics however -- Dirk van Deun, dirk@rave.org\n *\n * TODO:\n * Findmatch() should be adapted for lisp, also to make showmatch\n * work correctly: now (v5.3) it seems all C/C++ oriented:\n * - it does not recognize the #\\( and #\\) notations as character literals\n * - it doesn't know about comments starting with a semicolon\n * - it incorrectly interprets '(' as a character literal\n * All this messes up get_lisp_indent in some rare cases.\n * Update from Sergey Khorev:\n * I tried to fix the first two issues.\n */\n    int\nget_lisp_indent(void)\n{\n    pos_T\t*pos, realpos, paren;\n    int\t\tamount;\n    char_u\t*that;\n    colnr_T\tcol;\n    colnr_T\tfirsttry;\n    int\t\tparencount, quotecount;\n    int\t\tvi_lisp;\n\n    // Set vi_lisp to use the vi-compatible method\n    vi_lisp = (vim_strchr(p_cpo, CPO_LISP) != NULL);\n\n    realpos = curwin->w_cursor;\n    curwin->w_cursor.col = 0;\n\n    if ((pos = findmatch(NULL, '(')) == NULL)\n\tpos = findmatch(NULL, '[');\n    else\n    {\n\tparen = *pos;\n\tpos = findmatch(NULL, '[');\n\tif (pos == NULL || LT_POSP(pos, &paren))\n\t    pos = &paren;\n    }\n    if (pos != NULL)\n    {\n\t// Extra trick: Take the indent of the first previous non-white\n\t// line that is at the same () level.\n\tamount = -1;\n\tparencount = 0;\n\n\twhile (--curwin->w_cursor.lnum >= pos->lnum)\n\t{\n\t    if (linewhite(curwin->w_cursor.lnum))\n\t\tcontinue;\n\t    for (that = ml_get_curline(); *that != NUL; ++that)\n\t    {\n\t\tif (*that == ';')\n\t\t{\n\t\t    while (*(that + 1) != NUL)\n\t\t\t++that;\n\t\t    continue;\n\t\t}\n\t\tif (*that == '\\\\')\n\t\t{\n\t\t    if (*(that + 1) != NUL)\n\t\t\t++that;\n\t\t    continue;\n\t\t}\n\t\tif (*that == '\"' && *(that + 1) != NUL)\n\t\t{\n\t\t    while (*++that && *that != '\"')\n\t\t    {\n\t\t\t// skipping escaped characters in the string\n\t\t\tif (*that == '\\\\')\n\t\t\t{\n\t\t\t    if (*++that == NUL)\n\t\t\t\tbreak;\n\t\t\t    if (that[1] == NUL)\n\t\t\t    {\n\t\t\t\t++that;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (*that == '(' || *that == '[')\n\t\t    ++parencount;\n\t\telse if (*that == ')' || *that == ']')\n\t\t    --parencount;\n\t    }\n\t    if (parencount == 0)\n\t    {\n\t\tamount = get_indent();\n\t\tbreak;\n\t    }\n\t}\n\n\tif (amount == -1)\n\t{\n\t    curwin->w_cursor.lnum = pos->lnum;\n\t    curwin->w_cursor.col = pos->col;\n\t    col = pos->col;\n\n\t    that = ml_get_curline();\n\n\t    if (vi_lisp && get_indent() == 0)\n\t\tamount = 2;\n\t    else\n\t    {\n\t\tchar_u *line = that;\n\n\t\tamount = 0;\n\t\twhile (*that && col)\n\t\t{\n\t\t    amount += lbr_chartabsize_adv(line, &that, (colnr_T)amount);\n\t\t    col--;\n\t\t}\n\n\t\t// Some keywords require \"body\" indenting rules (the\n\t\t// non-standard-lisp ones are Scheme special forms):\n\t\t//\n\t\t// (let ((a 1))    instead    (let ((a 1))\n\t\t//   (...))\t      of\t   (...))\n\n\t\tif (!vi_lisp && (*that == '(' || *that == '[')\n\t\t\t\t\t\t      && lisp_match(that + 1))\n\t\t    amount += 2;\n\t\telse\n\t\t{\n\t\t    that++;\n\t\t    amount++;\n\t\t    firsttry = amount;\n\n\t\t    while (VIM_ISWHITE(*that))\n\t\t    {\n\t\t\tamount += lbr_chartabsize(line, that, (colnr_T)amount);\n\t\t\t++that;\n\t\t    }\n\n\t\t    if (*that && *that != ';') // not a comment line\n\t\t    {\n\t\t\t// test *that != '(' to accommodate first let/do\n\t\t\t// argument if it is more than one line\n\t\t\tif (!vi_lisp && *that != '(' && *that != '[')\n\t\t\t    firsttry++;\n\n\t\t\tparencount = 0;\n\t\t\tquotecount = 0;\n\n\t\t\tif (vi_lisp\n\t\t\t\t|| (*that != '\"'\n\t\t\t\t    && *that != '\\''\n\t\t\t\t    && *that != '#'\n\t\t\t\t    && (*that < '0' || *that > '9')))\n\t\t\t{\n\t\t\t    while (*that\n\t\t\t\t    && (!VIM_ISWHITE(*that)\n\t\t\t\t\t|| quotecount\n\t\t\t\t\t|| parencount)\n\t\t\t\t    && (!((*that == '(' || *that == '[')\n\t\t\t\t\t    && !quotecount\n\t\t\t\t\t    && !parencount\n\t\t\t\t\t    && vi_lisp)))\n\t\t\t    {\n\t\t\t\tif (*that == '\"')\n\t\t\t\t    quotecount = !quotecount;\n\t\t\t\tif ((*that == '(' || *that == '[')\n\t\t\t\t\t\t\t       && !quotecount)\n\t\t\t\t    ++parencount;\n\t\t\t\tif ((*that == ')' || *that == ']')\n\t\t\t\t\t\t\t       && !quotecount)\n\t\t\t\t    --parencount;\n\t\t\t\tif (*that == '\\\\' && *(that+1) != NUL)\n\t\t\t\t    amount += lbr_chartabsize_adv(\n\t\t\t\t\t\tline, &that, (colnr_T)amount);\n\t\t\t\tamount += lbr_chartabsize_adv(\n\t\t\t\t\t\tline, &that, (colnr_T)amount);\n\t\t\t    }\n\t\t\t}\n\t\t\twhile (VIM_ISWHITE(*that))\n\t\t\t{\n\t\t\t    amount += lbr_chartabsize(\n\t\t\t\t\t\t line, that, (colnr_T)amount);\n\t\t\t    that++;\n\t\t\t}\n\t\t\tif (!*that || *that == ';')\n\t\t\t    amount = firsttry;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    else\n\tamount = 0;\t// no matching '(' or '[' found, use zero indent\n\n    curwin->w_cursor = realpos;\n\n    return amount;\n}\n#endif // FEAT_LISP\n\n#if defined(FEAT_LISP) || defined(FEAT_CINDENT) || defined(PROTO)\n/*\n * Re-indent the current line, based on the current contents of it and the\n * surrounding lines. Fixing the cursor position seems really easy -- I'm very\n * confused what all the part that handles Control-T is doing that I'm not.\n * \"get_the_indent\" should be get_c_indent, get_expr_indent or get_lisp_indent.\n */\n\n    void\nfixthisline(int (*get_the_indent)(void))\n{\n    int amount = get_the_indent();\n\n    if (amount >= 0)\n    {\n\tchange_indent(INDENT_SET, amount, FALSE, 0, TRUE);\n\tif (linewhite(curwin->w_cursor.lnum))\n\t    did_ai = TRUE;\t// delete the indent if the line stays empty\n    }\n}\n\n/*\n * Fix indent for 'lisp' and 'cindent'.\n */\n    void\nfix_indent(void)\n{\n    if (p_paste)\n\treturn;\n# ifdef FEAT_LISP\n    if (curbuf->b_p_lisp && curbuf->b_p_ai)\n\tfixthisline(get_lisp_indent);\n# endif\n# if defined(FEAT_LISP) && defined(FEAT_CINDENT)\n    else\n# endif\n# ifdef FEAT_CINDENT\n\tif (cindent_on())\n\t    do_c_expr_indent();\n# endif\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * \"indent()\" function\n */\n    void\nf_indent(typval_T *argvars, typval_T *rettv)\n{\n    linenr_T\tlnum;\n\n    if (in_vim9script() && check_for_lnum_arg(argvars, 0) == FAIL)\n\treturn;\n\n    lnum = tv_get_lnum(argvars);\n    if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count)\n\trettv->vval.v_number = get_indent_lnum(lnum);\n    else\n    {\n\tif (in_vim9script())\n\t    semsg(_(e_invalid_line_number_nr), lnum);\n\trettv->vval.v_number = -1;\n    }\n}\n\n/*\n * \"lispindent(lnum)\" function\n */\n    void\nf_lispindent(typval_T *argvars UNUSED, typval_T *rettv)\n{\n#ifdef FEAT_LISP\n    pos_T\tpos;\n    linenr_T\tlnum;\n\n    if (in_vim9script() && check_for_lnum_arg(argvars, 0) == FAIL)\n\treturn;\n\n    pos = curwin->w_cursor;\n    lnum = tv_get_lnum(argvars);\n    if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count)\n    {\n\tcurwin->w_cursor.lnum = lnum;\n\trettv->vval.v_number = get_lisp_indent();\n\tcurwin->w_cursor = pos;\n    }\n    else if (in_vim9script())\n\tsemsg(_(e_invalid_line_number_nr), lnum);\n    else\n#endif\n\trettv->vval.v_number = -1;\n}\n#endif\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * Code to handle user-settable options. This is all pretty much table-\n * driven. Checklist for adding a new option:\n * - Put it in the options array below (copy an existing entry).\n * - For a global option: Add a variable for it in option.h.\n * - For a buffer or window local option:\n *   - Add a PV_XX entry to the enum below.\n *   - Add a variable to the window or buffer struct in structs.h.\n *   - For a window option, add some code to copy_winopt().\n *   - For a buffer option, add some code to buf_copy_options().\n *   - For a buffer string option, add code to check_buf_options().\n * - If it's a numeric option, add any necessary bounds checks to do_set().\n * - If it's a list of flags, add some code in do_set(), search for WW_ALL.\n * - When adding an option with expansion (P_EXPAND), but with a different\n *   default for Vi and Vim (no P_VI_DEF), add some code at VIMEXP.\n * - Add documentation!  One line in doc/quickref.txt, full description in\n *   options.txt, and any other related places.\n * - Add an entry in runtime/optwin.vim.\n * When making changes:\n * - Adjust the help for the option in doc/option.txt.\n * - When an entry has the P_VIM flag, or is lacking the P_VI_DEF flag, add a\n *   comment at the help for the 'compatible' option.\n */\n\n#define IN_OPTION_C\n#include \"vim.h\"\n#include \"optiondefs.h\"\n\nstatic void set_options_default(int opt_flags);\nstatic void set_string_default_esc(char *name, char_u *val, int escape);\nstatic char_u *find_dup_item(char_u *origval, char_u *newval, long_u flags);\nstatic char_u *option_expand(int opt_idx, char_u *val);\nstatic void didset_options(void);\nstatic void didset_options2(void);\n#if defined(FEAT_EVAL) || defined(PROTO)\nstatic long_u *insecure_flag(int opt_idx, int opt_flags);\n#else\n# define insecure_flag(opt_idx, opt_flags) (&options[opt_idx].flags)\n#endif\nstatic char *set_bool_option(int opt_idx, char_u *varp, int value, int opt_flags);\nstatic char *set_num_option(int opt_idx, char_u *varp, long value, char *errbuf, size_t errbuflen, int opt_flags);\nstatic int find_key_option(char_u *arg_arg, int has_lt);\nstatic void showoptions(int all, int opt_flags);\nstatic int optval_default(struct vimoption *, char_u *varp, int compatible);\nstatic void showoneopt(struct vimoption *, int opt_flags);\nstatic int put_setstring(FILE *fd, char *cmd, char *name, char_u **valuep, long_u flags);\nstatic int put_setnum(FILE *fd, char *cmd, char *name, long *valuep);\nstatic int put_setbool(FILE *fd, char *cmd, char *name, int value);\nstatic int istermoption(struct vimoption *p);\nstatic char_u *get_varp_scope(struct vimoption *p, int scope);\nstatic char_u *get_varp(struct vimoption *);\nstatic void check_win_options(win_T *win);\nstatic void option_value2string(struct vimoption *, int scope);\nstatic void check_winopt(winopt_T *wop);\nstatic int wc_use_keyname(char_u *varp, long *wcp);\nstatic void paste_option_changed(void);\nstatic void compatible_set(void);\n\n/*\n * Initialize the options, first part.\n *\n * Called only once from main(), just after creating the first buffer.\n * If \"clean_arg\" is TRUE Vim was started with --clean.\n */\n    void\nset_init_1(int clean_arg)\n{\n    char_u\t*p;\n    int\t\topt_idx;\n    long_u\tn;\n\n#ifdef FEAT_LANGMAP\n    langmap_init();\n#endif\n\n    // Be Vi compatible by default\n    p_cp = TRUE;\n\n    // Use POSIX compatibility when $VIM_POSIX is set.\n    if (mch_getenv((char_u *)\"VIM_POSIX\") != NULL)\n    {\n\tset_string_default(\"cpo\", (char_u *)CPO_ALL);\n\tset_string_default(\"shm\", (char_u *)SHM_POSIX);\n    }\n\n    /*\n     * Find default value for 'shell' option.\n     * Don't use it if it is empty.\n     */\n    if (((p = mch_getenv((char_u *)\"SHELL\")) != NULL && *p != NUL)\n#if defined(MSWIN)\n\t    || ((p = mch_getenv((char_u *)\"COMSPEC\")) != NULL && *p != NUL)\n\t    || ((p = (char_u *)default_shell()) != NULL && *p != NUL)\n#endif\n\t    )\n#if defined(MSWIN)\n    {\n\t// For MS-Windows put the path in quotes instead of escaping spaces.\n\tchar_u\t    *cmd;\n\tsize_t\t    len;\n\n\tif (vim_strchr(p, ' ') != NULL)\n\t{\n\t    len = STRLEN(p) + 3;  // two quotes and a trailing NUL\n\t    cmd = alloc(len);\n\t    if (cmd != NULL)\n\t    {\n\t\tvim_snprintf((char *)cmd, len, \"\\\"%s\\\"\", p);\n\t\tset_string_default(\"sh\", cmd);\n\t\tvim_free(cmd);\n\t    }\n\t}\n\telse\n\t    set_string_default(\"sh\", p);\n    }\n#else\n\tset_string_default_esc(\"sh\", p, TRUE);\n#endif\n\n#ifdef FEAT_WILDIGN\n    /*\n     * Set the default for 'backupskip' to include environment variables for\n     * temp files.\n     */\n    {\n# ifdef UNIX\n\tstatic char\t*(names[4]) = {\"\", \"TMPDIR\", \"TEMP\", \"TMP\"};\n# else\n\tstatic char\t*(names[3]) = {\"TMPDIR\", \"TEMP\", \"TMP\"};\n# endif\n\tint\t\tlen;\n\tgarray_T\tga;\n\tint\t\tmustfree;\n\tchar_u\t\t*item;\n\n\topt_idx = findoption((char_u *)\"backupskip\");\n\n\tga_init2(&ga, 1, 100);\n\tfor (n = 0; n < (long)ARRAY_LENGTH(names); ++n)\n\t{\n\t    mustfree = FALSE;\n# ifdef UNIX\n\t    if (*names[n] == NUL)\n#  ifdef MACOS_X\n\t\tp = (char_u *)\"/private/tmp\";\n#  else\n\t\tp = (char_u *)\"/tmp\";\n#  endif\n\t    else\n# endif\n\t\tp = vim_getenv((char_u *)names[n], &mustfree);\n\t    if (p != NULL && *p != NUL)\n\t    {\n\t\t// First time count the NUL, otherwise count the ','.\n\t\tlen = (int)STRLEN(p) + 3;\n\t\titem = alloc(len);\n\t\tSTRCPY(item, p);\n\t\tadd_pathsep(item);\n\t\tSTRCAT(item, \"*\");\n\t\tif (find_dup_item(ga.ga_data, item, options[opt_idx].flags)\n\t\t\t\t\t\t\t\t\t== NULL\n\t\t\t&& ga_grow(&ga, len) == OK)\n\t\t{\n\t\t    if (ga.ga_len > 0)\n\t\t\tSTRCAT(ga.ga_data, \",\");\n\t\t    STRCAT(ga.ga_data, item);\n\t\t    ga.ga_len += len;\n\t\t}\n\t\tvim_free(item);\n\t    }\n\t    if (mustfree)\n\t\tvim_free(p);\n\t}\n\tif (ga.ga_data != NULL)\n\t{\n\t    set_string_default(\"bsk\", ga.ga_data);\n\t    vim_free(ga.ga_data);\n\t}\n    }\n#endif\n\n    /*\n     * 'maxmemtot' and 'maxmem' may have to be adjusted for available memory\n     */\n    opt_idx = findoption((char_u *)\"maxmemtot\");\n    if (opt_idx >= 0)\n    {\n#if !defined(HAVE_AVAIL_MEM) && !defined(HAVE_TOTAL_MEM)\n\tif (options[opt_idx].def_val[VI_DEFAULT] == (char_u *)0L)\n#endif\n\t{\n#ifdef HAVE_AVAIL_MEM\n\t    // Use amount of memory available at this moment.\n\t    n = (mch_avail_mem(FALSE) >> 1);\n#else\n# ifdef HAVE_TOTAL_MEM\n\t    // Use amount of memory available to Vim.\n\t    n = (mch_total_mem(FALSE) >> 1);\n# else\n\t    n = (0x7fffffff >> 11);\n# endif\n#endif\n\t    options[opt_idx].def_val[VI_DEFAULT] = (char_u *)n;\n\t    opt_idx = findoption((char_u *)\"maxmem\");\n\t    if (opt_idx >= 0)\n\t    {\n#if !defined(HAVE_AVAIL_MEM) && !defined(HAVE_TOTAL_MEM)\n\t\tif ((long)(long_i)options[opt_idx].def_val[VI_DEFAULT] > (long)n\n\t\t  || (long)(long_i)options[opt_idx].def_val[VI_DEFAULT] == 0L)\n#endif\n\t\t    options[opt_idx].def_val[VI_DEFAULT] = (char_u *)n;\n\t    }\n\t}\n    }\n\n#ifdef FEAT_SEARCHPATH\n    {\n\tchar_u\t*cdpath;\n\tchar_u\t*buf;\n\tint\ti;\n\tint\tj;\n\tint\tmustfree = FALSE;\n\n\t// Initialize the 'cdpath' option's default value.\n\tcdpath = vim_getenv((char_u *)\"CDPATH\", &mustfree);\n\tif (cdpath != NULL)\n\t{\n\t    buf = alloc((STRLEN(cdpath) << 1) + 2);\n\t    if (buf != NULL)\n\t    {\n\t\tbuf[0] = ',';\t    // start with \",\", current dir first\n\t\tj = 1;\n\t\tfor (i = 0; cdpath[i] != NUL; ++i)\n\t\t{\n\t\t    if (vim_ispathlistsep(cdpath[i]))\n\t\t\tbuf[j++] = ',';\n\t\t    else\n\t\t    {\n\t\t\tif (cdpath[i] == ' ' || cdpath[i] == ',')\n\t\t\t    buf[j++] = '\\\\';\n\t\t\tbuf[j++] = cdpath[i];\n\t\t    }\n\t\t}\n\t\tbuf[j] = NUL;\n\t\topt_idx = findoption((char_u *)\"cdpath\");\n\t\tif (opt_idx >= 0)\n\t\t{\n\t\t    options[opt_idx].def_val[VI_DEFAULT] = buf;\n\t\t    options[opt_idx].flags |= P_DEF_ALLOCED;\n\t\t}\n\t\telse\n\t\t    vim_free(buf); // cannot happen\n\t    }\n\t    if (mustfree)\n\t\tvim_free(cdpath);\n\t}\n    }\n#endif\n\n#if defined(FEAT_POSTSCRIPT) && (defined(MSWIN) || defined(VMS) || defined(EBCDIC) || defined(MAC) || defined(hpux))\n    // Set print encoding on platforms that don't default to latin1\n    set_string_default(\"penc\",\n# if defined(MSWIN)\n\t\t       (char_u *)\"cp1252\"\n# else\n#  ifdef VMS\n\t\t       (char_u *)\"dec-mcs\"\n#  else\n#   ifdef EBCDIC\n\t\t       (char_u *)\"ebcdic-uk\"\n#   else\n#    ifdef MAC\n\t\t       (char_u *)\"mac-roman\"\n#    else // HPUX\n\t\t       (char_u *)\"hp-roman8\"\n#    endif\n#   endif\n#  endif\n# endif\n\t\t       );\n#endif\n\n#ifdef FEAT_POSTSCRIPT\n    // 'printexpr' must be allocated to be able to evaluate it.\n    set_string_default(\"pexpr\",\n# if defined(MSWIN)\n\t    (char_u *)\"system('copy' . ' ' . v:fname_in . (&printdevice == '' ? ' LPT1:' : (' \\\"' . &printdevice . '\\\"'))) . delete(v:fname_in)\"\n# else\n#  ifdef VMS\n\t    (char_u *)\"system('print/delete' . (&printdevice == '' ? '' : ' /queue=' . &printdevice) . ' ' . v:fname_in)\"\n\n#  else\n\t    (char_u *)\"system('lpr' . (&printdevice == '' ? '' : ' -P' . &printdevice) . ' ' . v:fname_in) . delete(v:fname_in) + v:shell_error\"\n#  endif\n# endif\n\t    );\n#endif\n\n    /*\n     * Set all the options (except the terminal options) to their default\n     * value.  Also set the global value for local options.\n     */\n    set_options_default(0);\n\n#ifdef CLEAN_RUNTIMEPATH\n    if (clean_arg)\n    {\n\topt_idx = findoption((char_u *)\"runtimepath\");\n\tif (opt_idx >= 0)\n\t{\n\t    options[opt_idx].def_val[VI_DEFAULT] = (char_u *)CLEAN_RUNTIMEPATH;\n\t    p_rtp = (char_u *)CLEAN_RUNTIMEPATH;\n\t}\n\topt_idx = findoption((char_u *)\"packpath\");\n\tif (opt_idx >= 0)\n\t{\n\t    options[opt_idx].def_val[VI_DEFAULT] = (char_u *)CLEAN_RUNTIMEPATH;\n\t    p_pp = (char_u *)CLEAN_RUNTIMEPATH;\n\t}\n    }\n#endif\n\n#ifdef FEAT_GUI\n    if (found_reverse_arg)\n\tset_option_value((char_u *)\"bg\", 0L, (char_u *)\"dark\", 0);\n#endif\n\n    curbuf->b_p_initialized = TRUE;\n    curbuf->b_p_ar = -1;\t// no local 'autoread' value\n    curbuf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n    check_buf_options(curbuf);\n    check_win_options(curwin);\n    check_options();\n\n    // Must be before option_expand(), because that one needs vim_isIDc()\n    didset_options();\n\n#ifdef FEAT_SPELL\n    // Use the current chartab for the generic chartab. This is not in\n    // didset_options() because it only depends on 'encoding'.\n    init_spell_chartab();\n#endif\n\n    /*\n     * Expand environment variables and things like \"~\" for the defaults.\n     * If option_expand() returns non-NULL the variable is expanded.  This can\n     * only happen for non-indirect options.\n     * Also set the default to the expanded value, so \":set\" does not list\n     * them.\n     * Don't set the P_ALLOCED flag, because we don't want to free the\n     * default.\n     */\n    for (opt_idx = 0; !istermoption_idx(opt_idx); opt_idx++)\n    {\n\tif ((options[opt_idx].flags & P_GETTEXT)\n\t\t\t\t\t      && options[opt_idx].var != NULL)\n\t    p = (char_u *)_(*(char **)options[opt_idx].var);\n\telse\n\t    p = option_expand(opt_idx, NULL);\n\tif (p != NULL && (p = vim_strsave(p)) != NULL)\n\t{\n\t    *(char_u **)options[opt_idx].var = p;\n\t    // VIMEXP\n\t    // Defaults for all expanded options are currently the same for Vi\n\t    // and Vim.  When this changes, add some code here!  Also need to\n\t    // split P_DEF_ALLOCED in two.\n\t    if (options[opt_idx].flags & P_DEF_ALLOCED)\n\t\tvim_free(options[opt_idx].def_val[VI_DEFAULT]);\n\t    options[opt_idx].def_val[VI_DEFAULT] = p;\n\t    options[opt_idx].flags |= P_DEF_ALLOCED;\n\t}\n    }\n\n    save_file_ff(curbuf);\t// Buffer is unchanged\n\n#if defined(FEAT_ARABIC)\n    // Detect use of mlterm.\n    // Mlterm is a terminal emulator akin to xterm that has some special\n    // abilities (bidi namely).\n    // NOTE: mlterm's author is being asked to 'set' a variable\n    //       instead of an environment variable due to inheritance.\n    if (mch_getenv((char_u *)\"MLTERM\") != NULL)\n\tset_option_value((char_u *)\"tbidi\", 1L, NULL, 0);\n#endif\n\n    didset_options2();\n\n# if defined(MSWIN) && defined(FEAT_GETTEXT)\n    /*\n     * If $LANG isn't set, try to get a good value for it.  This makes the\n     * right language be used automatically.  Don't do this for English.\n     */\n    if (mch_getenv((char_u *)\"LANG\") == NULL)\n    {\n\tchar\tbuf[20];\n\n\t// Could use LOCALE_SISO639LANGNAME, but it's not in Win95.\n\t// LOCALE_SABBREVLANGNAME gives us three letters, like \"enu\", we use\n\t// only the first two.\n\tn = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SABBREVLANGNAME,\n\t\t\t\t\t\t\t     (LPTSTR)buf, 20);\n\tif (n >= 2 && STRNICMP(buf, \"en\", 2) != 0)\n\t{\n\t    // There are a few exceptions (probably more)\n\t    if (STRNICMP(buf, \"cht\", 3) == 0 || STRNICMP(buf, \"zht\", 3) == 0)\n\t\tSTRCPY(buf, \"zh_TW\");\n\t    else if (STRNICMP(buf, \"chs\", 3) == 0\n\t\t\t\t\t      || STRNICMP(buf, \"zhc\", 3) == 0)\n\t\tSTRCPY(buf, \"zh_CN\");\n\t    else if (STRNICMP(buf, \"jp\", 2) == 0)\n\t\tSTRCPY(buf, \"ja\");\n\t    else\n\t\tbuf[2] = NUL;\t\t// truncate to two-letter code\n\t    vim_setenv((char_u *)\"LANG\", (char_u *)buf);\n\t}\n    }\n# else\n#  ifdef MACOS_CONVERT\n    // Moved to os_mac_conv.c to avoid dependency problems.\n    mac_lang_init();\n#  endif\n# endif\n\n# ifdef MSWIN\n    // MS-Windows has builtin support for conversion to and from Unicode, using\n    // \"utf-8\" for 'encoding' should work best for most users.\n    p = vim_strsave((char_u *)ENC_DFLT);\n# else\n    // enc_locale() will try to find the encoding of the current locale.\n    // This works best for properly configured systems, old and new.\n    p = enc_locale();\n# endif\n    if (p != NULL)\n    {\n\tchar_u *save_enc;\n\n\t// Try setting 'encoding' and check if the value is valid.\n\t// If not, go back to the default encoding.\n\tsave_enc = p_enc;\n\tp_enc = p;\n\tif (STRCMP(p_enc, \"gb18030\") == 0)\n\t{\n\t    // We don't support \"gb18030\", but \"cp936\" is a good substitute\n\t    // for practical purposes, thus use that.  It's not an alias to\n\t    // still support conversion between gb18030 and utf-8.\n\t    p_enc = vim_strsave((char_u *)\"cp936\");\n\t    vim_free(p);\n\t}\n\tif (mb_init() == NULL)\n\t{\n\t    opt_idx = findoption((char_u *)\"encoding\");\n\t    if (opt_idx >= 0)\n\t    {\n\t\toptions[opt_idx].def_val[VI_DEFAULT] = p_enc;\n\t\toptions[opt_idx].flags |= P_DEF_ALLOCED;\n\t    }\n\n#if defined(MSWIN) || defined(MACOS_X) || defined(VMS)\n\t    if (STRCMP(p_enc, \"latin1\") == 0 || enc_utf8)\n\t    {\n\t\t// Adjust the default for 'isprint' and 'iskeyword' to match\n\t\t// latin1.  Also set the defaults for when 'nocompatible' is\n\t\t// set.\n\t\tset_string_option_direct((char_u *)\"isp\", -1,\n\t\t\t\t\t      ISP_LATIN1, OPT_FREE, SID_NONE);\n\t\tset_string_option_direct((char_u *)\"isk\", -1,\n\t\t\t\t\t      ISK_LATIN1, OPT_FREE, SID_NONE);\n\t\topt_idx = findoption((char_u *)\"isp\");\n\t\tif (opt_idx >= 0)\n\t\t    options[opt_idx].def_val[VIM_DEFAULT] = ISP_LATIN1;\n\t\topt_idx = findoption((char_u *)\"isk\");\n\t\tif (opt_idx >= 0)\n\t\t    options[opt_idx].def_val[VIM_DEFAULT] = ISK_LATIN1;\n\t\t(void)init_chartab();\n\t    }\n#endif\n\n#if defined(MSWIN) && (!defined(FEAT_GUI) || defined(VIMDLL))\n\t    // Win32 console: When GetACP() returns a different value from\n\t    // GetConsoleCP() set 'termencoding'.\n\t    if (\n# ifdef VIMDLL\n\t       (!gui.in_use && !gui.starting) &&\n# endif\n\t        GetACP() != GetConsoleCP())\n\t    {\n\t\tchar\tbuf[50];\n\n\t\t// Win32 console: In ConPTY, GetConsoleCP() returns zero.\n\t\t// Use an alternative value.\n\t\tif (GetConsoleCP() == 0)\n\t\t    sprintf(buf, \"cp%ld\", (long)GetACP());\n\t\telse\n\t\t    sprintf(buf, \"cp%ld\", (long)GetConsoleCP());\n\t\tp_tenc = vim_strsave((char_u *)buf);\n\t\tif (p_tenc != NULL)\n\t\t{\n\t\t    opt_idx = findoption((char_u *)\"termencoding\");\n\t\t    if (opt_idx >= 0)\n\t\t    {\n\t\t\toptions[opt_idx].def_val[VI_DEFAULT] = p_tenc;\n\t\t\toptions[opt_idx].flags |= P_DEF_ALLOCED;\n\t\t    }\n\t\t    convert_setup(&input_conv, p_tenc, p_enc);\n\t\t    convert_setup(&output_conv, p_enc, p_tenc);\n\t\t}\n\t\telse\n\t\t    p_tenc = empty_option;\n\t    }\n#endif\n#if defined(MSWIN)\n\t    // $HOME may have characters in active code page.\n\t    init_homedir();\n#endif\n\t}\n\telse\n\t{\n\t    vim_free(p_enc);\n\t    p_enc = save_enc;\n\t}\n    }\n\n#ifdef FEAT_MULTI_LANG\n    // Set the default for 'helplang'.\n    set_helplang_default(get_mess_lang());\n#endif\n}\n\nstatic char_u *fencs_utf8_default = (char_u *)\"ucs-bom,utf-8,default,latin1\";\n\n/*\n * Set the \"fileencodings\" option to the default value for when 'encoding' is\n * utf-8.\n */\n    void\nset_fencs_unicode()\n{\n    set_string_option_direct((char_u *)\"fencs\", -1, fencs_utf8_default,\n\t\t\t\t\t\t\t\t  OPT_FREE, 0);\n}\n\n/*\n * Set an option to its default value.\n * This does not take care of side effects!\n */\n    static void\nset_option_default(\n    int\t\topt_idx,\n    int\t\topt_flags,\t// OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL\n    int\t\tcompatible)\t// use Vi default value\n{\n    char_u\t*varp;\t\t// pointer to variable for current option\n    int\t\tdvi;\t\t// index in def_val[]\n    long_u\tflags;\n    long_u\t*flagsp;\n    int\t\tboth = (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0;\n\n    varp = get_varp_scope(&(options[opt_idx]), both ? OPT_LOCAL : opt_flags);\n    flags = options[opt_idx].flags;\n    if (varp != NULL)\t    // skip hidden option, nothing to do for it\n    {\n\tdvi = ((flags & P_VI_DEF) || compatible) ? VI_DEFAULT : VIM_DEFAULT;\n\tif (flags & P_STRING)\n\t{\n\t    // 'fencs' default value depends on 'encoding'\n\t    if (options[opt_idx].var == (char_u *)&p_fencs && enc_utf8)\n\t\tset_fencs_unicode();\n\t    // Use set_string_option_direct() for local options to handle\n\t    // freeing and allocating the value.\n\t    else if (options[opt_idx].indir != PV_NONE)\n\t\tset_string_option_direct(NULL, opt_idx,\n\t\t\t\t options[opt_idx].def_val[dvi], opt_flags, 0);\n\t    else\n\t    {\n\t\tif ((opt_flags & OPT_FREE) && (flags & P_ALLOCED))\n\t\t    free_string_option(*(char_u **)(varp));\n\t\t*(char_u **)varp = options[opt_idx].def_val[dvi];\n\t\toptions[opt_idx].flags &= ~P_ALLOCED;\n\t    }\n\t}\n\telse if (flags & P_NUM)\n\t{\n\t    if (options[opt_idx].indir == PV_SCROLL)\n\t\twin_comp_scroll(curwin);\n\t    else\n\t    {\n\t\tlong def_val = (long)(long_i)options[opt_idx].def_val[dvi];\n\n\t\tif ((long *)varp == &curwin->w_p_so\n\t\t\t|| (long *)varp == &curwin->w_p_siso)\n\t\t    // 'scrolloff' and 'sidescrolloff' local values have a\n\t\t    // different default value than the global default.\n\t\t    *(long *)varp = -1;\n\t\telse\n\t\t    *(long *)varp = def_val;\n\t\t// May also set global value for local option.\n\t\tif (both)\n\t\t    *(long *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) =\n\t\t\t\t\t\t\t\tdef_val;\n\t    }\n\t}\n\telse\t// P_BOOL\n\t{\n\t    // the cast to long is required for Manx C, long_i is needed for\n\t    // MSVC\n\t    *(int *)varp = (int)(long)(long_i)options[opt_idx].def_val[dvi];\n#ifdef UNIX\n\t    // 'modeline' defaults to off for root\n\t    if (options[opt_idx].indir == PV_ML && getuid() == ROOT_UID)\n\t\t*(int *)varp = FALSE;\n#endif\n\t    // May also set global value for local option.\n\t    if (both)\n\t\t*(int *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) =\n\t\t\t\t\t\t\t\t*(int *)varp;\n\t}\n\n\t// The default value is not insecure.\n\tflagsp = insecure_flag(opt_idx, opt_flags);\n\t*flagsp = *flagsp & ~P_INSECURE;\n    }\n\n#ifdef FEAT_EVAL\n    set_option_sctx_idx(opt_idx, opt_flags, current_sctx);\n#endif\n}\n\n/*\n * Set all options (except terminal options) to their default value.\n * When \"opt_flags\" is non-zero skip 'encoding'.\n */\n    static void\nset_options_default(\n    int\t\topt_flags)\t// OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL\n{\n    int\t\ti;\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    for (i = 0; !istermoption_idx(i); i++)\n\tif (!(options[i].flags & P_NODEFAULT)\n\t\t&& (opt_flags == 0\n\t\t    || (options[i].var != (char_u *)&p_enc\n# if defined(FEAT_CRYPT)\n\t\t\t&& options[i].var != (char_u *)&p_cm\n\t\t\t&& options[i].var != (char_u *)&p_key\n# endif\n\t\t\t)))\n\t    set_option_default(i, opt_flags, p_cp);\n\n    // The 'scroll' option must be computed for all windows.\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\twin_comp_scroll(wp);\n#ifdef FEAT_CINDENT\n    parse_cino(curbuf);\n#endif\n}\n\n/*\n * Set the Vi-default value of a string option.\n * Used for 'sh', 'backupskip' and 'term'.\n * When \"escape\" is TRUE escape spaces with a backslash.\n */\n    static void\nset_string_default_esc(char *name, char_u *val, int escape)\n{\n    char_u\t*p;\n    int\t\topt_idx;\n\n    if (escape && vim_strchr(val, ' ') != NULL)\n\tp = vim_strsave_escaped(val, (char_u *)\" \");\n    else\n\tp = vim_strsave(val);\n    if (p != NULL)\t\t// we don't want a NULL\n    {\n\topt_idx = findoption((char_u *)name);\n\tif (opt_idx >= 0)\n\t{\n\t    if (options[opt_idx].flags & P_DEF_ALLOCED)\n\t\tvim_free(options[opt_idx].def_val[VI_DEFAULT]);\n\t    options[opt_idx].def_val[VI_DEFAULT] = p;\n\t    options[opt_idx].flags |= P_DEF_ALLOCED;\n\t}\n    }\n}\n\n    void\nset_string_default(char *name, char_u *val)\n{\n    set_string_default_esc(name, val, FALSE);\n}\n\n/*\n * For an option value that contains comma separated items, find \"newval\" in\n * \"origval\".  Return NULL if not found.\n */\n    static char_u *\nfind_dup_item(char_u *origval, char_u *newval, long_u flags)\n{\n    int\t    bs = 0;\n    size_t  newlen;\n    char_u  *s;\n\n    if (origval == NULL)\n\treturn NULL;\n\n    newlen = STRLEN(newval);\n    for (s = origval; *s != NUL; ++s)\n    {\n\tif ((!(flags & P_COMMA)\n\t\t    || s == origval\n\t\t    || (s[-1] == ',' && !(bs & 1)))\n\t\t&& STRNCMP(s, newval, newlen) == 0\n\t\t&& (!(flags & P_COMMA)\n\t\t    || s[newlen] == ','\n\t\t    || s[newlen] == NUL))\n\t    return s;\n\t// Count backslashes.  Only a comma with an even number of backslashes\n\t// or a single backslash preceded by a comma before it is recognized as\n\t// a separator.\n\tif ((s > origval + 1\n\t\t    && s[-1] == '\\\\'\n\t\t    && s[-2] != ',')\n\t\t|| (s == origval + 1\n\t\t    && s[-1] == '\\\\'))\n\t    ++bs;\n\telse\n\t    bs = 0;\n    }\n    return NULL;\n}\n\n/*\n * Set the Vi-default value of a number option.\n * Used for 'lines' and 'columns'.\n */\n    void\nset_number_default(char *name, long val)\n{\n    int\t\topt_idx;\n\n    opt_idx = findoption((char_u *)name);\n    if (opt_idx >= 0)\n\toptions[opt_idx].def_val[VI_DEFAULT] = (char_u *)(long_i)val;\n}\n\n#if defined(FEAT_PROP_POPUP) || defined(PROTO)\n/*\n * Set all window-local and buffer-local options to the Vim default.\n * local-global options will use the global value.\n * When \"do_buffer\" is FALSE don't set buffer-local options.\n */\n    void\nset_local_options_default(win_T *wp, int do_buffer)\n{\n    win_T\t*save_curwin = curwin;\n    int\t\ti;\n\n    curwin = wp;\n    curbuf = curwin->w_buffer;\n    block_autocmds();\n\n    for (i = 0; !istermoption_idx(i); i++)\n    {\n\tstruct vimoption    *p = &(options[i]);\n\tchar_u\t\t    *varp = get_varp_scope(p, OPT_LOCAL);\n\n\tif (p->indir != PV_NONE\n\t\t&& (do_buffer || (p->indir & PV_BUF) == 0)\n\t\t&& !(options[i].flags & P_NODEFAULT)\n\t\t&& !optval_default(p, varp, FALSE))\n\t    set_option_default(i, OPT_FREE|OPT_LOCAL, FALSE);\n    }\n\n    unblock_autocmds();\n    curwin = save_curwin;\n    curbuf = curwin->w_buffer;\n}\n#endif\n\n#if defined(EXITFREE) || defined(PROTO)\n/*\n * Free all options.\n */\n    void\nfree_all_options(void)\n{\n    int\t\ti;\n\n    for (i = 0; !istermoption_idx(i); i++)\n    {\n\tif (options[i].indir == PV_NONE)\n\t{\n\t    // global option: free value and default value.\n\t    if ((options[i].flags & P_ALLOCED) && options[i].var != NULL)\n\t\tfree_string_option(*(char_u **)options[i].var);\n\t    if (options[i].flags & P_DEF_ALLOCED)\n\t\tfree_string_option(options[i].def_val[VI_DEFAULT]);\n\t}\n\telse if (options[i].var != VAR_WIN\n\t\t&& (options[i].flags & P_STRING))\n\t    // buffer-local option: free global value\n\t    clear_string_option((char_u **)options[i].var);\n    }\n    free_operatorfunc_option();\n    free_tagfunc_option();\n}\n#endif\n\n\n/*\n * Initialize the options, part two: After getting Rows and Columns and\n * setting 'term'.\n */\n    void\nset_init_2(void)\n{\n    int\t\tidx;\n\n    /*\n     * 'scroll' defaults to half the window height. The stored default is zero,\n     * which results in the actual value computed from the window height.\n     */\n    idx = findoption((char_u *)\"scroll\");\n    if (idx >= 0 && !(options[idx].flags & P_WAS_SET))\n\tset_option_default(idx, OPT_LOCAL, p_cp);\n    comp_col();\n\n    /*\n     * 'window' is only for backwards compatibility with Vi.\n     * Default is Rows - 1.\n     */\n    if (!option_was_set((char_u *)\"window\"))\n\tp_window = Rows - 1;\n    set_number_default(\"window\", Rows - 1);\n\n    // For DOS console the default is always black.\n#if !((defined(MSWIN)) && !defined(FEAT_GUI))\n    /*\n     * If 'background' wasn't set by the user, try guessing the value,\n     * depending on the terminal name.  Only need to check for terminals\n     * with a dark background, that can handle color.\n     */\n    idx = findoption((char_u *)\"bg\");\n    if (idx >= 0 && !(options[idx].flags & P_WAS_SET)\n\t\t\t\t\t\t && *term_bg_default() == 'd')\n    {\n\tset_string_option_direct(NULL, idx, (char_u *)\"dark\", OPT_FREE, 0);\n\t// don't mark it as set, when starting the GUI it may be\n\t// changed again\n\toptions[idx].flags &= ~P_WAS_SET;\n    }\n#endif\n\n#ifdef CURSOR_SHAPE\n    parse_shape_opt(SHAPE_CURSOR); // set cursor shapes from 'guicursor'\n#endif\n#ifdef FEAT_MOUSESHAPE\n    parse_shape_opt(SHAPE_MOUSE);  // set mouse shapes from 'mouseshape'\n#endif\n#ifdef FEAT_PRINTER\n    (void)parse_printoptions();\t    // parse 'printoptions' default value\n#endif\n}\n\n/*\n * Initialize the options, part three: After reading the .vimrc\n */\n    void\nset_init_3(void)\n{\n#if defined(UNIX) || defined(MSWIN)\n/*\n * Set 'shellpipe' and 'shellredir', depending on the 'shell' option.\n * This is done after other initializations, where 'shell' might have been\n * set, but only if they have not been set before.\n */\n    char_u  *p;\n    int\t    idx_srr;\n    int\t    do_srr;\n# ifdef FEAT_QUICKFIX\n    int\t    idx_sp;\n    int\t    do_sp;\n# endif\n\n    idx_srr = findoption((char_u *)\"srr\");\n    if (idx_srr < 0)\n\tdo_srr = FALSE;\n    else\n\tdo_srr = !(options[idx_srr].flags & P_WAS_SET);\n# ifdef FEAT_QUICKFIX\n    idx_sp = findoption((char_u *)\"sp\");\n    if (idx_sp < 0)\n\tdo_sp = FALSE;\n    else\n\tdo_sp = !(options[idx_sp].flags & P_WAS_SET);\n# endif\n    p = get_isolated_shell_name();\n    if (p != NULL)\n    {\n\t/*\n\t * Default for p_sp is \"| tee\", for p_srr is \">\".\n\t * For known shells it is changed here to include stderr.\n\t */\n\tif (\t   fnamecmp(p, \"csh\") == 0\n\t\t|| fnamecmp(p, \"tcsh\") == 0\n# if defined(MSWIN)\t// also check with .exe extension\n\t\t|| fnamecmp(p, \"csh.exe\") == 0\n\t\t|| fnamecmp(p, \"tcsh.exe\") == 0\n# endif\n\t   )\n\t{\n# if defined(FEAT_QUICKFIX)\n\t    if (do_sp)\n\t    {\n#  ifdef MSWIN\n\t\tp_sp = (char_u *)\">&\";\n#  else\n\t\tp_sp = (char_u *)\"|& tee\";\n#  endif\n\t\toptions[idx_sp].def_val[VI_DEFAULT] = p_sp;\n\t    }\n# endif\n\t    if (do_srr)\n\t    {\n\t\tp_srr = (char_u *)\">&\";\n\t\toptions[idx_srr].def_val[VI_DEFAULT] = p_srr;\n\t    }\n\t}\n# ifdef MSWIN\n\t// Windows PowerShell output is UTF-16 with BOM so re-encode to the\n\t// current codepage.\n\telse if (   fnamecmp(p, \"powershell\") == 0\n\t\t    || fnamecmp(p, \"powershell.exe\") == 0\n\t\t)\n\t{\n# if defined(FEAT_QUICKFIX)\n\t\tif (do_sp)\n\t\t{\n\t\t    p_sp = (char_u *)\"2>&1 | Out-File -Encoding default\";\n\t\t    options[idx_sp].def_val[VI_DEFAULT] = p_sp;\n\t\t}\n# endif\n\t\tif (do_srr)\n\t\t{\n\t\t    p_srr = (char_u *)\"2>&1 | Out-File -Encoding default\";\n\t\t    options[idx_srr].def_val[VI_DEFAULT] = p_srr;\n\t\t}\n\t}\n#endif\n\telse\n\t    // Always use POSIX shell style redirection if we reach this\n\t    if (       fnamecmp(p, \"sh\") == 0\n\t\t    || fnamecmp(p, \"ksh\") == 0\n\t\t    || fnamecmp(p, \"mksh\") == 0\n\t\t    || fnamecmp(p, \"pdksh\") == 0\n\t\t    || fnamecmp(p, \"zsh\") == 0\n\t\t    || fnamecmp(p, \"zsh-beta\") == 0\n\t\t    || fnamecmp(p, \"bash\") == 0\n\t\t    || fnamecmp(p, \"fish\") == 0\n\t\t    || fnamecmp(p, \"ash\") == 0\n\t\t    || fnamecmp(p, \"dash\") == 0\n\t\t    || fnamecmp(p, \"pwsh\") == 0\n# ifdef MSWIN\n\t\t    || fnamecmp(p, \"cmd\") == 0\n\t\t    || fnamecmp(p, \"sh.exe\") == 0\n\t\t    || fnamecmp(p, \"ksh.exe\") == 0\n\t\t    || fnamecmp(p, \"mksh.exe\") == 0\n\t\t    || fnamecmp(p, \"pdksh.exe\") == 0\n\t\t    || fnamecmp(p, \"zsh.exe\") == 0\n\t\t    || fnamecmp(p, \"zsh-beta.exe\") == 0\n\t\t    || fnamecmp(p, \"bash.exe\") == 0\n\t\t    || fnamecmp(p, \"cmd.exe\") == 0\n\t\t    || fnamecmp(p, \"dash.exe\") == 0\n\t\t    || fnamecmp(p, \"pwsh.exe\") == 0\n# endif\n\t\t    )\n\t    {\n# if defined(FEAT_QUICKFIX)\n\t\tif (do_sp)\n\t\t{\n#  ifdef MSWIN\n\t\t    p_sp = (char_u *)\">%s 2>&1\";\n#  else\n\t\t    if (fnamecmp(p, \"pwsh\") == 0)\n\t\t\tp_sp = (char_u *)\">%s 2>&1\";\n\t\t    else\n\t\t\tp_sp = (char_u *)\"2>&1| tee\";\n#  endif\n\t\t    options[idx_sp].def_val[VI_DEFAULT] = p_sp;\n\t\t}\n# endif\n\t\tif (do_srr)\n\t\t{\n\t\t    p_srr = (char_u *)\">%s 2>&1\";\n\t\t    options[idx_srr].def_val[VI_DEFAULT] = p_srr;\n\t\t}\n\t    }\n\tvim_free(p);\n    }\n#endif\n\n#if defined(MSWIN)\n    /*\n     * Set 'shellcmdflag', 'shellxquote', and 'shellquote' depending on the\n     * 'shell' option.\n     * This is done after other initializations, where 'shell' might have been\n     * set, but only if they have not been set before.\n     * Default values depend on shell (cmd.exe is default shell):\n     *\n     *\t\t\t    p_shcf\tp_sxq\n     * cmd.exe          -   \"/c\"\t\"(\"\n     * powershell.exe   -   \"-Command\"\t\"\\\"\"\n     * pwsh.exe\t\t-   \"-c\"\t\"\\\"\"\n     * \"sh\" like shells -   \"-c\"\t\"\\\"\"\n     *\n     * For Win32 p_sxq is set instead of p_shq to include shell redirection.\n     */\n    if (strstr((char *)gettail(p_sh), \"powershell\") != NULL)\n    {\n\tint\tidx_opt;\n\n\tidx_opt = findoption((char_u *)\"shcf\");\n\tif (idx_opt >= 0 && !(options[idx_opt].flags & P_WAS_SET))\n\t{\n\t    p_shcf = (char_u*)\"-Command\";\n\t    options[idx_opt].def_val[VI_DEFAULT] = p_shcf;\n\t}\n\n\tidx_opt = findoption((char_u *)\"sxq\");\n\tif (idx_opt >= 0 && !(options[idx_opt].flags & P_WAS_SET))\n\t{\n\t    p_sxq = (char_u*)\"\\\"\";\n\t    options[idx_opt].def_val[VI_DEFAULT] = p_sxq;\n\t}\n    }\n    else if (strstr((char *)gettail(p_sh), \"sh\") != NULL)\n    {\n\tint\tidx3;\n\n\tidx3 = findoption((char_u *)\"shcf\");\n\tif (idx3 >= 0 && !(options[idx3].flags & P_WAS_SET))\n\t{\n\t    p_shcf = (char_u *)\"-c\";\n\t    options[idx3].def_val[VI_DEFAULT] = p_shcf;\n\t}\n\n\t// Somehow Win32 requires the quotes around the redirection too\n\tidx3 = findoption((char_u *)\"sxq\");\n\tif (idx3 >= 0 && !(options[idx3].flags & P_WAS_SET))\n\t{\n\t    p_sxq = (char_u *)\"\\\"\";\n\t    options[idx3].def_val[VI_DEFAULT] = p_sxq;\n\t}\n    }\n    else if (strstr((char *)gettail(p_sh), \"cmd.exe\") != NULL)\n    {\n\tint\tidx3;\n\n\t/*\n\t * cmd.exe on Windows will strip the first and last double quote given\n\t * on the command line, e.g. most of the time things like:\n\t *   cmd /c \"my path/to/echo\" \"my args to echo\"\n\t * become:\n\t *   my path/to/echo\" \"my args to echo\n\t * when executed.\n\t *\n\t * To avoid this, set shellxquote to surround the command in\n\t * parenthesis.  This appears to make most commands work, without\n\t * breaking commands that worked previously, such as\n\t * '\"path with spaces/cmd\" \"a&b\"'.\n\t */\n\tidx3 = findoption((char_u *)\"sxq\");\n\tif (idx3 >= 0 && !(options[idx3].flags & P_WAS_SET))\n\t{\n\t    p_sxq = (char_u *)\"(\";\n\t    options[idx3].def_val[VI_DEFAULT] = p_sxq;\n\t}\n\n\tidx3 = findoption((char_u *)\"shcf\");\n\tif (idx3 >= 0 && !(options[idx3].flags & P_WAS_SET))\n\t{\n\t    p_shcf = (char_u *)\"/c\";\n\t    options[idx3].def_val[VI_DEFAULT] = p_shcf;\n\t}\n    }\n#endif\n\n    if (BUFEMPTY())\n    {\n\tint idx_ffs = findoption((char_u *)\"ffs\");\n\n\t// Apply the first entry of 'fileformats' to the initial buffer.\n\tif (idx_ffs >= 0 && (options[idx_ffs].flags & P_WAS_SET))\n\t    set_fileformat(default_fileformat(), OPT_LOCAL);\n    }\n\n    set_title_defaults();\n}\n\n#if defined(FEAT_MULTI_LANG) || defined(PROTO)\n/*\n * When 'helplang' is still at its default value, set it to \"lang\".\n * Only the first two characters of \"lang\" are used.\n */\n    void\nset_helplang_default(char_u *lang)\n{\n    int\t\tidx;\n\n    if (lang == NULL || STRLEN(lang) < 2)\t// safety check\n\treturn;\n    idx = findoption((char_u *)\"hlg\");\n    if (idx >= 0 && !(options[idx].flags & P_WAS_SET))\n    {\n\tif (options[idx].flags & P_ALLOCED)\n\t    free_string_option(p_hlg);\n\tp_hlg = vim_strsave(lang);\n\tif (p_hlg == NULL)\n\t    p_hlg = empty_option;\n\telse\n\t{\n\t    // zh_CN becomes \"cn\", zh_TW becomes \"tw\"\n\t    if (STRNICMP(p_hlg, \"zh_\", 3) == 0 && STRLEN(p_hlg) >= 5)\n\t    {\n\t\tp_hlg[0] = TOLOWER_ASC(p_hlg[3]);\n\t\tp_hlg[1] = TOLOWER_ASC(p_hlg[4]);\n\t    }\n\t    // any C like setting, such as C.UTF-8, becomes \"en\"\n\t    else if (STRLEN(p_hlg) >= 1 && *p_hlg == 'C')\n\t    {\n\t\tp_hlg[0] = 'e';\n\t\tp_hlg[1] = 'n';\n\t    }\n\t    p_hlg[2] = NUL;\n\t}\n\toptions[idx].flags |= P_ALLOCED;\n    }\n}\n#endif\n\n/*\n * 'title' and 'icon' only default to true if they have not been set or reset\n * in .vimrc and we can read the old value.\n * When 'title' and 'icon' have been reset in .vimrc, we won't even check if\n * they can be reset.  This reduces startup time when using X on a remote\n * machine.\n */\n    void\nset_title_defaults(void)\n{\n    int\t    idx1;\n    long    val;\n\n    /*\n     * If GUI is (going to be) used, we can always set the window title and\n     * icon name.  Saves a bit of time, because the X11 display server does\n     * not need to be contacted.\n     */\n    idx1 = findoption((char_u *)\"title\");\n    if (idx1 >= 0 && !(options[idx1].flags & P_WAS_SET))\n    {\n#ifdef FEAT_GUI\n\tif (gui.starting || gui.in_use)\n\t    val = TRUE;\n\telse\n#endif\n\t    val = mch_can_restore_title();\n\toptions[idx1].def_val[VI_DEFAULT] = (char_u *)(long_i)val;\n\tp_title = val;\n    }\n    idx1 = findoption((char_u *)\"icon\");\n    if (idx1 >= 0 && !(options[idx1].flags & P_WAS_SET))\n    {\n#ifdef FEAT_GUI\n\tif (gui.starting || gui.in_use)\n\t    val = TRUE;\n\telse\n#endif\n\t    val = mch_can_restore_icon();\n\toptions[idx1].def_val[VI_DEFAULT] = (char_u *)(long_i)val;\n\tp_icon = val;\n    }\n}\n\n    void\nex_set(exarg_T *eap)\n{\n    int\t\tflags = 0;\n\n    if (eap->cmdidx == CMD_setlocal)\n\tflags = OPT_LOCAL;\n    else if (eap->cmdidx == CMD_setglobal)\n\tflags = OPT_GLOBAL;\n#if defined(FEAT_EVAL) && defined(FEAT_BROWSE)\n    if ((cmdmod.cmod_flags & CMOD_BROWSE) && flags == 0)\n\tex_options(eap);\n    else\n#endif\n    {\n\tif (eap->forceit)\n\t    flags |= OPT_ONECOLUMN;\n\t(void)do_set(eap->arg, flags);\n    }\n}\n\n/*\n * Parse 'arg' for option settings.\n *\n * 'arg' may be IObuff, but only when no errors can be present and option\n * does not need to be expanded with option_expand().\n * \"opt_flags\":\n * 0 for \":set\"\n * OPT_GLOBAL     for \":setglobal\"\n * OPT_LOCAL      for \":setlocal\" and a modeline\n * OPT_MODELINE   for a modeline\n * OPT_WINONLY    to only set window-local options\n * OPT_NOWIN\t  to skip setting window-local options\n * OPT_ONECOLUMN  do not use multiple columns\n *\n * returns FAIL if an error is detected, OK otherwise\n */\n    int\ndo_set(\n    char_u\t*arg_start,\t// option string (may be written to!)\n    int\t\topt_flags)\n{\n    char_u\t*arg = arg_start;\n    int\t\topt_idx;\n    char\t*errmsg;\n    char\terrbuf[80];\n    char_u\t*startarg;\n    int\t\tprefix;\t// 1: nothing, 0: \"no\", 2: \"inv\" in front of name\n    int\t\tnextchar;\t    // next non-white char after option name\n    int\t\tafterchar;\t    // character just after option name\n    int\t\tlen;\n    int\t\ti;\n    varnumber_T\tvalue;\n    int\t\tkey;\n    long_u\tflags;\t\t    // flags for current option\n    char_u\t*varp = NULL;\t    // pointer to variable for current option\n    int\t\tdid_show = FALSE;   // already showed one value\n    int\t\tadding;\t\t    // \"opt+=arg\"\n    int\t\tprepending;\t    // \"opt^=arg\"\n    int\t\tremoving;\t    // \"opt-=arg\"\n    int\t\tcp_val = 0;\n    char_u\tkey_name[2];\n\n    if (*arg == NUL)\n    {\n\tshowoptions(0, opt_flags);\n\tdid_show = TRUE;\n\tgoto theend;\n    }\n\n    while (*arg != NUL)\t\t// loop to process all options\n    {\n\terrmsg = NULL;\n\tstartarg = arg;\t\t// remember for error message\n\n\tif (STRNCMP(arg, \"all\", 3) == 0 && !isalpha(arg[3])\n\t\t\t\t\t\t&& !(opt_flags & OPT_MODELINE))\n\t{\n\t    /*\n\t     * \":set all\"  show all options.\n\t     * \":set all&\" set all options to their default value.\n\t     */\n\t    arg += 3;\n\t    if (*arg == '&')\n\t    {\n\t\t++arg;\n\t\t// Only for :set command set global value of local options.\n\t\tset_options_default(OPT_FREE | opt_flags);\n\t\tdidset_options();\n\t\tdidset_options2();\n\t\tredraw_all_later(CLEAR);\n\t    }\n\t    else\n\t    {\n\t\tshowoptions(1, opt_flags);\n\t\tdid_show = TRUE;\n\t    }\n\t}\n\telse if (STRNCMP(arg, \"termcap\", 7) == 0 && !(opt_flags & OPT_MODELINE))\n\t{\n\t    showoptions(2, opt_flags);\n\t    show_termcodes(opt_flags);\n\t    did_show = TRUE;\n\t    arg += 7;\n\t}\n\telse\n\t{\n\t    prefix = 1;\n\t    if (STRNCMP(arg, \"no\", 2) == 0 && STRNCMP(arg, \"novice\", 6) != 0)\n\t    {\n\t\tprefix = 0;\n\t\targ += 2;\n\t    }\n\t    else if (STRNCMP(arg, \"inv\", 3) == 0)\n\t    {\n\t\tprefix = 2;\n\t\targ += 3;\n\t    }\n\n\t    // find end of name\n\t    key = 0;\n\t    if (*arg == '<')\n\t    {\n\t\topt_idx = -1;\n\t\t// look out for <t_>;>\n\t\tif (arg[1] == 't' && arg[2] == '_' && arg[3] && arg[4])\n\t\t    len = 5;\n\t\telse\n\t\t{\n\t\t    len = 1;\n\t\t    while (arg[len] != NUL && arg[len] != '>')\n\t\t\t++len;\n\t\t}\n\t\tif (arg[len] != '>')\n\t\t{\n\t\t    errmsg = e_invalid_argument;\n\t\t    goto skip;\n\t\t}\n\t\targ[len] = NUL;\t\t\t    // put NUL after name\n\t\tif (arg[1] == 't' && arg[2] == '_') // could be term code\n\t\t    opt_idx = findoption(arg + 1);\n\t\targ[len++] = '>';\t\t    // restore '>'\n\t\tif (opt_idx == -1)\n\t\t    key = find_key_option(arg + 1, TRUE);\n\t    }\n\t    else\n\t    {\n\t\tlen = 0;\n\t\t/*\n\t\t * The two characters after \"t_\" may not be alphanumeric.\n\t\t */\n\t\tif (arg[0] == 't' && arg[1] == '_' && arg[2] && arg[3])\n\t\t    len = 4;\n\t\telse\n\t\t    while (ASCII_ISALNUM(arg[len]) || arg[len] == '_')\n\t\t\t++len;\n\t\tnextchar = arg[len];\n\t\targ[len] = NUL;\t\t\t    // put NUL after name\n\t\topt_idx = findoption(arg);\n\t\targ[len] = nextchar;\t\t    // restore nextchar\n\t\tif (opt_idx == -1)\n\t\t    key = find_key_option(arg, FALSE);\n\t    }\n\n\t    // remember character after option name\n\t    afterchar = arg[len];\n\n\t    if (in_vim9script())\n\t    {\n\t\tchar_u *p = skipwhite(arg + len);\n\n\t\t// disallow white space before =val, +=val, -=val, ^=val\n\t\tif (p > arg + len && (p[0] == '='\n\t\t\t|| (vim_strchr((char_u *)\"+-^\", p[0]) != NULL\n\t\t\t\t\t\t\t      && p[1] == '=')))\n\t\t{\n\t\t    errmsg = e_no_white_space_allowed_between_option_and;\n\t\t    arg = p;\n\t\t    startarg = p;\n\t\t    goto skip;\n\t\t}\n\t    }\n\t    else\n\t\t// skip white space, allow \":set ai  ?\", \":set hlsearch  !\"\n\t\twhile (VIM_ISWHITE(arg[len]))\n\t\t    ++len;\n\n\t    adding = FALSE;\n\t    prepending = FALSE;\n\t    removing = FALSE;\n\t    if (arg[len] != NUL && arg[len + 1] == '=')\n\t    {\n\t\tif (arg[len] == '+')\n\t\t{\n\t\t    adding = TRUE;\t\t// \"+=\"\n\t\t    ++len;\n\t\t}\n\t\telse if (arg[len] == '^')\n\t\t{\n\t\t    prepending = TRUE;\t\t// \"^=\"\n\t\t    ++len;\n\t\t}\n\t\telse if (arg[len] == '-')\n\t\t{\n\t\t    removing = TRUE;\t\t// \"-=\"\n\t\t    ++len;\n\t\t}\n\t    }\n\t    nextchar = arg[len];\n\n\t    if (opt_idx == -1 && key == 0)\t// found a mismatch: skip\n\t    {\n\t\tif (in_vim9script() && arg > arg_start\n\t\t\t\t  && vim_strchr((char_u *)\"!&<\", *arg) != NULL)\n\t\t    errmsg = e_no_white_space_allowed_between_option_and;\n\t\telse\n\t\t    errmsg = N_(e_unknown_option);\n\t\tgoto skip;\n\t    }\n\n\t    if (opt_idx >= 0)\n\t    {\n\t\tif (options[opt_idx].var == NULL)   // hidden option: skip\n\t\t{\n\t\t    // Only give an error message when requesting the value of\n\t\t    // a hidden option, ignore setting it.\n\t\t    if (vim_strchr((char_u *)\"=:!&<\", nextchar) == NULL\n\t\t\t    && (!(options[opt_idx].flags & P_BOOL)\n\t\t\t\t|| nextchar == '?'))\n\t\t\terrmsg = N_(e_option_not_supported);\n\t\t    goto skip;\n\t\t}\n\n\t\tflags = options[opt_idx].flags;\n\t\tvarp = get_varp_scope(&(options[opt_idx]), opt_flags);\n\t    }\n\t    else\n\t    {\n\t\tflags = P_STRING;\n\t\tif (key < 0)\n\t\t{\n\t\t    key_name[0] = KEY2TERMCAP0(key);\n\t\t    key_name[1] = KEY2TERMCAP1(key);\n\t\t}\n\t\telse\n\t\t{\n\t\t    key_name[0] = KS_KEY;\n\t\t    key_name[1] = (key & 0xff);\n\t\t}\n\t    }\n\n\t    // Skip all options that are not window-local (used when showing\n\t    // an already loaded buffer in a window).\n\t    if ((opt_flags & OPT_WINONLY)\n\t\t\t  && (opt_idx < 0 || options[opt_idx].var != VAR_WIN))\n\t\tgoto skip;\n\n\t    // Skip all options that are window-local (used for :vimgrep).\n\t    if ((opt_flags & OPT_NOWIN) && opt_idx >= 0\n\t\t\t\t\t   && options[opt_idx].var == VAR_WIN)\n\t\tgoto skip;\n\n\t    // Disallow changing some options from modelines.\n\t    if (opt_flags & OPT_MODELINE)\n\t    {\n\t\tif (flags & (P_SECURE | P_NO_ML))\n\t\t{\n\t\t    errmsg = N_(e_not_allowed_in_modeline);\n\t\t    goto skip;\n\t\t}\n\t\tif ((flags & P_MLE) && !p_mle)\n\t\t{\n\t\t    errmsg = N_(e_not_allowed_in_modeline_when_modelineexpr_is_off);\n\t\t    goto skip;\n\t\t}\n#ifdef FEAT_DIFF\n\t\t// In diff mode some options are overruled.  This avoids that\n\t\t// 'foldmethod' becomes \"marker\" instead of \"diff\" and that\n\t\t// \"wrap\" gets set.\n\t\tif (curwin->w_p_diff\n\t\t\t&& opt_idx >= 0  // shut up coverity warning\n\t\t\t&& (\n#ifdef FEAT_FOLDING\n\t\t\t    options[opt_idx].indir == PV_FDM ||\n#endif\n\t\t\t    options[opt_idx].indir == PV_WRAP))\n\t\t    goto skip;\n#endif\n\t    }\n\n#ifdef HAVE_SANDBOX\n\t    // Disallow changing some options in the sandbox\n\t    if (sandbox != 0 && (flags & P_SECURE))\n\t    {\n\t\terrmsg = e_not_allowed_in_sandbox;\n\t\tgoto skip;\n\t    }\n#endif\n\n\t    if (vim_strchr((char_u *)\"?=:!&<\", nextchar) != NULL)\n\t    {\n\t\targ += len;\n\t\tcp_val = p_cp;\n\t\tif (nextchar == '&' && arg[1] == 'v' && arg[2] == 'i')\n\t\t{\n\t\t    if (arg[3] == 'm')\t// \"opt&vim\": set to Vim default\n\t\t    {\n\t\t\tcp_val = FALSE;\n\t\t\targ += 3;\n\t\t    }\n\t\t    else\t\t// \"opt&vi\": set to Vi default\n\t\t    {\n\t\t\tcp_val = TRUE;\n\t\t\targ += 2;\n\t\t    }\n\t\t}\n\t\tif (vim_strchr((char_u *)\"?!&<\", nextchar) != NULL\n\t\t\t&& arg[1] != NUL && !VIM_ISWHITE(arg[1]))\n\t\t{\n\t\t    errmsg = e_trailing_characters;\n\t\t    goto skip;\n\t\t}\n\t    }\n\n\t    /*\n\t     * allow '=' and ':' for historical reasons (MSDOS command.com\n\t     * allows only one '=' character per \"set\" command line. grrr. (jw)\n\t     */\n\t    if (nextchar == '?'\n\t\t    || (prefix == 1\n\t\t\t&& vim_strchr((char_u *)\"=:&<\", nextchar) == NULL\n\t\t\t&& !(flags & P_BOOL)))\n\t    {\n\t\t/*\n\t\t * print value\n\t\t */\n\t\tif (did_show)\n\t\t    msg_putchar('\\n');\t    // cursor below last one\n\t\telse\n\t\t{\n\t\t    gotocmdline(TRUE);\t    // cursor at status line\n\t\t    did_show = TRUE;\t    // remember that we did a line\n\t\t}\n\t\tif (opt_idx >= 0)\n\t\t{\n\t\t    showoneopt(&options[opt_idx], opt_flags);\n#ifdef FEAT_EVAL\n\t\t    if (p_verbose > 0)\n\t\t    {\n\t\t\t// Mention where the option was last set.\n\t\t\tif (varp == options[opt_idx].var)\n\t\t\t    last_set_msg(options[opt_idx].script_ctx);\n\t\t\telse if ((int)options[opt_idx].indir & PV_WIN)\n\t\t\t    last_set_msg(curwin->w_p_script_ctx[\n\t\t\t\t      (int)options[opt_idx].indir & PV_MASK]);\n\t\t\telse if ((int)options[opt_idx].indir & PV_BUF)\n\t\t\t    last_set_msg(curbuf->b_p_script_ctx[\n\t\t\t\t      (int)options[opt_idx].indir & PV_MASK]);\n\t\t    }\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    char_u\t    *p;\n\n\t\t    p = find_termcode(key_name);\n\t\t    if (p == NULL)\n\t\t    {\n\t\t\terrmsg = N_(e_key_code_not_set);\n\t\t\tgoto skip;\n\t\t    }\n\t\t    else\n\t\t\t(void)show_one_termcode(key_name, p, TRUE);\n\t\t}\n\t\tif (nextchar != '?'\n\t\t\t&& nextchar != NUL && !VIM_ISWHITE(afterchar))\n\t\t    errmsg = e_trailing_characters;\n\t    }\n\t    else\n\t    {\n\t\tint value_is_replaced = !prepending && !adding && !removing;\n\t\tint value_checked = FALSE;\n\n\t\tif (flags & P_BOOL)\t\t    // boolean\n\t\t{\n\t\t    if (nextchar == '=' || nextchar == ':')\n\t\t    {\n\t\t\terrmsg = e_invalid_argument;\n\t\t\tgoto skip;\n\t\t    }\n\n\t\t    /*\n\t\t     * \":set opt!\": invert\n\t\t     * \":set opt&\": reset to default value\n\t\t     * \":set opt<\": reset to global value\n\t\t     */\n\t\t    if (nextchar == '!')\n\t\t\tvalue = *(int *)(varp) ^ 1;\n\t\t    else if (nextchar == '&')\n\t\t\tvalue = (int)(long)(long_i)options[opt_idx].def_val[\n\t\t\t\t\t\t((flags & P_VI_DEF) || cp_val)\n\t\t\t\t\t\t ?  VI_DEFAULT : VIM_DEFAULT];\n\t\t    else if (nextchar == '<')\n\t\t    {\n\t\t\t// For 'autoread' -1 means to use global value.\n\t\t\tif ((int *)varp == &curbuf->b_p_ar\n\t\t\t\t\t\t    && opt_flags == OPT_LOCAL)\n\t\t\t    value = -1;\n\t\t\telse\n\t\t\t    value = *(int *)get_varp_scope(&(options[opt_idx]),\n\t\t\t\t\t\t\t\t  OPT_GLOBAL);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t/*\n\t\t\t * \":set invopt\": invert\n\t\t\t * \":set opt\" or \":set noopt\": set or reset\n\t\t\t */\n\t\t\tif (nextchar != NUL && !VIM_ISWHITE(afterchar))\n\t\t\t{\n\t\t\t    errmsg = e_trailing_characters;\n\t\t\t    goto skip;\n\t\t\t}\n\t\t\tif (prefix == 2)\t// inv\n\t\t\t    value = *(int *)(varp) ^ 1;\n\t\t\telse\n\t\t\t    value = prefix;\n\t\t    }\n\n\t\t    errmsg = set_bool_option(opt_idx, varp, (int)value,\n\t\t\t\t\t\t\t\t   opt_flags);\n\t\t}\n\t\telse\t\t\t\t    // numeric or string\n\t\t{\n\t\t    if (vim_strchr((char_u *)\"=:&<\", nextchar) == NULL\n\t\t\t\t\t\t\t       || prefix != 1)\n\t\t    {\n\t\t\terrmsg = e_invalid_argument;\n\t\t\tgoto skip;\n\t\t    }\n\n\t\t    if (flags & P_NUM)\t\t    // numeric\n\t\t    {\n\t\t\t/*\n\t\t\t * Different ways to set a number option:\n\t\t\t * &\t    set to default value\n\t\t\t * <\t    set to global value\n\t\t\t * <xx>\t    accept special key codes for 'wildchar'\n\t\t\t * c\t    accept any non-digit for 'wildchar'\n\t\t\t * [-]0-9   set number\n\t\t\t * other    error\n\t\t\t */\n\t\t\t++arg;\n\t\t\tif (nextchar == '&')\n\t\t\t    value = (long)(long_i)options[opt_idx].def_val[\n\t\t\t\t\t\t((flags & P_VI_DEF) || cp_val)\n\t\t\t\t\t\t ?  VI_DEFAULT : VIM_DEFAULT];\n\t\t\telse if (nextchar == '<')\n\t\t\t{\n\t\t\t    // For 'undolevels' NO_LOCAL_UNDOLEVEL means to\n\t\t\t    // use the global value.\n\t\t\t    if ((long *)varp == &curbuf->b_p_ul\n\t\t\t\t\t\t    && opt_flags == OPT_LOCAL)\n\t\t\t\tvalue = NO_LOCAL_UNDOLEVEL;\n\t\t\t    else\n\t\t\t\tvalue = *(long *)get_varp_scope(\n\t\t\t\t\t     &(options[opt_idx]), OPT_GLOBAL);\n\t\t\t}\n\t\t\telse if (((long *)varp == &p_wc\n\t\t\t\t    || (long *)varp == &p_wcm)\n\t\t\t\t&& (*arg == '<'\n\t\t\t\t    || *arg == '^'\n\t\t\t\t    || (*arg != NUL\n\t\t\t\t\t&& (!arg[1] || VIM_ISWHITE(arg[1]))\n\t\t\t\t\t&& !VIM_ISDIGIT(*arg))))\n\t\t\t{\n\t\t\t    value = string_to_key(arg, FALSE);\n\t\t\t    if (value == 0 && (long *)varp != &p_wcm)\n\t\t\t    {\n\t\t\t\terrmsg = e_invalid_argument;\n\t\t\t\tgoto skip;\n\t\t\t    }\n\t\t\t}\n\t\t\telse if (*arg == '-' || VIM_ISDIGIT(*arg))\n\t\t\t{\n\t\t\t    // Allow negative (for 'undolevels'), octal and\n\t\t\t    // hex numbers.\n\t\t\t    vim_str2nr(arg, NULL, &i, STR2NR_ALL,\n\t\t\t\t\t\t     &value, NULL, 0, TRUE);\n\t\t\t    if (i == 0 || (arg[i] != NUL\n\t\t\t\t\t\t      && !VIM_ISWHITE(arg[i])))\n\t\t\t    {\n\t\t\t\terrmsg = N_(e_number_required_after_equal);\n\t\t\t\tgoto skip;\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    errmsg = N_(e_number_required_after_equal);\n\t\t\t    goto skip;\n\t\t\t}\n\n\t\t\tif (adding)\n\t\t\t    value = *(long *)varp + value;\n\t\t\tif (prepending)\n\t\t\t    value = *(long *)varp * value;\n\t\t\tif (removing)\n\t\t\t    value = *(long *)varp - value;\n\t\t\terrmsg = set_num_option(opt_idx, varp, value,\n\t\t\t\t\t   errbuf, sizeof(errbuf), opt_flags);\n\t\t    }\n\t\t    else if (opt_idx >= 0)\t\t    // string\n\t\t    {\n\t\t\tchar_u\t  *save_arg = NULL;\n\t\t\tchar_u\t  *s = NULL;\n\t\t\tchar_u\t  *oldval = NULL; // previous value if *varp\n\t\t\tchar_u\t  *newval;\n\t\t\tchar_u\t  *origval = NULL;\n\t\t\tchar_u\t  *origval_l = NULL;\n\t\t\tchar_u\t  *origval_g = NULL;\n#if defined(FEAT_EVAL)\n\t\t\tchar_u\t  *saved_origval = NULL;\n\t\t\tchar_u\t  *saved_origval_l = NULL;\n\t\t\tchar_u\t  *saved_origval_g = NULL;\n\t\t\tchar_u\t  *saved_newval = NULL;\n#endif\n\t\t\tunsigned  newlen;\n\t\t\tint\t  comma;\n\t\t\tint\t  new_value_alloced;\t// new string option\n\t\t\t\t\t\t\t// was allocated\n\n\t\t\t// When using \":set opt=val\" for a global option\n\t\t\t// with a local value the local value will be\n\t\t\t// reset, use the global value here.\n\t\t\tif ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0\n\t\t\t\t&& ((int)options[opt_idx].indir & PV_BOTH))\n\t\t\t    varp = options[opt_idx].var;\n\n\t\t\t// The old value is kept until we are sure that the\n\t\t\t// new value is valid.\n\t\t\toldval = *(char_u **)varp;\n\n\t\t\tif ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\t\t\t{\n\t\t\t    origval_l = *(char_u **)get_varp_scope(\n\t\t\t\t\t       &(options[opt_idx]), OPT_LOCAL);\n\t\t\t    origval_g = *(char_u **)get_varp_scope(\n\t\t\t\t\t      &(options[opt_idx]), OPT_GLOBAL);\n\n\t\t\t    // A global-local string option might have an empty\n\t\t\t    // option as value to indicate that the global\n\t\t\t    // value should be used.\n\t\t\t    if (((int)options[opt_idx].indir & PV_BOTH)\n\t\t\t\t\t\t  && origval_l == empty_option)\n\t\t\t\torigval_l = origval_g;\n\t\t\t}\n\n\t\t\t// When setting the local value of a global\n\t\t\t// option, the old value may be the global value.\n\t\t\tif (((int)options[opt_idx].indir & PV_BOTH)\n\t\t\t\t\t       && (opt_flags & OPT_LOCAL))\n\t\t\t    origval = *(char_u **)get_varp(\n\t\t\t\t\t\t       &options[opt_idx]);\n\t\t\telse\n\t\t\t    origval = oldval;\n\n\t\t\tif (nextchar == '&')\t// set to default val\n\t\t\t{\n\t\t\t    newval = options[opt_idx].def_val[\n\t\t\t\t\t\t((flags & P_VI_DEF) || cp_val)\n\t\t\t\t\t\t ?  VI_DEFAULT : VIM_DEFAULT];\n\t\t\t    if ((char_u **)varp == &p_bg)\n\t\t\t    {\n\t\t\t\t// guess the value of 'background'\n#ifdef FEAT_GUI\n\t\t\t\tif (gui.in_use)\n\t\t\t\t    newval = gui_bg_default();\n\t\t\t\telse\n#endif\n\t\t\t\t    newval = term_bg_default();\n\t\t\t    }\n\t\t\t    else if ((char_u **)varp == &p_fencs && enc_utf8)\n\t\t\t\tnewval = fencs_utf8_default;\n\n\t\t\t    // expand environment variables and ~ since the\n\t\t\t    // default value was already expanded, only\n\t\t\t    // required when an environment variable was set\n\t\t\t    // later\n\t\t\t    if (newval == NULL)\n\t\t\t\tnewval = empty_option;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\ts = option_expand(opt_idx, newval);\n\t\t\t\tif (s == NULL)\n\t\t\t\t    s = newval;\n\t\t\t\tnewval = vim_strsave(s);\n\t\t\t    }\n\t\t\t    new_value_alloced = TRUE;\n\t\t\t}\n\t\t\telse if (nextchar == '<')\t// set to global val\n\t\t\t{\n\t\t\t    newval = vim_strsave(*(char_u **)get_varp_scope(\n\t\t\t\t\t     &(options[opt_idx]), OPT_GLOBAL));\n\t\t\t    new_value_alloced = TRUE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    ++arg;\t// jump to after the '=' or ':'\n\n\t\t\t    /*\n\t\t\t     * Set 'keywordprg' to \":help\" if an empty\n\t\t\t     * value was passed to :set by the user.\n\t\t\t     * Misuse errbuf[] for the resulting string.\n\t\t\t     */\n\t\t\t    if (varp == (char_u *)&p_kp\n\t\t\t\t\t      && (*arg == NUL || *arg == ' '))\n\t\t\t    {\n\t\t\t\tSTRCPY(errbuf, \":help\");\n\t\t\t\tsave_arg = arg;\n\t\t\t\targ = (char_u *)errbuf;\n\t\t\t    }\n\t\t\t    /*\n\t\t\t     * Convert 'backspace' number to string, for\n\t\t\t     * adding, prepending and removing string.\n\t\t\t     */\n\t\t\t    else if (varp == (char_u *)&p_bs\n\t\t\t\t\t && VIM_ISDIGIT(**(char_u **)varp))\n\t\t\t    {\n\t\t\t\ti = getdigits((char_u **)varp);\n\t\t\t\tswitch (i)\n\t\t\t\t{\n\t\t\t\t    case 0:\n\t\t\t\t\t*(char_u **)varp = empty_option;\n\t\t\t\t\tbreak;\n\t\t\t\t    case 1:\n\t\t\t\t\t*(char_u **)varp = vim_strsave(\n\t\t\t\t\t\t      (char_u *)\"indent,eol\");\n\t\t\t\t\tbreak;\n\t\t\t\t    case 2:\n\t\t\t\t\t*(char_u **)varp = vim_strsave(\n\t\t\t\t\t\t(char_u *)\"indent,eol,start\");\n\t\t\t\t\tbreak;\n\t\t\t\t    case 3:\n\t\t\t\t\t*(char_u **)varp = vim_strsave(\n\t\t\t\t\t\t(char_u *)\"indent,eol,nostop\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvim_free(oldval);\n\t\t\t\tif (origval == oldval)\n\t\t\t\t    origval = *(char_u **)varp;\n\t\t\t\tif (origval_l == oldval)\n\t\t\t\t    origval_l = *(char_u **)varp;\n\t\t\t\tif (origval_g == oldval)\n\t\t\t\t    origval_g = *(char_u **)varp;\n\t\t\t\toldval = *(char_u **)varp;\n\t\t\t    }\n\t\t\t    /*\n\t\t\t     * Convert 'whichwrap' number to string, for\n\t\t\t     * backwards compatibility with Vim 3.0.\n\t\t\t     * Misuse errbuf[] for the resulting string.\n\t\t\t     */\n\t\t\t    else if (varp == (char_u *)&p_ww\n\t\t\t\t\t\t\t && VIM_ISDIGIT(*arg))\n\t\t\t    {\n\t\t\t\t*errbuf = NUL;\n\t\t\t\ti = getdigits(&arg);\n\t\t\t\tif (i & 1)\n\t\t\t\t    STRCAT(errbuf, \"b,\");\n\t\t\t\tif (i & 2)\n\t\t\t\t    STRCAT(errbuf, \"s,\");\n\t\t\t\tif (i & 4)\n\t\t\t\t    STRCAT(errbuf, \"h,l,\");\n\t\t\t\tif (i & 8)\n\t\t\t\t    STRCAT(errbuf, \"<,>,\");\n\t\t\t\tif (i & 16)\n\t\t\t\t    STRCAT(errbuf, \"[,],\");\n\t\t\t\tif (*errbuf != NUL)\t// remove trailing ,\n\t\t\t\t    errbuf[STRLEN(errbuf) - 1] = NUL;\n\t\t\t\tsave_arg = arg;\n\t\t\t\targ = (char_u *)errbuf;\n\t\t\t    }\n\t\t\t    /*\n\t\t\t     * Remove '>' before 'dir' and 'bdir', for\n\t\t\t     * backwards compatibility with version 3.0\n\t\t\t     */\n\t\t\t    else if (  *arg == '>'\n\t\t\t\t    && (varp == (char_u *)&p_dir\n\t\t\t\t\t    || varp == (char_u *)&p_bdir))\n\t\t\t    {\n\t\t\t\t++arg;\n\t\t\t    }\n\n\t\t\t    /*\n\t\t\t     * Copy the new string into allocated memory.\n\t\t\t     * Can't use set_string_option_direct(), because\n\t\t\t     * we need to remove the backslashes.\n\t\t\t     */\n\t\t\t    // get a bit too much\n\t\t\t    newlen = (unsigned)STRLEN(arg) + 1;\n\t\t\t    if (adding || prepending || removing)\n\t\t\t\tnewlen += (unsigned)STRLEN(origval) + 1;\n\t\t\t    newval = alloc(newlen);\n\t\t\t    if (newval == NULL)  // out of mem, don't change\n\t\t\t\tbreak;\n\t\t\t    s = newval;\n\n\t\t\t    /*\n\t\t\t     * Copy the string, skip over escaped chars.\n\t\t\t     * For MS-DOS and WIN32 backslashes before normal\n\t\t\t     * file name characters are not removed, and keep\n\t\t\t     * backslash at start, for \"\\\\machine\\path\", but\n\t\t\t     * do remove it for \"\\\\\\\\machine\\\\path\".\n\t\t\t     * The reverse is found in ExpandOldSetting().\n\t\t\t     */\n\t\t\t    while (*arg && !VIM_ISWHITE(*arg))\n\t\t\t    {\n\t\t\t\tif (*arg == '\\\\' && arg[1] != NUL\n#ifdef BACKSLASH_IN_FILENAME\n\t\t\t\t\t&& !((flags & P_EXPAND)\n\t\t\t\t\t\t&& vim_isfilec(arg[1])\n\t\t\t\t\t\t&& !VIM_ISWHITE(arg[1])\n\t\t\t\t\t\t&& (arg[1] != '\\\\'\n\t\t\t\t\t\t    || (s == newval\n\t\t\t\t\t\t\t&& arg[2] != '\\\\')))\n#endif\n\t\t\t\t\t\t\t\t    )\n\t\t\t\t    ++arg;\t// remove backslash\n\t\t\t\tif (has_mbyte\n\t\t\t\t\t&& (i = (*mb_ptr2len)(arg)) > 1)\n\t\t\t\t{\n\t\t\t\t    // copy multibyte char\n\t\t\t\t    mch_memmove(s, arg, (size_t)i);\n\t\t\t\t    arg += i;\n\t\t\t\t    s += i;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t    *s++ = *arg++;\n\t\t\t    }\n\t\t\t    *s = NUL;\n\n\t\t\t    /*\n\t\t\t     * Expand environment variables and ~.\n\t\t\t     * Don't do it when adding without inserting a\n\t\t\t     * comma.\n\t\t\t     */\n\t\t\t    if (!(adding || prepending || removing)\n\t\t\t\t\t\t\t || (flags & P_COMMA))\n\t\t\t    {\n\t\t\t\ts = option_expand(opt_idx, newval);\n\t\t\t\tif (s != NULL)\n\t\t\t\t{\n\t\t\t\t    vim_free(newval);\n\t\t\t\t    newlen = (unsigned)STRLEN(s) + 1;\n\t\t\t\t    if (adding || prepending || removing)\n\t\t\t\t\tnewlen += (unsigned)STRLEN(origval) + 1;\n\t\t\t\t    newval = alloc(newlen);\n\t\t\t\t    if (newval == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\t    STRCPY(newval, s);\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    // locate newval[] in origval[] when removing it\n\t\t\t    // and when adding to avoid duplicates\n\t\t\t    i = 0;\t// init for GCC\n\t\t\t    if (removing || (flags & P_NODUP))\n\t\t\t    {\n\t\t\t\ti = (int)STRLEN(newval);\n\t\t\t\ts = find_dup_item(origval, newval, flags);\n\n\t\t\t\t// do not add if already there\n\t\t\t\tif ((adding || prepending) && s != NULL)\n\t\t\t\t{\n\t\t\t\t    prepending = FALSE;\n\t\t\t\t    adding = FALSE;\n\t\t\t\t    STRCPY(newval, origval);\n\t\t\t\t}\n\n\t\t\t\t// if no duplicate, move pointer to end of\n\t\t\t\t// original value\n\t\t\t\tif (s == NULL)\n\t\t\t\t    s = origval + (int)STRLEN(origval);\n\t\t\t    }\n\n\t\t\t    // concatenate the two strings; add a ',' if\n\t\t\t    // needed\n\t\t\t    if (adding || prepending)\n\t\t\t    {\n\t\t\t\tcomma = ((flags & P_COMMA) && *origval != NUL\n\t\t\t\t\t\t\t   && *newval != NUL);\n\t\t\t\tif (adding)\n\t\t\t\t{\n\t\t\t\t    i = (int)STRLEN(origval);\n\t\t\t\t    // strip a trailing comma, would get 2\n\t\t\t\t    if (comma && i > 1\n\t\t\t\t\t  && (flags & P_ONECOMMA) == P_ONECOMMA\n\t\t\t\t\t  && origval[i - 1] == ','\n\t\t\t\t\t  && origval[i - 2] != '\\\\')\n\t\t\t\t\ti--;\n\t\t\t\t    mch_memmove(newval + i + comma, newval,\n\t\t\t\t\t\t\t  STRLEN(newval) + 1);\n\t\t\t\t    mch_memmove(newval, origval, (size_t)i);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    i = (int)STRLEN(newval);\n\t\t\t\t    STRMOVE(newval + i + comma, origval);\n\t\t\t\t}\n\t\t\t\tif (comma)\n\t\t\t\t    newval[i] = ',';\n\t\t\t    }\n\n\t\t\t    // Remove newval[] from origval[]. (Note: \"i\" has\n\t\t\t    // been set above and is used here).\n\t\t\t    if (removing)\n\t\t\t    {\n\t\t\t\tSTRCPY(newval, origval);\n\t\t\t\tif (*s)\n\t\t\t\t{\n\t\t\t\t    // may need to remove a comma\n\t\t\t\t    if (flags & P_COMMA)\n\t\t\t\t    {\n\t\t\t\t\tif (s == origval)\n\t\t\t\t\t{\n\t\t\t\t\t    // include comma after string\n\t\t\t\t\t    if (s[i] == ',')\n\t\t\t\t\t\t++i;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t    // include comma before string\n\t\t\t\t\t    --s;\n\t\t\t\t\t    ++i;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t    STRMOVE(newval + (s - origval), s + i);\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    if (flags & P_FLAGLIST)\n\t\t\t    {\n\t\t\t\t// Remove flags that appear twice.\n\t\t\t\tfor (s = newval; *s;)\n\t\t\t\t{\n\t\t\t\t    // if options have P_FLAGLIST and\n\t\t\t\t    // P_ONECOMMA such as 'whichwrap'\n\t\t\t\t    if (flags & P_ONECOMMA)\n\t\t\t\t    {\n\t\t\t\t\tif (*s != ',' && *(s + 1) == ','\n\t\t\t\t\t      && vim_strchr(s + 2, *s) != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t    // Remove the duplicated value and\n\t\t\t\t\t    // the next comma.\n\t\t\t\t\t    STRMOVE(s, s + 2);\n\t\t\t\t\t    continue;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t\tif ((!(flags & P_COMMA) || *s != ',')\n\t\t\t\t\t      && vim_strchr(s + 1, *s) != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t    STRMOVE(s, s + 1);\n\t\t\t\t\t    continue;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t    ++s;\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    if (save_arg != NULL)   // number for 'whichwrap'\n\t\t\t\targ = save_arg;\n\t\t\t    new_value_alloced = TRUE;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Set the new value.\n\t\t\t */\n\t\t\t*(char_u **)(varp) = newval;\n\n#if defined(FEAT_EVAL)\n\t\t\tif (!starting\n# ifdef FEAT_CRYPT\n\t\t\t\t&& options[opt_idx].indir != PV_KEY\n# endif\n\t\t\t\t\t  && origval != NULL && newval != NULL)\n\t\t\t{\n\t\t\t    // origval may be freed by\n\t\t\t    // did_set_string_option(), make a copy.\n\t\t\t    saved_origval = vim_strsave(origval);\n\t\t\t    // newval (and varp) may become invalid if the\n\t\t\t    // buffer is closed by autocommands.\n\t\t\t    saved_newval = vim_strsave(newval);\n\t\t\t    if (origval_l != NULL)\n\t\t\t\tsaved_origval_l = vim_strsave(origval_l);\n\t\t\t    if (origval_g != NULL)\n\t\t\t\tsaved_origval_g = vim_strsave(origval_g);\n\t\t\t}\n#endif\n\n\t\t\t{\n\t\t\t    long_u *p = insecure_flag(opt_idx, opt_flags);\n\t\t\t    int\t    secure_saved = secure;\n\n\t\t\t    // When an option is set in the sandbox, from a\n\t\t\t    // modeline or in secure mode, then deal with side\n\t\t\t    // effects in secure mode.  Also when the value was\n\t\t\t    // set with the P_INSECURE flag and is not\n\t\t\t    // completely replaced.\n\t\t\t    if ((opt_flags & OPT_MODELINE)\n#ifdef HAVE_SANDBOX\n\t\t\t\t  || sandbox != 0\n#endif\n\t\t\t\t  || (!value_is_replaced && (*p & P_INSECURE)))\n\t\t\t\tsecure = 1;\n\n\t\t\t    // Handle side effects, and set the global value\n\t\t\t    // for \":set\" on local options. Note: when setting\n\t\t\t    // 'syntax' or 'filetype' autocommands may be\n\t\t\t    // triggered that can cause havoc.\n\t\t\t    errmsg = did_set_string_option(\n\t\t\t\t    opt_idx, (char_u **)varp,\n\t\t\t\t    new_value_alloced, oldval, errbuf,\n\t\t\t\t    opt_flags, &value_checked);\n\n\t\t\t    secure = secure_saved;\n\t\t\t}\n\n#if defined(FEAT_EVAL)\n\t\t\tif (errmsg == NULL)\n\t\t\t    trigger_optionsset_string(\n\t\t\t\t    opt_idx, opt_flags, saved_origval,\n\t\t\t\t    saved_origval_l, saved_origval_g,\n\t\t\t\t    saved_newval);\n\t\t\tvim_free(saved_origval);\n\t\t\tvim_free(saved_origval_l);\n\t\t\tvim_free(saved_origval_g);\n\t\t\tvim_free(saved_newval);\n#endif\n\t\t\t// If error detected, print the error message.\n\t\t\tif (errmsg != NULL)\n\t\t\t    goto skip;\n\t\t    }\n\t\t    else\t    // key code option\n\t\t    {\n\t\t\tchar_u\t    *p;\n\n\t\t\tif (nextchar == '&')\n\t\t\t{\n\t\t\t    if (add_termcap_entry(key_name, TRUE) == FAIL)\n\t\t\t\terrmsg = N_(e_not_found_in_termcap);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    ++arg; // jump to after the '=' or ':'\n\t\t\t    for (p = arg; *p && !VIM_ISWHITE(*p); ++p)\n\t\t\t\tif (*p == '\\\\' && p[1] != NUL)\n\t\t\t\t    ++p;\n\t\t\t    nextchar = *p;\n\t\t\t    *p = NUL;\n\t\t\t    add_termcode(key_name, arg, FALSE);\n\t\t\t    *p = nextchar;\n\t\t\t}\n\t\t\tif (full_screen)\n\t\t\t    ttest(FALSE);\n\t\t\tredraw_all_later(CLEAR);\n\t\t    }\n\t\t}\n\n\t\tif (opt_idx >= 0)\n\t\t    did_set_option(\n\t\t\t opt_idx, opt_flags, value_is_replaced, value_checked);\n\t    }\n\nskip:\n\t    /*\n\t     * Advance to next argument.\n\t     * - skip until a blank found, taking care of backslashes\n\t     * - skip blanks\n\t     * - skip one \"=val\" argument (for hidden options \":set gfn =xx\")\n\t     */\n\t    for (i = 0; i < 2 ; ++i)\n\t    {\n\t\twhile (*arg != NUL && !VIM_ISWHITE(*arg))\n\t\t    if (*arg++ == '\\\\' && *arg != NUL)\n\t\t\t++arg;\n\t\targ = skipwhite(arg);\n\t\tif (*arg != '=')\n\t\t    break;\n\t    }\n\t}\n\n\tif (errmsg != NULL)\n\t{\n\t    vim_strncpy(IObuff, (char_u *)_(errmsg), IOSIZE - 1);\n\t    i = (int)STRLEN(IObuff) + 2;\n\t    if (i + (arg - startarg) < IOSIZE)\n\t    {\n\t\t// append the argument with the error\n\t\tSTRCAT(IObuff, \": \");\n\t\tmch_memmove(IObuff + i, startarg, (arg - startarg));\n\t\tIObuff[i + (arg - startarg)] = NUL;\n\t    }\n\t    // make sure all characters are printable\n\t    trans_characters(IObuff, IOSIZE);\n\n\t    ++no_wait_return;\t\t// wait_return done later\n\t    emsg((char *)IObuff);\t// show error highlighted\n\t    --no_wait_return;\n\n\t    return FAIL;\n\t}\n\n\targ = skipwhite(arg);\n    }\n\ntheend:\n    if (silent_mode && did_show)\n    {\n\t// After displaying option values in silent mode.\n\tsilent_mode = FALSE;\n\tinfo_message = TRUE;\t// use mch_msg(), not mch_errmsg()\n\tmsg_putchar('\\n');\n\tcursor_on();\t\t// msg_start() switches it off\n\tout_flush();\n\tsilent_mode = TRUE;\n\tinfo_message = FALSE;\t// use mch_msg(), not mch_errmsg()\n    }\n\n    return OK;\n}\n\n/*\n * Call this when an option has been given a new value through a user command.\n * Sets the P_WAS_SET flag and takes care of the P_INSECURE flag.\n */\n    void\ndid_set_option(\n    int\t    opt_idx,\n    int\t    opt_flags,\t    // possibly with OPT_MODELINE\n    int\t    new_value,\t    // value was replaced completely\n    int\t    value_checked)  // value was checked to be safe, no need to set the\n\t\t\t    // P_INSECURE flag.\n{\n    long_u\t*p;\n\n    options[opt_idx].flags |= P_WAS_SET;\n\n    // When an option is set in the sandbox, from a modeline or in secure mode\n    // set the P_INSECURE flag.  Otherwise, if a new value is stored reset the\n    // flag.\n    p = insecure_flag(opt_idx, opt_flags);\n    if (!value_checked && (secure\n#ifdef HAVE_SANDBOX\n\t    || sandbox != 0\n#endif\n\t    || (opt_flags & OPT_MODELINE)))\n\t*p = *p | P_INSECURE;\n    else if (new_value)\n\t*p = *p & ~P_INSECURE;\n}\n\n/*\n * Convert a key name or string into a key value.\n * Used for 'wildchar' and 'cedit' options.\n * When \"multi_byte\" is TRUE allow for multi-byte characters.\n */\n    int\nstring_to_key(char_u *arg, int multi_byte)\n{\n    if (*arg == '<')\n\treturn find_key_option(arg + 1, TRUE);\n    if (*arg == '^')\n\treturn Ctrl_chr(arg[1]);\n    if (multi_byte)\n\treturn PTR2CHAR(arg);\n    return *arg;\n}\n\n/*\n * When changing 'title', 'titlestring', 'icon' or 'iconstring', call\n * maketitle() to create and display it.\n * When switching the title or icon off, call mch_restore_title() to get\n * the old value back.\n */\n    void\ndid_set_title(void)\n{\n    if (starting != NO_SCREEN\n#ifdef FEAT_GUI\n\t    && !gui.starting\n#endif\n\t\t\t\t)\n\tmaketitle();\n}\n\n/*\n * set_options_bin -  called when 'bin' changes value.\n */\n    void\nset_options_bin(\n    int\t\toldval,\n    int\t\tnewval,\n    int\t\topt_flags)\t// OPT_LOCAL and/or OPT_GLOBAL\n{\n    /*\n     * The option values that are changed when 'bin' changes are\n     * copied when 'bin is set and restored when 'bin' is reset.\n     */\n    if (newval)\n    {\n\tif (!oldval)\t\t// switched on\n\t{\n\t    if (!(opt_flags & OPT_GLOBAL))\n\t    {\n\t\tcurbuf->b_p_tw_nobin = curbuf->b_p_tw;\n\t\tcurbuf->b_p_wm_nobin = curbuf->b_p_wm;\n\t\tcurbuf->b_p_ml_nobin = curbuf->b_p_ml;\n\t\tcurbuf->b_p_et_nobin = curbuf->b_p_et;\n\t    }\n\t    if (!(opt_flags & OPT_LOCAL))\n\t    {\n\t\tp_tw_nobin = p_tw;\n\t\tp_wm_nobin = p_wm;\n\t\tp_ml_nobin = p_ml;\n\t\tp_et_nobin = p_et;\n\t    }\n\t}\n\n\tif (!(opt_flags & OPT_GLOBAL))\n\t{\n\t    curbuf->b_p_tw = 0;\t// no automatic line wrap\n\t    curbuf->b_p_wm = 0;\t// no automatic line wrap\n\t    curbuf->b_p_ml = 0;\t// no modelines\n\t    curbuf->b_p_et = 0;\t// no expandtab\n\t}\n\tif (!(opt_flags & OPT_LOCAL))\n\t{\n\t    p_tw = 0;\n\t    p_wm = 0;\n\t    p_ml = FALSE;\n\t    p_et = FALSE;\n\t    p_bin = TRUE;\t// needed when called for the \"-b\" argument\n\t}\n    }\n    else if (oldval)\t\t// switched off\n    {\n\tif (!(opt_flags & OPT_GLOBAL))\n\t{\n\t    curbuf->b_p_tw = curbuf->b_p_tw_nobin;\n\t    curbuf->b_p_wm = curbuf->b_p_wm_nobin;\n\t    curbuf->b_p_ml = curbuf->b_p_ml_nobin;\n\t    curbuf->b_p_et = curbuf->b_p_et_nobin;\n\t}\n\tif (!(opt_flags & OPT_LOCAL))\n\t{\n\t    p_tw = p_tw_nobin;\n\t    p_wm = p_wm_nobin;\n\t    p_ml = p_ml_nobin;\n\t    p_et = p_et_nobin;\n\t}\n    }\n}\n\n/*\n * Expand environment variables for some string options.\n * These string options cannot be indirect!\n * If \"val\" is NULL expand the current value of the option.\n * Return pointer to NameBuff, or NULL when not expanded.\n */\n    static char_u *\noption_expand(int opt_idx, char_u *val)\n{\n    // if option doesn't need expansion nothing to do\n    if (!(options[opt_idx].flags & P_EXPAND) || options[opt_idx].var == NULL)\n\treturn NULL;\n\n    // If val is longer than MAXPATHL no meaningful expansion can be done,\n    // expand_env() would truncate the string.\n    if (val != NULL && STRLEN(val) > MAXPATHL)\n\treturn NULL;\n\n    if (val == NULL)\n\tval = *(char_u **)options[opt_idx].var;\n\n    /*\n     * Expanding this with NameBuff, expand_env() must not be passed IObuff.\n     * Escape spaces when expanding 'tags', they are used to separate file\n     * names.\n     * For 'spellsuggest' expand after \"file:\".\n     */\n    expand_env_esc(val, NameBuff, MAXPATHL,\n\t    (char_u **)options[opt_idx].var == &p_tags, FALSE,\n#ifdef FEAT_SPELL\n\t    (char_u **)options[opt_idx].var == &p_sps ? (char_u *)\"file:\" :\n#endif\n\t\t\t\t  NULL);\n    if (STRCMP(NameBuff, val) == 0)   // they are the same\n\treturn NULL;\n\n    return NameBuff;\n}\n\n/*\n * After setting various option values: recompute variables that depend on\n * option values.\n */\n    static void\ndidset_options(void)\n{\n    // initialize the table for 'iskeyword' et.al.\n    (void)init_chartab();\n\n    didset_string_options();\n\n#ifdef FEAT_SPELL\n    (void)spell_check_msm();\n    (void)spell_check_sps();\n    (void)compile_cap_prog(curwin->w_s);\n    (void)did_set_spell_option(TRUE);\n#endif\n#ifdef FEAT_CMDWIN\n    // set cedit_key\n    (void)check_cedit();\n#endif\n#ifdef FEAT_LINEBREAK\n    // initialize the table for 'breakat'.\n    fill_breakat_flags();\n#endif\n    after_copy_winopt(curwin);\n}\n\n/*\n * More side effects of setting options.\n */\n    static void\ndidset_options2(void)\n{\n    // Initialize the highlight_attr[] table.\n    (void)highlight_changed();\n\n    // Parse default for 'wildmode'\n    check_opt_wim();\n\n    // Parse default for 'listchars'.\n    (void)set_chars_option(curwin, &curwin->w_p_lcs);\n\n    // Parse default for 'fillchars'.\n    (void)set_chars_option(curwin, &p_fcs);\n\n#ifdef FEAT_CLIPBOARD\n    // Parse default for 'clipboard'\n    (void)check_clipboard_option();\n#endif\n#ifdef FEAT_VARTABS\n    vim_free(curbuf->b_p_vsts_array);\n    (void)tabstop_set(curbuf->b_p_vsts, &curbuf->b_p_vsts_array);\n    vim_free(curbuf->b_p_vts_array);\n    (void)tabstop_set(curbuf->b_p_vts,  &curbuf->b_p_vts_array);\n#endif\n}\n\n/*\n * Check for string options that are NULL (normally only termcap options).\n */\n    void\ncheck_options(void)\n{\n    int\t\topt_idx;\n\n    for (opt_idx = 0; options[opt_idx].fullname != NULL; opt_idx++)\n\tif ((options[opt_idx].flags & P_STRING) && options[opt_idx].var != NULL)\n\t    check_string_option((char_u **)get_varp(&(options[opt_idx])));\n}\n\n/*\n * Return the option index found by a pointer into term_strings[].\n * Return -1 if not found.\n */\n    int\nget_term_opt_idx(char_u **p)\n{\n    int opt_idx;\n\n    for (opt_idx = 1; options[opt_idx].fullname != NULL; opt_idx++)\n\tif (options[opt_idx].var == (char_u *)p)\n\t    return opt_idx;\n    return -1; // cannot happen: didn't find it!\n}\n\n/*\n * Mark a terminal option as allocated, found by a pointer into term_strings[].\n * Return the option index or -1 if not found.\n */\n    int\nset_term_option_alloced(char_u **p)\n{\n    int\t\topt_idx = get_term_opt_idx(p);\n\n    if (opt_idx >= 0)\n\toptions[opt_idx].flags |= P_ALLOCED;\n    return opt_idx;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE when option \"opt\" was set from a modeline or in secure mode.\n * Return FALSE when it wasn't.\n * Return -1 for an unknown option.\n */\n    int\nwas_set_insecurely(char_u *opt, int opt_flags)\n{\n    int\t    idx = findoption(opt);\n    long_u  *flagp;\n\n    if (idx >= 0)\n    {\n\tflagp = insecure_flag(idx, opt_flags);\n\treturn (*flagp & P_INSECURE) != 0;\n    }\n    internal_error(\"was_set_insecurely()\");\n    return -1;\n}\n\n/*\n * Get a pointer to the flags used for the P_INSECURE flag of option\n * \"opt_idx\".  For some local options a local flags field is used.\n * NOTE: Caller must make sure that \"curwin\" is set to the window from which\n * the option is used.\n */\n    static long_u *\ninsecure_flag(int opt_idx, int opt_flags)\n{\n    if (opt_flags & OPT_LOCAL)\n\tswitch ((int)options[opt_idx].indir)\n\t{\n#ifdef FEAT_STL_OPT\n\t    case PV_STL:\treturn &curwin->w_p_stl_flags;\n#endif\n#ifdef FEAT_EVAL\n# ifdef FEAT_FOLDING\n\t    case PV_FDE:\treturn &curwin->w_p_fde_flags;\n\t    case PV_FDT:\treturn &curwin->w_p_fdt_flags;\n# endif\n# ifdef FEAT_BEVAL\n\t    case PV_BEXPR:\treturn &curbuf->b_p_bexpr_flags;\n# endif\n# if defined(FEAT_CINDENT)\n\t    case PV_INDE:\treturn &curbuf->b_p_inde_flags;\n# endif\n\t    case PV_FEX:\treturn &curbuf->b_p_fex_flags;\n# ifdef FEAT_FIND_ID\n\t    case PV_INEX:\treturn &curbuf->b_p_inex_flags;\n# endif\n#endif\n\t}\n\n    // Nothing special, return global flags field.\n    return &options[opt_idx].flags;\n}\n#endif\n\n/*\n * Redraw the window title and/or tab page text later.\n */\nvoid redraw_titles(void)\n{\n    need_maketitle = TRUE;\n    redraw_tabline = TRUE;\n}\n\n/*\n * Return TRUE if \"val\" is a valid name: only consists of alphanumeric ASCII\n * characters or characters in \"allowed\".\n */\n    int\nvalid_name(char_u *val, char *allowed)\n{\n    char_u *s;\n\n    for (s = val; *s != NUL; ++s)\n\tif (!ASCII_ISALNUM(*s) && vim_strchr((char_u *)allowed, *s) == NULL)\n\t    return FALSE;\n    return TRUE;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Set the script_ctx for an option, taking care of setting the buffer- or\n * window-local value.\n */\n    void\nset_option_sctx_idx(int opt_idx, int opt_flags, sctx_T script_ctx)\n{\n    int\t\tboth = (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0;\n    int\t\tindir = (int)options[opt_idx].indir;\n    sctx_T\tnew_script_ctx = script_ctx;\n\n    // Modeline already has the line number set.\n    if (!(opt_flags & OPT_MODELINE))\n\tnew_script_ctx.sc_lnum += SOURCING_LNUM;\n\n    // Remember where the option was set.  For local options need to do that\n    // in the buffer or window structure.\n    if (both || (opt_flags & OPT_GLOBAL) || (indir & (PV_BUF|PV_WIN)) == 0)\n\toptions[opt_idx].script_ctx = new_script_ctx;\n    if (both || (opt_flags & OPT_LOCAL))\n    {\n\tif (indir & PV_BUF)\n\t    curbuf->b_p_script_ctx[indir & PV_MASK] = new_script_ctx;\n\telse if (indir & PV_WIN)\n\t{\n\t    curwin->w_p_script_ctx[indir & PV_MASK] = new_script_ctx;\n\t    if (both)\n\t\t// also setting the \"all buffers\" value\n\t\tcurwin->w_allbuf_opt.wo_script_ctx[indir & PV_MASK] =\n\t\t\t\t\t\t\t\tnew_script_ctx;\n\t}\n    }\n}\n\n/*\n * Get the script context of global option \"name\".\n *\n */\n    sctx_T *\nget_option_sctx(char *name)\n{\n    int idx = findoption((char_u *)name);\n\n    if (idx >= 0)\n\treturn &options[idx].script_ctx;\n    siemsg(\"no such option: %s\", name);\n    return NULL;\n}\n\n/*\n * Set the script_ctx for a termcap option.\n * \"name\" must be the two character code, e.g. \"RV\".\n * When \"name\" is NULL use \"opt_idx\".\n */\n    void\nset_term_option_sctx_idx(char *name, int opt_idx)\n{\n    char_u  buf[5];\n    int\t    idx;\n\n    if (name == NULL)\n\tidx = opt_idx;\n    else\n    {\n\tbuf[0] = 't';\n\tbuf[1] = '_';\n\tbuf[2] = name[0];\n\tbuf[3] = name[1];\n\tbuf[4] = 0;\n\tidx = findoption(buf);\n    }\n    if (idx >= 0)\n\tset_option_sctx_idx(idx, OPT_GLOBAL, current_sctx);\n}\n#endif\n\n#if defined(FEAT_EVAL)\n/*\n * Apply the OptionSet autocommand.\n */\n    static void\napply_optionset_autocmd(\n\tint\topt_idx,\n\tlong\topt_flags,\n\tlong\toldval,\n\tlong\toldval_g,\n\tlong\tnewval,\n\tchar\t*errmsg)\n{\n    char_u buf_old[12], buf_old_global[12], buf_new[12], buf_type[12];\n\n    // Don't do this while starting up, failure or recursively.\n    if (starting || errmsg != NULL || *get_vim_var_str(VV_OPTION_TYPE) != NUL)\n\treturn;\n\n    vim_snprintf((char *)buf_old, sizeof(buf_old), \"%ld\", oldval);\n    vim_snprintf((char *)buf_old_global, sizeof(buf_old_global), \"%ld\",\n\t\t\t\t\t\t\toldval_g);\n    vim_snprintf((char *)buf_new, sizeof(buf_new), \"%ld\", newval);\n    vim_snprintf((char *)buf_type, sizeof(buf_type), \"%s\",\n\t\t\t\t(opt_flags & OPT_LOCAL) ? \"local\" : \"global\");\n    set_vim_var_string(VV_OPTION_NEW, buf_new, -1);\n    set_vim_var_string(VV_OPTION_OLD, buf_old, -1);\n    set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);\n    if (opt_flags & OPT_LOCAL)\n    {\n\tset_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"setlocal\", -1);\n\tset_vim_var_string(VV_OPTION_OLDLOCAL, buf_old, -1);\n    }\n    if (opt_flags & OPT_GLOBAL)\n    {\n\tset_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"setglobal\", -1);\n\tset_vim_var_string(VV_OPTION_OLDGLOBAL, buf_old, -1);\n    }\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n    {\n\tset_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"set\", -1);\n\tset_vim_var_string(VV_OPTION_OLDLOCAL, buf_old, -1);\n\tset_vim_var_string(VV_OPTION_OLDGLOBAL, buf_old_global, -1);\n    }\n    if (opt_flags & OPT_MODELINE)\n    {\n\tset_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"modeline\", -1);\n\tset_vim_var_string(VV_OPTION_OLDLOCAL, buf_old, -1);\n    }\n    apply_autocmds(EVENT_OPTIONSET, (char_u *)options[opt_idx].fullname,\n\t    NULL, FALSE, NULL);\n    reset_v_option_vars();\n}\n#endif\n\n/*\n * Set the value of a boolean option, and take care of side effects.\n * Returns NULL for success, or an error message for an error.\n */\n    static char *\nset_bool_option(\n    int\t\topt_idx,\t\t// index in options[] table\n    char_u\t*varp,\t\t\t// pointer to the option variable\n    int\t\tvalue,\t\t\t// new value\n    int\t\topt_flags)\t\t// OPT_LOCAL and/or OPT_GLOBAL\n{\n    int\t\told_value = *(int *)varp;\n#if defined(FEAT_EVAL)\n    int\t\told_global_value = 0;\n#endif\n\n    // Disallow changing some options from secure mode\n    if ((secure\n#ifdef HAVE_SANDBOX\n\t\t|| sandbox != 0\n#endif\n\t\t) && (options[opt_idx].flags & P_SECURE))\n\treturn e_not_allowed_here;\n\n#if defined(FEAT_EVAL)\n    // Save the global value before changing anything. This is needed as for\n    // a global-only option setting the \"local value\" in fact sets the global\n    // value (since there is only one value).\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\told_global_value = *(int *)get_varp_scope(&(options[opt_idx]),\n\t\t\t\t\t\t\t\t   OPT_GLOBAL);\n#endif\n\n    *(int *)varp = value;\t    // set the new value\n#ifdef FEAT_EVAL\n    // Remember where the option was set.\n    set_option_sctx_idx(opt_idx, opt_flags, current_sctx);\n#endif\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    // May set global value for local option.\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\t*(int *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) = value;\n\n    /*\n     * Handle side effects of changing a bool option.\n     */\n\n    // 'compatible'\n    if ((int *)varp == &p_cp)\n\tcompatible_set();\n\n#ifdef FEAT_LANGMAP\n    if ((int *)varp == &p_lrm)\n\t// 'langremap' -> !'langnoremap'\n\tp_lnr = !p_lrm;\n    else if ((int *)varp == &p_lnr)\n\t// 'langnoremap' -> !'langremap'\n\tp_lrm = !p_lnr;\n#endif\n\n#ifdef FEAT_SYN_HL\n    else if ((int *)varp == &curwin->w_p_cul && !value && old_value)\n\treset_cursorline();\n#endif\n\n#ifdef FEAT_PERSISTENT_UNDO\n    // 'undofile'\n    else if ((int *)varp == &curbuf->b_p_udf || (int *)varp == &p_udf)\n    {\n\t// Only take action when the option was set. When reset we do not\n\t// delete the undo file, the option may be set again without making\n\t// any changes in between.\n\tif (curbuf->b_p_udf || p_udf)\n\t{\n\t    char_u\thash[UNDO_HASH_SIZE];\n\t    buf_T\t*save_curbuf = curbuf;\n\n\t    FOR_ALL_BUFFERS(curbuf)\n\t    {\n\t\t// When 'undofile' is set globally: for every buffer, otherwise\n\t\t// only for the current buffer: Try to read in the undofile,\n\t\t// if one exists, the buffer wasn't changed and the buffer was\n\t\t// loaded\n\t\tif ((curbuf == save_curbuf\n\t\t\t\t|| (opt_flags & OPT_GLOBAL) || opt_flags == 0)\n\t\t\t&& !curbufIsChanged() && curbuf->b_ml.ml_mfp != NULL)\n\t\t{\n#ifdef FEAT_CRYPT\n\t\t    if (crypt_get_method_nr(curbuf) == CRYPT_M_SOD)\n\t\t\tcontinue;\n#endif\n\t\t    u_compute_hash(hash);\n\t\t    u_read_undo(NULL, hash, curbuf->b_fname);\n\t\t}\n\t    }\n\t    curbuf = save_curbuf;\n\t}\n    }\n#endif\n\n    else if ((int *)varp == &curbuf->b_p_ro)\n    {\n\t// when 'readonly' is reset globally, also reset readonlymode\n\tif (!curbuf->b_p_ro && (opt_flags & OPT_LOCAL) == 0)\n\t    readonlymode = FALSE;\n\n\t// when 'readonly' is set may give W10 again\n\tif (curbuf->b_p_ro)\n\t    curbuf->b_did_warn = FALSE;\n\n\tredraw_titles();\n    }\n\n#ifdef FEAT_GUI\n    else if ((int *)varp == &p_mh)\n    {\n\tif (!p_mh)\n\t    gui_mch_mousehide(FALSE);\n    }\n#endif\n\n    // when 'modifiable' is changed, redraw the window title\n    else if ((int *)varp == &curbuf->b_p_ma)\n    {\n# ifdef FEAT_TERMINAL\n\t// Cannot set 'modifiable' when in Terminal mode.\n\tif (curbuf->b_p_ma && (term_in_normal_mode() || (bt_terminal(curbuf)\n\t\t      && curbuf->b_term != NULL && !term_is_finished(curbuf))))\n\t{\n\t    curbuf->b_p_ma = FALSE;\n\t    return N_(e_cannot_make_terminal_with_running_job_modifiable);\n\t}\n# endif\n\tredraw_titles();\n    }\n    // when 'endofline' is changed, redraw the window title\n    else if ((int *)varp == &curbuf->b_p_eol)\n    {\n\tredraw_titles();\n    }\n    // when 'fixeol' is changed, redraw the window title\n    else if ((int *)varp == &curbuf->b_p_fixeol)\n    {\n\tredraw_titles();\n    }\n    // when 'bomb' is changed, redraw the window title and tab page text\n    else if ((int *)varp == &curbuf->b_p_bomb)\n    {\n\tredraw_titles();\n    }\n\n    // when 'bin' is set also set some other options\n    else if ((int *)varp == &curbuf->b_p_bin)\n    {\n\tset_options_bin(old_value, curbuf->b_p_bin, opt_flags);\n\tredraw_titles();\n    }\n\n    // when 'buflisted' changes, trigger autocommands\n    else if ((int *)varp == &curbuf->b_p_bl && old_value != curbuf->b_p_bl)\n    {\n\tapply_autocmds(curbuf->b_p_bl ? EVENT_BUFADD : EVENT_BUFDELETE,\n\t\t\t\t\t\t    NULL, NULL, TRUE, curbuf);\n    }\n\n    // when 'swf' is set, create swapfile, when reset remove swapfile\n    else if ((int *)varp == &curbuf->b_p_swf)\n    {\n\tif (curbuf->b_p_swf && p_uc)\n\t    ml_open_file(curbuf);\t\t// create the swap file\n\telse\n\t    // no need to reset curbuf->b_may_swap, ml_open_file() will check\n\t    // buf->b_p_swf\n\t    mf_close_file(curbuf, TRUE);\t// remove the swap file\n    }\n\n    // when 'terse' is set change 'shortmess'\n    else if ((int *)varp == &p_terse)\n    {\n\tchar_u\t*p;\n\n\tp = vim_strchr(p_shm, SHM_SEARCH);\n\n\t// insert 's' in p_shm\n\tif (p_terse && p == NULL)\n\t{\n\t    STRCPY(IObuff, p_shm);\n\t    STRCAT(IObuff, \"s\");\n\t    set_string_option_direct((char_u *)\"shm\", -1, IObuff, OPT_FREE, 0);\n\t}\n\t// remove 's' from p_shm\n\telse if (!p_terse && p != NULL)\n\t    STRMOVE(p, p + 1);\n    }\n\n    // when 'paste' is set or reset also change other options\n    else if ((int *)varp == &p_paste)\n    {\n\tpaste_option_changed();\n    }\n\n    // when 'insertmode' is set from an autocommand need to do work here\n    else if ((int *)varp == &p_im)\n    {\n\tif (p_im)\n\t{\n\t    if ((State & INSERT) == 0)\n\t\tneed_start_insertmode = TRUE;\n\t    stop_insert_mode = FALSE;\n\t}\n\t// only reset if it was set previously\n\telse if (old_value)\n\t{\n\t    need_start_insertmode = FALSE;\n\t    stop_insert_mode = TRUE;\n\t    if (restart_edit != 0 && mode_displayed)\n\t\tclear_cmdline = TRUE;\t// remove \"(insert)\"\n\t    restart_edit = 0;\n\t}\n    }\n\n    // when 'ignorecase' is set or reset and 'hlsearch' is set, redraw\n    else if ((int *)varp == &p_ic && p_hls)\n    {\n\tredraw_all_later(SOME_VALID);\n    }\n\n#ifdef FEAT_SEARCH_EXTRA\n    // when 'hlsearch' is set or reset: reset no_hlsearch\n    else if ((int *)varp == &p_hls)\n    {\n\tset_no_hlsearch(FALSE);\n    }\n#endif\n\n    // when 'scrollbind' is set: snapshot the current position to avoid a jump\n    // at the end of normal_cmd()\n    else if ((int *)varp == &curwin->w_p_scb)\n    {\n\tif (curwin->w_p_scb)\n\t{\n\t    do_check_scrollbind(FALSE);\n\t    curwin->w_scbind_pos = curwin->w_topline;\n\t}\n    }\n\n#if defined(FEAT_QUICKFIX)\n    // There can be only one window with 'previewwindow' set.\n    else if ((int *)varp == &curwin->w_p_pvw)\n    {\n\tif (curwin->w_p_pvw)\n\t{\n\t    win_T\t*win;\n\n\t    FOR_ALL_WINDOWS(win)\n\t\tif (win->w_p_pvw && win != curwin)\n\t\t{\n\t\t    curwin->w_p_pvw = FALSE;\n\t\t    return N_(e_preview_window_already_exists);\n\t\t}\n\t}\n    }\n#endif\n\n    // when 'textmode' is set or reset also change 'fileformat'\n    else if ((int *)varp == &curbuf->b_p_tx)\n    {\n\tset_fileformat(curbuf->b_p_tx ? EOL_DOS : EOL_UNIX, opt_flags);\n    }\n\n    // when 'textauto' is set or reset also change 'fileformats'\n    else if ((int *)varp == &p_ta)\n    {\n\tset_string_option_direct((char_u *)\"ffs\", -1,\n\t\t\t\t p_ta ? (char_u *)DFLT_FFS_VIM : (char_u *)\"\",\n\t\t\t\t\t\t     OPT_FREE | opt_flags, 0);\n    }\n\n    /*\n     * When 'lisp' option changes include/exclude '-' in\n     * keyword characters.\n     */\n#ifdef FEAT_LISP\n    else if (varp == (char_u *)&(curbuf->b_p_lisp))\n    {\n\t(void)buf_init_chartab(curbuf, FALSE);\t    // ignore errors\n    }\n#endif\n\n    // when 'title' changed, may need to change the title; same for 'icon'\n    else if ((int *)varp == &p_title || (int *)varp == &p_icon)\n    {\n\tdid_set_title();\n    }\n\n    else if ((int *)varp == &curbuf->b_changed)\n    {\n\tif (!value)\n\t    save_file_ff(curbuf);\t// Buffer is unchanged\n\tredraw_titles();\n\tmodified_was_set = value;\n    }\n\n#ifdef BACKSLASH_IN_FILENAME\n    else if ((int *)varp == &p_ssl)\n    {\n\tif (p_ssl)\n\t{\n\t    psepc = '/';\n\t    psepcN = '\\\\';\n\t    pseps[0] = '/';\n\t}\n\telse\n\t{\n\t    psepc = '\\\\';\n\t    psepcN = '/';\n\t    pseps[0] = '\\\\';\n\t}\n\n\t// need to adjust the file name arguments and buffer names.\n\tbuflist_slash_adjust();\n\talist_slash_adjust();\n# ifdef FEAT_EVAL\n\tscriptnames_slash_adjust();\n# endif\n    }\n#endif\n\n    // If 'wrap' is set, set w_leftcol to zero.\n    else if ((int *)varp == &curwin->w_p_wrap)\n    {\n\tif (curwin->w_p_wrap)\n\t    curwin->w_leftcol = 0;\n    }\n\n    else if ((int *)varp == &p_ea)\n    {\n\tif (p_ea && !old_value)\n\t    win_equal(curwin, FALSE, 0);\n    }\n\n    else if ((int *)varp == &p_wiv)\n    {\n\t/*\n\t * When 'weirdinvert' changed, set/reset 't_xs'.\n\t * Then set 'weirdinvert' according to value of 't_xs'.\n\t */\n\tif (p_wiv && !old_value)\n\t    T_XS = (char_u *)\"y\";\n\telse if (!p_wiv && old_value)\n\t    T_XS = empty_option;\n\tp_wiv = (*T_XS != NUL);\n    }\n\n#ifdef FEAT_BEVAL_GUI\n    else if ((int *)varp == &p_beval)\n    {\n\tif (!balloonEvalForTerm)\n\t{\n\t    if (p_beval && !old_value)\n\t\tgui_mch_enable_beval_area(balloonEval);\n\t    else if (!p_beval && old_value)\n\t\tgui_mch_disable_beval_area(balloonEval);\n\t}\n    }\n#endif\n#ifdef FEAT_BEVAL_TERM\n    else if ((int *)varp == &p_bevalterm)\n    {\n\tmch_bevalterm_changed();\n    }\n#endif\n\n#ifdef FEAT_AUTOCHDIR\n    else if ((int *)varp == &p_acd)\n    {\n\t// Change directories when the 'acd' option is set now.\n\tDO_AUTOCHDIR;\n    }\n#endif\n\n#ifdef FEAT_DIFF\n    // 'diff'\n    else if ((int *)varp == &curwin->w_p_diff)\n    {\n\t// May add or remove the buffer from the list of diff buffers.\n\tdiff_buf_adjust(curwin);\n# ifdef FEAT_FOLDING\n\tif (foldmethodIsDiff(curwin))\n\t    foldUpdateAll(curwin);\n# endif\n    }\n#endif\n\n#ifdef HAVE_INPUT_METHOD\n    // 'imdisable'\n    else if ((int *)varp == &p_imdisable)\n    {\n\t// Only de-activate it here, it will be enabled when changing mode.\n\tif (p_imdisable)\n\t    im_set_active(FALSE);\n\telse if (State & INSERT)\n\t    // When the option is set from an autocommand, it may need to take\n\t    // effect right away.\n\t    im_set_active(curbuf->b_p_iminsert == B_IMODE_IM);\n    }\n#endif\n\n#ifdef FEAT_SPELL\n    // 'spell'\n    else if ((int *)varp == &curwin->w_p_spell)\n    {\n\tif (curwin->w_p_spell)\n\t{\n\t    char\t*errmsg = did_set_spelllang(curwin);\n\n\t    if (errmsg != NULL)\n\t\temsg(_(errmsg));\n\t}\n    }\n#endif\n\n#ifdef FEAT_ARABIC\n    if ((int *)varp == &curwin->w_p_arab)\n    {\n\tif (curwin->w_p_arab)\n\t{\n\t    /*\n\t     * 'arabic' is set, handle various sub-settings.\n\t     */\n\t    if (!p_tbidi)\n\t    {\n\t\t// set rightleft mode\n\t\tif (!curwin->w_p_rl)\n\t\t{\n\t\t    curwin->w_p_rl = TRUE;\n\t\t    changed_window_setting();\n\t\t}\n\n\t\t// Enable Arabic shaping (major part of what Arabic requires)\n\t\tif (!p_arshape)\n\t\t{\n\t\t    p_arshape = TRUE;\n\t\t    redraw_later_clear();\n\t\t}\n\t    }\n\n\t    // Arabic requires a utf-8 encoding, inform the user if it's not\n\t    // set.\n\t    if (STRCMP(p_enc, \"utf-8\") != 0)\n\t    {\n\t\tstatic char *w_arabic = N_(\"W17: Arabic requires UTF-8, do ':set encoding=utf-8'\");\n\n\t\tmsg_source(HL_ATTR(HLF_W));\n\t\tmsg_attr(_(w_arabic), HL_ATTR(HLF_W));\n#ifdef FEAT_EVAL\n\t\tset_vim_var_string(VV_WARNINGMSG, (char_u *)_(w_arabic), -1);\n#endif\n\t    }\n\n\t    // set 'delcombine'\n\t    p_deco = TRUE;\n\n# ifdef FEAT_KEYMAP\n\t    // Force-set the necessary keymap for arabic\n\t    set_option_value((char_u *)\"keymap\", 0L, (char_u *)\"arabic\",\n\t\t\t\t\t\t\t\t   OPT_LOCAL);\n# endif\n\t}\n\telse\n\t{\n\t    /*\n\t     * 'arabic' is reset, handle various sub-settings.\n\t     */\n\t    if (!p_tbidi)\n\t    {\n\t\t// reset rightleft mode\n\t\tif (curwin->w_p_rl)\n\t\t{\n\t\t    curwin->w_p_rl = FALSE;\n\t\t    changed_window_setting();\n\t\t}\n\n\t\t// 'arabicshape' isn't reset, it is a global option and\n\t\t// another window may still need it \"on\".\n\t    }\n\n\t    // 'delcombine' isn't reset, it is a global option and another\n\t    // window may still want it \"on\".\n\n# ifdef FEAT_KEYMAP\n\t    // Revert to the default keymap\n\t    curbuf->b_p_iminsert = B_IMODE_NONE;\n\t    curbuf->b_p_imsearch = B_IMODE_USE_INSERT;\n# endif\n\t}\n    }\n\n#endif\n\n#if defined(FEAT_SIGNS) && defined(FEAT_GUI)\n    else if (((int *)varp == &curwin->w_p_nu\n\t\t|| (int *)varp == &curwin->w_p_rnu)\n\t    && gui.in_use\n\t    && (*curwin->w_p_scl == 'n' && *(curwin->w_p_scl + 1) == 'u')\n\t    && curbuf->b_signlist != NULL)\n    {\n\t// If the 'number' or 'relativenumber' options are modified and\n\t// 'signcolumn' is set to 'number', then clear the screen for a full\n\t// refresh. Otherwise the sign icons are not displayed properly in the\n\t// number column.  If the 'number' option is set and only the\n\t// 'relativenumber' option is toggled, then don't refresh the screen\n\t// (optimization).\n\tif (!(curwin->w_p_nu && ((int *)varp == &curwin->w_p_rnu)))\n\t    redraw_all_later(CLEAR);\n    }\n#endif\n\n#ifdef FEAT_TERMGUICOLORS\n    // 'termguicolors'\n    else if ((int *)varp == &p_tgc)\n    {\n# ifdef FEAT_VTP\n\t// Do not turn on 'tgc' when 24-bit colors are not supported.\n\tif (\n#  ifdef VIMDLL\n\t    !gui.in_use && !gui.starting &&\n#  endif\n\t    !has_vtp_working())\n\t{\n\t    p_tgc = 0;\n\t    return N_(e_24_bit_colors_are_not_supported_on_this_environment);\n\t}\n\tif (is_term_win32())\n\t    swap_tcap();\n# endif\n# ifdef FEAT_GUI\n\tif (!gui.in_use && !gui.starting)\n# endif\n\t    highlight_gui_started();\n# ifdef FEAT_VTP\n\t// reset t_Co\n\tif (is_term_win32())\n\t{\n\t    control_console_color_rgb();\n\t    set_termname(T_NAME);\n\t    init_highlight(TRUE, FALSE);\n\t}\n# endif\n# ifdef FEAT_TERMINAL\n\tterm_update_colors_all();\n\tterm_update_wincolor_all();\n# endif\n    }\n#endif\n\n    /*\n     * End of handling side effects for bool options.\n     */\n\n    // after handling side effects, call autocommand\n\n    options[opt_idx].flags |= P_WAS_SET;\n\n#if defined(FEAT_EVAL)\n    apply_optionset_autocmd(opt_idx, opt_flags,\n\t\t\t\t(long)(old_value ? TRUE : FALSE),\n\t\t\t\t(long)(old_global_value ? TRUE : FALSE),\n\t\t\t\t(long)(value ? TRUE : FALSE), NULL);\n#endif\n\n    comp_col();\t\t\t    // in case 'ruler' or 'showcmd' changed\n    if (curwin->w_curswant != MAXCOL\n\t\t     && (options[opt_idx].flags & (P_CURSWANT | P_RALL)) != 0)\n\tcurwin->w_set_curswant = TRUE;\n\n    if ((opt_flags & OPT_NO_REDRAW) == 0)\n\tcheck_redraw(options[opt_idx].flags);\n\n    return NULL;\n}\n\n/*\n * Set the value of a number option, and take care of side effects.\n * Returns NULL for success, or an error message for an error.\n */\n    static char *\nset_num_option(\n    int\t\topt_idx,\t\t// index in options[] table\n    char_u\t*varp,\t\t\t// pointer to the option variable\n    long\tvalue,\t\t\t// new value\n    char\t*errbuf,\t\t// buffer for error messages\n    size_t\terrbuflen,\t\t// length of \"errbuf\"\n    int\t\topt_flags)\t\t// OPT_LOCAL, OPT_GLOBAL,\n\t\t\t\t\t// OPT_MODELINE, etc.\n{\n    char\t*errmsg = NULL;\n    long\told_value = *(long *)varp;\n#if defined(FEAT_EVAL)\n    long\told_global_value = 0;\t// only used when setting a local and\n\t\t\t\t\t// global option\n#endif\n    long\told_Rows = Rows;\t// remember old Rows\n    long\told_Columns = Columns;\t// remember old Columns\n    long\t*pp = (long *)varp;\n\n    // Disallow changing some options from secure mode.\n    if ((secure\n#ifdef HAVE_SANDBOX\n\t\t|| sandbox != 0\n#endif\n\t\t) && (options[opt_idx].flags & P_SECURE))\n\treturn e_not_allowed_here;\n\n#if defined(FEAT_EVAL)\n    // Save the global value before changing anything. This is needed as for\n    // a global-only option setting the \"local value\" in fact sets the global\n    // value (since there is only one value).\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\told_global_value = *(long *)get_varp_scope(&(options[opt_idx]),\n\t\t\t\t\t\t\t\t   OPT_GLOBAL);\n#endif\n\n    *pp = value;\n#ifdef FEAT_EVAL\n    // Remember where the option was set.\n    set_option_sctx_idx(opt_idx, opt_flags, current_sctx);\n#endif\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    if (curbuf->b_p_sw < 0)\n    {\n\terrmsg = e_argument_must_be_positive;\n#ifdef FEAT_VARTABS\n\t// Use the first 'vartabstop' value, or 'tabstop' if vts isn't in use.\n\tcurbuf->b_p_sw = tabstop_count(curbuf->b_p_vts_array) > 0\n\t               ? tabstop_first(curbuf->b_p_vts_array)\n\t\t       : curbuf->b_p_ts;\n#else\n\tcurbuf->b_p_sw = curbuf->b_p_ts;\n#endif\n    }\n\n    /*\n     * Number options that need some action when changed\n     */\n    if (pp == &p_wh || pp == &p_hh)\n    {\n\t// 'winheight' and 'helpheight'\n\tif (p_wh < 1)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_wh = 1;\n\t}\n\tif (p_wmh > p_wh)\n\t{\n\t    errmsg = e_winheight_cannot_be_smaller_than_winminheight;\n\t    p_wh = p_wmh;\n\t}\n\tif (p_hh < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_hh = 0;\n\t}\n\n\t// Change window height NOW\n\tif (!ONE_WINDOW)\n\t{\n\t    if (pp == &p_wh && curwin->w_height < p_wh)\n\t\twin_setheight((int)p_wh);\n\t    if (pp == &p_hh && curbuf->b_help && curwin->w_height < p_hh)\n\t\twin_setheight((int)p_hh);\n\t}\n    }\n    else if (pp == &p_wmh)\n    {\n\t// 'winminheight'\n\tif (p_wmh < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_wmh = 0;\n\t}\n\tif (p_wmh > p_wh)\n\t{\n\t    errmsg = e_winheight_cannot_be_smaller_than_winminheight;\n\t    p_wmh = p_wh;\n\t}\n\twin_setminheight();\n    }\n    else if (pp == &p_wiw)\n    {\n\t// 'winwidth'\n\tif (p_wiw < 1)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_wiw = 1;\n\t}\n\tif (p_wmw > p_wiw)\n\t{\n\t    errmsg = e_winwidth_cannot_be_smaller_than_winminwidth;\n\t    p_wiw = p_wmw;\n\t}\n\n\t// Change window width NOW\n\tif (!ONE_WINDOW && curwin->w_width < p_wiw)\n\t    win_setwidth((int)p_wiw);\n    }\n    else if (pp == &p_wmw)\n    {\n\t// 'winminwidth'\n\tif (p_wmw < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_wmw = 0;\n\t}\n\tif (p_wmw > p_wiw)\n\t{\n\t    errmsg = e_winwidth_cannot_be_smaller_than_winminwidth;\n\t    p_wmw = p_wiw;\n\t}\n\twin_setminwidth();\n    }\n\n    // (re)set last window status line\n    else if (pp == &p_ls)\n    {\n\tlast_status(FALSE);\n    }\n\n    // (re)set tab page line\n    else if (pp == &p_stal)\n    {\n\tshell_new_rows();\t// recompute window positions and heights\n    }\n\n#ifdef FEAT_GUI\n    else if (pp == &p_linespace)\n    {\n\t// Recompute gui.char_height and resize the Vim window to keep the\n\t// same number of lines.\n\tif (gui.in_use && gui_mch_adjust_charheight() == OK)\n\t    gui_set_shellsize(FALSE, FALSE, RESIZE_VERT);\n    }\n#endif\n\n#ifdef FEAT_FOLDING\n    // 'foldlevel'\n    else if (pp == &curwin->w_p_fdl)\n    {\n\tif (curwin->w_p_fdl < 0)\n\t    curwin->w_p_fdl = 0;\n\tnewFoldLevel();\n    }\n\n    // 'foldminlines'\n    else if (pp == &curwin->w_p_fml)\n    {\n\tfoldUpdateAll(curwin);\n    }\n\n    // 'foldnestmax'\n    else if (pp == &curwin->w_p_fdn)\n    {\n\tif (foldmethodIsSyntax(curwin) || foldmethodIsIndent(curwin))\n\t    foldUpdateAll(curwin);\n    }\n\n    // 'foldcolumn'\n    else if (pp == &curwin->w_p_fdc)\n    {\n\tif (curwin->w_p_fdc < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    curwin->w_p_fdc = 0;\n\t}\n\telse if (curwin->w_p_fdc > 12)\n\t{\n\t    errmsg = e_invalid_argument;\n\t    curwin->w_p_fdc = 12;\n\t}\n    }\n#endif // FEAT_FOLDING\n\n#if defined(FEAT_FOLDING) || defined(FEAT_CINDENT)\n    // 'shiftwidth' or 'tabstop'\n    else if (pp == &curbuf->b_p_sw || pp == &curbuf->b_p_ts)\n    {\n# ifdef FEAT_FOLDING\n\tif (foldmethodIsIndent(curwin))\n\t    foldUpdateAll(curwin);\n# endif\n# ifdef FEAT_CINDENT\n\t// When 'shiftwidth' changes, or it's zero and 'tabstop' changes:\n\t// parse 'cinoptions'.\n\tif (pp == &curbuf->b_p_sw || curbuf->b_p_sw == 0)\n\t    parse_cino(curbuf);\n# endif\n    }\n#endif\n\n    // 'maxcombine'\n    else if (pp == &p_mco)\n    {\n\tif (p_mco > MAX_MCO)\n\t    p_mco = MAX_MCO;\n\telse if (p_mco < 0)\n\t    p_mco = 0;\n\tscreenclear();\t    // will re-allocate the screen\n    }\n\n    else if (pp == &curbuf->b_p_iminsert)\n    {\n\tif (curbuf->b_p_iminsert < 0 || curbuf->b_p_iminsert > B_IMODE_LAST)\n\t{\n\t    errmsg = e_invalid_argument;\n\t    curbuf->b_p_iminsert = B_IMODE_NONE;\n\t}\n\tp_iminsert = curbuf->b_p_iminsert;\n\tif (termcap_active)\t// don't do this in the alternate screen\n\t    showmode();\n#if defined(FEAT_KEYMAP)\n\t// Show/unshow value of 'keymap' in status lines.\n\tstatus_redraw_curbuf();\n#endif\n    }\n\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n    // 'imstyle'\n    else if (pp == &p_imst)\n    {\n\tif (p_imst != IM_ON_THE_SPOT && p_imst != IM_OVER_THE_SPOT)\n\t    errmsg = e_invalid_argument;\n    }\n#endif\n\n    else if (pp == &p_window)\n    {\n\tif (p_window < 1)\n\t    p_window = 1;\n\telse if (p_window >= Rows)\n\t    p_window = Rows - 1;\n    }\n\n    else if (pp == &curbuf->b_p_imsearch)\n    {\n\tif (curbuf->b_p_imsearch < -1 || curbuf->b_p_imsearch > B_IMODE_LAST)\n\t{\n\t    errmsg = e_invalid_argument;\n\t    curbuf->b_p_imsearch = B_IMODE_NONE;\n\t}\n\tp_imsearch = curbuf->b_p_imsearch;\n    }\n\n    // if 'titlelen' has changed, redraw the title\n    else if (pp == &p_titlelen)\n    {\n\tif (p_titlelen < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_titlelen = 85;\n\t}\n\tif (starting != NO_SCREEN && old_value != p_titlelen)\n\t    need_maketitle = TRUE;\n    }\n\n    // if p_ch changed value, change the command line height\n    else if (pp == &p_ch)\n    {\n\tif (p_ch < 1)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_ch = 1;\n\t}\n\tif (p_ch > Rows - min_rows() + 1)\n\t    p_ch = Rows - min_rows() + 1;\n\n\t// Only compute the new window layout when startup has been\n\t// completed. Otherwise the frame sizes may be wrong.\n\tif (p_ch != old_value && full_screen\n#ifdef FEAT_GUI\n\t\t&& !gui.starting\n#endif\n\t   )\n\t    command_height();\n    }\n\n    // when 'updatecount' changes from zero to non-zero, open swap files\n    else if (pp == &p_uc)\n    {\n\tif (p_uc < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_uc = 100;\n\t}\n\tif (p_uc && !old_value)\n\t    ml_open_files();\n    }\n#ifdef FEAT_CONCEAL\n    else if (pp == &curwin->w_p_cole)\n    {\n\tif (curwin->w_p_cole < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    curwin->w_p_cole = 0;\n\t}\n\telse if (curwin->w_p_cole > 3)\n\t{\n\t    errmsg = e_invalid_argument;\n\t    curwin->w_p_cole = 3;\n\t}\n    }\n#endif\n#ifdef MZSCHEME_GUI_THREADS\n    else if (pp == &p_mzq)\n\tmzvim_reset_timer();\n#endif\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\n    // 'pyxversion'\n    else if (pp == &p_pyx)\n    {\n\tif (p_pyx != 0 && p_pyx != 2 && p_pyx != 3)\n\t    errmsg = e_invalid_argument;\n    }\n#endif\n\n    // sync undo before 'undolevels' changes\n    else if (pp == &p_ul)\n    {\n\t// use the old value, otherwise u_sync() may not work properly\n\tp_ul = old_value;\n\tu_sync(TRUE);\n\tp_ul = value;\n    }\n    else if (pp == &curbuf->b_p_ul)\n    {\n\t// use the old value, otherwise u_sync() may not work properly\n\tcurbuf->b_p_ul = old_value;\n\tu_sync(TRUE);\n\tcurbuf->b_p_ul = value;\n    }\n\n#ifdef FEAT_LINEBREAK\n    // 'numberwidth' must be positive\n    else if (pp == &curwin->w_p_nuw)\n    {\n\tif (curwin->w_p_nuw < 1)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    curwin->w_p_nuw = 1;\n\t}\n\tif (curwin->w_p_nuw > 20)\n\t{\n\t    errmsg = e_invalid_argument;\n\t    curwin->w_p_nuw = 20;\n\t}\n\tcurwin->w_nrwidth_line_count = 0; // trigger a redraw\n    }\n#endif\n\n    else if (pp == &curbuf->b_p_tw)\n    {\n\tif (curbuf->b_p_tw < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    curbuf->b_p_tw = 0;\n\t}\n#ifdef FEAT_SYN_HL\n\t{\n\t    win_T\t*wp;\n\t    tabpage_T\t*tp;\n\n\t    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t\tcheck_colorcolumn(wp);\n\t}\n#endif\n    }\n\n    /*\n     * Check the bounds for numeric options here\n     */\n    if (Rows < min_rows() && full_screen)\n    {\n\tif (errbuf != NULL)\n\t{\n\t    vim_snprintf(errbuf, errbuflen,\n\t\t\t       _(e_need_at_least_nr_lines), min_rows());\n\t    errmsg = errbuf;\n\t}\n\tRows = min_rows();\n    }\n    if (Columns < MIN_COLUMNS && full_screen)\n    {\n\tif (errbuf != NULL)\n\t{\n\t    vim_snprintf(errbuf, errbuflen,\n\t\t\t    _(e_need_at_least_nr_columns), MIN_COLUMNS);\n\t    errmsg = errbuf;\n\t}\n\tColumns = MIN_COLUMNS;\n    }\n    limit_screen_size();\n\n    /*\n     * If the screen (shell) height has been changed, assume it is the\n     * physical screenheight.\n     */\n    if (old_Rows != Rows || old_Columns != Columns)\n    {\n\t// Changing the screen size is not allowed while updating the screen.\n\tif (updating_screen)\n\t    *pp = old_value;\n\telse if (full_screen\n#ifdef FEAT_GUI\n\t\t&& !gui.starting\n#endif\n\t    )\n\t    set_shellsize((int)Columns, (int)Rows, TRUE);\n\telse\n\t{\n\t    // Postpone the resizing; check the size and cmdline position for\n\t    // messages.\n\t    check_shellsize();\n\t    if (cmdline_row > Rows - p_ch && Rows > p_ch)\n\t\tcmdline_row = Rows - p_ch;\n\t}\n\tif (p_window >= Rows || !option_was_set((char_u *)\"window\"))\n\t    p_window = Rows - 1;\n    }\n\n    if (curbuf->b_p_ts <= 0)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tcurbuf->b_p_ts = 8;\n    }\n    if (p_tm < 0)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_tm = 0;\n    }\n    if ((curwin->w_p_scr <= 0\n\t\t|| (curwin->w_p_scr > curwin->w_height\n\t\t    && curwin->w_height > 0))\n\t    && full_screen)\n    {\n\tif (pp == &(curwin->w_p_scr))\n\t{\n\t    if (curwin->w_p_scr != 0)\n\t\terrmsg = e_invalid_scroll_size;\n\t    win_comp_scroll(curwin);\n\t}\n\t// If 'scroll' became invalid because of a side effect silently adjust\n\t// it.\n\telse if (curwin->w_p_scr <= 0)\n\t    curwin->w_p_scr = 1;\n\telse // curwin->w_p_scr > curwin->w_height\n\t    curwin->w_p_scr = curwin->w_height;\n    }\n    if (p_hi < 0)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_hi = 0;\n    }\n    else if (p_hi > 10000)\n    {\n\terrmsg = e_invalid_argument;\n\tp_hi = 10000;\n    }\n    if (p_re < 0 || p_re > 2)\n    {\n\terrmsg = e_invalid_argument;\n\tp_re = 0;\n    }\n    if (p_report < 0)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_report = 1;\n    }\n    if ((p_sj < -100 || p_sj >= Rows) && full_screen)\n    {\n\tif (Rows != old_Rows)\t// Rows changed, just adjust p_sj\n\t    p_sj = Rows / 2;\n\telse\n\t{\n\t    errmsg = e_invalid_scroll_size;\n\t    p_sj = 1;\n\t}\n    }\n    if (p_so < 0 && full_screen)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_so = 0;\n    }\n    if (p_siso < 0 && full_screen)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_siso = 0;\n    }\n#ifdef FEAT_CMDWIN\n    if (p_cwh < 1)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_cwh = 1;\n    }\n#endif\n    if (p_ut < 0)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_ut = 2000;\n    }\n    if (p_ss < 0)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_ss = 0;\n    }\n\n    // May set global value for local option.\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\t*(long *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) = *pp;\n\n    options[opt_idx].flags |= P_WAS_SET;\n\n#if defined(FEAT_EVAL)\n    apply_optionset_autocmd(opt_idx, opt_flags, old_value, old_global_value,\n\t\t\t\t\t\t\t\tvalue, errmsg);\n#endif\n\n    comp_col();\t\t\t    // in case 'columns' or 'ls' changed\n    if (curwin->w_curswant != MAXCOL\n\t\t     && (options[opt_idx].flags & (P_CURSWANT | P_RALL)) != 0)\n\tcurwin->w_set_curswant = TRUE;\n    if ((opt_flags & OPT_NO_REDRAW) == 0)\n\tcheck_redraw(options[opt_idx].flags);\n\n    return errmsg;\n}\n\n/*\n * Called after an option changed: check if something needs to be redrawn.\n */\n    void\ncheck_redraw(long_u flags)\n{\n    // Careful: P_RCLR and P_RALL are a combination of other P_ flags\n    int\t\tdoclear = (flags & P_RCLR) == P_RCLR;\n    int\t\tall = ((flags & P_RALL) == P_RALL || doclear);\n\n    if ((flags & P_RSTAT) || all)\t// mark all status lines dirty\n\tstatus_redraw_all();\n\n    if ((flags & P_RBUF) || (flags & P_RWIN) || all)\n\tchanged_window_setting();\n    if (flags & P_RBUF)\n\tredraw_curbuf_later(NOT_VALID);\n    if (flags & P_RWINONLY)\n\tredraw_later(NOT_VALID);\n    if (doclear)\n\tredraw_all_later(CLEAR);\n    else if (all)\n\tredraw_all_later(NOT_VALID);\n}\n\n/*\n * Find index for option 'arg'.\n * Return -1 if not found.\n */\n    int\nfindoption(char_u *arg)\n{\n    int\t\t    opt_idx;\n    char\t    *s, *p;\n    static short    quick_tab[27] = {0, 0};\t// quick access table\n    int\t\t    is_term_opt;\n\n    /*\n     * For first call: Initialize the quick-access table.\n     * It contains the index for the first option that starts with a certain\n     * letter.  There are 26 letters, plus the first \"t_\" option.\n     */\n    if (quick_tab[1] == 0)\n    {\n\tp = options[0].fullname;\n\tfor (opt_idx = 1; (s = options[opt_idx].fullname) != NULL; opt_idx++)\n\t{\n\t    if (s[0] != p[0])\n\t    {\n\t\tif (s[0] == 't' && s[1] == '_')\n\t\t    quick_tab[26] = opt_idx;\n\t\telse\n\t\t    quick_tab[CharOrdLow(s[0])] = opt_idx;\n\t    }\n\t    p = s;\n\t}\n    }\n\n    /*\n     * Check for name starting with an illegal character.\n     */\n#ifdef EBCDIC\n    if (!islower(arg[0]))\n#else\n    if (arg[0] < 'a' || arg[0] > 'z')\n#endif\n\treturn -1;\n\n    is_term_opt = (arg[0] == 't' && arg[1] == '_');\n    if (is_term_opt)\n\topt_idx = quick_tab[26];\n    else\n\topt_idx = quick_tab[CharOrdLow(arg[0])];\n    for ( ; (s = options[opt_idx].fullname) != NULL; opt_idx++)\n    {\n\tif (STRCMP(arg, s) == 0)\t\t    // match full name\n\t    break;\n    }\n    if (s == NULL && !is_term_opt)\n    {\n\topt_idx = quick_tab[CharOrdLow(arg[0])];\n\tfor ( ; options[opt_idx].fullname != NULL; opt_idx++)\n\t{\n\t    s = options[opt_idx].shortname;\n\t    if (s != NULL && STRCMP(arg, s) == 0)   // match short name\n\t\tbreak;\n\t    s = NULL;\n\t}\n    }\n    if (s == NULL)\n\topt_idx = -1;\n    return opt_idx;\n}\n\n#if defined(FEAT_EVAL) || defined(FEAT_TCL) || defined(FEAT_MZSCHEME)\n/*\n * Get the value for an option.\n *\n * Returns:\n * Number option: gov_number, *numval gets value.\n * Toggle option: gov_bool,   *numval gets value.\n * String option: gov_string, *stringval gets allocated string.\n * Hidden Number option: gov_hidden_number.\n * Hidden Toggle option: gov_hidden_bool.\n * Hidden String option: gov_hidden_string.\n * Unknown option: gov_unknown.\n *\n * \"flagsp\" (if not NULL) is set to the option flags (P_xxxx).\n */\n    getoption_T\nget_option_value(\n    char_u\t*name,\n    long\t*numval,\n    char_u\t**stringval,\t    // NULL when only checking existence\n    int\t\t*flagsp,\n    int\t\tscope)\n{\n    int\t\topt_idx;\n    char_u\t*varp;\n\n    opt_idx = findoption(name);\n    if (opt_idx < 0)\t\t    // option not in the table\n    {\n\tint key;\n\n\tif (STRLEN(name) == 4 && name[0] == 't' && name[1] == '_'\n\t\t\t\t  && (key = find_key_option(name, FALSE)) != 0)\n\t{\n\t    char_u key_name[2];\n\t    char_u *p;\n\n\t    if (flagsp != NULL)\n\t\t*flagsp = 0;  // terminal option has no flags\n\n\t    // check for a terminal option\n\t    if (key < 0)\n\t    {\n\t\tkey_name[0] = KEY2TERMCAP0(key);\n\t\tkey_name[1] = KEY2TERMCAP1(key);\n\t    }\n\t    else\n\t    {\n\t\tkey_name[0] = KS_KEY;\n\t\tkey_name[1] = (key & 0xff);\n\t    }\n\t    p = find_termcode(key_name);\n\t    if (p != NULL)\n\t    {\n\t\tif (stringval != NULL)\n\t\t    *stringval = vim_strsave(p);\n\t\treturn gov_string;\n\t    }\n\t}\n\treturn gov_unknown;\n    }\n\n    varp = get_varp_scope(&(options[opt_idx]), scope);\n\n    if (flagsp != NULL)\n\t// Return the P_xxxx option flags.\n\t*flagsp = options[opt_idx].flags;\n\n    if (options[opt_idx].flags & P_STRING)\n    {\n\tif (varp == NULL)\t\t    // hidden option\n\t    return gov_hidden_string;\n\tif (stringval != NULL)\n\t{\n#ifdef FEAT_CRYPT\n\t    // never return the value of the crypt key\n\t    if ((char_u **)varp == &curbuf->b_p_key\n\t\t\t\t\t\t&& **(char_u **)(varp) != NUL)\n\t\t*stringval = vim_strsave((char_u *)\"*****\");\n\t    else\n#endif\n\t\t*stringval = vim_strsave(*(char_u **)(varp));\n\t}\n\treturn gov_string;\n    }\n\n    if (varp == NULL)\t\t    // hidden option\n\treturn (options[opt_idx].flags & P_NUM)\n\t\t\t\t\t ? gov_hidden_number : gov_hidden_bool;\n    if (options[opt_idx].flags & P_NUM)\n\t*numval = *(long *)varp;\n    else\n    {\n\t// Special case: 'modified' is b_changed, but we also want to consider\n\t// it set when 'ff' or 'fenc' changed.\n\tif ((int *)varp == &curbuf->b_changed)\n\t    *numval = curbufIsChanged();\n\telse\n\t    *numval = (long) *(int *)varp;\n    }\n    return (options[opt_idx].flags & P_NUM) ? gov_number : gov_bool;\n}\n#endif\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) || defined(PROTO)\n/*\n * Returns the option attributes and its value. Unlike the above function it\n * will return either global value or local value of the option depending on\n * what was requested, but it will never return global value if it was\n * requested to return local one and vice versa. Neither it will return\n * buffer-local value if it was requested to return window-local one.\n *\n * Pretends that option is absent if it is not present in the requested scope\n * (i.e. has no global, window-local or buffer-local value depending on\n * opt_type). Uses\n *\n * Returned flags:\n *       0 hidden or unknown option, also option that does not have requested\n *\t   type (see SREQ_* in vim.h)\n *  see SOPT_* in vim.h for other flags\n *\n * Possible opt_type values: see SREQ_* in vim.h\n */\n    int\nget_option_value_strict(\n    char_u\t*name,\n    long\t*numval,\n    char_u\t**stringval,\t    // NULL when only obtaining attributes\n    int\t\topt_type,\n    void\t*from)\n{\n    int\t\topt_idx;\n    char_u\t*varp = NULL;\n    struct vimoption *p;\n    int\t\tr = 0;\n\n    opt_idx = findoption(name);\n    if (opt_idx < 0)\n\treturn 0;\n\n    p = &(options[opt_idx]);\n\n    // Hidden option\n    if (p->var == NULL)\n\treturn 0;\n\n    if (p->flags & P_BOOL)\n\tr |= SOPT_BOOL;\n    else if (p->flags & P_NUM)\n\tr |= SOPT_NUM;\n    else if (p->flags & P_STRING)\n\tr |= SOPT_STRING;\n\n    if (p->indir == PV_NONE)\n    {\n\tif (opt_type == SREQ_GLOBAL)\n\t    r |= SOPT_GLOBAL;\n\telse\n\t    return 0; // Did not request global-only option\n    }\n    else\n    {\n\tif (p->indir & PV_BOTH)\n\t    r |= SOPT_GLOBAL;\n\telse if (opt_type == SREQ_GLOBAL)\n\t    return 0; // Requested global option\n\n\tif (p->indir & PV_WIN)\n\t{\n\t    if (opt_type == SREQ_BUF)\n\t\treturn 0; // Did not request window-local option\n\t    else\n\t\tr |= SOPT_WIN;\n\t}\n\telse if (p->indir & PV_BUF)\n\t{\n\t    if (opt_type == SREQ_WIN)\n\t\treturn 0; // Did not request buffer-local option\n\t    else\n\t\tr |= SOPT_BUF;\n\t}\n    }\n\n    if (stringval == NULL)\n\treturn r;\n\n    if (opt_type == SREQ_GLOBAL)\n\tvarp = p->var;\n    else\n    {\n\tif (opt_type == SREQ_BUF)\n\t{\n\t    // Special case: 'modified' is b_changed, but we also want to\n\t    // consider it set when 'ff' or 'fenc' changed.\n\t    if (p->indir == PV_MOD)\n\t    {\n\t\t*numval = bufIsChanged((buf_T *)from);\n\t\tvarp = NULL;\n\t    }\n#ifdef FEAT_CRYPT\n\t    else if (p->indir == PV_KEY)\n\t    {\n\t\t// never return the value of the crypt key\n\t\t*stringval = NULL;\n\t\tvarp = NULL;\n\t    }\n#endif\n\t    else\n\t    {\n\t\tbuf_T *save_curbuf = curbuf;\n\n\t\t// only getting a pointer, no need to use aucmd_prepbuf()\n\t\tcurbuf = (buf_T *)from;\n\t\tcurwin->w_buffer = curbuf;\n\t\tvarp = get_varp(p);\n\t\tcurbuf = save_curbuf;\n\t\tcurwin->w_buffer = curbuf;\n\t    }\n\t}\n\telse if (opt_type == SREQ_WIN)\n\t{\n\t    win_T\t*save_curwin = curwin;\n\n\t    curwin = (win_T *)from;\n\t    curbuf = curwin->w_buffer;\n\t    varp = get_varp(p);\n\t    curwin = save_curwin;\n\t    curbuf = curwin->w_buffer;\n\t}\n\tif (varp == p->var)\n\t    return (r | SOPT_UNSET);\n    }\n\n    if (varp != NULL)\n    {\n\tif (p->flags & P_STRING)\n\t    *stringval = vim_strsave(*(char_u **)(varp));\n\telse if (p->flags & P_NUM)\n\t    *numval = *(long *) varp;\n\telse\n\t    *numval = *(int *)varp;\n    }\n\n    return r;\n}\n\n/*\n * Iterate over options. First argument is a pointer to a pointer to a\n * structure inside options[] array, second is option type like in the above\n * function.\n *\n * If first argument points to NULL it is assumed that iteration just started\n * and caller needs the very first value.\n * If first argument points to the end marker function returns NULL and sets\n * first argument to NULL.\n *\n * Returns full option name for current option on each call.\n */\n    char_u *\noption_iter_next(void **option, int opt_type)\n{\n    struct vimoption\t*ret = NULL;\n    do\n    {\n\tif (*option == NULL)\n\t    *option = (void *) options;\n\telse if (((struct vimoption *) (*option))->fullname == NULL)\n\t{\n\t    *option = NULL;\n\t    return NULL;\n\t}\n\telse\n\t    *option = (void *) (((struct vimoption *) (*option)) + 1);\n\n\tret = ((struct vimoption *) (*option));\n\n\t// Hidden option\n\tif (ret->var == NULL)\n\t{\n\t    ret = NULL;\n\t    continue;\n\t}\n\n\tswitch (opt_type)\n\t{\n\t    case SREQ_GLOBAL:\n\t\tif (!(ret->indir == PV_NONE || ret->indir & PV_BOTH))\n\t\t    ret = NULL;\n\t\tbreak;\n\t    case SREQ_BUF:\n\t\tif (!(ret->indir & PV_BUF))\n\t\t    ret = NULL;\n\t\tbreak;\n\t    case SREQ_WIN:\n\t\tif (!(ret->indir & PV_WIN))\n\t\t    ret = NULL;\n\t\tbreak;\n\t    default:\n\t\tinternal_error(\"option_iter_next()\");\n\t\treturn NULL;\n\t}\n    }\n    while (ret == NULL);\n\n    return (char_u *)ret->fullname;\n}\n#endif\n\n/*\n * Return the flags for the option at 'opt_idx'.\n */\n    long_u\nget_option_flags(int opt_idx)\n{\n    return options[opt_idx].flags;\n}\n\n/*\n * Set a flag for the option at 'opt_idx'.\n */\n    void\nset_option_flag(int opt_idx, long_u flag)\n{\n    options[opt_idx].flags |= flag;\n}\n\n/*\n * Clear a flag for the option at 'opt_idx'.\n */\n    void\nclear_option_flag(int opt_idx, long_u flag)\n{\n    options[opt_idx].flags &= ~flag;\n}\n\n/*\n * Returns TRUE if the option at 'opt_idx' is a global option\n */\n    int\nis_global_option(int opt_idx)\n{\n    return options[opt_idx].indir == PV_NONE;\n}\n\n/*\n * Returns TRUE if the option at 'opt_idx' is a global option which also has a\n * local value.\n */\n    int\nis_global_local_option(int opt_idx)\n{\n    return options[opt_idx].indir & PV_BOTH;\n}\n\n/*\n * Returns TRUE if the option at 'opt_idx' is a window-local option\n */\n    int\nis_window_local_option(int opt_idx)\n{\n    return options[opt_idx].var == VAR_WIN;\n}\n\n/*\n * Returns TRUE if the option at 'opt_idx' is a hidden option\n */\n    int\nis_hidden_option(int opt_idx)\n{\n    return options[opt_idx].var == NULL;\n}\n\n#if defined(FEAT_CRYPT) || defined(PROTO)\n/*\n * Returns TRUE if the option at 'opt_idx' is a crypt key option\n */\n    int\nis_crypt_key_option(int opt_idx)\n{\n    return options[opt_idx].indir == PV_KEY;\n}\n#endif\n\n/*\n * Set the value of option \"name\".\n * Use \"string\" for string options, use \"number\" for other options.\n *\n * Returns NULL on success or error message on error.\n */\n    char *\nset_option_value(\n    char_u\t*name,\n    long\tnumber,\n    char_u\t*string,\n    int\t\topt_flags)\t// OPT_LOCAL or 0 (both)\n{\n    int\t\topt_idx;\n    char_u\t*varp;\n    long_u\tflags;\n\n    opt_idx = findoption(name);\n    if (opt_idx < 0)\n    {\n\tint key;\n\n\tif (STRLEN(name) == 4 && name[0] == 't' && name[1] == '_'\n\t\t&& (key = find_key_option(name, FALSE)) != 0)\n\t{\n\t    char_u key_name[2];\n\n\t    if (key < 0)\n\t    {\n\t\tkey_name[0] = KEY2TERMCAP0(key);\n\t\tkey_name[1] = KEY2TERMCAP1(key);\n\t    }\n\t    else\n\t    {\n\t\tkey_name[0] = KS_KEY;\n\t\tkey_name[1] = (key & 0xff);\n\t    }\n\t    add_termcode(key_name, string, FALSE);\n\t    if (full_screen)\n\t\tttest(FALSE);\n\t    redraw_all_later(CLEAR);\n\t    return NULL;\n\t}\n\n\tsemsg(_(e_unknown_option_str_2), name);\n    }\n    else\n    {\n\tflags = options[opt_idx].flags;\n#ifdef HAVE_SANDBOX\n\t// Disallow changing some options in the sandbox\n\tif (sandbox > 0 && (flags & P_SECURE))\n\t{\n\t    emsg(_(e_not_allowed_in_sandbox));\n\t    return NULL;\n\t}\n#endif\n\tif (flags & P_STRING)\n\t    return set_string_option(opt_idx, string, opt_flags);\n\telse\n\t{\n\t    varp = get_varp_scope(&(options[opt_idx]), opt_flags);\n\t    if (varp != NULL)\t// hidden option is not changed\n\t    {\n\t\tif (number == 0 && string != NULL)\n\t\t{\n\t\t    int idx;\n\n\t\t    // Either we are given a string or we are setting option\n\t\t    // to zero.\n\t\t    for (idx = 0; string[idx] == '0'; ++idx)\n\t\t\t;\n\t\t    if (string[idx] != NUL || idx == 0)\n\t\t    {\n\t\t\t// There's another character after zeros or the string\n\t\t\t// is empty.  In both cases, we are trying to set a\n\t\t\t// num option using a string.\n\t\t\tsemsg(_(e_number_required_after_str_equal_str),\n\t\t\t\t\t\t\t\tname, string);\n\t\t\treturn NULL;     // do nothing as we hit an error\n\n\t\t    }\n\t\t}\n\t\tif (flags & P_NUM)\n\t\t    return set_num_option(opt_idx, varp, number,\n\t\t\t\t\t\t\t  NULL, 0, opt_flags);\n\t\telse\n\t\t    return set_bool_option(opt_idx, varp, (int)number,\n\t\t\t\t\t\t\t\t   opt_flags);\n\t    }\n\t}\n    }\n    return NULL;\n}\n\n/*\n * Get the terminal code for a terminal option.\n * Returns NULL when not found.\n */\n    char_u *\nget_term_code(char_u *tname)\n{\n    int\t    opt_idx;\n    char_u  *varp;\n\n    if (tname[0] != 't' || tname[1] != '_' ||\n\t    tname[2] == NUL || tname[3] == NUL)\n\treturn NULL;\n    if ((opt_idx = findoption(tname)) >= 0)\n    {\n\tvarp = get_varp(&(options[opt_idx]));\n\tif (varp != NULL)\n\t    varp = *(char_u **)(varp);\n\treturn varp;\n    }\n    return find_termcode(tname + 2);\n}\n\n    char_u *\nget_highlight_default(void)\n{\n    int i;\n\n    i = findoption((char_u *)\"hl\");\n    if (i >= 0)\n\treturn options[i].def_val[VI_DEFAULT];\n    return (char_u *)NULL;\n}\n\n    char_u *\nget_encoding_default(void)\n{\n    int i;\n\n    i = findoption((char_u *)\"enc\");\n    if (i >= 0)\n\treturn options[i].def_val[VI_DEFAULT];\n    return (char_u *)NULL;\n}\n\n/*\n * Translate a string like \"t_xx\", \"<t_xx>\" or \"<S-Tab>\" to a key number.\n * When \"has_lt\" is true there is a '<' before \"*arg_arg\".\n * Returns 0 when the key is not recognized.\n */\n    static int\nfind_key_option(char_u *arg_arg, int has_lt)\n{\n    int\t\tkey = 0;\n    int\t\tmodifiers;\n    char_u\t*arg = arg_arg;\n\n    /*\n     * Don't use get_special_key_code() for t_xx, we don't want it to call\n     * add_termcap_entry().\n     */\n    if (arg[0] == 't' && arg[1] == '_' && arg[2] && arg[3])\n\tkey = TERMCAP2KEY(arg[2], arg[3]);\n    else if (has_lt)\n    {\n\t--arg;\t\t\t    // put arg at the '<'\n\tmodifiers = 0;\n\tkey = find_special_key(&arg, &modifiers,\n\t\t\t    FSK_KEYCODE | FSK_KEEP_X_KEY | FSK_SIMPLIFY, NULL);\n\tif (modifiers)\t\t    // can't handle modifiers here\n\t    key = 0;\n    }\n    return key;\n}\n\n/*\n * if 'all' == 0: show changed options\n * if 'all' == 1: show all normal options\n * if 'all' == 2: show all terminal options\n */\n    static void\nshowoptions(\n    int\t\tall,\n    int\t\topt_flags)\t// OPT_LOCAL and/or OPT_GLOBAL\n{\n    struct vimoption\t*p;\n    int\t\t\tcol;\n    int\t\t\tisterm;\n    char_u\t\t*varp;\n    struct vimoption\t**items;\n    int\t\t\titem_count;\n    int\t\t\trun;\n    int\t\t\trow, rows;\n    int\t\t\tcols;\n    int\t\t\ti;\n    int\t\t\tlen;\n\n#define INC 20\n#define GAP 3\n\n    items = ALLOC_MULT(struct vimoption *, OPTION_COUNT);\n    if (items == NULL)\n\treturn;\n\n    // Highlight title\n    if (all == 2)\n\tmsg_puts_title(_(\"\\n--- Terminal codes ---\"));\n    else if (opt_flags & OPT_GLOBAL)\n\tmsg_puts_title(_(\"\\n--- Global option values ---\"));\n    else if (opt_flags & OPT_LOCAL)\n\tmsg_puts_title(_(\"\\n--- Local option values ---\"));\n    else\n\tmsg_puts_title(_(\"\\n--- Options ---\"));\n\n    /*\n     * Do the loop two times:\n     * 1. display the short items\n     * 2. display the long items (only strings and numbers)\n     * When \"opt_flags\" has OPT_ONECOLUMN do everything in run 2.\n     */\n    for (run = 1; run <= 2 && !got_int; ++run)\n    {\n\t/*\n\t * collect the items in items[]\n\t */\n\titem_count = 0;\n\tfor (p = &options[0]; p->fullname != NULL; p++)\n\t{\n\t    // apply :filter /pat/\n\t    if (message_filtered((char_u *)p->fullname))\n\t\tcontinue;\n\n\t    varp = NULL;\n\t    isterm = istermoption(p);\n\t    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) != 0)\n\t    {\n\t\tif (p->indir != PV_NONE && !isterm)\n\t\t    varp = get_varp_scope(p, opt_flags);\n\t    }\n\t    else\n\t\tvarp = get_varp(p);\n\t    if (varp != NULL\n\t\t    && ((all == 2 && isterm)\n\t\t\t|| (all == 1 && !isterm)\n\t\t\t|| (all == 0 && !optval_default(p, varp, p_cp))))\n\t    {\n\t\tif (opt_flags & OPT_ONECOLUMN)\n\t\t    len = Columns;\n\t\telse if (p->flags & P_BOOL)\n\t\t    len = 1;\t\t// a toggle option fits always\n\t\telse\n\t\t{\n\t\t    option_value2string(p, opt_flags);\n\t\t    len = (int)STRLEN(p->fullname) + vim_strsize(NameBuff) + 1;\n\t\t}\n\t\tif ((len <= INC - GAP && run == 1) ||\n\t\t\t\t\t\t(len > INC - GAP && run == 2))\n\t\t    items[item_count++] = p;\n\t    }\n\t}\n\n\t/*\n\t * display the items\n\t */\n\tif (run == 1)\n\t{\n\t    cols = (Columns + GAP - 3) / INC;\n\t    if (cols == 0)\n\t\tcols = 1;\n\t    rows = (item_count + cols - 1) / cols;\n\t}\n\telse\t// run == 2\n\t    rows = item_count;\n\tfor (row = 0; row < rows && !got_int; ++row)\n\t{\n\t    msg_putchar('\\n');\t\t\t// go to next line\n\t    if (got_int)\t\t\t// 'q' typed in more\n\t\tbreak;\n\t    col = 0;\n\t    for (i = row; i < item_count; i += rows)\n\t    {\n\t\tmsg_col = col;\t\t\t// make columns\n\t\tshowoneopt(items[i], opt_flags);\n\t\tcol += INC;\n\t    }\n\t    out_flush();\n\t    ui_breakcheck();\n\t}\n    }\n    vim_free(items);\n}\n\n/*\n * Return TRUE if option \"p\" has its default value.\n */\n    static int\noptval_default(struct vimoption *p, char_u *varp, int compatible)\n{\n    int\t\tdvi;\n\n    if (varp == NULL)\n\treturn TRUE;\t    // hidden option is always at default\n    dvi = ((p->flags & P_VI_DEF) || compatible) ? VI_DEFAULT : VIM_DEFAULT;\n    if (p->flags & P_NUM)\n\treturn (*(long *)varp == (long)(long_i)p->def_val[dvi]);\n    if (p->flags & P_BOOL)\n\t\t\t// the cast to long is required for Manx C, long_i is\n\t\t\t// needed for MSVC\n\treturn (*(int *)varp == (int)(long)(long_i)p->def_val[dvi]);\n    // P_STRING\n    return (STRCMP(*(char_u **)varp, p->def_val[dvi]) == 0);\n}\n\n/*\n * showoneopt: show the value of one option\n * must not be called with a hidden option!\n */\n    static void\nshowoneopt(\n    struct vimoption\t*p,\n    int\t\t\topt_flags)\t// OPT_LOCAL or OPT_GLOBAL\n{\n    char_u\t*varp;\n    int\t\tsave_silent = silent_mode;\n\n    silent_mode = FALSE;\n    info_message = TRUE;\t// use mch_msg(), not mch_errmsg()\n\n    varp = get_varp_scope(p, opt_flags);\n\n    // for 'modified' we also need to check if 'ff' or 'fenc' changed.\n    if ((p->flags & P_BOOL) && ((int *)varp == &curbuf->b_changed\n\t\t\t\t\t? !curbufIsChanged() : !*(int *)varp))\n\tmsg_puts(\"no\");\n    else if ((p->flags & P_BOOL) && *(int *)varp < 0)\n\tmsg_puts(\"--\");\n    else\n\tmsg_puts(\"  \");\n    msg_puts(p->fullname);\n    if (!(p->flags & P_BOOL))\n    {\n\tmsg_putchar('=');\n\t// put value string in NameBuff\n\toption_value2string(p, opt_flags);\n\tmsg_outtrans(NameBuff);\n    }\n\n    silent_mode = save_silent;\n    info_message = FALSE;\n}\n\n/*\n * Write modified options as \":set\" commands to a file.\n *\n * There are three values for \"opt_flags\":\n * OPT_GLOBAL:\t\t   Write global option values and fresh values of\n *\t\t\t   buffer-local options (used for start of a session\n *\t\t\t   file).\n * OPT_GLOBAL + OPT_LOCAL: Idem, add fresh values of window-local options for\n *\t\t\t   curwin (used for a vimrc file).\n * OPT_LOCAL:\t\t   Write buffer-local option values for curbuf, fresh\n *\t\t\t   and local values for window-local options of\n *\t\t\t   curwin.  Local values are also written when at the\n *\t\t\t   default value, because a modeline or autocommand\n *\t\t\t   may have set them when doing \":edit file\" and the\n *\t\t\t   user has set them back at the default or fresh\n *\t\t\t   value.\n *\t\t\t   When \"local_only\" is TRUE, don't write fresh\n *\t\t\t   values, only local values (for \":mkview\").\n * (fresh value = value used for a new buffer or window for a local option).\n *\n * Return FAIL on error, OK otherwise.\n */\n    int\nmakeset(FILE *fd, int opt_flags, int local_only)\n{\n    struct vimoption\t*p;\n    char_u\t\t*varp;\t\t\t// currently used value\n    char_u\t\t*varp_fresh;\t\t// local value\n    char_u\t\t*varp_local = NULL;\t// fresh value\n    char\t\t*cmd;\n    int\t\t\tround;\n    int\t\t\tpri;\n\n    /*\n     * The options that don't have a default (terminal name, columns, lines)\n     * are never written.  Terminal options are also not written.\n     * Do the loop over \"options[]\" twice: once for options with the\n     * P_PRI_MKRC flag and once without.\n     */\n    for (pri = 1; pri >= 0; --pri)\n    {\n      for (p = &options[0]; !istermoption(p); p++)\n\tif (!(p->flags & P_NO_MKRC)\n\t\t&& !istermoption(p)\n\t\t&& ((pri == 1) == ((p->flags & P_PRI_MKRC) != 0)))\n\t{\n\t    // skip global option when only doing locals\n\t    if (p->indir == PV_NONE && !(opt_flags & OPT_GLOBAL))\n\t\tcontinue;\n\n\t    // Do not store options like 'bufhidden' and 'syntax' in a vimrc\n\t    // file, they are always buffer-specific.\n\t    if ((opt_flags & OPT_GLOBAL) && (p->flags & P_NOGLOB))\n\t\tcontinue;\n\n\t    // Global values are only written when not at the default value.\n\t    varp = get_varp_scope(p, opt_flags);\n\t    if ((opt_flags & OPT_GLOBAL) && optval_default(p, varp, p_cp))\n\t\tcontinue;\n\n\t    if ((opt_flags & OPT_SKIPRTP) && (p->var == (char_u *)&p_rtp\n\t\t\t\t\t\t || p->var == (char_u *)&p_pp))\n\t\tcontinue;\n\n\t    round = 2;\n\t    if (p->indir != PV_NONE)\n\t    {\n\t\tif (p->var == VAR_WIN)\n\t\t{\n\t\t    // skip window-local option when only doing globals\n\t\t    if (!(opt_flags & OPT_LOCAL))\n\t\t\tcontinue;\n\t\t    // When fresh value of window-local option is not at the\n\t\t    // default, need to write it too.\n\t\t    if (!(opt_flags & OPT_GLOBAL) && !local_only)\n\t\t    {\n\t\t\tvarp_fresh = get_varp_scope(p, OPT_GLOBAL);\n\t\t\tif (!optval_default(p, varp_fresh, p_cp))\n\t\t\t{\n\t\t\t    round = 1;\n\t\t\t    varp_local = varp;\n\t\t\t    varp = varp_fresh;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t    // Round 1: fresh value for window-local options.\n\t    // Round 2: other values\n\t    for ( ; round <= 2; varp = varp_local, ++round)\n\t    {\n\t\tif (round == 1 || (opt_flags & OPT_GLOBAL))\n\t\t    cmd = \"set\";\n\t\telse\n\t\t    cmd = \"setlocal\";\n\n\t\tif (p->flags & P_BOOL)\n\t\t{\n\t\t    if (put_setbool(fd, cmd, p->fullname, *(int *)varp) == FAIL)\n\t\t\treturn FAIL;\n\t\t}\n\t\telse if (p->flags & P_NUM)\n\t\t{\n\t\t    if (put_setnum(fd, cmd, p->fullname, (long *)varp) == FAIL)\n\t\t\treturn FAIL;\n\t\t}\n\t\telse    // P_STRING\n\t\t{\n\t\t    int\t\tdo_endif = FALSE;\n\n\t\t    // Don't set 'syntax' and 'filetype' again if the value is\n\t\t    // already right, avoids reloading the syntax file.\n\t\t    if (\n#if defined(FEAT_SYN_HL)\n\t\t\t    p->indir == PV_SYN ||\n#endif\n\t\t\t    p->indir == PV_FT)\n\t\t    {\n\t\t\tif (fprintf(fd, \"if &%s != '%s'\", p->fullname,\n\t\t\t\t\t\t       *(char_u **)(varp)) < 0\n\t\t\t\t|| put_eol(fd) < 0)\n\t\t\t    return FAIL;\n\t\t\tdo_endif = TRUE;\n\t\t    }\n\t\t    if (put_setstring(fd, cmd, p->fullname, (char_u **)varp,\n\t\t\t\t\t\t\t     p->flags) == FAIL)\n\t\t\treturn FAIL;\n\t\t    if (do_endif)\n\t\t    {\n\t\t\tif (put_line(fd, \"endif\") == FAIL)\n\t\t\t    return FAIL;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    return OK;\n}\n\n#if defined(FEAT_FOLDING) || defined(PROTO)\n/*\n * Generate set commands for the local fold options only.  Used when\n * 'sessionoptions' or 'viewoptions' contains \"folds\" but not \"options\".\n */\n    int\nmakefoldset(FILE *fd)\n{\n    if (put_setstring(fd, \"setlocal\", \"fdm\", &curwin->w_p_fdm, 0) == FAIL\n# ifdef FEAT_EVAL\n\t    || put_setstring(fd, \"setlocal\", \"fde\", &curwin->w_p_fde, 0)\n\t\t\t\t\t\t\t\t       == FAIL\n# endif\n\t    || put_setstring(fd, \"setlocal\", \"fmr\", &curwin->w_p_fmr, 0)\n\t\t\t\t\t\t\t\t       == FAIL\n\t    || put_setstring(fd, \"setlocal\", \"fdi\", &curwin->w_p_fdi, 0)\n\t\t\t\t\t\t\t\t       == FAIL\n\t    || put_setnum(fd, \"setlocal\", \"fdl\", &curwin->w_p_fdl) == FAIL\n\t    || put_setnum(fd, \"setlocal\", \"fml\", &curwin->w_p_fml) == FAIL\n\t    || put_setnum(fd, \"setlocal\", \"fdn\", &curwin->w_p_fdn) == FAIL\n\t    || put_setbool(fd, \"setlocal\", \"fen\", curwin->w_p_fen) == FAIL\n\t    )\n\treturn FAIL;\n\n    return OK;\n}\n#endif\n\n    static int\nput_setstring(\n    FILE\t*fd,\n    char\t*cmd,\n    char\t*name,\n    char_u\t**valuep,\n    long_u\tflags)\n{\n    char_u\t*s;\n    char_u\t*buf = NULL;\n    char_u\t*part = NULL;\n    char_u\t*p;\n\n    if (fprintf(fd, \"%s %s=\", cmd, name) < 0)\n\treturn FAIL;\n    if (*valuep != NULL)\n    {\n\t// Output 'pastetoggle' as key names.  For other\n\t// options some characters have to be escaped with\n\t// CTRL-V or backslash\n\tif (valuep == &p_pt)\n\t{\n\t    s = *valuep;\n\t    while (*s != NUL)\n\t\tif (put_escstr(fd, str2special(&s, FALSE), 2) == FAIL)\n\t\t    return FAIL;\n\t}\n\t// expand the option value, replace $HOME by ~\n\telse if ((flags & P_EXPAND) != 0)\n\t{\n\t    int  size = (int)STRLEN(*valuep) + 1;\n\n\t    // replace home directory in the whole option value into \"buf\"\n\t    buf = alloc(size);\n\t    if (buf == NULL)\n\t\tgoto fail;\n\t    home_replace(NULL, *valuep, buf, size, FALSE);\n\n\t    // If the option value is longer than MAXPATHL, we need to append\n\t    // each comma separated part of the option separately, so that it\n\t    // can be expanded when read back.\n\t    if (size >= MAXPATHL && (flags & P_COMMA) != 0\n\t\t\t\t\t   && vim_strchr(*valuep, ',') != NULL)\n\t    {\n\t\tpart = alloc(size);\n\t\tif (part == NULL)\n\t\t    goto fail;\n\n\t\t// write line break to clear the option, e.g. ':set rtp='\n\t\tif (put_eol(fd) == FAIL)\n\t\t    goto fail;\n\n\t\tp = buf;\n\t\twhile (*p != NUL)\n\t\t{\n\t\t    // for each comma separated option part, append value to\n\t\t    // the option, :set rtp+=value\n\t\t    if (fprintf(fd, \"%s %s+=\", cmd, name) < 0)\n\t\t\tgoto fail;\n\t\t    (void)copy_option_part(&p, part, size,  \",\");\n\t\t    if (put_escstr(fd, part, 2) == FAIL || put_eol(fd) == FAIL)\n\t\t\tgoto fail;\n\t\t}\n\t\tvim_free(buf);\n\t\tvim_free(part);\n\t\treturn OK;\n\t    }\n\t    if (put_escstr(fd, buf, 2) == FAIL)\n\t    {\n\t\tvim_free(buf);\n\t\treturn FAIL;\n\t    }\n\t    vim_free(buf);\n\t}\n\telse if (put_escstr(fd, *valuep, 2) == FAIL)\n\t    return FAIL;\n    }\n    if (put_eol(fd) < 0)\n\treturn FAIL;\n    return OK;\nfail:\n    vim_free(buf);\n    vim_free(part);\n    return FAIL;\n}\n\n    static int\nput_setnum(\n    FILE\t*fd,\n    char\t*cmd,\n    char\t*name,\n    long\t*valuep)\n{\n    long\twc;\n\n    if (fprintf(fd, \"%s %s=\", cmd, name) < 0)\n\treturn FAIL;\n    if (wc_use_keyname((char_u *)valuep, &wc))\n    {\n\t// print 'wildchar' and 'wildcharm' as a key name\n\tif (fputs((char *)get_special_key_name((int)wc, 0), fd) < 0)\n\t    return FAIL;\n    }\n    else if (fprintf(fd, \"%ld\", *valuep) < 0)\n\treturn FAIL;\n    if (put_eol(fd) < 0)\n\treturn FAIL;\n    return OK;\n}\n\n    static int\nput_setbool(\n    FILE\t*fd,\n    char\t*cmd,\n    char\t*name,\n    int\t\tvalue)\n{\n    if (value < 0)\t// global/local option using global value\n\treturn OK;\n    if (fprintf(fd, \"%s %s%s\", cmd, value ? \"\" : \"no\", name) < 0\n\t    || put_eol(fd) < 0)\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Clear all the terminal options.\n * If the option has been allocated, free the memory.\n * Terminal options are never hidden or indirect.\n */\n    void\nclear_termoptions(void)\n{\n    /*\n     * Reset a few things before clearing the old options. This may cause\n     * outputting a few things that the terminal doesn't understand, but the\n     * screen will be cleared later, so this is OK.\n     */\n    mch_setmouse(FALSE);\t    // switch mouse off\n    mch_restore_title(SAVE_RESTORE_BOTH);    // restore window titles\n#if defined(FEAT_XCLIPBOARD) && defined(FEAT_GUI)\n    // When starting the GUI close the display opened for the clipboard.\n    // After restoring the title, because that will need the display.\n    if (gui.starting)\n\tclear_xterm_clip();\n#endif\n    stoptermcap();\t\t\t// stop termcap mode\n\n    free_termoptions();\n}\n\n    void\nfree_termoptions(void)\n{\n    struct vimoption   *p;\n\n    for (p = options; p->fullname != NULL; p++)\n\tif (istermoption(p))\n\t{\n\t    if (p->flags & P_ALLOCED)\n\t\tfree_string_option(*(char_u **)(p->var));\n\t    if (p->flags & P_DEF_ALLOCED)\n\t\tfree_string_option(p->def_val[VI_DEFAULT]);\n\t    *(char_u **)(p->var) = empty_option;\n\t    p->def_val[VI_DEFAULT] = empty_option;\n\t    p->flags &= ~(P_ALLOCED|P_DEF_ALLOCED);\n#ifdef FEAT_EVAL\n\t    // remember where the option was cleared\n\t    set_option_sctx_idx((int)(p - options), OPT_GLOBAL, current_sctx);\n#endif\n\t}\n    clear_termcodes();\n}\n\n/*\n * Free the string for one term option, if it was allocated.\n * Set the string to empty_option and clear allocated flag.\n * \"var\" points to the option value.\n */\n    void\nfree_one_termoption(char_u *var)\n{\n    struct vimoption   *p;\n\n    for (p = &options[0]; p->fullname != NULL; p++)\n\tif (p->var == var)\n\t{\n\t    if (p->flags & P_ALLOCED)\n\t\tfree_string_option(*(char_u **)(p->var));\n\t    *(char_u **)(p->var) = empty_option;\n\t    p->flags &= ~P_ALLOCED;\n\t    break;\n\t}\n}\n\n/*\n * Set the terminal option defaults to the current value.\n * Used after setting the terminal name.\n */\n    void\nset_term_defaults(void)\n{\n    struct vimoption   *p;\n\n    for (p = &options[0]; p->fullname != NULL; p++)\n    {\n\tif (istermoption(p) && p->def_val[VI_DEFAULT] != *(char_u **)(p->var))\n\t{\n\t    if (p->flags & P_DEF_ALLOCED)\n\t    {\n\t\tfree_string_option(p->def_val[VI_DEFAULT]);\n\t\tp->flags &= ~P_DEF_ALLOCED;\n\t    }\n\t    p->def_val[VI_DEFAULT] = *(char_u **)(p->var);\n\t    if (p->flags & P_ALLOCED)\n\t    {\n\t\tp->flags |= P_DEF_ALLOCED;\n\t\tp->flags &= ~P_ALLOCED;\t // don't free the value now\n\t    }\n\t}\n    }\n}\n\n/*\n * return TRUE if 'p' starts with 't_'\n */\n    static int\nistermoption(struct vimoption *p)\n{\n    return (p->fullname[0] == 't' && p->fullname[1] == '_');\n}\n\n/*\n * Returns TRUE if the option at 'opt_idx' starts with 't_'\n */\n    int\nistermoption_idx(int opt_idx)\n{\n    return istermoption(&options[opt_idx]);\n}\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) || defined(PROTO)\n/*\n * Unset local option value, similar to \":set opt<\".\n */\n    void\nunset_global_local_option(char_u *name, void *from)\n{\n    struct vimoption *p;\n    int\t\topt_idx;\n    buf_T\t*buf = (buf_T *)from;\n\n    opt_idx = findoption(name);\n    if (opt_idx < 0)\n\treturn;\n    p = &(options[opt_idx]);\n\n    switch ((int)p->indir)\n    {\n\t// global option with local value: use local value if it's been set\n\tcase PV_EP:\n\t    clear_string_option(&buf->b_p_ep);\n\t    break;\n\tcase PV_KP:\n\t    clear_string_option(&buf->b_p_kp);\n\t    break;\n\tcase PV_PATH:\n\t    clear_string_option(&buf->b_p_path);\n\t    break;\n\tcase PV_AR:\n\t    buf->b_p_ar = -1;\n\t    break;\n\tcase PV_BKC:\n\t    clear_string_option(&buf->b_p_bkc);\n\t    buf->b_bkc_flags = 0;\n\t    break;\n\tcase PV_TAGS:\n\t    clear_string_option(&buf->b_p_tags);\n\t    break;\n\tcase PV_TC:\n\t    clear_string_option(&buf->b_p_tc);\n\t    buf->b_tc_flags = 0;\n\t    break;\n        case PV_SISO:\n            curwin->w_p_siso = -1;\n            break;\n        case PV_SO:\n            curwin->w_p_so = -1;\n            break;\n#ifdef FEAT_FIND_ID\n\tcase PV_DEF:\n\t    clear_string_option(&buf->b_p_def);\n\t    break;\n\tcase PV_INC:\n\t    clear_string_option(&buf->b_p_inc);\n\t    break;\n#endif\n\tcase PV_DICT:\n\t    clear_string_option(&buf->b_p_dict);\n\t    break;\n\tcase PV_TSR:\n\t    clear_string_option(&buf->b_p_tsr);\n\t    break;\n#ifdef FEAT_COMPL_FUNC\n\tcase PV_TSRFU:\n\t    clear_string_option(&buf->b_p_tsrfu);\n\t    break;\n#endif\n\tcase PV_FP:\n\t    clear_string_option(&buf->b_p_fp);\n\t    break;\n#ifdef FEAT_QUICKFIX\n\tcase PV_EFM:\n\t    clear_string_option(&buf->b_p_efm);\n\t    break;\n\tcase PV_GP:\n\t    clear_string_option(&buf->b_p_gp);\n\t    break;\n\tcase PV_MP:\n\t    clear_string_option(&buf->b_p_mp);\n\t    break;\n#endif\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n\tcase PV_BEXPR:\n\t    clear_string_option(&buf->b_p_bexpr);\n\t    break;\n#endif\n#if defined(FEAT_CRYPT)\n\tcase PV_CM:\n\t    clear_string_option(&buf->b_p_cm);\n\t    break;\n#endif\n#ifdef FEAT_LINEBREAK\n\tcase PV_SBR:\n\t    clear_string_option(&((win_T *)from)->w_p_sbr);\n\t    break;\n#endif\n#ifdef FEAT_STL_OPT\n\tcase PV_STL:\n\t    clear_string_option(&((win_T *)from)->w_p_stl);\n\t    break;\n#endif\n\tcase PV_UL:\n\t    buf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n\t    break;\n#ifdef FEAT_LISP\n\tcase PV_LW:\n\t    clear_string_option(&buf->b_p_lw);\n\t    break;\n#endif\n\tcase PV_MENC:\n\t    clear_string_option(&buf->b_p_menc);\n\t    break;\n\tcase PV_LCS:\n\t    clear_string_option(&((win_T *)from)->w_p_lcs);\n\t    set_chars_option((win_T *)from, &((win_T *)from)->w_p_lcs);\n\t    redraw_later(NOT_VALID);\n\t    break;\n\tcase PV_VE:\n\t    clear_string_option(&((win_T *)from)->w_p_ve);\n\t    ((win_T *)from)->w_ve_flags = 0;\n\t    break;\n    }\n}\n#endif\n\n/*\n * Get pointer to option variable, depending on local or global scope.\n * \"scope\" can be OPT_LOCAL, OPT_GLOBAL or a combination.\n */\n    static char_u *\nget_varp_scope(struct vimoption *p, int scope)\n{\n    if ((scope & OPT_GLOBAL) && p->indir != PV_NONE)\n    {\n\tif (p->var == VAR_WIN)\n\t    return (char_u *)GLOBAL_WO(get_varp(p));\n\treturn p->var;\n    }\n    if ((scope & OPT_LOCAL) && ((int)p->indir & PV_BOTH))\n    {\n\tswitch ((int)p->indir)\n\t{\n\t    case PV_FP:   return (char_u *)&(curbuf->b_p_fp);\n#ifdef FEAT_QUICKFIX\n\t    case PV_EFM:  return (char_u *)&(curbuf->b_p_efm);\n\t    case PV_GP:   return (char_u *)&(curbuf->b_p_gp);\n\t    case PV_MP:   return (char_u *)&(curbuf->b_p_mp);\n#endif\n\t    case PV_EP:   return (char_u *)&(curbuf->b_p_ep);\n\t    case PV_KP:   return (char_u *)&(curbuf->b_p_kp);\n\t    case PV_PATH: return (char_u *)&(curbuf->b_p_path);\n\t    case PV_AR:   return (char_u *)&(curbuf->b_p_ar);\n\t    case PV_TAGS: return (char_u *)&(curbuf->b_p_tags);\n\t    case PV_TC:   return (char_u *)&(curbuf->b_p_tc);\n            case PV_SISO: return (char_u *)&(curwin->w_p_siso);\n            case PV_SO:   return (char_u *)&(curwin->w_p_so);\n#ifdef FEAT_FIND_ID\n\t    case PV_DEF:  return (char_u *)&(curbuf->b_p_def);\n\t    case PV_INC:  return (char_u *)&(curbuf->b_p_inc);\n#endif\n\t    case PV_DICT: return (char_u *)&(curbuf->b_p_dict);\n\t    case PV_TSR:  return (char_u *)&(curbuf->b_p_tsr);\n#ifdef FEAT_COMPL_FUNC\n\t    case PV_TSRFU: return (char_u *)&(curbuf->b_p_tsrfu);\n#endif\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n\t    case PV_BEXPR: return (char_u *)&(curbuf->b_p_bexpr);\n#endif\n#if defined(FEAT_CRYPT)\n\t    case PV_CM:\t  return (char_u *)&(curbuf->b_p_cm);\n#endif\n#ifdef FEAT_LINEBREAK\n\t    case PV_SBR:  return (char_u *)&(curwin->w_p_sbr);\n#endif\n#ifdef FEAT_STL_OPT\n\t    case PV_STL:  return (char_u *)&(curwin->w_p_stl);\n#endif\n\t    case PV_UL:   return (char_u *)&(curbuf->b_p_ul);\n#ifdef FEAT_LISP\n\t    case PV_LW:   return (char_u *)&(curbuf->b_p_lw);\n#endif\n\t    case PV_BKC:  return (char_u *)&(curbuf->b_p_bkc);\n\t    case PV_MENC: return (char_u *)&(curbuf->b_p_menc);\n\t    case PV_LCS:  return (char_u *)&(curwin->w_p_lcs);\n\t    case PV_VE:\t  return (char_u *)&(curwin->w_p_ve);\n\n\t}\n\treturn NULL; // \"cannot happen\"\n    }\n    return get_varp(p);\n}\n\n/*\n * Get pointer to option variable at 'opt_idx', depending on local or global\n * scope.\n */\n    char_u *\nget_option_varp_scope(int opt_idx, int scope)\n{\n    return get_varp_scope(&(options[opt_idx]), scope);\n}\n\n/*\n * Get pointer to option variable.\n */\n    static char_u *\nget_varp(struct vimoption *p)\n{\n    // hidden option, always return NULL\n    if (p->var == NULL)\n\treturn NULL;\n\n    switch ((int)p->indir)\n    {\n\tcase PV_NONE:\treturn p->var;\n\n\t// global option with local value: use local value if it's been set\n\tcase PV_EP:\treturn *curbuf->b_p_ep != NUL\n\t\t\t\t    ? (char_u *)&curbuf->b_p_ep : p->var;\n\tcase PV_KP:\treturn *curbuf->b_p_kp != NUL\n\t\t\t\t    ? (char_u *)&curbuf->b_p_kp : p->var;\n\tcase PV_PATH:\treturn *curbuf->b_p_path != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_path) : p->var;\n\tcase PV_AR:\treturn curbuf->b_p_ar >= 0\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_ar) : p->var;\n\tcase PV_TAGS:\treturn *curbuf->b_p_tags != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_tags) : p->var;\n\tcase PV_TC:\treturn *curbuf->b_p_tc != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_tc) : p->var;\n\tcase PV_BKC:\treturn *curbuf->b_p_bkc != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_bkc) : p->var;\n\tcase PV_SISO:\treturn curwin->w_p_siso >= 0\n\t\t\t\t    ? (char_u *)&(curwin->w_p_siso) : p->var;\n\tcase PV_SO:\treturn curwin->w_p_so >= 0\n\t\t\t\t    ? (char_u *)&(curwin->w_p_so) : p->var;\n#ifdef FEAT_FIND_ID\n\tcase PV_DEF:\treturn *curbuf->b_p_def != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_def) : p->var;\n\tcase PV_INC:\treturn *curbuf->b_p_inc != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_inc) : p->var;\n#endif\n\tcase PV_DICT:\treturn *curbuf->b_p_dict != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_dict) : p->var;\n\tcase PV_TSR:\treturn *curbuf->b_p_tsr != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_tsr) : p->var;\n#ifdef FEAT_COMPL_FUNC\n\tcase PV_TSRFU:\treturn *curbuf->b_p_tsrfu != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_tsrfu) : p->var;\n#endif\n\tcase PV_FP:\treturn *curbuf->b_p_fp != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_fp) : p->var;\n#ifdef FEAT_QUICKFIX\n\tcase PV_EFM:\treturn *curbuf->b_p_efm != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_efm) : p->var;\n\tcase PV_GP:\treturn *curbuf->b_p_gp != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_gp) : p->var;\n\tcase PV_MP:\treturn *curbuf->b_p_mp != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_mp) : p->var;\n#endif\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n\tcase PV_BEXPR:\treturn *curbuf->b_p_bexpr != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_bexpr) : p->var;\n#endif\n#if defined(FEAT_CRYPT)\n\tcase PV_CM:\treturn *curbuf->b_p_cm != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_cm) : p->var;\n#endif\n#ifdef FEAT_LINEBREAK\n\tcase PV_SBR:\treturn *curwin->w_p_sbr != NUL\n\t\t\t\t    ? (char_u *)&(curwin->w_p_sbr) : p->var;\n#endif\n#ifdef FEAT_STL_OPT\n\tcase PV_STL:\treturn *curwin->w_p_stl != NUL\n\t\t\t\t    ? (char_u *)&(curwin->w_p_stl) : p->var;\n#endif\n\tcase PV_UL:\treturn curbuf->b_p_ul != NO_LOCAL_UNDOLEVEL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_ul) : p->var;\n#ifdef FEAT_LISP\n\tcase PV_LW:\treturn *curbuf->b_p_lw != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_lw) : p->var;\n#endif\n\tcase PV_MENC:\treturn *curbuf->b_p_menc != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_menc) : p->var;\n#ifdef FEAT_ARABIC\n\tcase PV_ARAB:\treturn (char_u *)&(curwin->w_p_arab);\n#endif\n\tcase PV_LIST:\treturn (char_u *)&(curwin->w_p_list);\n\tcase PV_LCS:\treturn *curwin->w_p_lcs != NUL\n\t\t\t\t    ? (char_u *)&(curwin->w_p_lcs) : p->var;\n\tcase PV_VE:\treturn *curwin->w_p_ve != NUL\n\t\t\t\t    ? (char_u *)&(curwin->w_p_ve) : p->var;\n#ifdef FEAT_SPELL\n\tcase PV_SPELL:\treturn (char_u *)&(curwin->w_p_spell);\n#endif\n#ifdef FEAT_SYN_HL\n\tcase PV_CUC:\treturn (char_u *)&(curwin->w_p_cuc);\n\tcase PV_CUL:\treturn (char_u *)&(curwin->w_p_cul);\n\tcase PV_CULOPT:\treturn (char_u *)&(curwin->w_p_culopt);\n\tcase PV_CC:\treturn (char_u *)&(curwin->w_p_cc);\n#endif\n#ifdef FEAT_DIFF\n\tcase PV_DIFF:\treturn (char_u *)&(curwin->w_p_diff);\n#endif\n#ifdef FEAT_FOLDING\n\tcase PV_FDC:\treturn (char_u *)&(curwin->w_p_fdc);\n\tcase PV_FEN:\treturn (char_u *)&(curwin->w_p_fen);\n\tcase PV_FDI:\treturn (char_u *)&(curwin->w_p_fdi);\n\tcase PV_FDL:\treturn (char_u *)&(curwin->w_p_fdl);\n\tcase PV_FDM:\treturn (char_u *)&(curwin->w_p_fdm);\n\tcase PV_FML:\treturn (char_u *)&(curwin->w_p_fml);\n\tcase PV_FDN:\treturn (char_u *)&(curwin->w_p_fdn);\n# ifdef FEAT_EVAL\n\tcase PV_FDE:\treturn (char_u *)&(curwin->w_p_fde);\n\tcase PV_FDT:\treturn (char_u *)&(curwin->w_p_fdt);\n# endif\n\tcase PV_FMR:\treturn (char_u *)&(curwin->w_p_fmr);\n#endif\n\tcase PV_NU:\treturn (char_u *)&(curwin->w_p_nu);\n\tcase PV_RNU:\treturn (char_u *)&(curwin->w_p_rnu);\n#ifdef FEAT_LINEBREAK\n\tcase PV_NUW:\treturn (char_u *)&(curwin->w_p_nuw);\n#endif\n\tcase PV_WFH:\treturn (char_u *)&(curwin->w_p_wfh);\n\tcase PV_WFW:\treturn (char_u *)&(curwin->w_p_wfw);\n#if defined(FEAT_QUICKFIX)\n\tcase PV_PVW:\treturn (char_u *)&(curwin->w_p_pvw);\n#endif\n#ifdef FEAT_RIGHTLEFT\n\tcase PV_RL:\treturn (char_u *)&(curwin->w_p_rl);\n\tcase PV_RLC:\treturn (char_u *)&(curwin->w_p_rlc);\n#endif\n\tcase PV_SCROLL:\treturn (char_u *)&(curwin->w_p_scr);\n\tcase PV_WRAP:\treturn (char_u *)&(curwin->w_p_wrap);\n#ifdef FEAT_LINEBREAK\n\tcase PV_LBR:\treturn (char_u *)&(curwin->w_p_lbr);\n\tcase PV_BRI:\treturn (char_u *)&(curwin->w_p_bri);\n\tcase PV_BRIOPT: return (char_u *)&(curwin->w_p_briopt);\n#endif\n\tcase PV_WCR:\treturn (char_u *)&(curwin->w_p_wcr);\n\tcase PV_SCBIND: return (char_u *)&(curwin->w_p_scb);\n\tcase PV_CRBIND: return (char_u *)&(curwin->w_p_crb);\n#ifdef FEAT_CONCEAL\n\tcase PV_COCU:   return (char_u *)&(curwin->w_p_cocu);\n\tcase PV_COLE:   return (char_u *)&(curwin->w_p_cole);\n#endif\n#ifdef FEAT_TERMINAL\n\tcase PV_TWK:    return (char_u *)&(curwin->w_p_twk);\n\tcase PV_TWS:    return (char_u *)&(curwin->w_p_tws);\n\tcase PV_TWSL:\treturn (char_u *)&(curbuf->b_p_twsl);\n#endif\n\n\tcase PV_AI:\treturn (char_u *)&(curbuf->b_p_ai);\n\tcase PV_BIN:\treturn (char_u *)&(curbuf->b_p_bin);\n\tcase PV_BOMB:\treturn (char_u *)&(curbuf->b_p_bomb);\n\tcase PV_BH:\treturn (char_u *)&(curbuf->b_p_bh);\n\tcase PV_BT:\treturn (char_u *)&(curbuf->b_p_bt);\n\tcase PV_BL:\treturn (char_u *)&(curbuf->b_p_bl);\n\tcase PV_CI:\treturn (char_u *)&(curbuf->b_p_ci);\n#ifdef FEAT_CINDENT\n\tcase PV_CIN:\treturn (char_u *)&(curbuf->b_p_cin);\n\tcase PV_CINK:\treturn (char_u *)&(curbuf->b_p_cink);\n\tcase PV_CINO:\treturn (char_u *)&(curbuf->b_p_cino);\n#endif\n#if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT)\n\tcase PV_CINW:\treturn (char_u *)&(curbuf->b_p_cinw);\n#endif\n\tcase PV_COM:\treturn (char_u *)&(curbuf->b_p_com);\n#ifdef FEAT_FOLDING\n\tcase PV_CMS:\treturn (char_u *)&(curbuf->b_p_cms);\n#endif\n\tcase PV_CPT:\treturn (char_u *)&(curbuf->b_p_cpt);\n#ifdef BACKSLASH_IN_FILENAME\n\tcase PV_CSL:\treturn (char_u *)&(curbuf->b_p_csl);\n#endif\n#ifdef FEAT_COMPL_FUNC\n\tcase PV_CFU:\treturn (char_u *)&(curbuf->b_p_cfu);\n\tcase PV_OFU:\treturn (char_u *)&(curbuf->b_p_ofu);\n#endif\n#ifdef FEAT_EVAL\n\tcase PV_TFU:\treturn (char_u *)&(curbuf->b_p_tfu);\n#endif\n\tcase PV_EOL:\treturn (char_u *)&(curbuf->b_p_eol);\n\tcase PV_FIXEOL:\treturn (char_u *)&(curbuf->b_p_fixeol);\n\tcase PV_ET:\treturn (char_u *)&(curbuf->b_p_et);\n\tcase PV_FENC:\treturn (char_u *)&(curbuf->b_p_fenc);\n\tcase PV_FF:\treturn (char_u *)&(curbuf->b_p_ff);\n\tcase PV_FT:\treturn (char_u *)&(curbuf->b_p_ft);\n\tcase PV_FO:\treturn (char_u *)&(curbuf->b_p_fo);\n\tcase PV_FLP:\treturn (char_u *)&(curbuf->b_p_flp);\n\tcase PV_IMI:\treturn (char_u *)&(curbuf->b_p_iminsert);\n\tcase PV_IMS:\treturn (char_u *)&(curbuf->b_p_imsearch);\n\tcase PV_INF:\treturn (char_u *)&(curbuf->b_p_inf);\n\tcase PV_ISK:\treturn (char_u *)&(curbuf->b_p_isk);\n#ifdef FEAT_FIND_ID\n# ifdef FEAT_EVAL\n\tcase PV_INEX:\treturn (char_u *)&(curbuf->b_p_inex);\n# endif\n#endif\n#if defined(FEAT_CINDENT) && defined(FEAT_EVAL)\n\tcase PV_INDE:\treturn (char_u *)&(curbuf->b_p_inde);\n\tcase PV_INDK:\treturn (char_u *)&(curbuf->b_p_indk);\n#endif\n#ifdef FEAT_EVAL\n\tcase PV_FEX:\treturn (char_u *)&(curbuf->b_p_fex);\n#endif\n#ifdef FEAT_CRYPT\n\tcase PV_KEY:\treturn (char_u *)&(curbuf->b_p_key);\n#endif\n#ifdef FEAT_LISP\n\tcase PV_LISP:\treturn (char_u *)&(curbuf->b_p_lisp);\n#endif\n\tcase PV_ML:\treturn (char_u *)&(curbuf->b_p_ml);\n\tcase PV_MPS:\treturn (char_u *)&(curbuf->b_p_mps);\n\tcase PV_MA:\treturn (char_u *)&(curbuf->b_p_ma);\n\tcase PV_MOD:\treturn (char_u *)&(curbuf->b_changed);\n\tcase PV_NF:\treturn (char_u *)&(curbuf->b_p_nf);\n\tcase PV_PI:\treturn (char_u *)&(curbuf->b_p_pi);\n#ifdef FEAT_TEXTOBJ\n\tcase PV_QE:\treturn (char_u *)&(curbuf->b_p_qe);\n#endif\n\tcase PV_RO:\treturn (char_u *)&(curbuf->b_p_ro);\n#ifdef FEAT_SMARTINDENT\n\tcase PV_SI:\treturn (char_u *)&(curbuf->b_p_si);\n#endif\n\tcase PV_SN:\treturn (char_u *)&(curbuf->b_p_sn);\n\tcase PV_STS:\treturn (char_u *)&(curbuf->b_p_sts);\n#ifdef FEAT_SEARCHPATH\n\tcase PV_SUA:\treturn (char_u *)&(curbuf->b_p_sua);\n#endif\n\tcase PV_SWF:\treturn (char_u *)&(curbuf->b_p_swf);\n#ifdef FEAT_SYN_HL\n\tcase PV_SMC:\treturn (char_u *)&(curbuf->b_p_smc);\n\tcase PV_SYN:\treturn (char_u *)&(curbuf->b_p_syn);\n#endif\n#ifdef FEAT_SPELL\n\tcase PV_SPC:\treturn (char_u *)&(curwin->w_s->b_p_spc);\n\tcase PV_SPF:\treturn (char_u *)&(curwin->w_s->b_p_spf);\n\tcase PV_SPL:\treturn (char_u *)&(curwin->w_s->b_p_spl);\n\tcase PV_SPO:\treturn (char_u *)&(curwin->w_s->b_p_spo);\n#endif\n\tcase PV_SW:\treturn (char_u *)&(curbuf->b_p_sw);\n\tcase PV_TS:\treturn (char_u *)&(curbuf->b_p_ts);\n\tcase PV_TW:\treturn (char_u *)&(curbuf->b_p_tw);\n\tcase PV_TX:\treturn (char_u *)&(curbuf->b_p_tx);\n#ifdef FEAT_PERSISTENT_UNDO\n\tcase PV_UDF:\treturn (char_u *)&(curbuf->b_p_udf);\n#endif\n\tcase PV_WM:\treturn (char_u *)&(curbuf->b_p_wm);\n#ifdef FEAT_KEYMAP\n\tcase PV_KMAP:\treturn (char_u *)&(curbuf->b_p_keymap);\n#endif\n#ifdef FEAT_SIGNS\n\tcase PV_SCL:\treturn (char_u *)&(curwin->w_p_scl);\n#endif\n#ifdef FEAT_VARTABS\n\tcase PV_VSTS:\treturn (char_u *)&(curbuf->b_p_vsts);\n\tcase PV_VTS:\treturn (char_u *)&(curbuf->b_p_vts);\n#endif\n\tdefault:\tiemsg(_(e_get_varp_error));\n    }\n    // always return a valid pointer to avoid a crash!\n    return (char_u *)&(curbuf->b_p_wm);\n}\n\n/*\n * Return a pointer to the variable for option at 'opt_idx'\n */\n    char_u *\nget_option_var(int opt_idx)\n{\n    return options[opt_idx].var;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return the full name of the option at 'opt_idx'\n */\n    char_u *\nget_option_fullname(int opt_idx)\n{\n    return (char_u *)options[opt_idx].fullname;\n}\n#endif\n\n/*\n * Get the value of 'equalprg', either the buffer-local one or the global one.\n */\n    char_u *\nget_equalprg(void)\n{\n    if (*curbuf->b_p_ep == NUL)\n\treturn p_ep;\n    return curbuf->b_p_ep;\n}\n\n/*\n * Copy options from one window to another.\n * Used when splitting a window.\n */\n    void\nwin_copy_options(win_T *wp_from, win_T *wp_to)\n{\n    copy_winopt(&wp_from->w_onebuf_opt, &wp_to->w_onebuf_opt);\n    copy_winopt(&wp_from->w_allbuf_opt, &wp_to->w_allbuf_opt);\n    after_copy_winopt(wp_to);\n}\n\n/*\n * After copying window options: update variables depending on options.\n */\n    void\nafter_copy_winopt(win_T *wp UNUSED)\n{\n#ifdef FEAT_LINEBREAK\n    briopt_check(wp);\n#endif\n#ifdef FEAT_SYN_HL\n    fill_culopt_flags(NULL, wp);\n    check_colorcolumn(wp);\n#endif\n    set_chars_option(wp, &wp->w_p_lcs);\n}\n\n/*\n * Copy the options from one winopt_T to another.\n * Doesn't free the old option values in \"to\", use clear_winopt() for that.\n * The 'scroll' option is not copied, because it depends on the window height.\n * The 'previewwindow' option is reset, there can be only one preview window.\n */\n    void\ncopy_winopt(winopt_T *from, winopt_T *to)\n{\n#ifdef FEAT_ARABIC\n    to->wo_arab = from->wo_arab;\n#endif\n    to->wo_list = from->wo_list;\n    to->wo_lcs = vim_strsave(from->wo_lcs);\n    to->wo_nu = from->wo_nu;\n    to->wo_rnu = from->wo_rnu;\n    to->wo_ve = vim_strsave(from->wo_ve);\n    to->wo_ve_flags = from->wo_ve_flags;\n#ifdef FEAT_LINEBREAK\n    to->wo_nuw = from->wo_nuw;\n#endif\n#ifdef FEAT_RIGHTLEFT\n    to->wo_rl  = from->wo_rl;\n    to->wo_rlc = vim_strsave(from->wo_rlc);\n#endif\n#ifdef FEAT_LINEBREAK\n    to->wo_sbr = vim_strsave(from->wo_sbr);\n#endif\n#ifdef FEAT_STL_OPT\n    to->wo_stl = vim_strsave(from->wo_stl);\n#endif\n    to->wo_wrap = from->wo_wrap;\n#ifdef FEAT_DIFF\n    to->wo_wrap_save = from->wo_wrap_save;\n#endif\n#ifdef FEAT_LINEBREAK\n    to->wo_lbr = from->wo_lbr;\n    to->wo_bri = from->wo_bri;\n    to->wo_briopt = vim_strsave(from->wo_briopt);\n#endif\n    to->wo_wcr = vim_strsave(from->wo_wcr);\n    to->wo_scb = from->wo_scb;\n    to->wo_scb_save = from->wo_scb_save;\n    to->wo_crb = from->wo_crb;\n    to->wo_crb_save = from->wo_crb_save;\n#ifdef FEAT_SPELL\n    to->wo_spell = from->wo_spell;\n#endif\n#ifdef FEAT_SYN_HL\n    to->wo_cuc = from->wo_cuc;\n    to->wo_cul = from->wo_cul;\n    to->wo_culopt = vim_strsave(from->wo_culopt);\n    to->wo_cc = vim_strsave(from->wo_cc);\n#endif\n#ifdef FEAT_DIFF\n    to->wo_diff = from->wo_diff;\n    to->wo_diff_saved = from->wo_diff_saved;\n#endif\n#ifdef FEAT_CONCEAL\n    to->wo_cocu = vim_strsave(from->wo_cocu);\n    to->wo_cole = from->wo_cole;\n#endif\n#ifdef FEAT_TERMINAL\n    to->wo_twk = vim_strsave(from->wo_twk);\n    to->wo_tws = vim_strsave(from->wo_tws);\n#endif\n#ifdef FEAT_FOLDING\n    to->wo_fdc = from->wo_fdc;\n    to->wo_fdc_save = from->wo_fdc_save;\n    to->wo_fen = from->wo_fen;\n    to->wo_fen_save = from->wo_fen_save;\n    to->wo_fdi = vim_strsave(from->wo_fdi);\n    to->wo_fml = from->wo_fml;\n    to->wo_fdl = from->wo_fdl;\n    to->wo_fdl_save = from->wo_fdl_save;\n    to->wo_fdm = vim_strsave(from->wo_fdm);\n    to->wo_fdm_save = from->wo_diff_saved\n\t\t\t      ? vim_strsave(from->wo_fdm_save) : empty_option;\n    to->wo_fdn = from->wo_fdn;\n# ifdef FEAT_EVAL\n    to->wo_fde = vim_strsave(from->wo_fde);\n    to->wo_fdt = vim_strsave(from->wo_fdt);\n# endif\n    to->wo_fmr = vim_strsave(from->wo_fmr);\n#endif\n#ifdef FEAT_SIGNS\n    to->wo_scl = vim_strsave(from->wo_scl);\n#endif\n\n#ifdef FEAT_EVAL\n    // Copy the script context so that we know where the value was last set.\n    mch_memmove(to->wo_script_ctx, from->wo_script_ctx,\n\t\t\t\t\t\t    sizeof(to->wo_script_ctx));\n#endif\n    check_winopt(to);\t\t// don't want NULL pointers\n}\n\n/*\n * Check string options in a window for a NULL value.\n */\n    static void\ncheck_win_options(win_T *win)\n{\n    check_winopt(&win->w_onebuf_opt);\n    check_winopt(&win->w_allbuf_opt);\n}\n\n/*\n * Check for NULL pointers in a winopt_T and replace them with empty_option.\n */\n    static void\ncheck_winopt(winopt_T *wop UNUSED)\n{\n#ifdef FEAT_FOLDING\n    check_string_option(&wop->wo_fdi);\n    check_string_option(&wop->wo_fdm);\n    check_string_option(&wop->wo_fdm_save);\n# ifdef FEAT_EVAL\n    check_string_option(&wop->wo_fde);\n    check_string_option(&wop->wo_fdt);\n# endif\n    check_string_option(&wop->wo_fmr);\n#endif\n#ifdef FEAT_SIGNS\n    check_string_option(&wop->wo_scl);\n#endif\n#ifdef FEAT_RIGHTLEFT\n    check_string_option(&wop->wo_rlc);\n#endif\n#ifdef FEAT_LINEBREAK\n    check_string_option(&wop->wo_sbr);\n#endif\n#ifdef FEAT_STL_OPT\n    check_string_option(&wop->wo_stl);\n#endif\n#ifdef FEAT_SYN_HL\n    check_string_option(&wop->wo_culopt);\n    check_string_option(&wop->wo_cc);\n#endif\n#ifdef FEAT_CONCEAL\n    check_string_option(&wop->wo_cocu);\n#endif\n#ifdef FEAT_TERMINAL\n    check_string_option(&wop->wo_twk);\n    check_string_option(&wop->wo_tws);\n#endif\n#ifdef FEAT_LINEBREAK\n    check_string_option(&wop->wo_briopt);\n#endif\n    check_string_option(&wop->wo_wcr);\n    check_string_option(&wop->wo_lcs);\n    check_string_option(&wop->wo_ve);\n}\n\n/*\n * Free the allocated memory inside a winopt_T.\n */\n    void\nclear_winopt(winopt_T *wop UNUSED)\n{\n#ifdef FEAT_FOLDING\n    clear_string_option(&wop->wo_fdi);\n    clear_string_option(&wop->wo_fdm);\n    clear_string_option(&wop->wo_fdm_save);\n# ifdef FEAT_EVAL\n    clear_string_option(&wop->wo_fde);\n    clear_string_option(&wop->wo_fdt);\n# endif\n    clear_string_option(&wop->wo_fmr);\n#endif\n#ifdef FEAT_SIGNS\n    clear_string_option(&wop->wo_scl);\n#endif\n#ifdef FEAT_LINEBREAK\n    clear_string_option(&wop->wo_briopt);\n#endif\n    clear_string_option(&wop->wo_wcr);\n#ifdef FEAT_RIGHTLEFT\n    clear_string_option(&wop->wo_rlc);\n#endif\n#ifdef FEAT_LINEBREAK\n    clear_string_option(&wop->wo_sbr);\n#endif\n#ifdef FEAT_STL_OPT\n    clear_string_option(&wop->wo_stl);\n#endif\n#ifdef FEAT_SYN_HL\n    clear_string_option(&wop->wo_culopt);\n    clear_string_option(&wop->wo_cc);\n#endif\n#ifdef FEAT_CONCEAL\n    clear_string_option(&wop->wo_cocu);\n#endif\n#ifdef FEAT_TERMINAL\n    clear_string_option(&wop->wo_twk);\n    clear_string_option(&wop->wo_tws);\n#endif\n    clear_string_option(&wop->wo_lcs);\n    clear_string_option(&wop->wo_ve);\n}\n\n#ifdef FEAT_EVAL\n// Index into the options table for a buffer-local option enum.\nstatic int buf_opt_idx[BV_COUNT];\n# define COPY_OPT_SCTX(buf, bv) buf->b_p_script_ctx[bv] = options[buf_opt_idx[bv]].script_ctx\n\n/*\n * Initialize buf_opt_idx[] if not done already.\n */\n    static void\ninit_buf_opt_idx(void)\n{\n    static int did_init_buf_opt_idx = FALSE;\n    int i;\n\n    if (did_init_buf_opt_idx)\n\treturn;\n    did_init_buf_opt_idx = TRUE;\n    for (i = 0; !istermoption_idx(i); i++)\n\tif (options[i].indir & PV_BUF)\n\t    buf_opt_idx[options[i].indir & PV_MASK] = i;\n}\n#else\n# define COPY_OPT_SCTX(buf, bv)\n#endif\n\n/*\n * Copy global option values to local options for one buffer.\n * Used when creating a new buffer and sometimes when entering a buffer.\n * flags:\n * BCO_ENTER\tWe will enter the buffer \"buf\".\n * BCO_ALWAYS\tAlways copy the options, but only set b_p_initialized when\n *\t\tappropriate.\n * BCO_NOHELP\tDon't copy the values to a help buffer.\n */\n    void\nbuf_copy_options(buf_T *buf, int flags)\n{\n    int\t\tshould_copy = TRUE;\n    char_u\t*save_p_isk = NULL;\t    // init for GCC\n    int\t\tdont_do_help;\n    int\t\tdid_isk = FALSE;\n\n    /*\n     * Skip this when the option defaults have not been set yet.  Happens when\n     * main() allocates the first buffer.\n     */\n    if (p_cpo != NULL)\n    {\n\t/*\n\t * Always copy when entering and 'cpo' contains 'S'.\n\t * Don't copy when already initialized.\n\t * Don't copy when 'cpo' contains 's' and not entering.\n\t * 'S'\tBCO_ENTER  initialized\t's'  should_copy\n\t * yes\t  yes\t       X\t X\tTRUE\n\t * yes\t  no\t      yes\t X\tFALSE\n\t * no\t   X\t      yes\t X\tFALSE\n\t *  X\t  no\t      no\tyes\tFALSE\n\t *  X\t  no\t      no\tno\tTRUE\n\t * no\t  yes\t      no\t X\tTRUE\n\t */\n\tif ((vim_strchr(p_cpo, CPO_BUFOPTGLOB) == NULL || !(flags & BCO_ENTER))\n\t\t&& (buf->b_p_initialized\n\t\t    || (!(flags & BCO_ENTER)\n\t\t\t&& vim_strchr(p_cpo, CPO_BUFOPT) != NULL)))\n\t    should_copy = FALSE;\n\n\tif (should_copy || (flags & BCO_ALWAYS))\n\t{\n#ifdef FEAT_EVAL\n\t    CLEAR_FIELD(buf->b_p_script_ctx);\n\t    init_buf_opt_idx();\n#endif\n\t    // Don't copy the options specific to a help buffer when\n\t    // BCO_NOHELP is given or the options were initialized already\n\t    // (jumping back to a help file with CTRL-T or CTRL-O)\n\t    dont_do_help = ((flags & BCO_NOHELP) && buf->b_help)\n\t\t\t\t\t\t       || buf->b_p_initialized;\n\t    if (dont_do_help)\t\t// don't free b_p_isk\n\t    {\n\t\tsave_p_isk = buf->b_p_isk;\n\t\tbuf->b_p_isk = NULL;\n\t    }\n\t    /*\n\t     * Always free the allocated strings.  If not already initialized,\n\t     * reset 'readonly' and copy 'fileformat'.\n\t     */\n\t    if (!buf->b_p_initialized)\n\t    {\n\t\tfree_buf_options(buf, TRUE);\n\t\tbuf->b_p_ro = FALSE;\t\t// don't copy readonly\n\t\tbuf->b_p_tx = p_tx;\n\t\tbuf->b_p_fenc = vim_strsave(p_fenc);\n\t\tswitch (*p_ffs)\n\t\t{\n\t\t    case 'm':\n\t\t\tbuf->b_p_ff = vim_strsave((char_u *)FF_MAC); break;\n\t\t    case 'd':\n\t\t\tbuf->b_p_ff = vim_strsave((char_u *)FF_DOS); break;\n\t\t    case 'u':\n\t\t\tbuf->b_p_ff = vim_strsave((char_u *)FF_UNIX); break;\n\t\t    default:\n\t\t\tbuf->b_p_ff = vim_strsave(p_ff);\n\t\t}\n\t\tif (buf->b_p_ff != NULL)\n\t\t    buf->b_start_ffc = *buf->b_p_ff;\n\t\tbuf->b_p_bh = empty_option;\n\t\tbuf->b_p_bt = empty_option;\n\t    }\n\t    else\n\t\tfree_buf_options(buf, FALSE);\n\n\t    buf->b_p_ai = p_ai;\n\t    COPY_OPT_SCTX(buf, BV_AI);\n\t    buf->b_p_ai_nopaste = p_ai_nopaste;\n\t    buf->b_p_sw = p_sw;\n\t    COPY_OPT_SCTX(buf, BV_SW);\n\t    buf->b_p_tw = p_tw;\n\t    COPY_OPT_SCTX(buf, BV_TW);\n\t    buf->b_p_tw_nopaste = p_tw_nopaste;\n\t    buf->b_p_tw_nobin = p_tw_nobin;\n\t    buf->b_p_wm = p_wm;\n\t    COPY_OPT_SCTX(buf, BV_WM);\n\t    buf->b_p_wm_nopaste = p_wm_nopaste;\n\t    buf->b_p_wm_nobin = p_wm_nobin;\n\t    buf->b_p_bin = p_bin;\n\t    COPY_OPT_SCTX(buf, BV_BIN);\n\t    buf->b_p_bomb = p_bomb;\n\t    COPY_OPT_SCTX(buf, BV_BOMB);\n\t    buf->b_p_fixeol = p_fixeol;\n\t    COPY_OPT_SCTX(buf, BV_FIXEOL);\n\t    buf->b_p_et = p_et;\n\t    COPY_OPT_SCTX(buf, BV_ET);\n\t    buf->b_p_et_nobin = p_et_nobin;\n\t    buf->b_p_et_nopaste = p_et_nopaste;\n\t    buf->b_p_ml = p_ml;\n\t    COPY_OPT_SCTX(buf, BV_ML);\n\t    buf->b_p_ml_nobin = p_ml_nobin;\n\t    buf->b_p_inf = p_inf;\n\t    COPY_OPT_SCTX(buf, BV_INF);\n\t    if (cmdmod.cmod_flags & CMOD_NOSWAPFILE)\n\t\tbuf->b_p_swf = FALSE;\n\t    else\n\t    {\n\t\tbuf->b_p_swf = p_swf;\n\t\tCOPY_OPT_SCTX(buf, BV_SWF);\n\t    }\n\t    buf->b_p_cpt = vim_strsave(p_cpt);\n\t    COPY_OPT_SCTX(buf, BV_CPT);\n#ifdef BACKSLASH_IN_FILENAME\n\t    buf->b_p_csl = vim_strsave(p_csl);\n\t    COPY_OPT_SCTX(buf, BV_CSL);\n#endif\n#ifdef FEAT_COMPL_FUNC\n\t    buf->b_p_cfu = vim_strsave(p_cfu);\n\t    COPY_OPT_SCTX(buf, BV_CFU);\n\t    set_buflocal_cfu_callback(buf);\n\t    buf->b_p_ofu = vim_strsave(p_ofu);\n\t    COPY_OPT_SCTX(buf, BV_OFU);\n\t    set_buflocal_ofu_callback(buf);\n#endif\n#ifdef FEAT_EVAL\n\t    buf->b_p_tfu = vim_strsave(p_tfu);\n\t    COPY_OPT_SCTX(buf, BV_TFU);\n\t    set_buflocal_tfu_callback(buf);\n#endif\n\t    buf->b_p_sts = p_sts;\n\t    COPY_OPT_SCTX(buf, BV_STS);\n\t    buf->b_p_sts_nopaste = p_sts_nopaste;\n#ifdef FEAT_VARTABS\n\t    buf->b_p_vsts = vim_strsave(p_vsts);\n\t    COPY_OPT_SCTX(buf, BV_VSTS);\n\t    if (p_vsts && p_vsts != empty_option)\n\t\t(void)tabstop_set(p_vsts, &buf->b_p_vsts_array);\n\t    else\n\t\tbuf->b_p_vsts_array = 0;\n\t    buf->b_p_vsts_nopaste = p_vsts_nopaste\n\t\t\t\t ? vim_strsave(p_vsts_nopaste) : NULL;\n#endif\n\t    buf->b_p_sn = p_sn;\n\t    COPY_OPT_SCTX(buf, BV_SN);\n\t    buf->b_p_com = vim_strsave(p_com);\n\t    COPY_OPT_SCTX(buf, BV_COM);\n#ifdef FEAT_FOLDING\n\t    buf->b_p_cms = vim_strsave(p_cms);\n\t    COPY_OPT_SCTX(buf, BV_CMS);\n#endif\n\t    buf->b_p_fo = vim_strsave(p_fo);\n\t    COPY_OPT_SCTX(buf, BV_FO);\n\t    buf->b_p_flp = vim_strsave(p_flp);\n\t    COPY_OPT_SCTX(buf, BV_FLP);\n\t    // NOTE: Valgrind may report a bogus memory leak for 'nrformats'\n\t    // when it is set to 8 bytes in defaults.vim.\n\t    buf->b_p_nf = vim_strsave(p_nf);\n\t    COPY_OPT_SCTX(buf, BV_NF);\n\t    buf->b_p_mps = vim_strsave(p_mps);\n\t    COPY_OPT_SCTX(buf, BV_MPS);\n#ifdef FEAT_SMARTINDENT\n\t    buf->b_p_si = p_si;\n\t    COPY_OPT_SCTX(buf, BV_SI);\n#endif\n\t    buf->b_p_ci = p_ci;\n\t    COPY_OPT_SCTX(buf, BV_CI);\n#ifdef FEAT_CINDENT\n\t    buf->b_p_cin = p_cin;\n\t    COPY_OPT_SCTX(buf, BV_CIN);\n\t    buf->b_p_cink = vim_strsave(p_cink);\n\t    COPY_OPT_SCTX(buf, BV_CINK);\n\t    buf->b_p_cino = vim_strsave(p_cino);\n\t    COPY_OPT_SCTX(buf, BV_CINO);\n#endif\n\t    // Don't copy 'filetype', it must be detected\n\t    buf->b_p_ft = empty_option;\n\t    buf->b_p_pi = p_pi;\n\t    COPY_OPT_SCTX(buf, BV_PI);\n#if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT)\n\t    buf->b_p_cinw = vim_strsave(p_cinw);\n\t    COPY_OPT_SCTX(buf, BV_CINW);\n#endif\n#ifdef FEAT_LISP\n\t    buf->b_p_lisp = p_lisp;\n\t    COPY_OPT_SCTX(buf, BV_LISP);\n#endif\n#ifdef FEAT_SYN_HL\n\t    // Don't copy 'syntax', it must be set\n\t    buf->b_p_syn = empty_option;\n\t    buf->b_p_smc = p_smc;\n\t    COPY_OPT_SCTX(buf, BV_SMC);\n\t    buf->b_s.b_syn_isk = empty_option;\n#endif\n#ifdef FEAT_SPELL\n\t    buf->b_s.b_p_spc = vim_strsave(p_spc);\n\t    COPY_OPT_SCTX(buf, BV_SPC);\n\t    (void)compile_cap_prog(&buf->b_s);\n\t    buf->b_s.b_p_spf = vim_strsave(p_spf);\n\t    COPY_OPT_SCTX(buf, BV_SPF);\n\t    buf->b_s.b_p_spl = vim_strsave(p_spl);\n\t    COPY_OPT_SCTX(buf, BV_SPL);\n\t    buf->b_s.b_p_spo = vim_strsave(p_spo);\n\t    COPY_OPT_SCTX(buf, BV_SPO);\n#endif\n#if defined(FEAT_CINDENT) && defined(FEAT_EVAL)\n\t    buf->b_p_inde = vim_strsave(p_inde);\n\t    COPY_OPT_SCTX(buf, BV_INDE);\n\t    buf->b_p_indk = vim_strsave(p_indk);\n\t    COPY_OPT_SCTX(buf, BV_INDK);\n#endif\n\t    buf->b_p_fp = empty_option;\n#if defined(FEAT_EVAL)\n\t    buf->b_p_fex = vim_strsave(p_fex);\n\t    COPY_OPT_SCTX(buf, BV_FEX);\n#endif\n#ifdef FEAT_CRYPT\n\t    buf->b_p_key = vim_strsave(p_key);\n\t    COPY_OPT_SCTX(buf, BV_KEY);\n#endif\n#ifdef FEAT_SEARCHPATH\n\t    buf->b_p_sua = vim_strsave(p_sua);\n\t    COPY_OPT_SCTX(buf, BV_SUA);\n#endif\n#ifdef FEAT_KEYMAP\n\t    buf->b_p_keymap = vim_strsave(p_keymap);\n\t    COPY_OPT_SCTX(buf, BV_KMAP);\n\t    buf->b_kmap_state |= KEYMAP_INIT;\n#endif\n#ifdef FEAT_TERMINAL\n\t    buf->b_p_twsl = p_twsl;\n\t    COPY_OPT_SCTX(buf, BV_TWSL);\n#endif\n\t    // This isn't really an option, but copying the langmap and IME\n\t    // state from the current buffer is better than resetting it.\n\t    buf->b_p_iminsert = p_iminsert;\n\t    COPY_OPT_SCTX(buf, BV_IMI);\n\t    buf->b_p_imsearch = p_imsearch;\n\t    COPY_OPT_SCTX(buf, BV_IMS);\n\n\t    // options that are normally global but also have a local value\n\t    // are not copied, start using the global value\n\t    buf->b_p_ar = -1;\n\t    buf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n\t    buf->b_p_bkc = empty_option;\n\t    buf->b_bkc_flags = 0;\n#ifdef FEAT_QUICKFIX\n\t    buf->b_p_gp = empty_option;\n\t    buf->b_p_mp = empty_option;\n\t    buf->b_p_efm = empty_option;\n#endif\n\t    buf->b_p_ep = empty_option;\n\t    buf->b_p_kp = empty_option;\n\t    buf->b_p_path = empty_option;\n\t    buf->b_p_tags = empty_option;\n\t    buf->b_p_tc = empty_option;\n\t    buf->b_tc_flags = 0;\n#ifdef FEAT_FIND_ID\n\t    buf->b_p_def = empty_option;\n\t    buf->b_p_inc = empty_option;\n# ifdef FEAT_EVAL\n\t    buf->b_p_inex = vim_strsave(p_inex);\n\t    COPY_OPT_SCTX(buf, BV_INEX);\n# endif\n#endif\n\t    buf->b_p_dict = empty_option;\n\t    buf->b_p_tsr = empty_option;\n#ifdef FEAT_COMPL_FUNC\n\t    buf->b_p_tsrfu = empty_option;\n#endif\n#ifdef FEAT_TEXTOBJ\n\t    buf->b_p_qe = vim_strsave(p_qe);\n\t    COPY_OPT_SCTX(buf, BV_QE);\n#endif\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n\t    buf->b_p_bexpr = empty_option;\n#endif\n#if defined(FEAT_CRYPT)\n\t    buf->b_p_cm = empty_option;\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t    buf->b_p_udf = p_udf;\n\t    COPY_OPT_SCTX(buf, BV_UDF);\n#endif\n#ifdef FEAT_LISP\n\t    buf->b_p_lw = empty_option;\n#endif\n\t    buf->b_p_menc = empty_option;\n\n\t    /*\n\t     * Don't copy the options set by ex_help(), use the saved values,\n\t     * when going from a help buffer to a non-help buffer.\n\t     * Don't touch these at all when BCO_NOHELP is used and going from\n\t     * or to a help buffer.\n\t     */\n\t    if (dont_do_help)\n\t    {\n\t\tbuf->b_p_isk = save_p_isk;\n#ifdef FEAT_VARTABS\n\t\tif (p_vts && p_vts != empty_option && !buf->b_p_vts_array)\n\t\t    (void)tabstop_set(p_vts, &buf->b_p_vts_array);\n\t\telse\n\t\t    buf->b_p_vts_array = NULL;\n#endif\n\t    }\n\t    else\n\t    {\n\t\tbuf->b_p_isk = vim_strsave(p_isk);\n\t\tCOPY_OPT_SCTX(buf, BV_ISK);\n\t\tdid_isk = TRUE;\n\t\tbuf->b_p_ts = p_ts;\n\t\tCOPY_OPT_SCTX(buf, BV_TS);\n#ifdef FEAT_VARTABS\n\t\tbuf->b_p_vts = vim_strsave(p_vts);\n\t\tCOPY_OPT_SCTX(buf, BV_VTS);\n\t\tif (p_vts && p_vts != empty_option && !buf->b_p_vts_array)\n\t\t    (void)tabstop_set(p_vts, &buf->b_p_vts_array);\n\t\telse\n\t\t    buf->b_p_vts_array = NULL;\n#endif\n\t\tbuf->b_help = FALSE;\n\t\tif (buf->b_p_bt[0] == 'h')\n\t\t    clear_string_option(&buf->b_p_bt);\n\t\tbuf->b_p_ma = p_ma;\n\t\tCOPY_OPT_SCTX(buf, BV_MA);\n\t    }\n\t}\n\n\t/*\n\t * When the options should be copied (ignoring BCO_ALWAYS), set the\n\t * flag that indicates that the options have been initialized.\n\t */\n\tif (should_copy)\n\t    buf->b_p_initialized = TRUE;\n    }\n\n    check_buf_options(buf);\t    // make sure we don't have NULLs\n    if (did_isk)\n\t(void)buf_init_chartab(buf, FALSE);\n}\n\n/*\n * Reset the 'modifiable' option and its default value.\n */\n    void\nreset_modifiable(void)\n{\n    int\t\topt_idx;\n\n    curbuf->b_p_ma = FALSE;\n    p_ma = FALSE;\n    opt_idx = findoption((char_u *)\"ma\");\n    if (opt_idx >= 0)\n\toptions[opt_idx].def_val[VI_DEFAULT] = FALSE;\n}\n\n/*\n * Set the global value for 'iminsert' to the local value.\n */\n    void\nset_iminsert_global(void)\n{\n    p_iminsert = curbuf->b_p_iminsert;\n}\n\n/*\n * Set the global value for 'imsearch' to the local value.\n */\n    void\nset_imsearch_global(void)\n{\n    p_imsearch = curbuf->b_p_imsearch;\n}\n\nstatic int expand_option_idx = -1;\nstatic char_u expand_option_name[5] = {'t', '_', NUL, NUL, NUL};\nstatic int expand_option_flags = 0;\n\n    void\nset_context_in_set_cmd(\n    expand_T\t*xp,\n    char_u\t*arg,\n    int\t\topt_flags)\t// OPT_GLOBAL and/or OPT_LOCAL\n{\n    int\t\tnextchar;\n    long_u\tflags = 0;\t// init for GCC\n    int\t\topt_idx = 0;\t// init for GCC\n    char_u\t*p;\n    char_u\t*s;\n    int\t\tis_term_option = FALSE;\n    int\t\tkey;\n\n    expand_option_flags = opt_flags;\n\n    xp->xp_context = EXPAND_SETTINGS;\n    if (*arg == NUL)\n    {\n\txp->xp_pattern = arg;\n\treturn;\n    }\n    p = arg + STRLEN(arg) - 1;\n    if (*p == ' ' && *(p - 1) != '\\\\')\n    {\n\txp->xp_pattern = p + 1;\n\treturn;\n    }\n    while (p > arg)\n    {\n\ts = p;\n\t// count number of backslashes before ' ' or ','\n\tif (*p == ' ' || *p == ',')\n\t{\n\t    while (s > arg && *(s - 1) == '\\\\')\n\t\t--s;\n\t}\n\t// break at a space with an even number of backslashes\n\tif (*p == ' ' && ((p - s) & 1) == 0)\n\t{\n\t    ++p;\n\t    break;\n\t}\n\t--p;\n    }\n    if (STRNCMP(p, \"no\", 2) == 0 && STRNCMP(p, \"novice\", 6) != 0)\n    {\n\txp->xp_context = EXPAND_BOOL_SETTINGS;\n\tp += 2;\n    }\n    if (STRNCMP(p, \"inv\", 3) == 0)\n    {\n\txp->xp_context = EXPAND_BOOL_SETTINGS;\n\tp += 3;\n    }\n    xp->xp_pattern = arg = p;\n    if (*arg == '<')\n    {\n\twhile (*p != '>')\n\t    if (*p++ == NUL)\t    // expand terminal option name\n\t\treturn;\n\tkey = get_special_key_code(arg + 1);\n\tif (key == 0)\t\t    // unknown name\n\t{\n\t    xp->xp_context = EXPAND_NOTHING;\n\t    return;\n\t}\n\tnextchar = *++p;\n\tis_term_option = TRUE;\n\texpand_option_name[2] = KEY2TERMCAP0(key);\n\texpand_option_name[3] = KEY2TERMCAP1(key);\n    }\n    else\n    {\n\tif (p[0] == 't' && p[1] == '_')\n\t{\n\t    p += 2;\n\t    if (*p != NUL)\n\t\t++p;\n\t    if (*p == NUL)\n\t\treturn;\t\t// expand option name\n\t    nextchar = *++p;\n\t    is_term_option = TRUE;\n\t    expand_option_name[2] = p[-2];\n\t    expand_option_name[3] = p[-1];\n\t}\n\telse\n\t{\n\t    // Allow * wildcard\n\t    while (ASCII_ISALNUM(*p) || *p == '_' || *p == '*')\n\t\tp++;\n\t    if (*p == NUL)\n\t\treturn;\n\t    nextchar = *p;\n\t    *p = NUL;\n\t    opt_idx = findoption(arg);\n\t    *p = nextchar;\n\t    if (opt_idx == -1 || options[opt_idx].var == NULL)\n\t    {\n\t\txp->xp_context = EXPAND_NOTHING;\n\t\treturn;\n\t    }\n\t    flags = options[opt_idx].flags;\n\t    if (flags & P_BOOL)\n\t    {\n\t\txp->xp_context = EXPAND_NOTHING;\n\t\treturn;\n\t    }\n\t}\n    }\n    // handle \"-=\" and \"+=\"\n    if ((nextchar == '-' || nextchar == '+' || nextchar == '^') && p[1] == '=')\n    {\n\t++p;\n\tnextchar = '=';\n    }\n    if ((nextchar != '=' && nextchar != ':')\n\t\t\t\t    || xp->xp_context == EXPAND_BOOL_SETTINGS)\n    {\n\txp->xp_context = EXPAND_UNSUCCESSFUL;\n\treturn;\n    }\n    if (xp->xp_context != EXPAND_BOOL_SETTINGS && p[1] == NUL)\n    {\n\txp->xp_context = EXPAND_OLD_SETTING;\n\tif (is_term_option)\n\t    expand_option_idx = -1;\n\telse\n\t    expand_option_idx = opt_idx;\n\txp->xp_pattern = p + 1;\n\treturn;\n    }\n    xp->xp_context = EXPAND_NOTHING;\n    if (is_term_option || (flags & P_NUM))\n\treturn;\n\n    xp->xp_pattern = p + 1;\n\n    if (flags & P_EXPAND)\n    {\n\tp = options[opt_idx].var;\n\tif (p == (char_u *)&p_bdir\n\t\t|| p == (char_u *)&p_dir\n\t\t|| p == (char_u *)&p_path\n\t\t|| p == (char_u *)&p_pp\n\t\t|| p == (char_u *)&p_rtp\n#ifdef FEAT_SEARCHPATH\n\t\t|| p == (char_u *)&p_cdpath\n#endif\n#ifdef FEAT_SESSION\n\t\t|| p == (char_u *)&p_vdir\n#endif\n\t\t)\n\t{\n\t    xp->xp_context = EXPAND_DIRECTORIES;\n\t    if (p == (char_u *)&p_path\n#ifdef FEAT_SEARCHPATH\n\t\t    || p == (char_u *)&p_cdpath\n#endif\n\t\t   )\n\t\txp->xp_backslash = XP_BS_THREE;\n\t    else\n\t\txp->xp_backslash = XP_BS_ONE;\n\t}\n\telse if (p == (char_u *)&p_ft)\n\t{\n\t    xp->xp_context = EXPAND_FILETYPE;\n\t}\n\telse\n\t{\n\t    xp->xp_context = EXPAND_FILES;\n\t    // for 'tags' need three backslashes for a space\n\t    if (p == (char_u *)&p_tags)\n\t\txp->xp_backslash = XP_BS_THREE;\n\t    else\n\t\txp->xp_backslash = XP_BS_ONE;\n\t}\n    }\n\n    // For an option that is a list of file names, find the start of the\n    // last file name.\n    for (p = arg + STRLEN(arg) - 1; p > xp->xp_pattern; --p)\n    {\n\t// count number of backslashes before ' ' or ','\n\tif (*p == ' ' || *p == ',')\n\t{\n\t    s = p;\n\t    while (s > xp->xp_pattern && *(s - 1) == '\\\\')\n\t\t--s;\n\t    if ((*p == ' ' && (xp->xp_backslash == XP_BS_THREE && (p - s) < 3))\n\t\t    || (*p == ',' && (flags & P_COMMA) && ((p - s) & 1) == 0))\n\t    {\n\t\txp->xp_pattern = p + 1;\n\t\tbreak;\n\t    }\n\t}\n\n#ifdef FEAT_SPELL\n\t// for 'spellsuggest' start at \"file:\"\n\tif (options[opt_idx].var == (char_u *)&p_sps\n\t\t\t\t\t       && STRNCMP(p, \"file:\", 5) == 0)\n\t{\n\t    xp->xp_pattern = p + 5;\n\t    break;\n\t}\n#endif\n    }\n}\n\n    int\nExpandSettings(\n    expand_T\t*xp,\n    regmatch_T\t*regmatch,\n    int\t\t*num_file,\n    char_u\t***file)\n{\n    int\t\tnum_normal = 0;\t    // Nr of matching non-term-code settings\n    int\t\tnum_term = 0;\t    // Nr of matching terminal code settings\n    int\t\topt_idx;\n    int\t\tmatch;\n    int\t\tcount = 0;\n    char_u\t*str;\n    int\t\tloop;\n    int\t\tis_term_opt;\n    char_u\tname_buf[MAX_KEY_NAME_LEN];\n    static char *(names[]) = {\"all\", \"termcap\"};\n    int\t\tic = regmatch->rm_ic;\t// remember the ignore-case flag\n\n    // do this loop twice:\n    // loop == 0: count the number of matching options\n    // loop == 1: copy the matching options into allocated memory\n    for (loop = 0; loop <= 1; ++loop)\n    {\n\tregmatch->rm_ic = ic;\n\tif (xp->xp_context != EXPAND_BOOL_SETTINGS)\n\t{\n\t    for (match = 0; match < (int)ARRAY_LENGTH(names); ++match)\n\t\tif (vim_regexec(regmatch, (char_u *)names[match], (colnr_T)0))\n\t\t{\n\t\t    if (loop == 0)\n\t\t\tnum_normal++;\n\t\t    else\n\t\t\t(*file)[count++] = vim_strsave((char_u *)names[match]);\n\t\t}\n\t}\n\tfor (opt_idx = 0; (str = (char_u *)options[opt_idx].fullname) != NULL;\n\t\t\t\t\t\t\t\t    opt_idx++)\n\t{\n\t    if (options[opt_idx].var == NULL)\n\t\tcontinue;\n\t    if (xp->xp_context == EXPAND_BOOL_SETTINGS\n\t      && !(options[opt_idx].flags & P_BOOL))\n\t\tcontinue;\n\t    is_term_opt = istermoption_idx(opt_idx);\n\t    if (is_term_opt && num_normal > 0)\n\t\tcontinue;\n\t    match = FALSE;\n\t    if (vim_regexec(regmatch, str, (colnr_T)0)\n\t\t    || (options[opt_idx].shortname != NULL\n\t\t\t&& vim_regexec(regmatch,\n\t\t\t   (char_u *)options[opt_idx].shortname, (colnr_T)0)))\n\t\tmatch = TRUE;\n\t    else if (is_term_opt)\n\t    {\n\t\tname_buf[0] = '<';\n\t\tname_buf[1] = 't';\n\t\tname_buf[2] = '_';\n\t\tname_buf[3] = str[2];\n\t\tname_buf[4] = str[3];\n\t\tname_buf[5] = '>';\n\t\tname_buf[6] = NUL;\n\t\tif (vim_regexec(regmatch, name_buf, (colnr_T)0))\n\t\t{\n\t\t    match = TRUE;\n\t\t    str = name_buf;\n\t\t}\n\t    }\n\t    if (match)\n\t    {\n\t\tif (loop == 0)\n\t\t{\n\t\t    if (is_term_opt)\n\t\t\tnum_term++;\n\t\t    else\n\t\t\tnum_normal++;\n\t\t}\n\t\telse\n\t\t    (*file)[count++] = vim_strsave(str);\n\t    }\n\t}\n\t/*\n\t * Check terminal key codes, these are not in the option table\n\t */\n\tif (xp->xp_context != EXPAND_BOOL_SETTINGS  && num_normal == 0)\n\t{\n\t    for (opt_idx = 0; (str = get_termcode(opt_idx)) != NULL; opt_idx++)\n\t    {\n\t\tif (!isprint(str[0]) || !isprint(str[1]))\n\t\t    continue;\n\n\t\tname_buf[0] = 't';\n\t\tname_buf[1] = '_';\n\t\tname_buf[2] = str[0];\n\t\tname_buf[3] = str[1];\n\t\tname_buf[4] = NUL;\n\n\t\tmatch = FALSE;\n\t\tif (vim_regexec(regmatch, name_buf, (colnr_T)0))\n\t\t    match = TRUE;\n\t\telse\n\t\t{\n\t\t    name_buf[0] = '<';\n\t\t    name_buf[1] = 't';\n\t\t    name_buf[2] = '_';\n\t\t    name_buf[3] = str[0];\n\t\t    name_buf[4] = str[1];\n\t\t    name_buf[5] = '>';\n\t\t    name_buf[6] = NUL;\n\n\t\t    if (vim_regexec(regmatch, name_buf, (colnr_T)0))\n\t\t\tmatch = TRUE;\n\t\t}\n\t\tif (match)\n\t\t{\n\t\t    if (loop == 0)\n\t\t\tnum_term++;\n\t\t    else\n\t\t\t(*file)[count++] = vim_strsave(name_buf);\n\t\t}\n\t    }\n\n\t    /*\n\t     * Check special key names.\n\t     */\n\t    regmatch->rm_ic = TRUE;\t\t// ignore case here\n\t    for (opt_idx = 0; (str = get_key_name(opt_idx)) != NULL; opt_idx++)\n\t    {\n\t\tname_buf[0] = '<';\n\t\tSTRCPY(name_buf + 1, str);\n\t\tSTRCAT(name_buf, \">\");\n\n\t\tif (vim_regexec(regmatch, name_buf, (colnr_T)0))\n\t\t{\n\t\t    if (loop == 0)\n\t\t\tnum_term++;\n\t\t    else\n\t\t\t(*file)[count++] = vim_strsave(name_buf);\n\t\t}\n\t    }\n\t}\n\tif (loop == 0)\n\t{\n\t    if (num_normal > 0)\n\t\t*num_file = num_normal;\n\t    else if (num_term > 0)\n\t\t*num_file = num_term;\n\t    else\n\t\treturn OK;\n\t    *file = ALLOC_MULT(char_u *, *num_file);\n\t    if (*file == NULL)\n\t    {\n\t\t*file = (char_u **)\"\";\n\t\treturn FAIL;\n\t    }\n\t}\n    }\n    return OK;\n}\n\n    int\nExpandOldSetting(int *num_file, char_u ***file)\n{\n    char_u  *var = NULL;\t// init for GCC\n    char_u  *buf;\n\n    *num_file = 0;\n    *file = ALLOC_ONE(char_u *);\n    if (*file == NULL)\n\treturn FAIL;\n\n    /*\n     * For a terminal key code expand_option_idx is < 0.\n     */\n    if (expand_option_idx < 0)\n    {\n\tvar = find_termcode(expand_option_name + 2);\n\tif (var == NULL)\n\t    expand_option_idx = findoption(expand_option_name);\n    }\n\n    if (expand_option_idx >= 0)\n    {\n\t// put string of option value in NameBuff\n\toption_value2string(&options[expand_option_idx], expand_option_flags);\n\tvar = NameBuff;\n    }\n    else if (var == NULL)\n\tvar = (char_u *)\"\";\n\n    // A backslash is required before some characters.  This is the reverse of\n    // what happens in do_set().\n    buf = vim_strsave_escaped(var, escape_chars);\n\n    if (buf == NULL)\n    {\n\tVIM_CLEAR(*file);\n\treturn FAIL;\n    }\n\n#ifdef BACKSLASH_IN_FILENAME\n    // For MS-Windows et al. we don't double backslashes at the start and\n    // before a file name character.\n    for (var = buf; *var != NUL; MB_PTR_ADV(var))\n\tif (var[0] == '\\\\' && var[1] == '\\\\'\n\t\t&& expand_option_idx >= 0\n\t\t&& (options[expand_option_idx].flags & P_EXPAND)\n\t\t&& vim_isfilec(var[2])\n\t\t&& (var[2] != '\\\\' || (var == buf && var[4] != '\\\\')))\n\t    STRMOVE(var, var + 1);\n#endif\n\n    *file[0] = buf;\n    *num_file = 1;\n    return OK;\n}\n\n/*\n * Get the value for the numeric or string option *opp in a nice format into\n * NameBuff[].  Must not be called with a hidden option!\n */\n    static void\noption_value2string(\n    struct vimoption\t*opp,\n    int\t\t\tscope)\t// OPT_GLOBAL and/or OPT_LOCAL\n{\n    char_u\t*varp;\n\n    varp = get_varp_scope(opp, scope);\n\n    if (opp->flags & P_NUM)\n    {\n\tlong wc = 0;\n\n\tif (wc_use_keyname(varp, &wc))\n\t    STRCPY(NameBuff, get_special_key_name((int)wc, 0));\n\telse if (wc != 0)\n\t    STRCPY(NameBuff, transchar((int)wc));\n\telse\n\t    sprintf((char *)NameBuff, \"%ld\", *(long *)varp);\n    }\n    else    // P_STRING\n    {\n\tvarp = *(char_u **)(varp);\n\tif (varp == NULL)\t\t    // just in case\n\t    NameBuff[0] = NUL;\n#ifdef FEAT_CRYPT\n\t// don't show the actual value of 'key', only that it's set\n\telse if (opp->var == (char_u *)&p_key && *varp)\n\t    STRCPY(NameBuff, \"*****\");\n#endif\n\telse if (opp->flags & P_EXPAND)\n\t    home_replace(NULL, varp, NameBuff, MAXPATHL, FALSE);\n\t// Translate 'pastetoggle' into special key names\n\telse if ((char_u **)opp->var == &p_pt)\n\t    str2specialbuf(p_pt, NameBuff, MAXPATHL);\n\telse\n\t    vim_strncpy(NameBuff, varp, MAXPATHL - 1);\n    }\n}\n\n/*\n * Return TRUE if \"varp\" points to 'wildchar' or 'wildcharm' and it can be\n * printed as a keyname.\n * \"*wcp\" is set to the value of the option if it's 'wildchar' or 'wildcharm'.\n */\n    static int\nwc_use_keyname(char_u *varp, long *wcp)\n{\n    if (((long *)varp == &p_wc) || ((long *)varp == &p_wcm))\n    {\n\t*wcp = *(long *)varp;\n\tif (IS_SPECIAL(*wcp) || find_special_key_in_table((int)*wcp) >= 0)\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE if \"x\" is present in 'shortmess' option, or\n * 'shortmess' contains 'a' and \"x\" is present in SHM_A.\n */\n    int\nshortmess(int x)\n{\n    return p_shm != NULL &&\n\t    (   vim_strchr(p_shm, x) != NULL\n\t    || (vim_strchr(p_shm, 'a') != NULL\n\t\t&& vim_strchr((char_u *)SHM_A, x) != NULL));\n}\n\n/*\n * paste_option_changed() - Called after p_paste was set or reset.\n */\n    static void\npaste_option_changed(void)\n{\n    static int\told_p_paste = FALSE;\n    static int\tsave_sm = 0;\n    static int\tsave_sta = 0;\n#ifdef FEAT_CMDL_INFO\n    static int\tsave_ru = 0;\n#endif\n#ifdef FEAT_RIGHTLEFT\n    static int\tsave_ri = 0;\n    static int\tsave_hkmap = 0;\n#endif\n    buf_T\t*buf;\n\n    if (p_paste)\n    {\n\t/*\n\t * Paste switched from off to on.\n\t * Save the current values, so they can be restored later.\n\t */\n\tif (!old_p_paste)\n\t{\n\t    // save options for each buffer\n\t    FOR_ALL_BUFFERS(buf)\n\t    {\n\t\tbuf->b_p_tw_nopaste = buf->b_p_tw;\n\t\tbuf->b_p_wm_nopaste = buf->b_p_wm;\n\t\tbuf->b_p_sts_nopaste = buf->b_p_sts;\n\t\tbuf->b_p_ai_nopaste = buf->b_p_ai;\n\t\tbuf->b_p_et_nopaste = buf->b_p_et;\n#ifdef FEAT_VARTABS\n\t\tif (buf->b_p_vsts_nopaste)\n\t\t    vim_free(buf->b_p_vsts_nopaste);\n\t\tbuf->b_p_vsts_nopaste = buf->b_p_vsts && buf->b_p_vsts != empty_option\n\t\t\t\t     ? vim_strsave(buf->b_p_vsts) : NULL;\n#endif\n\t    }\n\n\t    // save global options\n\t    save_sm = p_sm;\n\t    save_sta = p_sta;\n#ifdef FEAT_CMDL_INFO\n\t    save_ru = p_ru;\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t    save_ri = p_ri;\n\t    save_hkmap = p_hkmap;\n#endif\n\t    // save global values for local buffer options\n\t    p_ai_nopaste = p_ai;\n\t    p_et_nopaste = p_et;\n\t    p_sts_nopaste = p_sts;\n\t    p_tw_nopaste = p_tw;\n\t    p_wm_nopaste = p_wm;\n#ifdef FEAT_VARTABS\n\t    if (p_vsts_nopaste)\n\t\tvim_free(p_vsts_nopaste);\n\t    p_vsts_nopaste = p_vsts && p_vsts != empty_option ? vim_strsave(p_vsts) : NULL;\n#endif\n\t}\n\n\t/*\n\t * Always set the option values, also when 'paste' is set when it is\n\t * already on.\n\t */\n\t// set options for each buffer\n\tFOR_ALL_BUFFERS(buf)\n\t{\n\t    buf->b_p_tw = 0;\t    // textwidth is 0\n\t    buf->b_p_wm = 0;\t    // wrapmargin is 0\n\t    buf->b_p_sts = 0;\t    // softtabstop is 0\n\t    buf->b_p_ai = 0;\t    // no auto-indent\n\t    buf->b_p_et = 0;\t    // no expandtab\n#ifdef FEAT_VARTABS\n\t    if (buf->b_p_vsts)\n\t\tfree_string_option(buf->b_p_vsts);\n\t    buf->b_p_vsts = empty_option;\n\t    if (buf->b_p_vsts_array)\n\t\tvim_free(buf->b_p_vsts_array);\n\t    buf->b_p_vsts_array = 0;\n#endif\n\t}\n\n\t// set global options\n\tp_sm = 0;\t\t    // no showmatch\n\tp_sta = 0;\t\t    // no smarttab\n#ifdef FEAT_CMDL_INFO\n\tif (p_ru)\n\t    status_redraw_all();    // redraw to remove the ruler\n\tp_ru = 0;\t\t    // no ruler\n#endif\n#ifdef FEAT_RIGHTLEFT\n\tp_ri = 0;\t\t    // no reverse insert\n\tp_hkmap = 0;\t\t    // no Hebrew keyboard\n#endif\n\t// set global values for local buffer options\n\tp_tw = 0;\n\tp_wm = 0;\n\tp_sts = 0;\n\tp_ai = 0;\n#ifdef FEAT_VARTABS\n\tif (p_vsts)\n\t    free_string_option(p_vsts);\n\tp_vsts = empty_option;\n#endif\n    }\n\n    /*\n     * Paste switched from on to off: Restore saved values.\n     */\n    else if (old_p_paste)\n    {\n\t// restore options for each buffer\n\tFOR_ALL_BUFFERS(buf)\n\t{\n\t    buf->b_p_tw = buf->b_p_tw_nopaste;\n\t    buf->b_p_wm = buf->b_p_wm_nopaste;\n\t    buf->b_p_sts = buf->b_p_sts_nopaste;\n\t    buf->b_p_ai = buf->b_p_ai_nopaste;\n\t    buf->b_p_et = buf->b_p_et_nopaste;\n#ifdef FEAT_VARTABS\n\t    if (buf->b_p_vsts)\n\t\tfree_string_option(buf->b_p_vsts);\n\t    buf->b_p_vsts = buf->b_p_vsts_nopaste\n\t\t\t ? vim_strsave(buf->b_p_vsts_nopaste) : empty_option;\n\t    if (buf->b_p_vsts_array)\n\t\tvim_free(buf->b_p_vsts_array);\n\t    if (buf->b_p_vsts && buf->b_p_vsts != empty_option)\n\t\t(void)tabstop_set(buf->b_p_vsts, &buf->b_p_vsts_array);\n\t    else\n\t\tbuf->b_p_vsts_array = 0;\n#endif\n\t}\n\n\t// restore global options\n\tp_sm = save_sm;\n\tp_sta = save_sta;\n#ifdef FEAT_CMDL_INFO\n\tif (p_ru != save_ru)\n\t    status_redraw_all();    // redraw to draw the ruler\n\tp_ru = save_ru;\n#endif\n#ifdef FEAT_RIGHTLEFT\n\tp_ri = save_ri;\n\tp_hkmap = save_hkmap;\n#endif\n\t// set global values for local buffer options\n\tp_ai = p_ai_nopaste;\n\tp_et = p_et_nopaste;\n\tp_sts = p_sts_nopaste;\n\tp_tw = p_tw_nopaste;\n\tp_wm = p_wm_nopaste;\n#ifdef FEAT_VARTABS\n\tif (p_vsts)\n\t    free_string_option(p_vsts);\n\tp_vsts = p_vsts_nopaste ? vim_strsave(p_vsts_nopaste) : empty_option;\n#endif\n    }\n\n    old_p_paste = p_paste;\n}\n\n/*\n * vimrc_found() - Called when a \".vimrc\" or \"VIMINIT\" has been found.\n *\n * Reset 'compatible' and set the values for options that didn't get set yet\n * to the Vim defaults.\n * Don't do this if the 'compatible' option has been set or reset before.\n * When \"fname\" is not NULL, use it to set $\"envname\" when it wasn't set yet.\n */\n    void\nvimrc_found(char_u *fname, char_u *envname)\n{\n    int\t\topt_idx;\n    int\t\tdofree = FALSE;\n    char_u\t*p;\n\n    if (!option_was_set((char_u *)\"cp\"))\n    {\n\tp_cp = FALSE;\n\tfor (opt_idx = 0; !istermoption_idx(opt_idx); opt_idx++)\n\t    if (!(options[opt_idx].flags & (P_WAS_SET|P_VI_DEF)))\n\t\tset_option_default(opt_idx, OPT_FREE, FALSE);\n\tdidset_options();\n\tdidset_options2();\n    }\n\n    if (fname != NULL)\n    {\n\tp = vim_getenv(envname, &dofree);\n\tif (p == NULL)\n\t{\n\t    // Set $MYVIMRC to the first vimrc file found.\n\t    p = FullName_save(fname, FALSE);\n\t    if (p != NULL)\n\t    {\n\t\tvim_setenv(envname, p);\n\t\tvim_free(p);\n\t    }\n\t}\n\telse if (dofree)\n\t    vim_free(p);\n    }\n}\n\n/*\n * Set 'compatible' on or off.  Called for \"-C\" and \"-N\" command line arg.\n */\n    void\nchange_compatible(int on)\n{\n    int\t    opt_idx;\n\n    if (p_cp != on)\n    {\n\tp_cp = on;\n\tcompatible_set();\n    }\n    opt_idx = findoption((char_u *)\"cp\");\n    if (opt_idx >= 0)\n\toptions[opt_idx].flags |= P_WAS_SET;\n}\n\n/*\n * Return TRUE when option \"name\" has been set.\n * Only works correctly for global options.\n */\n    int\noption_was_set(char_u *name)\n{\n    int idx;\n\n    idx = findoption(name);\n    if (idx < 0)\t// unknown option\n\treturn FALSE;\n    if (options[idx].flags & P_WAS_SET)\n\treturn TRUE;\n    return FALSE;\n}\n\n/*\n * Reset the flag indicating option \"name\" was set.\n */\n    int\nreset_option_was_set(char_u *name)\n{\n    int idx = findoption(name);\n\n    if (idx >= 0)\n    {\n\toptions[idx].flags &= ~P_WAS_SET;\n\treturn OK;\n    }\n    return FAIL;\n}\n\n/*\n * compatible_set() - Called when 'compatible' has been set or unset.\n *\n * When 'compatible' set: Set all relevant options (those that have the P_VIM)\n * flag) to a Vi compatible value.\n * When 'compatible' is unset: Set all options that have a different default\n * for Vim (without the P_VI_DEF flag) to that default.\n */\n    static void\ncompatible_set(void)\n{\n    int\t    opt_idx;\n\n    for (opt_idx = 0; !istermoption_idx(opt_idx); opt_idx++)\n\tif (\t   ((options[opt_idx].flags & P_VIM) && p_cp)\n\t\t|| (!(options[opt_idx].flags & P_VI_DEF) && !p_cp))\n\t    set_option_default(opt_idx, OPT_FREE, p_cp);\n    didset_options();\n    didset_options2();\n}\n\n#if defined(FEAT_LINEBREAK) || defined(PROTO)\n\n/*\n * fill_breakat_flags() -- called when 'breakat' changes value.\n */\n    void\nfill_breakat_flags(void)\n{\n    char_u\t*p;\n    int\t\ti;\n\n    for (i = 0; i < 256; i++)\n\tbreakat_flags[i] = FALSE;\n\n    if (p_breakat != NULL)\n\tfor (p = p_breakat; *p; p++)\n\t    breakat_flags[*p] = TRUE;\n}\n#endif\n\n/*\n * Check if backspacing over something is allowed.\n */\n    int\ncan_bs(\n    int\t\twhat)\t    // BS_INDENT, BS_EOL, BS_START or BS_NOSTOP\n{\n#ifdef FEAT_JOB_CHANNEL\n    if (what == BS_START && bt_prompt(curbuf))\n\treturn FALSE;\n#endif\n    switch (*p_bs)\n    {\n\tcase '3':       return TRUE;\n\tcase '2':\treturn (what != BS_NOSTOP);\n\tcase '1':\treturn (what != BS_START);\n\tcase '0':\treturn FALSE;\n    }\n    return vim_strchr(p_bs, what) != NULL;\n}\n\n/*\n * Return the effective 'scrolloff' value for the current window, using the\n * global value when appropriate.\n */\n    long\nget_scrolloff_value(void)\n{\n    return curwin->w_p_so < 0 ? p_so : curwin->w_p_so;\n}\n\n/*\n * Return the effective 'sidescrolloff' value for the current window, using the\n * global value when appropriate.\n */\n    long\nget_sidescrolloff_value(void)\n{\n    return curwin->w_p_siso < 0 ? p_siso : curwin->w_p_siso;\n}\n\n/*\n * Get the local or global value of 'backupcopy'.\n */\n    unsigned int\nget_bkc_value(buf_T *buf)\n{\n    return buf->b_bkc_flags ? buf->b_bkc_flags : bkc_flags;\n}\n\n/*\n * Get the local or global value of 'formatlistpat'.\n */\n    char_u *\nget_flp_value(buf_T *buf)\n{\n    if (buf->b_p_flp == NULL || *buf->b_p_flp == NUL)\n\treturn p_flp;\n    return buf->b_p_flp;\n}\n\n/*\n * Get the local or global value of the 'virtualedit' flags.\n */\n    unsigned int\nget_ve_flags(void)\n{\n    return (curwin->w_ve_flags ? curwin->w_ve_flags : ve_flags)\n\t    & ~(VE_NONE | VE_NONEU);\n}\n\n#if defined(FEAT_LINEBREAK) || defined(PROTO)\n/*\n * Get the local or global value of 'showbreak'.\n */\n    char_u *\nget_showbreak_value(win_T *win)\n{\n    if (win->w_p_sbr == NULL || *win->w_p_sbr == NUL)\n\treturn p_sbr;\n    if (STRCMP(win->w_p_sbr, \"NONE\") == 0)\n\treturn empty_option;\n    return win->w_p_sbr;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Get window or buffer local options.\n */\n    dict_T *\nget_winbuf_options(int bufopt)\n{\n    dict_T\t*d;\n    int\t\topt_idx;\n\n    d = dict_alloc();\n    if (d == NULL)\n\treturn NULL;\n\n    for (opt_idx = 0; !istermoption_idx(opt_idx); opt_idx++)\n    {\n\tstruct vimoption *opt = &options[opt_idx];\n\n\tif ((bufopt && (opt->indir & PV_BUF))\n\t\t\t\t\t || (!bufopt && (opt->indir & PV_WIN)))\n\t{\n\t    char_u *varp = get_varp(opt);\n\n\t    if (varp != NULL)\n\t    {\n\t\tif (opt->flags & P_STRING)\n\t\t    dict_add_string(d, opt->fullname, *(char_u **)varp);\n\t\telse if (opt->flags & P_NUM)\n\t\t    dict_add_number(d, opt->fullname, *(long *)varp);\n\t\telse\n\t\t    dict_add_number(d, opt->fullname, *(int *)varp);\n\t    }\n\t}\n    }\n\n    return d;\n}\n#endif\n\n#if defined(FEAT_SYN_HL) || defined(PROTO)\n/*\n * This is called when 'culopt' is changed\n */\n    int\nfill_culopt_flags(char_u *val, win_T *wp)\n{\n    char_u\t*p;\n    char_u\tculopt_flags_new = 0;\n\n    if (val == NULL)\n\tp = wp->w_p_culopt;\n    else\n\tp = val;\n    while (*p != NUL)\n    {\n\tif (STRNCMP(p, \"line\", 4) == 0)\n\t{\n\t    p += 4;\n\t    culopt_flags_new |= CULOPT_LINE;\n\t}\n\telse if (STRNCMP(p, \"both\", 4) == 0)\n\t{\n\t    p += 4;\n\t    culopt_flags_new |= CULOPT_LINE | CULOPT_NBR;\n\t}\n\telse if (STRNCMP(p, \"number\", 6) == 0)\n\t{\n\t    p += 6;\n\t    culopt_flags_new |= CULOPT_NBR;\n\t}\n\telse if (STRNCMP(p, \"screenline\", 10) == 0)\n\t{\n\t    p += 10;\n\t    culopt_flags_new |= CULOPT_SCRLINE;\n\t}\n\n\tif (*p != ',' && *p != NUL)\n\t    return FAIL;\n\tif (*p == ',')\n\t    ++p;\n    }\n\n    // Can't have both \"line\" and \"screenline\".\n    if ((culopt_flags_new & CULOPT_LINE) && (culopt_flags_new & CULOPT_SCRLINE))\n\treturn FAIL;\n    wp->w_p_culopt_flags = culopt_flags_new;\n\n    return OK;\n}\n#endif\n\n/*\n * Get the value of 'magic' adjusted for Vim9 script.\n */\n    int\nmagic_isset(void)\n{\n    switch (magic_overruled)\n    {\n\tcase OPTION_MAGIC_ON:      return TRUE;\n\tcase OPTION_MAGIC_OFF:     return FALSE;\n\tcase OPTION_MAGIC_NOT_SET: break;\n    }\n#ifdef FEAT_EVAL\n    if (in_vim9script())\n\treturn TRUE;\n#endif\n    return p_magic;\n}\n\n/*\n * Set the callback function value for an option that accepts a function name,\n * lambda, et al. (e.g. 'operatorfunc', 'tagfunc', etc.)\n * Returns OK if the option is successfully set to a function, otherwise\n * returns FAIL.\n */\n    int\noption_set_callback_func(char_u *optval UNUSED, callback_T *optcb UNUSED)\n{\n#ifdef FEAT_EVAL\n    typval_T\t*tv;\n    callback_T\tcb;\n\n    if (optval == NULL || *optval == NUL)\n    {\n\tfree_callback(optcb);\n\treturn OK;\n    }\n\n    if (*optval == '{' || (in_vim9script() && *optval == '(')\n\t    || (STRNCMP(optval, \"function(\", 9) == 0)\n\t    || (STRNCMP(optval, \"funcref(\", 8) == 0))\n\t// Lambda expression or a funcref\n\ttv = eval_expr(optval, NULL);\n    else\n\t// treat everything else as a function name string\n\ttv = alloc_string_tv(vim_strsave(optval));\n    if (tv == NULL)\n\treturn FAIL;\n\n    cb = get_callback(tv);\n    if (cb.cb_name == NULL || *cb.cb_name == NUL)\n    {\n\tfree_tv(tv);\n\treturn FAIL;\n    }\n\n    free_callback(optcb);\n    set_callback(optcb, &cb);\n    free_tv(tv);\n\n    // when using Vim9 style \"import.funcname\" it needs to be expanded to\n    // \"import#funcname\".\n    expand_autload_callback(optcb);\n\n    return OK;\n#else\n    return FAIL;\n#endif\n}\n", "\" Test for options\n\nsource shared.vim\nsource check.vim\nsource view_util.vim\n\nfunc Test_whichwrap()\n  set whichwrap=b,s\n  call assert_equal('b,s', &whichwrap)\n\n  set whichwrap+=h,l\n  call assert_equal('b,s,h,l', &whichwrap)\n\n  set whichwrap+=h,l\n  call assert_equal('b,s,h,l', &whichwrap)\n\n  set whichwrap+=h,l\n  call assert_equal('b,s,h,l', &whichwrap)\n\n  set whichwrap=h,h\n  call assert_equal('h', &whichwrap)\n\n  set whichwrap=h,h,h\n  call assert_equal('h', &whichwrap)\n\n  \" For compatibility with Vim 3.0 and before, number values are also\n  \" supported for 'whichwrap'\n  set whichwrap=1\n  call assert_equal('b', &whichwrap)\n  set whichwrap=2\n  call assert_equal('s', &whichwrap)\n  set whichwrap=4\n  call assert_equal('h,l', &whichwrap)\n  set whichwrap=8\n  call assert_equal('<,>', &whichwrap)\n  set whichwrap=16\n  call assert_equal('[,]', &whichwrap)\n  set whichwrap=31\n  call assert_equal('b,s,h,l,<,>,[,]', &whichwrap)\n\n  set whichwrap&\nendfunc\n\nfunc Test_isfname()\n  \" This used to cause Vim to access uninitialized memory.\n  set isfname=\n  call assert_equal(\"~X\", expand(\"~X\"))\n  set isfname&\nendfunc\n\nfunc Test_wildchar()\n  \" Empty 'wildchar' used to access invalid memory.\n  call assert_fails('set wildchar=', 'E521:')\n  call assert_fails('set wildchar=abc', 'E521:')\n  set wildchar=<Esc>\n  let a=execute('set wildchar?')\n  call assert_equal(\"\\n  wildchar=<Esc>\", a)\n  set wildchar=27\n  let a=execute('set wildchar?')\n  call assert_equal(\"\\n  wildchar=<Esc>\", a)\n  set wildchar&\nendfunc\n\nfunc Test_wildoptions()\n  set wildoptions=\n  set wildoptions+=tagfile\n  set wildoptions+=tagfile\n  call assert_equal('tagfile', &wildoptions)\nendfunc\n\nfunc Test_options_command()\n  let caught = 'ok'\n  try\n    options\n  catch\n    let caught = v:throwpoint . \"\\n\" . v:exception\n  endtry\n  call assert_equal('ok', caught)\n\n  \" Check if the option-window is opened horizontally.\n  wincmd j\n  call assert_notequal('option-window', bufname(''))\n  wincmd k\n  call assert_equal('option-window', bufname(''))\n  \" close option-window\n  close\n\n  \" Open the option-window vertically.\n  vert options\n  \" Check if the option-window is opened vertically.\n  wincmd l\n  call assert_notequal('option-window', bufname(''))\n  wincmd h\n  call assert_equal('option-window', bufname(''))\n  \" close option-window\n  close\n\n  \" Open the option-window at the top.\n  set splitbelow\n  topleft options\n  call assert_equal(1, winnr())\n  close\n\n  \" Open the option-window at the bottom.\n  set nosplitbelow\n  botright options\n  call assert_equal(winnr('$'), winnr())\n  close\n  set splitbelow&\n\n  \" Open the option-window in a new tab.\n  tab options\n  \" Check if the option-window is opened in a tab.\n  normal gT\n  call assert_notequal('option-window', bufname(''))\n  normal gt\n  call assert_equal('option-window', bufname(''))\n  \" close option-window\n  close\n\n  \" Open the options window browse\n  if has('browse')\n    browse set\n    call assert_equal('option-window', bufname(''))\n    close\n  endif\nendfunc\n\nfunc Test_path_keep_commas()\n  \" Test that changing 'path' keeps two commas.\n  set path=foo,,bar\n  set path-=bar\n  set path+=bar\n  call assert_equal('foo,,bar', &path)\n\n  set path&\nendfunc\n\nfunc Test_path_too_long()\n  exe 'set path=' .. repeat('x', 10000)\n  call assert_fails('find x', 'E854:')\n  set path&\nendfunc\n\nfunc Test_signcolumn()\n  CheckFeature signs\n  call assert_equal(\"auto\", &signcolumn)\n  set signcolumn=yes\n  set signcolumn=no\n  call assert_fails('set signcolumn=nope')\nendfunc\n\nfunc Test_filetype_valid()\n  set ft=valid_name\n  call assert_equal(\"valid_name\", &filetype)\n  set ft=valid-name\n  call assert_equal(\"valid-name\", &filetype)\n\n  call assert_fails(\":set ft=wrong;name\", \"E474:\")\n  call assert_fails(\":set ft=wrong\\\\\\\\name\", \"E474:\")\n  call assert_fails(\":set ft=wrong\\\\|name\", \"E474:\")\n  call assert_fails(\":set ft=wrong/name\", \"E474:\")\n  call assert_fails(\":set ft=wrong\\\\\\nname\", \"E474:\")\n  call assert_equal(\"valid-name\", &filetype)\n\n  exe \"set ft=trunc\\x00name\"\n  call assert_equal(\"trunc\", &filetype)\nendfunc\n\nfunc Test_syntax_valid()\n  CheckFeature syntax\n  set syn=valid_name\n  call assert_equal(\"valid_name\", &syntax)\n  set syn=valid-name\n  call assert_equal(\"valid-name\", &syntax)\n\n  call assert_fails(\":set syn=wrong;name\", \"E474:\")\n  call assert_fails(\":set syn=wrong\\\\\\\\name\", \"E474:\")\n  call assert_fails(\":set syn=wrong\\\\|name\", \"E474:\")\n  call assert_fails(\":set syn=wrong/name\", \"E474:\")\n  call assert_fails(\":set syn=wrong\\\\\\nname\", \"E474:\")\n  call assert_equal(\"valid-name\", &syntax)\n\n  exe \"set syn=trunc\\x00name\"\n  call assert_equal(\"trunc\", &syntax)\nendfunc\n\nfunc Test_keymap_valid()\n  CheckFeature keymap\n  call assert_fails(\":set kmp=valid_name\", \"E544:\")\n  call assert_fails(\":set kmp=valid_name\", \"valid_name\")\n  call assert_fails(\":set kmp=valid-name\", \"E544:\")\n  call assert_fails(\":set kmp=valid-name\", \"valid-name\")\n\n  call assert_fails(\":set kmp=wrong;name\", \"E474:\")\n  call assert_fails(\":set kmp=wrong\\\\\\\\name\", \"E474:\")\n  call assert_fails(\":set kmp=wrong\\\\|name\", \"E474:\")\n  call assert_fails(\":set kmp=wrong/name\", \"E474:\")\n  call assert_fails(\":set kmp=wrong\\\\\\nname\", \"E474:\")\n\n  call assert_fails(\":set kmp=trunc\\x00name\", \"E544:\")\n  call assert_fails(\":set kmp=trunc\\x00name\", \"trunc\")\nendfunc\n\nfunc Check_dir_option(name)\n  \" Check that it's possible to set the option.\n  exe 'set ' . a:name . '=/usr/share/dict/words'\n  call assert_equal('/usr/share/dict/words', eval('&' . a:name))\n  exe 'set ' . a:name . '=/usr/share/dict/words,/and/there'\n  call assert_equal('/usr/share/dict/words,/and/there', eval('&' . a:name))\n  exe 'set ' . a:name . '=/usr/share/dict\\ words'\n  call assert_equal('/usr/share/dict words', eval('&' . a:name))\n\n  \" Check rejecting weird characters.\n  call assert_fails(\"set \" . a:name . \"=/not&there\", \"E474:\")\n  call assert_fails(\"set \" . a:name . \"=/not>there\", \"E474:\")\n  call assert_fails(\"set \" . a:name . \"=/not.*there\", \"E474:\")\nendfunc\n\nfunc Test_cinkeys()\n  \" This used to cause invalid memory access\n  set cindent cinkeys=0\n  norm a\n  set cindent& cinkeys&\nendfunc\n\nfunc Test_dictionary()\n  call Check_dir_option('dictionary')\nendfunc\n\nfunc Test_thesaurus()\n  call Check_dir_option('thesaurus')\nendfun\n\nfunc Test_complete()\n  \" Trailing single backslash used to cause invalid memory access.\n  set complete=s\\\n  new\n  call feedkeys(\"i\\<C-N>\\<Esc>\", 'xt')\n  bwipe!\n  call assert_fails('set complete=ix', 'E535:')\n  set complete&\nendfun\n\nfunc Test_set_completion()\n  call feedkeys(\":set di\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set dictionary diff diffexpr diffopt digraph directory display', @:)\n\n  call feedkeys(\":setlocal di\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"setlocal dictionary diff diffexpr diffopt digraph directory display', @:)\n\n  call feedkeys(\":setglobal di\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"setglobal dictionary diff diffexpr diffopt digraph directory display', @:)\n\n  \" Expand boolan options. When doing :set no<Tab>\n  \" vim displays the options names without \"no\" but completion uses \"no...\".\n  call feedkeys(\":set nodi\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set nodiff digraph', @:)\n\n  call feedkeys(\":set invdi\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set invdiff digraph', @:)\n\n  \" Expand abbreviation of options.\n  call feedkeys(\":set ts\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set tabstop thesaurus thesaurusfunc ttyscroll', @:)\n\n  \" Expand current value\n  call feedkeys(\":set fileencodings=\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set fileencodings=ucs-bom,utf-8,default,latin1', @:)\n\n  call feedkeys(\":set fileencodings:\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set fileencodings:ucs-bom,utf-8,default,latin1', @:)\n\n  \" Expand key codes.\n  call feedkeys(\":set <H\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set <Help> <Home>', @:)\n\n  \" Expand terminal options.\n  call feedkeys(\":set t_A\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set t_AB t_AF t_AU t_AL', @:)\n  call assert_fails('call feedkeys(\":set <t_afoo>=\\<C-A>\\<CR>\", \"xt\")', 'E474:')\n\n  \" Expand directories.\n  call feedkeys(\":set cdpath=./\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match(' ./samples/ ', @:)\n  call assert_notmatch(' ./summarize.vim ', @:)\n\n  \" Expand files and directories.\n  call feedkeys(\":set tags=./\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match(' ./samples/.* ./summarize.vim', @:)\n\n  call feedkeys(\":set tags=./\\\\\\\\ dif\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set tags=./\\\\ diff diffexpr diffopt', @:)\n  set tags&\n\n  \" Expanding the option names\n  call feedkeys(\":set \\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"set all', @:)\n\n  \" Expanding a second set of option names\n  call feedkeys(\":set wrapscan \\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"set wrapscan all', @:)\n\n  \" Expanding a special keycode\n  call feedkeys(\":set <Home>\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"set <Home>', @:)\n\n  \" Expanding an invalid special keycode\n  call feedkeys(\":set <abcd>\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"set <abcd>\\<Tab>\", @:)\n\n  \" Expanding a terminal keycode\n  call feedkeys(\":set t_AB\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"set t_AB\", @:)\n\n  \" Expanding an invalid option name\n  call feedkeys(\":set abcde=\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"set abcde=\\<Tab>\", @:)\n\n  \" Expanding after a = for a boolean option\n  call feedkeys(\":set wrapscan=\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"set wrapscan=\\<Tab>\", @:)\n\n  \" Expanding a numeric option\n  call feedkeys(\":set tabstop+=\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"set tabstop+=\" .. &tabstop, @:)\n\n  \" Expanding a non-boolean option\n  call feedkeys(\":set invtabstop=\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"set invtabstop=\", @:)\n\n  \" Expand options for 'spellsuggest'\n  call feedkeys(\":set spellsuggest=best,file:xyz\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"set spellsuggest=best,file:xyz\", @:)\n\n  \" Expand value for 'key'\n  set key=abcd\n  call feedkeys(\":set key=\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"set key=*****', @:)\n  set key=\n\n  \" Expand values for 'filetype'\n  call feedkeys(\":set filetype=sshdconfi\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"set filetype=sshdconfig', @:)\n  call feedkeys(\":set filetype=a\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"set filetype=' .. getcompletion('a*', 'filetype')->join(), @:)\nendfunc\n\nfunc Test_set_errors()\n  call assert_fails('set scroll=-1', 'E49:')\n  call assert_fails('set backupcopy=', 'E474:')\n  call assert_fails('set regexpengine=3', 'E474:')\n  call assert_fails('set history=10001', 'E474:')\n  call assert_fails('set numberwidth=21', 'E474:')\n  call assert_fails('set colorcolumn=-a', 'E474:')\n  call assert_fails('set colorcolumn=a', 'E474:')\n  call assert_fails('set colorcolumn=1,', 'E474:')\n  call assert_fails('set colorcolumn=1;', 'E474:')\n  call assert_fails('set cmdheight=-1', 'E487:')\n  call assert_fails('set cmdwinheight=-1', 'E487:')\n  if has('conceal')\n    call assert_fails('set conceallevel=-1', 'E487:')\n    call assert_fails('set conceallevel=4', 'E474:')\n  endif\n  call assert_fails('set helpheight=-1', 'E487:')\n  call assert_fails('set history=-1', 'E487:')\n  call assert_fails('set report=-1', 'E487:')\n  call assert_fails('set shiftwidth=-1', 'E487:')\n  call assert_fails('set sidescroll=-1', 'E487:')\n  call assert_fails('set tabstop=-1', 'E487:')\n  call assert_fails('set textwidth=-1', 'E487:')\n  call assert_fails('set timeoutlen=-1', 'E487:')\n  call assert_fails('set updatecount=-1', 'E487:')\n  call assert_fails('set updatetime=-1', 'E487:')\n  call assert_fails('set winheight=-1', 'E487:')\n  call assert_fails('set tabstop!', 'E488:')\n  call assert_fails('set xxx', 'E518:')\n  call assert_fails('set beautify?', 'E519:')\n  call assert_fails('set undolevels=x', 'E521:')\n  call assert_fails('set tabstop=', 'E521:')\n  call assert_fails('set comments=-', 'E524:')\n  call assert_fails('set comments=a', 'E525:')\n  call assert_fails('set foldmarker=x', 'E536:')\n  call assert_fails('set commentstring=x', 'E537:')\n  call assert_fails('set complete=x', 'E539:')\n  call assert_fails('set rulerformat=%-', 'E539:')\n  call assert_fails('set rulerformat=%(', 'E542:')\n  call assert_fails('set rulerformat=%15(%%', 'E542:')\n  call assert_fails('set statusline=%$', 'E539:')\n  call assert_fails('set statusline=%{', 'E540:')\n  call assert_fails('set statusline=%(', 'E542:')\n  call assert_fails('set statusline=%)', 'E542:')\n\n  if has('cursorshape')\n    \" This invalid value for 'guicursor' used to cause Vim to crash.\n    call assert_fails('set guicursor=i-ci,r-cr:h', 'E545:')\n    call assert_fails('set guicursor=i-ci', 'E545:')\n    call assert_fails('set guicursor=x', 'E545:')\n    call assert_fails('set guicursor=x:', 'E546:')\n    call assert_fails('set guicursor=r-cr:horx', 'E548:')\n    call assert_fails('set guicursor=r-cr:hor0', 'E549:')\n  endif\n  if has('mouseshape')\n    call assert_fails('se mouseshape=i-r:x', 'E547:')\n  endif\n  call assert_fails('set backupext=~ patchmode=~', 'E589:')\n  call assert_fails('set winminheight=10 winheight=9', 'E591:')\n  set winminheight& winheight&\n  set winheight=10 winminheight=10\n  call assert_fails('set winheight=9', 'E591:')\n  set winminheight& winheight&\n  call assert_fails('set winminwidth=10 winwidth=9', 'E592:')\n  set winminwidth& winwidth&\n  call assert_fails('set winwidth=9 winminwidth=10', 'E592:')\n  set winwidth& winminwidth&\n  call assert_fails(\"set showbreak=\\x01\", 'E595:')\n  call assert_fails('set t_foo=', 'E846:')\n  call assert_fails('set tabstop??', 'E488:')\n  call assert_fails('set wrapscan!!', 'E488:')\n  call assert_fails('set tabstop&&', 'E488:')\n  call assert_fails('set wrapscan<<', 'E488:')\n  call assert_fails('set wrapscan=1', 'E474:')\n  call assert_fails('set autoindent@', 'E488:')\n  call assert_fails('set wildchar=<abc>', 'E474:')\n  call assert_fails('set cmdheight=1a', 'E521:')\n  call assert_fails('set invcmdheight', 'E474:')\n  if has('python') || has('python3')\n    call assert_fails('set pyxversion=6', 'E474:')\n  endif\n  call assert_fails(\"let &tabstop='ab'\", 'E521:')\n  call assert_fails('set spellcapcheck=%\\\\(', 'E54:')\n  call assert_fails('set sessionoptions=curdir,sesdir', 'E474:')\n  call assert_fails('set foldmarker={{{,', 'E474:')\n  call assert_fails('set sessionoptions=sesdir,curdir', 'E474:')\n  call assert_fails('set listchars=trail:\u00b7 ambiwidth=double', 'E834:')\n  set listchars&\n  call assert_fails('set fillchars=stl:\u00b7 ambiwidth=double', 'E835:')\n  set fillchars&\n  call assert_fails('set fileencoding=latin1,utf-8', 'E474:')\n  set nomodifiable\n  call assert_fails('set fileencoding=latin1', 'E21:')\n  set modifiable&\n  call assert_fails('set t_#-&', 'E522:')\nendfunc\n\nfunc CheckWasSet(name)\n  let verb_cm = execute('verbose set ' .. a:name .. '?')\n  call assert_match('Last set from.*test_options.vim', verb_cm)\nendfunc\nfunc CheckWasNotSet(name)\n  let verb_cm = execute('verbose set ' .. a:name .. '?')\n  call assert_notmatch('Last set from', verb_cm)\nendfunc\n\n\" Must be executed before other tests that set 'term'.\nfunc Test_000_term_option_verbose()\n  CheckNotGui\n\n  call CheckWasNotSet('t_cm')\n\n  let term_save = &term\n  set term=ansi\n  call CheckWasSet('t_cm')\n  let &term = term_save\nendfunc\n\nfunc Test_copy_context()\n  setlocal list\n  call CheckWasSet('list')\n  split\n  call CheckWasSet('list')\n  quit\n  setlocal nolist\n\n  set ai\n  call CheckWasSet('ai')\n  set filetype=perl\n  call CheckWasSet('filetype')\n  set fo=tcroq\n  call CheckWasSet('fo')\n\n  split Xsomebuf\n  call CheckWasSet('ai')\n  call CheckWasNotSet('filetype')\n  call CheckWasSet('fo')\nendfunc\n\nfunc Test_set_ttytype()\n  CheckUnix\n  CheckNotGui\n\n  \" Setting 'ttytype' used to cause a double-free when exiting vim and\n  \" when vim is compiled with -DEXITFREE.\n  set ttytype=ansi\n  call assert_equal('ansi', &ttytype)\n  call assert_equal(&ttytype, &term)\n  set ttytype=xterm\n  call assert_equal('xterm', &ttytype)\n  call assert_equal(&ttytype, &term)\n  try\n    set ttytype=\n    call assert_report('set ttytype= did not fail')\n  catch /E529/\n  endtry\n\n  \" Some systems accept any terminal name and return dumb settings,\n  \" check for failure of finding the entry and for missing 'cm' entry.\n  try\n    set ttytype=xxx\n    call assert_report('set ttytype=xxx did not fail')\n  catch /E522\\|E437/\n  endtry\n\n  set ttytype&\n  call assert_equal(&ttytype, &term)\n\n  if has('gui') && !has('gui_running')\n    call assert_fails('set term=gui', 'E531:')\n  endif\nendfunc\n\nfunc Test_set_all()\n  set tw=75\n  set iskeyword=a-z,A-Z\n  set nosplitbelow\n  let out = execute('set all')\n  call assert_match('textwidth=75', out)\n  call assert_match('iskeyword=a-z,A-Z', out)\n  call assert_match('nosplitbelow', out)\n  set tw& iskeyword& splitbelow&\nendfunc\n\nfunc Test_set_one_column()\n  let out_mult = execute('set all')->split(\"\\n\")\n  let out_one = execute('set! all')->split(\"\\n\")\n  call assert_true(len(out_mult) < len(out_one))\nendfunc\n\nfunc Test_set_values()\n  \" opt_test.vim is generated from ../optiondefs.h using gen_opt_test.vim\n  if filereadable('opt_test.vim')\n    source opt_test.vim\n  else\n    throw 'Skipped: opt_test.vim does not exist'\n  endif\nendfunc\n\nfunc Test_renderoptions()\n  \" Only do this for Windows Vista and later, fails on Windows XP and earlier.\n  \" Doesn't hurt to do this on a non-Windows system.\n  if windowsversion() !~ '^[345]\\.'\n    set renderoptions=type:directx\n    set rop=type:directx\n  endif\nendfunc\n\nfunc ResetIndentexpr()\n  set indentexpr=\nendfunc\n\nfunc Test_set_indentexpr()\n  \" this was causing usage of freed memory\n  set indentexpr=ResetIndentexpr()\n  new\n  call feedkeys(\"i\\<c-f>\", 'x')\n  call assert_equal('', &indentexpr)\n  bwipe!\nendfunc\n\nfunc Test_backupskip()\n  \" Option 'backupskip' may contain several comma-separated path\n  \" specifications if one or more of the environment variables TMPDIR, TMP,\n  \" or TEMP is defined.  To simplify testing, convert the string value into a\n  \" list.\n  let bsklist = split(&bsk, ',')\n\n  if has(\"mac\")\n    let found = (index(bsklist, '/private/tmp/*') >= 0)\n    call assert_true(found, '/private/tmp not in option bsk: ' . &bsk)\n  elseif has(\"unix\")\n    let found = (index(bsklist, '/tmp/*') >= 0)\n    call assert_true(found, '/tmp not in option bsk: ' . &bsk)\n  endif\n\n  \" If our test platform is Windows, the path(s) in option bsk will use\n  \" backslash for the path separator and the components could be in short\n  \" (8.3) format.  As such, we need to replace the backslashes with forward\n  \" slashes and convert the path components to long format.  The expand()\n  \" function will do this but it cannot handle comma-separated paths.  This is\n  \" why bsk was converted from a string into a list of strings above.\n  \"\n  \" One final complication is that the wildcard \"/*\" is at the end of each\n  \" path and so expand() might return a list of matching files.  To prevent\n  \" this, we need to remove the wildcard before calling expand() and then\n  \" append it afterwards.\n  if has('win32')\n    let item_nbr = 0\n    while item_nbr < len(bsklist)\n      let path_spec = bsklist[item_nbr]\n      let path_spec = strcharpart(path_spec, 0, strlen(path_spec)-2)\n      let path_spec = substitute(expand(path_spec), '\\\\', '/', 'g')\n      let bsklist[item_nbr] = path_spec . '/*'\n      let item_nbr += 1\n    endwhile\n  endif\n\n  \" Option bsk will also include these environment variables if defined.\n  \" If they're defined, verify they appear in the option value.\n  for var in  ['$TMPDIR', '$TMP', '$TEMP']\n    if exists(var)\n      let varvalue = substitute(expand(var), '\\\\', '/', 'g')\n      let varvalue = substitute(varvalue, '/$', '', '')\n      let varvalue .= '/*'\n      let found = (index(bsklist, varvalue) >= 0)\n      call assert_true(found, var . ' (' . varvalue . ') not in option bsk: ' . &bsk)\n    endif\n  endfor\n\n  \" Duplicates from environment variables should be filtered out (option has\n  \" P_NODUP).  Run this in a separate instance and write v:errors in a file,\n  \" so that we see what happens on startup.\n  let after =<< trim [CODE]\n      let bsklist = split(&backupskip, ',')\n      call assert_equal(uniq(copy(bsklist)), bsklist)\n      call writefile(['errors:'] + v:errors, 'Xtestout')\n      qall\n  [CODE]\n  call writefile(after, 'Xafter')\n  let cmd = GetVimProg() . ' --not-a-term -S Xafter --cmd \"set enc=utf8\"'\n\n  let saveenv = {}\n  for var in ['TMPDIR', 'TMP', 'TEMP']\n    let saveenv[var] = getenv(var)\n    call setenv(var, '/duplicate/path')\n  endfor\n\n  exe 'silent !' . cmd\n  call assert_equal(['errors:'], readfile('Xtestout'))\n\n  \" restore environment variables\n  for var in ['TMPDIR', 'TMP', 'TEMP']\n    call setenv(var, saveenv[var])\n  endfor\n\n  call delete('Xtestout')\n  call delete('Xafter')\n\n  \" Duplicates should be filtered out (option has P_NODUP)\n  let backupskip = &backupskip\n  set backupskip=\n  set backupskip+=/test/dir\n  set backupskip+=/other/dir\n  set backupskip+=/test/dir\n  call assert_equal('/test/dir,/other/dir', &backupskip)\n  let &backupskip = backupskip\nendfunc\n\nfunc Test_copy_winopt()\n  set hidden\n\n  \" Test copy option from current buffer in window\n  split\n  enew\n  setlocal numberwidth=5\n  wincmd w\n  call assert_equal(4,&numberwidth)\n  bnext\n  call assert_equal(5,&numberwidth)\n  bw!\n  call assert_equal(4,&numberwidth)\n\n  \" Test copy value from window that used to be display the buffer\n  split\n  enew\n  setlocal numberwidth=6\n  bnext\n  wincmd w\n  call assert_equal(4,&numberwidth)\n  bnext\n  call assert_equal(6,&numberwidth)\n  bw!\n\n  \" Test that if buffer is current, don't use the stale cached value\n  \" from the last time the buffer was displayed.\n  split\n  enew\n  setlocal numberwidth=7\n  bnext\n  bnext\n  setlocal numberwidth=8\n  wincmd w\n  call assert_equal(4,&numberwidth)\n  bnext\n  call assert_equal(8,&numberwidth)\n  bw!\n\n  \" Test value is not copied if window already has seen the buffer\n  enew\n  split\n  setlocal numberwidth=9\n  bnext\n  setlocal numberwidth=10\n  wincmd w\n  call assert_equal(4,&numberwidth)\n  bnext\n  call assert_equal(4,&numberwidth)\n  bw!\n\n  set hidden&\nendfunc\n\nfunc Test_shortmess_F()\n  new\n  call assert_match('\\[No Name\\]', execute('file'))\n  set shortmess+=F\n  call assert_match('\\[No Name\\]', execute('file'))\n  call assert_match('^\\s*$', execute('file foo'))\n  call assert_match('foo', execute('file'))\n  set shortmess-=F\n  call assert_match('bar', execute('file bar'))\n  call assert_match('bar', execute('file'))\n  set shortmess&\n  bwipe\nendfunc\n\nfunc Test_shortmess_F2()\n  e file1\n  e file2\n  call assert_match('file1', execute('bn', ''))\n  call assert_match('file2', execute('bn', ''))\n  set shortmess+=F\n  call assert_true(empty(execute('bn', '')))\n  call assert_false(test_getvalue('need_fileinfo'))\n  call assert_true(empty(execute('bn', '')))\n  call assert_false('need_fileinfo'->test_getvalue())\n  set hidden\n  call assert_true(empty(execute('bn', '')))\n  call assert_false(test_getvalue('need_fileinfo'))\n  call assert_true(empty(execute('bn', '')))\n  call assert_false(test_getvalue('need_fileinfo'))\n  set nohidden\n  call assert_true(empty(execute('bn', '')))\n  call assert_false(test_getvalue('need_fileinfo'))\n  call assert_true(empty(execute('bn', '')))\n  call assert_false(test_getvalue('need_fileinfo'))\n  set shortmess&\n  call assert_match('file1', execute('bn', ''))\n  call assert_match('file2', execute('bn', ''))\n  bwipe\n  bwipe\nendfunc\n\nfunc Test_local_scrolloff()\n  set so=5\n  set siso=7\n  split\n  call assert_equal(5, &so)\n  setlocal so=3\n  call assert_equal(3, &so)\n  wincmd w\n  call assert_equal(5, &so)\n  wincmd w\n  setlocal so<\n  call assert_equal(5, &so)\n  setlocal so=0\n  call assert_equal(0, &so)\n  setlocal so=-1\n  call assert_equal(5, &so)\n\n  call assert_equal(7, &siso)\n  setlocal siso=3\n  call assert_equal(3, &siso)\n  wincmd w\n  call assert_equal(7, &siso)\n  wincmd w\n  setlocal siso<\n  call assert_equal(7, &siso)\n  setlocal siso=0\n  call assert_equal(0, &siso)\n  setlocal siso=-1\n  call assert_equal(7, &siso)\n\n  close\n  set so&\n  set siso&\nendfunc\n\nfunc Test_writedelay()\n  CheckFunction reltimefloat\n\n  new\n  call setline(1, 'empty')\n  redraw\n  set writedelay=10\n  let start = reltime()\n  call setline(1, repeat('x', 70))\n  redraw\n  let elapsed = reltimefloat(reltime(start))\n  set writedelay=0\n  \" With 'writedelay' set should take at least 30 * 10 msec\n  call assert_inrange(30 * 0.01, 999.0, elapsed)\n\n  bwipe!\nendfunc\n\nfunc Test_visualbell()\n  set belloff=\n  set visualbell\n  call assert_beeps('normal 0h')\n  set novisualbell\n  set belloff=all\nendfunc\n\n\" Test for the 'write' option\nfunc Test_write()\n  new\n  call setline(1, ['L1'])\n  set nowrite\n  call assert_fails('write Xfile', 'E142:')\n  set write\n  close!\nendfunc\n\n\" Test for 'buftype' option\nfunc Test_buftype()\n  new\n  call setline(1, ['L1'])\n  set buftype=nowrite\n  call assert_fails('write', 'E382:')\n\n  for val in ['', 'nofile', 'nowrite', 'acwrite', 'quickfix', 'help', 'terminal', 'prompt', 'popup']\n    exe 'set buftype=' .. val\n    call writefile(['something'], 'XBuftype')\n    call assert_fails('write XBuftype', 'E13:', 'with buftype=' .. val)\n  endfor\n\n  call delete('XBuftype')\n  bwipe!\nendfunc\n\n\" Test for the 'rightleftcmd' option\nfunc Test_rightleftcmd()\n  CheckFeature rightleft\n  set rightleft\n  set rightleftcmd\n\n  let g:l = []\n  func AddPos()\n    call add(g:l, screencol())\n    return ''\n  endfunc\n  cmap <expr> <F2> AddPos()\n\n  call feedkeys(\"/\\<F2>abc\\<Left>\\<F2>\\<Right>\\<Right>\\<F2>\" ..\n        \\ \"\\<Left>\\<F2>\\<Esc>\", 'xt')\n  call assert_equal([&co - 1, &co - 4, &co - 2, &co - 3], g:l)\n\n  cunmap <F2>\n  unlet g:l\n  set rightleftcmd&\n  set rightleft&\nendfunc\n\n\" Test for the \"debug\" option\nfunc Test_debug_option()\n  set debug=beep\n  exe \"normal \\<C-c>\"\n  call assert_equal('Beep!', Screenline(&lines))\n  set debug&\nendfunc\n\n\" Test for the default CDPATH option\nfunc Test_opt_default_cdpath()\n  CheckFeature file_in_path\n  let after =<< trim [CODE]\n    call assert_equal(',/path/to/dir1,/path/to/dir2', &cdpath)\n    call writefile(v:errors, 'Xtestout')\n    qall\n  [CODE]\n  if has('unix')\n    let $CDPATH='/path/to/dir1:/path/to/dir2'\n  else\n    let $CDPATH='/path/to/dir1;/path/to/dir2'\n  endif\n  if RunVim([], after, '')\n    call assert_equal([], readfile('Xtestout'))\n    call delete('Xtestout')\n  endif\nendfunc\n\n\" Test for setting keycodes using set\nfunc Test_opt_set_keycode()\n  call assert_fails('set <t_k1=l', 'E474:')\n  call assert_fails('set <Home=l', 'E474:')\n  set <t_k9>=abcd\n  call assert_equal('abcd', &t_k9)\n  set <t_k9>&\n  set <F9>=xyz\n  call assert_equal('xyz', &t_k9)\n  set <t_k9>&\nendfunc\n\n\" Test for changing options in a sandbox\nfunc Test_opt_sandbox()\n  for opt in ['backupdir', 'cdpath', 'exrc']\n    call assert_fails('sandbox set ' .. opt .. '?', 'E48:')\n    call assert_fails('sandbox let &' .. opt .. ' = 1', 'E48:')\n  endfor\n  call assert_fails('sandbox let &modelineexpr = 1', 'E48:')\nendfunc\n\n\" Test for setting an option with local value to global value\nfunc Test_opt_local_to_global()\n  setglobal equalprg=gprg\n  setlocal equalprg=lprg\n  call assert_equal('gprg', &g:equalprg)\n  call assert_equal('lprg', &l:equalprg)\n  call assert_equal('lprg', &equalprg)\n  set equalprg<\n  call assert_equal('', &l:equalprg)\n  call assert_equal('gprg', &equalprg)\n  setglobal equalprg=gnewprg\n  setlocal equalprg=lnewprg\n  setlocal equalprg<\n  call assert_equal('gnewprg', &l:equalprg)\n  call assert_equal('gnewprg', &equalprg)\n  set equalprg&\n\n  \" Test for setting the global/local value of a boolean option\n  setglobal autoread\n  setlocal noautoread\n  call assert_false(&autoread)\n  set autoread<\n  call assert_true(&autoread)\n  setglobal noautoread\n  setlocal autoread\n  setlocal autoread<\n  call assert_false(&autoread)\n  set autoread&\nendfunc\n\nfunc Test_set_in_sandbox()\n  \" Some boolean options cannot be set in sandbox, some can.\n  call assert_fails('sandbox set modelineexpr', 'E48:')\n  sandbox set number\n  call assert_true(&number)\n  set number&\n\n  \" Some boolean options cannot be set in sandbox, some can.\n  if has('python') || has('python3')\n    call assert_fails('sandbox set pyxversion=3', 'E48:')\n  endif\n  sandbox set tabstop=4\n  call assert_equal(4, &tabstop)\n  set tabstop&\n\n  \" Some string options cannot be set in sandbox, some can.\n  call assert_fails('sandbox set backupdir=/tmp', 'E48:')\n  sandbox set filetype=perl\n  call assert_equal('perl', &filetype)\n  set filetype&\nendfunc\n\n\" Test for incrementing, decrementing and multiplying a number option value\nfunc Test_opt_num_op()\n  set shiftwidth=4\n  set sw+=2\n  call assert_equal(6, &sw)\n  set sw-=2\n  call assert_equal(4, &sw)\n  set sw^=2\n  call assert_equal(8, &sw)\n  set shiftwidth&\nendfunc\n\n\" Test for setting option values using v:false and v:true\nfunc Test_opt_boolean()\n  set number&\n  set number\n  call assert_equal(1, &nu)\n  set nonu\n  call assert_equal(0, &nu)\n  let &nu = v:true\n  call assert_equal(1, &nu)\n  let &nu = v:false\n  call assert_equal(0, &nu)\n  set number&\nendfunc\n\n\" Test for the 'window' option\nfunc Test_window_opt()\n  \" Needs only one open widow\n  %bw!\n  call setline(1, range(1, 8))\n  set window=5\n  exe \"normal \\<C-F>\"\n  call assert_equal(4, line('w0'))\n  exe \"normal \\<C-F>\"\n  call assert_equal(7, line('w0'))\n  exe \"normal \\<C-F>\"\n  call assert_equal(8, line('w0'))\n  exe \"normal \\<C-B>\"\n  call assert_equal(5, line('w0'))\n  exe \"normal \\<C-B>\"\n  call assert_equal(2, line('w0'))\n  exe \"normal \\<C-B>\"\n  call assert_equal(1, line('w0'))\n  set window=1\n  exe \"normal gg\\<C-F>\"\n  call assert_equal(2, line('w0'))\n  exe \"normal \\<C-F>\"\n  call assert_equal(3, line('w0'))\n  exe \"normal \\<C-B>\"\n  call assert_equal(2, line('w0'))\n  exe \"normal \\<C-B>\"\n  call assert_equal(1, line('w0'))\n  enew!\n  set window&\nendfunc\n\n\" Test for the 'winminheight' option\nfunc Test_opt_winminheight()\n  only!\n  let &winheight = &lines + 4\n  call assert_fails('let &winminheight = &lines + 2', 'E36:')\n  call assert_true(&winminheight <= &lines)\n  set winminheight&\n  set winheight&\nendfunc\n\nfunc Test_opt_winminheight_term()\n  CheckRunVimInTerminal\n\n  \" The tabline should be taken into account.\n  let lines =<< trim END\n    set wmh=0 stal=2\n    below sp | wincmd _\n    below sp | wincmd _\n    below sp | wincmd _\n    below sp\n  END\n  call writefile(lines, 'Xwinminheight')\n  let buf = RunVimInTerminal('-S Xwinminheight', #{rows: 11})\n  call term_sendkeys(buf, \":set wmh=1\\n\")\n  call WaitForAssert({-> assert_match('E36: Not enough room', term_getline(buf, 11))})\n\n  call StopVimInTerminal(buf)\n  call delete('Xwinminheight')\nendfunc\n\nfunc Test_opt_winminheight_term_tabs()\n  CheckRunVimInTerminal\n\n  \" The tabline should be taken into account.\n  let lines =<< trim END\n    set wmh=0 stal=2\n    split\n    split\n    split\n    split\n    tabnew\n  END\n  call writefile(lines, 'Xwinminheight')\n  let buf = RunVimInTerminal('-S Xwinminheight', #{rows: 11})\n  call term_sendkeys(buf, \":set wmh=1\\n\")\n  call WaitForAssert({-> assert_match('E36: Not enough room', term_getline(buf, 11))})\n\n  call StopVimInTerminal(buf)\n  call delete('Xwinminheight')\nendfunc\n\n\" Test for the 'winminwidth' option\nfunc Test_opt_winminwidth()\n  only!\n  let &winwidth = &columns + 4\n  call assert_fails('let &winminwidth = &columns + 2', 'E36:')\n  call assert_true(&winminwidth <= &columns)\n  set winminwidth&\n  set winwidth&\nendfunc\n\n\" Test for setting option value containing spaces with isfname+=32\nfunc Test_isfname_with_options()\n  set isfname+=32\n  setlocal keywordprg=:term\\ help.exe\n  call assert_equal(':term help.exe', &keywordprg)\n  set isfname&\n  setlocal keywordprg&\nendfunc\n\n\" Test that resetting laststatus does change scroll option\nfunc Test_opt_reset_scroll()\n  CheckRunVimInTerminal\n  let vimrc =<< trim [CODE]\n    set scroll=2\n    set laststatus=2\n  [CODE]\n  call writefile(vimrc, 'Xscroll')\n  let buf = RunVimInTerminal('-S Xscroll', {'rows': 16, 'cols': 45})\n  call term_sendkeys(buf, \":verbose set scroll?\\n\")\n  call WaitForAssert({-> assert_match('Last set.*window size', term_getline(buf, 15))})\n  call assert_match('^\\s*scroll=7$', term_getline(buf, 14))\n  call StopVimInTerminal(buf)\n\n  \" clean up\n  call delete('Xscroll')\nendfunc\n\n\" Check that VIM_POSIX env variable influences default value of 'cpo' and 'shm'\nfunc Test_VIM_POSIX()\n  let saved_VIM_POSIX = getenv(\"VIM_POSIX\")\n\n  call setenv('VIM_POSIX', \"1\")\n  let after =<< trim [CODE]\n    call writefile([&cpo, &shm], 'X_VIM_POSIX')\n    qall\n  [CODE]\n  if RunVim([], after, '')\n    call assert_equal(['aAbBcCdDeEfFgHiIjJkKlLmMnoOpPqrRsStuvwWxXyZ$!%*-+<>#{|&/\\.;',\n          \\            'AS'], readfile('X_VIM_POSIX'))\n  endif\n\n  call setenv('VIM_POSIX', v:null)\n  let after =<< trim [CODE]\n    call writefile([&cpo, &shm], 'X_VIM_POSIX')\n    qall\n  [CODE]\n  if RunVim([], after, '')\n    call assert_equal(['aAbBcCdDeEfFgHiIjJkKlLmMnoOpPqrRsStuvwWxXyZ$!%*-+<>;',\n          \\            'S'], readfile('X_VIM_POSIX'))\n  endif\n\n  call delete('X_VIM_POSIX')\n  call setenv('VIM_POSIX', saved_VIM_POSIX)\nendfunc\n\n\" Test for setting an option to a Vi or Vim default\nfunc Test_opt_default()\n  set formatoptions&vi\n  call assert_equal('vt', &formatoptions)\n  set formatoptions&vim\n  call assert_equal('tcq', &formatoptions)\n\n  call assert_equal('ucs-bom,utf-8,default,latin1', &fencs)\n  set fencs=latin1\n  set fencs&\n  call assert_equal('ucs-bom,utf-8,default,latin1', &fencs)\n  set fencs=latin1\n  set all&\n  call assert_equal('ucs-bom,utf-8,default,latin1', &fencs)\nendfunc\n\n\" Test for the 'cmdheight' option\nfunc Test_cmdheight()\n  %bw!\n  let ht = &lines\n  set cmdheight=9999\n  call assert_equal(1, winheight(0))\n  call assert_equal(ht - 1, &cmdheight)\n  set cmdheight&\nendfunc\n\n\" To specify a control character as an option value, '^' can be used\nfunc Test_opt_control_char()\n  set wildchar=^v\n  call assert_equal(\"\\<C-V>\", nr2char(&wildchar))\n  set wildcharm=^r\n  call assert_equal(\"\\<C-R>\", nr2char(&wildcharm))\n  \" Bug: This doesn't work for the 'cedit' and 'termwinkey' options\n  set wildchar& wildcharm&\nendfunc\n\n\" Test for the 'errorbells' option\nfunc Test_opt_errorbells()\n  set errorbells\n  call assert_beeps('s/a1b2/x1y2/')\n  set noerrorbells\nendfunc\n\nfunc Test_opt_scrolljump()\n  help\n  resize 10\n\n  \" Test with positive 'scrolljump'.\n  set scrolljump=2\n  norm! Lj\n  call assert_equal({'lnum':11, 'leftcol':0, 'col':0, 'topfill':0,\n        \\            'topline':3, 'coladd':0, 'skipcol':0, 'curswant':0},\n        \\           winsaveview())\n\n  \" Test with negative 'scrolljump' (percentage of window height).\n  set scrolljump=-40\n  norm! ggLj\n  call assert_equal({'lnum':11, 'leftcol':0, 'col':0, 'topfill':0,\n         \\            'topline':5, 'coladd':0, 'skipcol':0, 'curswant':0},\n         \\           winsaveview())\n\n  set scrolljump&\n  bw\nendfunc\n\n\" Test for the 'cdhome' option\nfunc Test_opt_cdhome()\n  if has('unix') || has('vms')\n    throw 'Skipped: only works on non-Unix'\n  endif\n\n  set cdhome&\n  call assert_equal(0, &cdhome)\n  set cdhome\n\n  \" This paragraph is copied from Test_cd_no_arg().\n  let path = getcwd()\n  cd\n  call assert_equal($HOME, getcwd())\n  call assert_notequal(path, getcwd())\n  exe 'cd ' .. fnameescape(path)\n  call assert_equal(path, getcwd())\n\n  set cdhome&\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n */\n\n#ifndef VIM__H\n# define VIM__H\n\n#include \"protodef.h\"\n\n// _WIN32 is defined as 1 when the compilation target is 32-bit or 64-bit.\n// Note: If you want to check for 64-bit use the _WIN64 macro.\n#if defined(WIN32) || defined(_WIN32)\n# define MSWIN\n#endif\n\n#ifdef MSWIN\n# include <io.h>\n#endif\n\n// ============ the header file puzzle: order matters =========\n\n#ifdef HAVE_CONFIG_H\t// GNU autoconf (or something else) was here\n# include \"auto/config.h\"\n# define HAVE_PATHDEF\n\n/*\n * Check if configure correctly managed to find sizeof(int).  If this failed,\n * it becomes zero.  This is likely a problem of not being able to run the\n * test program.  Other items from configure may also be wrong then!\n */\n# if (VIM_SIZEOF_INT == 0)\n#  error configure did not run properly.  Check auto/config.log.\n# endif\n\n# if (defined(__linux__) && !defined(__ANDROID__)) || defined(__CYGWIN__)\n// Needed for strptime().  Needs to be done early, since header files can\n// include other header files and end up including time.h, where these symbols\n// matter for Vim.\n// 700 is needed for mkdtemp().\n#  ifndef _XOPEN_SOURCE\n#   define _XOPEN_SOURCE    700\n\n// On old systems, defining _XOPEN_SOURCE causes _BSD_SOURCE, _SVID_SOURCE\n// and/or // _DEFAULT_SOURCE not to be defined, so do that here.  Those are\n// needed to include nanosecond-resolution timestamps in struct stat.  On new\n// systems, _DEFAULT_SOURCE is needed to avoid warning messages about using\n// deprecated _BSD_SOURCE or _SVID_SOURCE.\n#   ifndef _BSD_SOURCE\n#    define _BSD_SOURCE 1\n#   endif\n#   ifndef _SVID_SOURCE\n#    define _SVID_SOURCE 1\n#   endif\n#   ifndef _DEFAULT_SOURCE\n#    define _DEFAULT_SOURCE 1\n#   endif\n#  endif\n# endif\n\n/*\n * Cygwin may have fchdir() in a newer release, but in most versions it\n * doesn't work well and avoiding it keeps the binary backward compatible.\n */\n# if defined(__CYGWIN32__) && defined(HAVE_FCHDIR)\n#  undef HAVE_FCHDIR\n# endif\n\n// We may need to define the uint32_t on non-Unix system, but using the same\n// identifier causes conflicts.  Therefore use UINT32_T.\n# define UINT32_TYPEDEF uint32_t\n#endif\n\n// for INT_MAX, LONG_MAX et al.\n#include <limits.h>\n\n#if !defined(UINT32_TYPEDEF)\n# if defined(uint32_t)  // this doesn't catch typedefs, unfortunately\n#  define UINT32_TYPEDEF uint32_t\n# else\n  // Fall back to assuming unsigned int is 32 bit.  If this is wrong then the\n  // test in blowfish.c will fail.\n#  define UINT32_TYPEDEF unsigned int\n# endif\n#endif\n\n// user ID of root is usually zero, but not for everybody\n#ifdef __TANDEM\n# ifndef _TANDEM_SOURCE\n#  define _TANDEM_SOURCE\n# endif\n# include <floss.h>\n# define ROOT_UID 65535\n# define OLDXAW\n# if (_TANDEM_ARCH_ == 2 && __H_Series_RVU >= 621)\n#  define SA_ONSTACK_COMPATIBILITY\n# endif\n#else\n# define ROOT_UID 0\n#endif\n\n/*\n * MACOS_X\t    compiling for Mac OS X\n * MACOS_X_DARWIN   integrating the darwin feature into MACOS_X\n */\n#if defined(MACOS_X_DARWIN) && !defined(MACOS_X)\n# define MACOS_X\n#endif\n// Unless made through the Makefile enforce GUI on Mac\n#if defined(MACOS_X) && !defined(HAVE_CONFIG_H)\n# define UNIX\n#endif\n\n#if defined(FEAT_GUI_MOTIF) \\\n    || defined(FEAT_GUI_GTK) \\\n    || defined(FEAT_GUI_ATHENA) \\\n    || defined(FEAT_GUI_HAIKU) \\\n    || defined(FEAT_GUI_MSWIN) \\\n    || defined(FEAT_GUI_PHOTON)\n# define FEAT_GUI_ENABLED  // also defined with NO_X11_INCLUDES\n# if !defined(FEAT_GUI) && !defined(NO_X11_INCLUDES)\n#  define FEAT_GUI\n# endif\n#endif\n\n// Check support for rendering options\n#ifdef FEAT_GUI\n# if defined(FEAT_DIRECTX)\n#  define FEAT_RENDER_OPTIONS\n# endif\n#endif\n\n/*\n * VIM_SIZEOF_INT is used in feature.h, and the system-specific included files\n * need items from feature.h.  Therefore define VIM_SIZEOF_INT here.\n */\n#ifdef MSWIN\n# define VIM_SIZEOF_INT 4\n#endif\n\n#ifdef AMIGA\n  // Be conservative about sizeof(int). It could be 4 too.\n# ifndef FEAT_GUI_GTK\t// avoid problems when generating prototypes\n#  ifdef __GNUC__\n#   define VIM_SIZEOF_INT\t4\n#  else\n#   define VIM_SIZEOF_INT\t2\n#  endif\n# endif\n#endif\n#if defined(MACOS_X) && !defined(HAVE_CONFIG_H)\n#  define VIM_SIZEOF_INT __SIZEOF_INT__\n#endif\n\n#if VIM_SIZEOF_INT < 4 && !defined(PROTO)\n# error Vim only works with 32 bit int or larger\n#endif\n\n/*\n * #defines for optionals and features\n * Also defines FEAT_TINY, FEAT_SMALL, etc. when FEAT_HUGE is defined.\n */\n#include \"feature.h\"\n\n#if defined(MACOS_X_DARWIN)\n# if defined(FEAT_SMALL) && !defined(FEAT_CLIPBOARD)\n#  define FEAT_CLIPBOARD\n# endif\n#endif\n\n// +x11 is only enabled when it's both available and wanted.\n#if defined(HAVE_X11) && defined(WANT_X11)\n# define FEAT_X11\n#endif\n\n#ifdef NO_X11_INCLUDES\n    // In os_mac_conv.c and os_macosx.m NO_X11_INCLUDES is defined to avoid\n    // X11 headers.  Disable all X11 related things to avoid conflicts.\n# ifdef FEAT_X11\n#  undef FEAT_X11\n# endif\n# ifdef FEAT_GUI_X11\n#  undef FEAT_GUI_X11\n# endif\n# ifdef FEAT_XCLIPBOARD\n#  undef FEAT_XCLIPBOARD\n# endif\n# ifdef FEAT_GUI_MOTIF\n#  undef FEAT_GUI_MOTIF\n# endif\n# ifdef FEAT_GUI_ATHENA\n#  undef FEAT_GUI_ATHENA\n# endif\n# ifdef FEAT_GUI_GTK\n#  undef FEAT_GUI_GTK\n# endif\n# ifdef FEAT_BEVAL_TIP\n#  undef FEAT_BEVAL_TIP\n# endif\n# ifdef FEAT_XIM\n#  undef FEAT_XIM\n# endif\n# ifdef FEAT_CLIENTSERVER\n#  undef FEAT_CLIENTSERVER\n# endif\n#endif\n\n// The Mac conversion stuff doesn't work under X11.\n#if defined(MACOS_X_DARWIN)\n# define MACOS_CONVERT\n#endif\n\n// Can't use \"PACKAGE\" here, conflicts with a Perl include file.\n#ifndef VIMPACKAGE\n# define VIMPACKAGE\t\"vim\"\n#endif\n\n/*\n * Find out if function definitions should include argument types\n */\n#ifdef AZTEC_C\n# include <functions.h>\n#endif\n\n#ifdef SASC\n# include <clib/exec_protos.h>\n#endif\n\n#ifdef _DCC\n# include <clib/exec_protos.h>\n#endif\n\n#ifdef __HAIKU__\n# include \"os_haiku.h\"\n# define __ARGS(x)  x\n#endif\n\n#if (defined(UNIX) || defined(VMS)) \\\n\t&& (!defined(MACOS_X) || defined(HAVE_CONFIG_H))\n# include \"os_unix.h\"\t    // bring lots of system header files\n#endif\n\n// Mark unused function arguments with UNUSED, so that gcc -Wunused-parameter\n// can be used to check for mistakes.\n#if defined(HAVE_ATTRIBUTE_UNUSED) || defined(__MINGW32__)\n# if !defined(UNUSED)\n#  define UNUSED __attribute__((unused))\n# endif\n#else\n# define UNUSED\n#endif\n\n// Used to check for \"sun\", \"__sun\" is used by newer compilers.\n#if defined(__sun)\n# define SUN_SYSTEM\n#endif\n\n// If we're compiling in C++ (currently only KVim), the system\n// headers must have the correct prototypes or nothing will build.\n// Conversely, our prototypes might clash due to throw() specifiers and\n// cause compilation failures even though the headers are correct.  For\n// a concrete example, gcc-3.2 enforces exception specifications, and\n// glibc-2.2.5 has them in their system headers.\n#if !defined(__cplusplus) && defined(UNIX) \\\n\t&& !defined(MACOS_X) // MACOS_X doesn't yet support osdef.h\n# include \"auto/osdef.h\"\t// bring missing declarations in\n#endif\n\n#ifdef AMIGA\n# include \"os_amiga.h\"\n#endif\n\n#ifdef MSWIN\n# include \"os_win32.h\"\n#endif\n\n#if defined(MACOS_X)\n# include \"os_mac.h\"\n#endif\n\n#ifdef __QNX__\n# include \"os_qnx.h\"\n#endif\n\n#ifdef X_LOCALE\n# include <X11/Xlocale.h>\n#else\n# ifdef HAVE_LOCALE_H\n#  include <locale.h>\n# endif\n#endif\n\n/*\n * Maximum length of a path (for non-unix systems) Make it a bit long, to stay\n * on the safe side.  But not too long to put on the stack.\n */\n#ifndef MAXPATHL\n# ifdef MAXPATHLEN\n#  define MAXPATHL  MAXPATHLEN\n# else\n#  define MAXPATHL  256\n# endif\n#endif\n#ifdef BACKSLASH_IN_FILENAME\n# define PATH_ESC_CHARS ((char_u *)\" \\t\\n*?[{`%#'\\\"|!<\")\n# define BUFFER_ESC_CHARS ((char_u *)\" \\t\\n*?[`%#'\\\"|!<\")\n#else\n# ifdef VMS\n    // VMS allows a lot of characters in the file name\n#  define PATH_ESC_CHARS ((char_u *)\" \\t\\n*?{`\\\\%#'\\\"|!\")\n#  define SHELL_ESC_CHARS ((char_u *)\" \\t\\n*?{`\\\\%#'|!()&\")\n# else\n#  define PATH_ESC_CHARS ((char_u *)\" \\t\\n*?[{`$\\\\%#'\\\"|!<\")\n#  define SHELL_ESC_CHARS ((char_u *)\" \\t\\n*?[{`$\\\\%#'\\\"|!<>();&\")\n# endif\n#  define BUFFER_ESC_CHARS ((char_u *)\" \\t\\n*?[`$\\\\%#'\\\"|!<\")\n#endif\n\n// length of a buffer to store a number in ASCII (64 bits binary + NUL)\n#define NUMBUFLEN 65\n\n// flags for vim_str2nr()\n#define STR2NR_BIN  0x01\n#define STR2NR_OCT  0x02\n#define STR2NR_HEX  0x04\n#define STR2NR_OOCT 0x08    // Octal with prefix \"0o\": 0o777\n#define STR2NR_ALL (STR2NR_BIN + STR2NR_OCT + STR2NR_HEX + STR2NR_OOCT)\n#define STR2NR_NO_OCT (STR2NR_BIN + STR2NR_HEX + STR2NR_OOCT)\n\n#define STR2NR_FORCE 0x80   // only when ONE of the above is used\n\n#define STR2NR_QUOTE 0x10   // ignore embedded single quotes\n\n/*\n * Shorthand for unsigned variables. Many systems, but not all, have u_char\n * already defined, so we use char_u to avoid trouble.\n */\ntypedef unsigned char\tchar_u;\ntypedef unsigned short\tshort_u;\ntypedef unsigned int\tint_u;\n\n// Make sure long_u is big enough to hold a pointer.\n// On Win64, longs are 32 bits and pointers are 64 bits.\n// For printf() and scanf(), we need to take care of long_u specifically.\n#ifdef _WIN64\ntypedef unsigned __int64\tlong_u;\ntypedef\t\t __int64\tlong_i;\n# define SCANF_HEX_LONG_U       \"%llx\"\n# define SCANF_DECIMAL_LONG_U   \"%llu\"\n# define PRINTF_HEX_LONG_U      \"0x%llx\"\n#else\ntypedef unsigned long\t\tlong_u;\ntypedef\t\t long\t\tlong_i;\n# define SCANF_HEX_LONG_U       \"%lx\"\n# define SCANF_DECIMAL_LONG_U   \"%lu\"\n# define PRINTF_HEX_LONG_U      \"0x%lx\"\n#endif\n#define PRINTF_DECIMAL_LONG_U SCANF_DECIMAL_LONG_U\n\n/*\n * Only systems which use configure will have SIZEOF_OFF_T and VIM_SIZEOF_LONG\n * defined, which is ok since those are the same systems which can have\n * varying sizes for off_t.  The other systems will continue to use \"%ld\" to\n * print off_t since off_t is simply a typedef to long for them.\n */\n#if defined(SIZEOF_OFF_T) && (SIZEOF_OFF_T > VIM_SIZEOF_LONG)\n# define LONG_LONG_OFF_T\n#endif\n\n/*\n * We use 64-bit file functions here, if available.  E.g. ftello() returns\n * off_t instead of long, which helps if long is 32 bit and off_t is 64 bit.\n * We assume that when fseeko() is available then ftello() is too.\n * Note that Windows has different function names.\n */\n#ifdef MSWIN\ntypedef __int64 off_T;\n# ifdef __MINGW32__\n#  define vim_lseek lseek64\n#  define vim_fseek fseeko64\n#  define vim_ftell ftello64\n# else\n#  define vim_lseek _lseeki64\n#  define vim_fseek _fseeki64\n#  define vim_ftell _ftelli64\n# endif\n#else\n# ifdef PROTO\ntypedef long off_T;\n# else\ntypedef off_t off_T;\n# endif\n# ifdef HAVE_FSEEKO\n#  define vim_lseek lseek\n#  define vim_ftell ftello\n#  define vim_fseek fseeko\n# else\n#  define vim_lseek lseek\n#  define vim_ftell ftell\n#  define vim_fseek(a, b, c)\tfseek(a, (long)b, c)\n# endif\n#endif\n\n/*\n * The characters and attributes cached for the screen.\n */\ntypedef char_u schar_T;\ntypedef unsigned short sattr_T;\n#define MAX_TYPENR 65535\n\n/*\n * The u8char_T can hold one decoded UTF-8 character.\n * We use 32 bits, since some Asian characters don't fit in 16 bits.\n */\ntypedef unsigned int u8char_T;\t// int is 32 bits or more\n\n#ifndef UNIX\t\t    // For Unix this is included in os_unix.h\n# include <stdio.h>\n# include <ctype.h>\n#endif\n\n#include \"ascii.h\"\n#include \"keymap.h\"\n#include \"termdefs.h\"\n#include \"macros.h\"\n\n#ifdef LATTICE\n# include <sys/types.h>\n# include <sys/stat.h>\n#endif\n#ifdef _DCC\n# include <sys/stat.h>\n#endif\n#if defined(MSWIN)\n# include <sys/stat.h>\n#endif\n\n#if defined(HAVE_ERRNO_H) || defined(MSWIN)\n# include <errno.h>\n#endif\n\n/*\n * Allow other (non-unix) systems to configure themselves now\n * These are also in os_unix.h, because osdef.sh needs them there.\n */\n#ifndef UNIX\n// Note: Some systems need both string.h and strings.h (Savage).  If the\n// system can't handle this, define NO_STRINGS_WITH_STRING_H.\n# ifdef HAVE_STRING_H\n#  include <string.h>\n# endif\n# if defined(HAVE_STRINGS_H) && !defined(NO_STRINGS_WITH_STRING_H)\n#  include <strings.h>\n# endif\n# ifdef HAVE_STAT_H\n#  include <stat.h>\n# endif\n# ifdef HAVE_STDLIB_H\n#  include <stdlib.h>\n# endif\n#endif // NON-UNIX\n\n#include <assert.h>\n\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n#ifdef HAVE_INTTYPES_H\n# include <inttypes.h>\n#endif\n#ifdef HAVE_WCTYPE_H\n# include <wctype.h>\n#endif\n#include <stdarg.h>\n\n// for offsetof()\n#include <stddef.h>\n\n#if defined(HAVE_SYS_SELECT_H) && \\\n\t(!defined(HAVE_SYS_TIME_H) || defined(SYS_SELECT_WITH_SYS_TIME))\n# include <sys/select.h>\n#endif\n\n#ifndef HAVE_SELECT\n# ifdef HAVE_SYS_POLL_H\n#  include <sys/poll.h>\n# elif defined(MSWIN)\n#  define HAVE_SELECT\n# else\n#  ifdef HAVE_POLL_H\n#   include <poll.h>\n#  endif\n# endif\n#endif\n\n#ifdef HAVE_SODIUM\n# include <sodium.h>\n#endif\n\n// ================ end of the header file puzzle ===============\n\n/*\n * For dynamically loaded imm library. Currently, only for Win32.\n */\n#ifdef DYNAMIC_IME\n# ifndef FEAT_MBYTE_IME\n#  define FEAT_MBYTE_IME\n# endif\n#endif\n\n/*\n * For dynamically loaded gettext library.  Currently, only for Win32.\n */\n#ifdef DYNAMIC_GETTEXT\n# ifndef FEAT_GETTEXT\n#  define FEAT_GETTEXT\n# endif\n// These are in os_win32.c\nextern char *(*dyn_libintl_gettext)(const char *msgid);\nextern char *(*dyn_libintl_ngettext)(const char *msgid, const char *msgid_plural, unsigned long n);\nextern char *(*dyn_libintl_bindtextdomain)(const char *domainname, const char *dirname);\nextern char *(*dyn_libintl_bind_textdomain_codeset)(const char *domainname, const char *codeset);\nextern char *(*dyn_libintl_textdomain)(const char *domainname);\nextern int (*dyn_libintl_wputenv)(const wchar_t *envstring);\n#endif\n\n\n/*\n * The _() stuff is for using gettext().  It is a no-op when libintl.h is not\n * found or the +multilang feature is disabled.\n * Use NGETTEXT(single, multi, number) to get plural behavior:\n * - single - message for singular form\n * - multi  - message for plural form\n * - number - the count\n */\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n#  define _(x) (*dyn_libintl_gettext)((char *)(x))\n#  define NGETTEXT(x, xs, n) (*dyn_libintl_ngettext)((char *)(x), (char *)(xs), (n))\n#  define N_(x) x\n#  define bindtextdomain(domain, dir) (*dyn_libintl_bindtextdomain)((domain), (dir))\n#  define bind_textdomain_codeset(domain, codeset) (*dyn_libintl_bind_textdomain_codeset)((domain), (codeset))\n#  if !defined(HAVE_BIND_TEXTDOMAIN_CODESET)\n#   define HAVE_BIND_TEXTDOMAIN_CODESET 1\n#  endif\n#  define textdomain(domain) (*dyn_libintl_textdomain)(domain)\n#  define libintl_wputenv(envstring) (*dyn_libintl_wputenv)(envstring)\n# else\n#  include <libintl.h>\n#  define _(x) gettext((char *)(x))\n#  define NGETTEXT(x, xs, n) ngettext((x), (xs), (n))\n#  ifdef gettext_noop\n#   define N_(x) gettext_noop(x)\n#  else\n#   define N_(x) x\n#  endif\n# endif\n#else\n# define _(x) ((char *)(x))\n# define NGETTEXT(x, xs, n) (((n) == 1) ? (char *)(x) : (char *)(xs))\n# define N_(x) x\n# ifdef bindtextdomain\n#  undef bindtextdomain\n# endif\n# define bindtextdomain(x, y) // empty\n# ifdef bind_textdomain_codeset\n#  undef bind_textdomain_codeset\n# endif\n# define bind_textdomain_codeset(x, y) // empty\n# ifdef textdomain\n#  undef textdomain\n# endif\n# define textdomain(x) // empty\n#endif\n\n/*\n * flags for update_screen()\n * The higher the value, the higher the priority\n */\n#define VALID_NO_UPDATE\t\t 5  // no new changes, keep the command line if\n\t\t\t\t    // possible\n#define VALID\t\t\t10  // buffer not changed, or changes marked\n\t\t\t\t    // with b_mod_*\n#define INVERTED\t\t20  // redisplay inverted part that changed\n#define INVERTED_ALL\t\t25  // redisplay whole inverted part\n#define REDRAW_TOP\t\t30  // display first w_upd_rows screen lines\n#define SOME_VALID\t\t35  // like NOT_VALID but may scroll\n#define NOT_VALID\t\t40  // buffer needs complete redraw\n#define CLEAR\t\t\t50  // screen messed up, clear it\n\n// flags for screen_line()\n#define SLF_RIGHTLEFT\t1\n#define SLF_POPUP\t2\n\n#define MB_FILLER_CHAR '<'  // character used when a double-width character\n\t\t\t    // doesn't fit.\n\n/*\n * Flags for w_valid.\n * These are set when something in a window structure becomes invalid, except\n * when the cursor is moved.  Call check_cursor_moved() before testing one of\n * the flags.\n * These are reset when that thing has been updated and is valid again.\n *\n * Every function that invalidates one of these must call one of the\n * invalidate_* functions.\n *\n * w_valid is supposed to be used only in screen.c.  From other files, use the\n * functions that set or reset the flags.\n *\n * VALID_BOTLINE    VALID_BOTLINE_AP\n *     on\t\ton\t\tw_botline valid\n *     off\t\ton\t\tw_botline approximated\n *     off\t\toff\t\tw_botline not valid\n *     on\t\toff\t\tnot possible\n */\n#define VALID_WROW\t0x01\t// w_wrow (window row) is valid\n#define VALID_WCOL\t0x02\t// w_wcol (window col) is valid\n#define VALID_VIRTCOL\t0x04\t// w_virtcol (file col) is valid\n#define VALID_CHEIGHT\t0x08\t// w_cline_height and w_cline_folded valid\n#define VALID_CROW\t0x10\t// w_cline_row is valid\n#define VALID_BOTLINE\t0x20\t// w_botine and w_empty_rows are valid\n#define VALID_BOTLINE_AP 0x40\t// w_botine is approximated\n#define VALID_TOPLINE\t0x80\t// w_topline is valid (for cursor position)\n\n// Values for w_popup_flags.\n#define POPF_IS_POPUP\t0x01\t// this is a popup window\n#define POPF_HIDDEN\t0x02\t// popup is not displayed\n#define POPF_CURSORLINE\t0x04\t// popup is highlighting at the cursorline\n#define POPF_ON_CMDLINE\t0x08\t// popup overlaps command line\n#define POPF_DRAG\t0x10\t// popup can be moved by dragging border\n#define POPF_DRAGALL\t0x20\t// popup can be moved by dragging everywhere\n#define POPF_RESIZE\t0x40\t// popup can be resized by dragging\n#define POPF_MAPPING\t0x80\t// mapping keys\n#define POPF_INFO\t0x100\t// used for info of popup menu\n#define POPF_INFO_MENU\t0x200\t// align info popup with popup menu\n#define POPF_POSINVERT\t0x400\t// vertical position can be inverted\n\n// flags used in w_popup_handled\n#define POPUP_HANDLED_1\t    0x01    // used by mouse_find_win()\n#define POPUP_HANDLED_2\t    0x02    // used by popup_do_filter()\n#define POPUP_HANDLED_3\t    0x04    // used by popup_check_cursor_pos()\n#define POPUP_HANDLED_4\t    0x08    // used by may_update_popup_mask()\n#define POPUP_HANDLED_5\t    0x10    // used by update_popups()\n\n/*\n * Terminal highlighting attribute bits.\n * Attributes above HL_ALL are used for syntax highlighting.\n */\n#define HL_NORMAL\t\t0x00\n#define HL_INVERSE\t\t0x01\n#define HL_BOLD\t\t\t0x02\n#define HL_ITALIC\t\t0x04\n#define HL_UNDERLINE\t\t0x08\n#define HL_UNDERCURL\t\t0x10\n#define HL_STANDOUT\t\t0x20\n#define HL_NOCOMBINE\t\t0x40\n#define HL_STRIKETHROUGH\t0x80\n#define HL_ALL\t\t\t0xff\n\n// special attribute addition: Put message in history\n#define MSG_HIST\t\t0x1000\n\n/*\n * values for State\n *\n * The lower bits up to 0x20 are used to distinguish normal/visual/op_pending\n * and cmdline/insert+replace mode.  This is used for mapping.  If none of\n * these bits are set, no mapping is done.\n * The upper bits are used to distinguish between other states.\n */\n#define NORMAL\t\t0x01\t// Normal mode, command expected\n#define VISUAL\t\t0x02\t// Visual mode - use get_real_state()\n#define OP_PENDING\t0x04\t// Normal mode, operator is pending - use\n\t\t\t\t// get_real_state()\n#define CMDLINE\t\t0x08\t// Editing command line\n#define INSERT\t\t0x10\t// Insert mode\n#define LANGMAP\t\t0x20\t// Language mapping, can be combined with\n\t\t\t\t// INSERT and CMDLINE\n\n#define REPLACE_FLAG\t0x40\t// Replace mode flag\n#define REPLACE\t\t(REPLACE_FLAG + INSERT)\n#define VREPLACE_FLAG\t0x80\t// Virtual-replace mode flag\n#define VREPLACE\t(REPLACE_FLAG + VREPLACE_FLAG + INSERT)\n#define LREPLACE\t(REPLACE_FLAG + LANGMAP)\n\n#define NORMAL_BUSY\t(0x100 + NORMAL) // Normal mode, busy with a command\n#define HITRETURN\t(0x200 + NORMAL) // waiting for return or command\n#define ASKMORE\t\t0x300\t// Asking if you want --more--\n#define SETWSIZE\t0x400\t// window size has changed\n#define ABBREV\t\t0x500\t// abbreviation instead of mapping\n#define EXTERNCMD\t0x600\t// executing an external command\n#define SHOWMATCH\t(0x700 + INSERT) // show matching paren\n#define CONFIRM\t\t0x800\t// \":confirm\" prompt\n#define SELECTMODE\t0x1000\t// Select mode, only for mappings\n#define TERMINAL        0x2000  // Terminal mode\n#define MODE_ALL\t0xffff\n\n#define MODE_MAX_LENGTH\t4\t// max mode length returned in mode()\n\n// all mode bits used for mapping\n#define MAP_ALL_MODES\t(0x3f | SELECTMODE | TERMINAL)\n\n// directions\n#define FORWARD\t\t\t1\n#define BACKWARD\t\t(-1)\n#define FORWARD_FILE\t\t3\n#define BACKWARD_FILE\t\t(-3)\n\n// return values for functions\n#if !(defined(OK) && (OK == 1))\n// OK already defined to 1 in MacOS X curses, skip this\n# define OK\t\t\t1\n#endif\n#define FAIL\t\t\t0\n#define NOTDONE\t\t\t2   // not OK or FAIL but skipped\n\n// flags for b_flags\n#define BF_RECOVERED\t0x01\t// buffer has been recovered\n#define BF_CHECK_RO\t0x02\t// need to check readonly when loading file\n\t\t\t\t// into buffer (set by \":e\", may be reset by\n\t\t\t\t// \":buf\"\n#define BF_NEVERLOADED\t0x04\t// file has never been loaded into buffer,\n\t\t\t\t// many variables still need to be set\n#define BF_NOTEDITED\t0x08\t// Set when file name is changed after\n\t\t\t\t// starting to edit, reset when file is\n\t\t\t\t// written out.\n#define BF_NEW\t\t0x10\t// file didn't exist when editing started\n#define BF_NEW_W\t0x20\t// Warned for BF_NEW and file created\n#define BF_READERR\t0x40\t// got errors while reading the file\n#define BF_DUMMY\t0x80\t// dummy buffer, only used internally\n#define BF_PRESERVED\t0x100\t// \":preserve\" was used\n#define BF_SYN_SET\t0x200\t// 'syntax' option was set\n#define BF_NO_SEA\t0x400\t// no swap_exists_action (ATTENTION prompt)\n\n// Mask to check for flags that prevent normal writing\n#define BF_WRITE_MASK\t(BF_NOTEDITED + BF_NEW + BF_READERR)\n\n/*\n * values for xp_context when doing command line completion\n */\n#define EXPAND_UNSUCCESSFUL\t(-2)\n#define EXPAND_OK\t\t(-1)\n#define EXPAND_NOTHING\t\t0\n#define EXPAND_COMMANDS\t\t1\n#define EXPAND_FILES\t\t2\n#define EXPAND_DIRECTORIES\t3\n#define EXPAND_SETTINGS\t\t4\n#define EXPAND_BOOL_SETTINGS\t5\n#define EXPAND_TAGS\t\t6\n#define EXPAND_OLD_SETTING\t7\n#define EXPAND_HELP\t\t8\n#define EXPAND_BUFFERS\t\t9\n#define EXPAND_EVENTS\t\t10\n#define EXPAND_MENUS\t\t11\n#define EXPAND_SYNTAX\t\t12\n#define EXPAND_HIGHLIGHT\t13\n#define EXPAND_AUGROUP\t\t14\n#define EXPAND_USER_VARS\t15\n#define EXPAND_MAPPINGS\t\t16\n#define EXPAND_TAGS_LISTFILES\t17\n#define EXPAND_FUNCTIONS\t18\n#define EXPAND_USER_FUNC\t19\n#define EXPAND_EXPRESSION\t20\n#define EXPAND_MENUNAMES\t21\n#define EXPAND_USER_COMMANDS\t22\n#define EXPAND_USER_CMD_FLAGS\t23\n#define EXPAND_USER_NARGS\t24\n#define EXPAND_USER_COMPLETE\t25\n#define EXPAND_ENV_VARS\t\t26\n#define EXPAND_LANGUAGE\t\t27\n#define EXPAND_COLORS\t\t28\n#define EXPAND_COMPILER\t\t29\n#define EXPAND_USER_DEFINED\t30\n#define EXPAND_USER_LIST\t31\n#define EXPAND_SHELLCMD\t\t32\n#define EXPAND_CSCOPE\t\t33\n#define EXPAND_SIGN\t\t34\n#define EXPAND_PROFILE\t\t35\n#define EXPAND_BEHAVE\t\t36\n#define EXPAND_FILETYPE\t\t37\n#define EXPAND_FILES_IN_PATH\t38\n#define EXPAND_OWNSYNTAX\t39\n#define EXPAND_LOCALES\t\t40\n#define EXPAND_HISTORY\t\t41\n#define EXPAND_USER\t\t42\n#define EXPAND_SYNTIME\t\t43\n#define EXPAND_USER_ADDR_TYPE\t44\n#define EXPAND_PACKADD\t\t45\n#define EXPAND_MESSAGES\t\t46\n#define EXPAND_MAPCLEAR\t\t47\n#define EXPAND_ARGLIST\t\t48\n#define EXPAND_DIFF_BUFFERS\t49\n#define EXPAND_DISASSEMBLE\t50\n\n// Values for exmode_active (0 is no exmode)\n#define EXMODE_NORMAL\t\t1\n#define EXMODE_VIM\t\t2\n\n// Values for nextwild() and ExpandOne().  See ExpandOne() for meaning.\n#define WILD_FREE\t\t1\n#define WILD_EXPAND_FREE\t2\n#define WILD_EXPAND_KEEP\t3\n#define WILD_NEXT\t\t4\n#define WILD_PREV\t\t5\n#define WILD_ALL\t\t6\n#define WILD_LONGEST\t\t7\n#define WILD_ALL_KEEP\t\t8\n\n#define WILD_LIST_NOTFOUND\t    0x01\n#define WILD_HOME_REPLACE\t    0x02\n#define WILD_USE_NL\t\t    0x04\n#define WILD_NO_BEEP\t\t    0x08\n#define WILD_ADD_SLASH\t\t    0x10\n#define WILD_KEEP_ALL\t\t    0x20\n#define WILD_SILENT\t\t    0x40\n#define WILD_ESCAPE\t\t    0x80\n#define WILD_ICASE\t\t    0x100\n#define WILD_ALLLINKS\t\t    0x200\n#define WILD_IGNORE_COMPLETESLASH   0x400\n#define WILD_NOERROR\t\t    0x800  // sets EW_NOERROR\n#define WILD_BUFLASTUSED\t    0x1000\n#define BUF_DIFF_FILTER\t\t    0x2000\n\n// Flags for expand_wildcards()\n#define EW_DIR\t\t0x01\t// include directory names\n#define EW_FILE\t\t0x02\t// include file names\n#define EW_NOTFOUND\t0x04\t// include not found names\n#define EW_ADDSLASH\t0x08\t// append slash to directory name\n#define EW_KEEPALL\t0x10\t// keep all matches\n#define EW_SILENT\t0x20\t// don't print \"1 returned\" from shell\n#define EW_EXEC\t\t0x40\t// executable files\n#define EW_PATH\t\t0x80\t// search in 'path' too\n#define EW_ICASE\t0x100\t// ignore case\n#define EW_NOERROR\t0x200\t// no error for bad regexp\n#define EW_NOTWILD\t0x400\t// add match with literal name if exists\n#define EW_KEEPDOLLAR\t0x800\t// do not escape $, $var is expanded\n// Note: mostly EW_NOTFOUND and EW_SILENT are mutually exclusive: EW_NOTFOUND\n// is used when executing commands and EW_SILENT for interactive expanding.\n#define EW_ALLLINKS\t0x1000\t// also links not pointing to existing file\n#define EW_SHELLCMD\t0x2000\t// called from expand_shellcmd(), don't check\n\t\t\t\t// if executable is in $PATH\n#define EW_DODOT\t0x4000\t// also files starting with a dot\n#define EW_EMPTYOK\t0x8000\t// no matches is not an error\n#define EW_NOTENV\t0x10000\t// do not expand environment variables\n\n// Flags for find_file_*() functions.\n#define FINDFILE_FILE\t0\t// only files\n#define FINDFILE_DIR\t1\t// only directories\n#define FINDFILE_BOTH\t2\t// files and directories\n\n#define W_ENDCOL(wp)\t(wp->w_wincol + wp->w_width)\n#ifdef FEAT_MENU\n# define W_WINROW(wp)\t(wp->w_winrow + wp->w_winbar_height)\n#else\n# define W_WINROW(wp)\t(wp->w_winrow)\n#endif\n\n// Values for the find_pattern_in_path() function args 'type' and 'action':\n#define FIND_ANY\t1\n#define FIND_DEFINE\t2\n#define CHECK_PATH\t3\n\n#define ACTION_SHOW\t1\n#define ACTION_GOTO\t2\n#define ACTION_SPLIT\t3\n#define ACTION_SHOW_ALL\t4\n#define ACTION_EXPAND\t5\n\n#ifdef FEAT_SYN_HL\n# define SST_MIN_ENTRIES 150\t// minimal size for state stack array\n# define SST_MAX_ENTRIES 1000\t// maximal size for state stack array\n# define SST_FIX_STATES\t 7\t// size of sst_stack[].\n# define SST_DIST\t 16\t// normal distance between entries\n# define SST_INVALID\t(synstate_T *)-1\t// invalid syn_state pointer\n\n# define HL_CONTAINED\t0x01\t// not used on toplevel\n# define HL_TRANSP\t0x02\t// has no highlighting\n# define HL_ONELINE\t0x04\t// match within one line only\n# define HL_HAS_EOL\t0x08\t// end pattern that matches with $\n# define HL_SYNC_HERE\t0x10\t// sync point after this item (syncing only)\n# define HL_SYNC_THERE\t0x20\t// sync point at current line (syncing only)\n# define HL_MATCH\t0x40\t// use match ID instead of item ID\n# define HL_SKIPNL\t0x80\t// nextgroup can skip newlines\n# define HL_SKIPWHITE\t0x100\t// nextgroup can skip white space\n# define HL_SKIPEMPTY\t0x200\t// nextgroup can skip empty lines\n# define HL_KEEPEND\t0x400\t// end match always kept\n# define HL_EXCLUDENL\t0x800\t// exclude NL from match\n# define HL_DISPLAY\t0x1000\t// only used for displaying, not syncing\n# define HL_FOLD\t0x2000\t// define fold\n# define HL_EXTEND\t0x4000\t// ignore a keepend\n# define HL_MATCHCONT\t0x8000\t// match continued from previous line\n# define HL_TRANS_CONT\t0x10000 // transparent item without contains arg\n# define HL_CONCEAL\t0x20000 // can be concealed\n# define HL_CONCEALENDS\t0x40000 // can be concealed\n#endif\n\n// Values for 'options' argument in do_search() and searchit()\n#define SEARCH_REV    0x01  // go in reverse of previous dir.\n#define SEARCH_ECHO   0x02  // echo the search command and handle options\n#define SEARCH_MSG    0x0c  // give messages (yes, it's not 0x04)\n#define SEARCH_NFMSG  0x08  // give all messages except not found\n#define SEARCH_OPT    0x10  // interpret optional flags\n#define SEARCH_HIS    0x20  // put search pattern in history\n#define SEARCH_END    0x40  // put cursor at end of match\n#define SEARCH_NOOF   0x80  // don't add offset to position\n#define SEARCH_START 0x100  // start search without col offset\n#define SEARCH_MARK  0x200  // set previous context mark\n#define SEARCH_KEEP  0x400  // keep previous search pattern\n#define SEARCH_PEEK  0x800  // peek for typed char, cancel search\n#define SEARCH_COL  0x1000  // start at specified column instead of zero\n\n// Values for find_ident_under_cursor()\n#define FIND_IDENT\t1\t// find identifier (word)\n#define FIND_STRING\t2\t// find any string (WORD)\n#define FIND_EVAL\t4\t// include \"->\", \"[]\" and \".\"\n#define FIND_NOERROR\t8\t// no error when no word found\n\n// Values for file_name_in_line()\n#define FNAME_MESS\t1\t// give error message\n#define FNAME_EXP\t2\t// expand to path\n#define FNAME_HYP\t4\t// check for hypertext link\n#define FNAME_INCL\t8\t// apply 'includeexpr'\n#define FNAME_REL\t16\t// \"..\" and \"./\" are relative to the (current)\n\t\t\t\t// file instead of the current directory\n#define FNAME_UNESC\t32\t// remove backslashes used for escaping\n\n// Values for buflist_getfile()\n#define GETF_SETMARK\t0x01\t// set pcmark before jumping\n#define GETF_ALT\t0x02\t// jumping to alternate file (not buf num)\n#define GETF_SWITCH\t0x04\t// respect 'switchbuf' settings when jumping\n\n// Return values of getfile()\n#define GETFILE_ERROR\t    1\t// normal error\n#define GETFILE_NOT_WRITTEN 2\t// \"not written\" error\n#define GETFILE_SAME_FILE   0\t// success, same file\n#define GETFILE_OPEN_OTHER -1\t// success, opened another file\n#define GETFILE_UNUSED\t    8\n#define GETFILE_SUCCESS(x)  ((x) <= 0)\n\n// Values for buflist_new() flags\n#define BLN_CURBUF\t1\t// may re-use curbuf for new buffer\n#define BLN_LISTED\t2\t// put new buffer in buffer list\n#define BLN_DUMMY\t4\t// allocating dummy buffer\n#define BLN_NEW\t\t8\t// create a new buffer\n#define BLN_NOOPT\t16\t// don't copy options to existing buffer\n#define BLN_DUMMY_OK\t32\t// also find an existing dummy buffer\n#define BLN_REUSE\t64\t// may re-use number from buf_reuse\n#define BLN_NOCURWIN\t128\t// buffer is not associated with curwin\n\n// Values for in_cinkeys()\n#define KEY_OPEN_FORW\t0x101\n#define KEY_OPEN_BACK\t0x102\n#define KEY_COMPLETE\t0x103\t// end of completion\n\n// Values for \"noremap\" argument of ins_typebuf().  Also used for\n// map->m_noremap and menu->noremap[].\n#define REMAP_YES\t0\t// allow remapping\n#define REMAP_NONE\t-1\t// no remapping\n#define REMAP_SCRIPT\t-2\t// remap script-local mappings only\n#define REMAP_SKIP\t-3\t// no remapping for first char\n\n// Values for mch_call_shell() second argument\n#define SHELL_FILTER\t1\t// filtering text\n#define SHELL_EXPAND\t2\t// expanding wildcards\n#define SHELL_COOKED\t4\t// set term to cooked mode\n#define SHELL_DOOUT\t8\t// redirecting output\n#define SHELL_SILENT\t16\t// don't print error returned by command\n#define SHELL_READ\t32\t// read lines and insert into buffer\n#define SHELL_WRITE\t64\t// write lines from buffer\n\n// Values returned by mch_nodetype()\n#define NODE_NORMAL\t0\t// file or directory, check with mch_isdir()\n#define NODE_WRITABLE\t1\t// something we can write to (character\n\t\t\t\t// device, fifo, socket, ..)\n#define NODE_OTHER\t2\t// non-writable thing (e.g., block device)\n\n// Values for readfile() flags\n#define READ_NEW\t0x01\t// read a file into a new buffer\n#define READ_FILTER\t0x02\t// read filter output\n#define READ_STDIN\t0x04\t// read from stdin\n#define READ_BUFFER\t0x08\t// read from curbuf (converting stdin)\n#define READ_DUMMY\t0x10\t// reading into a dummy buffer\n#define READ_KEEP_UNDO\t0x20\t// keep undo info\n#define READ_FIFO\t0x40\t// read from fifo or socket\n#define READ_NOWINENTER 0x80\t// do not trigger BufWinEnter\n\n// Values for change_indent()\n#define INDENT_SET\t1\t// set indent\n#define INDENT_INC\t2\t// increase indent\n#define INDENT_DEC\t3\t// decrease indent\n\n// Values for flags argument for findmatchlimit()\n#define FM_BACKWARD\t0x01\t// search backwards\n#define FM_FORWARD\t0x02\t// search forwards\n#define FM_BLOCKSTOP\t0x04\t// stop at start/end of block\n#define FM_SKIPCOMM\t0x08\t// skip comments\n\n// Values for action argument for do_buffer() and close_buffer()\n#define DOBUF_GOTO\t0\t// go to specified buffer\n#define DOBUF_SPLIT\t1\t// split window and go to specified buffer\n#define DOBUF_UNLOAD\t2\t// unload specified buffer(s)\n#define DOBUF_DEL\t3\t// delete specified buffer(s) from buflist\n#define DOBUF_WIPE\t4\t// delete specified buffer(s) really\n#define DOBUF_WIPE_REUSE 5\t// like DOBUF_WIPE and keep number for reuse\n\n// Values for start argument for do_buffer()\n#define DOBUF_CURRENT\t0\t// \"count\" buffer from current buffer\n#define DOBUF_FIRST\t1\t// \"count\" buffer from first buffer\n#define DOBUF_LAST\t2\t// \"count\" buffer from last buffer\n#define DOBUF_MOD\t3\t// \"count\" mod. buffer from current buffer\n\n// Values for flags argument of do_buffer()\n#define DOBUF_FORCEIT\t1\t// :cmd!\n#define DOBUF_NOPOPUP\t2\t// skip popup window buffers\n\n// Values for sub_cmd and which_pat argument for search_regcomp()\n// Also used for which_pat argument for searchit()\n#define RE_SEARCH\t0\t// save/use pat in/from search_pattern\n#define RE_SUBST\t1\t// save/use pat in/from subst_pattern\n#define RE_BOTH\t\t2\t// save pat in both patterns\n#define RE_LAST\t\t2\t// use last used pattern if \"pat\" is NULL\n\n// Second argument for vim_regcomp().\n#define RE_MAGIC\t1\t// 'magic' option\n#define RE_STRING\t2\t// match in string instead of buffer text\n#define RE_STRICT\t4\t// don't allow [abc] without ]\n#define RE_AUTO\t\t8\t// automatic engine selection\n\n#ifdef FEAT_SYN_HL\n// values for reg_do_extmatch\n# define REX_SET\t1\t// to allow \\z\\(...\\),\n# define REX_USE\t2\t// to allow \\z\\1 et al.\n# define REX_ALL\t(REX_SET | REX_USE)\n#endif\n\n// Return values for fullpathcmp()\n// Note: can use (fullpathcmp() & FPC_SAME) to check for equal files\n#define FPC_SAME\t1\t// both exist and are the same file.\n#define FPC_DIFF\t2\t// both exist and are different files.\n#define FPC_NOTX\t4\t// both don't exist.\n#define FPC_DIFFX\t6\t// one of them doesn't exist.\n#define FPC_SAMEX\t7\t// both don't exist and file names are same.\n\n// flags for do_ecmd()\n#define ECMD_HIDE\t0x01\t// don't free the current buffer\n#define ECMD_SET_HELP\t0x02\t// set b_help flag of (new) buffer before\n\t\t\t\t// opening file\n#define ECMD_OLDBUF\t0x04\t// use existing buffer if it exists\n#define ECMD_FORCEIT\t0x08\t// ! used in Ex command\n#define ECMD_ADDBUF\t0x10\t// don't edit, just add to buffer list\n#define ECMD_ALTBUF\t0x20\t// like ECMD_ADDBUF and set the alternate file\n#define ECMD_NOWINENTER\t0x40\t// do not trigger BufWinEnter\n\n// for lnum argument in do_ecmd()\n#define ECMD_LASTL\t(linenr_T)0\t// use last position in loaded file\n#define ECMD_LAST\t(linenr_T)-1\t// use last position in all files\n#define ECMD_ONE\t(linenr_T)1\t// use first line\n\n// flags for do_cmdline()\n#define DOCMD_VERBOSE\t0x01\t// included command in error message\n#define DOCMD_NOWAIT\t0x02\t// don't call wait_return() and friends\n#define DOCMD_REPEAT\t0x04\t// repeat exec. until getline() returns NULL\n#define DOCMD_KEYTYPED\t0x08\t// don't reset KeyTyped\n#define DOCMD_EXCRESET\t0x10\t// reset exception environment (for debugging)\n#define DOCMD_KEEPLINE  0x20\t// keep typed line for repeating with \".\"\n#define DOCMD_RANGEOK\t0x40\t// can use a range without \":\" in Vim9 script\n\n// flags for beginline()\n#define BL_WHITE\t1\t// cursor on first non-white in the line\n#define BL_SOL\t\t2\t// use 'sol' option\n#define BL_FIX\t\t4\t// don't leave cursor on a NUL\n\n// flags for mf_sync()\n#define MFS_ALL\t\t1\t// also sync blocks with negative numbers\n#define MFS_STOP\t2\t// stop syncing when a character is available\n#define MFS_FLUSH\t4\t// flushed file to disk\n#define MFS_ZERO\t8\t// only write block 0\n\n// flags for buf_copy_options()\n#define BCO_ENTER\t1\t// going to enter the buffer\n#define BCO_ALWAYS\t2\t// always copy the options\n#define BCO_NOHELP\t4\t// don't touch the help related options\n\n// flags for do_put()\n#define PUT_FIXINDENT\t1\t// make indent look nice\n#define PUT_CURSEND\t2\t// leave cursor after end of new text\n#define PUT_CURSLINE\t4\t// leave cursor on last line of new text\n#define PUT_LINE\t8\t// put register as lines\n#define PUT_LINE_SPLIT\t16\t// split line for linewise register\n#define PUT_LINE_FORWARD 32\t// put linewise register below Visual sel.\n#define PUT_BLOCK_INNER 64      // in block mode, do not add trailing spaces\n\n// flags for set_indent()\n#define SIN_CHANGED\t1\t// call changed_bytes() when line changed\n#define SIN_INSERT\t2\t// insert indent before existing text\n#define SIN_UNDO\t4\t// save line for undo before changing it\n\n// flags for insertchar()\n#define INSCHAR_FORMAT\t1\t// force formatting\n#define INSCHAR_DO_COM\t2\t// format comments\n#define INSCHAR_CTRLV\t4\t// char typed just after CTRL-V\n#define INSCHAR_NO_FEX\t8\t// don't use 'formatexpr'\n#define INSCHAR_COM_LIST 16\t// format comments with list/2nd line indent\n\n// flags for open_line()\n#define OPENLINE_DELSPACES  1\t// delete spaces after cursor\n#define OPENLINE_DO_COM\t    2\t// format comments\n#define OPENLINE_KEEPTRAIL  4\t// keep trailing spaces\n#define OPENLINE_MARKFIX    8\t// fix mark positions\n#define OPENLINE_COM_LIST  16\t// format comments with list/2nd line indent\n\n// There are five history tables:\n#define HIST_CMD\t0\t// colon commands\n#define HIST_SEARCH\t1\t// search commands\n#define HIST_EXPR\t2\t// expressions (from entering = register)\n#define HIST_INPUT\t3\t// input() lines\n#define HIST_DEBUG\t4\t// debug commands\n#define HIST_COUNT\t5\t// number of history tables\n\n// The type numbers are fixed for backwards compatibility.\n#define BARTYPE_VERSION 1\n#define BARTYPE_HISTORY 2\n#define BARTYPE_REGISTER 3\n#define BARTYPE_MARK 4\n\n#define VIMINFO_VERSION 4\n#define VIMINFO_VERSION_WITH_HISTORY 2\n#define VIMINFO_VERSION_WITH_REGISTERS 3\n#define VIMINFO_VERSION_WITH_MARKS 4\n\n/*\n * Values for do_tag().\n */\n#define DT_TAG\t\t1\t// jump to newer position or same tag again\n#define DT_POP\t\t2\t// jump to older position\n#define DT_NEXT\t\t3\t// jump to next match of same tag\n#define DT_PREV\t\t4\t// jump to previous match of same tag\n#define DT_FIRST\t5\t// jump to first match of same tag\n#define DT_LAST\t\t6\t// jump to first match of same tag\n#define DT_SELECT\t7\t// jump to selection from list\n#define DT_HELP\t\t8\t// like DT_TAG, but no wildcards\n#define DT_JUMP\t\t9\t// jump to new tag or selection from list\n#define DT_CSCOPE\t10\t// cscope find command (like tjump)\n#define DT_LTAG\t\t11\t// tag using location list\n#define DT_FREE\t\t99\t// free cached matches\n\n/*\n * flags for find_tags().\n */\n#define TAG_HELP\t1\t// only search for help tags\n#define TAG_NAMES\t2\t// only return name of tag\n#define\tTAG_REGEXP\t4\t// use tag pattern as regexp\n#define\tTAG_NOIC\t8\t// don't always ignore case\n#ifdef FEAT_CSCOPE\n# define TAG_CSCOPE\t16\t// cscope tag\n#endif\n#define TAG_VERBOSE\t32\t// message verbosity\n#define TAG_INS_COMP\t64\t// Currently doing insert completion\n#define TAG_KEEP_LANG\t128\t// keep current language\n#define TAG_NO_TAGFUNC\t256\t// do not use 'tagfunc'\n\n#define TAG_MANY\t300\t// When finding many tags (for completion),\n\t\t\t\t// find up to this many tags\n\n/*\n * Types of dialogs passed to do_vim_dialog().\n */\n#define VIM_GENERIC\t0\n#define VIM_ERROR\t1\n#define VIM_WARNING\t2\n#define VIM_INFO\t3\n#define VIM_QUESTION\t4\n#define VIM_LAST_TYPE\t4\t// sentinel value\n\n/*\n * Return values for functions like gui_yesnocancel()\n */\n#define VIM_YES\t\t2\n#define VIM_NO\t\t3\n#define VIM_CANCEL\t4\n#define VIM_ALL\t\t5\n#define VIM_DISCARDALL  6\n\n/*\n * arguments for win_split()\n */\n#define WSP_ROOM\t1\t// require enough room\n#define WSP_VERT\t2\t// split vertically\n#define WSP_TOP\t\t4\t// window at top-left of shell\n#define WSP_BOT\t\t8\t// window at bottom-right of shell\n#define WSP_HELP\t16\t// creating the help window\n#define WSP_BELOW\t32\t// put new window below/right\n#define WSP_ABOVE\t64\t// put new window above/left\n#define WSP_NEWLOC\t128\t// don't copy location list\n\n/*\n * arguments for gui_set_shellsize()\n */\n#define RESIZE_VERT\t1\t// resize vertically\n#define RESIZE_HOR\t2\t// resize horizontally\n#define RESIZE_BOTH\t15\t// resize in both directions\n\n/*\n * flags for check_changed()\n */\n#define CCGD_AW\t\t1\t// do autowrite if buffer was changed\n#define CCGD_MULTWIN\t2\t// check also when several wins for the buf\n#define CCGD_FORCEIT\t4\t// ! used\n#define CCGD_ALLBUF\t8\t// may write all buffers\n#define CCGD_EXCMD\t16\t// may suggest using !\n\n/*\n * \"flags\" values for option-setting functions.\n * When OPT_GLOBAL and OPT_LOCAL are both missing, set both local and global\n * values, get local value.\n */\n#define OPT_FREE\t0x01\t// free old value if it was allocated\n#define OPT_GLOBAL\t0x02\t// use global value\n#define OPT_LOCAL\t0x04\t// use local value\n#define OPT_MODELINE\t0x08\t// option in modeline\n#define OPT_WINONLY\t0x10\t// only set window-local options\n#define OPT_NOWIN\t0x20\t// don't set window-local options\n#define OPT_ONECOLUMN\t0x40\t// list options one per line\n#define OPT_NO_REDRAW\t0x80\t// ignore redraw flags on option\n#define OPT_SKIPRTP\t0x100\t// \"skiprtp\" in 'sessionoptions'\n\n// Magic chars used in confirm dialog strings\n#define DLG_BUTTON_SEP\t'\\n'\n#define DLG_HOTKEY_CHAR\t'&'\n\n// Values for \"starting\"\n#define NO_SCREEN\t2\t// no screen updating yet\n#define NO_BUFFERS\t1\t// not all buffers loaded yet\n//\t\t\t0\t   not starting anymore\n\n// Values for swap_exists_action: what to do when swap file already exists\n#define SEA_NONE\t0\t// don't use dialog\n#define SEA_DIALOG\t1\t// use dialog when possible\n#define SEA_QUIT\t2\t// quit editing the file\n#define SEA_RECOVER\t3\t// recover the file\n\n/*\n * Minimal size for block 0 of a swap file.\n * NOTE: This depends on size of struct block0! It's not done with a sizeof(),\n * because struct block0 is defined in memline.c (Sorry).\n * The maximal block size is arbitrary.\n */\n#define MIN_SWAP_PAGE_SIZE 1048\n#define MAX_SWAP_PAGE_SIZE 50000\n\n// Special values for current_sctx.sc_sid.\n#define SID_MODELINE\t-1\t// when using a modeline\n#define SID_CMDARG\t-2\t// for \"--cmd\" argument\n#define SID_CARG\t-3\t// for \"-c\" argument\n#define SID_ENV\t\t-4\t// for sourcing environment variable\n#define SID_ERROR\t-5\t// option was reset because of an error\n#define SID_NONE\t-6\t// don't set scriptID\n#define SID_WINLAYOUT\t-7\t// changing window size\n\n/*\n * Events for autocommands.\n */\nenum auto_event\n{\n    EVENT_BUFADD = 0,\t\t// after adding a buffer to the buffer list\n    EVENT_BUFDELETE,\t\t// deleting a buffer from the buffer list\n    EVENT_BUFENTER,\t\t// after entering a buffer\n    EVENT_BUFFILEPOST,\t\t// after renaming a buffer\n    EVENT_BUFFILEPRE,\t\t// before renaming a buffer\n    EVENT_BUFHIDDEN,\t\t// just after buffer becomes hidden\n    EVENT_BUFLEAVE,\t\t// before leaving a buffer\n    EVENT_BUFNEW,\t\t// after creating any buffer\n    EVENT_BUFNEWFILE,\t\t// when creating a buffer for a new file\n    EVENT_BUFREADCMD,\t\t// read buffer using command\n    EVENT_BUFREADPOST,\t\t// after reading a buffer\n    EVENT_BUFREADPRE,\t\t// before reading a buffer\n    EVENT_BUFUNLOAD,\t\t// just before unloading a buffer\n    EVENT_BUFWINENTER,\t\t// after showing a buffer in a window\n    EVENT_BUFWINLEAVE,\t\t// just after buffer removed from window\n    EVENT_BUFWIPEOUT,\t\t// just before really deleting a buffer\n    EVENT_BUFWRITECMD,\t\t// write buffer using command\n    EVENT_BUFWRITEPOST,\t\t// after writing a buffer\n    EVENT_BUFWRITEPRE,\t\t// before writing a buffer\n    EVENT_CMDLINECHANGED,\t// command line was modified\n    EVENT_CMDLINEENTER,\t\t// after entering the command line\n    EVENT_CMDLINELEAVE,\t\t// before leaving the command line\n    EVENT_CMDUNDEFINED,\t\t// command undefined\n    EVENT_CMDWINENTER,\t\t// after entering the cmdline window\n    EVENT_CMDWINLEAVE,\t\t// before leaving the cmdline window\n    EVENT_COLORSCHEME,\t\t// after loading a colorscheme\n    EVENT_COLORSCHEMEPRE,\t// before loading a colorscheme\n    EVENT_COMPLETECHANGED,\t// after completion popup menu changed\n    EVENT_COMPLETEDONE,\t\t// after finishing insert complete\n    EVENT_COMPLETEDONEPRE,\t// idem, before clearing info\n    EVENT_CURSORHOLD,\t\t// cursor in same position for a while\n    EVENT_CURSORHOLDI,\t\t// idem, in Insert mode\n    EVENT_CURSORMOVED,\t\t// cursor was moved\n    EVENT_CURSORMOVEDI,\t\t// cursor was moved in Insert mode\n    EVENT_DIFFUPDATED,\t\t// after diffs were updated\n    EVENT_DIRCHANGED,\t\t// after user changed directory\n    EVENT_ENCODINGCHANGED,\t// after changing the 'encoding' option\n    EVENT_EXITPRE,\t\t// before exiting\n    EVENT_FILEAPPENDCMD,\t// append to a file using command\n    EVENT_FILEAPPENDPOST,\t// after appending to a file\n    EVENT_FILEAPPENDPRE,\t// before appending to a file\n    EVENT_FILECHANGEDRO,\t// before first change to read-only file\n    EVENT_FILECHANGEDSHELL,\t// after shell command that changed file\n    EVENT_FILECHANGEDSHELLPOST,\t// after (not) reloading changed file\n    EVENT_FILEREADCMD,\t\t// read from a file using command\n    EVENT_FILEREADPOST,\t\t// after reading a file\n    EVENT_FILEREADPRE,\t\t// before reading a file\n    EVENT_FILETYPE,\t\t// new file type detected (user defined)\n    EVENT_FILEWRITECMD,\t\t// write to a file using command\n    EVENT_FILEWRITEPOST,\t// after writing a file\n    EVENT_FILEWRITEPRE,\t\t// before writing a file\n    EVENT_FILTERREADPOST,\t// after reading from a filter\n    EVENT_FILTERREADPRE,\t// before reading from a filter\n    EVENT_FILTERWRITEPOST,\t// after writing to a filter\n    EVENT_FILTERWRITEPRE,\t// before writing to a filter\n    EVENT_FOCUSGAINED,\t\t// got the focus\n    EVENT_FOCUSLOST,\t\t// lost the focus to another app\n    EVENT_FUNCUNDEFINED,\t// if calling a function which doesn't exist\n    EVENT_GUIENTER,\t\t// after starting the GUI\n    EVENT_GUIFAILED,\t\t// after starting the GUI failed\n    EVENT_INSERTCHANGE,\t\t// when changing Insert/Replace mode\n    EVENT_INSERTCHARPRE,\t// before inserting a char\n    EVENT_INSERTENTER,\t\t// when entering Insert mode\n    EVENT_INSERTLEAVEPRE,\t// just before leaving Insert mode\n    EVENT_INSERTLEAVE,\t\t// just after leaving Insert mode\n    EVENT_MENUPOPUP,\t\t// just before popup menu is displayed\n    EVENT_MODECHANGED,\t\t// after changing the mode\n    EVENT_OPTIONSET,\t\t// option was set\n    EVENT_QUICKFIXCMDPOST,\t// after :make, :grep etc.\n    EVENT_QUICKFIXCMDPRE,\t// before :make, :grep etc.\n    EVENT_QUITPRE,\t\t// before :quit\n    EVENT_REMOTEREPLY,\t\t// upon string reception from a remote vim\n    EVENT_SAFESTATE,\t\t// going to wait for a character\n    EVENT_SAFESTATEAGAIN,\t// still waiting for a character\n    EVENT_SESSIONLOADPOST,\t// after loading a session file\n    EVENT_SHELLCMDPOST,\t\t// after \":!cmd\"\n    EVENT_SHELLFILTERPOST,\t// after \":1,2!cmd\", \":w !cmd\", \":r !cmd\".\n    EVENT_SIGUSR1,\t\t// after the SIGUSR1 signal\n    EVENT_SOURCECMD,\t\t// sourcing a Vim script using command\n    EVENT_SOURCEPRE,\t\t// before sourcing a Vim script\n    EVENT_SOURCEPOST,\t\t// after sourcing a Vim script\n    EVENT_SPELLFILEMISSING,\t// spell file missing\n    EVENT_STDINREADPOST,\t// after reading from stdin\n    EVENT_STDINREADPRE,\t\t// before reading from stdin\n    EVENT_SWAPEXISTS,\t\t// found existing swap file\n    EVENT_SYNTAX,\t\t// syntax selected\n    EVENT_TABCLOSED,\t\t// after closing a tab page\n    EVENT_TABENTER,\t\t// after entering a tab page\n    EVENT_TABLEAVE,\t\t// before leaving a tab page\n    EVENT_TABNEW,\t\t// when entering a new tab page\n    EVENT_TERMCHANGED,\t\t// after changing 'term'\n    EVENT_TERMINALOPEN,\t\t// after a terminal buffer was created\n    EVENT_TERMINALWINOPEN,\t// after a terminal buffer was created and\n\t\t\t\t// entering its window\n    EVENT_TERMRESPONSE,\t\t// after setting \"v:termresponse\"\n    EVENT_TEXTCHANGED,\t\t// text was modified not in Insert mode\n    EVENT_TEXTCHANGEDI,         // text was modified in Insert mode\n    EVENT_TEXTCHANGEDP,         // TextChangedI with popup menu visible\n    EVENT_TEXTYANKPOST,\t\t// after some text was yanked\n    EVENT_USER,\t\t\t// user defined autocommand\n    EVENT_VIMENTER,\t\t// after starting Vim\n    EVENT_VIMLEAVE,\t\t// before exiting Vim\n    EVENT_VIMLEAVEPRE,\t\t// before exiting Vim and writing .viminfo\n    EVENT_VIMRESIZED,\t\t// after Vim window was resized\n    EVENT_WINENTER,\t\t// after entering a window\n    EVENT_WINLEAVE,\t\t// before leaving a window\n    EVENT_WINNEW,\t\t// when entering a new window\n    EVENT_WINCLOSED,\t\t// after closing a window\n    EVENT_VIMSUSPEND,\t\t// before Vim is suspended\n    EVENT_VIMRESUME,\t\t// after Vim is resumed\n\n    NUM_EVENTS\t\t\t// MUST be the last one\n};\n\ntypedef enum auto_event event_T;\n\n/*\n * Values for index in highlight_attr[].\n * When making changes, also update HL_FLAGS below!  And update the default\n * value of 'highlight' in option.c.\n */\ntypedef enum\n{\n    HLF_8 = 0\t    // Meta & special keys listed with \":map\", text that is\n\t\t    // displayed different from what it is\n    , HLF_EOB\t    // after the last line in the buffer\n    , HLF_AT\t    // @ characters at end of screen, characters that\n\t\t    // don't really exist in the text\n    , HLF_D\t    // directories in CTRL-D listing\n    , HLF_E\t    // error messages\n    , HLF_H\t    // obsolete, ignored\n    , HLF_I\t    // incremental search\n    , HLF_L\t    // last search string\n    , HLF_M\t    // \"--More--\" message\n    , HLF_CM\t    // Mode (e.g., \"-- INSERT --\")\n    , HLF_N\t    // line number for \":number\" and \":#\" commands\n    , HLF_LNA\t    // LineNrAbove\n    , HLF_LNB\t    // LineNrBelow\n    , HLF_CLN\t    // current line number\n    , HLF_CLS\t    // current line sign column\n    , HLF_CLF\t    // current line fold\n    , HLF_R\t    // return to continue message and yes/no questions\n    , HLF_S\t    // status lines\n    , HLF_SNC\t    // status lines of not-current windows\n    , HLF_C\t    // column to separate vertically split windows\n    , HLF_T\t    // Titles for output from \":set all\", \":autocmd\" etc.\n    , HLF_V\t    // Visual mode\n    , HLF_VNC\t    // Visual mode, autoselecting and not clipboard owner\n    , HLF_W\t    // warning messages\n    , HLF_WM\t    // Wildmenu highlight\n    , HLF_FL\t    // Folded line\n    , HLF_FC\t    // Fold column\n    , HLF_ADD\t    // Added diff line\n    , HLF_CHD\t    // Changed diff line\n    , HLF_DED\t    // Deleted diff line\n    , HLF_TXD\t    // Text Changed in diff line\n    , HLF_CONCEAL   // Concealed text\n    , HLF_SC\t    // Sign column\n    , HLF_SPB\t    // SpellBad\n    , HLF_SPC\t    // SpellCap\n    , HLF_SPR\t    // SpellRare\n    , HLF_SPL\t    // SpellLocal\n    , HLF_PNI\t    // popup menu normal item\n    , HLF_PSI\t    // popup menu selected item\n    , HLF_PSB\t    // popup menu scrollbar\n    , HLF_PST\t    // popup menu scrollbar thumb\n    , HLF_TP\t    // tabpage line\n    , HLF_TPS\t    // tabpage line selected\n    , HLF_TPF\t    // tabpage line filler\n    , HLF_CUC\t    // 'cursorcolumn'\n    , HLF_CUL\t    // 'cursorline'\n    , HLF_MC\t    // 'colorcolumn'\n    , HLF_QFL\t    // quickfix window line currently selected\n    , HLF_ST\t    // status lines of terminal windows\n    , HLF_STNC\t    // status lines of not-current terminal windows\n    , HLF_COUNT\t    // MUST be the last one\n} hlf_T;\n\n// The HL_FLAGS must be in the same order as the HLF_ enums!\n// When changing this also adjust the default for 'highlight'.\n#define HL_FLAGS {'8', '~', '@', 'd', 'e', 'h', 'i', 'l', 'm', 'M', \\\n\t\t  'n', 'a', 'b', 'N', 'G', 'O', 'r', 's', 'S', 'c', 't', 'v', 'V', \\\n\t\t  'w', 'W', 'f', 'F', 'A', 'C', 'D', 'T', '-', '>', \\\n\t\t  'B', 'P', 'R', 'L', \\\n\t\t  '+', '=', 'x', 'X', '*', '#', '_', '!', '.', 'o', 'q', \\\n\t\t  'z', 'Z'}\n\n/*\n * Boolean constants\n */\n#ifndef TRUE\n# define FALSE\t0\t    // note: this is an int, not a long!\n# define TRUE\t1\n#endif\n\n#define MAYBE\t2\t    // sometimes used for a variant on TRUE\n\n#ifndef UINT32_T\ntypedef UINT32_TYPEDEF UINT32_T;\n#endif\n\n/*\n * Operator IDs; The order must correspond to opchars[] in ops.c!\n */\n#define OP_NOP\t\t0\t// no pending operation\n#define OP_DELETE\t1\t// \"d\"  delete operator\n#define OP_YANK\t\t2\t// \"y\"  yank operator\n#define OP_CHANGE\t3\t// \"c\"  change operator\n#define OP_LSHIFT\t4\t// \"<\"  left shift operator\n#define OP_RSHIFT\t5\t// \">\"  right shift operator\n#define OP_FILTER\t6\t// \"!\"  filter operator\n#define OP_TILDE\t7\t// \"g~\" switch case operator\n#define OP_INDENT\t8\t// \"=\"  indent operator\n#define OP_FORMAT\t9\t// \"gq\" format operator\n#define OP_COLON\t10\t// \":\"  colon operator\n#define OP_UPPER\t11\t// \"gU\" make upper case operator\n#define OP_LOWER\t12\t// \"gu\" make lower case operator\n#define OP_JOIN\t\t13\t// \"J\"  join operator, only for Visual mode\n#define OP_JOIN_NS\t14\t// \"gJ\"  join operator, only for Visual mode\n#define OP_ROT13\t15\t// \"g?\" rot-13 encoding\n#define OP_REPLACE\t16\t// \"r\"  replace chars, only for Visual mode\n#define OP_INSERT\t17\t// \"I\"  Insert column, only for Visual mode\n#define OP_APPEND\t18\t// \"A\"  Append column, only for Visual mode\n#define OP_FOLD\t\t19\t// \"zf\" define a fold\n#define OP_FOLDOPEN\t20\t// \"zo\" open folds\n#define OP_FOLDOPENREC\t21\t// \"zO\" open folds recursively\n#define OP_FOLDCLOSE\t22\t// \"zc\" close folds\n#define OP_FOLDCLOSEREC\t23\t// \"zC\" close folds recursively\n#define OP_FOLDDEL\t24\t// \"zd\" delete folds\n#define OP_FOLDDELREC\t25\t// \"zD\" delete folds recursively\n#define OP_FORMAT2\t26\t// \"gw\" format operator, keeps cursor pos\n#define OP_FUNCTION\t27\t// \"g@\" call 'operatorfunc'\n#define OP_NR_ADD\t28\t// \"<C-A>\" Add to the number or alphabetic\n\t\t\t\t// character (OP_ADD conflicts with Perl)\n#define OP_NR_SUB\t29\t// \"<C-X>\" Subtract from the number or\n\t\t\t\t// alphabetic character\n\n/*\n * Motion types, used for operators and for yank/delete registers.\n */\n#define MCHAR\t0\t\t// character-wise movement/register\n#define MLINE\t1\t\t// line-wise movement/register\n#define MBLOCK\t2\t\t// block-wise register\n\n#define MAUTO\t0xff\t\t// Decide between MLINE/MCHAR\n\n/*\n * Minimum screen size\n */\n#define MIN_COLUMNS\t12\t// minimal columns for screen\n#define MIN_LINES\t2\t// minimal lines for screen\n#define STATUS_HEIGHT\t1\t// height of a status line under a window\n#ifdef FEAT_MENU\t\t// height of a status line under a window\n# define WINBAR_HEIGHT(wp)\t(wp)->w_winbar_height\n# define VISIBLE_HEIGHT(wp)\t((wp)->w_height + (wp)->w_winbar_height)\n#else\n# define WINBAR_HEIGHT(wp)\t0\n# define VISIBLE_HEIGHT(wp)\t(wp)->w_height\n#endif\n#define QF_WINHEIGHT\t10\t// default height for quickfix window\n\n/*\n * Buffer sizes\n */\n#ifndef CMDBUFFSIZE\n# define CMDBUFFSIZE\t256\t// size of the command processing buffer\n#endif\n\n#define LSIZE\t    512\t\t// max. size of a line in the tags file\n\n#define IOSIZE\t   (1024+1)\t// file i/o and sprintf buffer size\n\n#define DIALOG_MSG_SIZE 1000\t// buffer size for dialog_msg()\n\n#define MSG_BUF_LEN 480\t// length of buffer for small messages\n#define MSG_BUF_CLEN  (MSG_BUF_LEN / 6)    // cell length (worst case: utf-8\n\t\t\t\t\t   // takes 6 bytes for one cell)\n\n#define FOLD_TEXT_LEN  51\t// buffer size for get_foldtext()\n\n// Size of the buffer used for tgetent().  Unfortunately this is largely\n// undocumented, some systems use 1024.  Using a buffer that is too small\n// causes a buffer overrun and a crash.  Use the maximum known value to stay\n// on the safe side.\n#define TBUFSZ 2048\t\t// buffer size for termcap entry\n\n/*\n * Maximum length of key sequence to be mapped.\n * Must be able to hold an Amiga resize report.\n */\n#define MAXMAPLEN   50\n\n// Size in bytes of the hash used in the undo file.\n#define UNDO_HASH_SIZE 32\n\n#ifdef HAVE_FCNTL_H\n# include <fcntl.h>\n#endif\n\n#ifdef BINARY_FILE_IO\n# define WRITEBIN   \"wb\"\t// no CR-LF translation\n# define READBIN    \"rb\"\n# define APPENDBIN  \"ab\"\n#else\n# define WRITEBIN   \"w\"\n# define READBIN    \"r\"\n# define APPENDBIN  \"a\"\n#endif\n\n/*\n * EMX doesn't have a global way of making open() use binary I/O.\n * Use O_BINARY for all open() calls.\n */\n#if defined(__CYGWIN32__)\n# define O_EXTRA    O_BINARY\n#else\n# define O_EXTRA    0\n#endif\n\n#ifndef O_NOFOLLOW\n# define O_NOFOLLOW 0\n#endif\n\n#ifndef W_OK\n# define W_OK 2\t\t// for systems that don't have W_OK in unistd.h\n#endif\n#ifndef R_OK\n# define R_OK 4\t\t// for systems that don't have R_OK in unistd.h\n#endif\n\n// Allocate memory for one type and cast the returned pointer to have the\n// compiler check the types.\n#define ALLOC_ONE(type)  (type *)alloc(sizeof(type))\n#define ALLOC_MULT(type, count)  (type *)alloc(sizeof(type) * (count))\n#define ALLOC_CLEAR_ONE(type)  (type *)alloc_clear(sizeof(type))\n#define ALLOC_CLEAR_MULT(type, count)  (type *)alloc_clear(sizeof(type) * (count))\n#define LALLOC_CLEAR_ONE(type)  (type *)lalloc_clear(sizeof(type), FALSE)\n#define LALLOC_CLEAR_MULT(type, count)  (type *)lalloc_clear(sizeof(type) * (count), FALSE)\n#define LALLOC_MULT(type, count)  (type *)lalloc(sizeof(type) * (count), FALSE)\n\n#ifdef HAVE_MEMSET\n# define vim_memset(ptr, c, size)   memset((ptr), (c), (size))\n#else\nvoid *vim_memset(void *, int, size_t);\n#endif\n#define CLEAR_FIELD(field)  vim_memset(&(field), 0, sizeof(field))\n#define CLEAR_POINTER(ptr)  vim_memset((ptr), 0, sizeof(*(ptr)))\n\n/*\n * defines to avoid typecasts from (char_u *) to (char *) and back\n * (vim_strchr() and vim_strrchr() are now in alloc.c)\n */\n#define STRLEN(s)\t    strlen((char *)(s))\n#define STRCPY(d, s)\t    strcpy((char *)(d), (char *)(s))\n#define STRNCPY(d, s, n)    strncpy((char *)(d), (char *)(s), (size_t)(n))\n#define STRCMP(d, s)\t    strcmp((char *)(d), (char *)(s))\n#define STRNCMP(d, s, n)    strncmp((char *)(d), (char *)(s), (size_t)(n))\n#ifdef HAVE_STRCASECMP\n# define STRICMP(d, s)\t    strcasecmp((char *)(d), (char *)(s))\n#else\n# ifdef HAVE_STRICMP\n#  define STRICMP(d, s)\t    stricmp((char *)(d), (char *)(s))\n# else\n#  define STRICMP(d, s)\t    vim_stricmp((char *)(d), (char *)(s))\n# endif\n#endif\n#ifdef HAVE_STRCOLL\n# define STRCOLL(d, s)     strcoll((char *)(d), (char *)(s))\n#else\n# define STRCOLL(d, s)     strcmp((char *)(d), (char *)(s))\n#endif\n\n// Like strcpy() but allows overlapped source and destination.\n#define STRMOVE(d, s)\t    mch_memmove((d), (s), STRLEN(s) + 1)\n\n#ifdef HAVE_STRNCASECMP\n# define STRNICMP(d, s, n)  strncasecmp((char *)(d), (char *)(s), (size_t)(n))\n#else\n# ifdef HAVE_STRNICMP\n#  define STRNICMP(d, s, n) strnicmp((char *)(d), (char *)(s), (size_t)(n))\n# else\n#  define STRNICMP(d, s, n) vim_strnicmp((char *)(d), (char *)(s), (size_t)(n))\n# endif\n#endif\n\n// We need to call mb_stricmp() even when we aren't dealing with a multi-byte\n// encoding because mb_stricmp() takes care of all ascii and non-ascii\n// encodings, including characters with umlauts in latin1, etc., while\n// STRICMP() only handles the system locale version, which often does not\n// handle non-ascii properly.\n\n# define MB_STRICMP(d, s)\tmb_strnicmp((char_u *)(d), (char_u *)(s), (int)MAXCOL)\n# define MB_STRNICMP(d, s, n)\tmb_strnicmp((char_u *)(d), (char_u *)(s), (int)(n))\n\n#define STRCAT(d, s)\t    strcat((char *)(d), (char *)(s))\n#define STRNCAT(d, s, n)    strncat((char *)(d), (char *)(s), (size_t)(n))\n\n#ifdef HAVE_STRPBRK\n# define vim_strpbrk(s, cs) (char_u *)strpbrk((char *)(s), (char *)(cs))\n#endif\n\n#define OUT_STR(s)\t\t    out_str((char_u *)(s))\n#define OUT_STR_NF(s)\t\t    out_str_nf((char_u *)(s))\n\n#ifdef FEAT_GUI\n# ifdef FEAT_TERMGUICOLORS\n#  define GUI_FUNCTION(f)\t    (gui.in_use ? gui_##f : termgui_##f)\n#  define GUI_FUNCTION2(f, pixel)   (gui.in_use \\\n\t\t\t\t    ?  ((pixel) != INVALCOLOR \\\n\t\t\t\t\t? gui_##f((pixel)) \\\n\t\t\t\t\t: INVALCOLOR) \\\n\t\t\t\t    : termgui_##f((pixel)))\n#  define USE_24BIT\t\t    (gui.in_use || p_tgc)\n# else\n#  define GUI_FUNCTION(f)\t    gui_##f\n#  define GUI_FUNCTION2(f,pixel)    ((pixel) != INVALCOLOR \\\n\t\t\t\t     ? gui_##f((pixel)) \\\n\t\t\t\t     : INVALCOLOR)\n#  define USE_24BIT\t\t    gui.in_use\n# endif\n#else\n# ifdef FEAT_TERMGUICOLORS\n#  define GUI_FUNCTION(f)\t    termgui_##f\n#  define GUI_FUNCTION2(f, pixel)   termgui_##f((pixel))\n#  define USE_24BIT\t\t    p_tgc\n# endif\n#endif\n#ifdef FEAT_TERMGUICOLORS\n# define IS_CTERM\t\t    (t_colors > 1 || p_tgc)\n#else\n# define IS_CTERM\t\t    (t_colors > 1)\n#endif\n#ifdef GUI_FUNCTION\n# define GUI_MCH_GET_RGB\t    GUI_FUNCTION(mch_get_rgb)\n# define GUI_MCH_GET_RGB2(pixel)    GUI_FUNCTION2(mch_get_rgb, (pixel))\n# define GUI_MCH_GET_COLOR\t    GUI_FUNCTION(mch_get_color)\n# define GUI_GET_COLOR\t\t    GUI_FUNCTION(get_color)\n#endif\n\n// Prefer using emsgf(), because perror() may send the output to the wrong\n// destination and mess up the screen.\n#ifdef HAVE_STRERROR\n# define PERROR(msg)\t\t    (void)semsg(\"%s: %s\", (char *)msg, strerror(errno))\n#else\n# define PERROR(msg)\t\t    do_perror(msg)\n#endif\n\ntypedef long\tlinenr_T;\t\t// line number type\ntypedef int\tcolnr_T;\t\t// column number type\ntypedef unsigned short disptick_T;\t// display tick type\n\n/*\n * Well, you won't believe it, but some S/390 machines (\"host\", now also known\n * as zServer) use 31 bit pointers. There are also some newer machines, that\n * use 64 bit pointers. I don't know how to distinguish between 31 and 64 bit\n * machines, so the best way is to assume 31 bits whenever we detect OS/390\n * Unix.\n * With this we restrict the maximum line length to 1073741823. I guess this is\n * not a real problem. BTW:  Longer lines are split.\n */\n#ifdef __MVS__\n# define MAXCOL (0x3fffffffL)\t\t// maximum column number, 30 bits\n# define MAXLNUM (0x3fffffffL)\t\t// maximum (invalid) line number\n#else\n# define MAXCOL  INT_MAX\t\t// maximum column number\n# define MAXLNUM LONG_MAX\t\t// maximum (invalid) line number\n#endif\n\n#define SHOWCMD_COLS 10\t\t\t// columns needed by shown command\n\ntypedef void\t    *vim_acl_T;\t\t// dummy to pass an ACL to a function\n\n#ifndef mch_memmove\n# define mch_memmove(to, from, len) memmove((char*)(to), (char*)(from), (size_t)(len))\n#endif\n\n/*\n * fnamecmp() is used to compare file names.\n * On some systems case in a file name does not matter, on others it does.\n * (this does not account for maximum name lengths and things like \"../dir\",\n * thus it is not 100% accurate!)\n */\n#define fnamecmp(x, y) vim_fnamecmp((char_u *)(x), (char_u *)(y))\n#define fnamencmp(x, y, n) vim_fnamencmp((char_u *)(x), (char_u *)(y), (size_t)(n))\n\n#if defined(UNIX) || defined(FEAT_GUI) || defined(VMS) \\\n\t|| defined(FEAT_CLIENTSERVER)\n# define USE_INPUT_BUF\n#endif\n\n#ifndef EINTR\n# define read_eintr(fd, buf, count) vim_read((fd), (buf), (count))\n# define write_eintr(fd, buf, count) vim_write((fd), (buf), (count))\n#endif\n\n#ifdef MSWIN\n// On MS-Windows the third argument isn't size_t.  This matters for Win64,\n// where sizeof(size_t)==8, not 4\n# define vim_read(fd, buf, count)   read((fd), (char *)(buf), (unsigned int)(count))\n# define vim_write(fd, buf, count)  write((fd), (char *)(buf), (unsigned int)(count))\n#else\n# define vim_read(fd, buf, count)   read((fd), (char *)(buf), (size_t) (count))\n# define vim_write(fd, buf, count)  write((fd), (char *)(buf), (size_t) (count))\n#endif\n\n/*\n * Enums need a typecast to be used as array index (for Ultrix).\n */\n#define HL_ATTR(n)\thighlight_attr[(int)(n)]\n#define TERM_STR(n)\tterm_strings[(int)(n)]\n\n/*\n * EXTERN is only defined in main.c.  That's where global variables are\n * actually defined and initialized.\n */\n#ifndef EXTERN\n# define EXTERN extern\n# define INIT(x)\n# define INIT2(a, b)\n# define INIT3(a, b, c)\n# define INIT4(a, b, c, d)\n# define INIT5(a, b, c, d, e)\n# define INIT6(a, b, c, d, e, f)\n#else\n# ifndef INIT\n#  define INIT(x) x\n#  define INIT2(a, b) = {a, b}\n#  define INIT3(a, b, c) = {a, b, c}\n#  define INIT4(a, b, c, d) = {a, b, c, d}\n#  define INIT5(a, b, c, d, e) = {a, b, c, d, e}\n#  define INIT6(a, b, c, d, e, f) = {a, b, c, d, e, f}\n#  define DO_INIT\n# endif\n#endif\n\n#define MAX_MCO\t6\t// maximum value for 'maxcombine'\n\n// Maximum number of bytes in a multi-byte character.  It can be one 32-bit\n// character of up to 6 bytes, or one 16-bit character of up to three bytes\n// plus six following composing characters of three bytes each.\n#define MB_MAXBYTES\t21\n\n#if (defined(FEAT_PROFILE) || defined(FEAT_RELTIME)) && !defined(PROTO)\n# ifdef MSWIN\ntypedef LARGE_INTEGER proftime_T;\n# else\ntypedef struct timeval proftime_T;\n# endif\n#else\ntypedef int proftime_T;\t    // dummy for function prototypes\n#endif\n\n// Type of compilation passed to compile_def_function()\ntypedef enum {\n    CT_NONE,\t    // use df_instr\n    CT_PROFILE,\t    // use df_instr_prof\n    CT_DEBUG\t    // use df_instr_debug, overrules CT_PROFILE\n} compiletype_T;\n\n// Keep in sync with INSTRUCTIONS().\n#ifdef FEAT_PROFILE\n# define COMPILE_TYPE(ufunc) (debug_break_level > 0 \\\n\t|| may_break_in_function(ufunc) \\\n\t\t? CT_DEBUG \\\n\t\t: do_profiling == PROF_YES && (ufunc)->uf_profiling \\\n\t\t\t? CT_PROFILE : CT_NONE)\n#else\n# define COMPILE_TYPE(ufunc) debug_break_level > 0 \\\n\t|| may_break_in_function(ufunc) \\\n\t\t? CT_DEBUG \\\n\t\t: CT_NONE\n#endif\n\n/*\n * When compiling with 32 bit Perl time_t is 32 bits in the Perl code but 64\n * bits elsewhere.  That causes memory corruption.  Define time_T and use it\n * for global variables to avoid that.\n */\n#ifdef PROTO\ntypedef long  time_T;\n#else\n# ifdef MSWIN\ntypedef __time64_t  time_T;\n# else\ntypedef time_t\t    time_T;\n# endif\n#endif\n\n#ifdef _WIN64\ntypedef __int64 sock_T;\n#else\ntypedef int sock_T;\n#endif\n\n// Include option.h before structs.h, because the number of window-local and\n// buffer-local options is used there.\n#include \"option.h\"\t// options and default values\n\n#include \"beval.h\"\t// BalloonEval\n\n// Note that gui.h is included by structs.h\n\n#include \"structs.h\"\t// defines many structures\n\n#include \"alloc.h\"\n\n// Values for \"do_profiling\".\n#define PROF_NONE\t0\t// profiling not started\n#define PROF_YES\t1\t// profiling busy\n#define PROF_PAUSED\t2\t// profiling paused\n\n\n// Codes for mouse button events in lower three bits:\n#define MOUSE_LEFT\t0x00\n#define MOUSE_MIDDLE\t0x01\n#define MOUSE_RIGHT\t0x02\n#define MOUSE_RELEASE\t0x03\n\n// bit masks for modifiers:\n#define MOUSE_SHIFT\t0x04\n#define MOUSE_ALT\t0x08\n#define MOUSE_CTRL\t0x10\n\n// mouse buttons that are handled like a key press (GUI only)\n// Note that the scroll wheel keys are inverted: MOUSE_5 scrolls lines up but\n// the result of this is that the window moves down, similarly MOUSE_6 scrolls\n// columns left but the window moves right.\n#define MOUSE_4\t0x100\t// scroll wheel down\n#define MOUSE_5\t0x200\t// scroll wheel up\n\n#define MOUSE_X1\t0x300 // Mouse-button X1 (6th)\n#define MOUSE_X2\t0x400 // Mouse-button X2\n\n#define MOUSE_6\t0x500\t// scroll wheel left\n#define MOUSE_7\t0x600\t// scroll wheel right\n\n#define MOUSE_MOVE 0x700    // report mouse moved\n\n// 0x20 is reserved by xterm\n#define MOUSE_DRAG_XTERM   0x40\n\n#define MOUSE_DRAG\t(0x40 | MOUSE_RELEASE)\n\n// Lowest button code for using the mouse wheel (xterm only)\n#define MOUSEWHEEL_LOW\t\t0x60\n\n#define MOUSE_CLICK_MASK\t0x03\n\n#define NUM_MOUSE_CLICKS(code) \\\n    (((unsigned)((code) & 0xC0) >> 6) + 1)\n\n#define SET_NUM_MOUSE_CLICKS(code, num) \\\n    (code) = ((code) & 0x3f) | ((((num) - 1) & 3) << 6)\n\n// Added to mouse column for GUI when 'mousefocus' wants to give focus to a\n// window by simulating a click on its status line.  We could use up to 128 *\n// 128 = 16384 columns, now it's reduced to 10000.\n#define MOUSE_COLOFF 10000\n\n/*\n * jump_to_mouse() returns one of first four these values, possibly with\n * some of the other three added.\n */\n#define IN_UNKNOWN\t\t0\n#define IN_BUFFER\t\t1\n#define IN_STATUS_LINE\t\t2\t// on status or command line\n#define IN_SEP_LINE\t\t4\t// on vertical separator line\n#define IN_OTHER_WIN\t\t8\t// in other window but can't go there\n#define CURSOR_MOVED\t\t0x100\n#define MOUSE_FOLD_CLOSE\t0x200\t// clicked on '-' in fold column\n#define MOUSE_FOLD_OPEN\t\t0x400\t// clicked on '+' in fold column\n#define MOUSE_WINBAR\t\t0x800\t// in window toolbar\n\n// flags for jump_to_mouse()\n#define MOUSE_FOCUS\t\t0x01\t// need to stay in this window\n#define MOUSE_MAY_VIS\t\t0x02\t// may start Visual mode\n#define MOUSE_DID_MOVE\t\t0x04\t// only act when mouse has moved\n#define MOUSE_SETPOS\t\t0x08\t// only set current mouse position\n#define MOUSE_MAY_STOP_VIS\t0x10\t// may stop Visual mode\n#define MOUSE_RELEASED\t\t0x20\t// button was released\n\n#if defined(UNIX) && defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)\n# define CHECK_DOUBLE_CLICK 1\t// Checking for double clicks ourselves.\n#endif\n\n\n// defines for eval_vars()\n#define VALID_PATH\t\t1\n#define VALID_HEAD\t\t2\n\n// Defines for Vim variables.  These must match vimvars[] in evalvars.c!\n#define VV_COUNT\t0\n#define VV_COUNT1\t1\n#define VV_PREVCOUNT\t2\n#define VV_ERRMSG\t3\n#define VV_WARNINGMSG\t4\n#define VV_STATUSMSG\t5\n#define VV_SHELL_ERROR\t6\n#define VV_THIS_SESSION\t7\n#define VV_VERSION\t8\n#define VV_LNUM\t\t9\n#define VV_TERMRESPONSE\t10\n#define VV_FNAME\t11\n#define VV_LANG\t\t12\n#define VV_LC_TIME\t13\n#define VV_CTYPE\t14\n#define VV_CC_FROM\t15\n#define VV_CC_TO\t16\n#define VV_FNAME_IN\t17\n#define VV_FNAME_OUT\t18\n#define VV_FNAME_NEW\t19\n#define VV_FNAME_DIFF\t20\n#define VV_CMDARG\t21\n#define VV_FOLDSTART\t22\n#define VV_FOLDEND\t23\n#define VV_FOLDDASHES\t24\n#define VV_FOLDLEVEL\t25\n#define VV_PROGNAME\t26\n#define VV_SEND_SERVER\t27\n#define VV_DYING\t28\n#define VV_EXCEPTION\t29\n#define VV_THROWPOINT\t30\n#define VV_REG\t\t31\n#define VV_CMDBANG\t32\n#define VV_INSERTMODE\t33\n#define VV_VAL\t\t34\n#define VV_KEY\t\t35\n#define VV_PROFILING\t36\n#define VV_FCS_REASON\t37\n#define VV_FCS_CHOICE\t38\n#define VV_BEVAL_BUFNR\t39\n#define VV_BEVAL_WINNR\t40\n#define VV_BEVAL_WINID\t41\n#define VV_BEVAL_LNUM\t42\n#define VV_BEVAL_COL\t43\n#define VV_BEVAL_TEXT\t44\n#define VV_SCROLLSTART\t45\n#define VV_SWAPNAME\t46\n#define VV_SWAPCHOICE\t47\n#define VV_SWAPCOMMAND\t48\n#define VV_CHAR\t\t49\n#define VV_MOUSE_WIN\t50\n#define VV_MOUSE_WINID\t51\n#define VV_MOUSE_LNUM   52\n#define VV_MOUSE_COL\t53\n#define VV_OP\t\t54\n#define VV_SEARCHFORWARD 55\n#define VV_HLSEARCH\t56\n#define VV_OLDFILES\t57\n#define VV_WINDOWID\t58\n#define VV_PROGPATH\t59\n#define VV_COMPLETED_ITEM 60\n#define VV_OPTION_NEW   61\n#define VV_OPTION_OLD   62\n#define VV_OPTION_OLDLOCAL 63\n#define VV_OPTION_OLDGLOBAL 64\n#define VV_OPTION_COMMAND 65\n#define VV_OPTION_TYPE  66\n#define VV_ERRORS\t67\n#define VV_FALSE\t68\n#define VV_TRUE\t\t69\n#define VV_NONE\t\t70\n#define VV_NULL\t\t71\n#define VV_NUMBERMAX\t72\n#define VV_NUMBERMIN\t73\n#define VV_NUMBERSIZE\t74\n#define VV_VIM_DID_ENTER 75\n#define VV_TESTING\t76\n#define VV_TYPE_NUMBER\t77\n#define VV_TYPE_STRING\t78\n#define VV_TYPE_FUNC\t79\n#define VV_TYPE_LIST\t80\n#define VV_TYPE_DICT\t81\n#define VV_TYPE_FLOAT\t82\n#define VV_TYPE_BOOL\t83\n#define VV_TYPE_NONE\t84\n#define VV_TYPE_JOB\t85\n#define VV_TYPE_CHANNEL\t86\n#define VV_TYPE_BLOB\t87\n#define VV_TERMRFGRESP\t88\n#define VV_TERMRBGRESP\t89\n#define VV_TERMU7RESP\t90\n#define VV_TERMSTYLERESP 91\n#define VV_TERMBLINKRESP 92\n#define VV_EVENT\t93\n#define VV_VERSIONLONG\t94\n#define VV_ECHOSPACE\t95\n#define VV_ARGV\t\t96\n#define VV_COLLATE      97\n#define VV_EXITING\t98\n#define VV_COLORNAMES   99\n#define VV_SIZEOFINT\t100\n#define VV_SIZEOFLONG\t101\n#define VV_SIZEOFPOINTER 102\n#define VV_MAXCOL\t103\n#define VV_LEN\t\t104\t// number of v: vars\n\n// used for v_number in VAR_BOOL and VAR_SPECIAL\n#define VVAL_FALSE\t0L\t// VAR_BOOL\n#define VVAL_TRUE\t1L\t// VAR_BOOL\n#define VVAL_NONE\t2L\t// VAR_SPECIAL\n#define VVAL_NULL\t3L\t// VAR_SPECIAL\n\n// Type values for type().\n#define VAR_TYPE_NUMBER\t    0\n#define VAR_TYPE_STRING\t    1\n#define VAR_TYPE_FUNC\t    2\n#define VAR_TYPE_LIST\t    3\n#define VAR_TYPE_DICT\t    4\n#define VAR_TYPE_FLOAT\t    5\n#define VAR_TYPE_BOOL\t    6\n#define VAR_TYPE_NONE\t    7\n#define VAR_TYPE_JOB\t    8\n#define VAR_TYPE_CHANNEL    9\n#define VAR_TYPE_BLOB\t    10\n#define VAR_TYPE_INSTR\t    11\n\n#define DICT_MAXNEST 100\t// maximum nesting of lists and dicts\n\n#ifdef FEAT_CLIPBOARD\n\n// VIM_ATOM_NAME is the older Vim-specific selection type for X11.  Still\n// supported for when a mix of Vim versions is used. VIMENC_ATOM_NAME includes\n// the encoding to support Vims using different 'encoding' values.\n# define VIM_ATOM_NAME \"_VIM_TEXT\"\n# define VIMENC_ATOM_NAME \"_VIMENC_TEXT\"\n\n// Selection states for modeless selection\n# define SELECT_CLEARED\t\t0\n# define SELECT_IN_PROGRESS\t1\n# define SELECT_DONE\t\t2\n\n# define SELECT_MODE_CHAR\t0\n# define SELECT_MODE_WORD\t1\n# define SELECT_MODE_LINE\t2\n\n# ifdef FEAT_GUI_MSWIN\n#  ifdef FEAT_OLE\n#   define WM_OLE (WM_APP+0)\n#  endif\n# endif\n\n// Info about selected text\ntypedef struct\n{\n    int\t\tavailable;\t// Is clipboard available?\n    int\t\towned;\t\t// Flag: do we own the selection?\n    pos_T\tstart;\t\t// Start of selected area\n    pos_T\tend;\t\t// End of selected area\n    int\t\tvmode;\t\t// Visual mode character\n\n    // Fields for selection that doesn't use Visual mode\n    short_u\torigin_row;\n    short_u\torigin_start_col;\n    short_u\torigin_end_col;\n    short_u\tword_start_col;\n    short_u\tword_end_col;\n#ifdef FEAT_PROP_POPUP\n    // limits for selection inside a popup window\n    short_u\tmin_col;\n    short_u\tmax_col;\n    short_u\tmin_row;\n    short_u\tmax_row;\n#endif\n\n    pos_T\tprev;\t\t// Previous position\n    short_u\tstate;\t\t// Current selection state\n    short_u\tmode;\t\t// Select by char, word, or line.\n\n# if defined(FEAT_GUI_X11) || defined(FEAT_XCLIPBOARD)\n    Atom\tsel_atom;\t// PRIMARY/CLIPBOARD selection ID\n# endif\n\n# ifdef FEAT_GUI_GTK\n    GdkAtom     gtk_sel_atom;\t// PRIMARY/CLIPBOARD selection ID\n# endif\n\n# if defined(MSWIN) || defined(FEAT_CYGWIN_WIN32_CLIPBOARD)\n    int_u\tformat;\t\t// Vim's own special clipboard format\n    int_u\tformat_raw;\t// Vim's raw text clipboard format\n# endif\n# ifdef FEAT_GUI_HAIKU\n    // No clipboard at the moment. TODO?\n# endif\n} Clipboard_T;\n#else\ntypedef int Clipboard_T;\t// This is required for the prototypes.\n#endif\n\n// Use 64-bit stat structure on MS-Windows.\n#ifdef MSWIN\ntypedef struct _stat64 stat_T;\n#else\ntypedef struct stat stat_T;\n#endif\n\n#if (defined(__GNUC__) || defined(__clang__)) && !defined(__MINGW32__)\n# define ATTRIBUTE_FORMAT_PRINTF(fmt_idx, arg_idx) \\\n    __attribute__((format(printf, fmt_idx, arg_idx)))\n#else\n# define ATTRIBUTE_FORMAT_PRINTF(fmt_idx, arg_idx)\n#endif\n\n#if defined(__GNUC__) || defined(__clang__)\n# define likely(x)\t__builtin_expect((x), 1)\n# define unlikely(x)\t__builtin_expect((x), 0)\n# define ATTRIBUTE_COLD\t__attribute__((cold))\n#else\n# define unlikely(x)\t(x)\n# define likely(x)\t(x)\n# define ATTRIBUTE_COLD\n#endif\n\ntypedef enum {\n    ASSERT_EQUAL,\n    ASSERT_NOTEQUAL,\n    ASSERT_MATCH,\n    ASSERT_NOTMATCH,\n    ASSERT_OTHER\n} assert_type_T;\n\n// Mode for bracketed_paste().\ntypedef enum {\n    PASTE_INSERT,\t// insert mode\n    PASTE_CMDLINE,\t// command line\n    PASTE_EX,\t\t// ex mode line\n    PASTE_ONE_CHAR\t// return first character\n} paste_mode_T;\n\n// Argument for flush_buffers().\ntypedef enum {\n    FLUSH_MINIMAL,\n    FLUSH_TYPEAHEAD,\t// flush current typebuf contents\n    FLUSH_INPUT\t\t// flush typebuf and inchar() input\n} flush_buffers_T;\n\n// Argument for prepare_tagpreview()\ntypedef enum {\n    USEPOPUP_NONE,\n    USEPOPUP_NORMAL,\t// use info popup\n    USEPOPUP_HIDDEN\t// use info popup initially hidden\n} use_popup_T;\n\n// Argument for estack_sfile().\ntypedef enum {\n    ESTACK_NONE,\n    ESTACK_SFILE,\n    ESTACK_STACK\n} estack_arg_T;\n\n// Flags for assignment functions.\n#define ASSIGN_FINAL\t0x01  // \":final\"\n#define ASSIGN_CONST\t0x02  // \":const\"\n#define ASSIGN_NO_DECL\t0x04  // \"name = expr\" without \":let\"/\":const\"/\":final\"\n#define ASSIGN_DECL\t0x08  // may declare variable if it does not exist\n#define ASSIGN_UNPACK\t0x10  // using [a, b] = list\n#define ASSIGN_NO_MEMBER_TYPE 0x20 // use \"any\" for list and dict member type\n#define ASSIGN_FOR_LOOP 0x40 // assigning to loop variable\n\n#include \"ex_cmds.h\"\t    // Ex command defines\n#include \"spell.h\"\t    // spell checking stuff\n\n#include \"proto.h\"\t    // function prototypes\n\n// This has to go after the include of proto.h, as proto/gui.pro declares\n// functions of these names. The declarations would break if the defines had\n// been seen at that stage.  But it must be before globals.h, where error_ga\n// is declared.\n#if !defined(MSWIN) && !defined(FEAT_GUI_X11) && !defined(FEAT_GUI_HAIKU) \\\n\t&& !defined(FEAT_GUI_GTK) && !defined(PROTO)\n# define mch_errmsg(str)\tfprintf(stderr, \"%s\", (str))\n# define display_errors()\tfflush(stderr)\n# define mch_msg(str)\t\tprintf(\"%s\", (str))\n#else\n# define USE_MCH_ERRMSG\n#endif\n\n# if defined(FEAT_EVAL) \\\n\t&& (!defined(FEAT_GUI_MSWIN) || !defined(FEAT_MBYTE_IME))\n// Whether IME is supported by im_get_status() defined in mbyte.c.\n// For Win32 GUI it's in gui_w32.c when FEAT_MBYTE_IME is defined.\n# define IME_WITHOUT_XIM\n#endif\n\n#if defined(FEAT_XIM) \\\n\t|| defined(IME_WITHOUT_XIM) \\\n\t|| (defined(FEAT_GUI_MSWIN) && defined(FEAT_MBYTE_IME))\n// im_set_active() is available\n# define HAVE_INPUT_METHOD\n#endif\n\n#ifndef FEAT_LINEBREAK\n// Without the 'numberwidth' option line numbers are always 7 chars.\n# define number_width(x) 7\n#endif\n\n// This must come after including proto.h.\n// For VMS this is defined in macros.h.\n#if !defined(MSWIN) && !defined(VMS)\n# define mch_open(n, m, p)\topen((n), (m), (p))\n# define mch_fopen(n, p)\tfopen((n), (p))\n#endif\n\n#include \"globals.h\"\t    // global variables and messages\n#include \"errors.h\"\t    // error messages\n\n/*\n * If console dialog not supported, but GUI dialog is, use the GUI one.\n */\n#if defined(FEAT_GUI_DIALOG) && !defined(FEAT_CON_DIALOG)\n# define do_dialog gui_mch_dialog\n#endif\n\n/*\n * Default filters for gui_mch_browse().\n * The filters are almost system independent.  Except for the difference\n * between \"*\" and \"*.*\" for MSDOS-like systems.\n * NOTE: Motif only uses the very first pattern.  Therefore\n * BROWSE_FILTER_DEFAULT should start with a \"*\" pattern.\n */\n#ifdef FEAT_BROWSE\n# ifdef BACKSLASH_IN_FILENAME\n#  define BROWSE_FILTER_MACROS \\\n\t(char_u *)N_(\"Vim macro files (*.vim)\\t*.vim\\nAll Files (*.*)\\t*.*\\n\")\n#  define BROWSE_FILTER_ALL_FILES (char_u *)N_(\"All Files (*.*)\\t*.*\\n\")\n#  define BROWSE_FILTER_DEFAULT \\\n\t(char_u *)N_(\"All Files (*.*)\\t*.*\\nC source (*.c, *.h)\\t*.c;*.h\\nC++ source (*.cpp, *.hpp)\\t*.cpp;*.hpp\\nVB code (*.bas, *.frm)\\t*.bas;*.frm\\nVim files (*.vim, _vimrc, _gvimrc)\\t*.vim;_vimrc;_gvimrc\\n\")\n# else\n#  define BROWSE_FILTER_MACROS \\\n\t(char_u *)N_(\"Vim macro files (*.vim)\\t*.vim\\nAll Files (*)\\t*\\n\")\n#  define BROWSE_FILTER_ALL_FILES (char_u *)N_(\"All Files (*)\\t*\\n\")\n#  define BROWSE_FILTER_DEFAULT \\\n\t(char_u *)N_(\"All Files (*)\\t*\\nC source (*.c, *.h)\\t*.c;*.h\\nC++ source (*.cpp, *.hpp)\\t*.cpp;*.hpp\\nVim files (*.vim, _vimrc, _gvimrc)\\t*.vim;_vimrc;_gvimrc\\n\")\n# endif\n# define BROWSE_SAVE 1\t    // flag for do_browse()\n# define BROWSE_DIR 2\t    // flag for do_browse()\n#endif\n\n#ifdef _MSC_VER\n// Avoid useless warning \"conversion from X to Y of greater size\".\n #pragma warning(disable : 4312)\n// Avoid warning for old style function declarators\n #pragma warning(disable : 4131)\n// Avoid warning for conversion to type with smaller range\n #pragma warning(disable : 4244)\n// Avoid warning for conversion to larger size\n #pragma warning(disable : 4306)\n// Avoid warning for unreferenced formal parameter\n #pragma warning(disable : 4100)\n// Avoid warning for differs in indirection to slightly different base type\n #pragma warning(disable : 4057)\n// Avoid warning for constant conditional expression\n #pragma warning(disable : 4127)\n// Avoid warning for assignment within conditional\n #pragma warning(disable : 4706)\n#endif\n\n// Note: a NULL argument for vim_realloc() is not portable, don't use it.\n#if defined(MEM_PROFILE)\n# define vim_realloc(ptr, size)  mem_realloc((ptr), (size))\n#else\n# define vim_realloc(ptr, size)  realloc((ptr), (size))\n#endif\n\n/*\n * Return byte length of character that starts with byte \"b\".\n * Returns 1 for a single-byte character.\n * MB_BYTE2LEN_CHECK() can be used to count a special key as one byte.\n * Don't call MB_BYTE2LEN(b) with b < 0 or b > 255!\n */\n#define MB_BYTE2LEN(b)\t\tmb_bytelen_tab[b]\n#define MB_BYTE2LEN_CHECK(b)\t(((b) < 0 || (b) > 255) ? 1 : mb_bytelen_tab[b])\n\n// properties used in enc_canon_table[] (first three mutually exclusive)\n#define ENC_8BIT\t0x01\n#define ENC_DBCS\t0x02\n#define ENC_UNICODE\t0x04\n\n#define ENC_ENDIAN_B\t0x10\t    // Unicode: Big endian\n#define ENC_ENDIAN_L\t0x20\t    // Unicode: Little endian\n\n#define ENC_2BYTE\t0x40\t    // Unicode: UCS-2\n#define ENC_4BYTE\t0x80\t    // Unicode: UCS-4\n#define ENC_2WORD\t0x100\t    // Unicode: UTF-16\n\n#define ENC_LATIN1\t0x200\t    // Latin1\n#define ENC_LATIN9\t0x400\t    // Latin9\n#define ENC_MACROMAN\t0x800\t    // Mac Roman (not Macro Man! :-)\n\n#ifdef USE_ICONV\n# ifndef EILSEQ\n#  define EILSEQ 123\n# endif\n# ifdef DYNAMIC_ICONV\n// On Win32 iconv.dll is dynamically loaded.\n#  define ICONV_ERRNO (*iconv_errno())\n#  define ICONV_E2BIG  7\n#  define ICONV_EINVAL 22\n#  define ICONV_EILSEQ 42\n# else\n#  define ICONV_ERRNO errno\n#  define ICONV_E2BIG  E2BIG\n#  define ICONV_EINVAL EINVAL\n#  define ICONV_EILSEQ EILSEQ\n# endif\n#endif\n\n#define SIGN_BYTE 1\t    // byte value used where sign is displayed;\n\t\t\t    // attribute value is sign type\n\n#ifdef FEAT_NETBEANS_INTG\n# define MULTISIGN_BYTE 2   // byte value used where sign is displayed if\n\t\t\t    // multiple signs exist on the line\n#endif\n\n#if defined(FEAT_GUI) && defined(FEAT_XCLIPBOARD)\n# ifdef FEAT_GUI_GTK\n   // Avoid using a global variable for the X display.  It's ugly\n   // and is likely to cause trouble in multihead environments.\n#  define X_DISPLAY\t((gui.in_use) ? gui_mch_get_display() : xterm_dpy)\n# else\n#  define X_DISPLAY\t(gui.in_use ? gui.dpy : xterm_dpy)\n# endif\n#else\n# ifdef FEAT_GUI\n#  ifdef FEAT_GUI_GTK\n#   define X_DISPLAY\t((gui.in_use) ? gui_mch_get_display() : (Display *)NULL)\n#  else\n#   define X_DISPLAY\tgui.dpy\n#  endif\n# else\n#  define X_DISPLAY\txterm_dpy\n# endif\n#endif\n\n#if defined(FEAT_BROWSE) && defined(GTK_CHECK_VERSION)\n# if GTK_CHECK_VERSION(2,4,0)\n#  define USE_FILE_CHOOSER\n# endif\n#endif\n\n#ifdef FEAT_GUI_GTK\n# if !GTK_CHECK_VERSION(2,14,0)\n#  define gtk_widget_get_window(wid)\t((wid)->window)\n#  define gtk_plug_get_socket_window(wid)\t((wid)->socket_window)\n#  define gtk_selection_data_get_data(sel)\t((sel)->data)\n#  define gtk_selection_data_get_data_type(sel)\t((sel)->type)\n#  define gtk_selection_data_get_format(sel)\t((sel)->format)\n#  define gtk_selection_data_get_length(sel)\t((sel)->length)\n#  define gtk_adjustment_set_lower(adj, low) \\\n    do { (adj)->lower = low; } while (0)\n#  define gtk_adjustment_set_upper(adj, up) \\\n    do { (adj)->upper = up; } while (0)\n#  define gtk_adjustment_set_page_size(adj, size) \\\n    do { (adj)->page_size = size; } while (0)\n#  define gtk_adjustment_set_page_increment(adj, inc) \\\n    do { (adj)->page_increment = inc; } while (0)\n#  define gtk_adjustment_set_step_increment(adj, inc) \\\n    do { (adj)->step_increment = inc; } while (0)\n# endif\n# if !GTK_CHECK_VERSION(2,16,0)\n#  define gtk_selection_data_get_selection(sel)\t((sel)->selection)\n# endif\n# if !GTK_CHECK_VERSION(2,18,0)\n#  define gtk_widget_get_allocation(wid, alloc) \\\n    do { *(alloc) = (wid)->allocation; } while (0)\n#  define gtk_widget_set_allocation(wid, alloc) \\\n    do { (wid)->allocation = *(alloc); } while (0)\n#  define gtk_widget_get_has_window(wid)\t!GTK_WIDGET_NO_WINDOW(wid)\n#  define gtk_widget_get_sensitive(wid)\tGTK_WIDGET_SENSITIVE(wid)\n#  define gtk_widget_get_visible(wid)\tGTK_WIDGET_VISIBLE(wid)\n#  define gtk_widget_has_focus(wid)\tGTK_WIDGET_HAS_FOCUS(wid)\n#  define gtk_widget_set_window(wid, win) \\\n    do { (wid)->window = (win); } while (0)\n#  define gtk_widget_set_can_default(wid, can) \\\n    do { if (can) { GTK_WIDGET_SET_FLAGS(wid, GTK_CAN_DEFAULT); } \\\n\telse { GTK_WIDGET_UNSET_FLAGS(wid, GTK_CAN_DEFAULT); } } while (0)\n#  define gtk_widget_set_can_focus(wid, can) \\\n    do { if (can) { GTK_WIDGET_SET_FLAGS(wid, GTK_CAN_FOCUS); } \\\n\telse { GTK_WIDGET_UNSET_FLAGS(wid, GTK_CAN_FOCUS); } } while (0)\n#  define gtk_widget_set_visible(wid, vis) \\\n    do { if (vis) { gtk_widget_show(wid); } \\\n\telse { gtk_widget_hide(wid); } } while (0)\n# endif\n# if !GTK_CHECK_VERSION(2,20,0)\n#  define gtk_widget_get_mapped(wid)\tGTK_WIDGET_MAPPED(wid)\n#  define gtk_widget_get_realized(wid)\tGTK_WIDGET_REALIZED(wid)\n#  define gtk_widget_set_mapped(wid, map) \\\n    do { if (map) { GTK_WIDGET_SET_FLAGS(wid, GTK_MAPPED); } \\\n\telse { GTK_WIDGET_UNSET_FLAGS(wid, GTK_MAPPED); } } while (0)\n#  define gtk_widget_set_realized(wid, rea) \\\n    do { if (rea) { GTK_WIDGET_SET_FLAGS(wid, GTK_REALIZED); } \\\n\telse { GTK_WIDGET_UNSET_FLAGS(wid, GTK_REALIZED); } } while (0)\n# endif\n#endif\n\n#ifndef FEAT_NETBEANS_INTG\n# undef NBDEBUG\n#endif\n#ifdef NBDEBUG // Netbeans debugging.\n# include \"nbdebug.h\"\n#else\n# define nbdebug(a)\n#endif\n\n#ifdef IN_PERL_FILE\n  /*\n   * Avoid clashes between Perl and Vim namespace.\n   */\n# undef NORMAL\n# undef STRLEN\n# undef FF\n# undef OP_DELETE\n# undef OP_JOIN\n  // remove MAX and MIN, included by glib.h, redefined by sys/param.h\n# ifdef MAX\n#  undef MAX\n# endif\n# ifdef MIN\n#  undef MIN\n# endif\n  // We use _() for gettext(), Perl uses it for function prototypes...\n# ifdef _\n#  undef _\n# endif\n# ifdef DEBUG\n#  undef DEBUG\n# endif\n# ifdef _DEBUG\n#  undef _DEBUG\n# endif\n# ifdef instr\n#  undef instr\n# endif\n  // bool may cause trouble on some old versions of Mac OS X but is required\n  // on a few other systems and for Perl\n# if (defined(MACOS_X) && !defined(MAC_OS_X_VERSION_10_6)) \\\n\t\t\t\t       && defined(bool) && !defined(FEAT_PERL)\n#  undef bool\n# endif\n\n#endif\n\n// values for vim_handle_signal() that are not a signal\n#define SIGNAL_BLOCK\t-1\n#define SIGNAL_UNBLOCK  -2\n#if !defined(UNIX) && !defined(VMS)\n# define vim_handle_signal(x) 0\n#endif\n\n// flags for skip_vimgrep_pat()\n#define VGR_GLOBAL\t1\n#define VGR_NOJUMP\t2\n#define VGR_FUZZY\t4\n\n// behavior for bad character, \"++bad=\" argument\n#define BAD_REPLACE\t'?'\t// replace it with '?' (default)\n#define BAD_KEEP\t-1\t// leave it\n#define BAD_DROP\t-2\t// erase it\n\n// last argument for do_source()\n#define DOSO_NONE\t0\n#define DOSO_VIMRC\t1\t// loading vimrc file\n#define DOSO_GVIMRC\t2\t// loading gvimrc file\n\n// flags for read_viminfo() and children\n#define VIF_WANT_INFO\t    1\t// load non-mark info\n#define VIF_WANT_MARKS\t    2\t// load file marks\n#define VIF_ONLY_CURBUF\t    4\t// bail out after loading marks for curbuf\n#define VIF_FORCEIT\t    8\t// overwrite info already read\n#define VIF_GET_OLDFILES    16\t// load v:oldfiles\n\n// flags for buf_freeall()\n#define BFA_DEL\t\t 1\t// buffer is going to be deleted\n#define BFA_WIPE\t 2\t// buffer is going to be wiped out\n#define BFA_KEEP_UNDO\t 4\t// do not free undo information\n#define BFA_IGNORE_ABORT 8\t// do not abort for aborting()\n\n// direction for nv_mousescroll() and ins_mousescroll()\n#define MSCR_DOWN\t0\t// DOWN must be FALSE\n#define MSCR_UP\t\t1\n#define MSCR_LEFT\t-1\n#define MSCR_RIGHT\t-2\n\n#define KEYLEN_PART_KEY -1\t// keylen value for incomplete key-code\n#define KEYLEN_PART_MAP -2\t// keylen value for incomplete mapping\n#define KEYLEN_REMOVED  9999\t// keylen value for removed sequence\n\n// Return values from win32_fileinfo().\n#define FILEINFO_OK\t     0\n#define FILEINFO_ENC_FAIL    1\t// enc_to_utf16() failed\n#define FILEINFO_READ_FAIL   2\t// CreateFile() failed\n#define FILEINFO_INFO_FAIL   3\t// GetFileInformationByHandle() failed\n\n// Return value from get_option_value_strict\n#define SOPT_BOOL\t0x01\t// Boolean option\n#define SOPT_NUM\t0x02\t// Number option\n#define SOPT_STRING\t0x04\t// String option\n#define SOPT_GLOBAL\t0x08\t// Option has global value\n#define SOPT_WIN\t0x10\t// Option has window-local value\n#define SOPT_BUF\t0x20\t// Option has buffer-local value\n#define SOPT_UNSET\t0x40\t// Option does not have local value set\n\n// Option types for various functions in option.c\n#define SREQ_GLOBAL\t0\t// Request global option\n#define SREQ_WIN\t1\t// Request window-local option\n#define SREQ_BUF\t2\t// Request buffer-local option\n\n// Flags for get_reg_contents\n#define GREG_NO_EXPR\t1\t// Do not allow expression register\n#define GREG_EXPR_SRC\t2\t// Return expression itself for \"=\" register\n#define GREG_LIST\t4\t// Return list\n\n// Character used as separated in autoload function/variable names.\n#define AUTOLOAD_CHAR '#'\n\n#ifdef FEAT_JOB_CHANNEL\n# define MAX_OPEN_CHANNELS 10\n#else\n# define MAX_OPEN_CHANNELS 0\n#endif\n\n#if defined(MSWIN)\n# define MAX_NAMED_PIPE_SIZE 65535\n#endif\n\n// Options for json_encode() and json_decode.\n#define JSON_JS\t\t1   // use JS instead of JSON\n#define JSON_NO_NONE\t2   // v:none item not allowed\n#define JSON_NL\t\t4   // append a NL\n\n// Used for flags of do_in_path()\n#define DIP_ALL\t    0x01\t// all matches, not just the first one\n#define DIP_DIR\t    0x02\t// find directories instead of files.\n#define DIP_ERR\t    0x04\t// give an error message when none found.\n#define DIP_START   0x08\t// also use \"start\" directory in 'packpath'\n#define DIP_OPT\t    0x10\t// also use \"opt\" directory in 'packpath'\n#define DIP_NORTP   0x20\t// do not use 'runtimepath'\n#define DIP_NOAFTER 0x40\t// skip \"after\" directories\n#define DIP_AFTER   0x80\t// only use \"after\" directories\n\n// Lowest number used for window ID. Cannot have this many windows.\n#define LOWEST_WIN_ID 1000\n\n// Used by the garbage collector.\n#define COPYID_INC 2\n#define COPYID_MASK (~0x1)\n\n// Values for trans_function_name() argument:\n#define TFN_INT\t\t0x01\t// internal function name OK\n#define TFN_QUIET\t0x02\t// no error messages\n#define TFN_NO_AUTOLOAD\t0x04\t// do not use script autoloading\n#define TFN_NO_DEREF\t0x08\t// do not dereference a Funcref\n#define TFN_READ_ONLY\t0x10\t// will not change the var\n#define TFN_NO_DECL\t0x20\t// only used for GLV_NO_DECL\n#define TFN_COMPILING\t0x40\t// only used for GLV_COMPILING\n#define TFN_NEW_FUNC\t0x80\t// defining a new function\n\n// Values for get_lval() flags argument:\n#define GLV_QUIET\tTFN_QUIET\t// no error messages\n#define GLV_NO_AUTOLOAD\tTFN_NO_AUTOLOAD\t// do not use script autoloading\n#define GLV_READ_ONLY\tTFN_READ_ONLY\t// will not change the var\n#define GLV_NO_DECL\tTFN_NO_DECL\t// assignment without :var or :let\n#define GLV_COMPILING\tTFN_COMPILING\t// variable may be defined later\n\n#define DO_NOT_FREE_CNT 99999\t// refcount for dict or list that should not\n\t\t\t\t// be freed.\n\n// errors for when calling a function\n#define FCERR_UNKNOWN\t0\n#define FCERR_TOOMANY\t1\n#define FCERR_TOOFEW\t2\n#define FCERR_SCRIPT\t3\n#define FCERR_DICT\t4\n#define FCERR_NONE\t5\n#define FCERR_OTHER\t6\n#define FCERR_DELETED\t7\n#define FCERR_NOTMETHOD\t8   // function cannot be used as a method\n\n// fixed buffer length for fname_trans_sid()\n#define FLEN_FIXED 40\n\n// flags for find_name_end()\n#define FNE_INCL_BR\t1\t// include [] in name\n#define FNE_CHECK_START\t2\t// check name starts with valid character\n\n// BSD is supposed to cover FreeBSD and similar systems.\n#if (defined(SUN_SYSTEM) || defined(BSD) || defined(__FreeBSD_kernel__)) \\\n\t&& (defined(S_ISCHR) || defined(S_IFCHR))\n# define OPEN_CHR_FILES\n#endif\n\n// stat macros\n#ifndef S_ISDIR\n# ifdef S_IFDIR\n#  define S_ISDIR(m)\t(((m) & S_IFMT) == S_IFDIR)\n# else\n#  define S_ISDIR(m)\t0\n# endif\n#endif\n#ifndef S_ISREG\n# ifdef S_IFREG\n#  define S_ISREG(m)\t(((m) & S_IFMT) == S_IFREG)\n# else\n#  define S_ISREG(m)\t0\n# endif\n#endif\n#ifndef S_ISBLK\n# ifdef S_IFBLK\n#  define S_ISBLK(m)\t(((m) & S_IFMT) == S_IFBLK)\n# else\n#  define S_ISBLK(m)\t0\n# endif\n#endif\n#ifndef S_ISSOCK\n# ifdef S_IFSOCK\n#  define S_ISSOCK(m)\t(((m) & S_IFMT) == S_IFSOCK)\n# else\n#  define S_ISSOCK(m)\t0\n# endif\n#endif\n#ifndef S_ISFIFO\n# ifdef S_IFIFO\n#  define S_ISFIFO(m)\t(((m) & S_IFMT) == S_IFIFO)\n# else\n#  define S_ISFIFO(m)\t0\n# endif\n#endif\n#ifndef S_ISCHR\n# ifdef S_IFCHR\n#  define S_ISCHR(m)\t(((m) & S_IFMT) == S_IFCHR)\n# else\n#  define S_ISCHR(m)\t0\n# endif\n#endif\n#ifndef S_ISLNK\n# ifdef S_IFLNK\n#  define S_ISLNK(m)\t(((m) & S_IFMT) == S_IFLNK)\n# else\n#  define S_ISLNK(m)\t0\n# endif\n#endif\n\n#if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)\n# define ELAPSED_TIMEVAL\n# define ELAPSED_INIT(v) gettimeofday(&v, NULL)\n# define ELAPSED_FUNC(v) elapsed(&v)\ntypedef struct timeval elapsed_T;\nlong elapsed(struct timeval *start_tv);\n#elif defined(MSWIN)\n# define ELAPSED_TICKCOUNT\n# define ELAPSED_INIT(v) v = GetTickCount()\n# define ELAPSED_FUNC(v) elapsed(v)\n# ifdef PROTO\ntypedef int DWORD;\n# endif\ntypedef DWORD elapsed_T;\n# ifndef PROTO\nlong elapsed(DWORD start_tick);\n# endif\n#endif\n\n// Replacement for nchar used by nv_replace().\n#define REPLACE_CR_NCHAR    -1\n#define REPLACE_NL_NCHAR    -2\n\n// flags for term_start()\n#define TERM_START_NOJOB\t1\n#define TERM_START_FORCEIT\t2\n#define TERM_START_SYSTEM\t4\n\n// Used for icon/title save and restore.\n#define SAVE_RESTORE_TITLE\t1\n#define SAVE_RESTORE_ICON\t2\n#define SAVE_RESTORE_BOTH\t(SAVE_RESTORE_TITLE | SAVE_RESTORE_ICON)\n\n// Flags for adjust_prop_columns()\n#define APC_SAVE_FOR_UNDO\t1   // call u_savesub() before making changes\n#define APC_SUBSTITUTE\t\t2   // text is replaced, not inserted\n\n#define CLIP_ZINDEX 32000\n\n// Flags for replace_termcodes()\n#define REPTERM_FROM_PART\t1\n#define REPTERM_DO_LT\t\t2\n#define REPTERM_SPECIAL\t\t4\n#define REPTERM_NO_SIMPLIFY\t8\n\n// Flags for find_special_key()\n#define FSK_KEYCODE\t0x01\t// prefer key code, e.g. K_DEL instead of DEL\n#define FSK_KEEP_X_KEY\t0x02\t// don't translate xHome to Home key\n#define FSK_IN_STRING\t0x04\t// TRUE in string, double quote is escaped\n#define FSK_SIMPLIFY\t0x08\t// simplify <C-H> and <A-x>\n\n// Flags for the readdirex function, how to sort the result\n#define READDIR_SORT_NONE\t0  // do not sort\n#define READDIR_SORT_BYTE\t1  // sort by byte order (strcmp), default\n#define READDIR_SORT_IC\t\t2  // sort ignoring case (strcasecmp)\n#define READDIR_SORT_COLLATE\t3  // sort according to collation (strcoll)\n\n// Flags for mch_delay.\n#define MCH_DELAY_IGNOREINPUT\t1\n#define MCH_DELAY_SETTMODE\t2\n\n// Flags for eval_variable().\n#define EVAL_VAR_VERBOSE\t1   // may give error message\n#define EVAL_VAR_NOAUTOLOAD\t2   // do not use script autoloading\n#define EVAL_VAR_IMPORT\t\t4   // may return special variable for import\n#define EVAL_VAR_NO_FUNC\t8   // do not look for a function\n\n// Maximum number of characters that can be fuzzy matched\n#define MAX_FUZZY_MATCHES\t256\n\n// flags for equal_type()\n#define ETYPE_ARG_UNKNOWN 1\n\n// flags used by user commands and :autocmd\n#define UC_BUFFER\t1\t// -buffer: local to current buffer\n#define UC_VIM9\t\t2\t// {} argument: Vim9 syntax.\n\n// flags used by vim_strsave_escaped()\n#define VSE_NONE\t0\n#define VSE_SHELL\t1\t// escape for a shell command\n#define VSE_BUFFER\t2\t// escape for a \":buffer\" command\n\n// Flags used by find_func_even_dead()\n#define FFED_IS_GLOBAL\t1\t// \"g:\" was used\n#define FFED_NO_GLOBAL\t2\t// only check for script-local functions\n\n#endif // VIM__H\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * indent.c: Indentation related functions\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_VARTABS) || defined(PROTO)\n\n/*\n * Set the integer values corresponding to the string setting of 'vartabstop'.\n * \"array\" will be set, caller must free it if needed.\n * Return FAIL for an error.\n */\n    int\ntabstop_set(char_u *var, int **array)\n{\n    int\t    valcount = 1;\n    int\t    t;\n    char_u  *cp;\n\n    if (var[0] == NUL || (var[0] == '0' && var[1] == NUL))\n    {\n\t*array = NULL;\n\treturn OK;\n    }\n\n    for (cp = var; *cp != NUL; ++cp)\n    {\n\tif (cp == var || cp[-1] == ',')\n\t{\n\t    char_u *end;\n\n\t    if (strtol((char *)cp, (char **)&end, 10) <= 0)\n\t    {\n\t\tif (cp != end)\n\t\t    emsg(_(e_argument_must_be_positive));\n\t\telse\n\t\t    semsg(_(e_invalid_argument_str), cp);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\tif (VIM_ISDIGIT(*cp))\n\t    continue;\n\tif (cp[0] == ',' && cp > var && cp[-1] != ',' && cp[1] != NUL)\n\t{\n\t    ++valcount;\n\t    continue;\n\t}\n\tsemsg(_(e_invalid_argument_str), var);\n\treturn FAIL;\n    }\n\n    *array = ALLOC_MULT(int, valcount + 1);\n    if (*array == NULL)\n\treturn FAIL;\n    (*array)[0] = valcount;\n\n    t = 1;\n    for (cp = var; *cp != NUL;)\n    {\n\tint n = atoi((char *)cp);\n\n\t// Catch negative values, overflow and ridiculous big values.\n\tif (n < 0 || n > TABSTOP_MAX)\n\t{\n\t    semsg(_(e_invalid_argument_str), cp);\n\t    vim_free(*array);\n\t    *array = NULL;\n\t    return FAIL;\n\t}\n\t(*array)[t++] = n;\n\twhile (*cp != NUL && *cp != ',')\n\t    ++cp;\n\tif (*cp != NUL)\n\t    ++cp;\n    }\n\n    return OK;\n}\n\n/*\n * Calculate the number of screen spaces a tab will occupy.\n * If \"vts\" is set then the tab widths are taken from that array,\n * otherwise the value of ts is used.\n */\n    int\ntabstop_padding(colnr_T col, int ts_arg, int *vts)\n{\n    int\t\tts = ts_arg == 0 ? 8 : ts_arg;\n    int\t\ttabcount;\n    colnr_T\ttabcol = 0;\n    int\t\tt;\n    int\t\tpadding = 0;\n\n    if (vts == NULL || vts[0] == 0)\n\treturn ts - (col % ts);\n\n    tabcount = vts[0];\n\n    for (t = 1; t <= tabcount; ++t)\n    {\n\ttabcol += vts[t];\n\tif (tabcol > col)\n\t{\n\t    padding = (int)(tabcol - col);\n\t    break;\n\t}\n    }\n    if (t > tabcount)\n\tpadding = vts[tabcount] - (int)((col - tabcol) % vts[tabcount]);\n\n    return padding;\n}\n\n/*\n * Find the size of the tab that covers a particular column.\n */\n    int\ntabstop_at(colnr_T col, int ts, int *vts)\n{\n    int\t\ttabcount;\n    colnr_T\ttabcol = 0;\n    int\t\tt;\n    int\t\ttab_size = 0;\n\n    if (vts == 0 || vts[0] == 0)\n\treturn ts;\n\n    tabcount = vts[0];\n    for (t = 1; t <= tabcount; ++t)\n    {\n\ttabcol += vts[t];\n\tif (tabcol > col)\n\t{\n\t    tab_size = vts[t];\n\t    break;\n\t}\n    }\n    if (t > tabcount)\n\ttab_size = vts[tabcount];\n\n    return tab_size;\n}\n\n/*\n * Find the column on which a tab starts.\n */\n    colnr_T\ntabstop_start(colnr_T col, int ts, int *vts)\n{\n    int\t\ttabcount;\n    colnr_T\ttabcol = 0;\n    int\t\tt;\n    int         excess;\n\n    if (vts == NULL || vts[0] == 0)\n\treturn (col / ts) * ts;\n\n    tabcount = vts[0];\n    for (t = 1; t <= tabcount; ++t)\n    {\n\ttabcol += vts[t];\n\tif (tabcol > col)\n\t    return tabcol - vts[t];\n    }\n\n    excess = tabcol % vts[tabcount];\n    return excess + ((col - excess) / vts[tabcount]) * vts[tabcount];\n}\n\n/*\n * Find the number of tabs and spaces necessary to get from one column\n * to another.\n */\n    void\ntabstop_fromto(\n\tcolnr_T start_col,\n\tcolnr_T end_col,\n\tint\tts_arg,\n\tint\t*vts,\n\tint\t*ntabs,\n\tint\t*nspcs)\n{\n    int\t\tspaces = end_col - start_col;\n    colnr_T\ttabcol = 0;\n    int\t\tpadding = 0;\n    int\t\ttabcount;\n    int\t\tt;\n    int\t\tts = ts_arg == 0 ? curbuf->b_p_ts : ts_arg;\n\n    if (vts == NULL || vts[0] == 0)\n    {\n\tint tabs = 0;\n\tint initspc = 0;\n\n\tinitspc = ts - (start_col % ts);\n\tif (spaces >= initspc)\n\t{\n\t    spaces -= initspc;\n\t    tabs++;\n\t}\n\ttabs += spaces / ts;\n\tspaces -= (spaces / ts) * ts;\n\n\t*ntabs = tabs;\n\t*nspcs = spaces;\n\treturn;\n    }\n\n    // Find the padding needed to reach the next tabstop.\n    tabcount = vts[0];\n    for (t = 1; t <= tabcount; ++t)\n    {\n\ttabcol += vts[t];\n\tif (tabcol > start_col)\n\t{\n\t    padding = (int)(tabcol - start_col);\n\t    break;\n\t}\n    }\n    if (t > tabcount)\n\tpadding = vts[tabcount] - (int)((start_col - tabcol) % vts[tabcount]);\n\n    // If the space needed is less than the padding no tabs can be used.\n    if (spaces < padding)\n    {\n\t*ntabs = 0;\n\t*nspcs = spaces;\n\treturn;\n    }\n\n    *ntabs = 1;\n    spaces -= padding;\n\n    // At least one tab has been used. See if any more will fit.\n    while (spaces != 0 && ++t <= tabcount)\n    {\n\tpadding = vts[t];\n\tif (spaces < padding)\n\t{\n\t    *nspcs = spaces;\n\t    return;\n\t}\n\t++*ntabs;\n\tspaces -= padding;\n    }\n\n    *ntabs += spaces / vts[tabcount];\n    *nspcs =  spaces % vts[tabcount];\n}\n\n/*\n * See if two tabstop arrays contain the same values.\n */\n    static int\ntabstop_eq(int *ts1, int *ts2)\n{\n    int\t\tt;\n\n    if ((ts1 == 0 && ts2) || (ts1 && ts2 == 0))\n\treturn FALSE;\n    if (ts1 == ts2)\n\treturn TRUE;\n    if (ts1[0] != ts2[0])\n\treturn FALSE;\n\n    for (t = 1; t <= ts1[0]; ++t)\n\tif (ts1[t] != ts2[t])\n\t    return FALSE;\n\n    return TRUE;\n}\n\n# if defined(FEAT_BEVAL) || defined(PROTO)\n/*\n * Copy a tabstop array, allocating space for the new array.\n */\n    int *\ntabstop_copy(int *oldts)\n{\n    int\t\t*newts;\n    int\t\tt;\n\n    if (oldts == NULL)\n\treturn NULL;\n    newts = ALLOC_MULT(int, oldts[0] + 1);\n    if (newts != NULL)\n\tfor (t = 0; t <= oldts[0]; ++t)\n\t    newts[t] = oldts[t];\n    return newts;\n}\n# endif\n\n/*\n * Return a count of the number of tabstops.\n */\n    int\ntabstop_count(int *ts)\n{\n    return ts != NULL ? ts[0] : 0;\n}\n\n/*\n * Return the first tabstop, or 8 if there are no tabstops defined.\n */\n    int\ntabstop_first(int *ts)\n{\n    return ts != NULL ? ts[1] : 8;\n}\n\n#endif\n\n/*\n * Return the effective shiftwidth value for current buffer, using the\n * 'tabstop' value when 'shiftwidth' is zero.\n */\n    long\nget_sw_value(buf_T *buf)\n{\n    return get_sw_value_col(buf, 0);\n}\n\n/*\n * Idem, using \"pos\".\n */\n    static long\nget_sw_value_pos(buf_T *buf, pos_T *pos)\n{\n    pos_T save_cursor = curwin->w_cursor;\n    long sw_value;\n\n    curwin->w_cursor = *pos;\n    sw_value = get_sw_value_col(buf, get_nolist_virtcol());\n    curwin->w_cursor = save_cursor;\n    return sw_value;\n}\n\n/*\n * Idem, using the first non-black in the current line.\n */\n    long\nget_sw_value_indent(buf_T *buf)\n{\n    pos_T pos = curwin->w_cursor;\n\n    pos.col = getwhitecols_curline();\n    return get_sw_value_pos(buf, &pos);\n}\n\n/*\n * Idem, using virtual column \"col\".\n */\n    long\nget_sw_value_col(buf_T *buf, colnr_T col UNUSED)\n{\n    return buf->b_p_sw ? buf->b_p_sw :\n#ifdef FEAT_VARTABS\n\ttabstop_at(col, buf->b_p_ts, buf->b_p_vts_array);\n#else\n\tbuf->b_p_ts;\n#endif\n}\n\n/*\n * Return the effective softtabstop value for the current buffer, using the\n * 'shiftwidth' value when 'softtabstop' is negative.\n */\n    long\nget_sts_value(void)\n{\n    return curbuf->b_p_sts < 0 ? get_sw_value(curbuf) : curbuf->b_p_sts;\n}\n\n/*\n * Count the size (in window cells) of the indent in the current line.\n */\n    int\nget_indent(void)\n{\n#ifdef FEAT_VARTABS\n    return get_indent_str_vtab(ml_get_curline(), (int)curbuf->b_p_ts,\n\t\t\t\t\t\t curbuf->b_p_vts_array, FALSE);\n#else\n    return get_indent_str(ml_get_curline(), (int)curbuf->b_p_ts, FALSE);\n#endif\n}\n\n/*\n * Count the size (in window cells) of the indent in line \"lnum\".\n */\n    int\nget_indent_lnum(linenr_T lnum)\n{\n#ifdef FEAT_VARTABS\n    return get_indent_str_vtab(ml_get(lnum), (int)curbuf->b_p_ts,\n\t\t\t\t\t\t curbuf->b_p_vts_array, FALSE);\n#else\n    return get_indent_str(ml_get(lnum), (int)curbuf->b_p_ts, FALSE);\n#endif\n}\n\n#if defined(FEAT_FOLDING) || defined(PROTO)\n/*\n * Count the size (in window cells) of the indent in line \"lnum\" of buffer\n * \"buf\".\n */\n    int\nget_indent_buf(buf_T *buf, linenr_T lnum)\n{\n# ifdef FEAT_VARTABS\n    return get_indent_str_vtab(ml_get_buf(buf, lnum, FALSE),\n\t\t\t       (int)curbuf->b_p_ts, buf->b_p_vts_array, FALSE);\n# else\n    return get_indent_str(ml_get_buf(buf, lnum, FALSE), (int)buf->b_p_ts, FALSE);\n# endif\n}\n#endif\n\n/*\n * count the size (in window cells) of the indent in line \"ptr\", with\n * 'tabstop' at \"ts\"\n */\n    int\nget_indent_str(\n    char_u\t*ptr,\n    int\t\tts,\n    int\t\tlist) // if TRUE, count only screen size for tabs\n{\n    int\t\tcount = 0;\n\n    for ( ; *ptr; ++ptr)\n    {\n\tif (*ptr == TAB)\n\t{\n\t    if (!list || curwin->w_lcs_chars.tab1)\n\t\t// count a tab for what it is worth\n\t\tcount += ts - (count % ts);\n\t    else\n\t\t// In list mode, when tab is not set, count screen char width\n\t\t// for Tab, displays: ^I\n\t\tcount += ptr2cells(ptr);\n\t}\n\telse if (*ptr == ' ')\n\t    ++count;\t\t// count a space for one\n\telse\n\t    break;\n    }\n    return count;\n}\n\n#ifdef FEAT_VARTABS\n/*\n * Count the size (in window cells) of the indent in line \"ptr\", using\n * variable tabstops.\n * if \"list\" is TRUE, count only screen size for tabs.\n */\n    int\nget_indent_str_vtab(char_u *ptr, int ts, int *vts, int list)\n{\n    int\t\tcount = 0;\n\n    for ( ; *ptr; ++ptr)\n    {\n\tif (*ptr == TAB)    // count a tab for what it is worth\n\t{\n\t    if (!list || curwin->w_lcs_chars.tab1)\n\t\tcount += tabstop_padding(count, ts, vts);\n\t    else\n\t\t// In list mode, when tab is not set, count screen char width\n\t\t// for Tab, displays: ^I\n\t\tcount += ptr2cells(ptr);\n\t}\n\telse if (*ptr == ' ')\n\t    ++count;\t\t// count a space for one\n\telse\n\t    break;\n    }\n    return count;\n}\n#endif\n\n/*\n * Set the indent of the current line.\n * Leaves the cursor on the first non-blank in the line.\n * Caller must take care of undo.\n * \"flags\":\n *\tSIN_CHANGED:\tcall changed_bytes() if the line was changed.\n *\tSIN_INSERT:\tinsert the indent in front of the line.\n *\tSIN_UNDO:\tsave line for undo before changing it.\n * Returns TRUE if the line was changed.\n */\n    int\nset_indent(\n    int\t\tsize,\t\t    // measured in spaces\n    int\t\tflags)\n{\n    char_u\t*p;\n    char_u\t*newline;\n    char_u\t*oldline;\n    char_u\t*s;\n    int\t\ttodo;\n    int\t\tind_len;\t    // measured in characters\n    int\t\tline_len;\n    int\t\tdoit = FALSE;\n    int\t\tind_done = 0;\t    // measured in spaces\n#ifdef FEAT_VARTABS\n    int\t\tind_col = 0;\n#endif\n    int\t\ttab_pad;\n    int\t\tretval = FALSE;\n    int\t\torig_char_len = -1; // number of initial whitespace chars when\n\t\t\t\t    // 'et' and 'pi' are both set\n\n    // First check if there is anything to do and compute the number of\n    // characters needed for the indent.\n    todo = size;\n    ind_len = 0;\n    p = oldline = ml_get_curline();\n\n    // Calculate the buffer size for the new indent, and check to see if it\n    // isn't already set\n\n    // if 'expandtab' isn't set: use TABs; if both 'expandtab' and\n    // 'preserveindent' are set count the number of characters at the\n    // beginning of the line to be copied\n    if (!curbuf->b_p_et || (!(flags & SIN_INSERT) && curbuf->b_p_pi))\n    {\n\t// If 'preserveindent' is set then reuse as much as possible of\n\t// the existing indent structure for the new indent\n\tif (!(flags & SIN_INSERT) && curbuf->b_p_pi)\n\t{\n\t    ind_done = 0;\n\n\t    // count as many characters as we can use\n\t    while (todo > 0 && VIM_ISWHITE(*p))\n\t    {\n\t\tif (*p == TAB)\n\t\t{\n#ifdef FEAT_VARTABS\n\t\t    tab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,\n\t\t\t\t\t\t\tcurbuf->b_p_vts_array);\n#else\n\t\t    tab_pad = (int)curbuf->b_p_ts\n\t\t\t\t\t   - (ind_done % (int)curbuf->b_p_ts);\n#endif\n\t\t    // stop if this tab will overshoot the target\n\t\t    if (todo < tab_pad)\n\t\t\tbreak;\n\t\t    todo -= tab_pad;\n\t\t    ++ind_len;\n\t\t    ind_done += tab_pad;\n\t\t}\n\t\telse\n\t\t{\n\t\t    --todo;\n\t\t    ++ind_len;\n\t\t    ++ind_done;\n\t\t}\n\t\t++p;\n\t    }\n\n#ifdef FEAT_VARTABS\n\t    // These diverge from this point.\n\t    ind_col = ind_done;\n#endif\n\t    // Set initial number of whitespace chars to copy if we are\n\t    // preserving indent but expandtab is set\n\t    if (curbuf->b_p_et)\n\t\torig_char_len = ind_len;\n\n\t    // Fill to next tabstop with a tab, if possible\n#ifdef FEAT_VARTABS\n\t    tab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,\n\t\t\t\t\t\tcurbuf->b_p_vts_array);\n#else\n\t    tab_pad = (int)curbuf->b_p_ts - (ind_done % (int)curbuf->b_p_ts);\n#endif\n\t    if (todo >= tab_pad && orig_char_len == -1)\n\t    {\n\t\tdoit = TRUE;\n\t\ttodo -= tab_pad;\n\t\t++ind_len;\n\t\t// ind_done += tab_pad;\n#ifdef FEAT_VARTABS\n\t\tind_col += tab_pad;\n#endif\n\t    }\n\t}\n\n\t// count tabs required for indent\n#ifdef FEAT_VARTABS\n\tfor (;;)\n\t{\n\t    tab_pad = tabstop_padding(ind_col, curbuf->b_p_ts,\n\t\t\t\t\t\t\tcurbuf->b_p_vts_array);\n\t    if (todo < tab_pad)\n\t\tbreak;\n\t    if (*p != TAB)\n\t\tdoit = TRUE;\n\t    else\n\t\t++p;\n\t    todo -= tab_pad;\n\t    ++ind_len;\n\t    ind_col += tab_pad;\n\t}\n#else\n\twhile (todo >= (int)curbuf->b_p_ts)\n\t{\n\t    if (*p != TAB)\n\t\tdoit = TRUE;\n\t    else\n\t\t++p;\n\t    todo -= (int)curbuf->b_p_ts;\n\t    ++ind_len;\n\t    // ind_done += (int)curbuf->b_p_ts;\n\t}\n#endif\n    }\n    // count spaces required for indent\n    while (todo > 0)\n    {\n\tif (*p != ' ')\n\t    doit = TRUE;\n\telse\n\t    ++p;\n\t--todo;\n\t++ind_len;\n\t// ++ind_done;\n    }\n\n    // Return if the indent is OK already.\n    if (!doit && !VIM_ISWHITE(*p) && !(flags & SIN_INSERT))\n\treturn FALSE;\n\n    // Allocate memory for the new line.\n    if (flags & SIN_INSERT)\n\tp = oldline;\n    else\n\tp = skipwhite(p);\n    line_len = (int)STRLEN(p) + 1;\n\n    // If 'preserveindent' and 'expandtab' are both set keep the original\n    // characters and allocate accordingly.  We will fill the rest with spaces\n    // after the if (!curbuf->b_p_et) below.\n    if (orig_char_len != -1)\n    {\n\tnewline = alloc(orig_char_len + size - ind_done + line_len);\n\tif (newline == NULL)\n\t    return FALSE;\n\ttodo = size - ind_done;\n\tind_len = orig_char_len + todo;    // Set total length of indent in\n\t\t\t\t\t   // characters, which may have been\n\t\t\t\t\t   // undercounted until now\n\tp = oldline;\n\ts = newline;\n\twhile (orig_char_len > 0)\n\t{\n\t    *s++ = *p++;\n\t    orig_char_len--;\n\t}\n\n\t// Skip over any additional white space (useful when newindent is less\n\t// than old)\n\twhile (VIM_ISWHITE(*p))\n\t    ++p;\n\n    }\n    else\n    {\n\ttodo = size;\n\tnewline = alloc(ind_len + line_len);\n\tif (newline == NULL)\n\t    return FALSE;\n\ts = newline;\n    }\n\n    // Put the characters in the new line.\n    // if 'expandtab' isn't set: use TABs\n    if (!curbuf->b_p_et)\n    {\n\t// If 'preserveindent' is set then reuse as much as possible of\n\t// the existing indent structure for the new indent\n\tif (!(flags & SIN_INSERT) && curbuf->b_p_pi)\n\t{\n\t    p = oldline;\n\t    ind_done = 0;\n\n\t    while (todo > 0 && VIM_ISWHITE(*p))\n\t    {\n\t\tif (*p == TAB)\n\t\t{\n#ifdef FEAT_VARTABS\n\t\t    tab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,\n\t\t\t\t\t\t\tcurbuf->b_p_vts_array);\n#else\n\t\t    tab_pad = (int)curbuf->b_p_ts\n\t\t\t\t\t   - (ind_done % (int)curbuf->b_p_ts);\n#endif\n\t\t    // stop if this tab will overshoot the target\n\t\t    if (todo < tab_pad)\n\t\t\tbreak;\n\t\t    todo -= tab_pad;\n\t\t    ind_done += tab_pad;\n\t\t}\n\t\telse\n\t\t{\n\t\t    --todo;\n\t\t    ++ind_done;\n\t\t}\n\t\t*s++ = *p++;\n\t    }\n\n\t    // Fill to next tabstop with a tab, if possible\n#ifdef FEAT_VARTABS\n\t    tab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,\n\t\t\t\t\t\tcurbuf->b_p_vts_array);\n#else\n\t    tab_pad = (int)curbuf->b_p_ts - (ind_done % (int)curbuf->b_p_ts);\n#endif\n\t    if (todo >= tab_pad)\n\t    {\n\t\t*s++ = TAB;\n\t\ttodo -= tab_pad;\n#ifdef FEAT_VARTABS\n\t\tind_done += tab_pad;\n#endif\n\t    }\n\n\t    p = skipwhite(p);\n\t}\n\n#ifdef FEAT_VARTABS\n\tfor (;;)\n\t{\n\t    tab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,\n\t\t\t\t\t\t\tcurbuf->b_p_vts_array);\n\t    if (todo < tab_pad)\n\t\tbreak;\n\t    *s++ = TAB;\n\t    todo -= tab_pad;\n\t    ind_done += tab_pad;\n\t}\n#else\n\twhile (todo >= (int)curbuf->b_p_ts)\n\t{\n\t    *s++ = TAB;\n\t    todo -= (int)curbuf->b_p_ts;\n\t}\n#endif\n    }\n    while (todo > 0)\n    {\n\t*s++ = ' ';\n\t--todo;\n    }\n    mch_memmove(s, p, (size_t)line_len);\n\n    // Replace the line (unless undo fails).\n    if (!(flags & SIN_UNDO) || u_savesub(curwin->w_cursor.lnum) == OK)\n    {\n\tcolnr_T old_offset = (colnr_T)(p - oldline);\n\tcolnr_T new_offset = (colnr_T)(s - newline);\n\n\t// this may free \"newline\"\n\tml_replace(curwin->w_cursor.lnum, newline, FALSE);\n\tif (flags & SIN_CHANGED)\n\t    changed_bytes(curwin->w_cursor.lnum, 0);\n\n\t// Correct saved cursor position if it is in this line.\n\tif (saved_cursor.lnum == curwin->w_cursor.lnum)\n\t{\n\t    if (saved_cursor.col >= old_offset)\n\t\t// cursor was after the indent, adjust for the number of\n\t\t// bytes added/removed\n\t\tsaved_cursor.col += ind_len - old_offset;\n\t    else if (saved_cursor.col >= new_offset)\n\t\t// cursor was in the indent, and is now after it, put it back\n\t\t// at the start of the indent (replacing spaces with TAB)\n\t\tsaved_cursor.col = new_offset;\n\t}\n#ifdef FEAT_PROP_POPUP\n\t{\n\t    int added = ind_len - old_offset;\n\n\t    // When increasing indent this behaves like spaces were inserted at\n\t    // the old indent, when decreasing indent it behaves like spaces\n\t    // were deleted at the new indent.\n\t    adjust_prop_columns(curwin->w_cursor.lnum,\n\t\t\t  added > 0 ? old_offset : (colnr_T)ind_len, added, 0);\n\t}\n#endif\n\tretval = TRUE;\n    }\n    else\n\tvim_free(newline);\n\n    curwin->w_cursor.col = ind_len;\n    return retval;\n}\n\n/*\n * Return the indent of the current line after a number.  Return -1 if no\n * number was found.  Used for 'n' in 'formatoptions': numbered list.\n * Since a pattern is used it can actually handle more than numbers.\n */\n    int\nget_number_indent(linenr_T lnum)\n{\n    colnr_T\tcol;\n    pos_T\tpos;\n\n    regmatch_T\tregmatch;\n    int\t\tlead_len = 0;\t// length of comment leader\n\n    if (lnum > curbuf->b_ml.ml_line_count)\n\treturn -1;\n    pos.lnum = 0;\n\n    // In format_lines() (i.e. not insert mode), fo+=q is needed too...\n    if ((State & INSERT) || has_format_option(FO_Q_COMS))\n\tlead_len = get_leader_len(ml_get(lnum), NULL, FALSE, TRUE);\n\n    regmatch.regprog = vim_regcomp(curbuf->b_p_flp, RE_MAGIC);\n    if (regmatch.regprog != NULL)\n    {\n\tregmatch.rm_ic = FALSE;\n\n\t// vim_regexec() expects a pointer to a line.  This lets us\n\t// start matching for the flp beyond any comment leader...\n\tif (vim_regexec(&regmatch, ml_get(lnum) + lead_len, (colnr_T)0))\n\t{\n\t    pos.lnum = lnum;\n\t    pos.col = (colnr_T)(*regmatch.endp - ml_get(lnum));\n\t    pos.coladd = 0;\n\t}\n\tvim_regfree(regmatch.regprog);\n    }\n\n    if (pos.lnum == 0 || *ml_get_pos(&pos) == NUL)\n\treturn -1;\n    getvcol(curwin, &pos, &col, NULL, NULL);\n    return (int)col;\n}\n\n#if defined(FEAT_LINEBREAK) || defined(PROTO)\n/*\n * This is called when 'breakindentopt' is changed and when a window is\n * initialized.\n */\n    int\nbriopt_check(win_T *wp)\n{\n    char_u\t*p;\n    int\t\tbri_shift = 0;\n    long\tbri_min = 20;\n    int\t\tbri_sbr = FALSE;\n    int\t\tbri_list = 0;\n\n    p = wp->w_p_briopt;\n    while (*p != NUL)\n    {\n\tif (STRNCMP(p, \"shift:\", 6) == 0\n\t\t && ((p[6] == '-' && VIM_ISDIGIT(p[7])) || VIM_ISDIGIT(p[6])))\n\t{\n\t    p += 6;\n\t    bri_shift = getdigits(&p);\n\t}\n\telse if (STRNCMP(p, \"min:\", 4) == 0 && VIM_ISDIGIT(p[4]))\n\t{\n\t    p += 4;\n\t    bri_min = getdigits(&p);\n\t}\n\telse if (STRNCMP(p, \"sbr\", 3) == 0)\n\t{\n\t    p += 3;\n\t    bri_sbr = TRUE;\n\t}\n\telse if (STRNCMP(p, \"list:\", 5) == 0)\n\t{\n\t    p += 5;\n\t    bri_list = getdigits(&p);\n\t}\n\tif (*p != ',' && *p != NUL)\n\t    return FAIL;\n\tif (*p == ',')\n\t    ++p;\n    }\n\n    wp->w_briopt_shift = bri_shift;\n    wp->w_briopt_min   = bri_min;\n    wp->w_briopt_sbr   = bri_sbr;\n    wp->w_briopt_list  = bri_list;\n\n    return OK;\n}\n\n/*\n * Return appropriate space number for breakindent, taking influencing\n * parameters into account. Window must be specified, since it is not\n * necessarily always the current one.\n */\n    int\nget_breakindent_win(\n    win_T\t*wp,\n    char_u\t*line) // start of the line\n{\n    static int\t    prev_indent = 0;\t// cached indent value\n    static long\t    prev_ts     = 0L;\t// cached tabstop value\n    static char_u   *prev_line = NULL;\t// cached pointer to line\n    static varnumber_T prev_tick = 0;   // changedtick of cached value\n# ifdef FEAT_VARTABS\n    static int      *prev_vts = NULL;   // cached vartabs values\n# endif\n    static int      prev_list = 0;\t// cached list value\n    static int      prev_listopt = 0;\t// cached w_p_briopt_list value\n    // cached formatlistpat value\n    static char_u   *prev_flp = NULL;\n    int\t\t    bri = 0;\n    // window width minus window margin space, i.e. what rests for text\n    const int\t    eff_wwidth = wp->w_width\n\t\t\t    - ((wp->w_p_nu || wp->w_p_rnu)\n\t\t\t\t&& (vim_strchr(p_cpo, CPO_NUMCOL) == NULL)\n\t\t\t\t\t\t? number_width(wp) + 1 : 0);\n\n    // used cached indent, unless\n    // - line pointer changed\n    // - 'tabstop' changed\n    // - 'briopt_list changed' changed or\n    // - 'formatlistpattern' changed\n    if (prev_line != line || prev_ts != wp->w_buffer->b_p_ts\n\t    || prev_tick != CHANGEDTICK(wp->w_buffer)\n\t    || prev_listopt != wp->w_briopt_list\n\t    || (prev_flp == NULL\n\t\t|| (STRCMP(prev_flp, get_flp_value(wp->w_buffer)) != 0))\n# ifdef FEAT_VARTABS\n\t    || prev_vts != wp->w_buffer->b_p_vts_array\n# endif\n\t)\n    {\n\tprev_line = line;\n\tprev_ts = wp->w_buffer->b_p_ts;\n\tprev_tick = CHANGEDTICK(wp->w_buffer);\n# ifdef FEAT_VARTABS\n\tprev_vts = wp->w_buffer->b_p_vts_array;\n\tprev_indent = get_indent_str_vtab(line,\n\t\t\t\t     (int)wp->w_buffer->b_p_ts,\n\t\t\t\t    wp->w_buffer->b_p_vts_array, wp->w_p_list);\n# else\n\tprev_indent = get_indent_str(line,\n\t\t\t\t     (int)wp->w_buffer->b_p_ts, wp->w_p_list);\n# endif\n\tprev_listopt = wp->w_briopt_list;\n\tprev_list = 0;\n\tvim_free(prev_flp);\n\tprev_flp = vim_strsave(get_flp_value(wp->w_buffer));\n\t// add additional indent for numbered lists\n\tif (wp->w_briopt_list != 0)\n\t{\n\t    regmatch_T\t    regmatch;\n\n\t    regmatch.regprog = vim_regcomp(prev_flp,\n\t\t\t\t   RE_MAGIC + RE_STRING + RE_AUTO + RE_STRICT);\n\n\t    if (regmatch.regprog != NULL)\n\t    {\n\t\tregmatch.rm_ic = FALSE;\n\t\tif (vim_regexec(&regmatch, line, 0))\n\t\t{\n\t\t    if (wp->w_briopt_list > 0)\n\t\t\tprev_list = wp->w_briopt_list;\n\t\t    else\n\t\t\tprev_list = (*regmatch.endp - *regmatch.startp);\n\t\t}\n\t\tvim_regfree(regmatch.regprog);\n\t    }\n\t}\n    }\n    bri = prev_indent + wp->w_briopt_shift;\n\n    // Add offset for number column, if 'n' is in 'cpoptions'\n    bri += win_col_off2(wp);\n\n    // add additional indent for numbered lists\n    if (wp->w_briopt_list != 0)\n    {\n\tif (wp->w_briopt_list > 0)\n\t    bri += prev_list;\n\telse\n\t    bri = prev_list;\n    }\n\n    // indent minus the length of the showbreak string\n    if (wp->w_briopt_sbr)\n\tbri -= vim_strsize(get_showbreak_value(wp));\n\n\n    // never indent past left window margin\n    if (bri < 0)\n\tbri = 0;\n\n    // always leave at least bri_min characters on the left,\n    // if text width is sufficient\n    else if (bri > eff_wwidth - wp->w_briopt_min)\n\tbri = (eff_wwidth - wp->w_briopt_min < 0)\n\t\t\t\t\t   ? 0 : eff_wwidth - wp->w_briopt_min;\n\n    return bri;\n}\n#endif\n\n/*\n * When extra == 0: Return TRUE if the cursor is before or on the first\n *\t\t    non-blank in the line.\n * When extra == 1: Return TRUE if the cursor is before the first non-blank in\n *\t\t    the line.\n */\n    int\ninindent(int extra)\n{\n    char_u\t*ptr;\n    colnr_T\tcol;\n\n    for (col = 0, ptr = ml_get_curline(); VIM_ISWHITE(*ptr); ++col)\n\t++ptr;\n    if (col >= curwin->w_cursor.col + extra)\n\treturn TRUE;\n    else\n\treturn FALSE;\n}\n\n#if defined(FEAT_LISP) || defined(FEAT_CINDENT) || defined(PROTO)\n/*\n * op_reindent - handle reindenting a block of lines.\n */\n    void\nop_reindent(oparg_T *oap, int (*how)(void))\n{\n    long\ti;\n    char_u\t*l;\n    int\t\tamount;\n    linenr_T\tfirst_changed = 0;\n    linenr_T\tlast_changed = 0;\n    linenr_T\tstart_lnum = curwin->w_cursor.lnum;\n\n    // Don't even try when 'modifiable' is off.\n    if (!curbuf->b_p_ma)\n    {\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\treturn;\n    }\n\n    for (i = oap->line_count; --i >= 0 && !got_int; )\n    {\n\t// it's a slow thing to do, so give feedback so there's no worry that\n\t// the computer's just hung.\n\n\tif (i > 1\n\t\t&& (i % 50 == 0 || i == oap->line_count - 1)\n\t\t&& oap->line_count > p_report)\n\t    smsg(_(\"%ld lines to indent... \"), i);\n\n\t// Be vi-compatible: For lisp indenting the first line is not\n\t// indented, unless there is only one line.\n# ifdef FEAT_LISP\n\tif (i != oap->line_count - 1 || oap->line_count == 1\n\t\t\t\t\t\t    || how != get_lisp_indent)\n# endif\n\t{\n\t    l = skipwhite(ml_get_curline());\n\t    if (*l == NUL)\t\t    // empty or blank line\n\t\tamount = 0;\n\t    else\n\t\tamount = how();\t\t    // get the indent for this line\n\n\t    if (amount >= 0 && set_indent(amount, SIN_UNDO))\n\t    {\n\t\t// did change the indent, call changed_lines() later\n\t\tif (first_changed == 0)\n\t\t    first_changed = curwin->w_cursor.lnum;\n\t\tlast_changed = curwin->w_cursor.lnum;\n\t    }\n\t}\n\t++curwin->w_cursor.lnum;\n\tcurwin->w_cursor.col = 0;  // make sure it's valid\n    }\n\n    // put cursor on first non-blank of indented line\n    curwin->w_cursor.lnum = start_lnum;\n    beginline(BL_SOL | BL_FIX);\n\n    // Mark changed lines so that they will be redrawn.  When Visual\n    // highlighting was present, need to continue until the last line.  When\n    // there is no change still need to remove the Visual highlighting.\n    if (last_changed != 0)\n\tchanged_lines(first_changed, 0,\n\t\toap->is_VIsual ? start_lnum + oap->line_count :\n\t\tlast_changed + 1, 0L);\n    else if (oap->is_VIsual)\n\tredraw_curbuf_later(INVERTED);\n\n    if (oap->line_count > p_report)\n    {\n\ti = oap->line_count - (i + 1);\n\tsmsg(NGETTEXT(\"%ld line indented \",\n\t\t\t\t\t\t \"%ld lines indented \", i), i);\n    }\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// set '[ and '] marks\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end = oap->end;\n    }\n}\n#endif // defined(FEAT_LISP) || defined(FEAT_CINDENT)\n\n#if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT) || defined(PROTO)\n/*\n * Return TRUE if lines starting with '#' should be left aligned.\n */\n    int\npreprocs_left(void)\n{\n    return\n# ifdef FEAT_SMARTINDENT\n#  ifdef FEAT_CINDENT\n\t(curbuf->b_p_si && !curbuf->b_p_cin) ||\n#  else\n\tcurbuf->b_p_si\n#  endif\n# endif\n# ifdef FEAT_CINDENT\n\t(curbuf->b_p_cin && in_cinkeys('#', ' ', TRUE)\n\t\t\t\t\t   && curbuf->b_ind_hash_comment == 0)\n# endif\n\t;\n}\n#endif\n\n#ifdef FEAT_SMARTINDENT\n/*\n * Try to do some very smart auto-indenting.\n * Used when inserting a \"normal\" character.\n */\n    void\nins_try_si(int c)\n{\n    pos_T\t*pos, old_pos;\n    char_u\t*ptr;\n    int\t\ti;\n    int\t\ttemp;\n\n    // do some very smart indenting when entering '{' or '}'\n    if (((did_si || can_si_back) && c == '{') || (can_si && c == '}'))\n    {\n\t// for '}' set indent equal to indent of line containing matching '{'\n\tif (c == '}' && (pos = findmatch(NULL, '{')) != NULL)\n\t{\n\t    old_pos = curwin->w_cursor;\n\t    // If the matching '{' has a ')' immediately before it (ignoring\n\t    // white-space), then line up with the start of the line\n\t    // containing the matching '(' if there is one.  This handles the\n\t    // case where an \"if (..\\n..) {\" statement continues over multiple\n\t    // lines -- webb\n\t    ptr = ml_get(pos->lnum);\n\t    i = pos->col;\n\t    if (i > 0)\t\t// skip blanks before '{'\n\t\twhile (--i > 0 && VIM_ISWHITE(ptr[i]))\n\t\t    ;\n\t    curwin->w_cursor.lnum = pos->lnum;\n\t    curwin->w_cursor.col = i;\n\t    if (ptr[i] == ')' && (pos = findmatch(NULL, '(')) != NULL)\n\t\tcurwin->w_cursor = *pos;\n\t    i = get_indent();\n\t    curwin->w_cursor = old_pos;\n\t    if (State & VREPLACE_FLAG)\n\t\tchange_indent(INDENT_SET, i, FALSE, NUL, TRUE);\n\t    else\n\t\t(void)set_indent(i, SIN_CHANGED);\n\t}\n\telse if (curwin->w_cursor.col > 0)\n\t{\n\t    // when inserting '{' after \"O\" reduce indent, but not\n\t    // more than indent of previous line\n\t    temp = TRUE;\n\t    if (c == '{' && can_si_back && curwin->w_cursor.lnum > 1)\n\t    {\n\t\told_pos = curwin->w_cursor;\n\t\ti = get_indent();\n\t\twhile (curwin->w_cursor.lnum > 1)\n\t\t{\n\t\t    ptr = skipwhite(ml_get(--(curwin->w_cursor.lnum)));\n\n\t\t    // ignore empty lines and lines starting with '#'.\n\t\t    if (*ptr != '#' && *ptr != NUL)\n\t\t\tbreak;\n\t\t}\n\t\tif (get_indent() >= i)\n\t\t    temp = FALSE;\n\t\tcurwin->w_cursor = old_pos;\n\t    }\n\t    if (temp)\n\t\tshift_line(TRUE, FALSE, 1, TRUE);\n\t}\n    }\n\n    // set indent of '#' always to 0\n    if (curwin->w_cursor.col > 0 && can_si && c == '#')\n    {\n\t// remember current indent for next line\n\told_indent = get_indent();\n\t(void)set_indent(0, SIN_CHANGED);\n    }\n\n    // Adjust ai_col, the char at this position can be deleted.\n    if (ai_col > curwin->w_cursor.col)\n\tai_col = curwin->w_cursor.col;\n}\n#endif\n\n/*\n * Insert an indent (for <Tab> or CTRL-T) or delete an indent (for CTRL-D).\n * Keep the cursor on the same character.\n * type == INDENT_INC\tincrease indent (for CTRL-T or <Tab>)\n * type == INDENT_DEC\tdecrease indent (for CTRL-D)\n * type == INDENT_SET\tset indent to \"amount\"\n * if round is TRUE, round the indent to 'shiftwidth' (only with _INC and _Dec).\n */\n    void\nchange_indent(\n    int\t\ttype,\n    int\t\tamount,\n    int\t\tround,\n    int\t\treplaced,\t// replaced character, put on replace stack\n    int\t\tcall_changed_bytes)\t// call changed_bytes()\n{\n    int\t\tvcol;\n    int\t\tlast_vcol;\n    int\t\tinsstart_less;\t\t// reduction for Insstart.col\n    int\t\tnew_cursor_col;\n    int\t\ti;\n    char_u\t*ptr;\n    int\t\tsave_p_list;\n    int\t\tstart_col;\n    colnr_T\tvc;\n    colnr_T\torig_col = 0;\t\t// init for GCC\n    char_u\t*new_line, *orig_line = NULL;\t// init for GCC\n\n    // VREPLACE mode needs to know what the line was like before changing\n    if (State & VREPLACE_FLAG)\n    {\n\torig_line = vim_strsave(ml_get_curline());  // Deal with NULL below\n\torig_col = curwin->w_cursor.col;\n    }\n\n    // for the following tricks we don't want list mode\n    save_p_list = curwin->w_p_list;\n    curwin->w_p_list = FALSE;\n    vc = getvcol_nolist(&curwin->w_cursor);\n    vcol = vc;\n\n    // For Replace mode we need to fix the replace stack later, which is only\n    // possible when the cursor is in the indent.  Remember the number of\n    // characters before the cursor if it's possible.\n    start_col = curwin->w_cursor.col;\n\n    // determine offset from first non-blank\n    new_cursor_col = curwin->w_cursor.col;\n    beginline(BL_WHITE);\n    new_cursor_col -= curwin->w_cursor.col;\n\n    insstart_less = curwin->w_cursor.col;\n\n    // If the cursor is in the indent, compute how many screen columns the\n    // cursor is to the left of the first non-blank.\n    if (new_cursor_col < 0)\n\tvcol = get_indent() - vcol;\n\n    if (new_cursor_col > 0)\t    // can't fix replace stack\n\tstart_col = -1;\n\n    // Set the new indent.  The cursor will be put on the first non-blank.\n    if (type == INDENT_SET)\n\t(void)set_indent(amount, call_changed_bytes ? SIN_CHANGED : 0);\n    else\n    {\n\tint\tsave_State = State;\n\n\t// Avoid being called recursively.\n\tif (State & VREPLACE_FLAG)\n\t    State = INSERT;\n\tshift_line(type == INDENT_DEC, round, 1, call_changed_bytes);\n\tState = save_State;\n    }\n    insstart_less -= curwin->w_cursor.col;\n\n    // Try to put cursor on same character.\n    // If the cursor is at or after the first non-blank in the line,\n    // compute the cursor column relative to the column of the first\n    // non-blank character.\n    // If we are not in insert mode, leave the cursor on the first non-blank.\n    // If the cursor is before the first non-blank, position it relative\n    // to the first non-blank, counted in screen columns.\n    if (new_cursor_col >= 0)\n    {\n\t// When changing the indent while the cursor is touching it, reset\n\t// Insstart_col to 0.\n\tif (new_cursor_col == 0)\n\t    insstart_less = MAXCOL;\n\tnew_cursor_col += curwin->w_cursor.col;\n    }\n    else if (!(State & INSERT))\n\tnew_cursor_col = curwin->w_cursor.col;\n    else\n    {\n\t// Compute the screen column where the cursor should be.\n\tvcol = get_indent() - vcol;\n\tcurwin->w_virtcol = (colnr_T)((vcol < 0) ? 0 : vcol);\n\n\t// Advance the cursor until we reach the right screen column.\n\tvcol = last_vcol = 0;\n\tnew_cursor_col = -1;\n\tptr = ml_get_curline();\n\twhile (vcol <= (int)curwin->w_virtcol)\n\t{\n\t    last_vcol = vcol;\n\t    if (has_mbyte && new_cursor_col >= 0)\n\t\tnew_cursor_col += (*mb_ptr2len)(ptr + new_cursor_col);\n\t    else\n\t\t++new_cursor_col;\n\t    vcol += lbr_chartabsize(ptr, ptr + new_cursor_col, (colnr_T)vcol);\n\t}\n\tvcol = last_vcol;\n\n\t// May need to insert spaces to be able to position the cursor on\n\t// the right screen column.\n\tif (vcol != (int)curwin->w_virtcol)\n\t{\n\t    curwin->w_cursor.col = (colnr_T)new_cursor_col;\n\t    i = (int)curwin->w_virtcol - vcol;\n\t    ptr = alloc(i + 1);\n\t    if (ptr != NULL)\n\t    {\n\t\tnew_cursor_col += i;\n\t\tptr[i] = NUL;\n\t\twhile (--i >= 0)\n\t\t    ptr[i] = ' ';\n\t\tins_str(ptr);\n\t\tvim_free(ptr);\n\t    }\n\t}\n\n\t// When changing the indent while the cursor is in it, reset\n\t// Insstart_col to 0.\n\tinsstart_less = MAXCOL;\n    }\n\n    curwin->w_p_list = save_p_list;\n\n    if (new_cursor_col <= 0)\n\tcurwin->w_cursor.col = 0;\n    else\n\tcurwin->w_cursor.col = (colnr_T)new_cursor_col;\n    curwin->w_set_curswant = TRUE;\n    changed_cline_bef_curs();\n\n    // May have to adjust the start of the insert.\n    if (State & INSERT)\n    {\n\tif (curwin->w_cursor.lnum == Insstart.lnum && Insstart.col != 0)\n\t{\n\t    if ((int)Insstart.col <= insstart_less)\n\t\tInsstart.col = 0;\n\t    else\n\t\tInsstart.col -= insstart_less;\n\t}\n\tif ((int)ai_col <= insstart_less)\n\t    ai_col = 0;\n\telse\n\t    ai_col -= insstart_less;\n    }\n\n    // For REPLACE mode, may have to fix the replace stack, if it's possible.\n    // If the number of characters before the cursor decreased, need to pop a\n    // few characters from the replace stack.\n    // If the number of characters before the cursor increased, need to push a\n    // few NULs onto the replace stack.\n    if (REPLACE_NORMAL(State) && start_col >= 0)\n    {\n\twhile (start_col > (int)curwin->w_cursor.col)\n\t{\n\t    replace_join(0);\t    // remove a NUL from the replace stack\n\t    --start_col;\n\t}\n\twhile (start_col < (int)curwin->w_cursor.col || replaced)\n\t{\n\t    replace_push(NUL);\n\t    if (replaced)\n\t    {\n\t\treplace_push(replaced);\n\t\treplaced = NUL;\n\t    }\n\t    ++start_col;\n\t}\n    }\n\n    // For VREPLACE mode, we also have to fix the replace stack.  In this case\n    // it is always possible because we backspace over the whole line and then\n    // put it back again the way we wanted it.\n    if (State & VREPLACE_FLAG)\n    {\n\t// If orig_line didn't allocate, just return.  At least we did the job,\n\t// even if you can't backspace.\n\tif (orig_line == NULL)\n\t    return;\n\n\t// Save new line\n\tnew_line = vim_strsave(ml_get_curline());\n\tif (new_line == NULL)\n\t    return;\n\n\t// We only put back the new line up to the cursor\n\tnew_line[curwin->w_cursor.col] = NUL;\n\n\t// Put back original line\n\tml_replace(curwin->w_cursor.lnum, orig_line, FALSE);\n\tcurwin->w_cursor.col = orig_col;\n\n\t// Backspace from cursor to start of line\n\tbackspace_until_column(0);\n\n\t// Insert new stuff into line again\n\tins_bytes(new_line);\n\n\tvim_free(new_line);\n    }\n}\n\n/*\n * Copy the indent from ptr to the current line (and fill to size)\n * Leaves the cursor on the first non-blank in the line.\n * Returns TRUE if the line was changed.\n */\n    int\ncopy_indent(int size, char_u *src)\n{\n    char_u\t*p = NULL;\n    char_u\t*line = NULL;\n    char_u\t*s;\n    int\t\ttodo;\n    int\t\tind_len;\n    int\t\tline_len = 0;\n    int\t\ttab_pad;\n    int\t\tind_done;\n    int\t\tround;\n#ifdef FEAT_VARTABS\n    int\t\tind_col;\n#endif\n\n    // Round 1: compute the number of characters needed for the indent\n    // Round 2: copy the characters.\n    for (round = 1; round <= 2; ++round)\n    {\n\ttodo = size;\n\tind_len = 0;\n\tind_done = 0;\n#ifdef FEAT_VARTABS\n\tind_col = 0;\n#endif\n\ts = src;\n\n\t// Count/copy the usable portion of the source line\n\twhile (todo > 0 && VIM_ISWHITE(*s))\n\t{\n\t    if (*s == TAB)\n\t    {\n#ifdef FEAT_VARTABS\n\t\ttab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,\n\t\t\t\t\t\t\tcurbuf->b_p_vts_array);\n#else\n\t\ttab_pad = (int)curbuf->b_p_ts\n\t\t\t\t\t   - (ind_done % (int)curbuf->b_p_ts);\n#endif\n\t\t// Stop if this tab will overshoot the target\n\t\tif (todo < tab_pad)\n\t\t    break;\n\t\ttodo -= tab_pad;\n\t\tind_done += tab_pad;\n#ifdef FEAT_VARTABS\n\t\tind_col += tab_pad;\n#endif\n\t    }\n\t    else\n\t    {\n\t\t--todo;\n\t\t++ind_done;\n#ifdef FEAT_VARTABS\n\t\t++ind_col;\n#endif\n\t    }\n\t    ++ind_len;\n\t    if (p != NULL)\n\t\t*p++ = *s;\n\t    ++s;\n\t}\n\n\t// Fill to next tabstop with a tab, if possible\n#ifdef FEAT_VARTABS\n\ttab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,\n\t\t\t\t\t\t\tcurbuf->b_p_vts_array);\n#else\n\ttab_pad = (int)curbuf->b_p_ts - (ind_done % (int)curbuf->b_p_ts);\n#endif\n\tif (todo >= tab_pad && !curbuf->b_p_et)\n\t{\n\t    todo -= tab_pad;\n\t    ++ind_len;\n#ifdef FEAT_VARTABS\n\t    ind_col += tab_pad;\n#endif\n\t    if (p != NULL)\n\t\t*p++ = TAB;\n\t}\n\n\t// Add tabs required for indent\n\tif (!curbuf->b_p_et)\n\t{\n#ifdef FEAT_VARTABS\n\t    for (;;)\n\t    {\n\t\ttab_pad = tabstop_padding(ind_col, curbuf->b_p_ts,\n\t\t\t\t\t\t\tcurbuf->b_p_vts_array);\n\t\tif (todo < tab_pad)\n\t\t    break;\n\t\ttodo -= tab_pad;\n\t\t++ind_len;\n\t\tind_col += tab_pad;\n\t\tif (p != NULL)\n\t\t    *p++ = TAB;\n\t    }\n#else\n\t    while (todo >= (int)curbuf->b_p_ts)\n\t    {\n\t\ttodo -= (int)curbuf->b_p_ts;\n\t\t++ind_len;\n\t\tif (p != NULL)\n\t\t    *p++ = TAB;\n\t    }\n#endif\n\t}\n\n\t// Count/add spaces required for indent\n\twhile (todo > 0)\n\t{\n\t    --todo;\n\t    ++ind_len;\n\t    if (p != NULL)\n\t\t*p++ = ' ';\n\t}\n\n\tif (p == NULL)\n\t{\n\t    // Allocate memory for the result: the copied indent, new indent\n\t    // and the rest of the line.\n\t    line_len = (int)STRLEN(ml_get_curline()) + 1;\n\t    line = alloc(ind_len + line_len);\n\t    if (line == NULL)\n\t\treturn FALSE;\n\t    p = line;\n\t}\n    }\n\n    // Append the original line\n    mch_memmove(p, ml_get_curline(), (size_t)line_len);\n\n    // Replace the line\n    ml_replace(curwin->w_cursor.lnum, line, FALSE);\n\n    // Put the cursor after the indent.\n    curwin->w_cursor.col = ind_len;\n    return TRUE;\n}\n\n/*\n * \":retab\".\n */\n    void\nex_retab(exarg_T *eap)\n{\n    linenr_T\tlnum;\n    int\t\tgot_tab = FALSE;\n    long\tnum_spaces = 0;\n    long\tnum_tabs;\n    long\tlen;\n    long\tcol;\n    long\tvcol;\n    long\tstart_col = 0;\t\t// For start of white-space string\n    long\tstart_vcol = 0;\t\t// For start of white-space string\n    long\told_len;\n    char_u\t*ptr;\n    char_u\t*new_line = (char_u *)1; // init to non-NULL\n    int\t\tdid_undo;\t\t// called u_save for current line\n#ifdef FEAT_VARTABS\n    int\t\t*new_vts_array = NULL;\n    char_u\t*new_ts_str;\t\t// string value of tab argument\n#else\n    int\t\ttemp;\n    int\t\tnew_ts;\n#endif\n    int\t\tsave_list;\n    linenr_T\tfirst_line = 0;\t\t// first changed line\n    linenr_T\tlast_line = 0;\t\t// last changed line\n\n    save_list = curwin->w_p_list;\n    curwin->w_p_list = 0;\t    // don't want list mode here\n\n#ifdef FEAT_VARTABS\n    new_ts_str = eap->arg;\n    if (tabstop_set(eap->arg, &new_vts_array) == FAIL)\n\treturn;\n    while (vim_isdigit(*(eap->arg)) || *(eap->arg) == ',')\n\t++(eap->arg);\n\n    // This ensures that either new_vts_array and new_ts_str are freshly\n    // allocated, or new_vts_array points to an existing array and new_ts_str\n    // is null.\n    if (new_vts_array == NULL)\n    {\n\tnew_vts_array = curbuf->b_p_vts_array;\n\tnew_ts_str = NULL;\n    }\n    else\n\tnew_ts_str = vim_strnsave(new_ts_str, eap->arg - new_ts_str);\n#else\n    ptr = eap->arg;\n    new_ts = getdigits(&ptr);\n    if (new_ts < 0 && *eap->arg == '-')\n    {\n\temsg(_(e_argument_must_be_positive));\n\treturn;\n    }\n    if (new_ts < 0 || new_ts > TABSTOP_MAX)\n    {\n\tsemsg(_(e_invalid_argument_str), eap->arg);\n\treturn;\n    }\n    if (new_ts == 0)\n\tnew_ts = curbuf->b_p_ts;\n#endif\n    for (lnum = eap->line1; !got_int && lnum <= eap->line2; ++lnum)\n    {\n\tptr = ml_get(lnum);\n\tcol = 0;\n\tvcol = 0;\n\tdid_undo = FALSE;\n\tfor (;;)\n\t{\n\t    if (VIM_ISWHITE(ptr[col]))\n\t    {\n\t\tif (!got_tab && num_spaces == 0)\n\t\t{\n\t\t    // First consecutive white-space\n\t\t    start_vcol = vcol;\n\t\t    start_col = col;\n\t\t}\n\t\tif (ptr[col] == ' ')\n\t\t    num_spaces++;\n\t\telse\n\t\t    got_tab = TRUE;\n\t    }\n\t    else\n\t    {\n\t\tif (got_tab || (eap->forceit && num_spaces > 1))\n\t\t{\n\t\t    // Retabulate this string of white-space\n\n\t\t    // len is virtual length of white string\n\t\t    len = num_spaces = vcol - start_vcol;\n\t\t    num_tabs = 0;\n\t\t    if (!curbuf->b_p_et)\n\t\t    {\n#ifdef FEAT_VARTABS\n\t\t\tint t, s;\n\n\t\t\ttabstop_fromto(start_vcol, vcol,\n\t\t\t\t\tcurbuf->b_p_ts, new_vts_array, &t, &s);\n\t\t\tnum_tabs = t;\n\t\t\tnum_spaces = s;\n#else\n\t\t\ttemp = new_ts - (start_vcol % new_ts);\n\t\t\tif (num_spaces >= temp)\n\t\t\t{\n\t\t\t    num_spaces -= temp;\n\t\t\t    num_tabs++;\n\t\t\t}\n\t\t\tnum_tabs += num_spaces / new_ts;\n\t\t\tnum_spaces -= (num_spaces / new_ts) * new_ts;\n#endif\n\t\t    }\n\t\t    if (curbuf->b_p_et || got_tab ||\n\t\t\t\t\t(num_spaces + num_tabs < len))\n\t\t    {\n\t\t\tif (did_undo == FALSE)\n\t\t\t{\n\t\t\t    did_undo = TRUE;\n\t\t\t    if (u_save((linenr_T)(lnum - 1),\n\t\t\t\t\t\t(linenr_T)(lnum + 1)) == FAIL)\n\t\t\t    {\n\t\t\t\tnew_line = NULL;\t// flag out-of-memory\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\n\t\t\t// len is actual number of white characters used\n\t\t\tlen = num_spaces + num_tabs;\n\t\t\told_len = (long)STRLEN(ptr);\n\t\t\tnew_line = alloc(old_len - col + start_col + len + 1);\n\t\t\tif (new_line == NULL)\n\t\t\t    break;\n\t\t\tif (start_col > 0)\n\t\t\t    mch_memmove(new_line, ptr, (size_t)start_col);\n\t\t\tmch_memmove(new_line + start_col + len,\n\t\t\t\t      ptr + col, (size_t)(old_len - col + 1));\n\t\t\tptr = new_line + start_col;\n\t\t\tfor (col = 0; col < len; col++)\n\t\t\t    ptr[col] = (col < num_tabs) ? '\\t' : ' ';\n\t\t\tif (ml_replace(lnum, new_line, FALSE) == OK)\n\t\t\t    // \"new_line\" may have been copied\n\t\t\t    new_line = curbuf->b_ml.ml_line_ptr;\n\t\t\tif (first_line == 0)\n\t\t\t    first_line = lnum;\n\t\t\tlast_line = lnum;\n\t\t\tptr = new_line;\n\t\t\tcol = start_col + len;\n\t\t    }\n\t\t}\n\t\tgot_tab = FALSE;\n\t\tnum_spaces = 0;\n\t    }\n\t    if (ptr[col] == NUL)\n\t\tbreak;\n\t    vcol += chartabsize(ptr + col, (colnr_T)vcol);\n\t    if (has_mbyte)\n\t\tcol += (*mb_ptr2len)(ptr + col);\n\t    else\n\t\t++col;\n\t}\n\tif (new_line == NULL)\t\t    // out of memory\n\t    break;\n\tline_breakcheck();\n    }\n    if (got_int)\n\temsg(_(e_interrupted));\n\n#ifdef FEAT_VARTABS\n    // If a single value was given then it can be considered equal to\n    // either the value of 'tabstop' or the value of 'vartabstop'.\n    if (tabstop_count(curbuf->b_p_vts_array) == 0\n\t&& tabstop_count(new_vts_array) == 1\n\t&& curbuf->b_p_ts == tabstop_first(new_vts_array))\n\t; // not changed\n    else if (tabstop_count(curbuf->b_p_vts_array) > 0\n        && tabstop_eq(curbuf->b_p_vts_array, new_vts_array))\n\t; // not changed\n    else\n\tredraw_curbuf_later(NOT_VALID);\n#else\n    if (curbuf->b_p_ts != new_ts)\n\tredraw_curbuf_later(NOT_VALID);\n#endif\n    if (first_line != 0)\n\tchanged_lines(first_line, 0, last_line + 1, 0L);\n\n    curwin->w_p_list = save_list;\t// restore 'list'\n\n#ifdef FEAT_VARTABS\n    if (new_ts_str != NULL)\t\t// set the new tabstop\n    {\n\t// If 'vartabstop' is in use or if the value given to retab has more\n\t// than one tabstop then update 'vartabstop'.\n\tint *old_vts_ary = curbuf->b_p_vts_array;\n\n\tif (tabstop_count(old_vts_ary) > 0 || tabstop_count(new_vts_array) > 1)\n\t{\n\t    set_string_option_direct((char_u *)\"vts\", -1, new_ts_str,\n\t\t\t\t\t\t\tOPT_FREE|OPT_LOCAL, 0);\n\t    curbuf->b_p_vts_array = new_vts_array;\n\t    vim_free(old_vts_ary);\n\t}\n\telse\n\t{\n\t    // 'vartabstop' wasn't in use and a single value was given to\n\t    // retab then update 'tabstop'.\n\t    curbuf->b_p_ts = tabstop_first(new_vts_array);\n\t    vim_free(new_vts_array);\n\t}\n\tvim_free(new_ts_str);\n    }\n#else\n    curbuf->b_p_ts = new_ts;\n#endif\n    coladvance(curwin->w_curswant);\n\n    u_clearline();\n}\n\n#if (defined(FEAT_CINDENT) && defined(FEAT_EVAL)) || defined(PROTO)\n/*\n * Get indent level from 'indentexpr'.\n */\n    int\nget_expr_indent(void)\n{\n    int\t\tindent = -1;\n    char_u\t*inde_copy;\n    pos_T\tsave_pos;\n    colnr_T\tsave_curswant;\n    int\t\tsave_set_curswant;\n    int\t\tsave_State;\n    int\t\tuse_sandbox = was_set_insecurely((char_u *)\"indentexpr\",\n\t\t\t\t\t\t\t\t   OPT_LOCAL);\n    sctx_T\tsave_sctx = current_sctx;\n\n    // Save and restore cursor position and curswant, in case it was changed\n    // via :normal commands\n    save_pos = curwin->w_cursor;\n    save_curswant = curwin->w_curswant;\n    save_set_curswant = curwin->w_set_curswant;\n    set_vim_var_nr(VV_LNUM, curwin->w_cursor.lnum);\n    if (use_sandbox)\n\t++sandbox;\n    ++textwinlock;\n    current_sctx = curbuf->b_p_script_ctx[BV_INDE];\n\n    // Need to make a copy, the 'indentexpr' option could be changed while\n    // evaluating it.\n    inde_copy = vim_strsave(curbuf->b_p_inde);\n    if (inde_copy != NULL)\n    {\n\tindent = (int)eval_to_number(inde_copy);\n\tvim_free(inde_copy);\n    }\n\n    if (use_sandbox)\n\t--sandbox;\n    --textwinlock;\n    current_sctx = save_sctx;\n\n    // Restore the cursor position so that 'indentexpr' doesn't need to.\n    // Pretend to be in Insert mode, allow cursor past end of line for \"o\"\n    // command.\n    save_State = State;\n    State = INSERT;\n    curwin->w_cursor = save_pos;\n    curwin->w_curswant = save_curswant;\n    curwin->w_set_curswant = save_set_curswant;\n    check_cursor();\n    State = save_State;\n\n    // Reset did_throw, unless 'debug' has \"throw\" and inside a try/catch.\n    if (did_throw && (vim_strchr(p_debug, 't') == NULL || trylevel == 0))\n    {\n\thandle_did_throw();\n\tdid_throw = FALSE;\n    }\n\n    // If there is an error, just keep the current indent.\n    if (indent < 0)\n\tindent = get_indent();\n\n    return indent;\n}\n#endif\n\n#if defined(FEAT_LISP) || defined(PROTO)\n\n    static int\nlisp_match(char_u *p)\n{\n    char_u\tbuf[LSIZE];\n    int\t\tlen;\n    char_u\t*word = *curbuf->b_p_lw != NUL ? curbuf->b_p_lw : p_lispwords;\n\n    while (*word != NUL)\n    {\n\t(void)copy_option_part(&word, buf, LSIZE, \",\");\n\tlen = (int)STRLEN(buf);\n\tif (STRNCMP(buf, p, len) == 0 && p[len] == ' ')\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * When 'p' is present in 'cpoptions, a Vi compatible method is used.\n * The incompatible newer method is quite a bit better at indenting\n * code in lisp-like languages than the traditional one; it's still\n * mostly heuristics however -- Dirk van Deun, dirk@rave.org\n *\n * TODO:\n * Findmatch() should be adapted for lisp, also to make showmatch\n * work correctly: now (v5.3) it seems all C/C++ oriented:\n * - it does not recognize the #\\( and #\\) notations as character literals\n * - it doesn't know about comments starting with a semicolon\n * - it incorrectly interprets '(' as a character literal\n * All this messes up get_lisp_indent in some rare cases.\n * Update from Sergey Khorev:\n * I tried to fix the first two issues.\n */\n    int\nget_lisp_indent(void)\n{\n    pos_T\t*pos, realpos, paren;\n    int\t\tamount;\n    char_u\t*that;\n    colnr_T\tcol;\n    colnr_T\tfirsttry;\n    int\t\tparencount, quotecount;\n    int\t\tvi_lisp;\n\n    // Set vi_lisp to use the vi-compatible method\n    vi_lisp = (vim_strchr(p_cpo, CPO_LISP) != NULL);\n\n    realpos = curwin->w_cursor;\n    curwin->w_cursor.col = 0;\n\n    if ((pos = findmatch(NULL, '(')) == NULL)\n\tpos = findmatch(NULL, '[');\n    else\n    {\n\tparen = *pos;\n\tpos = findmatch(NULL, '[');\n\tif (pos == NULL || LT_POSP(pos, &paren))\n\t    pos = &paren;\n    }\n    if (pos != NULL)\n    {\n\t// Extra trick: Take the indent of the first previous non-white\n\t// line that is at the same () level.\n\tamount = -1;\n\tparencount = 0;\n\n\twhile (--curwin->w_cursor.lnum >= pos->lnum)\n\t{\n\t    if (linewhite(curwin->w_cursor.lnum))\n\t\tcontinue;\n\t    for (that = ml_get_curline(); *that != NUL; ++that)\n\t    {\n\t\tif (*that == ';')\n\t\t{\n\t\t    while (*(that + 1) != NUL)\n\t\t\t++that;\n\t\t    continue;\n\t\t}\n\t\tif (*that == '\\\\')\n\t\t{\n\t\t    if (*(that + 1) != NUL)\n\t\t\t++that;\n\t\t    continue;\n\t\t}\n\t\tif (*that == '\"' && *(that + 1) != NUL)\n\t\t{\n\t\t    while (*++that && *that != '\"')\n\t\t    {\n\t\t\t// skipping escaped characters in the string\n\t\t\tif (*that == '\\\\')\n\t\t\t{\n\t\t\t    if (*++that == NUL)\n\t\t\t\tbreak;\n\t\t\t    if (that[1] == NUL)\n\t\t\t    {\n\t\t\t\t++that;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (*that == '(' || *that == '[')\n\t\t    ++parencount;\n\t\telse if (*that == ')' || *that == ']')\n\t\t    --parencount;\n\t    }\n\t    if (parencount == 0)\n\t    {\n\t\tamount = get_indent();\n\t\tbreak;\n\t    }\n\t}\n\n\tif (amount == -1)\n\t{\n\t    curwin->w_cursor.lnum = pos->lnum;\n\t    curwin->w_cursor.col = pos->col;\n\t    col = pos->col;\n\n\t    that = ml_get_curline();\n\n\t    if (vi_lisp && get_indent() == 0)\n\t\tamount = 2;\n\t    else\n\t    {\n\t\tchar_u *line = that;\n\n\t\tamount = 0;\n\t\twhile (*that && col)\n\t\t{\n\t\t    amount += lbr_chartabsize_adv(line, &that, (colnr_T)amount);\n\t\t    col--;\n\t\t}\n\n\t\t// Some keywords require \"body\" indenting rules (the\n\t\t// non-standard-lisp ones are Scheme special forms):\n\t\t//\n\t\t// (let ((a 1))    instead    (let ((a 1))\n\t\t//   (...))\t      of\t   (...))\n\n\t\tif (!vi_lisp && (*that == '(' || *that == '[')\n\t\t\t\t\t\t      && lisp_match(that + 1))\n\t\t    amount += 2;\n\t\telse\n\t\t{\n\t\t    that++;\n\t\t    amount++;\n\t\t    firsttry = amount;\n\n\t\t    while (VIM_ISWHITE(*that))\n\t\t    {\n\t\t\tamount += lbr_chartabsize(line, that, (colnr_T)amount);\n\t\t\t++that;\n\t\t    }\n\n\t\t    if (*that && *that != ';') // not a comment line\n\t\t    {\n\t\t\t// test *that != '(' to accommodate first let/do\n\t\t\t// argument if it is more than one line\n\t\t\tif (!vi_lisp && *that != '(' && *that != '[')\n\t\t\t    firsttry++;\n\n\t\t\tparencount = 0;\n\t\t\tquotecount = 0;\n\n\t\t\tif (vi_lisp\n\t\t\t\t|| (*that != '\"'\n\t\t\t\t    && *that != '\\''\n\t\t\t\t    && *that != '#'\n\t\t\t\t    && (*that < '0' || *that > '9')))\n\t\t\t{\n\t\t\t    while (*that\n\t\t\t\t    && (!VIM_ISWHITE(*that)\n\t\t\t\t\t|| quotecount\n\t\t\t\t\t|| parencount)\n\t\t\t\t    && (!((*that == '(' || *that == '[')\n\t\t\t\t\t    && !quotecount\n\t\t\t\t\t    && !parencount\n\t\t\t\t\t    && vi_lisp)))\n\t\t\t    {\n\t\t\t\tif (*that == '\"')\n\t\t\t\t    quotecount = !quotecount;\n\t\t\t\tif ((*that == '(' || *that == '[')\n\t\t\t\t\t\t\t       && !quotecount)\n\t\t\t\t    ++parencount;\n\t\t\t\tif ((*that == ')' || *that == ']')\n\t\t\t\t\t\t\t       && !quotecount)\n\t\t\t\t    --parencount;\n\t\t\t\tif (*that == '\\\\' && *(that+1) != NUL)\n\t\t\t\t    amount += lbr_chartabsize_adv(\n\t\t\t\t\t\tline, &that, (colnr_T)amount);\n\t\t\t\tamount += lbr_chartabsize_adv(\n\t\t\t\t\t\tline, &that, (colnr_T)amount);\n\t\t\t    }\n\t\t\t}\n\t\t\twhile (VIM_ISWHITE(*that))\n\t\t\t{\n\t\t\t    amount += lbr_chartabsize(\n\t\t\t\t\t\t line, that, (colnr_T)amount);\n\t\t\t    that++;\n\t\t\t}\n\t\t\tif (!*that || *that == ';')\n\t\t\t    amount = firsttry;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    else\n\tamount = 0;\t// no matching '(' or '[' found, use zero indent\n\n    curwin->w_cursor = realpos;\n\n    return amount;\n}\n#endif // FEAT_LISP\n\n#if defined(FEAT_LISP) || defined(FEAT_CINDENT) || defined(PROTO)\n/*\n * Re-indent the current line, based on the current contents of it and the\n * surrounding lines. Fixing the cursor position seems really easy -- I'm very\n * confused what all the part that handles Control-T is doing that I'm not.\n * \"get_the_indent\" should be get_c_indent, get_expr_indent or get_lisp_indent.\n */\n\n    void\nfixthisline(int (*get_the_indent)(void))\n{\n    int amount = get_the_indent();\n\n    if (amount >= 0)\n    {\n\tchange_indent(INDENT_SET, amount, FALSE, 0, TRUE);\n\tif (linewhite(curwin->w_cursor.lnum))\n\t    did_ai = TRUE;\t// delete the indent if the line stays empty\n    }\n}\n\n/*\n * Fix indent for 'lisp' and 'cindent'.\n */\n    void\nfix_indent(void)\n{\n    if (p_paste)\n\treturn;\n# ifdef FEAT_LISP\n    if (curbuf->b_p_lisp && curbuf->b_p_ai)\n\tfixthisline(get_lisp_indent);\n# endif\n# if defined(FEAT_LISP) && defined(FEAT_CINDENT)\n    else\n# endif\n# ifdef FEAT_CINDENT\n\tif (cindent_on())\n\t    do_c_expr_indent();\n# endif\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * \"indent()\" function\n */\n    void\nf_indent(typval_T *argvars, typval_T *rettv)\n{\n    linenr_T\tlnum;\n\n    if (in_vim9script() && check_for_lnum_arg(argvars, 0) == FAIL)\n\treturn;\n\n    lnum = tv_get_lnum(argvars);\n    if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count)\n\trettv->vval.v_number = get_indent_lnum(lnum);\n    else\n    {\n\tif (in_vim9script())\n\t    semsg(_(e_invalid_line_number_nr), lnum);\n\trettv->vval.v_number = -1;\n    }\n}\n\n/*\n * \"lispindent(lnum)\" function\n */\n    void\nf_lispindent(typval_T *argvars UNUSED, typval_T *rettv)\n{\n#ifdef FEAT_LISP\n    pos_T\tpos;\n    linenr_T\tlnum;\n\n    if (in_vim9script() && check_for_lnum_arg(argvars, 0) == FAIL)\n\treturn;\n\n    pos = curwin->w_cursor;\n    lnum = tv_get_lnum(argvars);\n    if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count)\n    {\n\tcurwin->w_cursor.lnum = lnum;\n\trettv->vval.v_number = get_lisp_indent();\n\tcurwin->w_cursor = pos;\n    }\n    else if (in_vim9script())\n\tsemsg(_(e_invalid_line_number_nr), lnum);\n    else\n#endif\n\trettv->vval.v_number = -1;\n}\n#endif\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * Code to handle user-settable options. This is all pretty much table-\n * driven. Checklist for adding a new option:\n * - Put it in the options array below (copy an existing entry).\n * - For a global option: Add a variable for it in option.h.\n * - For a buffer or window local option:\n *   - Add a PV_XX entry to the enum below.\n *   - Add a variable to the window or buffer struct in structs.h.\n *   - For a window option, add some code to copy_winopt().\n *   - For a buffer option, add some code to buf_copy_options().\n *   - For a buffer string option, add code to check_buf_options().\n * - If it's a numeric option, add any necessary bounds checks to do_set().\n * - If it's a list of flags, add some code in do_set(), search for WW_ALL.\n * - When adding an option with expansion (P_EXPAND), but with a different\n *   default for Vi and Vim (no P_VI_DEF), add some code at VIMEXP.\n * - Add documentation!  One line in doc/quickref.txt, full description in\n *   options.txt, and any other related places.\n * - Add an entry in runtime/optwin.vim.\n * When making changes:\n * - Adjust the help for the option in doc/option.txt.\n * - When an entry has the P_VIM flag, or is lacking the P_VI_DEF flag, add a\n *   comment at the help for the 'compatible' option.\n */\n\n#define IN_OPTION_C\n#include \"vim.h\"\n#include \"optiondefs.h\"\n\nstatic void set_options_default(int opt_flags);\nstatic void set_string_default_esc(char *name, char_u *val, int escape);\nstatic char_u *find_dup_item(char_u *origval, char_u *newval, long_u flags);\nstatic char_u *option_expand(int opt_idx, char_u *val);\nstatic void didset_options(void);\nstatic void didset_options2(void);\n#if defined(FEAT_EVAL) || defined(PROTO)\nstatic long_u *insecure_flag(int opt_idx, int opt_flags);\n#else\n# define insecure_flag(opt_idx, opt_flags) (&options[opt_idx].flags)\n#endif\nstatic char *set_bool_option(int opt_idx, char_u *varp, int value, int opt_flags);\nstatic char *set_num_option(int opt_idx, char_u *varp, long value, char *errbuf, size_t errbuflen, int opt_flags);\nstatic int find_key_option(char_u *arg_arg, int has_lt);\nstatic void showoptions(int all, int opt_flags);\nstatic int optval_default(struct vimoption *, char_u *varp, int compatible);\nstatic void showoneopt(struct vimoption *, int opt_flags);\nstatic int put_setstring(FILE *fd, char *cmd, char *name, char_u **valuep, long_u flags);\nstatic int put_setnum(FILE *fd, char *cmd, char *name, long *valuep);\nstatic int put_setbool(FILE *fd, char *cmd, char *name, int value);\nstatic int istermoption(struct vimoption *p);\nstatic char_u *get_varp_scope(struct vimoption *p, int scope);\nstatic char_u *get_varp(struct vimoption *);\nstatic void check_win_options(win_T *win);\nstatic void option_value2string(struct vimoption *, int scope);\nstatic void check_winopt(winopt_T *wop);\nstatic int wc_use_keyname(char_u *varp, long *wcp);\nstatic void paste_option_changed(void);\nstatic void compatible_set(void);\n\n/*\n * Initialize the options, first part.\n *\n * Called only once from main(), just after creating the first buffer.\n * If \"clean_arg\" is TRUE Vim was started with --clean.\n */\n    void\nset_init_1(int clean_arg)\n{\n    char_u\t*p;\n    int\t\topt_idx;\n    long_u\tn;\n\n#ifdef FEAT_LANGMAP\n    langmap_init();\n#endif\n\n    // Be Vi compatible by default\n    p_cp = TRUE;\n\n    // Use POSIX compatibility when $VIM_POSIX is set.\n    if (mch_getenv((char_u *)\"VIM_POSIX\") != NULL)\n    {\n\tset_string_default(\"cpo\", (char_u *)CPO_ALL);\n\tset_string_default(\"shm\", (char_u *)SHM_POSIX);\n    }\n\n    /*\n     * Find default value for 'shell' option.\n     * Don't use it if it is empty.\n     */\n    if (((p = mch_getenv((char_u *)\"SHELL\")) != NULL && *p != NUL)\n#if defined(MSWIN)\n\t    || ((p = mch_getenv((char_u *)\"COMSPEC\")) != NULL && *p != NUL)\n\t    || ((p = (char_u *)default_shell()) != NULL && *p != NUL)\n#endif\n\t    )\n#if defined(MSWIN)\n    {\n\t// For MS-Windows put the path in quotes instead of escaping spaces.\n\tchar_u\t    *cmd;\n\tsize_t\t    len;\n\n\tif (vim_strchr(p, ' ') != NULL)\n\t{\n\t    len = STRLEN(p) + 3;  // two quotes and a trailing NUL\n\t    cmd = alloc(len);\n\t    if (cmd != NULL)\n\t    {\n\t\tvim_snprintf((char *)cmd, len, \"\\\"%s\\\"\", p);\n\t\tset_string_default(\"sh\", cmd);\n\t\tvim_free(cmd);\n\t    }\n\t}\n\telse\n\t    set_string_default(\"sh\", p);\n    }\n#else\n\tset_string_default_esc(\"sh\", p, TRUE);\n#endif\n\n#ifdef FEAT_WILDIGN\n    /*\n     * Set the default for 'backupskip' to include environment variables for\n     * temp files.\n     */\n    {\n# ifdef UNIX\n\tstatic char\t*(names[4]) = {\"\", \"TMPDIR\", \"TEMP\", \"TMP\"};\n# else\n\tstatic char\t*(names[3]) = {\"TMPDIR\", \"TEMP\", \"TMP\"};\n# endif\n\tint\t\tlen;\n\tgarray_T\tga;\n\tint\t\tmustfree;\n\tchar_u\t\t*item;\n\n\topt_idx = findoption((char_u *)\"backupskip\");\n\n\tga_init2(&ga, 1, 100);\n\tfor (n = 0; n < (long)ARRAY_LENGTH(names); ++n)\n\t{\n\t    mustfree = FALSE;\n# ifdef UNIX\n\t    if (*names[n] == NUL)\n#  ifdef MACOS_X\n\t\tp = (char_u *)\"/private/tmp\";\n#  else\n\t\tp = (char_u *)\"/tmp\";\n#  endif\n\t    else\n# endif\n\t\tp = vim_getenv((char_u *)names[n], &mustfree);\n\t    if (p != NULL && *p != NUL)\n\t    {\n\t\t// First time count the NUL, otherwise count the ','.\n\t\tlen = (int)STRLEN(p) + 3;\n\t\titem = alloc(len);\n\t\tSTRCPY(item, p);\n\t\tadd_pathsep(item);\n\t\tSTRCAT(item, \"*\");\n\t\tif (find_dup_item(ga.ga_data, item, options[opt_idx].flags)\n\t\t\t\t\t\t\t\t\t== NULL\n\t\t\t&& ga_grow(&ga, len) == OK)\n\t\t{\n\t\t    if (ga.ga_len > 0)\n\t\t\tSTRCAT(ga.ga_data, \",\");\n\t\t    STRCAT(ga.ga_data, item);\n\t\t    ga.ga_len += len;\n\t\t}\n\t\tvim_free(item);\n\t    }\n\t    if (mustfree)\n\t\tvim_free(p);\n\t}\n\tif (ga.ga_data != NULL)\n\t{\n\t    set_string_default(\"bsk\", ga.ga_data);\n\t    vim_free(ga.ga_data);\n\t}\n    }\n#endif\n\n    /*\n     * 'maxmemtot' and 'maxmem' may have to be adjusted for available memory\n     */\n    opt_idx = findoption((char_u *)\"maxmemtot\");\n    if (opt_idx >= 0)\n    {\n#if !defined(HAVE_AVAIL_MEM) && !defined(HAVE_TOTAL_MEM)\n\tif (options[opt_idx].def_val[VI_DEFAULT] == (char_u *)0L)\n#endif\n\t{\n#ifdef HAVE_AVAIL_MEM\n\t    // Use amount of memory available at this moment.\n\t    n = (mch_avail_mem(FALSE) >> 1);\n#else\n# ifdef HAVE_TOTAL_MEM\n\t    // Use amount of memory available to Vim.\n\t    n = (mch_total_mem(FALSE) >> 1);\n# else\n\t    n = (0x7fffffff >> 11);\n# endif\n#endif\n\t    options[opt_idx].def_val[VI_DEFAULT] = (char_u *)n;\n\t    opt_idx = findoption((char_u *)\"maxmem\");\n\t    if (opt_idx >= 0)\n\t    {\n#if !defined(HAVE_AVAIL_MEM) && !defined(HAVE_TOTAL_MEM)\n\t\tif ((long)(long_i)options[opt_idx].def_val[VI_DEFAULT] > (long)n\n\t\t  || (long)(long_i)options[opt_idx].def_val[VI_DEFAULT] == 0L)\n#endif\n\t\t    options[opt_idx].def_val[VI_DEFAULT] = (char_u *)n;\n\t    }\n\t}\n    }\n\n#ifdef FEAT_SEARCHPATH\n    {\n\tchar_u\t*cdpath;\n\tchar_u\t*buf;\n\tint\ti;\n\tint\tj;\n\tint\tmustfree = FALSE;\n\n\t// Initialize the 'cdpath' option's default value.\n\tcdpath = vim_getenv((char_u *)\"CDPATH\", &mustfree);\n\tif (cdpath != NULL)\n\t{\n\t    buf = alloc((STRLEN(cdpath) << 1) + 2);\n\t    if (buf != NULL)\n\t    {\n\t\tbuf[0] = ',';\t    // start with \",\", current dir first\n\t\tj = 1;\n\t\tfor (i = 0; cdpath[i] != NUL; ++i)\n\t\t{\n\t\t    if (vim_ispathlistsep(cdpath[i]))\n\t\t\tbuf[j++] = ',';\n\t\t    else\n\t\t    {\n\t\t\tif (cdpath[i] == ' ' || cdpath[i] == ',')\n\t\t\t    buf[j++] = '\\\\';\n\t\t\tbuf[j++] = cdpath[i];\n\t\t    }\n\t\t}\n\t\tbuf[j] = NUL;\n\t\topt_idx = findoption((char_u *)\"cdpath\");\n\t\tif (opt_idx >= 0)\n\t\t{\n\t\t    options[opt_idx].def_val[VI_DEFAULT] = buf;\n\t\t    options[opt_idx].flags |= P_DEF_ALLOCED;\n\t\t}\n\t\telse\n\t\t    vim_free(buf); // cannot happen\n\t    }\n\t    if (mustfree)\n\t\tvim_free(cdpath);\n\t}\n    }\n#endif\n\n#if defined(FEAT_POSTSCRIPT) && (defined(MSWIN) || defined(VMS) || defined(EBCDIC) || defined(MAC) || defined(hpux))\n    // Set print encoding on platforms that don't default to latin1\n    set_string_default(\"penc\",\n# if defined(MSWIN)\n\t\t       (char_u *)\"cp1252\"\n# else\n#  ifdef VMS\n\t\t       (char_u *)\"dec-mcs\"\n#  else\n#   ifdef EBCDIC\n\t\t       (char_u *)\"ebcdic-uk\"\n#   else\n#    ifdef MAC\n\t\t       (char_u *)\"mac-roman\"\n#    else // HPUX\n\t\t       (char_u *)\"hp-roman8\"\n#    endif\n#   endif\n#  endif\n# endif\n\t\t       );\n#endif\n\n#ifdef FEAT_POSTSCRIPT\n    // 'printexpr' must be allocated to be able to evaluate it.\n    set_string_default(\"pexpr\",\n# if defined(MSWIN)\n\t    (char_u *)\"system('copy' . ' ' . v:fname_in . (&printdevice == '' ? ' LPT1:' : (' \\\"' . &printdevice . '\\\"'))) . delete(v:fname_in)\"\n# else\n#  ifdef VMS\n\t    (char_u *)\"system('print/delete' . (&printdevice == '' ? '' : ' /queue=' . &printdevice) . ' ' . v:fname_in)\"\n\n#  else\n\t    (char_u *)\"system('lpr' . (&printdevice == '' ? '' : ' -P' . &printdevice) . ' ' . v:fname_in) . delete(v:fname_in) + v:shell_error\"\n#  endif\n# endif\n\t    );\n#endif\n\n    /*\n     * Set all the options (except the terminal options) to their default\n     * value.  Also set the global value for local options.\n     */\n    set_options_default(0);\n\n#ifdef CLEAN_RUNTIMEPATH\n    if (clean_arg)\n    {\n\topt_idx = findoption((char_u *)\"runtimepath\");\n\tif (opt_idx >= 0)\n\t{\n\t    options[opt_idx].def_val[VI_DEFAULT] = (char_u *)CLEAN_RUNTIMEPATH;\n\t    p_rtp = (char_u *)CLEAN_RUNTIMEPATH;\n\t}\n\topt_idx = findoption((char_u *)\"packpath\");\n\tif (opt_idx >= 0)\n\t{\n\t    options[opt_idx].def_val[VI_DEFAULT] = (char_u *)CLEAN_RUNTIMEPATH;\n\t    p_pp = (char_u *)CLEAN_RUNTIMEPATH;\n\t}\n    }\n#endif\n\n#ifdef FEAT_GUI\n    if (found_reverse_arg)\n\tset_option_value((char_u *)\"bg\", 0L, (char_u *)\"dark\", 0);\n#endif\n\n    curbuf->b_p_initialized = TRUE;\n    curbuf->b_p_ar = -1;\t// no local 'autoread' value\n    curbuf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n    check_buf_options(curbuf);\n    check_win_options(curwin);\n    check_options();\n\n    // Must be before option_expand(), because that one needs vim_isIDc()\n    didset_options();\n\n#ifdef FEAT_SPELL\n    // Use the current chartab for the generic chartab. This is not in\n    // didset_options() because it only depends on 'encoding'.\n    init_spell_chartab();\n#endif\n\n    /*\n     * Expand environment variables and things like \"~\" for the defaults.\n     * If option_expand() returns non-NULL the variable is expanded.  This can\n     * only happen for non-indirect options.\n     * Also set the default to the expanded value, so \":set\" does not list\n     * them.\n     * Don't set the P_ALLOCED flag, because we don't want to free the\n     * default.\n     */\n    for (opt_idx = 0; !istermoption_idx(opt_idx); opt_idx++)\n    {\n\tif ((options[opt_idx].flags & P_GETTEXT)\n\t\t\t\t\t      && options[opt_idx].var != NULL)\n\t    p = (char_u *)_(*(char **)options[opt_idx].var);\n\telse\n\t    p = option_expand(opt_idx, NULL);\n\tif (p != NULL && (p = vim_strsave(p)) != NULL)\n\t{\n\t    *(char_u **)options[opt_idx].var = p;\n\t    // VIMEXP\n\t    // Defaults for all expanded options are currently the same for Vi\n\t    // and Vim.  When this changes, add some code here!  Also need to\n\t    // split P_DEF_ALLOCED in two.\n\t    if (options[opt_idx].flags & P_DEF_ALLOCED)\n\t\tvim_free(options[opt_idx].def_val[VI_DEFAULT]);\n\t    options[opt_idx].def_val[VI_DEFAULT] = p;\n\t    options[opt_idx].flags |= P_DEF_ALLOCED;\n\t}\n    }\n\n    save_file_ff(curbuf);\t// Buffer is unchanged\n\n#if defined(FEAT_ARABIC)\n    // Detect use of mlterm.\n    // Mlterm is a terminal emulator akin to xterm that has some special\n    // abilities (bidi namely).\n    // NOTE: mlterm's author is being asked to 'set' a variable\n    //       instead of an environment variable due to inheritance.\n    if (mch_getenv((char_u *)\"MLTERM\") != NULL)\n\tset_option_value((char_u *)\"tbidi\", 1L, NULL, 0);\n#endif\n\n    didset_options2();\n\n# if defined(MSWIN) && defined(FEAT_GETTEXT)\n    /*\n     * If $LANG isn't set, try to get a good value for it.  This makes the\n     * right language be used automatically.  Don't do this for English.\n     */\n    if (mch_getenv((char_u *)\"LANG\") == NULL)\n    {\n\tchar\tbuf[20];\n\n\t// Could use LOCALE_SISO639LANGNAME, but it's not in Win95.\n\t// LOCALE_SABBREVLANGNAME gives us three letters, like \"enu\", we use\n\t// only the first two.\n\tn = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SABBREVLANGNAME,\n\t\t\t\t\t\t\t     (LPTSTR)buf, 20);\n\tif (n >= 2 && STRNICMP(buf, \"en\", 2) != 0)\n\t{\n\t    // There are a few exceptions (probably more)\n\t    if (STRNICMP(buf, \"cht\", 3) == 0 || STRNICMP(buf, \"zht\", 3) == 0)\n\t\tSTRCPY(buf, \"zh_TW\");\n\t    else if (STRNICMP(buf, \"chs\", 3) == 0\n\t\t\t\t\t      || STRNICMP(buf, \"zhc\", 3) == 0)\n\t\tSTRCPY(buf, \"zh_CN\");\n\t    else if (STRNICMP(buf, \"jp\", 2) == 0)\n\t\tSTRCPY(buf, \"ja\");\n\t    else\n\t\tbuf[2] = NUL;\t\t// truncate to two-letter code\n\t    vim_setenv((char_u *)\"LANG\", (char_u *)buf);\n\t}\n    }\n# else\n#  ifdef MACOS_CONVERT\n    // Moved to os_mac_conv.c to avoid dependency problems.\n    mac_lang_init();\n#  endif\n# endif\n\n# ifdef MSWIN\n    // MS-Windows has builtin support for conversion to and from Unicode, using\n    // \"utf-8\" for 'encoding' should work best for most users.\n    p = vim_strsave((char_u *)ENC_DFLT);\n# else\n    // enc_locale() will try to find the encoding of the current locale.\n    // This works best for properly configured systems, old and new.\n    p = enc_locale();\n# endif\n    if (p != NULL)\n    {\n\tchar_u *save_enc;\n\n\t// Try setting 'encoding' and check if the value is valid.\n\t// If not, go back to the default encoding.\n\tsave_enc = p_enc;\n\tp_enc = p;\n\tif (STRCMP(p_enc, \"gb18030\") == 0)\n\t{\n\t    // We don't support \"gb18030\", but \"cp936\" is a good substitute\n\t    // for practical purposes, thus use that.  It's not an alias to\n\t    // still support conversion between gb18030 and utf-8.\n\t    p_enc = vim_strsave((char_u *)\"cp936\");\n\t    vim_free(p);\n\t}\n\tif (mb_init() == NULL)\n\t{\n\t    opt_idx = findoption((char_u *)\"encoding\");\n\t    if (opt_idx >= 0)\n\t    {\n\t\toptions[opt_idx].def_val[VI_DEFAULT] = p_enc;\n\t\toptions[opt_idx].flags |= P_DEF_ALLOCED;\n\t    }\n\n#if defined(MSWIN) || defined(MACOS_X) || defined(VMS)\n\t    if (STRCMP(p_enc, \"latin1\") == 0 || enc_utf8)\n\t    {\n\t\t// Adjust the default for 'isprint' and 'iskeyword' to match\n\t\t// latin1.  Also set the defaults for when 'nocompatible' is\n\t\t// set.\n\t\tset_string_option_direct((char_u *)\"isp\", -1,\n\t\t\t\t\t      ISP_LATIN1, OPT_FREE, SID_NONE);\n\t\tset_string_option_direct((char_u *)\"isk\", -1,\n\t\t\t\t\t      ISK_LATIN1, OPT_FREE, SID_NONE);\n\t\topt_idx = findoption((char_u *)\"isp\");\n\t\tif (opt_idx >= 0)\n\t\t    options[opt_idx].def_val[VIM_DEFAULT] = ISP_LATIN1;\n\t\topt_idx = findoption((char_u *)\"isk\");\n\t\tif (opt_idx >= 0)\n\t\t    options[opt_idx].def_val[VIM_DEFAULT] = ISK_LATIN1;\n\t\t(void)init_chartab();\n\t    }\n#endif\n\n#if defined(MSWIN) && (!defined(FEAT_GUI) || defined(VIMDLL))\n\t    // Win32 console: When GetACP() returns a different value from\n\t    // GetConsoleCP() set 'termencoding'.\n\t    if (\n# ifdef VIMDLL\n\t       (!gui.in_use && !gui.starting) &&\n# endif\n\t        GetACP() != GetConsoleCP())\n\t    {\n\t\tchar\tbuf[50];\n\n\t\t// Win32 console: In ConPTY, GetConsoleCP() returns zero.\n\t\t// Use an alternative value.\n\t\tif (GetConsoleCP() == 0)\n\t\t    sprintf(buf, \"cp%ld\", (long)GetACP());\n\t\telse\n\t\t    sprintf(buf, \"cp%ld\", (long)GetConsoleCP());\n\t\tp_tenc = vim_strsave((char_u *)buf);\n\t\tif (p_tenc != NULL)\n\t\t{\n\t\t    opt_idx = findoption((char_u *)\"termencoding\");\n\t\t    if (opt_idx >= 0)\n\t\t    {\n\t\t\toptions[opt_idx].def_val[VI_DEFAULT] = p_tenc;\n\t\t\toptions[opt_idx].flags |= P_DEF_ALLOCED;\n\t\t    }\n\t\t    convert_setup(&input_conv, p_tenc, p_enc);\n\t\t    convert_setup(&output_conv, p_enc, p_tenc);\n\t\t}\n\t\telse\n\t\t    p_tenc = empty_option;\n\t    }\n#endif\n#if defined(MSWIN)\n\t    // $HOME may have characters in active code page.\n\t    init_homedir();\n#endif\n\t}\n\telse\n\t{\n\t    vim_free(p_enc);\n\t    p_enc = save_enc;\n\t}\n    }\n\n#ifdef FEAT_MULTI_LANG\n    // Set the default for 'helplang'.\n    set_helplang_default(get_mess_lang());\n#endif\n}\n\nstatic char_u *fencs_utf8_default = (char_u *)\"ucs-bom,utf-8,default,latin1\";\n\n/*\n * Set the \"fileencodings\" option to the default value for when 'encoding' is\n * utf-8.\n */\n    void\nset_fencs_unicode()\n{\n    set_string_option_direct((char_u *)\"fencs\", -1, fencs_utf8_default,\n\t\t\t\t\t\t\t\t  OPT_FREE, 0);\n}\n\n/*\n * Set an option to its default value.\n * This does not take care of side effects!\n */\n    static void\nset_option_default(\n    int\t\topt_idx,\n    int\t\topt_flags,\t// OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL\n    int\t\tcompatible)\t// use Vi default value\n{\n    char_u\t*varp;\t\t// pointer to variable for current option\n    int\t\tdvi;\t\t// index in def_val[]\n    long_u\tflags;\n    long_u\t*flagsp;\n    int\t\tboth = (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0;\n\n    varp = get_varp_scope(&(options[opt_idx]), both ? OPT_LOCAL : opt_flags);\n    flags = options[opt_idx].flags;\n    if (varp != NULL)\t    // skip hidden option, nothing to do for it\n    {\n\tdvi = ((flags & P_VI_DEF) || compatible) ? VI_DEFAULT : VIM_DEFAULT;\n\tif (flags & P_STRING)\n\t{\n\t    // 'fencs' default value depends on 'encoding'\n\t    if (options[opt_idx].var == (char_u *)&p_fencs && enc_utf8)\n\t\tset_fencs_unicode();\n\t    // Use set_string_option_direct() for local options to handle\n\t    // freeing and allocating the value.\n\t    else if (options[opt_idx].indir != PV_NONE)\n\t\tset_string_option_direct(NULL, opt_idx,\n\t\t\t\t options[opt_idx].def_val[dvi], opt_flags, 0);\n\t    else\n\t    {\n\t\tif ((opt_flags & OPT_FREE) && (flags & P_ALLOCED))\n\t\t    free_string_option(*(char_u **)(varp));\n\t\t*(char_u **)varp = options[opt_idx].def_val[dvi];\n\t\toptions[opt_idx].flags &= ~P_ALLOCED;\n\t    }\n\t}\n\telse if (flags & P_NUM)\n\t{\n\t    if (options[opt_idx].indir == PV_SCROLL)\n\t\twin_comp_scroll(curwin);\n\t    else\n\t    {\n\t\tlong def_val = (long)(long_i)options[opt_idx].def_val[dvi];\n\n\t\tif ((long *)varp == &curwin->w_p_so\n\t\t\t|| (long *)varp == &curwin->w_p_siso)\n\t\t    // 'scrolloff' and 'sidescrolloff' local values have a\n\t\t    // different default value than the global default.\n\t\t    *(long *)varp = -1;\n\t\telse\n\t\t    *(long *)varp = def_val;\n\t\t// May also set global value for local option.\n\t\tif (both)\n\t\t    *(long *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) =\n\t\t\t\t\t\t\t\tdef_val;\n\t    }\n\t}\n\telse\t// P_BOOL\n\t{\n\t    // the cast to long is required for Manx C, long_i is needed for\n\t    // MSVC\n\t    *(int *)varp = (int)(long)(long_i)options[opt_idx].def_val[dvi];\n#ifdef UNIX\n\t    // 'modeline' defaults to off for root\n\t    if (options[opt_idx].indir == PV_ML && getuid() == ROOT_UID)\n\t\t*(int *)varp = FALSE;\n#endif\n\t    // May also set global value for local option.\n\t    if (both)\n\t\t*(int *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) =\n\t\t\t\t\t\t\t\t*(int *)varp;\n\t}\n\n\t// The default value is not insecure.\n\tflagsp = insecure_flag(opt_idx, opt_flags);\n\t*flagsp = *flagsp & ~P_INSECURE;\n    }\n\n#ifdef FEAT_EVAL\n    set_option_sctx_idx(opt_idx, opt_flags, current_sctx);\n#endif\n}\n\n/*\n * Set all options (except terminal options) to their default value.\n * When \"opt_flags\" is non-zero skip 'encoding'.\n */\n    static void\nset_options_default(\n    int\t\topt_flags)\t// OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL\n{\n    int\t\ti;\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    for (i = 0; !istermoption_idx(i); i++)\n\tif (!(options[i].flags & P_NODEFAULT)\n\t\t&& (opt_flags == 0\n\t\t    || (options[i].var != (char_u *)&p_enc\n# if defined(FEAT_CRYPT)\n\t\t\t&& options[i].var != (char_u *)&p_cm\n\t\t\t&& options[i].var != (char_u *)&p_key\n# endif\n\t\t\t)))\n\t    set_option_default(i, opt_flags, p_cp);\n\n    // The 'scroll' option must be computed for all windows.\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\twin_comp_scroll(wp);\n#ifdef FEAT_CINDENT\n    parse_cino(curbuf);\n#endif\n}\n\n/*\n * Set the Vi-default value of a string option.\n * Used for 'sh', 'backupskip' and 'term'.\n * When \"escape\" is TRUE escape spaces with a backslash.\n */\n    static void\nset_string_default_esc(char *name, char_u *val, int escape)\n{\n    char_u\t*p;\n    int\t\topt_idx;\n\n    if (escape && vim_strchr(val, ' ') != NULL)\n\tp = vim_strsave_escaped(val, (char_u *)\" \");\n    else\n\tp = vim_strsave(val);\n    if (p != NULL)\t\t// we don't want a NULL\n    {\n\topt_idx = findoption((char_u *)name);\n\tif (opt_idx >= 0)\n\t{\n\t    if (options[opt_idx].flags & P_DEF_ALLOCED)\n\t\tvim_free(options[opt_idx].def_val[VI_DEFAULT]);\n\t    options[opt_idx].def_val[VI_DEFAULT] = p;\n\t    options[opt_idx].flags |= P_DEF_ALLOCED;\n\t}\n    }\n}\n\n    void\nset_string_default(char *name, char_u *val)\n{\n    set_string_default_esc(name, val, FALSE);\n}\n\n/*\n * For an option value that contains comma separated items, find \"newval\" in\n * \"origval\".  Return NULL if not found.\n */\n    static char_u *\nfind_dup_item(char_u *origval, char_u *newval, long_u flags)\n{\n    int\t    bs = 0;\n    size_t  newlen;\n    char_u  *s;\n\n    if (origval == NULL)\n\treturn NULL;\n\n    newlen = STRLEN(newval);\n    for (s = origval; *s != NUL; ++s)\n    {\n\tif ((!(flags & P_COMMA)\n\t\t    || s == origval\n\t\t    || (s[-1] == ',' && !(bs & 1)))\n\t\t&& STRNCMP(s, newval, newlen) == 0\n\t\t&& (!(flags & P_COMMA)\n\t\t    || s[newlen] == ','\n\t\t    || s[newlen] == NUL))\n\t    return s;\n\t// Count backslashes.  Only a comma with an even number of backslashes\n\t// or a single backslash preceded by a comma before it is recognized as\n\t// a separator.\n\tif ((s > origval + 1\n\t\t    && s[-1] == '\\\\'\n\t\t    && s[-2] != ',')\n\t\t|| (s == origval + 1\n\t\t    && s[-1] == '\\\\'))\n\t    ++bs;\n\telse\n\t    bs = 0;\n    }\n    return NULL;\n}\n\n/*\n * Set the Vi-default value of a number option.\n * Used for 'lines' and 'columns'.\n */\n    void\nset_number_default(char *name, long val)\n{\n    int\t\topt_idx;\n\n    opt_idx = findoption((char_u *)name);\n    if (opt_idx >= 0)\n\toptions[opt_idx].def_val[VI_DEFAULT] = (char_u *)(long_i)val;\n}\n\n#if defined(FEAT_PROP_POPUP) || defined(PROTO)\n/*\n * Set all window-local and buffer-local options to the Vim default.\n * local-global options will use the global value.\n * When \"do_buffer\" is FALSE don't set buffer-local options.\n */\n    void\nset_local_options_default(win_T *wp, int do_buffer)\n{\n    win_T\t*save_curwin = curwin;\n    int\t\ti;\n\n    curwin = wp;\n    curbuf = curwin->w_buffer;\n    block_autocmds();\n\n    for (i = 0; !istermoption_idx(i); i++)\n    {\n\tstruct vimoption    *p = &(options[i]);\n\tchar_u\t\t    *varp = get_varp_scope(p, OPT_LOCAL);\n\n\tif (p->indir != PV_NONE\n\t\t&& (do_buffer || (p->indir & PV_BUF) == 0)\n\t\t&& !(options[i].flags & P_NODEFAULT)\n\t\t&& !optval_default(p, varp, FALSE))\n\t    set_option_default(i, OPT_FREE|OPT_LOCAL, FALSE);\n    }\n\n    unblock_autocmds();\n    curwin = save_curwin;\n    curbuf = curwin->w_buffer;\n}\n#endif\n\n#if defined(EXITFREE) || defined(PROTO)\n/*\n * Free all options.\n */\n    void\nfree_all_options(void)\n{\n    int\t\ti;\n\n    for (i = 0; !istermoption_idx(i); i++)\n    {\n\tif (options[i].indir == PV_NONE)\n\t{\n\t    // global option: free value and default value.\n\t    if ((options[i].flags & P_ALLOCED) && options[i].var != NULL)\n\t\tfree_string_option(*(char_u **)options[i].var);\n\t    if (options[i].flags & P_DEF_ALLOCED)\n\t\tfree_string_option(options[i].def_val[VI_DEFAULT]);\n\t}\n\telse if (options[i].var != VAR_WIN\n\t\t&& (options[i].flags & P_STRING))\n\t    // buffer-local option: free global value\n\t    clear_string_option((char_u **)options[i].var);\n    }\n    free_operatorfunc_option();\n    free_tagfunc_option();\n}\n#endif\n\n\n/*\n * Initialize the options, part two: After getting Rows and Columns and\n * setting 'term'.\n */\n    void\nset_init_2(void)\n{\n    int\t\tidx;\n\n    /*\n     * 'scroll' defaults to half the window height. The stored default is zero,\n     * which results in the actual value computed from the window height.\n     */\n    idx = findoption((char_u *)\"scroll\");\n    if (idx >= 0 && !(options[idx].flags & P_WAS_SET))\n\tset_option_default(idx, OPT_LOCAL, p_cp);\n    comp_col();\n\n    /*\n     * 'window' is only for backwards compatibility with Vi.\n     * Default is Rows - 1.\n     */\n    if (!option_was_set((char_u *)\"window\"))\n\tp_window = Rows - 1;\n    set_number_default(\"window\", Rows - 1);\n\n    // For DOS console the default is always black.\n#if !((defined(MSWIN)) && !defined(FEAT_GUI))\n    /*\n     * If 'background' wasn't set by the user, try guessing the value,\n     * depending on the terminal name.  Only need to check for terminals\n     * with a dark background, that can handle color.\n     */\n    idx = findoption((char_u *)\"bg\");\n    if (idx >= 0 && !(options[idx].flags & P_WAS_SET)\n\t\t\t\t\t\t && *term_bg_default() == 'd')\n    {\n\tset_string_option_direct(NULL, idx, (char_u *)\"dark\", OPT_FREE, 0);\n\t// don't mark it as set, when starting the GUI it may be\n\t// changed again\n\toptions[idx].flags &= ~P_WAS_SET;\n    }\n#endif\n\n#ifdef CURSOR_SHAPE\n    parse_shape_opt(SHAPE_CURSOR); // set cursor shapes from 'guicursor'\n#endif\n#ifdef FEAT_MOUSESHAPE\n    parse_shape_opt(SHAPE_MOUSE);  // set mouse shapes from 'mouseshape'\n#endif\n#ifdef FEAT_PRINTER\n    (void)parse_printoptions();\t    // parse 'printoptions' default value\n#endif\n}\n\n/*\n * Initialize the options, part three: After reading the .vimrc\n */\n    void\nset_init_3(void)\n{\n#if defined(UNIX) || defined(MSWIN)\n/*\n * Set 'shellpipe' and 'shellredir', depending on the 'shell' option.\n * This is done after other initializations, where 'shell' might have been\n * set, but only if they have not been set before.\n */\n    char_u  *p;\n    int\t    idx_srr;\n    int\t    do_srr;\n# ifdef FEAT_QUICKFIX\n    int\t    idx_sp;\n    int\t    do_sp;\n# endif\n\n    idx_srr = findoption((char_u *)\"srr\");\n    if (idx_srr < 0)\n\tdo_srr = FALSE;\n    else\n\tdo_srr = !(options[idx_srr].flags & P_WAS_SET);\n# ifdef FEAT_QUICKFIX\n    idx_sp = findoption((char_u *)\"sp\");\n    if (idx_sp < 0)\n\tdo_sp = FALSE;\n    else\n\tdo_sp = !(options[idx_sp].flags & P_WAS_SET);\n# endif\n    p = get_isolated_shell_name();\n    if (p != NULL)\n    {\n\t/*\n\t * Default for p_sp is \"| tee\", for p_srr is \">\".\n\t * For known shells it is changed here to include stderr.\n\t */\n\tif (\t   fnamecmp(p, \"csh\") == 0\n\t\t|| fnamecmp(p, \"tcsh\") == 0\n# if defined(MSWIN)\t// also check with .exe extension\n\t\t|| fnamecmp(p, \"csh.exe\") == 0\n\t\t|| fnamecmp(p, \"tcsh.exe\") == 0\n# endif\n\t   )\n\t{\n# if defined(FEAT_QUICKFIX)\n\t    if (do_sp)\n\t    {\n#  ifdef MSWIN\n\t\tp_sp = (char_u *)\">&\";\n#  else\n\t\tp_sp = (char_u *)\"|& tee\";\n#  endif\n\t\toptions[idx_sp].def_val[VI_DEFAULT] = p_sp;\n\t    }\n# endif\n\t    if (do_srr)\n\t    {\n\t\tp_srr = (char_u *)\">&\";\n\t\toptions[idx_srr].def_val[VI_DEFAULT] = p_srr;\n\t    }\n\t}\n# ifdef MSWIN\n\t// Windows PowerShell output is UTF-16 with BOM so re-encode to the\n\t// current codepage.\n\telse if (   fnamecmp(p, \"powershell\") == 0\n\t\t    || fnamecmp(p, \"powershell.exe\") == 0\n\t\t)\n\t{\n# if defined(FEAT_QUICKFIX)\n\t\tif (do_sp)\n\t\t{\n\t\t    p_sp = (char_u *)\"2>&1 | Out-File -Encoding default\";\n\t\t    options[idx_sp].def_val[VI_DEFAULT] = p_sp;\n\t\t}\n# endif\n\t\tif (do_srr)\n\t\t{\n\t\t    p_srr = (char_u *)\"2>&1 | Out-File -Encoding default\";\n\t\t    options[idx_srr].def_val[VI_DEFAULT] = p_srr;\n\t\t}\n\t}\n#endif\n\telse\n\t    // Always use POSIX shell style redirection if we reach this\n\t    if (       fnamecmp(p, \"sh\") == 0\n\t\t    || fnamecmp(p, \"ksh\") == 0\n\t\t    || fnamecmp(p, \"mksh\") == 0\n\t\t    || fnamecmp(p, \"pdksh\") == 0\n\t\t    || fnamecmp(p, \"zsh\") == 0\n\t\t    || fnamecmp(p, \"zsh-beta\") == 0\n\t\t    || fnamecmp(p, \"bash\") == 0\n\t\t    || fnamecmp(p, \"fish\") == 0\n\t\t    || fnamecmp(p, \"ash\") == 0\n\t\t    || fnamecmp(p, \"dash\") == 0\n\t\t    || fnamecmp(p, \"pwsh\") == 0\n# ifdef MSWIN\n\t\t    || fnamecmp(p, \"cmd\") == 0\n\t\t    || fnamecmp(p, \"sh.exe\") == 0\n\t\t    || fnamecmp(p, \"ksh.exe\") == 0\n\t\t    || fnamecmp(p, \"mksh.exe\") == 0\n\t\t    || fnamecmp(p, \"pdksh.exe\") == 0\n\t\t    || fnamecmp(p, \"zsh.exe\") == 0\n\t\t    || fnamecmp(p, \"zsh-beta.exe\") == 0\n\t\t    || fnamecmp(p, \"bash.exe\") == 0\n\t\t    || fnamecmp(p, \"cmd.exe\") == 0\n\t\t    || fnamecmp(p, \"dash.exe\") == 0\n\t\t    || fnamecmp(p, \"pwsh.exe\") == 0\n# endif\n\t\t    )\n\t    {\n# if defined(FEAT_QUICKFIX)\n\t\tif (do_sp)\n\t\t{\n#  ifdef MSWIN\n\t\t    p_sp = (char_u *)\">%s 2>&1\";\n#  else\n\t\t    if (fnamecmp(p, \"pwsh\") == 0)\n\t\t\tp_sp = (char_u *)\">%s 2>&1\";\n\t\t    else\n\t\t\tp_sp = (char_u *)\"2>&1| tee\";\n#  endif\n\t\t    options[idx_sp].def_val[VI_DEFAULT] = p_sp;\n\t\t}\n# endif\n\t\tif (do_srr)\n\t\t{\n\t\t    p_srr = (char_u *)\">%s 2>&1\";\n\t\t    options[idx_srr].def_val[VI_DEFAULT] = p_srr;\n\t\t}\n\t    }\n\tvim_free(p);\n    }\n#endif\n\n#if defined(MSWIN)\n    /*\n     * Set 'shellcmdflag', 'shellxquote', and 'shellquote' depending on the\n     * 'shell' option.\n     * This is done after other initializations, where 'shell' might have been\n     * set, but only if they have not been set before.\n     * Default values depend on shell (cmd.exe is default shell):\n     *\n     *\t\t\t    p_shcf\tp_sxq\n     * cmd.exe          -   \"/c\"\t\"(\"\n     * powershell.exe   -   \"-Command\"\t\"\\\"\"\n     * pwsh.exe\t\t-   \"-c\"\t\"\\\"\"\n     * \"sh\" like shells -   \"-c\"\t\"\\\"\"\n     *\n     * For Win32 p_sxq is set instead of p_shq to include shell redirection.\n     */\n    if (strstr((char *)gettail(p_sh), \"powershell\") != NULL)\n    {\n\tint\tidx_opt;\n\n\tidx_opt = findoption((char_u *)\"shcf\");\n\tif (idx_opt >= 0 && !(options[idx_opt].flags & P_WAS_SET))\n\t{\n\t    p_shcf = (char_u*)\"-Command\";\n\t    options[idx_opt].def_val[VI_DEFAULT] = p_shcf;\n\t}\n\n\tidx_opt = findoption((char_u *)\"sxq\");\n\tif (idx_opt >= 0 && !(options[idx_opt].flags & P_WAS_SET))\n\t{\n\t    p_sxq = (char_u*)\"\\\"\";\n\t    options[idx_opt].def_val[VI_DEFAULT] = p_sxq;\n\t}\n    }\n    else if (strstr((char *)gettail(p_sh), \"sh\") != NULL)\n    {\n\tint\tidx3;\n\n\tidx3 = findoption((char_u *)\"shcf\");\n\tif (idx3 >= 0 && !(options[idx3].flags & P_WAS_SET))\n\t{\n\t    p_shcf = (char_u *)\"-c\";\n\t    options[idx3].def_val[VI_DEFAULT] = p_shcf;\n\t}\n\n\t// Somehow Win32 requires the quotes around the redirection too\n\tidx3 = findoption((char_u *)\"sxq\");\n\tif (idx3 >= 0 && !(options[idx3].flags & P_WAS_SET))\n\t{\n\t    p_sxq = (char_u *)\"\\\"\";\n\t    options[idx3].def_val[VI_DEFAULT] = p_sxq;\n\t}\n    }\n    else if (strstr((char *)gettail(p_sh), \"cmd.exe\") != NULL)\n    {\n\tint\tidx3;\n\n\t/*\n\t * cmd.exe on Windows will strip the first and last double quote given\n\t * on the command line, e.g. most of the time things like:\n\t *   cmd /c \"my path/to/echo\" \"my args to echo\"\n\t * become:\n\t *   my path/to/echo\" \"my args to echo\n\t * when executed.\n\t *\n\t * To avoid this, set shellxquote to surround the command in\n\t * parenthesis.  This appears to make most commands work, without\n\t * breaking commands that worked previously, such as\n\t * '\"path with spaces/cmd\" \"a&b\"'.\n\t */\n\tidx3 = findoption((char_u *)\"sxq\");\n\tif (idx3 >= 0 && !(options[idx3].flags & P_WAS_SET))\n\t{\n\t    p_sxq = (char_u *)\"(\";\n\t    options[idx3].def_val[VI_DEFAULT] = p_sxq;\n\t}\n\n\tidx3 = findoption((char_u *)\"shcf\");\n\tif (idx3 >= 0 && !(options[idx3].flags & P_WAS_SET))\n\t{\n\t    p_shcf = (char_u *)\"/c\";\n\t    options[idx3].def_val[VI_DEFAULT] = p_shcf;\n\t}\n    }\n#endif\n\n    if (BUFEMPTY())\n    {\n\tint idx_ffs = findoption((char_u *)\"ffs\");\n\n\t// Apply the first entry of 'fileformats' to the initial buffer.\n\tif (idx_ffs >= 0 && (options[idx_ffs].flags & P_WAS_SET))\n\t    set_fileformat(default_fileformat(), OPT_LOCAL);\n    }\n\n    set_title_defaults();\n}\n\n#if defined(FEAT_MULTI_LANG) || defined(PROTO)\n/*\n * When 'helplang' is still at its default value, set it to \"lang\".\n * Only the first two characters of \"lang\" are used.\n */\n    void\nset_helplang_default(char_u *lang)\n{\n    int\t\tidx;\n\n    if (lang == NULL || STRLEN(lang) < 2)\t// safety check\n\treturn;\n    idx = findoption((char_u *)\"hlg\");\n    if (idx >= 0 && !(options[idx].flags & P_WAS_SET))\n    {\n\tif (options[idx].flags & P_ALLOCED)\n\t    free_string_option(p_hlg);\n\tp_hlg = vim_strsave(lang);\n\tif (p_hlg == NULL)\n\t    p_hlg = empty_option;\n\telse\n\t{\n\t    // zh_CN becomes \"cn\", zh_TW becomes \"tw\"\n\t    if (STRNICMP(p_hlg, \"zh_\", 3) == 0 && STRLEN(p_hlg) >= 5)\n\t    {\n\t\tp_hlg[0] = TOLOWER_ASC(p_hlg[3]);\n\t\tp_hlg[1] = TOLOWER_ASC(p_hlg[4]);\n\t    }\n\t    // any C like setting, such as C.UTF-8, becomes \"en\"\n\t    else if (STRLEN(p_hlg) >= 1 && *p_hlg == 'C')\n\t    {\n\t\tp_hlg[0] = 'e';\n\t\tp_hlg[1] = 'n';\n\t    }\n\t    p_hlg[2] = NUL;\n\t}\n\toptions[idx].flags |= P_ALLOCED;\n    }\n}\n#endif\n\n/*\n * 'title' and 'icon' only default to true if they have not been set or reset\n * in .vimrc and we can read the old value.\n * When 'title' and 'icon' have been reset in .vimrc, we won't even check if\n * they can be reset.  This reduces startup time when using X on a remote\n * machine.\n */\n    void\nset_title_defaults(void)\n{\n    int\t    idx1;\n    long    val;\n\n    /*\n     * If GUI is (going to be) used, we can always set the window title and\n     * icon name.  Saves a bit of time, because the X11 display server does\n     * not need to be contacted.\n     */\n    idx1 = findoption((char_u *)\"title\");\n    if (idx1 >= 0 && !(options[idx1].flags & P_WAS_SET))\n    {\n#ifdef FEAT_GUI\n\tif (gui.starting || gui.in_use)\n\t    val = TRUE;\n\telse\n#endif\n\t    val = mch_can_restore_title();\n\toptions[idx1].def_val[VI_DEFAULT] = (char_u *)(long_i)val;\n\tp_title = val;\n    }\n    idx1 = findoption((char_u *)\"icon\");\n    if (idx1 >= 0 && !(options[idx1].flags & P_WAS_SET))\n    {\n#ifdef FEAT_GUI\n\tif (gui.starting || gui.in_use)\n\t    val = TRUE;\n\telse\n#endif\n\t    val = mch_can_restore_icon();\n\toptions[idx1].def_val[VI_DEFAULT] = (char_u *)(long_i)val;\n\tp_icon = val;\n    }\n}\n\n    void\nex_set(exarg_T *eap)\n{\n    int\t\tflags = 0;\n\n    if (eap->cmdidx == CMD_setlocal)\n\tflags = OPT_LOCAL;\n    else if (eap->cmdidx == CMD_setglobal)\n\tflags = OPT_GLOBAL;\n#if defined(FEAT_EVAL) && defined(FEAT_BROWSE)\n    if ((cmdmod.cmod_flags & CMOD_BROWSE) && flags == 0)\n\tex_options(eap);\n    else\n#endif\n    {\n\tif (eap->forceit)\n\t    flags |= OPT_ONECOLUMN;\n\t(void)do_set(eap->arg, flags);\n    }\n}\n\n/*\n * Parse 'arg' for option settings.\n *\n * 'arg' may be IObuff, but only when no errors can be present and option\n * does not need to be expanded with option_expand().\n * \"opt_flags\":\n * 0 for \":set\"\n * OPT_GLOBAL     for \":setglobal\"\n * OPT_LOCAL      for \":setlocal\" and a modeline\n * OPT_MODELINE   for a modeline\n * OPT_WINONLY    to only set window-local options\n * OPT_NOWIN\t  to skip setting window-local options\n * OPT_ONECOLUMN  do not use multiple columns\n *\n * returns FAIL if an error is detected, OK otherwise\n */\n    int\ndo_set(\n    char_u\t*arg_start,\t// option string (may be written to!)\n    int\t\topt_flags)\n{\n    char_u\t*arg = arg_start;\n    int\t\topt_idx;\n    char\t*errmsg;\n    char\terrbuf[80];\n    char_u\t*startarg;\n    int\t\tprefix;\t// 1: nothing, 0: \"no\", 2: \"inv\" in front of name\n    int\t\tnextchar;\t    // next non-white char after option name\n    int\t\tafterchar;\t    // character just after option name\n    int\t\tlen;\n    int\t\ti;\n    varnumber_T\tvalue;\n    int\t\tkey;\n    long_u\tflags;\t\t    // flags for current option\n    char_u\t*varp = NULL;\t    // pointer to variable for current option\n    int\t\tdid_show = FALSE;   // already showed one value\n    int\t\tadding;\t\t    // \"opt+=arg\"\n    int\t\tprepending;\t    // \"opt^=arg\"\n    int\t\tremoving;\t    // \"opt-=arg\"\n    int\t\tcp_val = 0;\n    char_u\tkey_name[2];\n\n    if (*arg == NUL)\n    {\n\tshowoptions(0, opt_flags);\n\tdid_show = TRUE;\n\tgoto theend;\n    }\n\n    while (*arg != NUL)\t\t// loop to process all options\n    {\n\terrmsg = NULL;\n\tstartarg = arg;\t\t// remember for error message\n\n\tif (STRNCMP(arg, \"all\", 3) == 0 && !isalpha(arg[3])\n\t\t\t\t\t\t&& !(opt_flags & OPT_MODELINE))\n\t{\n\t    /*\n\t     * \":set all\"  show all options.\n\t     * \":set all&\" set all options to their default value.\n\t     */\n\t    arg += 3;\n\t    if (*arg == '&')\n\t    {\n\t\t++arg;\n\t\t// Only for :set command set global value of local options.\n\t\tset_options_default(OPT_FREE | opt_flags);\n\t\tdidset_options();\n\t\tdidset_options2();\n\t\tredraw_all_later(CLEAR);\n\t    }\n\t    else\n\t    {\n\t\tshowoptions(1, opt_flags);\n\t\tdid_show = TRUE;\n\t    }\n\t}\n\telse if (STRNCMP(arg, \"termcap\", 7) == 0 && !(opt_flags & OPT_MODELINE))\n\t{\n\t    showoptions(2, opt_flags);\n\t    show_termcodes(opt_flags);\n\t    did_show = TRUE;\n\t    arg += 7;\n\t}\n\telse\n\t{\n\t    prefix = 1;\n\t    if (STRNCMP(arg, \"no\", 2) == 0 && STRNCMP(arg, \"novice\", 6) != 0)\n\t    {\n\t\tprefix = 0;\n\t\targ += 2;\n\t    }\n\t    else if (STRNCMP(arg, \"inv\", 3) == 0)\n\t    {\n\t\tprefix = 2;\n\t\targ += 3;\n\t    }\n\n\t    // find end of name\n\t    key = 0;\n\t    if (*arg == '<')\n\t    {\n\t\topt_idx = -1;\n\t\t// look out for <t_>;>\n\t\tif (arg[1] == 't' && arg[2] == '_' && arg[3] && arg[4])\n\t\t    len = 5;\n\t\telse\n\t\t{\n\t\t    len = 1;\n\t\t    while (arg[len] != NUL && arg[len] != '>')\n\t\t\t++len;\n\t\t}\n\t\tif (arg[len] != '>')\n\t\t{\n\t\t    errmsg = e_invalid_argument;\n\t\t    goto skip;\n\t\t}\n\t\targ[len] = NUL;\t\t\t    // put NUL after name\n\t\tif (arg[1] == 't' && arg[2] == '_') // could be term code\n\t\t    opt_idx = findoption(arg + 1);\n\t\targ[len++] = '>';\t\t    // restore '>'\n\t\tif (opt_idx == -1)\n\t\t    key = find_key_option(arg + 1, TRUE);\n\t    }\n\t    else\n\t    {\n\t\tlen = 0;\n\t\t/*\n\t\t * The two characters after \"t_\" may not be alphanumeric.\n\t\t */\n\t\tif (arg[0] == 't' && arg[1] == '_' && arg[2] && arg[3])\n\t\t    len = 4;\n\t\telse\n\t\t    while (ASCII_ISALNUM(arg[len]) || arg[len] == '_')\n\t\t\t++len;\n\t\tnextchar = arg[len];\n\t\targ[len] = NUL;\t\t\t    // put NUL after name\n\t\topt_idx = findoption(arg);\n\t\targ[len] = nextchar;\t\t    // restore nextchar\n\t\tif (opt_idx == -1)\n\t\t    key = find_key_option(arg, FALSE);\n\t    }\n\n\t    // remember character after option name\n\t    afterchar = arg[len];\n\n\t    if (in_vim9script())\n\t    {\n\t\tchar_u *p = skipwhite(arg + len);\n\n\t\t// disallow white space before =val, +=val, -=val, ^=val\n\t\tif (p > arg + len && (p[0] == '='\n\t\t\t|| (vim_strchr((char_u *)\"+-^\", p[0]) != NULL\n\t\t\t\t\t\t\t      && p[1] == '=')))\n\t\t{\n\t\t    errmsg = e_no_white_space_allowed_between_option_and;\n\t\t    arg = p;\n\t\t    startarg = p;\n\t\t    goto skip;\n\t\t}\n\t    }\n\t    else\n\t\t// skip white space, allow \":set ai  ?\", \":set hlsearch  !\"\n\t\twhile (VIM_ISWHITE(arg[len]))\n\t\t    ++len;\n\n\t    adding = FALSE;\n\t    prepending = FALSE;\n\t    removing = FALSE;\n\t    if (arg[len] != NUL && arg[len + 1] == '=')\n\t    {\n\t\tif (arg[len] == '+')\n\t\t{\n\t\t    adding = TRUE;\t\t// \"+=\"\n\t\t    ++len;\n\t\t}\n\t\telse if (arg[len] == '^')\n\t\t{\n\t\t    prepending = TRUE;\t\t// \"^=\"\n\t\t    ++len;\n\t\t}\n\t\telse if (arg[len] == '-')\n\t\t{\n\t\t    removing = TRUE;\t\t// \"-=\"\n\t\t    ++len;\n\t\t}\n\t    }\n\t    nextchar = arg[len];\n\n\t    if (opt_idx == -1 && key == 0)\t// found a mismatch: skip\n\t    {\n\t\tif (in_vim9script() && arg > arg_start\n\t\t\t\t  && vim_strchr((char_u *)\"!&<\", *arg) != NULL)\n\t\t    errmsg = e_no_white_space_allowed_between_option_and;\n\t\telse\n\t\t    errmsg = N_(e_unknown_option);\n\t\tgoto skip;\n\t    }\n\n\t    if (opt_idx >= 0)\n\t    {\n\t\tif (options[opt_idx].var == NULL)   // hidden option: skip\n\t\t{\n\t\t    // Only give an error message when requesting the value of\n\t\t    // a hidden option, ignore setting it.\n\t\t    if (vim_strchr((char_u *)\"=:!&<\", nextchar) == NULL\n\t\t\t    && (!(options[opt_idx].flags & P_BOOL)\n\t\t\t\t|| nextchar == '?'))\n\t\t\terrmsg = N_(e_option_not_supported);\n\t\t    goto skip;\n\t\t}\n\n\t\tflags = options[opt_idx].flags;\n\t\tvarp = get_varp_scope(&(options[opt_idx]), opt_flags);\n\t    }\n\t    else\n\t    {\n\t\tflags = P_STRING;\n\t\tif (key < 0)\n\t\t{\n\t\t    key_name[0] = KEY2TERMCAP0(key);\n\t\t    key_name[1] = KEY2TERMCAP1(key);\n\t\t}\n\t\telse\n\t\t{\n\t\t    key_name[0] = KS_KEY;\n\t\t    key_name[1] = (key & 0xff);\n\t\t}\n\t    }\n\n\t    // Skip all options that are not window-local (used when showing\n\t    // an already loaded buffer in a window).\n\t    if ((opt_flags & OPT_WINONLY)\n\t\t\t  && (opt_idx < 0 || options[opt_idx].var != VAR_WIN))\n\t\tgoto skip;\n\n\t    // Skip all options that are window-local (used for :vimgrep).\n\t    if ((opt_flags & OPT_NOWIN) && opt_idx >= 0\n\t\t\t\t\t   && options[opt_idx].var == VAR_WIN)\n\t\tgoto skip;\n\n\t    // Disallow changing some options from modelines.\n\t    if (opt_flags & OPT_MODELINE)\n\t    {\n\t\tif (flags & (P_SECURE | P_NO_ML))\n\t\t{\n\t\t    errmsg = N_(e_not_allowed_in_modeline);\n\t\t    goto skip;\n\t\t}\n\t\tif ((flags & P_MLE) && !p_mle)\n\t\t{\n\t\t    errmsg = N_(e_not_allowed_in_modeline_when_modelineexpr_is_off);\n\t\t    goto skip;\n\t\t}\n#ifdef FEAT_DIFF\n\t\t// In diff mode some options are overruled.  This avoids that\n\t\t// 'foldmethod' becomes \"marker\" instead of \"diff\" and that\n\t\t// \"wrap\" gets set.\n\t\tif (curwin->w_p_diff\n\t\t\t&& opt_idx >= 0  // shut up coverity warning\n\t\t\t&& (\n#ifdef FEAT_FOLDING\n\t\t\t    options[opt_idx].indir == PV_FDM ||\n#endif\n\t\t\t    options[opt_idx].indir == PV_WRAP))\n\t\t    goto skip;\n#endif\n\t    }\n\n#ifdef HAVE_SANDBOX\n\t    // Disallow changing some options in the sandbox\n\t    if (sandbox != 0 && (flags & P_SECURE))\n\t    {\n\t\terrmsg = e_not_allowed_in_sandbox;\n\t\tgoto skip;\n\t    }\n#endif\n\n\t    if (vim_strchr((char_u *)\"?=:!&<\", nextchar) != NULL)\n\t    {\n\t\targ += len;\n\t\tcp_val = p_cp;\n\t\tif (nextchar == '&' && arg[1] == 'v' && arg[2] == 'i')\n\t\t{\n\t\t    if (arg[3] == 'm')\t// \"opt&vim\": set to Vim default\n\t\t    {\n\t\t\tcp_val = FALSE;\n\t\t\targ += 3;\n\t\t    }\n\t\t    else\t\t// \"opt&vi\": set to Vi default\n\t\t    {\n\t\t\tcp_val = TRUE;\n\t\t\targ += 2;\n\t\t    }\n\t\t}\n\t\tif (vim_strchr((char_u *)\"?!&<\", nextchar) != NULL\n\t\t\t&& arg[1] != NUL && !VIM_ISWHITE(arg[1]))\n\t\t{\n\t\t    errmsg = e_trailing_characters;\n\t\t    goto skip;\n\t\t}\n\t    }\n\n\t    /*\n\t     * allow '=' and ':' for historical reasons (MSDOS command.com\n\t     * allows only one '=' character per \"set\" command line. grrr. (jw)\n\t     */\n\t    if (nextchar == '?'\n\t\t    || (prefix == 1\n\t\t\t&& vim_strchr((char_u *)\"=:&<\", nextchar) == NULL\n\t\t\t&& !(flags & P_BOOL)))\n\t    {\n\t\t/*\n\t\t * print value\n\t\t */\n\t\tif (did_show)\n\t\t    msg_putchar('\\n');\t    // cursor below last one\n\t\telse\n\t\t{\n\t\t    gotocmdline(TRUE);\t    // cursor at status line\n\t\t    did_show = TRUE;\t    // remember that we did a line\n\t\t}\n\t\tif (opt_idx >= 0)\n\t\t{\n\t\t    showoneopt(&options[opt_idx], opt_flags);\n#ifdef FEAT_EVAL\n\t\t    if (p_verbose > 0)\n\t\t    {\n\t\t\t// Mention where the option was last set.\n\t\t\tif (varp == options[opt_idx].var)\n\t\t\t    last_set_msg(options[opt_idx].script_ctx);\n\t\t\telse if ((int)options[opt_idx].indir & PV_WIN)\n\t\t\t    last_set_msg(curwin->w_p_script_ctx[\n\t\t\t\t      (int)options[opt_idx].indir & PV_MASK]);\n\t\t\telse if ((int)options[opt_idx].indir & PV_BUF)\n\t\t\t    last_set_msg(curbuf->b_p_script_ctx[\n\t\t\t\t      (int)options[opt_idx].indir & PV_MASK]);\n\t\t    }\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    char_u\t    *p;\n\n\t\t    p = find_termcode(key_name);\n\t\t    if (p == NULL)\n\t\t    {\n\t\t\terrmsg = N_(e_key_code_not_set);\n\t\t\tgoto skip;\n\t\t    }\n\t\t    else\n\t\t\t(void)show_one_termcode(key_name, p, TRUE);\n\t\t}\n\t\tif (nextchar != '?'\n\t\t\t&& nextchar != NUL && !VIM_ISWHITE(afterchar))\n\t\t    errmsg = e_trailing_characters;\n\t    }\n\t    else\n\t    {\n\t\tint value_is_replaced = !prepending && !adding && !removing;\n\t\tint value_checked = FALSE;\n\n\t\tif (flags & P_BOOL)\t\t    // boolean\n\t\t{\n\t\t    if (nextchar == '=' || nextchar == ':')\n\t\t    {\n\t\t\terrmsg = e_invalid_argument;\n\t\t\tgoto skip;\n\t\t    }\n\n\t\t    /*\n\t\t     * \":set opt!\": invert\n\t\t     * \":set opt&\": reset to default value\n\t\t     * \":set opt<\": reset to global value\n\t\t     */\n\t\t    if (nextchar == '!')\n\t\t\tvalue = *(int *)(varp) ^ 1;\n\t\t    else if (nextchar == '&')\n\t\t\tvalue = (int)(long)(long_i)options[opt_idx].def_val[\n\t\t\t\t\t\t((flags & P_VI_DEF) || cp_val)\n\t\t\t\t\t\t ?  VI_DEFAULT : VIM_DEFAULT];\n\t\t    else if (nextchar == '<')\n\t\t    {\n\t\t\t// For 'autoread' -1 means to use global value.\n\t\t\tif ((int *)varp == &curbuf->b_p_ar\n\t\t\t\t\t\t    && opt_flags == OPT_LOCAL)\n\t\t\t    value = -1;\n\t\t\telse\n\t\t\t    value = *(int *)get_varp_scope(&(options[opt_idx]),\n\t\t\t\t\t\t\t\t  OPT_GLOBAL);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t/*\n\t\t\t * \":set invopt\": invert\n\t\t\t * \":set opt\" or \":set noopt\": set or reset\n\t\t\t */\n\t\t\tif (nextchar != NUL && !VIM_ISWHITE(afterchar))\n\t\t\t{\n\t\t\t    errmsg = e_trailing_characters;\n\t\t\t    goto skip;\n\t\t\t}\n\t\t\tif (prefix == 2)\t// inv\n\t\t\t    value = *(int *)(varp) ^ 1;\n\t\t\telse\n\t\t\t    value = prefix;\n\t\t    }\n\n\t\t    errmsg = set_bool_option(opt_idx, varp, (int)value,\n\t\t\t\t\t\t\t\t   opt_flags);\n\t\t}\n\t\telse\t\t\t\t    // numeric or string\n\t\t{\n\t\t    if (vim_strchr((char_u *)\"=:&<\", nextchar) == NULL\n\t\t\t\t\t\t\t       || prefix != 1)\n\t\t    {\n\t\t\terrmsg = e_invalid_argument;\n\t\t\tgoto skip;\n\t\t    }\n\n\t\t    if (flags & P_NUM)\t\t    // numeric\n\t\t    {\n\t\t\t/*\n\t\t\t * Different ways to set a number option:\n\t\t\t * &\t    set to default value\n\t\t\t * <\t    set to global value\n\t\t\t * <xx>\t    accept special key codes for 'wildchar'\n\t\t\t * c\t    accept any non-digit for 'wildchar'\n\t\t\t * [-]0-9   set number\n\t\t\t * other    error\n\t\t\t */\n\t\t\t++arg;\n\t\t\tif (nextchar == '&')\n\t\t\t    value = (long)(long_i)options[opt_idx].def_val[\n\t\t\t\t\t\t((flags & P_VI_DEF) || cp_val)\n\t\t\t\t\t\t ?  VI_DEFAULT : VIM_DEFAULT];\n\t\t\telse if (nextchar == '<')\n\t\t\t{\n\t\t\t    // For 'undolevels' NO_LOCAL_UNDOLEVEL means to\n\t\t\t    // use the global value.\n\t\t\t    if ((long *)varp == &curbuf->b_p_ul\n\t\t\t\t\t\t    && opt_flags == OPT_LOCAL)\n\t\t\t\tvalue = NO_LOCAL_UNDOLEVEL;\n\t\t\t    else\n\t\t\t\tvalue = *(long *)get_varp_scope(\n\t\t\t\t\t     &(options[opt_idx]), OPT_GLOBAL);\n\t\t\t}\n\t\t\telse if (((long *)varp == &p_wc\n\t\t\t\t    || (long *)varp == &p_wcm)\n\t\t\t\t&& (*arg == '<'\n\t\t\t\t    || *arg == '^'\n\t\t\t\t    || (*arg != NUL\n\t\t\t\t\t&& (!arg[1] || VIM_ISWHITE(arg[1]))\n\t\t\t\t\t&& !VIM_ISDIGIT(*arg))))\n\t\t\t{\n\t\t\t    value = string_to_key(arg, FALSE);\n\t\t\t    if (value == 0 && (long *)varp != &p_wcm)\n\t\t\t    {\n\t\t\t\terrmsg = e_invalid_argument;\n\t\t\t\tgoto skip;\n\t\t\t    }\n\t\t\t}\n\t\t\telse if (*arg == '-' || VIM_ISDIGIT(*arg))\n\t\t\t{\n\t\t\t    // Allow negative (for 'undolevels'), octal and\n\t\t\t    // hex numbers.\n\t\t\t    vim_str2nr(arg, NULL, &i, STR2NR_ALL,\n\t\t\t\t\t\t     &value, NULL, 0, TRUE);\n\t\t\t    if (i == 0 || (arg[i] != NUL\n\t\t\t\t\t\t      && !VIM_ISWHITE(arg[i])))\n\t\t\t    {\n\t\t\t\terrmsg = N_(e_number_required_after_equal);\n\t\t\t\tgoto skip;\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    errmsg = N_(e_number_required_after_equal);\n\t\t\t    goto skip;\n\t\t\t}\n\n\t\t\tif (adding)\n\t\t\t    value = *(long *)varp + value;\n\t\t\tif (prepending)\n\t\t\t    value = *(long *)varp * value;\n\t\t\tif (removing)\n\t\t\t    value = *(long *)varp - value;\n\t\t\terrmsg = set_num_option(opt_idx, varp, value,\n\t\t\t\t\t   errbuf, sizeof(errbuf), opt_flags);\n\t\t    }\n\t\t    else if (opt_idx >= 0)\t\t    // string\n\t\t    {\n\t\t\tchar_u\t  *save_arg = NULL;\n\t\t\tchar_u\t  *s = NULL;\n\t\t\tchar_u\t  *oldval = NULL; // previous value if *varp\n\t\t\tchar_u\t  *newval;\n\t\t\tchar_u\t  *origval = NULL;\n\t\t\tchar_u\t  *origval_l = NULL;\n\t\t\tchar_u\t  *origval_g = NULL;\n#if defined(FEAT_EVAL)\n\t\t\tchar_u\t  *saved_origval = NULL;\n\t\t\tchar_u\t  *saved_origval_l = NULL;\n\t\t\tchar_u\t  *saved_origval_g = NULL;\n\t\t\tchar_u\t  *saved_newval = NULL;\n#endif\n\t\t\tunsigned  newlen;\n\t\t\tint\t  comma;\n\t\t\tint\t  new_value_alloced;\t// new string option\n\t\t\t\t\t\t\t// was allocated\n\n\t\t\t// When using \":set opt=val\" for a global option\n\t\t\t// with a local value the local value will be\n\t\t\t// reset, use the global value here.\n\t\t\tif ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0\n\t\t\t\t&& ((int)options[opt_idx].indir & PV_BOTH))\n\t\t\t    varp = options[opt_idx].var;\n\n\t\t\t// The old value is kept until we are sure that the\n\t\t\t// new value is valid.\n\t\t\toldval = *(char_u **)varp;\n\n\t\t\tif ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\t\t\t{\n\t\t\t    origval_l = *(char_u **)get_varp_scope(\n\t\t\t\t\t       &(options[opt_idx]), OPT_LOCAL);\n\t\t\t    origval_g = *(char_u **)get_varp_scope(\n\t\t\t\t\t      &(options[opt_idx]), OPT_GLOBAL);\n\n\t\t\t    // A global-local string option might have an empty\n\t\t\t    // option as value to indicate that the global\n\t\t\t    // value should be used.\n\t\t\t    if (((int)options[opt_idx].indir & PV_BOTH)\n\t\t\t\t\t\t  && origval_l == empty_option)\n\t\t\t\torigval_l = origval_g;\n\t\t\t}\n\n\t\t\t// When setting the local value of a global\n\t\t\t// option, the old value may be the global value.\n\t\t\tif (((int)options[opt_idx].indir & PV_BOTH)\n\t\t\t\t\t       && (opt_flags & OPT_LOCAL))\n\t\t\t    origval = *(char_u **)get_varp(\n\t\t\t\t\t\t       &options[opt_idx]);\n\t\t\telse\n\t\t\t    origval = oldval;\n\n\t\t\tif (nextchar == '&')\t// set to default val\n\t\t\t{\n\t\t\t    newval = options[opt_idx].def_val[\n\t\t\t\t\t\t((flags & P_VI_DEF) || cp_val)\n\t\t\t\t\t\t ?  VI_DEFAULT : VIM_DEFAULT];\n\t\t\t    if ((char_u **)varp == &p_bg)\n\t\t\t    {\n\t\t\t\t// guess the value of 'background'\n#ifdef FEAT_GUI\n\t\t\t\tif (gui.in_use)\n\t\t\t\t    newval = gui_bg_default();\n\t\t\t\telse\n#endif\n\t\t\t\t    newval = term_bg_default();\n\t\t\t    }\n\t\t\t    else if ((char_u **)varp == &p_fencs && enc_utf8)\n\t\t\t\tnewval = fencs_utf8_default;\n\n\t\t\t    // expand environment variables and ~ since the\n\t\t\t    // default value was already expanded, only\n\t\t\t    // required when an environment variable was set\n\t\t\t    // later\n\t\t\t    if (newval == NULL)\n\t\t\t\tnewval = empty_option;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\ts = option_expand(opt_idx, newval);\n\t\t\t\tif (s == NULL)\n\t\t\t\t    s = newval;\n\t\t\t\tnewval = vim_strsave(s);\n\t\t\t    }\n\t\t\t    new_value_alloced = TRUE;\n\t\t\t}\n\t\t\telse if (nextchar == '<')\t// set to global val\n\t\t\t{\n\t\t\t    newval = vim_strsave(*(char_u **)get_varp_scope(\n\t\t\t\t\t     &(options[opt_idx]), OPT_GLOBAL));\n\t\t\t    new_value_alloced = TRUE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    ++arg;\t// jump to after the '=' or ':'\n\n\t\t\t    /*\n\t\t\t     * Set 'keywordprg' to \":help\" if an empty\n\t\t\t     * value was passed to :set by the user.\n\t\t\t     * Misuse errbuf[] for the resulting string.\n\t\t\t     */\n\t\t\t    if (varp == (char_u *)&p_kp\n\t\t\t\t\t      && (*arg == NUL || *arg == ' '))\n\t\t\t    {\n\t\t\t\tSTRCPY(errbuf, \":help\");\n\t\t\t\tsave_arg = arg;\n\t\t\t\targ = (char_u *)errbuf;\n\t\t\t    }\n\t\t\t    /*\n\t\t\t     * Convert 'backspace' number to string, for\n\t\t\t     * adding, prepending and removing string.\n\t\t\t     */\n\t\t\t    else if (varp == (char_u *)&p_bs\n\t\t\t\t\t && VIM_ISDIGIT(**(char_u **)varp))\n\t\t\t    {\n\t\t\t\ti = getdigits((char_u **)varp);\n\t\t\t\tswitch (i)\n\t\t\t\t{\n\t\t\t\t    case 0:\n\t\t\t\t\t*(char_u **)varp = empty_option;\n\t\t\t\t\tbreak;\n\t\t\t\t    case 1:\n\t\t\t\t\t*(char_u **)varp = vim_strsave(\n\t\t\t\t\t\t      (char_u *)\"indent,eol\");\n\t\t\t\t\tbreak;\n\t\t\t\t    case 2:\n\t\t\t\t\t*(char_u **)varp = vim_strsave(\n\t\t\t\t\t\t(char_u *)\"indent,eol,start\");\n\t\t\t\t\tbreak;\n\t\t\t\t    case 3:\n\t\t\t\t\t*(char_u **)varp = vim_strsave(\n\t\t\t\t\t\t(char_u *)\"indent,eol,nostop\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvim_free(oldval);\n\t\t\t\tif (origval == oldval)\n\t\t\t\t    origval = *(char_u **)varp;\n\t\t\t\tif (origval_l == oldval)\n\t\t\t\t    origval_l = *(char_u **)varp;\n\t\t\t\tif (origval_g == oldval)\n\t\t\t\t    origval_g = *(char_u **)varp;\n\t\t\t\toldval = *(char_u **)varp;\n\t\t\t    }\n\t\t\t    /*\n\t\t\t     * Convert 'whichwrap' number to string, for\n\t\t\t     * backwards compatibility with Vim 3.0.\n\t\t\t     * Misuse errbuf[] for the resulting string.\n\t\t\t     */\n\t\t\t    else if (varp == (char_u *)&p_ww\n\t\t\t\t\t\t\t && VIM_ISDIGIT(*arg))\n\t\t\t    {\n\t\t\t\t*errbuf = NUL;\n\t\t\t\ti = getdigits(&arg);\n\t\t\t\tif (i & 1)\n\t\t\t\t    STRCAT(errbuf, \"b,\");\n\t\t\t\tif (i & 2)\n\t\t\t\t    STRCAT(errbuf, \"s,\");\n\t\t\t\tif (i & 4)\n\t\t\t\t    STRCAT(errbuf, \"h,l,\");\n\t\t\t\tif (i & 8)\n\t\t\t\t    STRCAT(errbuf, \"<,>,\");\n\t\t\t\tif (i & 16)\n\t\t\t\t    STRCAT(errbuf, \"[,],\");\n\t\t\t\tif (*errbuf != NUL)\t// remove trailing ,\n\t\t\t\t    errbuf[STRLEN(errbuf) - 1] = NUL;\n\t\t\t\tsave_arg = arg;\n\t\t\t\targ = (char_u *)errbuf;\n\t\t\t    }\n\t\t\t    /*\n\t\t\t     * Remove '>' before 'dir' and 'bdir', for\n\t\t\t     * backwards compatibility with version 3.0\n\t\t\t     */\n\t\t\t    else if (  *arg == '>'\n\t\t\t\t    && (varp == (char_u *)&p_dir\n\t\t\t\t\t    || varp == (char_u *)&p_bdir))\n\t\t\t    {\n\t\t\t\t++arg;\n\t\t\t    }\n\n\t\t\t    /*\n\t\t\t     * Copy the new string into allocated memory.\n\t\t\t     * Can't use set_string_option_direct(), because\n\t\t\t     * we need to remove the backslashes.\n\t\t\t     */\n\t\t\t    // get a bit too much\n\t\t\t    newlen = (unsigned)STRLEN(arg) + 1;\n\t\t\t    if (adding || prepending || removing)\n\t\t\t\tnewlen += (unsigned)STRLEN(origval) + 1;\n\t\t\t    newval = alloc(newlen);\n\t\t\t    if (newval == NULL)  // out of mem, don't change\n\t\t\t\tbreak;\n\t\t\t    s = newval;\n\n\t\t\t    /*\n\t\t\t     * Copy the string, skip over escaped chars.\n\t\t\t     * For MS-DOS and WIN32 backslashes before normal\n\t\t\t     * file name characters are not removed, and keep\n\t\t\t     * backslash at start, for \"\\\\machine\\path\", but\n\t\t\t     * do remove it for \"\\\\\\\\machine\\\\path\".\n\t\t\t     * The reverse is found in ExpandOldSetting().\n\t\t\t     */\n\t\t\t    while (*arg && !VIM_ISWHITE(*arg))\n\t\t\t    {\n\t\t\t\tif (*arg == '\\\\' && arg[1] != NUL\n#ifdef BACKSLASH_IN_FILENAME\n\t\t\t\t\t&& !((flags & P_EXPAND)\n\t\t\t\t\t\t&& vim_isfilec(arg[1])\n\t\t\t\t\t\t&& !VIM_ISWHITE(arg[1])\n\t\t\t\t\t\t&& (arg[1] != '\\\\'\n\t\t\t\t\t\t    || (s == newval\n\t\t\t\t\t\t\t&& arg[2] != '\\\\')))\n#endif\n\t\t\t\t\t\t\t\t    )\n\t\t\t\t    ++arg;\t// remove backslash\n\t\t\t\tif (has_mbyte\n\t\t\t\t\t&& (i = (*mb_ptr2len)(arg)) > 1)\n\t\t\t\t{\n\t\t\t\t    // copy multibyte char\n\t\t\t\t    mch_memmove(s, arg, (size_t)i);\n\t\t\t\t    arg += i;\n\t\t\t\t    s += i;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t    *s++ = *arg++;\n\t\t\t    }\n\t\t\t    *s = NUL;\n\n\t\t\t    /*\n\t\t\t     * Expand environment variables and ~.\n\t\t\t     * Don't do it when adding without inserting a\n\t\t\t     * comma.\n\t\t\t     */\n\t\t\t    if (!(adding || prepending || removing)\n\t\t\t\t\t\t\t || (flags & P_COMMA))\n\t\t\t    {\n\t\t\t\ts = option_expand(opt_idx, newval);\n\t\t\t\tif (s != NULL)\n\t\t\t\t{\n\t\t\t\t    vim_free(newval);\n\t\t\t\t    newlen = (unsigned)STRLEN(s) + 1;\n\t\t\t\t    if (adding || prepending || removing)\n\t\t\t\t\tnewlen += (unsigned)STRLEN(origval) + 1;\n\t\t\t\t    newval = alloc(newlen);\n\t\t\t\t    if (newval == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\t    STRCPY(newval, s);\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    // locate newval[] in origval[] when removing it\n\t\t\t    // and when adding to avoid duplicates\n\t\t\t    i = 0;\t// init for GCC\n\t\t\t    if (removing || (flags & P_NODUP))\n\t\t\t    {\n\t\t\t\ti = (int)STRLEN(newval);\n\t\t\t\ts = find_dup_item(origval, newval, flags);\n\n\t\t\t\t// do not add if already there\n\t\t\t\tif ((adding || prepending) && s != NULL)\n\t\t\t\t{\n\t\t\t\t    prepending = FALSE;\n\t\t\t\t    adding = FALSE;\n\t\t\t\t    STRCPY(newval, origval);\n\t\t\t\t}\n\n\t\t\t\t// if no duplicate, move pointer to end of\n\t\t\t\t// original value\n\t\t\t\tif (s == NULL)\n\t\t\t\t    s = origval + (int)STRLEN(origval);\n\t\t\t    }\n\n\t\t\t    // concatenate the two strings; add a ',' if\n\t\t\t    // needed\n\t\t\t    if (adding || prepending)\n\t\t\t    {\n\t\t\t\tcomma = ((flags & P_COMMA) && *origval != NUL\n\t\t\t\t\t\t\t   && *newval != NUL);\n\t\t\t\tif (adding)\n\t\t\t\t{\n\t\t\t\t    i = (int)STRLEN(origval);\n\t\t\t\t    // strip a trailing comma, would get 2\n\t\t\t\t    if (comma && i > 1\n\t\t\t\t\t  && (flags & P_ONECOMMA) == P_ONECOMMA\n\t\t\t\t\t  && origval[i - 1] == ','\n\t\t\t\t\t  && origval[i - 2] != '\\\\')\n\t\t\t\t\ti--;\n\t\t\t\t    mch_memmove(newval + i + comma, newval,\n\t\t\t\t\t\t\t  STRLEN(newval) + 1);\n\t\t\t\t    mch_memmove(newval, origval, (size_t)i);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    i = (int)STRLEN(newval);\n\t\t\t\t    STRMOVE(newval + i + comma, origval);\n\t\t\t\t}\n\t\t\t\tif (comma)\n\t\t\t\t    newval[i] = ',';\n\t\t\t    }\n\n\t\t\t    // Remove newval[] from origval[]. (Note: \"i\" has\n\t\t\t    // been set above and is used here).\n\t\t\t    if (removing)\n\t\t\t    {\n\t\t\t\tSTRCPY(newval, origval);\n\t\t\t\tif (*s)\n\t\t\t\t{\n\t\t\t\t    // may need to remove a comma\n\t\t\t\t    if (flags & P_COMMA)\n\t\t\t\t    {\n\t\t\t\t\tif (s == origval)\n\t\t\t\t\t{\n\t\t\t\t\t    // include comma after string\n\t\t\t\t\t    if (s[i] == ',')\n\t\t\t\t\t\t++i;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t    // include comma before string\n\t\t\t\t\t    --s;\n\t\t\t\t\t    ++i;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t    STRMOVE(newval + (s - origval), s + i);\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    if (flags & P_FLAGLIST)\n\t\t\t    {\n\t\t\t\t// Remove flags that appear twice.\n\t\t\t\tfor (s = newval; *s;)\n\t\t\t\t{\n\t\t\t\t    // if options have P_FLAGLIST and\n\t\t\t\t    // P_ONECOMMA such as 'whichwrap'\n\t\t\t\t    if (flags & P_ONECOMMA)\n\t\t\t\t    {\n\t\t\t\t\tif (*s != ',' && *(s + 1) == ','\n\t\t\t\t\t      && vim_strchr(s + 2, *s) != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t    // Remove the duplicated value and\n\t\t\t\t\t    // the next comma.\n\t\t\t\t\t    STRMOVE(s, s + 2);\n\t\t\t\t\t    continue;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t\tif ((!(flags & P_COMMA) || *s != ',')\n\t\t\t\t\t      && vim_strchr(s + 1, *s) != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t    STRMOVE(s, s + 1);\n\t\t\t\t\t    continue;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t    ++s;\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    if (save_arg != NULL)   // number for 'whichwrap'\n\t\t\t\targ = save_arg;\n\t\t\t    new_value_alloced = TRUE;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Set the new value.\n\t\t\t */\n\t\t\t*(char_u **)(varp) = newval;\n\n#if defined(FEAT_EVAL)\n\t\t\tif (!starting\n# ifdef FEAT_CRYPT\n\t\t\t\t&& options[opt_idx].indir != PV_KEY\n# endif\n\t\t\t\t\t  && origval != NULL && newval != NULL)\n\t\t\t{\n\t\t\t    // origval may be freed by\n\t\t\t    // did_set_string_option(), make a copy.\n\t\t\t    saved_origval = vim_strsave(origval);\n\t\t\t    // newval (and varp) may become invalid if the\n\t\t\t    // buffer is closed by autocommands.\n\t\t\t    saved_newval = vim_strsave(newval);\n\t\t\t    if (origval_l != NULL)\n\t\t\t\tsaved_origval_l = vim_strsave(origval_l);\n\t\t\t    if (origval_g != NULL)\n\t\t\t\tsaved_origval_g = vim_strsave(origval_g);\n\t\t\t}\n#endif\n\n\t\t\t{\n\t\t\t    long_u *p = insecure_flag(opt_idx, opt_flags);\n\t\t\t    int\t    secure_saved = secure;\n\n\t\t\t    // When an option is set in the sandbox, from a\n\t\t\t    // modeline or in secure mode, then deal with side\n\t\t\t    // effects in secure mode.  Also when the value was\n\t\t\t    // set with the P_INSECURE flag and is not\n\t\t\t    // completely replaced.\n\t\t\t    if ((opt_flags & OPT_MODELINE)\n#ifdef HAVE_SANDBOX\n\t\t\t\t  || sandbox != 0\n#endif\n\t\t\t\t  || (!value_is_replaced && (*p & P_INSECURE)))\n\t\t\t\tsecure = 1;\n\n\t\t\t    // Handle side effects, and set the global value\n\t\t\t    // for \":set\" on local options. Note: when setting\n\t\t\t    // 'syntax' or 'filetype' autocommands may be\n\t\t\t    // triggered that can cause havoc.\n\t\t\t    errmsg = did_set_string_option(\n\t\t\t\t    opt_idx, (char_u **)varp,\n\t\t\t\t    new_value_alloced, oldval, errbuf,\n\t\t\t\t    opt_flags, &value_checked);\n\n\t\t\t    secure = secure_saved;\n\t\t\t}\n\n#if defined(FEAT_EVAL)\n\t\t\tif (errmsg == NULL)\n\t\t\t    trigger_optionsset_string(\n\t\t\t\t    opt_idx, opt_flags, saved_origval,\n\t\t\t\t    saved_origval_l, saved_origval_g,\n\t\t\t\t    saved_newval);\n\t\t\tvim_free(saved_origval);\n\t\t\tvim_free(saved_origval_l);\n\t\t\tvim_free(saved_origval_g);\n\t\t\tvim_free(saved_newval);\n#endif\n\t\t\t// If error detected, print the error message.\n\t\t\tif (errmsg != NULL)\n\t\t\t    goto skip;\n\t\t    }\n\t\t    else\t    // key code option\n\t\t    {\n\t\t\tchar_u\t    *p;\n\n\t\t\tif (nextchar == '&')\n\t\t\t{\n\t\t\t    if (add_termcap_entry(key_name, TRUE) == FAIL)\n\t\t\t\terrmsg = N_(e_not_found_in_termcap);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    ++arg; // jump to after the '=' or ':'\n\t\t\t    for (p = arg; *p && !VIM_ISWHITE(*p); ++p)\n\t\t\t\tif (*p == '\\\\' && p[1] != NUL)\n\t\t\t\t    ++p;\n\t\t\t    nextchar = *p;\n\t\t\t    *p = NUL;\n\t\t\t    add_termcode(key_name, arg, FALSE);\n\t\t\t    *p = nextchar;\n\t\t\t}\n\t\t\tif (full_screen)\n\t\t\t    ttest(FALSE);\n\t\t\tredraw_all_later(CLEAR);\n\t\t    }\n\t\t}\n\n\t\tif (opt_idx >= 0)\n\t\t    did_set_option(\n\t\t\t opt_idx, opt_flags, value_is_replaced, value_checked);\n\t    }\n\nskip:\n\t    /*\n\t     * Advance to next argument.\n\t     * - skip until a blank found, taking care of backslashes\n\t     * - skip blanks\n\t     * - skip one \"=val\" argument (for hidden options \":set gfn =xx\")\n\t     */\n\t    for (i = 0; i < 2 ; ++i)\n\t    {\n\t\twhile (*arg != NUL && !VIM_ISWHITE(*arg))\n\t\t    if (*arg++ == '\\\\' && *arg != NUL)\n\t\t\t++arg;\n\t\targ = skipwhite(arg);\n\t\tif (*arg != '=')\n\t\t    break;\n\t    }\n\t}\n\n\tif (errmsg != NULL)\n\t{\n\t    vim_strncpy(IObuff, (char_u *)_(errmsg), IOSIZE - 1);\n\t    i = (int)STRLEN(IObuff) + 2;\n\t    if (i + (arg - startarg) < IOSIZE)\n\t    {\n\t\t// append the argument with the error\n\t\tSTRCAT(IObuff, \": \");\n\t\tmch_memmove(IObuff + i, startarg, (arg - startarg));\n\t\tIObuff[i + (arg - startarg)] = NUL;\n\t    }\n\t    // make sure all characters are printable\n\t    trans_characters(IObuff, IOSIZE);\n\n\t    ++no_wait_return;\t\t// wait_return done later\n\t    emsg((char *)IObuff);\t// show error highlighted\n\t    --no_wait_return;\n\n\t    return FAIL;\n\t}\n\n\targ = skipwhite(arg);\n    }\n\ntheend:\n    if (silent_mode && did_show)\n    {\n\t// After displaying option values in silent mode.\n\tsilent_mode = FALSE;\n\tinfo_message = TRUE;\t// use mch_msg(), not mch_errmsg()\n\tmsg_putchar('\\n');\n\tcursor_on();\t\t// msg_start() switches it off\n\tout_flush();\n\tsilent_mode = TRUE;\n\tinfo_message = FALSE;\t// use mch_msg(), not mch_errmsg()\n    }\n\n    return OK;\n}\n\n/*\n * Call this when an option has been given a new value through a user command.\n * Sets the P_WAS_SET flag and takes care of the P_INSECURE flag.\n */\n    void\ndid_set_option(\n    int\t    opt_idx,\n    int\t    opt_flags,\t    // possibly with OPT_MODELINE\n    int\t    new_value,\t    // value was replaced completely\n    int\t    value_checked)  // value was checked to be safe, no need to set the\n\t\t\t    // P_INSECURE flag.\n{\n    long_u\t*p;\n\n    options[opt_idx].flags |= P_WAS_SET;\n\n    // When an option is set in the sandbox, from a modeline or in secure mode\n    // set the P_INSECURE flag.  Otherwise, if a new value is stored reset the\n    // flag.\n    p = insecure_flag(opt_idx, opt_flags);\n    if (!value_checked && (secure\n#ifdef HAVE_SANDBOX\n\t    || sandbox != 0\n#endif\n\t    || (opt_flags & OPT_MODELINE)))\n\t*p = *p | P_INSECURE;\n    else if (new_value)\n\t*p = *p & ~P_INSECURE;\n}\n\n/*\n * Convert a key name or string into a key value.\n * Used for 'wildchar' and 'cedit' options.\n * When \"multi_byte\" is TRUE allow for multi-byte characters.\n */\n    int\nstring_to_key(char_u *arg, int multi_byte)\n{\n    if (*arg == '<')\n\treturn find_key_option(arg + 1, TRUE);\n    if (*arg == '^')\n\treturn Ctrl_chr(arg[1]);\n    if (multi_byte)\n\treturn PTR2CHAR(arg);\n    return *arg;\n}\n\n/*\n * When changing 'title', 'titlestring', 'icon' or 'iconstring', call\n * maketitle() to create and display it.\n * When switching the title or icon off, call mch_restore_title() to get\n * the old value back.\n */\n    void\ndid_set_title(void)\n{\n    if (starting != NO_SCREEN\n#ifdef FEAT_GUI\n\t    && !gui.starting\n#endif\n\t\t\t\t)\n\tmaketitle();\n}\n\n/*\n * set_options_bin -  called when 'bin' changes value.\n */\n    void\nset_options_bin(\n    int\t\toldval,\n    int\t\tnewval,\n    int\t\topt_flags)\t// OPT_LOCAL and/or OPT_GLOBAL\n{\n    /*\n     * The option values that are changed when 'bin' changes are\n     * copied when 'bin is set and restored when 'bin' is reset.\n     */\n    if (newval)\n    {\n\tif (!oldval)\t\t// switched on\n\t{\n\t    if (!(opt_flags & OPT_GLOBAL))\n\t    {\n\t\tcurbuf->b_p_tw_nobin = curbuf->b_p_tw;\n\t\tcurbuf->b_p_wm_nobin = curbuf->b_p_wm;\n\t\tcurbuf->b_p_ml_nobin = curbuf->b_p_ml;\n\t\tcurbuf->b_p_et_nobin = curbuf->b_p_et;\n\t    }\n\t    if (!(opt_flags & OPT_LOCAL))\n\t    {\n\t\tp_tw_nobin = p_tw;\n\t\tp_wm_nobin = p_wm;\n\t\tp_ml_nobin = p_ml;\n\t\tp_et_nobin = p_et;\n\t    }\n\t}\n\n\tif (!(opt_flags & OPT_GLOBAL))\n\t{\n\t    curbuf->b_p_tw = 0;\t// no automatic line wrap\n\t    curbuf->b_p_wm = 0;\t// no automatic line wrap\n\t    curbuf->b_p_ml = 0;\t// no modelines\n\t    curbuf->b_p_et = 0;\t// no expandtab\n\t}\n\tif (!(opt_flags & OPT_LOCAL))\n\t{\n\t    p_tw = 0;\n\t    p_wm = 0;\n\t    p_ml = FALSE;\n\t    p_et = FALSE;\n\t    p_bin = TRUE;\t// needed when called for the \"-b\" argument\n\t}\n    }\n    else if (oldval)\t\t// switched off\n    {\n\tif (!(opt_flags & OPT_GLOBAL))\n\t{\n\t    curbuf->b_p_tw = curbuf->b_p_tw_nobin;\n\t    curbuf->b_p_wm = curbuf->b_p_wm_nobin;\n\t    curbuf->b_p_ml = curbuf->b_p_ml_nobin;\n\t    curbuf->b_p_et = curbuf->b_p_et_nobin;\n\t}\n\tif (!(opt_flags & OPT_LOCAL))\n\t{\n\t    p_tw = p_tw_nobin;\n\t    p_wm = p_wm_nobin;\n\t    p_ml = p_ml_nobin;\n\t    p_et = p_et_nobin;\n\t}\n    }\n}\n\n/*\n * Expand environment variables for some string options.\n * These string options cannot be indirect!\n * If \"val\" is NULL expand the current value of the option.\n * Return pointer to NameBuff, or NULL when not expanded.\n */\n    static char_u *\noption_expand(int opt_idx, char_u *val)\n{\n    // if option doesn't need expansion nothing to do\n    if (!(options[opt_idx].flags & P_EXPAND) || options[opt_idx].var == NULL)\n\treturn NULL;\n\n    // If val is longer than MAXPATHL no meaningful expansion can be done,\n    // expand_env() would truncate the string.\n    if (val != NULL && STRLEN(val) > MAXPATHL)\n\treturn NULL;\n\n    if (val == NULL)\n\tval = *(char_u **)options[opt_idx].var;\n\n    /*\n     * Expanding this with NameBuff, expand_env() must not be passed IObuff.\n     * Escape spaces when expanding 'tags', they are used to separate file\n     * names.\n     * For 'spellsuggest' expand after \"file:\".\n     */\n    expand_env_esc(val, NameBuff, MAXPATHL,\n\t    (char_u **)options[opt_idx].var == &p_tags, FALSE,\n#ifdef FEAT_SPELL\n\t    (char_u **)options[opt_idx].var == &p_sps ? (char_u *)\"file:\" :\n#endif\n\t\t\t\t  NULL);\n    if (STRCMP(NameBuff, val) == 0)   // they are the same\n\treturn NULL;\n\n    return NameBuff;\n}\n\n/*\n * After setting various option values: recompute variables that depend on\n * option values.\n */\n    static void\ndidset_options(void)\n{\n    // initialize the table for 'iskeyword' et.al.\n    (void)init_chartab();\n\n    didset_string_options();\n\n#ifdef FEAT_SPELL\n    (void)spell_check_msm();\n    (void)spell_check_sps();\n    (void)compile_cap_prog(curwin->w_s);\n    (void)did_set_spell_option(TRUE);\n#endif\n#ifdef FEAT_CMDWIN\n    // set cedit_key\n    (void)check_cedit();\n#endif\n#ifdef FEAT_LINEBREAK\n    // initialize the table for 'breakat'.\n    fill_breakat_flags();\n#endif\n    after_copy_winopt(curwin);\n}\n\n/*\n * More side effects of setting options.\n */\n    static void\ndidset_options2(void)\n{\n    // Initialize the highlight_attr[] table.\n    (void)highlight_changed();\n\n    // Parse default for 'wildmode'\n    check_opt_wim();\n\n    // Parse default for 'listchars'.\n    (void)set_chars_option(curwin, &curwin->w_p_lcs);\n\n    // Parse default for 'fillchars'.\n    (void)set_chars_option(curwin, &p_fcs);\n\n#ifdef FEAT_CLIPBOARD\n    // Parse default for 'clipboard'\n    (void)check_clipboard_option();\n#endif\n#ifdef FEAT_VARTABS\n    vim_free(curbuf->b_p_vsts_array);\n    (void)tabstop_set(curbuf->b_p_vsts, &curbuf->b_p_vsts_array);\n    vim_free(curbuf->b_p_vts_array);\n    (void)tabstop_set(curbuf->b_p_vts,  &curbuf->b_p_vts_array);\n#endif\n}\n\n/*\n * Check for string options that are NULL (normally only termcap options).\n */\n    void\ncheck_options(void)\n{\n    int\t\topt_idx;\n\n    for (opt_idx = 0; options[opt_idx].fullname != NULL; opt_idx++)\n\tif ((options[opt_idx].flags & P_STRING) && options[opt_idx].var != NULL)\n\t    check_string_option((char_u **)get_varp(&(options[opt_idx])));\n}\n\n/*\n * Return the option index found by a pointer into term_strings[].\n * Return -1 if not found.\n */\n    int\nget_term_opt_idx(char_u **p)\n{\n    int opt_idx;\n\n    for (opt_idx = 1; options[opt_idx].fullname != NULL; opt_idx++)\n\tif (options[opt_idx].var == (char_u *)p)\n\t    return opt_idx;\n    return -1; // cannot happen: didn't find it!\n}\n\n/*\n * Mark a terminal option as allocated, found by a pointer into term_strings[].\n * Return the option index or -1 if not found.\n */\n    int\nset_term_option_alloced(char_u **p)\n{\n    int\t\topt_idx = get_term_opt_idx(p);\n\n    if (opt_idx >= 0)\n\toptions[opt_idx].flags |= P_ALLOCED;\n    return opt_idx;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE when option \"opt\" was set from a modeline or in secure mode.\n * Return FALSE when it wasn't.\n * Return -1 for an unknown option.\n */\n    int\nwas_set_insecurely(char_u *opt, int opt_flags)\n{\n    int\t    idx = findoption(opt);\n    long_u  *flagp;\n\n    if (idx >= 0)\n    {\n\tflagp = insecure_flag(idx, opt_flags);\n\treturn (*flagp & P_INSECURE) != 0;\n    }\n    internal_error(\"was_set_insecurely()\");\n    return -1;\n}\n\n/*\n * Get a pointer to the flags used for the P_INSECURE flag of option\n * \"opt_idx\".  For some local options a local flags field is used.\n * NOTE: Caller must make sure that \"curwin\" is set to the window from which\n * the option is used.\n */\n    static long_u *\ninsecure_flag(int opt_idx, int opt_flags)\n{\n    if (opt_flags & OPT_LOCAL)\n\tswitch ((int)options[opt_idx].indir)\n\t{\n#ifdef FEAT_STL_OPT\n\t    case PV_STL:\treturn &curwin->w_p_stl_flags;\n#endif\n#ifdef FEAT_EVAL\n# ifdef FEAT_FOLDING\n\t    case PV_FDE:\treturn &curwin->w_p_fde_flags;\n\t    case PV_FDT:\treturn &curwin->w_p_fdt_flags;\n# endif\n# ifdef FEAT_BEVAL\n\t    case PV_BEXPR:\treturn &curbuf->b_p_bexpr_flags;\n# endif\n# if defined(FEAT_CINDENT)\n\t    case PV_INDE:\treturn &curbuf->b_p_inde_flags;\n# endif\n\t    case PV_FEX:\treturn &curbuf->b_p_fex_flags;\n# ifdef FEAT_FIND_ID\n\t    case PV_INEX:\treturn &curbuf->b_p_inex_flags;\n# endif\n#endif\n\t}\n\n    // Nothing special, return global flags field.\n    return &options[opt_idx].flags;\n}\n#endif\n\n/*\n * Redraw the window title and/or tab page text later.\n */\nvoid redraw_titles(void)\n{\n    need_maketitle = TRUE;\n    redraw_tabline = TRUE;\n}\n\n/*\n * Return TRUE if \"val\" is a valid name: only consists of alphanumeric ASCII\n * characters or characters in \"allowed\".\n */\n    int\nvalid_name(char_u *val, char *allowed)\n{\n    char_u *s;\n\n    for (s = val; *s != NUL; ++s)\n\tif (!ASCII_ISALNUM(*s) && vim_strchr((char_u *)allowed, *s) == NULL)\n\t    return FALSE;\n    return TRUE;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Set the script_ctx for an option, taking care of setting the buffer- or\n * window-local value.\n */\n    void\nset_option_sctx_idx(int opt_idx, int opt_flags, sctx_T script_ctx)\n{\n    int\t\tboth = (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0;\n    int\t\tindir = (int)options[opt_idx].indir;\n    sctx_T\tnew_script_ctx = script_ctx;\n\n    // Modeline already has the line number set.\n    if (!(opt_flags & OPT_MODELINE))\n\tnew_script_ctx.sc_lnum += SOURCING_LNUM;\n\n    // Remember where the option was set.  For local options need to do that\n    // in the buffer or window structure.\n    if (both || (opt_flags & OPT_GLOBAL) || (indir & (PV_BUF|PV_WIN)) == 0)\n\toptions[opt_idx].script_ctx = new_script_ctx;\n    if (both || (opt_flags & OPT_LOCAL))\n    {\n\tif (indir & PV_BUF)\n\t    curbuf->b_p_script_ctx[indir & PV_MASK] = new_script_ctx;\n\telse if (indir & PV_WIN)\n\t{\n\t    curwin->w_p_script_ctx[indir & PV_MASK] = new_script_ctx;\n\t    if (both)\n\t\t// also setting the \"all buffers\" value\n\t\tcurwin->w_allbuf_opt.wo_script_ctx[indir & PV_MASK] =\n\t\t\t\t\t\t\t\tnew_script_ctx;\n\t}\n    }\n}\n\n/*\n * Get the script context of global option \"name\".\n *\n */\n    sctx_T *\nget_option_sctx(char *name)\n{\n    int idx = findoption((char_u *)name);\n\n    if (idx >= 0)\n\treturn &options[idx].script_ctx;\n    siemsg(\"no such option: %s\", name);\n    return NULL;\n}\n\n/*\n * Set the script_ctx for a termcap option.\n * \"name\" must be the two character code, e.g. \"RV\".\n * When \"name\" is NULL use \"opt_idx\".\n */\n    void\nset_term_option_sctx_idx(char *name, int opt_idx)\n{\n    char_u  buf[5];\n    int\t    idx;\n\n    if (name == NULL)\n\tidx = opt_idx;\n    else\n    {\n\tbuf[0] = 't';\n\tbuf[1] = '_';\n\tbuf[2] = name[0];\n\tbuf[3] = name[1];\n\tbuf[4] = 0;\n\tidx = findoption(buf);\n    }\n    if (idx >= 0)\n\tset_option_sctx_idx(idx, OPT_GLOBAL, current_sctx);\n}\n#endif\n\n#if defined(FEAT_EVAL)\n/*\n * Apply the OptionSet autocommand.\n */\n    static void\napply_optionset_autocmd(\n\tint\topt_idx,\n\tlong\topt_flags,\n\tlong\toldval,\n\tlong\toldval_g,\n\tlong\tnewval,\n\tchar\t*errmsg)\n{\n    char_u buf_old[12], buf_old_global[12], buf_new[12], buf_type[12];\n\n    // Don't do this while starting up, failure or recursively.\n    if (starting || errmsg != NULL || *get_vim_var_str(VV_OPTION_TYPE) != NUL)\n\treturn;\n\n    vim_snprintf((char *)buf_old, sizeof(buf_old), \"%ld\", oldval);\n    vim_snprintf((char *)buf_old_global, sizeof(buf_old_global), \"%ld\",\n\t\t\t\t\t\t\toldval_g);\n    vim_snprintf((char *)buf_new, sizeof(buf_new), \"%ld\", newval);\n    vim_snprintf((char *)buf_type, sizeof(buf_type), \"%s\",\n\t\t\t\t(opt_flags & OPT_LOCAL) ? \"local\" : \"global\");\n    set_vim_var_string(VV_OPTION_NEW, buf_new, -1);\n    set_vim_var_string(VV_OPTION_OLD, buf_old, -1);\n    set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);\n    if (opt_flags & OPT_LOCAL)\n    {\n\tset_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"setlocal\", -1);\n\tset_vim_var_string(VV_OPTION_OLDLOCAL, buf_old, -1);\n    }\n    if (opt_flags & OPT_GLOBAL)\n    {\n\tset_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"setglobal\", -1);\n\tset_vim_var_string(VV_OPTION_OLDGLOBAL, buf_old, -1);\n    }\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n    {\n\tset_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"set\", -1);\n\tset_vim_var_string(VV_OPTION_OLDLOCAL, buf_old, -1);\n\tset_vim_var_string(VV_OPTION_OLDGLOBAL, buf_old_global, -1);\n    }\n    if (opt_flags & OPT_MODELINE)\n    {\n\tset_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"modeline\", -1);\n\tset_vim_var_string(VV_OPTION_OLDLOCAL, buf_old, -1);\n    }\n    apply_autocmds(EVENT_OPTIONSET, (char_u *)options[opt_idx].fullname,\n\t    NULL, FALSE, NULL);\n    reset_v_option_vars();\n}\n#endif\n\n/*\n * Set the value of a boolean option, and take care of side effects.\n * Returns NULL for success, or an error message for an error.\n */\n    static char *\nset_bool_option(\n    int\t\topt_idx,\t\t// index in options[] table\n    char_u\t*varp,\t\t\t// pointer to the option variable\n    int\t\tvalue,\t\t\t// new value\n    int\t\topt_flags)\t\t// OPT_LOCAL and/or OPT_GLOBAL\n{\n    int\t\told_value = *(int *)varp;\n#if defined(FEAT_EVAL)\n    int\t\told_global_value = 0;\n#endif\n\n    // Disallow changing some options from secure mode\n    if ((secure\n#ifdef HAVE_SANDBOX\n\t\t|| sandbox != 0\n#endif\n\t\t) && (options[opt_idx].flags & P_SECURE))\n\treturn e_not_allowed_here;\n\n#if defined(FEAT_EVAL)\n    // Save the global value before changing anything. This is needed as for\n    // a global-only option setting the \"local value\" in fact sets the global\n    // value (since there is only one value).\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\told_global_value = *(int *)get_varp_scope(&(options[opt_idx]),\n\t\t\t\t\t\t\t\t   OPT_GLOBAL);\n#endif\n\n    *(int *)varp = value;\t    // set the new value\n#ifdef FEAT_EVAL\n    // Remember where the option was set.\n    set_option_sctx_idx(opt_idx, opt_flags, current_sctx);\n#endif\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    // May set global value for local option.\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\t*(int *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) = value;\n\n    /*\n     * Handle side effects of changing a bool option.\n     */\n\n    // 'compatible'\n    if ((int *)varp == &p_cp)\n\tcompatible_set();\n\n#ifdef FEAT_LANGMAP\n    if ((int *)varp == &p_lrm)\n\t// 'langremap' -> !'langnoremap'\n\tp_lnr = !p_lrm;\n    else if ((int *)varp == &p_lnr)\n\t// 'langnoremap' -> !'langremap'\n\tp_lrm = !p_lnr;\n#endif\n\n#ifdef FEAT_SYN_HL\n    else if ((int *)varp == &curwin->w_p_cul && !value && old_value)\n\treset_cursorline();\n#endif\n\n#ifdef FEAT_PERSISTENT_UNDO\n    // 'undofile'\n    else if ((int *)varp == &curbuf->b_p_udf || (int *)varp == &p_udf)\n    {\n\t// Only take action when the option was set. When reset we do not\n\t// delete the undo file, the option may be set again without making\n\t// any changes in between.\n\tif (curbuf->b_p_udf || p_udf)\n\t{\n\t    char_u\thash[UNDO_HASH_SIZE];\n\t    buf_T\t*save_curbuf = curbuf;\n\n\t    FOR_ALL_BUFFERS(curbuf)\n\t    {\n\t\t// When 'undofile' is set globally: for every buffer, otherwise\n\t\t// only for the current buffer: Try to read in the undofile,\n\t\t// if one exists, the buffer wasn't changed and the buffer was\n\t\t// loaded\n\t\tif ((curbuf == save_curbuf\n\t\t\t\t|| (opt_flags & OPT_GLOBAL) || opt_flags == 0)\n\t\t\t&& !curbufIsChanged() && curbuf->b_ml.ml_mfp != NULL)\n\t\t{\n#ifdef FEAT_CRYPT\n\t\t    if (crypt_get_method_nr(curbuf) == CRYPT_M_SOD)\n\t\t\tcontinue;\n#endif\n\t\t    u_compute_hash(hash);\n\t\t    u_read_undo(NULL, hash, curbuf->b_fname);\n\t\t}\n\t    }\n\t    curbuf = save_curbuf;\n\t}\n    }\n#endif\n\n    else if ((int *)varp == &curbuf->b_p_ro)\n    {\n\t// when 'readonly' is reset globally, also reset readonlymode\n\tif (!curbuf->b_p_ro && (opt_flags & OPT_LOCAL) == 0)\n\t    readonlymode = FALSE;\n\n\t// when 'readonly' is set may give W10 again\n\tif (curbuf->b_p_ro)\n\t    curbuf->b_did_warn = FALSE;\n\n\tredraw_titles();\n    }\n\n#ifdef FEAT_GUI\n    else if ((int *)varp == &p_mh)\n    {\n\tif (!p_mh)\n\t    gui_mch_mousehide(FALSE);\n    }\n#endif\n\n    // when 'modifiable' is changed, redraw the window title\n    else if ((int *)varp == &curbuf->b_p_ma)\n    {\n# ifdef FEAT_TERMINAL\n\t// Cannot set 'modifiable' when in Terminal mode.\n\tif (curbuf->b_p_ma && (term_in_normal_mode() || (bt_terminal(curbuf)\n\t\t      && curbuf->b_term != NULL && !term_is_finished(curbuf))))\n\t{\n\t    curbuf->b_p_ma = FALSE;\n\t    return N_(e_cannot_make_terminal_with_running_job_modifiable);\n\t}\n# endif\n\tredraw_titles();\n    }\n    // when 'endofline' is changed, redraw the window title\n    else if ((int *)varp == &curbuf->b_p_eol)\n    {\n\tredraw_titles();\n    }\n    // when 'fixeol' is changed, redraw the window title\n    else if ((int *)varp == &curbuf->b_p_fixeol)\n    {\n\tredraw_titles();\n    }\n    // when 'bomb' is changed, redraw the window title and tab page text\n    else if ((int *)varp == &curbuf->b_p_bomb)\n    {\n\tredraw_titles();\n    }\n\n    // when 'bin' is set also set some other options\n    else if ((int *)varp == &curbuf->b_p_bin)\n    {\n\tset_options_bin(old_value, curbuf->b_p_bin, opt_flags);\n\tredraw_titles();\n    }\n\n    // when 'buflisted' changes, trigger autocommands\n    else if ((int *)varp == &curbuf->b_p_bl && old_value != curbuf->b_p_bl)\n    {\n\tapply_autocmds(curbuf->b_p_bl ? EVENT_BUFADD : EVENT_BUFDELETE,\n\t\t\t\t\t\t    NULL, NULL, TRUE, curbuf);\n    }\n\n    // when 'swf' is set, create swapfile, when reset remove swapfile\n    else if ((int *)varp == &curbuf->b_p_swf)\n    {\n\tif (curbuf->b_p_swf && p_uc)\n\t    ml_open_file(curbuf);\t\t// create the swap file\n\telse\n\t    // no need to reset curbuf->b_may_swap, ml_open_file() will check\n\t    // buf->b_p_swf\n\t    mf_close_file(curbuf, TRUE);\t// remove the swap file\n    }\n\n    // when 'terse' is set change 'shortmess'\n    else if ((int *)varp == &p_terse)\n    {\n\tchar_u\t*p;\n\n\tp = vim_strchr(p_shm, SHM_SEARCH);\n\n\t// insert 's' in p_shm\n\tif (p_terse && p == NULL)\n\t{\n\t    STRCPY(IObuff, p_shm);\n\t    STRCAT(IObuff, \"s\");\n\t    set_string_option_direct((char_u *)\"shm\", -1, IObuff, OPT_FREE, 0);\n\t}\n\t// remove 's' from p_shm\n\telse if (!p_terse && p != NULL)\n\t    STRMOVE(p, p + 1);\n    }\n\n    // when 'paste' is set or reset also change other options\n    else if ((int *)varp == &p_paste)\n    {\n\tpaste_option_changed();\n    }\n\n    // when 'insertmode' is set from an autocommand need to do work here\n    else if ((int *)varp == &p_im)\n    {\n\tif (p_im)\n\t{\n\t    if ((State & INSERT) == 0)\n\t\tneed_start_insertmode = TRUE;\n\t    stop_insert_mode = FALSE;\n\t}\n\t// only reset if it was set previously\n\telse if (old_value)\n\t{\n\t    need_start_insertmode = FALSE;\n\t    stop_insert_mode = TRUE;\n\t    if (restart_edit != 0 && mode_displayed)\n\t\tclear_cmdline = TRUE;\t// remove \"(insert)\"\n\t    restart_edit = 0;\n\t}\n    }\n\n    // when 'ignorecase' is set or reset and 'hlsearch' is set, redraw\n    else if ((int *)varp == &p_ic && p_hls)\n    {\n\tredraw_all_later(SOME_VALID);\n    }\n\n#ifdef FEAT_SEARCH_EXTRA\n    // when 'hlsearch' is set or reset: reset no_hlsearch\n    else if ((int *)varp == &p_hls)\n    {\n\tset_no_hlsearch(FALSE);\n    }\n#endif\n\n    // when 'scrollbind' is set: snapshot the current position to avoid a jump\n    // at the end of normal_cmd()\n    else if ((int *)varp == &curwin->w_p_scb)\n    {\n\tif (curwin->w_p_scb)\n\t{\n\t    do_check_scrollbind(FALSE);\n\t    curwin->w_scbind_pos = curwin->w_topline;\n\t}\n    }\n\n#if defined(FEAT_QUICKFIX)\n    // There can be only one window with 'previewwindow' set.\n    else if ((int *)varp == &curwin->w_p_pvw)\n    {\n\tif (curwin->w_p_pvw)\n\t{\n\t    win_T\t*win;\n\n\t    FOR_ALL_WINDOWS(win)\n\t\tif (win->w_p_pvw && win != curwin)\n\t\t{\n\t\t    curwin->w_p_pvw = FALSE;\n\t\t    return N_(e_preview_window_already_exists);\n\t\t}\n\t}\n    }\n#endif\n\n    // when 'textmode' is set or reset also change 'fileformat'\n    else if ((int *)varp == &curbuf->b_p_tx)\n    {\n\tset_fileformat(curbuf->b_p_tx ? EOL_DOS : EOL_UNIX, opt_flags);\n    }\n\n    // when 'textauto' is set or reset also change 'fileformats'\n    else if ((int *)varp == &p_ta)\n    {\n\tset_string_option_direct((char_u *)\"ffs\", -1,\n\t\t\t\t p_ta ? (char_u *)DFLT_FFS_VIM : (char_u *)\"\",\n\t\t\t\t\t\t     OPT_FREE | opt_flags, 0);\n    }\n\n    /*\n     * When 'lisp' option changes include/exclude '-' in\n     * keyword characters.\n     */\n#ifdef FEAT_LISP\n    else if (varp == (char_u *)&(curbuf->b_p_lisp))\n    {\n\t(void)buf_init_chartab(curbuf, FALSE);\t    // ignore errors\n    }\n#endif\n\n    // when 'title' changed, may need to change the title; same for 'icon'\n    else if ((int *)varp == &p_title || (int *)varp == &p_icon)\n    {\n\tdid_set_title();\n    }\n\n    else if ((int *)varp == &curbuf->b_changed)\n    {\n\tif (!value)\n\t    save_file_ff(curbuf);\t// Buffer is unchanged\n\tredraw_titles();\n\tmodified_was_set = value;\n    }\n\n#ifdef BACKSLASH_IN_FILENAME\n    else if ((int *)varp == &p_ssl)\n    {\n\tif (p_ssl)\n\t{\n\t    psepc = '/';\n\t    psepcN = '\\\\';\n\t    pseps[0] = '/';\n\t}\n\telse\n\t{\n\t    psepc = '\\\\';\n\t    psepcN = '/';\n\t    pseps[0] = '\\\\';\n\t}\n\n\t// need to adjust the file name arguments and buffer names.\n\tbuflist_slash_adjust();\n\talist_slash_adjust();\n# ifdef FEAT_EVAL\n\tscriptnames_slash_adjust();\n# endif\n    }\n#endif\n\n    // If 'wrap' is set, set w_leftcol to zero.\n    else if ((int *)varp == &curwin->w_p_wrap)\n    {\n\tif (curwin->w_p_wrap)\n\t    curwin->w_leftcol = 0;\n    }\n\n    else if ((int *)varp == &p_ea)\n    {\n\tif (p_ea && !old_value)\n\t    win_equal(curwin, FALSE, 0);\n    }\n\n    else if ((int *)varp == &p_wiv)\n    {\n\t/*\n\t * When 'weirdinvert' changed, set/reset 't_xs'.\n\t * Then set 'weirdinvert' according to value of 't_xs'.\n\t */\n\tif (p_wiv && !old_value)\n\t    T_XS = (char_u *)\"y\";\n\telse if (!p_wiv && old_value)\n\t    T_XS = empty_option;\n\tp_wiv = (*T_XS != NUL);\n    }\n\n#ifdef FEAT_BEVAL_GUI\n    else if ((int *)varp == &p_beval)\n    {\n\tif (!balloonEvalForTerm)\n\t{\n\t    if (p_beval && !old_value)\n\t\tgui_mch_enable_beval_area(balloonEval);\n\t    else if (!p_beval && old_value)\n\t\tgui_mch_disable_beval_area(balloonEval);\n\t}\n    }\n#endif\n#ifdef FEAT_BEVAL_TERM\n    else if ((int *)varp == &p_bevalterm)\n    {\n\tmch_bevalterm_changed();\n    }\n#endif\n\n#ifdef FEAT_AUTOCHDIR\n    else if ((int *)varp == &p_acd)\n    {\n\t// Change directories when the 'acd' option is set now.\n\tDO_AUTOCHDIR;\n    }\n#endif\n\n#ifdef FEAT_DIFF\n    // 'diff'\n    else if ((int *)varp == &curwin->w_p_diff)\n    {\n\t// May add or remove the buffer from the list of diff buffers.\n\tdiff_buf_adjust(curwin);\n# ifdef FEAT_FOLDING\n\tif (foldmethodIsDiff(curwin))\n\t    foldUpdateAll(curwin);\n# endif\n    }\n#endif\n\n#ifdef HAVE_INPUT_METHOD\n    // 'imdisable'\n    else if ((int *)varp == &p_imdisable)\n    {\n\t// Only de-activate it here, it will be enabled when changing mode.\n\tif (p_imdisable)\n\t    im_set_active(FALSE);\n\telse if (State & INSERT)\n\t    // When the option is set from an autocommand, it may need to take\n\t    // effect right away.\n\t    im_set_active(curbuf->b_p_iminsert == B_IMODE_IM);\n    }\n#endif\n\n#ifdef FEAT_SPELL\n    // 'spell'\n    else if ((int *)varp == &curwin->w_p_spell)\n    {\n\tif (curwin->w_p_spell)\n\t{\n\t    char\t*errmsg = did_set_spelllang(curwin);\n\n\t    if (errmsg != NULL)\n\t\temsg(_(errmsg));\n\t}\n    }\n#endif\n\n#ifdef FEAT_ARABIC\n    if ((int *)varp == &curwin->w_p_arab)\n    {\n\tif (curwin->w_p_arab)\n\t{\n\t    /*\n\t     * 'arabic' is set, handle various sub-settings.\n\t     */\n\t    if (!p_tbidi)\n\t    {\n\t\t// set rightleft mode\n\t\tif (!curwin->w_p_rl)\n\t\t{\n\t\t    curwin->w_p_rl = TRUE;\n\t\t    changed_window_setting();\n\t\t}\n\n\t\t// Enable Arabic shaping (major part of what Arabic requires)\n\t\tif (!p_arshape)\n\t\t{\n\t\t    p_arshape = TRUE;\n\t\t    redraw_later_clear();\n\t\t}\n\t    }\n\n\t    // Arabic requires a utf-8 encoding, inform the user if it's not\n\t    // set.\n\t    if (STRCMP(p_enc, \"utf-8\") != 0)\n\t    {\n\t\tstatic char *w_arabic = N_(\"W17: Arabic requires UTF-8, do ':set encoding=utf-8'\");\n\n\t\tmsg_source(HL_ATTR(HLF_W));\n\t\tmsg_attr(_(w_arabic), HL_ATTR(HLF_W));\n#ifdef FEAT_EVAL\n\t\tset_vim_var_string(VV_WARNINGMSG, (char_u *)_(w_arabic), -1);\n#endif\n\t    }\n\n\t    // set 'delcombine'\n\t    p_deco = TRUE;\n\n# ifdef FEAT_KEYMAP\n\t    // Force-set the necessary keymap for arabic\n\t    set_option_value((char_u *)\"keymap\", 0L, (char_u *)\"arabic\",\n\t\t\t\t\t\t\t\t   OPT_LOCAL);\n# endif\n\t}\n\telse\n\t{\n\t    /*\n\t     * 'arabic' is reset, handle various sub-settings.\n\t     */\n\t    if (!p_tbidi)\n\t    {\n\t\t// reset rightleft mode\n\t\tif (curwin->w_p_rl)\n\t\t{\n\t\t    curwin->w_p_rl = FALSE;\n\t\t    changed_window_setting();\n\t\t}\n\n\t\t// 'arabicshape' isn't reset, it is a global option and\n\t\t// another window may still need it \"on\".\n\t    }\n\n\t    // 'delcombine' isn't reset, it is a global option and another\n\t    // window may still want it \"on\".\n\n# ifdef FEAT_KEYMAP\n\t    // Revert to the default keymap\n\t    curbuf->b_p_iminsert = B_IMODE_NONE;\n\t    curbuf->b_p_imsearch = B_IMODE_USE_INSERT;\n# endif\n\t}\n    }\n\n#endif\n\n#if defined(FEAT_SIGNS) && defined(FEAT_GUI)\n    else if (((int *)varp == &curwin->w_p_nu\n\t\t|| (int *)varp == &curwin->w_p_rnu)\n\t    && gui.in_use\n\t    && (*curwin->w_p_scl == 'n' && *(curwin->w_p_scl + 1) == 'u')\n\t    && curbuf->b_signlist != NULL)\n    {\n\t// If the 'number' or 'relativenumber' options are modified and\n\t// 'signcolumn' is set to 'number', then clear the screen for a full\n\t// refresh. Otherwise the sign icons are not displayed properly in the\n\t// number column.  If the 'number' option is set and only the\n\t// 'relativenumber' option is toggled, then don't refresh the screen\n\t// (optimization).\n\tif (!(curwin->w_p_nu && ((int *)varp == &curwin->w_p_rnu)))\n\t    redraw_all_later(CLEAR);\n    }\n#endif\n\n#ifdef FEAT_TERMGUICOLORS\n    // 'termguicolors'\n    else if ((int *)varp == &p_tgc)\n    {\n# ifdef FEAT_VTP\n\t// Do not turn on 'tgc' when 24-bit colors are not supported.\n\tif (\n#  ifdef VIMDLL\n\t    !gui.in_use && !gui.starting &&\n#  endif\n\t    !has_vtp_working())\n\t{\n\t    p_tgc = 0;\n\t    return N_(e_24_bit_colors_are_not_supported_on_this_environment);\n\t}\n\tif (is_term_win32())\n\t    swap_tcap();\n# endif\n# ifdef FEAT_GUI\n\tif (!gui.in_use && !gui.starting)\n# endif\n\t    highlight_gui_started();\n# ifdef FEAT_VTP\n\t// reset t_Co\n\tif (is_term_win32())\n\t{\n\t    control_console_color_rgb();\n\t    set_termname(T_NAME);\n\t    init_highlight(TRUE, FALSE);\n\t}\n# endif\n# ifdef FEAT_TERMINAL\n\tterm_update_colors_all();\n\tterm_update_wincolor_all();\n# endif\n    }\n#endif\n\n    /*\n     * End of handling side effects for bool options.\n     */\n\n    // after handling side effects, call autocommand\n\n    options[opt_idx].flags |= P_WAS_SET;\n\n#if defined(FEAT_EVAL)\n    apply_optionset_autocmd(opt_idx, opt_flags,\n\t\t\t\t(long)(old_value ? TRUE : FALSE),\n\t\t\t\t(long)(old_global_value ? TRUE : FALSE),\n\t\t\t\t(long)(value ? TRUE : FALSE), NULL);\n#endif\n\n    comp_col();\t\t\t    // in case 'ruler' or 'showcmd' changed\n    if (curwin->w_curswant != MAXCOL\n\t\t     && (options[opt_idx].flags & (P_CURSWANT | P_RALL)) != 0)\n\tcurwin->w_set_curswant = TRUE;\n\n    if ((opt_flags & OPT_NO_REDRAW) == 0)\n\tcheck_redraw(options[opt_idx].flags);\n\n    return NULL;\n}\n\n/*\n * Set the value of a number option, and take care of side effects.\n * Returns NULL for success, or an error message for an error.\n */\n    static char *\nset_num_option(\n    int\t\topt_idx,\t\t// index in options[] table\n    char_u\t*varp,\t\t\t// pointer to the option variable\n    long\tvalue,\t\t\t// new value\n    char\t*errbuf,\t\t// buffer for error messages\n    size_t\terrbuflen,\t\t// length of \"errbuf\"\n    int\t\topt_flags)\t\t// OPT_LOCAL, OPT_GLOBAL,\n\t\t\t\t\t// OPT_MODELINE, etc.\n{\n    char\t*errmsg = NULL;\n    long\told_value = *(long *)varp;\n#if defined(FEAT_EVAL)\n    long\told_global_value = 0;\t// only used when setting a local and\n\t\t\t\t\t// global option\n#endif\n    long\told_Rows = Rows;\t// remember old Rows\n    long\told_Columns = Columns;\t// remember old Columns\n    long\t*pp = (long *)varp;\n\n    // Disallow changing some options from secure mode.\n    if ((secure\n#ifdef HAVE_SANDBOX\n\t\t|| sandbox != 0\n#endif\n\t\t) && (options[opt_idx].flags & P_SECURE))\n\treturn e_not_allowed_here;\n\n#if defined(FEAT_EVAL)\n    // Save the global value before changing anything. This is needed as for\n    // a global-only option setting the \"local value\" in fact sets the global\n    // value (since there is only one value).\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\told_global_value = *(long *)get_varp_scope(&(options[opt_idx]),\n\t\t\t\t\t\t\t\t   OPT_GLOBAL);\n#endif\n\n    *pp = value;\n#ifdef FEAT_EVAL\n    // Remember where the option was set.\n    set_option_sctx_idx(opt_idx, opt_flags, current_sctx);\n#endif\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    if (curbuf->b_p_sw < 0)\n    {\n\terrmsg = e_argument_must_be_positive;\n#ifdef FEAT_VARTABS\n\t// Use the first 'vartabstop' value, or 'tabstop' if vts isn't in use.\n\tcurbuf->b_p_sw = tabstop_count(curbuf->b_p_vts_array) > 0\n\t               ? tabstop_first(curbuf->b_p_vts_array)\n\t\t       : curbuf->b_p_ts;\n#else\n\tcurbuf->b_p_sw = curbuf->b_p_ts;\n#endif\n    }\n\n    /*\n     * Number options that need some action when changed\n     */\n    if (pp == &p_wh || pp == &p_hh)\n    {\n\t// 'winheight' and 'helpheight'\n\tif (p_wh < 1)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_wh = 1;\n\t}\n\tif (p_wmh > p_wh)\n\t{\n\t    errmsg = e_winheight_cannot_be_smaller_than_winminheight;\n\t    p_wh = p_wmh;\n\t}\n\tif (p_hh < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_hh = 0;\n\t}\n\n\t// Change window height NOW\n\tif (!ONE_WINDOW)\n\t{\n\t    if (pp == &p_wh && curwin->w_height < p_wh)\n\t\twin_setheight((int)p_wh);\n\t    if (pp == &p_hh && curbuf->b_help && curwin->w_height < p_hh)\n\t\twin_setheight((int)p_hh);\n\t}\n    }\n    else if (pp == &p_wmh)\n    {\n\t// 'winminheight'\n\tif (p_wmh < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_wmh = 0;\n\t}\n\tif (p_wmh > p_wh)\n\t{\n\t    errmsg = e_winheight_cannot_be_smaller_than_winminheight;\n\t    p_wmh = p_wh;\n\t}\n\twin_setminheight();\n    }\n    else if (pp == &p_wiw)\n    {\n\t// 'winwidth'\n\tif (p_wiw < 1)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_wiw = 1;\n\t}\n\tif (p_wmw > p_wiw)\n\t{\n\t    errmsg = e_winwidth_cannot_be_smaller_than_winminwidth;\n\t    p_wiw = p_wmw;\n\t}\n\n\t// Change window width NOW\n\tif (!ONE_WINDOW && curwin->w_width < p_wiw)\n\t    win_setwidth((int)p_wiw);\n    }\n    else if (pp == &p_wmw)\n    {\n\t// 'winminwidth'\n\tif (p_wmw < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_wmw = 0;\n\t}\n\tif (p_wmw > p_wiw)\n\t{\n\t    errmsg = e_winwidth_cannot_be_smaller_than_winminwidth;\n\t    p_wmw = p_wiw;\n\t}\n\twin_setminwidth();\n    }\n\n    // (re)set last window status line\n    else if (pp == &p_ls)\n    {\n\tlast_status(FALSE);\n    }\n\n    // (re)set tab page line\n    else if (pp == &p_stal)\n    {\n\tshell_new_rows();\t// recompute window positions and heights\n    }\n\n#ifdef FEAT_GUI\n    else if (pp == &p_linespace)\n    {\n\t// Recompute gui.char_height and resize the Vim window to keep the\n\t// same number of lines.\n\tif (gui.in_use && gui_mch_adjust_charheight() == OK)\n\t    gui_set_shellsize(FALSE, FALSE, RESIZE_VERT);\n    }\n#endif\n\n#ifdef FEAT_FOLDING\n    // 'foldlevel'\n    else if (pp == &curwin->w_p_fdl)\n    {\n\tif (curwin->w_p_fdl < 0)\n\t    curwin->w_p_fdl = 0;\n\tnewFoldLevel();\n    }\n\n    // 'foldminlines'\n    else if (pp == &curwin->w_p_fml)\n    {\n\tfoldUpdateAll(curwin);\n    }\n\n    // 'foldnestmax'\n    else if (pp == &curwin->w_p_fdn)\n    {\n\tif (foldmethodIsSyntax(curwin) || foldmethodIsIndent(curwin))\n\t    foldUpdateAll(curwin);\n    }\n\n    // 'foldcolumn'\n    else if (pp == &curwin->w_p_fdc)\n    {\n\tif (curwin->w_p_fdc < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    curwin->w_p_fdc = 0;\n\t}\n\telse if (curwin->w_p_fdc > 12)\n\t{\n\t    errmsg = e_invalid_argument;\n\t    curwin->w_p_fdc = 12;\n\t}\n    }\n#endif // FEAT_FOLDING\n\n#if defined(FEAT_FOLDING) || defined(FEAT_CINDENT)\n    // 'shiftwidth' or 'tabstop'\n    else if (pp == &curbuf->b_p_sw || pp == &curbuf->b_p_ts)\n    {\n# ifdef FEAT_FOLDING\n\tif (foldmethodIsIndent(curwin))\n\t    foldUpdateAll(curwin);\n# endif\n# ifdef FEAT_CINDENT\n\t// When 'shiftwidth' changes, or it's zero and 'tabstop' changes:\n\t// parse 'cinoptions'.\n\tif (pp == &curbuf->b_p_sw || curbuf->b_p_sw == 0)\n\t    parse_cino(curbuf);\n# endif\n    }\n#endif\n\n    // 'maxcombine'\n    else if (pp == &p_mco)\n    {\n\tif (p_mco > MAX_MCO)\n\t    p_mco = MAX_MCO;\n\telse if (p_mco < 0)\n\t    p_mco = 0;\n\tscreenclear();\t    // will re-allocate the screen\n    }\n\n    else if (pp == &curbuf->b_p_iminsert)\n    {\n\tif (curbuf->b_p_iminsert < 0 || curbuf->b_p_iminsert > B_IMODE_LAST)\n\t{\n\t    errmsg = e_invalid_argument;\n\t    curbuf->b_p_iminsert = B_IMODE_NONE;\n\t}\n\tp_iminsert = curbuf->b_p_iminsert;\n\tif (termcap_active)\t// don't do this in the alternate screen\n\t    showmode();\n#if defined(FEAT_KEYMAP)\n\t// Show/unshow value of 'keymap' in status lines.\n\tstatus_redraw_curbuf();\n#endif\n    }\n\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n    // 'imstyle'\n    else if (pp == &p_imst)\n    {\n\tif (p_imst != IM_ON_THE_SPOT && p_imst != IM_OVER_THE_SPOT)\n\t    errmsg = e_invalid_argument;\n    }\n#endif\n\n    else if (pp == &p_window)\n    {\n\tif (p_window < 1)\n\t    p_window = 1;\n\telse if (p_window >= Rows)\n\t    p_window = Rows - 1;\n    }\n\n    else if (pp == &curbuf->b_p_imsearch)\n    {\n\tif (curbuf->b_p_imsearch < -1 || curbuf->b_p_imsearch > B_IMODE_LAST)\n\t{\n\t    errmsg = e_invalid_argument;\n\t    curbuf->b_p_imsearch = B_IMODE_NONE;\n\t}\n\tp_imsearch = curbuf->b_p_imsearch;\n    }\n\n    // if 'titlelen' has changed, redraw the title\n    else if (pp == &p_titlelen)\n    {\n\tif (p_titlelen < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_titlelen = 85;\n\t}\n\tif (starting != NO_SCREEN && old_value != p_titlelen)\n\t    need_maketitle = TRUE;\n    }\n\n    // if p_ch changed value, change the command line height\n    else if (pp == &p_ch)\n    {\n\tif (p_ch < 1)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_ch = 1;\n\t}\n\tif (p_ch > Rows - min_rows() + 1)\n\t    p_ch = Rows - min_rows() + 1;\n\n\t// Only compute the new window layout when startup has been\n\t// completed. Otherwise the frame sizes may be wrong.\n\tif (p_ch != old_value && full_screen\n#ifdef FEAT_GUI\n\t\t&& !gui.starting\n#endif\n\t   )\n\t    command_height();\n    }\n\n    // when 'updatecount' changes from zero to non-zero, open swap files\n    else if (pp == &p_uc)\n    {\n\tif (p_uc < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_uc = 100;\n\t}\n\tif (p_uc && !old_value)\n\t    ml_open_files();\n    }\n#ifdef FEAT_CONCEAL\n    else if (pp == &curwin->w_p_cole)\n    {\n\tif (curwin->w_p_cole < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    curwin->w_p_cole = 0;\n\t}\n\telse if (curwin->w_p_cole > 3)\n\t{\n\t    errmsg = e_invalid_argument;\n\t    curwin->w_p_cole = 3;\n\t}\n    }\n#endif\n#ifdef MZSCHEME_GUI_THREADS\n    else if (pp == &p_mzq)\n\tmzvim_reset_timer();\n#endif\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\n    // 'pyxversion'\n    else if (pp == &p_pyx)\n    {\n\tif (p_pyx != 0 && p_pyx != 2 && p_pyx != 3)\n\t    errmsg = e_invalid_argument;\n    }\n#endif\n\n    // sync undo before 'undolevels' changes\n    else if (pp == &p_ul)\n    {\n\t// use the old value, otherwise u_sync() may not work properly\n\tp_ul = old_value;\n\tu_sync(TRUE);\n\tp_ul = value;\n    }\n    else if (pp == &curbuf->b_p_ul)\n    {\n\t// use the old value, otherwise u_sync() may not work properly\n\tcurbuf->b_p_ul = old_value;\n\tu_sync(TRUE);\n\tcurbuf->b_p_ul = value;\n    }\n\n#ifdef FEAT_LINEBREAK\n    // 'numberwidth' must be positive\n    else if (pp == &curwin->w_p_nuw)\n    {\n\tif (curwin->w_p_nuw < 1)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    curwin->w_p_nuw = 1;\n\t}\n\tif (curwin->w_p_nuw > 20)\n\t{\n\t    errmsg = e_invalid_argument;\n\t    curwin->w_p_nuw = 20;\n\t}\n\tcurwin->w_nrwidth_line_count = 0; // trigger a redraw\n    }\n#endif\n\n    else if (pp == &curbuf->b_p_tw)\n    {\n\tif (curbuf->b_p_tw < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    curbuf->b_p_tw = 0;\n\t}\n#ifdef FEAT_SYN_HL\n\t{\n\t    win_T\t*wp;\n\t    tabpage_T\t*tp;\n\n\t    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t\tcheck_colorcolumn(wp);\n\t}\n#endif\n    }\n\n    /*\n     * Check the bounds for numeric options here\n     */\n    if (Rows < min_rows() && full_screen)\n    {\n\tif (errbuf != NULL)\n\t{\n\t    vim_snprintf(errbuf, errbuflen,\n\t\t\t       _(e_need_at_least_nr_lines), min_rows());\n\t    errmsg = errbuf;\n\t}\n\tRows = min_rows();\n    }\n    if (Columns < MIN_COLUMNS && full_screen)\n    {\n\tif (errbuf != NULL)\n\t{\n\t    vim_snprintf(errbuf, errbuflen,\n\t\t\t    _(e_need_at_least_nr_columns), MIN_COLUMNS);\n\t    errmsg = errbuf;\n\t}\n\tColumns = MIN_COLUMNS;\n    }\n    limit_screen_size();\n\n    /*\n     * If the screen (shell) height has been changed, assume it is the\n     * physical screenheight.\n     */\n    if (old_Rows != Rows || old_Columns != Columns)\n    {\n\t// Changing the screen size is not allowed while updating the screen.\n\tif (updating_screen)\n\t    *pp = old_value;\n\telse if (full_screen\n#ifdef FEAT_GUI\n\t\t&& !gui.starting\n#endif\n\t    )\n\t    set_shellsize((int)Columns, (int)Rows, TRUE);\n\telse\n\t{\n\t    // Postpone the resizing; check the size and cmdline position for\n\t    // messages.\n\t    check_shellsize();\n\t    if (cmdline_row > Rows - p_ch && Rows > p_ch)\n\t\tcmdline_row = Rows - p_ch;\n\t}\n\tif (p_window >= Rows || !option_was_set((char_u *)\"window\"))\n\t    p_window = Rows - 1;\n    }\n\n    if (curbuf->b_p_ts <= 0)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tcurbuf->b_p_ts = 8;\n    }\n    else if (curbuf->b_p_ts > TABSTOP_MAX)\n    {\n\terrmsg = e_invalid_argument;\n\tcurbuf->b_p_ts = 8;\n    }\n    if (p_tm < 0)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_tm = 0;\n    }\n    if ((curwin->w_p_scr <= 0\n\t\t|| (curwin->w_p_scr > curwin->w_height\n\t\t    && curwin->w_height > 0))\n\t    && full_screen)\n    {\n\tif (pp == &(curwin->w_p_scr))\n\t{\n\t    if (curwin->w_p_scr != 0)\n\t\terrmsg = e_invalid_scroll_size;\n\t    win_comp_scroll(curwin);\n\t}\n\t// If 'scroll' became invalid because of a side effect silently adjust\n\t// it.\n\telse if (curwin->w_p_scr <= 0)\n\t    curwin->w_p_scr = 1;\n\telse // curwin->w_p_scr > curwin->w_height\n\t    curwin->w_p_scr = curwin->w_height;\n    }\n    if (p_hi < 0)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_hi = 0;\n    }\n    else if (p_hi > 10000)\n    {\n\terrmsg = e_invalid_argument;\n\tp_hi = 10000;\n    }\n    if (p_re < 0 || p_re > 2)\n    {\n\terrmsg = e_invalid_argument;\n\tp_re = 0;\n    }\n    if (p_report < 0)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_report = 1;\n    }\n    if ((p_sj < -100 || p_sj >= Rows) && full_screen)\n    {\n\tif (Rows != old_Rows)\t// Rows changed, just adjust p_sj\n\t    p_sj = Rows / 2;\n\telse\n\t{\n\t    errmsg = e_invalid_scroll_size;\n\t    p_sj = 1;\n\t}\n    }\n    if (p_so < 0 && full_screen)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_so = 0;\n    }\n    if (p_siso < 0 && full_screen)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_siso = 0;\n    }\n#ifdef FEAT_CMDWIN\n    if (p_cwh < 1)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_cwh = 1;\n    }\n#endif\n    if (p_ut < 0)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_ut = 2000;\n    }\n    if (p_ss < 0)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_ss = 0;\n    }\n\n    // May set global value for local option.\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\t*(long *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) = *pp;\n\n    options[opt_idx].flags |= P_WAS_SET;\n\n#if defined(FEAT_EVAL)\n    apply_optionset_autocmd(opt_idx, opt_flags, old_value, old_global_value,\n\t\t\t\t\t\t\t\tvalue, errmsg);\n#endif\n\n    comp_col();\t\t\t    // in case 'columns' or 'ls' changed\n    if (curwin->w_curswant != MAXCOL\n\t\t     && (options[opt_idx].flags & (P_CURSWANT | P_RALL)) != 0)\n\tcurwin->w_set_curswant = TRUE;\n    if ((opt_flags & OPT_NO_REDRAW) == 0)\n\tcheck_redraw(options[opt_idx].flags);\n\n    return errmsg;\n}\n\n/*\n * Called after an option changed: check if something needs to be redrawn.\n */\n    void\ncheck_redraw(long_u flags)\n{\n    // Careful: P_RCLR and P_RALL are a combination of other P_ flags\n    int\t\tdoclear = (flags & P_RCLR) == P_RCLR;\n    int\t\tall = ((flags & P_RALL) == P_RALL || doclear);\n\n    if ((flags & P_RSTAT) || all)\t// mark all status lines dirty\n\tstatus_redraw_all();\n\n    if ((flags & P_RBUF) || (flags & P_RWIN) || all)\n\tchanged_window_setting();\n    if (flags & P_RBUF)\n\tredraw_curbuf_later(NOT_VALID);\n    if (flags & P_RWINONLY)\n\tredraw_later(NOT_VALID);\n    if (doclear)\n\tredraw_all_later(CLEAR);\n    else if (all)\n\tredraw_all_later(NOT_VALID);\n}\n\n/*\n * Find index for option 'arg'.\n * Return -1 if not found.\n */\n    int\nfindoption(char_u *arg)\n{\n    int\t\t    opt_idx;\n    char\t    *s, *p;\n    static short    quick_tab[27] = {0, 0};\t// quick access table\n    int\t\t    is_term_opt;\n\n    /*\n     * For first call: Initialize the quick-access table.\n     * It contains the index for the first option that starts with a certain\n     * letter.  There are 26 letters, plus the first \"t_\" option.\n     */\n    if (quick_tab[1] == 0)\n    {\n\tp = options[0].fullname;\n\tfor (opt_idx = 1; (s = options[opt_idx].fullname) != NULL; opt_idx++)\n\t{\n\t    if (s[0] != p[0])\n\t    {\n\t\tif (s[0] == 't' && s[1] == '_')\n\t\t    quick_tab[26] = opt_idx;\n\t\telse\n\t\t    quick_tab[CharOrdLow(s[0])] = opt_idx;\n\t    }\n\t    p = s;\n\t}\n    }\n\n    /*\n     * Check for name starting with an illegal character.\n     */\n#ifdef EBCDIC\n    if (!islower(arg[0]))\n#else\n    if (arg[0] < 'a' || arg[0] > 'z')\n#endif\n\treturn -1;\n\n    is_term_opt = (arg[0] == 't' && arg[1] == '_');\n    if (is_term_opt)\n\topt_idx = quick_tab[26];\n    else\n\topt_idx = quick_tab[CharOrdLow(arg[0])];\n    for ( ; (s = options[opt_idx].fullname) != NULL; opt_idx++)\n    {\n\tif (STRCMP(arg, s) == 0)\t\t    // match full name\n\t    break;\n    }\n    if (s == NULL && !is_term_opt)\n    {\n\topt_idx = quick_tab[CharOrdLow(arg[0])];\n\tfor ( ; options[opt_idx].fullname != NULL; opt_idx++)\n\t{\n\t    s = options[opt_idx].shortname;\n\t    if (s != NULL && STRCMP(arg, s) == 0)   // match short name\n\t\tbreak;\n\t    s = NULL;\n\t}\n    }\n    if (s == NULL)\n\topt_idx = -1;\n    return opt_idx;\n}\n\n#if defined(FEAT_EVAL) || defined(FEAT_TCL) || defined(FEAT_MZSCHEME)\n/*\n * Get the value for an option.\n *\n * Returns:\n * Number option: gov_number, *numval gets value.\n * Toggle option: gov_bool,   *numval gets value.\n * String option: gov_string, *stringval gets allocated string.\n * Hidden Number option: gov_hidden_number.\n * Hidden Toggle option: gov_hidden_bool.\n * Hidden String option: gov_hidden_string.\n * Unknown option: gov_unknown.\n *\n * \"flagsp\" (if not NULL) is set to the option flags (P_xxxx).\n */\n    getoption_T\nget_option_value(\n    char_u\t*name,\n    long\t*numval,\n    char_u\t**stringval,\t    // NULL when only checking existence\n    int\t\t*flagsp,\n    int\t\tscope)\n{\n    int\t\topt_idx;\n    char_u\t*varp;\n\n    opt_idx = findoption(name);\n    if (opt_idx < 0)\t\t    // option not in the table\n    {\n\tint key;\n\n\tif (STRLEN(name) == 4 && name[0] == 't' && name[1] == '_'\n\t\t\t\t  && (key = find_key_option(name, FALSE)) != 0)\n\t{\n\t    char_u key_name[2];\n\t    char_u *p;\n\n\t    if (flagsp != NULL)\n\t\t*flagsp = 0;  // terminal option has no flags\n\n\t    // check for a terminal option\n\t    if (key < 0)\n\t    {\n\t\tkey_name[0] = KEY2TERMCAP0(key);\n\t\tkey_name[1] = KEY2TERMCAP1(key);\n\t    }\n\t    else\n\t    {\n\t\tkey_name[0] = KS_KEY;\n\t\tkey_name[1] = (key & 0xff);\n\t    }\n\t    p = find_termcode(key_name);\n\t    if (p != NULL)\n\t    {\n\t\tif (stringval != NULL)\n\t\t    *stringval = vim_strsave(p);\n\t\treturn gov_string;\n\t    }\n\t}\n\treturn gov_unknown;\n    }\n\n    varp = get_varp_scope(&(options[opt_idx]), scope);\n\n    if (flagsp != NULL)\n\t// Return the P_xxxx option flags.\n\t*flagsp = options[opt_idx].flags;\n\n    if (options[opt_idx].flags & P_STRING)\n    {\n\tif (varp == NULL)\t\t    // hidden option\n\t    return gov_hidden_string;\n\tif (stringval != NULL)\n\t{\n#ifdef FEAT_CRYPT\n\t    // never return the value of the crypt key\n\t    if ((char_u **)varp == &curbuf->b_p_key\n\t\t\t\t\t\t&& **(char_u **)(varp) != NUL)\n\t\t*stringval = vim_strsave((char_u *)\"*****\");\n\t    else\n#endif\n\t\t*stringval = vim_strsave(*(char_u **)(varp));\n\t}\n\treturn gov_string;\n    }\n\n    if (varp == NULL)\t\t    // hidden option\n\treturn (options[opt_idx].flags & P_NUM)\n\t\t\t\t\t ? gov_hidden_number : gov_hidden_bool;\n    if (options[opt_idx].flags & P_NUM)\n\t*numval = *(long *)varp;\n    else\n    {\n\t// Special case: 'modified' is b_changed, but we also want to consider\n\t// it set when 'ff' or 'fenc' changed.\n\tif ((int *)varp == &curbuf->b_changed)\n\t    *numval = curbufIsChanged();\n\telse\n\t    *numval = (long) *(int *)varp;\n    }\n    return (options[opt_idx].flags & P_NUM) ? gov_number : gov_bool;\n}\n#endif\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) || defined(PROTO)\n/*\n * Returns the option attributes and its value. Unlike the above function it\n * will return either global value or local value of the option depending on\n * what was requested, but it will never return global value if it was\n * requested to return local one and vice versa. Neither it will return\n * buffer-local value if it was requested to return window-local one.\n *\n * Pretends that option is absent if it is not present in the requested scope\n * (i.e. has no global, window-local or buffer-local value depending on\n * opt_type). Uses\n *\n * Returned flags:\n *       0 hidden or unknown option, also option that does not have requested\n *\t   type (see SREQ_* in vim.h)\n *  see SOPT_* in vim.h for other flags\n *\n * Possible opt_type values: see SREQ_* in vim.h\n */\n    int\nget_option_value_strict(\n    char_u\t*name,\n    long\t*numval,\n    char_u\t**stringval,\t    // NULL when only obtaining attributes\n    int\t\topt_type,\n    void\t*from)\n{\n    int\t\topt_idx;\n    char_u\t*varp = NULL;\n    struct vimoption *p;\n    int\t\tr = 0;\n\n    opt_idx = findoption(name);\n    if (opt_idx < 0)\n\treturn 0;\n\n    p = &(options[opt_idx]);\n\n    // Hidden option\n    if (p->var == NULL)\n\treturn 0;\n\n    if (p->flags & P_BOOL)\n\tr |= SOPT_BOOL;\n    else if (p->flags & P_NUM)\n\tr |= SOPT_NUM;\n    else if (p->flags & P_STRING)\n\tr |= SOPT_STRING;\n\n    if (p->indir == PV_NONE)\n    {\n\tif (opt_type == SREQ_GLOBAL)\n\t    r |= SOPT_GLOBAL;\n\telse\n\t    return 0; // Did not request global-only option\n    }\n    else\n    {\n\tif (p->indir & PV_BOTH)\n\t    r |= SOPT_GLOBAL;\n\telse if (opt_type == SREQ_GLOBAL)\n\t    return 0; // Requested global option\n\n\tif (p->indir & PV_WIN)\n\t{\n\t    if (opt_type == SREQ_BUF)\n\t\treturn 0; // Did not request window-local option\n\t    else\n\t\tr |= SOPT_WIN;\n\t}\n\telse if (p->indir & PV_BUF)\n\t{\n\t    if (opt_type == SREQ_WIN)\n\t\treturn 0; // Did not request buffer-local option\n\t    else\n\t\tr |= SOPT_BUF;\n\t}\n    }\n\n    if (stringval == NULL)\n\treturn r;\n\n    if (opt_type == SREQ_GLOBAL)\n\tvarp = p->var;\n    else\n    {\n\tif (opt_type == SREQ_BUF)\n\t{\n\t    // Special case: 'modified' is b_changed, but we also want to\n\t    // consider it set when 'ff' or 'fenc' changed.\n\t    if (p->indir == PV_MOD)\n\t    {\n\t\t*numval = bufIsChanged((buf_T *)from);\n\t\tvarp = NULL;\n\t    }\n#ifdef FEAT_CRYPT\n\t    else if (p->indir == PV_KEY)\n\t    {\n\t\t// never return the value of the crypt key\n\t\t*stringval = NULL;\n\t\tvarp = NULL;\n\t    }\n#endif\n\t    else\n\t    {\n\t\tbuf_T *save_curbuf = curbuf;\n\n\t\t// only getting a pointer, no need to use aucmd_prepbuf()\n\t\tcurbuf = (buf_T *)from;\n\t\tcurwin->w_buffer = curbuf;\n\t\tvarp = get_varp(p);\n\t\tcurbuf = save_curbuf;\n\t\tcurwin->w_buffer = curbuf;\n\t    }\n\t}\n\telse if (opt_type == SREQ_WIN)\n\t{\n\t    win_T\t*save_curwin = curwin;\n\n\t    curwin = (win_T *)from;\n\t    curbuf = curwin->w_buffer;\n\t    varp = get_varp(p);\n\t    curwin = save_curwin;\n\t    curbuf = curwin->w_buffer;\n\t}\n\tif (varp == p->var)\n\t    return (r | SOPT_UNSET);\n    }\n\n    if (varp != NULL)\n    {\n\tif (p->flags & P_STRING)\n\t    *stringval = vim_strsave(*(char_u **)(varp));\n\telse if (p->flags & P_NUM)\n\t    *numval = *(long *) varp;\n\telse\n\t    *numval = *(int *)varp;\n    }\n\n    return r;\n}\n\n/*\n * Iterate over options. First argument is a pointer to a pointer to a\n * structure inside options[] array, second is option type like in the above\n * function.\n *\n * If first argument points to NULL it is assumed that iteration just started\n * and caller needs the very first value.\n * If first argument points to the end marker function returns NULL and sets\n * first argument to NULL.\n *\n * Returns full option name for current option on each call.\n */\n    char_u *\noption_iter_next(void **option, int opt_type)\n{\n    struct vimoption\t*ret = NULL;\n    do\n    {\n\tif (*option == NULL)\n\t    *option = (void *) options;\n\telse if (((struct vimoption *) (*option))->fullname == NULL)\n\t{\n\t    *option = NULL;\n\t    return NULL;\n\t}\n\telse\n\t    *option = (void *) (((struct vimoption *) (*option)) + 1);\n\n\tret = ((struct vimoption *) (*option));\n\n\t// Hidden option\n\tif (ret->var == NULL)\n\t{\n\t    ret = NULL;\n\t    continue;\n\t}\n\n\tswitch (opt_type)\n\t{\n\t    case SREQ_GLOBAL:\n\t\tif (!(ret->indir == PV_NONE || ret->indir & PV_BOTH))\n\t\t    ret = NULL;\n\t\tbreak;\n\t    case SREQ_BUF:\n\t\tif (!(ret->indir & PV_BUF))\n\t\t    ret = NULL;\n\t\tbreak;\n\t    case SREQ_WIN:\n\t\tif (!(ret->indir & PV_WIN))\n\t\t    ret = NULL;\n\t\tbreak;\n\t    default:\n\t\tinternal_error(\"option_iter_next()\");\n\t\treturn NULL;\n\t}\n    }\n    while (ret == NULL);\n\n    return (char_u *)ret->fullname;\n}\n#endif\n\n/*\n * Return the flags for the option at 'opt_idx'.\n */\n    long_u\nget_option_flags(int opt_idx)\n{\n    return options[opt_idx].flags;\n}\n\n/*\n * Set a flag for the option at 'opt_idx'.\n */\n    void\nset_option_flag(int opt_idx, long_u flag)\n{\n    options[opt_idx].flags |= flag;\n}\n\n/*\n * Clear a flag for the option at 'opt_idx'.\n */\n    void\nclear_option_flag(int opt_idx, long_u flag)\n{\n    options[opt_idx].flags &= ~flag;\n}\n\n/*\n * Returns TRUE if the option at 'opt_idx' is a global option\n */\n    int\nis_global_option(int opt_idx)\n{\n    return options[opt_idx].indir == PV_NONE;\n}\n\n/*\n * Returns TRUE if the option at 'opt_idx' is a global option which also has a\n * local value.\n */\n    int\nis_global_local_option(int opt_idx)\n{\n    return options[opt_idx].indir & PV_BOTH;\n}\n\n/*\n * Returns TRUE if the option at 'opt_idx' is a window-local option\n */\n    int\nis_window_local_option(int opt_idx)\n{\n    return options[opt_idx].var == VAR_WIN;\n}\n\n/*\n * Returns TRUE if the option at 'opt_idx' is a hidden option\n */\n    int\nis_hidden_option(int opt_idx)\n{\n    return options[opt_idx].var == NULL;\n}\n\n#if defined(FEAT_CRYPT) || defined(PROTO)\n/*\n * Returns TRUE if the option at 'opt_idx' is a crypt key option\n */\n    int\nis_crypt_key_option(int opt_idx)\n{\n    return options[opt_idx].indir == PV_KEY;\n}\n#endif\n\n/*\n * Set the value of option \"name\".\n * Use \"string\" for string options, use \"number\" for other options.\n *\n * Returns NULL on success or error message on error.\n */\n    char *\nset_option_value(\n    char_u\t*name,\n    long\tnumber,\n    char_u\t*string,\n    int\t\topt_flags)\t// OPT_LOCAL or 0 (both)\n{\n    int\t\topt_idx;\n    char_u\t*varp;\n    long_u\tflags;\n\n    opt_idx = findoption(name);\n    if (opt_idx < 0)\n    {\n\tint key;\n\n\tif (STRLEN(name) == 4 && name[0] == 't' && name[1] == '_'\n\t\t&& (key = find_key_option(name, FALSE)) != 0)\n\t{\n\t    char_u key_name[2];\n\n\t    if (key < 0)\n\t    {\n\t\tkey_name[0] = KEY2TERMCAP0(key);\n\t\tkey_name[1] = KEY2TERMCAP1(key);\n\t    }\n\t    else\n\t    {\n\t\tkey_name[0] = KS_KEY;\n\t\tkey_name[1] = (key & 0xff);\n\t    }\n\t    add_termcode(key_name, string, FALSE);\n\t    if (full_screen)\n\t\tttest(FALSE);\n\t    redraw_all_later(CLEAR);\n\t    return NULL;\n\t}\n\n\tsemsg(_(e_unknown_option_str_2), name);\n    }\n    else\n    {\n\tflags = options[opt_idx].flags;\n#ifdef HAVE_SANDBOX\n\t// Disallow changing some options in the sandbox\n\tif (sandbox > 0 && (flags & P_SECURE))\n\t{\n\t    emsg(_(e_not_allowed_in_sandbox));\n\t    return NULL;\n\t}\n#endif\n\tif (flags & P_STRING)\n\t    return set_string_option(opt_idx, string, opt_flags);\n\telse\n\t{\n\t    varp = get_varp_scope(&(options[opt_idx]), opt_flags);\n\t    if (varp != NULL)\t// hidden option is not changed\n\t    {\n\t\tif (number == 0 && string != NULL)\n\t\t{\n\t\t    int idx;\n\n\t\t    // Either we are given a string or we are setting option\n\t\t    // to zero.\n\t\t    for (idx = 0; string[idx] == '0'; ++idx)\n\t\t\t;\n\t\t    if (string[idx] != NUL || idx == 0)\n\t\t    {\n\t\t\t// There's another character after zeros or the string\n\t\t\t// is empty.  In both cases, we are trying to set a\n\t\t\t// num option using a string.\n\t\t\tsemsg(_(e_number_required_after_str_equal_str),\n\t\t\t\t\t\t\t\tname, string);\n\t\t\treturn NULL;     // do nothing as we hit an error\n\n\t\t    }\n\t\t}\n\t\tif (flags & P_NUM)\n\t\t    return set_num_option(opt_idx, varp, number,\n\t\t\t\t\t\t\t  NULL, 0, opt_flags);\n\t\telse\n\t\t    return set_bool_option(opt_idx, varp, (int)number,\n\t\t\t\t\t\t\t\t   opt_flags);\n\t    }\n\t}\n    }\n    return NULL;\n}\n\n/*\n * Get the terminal code for a terminal option.\n * Returns NULL when not found.\n */\n    char_u *\nget_term_code(char_u *tname)\n{\n    int\t    opt_idx;\n    char_u  *varp;\n\n    if (tname[0] != 't' || tname[1] != '_' ||\n\t    tname[2] == NUL || tname[3] == NUL)\n\treturn NULL;\n    if ((opt_idx = findoption(tname)) >= 0)\n    {\n\tvarp = get_varp(&(options[opt_idx]));\n\tif (varp != NULL)\n\t    varp = *(char_u **)(varp);\n\treturn varp;\n    }\n    return find_termcode(tname + 2);\n}\n\n    char_u *\nget_highlight_default(void)\n{\n    int i;\n\n    i = findoption((char_u *)\"hl\");\n    if (i >= 0)\n\treturn options[i].def_val[VI_DEFAULT];\n    return (char_u *)NULL;\n}\n\n    char_u *\nget_encoding_default(void)\n{\n    int i;\n\n    i = findoption((char_u *)\"enc\");\n    if (i >= 0)\n\treturn options[i].def_val[VI_DEFAULT];\n    return (char_u *)NULL;\n}\n\n/*\n * Translate a string like \"t_xx\", \"<t_xx>\" or \"<S-Tab>\" to a key number.\n * When \"has_lt\" is true there is a '<' before \"*arg_arg\".\n * Returns 0 when the key is not recognized.\n */\n    static int\nfind_key_option(char_u *arg_arg, int has_lt)\n{\n    int\t\tkey = 0;\n    int\t\tmodifiers;\n    char_u\t*arg = arg_arg;\n\n    /*\n     * Don't use get_special_key_code() for t_xx, we don't want it to call\n     * add_termcap_entry().\n     */\n    if (arg[0] == 't' && arg[1] == '_' && arg[2] && arg[3])\n\tkey = TERMCAP2KEY(arg[2], arg[3]);\n    else if (has_lt)\n    {\n\t--arg;\t\t\t    // put arg at the '<'\n\tmodifiers = 0;\n\tkey = find_special_key(&arg, &modifiers,\n\t\t\t    FSK_KEYCODE | FSK_KEEP_X_KEY | FSK_SIMPLIFY, NULL);\n\tif (modifiers)\t\t    // can't handle modifiers here\n\t    key = 0;\n    }\n    return key;\n}\n\n/*\n * if 'all' == 0: show changed options\n * if 'all' == 1: show all normal options\n * if 'all' == 2: show all terminal options\n */\n    static void\nshowoptions(\n    int\t\tall,\n    int\t\topt_flags)\t// OPT_LOCAL and/or OPT_GLOBAL\n{\n    struct vimoption\t*p;\n    int\t\t\tcol;\n    int\t\t\tisterm;\n    char_u\t\t*varp;\n    struct vimoption\t**items;\n    int\t\t\titem_count;\n    int\t\t\trun;\n    int\t\t\trow, rows;\n    int\t\t\tcols;\n    int\t\t\ti;\n    int\t\t\tlen;\n\n#define INC 20\n#define GAP 3\n\n    items = ALLOC_MULT(struct vimoption *, OPTION_COUNT);\n    if (items == NULL)\n\treturn;\n\n    // Highlight title\n    if (all == 2)\n\tmsg_puts_title(_(\"\\n--- Terminal codes ---\"));\n    else if (opt_flags & OPT_GLOBAL)\n\tmsg_puts_title(_(\"\\n--- Global option values ---\"));\n    else if (opt_flags & OPT_LOCAL)\n\tmsg_puts_title(_(\"\\n--- Local option values ---\"));\n    else\n\tmsg_puts_title(_(\"\\n--- Options ---\"));\n\n    /*\n     * Do the loop two times:\n     * 1. display the short items\n     * 2. display the long items (only strings and numbers)\n     * When \"opt_flags\" has OPT_ONECOLUMN do everything in run 2.\n     */\n    for (run = 1; run <= 2 && !got_int; ++run)\n    {\n\t/*\n\t * collect the items in items[]\n\t */\n\titem_count = 0;\n\tfor (p = &options[0]; p->fullname != NULL; p++)\n\t{\n\t    // apply :filter /pat/\n\t    if (message_filtered((char_u *)p->fullname))\n\t\tcontinue;\n\n\t    varp = NULL;\n\t    isterm = istermoption(p);\n\t    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) != 0)\n\t    {\n\t\tif (p->indir != PV_NONE && !isterm)\n\t\t    varp = get_varp_scope(p, opt_flags);\n\t    }\n\t    else\n\t\tvarp = get_varp(p);\n\t    if (varp != NULL\n\t\t    && ((all == 2 && isterm)\n\t\t\t|| (all == 1 && !isterm)\n\t\t\t|| (all == 0 && !optval_default(p, varp, p_cp))))\n\t    {\n\t\tif (opt_flags & OPT_ONECOLUMN)\n\t\t    len = Columns;\n\t\telse if (p->flags & P_BOOL)\n\t\t    len = 1;\t\t// a toggle option fits always\n\t\telse\n\t\t{\n\t\t    option_value2string(p, opt_flags);\n\t\t    len = (int)STRLEN(p->fullname) + vim_strsize(NameBuff) + 1;\n\t\t}\n\t\tif ((len <= INC - GAP && run == 1) ||\n\t\t\t\t\t\t(len > INC - GAP && run == 2))\n\t\t    items[item_count++] = p;\n\t    }\n\t}\n\n\t/*\n\t * display the items\n\t */\n\tif (run == 1)\n\t{\n\t    cols = (Columns + GAP - 3) / INC;\n\t    if (cols == 0)\n\t\tcols = 1;\n\t    rows = (item_count + cols - 1) / cols;\n\t}\n\telse\t// run == 2\n\t    rows = item_count;\n\tfor (row = 0; row < rows && !got_int; ++row)\n\t{\n\t    msg_putchar('\\n');\t\t\t// go to next line\n\t    if (got_int)\t\t\t// 'q' typed in more\n\t\tbreak;\n\t    col = 0;\n\t    for (i = row; i < item_count; i += rows)\n\t    {\n\t\tmsg_col = col;\t\t\t// make columns\n\t\tshowoneopt(items[i], opt_flags);\n\t\tcol += INC;\n\t    }\n\t    out_flush();\n\t    ui_breakcheck();\n\t}\n    }\n    vim_free(items);\n}\n\n/*\n * Return TRUE if option \"p\" has its default value.\n */\n    static int\noptval_default(struct vimoption *p, char_u *varp, int compatible)\n{\n    int\t\tdvi;\n\n    if (varp == NULL)\n\treturn TRUE;\t    // hidden option is always at default\n    dvi = ((p->flags & P_VI_DEF) || compatible) ? VI_DEFAULT : VIM_DEFAULT;\n    if (p->flags & P_NUM)\n\treturn (*(long *)varp == (long)(long_i)p->def_val[dvi]);\n    if (p->flags & P_BOOL)\n\t\t\t// the cast to long is required for Manx C, long_i is\n\t\t\t// needed for MSVC\n\treturn (*(int *)varp == (int)(long)(long_i)p->def_val[dvi]);\n    // P_STRING\n    return (STRCMP(*(char_u **)varp, p->def_val[dvi]) == 0);\n}\n\n/*\n * showoneopt: show the value of one option\n * must not be called with a hidden option!\n */\n    static void\nshowoneopt(\n    struct vimoption\t*p,\n    int\t\t\topt_flags)\t// OPT_LOCAL or OPT_GLOBAL\n{\n    char_u\t*varp;\n    int\t\tsave_silent = silent_mode;\n\n    silent_mode = FALSE;\n    info_message = TRUE;\t// use mch_msg(), not mch_errmsg()\n\n    varp = get_varp_scope(p, opt_flags);\n\n    // for 'modified' we also need to check if 'ff' or 'fenc' changed.\n    if ((p->flags & P_BOOL) && ((int *)varp == &curbuf->b_changed\n\t\t\t\t\t? !curbufIsChanged() : !*(int *)varp))\n\tmsg_puts(\"no\");\n    else if ((p->flags & P_BOOL) && *(int *)varp < 0)\n\tmsg_puts(\"--\");\n    else\n\tmsg_puts(\"  \");\n    msg_puts(p->fullname);\n    if (!(p->flags & P_BOOL))\n    {\n\tmsg_putchar('=');\n\t// put value string in NameBuff\n\toption_value2string(p, opt_flags);\n\tmsg_outtrans(NameBuff);\n    }\n\n    silent_mode = save_silent;\n    info_message = FALSE;\n}\n\n/*\n * Write modified options as \":set\" commands to a file.\n *\n * There are three values for \"opt_flags\":\n * OPT_GLOBAL:\t\t   Write global option values and fresh values of\n *\t\t\t   buffer-local options (used for start of a session\n *\t\t\t   file).\n * OPT_GLOBAL + OPT_LOCAL: Idem, add fresh values of window-local options for\n *\t\t\t   curwin (used for a vimrc file).\n * OPT_LOCAL:\t\t   Write buffer-local option values for curbuf, fresh\n *\t\t\t   and local values for window-local options of\n *\t\t\t   curwin.  Local values are also written when at the\n *\t\t\t   default value, because a modeline or autocommand\n *\t\t\t   may have set them when doing \":edit file\" and the\n *\t\t\t   user has set them back at the default or fresh\n *\t\t\t   value.\n *\t\t\t   When \"local_only\" is TRUE, don't write fresh\n *\t\t\t   values, only local values (for \":mkview\").\n * (fresh value = value used for a new buffer or window for a local option).\n *\n * Return FAIL on error, OK otherwise.\n */\n    int\nmakeset(FILE *fd, int opt_flags, int local_only)\n{\n    struct vimoption\t*p;\n    char_u\t\t*varp;\t\t\t// currently used value\n    char_u\t\t*varp_fresh;\t\t// local value\n    char_u\t\t*varp_local = NULL;\t// fresh value\n    char\t\t*cmd;\n    int\t\t\tround;\n    int\t\t\tpri;\n\n    /*\n     * The options that don't have a default (terminal name, columns, lines)\n     * are never written.  Terminal options are also not written.\n     * Do the loop over \"options[]\" twice: once for options with the\n     * P_PRI_MKRC flag and once without.\n     */\n    for (pri = 1; pri >= 0; --pri)\n    {\n      for (p = &options[0]; !istermoption(p); p++)\n\tif (!(p->flags & P_NO_MKRC)\n\t\t&& !istermoption(p)\n\t\t&& ((pri == 1) == ((p->flags & P_PRI_MKRC) != 0)))\n\t{\n\t    // skip global option when only doing locals\n\t    if (p->indir == PV_NONE && !(opt_flags & OPT_GLOBAL))\n\t\tcontinue;\n\n\t    // Do not store options like 'bufhidden' and 'syntax' in a vimrc\n\t    // file, they are always buffer-specific.\n\t    if ((opt_flags & OPT_GLOBAL) && (p->flags & P_NOGLOB))\n\t\tcontinue;\n\n\t    // Global values are only written when not at the default value.\n\t    varp = get_varp_scope(p, opt_flags);\n\t    if ((opt_flags & OPT_GLOBAL) && optval_default(p, varp, p_cp))\n\t\tcontinue;\n\n\t    if ((opt_flags & OPT_SKIPRTP) && (p->var == (char_u *)&p_rtp\n\t\t\t\t\t\t || p->var == (char_u *)&p_pp))\n\t\tcontinue;\n\n\t    round = 2;\n\t    if (p->indir != PV_NONE)\n\t    {\n\t\tif (p->var == VAR_WIN)\n\t\t{\n\t\t    // skip window-local option when only doing globals\n\t\t    if (!(opt_flags & OPT_LOCAL))\n\t\t\tcontinue;\n\t\t    // When fresh value of window-local option is not at the\n\t\t    // default, need to write it too.\n\t\t    if (!(opt_flags & OPT_GLOBAL) && !local_only)\n\t\t    {\n\t\t\tvarp_fresh = get_varp_scope(p, OPT_GLOBAL);\n\t\t\tif (!optval_default(p, varp_fresh, p_cp))\n\t\t\t{\n\t\t\t    round = 1;\n\t\t\t    varp_local = varp;\n\t\t\t    varp = varp_fresh;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t    // Round 1: fresh value for window-local options.\n\t    // Round 2: other values\n\t    for ( ; round <= 2; varp = varp_local, ++round)\n\t    {\n\t\tif (round == 1 || (opt_flags & OPT_GLOBAL))\n\t\t    cmd = \"set\";\n\t\telse\n\t\t    cmd = \"setlocal\";\n\n\t\tif (p->flags & P_BOOL)\n\t\t{\n\t\t    if (put_setbool(fd, cmd, p->fullname, *(int *)varp) == FAIL)\n\t\t\treturn FAIL;\n\t\t}\n\t\telse if (p->flags & P_NUM)\n\t\t{\n\t\t    if (put_setnum(fd, cmd, p->fullname, (long *)varp) == FAIL)\n\t\t\treturn FAIL;\n\t\t}\n\t\telse    // P_STRING\n\t\t{\n\t\t    int\t\tdo_endif = FALSE;\n\n\t\t    // Don't set 'syntax' and 'filetype' again if the value is\n\t\t    // already right, avoids reloading the syntax file.\n\t\t    if (\n#if defined(FEAT_SYN_HL)\n\t\t\t    p->indir == PV_SYN ||\n#endif\n\t\t\t    p->indir == PV_FT)\n\t\t    {\n\t\t\tif (fprintf(fd, \"if &%s != '%s'\", p->fullname,\n\t\t\t\t\t\t       *(char_u **)(varp)) < 0\n\t\t\t\t|| put_eol(fd) < 0)\n\t\t\t    return FAIL;\n\t\t\tdo_endif = TRUE;\n\t\t    }\n\t\t    if (put_setstring(fd, cmd, p->fullname, (char_u **)varp,\n\t\t\t\t\t\t\t     p->flags) == FAIL)\n\t\t\treturn FAIL;\n\t\t    if (do_endif)\n\t\t    {\n\t\t\tif (put_line(fd, \"endif\") == FAIL)\n\t\t\t    return FAIL;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    return OK;\n}\n\n#if defined(FEAT_FOLDING) || defined(PROTO)\n/*\n * Generate set commands for the local fold options only.  Used when\n * 'sessionoptions' or 'viewoptions' contains \"folds\" but not \"options\".\n */\n    int\nmakefoldset(FILE *fd)\n{\n    if (put_setstring(fd, \"setlocal\", \"fdm\", &curwin->w_p_fdm, 0) == FAIL\n# ifdef FEAT_EVAL\n\t    || put_setstring(fd, \"setlocal\", \"fde\", &curwin->w_p_fde, 0)\n\t\t\t\t\t\t\t\t       == FAIL\n# endif\n\t    || put_setstring(fd, \"setlocal\", \"fmr\", &curwin->w_p_fmr, 0)\n\t\t\t\t\t\t\t\t       == FAIL\n\t    || put_setstring(fd, \"setlocal\", \"fdi\", &curwin->w_p_fdi, 0)\n\t\t\t\t\t\t\t\t       == FAIL\n\t    || put_setnum(fd, \"setlocal\", \"fdl\", &curwin->w_p_fdl) == FAIL\n\t    || put_setnum(fd, \"setlocal\", \"fml\", &curwin->w_p_fml) == FAIL\n\t    || put_setnum(fd, \"setlocal\", \"fdn\", &curwin->w_p_fdn) == FAIL\n\t    || put_setbool(fd, \"setlocal\", \"fen\", curwin->w_p_fen) == FAIL\n\t    )\n\treturn FAIL;\n\n    return OK;\n}\n#endif\n\n    static int\nput_setstring(\n    FILE\t*fd,\n    char\t*cmd,\n    char\t*name,\n    char_u\t**valuep,\n    long_u\tflags)\n{\n    char_u\t*s;\n    char_u\t*buf = NULL;\n    char_u\t*part = NULL;\n    char_u\t*p;\n\n    if (fprintf(fd, \"%s %s=\", cmd, name) < 0)\n\treturn FAIL;\n    if (*valuep != NULL)\n    {\n\t// Output 'pastetoggle' as key names.  For other\n\t// options some characters have to be escaped with\n\t// CTRL-V or backslash\n\tif (valuep == &p_pt)\n\t{\n\t    s = *valuep;\n\t    while (*s != NUL)\n\t\tif (put_escstr(fd, str2special(&s, FALSE), 2) == FAIL)\n\t\t    return FAIL;\n\t}\n\t// expand the option value, replace $HOME by ~\n\telse if ((flags & P_EXPAND) != 0)\n\t{\n\t    int  size = (int)STRLEN(*valuep) + 1;\n\n\t    // replace home directory in the whole option value into \"buf\"\n\t    buf = alloc(size);\n\t    if (buf == NULL)\n\t\tgoto fail;\n\t    home_replace(NULL, *valuep, buf, size, FALSE);\n\n\t    // If the option value is longer than MAXPATHL, we need to append\n\t    // each comma separated part of the option separately, so that it\n\t    // can be expanded when read back.\n\t    if (size >= MAXPATHL && (flags & P_COMMA) != 0\n\t\t\t\t\t   && vim_strchr(*valuep, ',') != NULL)\n\t    {\n\t\tpart = alloc(size);\n\t\tif (part == NULL)\n\t\t    goto fail;\n\n\t\t// write line break to clear the option, e.g. ':set rtp='\n\t\tif (put_eol(fd) == FAIL)\n\t\t    goto fail;\n\n\t\tp = buf;\n\t\twhile (*p != NUL)\n\t\t{\n\t\t    // for each comma separated option part, append value to\n\t\t    // the option, :set rtp+=value\n\t\t    if (fprintf(fd, \"%s %s+=\", cmd, name) < 0)\n\t\t\tgoto fail;\n\t\t    (void)copy_option_part(&p, part, size,  \",\");\n\t\t    if (put_escstr(fd, part, 2) == FAIL || put_eol(fd) == FAIL)\n\t\t\tgoto fail;\n\t\t}\n\t\tvim_free(buf);\n\t\tvim_free(part);\n\t\treturn OK;\n\t    }\n\t    if (put_escstr(fd, buf, 2) == FAIL)\n\t    {\n\t\tvim_free(buf);\n\t\treturn FAIL;\n\t    }\n\t    vim_free(buf);\n\t}\n\telse if (put_escstr(fd, *valuep, 2) == FAIL)\n\t    return FAIL;\n    }\n    if (put_eol(fd) < 0)\n\treturn FAIL;\n    return OK;\nfail:\n    vim_free(buf);\n    vim_free(part);\n    return FAIL;\n}\n\n    static int\nput_setnum(\n    FILE\t*fd,\n    char\t*cmd,\n    char\t*name,\n    long\t*valuep)\n{\n    long\twc;\n\n    if (fprintf(fd, \"%s %s=\", cmd, name) < 0)\n\treturn FAIL;\n    if (wc_use_keyname((char_u *)valuep, &wc))\n    {\n\t// print 'wildchar' and 'wildcharm' as a key name\n\tif (fputs((char *)get_special_key_name((int)wc, 0), fd) < 0)\n\t    return FAIL;\n    }\n    else if (fprintf(fd, \"%ld\", *valuep) < 0)\n\treturn FAIL;\n    if (put_eol(fd) < 0)\n\treturn FAIL;\n    return OK;\n}\n\n    static int\nput_setbool(\n    FILE\t*fd,\n    char\t*cmd,\n    char\t*name,\n    int\t\tvalue)\n{\n    if (value < 0)\t// global/local option using global value\n\treturn OK;\n    if (fprintf(fd, \"%s %s%s\", cmd, value ? \"\" : \"no\", name) < 0\n\t    || put_eol(fd) < 0)\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Clear all the terminal options.\n * If the option has been allocated, free the memory.\n * Terminal options are never hidden or indirect.\n */\n    void\nclear_termoptions(void)\n{\n    /*\n     * Reset a few things before clearing the old options. This may cause\n     * outputting a few things that the terminal doesn't understand, but the\n     * screen will be cleared later, so this is OK.\n     */\n    mch_setmouse(FALSE);\t    // switch mouse off\n    mch_restore_title(SAVE_RESTORE_BOTH);    // restore window titles\n#if defined(FEAT_XCLIPBOARD) && defined(FEAT_GUI)\n    // When starting the GUI close the display opened for the clipboard.\n    // After restoring the title, because that will need the display.\n    if (gui.starting)\n\tclear_xterm_clip();\n#endif\n    stoptermcap();\t\t\t// stop termcap mode\n\n    free_termoptions();\n}\n\n    void\nfree_termoptions(void)\n{\n    struct vimoption   *p;\n\n    for (p = options; p->fullname != NULL; p++)\n\tif (istermoption(p))\n\t{\n\t    if (p->flags & P_ALLOCED)\n\t\tfree_string_option(*(char_u **)(p->var));\n\t    if (p->flags & P_DEF_ALLOCED)\n\t\tfree_string_option(p->def_val[VI_DEFAULT]);\n\t    *(char_u **)(p->var) = empty_option;\n\t    p->def_val[VI_DEFAULT] = empty_option;\n\t    p->flags &= ~(P_ALLOCED|P_DEF_ALLOCED);\n#ifdef FEAT_EVAL\n\t    // remember where the option was cleared\n\t    set_option_sctx_idx((int)(p - options), OPT_GLOBAL, current_sctx);\n#endif\n\t}\n    clear_termcodes();\n}\n\n/*\n * Free the string for one term option, if it was allocated.\n * Set the string to empty_option and clear allocated flag.\n * \"var\" points to the option value.\n */\n    void\nfree_one_termoption(char_u *var)\n{\n    struct vimoption   *p;\n\n    for (p = &options[0]; p->fullname != NULL; p++)\n\tif (p->var == var)\n\t{\n\t    if (p->flags & P_ALLOCED)\n\t\tfree_string_option(*(char_u **)(p->var));\n\t    *(char_u **)(p->var) = empty_option;\n\t    p->flags &= ~P_ALLOCED;\n\t    break;\n\t}\n}\n\n/*\n * Set the terminal option defaults to the current value.\n * Used after setting the terminal name.\n */\n    void\nset_term_defaults(void)\n{\n    struct vimoption   *p;\n\n    for (p = &options[0]; p->fullname != NULL; p++)\n    {\n\tif (istermoption(p) && p->def_val[VI_DEFAULT] != *(char_u **)(p->var))\n\t{\n\t    if (p->flags & P_DEF_ALLOCED)\n\t    {\n\t\tfree_string_option(p->def_val[VI_DEFAULT]);\n\t\tp->flags &= ~P_DEF_ALLOCED;\n\t    }\n\t    p->def_val[VI_DEFAULT] = *(char_u **)(p->var);\n\t    if (p->flags & P_ALLOCED)\n\t    {\n\t\tp->flags |= P_DEF_ALLOCED;\n\t\tp->flags &= ~P_ALLOCED;\t // don't free the value now\n\t    }\n\t}\n    }\n}\n\n/*\n * return TRUE if 'p' starts with 't_'\n */\n    static int\nistermoption(struct vimoption *p)\n{\n    return (p->fullname[0] == 't' && p->fullname[1] == '_');\n}\n\n/*\n * Returns TRUE if the option at 'opt_idx' starts with 't_'\n */\n    int\nistermoption_idx(int opt_idx)\n{\n    return istermoption(&options[opt_idx]);\n}\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) || defined(PROTO)\n/*\n * Unset local option value, similar to \":set opt<\".\n */\n    void\nunset_global_local_option(char_u *name, void *from)\n{\n    struct vimoption *p;\n    int\t\topt_idx;\n    buf_T\t*buf = (buf_T *)from;\n\n    opt_idx = findoption(name);\n    if (opt_idx < 0)\n\treturn;\n    p = &(options[opt_idx]);\n\n    switch ((int)p->indir)\n    {\n\t// global option with local value: use local value if it's been set\n\tcase PV_EP:\n\t    clear_string_option(&buf->b_p_ep);\n\t    break;\n\tcase PV_KP:\n\t    clear_string_option(&buf->b_p_kp);\n\t    break;\n\tcase PV_PATH:\n\t    clear_string_option(&buf->b_p_path);\n\t    break;\n\tcase PV_AR:\n\t    buf->b_p_ar = -1;\n\t    break;\n\tcase PV_BKC:\n\t    clear_string_option(&buf->b_p_bkc);\n\t    buf->b_bkc_flags = 0;\n\t    break;\n\tcase PV_TAGS:\n\t    clear_string_option(&buf->b_p_tags);\n\t    break;\n\tcase PV_TC:\n\t    clear_string_option(&buf->b_p_tc);\n\t    buf->b_tc_flags = 0;\n\t    break;\n        case PV_SISO:\n            curwin->w_p_siso = -1;\n            break;\n        case PV_SO:\n            curwin->w_p_so = -1;\n            break;\n#ifdef FEAT_FIND_ID\n\tcase PV_DEF:\n\t    clear_string_option(&buf->b_p_def);\n\t    break;\n\tcase PV_INC:\n\t    clear_string_option(&buf->b_p_inc);\n\t    break;\n#endif\n\tcase PV_DICT:\n\t    clear_string_option(&buf->b_p_dict);\n\t    break;\n\tcase PV_TSR:\n\t    clear_string_option(&buf->b_p_tsr);\n\t    break;\n#ifdef FEAT_COMPL_FUNC\n\tcase PV_TSRFU:\n\t    clear_string_option(&buf->b_p_tsrfu);\n\t    break;\n#endif\n\tcase PV_FP:\n\t    clear_string_option(&buf->b_p_fp);\n\t    break;\n#ifdef FEAT_QUICKFIX\n\tcase PV_EFM:\n\t    clear_string_option(&buf->b_p_efm);\n\t    break;\n\tcase PV_GP:\n\t    clear_string_option(&buf->b_p_gp);\n\t    break;\n\tcase PV_MP:\n\t    clear_string_option(&buf->b_p_mp);\n\t    break;\n#endif\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n\tcase PV_BEXPR:\n\t    clear_string_option(&buf->b_p_bexpr);\n\t    break;\n#endif\n#if defined(FEAT_CRYPT)\n\tcase PV_CM:\n\t    clear_string_option(&buf->b_p_cm);\n\t    break;\n#endif\n#ifdef FEAT_LINEBREAK\n\tcase PV_SBR:\n\t    clear_string_option(&((win_T *)from)->w_p_sbr);\n\t    break;\n#endif\n#ifdef FEAT_STL_OPT\n\tcase PV_STL:\n\t    clear_string_option(&((win_T *)from)->w_p_stl);\n\t    break;\n#endif\n\tcase PV_UL:\n\t    buf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n\t    break;\n#ifdef FEAT_LISP\n\tcase PV_LW:\n\t    clear_string_option(&buf->b_p_lw);\n\t    break;\n#endif\n\tcase PV_MENC:\n\t    clear_string_option(&buf->b_p_menc);\n\t    break;\n\tcase PV_LCS:\n\t    clear_string_option(&((win_T *)from)->w_p_lcs);\n\t    set_chars_option((win_T *)from, &((win_T *)from)->w_p_lcs);\n\t    redraw_later(NOT_VALID);\n\t    break;\n\tcase PV_VE:\n\t    clear_string_option(&((win_T *)from)->w_p_ve);\n\t    ((win_T *)from)->w_ve_flags = 0;\n\t    break;\n    }\n}\n#endif\n\n/*\n * Get pointer to option variable, depending on local or global scope.\n * \"scope\" can be OPT_LOCAL, OPT_GLOBAL or a combination.\n */\n    static char_u *\nget_varp_scope(struct vimoption *p, int scope)\n{\n    if ((scope & OPT_GLOBAL) && p->indir != PV_NONE)\n    {\n\tif (p->var == VAR_WIN)\n\t    return (char_u *)GLOBAL_WO(get_varp(p));\n\treturn p->var;\n    }\n    if ((scope & OPT_LOCAL) && ((int)p->indir & PV_BOTH))\n    {\n\tswitch ((int)p->indir)\n\t{\n\t    case PV_FP:   return (char_u *)&(curbuf->b_p_fp);\n#ifdef FEAT_QUICKFIX\n\t    case PV_EFM:  return (char_u *)&(curbuf->b_p_efm);\n\t    case PV_GP:   return (char_u *)&(curbuf->b_p_gp);\n\t    case PV_MP:   return (char_u *)&(curbuf->b_p_mp);\n#endif\n\t    case PV_EP:   return (char_u *)&(curbuf->b_p_ep);\n\t    case PV_KP:   return (char_u *)&(curbuf->b_p_kp);\n\t    case PV_PATH: return (char_u *)&(curbuf->b_p_path);\n\t    case PV_AR:   return (char_u *)&(curbuf->b_p_ar);\n\t    case PV_TAGS: return (char_u *)&(curbuf->b_p_tags);\n\t    case PV_TC:   return (char_u *)&(curbuf->b_p_tc);\n            case PV_SISO: return (char_u *)&(curwin->w_p_siso);\n            case PV_SO:   return (char_u *)&(curwin->w_p_so);\n#ifdef FEAT_FIND_ID\n\t    case PV_DEF:  return (char_u *)&(curbuf->b_p_def);\n\t    case PV_INC:  return (char_u *)&(curbuf->b_p_inc);\n#endif\n\t    case PV_DICT: return (char_u *)&(curbuf->b_p_dict);\n\t    case PV_TSR:  return (char_u *)&(curbuf->b_p_tsr);\n#ifdef FEAT_COMPL_FUNC\n\t    case PV_TSRFU: return (char_u *)&(curbuf->b_p_tsrfu);\n#endif\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n\t    case PV_BEXPR: return (char_u *)&(curbuf->b_p_bexpr);\n#endif\n#if defined(FEAT_CRYPT)\n\t    case PV_CM:\t  return (char_u *)&(curbuf->b_p_cm);\n#endif\n#ifdef FEAT_LINEBREAK\n\t    case PV_SBR:  return (char_u *)&(curwin->w_p_sbr);\n#endif\n#ifdef FEAT_STL_OPT\n\t    case PV_STL:  return (char_u *)&(curwin->w_p_stl);\n#endif\n\t    case PV_UL:   return (char_u *)&(curbuf->b_p_ul);\n#ifdef FEAT_LISP\n\t    case PV_LW:   return (char_u *)&(curbuf->b_p_lw);\n#endif\n\t    case PV_BKC:  return (char_u *)&(curbuf->b_p_bkc);\n\t    case PV_MENC: return (char_u *)&(curbuf->b_p_menc);\n\t    case PV_LCS:  return (char_u *)&(curwin->w_p_lcs);\n\t    case PV_VE:\t  return (char_u *)&(curwin->w_p_ve);\n\n\t}\n\treturn NULL; // \"cannot happen\"\n    }\n    return get_varp(p);\n}\n\n/*\n * Get pointer to option variable at 'opt_idx', depending on local or global\n * scope.\n */\n    char_u *\nget_option_varp_scope(int opt_idx, int scope)\n{\n    return get_varp_scope(&(options[opt_idx]), scope);\n}\n\n/*\n * Get pointer to option variable.\n */\n    static char_u *\nget_varp(struct vimoption *p)\n{\n    // hidden option, always return NULL\n    if (p->var == NULL)\n\treturn NULL;\n\n    switch ((int)p->indir)\n    {\n\tcase PV_NONE:\treturn p->var;\n\n\t// global option with local value: use local value if it's been set\n\tcase PV_EP:\treturn *curbuf->b_p_ep != NUL\n\t\t\t\t    ? (char_u *)&curbuf->b_p_ep : p->var;\n\tcase PV_KP:\treturn *curbuf->b_p_kp != NUL\n\t\t\t\t    ? (char_u *)&curbuf->b_p_kp : p->var;\n\tcase PV_PATH:\treturn *curbuf->b_p_path != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_path) : p->var;\n\tcase PV_AR:\treturn curbuf->b_p_ar >= 0\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_ar) : p->var;\n\tcase PV_TAGS:\treturn *curbuf->b_p_tags != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_tags) : p->var;\n\tcase PV_TC:\treturn *curbuf->b_p_tc != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_tc) : p->var;\n\tcase PV_BKC:\treturn *curbuf->b_p_bkc != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_bkc) : p->var;\n\tcase PV_SISO:\treturn curwin->w_p_siso >= 0\n\t\t\t\t    ? (char_u *)&(curwin->w_p_siso) : p->var;\n\tcase PV_SO:\treturn curwin->w_p_so >= 0\n\t\t\t\t    ? (char_u *)&(curwin->w_p_so) : p->var;\n#ifdef FEAT_FIND_ID\n\tcase PV_DEF:\treturn *curbuf->b_p_def != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_def) : p->var;\n\tcase PV_INC:\treturn *curbuf->b_p_inc != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_inc) : p->var;\n#endif\n\tcase PV_DICT:\treturn *curbuf->b_p_dict != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_dict) : p->var;\n\tcase PV_TSR:\treturn *curbuf->b_p_tsr != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_tsr) : p->var;\n#ifdef FEAT_COMPL_FUNC\n\tcase PV_TSRFU:\treturn *curbuf->b_p_tsrfu != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_tsrfu) : p->var;\n#endif\n\tcase PV_FP:\treturn *curbuf->b_p_fp != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_fp) : p->var;\n#ifdef FEAT_QUICKFIX\n\tcase PV_EFM:\treturn *curbuf->b_p_efm != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_efm) : p->var;\n\tcase PV_GP:\treturn *curbuf->b_p_gp != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_gp) : p->var;\n\tcase PV_MP:\treturn *curbuf->b_p_mp != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_mp) : p->var;\n#endif\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n\tcase PV_BEXPR:\treturn *curbuf->b_p_bexpr != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_bexpr) : p->var;\n#endif\n#if defined(FEAT_CRYPT)\n\tcase PV_CM:\treturn *curbuf->b_p_cm != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_cm) : p->var;\n#endif\n#ifdef FEAT_LINEBREAK\n\tcase PV_SBR:\treturn *curwin->w_p_sbr != NUL\n\t\t\t\t    ? (char_u *)&(curwin->w_p_sbr) : p->var;\n#endif\n#ifdef FEAT_STL_OPT\n\tcase PV_STL:\treturn *curwin->w_p_stl != NUL\n\t\t\t\t    ? (char_u *)&(curwin->w_p_stl) : p->var;\n#endif\n\tcase PV_UL:\treturn curbuf->b_p_ul != NO_LOCAL_UNDOLEVEL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_ul) : p->var;\n#ifdef FEAT_LISP\n\tcase PV_LW:\treturn *curbuf->b_p_lw != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_lw) : p->var;\n#endif\n\tcase PV_MENC:\treturn *curbuf->b_p_menc != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_menc) : p->var;\n#ifdef FEAT_ARABIC\n\tcase PV_ARAB:\treturn (char_u *)&(curwin->w_p_arab);\n#endif\n\tcase PV_LIST:\treturn (char_u *)&(curwin->w_p_list);\n\tcase PV_LCS:\treturn *curwin->w_p_lcs != NUL\n\t\t\t\t    ? (char_u *)&(curwin->w_p_lcs) : p->var;\n\tcase PV_VE:\treturn *curwin->w_p_ve != NUL\n\t\t\t\t    ? (char_u *)&(curwin->w_p_ve) : p->var;\n#ifdef FEAT_SPELL\n\tcase PV_SPELL:\treturn (char_u *)&(curwin->w_p_spell);\n#endif\n#ifdef FEAT_SYN_HL\n\tcase PV_CUC:\treturn (char_u *)&(curwin->w_p_cuc);\n\tcase PV_CUL:\treturn (char_u *)&(curwin->w_p_cul);\n\tcase PV_CULOPT:\treturn (char_u *)&(curwin->w_p_culopt);\n\tcase PV_CC:\treturn (char_u *)&(curwin->w_p_cc);\n#endif\n#ifdef FEAT_DIFF\n\tcase PV_DIFF:\treturn (char_u *)&(curwin->w_p_diff);\n#endif\n#ifdef FEAT_FOLDING\n\tcase PV_FDC:\treturn (char_u *)&(curwin->w_p_fdc);\n\tcase PV_FEN:\treturn (char_u *)&(curwin->w_p_fen);\n\tcase PV_FDI:\treturn (char_u *)&(curwin->w_p_fdi);\n\tcase PV_FDL:\treturn (char_u *)&(curwin->w_p_fdl);\n\tcase PV_FDM:\treturn (char_u *)&(curwin->w_p_fdm);\n\tcase PV_FML:\treturn (char_u *)&(curwin->w_p_fml);\n\tcase PV_FDN:\treturn (char_u *)&(curwin->w_p_fdn);\n# ifdef FEAT_EVAL\n\tcase PV_FDE:\treturn (char_u *)&(curwin->w_p_fde);\n\tcase PV_FDT:\treturn (char_u *)&(curwin->w_p_fdt);\n# endif\n\tcase PV_FMR:\treturn (char_u *)&(curwin->w_p_fmr);\n#endif\n\tcase PV_NU:\treturn (char_u *)&(curwin->w_p_nu);\n\tcase PV_RNU:\treturn (char_u *)&(curwin->w_p_rnu);\n#ifdef FEAT_LINEBREAK\n\tcase PV_NUW:\treturn (char_u *)&(curwin->w_p_nuw);\n#endif\n\tcase PV_WFH:\treturn (char_u *)&(curwin->w_p_wfh);\n\tcase PV_WFW:\treturn (char_u *)&(curwin->w_p_wfw);\n#if defined(FEAT_QUICKFIX)\n\tcase PV_PVW:\treturn (char_u *)&(curwin->w_p_pvw);\n#endif\n#ifdef FEAT_RIGHTLEFT\n\tcase PV_RL:\treturn (char_u *)&(curwin->w_p_rl);\n\tcase PV_RLC:\treturn (char_u *)&(curwin->w_p_rlc);\n#endif\n\tcase PV_SCROLL:\treturn (char_u *)&(curwin->w_p_scr);\n\tcase PV_WRAP:\treturn (char_u *)&(curwin->w_p_wrap);\n#ifdef FEAT_LINEBREAK\n\tcase PV_LBR:\treturn (char_u *)&(curwin->w_p_lbr);\n\tcase PV_BRI:\treturn (char_u *)&(curwin->w_p_bri);\n\tcase PV_BRIOPT: return (char_u *)&(curwin->w_p_briopt);\n#endif\n\tcase PV_WCR:\treturn (char_u *)&(curwin->w_p_wcr);\n\tcase PV_SCBIND: return (char_u *)&(curwin->w_p_scb);\n\tcase PV_CRBIND: return (char_u *)&(curwin->w_p_crb);\n#ifdef FEAT_CONCEAL\n\tcase PV_COCU:   return (char_u *)&(curwin->w_p_cocu);\n\tcase PV_COLE:   return (char_u *)&(curwin->w_p_cole);\n#endif\n#ifdef FEAT_TERMINAL\n\tcase PV_TWK:    return (char_u *)&(curwin->w_p_twk);\n\tcase PV_TWS:    return (char_u *)&(curwin->w_p_tws);\n\tcase PV_TWSL:\treturn (char_u *)&(curbuf->b_p_twsl);\n#endif\n\n\tcase PV_AI:\treturn (char_u *)&(curbuf->b_p_ai);\n\tcase PV_BIN:\treturn (char_u *)&(curbuf->b_p_bin);\n\tcase PV_BOMB:\treturn (char_u *)&(curbuf->b_p_bomb);\n\tcase PV_BH:\treturn (char_u *)&(curbuf->b_p_bh);\n\tcase PV_BT:\treturn (char_u *)&(curbuf->b_p_bt);\n\tcase PV_BL:\treturn (char_u *)&(curbuf->b_p_bl);\n\tcase PV_CI:\treturn (char_u *)&(curbuf->b_p_ci);\n#ifdef FEAT_CINDENT\n\tcase PV_CIN:\treturn (char_u *)&(curbuf->b_p_cin);\n\tcase PV_CINK:\treturn (char_u *)&(curbuf->b_p_cink);\n\tcase PV_CINO:\treturn (char_u *)&(curbuf->b_p_cino);\n#endif\n#if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT)\n\tcase PV_CINW:\treturn (char_u *)&(curbuf->b_p_cinw);\n#endif\n\tcase PV_COM:\treturn (char_u *)&(curbuf->b_p_com);\n#ifdef FEAT_FOLDING\n\tcase PV_CMS:\treturn (char_u *)&(curbuf->b_p_cms);\n#endif\n\tcase PV_CPT:\treturn (char_u *)&(curbuf->b_p_cpt);\n#ifdef BACKSLASH_IN_FILENAME\n\tcase PV_CSL:\treturn (char_u *)&(curbuf->b_p_csl);\n#endif\n#ifdef FEAT_COMPL_FUNC\n\tcase PV_CFU:\treturn (char_u *)&(curbuf->b_p_cfu);\n\tcase PV_OFU:\treturn (char_u *)&(curbuf->b_p_ofu);\n#endif\n#ifdef FEAT_EVAL\n\tcase PV_TFU:\treturn (char_u *)&(curbuf->b_p_tfu);\n#endif\n\tcase PV_EOL:\treturn (char_u *)&(curbuf->b_p_eol);\n\tcase PV_FIXEOL:\treturn (char_u *)&(curbuf->b_p_fixeol);\n\tcase PV_ET:\treturn (char_u *)&(curbuf->b_p_et);\n\tcase PV_FENC:\treturn (char_u *)&(curbuf->b_p_fenc);\n\tcase PV_FF:\treturn (char_u *)&(curbuf->b_p_ff);\n\tcase PV_FT:\treturn (char_u *)&(curbuf->b_p_ft);\n\tcase PV_FO:\treturn (char_u *)&(curbuf->b_p_fo);\n\tcase PV_FLP:\treturn (char_u *)&(curbuf->b_p_flp);\n\tcase PV_IMI:\treturn (char_u *)&(curbuf->b_p_iminsert);\n\tcase PV_IMS:\treturn (char_u *)&(curbuf->b_p_imsearch);\n\tcase PV_INF:\treturn (char_u *)&(curbuf->b_p_inf);\n\tcase PV_ISK:\treturn (char_u *)&(curbuf->b_p_isk);\n#ifdef FEAT_FIND_ID\n# ifdef FEAT_EVAL\n\tcase PV_INEX:\treturn (char_u *)&(curbuf->b_p_inex);\n# endif\n#endif\n#if defined(FEAT_CINDENT) && defined(FEAT_EVAL)\n\tcase PV_INDE:\treturn (char_u *)&(curbuf->b_p_inde);\n\tcase PV_INDK:\treturn (char_u *)&(curbuf->b_p_indk);\n#endif\n#ifdef FEAT_EVAL\n\tcase PV_FEX:\treturn (char_u *)&(curbuf->b_p_fex);\n#endif\n#ifdef FEAT_CRYPT\n\tcase PV_KEY:\treturn (char_u *)&(curbuf->b_p_key);\n#endif\n#ifdef FEAT_LISP\n\tcase PV_LISP:\treturn (char_u *)&(curbuf->b_p_lisp);\n#endif\n\tcase PV_ML:\treturn (char_u *)&(curbuf->b_p_ml);\n\tcase PV_MPS:\treturn (char_u *)&(curbuf->b_p_mps);\n\tcase PV_MA:\treturn (char_u *)&(curbuf->b_p_ma);\n\tcase PV_MOD:\treturn (char_u *)&(curbuf->b_changed);\n\tcase PV_NF:\treturn (char_u *)&(curbuf->b_p_nf);\n\tcase PV_PI:\treturn (char_u *)&(curbuf->b_p_pi);\n#ifdef FEAT_TEXTOBJ\n\tcase PV_QE:\treturn (char_u *)&(curbuf->b_p_qe);\n#endif\n\tcase PV_RO:\treturn (char_u *)&(curbuf->b_p_ro);\n#ifdef FEAT_SMARTINDENT\n\tcase PV_SI:\treturn (char_u *)&(curbuf->b_p_si);\n#endif\n\tcase PV_SN:\treturn (char_u *)&(curbuf->b_p_sn);\n\tcase PV_STS:\treturn (char_u *)&(curbuf->b_p_sts);\n#ifdef FEAT_SEARCHPATH\n\tcase PV_SUA:\treturn (char_u *)&(curbuf->b_p_sua);\n#endif\n\tcase PV_SWF:\treturn (char_u *)&(curbuf->b_p_swf);\n#ifdef FEAT_SYN_HL\n\tcase PV_SMC:\treturn (char_u *)&(curbuf->b_p_smc);\n\tcase PV_SYN:\treturn (char_u *)&(curbuf->b_p_syn);\n#endif\n#ifdef FEAT_SPELL\n\tcase PV_SPC:\treturn (char_u *)&(curwin->w_s->b_p_spc);\n\tcase PV_SPF:\treturn (char_u *)&(curwin->w_s->b_p_spf);\n\tcase PV_SPL:\treturn (char_u *)&(curwin->w_s->b_p_spl);\n\tcase PV_SPO:\treturn (char_u *)&(curwin->w_s->b_p_spo);\n#endif\n\tcase PV_SW:\treturn (char_u *)&(curbuf->b_p_sw);\n\tcase PV_TS:\treturn (char_u *)&(curbuf->b_p_ts);\n\tcase PV_TW:\treturn (char_u *)&(curbuf->b_p_tw);\n\tcase PV_TX:\treturn (char_u *)&(curbuf->b_p_tx);\n#ifdef FEAT_PERSISTENT_UNDO\n\tcase PV_UDF:\treturn (char_u *)&(curbuf->b_p_udf);\n#endif\n\tcase PV_WM:\treturn (char_u *)&(curbuf->b_p_wm);\n#ifdef FEAT_KEYMAP\n\tcase PV_KMAP:\treturn (char_u *)&(curbuf->b_p_keymap);\n#endif\n#ifdef FEAT_SIGNS\n\tcase PV_SCL:\treturn (char_u *)&(curwin->w_p_scl);\n#endif\n#ifdef FEAT_VARTABS\n\tcase PV_VSTS:\treturn (char_u *)&(curbuf->b_p_vsts);\n\tcase PV_VTS:\treturn (char_u *)&(curbuf->b_p_vts);\n#endif\n\tdefault:\tiemsg(_(e_get_varp_error));\n    }\n    // always return a valid pointer to avoid a crash!\n    return (char_u *)&(curbuf->b_p_wm);\n}\n\n/*\n * Return a pointer to the variable for option at 'opt_idx'\n */\n    char_u *\nget_option_var(int opt_idx)\n{\n    return options[opt_idx].var;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return the full name of the option at 'opt_idx'\n */\n    char_u *\nget_option_fullname(int opt_idx)\n{\n    return (char_u *)options[opt_idx].fullname;\n}\n#endif\n\n/*\n * Get the value of 'equalprg', either the buffer-local one or the global one.\n */\n    char_u *\nget_equalprg(void)\n{\n    if (*curbuf->b_p_ep == NUL)\n\treturn p_ep;\n    return curbuf->b_p_ep;\n}\n\n/*\n * Copy options from one window to another.\n * Used when splitting a window.\n */\n    void\nwin_copy_options(win_T *wp_from, win_T *wp_to)\n{\n    copy_winopt(&wp_from->w_onebuf_opt, &wp_to->w_onebuf_opt);\n    copy_winopt(&wp_from->w_allbuf_opt, &wp_to->w_allbuf_opt);\n    after_copy_winopt(wp_to);\n}\n\n/*\n * After copying window options: update variables depending on options.\n */\n    void\nafter_copy_winopt(win_T *wp UNUSED)\n{\n#ifdef FEAT_LINEBREAK\n    briopt_check(wp);\n#endif\n#ifdef FEAT_SYN_HL\n    fill_culopt_flags(NULL, wp);\n    check_colorcolumn(wp);\n#endif\n    set_chars_option(wp, &wp->w_p_lcs);\n}\n\n/*\n * Copy the options from one winopt_T to another.\n * Doesn't free the old option values in \"to\", use clear_winopt() for that.\n * The 'scroll' option is not copied, because it depends on the window height.\n * The 'previewwindow' option is reset, there can be only one preview window.\n */\n    void\ncopy_winopt(winopt_T *from, winopt_T *to)\n{\n#ifdef FEAT_ARABIC\n    to->wo_arab = from->wo_arab;\n#endif\n    to->wo_list = from->wo_list;\n    to->wo_lcs = vim_strsave(from->wo_lcs);\n    to->wo_nu = from->wo_nu;\n    to->wo_rnu = from->wo_rnu;\n    to->wo_ve = vim_strsave(from->wo_ve);\n    to->wo_ve_flags = from->wo_ve_flags;\n#ifdef FEAT_LINEBREAK\n    to->wo_nuw = from->wo_nuw;\n#endif\n#ifdef FEAT_RIGHTLEFT\n    to->wo_rl  = from->wo_rl;\n    to->wo_rlc = vim_strsave(from->wo_rlc);\n#endif\n#ifdef FEAT_LINEBREAK\n    to->wo_sbr = vim_strsave(from->wo_sbr);\n#endif\n#ifdef FEAT_STL_OPT\n    to->wo_stl = vim_strsave(from->wo_stl);\n#endif\n    to->wo_wrap = from->wo_wrap;\n#ifdef FEAT_DIFF\n    to->wo_wrap_save = from->wo_wrap_save;\n#endif\n#ifdef FEAT_LINEBREAK\n    to->wo_lbr = from->wo_lbr;\n    to->wo_bri = from->wo_bri;\n    to->wo_briopt = vim_strsave(from->wo_briopt);\n#endif\n    to->wo_wcr = vim_strsave(from->wo_wcr);\n    to->wo_scb = from->wo_scb;\n    to->wo_scb_save = from->wo_scb_save;\n    to->wo_crb = from->wo_crb;\n    to->wo_crb_save = from->wo_crb_save;\n#ifdef FEAT_SPELL\n    to->wo_spell = from->wo_spell;\n#endif\n#ifdef FEAT_SYN_HL\n    to->wo_cuc = from->wo_cuc;\n    to->wo_cul = from->wo_cul;\n    to->wo_culopt = vim_strsave(from->wo_culopt);\n    to->wo_cc = vim_strsave(from->wo_cc);\n#endif\n#ifdef FEAT_DIFF\n    to->wo_diff = from->wo_diff;\n    to->wo_diff_saved = from->wo_diff_saved;\n#endif\n#ifdef FEAT_CONCEAL\n    to->wo_cocu = vim_strsave(from->wo_cocu);\n    to->wo_cole = from->wo_cole;\n#endif\n#ifdef FEAT_TERMINAL\n    to->wo_twk = vim_strsave(from->wo_twk);\n    to->wo_tws = vim_strsave(from->wo_tws);\n#endif\n#ifdef FEAT_FOLDING\n    to->wo_fdc = from->wo_fdc;\n    to->wo_fdc_save = from->wo_fdc_save;\n    to->wo_fen = from->wo_fen;\n    to->wo_fen_save = from->wo_fen_save;\n    to->wo_fdi = vim_strsave(from->wo_fdi);\n    to->wo_fml = from->wo_fml;\n    to->wo_fdl = from->wo_fdl;\n    to->wo_fdl_save = from->wo_fdl_save;\n    to->wo_fdm = vim_strsave(from->wo_fdm);\n    to->wo_fdm_save = from->wo_diff_saved\n\t\t\t      ? vim_strsave(from->wo_fdm_save) : empty_option;\n    to->wo_fdn = from->wo_fdn;\n# ifdef FEAT_EVAL\n    to->wo_fde = vim_strsave(from->wo_fde);\n    to->wo_fdt = vim_strsave(from->wo_fdt);\n# endif\n    to->wo_fmr = vim_strsave(from->wo_fmr);\n#endif\n#ifdef FEAT_SIGNS\n    to->wo_scl = vim_strsave(from->wo_scl);\n#endif\n\n#ifdef FEAT_EVAL\n    // Copy the script context so that we know where the value was last set.\n    mch_memmove(to->wo_script_ctx, from->wo_script_ctx,\n\t\t\t\t\t\t    sizeof(to->wo_script_ctx));\n#endif\n    check_winopt(to);\t\t// don't want NULL pointers\n}\n\n/*\n * Check string options in a window for a NULL value.\n */\n    static void\ncheck_win_options(win_T *win)\n{\n    check_winopt(&win->w_onebuf_opt);\n    check_winopt(&win->w_allbuf_opt);\n}\n\n/*\n * Check for NULL pointers in a winopt_T and replace them with empty_option.\n */\n    static void\ncheck_winopt(winopt_T *wop UNUSED)\n{\n#ifdef FEAT_FOLDING\n    check_string_option(&wop->wo_fdi);\n    check_string_option(&wop->wo_fdm);\n    check_string_option(&wop->wo_fdm_save);\n# ifdef FEAT_EVAL\n    check_string_option(&wop->wo_fde);\n    check_string_option(&wop->wo_fdt);\n# endif\n    check_string_option(&wop->wo_fmr);\n#endif\n#ifdef FEAT_SIGNS\n    check_string_option(&wop->wo_scl);\n#endif\n#ifdef FEAT_RIGHTLEFT\n    check_string_option(&wop->wo_rlc);\n#endif\n#ifdef FEAT_LINEBREAK\n    check_string_option(&wop->wo_sbr);\n#endif\n#ifdef FEAT_STL_OPT\n    check_string_option(&wop->wo_stl);\n#endif\n#ifdef FEAT_SYN_HL\n    check_string_option(&wop->wo_culopt);\n    check_string_option(&wop->wo_cc);\n#endif\n#ifdef FEAT_CONCEAL\n    check_string_option(&wop->wo_cocu);\n#endif\n#ifdef FEAT_TERMINAL\n    check_string_option(&wop->wo_twk);\n    check_string_option(&wop->wo_tws);\n#endif\n#ifdef FEAT_LINEBREAK\n    check_string_option(&wop->wo_briopt);\n#endif\n    check_string_option(&wop->wo_wcr);\n    check_string_option(&wop->wo_lcs);\n    check_string_option(&wop->wo_ve);\n}\n\n/*\n * Free the allocated memory inside a winopt_T.\n */\n    void\nclear_winopt(winopt_T *wop UNUSED)\n{\n#ifdef FEAT_FOLDING\n    clear_string_option(&wop->wo_fdi);\n    clear_string_option(&wop->wo_fdm);\n    clear_string_option(&wop->wo_fdm_save);\n# ifdef FEAT_EVAL\n    clear_string_option(&wop->wo_fde);\n    clear_string_option(&wop->wo_fdt);\n# endif\n    clear_string_option(&wop->wo_fmr);\n#endif\n#ifdef FEAT_SIGNS\n    clear_string_option(&wop->wo_scl);\n#endif\n#ifdef FEAT_LINEBREAK\n    clear_string_option(&wop->wo_briopt);\n#endif\n    clear_string_option(&wop->wo_wcr);\n#ifdef FEAT_RIGHTLEFT\n    clear_string_option(&wop->wo_rlc);\n#endif\n#ifdef FEAT_LINEBREAK\n    clear_string_option(&wop->wo_sbr);\n#endif\n#ifdef FEAT_STL_OPT\n    clear_string_option(&wop->wo_stl);\n#endif\n#ifdef FEAT_SYN_HL\n    clear_string_option(&wop->wo_culopt);\n    clear_string_option(&wop->wo_cc);\n#endif\n#ifdef FEAT_CONCEAL\n    clear_string_option(&wop->wo_cocu);\n#endif\n#ifdef FEAT_TERMINAL\n    clear_string_option(&wop->wo_twk);\n    clear_string_option(&wop->wo_tws);\n#endif\n    clear_string_option(&wop->wo_lcs);\n    clear_string_option(&wop->wo_ve);\n}\n\n#ifdef FEAT_EVAL\n// Index into the options table for a buffer-local option enum.\nstatic int buf_opt_idx[BV_COUNT];\n# define COPY_OPT_SCTX(buf, bv) buf->b_p_script_ctx[bv] = options[buf_opt_idx[bv]].script_ctx\n\n/*\n * Initialize buf_opt_idx[] if not done already.\n */\n    static void\ninit_buf_opt_idx(void)\n{\n    static int did_init_buf_opt_idx = FALSE;\n    int i;\n\n    if (did_init_buf_opt_idx)\n\treturn;\n    did_init_buf_opt_idx = TRUE;\n    for (i = 0; !istermoption_idx(i); i++)\n\tif (options[i].indir & PV_BUF)\n\t    buf_opt_idx[options[i].indir & PV_MASK] = i;\n}\n#else\n# define COPY_OPT_SCTX(buf, bv)\n#endif\n\n/*\n * Copy global option values to local options for one buffer.\n * Used when creating a new buffer and sometimes when entering a buffer.\n * flags:\n * BCO_ENTER\tWe will enter the buffer \"buf\".\n * BCO_ALWAYS\tAlways copy the options, but only set b_p_initialized when\n *\t\tappropriate.\n * BCO_NOHELP\tDon't copy the values to a help buffer.\n */\n    void\nbuf_copy_options(buf_T *buf, int flags)\n{\n    int\t\tshould_copy = TRUE;\n    char_u\t*save_p_isk = NULL;\t    // init for GCC\n    int\t\tdont_do_help;\n    int\t\tdid_isk = FALSE;\n\n    /*\n     * Skip this when the option defaults have not been set yet.  Happens when\n     * main() allocates the first buffer.\n     */\n    if (p_cpo != NULL)\n    {\n\t/*\n\t * Always copy when entering and 'cpo' contains 'S'.\n\t * Don't copy when already initialized.\n\t * Don't copy when 'cpo' contains 's' and not entering.\n\t * 'S'\tBCO_ENTER  initialized\t's'  should_copy\n\t * yes\t  yes\t       X\t X\tTRUE\n\t * yes\t  no\t      yes\t X\tFALSE\n\t * no\t   X\t      yes\t X\tFALSE\n\t *  X\t  no\t      no\tyes\tFALSE\n\t *  X\t  no\t      no\tno\tTRUE\n\t * no\t  yes\t      no\t X\tTRUE\n\t */\n\tif ((vim_strchr(p_cpo, CPO_BUFOPTGLOB) == NULL || !(flags & BCO_ENTER))\n\t\t&& (buf->b_p_initialized\n\t\t    || (!(flags & BCO_ENTER)\n\t\t\t&& vim_strchr(p_cpo, CPO_BUFOPT) != NULL)))\n\t    should_copy = FALSE;\n\n\tif (should_copy || (flags & BCO_ALWAYS))\n\t{\n#ifdef FEAT_EVAL\n\t    CLEAR_FIELD(buf->b_p_script_ctx);\n\t    init_buf_opt_idx();\n#endif\n\t    // Don't copy the options specific to a help buffer when\n\t    // BCO_NOHELP is given or the options were initialized already\n\t    // (jumping back to a help file with CTRL-T or CTRL-O)\n\t    dont_do_help = ((flags & BCO_NOHELP) && buf->b_help)\n\t\t\t\t\t\t       || buf->b_p_initialized;\n\t    if (dont_do_help)\t\t// don't free b_p_isk\n\t    {\n\t\tsave_p_isk = buf->b_p_isk;\n\t\tbuf->b_p_isk = NULL;\n\t    }\n\t    /*\n\t     * Always free the allocated strings.  If not already initialized,\n\t     * reset 'readonly' and copy 'fileformat'.\n\t     */\n\t    if (!buf->b_p_initialized)\n\t    {\n\t\tfree_buf_options(buf, TRUE);\n\t\tbuf->b_p_ro = FALSE;\t\t// don't copy readonly\n\t\tbuf->b_p_tx = p_tx;\n\t\tbuf->b_p_fenc = vim_strsave(p_fenc);\n\t\tswitch (*p_ffs)\n\t\t{\n\t\t    case 'm':\n\t\t\tbuf->b_p_ff = vim_strsave((char_u *)FF_MAC); break;\n\t\t    case 'd':\n\t\t\tbuf->b_p_ff = vim_strsave((char_u *)FF_DOS); break;\n\t\t    case 'u':\n\t\t\tbuf->b_p_ff = vim_strsave((char_u *)FF_UNIX); break;\n\t\t    default:\n\t\t\tbuf->b_p_ff = vim_strsave(p_ff);\n\t\t}\n\t\tif (buf->b_p_ff != NULL)\n\t\t    buf->b_start_ffc = *buf->b_p_ff;\n\t\tbuf->b_p_bh = empty_option;\n\t\tbuf->b_p_bt = empty_option;\n\t    }\n\t    else\n\t\tfree_buf_options(buf, FALSE);\n\n\t    buf->b_p_ai = p_ai;\n\t    COPY_OPT_SCTX(buf, BV_AI);\n\t    buf->b_p_ai_nopaste = p_ai_nopaste;\n\t    buf->b_p_sw = p_sw;\n\t    COPY_OPT_SCTX(buf, BV_SW);\n\t    buf->b_p_tw = p_tw;\n\t    COPY_OPT_SCTX(buf, BV_TW);\n\t    buf->b_p_tw_nopaste = p_tw_nopaste;\n\t    buf->b_p_tw_nobin = p_tw_nobin;\n\t    buf->b_p_wm = p_wm;\n\t    COPY_OPT_SCTX(buf, BV_WM);\n\t    buf->b_p_wm_nopaste = p_wm_nopaste;\n\t    buf->b_p_wm_nobin = p_wm_nobin;\n\t    buf->b_p_bin = p_bin;\n\t    COPY_OPT_SCTX(buf, BV_BIN);\n\t    buf->b_p_bomb = p_bomb;\n\t    COPY_OPT_SCTX(buf, BV_BOMB);\n\t    buf->b_p_fixeol = p_fixeol;\n\t    COPY_OPT_SCTX(buf, BV_FIXEOL);\n\t    buf->b_p_et = p_et;\n\t    COPY_OPT_SCTX(buf, BV_ET);\n\t    buf->b_p_et_nobin = p_et_nobin;\n\t    buf->b_p_et_nopaste = p_et_nopaste;\n\t    buf->b_p_ml = p_ml;\n\t    COPY_OPT_SCTX(buf, BV_ML);\n\t    buf->b_p_ml_nobin = p_ml_nobin;\n\t    buf->b_p_inf = p_inf;\n\t    COPY_OPT_SCTX(buf, BV_INF);\n\t    if (cmdmod.cmod_flags & CMOD_NOSWAPFILE)\n\t\tbuf->b_p_swf = FALSE;\n\t    else\n\t    {\n\t\tbuf->b_p_swf = p_swf;\n\t\tCOPY_OPT_SCTX(buf, BV_SWF);\n\t    }\n\t    buf->b_p_cpt = vim_strsave(p_cpt);\n\t    COPY_OPT_SCTX(buf, BV_CPT);\n#ifdef BACKSLASH_IN_FILENAME\n\t    buf->b_p_csl = vim_strsave(p_csl);\n\t    COPY_OPT_SCTX(buf, BV_CSL);\n#endif\n#ifdef FEAT_COMPL_FUNC\n\t    buf->b_p_cfu = vim_strsave(p_cfu);\n\t    COPY_OPT_SCTX(buf, BV_CFU);\n\t    set_buflocal_cfu_callback(buf);\n\t    buf->b_p_ofu = vim_strsave(p_ofu);\n\t    COPY_OPT_SCTX(buf, BV_OFU);\n\t    set_buflocal_ofu_callback(buf);\n#endif\n#ifdef FEAT_EVAL\n\t    buf->b_p_tfu = vim_strsave(p_tfu);\n\t    COPY_OPT_SCTX(buf, BV_TFU);\n\t    set_buflocal_tfu_callback(buf);\n#endif\n\t    buf->b_p_sts = p_sts;\n\t    COPY_OPT_SCTX(buf, BV_STS);\n\t    buf->b_p_sts_nopaste = p_sts_nopaste;\n#ifdef FEAT_VARTABS\n\t    buf->b_p_vsts = vim_strsave(p_vsts);\n\t    COPY_OPT_SCTX(buf, BV_VSTS);\n\t    if (p_vsts && p_vsts != empty_option)\n\t\t(void)tabstop_set(p_vsts, &buf->b_p_vsts_array);\n\t    else\n\t\tbuf->b_p_vsts_array = NULL;\n\t    buf->b_p_vsts_nopaste = p_vsts_nopaste\n\t\t\t\t ? vim_strsave(p_vsts_nopaste) : NULL;\n#endif\n\t    buf->b_p_sn = p_sn;\n\t    COPY_OPT_SCTX(buf, BV_SN);\n\t    buf->b_p_com = vim_strsave(p_com);\n\t    COPY_OPT_SCTX(buf, BV_COM);\n#ifdef FEAT_FOLDING\n\t    buf->b_p_cms = vim_strsave(p_cms);\n\t    COPY_OPT_SCTX(buf, BV_CMS);\n#endif\n\t    buf->b_p_fo = vim_strsave(p_fo);\n\t    COPY_OPT_SCTX(buf, BV_FO);\n\t    buf->b_p_flp = vim_strsave(p_flp);\n\t    COPY_OPT_SCTX(buf, BV_FLP);\n\t    // NOTE: Valgrind may report a bogus memory leak for 'nrformats'\n\t    // when it is set to 8 bytes in defaults.vim.\n\t    buf->b_p_nf = vim_strsave(p_nf);\n\t    COPY_OPT_SCTX(buf, BV_NF);\n\t    buf->b_p_mps = vim_strsave(p_mps);\n\t    COPY_OPT_SCTX(buf, BV_MPS);\n#ifdef FEAT_SMARTINDENT\n\t    buf->b_p_si = p_si;\n\t    COPY_OPT_SCTX(buf, BV_SI);\n#endif\n\t    buf->b_p_ci = p_ci;\n\t    COPY_OPT_SCTX(buf, BV_CI);\n#ifdef FEAT_CINDENT\n\t    buf->b_p_cin = p_cin;\n\t    COPY_OPT_SCTX(buf, BV_CIN);\n\t    buf->b_p_cink = vim_strsave(p_cink);\n\t    COPY_OPT_SCTX(buf, BV_CINK);\n\t    buf->b_p_cino = vim_strsave(p_cino);\n\t    COPY_OPT_SCTX(buf, BV_CINO);\n#endif\n\t    // Don't copy 'filetype', it must be detected\n\t    buf->b_p_ft = empty_option;\n\t    buf->b_p_pi = p_pi;\n\t    COPY_OPT_SCTX(buf, BV_PI);\n#if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT)\n\t    buf->b_p_cinw = vim_strsave(p_cinw);\n\t    COPY_OPT_SCTX(buf, BV_CINW);\n#endif\n#ifdef FEAT_LISP\n\t    buf->b_p_lisp = p_lisp;\n\t    COPY_OPT_SCTX(buf, BV_LISP);\n#endif\n#ifdef FEAT_SYN_HL\n\t    // Don't copy 'syntax', it must be set\n\t    buf->b_p_syn = empty_option;\n\t    buf->b_p_smc = p_smc;\n\t    COPY_OPT_SCTX(buf, BV_SMC);\n\t    buf->b_s.b_syn_isk = empty_option;\n#endif\n#ifdef FEAT_SPELL\n\t    buf->b_s.b_p_spc = vim_strsave(p_spc);\n\t    COPY_OPT_SCTX(buf, BV_SPC);\n\t    (void)compile_cap_prog(&buf->b_s);\n\t    buf->b_s.b_p_spf = vim_strsave(p_spf);\n\t    COPY_OPT_SCTX(buf, BV_SPF);\n\t    buf->b_s.b_p_spl = vim_strsave(p_spl);\n\t    COPY_OPT_SCTX(buf, BV_SPL);\n\t    buf->b_s.b_p_spo = vim_strsave(p_spo);\n\t    COPY_OPT_SCTX(buf, BV_SPO);\n#endif\n#if defined(FEAT_CINDENT) && defined(FEAT_EVAL)\n\t    buf->b_p_inde = vim_strsave(p_inde);\n\t    COPY_OPT_SCTX(buf, BV_INDE);\n\t    buf->b_p_indk = vim_strsave(p_indk);\n\t    COPY_OPT_SCTX(buf, BV_INDK);\n#endif\n\t    buf->b_p_fp = empty_option;\n#if defined(FEAT_EVAL)\n\t    buf->b_p_fex = vim_strsave(p_fex);\n\t    COPY_OPT_SCTX(buf, BV_FEX);\n#endif\n#ifdef FEAT_CRYPT\n\t    buf->b_p_key = vim_strsave(p_key);\n\t    COPY_OPT_SCTX(buf, BV_KEY);\n#endif\n#ifdef FEAT_SEARCHPATH\n\t    buf->b_p_sua = vim_strsave(p_sua);\n\t    COPY_OPT_SCTX(buf, BV_SUA);\n#endif\n#ifdef FEAT_KEYMAP\n\t    buf->b_p_keymap = vim_strsave(p_keymap);\n\t    COPY_OPT_SCTX(buf, BV_KMAP);\n\t    buf->b_kmap_state |= KEYMAP_INIT;\n#endif\n#ifdef FEAT_TERMINAL\n\t    buf->b_p_twsl = p_twsl;\n\t    COPY_OPT_SCTX(buf, BV_TWSL);\n#endif\n\t    // This isn't really an option, but copying the langmap and IME\n\t    // state from the current buffer is better than resetting it.\n\t    buf->b_p_iminsert = p_iminsert;\n\t    COPY_OPT_SCTX(buf, BV_IMI);\n\t    buf->b_p_imsearch = p_imsearch;\n\t    COPY_OPT_SCTX(buf, BV_IMS);\n\n\t    // options that are normally global but also have a local value\n\t    // are not copied, start using the global value\n\t    buf->b_p_ar = -1;\n\t    buf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n\t    buf->b_p_bkc = empty_option;\n\t    buf->b_bkc_flags = 0;\n#ifdef FEAT_QUICKFIX\n\t    buf->b_p_gp = empty_option;\n\t    buf->b_p_mp = empty_option;\n\t    buf->b_p_efm = empty_option;\n#endif\n\t    buf->b_p_ep = empty_option;\n\t    buf->b_p_kp = empty_option;\n\t    buf->b_p_path = empty_option;\n\t    buf->b_p_tags = empty_option;\n\t    buf->b_p_tc = empty_option;\n\t    buf->b_tc_flags = 0;\n#ifdef FEAT_FIND_ID\n\t    buf->b_p_def = empty_option;\n\t    buf->b_p_inc = empty_option;\n# ifdef FEAT_EVAL\n\t    buf->b_p_inex = vim_strsave(p_inex);\n\t    COPY_OPT_SCTX(buf, BV_INEX);\n# endif\n#endif\n\t    buf->b_p_dict = empty_option;\n\t    buf->b_p_tsr = empty_option;\n#ifdef FEAT_COMPL_FUNC\n\t    buf->b_p_tsrfu = empty_option;\n#endif\n#ifdef FEAT_TEXTOBJ\n\t    buf->b_p_qe = vim_strsave(p_qe);\n\t    COPY_OPT_SCTX(buf, BV_QE);\n#endif\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n\t    buf->b_p_bexpr = empty_option;\n#endif\n#if defined(FEAT_CRYPT)\n\t    buf->b_p_cm = empty_option;\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t    buf->b_p_udf = p_udf;\n\t    COPY_OPT_SCTX(buf, BV_UDF);\n#endif\n#ifdef FEAT_LISP\n\t    buf->b_p_lw = empty_option;\n#endif\n\t    buf->b_p_menc = empty_option;\n\n\t    /*\n\t     * Don't copy the options set by ex_help(), use the saved values,\n\t     * when going from a help buffer to a non-help buffer.\n\t     * Don't touch these at all when BCO_NOHELP is used and going from\n\t     * or to a help buffer.\n\t     */\n\t    if (dont_do_help)\n\t    {\n\t\tbuf->b_p_isk = save_p_isk;\n#ifdef FEAT_VARTABS\n\t\tif (p_vts && p_vts != empty_option && !buf->b_p_vts_array)\n\t\t    (void)tabstop_set(p_vts, &buf->b_p_vts_array);\n\t\telse\n\t\t    buf->b_p_vts_array = NULL;\n#endif\n\t    }\n\t    else\n\t    {\n\t\tbuf->b_p_isk = vim_strsave(p_isk);\n\t\tCOPY_OPT_SCTX(buf, BV_ISK);\n\t\tdid_isk = TRUE;\n\t\tbuf->b_p_ts = p_ts;\n\t\tCOPY_OPT_SCTX(buf, BV_TS);\n#ifdef FEAT_VARTABS\n\t\tbuf->b_p_vts = vim_strsave(p_vts);\n\t\tCOPY_OPT_SCTX(buf, BV_VTS);\n\t\tif (p_vts && p_vts != empty_option && !buf->b_p_vts_array)\n\t\t    (void)tabstop_set(p_vts, &buf->b_p_vts_array);\n\t\telse\n\t\t    buf->b_p_vts_array = NULL;\n#endif\n\t\tbuf->b_help = FALSE;\n\t\tif (buf->b_p_bt[0] == 'h')\n\t\t    clear_string_option(&buf->b_p_bt);\n\t\tbuf->b_p_ma = p_ma;\n\t\tCOPY_OPT_SCTX(buf, BV_MA);\n\t    }\n\t}\n\n\t/*\n\t * When the options should be copied (ignoring BCO_ALWAYS), set the\n\t * flag that indicates that the options have been initialized.\n\t */\n\tif (should_copy)\n\t    buf->b_p_initialized = TRUE;\n    }\n\n    check_buf_options(buf);\t    // make sure we don't have NULLs\n    if (did_isk)\n\t(void)buf_init_chartab(buf, FALSE);\n}\n\n/*\n * Reset the 'modifiable' option and its default value.\n */\n    void\nreset_modifiable(void)\n{\n    int\t\topt_idx;\n\n    curbuf->b_p_ma = FALSE;\n    p_ma = FALSE;\n    opt_idx = findoption((char_u *)\"ma\");\n    if (opt_idx >= 0)\n\toptions[opt_idx].def_val[VI_DEFAULT] = FALSE;\n}\n\n/*\n * Set the global value for 'iminsert' to the local value.\n */\n    void\nset_iminsert_global(void)\n{\n    p_iminsert = curbuf->b_p_iminsert;\n}\n\n/*\n * Set the global value for 'imsearch' to the local value.\n */\n    void\nset_imsearch_global(void)\n{\n    p_imsearch = curbuf->b_p_imsearch;\n}\n\nstatic int expand_option_idx = -1;\nstatic char_u expand_option_name[5] = {'t', '_', NUL, NUL, NUL};\nstatic int expand_option_flags = 0;\n\n    void\nset_context_in_set_cmd(\n    expand_T\t*xp,\n    char_u\t*arg,\n    int\t\topt_flags)\t// OPT_GLOBAL and/or OPT_LOCAL\n{\n    int\t\tnextchar;\n    long_u\tflags = 0;\t// init for GCC\n    int\t\topt_idx = 0;\t// init for GCC\n    char_u\t*p;\n    char_u\t*s;\n    int\t\tis_term_option = FALSE;\n    int\t\tkey;\n\n    expand_option_flags = opt_flags;\n\n    xp->xp_context = EXPAND_SETTINGS;\n    if (*arg == NUL)\n    {\n\txp->xp_pattern = arg;\n\treturn;\n    }\n    p = arg + STRLEN(arg) - 1;\n    if (*p == ' ' && *(p - 1) != '\\\\')\n    {\n\txp->xp_pattern = p + 1;\n\treturn;\n    }\n    while (p > arg)\n    {\n\ts = p;\n\t// count number of backslashes before ' ' or ','\n\tif (*p == ' ' || *p == ',')\n\t{\n\t    while (s > arg && *(s - 1) == '\\\\')\n\t\t--s;\n\t}\n\t// break at a space with an even number of backslashes\n\tif (*p == ' ' && ((p - s) & 1) == 0)\n\t{\n\t    ++p;\n\t    break;\n\t}\n\t--p;\n    }\n    if (STRNCMP(p, \"no\", 2) == 0 && STRNCMP(p, \"novice\", 6) != 0)\n    {\n\txp->xp_context = EXPAND_BOOL_SETTINGS;\n\tp += 2;\n    }\n    if (STRNCMP(p, \"inv\", 3) == 0)\n    {\n\txp->xp_context = EXPAND_BOOL_SETTINGS;\n\tp += 3;\n    }\n    xp->xp_pattern = arg = p;\n    if (*arg == '<')\n    {\n\twhile (*p != '>')\n\t    if (*p++ == NUL)\t    // expand terminal option name\n\t\treturn;\n\tkey = get_special_key_code(arg + 1);\n\tif (key == 0)\t\t    // unknown name\n\t{\n\t    xp->xp_context = EXPAND_NOTHING;\n\t    return;\n\t}\n\tnextchar = *++p;\n\tis_term_option = TRUE;\n\texpand_option_name[2] = KEY2TERMCAP0(key);\n\texpand_option_name[3] = KEY2TERMCAP1(key);\n    }\n    else\n    {\n\tif (p[0] == 't' && p[1] == '_')\n\t{\n\t    p += 2;\n\t    if (*p != NUL)\n\t\t++p;\n\t    if (*p == NUL)\n\t\treturn;\t\t// expand option name\n\t    nextchar = *++p;\n\t    is_term_option = TRUE;\n\t    expand_option_name[2] = p[-2];\n\t    expand_option_name[3] = p[-1];\n\t}\n\telse\n\t{\n\t    // Allow * wildcard\n\t    while (ASCII_ISALNUM(*p) || *p == '_' || *p == '*')\n\t\tp++;\n\t    if (*p == NUL)\n\t\treturn;\n\t    nextchar = *p;\n\t    *p = NUL;\n\t    opt_idx = findoption(arg);\n\t    *p = nextchar;\n\t    if (opt_idx == -1 || options[opt_idx].var == NULL)\n\t    {\n\t\txp->xp_context = EXPAND_NOTHING;\n\t\treturn;\n\t    }\n\t    flags = options[opt_idx].flags;\n\t    if (flags & P_BOOL)\n\t    {\n\t\txp->xp_context = EXPAND_NOTHING;\n\t\treturn;\n\t    }\n\t}\n    }\n    // handle \"-=\" and \"+=\"\n    if ((nextchar == '-' || nextchar == '+' || nextchar == '^') && p[1] == '=')\n    {\n\t++p;\n\tnextchar = '=';\n    }\n    if ((nextchar != '=' && nextchar != ':')\n\t\t\t\t    || xp->xp_context == EXPAND_BOOL_SETTINGS)\n    {\n\txp->xp_context = EXPAND_UNSUCCESSFUL;\n\treturn;\n    }\n    if (xp->xp_context != EXPAND_BOOL_SETTINGS && p[1] == NUL)\n    {\n\txp->xp_context = EXPAND_OLD_SETTING;\n\tif (is_term_option)\n\t    expand_option_idx = -1;\n\telse\n\t    expand_option_idx = opt_idx;\n\txp->xp_pattern = p + 1;\n\treturn;\n    }\n    xp->xp_context = EXPAND_NOTHING;\n    if (is_term_option || (flags & P_NUM))\n\treturn;\n\n    xp->xp_pattern = p + 1;\n\n    if (flags & P_EXPAND)\n    {\n\tp = options[opt_idx].var;\n\tif (p == (char_u *)&p_bdir\n\t\t|| p == (char_u *)&p_dir\n\t\t|| p == (char_u *)&p_path\n\t\t|| p == (char_u *)&p_pp\n\t\t|| p == (char_u *)&p_rtp\n#ifdef FEAT_SEARCHPATH\n\t\t|| p == (char_u *)&p_cdpath\n#endif\n#ifdef FEAT_SESSION\n\t\t|| p == (char_u *)&p_vdir\n#endif\n\t\t)\n\t{\n\t    xp->xp_context = EXPAND_DIRECTORIES;\n\t    if (p == (char_u *)&p_path\n#ifdef FEAT_SEARCHPATH\n\t\t    || p == (char_u *)&p_cdpath\n#endif\n\t\t   )\n\t\txp->xp_backslash = XP_BS_THREE;\n\t    else\n\t\txp->xp_backslash = XP_BS_ONE;\n\t}\n\telse if (p == (char_u *)&p_ft)\n\t{\n\t    xp->xp_context = EXPAND_FILETYPE;\n\t}\n\telse\n\t{\n\t    xp->xp_context = EXPAND_FILES;\n\t    // for 'tags' need three backslashes for a space\n\t    if (p == (char_u *)&p_tags)\n\t\txp->xp_backslash = XP_BS_THREE;\n\t    else\n\t\txp->xp_backslash = XP_BS_ONE;\n\t}\n    }\n\n    // For an option that is a list of file names, find the start of the\n    // last file name.\n    for (p = arg + STRLEN(arg) - 1; p > xp->xp_pattern; --p)\n    {\n\t// count number of backslashes before ' ' or ','\n\tif (*p == ' ' || *p == ',')\n\t{\n\t    s = p;\n\t    while (s > xp->xp_pattern && *(s - 1) == '\\\\')\n\t\t--s;\n\t    if ((*p == ' ' && (xp->xp_backslash == XP_BS_THREE && (p - s) < 3))\n\t\t    || (*p == ',' && (flags & P_COMMA) && ((p - s) & 1) == 0))\n\t    {\n\t\txp->xp_pattern = p + 1;\n\t\tbreak;\n\t    }\n\t}\n\n#ifdef FEAT_SPELL\n\t// for 'spellsuggest' start at \"file:\"\n\tif (options[opt_idx].var == (char_u *)&p_sps\n\t\t\t\t\t       && STRNCMP(p, \"file:\", 5) == 0)\n\t{\n\t    xp->xp_pattern = p + 5;\n\t    break;\n\t}\n#endif\n    }\n}\n\n    int\nExpandSettings(\n    expand_T\t*xp,\n    regmatch_T\t*regmatch,\n    int\t\t*num_file,\n    char_u\t***file)\n{\n    int\t\tnum_normal = 0;\t    // Nr of matching non-term-code settings\n    int\t\tnum_term = 0;\t    // Nr of matching terminal code settings\n    int\t\topt_idx;\n    int\t\tmatch;\n    int\t\tcount = 0;\n    char_u\t*str;\n    int\t\tloop;\n    int\t\tis_term_opt;\n    char_u\tname_buf[MAX_KEY_NAME_LEN];\n    static char *(names[]) = {\"all\", \"termcap\"};\n    int\t\tic = regmatch->rm_ic;\t// remember the ignore-case flag\n\n    // do this loop twice:\n    // loop == 0: count the number of matching options\n    // loop == 1: copy the matching options into allocated memory\n    for (loop = 0; loop <= 1; ++loop)\n    {\n\tregmatch->rm_ic = ic;\n\tif (xp->xp_context != EXPAND_BOOL_SETTINGS)\n\t{\n\t    for (match = 0; match < (int)ARRAY_LENGTH(names); ++match)\n\t\tif (vim_regexec(regmatch, (char_u *)names[match], (colnr_T)0))\n\t\t{\n\t\t    if (loop == 0)\n\t\t\tnum_normal++;\n\t\t    else\n\t\t\t(*file)[count++] = vim_strsave((char_u *)names[match]);\n\t\t}\n\t}\n\tfor (opt_idx = 0; (str = (char_u *)options[opt_idx].fullname) != NULL;\n\t\t\t\t\t\t\t\t    opt_idx++)\n\t{\n\t    if (options[opt_idx].var == NULL)\n\t\tcontinue;\n\t    if (xp->xp_context == EXPAND_BOOL_SETTINGS\n\t      && !(options[opt_idx].flags & P_BOOL))\n\t\tcontinue;\n\t    is_term_opt = istermoption_idx(opt_idx);\n\t    if (is_term_opt && num_normal > 0)\n\t\tcontinue;\n\t    match = FALSE;\n\t    if (vim_regexec(regmatch, str, (colnr_T)0)\n\t\t    || (options[opt_idx].shortname != NULL\n\t\t\t&& vim_regexec(regmatch,\n\t\t\t   (char_u *)options[opt_idx].shortname, (colnr_T)0)))\n\t\tmatch = TRUE;\n\t    else if (is_term_opt)\n\t    {\n\t\tname_buf[0] = '<';\n\t\tname_buf[1] = 't';\n\t\tname_buf[2] = '_';\n\t\tname_buf[3] = str[2];\n\t\tname_buf[4] = str[3];\n\t\tname_buf[5] = '>';\n\t\tname_buf[6] = NUL;\n\t\tif (vim_regexec(regmatch, name_buf, (colnr_T)0))\n\t\t{\n\t\t    match = TRUE;\n\t\t    str = name_buf;\n\t\t}\n\t    }\n\t    if (match)\n\t    {\n\t\tif (loop == 0)\n\t\t{\n\t\t    if (is_term_opt)\n\t\t\tnum_term++;\n\t\t    else\n\t\t\tnum_normal++;\n\t\t}\n\t\telse\n\t\t    (*file)[count++] = vim_strsave(str);\n\t    }\n\t}\n\t/*\n\t * Check terminal key codes, these are not in the option table\n\t */\n\tif (xp->xp_context != EXPAND_BOOL_SETTINGS  && num_normal == 0)\n\t{\n\t    for (opt_idx = 0; (str = get_termcode(opt_idx)) != NULL; opt_idx++)\n\t    {\n\t\tif (!isprint(str[0]) || !isprint(str[1]))\n\t\t    continue;\n\n\t\tname_buf[0] = 't';\n\t\tname_buf[1] = '_';\n\t\tname_buf[2] = str[0];\n\t\tname_buf[3] = str[1];\n\t\tname_buf[4] = NUL;\n\n\t\tmatch = FALSE;\n\t\tif (vim_regexec(regmatch, name_buf, (colnr_T)0))\n\t\t    match = TRUE;\n\t\telse\n\t\t{\n\t\t    name_buf[0] = '<';\n\t\t    name_buf[1] = 't';\n\t\t    name_buf[2] = '_';\n\t\t    name_buf[3] = str[0];\n\t\t    name_buf[4] = str[1];\n\t\t    name_buf[5] = '>';\n\t\t    name_buf[6] = NUL;\n\n\t\t    if (vim_regexec(regmatch, name_buf, (colnr_T)0))\n\t\t\tmatch = TRUE;\n\t\t}\n\t\tif (match)\n\t\t{\n\t\t    if (loop == 0)\n\t\t\tnum_term++;\n\t\t    else\n\t\t\t(*file)[count++] = vim_strsave(name_buf);\n\t\t}\n\t    }\n\n\t    /*\n\t     * Check special key names.\n\t     */\n\t    regmatch->rm_ic = TRUE;\t\t// ignore case here\n\t    for (opt_idx = 0; (str = get_key_name(opt_idx)) != NULL; opt_idx++)\n\t    {\n\t\tname_buf[0] = '<';\n\t\tSTRCPY(name_buf + 1, str);\n\t\tSTRCAT(name_buf, \">\");\n\n\t\tif (vim_regexec(regmatch, name_buf, (colnr_T)0))\n\t\t{\n\t\t    if (loop == 0)\n\t\t\tnum_term++;\n\t\t    else\n\t\t\t(*file)[count++] = vim_strsave(name_buf);\n\t\t}\n\t    }\n\t}\n\tif (loop == 0)\n\t{\n\t    if (num_normal > 0)\n\t\t*num_file = num_normal;\n\t    else if (num_term > 0)\n\t\t*num_file = num_term;\n\t    else\n\t\treturn OK;\n\t    *file = ALLOC_MULT(char_u *, *num_file);\n\t    if (*file == NULL)\n\t    {\n\t\t*file = (char_u **)\"\";\n\t\treturn FAIL;\n\t    }\n\t}\n    }\n    return OK;\n}\n\n    int\nExpandOldSetting(int *num_file, char_u ***file)\n{\n    char_u  *var = NULL;\t// init for GCC\n    char_u  *buf;\n\n    *num_file = 0;\n    *file = ALLOC_ONE(char_u *);\n    if (*file == NULL)\n\treturn FAIL;\n\n    /*\n     * For a terminal key code expand_option_idx is < 0.\n     */\n    if (expand_option_idx < 0)\n    {\n\tvar = find_termcode(expand_option_name + 2);\n\tif (var == NULL)\n\t    expand_option_idx = findoption(expand_option_name);\n    }\n\n    if (expand_option_idx >= 0)\n    {\n\t// put string of option value in NameBuff\n\toption_value2string(&options[expand_option_idx], expand_option_flags);\n\tvar = NameBuff;\n    }\n    else if (var == NULL)\n\tvar = (char_u *)\"\";\n\n    // A backslash is required before some characters.  This is the reverse of\n    // what happens in do_set().\n    buf = vim_strsave_escaped(var, escape_chars);\n\n    if (buf == NULL)\n    {\n\tVIM_CLEAR(*file);\n\treturn FAIL;\n    }\n\n#ifdef BACKSLASH_IN_FILENAME\n    // For MS-Windows et al. we don't double backslashes at the start and\n    // before a file name character.\n    for (var = buf; *var != NUL; MB_PTR_ADV(var))\n\tif (var[0] == '\\\\' && var[1] == '\\\\'\n\t\t&& expand_option_idx >= 0\n\t\t&& (options[expand_option_idx].flags & P_EXPAND)\n\t\t&& vim_isfilec(var[2])\n\t\t&& (var[2] != '\\\\' || (var == buf && var[4] != '\\\\')))\n\t    STRMOVE(var, var + 1);\n#endif\n\n    *file[0] = buf;\n    *num_file = 1;\n    return OK;\n}\n\n/*\n * Get the value for the numeric or string option *opp in a nice format into\n * NameBuff[].  Must not be called with a hidden option!\n */\n    static void\noption_value2string(\n    struct vimoption\t*opp,\n    int\t\t\tscope)\t// OPT_GLOBAL and/or OPT_LOCAL\n{\n    char_u\t*varp;\n\n    varp = get_varp_scope(opp, scope);\n\n    if (opp->flags & P_NUM)\n    {\n\tlong wc = 0;\n\n\tif (wc_use_keyname(varp, &wc))\n\t    STRCPY(NameBuff, get_special_key_name((int)wc, 0));\n\telse if (wc != 0)\n\t    STRCPY(NameBuff, transchar((int)wc));\n\telse\n\t    sprintf((char *)NameBuff, \"%ld\", *(long *)varp);\n    }\n    else    // P_STRING\n    {\n\tvarp = *(char_u **)(varp);\n\tif (varp == NULL)\t\t    // just in case\n\t    NameBuff[0] = NUL;\n#ifdef FEAT_CRYPT\n\t// don't show the actual value of 'key', only that it's set\n\telse if (opp->var == (char_u *)&p_key && *varp)\n\t    STRCPY(NameBuff, \"*****\");\n#endif\n\telse if (opp->flags & P_EXPAND)\n\t    home_replace(NULL, varp, NameBuff, MAXPATHL, FALSE);\n\t// Translate 'pastetoggle' into special key names\n\telse if ((char_u **)opp->var == &p_pt)\n\t    str2specialbuf(p_pt, NameBuff, MAXPATHL);\n\telse\n\t    vim_strncpy(NameBuff, varp, MAXPATHL - 1);\n    }\n}\n\n/*\n * Return TRUE if \"varp\" points to 'wildchar' or 'wildcharm' and it can be\n * printed as a keyname.\n * \"*wcp\" is set to the value of the option if it's 'wildchar' or 'wildcharm'.\n */\n    static int\nwc_use_keyname(char_u *varp, long *wcp)\n{\n    if (((long *)varp == &p_wc) || ((long *)varp == &p_wcm))\n    {\n\t*wcp = *(long *)varp;\n\tif (IS_SPECIAL(*wcp) || find_special_key_in_table((int)*wcp) >= 0)\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE if \"x\" is present in 'shortmess' option, or\n * 'shortmess' contains 'a' and \"x\" is present in SHM_A.\n */\n    int\nshortmess(int x)\n{\n    return p_shm != NULL &&\n\t    (   vim_strchr(p_shm, x) != NULL\n\t    || (vim_strchr(p_shm, 'a') != NULL\n\t\t&& vim_strchr((char_u *)SHM_A, x) != NULL));\n}\n\n/*\n * paste_option_changed() - Called after p_paste was set or reset.\n */\n    static void\npaste_option_changed(void)\n{\n    static int\told_p_paste = FALSE;\n    static int\tsave_sm = 0;\n    static int\tsave_sta = 0;\n#ifdef FEAT_CMDL_INFO\n    static int\tsave_ru = 0;\n#endif\n#ifdef FEAT_RIGHTLEFT\n    static int\tsave_ri = 0;\n    static int\tsave_hkmap = 0;\n#endif\n    buf_T\t*buf;\n\n    if (p_paste)\n    {\n\t/*\n\t * Paste switched from off to on.\n\t * Save the current values, so they can be restored later.\n\t */\n\tif (!old_p_paste)\n\t{\n\t    // save options for each buffer\n\t    FOR_ALL_BUFFERS(buf)\n\t    {\n\t\tbuf->b_p_tw_nopaste = buf->b_p_tw;\n\t\tbuf->b_p_wm_nopaste = buf->b_p_wm;\n\t\tbuf->b_p_sts_nopaste = buf->b_p_sts;\n\t\tbuf->b_p_ai_nopaste = buf->b_p_ai;\n\t\tbuf->b_p_et_nopaste = buf->b_p_et;\n#ifdef FEAT_VARTABS\n\t\tif (buf->b_p_vsts_nopaste)\n\t\t    vim_free(buf->b_p_vsts_nopaste);\n\t\tbuf->b_p_vsts_nopaste = buf->b_p_vsts && buf->b_p_vsts != empty_option\n\t\t\t\t     ? vim_strsave(buf->b_p_vsts) : NULL;\n#endif\n\t    }\n\n\t    // save global options\n\t    save_sm = p_sm;\n\t    save_sta = p_sta;\n#ifdef FEAT_CMDL_INFO\n\t    save_ru = p_ru;\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t    save_ri = p_ri;\n\t    save_hkmap = p_hkmap;\n#endif\n\t    // save global values for local buffer options\n\t    p_ai_nopaste = p_ai;\n\t    p_et_nopaste = p_et;\n\t    p_sts_nopaste = p_sts;\n\t    p_tw_nopaste = p_tw;\n\t    p_wm_nopaste = p_wm;\n#ifdef FEAT_VARTABS\n\t    if (p_vsts_nopaste)\n\t\tvim_free(p_vsts_nopaste);\n\t    p_vsts_nopaste = p_vsts && p_vsts != empty_option ? vim_strsave(p_vsts) : NULL;\n#endif\n\t}\n\n\t/*\n\t * Always set the option values, also when 'paste' is set when it is\n\t * already on.\n\t */\n\t// set options for each buffer\n\tFOR_ALL_BUFFERS(buf)\n\t{\n\t    buf->b_p_tw = 0;\t    // textwidth is 0\n\t    buf->b_p_wm = 0;\t    // wrapmargin is 0\n\t    buf->b_p_sts = 0;\t    // softtabstop is 0\n\t    buf->b_p_ai = 0;\t    // no auto-indent\n\t    buf->b_p_et = 0;\t    // no expandtab\n#ifdef FEAT_VARTABS\n\t    if (buf->b_p_vsts)\n\t\tfree_string_option(buf->b_p_vsts);\n\t    buf->b_p_vsts = empty_option;\n\t    VIM_CLEAR(buf->b_p_vsts_array);\n#endif\n\t}\n\n\t// set global options\n\tp_sm = 0;\t\t    // no showmatch\n\tp_sta = 0;\t\t    // no smarttab\n#ifdef FEAT_CMDL_INFO\n\tif (p_ru)\n\t    status_redraw_all();    // redraw to remove the ruler\n\tp_ru = 0;\t\t    // no ruler\n#endif\n#ifdef FEAT_RIGHTLEFT\n\tp_ri = 0;\t\t    // no reverse insert\n\tp_hkmap = 0;\t\t    // no Hebrew keyboard\n#endif\n\t// set global values for local buffer options\n\tp_tw = 0;\n\tp_wm = 0;\n\tp_sts = 0;\n\tp_ai = 0;\n#ifdef FEAT_VARTABS\n\tif (p_vsts)\n\t    free_string_option(p_vsts);\n\tp_vsts = empty_option;\n#endif\n    }\n\n    /*\n     * Paste switched from on to off: Restore saved values.\n     */\n    else if (old_p_paste)\n    {\n\t// restore options for each buffer\n\tFOR_ALL_BUFFERS(buf)\n\t{\n\t    buf->b_p_tw = buf->b_p_tw_nopaste;\n\t    buf->b_p_wm = buf->b_p_wm_nopaste;\n\t    buf->b_p_sts = buf->b_p_sts_nopaste;\n\t    buf->b_p_ai = buf->b_p_ai_nopaste;\n\t    buf->b_p_et = buf->b_p_et_nopaste;\n#ifdef FEAT_VARTABS\n\t    if (buf->b_p_vsts)\n\t\tfree_string_option(buf->b_p_vsts);\n\t    buf->b_p_vsts = buf->b_p_vsts_nopaste\n\t\t\t ? vim_strsave(buf->b_p_vsts_nopaste) : empty_option;\n\t    vim_free(buf->b_p_vsts_array);\n\t    if (buf->b_p_vsts && buf->b_p_vsts != empty_option)\n\t\t(void)tabstop_set(buf->b_p_vsts, &buf->b_p_vsts_array);\n\t    else\n\t\tbuf->b_p_vsts_array = NULL;\n#endif\n\t}\n\n\t// restore global options\n\tp_sm = save_sm;\n\tp_sta = save_sta;\n#ifdef FEAT_CMDL_INFO\n\tif (p_ru != save_ru)\n\t    status_redraw_all();    // redraw to draw the ruler\n\tp_ru = save_ru;\n#endif\n#ifdef FEAT_RIGHTLEFT\n\tp_ri = save_ri;\n\tp_hkmap = save_hkmap;\n#endif\n\t// set global values for local buffer options\n\tp_ai = p_ai_nopaste;\n\tp_et = p_et_nopaste;\n\tp_sts = p_sts_nopaste;\n\tp_tw = p_tw_nopaste;\n\tp_wm = p_wm_nopaste;\n#ifdef FEAT_VARTABS\n\tif (p_vsts)\n\t    free_string_option(p_vsts);\n\tp_vsts = p_vsts_nopaste ? vim_strsave(p_vsts_nopaste) : empty_option;\n#endif\n    }\n\n    old_p_paste = p_paste;\n}\n\n/*\n * vimrc_found() - Called when a \".vimrc\" or \"VIMINIT\" has been found.\n *\n * Reset 'compatible' and set the values for options that didn't get set yet\n * to the Vim defaults.\n * Don't do this if the 'compatible' option has been set or reset before.\n * When \"fname\" is not NULL, use it to set $\"envname\" when it wasn't set yet.\n */\n    void\nvimrc_found(char_u *fname, char_u *envname)\n{\n    int\t\topt_idx;\n    int\t\tdofree = FALSE;\n    char_u\t*p;\n\n    if (!option_was_set((char_u *)\"cp\"))\n    {\n\tp_cp = FALSE;\n\tfor (opt_idx = 0; !istermoption_idx(opt_idx); opt_idx++)\n\t    if (!(options[opt_idx].flags & (P_WAS_SET|P_VI_DEF)))\n\t\tset_option_default(opt_idx, OPT_FREE, FALSE);\n\tdidset_options();\n\tdidset_options2();\n    }\n\n    if (fname != NULL)\n    {\n\tp = vim_getenv(envname, &dofree);\n\tif (p == NULL)\n\t{\n\t    // Set $MYVIMRC to the first vimrc file found.\n\t    p = FullName_save(fname, FALSE);\n\t    if (p != NULL)\n\t    {\n\t\tvim_setenv(envname, p);\n\t\tvim_free(p);\n\t    }\n\t}\n\telse if (dofree)\n\t    vim_free(p);\n    }\n}\n\n/*\n * Set 'compatible' on or off.  Called for \"-C\" and \"-N\" command line arg.\n */\n    void\nchange_compatible(int on)\n{\n    int\t    opt_idx;\n\n    if (p_cp != on)\n    {\n\tp_cp = on;\n\tcompatible_set();\n    }\n    opt_idx = findoption((char_u *)\"cp\");\n    if (opt_idx >= 0)\n\toptions[opt_idx].flags |= P_WAS_SET;\n}\n\n/*\n * Return TRUE when option \"name\" has been set.\n * Only works correctly for global options.\n */\n    int\noption_was_set(char_u *name)\n{\n    int idx;\n\n    idx = findoption(name);\n    if (idx < 0)\t// unknown option\n\treturn FALSE;\n    if (options[idx].flags & P_WAS_SET)\n\treturn TRUE;\n    return FALSE;\n}\n\n/*\n * Reset the flag indicating option \"name\" was set.\n */\n    int\nreset_option_was_set(char_u *name)\n{\n    int idx = findoption(name);\n\n    if (idx >= 0)\n    {\n\toptions[idx].flags &= ~P_WAS_SET;\n\treturn OK;\n    }\n    return FAIL;\n}\n\n/*\n * compatible_set() - Called when 'compatible' has been set or unset.\n *\n * When 'compatible' set: Set all relevant options (those that have the P_VIM)\n * flag) to a Vi compatible value.\n * When 'compatible' is unset: Set all options that have a different default\n * for Vim (without the P_VI_DEF flag) to that default.\n */\n    static void\ncompatible_set(void)\n{\n    int\t    opt_idx;\n\n    for (opt_idx = 0; !istermoption_idx(opt_idx); opt_idx++)\n\tif (\t   ((options[opt_idx].flags & P_VIM) && p_cp)\n\t\t|| (!(options[opt_idx].flags & P_VI_DEF) && !p_cp))\n\t    set_option_default(opt_idx, OPT_FREE, p_cp);\n    didset_options();\n    didset_options2();\n}\n\n#if defined(FEAT_LINEBREAK) || defined(PROTO)\n\n/*\n * fill_breakat_flags() -- called when 'breakat' changes value.\n */\n    void\nfill_breakat_flags(void)\n{\n    char_u\t*p;\n    int\t\ti;\n\n    for (i = 0; i < 256; i++)\n\tbreakat_flags[i] = FALSE;\n\n    if (p_breakat != NULL)\n\tfor (p = p_breakat; *p; p++)\n\t    breakat_flags[*p] = TRUE;\n}\n#endif\n\n/*\n * Check if backspacing over something is allowed.\n */\n    int\ncan_bs(\n    int\t\twhat)\t    // BS_INDENT, BS_EOL, BS_START or BS_NOSTOP\n{\n#ifdef FEAT_JOB_CHANNEL\n    if (what == BS_START && bt_prompt(curbuf))\n\treturn FALSE;\n#endif\n    switch (*p_bs)\n    {\n\tcase '3':       return TRUE;\n\tcase '2':\treturn (what != BS_NOSTOP);\n\tcase '1':\treturn (what != BS_START);\n\tcase '0':\treturn FALSE;\n    }\n    return vim_strchr(p_bs, what) != NULL;\n}\n\n/*\n * Return the effective 'scrolloff' value for the current window, using the\n * global value when appropriate.\n */\n    long\nget_scrolloff_value(void)\n{\n    return curwin->w_p_so < 0 ? p_so : curwin->w_p_so;\n}\n\n/*\n * Return the effective 'sidescrolloff' value for the current window, using the\n * global value when appropriate.\n */\n    long\nget_sidescrolloff_value(void)\n{\n    return curwin->w_p_siso < 0 ? p_siso : curwin->w_p_siso;\n}\n\n/*\n * Get the local or global value of 'backupcopy'.\n */\n    unsigned int\nget_bkc_value(buf_T *buf)\n{\n    return buf->b_bkc_flags ? buf->b_bkc_flags : bkc_flags;\n}\n\n/*\n * Get the local or global value of 'formatlistpat'.\n */\n    char_u *\nget_flp_value(buf_T *buf)\n{\n    if (buf->b_p_flp == NULL || *buf->b_p_flp == NUL)\n\treturn p_flp;\n    return buf->b_p_flp;\n}\n\n/*\n * Get the local or global value of the 'virtualedit' flags.\n */\n    unsigned int\nget_ve_flags(void)\n{\n    return (curwin->w_ve_flags ? curwin->w_ve_flags : ve_flags)\n\t    & ~(VE_NONE | VE_NONEU);\n}\n\n#if defined(FEAT_LINEBREAK) || defined(PROTO)\n/*\n * Get the local or global value of 'showbreak'.\n */\n    char_u *\nget_showbreak_value(win_T *win)\n{\n    if (win->w_p_sbr == NULL || *win->w_p_sbr == NUL)\n\treturn p_sbr;\n    if (STRCMP(win->w_p_sbr, \"NONE\") == 0)\n\treturn empty_option;\n    return win->w_p_sbr;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Get window or buffer local options.\n */\n    dict_T *\nget_winbuf_options(int bufopt)\n{\n    dict_T\t*d;\n    int\t\topt_idx;\n\n    d = dict_alloc();\n    if (d == NULL)\n\treturn NULL;\n\n    for (opt_idx = 0; !istermoption_idx(opt_idx); opt_idx++)\n    {\n\tstruct vimoption *opt = &options[opt_idx];\n\n\tif ((bufopt && (opt->indir & PV_BUF))\n\t\t\t\t\t || (!bufopt && (opt->indir & PV_WIN)))\n\t{\n\t    char_u *varp = get_varp(opt);\n\n\t    if (varp != NULL)\n\t    {\n\t\tif (opt->flags & P_STRING)\n\t\t    dict_add_string(d, opt->fullname, *(char_u **)varp);\n\t\telse if (opt->flags & P_NUM)\n\t\t    dict_add_number(d, opt->fullname, *(long *)varp);\n\t\telse\n\t\t    dict_add_number(d, opt->fullname, *(int *)varp);\n\t    }\n\t}\n    }\n\n    return d;\n}\n#endif\n\n#if defined(FEAT_SYN_HL) || defined(PROTO)\n/*\n * This is called when 'culopt' is changed\n */\n    int\nfill_culopt_flags(char_u *val, win_T *wp)\n{\n    char_u\t*p;\n    char_u\tculopt_flags_new = 0;\n\n    if (val == NULL)\n\tp = wp->w_p_culopt;\n    else\n\tp = val;\n    while (*p != NUL)\n    {\n\tif (STRNCMP(p, \"line\", 4) == 0)\n\t{\n\t    p += 4;\n\t    culopt_flags_new |= CULOPT_LINE;\n\t}\n\telse if (STRNCMP(p, \"both\", 4) == 0)\n\t{\n\t    p += 4;\n\t    culopt_flags_new |= CULOPT_LINE | CULOPT_NBR;\n\t}\n\telse if (STRNCMP(p, \"number\", 6) == 0)\n\t{\n\t    p += 6;\n\t    culopt_flags_new |= CULOPT_NBR;\n\t}\n\telse if (STRNCMP(p, \"screenline\", 10) == 0)\n\t{\n\t    p += 10;\n\t    culopt_flags_new |= CULOPT_SCRLINE;\n\t}\n\n\tif (*p != ',' && *p != NUL)\n\t    return FAIL;\n\tif (*p == ',')\n\t    ++p;\n    }\n\n    // Can't have both \"line\" and \"screenline\".\n    if ((culopt_flags_new & CULOPT_LINE) && (culopt_flags_new & CULOPT_SCRLINE))\n\treturn FAIL;\n    wp->w_p_culopt_flags = culopt_flags_new;\n\n    return OK;\n}\n#endif\n\n/*\n * Get the value of 'magic' adjusted for Vim9 script.\n */\n    int\nmagic_isset(void)\n{\n    switch (magic_overruled)\n    {\n\tcase OPTION_MAGIC_ON:      return TRUE;\n\tcase OPTION_MAGIC_OFF:     return FALSE;\n\tcase OPTION_MAGIC_NOT_SET: break;\n    }\n#ifdef FEAT_EVAL\n    if (in_vim9script())\n\treturn TRUE;\n#endif\n    return p_magic;\n}\n\n/*\n * Set the callback function value for an option that accepts a function name,\n * lambda, et al. (e.g. 'operatorfunc', 'tagfunc', etc.)\n * Returns OK if the option is successfully set to a function, otherwise\n * returns FAIL.\n */\n    int\noption_set_callback_func(char_u *optval UNUSED, callback_T *optcb UNUSED)\n{\n#ifdef FEAT_EVAL\n    typval_T\t*tv;\n    callback_T\tcb;\n\n    if (optval == NULL || *optval == NUL)\n    {\n\tfree_callback(optcb);\n\treturn OK;\n    }\n\n    if (*optval == '{' || (in_vim9script() && *optval == '(')\n\t    || (STRNCMP(optval, \"function(\", 9) == 0)\n\t    || (STRNCMP(optval, \"funcref(\", 8) == 0))\n\t// Lambda expression or a funcref\n\ttv = eval_expr(optval, NULL);\n    else\n\t// treat everything else as a function name string\n\ttv = alloc_string_tv(vim_strsave(optval));\n    if (tv == NULL)\n\treturn FAIL;\n\n    cb = get_callback(tv);\n    if (cb.cb_name == NULL || *cb.cb_name == NUL)\n    {\n\tfree_tv(tv);\n\treturn FAIL;\n    }\n\n    free_callback(optcb);\n    set_callback(optcb, &cb);\n    free_tv(tv);\n\n    // when using Vim9 style \"import.funcname\" it needs to be expanded to\n    // \"import#funcname\".\n    expand_autload_callback(optcb);\n\n    return OK;\n#else\n    return FAIL;\n#endif\n}\n", "\" Test for options\n\nsource shared.vim\nsource check.vim\nsource view_util.vim\n\nfunc Test_whichwrap()\n  set whichwrap=b,s\n  call assert_equal('b,s', &whichwrap)\n\n  set whichwrap+=h,l\n  call assert_equal('b,s,h,l', &whichwrap)\n\n  set whichwrap+=h,l\n  call assert_equal('b,s,h,l', &whichwrap)\n\n  set whichwrap+=h,l\n  call assert_equal('b,s,h,l', &whichwrap)\n\n  set whichwrap=h,h\n  call assert_equal('h', &whichwrap)\n\n  set whichwrap=h,h,h\n  call assert_equal('h', &whichwrap)\n\n  \" For compatibility with Vim 3.0 and before, number values are also\n  \" supported for 'whichwrap'\n  set whichwrap=1\n  call assert_equal('b', &whichwrap)\n  set whichwrap=2\n  call assert_equal('s', &whichwrap)\n  set whichwrap=4\n  call assert_equal('h,l', &whichwrap)\n  set whichwrap=8\n  call assert_equal('<,>', &whichwrap)\n  set whichwrap=16\n  call assert_equal('[,]', &whichwrap)\n  set whichwrap=31\n  call assert_equal('b,s,h,l,<,>,[,]', &whichwrap)\n\n  set whichwrap&\nendfunc\n\nfunc Test_isfname()\n  \" This used to cause Vim to access uninitialized memory.\n  set isfname=\n  call assert_equal(\"~X\", expand(\"~X\"))\n  set isfname&\nendfunc\n\nfunc Test_wildchar()\n  \" Empty 'wildchar' used to access invalid memory.\n  call assert_fails('set wildchar=', 'E521:')\n  call assert_fails('set wildchar=abc', 'E521:')\n  set wildchar=<Esc>\n  let a=execute('set wildchar?')\n  call assert_equal(\"\\n  wildchar=<Esc>\", a)\n  set wildchar=27\n  let a=execute('set wildchar?')\n  call assert_equal(\"\\n  wildchar=<Esc>\", a)\n  set wildchar&\nendfunc\n\nfunc Test_wildoptions()\n  set wildoptions=\n  set wildoptions+=tagfile\n  set wildoptions+=tagfile\n  call assert_equal('tagfile', &wildoptions)\nendfunc\n\nfunc Test_options_command()\n  let caught = 'ok'\n  try\n    options\n  catch\n    let caught = v:throwpoint . \"\\n\" . v:exception\n  endtry\n  call assert_equal('ok', caught)\n\n  \" Check if the option-window is opened horizontally.\n  wincmd j\n  call assert_notequal('option-window', bufname(''))\n  wincmd k\n  call assert_equal('option-window', bufname(''))\n  \" close option-window\n  close\n\n  \" Open the option-window vertically.\n  vert options\n  \" Check if the option-window is opened vertically.\n  wincmd l\n  call assert_notequal('option-window', bufname(''))\n  wincmd h\n  call assert_equal('option-window', bufname(''))\n  \" close option-window\n  close\n\n  \" Open the option-window at the top.\n  set splitbelow\n  topleft options\n  call assert_equal(1, winnr())\n  close\n\n  \" Open the option-window at the bottom.\n  set nosplitbelow\n  botright options\n  call assert_equal(winnr('$'), winnr())\n  close\n  set splitbelow&\n\n  \" Open the option-window in a new tab.\n  tab options\n  \" Check if the option-window is opened in a tab.\n  normal gT\n  call assert_notequal('option-window', bufname(''))\n  normal gt\n  call assert_equal('option-window', bufname(''))\n  \" close option-window\n  close\n\n  \" Open the options window browse\n  if has('browse')\n    browse set\n    call assert_equal('option-window', bufname(''))\n    close\n  endif\nendfunc\n\nfunc Test_path_keep_commas()\n  \" Test that changing 'path' keeps two commas.\n  set path=foo,,bar\n  set path-=bar\n  set path+=bar\n  call assert_equal('foo,,bar', &path)\n\n  set path&\nendfunc\n\nfunc Test_path_too_long()\n  exe 'set path=' .. repeat('x', 10000)\n  call assert_fails('find x', 'E854:')\n  set path&\nendfunc\n\nfunc Test_signcolumn()\n  CheckFeature signs\n  call assert_equal(\"auto\", &signcolumn)\n  set signcolumn=yes\n  set signcolumn=no\n  call assert_fails('set signcolumn=nope')\nendfunc\n\nfunc Test_filetype_valid()\n  set ft=valid_name\n  call assert_equal(\"valid_name\", &filetype)\n  set ft=valid-name\n  call assert_equal(\"valid-name\", &filetype)\n\n  call assert_fails(\":set ft=wrong;name\", \"E474:\")\n  call assert_fails(\":set ft=wrong\\\\\\\\name\", \"E474:\")\n  call assert_fails(\":set ft=wrong\\\\|name\", \"E474:\")\n  call assert_fails(\":set ft=wrong/name\", \"E474:\")\n  call assert_fails(\":set ft=wrong\\\\\\nname\", \"E474:\")\n  call assert_equal(\"valid-name\", &filetype)\n\n  exe \"set ft=trunc\\x00name\"\n  call assert_equal(\"trunc\", &filetype)\nendfunc\n\nfunc Test_syntax_valid()\n  CheckFeature syntax\n  set syn=valid_name\n  call assert_equal(\"valid_name\", &syntax)\n  set syn=valid-name\n  call assert_equal(\"valid-name\", &syntax)\n\n  call assert_fails(\":set syn=wrong;name\", \"E474:\")\n  call assert_fails(\":set syn=wrong\\\\\\\\name\", \"E474:\")\n  call assert_fails(\":set syn=wrong\\\\|name\", \"E474:\")\n  call assert_fails(\":set syn=wrong/name\", \"E474:\")\n  call assert_fails(\":set syn=wrong\\\\\\nname\", \"E474:\")\n  call assert_equal(\"valid-name\", &syntax)\n\n  exe \"set syn=trunc\\x00name\"\n  call assert_equal(\"trunc\", &syntax)\nendfunc\n\nfunc Test_keymap_valid()\n  CheckFeature keymap\n  call assert_fails(\":set kmp=valid_name\", \"E544:\")\n  call assert_fails(\":set kmp=valid_name\", \"valid_name\")\n  call assert_fails(\":set kmp=valid-name\", \"E544:\")\n  call assert_fails(\":set kmp=valid-name\", \"valid-name\")\n\n  call assert_fails(\":set kmp=wrong;name\", \"E474:\")\n  call assert_fails(\":set kmp=wrong\\\\\\\\name\", \"E474:\")\n  call assert_fails(\":set kmp=wrong\\\\|name\", \"E474:\")\n  call assert_fails(\":set kmp=wrong/name\", \"E474:\")\n  call assert_fails(\":set kmp=wrong\\\\\\nname\", \"E474:\")\n\n  call assert_fails(\":set kmp=trunc\\x00name\", \"E544:\")\n  call assert_fails(\":set kmp=trunc\\x00name\", \"trunc\")\nendfunc\n\nfunc Check_dir_option(name)\n  \" Check that it's possible to set the option.\n  exe 'set ' . a:name . '=/usr/share/dict/words'\n  call assert_equal('/usr/share/dict/words', eval('&' . a:name))\n  exe 'set ' . a:name . '=/usr/share/dict/words,/and/there'\n  call assert_equal('/usr/share/dict/words,/and/there', eval('&' . a:name))\n  exe 'set ' . a:name . '=/usr/share/dict\\ words'\n  call assert_equal('/usr/share/dict words', eval('&' . a:name))\n\n  \" Check rejecting weird characters.\n  call assert_fails(\"set \" . a:name . \"=/not&there\", \"E474:\")\n  call assert_fails(\"set \" . a:name . \"=/not>there\", \"E474:\")\n  call assert_fails(\"set \" . a:name . \"=/not.*there\", \"E474:\")\nendfunc\n\nfunc Test_cinkeys()\n  \" This used to cause invalid memory access\n  set cindent cinkeys=0\n  norm a\n  set cindent& cinkeys&\nendfunc\n\nfunc Test_dictionary()\n  call Check_dir_option('dictionary')\nendfunc\n\nfunc Test_thesaurus()\n  call Check_dir_option('thesaurus')\nendfun\n\nfunc Test_complete()\n  \" Trailing single backslash used to cause invalid memory access.\n  set complete=s\\\n  new\n  call feedkeys(\"i\\<C-N>\\<Esc>\", 'xt')\n  bwipe!\n  call assert_fails('set complete=ix', 'E535:')\n  set complete&\nendfun\n\nfunc Test_set_completion()\n  call feedkeys(\":set di\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set dictionary diff diffexpr diffopt digraph directory display', @:)\n\n  call feedkeys(\":setlocal di\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"setlocal dictionary diff diffexpr diffopt digraph directory display', @:)\n\n  call feedkeys(\":setglobal di\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"setglobal dictionary diff diffexpr diffopt digraph directory display', @:)\n\n  \" Expand boolan options. When doing :set no<Tab>\n  \" vim displays the options names without \"no\" but completion uses \"no...\".\n  call feedkeys(\":set nodi\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set nodiff digraph', @:)\n\n  call feedkeys(\":set invdi\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set invdiff digraph', @:)\n\n  \" Expand abbreviation of options.\n  call feedkeys(\":set ts\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set tabstop thesaurus thesaurusfunc ttyscroll', @:)\n\n  \" Expand current value\n  call feedkeys(\":set fileencodings=\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set fileencodings=ucs-bom,utf-8,default,latin1', @:)\n\n  call feedkeys(\":set fileencodings:\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set fileencodings:ucs-bom,utf-8,default,latin1', @:)\n\n  \" Expand key codes.\n  call feedkeys(\":set <H\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set <Help> <Home>', @:)\n\n  \" Expand terminal options.\n  call feedkeys(\":set t_A\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set t_AB t_AF t_AU t_AL', @:)\n  call assert_fails('call feedkeys(\":set <t_afoo>=\\<C-A>\\<CR>\", \"xt\")', 'E474:')\n\n  \" Expand directories.\n  call feedkeys(\":set cdpath=./\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match(' ./samples/ ', @:)\n  call assert_notmatch(' ./summarize.vim ', @:)\n\n  \" Expand files and directories.\n  call feedkeys(\":set tags=./\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match(' ./samples/.* ./summarize.vim', @:)\n\n  call feedkeys(\":set tags=./\\\\\\\\ dif\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set tags=./\\\\ diff diffexpr diffopt', @:)\n  set tags&\n\n  \" Expanding the option names\n  call feedkeys(\":set \\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"set all', @:)\n\n  \" Expanding a second set of option names\n  call feedkeys(\":set wrapscan \\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"set wrapscan all', @:)\n\n  \" Expanding a special keycode\n  call feedkeys(\":set <Home>\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"set <Home>', @:)\n\n  \" Expanding an invalid special keycode\n  call feedkeys(\":set <abcd>\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"set <abcd>\\<Tab>\", @:)\n\n  \" Expanding a terminal keycode\n  call feedkeys(\":set t_AB\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"set t_AB\", @:)\n\n  \" Expanding an invalid option name\n  call feedkeys(\":set abcde=\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"set abcde=\\<Tab>\", @:)\n\n  \" Expanding after a = for a boolean option\n  call feedkeys(\":set wrapscan=\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"set wrapscan=\\<Tab>\", @:)\n\n  \" Expanding a numeric option\n  call feedkeys(\":set tabstop+=\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"set tabstop+=\" .. &tabstop, @:)\n\n  \" Expanding a non-boolean option\n  call feedkeys(\":set invtabstop=\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"set invtabstop=\", @:)\n\n  \" Expand options for 'spellsuggest'\n  call feedkeys(\":set spellsuggest=best,file:xyz\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"set spellsuggest=best,file:xyz\", @:)\n\n  \" Expand value for 'key'\n  set key=abcd\n  call feedkeys(\":set key=\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"set key=*****', @:)\n  set key=\n\n  \" Expand values for 'filetype'\n  call feedkeys(\":set filetype=sshdconfi\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"set filetype=sshdconfig', @:)\n  call feedkeys(\":set filetype=a\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"set filetype=' .. getcompletion('a*', 'filetype')->join(), @:)\nendfunc\n\nfunc Test_set_errors()\n  call assert_fails('set scroll=-1', 'E49:')\n  call assert_fails('set backupcopy=', 'E474:')\n  call assert_fails('set regexpengine=3', 'E474:')\n  call assert_fails('set history=10001', 'E474:')\n  call assert_fails('set numberwidth=21', 'E474:')\n  call assert_fails('set colorcolumn=-a', 'E474:')\n  call assert_fails('set colorcolumn=a', 'E474:')\n  call assert_fails('set colorcolumn=1,', 'E474:')\n  call assert_fails('set colorcolumn=1;', 'E474:')\n  call assert_fails('set cmdheight=-1', 'E487:')\n  call assert_fails('set cmdwinheight=-1', 'E487:')\n  if has('conceal')\n    call assert_fails('set conceallevel=-1', 'E487:')\n    call assert_fails('set conceallevel=4', 'E474:')\n  endif\n  call assert_fails('set helpheight=-1', 'E487:')\n  call assert_fails('set history=-1', 'E487:')\n  call assert_fails('set report=-1', 'E487:')\n  call assert_fails('set shiftwidth=-1', 'E487:')\n  call assert_fails('set sidescroll=-1', 'E487:')\n  call assert_fails('set tabstop=-1', 'E487:')\n  call assert_fails('set tabstop=10000', 'E474:')\n  call assert_fails('set tabstop=5500000000', 'E474:')\n  call assert_fails('set textwidth=-1', 'E487:')\n  call assert_fails('set timeoutlen=-1', 'E487:')\n  call assert_fails('set updatecount=-1', 'E487:')\n  call assert_fails('set updatetime=-1', 'E487:')\n  call assert_fails('set winheight=-1', 'E487:')\n  call assert_fails('set tabstop!', 'E488:')\n  call assert_fails('set xxx', 'E518:')\n  call assert_fails('set beautify?', 'E519:')\n  call assert_fails('set undolevels=x', 'E521:')\n  call assert_fails('set tabstop=', 'E521:')\n  call assert_fails('set comments=-', 'E524:')\n  call assert_fails('set comments=a', 'E525:')\n  call assert_fails('set foldmarker=x', 'E536:')\n  call assert_fails('set commentstring=x', 'E537:')\n  call assert_fails('set complete=x', 'E539:')\n  call assert_fails('set rulerformat=%-', 'E539:')\n  call assert_fails('set rulerformat=%(', 'E542:')\n  call assert_fails('set rulerformat=%15(%%', 'E542:')\n  call assert_fails('set statusline=%$', 'E539:')\n  call assert_fails('set statusline=%{', 'E540:')\n  call assert_fails('set statusline=%(', 'E542:')\n  call assert_fails('set statusline=%)', 'E542:')\n\n  if has('cursorshape')\n    \" This invalid value for 'guicursor' used to cause Vim to crash.\n    call assert_fails('set guicursor=i-ci,r-cr:h', 'E545:')\n    call assert_fails('set guicursor=i-ci', 'E545:')\n    call assert_fails('set guicursor=x', 'E545:')\n    call assert_fails('set guicursor=x:', 'E546:')\n    call assert_fails('set guicursor=r-cr:horx', 'E548:')\n    call assert_fails('set guicursor=r-cr:hor0', 'E549:')\n  endif\n  if has('mouseshape')\n    call assert_fails('se mouseshape=i-r:x', 'E547:')\n  endif\n  call assert_fails('set backupext=~ patchmode=~', 'E589:')\n  call assert_fails('set winminheight=10 winheight=9', 'E591:')\n  set winminheight& winheight&\n  set winheight=10 winminheight=10\n  call assert_fails('set winheight=9', 'E591:')\n  set winminheight& winheight&\n  call assert_fails('set winminwidth=10 winwidth=9', 'E592:')\n  set winminwidth& winwidth&\n  call assert_fails('set winwidth=9 winminwidth=10', 'E592:')\n  set winwidth& winminwidth&\n  call assert_fails(\"set showbreak=\\x01\", 'E595:')\n  call assert_fails('set t_foo=', 'E846:')\n  call assert_fails('set tabstop??', 'E488:')\n  call assert_fails('set wrapscan!!', 'E488:')\n  call assert_fails('set tabstop&&', 'E488:')\n  call assert_fails('set wrapscan<<', 'E488:')\n  call assert_fails('set wrapscan=1', 'E474:')\n  call assert_fails('set autoindent@', 'E488:')\n  call assert_fails('set wildchar=<abc>', 'E474:')\n  call assert_fails('set cmdheight=1a', 'E521:')\n  call assert_fails('set invcmdheight', 'E474:')\n  if has('python') || has('python3')\n    call assert_fails('set pyxversion=6', 'E474:')\n  endif\n  call assert_fails(\"let &tabstop='ab'\", 'E521:')\n  call assert_fails('set spellcapcheck=%\\\\(', 'E54:')\n  call assert_fails('set sessionoptions=curdir,sesdir', 'E474:')\n  call assert_fails('set foldmarker={{{,', 'E474:')\n  call assert_fails('set sessionoptions=sesdir,curdir', 'E474:')\n  call assert_fails('set listchars=trail:\u00b7 ambiwidth=double', 'E834:')\n  set listchars&\n  call assert_fails('set fillchars=stl:\u00b7 ambiwidth=double', 'E835:')\n  set fillchars&\n  call assert_fails('set fileencoding=latin1,utf-8', 'E474:')\n  set nomodifiable\n  call assert_fails('set fileencoding=latin1', 'E21:')\n  set modifiable&\n  call assert_fails('set t_#-&', 'E522:')\nendfunc\n\nfunc CheckWasSet(name)\n  let verb_cm = execute('verbose set ' .. a:name .. '?')\n  call assert_match('Last set from.*test_options.vim', verb_cm)\nendfunc\nfunc CheckWasNotSet(name)\n  let verb_cm = execute('verbose set ' .. a:name .. '?')\n  call assert_notmatch('Last set from', verb_cm)\nendfunc\n\n\" Must be executed before other tests that set 'term'.\nfunc Test_000_term_option_verbose()\n  CheckNotGui\n\n  call CheckWasNotSet('t_cm')\n\n  let term_save = &term\n  set term=ansi\n  call CheckWasSet('t_cm')\n  let &term = term_save\nendfunc\n\nfunc Test_copy_context()\n  setlocal list\n  call CheckWasSet('list')\n  split\n  call CheckWasSet('list')\n  quit\n  setlocal nolist\n\n  set ai\n  call CheckWasSet('ai')\n  set filetype=perl\n  call CheckWasSet('filetype')\n  set fo=tcroq\n  call CheckWasSet('fo')\n\n  split Xsomebuf\n  call CheckWasSet('ai')\n  call CheckWasNotSet('filetype')\n  call CheckWasSet('fo')\nendfunc\n\nfunc Test_set_ttytype()\n  CheckUnix\n  CheckNotGui\n\n  \" Setting 'ttytype' used to cause a double-free when exiting vim and\n  \" when vim is compiled with -DEXITFREE.\n  set ttytype=ansi\n  call assert_equal('ansi', &ttytype)\n  call assert_equal(&ttytype, &term)\n  set ttytype=xterm\n  call assert_equal('xterm', &ttytype)\n  call assert_equal(&ttytype, &term)\n  try\n    set ttytype=\n    call assert_report('set ttytype= did not fail')\n  catch /E529/\n  endtry\n\n  \" Some systems accept any terminal name and return dumb settings,\n  \" check for failure of finding the entry and for missing 'cm' entry.\n  try\n    set ttytype=xxx\n    call assert_report('set ttytype=xxx did not fail')\n  catch /E522\\|E437/\n  endtry\n\n  set ttytype&\n  call assert_equal(&ttytype, &term)\n\n  if has('gui') && !has('gui_running')\n    call assert_fails('set term=gui', 'E531:')\n  endif\nendfunc\n\nfunc Test_set_all()\n  set tw=75\n  set iskeyword=a-z,A-Z\n  set nosplitbelow\n  let out = execute('set all')\n  call assert_match('textwidth=75', out)\n  call assert_match('iskeyword=a-z,A-Z', out)\n  call assert_match('nosplitbelow', out)\n  set tw& iskeyword& splitbelow&\nendfunc\n\nfunc Test_set_one_column()\n  let out_mult = execute('set all')->split(\"\\n\")\n  let out_one = execute('set! all')->split(\"\\n\")\n  call assert_true(len(out_mult) < len(out_one))\nendfunc\n\nfunc Test_set_values()\n  \" opt_test.vim is generated from ../optiondefs.h using gen_opt_test.vim\n  if filereadable('opt_test.vim')\n    source opt_test.vim\n  else\n    throw 'Skipped: opt_test.vim does not exist'\n  endif\nendfunc\n\nfunc Test_renderoptions()\n  \" Only do this for Windows Vista and later, fails on Windows XP and earlier.\n  \" Doesn't hurt to do this on a non-Windows system.\n  if windowsversion() !~ '^[345]\\.'\n    set renderoptions=type:directx\n    set rop=type:directx\n  endif\nendfunc\n\nfunc ResetIndentexpr()\n  set indentexpr=\nendfunc\n\nfunc Test_set_indentexpr()\n  \" this was causing usage of freed memory\n  set indentexpr=ResetIndentexpr()\n  new\n  call feedkeys(\"i\\<c-f>\", 'x')\n  call assert_equal('', &indentexpr)\n  bwipe!\nendfunc\n\nfunc Test_backupskip()\n  \" Option 'backupskip' may contain several comma-separated path\n  \" specifications if one or more of the environment variables TMPDIR, TMP,\n  \" or TEMP is defined.  To simplify testing, convert the string value into a\n  \" list.\n  let bsklist = split(&bsk, ',')\n\n  if has(\"mac\")\n    let found = (index(bsklist, '/private/tmp/*') >= 0)\n    call assert_true(found, '/private/tmp not in option bsk: ' . &bsk)\n  elseif has(\"unix\")\n    let found = (index(bsklist, '/tmp/*') >= 0)\n    call assert_true(found, '/tmp not in option bsk: ' . &bsk)\n  endif\n\n  \" If our test platform is Windows, the path(s) in option bsk will use\n  \" backslash for the path separator and the components could be in short\n  \" (8.3) format.  As such, we need to replace the backslashes with forward\n  \" slashes and convert the path components to long format.  The expand()\n  \" function will do this but it cannot handle comma-separated paths.  This is\n  \" why bsk was converted from a string into a list of strings above.\n  \"\n  \" One final complication is that the wildcard \"/*\" is at the end of each\n  \" path and so expand() might return a list of matching files.  To prevent\n  \" this, we need to remove the wildcard before calling expand() and then\n  \" append it afterwards.\n  if has('win32')\n    let item_nbr = 0\n    while item_nbr < len(bsklist)\n      let path_spec = bsklist[item_nbr]\n      let path_spec = strcharpart(path_spec, 0, strlen(path_spec)-2)\n      let path_spec = substitute(expand(path_spec), '\\\\', '/', 'g')\n      let bsklist[item_nbr] = path_spec . '/*'\n      let item_nbr += 1\n    endwhile\n  endif\n\n  \" Option bsk will also include these environment variables if defined.\n  \" If they're defined, verify they appear in the option value.\n  for var in  ['$TMPDIR', '$TMP', '$TEMP']\n    if exists(var)\n      let varvalue = substitute(expand(var), '\\\\', '/', 'g')\n      let varvalue = substitute(varvalue, '/$', '', '')\n      let varvalue .= '/*'\n      let found = (index(bsklist, varvalue) >= 0)\n      call assert_true(found, var . ' (' . varvalue . ') not in option bsk: ' . &bsk)\n    endif\n  endfor\n\n  \" Duplicates from environment variables should be filtered out (option has\n  \" P_NODUP).  Run this in a separate instance and write v:errors in a file,\n  \" so that we see what happens on startup.\n  let after =<< trim [CODE]\n      let bsklist = split(&backupskip, ',')\n      call assert_equal(uniq(copy(bsklist)), bsklist)\n      call writefile(['errors:'] + v:errors, 'Xtestout')\n      qall\n  [CODE]\n  call writefile(after, 'Xafter')\n  let cmd = GetVimProg() . ' --not-a-term -S Xafter --cmd \"set enc=utf8\"'\n\n  let saveenv = {}\n  for var in ['TMPDIR', 'TMP', 'TEMP']\n    let saveenv[var] = getenv(var)\n    call setenv(var, '/duplicate/path')\n  endfor\n\n  exe 'silent !' . cmd\n  call assert_equal(['errors:'], readfile('Xtestout'))\n\n  \" restore environment variables\n  for var in ['TMPDIR', 'TMP', 'TEMP']\n    call setenv(var, saveenv[var])\n  endfor\n\n  call delete('Xtestout')\n  call delete('Xafter')\n\n  \" Duplicates should be filtered out (option has P_NODUP)\n  let backupskip = &backupskip\n  set backupskip=\n  set backupskip+=/test/dir\n  set backupskip+=/other/dir\n  set backupskip+=/test/dir\n  call assert_equal('/test/dir,/other/dir', &backupskip)\n  let &backupskip = backupskip\nendfunc\n\nfunc Test_copy_winopt()\n  set hidden\n\n  \" Test copy option from current buffer in window\n  split\n  enew\n  setlocal numberwidth=5\n  wincmd w\n  call assert_equal(4,&numberwidth)\n  bnext\n  call assert_equal(5,&numberwidth)\n  bw!\n  call assert_equal(4,&numberwidth)\n\n  \" Test copy value from window that used to be display the buffer\n  split\n  enew\n  setlocal numberwidth=6\n  bnext\n  wincmd w\n  call assert_equal(4,&numberwidth)\n  bnext\n  call assert_equal(6,&numberwidth)\n  bw!\n\n  \" Test that if buffer is current, don't use the stale cached value\n  \" from the last time the buffer was displayed.\n  split\n  enew\n  setlocal numberwidth=7\n  bnext\n  bnext\n  setlocal numberwidth=8\n  wincmd w\n  call assert_equal(4,&numberwidth)\n  bnext\n  call assert_equal(8,&numberwidth)\n  bw!\n\n  \" Test value is not copied if window already has seen the buffer\n  enew\n  split\n  setlocal numberwidth=9\n  bnext\n  setlocal numberwidth=10\n  wincmd w\n  call assert_equal(4,&numberwidth)\n  bnext\n  call assert_equal(4,&numberwidth)\n  bw!\n\n  set hidden&\nendfunc\n\nfunc Test_shortmess_F()\n  new\n  call assert_match('\\[No Name\\]', execute('file'))\n  set shortmess+=F\n  call assert_match('\\[No Name\\]', execute('file'))\n  call assert_match('^\\s*$', execute('file foo'))\n  call assert_match('foo', execute('file'))\n  set shortmess-=F\n  call assert_match('bar', execute('file bar'))\n  call assert_match('bar', execute('file'))\n  set shortmess&\n  bwipe\nendfunc\n\nfunc Test_shortmess_F2()\n  e file1\n  e file2\n  call assert_match('file1', execute('bn', ''))\n  call assert_match('file2', execute('bn', ''))\n  set shortmess+=F\n  call assert_true(empty(execute('bn', '')))\n  call assert_false(test_getvalue('need_fileinfo'))\n  call assert_true(empty(execute('bn', '')))\n  call assert_false('need_fileinfo'->test_getvalue())\n  set hidden\n  call assert_true(empty(execute('bn', '')))\n  call assert_false(test_getvalue('need_fileinfo'))\n  call assert_true(empty(execute('bn', '')))\n  call assert_false(test_getvalue('need_fileinfo'))\n  set nohidden\n  call assert_true(empty(execute('bn', '')))\n  call assert_false(test_getvalue('need_fileinfo'))\n  call assert_true(empty(execute('bn', '')))\n  call assert_false(test_getvalue('need_fileinfo'))\n  set shortmess&\n  call assert_match('file1', execute('bn', ''))\n  call assert_match('file2', execute('bn', ''))\n  bwipe\n  bwipe\nendfunc\n\nfunc Test_local_scrolloff()\n  set so=5\n  set siso=7\n  split\n  call assert_equal(5, &so)\n  setlocal so=3\n  call assert_equal(3, &so)\n  wincmd w\n  call assert_equal(5, &so)\n  wincmd w\n  setlocal so<\n  call assert_equal(5, &so)\n  setlocal so=0\n  call assert_equal(0, &so)\n  setlocal so=-1\n  call assert_equal(5, &so)\n\n  call assert_equal(7, &siso)\n  setlocal siso=3\n  call assert_equal(3, &siso)\n  wincmd w\n  call assert_equal(7, &siso)\n  wincmd w\n  setlocal siso<\n  call assert_equal(7, &siso)\n  setlocal siso=0\n  call assert_equal(0, &siso)\n  setlocal siso=-1\n  call assert_equal(7, &siso)\n\n  close\n  set so&\n  set siso&\nendfunc\n\nfunc Test_writedelay()\n  CheckFunction reltimefloat\n\n  new\n  call setline(1, 'empty')\n  redraw\n  set writedelay=10\n  let start = reltime()\n  call setline(1, repeat('x', 70))\n  redraw\n  let elapsed = reltimefloat(reltime(start))\n  set writedelay=0\n  \" With 'writedelay' set should take at least 30 * 10 msec\n  call assert_inrange(30 * 0.01, 999.0, elapsed)\n\n  bwipe!\nendfunc\n\nfunc Test_visualbell()\n  set belloff=\n  set visualbell\n  call assert_beeps('normal 0h')\n  set novisualbell\n  set belloff=all\nendfunc\n\n\" Test for the 'write' option\nfunc Test_write()\n  new\n  call setline(1, ['L1'])\n  set nowrite\n  call assert_fails('write Xfile', 'E142:')\n  set write\n  close!\nendfunc\n\n\" Test for 'buftype' option\nfunc Test_buftype()\n  new\n  call setline(1, ['L1'])\n  set buftype=nowrite\n  call assert_fails('write', 'E382:')\n\n  for val in ['', 'nofile', 'nowrite', 'acwrite', 'quickfix', 'help', 'terminal', 'prompt', 'popup']\n    exe 'set buftype=' .. val\n    call writefile(['something'], 'XBuftype')\n    call assert_fails('write XBuftype', 'E13:', 'with buftype=' .. val)\n  endfor\n\n  call delete('XBuftype')\n  bwipe!\nendfunc\n\n\" Test for the 'rightleftcmd' option\nfunc Test_rightleftcmd()\n  CheckFeature rightleft\n  set rightleft\n  set rightleftcmd\n\n  let g:l = []\n  func AddPos()\n    call add(g:l, screencol())\n    return ''\n  endfunc\n  cmap <expr> <F2> AddPos()\n\n  call feedkeys(\"/\\<F2>abc\\<Left>\\<F2>\\<Right>\\<Right>\\<F2>\" ..\n        \\ \"\\<Left>\\<F2>\\<Esc>\", 'xt')\n  call assert_equal([&co - 1, &co - 4, &co - 2, &co - 3], g:l)\n\n  cunmap <F2>\n  unlet g:l\n  set rightleftcmd&\n  set rightleft&\nendfunc\n\n\" Test for the \"debug\" option\nfunc Test_debug_option()\n  set debug=beep\n  exe \"normal \\<C-c>\"\n  call assert_equal('Beep!', Screenline(&lines))\n  set debug&\nendfunc\n\n\" Test for the default CDPATH option\nfunc Test_opt_default_cdpath()\n  CheckFeature file_in_path\n  let after =<< trim [CODE]\n    call assert_equal(',/path/to/dir1,/path/to/dir2', &cdpath)\n    call writefile(v:errors, 'Xtestout')\n    qall\n  [CODE]\n  if has('unix')\n    let $CDPATH='/path/to/dir1:/path/to/dir2'\n  else\n    let $CDPATH='/path/to/dir1;/path/to/dir2'\n  endif\n  if RunVim([], after, '')\n    call assert_equal([], readfile('Xtestout'))\n    call delete('Xtestout')\n  endif\nendfunc\n\n\" Test for setting keycodes using set\nfunc Test_opt_set_keycode()\n  call assert_fails('set <t_k1=l', 'E474:')\n  call assert_fails('set <Home=l', 'E474:')\n  set <t_k9>=abcd\n  call assert_equal('abcd', &t_k9)\n  set <t_k9>&\n  set <F9>=xyz\n  call assert_equal('xyz', &t_k9)\n  set <t_k9>&\nendfunc\n\n\" Test for changing options in a sandbox\nfunc Test_opt_sandbox()\n  for opt in ['backupdir', 'cdpath', 'exrc']\n    call assert_fails('sandbox set ' .. opt .. '?', 'E48:')\n    call assert_fails('sandbox let &' .. opt .. ' = 1', 'E48:')\n  endfor\n  call assert_fails('sandbox let &modelineexpr = 1', 'E48:')\nendfunc\n\n\" Test for setting an option with local value to global value\nfunc Test_opt_local_to_global()\n  setglobal equalprg=gprg\n  setlocal equalprg=lprg\n  call assert_equal('gprg', &g:equalprg)\n  call assert_equal('lprg', &l:equalprg)\n  call assert_equal('lprg', &equalprg)\n  set equalprg<\n  call assert_equal('', &l:equalprg)\n  call assert_equal('gprg', &equalprg)\n  setglobal equalprg=gnewprg\n  setlocal equalprg=lnewprg\n  setlocal equalprg<\n  call assert_equal('gnewprg', &l:equalprg)\n  call assert_equal('gnewprg', &equalprg)\n  set equalprg&\n\n  \" Test for setting the global/local value of a boolean option\n  setglobal autoread\n  setlocal noautoread\n  call assert_false(&autoread)\n  set autoread<\n  call assert_true(&autoread)\n  setglobal noautoread\n  setlocal autoread\n  setlocal autoread<\n  call assert_false(&autoread)\n  set autoread&\nendfunc\n\nfunc Test_set_in_sandbox()\n  \" Some boolean options cannot be set in sandbox, some can.\n  call assert_fails('sandbox set modelineexpr', 'E48:')\n  sandbox set number\n  call assert_true(&number)\n  set number&\n\n  \" Some boolean options cannot be set in sandbox, some can.\n  if has('python') || has('python3')\n    call assert_fails('sandbox set pyxversion=3', 'E48:')\n  endif\n  sandbox set tabstop=4\n  call assert_equal(4, &tabstop)\n  set tabstop&\n\n  \" Some string options cannot be set in sandbox, some can.\n  call assert_fails('sandbox set backupdir=/tmp', 'E48:')\n  sandbox set filetype=perl\n  call assert_equal('perl', &filetype)\n  set filetype&\nendfunc\n\n\" Test for incrementing, decrementing and multiplying a number option value\nfunc Test_opt_num_op()\n  set shiftwidth=4\n  set sw+=2\n  call assert_equal(6, &sw)\n  set sw-=2\n  call assert_equal(4, &sw)\n  set sw^=2\n  call assert_equal(8, &sw)\n  set shiftwidth&\nendfunc\n\n\" Test for setting option values using v:false and v:true\nfunc Test_opt_boolean()\n  set number&\n  set number\n  call assert_equal(1, &nu)\n  set nonu\n  call assert_equal(0, &nu)\n  let &nu = v:true\n  call assert_equal(1, &nu)\n  let &nu = v:false\n  call assert_equal(0, &nu)\n  set number&\nendfunc\n\n\" Test for the 'window' option\nfunc Test_window_opt()\n  \" Needs only one open widow\n  %bw!\n  call setline(1, range(1, 8))\n  set window=5\n  exe \"normal \\<C-F>\"\n  call assert_equal(4, line('w0'))\n  exe \"normal \\<C-F>\"\n  call assert_equal(7, line('w0'))\n  exe \"normal \\<C-F>\"\n  call assert_equal(8, line('w0'))\n  exe \"normal \\<C-B>\"\n  call assert_equal(5, line('w0'))\n  exe \"normal \\<C-B>\"\n  call assert_equal(2, line('w0'))\n  exe \"normal \\<C-B>\"\n  call assert_equal(1, line('w0'))\n  set window=1\n  exe \"normal gg\\<C-F>\"\n  call assert_equal(2, line('w0'))\n  exe \"normal \\<C-F>\"\n  call assert_equal(3, line('w0'))\n  exe \"normal \\<C-B>\"\n  call assert_equal(2, line('w0'))\n  exe \"normal \\<C-B>\"\n  call assert_equal(1, line('w0'))\n  enew!\n  set window&\nendfunc\n\n\" Test for the 'winminheight' option\nfunc Test_opt_winminheight()\n  only!\n  let &winheight = &lines + 4\n  call assert_fails('let &winminheight = &lines + 2', 'E36:')\n  call assert_true(&winminheight <= &lines)\n  set winminheight&\n  set winheight&\nendfunc\n\nfunc Test_opt_winminheight_term()\n  CheckRunVimInTerminal\n\n  \" The tabline should be taken into account.\n  let lines =<< trim END\n    set wmh=0 stal=2\n    below sp | wincmd _\n    below sp | wincmd _\n    below sp | wincmd _\n    below sp\n  END\n  call writefile(lines, 'Xwinminheight')\n  let buf = RunVimInTerminal('-S Xwinminheight', #{rows: 11})\n  call term_sendkeys(buf, \":set wmh=1\\n\")\n  call WaitForAssert({-> assert_match('E36: Not enough room', term_getline(buf, 11))})\n\n  call StopVimInTerminal(buf)\n  call delete('Xwinminheight')\nendfunc\n\nfunc Test_opt_winminheight_term_tabs()\n  CheckRunVimInTerminal\n\n  \" The tabline should be taken into account.\n  let lines =<< trim END\n    set wmh=0 stal=2\n    split\n    split\n    split\n    split\n    tabnew\n  END\n  call writefile(lines, 'Xwinminheight')\n  let buf = RunVimInTerminal('-S Xwinminheight', #{rows: 11})\n  call term_sendkeys(buf, \":set wmh=1\\n\")\n  call WaitForAssert({-> assert_match('E36: Not enough room', term_getline(buf, 11))})\n\n  call StopVimInTerminal(buf)\n  call delete('Xwinminheight')\nendfunc\n\n\" Test for the 'winminwidth' option\nfunc Test_opt_winminwidth()\n  only!\n  let &winwidth = &columns + 4\n  call assert_fails('let &winminwidth = &columns + 2', 'E36:')\n  call assert_true(&winminwidth <= &columns)\n  set winminwidth&\n  set winwidth&\nendfunc\n\n\" Test for setting option value containing spaces with isfname+=32\nfunc Test_isfname_with_options()\n  set isfname+=32\n  setlocal keywordprg=:term\\ help.exe\n  call assert_equal(':term help.exe', &keywordprg)\n  set isfname&\n  setlocal keywordprg&\nendfunc\n\n\" Test that resetting laststatus does change scroll option\nfunc Test_opt_reset_scroll()\n  CheckRunVimInTerminal\n  let vimrc =<< trim [CODE]\n    set scroll=2\n    set laststatus=2\n  [CODE]\n  call writefile(vimrc, 'Xscroll')\n  let buf = RunVimInTerminal('-S Xscroll', {'rows': 16, 'cols': 45})\n  call term_sendkeys(buf, \":verbose set scroll?\\n\")\n  call WaitForAssert({-> assert_match('Last set.*window size', term_getline(buf, 15))})\n  call assert_match('^\\s*scroll=7$', term_getline(buf, 14))\n  call StopVimInTerminal(buf)\n\n  \" clean up\n  call delete('Xscroll')\nendfunc\n\n\" Check that VIM_POSIX env variable influences default value of 'cpo' and 'shm'\nfunc Test_VIM_POSIX()\n  let saved_VIM_POSIX = getenv(\"VIM_POSIX\")\n\n  call setenv('VIM_POSIX', \"1\")\n  let after =<< trim [CODE]\n    call writefile([&cpo, &shm], 'X_VIM_POSIX')\n    qall\n  [CODE]\n  if RunVim([], after, '')\n    call assert_equal(['aAbBcCdDeEfFgHiIjJkKlLmMnoOpPqrRsStuvwWxXyZ$!%*-+<>#{|&/\\.;',\n          \\            'AS'], readfile('X_VIM_POSIX'))\n  endif\n\n  call setenv('VIM_POSIX', v:null)\n  let after =<< trim [CODE]\n    call writefile([&cpo, &shm], 'X_VIM_POSIX')\n    qall\n  [CODE]\n  if RunVim([], after, '')\n    call assert_equal(['aAbBcCdDeEfFgHiIjJkKlLmMnoOpPqrRsStuvwWxXyZ$!%*-+<>;',\n          \\            'S'], readfile('X_VIM_POSIX'))\n  endif\n\n  call delete('X_VIM_POSIX')\n  call setenv('VIM_POSIX', saved_VIM_POSIX)\nendfunc\n\n\" Test for setting an option to a Vi or Vim default\nfunc Test_opt_default()\n  set formatoptions&vi\n  call assert_equal('vt', &formatoptions)\n  set formatoptions&vim\n  call assert_equal('tcq', &formatoptions)\n\n  call assert_equal('ucs-bom,utf-8,default,latin1', &fencs)\n  set fencs=latin1\n  set fencs&\n  call assert_equal('ucs-bom,utf-8,default,latin1', &fencs)\n  set fencs=latin1\n  set all&\n  call assert_equal('ucs-bom,utf-8,default,latin1', &fencs)\nendfunc\n\n\" Test for the 'cmdheight' option\nfunc Test_cmdheight()\n  %bw!\n  let ht = &lines\n  set cmdheight=9999\n  call assert_equal(1, winheight(0))\n  call assert_equal(ht - 1, &cmdheight)\n  set cmdheight&\nendfunc\n\n\" To specify a control character as an option value, '^' can be used\nfunc Test_opt_control_char()\n  set wildchar=^v\n  call assert_equal(\"\\<C-V>\", nr2char(&wildchar))\n  set wildcharm=^r\n  call assert_equal(\"\\<C-R>\", nr2char(&wildcharm))\n  \" Bug: This doesn't work for the 'cedit' and 'termwinkey' options\n  set wildchar& wildcharm&\nendfunc\n\n\" Test for the 'errorbells' option\nfunc Test_opt_errorbells()\n  set errorbells\n  call assert_beeps('s/a1b2/x1y2/')\n  set noerrorbells\nendfunc\n\nfunc Test_opt_scrolljump()\n  help\n  resize 10\n\n  \" Test with positive 'scrolljump'.\n  set scrolljump=2\n  norm! Lj\n  call assert_equal({'lnum':11, 'leftcol':0, 'col':0, 'topfill':0,\n        \\            'topline':3, 'coladd':0, 'skipcol':0, 'curswant':0},\n        \\           winsaveview())\n\n  \" Test with negative 'scrolljump' (percentage of window height).\n  set scrolljump=-40\n  norm! ggLj\n  call assert_equal({'lnum':11, 'leftcol':0, 'col':0, 'topfill':0,\n         \\            'topline':5, 'coladd':0, 'skipcol':0, 'curswant':0},\n         \\           winsaveview())\n\n  set scrolljump&\n  bw\nendfunc\n\n\" Test for the 'cdhome' option\nfunc Test_opt_cdhome()\n  if has('unix') || has('vms')\n    throw 'Skipped: only works on non-Unix'\n  endif\n\n  set cdhome&\n  call assert_equal(0, &cdhome)\n  set cdhome\n\n  \" This paragraph is copied from Test_cd_no_arg().\n  let path = getcwd()\n  cd\n  call assert_equal($HOME, getcwd())\n  call assert_notequal(path, getcwd())\n  exe 'cd ' .. fnameescape(path)\n  call assert_equal(path, getcwd())\n\n  set cdhome&\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    4245,\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n */\n\n#ifndef VIM__H\n# define VIM__H\n\n#include \"protodef.h\"\n\n// _WIN32 is defined as 1 when the compilation target is 32-bit or 64-bit.\n// Note: If you want to check for 64-bit use the _WIN64 macro.\n#if defined(WIN32) || defined(_WIN32)\n# define MSWIN\n#endif\n\n#ifdef MSWIN\n# include <io.h>\n#endif\n\n// ============ the header file puzzle: order matters =========\n\n#ifdef HAVE_CONFIG_H\t// GNU autoconf (or something else) was here\n# include \"auto/config.h\"\n# define HAVE_PATHDEF\n\n/*\n * Check if configure correctly managed to find sizeof(int).  If this failed,\n * it becomes zero.  This is likely a problem of not being able to run the\n * test program.  Other items from configure may also be wrong then!\n */\n# if (VIM_SIZEOF_INT == 0)\n#  error configure did not run properly.  Check auto/config.log.\n# endif\n\n# if (defined(__linux__) && !defined(__ANDROID__)) || defined(__CYGWIN__)\n// Needed for strptime().  Needs to be done early, since header files can\n// include other header files and end up including time.h, where these symbols\n// matter for Vim.\n// 700 is needed for mkdtemp().\n#  ifndef _XOPEN_SOURCE\n#   define _XOPEN_SOURCE    700\n\n// On old systems, defining _XOPEN_SOURCE causes _BSD_SOURCE, _SVID_SOURCE\n// and/or // _DEFAULT_SOURCE not to be defined, so do that here.  Those are\n// needed to include nanosecond-resolution timestamps in struct stat.  On new\n// systems, _DEFAULT_SOURCE is needed to avoid warning messages about using\n// deprecated _BSD_SOURCE or _SVID_SOURCE.\n#   ifndef _BSD_SOURCE\n#    define _BSD_SOURCE 1\n#   endif\n#   ifndef _SVID_SOURCE\n#    define _SVID_SOURCE 1\n#   endif\n#   ifndef _DEFAULT_SOURCE\n#    define _DEFAULT_SOURCE 1\n#   endif\n#  endif\n# endif\n\n/*\n * Cygwin may have fchdir() in a newer release, but in most versions it\n * doesn't work well and avoiding it keeps the binary backward compatible.\n */\n# if defined(__CYGWIN32__) && defined(HAVE_FCHDIR)\n#  undef HAVE_FCHDIR\n# endif\n\n// We may need to define the uint32_t on non-Unix system, but using the same\n// identifier causes conflicts.  Therefore use UINT32_T.\n# define UINT32_TYPEDEF uint32_t\n#endif\n\n// for INT_MAX, LONG_MAX et al.\n#include <limits.h>\n\n#if !defined(UINT32_TYPEDEF)\n# if defined(uint32_t)  // this doesn't catch typedefs, unfortunately\n#  define UINT32_TYPEDEF uint32_t\n# else\n  // Fall back to assuming unsigned int is 32 bit.  If this is wrong then the\n  // test in blowfish.c will fail.\n#  define UINT32_TYPEDEF unsigned int\n# endif\n#endif\n\n// user ID of root is usually zero, but not for everybody\n#ifdef __TANDEM\n# ifndef _TANDEM_SOURCE\n#  define _TANDEM_SOURCE\n# endif\n# include <floss.h>\n# define ROOT_UID 65535\n# define OLDXAW\n# if (_TANDEM_ARCH_ == 2 && __H_Series_RVU >= 621)\n#  define SA_ONSTACK_COMPATIBILITY\n# endif\n#else\n# define ROOT_UID 0\n#endif\n\n/*\n * MACOS_X\t    compiling for Mac OS X\n * MACOS_X_DARWIN   integrating the darwin feature into MACOS_X\n */\n#if defined(MACOS_X_DARWIN) && !defined(MACOS_X)\n# define MACOS_X\n#endif\n// Unless made through the Makefile enforce GUI on Mac\n#if defined(MACOS_X) && !defined(HAVE_CONFIG_H)\n# define UNIX\n#endif\n\n#if defined(FEAT_GUI_MOTIF) \\\n    || defined(FEAT_GUI_GTK) \\\n    || defined(FEAT_GUI_ATHENA) \\\n    || defined(FEAT_GUI_HAIKU) \\\n    || defined(FEAT_GUI_MSWIN) \\\n    || defined(FEAT_GUI_PHOTON)\n# define FEAT_GUI_ENABLED  // also defined with NO_X11_INCLUDES\n# if !defined(FEAT_GUI) && !defined(NO_X11_INCLUDES)\n#  define FEAT_GUI\n# endif\n#endif\n\n// Check support for rendering options\n#ifdef FEAT_GUI\n# if defined(FEAT_DIRECTX)\n#  define FEAT_RENDER_OPTIONS\n# endif\n#endif\n\n/*\n * VIM_SIZEOF_INT is used in feature.h, and the system-specific included files\n * need items from feature.h.  Therefore define VIM_SIZEOF_INT here.\n */\n#ifdef MSWIN\n# define VIM_SIZEOF_INT 4\n#endif\n\n#ifdef AMIGA\n  // Be conservative about sizeof(int). It could be 4 too.\n# ifndef FEAT_GUI_GTK\t// avoid problems when generating prototypes\n#  ifdef __GNUC__\n#   define VIM_SIZEOF_INT\t4\n#  else\n#   define VIM_SIZEOF_INT\t2\n#  endif\n# endif\n#endif\n#if defined(MACOS_X) && !defined(HAVE_CONFIG_H)\n#  define VIM_SIZEOF_INT __SIZEOF_INT__\n#endif\n\n#if VIM_SIZEOF_INT < 4 && !defined(PROTO)\n# error Vim only works with 32 bit int or larger\n#endif\n\n/*\n * #defines for optionals and features\n * Also defines FEAT_TINY, FEAT_SMALL, etc. when FEAT_HUGE is defined.\n */\n#include \"feature.h\"\n\n#if defined(MACOS_X_DARWIN)\n# if defined(FEAT_SMALL) && !defined(FEAT_CLIPBOARD)\n#  define FEAT_CLIPBOARD\n# endif\n#endif\n\n// +x11 is only enabled when it's both available and wanted.\n#if defined(HAVE_X11) && defined(WANT_X11)\n# define FEAT_X11\n#endif\n\n#ifdef NO_X11_INCLUDES\n    // In os_mac_conv.c and os_macosx.m NO_X11_INCLUDES is defined to avoid\n    // X11 headers.  Disable all X11 related things to avoid conflicts.\n# ifdef FEAT_X11\n#  undef FEAT_X11\n# endif\n# ifdef FEAT_GUI_X11\n#  undef FEAT_GUI_X11\n# endif\n# ifdef FEAT_XCLIPBOARD\n#  undef FEAT_XCLIPBOARD\n# endif\n# ifdef FEAT_GUI_MOTIF\n#  undef FEAT_GUI_MOTIF\n# endif\n# ifdef FEAT_GUI_ATHENA\n#  undef FEAT_GUI_ATHENA\n# endif\n# ifdef FEAT_GUI_GTK\n#  undef FEAT_GUI_GTK\n# endif\n# ifdef FEAT_BEVAL_TIP\n#  undef FEAT_BEVAL_TIP\n# endif\n# ifdef FEAT_XIM\n#  undef FEAT_XIM\n# endif\n# ifdef FEAT_CLIENTSERVER\n#  undef FEAT_CLIENTSERVER\n# endif\n#endif\n\n// The Mac conversion stuff doesn't work under X11.\n#if defined(MACOS_X_DARWIN)\n# define MACOS_CONVERT\n#endif\n\n// Can't use \"PACKAGE\" here, conflicts with a Perl include file.\n#ifndef VIMPACKAGE\n# define VIMPACKAGE\t\"vim\"\n#endif\n\n/*\n * Find out if function definitions should include argument types\n */\n#ifdef AZTEC_C\n# include <functions.h>\n#endif\n\n#ifdef SASC\n# include <clib/exec_protos.h>\n#endif\n\n#ifdef _DCC\n# include <clib/exec_protos.h>\n#endif\n\n#ifdef __HAIKU__\n# include \"os_haiku.h\"\n# define __ARGS(x)  x\n#endif\n\n#if (defined(UNIX) || defined(VMS)) \\\n\t&& (!defined(MACOS_X) || defined(HAVE_CONFIG_H))\n# include \"os_unix.h\"\t    // bring lots of system header files\n#endif\n\n// Mark unused function arguments with UNUSED, so that gcc -Wunused-parameter\n// can be used to check for mistakes.\n#if defined(HAVE_ATTRIBUTE_UNUSED) || defined(__MINGW32__)\n# if !defined(UNUSED)\n#  define UNUSED __attribute__((unused))\n# endif\n#else\n# define UNUSED\n#endif\n\n// Used to check for \"sun\", \"__sun\" is used by newer compilers.\n#if defined(__sun)\n# define SUN_SYSTEM\n#endif\n\n// If we're compiling in C++ (currently only KVim), the system\n// headers must have the correct prototypes or nothing will build.\n// Conversely, our prototypes might clash due to throw() specifiers and\n// cause compilation failures even though the headers are correct.  For\n// a concrete example, gcc-3.2 enforces exception specifications, and\n// glibc-2.2.5 has them in their system headers.\n#if !defined(__cplusplus) && defined(UNIX) \\\n\t&& !defined(MACOS_X) // MACOS_X doesn't yet support osdef.h\n# include \"auto/osdef.h\"\t// bring missing declarations in\n#endif\n\n#ifdef AMIGA\n# include \"os_amiga.h\"\n#endif\n\n#ifdef MSWIN\n# include \"os_win32.h\"\n#endif\n\n#if defined(MACOS_X)\n# include \"os_mac.h\"\n#endif\n\n#ifdef __QNX__\n# include \"os_qnx.h\"\n#endif\n\n#ifdef X_LOCALE\n# include <X11/Xlocale.h>\n#else\n# ifdef HAVE_LOCALE_H\n#  include <locale.h>\n# endif\n#endif\n\n/*\n * Maximum length of a path (for non-unix systems) Make it a bit long, to stay\n * on the safe side.  But not too long to put on the stack.\n */\n#ifndef MAXPATHL\n# ifdef MAXPATHLEN\n#  define MAXPATHL  MAXPATHLEN\n# else\n#  define MAXPATHL  256\n# endif\n#endif\n#ifdef BACKSLASH_IN_FILENAME\n# define PATH_ESC_CHARS ((char_u *)\" \\t\\n*?[{`%#'\\\"|!<\")\n# define BUFFER_ESC_CHARS ((char_u *)\" \\t\\n*?[`%#'\\\"|!<\")\n#else\n# ifdef VMS\n    // VMS allows a lot of characters in the file name\n#  define PATH_ESC_CHARS ((char_u *)\" \\t\\n*?{`\\\\%#'\\\"|!\")\n#  define SHELL_ESC_CHARS ((char_u *)\" \\t\\n*?{`\\\\%#'|!()&\")\n# else\n#  define PATH_ESC_CHARS ((char_u *)\" \\t\\n*?[{`$\\\\%#'\\\"|!<\")\n#  define SHELL_ESC_CHARS ((char_u *)\" \\t\\n*?[{`$\\\\%#'\\\"|!<>();&\")\n# endif\n#  define BUFFER_ESC_CHARS ((char_u *)\" \\t\\n*?[`$\\\\%#'\\\"|!<\")\n#endif\n\n// length of a buffer to store a number in ASCII (64 bits binary + NUL)\n#define NUMBUFLEN 65\n\n// flags for vim_str2nr()\n#define STR2NR_BIN  0x01\n#define STR2NR_OCT  0x02\n#define STR2NR_HEX  0x04\n#define STR2NR_OOCT 0x08    // Octal with prefix \"0o\": 0o777\n#define STR2NR_ALL (STR2NR_BIN + STR2NR_OCT + STR2NR_HEX + STR2NR_OOCT)\n#define STR2NR_NO_OCT (STR2NR_BIN + STR2NR_HEX + STR2NR_OOCT)\n\n#define STR2NR_FORCE 0x80   // only when ONE of the above is used\n\n#define STR2NR_QUOTE 0x10   // ignore embedded single quotes\n\n/*\n * Shorthand for unsigned variables. Many systems, but not all, have u_char\n * already defined, so we use char_u to avoid trouble.\n */\ntypedef unsigned char\tchar_u;\ntypedef unsigned short\tshort_u;\ntypedef unsigned int\tint_u;\n\n// Make sure long_u is big enough to hold a pointer.\n// On Win64, longs are 32 bits and pointers are 64 bits.\n// For printf() and scanf(), we need to take care of long_u specifically.\n#ifdef _WIN64\ntypedef unsigned __int64\tlong_u;\ntypedef\t\t __int64\tlong_i;\n# define SCANF_HEX_LONG_U       \"%llx\"\n# define SCANF_DECIMAL_LONG_U   \"%llu\"\n# define PRINTF_HEX_LONG_U      \"0x%llx\"\n#else\ntypedef unsigned long\t\tlong_u;\ntypedef\t\t long\t\tlong_i;\n# define SCANF_HEX_LONG_U       \"%lx\"\n# define SCANF_DECIMAL_LONG_U   \"%lu\"\n# define PRINTF_HEX_LONG_U      \"0x%lx\"\n#endif\n#define PRINTF_DECIMAL_LONG_U SCANF_DECIMAL_LONG_U\n\n/*\n * Only systems which use configure will have SIZEOF_OFF_T and VIM_SIZEOF_LONG\n * defined, which is ok since those are the same systems which can have\n * varying sizes for off_t.  The other systems will continue to use \"%ld\" to\n * print off_t since off_t is simply a typedef to long for them.\n */\n#if defined(SIZEOF_OFF_T) && (SIZEOF_OFF_T > VIM_SIZEOF_LONG)\n# define LONG_LONG_OFF_T\n#endif\n\n/*\n * We use 64-bit file functions here, if available.  E.g. ftello() returns\n * off_t instead of long, which helps if long is 32 bit and off_t is 64 bit.\n * We assume that when fseeko() is available then ftello() is too.\n * Note that Windows has different function names.\n */\n#ifdef MSWIN\ntypedef __int64 off_T;\n# ifdef __MINGW32__\n#  define vim_lseek lseek64\n#  define vim_fseek fseeko64\n#  define vim_ftell ftello64\n# else\n#  define vim_lseek _lseeki64\n#  define vim_fseek _fseeki64\n#  define vim_ftell _ftelli64\n# endif\n#else\n# ifdef PROTO\ntypedef long off_T;\n# else\ntypedef off_t off_T;\n# endif\n# ifdef HAVE_FSEEKO\n#  define vim_lseek lseek\n#  define vim_ftell ftello\n#  define vim_fseek fseeko\n# else\n#  define vim_lseek lseek\n#  define vim_ftell ftell\n#  define vim_fseek(a, b, c)\tfseek(a, (long)b, c)\n# endif\n#endif\n\n/*\n * The characters and attributes cached for the screen.\n */\ntypedef char_u schar_T;\ntypedef unsigned short sattr_T;\n#define MAX_TYPENR 65535\n\n/*\n * The u8char_T can hold one decoded UTF-8 character.\n * We use 32 bits, since some Asian characters don't fit in 16 bits.\n */\ntypedef unsigned int u8char_T;\t// int is 32 bits or more\n\n#ifndef UNIX\t\t    // For Unix this is included in os_unix.h\n# include <stdio.h>\n# include <ctype.h>\n#endif\n\n#include \"ascii.h\"\n#include \"keymap.h\"\n#include \"termdefs.h\"\n#include \"macros.h\"\n\n#ifdef LATTICE\n# include <sys/types.h>\n# include <sys/stat.h>\n#endif\n#ifdef _DCC\n# include <sys/stat.h>\n#endif\n#if defined(MSWIN)\n# include <sys/stat.h>\n#endif\n\n#if defined(HAVE_ERRNO_H) || defined(MSWIN)\n# include <errno.h>\n#endif\n\n/*\n * Allow other (non-unix) systems to configure themselves now\n * These are also in os_unix.h, because osdef.sh needs them there.\n */\n#ifndef UNIX\n// Note: Some systems need both string.h and strings.h (Savage).  If the\n// system can't handle this, define NO_STRINGS_WITH_STRING_H.\n# ifdef HAVE_STRING_H\n#  include <string.h>\n# endif\n# if defined(HAVE_STRINGS_H) && !defined(NO_STRINGS_WITH_STRING_H)\n#  include <strings.h>\n# endif\n# ifdef HAVE_STAT_H\n#  include <stat.h>\n# endif\n# ifdef HAVE_STDLIB_H\n#  include <stdlib.h>\n# endif\n#endif // NON-UNIX\n\n#include <assert.h>\n\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n#ifdef HAVE_INTTYPES_H\n# include <inttypes.h>\n#endif\n#ifdef HAVE_WCTYPE_H\n# include <wctype.h>\n#endif\n#include <stdarg.h>\n\n// for offsetof()\n#include <stddef.h>\n\n#if defined(HAVE_SYS_SELECT_H) && \\\n\t(!defined(HAVE_SYS_TIME_H) || defined(SYS_SELECT_WITH_SYS_TIME))\n# include <sys/select.h>\n#endif\n\n#ifndef HAVE_SELECT\n# ifdef HAVE_SYS_POLL_H\n#  include <sys/poll.h>\n# elif defined(MSWIN)\n#  define HAVE_SELECT\n# else\n#  ifdef HAVE_POLL_H\n#   include <poll.h>\n#  endif\n# endif\n#endif\n\n#ifdef HAVE_SODIUM\n# include <sodium.h>\n#endif\n\n// ================ end of the header file puzzle ===============\n\n/*\n * For dynamically loaded imm library. Currently, only for Win32.\n */\n#ifdef DYNAMIC_IME\n# ifndef FEAT_MBYTE_IME\n#  define FEAT_MBYTE_IME\n# endif\n#endif\n\n/*\n * For dynamically loaded gettext library.  Currently, only for Win32.\n */\n#ifdef DYNAMIC_GETTEXT\n# ifndef FEAT_GETTEXT\n#  define FEAT_GETTEXT\n# endif\n// These are in os_win32.c\nextern char *(*dyn_libintl_gettext)(const char *msgid);\nextern char *(*dyn_libintl_ngettext)(const char *msgid, const char *msgid_plural, unsigned long n);\nextern char *(*dyn_libintl_bindtextdomain)(const char *domainname, const char *dirname);\nextern char *(*dyn_libintl_bind_textdomain_codeset)(const char *domainname, const char *codeset);\nextern char *(*dyn_libintl_textdomain)(const char *domainname);\nextern int (*dyn_libintl_wputenv)(const wchar_t *envstring);\n#endif\n\n\n/*\n * The _() stuff is for using gettext().  It is a no-op when libintl.h is not\n * found or the +multilang feature is disabled.\n * Use NGETTEXT(single, multi, number) to get plural behavior:\n * - single - message for singular form\n * - multi  - message for plural form\n * - number - the count\n */\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n#  define _(x) (*dyn_libintl_gettext)((char *)(x))\n#  define NGETTEXT(x, xs, n) (*dyn_libintl_ngettext)((char *)(x), (char *)(xs), (n))\n#  define N_(x) x\n#  define bindtextdomain(domain, dir) (*dyn_libintl_bindtextdomain)((domain), (dir))\n#  define bind_textdomain_codeset(domain, codeset) (*dyn_libintl_bind_textdomain_codeset)((domain), (codeset))\n#  if !defined(HAVE_BIND_TEXTDOMAIN_CODESET)\n#   define HAVE_BIND_TEXTDOMAIN_CODESET 1\n#  endif\n#  define textdomain(domain) (*dyn_libintl_textdomain)(domain)\n#  define libintl_wputenv(envstring) (*dyn_libintl_wputenv)(envstring)\n# else\n#  include <libintl.h>\n#  define _(x) gettext((char *)(x))\n#  define NGETTEXT(x, xs, n) ngettext((x), (xs), (n))\n#  ifdef gettext_noop\n#   define N_(x) gettext_noop(x)\n#  else\n#   define N_(x) x\n#  endif\n# endif\n#else\n# define _(x) ((char *)(x))\n# define NGETTEXT(x, xs, n) (((n) == 1) ? (char *)(x) : (char *)(xs))\n# define N_(x) x\n# ifdef bindtextdomain\n#  undef bindtextdomain\n# endif\n# define bindtextdomain(x, y) // empty\n# ifdef bind_textdomain_codeset\n#  undef bind_textdomain_codeset\n# endif\n# define bind_textdomain_codeset(x, y) // empty\n# ifdef textdomain\n#  undef textdomain\n# endif\n# define textdomain(x) // empty\n#endif\n\n/*\n * flags for update_screen()\n * The higher the value, the higher the priority\n */\n#define VALID_NO_UPDATE\t\t 5  // no new changes, keep the command line if\n\t\t\t\t    // possible\n#define VALID\t\t\t10  // buffer not changed, or changes marked\n\t\t\t\t    // with b_mod_*\n#define INVERTED\t\t20  // redisplay inverted part that changed\n#define INVERTED_ALL\t\t25  // redisplay whole inverted part\n#define REDRAW_TOP\t\t30  // display first w_upd_rows screen lines\n#define SOME_VALID\t\t35  // like NOT_VALID but may scroll\n#define NOT_VALID\t\t40  // buffer needs complete redraw\n#define CLEAR\t\t\t50  // screen messed up, clear it\n\n// flags for screen_line()\n#define SLF_RIGHTLEFT\t1\n#define SLF_POPUP\t2\n\n#define MB_FILLER_CHAR '<'  // character used when a double-width character\n\t\t\t    // doesn't fit.\n\n/*\n * Flags for w_valid.\n * These are set when something in a window structure becomes invalid, except\n * when the cursor is moved.  Call check_cursor_moved() before testing one of\n * the flags.\n * These are reset when that thing has been updated and is valid again.\n *\n * Every function that invalidates one of these must call one of the\n * invalidate_* functions.\n *\n * w_valid is supposed to be used only in screen.c.  From other files, use the\n * functions that set or reset the flags.\n *\n * VALID_BOTLINE    VALID_BOTLINE_AP\n *     on\t\ton\t\tw_botline valid\n *     off\t\ton\t\tw_botline approximated\n *     off\t\toff\t\tw_botline not valid\n *     on\t\toff\t\tnot possible\n */\n#define VALID_WROW\t0x01\t// w_wrow (window row) is valid\n#define VALID_WCOL\t0x02\t// w_wcol (window col) is valid\n#define VALID_VIRTCOL\t0x04\t// w_virtcol (file col) is valid\n#define VALID_CHEIGHT\t0x08\t// w_cline_height and w_cline_folded valid\n#define VALID_CROW\t0x10\t// w_cline_row is valid\n#define VALID_BOTLINE\t0x20\t// w_botine and w_empty_rows are valid\n#define VALID_BOTLINE_AP 0x40\t// w_botine is approximated\n#define VALID_TOPLINE\t0x80\t// w_topline is valid (for cursor position)\n\n// Values for w_popup_flags.\n#define POPF_IS_POPUP\t0x01\t// this is a popup window\n#define POPF_HIDDEN\t0x02\t// popup is not displayed\n#define POPF_CURSORLINE\t0x04\t// popup is highlighting at the cursorline\n#define POPF_ON_CMDLINE\t0x08\t// popup overlaps command line\n#define POPF_DRAG\t0x10\t// popup can be moved by dragging border\n#define POPF_DRAGALL\t0x20\t// popup can be moved by dragging everywhere\n#define POPF_RESIZE\t0x40\t// popup can be resized by dragging\n#define POPF_MAPPING\t0x80\t// mapping keys\n#define POPF_INFO\t0x100\t// used for info of popup menu\n#define POPF_INFO_MENU\t0x200\t// align info popup with popup menu\n#define POPF_POSINVERT\t0x400\t// vertical position can be inverted\n\n// flags used in w_popup_handled\n#define POPUP_HANDLED_1\t    0x01    // used by mouse_find_win()\n#define POPUP_HANDLED_2\t    0x02    // used by popup_do_filter()\n#define POPUP_HANDLED_3\t    0x04    // used by popup_check_cursor_pos()\n#define POPUP_HANDLED_4\t    0x08    // used by may_update_popup_mask()\n#define POPUP_HANDLED_5\t    0x10    // used by update_popups()\n\n/*\n * Terminal highlighting attribute bits.\n * Attributes above HL_ALL are used for syntax highlighting.\n */\n#define HL_NORMAL\t\t0x00\n#define HL_INVERSE\t\t0x01\n#define HL_BOLD\t\t\t0x02\n#define HL_ITALIC\t\t0x04\n#define HL_UNDERLINE\t\t0x08\n#define HL_UNDERCURL\t\t0x10\n#define HL_STANDOUT\t\t0x20\n#define HL_NOCOMBINE\t\t0x40\n#define HL_STRIKETHROUGH\t0x80\n#define HL_ALL\t\t\t0xff\n\n// special attribute addition: Put message in history\n#define MSG_HIST\t\t0x1000\n\n/*\n * values for State\n *\n * The lower bits up to 0x20 are used to distinguish normal/visual/op_pending\n * and cmdline/insert+replace mode.  This is used for mapping.  If none of\n * these bits are set, no mapping is done.\n * The upper bits are used to distinguish between other states.\n */\n#define NORMAL\t\t0x01\t// Normal mode, command expected\n#define VISUAL\t\t0x02\t// Visual mode - use get_real_state()\n#define OP_PENDING\t0x04\t// Normal mode, operator is pending - use\n\t\t\t\t// get_real_state()\n#define CMDLINE\t\t0x08\t// Editing command line\n#define INSERT\t\t0x10\t// Insert mode\n#define LANGMAP\t\t0x20\t// Language mapping, can be combined with\n\t\t\t\t// INSERT and CMDLINE\n\n#define REPLACE_FLAG\t0x40\t// Replace mode flag\n#define REPLACE\t\t(REPLACE_FLAG + INSERT)\n#define VREPLACE_FLAG\t0x80\t// Virtual-replace mode flag\n#define VREPLACE\t(REPLACE_FLAG + VREPLACE_FLAG + INSERT)\n#define LREPLACE\t(REPLACE_FLAG + LANGMAP)\n\n#define NORMAL_BUSY\t(0x100 + NORMAL) // Normal mode, busy with a command\n#define HITRETURN\t(0x200 + NORMAL) // waiting for return or command\n#define ASKMORE\t\t0x300\t// Asking if you want --more--\n#define SETWSIZE\t0x400\t// window size has changed\n#define ABBREV\t\t0x500\t// abbreviation instead of mapping\n#define EXTERNCMD\t0x600\t// executing an external command\n#define SHOWMATCH\t(0x700 + INSERT) // show matching paren\n#define CONFIRM\t\t0x800\t// \":confirm\" prompt\n#define SELECTMODE\t0x1000\t// Select mode, only for mappings\n#define TERMINAL        0x2000  // Terminal mode\n#define MODE_ALL\t0xffff\n\n#define MODE_MAX_LENGTH\t4\t// max mode length returned in mode()\n\n// all mode bits used for mapping\n#define MAP_ALL_MODES\t(0x3f | SELECTMODE | TERMINAL)\n\n// directions\n#define FORWARD\t\t\t1\n#define BACKWARD\t\t(-1)\n#define FORWARD_FILE\t\t3\n#define BACKWARD_FILE\t\t(-3)\n\n// return values for functions\n#if !(defined(OK) && (OK == 1))\n// OK already defined to 1 in MacOS X curses, skip this\n# define OK\t\t\t1\n#endif\n#define FAIL\t\t\t0\n#define NOTDONE\t\t\t2   // not OK or FAIL but skipped\n\n// flags for b_flags\n#define BF_RECOVERED\t0x01\t// buffer has been recovered\n#define BF_CHECK_RO\t0x02\t// need to check readonly when loading file\n\t\t\t\t// into buffer (set by \":e\", may be reset by\n\t\t\t\t// \":buf\"\n#define BF_NEVERLOADED\t0x04\t// file has never been loaded into buffer,\n\t\t\t\t// many variables still need to be set\n#define BF_NOTEDITED\t0x08\t// Set when file name is changed after\n\t\t\t\t// starting to edit, reset when file is\n\t\t\t\t// written out.\n#define BF_NEW\t\t0x10\t// file didn't exist when editing started\n#define BF_NEW_W\t0x20\t// Warned for BF_NEW and file created\n#define BF_READERR\t0x40\t// got errors while reading the file\n#define BF_DUMMY\t0x80\t// dummy buffer, only used internally\n#define BF_PRESERVED\t0x100\t// \":preserve\" was used\n#define BF_SYN_SET\t0x200\t// 'syntax' option was set\n#define BF_NO_SEA\t0x400\t// no swap_exists_action (ATTENTION prompt)\n\n// Mask to check for flags that prevent normal writing\n#define BF_WRITE_MASK\t(BF_NOTEDITED + BF_NEW + BF_READERR)\n\n/*\n * values for xp_context when doing command line completion\n */\n#define EXPAND_UNSUCCESSFUL\t(-2)\n#define EXPAND_OK\t\t(-1)\n#define EXPAND_NOTHING\t\t0\n#define EXPAND_COMMANDS\t\t1\n#define EXPAND_FILES\t\t2\n#define EXPAND_DIRECTORIES\t3\n#define EXPAND_SETTINGS\t\t4\n#define EXPAND_BOOL_SETTINGS\t5\n#define EXPAND_TAGS\t\t6\n#define EXPAND_OLD_SETTING\t7\n#define EXPAND_HELP\t\t8\n#define EXPAND_BUFFERS\t\t9\n#define EXPAND_EVENTS\t\t10\n#define EXPAND_MENUS\t\t11\n#define EXPAND_SYNTAX\t\t12\n#define EXPAND_HIGHLIGHT\t13\n#define EXPAND_AUGROUP\t\t14\n#define EXPAND_USER_VARS\t15\n#define EXPAND_MAPPINGS\t\t16\n#define EXPAND_TAGS_LISTFILES\t17\n#define EXPAND_FUNCTIONS\t18\n#define EXPAND_USER_FUNC\t19\n#define EXPAND_EXPRESSION\t20\n#define EXPAND_MENUNAMES\t21\n#define EXPAND_USER_COMMANDS\t22\n#define EXPAND_USER_CMD_FLAGS\t23\n#define EXPAND_USER_NARGS\t24\n#define EXPAND_USER_COMPLETE\t25\n#define EXPAND_ENV_VARS\t\t26\n#define EXPAND_LANGUAGE\t\t27\n#define EXPAND_COLORS\t\t28\n#define EXPAND_COMPILER\t\t29\n#define EXPAND_USER_DEFINED\t30\n#define EXPAND_USER_LIST\t31\n#define EXPAND_SHELLCMD\t\t32\n#define EXPAND_CSCOPE\t\t33\n#define EXPAND_SIGN\t\t34\n#define EXPAND_PROFILE\t\t35\n#define EXPAND_BEHAVE\t\t36\n#define EXPAND_FILETYPE\t\t37\n#define EXPAND_FILES_IN_PATH\t38\n#define EXPAND_OWNSYNTAX\t39\n#define EXPAND_LOCALES\t\t40\n#define EXPAND_HISTORY\t\t41\n#define EXPAND_USER\t\t42\n#define EXPAND_SYNTIME\t\t43\n#define EXPAND_USER_ADDR_TYPE\t44\n#define EXPAND_PACKADD\t\t45\n#define EXPAND_MESSAGES\t\t46\n#define EXPAND_MAPCLEAR\t\t47\n#define EXPAND_ARGLIST\t\t48\n#define EXPAND_DIFF_BUFFERS\t49\n#define EXPAND_DISASSEMBLE\t50\n\n// Values for exmode_active (0 is no exmode)\n#define EXMODE_NORMAL\t\t1\n#define EXMODE_VIM\t\t2\n\n// Values for nextwild() and ExpandOne().  See ExpandOne() for meaning.\n#define WILD_FREE\t\t1\n#define WILD_EXPAND_FREE\t2\n#define WILD_EXPAND_KEEP\t3\n#define WILD_NEXT\t\t4\n#define WILD_PREV\t\t5\n#define WILD_ALL\t\t6\n#define WILD_LONGEST\t\t7\n#define WILD_ALL_KEEP\t\t8\n\n#define WILD_LIST_NOTFOUND\t    0x01\n#define WILD_HOME_REPLACE\t    0x02\n#define WILD_USE_NL\t\t    0x04\n#define WILD_NO_BEEP\t\t    0x08\n#define WILD_ADD_SLASH\t\t    0x10\n#define WILD_KEEP_ALL\t\t    0x20\n#define WILD_SILENT\t\t    0x40\n#define WILD_ESCAPE\t\t    0x80\n#define WILD_ICASE\t\t    0x100\n#define WILD_ALLLINKS\t\t    0x200\n#define WILD_IGNORE_COMPLETESLASH   0x400\n#define WILD_NOERROR\t\t    0x800  // sets EW_NOERROR\n#define WILD_BUFLASTUSED\t    0x1000\n#define BUF_DIFF_FILTER\t\t    0x2000\n\n// Flags for expand_wildcards()\n#define EW_DIR\t\t0x01\t// include directory names\n#define EW_FILE\t\t0x02\t// include file names\n#define EW_NOTFOUND\t0x04\t// include not found names\n#define EW_ADDSLASH\t0x08\t// append slash to directory name\n#define EW_KEEPALL\t0x10\t// keep all matches\n#define EW_SILENT\t0x20\t// don't print \"1 returned\" from shell\n#define EW_EXEC\t\t0x40\t// executable files\n#define EW_PATH\t\t0x80\t// search in 'path' too\n#define EW_ICASE\t0x100\t// ignore case\n#define EW_NOERROR\t0x200\t// no error for bad regexp\n#define EW_NOTWILD\t0x400\t// add match with literal name if exists\n#define EW_KEEPDOLLAR\t0x800\t// do not escape $, $var is expanded\n// Note: mostly EW_NOTFOUND and EW_SILENT are mutually exclusive: EW_NOTFOUND\n// is used when executing commands and EW_SILENT for interactive expanding.\n#define EW_ALLLINKS\t0x1000\t// also links not pointing to existing file\n#define EW_SHELLCMD\t0x2000\t// called from expand_shellcmd(), don't check\n\t\t\t\t// if executable is in $PATH\n#define EW_DODOT\t0x4000\t// also files starting with a dot\n#define EW_EMPTYOK\t0x8000\t// no matches is not an error\n#define EW_NOTENV\t0x10000\t// do not expand environment variables\n\n// Flags for find_file_*() functions.\n#define FINDFILE_FILE\t0\t// only files\n#define FINDFILE_DIR\t1\t// only directories\n#define FINDFILE_BOTH\t2\t// files and directories\n\n#define W_ENDCOL(wp)\t(wp->w_wincol + wp->w_width)\n#ifdef FEAT_MENU\n# define W_WINROW(wp)\t(wp->w_winrow + wp->w_winbar_height)\n#else\n# define W_WINROW(wp)\t(wp->w_winrow)\n#endif\n\n// Values for the find_pattern_in_path() function args 'type' and 'action':\n#define FIND_ANY\t1\n#define FIND_DEFINE\t2\n#define CHECK_PATH\t3\n\n#define ACTION_SHOW\t1\n#define ACTION_GOTO\t2\n#define ACTION_SPLIT\t3\n#define ACTION_SHOW_ALL\t4\n#define ACTION_EXPAND\t5\n\n#ifdef FEAT_SYN_HL\n# define SST_MIN_ENTRIES 150\t// minimal size for state stack array\n# define SST_MAX_ENTRIES 1000\t// maximal size for state stack array\n# define SST_FIX_STATES\t 7\t// size of sst_stack[].\n# define SST_DIST\t 16\t// normal distance between entries\n# define SST_INVALID\t(synstate_T *)-1\t// invalid syn_state pointer\n\n# define HL_CONTAINED\t0x01\t// not used on toplevel\n# define HL_TRANSP\t0x02\t// has no highlighting\n# define HL_ONELINE\t0x04\t// match within one line only\n# define HL_HAS_EOL\t0x08\t// end pattern that matches with $\n# define HL_SYNC_HERE\t0x10\t// sync point after this item (syncing only)\n# define HL_SYNC_THERE\t0x20\t// sync point at current line (syncing only)\n# define HL_MATCH\t0x40\t// use match ID instead of item ID\n# define HL_SKIPNL\t0x80\t// nextgroup can skip newlines\n# define HL_SKIPWHITE\t0x100\t// nextgroup can skip white space\n# define HL_SKIPEMPTY\t0x200\t// nextgroup can skip empty lines\n# define HL_KEEPEND\t0x400\t// end match always kept\n# define HL_EXCLUDENL\t0x800\t// exclude NL from match\n# define HL_DISPLAY\t0x1000\t// only used for displaying, not syncing\n# define HL_FOLD\t0x2000\t// define fold\n# define HL_EXTEND\t0x4000\t// ignore a keepend\n# define HL_MATCHCONT\t0x8000\t// match continued from previous line\n# define HL_TRANS_CONT\t0x10000 // transparent item without contains arg\n# define HL_CONCEAL\t0x20000 // can be concealed\n# define HL_CONCEALENDS\t0x40000 // can be concealed\n#endif\n\n// Values for 'options' argument in do_search() and searchit()\n#define SEARCH_REV    0x01  // go in reverse of previous dir.\n#define SEARCH_ECHO   0x02  // echo the search command and handle options\n#define SEARCH_MSG    0x0c  // give messages (yes, it's not 0x04)\n#define SEARCH_NFMSG  0x08  // give all messages except not found\n#define SEARCH_OPT    0x10  // interpret optional flags\n#define SEARCH_HIS    0x20  // put search pattern in history\n#define SEARCH_END    0x40  // put cursor at end of match\n#define SEARCH_NOOF   0x80  // don't add offset to position\n#define SEARCH_START 0x100  // start search without col offset\n#define SEARCH_MARK  0x200  // set previous context mark\n#define SEARCH_KEEP  0x400  // keep previous search pattern\n#define SEARCH_PEEK  0x800  // peek for typed char, cancel search\n#define SEARCH_COL  0x1000  // start at specified column instead of zero\n\n// Values for find_ident_under_cursor()\n#define FIND_IDENT\t1\t// find identifier (word)\n#define FIND_STRING\t2\t// find any string (WORD)\n#define FIND_EVAL\t4\t// include \"->\", \"[]\" and \".\"\n#define FIND_NOERROR\t8\t// no error when no word found\n\n// Values for file_name_in_line()\n#define FNAME_MESS\t1\t// give error message\n#define FNAME_EXP\t2\t// expand to path\n#define FNAME_HYP\t4\t// check for hypertext link\n#define FNAME_INCL\t8\t// apply 'includeexpr'\n#define FNAME_REL\t16\t// \"..\" and \"./\" are relative to the (current)\n\t\t\t\t// file instead of the current directory\n#define FNAME_UNESC\t32\t// remove backslashes used for escaping\n\n// Values for buflist_getfile()\n#define GETF_SETMARK\t0x01\t// set pcmark before jumping\n#define GETF_ALT\t0x02\t// jumping to alternate file (not buf num)\n#define GETF_SWITCH\t0x04\t// respect 'switchbuf' settings when jumping\n\n// Return values of getfile()\n#define GETFILE_ERROR\t    1\t// normal error\n#define GETFILE_NOT_WRITTEN 2\t// \"not written\" error\n#define GETFILE_SAME_FILE   0\t// success, same file\n#define GETFILE_OPEN_OTHER -1\t// success, opened another file\n#define GETFILE_UNUSED\t    8\n#define GETFILE_SUCCESS(x)  ((x) <= 0)\n\n// Values for buflist_new() flags\n#define BLN_CURBUF\t1\t// may re-use curbuf for new buffer\n#define BLN_LISTED\t2\t// put new buffer in buffer list\n#define BLN_DUMMY\t4\t// allocating dummy buffer\n#define BLN_NEW\t\t8\t// create a new buffer\n#define BLN_NOOPT\t16\t// don't copy options to existing buffer\n#define BLN_DUMMY_OK\t32\t// also find an existing dummy buffer\n#define BLN_REUSE\t64\t// may re-use number from buf_reuse\n#define BLN_NOCURWIN\t128\t// buffer is not associated with curwin\n\n// Values for in_cinkeys()\n#define KEY_OPEN_FORW\t0x101\n#define KEY_OPEN_BACK\t0x102\n#define KEY_COMPLETE\t0x103\t// end of completion\n\n// Values for \"noremap\" argument of ins_typebuf().  Also used for\n// map->m_noremap and menu->noremap[].\n#define REMAP_YES\t0\t// allow remapping\n#define REMAP_NONE\t-1\t// no remapping\n#define REMAP_SCRIPT\t-2\t// remap script-local mappings only\n#define REMAP_SKIP\t-3\t// no remapping for first char\n\n// Values for mch_call_shell() second argument\n#define SHELL_FILTER\t1\t// filtering text\n#define SHELL_EXPAND\t2\t// expanding wildcards\n#define SHELL_COOKED\t4\t// set term to cooked mode\n#define SHELL_DOOUT\t8\t// redirecting output\n#define SHELL_SILENT\t16\t// don't print error returned by command\n#define SHELL_READ\t32\t// read lines and insert into buffer\n#define SHELL_WRITE\t64\t// write lines from buffer\n\n// Values returned by mch_nodetype()\n#define NODE_NORMAL\t0\t// file or directory, check with mch_isdir()\n#define NODE_WRITABLE\t1\t// something we can write to (character\n\t\t\t\t// device, fifo, socket, ..)\n#define NODE_OTHER\t2\t// non-writable thing (e.g., block device)\n\n// Values for readfile() flags\n#define READ_NEW\t0x01\t// read a file into a new buffer\n#define READ_FILTER\t0x02\t// read filter output\n#define READ_STDIN\t0x04\t// read from stdin\n#define READ_BUFFER\t0x08\t// read from curbuf (converting stdin)\n#define READ_DUMMY\t0x10\t// reading into a dummy buffer\n#define READ_KEEP_UNDO\t0x20\t// keep undo info\n#define READ_FIFO\t0x40\t// read from fifo or socket\n#define READ_NOWINENTER 0x80\t// do not trigger BufWinEnter\n\n// Values for change_indent()\n#define INDENT_SET\t1\t// set indent\n#define INDENT_INC\t2\t// increase indent\n#define INDENT_DEC\t3\t// decrease indent\n\n// Values for flags argument for findmatchlimit()\n#define FM_BACKWARD\t0x01\t// search backwards\n#define FM_FORWARD\t0x02\t// search forwards\n#define FM_BLOCKSTOP\t0x04\t// stop at start/end of block\n#define FM_SKIPCOMM\t0x08\t// skip comments\n\n// Values for action argument for do_buffer() and close_buffer()\n#define DOBUF_GOTO\t0\t// go to specified buffer\n#define DOBUF_SPLIT\t1\t// split window and go to specified buffer\n#define DOBUF_UNLOAD\t2\t// unload specified buffer(s)\n#define DOBUF_DEL\t3\t// delete specified buffer(s) from buflist\n#define DOBUF_WIPE\t4\t// delete specified buffer(s) really\n#define DOBUF_WIPE_REUSE 5\t// like DOBUF_WIPE and keep number for reuse\n\n// Values for start argument for do_buffer()\n#define DOBUF_CURRENT\t0\t// \"count\" buffer from current buffer\n#define DOBUF_FIRST\t1\t// \"count\" buffer from first buffer\n#define DOBUF_LAST\t2\t// \"count\" buffer from last buffer\n#define DOBUF_MOD\t3\t// \"count\" mod. buffer from current buffer\n\n// Values for flags argument of do_buffer()\n#define DOBUF_FORCEIT\t1\t// :cmd!\n#define DOBUF_NOPOPUP\t2\t// skip popup window buffers\n\n// Values for sub_cmd and which_pat argument for search_regcomp()\n// Also used for which_pat argument for searchit()\n#define RE_SEARCH\t0\t// save/use pat in/from search_pattern\n#define RE_SUBST\t1\t// save/use pat in/from subst_pattern\n#define RE_BOTH\t\t2\t// save pat in both patterns\n#define RE_LAST\t\t2\t// use last used pattern if \"pat\" is NULL\n\n// Second argument for vim_regcomp().\n#define RE_MAGIC\t1\t// 'magic' option\n#define RE_STRING\t2\t// match in string instead of buffer text\n#define RE_STRICT\t4\t// don't allow [abc] without ]\n#define RE_AUTO\t\t8\t// automatic engine selection\n\n#ifdef FEAT_SYN_HL\n// values for reg_do_extmatch\n# define REX_SET\t1\t// to allow \\z\\(...\\),\n# define REX_USE\t2\t// to allow \\z\\1 et al.\n# define REX_ALL\t(REX_SET | REX_USE)\n#endif\n\n// Return values for fullpathcmp()\n// Note: can use (fullpathcmp() & FPC_SAME) to check for equal files\n#define FPC_SAME\t1\t// both exist and are the same file.\n#define FPC_DIFF\t2\t// both exist and are different files.\n#define FPC_NOTX\t4\t// both don't exist.\n#define FPC_DIFFX\t6\t// one of them doesn't exist.\n#define FPC_SAMEX\t7\t// both don't exist and file names are same.\n\n// flags for do_ecmd()\n#define ECMD_HIDE\t0x01\t// don't free the current buffer\n#define ECMD_SET_HELP\t0x02\t// set b_help flag of (new) buffer before\n\t\t\t\t// opening file\n#define ECMD_OLDBUF\t0x04\t// use existing buffer if it exists\n#define ECMD_FORCEIT\t0x08\t// ! used in Ex command\n#define ECMD_ADDBUF\t0x10\t// don't edit, just add to buffer list\n#define ECMD_ALTBUF\t0x20\t// like ECMD_ADDBUF and set the alternate file\n#define ECMD_NOWINENTER\t0x40\t// do not trigger BufWinEnter\n\n// for lnum argument in do_ecmd()\n#define ECMD_LASTL\t(linenr_T)0\t// use last position in loaded file\n#define ECMD_LAST\t(linenr_T)-1\t// use last position in all files\n#define ECMD_ONE\t(linenr_T)1\t// use first line\n\n// flags for do_cmdline()\n#define DOCMD_VERBOSE\t0x01\t// included command in error message\n#define DOCMD_NOWAIT\t0x02\t// don't call wait_return() and friends\n#define DOCMD_REPEAT\t0x04\t// repeat exec. until getline() returns NULL\n#define DOCMD_KEYTYPED\t0x08\t// don't reset KeyTyped\n#define DOCMD_EXCRESET\t0x10\t// reset exception environment (for debugging)\n#define DOCMD_KEEPLINE  0x20\t// keep typed line for repeating with \".\"\n#define DOCMD_RANGEOK\t0x40\t// can use a range without \":\" in Vim9 script\n\n// flags for beginline()\n#define BL_WHITE\t1\t// cursor on first non-white in the line\n#define BL_SOL\t\t2\t// use 'sol' option\n#define BL_FIX\t\t4\t// don't leave cursor on a NUL\n\n// flags for mf_sync()\n#define MFS_ALL\t\t1\t// also sync blocks with negative numbers\n#define MFS_STOP\t2\t// stop syncing when a character is available\n#define MFS_FLUSH\t4\t// flushed file to disk\n#define MFS_ZERO\t8\t// only write block 0\n\n// flags for buf_copy_options()\n#define BCO_ENTER\t1\t// going to enter the buffer\n#define BCO_ALWAYS\t2\t// always copy the options\n#define BCO_NOHELP\t4\t// don't touch the help related options\n\n// flags for do_put()\n#define PUT_FIXINDENT\t1\t// make indent look nice\n#define PUT_CURSEND\t2\t// leave cursor after end of new text\n#define PUT_CURSLINE\t4\t// leave cursor on last line of new text\n#define PUT_LINE\t8\t// put register as lines\n#define PUT_LINE_SPLIT\t16\t// split line for linewise register\n#define PUT_LINE_FORWARD 32\t// put linewise register below Visual sel.\n#define PUT_BLOCK_INNER 64      // in block mode, do not add trailing spaces\n\n// flags for set_indent()\n#define SIN_CHANGED\t1\t// call changed_bytes() when line changed\n#define SIN_INSERT\t2\t// insert indent before existing text\n#define SIN_UNDO\t4\t// save line for undo before changing it\n\n// flags for insertchar()\n#define INSCHAR_FORMAT\t1\t// force formatting\n#define INSCHAR_DO_COM\t2\t// format comments\n#define INSCHAR_CTRLV\t4\t// char typed just after CTRL-V\n#define INSCHAR_NO_FEX\t8\t// don't use 'formatexpr'\n#define INSCHAR_COM_LIST 16\t// format comments with list/2nd line indent\n\n// flags for open_line()\n#define OPENLINE_DELSPACES  1\t// delete spaces after cursor\n#define OPENLINE_DO_COM\t    2\t// format comments\n#define OPENLINE_KEEPTRAIL  4\t// keep trailing spaces\n#define OPENLINE_MARKFIX    8\t// fix mark positions\n#define OPENLINE_COM_LIST  16\t// format comments with list/2nd line indent\n\n// There are five history tables:\n#define HIST_CMD\t0\t// colon commands\n#define HIST_SEARCH\t1\t// search commands\n#define HIST_EXPR\t2\t// expressions (from entering = register)\n#define HIST_INPUT\t3\t// input() lines\n#define HIST_DEBUG\t4\t// debug commands\n#define HIST_COUNT\t5\t// number of history tables\n\n// The type numbers are fixed for backwards compatibility.\n#define BARTYPE_VERSION 1\n#define BARTYPE_HISTORY 2\n#define BARTYPE_REGISTER 3\n#define BARTYPE_MARK 4\n\n#define VIMINFO_VERSION 4\n#define VIMINFO_VERSION_WITH_HISTORY 2\n#define VIMINFO_VERSION_WITH_REGISTERS 3\n#define VIMINFO_VERSION_WITH_MARKS 4\n\n/*\n * Values for do_tag().\n */\n#define DT_TAG\t\t1\t// jump to newer position or same tag again\n#define DT_POP\t\t2\t// jump to older position\n#define DT_NEXT\t\t3\t// jump to next match of same tag\n#define DT_PREV\t\t4\t// jump to previous match of same tag\n#define DT_FIRST\t5\t// jump to first match of same tag\n#define DT_LAST\t\t6\t// jump to first match of same tag\n#define DT_SELECT\t7\t// jump to selection from list\n#define DT_HELP\t\t8\t// like DT_TAG, but no wildcards\n#define DT_JUMP\t\t9\t// jump to new tag or selection from list\n#define DT_CSCOPE\t10\t// cscope find command (like tjump)\n#define DT_LTAG\t\t11\t// tag using location list\n#define DT_FREE\t\t99\t// free cached matches\n\n/*\n * flags for find_tags().\n */\n#define TAG_HELP\t1\t// only search for help tags\n#define TAG_NAMES\t2\t// only return name of tag\n#define\tTAG_REGEXP\t4\t// use tag pattern as regexp\n#define\tTAG_NOIC\t8\t// don't always ignore case\n#ifdef FEAT_CSCOPE\n# define TAG_CSCOPE\t16\t// cscope tag\n#endif\n#define TAG_VERBOSE\t32\t// message verbosity\n#define TAG_INS_COMP\t64\t// Currently doing insert completion\n#define TAG_KEEP_LANG\t128\t// keep current language\n#define TAG_NO_TAGFUNC\t256\t// do not use 'tagfunc'\n\n#define TAG_MANY\t300\t// When finding many tags (for completion),\n\t\t\t\t// find up to this many tags\n\n/*\n * Types of dialogs passed to do_vim_dialog().\n */\n#define VIM_GENERIC\t0\n#define VIM_ERROR\t1\n#define VIM_WARNING\t2\n#define VIM_INFO\t3\n#define VIM_QUESTION\t4\n#define VIM_LAST_TYPE\t4\t// sentinel value\n\n/*\n * Return values for functions like gui_yesnocancel()\n */\n#define VIM_YES\t\t2\n#define VIM_NO\t\t3\n#define VIM_CANCEL\t4\n#define VIM_ALL\t\t5\n#define VIM_DISCARDALL  6\n\n/*\n * arguments for win_split()\n */\n#define WSP_ROOM\t1\t// require enough room\n#define WSP_VERT\t2\t// split vertically\n#define WSP_TOP\t\t4\t// window at top-left of shell\n#define WSP_BOT\t\t8\t// window at bottom-right of shell\n#define WSP_HELP\t16\t// creating the help window\n#define WSP_BELOW\t32\t// put new window below/right\n#define WSP_ABOVE\t64\t// put new window above/left\n#define WSP_NEWLOC\t128\t// don't copy location list\n\n/*\n * arguments for gui_set_shellsize()\n */\n#define RESIZE_VERT\t1\t// resize vertically\n#define RESIZE_HOR\t2\t// resize horizontally\n#define RESIZE_BOTH\t15\t// resize in both directions\n\n/*\n * flags for check_changed()\n */\n#define CCGD_AW\t\t1\t// do autowrite if buffer was changed\n#define CCGD_MULTWIN\t2\t// check also when several wins for the buf\n#define CCGD_FORCEIT\t4\t// ! used\n#define CCGD_ALLBUF\t8\t// may write all buffers\n#define CCGD_EXCMD\t16\t// may suggest using !\n\n/*\n * \"flags\" values for option-setting functions.\n * When OPT_GLOBAL and OPT_LOCAL are both missing, set both local and global\n * values, get local value.\n */\n#define OPT_FREE\t0x01\t// free old value if it was allocated\n#define OPT_GLOBAL\t0x02\t// use global value\n#define OPT_LOCAL\t0x04\t// use local value\n#define OPT_MODELINE\t0x08\t// option in modeline\n#define OPT_WINONLY\t0x10\t// only set window-local options\n#define OPT_NOWIN\t0x20\t// don't set window-local options\n#define OPT_ONECOLUMN\t0x40\t// list options one per line\n#define OPT_NO_REDRAW\t0x80\t// ignore redraw flags on option\n#define OPT_SKIPRTP\t0x100\t// \"skiprtp\" in 'sessionoptions'\n\n// Magic chars used in confirm dialog strings\n#define DLG_BUTTON_SEP\t'\\n'\n#define DLG_HOTKEY_CHAR\t'&'\n\n// Values for \"starting\"\n#define NO_SCREEN\t2\t// no screen updating yet\n#define NO_BUFFERS\t1\t// not all buffers loaded yet\n//\t\t\t0\t   not starting anymore\n\n// Values for swap_exists_action: what to do when swap file already exists\n#define SEA_NONE\t0\t// don't use dialog\n#define SEA_DIALOG\t1\t// use dialog when possible\n#define SEA_QUIT\t2\t// quit editing the file\n#define SEA_RECOVER\t3\t// recover the file\n\n/*\n * Minimal size for block 0 of a swap file.\n * NOTE: This depends on size of struct block0! It's not done with a sizeof(),\n * because struct block0 is defined in memline.c (Sorry).\n * The maximal block size is arbitrary.\n */\n#define MIN_SWAP_PAGE_SIZE 1048\n#define MAX_SWAP_PAGE_SIZE 50000\n\n// Special values for current_sctx.sc_sid.\n#define SID_MODELINE\t-1\t// when using a modeline\n#define SID_CMDARG\t-2\t// for \"--cmd\" argument\n#define SID_CARG\t-3\t// for \"-c\" argument\n#define SID_ENV\t\t-4\t// for sourcing environment variable\n#define SID_ERROR\t-5\t// option was reset because of an error\n#define SID_NONE\t-6\t// don't set scriptID\n#define SID_WINLAYOUT\t-7\t// changing window size\n\n/*\n * Events for autocommands.\n */\nenum auto_event\n{\n    EVENT_BUFADD = 0,\t\t// after adding a buffer to the buffer list\n    EVENT_BUFDELETE,\t\t// deleting a buffer from the buffer list\n    EVENT_BUFENTER,\t\t// after entering a buffer\n    EVENT_BUFFILEPOST,\t\t// after renaming a buffer\n    EVENT_BUFFILEPRE,\t\t// before renaming a buffer\n    EVENT_BUFHIDDEN,\t\t// just after buffer becomes hidden\n    EVENT_BUFLEAVE,\t\t// before leaving a buffer\n    EVENT_BUFNEW,\t\t// after creating any buffer\n    EVENT_BUFNEWFILE,\t\t// when creating a buffer for a new file\n    EVENT_BUFREADCMD,\t\t// read buffer using command\n    EVENT_BUFREADPOST,\t\t// after reading a buffer\n    EVENT_BUFREADPRE,\t\t// before reading a buffer\n    EVENT_BUFUNLOAD,\t\t// just before unloading a buffer\n    EVENT_BUFWINENTER,\t\t// after showing a buffer in a window\n    EVENT_BUFWINLEAVE,\t\t// just after buffer removed from window\n    EVENT_BUFWIPEOUT,\t\t// just before really deleting a buffer\n    EVENT_BUFWRITECMD,\t\t// write buffer using command\n    EVENT_BUFWRITEPOST,\t\t// after writing a buffer\n    EVENT_BUFWRITEPRE,\t\t// before writing a buffer\n    EVENT_CMDLINECHANGED,\t// command line was modified\n    EVENT_CMDLINEENTER,\t\t// after entering the command line\n    EVENT_CMDLINELEAVE,\t\t// before leaving the command line\n    EVENT_CMDUNDEFINED,\t\t// command undefined\n    EVENT_CMDWINENTER,\t\t// after entering the cmdline window\n    EVENT_CMDWINLEAVE,\t\t// before leaving the cmdline window\n    EVENT_COLORSCHEME,\t\t// after loading a colorscheme\n    EVENT_COLORSCHEMEPRE,\t// before loading a colorscheme\n    EVENT_COMPLETECHANGED,\t// after completion popup menu changed\n    EVENT_COMPLETEDONE,\t\t// after finishing insert complete\n    EVENT_COMPLETEDONEPRE,\t// idem, before clearing info\n    EVENT_CURSORHOLD,\t\t// cursor in same position for a while\n    EVENT_CURSORHOLDI,\t\t// idem, in Insert mode\n    EVENT_CURSORMOVED,\t\t// cursor was moved\n    EVENT_CURSORMOVEDI,\t\t// cursor was moved in Insert mode\n    EVENT_DIFFUPDATED,\t\t// after diffs were updated\n    EVENT_DIRCHANGED,\t\t// after user changed directory\n    EVENT_ENCODINGCHANGED,\t// after changing the 'encoding' option\n    EVENT_EXITPRE,\t\t// before exiting\n    EVENT_FILEAPPENDCMD,\t// append to a file using command\n    EVENT_FILEAPPENDPOST,\t// after appending to a file\n    EVENT_FILEAPPENDPRE,\t// before appending to a file\n    EVENT_FILECHANGEDRO,\t// before first change to read-only file\n    EVENT_FILECHANGEDSHELL,\t// after shell command that changed file\n    EVENT_FILECHANGEDSHELLPOST,\t// after (not) reloading changed file\n    EVENT_FILEREADCMD,\t\t// read from a file using command\n    EVENT_FILEREADPOST,\t\t// after reading a file\n    EVENT_FILEREADPRE,\t\t// before reading a file\n    EVENT_FILETYPE,\t\t// new file type detected (user defined)\n    EVENT_FILEWRITECMD,\t\t// write to a file using command\n    EVENT_FILEWRITEPOST,\t// after writing a file\n    EVENT_FILEWRITEPRE,\t\t// before writing a file\n    EVENT_FILTERREADPOST,\t// after reading from a filter\n    EVENT_FILTERREADPRE,\t// before reading from a filter\n    EVENT_FILTERWRITEPOST,\t// after writing to a filter\n    EVENT_FILTERWRITEPRE,\t// before writing to a filter\n    EVENT_FOCUSGAINED,\t\t// got the focus\n    EVENT_FOCUSLOST,\t\t// lost the focus to another app\n    EVENT_FUNCUNDEFINED,\t// if calling a function which doesn't exist\n    EVENT_GUIENTER,\t\t// after starting the GUI\n    EVENT_GUIFAILED,\t\t// after starting the GUI failed\n    EVENT_INSERTCHANGE,\t\t// when changing Insert/Replace mode\n    EVENT_INSERTCHARPRE,\t// before inserting a char\n    EVENT_INSERTENTER,\t\t// when entering Insert mode\n    EVENT_INSERTLEAVEPRE,\t// just before leaving Insert mode\n    EVENT_INSERTLEAVE,\t\t// just after leaving Insert mode\n    EVENT_MENUPOPUP,\t\t// just before popup menu is displayed\n    EVENT_MODECHANGED,\t\t// after changing the mode\n    EVENT_OPTIONSET,\t\t// option was set\n    EVENT_QUICKFIXCMDPOST,\t// after :make, :grep etc.\n    EVENT_QUICKFIXCMDPRE,\t// before :make, :grep etc.\n    EVENT_QUITPRE,\t\t// before :quit\n    EVENT_REMOTEREPLY,\t\t// upon string reception from a remote vim\n    EVENT_SAFESTATE,\t\t// going to wait for a character\n    EVENT_SAFESTATEAGAIN,\t// still waiting for a character\n    EVENT_SESSIONLOADPOST,\t// after loading a session file\n    EVENT_SHELLCMDPOST,\t\t// after \":!cmd\"\n    EVENT_SHELLFILTERPOST,\t// after \":1,2!cmd\", \":w !cmd\", \":r !cmd\".\n    EVENT_SIGUSR1,\t\t// after the SIGUSR1 signal\n    EVENT_SOURCECMD,\t\t// sourcing a Vim script using command\n    EVENT_SOURCEPRE,\t\t// before sourcing a Vim script\n    EVENT_SOURCEPOST,\t\t// after sourcing a Vim script\n    EVENT_SPELLFILEMISSING,\t// spell file missing\n    EVENT_STDINREADPOST,\t// after reading from stdin\n    EVENT_STDINREADPRE,\t\t// before reading from stdin\n    EVENT_SWAPEXISTS,\t\t// found existing swap file\n    EVENT_SYNTAX,\t\t// syntax selected\n    EVENT_TABCLOSED,\t\t// after closing a tab page\n    EVENT_TABENTER,\t\t// after entering a tab page\n    EVENT_TABLEAVE,\t\t// before leaving a tab page\n    EVENT_TABNEW,\t\t// when entering a new tab page\n    EVENT_TERMCHANGED,\t\t// after changing 'term'\n    EVENT_TERMINALOPEN,\t\t// after a terminal buffer was created\n    EVENT_TERMINALWINOPEN,\t// after a terminal buffer was created and\n\t\t\t\t// entering its window\n    EVENT_TERMRESPONSE,\t\t// after setting \"v:termresponse\"\n    EVENT_TEXTCHANGED,\t\t// text was modified not in Insert mode\n    EVENT_TEXTCHANGEDI,         // text was modified in Insert mode\n    EVENT_TEXTCHANGEDP,         // TextChangedI with popup menu visible\n    EVENT_TEXTYANKPOST,\t\t// after some text was yanked\n    EVENT_USER,\t\t\t// user defined autocommand\n    EVENT_VIMENTER,\t\t// after starting Vim\n    EVENT_VIMLEAVE,\t\t// before exiting Vim\n    EVENT_VIMLEAVEPRE,\t\t// before exiting Vim and writing .viminfo\n    EVENT_VIMRESIZED,\t\t// after Vim window was resized\n    EVENT_WINENTER,\t\t// after entering a window\n    EVENT_WINLEAVE,\t\t// before leaving a window\n    EVENT_WINNEW,\t\t// when entering a new window\n    EVENT_WINCLOSED,\t\t// after closing a window\n    EVENT_VIMSUSPEND,\t\t// before Vim is suspended\n    EVENT_VIMRESUME,\t\t// after Vim is resumed\n\n    NUM_EVENTS\t\t\t// MUST be the last one\n};\n\ntypedef enum auto_event event_T;\n\n/*\n * Values for index in highlight_attr[].\n * When making changes, also update HL_FLAGS below!  And update the default\n * value of 'highlight' in option.c.\n */\ntypedef enum\n{\n    HLF_8 = 0\t    // Meta & special keys listed with \":map\", text that is\n\t\t    // displayed different from what it is\n    , HLF_EOB\t    // after the last line in the buffer\n    , HLF_AT\t    // @ characters at end of screen, characters that\n\t\t    // don't really exist in the text\n    , HLF_D\t    // directories in CTRL-D listing\n    , HLF_E\t    // error messages\n    , HLF_H\t    // obsolete, ignored\n    , HLF_I\t    // incremental search\n    , HLF_L\t    // last search string\n    , HLF_M\t    // \"--More--\" message\n    , HLF_CM\t    // Mode (e.g., \"-- INSERT --\")\n    , HLF_N\t    // line number for \":number\" and \":#\" commands\n    , HLF_LNA\t    // LineNrAbove\n    , HLF_LNB\t    // LineNrBelow\n    , HLF_CLN\t    // current line number\n    , HLF_CLS\t    // current line sign column\n    , HLF_CLF\t    // current line fold\n    , HLF_R\t    // return to continue message and yes/no questions\n    , HLF_S\t    // status lines\n    , HLF_SNC\t    // status lines of not-current windows\n    , HLF_C\t    // column to separate vertically split windows\n    , HLF_T\t    // Titles for output from \":set all\", \":autocmd\" etc.\n    , HLF_V\t    // Visual mode\n    , HLF_VNC\t    // Visual mode, autoselecting and not clipboard owner\n    , HLF_W\t    // warning messages\n    , HLF_WM\t    // Wildmenu highlight\n    , HLF_FL\t    // Folded line\n    , HLF_FC\t    // Fold column\n    , HLF_ADD\t    // Added diff line\n    , HLF_CHD\t    // Changed diff line\n    , HLF_DED\t    // Deleted diff line\n    , HLF_TXD\t    // Text Changed in diff line\n    , HLF_CONCEAL   // Concealed text\n    , HLF_SC\t    // Sign column\n    , HLF_SPB\t    // SpellBad\n    , HLF_SPC\t    // SpellCap\n    , HLF_SPR\t    // SpellRare\n    , HLF_SPL\t    // SpellLocal\n    , HLF_PNI\t    // popup menu normal item\n    , HLF_PSI\t    // popup menu selected item\n    , HLF_PSB\t    // popup menu scrollbar\n    , HLF_PST\t    // popup menu scrollbar thumb\n    , HLF_TP\t    // tabpage line\n    , HLF_TPS\t    // tabpage line selected\n    , HLF_TPF\t    // tabpage line filler\n    , HLF_CUC\t    // 'cursorcolumn'\n    , HLF_CUL\t    // 'cursorline'\n    , HLF_MC\t    // 'colorcolumn'\n    , HLF_QFL\t    // quickfix window line currently selected\n    , HLF_ST\t    // status lines of terminal windows\n    , HLF_STNC\t    // status lines of not-current terminal windows\n    , HLF_COUNT\t    // MUST be the last one\n} hlf_T;\n\n// The HL_FLAGS must be in the same order as the HLF_ enums!\n// When changing this also adjust the default for 'highlight'.\n#define HL_FLAGS {'8', '~', '@', 'd', 'e', 'h', 'i', 'l', 'm', 'M', \\\n\t\t  'n', 'a', 'b', 'N', 'G', 'O', 'r', 's', 'S', 'c', 't', 'v', 'V', \\\n\t\t  'w', 'W', 'f', 'F', 'A', 'C', 'D', 'T', '-', '>', \\\n\t\t  'B', 'P', 'R', 'L', \\\n\t\t  '+', '=', 'x', 'X', '*', '#', '_', '!', '.', 'o', 'q', \\\n\t\t  'z', 'Z'}\n\n/*\n * Boolean constants\n */\n#ifndef TRUE\n# define FALSE\t0\t    // note: this is an int, not a long!\n# define TRUE\t1\n#endif\n\n#define MAYBE\t2\t    // sometimes used for a variant on TRUE\n\n#ifndef UINT32_T\ntypedef UINT32_TYPEDEF UINT32_T;\n#endif\n\n/*\n * Operator IDs; The order must correspond to opchars[] in ops.c!\n */\n#define OP_NOP\t\t0\t// no pending operation\n#define OP_DELETE\t1\t// \"d\"  delete operator\n#define OP_YANK\t\t2\t// \"y\"  yank operator\n#define OP_CHANGE\t3\t// \"c\"  change operator\n#define OP_LSHIFT\t4\t// \"<\"  left shift operator\n#define OP_RSHIFT\t5\t// \">\"  right shift operator\n#define OP_FILTER\t6\t// \"!\"  filter operator\n#define OP_TILDE\t7\t// \"g~\" switch case operator\n#define OP_INDENT\t8\t// \"=\"  indent operator\n#define OP_FORMAT\t9\t// \"gq\" format operator\n#define OP_COLON\t10\t// \":\"  colon operator\n#define OP_UPPER\t11\t// \"gU\" make upper case operator\n#define OP_LOWER\t12\t// \"gu\" make lower case operator\n#define OP_JOIN\t\t13\t// \"J\"  join operator, only for Visual mode\n#define OP_JOIN_NS\t14\t// \"gJ\"  join operator, only for Visual mode\n#define OP_ROT13\t15\t// \"g?\" rot-13 encoding\n#define OP_REPLACE\t16\t// \"r\"  replace chars, only for Visual mode\n#define OP_INSERT\t17\t// \"I\"  Insert column, only for Visual mode\n#define OP_APPEND\t18\t// \"A\"  Append column, only for Visual mode\n#define OP_FOLD\t\t19\t// \"zf\" define a fold\n#define OP_FOLDOPEN\t20\t// \"zo\" open folds\n#define OP_FOLDOPENREC\t21\t// \"zO\" open folds recursively\n#define OP_FOLDCLOSE\t22\t// \"zc\" close folds\n#define OP_FOLDCLOSEREC\t23\t// \"zC\" close folds recursively\n#define OP_FOLDDEL\t24\t// \"zd\" delete folds\n#define OP_FOLDDELREC\t25\t// \"zD\" delete folds recursively\n#define OP_FORMAT2\t26\t// \"gw\" format operator, keeps cursor pos\n#define OP_FUNCTION\t27\t// \"g@\" call 'operatorfunc'\n#define OP_NR_ADD\t28\t// \"<C-A>\" Add to the number or alphabetic\n\t\t\t\t// character (OP_ADD conflicts with Perl)\n#define OP_NR_SUB\t29\t// \"<C-X>\" Subtract from the number or\n\t\t\t\t// alphabetic character\n\n/*\n * Motion types, used for operators and for yank/delete registers.\n */\n#define MCHAR\t0\t\t// character-wise movement/register\n#define MLINE\t1\t\t// line-wise movement/register\n#define MBLOCK\t2\t\t// block-wise register\n\n#define MAUTO\t0xff\t\t// Decide between MLINE/MCHAR\n\n/*\n * Minimum screen size\n */\n#define MIN_COLUMNS\t12\t// minimal columns for screen\n#define MIN_LINES\t2\t// minimal lines for screen\n#define STATUS_HEIGHT\t1\t// height of a status line under a window\n#ifdef FEAT_MENU\t\t// height of a status line under a window\n# define WINBAR_HEIGHT(wp)\t(wp)->w_winbar_height\n# define VISIBLE_HEIGHT(wp)\t((wp)->w_height + (wp)->w_winbar_height)\n#else\n# define WINBAR_HEIGHT(wp)\t0\n# define VISIBLE_HEIGHT(wp)\t(wp)->w_height\n#endif\n#define QF_WINHEIGHT\t10\t// default height for quickfix window\n\n/*\n * Buffer sizes\n */\n#ifndef CMDBUFFSIZE\n# define CMDBUFFSIZE\t256\t// size of the command processing buffer\n#endif\n\n#define LSIZE\t    512\t\t// max. size of a line in the tags file\n\n#define IOSIZE\t   (1024+1)\t// file i/o and sprintf buffer size\n\n#define DIALOG_MSG_SIZE 1000\t// buffer size for dialog_msg()\n\n#define MSG_BUF_LEN 480\t// length of buffer for small messages\n#define MSG_BUF_CLEN  (MSG_BUF_LEN / 6)    // cell length (worst case: utf-8\n\t\t\t\t\t   // takes 6 bytes for one cell)\n\n#define FOLD_TEXT_LEN  51\t// buffer size for get_foldtext()\n\n// Size of the buffer used for tgetent().  Unfortunately this is largely\n// undocumented, some systems use 1024.  Using a buffer that is too small\n// causes a buffer overrun and a crash.  Use the maximum known value to stay\n// on the safe side.\n#define TBUFSZ 2048\t\t// buffer size for termcap entry\n\n/*\n * Maximum length of key sequence to be mapped.\n * Must be able to hold an Amiga resize report.\n */\n#define MAXMAPLEN   50\n\n// Size in bytes of the hash used in the undo file.\n#define UNDO_HASH_SIZE 32\n\n#ifdef HAVE_FCNTL_H\n# include <fcntl.h>\n#endif\n\n#ifdef BINARY_FILE_IO\n# define WRITEBIN   \"wb\"\t// no CR-LF translation\n# define READBIN    \"rb\"\n# define APPENDBIN  \"ab\"\n#else\n# define WRITEBIN   \"w\"\n# define READBIN    \"r\"\n# define APPENDBIN  \"a\"\n#endif\n\n/*\n * EMX doesn't have a global way of making open() use binary I/O.\n * Use O_BINARY for all open() calls.\n */\n#if defined(__CYGWIN32__)\n# define O_EXTRA    O_BINARY\n#else\n# define O_EXTRA    0\n#endif\n\n#ifndef O_NOFOLLOW\n# define O_NOFOLLOW 0\n#endif\n\n#ifndef W_OK\n# define W_OK 2\t\t// for systems that don't have W_OK in unistd.h\n#endif\n#ifndef R_OK\n# define R_OK 4\t\t// for systems that don't have R_OK in unistd.h\n#endif\n\n// Allocate memory for one type and cast the returned pointer to have the\n// compiler check the types.\n#define ALLOC_ONE(type)  (type *)alloc(sizeof(type))\n#define ALLOC_MULT(type, count)  (type *)alloc(sizeof(type) * (count))\n#define ALLOC_CLEAR_ONE(type)  (type *)alloc_clear(sizeof(type))\n#define ALLOC_CLEAR_MULT(type, count)  (type *)alloc_clear(sizeof(type) * (count))\n#define LALLOC_CLEAR_ONE(type)  (type *)lalloc_clear(sizeof(type), FALSE)\n#define LALLOC_CLEAR_MULT(type, count)  (type *)lalloc_clear(sizeof(type) * (count), FALSE)\n#define LALLOC_MULT(type, count)  (type *)lalloc(sizeof(type) * (count), FALSE)\n\n#ifdef HAVE_MEMSET\n# define vim_memset(ptr, c, size)   memset((ptr), (c), (size))\n#else\nvoid *vim_memset(void *, int, size_t);\n#endif\n#define CLEAR_FIELD(field)  vim_memset(&(field), 0, sizeof(field))\n#define CLEAR_POINTER(ptr)  vim_memset((ptr), 0, sizeof(*(ptr)))\n\n/*\n * defines to avoid typecasts from (char_u *) to (char *) and back\n * (vim_strchr() and vim_strrchr() are now in alloc.c)\n */\n#define STRLEN(s)\t    strlen((char *)(s))\n#define STRCPY(d, s)\t    strcpy((char *)(d), (char *)(s))\n#define STRNCPY(d, s, n)    strncpy((char *)(d), (char *)(s), (size_t)(n))\n#define STRCMP(d, s)\t    strcmp((char *)(d), (char *)(s))\n#define STRNCMP(d, s, n)    strncmp((char *)(d), (char *)(s), (size_t)(n))\n#ifdef HAVE_STRCASECMP\n# define STRICMP(d, s)\t    strcasecmp((char *)(d), (char *)(s))\n#else\n# ifdef HAVE_STRICMP\n#  define STRICMP(d, s)\t    stricmp((char *)(d), (char *)(s))\n# else\n#  define STRICMP(d, s)\t    vim_stricmp((char *)(d), (char *)(s))\n# endif\n#endif\n#ifdef HAVE_STRCOLL\n# define STRCOLL(d, s)     strcoll((char *)(d), (char *)(s))\n#else\n# define STRCOLL(d, s)     strcmp((char *)(d), (char *)(s))\n#endif\n\n// Like strcpy() but allows overlapped source and destination.\n#define STRMOVE(d, s)\t    mch_memmove((d), (s), STRLEN(s) + 1)\n\n#ifdef HAVE_STRNCASECMP\n# define STRNICMP(d, s, n)  strncasecmp((char *)(d), (char *)(s), (size_t)(n))\n#else\n# ifdef HAVE_STRNICMP\n#  define STRNICMP(d, s, n) strnicmp((char *)(d), (char *)(s), (size_t)(n))\n# else\n#  define STRNICMP(d, s, n) vim_strnicmp((char *)(d), (char *)(s), (size_t)(n))\n# endif\n#endif\n\n// We need to call mb_stricmp() even when we aren't dealing with a multi-byte\n// encoding because mb_stricmp() takes care of all ascii and non-ascii\n// encodings, including characters with umlauts in latin1, etc., while\n// STRICMP() only handles the system locale version, which often does not\n// handle non-ascii properly.\n\n# define MB_STRICMP(d, s)\tmb_strnicmp((char_u *)(d), (char_u *)(s), (int)MAXCOL)\n# define MB_STRNICMP(d, s, n)\tmb_strnicmp((char_u *)(d), (char_u *)(s), (int)(n))\n\n#define STRCAT(d, s)\t    strcat((char *)(d), (char *)(s))\n#define STRNCAT(d, s, n)    strncat((char *)(d), (char *)(s), (size_t)(n))\n\n#ifdef HAVE_STRPBRK\n# define vim_strpbrk(s, cs) (char_u *)strpbrk((char *)(s), (char *)(cs))\n#endif\n\n#define OUT_STR(s)\t\t    out_str((char_u *)(s))\n#define OUT_STR_NF(s)\t\t    out_str_nf((char_u *)(s))\n\n#ifdef FEAT_GUI\n# ifdef FEAT_TERMGUICOLORS\n#  define GUI_FUNCTION(f)\t    (gui.in_use ? gui_##f : termgui_##f)\n#  define GUI_FUNCTION2(f, pixel)   (gui.in_use \\\n\t\t\t\t    ?  ((pixel) != INVALCOLOR \\\n\t\t\t\t\t? gui_##f((pixel)) \\\n\t\t\t\t\t: INVALCOLOR) \\\n\t\t\t\t    : termgui_##f((pixel)))\n#  define USE_24BIT\t\t    (gui.in_use || p_tgc)\n# else\n#  define GUI_FUNCTION(f)\t    gui_##f\n#  define GUI_FUNCTION2(f,pixel)    ((pixel) != INVALCOLOR \\\n\t\t\t\t     ? gui_##f((pixel)) \\\n\t\t\t\t     : INVALCOLOR)\n#  define USE_24BIT\t\t    gui.in_use\n# endif\n#else\n# ifdef FEAT_TERMGUICOLORS\n#  define GUI_FUNCTION(f)\t    termgui_##f\n#  define GUI_FUNCTION2(f, pixel)   termgui_##f((pixel))\n#  define USE_24BIT\t\t    p_tgc\n# endif\n#endif\n#ifdef FEAT_TERMGUICOLORS\n# define IS_CTERM\t\t    (t_colors > 1 || p_tgc)\n#else\n# define IS_CTERM\t\t    (t_colors > 1)\n#endif\n#ifdef GUI_FUNCTION\n# define GUI_MCH_GET_RGB\t    GUI_FUNCTION(mch_get_rgb)\n# define GUI_MCH_GET_RGB2(pixel)    GUI_FUNCTION2(mch_get_rgb, (pixel))\n# define GUI_MCH_GET_COLOR\t    GUI_FUNCTION(mch_get_color)\n# define GUI_GET_COLOR\t\t    GUI_FUNCTION(get_color)\n#endif\n\n// Prefer using emsgf(), because perror() may send the output to the wrong\n// destination and mess up the screen.\n#ifdef HAVE_STRERROR\n# define PERROR(msg)\t\t    (void)semsg(\"%s: %s\", (char *)msg, strerror(errno))\n#else\n# define PERROR(msg)\t\t    do_perror(msg)\n#endif\n\ntypedef long\tlinenr_T;\t\t// line number type\ntypedef int\tcolnr_T;\t\t// column number type\ntypedef unsigned short disptick_T;\t// display tick type\n\n/*\n * Well, you won't believe it, but some S/390 machines (\"host\", now also known\n * as zServer) use 31 bit pointers. There are also some newer machines, that\n * use 64 bit pointers. I don't know how to distinguish between 31 and 64 bit\n * machines, so the best way is to assume 31 bits whenever we detect OS/390\n * Unix.\n * With this we restrict the maximum line length to 1073741823. I guess this is\n * not a real problem. BTW:  Longer lines are split.\n */\n#ifdef __MVS__\n# define MAXCOL (0x3fffffffL)\t\t// maximum column number, 30 bits\n# define MAXLNUM (0x3fffffffL)\t\t// maximum (invalid) line number\n#else\n# define MAXCOL  INT_MAX\t\t// maximum column number\n# define MAXLNUM LONG_MAX\t\t// maximum (invalid) line number\n#endif\n\n#define SHOWCMD_COLS 10\t\t\t// columns needed by shown command\n\ntypedef void\t    *vim_acl_T;\t\t// dummy to pass an ACL to a function\n\n#ifndef mch_memmove\n# define mch_memmove(to, from, len) memmove((char*)(to), (char*)(from), (size_t)(len))\n#endif\n\n/*\n * fnamecmp() is used to compare file names.\n * On some systems case in a file name does not matter, on others it does.\n * (this does not account for maximum name lengths and things like \"../dir\",\n * thus it is not 100% accurate!)\n */\n#define fnamecmp(x, y) vim_fnamecmp((char_u *)(x), (char_u *)(y))\n#define fnamencmp(x, y, n) vim_fnamencmp((char_u *)(x), (char_u *)(y), (size_t)(n))\n\n#if defined(UNIX) || defined(FEAT_GUI) || defined(VMS) \\\n\t|| defined(FEAT_CLIENTSERVER)\n# define USE_INPUT_BUF\n#endif\n\n#ifndef EINTR\n# define read_eintr(fd, buf, count) vim_read((fd), (buf), (count))\n# define write_eintr(fd, buf, count) vim_write((fd), (buf), (count))\n#endif\n\n#ifdef MSWIN\n// On MS-Windows the third argument isn't size_t.  This matters for Win64,\n// where sizeof(size_t)==8, not 4\n# define vim_read(fd, buf, count)   read((fd), (char *)(buf), (unsigned int)(count))\n# define vim_write(fd, buf, count)  write((fd), (char *)(buf), (unsigned int)(count))\n#else\n# define vim_read(fd, buf, count)   read((fd), (char *)(buf), (size_t) (count))\n# define vim_write(fd, buf, count)  write((fd), (char *)(buf), (size_t) (count))\n#endif\n\n/*\n * Enums need a typecast to be used as array index (for Ultrix).\n */\n#define HL_ATTR(n)\thighlight_attr[(int)(n)]\n#define TERM_STR(n)\tterm_strings[(int)(n)]\n\n/*\n * EXTERN is only defined in main.c.  That's where global variables are\n * actually defined and initialized.\n */\n#ifndef EXTERN\n# define EXTERN extern\n# define INIT(x)\n# define INIT2(a, b)\n# define INIT3(a, b, c)\n# define INIT4(a, b, c, d)\n# define INIT5(a, b, c, d, e)\n# define INIT6(a, b, c, d, e, f)\n#else\n# ifndef INIT\n#  define INIT(x) x\n#  define INIT2(a, b) = {a, b}\n#  define INIT3(a, b, c) = {a, b, c}\n#  define INIT4(a, b, c, d) = {a, b, c, d}\n#  define INIT5(a, b, c, d, e) = {a, b, c, d, e}\n#  define INIT6(a, b, c, d, e, f) = {a, b, c, d, e, f}\n#  define DO_INIT\n# endif\n#endif\n\n#define MAX_MCO\t6\t// maximum value for 'maxcombine'\n\n// Maximum number of bytes in a multi-byte character.  It can be one 32-bit\n// character of up to 6 bytes, or one 16-bit character of up to three bytes\n// plus six following composing characters of three bytes each.\n#define MB_MAXBYTES\t21\n\n#if (defined(FEAT_PROFILE) || defined(FEAT_RELTIME)) && !defined(PROTO)\n# ifdef MSWIN\ntypedef LARGE_INTEGER proftime_T;\n# else\ntypedef struct timeval proftime_T;\n# endif\n#else\ntypedef int proftime_T;\t    // dummy for function prototypes\n#endif\n\n// Type of compilation passed to compile_def_function()\ntypedef enum {\n    CT_NONE,\t    // use df_instr\n    CT_PROFILE,\t    // use df_instr_prof\n    CT_DEBUG\t    // use df_instr_debug, overrules CT_PROFILE\n} compiletype_T;\n\n// Keep in sync with INSTRUCTIONS().\n#ifdef FEAT_PROFILE\n# define COMPILE_TYPE(ufunc) (debug_break_level > 0 \\\n\t|| may_break_in_function(ufunc) \\\n\t\t? CT_DEBUG \\\n\t\t: do_profiling == PROF_YES && (ufunc)->uf_profiling \\\n\t\t\t? CT_PROFILE : CT_NONE)\n#else\n# define COMPILE_TYPE(ufunc) debug_break_level > 0 \\\n\t|| may_break_in_function(ufunc) \\\n\t\t? CT_DEBUG \\\n\t\t: CT_NONE\n#endif\n\n/*\n * When compiling with 32 bit Perl time_t is 32 bits in the Perl code but 64\n * bits elsewhere.  That causes memory corruption.  Define time_T and use it\n * for global variables to avoid that.\n */\n#ifdef PROTO\ntypedef long  time_T;\n#else\n# ifdef MSWIN\ntypedef __time64_t  time_T;\n# else\ntypedef time_t\t    time_T;\n# endif\n#endif\n\n#ifdef _WIN64\ntypedef __int64 sock_T;\n#else\ntypedef int sock_T;\n#endif\n\n// Include option.h before structs.h, because the number of window-local and\n// buffer-local options is used there.\n#include \"option.h\"\t// options and default values\n\n#include \"beval.h\"\t// BalloonEval\n\n// Note that gui.h is included by structs.h\n\n#include \"structs.h\"\t// defines many structures\n\n#include \"alloc.h\"\n\n// Values for \"do_profiling\".\n#define PROF_NONE\t0\t// profiling not started\n#define PROF_YES\t1\t// profiling busy\n#define PROF_PAUSED\t2\t// profiling paused\n\n\n// Codes for mouse button events in lower three bits:\n#define MOUSE_LEFT\t0x00\n#define MOUSE_MIDDLE\t0x01\n#define MOUSE_RIGHT\t0x02\n#define MOUSE_RELEASE\t0x03\n\n// bit masks for modifiers:\n#define MOUSE_SHIFT\t0x04\n#define MOUSE_ALT\t0x08\n#define MOUSE_CTRL\t0x10\n\n// mouse buttons that are handled like a key press (GUI only)\n// Note that the scroll wheel keys are inverted: MOUSE_5 scrolls lines up but\n// the result of this is that the window moves down, similarly MOUSE_6 scrolls\n// columns left but the window moves right.\n#define MOUSE_4\t0x100\t// scroll wheel down\n#define MOUSE_5\t0x200\t// scroll wheel up\n\n#define MOUSE_X1\t0x300 // Mouse-button X1 (6th)\n#define MOUSE_X2\t0x400 // Mouse-button X2\n\n#define MOUSE_6\t0x500\t// scroll wheel left\n#define MOUSE_7\t0x600\t// scroll wheel right\n\n#define MOUSE_MOVE 0x700    // report mouse moved\n\n// 0x20 is reserved by xterm\n#define MOUSE_DRAG_XTERM   0x40\n\n#define MOUSE_DRAG\t(0x40 | MOUSE_RELEASE)\n\n// Lowest button code for using the mouse wheel (xterm only)\n#define MOUSEWHEEL_LOW\t\t0x60\n\n#define MOUSE_CLICK_MASK\t0x03\n\n#define NUM_MOUSE_CLICKS(code) \\\n    (((unsigned)((code) & 0xC0) >> 6) + 1)\n\n#define SET_NUM_MOUSE_CLICKS(code, num) \\\n    (code) = ((code) & 0x3f) | ((((num) - 1) & 3) << 6)\n\n// Added to mouse column for GUI when 'mousefocus' wants to give focus to a\n// window by simulating a click on its status line.  We could use up to 128 *\n// 128 = 16384 columns, now it's reduced to 10000.\n#define MOUSE_COLOFF 10000\n\n/*\n * jump_to_mouse() returns one of first four these values, possibly with\n * some of the other three added.\n */\n#define IN_UNKNOWN\t\t0\n#define IN_BUFFER\t\t1\n#define IN_STATUS_LINE\t\t2\t// on status or command line\n#define IN_SEP_LINE\t\t4\t// on vertical separator line\n#define IN_OTHER_WIN\t\t8\t// in other window but can't go there\n#define CURSOR_MOVED\t\t0x100\n#define MOUSE_FOLD_CLOSE\t0x200\t// clicked on '-' in fold column\n#define MOUSE_FOLD_OPEN\t\t0x400\t// clicked on '+' in fold column\n#define MOUSE_WINBAR\t\t0x800\t// in window toolbar\n\n// flags for jump_to_mouse()\n#define MOUSE_FOCUS\t\t0x01\t// need to stay in this window\n#define MOUSE_MAY_VIS\t\t0x02\t// may start Visual mode\n#define MOUSE_DID_MOVE\t\t0x04\t// only act when mouse has moved\n#define MOUSE_SETPOS\t\t0x08\t// only set current mouse position\n#define MOUSE_MAY_STOP_VIS\t0x10\t// may stop Visual mode\n#define MOUSE_RELEASED\t\t0x20\t// button was released\n\n#if defined(UNIX) && defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)\n# define CHECK_DOUBLE_CLICK 1\t// Checking for double clicks ourselves.\n#endif\n\n\n// defines for eval_vars()\n#define VALID_PATH\t\t1\n#define VALID_HEAD\t\t2\n\n// Defines for Vim variables.  These must match vimvars[] in evalvars.c!\n#define VV_COUNT\t0\n#define VV_COUNT1\t1\n#define VV_PREVCOUNT\t2\n#define VV_ERRMSG\t3\n#define VV_WARNINGMSG\t4\n#define VV_STATUSMSG\t5\n#define VV_SHELL_ERROR\t6\n#define VV_THIS_SESSION\t7\n#define VV_VERSION\t8\n#define VV_LNUM\t\t9\n#define VV_TERMRESPONSE\t10\n#define VV_FNAME\t11\n#define VV_LANG\t\t12\n#define VV_LC_TIME\t13\n#define VV_CTYPE\t14\n#define VV_CC_FROM\t15\n#define VV_CC_TO\t16\n#define VV_FNAME_IN\t17\n#define VV_FNAME_OUT\t18\n#define VV_FNAME_NEW\t19\n#define VV_FNAME_DIFF\t20\n#define VV_CMDARG\t21\n#define VV_FOLDSTART\t22\n#define VV_FOLDEND\t23\n#define VV_FOLDDASHES\t24\n#define VV_FOLDLEVEL\t25\n#define VV_PROGNAME\t26\n#define VV_SEND_SERVER\t27\n#define VV_DYING\t28\n#define VV_EXCEPTION\t29\n#define VV_THROWPOINT\t30\n#define VV_REG\t\t31\n#define VV_CMDBANG\t32\n#define VV_INSERTMODE\t33\n#define VV_VAL\t\t34\n#define VV_KEY\t\t35\n#define VV_PROFILING\t36\n#define VV_FCS_REASON\t37\n#define VV_FCS_CHOICE\t38\n#define VV_BEVAL_BUFNR\t39\n#define VV_BEVAL_WINNR\t40\n#define VV_BEVAL_WINID\t41\n#define VV_BEVAL_LNUM\t42\n#define VV_BEVAL_COL\t43\n#define VV_BEVAL_TEXT\t44\n#define VV_SCROLLSTART\t45\n#define VV_SWAPNAME\t46\n#define VV_SWAPCHOICE\t47\n#define VV_SWAPCOMMAND\t48\n#define VV_CHAR\t\t49\n#define VV_MOUSE_WIN\t50\n#define VV_MOUSE_WINID\t51\n#define VV_MOUSE_LNUM   52\n#define VV_MOUSE_COL\t53\n#define VV_OP\t\t54\n#define VV_SEARCHFORWARD 55\n#define VV_HLSEARCH\t56\n#define VV_OLDFILES\t57\n#define VV_WINDOWID\t58\n#define VV_PROGPATH\t59\n#define VV_COMPLETED_ITEM 60\n#define VV_OPTION_NEW   61\n#define VV_OPTION_OLD   62\n#define VV_OPTION_OLDLOCAL 63\n#define VV_OPTION_OLDGLOBAL 64\n#define VV_OPTION_COMMAND 65\n#define VV_OPTION_TYPE  66\n#define VV_ERRORS\t67\n#define VV_FALSE\t68\n#define VV_TRUE\t\t69\n#define VV_NONE\t\t70\n#define VV_NULL\t\t71\n#define VV_NUMBERMAX\t72\n#define VV_NUMBERMIN\t73\n#define VV_NUMBERSIZE\t74\n#define VV_VIM_DID_ENTER 75\n#define VV_TESTING\t76\n#define VV_TYPE_NUMBER\t77\n#define VV_TYPE_STRING\t78\n#define VV_TYPE_FUNC\t79\n#define VV_TYPE_LIST\t80\n#define VV_TYPE_DICT\t81\n#define VV_TYPE_FLOAT\t82\n#define VV_TYPE_BOOL\t83\n#define VV_TYPE_NONE\t84\n#define VV_TYPE_JOB\t85\n#define VV_TYPE_CHANNEL\t86\n#define VV_TYPE_BLOB\t87\n#define VV_TERMRFGRESP\t88\n#define VV_TERMRBGRESP\t89\n#define VV_TERMU7RESP\t90\n#define VV_TERMSTYLERESP 91\n#define VV_TERMBLINKRESP 92\n#define VV_EVENT\t93\n#define VV_VERSIONLONG\t94\n#define VV_ECHOSPACE\t95\n#define VV_ARGV\t\t96\n#define VV_COLLATE      97\n#define VV_EXITING\t98\n#define VV_COLORNAMES   99\n#define VV_SIZEOFINT\t100\n#define VV_SIZEOFLONG\t101\n#define VV_SIZEOFPOINTER 102\n#define VV_MAXCOL\t103\n#define VV_LEN\t\t104\t// number of v: vars\n\n// used for v_number in VAR_BOOL and VAR_SPECIAL\n#define VVAL_FALSE\t0L\t// VAR_BOOL\n#define VVAL_TRUE\t1L\t// VAR_BOOL\n#define VVAL_NONE\t2L\t// VAR_SPECIAL\n#define VVAL_NULL\t3L\t// VAR_SPECIAL\n\n// Type values for type().\n#define VAR_TYPE_NUMBER\t    0\n#define VAR_TYPE_STRING\t    1\n#define VAR_TYPE_FUNC\t    2\n#define VAR_TYPE_LIST\t    3\n#define VAR_TYPE_DICT\t    4\n#define VAR_TYPE_FLOAT\t    5\n#define VAR_TYPE_BOOL\t    6\n#define VAR_TYPE_NONE\t    7\n#define VAR_TYPE_JOB\t    8\n#define VAR_TYPE_CHANNEL    9\n#define VAR_TYPE_BLOB\t    10\n#define VAR_TYPE_INSTR\t    11\n\n#define DICT_MAXNEST 100\t// maximum nesting of lists and dicts\n\n#define TABSTOP_MAX 9999\n\n#ifdef FEAT_CLIPBOARD\n\n// VIM_ATOM_NAME is the older Vim-specific selection type for X11.  Still\n// supported for when a mix of Vim versions is used. VIMENC_ATOM_NAME includes\n// the encoding to support Vims using different 'encoding' values.\n# define VIM_ATOM_NAME \"_VIM_TEXT\"\n# define VIMENC_ATOM_NAME \"_VIMENC_TEXT\"\n\n// Selection states for modeless selection\n# define SELECT_CLEARED\t\t0\n# define SELECT_IN_PROGRESS\t1\n# define SELECT_DONE\t\t2\n\n# define SELECT_MODE_CHAR\t0\n# define SELECT_MODE_WORD\t1\n# define SELECT_MODE_LINE\t2\n\n# ifdef FEAT_GUI_MSWIN\n#  ifdef FEAT_OLE\n#   define WM_OLE (WM_APP+0)\n#  endif\n# endif\n\n// Info about selected text\ntypedef struct\n{\n    int\t\tavailable;\t// Is clipboard available?\n    int\t\towned;\t\t// Flag: do we own the selection?\n    pos_T\tstart;\t\t// Start of selected area\n    pos_T\tend;\t\t// End of selected area\n    int\t\tvmode;\t\t// Visual mode character\n\n    // Fields for selection that doesn't use Visual mode\n    short_u\torigin_row;\n    short_u\torigin_start_col;\n    short_u\torigin_end_col;\n    short_u\tword_start_col;\n    short_u\tword_end_col;\n#ifdef FEAT_PROP_POPUP\n    // limits for selection inside a popup window\n    short_u\tmin_col;\n    short_u\tmax_col;\n    short_u\tmin_row;\n    short_u\tmax_row;\n#endif\n\n    pos_T\tprev;\t\t// Previous position\n    short_u\tstate;\t\t// Current selection state\n    short_u\tmode;\t\t// Select by char, word, or line.\n\n# if defined(FEAT_GUI_X11) || defined(FEAT_XCLIPBOARD)\n    Atom\tsel_atom;\t// PRIMARY/CLIPBOARD selection ID\n# endif\n\n# ifdef FEAT_GUI_GTK\n    GdkAtom     gtk_sel_atom;\t// PRIMARY/CLIPBOARD selection ID\n# endif\n\n# if defined(MSWIN) || defined(FEAT_CYGWIN_WIN32_CLIPBOARD)\n    int_u\tformat;\t\t// Vim's own special clipboard format\n    int_u\tformat_raw;\t// Vim's raw text clipboard format\n# endif\n# ifdef FEAT_GUI_HAIKU\n    // No clipboard at the moment. TODO?\n# endif\n} Clipboard_T;\n#else\ntypedef int Clipboard_T;\t// This is required for the prototypes.\n#endif\n\n// Use 64-bit stat structure on MS-Windows.\n#ifdef MSWIN\ntypedef struct _stat64 stat_T;\n#else\ntypedef struct stat stat_T;\n#endif\n\n#if (defined(__GNUC__) || defined(__clang__)) && !defined(__MINGW32__)\n# define ATTRIBUTE_FORMAT_PRINTF(fmt_idx, arg_idx) \\\n    __attribute__((format(printf, fmt_idx, arg_idx)))\n#else\n# define ATTRIBUTE_FORMAT_PRINTF(fmt_idx, arg_idx)\n#endif\n\n#if defined(__GNUC__) || defined(__clang__)\n# define likely(x)\t__builtin_expect((x), 1)\n# define unlikely(x)\t__builtin_expect((x), 0)\n# define ATTRIBUTE_COLD\t__attribute__((cold))\n#else\n# define unlikely(x)\t(x)\n# define likely(x)\t(x)\n# define ATTRIBUTE_COLD\n#endif\n\ntypedef enum {\n    ASSERT_EQUAL,\n    ASSERT_NOTEQUAL,\n    ASSERT_MATCH,\n    ASSERT_NOTMATCH,\n    ASSERT_OTHER\n} assert_type_T;\n\n// Mode for bracketed_paste().\ntypedef enum {\n    PASTE_INSERT,\t// insert mode\n    PASTE_CMDLINE,\t// command line\n    PASTE_EX,\t\t// ex mode line\n    PASTE_ONE_CHAR\t// return first character\n} paste_mode_T;\n\n// Argument for flush_buffers().\ntypedef enum {\n    FLUSH_MINIMAL,\n    FLUSH_TYPEAHEAD,\t// flush current typebuf contents\n    FLUSH_INPUT\t\t// flush typebuf and inchar() input\n} flush_buffers_T;\n\n// Argument for prepare_tagpreview()\ntypedef enum {\n    USEPOPUP_NONE,\n    USEPOPUP_NORMAL,\t// use info popup\n    USEPOPUP_HIDDEN\t// use info popup initially hidden\n} use_popup_T;\n\n// Argument for estack_sfile().\ntypedef enum {\n    ESTACK_NONE,\n    ESTACK_SFILE,\n    ESTACK_STACK\n} estack_arg_T;\n\n// Flags for assignment functions.\n#define ASSIGN_FINAL\t0x01  // \":final\"\n#define ASSIGN_CONST\t0x02  // \":const\"\n#define ASSIGN_NO_DECL\t0x04  // \"name = expr\" without \":let\"/\":const\"/\":final\"\n#define ASSIGN_DECL\t0x08  // may declare variable if it does not exist\n#define ASSIGN_UNPACK\t0x10  // using [a, b] = list\n#define ASSIGN_NO_MEMBER_TYPE 0x20 // use \"any\" for list and dict member type\n#define ASSIGN_FOR_LOOP 0x40 // assigning to loop variable\n\n#include \"ex_cmds.h\"\t    // Ex command defines\n#include \"spell.h\"\t    // spell checking stuff\n\n#include \"proto.h\"\t    // function prototypes\n\n// This has to go after the include of proto.h, as proto/gui.pro declares\n// functions of these names. The declarations would break if the defines had\n// been seen at that stage.  But it must be before globals.h, where error_ga\n// is declared.\n#if !defined(MSWIN) && !defined(FEAT_GUI_X11) && !defined(FEAT_GUI_HAIKU) \\\n\t&& !defined(FEAT_GUI_GTK) && !defined(PROTO)\n# define mch_errmsg(str)\tfprintf(stderr, \"%s\", (str))\n# define display_errors()\tfflush(stderr)\n# define mch_msg(str)\t\tprintf(\"%s\", (str))\n#else\n# define USE_MCH_ERRMSG\n#endif\n\n# if defined(FEAT_EVAL) \\\n\t&& (!defined(FEAT_GUI_MSWIN) || !defined(FEAT_MBYTE_IME))\n// Whether IME is supported by im_get_status() defined in mbyte.c.\n// For Win32 GUI it's in gui_w32.c when FEAT_MBYTE_IME is defined.\n# define IME_WITHOUT_XIM\n#endif\n\n#if defined(FEAT_XIM) \\\n\t|| defined(IME_WITHOUT_XIM) \\\n\t|| (defined(FEAT_GUI_MSWIN) && defined(FEAT_MBYTE_IME))\n// im_set_active() is available\n# define HAVE_INPUT_METHOD\n#endif\n\n#ifndef FEAT_LINEBREAK\n// Without the 'numberwidth' option line numbers are always 7 chars.\n# define number_width(x) 7\n#endif\n\n// This must come after including proto.h.\n// For VMS this is defined in macros.h.\n#if !defined(MSWIN) && !defined(VMS)\n# define mch_open(n, m, p)\topen((n), (m), (p))\n# define mch_fopen(n, p)\tfopen((n), (p))\n#endif\n\n#include \"globals.h\"\t    // global variables and messages\n#include \"errors.h\"\t    // error messages\n\n/*\n * If console dialog not supported, but GUI dialog is, use the GUI one.\n */\n#if defined(FEAT_GUI_DIALOG) && !defined(FEAT_CON_DIALOG)\n# define do_dialog gui_mch_dialog\n#endif\n\n/*\n * Default filters for gui_mch_browse().\n * The filters are almost system independent.  Except for the difference\n * between \"*\" and \"*.*\" for MSDOS-like systems.\n * NOTE: Motif only uses the very first pattern.  Therefore\n * BROWSE_FILTER_DEFAULT should start with a \"*\" pattern.\n */\n#ifdef FEAT_BROWSE\n# ifdef BACKSLASH_IN_FILENAME\n#  define BROWSE_FILTER_MACROS \\\n\t(char_u *)N_(\"Vim macro files (*.vim)\\t*.vim\\nAll Files (*.*)\\t*.*\\n\")\n#  define BROWSE_FILTER_ALL_FILES (char_u *)N_(\"All Files (*.*)\\t*.*\\n\")\n#  define BROWSE_FILTER_DEFAULT \\\n\t(char_u *)N_(\"All Files (*.*)\\t*.*\\nC source (*.c, *.h)\\t*.c;*.h\\nC++ source (*.cpp, *.hpp)\\t*.cpp;*.hpp\\nVB code (*.bas, *.frm)\\t*.bas;*.frm\\nVim files (*.vim, _vimrc, _gvimrc)\\t*.vim;_vimrc;_gvimrc\\n\")\n# else\n#  define BROWSE_FILTER_MACROS \\\n\t(char_u *)N_(\"Vim macro files (*.vim)\\t*.vim\\nAll Files (*)\\t*\\n\")\n#  define BROWSE_FILTER_ALL_FILES (char_u *)N_(\"All Files (*)\\t*\\n\")\n#  define BROWSE_FILTER_DEFAULT \\\n\t(char_u *)N_(\"All Files (*)\\t*\\nC source (*.c, *.h)\\t*.c;*.h\\nC++ source (*.cpp, *.hpp)\\t*.cpp;*.hpp\\nVim files (*.vim, _vimrc, _gvimrc)\\t*.vim;_vimrc;_gvimrc\\n\")\n# endif\n# define BROWSE_SAVE 1\t    // flag for do_browse()\n# define BROWSE_DIR 2\t    // flag for do_browse()\n#endif\n\n#ifdef _MSC_VER\n// Avoid useless warning \"conversion from X to Y of greater size\".\n #pragma warning(disable : 4312)\n// Avoid warning for old style function declarators\n #pragma warning(disable : 4131)\n// Avoid warning for conversion to type with smaller range\n #pragma warning(disable : 4244)\n// Avoid warning for conversion to larger size\n #pragma warning(disable : 4306)\n// Avoid warning for unreferenced formal parameter\n #pragma warning(disable : 4100)\n// Avoid warning for differs in indirection to slightly different base type\n #pragma warning(disable : 4057)\n// Avoid warning for constant conditional expression\n #pragma warning(disable : 4127)\n// Avoid warning for assignment within conditional\n #pragma warning(disable : 4706)\n#endif\n\n// Note: a NULL argument for vim_realloc() is not portable, don't use it.\n#if defined(MEM_PROFILE)\n# define vim_realloc(ptr, size)  mem_realloc((ptr), (size))\n#else\n# define vim_realloc(ptr, size)  realloc((ptr), (size))\n#endif\n\n/*\n * Return byte length of character that starts with byte \"b\".\n * Returns 1 for a single-byte character.\n * MB_BYTE2LEN_CHECK() can be used to count a special key as one byte.\n * Don't call MB_BYTE2LEN(b) with b < 0 or b > 255!\n */\n#define MB_BYTE2LEN(b)\t\tmb_bytelen_tab[b]\n#define MB_BYTE2LEN_CHECK(b)\t(((b) < 0 || (b) > 255) ? 1 : mb_bytelen_tab[b])\n\n// properties used in enc_canon_table[] (first three mutually exclusive)\n#define ENC_8BIT\t0x01\n#define ENC_DBCS\t0x02\n#define ENC_UNICODE\t0x04\n\n#define ENC_ENDIAN_B\t0x10\t    // Unicode: Big endian\n#define ENC_ENDIAN_L\t0x20\t    // Unicode: Little endian\n\n#define ENC_2BYTE\t0x40\t    // Unicode: UCS-2\n#define ENC_4BYTE\t0x80\t    // Unicode: UCS-4\n#define ENC_2WORD\t0x100\t    // Unicode: UTF-16\n\n#define ENC_LATIN1\t0x200\t    // Latin1\n#define ENC_LATIN9\t0x400\t    // Latin9\n#define ENC_MACROMAN\t0x800\t    // Mac Roman (not Macro Man! :-)\n\n#ifdef USE_ICONV\n# ifndef EILSEQ\n#  define EILSEQ 123\n# endif\n# ifdef DYNAMIC_ICONV\n// On Win32 iconv.dll is dynamically loaded.\n#  define ICONV_ERRNO (*iconv_errno())\n#  define ICONV_E2BIG  7\n#  define ICONV_EINVAL 22\n#  define ICONV_EILSEQ 42\n# else\n#  define ICONV_ERRNO errno\n#  define ICONV_E2BIG  E2BIG\n#  define ICONV_EINVAL EINVAL\n#  define ICONV_EILSEQ EILSEQ\n# endif\n#endif\n\n#define SIGN_BYTE 1\t    // byte value used where sign is displayed;\n\t\t\t    // attribute value is sign type\n\n#ifdef FEAT_NETBEANS_INTG\n# define MULTISIGN_BYTE 2   // byte value used where sign is displayed if\n\t\t\t    // multiple signs exist on the line\n#endif\n\n#if defined(FEAT_GUI) && defined(FEAT_XCLIPBOARD)\n# ifdef FEAT_GUI_GTK\n   // Avoid using a global variable for the X display.  It's ugly\n   // and is likely to cause trouble in multihead environments.\n#  define X_DISPLAY\t((gui.in_use) ? gui_mch_get_display() : xterm_dpy)\n# else\n#  define X_DISPLAY\t(gui.in_use ? gui.dpy : xterm_dpy)\n# endif\n#else\n# ifdef FEAT_GUI\n#  ifdef FEAT_GUI_GTK\n#   define X_DISPLAY\t((gui.in_use) ? gui_mch_get_display() : (Display *)NULL)\n#  else\n#   define X_DISPLAY\tgui.dpy\n#  endif\n# else\n#  define X_DISPLAY\txterm_dpy\n# endif\n#endif\n\n#if defined(FEAT_BROWSE) && defined(GTK_CHECK_VERSION)\n# if GTK_CHECK_VERSION(2,4,0)\n#  define USE_FILE_CHOOSER\n# endif\n#endif\n\n#ifdef FEAT_GUI_GTK\n# if !GTK_CHECK_VERSION(2,14,0)\n#  define gtk_widget_get_window(wid)\t((wid)->window)\n#  define gtk_plug_get_socket_window(wid)\t((wid)->socket_window)\n#  define gtk_selection_data_get_data(sel)\t((sel)->data)\n#  define gtk_selection_data_get_data_type(sel)\t((sel)->type)\n#  define gtk_selection_data_get_format(sel)\t((sel)->format)\n#  define gtk_selection_data_get_length(sel)\t((sel)->length)\n#  define gtk_adjustment_set_lower(adj, low) \\\n    do { (adj)->lower = low; } while (0)\n#  define gtk_adjustment_set_upper(adj, up) \\\n    do { (adj)->upper = up; } while (0)\n#  define gtk_adjustment_set_page_size(adj, size) \\\n    do { (adj)->page_size = size; } while (0)\n#  define gtk_adjustment_set_page_increment(adj, inc) \\\n    do { (adj)->page_increment = inc; } while (0)\n#  define gtk_adjustment_set_step_increment(adj, inc) \\\n    do { (adj)->step_increment = inc; } while (0)\n# endif\n# if !GTK_CHECK_VERSION(2,16,0)\n#  define gtk_selection_data_get_selection(sel)\t((sel)->selection)\n# endif\n# if !GTK_CHECK_VERSION(2,18,0)\n#  define gtk_widget_get_allocation(wid, alloc) \\\n    do { *(alloc) = (wid)->allocation; } while (0)\n#  define gtk_widget_set_allocation(wid, alloc) \\\n    do { (wid)->allocation = *(alloc); } while (0)\n#  define gtk_widget_get_has_window(wid)\t!GTK_WIDGET_NO_WINDOW(wid)\n#  define gtk_widget_get_sensitive(wid)\tGTK_WIDGET_SENSITIVE(wid)\n#  define gtk_widget_get_visible(wid)\tGTK_WIDGET_VISIBLE(wid)\n#  define gtk_widget_has_focus(wid)\tGTK_WIDGET_HAS_FOCUS(wid)\n#  define gtk_widget_set_window(wid, win) \\\n    do { (wid)->window = (win); } while (0)\n#  define gtk_widget_set_can_default(wid, can) \\\n    do { if (can) { GTK_WIDGET_SET_FLAGS(wid, GTK_CAN_DEFAULT); } \\\n\telse { GTK_WIDGET_UNSET_FLAGS(wid, GTK_CAN_DEFAULT); } } while (0)\n#  define gtk_widget_set_can_focus(wid, can) \\\n    do { if (can) { GTK_WIDGET_SET_FLAGS(wid, GTK_CAN_FOCUS); } \\\n\telse { GTK_WIDGET_UNSET_FLAGS(wid, GTK_CAN_FOCUS); } } while (0)\n#  define gtk_widget_set_visible(wid, vis) \\\n    do { if (vis) { gtk_widget_show(wid); } \\\n\telse { gtk_widget_hide(wid); } } while (0)\n# endif\n# if !GTK_CHECK_VERSION(2,20,0)\n#  define gtk_widget_get_mapped(wid)\tGTK_WIDGET_MAPPED(wid)\n#  define gtk_widget_get_realized(wid)\tGTK_WIDGET_REALIZED(wid)\n#  define gtk_widget_set_mapped(wid, map) \\\n    do { if (map) { GTK_WIDGET_SET_FLAGS(wid, GTK_MAPPED); } \\\n\telse { GTK_WIDGET_UNSET_FLAGS(wid, GTK_MAPPED); } } while (0)\n#  define gtk_widget_set_realized(wid, rea) \\\n    do { if (rea) { GTK_WIDGET_SET_FLAGS(wid, GTK_REALIZED); } \\\n\telse { GTK_WIDGET_UNSET_FLAGS(wid, GTK_REALIZED); } } while (0)\n# endif\n#endif\n\n#ifndef FEAT_NETBEANS_INTG\n# undef NBDEBUG\n#endif\n#ifdef NBDEBUG // Netbeans debugging.\n# include \"nbdebug.h\"\n#else\n# define nbdebug(a)\n#endif\n\n#ifdef IN_PERL_FILE\n  /*\n   * Avoid clashes between Perl and Vim namespace.\n   */\n# undef NORMAL\n# undef STRLEN\n# undef FF\n# undef OP_DELETE\n# undef OP_JOIN\n  // remove MAX and MIN, included by glib.h, redefined by sys/param.h\n# ifdef MAX\n#  undef MAX\n# endif\n# ifdef MIN\n#  undef MIN\n# endif\n  // We use _() for gettext(), Perl uses it for function prototypes...\n# ifdef _\n#  undef _\n# endif\n# ifdef DEBUG\n#  undef DEBUG\n# endif\n# ifdef _DEBUG\n#  undef _DEBUG\n# endif\n# ifdef instr\n#  undef instr\n# endif\n  // bool may cause trouble on some old versions of Mac OS X but is required\n  // on a few other systems and for Perl\n# if (defined(MACOS_X) && !defined(MAC_OS_X_VERSION_10_6)) \\\n\t\t\t\t       && defined(bool) && !defined(FEAT_PERL)\n#  undef bool\n# endif\n\n#endif\n\n// values for vim_handle_signal() that are not a signal\n#define SIGNAL_BLOCK\t-1\n#define SIGNAL_UNBLOCK  -2\n#if !defined(UNIX) && !defined(VMS)\n# define vim_handle_signal(x) 0\n#endif\n\n// flags for skip_vimgrep_pat()\n#define VGR_GLOBAL\t1\n#define VGR_NOJUMP\t2\n#define VGR_FUZZY\t4\n\n// behavior for bad character, \"++bad=\" argument\n#define BAD_REPLACE\t'?'\t// replace it with '?' (default)\n#define BAD_KEEP\t-1\t// leave it\n#define BAD_DROP\t-2\t// erase it\n\n// last argument for do_source()\n#define DOSO_NONE\t0\n#define DOSO_VIMRC\t1\t// loading vimrc file\n#define DOSO_GVIMRC\t2\t// loading gvimrc file\n\n// flags for read_viminfo() and children\n#define VIF_WANT_INFO\t    1\t// load non-mark info\n#define VIF_WANT_MARKS\t    2\t// load file marks\n#define VIF_ONLY_CURBUF\t    4\t// bail out after loading marks for curbuf\n#define VIF_FORCEIT\t    8\t// overwrite info already read\n#define VIF_GET_OLDFILES    16\t// load v:oldfiles\n\n// flags for buf_freeall()\n#define BFA_DEL\t\t 1\t// buffer is going to be deleted\n#define BFA_WIPE\t 2\t// buffer is going to be wiped out\n#define BFA_KEEP_UNDO\t 4\t// do not free undo information\n#define BFA_IGNORE_ABORT 8\t// do not abort for aborting()\n\n// direction for nv_mousescroll() and ins_mousescroll()\n#define MSCR_DOWN\t0\t// DOWN must be FALSE\n#define MSCR_UP\t\t1\n#define MSCR_LEFT\t-1\n#define MSCR_RIGHT\t-2\n\n#define KEYLEN_PART_KEY -1\t// keylen value for incomplete key-code\n#define KEYLEN_PART_MAP -2\t// keylen value for incomplete mapping\n#define KEYLEN_REMOVED  9999\t// keylen value for removed sequence\n\n// Return values from win32_fileinfo().\n#define FILEINFO_OK\t     0\n#define FILEINFO_ENC_FAIL    1\t// enc_to_utf16() failed\n#define FILEINFO_READ_FAIL   2\t// CreateFile() failed\n#define FILEINFO_INFO_FAIL   3\t// GetFileInformationByHandle() failed\n\n// Return value from get_option_value_strict\n#define SOPT_BOOL\t0x01\t// Boolean option\n#define SOPT_NUM\t0x02\t// Number option\n#define SOPT_STRING\t0x04\t// String option\n#define SOPT_GLOBAL\t0x08\t// Option has global value\n#define SOPT_WIN\t0x10\t// Option has window-local value\n#define SOPT_BUF\t0x20\t// Option has buffer-local value\n#define SOPT_UNSET\t0x40\t// Option does not have local value set\n\n// Option types for various functions in option.c\n#define SREQ_GLOBAL\t0\t// Request global option\n#define SREQ_WIN\t1\t// Request window-local option\n#define SREQ_BUF\t2\t// Request buffer-local option\n\n// Flags for get_reg_contents\n#define GREG_NO_EXPR\t1\t// Do not allow expression register\n#define GREG_EXPR_SRC\t2\t// Return expression itself for \"=\" register\n#define GREG_LIST\t4\t// Return list\n\n// Character used as separated in autoload function/variable names.\n#define AUTOLOAD_CHAR '#'\n\n#ifdef FEAT_JOB_CHANNEL\n# define MAX_OPEN_CHANNELS 10\n#else\n# define MAX_OPEN_CHANNELS 0\n#endif\n\n#if defined(MSWIN)\n# define MAX_NAMED_PIPE_SIZE 65535\n#endif\n\n// Options for json_encode() and json_decode.\n#define JSON_JS\t\t1   // use JS instead of JSON\n#define JSON_NO_NONE\t2   // v:none item not allowed\n#define JSON_NL\t\t4   // append a NL\n\n// Used for flags of do_in_path()\n#define DIP_ALL\t    0x01\t// all matches, not just the first one\n#define DIP_DIR\t    0x02\t// find directories instead of files.\n#define DIP_ERR\t    0x04\t// give an error message when none found.\n#define DIP_START   0x08\t// also use \"start\" directory in 'packpath'\n#define DIP_OPT\t    0x10\t// also use \"opt\" directory in 'packpath'\n#define DIP_NORTP   0x20\t// do not use 'runtimepath'\n#define DIP_NOAFTER 0x40\t// skip \"after\" directories\n#define DIP_AFTER   0x80\t// only use \"after\" directories\n\n// Lowest number used for window ID. Cannot have this many windows.\n#define LOWEST_WIN_ID 1000\n\n// Used by the garbage collector.\n#define COPYID_INC 2\n#define COPYID_MASK (~0x1)\n\n// Values for trans_function_name() argument:\n#define TFN_INT\t\t0x01\t// internal function name OK\n#define TFN_QUIET\t0x02\t// no error messages\n#define TFN_NO_AUTOLOAD\t0x04\t// do not use script autoloading\n#define TFN_NO_DEREF\t0x08\t// do not dereference a Funcref\n#define TFN_READ_ONLY\t0x10\t// will not change the var\n#define TFN_NO_DECL\t0x20\t// only used for GLV_NO_DECL\n#define TFN_COMPILING\t0x40\t// only used for GLV_COMPILING\n#define TFN_NEW_FUNC\t0x80\t// defining a new function\n\n// Values for get_lval() flags argument:\n#define GLV_QUIET\tTFN_QUIET\t// no error messages\n#define GLV_NO_AUTOLOAD\tTFN_NO_AUTOLOAD\t// do not use script autoloading\n#define GLV_READ_ONLY\tTFN_READ_ONLY\t// will not change the var\n#define GLV_NO_DECL\tTFN_NO_DECL\t// assignment without :var or :let\n#define GLV_COMPILING\tTFN_COMPILING\t// variable may be defined later\n\n#define DO_NOT_FREE_CNT 99999\t// refcount for dict or list that should not\n\t\t\t\t// be freed.\n\n// errors for when calling a function\n#define FCERR_UNKNOWN\t0\n#define FCERR_TOOMANY\t1\n#define FCERR_TOOFEW\t2\n#define FCERR_SCRIPT\t3\n#define FCERR_DICT\t4\n#define FCERR_NONE\t5\n#define FCERR_OTHER\t6\n#define FCERR_DELETED\t7\n#define FCERR_NOTMETHOD\t8   // function cannot be used as a method\n\n// fixed buffer length for fname_trans_sid()\n#define FLEN_FIXED 40\n\n// flags for find_name_end()\n#define FNE_INCL_BR\t1\t// include [] in name\n#define FNE_CHECK_START\t2\t// check name starts with valid character\n\n// BSD is supposed to cover FreeBSD and similar systems.\n#if (defined(SUN_SYSTEM) || defined(BSD) || defined(__FreeBSD_kernel__)) \\\n\t&& (defined(S_ISCHR) || defined(S_IFCHR))\n# define OPEN_CHR_FILES\n#endif\n\n// stat macros\n#ifndef S_ISDIR\n# ifdef S_IFDIR\n#  define S_ISDIR(m)\t(((m) & S_IFMT) == S_IFDIR)\n# else\n#  define S_ISDIR(m)\t0\n# endif\n#endif\n#ifndef S_ISREG\n# ifdef S_IFREG\n#  define S_ISREG(m)\t(((m) & S_IFMT) == S_IFREG)\n# else\n#  define S_ISREG(m)\t0\n# endif\n#endif\n#ifndef S_ISBLK\n# ifdef S_IFBLK\n#  define S_ISBLK(m)\t(((m) & S_IFMT) == S_IFBLK)\n# else\n#  define S_ISBLK(m)\t0\n# endif\n#endif\n#ifndef S_ISSOCK\n# ifdef S_IFSOCK\n#  define S_ISSOCK(m)\t(((m) & S_IFMT) == S_IFSOCK)\n# else\n#  define S_ISSOCK(m)\t0\n# endif\n#endif\n#ifndef S_ISFIFO\n# ifdef S_IFIFO\n#  define S_ISFIFO(m)\t(((m) & S_IFMT) == S_IFIFO)\n# else\n#  define S_ISFIFO(m)\t0\n# endif\n#endif\n#ifndef S_ISCHR\n# ifdef S_IFCHR\n#  define S_ISCHR(m)\t(((m) & S_IFMT) == S_IFCHR)\n# else\n#  define S_ISCHR(m)\t0\n# endif\n#endif\n#ifndef S_ISLNK\n# ifdef S_IFLNK\n#  define S_ISLNK(m)\t(((m) & S_IFMT) == S_IFLNK)\n# else\n#  define S_ISLNK(m)\t0\n# endif\n#endif\n\n#if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)\n# define ELAPSED_TIMEVAL\n# define ELAPSED_INIT(v) gettimeofday(&v, NULL)\n# define ELAPSED_FUNC(v) elapsed(&v)\ntypedef struct timeval elapsed_T;\nlong elapsed(struct timeval *start_tv);\n#elif defined(MSWIN)\n# define ELAPSED_TICKCOUNT\n# define ELAPSED_INIT(v) v = GetTickCount()\n# define ELAPSED_FUNC(v) elapsed(v)\n# ifdef PROTO\ntypedef int DWORD;\n# endif\ntypedef DWORD elapsed_T;\n# ifndef PROTO\nlong elapsed(DWORD start_tick);\n# endif\n#endif\n\n// Replacement for nchar used by nv_replace().\n#define REPLACE_CR_NCHAR    -1\n#define REPLACE_NL_NCHAR    -2\n\n// flags for term_start()\n#define TERM_START_NOJOB\t1\n#define TERM_START_FORCEIT\t2\n#define TERM_START_SYSTEM\t4\n\n// Used for icon/title save and restore.\n#define SAVE_RESTORE_TITLE\t1\n#define SAVE_RESTORE_ICON\t2\n#define SAVE_RESTORE_BOTH\t(SAVE_RESTORE_TITLE | SAVE_RESTORE_ICON)\n\n// Flags for adjust_prop_columns()\n#define APC_SAVE_FOR_UNDO\t1   // call u_savesub() before making changes\n#define APC_SUBSTITUTE\t\t2   // text is replaced, not inserted\n\n#define CLIP_ZINDEX 32000\n\n// Flags for replace_termcodes()\n#define REPTERM_FROM_PART\t1\n#define REPTERM_DO_LT\t\t2\n#define REPTERM_SPECIAL\t\t4\n#define REPTERM_NO_SIMPLIFY\t8\n\n// Flags for find_special_key()\n#define FSK_KEYCODE\t0x01\t// prefer key code, e.g. K_DEL instead of DEL\n#define FSK_KEEP_X_KEY\t0x02\t// don't translate xHome to Home key\n#define FSK_IN_STRING\t0x04\t// TRUE in string, double quote is escaped\n#define FSK_SIMPLIFY\t0x08\t// simplify <C-H> and <A-x>\n\n// Flags for the readdirex function, how to sort the result\n#define READDIR_SORT_NONE\t0  // do not sort\n#define READDIR_SORT_BYTE\t1  // sort by byte order (strcmp), default\n#define READDIR_SORT_IC\t\t2  // sort ignoring case (strcasecmp)\n#define READDIR_SORT_COLLATE\t3  // sort according to collation (strcoll)\n\n// Flags for mch_delay.\n#define MCH_DELAY_IGNOREINPUT\t1\n#define MCH_DELAY_SETTMODE\t2\n\n// Flags for eval_variable().\n#define EVAL_VAR_VERBOSE\t1   // may give error message\n#define EVAL_VAR_NOAUTOLOAD\t2   // do not use script autoloading\n#define EVAL_VAR_IMPORT\t\t4   // may return special variable for import\n#define EVAL_VAR_NO_FUNC\t8   // do not look for a function\n\n// Maximum number of characters that can be fuzzy matched\n#define MAX_FUZZY_MATCHES\t256\n\n// flags for equal_type()\n#define ETYPE_ARG_UNKNOWN 1\n\n// flags used by user commands and :autocmd\n#define UC_BUFFER\t1\t// -buffer: local to current buffer\n#define UC_VIM9\t\t2\t// {} argument: Vim9 syntax.\n\n// flags used by vim_strsave_escaped()\n#define VSE_NONE\t0\n#define VSE_SHELL\t1\t// escape for a shell command\n#define VSE_BUFFER\t2\t// escape for a \":buffer\" command\n\n// Flags used by find_func_even_dead()\n#define FFED_IS_GLOBAL\t1\t// \"g:\" was used\n#define FFED_NO_GLOBAL\t2\t// only check for script-local functions\n\n#endif // VIM__H\n"], "filenames": ["src/indent.c", "src/option.c", "src/testdir/test_options.vim", "src/version.c", "src/vim.h"], "buggy_code_start_loc": [74, 3754, 370, 752, 2087], "buggy_code_end_loc": [1653, 6860, 370, 752, 2087], "fixing_code_start_loc": [74, 3755, 371, 753, 2088], "fixing_code_end_loc": [1653, 6862, 373, 755, 2090], "type": "CWE-122", "message": "Heap-based Buffer Overflow GitHub repository vim/vim prior to 8.2.", "other": {"cve": {"id": "CVE-2022-0417", "sourceIdentifier": "security@huntr.dev", "published": "2022-02-01T13:15:10.070", "lastModified": "2022-12-13T16:46:06.777", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Heap-based Buffer Overflow GitHub repository vim/vim prior to 8.2."}, {"lang": "es", "value": "Un desbordamiento de b\u00fafer basado en Heap Repositorio de GitHub vim/vim anterior a 8.2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.5, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.2.4245", "matchCriteriaId": "C5429E3A-F90C-444C-A244-1E8C4B1770DC"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/652dee448618589de5528a9e9a36995803f5557a", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/fc86bc8d-c866-4ade-8b7f-e49cec306d1a", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/06/msg00014.html", "source": "security@huntr.dev", "tags": ["Mitigation", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/7ZLEHVP4LNAGER4ZDGUDS5V5YVQD6INF/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/UFXFAILMLUIK4MBUEZO4HNBNKYZRJ5AP/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/652dee448618589de5528a9e9a36995803f5557a"}}