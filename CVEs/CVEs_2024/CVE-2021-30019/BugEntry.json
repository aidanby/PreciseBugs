{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / AAC ADTS reframer filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/avparse.h>\n#include <gpac/constants.h>\n#include <gpac/filters.h>\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\nenum\n{\n\tAAC_SIGNAL_NONE=0,\n\tAAC_SIGNAL_IMPLICIT,\n\tAAC_SIGNAL_EXPLICIT\n};\n\ntypedef struct\n{\n\tBool is_mp2, no_crc;\n\tu32 profile, sr_idx, nb_ch, frame_size, hdr_size;\n} ADTSHeader;\n\ntypedef struct\n{\n\tu64 pos;\n\tDouble duration;\n} ADTSIdx;\n\ntypedef struct\n{\n\t//filter args\n\tu32 frame_size;\n\tDouble index;\n\tu32 sbr;\n\tu32 ps;\n//\tBool mpeg4;\n\tBool ovsbr;\n\tBool expart;\n\ts32 aacchcfg;\n\n\t//only one input pid declared\n\tGF_FilterPid *ipid;\n\t//output pid for audio\n\tGF_FilterPid *opid;\n\n\t//video pid for cover art\n\tGF_FilterPid *vpid;\n\n\tGF_BitStream *bs;\n\tu64 file_pos, cts;\n\tu32 sr_idx, nb_ch, is_mp2, profile;\n\tGF_Fraction64 duration;\n\tDouble start_range;\n\tBool in_seek;\n\tu32 timescale;\n\n\tADTSHeader hdr;\n\tu32 dts_inc;\n\n\tBool is_playing;\n\tBool is_file, file_loaded;\n\tBool initial_play_done;\n\n\tGF_FilterPacket *src_pck;\n\n\tADTSIdx *indexes;\n\tu32 index_alloc_size, index_size;\n\n\tu8 *adts_buffer;\n\tu32 adts_buffer_size, adts_buffer_alloc, resume_from;\n\tu64 byte_offset;\n\n\tu32 tag_size;\n\tu8 *id3_buffer;\n\tu32 id3_buffer_size, id3_buffer_alloc;\n\tu32 nb_frames;\n\n\tGF_M4ADecSpecInfo acfg;\n\tu32 bitrate;\n} GF_ADTSDmxCtx;\n\n\nstatic Bool adts_dmx_sync_frame_bs(GF_BitStream *bs, ADTSHeader *hdr)\n{\n\tu32 val;\n\tu64 pos;\n\n\twhile (gf_bs_available(bs)>7) {\n\t\tval = gf_bs_read_u8(bs);\n\t\tif (val!=0xFF) continue;\n\t\tval = gf_bs_read_int(bs, 4);\n\t\tif (val != 0x0F) {\n\t\t\tgf_bs_read_int(bs, 4);\n\t\t\tcontinue;\n\t\t}\n\t\thdr->is_mp2 = (Bool)gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 2);\n\t\thdr->no_crc = (Bool)gf_bs_read_int(bs, 1);\n\t\tpos = gf_bs_get_position(bs) - 2;\n\n\t\thdr->profile = 1 + gf_bs_read_int(bs, 2);\n\t\thdr->sr_idx = gf_bs_read_int(bs, 4);\n\t\tgf_bs_read_int(bs, 1);\n\t\thdr->nb_ch = gf_bs_read_int(bs, 3);\n\t\t//value 1->6 match channel number, value 7 is 7.1\n\t\tif (hdr->nb_ch==7)\n\t\t\thdr->nb_ch = 8;\n\n\t\tgf_bs_read_int(bs, 4);\n\t\thdr->frame_size = gf_bs_read_int(bs, 13);\n\t\tgf_bs_read_int(bs, 11);\n\t\tgf_bs_read_int(bs, 2);\n\t\thdr->hdr_size = 7;\n\t\tif (!hdr->no_crc) {\n\t\t\tgf_bs_read_u16(bs);\n\t\t\thdr->hdr_size = 9;\n\t\t}\n\t\tif (!GF_M4ASampleRates[hdr->sr_idx] || (hdr->frame_size < hdr->hdr_size)) {\n\t\t\tgf_bs_seek(bs, pos+1);\n\t\t\tcontinue;\n\t\t}\n\t\thdr->frame_size -= hdr->hdr_size;\n\n\t\tif (gf_bs_available(bs) == hdr->frame_size) {\n\t\t\treturn GF_TRUE;\n\t\t}\n\t\tif (gf_bs_available(bs) < hdr->frame_size) {\n\t\t\tbreak;\n\t\t}\n\n\t\tgf_bs_skip_bytes(bs, hdr->frame_size);\n\t\tval = gf_bs_read_u8(bs);\n\t\tif (val!=0xFF) {\n\t\t\tgf_bs_seek(bs, pos+1);\n\t\t\tcontinue;\n\t\t}\n\t\tval = gf_bs_read_int(bs, 4);\n\t\tif (val!=0x0F) {\n\t\t\tgf_bs_read_int(bs, 4);\n\t\t\tgf_bs_seek(bs, pos+1);\n\t\t\tcontinue;\n\t\t}\n\t\tgf_bs_seek(bs, pos+hdr->hdr_size);\n\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\n\nvoid id3dmx_flush(GF_Filter *filter, u8 *id3_buf, u32 id3_buf_size, GF_FilterPid *audio_pid, GF_FilterPid **video_pid_p);\n\n\nGF_Err adts_dmx_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tconst GF_PropertyValue *p;\n\tGF_ADTSDmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (is_remove) {\n\t\tctx->ipid = NULL;\n\t\tif (ctx->opid) {\n\t\t\tgf_filter_pid_remove(ctx->opid);\n\t\t\tctx->opid = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (! gf_filter_pid_check_caps(pid))\n\t\treturn GF_NOT_SUPPORTED;\n\n\tctx->ipid = pid;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\tif (p) ctx->timescale = p->value.uint;\n\n\tif (ctx->timescale && !ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);\n\t\t//we don't update copy props on output for now - if we decide we need it, we will need to also force resengin the decoder config\n\t}\n\n\treturn GF_OK;\n}\n\nstatic void adts_dmx_check_dur(GF_Filter *filter, GF_ADTSDmxCtx *ctx)\n{\n\tFILE *stream;\n\tGF_BitStream *bs;\n\tADTSHeader hdr;\n\tu64 duration, cur_dur, rate;\n\ts32 sr_idx = -1;\n\tconst GF_PropertyValue *p;\n\tif (!ctx->opid || ctx->timescale || ctx->file_loaded) return;\n\n\tif (ctx->index<=0) {\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILEPATH);\n\tif (!p || !p->value.string || !strncmp(p->value.string, \"gmem://\", 7)) {\n\t\tctx->is_file = GF_FALSE;\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\tctx->is_file = GF_TRUE;\n\n\tstream = gf_fopen(p->value.string, \"rb\");\n\tif (!stream) return;\n\n\tctx->index_size = 0;\n\n\tbs = gf_bs_from_file(stream, GF_BITSTREAM_READ);\n\tduration = 0;\n\tcur_dur = 0;\n\twhile (adts_dmx_sync_frame_bs(bs, &hdr)) {\n\t\tif ((sr_idx>=0) && (sr_idx != hdr.sr_idx)) {\n\t\t\tduration *= GF_M4ASampleRates[hdr.sr_idx];\n\t\t\tduration /= GF_M4ASampleRates[sr_idx];\n\n\t\t\tcur_dur *= GF_M4ASampleRates[hdr.sr_idx];\n\t\t\tcur_dur /= GF_M4ASampleRates[sr_idx];\n\t\t}\n\t\tsr_idx = hdr.sr_idx;\n\t\tduration += ctx->frame_size;\n\t\tcur_dur += ctx->frame_size;\n\t\tif (cur_dur > ctx->index * GF_M4ASampleRates[sr_idx]) {\n\t\t\tif (!ctx->index_alloc_size) ctx->index_alloc_size = 10;\n\t\t\telse if (ctx->index_alloc_size == ctx->index_size) ctx->index_alloc_size *= 2;\n\t\t\tctx->indexes = gf_realloc(ctx->indexes, sizeof(ADTSIdx)*ctx->index_alloc_size);\n\t\t\tctx->indexes[ctx->index_size].pos = gf_bs_get_position(bs) - hdr.hdr_size;\n\t\t\tctx->indexes[ctx->index_size].duration = (Double) duration;\n\t\t\tctx->indexes[ctx->index_size].duration /= GF_M4ASampleRates[sr_idx];\n\t\t\tctx->index_size ++;\n\t\t\tcur_dur = 0;\n\t\t}\n\n\t\tgf_bs_skip_bytes(bs, hdr.frame_size);\n\t}\n\trate = gf_bs_get_position(bs);\n\tgf_bs_del(bs);\n\tgf_fclose(stream);\n\n\tif (sr_idx>=0) {\n\t\tif (!ctx->duration.num || (ctx->duration.num  * GF_M4ASampleRates[sr_idx] != duration * ctx->duration.den)) {\n\t\t\tctx->duration.num = (s32) duration;\n\t\t\tctx->duration.den = GF_M4ASampleRates[sr_idx];\n\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\n\t\t\tif (duration && !gf_sys_is_test_mode() ) {\n\t\t\t\trate *= 8 * ctx->duration.den;\n\t\t\t\trate /= ctx->duration.num;\n\t\t\t\tctx->bitrate = (u32) rate;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILE_CACHED);\n\tif (p && p->value.boolean) ctx->file_loaded = GF_TRUE;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CAN_DATAREF, & PROP_BOOL(GF_TRUE ) );\n}\n\nstatic void adts_dmx_check_pid(GF_Filter *filter, GF_ADTSDmxCtx *ctx)\n{\n\tGF_BitStream *dsi;\n\tBool use_implicit=GF_FALSE;\n\tu8 *dsi_b;\n\tu32 i, sbr_sr_idx, dsi_s, sr, sbr_sr, codecid, timescale=0;\n\n\tif (!ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\t\tadts_dmx_check_dur(filter, ctx);\n\t}\n\n\tif ((ctx->sr_idx == ctx->hdr.sr_idx) && (ctx->nb_ch == ctx->hdr.nb_ch)\n\t\t&& (ctx->is_mp2 == ctx->hdr.is_mp2) && (ctx->profile == ctx->hdr.profile) ) return;\n\n\t//copy properties at init or reconfig\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, & PROP_UINT( GF_STREAM_AUDIO));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT( GF_CODECID_AAC_MPEG4));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLES_PER_FRAME, & PROP_UINT(ctx->frame_size) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, & PROP_BOOL(GF_FALSE) );\n\tif (ctx->is_file && ctx->index) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, & PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD) );\n\t}\n\n\tif (ctx->duration.num)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\n\n\tctx->is_mp2 = ctx->hdr.is_mp2;\n\tctx->nb_ch = ctx->hdr.nb_ch;\n\tctx->profile = ctx->hdr.profile;\n\n\tsr = GF_M4ASampleRates[ctx->hdr.sr_idx];\n\tif (!ctx->timescale) {\n\t\t//we change sample rate, change cts\n\t\tif (ctx->cts && (ctx->sr_idx != ctx->hdr.sr_idx)) {\n\t\t\tctx->cts *= sr;\n\t\t\tctx->cts /= GF_M4ASampleRates[ctx->sr_idx];\n\t\t}\n\t}\n\tctx->sr_idx = ctx->hdr.sr_idx;\n\n\t/*keep MPEG-2 AAC codecid even for HE-SBR (that's correct according to latest MPEG-4 audio spec)*/\n\tcodecid = ctx->hdr.is_mp2 ? ctx->hdr.profile+GF_CODECID_AAC_MPEG2_MP-1 : GF_CODECID_AAC_MPEG4;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT(codecid) );\n\n\t//force explicit SBR if explicit PS\n\tif (ctx->ps==AAC_SIGNAL_EXPLICIT) {\n\t\tctx->sbr = AAC_SIGNAL_EXPLICIT;\n\t}\n\t/*no provision for explicit indication of MPEG-2 AAC through MPEG-4 PLs, so force implicit*/\n\tif (ctx->hdr.is_mp2) {\n\t\tif (ctx->sbr == AAC_SIGNAL_EXPLICIT) ctx->sbr = AAC_SIGNAL_IMPLICIT;\n\t\tif (ctx->ps == AAC_SIGNAL_EXPLICIT) ctx->ps = AAC_SIGNAL_IMPLICIT;\n\t}\n\n\tdsi = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tctx->dts_inc = ctx->frame_size;\n\n\tif (!ctx->ovsbr) {\n\t\tsbr_sr = 0;\n\t\tsbr_sr_idx = 0;\n\t\tfor (i=0; i<16; i++) {\n\t\t\tif (GF_M4ASampleRates[i] == (u32) 2*sr) {\n\t\t\t\tsbr_sr_idx = i;\n\t\t\t\tsbr_sr = 2*sr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsbr_sr = sr;\n\t\tsbr_sr_idx = ctx->hdr.sr_idx;\n\t}\n\n\tctx->acfg.base_object_type = ctx->hdr.profile;\n\tctx->acfg.base_sr = sr;\n\tctx->acfg.base_sr_index = ctx->hdr.sr_idx;\n\tctx->acfg.nb_chan = ctx->hdr.nb_ch;\n\tctx->acfg.sbr_object_type = 0;\n\n\t/*explicit PS signal (non backward-compatible), only for stereo ADTS*/\n\tif  (ctx->acfg.nb_chan<=2) {\n\t\tif (ctx->ps==AAC_SIGNAL_EXPLICIT) {\n\t\t\tctx->acfg.base_object_type = 29;\n\t\t\tctx->acfg.sbr_object_type = ctx->hdr.profile;\n\t\t\tctx->acfg.sbr_sr = sr;\n\t\t\tctx->acfg.sbr_sr_index = ctx->acfg.base_sr_index;\n\t\t} else if (ctx->ps==AAC_SIGNAL_IMPLICIT) {\n\t\t\tuse_implicit = GF_TRUE;\n\t\t}\n\t}\n\n\tif (ctx->sbr==AAC_SIGNAL_EXPLICIT) {\n\t\t//don't overwrite obj type if explicit PS is used\n\t\tif (ctx->acfg.base_object_type != 29)\n\t\t\tctx->acfg.base_object_type = 5;\n\t\tctx->acfg.sbr_object_type = ctx->hdr.profile;\n\t\tctx->acfg.sbr_sr = sbr_sr;\n\t\tctx->acfg.sbr_sr_index = sbr_sr_idx;\n\t} else if (ctx->sbr==AAC_SIGNAL_IMPLICIT) {\n\t\tsbr_sr = 0;\n\t\tuse_implicit = GF_TRUE;\n\t} else {\n\t\tsbr_sr = 0;\n\t}\n\tctx->acfg.audioPL = gf_m4a_get_profile(&ctx->acfg);\n\n\t/*for better interop, always store using full SR when using explict signaling*/\n\tif (sbr_sr) {\n\t\tctx->dts_inc *= 2;\n\t\tsr = sbr_sr;\n\t}\n\n\tgf_m4a_write_config_bs(dsi, &ctx->acfg);\n\tgf_bs_align(dsi);\n\n\t//implicit signaling, not written by gf_m4a_write_config_bs\n\tif (use_implicit) {\n\t\tgf_bs_write_int(dsi, 0x2b7, 11); /*sync extension type*/\n\t\tgf_bs_write_int(dsi, 5, 5);\t/*audio objectType*/\n\t\t/*implicit AAC SBR signal*/\n\t\tif (ctx->sbr==AAC_SIGNAL_IMPLICIT) {\n\t\t\tgf_bs_write_int(dsi, 1, 1);\t/*SBR present flag*/\n\t\t\tgf_bs_write_int(dsi, sbr_sr_idx, 4);\n\t\t} else {\n\t\t\tgf_bs_write_int(dsi, 0, 1);\t/*SBR present flag*/\n\t\t}\n\t\tif (ctx->ps==AAC_SIGNAL_IMPLICIT) {\n\t\t\tgf_bs_write_int(dsi, 0x548, 11); /*sync extension type*/\n\t\t\tgf_bs_write_int(dsi, 1, 1);\t/* PS present flag */\n\t\t}\n\t\tgf_bs_align(dsi);\n\t}\n\n\tgf_bs_get_content(dsi, &dsi_b, &dsi_s);\n\tgf_bs_del(dsi);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, & PROP_DATA_NO_COPY(dsi_b, dsi_s) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PROFILE_LEVEL, & PROP_UINT (ctx->acfg.audioPL) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLE_RATE, & PROP_UINT(sr));\n\n\ttimescale = sr;\n\tif (ctx->ovsbr) timescale = 2*sr;\n\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, & PROP_UINT(ctx->timescale ? ctx->timescale : timescale));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_NUM_CHANNELS, & PROP_UINT(ctx->nb_ch) );\n\n\tif (ctx->bitrate) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_BITRATE, & PROP_UINT(ctx->bitrate));\n\t}\n\n\tif (ctx->id3_buffer_size) {\n\t\tid3dmx_flush(filter, ctx->id3_buffer, ctx->id3_buffer_size, ctx->opid, ctx->expart ? &ctx->vpid : NULL);\n\t\tctx->id3_buffer_size = 0;\n\t}\n\n}\n\nstatic Bool adts_dmx_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tu32 i;\n\tGF_FilterEvent fevt;\n\tGF_ADTSDmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tswitch (evt->base.type) {\n\tcase GF_FEVT_PLAY:\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->is_playing = GF_TRUE;\n\t\t\tctx->cts = 0;\n\t\t}\n\t\tctx->nb_frames = 0;\n\t\tctx->id3_buffer_size = 0;\n\n\t\tif (! ctx->is_file) {\n\t\t\tif (evt->play.start_range || ctx->initial_play_done) {\n\t\t\t\tctx->adts_buffer_size = 0;\n\t\t\t\tctx->resume_from = 0;\n\t\t\t}\n\n\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tctx->start_range = evt->play.start_range;\n\t\tctx->in_seek = GF_TRUE;\n\t\tctx->file_pos = 0;\n\t\tif (ctx->start_range) {\n\t\t\tfor (i=1; i<ctx->index_size; i++) {\n\t\t\t\tif (ctx->indexes[i].duration>ctx->start_range) {\n\t\t\t\t\tctx->cts = (u64) (ctx->indexes[i-1].duration * GF_M4ASampleRates[ctx->sr_idx]);\n\t\t\t\t\tctx->file_pos = ctx->indexes[i-1].pos;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ctx->initial_play_done) {\n\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\t//seek will not change the current source state, don't send a seek\n\t\t\tif (!ctx->file_pos)\n\t\t\t\treturn GF_TRUE;\n\t\t}\n\t\tctx->resume_from = 0;\n\t\tctx->adts_buffer_size = 0;\n\t\t//post a seek\n\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);\n\t\tfevt.seek.start_offset = ctx->file_pos;\n\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\n\tcase GF_FEVT_STOP:\n\t\t//don't cancel event\n\t\tctx->is_playing = GF_FALSE;\n\t\treturn GF_FALSE;\n\n\tcase GF_FEVT_SET_SPEED:\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\tdefault:\n\t\tbreak;\n\t}\n\t//by default don't cancel event - to rework once we have downloading in place\n\treturn GF_FALSE;\n}\n\nstatic GFINLINE void adts_dmx_update_cts(GF_ADTSDmxCtx *ctx)\n{\n\tassert(ctx->dts_inc);\n\n\tif (ctx->timescale) {\n\t\tu64 inc = ctx->dts_inc;\n\t\tinc *= ctx->timescale;\n\t\tinc /= GF_M4ASampleRates[ctx->sr_idx];\n\t\tctx->cts += inc;\n\t} else {\n\t\tctx->cts += ctx->dts_inc;\n\t}\n}\n\nGF_Err adts_dmx_process(GF_Filter *filter)\n{\n\tGF_ADTSDmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *dst_pck;\n\tu8 *data, *output;\n\tu8 *start;\n\tu32 pck_size, remain, prev_pck_size;\n\tu64 cts = GF_FILTER_NO_TS;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tadts_dmx_check_dur(filter, ctx);\n\n\tif (ctx->opid && !ctx->is_playing)\n\t\treturn GF_OK;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tif (!ctx->adts_buffer_size) {\n\t\t\t\tif (ctx->opid)\n\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = NULL;\n\t\t\t\treturn GF_EOS;\n\t\t\t}\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tprev_pck_size = ctx->adts_buffer_size;\n\tif (pck && !ctx->resume_from) {\n\t\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\t\tif (!pck_size) {\n\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\tu64 byte_offset = gf_filter_pck_get_byte_offset(pck);\n\t\t\tif (!ctx->adts_buffer_size) {\n\t\t\t\tctx->byte_offset = byte_offset;\n\t\t\t} else if (ctx->byte_offset + ctx->adts_buffer_size != byte_offset) {\n\t\t\t\tctx->byte_offset = GF_FILTER_NO_BO;\n\t\t\t\tif ((byte_offset != GF_FILTER_NO_BO) && (byte_offset>ctx->adts_buffer_size) ) {\n\t\t\t\t\tctx->byte_offset = byte_offset - ctx->adts_buffer_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->adts_buffer_size + pck_size > ctx->adts_buffer_alloc) {\n\t\t\tctx->adts_buffer_alloc = ctx->adts_buffer_size + pck_size;\n\t\t\tctx->adts_buffer = gf_realloc(ctx->adts_buffer, ctx->adts_buffer_alloc);\n\t\t}\n\t\tmemcpy(ctx->adts_buffer + ctx->adts_buffer_size, data, pck_size);\n\t\tctx->adts_buffer_size += pck_size;\n\t}\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (ctx->timescale && pck) {\n\t\tcts = gf_filter_pck_get_cts(pck);\n\t}\n\n\tif (cts == GF_FILTER_NO_TS) {\n\t\t//avoids updating cts\n\t\tprev_pck_size = 0;\n\t}\n\n\tremain = ctx->adts_buffer_size;\n\tstart = ctx->adts_buffer;\n\n\tif (ctx->resume_from) {\n\t\tstart += ctx->resume_from - 1;\n\t\tremain -= ctx->resume_from - 1;\n\t\tctx->resume_from = 0;\n\t}\n\n\twhile (remain) {\n\t\tu8 *sync;\n\t\tu32 sync_pos, size, offset, bytes_to_drop=0, nb_blocks_per_frame;\n\n\t\tif (!ctx->tag_size && (remain>3)) {\n\n\t\t\t/* Did we read an ID3v2 ? */\n\t\t\tif (start[0] == 'I' && start[1] == 'D' && start[2] == '3') {\n\t\t\t\tif (remain<10)\n\t\t\t\t\treturn GF_OK;\n\n\t\t\t\tctx->tag_size = ((start[9] & 0x7f) + ((start[8] & 0x7f) << 7) + ((start[7] & 0x7f) << 14) + ((start[6] & 0x7f) << 21));\n\n\t\t\t\tbytes_to_drop = 10;\n\t\t\t\tif (ctx->id3_buffer_alloc < ctx->tag_size+10) {\n\t\t\t\t\tctx->id3_buffer = gf_realloc(ctx->id3_buffer, ctx->tag_size+10);\n\t\t\t\t\tctx->id3_buffer_alloc = ctx->tag_size+10;\n\t\t\t\t}\n\t\t\t\tmemcpy(ctx->id3_buffer, start, 10);\n\t\t\t\tctx->id3_buffer_size = 10;\n\t\t\t\tgoto drop_byte;\n\t\t\t}\n\t\t}\n\t\tif (ctx->tag_size) {\n\t\t\tif (ctx->tag_size>remain) {\n\t\t\t\tbytes_to_drop = remain;\n\t\t\t\tctx->tag_size-=remain;\n\t\t\t} else {\n\t\t\t\tbytes_to_drop = ctx->tag_size;\n\t\t\t\tctx->tag_size = 0;\n\t\t\t}\n\t\t\tmemcpy(ctx->id3_buffer + ctx->id3_buffer_size, start, bytes_to_drop);\n\t\t\tctx->id3_buffer_size += bytes_to_drop;\n\n\t\t\tif (!ctx->tag_size && ctx->opid) {\n\t\t\t\tid3dmx_flush(filter, ctx->id3_buffer, ctx->id3_buffer_size, ctx->opid, ctx->expart ? &ctx->vpid : NULL);\n\t\t\t\tctx->id3_buffer_size = 0;\n\t\t\t}\n\t\t\tgoto drop_byte;\n\n\t\t}\n\n\t\tsync = memchr(start, 0xFF, remain);\n\t\tsync_pos = (u32) (sync ? sync - start : remain);\n\n\t\t//couldn't find sync byte in this packet\n\t\tif (remain - sync_pos < 7) {\n\t\t\tbreak;\n\t\t}\n\n\t\t//not sync !\n\t\tif ((sync[1] & 0xF0) != 0xF0) {\n\t\t\tGF_LOG(ctx->nb_frames ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_PARSER, (\"[ADTSDmx] invalid ADTS sync bytes, resyncing\\n\"));\n\t\t\tctx->nb_frames = 0;\n\t\t\tgoto drop_byte;\n\t\t}\n\t\tif (!ctx->bs) {\n\t\t\tctx->bs = gf_bs_new(sync + 1, remain - sync_pos - 1, GF_BITSTREAM_READ);\n\t\t} else {\n\t\t\tgf_bs_reassign_buffer(ctx->bs, sync + 1, remain - sync_pos - 1);\n\t\t}\n\n\t\t//ok parse header\n\t\tgf_bs_read_int(ctx->bs, 4);\n\n\t\tctx->hdr.is_mp2 = (Bool)gf_bs_read_int(ctx->bs, 1);\n\t\t//if (ctx->mpeg4)\n\t\t//we deprecate old MPEG-2 signaling for AAC in ISOBMFF, as it is not well supported anyway and we don't write adif_header as\n\t\t//supposed to be for these types\n\t\tctx->hdr.is_mp2 = 0;\n\n\t\tgf_bs_read_int(ctx->bs, 2);\n\t\tctx->hdr.no_crc = (Bool)gf_bs_read_int(ctx->bs, 1);\n\n\t\tctx->hdr.profile = 1 + gf_bs_read_int(ctx->bs, 2);\n\t\tctx->hdr.sr_idx = gf_bs_read_int(ctx->bs, 4);\n\t\tgf_bs_read_int(ctx->bs, 1);\n\t\tctx->hdr.nb_ch = gf_bs_read_int(ctx->bs, 3);\n\n\t\tgf_bs_read_int(ctx->bs, 4);\n\t\tctx->hdr.frame_size = gf_bs_read_int(ctx->bs, 13);\n\t\tgf_bs_read_int(ctx->bs, 11);\n\t\tnb_blocks_per_frame = gf_bs_read_int(ctx->bs, 2);\n\t\tctx->hdr.hdr_size = 7;\n\n\t\tif (!ctx->hdr.no_crc) {\n\t\t\tu32 skip;\n\t\t\tif (!nb_blocks_per_frame) {\n\t\t\t\tskip = 2;\n\t\t\t} else {\n\t\t\t\tskip = 2 + 2*nb_blocks_per_frame; //and we have 2 bytes per raw_data_block\n\t\t\t}\n\t\t\tctx->hdr.hdr_size += skip;\n\t\t\tgf_bs_skip_bytes(ctx->bs, skip);\n\t\t}\n\n\t\tif (!ctx->hdr.frame_size || !GF_M4ASampleRates[ctx->hdr.sr_idx]) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[ADTSDmx] Invalid ADTS frame header, resyncing\\n\"));\n\t\t\tctx->nb_frames = 0;\n\t\t\tgoto drop_byte;\n\t\t}\n\t\tif ((nb_blocks_per_frame>2) || (nb_blocks_per_frame && ctx->hdr.nb_ch)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[ADTSDmx] Unsupported multi-block ADTS frame header - patch welcome\\n\"));\n\t\t\tctx->nb_frames = 0;\n\t\t\tgoto drop_byte;\n\t\t} else if (!nb_blocks_per_frame) {\n\t\t\tif (ctx->aacchcfg<0)\n\t\t\t\tctx->hdr.nb_ch = -ctx->aacchcfg;\n\t\t\telse if (!ctx->hdr.nb_ch)\n\t\t\t\tctx->hdr.nb_ch = ctx->aacchcfg;\n\n\t\t\tif (!ctx->hdr.nb_ch) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[ADTSDmx] Missing channel configuration in ADTS frame header, defaulting to stereo - use `--aacchcfg` to force config\\n\"));\n\t\t\t\tctx->hdr.nb_ch = ctx->aacchcfg = 2;\n\t\t\t}\n\t\t}\n\n\t\tif (nb_blocks_per_frame==2) {\n\t\t\tu32 pos = (u32) gf_bs_get_position(ctx->bs);\n\t\t\tgf_m4a_parse_program_config_element(ctx->bs, &ctx->acfg);\n\t\t\tif (!ctx->hdr.no_crc)\n\t\t\t\tgf_bs_skip_bytes(ctx->bs, 2);  //per block CRC\n\n\t\t\tctx->hdr.hdr_size += (u32) gf_bs_get_position(ctx->bs) - pos;\n\t\t}\n\t\t//value 1->6 match channel number, value 7 is 7.1\n\t\tif (ctx->hdr.nb_ch==7)\n\t\t\tctx->hdr.nb_ch = 8;\n\n\n\t\t//ready to send packet\n\t\tif (ctx->hdr.frame_size + 1 < remain) {\n\t\t\tu32 next_frame = ctx->hdr.frame_size;\n\t\t\t//make sure we are sync!\n\t\t\tif ((sync[next_frame] !=0xFF) || ((sync[next_frame+1] & 0xF0) !=0xF0) ) {\n\t\t\t\tGF_LOG(ctx->nb_frames ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_PARSER, (\"[ADTSDmx] invalid next ADTS frame sync, resyncing\\n\"));\n\t\t\t\tctx->nb_frames = 0;\n\t\t\t\tgoto drop_byte;\n\t\t\t}\n\t\t}\n\t\t//otherwise wait for next frame, unless if end of stream\n\t\telse if (pck) {\n\t\t\tif (ctx->timescale && !prev_pck_size &&  (cts != GF_FILTER_NO_TS) ) {\n\t\t\t\tctx->cts = cts;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tadts_dmx_check_pid(filter, ctx);\n\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->resume_from = 1 + ctx->adts_buffer_size - remain;\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tctx->nb_frames++;\n\t\tsize = ctx->hdr.frame_size - ctx->hdr.hdr_size;\n\t\toffset = ctx->hdr.hdr_size;\n\t\t//per raw-block CRC\n\t\tif ((nb_blocks_per_frame==2) && !ctx->hdr.no_crc)\n\t\t\tsize -= 2;\n\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_samples_at_seek = (u64) (ctx->start_range * GF_M4ASampleRates[ctx->sr_idx]);\n\t\t\tif (ctx->cts + ctx->dts_inc >= nb_samples_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek;\n\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tbytes_to_drop = ctx->hdr.frame_size;\n\t\tif (ctx->timescale && !prev_pck_size &&  (cts != GF_FILTER_NO_TS) ) {\n\t\t\tctx->cts = cts;\n\t\t\tcts = GF_FILTER_NO_TS;\n\t\t}\n\n\t\tif (!ctx->in_seek) {\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, size, &output);\n\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\n\t\t\tmemcpy(output, sync + offset, size);\n\n\t\t\tgf_filter_pck_set_dts(dst_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_duration(dst_pck, ctx->dts_inc);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\t\t\tgf_filter_pck_set_sap(dst_pck, GF_FILTER_SAP_1);\n\n\t\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, ctx->byte_offset + ctx->hdr.hdr_size);\n\t\t\t}\n\n\t\t\tgf_filter_pck_send(dst_pck);\n\t\t}\n\t\tadts_dmx_update_cts(ctx);\n\n\n\t\t//truncated last frame\n\t\tif (bytes_to_drop>remain) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[ADTSDmx] truncated ADTS frame!\\n\"));\n\t\t\tbytes_to_drop=remain;\n\t\t}\n\ndrop_byte:\n\t\tif (!bytes_to_drop) {\n\t\t\tbytes_to_drop = 1;\n\t\t}\n\t\tstart += bytes_to_drop;\n\t\tremain -= bytes_to_drop;\n\n\t\tif (prev_pck_size) {\n\t\t\tif (prev_pck_size > bytes_to_drop) prev_pck_size -= bytes_to_drop;\n\t\t\telse {\n\t\t\t\tprev_pck_size=0;\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = pck;\n\t\t\t\tif (pck)\n\t\t\t\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t\t\t}\n\t\t}\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO)\n\t\t\tctx->byte_offset += bytes_to_drop;\n\t}\n\n\tif (!pck) {\n\t\tctx->adts_buffer_size = 0;\n\t\treturn adts_dmx_process(filter);\n\t} else {\n\t\tif (remain) {\n\t\t\tmemmove(ctx->adts_buffer, start, remain);\n\t\t}\n\t\tctx->adts_buffer_size = remain;\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t}\n\treturn GF_OK;\n}\n\nstatic void adts_dmx_finalize(GF_Filter *filter)\n{\n\tGF_ADTSDmxCtx *ctx = gf_filter_get_udta(filter);\n\tif (ctx->bs) gf_bs_del(ctx->bs);\n\tif (ctx->indexes) gf_free(ctx->indexes);\n\tif (ctx->adts_buffer) gf_free(ctx->adts_buffer);\n\tif (ctx->id3_buffer) gf_free(ctx->id3_buffer);\n\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n}\n\nstatic const char *adts_dmx_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)\n{\n\tu32 nb_frames=0, next_pos=0, max_consecutive_frames=0;\n\tADTSHeader prev_hdr;\n\tGF_BitStream *bs;\n\tBool has_id3=GF_FALSE;\n\tBool has_broken_data=GF_FALSE;\n\n\t/*check for id3*/\n\tif (size>= 10) {\n\t\tif (data[0] == 'I' && data[1] == 'D' && data[2] == '3') {\n\t\t\tu32 tag_size = ((data[9] & 0x7f) + ((data[8] & 0x7f) << 7) + ((data[7] & 0x7f) << 14) + ((data[6] & 0x7f) << 21));\n\n\t\t\tif (tag_size+10 > size) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"ID3 tag detected size %d but probe data only %d bytes, will rely on file extension (try increasing probe size using --block_size)\\n\", tag_size+10, size));\n\t\t\t\t*score = GF_FPROBE_EXT_MATCH;\n\t\t\t\treturn \"aac|adts\";\n\t\t\t}\n\t\t\tdata += tag_size+10;\n\t\t\tsize -= tag_size+10;\n\t\t\thas_id3 = GF_TRUE;\n\t\t}\n\t}\n\n\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\tmemset(&prev_hdr, 0, sizeof(ADTSHeader));\n\twhile (gf_bs_available(bs)) {\n\t\tADTSHeader hdr;\n\t\tu32 pos;\n\t\thdr.frame_size = 0;\n\t\tif (!adts_dmx_sync_frame_bs(bs, &hdr)) {\n\t\t\tif (hdr.frame_size) {\n\t\t\t\t//nb_frames++;\n\t\t\t\tmax_consecutive_frames++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif ((hdr.hdr_size!=7) && (hdr.hdr_size!=9)) continue;\n//\t\tif (!hdr.nb_ch) continue;\n\t\tpos = (u32) gf_bs_get_position(bs);\n\n\t\tif (!nb_frames) {\n\t\t\tnb_frames = 1;\n\t\t} else if ((next_pos + hdr.hdr_size == pos) && (hdr.sr_idx==prev_hdr.sr_idx) && (hdr.nb_ch==prev_hdr.nb_ch) ) {\n\t\t\tnb_frames++;\n\t\t\tif (max_consecutive_frames<nb_frames) max_consecutive_frames = nb_frames;\n\t\t\tif (max_consecutive_frames>5)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tnb_frames=1;\n\t\t\thas_broken_data=GF_TRUE;\n\t\t}\n\t\tprev_hdr = hdr;\n\t\tgf_bs_skip_bytes(bs, hdr.frame_size);\n\t\tnext_pos = (u32) gf_bs_get_position(bs);\n\t}\n\tgf_bs_del(bs);\n\tif (max_consecutive_frames>=4) {\n\t\t*score = has_broken_data ? GF_FPROBE_MAYBE_SUPPORTED : GF_FPROBE_SUPPORTED;\n\t\treturn \"audio/aac\";\n\t}\n\tif (has_id3 && max_consecutive_frames) {\n\t\t*score = GF_FPROBE_MAYBE_SUPPORTED;\n\t\treturn \"audio/aac\";\n\t}\n\treturn NULL;\n}\n\nstatic const GF_FilterCapability ADTSDmxCaps[] =\n{\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_FILE_EXT, \"aac|adts\"),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_MIME, \"audio/x-m4a|audio/aac|audio/aacp|audio/x-aac\"),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_AAC_MPEG4),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_AAC_MPEG2_MP),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_AAC_MPEG2_LCP),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_AAC_MPEG2_SSRP),\n\t//we explitely set this one to prevent adts->latm reframer connection\n\tCAP_BOOL(GF_CAPS_OUTPUT_STATIC_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t{0},\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_AAC_MPEG4),\n\tCAP_BOOL(GF_CAPS_INPUT,GF_PROP_PID_UNFRAMED, GF_TRUE),\n};\n\n\n#define OFFS(_n)\t#_n, offsetof(GF_ADTSDmxCtx, _n)\nstatic const GF_FilterArgs ADTSDmxArgs[] =\n{\n\t{ OFFS(frame_size), \"size of AAC frame in audio samples\", GF_PROP_UINT, \"1024\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(index), \"indexing window length\", GF_PROP_DOUBLE, \"1.0\", NULL, 0},\n//\t{ OFFS(mpeg4), \"force signaling as MPEG-4 AAC\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ovsbr), \"force oversampling SBR (does not multiply timescales by 2)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(sbr), \"set SBR signaling\\n\"\\\n\t\t\t\t\"- no: no SBR signaling at all\\n\"\\\n\t\t\t\t\"- imp: backward-compatible SBR signaling (audio signaled as AAC-LC)\\n\"\\\n\t\t\t\t\"- exp: explicit SBR signaling (audio signaled as AAC-SBR)\"\\\n\t\t\t\t, GF_PROP_UINT, \"no\", \"no|imp|exp\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ps), \"set PS signaling\\n\"\\\n\t\t\t\t\"- no: no PS signaling at all\\n\"\\\n\t\t\t\t\"- imp: backward-compatible PS signaling (audio signaled as AAC-LC)\\n\"\\\n\t\t\t\t\"- exp: explicit PS signaling (audio signaled as AAC-PS)\"\\\n\t\t\t\t, GF_PROP_UINT, \"no\", \"no|imp|exp\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(expart), \"expose pictures as a dedicated video pid\", GF_PROP_BOOL, \"false\", NULL, 0},\n\t{ OFFS(aacchcfg), \"set AAC channel configuration to this value if missing from ADTS header, use negative value to always override\", GF_PROP_SINT, \"0\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{0}\n};\n\n\nGF_FilterRegister ADTSDmxRegister = {\n\t.name = \"rfadts\",\n\tGF_FS_SET_DESCRIPTION(\"ADTS reframer\")\n\tGF_FS_SET_HELP(\"This filter parses AAC files/data and outputs corresponding audio PID and frames.\")\n\t.private_size = sizeof(GF_ADTSDmxCtx),\n\t.args = ADTSDmxArgs,\n\t.finalize = adts_dmx_finalize,\n\tSETCAPS(ADTSDmxCaps),\n\t.configure_pid = adts_dmx_configure_pid,\n\t.process = adts_dmx_process,\n\t.probe_data = adts_dmx_probe_data,\n\t.process_event = adts_dmx_process_event\n};\n\n\nconst GF_FilterRegister *adts_dmx_register(GF_FilterSession *session)\n{\n\treturn &ADTSDmxRegister;\n}\n\n#else\nconst GF_FilterRegister *adts_dmx_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n#endif // GPAC_DISABLE_AV_PARSERS\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / AAC ADTS reframer filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/avparse.h>\n#include <gpac/constants.h>\n#include <gpac/filters.h>\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\nenum\n{\n\tAAC_SIGNAL_NONE=0,\n\tAAC_SIGNAL_IMPLICIT,\n\tAAC_SIGNAL_EXPLICIT\n};\n\ntypedef struct\n{\n\tBool is_mp2, no_crc;\n\tu32 profile, sr_idx, nb_ch, frame_size, hdr_size;\n} ADTSHeader;\n\ntypedef struct\n{\n\tu64 pos;\n\tDouble duration;\n} ADTSIdx;\n\ntypedef struct\n{\n\t//filter args\n\tu32 frame_size;\n\tDouble index;\n\tu32 sbr;\n\tu32 ps;\n//\tBool mpeg4;\n\tBool ovsbr;\n\tBool expart;\n\ts32 aacchcfg;\n\n\t//only one input pid declared\n\tGF_FilterPid *ipid;\n\t//output pid for audio\n\tGF_FilterPid *opid;\n\n\t//video pid for cover art\n\tGF_FilterPid *vpid;\n\n\tGF_BitStream *bs;\n\tu64 file_pos, cts;\n\tu32 sr_idx, nb_ch, is_mp2, profile;\n\tGF_Fraction64 duration;\n\tDouble start_range;\n\tBool in_seek;\n\tu32 timescale;\n\n\tADTSHeader hdr;\n\tu32 dts_inc;\n\n\tBool is_playing;\n\tBool is_file, file_loaded;\n\tBool initial_play_done;\n\n\tGF_FilterPacket *src_pck;\n\n\tADTSIdx *indexes;\n\tu32 index_alloc_size, index_size;\n\n\tu8 *adts_buffer;\n\tu32 adts_buffer_size, adts_buffer_alloc, resume_from;\n\tu64 byte_offset;\n\n\tu32 tag_size;\n\tu8 *id3_buffer;\n\tu32 id3_buffer_size, id3_buffer_alloc;\n\tu32 nb_frames;\n\n\tGF_M4ADecSpecInfo acfg;\n\tu32 bitrate;\n} GF_ADTSDmxCtx;\n\n\nstatic Bool adts_dmx_sync_frame_bs(GF_BitStream *bs, ADTSHeader *hdr)\n{\n\tu32 val;\n\tu64 pos;\n\n\twhile (gf_bs_available(bs)>7) {\n\t\tval = gf_bs_read_u8(bs);\n\t\tif (val!=0xFF) continue;\n\t\tval = gf_bs_read_int(bs, 4);\n\t\tif (val != 0x0F) {\n\t\t\tgf_bs_read_int(bs, 4);\n\t\t\tcontinue;\n\t\t}\n\t\thdr->is_mp2 = (Bool)gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 2);\n\t\thdr->no_crc = (Bool)gf_bs_read_int(bs, 1);\n\t\tpos = gf_bs_get_position(bs) - 2;\n\n\t\thdr->profile = 1 + gf_bs_read_int(bs, 2);\n\t\thdr->sr_idx = gf_bs_read_int(bs, 4);\n\t\tgf_bs_read_int(bs, 1);\n\t\thdr->nb_ch = gf_bs_read_int(bs, 3);\n\t\t//value 1->6 match channel number, value 7 is 7.1\n\t\tif (hdr->nb_ch==7)\n\t\t\thdr->nb_ch = 8;\n\n\t\tgf_bs_read_int(bs, 4);\n\t\thdr->frame_size = gf_bs_read_int(bs, 13);\n\t\tgf_bs_read_int(bs, 11);\n\t\tgf_bs_read_int(bs, 2);\n\t\thdr->hdr_size = 7;\n\t\tif (!hdr->no_crc) {\n\t\t\tgf_bs_read_u16(bs);\n\t\t\thdr->hdr_size = 9;\n\t\t}\n\t\tif (!GF_M4ASampleRates[hdr->sr_idx] || (hdr->frame_size < hdr->hdr_size)) {\n\t\t\tgf_bs_seek(bs, pos+1);\n\t\t\tcontinue;\n\t\t}\n\t\thdr->frame_size -= hdr->hdr_size;\n\n\t\tif (gf_bs_available(bs) == hdr->frame_size) {\n\t\t\treturn GF_TRUE;\n\t\t}\n\t\tif (gf_bs_available(bs) < hdr->frame_size) {\n\t\t\tbreak;\n\t\t}\n\n\t\tgf_bs_skip_bytes(bs, hdr->frame_size);\n\t\tval = gf_bs_read_u8(bs);\n\t\tif (val!=0xFF) {\n\t\t\tgf_bs_seek(bs, pos+1);\n\t\t\tcontinue;\n\t\t}\n\t\tval = gf_bs_read_int(bs, 4);\n\t\tif (val!=0x0F) {\n\t\t\tgf_bs_read_int(bs, 4);\n\t\t\tgf_bs_seek(bs, pos+1);\n\t\t\tcontinue;\n\t\t}\n\t\tgf_bs_seek(bs, pos+hdr->hdr_size);\n\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\n\nvoid id3dmx_flush(GF_Filter *filter, u8 *id3_buf, u32 id3_buf_size, GF_FilterPid *audio_pid, GF_FilterPid **video_pid_p);\n\n\nGF_Err adts_dmx_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tconst GF_PropertyValue *p;\n\tGF_ADTSDmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (is_remove) {\n\t\tctx->ipid = NULL;\n\t\tif (ctx->opid) {\n\t\t\tgf_filter_pid_remove(ctx->opid);\n\t\t\tctx->opid = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (! gf_filter_pid_check_caps(pid))\n\t\treturn GF_NOT_SUPPORTED;\n\n\tctx->ipid = pid;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\tif (p) ctx->timescale = p->value.uint;\n\n\tif (ctx->timescale && !ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);\n\t\t//we don't update copy props on output for now - if we decide we need it, we will need to also force resengin the decoder config\n\t}\n\n\treturn GF_OK;\n}\n\nstatic void adts_dmx_check_dur(GF_Filter *filter, GF_ADTSDmxCtx *ctx)\n{\n\tFILE *stream;\n\tGF_BitStream *bs;\n\tADTSHeader hdr;\n\tu64 duration, cur_dur, rate;\n\ts32 sr_idx = -1;\n\tconst GF_PropertyValue *p;\n\tif (!ctx->opid || ctx->timescale || ctx->file_loaded) return;\n\n\tif (ctx->index<=0) {\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILEPATH);\n\tif (!p || !p->value.string || !strncmp(p->value.string, \"gmem://\", 7)) {\n\t\tctx->is_file = GF_FALSE;\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\tctx->is_file = GF_TRUE;\n\n\tstream = gf_fopen(p->value.string, \"rb\");\n\tif (!stream) return;\n\n\tctx->index_size = 0;\n\n\tbs = gf_bs_from_file(stream, GF_BITSTREAM_READ);\n\tduration = 0;\n\tcur_dur = 0;\n\twhile (adts_dmx_sync_frame_bs(bs, &hdr)) {\n\t\tif ((sr_idx>=0) && (sr_idx != hdr.sr_idx)) {\n\t\t\tduration *= GF_M4ASampleRates[hdr.sr_idx];\n\t\t\tduration /= GF_M4ASampleRates[sr_idx];\n\n\t\t\tcur_dur *= GF_M4ASampleRates[hdr.sr_idx];\n\t\t\tcur_dur /= GF_M4ASampleRates[sr_idx];\n\t\t}\n\t\tsr_idx = hdr.sr_idx;\n\t\tduration += ctx->frame_size;\n\t\tcur_dur += ctx->frame_size;\n\t\tif (cur_dur > ctx->index * GF_M4ASampleRates[sr_idx]) {\n\t\t\tif (!ctx->index_alloc_size) ctx->index_alloc_size = 10;\n\t\t\telse if (ctx->index_alloc_size == ctx->index_size) ctx->index_alloc_size *= 2;\n\t\t\tctx->indexes = gf_realloc(ctx->indexes, sizeof(ADTSIdx)*ctx->index_alloc_size);\n\t\t\tctx->indexes[ctx->index_size].pos = gf_bs_get_position(bs) - hdr.hdr_size;\n\t\t\tctx->indexes[ctx->index_size].duration = (Double) duration;\n\t\t\tctx->indexes[ctx->index_size].duration /= GF_M4ASampleRates[sr_idx];\n\t\t\tctx->index_size ++;\n\t\t\tcur_dur = 0;\n\t\t}\n\n\t\tgf_bs_skip_bytes(bs, hdr.frame_size);\n\t}\n\trate = gf_bs_get_position(bs);\n\tgf_bs_del(bs);\n\tgf_fclose(stream);\n\n\tif (sr_idx>=0) {\n\t\tif (!ctx->duration.num || (ctx->duration.num  * GF_M4ASampleRates[sr_idx] != duration * ctx->duration.den)) {\n\t\t\tctx->duration.num = (s32) duration;\n\t\t\tctx->duration.den = GF_M4ASampleRates[sr_idx];\n\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\n\t\t\tif (duration && !gf_sys_is_test_mode() ) {\n\t\t\t\trate *= 8 * ctx->duration.den;\n\t\t\t\trate /= ctx->duration.num;\n\t\t\t\tctx->bitrate = (u32) rate;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILE_CACHED);\n\tif (p && p->value.boolean) ctx->file_loaded = GF_TRUE;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CAN_DATAREF, & PROP_BOOL(GF_TRUE ) );\n}\n\nstatic void adts_dmx_check_pid(GF_Filter *filter, GF_ADTSDmxCtx *ctx)\n{\n\tGF_BitStream *dsi;\n\tBool use_implicit=GF_FALSE;\n\tu8 *dsi_b;\n\tu32 i, sbr_sr_idx, dsi_s, sr, sbr_sr, codecid, timescale=0;\n\n\tif (!ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\t\tadts_dmx_check_dur(filter, ctx);\n\t}\n\n\tif ((ctx->sr_idx == ctx->hdr.sr_idx) && (ctx->nb_ch == ctx->hdr.nb_ch)\n\t\t&& (ctx->is_mp2 == ctx->hdr.is_mp2) && (ctx->profile == ctx->hdr.profile) ) return;\n\n\t//copy properties at init or reconfig\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, & PROP_UINT( GF_STREAM_AUDIO));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT( GF_CODECID_AAC_MPEG4));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLES_PER_FRAME, & PROP_UINT(ctx->frame_size) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, & PROP_BOOL(GF_FALSE) );\n\tif (ctx->is_file && ctx->index) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, & PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD) );\n\t}\n\n\tif (ctx->duration.num)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\n\n\tctx->is_mp2 = ctx->hdr.is_mp2;\n\tctx->nb_ch = ctx->hdr.nb_ch;\n\tctx->profile = ctx->hdr.profile;\n\n\tsr = GF_M4ASampleRates[ctx->hdr.sr_idx];\n\tif (!ctx->timescale) {\n\t\t//we change sample rate, change cts\n\t\tif (ctx->cts && (ctx->sr_idx != ctx->hdr.sr_idx)) {\n\t\t\tctx->cts *= sr;\n\t\t\tctx->cts /= GF_M4ASampleRates[ctx->sr_idx];\n\t\t}\n\t}\n\tctx->sr_idx = ctx->hdr.sr_idx;\n\n\t/*keep MPEG-2 AAC codecid even for HE-SBR (that's correct according to latest MPEG-4 audio spec)*/\n\tcodecid = ctx->hdr.is_mp2 ? ctx->hdr.profile+GF_CODECID_AAC_MPEG2_MP-1 : GF_CODECID_AAC_MPEG4;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT(codecid) );\n\n\t//force explicit SBR if explicit PS\n\tif (ctx->ps==AAC_SIGNAL_EXPLICIT) {\n\t\tctx->sbr = AAC_SIGNAL_EXPLICIT;\n\t}\n\t/*no provision for explicit indication of MPEG-2 AAC through MPEG-4 PLs, so force implicit*/\n\tif (ctx->hdr.is_mp2) {\n\t\tif (ctx->sbr == AAC_SIGNAL_EXPLICIT) ctx->sbr = AAC_SIGNAL_IMPLICIT;\n\t\tif (ctx->ps == AAC_SIGNAL_EXPLICIT) ctx->ps = AAC_SIGNAL_IMPLICIT;\n\t}\n\n\tdsi = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tctx->dts_inc = ctx->frame_size;\n\n\tif (!ctx->ovsbr) {\n\t\tsbr_sr = 0;\n\t\tsbr_sr_idx = 0;\n\t\tfor (i=0; i<16; i++) {\n\t\t\tif (GF_M4ASampleRates[i] == (u32) 2*sr) {\n\t\t\t\tsbr_sr_idx = i;\n\t\t\t\tsbr_sr = 2*sr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsbr_sr = sr;\n\t\tsbr_sr_idx = ctx->hdr.sr_idx;\n\t}\n\n\tctx->acfg.base_object_type = ctx->hdr.profile;\n\tctx->acfg.base_sr = sr;\n\tctx->acfg.base_sr_index = ctx->hdr.sr_idx;\n\tctx->acfg.nb_chan = ctx->hdr.nb_ch;\n\tctx->acfg.sbr_object_type = 0;\n\n\t/*explicit PS signal (non backward-compatible), only for stereo ADTS*/\n\tif  (ctx->acfg.nb_chan<=2) {\n\t\tif (ctx->ps==AAC_SIGNAL_EXPLICIT) {\n\t\t\tctx->acfg.base_object_type = 29;\n\t\t\tctx->acfg.sbr_object_type = ctx->hdr.profile;\n\t\t\tctx->acfg.sbr_sr = sr;\n\t\t\tctx->acfg.sbr_sr_index = ctx->acfg.base_sr_index;\n\t\t} else if (ctx->ps==AAC_SIGNAL_IMPLICIT) {\n\t\t\tuse_implicit = GF_TRUE;\n\t\t}\n\t}\n\n\tif (ctx->sbr==AAC_SIGNAL_EXPLICIT) {\n\t\t//don't overwrite obj type if explicit PS is used\n\t\tif (ctx->acfg.base_object_type != 29)\n\t\t\tctx->acfg.base_object_type = 5;\n\t\tctx->acfg.sbr_object_type = ctx->hdr.profile;\n\t\tctx->acfg.sbr_sr = sbr_sr;\n\t\tctx->acfg.sbr_sr_index = sbr_sr_idx;\n\t} else if (ctx->sbr==AAC_SIGNAL_IMPLICIT) {\n\t\tsbr_sr = 0;\n\t\tuse_implicit = GF_TRUE;\n\t} else {\n\t\tsbr_sr = 0;\n\t}\n\tctx->acfg.audioPL = gf_m4a_get_profile(&ctx->acfg);\n\n\t/*for better interop, always store using full SR when using explict signaling*/\n\tif (sbr_sr) {\n\t\tctx->dts_inc *= 2;\n\t\tsr = sbr_sr;\n\t}\n\n\tgf_m4a_write_config_bs(dsi, &ctx->acfg);\n\tgf_bs_align(dsi);\n\n\t//implicit signaling, not written by gf_m4a_write_config_bs\n\tif (use_implicit) {\n\t\tgf_bs_write_int(dsi, 0x2b7, 11); /*sync extension type*/\n\t\tgf_bs_write_int(dsi, 5, 5);\t/*audio objectType*/\n\t\t/*implicit AAC SBR signal*/\n\t\tif (ctx->sbr==AAC_SIGNAL_IMPLICIT) {\n\t\t\tgf_bs_write_int(dsi, 1, 1);\t/*SBR present flag*/\n\t\t\tgf_bs_write_int(dsi, sbr_sr_idx, 4);\n\t\t} else {\n\t\t\tgf_bs_write_int(dsi, 0, 1);\t/*SBR present flag*/\n\t\t}\n\t\tif (ctx->ps==AAC_SIGNAL_IMPLICIT) {\n\t\t\tgf_bs_write_int(dsi, 0x548, 11); /*sync extension type*/\n\t\t\tgf_bs_write_int(dsi, 1, 1);\t/* PS present flag */\n\t\t}\n\t\tgf_bs_align(dsi);\n\t}\n\n\tgf_bs_get_content(dsi, &dsi_b, &dsi_s);\n\tgf_bs_del(dsi);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, & PROP_DATA_NO_COPY(dsi_b, dsi_s) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PROFILE_LEVEL, & PROP_UINT (ctx->acfg.audioPL) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLE_RATE, & PROP_UINT(sr));\n\n\ttimescale = sr;\n\tif (ctx->ovsbr) timescale = 2*sr;\n\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, & PROP_UINT(ctx->timescale ? ctx->timescale : timescale));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_NUM_CHANNELS, & PROP_UINT(ctx->nb_ch) );\n\n\tif (ctx->bitrate) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_BITRATE, & PROP_UINT(ctx->bitrate));\n\t}\n\n\tif (ctx->id3_buffer_size) {\n\t\tid3dmx_flush(filter, ctx->id3_buffer, ctx->id3_buffer_size, ctx->opid, ctx->expart ? &ctx->vpid : NULL);\n\t\tctx->id3_buffer_size = 0;\n\t}\n\n}\n\nstatic Bool adts_dmx_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tu32 i;\n\tGF_FilterEvent fevt;\n\tGF_ADTSDmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tswitch (evt->base.type) {\n\tcase GF_FEVT_PLAY:\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->is_playing = GF_TRUE;\n\t\t\tctx->cts = 0;\n\t\t}\n\t\tctx->nb_frames = 0;\n\t\tctx->id3_buffer_size = 0;\n\n\t\tif (! ctx->is_file) {\n\t\t\tif (evt->play.start_range || ctx->initial_play_done) {\n\t\t\t\tctx->adts_buffer_size = 0;\n\t\t\t\tctx->resume_from = 0;\n\t\t\t}\n\n\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tctx->start_range = evt->play.start_range;\n\t\tctx->in_seek = GF_TRUE;\n\t\tctx->file_pos = 0;\n\t\tif (ctx->start_range) {\n\t\t\tfor (i=1; i<ctx->index_size; i++) {\n\t\t\t\tif (ctx->indexes[i].duration>ctx->start_range) {\n\t\t\t\t\tctx->cts = (u64) (ctx->indexes[i-1].duration * GF_M4ASampleRates[ctx->sr_idx]);\n\t\t\t\t\tctx->file_pos = ctx->indexes[i-1].pos;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ctx->initial_play_done) {\n\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\t//seek will not change the current source state, don't send a seek\n\t\t\tif (!ctx->file_pos)\n\t\t\t\treturn GF_TRUE;\n\t\t}\n\t\tctx->resume_from = 0;\n\t\tctx->adts_buffer_size = 0;\n\t\t//post a seek\n\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);\n\t\tfevt.seek.start_offset = ctx->file_pos;\n\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\n\tcase GF_FEVT_STOP:\n\t\t//don't cancel event\n\t\tctx->is_playing = GF_FALSE;\n\t\treturn GF_FALSE;\n\n\tcase GF_FEVT_SET_SPEED:\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\tdefault:\n\t\tbreak;\n\t}\n\t//by default don't cancel event - to rework once we have downloading in place\n\treturn GF_FALSE;\n}\n\nstatic GFINLINE void adts_dmx_update_cts(GF_ADTSDmxCtx *ctx)\n{\n\tassert(ctx->dts_inc);\n\n\tif (ctx->timescale) {\n\t\tu64 inc = ctx->dts_inc;\n\t\tinc *= ctx->timescale;\n\t\tinc /= GF_M4ASampleRates[ctx->sr_idx];\n\t\tctx->cts += inc;\n\t} else {\n\t\tctx->cts += ctx->dts_inc;\n\t}\n}\n\nGF_Err adts_dmx_process(GF_Filter *filter)\n{\n\tGF_ADTSDmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *dst_pck;\n\tu8 *data, *output;\n\tu8 *start;\n\tu32 pck_size, remain, prev_pck_size;\n\tu64 cts = GF_FILTER_NO_TS;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tadts_dmx_check_dur(filter, ctx);\n\n\tif (ctx->opid && !ctx->is_playing)\n\t\treturn GF_OK;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tif (!ctx->adts_buffer_size) {\n\t\t\t\tif (ctx->opid)\n\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = NULL;\n\t\t\t\treturn GF_EOS;\n\t\t\t}\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tprev_pck_size = ctx->adts_buffer_size;\n\tif (pck && !ctx->resume_from) {\n\t\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\t\tif (!pck_size) {\n\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\tu64 byte_offset = gf_filter_pck_get_byte_offset(pck);\n\t\t\tif (!ctx->adts_buffer_size) {\n\t\t\t\tctx->byte_offset = byte_offset;\n\t\t\t} else if (ctx->byte_offset + ctx->adts_buffer_size != byte_offset) {\n\t\t\t\tctx->byte_offset = GF_FILTER_NO_BO;\n\t\t\t\tif ((byte_offset != GF_FILTER_NO_BO) && (byte_offset>ctx->adts_buffer_size) ) {\n\t\t\t\t\tctx->byte_offset = byte_offset - ctx->adts_buffer_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->adts_buffer_size + pck_size > ctx->adts_buffer_alloc) {\n\t\t\tctx->adts_buffer_alloc = ctx->adts_buffer_size + pck_size;\n\t\t\tctx->adts_buffer = gf_realloc(ctx->adts_buffer, ctx->adts_buffer_alloc);\n\t\t}\n\t\tmemcpy(ctx->adts_buffer + ctx->adts_buffer_size, data, pck_size);\n\t\tctx->adts_buffer_size += pck_size;\n\t}\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (ctx->timescale && pck) {\n\t\tcts = gf_filter_pck_get_cts(pck);\n\t}\n\n\tif (cts == GF_FILTER_NO_TS) {\n\t\t//avoids updating cts\n\t\tprev_pck_size = 0;\n\t}\n\n\tremain = ctx->adts_buffer_size;\n\tstart = ctx->adts_buffer;\n\n\tif (ctx->resume_from) {\n\t\tstart += ctx->resume_from - 1;\n\t\tremain -= ctx->resume_from - 1;\n\t\tctx->resume_from = 0;\n\t}\n\n\twhile (remain) {\n\t\tu8 *sync;\n\t\tu32 sync_pos, size, offset, bytes_to_drop=0, nb_blocks_per_frame;\n\n\t\tif (!ctx->tag_size && (remain>3)) {\n\n\t\t\t/* Did we read an ID3v2 ? */\n\t\t\tif (start[0] == 'I' && start[1] == 'D' && start[2] == '3') {\n\t\t\t\tif (remain<10)\n\t\t\t\t\treturn GF_OK;\n\n\t\t\t\tctx->tag_size = ((start[9] & 0x7f) + ((start[8] & 0x7f) << 7) + ((start[7] & 0x7f) << 14) + ((start[6] & 0x7f) << 21));\n\n\t\t\t\tbytes_to_drop = 10;\n\t\t\t\tif (ctx->id3_buffer_alloc < ctx->tag_size+10) {\n\t\t\t\t\tctx->id3_buffer = gf_realloc(ctx->id3_buffer, ctx->tag_size+10);\n\t\t\t\t\tctx->id3_buffer_alloc = ctx->tag_size+10;\n\t\t\t\t}\n\t\t\t\tmemcpy(ctx->id3_buffer, start, 10);\n\t\t\t\tctx->id3_buffer_size = 10;\n\t\t\t\tgoto drop_byte;\n\t\t\t}\n\t\t}\n\t\tif (ctx->tag_size) {\n\t\t\tif (ctx->tag_size>remain) {\n\t\t\t\tbytes_to_drop = remain;\n\t\t\t\tctx->tag_size-=remain;\n\t\t\t} else {\n\t\t\t\tbytes_to_drop = ctx->tag_size;\n\t\t\t\tctx->tag_size = 0;\n\t\t\t}\n\t\t\tmemcpy(ctx->id3_buffer + ctx->id3_buffer_size, start, bytes_to_drop);\n\t\t\tctx->id3_buffer_size += bytes_to_drop;\n\n\t\t\tif (!ctx->tag_size && ctx->opid) {\n\t\t\t\tid3dmx_flush(filter, ctx->id3_buffer, ctx->id3_buffer_size, ctx->opid, ctx->expart ? &ctx->vpid : NULL);\n\t\t\t\tctx->id3_buffer_size = 0;\n\t\t\t}\n\t\t\tgoto drop_byte;\n\n\t\t}\n\n\t\tsync = memchr(start, 0xFF, remain);\n\t\tsync_pos = (u32) (sync ? sync - start : remain);\n\n\t\t//couldn't find sync byte in this packet\n\t\tif (remain - sync_pos < 7) {\n\t\t\tbreak;\n\t\t}\n\n\t\t//not sync !\n\t\tif ((sync[1] & 0xF0) != 0xF0) {\n\t\t\tGF_LOG(ctx->nb_frames ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_PARSER, (\"[ADTSDmx] invalid ADTS sync bytes, resyncing\\n\"));\n\t\t\tctx->nb_frames = 0;\n\t\t\tgoto drop_byte;\n\t\t}\n\t\tif (!ctx->bs) {\n\t\t\tctx->bs = gf_bs_new(sync + 1, remain - sync_pos - 1, GF_BITSTREAM_READ);\n\t\t} else {\n\t\t\tgf_bs_reassign_buffer(ctx->bs, sync + 1, remain - sync_pos - 1);\n\t\t}\n\n\t\t//ok parse header\n\t\tgf_bs_read_int(ctx->bs, 4);\n\n\t\tctx->hdr.is_mp2 = (Bool)gf_bs_read_int(ctx->bs, 1);\n\t\t//if (ctx->mpeg4)\n\t\t//we deprecate old MPEG-2 signaling for AAC in ISOBMFF, as it is not well supported anyway and we don't write adif_header as\n\t\t//supposed to be for these types\n\t\tctx->hdr.is_mp2 = 0;\n\n\t\tgf_bs_read_int(ctx->bs, 2);\n\t\tctx->hdr.no_crc = (Bool)gf_bs_read_int(ctx->bs, 1);\n\n\t\tctx->hdr.profile = 1 + gf_bs_read_int(ctx->bs, 2);\n\t\tctx->hdr.sr_idx = gf_bs_read_int(ctx->bs, 4);\n\t\tgf_bs_read_int(ctx->bs, 1);\n\t\tctx->hdr.nb_ch = gf_bs_read_int(ctx->bs, 3);\n\n\t\tgf_bs_read_int(ctx->bs, 4);\n\t\tctx->hdr.frame_size = gf_bs_read_int(ctx->bs, 13);\n\t\tgf_bs_read_int(ctx->bs, 11);\n\t\tnb_blocks_per_frame = gf_bs_read_int(ctx->bs, 2);\n\t\tctx->hdr.hdr_size = 7;\n\n\t\tif (!ctx->hdr.no_crc) {\n\t\t\tu32 skip;\n\t\t\tif (!nb_blocks_per_frame) {\n\t\t\t\tskip = 2;\n\t\t\t} else {\n\t\t\t\tskip = 2 + 2*nb_blocks_per_frame; //and we have 2 bytes per raw_data_block\n\t\t\t}\n\t\t\tctx->hdr.hdr_size += skip;\n\t\t\tgf_bs_skip_bytes(ctx->bs, skip);\n\t\t}\n\n\t\tif (!ctx->hdr.frame_size || !GF_M4ASampleRates[ctx->hdr.sr_idx]) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[ADTSDmx] Invalid ADTS frame header, resyncing\\n\"));\n\t\t\tctx->nb_frames = 0;\n\t\t\tgoto drop_byte;\n\t\t}\n\t\tif ((nb_blocks_per_frame>2) || (nb_blocks_per_frame && ctx->hdr.nb_ch)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[ADTSDmx] Unsupported multi-block ADTS frame header - patch welcome\\n\"));\n\t\t\tctx->nb_frames = 0;\n\t\t\tgoto drop_byte;\n\t\t} else if (!nb_blocks_per_frame) {\n\t\t\tif (ctx->aacchcfg<0)\n\t\t\t\tctx->hdr.nb_ch = -ctx->aacchcfg;\n\t\t\telse if (!ctx->hdr.nb_ch)\n\t\t\t\tctx->hdr.nb_ch = ctx->aacchcfg;\n\n\t\t\tif (!ctx->hdr.nb_ch) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[ADTSDmx] Missing channel configuration in ADTS frame header, defaulting to stereo - use `--aacchcfg` to force config\\n\"));\n\t\t\t\tctx->hdr.nb_ch = ctx->aacchcfg = 2;\n\t\t\t}\n\t\t}\n\n\t\tif (nb_blocks_per_frame==2) {\n\t\t\tu32 pos = (u32) gf_bs_get_position(ctx->bs);\n\t\t\tgf_m4a_parse_program_config_element(ctx->bs, &ctx->acfg);\n\t\t\tif (!ctx->hdr.no_crc)\n\t\t\t\tgf_bs_skip_bytes(ctx->bs, 2);  //per block CRC\n\n\t\t\tctx->hdr.hdr_size += (u32) gf_bs_get_position(ctx->bs) - pos;\n\t\t}\n\t\t//value 1->6 match channel number, value 7 is 7.1\n\t\tif (ctx->hdr.nb_ch==7)\n\t\t\tctx->hdr.nb_ch = 8;\n\n\n\t\t//ready to send packet\n\t\tif (ctx->hdr.frame_size + 1 < remain) {\n\t\t\tu32 next_frame = ctx->hdr.frame_size;\n\t\t\t//make sure we are sync!\n\t\t\tif ((sync[next_frame] !=0xFF) || ((sync[next_frame+1] & 0xF0) !=0xF0) ) {\n\t\t\t\tGF_LOG(ctx->nb_frames ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_PARSER, (\"[ADTSDmx] invalid next ADTS frame sync, resyncing\\n\"));\n\t\t\t\tctx->nb_frames = 0;\n\t\t\t\tgoto drop_byte;\n\t\t\t}\n\t\t}\n\t\t//otherwise wait for next frame, unless if end of stream\n\t\telse if (pck) {\n\t\t\tif (ctx->timescale && !prev_pck_size &&  (cts != GF_FILTER_NO_TS) ) {\n\t\t\t\tctx->cts = cts;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ctx->hdr.frame_size < ctx->hdr.hdr_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[ADTSDmx] Corrupted ADTS frame header, resyncing\\n\"));\n\t\t\tctx->nb_frames = 0;\n\t\t\tgoto drop_byte;\n\t\t}\n\n\t\tadts_dmx_check_pid(filter, ctx);\n\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->resume_from = 1 + ctx->adts_buffer_size - remain;\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tctx->nb_frames++;\n\t\tsize = ctx->hdr.frame_size - ctx->hdr.hdr_size;\n\t\toffset = ctx->hdr.hdr_size;\n\t\t//per raw-block CRC\n\t\tif ((nb_blocks_per_frame==2) && !ctx->hdr.no_crc)\n\t\t\tsize -= 2;\n\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_samples_at_seek = (u64) (ctx->start_range * GF_M4ASampleRates[ctx->sr_idx]);\n\t\t\tif (ctx->cts + ctx->dts_inc >= nb_samples_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek;\n\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tbytes_to_drop = ctx->hdr.frame_size;\n\t\tif (ctx->timescale && !prev_pck_size &&  (cts != GF_FILTER_NO_TS) ) {\n\t\t\tctx->cts = cts;\n\t\t\tcts = GF_FILTER_NO_TS;\n\t\t}\n\n\t\tif (!ctx->in_seek) {\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, size, &output);\n\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\n\t\t\tmemcpy(output, sync + offset, size);\n\n\t\t\tgf_filter_pck_set_dts(dst_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_duration(dst_pck, ctx->dts_inc);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\t\t\tgf_filter_pck_set_sap(dst_pck, GF_FILTER_SAP_1);\n\n\t\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, ctx->byte_offset + ctx->hdr.hdr_size);\n\t\t\t}\n\n\t\t\tgf_filter_pck_send(dst_pck);\n\t\t}\n\t\tadts_dmx_update_cts(ctx);\n\n\n\t\t//truncated last frame\n\t\tif (bytes_to_drop>remain) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[ADTSDmx] truncated ADTS frame!\\n\"));\n\t\t\tbytes_to_drop=remain;\n\t\t}\n\ndrop_byte:\n\t\tif (!bytes_to_drop) {\n\t\t\tbytes_to_drop = 1;\n\t\t}\n\t\tstart += bytes_to_drop;\n\t\tremain -= bytes_to_drop;\n\n\t\tif (prev_pck_size) {\n\t\t\tif (prev_pck_size > bytes_to_drop) prev_pck_size -= bytes_to_drop;\n\t\t\telse {\n\t\t\t\tprev_pck_size=0;\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = pck;\n\t\t\t\tif (pck)\n\t\t\t\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t\t\t}\n\t\t}\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO)\n\t\t\tctx->byte_offset += bytes_to_drop;\n\t}\n\n\tif (!pck) {\n\t\tctx->adts_buffer_size = 0;\n\t\treturn adts_dmx_process(filter);\n\t} else {\n\t\tif (remain) {\n\t\t\tmemmove(ctx->adts_buffer, start, remain);\n\t\t}\n\t\tctx->adts_buffer_size = remain;\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t}\n\treturn GF_OK;\n}\n\nstatic void adts_dmx_finalize(GF_Filter *filter)\n{\n\tGF_ADTSDmxCtx *ctx = gf_filter_get_udta(filter);\n\tif (ctx->bs) gf_bs_del(ctx->bs);\n\tif (ctx->indexes) gf_free(ctx->indexes);\n\tif (ctx->adts_buffer) gf_free(ctx->adts_buffer);\n\tif (ctx->id3_buffer) gf_free(ctx->id3_buffer);\n\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n}\n\nstatic const char *adts_dmx_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)\n{\n\tu32 nb_frames=0, next_pos=0, max_consecutive_frames=0;\n\tADTSHeader prev_hdr;\n\tGF_BitStream *bs;\n\tBool has_id3=GF_FALSE;\n\tBool has_broken_data=GF_FALSE;\n\n\t/*check for id3*/\n\tif (size>= 10) {\n\t\tif (data[0] == 'I' && data[1] == 'D' && data[2] == '3') {\n\t\t\tu32 tag_size = ((data[9] & 0x7f) + ((data[8] & 0x7f) << 7) + ((data[7] & 0x7f) << 14) + ((data[6] & 0x7f) << 21));\n\n\t\t\tif (tag_size+10 > size) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"ID3 tag detected size %d but probe data only %d bytes, will rely on file extension (try increasing probe size using --block_size)\\n\", tag_size+10, size));\n\t\t\t\t*score = GF_FPROBE_EXT_MATCH;\n\t\t\t\treturn \"aac|adts\";\n\t\t\t}\n\t\t\tdata += tag_size+10;\n\t\t\tsize -= tag_size+10;\n\t\t\thas_id3 = GF_TRUE;\n\t\t}\n\t}\n\n\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\tmemset(&prev_hdr, 0, sizeof(ADTSHeader));\n\twhile (gf_bs_available(bs)) {\n\t\tADTSHeader hdr;\n\t\tu32 pos;\n\t\thdr.frame_size = 0;\n\t\tif (!adts_dmx_sync_frame_bs(bs, &hdr)) {\n\t\t\tif (hdr.frame_size) {\n\t\t\t\t//nb_frames++;\n\t\t\t\tmax_consecutive_frames++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif ((hdr.hdr_size!=7) && (hdr.hdr_size!=9)) continue;\n//\t\tif (!hdr.nb_ch) continue;\n\t\tpos = (u32) gf_bs_get_position(bs);\n\n\t\tif (!nb_frames) {\n\t\t\tnb_frames = 1;\n\t\t} else if ((next_pos + hdr.hdr_size == pos) && (hdr.sr_idx==prev_hdr.sr_idx) && (hdr.nb_ch==prev_hdr.nb_ch) ) {\n\t\t\tnb_frames++;\n\t\t\tif (max_consecutive_frames<nb_frames) max_consecutive_frames = nb_frames;\n\t\t\tif (max_consecutive_frames>5)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tnb_frames=1;\n\t\t\thas_broken_data=GF_TRUE;\n\t\t}\n\t\tprev_hdr = hdr;\n\t\tgf_bs_skip_bytes(bs, hdr.frame_size);\n\t\tnext_pos = (u32) gf_bs_get_position(bs);\n\t}\n\tgf_bs_del(bs);\n\tif (max_consecutive_frames>=4) {\n\t\t*score = has_broken_data ? GF_FPROBE_MAYBE_SUPPORTED : GF_FPROBE_SUPPORTED;\n\t\treturn \"audio/aac\";\n\t}\n\tif (has_id3 && max_consecutive_frames) {\n\t\t*score = GF_FPROBE_MAYBE_SUPPORTED;\n\t\treturn \"audio/aac\";\n\t}\n\treturn NULL;\n}\n\nstatic const GF_FilterCapability ADTSDmxCaps[] =\n{\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_FILE_EXT, \"aac|adts\"),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_MIME, \"audio/x-m4a|audio/aac|audio/aacp|audio/x-aac\"),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_AAC_MPEG4),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_AAC_MPEG2_MP),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_AAC_MPEG2_LCP),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_AAC_MPEG2_SSRP),\n\t//we explitely set this one to prevent adts->latm reframer connection\n\tCAP_BOOL(GF_CAPS_OUTPUT_STATIC_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t{0},\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_AAC_MPEG4),\n\tCAP_BOOL(GF_CAPS_INPUT,GF_PROP_PID_UNFRAMED, GF_TRUE),\n};\n\n\n#define OFFS(_n)\t#_n, offsetof(GF_ADTSDmxCtx, _n)\nstatic const GF_FilterArgs ADTSDmxArgs[] =\n{\n\t{ OFFS(frame_size), \"size of AAC frame in audio samples\", GF_PROP_UINT, \"1024\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(index), \"indexing window length\", GF_PROP_DOUBLE, \"1.0\", NULL, 0},\n//\t{ OFFS(mpeg4), \"force signaling as MPEG-4 AAC\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ovsbr), \"force oversampling SBR (does not multiply timescales by 2)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(sbr), \"set SBR signaling\\n\"\\\n\t\t\t\t\"- no: no SBR signaling at all\\n\"\\\n\t\t\t\t\"- imp: backward-compatible SBR signaling (audio signaled as AAC-LC)\\n\"\\\n\t\t\t\t\"- exp: explicit SBR signaling (audio signaled as AAC-SBR)\"\\\n\t\t\t\t, GF_PROP_UINT, \"no\", \"no|imp|exp\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ps), \"set PS signaling\\n\"\\\n\t\t\t\t\"- no: no PS signaling at all\\n\"\\\n\t\t\t\t\"- imp: backward-compatible PS signaling (audio signaled as AAC-LC)\\n\"\\\n\t\t\t\t\"- exp: explicit PS signaling (audio signaled as AAC-PS)\"\\\n\t\t\t\t, GF_PROP_UINT, \"no\", \"no|imp|exp\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(expart), \"expose pictures as a dedicated video pid\", GF_PROP_BOOL, \"false\", NULL, 0},\n\t{ OFFS(aacchcfg), \"set AAC channel configuration to this value if missing from ADTS header, use negative value to always override\", GF_PROP_SINT, \"0\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{0}\n};\n\n\nGF_FilterRegister ADTSDmxRegister = {\n\t.name = \"rfadts\",\n\tGF_FS_SET_DESCRIPTION(\"ADTS reframer\")\n\tGF_FS_SET_HELP(\"This filter parses AAC files/data and outputs corresponding audio PID and frames.\")\n\t.private_size = sizeof(GF_ADTSDmxCtx),\n\t.args = ADTSDmxArgs,\n\t.finalize = adts_dmx_finalize,\n\tSETCAPS(ADTSDmxCaps),\n\t.configure_pid = adts_dmx_configure_pid,\n\t.process = adts_dmx_process,\n\t.probe_data = adts_dmx_probe_data,\n\t.process_event = adts_dmx_process_event\n};\n\n\nconst GF_FilterRegister *adts_dmx_register(GF_FilterSession *session)\n{\n\treturn &ADTSDmxRegister;\n}\n\n#else\nconst GF_FilterRegister *adts_dmx_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n#endif // GPAC_DISABLE_AV_PARSERS\n"], "filenames": ["src/filters/reframe_adts.c"], "buggy_code_start_loc": [747], "buggy_code_end_loc": [747], "fixing_code_start_loc": [748], "fixing_code_end_loc": [754], "type": "CWE-787", "message": "In the adts_dmx_process function in filters/reframe_adts.c in GPAC 1.0.1, a crafted file may cause ctx->hdr.frame_size to be smaller than ctx->hdr.hdr_size, resulting in size to be a negative number and a heap overflow in the memcpy.", "other": {"cve": {"id": "CVE-2021-30019", "sourceIdentifier": "cve@mitre.org", "published": "2021-04-19T20:15:14.490", "lastModified": "2021-04-21T19:01:59.187", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the adts_dmx_process function in filters/reframe_adts.c in GPAC 1.0.1, a crafted file may cause ctx->hdr.frame_size to be smaller than ctx->hdr.hdr_size, resulting in size to be a negative number and a heap overflow in the memcpy."}, {"lang": "es", "value": "En la funci\u00f3n adts_dmx_process en el archivo filters/reframe_adts.c en GPAC versi\u00f3n 1.0.1, un archivo dise\u00f1ado puede hacer que ctx-)hdr.frame_size sea m\u00e1s peque\u00f1o que ctx-)hdr.hdr_size, resultando en un tama\u00f1o sea un n\u00famero negativo y un desbordamiento de la pila en el memcpy"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "82DD2D40-0A05-48FD-940D-32B4D8B51AB3"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/22774aa9e62f586319c8f107f5bae950fed900bc", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1723", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/22774aa9e62f586319c8f107f5bae950fed900bc"}}