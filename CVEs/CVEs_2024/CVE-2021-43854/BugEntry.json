{"buggy_code": ["# Natural Language Toolkit: Punkt sentence tokenizer\n#\n# Copyright (C) 2001-2021 NLTK Project\n# Algorithm: Kiss & Strunk (2006)\n# Author: Willy <willy@csse.unimelb.edu.au> (original Python port)\n#         Steven Bird <stevenbird1@gmail.com> (additions)\n#         Edward Loper <edloper@gmail.com> (rewrite)\n#         Joel Nothman <jnothman@student.usyd.edu.au> (almost rewrite)\n#         Arthur Darcet <arthur@darcet.fr> (fixes)\n# URL: <https://www.nltk.org/>\n# For license information, see LICENSE.TXT\n\nr\"\"\"\nPunkt Sentence Tokenizer\n\nThis tokenizer divides a text into a list of sentences\nby using an unsupervised algorithm to build a model for abbreviation\nwords, collocations, and words that start sentences.  It must be\ntrained on a large collection of plaintext in the target language\nbefore it can be used.\n\nThe NLTK data package includes a pre-trained Punkt tokenizer for\nEnglish.\n\n    >>> import nltk.data\n    >>> text = '''\n    ... Punkt knows that the periods in Mr. Smith and Johann S. Bach\n    ... do not mark sentence boundaries.  And sometimes sentences\n    ... can start with non-capitalized words.  i is a good variable\n    ... name.\n    ... '''\n    >>> sent_detector = nltk.data.load('tokenizers/punkt/english.pickle')\n    >>> print('\\n-----\\n'.join(sent_detector.tokenize(text.strip())))\n    Punkt knows that the periods in Mr. Smith and Johann S. Bach\n    do not mark sentence boundaries.\n    -----\n    And sometimes sentences\n    can start with non-capitalized words.\n    -----\n    i is a good variable\n    name.\n\n(Note that whitespace from the original text, including newlines, is\nretained in the output.)\n\nPunctuation following sentences is also included by default\n(from NLTK 3.0 onwards). It can be excluded with the realign_boundaries\nflag.\n\n    >>> text = '''\n    ... (How does it deal with this parenthesis?)  \"It should be part of the\n    ... previous sentence.\" \"(And the same with this one.)\" ('And this one!')\n    ... \"('(And (this)) '?)\" [(and this. )]\n    ... '''\n    >>> print('\\n-----\\n'.join(\n    ...     sent_detector.tokenize(text.strip())))\n    (How does it deal with this parenthesis?)\n    -----\n    \"It should be part of the\n    previous sentence.\"\n    -----\n    \"(And the same with this one.)\"\n    -----\n    ('And this one!')\n    -----\n    \"('(And (this)) '?)\"\n    -----\n    [(and this. )]\n    >>> print('\\n-----\\n'.join(\n    ...     sent_detector.tokenize(text.strip(), realign_boundaries=False)))\n    (How does it deal with this parenthesis?\n    -----\n    )  \"It should be part of the\n    previous sentence.\n    -----\n    \" \"(And the same with this one.\n    -----\n    )\" ('And this one!\n    -----\n    ')\n    \"('(And (this)) '?\n    -----\n    )\" [(and this.\n    -----\n    )]\n\nHowever, Punkt is designed to learn parameters (a list of abbreviations, etc.)\nunsupervised from a corpus similar to the target domain. The pre-packaged models\nmay therefore be unsuitable: use ``PunktSentenceTokenizer(text)`` to learn\nparameters from the given text.\n\n:class:`.PunktTrainer` learns parameters such as a list of abbreviations\n(without supervision) from portions of text. Using a ``PunktTrainer`` directly\nallows for incremental training and modification of the hyper-parameters used\nto decide what is considered an abbreviation, etc.\n\nThe algorithm for this tokenizer is described in::\n\n  Kiss, Tibor and Strunk, Jan (2006): Unsupervised Multilingual Sentence\n    Boundary Detection.  Computational Linguistics 32: 485-525.\n\"\"\"\n\n# TODO: Make orthographic heuristic less susceptible to overtraining\n# TODO: Frequent sentence starters optionally exclude always-capitalised words\n# FIXME: Problem with ending string with e.g. '!!!' -> '!! !'\n\nimport math\nimport re\nfrom collections import defaultdict\n\nfrom nltk.probability import FreqDist\nfrom nltk.tokenize.api import TokenizerI\n\n######################################################################\n# { Orthographic Context Constants\n######################################################################\n# The following constants are used to describe the orthographic\n# contexts in which a word can occur.  BEG=beginning, MID=middle,\n# UNK=unknown, UC=uppercase, LC=lowercase, NC=no case.\n\n_ORTHO_BEG_UC = 1 << 1\n\"\"\"Orthographic context: beginning of a sentence with upper case.\"\"\"\n\n_ORTHO_MID_UC = 1 << 2\n\"\"\"Orthographic context: middle of a sentence with upper case.\"\"\"\n\n_ORTHO_UNK_UC = 1 << 3\n\"\"\"Orthographic context: unknown position in a sentence with upper case.\"\"\"\n\n_ORTHO_BEG_LC = 1 << 4\n\"\"\"Orthographic context: beginning of a sentence with lower case.\"\"\"\n\n_ORTHO_MID_LC = 1 << 5\n\"\"\"Orthographic context: middle of a sentence with lower case.\"\"\"\n\n_ORTHO_UNK_LC = 1 << 6\n\"\"\"Orthographic context: unknown position in a sentence with lower case.\"\"\"\n\n_ORTHO_UC = _ORTHO_BEG_UC + _ORTHO_MID_UC + _ORTHO_UNK_UC\n\"\"\"Orthographic context: occurs with upper case.\"\"\"\n\n_ORTHO_LC = _ORTHO_BEG_LC + _ORTHO_MID_LC + _ORTHO_UNK_LC\n\"\"\"Orthographic context: occurs with lower case.\"\"\"\n\n_ORTHO_MAP = {\n    (\"initial\", \"upper\"): _ORTHO_BEG_UC,\n    (\"internal\", \"upper\"): _ORTHO_MID_UC,\n    (\"unknown\", \"upper\"): _ORTHO_UNK_UC,\n    (\"initial\", \"lower\"): _ORTHO_BEG_LC,\n    (\"internal\", \"lower\"): _ORTHO_MID_LC,\n    (\"unknown\", \"lower\"): _ORTHO_UNK_LC,\n}\n\"\"\"A map from context position and first-letter case to the\nappropriate orthographic context flag.\"\"\"\n\n# } (end orthographic context constants)\n######################################################################\n\n######################################################################\n# { Decision reasons for debugging\n######################################################################\n\nREASON_DEFAULT_DECISION = \"default decision\"\nREASON_KNOWN_COLLOCATION = \"known collocation (both words)\"\nREASON_ABBR_WITH_ORTHOGRAPHIC_HEURISTIC = \"abbreviation + orthographic heuristic\"\nREASON_ABBR_WITH_SENTENCE_STARTER = \"abbreviation + frequent sentence starter\"\nREASON_INITIAL_WITH_ORTHOGRAPHIC_HEURISTIC = \"initial + orthographic heuristic\"\nREASON_NUMBER_WITH_ORTHOGRAPHIC_HEURISTIC = \"initial + orthographic heuristic\"\nREASON_INITIAL_WITH_SPECIAL_ORTHOGRAPHIC_HEURISTIC = (\n    \"initial + special orthographic heuristic\"\n)\n\n\n# } (end decision reasons for debugging)\n######################################################################\n\n######################################################################\n# { Language-dependent variables\n######################################################################\n\n\nclass PunktLanguageVars:\n    \"\"\"\n    Stores variables, mostly regular expressions, which may be\n    language-dependent for correct application of the algorithm.\n    An extension of this class may modify its properties to suit\n    a language other than English; an instance can then be passed\n    as an argument to PunktSentenceTokenizer and PunktTrainer\n    constructors.\n    \"\"\"\n\n    __slots__ = (\"_re_period_context\", \"_re_word_tokenizer\")\n\n    def __getstate__(self):\n        # All modifications to the class are performed by inheritance.\n        # Non-default parameters to be pickled must be defined in the inherited\n        # class.\n        return 1\n\n    def __setstate__(self, state):\n        return 1\n\n    sent_end_chars = (\".\", \"?\", \"!\")\n    \"\"\"Characters which are candidates for sentence boundaries\"\"\"\n\n    @property\n    def _re_sent_end_chars(self):\n        return \"[%s]\" % re.escape(\"\".join(self.sent_end_chars))\n\n    internal_punctuation = \",:;\"  # might want to extend this..\n    \"\"\"sentence internal punctuation, which indicates an abbreviation if\n    preceded by a period-final token.\"\"\"\n\n    re_boundary_realignment = re.compile(r'[\"\\')\\]}]+?(?:\\s+|(?=--)|$)', re.MULTILINE)\n    \"\"\"Used to realign punctuation that should be included in a sentence\n    although it follows the period (or ?, !).\"\"\"\n\n    _re_word_start = r\"[^\\(\\\"\\`{\\[:;&\\#\\*@\\)}\\]\\-,]\"\n    \"\"\"Excludes some characters from starting word tokens\"\"\"\n\n    @property\n    def _re_non_word_chars(self):\n        return r\"(?:[)\\\";}\\]\\*:@\\'\\({\\[%s])\" % re.escape(\n            \"\".join(set(self.sent_end_chars) - {\".\"})\n        )\n\n    \"\"\"Characters that cannot appear within words\"\"\"\n\n    _re_multi_char_punct = r\"(?:\\-{2,}|\\.{2,}|(?:\\.\\s){2,}\\.)\"\n    \"\"\"Hyphen and ellipsis are multi-character punctuation\"\"\"\n\n    _word_tokenize_fmt = r\"\"\"(\n        %(MultiChar)s\n        |\n        (?=%(WordStart)s)\\S+?  # Accept word characters until end is found\n        (?= # Sequences marking a word's end\n            \\s|                                 # White-space\n            $|                                  # End-of-string\n            %(NonWord)s|%(MultiChar)s|          # Punctuation\n            ,(?=$|\\s|%(NonWord)s|%(MultiChar)s) # Comma if at end of word\n        )\n        |\n        \\S\n    )\"\"\"\n    \"\"\"Format of a regular expression to split punctuation from words,\n    excluding period.\"\"\"\n\n    def _word_tokenizer_re(self):\n        \"\"\"Compiles and returns a regular expression for word tokenization\"\"\"\n        try:\n            return self._re_word_tokenizer\n        except AttributeError:\n            self._re_word_tokenizer = re.compile(\n                self._word_tokenize_fmt\n                % {\n                    \"NonWord\": self._re_non_word_chars,\n                    \"MultiChar\": self._re_multi_char_punct,\n                    \"WordStart\": self._re_word_start,\n                },\n                re.UNICODE | re.VERBOSE,\n            )\n            return self._re_word_tokenizer\n\n    def word_tokenize(self, s):\n        \"\"\"Tokenize a string to split off punctuation other than periods\"\"\"\n        return self._word_tokenizer_re().findall(s)\n\n    _period_context_fmt = r\"\"\"\n        \\S*                          # some word material\n        %(SentEndChars)s             # a potential sentence ending\n        (?=(?P<after_tok>\n            %(NonWord)s              # either other punctuation\n            |\n            \\s+(?P<next_tok>\\S+)     # or whitespace and some other token\n        ))\"\"\"\n    \"\"\"Format of a regular expression to find contexts including possible\n    sentence boundaries. Matches token which the possible sentence boundary\n    ends, and matches the following token within a lookahead expression.\"\"\"\n\n    def period_context_re(self):\n        \"\"\"Compiles and returns a regular expression to find contexts\n        including possible sentence boundaries.\"\"\"\n        try:\n            return self._re_period_context\n        except:\n            self._re_period_context = re.compile(\n                self._period_context_fmt\n                % {\n                    \"NonWord\": self._re_non_word_chars,\n                    \"SentEndChars\": self._re_sent_end_chars,\n                },\n                re.UNICODE | re.VERBOSE,\n            )\n            return self._re_period_context\n\n\n_re_non_punct = re.compile(r\"[^\\W\\d]\", re.UNICODE)\n\"\"\"Matches token types that are not merely punctuation. (Types for\nnumeric tokens are changed to ##number## and hence contain alpha.)\"\"\"\n\n\n# }\n######################################################################\n\n\n# ////////////////////////////////////////////////////////////\n# { Helper Functions\n# ////////////////////////////////////////////////////////////\n\n\ndef _pair_iter(iterator):\n    \"\"\"\n    Yields pairs of tokens from the given iterator such that each input\n    token will appear as the first element in a yielded tuple. The last\n    pair will have None as its second element.\n    \"\"\"\n    iterator = iter(iterator)\n    try:\n        prev = next(iterator)\n    except StopIteration:\n        return\n    for el in iterator:\n        yield (prev, el)\n        prev = el\n    yield (prev, None)\n\n\n######################################################################\n# { Punkt Parameters\n######################################################################\n\n\nclass PunktParameters:\n    \"\"\"Stores data used to perform sentence boundary detection with Punkt.\"\"\"\n\n    def __init__(self):\n        self.abbrev_types = set()\n        \"\"\"A set of word types for known abbreviations.\"\"\"\n\n        self.collocations = set()\n        \"\"\"A set of word type tuples for known common collocations\n        where the first word ends in a period.  E.g., ('S.', 'Bach')\n        is a common collocation in a text that discusses 'Johann\n        S. Bach'.  These count as negative evidence for sentence\n        boundaries.\"\"\"\n\n        self.sent_starters = set()\n        \"\"\"A set of word types for words that often appear at the\n        beginning of sentences.\"\"\"\n\n        self.ortho_context = defaultdict(int)\n        \"\"\"A dictionary mapping word types to the set of orthographic\n        contexts that word type appears in.  Contexts are represented\n        by adding orthographic context flags: ...\"\"\"\n\n    def clear_abbrevs(self):\n        self.abbrev_types = set()\n\n    def clear_collocations(self):\n        self.collocations = set()\n\n    def clear_sent_starters(self):\n        self.sent_starters = set()\n\n    def clear_ortho_context(self):\n        self.ortho_context = defaultdict(int)\n\n    def add_ortho_context(self, typ, flag):\n        self.ortho_context[typ] |= flag\n\n    def _debug_ortho_context(self, typ):\n        context = self.ortho_context[typ]\n        if context & _ORTHO_BEG_UC:\n            yield \"BEG-UC\"\n        if context & _ORTHO_MID_UC:\n            yield \"MID-UC\"\n        if context & _ORTHO_UNK_UC:\n            yield \"UNK-UC\"\n        if context & _ORTHO_BEG_LC:\n            yield \"BEG-LC\"\n        if context & _ORTHO_MID_LC:\n            yield \"MID-LC\"\n        if context & _ORTHO_UNK_LC:\n            yield \"UNK-LC\"\n\n\n######################################################################\n# { PunktToken\n######################################################################\n\n\nclass PunktToken:\n    \"\"\"Stores a token of text with annotations produced during\n    sentence boundary detection.\"\"\"\n\n    _properties = [\"parastart\", \"linestart\", \"sentbreak\", \"abbr\", \"ellipsis\"]\n    __slots__ = [\"tok\", \"type\", \"period_final\"] + _properties\n\n    def __init__(self, tok, **params):\n        self.tok = tok\n        self.type = self._get_type(tok)\n        self.period_final = tok.endswith(\".\")\n\n        for prop in self._properties:\n            setattr(self, prop, None)\n        for k in params:\n            setattr(self, k, params[k])\n\n    # ////////////////////////////////////////////////////////////\n    # { Regular expressions for properties\n    # ////////////////////////////////////////////////////////////\n    # Note: [A-Za-z] is approximated by [^\\W\\d] in the general case.\n    _RE_ELLIPSIS = re.compile(r\"\\.\\.+$\")\n    _RE_NUMERIC = re.compile(r\"^-?[\\.,]?\\d[\\d,\\.-]*\\.?$\")\n    _RE_INITIAL = re.compile(r\"[^\\W\\d]\\.$\", re.UNICODE)\n    _RE_ALPHA = re.compile(r\"[^\\W\\d]+$\", re.UNICODE)\n\n    # ////////////////////////////////////////////////////////////\n    # { Derived properties\n    # ////////////////////////////////////////////////////////////\n\n    def _get_type(self, tok):\n        \"\"\"Returns a case-normalized representation of the token.\"\"\"\n        return self._RE_NUMERIC.sub(\"##number##\", tok.lower())\n\n    @property\n    def type_no_period(self):\n        \"\"\"\n        The type with its final period removed if it has one.\n        \"\"\"\n        if len(self.type) > 1 and self.type[-1] == \".\":\n            return self.type[:-1]\n        return self.type\n\n    @property\n    def type_no_sentperiod(self):\n        \"\"\"\n        The type with its final period removed if it is marked as a\n        sentence break.\n        \"\"\"\n        if self.sentbreak:\n            return self.type_no_period\n        return self.type\n\n    @property\n    def first_upper(self):\n        \"\"\"True if the token's first character is uppercase.\"\"\"\n        return self.tok[0].isupper()\n\n    @property\n    def first_lower(self):\n        \"\"\"True if the token's first character is lowercase.\"\"\"\n        return self.tok[0].islower()\n\n    @property\n    def first_case(self):\n        if self.first_lower:\n            return \"lower\"\n        if self.first_upper:\n            return \"upper\"\n        return \"none\"\n\n    @property\n    def is_ellipsis(self):\n        \"\"\"True if the token text is that of an ellipsis.\"\"\"\n        return self._RE_ELLIPSIS.match(self.tok)\n\n    @property\n    def is_number(self):\n        \"\"\"True if the token text is that of a number.\"\"\"\n        return self.type.startswith(\"##number##\")\n\n    @property\n    def is_initial(self):\n        \"\"\"True if the token text is that of an initial.\"\"\"\n        return self._RE_INITIAL.match(self.tok)\n\n    @property\n    def is_alpha(self):\n        \"\"\"True if the token text is all alphabetic.\"\"\"\n        return self._RE_ALPHA.match(self.tok)\n\n    @property\n    def is_non_punct(self):\n        \"\"\"True if the token is either a number or is alphabetic.\"\"\"\n        return _re_non_punct.search(self.type)\n\n    # ////////////////////////////////////////////////////////////\n    # { String representation\n    # ////////////////////////////////////////////////////////////\n\n    def __repr__(self):\n        \"\"\"\n        A string representation of the token that can reproduce it\n        with eval(), which lists all the token's non-default\n        annotations.\n        \"\"\"\n        typestr = \" type=%s,\" % repr(self.type) if self.type != self.tok else \"\"\n\n        propvals = \", \".join(\n            f\"{p}={repr(getattr(self, p))}\"\n            for p in self._properties\n            if getattr(self, p)\n        )\n\n        return \"{}({},{} {})\".format(\n            self.__class__.__name__,\n            repr(self.tok),\n            typestr,\n            propvals,\n        )\n\n    def __str__(self):\n        \"\"\"\n        A string representation akin to that used by Kiss and Strunk.\n        \"\"\"\n        res = self.tok\n        if self.abbr:\n            res += \"<A>\"\n        if self.ellipsis:\n            res += \"<E>\"\n        if self.sentbreak:\n            res += \"<S>\"\n        return res\n\n\n######################################################################\n# { Punkt base class\n######################################################################\n\n\nclass PunktBaseClass:\n    \"\"\"\n    Includes common components of PunktTrainer and PunktSentenceTokenizer.\n    \"\"\"\n\n    def __init__(self, lang_vars=None, token_cls=PunktToken, params=None):\n        if lang_vars is None:\n            lang_vars = PunktLanguageVars()\n        if params is None:\n            params = PunktParameters()\n        self._params = params\n        self._lang_vars = lang_vars\n        self._Token = token_cls\n        \"\"\"The collection of parameters that determines the behavior\n        of the punkt tokenizer.\"\"\"\n\n    # ////////////////////////////////////////////////////////////\n    # { Word tokenization\n    # ////////////////////////////////////////////////////////////\n\n    def _tokenize_words(self, plaintext):\n        \"\"\"\n        Divide the given text into tokens, using the punkt word\n        segmentation regular expression, and generate the resulting list\n        of tokens augmented as three-tuples with two boolean values for whether\n        the given token occurs at the start of a paragraph or a new line,\n        respectively.\n        \"\"\"\n        parastart = False\n        for line in plaintext.split(\"\\n\"):\n            if line.strip():\n                line_toks = iter(self._lang_vars.word_tokenize(line))\n\n                try:\n                    tok = next(line_toks)\n                except StopIteration:\n                    continue\n\n                yield self._Token(tok, parastart=parastart, linestart=True)\n                parastart = False\n\n                for tok in line_toks:\n                    yield self._Token(tok)\n            else:\n                parastart = True\n\n    # ////////////////////////////////////////////////////////////\n    # { Annotation Procedures\n    # ////////////////////////////////////////////////////////////\n\n    def _annotate_first_pass(self, tokens):\n        \"\"\"\n        Perform the first pass of annotation, which makes decisions\n        based purely based on the word type of each word:\n\n          - '?', '!', and '.' are marked as sentence breaks.\n          - sequences of two or more periods are marked as ellipsis.\n          - any word ending in '.' that's a known abbreviation is\n            marked as an abbreviation.\n          - any other word ending in '.' is marked as a sentence break.\n\n        Return these annotations as a tuple of three sets:\n\n          - sentbreak_toks: The indices of all sentence breaks.\n          - abbrev_toks: The indices of all abbreviations.\n          - ellipsis_toks: The indices of all ellipsis marks.\n        \"\"\"\n        for aug_tok in tokens:\n            self._first_pass_annotation(aug_tok)\n            yield aug_tok\n\n    def _first_pass_annotation(self, aug_tok):\n        \"\"\"\n        Performs type-based annotation on a single token.\n        \"\"\"\n\n        tok = aug_tok.tok\n\n        if tok in self._lang_vars.sent_end_chars:\n            aug_tok.sentbreak = True\n        elif aug_tok.is_ellipsis:\n            aug_tok.ellipsis = True\n        elif aug_tok.period_final and not tok.endswith(\"..\"):\n            if (\n                tok[:-1].lower() in self._params.abbrev_types\n                or tok[:-1].lower().split(\"-\")[-1] in self._params.abbrev_types\n            ):\n\n                aug_tok.abbr = True\n            else:\n                aug_tok.sentbreak = True\n\n        return\n\n\n######################################################################\n# { Punkt Trainer\n######################################################################\n\n\nclass PunktTrainer(PunktBaseClass):\n    \"\"\"Learns parameters used in Punkt sentence boundary detection.\"\"\"\n\n    def __init__(\n        self, train_text=None, verbose=False, lang_vars=None, token_cls=PunktToken\n    ):\n\n        PunktBaseClass.__init__(self, lang_vars=lang_vars, token_cls=token_cls)\n\n        self._type_fdist = FreqDist()\n        \"\"\"A frequency distribution giving the frequency of each\n        case-normalized token type in the training data.\"\"\"\n\n        self._num_period_toks = 0\n        \"\"\"The number of words ending in period in the training data.\"\"\"\n\n        self._collocation_fdist = FreqDist()\n        \"\"\"A frequency distribution giving the frequency of all\n        bigrams in the training data where the first word ends in a\n        period.  Bigrams are encoded as tuples of word types.\n        Especially common collocations are extracted from this\n        frequency distribution, and stored in\n        ``_params``.``collocations <PunktParameters.collocations>``.\"\"\"\n\n        self._sent_starter_fdist = FreqDist()\n        \"\"\"A frequency distribution giving the frequency of all words\n        that occur at the training data at the beginning of a sentence\n        (after the first pass of annotation).  Especially common\n        sentence starters are extracted from this frequency\n        distribution, and stored in ``_params.sent_starters``.\n        \"\"\"\n\n        self._sentbreak_count = 0\n        \"\"\"The total number of sentence breaks identified in training, used for\n        calculating the frequent sentence starter heuristic.\"\"\"\n\n        self._finalized = True\n        \"\"\"A flag as to whether the training has been finalized by finding\n        collocations and sentence starters, or whether finalize_training()\n        still needs to be called.\"\"\"\n\n        if train_text:\n            self.train(train_text, verbose, finalize=True)\n\n    def get_params(self):\n        \"\"\"\n        Calculates and returns parameters for sentence boundary detection as\n        derived from training.\"\"\"\n        if not self._finalized:\n            self.finalize_training()\n        return self._params\n\n    # ////////////////////////////////////////////////////////////\n    # { Customization Variables\n    # ////////////////////////////////////////////////////////////\n\n    ABBREV = 0.3\n    \"\"\"cut-off value whether a 'token' is an abbreviation\"\"\"\n\n    IGNORE_ABBREV_PENALTY = False\n    \"\"\"allows the disabling of the abbreviation penalty heuristic, which\n    exponentially disadvantages words that are found at times without a\n    final period.\"\"\"\n\n    ABBREV_BACKOFF = 5\n    \"\"\"upper cut-off for Mikheev's(2002) abbreviation detection algorithm\"\"\"\n\n    COLLOCATION = 7.88\n    \"\"\"minimal log-likelihood value that two tokens need to be considered\n    as a collocation\"\"\"\n\n    SENT_STARTER = 30\n    \"\"\"minimal log-likelihood value that a token requires to be considered\n    as a frequent sentence starter\"\"\"\n\n    INCLUDE_ALL_COLLOCS = False\n    \"\"\"this includes as potential collocations all word pairs where the first\n    word ends in a period. It may be useful in corpora where there is a lot\n    of variation that makes abbreviations like Mr difficult to identify.\"\"\"\n\n    INCLUDE_ABBREV_COLLOCS = False\n    \"\"\"this includes as potential collocations all word pairs where the first\n    word is an abbreviation. Such collocations override the orthographic\n    heuristic, but not the sentence starter heuristic. This is overridden by\n    INCLUDE_ALL_COLLOCS, and if both are false, only collocations with initials\n    and ordinals are considered.\"\"\"\n    \"\"\"\"\"\"\n\n    MIN_COLLOC_FREQ = 1\n    \"\"\"this sets a minimum bound on the number of times a bigram needs to\n    appear before it can be considered a collocation, in addition to log\n    likelihood statistics. This is useful when INCLUDE_ALL_COLLOCS is True.\"\"\"\n\n    # ////////////////////////////////////////////////////////////\n    # { Training..\n    # ////////////////////////////////////////////////////////////\n\n    def train(self, text, verbose=False, finalize=True):\n        \"\"\"\n        Collects training data from a given text. If finalize is True, it\n        will determine all the parameters for sentence boundary detection. If\n        not, this will be delayed until get_params() or finalize_training() is\n        called. If verbose is True, abbreviations found will be listed.\n        \"\"\"\n        # Break the text into tokens; record which token indices correspond to\n        # line starts and paragraph starts; and determine their types.\n        self._train_tokens(self._tokenize_words(text), verbose)\n        if finalize:\n            self.finalize_training(verbose)\n\n    def train_tokens(self, tokens, verbose=False, finalize=True):\n        \"\"\"\n        Collects training data from a given list of tokens.\n        \"\"\"\n        self._train_tokens((self._Token(t) for t in tokens), verbose)\n        if finalize:\n            self.finalize_training(verbose)\n\n    def _train_tokens(self, tokens, verbose):\n        self._finalized = False\n\n        # Ensure tokens are a list\n        tokens = list(tokens)\n\n        # Find the frequency of each case-normalized type.  (Don't\n        # strip off final periods.)  Also keep track of the number of\n        # tokens that end in periods.\n        for aug_tok in tokens:\n            self._type_fdist[aug_tok.type] += 1\n            if aug_tok.period_final:\n                self._num_period_toks += 1\n\n        # Look for new abbreviations, and for types that no longer are\n        unique_types = self._unique_types(tokens)\n        for abbr, score, is_add in self._reclassify_abbrev_types(unique_types):\n            if score >= self.ABBREV:\n                if is_add:\n                    self._params.abbrev_types.add(abbr)\n                    if verbose:\n                        print(f\"  Abbreviation: [{score:6.4f}] {abbr}\")\n            else:\n                if not is_add:\n                    self._params.abbrev_types.remove(abbr)\n                    if verbose:\n                        print(f\"  Removed abbreviation: [{score:6.4f}] {abbr}\")\n\n        # Make a preliminary pass through the document, marking likely\n        # sentence breaks, abbreviations, and ellipsis tokens.\n        tokens = list(self._annotate_first_pass(tokens))\n\n        # Check what contexts each word type can appear in, given the\n        # case of its first letter.\n        self._get_orthography_data(tokens)\n\n        # We need total number of sentence breaks to find sentence starters\n        self._sentbreak_count += self._get_sentbreak_count(tokens)\n\n        # The remaining heuristics relate to pairs of tokens where the first\n        # ends in a period.\n        for aug_tok1, aug_tok2 in _pair_iter(tokens):\n            if not aug_tok1.period_final or not aug_tok2:\n                continue\n\n            # Is the first token a rare abbreviation?\n            if self._is_rare_abbrev_type(aug_tok1, aug_tok2):\n                self._params.abbrev_types.add(aug_tok1.type_no_period)\n                if verbose:\n                    print(\"  Rare Abbrev: %s\" % aug_tok1.type)\n\n            # Does second token have a high likelihood of starting a sentence?\n            if self._is_potential_sent_starter(aug_tok2, aug_tok1):\n                self._sent_starter_fdist[aug_tok2.type] += 1\n\n            # Is this bigram a potential collocation?\n            if self._is_potential_collocation(aug_tok1, aug_tok2):\n                self._collocation_fdist[\n                    (aug_tok1.type_no_period, aug_tok2.type_no_sentperiod)\n                ] += 1\n\n    def _unique_types(self, tokens):\n        return {aug_tok.type for aug_tok in tokens}\n\n    def finalize_training(self, verbose=False):\n        \"\"\"\n        Uses data that has been gathered in training to determine likely\n        collocations and sentence starters.\n        \"\"\"\n        self._params.clear_sent_starters()\n        for typ, log_likelihood in self._find_sent_starters():\n            self._params.sent_starters.add(typ)\n            if verbose:\n                print(f\"  Sent Starter: [{log_likelihood:6.4f}] {typ!r}\")\n\n        self._params.clear_collocations()\n        for (typ1, typ2), log_likelihood in self._find_collocations():\n            self._params.collocations.add((typ1, typ2))\n            if verbose:\n                print(f\"  Collocation: [{log_likelihood:6.4f}] {typ1!r}+{typ2!r}\")\n\n        self._finalized = True\n\n    # ////////////////////////////////////////////////////////////\n    # { Overhead reduction\n    # ////////////////////////////////////////////////////////////\n\n    def freq_threshold(\n        self, ortho_thresh=2, type_thresh=2, colloc_thres=2, sentstart_thresh=2\n    ):\n        \"\"\"\n        Allows memory use to be reduced after much training by removing data\n        about rare tokens that are unlikely to have a statistical effect with\n        further training. Entries occurring above the given thresholds will be\n        retained.\n        \"\"\"\n        if ortho_thresh > 1:\n            old_oc = self._params.ortho_context\n            self._params.clear_ortho_context()\n            for tok in self._type_fdist:\n                count = self._type_fdist[tok]\n                if count >= ortho_thresh:\n                    self._params.ortho_context[tok] = old_oc[tok]\n\n        self._type_fdist = self._freq_threshold(self._type_fdist, type_thresh)\n        self._collocation_fdist = self._freq_threshold(\n            self._collocation_fdist, colloc_thres\n        )\n        self._sent_starter_fdist = self._freq_threshold(\n            self._sent_starter_fdist, sentstart_thresh\n        )\n\n    def _freq_threshold(self, fdist, threshold):\n        \"\"\"\n        Returns a FreqDist containing only data with counts below a given\n        threshold, as well as a mapping (None -> count_removed).\n        \"\"\"\n        # We assume that there is more data below the threshold than above it\n        # and so create a new FreqDist rather than working in place.\n        res = FreqDist()\n        num_removed = 0\n        for tok in fdist:\n            count = fdist[tok]\n            if count < threshold:\n                num_removed += 1\n            else:\n                res[tok] += count\n        res[None] += num_removed\n        return res\n\n    # ////////////////////////////////////////////////////////////\n    # { Orthographic data\n    # ////////////////////////////////////////////////////////////\n\n    def _get_orthography_data(self, tokens):\n        \"\"\"\n        Collect information about whether each token type occurs\n        with different case patterns (i) overall, (ii) at\n        sentence-initial positions, and (iii) at sentence-internal\n        positions.\n        \"\"\"\n        # 'initial' or 'internal' or 'unknown'\n        context = \"internal\"\n        tokens = list(tokens)\n\n        for aug_tok in tokens:\n            # If we encounter a paragraph break, then it's a good sign\n            # that it's a sentence break.  But err on the side of\n            # caution (by not positing a sentence break) if we just\n            # saw an abbreviation.\n            if aug_tok.parastart and context != \"unknown\":\n                context = \"initial\"\n\n            # If we're at the beginning of a line, then we can't decide\n            # between 'internal' and 'initial'.\n            if aug_tok.linestart and context == \"internal\":\n                context = \"unknown\"\n\n            # Find the case-normalized type of the token.  If it's a\n            # sentence-final token, strip off the period.\n            typ = aug_tok.type_no_sentperiod\n\n            # Update the orthographic context table.\n            flag = _ORTHO_MAP.get((context, aug_tok.first_case), 0)\n            if flag:\n                self._params.add_ortho_context(typ, flag)\n\n            # Decide whether the next word is at a sentence boundary.\n            if aug_tok.sentbreak:\n                if not (aug_tok.is_number or aug_tok.is_initial):\n                    context = \"initial\"\n                else:\n                    context = \"unknown\"\n            elif aug_tok.ellipsis or aug_tok.abbr:\n                context = \"unknown\"\n            else:\n                context = \"internal\"\n\n    # ////////////////////////////////////////////////////////////\n    # { Abbreviations\n    # ////////////////////////////////////////////////////////////\n\n    def _reclassify_abbrev_types(self, types):\n        \"\"\"\n        (Re)classifies each given token if\n          - it is period-final and not a known abbreviation; or\n          - it is not period-final and is otherwise a known abbreviation\n        by checking whether its previous classification still holds according\n        to the heuristics of section 3.\n        Yields triples (abbr, score, is_add) where abbr is the type in question,\n        score is its log-likelihood with penalties applied, and is_add specifies\n        whether the present type is a candidate for inclusion or exclusion as an\n        abbreviation, such that:\n          - (is_add and score >= 0.3)    suggests a new abbreviation; and\n          - (not is_add and score < 0.3) suggests excluding an abbreviation.\n        \"\"\"\n        # (While one could recalculate abbreviations from all .-final tokens at\n        # every iteration, in cases requiring efficiency, the number of tokens\n        # in the present training document will be much less.)\n\n        for typ in types:\n            # Check some basic conditions, to rule out words that are\n            # clearly not abbrev_types.\n            if not _re_non_punct.search(typ) or typ == \"##number##\":\n                continue\n\n            if typ.endswith(\".\"):\n                if typ in self._params.abbrev_types:\n                    continue\n                typ = typ[:-1]\n                is_add = True\n            else:\n                if typ not in self._params.abbrev_types:\n                    continue\n                is_add = False\n\n            # Count how many periods & nonperiods are in the\n            # candidate.\n            num_periods = typ.count(\".\") + 1\n            num_nonperiods = len(typ) - num_periods + 1\n\n            # Let <a> be the candidate without the period, and <b>\n            # be the period.  Find a log likelihood ratio that\n            # indicates whether <ab> occurs as a single unit (high\n            # value of log_likelihood), or as two independent units <a> and\n            # <b> (low value of log_likelihood).\n            count_with_period = self._type_fdist[typ + \".\"]\n            count_without_period = self._type_fdist[typ]\n            log_likelihood = self._dunning_log_likelihood(\n                count_with_period + count_without_period,\n                self._num_period_toks,\n                count_with_period,\n                self._type_fdist.N(),\n            )\n\n            # Apply three scaling factors to 'tweak' the basic log\n            # likelihood ratio:\n            #   F_length: long word -> less likely to be an abbrev\n            #   F_periods: more periods -> more likely to be an abbrev\n            #   F_penalty: penalize occurrences w/o a period\n            f_length = math.exp(-num_nonperiods)\n            f_periods = num_periods\n            f_penalty = int(self.IGNORE_ABBREV_PENALTY) or math.pow(\n                num_nonperiods, -count_without_period\n            )\n            score = log_likelihood * f_length * f_periods * f_penalty\n\n            yield typ, score, is_add\n\n    def find_abbrev_types(self):\n        \"\"\"\n        Recalculates abbreviations given type frequencies, despite no prior\n        determination of abbreviations.\n        This fails to include abbreviations otherwise found as \"rare\".\n        \"\"\"\n        self._params.clear_abbrevs()\n        tokens = (typ for typ in self._type_fdist if typ and typ.endswith(\".\"))\n        for abbr, score, _is_add in self._reclassify_abbrev_types(tokens):\n            if score >= self.ABBREV:\n                self._params.abbrev_types.add(abbr)\n\n    # This function combines the work done by the original code's\n    # functions `count_orthography_context`, `get_orthography_count`,\n    # and `get_rare_abbreviations`.\n    def _is_rare_abbrev_type(self, cur_tok, next_tok):\n        \"\"\"\n        A word type is counted as a rare abbreviation if...\n          - it's not already marked as an abbreviation\n          - it occurs fewer than ABBREV_BACKOFF times\n          - either it is followed by a sentence-internal punctuation\n            mark, *or* it is followed by a lower-case word that\n            sometimes appears with upper case, but never occurs with\n            lower case at the beginning of sentences.\n        \"\"\"\n        if cur_tok.abbr or not cur_tok.sentbreak:\n            return False\n\n        # Find the case-normalized type of the token.  If it's\n        # a sentence-final token, strip off the period.\n        typ = cur_tok.type_no_sentperiod\n\n        # Proceed only if the type hasn't been categorized as an\n        # abbreviation already, and is sufficiently rare...\n        count = self._type_fdist[typ] + self._type_fdist[typ[:-1]]\n        if typ in self._params.abbrev_types or count >= self.ABBREV_BACKOFF:\n            return False\n\n        # Record this token as an abbreviation if the next\n        # token is a sentence-internal punctuation mark.\n        # [XX] :1 or check the whole thing??\n        if next_tok.tok[:1] in self._lang_vars.internal_punctuation:\n            return True\n\n        # Record this type as an abbreviation if the next\n        # token...  (i) starts with a lower case letter,\n        # (ii) sometimes occurs with an uppercase letter,\n        # and (iii) never occus with an uppercase letter\n        # sentence-internally.\n        # [xx] should the check for (ii) be modified??\n        if next_tok.first_lower:\n            typ2 = next_tok.type_no_sentperiod\n            typ2ortho_context = self._params.ortho_context[typ2]\n            if (typ2ortho_context & _ORTHO_BEG_UC) and not (\n                typ2ortho_context & _ORTHO_MID_UC\n            ):\n                return True\n\n    # ////////////////////////////////////////////////////////////\n    # { Log Likelihoods\n    # ////////////////////////////////////////////////////////////\n\n    # helper for _reclassify_abbrev_types:\n    @staticmethod\n    def _dunning_log_likelihood(count_a, count_b, count_ab, N):\n        \"\"\"\n        A function that calculates the modified Dunning log-likelihood\n        ratio scores for abbreviation candidates.  The details of how\n        this works is available in the paper.\n        \"\"\"\n        p1 = count_b / N\n        p2 = 0.99\n\n        null_hypo = count_ab * math.log(p1) + (count_a - count_ab) * math.log(1.0 - p1)\n        alt_hypo = count_ab * math.log(p2) + (count_a - count_ab) * math.log(1.0 - p2)\n\n        likelihood = null_hypo - alt_hypo\n\n        return -2.0 * likelihood\n\n    @staticmethod\n    def _col_log_likelihood(count_a, count_b, count_ab, N):\n        \"\"\"\n        A function that will just compute log-likelihood estimate, in\n        the original paper it's described in algorithm 6 and 7.\n\n        This *should* be the original Dunning log-likelihood values,\n        unlike the previous log_l function where it used modified\n        Dunning log-likelihood values\n        \"\"\"\n        p = count_b / N\n        p1 = count_ab / count_a\n        try:\n            p2 = (count_b - count_ab) / (N - count_a)\n        except ZeroDivisionError:\n            p2 = 1\n\n        try:\n            summand1 = count_ab * math.log(p) + (count_a - count_ab) * math.log(1.0 - p)\n        except ValueError:\n            summand1 = 0\n\n        try:\n            summand2 = (count_b - count_ab) * math.log(p) + (\n                N - count_a - count_b + count_ab\n            ) * math.log(1.0 - p)\n        except ValueError:\n            summand2 = 0\n\n        if count_a == count_ab or p1 <= 0 or p1 >= 1:\n            summand3 = 0\n        else:\n            summand3 = count_ab * math.log(p1) + (count_a - count_ab) * math.log(\n                1.0 - p1\n            )\n\n        if count_b == count_ab or p2 <= 0 or p2 >= 1:\n            summand4 = 0\n        else:\n            summand4 = (count_b - count_ab) * math.log(p2) + (\n                N - count_a - count_b + count_ab\n            ) * math.log(1.0 - p2)\n\n        likelihood = summand1 + summand2 - summand3 - summand4\n\n        return -2.0 * likelihood\n\n    # ////////////////////////////////////////////////////////////\n    # { Collocation Finder\n    # ////////////////////////////////////////////////////////////\n\n    def _is_potential_collocation(self, aug_tok1, aug_tok2):\n        \"\"\"\n        Returns True if the pair of tokens may form a collocation given\n        log-likelihood statistics.\n        \"\"\"\n        return (\n            (\n                self.INCLUDE_ALL_COLLOCS\n                or (self.INCLUDE_ABBREV_COLLOCS and aug_tok1.abbr)\n                or (aug_tok1.sentbreak and (aug_tok1.is_number or aug_tok1.is_initial))\n            )\n            and aug_tok1.is_non_punct\n            and aug_tok2.is_non_punct\n        )\n\n    def _find_collocations(self):\n        \"\"\"\n        Generates likely collocations and their log-likelihood.\n        \"\"\"\n        for types in self._collocation_fdist:\n            try:\n                typ1, typ2 = types\n            except TypeError:\n                # types may be None after calling freq_threshold()\n                continue\n            if typ2 in self._params.sent_starters:\n                continue\n\n            col_count = self._collocation_fdist[types]\n            typ1_count = self._type_fdist[typ1] + self._type_fdist[typ1 + \".\"]\n            typ2_count = self._type_fdist[typ2] + self._type_fdist[typ2 + \".\"]\n            if (\n                typ1_count > 1\n                and typ2_count > 1\n                and self.MIN_COLLOC_FREQ < col_count <= min(typ1_count, typ2_count)\n            ):\n\n                log_likelihood = self._col_log_likelihood(\n                    typ1_count, typ2_count, col_count, self._type_fdist.N()\n                )\n                # Filter out the not-so-collocative\n                if log_likelihood >= self.COLLOCATION and (\n                    self._type_fdist.N() / typ1_count > typ2_count / col_count\n                ):\n                    yield (typ1, typ2), log_likelihood\n\n    # ////////////////////////////////////////////////////////////\n    # { Sentence-Starter Finder\n    # ////////////////////////////////////////////////////////////\n\n    def _is_potential_sent_starter(self, cur_tok, prev_tok):\n        \"\"\"\n        Returns True given a token and the token that precedes it if it\n        seems clear that the token is beginning a sentence.\n        \"\"\"\n        # If a token (i) is preceded by a sentece break that is\n        # not a potential ordinal number or initial, and (ii) is\n        # alphabetic, then it is a a sentence-starter.\n        return (\n            prev_tok.sentbreak\n            and not (prev_tok.is_number or prev_tok.is_initial)\n            and cur_tok.is_alpha\n        )\n\n    def _find_sent_starters(self):\n        \"\"\"\n        Uses collocation heuristics for each candidate token to\n        determine if it frequently starts sentences.\n        \"\"\"\n        for typ in self._sent_starter_fdist:\n            if not typ:\n                continue\n\n            typ_at_break_count = self._sent_starter_fdist[typ]\n            typ_count = self._type_fdist[typ] + self._type_fdist[typ + \".\"]\n            if typ_count < typ_at_break_count:\n                # needed after freq_threshold\n                continue\n\n            log_likelihood = self._col_log_likelihood(\n                self._sentbreak_count,\n                typ_count,\n                typ_at_break_count,\n                self._type_fdist.N(),\n            )\n\n            if (\n                log_likelihood >= self.SENT_STARTER\n                and self._type_fdist.N() / self._sentbreak_count\n                > typ_count / typ_at_break_count\n            ):\n                yield typ, log_likelihood\n\n    def _get_sentbreak_count(self, tokens):\n        \"\"\"\n        Returns the number of sentence breaks marked in a given set of\n        augmented tokens.\n        \"\"\"\n        return sum(1 for aug_tok in tokens if aug_tok.sentbreak)\n\n\n######################################################################\n# { Punkt Sentence Tokenizer\n######################################################################\n\n\nclass PunktSentenceTokenizer(PunktBaseClass, TokenizerI):\n    \"\"\"\n    A sentence tokenizer which uses an unsupervised algorithm to build\n    a model for abbreviation words, collocations, and words that start\n    sentences; and then uses that model to find sentence boundaries.\n    This approach has been shown to work well for many European\n    languages.\n    \"\"\"\n\n    def __init__(\n        self, train_text=None, verbose=False, lang_vars=None, token_cls=PunktToken\n    ):\n        \"\"\"\n        train_text can either be the sole training text for this sentence\n        boundary detector, or can be a PunktParameters object.\n        \"\"\"\n        PunktBaseClass.__init__(self, lang_vars=lang_vars, token_cls=token_cls)\n\n        if train_text:\n            self._params = self.train(train_text, verbose)\n\n    def train(self, train_text, verbose=False):\n        \"\"\"\n        Derives parameters from a given training text, or uses the parameters\n        given. Repeated calls to this method destroy previous parameters. For\n        incremental training, instantiate a separate PunktTrainer instance.\n        \"\"\"\n        if not isinstance(train_text, str):\n            return train_text\n        return PunktTrainer(\n            train_text, lang_vars=self._lang_vars, token_cls=self._Token\n        ).get_params()\n\n    # ////////////////////////////////////////////////////////////\n    # { Tokenization\n    # ////////////////////////////////////////////////////////////\n\n    def tokenize(self, text, realign_boundaries=True):\n        \"\"\"\n        Given a text, returns a list of the sentences in that text.\n        \"\"\"\n        return list(self.sentences_from_text(text, realign_boundaries))\n\n    def debug_decisions(self, text):\n        \"\"\"\n        Classifies candidate periods as sentence breaks, yielding a dict for\n        each that may be used to understand why the decision was made.\n\n        See format_debug_decision() to help make this output readable.\n        \"\"\"\n\n        for match in self._lang_vars.period_context_re().finditer(text):\n            decision_text = match.group() + match.group(\"after_tok\")\n            tokens = self._tokenize_words(decision_text)\n            tokens = list(self._annotate_first_pass(tokens))\n            while tokens and not tokens[0].tok.endswith(self._lang_vars.sent_end_chars):\n                tokens.pop(0)\n            yield {\n                \"period_index\": match.end() - 1,\n                \"text\": decision_text,\n                \"type1\": tokens[0].type,\n                \"type2\": tokens[1].type,\n                \"type1_in_abbrs\": bool(tokens[0].abbr),\n                \"type1_is_initial\": bool(tokens[0].is_initial),\n                \"type2_is_sent_starter\": tokens[1].type_no_sentperiod\n                in self._params.sent_starters,\n                \"type2_ortho_heuristic\": self._ortho_heuristic(tokens[1]),\n                \"type2_ortho_contexts\": set(\n                    self._params._debug_ortho_context(tokens[1].type_no_sentperiod)\n                ),\n                \"collocation\": (\n                    tokens[0].type_no_sentperiod,\n                    tokens[1].type_no_sentperiod,\n                )\n                in self._params.collocations,\n                \"reason\": self._second_pass_annotation(tokens[0], tokens[1])\n                or REASON_DEFAULT_DECISION,\n                \"break_decision\": tokens[0].sentbreak,\n            }\n\n    def span_tokenize(self, text, realign_boundaries=True):\n        \"\"\"\n        Given a text, generates (start, end) spans of sentences\n        in the text.\n        \"\"\"\n        slices = self._slices_from_text(text)\n        if realign_boundaries:\n            slices = self._realign_boundaries(text, slices)\n        for sentence in slices:\n            yield (sentence.start, sentence.stop)\n\n    def sentences_from_text(self, text, realign_boundaries=True):\n        \"\"\"\n        Given a text, generates the sentences in that text by only\n        testing candidate sentence breaks. If realign_boundaries is\n        True, includes in the sentence closing punctuation that\n        follows the period.\n        \"\"\"\n        return [text[s:e] for s, e in self.span_tokenize(text, realign_boundaries)]\n\n    def _slices_from_text(self, text):\n        last_break = 0\n        for match in self._lang_vars.period_context_re().finditer(text):\n            context = match.group() + match.group(\"after_tok\")\n            if self.text_contains_sentbreak(context):\n                yield slice(last_break, match.end())\n                if match.group(\"next_tok\"):\n                    # next sentence starts after whitespace\n                    last_break = match.start(\"next_tok\")\n                else:\n                    # next sentence starts at following punctuation\n                    last_break = match.end()\n        # The last sentence should not contain trailing whitespace.\n        yield slice(last_break, len(text.rstrip()))\n\n    def _realign_boundaries(self, text, slices):\n        \"\"\"\n        Attempts to realign punctuation that falls after the period but\n        should otherwise be included in the same sentence.\n\n        For example: \"(Sent1.) Sent2.\" will otherwise be split as::\n\n            [\"(Sent1.\", \") Sent1.\"].\n\n        This method will produce::\n\n            [\"(Sent1.)\", \"Sent2.\"].\n        \"\"\"\n        realign = 0\n        for sentence1, sentence2 in _pair_iter(slices):\n            sentence1 = slice(sentence1.start + realign, sentence1.stop)\n            if not sentence2:\n                if text[sentence1]:\n                    yield sentence1\n                continue\n\n            m = self._lang_vars.re_boundary_realignment.match(text[sentence2])\n            if m:\n                yield slice(sentence1.start, sentence2.start + len(m.group(0).rstrip()))\n                realign = m.end()\n            else:\n                realign = 0\n                if text[sentence1]:\n                    yield sentence1\n\n    def text_contains_sentbreak(self, text):\n        \"\"\"\n        Returns True if the given text includes a sentence break.\n        \"\"\"\n        found = False  # used to ignore last token\n        for tok in self._annotate_tokens(self._tokenize_words(text)):\n            if found:\n                return True\n            if tok.sentbreak:\n                found = True\n        return False\n\n    def sentences_from_text_legacy(self, text):\n        \"\"\"\n        Given a text, generates the sentences in that text. Annotates all\n        tokens, rather than just those with possible sentence breaks. Should\n        produce the same results as ``sentences_from_text``.\n        \"\"\"\n        tokens = self._annotate_tokens(self._tokenize_words(text))\n        return self._build_sentence_list(text, tokens)\n\n    def sentences_from_tokens(self, tokens):\n        \"\"\"\n        Given a sequence of tokens, generates lists of tokens, each list\n        corresponding to a sentence.\n        \"\"\"\n        tokens = iter(self._annotate_tokens(self._Token(t) for t in tokens))\n        sentence = []\n        for aug_tok in tokens:\n            sentence.append(aug_tok.tok)\n            if aug_tok.sentbreak:\n                yield sentence\n                sentence = []\n        if sentence:\n            yield sentence\n\n    def _annotate_tokens(self, tokens):\n        \"\"\"\n        Given a set of tokens augmented with markers for line-start and\n        paragraph-start, returns an iterator through those tokens with full\n        annotation including predicted sentence breaks.\n        \"\"\"\n        # Make a preliminary pass through the document, marking likely\n        # sentence breaks, abbreviations, and ellipsis tokens.\n        tokens = self._annotate_first_pass(tokens)\n\n        # Make a second pass through the document, using token context\n        # information to change our preliminary decisions about where\n        # sentence breaks, abbreviations, and ellipsis occurs.\n        tokens = self._annotate_second_pass(tokens)\n\n        ## [XX] TESTING\n        # tokens = list(tokens)\n        # self.dump(tokens)\n\n        return tokens\n\n    def _build_sentence_list(self, text, tokens):\n        \"\"\"\n        Given the original text and the list of augmented word tokens,\n        construct and return a tokenized list of sentence strings.\n        \"\"\"\n        # Most of the work here is making sure that we put the right\n        # pieces of whitespace back in all the right places.\n\n        # Our position in the source text, used to keep track of which\n        # whitespace to add:\n        pos = 0\n\n        # A regular expression that finds pieces of whitespace:\n        white_space_regexp = re.compile(r\"\\s*\")\n\n        sentence = \"\"\n        for aug_tok in tokens:\n            tok = aug_tok.tok\n\n            # Find the whitespace before this token, and update pos.\n            white_space = white_space_regexp.match(text, pos).group()\n            pos += len(white_space)\n\n            # Some of the rules used by the punkt word tokenizer\n            # strip whitespace out of the text, resulting in tokens\n            # that contain whitespace in the source text.  If our\n            # token doesn't match, see if adding whitespace helps.\n            # If so, then use the version with whitespace.\n            if text[pos : pos + len(tok)] != tok:\n                pat = r\"\\s*\".join(re.escape(c) for c in tok)\n                m = re.compile(pat).match(text, pos)\n                if m:\n                    tok = m.group()\n\n            # Move our position pointer to the end of the token.\n            assert text[pos : pos + len(tok)] == tok\n            pos += len(tok)\n\n            # Add this token.  If it's not at the beginning of the\n            # sentence, then include any whitespace that separated it\n            # from the previous token.\n            if sentence:\n                sentence += white_space\n            sentence += tok\n\n            # If we're at a sentence break, then start a new sentence.\n            if aug_tok.sentbreak:\n                yield sentence\n                sentence = \"\"\n\n        # If the last sentence is empty, discard it.\n        if sentence:\n            yield sentence\n\n    # [XX] TESTING\n    def dump(self, tokens):\n        print(\"writing to /tmp/punkt.new...\")\n        with open(\"/tmp/punkt.new\", \"w\") as outfile:\n            for aug_tok in tokens:\n                if aug_tok.parastart:\n                    outfile.write(\"\\n\\n\")\n                elif aug_tok.linestart:\n                    outfile.write(\"\\n\")\n                else:\n                    outfile.write(\" \")\n\n                outfile.write(str(aug_tok))\n\n    # ////////////////////////////////////////////////////////////\n    # { Customization Variables\n    # ////////////////////////////////////////////////////////////\n\n    PUNCTUATION = tuple(\";:,.!?\")\n\n    # ////////////////////////////////////////////////////////////\n    # { Annotation Procedures\n    # ////////////////////////////////////////////////////////////\n\n    def _annotate_second_pass(self, tokens):\n        \"\"\"\n        Performs a token-based classification (section 4) over the given\n        tokens, making use of the orthographic heuristic (4.1.1), collocation\n        heuristic (4.1.2) and frequent sentence starter heuristic (4.1.3).\n        \"\"\"\n        for token1, token2 in _pair_iter(tokens):\n            self._second_pass_annotation(token1, token2)\n            yield token1\n\n    def _second_pass_annotation(self, aug_tok1, aug_tok2):\n        \"\"\"\n        Performs token-based classification over a pair of contiguous tokens\n        updating the first.\n        \"\"\"\n        # Is it the last token? We can't do anything then.\n        if not aug_tok2:\n            return\n\n        if not aug_tok1.period_final:\n            # We only care about words ending in periods.\n            return\n        typ = aug_tok1.type_no_period\n        next_typ = aug_tok2.type_no_sentperiod\n        tok_is_initial = aug_tok1.is_initial\n\n        # [4.1.2. Collocation Heuristic] If there's a\n        # collocation between the word before and after the\n        # period, then label tok as an abbreviation and NOT\n        # a sentence break. Note that collocations with\n        # frequent sentence starters as their second word are\n        # excluded in training.\n        if (typ, next_typ) in self._params.collocations:\n            aug_tok1.sentbreak = False\n            aug_tok1.abbr = True\n            return REASON_KNOWN_COLLOCATION\n\n        # [4.2. Token-Based Reclassification of Abbreviations] If\n        # the token is an abbreviation or an ellipsis, then decide\n        # whether we should *also* classify it as a sentbreak.\n        if (aug_tok1.abbr or aug_tok1.ellipsis) and (not tok_is_initial):\n            # [4.1.1. Orthographic Heuristic] Check if there's\n            # orthogrpahic evidence about whether the next word\n            # starts a sentence or not.\n            is_sent_starter = self._ortho_heuristic(aug_tok2)\n            if is_sent_starter == True:\n                aug_tok1.sentbreak = True\n                return REASON_ABBR_WITH_ORTHOGRAPHIC_HEURISTIC\n\n            # [4.1.3. Frequent Sentence Starter Heruistic] If the\n            # next word is capitalized, and is a member of the\n            # frequent-sentence-starters list, then label tok as a\n            # sentence break.\n            if aug_tok2.first_upper and next_typ in self._params.sent_starters:\n                aug_tok1.sentbreak = True\n                return REASON_ABBR_WITH_SENTENCE_STARTER\n\n        # [4.3. Token-Based Detection of Initials and Ordinals]\n        # Check if any initials or ordinals tokens that are marked\n        # as sentbreaks should be reclassified as abbreviations.\n        if tok_is_initial or typ == \"##number##\":\n\n            # [4.1.1. Orthographic Heuristic] Check if there's\n            # orthogrpahic evidence about whether the next word\n            # starts a sentence or not.\n            is_sent_starter = self._ortho_heuristic(aug_tok2)\n\n            if is_sent_starter == False:\n                aug_tok1.sentbreak = False\n                aug_tok1.abbr = True\n                if tok_is_initial:\n                    return REASON_INITIAL_WITH_ORTHOGRAPHIC_HEURISTIC\n                return REASON_NUMBER_WITH_ORTHOGRAPHIC_HEURISTIC\n\n            # Special heuristic for initials: if orthogrpahic\n            # heuristic is unknown, and next word is always\n            # capitalized, then mark as abbrev (eg: J. Bach).\n            if (\n                is_sent_starter == \"unknown\"\n                and tok_is_initial\n                and aug_tok2.first_upper\n                and not (self._params.ortho_context[next_typ] & _ORTHO_LC)\n            ):\n                aug_tok1.sentbreak = False\n                aug_tok1.abbr = True\n                return REASON_INITIAL_WITH_SPECIAL_ORTHOGRAPHIC_HEURISTIC\n\n        return\n\n    def _ortho_heuristic(self, aug_tok):\n        \"\"\"\n        Decide whether the given token is the first token in a sentence.\n        \"\"\"\n        # Sentences don't start with punctuation marks:\n        if aug_tok.tok in self.PUNCTUATION:\n            return False\n\n        ortho_context = self._params.ortho_context[aug_tok.type_no_sentperiod]\n\n        # If the word is capitalized, occurs at least once with a\n        # lower case first letter, and never occurs with an upper case\n        # first letter sentence-internally, then it's a sentence starter.\n        if (\n            aug_tok.first_upper\n            and (ortho_context & _ORTHO_LC)\n            and not (ortho_context & _ORTHO_MID_UC)\n        ):\n            return True\n\n        # If the word is lower case, and either (a) we've seen it used\n        # with upper case, or (b) we've never seen it used\n        # sentence-initially with lower case, then it's not a sentence\n        # starter.\n        if aug_tok.first_lower and (\n            (ortho_context & _ORTHO_UC) or not (ortho_context & _ORTHO_BEG_LC)\n        ):\n            return False\n\n        # Otherwise, we're not sure.\n        return \"unknown\"\n\n\nDEBUG_DECISION_FMT = \"\"\"Text: {text!r} (at offset {period_index})\nSentence break? {break_decision} ({reason})\nCollocation? {collocation}\n{type1!r}:\n    known abbreviation: {type1_in_abbrs}\n    is initial: {type1_is_initial}\n{type2!r}:\n    known sentence starter: {type2_is_sent_starter}\n    orthographic heuristic suggests is a sentence starter? {type2_ortho_heuristic}\n    orthographic contexts in training: {type2_ortho_contexts}\n\"\"\"\n\n\ndef format_debug_decision(d):\n    return DEBUG_DECISION_FMT.format(**d)\n\n\ndef demo(text, tok_cls=PunktSentenceTokenizer, train_cls=PunktTrainer):\n    \"\"\"Builds a punkt model and applies it to the same text\"\"\"\n    cleanup = (\n        lambda s: re.compile(r\"(?:\\r|^\\s+)\", re.MULTILINE).sub(\"\", s).replace(\"\\n\", \" \")\n    )\n    trainer = train_cls()\n    trainer.INCLUDE_ALL_COLLOCS = True\n    trainer.train(text)\n    sbd = tok_cls(trainer.get_params())\n    for sentence in sbd.sentences_from_text(text):\n        print(cleanup(sentence))\n"], "fixing_code": ["# Natural Language Toolkit: Punkt sentence tokenizer\n#\n# Copyright (C) 2001-2021 NLTK Project\n# Algorithm: Kiss & Strunk (2006)\n# Author: Willy <willy@csse.unimelb.edu.au> (original Python port)\n#         Steven Bird <stevenbird1@gmail.com> (additions)\n#         Edward Loper <edloper@gmail.com> (rewrite)\n#         Joel Nothman <jnothman@student.usyd.edu.au> (almost rewrite)\n#         Arthur Darcet <arthur@darcet.fr> (fixes)\n# URL: <https://www.nltk.org/>\n# For license information, see LICENSE.TXT\n\nr\"\"\"\nPunkt Sentence Tokenizer\n\nThis tokenizer divides a text into a list of sentences\nby using an unsupervised algorithm to build a model for abbreviation\nwords, collocations, and words that start sentences.  It must be\ntrained on a large collection of plaintext in the target language\nbefore it can be used.\n\nThe NLTK data package includes a pre-trained Punkt tokenizer for\nEnglish.\n\n    >>> import nltk.data\n    >>> text = '''\n    ... Punkt knows that the periods in Mr. Smith and Johann S. Bach\n    ... do not mark sentence boundaries.  And sometimes sentences\n    ... can start with non-capitalized words.  i is a good variable\n    ... name.\n    ... '''\n    >>> sent_detector = nltk.data.load('tokenizers/punkt/english.pickle')\n    >>> print('\\n-----\\n'.join(sent_detector.tokenize(text.strip())))\n    Punkt knows that the periods in Mr. Smith and Johann S. Bach\n    do not mark sentence boundaries.\n    -----\n    And sometimes sentences\n    can start with non-capitalized words.\n    -----\n    i is a good variable\n    name.\n\n(Note that whitespace from the original text, including newlines, is\nretained in the output.)\n\nPunctuation following sentences is also included by default\n(from NLTK 3.0 onwards). It can be excluded with the realign_boundaries\nflag.\n\n    >>> text = '''\n    ... (How does it deal with this parenthesis?)  \"It should be part of the\n    ... previous sentence.\" \"(And the same with this one.)\" ('And this one!')\n    ... \"('(And (this)) '?)\" [(and this. )]\n    ... '''\n    >>> print('\\n-----\\n'.join(\n    ...     sent_detector.tokenize(text.strip())))\n    (How does it deal with this parenthesis?)\n    -----\n    \"It should be part of the\n    previous sentence.\"\n    -----\n    \"(And the same with this one.)\"\n    -----\n    ('And this one!')\n    -----\n    \"('(And (this)) '?)\"\n    -----\n    [(and this. )]\n    >>> print('\\n-----\\n'.join(\n    ...     sent_detector.tokenize(text.strip(), realign_boundaries=False)))\n    (How does it deal with this parenthesis?\n    -----\n    )  \"It should be part of the\n    previous sentence.\n    -----\n    \" \"(And the same with this one.\n    -----\n    )\" ('And this one!\n    -----\n    ')\n    \"('(And (this)) '?\n    -----\n    )\" [(and this.\n    -----\n    )]\n\nHowever, Punkt is designed to learn parameters (a list of abbreviations, etc.)\nunsupervised from a corpus similar to the target domain. The pre-packaged models\nmay therefore be unsuitable: use ``PunktSentenceTokenizer(text)`` to learn\nparameters from the given text.\n\n:class:`.PunktTrainer` learns parameters such as a list of abbreviations\n(without supervision) from portions of text. Using a ``PunktTrainer`` directly\nallows for incremental training and modification of the hyper-parameters used\nto decide what is considered an abbreviation, etc.\n\nThe algorithm for this tokenizer is described in::\n\n  Kiss, Tibor and Strunk, Jan (2006): Unsupervised Multilingual Sentence\n    Boundary Detection.  Computational Linguistics 32: 485-525.\n\"\"\"\n\n# TODO: Make orthographic heuristic less susceptible to overtraining\n# TODO: Frequent sentence starters optionally exclude always-capitalised words\n# FIXME: Problem with ending string with e.g. '!!!' -> '!! !'\n\nimport math\nimport re\nfrom collections import defaultdict\n\nfrom nltk.probability import FreqDist\nfrom nltk.tokenize.api import TokenizerI\n\n######################################################################\n# { Orthographic Context Constants\n######################################################################\n# The following constants are used to describe the orthographic\n# contexts in which a word can occur.  BEG=beginning, MID=middle,\n# UNK=unknown, UC=uppercase, LC=lowercase, NC=no case.\n\n_ORTHO_BEG_UC = 1 << 1\n\"\"\"Orthographic context: beginning of a sentence with upper case.\"\"\"\n\n_ORTHO_MID_UC = 1 << 2\n\"\"\"Orthographic context: middle of a sentence with upper case.\"\"\"\n\n_ORTHO_UNK_UC = 1 << 3\n\"\"\"Orthographic context: unknown position in a sentence with upper case.\"\"\"\n\n_ORTHO_BEG_LC = 1 << 4\n\"\"\"Orthographic context: beginning of a sentence with lower case.\"\"\"\n\n_ORTHO_MID_LC = 1 << 5\n\"\"\"Orthographic context: middle of a sentence with lower case.\"\"\"\n\n_ORTHO_UNK_LC = 1 << 6\n\"\"\"Orthographic context: unknown position in a sentence with lower case.\"\"\"\n\n_ORTHO_UC = _ORTHO_BEG_UC + _ORTHO_MID_UC + _ORTHO_UNK_UC\n\"\"\"Orthographic context: occurs with upper case.\"\"\"\n\n_ORTHO_LC = _ORTHO_BEG_LC + _ORTHO_MID_LC + _ORTHO_UNK_LC\n\"\"\"Orthographic context: occurs with lower case.\"\"\"\n\n_ORTHO_MAP = {\n    (\"initial\", \"upper\"): _ORTHO_BEG_UC,\n    (\"internal\", \"upper\"): _ORTHO_MID_UC,\n    (\"unknown\", \"upper\"): _ORTHO_UNK_UC,\n    (\"initial\", \"lower\"): _ORTHO_BEG_LC,\n    (\"internal\", \"lower\"): _ORTHO_MID_LC,\n    (\"unknown\", \"lower\"): _ORTHO_UNK_LC,\n}\n\"\"\"A map from context position and first-letter case to the\nappropriate orthographic context flag.\"\"\"\n\n# } (end orthographic context constants)\n######################################################################\n\n######################################################################\n# { Decision reasons for debugging\n######################################################################\n\nREASON_DEFAULT_DECISION = \"default decision\"\nREASON_KNOWN_COLLOCATION = \"known collocation (both words)\"\nREASON_ABBR_WITH_ORTHOGRAPHIC_HEURISTIC = \"abbreviation + orthographic heuristic\"\nREASON_ABBR_WITH_SENTENCE_STARTER = \"abbreviation + frequent sentence starter\"\nREASON_INITIAL_WITH_ORTHOGRAPHIC_HEURISTIC = \"initial + orthographic heuristic\"\nREASON_NUMBER_WITH_ORTHOGRAPHIC_HEURISTIC = \"initial + orthographic heuristic\"\nREASON_INITIAL_WITH_SPECIAL_ORTHOGRAPHIC_HEURISTIC = (\n    \"initial + special orthographic heuristic\"\n)\n\n\n# } (end decision reasons for debugging)\n######################################################################\n\n######################################################################\n# { Language-dependent variables\n######################################################################\n\n\nclass PunktLanguageVars:\n    \"\"\"\n    Stores variables, mostly regular expressions, which may be\n    language-dependent for correct application of the algorithm.\n    An extension of this class may modify its properties to suit\n    a language other than English; an instance can then be passed\n    as an argument to PunktSentenceTokenizer and PunktTrainer\n    constructors.\n    \"\"\"\n\n    __slots__ = (\"_re_period_context\", \"_re_word_tokenizer\")\n\n    def __getstate__(self):\n        # All modifications to the class are performed by inheritance.\n        # Non-default parameters to be pickled must be defined in the inherited\n        # class.\n        return 1\n\n    def __setstate__(self, state):\n        return 1\n\n    sent_end_chars = (\".\", \"?\", \"!\")\n    \"\"\"Characters which are candidates for sentence boundaries\"\"\"\n\n    @property\n    def _re_sent_end_chars(self):\n        return \"[%s]\" % re.escape(\"\".join(self.sent_end_chars))\n\n    internal_punctuation = \",:;\"  # might want to extend this..\n    \"\"\"sentence internal punctuation, which indicates an abbreviation if\n    preceded by a period-final token.\"\"\"\n\n    re_boundary_realignment = re.compile(r'[\"\\')\\]}]+?(?:\\s+|(?=--)|$)', re.MULTILINE)\n    \"\"\"Used to realign punctuation that should be included in a sentence\n    although it follows the period (or ?, !).\"\"\"\n\n    _re_word_start = r\"[^\\(\\\"\\`{\\[:;&\\#\\*@\\)}\\]\\-,]\"\n    \"\"\"Excludes some characters from starting word tokens\"\"\"\n\n    @property\n    def _re_non_word_chars(self):\n        return r\"(?:[)\\\";}\\]\\*:@\\'\\({\\[%s])\" % re.escape(\n            \"\".join(set(self.sent_end_chars) - {\".\"})\n        )\n\n    \"\"\"Characters that cannot appear within words\"\"\"\n\n    _re_multi_char_punct = r\"(?:\\-{2,}|\\.{2,}|(?:\\.\\s){2,}\\.)\"\n    \"\"\"Hyphen and ellipsis are multi-character punctuation\"\"\"\n\n    _word_tokenize_fmt = r\"\"\"(\n        %(MultiChar)s\n        |\n        (?=%(WordStart)s)\\S+?  # Accept word characters until end is found\n        (?= # Sequences marking a word's end\n            \\s|                                 # White-space\n            $|                                  # End-of-string\n            %(NonWord)s|%(MultiChar)s|          # Punctuation\n            ,(?=$|\\s|%(NonWord)s|%(MultiChar)s) # Comma if at end of word\n        )\n        |\n        \\S\n    )\"\"\"\n    \"\"\"Format of a regular expression to split punctuation from words,\n    excluding period.\"\"\"\n\n    def _word_tokenizer_re(self):\n        \"\"\"Compiles and returns a regular expression for word tokenization\"\"\"\n        try:\n            return self._re_word_tokenizer\n        except AttributeError:\n            self._re_word_tokenizer = re.compile(\n                self._word_tokenize_fmt\n                % {\n                    \"NonWord\": self._re_non_word_chars,\n                    \"MultiChar\": self._re_multi_char_punct,\n                    \"WordStart\": self._re_word_start,\n                },\n                re.UNICODE | re.VERBOSE,\n            )\n            return self._re_word_tokenizer\n\n    def word_tokenize(self, s):\n        \"\"\"Tokenize a string to split off punctuation other than periods\"\"\"\n        return self._word_tokenizer_re().findall(s)\n\n    _period_context_fmt = r\"\"\"\n        %(SentEndChars)s             # a potential sentence ending\n        (?=(?P<after_tok>\n            %(NonWord)s              # either other punctuation\n            |\n            \\s+(?P<next_tok>\\S+)     # or whitespace and some other token\n        ))\"\"\"\n    \"\"\"Format of a regular expression to find contexts including possible\n    sentence boundaries. Matches token which the possible sentence boundary\n    ends, and matches the following token within a lookahead expression.\"\"\"\n\n    def period_context_re(self):\n        \"\"\"Compiles and returns a regular expression to find contexts\n        including possible sentence boundaries.\"\"\"\n        try:\n            return self._re_period_context\n        except:\n            self._re_period_context = re.compile(\n                self._period_context_fmt\n                % {\n                    \"NonWord\": self._re_non_word_chars,\n                    \"SentEndChars\": self._re_sent_end_chars,\n                },\n                re.UNICODE | re.VERBOSE,\n            )\n            return self._re_period_context\n\n\n_re_non_punct = re.compile(r\"[^\\W\\d]\", re.UNICODE)\n\"\"\"Matches token types that are not merely punctuation. (Types for\nnumeric tokens are changed to ##number## and hence contain alpha.)\"\"\"\n\n\n# }\n######################################################################\n\n\n# ////////////////////////////////////////////////////////////\n# { Helper Functions\n# ////////////////////////////////////////////////////////////\n\n\ndef _pair_iter(iterator):\n    \"\"\"\n    Yields pairs of tokens from the given iterator such that each input\n    token will appear as the first element in a yielded tuple. The last\n    pair will have None as its second element.\n    \"\"\"\n    iterator = iter(iterator)\n    try:\n        prev = next(iterator)\n    except StopIteration:\n        return\n    for el in iterator:\n        yield (prev, el)\n        prev = el\n    yield (prev, None)\n\n\n######################################################################\n# { Punkt Parameters\n######################################################################\n\n\nclass PunktParameters:\n    \"\"\"Stores data used to perform sentence boundary detection with Punkt.\"\"\"\n\n    def __init__(self):\n        self.abbrev_types = set()\n        \"\"\"A set of word types for known abbreviations.\"\"\"\n\n        self.collocations = set()\n        \"\"\"A set of word type tuples for known common collocations\n        where the first word ends in a period.  E.g., ('S.', 'Bach')\n        is a common collocation in a text that discusses 'Johann\n        S. Bach'.  These count as negative evidence for sentence\n        boundaries.\"\"\"\n\n        self.sent_starters = set()\n        \"\"\"A set of word types for words that often appear at the\n        beginning of sentences.\"\"\"\n\n        self.ortho_context = defaultdict(int)\n        \"\"\"A dictionary mapping word types to the set of orthographic\n        contexts that word type appears in.  Contexts are represented\n        by adding orthographic context flags: ...\"\"\"\n\n    def clear_abbrevs(self):\n        self.abbrev_types = set()\n\n    def clear_collocations(self):\n        self.collocations = set()\n\n    def clear_sent_starters(self):\n        self.sent_starters = set()\n\n    def clear_ortho_context(self):\n        self.ortho_context = defaultdict(int)\n\n    def add_ortho_context(self, typ, flag):\n        self.ortho_context[typ] |= flag\n\n    def _debug_ortho_context(self, typ):\n        context = self.ortho_context[typ]\n        if context & _ORTHO_BEG_UC:\n            yield \"BEG-UC\"\n        if context & _ORTHO_MID_UC:\n            yield \"MID-UC\"\n        if context & _ORTHO_UNK_UC:\n            yield \"UNK-UC\"\n        if context & _ORTHO_BEG_LC:\n            yield \"BEG-LC\"\n        if context & _ORTHO_MID_LC:\n            yield \"MID-LC\"\n        if context & _ORTHO_UNK_LC:\n            yield \"UNK-LC\"\n\n\n######################################################################\n# { PunktToken\n######################################################################\n\n\nclass PunktToken:\n    \"\"\"Stores a token of text with annotations produced during\n    sentence boundary detection.\"\"\"\n\n    _properties = [\"parastart\", \"linestart\", \"sentbreak\", \"abbr\", \"ellipsis\"]\n    __slots__ = [\"tok\", \"type\", \"period_final\"] + _properties\n\n    def __init__(self, tok, **params):\n        self.tok = tok\n        self.type = self._get_type(tok)\n        self.period_final = tok.endswith(\".\")\n\n        for prop in self._properties:\n            setattr(self, prop, None)\n        for k in params:\n            setattr(self, k, params[k])\n\n    # ////////////////////////////////////////////////////////////\n    # { Regular expressions for properties\n    # ////////////////////////////////////////////////////////////\n    # Note: [A-Za-z] is approximated by [^\\W\\d] in the general case.\n    _RE_ELLIPSIS = re.compile(r\"\\.\\.+$\")\n    _RE_NUMERIC = re.compile(r\"^-?[\\.,]?\\d[\\d,\\.-]*\\.?$\")\n    _RE_INITIAL = re.compile(r\"[^\\W\\d]\\.$\", re.UNICODE)\n    _RE_ALPHA = re.compile(r\"[^\\W\\d]+$\", re.UNICODE)\n\n    # ////////////////////////////////////////////////////////////\n    # { Derived properties\n    # ////////////////////////////////////////////////////////////\n\n    def _get_type(self, tok):\n        \"\"\"Returns a case-normalized representation of the token.\"\"\"\n        return self._RE_NUMERIC.sub(\"##number##\", tok.lower())\n\n    @property\n    def type_no_period(self):\n        \"\"\"\n        The type with its final period removed if it has one.\n        \"\"\"\n        if len(self.type) > 1 and self.type[-1] == \".\":\n            return self.type[:-1]\n        return self.type\n\n    @property\n    def type_no_sentperiod(self):\n        \"\"\"\n        The type with its final period removed if it is marked as a\n        sentence break.\n        \"\"\"\n        if self.sentbreak:\n            return self.type_no_period\n        return self.type\n\n    @property\n    def first_upper(self):\n        \"\"\"True if the token's first character is uppercase.\"\"\"\n        return self.tok[0].isupper()\n\n    @property\n    def first_lower(self):\n        \"\"\"True if the token's first character is lowercase.\"\"\"\n        return self.tok[0].islower()\n\n    @property\n    def first_case(self):\n        if self.first_lower:\n            return \"lower\"\n        if self.first_upper:\n            return \"upper\"\n        return \"none\"\n\n    @property\n    def is_ellipsis(self):\n        \"\"\"True if the token text is that of an ellipsis.\"\"\"\n        return self._RE_ELLIPSIS.match(self.tok)\n\n    @property\n    def is_number(self):\n        \"\"\"True if the token text is that of a number.\"\"\"\n        return self.type.startswith(\"##number##\")\n\n    @property\n    def is_initial(self):\n        \"\"\"True if the token text is that of an initial.\"\"\"\n        return self._RE_INITIAL.match(self.tok)\n\n    @property\n    def is_alpha(self):\n        \"\"\"True if the token text is all alphabetic.\"\"\"\n        return self._RE_ALPHA.match(self.tok)\n\n    @property\n    def is_non_punct(self):\n        \"\"\"True if the token is either a number or is alphabetic.\"\"\"\n        return _re_non_punct.search(self.type)\n\n    # ////////////////////////////////////////////////////////////\n    # { String representation\n    # ////////////////////////////////////////////////////////////\n\n    def __repr__(self):\n        \"\"\"\n        A string representation of the token that can reproduce it\n        with eval(), which lists all the token's non-default\n        annotations.\n        \"\"\"\n        typestr = \" type=%s,\" % repr(self.type) if self.type != self.tok else \"\"\n\n        propvals = \", \".join(\n            f\"{p}={repr(getattr(self, p))}\"\n            for p in self._properties\n            if getattr(self, p)\n        )\n\n        return \"{}({},{} {})\".format(\n            self.__class__.__name__,\n            repr(self.tok),\n            typestr,\n            propvals,\n        )\n\n    def __str__(self):\n        \"\"\"\n        A string representation akin to that used by Kiss and Strunk.\n        \"\"\"\n        res = self.tok\n        if self.abbr:\n            res += \"<A>\"\n        if self.ellipsis:\n            res += \"<E>\"\n        if self.sentbreak:\n            res += \"<S>\"\n        return res\n\n\n######################################################################\n# { Punkt base class\n######################################################################\n\n\nclass PunktBaseClass:\n    \"\"\"\n    Includes common components of PunktTrainer and PunktSentenceTokenizer.\n    \"\"\"\n\n    def __init__(self, lang_vars=None, token_cls=PunktToken, params=None):\n        if lang_vars is None:\n            lang_vars = PunktLanguageVars()\n        if params is None:\n            params = PunktParameters()\n        self._params = params\n        self._lang_vars = lang_vars\n        self._Token = token_cls\n        \"\"\"The collection of parameters that determines the behavior\n        of the punkt tokenizer.\"\"\"\n\n    # ////////////////////////////////////////////////////////////\n    # { Word tokenization\n    # ////////////////////////////////////////////////////////////\n\n    def _tokenize_words(self, plaintext):\n        \"\"\"\n        Divide the given text into tokens, using the punkt word\n        segmentation regular expression, and generate the resulting list\n        of tokens augmented as three-tuples with two boolean values for whether\n        the given token occurs at the start of a paragraph or a new line,\n        respectively.\n        \"\"\"\n        parastart = False\n        for line in plaintext.split(\"\\n\"):\n            if line.strip():\n                line_toks = iter(self._lang_vars.word_tokenize(line))\n\n                try:\n                    tok = next(line_toks)\n                except StopIteration:\n                    continue\n\n                yield self._Token(tok, parastart=parastart, linestart=True)\n                parastart = False\n\n                for tok in line_toks:\n                    yield self._Token(tok)\n            else:\n                parastart = True\n\n    # ////////////////////////////////////////////////////////////\n    # { Annotation Procedures\n    # ////////////////////////////////////////////////////////////\n\n    def _annotate_first_pass(self, tokens):\n        \"\"\"\n        Perform the first pass of annotation, which makes decisions\n        based purely based on the word type of each word:\n\n          - '?', '!', and '.' are marked as sentence breaks.\n          - sequences of two or more periods are marked as ellipsis.\n          - any word ending in '.' that's a known abbreviation is\n            marked as an abbreviation.\n          - any other word ending in '.' is marked as a sentence break.\n\n        Return these annotations as a tuple of three sets:\n\n          - sentbreak_toks: The indices of all sentence breaks.\n          - abbrev_toks: The indices of all abbreviations.\n          - ellipsis_toks: The indices of all ellipsis marks.\n        \"\"\"\n        for aug_tok in tokens:\n            self._first_pass_annotation(aug_tok)\n            yield aug_tok\n\n    def _first_pass_annotation(self, aug_tok):\n        \"\"\"\n        Performs type-based annotation on a single token.\n        \"\"\"\n\n        tok = aug_tok.tok\n\n        if tok in self._lang_vars.sent_end_chars:\n            aug_tok.sentbreak = True\n        elif aug_tok.is_ellipsis:\n            aug_tok.ellipsis = True\n        elif aug_tok.period_final and not tok.endswith(\"..\"):\n            if (\n                tok[:-1].lower() in self._params.abbrev_types\n                or tok[:-1].lower().split(\"-\")[-1] in self._params.abbrev_types\n            ):\n\n                aug_tok.abbr = True\n            else:\n                aug_tok.sentbreak = True\n\n        return\n\n\n######################################################################\n# { Punkt Trainer\n######################################################################\n\n\nclass PunktTrainer(PunktBaseClass):\n    \"\"\"Learns parameters used in Punkt sentence boundary detection.\"\"\"\n\n    def __init__(\n        self, train_text=None, verbose=False, lang_vars=None, token_cls=PunktToken\n    ):\n\n        PunktBaseClass.__init__(self, lang_vars=lang_vars, token_cls=token_cls)\n\n        self._type_fdist = FreqDist()\n        \"\"\"A frequency distribution giving the frequency of each\n        case-normalized token type in the training data.\"\"\"\n\n        self._num_period_toks = 0\n        \"\"\"The number of words ending in period in the training data.\"\"\"\n\n        self._collocation_fdist = FreqDist()\n        \"\"\"A frequency distribution giving the frequency of all\n        bigrams in the training data where the first word ends in a\n        period.  Bigrams are encoded as tuples of word types.\n        Especially common collocations are extracted from this\n        frequency distribution, and stored in\n        ``_params``.``collocations <PunktParameters.collocations>``.\"\"\"\n\n        self._sent_starter_fdist = FreqDist()\n        \"\"\"A frequency distribution giving the frequency of all words\n        that occur at the training data at the beginning of a sentence\n        (after the first pass of annotation).  Especially common\n        sentence starters are extracted from this frequency\n        distribution, and stored in ``_params.sent_starters``.\n        \"\"\"\n\n        self._sentbreak_count = 0\n        \"\"\"The total number of sentence breaks identified in training, used for\n        calculating the frequent sentence starter heuristic.\"\"\"\n\n        self._finalized = True\n        \"\"\"A flag as to whether the training has been finalized by finding\n        collocations and sentence starters, or whether finalize_training()\n        still needs to be called.\"\"\"\n\n        if train_text:\n            self.train(train_text, verbose, finalize=True)\n\n    def get_params(self):\n        \"\"\"\n        Calculates and returns parameters for sentence boundary detection as\n        derived from training.\"\"\"\n        if not self._finalized:\n            self.finalize_training()\n        return self._params\n\n    # ////////////////////////////////////////////////////////////\n    # { Customization Variables\n    # ////////////////////////////////////////////////////////////\n\n    ABBREV = 0.3\n    \"\"\"cut-off value whether a 'token' is an abbreviation\"\"\"\n\n    IGNORE_ABBREV_PENALTY = False\n    \"\"\"allows the disabling of the abbreviation penalty heuristic, which\n    exponentially disadvantages words that are found at times without a\n    final period.\"\"\"\n\n    ABBREV_BACKOFF = 5\n    \"\"\"upper cut-off for Mikheev's(2002) abbreviation detection algorithm\"\"\"\n\n    COLLOCATION = 7.88\n    \"\"\"minimal log-likelihood value that two tokens need to be considered\n    as a collocation\"\"\"\n\n    SENT_STARTER = 30\n    \"\"\"minimal log-likelihood value that a token requires to be considered\n    as a frequent sentence starter\"\"\"\n\n    INCLUDE_ALL_COLLOCS = False\n    \"\"\"this includes as potential collocations all word pairs where the first\n    word ends in a period. It may be useful in corpora where there is a lot\n    of variation that makes abbreviations like Mr difficult to identify.\"\"\"\n\n    INCLUDE_ABBREV_COLLOCS = False\n    \"\"\"this includes as potential collocations all word pairs where the first\n    word is an abbreviation. Such collocations override the orthographic\n    heuristic, but not the sentence starter heuristic. This is overridden by\n    INCLUDE_ALL_COLLOCS, and if both are false, only collocations with initials\n    and ordinals are considered.\"\"\"\n    \"\"\"\"\"\"\n\n    MIN_COLLOC_FREQ = 1\n    \"\"\"this sets a minimum bound on the number of times a bigram needs to\n    appear before it can be considered a collocation, in addition to log\n    likelihood statistics. This is useful when INCLUDE_ALL_COLLOCS is True.\"\"\"\n\n    # ////////////////////////////////////////////////////////////\n    # { Training..\n    # ////////////////////////////////////////////////////////////\n\n    def train(self, text, verbose=False, finalize=True):\n        \"\"\"\n        Collects training data from a given text. If finalize is True, it\n        will determine all the parameters for sentence boundary detection. If\n        not, this will be delayed until get_params() or finalize_training() is\n        called. If verbose is True, abbreviations found will be listed.\n        \"\"\"\n        # Break the text into tokens; record which token indices correspond to\n        # line starts and paragraph starts; and determine their types.\n        self._train_tokens(self._tokenize_words(text), verbose)\n        if finalize:\n            self.finalize_training(verbose)\n\n    def train_tokens(self, tokens, verbose=False, finalize=True):\n        \"\"\"\n        Collects training data from a given list of tokens.\n        \"\"\"\n        self._train_tokens((self._Token(t) for t in tokens), verbose)\n        if finalize:\n            self.finalize_training(verbose)\n\n    def _train_tokens(self, tokens, verbose):\n        self._finalized = False\n\n        # Ensure tokens are a list\n        tokens = list(tokens)\n\n        # Find the frequency of each case-normalized type.  (Don't\n        # strip off final periods.)  Also keep track of the number of\n        # tokens that end in periods.\n        for aug_tok in tokens:\n            self._type_fdist[aug_tok.type] += 1\n            if aug_tok.period_final:\n                self._num_period_toks += 1\n\n        # Look for new abbreviations, and for types that no longer are\n        unique_types = self._unique_types(tokens)\n        for abbr, score, is_add in self._reclassify_abbrev_types(unique_types):\n            if score >= self.ABBREV:\n                if is_add:\n                    self._params.abbrev_types.add(abbr)\n                    if verbose:\n                        print(f\"  Abbreviation: [{score:6.4f}] {abbr}\")\n            else:\n                if not is_add:\n                    self._params.abbrev_types.remove(abbr)\n                    if verbose:\n                        print(f\"  Removed abbreviation: [{score:6.4f}] {abbr}\")\n\n        # Make a preliminary pass through the document, marking likely\n        # sentence breaks, abbreviations, and ellipsis tokens.\n        tokens = list(self._annotate_first_pass(tokens))\n\n        # Check what contexts each word type can appear in, given the\n        # case of its first letter.\n        self._get_orthography_data(tokens)\n\n        # We need total number of sentence breaks to find sentence starters\n        self._sentbreak_count += self._get_sentbreak_count(tokens)\n\n        # The remaining heuristics relate to pairs of tokens where the first\n        # ends in a period.\n        for aug_tok1, aug_tok2 in _pair_iter(tokens):\n            if not aug_tok1.period_final or not aug_tok2:\n                continue\n\n            # Is the first token a rare abbreviation?\n            if self._is_rare_abbrev_type(aug_tok1, aug_tok2):\n                self._params.abbrev_types.add(aug_tok1.type_no_period)\n                if verbose:\n                    print(\"  Rare Abbrev: %s\" % aug_tok1.type)\n\n            # Does second token have a high likelihood of starting a sentence?\n            if self._is_potential_sent_starter(aug_tok2, aug_tok1):\n                self._sent_starter_fdist[aug_tok2.type] += 1\n\n            # Is this bigram a potential collocation?\n            if self._is_potential_collocation(aug_tok1, aug_tok2):\n                self._collocation_fdist[\n                    (aug_tok1.type_no_period, aug_tok2.type_no_sentperiod)\n                ] += 1\n\n    def _unique_types(self, tokens):\n        return {aug_tok.type for aug_tok in tokens}\n\n    def finalize_training(self, verbose=False):\n        \"\"\"\n        Uses data that has been gathered in training to determine likely\n        collocations and sentence starters.\n        \"\"\"\n        self._params.clear_sent_starters()\n        for typ, log_likelihood in self._find_sent_starters():\n            self._params.sent_starters.add(typ)\n            if verbose:\n                print(f\"  Sent Starter: [{log_likelihood:6.4f}] {typ!r}\")\n\n        self._params.clear_collocations()\n        for (typ1, typ2), log_likelihood in self._find_collocations():\n            self._params.collocations.add((typ1, typ2))\n            if verbose:\n                print(f\"  Collocation: [{log_likelihood:6.4f}] {typ1!r}+{typ2!r}\")\n\n        self._finalized = True\n\n    # ////////////////////////////////////////////////////////////\n    # { Overhead reduction\n    # ////////////////////////////////////////////////////////////\n\n    def freq_threshold(\n        self, ortho_thresh=2, type_thresh=2, colloc_thres=2, sentstart_thresh=2\n    ):\n        \"\"\"\n        Allows memory use to be reduced after much training by removing data\n        about rare tokens that are unlikely to have a statistical effect with\n        further training. Entries occurring above the given thresholds will be\n        retained.\n        \"\"\"\n        if ortho_thresh > 1:\n            old_oc = self._params.ortho_context\n            self._params.clear_ortho_context()\n            for tok in self._type_fdist:\n                count = self._type_fdist[tok]\n                if count >= ortho_thresh:\n                    self._params.ortho_context[tok] = old_oc[tok]\n\n        self._type_fdist = self._freq_threshold(self._type_fdist, type_thresh)\n        self._collocation_fdist = self._freq_threshold(\n            self._collocation_fdist, colloc_thres\n        )\n        self._sent_starter_fdist = self._freq_threshold(\n            self._sent_starter_fdist, sentstart_thresh\n        )\n\n    def _freq_threshold(self, fdist, threshold):\n        \"\"\"\n        Returns a FreqDist containing only data with counts below a given\n        threshold, as well as a mapping (None -> count_removed).\n        \"\"\"\n        # We assume that there is more data below the threshold than above it\n        # and so create a new FreqDist rather than working in place.\n        res = FreqDist()\n        num_removed = 0\n        for tok in fdist:\n            count = fdist[tok]\n            if count < threshold:\n                num_removed += 1\n            else:\n                res[tok] += count\n        res[None] += num_removed\n        return res\n\n    # ////////////////////////////////////////////////////////////\n    # { Orthographic data\n    # ////////////////////////////////////////////////////////////\n\n    def _get_orthography_data(self, tokens):\n        \"\"\"\n        Collect information about whether each token type occurs\n        with different case patterns (i) overall, (ii) at\n        sentence-initial positions, and (iii) at sentence-internal\n        positions.\n        \"\"\"\n        # 'initial' or 'internal' or 'unknown'\n        context = \"internal\"\n        tokens = list(tokens)\n\n        for aug_tok in tokens:\n            # If we encounter a paragraph break, then it's a good sign\n            # that it's a sentence break.  But err on the side of\n            # caution (by not positing a sentence break) if we just\n            # saw an abbreviation.\n            if aug_tok.parastart and context != \"unknown\":\n                context = \"initial\"\n\n            # If we're at the beginning of a line, then we can't decide\n            # between 'internal' and 'initial'.\n            if aug_tok.linestart and context == \"internal\":\n                context = \"unknown\"\n\n            # Find the case-normalized type of the token.  If it's a\n            # sentence-final token, strip off the period.\n            typ = aug_tok.type_no_sentperiod\n\n            # Update the orthographic context table.\n            flag = _ORTHO_MAP.get((context, aug_tok.first_case), 0)\n            if flag:\n                self._params.add_ortho_context(typ, flag)\n\n            # Decide whether the next word is at a sentence boundary.\n            if aug_tok.sentbreak:\n                if not (aug_tok.is_number or aug_tok.is_initial):\n                    context = \"initial\"\n                else:\n                    context = \"unknown\"\n            elif aug_tok.ellipsis or aug_tok.abbr:\n                context = \"unknown\"\n            else:\n                context = \"internal\"\n\n    # ////////////////////////////////////////////////////////////\n    # { Abbreviations\n    # ////////////////////////////////////////////////////////////\n\n    def _reclassify_abbrev_types(self, types):\n        \"\"\"\n        (Re)classifies each given token if\n          - it is period-final and not a known abbreviation; or\n          - it is not period-final and is otherwise a known abbreviation\n        by checking whether its previous classification still holds according\n        to the heuristics of section 3.\n        Yields triples (abbr, score, is_add) where abbr is the type in question,\n        score is its log-likelihood with penalties applied, and is_add specifies\n        whether the present type is a candidate for inclusion or exclusion as an\n        abbreviation, such that:\n          - (is_add and score >= 0.3)    suggests a new abbreviation; and\n          - (not is_add and score < 0.3) suggests excluding an abbreviation.\n        \"\"\"\n        # (While one could recalculate abbreviations from all .-final tokens at\n        # every iteration, in cases requiring efficiency, the number of tokens\n        # in the present training document will be much less.)\n\n        for typ in types:\n            # Check some basic conditions, to rule out words that are\n            # clearly not abbrev_types.\n            if not _re_non_punct.search(typ) or typ == \"##number##\":\n                continue\n\n            if typ.endswith(\".\"):\n                if typ in self._params.abbrev_types:\n                    continue\n                typ = typ[:-1]\n                is_add = True\n            else:\n                if typ not in self._params.abbrev_types:\n                    continue\n                is_add = False\n\n            # Count how many periods & nonperiods are in the\n            # candidate.\n            num_periods = typ.count(\".\") + 1\n            num_nonperiods = len(typ) - num_periods + 1\n\n            # Let <a> be the candidate without the period, and <b>\n            # be the period.  Find a log likelihood ratio that\n            # indicates whether <ab> occurs as a single unit (high\n            # value of log_likelihood), or as two independent units <a> and\n            # <b> (low value of log_likelihood).\n            count_with_period = self._type_fdist[typ + \".\"]\n            count_without_period = self._type_fdist[typ]\n            log_likelihood = self._dunning_log_likelihood(\n                count_with_period + count_without_period,\n                self._num_period_toks,\n                count_with_period,\n                self._type_fdist.N(),\n            )\n\n            # Apply three scaling factors to 'tweak' the basic log\n            # likelihood ratio:\n            #   F_length: long word -> less likely to be an abbrev\n            #   F_periods: more periods -> more likely to be an abbrev\n            #   F_penalty: penalize occurrences w/o a period\n            f_length = math.exp(-num_nonperiods)\n            f_periods = num_periods\n            f_penalty = int(self.IGNORE_ABBREV_PENALTY) or math.pow(\n                num_nonperiods, -count_without_period\n            )\n            score = log_likelihood * f_length * f_periods * f_penalty\n\n            yield typ, score, is_add\n\n    def find_abbrev_types(self):\n        \"\"\"\n        Recalculates abbreviations given type frequencies, despite no prior\n        determination of abbreviations.\n        This fails to include abbreviations otherwise found as \"rare\".\n        \"\"\"\n        self._params.clear_abbrevs()\n        tokens = (typ for typ in self._type_fdist if typ and typ.endswith(\".\"))\n        for abbr, score, _is_add in self._reclassify_abbrev_types(tokens):\n            if score >= self.ABBREV:\n                self._params.abbrev_types.add(abbr)\n\n    # This function combines the work done by the original code's\n    # functions `count_orthography_context`, `get_orthography_count`,\n    # and `get_rare_abbreviations`.\n    def _is_rare_abbrev_type(self, cur_tok, next_tok):\n        \"\"\"\n        A word type is counted as a rare abbreviation if...\n          - it's not already marked as an abbreviation\n          - it occurs fewer than ABBREV_BACKOFF times\n          - either it is followed by a sentence-internal punctuation\n            mark, *or* it is followed by a lower-case word that\n            sometimes appears with upper case, but never occurs with\n            lower case at the beginning of sentences.\n        \"\"\"\n        if cur_tok.abbr or not cur_tok.sentbreak:\n            return False\n\n        # Find the case-normalized type of the token.  If it's\n        # a sentence-final token, strip off the period.\n        typ = cur_tok.type_no_sentperiod\n\n        # Proceed only if the type hasn't been categorized as an\n        # abbreviation already, and is sufficiently rare...\n        count = self._type_fdist[typ] + self._type_fdist[typ[:-1]]\n        if typ in self._params.abbrev_types or count >= self.ABBREV_BACKOFF:\n            return False\n\n        # Record this token as an abbreviation if the next\n        # token is a sentence-internal punctuation mark.\n        # [XX] :1 or check the whole thing??\n        if next_tok.tok[:1] in self._lang_vars.internal_punctuation:\n            return True\n\n        # Record this type as an abbreviation if the next\n        # token...  (i) starts with a lower case letter,\n        # (ii) sometimes occurs with an uppercase letter,\n        # and (iii) never occus with an uppercase letter\n        # sentence-internally.\n        # [xx] should the check for (ii) be modified??\n        if next_tok.first_lower:\n            typ2 = next_tok.type_no_sentperiod\n            typ2ortho_context = self._params.ortho_context[typ2]\n            if (typ2ortho_context & _ORTHO_BEG_UC) and not (\n                typ2ortho_context & _ORTHO_MID_UC\n            ):\n                return True\n\n    # ////////////////////////////////////////////////////////////\n    # { Log Likelihoods\n    # ////////////////////////////////////////////////////////////\n\n    # helper for _reclassify_abbrev_types:\n    @staticmethod\n    def _dunning_log_likelihood(count_a, count_b, count_ab, N):\n        \"\"\"\n        A function that calculates the modified Dunning log-likelihood\n        ratio scores for abbreviation candidates.  The details of how\n        this works is available in the paper.\n        \"\"\"\n        p1 = count_b / N\n        p2 = 0.99\n\n        null_hypo = count_ab * math.log(p1) + (count_a - count_ab) * math.log(1.0 - p1)\n        alt_hypo = count_ab * math.log(p2) + (count_a - count_ab) * math.log(1.0 - p2)\n\n        likelihood = null_hypo - alt_hypo\n\n        return -2.0 * likelihood\n\n    @staticmethod\n    def _col_log_likelihood(count_a, count_b, count_ab, N):\n        \"\"\"\n        A function that will just compute log-likelihood estimate, in\n        the original paper it's described in algorithm 6 and 7.\n\n        This *should* be the original Dunning log-likelihood values,\n        unlike the previous log_l function where it used modified\n        Dunning log-likelihood values\n        \"\"\"\n        p = count_b / N\n        p1 = count_ab / count_a\n        try:\n            p2 = (count_b - count_ab) / (N - count_a)\n        except ZeroDivisionError:\n            p2 = 1\n\n        try:\n            summand1 = count_ab * math.log(p) + (count_a - count_ab) * math.log(1.0 - p)\n        except ValueError:\n            summand1 = 0\n\n        try:\n            summand2 = (count_b - count_ab) * math.log(p) + (\n                N - count_a - count_b + count_ab\n            ) * math.log(1.0 - p)\n        except ValueError:\n            summand2 = 0\n\n        if count_a == count_ab or p1 <= 0 or p1 >= 1:\n            summand3 = 0\n        else:\n            summand3 = count_ab * math.log(p1) + (count_a - count_ab) * math.log(\n                1.0 - p1\n            )\n\n        if count_b == count_ab or p2 <= 0 or p2 >= 1:\n            summand4 = 0\n        else:\n            summand4 = (count_b - count_ab) * math.log(p2) + (\n                N - count_a - count_b + count_ab\n            ) * math.log(1.0 - p2)\n\n        likelihood = summand1 + summand2 - summand3 - summand4\n\n        return -2.0 * likelihood\n\n    # ////////////////////////////////////////////////////////////\n    # { Collocation Finder\n    # ////////////////////////////////////////////////////////////\n\n    def _is_potential_collocation(self, aug_tok1, aug_tok2):\n        \"\"\"\n        Returns True if the pair of tokens may form a collocation given\n        log-likelihood statistics.\n        \"\"\"\n        return (\n            (\n                self.INCLUDE_ALL_COLLOCS\n                or (self.INCLUDE_ABBREV_COLLOCS and aug_tok1.abbr)\n                or (aug_tok1.sentbreak and (aug_tok1.is_number or aug_tok1.is_initial))\n            )\n            and aug_tok1.is_non_punct\n            and aug_tok2.is_non_punct\n        )\n\n    def _find_collocations(self):\n        \"\"\"\n        Generates likely collocations and their log-likelihood.\n        \"\"\"\n        for types in self._collocation_fdist:\n            try:\n                typ1, typ2 = types\n            except TypeError:\n                # types may be None after calling freq_threshold()\n                continue\n            if typ2 in self._params.sent_starters:\n                continue\n\n            col_count = self._collocation_fdist[types]\n            typ1_count = self._type_fdist[typ1] + self._type_fdist[typ1 + \".\"]\n            typ2_count = self._type_fdist[typ2] + self._type_fdist[typ2 + \".\"]\n            if (\n                typ1_count > 1\n                and typ2_count > 1\n                and self.MIN_COLLOC_FREQ < col_count <= min(typ1_count, typ2_count)\n            ):\n\n                log_likelihood = self._col_log_likelihood(\n                    typ1_count, typ2_count, col_count, self._type_fdist.N()\n                )\n                # Filter out the not-so-collocative\n                if log_likelihood >= self.COLLOCATION and (\n                    self._type_fdist.N() / typ1_count > typ2_count / col_count\n                ):\n                    yield (typ1, typ2), log_likelihood\n\n    # ////////////////////////////////////////////////////////////\n    # { Sentence-Starter Finder\n    # ////////////////////////////////////////////////////////////\n\n    def _is_potential_sent_starter(self, cur_tok, prev_tok):\n        \"\"\"\n        Returns True given a token and the token that precedes it if it\n        seems clear that the token is beginning a sentence.\n        \"\"\"\n        # If a token (i) is preceded by a sentece break that is\n        # not a potential ordinal number or initial, and (ii) is\n        # alphabetic, then it is a a sentence-starter.\n        return (\n            prev_tok.sentbreak\n            and not (prev_tok.is_number or prev_tok.is_initial)\n            and cur_tok.is_alpha\n        )\n\n    def _find_sent_starters(self):\n        \"\"\"\n        Uses collocation heuristics for each candidate token to\n        determine if it frequently starts sentences.\n        \"\"\"\n        for typ in self._sent_starter_fdist:\n            if not typ:\n                continue\n\n            typ_at_break_count = self._sent_starter_fdist[typ]\n            typ_count = self._type_fdist[typ] + self._type_fdist[typ + \".\"]\n            if typ_count < typ_at_break_count:\n                # needed after freq_threshold\n                continue\n\n            log_likelihood = self._col_log_likelihood(\n                self._sentbreak_count,\n                typ_count,\n                typ_at_break_count,\n                self._type_fdist.N(),\n            )\n\n            if (\n                log_likelihood >= self.SENT_STARTER\n                and self._type_fdist.N() / self._sentbreak_count\n                > typ_count / typ_at_break_count\n            ):\n                yield typ, log_likelihood\n\n    def _get_sentbreak_count(self, tokens):\n        \"\"\"\n        Returns the number of sentence breaks marked in a given set of\n        augmented tokens.\n        \"\"\"\n        return sum(1 for aug_tok in tokens if aug_tok.sentbreak)\n\n\n######################################################################\n# { Punkt Sentence Tokenizer\n######################################################################\n\n\nclass PunktSentenceTokenizer(PunktBaseClass, TokenizerI):\n    \"\"\"\n    A sentence tokenizer which uses an unsupervised algorithm to build\n    a model for abbreviation words, collocations, and words that start\n    sentences; and then uses that model to find sentence boundaries.\n    This approach has been shown to work well for many European\n    languages.\n    \"\"\"\n\n    def __init__(\n        self, train_text=None, verbose=False, lang_vars=None, token_cls=PunktToken\n    ):\n        \"\"\"\n        train_text can either be the sole training text for this sentence\n        boundary detector, or can be a PunktParameters object.\n        \"\"\"\n        PunktBaseClass.__init__(self, lang_vars=lang_vars, token_cls=token_cls)\n\n        if train_text:\n            self._params = self.train(train_text, verbose)\n\n    def train(self, train_text, verbose=False):\n        \"\"\"\n        Derives parameters from a given training text, or uses the parameters\n        given. Repeated calls to this method destroy previous parameters. For\n        incremental training, instantiate a separate PunktTrainer instance.\n        \"\"\"\n        if not isinstance(train_text, str):\n            return train_text\n        return PunktTrainer(\n            train_text, lang_vars=self._lang_vars, token_cls=self._Token\n        ).get_params()\n\n    # ////////////////////////////////////////////////////////////\n    # { Tokenization\n    # ////////////////////////////////////////////////////////////\n\n    def tokenize(self, text, realign_boundaries=True):\n        \"\"\"\n        Given a text, returns a list of the sentences in that text.\n        \"\"\"\n        return list(self.sentences_from_text(text, realign_boundaries))\n\n    def debug_decisions(self, text):\n        \"\"\"\n        Classifies candidate periods as sentence breaks, yielding a dict for\n        each that may be used to understand why the decision was made.\n\n        See format_debug_decision() to help make this output readable.\n        \"\"\"\n\n        for match, decision_text in self._match_potential_end_contexts(text):\n            tokens = self._tokenize_words(decision_text)\n            tokens = list(self._annotate_first_pass(tokens))\n            while tokens and not tokens[0].tok.endswith(self._lang_vars.sent_end_chars):\n                tokens.pop(0)\n            yield {\n                \"period_index\": match.end() - 1,\n                \"text\": decision_text,\n                \"type1\": tokens[0].type,\n                \"type2\": tokens[1].type,\n                \"type1_in_abbrs\": bool(tokens[0].abbr),\n                \"type1_is_initial\": bool(tokens[0].is_initial),\n                \"type2_is_sent_starter\": tokens[1].type_no_sentperiod\n                in self._params.sent_starters,\n                \"type2_ortho_heuristic\": self._ortho_heuristic(tokens[1]),\n                \"type2_ortho_contexts\": set(\n                    self._params._debug_ortho_context(tokens[1].type_no_sentperiod)\n                ),\n                \"collocation\": (\n                    tokens[0].type_no_sentperiod,\n                    tokens[1].type_no_sentperiod,\n                )\n                in self._params.collocations,\n                \"reason\": self._second_pass_annotation(tokens[0], tokens[1])\n                or REASON_DEFAULT_DECISION,\n                \"break_decision\": tokens[0].sentbreak,\n            }\n\n    def span_tokenize(self, text, realign_boundaries=True):\n        \"\"\"\n        Given a text, generates (start, end) spans of sentences\n        in the text.\n        \"\"\"\n        slices = self._slices_from_text(text)\n        if realign_boundaries:\n            slices = self._realign_boundaries(text, slices)\n        for sentence in slices:\n            yield (sentence.start, sentence.stop)\n\n    def sentences_from_text(self, text, realign_boundaries=True):\n        \"\"\"\n        Given a text, generates the sentences in that text by only\n        testing candidate sentence breaks. If realign_boundaries is\n        True, includes in the sentence closing punctuation that\n        follows the period.\n        \"\"\"\n        return [text[s:e] for s, e in self.span_tokenize(text, realign_boundaries)]\n\n    def _match_potential_end_contexts(self, text):\n        \"\"\"\n        Given a text, find the matches of potential sentence breaks,\n        alongside the contexts surrounding these sentence breaks.\n\n        Since the fix for the ReDOS discovered in issue #2866, we no longer match\n        the word before a potential end of sentence token. Instead, we use a separate\n        regex for this. As a consequence, `finditer`'s desire to find non-overlapping\n        matches no longer aids us in finding the single longest match.\n        Where previously, we could use::\n\n            >>> pst = PunktSentenceTokenizer()\n            >>> text = \"Very bad acting!!! I promise.\"\n            >>> list(pst._lang_vars.period_context_re().finditer(text)) # doctest: +SKIP\n            [<re.Match object; span=(9, 18), match='acting!!!'>]\n\n        Now we have to find the word before (i.e. 'acting') separately, and `finditer`\n        returns::\n\n            >>> pst = PunktSentenceTokenizer()\n            >>> text = \"Very bad acting!!! I promise.\"\n            >>> list(pst._lang_vars.period_context_re().finditer(text)) # doctest: +NORMALIZE_WHITESPACE\n            [<re.Match object; span=(15, 16), match='!'>,\n            <re.Match object; span=(16, 17), match='!'>,\n            <re.Match object; span=(17, 18), match='!'>]\n\n        So, we need to find the word before the match from right to left, and then manually remove\n        the overlaps. That is what this method does::\n\n            >>> pst = PunktSentenceTokenizer()\n            >>> text = \"Very bad acting!!! I promise.\"\n            >>> pst._match_potential_end_contexts(text)\n            [(<re.Match object; span=(17, 18), match='!'>, 'acting!!! I')]\n\n        :param text: String of one or more sentences\n        :type text: str\n        :return: List of match-context tuples.\n        :rtype: List[Tuple[re.Match, str]]\n        \"\"\"\n        before_words = {}\n        matches = []\n        for match in reversed(list(self._lang_vars.period_context_re().finditer(text))):\n            # Ignore matches that have already been captured by matches to the right of this match\n            if matches and match.end() > before_start:\n                continue\n            # Find the word before the current match\n            split = text[: match.start()].rsplit(maxsplit=1)\n            before_start = len(split[0]) if len(split) == 2 else 0\n            before_words[match] = split[-1]\n            matches.append(match)\n\n        return [\n            (\n                match,\n                before_words[match] + match.group() + match.group(\"after_tok\"),\n            )\n            for match in matches[::-1]\n        ]\n\n    def _slices_from_text(self, text):\n        last_break = 0\n        for match, context in self._match_potential_end_contexts(text):\n            if self.text_contains_sentbreak(context):\n                yield slice(last_break, match.end())\n                if match.group(\"next_tok\"):\n                    # next sentence starts after whitespace\n                    last_break = match.start(\"next_tok\")\n                else:\n                    # next sentence starts at following punctuation\n                    last_break = match.end()\n        # The last sentence should not contain trailing whitespace.\n        yield slice(last_break, len(text.rstrip()))\n\n    def _realign_boundaries(self, text, slices):\n        \"\"\"\n        Attempts to realign punctuation that falls after the period but\n        should otherwise be included in the same sentence.\n\n        For example: \"(Sent1.) Sent2.\" will otherwise be split as::\n\n            [\"(Sent1.\", \") Sent1.\"].\n\n        This method will produce::\n\n            [\"(Sent1.)\", \"Sent2.\"].\n        \"\"\"\n        realign = 0\n        for sentence1, sentence2 in _pair_iter(slices):\n            sentence1 = slice(sentence1.start + realign, sentence1.stop)\n            if not sentence2:\n                if text[sentence1]:\n                    yield sentence1\n                continue\n\n            m = self._lang_vars.re_boundary_realignment.match(text[sentence2])\n            if m:\n                yield slice(sentence1.start, sentence2.start + len(m.group(0).rstrip()))\n                realign = m.end()\n            else:\n                realign = 0\n                if text[sentence1]:\n                    yield sentence1\n\n    def text_contains_sentbreak(self, text):\n        \"\"\"\n        Returns True if the given text includes a sentence break.\n        \"\"\"\n        found = False  # used to ignore last token\n        for tok in self._annotate_tokens(self._tokenize_words(text)):\n            if found:\n                return True\n            if tok.sentbreak:\n                found = True\n        return False\n\n    def sentences_from_text_legacy(self, text):\n        \"\"\"\n        Given a text, generates the sentences in that text. Annotates all\n        tokens, rather than just those with possible sentence breaks. Should\n        produce the same results as ``sentences_from_text``.\n        \"\"\"\n        tokens = self._annotate_tokens(self._tokenize_words(text))\n        return self._build_sentence_list(text, tokens)\n\n    def sentences_from_tokens(self, tokens):\n        \"\"\"\n        Given a sequence of tokens, generates lists of tokens, each list\n        corresponding to a sentence.\n        \"\"\"\n        tokens = iter(self._annotate_tokens(self._Token(t) for t in tokens))\n        sentence = []\n        for aug_tok in tokens:\n            sentence.append(aug_tok.tok)\n            if aug_tok.sentbreak:\n                yield sentence\n                sentence = []\n        if sentence:\n            yield sentence\n\n    def _annotate_tokens(self, tokens):\n        \"\"\"\n        Given a set of tokens augmented with markers for line-start and\n        paragraph-start, returns an iterator through those tokens with full\n        annotation including predicted sentence breaks.\n        \"\"\"\n        # Make a preliminary pass through the document, marking likely\n        # sentence breaks, abbreviations, and ellipsis tokens.\n        tokens = self._annotate_first_pass(tokens)\n\n        # Make a second pass through the document, using token context\n        # information to change our preliminary decisions about where\n        # sentence breaks, abbreviations, and ellipsis occurs.\n        tokens = self._annotate_second_pass(tokens)\n\n        ## [XX] TESTING\n        # tokens = list(tokens)\n        # self.dump(tokens)\n\n        return tokens\n\n    def _build_sentence_list(self, text, tokens):\n        \"\"\"\n        Given the original text and the list of augmented word tokens,\n        construct and return a tokenized list of sentence strings.\n        \"\"\"\n        # Most of the work here is making sure that we put the right\n        # pieces of whitespace back in all the right places.\n\n        # Our position in the source text, used to keep track of which\n        # whitespace to add:\n        pos = 0\n\n        # A regular expression that finds pieces of whitespace:\n        white_space_regexp = re.compile(r\"\\s*\")\n\n        sentence = \"\"\n        for aug_tok in tokens:\n            tok = aug_tok.tok\n\n            # Find the whitespace before this token, and update pos.\n            white_space = white_space_regexp.match(text, pos).group()\n            pos += len(white_space)\n\n            # Some of the rules used by the punkt word tokenizer\n            # strip whitespace out of the text, resulting in tokens\n            # that contain whitespace in the source text.  If our\n            # token doesn't match, see if adding whitespace helps.\n            # If so, then use the version with whitespace.\n            if text[pos : pos + len(tok)] != tok:\n                pat = r\"\\s*\".join(re.escape(c) for c in tok)\n                m = re.compile(pat).match(text, pos)\n                if m:\n                    tok = m.group()\n\n            # Move our position pointer to the end of the token.\n            assert text[pos : pos + len(tok)] == tok\n            pos += len(tok)\n\n            # Add this token.  If it's not at the beginning of the\n            # sentence, then include any whitespace that separated it\n            # from the previous token.\n            if sentence:\n                sentence += white_space\n            sentence += tok\n\n            # If we're at a sentence break, then start a new sentence.\n            if aug_tok.sentbreak:\n                yield sentence\n                sentence = \"\"\n\n        # If the last sentence is empty, discard it.\n        if sentence:\n            yield sentence\n\n    # [XX] TESTING\n    def dump(self, tokens):\n        print(\"writing to /tmp/punkt.new...\")\n        with open(\"/tmp/punkt.new\", \"w\") as outfile:\n            for aug_tok in tokens:\n                if aug_tok.parastart:\n                    outfile.write(\"\\n\\n\")\n                elif aug_tok.linestart:\n                    outfile.write(\"\\n\")\n                else:\n                    outfile.write(\" \")\n\n                outfile.write(str(aug_tok))\n\n    # ////////////////////////////////////////////////////////////\n    # { Customization Variables\n    # ////////////////////////////////////////////////////////////\n\n    PUNCTUATION = tuple(\";:,.!?\")\n\n    # ////////////////////////////////////////////////////////////\n    # { Annotation Procedures\n    # ////////////////////////////////////////////////////////////\n\n    def _annotate_second_pass(self, tokens):\n        \"\"\"\n        Performs a token-based classification (section 4) over the given\n        tokens, making use of the orthographic heuristic (4.1.1), collocation\n        heuristic (4.1.2) and frequent sentence starter heuristic (4.1.3).\n        \"\"\"\n        for token1, token2 in _pair_iter(tokens):\n            self._second_pass_annotation(token1, token2)\n            yield token1\n\n    def _second_pass_annotation(self, aug_tok1, aug_tok2):\n        \"\"\"\n        Performs token-based classification over a pair of contiguous tokens\n        updating the first.\n        \"\"\"\n        # Is it the last token? We can't do anything then.\n        if not aug_tok2:\n            return\n\n        if not aug_tok1.period_final:\n            # We only care about words ending in periods.\n            return\n        typ = aug_tok1.type_no_period\n        next_typ = aug_tok2.type_no_sentperiod\n        tok_is_initial = aug_tok1.is_initial\n\n        # [4.1.2. Collocation Heuristic] If there's a\n        # collocation between the word before and after the\n        # period, then label tok as an abbreviation and NOT\n        # a sentence break. Note that collocations with\n        # frequent sentence starters as their second word are\n        # excluded in training.\n        if (typ, next_typ) in self._params.collocations:\n            aug_tok1.sentbreak = False\n            aug_tok1.abbr = True\n            return REASON_KNOWN_COLLOCATION\n\n        # [4.2. Token-Based Reclassification of Abbreviations] If\n        # the token is an abbreviation or an ellipsis, then decide\n        # whether we should *also* classify it as a sentbreak.\n        if (aug_tok1.abbr or aug_tok1.ellipsis) and (not tok_is_initial):\n            # [4.1.1. Orthographic Heuristic] Check if there's\n            # orthogrpahic evidence about whether the next word\n            # starts a sentence or not.\n            is_sent_starter = self._ortho_heuristic(aug_tok2)\n            if is_sent_starter == True:\n                aug_tok1.sentbreak = True\n                return REASON_ABBR_WITH_ORTHOGRAPHIC_HEURISTIC\n\n            # [4.1.3. Frequent Sentence Starter Heruistic] If the\n            # next word is capitalized, and is a member of the\n            # frequent-sentence-starters list, then label tok as a\n            # sentence break.\n            if aug_tok2.first_upper and next_typ in self._params.sent_starters:\n                aug_tok1.sentbreak = True\n                return REASON_ABBR_WITH_SENTENCE_STARTER\n\n        # [4.3. Token-Based Detection of Initials and Ordinals]\n        # Check if any initials or ordinals tokens that are marked\n        # as sentbreaks should be reclassified as abbreviations.\n        if tok_is_initial or typ == \"##number##\":\n\n            # [4.1.1. Orthographic Heuristic] Check if there's\n            # orthogrpahic evidence about whether the next word\n            # starts a sentence or not.\n            is_sent_starter = self._ortho_heuristic(aug_tok2)\n\n            if is_sent_starter == False:\n                aug_tok1.sentbreak = False\n                aug_tok1.abbr = True\n                if tok_is_initial:\n                    return REASON_INITIAL_WITH_ORTHOGRAPHIC_HEURISTIC\n                return REASON_NUMBER_WITH_ORTHOGRAPHIC_HEURISTIC\n\n            # Special heuristic for initials: if orthogrpahic\n            # heuristic is unknown, and next word is always\n            # capitalized, then mark as abbrev (eg: J. Bach).\n            if (\n                is_sent_starter == \"unknown\"\n                and tok_is_initial\n                and aug_tok2.first_upper\n                and not (self._params.ortho_context[next_typ] & _ORTHO_LC)\n            ):\n                aug_tok1.sentbreak = False\n                aug_tok1.abbr = True\n                return REASON_INITIAL_WITH_SPECIAL_ORTHOGRAPHIC_HEURISTIC\n\n        return\n\n    def _ortho_heuristic(self, aug_tok):\n        \"\"\"\n        Decide whether the given token is the first token in a sentence.\n        \"\"\"\n        # Sentences don't start with punctuation marks:\n        if aug_tok.tok in self.PUNCTUATION:\n            return False\n\n        ortho_context = self._params.ortho_context[aug_tok.type_no_sentperiod]\n\n        # If the word is capitalized, occurs at least once with a\n        # lower case first letter, and never occurs with an upper case\n        # first letter sentence-internally, then it's a sentence starter.\n        if (\n            aug_tok.first_upper\n            and (ortho_context & _ORTHO_LC)\n            and not (ortho_context & _ORTHO_MID_UC)\n        ):\n            return True\n\n        # If the word is lower case, and either (a) we've seen it used\n        # with upper case, or (b) we've never seen it used\n        # sentence-initially with lower case, then it's not a sentence\n        # starter.\n        if aug_tok.first_lower and (\n            (ortho_context & _ORTHO_UC) or not (ortho_context & _ORTHO_BEG_LC)\n        ):\n            return False\n\n        # Otherwise, we're not sure.\n        return \"unknown\"\n\n\nDEBUG_DECISION_FMT = \"\"\"Text: {text!r} (at offset {period_index})\nSentence break? {break_decision} ({reason})\nCollocation? {collocation}\n{type1!r}:\n    known abbreviation: {type1_in_abbrs}\n    is initial: {type1_is_initial}\n{type2!r}:\n    known sentence starter: {type2_is_sent_starter}\n    orthographic heuristic suggests is a sentence starter? {type2_ortho_heuristic}\n    orthographic contexts in training: {type2_ortho_contexts}\n\"\"\"\n\n\ndef format_debug_decision(d):\n    return DEBUG_DECISION_FMT.format(**d)\n\n\ndef demo(text, tok_cls=PunktSentenceTokenizer, train_cls=PunktTrainer):\n    \"\"\"Builds a punkt model and applies it to the same text\"\"\"\n    cleanup = (\n        lambda s: re.compile(r\"(?:\\r|^\\s+)\", re.MULTILINE).sub(\"\", s).replace(\"\\n\", \" \")\n    )\n    trainer = train_cls()\n    trainer.INCLUDE_ALL_COLLOCS = True\n    trainer.train(text)\n    sbd = tok_cls(trainer.get_params())\n    for sentence in sbd.sentences_from_text(text):\n        print(cleanup(sentence))\n"], "filenames": ["nltk/tokenize/punkt.py"], "buggy_code_start_loc": [269], "buggy_code_end_loc": [1340], "fixing_code_start_loc": [268], "fixing_code_end_loc": [1396], "type": "CWE-400", "message": "NLTK (Natural Language Toolkit) is a suite of open source Python modules, data sets, and tutorials supporting research and development in Natural Language Processing. Versions prior to 3.6.5 are vulnerable to regular expression denial of service (ReDoS) attacks. The vulnerability is present in PunktSentenceTokenizer, sent_tokenize and word_tokenize. Any users of this class, or these two functions, are vulnerable to the ReDoS attack. In short, a specifically crafted long input to any of these vulnerable functions will cause them to take a significant amount of execution time. If your program relies on any of the vulnerable functions for tokenizing unpredictable user input, then we would strongly recommend upgrading to a version of NLTK without the vulnerability. For users unable to upgrade the execution time can be bounded by limiting the maximum length of an input to any of the vulnerable functions. Our recommendation is to implement such a limit.", "other": {"cve": {"id": "CVE-2021-43854", "sourceIdentifier": "security-advisories@github.com", "published": "2021-12-23T18:15:07.327", "lastModified": "2022-01-04T16:38:20.947", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "NLTK (Natural Language Toolkit) is a suite of open source Python modules, data sets, and tutorials supporting research and development in Natural Language Processing. Versions prior to 3.6.5 are vulnerable to regular expression denial of service (ReDoS) attacks. The vulnerability is present in PunktSentenceTokenizer, sent_tokenize and word_tokenize. Any users of this class, or these two functions, are vulnerable to the ReDoS attack. In short, a specifically crafted long input to any of these vulnerable functions will cause them to take a significant amount of execution time. If your program relies on any of the vulnerable functions for tokenizing unpredictable user input, then we would strongly recommend upgrading to a version of NLTK without the vulnerability. For users unable to upgrade the execution time can be bounded by limiting the maximum length of an input to any of the vulnerable functions. Our recommendation is to implement such a limit."}, {"lang": "es", "value": "NLTK (Natural Language Toolkit) es un conjunto de m\u00f3dulos de c\u00f3digo abierto de Python, conjuntos de datos y tutoriales que apoyan la investigaci\u00f3n y el desarrollo en el procesamiento del lenguaje natural. Las Versiones anteriores a 3.6.5, son vulnerables a ataques de denegaci\u00f3n de servicio con expresiones regulares (ReDoS). La vulnerabilidad est\u00e1 presente en PunktSentenceTokenizer, sent_tokenize y word_tokenize. Cualquier usuario de esta clase, o de estas dos funciones, es vulnerable al ataque ReDoS. En resumen, una entrada larga espec\u00edficamente dise\u00f1ada para cualquiera de estas funciones vulnerables causar\u00e1 que tomen una cantidad significativa de tiempo de ejecuci\u00f3n. Si su programa depende de cualquiera de las funciones vulnerables para tokenizar entradas de usuario imprevisibles, le recomendamos encarecidamente que actualice a una versi\u00f3n de NLTK sin la vulnerabilidad. Para usuarios que no puedan actualizarse, el tiempo de ejecuci\u00f3n puede limitarse mediante la limitaci\u00f3n de la longitud m\u00e1xima de una entrada a cualquiera de las funciones vulnerables. Nuestra recomendaci\u00f3n es implementar dicho l\u00edmite"}], "metrics": {"cvssMetricV31": [{"source": "security-advisories@github.com", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nltk:nltk:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.6.5", "matchCriteriaId": "355BC362-D4FF-4893-9F37-B97D23E48267"}]}]}], "references": [{"url": "https://github.com/nltk/nltk/commit/1405aad979c6b8080dbbc8e0858f89b2e3690341", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/nltk/nltk/issues/2866", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/nltk/nltk/pull/2869", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/nltk/nltk/security/advisories/GHSA-f8m6-h2c7-8h9x", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nltk/nltk/commit/1405aad979c6b8080dbbc8e0858f89b2e3690341"}}