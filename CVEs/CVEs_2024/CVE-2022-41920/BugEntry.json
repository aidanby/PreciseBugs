{"buggy_code": ["// Copyright 2021 dudaodong@gmail.com. All rights reserved.\n// Use of this source code is governed by MIT license.\n\n// Package fileutil implements some basic functions for file operations\npackage fileutil\n\nimport (\n\t\"archive/zip\"\n\t\"bufio\"\n\t\"errors\"\n\t\"io\"\n\t\"io/fs\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\n// IsExist checks if a file or directory exists\nfunc IsExist(path string) bool {\n\t_, err := os.Stat(path)\n\tif err == nil {\n\t\treturn true\n\t}\n\tif errors.Is(err, os.ErrNotExist) {\n\t\treturn false\n\t}\n\treturn false\n}\n\n// CreateFile create a file in path\nfunc CreateFile(path string) bool {\n\tfile, err := os.Create(path)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tdefer file.Close()\n\treturn true\n}\n\n// CreateDir create directory in absolute path. param `absPath` like /a/, /a/b/\nfunc CreateDir(absPath string) error {\n\treturn os.MkdirAll(path.Dir(absPath), os.ModePerm)\n}\n\n// IsDir checks if the path is directory or not\nfunc IsDir(path string) bool {\n\tfile, err := os.Stat(path)\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn file.IsDir()\n}\n\n// RemoveFile remove the path file\nfunc RemoveFile(path string) error {\n\treturn os.Remove(path)\n}\n\n// CopyFile copy src file to dest file\nfunc CopyFile(srcFilePath string, dstFilePath string) error {\n\tsrcFile, err := os.Open(srcFilePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer srcFile.Close()\n\n\tdistFile, err := os.Create(dstFilePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer distFile.Close()\n\n\tvar tmp = make([]byte, 1024*4)\n\tfor {\n\t\tn, err := srcFile.Read(tmp)\n\t\tdistFile.Write(tmp[:n])\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n}\n\n//ClearFile write empty string to path file\nfunc ClearFile(path string) error {\n\tf, err := os.OpenFile(path, os.O_WRONLY|os.O_TRUNC, 0777)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\t_, err = f.WriteString(\"\")\n\treturn err\n}\n\n//ReadFileToString return string of file content\nfunc ReadFileToString(path string) (string, error) {\n\tbytes, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(bytes), nil\n}\n\n// ReadFileByLine read file line by line\nfunc ReadFileByLine(path string) ([]string, error) {\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer f.Close()\n\n\tres := make([]string, 0)\n\tbuf := bufio.NewReader(f)\n\n\tfor {\n\t\tline, _, err := buf.ReadLine()\n\t\tl := string(line)\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tres = append(res, l)\n\t}\n\n\treturn res, nil\n}\n\n// ListFileNames return all file names in the path\nfunc ListFileNames(path string) ([]string, error) {\n\tif !IsExist(path) {\n\t\treturn []string{}, nil\n\t}\n\n\tfs, err := ioutil.ReadDir(path)\n\tif err != nil {\n\t\treturn []string{}, err\n\t}\n\n\tsz := len(fs)\n\tif sz == 0 {\n\t\treturn []string{}, nil\n\t}\n\n\tres := []string{}\n\tfor i := 0; i < sz; i++ {\n\t\tif !fs[i].IsDir() {\n\t\t\tres = append(res, fs[i].Name())\n\t\t}\n\t}\n\n\treturn res, nil\n}\n\n// Zip create zip file, fpath could be a single file or a directory\nfunc Zip(fpath string, destPath string) error {\n\tzipFile, err := os.Create(destPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer zipFile.Close()\n\n\tarchive := zip.NewWriter(zipFile)\n\tdefer archive.Close()\n\n\tfilepath.Walk(fpath, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\theader, err := zip.FileInfoHeader(info)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\theader.Name = strings.TrimPrefix(path, filepath.Dir(fpath)+\"/\")\n\n\t\tif info.IsDir() {\n\t\t\theader.Name += \"/\"\n\t\t} else {\n\t\t\theader.Method = zip.Deflate\n\t\t}\n\n\t\twriter, err := archive.CreateHeader(header)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif !info.IsDir() {\n\t\t\tfile, err := os.Open(path)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer file.Close()\n\t\t\t_, err = io.Copy(writer, file)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\n\treturn nil\n}\n\n// UnZip unzip the file and save it to destPath\nfunc UnZip(zipFile string, destPath string) error {\n\tzipReader, err := zip.OpenReader(zipFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer zipReader.Close()\n\n\tfor _, f := range zipReader.File {\n\t\tpath := filepath.Join(destPath, f.Name)\n\t\tif f.FileInfo().IsDir() {\n\t\t\tos.MkdirAll(path, os.ModePerm)\n\t\t} else {\n\t\t\tif err = os.MkdirAll(filepath.Dir(path), os.ModePerm); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tinFile, err := f.Open()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer inFile.Close()\n\n\t\t\toutFile, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, f.Mode())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer outFile.Close()\n\n\t\t\t_, err = io.Copy(outFile, inFile)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// IsLink checks if a file is symbol link or not\nfunc IsLink(path string) bool {\n\tfi, err := os.Lstat(path)\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn fi.Mode()&os.ModeSymlink != 0\n}\n\n// FileMode return file's mode and permission\nfunc FileMode(path string) (fs.FileMode, error) {\n\tfi, err := os.Lstat(path)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn fi.Mode(), nil\n}\n\n// MiMeType return file mime type\n// param `file` should be string(file path) or *os.File\nfunc MiMeType(file interface{}) string {\n\tvar mediatype string\n\n\treadBuffer := func(f *os.File) ([]byte, error) {\n\t\tbuffer := make([]byte, 512)\n\t\t_, err := f.Read(buffer)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn buffer, nil\n\t}\n\n\tif filePath, ok := file.(string); ok {\n\t\tf, err := os.Open(filePath)\n\t\tif err != nil {\n\t\t\treturn mediatype\n\t\t}\n\t\tbuffer, err := readBuffer(f)\n\t\tif err != nil {\n\t\t\treturn mediatype\n\t\t}\n\t\treturn http.DetectContentType(buffer)\n\t}\n\n\tif f, ok := file.(*os.File); ok {\n\t\tbuffer, err := readBuffer(f)\n\t\tif err != nil {\n\t\t\treturn mediatype\n\t\t}\n\t\treturn http.DetectContentType(buffer)\n\t}\n\treturn mediatype\n}\n"], "fixing_code": ["// Copyright 2021 dudaodong@gmail.com. All rights reserved.\n// Use of this source code is governed by MIT license.\n\n// Package fileutil implements some basic functions for file operations\npackage fileutil\n\nimport (\n\t\"archive/zip\"\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/fs\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\n// IsExist checks if a file or directory exists\nfunc IsExist(path string) bool {\n\t_, err := os.Stat(path)\n\tif err == nil {\n\t\treturn true\n\t}\n\tif errors.Is(err, os.ErrNotExist) {\n\t\treturn false\n\t}\n\treturn false\n}\n\n// CreateFile create a file in path\nfunc CreateFile(path string) bool {\n\tfile, err := os.Create(path)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tdefer file.Close()\n\treturn true\n}\n\n// CreateDir create directory in absolute path. param `absPath` like /a/, /a/b/\nfunc CreateDir(absPath string) error {\n\treturn os.MkdirAll(path.Dir(absPath), os.ModePerm)\n}\n\n// IsDir checks if the path is directory or not\nfunc IsDir(path string) bool {\n\tfile, err := os.Stat(path)\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn file.IsDir()\n}\n\n// RemoveFile remove the path file\nfunc RemoveFile(path string) error {\n\treturn os.Remove(path)\n}\n\n// CopyFile copy src file to dest file\nfunc CopyFile(srcFilePath string, dstFilePath string) error {\n\tsrcFile, err := os.Open(srcFilePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer srcFile.Close()\n\n\tdistFile, err := os.Create(dstFilePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer distFile.Close()\n\n\tvar tmp = make([]byte, 1024*4)\n\tfor {\n\t\tn, err := srcFile.Read(tmp)\n\t\tdistFile.Write(tmp[:n])\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n}\n\n//ClearFile write empty string to path file\nfunc ClearFile(path string) error {\n\tf, err := os.OpenFile(path, os.O_WRONLY|os.O_TRUNC, 0777)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\t_, err = f.WriteString(\"\")\n\treturn err\n}\n\n//ReadFileToString return string of file content\nfunc ReadFileToString(path string) (string, error) {\n\tbytes, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(bytes), nil\n}\n\n// ReadFileByLine read file line by line\nfunc ReadFileByLine(path string) ([]string, error) {\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer f.Close()\n\n\tres := make([]string, 0)\n\tbuf := bufio.NewReader(f)\n\n\tfor {\n\t\tline, _, err := buf.ReadLine()\n\t\tl := string(line)\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tres = append(res, l)\n\t}\n\n\treturn res, nil\n}\n\n// ListFileNames return all file names in the path\nfunc ListFileNames(path string) ([]string, error) {\n\tif !IsExist(path) {\n\t\treturn []string{}, nil\n\t}\n\n\tfs, err := ioutil.ReadDir(path)\n\tif err != nil {\n\t\treturn []string{}, err\n\t}\n\n\tsz := len(fs)\n\tif sz == 0 {\n\t\treturn []string{}, nil\n\t}\n\n\tres := []string{}\n\tfor i := 0; i < sz; i++ {\n\t\tif !fs[i].IsDir() {\n\t\t\tres = append(res, fs[i].Name())\n\t\t}\n\t}\n\n\treturn res, nil\n}\n\n// Zip create zip file, fpath could be a single file or a directory\nfunc Zip(fpath string, destPath string) error {\n\tzipFile, err := os.Create(destPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer zipFile.Close()\n\n\tarchive := zip.NewWriter(zipFile)\n\tdefer archive.Close()\n\n\tfilepath.Walk(fpath, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\theader, err := zip.FileInfoHeader(info)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\theader.Name = strings.TrimPrefix(path, filepath.Dir(fpath)+\"/\")\n\n\t\tif info.IsDir() {\n\t\t\theader.Name += \"/\"\n\t\t} else {\n\t\t\theader.Method = zip.Deflate\n\t\t}\n\n\t\twriter, err := archive.CreateHeader(header)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif !info.IsDir() {\n\t\t\tfile, err := os.Open(path)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer file.Close()\n\t\t\t_, err = io.Copy(writer, file)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\n\treturn nil\n}\n\n// UnZip unzip the file and save it to destPath\nfunc UnZip(zipFile string, destPath string) error {\n\tzipReader, err := zip.OpenReader(zipFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer zipReader.Close()\n\n\tfor _, f := range zipReader.File {\n\t\t//issue#62: fix ZipSlip bug\n\t\tpath, err := safeFilepathJoin(destPath, f.Name)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif f.FileInfo().IsDir() {\n\t\t\tos.MkdirAll(path, os.ModePerm)\n\t\t} else {\n\t\t\tif err = os.MkdirAll(filepath.Dir(path), os.ModePerm); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tinFile, err := f.Open()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer inFile.Close()\n\n\t\t\toutFile, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, f.Mode())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer outFile.Close()\n\n\t\t\t_, err = io.Copy(outFile, inFile)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc safeFilepathJoin(path1, path2 string) (string, error) {\n\trelPath, err := filepath.Rel(\".\", path2)\n\tif err != nil || strings.HasPrefix(relPath, \"..\") {\n\t\treturn \"\", fmt.Errorf(\"(zipslip) filepath is unsafe %q: %v\", path2, err)\n\t}\n\tif path1 == \"\" {\n\t\tpath1 = \".\"\n\t}\n\treturn filepath.Join(path1, filepath.Join(\"/\", relPath)), nil\n}\n\n// IsLink checks if a file is symbol link or not\nfunc IsLink(path string) bool {\n\tfi, err := os.Lstat(path)\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn fi.Mode()&os.ModeSymlink != 0\n}\n\n// FileMode return file's mode and permission\nfunc FileMode(path string) (fs.FileMode, error) {\n\tfi, err := os.Lstat(path)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn fi.Mode(), nil\n}\n\n// MiMeType return file mime type\n// param `file` should be string(file path) or *os.File\nfunc MiMeType(file interface{}) string {\n\tvar mediatype string\n\n\treadBuffer := func(f *os.File) ([]byte, error) {\n\t\tbuffer := make([]byte, 512)\n\t\t_, err := f.Read(buffer)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn buffer, nil\n\t}\n\n\tif filePath, ok := file.(string); ok {\n\t\tf, err := os.Open(filePath)\n\t\tif err != nil {\n\t\t\treturn mediatype\n\t\t}\n\t\tbuffer, err := readBuffer(f)\n\t\tif err != nil {\n\t\t\treturn mediatype\n\t\t}\n\t\treturn http.DetectContentType(buffer)\n\t}\n\n\tif f, ok := file.(*os.File); ok {\n\t\tbuffer, err := readBuffer(f)\n\t\tif err != nil {\n\t\t\treturn mediatype\n\t\t}\n\t\treturn http.DetectContentType(buffer)\n\t}\n\treturn mediatype\n}\n"], "filenames": ["fileutil/file.go"], "buggy_code_start_loc": [10], "buggy_code_end_loc": [251], "fixing_code_start_loc": [11], "fixing_code_end_loc": [268], "type": "CWE-22", "message": "Lancet is a general utility library for the go programming language. Affected versions are subject to a ZipSlip issue when using the fileutil package to unzip files. This issue has been addressed and a fix will be included in versions 2.1.10 and 1.3.4. Users are advised to upgrade. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-41920", "sourceIdentifier": "security-advisories@github.com", "published": "2022-11-17T18:15:10.100", "lastModified": "2022-11-22T19:09:57.583", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Lancet is a general utility library for the go programming language. Affected versions are subject to a ZipSlip issue when using the fileutil package to unzip files. This issue has been addressed and a fix will be included in versions 2.1.10 and 1.3.4. Users are advised to upgrade. There are no known workarounds for this issue."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lancet_project:lancet:*:*:*:*:*:go:*:*", "versionEndExcluding": "1.3.4", "matchCriteriaId": "B1C2AAFE-19C2-489A-942C-6F0F833A348D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:lancet_project:lancet:*:*:*:*:*:go:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.1.10", "matchCriteriaId": "B662D915-5AC9-44EA-9E0A-B765A89ACE6E"}]}]}], "references": [{"url": "https://github.com/duke-git/lancet/commit/f133b32faa05eb93e66175d01827afa4b7094572", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/duke-git/lancet/commit/f869a0a67098e92d24ddd913e188b32404fa72c9", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/duke-git/lancet/issues/62", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/duke-git/lancet/security/advisories/GHSA-pp3f-xrw5-q5j4", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/duke-git/lancet/commit/f133b32faa05eb93e66175d01827afa4b7094572"}}