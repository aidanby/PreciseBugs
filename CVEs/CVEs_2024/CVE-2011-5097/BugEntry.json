{"buggy_code": ["#\n# Author:: Adam Jacob (<adam@opscode.com>)\n# Author:: Christopher Brown (<cb@opscode.com>)\n# Author:: Christopher Walters (<cw@opscode.com>)\n# Author:: Tim Hinderliter (<tim@opscode.com>)\n# Copyright:: Copyright (c) 2008, 2009, 2010 Opscode, Inc.\n# License:: Apache License, Version 2.0\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n\nrequire 'chef/cookbook_loader'\nrequire 'chef/cookbook/metadata'\n\nclass Cookbooks < Application\n\n  include Merb::CookbookVersionHelper\n\n  provides :json\n\n  before :authenticate_every\n  before :params_helper\n\n  attr_accessor :cookbook_name, :cookbook_version\n\n  def params_helper\n    self.cookbook_name = params[:cookbook_name]\n    self.cookbook_version = params[:cookbook_version]\n  end\n\n  include Chef::Mixin::Checksum\n  include Merb::TarballHelper\n\n  def index\n    if request.env['HTTP_X_CHEF_VERSION'] =~ /0\\.9/\n      index_09\n    else\n      index_010\n    end\n  end\n\n  # GET /cookbooks\n  # returns data in the format of:\n  # {\"apache2\" => {\n  #     :url => \"http://url\",\n  #     :versions => [{:url => \"http://url/1.0.0\", :version => \"1.0.0\"}, {:url => \"http://url/0.0.1\", :version=>\"0.0.1\"}]\n  #   }\n  # }\n  def index_010\n    cookbook_list = Chef::CookbookVersion.cdb_list\n    # cookbook_list is in the format of {\"apache2\" => [0.0.1, 0.0.0]} where the version numbers are DepSelector::Version objects\n    num_versions = num_versions!\n    display(cookbook_list.inject({}) {|res, (cookbook_name, versions)|\n      versions = versions.map{ |x| DepSelector::Version.new(x) }.sort.reverse.map{ |x| x.to_s }\n      res[cookbook_name] = expand_cookbook_urls(cookbook_name, versions, num_versions)\n      res\n    })\n  end\n\n  # GET /cookbooks\n  #\n  # returns data in the format of:\n  # {\n  #   \"apache2\" => \"http://url/apache2\",\n  #   \"python\" => \"http://url/python\"\n  # }\n  def index_09\n    cookbook_list = Chef::CookbookVersion.cdb_list_latest(false).keys.sort\n    response = Hash.new\n    cookbook_list.map! do |cookbook_name|\n      response[cookbook_name] = absolute_url(:cookbook, :cookbook_name => cookbook_name)\n    end\n    display response\n  end\n\n  def index_recipes\n    recipes_with_versions = Chef::CookbookVersion.cdb_list(true).inject({}) do|memo, f|\n      memo[f.name] ||= {}\n      memo[f.name][f.version] = f.recipe_filenames_by_name.keys\n      memo\n    end\n    display recipes_with_versions\n  end\n\n  def show_versions\n    if request.env['HTTP_X_CHEF_VERSION'] =~ /0\\.9/\n      show_versions_09\n    else\n      show_versions_010\n    end\n  end\n\n  # GET /cookbooks/:cookbook_name\n  #\n  # returns data in the format of:\n  # {\"apache2\" => {\n  #     :url => \"http://url\",\n  #     :versions => [{:url => \"http://url/1.0.0\", :version => \"1.0.0\"}, {:url => \"http://url/0.0.1\", :version=>\"0.0.1\"}]\n  #   }\n  # }\n  def show_versions_010\n    versions = Chef::CookbookVersion.cdb_by_name(cookbook_name)\n    raise NotFound, \"Cannot find a cookbook named #{cookbook_name}\" unless versions && versions.size > 0\n    num_versions = num_versions!(\"all\")\n    cb_versions = versions[cookbook_name].map{ |x| DepSelector::Version.new(x) }.sort.reverse.map{ |x| x.to_s }\n    display({ cookbook_name => expand_cookbook_urls(cookbook_name, cb_versions, num_versions) })\n  end\n\n  # GET /cookbooks/:cookbook_name\n  #\n  # returns data in the format of:\n  # {\"apache2\" => [\"1.0.0\", \"0.0.1\"]}\n  def show_versions_09\n    versions = Chef::CookbookVersion.cdb_by_name(cookbook_name)\n    raise NotFound, \"Cannot find a cookbook named #{requested_cookbook_name}\" unless versions && versions.size > 0\n\n    display versions\n  end\n\n  def show\n    cookbook = get_cookbook_version(cookbook_name, cookbook_version)\n    display cookbook.generate_manifest_with_urls { |opts| absolute_url(:cookbook_file, opts) }\n  end\n\n  def show_file\n    cookbook = get_cookbook_version(cookbook_name, cookbook_version)\n\n    checksum = params[:checksum]\n    raise NotFound, \"Cookbook #{cookbook_name} version #{cookbook_version} does not contain a file with checksum #{checksum}\" unless cookbook.checksums.keys.include?(checksum)\n\n    filename = Chef::Checksum.new(checksum).file_location\n    raise InternalServerError, \"File with checksum #{checksum} not found in the repository (this should not happen)\" unless File.exists?(filename)\n\n    send_file(filename)\n  end\n\n  def update\n    raise(BadRequest, \"You didn't pass me a valid object!\") unless params.has_key?('inflated_object')\n    raise(BadRequest, \"You didn't pass me a Chef::CookbookVersion object!\") unless params['inflated_object'].kind_of?(Chef::CookbookVersion)\n    unless params[\"inflated_object\"].name == cookbook_name\n      raise(BadRequest, \"You said the cookbook was named #{params['inflated_object'].name}, but the URL says it should be #{cookbook_name}.\")\n    end\n\n    unless params[\"inflated_object\"].version == cookbook_version\n      raise(BadRequest, \"You said the cookbook was version #{params['inflated_object'].version}, but the URL says it should be #{cookbook_version}.\")\n    end\n\n    begin\n      cookbook = Chef::CookbookVersion.cdb_load(cookbook_name, cookbook_version)\n      cookbook.manifest = params['inflated_object'].manifest\n    rescue Chef::Exceptions::CouchDBNotFound => e\n      Chef::Log.debug(\"Cookbook #{cookbook_name} version #{cookbook_version} does not exist\")\n      cookbook = params['inflated_object']\n    end\n\n    if cookbook.frozen_version? && params[:force].nil?\n      raise Conflict, \"The cookbook #{cookbook.name} at version #{cookbook.version} is frozen. Use the 'force' option to override.\"\n    end\n\n    cookbook.freeze_version if params[\"inflated_object\"].frozen_version?\n\n    # ensure that all checksums referred to by the manifest have been uploaded.\n    Chef::CookbookVersion::COOKBOOK_SEGMENTS.each do |segment|\n      next unless cookbook.manifest[segment]\n      cookbook.manifest[segment].each do |manifest_record|\n        checksum = manifest_record[:checksum]\n        path = manifest_record[:path]\n\n        begin\n          checksum_obj = Chef::Checksum.cdb_load(checksum)\n        rescue Chef::Exceptions::CouchDBNotFound => cdbx\n          checksum_obj = nil\n        end\n\n        raise BadRequest, \"Manifest has checksum #{checksum} (path #{path}) but it hasn't yet been uploaded\" unless checksum_obj\n      end\n    end\n\n    raise InternalServerError, \"Error saving cookbook\" unless cookbook.cdb_save\n\n    display cookbook\n  end\n\n  def destroy\n    begin\n      cookbook = get_cookbook_version(cookbook_name, cookbook_version)\n    rescue ArgumentError => e\n      raise NotFound, \"Cannot find a cookbook named #{cookbook_name} with version #{cookbook_version}\"\n    end\n\n    if params[\"purge\"] == \"true\"\n      display cookbook.purge\n    else\n      display cookbook.cdb_destroy\n    end\n  end\n\n  private\n\n  def get_cookbook_version(name, version)\n    Chef::CookbookVersion.cdb_load(name, version)\n  rescue Chef::Exceptions::CouchDBNotFound => e\n    raise NotFound, \"Cannot find a cookbook named #{name} with version #{version}\"\n  rescue Net::HTTPServerException => e\n    if e.to_s =~ /^404/\n      raise NotFound, \"Cannot find a cookbook named #{name} with version #{version}\"\n    else\n      raise\n    end\n  end\n\nend\n\n", "@api @cookbooks @api_cookbooks_delete\n@manage_cookbook\n\nFeature: CRUD cookbooks\n  In order to manage cookbook data\n  As a Developer\n  I want to delete cookbook versions\n\n  @delete_cookbook_positive @delete_cookbook_version_positive\n  Scenario: After uploading two versions of a cookbook, then deleting the second, I should not be able to interact with the second but should be able to interact with the first\n    Given I am an administrator\n     When I fully upload a sandboxed cookbook named 'testcookbook_valid' versioned '0.1.0' with 'testcookbook_valid'\n      And I fully upload a sandboxed cookbook force-named 'testcookbook_valid' versioned '0.2.0' with 'testcookbook_valid_v0.2.0'\n     When I 'GET' to the path '/cookbooks/testcookbook_valid/0.2.0'\n     Then I should not get an exception\n     When I 'DELETE' to the path '/cookbooks/testcookbook_valid/0.2.0'\n     When I 'GET' to the path '/cookbooks/testcookbook_valid'\n     Then the inflated responses key 'testcookbook_valid' should exist\n     Then the inflated responses key 'testcookbook_valid' sub-key 'versions' should be '1' items long\n     Then the inflated responses key 'testcookbook_valid' sub-key 'versions' item '0' sub-key 'version' should equal '0.1.0'\n     When I 'GET' to the path '/cookbooks/testcookbook_valid/0.2.0'\n     Then I should get a '404 \"Not Found\"' exception\n     When I download the cookbook manifest for 'testcookbook_valid' version '0.1.0'\n     Then I should not get an exception\n     When I download the file 'recipes/default.rb' from the downloaded cookbook manifest\n     Then the downloaded cookbook file contents should match the pattern '.*0.1.0.*'\n\n  @delete_cookbook_negative @delete_cookbook_version_negative\n  Scenario: I should not be able to delete a cookbook version that does not exist\n    Given I am an administrator\n     When I fully upload a sandboxed cookbook named 'testcookbook_valid' versioned '0.1.0' with 'testcookbook_valid'\n      And I fully upload a sandboxed cookbook force-named 'testcookbook_valid' versioned '0.2.0' with 'testcookbook_valid_v0.2.0'\n     When I 'DELETE' to the path '/cookbooks/testcookbook_valid/0.3.0'\n     Then I should get a '404 \"Not Found\"' exception\n\n  # Currently you cannot delete a cookbook by, e.g., DELETE /cookbooks/foo.\n  # You delete all of its versions and then it disappears.     \n  @delete_cookbook_positive\n  Scenario: I should be able to delete a cookbook by deleting all of its versions\n    Given I am an administrator\n     When I fully upload a sandboxed cookbook named 'testcookbook_valid' versioned '0.1.0' with 'testcookbook_valid'\n     When I 'DELETE' to the path '/cookbooks/testcookbook_valid/0.1.0'\n     Then I should not get an exception\n     When I 'GET' the path '/cookbooks'\n     Then the inflated responses key 'testcookbook_valid' should not exist\n     When I 'GET' the path '/cookbooks/testcookbook_valid'\n     Then I should get a '404 \"Not Found\"' exception\n     \n  @delete_cookbook_negative\n  Scenario: I should not be able to delete a cookbook that doesn't exist'\n    Given I am an administrator\n     When I 'DELETE' to the path '/cookbooks/testcookbook_nonexistent/1.2.3'\n     Then I should get a '404 \"Not Found\"' exception\n\n", "@api @cookbooks @api_cookbooks_upload\n@manage_cookbook\n\nFeature: CRUD cookbooks\n  In order to manage cookbook data\n  As a Developer\n  I want to create and upload cookbook files and manifests\n\n  @create_cookbook_negative\n\n  Scenario: Should not be able to create a cookbook with the wrong name\n    Given I am an administrator\n     When I create a versioned cookbook named 'foo' versioned '1.0.0' with 'testcookbook_valid'\n     Then I should get a '400 \"Bad Request\"' exception\n\n  Scenario: Should not be able to create a cookbook with the wrong version\n    Given I am an administrator\n     When I create a versioned cookbook named 'testcookbook_valid' versioned '9.9.9' with 'testcookbook_valid'\n     Then I should get a '400 \"Bad Request\"' exception\n\n  Scenario: Should not be able to create a cookbook with missing name\n    Given I am an administrator\n     When I create a versioned cookbook named '' versioned '9.9.9' with 'testcookbook_valid'\n     Then I should get a '404 \"Not Found\"' exception\n\n  Scenario: Should not be able to create a cookbook with missing name and version\n    Given I am an administrator\n     When I create a versioned cookbook named '' versioned '' with 'testcookbook_valid'\n     Then I should get a '404 \"Not Found\"' exception\n\n  Scenario: Should not be able to create a cookbook with non-X.Y.Z version\n    Given I am an administrator\n     When I create a versioned cookbook named 'testcookbook_valid' versioned '1.0' with 'testcookbook_valid'\n     Then I should get a '404 \"Not Found\"' exception\n\n  Scenario: Should not be able to create a cookbook if none of its contained files have been uploaded\n    Given I am an administrator\n     When I create a versioned cookbook named 'testcookbook_valid' versioned '0.1.0' with 'testcookbook_valid'\n     Then I should get a '400 \"Bad Request\"' exception\n\n  @create_cookbook_positive\n  Scenario: Should be able to create a cookbook if its files have been uploaded\n    Given I am an administrator\n     When I create a sandbox named 'sandbox1' for cookbook 'testcookbook_valid'\n     Then the inflated responses key 'uri' should match '^http://.+/sandboxes/[^\\/]+$'\n     Then I upload a file named 'metadata.json' from cookbook 'testcookbook_valid' to the sandbox\n     Then the response code should be '200'\n     Then I upload a file named 'metadata.rb' from cookbook 'testcookbook_valid' to the sandbox\n     Then the response code should be '200'\n     Then I upload a file named 'attributes/attributes.rb' from cookbook 'testcookbook_valid' to the sandbox\n     Then the response code should be '200'\n     Then I upload a file named 'recipes/default.rb' from cookbook 'testcookbook_valid' to the sandbox\n     Then the response code should be '200'\n     When I commit the sandbox\n     Then I should not get an exception\n     When I create a versioned cookbook named 'testcookbook_valid' versioned '0.1.0' with 'testcookbook_valid'\n     Then I should not get an exception\n     \n  @create_cookbook_positive\n  Scenario: Cookbook successfully uploaded via sandbox should later be visible via /cookbooks, including its versions and metadata\n    Given I am an administrator\n     When I fully upload a sandboxed cookbook named 'testcookbook_valid' versioned '0.1.0' with 'testcookbook_valid'\n     When I 'GET' the path '/cookbooks'\n     Then the inflated responses key 'testcookbook_valid' should exist\n     When I 'GET' the path '/cookbooks/testcookbook_valid'\n     Then the inflated responses key 'testcookbook_valid' should exist\n     Then the inflated responses key 'testcookbook_valid' sub-key 'versions' item '0' sub-key 'version' should equal '0.1.0'\n     When I 'GET' the path '/cookbooks/testcookbook_valid/0.1.0'\n     Then the inflated response should match '.*default.rb.*' as json\n\n  @create_multiple_cookbook_versions_positive\n  Scenario: Multiple cookbook versions successfully uploaded are visible\n    Given I am an administrator\n      And I fully upload a sandboxed cookbook named 'testcookbook_valid' versioned '0.1.0' with 'testcookbook_valid'\n      And I fully upload a sandboxed cookbook force-named 'testcookbook_valid' versioned '0.2.0' with 'testcookbook_valid_v0.2.0'\n     When I 'GET' the path '/cookbooks'\n     Then the inflated responses key 'testcookbook_valid' should exist\n     When I 'GET' the path '/cookbooks/testcookbook_valid'\n     Then the inflated responses key 'testcookbook_valid' should exist\n      And the inflated responses key 'testcookbook_valid' sub-key 'versions' should be '2' items long\n      And the inflated responses key 'testcookbook_valid' sub-key 'versions' item '0' sub-key 'version' should equal '0.2.0'\n      And the inflated responses key 'testcookbook_valid' sub-key 'versions' item '1' sub-key 'version' should equal '0.1.0'\n\n  @update_cookbook_version_metadata_positive\n  Scenario: A successful cookbook version upload that changes the metadata is properly reflected\n    Given I am an administrator\n      And I fully upload a sandboxed cookbook named 'testcookbook_valid' versioned '0.1.0' with 'testcookbook_valid'\n     When I 'GET' the path '/cookbooks/testcookbook_valid/0.1.0'\n     Then the inflated response should be a kind of 'Chef::CookbookVersion'\n      And the dependencies in its metadata should be an empty hash\n     When I fully upload a sandboxed cookbook force-named 'testcookbook_valid' versioned '0.1.0' with 'testcookbook_valid_v0.1.0_with_different_dependencies'\n     Then the inflated response should be a kind of 'Chef::CookbookVersion'\n      And the metadata should include a dependency on 'aws'\n\n  # The sandbox is created missing 'metadata.json'. However, the cookbook's\n  # manifest includes that file. We don't upload the file to the sandbox, but\n  # the sandbox commits ok cuz it wasn't expecting that file. However, when we\n  # try to create the cookbook, it should complain as its manifest wants that\n  # file.\n  @create_cookbook_negative\n  Scenario: Should not be able to create a cookbook if it is missing one file\n    Given I am an administrator\n     When I create a sandbox named 'sandbox1' for cookbook 'testcookbook_valid' minus files 'metadata.rb'\n     Then the inflated responses key 'uri' should match '^http://.+/sandboxes/[^\\/]+$'\n     Then I upload a file named 'metadata.json' from cookbook 'testcookbook_valid' to the sandbox\n     Then the response code should be '200'\n     Then I upload a file named 'attributes/attributes.rb' from cookbook 'testcookbook_valid' to the sandbox\n     Then the response code should be '200'\n     Then I upload a file named 'recipes/default.rb' from cookbook 'testcookbook_valid' to the sandbox\n     Then the response code should be '200'\n     When I commit the sandbox\n     Then I should not get an exception\n     When I create a versioned cookbook named 'testcookbook_valid' versioned '0.1.0' with 'testcookbook_valid'\n     Then I should get a '400 \"Bad Request\"' exception\n  \n  @create_cookbook_negative\n  Scenario: Should not be able to create a cookbook if it has no metadata file\n    Given I am an administrator\n     When I create a sandbox named 'sandbox1' for cookbook 'testcookbook_invalid_nometadata'\n     Then the inflated responses key 'uri' should match '^http://.+/sandboxes/[^\\/]+$'\n     Then I upload a file named 'attributes/attributes.rb' from cookbook 'testcookbook_invalid_nometadata' to the sandbox\n     Then the response code should be '200'\n     Then I upload a file named 'recipes/default.rb' from cookbook 'testcookbook_invalid_nometadata' to the sandbox\n     Then the response code should be '200'\n     When I commit the sandbox\n     Then I should not get an exception\n     When I create a versioned cookbook named 'testcookbook_invalid_nometadata' versioned '0.1.0' with 'testcookbook_invalid_nometadata'\n     Then I should get a '400 \"Bad Request\"' exception\n    \n  #  update a cookbook with no files should fail\n  @create_cookbook_negative\n  Scenario: Should not be able to create a cookbook if it has no files and just metadata\n    Given I am an administrator\n     When I create a sandbox named 'sandbox1' for cookbook 'testcookbook_invalid_empty_except_metadata'\n     Then the inflated responses key 'uri' should match '^http://.+/sandboxes/[^\\/]+$'\n     Then I upload a file named 'metadata.json' from cookbook 'testcookbook_invalid_empty_except_metadata' to the sandbox\n     Then the response code should be '200'\n     Then I upload a file named 'metadata.rb' from cookbook 'testcookbook_invalid_empty_except_metadata' to the sandbox\n     Then the response code should be '200'\n     When I commit the sandbox\n     Then I should not get an exception\n     When I create a cookbook named 'testcookbook_invalid_empty_except_metadata' with only the metadata file\n     Then I should get a '400 \"Bad Request\"' exception\n\n  @freeze_cookbook_version\n  Scenario: Create a frozen Cookbook Version\n    Given I am an administrator\n      And I have uploaded a frozen cookbook named 'testcookbook_valid' at version '0.1.0'\n     When I 'GET' the path '/cookbooks/testcookbook_valid/0.1.0'\n     Then the cookbook version document should be frozen\n\n  @freeze_cookbook_version @overwrite_frozen_version\n  Scenario: Cannot overwrite a frozen Cookbook Version\n    Given I am an administrator\n      And I have uploaded a frozen cookbook named 'testcookbook_valid' at version '0.1.0'\n     When I upload a cookbook named 'testcookbook_valid' at version '0.1.0'\n     Then I should get a '409 \"Conflict\"' exception\n", "# Copyright:: Copyright (c) 2008 Opscode, Inc.\n# License:: Apache License, Version 2.0\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n\nThread.abort_on_exception = true\n\nrequire 'rubygems'\nrequire 'rspec/expectations'\n\nCHEF_PROJECT_ROOT = File.expand_path(File.dirname(__FILE__) + '/../../')\nKNIFE_CONFIG = CHEF_PROJECT_ROOT + '/features/data/config/knife.rb'\nKNIFE_CMD = File.expand_path(File.join(CHEF_PROJECT_ROOT, \"chef\", \"bin\", \"knife\"))\nFEATURES_DATA = File.join(CHEF_PROJECT_ROOT, \"features\", \"data\")\nINTEGRATION_COOKBOOKS = File.join(FEATURES_DATA, \"cookbooks\")\nEXTRA_COOKBOOKS = File.join(FEATURES_DATA, \"cookbooks_not_uploaded_at_feature_start\")\n\n$:.unshift(CHEF_PROJECT_ROOT)\n$:.unshift(CHEF_PROJECT_ROOT + '/chef/lib')\n$:.unshift(CHEF_PROJECT_ROOT + '/chef-server-api/lib')\n$:.unshift(CHEF_PROJECT_ROOT + '/chef-server-webui/lib')\n$:.unshift(CHEF_PROJECT_ROOT + '/chef-solr/lib')\n\nrequire 'chef'\nrequire 'chef/config'\nrequire 'chef/client'\nrequire 'chef/environment'\nrequire 'chef/data_bag'\nrequire 'chef/data_bag_item'\nrequire 'chef/api_client'\nrequire 'chef/checksum'\nrequire 'chef/sandbox'\nrequire 'chef/solr_query'\nrequire 'chef/certificate'\nrequire 'chef/cookbook_version'\nrequire 'chef/cookbook_loader'\nrequire 'chef/mixin/shell_out'\nrequire 'tmpdir'\nrequire 'chef/streaming_cookbook_uploader'\nrequire 'webrick'\nrequire 'restclient'\nrequire 'features/support/couchdb_replicate'\n\ninclude Chef::Mixin::ShellOut\n\nOhai::Config[:disabled_plugins] << 'darwin::system_profiler' << 'darwin::kernel' << 'darwin::ssh_host_key' << 'network_listeners'\nOhai::Config[:disabled_plugins ]<< 'darwin::uptime' << 'darwin::filesystem' << 'dmi' << 'lanuages' << 'perl' << 'python' << 'java'\n\nENV['LOG_LEVEL'] ||= 'error'\n\ndef setup_logging\n  Chef::Config.from_file(File.join(File.dirname(__FILE__), '..', 'data', 'config', 'server.rb'))\n  if ENV['DEBUG'] == 'true' || ENV['LOG_LEVEL'] == 'debug'\n    Chef::Config[:log_level] = :debug\n    Chef::Log.level = :debug\n  else\n    Chef::Config[:log_level] = ENV['LOG_LEVEL'].to_sym\n    Chef::Log.level = ENV['LOG_LEVEL'].to_sym\n  end\n  Ohai::Log.logger = Chef::Log.logger\nend\n\ndef delete_databases\n  c = Chef::REST.new(Chef::Config[:couchdb_url], nil, nil)\n  %w{chef_integration chef_integration_safe}.each do |db|\n    begin\n      c.delete_rest(\"#{db}/\")\n    rescue\n    end\n  end\nend\n\ndef create_databases\n  Chef::Log.info(\"Creating bootstrap databases\")\n  cdb = Chef::CouchDB.new(Chef::Config[:couchdb_url], \"chef_integration\")\n\n  # Sometimes Couch returns a '412 Precondition Failed' when creating a database,\n  # via a PUT to its URL, as the DELETE from the previous step in delete_databases\n  # has not yet finished. This condition disappears if you try again. So here we\n  # try up to 10 times if PreconditionFailed occurs. See\n  #   http://tickets.opscode.com/browse/CHEF-1788 and\n  #   http://tickets.opscode.com/browse/CHEF-1764.\n  #\n  # According to https://issues.apache.org/jira/browse/COUCHDB-449, setting the\n  # 'X-Couch-Full-Commit: true' header on the DELETE should work around this issue,\n  # but it does not.\n  db_created = nil\n  max_tries = 10\n  num_tries = 1\n  while !db_created && num_tries <= max_tries\n    begin\n      cdb.create_db\n      db_created = true\n    rescue Net::HTTPServerException => e\n      unless e.response.code.to_i == 412\n        # Re-raise if we got anything but 412.\n        raise\n      end\n\n      if num_tries <= max_tries\n        Chef::Log.debug(\"In creating chef_integration try #{num_tries}/#{max_tries}, got #{e}; try again\")\n        sleep 0.25\n      else\n        Chef::Log.error(\"In creating chef_integration, tried #{max_tries} times: got #{e}; giving up\")\n      end\n    end\n    num_tries += 1\n  end\n\n  cdb.create_id_map\n  Chef::Node.create_design_document\n  Chef::Role.create_design_document\n  Chef::DataBag.create_design_document\n  Chef::ApiClient.create_design_document\n  Chef::WebUIUser.create_design_document\n  Chef::CookbookVersion.create_design_document\n  Chef::Sandbox.create_design_document\n  Chef::Checksum.create_design_document\n  Chef::Environment.create_design_document\n\n  Chef::Certificate.generate_signing_ca\n  Chef::Certificate.gen_validation_key\n  Chef::Certificate.gen_validation_key(Chef::Config[:web_ui_client_name], Chef::Config[:web_ui_key])\n  Chef::Environment.create_default_environment\n  system(\"cp #{File.join(Dir.tmpdir, \"chef_integration\", \"validation.pem\")} #{Dir.tmpdir}\")\n  system(\"cp #{File.join(Dir.tmpdir, \"chef_integration\", \"webui.pem\")} #{Dir.tmpdir}\")\n\n  cmd = [KNIFE_CMD, \"cookbook\", \"upload\", \"-a\", \"-o\", INTEGRATION_COOKBOOKS, \"-u\", \"validator\", \"-k\", File.join(Dir.tmpdir, \"validation.pem\"), \"-c\", KNIFE_CONFIG]\n  Chef::Log.info(\"Uploading fixture cookbooks with #{cmd.join(' ')}\")\n  cmd << {:timeout => 120}\n  shell_out!(*cmd)\nend\n\ndef prepare_replicas\n  replicate_dbs({ :source_db => \"#{Chef::Config[:couchdb_url]}/chef_integration\", :target_db => \"#{Chef::Config[:couchdb_url]}/chef_integration_safe\" })\nend\n\ndef cleanup\n  if File.exists?(Chef::Config[:validation_key])\n    File.unlink(Chef::Config[:validation_key])\n  end\n  if File.exists?(Chef::Config[:web_ui_key])\n    File.unlink(Chef::Config[:web_ui_key])\n  end\nend\n\n###\n# Pre-testing setup\n###\nsetup_logging\ncleanup\ndelete_databases\ncreate_databases\nprepare_replicas\n\nChef::Log.info(\"Ready to run tests\")\n\n###\n# The Cucumber World\n###\nmodule ChefWorld\n\n  attr_accessor :recipe, :cookbook, :api_response, :inflated_response, :log_level,\n                :chef_args, :config_file, :stdout, :stderr, :status, :exception,\n                :gemserver_thread, :sandbox_url\n\n  def self.ohai\n    # ohai takes a while, so only ever run it once.\n    @ohai ||= begin\n      o = Ohai::System.new\n      o.all_plugins\n      o\n    end\n  end\n\n  def ohai\n    ChefWorld.ohai\n  end\n\n  def client\n    @client ||= begin\n      c = Chef::Client.new\n      c.ohai = ohai\n      c\n    end\n  end\n\n  def client_key\n    File.join(tmpdir, \"client.pem\")\n  end\n\n  def rest\n    @rest ||= Chef::REST.new('http://localhost:4000', nil, nil)\n  end\n\n  def tmpdir\n    @tmpdir ||= File.join(Dir.tmpdir, \"chef_integration\")\n  end\n\n  def server_tmpdir\n    @server_tmpdir ||= File.expand_path(File.join(datadir, \"tmp\"))\n  end\n\n  def datadir\n    @datadir ||= File.join(File.dirname(__FILE__), \"..\", \"data\")\n  end\n\n  def configdir\n    @configdir ||= File.join(File.dirname(__FILE__), \"..\", \"data\", \"config\")\n  end\n\n  def cleanup_files\n    @cleanup_files ||= Array.new\n  end\n\n  def cleanup_dirs\n    @cleanup_dirs ||= Array.new\n  end\n\n  def stash\n    @stash ||= Hash.new\n  end\n\n  def gemserver\n    @gemserver ||= WEBrick::HTTPServer.new(\n      :Port         => 8000,\n      :DocumentRoot => datadir + \"/gems/\",\n      # Make WEBrick STFU\n      :Logger       => Logger.new(StringIO.new),\n      :AccessLog    => [ StringIO.new, WEBrick::AccessLog::COMMON_LOG_FORMAT ]\n    )\n  end\n\n  attr_accessor :apt_server_thread\n\n  def apt_server\n    @apt_server ||= WEBrick::HTTPServer.new(\n      :Port         => 9000,\n      :DocumentRoot => datadir + \"/apt/var/www/apt\",\n      # Make WEBrick STFU\n      :Logger       => Logger.new(StringIO.new),\n      :AccessLog    => [ StringIO.new, WEBrick::AccessLog::COMMON_LOG_FORMAT ]\n    )\n  end\n\n  def make_admin\n    admin_client\n    @rest = Chef::REST.new(Chef::Config[:registration_url], 'bobo', \"#{tmpdir}/bobo.pem\")\n    #Chef::Config[:client_key] = \"#{tmpdir}/bobo.pem\"\n    #Chef::Config[:node_name] = \"bobo\"\n  end\n\n  def admin_rest\n    admin_client\n    @admin_rest ||= Chef::REST.new(Chef::Config[:registration_url], 'bobo', \"#{tmpdir}/bobo.pem\")\n  end\n\n  def admin_client\n    unless @admin_client\n      r = Chef::REST.new(Chef::Config[:registration_url], Chef::Config[:validation_client_name], Chef::Config[:validation_key])\n      r.register(\"bobo\", \"#{tmpdir}/bobo.pem\")\n      c = Chef::ApiClient.cdb_load(\"bobo\")\n      c.admin(true)\n      c.cdb_save\n      @admin_client = c\n    end\n  end\n\n  def make_non_admin\n    r = Chef::REST.new(Chef::Config[:registration_url], Chef::Config[:validation_client_name], Chef::Config[:validation_key])\n    r.register(\"not_admin\", \"#{tmpdir}/not_admin.pem\")\n    c = Chef::ApiClient.cdb_load(\"not_admin\")\n    c.cdb_save\n    @rest = Chef::REST.new(Chef::Config[:registration_url], 'not_admin', \"#{tmpdir}/not_admin.pem\")\n    #Chef::Config[:client_key] = \"#{tmpdir}/not_admin.pem\"\n    #Chef::Config[:node_name] = \"not_admin\"\n  end\n\n  def couchdb_rest_client\n    Chef::REST.new('http://localhost:5984/chef_integration', false, false)\n  end\n\n\nend\n\nWorld(ChefWorld)\n\nBefore do\n  data_tmp = File.join(File.dirname(__FILE__), \"..\", \"data\", \"tmp\")\n  system(\"rm -rf #{data_tmp}/*\")\n  system(\"rm -rf #{tmpdir}\")\n\n  system(\"mkdir -p #{tmpdir}\")\n  system(\"cp -r #{File.join(Dir.tmpdir, \"validation.pem\")} #{File.join(tmpdir, \"validation.pem\")}\")\n  system(\"cp -r #{File.join(Dir.tmpdir, \"webui.pem\")} #{File.join(tmpdir, \"webui.pem\")}\")\n\n  replicate_dbs({:source_db => \"#{Chef::Config[:couchdb_url]}/chef_integration_safe\",\n                 :target_db => \"#{Chef::Config[:couchdb_url]}/chef_integration\"})\n\n  s = Chef::SolrQuery.new\n  s.delete_database(\"chef_integration\")\n  s.commit\nend\n\nAfter do\n  gemserver.shutdown\n  gemserver_thread && gemserver_thread.join\n\n  apt_server.shutdown\n  apt_server_thread && apt_server_thread.join\n\n  cleanup_files.each do |file|\n    system(\"rm #{file}\")\n  end\n  cleanup_dirs.each do |dir|\n    system(\"rm -rf #{dir}\")\n  end\n  cj = Chef::REST::CookieJar.instance\n  cj.keys.each do |key|\n    cj.delete(key)\n  end\nend\n"], "fixing_code": ["#\n# Author:: Adam Jacob (<adam@opscode.com>)\n# Author:: Christopher Brown (<cb@opscode.com>)\n# Author:: Christopher Walters (<cw@opscode.com>)\n# Author:: Tim Hinderliter (<tim@opscode.com>)\n# Copyright:: Copyright (c) 2008, 2009, 2010 Opscode, Inc.\n# License:: Apache License, Version 2.0\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n\nrequire 'chef/cookbook_loader'\nrequire 'chef/cookbook/metadata'\n\nclass Cookbooks < Application\n\n  include Merb::CookbookVersionHelper\n\n  provides :json\n\n  before :authenticate_every\n  before :params_helper\n  before :is_admin, :only => [ :update, :destroy ]\n\n  attr_accessor :cookbook_name, :cookbook_version\n\n  def params_helper\n    self.cookbook_name = params[:cookbook_name]\n    self.cookbook_version = params[:cookbook_version]\n  end\n\n  include Chef::Mixin::Checksum\n  include Merb::TarballHelper\n\n  def index\n    if request.env['HTTP_X_CHEF_VERSION'] =~ /0\\.9/\n      index_09\n    else\n      index_010\n    end\n  end\n\n  # GET /cookbooks\n  # returns data in the format of:\n  # {\"apache2\" => {\n  #     :url => \"http://url\",\n  #     :versions => [{:url => \"http://url/1.0.0\", :version => \"1.0.0\"}, {:url => \"http://url/0.0.1\", :version=>\"0.0.1\"}]\n  #   }\n  # }\n  def index_010\n    cookbook_list = Chef::CookbookVersion.cdb_list\n    # cookbook_list is in the format of {\"apache2\" => [0.0.1, 0.0.0]} where the version numbers are DepSelector::Version objects\n    num_versions = num_versions!\n    display(cookbook_list.inject({}) {|res, (cookbook_name, versions)|\n      versions = versions.map{ |x| DepSelector::Version.new(x) }.sort.reverse.map{ |x| x.to_s }\n      res[cookbook_name] = expand_cookbook_urls(cookbook_name, versions, num_versions)\n      res\n    })\n  end\n\n  # GET /cookbooks\n  #\n  # returns data in the format of:\n  # {\n  #   \"apache2\" => \"http://url/apache2\",\n  #   \"python\" => \"http://url/python\"\n  # }\n  def index_09\n    cookbook_list = Chef::CookbookVersion.cdb_list_latest(false).keys.sort\n    response = Hash.new\n    cookbook_list.map! do |cookbook_name|\n      response[cookbook_name] = absolute_url(:cookbook, :cookbook_name => cookbook_name)\n    end\n    display response\n  end\n\n  def index_recipes\n    recipes_with_versions = Chef::CookbookVersion.cdb_list(true).inject({}) do|memo, f|\n      memo[f.name] ||= {}\n      memo[f.name][f.version] = f.recipe_filenames_by_name.keys\n      memo\n    end\n    display recipes_with_versions\n  end\n\n  def show_versions\n    if request.env['HTTP_X_CHEF_VERSION'] =~ /0\\.9/\n      show_versions_09\n    else\n      show_versions_010\n    end\n  end\n\n  # GET /cookbooks/:cookbook_name\n  #\n  # returns data in the format of:\n  # {\"apache2\" => {\n  #     :url => \"http://url\",\n  #     :versions => [{:url => \"http://url/1.0.0\", :version => \"1.0.0\"}, {:url => \"http://url/0.0.1\", :version=>\"0.0.1\"}]\n  #   }\n  # }\n  def show_versions_010\n    versions = Chef::CookbookVersion.cdb_by_name(cookbook_name)\n    raise NotFound, \"Cannot find a cookbook named #{cookbook_name}\" unless versions && versions.size > 0\n    num_versions = num_versions!(\"all\")\n    cb_versions = versions[cookbook_name].map{ |x| DepSelector::Version.new(x) }.sort.reverse.map{ |x| x.to_s }\n    display({ cookbook_name => expand_cookbook_urls(cookbook_name, cb_versions, num_versions) })\n  end\n\n  # GET /cookbooks/:cookbook_name\n  #\n  # returns data in the format of:\n  # {\"apache2\" => [\"1.0.0\", \"0.0.1\"]}\n  def show_versions_09\n    versions = Chef::CookbookVersion.cdb_by_name(cookbook_name)\n    raise NotFound, \"Cannot find a cookbook named #{requested_cookbook_name}\" unless versions && versions.size > 0\n\n    display versions\n  end\n\n  def show\n    cookbook = get_cookbook_version(cookbook_name, cookbook_version)\n    display cookbook.generate_manifest_with_urls { |opts| absolute_url(:cookbook_file, opts) }\n  end\n\n  def show_file\n    cookbook = get_cookbook_version(cookbook_name, cookbook_version)\n\n    checksum = params[:checksum]\n    raise NotFound, \"Cookbook #{cookbook_name} version #{cookbook_version} does not contain a file with checksum #{checksum}\" unless cookbook.checksums.keys.include?(checksum)\n\n    filename = Chef::Checksum.new(checksum).file_location\n    raise InternalServerError, \"File with checksum #{checksum} not found in the repository (this should not happen)\" unless File.exists?(filename)\n\n    send_file(filename)\n  end\n\n  def update\n    raise(BadRequest, \"You didn't pass me a valid object!\") unless params.has_key?('inflated_object')\n    raise(BadRequest, \"You didn't pass me a Chef::CookbookVersion object!\") unless params['inflated_object'].kind_of?(Chef::CookbookVersion)\n    unless params[\"inflated_object\"].name == cookbook_name\n      raise(BadRequest, \"You said the cookbook was named #{params['inflated_object'].name}, but the URL says it should be #{cookbook_name}.\")\n    end\n\n    unless params[\"inflated_object\"].version == cookbook_version\n      raise(BadRequest, \"You said the cookbook was version #{params['inflated_object'].version}, but the URL says it should be #{cookbook_version}.\")\n    end\n\n    begin\n      cookbook = Chef::CookbookVersion.cdb_load(cookbook_name, cookbook_version)\n      cookbook.manifest = params['inflated_object'].manifest\n    rescue Chef::Exceptions::CouchDBNotFound => e\n      Chef::Log.debug(\"Cookbook #{cookbook_name} version #{cookbook_version} does not exist\")\n      cookbook = params['inflated_object']\n    end\n\n    if cookbook.frozen_version? && params[:force].nil?\n      raise Conflict, \"The cookbook #{cookbook.name} at version #{cookbook.version} is frozen. Use the 'force' option to override.\"\n    end\n\n    cookbook.freeze_version if params[\"inflated_object\"].frozen_version?\n\n    # ensure that all checksums referred to by the manifest have been uploaded.\n    Chef::CookbookVersion::COOKBOOK_SEGMENTS.each do |segment|\n      next unless cookbook.manifest[segment]\n      cookbook.manifest[segment].each do |manifest_record|\n        checksum = manifest_record[:checksum]\n        path = manifest_record[:path]\n\n        begin\n          checksum_obj = Chef::Checksum.cdb_load(checksum)\n        rescue Chef::Exceptions::CouchDBNotFound => cdbx\n          checksum_obj = nil\n        end\n\n        raise BadRequest, \"Manifest has checksum #{checksum} (path #{path}) but it hasn't yet been uploaded\" unless checksum_obj\n      end\n    end\n\n    raise InternalServerError, \"Error saving cookbook\" unless cookbook.cdb_save\n\n    display cookbook\n  end\n\n  def destroy\n    begin\n      cookbook = get_cookbook_version(cookbook_name, cookbook_version)\n    rescue ArgumentError => e\n      raise NotFound, \"Cannot find a cookbook named #{cookbook_name} with version #{cookbook_version}\"\n    end\n\n    if params[\"purge\"] == \"true\"\n      display cookbook.purge\n    else\n      display cookbook.cdb_destroy\n    end\n  end\n\n  private\n\n  def get_cookbook_version(name, version)\n    Chef::CookbookVersion.cdb_load(name, version)\n  rescue Chef::Exceptions::CouchDBNotFound => e\n    raise NotFound, \"Cannot find a cookbook named #{name} with version #{version}\"\n  rescue Net::HTTPServerException => e\n    if e.to_s =~ /^404/\n      raise NotFound, \"Cannot find a cookbook named #{name} with version #{version}\"\n    else\n      raise\n    end\n  end\n\nend\n\n", "@api @cookbooks @api_cookbooks_delete\n@manage_cookbook\n\nFeature: CRUD cookbooks\n  In order to manage cookbook data\n  As a Developer\n  I want to delete cookbook versions\n\n  @delete_cookbook_positive @delete_cookbook_version_positive\n  Scenario: After uploading two versions of a cookbook, then deleting the second, I should not be able to interact with the second but should be able to interact with the first\n    Given I am an administrator\n     When I fully upload a sandboxed cookbook named 'testcookbook_valid' versioned '0.1.0' with 'testcookbook_valid'\n      And I fully upload a sandboxed cookbook force-named 'testcookbook_valid' versioned '0.2.0' with 'testcookbook_valid_v0.2.0'\n     When I 'GET' to the path '/cookbooks/testcookbook_valid/0.2.0'\n     Then I should not get an exception\n     When I 'DELETE' to the path '/cookbooks/testcookbook_valid/0.2.0'\n     When I 'GET' to the path '/cookbooks/testcookbook_valid'\n     Then the inflated responses key 'testcookbook_valid' should exist\n     Then the inflated responses key 'testcookbook_valid' sub-key 'versions' should be '1' items long\n     Then the inflated responses key 'testcookbook_valid' sub-key 'versions' item '0' sub-key 'version' should equal '0.1.0'\n     When I 'GET' to the path '/cookbooks/testcookbook_valid/0.2.0'\n     Then I should get a '404 \"Not Found\"' exception\n     When I download the cookbook manifest for 'testcookbook_valid' version '0.1.0'\n     Then I should not get an exception\n     When I download the file 'recipes/default.rb' from the downloaded cookbook manifest\n     Then the downloaded cookbook file contents should match the pattern '.*0.1.0.*'\n\n  @delete_cookbook_negative @delete_cookbook_version_negative\n  Scenario: I should not be able to delete a cookbook version that does not exist\n    Given I am an administrator\n     When I fully upload a sandboxed cookbook named 'testcookbook_valid' versioned '0.1.0' with 'testcookbook_valid'\n      And I fully upload a sandboxed cookbook force-named 'testcookbook_valid' versioned '0.2.0' with 'testcookbook_valid_v0.2.0'\n     When I 'DELETE' to the path '/cookbooks/testcookbook_valid/0.3.0'\n     Then I should get a '404 \"Not Found\"' exception\n\n  # Currently you cannot delete a cookbook by, e.g., DELETE /cookbooks/foo.\n  # You delete all of its versions and then it disappears.     \n  @delete_cookbook_positive\n  Scenario: I should be able to delete a cookbook by deleting all of its versions\n    Given I am an administrator\n     When I fully upload a sandboxed cookbook named 'testcookbook_valid' versioned '0.1.0' with 'testcookbook_valid'\n     When I 'DELETE' to the path '/cookbooks/testcookbook_valid/0.1.0'\n     Then I should not get an exception\n     When I 'GET' the path '/cookbooks'\n     Then the inflated responses key 'testcookbook_valid' should not exist\n     When I 'GET' the path '/cookbooks/testcookbook_valid'\n     Then I should get a '404 \"Not Found\"' exception\n     \n  @delete_cookbook_negative\n  Scenario: I should not be able to delete a cookbook that doesn't exist'\n    Given I am an administrator\n     When I 'DELETE' to the path '/cookbooks/testcookbook_nonexistent/1.2.3'\n     Then I should get a '404 \"Not Found\"' exception\n\n  @delete_cookbook_negative @cookbook_non_admin\n  Scenario: I should not be able to delete cookbook if I am not an admin\n    Given I am an administrator\n     When I fully upload a sandboxed cookbook named 'testcookbook_valid' versioned '0.1.0' with 'testcookbook_valid'\n    Given I am a non-admin\n     When I 'DELETE' to the path '/cookbooks/testcookbook_valid/0.1.0'\n     Then I should get a '403 \"Forbidden\"' exception\n", "@api @cookbooks @api_cookbooks_upload\n@manage_cookbook\n\nFeature: CRUD cookbooks\n  In order to manage cookbook data\n  As a Developer\n  I want to create and upload cookbook files and manifests\n\n  @create_cookbook_negative\n\n  Scenario: Should not be able to create a cookbook with the wrong name\n    Given I am an administrator\n     When I create a versioned cookbook named 'foo' versioned '1.0.0' with 'testcookbook_valid'\n     Then I should get a '400 \"Bad Request\"' exception\n\n  Scenario: Should not be able to create a cookbook with the wrong version\n    Given I am an administrator\n     When I create a versioned cookbook named 'testcookbook_valid' versioned '9.9.9' with 'testcookbook_valid'\n     Then I should get a '400 \"Bad Request\"' exception\n\n  Scenario: Should not be able to create a cookbook with missing name\n    Given I am an administrator\n     When I create a versioned cookbook named '' versioned '9.9.9' with 'testcookbook_valid'\n     Then I should get a '404 \"Not Found\"' exception\n\n  Scenario: Should not be able to create a cookbook with missing name and version\n    Given I am an administrator\n     When I create a versioned cookbook named '' versioned '' with 'testcookbook_valid'\n     Then I should get a '404 \"Not Found\"' exception\n\n  Scenario: Should not be able to create a cookbook with non-X.Y.Z version\n    Given I am an administrator\n     When I create a versioned cookbook named 'testcookbook_valid' versioned '1.0' with 'testcookbook_valid'\n     Then I should get a '404 \"Not Found\"' exception\n\n  Scenario: Should not be able to create a cookbook if none of its contained files have been uploaded\n    Given I am an administrator\n     When I create a versioned cookbook named 'testcookbook_valid' versioned '0.1.0' with 'testcookbook_valid'\n     Then I should get a '400 \"Bad Request\"' exception\n\n  @create_cookbook_positive\n  Scenario: Should be able to create a cookbook if its files have been uploaded\n    Given I am an administrator\n     When I create a sandbox named 'sandbox1' for cookbook 'testcookbook_valid'\n     Then the inflated responses key 'uri' should match '^http://.+/sandboxes/[^\\/]+$'\n     Then I upload a file named 'metadata.json' from cookbook 'testcookbook_valid' to the sandbox\n     Then the response code should be '200'\n     Then I upload a file named 'metadata.rb' from cookbook 'testcookbook_valid' to the sandbox\n     Then the response code should be '200'\n     Then I upload a file named 'attributes/attributes.rb' from cookbook 'testcookbook_valid' to the sandbox\n     Then the response code should be '200'\n     Then I upload a file named 'recipes/default.rb' from cookbook 'testcookbook_valid' to the sandbox\n     Then the response code should be '200'\n     When I commit the sandbox\n     Then I should not get an exception\n     When I create a versioned cookbook named 'testcookbook_valid' versioned '0.1.0' with 'testcookbook_valid'\n     Then I should not get an exception\n     \n  @create_cookbook_positive\n  Scenario: Cookbook successfully uploaded via sandbox should later be visible via /cookbooks, including its versions and metadata\n    Given I am an administrator\n     When I fully upload a sandboxed cookbook named 'testcookbook_valid' versioned '0.1.0' with 'testcookbook_valid'\n     When I 'GET' the path '/cookbooks'\n     Then the inflated responses key 'testcookbook_valid' should exist\n     When I 'GET' the path '/cookbooks/testcookbook_valid'\n     Then the inflated responses key 'testcookbook_valid' should exist\n     Then the inflated responses key 'testcookbook_valid' sub-key 'versions' item '0' sub-key 'version' should equal '0.1.0'\n     When I 'GET' the path '/cookbooks/testcookbook_valid/0.1.0'\n     Then the inflated response should match '.*default.rb.*' as json\n\n  @create_multiple_cookbook_versions_positive\n  Scenario: Multiple cookbook versions successfully uploaded are visible\n    Given I am an administrator\n      And I fully upload a sandboxed cookbook named 'testcookbook_valid' versioned '0.1.0' with 'testcookbook_valid'\n      And I fully upload a sandboxed cookbook force-named 'testcookbook_valid' versioned '0.2.0' with 'testcookbook_valid_v0.2.0'\n     When I 'GET' the path '/cookbooks'\n     Then the inflated responses key 'testcookbook_valid' should exist\n     When I 'GET' the path '/cookbooks/testcookbook_valid'\n     Then the inflated responses key 'testcookbook_valid' should exist\n      And the inflated responses key 'testcookbook_valid' sub-key 'versions' should be '2' items long\n      And the inflated responses key 'testcookbook_valid' sub-key 'versions' item '0' sub-key 'version' should equal '0.2.0'\n      And the inflated responses key 'testcookbook_valid' sub-key 'versions' item '1' sub-key 'version' should equal '0.1.0'\n\n  @update_cookbook_version_metadata_positive\n  Scenario: A successful cookbook version upload that changes the metadata is properly reflected\n    Given I am an administrator\n      And I fully upload a sandboxed cookbook named 'testcookbook_valid' versioned '0.1.0' with 'testcookbook_valid'\n     When I 'GET' the path '/cookbooks/testcookbook_valid/0.1.0'\n     Then the inflated response should be a kind of 'Chef::CookbookVersion'\n      And the dependencies in its metadata should be an empty hash\n     When I fully upload a sandboxed cookbook force-named 'testcookbook_valid' versioned '0.1.0' with 'testcookbook_valid_v0.1.0_with_different_dependencies'\n     Then the inflated response should be a kind of 'Chef::CookbookVersion'\n      And the metadata should include a dependency on 'aws'\n\n  # The sandbox is created missing 'metadata.json'. However, the cookbook's\n  # manifest includes that file. We don't upload the file to the sandbox, but\n  # the sandbox commits ok cuz it wasn't expecting that file. However, when we\n  # try to create the cookbook, it should complain as its manifest wants that\n  # file.\n  @create_cookbook_negative\n  Scenario: Should not be able to create a cookbook if it is missing one file\n    Given I am an administrator\n     When I create a sandbox named 'sandbox1' for cookbook 'testcookbook_valid' minus files 'metadata.rb'\n     Then the inflated responses key 'uri' should match '^http://.+/sandboxes/[^\\/]+$'\n     Then I upload a file named 'metadata.json' from cookbook 'testcookbook_valid' to the sandbox\n     Then the response code should be '200'\n     Then I upload a file named 'attributes/attributes.rb' from cookbook 'testcookbook_valid' to the sandbox\n     Then the response code should be '200'\n     Then I upload a file named 'recipes/default.rb' from cookbook 'testcookbook_valid' to the sandbox\n     Then the response code should be '200'\n     When I commit the sandbox\n     Then I should not get an exception\n     When I create a versioned cookbook named 'testcookbook_valid' versioned '0.1.0' with 'testcookbook_valid'\n     Then I should get a '400 \"Bad Request\"' exception\n  \n  @create_cookbook_negative\n  Scenario: Should not be able to create a cookbook if it has no metadata file\n    Given I am an administrator\n     When I create a sandbox named 'sandbox1' for cookbook 'testcookbook_invalid_nometadata'\n     Then the inflated responses key 'uri' should match '^http://.+/sandboxes/[^\\/]+$'\n     Then I upload a file named 'attributes/attributes.rb' from cookbook 'testcookbook_invalid_nometadata' to the sandbox\n     Then the response code should be '200'\n     Then I upload a file named 'recipes/default.rb' from cookbook 'testcookbook_invalid_nometadata' to the sandbox\n     Then the response code should be '200'\n     When I commit the sandbox\n     Then I should not get an exception\n     When I create a versioned cookbook named 'testcookbook_invalid_nometadata' versioned '0.1.0' with 'testcookbook_invalid_nometadata'\n     Then I should get a '400 \"Bad Request\"' exception\n    \n  #  update a cookbook with no files should fail\n  @create_cookbook_negative\n  Scenario: Should not be able to create a cookbook if it has no files and just metadata\n    Given I am an administrator\n     When I create a sandbox named 'sandbox1' for cookbook 'testcookbook_invalid_empty_except_metadata'\n     Then the inflated responses key 'uri' should match '^http://.+/sandboxes/[^\\/]+$'\n     Then I upload a file named 'metadata.json' from cookbook 'testcookbook_invalid_empty_except_metadata' to the sandbox\n     Then the response code should be '200'\n     Then I upload a file named 'metadata.rb' from cookbook 'testcookbook_invalid_empty_except_metadata' to the sandbox\n     Then the response code should be '200'\n     When I commit the sandbox\n     Then I should not get an exception\n     When I create a cookbook named 'testcookbook_invalid_empty_except_metadata' with only the metadata file\n     Then I should get a '400 \"Bad Request\"' exception\n\n  @freeze_cookbook_version\n  Scenario: Create a frozen Cookbook Version\n    Given I am an administrator\n      And I have uploaded a frozen cookbook named 'testcookbook_valid' at version '0.1.0'\n     When I 'GET' the path '/cookbooks/testcookbook_valid/0.1.0'\n     Then the cookbook version document should be frozen\n\n  @freeze_cookbook_version @overwrite_frozen_version\n  Scenario: Cannot overwrite a frozen Cookbook Version\n    Given I am an administrator\n      And I have uploaded a frozen cookbook named 'testcookbook_valid' at version '0.1.0'\n     When I upload a cookbook named 'testcookbook_valid' at version '0.1.0'\n     Then I should get a '409 \"Conflict\"' exception\n\n  @create_cookbook_negative @cookbook_non_admin\n  Scenario: Should not be able to create a cookbook if I am not an admin\n    Given I am an administrator\n     When I create a sandbox named 'sandbox1' for cookbook 'testcookbook_valid'\n     Then the inflated responses key 'uri' should match '^http://.+/sandboxes/[^\\/]+$'\n     Then I upload a file named 'metadata.json' from cookbook 'testcookbook_valid' to the sandbox\n     Then the response code should be '200'\n     Then I upload a file named 'metadata.rb' from cookbook 'testcookbook_valid' to the sandbox\n     Then the response code should be '200'\n     Then I upload a file named 'attributes/attributes.rb' from cookbook 'testcookbook_valid' to the sandbox\n     Then the response code should be '200'\n     Then I upload a file named 'recipes/default.rb' from cookbook 'testcookbook_valid' to the sandbox\n     Then the response code should be '200'\n     When I commit the sandbox\n     Then I should not get an exception\n    Given I am a non-admin\n     When I create a versioned cookbook named 'testcookbook_valid' versioned '0.1.0' with 'testcookbook_valid'\n     Then I should get a '403 \"Forbidden\"' exception\n", "# Copyright:: Copyright (c) 2008 Opscode, Inc.\n# License:: Apache License, Version 2.0\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n\nThread.abort_on_exception = true\n\nrequire 'rubygems'\nrequire 'rspec/expectations'\n\nCHEF_PROJECT_ROOT = File.expand_path(File.dirname(__FILE__) + '/../../')\nKNIFE_CONFIG = CHEF_PROJECT_ROOT + '/features/data/config/knife.rb'\nKNIFE_CMD = File.expand_path(File.join(CHEF_PROJECT_ROOT, \"chef\", \"bin\", \"knife\"))\nFEATURES_DATA = File.join(CHEF_PROJECT_ROOT, \"features\", \"data\")\nINTEGRATION_COOKBOOKS = File.join(FEATURES_DATA, \"cookbooks\")\nEXTRA_COOKBOOKS = File.join(FEATURES_DATA, \"cookbooks_not_uploaded_at_feature_start\")\n\n$:.unshift(CHEF_PROJECT_ROOT)\n$:.unshift(CHEF_PROJECT_ROOT + '/chef/lib')\n$:.unshift(CHEF_PROJECT_ROOT + '/chef-server-api/lib')\n$:.unshift(CHEF_PROJECT_ROOT + '/chef-server-webui/lib')\n$:.unshift(CHEF_PROJECT_ROOT + '/chef-solr/lib')\n\nrequire 'chef'\nrequire 'chef/config'\nrequire 'chef/client'\nrequire 'chef/environment'\nrequire 'chef/data_bag'\nrequire 'chef/data_bag_item'\nrequire 'chef/api_client'\nrequire 'chef/checksum'\nrequire 'chef/sandbox'\nrequire 'chef/solr_query'\nrequire 'chef/certificate'\nrequire 'chef/cookbook_version'\nrequire 'chef/cookbook_loader'\nrequire 'chef/mixin/shell_out'\nrequire 'tmpdir'\nrequire 'chef/streaming_cookbook_uploader'\nrequire 'webrick'\nrequire 'restclient'\nrequire 'features/support/couchdb_replicate'\n\ninclude Chef::Mixin::ShellOut\n\nOhai::Config[:disabled_plugins] << 'darwin::system_profiler' << 'darwin::kernel' << 'darwin::ssh_host_key' << 'network_listeners'\nOhai::Config[:disabled_plugins ]<< 'darwin::uptime' << 'darwin::filesystem' << 'dmi' << 'lanuages' << 'perl' << 'python' << 'java'\n\nENV['LOG_LEVEL'] ||= 'error'\n\ndef setup_logging\n  Chef::Config.from_file(File.join(File.dirname(__FILE__), '..', 'data', 'config', 'server.rb'))\n  if ENV['DEBUG'] == 'true' || ENV['LOG_LEVEL'] == 'debug'\n    Chef::Config[:log_level] = :debug\n    Chef::Log.level = :debug\n  else\n    Chef::Config[:log_level] = ENV['LOG_LEVEL'].to_sym\n    Chef::Log.level = ENV['LOG_LEVEL'].to_sym\n  end\n  Ohai::Log.logger = Chef::Log.logger\nend\n\ndef delete_databases\n  c = Chef::REST.new(Chef::Config[:couchdb_url], nil, nil)\n  %w{chef_integration chef_integration_safe}.each do |db|\n    begin\n      c.delete_rest(\"#{db}/\")\n    rescue\n    end\n  end\nend\n\ndef create_databases\n  Chef::Log.info(\"Creating bootstrap databases\")\n  cdb = Chef::CouchDB.new(Chef::Config[:couchdb_url], \"chef_integration\")\n\n  # Sometimes Couch returns a '412 Precondition Failed' when creating a database,\n  # via a PUT to its URL, as the DELETE from the previous step in delete_databases\n  # has not yet finished. This condition disappears if you try again. So here we\n  # try up to 10 times if PreconditionFailed occurs. See\n  #   http://tickets.opscode.com/browse/CHEF-1788 and\n  #   http://tickets.opscode.com/browse/CHEF-1764.\n  #\n  # According to https://issues.apache.org/jira/browse/COUCHDB-449, setting the\n  # 'X-Couch-Full-Commit: true' header on the DELETE should work around this issue,\n  # but it does not.\n  db_created = nil\n  max_tries = 10\n  num_tries = 1\n  while !db_created && num_tries <= max_tries\n    begin\n      cdb.create_db\n      db_created = true\n    rescue Net::HTTPServerException => e\n      unless e.response.code.to_i == 412\n        # Re-raise if we got anything but 412.\n        raise\n      end\n\n      if num_tries <= max_tries\n        Chef::Log.debug(\"In creating chef_integration try #{num_tries}/#{max_tries}, got #{e}; try again\")\n        sleep 0.25\n      else\n        Chef::Log.error(\"In creating chef_integration, tried #{max_tries} times: got #{e}; giving up\")\n      end\n    end\n    num_tries += 1\n  end\n\n  cdb.create_id_map\n  Chef::Node.create_design_document\n  Chef::Role.create_design_document\n  Chef::DataBag.create_design_document\n  Chef::ApiClient.create_design_document\n  Chef::WebUIUser.create_design_document\n  Chef::CookbookVersion.create_design_document\n  Chef::Sandbox.create_design_document\n  Chef::Checksum.create_design_document\n  Chef::Environment.create_design_document\n\n  Chef::Certificate.generate_signing_ca\n  Chef::Certificate.gen_validation_key\n  Chef::Certificate.gen_validation_key(Chef::Config[:web_ui_client_name], Chef::Config[:web_ui_key])\n  Chef::Environment.create_default_environment\n  system(\"cp #{File.join(Dir.tmpdir, \"chef_integration\", \"validation.pem\")} #{Dir.tmpdir}\")\n  system(\"cp #{File.join(Dir.tmpdir, \"chef_integration\", \"webui.pem\")} #{Dir.tmpdir}\")\n  c = Chef::ApiClient.cdb_load(Chef::Config[:web_ui_client_name])\n  c.admin(true)\n  c.cdb_save\n\n  cmd = [KNIFE_CMD, \"cookbook\", \"upload\", \"-a\", \"-o\", INTEGRATION_COOKBOOKS, \"-u\", Chef::Config[:web_ui_client_name], \"-k\", File.join(Dir.tmpdir, \"webui.pem\"), \"-c\", KNIFE_CONFIG]\n  Chef::Log.info(\"Uploading fixture cookbooks with #{cmd.join(' ')}\")\n  cmd << {:timeout => 120}\n  shell_out!(*cmd)\nend\n\ndef prepare_replicas\n  replicate_dbs({ :source_db => \"#{Chef::Config[:couchdb_url]}/chef_integration\", :target_db => \"#{Chef::Config[:couchdb_url]}/chef_integration_safe\" })\nend\n\ndef cleanup\n  if File.exists?(Chef::Config[:validation_key])\n    File.unlink(Chef::Config[:validation_key])\n  end\n  if File.exists?(Chef::Config[:web_ui_key])\n    File.unlink(Chef::Config[:web_ui_key])\n  end\nend\n\n###\n# Pre-testing setup\n###\nsetup_logging\ncleanup\ndelete_databases\ncreate_databases\nprepare_replicas\n\nChef::Log.info(\"Ready to run tests\")\n\n###\n# The Cucumber World\n###\nmodule ChefWorld\n\n  attr_accessor :recipe, :cookbook, :api_response, :inflated_response, :log_level,\n                :chef_args, :config_file, :stdout, :stderr, :status, :exception,\n                :gemserver_thread, :sandbox_url\n\n  def self.ohai\n    # ohai takes a while, so only ever run it once.\n    @ohai ||= begin\n      o = Ohai::System.new\n      o.all_plugins\n      o\n    end\n  end\n\n  def ohai\n    ChefWorld.ohai\n  end\n\n  def client\n    @client ||= begin\n      c = Chef::Client.new\n      c.ohai = ohai\n      c\n    end\n  end\n\n  def client_key\n    File.join(tmpdir, \"client.pem\")\n  end\n\n  def rest\n    @rest ||= Chef::REST.new('http://localhost:4000', nil, nil)\n  end\n\n  def tmpdir\n    @tmpdir ||= File.join(Dir.tmpdir, \"chef_integration\")\n  end\n\n  def server_tmpdir\n    @server_tmpdir ||= File.expand_path(File.join(datadir, \"tmp\"))\n  end\n\n  def datadir\n    @datadir ||= File.join(File.dirname(__FILE__), \"..\", \"data\")\n  end\n\n  def configdir\n    @configdir ||= File.join(File.dirname(__FILE__), \"..\", \"data\", \"config\")\n  end\n\n  def cleanup_files\n    @cleanup_files ||= Array.new\n  end\n\n  def cleanup_dirs\n    @cleanup_dirs ||= Array.new\n  end\n\n  def stash\n    @stash ||= Hash.new\n  end\n\n  def gemserver\n    @gemserver ||= WEBrick::HTTPServer.new(\n      :Port         => 8000,\n      :DocumentRoot => datadir + \"/gems/\",\n      # Make WEBrick STFU\n      :Logger       => Logger.new(StringIO.new),\n      :AccessLog    => [ StringIO.new, WEBrick::AccessLog::COMMON_LOG_FORMAT ]\n    )\n  end\n\n  attr_accessor :apt_server_thread\n\n  def apt_server\n    @apt_server ||= WEBrick::HTTPServer.new(\n      :Port         => 9000,\n      :DocumentRoot => datadir + \"/apt/var/www/apt\",\n      # Make WEBrick STFU\n      :Logger       => Logger.new(StringIO.new),\n      :AccessLog    => [ StringIO.new, WEBrick::AccessLog::COMMON_LOG_FORMAT ]\n    )\n  end\n\n  def make_admin\n    admin_client\n    @rest = Chef::REST.new(Chef::Config[:registration_url], 'bobo', \"#{tmpdir}/bobo.pem\")\n    #Chef::Config[:client_key] = \"#{tmpdir}/bobo.pem\"\n    #Chef::Config[:node_name] = \"bobo\"\n  end\n\n  def admin_rest\n    admin_client\n    @admin_rest ||= Chef::REST.new(Chef::Config[:registration_url], 'bobo', \"#{tmpdir}/bobo.pem\")\n  end\n\n  def admin_client\n    unless @admin_client\n      r = Chef::REST.new(Chef::Config[:registration_url], Chef::Config[:validation_client_name], Chef::Config[:validation_key])\n      r.register(\"bobo\", \"#{tmpdir}/bobo.pem\")\n      c = Chef::ApiClient.cdb_load(\"bobo\")\n      c.admin(true)\n      c.cdb_save\n      @admin_client = c\n    end\n  end\n\n  def make_non_admin\n    r = Chef::REST.new(Chef::Config[:registration_url], Chef::Config[:validation_client_name], Chef::Config[:validation_key])\n    r.register(\"not_admin\", \"#{tmpdir}/not_admin.pem\")\n    c = Chef::ApiClient.cdb_load(\"not_admin\")\n    c.cdb_save\n    @rest = Chef::REST.new(Chef::Config[:registration_url], 'not_admin', \"#{tmpdir}/not_admin.pem\")\n    #Chef::Config[:client_key] = \"#{tmpdir}/not_admin.pem\"\n    #Chef::Config[:node_name] = \"not_admin\"\n  end\n\n  def couchdb_rest_client\n    Chef::REST.new('http://localhost:5984/chef_integration', false, false)\n  end\n\n\nend\n\nWorld(ChefWorld)\n\nBefore do\n  data_tmp = File.join(File.dirname(__FILE__), \"..\", \"data\", \"tmp\")\n  system(\"rm -rf #{data_tmp}/*\")\n  system(\"rm -rf #{tmpdir}\")\n\n  system(\"mkdir -p #{tmpdir}\")\n  system(\"cp -r #{File.join(Dir.tmpdir, \"validation.pem\")} #{File.join(tmpdir, \"validation.pem\")}\")\n  system(\"cp -r #{File.join(Dir.tmpdir, \"webui.pem\")} #{File.join(tmpdir, \"webui.pem\")}\")\n\n  replicate_dbs({:source_db => \"#{Chef::Config[:couchdb_url]}/chef_integration_safe\",\n                 :target_db => \"#{Chef::Config[:couchdb_url]}/chef_integration\"})\n\n  s = Chef::SolrQuery.new\n  s.delete_database(\"chef_integration\")\n  s.commit\nend\n\nAfter do\n  gemserver.shutdown\n  gemserver_thread && gemserver_thread.join\n\n  apt_server.shutdown\n  apt_server_thread && apt_server_thread.join\n\n  cleanup_files.each do |file|\n    system(\"rm #{file}\")\n  end\n  cleanup_dirs.each do |dir|\n    system(\"rm -rf #{dir}\")\n  end\n  cj = Chef::REST::CookieJar.instance\n  cj.keys.each do |key|\n    cj.delete(key)\n  end\nend\n"], "filenames": ["chef-server-api/app/controllers/cookbooks.rb", "features/api/cookbooks/delete_cookbooks.feature", "features/api/cookbooks/upload_cookbooks.feature", "features/support/env.rb"], "buggy_code_start_loc": [32, 54, 157, 138], "buggy_code_end_loc": [32, 54, 157, 140], "fixing_code_start_loc": [33, 55, 158, 138], "fixing_code_end_loc": [34, 62, 177, 143], "type": "CWE-264", "message": "chef-server-api/app/controllers/cookbooks.rb in Chef Server in Chef before 0.9.18, and 0.10.x before 0.10.2, does not require administrative privileges for the update and destroy methods, which allows remote authenticated users to (1) upload cookbooks via a knife cookbook upload command or (2) delete cookbooks via a knife cookbook delete command.", "other": {"cve": {"id": "CVE-2011-5097", "sourceIdentifier": "cve@mitre.org", "published": "2012-08-08T10:26:18.173", "lastModified": "2012-08-13T04:00:00.000", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "chef-server-api/app/controllers/cookbooks.rb in Chef Server in Chef before 0.9.18, and 0.10.x before 0.10.2, does not require administrative privileges for the update and destroy methods, which allows remote authenticated users to (1) upload cookbooks via a knife cookbook upload command or (2) delete cookbooks via a knife cookbook delete command."}, {"lang": "es", "value": "chef-server-api/app/controllers/cookbooks.rb en Chef Server en Chef anterior a v0.9.18, y v0.10.x anterior a v0.10.2, no requiere privilegios administrativos para actualizar y destruir m\u00e9todos, lo que permite a usuarios remotos autenticados (1) subir (cookbooks) a trav\u00e9s de un comando de subida de un (knife cookbook) o (2) eliminar (cookbooks) a trav\u00e9s de un comando (knife cookbook) de borrado."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opscode:chef:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.9.16", "matchCriteriaId": "001059B9-0BBC-44B1-9B80-0252AFF77915"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opscode:chef:0.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "4303E45B-3CC7-4F86-9AA3-9DE9E340DDB7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opscode:chef:0.7.4:*:*:*:*:*:*:*", "matchCriteriaId": "2DE318AD-5737-453F-90B9-449A3593887E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opscode:chef:0.7.6:*:*:*:*:*:*:*", "matchCriteriaId": "D0FB009E-708B-41BE-98E3-0548204A594A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opscode:chef:0.7.8:*:*:*:*:*:*:*", "matchCriteriaId": "C369798E-2499-4DD5-8C13-F7A3D0BCAED9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opscode:chef:0.7.10:*:*:*:*:*:*:*", "matchCriteriaId": "E247C8C9-7404-4920-9CA8-91316483CF01"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opscode:chef:0.7.12:*:*:*:*:*:*:*", "matchCriteriaId": "0189B6A3-9D58-40D7-BB42-101A600B5014"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opscode:chef:0.7.14:*:*:*:*:*:*:*", "matchCriteriaId": "97B55226-BC34-4060-A37D-8317B8BFB43B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opscode:chef:0.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "E624C53F-1755-4E88-B575-1AB92781A06C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opscode:chef:0.8.4:*:*:*:*:*:*:*", "matchCriteriaId": "DAA73864-4852-47D9-9EB9-A2AD654D0BAC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opscode:chef:0.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "112F8AEB-9DD0-4A68-B69C-B677BE373DAE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opscode:chef:0.8.8:*:*:*:*:*:*:*", "matchCriteriaId": "9C6B61EE-2F0D-49DC-ADFD-D0A25A21B8B6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opscode:chef:0.8.10:*:*:*:*:*:*:*", "matchCriteriaId": "B91DE695-5740-4A14-AC39-873E69E5C69B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opscode:chef:0.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "2BBC6CA8-45FE-4A3E-8EA2-D4B3B2C8036C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opscode:chef:0.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "1B0E4636-741A-488B-B630-069C31476987"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opscode:chef:0.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "870939E2-77E8-4821-851D-0B770B6BAD47"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opscode:chef:0.9.6:*:*:*:*:*:*:*", "matchCriteriaId": "A5B26A9F-3A23-4828-80B5-D8B19AEC843B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opscode:chef:0.9.8:*:*:*:*:*:*:*", "matchCriteriaId": "802801AB-C583-4DCB-8542-D509C6E427B7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opscode:chef:0.9.10:*:*:*:*:*:*:*", "matchCriteriaId": "993E5C5C-C351-4B24-ABEB-AB43C364152B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opscode:chef:0.9.12:*:*:*:*:*:*:*", "matchCriteriaId": "571427BE-B823-414B-9553-D1F744FE24AE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opscode:chef:0.9.14:*:*:*:*:*:*:*", "matchCriteriaId": "B5A21EFF-2E01-4CD9-9710-328413910E58"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opscode:chef:0.10.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1F1938B-B09A-456A-B831-72A1BA7A76C2"}]}]}], "references": [{"url": "http://tickets.opscode.com/browse/CHEF-2436", "source": "cve@mitre.org"}, {"url": "https://github.com/opscode/chef/commit/a4ea6edab2fecb922f999cffb0daa04eeeec7a26", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/opscode/chef/commit/a4ea6edab2fecb922f999cffb0daa04eeeec7a26"}}