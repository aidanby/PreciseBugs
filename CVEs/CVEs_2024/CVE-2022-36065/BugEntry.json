{"buggy_code": ["import { Request, Response } from \"express\";\nimport jwt from \"jsonwebtoken\";\nimport {\n  createRefreshToken,\n  deleteRefreshToken,\n  getUserIdFromAuthRefreshToken,\n} from \"../models/AuthRefreshModel\";\nimport {\n  createForgotPasswordToken,\n  deleteForgotPasswordToken,\n  getUserIdFromForgotPasswordToken,\n} from \"../models/ForgotPasswordModel\";\nimport {\n  createOrganization,\n  hasOrganization,\n} from \"../models/OrganizationModel\";\nimport { IS_CLOUD } from \"../util/secrets\";\nimport {\n  isNewInstallation,\n  markInstalled,\n  validatePasswordFormat,\n} from \"../services/auth\";\nimport { getEmailFromUserId, getOrgFromReq } from \"../services/organizations\";\nimport {\n  createUser,\n  getUserByEmail,\n  getUserById,\n  updatePassword,\n  verifyPassword,\n} from \"../services/users\";\nimport { AuthRequest } from \"../types/AuthRequest\";\nimport { JWT_SECRET } from \"../util/secrets\";\n\nfunction generateJWT(userId: string) {\n  return jwt.sign(\n    {\n      scope: \"profile openid email\",\n    },\n    JWT_SECRET,\n    {\n      algorithm: \"HS256\",\n      audience: \"https://api.growthbook.io\",\n      issuer: \"https://api.growthbook.io\",\n      subject: userId,\n      // 30 minutes\n      expiresIn: 1800,\n    }\n  );\n}\n\nasync function successResponse(req: Request, res: Response, userId: string) {\n  const token = generateJWT(userId);\n\n  // Create a refresh token\n  await createRefreshToken(req, res, userId);\n\n  return res.status(200).json({\n    status: 200,\n    token,\n  });\n}\n\nexport async function getHasOrganizations(req: Request, res: Response) {\n  const hasOrg = IS_CLOUD ? true : await hasOrganization();\n  return res.json({\n    status: 200,\n    hasOrganizations: hasOrg,\n  });\n}\n\nexport async function postRefresh(req: Request, res: Response) {\n  // Look for refresh token header\n  const refreshToken = req.cookies[\"AUTH_REFRESH_TOKEN\"];\n  if (!refreshToken) {\n    const newInstallation = await isNewInstallation();\n\n    return res.json({\n      status: 200,\n      authenticated: false,\n      newInstallation,\n    });\n  }\n\n  const userId = await getUserIdFromAuthRefreshToken(refreshToken);\n  if (!userId) {\n    return res.json({\n      status: 200,\n      authenticated: false,\n    });\n  }\n\n  const user = await getUserById(userId);\n\n  const token = generateJWT(userId);\n  return res.json({\n    status: 200,\n    authenticated: true,\n    token,\n    email: user?.email || \"\",\n  });\n}\n\nexport async function postLogin(\n  // eslint-disable-next-line\n  req: Request<any, any, { email: string; password: string }>,\n  res: Response\n) {\n  const { email, password } = req.body;\n\n  validatePasswordFormat(password);\n\n  const user = await getUserByEmail(email);\n  if (!user) {\n    console.log(\"Unknown email\", email);\n    return res.status(400).json({\n      status: 400,\n      message: \"Invalid email or password\",\n    });\n  }\n\n  const valid = await verifyPassword(user, password);\n  if (!valid) {\n    console.log(\"Invalid password for\", email);\n    return res.status(400).json({\n      status: 400,\n      message: \"Invalid email or password\",\n    });\n  }\n\n  return successResponse(req as Request, res, user.id);\n}\n\nexport async function postLogout(req: Request, res: Response) {\n  await deleteRefreshToken(req, res);\n\n  res.status(200).json({\n    status: 200,\n  });\n}\n\nexport async function postRegister(\n  // eslint-disable-next-line\n  req: Request<any, any, { email: string; name: string; password: string }>,\n  res: Response\n) {\n  const { email, name, password } = req.body;\n\n  validatePasswordFormat(password);\n\n  // TODO: validate email and name\n\n  const existingUser = await getUserByEmail(email);\n  if (existingUser) {\n    // Try to login to existing account\n    const valid = await verifyPassword(existingUser, password);\n    if (valid) {\n      return successResponse(req as Request, res, existingUser.id);\n    }\n\n    return res.status(400).json({\n      status: 400,\n      message: \"That email address is already registered.\",\n    });\n  }\n\n  // Create new account\n  const user = await createUser(name, email, password);\n  return successResponse(req as Request, res, user.id);\n}\n\nexport async function postFirstTimeRegister(\n  req: Request<\n    // eslint-disable-next-line\n    any,\n    // eslint-disable-next-line\n    any,\n    {\n      email: string;\n      name: string;\n      password: string;\n      companyname: string;\n    }\n  >,\n  res: Response\n) {\n  const { email, name, password, companyname } = req.body;\n\n  validatePasswordFormat(password);\n  if (companyname.length < 3) {\n    throw Error(\"Company length must be at least 3 characters\");\n  }\n\n  const existingUser = await getUserByEmail(email);\n  if (existingUser) {\n    return res.status(400).json({\n      status: 400,\n      message: \"An error ocurred, please refresh the page and try again.\",\n    });\n  }\n\n  const user = await createUser(name, email, password);\n  await createOrganization(email, user.id, companyname, \"\");\n  markInstalled();\n  return successResponse(req, res, user.id);\n}\n\nexport async function postForgotPassword(\n  // eslint-disable-next-line\n  req: Request<any, any, { email: string }>,\n  res: Response\n) {\n  const { email } = req.body;\n  await createForgotPasswordToken(email);\n\n  res.status(200).json({\n    status: 200,\n  });\n}\n\nexport async function getResetPassword(\n  req: Request<{ token: string }>,\n  res: Response\n) {\n  const { token } = req.params;\n  if (!token) {\n    throw new Error(\"Invalid password reset token.\");\n  }\n\n  const userId = await getUserIdFromForgotPasswordToken(token);\n\n  if (!userId) {\n    throw new Error(\"Invalid password reset token.\");\n  }\n\n  const email = await getEmailFromUserId(userId);\n  if (!email) {\n    throw new Error(\"Could not find user for that password reset token.\");\n  }\n\n  res.status(200).json({\n    status: 200,\n    email,\n  });\n}\n\nexport async function postResetPassword(\n  // eslint-disable-next-line\n  req: Request<{ token: string }, any, { password: string }>,\n  res: Response\n) {\n  const { token } = req.params;\n  const { password } = req.body;\n\n  if (!token) {\n    throw new Error(\"Invalid password reset token.\");\n  }\n\n  const userId = await getUserIdFromForgotPasswordToken(token);\n\n  if (!userId) {\n    throw new Error(\"Invalid password reset token.\");\n  }\n\n  const email = await getEmailFromUserId(userId);\n  if (!email) {\n    throw new Error(\"Could not find user for that password reset token.\");\n  }\n\n  await updatePassword(userId, password);\n  await deleteForgotPasswordToken(token);\n\n  res.status(200).json({\n    status: 200,\n    email,\n  });\n}\n\nexport async function postChangePassword(\n  req: AuthRequest<{\n    currentPassword: string;\n    newPassword: string;\n  }>,\n  res: Response\n) {\n  const { currentPassword, newPassword } = req.body;\n  const { userId } = getOrgFromReq(req);\n\n  const user = await getUserById(userId);\n  if (!user) {\n    throw new Error(\"Invalid user\");\n  }\n\n  const valid = await verifyPassword(user, currentPassword);\n  if (!valid) {\n    throw new Error(\"Current password is incorrect\");\n  }\n\n  await updatePassword(user.id, newPassword);\n\n  res.status(200).json({\n    status: 200,\n  });\n}\n", "import uniqid from \"uniqid\";\nimport AWS from \"aws-sdk\";\nimport crypto from \"crypto\";\nimport path from \"path\";\nimport fs from \"fs\";\nimport {\n  JWT_SECRET,\n  S3_BUCKET,\n  S3_DOMAIN,\n  S3_REGION,\n  UPLOAD_METHOD,\n  GCS_BUCKET_NAME,\n  GCS_DOMAIN,\n} from \"../util/secrets\";\nimport { Storage, GetSignedUrlConfig } from \"@google-cloud/storage\";\n\nlet s3: AWS.S3;\nfunction getS3(): AWS.S3 {\n  if (!s3) {\n    AWS.config.update({ region: S3_REGION });\n    s3 = new AWS.S3({ signatureVersion: \"v4\" });\n  }\n  return s3;\n}\n\nexport function getUploadsDir() {\n  return path.join(__dirname, \"..\", \"..\", \"uploads\");\n}\n\nfunction getFileSignature(filePath: string) {\n  return crypto.createHmac(\"sha256\", JWT_SECRET).update(filePath).digest(\"hex\");\n}\n\nexport async function uploadFile(\n  filePath: string,\n  signature: string,\n  contents: Buffer\n) {\n  // Make sure signature matches\n  const comp = getFileSignature(filePath);\n  if (!crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(comp))) {\n    throw new Error(\"Invalid upload signature\");\n  }\n\n  const fullPath = getUploadsDir() + \"/\" + filePath;\n  const dir = path.dirname(fullPath);\n  await fs.promises.mkdir(dir, { recursive: true });\n  await fs.promises.writeFile(fullPath, contents);\n}\n\nexport async function getFileUploadURL(ext: string, pathPrefix: string) {\n  const mimetypes: { [key: string]: string } = {\n    png: \"image/png\",\n    jpg: \"image/jpeg\",\n    jpeg: \"image/jpeg\",\n    gif: \"image/gif\",\n    svg: \"text/svg\",\n  };\n\n  if (!mimetypes[ext.toLowerCase()]) {\n    throw new Error(\n      `Invalid image file type. Only ${Object.keys(mimetypes).join(\n        \", \"\n      )} accepted.`\n    );\n  }\n\n  const filename = uniqid(\"img_\");\n  const filePath = `${pathPrefix}${filename}.${ext}`;\n\n  async function getSignedGoogleUrl() {\n    const storage = new Storage();\n\n    const options: GetSignedUrlConfig = {\n      version: \"v4\",\n      action: \"write\",\n      expires: Date.now() + 15 * 60 * 1000,\n      contentType: mimetypes[ext],\n    };\n\n    const [url] = await storage\n      .bucket(GCS_BUCKET_NAME)\n      .file(filePath)\n      .getSignedUrl(options);\n\n    return url;\n  }\n\n  if (UPLOAD_METHOD === \"s3\") {\n    const s3Params = {\n      Bucket: S3_BUCKET,\n      Key: filePath,\n      ContentType: mimetypes[ext],\n      ACL: \"public-read\",\n    };\n\n    const uploadURL = getS3().getSignedUrl(\"putObject\", s3Params);\n\n    return {\n      uploadURL,\n      fileURL: S3_DOMAIN + (S3_DOMAIN.endsWith(\"/\") ? \"\" : \"/\") + filePath,\n    };\n  } else if (UPLOAD_METHOD === \"google-cloud\") {\n    const uploadURL = await getSignedGoogleUrl();\n\n    return {\n      uploadURL,\n      fileURL: GCS_DOMAIN + (GCS_DOMAIN.endsWith(\"/\") ? \"\" : \"/\") + filePath,\n    };\n  } else {\n    const fileURL = `/upload/${filePath}`;\n    const uploadURL = `/upload?path=${filePath}&signature=${getFileSignature(\n      filePath\n    )}`;\n    return {\n      uploadURL,\n      fileURL,\n    };\n  }\n}\n", "import dotenv from \"dotenv\";\nimport fs from \"fs\";\n\nexport const ENVIRONMENT = process.env.NODE_ENV;\nconst prod = ENVIRONMENT === \"production\";\n\nif (fs.existsSync(\".env.local\")) {\n  dotenv.config({ path: \".env.local\" });\n}\n\nexport const IS_CLOUD = !!process.env.IS_CLOUD;\n\nexport const UPLOAD_METHOD = (() => {\n  if (IS_CLOUD) return \"s3\";\n\n  const method = process.env.UPLOAD_METHOD;\n  if (method && [\"s3\", \"google-cloud\"].includes(method)) {\n    return method;\n  }\n\n  return \"local\";\n})();\n\nexport const MONGODB_URI =\n  process.env.MONGODB_URI ??\n  (prod ? \"\" : \"mongodb://root:password@localhost:27017/\");\nif (!MONGODB_URI) {\n  throw new Error(\"Missing MONGODB_URI environment variable\");\n}\n\nexport const APP_ORIGIN = process.env.APP_ORIGIN || \"http://localhost:3000\";\n\nconst corsOriginRegex = process.env.CORS_ORIGIN_REGEX;\nexport const CORS_ORIGIN_REGEX = corsOriginRegex\n  ? new RegExp(corsOriginRegex, \"i\")\n  : null;\n\nexport const GOOGLE_OAUTH_CLIENT_ID = process.env.GOOGLE_OAUTH_CLIENT_ID || \"\";\nexport const GOOGLE_OAUTH_CLIENT_SECRET =\n  process.env.GOOGLE_OAUTH_CLIENT_SECRET || \"\";\n\nexport const S3_BUCKET = process.env.S3_BUCKET || \"\";\nexport const S3_REGION = process.env.S3_REGION || \"us-east-1\";\nexport const S3_DOMAIN =\n  process.env.S3_DOMAIN || `https://${S3_BUCKET}.s3.amazonaws.com/`;\nexport const ENCRYPTION_KEY = process.env.ENCRYPTION_KEY || \"dev\";\nif (prod && ENCRYPTION_KEY === \"dev\") {\n  throw new Error(\n    \"Cannot use ENCRYPTION_KEY=dev in production. Please set to a long random string.\"\n  );\n}\n\nexport const GCS_BUCKET_NAME = process.env.GCS_BUCKET_NAME || \"\";\nexport const GCS_DOMAIN =\n  process.env.GCS_DOMAIN ||\n  `https://storage.googleapis.com/${GCS_BUCKET_NAME}/`;\n\nexport const JWT_SECRET = process.env.JWT_SECRET || \"dev\";\nif (prod && !IS_CLOUD && JWT_SECRET === \"dev\") {\n  throw new Error(\n    \"Cannot use JWT_SECRET=dev in production. Please set to a long random string.\"\n  );\n}\n\nexport const EMAIL_ENABLED = process.env.EMAIL_ENABLED === \"true\";\nexport const EMAIL_HOST = process.env.EMAIL_HOST;\nexport const EMAIL_PORT = parseInt(process.env.EMAIL_PORT || \"\") || 587;\nexport const EMAIL_HOST_USER = process.env.EMAIL_HOST_USER;\nexport const EMAIL_HOST_PASSWORD = process.env.EMAIL_HOST_PASSWORD;\nexport const EMAIL_FROM = process.env.EMAIL_FROM;\nexport const SITE_MANAGER_EMAIL = process.env.SITE_MANAGER_EMAIL;\n\nexport const STRIPE_SECRET = process.env.STRIPE_SECRET || \"\";\nexport const STRIPE_WEBHOOK_SECRET = process.env.STRIPE_WEBHOOK_SECRET || \"\";\nexport const STRIPE_PRICE = process.env.STRIPE_PRICE || \"\";\n\nexport const SLACK_SIGNING_SECRET = process.env.SLACK_SIGNING_SECRET || \"\";\n\nconst testConn = process.env.POSTGRES_TEST_CONN;\nexport const POSTGRES_TEST_CONN = testConn ? JSON.parse(testConn) : {};\n\nexport const AWS_CLOUDFRONT_DISTRIBUTION_ID =\n  process.env.AWS_CLOUDFRONT_DISTRIBUTION_ID || \"\";\n\n// Update results every X hours\nexport const EXPERIMENT_REFRESH_FREQUENCY =\n  parseInt(process.env.EXPERIMENT_REFRESH_FREQUENCY || \"\") || 6;\n\nexport const DEFAULT_CONVERSION_WINDOW_HOURS =\n  parseInt(process.env.DEFAULT_CONVERSION_WINDOW_HOURS || \"\") || 72;\n\n// Update metrics every X hours\nexport const METRIC_REFRESH_FREQUENCY =\n  parseInt(process.env.METRIC_REFRESH_FREQUENCY || \"\") || 24;\n\nexport const QUERY_CACHE_TTL_MINS =\n  parseInt(process.env.QUERY_CACHE_TTL_MINS || \"\") || 60;\n\n// When importing past experiments, limit to this number of days:\nexport const IMPORT_LIMIT_DAYS =\n  parseInt(process.env?.IMPORT_LIMIT_DAYS || \"\") || 365;\n\nexport const CRON_ENABLED = !process.env.CRON_DISABLED;\n"], "fixing_code": ["import { Request, Response } from \"express\";\nimport jwt from \"jsonwebtoken\";\nimport {\n  createRefreshToken,\n  deleteRefreshToken,\n  getUserIdFromAuthRefreshToken,\n} from \"../models/AuthRefreshModel\";\nimport {\n  createForgotPasswordToken,\n  deleteForgotPasswordToken,\n  getUserIdFromForgotPasswordToken,\n} from \"../models/ForgotPasswordModel\";\nimport {\n  createOrganization,\n  hasOrganization,\n} from \"../models/OrganizationModel\";\nimport { IS_CLOUD } from \"../util/secrets\";\nimport {\n  isNewInstallation,\n  markInstalled,\n  validatePasswordFormat,\n} from \"../services/auth\";\nimport { getEmailFromUserId, getOrgFromReq } from \"../services/organizations\";\nimport {\n  createUser,\n  getUserByEmail,\n  getUserById,\n  updatePassword,\n  verifyPassword,\n} from \"../services/users\";\nimport { AuthRequest } from \"../types/AuthRequest\";\nimport { JWT_SECRET } from \"../util/secrets\";\n\nfunction generateJWT(userId: string) {\n  return jwt.sign(\n    {\n      scope: \"profile openid email\",\n    },\n    JWT_SECRET,\n    {\n      algorithm: \"HS256\",\n      audience: \"https://api.growthbook.io\",\n      issuer: \"https://api.growthbook.io\",\n      subject: userId,\n      // 30 minutes\n      expiresIn: 1800,\n    }\n  );\n}\n\nasync function successResponse(req: Request, res: Response, userId: string) {\n  const token = generateJWT(userId);\n\n  // Create a refresh token\n  await createRefreshToken(req, res, userId);\n\n  return res.status(200).json({\n    status: 200,\n    token,\n  });\n}\n\nexport async function getHasOrganizations(req: Request, res: Response) {\n  const hasOrg = IS_CLOUD ? true : await hasOrganization();\n  return res.json({\n    status: 200,\n    hasOrganizations: hasOrg,\n  });\n}\n\nexport async function postRefresh(req: Request, res: Response) {\n  // Look for refresh token header\n  const refreshToken = req.cookies[\"AUTH_REFRESH_TOKEN\"];\n  if (!refreshToken) {\n    const newInstallation = await isNewInstallation();\n\n    return res.json({\n      status: 200,\n      authenticated: false,\n      newInstallation,\n    });\n  }\n\n  const userId = await getUserIdFromAuthRefreshToken(refreshToken);\n  if (!userId) {\n    return res.json({\n      status: 200,\n      authenticated: false,\n    });\n  }\n\n  const user = await getUserById(userId);\n\n  const token = generateJWT(userId);\n  return res.json({\n    status: 200,\n    authenticated: true,\n    token,\n    email: user?.email || \"\",\n  });\n}\n\nexport async function postLogin(\n  // eslint-disable-next-line\n  req: Request<any, any, { email: string; password: string }>,\n  res: Response\n) {\n  const { email, password } = req.body;\n\n  validatePasswordFormat(password);\n\n  const user = await getUserByEmail(email);\n  if (!user) {\n    console.log(\"Unknown email\", email);\n    return res.status(400).json({\n      status: 400,\n      message: \"Invalid email or password\",\n    });\n  }\n\n  const valid = await verifyPassword(user, password);\n  if (!valid) {\n    console.log(\"Invalid password for\", email);\n    return res.status(400).json({\n      status: 400,\n      message: \"Invalid email or password\",\n    });\n  }\n\n  return successResponse(req as Request, res, user.id);\n}\n\nexport async function postLogout(req: Request, res: Response) {\n  await deleteRefreshToken(req, res);\n\n  res.status(200).json({\n    status: 200,\n  });\n}\n\nexport async function postRegister(\n  // eslint-disable-next-line\n  req: Request<any, any, { email: string; name: string; password: string }>,\n  res: Response\n) {\n  const { email, name, password } = req.body;\n\n  validatePasswordFormat(password);\n\n  // TODO: validate email and name\n\n  const existingUser = await getUserByEmail(email);\n  if (existingUser) {\n    // Try to login to existing account\n    const valid = await verifyPassword(existingUser, password);\n    if (valid) {\n      return successResponse(req as Request, res, existingUser.id);\n    }\n\n    return res.status(400).json({\n      status: 400,\n      message: \"That email address is already registered.\",\n    });\n  }\n\n  // Create new account\n  const user = await createUser(name, email, password);\n  return successResponse(req as Request, res, user.id);\n}\n\nexport async function postFirstTimeRegister(\n  req: Request<\n    // eslint-disable-next-line\n    any,\n    // eslint-disable-next-line\n    any,\n    {\n      email: string;\n      name: string;\n      password: string;\n      companyname: string;\n    }\n  >,\n  res: Response\n) {\n  // Only allow this API endpoint when it's a brand-new installation with no users yet\n  const newInstallation = await isNewInstallation();\n  if (!newInstallation) {\n    throw new Error(\n      \"An organization is already configured. Please refresh the page and try again.\"\n    );\n  }\n\n  const { email, name, password, companyname } = req.body;\n\n  validatePasswordFormat(password);\n  if (companyname.length < 3) {\n    throw Error(\"Company length must be at least 3 characters\");\n  }\n\n  const existingUser = await getUserByEmail(email);\n  if (existingUser) {\n    return res.status(400).json({\n      status: 400,\n      message: \"An error ocurred, please refresh the page and try again.\",\n    });\n  }\n\n  const user = await createUser(name, email, password);\n  await createOrganization(email, user.id, companyname, \"\");\n  markInstalled();\n  return successResponse(req, res, user.id);\n}\n\nexport async function postForgotPassword(\n  // eslint-disable-next-line\n  req: Request<any, any, { email: string }>,\n  res: Response\n) {\n  const { email } = req.body;\n  await createForgotPasswordToken(email);\n\n  res.status(200).json({\n    status: 200,\n  });\n}\n\nexport async function getResetPassword(\n  req: Request<{ token: string }>,\n  res: Response\n) {\n  const { token } = req.params;\n  if (!token) {\n    throw new Error(\"Invalid password reset token.\");\n  }\n\n  const userId = await getUserIdFromForgotPasswordToken(token);\n\n  if (!userId) {\n    throw new Error(\"Invalid password reset token.\");\n  }\n\n  const email = await getEmailFromUserId(userId);\n  if (!email) {\n    throw new Error(\"Could not find user for that password reset token.\");\n  }\n\n  res.status(200).json({\n    status: 200,\n    email,\n  });\n}\n\nexport async function postResetPassword(\n  // eslint-disable-next-line\n  req: Request<{ token: string }, any, { password: string }>,\n  res: Response\n) {\n  const { token } = req.params;\n  const { password } = req.body;\n\n  if (!token) {\n    throw new Error(\"Invalid password reset token.\");\n  }\n\n  const userId = await getUserIdFromForgotPasswordToken(token);\n\n  if (!userId) {\n    throw new Error(\"Invalid password reset token.\");\n  }\n\n  const email = await getEmailFromUserId(userId);\n  if (!email) {\n    throw new Error(\"Could not find user for that password reset token.\");\n  }\n\n  await updatePassword(userId, password);\n  await deleteForgotPasswordToken(token);\n\n  res.status(200).json({\n    status: 200,\n    email,\n  });\n}\n\nexport async function postChangePassword(\n  req: AuthRequest<{\n    currentPassword: string;\n    newPassword: string;\n  }>,\n  res: Response\n) {\n  const { currentPassword, newPassword } = req.body;\n  const { userId } = getOrgFromReq(req);\n\n  const user = await getUserById(userId);\n  if (!user) {\n    throw new Error(\"Invalid user\");\n  }\n\n  const valid = await verifyPassword(user, currentPassword);\n  if (!valid) {\n    throw new Error(\"Current password is incorrect\");\n  }\n\n  await updatePassword(user.id, newPassword);\n\n  res.status(200).json({\n    status: 200,\n  });\n}\n", "import uniqid from \"uniqid\";\nimport AWS from \"aws-sdk\";\nimport crypto from \"crypto\";\nimport path from \"path\";\nimport fs from \"fs\";\nimport {\n  JWT_SECRET,\n  S3_BUCKET,\n  S3_DOMAIN,\n  S3_REGION,\n  UPLOAD_METHOD,\n  GCS_BUCKET_NAME,\n  GCS_DOMAIN,\n} from \"../util/secrets\";\nimport { Storage, GetSignedUrlConfig } from \"@google-cloud/storage\";\n\nlet s3: AWS.S3;\nfunction getS3(): AWS.S3 {\n  if (!s3) {\n    AWS.config.update({ region: S3_REGION });\n    s3 = new AWS.S3({ signatureVersion: \"v4\" });\n  }\n  return s3;\n}\n\nexport function getUploadsDir() {\n  return path.join(__dirname, \"..\", \"..\", \"uploads\");\n}\n\nfunction getFileSignature(filePath: string) {\n  return crypto.createHmac(\"sha256\", JWT_SECRET).update(filePath).digest(\"hex\");\n}\n\nexport async function uploadFile(\n  filePath: string,\n  signature: string,\n  contents: Buffer\n) {\n  // Make sure signature matches\n  const comp = getFileSignature(filePath);\n  if (!crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(comp))) {\n    throw new Error(\"Invalid upload signature\");\n  }\n\n  // Watch out for poison null bytes\n  if (filePath.indexOf(\"\\0\") !== -1) {\n    throw new Error(\"Error: Filename must not contain null bytes\");\n  }\n\n  const rootDirectory = getUploadsDir();\n  const fullPath = path.join(rootDirectory, filePath);\n\n  // Prevent directory traversal\n  if (fullPath.indexOf(rootDirectory) !== 0) {\n    throw new Error(\n      \"Error: Path must not escape out of the 'uploads' directory.\"\n    );\n  }\n\n  const dir = path.dirname(fullPath);\n  await fs.promises.mkdir(dir, { recursive: true });\n  await fs.promises.writeFile(fullPath, contents);\n}\n\nexport async function getFileUploadURL(ext: string, pathPrefix: string) {\n  const mimetypes: { [key: string]: string } = {\n    png: \"image/png\",\n    jpg: \"image/jpeg\",\n    jpeg: \"image/jpeg\",\n    gif: \"image/gif\",\n    svg: \"text/svg\",\n  };\n\n  if (!mimetypes[ext.toLowerCase()]) {\n    throw new Error(\n      `Invalid image file type. Only ${Object.keys(mimetypes).join(\n        \", \"\n      )} accepted.`\n    );\n  }\n\n  const filename = uniqid(\"img_\");\n  const filePath = `${pathPrefix}${filename}.${ext}`;\n\n  async function getSignedGoogleUrl() {\n    const storage = new Storage();\n\n    const options: GetSignedUrlConfig = {\n      version: \"v4\",\n      action: \"write\",\n      expires: Date.now() + 15 * 60 * 1000,\n      contentType: mimetypes[ext],\n    };\n\n    const [url] = await storage\n      .bucket(GCS_BUCKET_NAME)\n      .file(filePath)\n      .getSignedUrl(options);\n\n    return url;\n  }\n\n  if (UPLOAD_METHOD === \"s3\") {\n    const s3Params = {\n      Bucket: S3_BUCKET,\n      Key: filePath,\n      ContentType: mimetypes[ext],\n      ACL: \"public-read\",\n    };\n\n    const uploadURL = getS3().getSignedUrl(\"putObject\", s3Params);\n\n    return {\n      uploadURL,\n      fileURL: S3_DOMAIN + (S3_DOMAIN.endsWith(\"/\") ? \"\" : \"/\") + filePath,\n    };\n  } else if (UPLOAD_METHOD === \"google-cloud\") {\n    const uploadURL = await getSignedGoogleUrl();\n\n    return {\n      uploadURL,\n      fileURL: GCS_DOMAIN + (GCS_DOMAIN.endsWith(\"/\") ? \"\" : \"/\") + filePath,\n    };\n  } else {\n    const fileURL = `/upload/${filePath}`;\n    const uploadURL = `/upload?path=${filePath}&signature=${getFileSignature(\n      filePath\n    )}`;\n    return {\n      uploadURL,\n      fileURL,\n    };\n  }\n}\n", "import dotenv from \"dotenv\";\nimport fs from \"fs\";\n\nexport const ENVIRONMENT = process.env.NODE_ENV;\nconst prod = ENVIRONMENT === \"production\";\n\nif (fs.existsSync(\".env.local\")) {\n  dotenv.config({ path: \".env.local\" });\n}\n\nexport const IS_CLOUD = !!process.env.IS_CLOUD;\n\nexport const UPLOAD_METHOD = (() => {\n  if (IS_CLOUD) return \"s3\";\n\n  const method = process.env.UPLOAD_METHOD;\n  if (method && [\"s3\", \"google-cloud\"].includes(method)) {\n    return method;\n  }\n\n  return \"local\";\n})();\n\nexport const MONGODB_URI =\n  process.env.MONGODB_URI ??\n  (prod ? \"\" : \"mongodb://root:password@localhost:27017/\");\nif (!MONGODB_URI) {\n  throw new Error(\"Missing MONGODB_URI environment variable\");\n}\n\nexport const APP_ORIGIN = process.env.APP_ORIGIN || \"http://localhost:3000\";\nconst isLocalhost = APP_ORIGIN.includes(\"localhost\");\n\nconst corsOriginRegex = process.env.CORS_ORIGIN_REGEX;\nexport const CORS_ORIGIN_REGEX = corsOriginRegex\n  ? new RegExp(corsOriginRegex, \"i\")\n  : null;\n\nexport const GOOGLE_OAUTH_CLIENT_ID = process.env.GOOGLE_OAUTH_CLIENT_ID || \"\";\nexport const GOOGLE_OAUTH_CLIENT_SECRET =\n  process.env.GOOGLE_OAUTH_CLIENT_SECRET || \"\";\n\nexport const S3_BUCKET = process.env.S3_BUCKET || \"\";\nexport const S3_REGION = process.env.S3_REGION || \"us-east-1\";\nexport const S3_DOMAIN =\n  process.env.S3_DOMAIN || `https://${S3_BUCKET}.s3.amazonaws.com/`;\nexport const ENCRYPTION_KEY = process.env.ENCRYPTION_KEY || \"dev\";\nif (prod && ENCRYPTION_KEY === \"dev\") {\n  throw new Error(\n    \"Cannot use ENCRYPTION_KEY=dev in production. Please set to a long random string.\"\n  );\n}\n\nexport const GCS_BUCKET_NAME = process.env.GCS_BUCKET_NAME || \"\";\nexport const GCS_DOMAIN =\n  process.env.GCS_DOMAIN ||\n  `https://storage.googleapis.com/${GCS_BUCKET_NAME}/`;\n\nexport const JWT_SECRET = process.env.JWT_SECRET || \"dev\";\nif ((prod || !isLocalhost) && !IS_CLOUD && JWT_SECRET === \"dev\") {\n  throw new Error(\n    \"Cannot use JWT_SECRET=dev in production. Please set to a long random string.\"\n  );\n}\n\nexport const EMAIL_ENABLED = process.env.EMAIL_ENABLED === \"true\";\nexport const EMAIL_HOST = process.env.EMAIL_HOST;\nexport const EMAIL_PORT = parseInt(process.env.EMAIL_PORT || \"\") || 587;\nexport const EMAIL_HOST_USER = process.env.EMAIL_HOST_USER;\nexport const EMAIL_HOST_PASSWORD = process.env.EMAIL_HOST_PASSWORD;\nexport const EMAIL_FROM = process.env.EMAIL_FROM;\nexport const SITE_MANAGER_EMAIL = process.env.SITE_MANAGER_EMAIL;\n\nexport const STRIPE_SECRET = process.env.STRIPE_SECRET || \"\";\nexport const STRIPE_WEBHOOK_SECRET = process.env.STRIPE_WEBHOOK_SECRET || \"\";\nexport const STRIPE_PRICE = process.env.STRIPE_PRICE || \"\";\n\nexport const SLACK_SIGNING_SECRET = process.env.SLACK_SIGNING_SECRET || \"\";\n\nconst testConn = process.env.POSTGRES_TEST_CONN;\nexport const POSTGRES_TEST_CONN = testConn ? JSON.parse(testConn) : {};\n\nexport const AWS_CLOUDFRONT_DISTRIBUTION_ID =\n  process.env.AWS_CLOUDFRONT_DISTRIBUTION_ID || \"\";\n\n// Update results every X hours\nexport const EXPERIMENT_REFRESH_FREQUENCY =\n  parseInt(process.env.EXPERIMENT_REFRESH_FREQUENCY || \"\") || 6;\n\nexport const DEFAULT_CONVERSION_WINDOW_HOURS =\n  parseInt(process.env.DEFAULT_CONVERSION_WINDOW_HOURS || \"\") || 72;\n\n// Update metrics every X hours\nexport const METRIC_REFRESH_FREQUENCY =\n  parseInt(process.env.METRIC_REFRESH_FREQUENCY || \"\") || 24;\n\nexport const QUERY_CACHE_TTL_MINS =\n  parseInt(process.env.QUERY_CACHE_TTL_MINS || \"\") || 60;\n\n// When importing past experiments, limit to this number of days:\nexport const IMPORT_LIMIT_DAYS =\n  parseInt(process.env?.IMPORT_LIMIT_DAYS || \"\") || 365;\n\nexport const CRON_ENABLED = !process.env.CRON_DISABLED;\n"], "filenames": ["packages/back-end/src/controllers/auth.ts", "packages/back-end/src/services/files.ts", "packages/back-end/src/util/secrets.ts"], "buggy_code_start_loc": [185, 45, 31], "buggy_code_end_loc": [185, 46, 60], "fixing_code_start_loc": [186, 45, 32], "fixing_code_end_loc": [194, 60, 61], "type": "CWE-434", "message": "GrowthBook is an open-source platform for feature flagging and A/B testing. With some self-hosted configurations in versions prior to 2022-08-29, attackers can register new accounts and upload files to arbitrary directories within the container. If the attacker uploads a Python script to the right location, they can execute arbitrary code within the container. To be affected, ALL of the following must be true: Self-hosted deployment (GrowthBook Cloud is unaffected); using local file uploads (as opposed to S3 or Google Cloud Storage); NODE_ENV set to a non-production value and JWT_SECRET set to an easily guessable string like `dev`. This issue is patched in commit 1a5edff8786d141161bf880c2fd9ccbe2850a264 (2022-08-29). As a workaround, set `JWT_SECRET` environment variable to a long random string. This will stop arbitrary file uploads, but the only way to stop attackers from registering accounts is by updating to the latest build.", "other": {"cve": {"id": "CVE-2022-36065", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-06T21:15:08.760", "lastModified": "2022-09-12T15:48:28.990", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "GrowthBook is an open-source platform for feature flagging and A/B testing. With some self-hosted configurations in versions prior to 2022-08-29, attackers can register new accounts and upload files to arbitrary directories within the container. If the attacker uploads a Python script to the right location, they can execute arbitrary code within the container. To be affected, ALL of the following must be true: Self-hosted deployment (GrowthBook Cloud is unaffected); using local file uploads (as opposed to S3 or Google Cloud Storage); NODE_ENV set to a non-production value and JWT_SECRET set to an easily guessable string like `dev`. This issue is patched in commit 1a5edff8786d141161bf880c2fd9ccbe2850a264 (2022-08-29). As a workaround, set `JWT_SECRET` environment variable to a long random string. This will stop arbitrary file uploads, but the only way to stop attackers from registering accounts is by updating to the latest build."}, {"lang": "es", "value": "GrowthBook es una plataforma de c\u00f3digo abierto para el marcado de caracter\u00edsticas y las pruebas A/B. Con algunas configuraciones auto-alojadas en versiones anteriores al 29-08-2022, los atacantes pueden registrar nuevas cuentas y subir archivos a directorios arbitrarios dentro del contenedor. Si el atacante sube un script de Python a la ubicaci\u00f3n correcta, puede ejecutar c\u00f3digo arbitrario dentro del contenedor. Para ser afectado, TODO lo siguiente debe ser cierto: despliegue auto-alojado (GrowthBook Cloud no est\u00e1 afectado); el uso de cargas de archivos locales (en lugar de S3 o Google Cloud Storage); NODE_ENV establecido a un valor no de producci\u00f3n y JWT_SECRET establecido a una cadena f\u00e1cilmente adivinable como \"dev\". Este problema est\u00e1 parcheado en el commit 1a5edff8786d141161bf880c2fd9ccbe2850a264 (2022-08-29). Como mitigaci\u00f3n, establezca la variable de entorno \"JWT_SECRET\" a una cadena larga y aleatoria. Esto detendr\u00e1 la carga de archivos arbitrarios, pero la \u00fanica forma de evitar que los atacantes registren cuentas es actualizando a la \u00faltima versi\u00f3n.\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-434"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}, {"lang": "en", "value": "CWE-24"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:growthbook:growthbook:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.6.0", "matchCriteriaId": "3749527E-1CFE-4D57-93C5-663AF209209C"}]}]}], "references": [{"url": "https://github.com/growthbook/growthbook/commit/1a5edff8786d141161bf880c2fd9ccbe2850a264", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/growthbook/growthbook/pull/487", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Mitigation", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/growthbook/growthbook/security/advisories/GHSA-j24q-55xh-wm4r", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Mitigation", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/growthbook/growthbook/commit/1a5edff8786d141161bf880c2fd9ccbe2850a264"}}