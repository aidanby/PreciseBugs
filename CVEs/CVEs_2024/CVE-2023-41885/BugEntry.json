{"buggy_code": ["\"\"\"\nA User model, used for authentication.\n\"\"\"\nfrom __future__ import annotations\n\nimport datetime\nimport hashlib\nimport logging\nimport secrets\nimport typing as t\n\nfrom piccolo.columns import Boolean, Secret, Timestamp, Varchar\nfrom piccolo.columns.column_types import Serial\nfrom piccolo.columns.readable import Readable\nfrom piccolo.table import Table\nfrom piccolo.utils.sync import run_sync\n\nlogger = logging.getLogger(__name__)\n\n\nclass BaseUser(Table, tablename=\"piccolo_user\"):\n    \"\"\"\n    Provides a basic user, with authentication support.\n    \"\"\"\n\n    id: Serial\n    username = Varchar(length=100, unique=True)\n    password = Secret(length=255)\n    first_name = Varchar(null=True)\n    last_name = Varchar(null=True)\n    email = Varchar(length=255, unique=True)\n    active = Boolean(default=False)\n    admin = Boolean(\n        default=False, help_text=\"An admin can log into the Piccolo admin GUI.\"\n    )\n    superuser = Boolean(\n        default=False,\n        help_text=(\n            \"If True, this user can manage other users's passwords in the \"\n            \"Piccolo admin GUI.\"\n        ),\n    )\n    last_login = Timestamp(\n        null=True,\n        default=None,\n        required=False,\n        help_text=\"When this user last logged in.\",\n    )\n\n    _min_password_length = 6\n    _max_password_length = 128\n    # The number of hash iterations recommended by OWASP:\n    # https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#pbkdf2\n    _pbkdf2_iteration_count = 600_000\n\n    def __init__(self, **kwargs):\n        # Generating passwords upfront is expensive, so might need reworking.\n        password = kwargs.get(\"password\", None)\n        if password:\n            if not password.startswith(\"pbkdf2_sha256\"):\n                kwargs[\"password\"] = self.__class__.hash_password(password)\n        super().__init__(**kwargs)\n\n    @classmethod\n    def get_salt(cls):\n        return secrets.token_hex(16)\n\n    @classmethod\n    def get_readable(cls) -> Readable:\n        \"\"\"\n        Used to get a readable string, representing a table row.\n        \"\"\"\n        return Readable(template=\"%s\", columns=[cls.username])\n\n    ###########################################################################\n\n    @classmethod\n    def _validate_password(cls, password: str):\n        \"\"\"\n        Validate the raw password. Used by :meth:`update_password` and\n        :meth:`create_user`.\n\n        :param password:\n            The raw password e.g. ``'hello123'``.\n        :raises ValueError:\n            If the password fails any of the criteria.\n\n        \"\"\"\n        if not password:\n            raise ValueError(\"A password must be provided.\")\n\n        if len(password) < cls._min_password_length:\n            raise ValueError(\"The password is too short.\")\n\n        if len(password) > cls._max_password_length:\n            raise ValueError(\"The password is too long.\")\n\n        if password.startswith(\"pbkdf2_sha256\"):\n            logger.warning(\n                \"Tried to create a user with an already hashed password.\"\n            )\n            raise ValueError(\"Do not pass a hashed password.\")\n\n    ###########################################################################\n\n    @classmethod\n    def update_password_sync(cls, user: t.Union[str, int], password: str):\n        \"\"\"\n        A sync equivalent of :meth:`update_password`.\n        \"\"\"\n        return run_sync(cls.update_password(user, password))\n\n    @classmethod\n    async def update_password(cls, user: t.Union[str, int], password: str):\n        \"\"\"\n        The password is the raw password string e.g. ``'password123'``.\n        The user can be a user ID, or a username.\n        \"\"\"\n        if isinstance(user, str):\n            clause = cls.username == user\n        elif isinstance(user, int):\n            clause = cls.id == user\n        else:\n            raise ValueError(\n                \"The `user` arg must be a user id, or a username.\"\n            )\n\n        cls._validate_password(password=password)\n\n        password = cls.hash_password(password)\n        await cls.update({cls.password: password}).where(clause).run()\n\n    ###########################################################################\n\n    @classmethod\n    def hash_password(\n        cls, password: str, salt: str = \"\", iterations: t.Optional[int] = None\n    ) -> str:\n        \"\"\"\n        Hashes the password, ready for storage, and for comparing during\n        login.\n\n        :raises ValueError:\n            If an excessively long password is provided.\n\n        \"\"\"\n        if len(password) > cls._max_password_length:\n            logger.warning(\"Excessively long password provided.\")\n            raise ValueError(\"The password is too long.\")\n\n        if not salt:\n            salt = cls.get_salt()\n\n        if iterations is None:\n            iterations = cls._pbkdf2_iteration_count\n\n        hashed = hashlib.pbkdf2_hmac(\n            \"sha256\",\n            bytes(password, encoding=\"utf-8\"),\n            bytes(salt, encoding=\"utf-8\"),\n            iterations,\n        ).hex()\n        return f\"pbkdf2_sha256${iterations}${salt}${hashed}\"\n\n    def __setattr__(self, name: str, value: t.Any):\n        \"\"\"\n        Make sure that if the password is set, it's stored in a hashed form.\n        \"\"\"\n        if name == \"password\" and not value.startswith(\"pbkdf2_sha256\"):\n            value = self.__class__.hash_password(value)\n\n        super().__setattr__(name, value)\n\n    @classmethod\n    def split_stored_password(cls, password: str) -> t.List[str]:\n        elements = password.split(\"$\")\n        if len(elements) != 4:\n            raise ValueError(\"Unable to split hashed password\")\n        return elements\n\n    ###########################################################################\n\n    @classmethod\n    def login_sync(cls, username: str, password: str) -> t.Optional[int]:\n        \"\"\"\n        A sync equivalent of :meth:`login`.\n        \"\"\"\n        return run_sync(cls.login(username, password))\n\n    @classmethod\n    async def login(cls, username: str, password: str) -> t.Optional[int]:\n        \"\"\"\n        Make sure the user exists and the password is valid. If so, the\n        ``last_login`` value is updated in the database.\n\n        :returns:\n            The id of the user if a match is found, otherwise ``None``.\n\n        \"\"\"\n        if len(username) > cls.username.length:\n            logger.warning(\"Excessively long username provided.\")\n            return None\n\n        if len(password) > cls._max_password_length:\n            logger.warning(\"Excessively long password provided.\")\n            return None\n\n        response = (\n            await cls.select(cls._meta.primary_key, cls.password)\n            .where(cls.username == username)\n            .first()\n            .run()\n        )\n        if not response:\n            # No match found\n            return None\n\n        stored_password = response[\"password\"]\n\n        algorithm, iterations_, salt, hashed = cls.split_stored_password(\n            stored_password\n        )\n        iterations = int(iterations_)\n\n        if cls.hash_password(password, salt, iterations) == stored_password:\n            # If the password was hashed in an earlier Piccolo version, update\n            # it so it's hashed with the currently recommended number of\n            # iterations:\n            if iterations != cls._pbkdf2_iteration_count:\n                await cls.update_password(username, password)\n\n            await cls.update({cls.last_login: datetime.datetime.now()}).where(\n                cls.username == username\n            )\n            return response[\"id\"]\n        else:\n            return None\n\n    ###########################################################################\n\n    @classmethod\n    def create_user_sync(\n        cls, username: str, password: str, **extra_params\n    ) -> BaseUser:\n        \"\"\"\n        A sync equivalent of :meth:`create_user`.\n        \"\"\"\n        return run_sync(\n            cls.create_user(\n                username=username, password=password, **extra_params\n            )\n        )\n\n    @classmethod\n    async def create_user(\n        cls, username: str, password: str, **extra_params\n    ) -> BaseUser:\n        \"\"\"\n        Creates a new user, and saves it in the database. It is recommended to\n        use this rather than instantiating and saving ``BaseUser`` directly, as\n        we add extra validation.\n\n        :raises ValueError:\n            If the username or password is invalid.\n        :returns:\n            The created ``BaseUser`` instance.\n\n        \"\"\"\n        if not username:\n            raise ValueError(\"A username must be provided.\")\n\n        cls._validate_password(password=password)\n\n        user = cls(username=username, password=password, **extra_params)\n        await user.save()\n        return user\n"], "fixing_code": ["\"\"\"\nA User model, used for authentication.\n\"\"\"\nfrom __future__ import annotations\n\nimport datetime\nimport hashlib\nimport logging\nimport secrets\nimport typing as t\n\nfrom piccolo.columns import Boolean, Secret, Timestamp, Varchar\nfrom piccolo.columns.column_types import Serial\nfrom piccolo.columns.readable import Readable\nfrom piccolo.table import Table\nfrom piccolo.utils.sync import run_sync\n\nlogger = logging.getLogger(__name__)\n\n\nclass BaseUser(Table, tablename=\"piccolo_user\"):\n    \"\"\"\n    Provides a basic user, with authentication support.\n    \"\"\"\n\n    id: Serial\n    username = Varchar(length=100, unique=True)\n    password = Secret(length=255)\n    first_name = Varchar(null=True)\n    last_name = Varchar(null=True)\n    email = Varchar(length=255, unique=True)\n    active = Boolean(default=False)\n    admin = Boolean(\n        default=False, help_text=\"An admin can log into the Piccolo admin GUI.\"\n    )\n    superuser = Boolean(\n        default=False,\n        help_text=(\n            \"If True, this user can manage other users's passwords in the \"\n            \"Piccolo admin GUI.\"\n        ),\n    )\n    last_login = Timestamp(\n        null=True,\n        default=None,\n        required=False,\n        help_text=\"When this user last logged in.\",\n    )\n\n    _min_password_length = 6\n    _max_password_length = 128\n    # The number of hash iterations recommended by OWASP:\n    # https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#pbkdf2\n    _pbkdf2_iteration_count = 600_000\n\n    def __init__(self, **kwargs):\n        # Generating passwords upfront is expensive, so might need reworking.\n        password = kwargs.get(\"password\", None)\n        if password:\n            if not password.startswith(\"pbkdf2_sha256\"):\n                kwargs[\"password\"] = self.__class__.hash_password(password)\n        super().__init__(**kwargs)\n\n    @classmethod\n    def get_salt(cls):\n        return secrets.token_hex(16)\n\n    @classmethod\n    def get_readable(cls) -> Readable:\n        \"\"\"\n        Used to get a readable string, representing a table row.\n        \"\"\"\n        return Readable(template=\"%s\", columns=[cls.username])\n\n    ###########################################################################\n\n    @classmethod\n    def _validate_password(cls, password: str):\n        \"\"\"\n        Validate the raw password. Used by :meth:`update_password` and\n        :meth:`create_user`.\n\n        :param password:\n            The raw password e.g. ``'hello123'``.\n        :raises ValueError:\n            If the password fails any of the criteria.\n\n        \"\"\"\n        if not password:\n            raise ValueError(\"A password must be provided.\")\n\n        if len(password) < cls._min_password_length:\n            raise ValueError(\"The password is too short.\")\n\n        if len(password) > cls._max_password_length:\n            raise ValueError(\"The password is too long.\")\n\n        if password.startswith(\"pbkdf2_sha256\"):\n            logger.warning(\n                \"Tried to create a user with an already hashed password.\"\n            )\n            raise ValueError(\"Do not pass a hashed password.\")\n\n    ###########################################################################\n\n    @classmethod\n    def update_password_sync(cls, user: t.Union[str, int], password: str):\n        \"\"\"\n        A sync equivalent of :meth:`update_password`.\n        \"\"\"\n        return run_sync(cls.update_password(user, password))\n\n    @classmethod\n    async def update_password(cls, user: t.Union[str, int], password: str):\n        \"\"\"\n        The password is the raw password string e.g. ``'password123'``.\n        The user can be a user ID, or a username.\n        \"\"\"\n        if isinstance(user, str):\n            clause = cls.username == user\n        elif isinstance(user, int):\n            clause = cls.id == user\n        else:\n            raise ValueError(\n                \"The `user` arg must be a user id, or a username.\"\n            )\n\n        cls._validate_password(password=password)\n\n        password = cls.hash_password(password)\n        await cls.update({cls.password: password}).where(clause).run()\n\n    ###########################################################################\n\n    @classmethod\n    def hash_password(\n        cls, password: str, salt: str = \"\", iterations: t.Optional[int] = None\n    ) -> str:\n        \"\"\"\n        Hashes the password, ready for storage, and for comparing during\n        login.\n\n        :raises ValueError:\n            If an excessively long password is provided.\n\n        \"\"\"\n        if len(password) > cls._max_password_length:\n            logger.warning(\"Excessively long password provided.\")\n            raise ValueError(\"The password is too long.\")\n\n        if not salt:\n            salt = cls.get_salt()\n\n        if iterations is None:\n            iterations = cls._pbkdf2_iteration_count\n\n        hashed = hashlib.pbkdf2_hmac(\n            \"sha256\",\n            bytes(password, encoding=\"utf-8\"),\n            bytes(salt, encoding=\"utf-8\"),\n            iterations,\n        ).hex()\n        return f\"pbkdf2_sha256${iterations}${salt}${hashed}\"\n\n    def __setattr__(self, name: str, value: t.Any):\n        \"\"\"\n        Make sure that if the password is set, it's stored in a hashed form.\n        \"\"\"\n        if name == \"password\" and not value.startswith(\"pbkdf2_sha256\"):\n            value = self.__class__.hash_password(value)\n\n        super().__setattr__(name, value)\n\n    @classmethod\n    def split_stored_password(cls, password: str) -> t.List[str]:\n        elements = password.split(\"$\")\n        if len(elements) != 4:\n            raise ValueError(\"Unable to split hashed password\")\n        return elements\n\n    ###########################################################################\n\n    @classmethod\n    def login_sync(cls, username: str, password: str) -> t.Optional[int]:\n        \"\"\"\n        A sync equivalent of :meth:`login`.\n        \"\"\"\n        return run_sync(cls.login(username, password))\n\n    @classmethod\n    async def login(cls, username: str, password: str) -> t.Optional[int]:\n        \"\"\"\n        Make sure the user exists and the password is valid. If so, the\n        ``last_login`` value is updated in the database.\n\n        :returns:\n            The id of the user if a match is found, otherwise ``None``.\n\n        \"\"\"\n        if len(username) > cls.username.length:\n            logger.warning(\"Excessively long username provided.\")\n            return None\n\n        if len(password) > cls._max_password_length:\n            logger.warning(\"Excessively long password provided.\")\n            return None\n\n        response = (\n            await cls.select(cls._meta.primary_key, cls.password)\n            .where(cls.username == username)\n            .first()\n            .run()\n        )\n        if not response:\n            # No match found. We still call hash_password\n            # here to mitigate the ability to enumerate\n            # users via response timings\n            cls.hash_password(password)\n            return None\n\n        stored_password = response[\"password\"]\n\n        algorithm, iterations_, salt, hashed = cls.split_stored_password(\n            stored_password\n        )\n        iterations = int(iterations_)\n\n        if cls.hash_password(password, salt, iterations) == stored_password:\n            # If the password was hashed in an earlier Piccolo version, update\n            # it so it's hashed with the currently recommended number of\n            # iterations:\n            if iterations != cls._pbkdf2_iteration_count:\n                await cls.update_password(username, password)\n\n            await cls.update({cls.last_login: datetime.datetime.now()}).where(\n                cls.username == username\n            )\n            return response[\"id\"]\n        else:\n            return None\n\n    ###########################################################################\n\n    @classmethod\n    def create_user_sync(\n        cls, username: str, password: str, **extra_params\n    ) -> BaseUser:\n        \"\"\"\n        A sync equivalent of :meth:`create_user`.\n        \"\"\"\n        return run_sync(\n            cls.create_user(\n                username=username, password=password, **extra_params\n            )\n        )\n\n    @classmethod\n    async def create_user(\n        cls, username: str, password: str, **extra_params\n    ) -> BaseUser:\n        \"\"\"\n        Creates a new user, and saves it in the database. It is recommended to\n        use this rather than instantiating and saving ``BaseUser`` directly, as\n        we add extra validation.\n\n        :raises ValueError:\n            If the username or password is invalid.\n        :returns:\n            The created ``BaseUser`` instance.\n\n        \"\"\"\n        if not username:\n            raise ValueError(\"A username must be provided.\")\n\n        cls._validate_password(password=password)\n\n        user = cls(username=username, password=password, **extra_params)\n        await user.save()\n        return user\n"], "filenames": ["piccolo/apps/user/tables.py"], "buggy_code_start_loc": [215], "buggy_code_end_loc": [216], "fixing_code_start_loc": [215], "fixing_code_end_loc": [219], "type": "CWE-203", "message": "Piccolo is an ORM and query builder which supports asyncio. In versions 0.120.0 and prior, the implementation of `BaseUser.login` leaks enough information to a malicious user such that they would be able to successfully generate a list of valid users on the platform. As Piccolo on its own does not also enforce strong passwords, these lists of valid accounts are likely to be used in a password spray attack with the outcome being attempted takeover of user accounts on the platform. The impact of this vulnerability is minor as it requires chaining with other attack vectors in order to gain more then simply a list of valid users on the underlying platform. The likelihood of this vulnerability is possible as it requires minimal skills to pull off, especially given the underlying login functionality for Piccolo based sites is open source. This issue has been patched in version 0.121.0.", "other": {"cve": {"id": "CVE-2023-41885", "sourceIdentifier": "security-advisories@github.com", "published": "2023-09-12T21:15:08.163", "lastModified": "2023-09-15T19:45:09.877", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Piccolo is an ORM and query builder which supports asyncio. In versions 0.120.0 and prior, the implementation of `BaseUser.login` leaks enough information to a malicious user such that they would be able to successfully generate a list of valid users on the platform. As Piccolo on its own does not also enforce strong passwords, these lists of valid accounts are likely to be used in a password spray attack with the outcome being attempted takeover of user accounts on the platform. The impact of this vulnerability is minor as it requires chaining with other attack vectors in order to gain more then simply a list of valid users on the underlying platform. The likelihood of this vulnerability is possible as it requires minimal skills to pull off, especially given the underlying login functionality for Piccolo based sites is open source. This issue has been patched in version 0.121.0."}, {"lang": "es", "value": "Piccolo es un ORM y un generador de consultas que admite asyncio. En las versiones 0.120.0 y anteriores, la implementaci\u00f3n de `BaseUser.login` filtra suficiente informaci\u00f3n a un usuario malicioso para que pueda generar con \u00e9xito una lista de usuarios v\u00e1lidos en la plataforma. Como Piccolo por s\u00ed solo no exige contrase\u00f1as seguras, es probable que estas listas de cuentas v\u00e1lidas se utilicen en un ataque de pulverizaci\u00f3n de contrase\u00f1as con el resultado de un intento de apoderarse de las cuentas de usuario en la plataforma. El impacto de esta vulnerabilidad es menor ya que requiere encadenamiento con otros vectores de ataque para obtener algo m\u00e1s que una simple lista de usuarios v\u00e1lidos en la plataforma subyacente. La probabilidad de que se produzca esta vulnerabilidad es posible ya que requiere habilidades m\u00ednimas para lograrla, especialmente dado que la funcionalidad de inicio de sesi\u00f3n subyacente para los sitios basados ??en Piccolo es de c\u00f3digo abierto. Este problema se solucion\u00f3 en la versi\u00f3n 0.121.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-203"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-204"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:piccolo-orm:piccolo:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.121.0", "matchCriteriaId": "48B448E6-A2DC-4E30-BC40-4C98014CBAA1"}]}]}], "references": [{"url": "https://github.com/piccolo-orm/piccolo/commit/edcfe3568382922ba3e3b65896e6e7272f972261", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/piccolo-orm/piccolo/security/advisories/GHSA-h7cm-mrvq-wcfr", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/piccolo-orm/piccolo/commit/edcfe3568382922ba3e3b65896e6e7272f972261"}}