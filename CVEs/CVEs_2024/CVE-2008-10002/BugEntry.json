{"buggy_code": ["/* Copyright (c) 2008, Katharine Berry\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of Katharine Berry nor the names of any contributors\n *       may be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY KATHARINE BERRY ``AS IS'' AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL KATHARINE BERRY BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n ******************************************************************************/\n\n// IM Window Handler\nAjaxLife.InstantMessage = function() {\n\t// Private\n\tvar dialog = false;\n\tvar activesession = false;\n\tvar width = 700;\n\tvar height = 400;\n\tvar chats = {};\n\tvar highlighted = new Array();\n\tvar origtabcolour = false;\n\tvar highlightcolour = 'red';\n\tvar highlight = false;\n\tvar friendlist = false;\n\tvar noted_typing = false;\n\tvar grouplist = false;\n\tvar groups = {};\n\t\n\tfunction fillgroups(data)\n\t{\n\t\tfor(var key in data.Groups)\n\t\t{\n\t\t\tvar group = data.Groups[key];\n\t\t\tgroups[key] = group;\n\t\t\tAjaxLife.NameCache.AddGroup(key,group.Name);\n\t\t\tgrouplist.add(key,group.Name);\n\t\t}\n\t}\n\t\n\t// Set a tab to flash\n\tfunction highlighttab(sessionid)\n\t{\n\t\tif(chats[sessionid] && highlighted.indexOf(sessionid) == -1)\n\t\t{\n\t\t\torigtabcolour = chats[sessionid].tab.textEl.getStyle('color');\n\t\t\thighlighted[highlighted.length] = sessionid;\n\t\t}\n\t};\n\t\n\t// Set a tab to stop flashing\n\tfunction unhighlight(sessionid)\n\t{\n\t\thighlighted = highlighted.without(sessionid);\n\t\tif(chats[sessionid]) chats[sessionid].tab.textEl.setStyle({color: origtabcolour});\n\t};\n\t\n\t// Turn the text of a tab red or not red, alternating each time it's called.\n\tfunction processhighlight()\n\t{\n\t\thighlight = !highlight;\n\t\thighlighted.each(function(item) {\n\t\t\t// Check that the tab's still there. If it's not, remove it from the array.\n\t\t\tif(chats[item])\n\t\t\t{\n\t\t\t\tchats[item].tab.textEl.setStyle({color: highlight?highlightcolour:origtabcolour});\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\thighlighted = highlighted.without(item);\n\t\t\t}\n\t\t});\n\t};\n\t\n\t// Handles resized tabs.\n\tfunction fixtab(sessionid)\n\t{\n\t\tif(chats[sessionid])\n\t\t{\n\t\t\tchats[sessionid].content.dom.scrollTop = chats[sessionid].content.dom.scrollHeight;\n\t\t\tchats[sessionid].content.setStyle({height: (height - 88)+'px'});\n\t\t\tchats[sessionid].entrybox.setStyle({width: (width - 133)+'px'});\n\t\t}\n\t};\n\t\n\t// Sends an IM saying the target, using the sessionid.\n\t// NOTE: sessionid should be the same each time an agent is messaged - otherwise the IM\n\t// will appear in a different tab in the official client.\n\tfunction sendmessage(target, message, sessionid)\n\t{\n\t\tif(message.blank())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif(sessionid == null)\n\t\t{\n\t\t\tsessionid = AjaxLife.Utils.UUID.Random();\n\t\t}\n\t\t// Notify other person that typing has stopped (unless we're in a group chat)\n\t\tif(!chats[sessionid].groupIM)\n\t\t{\n\t\t\tAjaxLife.Network.Send('GenericInstantMessage', {\n\t\t\t\tMessage: \"none\",\n\t\t\t\tTarget: chats[sessionid].target,\n\t\t\t\tIMSessionID: sessionid,\n\t\t\t\tOnline: AjaxLife.Constants.MainAvatar.InstantMessageOnline.Online,\n\t\t\t\tDialog: AjaxLife.Constants.MainAvatar.InstantMessageDialog.StopTyping\n\t\t\t});\n\t\t\tAjaxLife.Network.Send(\"SimpleInstantMessage\", {\n\t\t\t\tIMSessionID: sessionid,\n\t\t\t\tTarget: chats[sessionid].groupIM ? sessionid : target,\n\t\t\t\tMessage: message\n\t\t\t});\n\t\t\t// Add the IM to your own window, being sure to handle /me correctly.\n\t\t\tif(message.substr(0,3) == \"/me\")\n\t\t\t{\n\t\t\t\tmessage = gUserName+message.substr(3);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmessage = gUserName+\": \"+message;\n\t\t\t}\n\t\t\tappendline(sessionid,message);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tAjaxLife.Network.Send(\"GroupInstantMessage\", {\n\t\t\t\tMessage: message,\n\t\t\t\tGroup: sessionid\n\t\t\t});\n\t\t}\n\t\tnoted_typing = false;\n\t};\n\t\n\t// Creates a new IM session with agent \"id\" who is called \"name\".\n\t// Session ID should be generated such that all IMs with the target will have the same ID,\n\t// but IMs from different people to the same agent, or the same person to different agents, will not.\n\tfunction createTab(id, name, sessionid, groupIM)\n\t{\n\t\tif(!groupIM) groupIM = false; // Avoid differences between false and undefined.\n\t\tAjaxLife.Debug(\"InstantMessage: Creating session \"+sessionid+\" with \"+id+\" (\"+name+\"; groupIM = \"+groupIM+\")\");\n\t\t// Create the tab and add to the array.\n\t\tchats[sessionid] = {\n\t\t\ttab: dialog.getTabs().addTab(\"im-\"+sessionid, (groupIM ? \"(hippos)\" : name), \"\", true),\n\t\t\tname: name,\n\t\t\ttarget: id,\n\t\t\tcontent: false,\n\t\t\tentrybox: false,\n\t\t\tsendbtn: false,\n\t\t\tdiv_typing: false,\n\t\t\tsession: sessionid,\n\t\t\tgroupIM: groupIM\n\t\t};\n\t\tif(groupIM)\n\t\t{\n\t\t\tAjaxLife.Debug(\"InstantMessage: Looking up group \"+sessionid+\"...\");\n\t\t\tAjaxLife.NameCache.FindGroup(sessionid, function(groupname) {\n\t\t\t\tAjaxLife.Debug(\"InstantMessage: Found group name: \"+groupname);\n\t\t\t\tchats[sessionid].name = groupname;\n\t\t\t\tchats[sessionid].tab.setText(groupname);\n\t\t\t});\n\t\t}\n\t\tchats[sessionid].tab.on('close',function() {\n\t\t\t// Send message informing that we have left the conversation.\n\t\t\tAjaxLife.Network.Send('GenericInstantMessage', {\n\t\t\t\tMessage: \"\",\n\t\t\t\tTarget: id,\n\t\t\t\tIMSessionID: sessionid,\n\t\t\t\tOnline: AjaxLife.Constants.MainAvatar.InstantMessageOnline.Online,\n\t\t\t\tDialog: AjaxLife.Constants.MainAvatar.InstantMessageDialog.SessionDrop\n\t\t\t});\n\t\t\tif(dialog.getTabs().getActiveTab() && dialog.getTabs().getActiveTab().id == chats[sessionid].tab.id)\n\t\t\t{\n\t\t\t\tactivesession = false;\n\t\t\t}\n\t\t\tdelete chats[sessionid];\n\t\t});\n\t\tchats[sessionid].tab.bodyEl.setStyle({'overflow': 'hidden'});\n\t\t// Chat area\n\t\tvar content = Ext.get(document.createElement('div'));\n\t\tcontent.setStyle({overflow: 'auto', width:'99%'});\n\t\tchats[sessionid].content = content;\n\t\tvar entrybox = Ext.get(document.createElement('input'));\n\t\tentrybox.setHeight(20);\n\t\tchats[sessionid].entrybox = entrybox;\n\t\tchats[sessionid].tab.bodyEl.setStyle({overflow: 'hidden'});\n\t\tchats[sessionid].tab.bodyEl.dom.appendChild(content.dom);\n\t\tchats[sessionid].tab.bodyEl.dom.appendChild(entrybox.dom);\n\t\t// Button setup, callbacks and formatting.\n\t\tvar style = {position: 'absolute', bottom: '0px', right: '0px'};\n\t\tchats[sessionid].sendbtn = new Ext.Button(chats[sessionid].tab.bodyEl, {\n\t\t\thandler: function() {\n\t\t\t\tsendmessage(id, entrybox.dom.value, chats[sessionid].session);\n\t\t\t\tentrybox.dom.value = '';\n\t\t\t\tentrybox.dom.focus();\n\t\t\t},\n\t\t\ttext: _(\"InstantMessage.Send\")\n\t\t});\n\t\tchats[sessionid].sendbtn.getEl().setStyle(style);\n\t\tstyle.right = '48px';\n\t\t// We can't do group profiles yet.\n\t\tif(!groupIM)\n\t\t{\n\t\t\t(new Ext.Button(chats[sessionid].tab.bodyEl, {\n\t\t\t\thandler: function() {\n\t\t\t\t\tnew AjaxLife.Profile(chats[sessionid].target);\n\t\t\t\t},\n\t\t\t\ttext: _(\"InstantMessage.Profile\")\n\t\t\t})).getEl().setStyle(style);\n\t\t}\n\t\tdiv_typing = Ext.get(document.createElement('div'));\n\t\tdiv_typing.addClass(['chatline','agenttyping']);\n\t\tdiv_typing.dom.appendChild(document.createTextNode(_(\"InstantMessage.Typing\",{name: name})));\n\t\tchats[sessionid].div_typing = div_typing;\n\t\t// None of the \"... is typing\" stuff works in group IMs.\n\t\tif(!groupIM)\n\t\t{\n\t\t\t// Called two seconds after the last key is pressed. Sends not typing notification.\n\t\t\tvar delayed_stop_typing = new Ext.util.DelayedTask(function() {\n\t\t\t\tAjaxLife.Network.Send('GenericInstantMessage', {\n\t\t\t\t\tMessage: \"none\",\n\t\t\t\t\tTarget: chats[sessionid].target,\n\t\t\t\t\tIMSessionID: chats[sessionid].session,\n\t\t\t\t\tOnline: AjaxLife.Constants.MainAvatar.InstantMessageOnline.Online,\n\t\t\t\t\tDialog: AjaxLife.Constants.MainAvatar.InstantMessageDialog.StopTyping\n\t\t\t\t});\n\t\t\t\tnoted_typing = false;\n\t\t\t});\n\t\t\t// Sends typing notification and sets timeout for above function to two seconds.\n\t\t\tentrybox.on('keypress',function(e) {\n\t\t\t\tif(!noted_typing)\n\t\t\t\t{\n\t\t\t\t\tnoted_typing = true;\n\t\t\t\t\tAjaxLife.Network.Send('GenericInstantMessage', {\n\t\t\t\t\t\tMessage: \"none\",\n\t\t\t\t\t\tTarget: chats[sessionid].target,\n\t\t\t\t\t\tIMSessionID: chats[sessionid].session,\n\t\t\t\t\t\tOnline: AjaxLife.Constants.MainAvatar.InstantMessageOnline.Online,\n\t\t\t\t\t\tDialog: AjaxLife.Constants.MainAvatar.InstantMessageDialog.StartTyping\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tdelayed_stop_typing.delay(2000);\n\t\t\t});\n\t\t}\n\t\tentrybox.on('keyup',function(e) {\n\t\t\tif(e.keyCode == 13 || e.which == 13)\n\t\t\t{\n\t\t\t\tsendmessage(id, entrybox.dom.value, sessionid);\n\t\t\t\tentrybox.dom.value = '';\n\t\t\t\tentrybox.dom.focus();\n\t\t\t}\n\t\t});\n\t\tchats[sessionid].tab.on('activate',function() {\n\t\t\tunhighlight(sessionid);\n\t\t\tactivesession = sessionid;\n\t\t\tfixtab(sessionid);\n\t\t\tentrybox.dom.focus();\n\t\t});\n\t\tvar currenttab = dialog.getTabs().getActiveTab().id;\n\t\t// These are essentially contentless, so switch IM window if we're activated and on one of these.\n\t\tif(currenttab == 'im-default-tab' || currenttab == 'im-group-tab')\n\t\t{\n\t\t\tchats[sessionid].tab.activate();\n\t\t}\n\t\treturn true;\n\t};\n\t\n\t// Append a line to the box with a timestamp.\n\tfunction appendline(session, text)\n\t{\n\t\tif(chats[session] && chats[session].content)\n\t\t{\n\t\t\ttext = AjaxLife.Utils.LinkURLs(text);\n\t\t\tvar line = Ext.get(document.createElement('div'));\n\t\t\tline.addClass([\"agentmessage\",\"chatline\"]);\n\t\t\tvar timestamp = Ext.get(document.createElement('span'));\n\t\t\ttimestamp.addClass(\"chattimestamp\");\n\t\t\tvar time = new Date();\n\t\t\ttimestamp.dom.appendChild(document.createTextNode(\"[\"+time.getHours()+\":\"+((time.getMinutes()<10)?(\"0\"+time.getMinutes()):time.getMinutes())+\"]\"));\n\t\t\tline.dom.appendChild(timestamp.dom);\n\t\t\tline.dom.appendChild(document.createTextNode(\" \"));\n\t\t\tvar span = document.createElement('span');\n\t\t\tspan.innerHTML = text;\n\t\t\tline.dom.appendChild(span);\n\t\t\tchats[session].content.dom.appendChild(line.dom);\n\t\t\t// Scroll to the end.\n\t\t\tchats[session].content.dom.scrollTop = chats[session].content.dom.scrollHeight;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tAjaxLife.Widgets.Ext.msg(\"Warning\",\"Instant message with unknown ID {0}:<br />{1}\",session,text);\n\t\t}\n\t};\n\t\n\tfunction joingroupchat(group)\n\t{\t\t\n\t\tAjaxLife.Network.Send(\"GenericInstantMessage\", {\n\t\t\tMessage: \"\",\n\t\t\tTarget: group,\n\t\t\tIMSessionID: group,\n\t\t\tOnline: AjaxLife.Constants.MainAvatar.InstantMessageOnline.Online,\n\t\t\tDialog: AjaxLife.Constants.MainAvatar.InstantMessageDialog.SessionGroupStart\n\t\t});\n\t}\n\t\n\treturn {\n\t\t// Public\n\t\tinit: function () {\n\t\t\t// Create the new window at 700x400, with a default tab for friendlist.\n\t\t\tdialog = new Ext.BasicDialog(\"dlg_im\", {\n\t\t\t\theight: 400,\n\t\t\t\twidth: 700,\n\t\t\t\tminHeight: 100,\n\t\t\t\tminWidth: 150,\n\t\t\t\tmodal: false,\n\t\t\t\tshadow: true,\n\t\t\t\tautoCreate: true,\n\t\t\t\ttitle: _(\"InstantMessage.WindowTitle\"),\n\t\t\t\tproxyDrag: !AjaxLife.Fancy\n\t\t\t});\n\t\t\t\n\t\t\tdialog.getTabs().addTab(\"im-default-tab\",_(\"InstantMessage.OnlineFriends\"),\"\",false).activate();\n\t\t\tfriendlist = new AjaxLife.Widgets.SelectList('im-friend-list',dialog.getTabs().getActiveTab().bodyEl.dom,{\n\t\t\t\twidth: '99%',\n\t\t\t\tcallback: function(key) {\n\t\t\t\t\tAjaxLife.NameCache.Find(key, function(name) {\n\t\t\t\t\t\tcreateTab(key, name, AjaxLife.Utils.UUID.Combine(gAgentID,key));\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t\tvar sortdelay = new Ext.util.DelayedTask(function() {\n\t\t\t\tfriendlist.sort();\n\t\t\t});\n\t\t\t// Deal with adding and removing friends to/from the friend list.\n\t\t\tvar addname = function (friend) {\n\t\t\t\tif(friend.Online)\n\t\t\t\t{\n\t\t\t\t\tfriendlist.add(friend.ID,friend.Name);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfriendlist.remove(friend.ID);\n\t\t\t\t}\n\t\t\t\tsortdelay.delay(200);\n\t\t\t};\n\t\t\tAjaxLife.Friends.AddStatusCallback(addname);\n\t\t\tAjaxLife.Friends.AddNewFriendCallback(addname);\n\t\t\tdialog.body.setStyle({overflow: 'hidden'});\n\t\t\twidth = 700;\n\t\t\theight = 400;\n\t\t\tdialog.on('resize', function(d, w, h) {\n\t\t\t\twidth = w;\n\t\t\t\theight = h;\n\t\t\t\tfixtab(activesession);\n\t\t\t});\n\t\t\t\n\t\t\tvar grouptab = dialog.getTabs().addTab(\"im-group-tab\",_(\"InstantMessage.Groups\"), \"\", false);\n\t\t\t\n\t\t\tgrouplist = new AjaxLife.Widgets.SelectList(\"im-group-list\", grouptab.bodyEl.dom, {\n\t\t\t\twidth: '99%',\n\t\t\t\tcallback: function(key) {\n\t\t\t\t\tjoingroupchat(key);\n\t\t\t\t\tcreateTab(key, key, key, true);\n\t\t\t\t\tchats[key].entrybox.dom.enabled = false;\n\t\t\t\t\tchats[key].sendbtn.getEl().dom.enabled = false;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\t// Handle successfully started chats.\n\t\t\tAjaxLife.Network.MessageQueue.RegisterCallback('ChatGroupJoin', function(data) {\n\t\t\t\tvar group = data.GroupChatSessionID;\n\t\t\t\tif(chats[group] && !chats[group].entrybox.dom.enabled)\n\t\t\t\t{\n\t\t\t\t\tif(data.Success)\n\t\t\t\t\t{\n\t\t\t\t\t\tchats[group].entrybox.dom.enabled = true;\n\t\t\t\t\t\tchats[group].sentbtn.dom.enabled = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tappendline(group, _(\"InstantMessage.SessionCreateFailed\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\t// Handle incoming IMs.\n\t\t\tAjaxLife.Network.MessageQueue.RegisterCallback('InstantMessage',function(data) {\n\t\t\t\t// Ensure it's something to display\n\t\t\t\tif(data.IMSessionID == AjaxLife.Utils.UUID.Zero) return; // Estate messages have null sessions.\n\t\t\t\tif(data.Dialog == AjaxLife.Constants.MainAvatar.InstantMessageDialog.MessageFromAgent || data.Dialog == AjaxLife.Constants.MainAvatar.InstantMessageDialog.SessionSend)\n\t\t\t\t{\n\t\t\t\t\t// Create a tab for them if we haven't already. Also play new IM sound.\n\t\t\t\t\tif(!chats[data.IMSessionID])\n\t\t\t\t\t{\n\t\t\t\t\t\tAjaxLife.Widgets.Ext.msg(\"\",_(\"InstantMessage.NewIMSession\", {from: data.FromAgentName}), \"newimsession\", true);\n\t\t\t\t\t\tif(data.GroupIM) joingroupchat(data.IMSessionID);\n\t\t\t\t\t\tvar created = createTab(data.FromAgentID, data.FromAgentName, data.IMSessionID, data.GroupIM);\n\t\t\t\t\t\tif(!created)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tAjaxLife.Widgets.Ext.msg(\"Lost Instant Message\",\"From: {0}<br />Message: {1}\",data.FromAgentName,data.Message);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!dialog.isVisible())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdialog.show();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSound.play(AjaxLife.STATIC_ROOT+\"sounds/im.wav\");\n\t\t\t\t\t}\n\t\t\t\t\t// Format the incoming message, taking care of /me.\n\t\t\t\t\tvar message = data.Message;\n\t\t\t\t\tif(message.substr(0,3) == \"/me\")\n\t\t\t\t\t{\n\t\t\t\t\t\tmessage = data.FromAgentName+message.substr(3);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tmessage = data.FromAgentName+\": \"+message;\n\t\t\t\t\t}\n\t\t\t\t\t// Assume they stopped typing.\n\t\t\t\t\tif(chats[data.IMSessionID].div_typing.dom.parentNode)\n\t\t\t\t\t{\n\t\t\t\t\t\tchats[data.IMSessionID].div_typing.dom.parentNode.removeChild(chats[data.IMSessionID].div_typing.dom);\n\t\t\t\t\t}\n\t\t\t\t\t// Actually add the line.\n\t\t\t\t\tappendline(data.IMSessionID, message);\n\t\t\t\t\t// If the tab is not active, make it flash.\n\t\t\t\t\tif(dialog.getTabs().getActiveTab().id != 'im-'+data.IMSessionID)\n\t\t\t\t\t{\n\t\t\t\t\t\thighlighttab(data.IMSessionID);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If we have a tab for the sessionid...\n\t\t\t\tif(chats[data.IMSessionID])\n\t\t\t\t{\n\t\t\t\t\t// Show typing note on StartTyping message, remove it on StopTyping.\n\t\t\t\t\tif(data.Dialog == AjaxLife.Constants.MainAvatar.InstantMessageDialog.StartTyping)\n\t\t\t\t\t{\n\t\t\t\t\t\t// If it's already there higher up, remove it from there.\n\t\t\t\t\t\t// This is arguably completely redundant.\n\t\t\t\t\t\tif(chats[data.IMSessionID].div_typing.dom.parentNode)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchats[data.IMSessionID].div_typing.dom.parentNode.removeChild(chats[data.IMSessionID].div_typing.dom);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchats[data.IMSessionID].content.dom.appendChild(chats[data.IMSessionID].div_typing.dom);\n\t\t\t\t\t\t// Scroll down to show it.\n\t\t\t\t\t\tchats[data.IMSessionID].content.dom.scrollTop = chats[data.IMSessionID].content.dom.scrollHeight;\n\t\t\t\t\t}\n\t\t\t\t\telse if(data.Dialog == AjaxLife.Constants.MainAvatar.InstantMessageDialog.StopTyping)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(chats[data.IMSessionID].div_typing && \n\t\t\t\t\t\t\tchats[data.IMSessionID].div_typing.dom.parentNode && \n\t\t\t\t\t\t\ttypeof chats[data.IMSessionID].div_typing.dom.parentNode.removeChild == 'function')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchats[data.IMSessionID].div_typing.dom.parentNode.removeChild(chats[data.IMSessionID].div_typing.dom);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tAjaxLife.Network.MessageQueue.RegisterCallback('CurrentGroups', fillgroups);\n\t\t\tAjaxLife.Network.Send(\"RequestCurrentGroups\",{});\n\t\t\t// Highlighted tabs to flash every half second.\n\t\t\tsetInterval(processhighlight,500);\n\t\t},\n\t\topen: function(opener) {\n\t\t\tif(opener)\n\t\t\t{\n\t\t\t\tdialog.show(opener);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdialog.show();\n\t\t\t}\n\t\t},\n\t\tclose: function() {\n\t\t\tdialog.hide();\n\t\t},\n\t\ttoggle: function(opener) {\n\t\t\tif(!dialog.isVisible())\n\t\t\t{\n\t\t\t\tthis.open(opener);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.close();\n\t\t\t}\n\t\t},\n\t\tstart: function(id) {\n\t\t\tAjaxLife.NameCache.Find(id, function(name) {\n\t\t\t\tcreateTab(id,name,AjaxLife.Utils.UUID.Combine(gAgentID,id));\n\t\t\t});\n\t\t}\n\t};\n}();", "/* Copyright (c) 2007, Katharine Berry\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of Katharine Berry nor the names of any contributors\n *       may be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY KATHARINE BERRY ``AS IS'' AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL KATHARINE BERRY BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n ******************************************************************************/\n\nAjaxLife.SpatialChat = function() {\n\t// Private\n\tvar chat_win = false;\n\tvar div_chat_history = false;\n\tvar box_chat_entry = false;\n\tvar btn_shout = false;\n\tvar btn_say = false;\n\tvar btn_whisper = false;\n\tvar last_channel = 0;\n\tvar anim_started = false;\n\t\n\t// Send a message to the server.\n\t// If the message starts with a \"/\", extra processing takes place first:\n\t// If the message starts \"//\" it's sent on the the last-used channel.\n\t// If the message starts \"/123\" (or other number), the message is sent on that channel.\n\t// The channel number is determined by counting characters forward until we reach something\n\t// not in the numbers array.\n\t// The message will be sent back to us, so we don't have to add it to the log.\n\tfunction sendmessage(type, message)\n\t{\n\t\tvar channel = 0;\n\t\tvar nums = [0,1,2,3,4,5,6,7,8,9];\n\t\tvar indexpos = 0;\n\t\tif(message.substr(0,1) == \"/\")\n\t\t{\n\t\t\tif(message.substr(1,1) == \"/\")\n\t\t\t{\n\t\t\t\tchannel = last_channel;\n\t\t\t\tmessage = message.substr(2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(var i = 1; i < message.length; ++i)\n\t\t\t\t{\n\t\t\t\t\tif(nums.indexOf(message.substr(i,1)) > -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tindexpos = i;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(indexpos > 0)\n\t\t\t\t{\n\t\t\t\t\tchannel = message.substr(1,indexpos);\n\t\t\t\t\tlast_channel = channel;\n\t\t\t\t\tmessage = message.substr(indexpos+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tAjaxLife.Network.Send(\"SpatialChat\", {\n\t\t\tMessage: message,\n\t\t\tChannel: channel,\n\t\t\tType: type\n\t\t});\n\t}\n\t\n\t// Add a line to the chatlog. Formatting is applied based on the sourcetype,\n\t// and a timestamp is calculated in the user's timezone (assuming their computer clock is accurate)\n\tfunction add(text, sourcetype)\n\t{\n\t\ttext = AjaxLife.Utils.LinkURLs(text);\n\t\t// Make a div to put this in.\n\t\tvar line = Ext.get(document.createElement('div'));\n\t\tline.addClass(\"chatline\");\n\t\t// Give the line the appropriate class for the type of message it is.\n\t\tif(sourcetype == AjaxLife.Constants.MainAvatar.ChatSourceType.System)\n\t\t{\n\t\t\tline.addClass(\"systemmessage\");\n\t\t}\n\t\telse if(sourcetype == AjaxLife.Constants.MainAvatar.ChatSourceType.Agent)\n\t\t{\n\t\t\tline.addClass(\"agentmessage\");\n\t\t}\n\t\telse if(sourcetype == AjaxLife.Constants.MainAvatar.ChatSourceType.Object)\n\t\t{\n\t\t\tline.addClass(\"objectmessage\");\n\t\t}\n\t\tvar timestamp = Ext.get(document.createElement('span'));\n\t\t// Make a timestamp in the user's timezone\n\t\ttimestamp.addClass(\"chattimestamp\");\n\t\tvar time = new Date();\n\t\t// Build the timestamp into an actual string and put it into an HTML node.\n\t\ttimestamp.dom.appendChild(document.createTextNode(\"[\" + time.getHours() + \":\" + ((time.getMinutes() < 10) ? (\"0\" + time.getMinutes()) : time.getMinutes()) + \"]\"));\n\t\t// Put the timestamp at the beginning of the line.\n\t\tline.dom.appendChild(timestamp.dom);\n\t\t// Add the actual text.\n\t\tline.dom.appendChild(document.createTextNode(\" \"));\n\t\tvar span = document.createElement('span');\n\t\tspan.innerHTML = text;\n\t\tline.dom.appendChild(span);\n\t\t// Add the line to the chat log.\n\t\tdiv_chat_history.dom.appendChild(line.dom);\n\t\t// Scroll the chatlog down to the new entry.\n\t\tdiv_chat_history.dom.scrollTop = div_chat_history.dom.scrollHeight;\n\t}\n\t\n\t// Some incoming chat. This is essentially a wrapper around addline, with some\n\t// processing to deal with formatting it in the first person, use of \"/me\"\n\t// (which requres removal of the colon), and to add the appropriate verb to the line\n\t// (i.e. if they're shouting or whispering)\n\tfunction incomingline (name, message, sourcetype, type)\n\t{\n\t\t// Ignore blank lines.\n\t\tif(message.blank())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t// Only do this processing if it's not a system message.\n\t\tif(sourcetype != AjaxLife.Constants.MainAvatar.ChatSourceType.System)\n\t\t{\n\t\t\t// If it's a /me, strip the \"/me\" and combine the name and message.\n\t\t\tif(message.substr(0,3) == \"/me\")\n\t\t\t{\n\t\t\t\tmessage = name+message.substr(3);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar you = false;\n\t\t\t\t// If we said it.\n\t\t\t\tif(name == gUserName)\n\t\t\t\t{\n\t\t\t\t\tname = _(\"SpatialChat.You\");\n\t\t\t\t\tyou = true;\n\t\t\t\t}\n\t\t\t\t// Say it was shouted if it was shouted.\n\t\t\t\tif(type == AjaxLife.Constants.MainAvatar.ChatType.Shout)\n\t\t\t\t{\n\t\t\t\t\tmessage = name+(you?_(\"SpatialChat.SecondPersonShout\"):_(\"SpatialChat.ThirdPersonShout\"))+\" \"+message;\n\t\t\t\t}\n\t\t\t\t// Say it was whispered if it was whispered.\n\t\t\t\telse if(type == AjaxLife.Constants.MainAvatar.ChatType.Whisper)\n\t\t\t\t{\n\t\t\t\t\tmessage = name+(you?_(\"SpatialChat.SecondPersonWhisper\"):_(\"SpatialChat.ThirdPersonWhisper\"))+\" \"+message;\n\t\t\t\t}\n\t\t\t\t// Otherwise just use a colon.\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmessage = name+(you?_(\"SpatialChat.SecondPersonSay\"):_(\"SpatialChat.ThirdPersonSay\"))+\" \"+message;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Add it do the display.\n\t\tadd(message, sourcetype);\n\t}\n\t\n\treturn {\n\t\t// Public\n\t\tinit: function() {\n\t\t\t// Build the window and UI\n\t\t\tchat_win = new Ext.BasicDialog(\"dlg_chat\",{\n\t\t\t\twidth: 500,\n\t\t\t\theight: 300,\n\t\t\t\tmodal: false,\n\t\t\t\tshadow: true,\n\t\t\t\tautoCreate: true,\n\t\t\t\ttitle: _(\"SpatialChat.WindowTitle\"),\n\t\t\t\tproxyDrag: !AjaxLife.Fancy\n\t\t\t});\n\t\t\tchat_win.body.setStyle({overflow: 'hidden'});\n\t\t\tdiv_chat_history = Ext.get(document.createElement('div'));\n\t\t\tdiv_chat_history.setStyle({height: '241px', width: '99%', overflow: 'auto'});\n\t\t\tbox_chat_entry = Ext.get(document.createElement('input'));\n\t\t\tbox_chat_entry.dom.setAttribute('type','text');\n\t\t\tbox_chat_entry.setStyle({width: '310px', height: '15px', 'float': 'left'});\n\t\t\t// Resize the chatlog and input line when the window is resized.\n\t\t\tchat_win.on('resize',function(win, width, height) {\n\t\t\t\tdiv_chat_history.setStyle({height: (height-59)+'px'});\n\t\t\t\tbox_chat_entry.setStyle({width: (width-190)+'px'});\n\t\t\t\tdiv_chat_history.dom.scrollTop = div_chat_history.dom.scrollHeight;\n\t\t\t});\n\t\t\t\n\t\t\tchat_win.body.dom.appendChild(div_chat_history.dom);\n\t\t\tchat_win.body.dom.appendChild(box_chat_entry.dom);\n\t\t\t// All of these buttons do exactly the same thing, but use a differing ChatType.\n\t\t\t// They clear the input box, focus it, and send the message. Not in that order.\n\t\t\tbtn_say = new Ext.Button(chat_win.body, {\n\t\t\t\thandler: function() {\n\t\t\t\t\tsendmessage(AjaxLife.Constants.MainAvatar.ChatType.Normal,box_chat_entry.dom.value);\n\t\t\t\t\tbox_chat_entry.dom.value = '';\n\t\t\t\t\tbox_chat_entry.dom.focus();\n\t\t\t\t},\n\t\t\t\ttext: _(\"SpatialChat.Say\"),\n\t\t\t\theight: '12px'\n\t\t\t});\n\t\t\tbtn_say.getEl().setStyle({position: 'absolute', right: '125px', bottom: '2px'});\n\t\t\tbtn_whisper = new Ext.Button(chat_win.body, {\n\t\t\t\thandler: function() {\n\t\t\t\t\tsendmessage(AjaxLife.Constants.MainAvatar.ChatType.Whisper,box_chat_entry.dom.value);\n\t\t\t\t\tbox_chat_entry.dom.value = '';\n\t\t\t\t\tbox_chat_entry.dom.focus();\n\t\t\t\t},\n\t\t\t\ttext: _(\"SpatialChat.Whisper\"),\n\t\t\t\theight: '12px'\n\t\t\t});\n\t\t\tbtn_whisper.getEl().setStyle({position: 'absolute', right: '59px', bottom: '2px'});\n\t\t\tbtn_shout = new Ext.Button(chat_win.body, {\n\t\t\t\thandler: function() {\n\t\t\t\t\tsendmessage(AjaxLife.Constants.MainAvatar.ChatType.Shout,box_chat_entry.dom.value);\n\t\t\t\t\tbox_chat_entry.dom.value = '';\n\t\t\t\t\tbox_chat_entry.dom.focus();\n\t\t\t\t},\n\t\t\t\ttext: _(\"SpatialChat.Shout\"),\n\t\t\t\theight: '12px'\n\t\t\t});\n\t\t\tbtn_shout.getEl().setStyle({position: 'absolute', right: '5px', bottom: '2px'});\n\t\t\t// This captures keys pressed in the chatbox. If the key was the return key,\n\t\t\t// we send the message and stop the typing animation. The remainder is handled by\n\t\t\t// the keypress event later on, as that accounts for holding keys down. This isn't there\n\t\t\t// because we don't want the message to be sent repeatedly.\n\t\t\tbox_chat_entry.addListener('keyup', function(event) {\n\t\t\t\tif(event.keyCode == 13 || event.which == 13)\n\t\t\t\t{\n\t\t\t\t\tif(box_chat_entry.dom.value != '')\n\t\t\t\t\t{\n\t\t\t\t\t\tAjaxLife.Network.Send(\"StopAnimation\", {\n\t\t\t\t\t\t\tAnimation: AjaxLife.Constants.Animations.avatar_type\n\t\t\t\t\t\t});\n\t\t\t\t\t\tAjaxLife.Network.Send(\"SpatialChat\", {\n\t\t\t\t\t\t\tMessage: \"a\",\n\t\t\t\t\t\t\tChannel: 0,\n\t\t\t\t\t\t\tType: AjaxLife.Constants.MainAvatar.ChatType.StopTyping\n\t\t\t\t\t\t});\n\t\t\t\t\t\tanim_started = false;\n\t\t\t\t\t\tsendmessage(AjaxLife.Constants.MainAvatar.ChatType.Normal,box_chat_entry.dom.value);\n\t\t\t\t\t\tbox_chat_entry.dom.value = '';\n\t\t\t\t\t\tbox_chat_entry.dom.focus();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\t// This is set by the keypress event in the chatbox. It stops the typing animation\n\t\t\t// and sends the StopTyping message.\n\t\t\tvar chat_stop_task = new Ext.util.DelayedTask(function() {\n\t\t\t\t//AjaxLife.Network.Send(\"StopAnimation\", {\n\t\t\t\t// FIXME: Code duplication is bad. (See 17 lines up)\n\t\t\t\tAjaxLife.Network.Send(\"StopAnimation\", {\n\t\t\t\t\tAnimation: AjaxLife.Constants.Animations.avatar_type\n\t\t\t\t});\n\t\t\t\tAjaxLife.Network.Send(\"SpatialChat\", {\n\t\t\t\t\tMessage: \"a\",\n\t\t\t\t\tChannel: 0,\n\t\t\t\t\tType: AjaxLife.Constants.MainAvatar.ChatType.StopTyping\n\t\t\t\t});\n\t\t\t\tanim_started = false;\n\t\t\t});\n\t\t\t// If the first character of the text is not \"/\", this sends the StartTyping\n\t\t\t// message and starts the typing animation, if this hasn't already been done.\n\t\t\t// After two seconds of not typing, the chat_stop_task function will be fired.\n\t\t\tbox_chat_entry.addListener('keypress', function(event) {\n\t\t\t\tif(!anim_started && box_chat_entry.dom.value.substr(0,1) != '/')\n\t\t\t\t{\n\t\t\t\t\tanim_started = true;\n\t\t\t\t\tAjaxLife.Network.Send(\"StartAnimation\", {\n\t\t\t\t\t\tAnimation: AjaxLife.Constants.Animations.avatar_type\n\t\t\t\t\t});\n\t\t\t\t\tAjaxLife.Network.Send(\"SpatialChat\", {\n\t\t\t\t\t\tMessage: \"a\",\n\t\t\t\t\t\tChannel: 0,\n\t\t\t\t\t\tType: AjaxLife.Constants.MainAvatar.ChatType.StartTyping\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tchat_stop_task.delay(2000);\n\t\t\t});\n\t\t\t\n\t\t\t//chat_win.on('open', function() {\n\t\t\t//\tbox_chat_entry.dom.focus();\t\t\t\t\t\t \n\t\t\t//});\n\t\t\t\n\t\t\t// Friend notifications.\n\t\t\t// This just adds an online/offline note to the chatlog when friends log on or off.\n\t\t\tAjaxLife.Friends.AddStatusCallback(function(friend) {\n\t\t\t\tadd(_(\"Friends.OnlineNotification\",{name: friend.Name, status: (friend.Online?_(\"Friends.Online\"):_(\"Friends.Offline\"))}),AjaxLife.Constants.MainAvatar.ChatSourceType.System);\n\t\t\t});\n\t\t\t\n\t\t\t// Incoming chat.\n\t\t\t// This deals with incoming chat. If it's audible, and is a type of standard chat,\n\t\t\t// it is proceesed by the incomingline function. Otherwise we ignore it.\n\t\t\t// (To avoid printing messages whenever people type or annoying things like that)\n\t\t\tAjaxLife.Network.MessageQueue.RegisterCallback('SpatialChat', function(data) {\n\t\t\t\tif(data.Audible > -1)\n\t\t\t\t{\n\t\t\t\t\t// Check that it is actually a displayable chat message.\n\t\t\t\t\tif(data.Type == AjaxLife.Constants.MainAvatar.ChatType.Whisper\t|| \n\t\t\t\t\t\tdata.Type == AjaxLife.Constants.MainAvatar.ChatType.Shout\t||\n\t\t\t\t\t\tdata.Type == AjaxLife.Constants.MainAvatar.ChatType.Normal\t||\n\t\t\t\t\t\tdata.Type == AjaxLife.Constants.MainAvatar.ChatType.OwnerSay)\n\t\t\t\t\t{\n\t\t\t\t\t\tincomingline(data.FromName, data.Message,data.SourceType, data.Type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\t// We subscribe to the InstantMessage event in order to take account of objects\n\t\t\t// using the llInstantMessage function. We simply handle this as normal object chat.\n\t\t\tAjaxLife.Network.MessageQueue.RegisterCallback('InstantMessage', function(data) {\n\t\t\t\t// Only do anything if this message comes from an object.\n\t\t\t\tif(data.Dialog == AjaxLife.Constants.MainAvatar.InstantMessageDialog.MessageFromObject)\n\t\t\t\t{\n\t\t\t\t\tincomingline(data.FromAgentName, data.Message, AjaxLife.Constants.MainAvatar.ChatSourceType.Object, AjaxLife.Constants.MainAvatar.ChatType.Normal);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t\n\t\t// Manually add a line to the chatlog\n\t\taddline: function(name, message, sourcetype, type) {\n\t\t\tincomingline(name, message, sourcetype, type);\n\t\t},\n\t\t// Add a system message to the chatlog.\n\t\tsystemmessage: function(message) {\n\t\t\tadd(message,AjaxLife.Constants.MainAvatar.ChatSourceType.System);\n\t\t},\n\t\topen: function(opener) {\n\t\t\tif(opener)\n\t\t\t{\n\t\t\t\tchat_win.show(opener);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchat_win.show();\n\t\t\t}\n\t\t},\n\t\tclose: function() {\n\t\t\tchat_win.hide();\n\t\t},\n\t\ttoggle: function(opener) {\n\t\t\tif(!chat_win.isVisible())\n\t\t\t{\n\t\t\t\tif(opener)\n\t\t\t\t{\n\t\t\t\t\tchat_win.show(opener);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tchat_win.show();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchat_win.hide();\n\t\t\t}\n\t\t}\n\t};\n}();"], "fixing_code": ["/* Copyright (c) 2008, Katharine Berry\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of Katharine Berry nor the names of any contributors\n *       may be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY KATHARINE BERRY ``AS IS'' AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL KATHARINE BERRY BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n ******************************************************************************/\n\n// IM Window Handler\nAjaxLife.InstantMessage = function() {\n\t// Private\n\tvar dialog = false;\n\tvar activesession = false;\n\tvar width = 700;\n\tvar height = 400;\n\tvar chats = {};\n\tvar highlighted = new Array();\n\tvar origtabcolour = false;\n\tvar highlightcolour = 'red';\n\tvar highlight = false;\n\tvar friendlist = false;\n\tvar noted_typing = false;\n\tvar grouplist = false;\n\tvar groups = {};\n\t\n\tfunction fillgroups(data)\n\t{\n\t\tfor(var key in data.Groups)\n\t\t{\n\t\t\tvar group = data.Groups[key];\n\t\t\tgroups[key] = group;\n\t\t\tAjaxLife.NameCache.AddGroup(key,group.Name);\n\t\t\tgrouplist.add(key,group.Name);\n\t\t}\n\t}\n\t\n\t// Set a tab to flash\n\tfunction highlighttab(sessionid)\n\t{\n\t\tif(chats[sessionid] && highlighted.indexOf(sessionid) == -1)\n\t\t{\n\t\t\torigtabcolour = chats[sessionid].tab.textEl.getStyle('color');\n\t\t\thighlighted[highlighted.length] = sessionid;\n\t\t}\n\t};\n\t\n\t// Set a tab to stop flashing\n\tfunction unhighlight(sessionid)\n\t{\n\t\thighlighted = highlighted.without(sessionid);\n\t\tif(chats[sessionid]) chats[sessionid].tab.textEl.setStyle({color: origtabcolour});\n\t};\n\t\n\t// Turn the text of a tab red or not red, alternating each time it's called.\n\tfunction processhighlight()\n\t{\n\t\thighlight = !highlight;\n\t\thighlighted.each(function(item) {\n\t\t\t// Check that the tab's still there. If it's not, remove it from the array.\n\t\t\tif(chats[item])\n\t\t\t{\n\t\t\t\tchats[item].tab.textEl.setStyle({color: highlight?highlightcolour:origtabcolour});\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\thighlighted = highlighted.without(item);\n\t\t\t}\n\t\t});\n\t};\n\t\n\t// Handles resized tabs.\n\tfunction fixtab(sessionid)\n\t{\n\t\tif(chats[sessionid])\n\t\t{\n\t\t\tchats[sessionid].content.dom.scrollTop = chats[sessionid].content.dom.scrollHeight;\n\t\t\tchats[sessionid].content.setStyle({height: (height - 88)+'px'});\n\t\t\tchats[sessionid].entrybox.setStyle({width: (width - 133)+'px'});\n\t\t}\n\t};\n\t\n\t// Sends an IM saying the target, using the sessionid.\n\t// NOTE: sessionid should be the same each time an agent is messaged - otherwise the IM\n\t// will appear in a different tab in the official client.\n\tfunction sendmessage(target, message, sessionid)\n\t{\n\t\tif(message.blank())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif(sessionid == null)\n\t\t{\n\t\t\tsessionid = AjaxLife.Utils.UUID.Random();\n\t\t}\n\t\t// Notify other person that typing has stopped (unless we're in a group chat)\n\t\tif(!chats[sessionid].groupIM)\n\t\t{\n\t\t\tAjaxLife.Network.Send('GenericInstantMessage', {\n\t\t\t\tMessage: \"none\",\n\t\t\t\tTarget: chats[sessionid].target,\n\t\t\t\tIMSessionID: sessionid,\n\t\t\t\tOnline: AjaxLife.Constants.MainAvatar.InstantMessageOnline.Online,\n\t\t\t\tDialog: AjaxLife.Constants.MainAvatar.InstantMessageDialog.StopTyping\n\t\t\t});\n\t\t\tAjaxLife.Network.Send(\"SimpleInstantMessage\", {\n\t\t\t\tIMSessionID: sessionid,\n\t\t\t\tTarget: chats[sessionid].groupIM ? sessionid : target,\n\t\t\t\tMessage: message\n\t\t\t});\n\t\t\t// Add the IM to your own window, being sure to handle /me correctly.\n\t\t\tif(message.substr(0,3) == \"/me\")\n\t\t\t{\n\t\t\t\tmessage = gUserName+message.substr(3);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmessage = gUserName+\": \"+message;\n\t\t\t}\n\t\t\tappendline(sessionid,message);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tAjaxLife.Network.Send(\"GroupInstantMessage\", {\n\t\t\t\tMessage: message,\n\t\t\t\tGroup: sessionid\n\t\t\t});\n\t\t}\n\t\tnoted_typing = false;\n\t};\n\t\n\t// Creates a new IM session with agent \"id\" who is called \"name\".\n\t// Session ID should be generated such that all IMs with the target will have the same ID,\n\t// but IMs from different people to the same agent, or the same person to different agents, will not.\n\tfunction createTab(id, name, sessionid, groupIM)\n\t{\n\t\tif(!groupIM) groupIM = false; // Avoid differences between false and undefined.\n\t\tAjaxLife.Debug(\"InstantMessage: Creating session \"+sessionid+\" with \"+id+\" (\"+name+\"; groupIM = \"+groupIM+\")\");\n\t\t// Create the tab and add to the array.\n\t\tchats[sessionid] = {\n\t\t\ttab: dialog.getTabs().addTab(\"im-\"+sessionid, (groupIM ? \"(hippos)\" : name), \"\", true),\n\t\t\tname: name,\n\t\t\ttarget: id,\n\t\t\tcontent: false,\n\t\t\tentrybox: false,\n\t\t\tsendbtn: false,\n\t\t\tdiv_typing: false,\n\t\t\tsession: sessionid,\n\t\t\tgroupIM: groupIM\n\t\t};\n\t\tif(groupIM)\n\t\t{\n\t\t\tAjaxLife.Debug(\"InstantMessage: Looking up group \"+sessionid+\"...\");\n\t\t\tAjaxLife.NameCache.FindGroup(sessionid, function(groupname) {\n\t\t\t\tAjaxLife.Debug(\"InstantMessage: Found group name: \"+groupname);\n\t\t\t\tchats[sessionid].name = groupname;\n\t\t\t\tchats[sessionid].tab.setText(groupname);\n\t\t\t});\n\t\t}\n\t\tchats[sessionid].tab.on('close',function() {\n\t\t\t// Send message informing that we have left the conversation.\n\t\t\tAjaxLife.Network.Send('GenericInstantMessage', {\n\t\t\t\tMessage: \"\",\n\t\t\t\tTarget: id,\n\t\t\t\tIMSessionID: sessionid,\n\t\t\t\tOnline: AjaxLife.Constants.MainAvatar.InstantMessageOnline.Online,\n\t\t\t\tDialog: AjaxLife.Constants.MainAvatar.InstantMessageDialog.SessionDrop\n\t\t\t});\n\t\t\tif(dialog.getTabs().getActiveTab() && dialog.getTabs().getActiveTab().id == chats[sessionid].tab.id)\n\t\t\t{\n\t\t\t\tactivesession = false;\n\t\t\t}\n\t\t\tdelete chats[sessionid];\n\t\t});\n\t\tchats[sessionid].tab.bodyEl.setStyle({'overflow': 'hidden'});\n\t\t// Chat area\n\t\tvar content = Ext.get(document.createElement('div'));\n\t\tcontent.setStyle({overflow: 'auto', width:'99%'});\n\t\tchats[sessionid].content = content;\n\t\tvar entrybox = Ext.get(document.createElement('input'));\n\t\tentrybox.setHeight(20);\n\t\tchats[sessionid].entrybox = entrybox;\n\t\tchats[sessionid].tab.bodyEl.setStyle({overflow: 'hidden'});\n\t\tchats[sessionid].tab.bodyEl.dom.appendChild(content.dom);\n\t\tchats[sessionid].tab.bodyEl.dom.appendChild(entrybox.dom);\n\t\t// Button setup, callbacks and formatting.\n\t\tvar style = {position: 'absolute', bottom: '0px', right: '0px'};\n\t\tchats[sessionid].sendbtn = new Ext.Button(chats[sessionid].tab.bodyEl, {\n\t\t\thandler: function() {\n\t\t\t\tsendmessage(id, entrybox.dom.value, chats[sessionid].session);\n\t\t\t\tentrybox.dom.value = '';\n\t\t\t\tentrybox.dom.focus();\n\t\t\t},\n\t\t\ttext: _(\"InstantMessage.Send\")\n\t\t});\n\t\tchats[sessionid].sendbtn.getEl().setStyle(style);\n\t\tstyle.right = '48px';\n\t\t// We can't do group profiles yet.\n\t\tif(!groupIM)\n\t\t{\n\t\t\t(new Ext.Button(chats[sessionid].tab.bodyEl, {\n\t\t\t\thandler: function() {\n\t\t\t\t\tnew AjaxLife.Profile(chats[sessionid].target);\n\t\t\t\t},\n\t\t\t\ttext: _(\"InstantMessage.Profile\")\n\t\t\t})).getEl().setStyle(style);\n\t\t}\n\t\tdiv_typing = Ext.get(document.createElement('div'));\n\t\tdiv_typing.addClass(['chatline','agenttyping']);\n\t\tdiv_typing.dom.appendChild(document.createTextNode(_(\"InstantMessage.Typing\",{name: name})));\n\t\tchats[sessionid].div_typing = div_typing;\n\t\t// None of the \"... is typing\" stuff works in group IMs.\n\t\tif(!groupIM)\n\t\t{\n\t\t\t// Called two seconds after the last key is pressed. Sends not typing notification.\n\t\t\tvar delayed_stop_typing = new Ext.util.DelayedTask(function() {\n\t\t\t\tAjaxLife.Network.Send('GenericInstantMessage', {\n\t\t\t\t\tMessage: \"none\",\n\t\t\t\t\tTarget: chats[sessionid].target,\n\t\t\t\t\tIMSessionID: chats[sessionid].session,\n\t\t\t\t\tOnline: AjaxLife.Constants.MainAvatar.InstantMessageOnline.Online,\n\t\t\t\t\tDialog: AjaxLife.Constants.MainAvatar.InstantMessageDialog.StopTyping\n\t\t\t\t});\n\t\t\t\tnoted_typing = false;\n\t\t\t});\n\t\t\t// Sends typing notification and sets timeout for above function to two seconds.\n\t\t\tentrybox.on('keypress',function(e) {\n\t\t\t\tif(!noted_typing)\n\t\t\t\t{\n\t\t\t\t\tnoted_typing = true;\n\t\t\t\t\tAjaxLife.Network.Send('GenericInstantMessage', {\n\t\t\t\t\t\tMessage: \"none\",\n\t\t\t\t\t\tTarget: chats[sessionid].target,\n\t\t\t\t\t\tIMSessionID: chats[sessionid].session,\n\t\t\t\t\t\tOnline: AjaxLife.Constants.MainAvatar.InstantMessageOnline.Online,\n\t\t\t\t\t\tDialog: AjaxLife.Constants.MainAvatar.InstantMessageDialog.StartTyping\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tdelayed_stop_typing.delay(2000);\n\t\t\t});\n\t\t}\n\t\tentrybox.on('keyup',function(e) {\n\t\t\tif(e.keyCode == 13 || e.which == 13)\n\t\t\t{\n\t\t\t\tsendmessage(id, entrybox.dom.value, sessionid);\n\t\t\t\tentrybox.dom.value = '';\n\t\t\t\tentrybox.dom.focus();\n\t\t\t}\n\t\t});\n\t\tchats[sessionid].tab.on('activate',function() {\n\t\t\tunhighlight(sessionid);\n\t\t\tactivesession = sessionid;\n\t\t\tfixtab(sessionid);\n\t\t\tentrybox.dom.focus();\n\t\t});\n\t\tvar currenttab = dialog.getTabs().getActiveTab().id;\n\t\t// These are essentially contentless, so switch IM window if we're activated and on one of these.\n\t\tif(currenttab == 'im-default-tab' || currenttab == 'im-group-tab')\n\t\t{\n\t\t\tchats[sessionid].tab.activate();\n\t\t}\n\t\treturn true;\n\t};\n\t\n\t// Append a line to the box with a timestamp.\n\tfunction appendline(session, text)\n\t{\n\t\tif(chats[session] && chats[session].content)\n\t\t{\n\t\t\ttext = AjaxLife.Utils.LinkURLs(text.escapeHTML());\n\t\t\tvar line = Ext.get(document.createElement('div'));\n\t\t\tline.addClass([\"agentmessage\",\"chatline\"]);\n\t\t\tvar timestamp = Ext.get(document.createElement('span'));\n\t\t\ttimestamp.addClass(\"chattimestamp\");\n\t\t\tvar time = new Date();\n\t\t\ttimestamp.dom.appendChild(document.createTextNode(\"[\"+time.getHours()+\":\"+((time.getMinutes()<10)?(\"0\"+time.getMinutes()):time.getMinutes())+\"]\"));\n\t\t\tline.dom.appendChild(timestamp.dom);\n\t\t\tline.dom.appendChild(document.createTextNode(\" \"));\n\t\t\tvar span = document.createElement('span');\n\t\t\tspan.innerHTML = text;\n\t\t\tline.dom.appendChild(span);\n\t\t\tchats[session].content.dom.appendChild(line.dom);\n\t\t\t// Scroll to the end.\n\t\t\tchats[session].content.dom.scrollTop = chats[session].content.dom.scrollHeight;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tAjaxLife.Widgets.Ext.msg(\"Warning\",\"Instant message with unknown ID {0}:<br />{1}\",session,text);\n\t\t}\n\t};\n\t\n\tfunction joingroupchat(group)\n\t{\t\t\n\t\tAjaxLife.Network.Send(\"GenericInstantMessage\", {\n\t\t\tMessage: \"\",\n\t\t\tTarget: group,\n\t\t\tIMSessionID: group,\n\t\t\tOnline: AjaxLife.Constants.MainAvatar.InstantMessageOnline.Online,\n\t\t\tDialog: AjaxLife.Constants.MainAvatar.InstantMessageDialog.SessionGroupStart\n\t\t});\n\t}\n\t\n\treturn {\n\t\t// Public\n\t\tinit: function () {\n\t\t\t// Create the new window at 700x400, with a default tab for friendlist.\n\t\t\tdialog = new Ext.BasicDialog(\"dlg_im\", {\n\t\t\t\theight: 400,\n\t\t\t\twidth: 700,\n\t\t\t\tminHeight: 100,\n\t\t\t\tminWidth: 150,\n\t\t\t\tmodal: false,\n\t\t\t\tshadow: true,\n\t\t\t\tautoCreate: true,\n\t\t\t\ttitle: _(\"InstantMessage.WindowTitle\"),\n\t\t\t\tproxyDrag: !AjaxLife.Fancy\n\t\t\t});\n\t\t\t\n\t\t\tdialog.getTabs().addTab(\"im-default-tab\",_(\"InstantMessage.OnlineFriends\"),\"\",false).activate();\n\t\t\tfriendlist = new AjaxLife.Widgets.SelectList('im-friend-list',dialog.getTabs().getActiveTab().bodyEl.dom,{\n\t\t\t\twidth: '99%',\n\t\t\t\tcallback: function(key) {\n\t\t\t\t\tAjaxLife.NameCache.Find(key, function(name) {\n\t\t\t\t\t\tcreateTab(key, name, AjaxLife.Utils.UUID.Combine(gAgentID,key));\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t\tvar sortdelay = new Ext.util.DelayedTask(function() {\n\t\t\t\tfriendlist.sort();\n\t\t\t});\n\t\t\t// Deal with adding and removing friends to/from the friend list.\n\t\t\tvar addname = function (friend) {\n\t\t\t\tif(friend.Online)\n\t\t\t\t{\n\t\t\t\t\tfriendlist.add(friend.ID,friend.Name);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfriendlist.remove(friend.ID);\n\t\t\t\t}\n\t\t\t\tsortdelay.delay(200);\n\t\t\t};\n\t\t\tAjaxLife.Friends.AddStatusCallback(addname);\n\t\t\tAjaxLife.Friends.AddNewFriendCallback(addname);\n\t\t\tdialog.body.setStyle({overflow: 'hidden'});\n\t\t\twidth = 700;\n\t\t\theight = 400;\n\t\t\tdialog.on('resize', function(d, w, h) {\n\t\t\t\twidth = w;\n\t\t\t\theight = h;\n\t\t\t\tfixtab(activesession);\n\t\t\t});\n\t\t\t\n\t\t\tvar grouptab = dialog.getTabs().addTab(\"im-group-tab\",_(\"InstantMessage.Groups\"), \"\", false);\n\t\t\t\n\t\t\tgrouplist = new AjaxLife.Widgets.SelectList(\"im-group-list\", grouptab.bodyEl.dom, {\n\t\t\t\twidth: '99%',\n\t\t\t\tcallback: function(key) {\n\t\t\t\t\tjoingroupchat(key);\n\t\t\t\t\tcreateTab(key, key, key, true);\n\t\t\t\t\tchats[key].entrybox.dom.enabled = false;\n\t\t\t\t\tchats[key].sendbtn.getEl().dom.enabled = false;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\t// Handle successfully started chats.\n\t\t\tAjaxLife.Network.MessageQueue.RegisterCallback('ChatGroupJoin', function(data) {\n\t\t\t\tvar group = data.GroupChatSessionID;\n\t\t\t\tif(chats[group] && !chats[group].entrybox.dom.enabled)\n\t\t\t\t{\n\t\t\t\t\tif(data.Success)\n\t\t\t\t\t{\n\t\t\t\t\t\tchats[group].entrybox.dom.enabled = true;\n\t\t\t\t\t\tchats[group].sentbtn.dom.enabled = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tappendline(group, _(\"InstantMessage.SessionCreateFailed\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\t// Handle incoming IMs.\n\t\t\tAjaxLife.Network.MessageQueue.RegisterCallback('InstantMessage',function(data) {\n\t\t\t\t// Ensure it's something to display\n\t\t\t\tif(data.IMSessionID == AjaxLife.Utils.UUID.Zero) return; // Estate messages have null sessions.\n\t\t\t\tif(data.Dialog == AjaxLife.Constants.MainAvatar.InstantMessageDialog.MessageFromAgent || data.Dialog == AjaxLife.Constants.MainAvatar.InstantMessageDialog.SessionSend)\n\t\t\t\t{\n\t\t\t\t\t// Create a tab for them if we haven't already. Also play new IM sound.\n\t\t\t\t\tif(!chats[data.IMSessionID])\n\t\t\t\t\t{\n\t\t\t\t\t\tAjaxLife.Widgets.Ext.msg(\"\",_(\"InstantMessage.NewIMSession\", {from: data.FromAgentName}), \"newimsession\", true);\n\t\t\t\t\t\tif(data.GroupIM) joingroupchat(data.IMSessionID);\n\t\t\t\t\t\tvar created = createTab(data.FromAgentID, data.FromAgentName, data.IMSessionID, data.GroupIM);\n\t\t\t\t\t\tif(!created)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tAjaxLife.Widgets.Ext.msg(\"Lost Instant Message\",\"From: {0}<br />Message: {1}\",data.FromAgentName,data.Message);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!dialog.isVisible())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdialog.show();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSound.play(AjaxLife.STATIC_ROOT+\"sounds/im.wav\");\n\t\t\t\t\t}\n\t\t\t\t\t// Format the incoming message, taking care of /me.\n\t\t\t\t\tvar message = data.Message;\n\t\t\t\t\tif(message.substr(0,3) == \"/me\")\n\t\t\t\t\t{\n\t\t\t\t\t\tmessage = data.FromAgentName+message.substr(3);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tmessage = data.FromAgentName+\": \"+message;\n\t\t\t\t\t}\n\t\t\t\t\t// Assume they stopped typing.\n\t\t\t\t\tif(chats[data.IMSessionID].div_typing.dom.parentNode)\n\t\t\t\t\t{\n\t\t\t\t\t\tchats[data.IMSessionID].div_typing.dom.parentNode.removeChild(chats[data.IMSessionID].div_typing.dom);\n\t\t\t\t\t}\n\t\t\t\t\t// Actually add the line.\n\t\t\t\t\tappendline(data.IMSessionID, message);\n\t\t\t\t\t// If the tab is not active, make it flash.\n\t\t\t\t\tif(dialog.getTabs().getActiveTab().id != 'im-'+data.IMSessionID)\n\t\t\t\t\t{\n\t\t\t\t\t\thighlighttab(data.IMSessionID);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If we have a tab for the sessionid...\n\t\t\t\tif(chats[data.IMSessionID])\n\t\t\t\t{\n\t\t\t\t\t// Show typing note on StartTyping message, remove it on StopTyping.\n\t\t\t\t\tif(data.Dialog == AjaxLife.Constants.MainAvatar.InstantMessageDialog.StartTyping)\n\t\t\t\t\t{\n\t\t\t\t\t\t// If it's already there higher up, remove it from there.\n\t\t\t\t\t\t// This is arguably completely redundant.\n\t\t\t\t\t\tif(chats[data.IMSessionID].div_typing.dom.parentNode)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchats[data.IMSessionID].div_typing.dom.parentNode.removeChild(chats[data.IMSessionID].div_typing.dom);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchats[data.IMSessionID].content.dom.appendChild(chats[data.IMSessionID].div_typing.dom);\n\t\t\t\t\t\t// Scroll down to show it.\n\t\t\t\t\t\tchats[data.IMSessionID].content.dom.scrollTop = chats[data.IMSessionID].content.dom.scrollHeight;\n\t\t\t\t\t}\n\t\t\t\t\telse if(data.Dialog == AjaxLife.Constants.MainAvatar.InstantMessageDialog.StopTyping)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(chats[data.IMSessionID].div_typing && \n\t\t\t\t\t\t\tchats[data.IMSessionID].div_typing.dom.parentNode && \n\t\t\t\t\t\t\ttypeof chats[data.IMSessionID].div_typing.dom.parentNode.removeChild == 'function')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchats[data.IMSessionID].div_typing.dom.parentNode.removeChild(chats[data.IMSessionID].div_typing.dom);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tAjaxLife.Network.MessageQueue.RegisterCallback('CurrentGroups', fillgroups);\n\t\t\tAjaxLife.Network.Send(\"RequestCurrentGroups\",{});\n\t\t\t// Highlighted tabs to flash every half second.\n\t\t\tsetInterval(processhighlight,500);\n\t\t},\n\t\topen: function(opener) {\n\t\t\tif(opener)\n\t\t\t{\n\t\t\t\tdialog.show(opener);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdialog.show();\n\t\t\t}\n\t\t},\n\t\tclose: function() {\n\t\t\tdialog.hide();\n\t\t},\n\t\ttoggle: function(opener) {\n\t\t\tif(!dialog.isVisible())\n\t\t\t{\n\t\t\t\tthis.open(opener);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.close();\n\t\t\t}\n\t\t},\n\t\tstart: function(id) {\n\t\t\tAjaxLife.NameCache.Find(id, function(name) {\n\t\t\t\tcreateTab(id,name,AjaxLife.Utils.UUID.Combine(gAgentID,id));\n\t\t\t});\n\t\t}\n\t};\n}();", "/* Copyright (c) 2007, Katharine Berry\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of Katharine Berry nor the names of any contributors\n *       may be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY KATHARINE BERRY ``AS IS'' AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL KATHARINE BERRY BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n ******************************************************************************/\n\nAjaxLife.SpatialChat = function() {\n\t// Private\n\tvar chat_win = false;\n\tvar div_chat_history = false;\n\tvar box_chat_entry = false;\n\tvar btn_shout = false;\n\tvar btn_say = false;\n\tvar btn_whisper = false;\n\tvar last_channel = 0;\n\tvar anim_started = false;\n\t\n\t// Send a message to the server.\n\t// If the message starts with a \"/\", extra processing takes place first:\n\t// If the message starts \"//\" it's sent on the the last-used channel.\n\t// If the message starts \"/123\" (or other number), the message is sent on that channel.\n\t// The channel number is determined by counting characters forward until we reach something\n\t// not in the numbers array.\n\t// The message will be sent back to us, so we don't have to add it to the log.\n\tfunction sendmessage(type, message)\n\t{\n\t\tvar channel = 0;\n\t\tvar nums = [0,1,2,3,4,5,6,7,8,9];\n\t\tvar indexpos = 0;\n\t\tif(message.substr(0,1) == \"/\")\n\t\t{\n\t\t\tif(message.substr(1,1) == \"/\")\n\t\t\t{\n\t\t\t\tchannel = last_channel;\n\t\t\t\tmessage = message.substr(2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(var i = 1; i < message.length; ++i)\n\t\t\t\t{\n\t\t\t\t\tif(nums.indexOf(message.substr(i,1)) > -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tindexpos = i;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(indexpos > 0)\n\t\t\t\t{\n\t\t\t\t\tchannel = message.substr(1,indexpos);\n\t\t\t\t\tlast_channel = channel;\n\t\t\t\t\tmessage = message.substr(indexpos+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tAjaxLife.Network.Send(\"SpatialChat\", {\n\t\t\tMessage: message,\n\t\t\tChannel: channel,\n\t\t\tType: type\n\t\t});\n\t}\n\t\n\t// Add a line to the chatlog. Formatting is applied based on the sourcetype,\n\t// and a timestamp is calculated in the user's timezone (assuming their computer clock is accurate)\n\tfunction add(text, sourcetype)\n\t{\n\t\ttext = AjaxLife.Utils.LinkURLs(text.escapeHTML());\n\t\t// Make a div to put this in.\n\t\tvar line = Ext.get(document.createElement('div'));\n\t\tline.addClass(\"chatline\");\n\t\t// Give the line the appropriate class for the type of message it is.\n\t\tif(sourcetype == AjaxLife.Constants.MainAvatar.ChatSourceType.System)\n\t\t{\n\t\t\tline.addClass(\"systemmessage\");\n\t\t}\n\t\telse if(sourcetype == AjaxLife.Constants.MainAvatar.ChatSourceType.Agent)\n\t\t{\n\t\t\tline.addClass(\"agentmessage\");\n\t\t}\n\t\telse if(sourcetype == AjaxLife.Constants.MainAvatar.ChatSourceType.Object)\n\t\t{\n\t\t\tline.addClass(\"objectmessage\");\n\t\t}\n\t\tvar timestamp = Ext.get(document.createElement('span'));\n\t\t// Make a timestamp in the user's timezone\n\t\ttimestamp.addClass(\"chattimestamp\");\n\t\tvar time = new Date();\n\t\t// Build the timestamp into an actual string and put it into an HTML node.\n\t\ttimestamp.dom.appendChild(document.createTextNode(\"[\" + time.getHours() + \":\" + ((time.getMinutes() < 10) ? (\"0\" + time.getMinutes()) : time.getMinutes()) + \"]\"));\n\t\t// Put the timestamp at the beginning of the line.\n\t\tline.dom.appendChild(timestamp.dom);\n\t\t// Add the actual text.\n\t\tline.dom.appendChild(document.createTextNode(\" \"));\n\t\tvar span = document.createElement('span');\n\t\tspan.innerHTML = text;\n\t\tline.dom.appendChild(span);\n\t\t// Add the line to the chat log.\n\t\tdiv_chat_history.dom.appendChild(line.dom);\n\t\t// Scroll the chatlog down to the new entry.\n\t\tdiv_chat_history.dom.scrollTop = div_chat_history.dom.scrollHeight;\n\t}\n\t\n\t// Some incoming chat. This is essentially a wrapper around addline, with some\n\t// processing to deal with formatting it in the first person, use of \"/me\"\n\t// (which requres removal of the colon), and to add the appropriate verb to the line\n\t// (i.e. if they're shouting or whispering)\n\tfunction incomingline (name, message, sourcetype, type)\n\t{\n\t\t// Ignore blank lines.\n\t\tif(message.blank())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t// Only do this processing if it's not a system message.\n\t\tif(sourcetype != AjaxLife.Constants.MainAvatar.ChatSourceType.System)\n\t\t{\n\t\t\t// If it's a /me, strip the \"/me\" and combine the name and message.\n\t\t\tif(message.substr(0,3) == \"/me\")\n\t\t\t{\n\t\t\t\tmessage = name+message.substr(3);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar you = false;\n\t\t\t\t// If we said it.\n\t\t\t\tif(name == gUserName)\n\t\t\t\t{\n\t\t\t\t\tname = _(\"SpatialChat.You\");\n\t\t\t\t\tyou = true;\n\t\t\t\t}\n\t\t\t\t// Say it was shouted if it was shouted.\n\t\t\t\tif(type == AjaxLife.Constants.MainAvatar.ChatType.Shout)\n\t\t\t\t{\n\t\t\t\t\tmessage = name+(you?_(\"SpatialChat.SecondPersonShout\"):_(\"SpatialChat.ThirdPersonShout\"))+\" \"+message;\n\t\t\t\t}\n\t\t\t\t// Say it was whispered if it was whispered.\n\t\t\t\telse if(type == AjaxLife.Constants.MainAvatar.ChatType.Whisper)\n\t\t\t\t{\n\t\t\t\t\tmessage = name+(you?_(\"SpatialChat.SecondPersonWhisper\"):_(\"SpatialChat.ThirdPersonWhisper\"))+\" \"+message;\n\t\t\t\t}\n\t\t\t\t// Otherwise just use a colon.\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmessage = name+(you?_(\"SpatialChat.SecondPersonSay\"):_(\"SpatialChat.ThirdPersonSay\"))+\" \"+message;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Add it do the display.\n\t\tadd(message, sourcetype);\n\t}\n\t\n\treturn {\n\t\t// Public\n\t\tinit: function() {\n\t\t\t// Build the window and UI\n\t\t\tchat_win = new Ext.BasicDialog(\"dlg_chat\",{\n\t\t\t\twidth: 500,\n\t\t\t\theight: 300,\n\t\t\t\tmodal: false,\n\t\t\t\tshadow: true,\n\t\t\t\tautoCreate: true,\n\t\t\t\ttitle: _(\"SpatialChat.WindowTitle\"),\n\t\t\t\tproxyDrag: !AjaxLife.Fancy\n\t\t\t});\n\t\t\tchat_win.body.setStyle({overflow: 'hidden'});\n\t\t\tdiv_chat_history = Ext.get(document.createElement('div'));\n\t\t\tdiv_chat_history.setStyle({height: '241px', width: '99%', overflow: 'auto'});\n\t\t\tbox_chat_entry = Ext.get(document.createElement('input'));\n\t\t\tbox_chat_entry.dom.setAttribute('type','text');\n\t\t\tbox_chat_entry.setStyle({width: '310px', height: '15px', 'float': 'left'});\n\t\t\t// Resize the chatlog and input line when the window is resized.\n\t\t\tchat_win.on('resize',function(win, width, height) {\n\t\t\t\tdiv_chat_history.setStyle({height: (height-59)+'px'});\n\t\t\t\tbox_chat_entry.setStyle({width: (width-190)+'px'});\n\t\t\t\tdiv_chat_history.dom.scrollTop = div_chat_history.dom.scrollHeight;\n\t\t\t});\n\t\t\t\n\t\t\tchat_win.body.dom.appendChild(div_chat_history.dom);\n\t\t\tchat_win.body.dom.appendChild(box_chat_entry.dom);\n\t\t\t// All of these buttons do exactly the same thing, but use a differing ChatType.\n\t\t\t// They clear the input box, focus it, and send the message. Not in that order.\n\t\t\tbtn_say = new Ext.Button(chat_win.body, {\n\t\t\t\thandler: function() {\n\t\t\t\t\tsendmessage(AjaxLife.Constants.MainAvatar.ChatType.Normal,box_chat_entry.dom.value);\n\t\t\t\t\tbox_chat_entry.dom.value = '';\n\t\t\t\t\tbox_chat_entry.dom.focus();\n\t\t\t\t},\n\t\t\t\ttext: _(\"SpatialChat.Say\"),\n\t\t\t\theight: '12px'\n\t\t\t});\n\t\t\tbtn_say.getEl().setStyle({position: 'absolute', right: '125px', bottom: '2px'});\n\t\t\tbtn_whisper = new Ext.Button(chat_win.body, {\n\t\t\t\thandler: function() {\n\t\t\t\t\tsendmessage(AjaxLife.Constants.MainAvatar.ChatType.Whisper,box_chat_entry.dom.value);\n\t\t\t\t\tbox_chat_entry.dom.value = '';\n\t\t\t\t\tbox_chat_entry.dom.focus();\n\t\t\t\t},\n\t\t\t\ttext: _(\"SpatialChat.Whisper\"),\n\t\t\t\theight: '12px'\n\t\t\t});\n\t\t\tbtn_whisper.getEl().setStyle({position: 'absolute', right: '59px', bottom: '2px'});\n\t\t\tbtn_shout = new Ext.Button(chat_win.body, {\n\t\t\t\thandler: function() {\n\t\t\t\t\tsendmessage(AjaxLife.Constants.MainAvatar.ChatType.Shout,box_chat_entry.dom.value);\n\t\t\t\t\tbox_chat_entry.dom.value = '';\n\t\t\t\t\tbox_chat_entry.dom.focus();\n\t\t\t\t},\n\t\t\t\ttext: _(\"SpatialChat.Shout\"),\n\t\t\t\theight: '12px'\n\t\t\t});\n\t\t\tbtn_shout.getEl().setStyle({position: 'absolute', right: '5px', bottom: '2px'});\n\t\t\t// This captures keys pressed in the chatbox. If the key was the return key,\n\t\t\t// we send the message and stop the typing animation. The remainder is handled by\n\t\t\t// the keypress event later on, as that accounts for holding keys down. This isn't there\n\t\t\t// because we don't want the message to be sent repeatedly.\n\t\t\tbox_chat_entry.addListener('keyup', function(event) {\n\t\t\t\tif(event.keyCode == 13 || event.which == 13)\n\t\t\t\t{\n\t\t\t\t\tif(box_chat_entry.dom.value != '')\n\t\t\t\t\t{\n\t\t\t\t\t\tAjaxLife.Network.Send(\"StopAnimation\", {\n\t\t\t\t\t\t\tAnimation: AjaxLife.Constants.Animations.avatar_type\n\t\t\t\t\t\t});\n\t\t\t\t\t\tAjaxLife.Network.Send(\"SpatialChat\", {\n\t\t\t\t\t\t\tMessage: \"a\",\n\t\t\t\t\t\t\tChannel: 0,\n\t\t\t\t\t\t\tType: AjaxLife.Constants.MainAvatar.ChatType.StopTyping\n\t\t\t\t\t\t});\n\t\t\t\t\t\tanim_started = false;\n\t\t\t\t\t\tsendmessage(AjaxLife.Constants.MainAvatar.ChatType.Normal,box_chat_entry.dom.value);\n\t\t\t\t\t\tbox_chat_entry.dom.value = '';\n\t\t\t\t\t\tbox_chat_entry.dom.focus();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\t// This is set by the keypress event in the chatbox. It stops the typing animation\n\t\t\t// and sends the StopTyping message.\n\t\t\tvar chat_stop_task = new Ext.util.DelayedTask(function() {\n\t\t\t\t//AjaxLife.Network.Send(\"StopAnimation\", {\n\t\t\t\t// FIXME: Code duplication is bad. (See 17 lines up)\n\t\t\t\tAjaxLife.Network.Send(\"StopAnimation\", {\n\t\t\t\t\tAnimation: AjaxLife.Constants.Animations.avatar_type\n\t\t\t\t});\n\t\t\t\tAjaxLife.Network.Send(\"SpatialChat\", {\n\t\t\t\t\tMessage: \"a\",\n\t\t\t\t\tChannel: 0,\n\t\t\t\t\tType: AjaxLife.Constants.MainAvatar.ChatType.StopTyping\n\t\t\t\t});\n\t\t\t\tanim_started = false;\n\t\t\t});\n\t\t\t// If the first character of the text is not \"/\", this sends the StartTyping\n\t\t\t// message and starts the typing animation, if this hasn't already been done.\n\t\t\t// After two seconds of not typing, the chat_stop_task function will be fired.\n\t\t\tbox_chat_entry.addListener('keypress', function(event) {\n\t\t\t\tif(!anim_started && box_chat_entry.dom.value.substr(0,1) != '/')\n\t\t\t\t{\n\t\t\t\t\tanim_started = true;\n\t\t\t\t\tAjaxLife.Network.Send(\"StartAnimation\", {\n\t\t\t\t\t\tAnimation: AjaxLife.Constants.Animations.avatar_type\n\t\t\t\t\t});\n\t\t\t\t\tAjaxLife.Network.Send(\"SpatialChat\", {\n\t\t\t\t\t\tMessage: \"a\",\n\t\t\t\t\t\tChannel: 0,\n\t\t\t\t\t\tType: AjaxLife.Constants.MainAvatar.ChatType.StartTyping\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tchat_stop_task.delay(2000);\n\t\t\t});\n\t\t\t\n\t\t\t//chat_win.on('open', function() {\n\t\t\t//\tbox_chat_entry.dom.focus();\t\t\t\t\t\t \n\t\t\t//});\n\t\t\t\n\t\t\t// Friend notifications.\n\t\t\t// This just adds an online/offline note to the chatlog when friends log on or off.\n\t\t\tAjaxLife.Friends.AddStatusCallback(function(friend) {\n\t\t\t\tadd(_(\"Friends.OnlineNotification\",{name: friend.Name, status: (friend.Online?_(\"Friends.Online\"):_(\"Friends.Offline\"))}),AjaxLife.Constants.MainAvatar.ChatSourceType.System);\n\t\t\t});\n\t\t\t\n\t\t\t// Incoming chat.\n\t\t\t// This deals with incoming chat. If it's audible, and is a type of standard chat,\n\t\t\t// it is proceesed by the incomingline function. Otherwise we ignore it.\n\t\t\t// (To avoid printing messages whenever people type or annoying things like that)\n\t\t\tAjaxLife.Network.MessageQueue.RegisterCallback('SpatialChat', function(data) {\n\t\t\t\tif(data.Audible > -1)\n\t\t\t\t{\n\t\t\t\t\t// Check that it is actually a displayable chat message.\n\t\t\t\t\tif(data.Type == AjaxLife.Constants.MainAvatar.ChatType.Whisper\t|| \n\t\t\t\t\t\tdata.Type == AjaxLife.Constants.MainAvatar.ChatType.Shout\t||\n\t\t\t\t\t\tdata.Type == AjaxLife.Constants.MainAvatar.ChatType.Normal\t||\n\t\t\t\t\t\tdata.Type == AjaxLife.Constants.MainAvatar.ChatType.OwnerSay)\n\t\t\t\t\t{\n\t\t\t\t\t\tincomingline(data.FromName, data.Message,data.SourceType, data.Type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\t// We subscribe to the InstantMessage event in order to take account of objects\n\t\t\t// using the llInstantMessage function. We simply handle this as normal object chat.\n\t\t\tAjaxLife.Network.MessageQueue.RegisterCallback('InstantMessage', function(data) {\n\t\t\t\t// Only do anything if this message comes from an object.\n\t\t\t\tif(data.Dialog == AjaxLife.Constants.MainAvatar.InstantMessageDialog.MessageFromObject)\n\t\t\t\t{\n\t\t\t\t\tincomingline(data.FromAgentName, data.Message, AjaxLife.Constants.MainAvatar.ChatSourceType.Object, AjaxLife.Constants.MainAvatar.ChatType.Normal);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t\n\t\t// Manually add a line to the chatlog\n\t\taddline: function(name, message, sourcetype, type) {\n\t\t\tincomingline(name, message, sourcetype, type);\n\t\t},\n\t\t// Add a system message to the chatlog.\n\t\tsystemmessage: function(message) {\n\t\t\tadd(message,AjaxLife.Constants.MainAvatar.ChatSourceType.System);\n\t\t},\n\t\topen: function(opener) {\n\t\t\tif(opener)\n\t\t\t{\n\t\t\t\tchat_win.show(opener);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchat_win.show();\n\t\t\t}\n\t\t},\n\t\tclose: function() {\n\t\t\tchat_win.hide();\n\t\t},\n\t\ttoggle: function(opener) {\n\t\t\tif(!chat_win.isVisible())\n\t\t\t{\n\t\t\t\tif(opener)\n\t\t\t\t{\n\t\t\t\t\tchat_win.show(opener);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tchat_win.show();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchat_win.hide();\n\t\t\t}\n\t\t}\n\t};\n}();"], "filenames": ["client/AjaxLife.InstantMessage.js", "client/AjaxLife.SpatialChat.js"], "buggy_code_start_loc": [287, 89], "buggy_code_end_loc": [288, 90], "fixing_code_start_loc": [287, 89], "fixing_code_end_loc": [288, 90], "type": "CWE-79", "message": "A vulnerability has been found in cfire24 ajaxlife up to 0.3.2 and classified as problematic. This vulnerability affects unknown code. The manipulation leads to cross site scripting. The attack can be initiated remotely. Upgrading to version 0.3.3 is able to address this issue. The name of the patch is 9fb53b67312fe3f4336e01c1e3e1bedb4be0c1c8. It is recommended to upgrade the affected component. VDB-222286 is the identifier assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2008-10002", "sourceIdentifier": "cna@vuldb.com", "published": "2023-03-05T02:15:58.877", "lastModified": "2023-03-09T20:42:24.367", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability has been found in cfire24 ajaxlife up to 0.3.2 and classified as problematic. This vulnerability affects unknown code. The manipulation leads to cross site scripting. The attack can be initiated remotely. Upgrading to version 0.3.3 is able to address this issue. The name of the patch is 9fb53b67312fe3f4336e01c1e3e1bedb4be0c1c8. It is recommended to upgrade the affected component. VDB-222286 is the identifier assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ajaxlife_project:ajaxlife:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.3.2", "matchCriteriaId": "203D6B15-7434-4CD0-884E-B1E88DD3DB85"}]}]}], "references": [{"url": "https://github.com/cfire24/ajaxlife/commit/9fb53b67312fe3f4336e01c1e3e1bedb4be0c1c8", "source": "cna@vuldb.com", "tags": ["Patch"]}, {"url": "https://github.com/cfire24/ajaxlife/releases/tag/0.3.3", "source": "cna@vuldb.com", "tags": ["Release Notes"]}, {"url": "https://vuldb.com/?ctiid.222286", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory", "VDB Entry"]}, {"url": "https://vuldb.com/?id.222286", "source": "cna@vuldb.com", "tags": ["Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/cfire24/ajaxlife/commit/9fb53b67312fe3f4336e01c1e3e1bedb4be0c1c8"}}