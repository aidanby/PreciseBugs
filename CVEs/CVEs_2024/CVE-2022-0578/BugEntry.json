{"buggy_code": ["# frozen_string_literal: true\n\nrequire \"aasm\"\nrequire \"akismet\"\n\nclass Feedback < ApplicationRecord\n  self.table_name = \"feedback\"\n\n  belongs_to :article, touch: true\n\n  include PublifyGuid\n  include ContentBase\n\n  validate :article_allows_this_feedback, on: :create\n  validate :feedback_not_closed, on: :create\n  validates :article, presence: true\n\n  before_save :correct_url, :classify_content\n  before_create :create_guid\n\n  # TODO: Rename so it doesn't sound like only approved ham\n  scope :ham, -> { where(state: %w(presumed_ham ham)) }\n\n  scope :spam, -> { where(state: \"spam\") }\n  scope :created_since, ->(time) { ham.where(\"created_at > ?\", time) }\n  scope :presumed_ham, -> { where(state: \"presumed_ham\") }\n  scope :presumed_spam, -> { where(state: \"presumed_spam\") }\n  scope :unapproved, -> { where(state: [\"presumed_spam\", \"presumed_ham\"]) }\n\n  scope :published, -> { ham }\n  scope :oldest_first, -> { order(:created_at) }\n  scope :newest_first, -> { order(created_at: :desc) }\n\n  include AASM\n\n  aasm column: :state do\n    state :unclassified, initial: true\n    state :presumed_ham\n    state :presumed_spam\n    state :spam, after_enter: [:send_notifications, :report_as_spam]\n    state :ham, after_enter: [:send_notifications, :report_as_ham]\n\n    event :presume_ham do\n      transitions from: :unclassified, to: :ham, if: ->() { user_id.present? }\n      transitions from: :unclassified, to: :presumed_ham\n    end\n\n    event :presume_spam do\n      transitions from: :unclassified, to: :presumed_spam\n    end\n\n    event :mark_as_ham do\n      transitions to: :ham\n    end\n\n    event :mark_as_spam do\n      transitions to: :spam\n    end\n\n    event :withdraw do\n      transitions from: [:presumed_ham, :ham], to: :spam\n    end\n  end\n\n  # FIXME: Inline this method\n  def self.paginated(page, per_page)\n    page(page).per(per_page)\n  end\n\n  def parent\n    article\n  end\n\n  def classify_content\n    return unless unclassified?\n\n    case classify\n    when :ham then presume_ham\n    else presume_spam\n    end\n  end\n\n  def permalink_url(_anchor = :ignored, only_path = false)\n    article.permalink_url(\"#{self.class.to_s.downcase}-#{id}\", only_path)\n  end\n\n  def html_postprocess(_field, html)\n    helper = ContentTextHelpers.new\n    helper.sanitize(helper.auto_link(html))\n  end\n\n  def correct_url\n    return if url.blank?\n\n    self.url = \"http://#{url}\" unless %r{^https?://}.match?(url)\n  end\n\n  def article_allows_this_feedback\n    article && blog_allows_feedback? && article_allows_feedback?\n  end\n\n  def akismet_options\n    { type: self.class.to_s.downcase,\n      author: originator,\n      author_email: email,\n      author_url: url,\n      text: body }\n  end\n\n  def spam_fields\n    [:title, :body, :ip, :url]\n  end\n\n  def classify\n    return :ham if user_id\n    return :spam if blog.default_moderate_comments\n    return :ham unless blog.sp_global\n\n    # Yeah, three state logic is evil...\n    case sp_is_spam? || akismet_is_spam?\n    when nil then :spam\n    when true then :spam\n    when false then :ham\n    end\n  end\n\n  def sp_is_spam?(_options = {})\n    sp = SpamProtection.new(blog)\n    Timeout.timeout(30) do\n      spam_fields.any? do |field|\n        sp.is_spam?(send(field))\n      end\n    end\n  rescue Timeout::Error\n    nil\n  end\n\n  def akismet_is_spam?(_options = {})\n    return false if akismet.nil?\n\n    begin\n      Timeout.timeout(60) do\n        akismet.comment_check(ip, user_agent, akismet_options)\n      end\n    rescue Timeout::Error\n      nil\n    end\n  end\n\n  def change_state!\n    result = \"\"\n    if spam? || presumed_spam?\n      mark_as_ham!\n      result = \"ham\"\n    else\n      mark_as_spam!\n      result = \"spam\"\n    end\n    result\n  end\n\n  def confirm_classification!\n    confirm_classification\n    save!\n  end\n\n  def confirm_classification\n    if presumed_spam?\n      mark_as_spam\n    elsif presumed_ham?\n      mark_as_ham\n    end\n  end\n\n  def report_as_spam\n    return if akismet.nil?\n\n    begin\n      Timeout.timeout(5) do\n        akismet.submit_spam(ip, user_agent, akismet_options)\n      end\n    rescue Timeout::Error\n      nil\n    end\n  end\n\n  def report_as_ham\n    return if akismet.nil?\n\n    begin\n      Timeout.timeout(5) do\n        akismet.ham(ip, user_agent, akismet_options)\n      end\n    rescue Timeout::Error\n      nil\n    end\n  end\n\n  def feedback_not_closed\n    check_article_closed_for_feedback\n  end\n\n  def send_notifications\n    nil\n  end\n\n  def published?\n    ham? || presumed_ham?\n  end\n\n  def status_confirmed?\n    ham? || spam?\n  end\n\n  def spammy?\n    spam? || presumed_spam?\n  end\n\n  delegate :blog, to: :article\n\n  private\n\n  def akismet\n    @akismet ||= akismet_client\n  end\n\n  def akismet_client\n    return nil if blog.sp_akismet_key.blank?\n\n    client = Akismet::Client.new(blog.sp_akismet_key, blog.base_url)\n    begin\n      client.verify_key ? client : nil\n    rescue SocketError\n      nil\n    end\n  end\n\n  def blog_id\n    article.blog_id if article.present?\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\nrequire \"publify_core/testing_support/dns_mock\"\n\ndescribe Comment, type: :model do\n  let(:blog) { build_stubbed :blog }\n\n  let(:published_article) { build_stubbed(:article, published_at: 1.hour.ago, blog: blog) }\n\n  def valid_comment(options = {})\n    Comment.new({ author: \"Bob\", article: published_article, body: \"nice post\",\n                  ip: \"1.2.3.4\" }.merge(options))\n  end\n\n  describe \"#permalink_url\" do\n    let(:comment) { build_stubbed(:comment) }\n\n    it \"renders permalink to comment in public part\" do\n      expect(comment.permalink_url).\n        to eq(\"#{comment.article.permalink_url}#comment-#{comment.id}\")\n    end\n  end\n\n  describe \"#save\" do\n    it \"saves good comment\" do\n      c = build(:comment, url: \"http://www.google.de\")\n      assert c.save\n      assert_equal \"http://www.google.de\", c.url\n    end\n\n    it \"saves spam comment\" do\n      c = build(:comment, body: 'test <a href=\"http://fakeurl.com\">body</a>')\n      assert c.save\n      assert_equal \"http://fakeurl.com\", c.url\n    end\n\n    it \"does not save when article comment window is closed\" do\n      article = build :article, published_at: 1.year.ago\n      article.blog.sp_article_auto_close = 30\n      comment = build(:comment, author: \"Old Spammer\", body: \"Old trackback body\",\n                                article: article)\n      expect(comment.save).to be_falsey\n      expect(comment.errors[:article]).not_to be_empty\n    end\n\n    it \"changes old comment\" do\n      c = build(:comment, body: \"Comment body <em>italic</em> <strong>bold</strong>\")\n      assert c.save\n      assert c.errors.empty?\n    end\n\n    it \"saves a valid comment\" do\n      c = build :comment\n      expect(c.save).to be_truthy\n      expect(c.errors).to be_empty\n    end\n\n    it \"does not save with article not allow comment\" do\n      c = build(:comment, article: build_stubbed(:article, allow_comments: false))\n      expect(c.save).not_to be_truthy\n      expect(c.errors).not_to be_empty\n    end\n\n    it \"generates guid\" do\n      c = build :comment, guid: nil\n      assert c.save\n      assert c.guid.size > 15\n    end\n\n    it \"preserves urls starting with https://\" do\n      c = build :comment, url: \"https://example.com/\"\n      c.save\n      expect(c.url).to eq(\"https://example.com/\")\n    end\n\n    it \"preserves urls starting with http://\" do\n      c = build :comment, url: \"http://example.com/\"\n      c.save\n      expect(c.url).to eq(\"http://example.com/\")\n    end\n\n    it \"prepends http:// to urls without protocol\" do\n      c = build :comment, url: \"example.com\"\n      c.save\n      expect(c.url).to eq(\"http://example.com\")\n    end\n  end\n\n  describe \"#classify_content\" do\n    it \"rejects spam rbl\" do\n      comment = valid_comment(\n        author: \"Spammer\",\n        body: <<-BODY,\n          This is just some random text.\n          &lt;a href=\"http://chinaaircatering.com\"&gt;without any senses.&lt;/a&gt;.\n          Please disregard.\n        BODY\n        url: \"http://buy-computer.us\")\n      comment.classify_content\n      expect(comment).to be_spammy\n      expect(comment).not_to be_status_confirmed\n    end\n\n    it \"does not define spam a comment rbl with lookup succeeds\" do\n      comment = valid_comment(author: \"Not a Spammer\", body: \"Useful commentary!\",\n                              url: \"http://www.bofh.org.uk\")\n      comment.classify_content\n      expect(comment).not_to be_spammy\n      expect(comment).not_to be_status_confirmed\n    end\n\n    it \"rejects spam with uri limit\" do\n      comment =\n        valid_comment(author: \"Yet Another Spammer\",\n                      body: <<~HTML,\n                        <a href=\"http://www.one.com/\">one</a>\n                        <a href=\"http://www.two.com/\">two</a>\n                        <a href=\"http://www.three.com/\">three</a>\n                        <a href=\"http://www.four.com/\">four</a>\n                      HTML\n                      url: \"http://www.uri-limit.com\")\n      comment.classify_content\n      expect(comment).to be_spammy\n      expect(comment).not_to be_status_confirmed\n    end\n\n    describe \"with feedback moderation enabled\" do\n      before do\n        allow(blog).to receive(:sp_global).and_return(false)\n        allow(blog).to receive(:default_moderate_comments).and_return(true)\n      end\n\n      it \"marks comment as presumably spam\" do\n        comment = described_class.new do |c|\n          c.body = \"Test foo\"\n          c.author = \"Bob\"\n          c.article = build_stubbed(:article, blog: blog)\n        end\n\n        comment.classify_content\n\n        assert !comment.published?\n        assert comment.presumed_spam?\n        assert !comment.status_confirmed?\n      end\n\n      it \"marks comment from known user as confirmed ham\" do\n        comment = described_class.new do |c|\n          c.body = \"Test foo\"\n          c.author = \"Henri\"\n          c.article = build_stubbed(:article, blog: blog)\n          c.user = build_stubbed(:user)\n        end\n\n        comment.classify_content\n\n        assert comment.published?\n        assert comment.ham?\n        assert comment.status_confirmed?\n      end\n    end\n  end\n\n  it \"has good relation\" do\n    article = build_stubbed(:article)\n    comment = build_stubbed(:comment, article: article)\n    assert comment.article\n    assert_equal article, comment.article\n  end\n\n  describe \"change state\" do\n    it \"becomes unpublished if withdrawn\" do\n      c = build :comment\n      assert c.published?\n      assert c.withdraw!\n      assert !c.published?\n      assert c.spam?\n      assert c.status_confirmed?\n    end\n\n    it \"becomeses confirmed if withdrawn\" do\n      unconfirmed = build(:comment, state: \"presumed_ham\")\n      expect(unconfirmed).not_to be_status_confirmed\n      unconfirmed.withdraw!\n      expect(unconfirmed).to be_status_confirmed\n    end\n  end\n\n  it \"has good default filter\" do\n    create :blog, text_filter: \"textile\", comment_text_filter: \"markdown\"\n    a = create(:comment)\n    assert_equal \"markdown\", a.default_text_filter.name\n  end\n\n  describe \"spam\", integration: true do\n    let!(:comment) { create(:comment, state: \"spam\") }\n    let!(:ham_comment) { create(:comment, state: \"ham\") }\n\n    it \"returns only spam comment\" do\n      expect(described_class.spam).to eq([comment])\n    end\n  end\n\n  describe \"not_spam\", integration: true do\n    let!(:comment) { create(:comment, state: \"spam\") }\n    let!(:ham_comment) { create(:comment, state: \"ham\") }\n    let!(:presumed_spam_comment) { create(:comment, state: \"presumed_spam\") }\n\n    it \"returns all comment that not_spam\" do\n      expect(described_class.not_spam).to match_array [ham_comment, presumed_spam_comment]\n    end\n  end\n\n  describe \"presumed_spam\", integration: true do\n    let!(:comment) { create(:comment, state: \"spam\") }\n    let!(:ham_comment) { create(:comment, state: \"ham\") }\n    let!(:presumed_spam_comment) { create(:comment, state: \"presumed_spam\") }\n\n    it \"returns only presumed_spam\" do\n      expect(described_class.presumed_spam).to eq([presumed_spam_comment])\n    end\n  end\n\n  describe \"last_published\", integration: true do\n    let(:date) { DateTime.new(2012, 12, 23, 12, 47).in_time_zone }\n    let!(:comment_1) { create(:comment, body: \"1\", created_at: date + 1.day) }\n    let!(:comment_4) { create(:comment, body: \"4\", created_at: date + 4.days) }\n    let!(:comment_2) { create(:comment, body: \"2\", created_at: date + 2.days) }\n    let!(:comment_6) { create(:comment, body: \"6\", created_at: date + 6.days) }\n    let!(:comment_3) { create(:comment, body: \"3\", created_at: date + 3.days) }\n    let!(:comment_5) { create(:comment, body: \"5\", created_at: date + 5.days) }\n\n    it \"respond only 5 last_published\" do\n      expect(described_class.last_published).to eq([comment_6, comment_5, comment_4,\n                                                    comment_3, comment_2])\n    end\n  end\n\n  describe \"#html\" do\n    it \"renders email addresses in the body\" do\n      comment = build_stubbed(:comment, body: \"foo@example.com\")\n      expect(comment.html).to match(/mailto:/)\n    end\n\n    it \"returns an html_safe string\" do\n      comment = build_stubbed(:comment, body: \"Just a comment\")\n      expect(comment.html).to be_html_safe\n    end\n\n    context \"with an attempted xss body\" do\n      let(:comment) do\n        described_class.new do |c|\n          c.body = \"Test foo <script>do_evil();</script>\"\n          c.author = \"Bob\"\n          c.article = build_stubbed(:article, blog: blog)\n        end\n      end\n\n      [\"\", \"textile\", \"markdown\", \"smartypants\", \"markdown smartypants\"].each do |filter|\n        it \"rejects with filter '#{filter}'\" do\n          blog.comment_text_filter = filter\n\n          ActiveSupport::Deprecation.silence do\n            assert comment.html(:body) !~ /<script>/\n          end\n        end\n      end\n    end\n\n    context \"with a markdown comment with italic and bold\" do\n      let(:comment) { build(:comment, body: \"Comment body _italic_ **bold**\") }\n      let(:blog) { comment.article.blog }\n\n      it \"converts the comment markup to html\" do\n        blog.comment_text_filter = \"markdown\"\n        result = comment.html\n\n        aggregate_failures do\n          expect(result).to match(%r{<em>italic</em>})\n          expect(result).to match(%r{<strong>bold</strong>})\n        end\n      end\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nrequire \"aasm\"\nrequire \"akismet\"\n\nclass Feedback < ApplicationRecord\n  self.table_name = \"feedback\"\n\n  belongs_to :article, touch: true\n\n  include PublifyGuid\n  include ContentBase\n\n  validate :article_allows_this_feedback, on: :create\n  validate :feedback_not_closed, on: :create\n  validates :article, presence: true\n\n  before_save :correct_url, :classify_content\n  before_create :create_guid\n\n  # TODO: Rename so it doesn't sound like only approved ham\n  scope :ham, -> { where(state: %w(presumed_ham ham)) }\n\n  scope :spam, -> { where(state: \"spam\") }\n  scope :created_since, ->(time) { ham.where(\"created_at > ?\", time) }\n  scope :presumed_ham, -> { where(state: \"presumed_ham\") }\n  scope :presumed_spam, -> { where(state: \"presumed_spam\") }\n  scope :unapproved, -> { where(state: [\"presumed_spam\", \"presumed_ham\"]) }\n\n  scope :published, -> { ham }\n  scope :oldest_first, -> { order(:created_at) }\n  scope :newest_first, -> { order(created_at: :desc) }\n\n  include AASM\n\n  aasm column: :state do\n    state :unclassified, initial: true\n    state :presumed_ham\n    state :presumed_spam\n    state :spam, after_enter: [:send_notifications, :report_as_spam]\n    state :ham, after_enter: [:send_notifications, :report_as_ham]\n\n    event :presume_ham do\n      transitions from: :unclassified, to: :ham, if: ->() { user_id.present? }\n      transitions from: :unclassified, to: :presumed_ham\n    end\n\n    event :presume_spam do\n      transitions from: :unclassified, to: :presumed_spam\n    end\n\n    event :mark_as_ham do\n      transitions to: :ham\n    end\n\n    event :mark_as_spam do\n      transitions to: :spam\n    end\n\n    event :withdraw do\n      transitions from: [:presumed_ham, :ham], to: :spam\n    end\n  end\n\n  # FIXME: Inline this method\n  def self.paginated(page, per_page)\n    page(page).per(per_page)\n  end\n\n  def self.allowed_tags\n    @allowed_tags ||= Rails::Html::SafeListSanitizer.allowed_tags - [\"img\"]\n  end\n\n  def parent\n    article\n  end\n\n  def classify_content\n    return unless unclassified?\n\n    case classify\n    when :ham then presume_ham\n    else presume_spam\n    end\n  end\n\n  def permalink_url(_anchor = :ignored, only_path = false)\n    article.permalink_url(\"#{self.class.to_s.downcase}-#{id}\", only_path)\n  end\n\n  def html_postprocess(_field, html)\n    helper = ContentTextHelpers.new\n    helper.sanitize(helper.auto_link(html), tags: self.class.allowed_tags)\n  end\n\n  def correct_url\n    return if url.blank?\n\n    self.url = \"http://#{url}\" unless %r{^https?://}.match?(url)\n  end\n\n  def article_allows_this_feedback\n    article && blog_allows_feedback? && article_allows_feedback?\n  end\n\n  def akismet_options\n    { type: self.class.to_s.downcase,\n      author: originator,\n      author_email: email,\n      author_url: url,\n      text: body }\n  end\n\n  def spam_fields\n    [:title, :body, :ip, :url]\n  end\n\n  def classify\n    return :ham if user_id\n    return :spam if blog.default_moderate_comments\n    return :ham unless blog.sp_global\n\n    # Yeah, three state logic is evil...\n    case sp_is_spam? || akismet_is_spam?\n    when nil then :spam\n    when true then :spam\n    when false then :ham\n    end\n  end\n\n  def sp_is_spam?(_options = {})\n    sp = SpamProtection.new(blog)\n    Timeout.timeout(30) do\n      spam_fields.any? do |field|\n        sp.is_spam?(send(field))\n      end\n    end\n  rescue Timeout::Error\n    nil\n  end\n\n  def akismet_is_spam?(_options = {})\n    return false if akismet.nil?\n\n    begin\n      Timeout.timeout(60) do\n        akismet.comment_check(ip, user_agent, akismet_options)\n      end\n    rescue Timeout::Error\n      nil\n    end\n  end\n\n  def change_state!\n    result = \"\"\n    if spam? || presumed_spam?\n      mark_as_ham!\n      result = \"ham\"\n    else\n      mark_as_spam!\n      result = \"spam\"\n    end\n    result\n  end\n\n  def confirm_classification!\n    confirm_classification\n    save!\n  end\n\n  def confirm_classification\n    if presumed_spam?\n      mark_as_spam\n    elsif presumed_ham?\n      mark_as_ham\n    end\n  end\n\n  def report_as_spam\n    return if akismet.nil?\n\n    begin\n      Timeout.timeout(5) do\n        akismet.submit_spam(ip, user_agent, akismet_options)\n      end\n    rescue Timeout::Error\n      nil\n    end\n  end\n\n  def report_as_ham\n    return if akismet.nil?\n\n    begin\n      Timeout.timeout(5) do\n        akismet.ham(ip, user_agent, akismet_options)\n      end\n    rescue Timeout::Error\n      nil\n    end\n  end\n\n  def feedback_not_closed\n    check_article_closed_for_feedback\n  end\n\n  def send_notifications\n    nil\n  end\n\n  def published?\n    ham? || presumed_ham?\n  end\n\n  def status_confirmed?\n    ham? || spam?\n  end\n\n  def spammy?\n    spam? || presumed_spam?\n  end\n\n  delegate :blog, to: :article\n\n  private\n\n  def akismet\n    @akismet ||= akismet_client\n  end\n\n  def akismet_client\n    return nil if blog.sp_akismet_key.blank?\n\n    client = Akismet::Client.new(blog.sp_akismet_key, blog.base_url)\n    begin\n      client.verify_key ? client : nil\n    rescue SocketError\n      nil\n    end\n  end\n\n  def blog_id\n    article.blog_id if article.present?\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\nrequire \"publify_core/testing_support/dns_mock\"\n\ndescribe Comment, type: :model do\n  let(:blog) { build_stubbed :blog }\n\n  let(:published_article) { build_stubbed(:article, published_at: 1.hour.ago, blog: blog) }\n\n  def valid_comment(options = {})\n    Comment.new({ author: \"Bob\", article: published_article, body: \"nice post\",\n                  ip: \"1.2.3.4\" }.merge(options))\n  end\n\n  describe \"#permalink_url\" do\n    let(:comment) { build_stubbed(:comment) }\n\n    it \"renders permalink to comment in public part\" do\n      expect(comment.permalink_url).\n        to eq(\"#{comment.article.permalink_url}#comment-#{comment.id}\")\n    end\n  end\n\n  describe \"#save\" do\n    it \"saves good comment\" do\n      c = build(:comment, url: \"http://www.google.de\")\n      assert c.save\n      assert_equal \"http://www.google.de\", c.url\n    end\n\n    it \"saves spam comment\" do\n      c = build(:comment, body: 'test <a href=\"http://fakeurl.com\">body</a>')\n      assert c.save\n      assert_equal \"http://fakeurl.com\", c.url\n    end\n\n    it \"does not save when article comment window is closed\" do\n      article = build :article, published_at: 1.year.ago\n      article.blog.sp_article_auto_close = 30\n      comment = build(:comment, author: \"Old Spammer\", body: \"Old trackback body\",\n                                article: article)\n      expect(comment.save).to be_falsey\n      expect(comment.errors[:article]).not_to be_empty\n    end\n\n    it \"changes old comment\" do\n      c = build(:comment, body: \"Comment body <em>italic</em> <strong>bold</strong>\")\n      assert c.save\n      assert c.errors.empty?\n    end\n\n    it \"saves a valid comment\" do\n      c = build :comment\n      expect(c.save).to be_truthy\n      expect(c.errors).to be_empty\n    end\n\n    it \"does not save with article not allow comment\" do\n      c = build(:comment, article: build_stubbed(:article, allow_comments: false))\n      expect(c.save).not_to be_truthy\n      expect(c.errors).not_to be_empty\n    end\n\n    it \"generates guid\" do\n      c = build :comment, guid: nil\n      assert c.save\n      assert c.guid.size > 15\n    end\n\n    it \"preserves urls starting with https://\" do\n      c = build :comment, url: \"https://example.com/\"\n      c.save\n      expect(c.url).to eq(\"https://example.com/\")\n    end\n\n    it \"preserves urls starting with http://\" do\n      c = build :comment, url: \"http://example.com/\"\n      c.save\n      expect(c.url).to eq(\"http://example.com/\")\n    end\n\n    it \"prepends http:// to urls without protocol\" do\n      c = build :comment, url: \"example.com\"\n      c.save\n      expect(c.url).to eq(\"http://example.com\")\n    end\n  end\n\n  describe \"#classify_content\" do\n    it \"rejects spam rbl\" do\n      comment = valid_comment(\n        author: \"Spammer\",\n        body: <<-BODY,\n          This is just some random text.\n          &lt;a href=\"http://chinaaircatering.com\"&gt;without any senses.&lt;/a&gt;.\n          Please disregard.\n        BODY\n        url: \"http://buy-computer.us\")\n      comment.classify_content\n      expect(comment).to be_spammy\n      expect(comment).not_to be_status_confirmed\n    end\n\n    it \"does not define spam a comment rbl with lookup succeeds\" do\n      comment = valid_comment(author: \"Not a Spammer\", body: \"Useful commentary!\",\n                              url: \"http://www.bofh.org.uk\")\n      comment.classify_content\n      expect(comment).not_to be_spammy\n      expect(comment).not_to be_status_confirmed\n    end\n\n    it \"rejects spam with uri limit\" do\n      comment =\n        valid_comment(author: \"Yet Another Spammer\",\n                      body: <<~HTML,\n                        <a href=\"http://www.one.com/\">one</a>\n                        <a href=\"http://www.two.com/\">two</a>\n                        <a href=\"http://www.three.com/\">three</a>\n                        <a href=\"http://www.four.com/\">four</a>\n                      HTML\n                      url: \"http://www.uri-limit.com\")\n      comment.classify_content\n      expect(comment).to be_spammy\n      expect(comment).not_to be_status_confirmed\n    end\n\n    describe \"with feedback moderation enabled\" do\n      before do\n        allow(blog).to receive(:sp_global).and_return(false)\n        allow(blog).to receive(:default_moderate_comments).and_return(true)\n      end\n\n      it \"marks comment as presumably spam\" do\n        comment = described_class.new do |c|\n          c.body = \"Test foo\"\n          c.author = \"Bob\"\n          c.article = build_stubbed(:article, blog: blog)\n        end\n\n        comment.classify_content\n\n        assert !comment.published?\n        assert comment.presumed_spam?\n        assert !comment.status_confirmed?\n      end\n\n      it \"marks comment from known user as confirmed ham\" do\n        comment = described_class.new do |c|\n          c.body = \"Test foo\"\n          c.author = \"Henri\"\n          c.article = build_stubbed(:article, blog: blog)\n          c.user = build_stubbed(:user)\n        end\n\n        comment.classify_content\n\n        assert comment.published?\n        assert comment.ham?\n        assert comment.status_confirmed?\n      end\n    end\n  end\n\n  it \"has good relation\" do\n    article = build_stubbed(:article)\n    comment = build_stubbed(:comment, article: article)\n    assert comment.article\n    assert_equal article, comment.article\n  end\n\n  describe \"change state\" do\n    it \"becomes unpublished if withdrawn\" do\n      c = build :comment\n      assert c.published?\n      assert c.withdraw!\n      assert !c.published?\n      assert c.spam?\n      assert c.status_confirmed?\n    end\n\n    it \"becomeses confirmed if withdrawn\" do\n      unconfirmed = build(:comment, state: \"presumed_ham\")\n      expect(unconfirmed).not_to be_status_confirmed\n      unconfirmed.withdraw!\n      expect(unconfirmed).to be_status_confirmed\n    end\n  end\n\n  it \"has good default filter\" do\n    create :blog, text_filter: \"textile\", comment_text_filter: \"markdown\"\n    a = create(:comment)\n    assert_equal \"markdown\", a.default_text_filter.name\n  end\n\n  describe \"spam\", integration: true do\n    let!(:comment) { create(:comment, state: \"spam\") }\n    let!(:ham_comment) { create(:comment, state: \"ham\") }\n\n    it \"returns only spam comment\" do\n      expect(described_class.spam).to eq([comment])\n    end\n  end\n\n  describe \"not_spam\", integration: true do\n    let!(:comment) { create(:comment, state: \"spam\") }\n    let!(:ham_comment) { create(:comment, state: \"ham\") }\n    let!(:presumed_spam_comment) { create(:comment, state: \"presumed_spam\") }\n\n    it \"returns all comment that not_spam\" do\n      expect(described_class.not_spam).to match_array [ham_comment, presumed_spam_comment]\n    end\n  end\n\n  describe \"presumed_spam\", integration: true do\n    let!(:comment) { create(:comment, state: \"spam\") }\n    let!(:ham_comment) { create(:comment, state: \"ham\") }\n    let!(:presumed_spam_comment) { create(:comment, state: \"presumed_spam\") }\n\n    it \"returns only presumed_spam\" do\n      expect(described_class.presumed_spam).to eq([presumed_spam_comment])\n    end\n  end\n\n  describe \"last_published\", integration: true do\n    let(:date) { DateTime.new(2012, 12, 23, 12, 47).in_time_zone }\n    let!(:comment_1) { create(:comment, body: \"1\", created_at: date + 1.day) }\n    let!(:comment_4) { create(:comment, body: \"4\", created_at: date + 4.days) }\n    let!(:comment_2) { create(:comment, body: \"2\", created_at: date + 2.days) }\n    let!(:comment_6) { create(:comment, body: \"6\", created_at: date + 6.days) }\n    let!(:comment_3) { create(:comment, body: \"3\", created_at: date + 3.days) }\n    let!(:comment_5) { create(:comment, body: \"5\", created_at: date + 5.days) }\n\n    it \"respond only 5 last_published\" do\n      expect(described_class.last_published).to eq([comment_6, comment_5, comment_4,\n                                                    comment_3, comment_2])\n    end\n  end\n\n  describe \"#html\" do\n    it \"renders email addresses in the body\" do\n      comment = build_stubbed(:comment, body: \"foo@example.com\")\n      expect(comment.html).to match(/mailto:/)\n    end\n\n    it \"returns an html_safe string\" do\n      comment = build_stubbed(:comment, body: \"Just a comment\")\n      expect(comment.html).to be_html_safe\n    end\n\n    context \"with an attempted xss body\" do\n      let(:comment) do\n        described_class.new do |c|\n          c.body = \"Test foo <script>do_evil();</script>\"\n          c.author = \"Bob\"\n          c.article = build_stubbed(:article, blog: blog)\n        end\n      end\n\n      [\"\", \"textile\", \"markdown\", \"smartypants\", \"markdown smartypants\"].each do |filter|\n        it \"rejects with filter '#{filter}'\" do\n          blog.comment_text_filter = filter\n\n          ActiveSupport::Deprecation.silence do\n            assert comment.html(:body) !~ /<script>/\n          end\n        end\n      end\n    end\n\n    context \"with a comment containing some html\" do\n      let(:comment) do\n        described_class.new do |c|\n          c.body = \"Test <b>foo</b> <img src=\\\"https://eviloverlord.com/getmyip.jpg\\\">\"\n          c.author = \"Bob\"\n          c.article = build_stubbed(:article, blog: blog)\n        end\n      end\n\n      [\"\", \"textile\", \"markdown\", \"smartypants\", \"markdown smartypants\"].each do |filter|\n        it \"rejects images but not formatting with filter '#{filter}'\" do\n          blog.comment_text_filter = filter\n\n          html = comment.html(:body)\n\n          ActiveSupport::Deprecation.silence do\n            expect(html).not_to match(/<img/)\n            expect(html).to match(%r{<b>foo</b>})\n          end\n        end\n      end\n    end\n\n    context \"with a markdown comment with italic and bold\" do\n      let(:comment) { build(:comment, body: \"Comment body _italic_ **bold**\") }\n      let(:blog) { comment.article.blog }\n\n      it \"converts the comment markup to html\" do\n        blog.comment_text_filter = \"markdown\"\n        result = comment.html\n\n        aggregate_failures do\n          expect(result).to match(%r{<em>italic</em>})\n          expect(result).to match(%r{<strong>bold</strong>})\n        end\n      end\n    end\n  end\nend\n"], "filenames": ["publify_core/app/models/feedback.rb", "publify_core/spec/models/comment_spec.rb"], "buggy_code_start_loc": [69, 270], "buggy_code_end_loc": [90, 270], "fixing_code_start_loc": [70, 271], "fixing_code_end_loc": [94, 294], "type": "CWE-94", "message": "Code Injection in GitHub repository publify/publify prior to 9.2.8.", "other": {"cve": {"id": "CVE-2022-0578", "sourceIdentifier": "security@huntr.dev", "published": "2022-05-16T15:15:08.607", "lastModified": "2022-05-24T20:31:57.213", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Code Injection in GitHub repository publify/publify prior to 9.2.8."}, {"lang": "es", "value": "Una Inyecci\u00f3n de C\u00f3digo en el repositorio GitHub publify/publify versiones anteriores a 9.2.8"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-94"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-94"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:publify_project:publify:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.2.8", "matchCriteriaId": "3310B9A3-CF26-460A-8F77-9D245D34243B"}]}]}], "references": [{"url": "https://github.com/publify/publify/commit/b50df050c593cc532b2c516792989bcfce2d73f7", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/02c81928-eb47-476f-8000-e93dc796dbcc", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/publify/publify/commit/b50df050c593cc532b2c516792989bcfce2d73f7"}}