{"buggy_code": ["/*****************************************************************************\n* Open MCT, Copyright (c) 2014-2021, United States Government\n* as represented by the Administrator of the National Aeronautics and Space\n* Administration. All rights reserved.\n*\n* Open MCT is licensed under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n* http://www.apache.org/licenses/LICENSE-2.0.\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n* License for the specific language governing permissions and limitations\n* under the License.\n*\n* Open MCT includes source code licensed under additional open source\n* licenses. See the Open Source Licenses file (LICENSES.md) included with\n* this source code distribution or the Licensing information page available\n* at runtime from the About dialog for additional information.\n*****************************************************************************/\n\n<template>\n<component :is=\"urlDefined ? 'a' : 'span'\"\n           class=\"c-condition-widget u-style-receiver js-style-receiver\"\n           :href=\"url\"\n>\n    <div class=\"c-condition-widget__label\">\n        {{ internalDomainObject.label }}\n    </div>\n</component>\n</template>\n\n<script>\nconst sanitizeUrl = require(\"@braintree/sanitize-url\").sanitizeUrl;\n\nexport default {\n    inject: ['openmct', 'domainObject'],\n    data: function () {\n        return {\n            internalDomainObject: this.domainObject\n        };\n    },\n    computed: {\n        url() {\n            const urlDefined = this.internalDomainObject.url && this.internalDomainObject.url.length > 0;\n            let url = urlDefined ? this.internalDomainObject.url : null;\n            if (url) {\n                url = sanitizeUrl(url);\n            }\n\n            return url;\n        }\n    },\n    mounted() {\n        this.unlisten = this.openmct.objects.observe(this.internalDomainObject, '*', this.updateInternalDomainObject);\n    },\n    beforeDestroy() {\n        if (this.unlisten) {\n            this.unlisten();\n        }\n    },\n    methods: {\n        updateInternalDomainObject(domainObject) {\n            this.internalDomainObject = domainObject;\n        }\n    }\n};\n</script>\n", "/*****************************************************************************\n* Open MCT, Copyright (c) 2014-2021, United States Government\n* as represented by the Administrator of the National Aeronautics and Space\n* Administration. All rights reserved.\n*\n* Open MCT is licensed under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n* http://www.apache.org/licenses/LICENSE-2.0.\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n* License for the specific language governing permissions and limitations\n* under the License.\n*\n* Open MCT includes source code licensed under additional open source\n* licenses. See the Open Source Licenses file (LICENSES.md) included with\n* this source code distribution or the Licensing information page available\n* at runtime from the About dialog for additional information.\n*****************************************************************************/\n\n<template>\n\n<a class=\"c-hyperlink\"\n   :class=\"{\n       'c-hyperlink--button' : isButton\n   }\"\n   :target=\"domainObject.linkTarget\"\n   :href=\"url\"\n>\n    <span class=\"c-hyperlink__label\">{{ domainObject.displayText }}</span>\n</a>\n\n</template>\n\n<script>\nconst sanitizeUrl = require(\"@braintree/sanitize-url\").sanitizeUrl;\n\nexport default {\n    inject: ['domainObject'],\n    computed: {\n        isButton() {\n            if (this.domainObject.displayFormat === \"link\") {\n                return false;\n            }\n\n            return true;\n        },\n        url() {\n            let url = this.domainObject.url;\n            if (url) {\n                url = sanitizeUrl(url);\n            }\n\n            return url;\n        }\n    }\n};\n</script>\n", "define([\r\n    '../res/widgetTemplate.html',\r\n    './Rule',\r\n    './ConditionManager',\r\n    './TestDataManager',\r\n    './WidgetDnD',\r\n    './eventHelpers',\r\n    'objectUtils',\r\n    'lodash',\r\n    'zepto',\r\n    '@braintree/sanitize-url'\r\n], function (\r\n    widgetTemplate,\r\n    Rule,\r\n    ConditionManager,\r\n    TestDataManager,\r\n    WidgetDnD,\r\n    eventHelpers,\r\n    objectUtils,\r\n    _,\r\n    $,\r\n    urlSanitizeLib\r\n) {\r\n\r\n    //default css configuration for new rules\r\n    const DEFAULT_PROPS = {\r\n        'color': '#cccccc',\r\n        'background-color': '#666666',\r\n        'border-color': 'rgba(0,0,0,0)'\r\n    };\r\n\r\n    /**\r\n     * A Summary Widget object, which allows a user to configure rules based\r\n     * on telemetry producing domain objects, and update a compact display\r\n     * accordingly.\r\n     * @constructor\r\n     * @param {Object} domainObject The domain Object represented by this Widget\r\n     * @param {MCT} openmct An MCT instance\r\n     */\r\n    function SummaryWidget(domainObject, openmct) {\r\n        eventHelpers.extend(this);\r\n\r\n        this.domainObject = domainObject;\r\n        this.openmct = openmct;\r\n\r\n        this.domainObject.configuration = this.domainObject.configuration || {};\r\n        this.domainObject.configuration.ruleConfigById = this.domainObject.configuration.ruleConfigById || {};\r\n        this.domainObject.configuration.ruleOrder = this.domainObject.configuration.ruleOrder || ['default'];\r\n        this.domainObject.configuration.testDataConfig = this.domainObject.configuration.testDataConfig || [{\r\n            object: '',\r\n            key: '',\r\n            value: ''\r\n        }];\r\n\r\n        this.activeId = 'default';\r\n        this.rulesById = {};\r\n        this.domElement = $(widgetTemplate);\r\n        this.toggleRulesControl = $('.t-view-control-rules', this.domElement);\r\n        this.toggleTestDataControl = $('.t-view-control-test-data', this.domElement);\r\n        this.widgetButton = this.domElement.children('#widget');\r\n        this.editing = false;\r\n        this.container = '';\r\n        this.editListenerUnsubscribe = $.noop;\r\n\r\n        this.outerWrapper = $('.widget-edit-holder', this.domElement);\r\n        this.ruleArea = $('#ruleArea', this.domElement);\r\n        this.configAreaRules = $('.widget-rules-wrapper', this.domElement);\r\n\r\n        this.testDataArea = $('.widget-test-data', this.domElement);\r\n        this.addRuleButton = $('#addRule', this.domElement);\r\n\r\n        this.conditionManager = new ConditionManager(this.domainObject, this.openmct);\r\n        this.testDataManager = new TestDataManager(this.domainObject, this.conditionManager, this.openmct);\r\n\r\n        this.watchForChanges = this.watchForChanges.bind(this);\r\n        this.show = this.show.bind(this);\r\n        this.destroy = this.destroy.bind(this);\r\n        this.addRule = this.addRule.bind(this);\r\n\r\n        this.addHyperlink(domainObject.url, domainObject.openNewTab);\r\n        this.watchForChanges(openmct, domainObject);\r\n\r\n        const id = objectUtils.makeKeyString(this.domainObject.identifier);\r\n        const self = this;\r\n\r\n        /**\r\n         * Toggles the configuration area for test data in the view\r\n         * @private\r\n         */\r\n        function toggleTestData() {\r\n            self.outerWrapper.toggleClass('expanded-widget-test-data');\r\n            self.toggleTestDataControl.toggleClass('c-disclosure-triangle--expanded');\r\n        }\r\n\r\n        this.listenTo(this.toggleTestDataControl, 'click', toggleTestData);\r\n\r\n        /**\r\n         * Toggles the configuration area for rules in the view\r\n         * @private\r\n         */\r\n        function toggleRules() {\r\n            self.outerWrapper.toggleClass('expanded-widget-rules');\r\n            self.toggleRulesControl.toggleClass('c-disclosure-triangle--expanded');\r\n        }\r\n\r\n        this.listenTo(this.toggleRulesControl, 'click', toggleRules);\r\n\r\n        openmct.$injector.get('objectService')\r\n            .getObjects([id]);\r\n    }\r\n\r\n    /**\r\n     * adds or removes href to widget button and adds or removes openInNewTab\r\n     * @param {string} url String that denotes the url to be opened\r\n     * @param {string} openNewTab String that denotes wether to open link in new tab or not\r\n     */\r\n    SummaryWidget.prototype.addHyperlink = function (url, openNewTab) {\r\n        if (url) {\r\n            const sanitizeUrl = urlSanitizeLib.sanitizeUrl;\r\n            url = sanitizeUrl(url);\r\n            this.widgetButton.attr('href', url);\r\n        } else {\r\n            this.widgetButton.removeAttr('href');\r\n        }\r\n\r\n        if (openNewTab === 'newTab') {\r\n            this.widgetButton.attr('target', '_blank');\r\n        } else {\r\n            this.widgetButton.removeAttr('target');\r\n        }\r\n    };\r\n\r\n    /**\r\n     * adds a listener to the object to watch for any changes made by user\r\n     * only executes if changes are observed\r\n     * @param {openmct} Object Instance of OpenMCT\r\n     * @param {domainObject} Object instance of this object\r\n     */\r\n    SummaryWidget.prototype.watchForChanges = function (openmct, domainObject) {\r\n        this.watchForChangesUnsubscribe = openmct.objects.observe(domainObject, '*', function (newDomainObject) {\r\n            if (newDomainObject.url !== this.domainObject.url\r\n                    || newDomainObject.openNewTab !== this.domainObject.openNewTab) {\r\n                this.addHyperlink(newDomainObject.url, newDomainObject.openNewTab);\r\n            }\r\n        }.bind(this));\r\n    };\r\n\r\n    /**\r\n     * Builds the Summary Widget's DOM, performs other necessary setup, and attaches\r\n     * this Summary Widget's view to the supplied container.\r\n     * @param {element} container The DOM element that will contain this Summary\r\n     *                            Widget's view.\r\n     */\r\n    SummaryWidget.prototype.show = function (container) {\r\n        const self = this;\r\n        this.container = container;\r\n        $(container).append(this.domElement);\r\n        $('.widget-test-data', this.domElement).append(this.testDataManager.getDOM());\r\n        this.widgetDnD = new WidgetDnD(this.domElement, this.domainObject.configuration.ruleOrder, this.rulesById);\r\n        this.initRule('default', 'Default');\r\n        this.domainObject.configuration.ruleOrder.forEach(function (ruleId) {\r\n            if (ruleId !== 'default') {\r\n                self.initRule(ruleId);\r\n            }\r\n        });\r\n        this.refreshRules();\r\n        this.updateWidget();\r\n\r\n        this.listenTo(this.addRuleButton, 'click', this.addRule);\r\n        this.conditionManager.on('receiveTelemetry', this.executeRules, this);\r\n        this.widgetDnD.on('drop', this.reorder, this);\r\n    };\r\n\r\n    /**\r\n     * Unregister event listeners with the Open MCT APIs, unsubscribe from telemetry,\r\n     * and clean up event handlers\r\n     */\r\n    SummaryWidget.prototype.destroy = function (container) {\r\n        this.editListenerUnsubscribe();\r\n        this.conditionManager.destroy();\r\n        this.testDataManager.destroy();\r\n        this.widgetDnD.destroy();\r\n        this.watchForChangesUnsubscribe();\r\n        Object.values(this.rulesById).forEach(function (rule) {\r\n            rule.destroy();\r\n        });\r\n\r\n        this.stopListening();\r\n    };\r\n\r\n    /**\r\n     * Update the view from the current rule configuration and order\r\n     */\r\n    SummaryWidget.prototype.refreshRules = function () {\r\n        const self = this;\r\n        const ruleOrder = self.domainObject.configuration.ruleOrder;\r\n        const rules = self.rulesById;\r\n        self.ruleArea.html('');\r\n        Object.values(ruleOrder).forEach(function (ruleId) {\r\n            self.ruleArea.append(rules[ruleId].getDOM());\r\n        });\r\n\r\n        this.executeRules();\r\n        this.addOrRemoveDragIndicator();\r\n    };\r\n\r\n    SummaryWidget.prototype.addOrRemoveDragIndicator = function () {\r\n        const rules = this.domainObject.configuration.ruleOrder;\r\n        const rulesById = this.rulesById;\r\n\r\n        rules.forEach(function (ruleKey, index, array) {\r\n            if (array.length > 2 && index > 0) {\r\n                $('.t-grippy', rulesById[ruleKey].domElement).show();\r\n            } else {\r\n                $('.t-grippy', rulesById[ruleKey].domElement).hide();\r\n            }\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Update the widget's appearance from the configuration of the active rule\r\n     */\r\n    SummaryWidget.prototype.updateWidget = function () {\r\n        const WIDGET_ICON_CLASS = 'c-sw__icon js-sw__icon';\r\n        const activeRule = this.rulesById[this.activeId];\r\n        this.applyStyle($('#widget', this.domElement), activeRule.getProperty('style'));\r\n        $('#widget', this.domElement).prop('title', activeRule.getProperty('message'));\r\n        $('#widgetLabel', this.domElement).html(activeRule.getProperty('label'));\r\n        $('#widgetIcon', this.domElement).removeClass().addClass(WIDGET_ICON_CLASS + ' ' + activeRule.getProperty('icon'));\r\n    };\r\n\r\n    /**\r\n     * Get the active rule and update the Widget's appearance.\r\n     */\r\n    SummaryWidget.prototype.executeRules = function () {\r\n        this.activeId = this.conditionManager.executeRules(\r\n            this.domainObject.configuration.ruleOrder,\r\n            this.rulesById\r\n        );\r\n        this.updateWidget();\r\n    };\r\n\r\n    /**\r\n     * Add a new rule to this widget\r\n     */\r\n    SummaryWidget.prototype.addRule = function () {\r\n        let ruleCount = 0;\r\n        let ruleId;\r\n        const ruleOrder = this.domainObject.configuration.ruleOrder;\r\n\r\n        while (Object.keys(this.rulesById).includes('rule' + ruleCount)) {\r\n            ruleCount++;\r\n        }\r\n\r\n        ruleId = 'rule' + ruleCount;\r\n        ruleOrder.push(ruleId);\r\n        this.domainObject.configuration.ruleOrder = ruleOrder;\r\n\r\n        this.initRule(ruleId, 'Rule');\r\n        this.updateDomainObject();\r\n        this.refreshRules();\r\n    };\r\n\r\n    /**\r\n     * Duplicate an existing widget rule from its configuration and splice it in\r\n     * after the rule it duplicates\r\n     * @param {Object} sourceConfig The configuration properties of the rule to be\r\n     *                              instantiated\r\n     */\r\n    SummaryWidget.prototype.duplicateRule = function (sourceConfig) {\r\n        let ruleCount = 0;\r\n        let ruleId;\r\n        const sourceRuleId = sourceConfig.id;\r\n        const ruleOrder = this.domainObject.configuration.ruleOrder;\r\n        const ruleIds = Object.keys(this.rulesById);\r\n\r\n        while (ruleIds.includes('rule' + ruleCount)) {\r\n            ruleCount = ++ruleCount;\r\n        }\r\n\r\n        ruleId = 'rule' + ruleCount;\r\n        sourceConfig.id = ruleId;\r\n        sourceConfig.name += ' Copy';\r\n        ruleOrder.splice(ruleOrder.indexOf(sourceRuleId) + 1, 0, ruleId);\r\n        this.domainObject.configuration.ruleOrder = ruleOrder;\r\n        this.domainObject.configuration.ruleConfigById[ruleId] = sourceConfig;\r\n        this.initRule(ruleId, sourceConfig.name);\r\n        this.updateDomainObject();\r\n        this.refreshRules();\r\n    };\r\n\r\n    /**\r\n     * Initialze a new rule from a default configuration, or build a {Rule} object\r\n     * from it if already exists\r\n     * @param {string} ruleId An key to be used to identify this ruleId, or the key\r\n                              of the rule to be instantiated\r\n     * @param {string} ruleName The initial human-readable name of this rule\r\n     */\r\n    SummaryWidget.prototype.initRule = function (ruleId, ruleName) {\r\n        let ruleConfig;\r\n        const styleObj = {};\r\n\r\n        Object.assign(styleObj, DEFAULT_PROPS);\r\n        if (!this.domainObject.configuration.ruleConfigById[ruleId]) {\r\n            this.domainObject.configuration.ruleConfigById[ruleId] = {\r\n                name: ruleName || 'Rule',\r\n                label: 'Unnamed Rule',\r\n                message: '',\r\n                id: ruleId,\r\n                icon: ' ',\r\n                style: styleObj,\r\n                description: ruleId === 'default' ? 'Default appearance for the widget' : 'A new rule',\r\n                conditions: [{\r\n                    object: '',\r\n                    key: '',\r\n                    operation: '',\r\n                    values: []\r\n                }],\r\n                jsCondition: '',\r\n                trigger: 'any',\r\n                expanded: 'true'\r\n            };\r\n\r\n        }\r\n\r\n        ruleConfig = this.domainObject.configuration.ruleConfigById[ruleId];\r\n        this.rulesById[ruleId] = new Rule(ruleConfig, this.domainObject, this.openmct,\r\n            this.conditionManager, this.widgetDnD, this.container);\r\n        this.rulesById[ruleId].on('remove', this.refreshRules, this);\r\n        this.rulesById[ruleId].on('duplicate', this.duplicateRule, this);\r\n        this.rulesById[ruleId].on('change', this.updateWidget, this);\r\n        this.rulesById[ruleId].on('conditionChange', this.executeRules, this);\r\n    };\r\n\r\n    /**\r\n     * Given two ruleIds, move the source rule after the target rule and update\r\n     * the view.\r\n     * @param {Object} event An event object representing this drop with draggingId\r\n     *                       and dropTarget fields\r\n     */\r\n    SummaryWidget.prototype.reorder = function (event) {\r\n        const ruleOrder = this.domainObject.configuration.ruleOrder;\r\n        const sourceIndex = ruleOrder.indexOf(event.draggingId);\r\n        let targetIndex;\r\n\r\n        if (event.draggingId !== event.dropTarget) {\r\n            ruleOrder.splice(sourceIndex, 1);\r\n            targetIndex = ruleOrder.indexOf(event.dropTarget);\r\n            ruleOrder.splice(targetIndex + 1, 0, event.draggingId);\r\n            this.domainObject.configuration.ruleOrder = ruleOrder;\r\n            this.updateDomainObject();\r\n        }\r\n\r\n        this.refreshRules();\r\n    };\r\n\r\n    /**\r\n     * Apply a list of css properties to an element\r\n     * @param {element} elem The DOM element to which the rules will be applied\r\n     * @param {object} style an object representing the style\r\n     */\r\n    SummaryWidget.prototype.applyStyle = function (elem, style) {\r\n        Object.keys(style).forEach(function (propId) {\r\n            elem.css(propId, style[propId]);\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Mutate this domain object's configuration with the current local configuration\r\n     */\r\n    SummaryWidget.prototype.updateDomainObject = function () {\r\n        this.openmct.objects.mutate(this.domainObject, 'configuration', this.domainObject.configuration);\r\n    };\r\n\r\n    return SummaryWidget;\r\n});\r\n", "define([\n    './summary-widget.html',\n    '@braintree/sanitize-url'\n], function (\n    summaryWidgetTemplate,\n    urlSanitizeLib\n) {\n    const WIDGET_ICON_CLASS = 'c-sw__icon js-sw__icon';\n\n    function SummaryWidgetView(domainObject, openmct) {\n        this.openmct = openmct;\n        this.domainObject = domainObject;\n        this.hasUpdated = false;\n        this.render = this.render.bind(this);\n    }\n\n    SummaryWidgetView.prototype.updateState = function (datum) {\n        this.hasUpdated = true;\n        this.widget.style.color = datum.textColor;\n        this.widget.style.backgroundColor = datum.backgroundColor;\n        this.widget.style.borderColor = datum.borderColor;\n        this.widget.title = datum.message;\n        this.label.title = datum.message;\n        this.label.innerHTML = datum.ruleLabel;\n        this.icon.className = WIDGET_ICON_CLASS + ' ' + datum.icon;\n    };\n\n    SummaryWidgetView.prototype.render = function () {\n        if (this.unsubscribe) {\n            this.unsubscribe();\n        }\n\n        this.hasUpdated = false;\n\n        this.container.innerHTML = summaryWidgetTemplate;\n        this.widget = this.container.querySelector('a');\n        this.icon = this.container.querySelector('#widgetIcon');\n        this.label = this.container.querySelector('.js-sw__label');\n\n        let url = this.domainObject.url;\n        if (url) {\n            const sanitizeUrl = urlSanitizeLib.sanitizeUrl;\n            url = sanitizeUrl(url);\n            this.widget.setAttribute('href', url);\n        } else {\n            this.widget.removeAttribute('href');\n        }\n\n        if (this.domainObject.openNewTab === 'newTab') {\n            this.widget.setAttribute('target', '_blank');\n        } else {\n            this.widget.removeAttribute('target');\n        }\n\n        const renderTracker = {};\n        this.renderTracker = renderTracker;\n        this.openmct.telemetry.request(this.domainObject, {\n            strategy: 'latest',\n            size: 1\n        }).then(function (results) {\n            if (this.destroyed\n                || this.hasUpdated\n                || this.renderTracker !== renderTracker\n                || results.length === 0) {\n                return;\n            }\n\n            this.updateState(results[results.length - 1]);\n        }.bind(this));\n\n        this.unsubscribe = this.openmct\n            .telemetry\n            .subscribe(this.domainObject, this.updateState.bind(this));\n    };\n\n    SummaryWidgetView.prototype.show = function (container) {\n        this.container = container;\n        this.render();\n        this.removeMutationListener = this.openmct.objects.observe(\n            this.domainObject,\n            '*',\n            this.onMutation.bind(this)\n        );\n        this.openmct.time.on('timeSystem', this.render);\n    };\n\n    SummaryWidgetView.prototype.onMutation = function (domainObject) {\n        this.domainObject = domainObject;\n        this.render();\n    };\n\n    SummaryWidgetView.prototype.destroy = function (container) {\n        this.unsubscribe();\n        this.removeMutationListener();\n        this.openmct.time.off('timeSystem', this.render);\n        this.destroyed = true;\n        delete this.widget;\n        delete this.label;\n        delete this.openmct;\n        delete this.domainObject;\n    };\n\n    return SummaryWidgetView;\n\n});\n", "<template>\n<div class=\"l-iframe abs\">\n    <iframe :src=\"url\"></iframe>\n</div>\n</template>\n\n<script>\nconst sanitizeUrl = require(\"@braintree/sanitize-url\").sanitizeUrl;\n\nexport default {\n    inject: ['openmct', 'domainObject'],\n    data: function () {\n        return {\n            currentDomainObject: this.domainObject\n        };\n    },\n    computed: {\n        url() {\n            let url = this.currentDomainObject.url;\n            if (url) {\n                url = sanitizeUrl(url);\n            }\n\n            return url;\n        }\n    }\n};\n</script>\n"], "fixing_code": ["/*****************************************************************************\n* Open MCT, Copyright (c) 2014-2021, United States Government\n* as represented by the Administrator of the National Aeronautics and Space\n* Administration. All rights reserved.\n*\n* Open MCT is licensed under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n* http://www.apache.org/licenses/LICENSE-2.0.\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n* License for the specific language governing permissions and limitations\n* under the License.\n*\n* Open MCT includes source code licensed under additional open source\n* licenses. See the Open Source Licenses file (LICENSES.md) included with\n* this source code distribution or the Licensing information page available\n* at runtime from the About dialog for additional information.\n*****************************************************************************/\n\n<template>\n<component :is=\"urlDefined ? 'a' : 'span'\"\n           class=\"c-condition-widget u-style-receiver js-style-receiver\"\n           :href=\"url\"\n>\n    <div class=\"c-condition-widget__label\">\n        {{ internalDomainObject.label }}\n    </div>\n</component>\n</template>\n\n<script>\nconst sanitizeUrl = require(\"@braintree/sanitize-url\").sanitizeUrl;\n\nexport default {\n    inject: ['openmct', 'domainObject'],\n    data: function () {\n        return {\n            internalDomainObject: this.domainObject\n        };\n    },\n    computed: {\n        urlDefined() {\n            return this.internalDomainObject.url && this.internalDomainObject.url.length > 0;\n        },\n        url() {\n            return this.urlDefined ? sanitizeUrl(this.internalDomainObject.url) : null;\n        }\n    },\n    mounted() {\n        this.unlisten = this.openmct.objects.observe(this.internalDomainObject, '*', this.updateInternalDomainObject);\n    },\n    beforeDestroy() {\n        if (this.unlisten) {\n            this.unlisten();\n        }\n    },\n    methods: {\n        updateInternalDomainObject(domainObject) {\n            this.internalDomainObject = domainObject;\n        }\n    }\n};\n</script>\n", "/*****************************************************************************\n* Open MCT, Copyright (c) 2014-2021, United States Government\n* as represented by the Administrator of the National Aeronautics and Space\n* Administration. All rights reserved.\n*\n* Open MCT is licensed under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n* http://www.apache.org/licenses/LICENSE-2.0.\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n* License for the specific language governing permissions and limitations\n* under the License.\n*\n* Open MCT includes source code licensed under additional open source\n* licenses. See the Open Source Licenses file (LICENSES.md) included with\n* this source code distribution or the Licensing information page available\n* at runtime from the About dialog for additional information.\n*****************************************************************************/\n\n<template>\n\n<a class=\"c-hyperlink\"\n   :class=\"{\n       'c-hyperlink--button' : isButton\n   }\"\n   :target=\"domainObject.linkTarget\"\n   :href=\"url\"\n>\n    <span class=\"c-hyperlink__label\">{{ domainObject.displayText }}</span>\n</a>\n\n</template>\n\n<script>\nconst sanitizeUrl = require(\"@braintree/sanitize-url\").sanitizeUrl;\n\nexport default {\n    inject: ['domainObject'],\n    computed: {\n        isButton() {\n            if (this.domainObject.displayFormat === \"link\") {\n                return false;\n            }\n\n            return true;\n        },\n        url() {\n            return sanitizeUrl(this.domainObject.url);\n        }\n    }\n};\n</script>\n", "define([\r\n    '../res/widgetTemplate.html',\r\n    './Rule',\r\n    './ConditionManager',\r\n    './TestDataManager',\r\n    './WidgetDnD',\r\n    './eventHelpers',\r\n    'objectUtils',\r\n    'lodash',\r\n    'zepto',\r\n    '@braintree/sanitize-url'\r\n], function (\r\n    widgetTemplate,\r\n    Rule,\r\n    ConditionManager,\r\n    TestDataManager,\r\n    WidgetDnD,\r\n    eventHelpers,\r\n    objectUtils,\r\n    _,\r\n    $,\r\n    urlSanitizeLib\r\n) {\r\n\r\n    //default css configuration for new rules\r\n    const DEFAULT_PROPS = {\r\n        'color': '#cccccc',\r\n        'background-color': '#666666',\r\n        'border-color': 'rgba(0,0,0,0)'\r\n    };\r\n\r\n    /**\r\n     * A Summary Widget object, which allows a user to configure rules based\r\n     * on telemetry producing domain objects, and update a compact display\r\n     * accordingly.\r\n     * @constructor\r\n     * @param {Object} domainObject The domain Object represented by this Widget\r\n     * @param {MCT} openmct An MCT instance\r\n     */\r\n    function SummaryWidget(domainObject, openmct) {\r\n        eventHelpers.extend(this);\r\n\r\n        this.domainObject = domainObject;\r\n        this.openmct = openmct;\r\n\r\n        this.domainObject.configuration = this.domainObject.configuration || {};\r\n        this.domainObject.configuration.ruleConfigById = this.domainObject.configuration.ruleConfigById || {};\r\n        this.domainObject.configuration.ruleOrder = this.domainObject.configuration.ruleOrder || ['default'];\r\n        this.domainObject.configuration.testDataConfig = this.domainObject.configuration.testDataConfig || [{\r\n            object: '',\r\n            key: '',\r\n            value: ''\r\n        }];\r\n\r\n        this.activeId = 'default';\r\n        this.rulesById = {};\r\n        this.domElement = $(widgetTemplate);\r\n        this.toggleRulesControl = $('.t-view-control-rules', this.domElement);\r\n        this.toggleTestDataControl = $('.t-view-control-test-data', this.domElement);\r\n        this.widgetButton = this.domElement.children('#widget');\r\n        this.editing = false;\r\n        this.container = '';\r\n        this.editListenerUnsubscribe = $.noop;\r\n\r\n        this.outerWrapper = $('.widget-edit-holder', this.domElement);\r\n        this.ruleArea = $('#ruleArea', this.domElement);\r\n        this.configAreaRules = $('.widget-rules-wrapper', this.domElement);\r\n\r\n        this.testDataArea = $('.widget-test-data', this.domElement);\r\n        this.addRuleButton = $('#addRule', this.domElement);\r\n\r\n        this.conditionManager = new ConditionManager(this.domainObject, this.openmct);\r\n        this.testDataManager = new TestDataManager(this.domainObject, this.conditionManager, this.openmct);\r\n\r\n        this.watchForChanges = this.watchForChanges.bind(this);\r\n        this.show = this.show.bind(this);\r\n        this.destroy = this.destroy.bind(this);\r\n        this.addRule = this.addRule.bind(this);\r\n\r\n        this.addHyperlink(domainObject.url, domainObject.openNewTab);\r\n        this.watchForChanges(openmct, domainObject);\r\n\r\n        const id = objectUtils.makeKeyString(this.domainObject.identifier);\r\n        const self = this;\r\n\r\n        /**\r\n         * Toggles the configuration area for test data in the view\r\n         * @private\r\n         */\r\n        function toggleTestData() {\r\n            self.outerWrapper.toggleClass('expanded-widget-test-data');\r\n            self.toggleTestDataControl.toggleClass('c-disclosure-triangle--expanded');\r\n        }\r\n\r\n        this.listenTo(this.toggleTestDataControl, 'click', toggleTestData);\r\n\r\n        /**\r\n         * Toggles the configuration area for rules in the view\r\n         * @private\r\n         */\r\n        function toggleRules() {\r\n            self.outerWrapper.toggleClass('expanded-widget-rules');\r\n            self.toggleRulesControl.toggleClass('c-disclosure-triangle--expanded');\r\n        }\r\n\r\n        this.listenTo(this.toggleRulesControl, 'click', toggleRules);\r\n\r\n        openmct.$injector.get('objectService')\r\n            .getObjects([id]);\r\n    }\r\n\r\n    /**\r\n     * adds or removes href to widget button and adds or removes openInNewTab\r\n     * @param {string} url String that denotes the url to be opened\r\n     * @param {string} openNewTab String that denotes wether to open link in new tab or not\r\n     */\r\n    SummaryWidget.prototype.addHyperlink = function (url, openNewTab) {\r\n        if (url) {\r\n            this.widgetButton.attr('href', urlSanitizeLib.sanitizeUrl(url));\r\n        } else {\r\n            this.widgetButton.removeAttr('href');\r\n        }\r\n\r\n        if (openNewTab === 'newTab') {\r\n            this.widgetButton.attr('target', '_blank');\r\n        } else {\r\n            this.widgetButton.removeAttr('target');\r\n        }\r\n    };\r\n\r\n    /**\r\n     * adds a listener to the object to watch for any changes made by user\r\n     * only executes if changes are observed\r\n     * @param {openmct} Object Instance of OpenMCT\r\n     * @param {domainObject} Object instance of this object\r\n     */\r\n    SummaryWidget.prototype.watchForChanges = function (openmct, domainObject) {\r\n        this.watchForChangesUnsubscribe = openmct.objects.observe(domainObject, '*', function (newDomainObject) {\r\n            if (newDomainObject.url !== this.domainObject.url\r\n                    || newDomainObject.openNewTab !== this.domainObject.openNewTab) {\r\n                this.addHyperlink(newDomainObject.url, newDomainObject.openNewTab);\r\n            }\r\n        }.bind(this));\r\n    };\r\n\r\n    /**\r\n     * Builds the Summary Widget's DOM, performs other necessary setup, and attaches\r\n     * this Summary Widget's view to the supplied container.\r\n     * @param {element} container The DOM element that will contain this Summary\r\n     *                            Widget's view.\r\n     */\r\n    SummaryWidget.prototype.show = function (container) {\r\n        const self = this;\r\n        this.container = container;\r\n        $(container).append(this.domElement);\r\n        $('.widget-test-data', this.domElement).append(this.testDataManager.getDOM());\r\n        this.widgetDnD = new WidgetDnD(this.domElement, this.domainObject.configuration.ruleOrder, this.rulesById);\r\n        this.initRule('default', 'Default');\r\n        this.domainObject.configuration.ruleOrder.forEach(function (ruleId) {\r\n            if (ruleId !== 'default') {\r\n                self.initRule(ruleId);\r\n            }\r\n        });\r\n        this.refreshRules();\r\n        this.updateWidget();\r\n\r\n        this.listenTo(this.addRuleButton, 'click', this.addRule);\r\n        this.conditionManager.on('receiveTelemetry', this.executeRules, this);\r\n        this.widgetDnD.on('drop', this.reorder, this);\r\n    };\r\n\r\n    /**\r\n     * Unregister event listeners with the Open MCT APIs, unsubscribe from telemetry,\r\n     * and clean up event handlers\r\n     */\r\n    SummaryWidget.prototype.destroy = function (container) {\r\n        this.editListenerUnsubscribe();\r\n        this.conditionManager.destroy();\r\n        this.testDataManager.destroy();\r\n        this.widgetDnD.destroy();\r\n        this.watchForChangesUnsubscribe();\r\n        Object.values(this.rulesById).forEach(function (rule) {\r\n            rule.destroy();\r\n        });\r\n\r\n        this.stopListening();\r\n    };\r\n\r\n    /**\r\n     * Update the view from the current rule configuration and order\r\n     */\r\n    SummaryWidget.prototype.refreshRules = function () {\r\n        const self = this;\r\n        const ruleOrder = self.domainObject.configuration.ruleOrder;\r\n        const rules = self.rulesById;\r\n        self.ruleArea.html('');\r\n        Object.values(ruleOrder).forEach(function (ruleId) {\r\n            self.ruleArea.append(rules[ruleId].getDOM());\r\n        });\r\n\r\n        this.executeRules();\r\n        this.addOrRemoveDragIndicator();\r\n    };\r\n\r\n    SummaryWidget.prototype.addOrRemoveDragIndicator = function () {\r\n        const rules = this.domainObject.configuration.ruleOrder;\r\n        const rulesById = this.rulesById;\r\n\r\n        rules.forEach(function (ruleKey, index, array) {\r\n            if (array.length > 2 && index > 0) {\r\n                $('.t-grippy', rulesById[ruleKey].domElement).show();\r\n            } else {\r\n                $('.t-grippy', rulesById[ruleKey].domElement).hide();\r\n            }\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Update the widget's appearance from the configuration of the active rule\r\n     */\r\n    SummaryWidget.prototype.updateWidget = function () {\r\n        const WIDGET_ICON_CLASS = 'c-sw__icon js-sw__icon';\r\n        const activeRule = this.rulesById[this.activeId];\r\n        this.applyStyle($('#widget', this.domElement), activeRule.getProperty('style'));\r\n        $('#widget', this.domElement).prop('title', activeRule.getProperty('message'));\r\n        $('#widgetLabel', this.domElement).html(activeRule.getProperty('label'));\r\n        $('#widgetIcon', this.domElement).removeClass().addClass(WIDGET_ICON_CLASS + ' ' + activeRule.getProperty('icon'));\r\n    };\r\n\r\n    /**\r\n     * Get the active rule and update the Widget's appearance.\r\n     */\r\n    SummaryWidget.prototype.executeRules = function () {\r\n        this.activeId = this.conditionManager.executeRules(\r\n            this.domainObject.configuration.ruleOrder,\r\n            this.rulesById\r\n        );\r\n        this.updateWidget();\r\n    };\r\n\r\n    /**\r\n     * Add a new rule to this widget\r\n     */\r\n    SummaryWidget.prototype.addRule = function () {\r\n        let ruleCount = 0;\r\n        let ruleId;\r\n        const ruleOrder = this.domainObject.configuration.ruleOrder;\r\n\r\n        while (Object.keys(this.rulesById).includes('rule' + ruleCount)) {\r\n            ruleCount++;\r\n        }\r\n\r\n        ruleId = 'rule' + ruleCount;\r\n        ruleOrder.push(ruleId);\r\n        this.domainObject.configuration.ruleOrder = ruleOrder;\r\n\r\n        this.initRule(ruleId, 'Rule');\r\n        this.updateDomainObject();\r\n        this.refreshRules();\r\n    };\r\n\r\n    /**\r\n     * Duplicate an existing widget rule from its configuration and splice it in\r\n     * after the rule it duplicates\r\n     * @param {Object} sourceConfig The configuration properties of the rule to be\r\n     *                              instantiated\r\n     */\r\n    SummaryWidget.prototype.duplicateRule = function (sourceConfig) {\r\n        let ruleCount = 0;\r\n        let ruleId;\r\n        const sourceRuleId = sourceConfig.id;\r\n        const ruleOrder = this.domainObject.configuration.ruleOrder;\r\n        const ruleIds = Object.keys(this.rulesById);\r\n\r\n        while (ruleIds.includes('rule' + ruleCount)) {\r\n            ruleCount = ++ruleCount;\r\n        }\r\n\r\n        ruleId = 'rule' + ruleCount;\r\n        sourceConfig.id = ruleId;\r\n        sourceConfig.name += ' Copy';\r\n        ruleOrder.splice(ruleOrder.indexOf(sourceRuleId) + 1, 0, ruleId);\r\n        this.domainObject.configuration.ruleOrder = ruleOrder;\r\n        this.domainObject.configuration.ruleConfigById[ruleId] = sourceConfig;\r\n        this.initRule(ruleId, sourceConfig.name);\r\n        this.updateDomainObject();\r\n        this.refreshRules();\r\n    };\r\n\r\n    /**\r\n     * Initialze a new rule from a default configuration, or build a {Rule} object\r\n     * from it if already exists\r\n     * @param {string} ruleId An key to be used to identify this ruleId, or the key\r\n                              of the rule to be instantiated\r\n     * @param {string} ruleName The initial human-readable name of this rule\r\n     */\r\n    SummaryWidget.prototype.initRule = function (ruleId, ruleName) {\r\n        let ruleConfig;\r\n        const styleObj = {};\r\n\r\n        Object.assign(styleObj, DEFAULT_PROPS);\r\n        if (!this.domainObject.configuration.ruleConfigById[ruleId]) {\r\n            this.domainObject.configuration.ruleConfigById[ruleId] = {\r\n                name: ruleName || 'Rule',\r\n                label: 'Unnamed Rule',\r\n                message: '',\r\n                id: ruleId,\r\n                icon: ' ',\r\n                style: styleObj,\r\n                description: ruleId === 'default' ? 'Default appearance for the widget' : 'A new rule',\r\n                conditions: [{\r\n                    object: '',\r\n                    key: '',\r\n                    operation: '',\r\n                    values: []\r\n                }],\r\n                jsCondition: '',\r\n                trigger: 'any',\r\n                expanded: 'true'\r\n            };\r\n\r\n        }\r\n\r\n        ruleConfig = this.domainObject.configuration.ruleConfigById[ruleId];\r\n        this.rulesById[ruleId] = new Rule(ruleConfig, this.domainObject, this.openmct,\r\n            this.conditionManager, this.widgetDnD, this.container);\r\n        this.rulesById[ruleId].on('remove', this.refreshRules, this);\r\n        this.rulesById[ruleId].on('duplicate', this.duplicateRule, this);\r\n        this.rulesById[ruleId].on('change', this.updateWidget, this);\r\n        this.rulesById[ruleId].on('conditionChange', this.executeRules, this);\r\n    };\r\n\r\n    /**\r\n     * Given two ruleIds, move the source rule after the target rule and update\r\n     * the view.\r\n     * @param {Object} event An event object representing this drop with draggingId\r\n     *                       and dropTarget fields\r\n     */\r\n    SummaryWidget.prototype.reorder = function (event) {\r\n        const ruleOrder = this.domainObject.configuration.ruleOrder;\r\n        const sourceIndex = ruleOrder.indexOf(event.draggingId);\r\n        let targetIndex;\r\n\r\n        if (event.draggingId !== event.dropTarget) {\r\n            ruleOrder.splice(sourceIndex, 1);\r\n            targetIndex = ruleOrder.indexOf(event.dropTarget);\r\n            ruleOrder.splice(targetIndex + 1, 0, event.draggingId);\r\n            this.domainObject.configuration.ruleOrder = ruleOrder;\r\n            this.updateDomainObject();\r\n        }\r\n\r\n        this.refreshRules();\r\n    };\r\n\r\n    /**\r\n     * Apply a list of css properties to an element\r\n     * @param {element} elem The DOM element to which the rules will be applied\r\n     * @param {object} style an object representing the style\r\n     */\r\n    SummaryWidget.prototype.applyStyle = function (elem, style) {\r\n        Object.keys(style).forEach(function (propId) {\r\n            elem.css(propId, style[propId]);\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Mutate this domain object's configuration with the current local configuration\r\n     */\r\n    SummaryWidget.prototype.updateDomainObject = function () {\r\n        this.openmct.objects.mutate(this.domainObject, 'configuration', this.domainObject.configuration);\r\n    };\r\n\r\n    return SummaryWidget;\r\n});\r\n", "define([\n    './summary-widget.html',\n    '@braintree/sanitize-url'\n], function (\n    summaryWidgetTemplate,\n    urlSanitizeLib\n) {\n    const WIDGET_ICON_CLASS = 'c-sw__icon js-sw__icon';\n\n    function SummaryWidgetView(domainObject, openmct) {\n        this.openmct = openmct;\n        this.domainObject = domainObject;\n        this.hasUpdated = false;\n        this.render = this.render.bind(this);\n    }\n\n    SummaryWidgetView.prototype.updateState = function (datum) {\n        this.hasUpdated = true;\n        this.widget.style.color = datum.textColor;\n        this.widget.style.backgroundColor = datum.backgroundColor;\n        this.widget.style.borderColor = datum.borderColor;\n        this.widget.title = datum.message;\n        this.label.title = datum.message;\n        this.label.innerHTML = datum.ruleLabel;\n        this.icon.className = WIDGET_ICON_CLASS + ' ' + datum.icon;\n    };\n\n    SummaryWidgetView.prototype.render = function () {\n        if (this.unsubscribe) {\n            this.unsubscribe();\n        }\n\n        this.hasUpdated = false;\n\n        this.container.innerHTML = summaryWidgetTemplate;\n        this.widget = this.container.querySelector('a');\n        this.icon = this.container.querySelector('#widgetIcon');\n        this.label = this.container.querySelector('.js-sw__label');\n\n        let url = this.domainObject.url;\n        if (url) {\n            this.widget.setAttribute('href', urlSanitizeLib.sanitizeUrl(url));\n        } else {\n            this.widget.removeAttribute('href');\n        }\n\n        if (this.domainObject.openNewTab === 'newTab') {\n            this.widget.setAttribute('target', '_blank');\n        } else {\n            this.widget.removeAttribute('target');\n        }\n\n        const renderTracker = {};\n        this.renderTracker = renderTracker;\n        this.openmct.telemetry.request(this.domainObject, {\n            strategy: 'latest',\n            size: 1\n        }).then(function (results) {\n            if (this.destroyed\n                || this.hasUpdated\n                || this.renderTracker !== renderTracker\n                || results.length === 0) {\n                return;\n            }\n\n            this.updateState(results[results.length - 1]);\n        }.bind(this));\n\n        this.unsubscribe = this.openmct\n            .telemetry\n            .subscribe(this.domainObject, this.updateState.bind(this));\n    };\n\n    SummaryWidgetView.prototype.show = function (container) {\n        this.container = container;\n        this.render();\n        this.removeMutationListener = this.openmct.objects.observe(\n            this.domainObject,\n            '*',\n            this.onMutation.bind(this)\n        );\n        this.openmct.time.on('timeSystem', this.render);\n    };\n\n    SummaryWidgetView.prototype.onMutation = function (domainObject) {\n        this.domainObject = domainObject;\n        this.render();\n    };\n\n    SummaryWidgetView.prototype.destroy = function (container) {\n        this.unsubscribe();\n        this.removeMutationListener();\n        this.openmct.time.off('timeSystem', this.render);\n        this.destroyed = true;\n        delete this.widget;\n        delete this.label;\n        delete this.openmct;\n        delete this.domainObject;\n    };\n\n    return SummaryWidgetView;\n\n});\n", "<template>\n<div class=\"l-iframe abs\">\n    <iframe :src=\"url\"></iframe>\n</div>\n</template>\n\n<script>\nconst sanitizeUrl = require(\"@braintree/sanitize-url\").sanitizeUrl;\n\nexport default {\n    inject: ['openmct', 'domainObject'],\n    data: function () {\n        return {\n            currentDomainObject: this.domainObject\n        };\n    },\n    computed: {\n        url() {\n            return sanitizeUrl(this.currentDomainObject.url);\n        }\n    }\n};\n</script>\n"], "filenames": ["src/plugins/conditionWidget/components/ConditionWidget.vue", "src/plugins/hyperlink/HyperlinkLayout.vue", "src/plugins/summaryWidget/src/SummaryWidget.js", "src/plugins/summaryWidget/src/views/SummaryWidgetView.js", "src/plugins/webPage/components/WebPage.vue"], "buggy_code_start_loc": [44, 51, 119, 42, 19], "buggy_code_end_loc": [53, 57, 122, 45, 25], "fixing_code_start_loc": [45, 51, 119, 42, 19], "fixing_code_end_loc": [50, 52, 120, 43, 20], "type": "CWE-79", "message": "Openmct versions 1.3.0 to 1.7.7 are vulnerable against stored XSS via the \u201cWeb Page\u201d element, that allows the injection of malicious JavaScript into the \u2018URL\u2019 field. This issue affects: nasa openmct 1.7.7 version and prior versions; 1.3.0 version and later versions.", "other": {"cve": {"id": "CVE-2022-22126", "sourceIdentifier": "vulnerabilitylab@mend.io", "published": "2022-02-20T19:15:09.230", "lastModified": "2022-03-01T20:10:59.323", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Openmct versions 1.3.0 to 1.7.7 are vulnerable against stored XSS via the \u201cWeb Page\u201d element, that allows the injection of malicious JavaScript into the \u2018URL\u2019 field. This issue affects: nasa openmct 1.7.7 version and prior versions; 1.3.0 version and later versions."}, {"lang": "es", "value": "Openmct versiones 1.3.0 hasta 1.7.7, son vulnerables a un ataque de tipo XSS almacenado por medio del elemento \"Web Page\", que permite una inyecci\u00f3n de JavaScript malicioso en el campo \"URL\". Este problema afecta a: nasa openmct versiones 1.7.7 y anteriores; versiones 1.3.0 y posteriores"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "vulnerabilitylab@mend.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "vulnerabilitylab@mend.io", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nasa:openmct:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.3.0", "versionEndIncluding": "1.7.7", "matchCriteriaId": "C14A1D57-15BD-4795-B4EA-B16E1F8C69B8"}]}]}], "references": [{"url": "https://github.com/nasa/openmct/commit/abc93d0ec4b104dac1ea5f8a615d06e3ab78934a", "source": "vulnerabilitylab@mend.io", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nasa/openmct/commit/abc93d0ec4b104dac1ea5f8a615d06e3ab78934a"}}