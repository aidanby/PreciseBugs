{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.\n * All rights reserved.\n */\n\n#include \"cfg80211.h\"\n\n#define GO_NEG_REQ\t\t\t0x00\n#define GO_NEG_RSP\t\t\t0x01\n#define GO_NEG_CONF\t\t\t0x02\n#define P2P_INV_REQ\t\t\t0x03\n#define P2P_INV_RSP\t\t\t0x04\n\n#define WILC_INVALID_CHANNEL\t\t0\n\n/* Operation at 2.4 GHz with channels 1-13 */\n#define WILC_WLAN_OPERATING_CLASS_2_4GHZ\t\t0x51\n\nstatic const struct ieee80211_txrx_stypes\n\twilc_wfi_cfg80211_mgmt_types[NUM_NL80211_IFTYPES] = {\n\t[NL80211_IFTYPE_STATION] = {\n\t\t.tx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_AUTH >> 4),\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_PROBE_REQ >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_AUTH >> 4)\n\t},\n\t[NL80211_IFTYPE_AP] = {\n\t\t.tx = 0xffff,\n\t\t.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_PROBE_REQ >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_DISASSOC >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_AUTH >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_DEAUTH >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_ACTION >> 4)\n\t},\n\t[NL80211_IFTYPE_P2P_CLIENT] = {\n\t\t.tx = 0xffff,\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_PROBE_REQ >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_DISASSOC >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_AUTH >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_DEAUTH >> 4)\n\t}\n};\n\n#ifdef CONFIG_PM\nstatic const struct wiphy_wowlan_support wowlan_support = {\n\t.flags = WIPHY_WOWLAN_ANY\n};\n#endif\n\nstruct wilc_p2p_mgmt_data {\n\tint size;\n\tu8 *buff;\n};\n\nstruct wilc_p2p_pub_act_frame {\n\tu8 category;\n\tu8 action;\n\tu8 oui[3];\n\tu8 oui_type;\n\tu8 oui_subtype;\n\tu8 dialog_token;\n\tu8 elem[];\n} __packed;\n\nstruct wilc_vendor_specific_ie {\n\tu8 tag_number;\n\tu8 tag_len;\n\tu8 oui[3];\n\tu8 oui_type;\n\tu8 attr[];\n} __packed;\n\nstruct wilc_attr_entry {\n\tu8  attr_type;\n\t__le16 attr_len;\n\tu8 val[];\n} __packed;\n\nstruct wilc_attr_oper_ch {\n\tu8 attr_type;\n\t__le16 attr_len;\n\tu8 country_code[IEEE80211_COUNTRY_STRING_LEN];\n\tu8 op_class;\n\tu8 op_channel;\n} __packed;\n\nstruct wilc_attr_ch_list {\n\tu8 attr_type;\n\t__le16 attr_len;\n\tu8 country_code[IEEE80211_COUNTRY_STRING_LEN];\n\tu8 elem[];\n} __packed;\n\nstruct wilc_ch_list_elem {\n\tu8 op_class;\n\tu8 no_of_channels;\n\tu8 ch_list[];\n} __packed;\n\nstatic void cfg_scan_result(enum scan_event scan_event,\n\t\t\t    struct wilc_rcvd_net_info *info, void *user_void)\n{\n\tstruct wilc_priv *priv = user_void;\n\n\tif (!priv->cfg_scanning)\n\t\treturn;\n\n\tif (scan_event == SCAN_EVENT_NETWORK_FOUND) {\n\t\ts32 freq;\n\t\tstruct ieee80211_channel *channel;\n\t\tstruct cfg80211_bss *bss;\n\t\tstruct wiphy *wiphy = priv->dev->ieee80211_ptr->wiphy;\n\n\t\tif (!wiphy || !info)\n\t\t\treturn;\n\n\t\tfreq = ieee80211_channel_to_frequency((s32)info->ch,\n\t\t\t\t\t\t      NL80211_BAND_2GHZ);\n\t\tchannel = ieee80211_get_channel(wiphy, freq);\n\t\tif (!channel)\n\t\t\treturn;\n\n\t\tbss = cfg80211_inform_bss_frame(wiphy, channel, info->mgmt,\n\t\t\t\t\t\tinfo->frame_len,\n\t\t\t\t\t\t(s32)info->rssi * 100,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tcfg80211_put_bss(wiphy, bss);\n\t} else if (scan_event == SCAN_EVENT_DONE) {\n\t\tmutex_lock(&priv->scan_req_lock);\n\n\t\tif (priv->scan_req) {\n\t\t\tstruct cfg80211_scan_info info = {\n\t\t\t\t.aborted = false,\n\t\t\t};\n\n\t\t\tcfg80211_scan_done(priv->scan_req, &info);\n\t\t\tpriv->cfg_scanning = false;\n\t\t\tpriv->scan_req = NULL;\n\t\t}\n\t\tmutex_unlock(&priv->scan_req_lock);\n\t} else if (scan_event == SCAN_EVENT_ABORTED) {\n\t\tmutex_lock(&priv->scan_req_lock);\n\n\t\tif (priv->scan_req) {\n\t\t\tstruct cfg80211_scan_info info = {\n\t\t\t\t.aborted = false,\n\t\t\t};\n\n\t\t\tcfg80211_scan_done(priv->scan_req, &info);\n\t\t\tpriv->cfg_scanning = false;\n\t\t\tpriv->scan_req = NULL;\n\t\t}\n\t\tmutex_unlock(&priv->scan_req_lock);\n\t}\n}\n\nstatic void cfg_connect_result(enum conn_event conn_disconn_evt, u8 mac_status,\n\t\t\t       void *priv_data)\n{\n\tstruct wilc_priv *priv = priv_data;\n\tstruct net_device *dev = priv->dev;\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc *wl = vif->wilc;\n\tstruct host_if_drv *wfi_drv = priv->hif_drv;\n\tstruct wilc_conn_info *conn_info = &wfi_drv->conn_info;\n\tstruct wiphy *wiphy = dev->ieee80211_ptr->wiphy;\n\n\tvif->connecting = false;\n\n\tif (conn_disconn_evt == CONN_DISCONN_EVENT_CONN_RESP) {\n\t\tu16 connect_status = conn_info->status;\n\n\t\tif (mac_status == WILC_MAC_STATUS_DISCONNECTED &&\n\t\t    connect_status == WLAN_STATUS_SUCCESS) {\n\t\t\tconnect_status = WLAN_STATUS_UNSPECIFIED_FAILURE;\n\t\t\twilc_wlan_set_bssid(priv->dev, NULL, WILC_STATION_MODE);\n\n\t\t\tif (vif->iftype != WILC_CLIENT_MODE)\n\t\t\t\twl->sta_ch = WILC_INVALID_CHANNEL;\n\n\t\t\tnetdev_err(dev, \"Unspecified failure\\n\");\n\t\t}\n\n\t\tif (connect_status == WLAN_STATUS_SUCCESS)\n\t\t\tmemcpy(priv->associated_bss, conn_info->bssid,\n\t\t\t       ETH_ALEN);\n\n\t\tcfg80211_ref_bss(wiphy, vif->bss);\n\t\tcfg80211_connect_bss(dev, conn_info->bssid, vif->bss,\n\t\t\t\t     conn_info->req_ies,\n\t\t\t\t     conn_info->req_ies_len,\n\t\t\t\t     conn_info->resp_ies,\n\t\t\t\t     conn_info->resp_ies_len,\n\t\t\t\t     connect_status, GFP_KERNEL,\n\t\t\t\t     NL80211_TIMEOUT_UNSPECIFIED);\n\n\t\tvif->bss = NULL;\n\t} else if (conn_disconn_evt == CONN_DISCONN_EVENT_DISCONN_NOTIF) {\n\t\tu16 reason = 0;\n\n\t\teth_zero_addr(priv->associated_bss);\n\t\twilc_wlan_set_bssid(priv->dev, NULL, WILC_STATION_MODE);\n\n\t\tif (vif->iftype != WILC_CLIENT_MODE) {\n\t\t\twl->sta_ch = WILC_INVALID_CHANNEL;\n\t\t} else {\n\t\t\tif (wfi_drv->ifc_up)\n\t\t\t\treason = 3;\n\t\t\telse\n\t\t\t\treason = 1;\n\t\t}\n\n\t\tcfg80211_disconnected(dev, reason, NULL, 0, false, GFP_KERNEL);\n\t}\n}\n\nstruct wilc_vif *wilc_get_wl_to_vif(struct wilc *wl)\n{\n\tstruct wilc_vif *vif;\n\n\tvif = list_first_or_null_rcu(&wl->vif_list, typeof(*vif), list);\n\tif (!vif)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn vif;\n}\n\nstatic int set_channel(struct wiphy *wiphy,\n\t\t       struct cfg80211_chan_def *chandef)\n{\n\tstruct wilc *wl = wiphy_priv(wiphy);\n\tstruct wilc_vif *vif;\n\tu32 channelnum;\n\tint result;\n\tint srcu_idx;\n\n\tsrcu_idx = srcu_read_lock(&wl->srcu);\n\tvif = wilc_get_wl_to_vif(wl);\n\tif (IS_ERR(vif)) {\n\t\tsrcu_read_unlock(&wl->srcu, srcu_idx);\n\t\treturn PTR_ERR(vif);\n\t}\n\n\tchannelnum = ieee80211_frequency_to_channel(chandef->chan->center_freq);\n\n\twl->op_ch = channelnum;\n\tresult = wilc_set_mac_chnl_num(vif, channelnum);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Error in setting channel\\n\");\n\n\tsrcu_read_unlock(&wl->srcu, srcu_idx);\n\treturn result;\n}\n\nstatic int scan(struct wiphy *wiphy, struct cfg80211_scan_request *request)\n{\n\tstruct wilc_vif *vif = netdev_priv(request->wdev->netdev);\n\tstruct wilc_priv *priv = &vif->priv;\n\tu32 i;\n\tint ret = 0;\n\tu8 scan_ch_list[WILC_MAX_NUM_SCANNED_CH];\n\tu8 scan_type;\n\n\tif (request->n_channels > WILC_MAX_NUM_SCANNED_CH) {\n\t\tnetdev_err(vif->ndev, \"Requested scanned channels over\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->scan_req = request;\n\tpriv->cfg_scanning = true;\n\tfor (i = 0; i < request->n_channels; i++) {\n\t\tu16 freq = request->channels[i]->center_freq;\n\n\t\tscan_ch_list[i] = ieee80211_frequency_to_channel(freq);\n\t}\n\n\tif (request->n_ssids)\n\t\tscan_type = WILC_FW_ACTIVE_SCAN;\n\telse\n\t\tscan_type = WILC_FW_PASSIVE_SCAN;\n\n\tret = wilc_scan(vif, WILC_FW_USER_SCAN, scan_type, scan_ch_list,\n\t\t\trequest->n_channels, cfg_scan_result, (void *)priv,\n\t\t\trequest);\n\n\tif (ret) {\n\t\tpriv->scan_req = NULL;\n\t\tpriv->cfg_scanning = false;\n\t}\n\n\treturn ret;\n}\n\nstatic int connect(struct wiphy *wiphy, struct net_device *dev,\n\t\t   struct cfg80211_connect_params *sme)\n{\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc_priv *priv = &vif->priv;\n\tstruct host_if_drv *wfi_drv = priv->hif_drv;\n\tint ret;\n\tu32 i;\n\tu8 security = WILC_FW_SEC_NO;\n\tenum mfptype mfp_type = WILC_FW_MFP_NONE;\n\tenum authtype auth_type = WILC_FW_AUTH_ANY;\n\tu32 cipher_group;\n\tstruct cfg80211_bss *bss;\n\tvoid *join_params;\n\tu8 ch;\n\n\tvif->connecting = true;\n\n\tcipher_group = sme->crypto.cipher_group;\n\tif (cipher_group != 0) {\n\t\tif (sme->crypto.wpa_versions & NL80211_WPA_VERSION_2) {\n\t\t\tif (cipher_group == WLAN_CIPHER_SUITE_TKIP)\n\t\t\t\tsecurity = WILC_FW_SEC_WPA2_TKIP;\n\t\t\telse\n\t\t\t\tsecurity = WILC_FW_SEC_WPA2_AES;\n\t\t} else if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_1) {\n\t\t\tif (cipher_group == WLAN_CIPHER_SUITE_TKIP)\n\t\t\t\tsecurity = WILC_FW_SEC_WPA_TKIP;\n\t\t\telse\n\t\t\t\tsecurity = WILC_FW_SEC_WPA_AES;\n\t\t} else {\n\t\t\tret = -ENOTSUPP;\n\t\t\tnetdev_err(dev, \"%s: Unsupported cipher\\n\",\n\t\t\t\t   __func__);\n\t\t\tgoto out_error;\n\t\t}\n\t}\n\n\tif ((sme->crypto.wpa_versions & NL80211_WPA_VERSION_1) ||\n\t    (sme->crypto.wpa_versions & NL80211_WPA_VERSION_2)) {\n\t\tfor (i = 0; i < sme->crypto.n_ciphers_pairwise; i++) {\n\t\t\tu32 ciphers_pairwise = sme->crypto.ciphers_pairwise[i];\n\n\t\t\tif (ciphers_pairwise == WLAN_CIPHER_SUITE_TKIP)\n\t\t\t\tsecurity |= WILC_FW_TKIP;\n\t\t\telse\n\t\t\t\tsecurity |= WILC_FW_AES;\n\t\t}\n\t}\n\n\tswitch (sme->auth_type) {\n\tcase NL80211_AUTHTYPE_OPEN_SYSTEM:\n\t\tauth_type = WILC_FW_AUTH_OPEN_SYSTEM;\n\t\tbreak;\n\n\tcase NL80211_AUTHTYPE_SAE:\n\t\tauth_type = WILC_FW_AUTH_SAE;\n\t\tif (sme->ssid_len) {\n\t\t\tmemcpy(vif->auth.ssid.ssid, sme->ssid, sme->ssid_len);\n\t\t\tvif->auth.ssid.ssid_len = sme->ssid_len;\n\t\t}\n\t\tvif->auth.key_mgmt_suite = cpu_to_be32(sme->crypto.akm_suites[0]);\n\t\tether_addr_copy(vif->auth.bssid, sme->bssid);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (sme->crypto.n_akm_suites) {\n\t\tif (sme->crypto.akm_suites[0] == WLAN_AKM_SUITE_8021X)\n\t\t\tauth_type = WILC_FW_AUTH_IEEE8021;\n\t\telse if (sme->crypto.akm_suites[0] == WLAN_AKM_SUITE_PSK_SHA256)\n\t\t\tauth_type = WILC_FW_AUTH_OPEN_SYSTEM_SHA256;\n\t\telse if (sme->crypto.akm_suites[0] == WLAN_AKM_SUITE_8021X_SHA256)\n\t\t\tauth_type = WILC_FW_AUTH_IEE8021X_SHA256;\n\t}\n\n\tif (wfi_drv->usr_scan_req.scan_result) {\n\t\tnetdev_err(vif->ndev, \"%s: Scan in progress\\n\", __func__);\n\t\tret = -EBUSY;\n\t\tgoto out_error;\n\t}\n\n\tbss = cfg80211_get_bss(wiphy, sme->channel, sme->bssid, sme->ssid,\n\t\t\t       sme->ssid_len, IEEE80211_BSS_TYPE_ANY,\n\t\t\t       IEEE80211_PRIVACY(sme->privacy));\n\tif (!bss) {\n\t\tret = -EINVAL;\n\t\tgoto out_error;\n\t}\n\n\tif (ether_addr_equal_unaligned(vif->bssid, bss->bssid)) {\n\t\tret = -EALREADY;\n\t\tgoto out_put_bss;\n\t}\n\n\tjoin_params = wilc_parse_join_bss_param(bss, &sme->crypto);\n\tif (!join_params) {\n\t\tnetdev_err(dev, \"%s: failed to construct join param\\n\",\n\t\t\t   __func__);\n\t\tret = -EINVAL;\n\t\tgoto out_put_bss;\n\t}\n\n\tch = ieee80211_frequency_to_channel(bss->channel->center_freq);\n\tvif->wilc->op_ch = ch;\n\tif (vif->iftype != WILC_CLIENT_MODE)\n\t\tvif->wilc->sta_ch = ch;\n\n\twilc_wlan_set_bssid(dev, bss->bssid, WILC_STATION_MODE);\n\n\twfi_drv->conn_info.security = security;\n\twfi_drv->conn_info.auth_type = auth_type;\n\twfi_drv->conn_info.ch = ch;\n\twfi_drv->conn_info.conn_result = cfg_connect_result;\n\twfi_drv->conn_info.arg = priv;\n\twfi_drv->conn_info.param = join_params;\n\n\tif (sme->mfp == NL80211_MFP_OPTIONAL)\n\t\tmfp_type = WILC_FW_MFP_OPTIONAL;\n\telse if (sme->mfp == NL80211_MFP_REQUIRED)\n\t\tmfp_type = WILC_FW_MFP_REQUIRED;\n\n\twfi_drv->conn_info.mfp_type = mfp_type;\n\n\tret = wilc_set_join_req(vif, bss->bssid, sme->ie, sme->ie_len);\n\tif (ret) {\n\t\tnetdev_err(dev, \"wilc_set_join_req(): Error\\n\");\n\t\tret = -ENOENT;\n\t\tif (vif->iftype != WILC_CLIENT_MODE)\n\t\t\tvif->wilc->sta_ch = WILC_INVALID_CHANNEL;\n\t\twilc_wlan_set_bssid(dev, NULL, WILC_STATION_MODE);\n\t\twfi_drv->conn_info.conn_result = NULL;\n\t\tkfree(join_params);\n\t\tgoto out_put_bss;\n\t}\n\tkfree(join_params);\n\tvif->bss = bss;\n\tcfg80211_put_bss(wiphy, bss);\n\treturn 0;\n\nout_put_bss:\n\tcfg80211_put_bss(wiphy, bss);\n\nout_error:\n\tvif->connecting = false;\n\treturn ret;\n}\n\nstatic int disconnect(struct wiphy *wiphy, struct net_device *dev,\n\t\t      u16 reason_code)\n{\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc_priv *priv = &vif->priv;\n\tstruct wilc *wilc = vif->wilc;\n\tint ret;\n\n\tvif->connecting = false;\n\n\tif (!wilc)\n\t\treturn -EIO;\n\n\tif (wilc->close) {\n\t\t/* already disconnected done */\n\t\tcfg80211_disconnected(dev, 0, NULL, 0, true, GFP_KERNEL);\n\t\treturn 0;\n\t}\n\n\tif (vif->iftype != WILC_CLIENT_MODE)\n\t\twilc->sta_ch = WILC_INVALID_CHANNEL;\n\twilc_wlan_set_bssid(priv->dev, NULL, WILC_STATION_MODE);\n\n\tpriv->hif_drv->p2p_timeout = 0;\n\n\tret = wilc_disconnect(vif);\n\tif (ret != 0) {\n\t\tnetdev_err(priv->dev, \"Error in disconnecting\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\tvif->bss = NULL;\n\n\treturn ret;\n}\n\nstatic int wilc_wfi_cfg_allocate_wpa_entry(struct wilc_priv *priv, u8 idx)\n{\n\tif (!priv->wilc_gtk[idx]) {\n\t\tpriv->wilc_gtk[idx] = kzalloc(sizeof(*priv->wilc_gtk[idx]),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!priv->wilc_gtk[idx])\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (!priv->wilc_ptk[idx]) {\n\t\tpriv->wilc_ptk[idx] = kzalloc(sizeof(*priv->wilc_ptk[idx]),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!priv->wilc_ptk[idx])\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int wilc_wfi_cfg_allocate_wpa_igtk_entry(struct wilc_priv *priv, u8 idx)\n{\n\tidx -= 4;\n\tif (!priv->wilc_igtk[idx]) {\n\t\tpriv->wilc_igtk[idx] = kzalloc(sizeof(*priv->wilc_igtk[idx]),\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!priv->wilc_igtk[idx])\n\t\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic int wilc_wfi_cfg_copy_wpa_info(struct wilc_wfi_key *key_info,\n\t\t\t\t      struct key_params *params)\n{\n\tkfree(key_info->key);\n\n\tkey_info->key = kmemdup(params->key, params->key_len, GFP_KERNEL);\n\tif (!key_info->key)\n\t\treturn -ENOMEM;\n\n\tkfree(key_info->seq);\n\n\tif (params->seq_len > 0) {\n\t\tkey_info->seq = kmemdup(params->seq, params->seq_len,\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!key_info->seq)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tkey_info->cipher = params->cipher;\n\tkey_info->key_len = params->key_len;\n\tkey_info->seq_len = params->seq_len;\n\n\treturn 0;\n}\n\nstatic int add_key(struct wiphy *wiphy, struct net_device *netdev, int link_id,\n\t\t   u8 key_index, bool pairwise, const u8 *mac_addr,\n\t\t   struct key_params *params)\n\n{\n\tint ret = 0, keylen = params->key_len;\n\tconst u8 *rx_mic = NULL;\n\tconst u8 *tx_mic = NULL;\n\tu8 mode = WILC_FW_SEC_NO;\n\tu8 op_mode;\n\tstruct wilc_vif *vif = netdev_priv(netdev);\n\tstruct wilc_priv *priv = &vif->priv;\n\tstruct wilc_wfi_key *key;\n\n\tswitch (params->cipher) {\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tif (priv->wdev.iftype == NL80211_IFTYPE_AP ||\n\t\t    priv->wdev.iftype == NL80211_IFTYPE_P2P_GO) {\n\t\t\tstruct wilc_wfi_key *key;\n\n\t\t\tret = wilc_wfi_cfg_allocate_wpa_entry(priv, key_index);\n\t\t\tif (ret)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tif (params->key_len > 16 &&\n\t\t\t    params->cipher == WLAN_CIPHER_SUITE_TKIP) {\n\t\t\t\ttx_mic = params->key + 24;\n\t\t\t\trx_mic = params->key + 16;\n\t\t\t\tkeylen = params->key_len - 16;\n\t\t\t}\n\n\t\t\tif (!pairwise) {\n\t\t\t\tif (params->cipher == WLAN_CIPHER_SUITE_TKIP)\n\t\t\t\t\tmode = WILC_FW_SEC_WPA_TKIP;\n\t\t\t\telse\n\t\t\t\t\tmode = WILC_FW_SEC_WPA2_AES;\n\n\t\t\t\tpriv->wilc_groupkey = mode;\n\n\t\t\t\tkey = priv->wilc_gtk[key_index];\n\t\t\t} else {\n\t\t\t\tif (params->cipher == WLAN_CIPHER_SUITE_TKIP)\n\t\t\t\t\tmode = WILC_FW_SEC_WPA_TKIP;\n\t\t\t\telse\n\t\t\t\t\tmode = priv->wilc_groupkey | WILC_FW_AES;\n\n\t\t\t\tkey = priv->wilc_ptk[key_index];\n\t\t\t}\n\t\t\tret = wilc_wfi_cfg_copy_wpa_info(key, params);\n\t\t\tif (ret)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\top_mode = WILC_AP_MODE;\n\t\t} else {\n\t\t\tif (params->key_len > 16 &&\n\t\t\t    params->cipher == WLAN_CIPHER_SUITE_TKIP) {\n\t\t\t\trx_mic = params->key + 24;\n\t\t\t\ttx_mic = params->key + 16;\n\t\t\t\tkeylen = params->key_len - 16;\n\t\t\t}\n\n\t\t\top_mode = WILC_STATION_MODE;\n\t\t}\n\n\t\tif (!pairwise)\n\t\t\tret = wilc_add_rx_gtk(vif, params->key, keylen,\n\t\t\t\t\t      key_index, params->seq_len,\n\t\t\t\t\t      params->seq, rx_mic, tx_mic,\n\t\t\t\t\t      op_mode, mode);\n\t\telse\n\t\t\tret = wilc_add_ptk(vif, params->key, keylen, mac_addr,\n\t\t\t\t\t   rx_mic, tx_mic, op_mode, mode,\n\t\t\t\t\t   key_index);\n\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\tret = wilc_wfi_cfg_allocate_wpa_igtk_entry(priv, key_index);\n\t\tif (ret)\n\t\t\treturn -ENOMEM;\n\n\t\tkey = priv->wilc_igtk[key_index - 4];\n\t\tret = wilc_wfi_cfg_copy_wpa_info(key, params);\n\t\tif (ret)\n\t\t\treturn -ENOMEM;\n\n\t\tif (priv->wdev.iftype == NL80211_IFTYPE_AP ||\n\t\t    priv->wdev.iftype == NL80211_IFTYPE_P2P_GO)\n\t\t\top_mode = WILC_AP_MODE;\n\t\telse\n\t\t\top_mode = WILC_STATION_MODE;\n\n\t\tret = wilc_add_igtk(vif, params->key, keylen, params->seq,\n\t\t\t\t    params->seq_len, mac_addr, op_mode,\n\t\t\t\t    key_index);\n\t\tbreak;\n\n\tdefault:\n\t\tnetdev_err(netdev, \"%s: Unsupported cipher\\n\", __func__);\n\t\tret = -ENOTSUPP;\n\t}\n\n\treturn ret;\n}\n\nstatic int del_key(struct wiphy *wiphy, struct net_device *netdev, int link_id,\n\t\t   u8 key_index,\n\t\t   bool pairwise,\n\t\t   const u8 *mac_addr)\n{\n\tstruct wilc_vif *vif = netdev_priv(netdev);\n\tstruct wilc_priv *priv = &vif->priv;\n\n\tif (!pairwise && (key_index == 4 || key_index == 5)) {\n\t\tkey_index -= 4;\n\t\tif (priv->wilc_igtk[key_index]) {\n\t\t\tkfree(priv->wilc_igtk[key_index]->key);\n\t\t\tpriv->wilc_igtk[key_index]->key = NULL;\n\t\t\tkfree(priv->wilc_igtk[key_index]->seq);\n\t\t\tpriv->wilc_igtk[key_index]->seq = NULL;\n\t\t\tkfree(priv->wilc_igtk[key_index]);\n\t\t\tpriv->wilc_igtk[key_index] = NULL;\n\t\t}\n\t} else {\n\t\tif (priv->wilc_gtk[key_index]) {\n\t\t\tkfree(priv->wilc_gtk[key_index]->key);\n\t\t\tpriv->wilc_gtk[key_index]->key = NULL;\n\t\t\tkfree(priv->wilc_gtk[key_index]->seq);\n\t\t\tpriv->wilc_gtk[key_index]->seq = NULL;\n\n\t\t\tkfree(priv->wilc_gtk[key_index]);\n\t\t\tpriv->wilc_gtk[key_index] = NULL;\n\t\t}\n\t\tif (priv->wilc_ptk[key_index]) {\n\t\t\tkfree(priv->wilc_ptk[key_index]->key);\n\t\t\tpriv->wilc_ptk[key_index]->key = NULL;\n\t\t\tkfree(priv->wilc_ptk[key_index]->seq);\n\t\t\tpriv->wilc_ptk[key_index]->seq = NULL;\n\t\t\tkfree(priv->wilc_ptk[key_index]);\n\t\t\tpriv->wilc_ptk[key_index] = NULL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int get_key(struct wiphy *wiphy, struct net_device *netdev, int link_id,\n\t\t   u8 key_index, bool pairwise, const u8 *mac_addr,\n\t\t   void *cookie,\n\t\t   void (*callback)(void *cookie, struct key_params *))\n{\n\tstruct wilc_vif *vif = netdev_priv(netdev);\n\tstruct wilc_priv *priv = &vif->priv;\n\tstruct  key_params key_params;\n\n\tif (!pairwise) {\n\t\tif (key_index == 4 || key_index == 5) {\n\t\t\tkey_index -= 4;\n\t\t\tkey_params.key = priv->wilc_igtk[key_index]->key;\n\t\t\tkey_params.cipher = priv->wilc_igtk[key_index]->cipher;\n\t\t\tkey_params.key_len = priv->wilc_igtk[key_index]->key_len;\n\t\t\tkey_params.seq = priv->wilc_igtk[key_index]->seq;\n\t\t\tkey_params.seq_len = priv->wilc_igtk[key_index]->seq_len;\n\t\t} else {\n\t\t\tkey_params.key = priv->wilc_gtk[key_index]->key;\n\t\t\tkey_params.cipher = priv->wilc_gtk[key_index]->cipher;\n\t\t\tkey_params.key_len = priv->wilc_gtk[key_index]->key_len;\n\t\t\tkey_params.seq = priv->wilc_gtk[key_index]->seq;\n\t\t\tkey_params.seq_len = priv->wilc_gtk[key_index]->seq_len;\n\t\t}\n\t} else {\n\t\tkey_params.key = priv->wilc_ptk[key_index]->key;\n\t\tkey_params.cipher = priv->wilc_ptk[key_index]->cipher;\n\t\tkey_params.key_len = priv->wilc_ptk[key_index]->key_len;\n\t\tkey_params.seq = priv->wilc_ptk[key_index]->seq;\n\t\tkey_params.seq_len = priv->wilc_ptk[key_index]->seq_len;\n\t}\n\n\tcallback(cookie, &key_params);\n\n\treturn 0;\n}\n\n/* wiphy_new_nm() will WARNON if not present */\nstatic int set_default_key(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t   int link_id, u8 key_index, bool unicast,\n\t\t\t   bool multicast)\n{\n\treturn 0;\n}\n\nstatic int set_default_mgmt_key(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t\tint link_id, u8 key_index)\n{\n\tstruct wilc_vif *vif = netdev_priv(netdev);\n\n\treturn wilc_set_default_mgmt_key_index(vif, key_index);\n}\n\nstatic int get_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t       const u8 *mac, struct station_info *sinfo)\n{\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc_priv *priv = &vif->priv;\n\tstruct wilc *wilc = vif->wilc;\n\tu32 i = 0;\n\tu32 associatedsta = ~0;\n\tu32 inactive_time = 0;\n\n\tif (vif->iftype == WILC_AP_MODE || vif->iftype == WILC_GO_MODE) {\n\t\tfor (i = 0; i < NUM_STA_ASSOCIATED; i++) {\n\t\t\tif (!(memcmp(mac,\n\t\t\t\t     priv->assoc_stainfo.sta_associated_bss[i],\n\t\t\t\t     ETH_ALEN))) {\n\t\t\t\tassociatedsta = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (associatedsta == ~0) {\n\t\t\tnetdev_err(dev, \"sta required is not associated\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_INACTIVE_TIME);\n\n\t\twilc_get_inactive_time(vif, mac, &inactive_time);\n\t\tsinfo->inactive_time = 1000 * inactive_time;\n\t} else if (vif->iftype == WILC_STATION_MODE) {\n\t\tstruct rf_info stats;\n\n\t\tif (!wilc->initialized)\n\t\t\treturn -EBUSY;\n\n\t\twilc_get_statistics(vif, &stats);\n\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL) |\n\t\t\t\t BIT_ULL(NL80211_STA_INFO_RX_PACKETS) |\n\t\t\t\t BIT_ULL(NL80211_STA_INFO_TX_PACKETS) |\n\t\t\t\t BIT_ULL(NL80211_STA_INFO_TX_FAILED) |\n\t\t\t\t BIT_ULL(NL80211_STA_INFO_TX_BITRATE);\n\n\t\tsinfo->signal = stats.rssi;\n\t\tsinfo->rx_packets = stats.rx_cnt;\n\t\tsinfo->tx_packets = stats.tx_cnt + stats.tx_fail_cnt;\n\t\tsinfo->tx_failed = stats.tx_fail_cnt;\n\t\tsinfo->txrate.legacy = stats.link_speed * 10;\n\n\t\tif (stats.link_speed > TCP_ACK_FILTER_LINK_SPEED_THRESH &&\n\t\t    stats.link_speed != DEFAULT_LINK_SPEED)\n\t\t\twilc_enable_tcp_ack_filter(vif, true);\n\t\telse if (stats.link_speed != DEFAULT_LINK_SPEED)\n\t\t\twilc_enable_tcp_ack_filter(vif, false);\n\t}\n\treturn 0;\n}\n\nstatic int change_bss(struct wiphy *wiphy, struct net_device *dev,\n\t\t      struct bss_parameters *params)\n{\n\treturn 0;\n}\n\nstatic int set_wiphy_params(struct wiphy *wiphy, u32 changed)\n{\n\tint ret = -EINVAL;\n\tstruct cfg_param_attr cfg_param_val;\n\tstruct wilc *wl = wiphy_priv(wiphy);\n\tstruct wilc_vif *vif;\n\tstruct wilc_priv *priv;\n\tint srcu_idx;\n\n\tsrcu_idx = srcu_read_lock(&wl->srcu);\n\tvif = wilc_get_wl_to_vif(wl);\n\tif (IS_ERR(vif))\n\t\tgoto out;\n\n\tpriv = &vif->priv;\n\tcfg_param_val.flag = 0;\n\n\tif (changed & WIPHY_PARAM_RETRY_SHORT) {\n\t\tnetdev_dbg(vif->ndev,\n\t\t\t   \"Setting WIPHY_PARAM_RETRY_SHORT %d\\n\",\n\t\t\t   wiphy->retry_short);\n\t\tcfg_param_val.flag  |= WILC_CFG_PARAM_RETRY_SHORT;\n\t\tcfg_param_val.short_retry_limit = wiphy->retry_short;\n\t}\n\tif (changed & WIPHY_PARAM_RETRY_LONG) {\n\t\tnetdev_dbg(vif->ndev,\n\t\t\t   \"Setting WIPHY_PARAM_RETRY_LONG %d\\n\",\n\t\t\t   wiphy->retry_long);\n\t\tcfg_param_val.flag |= WILC_CFG_PARAM_RETRY_LONG;\n\t\tcfg_param_val.long_retry_limit = wiphy->retry_long;\n\t}\n\tif (changed & WIPHY_PARAM_FRAG_THRESHOLD) {\n\t\tif (wiphy->frag_threshold > 255 &&\n\t\t    wiphy->frag_threshold < 7937) {\n\t\t\tnetdev_dbg(vif->ndev,\n\t\t\t\t   \"Setting WIPHY_PARAM_FRAG_THRESHOLD %d\\n\",\n\t\t\t\t   wiphy->frag_threshold);\n\t\t\tcfg_param_val.flag |= WILC_CFG_PARAM_FRAG_THRESHOLD;\n\t\t\tcfg_param_val.frag_threshold = wiphy->frag_threshold;\n\t\t} else {\n\t\t\tnetdev_err(vif->ndev,\n\t\t\t\t   \"Fragmentation threshold out of range\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (changed & WIPHY_PARAM_RTS_THRESHOLD) {\n\t\tif (wiphy->rts_threshold > 255) {\n\t\t\tnetdev_dbg(vif->ndev,\n\t\t\t\t   \"Setting WIPHY_PARAM_RTS_THRESHOLD %d\\n\",\n\t\t\t\t   wiphy->rts_threshold);\n\t\t\tcfg_param_val.flag |= WILC_CFG_PARAM_RTS_THRESHOLD;\n\t\t\tcfg_param_val.rts_threshold = wiphy->rts_threshold;\n\t\t} else {\n\t\t\tnetdev_err(vif->ndev, \"RTS threshold out of range\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = wilc_hif_set_cfg(vif, &cfg_param_val);\n\tif (ret)\n\t\tnetdev_err(priv->dev, \"Error in setting WIPHY PARAMS\\n\");\n\nout:\n\tsrcu_read_unlock(&wl->srcu, srcu_idx);\n\treturn ret;\n}\n\nstatic int set_pmksa(struct wiphy *wiphy, struct net_device *netdev,\n\t\t     struct cfg80211_pmksa *pmksa)\n{\n\tstruct wilc_vif *vif = netdev_priv(netdev);\n\tstruct wilc_priv *priv = &vif->priv;\n\tu32 i;\n\tint ret = 0;\n\tu8 flag = 0;\n\n\tfor (i = 0; i < priv->pmkid_list.numpmkid; i++)\t{\n\t\tif (!memcmp(pmksa->bssid, priv->pmkid_list.pmkidlist[i].bssid,\n\t\t\t    ETH_ALEN)) {\n\t\t\tflag = PMKID_FOUND;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i < WILC_MAX_NUM_PMKIDS) {\n\t\tmemcpy(priv->pmkid_list.pmkidlist[i].bssid, pmksa->bssid,\n\t\t       ETH_ALEN);\n\t\tmemcpy(priv->pmkid_list.pmkidlist[i].pmkid, pmksa->pmkid,\n\t\t       WLAN_PMKID_LEN);\n\t\tif (!(flag == PMKID_FOUND))\n\t\t\tpriv->pmkid_list.numpmkid++;\n\t} else {\n\t\tnetdev_err(netdev, \"Invalid PMKID index\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\tif (!ret)\n\t\tret = wilc_set_pmkid_info(vif, &priv->pmkid_list);\n\n\treturn ret;\n}\n\nstatic int del_pmksa(struct wiphy *wiphy, struct net_device *netdev,\n\t\t     struct cfg80211_pmksa *pmksa)\n{\n\tu32 i;\n\tstruct wilc_vif *vif = netdev_priv(netdev);\n\tstruct wilc_priv *priv = &vif->priv;\n\n\tfor (i = 0; i < priv->pmkid_list.numpmkid; i++)\t{\n\t\tif (!memcmp(pmksa->bssid, priv->pmkid_list.pmkidlist[i].bssid,\n\t\t\t    ETH_ALEN)) {\n\t\t\tmemset(&priv->pmkid_list.pmkidlist[i], 0,\n\t\t\t       sizeof(struct wilc_pmkid));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == priv->pmkid_list.numpmkid)\n\t\treturn -EINVAL;\n\n\tfor (; i < (priv->pmkid_list.numpmkid - 1); i++) {\n\t\tmemcpy(priv->pmkid_list.pmkidlist[i].bssid,\n\t\t       priv->pmkid_list.pmkidlist[i + 1].bssid,\n\t\t       ETH_ALEN);\n\t\tmemcpy(priv->pmkid_list.pmkidlist[i].pmkid,\n\t\t       priv->pmkid_list.pmkidlist[i + 1].pmkid,\n\t\t       WLAN_PMKID_LEN);\n\t}\n\tpriv->pmkid_list.numpmkid--;\n\n\treturn 0;\n}\n\nstatic int flush_pmksa(struct wiphy *wiphy, struct net_device *netdev)\n{\n\tstruct wilc_vif *vif = netdev_priv(netdev);\n\n\tmemset(&vif->priv.pmkid_list, 0, sizeof(struct wilc_pmkid_attr));\n\n\treturn 0;\n}\n\nstatic inline void wilc_wfi_cfg_parse_ch_attr(u8 *buf, u32 len, u8 sta_ch)\n{\n\tstruct wilc_attr_entry *e;\n\tstruct wilc_attr_ch_list *ch_list;\n\tstruct wilc_attr_oper_ch *op_ch;\n\tu32 index = 0;\n\tu8 ch_list_idx = 0;\n\tu8 op_ch_idx = 0;\n\n\tif (sta_ch == WILC_INVALID_CHANNEL)\n\t\treturn;\n\n\twhile (index + sizeof(*e) <= len) {\n\t\tu16 attr_size;\n\n\t\te = (struct wilc_attr_entry *)&buf[index];\n\t\tattr_size = le16_to_cpu(e->attr_len);\n\n\t\tif (index + sizeof(*e) + attr_size > len)\n\t\t\treturn;\n\n\t\tif (e->attr_type == IEEE80211_P2P_ATTR_CHANNEL_LIST)\n\t\t\tch_list_idx = index;\n\t\telse if (e->attr_type == IEEE80211_P2P_ATTR_OPER_CHANNEL &&\n\t\t\t attr_size == (sizeof(struct wilc_attr_oper_ch) - sizeof(*e)))\n\t\t\top_ch_idx = index;\n\n\t\tif (ch_list_idx && op_ch_idx)\n\t\t\tbreak;\n\n\t\tindex += sizeof(*e) + attr_size;\n\t}\n\n\tif (ch_list_idx) {\n\t\tu16 attr_size;\n\t\tstruct wilc_ch_list_elem *e;\n\t\tint i;\n\n\t\tch_list = (struct wilc_attr_ch_list *)&buf[ch_list_idx];\n\t\tattr_size = le16_to_cpu(ch_list->attr_len);\n\t\tfor (i = 0; i < attr_size;) {\n\t\t\te = (struct wilc_ch_list_elem *)(ch_list->elem + i);\n\t\t\tif (e->op_class == WILC_WLAN_OPERATING_CLASS_2_4GHZ) {\n\t\t\t\tmemset(e->ch_list, sta_ch, e->no_of_channels);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti += e->no_of_channels;\n\t\t}\n\t}\n\n\tif (op_ch_idx) {\n\t\top_ch = (struct wilc_attr_oper_ch *)&buf[op_ch_idx];\n\t\top_ch->op_class = WILC_WLAN_OPERATING_CLASS_2_4GHZ;\n\t\top_ch->op_channel = sta_ch;\n\t}\n}\n\nbool wilc_wfi_mgmt_frame_rx(struct wilc_vif *vif, u8 *buff, u32 size)\n{\n\tstruct wilc *wl = vif->wilc;\n\tstruct wilc_priv *priv = &vif->priv;\n\tint freq;\n\n\tfreq = ieee80211_channel_to_frequency(wl->op_ch, NL80211_BAND_2GHZ);\n\n\treturn cfg80211_rx_mgmt(&priv->wdev, freq, 0, buff, size, 0);\n}\n\nvoid wilc_wfi_p2p_rx(struct wilc_vif *vif, u8 *buff, u32 size)\n{\n\tstruct wilc *wl = vif->wilc;\n\tstruct wilc_priv *priv = &vif->priv;\n\tstruct host_if_drv *wfi_drv = priv->hif_drv;\n\tstruct ieee80211_mgmt *mgmt;\n\tstruct wilc_vendor_specific_ie *p;\n\tstruct wilc_p2p_pub_act_frame *d;\n\tint ie_offset = offsetof(struct ieee80211_mgmt, u) + sizeof(*d);\n\tconst u8 *vendor_ie;\n\tu32 header, pkt_offset;\n\ts32 freq;\n\n\theader = get_unaligned_le32(buff - HOST_HDR_OFFSET);\n\tpkt_offset = FIELD_GET(WILC_PKT_HDR_OFFSET_FIELD, header);\n\n\tif (pkt_offset & IS_MANAGMEMENT_CALLBACK) {\n\t\tbool ack = false;\n\t\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)buff;\n\n\t\tif (ieee80211_is_probe_resp(hdr->frame_control) ||\n\t\t    pkt_offset & IS_MGMT_STATUS_SUCCES)\n\t\t\tack = true;\n\n\t\tcfg80211_mgmt_tx_status(&priv->wdev, priv->tx_cookie, buff,\n\t\t\t\t\tsize, ack, GFP_KERNEL);\n\t\treturn;\n\t}\n\n\tfreq = ieee80211_channel_to_frequency(wl->op_ch, NL80211_BAND_2GHZ);\n\n\tmgmt = (struct ieee80211_mgmt *)buff;\n\tif (!ieee80211_is_action(mgmt->frame_control))\n\t\tgoto out_rx_mgmt;\n\n\tif (priv->cfg_scanning &&\n\t    time_after_eq(jiffies, (unsigned long)wfi_drv->p2p_timeout)) {\n\t\tnetdev_dbg(vif->ndev, \"Receiving action wrong ch\\n\");\n\t\treturn;\n\t}\n\n\tif (!ieee80211_is_public_action((struct ieee80211_hdr *)buff, size))\n\t\tgoto out_rx_mgmt;\n\n\td = (struct wilc_p2p_pub_act_frame *)(&mgmt->u.action);\n\tif (d->oui_subtype != GO_NEG_REQ && d->oui_subtype != GO_NEG_RSP &&\n\t    d->oui_subtype != P2P_INV_REQ && d->oui_subtype != P2P_INV_RSP)\n\t\tgoto out_rx_mgmt;\n\n\tvendor_ie = cfg80211_find_vendor_ie(WLAN_OUI_WFA, WLAN_OUI_TYPE_WFA_P2P,\n\t\t\t\t\t    buff + ie_offset, size - ie_offset);\n\tif (!vendor_ie)\n\t\tgoto out_rx_mgmt;\n\n\tp = (struct wilc_vendor_specific_ie *)vendor_ie;\n\twilc_wfi_cfg_parse_ch_attr(p->attr, p->tag_len - 4, vif->wilc->sta_ch);\n\nout_rx_mgmt:\n\tcfg80211_rx_mgmt(&priv->wdev, freq, 0, buff, size, 0);\n}\n\nstatic void wilc_wfi_mgmt_tx_complete(void *priv, int status)\n{\n\tstruct wilc_p2p_mgmt_data *pv_data = priv;\n\n\tkfree(pv_data->buff);\n\tkfree(pv_data);\n}\n\nstatic void wilc_wfi_remain_on_channel_expired(void *data, u64 cookie)\n{\n\tstruct wilc_vif *vif = data;\n\tstruct wilc_priv *priv = &vif->priv;\n\tstruct wilc_wfi_p2p_listen_params *params = &priv->remain_on_ch_params;\n\n\tif (cookie != params->listen_cookie)\n\t\treturn;\n\n\tpriv->p2p_listen_state = false;\n\n\tcfg80211_remain_on_channel_expired(&priv->wdev, params->listen_cookie,\n\t\t\t\t\t   params->listen_ch, GFP_KERNEL);\n}\n\nstatic int remain_on_channel(struct wiphy *wiphy,\n\t\t\t     struct wireless_dev *wdev,\n\t\t\t     struct ieee80211_channel *chan,\n\t\t\t     unsigned int duration, u64 *cookie)\n{\n\tint ret = 0;\n\tstruct wilc_vif *vif = netdev_priv(wdev->netdev);\n\tstruct wilc_priv *priv = &vif->priv;\n\tu64 id;\n\n\tif (wdev->iftype == NL80211_IFTYPE_AP) {\n\t\tnetdev_dbg(vif->ndev, \"Required while in AP mode\\n\");\n\t\treturn ret;\n\t}\n\n\tid = ++priv->inc_roc_cookie;\n\tif (id == 0)\n\t\tid = ++priv->inc_roc_cookie;\n\n\tret = wilc_remain_on_channel(vif, id, duration, chan->hw_value,\n\t\t\t\t     wilc_wfi_remain_on_channel_expired,\n\t\t\t\t     (void *)vif);\n\tif (ret)\n\t\treturn ret;\n\n\tvif->wilc->op_ch = chan->hw_value;\n\n\tpriv->remain_on_ch_params.listen_ch = chan;\n\tpriv->remain_on_ch_params.listen_cookie = id;\n\t*cookie = id;\n\tpriv->p2p_listen_state = true;\n\tpriv->remain_on_ch_params.listen_duration = duration;\n\n\tcfg80211_ready_on_channel(wdev, *cookie, chan, duration, GFP_KERNEL);\n\tmod_timer(&vif->hif_drv->remain_on_ch_timer,\n\t\t  jiffies + msecs_to_jiffies(duration + 1000));\n\n\treturn ret;\n}\n\nstatic int cancel_remain_on_channel(struct wiphy *wiphy,\n\t\t\t\t    struct wireless_dev *wdev,\n\t\t\t\t    u64 cookie)\n{\n\tstruct wilc_vif *vif = netdev_priv(wdev->netdev);\n\tstruct wilc_priv *priv = &vif->priv;\n\n\tif (cookie != priv->remain_on_ch_params.listen_cookie)\n\t\treturn -ENOENT;\n\n\treturn wilc_listen_state_expired(vif, cookie);\n}\n\nstatic int mgmt_tx(struct wiphy *wiphy,\n\t\t   struct wireless_dev *wdev,\n\t\t   struct cfg80211_mgmt_tx_params *params,\n\t\t   u64 *cookie)\n{\n\tstruct ieee80211_channel *chan = params->chan;\n\tunsigned int wait = params->wait;\n\tconst u8 *buf = params->buf;\n\tsize_t len = params->len;\n\tconst struct ieee80211_mgmt *mgmt;\n\tstruct wilc_p2p_mgmt_data *mgmt_tx;\n\tstruct wilc_vif *vif = netdev_priv(wdev->netdev);\n\tstruct wilc_priv *priv = &vif->priv;\n\tstruct host_if_drv *wfi_drv = priv->hif_drv;\n\tstruct wilc_vendor_specific_ie *p;\n\tstruct wilc_p2p_pub_act_frame *d;\n\tint ie_offset = offsetof(struct ieee80211_mgmt, u) + sizeof(*d);\n\tconst u8 *vendor_ie;\n\tint ret = 0;\n\n\t*cookie = get_random_u32();\n\tpriv->tx_cookie = *cookie;\n\tmgmt = (const struct ieee80211_mgmt *)buf;\n\n\tif (!ieee80211_is_mgmt(mgmt->frame_control))\n\t\tgoto out;\n\n\tmgmt_tx = kmalloc(sizeof(*mgmt_tx), GFP_KERNEL);\n\tif (!mgmt_tx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmgmt_tx->buff = kmemdup(buf, len, GFP_KERNEL);\n\tif (!mgmt_tx->buff) {\n\t\tret = -ENOMEM;\n\t\tkfree(mgmt_tx);\n\t\tgoto out;\n\t}\n\n\tmgmt_tx->size = len;\n\n\tif (ieee80211_is_probe_resp(mgmt->frame_control)) {\n\t\twilc_set_mac_chnl_num(vif, chan->hw_value);\n\t\tvif->wilc->op_ch = chan->hw_value;\n\t\tgoto out_txq_add_pkt;\n\t}\n\n\tif (!ieee80211_is_public_action((struct ieee80211_hdr *)buf, len)) {\n\t\tif (chan)\n\t\t\twilc_set_mac_chnl_num(vif, chan->hw_value);\n\t\telse\n\t\t\twilc_set_mac_chnl_num(vif, vif->wilc->op_ch);\n\n\t\tgoto out_set_timeout;\n\t}\n\n\td = (struct wilc_p2p_pub_act_frame *)(&mgmt->u.action);\n\tif (d->oui_type != WLAN_OUI_TYPE_WFA_P2P ||\n\t    d->oui_subtype != GO_NEG_CONF) {\n\t\twilc_set_mac_chnl_num(vif, chan->hw_value);\n\t\tvif->wilc->op_ch = chan->hw_value;\n\t}\n\n\tif (d->oui_subtype != P2P_INV_REQ && d->oui_subtype != P2P_INV_RSP)\n\t\tgoto out_set_timeout;\n\n\tvendor_ie = cfg80211_find_vendor_ie(WLAN_OUI_WFA, WLAN_OUI_TYPE_WFA_P2P,\n\t\t\t\t\t    mgmt_tx->buff + ie_offset,\n\t\t\t\t\t    len - ie_offset);\n\tif (!vendor_ie)\n\t\tgoto out_set_timeout;\n\n\tp = (struct wilc_vendor_specific_ie *)vendor_ie;\n\twilc_wfi_cfg_parse_ch_attr(p->attr, p->tag_len - 4, vif->wilc->sta_ch);\n\nout_set_timeout:\n\twfi_drv->p2p_timeout = (jiffies + msecs_to_jiffies(wait));\n\nout_txq_add_pkt:\n\n\twilc_wlan_txq_add_mgmt_pkt(wdev->netdev, mgmt_tx,\n\t\t\t\t   mgmt_tx->buff, mgmt_tx->size,\n\t\t\t\t   wilc_wfi_mgmt_tx_complete);\n\nout:\n\n\treturn ret;\n}\n\nstatic int mgmt_tx_cancel_wait(struct wiphy *wiphy,\n\t\t\t       struct wireless_dev *wdev,\n\t\t\t       u64 cookie)\n{\n\tstruct wilc_vif *vif = netdev_priv(wdev->netdev);\n\tstruct wilc_priv *priv = &vif->priv;\n\tstruct host_if_drv *wfi_drv = priv->hif_drv;\n\n\twfi_drv->p2p_timeout = jiffies;\n\n\tif (!priv->p2p_listen_state) {\n\t\tstruct wilc_wfi_p2p_listen_params *params;\n\n\t\tparams = &priv->remain_on_ch_params;\n\n\t\tcfg80211_remain_on_channel_expired(wdev,\n\t\t\t\t\t\t   params->listen_cookie,\n\t\t\t\t\t\t   params->listen_ch,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t}\n\n\treturn 0;\n}\n\nvoid wilc_update_mgmt_frame_registrations(struct wiphy *wiphy,\n\t\t\t\t\t  struct wireless_dev *wdev,\n\t\t\t\t\t  struct mgmt_frame_regs *upd)\n{\n\tstruct wilc *wl = wiphy_priv(wiphy);\n\tstruct wilc_vif *vif = netdev_priv(wdev->netdev);\n\tu32 presp_bit = BIT(IEEE80211_STYPE_PROBE_REQ >> 4);\n\tu32 action_bit = BIT(IEEE80211_STYPE_ACTION >> 4);\n\tu32 pauth_bit = BIT(IEEE80211_STYPE_AUTH >> 4);\n\n\tif (wl->initialized) {\n\t\tbool prev = vif->mgmt_reg_stypes & presp_bit;\n\t\tbool now = upd->interface_stypes & presp_bit;\n\n\t\tif (now != prev)\n\t\t\twilc_frame_register(vif, IEEE80211_STYPE_PROBE_REQ, now);\n\n\t\tprev = vif->mgmt_reg_stypes & action_bit;\n\t\tnow = upd->interface_stypes & action_bit;\n\n\t\tif (now != prev)\n\t\t\twilc_frame_register(vif, IEEE80211_STYPE_ACTION, now);\n\n\t\tprev = vif->mgmt_reg_stypes & pauth_bit;\n\t\tnow = upd->interface_stypes & pauth_bit;\n\t\tif (now != prev)\n\t\t\twilc_frame_register(vif, IEEE80211_STYPE_AUTH, now);\n\t}\n\n\tvif->mgmt_reg_stypes =\n\t\tupd->interface_stypes & (presp_bit | action_bit | pauth_bit);\n}\n\nstatic int external_auth(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t struct cfg80211_external_auth_params *auth)\n{\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\n\tif (auth->status == WLAN_STATUS_SUCCESS)\n\t\twilc_set_external_auth_param(vif, auth);\n\n\treturn 0;\n}\n\nstatic int set_cqm_rssi_config(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t       s32 rssi_thold, u32 rssi_hyst)\n{\n\treturn 0;\n}\n\nstatic int dump_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t\tint idx, u8 *mac, struct station_info *sinfo)\n{\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tint ret;\n\n\tif (idx != 0)\n\t\treturn -ENOENT;\n\n\tret = wilc_get_rssi(vif, &sinfo->signal);\n\tif (ret)\n\t\treturn ret;\n\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL);\n\tmemcpy(mac, vif->priv.associated_bss, ETH_ALEN);\n\treturn 0;\n}\n\nstatic int set_power_mgmt(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t  bool enabled, int timeout)\n{\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc_priv *priv = &vif->priv;\n\n\tif (!priv->hif_drv)\n\t\treturn -EIO;\n\n\twilc_set_power_mgmt(vif, enabled, timeout);\n\n\treturn 0;\n}\n\nstatic int change_virtual_intf(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t       enum nl80211_iftype type,\n\t\t\t       struct vif_params *params)\n{\n\tstruct wilc *wl = wiphy_priv(wiphy);\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc_priv *priv = &vif->priv;\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tvif->connecting = false;\n\t\tdev->ieee80211_ptr->iftype = type;\n\t\tpriv->wdev.iftype = type;\n\t\tvif->monitor_flag = 0;\n\t\tif (vif->iftype == WILC_AP_MODE || vif->iftype == WILC_GO_MODE)\n\t\t\twilc_wfi_deinit_mon_interface(wl, true);\n\t\tvif->iftype = WILC_STATION_MODE;\n\n\t\tif (wl->initialized)\n\t\t\twilc_set_operation_mode(vif, wilc_get_vif_idx(vif),\n\t\t\t\t\t\tWILC_STATION_MODE, vif->idx);\n\n\t\tmemset(priv->assoc_stainfo.sta_associated_bss, 0,\n\t\t       WILC_MAX_NUM_STA * ETH_ALEN);\n\t\tbreak;\n\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tvif->connecting = false;\n\t\tdev->ieee80211_ptr->iftype = type;\n\t\tpriv->wdev.iftype = type;\n\t\tvif->monitor_flag = 0;\n\t\tvif->iftype = WILC_CLIENT_MODE;\n\n\t\tif (wl->initialized)\n\t\t\twilc_set_operation_mode(vif, wilc_get_vif_idx(vif),\n\t\t\t\t\t\tWILC_STATION_MODE, vif->idx);\n\t\tbreak;\n\n\tcase NL80211_IFTYPE_AP:\n\t\tdev->ieee80211_ptr->iftype = type;\n\t\tpriv->wdev.iftype = type;\n\t\tvif->iftype = WILC_AP_MODE;\n\n\t\tif (wl->initialized)\n\t\t\twilc_set_operation_mode(vif, wilc_get_vif_idx(vif),\n\t\t\t\t\t\tWILC_AP_MODE, vif->idx);\n\t\tbreak;\n\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tdev->ieee80211_ptr->iftype = type;\n\t\tpriv->wdev.iftype = type;\n\t\tvif->iftype = WILC_GO_MODE;\n\n\t\tif (wl->initialized)\n\t\t\twilc_set_operation_mode(vif, wilc_get_vif_idx(vif),\n\t\t\t\t\t\tWILC_AP_MODE, vif->idx);\n\t\tbreak;\n\n\tdefault:\n\t\tnetdev_err(dev, \"Unknown interface type= %d\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int start_ap(struct wiphy *wiphy, struct net_device *dev,\n\t\t    struct cfg80211_ap_settings *settings)\n{\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tint ret;\n\n\tret = set_channel(wiphy, &settings->chandef);\n\tif (ret != 0)\n\t\tnetdev_err(dev, \"Error in setting channel\\n\");\n\n\twilc_wlan_set_bssid(dev, dev->dev_addr, WILC_AP_MODE);\n\n\treturn wilc_add_beacon(vif, settings->beacon_interval,\n\t\t\t\t   settings->dtim_period, &settings->beacon);\n}\n\nstatic int change_beacon(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t struct cfg80211_beacon_data *beacon)\n{\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\n\treturn wilc_add_beacon(vif, 0, 0, beacon);\n}\n\nstatic int stop_ap(struct wiphy *wiphy, struct net_device *dev,\n\t\t   unsigned int link_id)\n{\n\tint ret;\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\n\twilc_wlan_set_bssid(dev, NULL, WILC_AP_MODE);\n\n\tret = wilc_del_beacon(vif);\n\n\tif (ret)\n\t\tnetdev_err(dev, \"Host delete beacon fail\\n\");\n\n\treturn ret;\n}\n\nstatic int add_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t       const u8 *mac, struct station_parameters *params)\n{\n\tint ret = 0;\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc_priv *priv = &vif->priv;\n\n\tif (vif->iftype == WILC_AP_MODE || vif->iftype == WILC_GO_MODE) {\n\t\tmemcpy(priv->assoc_stainfo.sta_associated_bss[params->aid], mac,\n\t\t       ETH_ALEN);\n\n\t\tret = wilc_add_station(vif, mac, params);\n\t\tif (ret)\n\t\t\tnetdev_err(dev, \"Host add station fail\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic int del_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t       struct station_del_parameters *params)\n{\n\tconst u8 *mac = params->mac;\n\tint ret = 0;\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc_priv *priv = &vif->priv;\n\tstruct sta_info *info;\n\n\tif (!(vif->iftype == WILC_AP_MODE || vif->iftype == WILC_GO_MODE))\n\t\treturn ret;\n\n\tinfo = &priv->assoc_stainfo;\n\n\tif (!mac)\n\t\tret = wilc_del_allstation(vif, info->sta_associated_bss);\n\n\tret = wilc_del_station(vif, mac);\n\tif (ret)\n\t\tnetdev_err(dev, \"Host delete station fail\\n\");\n\treturn ret;\n}\n\nstatic int change_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t  const u8 *mac, struct station_parameters *params)\n{\n\tint ret = 0;\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\n\tif (vif->iftype == WILC_AP_MODE || vif->iftype == WILC_GO_MODE) {\n\t\tret = wilc_edit_station(vif, mac, params);\n\t\tif (ret)\n\t\t\tnetdev_err(dev, \"Host edit station fail\\n\");\n\t}\n\treturn ret;\n}\n\nstatic struct wilc_vif *wilc_get_vif_from_type(struct wilc *wl, int type)\n{\n\tstruct wilc_vif *vif;\n\n\tlist_for_each_entry_rcu(vif, &wl->vif_list, list) {\n\t\tif (vif->iftype == type)\n\t\t\treturn vif;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct wireless_dev *add_virtual_intf(struct wiphy *wiphy,\n\t\t\t\t\t     const char *name,\n\t\t\t\t\t     unsigned char name_assign_type,\n\t\t\t\t\t     enum nl80211_iftype type,\n\t\t\t\t\t     struct vif_params *params)\n{\n\tstruct wilc *wl = wiphy_priv(wiphy);\n\tstruct wilc_vif *vif;\n\tstruct wireless_dev *wdev;\n\tint iftype;\n\n\tif (type == NL80211_IFTYPE_MONITOR) {\n\t\tstruct net_device *ndev;\n\t\tint srcu_idx;\n\n\t\tsrcu_idx = srcu_read_lock(&wl->srcu);\n\t\tvif = wilc_get_vif_from_type(wl, WILC_AP_MODE);\n\t\tif (!vif) {\n\t\t\tvif = wilc_get_vif_from_type(wl, WILC_GO_MODE);\n\t\t\tif (!vif) {\n\t\t\t\tsrcu_read_unlock(&wl->srcu, srcu_idx);\n\t\t\t\tgoto validate_interface;\n\t\t\t}\n\t\t}\n\n\t\tif (vif->monitor_flag) {\n\t\t\tsrcu_read_unlock(&wl->srcu, srcu_idx);\n\t\t\tgoto validate_interface;\n\t\t}\n\n\t\tndev = wilc_wfi_init_mon_interface(wl, name, vif->ndev);\n\t\tif (ndev) {\n\t\t\tvif->monitor_flag = 1;\n\t\t} else {\n\t\t\tsrcu_read_unlock(&wl->srcu, srcu_idx);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\n\t\twdev = &vif->priv.wdev;\n\t\tsrcu_read_unlock(&wl->srcu, srcu_idx);\n\t\treturn wdev;\n\t}\n\nvalidate_interface:\n\tmutex_lock(&wl->vif_mutex);\n\tif (wl->vif_num == WILC_NUM_CONCURRENT_IFC) {\n\t\tpr_err(\"Reached maximum number of interface\\n\");\n\t\tmutex_unlock(&wl->vif_mutex);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tmutex_unlock(&wl->vif_mutex);\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tiftype = WILC_STATION_MODE;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tiftype = WILC_AP_MODE;\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\n\tvif = wilc_netdev_ifc_init(wl, name, iftype, type, true);\n\tif (IS_ERR(vif))\n\t\treturn ERR_CAST(vif);\n\n\treturn &vif->priv.wdev;\n}\n\nstatic int del_virtual_intf(struct wiphy *wiphy, struct wireless_dev *wdev)\n{\n\tstruct wilc *wl = wiphy_priv(wiphy);\n\tstruct wilc_vif *vif;\n\n\tif (wdev->iftype == NL80211_IFTYPE_AP ||\n\t    wdev->iftype == NL80211_IFTYPE_P2P_GO)\n\t\twilc_wfi_deinit_mon_interface(wl, true);\n\tvif = netdev_priv(wdev->netdev);\n\tcfg80211_stop_iface(wiphy, wdev, GFP_KERNEL);\n\tcfg80211_unregister_netdevice(vif->ndev);\n\tvif->monitor_flag = 0;\n\n\twilc_set_operation_mode(vif, 0, 0, 0);\n\tmutex_lock(&wl->vif_mutex);\n\tlist_del_rcu(&vif->list);\n\twl->vif_num--;\n\tmutex_unlock(&wl->vif_mutex);\n\tsynchronize_srcu(&wl->srcu);\n\treturn 0;\n}\n\nstatic int wilc_suspend(struct wiphy *wiphy, struct cfg80211_wowlan *wow)\n{\n\tstruct wilc *wl = wiphy_priv(wiphy);\n\n\tif (!wow && wilc_wlan_get_num_conn_ifcs(wl))\n\t\twl->suspend_event = true;\n\telse\n\t\twl->suspend_event = false;\n\n\treturn 0;\n}\n\nstatic int wilc_resume(struct wiphy *wiphy)\n{\n\treturn 0;\n}\n\nstatic void wilc_set_wakeup(struct wiphy *wiphy, bool enabled)\n{\n\tstruct wilc *wl = wiphy_priv(wiphy);\n\tstruct wilc_vif *vif;\n\tint srcu_idx;\n\n\tsrcu_idx = srcu_read_lock(&wl->srcu);\n\tvif = wilc_get_wl_to_vif(wl);\n\tif (IS_ERR(vif)) {\n\t\tsrcu_read_unlock(&wl->srcu, srcu_idx);\n\t\treturn;\n\t}\n\n\tnetdev_info(vif->ndev, \"cfg set wake up = %d\\n\", enabled);\n\twilc_set_wowlan_trigger(vif, enabled);\n\tsrcu_read_unlock(&wl->srcu, srcu_idx);\n}\n\nstatic int set_tx_power(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\tenum nl80211_tx_power_setting type, int mbm)\n{\n\tint ret;\n\tint srcu_idx;\n\ts32 tx_power = MBM_TO_DBM(mbm);\n\tstruct wilc *wl = wiphy_priv(wiphy);\n\tstruct wilc_vif *vif;\n\n\tif (!wl->initialized)\n\t\treturn -EIO;\n\n\tsrcu_idx = srcu_read_lock(&wl->srcu);\n\tvif = wilc_get_wl_to_vif(wl);\n\tif (IS_ERR(vif)) {\n\t\tsrcu_read_unlock(&wl->srcu, srcu_idx);\n\t\treturn -EINVAL;\n\t}\n\n\tnetdev_info(vif->ndev, \"Setting tx power %d\\n\", tx_power);\n\tif (tx_power < 0)\n\t\ttx_power = 0;\n\telse if (tx_power > 18)\n\t\ttx_power = 18;\n\tret = wilc_set_tx_power(vif, tx_power);\n\tif (ret)\n\t\tnetdev_err(vif->ndev, \"Failed to set tx power\\n\");\n\tsrcu_read_unlock(&wl->srcu, srcu_idx);\n\n\treturn ret;\n}\n\nstatic int get_tx_power(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\tint *dbm)\n{\n\tint ret;\n\tstruct wilc_vif *vif = netdev_priv(wdev->netdev);\n\tstruct wilc *wl = vif->wilc;\n\n\t/* If firmware is not started, return. */\n\tif (!wl->initialized)\n\t\treturn -EIO;\n\n\tret = wilc_get_tx_power(vif, (u8 *)dbm);\n\tif (ret)\n\t\tnetdev_err(vif->ndev, \"Failed to get tx power\\n\");\n\n\treturn ret;\n}\n\nstatic const struct cfg80211_ops wilc_cfg80211_ops = {\n\t.set_monitor_channel = set_channel,\n\t.scan = scan,\n\t.connect = connect,\n\t.disconnect = disconnect,\n\t.add_key = add_key,\n\t.del_key = del_key,\n\t.get_key = get_key,\n\t.set_default_key = set_default_key,\n\t.set_default_mgmt_key = set_default_mgmt_key,\n\t.add_virtual_intf = add_virtual_intf,\n\t.del_virtual_intf = del_virtual_intf,\n\t.change_virtual_intf = change_virtual_intf,\n\n\t.start_ap = start_ap,\n\t.change_beacon = change_beacon,\n\t.stop_ap = stop_ap,\n\t.add_station = add_station,\n\t.del_station = del_station,\n\t.change_station = change_station,\n\t.get_station = get_station,\n\t.dump_station = dump_station,\n\t.change_bss = change_bss,\n\t.set_wiphy_params = set_wiphy_params,\n\n\t.external_auth = external_auth,\n\t.set_pmksa = set_pmksa,\n\t.del_pmksa = del_pmksa,\n\t.flush_pmksa = flush_pmksa,\n\t.remain_on_channel = remain_on_channel,\n\t.cancel_remain_on_channel = cancel_remain_on_channel,\n\t.mgmt_tx_cancel_wait = mgmt_tx_cancel_wait,\n\t.mgmt_tx = mgmt_tx,\n\t.update_mgmt_frame_registrations = wilc_update_mgmt_frame_registrations,\n\t.set_power_mgmt = set_power_mgmt,\n\t.set_cqm_rssi_config = set_cqm_rssi_config,\n\n\t.suspend = wilc_suspend,\n\t.resume = wilc_resume,\n\t.set_wakeup = wilc_set_wakeup,\n\t.set_tx_power = set_tx_power,\n\t.get_tx_power = get_tx_power,\n\n};\n\nstatic void wlan_init_locks(struct wilc *wl)\n{\n\tmutex_init(&wl->hif_cs);\n\tmutex_init(&wl->rxq_cs);\n\tmutex_init(&wl->cfg_cmd_lock);\n\tmutex_init(&wl->vif_mutex);\n\tmutex_init(&wl->deinit_lock);\n\n\tspin_lock_init(&wl->txq_spinlock);\n\tmutex_init(&wl->txq_add_to_head_cs);\n\n\tinit_completion(&wl->txq_event);\n\tinit_completion(&wl->cfg_event);\n\tinit_completion(&wl->sync_event);\n\tinit_completion(&wl->txq_thread_started);\n\tinit_srcu_struct(&wl->srcu);\n}\n\nvoid wlan_deinit_locks(struct wilc *wilc)\n{\n\tmutex_destroy(&wilc->hif_cs);\n\tmutex_destroy(&wilc->rxq_cs);\n\tmutex_destroy(&wilc->cfg_cmd_lock);\n\tmutex_destroy(&wilc->txq_add_to_head_cs);\n\tmutex_destroy(&wilc->vif_mutex);\n\tmutex_destroy(&wilc->deinit_lock);\n\tcleanup_srcu_struct(&wilc->srcu);\n}\n\nint wilc_cfg80211_init(struct wilc **wilc, struct device *dev, int io_type,\n\t\t       const struct wilc_hif_func *ops)\n{\n\tstruct wilc *wl;\n\tstruct wilc_vif *vif;\n\tint ret, i;\n\n\twl = wilc_create_wiphy(dev);\n\tif (!wl)\n\t\treturn -EINVAL;\n\n\twlan_init_locks(wl);\n\n\tret = wilc_wlan_cfg_init(wl);\n\tif (ret)\n\t\tgoto free_wl;\n\n\t*wilc = wl;\n\twl->io_type = io_type;\n\twl->hif_func = ops;\n\n\tfor (i = 0; i < NQUEUES; i++)\n\t\tINIT_LIST_HEAD(&wl->txq[i].txq_head.list);\n\n\tINIT_LIST_HEAD(&wl->rxq_head.list);\n\tINIT_LIST_HEAD(&wl->vif_list);\n\n\tvif = wilc_netdev_ifc_init(wl, \"wlan%d\", WILC_STATION_MODE,\n\t\t\t\t   NL80211_IFTYPE_STATION, false);\n\tif (IS_ERR(vif)) {\n\t\tret = PTR_ERR(vif);\n\t\tgoto free_cfg;\n\t}\n\n\treturn 0;\n\nfree_cfg:\n\twilc_wlan_cfg_deinit(wl);\n\nfree_wl:\n\twlan_deinit_locks(wl);\n\twiphy_unregister(wl->wiphy);\n\twiphy_free(wl->wiphy);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wilc_cfg80211_init);\n\nstruct wilc *wilc_create_wiphy(struct device *dev)\n{\n\tstruct wiphy *wiphy;\n\tstruct wilc *wl;\n\tint ret;\n\n\twiphy = wiphy_new(&wilc_cfg80211_ops, sizeof(*wl));\n\tif (!wiphy)\n\t\treturn NULL;\n\n\twl = wiphy_priv(wiphy);\n\n\tmemcpy(wl->bitrates, wilc_bitrates, sizeof(wilc_bitrates));\n\tmemcpy(wl->channels, wilc_2ghz_channels, sizeof(wilc_2ghz_channels));\n\twl->band.bitrates = wl->bitrates;\n\twl->band.n_bitrates = ARRAY_SIZE(wl->bitrates);\n\twl->band.channels = wl->channels;\n\twl->band.n_channels = ARRAY_SIZE(wilc_2ghz_channels);\n\n\twl->band.ht_cap.ht_supported = 1;\n\twl->band.ht_cap.cap |= (1 << IEEE80211_HT_CAP_RX_STBC_SHIFT);\n\twl->band.ht_cap.mcs.rx_mask[0] = 0xff;\n\twl->band.ht_cap.ampdu_factor = IEEE80211_HT_MAX_AMPDU_8K;\n\twl->band.ht_cap.ampdu_density = IEEE80211_HT_MPDU_DENSITY_NONE;\n\n\twiphy->bands[NL80211_BAND_2GHZ] = &wl->band;\n\n\twiphy->max_scan_ssids = WILC_MAX_NUM_PROBED_SSID;\n#ifdef CONFIG_PM\n\twiphy->wowlan = &wowlan_support;\n#endif\n\twiphy->max_num_pmkids = WILC_MAX_NUM_PMKIDS;\n\twiphy->max_scan_ie_len = 1000;\n\twiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;\n\tmemcpy(wl->cipher_suites, wilc_cipher_suites,\n\t       sizeof(wilc_cipher_suites));\n\twiphy->cipher_suites = wl->cipher_suites;\n\twiphy->n_cipher_suites = ARRAY_SIZE(wilc_cipher_suites);\n\twiphy->mgmt_stypes = wilc_wfi_cfg80211_mgmt_types;\n\n\twiphy->max_remain_on_channel_duration = 500;\n\twiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\tBIT(NL80211_IFTYPE_AP) |\n\t\t\t\tBIT(NL80211_IFTYPE_MONITOR) |\n\t\t\t\tBIT(NL80211_IFTYPE_P2P_GO) |\n\t\t\t\tBIT(NL80211_IFTYPE_P2P_CLIENT);\n\twiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;\n\twiphy->features |= NL80211_FEATURE_SAE;\n\tset_wiphy_dev(wiphy, dev);\n\twl->wiphy = wiphy;\n\tret = wiphy_register(wiphy);\n\tif (ret) {\n\t\twiphy_free(wiphy);\n\t\treturn NULL;\n\t}\n\treturn wl;\n}\n\nint wilc_init_host_int(struct net_device *net)\n{\n\tint ret;\n\tstruct wilc_vif *vif = netdev_priv(net);\n\tstruct wilc_priv *priv = &vif->priv;\n\n\tpriv->p2p_listen_state = false;\n\n\tmutex_init(&priv->scan_req_lock);\n\tret = wilc_init(net, &priv->hif_drv);\n\tif (ret)\n\t\tnetdev_err(net, \"Error while initializing hostinterface\\n\");\n\n\treturn ret;\n}\n\nvoid wilc_deinit_host_int(struct net_device *net)\n{\n\tint ret;\n\tstruct wilc_vif *vif = netdev_priv(net);\n\tstruct wilc_priv *priv = &vif->priv;\n\n\tpriv->p2p_listen_state = false;\n\n\tflush_workqueue(vif->wilc->hif_workqueue);\n\tmutex_destroy(&priv->scan_req_lock);\n\tret = wilc_deinit(vif);\n\n\tif (ret)\n\t\tnetdev_err(net, \"Error while deinitializing host interface\\n\");\n}\n\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.\n * All rights reserved.\n */\n\n#include \"cfg80211.h\"\n\n#define GO_NEG_REQ\t\t\t0x00\n#define GO_NEG_RSP\t\t\t0x01\n#define GO_NEG_CONF\t\t\t0x02\n#define P2P_INV_REQ\t\t\t0x03\n#define P2P_INV_RSP\t\t\t0x04\n\n#define WILC_INVALID_CHANNEL\t\t0\n\n/* Operation at 2.4 GHz with channels 1-13 */\n#define WILC_WLAN_OPERATING_CLASS_2_4GHZ\t\t0x51\n\nstatic const struct ieee80211_txrx_stypes\n\twilc_wfi_cfg80211_mgmt_types[NUM_NL80211_IFTYPES] = {\n\t[NL80211_IFTYPE_STATION] = {\n\t\t.tx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_AUTH >> 4),\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_PROBE_REQ >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_AUTH >> 4)\n\t},\n\t[NL80211_IFTYPE_AP] = {\n\t\t.tx = 0xffff,\n\t\t.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_PROBE_REQ >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_DISASSOC >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_AUTH >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_DEAUTH >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_ACTION >> 4)\n\t},\n\t[NL80211_IFTYPE_P2P_CLIENT] = {\n\t\t.tx = 0xffff,\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_PROBE_REQ >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_DISASSOC >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_AUTH >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_DEAUTH >> 4)\n\t}\n};\n\n#ifdef CONFIG_PM\nstatic const struct wiphy_wowlan_support wowlan_support = {\n\t.flags = WIPHY_WOWLAN_ANY\n};\n#endif\n\nstruct wilc_p2p_mgmt_data {\n\tint size;\n\tu8 *buff;\n};\n\nstruct wilc_p2p_pub_act_frame {\n\tu8 category;\n\tu8 action;\n\tu8 oui[3];\n\tu8 oui_type;\n\tu8 oui_subtype;\n\tu8 dialog_token;\n\tu8 elem[];\n} __packed;\n\nstruct wilc_vendor_specific_ie {\n\tu8 tag_number;\n\tu8 tag_len;\n\tu8 oui[3];\n\tu8 oui_type;\n\tu8 attr[];\n} __packed;\n\nstruct wilc_attr_entry {\n\tu8  attr_type;\n\t__le16 attr_len;\n\tu8 val[];\n} __packed;\n\nstruct wilc_attr_oper_ch {\n\tu8 attr_type;\n\t__le16 attr_len;\n\tu8 country_code[IEEE80211_COUNTRY_STRING_LEN];\n\tu8 op_class;\n\tu8 op_channel;\n} __packed;\n\nstruct wilc_attr_ch_list {\n\tu8 attr_type;\n\t__le16 attr_len;\n\tu8 country_code[IEEE80211_COUNTRY_STRING_LEN];\n\tu8 elem[];\n} __packed;\n\nstruct wilc_ch_list_elem {\n\tu8 op_class;\n\tu8 no_of_channels;\n\tu8 ch_list[];\n} __packed;\n\nstatic void cfg_scan_result(enum scan_event scan_event,\n\t\t\t    struct wilc_rcvd_net_info *info, void *user_void)\n{\n\tstruct wilc_priv *priv = user_void;\n\n\tif (!priv->cfg_scanning)\n\t\treturn;\n\n\tif (scan_event == SCAN_EVENT_NETWORK_FOUND) {\n\t\ts32 freq;\n\t\tstruct ieee80211_channel *channel;\n\t\tstruct cfg80211_bss *bss;\n\t\tstruct wiphy *wiphy = priv->dev->ieee80211_ptr->wiphy;\n\n\t\tif (!wiphy || !info)\n\t\t\treturn;\n\n\t\tfreq = ieee80211_channel_to_frequency((s32)info->ch,\n\t\t\t\t\t\t      NL80211_BAND_2GHZ);\n\t\tchannel = ieee80211_get_channel(wiphy, freq);\n\t\tif (!channel)\n\t\t\treturn;\n\n\t\tbss = cfg80211_inform_bss_frame(wiphy, channel, info->mgmt,\n\t\t\t\t\t\tinfo->frame_len,\n\t\t\t\t\t\t(s32)info->rssi * 100,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tcfg80211_put_bss(wiphy, bss);\n\t} else if (scan_event == SCAN_EVENT_DONE) {\n\t\tmutex_lock(&priv->scan_req_lock);\n\n\t\tif (priv->scan_req) {\n\t\t\tstruct cfg80211_scan_info info = {\n\t\t\t\t.aborted = false,\n\t\t\t};\n\n\t\t\tcfg80211_scan_done(priv->scan_req, &info);\n\t\t\tpriv->cfg_scanning = false;\n\t\t\tpriv->scan_req = NULL;\n\t\t}\n\t\tmutex_unlock(&priv->scan_req_lock);\n\t} else if (scan_event == SCAN_EVENT_ABORTED) {\n\t\tmutex_lock(&priv->scan_req_lock);\n\n\t\tif (priv->scan_req) {\n\t\t\tstruct cfg80211_scan_info info = {\n\t\t\t\t.aborted = false,\n\t\t\t};\n\n\t\t\tcfg80211_scan_done(priv->scan_req, &info);\n\t\t\tpriv->cfg_scanning = false;\n\t\t\tpriv->scan_req = NULL;\n\t\t}\n\t\tmutex_unlock(&priv->scan_req_lock);\n\t}\n}\n\nstatic void cfg_connect_result(enum conn_event conn_disconn_evt, u8 mac_status,\n\t\t\t       void *priv_data)\n{\n\tstruct wilc_priv *priv = priv_data;\n\tstruct net_device *dev = priv->dev;\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc *wl = vif->wilc;\n\tstruct host_if_drv *wfi_drv = priv->hif_drv;\n\tstruct wilc_conn_info *conn_info = &wfi_drv->conn_info;\n\tstruct wiphy *wiphy = dev->ieee80211_ptr->wiphy;\n\n\tvif->connecting = false;\n\n\tif (conn_disconn_evt == CONN_DISCONN_EVENT_CONN_RESP) {\n\t\tu16 connect_status = conn_info->status;\n\n\t\tif (mac_status == WILC_MAC_STATUS_DISCONNECTED &&\n\t\t    connect_status == WLAN_STATUS_SUCCESS) {\n\t\t\tconnect_status = WLAN_STATUS_UNSPECIFIED_FAILURE;\n\t\t\twilc_wlan_set_bssid(priv->dev, NULL, WILC_STATION_MODE);\n\n\t\t\tif (vif->iftype != WILC_CLIENT_MODE)\n\t\t\t\twl->sta_ch = WILC_INVALID_CHANNEL;\n\n\t\t\tnetdev_err(dev, \"Unspecified failure\\n\");\n\t\t}\n\n\t\tif (connect_status == WLAN_STATUS_SUCCESS)\n\t\t\tmemcpy(priv->associated_bss, conn_info->bssid,\n\t\t\t       ETH_ALEN);\n\n\t\tcfg80211_ref_bss(wiphy, vif->bss);\n\t\tcfg80211_connect_bss(dev, conn_info->bssid, vif->bss,\n\t\t\t\t     conn_info->req_ies,\n\t\t\t\t     conn_info->req_ies_len,\n\t\t\t\t     conn_info->resp_ies,\n\t\t\t\t     conn_info->resp_ies_len,\n\t\t\t\t     connect_status, GFP_KERNEL,\n\t\t\t\t     NL80211_TIMEOUT_UNSPECIFIED);\n\n\t\tvif->bss = NULL;\n\t} else if (conn_disconn_evt == CONN_DISCONN_EVENT_DISCONN_NOTIF) {\n\t\tu16 reason = 0;\n\n\t\teth_zero_addr(priv->associated_bss);\n\t\twilc_wlan_set_bssid(priv->dev, NULL, WILC_STATION_MODE);\n\n\t\tif (vif->iftype != WILC_CLIENT_MODE) {\n\t\t\twl->sta_ch = WILC_INVALID_CHANNEL;\n\t\t} else {\n\t\t\tif (wfi_drv->ifc_up)\n\t\t\t\treason = 3;\n\t\t\telse\n\t\t\t\treason = 1;\n\t\t}\n\n\t\tcfg80211_disconnected(dev, reason, NULL, 0, false, GFP_KERNEL);\n\t}\n}\n\nstruct wilc_vif *wilc_get_wl_to_vif(struct wilc *wl)\n{\n\tstruct wilc_vif *vif;\n\n\tvif = list_first_or_null_rcu(&wl->vif_list, typeof(*vif), list);\n\tif (!vif)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn vif;\n}\n\nstatic int set_channel(struct wiphy *wiphy,\n\t\t       struct cfg80211_chan_def *chandef)\n{\n\tstruct wilc *wl = wiphy_priv(wiphy);\n\tstruct wilc_vif *vif;\n\tu32 channelnum;\n\tint result;\n\tint srcu_idx;\n\n\tsrcu_idx = srcu_read_lock(&wl->srcu);\n\tvif = wilc_get_wl_to_vif(wl);\n\tif (IS_ERR(vif)) {\n\t\tsrcu_read_unlock(&wl->srcu, srcu_idx);\n\t\treturn PTR_ERR(vif);\n\t}\n\n\tchannelnum = ieee80211_frequency_to_channel(chandef->chan->center_freq);\n\n\twl->op_ch = channelnum;\n\tresult = wilc_set_mac_chnl_num(vif, channelnum);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Error in setting channel\\n\");\n\n\tsrcu_read_unlock(&wl->srcu, srcu_idx);\n\treturn result;\n}\n\nstatic int scan(struct wiphy *wiphy, struct cfg80211_scan_request *request)\n{\n\tstruct wilc_vif *vif = netdev_priv(request->wdev->netdev);\n\tstruct wilc_priv *priv = &vif->priv;\n\tu32 i;\n\tint ret = 0;\n\tu8 scan_ch_list[WILC_MAX_NUM_SCANNED_CH];\n\tu8 scan_type;\n\n\tif (request->n_channels > WILC_MAX_NUM_SCANNED_CH) {\n\t\tnetdev_err(vif->ndev, \"Requested scanned channels over\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->scan_req = request;\n\tpriv->cfg_scanning = true;\n\tfor (i = 0; i < request->n_channels; i++) {\n\t\tu16 freq = request->channels[i]->center_freq;\n\n\t\tscan_ch_list[i] = ieee80211_frequency_to_channel(freq);\n\t}\n\n\tif (request->n_ssids)\n\t\tscan_type = WILC_FW_ACTIVE_SCAN;\n\telse\n\t\tscan_type = WILC_FW_PASSIVE_SCAN;\n\n\tret = wilc_scan(vif, WILC_FW_USER_SCAN, scan_type, scan_ch_list,\n\t\t\trequest->n_channels, cfg_scan_result, (void *)priv,\n\t\t\trequest);\n\n\tif (ret) {\n\t\tpriv->scan_req = NULL;\n\t\tpriv->cfg_scanning = false;\n\t}\n\n\treturn ret;\n}\n\nstatic int connect(struct wiphy *wiphy, struct net_device *dev,\n\t\t   struct cfg80211_connect_params *sme)\n{\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc_priv *priv = &vif->priv;\n\tstruct host_if_drv *wfi_drv = priv->hif_drv;\n\tint ret;\n\tu32 i;\n\tu8 security = WILC_FW_SEC_NO;\n\tenum mfptype mfp_type = WILC_FW_MFP_NONE;\n\tenum authtype auth_type = WILC_FW_AUTH_ANY;\n\tu32 cipher_group;\n\tstruct cfg80211_bss *bss;\n\tvoid *join_params;\n\tu8 ch;\n\n\tvif->connecting = true;\n\n\tcipher_group = sme->crypto.cipher_group;\n\tif (cipher_group != 0) {\n\t\tif (sme->crypto.wpa_versions & NL80211_WPA_VERSION_2) {\n\t\t\tif (cipher_group == WLAN_CIPHER_SUITE_TKIP)\n\t\t\t\tsecurity = WILC_FW_SEC_WPA2_TKIP;\n\t\t\telse\n\t\t\t\tsecurity = WILC_FW_SEC_WPA2_AES;\n\t\t} else if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_1) {\n\t\t\tif (cipher_group == WLAN_CIPHER_SUITE_TKIP)\n\t\t\t\tsecurity = WILC_FW_SEC_WPA_TKIP;\n\t\t\telse\n\t\t\t\tsecurity = WILC_FW_SEC_WPA_AES;\n\t\t} else {\n\t\t\tret = -ENOTSUPP;\n\t\t\tnetdev_err(dev, \"%s: Unsupported cipher\\n\",\n\t\t\t\t   __func__);\n\t\t\tgoto out_error;\n\t\t}\n\t}\n\n\tif ((sme->crypto.wpa_versions & NL80211_WPA_VERSION_1) ||\n\t    (sme->crypto.wpa_versions & NL80211_WPA_VERSION_2)) {\n\t\tfor (i = 0; i < sme->crypto.n_ciphers_pairwise; i++) {\n\t\t\tu32 ciphers_pairwise = sme->crypto.ciphers_pairwise[i];\n\n\t\t\tif (ciphers_pairwise == WLAN_CIPHER_SUITE_TKIP)\n\t\t\t\tsecurity |= WILC_FW_TKIP;\n\t\t\telse\n\t\t\t\tsecurity |= WILC_FW_AES;\n\t\t}\n\t}\n\n\tswitch (sme->auth_type) {\n\tcase NL80211_AUTHTYPE_OPEN_SYSTEM:\n\t\tauth_type = WILC_FW_AUTH_OPEN_SYSTEM;\n\t\tbreak;\n\n\tcase NL80211_AUTHTYPE_SAE:\n\t\tauth_type = WILC_FW_AUTH_SAE;\n\t\tif (sme->ssid_len) {\n\t\t\tmemcpy(vif->auth.ssid.ssid, sme->ssid, sme->ssid_len);\n\t\t\tvif->auth.ssid.ssid_len = sme->ssid_len;\n\t\t}\n\t\tvif->auth.key_mgmt_suite = cpu_to_be32(sme->crypto.akm_suites[0]);\n\t\tether_addr_copy(vif->auth.bssid, sme->bssid);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (sme->crypto.n_akm_suites) {\n\t\tif (sme->crypto.akm_suites[0] == WLAN_AKM_SUITE_8021X)\n\t\t\tauth_type = WILC_FW_AUTH_IEEE8021;\n\t\telse if (sme->crypto.akm_suites[0] == WLAN_AKM_SUITE_PSK_SHA256)\n\t\t\tauth_type = WILC_FW_AUTH_OPEN_SYSTEM_SHA256;\n\t\telse if (sme->crypto.akm_suites[0] == WLAN_AKM_SUITE_8021X_SHA256)\n\t\t\tauth_type = WILC_FW_AUTH_IEE8021X_SHA256;\n\t}\n\n\tif (wfi_drv->usr_scan_req.scan_result) {\n\t\tnetdev_err(vif->ndev, \"%s: Scan in progress\\n\", __func__);\n\t\tret = -EBUSY;\n\t\tgoto out_error;\n\t}\n\n\tbss = cfg80211_get_bss(wiphy, sme->channel, sme->bssid, sme->ssid,\n\t\t\t       sme->ssid_len, IEEE80211_BSS_TYPE_ANY,\n\t\t\t       IEEE80211_PRIVACY(sme->privacy));\n\tif (!bss) {\n\t\tret = -EINVAL;\n\t\tgoto out_error;\n\t}\n\n\tif (ether_addr_equal_unaligned(vif->bssid, bss->bssid)) {\n\t\tret = -EALREADY;\n\t\tgoto out_put_bss;\n\t}\n\n\tjoin_params = wilc_parse_join_bss_param(bss, &sme->crypto);\n\tif (!join_params) {\n\t\tnetdev_err(dev, \"%s: failed to construct join param\\n\",\n\t\t\t   __func__);\n\t\tret = -EINVAL;\n\t\tgoto out_put_bss;\n\t}\n\n\tch = ieee80211_frequency_to_channel(bss->channel->center_freq);\n\tvif->wilc->op_ch = ch;\n\tif (vif->iftype != WILC_CLIENT_MODE)\n\t\tvif->wilc->sta_ch = ch;\n\n\twilc_wlan_set_bssid(dev, bss->bssid, WILC_STATION_MODE);\n\n\twfi_drv->conn_info.security = security;\n\twfi_drv->conn_info.auth_type = auth_type;\n\twfi_drv->conn_info.ch = ch;\n\twfi_drv->conn_info.conn_result = cfg_connect_result;\n\twfi_drv->conn_info.arg = priv;\n\twfi_drv->conn_info.param = join_params;\n\n\tif (sme->mfp == NL80211_MFP_OPTIONAL)\n\t\tmfp_type = WILC_FW_MFP_OPTIONAL;\n\telse if (sme->mfp == NL80211_MFP_REQUIRED)\n\t\tmfp_type = WILC_FW_MFP_REQUIRED;\n\n\twfi_drv->conn_info.mfp_type = mfp_type;\n\n\tret = wilc_set_join_req(vif, bss->bssid, sme->ie, sme->ie_len);\n\tif (ret) {\n\t\tnetdev_err(dev, \"wilc_set_join_req(): Error\\n\");\n\t\tret = -ENOENT;\n\t\tif (vif->iftype != WILC_CLIENT_MODE)\n\t\t\tvif->wilc->sta_ch = WILC_INVALID_CHANNEL;\n\t\twilc_wlan_set_bssid(dev, NULL, WILC_STATION_MODE);\n\t\twfi_drv->conn_info.conn_result = NULL;\n\t\tkfree(join_params);\n\t\tgoto out_put_bss;\n\t}\n\tkfree(join_params);\n\tvif->bss = bss;\n\tcfg80211_put_bss(wiphy, bss);\n\treturn 0;\n\nout_put_bss:\n\tcfg80211_put_bss(wiphy, bss);\n\nout_error:\n\tvif->connecting = false;\n\treturn ret;\n}\n\nstatic int disconnect(struct wiphy *wiphy, struct net_device *dev,\n\t\t      u16 reason_code)\n{\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc_priv *priv = &vif->priv;\n\tstruct wilc *wilc = vif->wilc;\n\tint ret;\n\n\tvif->connecting = false;\n\n\tif (!wilc)\n\t\treturn -EIO;\n\n\tif (wilc->close) {\n\t\t/* already disconnected done */\n\t\tcfg80211_disconnected(dev, 0, NULL, 0, true, GFP_KERNEL);\n\t\treturn 0;\n\t}\n\n\tif (vif->iftype != WILC_CLIENT_MODE)\n\t\twilc->sta_ch = WILC_INVALID_CHANNEL;\n\twilc_wlan_set_bssid(priv->dev, NULL, WILC_STATION_MODE);\n\n\tpriv->hif_drv->p2p_timeout = 0;\n\n\tret = wilc_disconnect(vif);\n\tif (ret != 0) {\n\t\tnetdev_err(priv->dev, \"Error in disconnecting\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\tvif->bss = NULL;\n\n\treturn ret;\n}\n\nstatic int wilc_wfi_cfg_allocate_wpa_entry(struct wilc_priv *priv, u8 idx)\n{\n\tif (!priv->wilc_gtk[idx]) {\n\t\tpriv->wilc_gtk[idx] = kzalloc(sizeof(*priv->wilc_gtk[idx]),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!priv->wilc_gtk[idx])\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (!priv->wilc_ptk[idx]) {\n\t\tpriv->wilc_ptk[idx] = kzalloc(sizeof(*priv->wilc_ptk[idx]),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!priv->wilc_ptk[idx])\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int wilc_wfi_cfg_allocate_wpa_igtk_entry(struct wilc_priv *priv, u8 idx)\n{\n\tidx -= 4;\n\tif (!priv->wilc_igtk[idx]) {\n\t\tpriv->wilc_igtk[idx] = kzalloc(sizeof(*priv->wilc_igtk[idx]),\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!priv->wilc_igtk[idx])\n\t\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic int wilc_wfi_cfg_copy_wpa_info(struct wilc_wfi_key *key_info,\n\t\t\t\t      struct key_params *params)\n{\n\tkfree(key_info->key);\n\n\tkey_info->key = kmemdup(params->key, params->key_len, GFP_KERNEL);\n\tif (!key_info->key)\n\t\treturn -ENOMEM;\n\n\tkfree(key_info->seq);\n\n\tif (params->seq_len > 0) {\n\t\tkey_info->seq = kmemdup(params->seq, params->seq_len,\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!key_info->seq)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tkey_info->cipher = params->cipher;\n\tkey_info->key_len = params->key_len;\n\tkey_info->seq_len = params->seq_len;\n\n\treturn 0;\n}\n\nstatic int add_key(struct wiphy *wiphy, struct net_device *netdev, int link_id,\n\t\t   u8 key_index, bool pairwise, const u8 *mac_addr,\n\t\t   struct key_params *params)\n\n{\n\tint ret = 0, keylen = params->key_len;\n\tconst u8 *rx_mic = NULL;\n\tconst u8 *tx_mic = NULL;\n\tu8 mode = WILC_FW_SEC_NO;\n\tu8 op_mode;\n\tstruct wilc_vif *vif = netdev_priv(netdev);\n\tstruct wilc_priv *priv = &vif->priv;\n\tstruct wilc_wfi_key *key;\n\n\tswitch (params->cipher) {\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tif (priv->wdev.iftype == NL80211_IFTYPE_AP ||\n\t\t    priv->wdev.iftype == NL80211_IFTYPE_P2P_GO) {\n\t\t\tstruct wilc_wfi_key *key;\n\n\t\t\tret = wilc_wfi_cfg_allocate_wpa_entry(priv, key_index);\n\t\t\tif (ret)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tif (params->key_len > 16 &&\n\t\t\t    params->cipher == WLAN_CIPHER_SUITE_TKIP) {\n\t\t\t\ttx_mic = params->key + 24;\n\t\t\t\trx_mic = params->key + 16;\n\t\t\t\tkeylen = params->key_len - 16;\n\t\t\t}\n\n\t\t\tif (!pairwise) {\n\t\t\t\tif (params->cipher == WLAN_CIPHER_SUITE_TKIP)\n\t\t\t\t\tmode = WILC_FW_SEC_WPA_TKIP;\n\t\t\t\telse\n\t\t\t\t\tmode = WILC_FW_SEC_WPA2_AES;\n\n\t\t\t\tpriv->wilc_groupkey = mode;\n\n\t\t\t\tkey = priv->wilc_gtk[key_index];\n\t\t\t} else {\n\t\t\t\tif (params->cipher == WLAN_CIPHER_SUITE_TKIP)\n\t\t\t\t\tmode = WILC_FW_SEC_WPA_TKIP;\n\t\t\t\telse\n\t\t\t\t\tmode = priv->wilc_groupkey | WILC_FW_AES;\n\n\t\t\t\tkey = priv->wilc_ptk[key_index];\n\t\t\t}\n\t\t\tret = wilc_wfi_cfg_copy_wpa_info(key, params);\n\t\t\tif (ret)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\top_mode = WILC_AP_MODE;\n\t\t} else {\n\t\t\tif (params->key_len > 16 &&\n\t\t\t    params->cipher == WLAN_CIPHER_SUITE_TKIP) {\n\t\t\t\trx_mic = params->key + 24;\n\t\t\t\ttx_mic = params->key + 16;\n\t\t\t\tkeylen = params->key_len - 16;\n\t\t\t}\n\n\t\t\top_mode = WILC_STATION_MODE;\n\t\t}\n\n\t\tif (!pairwise)\n\t\t\tret = wilc_add_rx_gtk(vif, params->key, keylen,\n\t\t\t\t\t      key_index, params->seq_len,\n\t\t\t\t\t      params->seq, rx_mic, tx_mic,\n\t\t\t\t\t      op_mode, mode);\n\t\telse\n\t\t\tret = wilc_add_ptk(vif, params->key, keylen, mac_addr,\n\t\t\t\t\t   rx_mic, tx_mic, op_mode, mode,\n\t\t\t\t\t   key_index);\n\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\tret = wilc_wfi_cfg_allocate_wpa_igtk_entry(priv, key_index);\n\t\tif (ret)\n\t\t\treturn -ENOMEM;\n\n\t\tkey = priv->wilc_igtk[key_index - 4];\n\t\tret = wilc_wfi_cfg_copy_wpa_info(key, params);\n\t\tif (ret)\n\t\t\treturn -ENOMEM;\n\n\t\tif (priv->wdev.iftype == NL80211_IFTYPE_AP ||\n\t\t    priv->wdev.iftype == NL80211_IFTYPE_P2P_GO)\n\t\t\top_mode = WILC_AP_MODE;\n\t\telse\n\t\t\top_mode = WILC_STATION_MODE;\n\n\t\tret = wilc_add_igtk(vif, params->key, keylen, params->seq,\n\t\t\t\t    params->seq_len, mac_addr, op_mode,\n\t\t\t\t    key_index);\n\t\tbreak;\n\n\tdefault:\n\t\tnetdev_err(netdev, \"%s: Unsupported cipher\\n\", __func__);\n\t\tret = -ENOTSUPP;\n\t}\n\n\treturn ret;\n}\n\nstatic int del_key(struct wiphy *wiphy, struct net_device *netdev, int link_id,\n\t\t   u8 key_index,\n\t\t   bool pairwise,\n\t\t   const u8 *mac_addr)\n{\n\tstruct wilc_vif *vif = netdev_priv(netdev);\n\tstruct wilc_priv *priv = &vif->priv;\n\n\tif (!pairwise && (key_index == 4 || key_index == 5)) {\n\t\tkey_index -= 4;\n\t\tif (priv->wilc_igtk[key_index]) {\n\t\t\tkfree(priv->wilc_igtk[key_index]->key);\n\t\t\tpriv->wilc_igtk[key_index]->key = NULL;\n\t\t\tkfree(priv->wilc_igtk[key_index]->seq);\n\t\t\tpriv->wilc_igtk[key_index]->seq = NULL;\n\t\t\tkfree(priv->wilc_igtk[key_index]);\n\t\t\tpriv->wilc_igtk[key_index] = NULL;\n\t\t}\n\t} else {\n\t\tif (priv->wilc_gtk[key_index]) {\n\t\t\tkfree(priv->wilc_gtk[key_index]->key);\n\t\t\tpriv->wilc_gtk[key_index]->key = NULL;\n\t\t\tkfree(priv->wilc_gtk[key_index]->seq);\n\t\t\tpriv->wilc_gtk[key_index]->seq = NULL;\n\n\t\t\tkfree(priv->wilc_gtk[key_index]);\n\t\t\tpriv->wilc_gtk[key_index] = NULL;\n\t\t}\n\t\tif (priv->wilc_ptk[key_index]) {\n\t\t\tkfree(priv->wilc_ptk[key_index]->key);\n\t\t\tpriv->wilc_ptk[key_index]->key = NULL;\n\t\t\tkfree(priv->wilc_ptk[key_index]->seq);\n\t\t\tpriv->wilc_ptk[key_index]->seq = NULL;\n\t\t\tkfree(priv->wilc_ptk[key_index]);\n\t\t\tpriv->wilc_ptk[key_index] = NULL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int get_key(struct wiphy *wiphy, struct net_device *netdev, int link_id,\n\t\t   u8 key_index, bool pairwise, const u8 *mac_addr,\n\t\t   void *cookie,\n\t\t   void (*callback)(void *cookie, struct key_params *))\n{\n\tstruct wilc_vif *vif = netdev_priv(netdev);\n\tstruct wilc_priv *priv = &vif->priv;\n\tstruct  key_params key_params;\n\n\tif (!pairwise) {\n\t\tif (key_index == 4 || key_index == 5) {\n\t\t\tkey_index -= 4;\n\t\t\tkey_params.key = priv->wilc_igtk[key_index]->key;\n\t\t\tkey_params.cipher = priv->wilc_igtk[key_index]->cipher;\n\t\t\tkey_params.key_len = priv->wilc_igtk[key_index]->key_len;\n\t\t\tkey_params.seq = priv->wilc_igtk[key_index]->seq;\n\t\t\tkey_params.seq_len = priv->wilc_igtk[key_index]->seq_len;\n\t\t} else {\n\t\t\tkey_params.key = priv->wilc_gtk[key_index]->key;\n\t\t\tkey_params.cipher = priv->wilc_gtk[key_index]->cipher;\n\t\t\tkey_params.key_len = priv->wilc_gtk[key_index]->key_len;\n\t\t\tkey_params.seq = priv->wilc_gtk[key_index]->seq;\n\t\t\tkey_params.seq_len = priv->wilc_gtk[key_index]->seq_len;\n\t\t}\n\t} else {\n\t\tkey_params.key = priv->wilc_ptk[key_index]->key;\n\t\tkey_params.cipher = priv->wilc_ptk[key_index]->cipher;\n\t\tkey_params.key_len = priv->wilc_ptk[key_index]->key_len;\n\t\tkey_params.seq = priv->wilc_ptk[key_index]->seq;\n\t\tkey_params.seq_len = priv->wilc_ptk[key_index]->seq_len;\n\t}\n\n\tcallback(cookie, &key_params);\n\n\treturn 0;\n}\n\n/* wiphy_new_nm() will WARNON if not present */\nstatic int set_default_key(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t   int link_id, u8 key_index, bool unicast,\n\t\t\t   bool multicast)\n{\n\treturn 0;\n}\n\nstatic int set_default_mgmt_key(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t\tint link_id, u8 key_index)\n{\n\tstruct wilc_vif *vif = netdev_priv(netdev);\n\n\treturn wilc_set_default_mgmt_key_index(vif, key_index);\n}\n\nstatic int get_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t       const u8 *mac, struct station_info *sinfo)\n{\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc_priv *priv = &vif->priv;\n\tstruct wilc *wilc = vif->wilc;\n\tu32 i = 0;\n\tu32 associatedsta = ~0;\n\tu32 inactive_time = 0;\n\n\tif (vif->iftype == WILC_AP_MODE || vif->iftype == WILC_GO_MODE) {\n\t\tfor (i = 0; i < NUM_STA_ASSOCIATED; i++) {\n\t\t\tif (!(memcmp(mac,\n\t\t\t\t     priv->assoc_stainfo.sta_associated_bss[i],\n\t\t\t\t     ETH_ALEN))) {\n\t\t\t\tassociatedsta = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (associatedsta == ~0) {\n\t\t\tnetdev_err(dev, \"sta required is not associated\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_INACTIVE_TIME);\n\n\t\twilc_get_inactive_time(vif, mac, &inactive_time);\n\t\tsinfo->inactive_time = 1000 * inactive_time;\n\t} else if (vif->iftype == WILC_STATION_MODE) {\n\t\tstruct rf_info stats;\n\n\t\tif (!wilc->initialized)\n\t\t\treturn -EBUSY;\n\n\t\twilc_get_statistics(vif, &stats);\n\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL) |\n\t\t\t\t BIT_ULL(NL80211_STA_INFO_RX_PACKETS) |\n\t\t\t\t BIT_ULL(NL80211_STA_INFO_TX_PACKETS) |\n\t\t\t\t BIT_ULL(NL80211_STA_INFO_TX_FAILED) |\n\t\t\t\t BIT_ULL(NL80211_STA_INFO_TX_BITRATE);\n\n\t\tsinfo->signal = stats.rssi;\n\t\tsinfo->rx_packets = stats.rx_cnt;\n\t\tsinfo->tx_packets = stats.tx_cnt + stats.tx_fail_cnt;\n\t\tsinfo->tx_failed = stats.tx_fail_cnt;\n\t\tsinfo->txrate.legacy = stats.link_speed * 10;\n\n\t\tif (stats.link_speed > TCP_ACK_FILTER_LINK_SPEED_THRESH &&\n\t\t    stats.link_speed != DEFAULT_LINK_SPEED)\n\t\t\twilc_enable_tcp_ack_filter(vif, true);\n\t\telse if (stats.link_speed != DEFAULT_LINK_SPEED)\n\t\t\twilc_enable_tcp_ack_filter(vif, false);\n\t}\n\treturn 0;\n}\n\nstatic int change_bss(struct wiphy *wiphy, struct net_device *dev,\n\t\t      struct bss_parameters *params)\n{\n\treturn 0;\n}\n\nstatic int set_wiphy_params(struct wiphy *wiphy, u32 changed)\n{\n\tint ret = -EINVAL;\n\tstruct cfg_param_attr cfg_param_val;\n\tstruct wilc *wl = wiphy_priv(wiphy);\n\tstruct wilc_vif *vif;\n\tstruct wilc_priv *priv;\n\tint srcu_idx;\n\n\tsrcu_idx = srcu_read_lock(&wl->srcu);\n\tvif = wilc_get_wl_to_vif(wl);\n\tif (IS_ERR(vif))\n\t\tgoto out;\n\n\tpriv = &vif->priv;\n\tcfg_param_val.flag = 0;\n\n\tif (changed & WIPHY_PARAM_RETRY_SHORT) {\n\t\tnetdev_dbg(vif->ndev,\n\t\t\t   \"Setting WIPHY_PARAM_RETRY_SHORT %d\\n\",\n\t\t\t   wiphy->retry_short);\n\t\tcfg_param_val.flag  |= WILC_CFG_PARAM_RETRY_SHORT;\n\t\tcfg_param_val.short_retry_limit = wiphy->retry_short;\n\t}\n\tif (changed & WIPHY_PARAM_RETRY_LONG) {\n\t\tnetdev_dbg(vif->ndev,\n\t\t\t   \"Setting WIPHY_PARAM_RETRY_LONG %d\\n\",\n\t\t\t   wiphy->retry_long);\n\t\tcfg_param_val.flag |= WILC_CFG_PARAM_RETRY_LONG;\n\t\tcfg_param_val.long_retry_limit = wiphy->retry_long;\n\t}\n\tif (changed & WIPHY_PARAM_FRAG_THRESHOLD) {\n\t\tif (wiphy->frag_threshold > 255 &&\n\t\t    wiphy->frag_threshold < 7937) {\n\t\t\tnetdev_dbg(vif->ndev,\n\t\t\t\t   \"Setting WIPHY_PARAM_FRAG_THRESHOLD %d\\n\",\n\t\t\t\t   wiphy->frag_threshold);\n\t\t\tcfg_param_val.flag |= WILC_CFG_PARAM_FRAG_THRESHOLD;\n\t\t\tcfg_param_val.frag_threshold = wiphy->frag_threshold;\n\t\t} else {\n\t\t\tnetdev_err(vif->ndev,\n\t\t\t\t   \"Fragmentation threshold out of range\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (changed & WIPHY_PARAM_RTS_THRESHOLD) {\n\t\tif (wiphy->rts_threshold > 255) {\n\t\t\tnetdev_dbg(vif->ndev,\n\t\t\t\t   \"Setting WIPHY_PARAM_RTS_THRESHOLD %d\\n\",\n\t\t\t\t   wiphy->rts_threshold);\n\t\t\tcfg_param_val.flag |= WILC_CFG_PARAM_RTS_THRESHOLD;\n\t\t\tcfg_param_val.rts_threshold = wiphy->rts_threshold;\n\t\t} else {\n\t\t\tnetdev_err(vif->ndev, \"RTS threshold out of range\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = wilc_hif_set_cfg(vif, &cfg_param_val);\n\tif (ret)\n\t\tnetdev_err(priv->dev, \"Error in setting WIPHY PARAMS\\n\");\n\nout:\n\tsrcu_read_unlock(&wl->srcu, srcu_idx);\n\treturn ret;\n}\n\nstatic int set_pmksa(struct wiphy *wiphy, struct net_device *netdev,\n\t\t     struct cfg80211_pmksa *pmksa)\n{\n\tstruct wilc_vif *vif = netdev_priv(netdev);\n\tstruct wilc_priv *priv = &vif->priv;\n\tu32 i;\n\tint ret = 0;\n\tu8 flag = 0;\n\n\tfor (i = 0; i < priv->pmkid_list.numpmkid; i++)\t{\n\t\tif (!memcmp(pmksa->bssid, priv->pmkid_list.pmkidlist[i].bssid,\n\t\t\t    ETH_ALEN)) {\n\t\t\tflag = PMKID_FOUND;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i < WILC_MAX_NUM_PMKIDS) {\n\t\tmemcpy(priv->pmkid_list.pmkidlist[i].bssid, pmksa->bssid,\n\t\t       ETH_ALEN);\n\t\tmemcpy(priv->pmkid_list.pmkidlist[i].pmkid, pmksa->pmkid,\n\t\t       WLAN_PMKID_LEN);\n\t\tif (!(flag == PMKID_FOUND))\n\t\t\tpriv->pmkid_list.numpmkid++;\n\t} else {\n\t\tnetdev_err(netdev, \"Invalid PMKID index\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\tif (!ret)\n\t\tret = wilc_set_pmkid_info(vif, &priv->pmkid_list);\n\n\treturn ret;\n}\n\nstatic int del_pmksa(struct wiphy *wiphy, struct net_device *netdev,\n\t\t     struct cfg80211_pmksa *pmksa)\n{\n\tu32 i;\n\tstruct wilc_vif *vif = netdev_priv(netdev);\n\tstruct wilc_priv *priv = &vif->priv;\n\n\tfor (i = 0; i < priv->pmkid_list.numpmkid; i++)\t{\n\t\tif (!memcmp(pmksa->bssid, priv->pmkid_list.pmkidlist[i].bssid,\n\t\t\t    ETH_ALEN)) {\n\t\t\tmemset(&priv->pmkid_list.pmkidlist[i], 0,\n\t\t\t       sizeof(struct wilc_pmkid));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == priv->pmkid_list.numpmkid)\n\t\treturn -EINVAL;\n\n\tfor (; i < (priv->pmkid_list.numpmkid - 1); i++) {\n\t\tmemcpy(priv->pmkid_list.pmkidlist[i].bssid,\n\t\t       priv->pmkid_list.pmkidlist[i + 1].bssid,\n\t\t       ETH_ALEN);\n\t\tmemcpy(priv->pmkid_list.pmkidlist[i].pmkid,\n\t\t       priv->pmkid_list.pmkidlist[i + 1].pmkid,\n\t\t       WLAN_PMKID_LEN);\n\t}\n\tpriv->pmkid_list.numpmkid--;\n\n\treturn 0;\n}\n\nstatic int flush_pmksa(struct wiphy *wiphy, struct net_device *netdev)\n{\n\tstruct wilc_vif *vif = netdev_priv(netdev);\n\n\tmemset(&vif->priv.pmkid_list, 0, sizeof(struct wilc_pmkid_attr));\n\n\treturn 0;\n}\n\nstatic inline void wilc_wfi_cfg_parse_ch_attr(u8 *buf, u32 len, u8 sta_ch)\n{\n\tstruct wilc_attr_entry *e;\n\tstruct wilc_attr_ch_list *ch_list;\n\tstruct wilc_attr_oper_ch *op_ch;\n\tu32 index = 0;\n\tu8 ch_list_idx = 0;\n\tu8 op_ch_idx = 0;\n\n\tif (sta_ch == WILC_INVALID_CHANNEL)\n\t\treturn;\n\n\twhile (index + sizeof(*e) <= len) {\n\t\tu16 attr_size;\n\n\t\te = (struct wilc_attr_entry *)&buf[index];\n\t\tattr_size = le16_to_cpu(e->attr_len);\n\n\t\tif (index + sizeof(*e) + attr_size > len)\n\t\t\treturn;\n\n\t\tif (e->attr_type == IEEE80211_P2P_ATTR_CHANNEL_LIST &&\n\t\t    attr_size >= (sizeof(struct wilc_attr_ch_list) - sizeof(*e)))\n\t\t\tch_list_idx = index;\n\t\telse if (e->attr_type == IEEE80211_P2P_ATTR_OPER_CHANNEL &&\n\t\t\t attr_size == (sizeof(struct wilc_attr_oper_ch) - sizeof(*e)))\n\t\t\top_ch_idx = index;\n\n\t\tif (ch_list_idx && op_ch_idx)\n\t\t\tbreak;\n\n\t\tindex += sizeof(*e) + attr_size;\n\t}\n\n\tif (ch_list_idx) {\n\t\tu16 attr_size;\n\t\tstruct wilc_ch_list_elem *e;\n\t\tint i;\n\n\t\tch_list = (struct wilc_attr_ch_list *)&buf[ch_list_idx];\n\t\tattr_size = le16_to_cpu(ch_list->attr_len);\n\t\tfor (i = 0; i < attr_size;) {\n\t\t\te = (struct wilc_ch_list_elem *)(ch_list->elem + i);\n\t\t\tif (e->op_class == WILC_WLAN_OPERATING_CLASS_2_4GHZ) {\n\t\t\t\tmemset(e->ch_list, sta_ch, e->no_of_channels);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti += e->no_of_channels;\n\t\t}\n\t}\n\n\tif (op_ch_idx) {\n\t\top_ch = (struct wilc_attr_oper_ch *)&buf[op_ch_idx];\n\t\top_ch->op_class = WILC_WLAN_OPERATING_CLASS_2_4GHZ;\n\t\top_ch->op_channel = sta_ch;\n\t}\n}\n\nbool wilc_wfi_mgmt_frame_rx(struct wilc_vif *vif, u8 *buff, u32 size)\n{\n\tstruct wilc *wl = vif->wilc;\n\tstruct wilc_priv *priv = &vif->priv;\n\tint freq;\n\n\tfreq = ieee80211_channel_to_frequency(wl->op_ch, NL80211_BAND_2GHZ);\n\n\treturn cfg80211_rx_mgmt(&priv->wdev, freq, 0, buff, size, 0);\n}\n\nvoid wilc_wfi_p2p_rx(struct wilc_vif *vif, u8 *buff, u32 size)\n{\n\tstruct wilc *wl = vif->wilc;\n\tstruct wilc_priv *priv = &vif->priv;\n\tstruct host_if_drv *wfi_drv = priv->hif_drv;\n\tstruct ieee80211_mgmt *mgmt;\n\tstruct wilc_vendor_specific_ie *p;\n\tstruct wilc_p2p_pub_act_frame *d;\n\tint ie_offset = offsetof(struct ieee80211_mgmt, u) + sizeof(*d);\n\tconst u8 *vendor_ie;\n\tu32 header, pkt_offset;\n\ts32 freq;\n\n\theader = get_unaligned_le32(buff - HOST_HDR_OFFSET);\n\tpkt_offset = FIELD_GET(WILC_PKT_HDR_OFFSET_FIELD, header);\n\n\tif (pkt_offset & IS_MANAGMEMENT_CALLBACK) {\n\t\tbool ack = false;\n\t\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)buff;\n\n\t\tif (ieee80211_is_probe_resp(hdr->frame_control) ||\n\t\t    pkt_offset & IS_MGMT_STATUS_SUCCES)\n\t\t\tack = true;\n\n\t\tcfg80211_mgmt_tx_status(&priv->wdev, priv->tx_cookie, buff,\n\t\t\t\t\tsize, ack, GFP_KERNEL);\n\t\treturn;\n\t}\n\n\tfreq = ieee80211_channel_to_frequency(wl->op_ch, NL80211_BAND_2GHZ);\n\n\tmgmt = (struct ieee80211_mgmt *)buff;\n\tif (!ieee80211_is_action(mgmt->frame_control))\n\t\tgoto out_rx_mgmt;\n\n\tif (priv->cfg_scanning &&\n\t    time_after_eq(jiffies, (unsigned long)wfi_drv->p2p_timeout)) {\n\t\tnetdev_dbg(vif->ndev, \"Receiving action wrong ch\\n\");\n\t\treturn;\n\t}\n\n\tif (!ieee80211_is_public_action((struct ieee80211_hdr *)buff, size))\n\t\tgoto out_rx_mgmt;\n\n\td = (struct wilc_p2p_pub_act_frame *)(&mgmt->u.action);\n\tif (d->oui_subtype != GO_NEG_REQ && d->oui_subtype != GO_NEG_RSP &&\n\t    d->oui_subtype != P2P_INV_REQ && d->oui_subtype != P2P_INV_RSP)\n\t\tgoto out_rx_mgmt;\n\n\tvendor_ie = cfg80211_find_vendor_ie(WLAN_OUI_WFA, WLAN_OUI_TYPE_WFA_P2P,\n\t\t\t\t\t    buff + ie_offset, size - ie_offset);\n\tif (!vendor_ie)\n\t\tgoto out_rx_mgmt;\n\n\tp = (struct wilc_vendor_specific_ie *)vendor_ie;\n\twilc_wfi_cfg_parse_ch_attr(p->attr, p->tag_len - 4, vif->wilc->sta_ch);\n\nout_rx_mgmt:\n\tcfg80211_rx_mgmt(&priv->wdev, freq, 0, buff, size, 0);\n}\n\nstatic void wilc_wfi_mgmt_tx_complete(void *priv, int status)\n{\n\tstruct wilc_p2p_mgmt_data *pv_data = priv;\n\n\tkfree(pv_data->buff);\n\tkfree(pv_data);\n}\n\nstatic void wilc_wfi_remain_on_channel_expired(void *data, u64 cookie)\n{\n\tstruct wilc_vif *vif = data;\n\tstruct wilc_priv *priv = &vif->priv;\n\tstruct wilc_wfi_p2p_listen_params *params = &priv->remain_on_ch_params;\n\n\tif (cookie != params->listen_cookie)\n\t\treturn;\n\n\tpriv->p2p_listen_state = false;\n\n\tcfg80211_remain_on_channel_expired(&priv->wdev, params->listen_cookie,\n\t\t\t\t\t   params->listen_ch, GFP_KERNEL);\n}\n\nstatic int remain_on_channel(struct wiphy *wiphy,\n\t\t\t     struct wireless_dev *wdev,\n\t\t\t     struct ieee80211_channel *chan,\n\t\t\t     unsigned int duration, u64 *cookie)\n{\n\tint ret = 0;\n\tstruct wilc_vif *vif = netdev_priv(wdev->netdev);\n\tstruct wilc_priv *priv = &vif->priv;\n\tu64 id;\n\n\tif (wdev->iftype == NL80211_IFTYPE_AP) {\n\t\tnetdev_dbg(vif->ndev, \"Required while in AP mode\\n\");\n\t\treturn ret;\n\t}\n\n\tid = ++priv->inc_roc_cookie;\n\tif (id == 0)\n\t\tid = ++priv->inc_roc_cookie;\n\n\tret = wilc_remain_on_channel(vif, id, duration, chan->hw_value,\n\t\t\t\t     wilc_wfi_remain_on_channel_expired,\n\t\t\t\t     (void *)vif);\n\tif (ret)\n\t\treturn ret;\n\n\tvif->wilc->op_ch = chan->hw_value;\n\n\tpriv->remain_on_ch_params.listen_ch = chan;\n\tpriv->remain_on_ch_params.listen_cookie = id;\n\t*cookie = id;\n\tpriv->p2p_listen_state = true;\n\tpriv->remain_on_ch_params.listen_duration = duration;\n\n\tcfg80211_ready_on_channel(wdev, *cookie, chan, duration, GFP_KERNEL);\n\tmod_timer(&vif->hif_drv->remain_on_ch_timer,\n\t\t  jiffies + msecs_to_jiffies(duration + 1000));\n\n\treturn ret;\n}\n\nstatic int cancel_remain_on_channel(struct wiphy *wiphy,\n\t\t\t\t    struct wireless_dev *wdev,\n\t\t\t\t    u64 cookie)\n{\n\tstruct wilc_vif *vif = netdev_priv(wdev->netdev);\n\tstruct wilc_priv *priv = &vif->priv;\n\n\tif (cookie != priv->remain_on_ch_params.listen_cookie)\n\t\treturn -ENOENT;\n\n\treturn wilc_listen_state_expired(vif, cookie);\n}\n\nstatic int mgmt_tx(struct wiphy *wiphy,\n\t\t   struct wireless_dev *wdev,\n\t\t   struct cfg80211_mgmt_tx_params *params,\n\t\t   u64 *cookie)\n{\n\tstruct ieee80211_channel *chan = params->chan;\n\tunsigned int wait = params->wait;\n\tconst u8 *buf = params->buf;\n\tsize_t len = params->len;\n\tconst struct ieee80211_mgmt *mgmt;\n\tstruct wilc_p2p_mgmt_data *mgmt_tx;\n\tstruct wilc_vif *vif = netdev_priv(wdev->netdev);\n\tstruct wilc_priv *priv = &vif->priv;\n\tstruct host_if_drv *wfi_drv = priv->hif_drv;\n\tstruct wilc_vendor_specific_ie *p;\n\tstruct wilc_p2p_pub_act_frame *d;\n\tint ie_offset = offsetof(struct ieee80211_mgmt, u) + sizeof(*d);\n\tconst u8 *vendor_ie;\n\tint ret = 0;\n\n\t*cookie = get_random_u32();\n\tpriv->tx_cookie = *cookie;\n\tmgmt = (const struct ieee80211_mgmt *)buf;\n\n\tif (!ieee80211_is_mgmt(mgmt->frame_control))\n\t\tgoto out;\n\n\tmgmt_tx = kmalloc(sizeof(*mgmt_tx), GFP_KERNEL);\n\tif (!mgmt_tx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmgmt_tx->buff = kmemdup(buf, len, GFP_KERNEL);\n\tif (!mgmt_tx->buff) {\n\t\tret = -ENOMEM;\n\t\tkfree(mgmt_tx);\n\t\tgoto out;\n\t}\n\n\tmgmt_tx->size = len;\n\n\tif (ieee80211_is_probe_resp(mgmt->frame_control)) {\n\t\twilc_set_mac_chnl_num(vif, chan->hw_value);\n\t\tvif->wilc->op_ch = chan->hw_value;\n\t\tgoto out_txq_add_pkt;\n\t}\n\n\tif (!ieee80211_is_public_action((struct ieee80211_hdr *)buf, len)) {\n\t\tif (chan)\n\t\t\twilc_set_mac_chnl_num(vif, chan->hw_value);\n\t\telse\n\t\t\twilc_set_mac_chnl_num(vif, vif->wilc->op_ch);\n\n\t\tgoto out_set_timeout;\n\t}\n\n\td = (struct wilc_p2p_pub_act_frame *)(&mgmt->u.action);\n\tif (d->oui_type != WLAN_OUI_TYPE_WFA_P2P ||\n\t    d->oui_subtype != GO_NEG_CONF) {\n\t\twilc_set_mac_chnl_num(vif, chan->hw_value);\n\t\tvif->wilc->op_ch = chan->hw_value;\n\t}\n\n\tif (d->oui_subtype != P2P_INV_REQ && d->oui_subtype != P2P_INV_RSP)\n\t\tgoto out_set_timeout;\n\n\tvendor_ie = cfg80211_find_vendor_ie(WLAN_OUI_WFA, WLAN_OUI_TYPE_WFA_P2P,\n\t\t\t\t\t    mgmt_tx->buff + ie_offset,\n\t\t\t\t\t    len - ie_offset);\n\tif (!vendor_ie)\n\t\tgoto out_set_timeout;\n\n\tp = (struct wilc_vendor_specific_ie *)vendor_ie;\n\twilc_wfi_cfg_parse_ch_attr(p->attr, p->tag_len - 4, vif->wilc->sta_ch);\n\nout_set_timeout:\n\twfi_drv->p2p_timeout = (jiffies + msecs_to_jiffies(wait));\n\nout_txq_add_pkt:\n\n\twilc_wlan_txq_add_mgmt_pkt(wdev->netdev, mgmt_tx,\n\t\t\t\t   mgmt_tx->buff, mgmt_tx->size,\n\t\t\t\t   wilc_wfi_mgmt_tx_complete);\n\nout:\n\n\treturn ret;\n}\n\nstatic int mgmt_tx_cancel_wait(struct wiphy *wiphy,\n\t\t\t       struct wireless_dev *wdev,\n\t\t\t       u64 cookie)\n{\n\tstruct wilc_vif *vif = netdev_priv(wdev->netdev);\n\tstruct wilc_priv *priv = &vif->priv;\n\tstruct host_if_drv *wfi_drv = priv->hif_drv;\n\n\twfi_drv->p2p_timeout = jiffies;\n\n\tif (!priv->p2p_listen_state) {\n\t\tstruct wilc_wfi_p2p_listen_params *params;\n\n\t\tparams = &priv->remain_on_ch_params;\n\n\t\tcfg80211_remain_on_channel_expired(wdev,\n\t\t\t\t\t\t   params->listen_cookie,\n\t\t\t\t\t\t   params->listen_ch,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t}\n\n\treturn 0;\n}\n\nvoid wilc_update_mgmt_frame_registrations(struct wiphy *wiphy,\n\t\t\t\t\t  struct wireless_dev *wdev,\n\t\t\t\t\t  struct mgmt_frame_regs *upd)\n{\n\tstruct wilc *wl = wiphy_priv(wiphy);\n\tstruct wilc_vif *vif = netdev_priv(wdev->netdev);\n\tu32 presp_bit = BIT(IEEE80211_STYPE_PROBE_REQ >> 4);\n\tu32 action_bit = BIT(IEEE80211_STYPE_ACTION >> 4);\n\tu32 pauth_bit = BIT(IEEE80211_STYPE_AUTH >> 4);\n\n\tif (wl->initialized) {\n\t\tbool prev = vif->mgmt_reg_stypes & presp_bit;\n\t\tbool now = upd->interface_stypes & presp_bit;\n\n\t\tif (now != prev)\n\t\t\twilc_frame_register(vif, IEEE80211_STYPE_PROBE_REQ, now);\n\n\t\tprev = vif->mgmt_reg_stypes & action_bit;\n\t\tnow = upd->interface_stypes & action_bit;\n\n\t\tif (now != prev)\n\t\t\twilc_frame_register(vif, IEEE80211_STYPE_ACTION, now);\n\n\t\tprev = vif->mgmt_reg_stypes & pauth_bit;\n\t\tnow = upd->interface_stypes & pauth_bit;\n\t\tif (now != prev)\n\t\t\twilc_frame_register(vif, IEEE80211_STYPE_AUTH, now);\n\t}\n\n\tvif->mgmt_reg_stypes =\n\t\tupd->interface_stypes & (presp_bit | action_bit | pauth_bit);\n}\n\nstatic int external_auth(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t struct cfg80211_external_auth_params *auth)\n{\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\n\tif (auth->status == WLAN_STATUS_SUCCESS)\n\t\twilc_set_external_auth_param(vif, auth);\n\n\treturn 0;\n}\n\nstatic int set_cqm_rssi_config(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t       s32 rssi_thold, u32 rssi_hyst)\n{\n\treturn 0;\n}\n\nstatic int dump_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t\tint idx, u8 *mac, struct station_info *sinfo)\n{\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tint ret;\n\n\tif (idx != 0)\n\t\treturn -ENOENT;\n\n\tret = wilc_get_rssi(vif, &sinfo->signal);\n\tif (ret)\n\t\treturn ret;\n\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL);\n\tmemcpy(mac, vif->priv.associated_bss, ETH_ALEN);\n\treturn 0;\n}\n\nstatic int set_power_mgmt(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t  bool enabled, int timeout)\n{\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc_priv *priv = &vif->priv;\n\n\tif (!priv->hif_drv)\n\t\treturn -EIO;\n\n\twilc_set_power_mgmt(vif, enabled, timeout);\n\n\treturn 0;\n}\n\nstatic int change_virtual_intf(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t       enum nl80211_iftype type,\n\t\t\t       struct vif_params *params)\n{\n\tstruct wilc *wl = wiphy_priv(wiphy);\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc_priv *priv = &vif->priv;\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tvif->connecting = false;\n\t\tdev->ieee80211_ptr->iftype = type;\n\t\tpriv->wdev.iftype = type;\n\t\tvif->monitor_flag = 0;\n\t\tif (vif->iftype == WILC_AP_MODE || vif->iftype == WILC_GO_MODE)\n\t\t\twilc_wfi_deinit_mon_interface(wl, true);\n\t\tvif->iftype = WILC_STATION_MODE;\n\n\t\tif (wl->initialized)\n\t\t\twilc_set_operation_mode(vif, wilc_get_vif_idx(vif),\n\t\t\t\t\t\tWILC_STATION_MODE, vif->idx);\n\n\t\tmemset(priv->assoc_stainfo.sta_associated_bss, 0,\n\t\t       WILC_MAX_NUM_STA * ETH_ALEN);\n\t\tbreak;\n\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tvif->connecting = false;\n\t\tdev->ieee80211_ptr->iftype = type;\n\t\tpriv->wdev.iftype = type;\n\t\tvif->monitor_flag = 0;\n\t\tvif->iftype = WILC_CLIENT_MODE;\n\n\t\tif (wl->initialized)\n\t\t\twilc_set_operation_mode(vif, wilc_get_vif_idx(vif),\n\t\t\t\t\t\tWILC_STATION_MODE, vif->idx);\n\t\tbreak;\n\n\tcase NL80211_IFTYPE_AP:\n\t\tdev->ieee80211_ptr->iftype = type;\n\t\tpriv->wdev.iftype = type;\n\t\tvif->iftype = WILC_AP_MODE;\n\n\t\tif (wl->initialized)\n\t\t\twilc_set_operation_mode(vif, wilc_get_vif_idx(vif),\n\t\t\t\t\t\tWILC_AP_MODE, vif->idx);\n\t\tbreak;\n\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tdev->ieee80211_ptr->iftype = type;\n\t\tpriv->wdev.iftype = type;\n\t\tvif->iftype = WILC_GO_MODE;\n\n\t\tif (wl->initialized)\n\t\t\twilc_set_operation_mode(vif, wilc_get_vif_idx(vif),\n\t\t\t\t\t\tWILC_AP_MODE, vif->idx);\n\t\tbreak;\n\n\tdefault:\n\t\tnetdev_err(dev, \"Unknown interface type= %d\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int start_ap(struct wiphy *wiphy, struct net_device *dev,\n\t\t    struct cfg80211_ap_settings *settings)\n{\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tint ret;\n\n\tret = set_channel(wiphy, &settings->chandef);\n\tif (ret != 0)\n\t\tnetdev_err(dev, \"Error in setting channel\\n\");\n\n\twilc_wlan_set_bssid(dev, dev->dev_addr, WILC_AP_MODE);\n\n\treturn wilc_add_beacon(vif, settings->beacon_interval,\n\t\t\t\t   settings->dtim_period, &settings->beacon);\n}\n\nstatic int change_beacon(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t struct cfg80211_beacon_data *beacon)\n{\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\n\treturn wilc_add_beacon(vif, 0, 0, beacon);\n}\n\nstatic int stop_ap(struct wiphy *wiphy, struct net_device *dev,\n\t\t   unsigned int link_id)\n{\n\tint ret;\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\n\twilc_wlan_set_bssid(dev, NULL, WILC_AP_MODE);\n\n\tret = wilc_del_beacon(vif);\n\n\tif (ret)\n\t\tnetdev_err(dev, \"Host delete beacon fail\\n\");\n\n\treturn ret;\n}\n\nstatic int add_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t       const u8 *mac, struct station_parameters *params)\n{\n\tint ret = 0;\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc_priv *priv = &vif->priv;\n\n\tif (vif->iftype == WILC_AP_MODE || vif->iftype == WILC_GO_MODE) {\n\t\tmemcpy(priv->assoc_stainfo.sta_associated_bss[params->aid], mac,\n\t\t       ETH_ALEN);\n\n\t\tret = wilc_add_station(vif, mac, params);\n\t\tif (ret)\n\t\t\tnetdev_err(dev, \"Host add station fail\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic int del_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t       struct station_del_parameters *params)\n{\n\tconst u8 *mac = params->mac;\n\tint ret = 0;\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc_priv *priv = &vif->priv;\n\tstruct sta_info *info;\n\n\tif (!(vif->iftype == WILC_AP_MODE || vif->iftype == WILC_GO_MODE))\n\t\treturn ret;\n\n\tinfo = &priv->assoc_stainfo;\n\n\tif (!mac)\n\t\tret = wilc_del_allstation(vif, info->sta_associated_bss);\n\n\tret = wilc_del_station(vif, mac);\n\tif (ret)\n\t\tnetdev_err(dev, \"Host delete station fail\\n\");\n\treturn ret;\n}\n\nstatic int change_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t  const u8 *mac, struct station_parameters *params)\n{\n\tint ret = 0;\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\n\tif (vif->iftype == WILC_AP_MODE || vif->iftype == WILC_GO_MODE) {\n\t\tret = wilc_edit_station(vif, mac, params);\n\t\tif (ret)\n\t\t\tnetdev_err(dev, \"Host edit station fail\\n\");\n\t}\n\treturn ret;\n}\n\nstatic struct wilc_vif *wilc_get_vif_from_type(struct wilc *wl, int type)\n{\n\tstruct wilc_vif *vif;\n\n\tlist_for_each_entry_rcu(vif, &wl->vif_list, list) {\n\t\tif (vif->iftype == type)\n\t\t\treturn vif;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct wireless_dev *add_virtual_intf(struct wiphy *wiphy,\n\t\t\t\t\t     const char *name,\n\t\t\t\t\t     unsigned char name_assign_type,\n\t\t\t\t\t     enum nl80211_iftype type,\n\t\t\t\t\t     struct vif_params *params)\n{\n\tstruct wilc *wl = wiphy_priv(wiphy);\n\tstruct wilc_vif *vif;\n\tstruct wireless_dev *wdev;\n\tint iftype;\n\n\tif (type == NL80211_IFTYPE_MONITOR) {\n\t\tstruct net_device *ndev;\n\t\tint srcu_idx;\n\n\t\tsrcu_idx = srcu_read_lock(&wl->srcu);\n\t\tvif = wilc_get_vif_from_type(wl, WILC_AP_MODE);\n\t\tif (!vif) {\n\t\t\tvif = wilc_get_vif_from_type(wl, WILC_GO_MODE);\n\t\t\tif (!vif) {\n\t\t\t\tsrcu_read_unlock(&wl->srcu, srcu_idx);\n\t\t\t\tgoto validate_interface;\n\t\t\t}\n\t\t}\n\n\t\tif (vif->monitor_flag) {\n\t\t\tsrcu_read_unlock(&wl->srcu, srcu_idx);\n\t\t\tgoto validate_interface;\n\t\t}\n\n\t\tndev = wilc_wfi_init_mon_interface(wl, name, vif->ndev);\n\t\tif (ndev) {\n\t\t\tvif->monitor_flag = 1;\n\t\t} else {\n\t\t\tsrcu_read_unlock(&wl->srcu, srcu_idx);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\n\t\twdev = &vif->priv.wdev;\n\t\tsrcu_read_unlock(&wl->srcu, srcu_idx);\n\t\treturn wdev;\n\t}\n\nvalidate_interface:\n\tmutex_lock(&wl->vif_mutex);\n\tif (wl->vif_num == WILC_NUM_CONCURRENT_IFC) {\n\t\tpr_err(\"Reached maximum number of interface\\n\");\n\t\tmutex_unlock(&wl->vif_mutex);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tmutex_unlock(&wl->vif_mutex);\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tiftype = WILC_STATION_MODE;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tiftype = WILC_AP_MODE;\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\n\tvif = wilc_netdev_ifc_init(wl, name, iftype, type, true);\n\tif (IS_ERR(vif))\n\t\treturn ERR_CAST(vif);\n\n\treturn &vif->priv.wdev;\n}\n\nstatic int del_virtual_intf(struct wiphy *wiphy, struct wireless_dev *wdev)\n{\n\tstruct wilc *wl = wiphy_priv(wiphy);\n\tstruct wilc_vif *vif;\n\n\tif (wdev->iftype == NL80211_IFTYPE_AP ||\n\t    wdev->iftype == NL80211_IFTYPE_P2P_GO)\n\t\twilc_wfi_deinit_mon_interface(wl, true);\n\tvif = netdev_priv(wdev->netdev);\n\tcfg80211_stop_iface(wiphy, wdev, GFP_KERNEL);\n\tcfg80211_unregister_netdevice(vif->ndev);\n\tvif->monitor_flag = 0;\n\n\twilc_set_operation_mode(vif, 0, 0, 0);\n\tmutex_lock(&wl->vif_mutex);\n\tlist_del_rcu(&vif->list);\n\twl->vif_num--;\n\tmutex_unlock(&wl->vif_mutex);\n\tsynchronize_srcu(&wl->srcu);\n\treturn 0;\n}\n\nstatic int wilc_suspend(struct wiphy *wiphy, struct cfg80211_wowlan *wow)\n{\n\tstruct wilc *wl = wiphy_priv(wiphy);\n\n\tif (!wow && wilc_wlan_get_num_conn_ifcs(wl))\n\t\twl->suspend_event = true;\n\telse\n\t\twl->suspend_event = false;\n\n\treturn 0;\n}\n\nstatic int wilc_resume(struct wiphy *wiphy)\n{\n\treturn 0;\n}\n\nstatic void wilc_set_wakeup(struct wiphy *wiphy, bool enabled)\n{\n\tstruct wilc *wl = wiphy_priv(wiphy);\n\tstruct wilc_vif *vif;\n\tint srcu_idx;\n\n\tsrcu_idx = srcu_read_lock(&wl->srcu);\n\tvif = wilc_get_wl_to_vif(wl);\n\tif (IS_ERR(vif)) {\n\t\tsrcu_read_unlock(&wl->srcu, srcu_idx);\n\t\treturn;\n\t}\n\n\tnetdev_info(vif->ndev, \"cfg set wake up = %d\\n\", enabled);\n\twilc_set_wowlan_trigger(vif, enabled);\n\tsrcu_read_unlock(&wl->srcu, srcu_idx);\n}\n\nstatic int set_tx_power(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\tenum nl80211_tx_power_setting type, int mbm)\n{\n\tint ret;\n\tint srcu_idx;\n\ts32 tx_power = MBM_TO_DBM(mbm);\n\tstruct wilc *wl = wiphy_priv(wiphy);\n\tstruct wilc_vif *vif;\n\n\tif (!wl->initialized)\n\t\treturn -EIO;\n\n\tsrcu_idx = srcu_read_lock(&wl->srcu);\n\tvif = wilc_get_wl_to_vif(wl);\n\tif (IS_ERR(vif)) {\n\t\tsrcu_read_unlock(&wl->srcu, srcu_idx);\n\t\treturn -EINVAL;\n\t}\n\n\tnetdev_info(vif->ndev, \"Setting tx power %d\\n\", tx_power);\n\tif (tx_power < 0)\n\t\ttx_power = 0;\n\telse if (tx_power > 18)\n\t\ttx_power = 18;\n\tret = wilc_set_tx_power(vif, tx_power);\n\tif (ret)\n\t\tnetdev_err(vif->ndev, \"Failed to set tx power\\n\");\n\tsrcu_read_unlock(&wl->srcu, srcu_idx);\n\n\treturn ret;\n}\n\nstatic int get_tx_power(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\tint *dbm)\n{\n\tint ret;\n\tstruct wilc_vif *vif = netdev_priv(wdev->netdev);\n\tstruct wilc *wl = vif->wilc;\n\n\t/* If firmware is not started, return. */\n\tif (!wl->initialized)\n\t\treturn -EIO;\n\n\tret = wilc_get_tx_power(vif, (u8 *)dbm);\n\tif (ret)\n\t\tnetdev_err(vif->ndev, \"Failed to get tx power\\n\");\n\n\treturn ret;\n}\n\nstatic const struct cfg80211_ops wilc_cfg80211_ops = {\n\t.set_monitor_channel = set_channel,\n\t.scan = scan,\n\t.connect = connect,\n\t.disconnect = disconnect,\n\t.add_key = add_key,\n\t.del_key = del_key,\n\t.get_key = get_key,\n\t.set_default_key = set_default_key,\n\t.set_default_mgmt_key = set_default_mgmt_key,\n\t.add_virtual_intf = add_virtual_intf,\n\t.del_virtual_intf = del_virtual_intf,\n\t.change_virtual_intf = change_virtual_intf,\n\n\t.start_ap = start_ap,\n\t.change_beacon = change_beacon,\n\t.stop_ap = stop_ap,\n\t.add_station = add_station,\n\t.del_station = del_station,\n\t.change_station = change_station,\n\t.get_station = get_station,\n\t.dump_station = dump_station,\n\t.change_bss = change_bss,\n\t.set_wiphy_params = set_wiphy_params,\n\n\t.external_auth = external_auth,\n\t.set_pmksa = set_pmksa,\n\t.del_pmksa = del_pmksa,\n\t.flush_pmksa = flush_pmksa,\n\t.remain_on_channel = remain_on_channel,\n\t.cancel_remain_on_channel = cancel_remain_on_channel,\n\t.mgmt_tx_cancel_wait = mgmt_tx_cancel_wait,\n\t.mgmt_tx = mgmt_tx,\n\t.update_mgmt_frame_registrations = wilc_update_mgmt_frame_registrations,\n\t.set_power_mgmt = set_power_mgmt,\n\t.set_cqm_rssi_config = set_cqm_rssi_config,\n\n\t.suspend = wilc_suspend,\n\t.resume = wilc_resume,\n\t.set_wakeup = wilc_set_wakeup,\n\t.set_tx_power = set_tx_power,\n\t.get_tx_power = get_tx_power,\n\n};\n\nstatic void wlan_init_locks(struct wilc *wl)\n{\n\tmutex_init(&wl->hif_cs);\n\tmutex_init(&wl->rxq_cs);\n\tmutex_init(&wl->cfg_cmd_lock);\n\tmutex_init(&wl->vif_mutex);\n\tmutex_init(&wl->deinit_lock);\n\n\tspin_lock_init(&wl->txq_spinlock);\n\tmutex_init(&wl->txq_add_to_head_cs);\n\n\tinit_completion(&wl->txq_event);\n\tinit_completion(&wl->cfg_event);\n\tinit_completion(&wl->sync_event);\n\tinit_completion(&wl->txq_thread_started);\n\tinit_srcu_struct(&wl->srcu);\n}\n\nvoid wlan_deinit_locks(struct wilc *wilc)\n{\n\tmutex_destroy(&wilc->hif_cs);\n\tmutex_destroy(&wilc->rxq_cs);\n\tmutex_destroy(&wilc->cfg_cmd_lock);\n\tmutex_destroy(&wilc->txq_add_to_head_cs);\n\tmutex_destroy(&wilc->vif_mutex);\n\tmutex_destroy(&wilc->deinit_lock);\n\tcleanup_srcu_struct(&wilc->srcu);\n}\n\nint wilc_cfg80211_init(struct wilc **wilc, struct device *dev, int io_type,\n\t\t       const struct wilc_hif_func *ops)\n{\n\tstruct wilc *wl;\n\tstruct wilc_vif *vif;\n\tint ret, i;\n\n\twl = wilc_create_wiphy(dev);\n\tif (!wl)\n\t\treturn -EINVAL;\n\n\twlan_init_locks(wl);\n\n\tret = wilc_wlan_cfg_init(wl);\n\tif (ret)\n\t\tgoto free_wl;\n\n\t*wilc = wl;\n\twl->io_type = io_type;\n\twl->hif_func = ops;\n\n\tfor (i = 0; i < NQUEUES; i++)\n\t\tINIT_LIST_HEAD(&wl->txq[i].txq_head.list);\n\n\tINIT_LIST_HEAD(&wl->rxq_head.list);\n\tINIT_LIST_HEAD(&wl->vif_list);\n\n\tvif = wilc_netdev_ifc_init(wl, \"wlan%d\", WILC_STATION_MODE,\n\t\t\t\t   NL80211_IFTYPE_STATION, false);\n\tif (IS_ERR(vif)) {\n\t\tret = PTR_ERR(vif);\n\t\tgoto free_cfg;\n\t}\n\n\treturn 0;\n\nfree_cfg:\n\twilc_wlan_cfg_deinit(wl);\n\nfree_wl:\n\twlan_deinit_locks(wl);\n\twiphy_unregister(wl->wiphy);\n\twiphy_free(wl->wiphy);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wilc_cfg80211_init);\n\nstruct wilc *wilc_create_wiphy(struct device *dev)\n{\n\tstruct wiphy *wiphy;\n\tstruct wilc *wl;\n\tint ret;\n\n\twiphy = wiphy_new(&wilc_cfg80211_ops, sizeof(*wl));\n\tif (!wiphy)\n\t\treturn NULL;\n\n\twl = wiphy_priv(wiphy);\n\n\tmemcpy(wl->bitrates, wilc_bitrates, sizeof(wilc_bitrates));\n\tmemcpy(wl->channels, wilc_2ghz_channels, sizeof(wilc_2ghz_channels));\n\twl->band.bitrates = wl->bitrates;\n\twl->band.n_bitrates = ARRAY_SIZE(wl->bitrates);\n\twl->band.channels = wl->channels;\n\twl->band.n_channels = ARRAY_SIZE(wilc_2ghz_channels);\n\n\twl->band.ht_cap.ht_supported = 1;\n\twl->band.ht_cap.cap |= (1 << IEEE80211_HT_CAP_RX_STBC_SHIFT);\n\twl->band.ht_cap.mcs.rx_mask[0] = 0xff;\n\twl->band.ht_cap.ampdu_factor = IEEE80211_HT_MAX_AMPDU_8K;\n\twl->band.ht_cap.ampdu_density = IEEE80211_HT_MPDU_DENSITY_NONE;\n\n\twiphy->bands[NL80211_BAND_2GHZ] = &wl->band;\n\n\twiphy->max_scan_ssids = WILC_MAX_NUM_PROBED_SSID;\n#ifdef CONFIG_PM\n\twiphy->wowlan = &wowlan_support;\n#endif\n\twiphy->max_num_pmkids = WILC_MAX_NUM_PMKIDS;\n\twiphy->max_scan_ie_len = 1000;\n\twiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;\n\tmemcpy(wl->cipher_suites, wilc_cipher_suites,\n\t       sizeof(wilc_cipher_suites));\n\twiphy->cipher_suites = wl->cipher_suites;\n\twiphy->n_cipher_suites = ARRAY_SIZE(wilc_cipher_suites);\n\twiphy->mgmt_stypes = wilc_wfi_cfg80211_mgmt_types;\n\n\twiphy->max_remain_on_channel_duration = 500;\n\twiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\tBIT(NL80211_IFTYPE_AP) |\n\t\t\t\tBIT(NL80211_IFTYPE_MONITOR) |\n\t\t\t\tBIT(NL80211_IFTYPE_P2P_GO) |\n\t\t\t\tBIT(NL80211_IFTYPE_P2P_CLIENT);\n\twiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;\n\twiphy->features |= NL80211_FEATURE_SAE;\n\tset_wiphy_dev(wiphy, dev);\n\twl->wiphy = wiphy;\n\tret = wiphy_register(wiphy);\n\tif (ret) {\n\t\twiphy_free(wiphy);\n\t\treturn NULL;\n\t}\n\treturn wl;\n}\n\nint wilc_init_host_int(struct net_device *net)\n{\n\tint ret;\n\tstruct wilc_vif *vif = netdev_priv(net);\n\tstruct wilc_priv *priv = &vif->priv;\n\n\tpriv->p2p_listen_state = false;\n\n\tmutex_init(&priv->scan_req_lock);\n\tret = wilc_init(net, &priv->hif_drv);\n\tif (ret)\n\t\tnetdev_err(net, \"Error while initializing hostinterface\\n\");\n\n\treturn ret;\n}\n\nvoid wilc_deinit_host_int(struct net_device *net)\n{\n\tint ret;\n\tstruct wilc_vif *vif = netdev_priv(net);\n\tstruct wilc_priv *priv = &vif->priv;\n\n\tpriv->p2p_listen_state = false;\n\n\tflush_workqueue(vif->wilc->hif_workqueue);\n\tmutex_destroy(&priv->scan_req_lock);\n\tret = wilc_deinit(vif);\n\n\tif (ret)\n\t\tnetdev_err(net, \"Error while deinitializing host interface\\n\");\n}\n\n"], "filenames": ["drivers/net/wireless/microchip/wilc1000/cfg80211.c"], "buggy_code_start_loc": [970], "buggy_code_end_loc": [971], "fixing_code_start_loc": [970], "fixing_code_end_loc": [972], "type": "CWE-787", "message": "An issue was discovered in the Linux kernel before 6.0.11. Missing validation of IEEE80211_P2P_ATTR_CHANNEL_LIST in drivers/net/wireless/microchip/wilc1000/cfg80211.c in the WILC1000 wireless driver can trigger a heap-based buffer overflow when parsing the operating channel attribute from Wi-Fi management frames.", "other": {"cve": {"id": "CVE-2022-47521", "sourceIdentifier": "cve@mitre.org", "published": "2022-12-18T06:15:09.527", "lastModified": "2023-04-11T18:15:52.067", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in the Linux kernel before 6.0.11. Missing validation of IEEE80211_P2P_ATTR_CHANNEL_LIST in drivers/net/wireless/microchip/wilc1000/cfg80211.c in the WILC1000 wireless driver can trigger a heap-based buffer overflow when parsing the operating channel attribute from Wi-Fi management frames."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.7", "versionEndExcluding": "5.10.157", "matchCriteriaId": "E36A4D4A-31D1-451A-AA9B-3676D3C7A05F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.11", "versionEndExcluding": "5.15.81", "matchCriteriaId": "899FBA32-27B2-4660-BC94-C43ED4349EB5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.16", "versionEndExcluding": "6.0.11", "matchCriteriaId": "BA01D181-8E71-42E1-ACF4-7A5B65006EC8"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "234DEFE0-5CE5-4B0A-96B8-5D227CB8ED31"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410c:-:*:*:*:*:*:*:*", "matchCriteriaId": "CDDF61B7-EC5C-467C-B710-B89F502CD04F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}], "references": [{"url": "https://github.com/torvalds/linux/commit/f9b62f9843c7b0afdaecabbcebf1dbba18599408", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/12/msg00031.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lore.kernel.org/r/20221123153543.8568-4-philipturnbull@github.com", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20230113-0007/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/f9b62f9843c7b0afdaecabbcebf1dbba18599408"}}