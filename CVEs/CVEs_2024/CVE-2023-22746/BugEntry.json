{"buggy_code": ["# encoding: utf-8\n\n'''API functions for adding data to CKAN.'''\n\nimport logging\nimport random\nimport re\nfrom socket import error as socket_error\nimport string\n\nimport paste.deploy.converters\nfrom sqlalchemy import func\n\nimport ckan.lib.plugins as lib_plugins\nimport ckan.logic as logic\nimport ckan.plugins as plugins\nimport ckan.lib.dictization\nimport ckan.logic.action\nimport ckan.logic.schema\nimport ckan.lib.dictization.model_dictize as model_dictize\nimport ckan.lib.dictization.model_save as model_save\nimport ckan.lib.navl.dictization_functions\nimport ckan.lib.uploader as uploader\nimport ckan.lib.navl.validators as validators\nimport ckan.lib.mailer as mailer\nimport ckan.lib.datapreview\n\nfrom ckan.common import _, config\n\n# FIXME this looks nasty and should be shared better\nfrom ckan.logic.action.update import _update_package_relationship\n\nlog = logging.getLogger(__name__)\n\n# Define some shortcuts\n# Ensure they are module-private so that they don't get loaded as available\n# actions in the action API.\n_validate = ckan.lib.navl.dictization_functions.validate\n_check_access = logic.check_access\n_get_action = logic.get_action\nValidationError = logic.ValidationError\nNotFound = logic.NotFound\n_get_or_bust = logic.get_or_bust\n\n\ndef package_create(context, data_dict):\n    '''Create a new dataset (package).\n\n    You must be authorized to create new datasets. If you specify any groups\n    for the new dataset, you must also be authorized to edit these groups.\n\n    Plugins may change the parameters of this function depending on the value\n    of the ``type`` parameter, see the\n    :py:class:`~ckan.plugins.interfaces.IDatasetForm` plugin interface.\n\n    :param name: the name of the new dataset, must be between 2 and 100\n        characters long and contain only lowercase alphanumeric characters,\n        ``-`` and ``_``, e.g. ``'warandpeace'``\n    :type name: string\n    :param title: the title of the dataset (optional, default: same as\n        ``name``)\n    :type title: string\n    :param private: If ``True`` creates a private dataset\n    :type private: bool\n    :param author: the name of the dataset's author (optional)\n    :type author: string\n    :param author_email: the email address of the dataset's author (optional)\n    :type author_email: string\n    :param maintainer: the name of the dataset's maintainer (optional)\n    :type maintainer: string\n    :param maintainer_email: the email address of the dataset's maintainer\n        (optional)\n    :type maintainer_email: string\n    :param license_id: the id of the dataset's license, see\n        :py:func:`~ckan.logic.action.get.license_list` for available values\n        (optional)\n    :type license_id: license id string\n    :param notes: a description of the dataset (optional)\n    :type notes: string\n    :param url: a URL for the dataset's source (optional)\n    :type url: string\n    :param version: (optional)\n    :type version: string, no longer than 100 characters\n    :param state: the current state of the dataset, e.g. ``'active'`` or\n        ``'deleted'``, only active datasets show up in search results and\n        other lists of datasets, this parameter will be ignored if you are not\n        authorized to change the state of the dataset (optional, default:\n        ``'active'``)\n    :type state: string\n    :param type: the type of the dataset (optional),\n        :py:class:`~ckan.plugins.interfaces.IDatasetForm` plugins\n        associate themselves with different dataset types and provide custom\n        dataset handling behaviour for these types\n    :type type: string\n    :param resources: the dataset's resources, see\n        :py:func:`resource_create` for the format of resource dictionaries\n        (optional)\n    :type resources: list of resource dictionaries\n    :param tags: the dataset's tags, see :py:func:`tag_create` for the format\n        of tag dictionaries (optional)\n    :type tags: list of tag dictionaries\n    :param extras: the dataset's extras (optional), extras are arbitrary\n        (key: value) metadata items that can be added to datasets, each extra\n        dictionary should have keys ``'key'`` (a string), ``'value'`` (a\n        string)\n    :type extras: list of dataset extra dictionaries\n    :param relationships_as_object: see :py:func:`package_relationship_create`\n        for the format of relationship dictionaries (optional)\n    :type relationships_as_object: list of relationship dictionaries\n    :param relationships_as_subject: see :py:func:`package_relationship_create`\n        for the format of relationship dictionaries (optional)\n    :type relationships_as_subject: list of relationship dictionaries\n    :param groups: the groups to which the dataset belongs (optional), each\n        group dictionary should have one or more of the following keys which\n        identify an existing group:\n        ``'id'`` (the id of the group, string), or ``'name'`` (the name of the\n        group, string),  to see which groups exist\n        call :py:func:`~ckan.logic.action.get.group_list`\n    :type groups: list of dictionaries\n    :param owner_org: the id of the dataset's owning organization, see\n        :py:func:`~ckan.logic.action.get.organization_list` or\n        :py:func:`~ckan.logic.action.get.organization_list_for_user` for\n        available values. This parameter can be made optional if the config\n        option :ref:`ckan.auth.create_unowned_dataset` is set to ``True``.\n    :type owner_org: string\n\n    :returns: the newly created dataset (unless 'return_id_only' is set to True\n              in the context, in which case just the dataset id will\n              be returned)\n    :rtype: dictionary\n\n    '''\n    model = context['model']\n    user = context['user']\n\n    if 'type' not in data_dict:\n        package_plugin = lib_plugins.lookup_package_plugin()\n        try:\n            # use first type as default if user didn't provide type\n            package_type = package_plugin.package_types()[0]\n        except (AttributeError, IndexError):\n            package_type = 'dataset'\n            # in case a 'dataset' plugin was registered w/o fallback\n            package_plugin = lib_plugins.lookup_package_plugin(package_type)\n        data_dict['type'] = package_type\n    else:\n        package_plugin = lib_plugins.lookup_package_plugin(data_dict['type'])\n\n    if 'schema' in context:\n        schema = context['schema']\n    else:\n        schema = package_plugin.create_package_schema()\n\n    _check_access('package_create', context, data_dict)\n\n    if 'api_version' not in context:\n        # check_data_dict() is deprecated. If the package_plugin has a\n        # check_data_dict() we'll call it, if it doesn't have the method we'll\n        # do nothing.\n        check_data_dict = getattr(package_plugin, 'check_data_dict', None)\n        if check_data_dict:\n            try:\n                check_data_dict(data_dict, schema)\n            except TypeError:\n                # Old plugins do not support passing the schema so we need\n                # to ensure they still work\n                package_plugin.check_data_dict(data_dict)\n\n    data, errors = lib_plugins.plugin_validate(\n        package_plugin, context, data_dict, schema, 'package_create')\n    log.debug('package_create validate_errs=%r user=%s package=%s data=%r',\n              errors, context.get('user'),\n              data.get('name'), data_dict)\n\n    if errors:\n        model.Session.rollback()\n        raise ValidationError(errors)\n\n    rev = model.repo.new_revision()\n    rev.author = user\n    if 'message' in context:\n        rev.message = context['message']\n    else:\n        rev.message = _(u'REST API: Create object %s') % data.get(\"name\")\n\n    if user:\n        user_obj = model.User.by_name(user.decode('utf8'))\n        if user_obj:\n            data['creator_user_id'] = user_obj.id\n\n    pkg = model_save.package_dict_save(data, context)\n\n    # Needed to let extensions know the package and resources ids\n    model.Session.flush()\n    data['id'] = pkg.id\n    if data.get('resources'):\n        for index, resource in enumerate(data['resources']):\n            resource['id'] = pkg.resources[index].id\n\n    context_org_update = context.copy()\n    context_org_update['ignore_auth'] = True\n    context_org_update['defer_commit'] = True\n    context_org_update['add_revision'] = False\n    _get_action('package_owner_org_update')(context_org_update,\n                                            {'id': pkg.id,\n                                             'organization_id': pkg.owner_org})\n\n    for item in plugins.PluginImplementations(plugins.IPackageController):\n        item.create(pkg)\n\n        item.after_create(context, data)\n\n    # Make sure that a user provided schema is not used in create_views\n    # and on package_show\n    context.pop('schema', None)\n\n    # Create default views for resources if necessary\n    if data.get('resources'):\n        logic.get_action('package_create_default_resource_views')(\n            {'model': context['model'], 'user': context['user'],\n             'ignore_auth': True},\n            {'package': data})\n\n    if not context.get('defer_commit'):\n        model.repo.commit()\n\n    # need to let rest api create\n    context[\"package\"] = pkg\n    # this is added so that the rest controller can make a new location\n    context[\"id\"] = pkg.id\n    log.debug('Created object %s' % pkg.name)\n\n    return_id_only = context.get('return_id_only', False)\n\n    output = context['id'] if return_id_only \\\n        else _get_action('package_show')(context, {'id': context['id']})\n\n    return output\n\n\ndef resource_create(context, data_dict):\n    '''Appends a new resource to a datasets list of resources.\n\n    :param package_id: id of package that the resource should be added to.\n\n    :type package_id: string\n    :param url: url of resource\n    :type url: string\n    :param revision_id: (optional)\n    :type revision_id: string\n    :param description: (optional)\n    :type description: string\n    :param format: (optional)\n    :type format: string\n    :param hash: (optional)\n    :type hash: string\n    :param name: (optional)\n    :type name: string\n    :param resource_type: (optional)\n    :type resource_type: string\n    :param mimetype: (optional)\n    :type mimetype: string\n    :param mimetype_inner: (optional)\n    :type mimetype_inner: string\n    :param cache_url: (optional)\n    :type cache_url: string\n    :param size: (optional)\n    :type size: int\n    :param created: (optional)\n    :type created: iso date string\n    :param last_modified: (optional)\n    :type last_modified: iso date string\n    :param cache_last_updated: (optional)\n    :type cache_last_updated: iso date string\n    :param upload: (optional)\n    :type upload: FieldStorage (optional) needs multipart/form-data\n\n    :returns: the newly created resource\n    :rtype: dictionary\n\n    '''\n    model = context['model']\n    user = context['user']\n\n    package_id = _get_or_bust(data_dict, 'package_id')\n    if not data_dict.get('url'):\n        data_dict['url'] = ''\n\n    pkg_dict = _get_action('package_show')(\n        dict(context, return_type='dict'),\n        {'id': package_id})\n\n    _check_access('resource_create', context, data_dict)\n\n    for plugin in plugins.PluginImplementations(plugins.IResourceController):\n        plugin.before_create(context, data_dict)\n\n    if 'resources' not in pkg_dict:\n        pkg_dict['resources'] = []\n\n    upload = uploader.get_resource_uploader(data_dict)\n\n    if 'mimetype' not in data_dict:\n        if hasattr(upload, 'mimetype'):\n            data_dict['mimetype'] = upload.mimetype\n\n    if 'size' not in data_dict:\n        if hasattr(upload, 'filesize'):\n            data_dict['size'] = upload.filesize\n\n    pkg_dict['resources'].append(data_dict)\n\n    try:\n        context['defer_commit'] = True\n        context['use_cache'] = False\n        _get_action('package_update')(context, pkg_dict)\n        context.pop('defer_commit')\n    except ValidationError as e:\n        try:\n            raise ValidationError(e.error_dict['resources'][-1])\n        except (KeyError, IndexError):\n            raise ValidationError(e.error_dict)\n\n    # Get out resource_id resource from model as it will not appear in\n    # package_show until after commit\n    upload.upload(context['package'].resources[-1].id,\n                  uploader.get_max_resource_size())\n\n    model.repo.commit()\n\n    #  Run package show again to get out actual last_resource\n    updated_pkg_dict = _get_action('package_show')(context, {'id': package_id})\n    resource = updated_pkg_dict['resources'][-1]\n\n    #  Add the default views to the new resource\n    logic.get_action('resource_create_default_resource_views')(\n        {'model': context['model'],\n         'user': context['user'],\n         'ignore_auth': True\n         },\n        {'resource': resource,\n         'package': updated_pkg_dict\n         })\n\n    for plugin in plugins.PluginImplementations(plugins.IResourceController):\n        plugin.after_create(context, resource)\n\n    return resource\n\n\ndef resource_view_create(context, data_dict):\n    '''Creates a new resource view.\n\n    :param resource_id: id of the resource\n    :type resource_id: string\n    :param title: the title of the view\n    :type title: string\n    :param description: a description of the view (optional)\n    :type description: string\n    :param view_type: type of view\n    :type view_type: string\n    :param config: options necessary to recreate a view state (optional)\n    :type config: JSON string\n\n    :returns: the newly created resource view\n    :rtype: dictionary\n\n    '''\n    model = context['model']\n\n    resource_id = _get_or_bust(data_dict, 'resource_id')\n    view_type = _get_or_bust(data_dict, 'view_type')\n    view_plugin = ckan.lib.datapreview.get_view_plugin(view_type)\n\n    if not view_plugin:\n        raise ValidationError(\n            {\"view_type\": \"No plugin found for view_type {view_type}\".format(\n                view_type=view_type\n            )}\n        )\n\n    default = logic.schema.default_create_resource_view_schema(view_plugin)\n    schema = context.get('schema', default)\n    plugin_schema = view_plugin.info().get('schema', {})\n    schema.update(plugin_schema)\n\n    data, errors = _validate(data_dict, schema, context)\n    if errors:\n        model.Session.rollback()\n        raise ValidationError(errors)\n\n    _check_access('resource_view_create', context, data_dict)\n\n    if context.get('preview'):\n        return data\n\n    max_order = model.Session.query(\n        func.max(model.ResourceView.order)\n        ).filter_by(resource_id=resource_id).first()\n\n    order = 0\n    if max_order[0] is not None:\n        order = max_order[0] + 1\n    data['order'] = order\n\n    resource_view = model_save.resource_view_dict_save(data, context)\n    if not context.get('defer_commit'):\n        model.repo.commit()\n    return model_dictize.resource_view_dictize(resource_view, context)\n\n\ndef resource_create_default_resource_views(context, data_dict):\n    '''\n    Creates the default views (if necessary) on the provided resource\n\n    The function will get the plugins for the default views defined in\n    the configuration, and if some were found the `can_view` method of\n    each one of them will be called to determine if a resource view should\n    be created. Resource views extensions get the resource dict and the\n    parent dataset dict.\n\n    If the latter is not provided, `package_show` is called to get it.\n\n    By default only view plugins that don't require the resource data to be in\n    the DataStore are called. See\n    :py:func:`ckan.logic.action.create.package_create_default_resource_views.``\n    for details on the ``create_datastore_views`` parameter.\n\n    :param resource: full resource dict\n    :type resource: dict\n    :param package: full dataset dict (optional, if not provided\n        :py:func:`~ckan.logic.action.get.package_show` will be called).\n    :type package: dict\n    :param create_datastore_views: whether to create views that rely on data\n        being on the DataStore (optional, defaults to False)\n    :type create_datastore_views: bool\n\n    :returns: a list of resource views created (empty if none were created)\n    :rtype: list of dictionaries\n    '''\n\n    resource_dict = _get_or_bust(data_dict, 'resource')\n\n    _check_access('resource_create_default_resource_views', context, data_dict)\n\n    dataset_dict = data_dict.get('package')\n\n    create_datastore_views = paste.deploy.converters.asbool(\n        data_dict.get('create_datastore_views', False))\n\n    return ckan.lib.datapreview.add_views_to_resource(\n        context,\n        resource_dict,\n        dataset_dict,\n        view_types=[],\n        create_datastore_views=create_datastore_views)\n\n\ndef package_create_default_resource_views(context, data_dict):\n    '''\n    Creates the default views on all resources of the provided dataset\n\n    By default only view plugins that don't require the resource data to be in\n    the DataStore are called. Passing `create_datastore_views` as True will\n    only create views that require data to be in the DataStore. The first case\n    happens when the function is called from `package_create` or\n    `package_update`, the second when it's called from the DataPusher when\n    data was uploaded to the DataStore.\n\n    :param package: full dataset dict (ie the one obtained\n        calling :py:func:`~ckan.logic.action.get.package_show`).\n    :type package: dict\n    :param create_datastore_views: whether to create views that rely on data\n        being on the DataStore (optional, defaults to False)\n    :type create_datastore_views: bool\n\n    :returns: a list of resource views created (empty if none were created)\n    :rtype: list of dictionaries\n    '''\n\n    dataset_dict = _get_or_bust(data_dict, 'package')\n\n    _check_access('package_create_default_resource_views', context, data_dict)\n\n    create_datastore_views = paste.deploy.converters.asbool(\n        data_dict.get('create_datastore_views', False))\n\n    return ckan.lib.datapreview.add_views_to_dataset_resources(\n        context,\n        dataset_dict,\n        view_types=[],\n        create_datastore_views=create_datastore_views)\n\n\ndef package_relationship_create(context, data_dict):\n    '''Create a relationship between two datasets (packages).\n\n    You must be authorized to edit both the subject and the object datasets.\n\n    :param subject: the id or name of the dataset that is the subject of the\n        relationship\n    :type subject: string\n    :param object: the id or name of the dataset that is the object of the\n        relationship\n    :param type: the type of the relationship, one of ``'depends_on'``,\n        ``'dependency_of'``, ``'derives_from'``, ``'has_derivation'``,\n        ``'links_to'``, ``'linked_from'``, ``'child_of'`` or ``'parent_of'``\n    :type type: string\n    :param comment: a comment about the relationship (optional)\n    :type comment: string\n\n    :returns: the newly created package relationship\n    :rtype: dictionary\n\n    '''\n    model = context['model']\n    user = context['user']\n    schema = context.get('schema') \\\n        or ckan.logic.schema.default_create_relationship_schema()\n    api = context.get('api_version')\n    ref_package_by = 'id' if api == 2 else 'name'\n\n    id, id2, rel_type = _get_or_bust(data_dict, ['subject', 'object', 'type'])\n    comment = data_dict.get('comment', u'')\n\n    pkg1 = model.Package.get(id)\n    pkg2 = model.Package.get(id2)\n    if not pkg1:\n        raise NotFound('Subject package %r was not found.' % id)\n    if not pkg2:\n        return NotFound('Object package %r was not found.' % id2)\n\n    data, errors = _validate(data_dict, schema, context)\n    if errors:\n        model.Session.rollback()\n        raise ValidationError(errors)\n\n    _check_access('package_relationship_create', context, data_dict)\n\n    # Create a Package Relationship.\n    existing_rels = pkg1.get_relationships_with(pkg2, rel_type)\n    if existing_rels:\n        return _update_package_relationship(existing_rels[0],\n                                            comment, context)\n    rev = model.repo.new_revision()\n    rev.author = user\n    rev.message = _(u'REST API: Create package relationship: %s %s %s') \\\n        % (pkg1, rel_type, pkg2)\n    rel = pkg1.add_relationship(rel_type, pkg2, comment=comment)\n    if not context.get('defer_commit'):\n        model.repo.commit_and_remove()\n    context['relationship'] = rel\n\n    relationship_dicts = rel.as_dict(ref_package_by=ref_package_by)\n    return relationship_dicts\n\n\ndef member_create(context, data_dict=None):\n    '''Make an object (e.g. a user, dataset or group) a member of a group.\n\n    If the object is already a member of the group then the capacity of the\n    membership will be updated.\n\n    You must be authorized to edit the group.\n\n    :param id: the id or name of the group to add the object to\n    :type id: string\n    :param object: the id or name of the object to add\n    :type object: string\n    :param object_type: the type of the object being added, e.g. ``'package'``\n        or ``'user'``\n    :type object_type: string\n    :param capacity: the capacity of the membership\n    :type capacity: string\n\n    :returns: the newly created (or updated) membership\n    :rtype: dictionary\n\n    '''\n    model = context['model']\n    user = context['user']\n\n    rev = model.repo.new_revision()\n    rev.author = user\n    if 'message' in context:\n        rev.message = context['message']\n    else:\n        rev.message = _(u'REST API: Create member object %s') \\\n            % data_dict.get('name', '')\n\n    group_id, obj_id, obj_type, capacity = \\\n        _get_or_bust(data_dict, ['id', 'object', 'object_type', 'capacity'])\n\n    group = model.Group.get(group_id)\n    if not group:\n        raise NotFound('Group was not found.')\n\n    obj_class = ckan.logic.model_name_to_class(model, obj_type)\n    obj = obj_class.get(obj_id)\n    if not obj:\n        raise NotFound('%s was not found.' % obj_type.title())\n\n    _check_access('member_create', context, data_dict)\n\n    # Look up existing, in case it exists\n    member = model.Session.query(model.Member).\\\n        filter(model.Member.table_name == obj_type).\\\n        filter(model.Member.table_id == obj.id).\\\n        filter(model.Member.group_id == group.id).\\\n        filter(model.Member.state == 'active').first()\n    if not member:\n        member = model.Member(table_name=obj_type,\n                              table_id=obj.id,\n                              group_id=group.id,\n                              state='active')\n        member.group = group\n    member.capacity = capacity\n\n    model.Session.add(member)\n    model.repo.commit()\n\n    return model_dictize.member_dictize(member, context)\n\n\ndef _group_or_org_create(context, data_dict, is_org=False):\n    model = context['model']\n    user = context['user']\n    session = context['session']\n    data_dict['is_organization'] = is_org\n\n    upload = uploader.get_uploader('group')\n    upload.update_data_dict(data_dict, 'image_url',\n                            'image_upload', 'clear_upload')\n    # get the schema\n    group_type = data_dict.get('type', 'organization' if is_org else 'group')\n    group_plugin = lib_plugins.lookup_group_plugin(group_type)\n    try:\n        schema = group_plugin.form_to_db_schema_options({\n            'type': 'create', 'api': 'api_version' in context,\n            'context': context})\n    except AttributeError:\n        schema = group_plugin.form_to_db_schema()\n\n    if 'api_version' not in context:\n        # old plugins do not support passing the schema so we need\n        # to ensure they still work\n        try:\n            group_plugin.check_data_dict(data_dict, schema)\n        except TypeError:\n            group_plugin.check_data_dict(data_dict)\n\n    data, errors = lib_plugins.plugin_validate(\n        group_plugin, context, data_dict, schema,\n        'organization_create' if is_org else 'group_create')\n    log.debug('group_create validate_errs=%r user=%s group=%s data_dict=%r',\n              errors, context.get('user'), data_dict.get('name'), data_dict)\n\n    if errors:\n        session.rollback()\n        raise ValidationError(errors)\n\n    rev = model.repo.new_revision()\n    rev.author = user\n\n    if 'message' in context:\n        rev.message = context['message']\n    else:\n        rev.message = _(u'REST API: Create object %s') % data.get(\"name\")\n\n    group = model_save.group_dict_save(data, context)\n\n    # Needed to let extensions know the group id\n    session.flush()\n\n    if is_org:\n        plugin_type = plugins.IOrganizationController\n    else:\n        plugin_type = plugins.IGroupController\n\n    for item in plugins.PluginImplementations(plugin_type):\n        item.create(group)\n\n    if is_org:\n        activity_type = 'new organization'\n    else:\n        activity_type = 'new group'\n\n    user_id = model.User.by_name(user.decode('utf8')).id\n\n    activity_dict = {\n        'user_id': user_id,\n        'object_id': group.id,\n        'activity_type': activity_type,\n    }\n    activity_dict['data'] = {\n        'group': ckan.lib.dictization.table_dictize(group, context)\n    }\n    activity_create_context = {\n        'model': model,\n        'user': user,\n        'defer_commit': True,\n        'ignore_auth': True,\n        'session': session\n    }\n    logic.get_action('activity_create')(activity_create_context, activity_dict)\n\n    upload.upload(uploader.get_max_image_size())\n\n    if not context.get('defer_commit'):\n        model.repo.commit()\n    context[\"group\"] = group\n    context[\"id\"] = group.id\n\n    # creator of group/org becomes an admin\n    # this needs to be after the repo.commit or else revisions break\n    member_dict = {\n        'id': group.id,\n        'object': user_id,\n        'object_type': 'user',\n        'capacity': 'admin',\n    }\n    member_create_context = {\n        'model': model,\n        'user': user,\n        'ignore_auth': True,  # we are not a member of the group at this point\n        'session': session\n    }\n    logic.get_action('member_create')(member_create_context, member_dict)\n\n    log.debug('Created object %s' % group.name)\n\n    return_id_only = context.get('return_id_only', False)\n    action = 'organization_show' if is_org else 'group_show'\n\n    output = context['id'] if return_id_only \\\n        else _get_action(action)(context, {'id': group.id})\n\n    return output\n\n\ndef group_create(context, data_dict):\n    '''Create a new group.\n\n    You must be authorized to create groups.\n\n    Plugins may change the parameters of this function depending on the value\n    of the ``type`` parameter, see the\n    :py:class:`~ckan.plugins.interfaces.IGroupForm` plugin interface.\n\n    :param name: the name of the group, a string between 2 and 100 characters\n        long, containing only lowercase alphanumeric characters, ``-`` and\n        ``_``\n    :type name: string\n    :param id: the id of the group (optional)\n    :type id: string\n    :param title: the title of the group (optional)\n    :type title: string\n    :param description: the description of the group (optional)\n    :type description: string\n    :param image_url: the URL to an image to be displayed on the group's page\n        (optional)\n    :type image_url: string\n    :param type: the type of the group (optional, default: ``'group'``),\n        :py:class:`~ckan.plugins.interfaces.IGroupForm` plugins\n        associate themselves with different group types and provide custom\n        group handling behaviour for these types\n        Cannot be 'organization'\n    :type type: string\n    :param state: the current state of the group, e.g. ``'active'`` or\n        ``'deleted'``, only active groups show up in search results and\n        other lists of groups, this parameter will be ignored if you are not\n        authorized to change the state of the group (optional, default:\n        ``'active'``)\n    :type state: string\n    :param approval_status: (optional)\n    :type approval_status: string\n    :param extras: the group's extras (optional), extras are arbitrary\n        (key: value) metadata items that can be added to groups, each extra\n        dictionary should have keys ``'key'`` (a string), ``'value'`` (a\n        string), and optionally ``'deleted'``\n    :type extras: list of dataset extra dictionaries\n    :param packages: the datasets (packages) that belong to the group, a list\n        of dictionaries each with keys ``'name'`` (string, the id or name of\n        the dataset) and optionally ``'title'`` (string, the title of the\n        dataset)\n    :type packages: list of dictionaries\n    :param groups: the groups that belong to the group, a list of dictionaries\n        each with key ``'name'`` (string, the id or name of the group) and\n        optionally ``'capacity'`` (string, the capacity in which the group is\n        a member of the group)\n    :type groups: list of dictionaries\n    :param users: the users that belong to the group, a list of dictionaries\n        each with key ``'name'`` (string, the id or name of the user) and\n        optionally ``'capacity'`` (string, the capacity in which the user is\n        a member of the group)\n    :type users: list of dictionaries\n\n    :returns: the newly created group (unless 'return_id_only' is set to True\n              in the context, in which case just the group id will\n              be returned)\n    :rtype: dictionary\n\n    '''\n    # wrapper for creating groups\n    if data_dict.get('type') == 'organization':\n        # FIXME better exception?\n        raise Exception(_('Trying to create an organization as a group'))\n    _check_access('group_create', context, data_dict)\n    return _group_or_org_create(context, data_dict)\n\n\ndef organization_create(context, data_dict):\n    '''Create a new organization.\n\n    You must be authorized to create organizations.\n\n    Plugins may change the parameters of this function depending on the value\n    of the ``type`` parameter, see the\n    :py:class:`~ckan.plugins.interfaces.IGroupForm` plugin interface.\n\n    :param name: the name of the organization, a string between 2 and\n        100 characters long, containing only lowercase alphanumeric\n        characters, ``-`` and ``_``\n    :type name: string\n    :param id: the id of the organization (optional)\n    :type id: string\n    :param title: the title of the organization (optional)\n    :type title: string\n    :param description: the description of the organization (optional)\n    :type description: string\n    :param image_url: the URL to an image to be displayed on the\n        organization's page (optional)\n    :type image_url: string\n    :param state: the current state of the organization, e.g. ``'active'`` or\n        ``'deleted'``, only active organizations show up in search results and\n        other lists of organizations, this parameter will be ignored if you\n        are not authorized to change the state of the organization\n        (optional, default: ``'active'``)\n    :type state: string\n    :param approval_status: (optional)\n    :type approval_status: string\n    :param extras: the organization's extras (optional), extras are arbitrary\n        (key: value) metadata items that can be added to organizations,\n        each extra\n        dictionary should have keys ``'key'`` (a string), ``'value'`` (a\n        string), and optionally ``'deleted'``\n    :type extras: list of dataset extra dictionaries\n    :param packages: the datasets (packages) that belong to the organization,\n        a list of dictionaries each with keys ``'name'`` (string, the id\n        or name of the dataset) and optionally ``'title'`` (string, the\n        title of the dataset)\n    :type packages: list of dictionaries\n    :param users: the users that belong to the organization, a list\n        of dictionaries each with key ``'name'`` (string, the id or name\n        of the user) and optionally ``'capacity'`` (string, the capacity\n        in which the user is a member of the organization)\n    :type users: list of dictionaries\n\n    :returns: the newly created organization (unless 'return_id_only' is set\n              to True in the context, in which case just the organization id\n              will be returned)\n    :rtype: dictionary\n\n    '''\n    # wrapper for creating organizations\n    data_dict.setdefault('type', 'organization')\n    _check_access('organization_create', context, data_dict)\n    return _group_or_org_create(context, data_dict, is_org=True)\n\n\n@logic.auth_audit_exempt\ndef rating_create(context, data_dict):\n    '''Rate a dataset (package).\n\n    You must provide your API key in the Authorization header.\n\n    :param package: the name or id of the dataset to rate\n    :type package: string\n    :param rating: the rating to give to the dataset, an integer between 1 and\n        5\n    :type rating: int\n\n    :returns: a dictionary with two keys: ``'rating average'`` (the average\n        rating of the dataset you rated) and ``'rating count'`` (the number of\n        times the dataset has been rated)\n    :rtype: dictionary\n\n    '''\n    model = context['model']\n    user = context.get(\"user\")\n\n    package_ref = data_dict.get('package')\n    rating = data_dict.get('rating')\n    opts_err = None\n    if not package_ref:\n        opts_err = _('You must supply a package id or name '\n                     '(parameter \"package\").')\n    elif not rating:\n        opts_err = _('You must supply a rating (parameter \"rating\").')\n    else:\n        try:\n            rating_int = int(rating)\n        except ValueError:\n            opts_err = _('Rating must be an integer value.')\n        else:\n            package = model.Package.get(package_ref)\n            if rating < model.MIN_RATING or rating > model.MAX_RATING:\n                opts_err = _('Rating must be between %i and %i.') \\\n                    % (model.MIN_RATING, model.MAX_RATING)\n            elif not package:\n                opts_err = _('Not found') + ': %r' % package_ref\n    if opts_err:\n        raise ValidationError(opts_err)\n\n    user = model.User.by_name(user)\n    package.set_rating(user, rating_int)\n    model.repo.commit()\n\n    package = model.Package.get(package_ref)\n    ret_dict = {'rating average': package.get_average_rating(),\n                'rating count': len(package.ratings)}\n    return ret_dict\n\n\ndef user_create(context, data_dict):\n    '''Create a new user.\n\n    You must be authorized to create users.\n\n    :param name: the name of the new user, a string between 2 and 100\n        characters in length, containing only lowercase alphanumeric\n        characters, ``-`` and ``_``\n    :type name: string\n    :param email: the email address for the new user\n    :type email: string\n    :param password: the password of the new user, a string of at least 4\n        characters\n    :type password: string\n    :param id: the id of the new user (optional)\n    :type id: string\n    :param fullname: the full name of the new user (optional)\n    :type fullname: string\n    :param about: a description of the new user (optional)\n    :type about: string\n\n    :returns: the newly created user\n    :rtype: dictionary\n\n    '''\n    model = context['model']\n    schema = context.get('schema') or ckan.logic.schema.default_user_schema()\n    session = context['session']\n\n    _check_access('user_create', context, data_dict)\n\n    data, errors = _validate(data_dict, schema, context)\n\n    if errors:\n        session.rollback()\n        raise ValidationError(errors)\n\n    # user schema prevents non-sysadmins from providing password_hash\n    if 'password_hash' in data:\n        data['_password'] = data.pop('password_hash')\n\n    user = model_save.user_dict_save(data, context)\n\n    # Flush the session to cause user.id to be initialised, because\n    # activity_create() (below) needs it.\n    session.flush()\n\n    activity_create_context = {\n        'model': model,\n        'user': context['user'],\n        'defer_commit': True,\n        'ignore_auth': True,\n        'session': session\n    }\n    activity_dict = {\n        'user_id': user.id,\n        'object_id': user.id,\n        'activity_type': 'new user',\n    }\n    logic.get_action('activity_create')(activity_create_context, activity_dict)\n\n    if not context.get('defer_commit'):\n        model.repo.commit()\n\n    # A new context is required for dictizing the newly constructed user in\n    # order that all the new user's data is returned, in particular, the\n    # api_key.\n    #\n    # The context is copied so as not to clobber the caller's context dict.\n    user_dictize_context = context.copy()\n    user_dictize_context['keep_apikey'] = True\n    user_dictize_context['keep_email'] = True\n    user_dict = model_dictize.user_dictize(user, user_dictize_context)\n\n    context['user_obj'] = user\n    context['id'] = user.id\n\n    model.Dashboard.get(user.id)  # Create dashboard for user.\n\n    log.debug('Created user {name}'.format(name=user.name))\n    return user_dict\n\n\ndef user_invite(context, data_dict):\n    '''Invite a new user.\n\n    You must be authorized to create group members.\n\n    :param email: the email of the user to be invited to the group\n    :type email: string\n    :param group_id: the id or name of the group\n    :type group_id: string\n    :param role: role of the user in the group. One of ``member``, ``editor``,\n        or ``admin``\n    :type role: string\n\n    :returns: the newly created user\n    :rtype: dictionary\n    '''\n    import string\n    _check_access('user_invite', context, data_dict)\n\n    schema = context.get('schema',\n                         ckan.logic.schema.default_user_invite_schema())\n    data, errors = _validate(data_dict, schema, context)\n    if errors:\n        raise ValidationError(errors)\n\n    model = context['model']\n    group = model.Group.get(data['group_id'])\n    if not group:\n        raise NotFound()\n\n    name = _get_random_username_from_email(data['email'])\n    # Choose a password. However it will not be used - the invitee will not be\n    # told it - they will need to reset it\n    while True:\n        password = ''.join(random.SystemRandom().choice(\n            string.ascii_lowercase + string.ascii_uppercase + string.digits)\n            for _ in range(12))\n        # Occasionally it won't meet the constraints, so check\n        errors = {}\n        logic.validators.user_password_validator(\n            'password', {'password': password}, errors, None)\n        if not errors:\n            break\n\n    data['name'] = name\n    data['password'] = password\n    data['state'] = ckan.model.State.PENDING\n    user_dict = _get_action('user_create')(context, data)\n    user = ckan.model.User.get(user_dict['id'])\n    member_dict = {\n        'username': user.id,\n        'id': data['group_id'],\n        'role': data['role']\n    }\n\n    if group.is_organization:\n        _get_action('organization_member_create')(context, member_dict)\n        group_dict = _get_action('organization_show')(context,\n                                                      {'id': data['group_id']})\n    else:\n        _get_action('group_member_create')(context, member_dict)\n        group_dict = _get_action('group_show')(context,\n                                               {'id': data['group_id']})\n    try:\n        mailer.send_invite(user, group_dict, data['role'])\n    except (socket_error, mailer.MailerException) as error:\n        # Email could not be sent, delete the pending user\n\n        _get_action('user_delete')(context, {'id': user.id})\n\n        msg = _('Error sending the invite email, ' +\n                'the user was not created: {0}').format(error)\n        raise ValidationError({'message': msg}, error_summary=msg)\n\n    return model_dictize.user_dictize(user, context)\n\n\ndef _get_random_username_from_email(email):\n    localpart = email.split('@')[0]\n    cleaned_localpart = re.sub(r'[^\\w]', '-', localpart).lower()\n\n    # if we can't create a unique user name within this many attempts\n    # then something else is probably wrong and we should give up\n    max_name_creation_attempts = 100\n\n    for i in range(max_name_creation_attempts):\n        random_number = random.SystemRandom().random() * 10000\n        name = '%s-%d' % (cleaned_localpart, random_number)\n        if not ckan.model.User.get(name):\n            return name\n\n    return cleaned_localpart\n\n\ndef vocabulary_create(context, data_dict):\n    '''Create a new tag vocabulary.\n\n    You must be a sysadmin to create vocabularies.\n\n    :param name: the name of the new vocabulary, e.g. ``'Genre'``\n    :type name: string\n    :param tags: the new tags to add to the new vocabulary, for the format of\n        tag dictionaries see :py:func:`tag_create`\n    :type tags: list of tag dictionaries\n\n    :returns: the newly-created vocabulary\n    :rtype: dictionary\n\n    '''\n    model = context['model']\n    schema = context.get('schema') or \\\n        ckan.logic.schema.default_create_vocabulary_schema()\n\n    _check_access('vocabulary_create', context, data_dict)\n\n    data, errors = _validate(data_dict, schema, context)\n\n    if errors:\n        model.Session.rollback()\n        raise ValidationError(errors)\n\n    vocabulary = model_save.vocabulary_dict_save(data, context)\n\n    if not context.get('defer_commit'):\n        model.repo.commit()\n\n    log.debug('Created Vocabulary %s' % vocabulary.name)\n\n    return model_dictize.vocabulary_dictize(vocabulary, context)\n\n\ndef activity_create(context, activity_dict, **kw):\n    '''Create a new activity stream activity.\n\n    You must be a sysadmin to create new activities.\n\n    :param user_id: the name or id of the user who carried out the activity,\n        e.g. ``'seanh'``\n    :type user_id: string\n    :param object_id: the name or id of the object of the activity, e.g.\n        ``'my_dataset'``\n    :param activity_type: the type of the activity, this must be an activity\n        type that CKAN knows how to render, e.g. ``'new package'``,\n        ``'changed user'``, ``'deleted group'`` etc.\n    :type activity_type: string\n    :param data: any additional data about the activity\n    :type data: dictionary\n\n    :returns: the newly created activity\n    :rtype: dictionary\n\n    '''\n\n    _check_access('activity_create', context, activity_dict)\n\n    # this action had a ignore_auth param which has been removed\n    # removed in 2.2\n    if 'ignore_auth' in kw:\n        raise Exception('Activity Stream calling parameters have changed '\n                        'ignore_auth must be passed in the context not as '\n                        'a param')\n\n    if not paste.deploy.converters.asbool(\n            config.get('ckan.activity_streams_enabled', 'true')):\n        return\n\n    model = context['model']\n\n    # Any revision_id that the caller attempts to pass in the activity_dict is\n    # ignored and overwritten here.\n    if getattr(model.Session, 'revision', None):\n        activity_dict['revision_id'] = model.Session.revision.id\n    else:\n        activity_dict['revision_id'] = None\n\n    schema = context.get('schema') or \\\n        ckan.logic.schema.default_create_activity_schema()\n\n    data, errors = _validate(activity_dict, schema, context)\n    if errors:\n        raise ValidationError(errors)\n\n    activity = model_save.activity_dict_save(data, context)\n\n    if not context.get('defer_commit'):\n        model.repo.commit()\n\n    log.debug(\"Created '%s' activity\" % activity.activity_type)\n    return model_dictize.activity_dictize(activity, context)\n\n\ndef tag_create(context, data_dict):\n    '''Create a new vocabulary tag.\n\n    You must be a sysadmin to create vocabulary tags.\n\n    You can only use this function to create tags that belong to a vocabulary,\n    not to create free tags. (To create a new free tag simply add the tag to\n    a package, e.g. using the\n    :py:func:`~ckan.logic.action.update.package_update` function.)\n\n    :param name: the name for the new tag, a string between 2 and 100\n        characters long containing only alphanumeric characters and ``-``,\n        ``_`` and ``.``, e.g. ``'Jazz'``\n    :type name: string\n    :param vocabulary_id: the id of the vocabulary that the new tag\n        should be added to, e.g. the id of vocabulary ``'Genre'``\n    :type vocabulary_id: string\n\n    :returns: the newly-created tag\n    :rtype: dictionary\n\n    '''\n    model = context['model']\n\n    _check_access('tag_create', context, data_dict)\n\n    schema = context.get('schema') or \\\n        ckan.logic.schema.default_create_tag_schema()\n    data, errors = _validate(data_dict, schema, context)\n    if errors:\n        raise ValidationError(errors)\n\n    tag = model_save.tag_dict_save(data_dict, context)\n\n    if not context.get('defer_commit'):\n        model.repo.commit()\n\n    log.debug(\"Created tag '%s' \" % tag)\n    return model_dictize.tag_dictize(tag, context)\n\n\ndef follow_user(context, data_dict):\n    '''Start following another user.\n\n    You must provide your API key in the Authorization header.\n\n    :param id: the id or name of the user to follow, e.g. ``'joeuser'``\n    :type id: string\n\n    :returns: a representation of the 'follower' relationship between yourself\n        and the other user\n    :rtype: dictionary\n\n    '''\n    if 'user' not in context:\n        raise logic.NotAuthorized(_(\"You must be logged in to follow users\"))\n\n    model = context['model']\n    session = context['session']\n\n    userobj = model.User.get(context['user'])\n    if not userobj:\n        raise logic.NotAuthorized(_(\"You must be logged in to follow users\"))\n\n    schema = (context.get('schema')\n              or ckan.logic.schema.default_follow_user_schema())\n\n    validated_data_dict, errors = _validate(data_dict, schema, context)\n\n    if errors:\n        model.Session.rollback()\n        raise ValidationError(errors)\n\n    # Don't let a user follow herself.\n    if userobj.id == validated_data_dict['id']:\n        message = _('You cannot follow yourself')\n        raise ValidationError({'message': message}, error_summary=message)\n\n    # Don't let a user follow someone she is already following.\n    if model.UserFollowingUser.is_following(userobj.id,\n                                            validated_data_dict['id']):\n        followeduserobj = model.User.get(validated_data_dict['id'])\n        name = followeduserobj.display_name\n        message = _('You are already following {0}').format(name)\n        raise ValidationError({'message': message}, error_summary=message)\n\n    follower = model_save.follower_dict_save(\n        validated_data_dict, context, model.UserFollowingUser)\n\n    if not context.get('defer_commit'):\n        model.repo.commit()\n\n    log.debug(u'User {follower} started following user {object}'.format(\n        follower=follower.follower_id, object=follower.object_id))\n\n    return model_dictize.user_following_user_dictize(follower, context)\n\n\ndef follow_dataset(context, data_dict):\n    '''Start following a dataset.\n\n    You must provide your API key in the Authorization header.\n\n    :param id: the id or name of the dataset to follow, e.g. ``'warandpeace'``\n    :type id: string\n\n    :returns: a representation of the 'follower' relationship between yourself\n        and the dataset\n    :rtype: dictionary\n\n    '''\n\n    if 'user' not in context:\n        raise logic.NotAuthorized(\n            _(\"You must be logged in to follow a dataset.\"))\n\n    model = context['model']\n    session = context['session']\n\n    userobj = model.User.get(context['user'])\n    if not userobj:\n        raise logic.NotAuthorized(\n            _(\"You must be logged in to follow a dataset.\"))\n\n    schema = (context.get('schema')\n              or ckan.logic.schema.default_follow_dataset_schema())\n\n    validated_data_dict, errors = _validate(data_dict, schema, context)\n\n    if errors:\n        model.Session.rollback()\n        raise ValidationError(errors)\n\n    # Don't let a user follow a dataset she is already following.\n    if model.UserFollowingDataset.is_following(userobj.id,\n                                               validated_data_dict['id']):\n        # FIXME really package model should have this logic and provide\n        # 'display_name' like users and groups\n        pkgobj = model.Package.get(validated_data_dict['id'])\n        name = pkgobj.title or pkgobj.name or pkgobj.id\n        message = _(\n            'You are already following {0}').format(name)\n        raise ValidationError({'message': message}, error_summary=message)\n\n    follower = model_save.follower_dict_save(validated_data_dict, context,\n                                             model.UserFollowingDataset)\n\n    if not context.get('defer_commit'):\n        model.repo.commit()\n\n    log.debug(u'User {follower} started following dataset {object}'.format(\n        follower=follower.follower_id, object=follower.object_id))\n\n    return model_dictize.user_following_dataset_dictize(follower, context)\n\n\ndef _group_or_org_member_create(context, data_dict, is_org=False):\n    # creator of group/org becomes an admin\n    # this needs to be after the repo.commit or else revisions break\n    model = context['model']\n    user = context['user']\n    session = context['session']\n\n    schema = ckan.logic.schema.member_schema()\n    data, errors = _validate(data_dict, schema, context)\n    if errors:\n        model.Session.rollback()\n        raise ValidationError(errors)\n\n    username = _get_or_bust(data_dict, 'username')\n    role = data_dict.get('role')\n    group_id = data_dict.get('id')\n    group = model.Group.get(group_id)\n    if not group:\n        msg = _('Organization not found') if is_org else _('Group not found')\n        raise NotFound(msg)\n    result = model.User.get(username)\n    if result:\n        user_id = result.id\n    else:\n        message = _(u'User {username} does not exist.').format(\n            username=username)\n        raise ValidationError({'message': message}, error_summary=message)\n    member_dict = {\n        'id': group.id,\n        'object': user_id,\n        'object_type': 'user',\n        'capacity': role,\n    }\n    member_create_context = {\n        'model': model,\n        'user': user,\n        'session': session,\n        'ignore_auth': context.get('ignore_auth'),\n    }\n    return logic.get_action('member_create')(member_create_context,\n                                             member_dict)\n\n\ndef group_member_create(context, data_dict):\n    '''Make a user a member of a group.\n\n    You must be authorized to edit the group.\n\n    :param id: the id or name of the group\n    :type id: string\n    :param username: name or id of the user to be made member of the group\n    :type username: string\n    :param role: role of the user in the group. One of ``member``, ``editor``,\n        or ``admin``\n    :type role: string\n\n    :returns: the newly created (or updated) membership\n    :rtype: dictionary\n    '''\n    _check_access('group_member_create', context, data_dict)\n    return _group_or_org_member_create(context, data_dict)\n\n\ndef organization_member_create(context, data_dict):\n    '''Make a user a member of an organization.\n\n    You must be authorized to edit the organization.\n\n    :param id: the id or name of the organization\n    :type id: string\n    :param username: name or id of the user to be made member of the\n        organization\n    :type username: string\n    :param role: role of the user in the organization. One of ``member``,\n        ``editor``, or ``admin``\n    :type role: string\n\n    :returns: the newly created (or updated) membership\n    :rtype: dictionary\n    '''\n    _check_access('organization_member_create', context, data_dict)\n    return _group_or_org_member_create(context, data_dict, is_org=True)\n\n\ndef follow_group(context, data_dict):\n    '''Start following a group.\n\n    You must provide your API key in the Authorization header.\n\n    :param id: the id or name of the group to follow, e.g. ``'roger'``\n    :type id: string\n\n    :returns: a representation of the 'follower' relationship between yourself\n        and the group\n    :rtype: dictionary\n\n    '''\n    if 'user' not in context:\n        raise logic.NotAuthorized(\n            _(\"You must be logged in to follow a group.\"))\n\n    model = context['model']\n    session = context['session']\n\n    userobj = model.User.get(context['user'])\n    if not userobj:\n        raise logic.NotAuthorized(\n            _(\"You must be logged in to follow a group.\"))\n\n    schema = context.get('schema',\n                         ckan.logic.schema.default_follow_group_schema())\n\n    validated_data_dict, errors = _validate(data_dict, schema, context)\n\n    if errors:\n        model.Session.rollback()\n        raise ValidationError(errors)\n\n    # Don't let a user follow a group she is already following.\n    if model.UserFollowingGroup.is_following(userobj.id,\n                                             validated_data_dict['id']):\n        groupobj = model.Group.get(validated_data_dict['id'])\n        name = groupobj.display_name\n        message = _(\n            'You are already following {0}').format(name)\n        raise ValidationError({'message': message}, error_summary=message)\n\n    follower = model_save.follower_dict_save(validated_data_dict, context,\n                                             model.UserFollowingGroup)\n\n    if not context.get('defer_commit'):\n        model.repo.commit()\n\n    log.debug(u'User {follower} started following group {object}'.format(\n        follower=follower.follower_id, object=follower.object_id))\n\n    return model_dictize.user_following_group_dictize(follower, context)\n", "# encoding: utf-8\n\n'''Unit tests for ckan/logic/auth/create.py.\n\n'''\nimport __builtin__ as builtins\n\nimport ckan\nimport ckan.logic as logic\nimport ckan.model as model\nimport ckan.plugins as p\nimport ckan.tests.factories as factories\nimport ckan.tests.helpers as helpers\nimport mock\nimport nose.tools\nfrom ckan.common import config\nfrom pyfakefs import fake_filesystem\n\nassert_equals = nose.tools.assert_equals\nassert_raises = nose.tools.assert_raises\nassert_not_equals = nose.tools.assert_not_equals\n\nreal_open = open\nfs = fake_filesystem.FakeFilesystem()\nfake_os = fake_filesystem.FakeOsModule(fs)\nfake_open = fake_filesystem.FakeFileOpen(fs)\n\n\ndef mock_open_if_open_fails(*args, **kwargs):\n    try:\n        return real_open(*args, **kwargs)\n    except (OSError, IOError):\n        return fake_open(*args, **kwargs)\n\n\nclass TestUserInvite(object):\n\n    def setup(self):\n        helpers.reset_db()\n\n    @mock.patch('ckan.lib.mailer.send_invite')\n    def test_invited_user_is_created_as_pending(self, _):\n        invited_user = self._invite_user_to_group()\n\n        assert invited_user is not None\n        assert invited_user.is_pending()\n\n    @mock.patch('ckan.lib.mailer.send_invite')\n    def test_creates_user_with_valid_username(self, _):\n        email = 'user$%+abc@email.com'\n        invited_user = self._invite_user_to_group(email)\n\n        assert invited_user.name.startswith('user---abc'), invited_user\n\n    @mock.patch('ckan.lib.mailer.send_invite')\n    def test_assigns_user_to_group_in_expected_role(self, _):\n        role = 'admin'\n        invited_user = self._invite_user_to_group(role=role)\n\n        group_ids = invited_user.get_group_ids(capacity=role)\n        assert len(group_ids) == 1, group_ids\n\n    @mock.patch('ckan.lib.mailer.send_invite')\n    def test_sends_invite(self, send_invite):\n        invited_user = self._invite_user_to_group()\n\n        assert send_invite.called\n        assert send_invite.call_args[0][0].id == invited_user.id\n\n    @mock.patch('ckan.lib.mailer.send_invite')\n    @mock.patch('random.SystemRandom')\n    def test_works_even_if_username_already_exists(self, rand, _):\n        # usernames\n        rand.return_value.random.side_effect = [1000, 1000, 2000, 3000]\n        # passwords (need to set something, otherwise choice will break)\n        rand.return_value.choice.side_effect = 'TestPassword1' * 3\n\n        for _ in range(3):\n            invited_user = self._invite_user_to_group(email='same@email.com')\n            assert invited_user is not None, invited_user\n\n    @mock.patch('ckan.lib.mailer.send_invite')\n    @nose.tools.raises(logic.ValidationError)\n    def test_requires_email(self, _):\n        self._invite_user_to_group(email=None)\n\n    @mock.patch('ckan.lib.mailer.send_invite')\n    @nose.tools.raises(logic.ValidationError)\n    def test_requires_role(self, _):\n        self._invite_user_to_group(role=None)\n\n    @mock.patch('ckan.lib.mailer.send_invite')\n    @nose.tools.raises(logic.NotFound)\n    def test_raises_not_found(self, _):\n        user = factories.User()\n\n        context = {\n            'user': user['name']\n        }\n        params = {\n            'email': 'a@example.com',\n            'group_id': 'group_not_found',\n            'role': 'admin'\n        }\n\n        helpers.call_action('user_invite', context, **params)\n\n    @mock.patch('ckan.lib.mailer.send_invite')\n    @nose.tools.raises(logic.ValidationError)\n    def test_requires_group_id(self, _):\n        self._invite_user_to_group(group={'id': None})\n\n    @mock.patch('ckan.lib.mailer.send_invite')\n    def test_user_name_lowercase_when_email_is_uppercase(self, _):\n        invited_user = self._invite_user_to_group(email='Maria@example.com')\n\n        assert_equals(invited_user.name.split('-')[0], 'maria')\n\n    @helpers.change_config('smtp.server', 'email.example.com')\n    def test_smtp_error_returns_error_message(self):\n\n        sysadmin = factories.Sysadmin()\n        group = factories.Group()\n\n        context = {\n            'user': sysadmin['name']\n        }\n        params = {\n            'email': 'example-invited-user@example.com',\n            'group_id': group['id'],\n            'role': 'editor'\n        }\n\n        assert_raises(logic.ValidationError, helpers.call_action,\n                      'user_invite', context, **params)\n\n        # Check that the pending user was deleted\n        user = model.Session.query(model.User).filter(\n            model.User.name.like('example-invited-user%')).all()\n\n        assert_equals(user[0].state, 'deleted')\n\n    def _invite_user_to_group(self, email='user@email.com',\n                              group=None, role='member'):\n        user = factories.User()\n        group = group or factories.Group(user=user)\n\n        context = {\n            'user': user['name']\n        }\n        params = {\n            'email': email,\n            'group_id': group['id'],\n            'role': role\n        }\n\n        result = helpers.call_action('user_invite', context, **params)\n\n        return model.User.get(result['id'])\n\n\nclass TestResourceViewCreate(object):\n\n    @classmethod\n    def setup_class(cls):\n        if not p.plugin_loaded('image_view'):\n            p.load('image_view')\n\n    @classmethod\n    def teardown_class(cls):\n        p.unload('image_view')\n        helpers.reset_db()\n\n    def setup(self):\n        helpers.reset_db()\n\n    def test_resource_view_create(self):\n        context = {}\n        params = self._default_resource_view_attributes()\n\n        result = helpers.call_action('resource_view_create', context, **params)\n\n        result.pop('id')\n        result.pop('package_id')\n\n        assert_equals(params, result)\n\n    def test_requires_resource_id(self):\n        context = {}\n        params = self._default_resource_view_attributes()\n        params.pop('resource_id')\n\n        assert_raises(logic.ValidationError, helpers.call_action,\n                      'resource_view_create', context, **params)\n\n    def test_requires_title(self):\n        context = {}\n        params = self._default_resource_view_attributes()\n        params.pop('title')\n\n        assert_raises(logic.ValidationError, helpers.call_action,\n                      'resource_view_create', context, **params)\n\n    @mock.patch('ckan.lib.datapreview.get_view_plugin')\n    def test_requires_view_type(self, get_view_plugin):\n        context = {}\n        params = self._default_resource_view_attributes()\n        params.pop('view_type')\n\n        get_view_plugin.return_value = 'mock_view_plugin'\n\n        assert_raises(logic.ValidationError, helpers.call_action,\n                      'resource_view_create', context, **params)\n\n    def test_raises_if_couldnt_find_resource(self):\n        context = {}\n        params = self._default_resource_view_attributes(resource_id='unknown')\n        assert_raises(logic.ValidationError, helpers.call_action,\n                      'resource_view_create', context, **params)\n\n    def test_raises_if_couldnt_find_view_extension(self):\n        context = {}\n        params = self._default_resource_view_attributes(view_type='unknown')\n        assert_raises(logic.ValidationError, helpers.call_action,\n                      'resource_view_create', context, **params)\n\n    @mock.patch('ckan.lib.datapreview')\n    def test_filterable_views_dont_require_any_extra_fields(self, datapreview_mock):\n        self._configure_datapreview_to_return_filterable_view(datapreview_mock)\n        context = {}\n        params = self._default_resource_view_attributes()\n\n        result = helpers.call_action('resource_view_create', context, **params)\n\n        result.pop('id')\n        result.pop('package_id')\n\n        assert_equals(params, result)\n\n    @mock.patch('ckan.lib.datapreview')\n    def test_filterable_views_converts_filter_fields_and_values_into_filters_dict(self, datapreview_mock):\n        self._configure_datapreview_to_return_filterable_view(datapreview_mock)\n        context = {}\n        filters = {\n            'filter_fields': ['country', 'weather', 'country'],\n            'filter_values': ['Brazil', 'warm', 'Argentina']\n        }\n        params = self._default_resource_view_attributes(**filters)\n        result = helpers.call_action('resource_view_create', context, **params)\n        expected_filters = {\n            'country': ['Brazil', 'Argentina'],\n            'weather': ['warm']\n        }\n        assert_equals(result['filters'], expected_filters)\n\n    @mock.patch('ckan.lib.datapreview')\n    def test_filterable_views_converts_filter_fields_and_values_to_list(self, datapreview_mock):\n        self._configure_datapreview_to_return_filterable_view(datapreview_mock)\n        context = {}\n        filters = {\n            'filter_fields': 'country',\n            'filter_values': 'Brazil'\n        }\n        params = self._default_resource_view_attributes(**filters)\n        result = helpers.call_action('resource_view_create', context, **params)\n        assert_equals(result['filter_fields'], ['country'])\n        assert_equals(result['filter_values'], ['Brazil'])\n        assert_equals(result['filters'], {'country': ['Brazil']})\n\n    @mock.patch('ckan.lib.datapreview')\n    def test_filterable_views_require_filter_fields_and_values_to_have_same_length(self, datapreview_mock):\n        self._configure_datapreview_to_return_filterable_view(datapreview_mock)\n        context = {}\n        filters = {\n            'filter_fields': ['country', 'country'],\n            'filter_values': 'Brazil'\n        }\n        params = self._default_resource_view_attributes(**filters)\n        assert_raises(logic.ValidationError, helpers.call_action,\n                      'resource_view_create', context, **params)\n\n    def test_non_filterable_views_dont_accept_filter_fields_and_values(self):\n        context = {}\n        filters = {\n            'filter_fields': 'country',\n            'filter_values': 'Brazil'\n        }\n        params = self._default_resource_view_attributes(**filters)\n        assert_raises(logic.ValidationError, helpers.call_action,\n                      'resource_view_create', context, **params)\n\n    def _default_resource_view_attributes(self, **kwargs):\n        default_attributes = {\n            'resource_id': factories.Resource()['id'],\n            'view_type': 'image_view',\n            'title': 'View',\n            'description': 'A nice view'\n        }\n\n        default_attributes.update(kwargs)\n\n        return default_attributes\n\n    def _configure_datapreview_to_return_filterable_view(self, datapreview_mock):\n        filterable_view = mock.MagicMock()\n        filterable_view.info.return_value = {'filterable': True}\n        datapreview_mock.get_view_plugin.return_value = filterable_view\n\n\nclass TestCreateDefaultResourceViews(object):\n\n    @classmethod\n    def setup_class(cls):\n        if not p.plugin_loaded('image_view'):\n            p.load('image_view')\n\n    @classmethod\n    def teardown_class(cls):\n        p.unload('image_view')\n\n        helpers.reset_db()\n\n    def setup(self):\n        helpers.reset_db()\n\n    @helpers.change_config('ckan.views.default_views', '')\n    def test_add_default_views_to_dataset_resources(self):\n\n        # New resources have no views\n        dataset_dict = factories.Dataset(resources=[\n            {\n                'url': 'http://some.image.png',\n                'format': 'png',\n                'name': 'Image 1',\n            },\n            {\n                'url': 'http://some.image.png',\n                'format': 'png',\n                'name': 'Image 2',\n            },\n        ])\n\n        # Change default views config setting\n        config['ckan.views.default_views'] = 'image_view'\n\n        context = {\n            'user': helpers.call_action('get_site_user')['name']\n        }\n        created_views = helpers.call_action(\n            'package_create_default_resource_views',\n            context,\n            package=dataset_dict)\n\n        assert_equals(len(created_views), 2)\n\n        assert_equals(created_views[0]['view_type'], 'image_view')\n        assert_equals(created_views[1]['view_type'], 'image_view')\n\n    @helpers.change_config('ckan.views.default_views', '')\n    def test_add_default_views_to_resource(self):\n\n        # New resources have no views\n        dataset_dict = factories.Dataset()\n        resource_dict = factories.Resource(\n            package_id=dataset_dict['id'],\n            url='http://some.image.png',\n            format='png',\n        )\n\n        # Change default views config setting\n        config['ckan.views.default_views'] = 'image_view'\n\n        context = {\n            'user': helpers.call_action('get_site_user')['name']\n        }\n        created_views = helpers.call_action(\n            'resource_create_default_resource_views',\n            context,\n            resource=resource_dict,\n            package=dataset_dict)\n\n        assert_equals(len(created_views), 1)\n\n        assert_equals(created_views[0]['view_type'], 'image_view')\n\n    @helpers.change_config('ckan.views.default_views', '')\n    def test_add_default_views_to_resource_no_dataset_passed(self):\n\n        # New resources have no views\n        dataset_dict = factories.Dataset()\n        resource_dict = factories.Resource(\n            package_id=dataset_dict['id'],\n            url='http://some.image.png',\n            format='png',\n        )\n\n        # Change default views config setting\n        config['ckan.views.default_views'] = 'image_view'\n\n        context = {\n            'user': helpers.call_action('get_site_user')['name']\n        }\n        created_views = helpers.call_action(\n            'resource_create_default_resource_views',\n            context,\n            resource=resource_dict)\n\n        assert_equals(len(created_views), 1)\n\n        assert_equals(created_views[0]['view_type'], 'image_view')\n\n\nclass TestResourceCreate(object):\n    import cgi\n\n    class FakeFileStorage(cgi.FieldStorage):\n        def __init__(self, fp, filename):\n            self.file = fp\n            self.filename = filename\n            self.name = 'upload'\n\n    @classmethod\n    def setup_class(cls):\n        helpers.reset_db()\n\n    def setup(self):\n        model.repo.rebuild_db()\n\n    def test_resource_create(self):\n        context = {}\n        params = {\n            'package_id': factories.Dataset()['id'],\n            'url': 'http://data',\n            'name': 'A nice resource',\n        }\n        result = helpers.call_action('resource_create', context, **params)\n\n        id = result.pop('id')\n\n        assert id\n\n        params.pop('package_id')\n        for key in params.keys():\n            assert_equals(params[key], result[key])\n\n    def test_it_requires_package_id(self):\n\n        data_dict = {\n            'url': 'http://data',\n        }\n\n        assert_raises(logic.ValidationError, helpers.call_action,\n                      'resource_create', **data_dict)\n\n    def test_doesnt_require_url(self):\n        user = factories.User()\n        dataset = factories.Dataset(user=user)\n        data_dict = {\n            'package_id': dataset['id']\n        }\n        new_resouce = helpers.call_action('resource_create', **data_dict)\n\n        data_dict = {\n            'id': new_resouce['id']\n        }\n        stored_resource = helpers.call_action('resource_show', **data_dict)\n\n        assert not stored_resource['url']\n\n    @helpers.change_config('ckan.storage_path', '/doesnt_exist')\n    @mock.patch.object(ckan.lib.uploader, 'os', fake_os)\n    @mock.patch.object(builtins, 'open', side_effect=mock_open_if_open_fails)\n    @mock.patch.object(ckan.lib.uploader, '_storage_path', new='/doesnt_exist')\n    def test_mimetype_by_url(self, mock_open):\n        '''\n        The mimetype is guessed from the url\n\n        Real world usage would be externally linking the resource and the mimetype would\n        be guessed, based on the url\n        '''\n        context = {}\n        params = {\n            'package_id': factories.Dataset()['id'],\n            'url': 'http://localhost/data.csv',\n            'name': 'A nice resource',\n        }\n        result = helpers.call_action('resource_create', context, **params)\n\n        mimetype = result.pop('mimetype')\n\n        assert mimetype\n        assert_equals(mimetype, 'text/csv')\n\n    def test_mimetype_by_url_without_path(self):\n        \"\"\"\n        The mimetype should not be guessed from url if url contains only domain\n        \"\"\"\n        context = {}\n        params = {\n            \"package_id\": factories.Dataset()[\"id\"],\n            \"url\": \"http://example.com\",\n            \"name\": \"A nice resource\",\n        }\n        result = helpers.call_action(\"resource_create\", context, **params)\n\n        mimetype = result.pop(\"mimetype\")\n        assert mimetype is None\n\n    def test_mimetype_by_user(self):\n        '''\n        The mimetype is supplied by the user\n\n        Real world usage would be using the FileStore API or web UI form to create a resource\n        and the user wanted to specify the mimetype themselves\n        '''\n        context = {}\n        params = {\n            'package_id': factories.Dataset()['id'],\n            'url': 'http://localhost/data.csv',\n            'name': 'A nice resource',\n            'mimetype': 'application/csv'\n        }\n        result = helpers.call_action('resource_create', context, **params)\n\n        mimetype = result.pop('mimetype')\n        assert_equals(mimetype, 'application/csv')\n\n    @helpers.change_config('ckan.storage_path', '/doesnt_exist')\n    @mock.patch.object(ckan.lib.uploader, 'os', fake_os)\n    @mock.patch.object(builtins, 'open', side_effect=mock_open_if_open_fails)\n    @mock.patch.object(ckan.lib.uploader, '_storage_path', new='/doesnt_exist')\n    def test_mimetype_by_upload_by_filename(self, mock_open):\n        '''\n        The mimetype is guessed from an uploaded file with a filename\n\n        Real world usage would be using the FileStore API or web UI form to upload a file, with a filename plus extension\n        If there's no url or the mimetype can't be guessed by the url, mimetype will be guessed by the extension in the filename\n        '''\n        import StringIO\n        test_file = StringIO.StringIO()\n        test_file.write('''\n        \"info\": {\n            \"title\": \"BC Data Catalogue API\",\n            \"description\": \"This API provides information about datasets in the BC Data Catalogue.\",\n            \"termsOfService\": \"http://www.data.gov.bc.ca/local/dbc/docs/license/API_Terms_of_Use.pdf\",\n            \"contact\": {\n                \"name\": \"Data BC\",\n                \"url\": \"http://data.gov.bc.ca/\",\n                \"email\": \"\"\n            },\n            \"license\": {\n                \"name\": \"Open Government License - British Columbia\",\n                \"url\": \"http://www.data.gov.bc.ca/local/dbc/docs/license/OGL-vbc2.0.pdf\"\n            },\n            \"version\": \"3.0.0\"\n        }\n        ''')\n        test_resource = TestResourceCreate.FakeFileStorage(test_file, 'test.json')\n\n        context = {}\n        params = {\n            'package_id': factories.Dataset()['id'],\n            'url': 'http://data',\n            'name': 'A nice resource',\n            'upload': test_resource\n        }\n\n        # Mock url_for as using a test request context interferes with the FS mocking\n        with mock.patch('ckan.lib.helpers.url_for'):\n            result = helpers.call_action('resource_create', context, **params)\n\n        mimetype = result.pop('mimetype')\n\n        assert mimetype\n        assert_equals(mimetype, 'application/json')\n\n    @helpers.change_config('ckan.mimetype_guess', 'file_contents')\n    @helpers.change_config('ckan.storage_path', '/doesnt_exist')\n    @mock.patch.object(ckan.lib.uploader, 'os', fake_os)\n    @mock.patch.object(builtins, 'open', side_effect=mock_open_if_open_fails)\n    @mock.patch.object(ckan.lib.uploader, '_storage_path', new='/doesnt_exist')\n    def test_mimetype_by_upload_by_file(self, mock_open):\n        '''\n        The mimetype is guessed from an uploaded file by the contents inside\n\n        Real world usage would be using the FileStore API or web UI form to upload a file, that has no extension\n        If the mimetype can't be guessed by the url or filename, mimetype will be guessed by the contents inside the file\n        '''\n        import StringIO\n        test_file = StringIO.StringIO()\n        test_file.write('''\n        Snow Course Name, Number, Elev. metres, Date of Survey, Snow Depth cm, Water Equiv. mm, Survey Code, % of Normal, Density %, Survey Period, Normal mm\n        SKINS LAKE,1B05,890,2015/12/30,34,53,,98,16,JAN-01,54\n        MCGILLIVRAY PASS,1C05,1725,2015/12/31,88,239,,87,27,JAN-01,274\n        NAZKO,1C08,1070,2016/01/05,20,31,,76,16,JAN-01,41\n        ''')\n        test_resource = TestResourceCreate.FakeFileStorage(test_file, '')\n\n        context = {}\n        params = {\n            'package_id': factories.Dataset()['id'],\n            'url': 'http://data',\n            'name': 'A nice resource',\n            'upload': test_resource\n        }\n\n        # Mock url_for as using a test request context interferes with the FS mocking\n        with mock.patch('ckan.lib.helpers.url_for'):\n            result = helpers.call_action('resource_create', context, **params)\n\n        mimetype = result.pop('mimetype')\n\n        assert mimetype\n        assert_equals(mimetype, 'text/plain')\n\n    @helpers.change_config('ckan.storage_path', '/doesnt_exist')\n    @mock.patch.object(ckan.lib.uploader, 'os', fake_os)\n    @mock.patch.object(builtins, 'open', side_effect=mock_open_if_open_fails)\n    @mock.patch.object(ckan.lib.uploader, '_storage_path', new='/doesnt_exist')\n    def test_size_of_resource_by_upload(self, mock_open):\n        '''\n        The size of the resource determined by the uploaded file\n        '''\n        import StringIO\n        test_file = StringIO.StringIO()\n        test_file.write('''\n        Snow Course Name, Number, Elev. metres, Date of Survey, Snow Depth cm, Water Equiv. mm, Survey Code, % of Normal, Density %, Survey Period, Normal mm\n        SKINS LAKE,1B05,890,2015/12/30,34,53,,98,16,JAN-01,54\n        MCGILLIVRAY PASS,1C05,1725,2015/12/31,88,239,,87,27,JAN-01,274\n        NAZKO,1C08,1070,2016/01/05,20,31,,76,16,JAN-01,41\n        ''')\n        test_resource = TestResourceCreate.FakeFileStorage(test_file, 'test.csv')\n\n        context = {}\n        params = {\n            'package_id': factories.Dataset()['id'],\n            'url': 'http://data',\n            'name': 'A nice resource',\n            'upload': test_resource\n        }\n\n        # Mock url_for as using a test request context interferes with the FS mocking\n        with mock.patch('ckan.lib.helpers.url_for'):\n            result = helpers.call_action('resource_create', context, **params)\n\n        size = result.pop('size')\n\n        assert size\n        assert size > 0\n\n    def test_size_of_resource_by_user(self):\n        '''\n        The size of the resource is provided by the users\n\n        Real world usage would be using the FileStore API and the user provides a size for the resource\n        '''\n        context = {}\n        params = {\n            'package_id': factories.Dataset()['id'],\n            'url': 'http://data',\n            'name': 'A nice resource',\n            'size': 500\n        }\n        result = helpers.call_action('resource_create', context, **params)\n\n        size = int(result.pop('size'))\n        assert_equals(size, 500)\n\n    def test_extras(self):\n        user = factories.User()\n        dataset = factories.Dataset(\n            user=user)\n\n        resource = helpers.call_action(\n            \"resource_create\",\n            package_id=dataset[\"id\"],\n            somekey=\"somevalue\",  # this is how to do resource extras\n            extras={u\"someotherkey\": u\"alt234\"},  # this isnt\n            subobject={u'hello': u'there'},  # JSON objects supported\n            sublist=[1, 2, 3],  # JSON lists suppoted\n            format=u\"plain text\",\n            url=u\"http://datahub.io/download/\",\n        )\n\n        assert resource[\"somekey\"] == \"somevalue\"\n        assert \"extras\" not in resource\n        assert \"someotherkey\" not in resource\n        assert resource[\"subobject\"] == {u\"hello\": u\"there\"}\n        assert resource[\"sublist\"] == [1, 2, 3]\n        resource = helpers.call_action(\"package_show\", id=dataset[\"id\"])[\n            \"resources\"\n        ][0]\n        assert resource[\"somekey\"] == \"somevalue\"\n        assert \"extras\" not in resource\n        assert \"someotherkey\" not in resource\n        assert resource[\"subobject\"] == {u\"hello\": u\"there\"}\n        assert resource[\"sublist\"] == [1, 2, 3]\n\n\nclass TestMemberCreate(object):\n    @classmethod\n    def setup_class(cls):\n        helpers.reset_db()\n\n    def setup(self):\n        model.repo.rebuild_db()\n\n    def test_group_member_creation(self):\n        user = factories.User()\n        group = factories.Group()\n\n        new_membership = helpers.call_action(\n            'group_member_create',\n            id=group['id'],\n            username=user['name'],\n            role='member',\n        )\n\n        assert_equals(new_membership['group_id'], group['id'])\n        assert_equals(new_membership['table_name'], 'user')\n        assert_equals(new_membership['table_id'], user['id'])\n        assert_equals(new_membership['capacity'], 'member')\n\n    def test_organization_member_creation(self):\n        user = factories.User()\n        organization = factories.Organization()\n\n        new_membership = helpers.call_action(\n            'organization_member_create',\n            id=organization['id'],\n            username=user['name'],\n            role='member',\n        )\n\n        assert_equals(new_membership['group_id'], organization['id'])\n        assert_equals(new_membership['table_name'], 'user')\n        assert_equals(new_membership['table_id'], user['id'])\n        assert_equals(new_membership['capacity'], 'member')\n\n    def test_group_member_creation_raises_validation_error_if_id_missing(self):\n\n        assert_raises(logic.ValidationError,\n                      helpers.call_action, 'group_member_create',\n                      username='someuser',\n                      role='member',)\n\n    def test_group_member_creation_raises_validation_error_if_username_missing(self):\n\n        assert_raises(logic.ValidationError,\n                      helpers.call_action, 'group_member_create',\n                      id='someid',\n                      role='member',)\n\n    def test_group_member_creation_raises_validation_error_if_role_missing(self):\n\n        assert_raises(logic.ValidationError,\n                      helpers.call_action, 'group_member_create',\n                      id='someid',\n                      username='someuser',)\n\n    def test_org_member_creation_raises_validation_error_if_id_missing(self):\n\n        assert_raises(logic.ValidationError,\n                      helpers.call_action, 'organization_member_create',\n                      username='someuser',\n                      role='member',)\n\n    def test_org_member_creation_raises_validation_error_if_username_missing(self):\n\n        assert_raises(logic.ValidationError,\n                      helpers.call_action, 'organization_member_create',\n                      id='someid',\n                      role='member',)\n\n    def test_org_member_creation_raises_validation_error_if_role_missing(self):\n\n        assert_raises(logic.ValidationError,\n                      helpers.call_action, 'organization_member_create',\n                      id='someid',\n                      username='someuser',)\n\n\nclass TestDatasetCreate(helpers.FunctionalTestBase):\n\n    def test_normal_user_cant_set_id(self):\n        user = factories.User()\n        context = {\n            'user': user['name'],\n            'ignore_auth': False,\n        }\n        assert_raises(\n            logic.ValidationError,\n            helpers.call_action,\n            'package_create',\n            context=context,\n            id='1234',\n            name='test-dataset',\n        )\n\n    def test_sysadmin_can_set_id(self):\n        user = factories.Sysadmin()\n        context = {\n            'user': user['name'],\n            'ignore_auth': False,\n        }\n        dataset = helpers.call_action(\n            'package_create',\n            context=context,\n            id='1234',\n            name='test-dataset',\n        )\n        assert_equals(dataset['id'], '1234')\n\n    def test_id_cant_already_exist(self):\n        dataset = factories.Dataset()\n        user = factories.Sysadmin()\n        assert_raises(\n            logic.ValidationError,\n            helpers.call_action,\n            'package_create',\n            id=dataset['id'],\n            name='test-dataset',\n        )\n\n    def test_name_not_changed_during_deletion(self):\n        dataset = factories.Dataset()\n        helpers.call_action('package_delete', id=dataset['id'])\n        deleted_dataset = helpers.call_action('package_show', id=dataset['id'])\n        assert_equals(deleted_dataset['name'], dataset['name'])\n\n    def test_name_not_changed_after_restoring(self):\n        dataset = factories.Dataset()\n        context = {\n            'user': factories.Sysadmin()['name']\n        }\n        helpers.call_action('package_delete', id=dataset['id'])\n        deleted_dataset = helpers.call_action('package_show', id=dataset['id'])\n        restored_dataset = helpers.call_action(\n            'package_patch', context=context, id=dataset['id'], state='active')\n        assert_equals(deleted_dataset['name'], restored_dataset['name'])\n        assert_equals(deleted_dataset['id'], restored_dataset['id'])\n\n    def test_creation_of_dataset_with_name_same_as_of_previously_removed(self):\n        dataset = factories.Dataset()\n        initial_name = dataset['name']\n        helpers.call_action('package_delete', id=dataset['id'])\n        new_dataset = helpers.call_action(\n            'package_create',\n            name=initial_name\n        )\n        assert_equals(new_dataset['name'], initial_name)\n        deleted_dataset = helpers.call_action('package_show', id=dataset['id'])\n\n        assert_not_equals(new_dataset['id'], deleted_dataset['id'])\n        assert_equals(deleted_dataset['name'], deleted_dataset['id'])\n\n    def test_missing_id(self):\n        assert_raises(\n            logic.ValidationError, helpers.call_action,\n            'package_create'\n        )\n\n    def test_name(self):\n        dataset = helpers.call_action(\n            'package_create',\n            name='some-name',\n        )\n\n        assert_equals(dataset['name'], 'some-name')\n        assert_equals(\n            helpers.call_action('package_show', id=dataset['id'])['name'],\n            'some-name')\n\n    def test_title(self):\n        dataset = helpers.call_action(\n            'package_create',\n            name='test_title',\n            title='New Title',\n        )\n\n        assert_equals(dataset['title'], 'New Title')\n        assert_equals(\n            helpers.call_action('package_show', id=dataset['id'])['title'],\n            'New Title')\n\n    def test_extras(self):\n        dataset = helpers.call_action(\n            'package_create',\n            name='test-extras',\n            title='Test Extras',\n            extras=[{'key': u'original media',\n                     'value': u'\"book\"'}],\n        )\n\n        assert_equals(dataset['extras'][0]['key'], 'original media')\n        assert_equals(dataset['extras'][0]['value'], '\"book\"')\n        dataset = helpers.call_action('package_show', id=dataset['id'])\n        assert_equals(dataset['extras'][0]['key'], 'original media')\n        assert_equals(dataset['extras'][0]['value'], '\"book\"')\n\n    def test_license(self):\n        dataset = helpers.call_action(\n            'package_create',\n            name='test-license',\n            title='Test License',\n            license_id='other-open',\n        )\n\n        assert_equals(dataset['license_id'], 'other-open')\n        dataset = helpers.call_action('package_show', id=dataset['id'])\n        assert_equals(dataset['license_id'], 'other-open')\n\n    def test_notes(self):\n        dataset = helpers.call_action(\n            'package_create',\n            name='test-notes',\n            title='Test Notes',\n            notes='some notes',\n        )\n\n        assert_equals(dataset['notes'], 'some notes')\n        dataset = helpers.call_action('package_show', id=dataset['id'])\n        assert_equals(dataset['notes'], 'some notes')\n\n    def test_resources(self):\n        dataset = helpers.call_action(\n            'package_create',\n            name='test-resources',\n            title='Test Resources',\n            resources=[\n                {'alt_url': u'alt123',\n                 'description': u'Full text.',\n                 'somekey': 'somevalue',  # this is how to do resource extras\n                 'extras': {u'someotherkey': u'alt234'},  # this isnt\n                 'format': u'plain text',\n                 'hash': u'abc123',\n                 'position': 0,\n                 'url': u'http://datahub.io/download/'},\n                {'description': u'Index of the novel',\n                 'format': u'JSON',\n                 'position': 1,\n                 'url': u'http://datahub.io/index.json'}\n            ],\n        )\n\n        resources = dataset['resources']\n        assert_equals(resources[0]['alt_url'], 'alt123')\n        assert_equals(resources[0]['description'], 'Full text.')\n        assert_equals(resources[0]['somekey'], 'somevalue')\n        assert 'extras' not in resources[0]\n        assert 'someotherkey' not in resources[0]\n        assert_equals(resources[0]['format'], 'plain text')\n        assert_equals(resources[0]['hash'], 'abc123')\n        assert_equals(resources[0]['position'], 0)\n        assert_equals(resources[0]['url'], 'http://datahub.io/download/')\n        assert_equals(resources[1]['description'], 'Index of the novel')\n        assert_equals(resources[1]['format'], 'JSON')\n        assert_equals(resources[1]['url'], 'http://datahub.io/index.json')\n        assert_equals(resources[1]['position'], 1)\n        resources = helpers.call_action(\n            'package_show', id=dataset['id'])['resources']\n        assert_equals(resources[0]['alt_url'], 'alt123')\n        assert_equals(resources[0]['description'], 'Full text.')\n        assert_equals(resources[0]['somekey'], 'somevalue')\n        assert 'extras' not in resources[0]\n        assert 'someotherkey' not in resources[0]\n        assert_equals(resources[0]['format'], 'plain text')\n        assert_equals(resources[0]['hash'], 'abc123')\n        assert_equals(resources[0]['position'], 0)\n        assert_equals(resources[0]['url'], 'http://datahub.io/download/')\n        assert_equals(resources[1]['description'], 'Index of the novel')\n        assert_equals(resources[1]['format'], 'JSON')\n        assert_equals(resources[1]['url'], 'http://datahub.io/index.json')\n        assert_equals(resources[1]['position'], 1)\n\n    def test_tags(self):\n        dataset = helpers.call_action(\n            'package_create',\n            name='test-tags',\n            title='Test Tags',\n            tags=[{'name': u'russian'}, {'name': u'tolstoy'}],\n        )\n\n        tag_names = sorted([tag_dict['name']\n                            for tag_dict in dataset['tags']])\n        assert_equals(tag_names, ['russian', 'tolstoy'])\n        dataset = helpers.call_action('package_show', id=dataset['id'])\n        tag_names = sorted([tag_dict['name']\n                            for tag_dict in dataset['tags']])\n        assert_equals(tag_names, ['russian', 'tolstoy'])\n\n\nclass TestGroupCreate(helpers.FunctionalTestBase):\n\n    def test_create_group(self):\n        user = factories.User()\n        context = {\n            'user': user['name'],\n            'ignore_auth': True,\n        }\n\n        group = helpers.call_action(\n            'group_create',\n            context=context,\n            name='test-group',\n        )\n\n        assert len(group['users']) == 1\n        assert group['display_name'] == u'test-group'\n        assert group['package_count'] == 0\n        assert not group['is_organization']\n        assert group['type'] == 'group'\n\n    @nose.tools.raises(logic.ValidationError)\n    def test_create_group_validation_fail(self):\n        user = factories.User()\n        context = {\n            'user': user['name'],\n            'ignore_auth': True,\n        }\n\n        group = helpers.call_action(\n            'group_create',\n            context=context,\n            name='',\n        )\n\n    def test_create_group_return_id(self):\n        import re\n\n        user = factories.User()\n        context = {\n            'user': user['name'],\n            'ignore_auth': True,\n            'return_id_only': True\n        }\n\n        group = helpers.call_action(\n            'group_create',\n            context=context,\n            name='test-group',\n        )\n\n        assert isinstance(group, str)\n        assert re.match('([a-f\\d]{8}(-[a-f\\d]{4}){3}-[a-f\\d]{12}?)', group)\n\n    def test_create_matches_show(self):\n        user = factories.User()\n        context = {\n            'user': user['name'],\n            'ignore_auth': True,\n        }\n\n        created = helpers.call_action(\n            'organization_create',\n            context=context,\n            name='test-organization',\n        )\n\n        shown = helpers.call_action(\n            'organization_show',\n            context=context,\n            id='test-organization',\n        )\n\n        assert sorted(created.keys()) == sorted(shown.keys())\n        for k in created.keys():\n            assert created[k] == shown[k], k\n\n\nclass TestOrganizationCreate(helpers.FunctionalTestBase):\n\n    def test_create_organization(self):\n        user = factories.User()\n        context = {\n            'user': user['name'],\n            'ignore_auth': True,\n        }\n\n        org = helpers.call_action(\n            'organization_create',\n            context=context,\n            name='test-organization',\n        )\n\n        assert len(org['users']) == 1\n        assert org['display_name'] == u'test-organization'\n        assert org['package_count'] == 0\n        assert org['is_organization']\n        assert org['type'] == 'organization'\n\n    @nose.tools.raises(logic.ValidationError)\n    def test_create_organization_validation_fail(self):\n        user = factories.User()\n        context = {\n            'user': user['name'],\n            'ignore_auth': True,\n        }\n\n        org = helpers.call_action(\n            'organization_create',\n            context=context,\n            name='',\n        )\n\n    def test_create_organization_return_id(self):\n        import re\n\n        user = factories.User()\n        context = {\n            'user': user['name'],\n            'ignore_auth': True,\n            'return_id_only': True\n        }\n\n        org = helpers.call_action(\n            'organization_create',\n            context=context,\n            name='test-organization',\n        )\n\n        assert isinstance(org, str)\n        assert re.match('([a-f\\d]{8}(-[a-f\\d]{4}){3}-[a-f\\d]{12}?)', org)\n\n    def test_create_matches_show(self):\n        user = factories.User()\n        context = {\n            'user': user['name'],\n            'ignore_auth': True,\n        }\n\n        created = helpers.call_action(\n            'organization_create',\n            context=context,\n            name='test-organization',\n        )\n\n        shown = helpers.call_action(\n            'organization_show',\n            context=context,\n            id='test-organization',\n        )\n\n        assert sorted(created.keys()) == sorted(shown.keys())\n        for k in created.keys():\n            assert created[k] == shown[k], k\n\n    def test_create_organization_custom_type(self):\n        custom_org_type = 'some-custom-type'\n        user = factories.User()\n        context = {\n            'user': user['name'],\n            'ignore_auth': True,\n        }\n\n        org = helpers.call_action(\n            'organization_create',\n            context=context,\n            name='test-organization',\n            type=custom_org_type\n        )\n\n        assert len(org['users']) == 1\n        assert org['display_name'] == u'test-organization'\n        assert org['package_count'] == 0\n        assert org['is_organization']\n        assert org['type'] == custom_org_type\n\n\nclass TestUserCreate(helpers.FunctionalTestBase):\n\n    def test_user_create_with_password_hash(self):\n        sysadmin = factories.Sysadmin()\n        context = {\n            'user': sysadmin['name'],\n        }\n\n        user = helpers.call_action(\n            'user_create',\n            context=context,\n            email='test@example.com',\n            name='test',\n            password_hash='pretend-this-is-a-valid-hash')\n\n        user_obj = model.User.get(user['id'])\n        assert user_obj.password == 'pretend-this-is-a-valid-hash'\n\n    def test_user_create_password_hash_not_for_normal_users(self):\n        normal_user = factories.User()\n        context = {\n            'user': normal_user['name'],\n        }\n\n        user = helpers.call_action(\n            'user_create',\n            context=context,\n            email='test@example.com',\n            name='test',\n            password='required',\n            password_hash='pretend-this-is-a-valid-hash')\n\n        user_obj = model.User.get(user['id'])\n        assert user_obj.password != 'pretend-this-is-a-valid-hash'\n"], "fixing_code": ["# encoding: utf-8\n\n'''API functions for adding data to CKAN.'''\n\nimport logging\nimport random\nimport re\nfrom socket import error as socket_error\nimport string\n\nimport paste.deploy.converters\nfrom sqlalchemy import func\n\nimport ckan.lib.plugins as lib_plugins\nimport ckan.logic as logic\nimport ckan.plugins as plugins\nimport ckan.lib.dictization\nimport ckan.logic.action\nimport ckan.logic.schema\nimport ckan.lib.dictization.model_dictize as model_dictize\nimport ckan.lib.dictization.model_save as model_save\nimport ckan.lib.navl.dictization_functions\nimport ckan.lib.uploader as uploader\nimport ckan.lib.navl.validators as validators\nimport ckan.lib.mailer as mailer\nimport ckan.lib.datapreview\n\nfrom ckan.common import _, config\n\n# FIXME this looks nasty and should be shared better\nfrom ckan.logic.action.update import _update_package_relationship\n\nlog = logging.getLogger(__name__)\n\n# Define some shortcuts\n# Ensure they are module-private so that they don't get loaded as available\n# actions in the action API.\n_validate = ckan.lib.navl.dictization_functions.validate\n_check_access = logic.check_access\n_get_action = logic.get_action\nValidationError = logic.ValidationError\nNotFound = logic.NotFound\n_get_or_bust = logic.get_or_bust\n\n\ndef package_create(context, data_dict):\n    '''Create a new dataset (package).\n\n    You must be authorized to create new datasets. If you specify any groups\n    for the new dataset, you must also be authorized to edit these groups.\n\n    Plugins may change the parameters of this function depending on the value\n    of the ``type`` parameter, see the\n    :py:class:`~ckan.plugins.interfaces.IDatasetForm` plugin interface.\n\n    :param name: the name of the new dataset, must be between 2 and 100\n        characters long and contain only lowercase alphanumeric characters,\n        ``-`` and ``_``, e.g. ``'warandpeace'``\n    :type name: string\n    :param title: the title of the dataset (optional, default: same as\n        ``name``)\n    :type title: string\n    :param private: If ``True`` creates a private dataset\n    :type private: bool\n    :param author: the name of the dataset's author (optional)\n    :type author: string\n    :param author_email: the email address of the dataset's author (optional)\n    :type author_email: string\n    :param maintainer: the name of the dataset's maintainer (optional)\n    :type maintainer: string\n    :param maintainer_email: the email address of the dataset's maintainer\n        (optional)\n    :type maintainer_email: string\n    :param license_id: the id of the dataset's license, see\n        :py:func:`~ckan.logic.action.get.license_list` for available values\n        (optional)\n    :type license_id: license id string\n    :param notes: a description of the dataset (optional)\n    :type notes: string\n    :param url: a URL for the dataset's source (optional)\n    :type url: string\n    :param version: (optional)\n    :type version: string, no longer than 100 characters\n    :param state: the current state of the dataset, e.g. ``'active'`` or\n        ``'deleted'``, only active datasets show up in search results and\n        other lists of datasets, this parameter will be ignored if you are not\n        authorized to change the state of the dataset (optional, default:\n        ``'active'``)\n    :type state: string\n    :param type: the type of the dataset (optional),\n        :py:class:`~ckan.plugins.interfaces.IDatasetForm` plugins\n        associate themselves with different dataset types and provide custom\n        dataset handling behaviour for these types\n    :type type: string\n    :param resources: the dataset's resources, see\n        :py:func:`resource_create` for the format of resource dictionaries\n        (optional)\n    :type resources: list of resource dictionaries\n    :param tags: the dataset's tags, see :py:func:`tag_create` for the format\n        of tag dictionaries (optional)\n    :type tags: list of tag dictionaries\n    :param extras: the dataset's extras (optional), extras are arbitrary\n        (key: value) metadata items that can be added to datasets, each extra\n        dictionary should have keys ``'key'`` (a string), ``'value'`` (a\n        string)\n    :type extras: list of dataset extra dictionaries\n    :param relationships_as_object: see :py:func:`package_relationship_create`\n        for the format of relationship dictionaries (optional)\n    :type relationships_as_object: list of relationship dictionaries\n    :param relationships_as_subject: see :py:func:`package_relationship_create`\n        for the format of relationship dictionaries (optional)\n    :type relationships_as_subject: list of relationship dictionaries\n    :param groups: the groups to which the dataset belongs (optional), each\n        group dictionary should have one or more of the following keys which\n        identify an existing group:\n        ``'id'`` (the id of the group, string), or ``'name'`` (the name of the\n        group, string),  to see which groups exist\n        call :py:func:`~ckan.logic.action.get.group_list`\n    :type groups: list of dictionaries\n    :param owner_org: the id of the dataset's owning organization, see\n        :py:func:`~ckan.logic.action.get.organization_list` or\n        :py:func:`~ckan.logic.action.get.organization_list_for_user` for\n        available values. This parameter can be made optional if the config\n        option :ref:`ckan.auth.create_unowned_dataset` is set to ``True``.\n    :type owner_org: string\n\n    :returns: the newly created dataset (unless 'return_id_only' is set to True\n              in the context, in which case just the dataset id will\n              be returned)\n    :rtype: dictionary\n\n    '''\n    model = context['model']\n    user = context['user']\n\n    if 'type' not in data_dict:\n        package_plugin = lib_plugins.lookup_package_plugin()\n        try:\n            # use first type as default if user didn't provide type\n            package_type = package_plugin.package_types()[0]\n        except (AttributeError, IndexError):\n            package_type = 'dataset'\n            # in case a 'dataset' plugin was registered w/o fallback\n            package_plugin = lib_plugins.lookup_package_plugin(package_type)\n        data_dict['type'] = package_type\n    else:\n        package_plugin = lib_plugins.lookup_package_plugin(data_dict['type'])\n\n    if 'schema' in context:\n        schema = context['schema']\n    else:\n        schema = package_plugin.create_package_schema()\n\n    _check_access('package_create', context, data_dict)\n\n    if 'api_version' not in context:\n        # check_data_dict() is deprecated. If the package_plugin has a\n        # check_data_dict() we'll call it, if it doesn't have the method we'll\n        # do nothing.\n        check_data_dict = getattr(package_plugin, 'check_data_dict', None)\n        if check_data_dict:\n            try:\n                check_data_dict(data_dict, schema)\n            except TypeError:\n                # Old plugins do not support passing the schema so we need\n                # to ensure they still work\n                package_plugin.check_data_dict(data_dict)\n\n    data, errors = lib_plugins.plugin_validate(\n        package_plugin, context, data_dict, schema, 'package_create')\n    log.debug('package_create validate_errs=%r user=%s package=%s data=%r',\n              errors, context.get('user'),\n              data.get('name'), data_dict)\n\n    if errors:\n        model.Session.rollback()\n        raise ValidationError(errors)\n\n    rev = model.repo.new_revision()\n    rev.author = user\n    if 'message' in context:\n        rev.message = context['message']\n    else:\n        rev.message = _(u'REST API: Create object %s') % data.get(\"name\")\n\n    if user:\n        user_obj = model.User.by_name(user.decode('utf8'))\n        if user_obj:\n            data['creator_user_id'] = user_obj.id\n\n    pkg = model_save.package_dict_save(data, context)\n\n    # Needed to let extensions know the package and resources ids\n    model.Session.flush()\n    data['id'] = pkg.id\n    if data.get('resources'):\n        for index, resource in enumerate(data['resources']):\n            resource['id'] = pkg.resources[index].id\n\n    context_org_update = context.copy()\n    context_org_update['ignore_auth'] = True\n    context_org_update['defer_commit'] = True\n    context_org_update['add_revision'] = False\n    _get_action('package_owner_org_update')(context_org_update,\n                                            {'id': pkg.id,\n                                             'organization_id': pkg.owner_org})\n\n    for item in plugins.PluginImplementations(plugins.IPackageController):\n        item.create(pkg)\n\n        item.after_create(context, data)\n\n    # Make sure that a user provided schema is not used in create_views\n    # and on package_show\n    context.pop('schema', None)\n\n    # Create default views for resources if necessary\n    if data.get('resources'):\n        logic.get_action('package_create_default_resource_views')(\n            {'model': context['model'], 'user': context['user'],\n             'ignore_auth': True},\n            {'package': data})\n\n    if not context.get('defer_commit'):\n        model.repo.commit()\n\n    # need to let rest api create\n    context[\"package\"] = pkg\n    # this is added so that the rest controller can make a new location\n    context[\"id\"] = pkg.id\n    log.debug('Created object %s' % pkg.name)\n\n    return_id_only = context.get('return_id_only', False)\n\n    output = context['id'] if return_id_only \\\n        else _get_action('package_show')(context, {'id': context['id']})\n\n    return output\n\n\ndef resource_create(context, data_dict):\n    '''Appends a new resource to a datasets list of resources.\n\n    :param package_id: id of package that the resource should be added to.\n\n    :type package_id: string\n    :param url: url of resource\n    :type url: string\n    :param revision_id: (optional)\n    :type revision_id: string\n    :param description: (optional)\n    :type description: string\n    :param format: (optional)\n    :type format: string\n    :param hash: (optional)\n    :type hash: string\n    :param name: (optional)\n    :type name: string\n    :param resource_type: (optional)\n    :type resource_type: string\n    :param mimetype: (optional)\n    :type mimetype: string\n    :param mimetype_inner: (optional)\n    :type mimetype_inner: string\n    :param cache_url: (optional)\n    :type cache_url: string\n    :param size: (optional)\n    :type size: int\n    :param created: (optional)\n    :type created: iso date string\n    :param last_modified: (optional)\n    :type last_modified: iso date string\n    :param cache_last_updated: (optional)\n    :type cache_last_updated: iso date string\n    :param upload: (optional)\n    :type upload: FieldStorage (optional) needs multipart/form-data\n\n    :returns: the newly created resource\n    :rtype: dictionary\n\n    '''\n    model = context['model']\n    user = context['user']\n\n    package_id = _get_or_bust(data_dict, 'package_id')\n    if not data_dict.get('url'):\n        data_dict['url'] = ''\n\n    pkg_dict = _get_action('package_show')(\n        dict(context, return_type='dict'),\n        {'id': package_id})\n\n    _check_access('resource_create', context, data_dict)\n\n    for plugin in plugins.PluginImplementations(plugins.IResourceController):\n        plugin.before_create(context, data_dict)\n\n    if 'resources' not in pkg_dict:\n        pkg_dict['resources'] = []\n\n    upload = uploader.get_resource_uploader(data_dict)\n\n    if 'mimetype' not in data_dict:\n        if hasattr(upload, 'mimetype'):\n            data_dict['mimetype'] = upload.mimetype\n\n    if 'size' not in data_dict:\n        if hasattr(upload, 'filesize'):\n            data_dict['size'] = upload.filesize\n\n    pkg_dict['resources'].append(data_dict)\n\n    try:\n        context['defer_commit'] = True\n        context['use_cache'] = False\n        _get_action('package_update')(context, pkg_dict)\n        context.pop('defer_commit')\n    except ValidationError as e:\n        try:\n            raise ValidationError(e.error_dict['resources'][-1])\n        except (KeyError, IndexError):\n            raise ValidationError(e.error_dict)\n\n    # Get out resource_id resource from model as it will not appear in\n    # package_show until after commit\n    upload.upload(context['package'].resources[-1].id,\n                  uploader.get_max_resource_size())\n\n    model.repo.commit()\n\n    #  Run package show again to get out actual last_resource\n    updated_pkg_dict = _get_action('package_show')(context, {'id': package_id})\n    resource = updated_pkg_dict['resources'][-1]\n\n    #  Add the default views to the new resource\n    logic.get_action('resource_create_default_resource_views')(\n        {'model': context['model'],\n         'user': context['user'],\n         'ignore_auth': True\n         },\n        {'resource': resource,\n         'package': updated_pkg_dict\n         })\n\n    for plugin in plugins.PluginImplementations(plugins.IResourceController):\n        plugin.after_create(context, resource)\n\n    return resource\n\n\ndef resource_view_create(context, data_dict):\n    '''Creates a new resource view.\n\n    :param resource_id: id of the resource\n    :type resource_id: string\n    :param title: the title of the view\n    :type title: string\n    :param description: a description of the view (optional)\n    :type description: string\n    :param view_type: type of view\n    :type view_type: string\n    :param config: options necessary to recreate a view state (optional)\n    :type config: JSON string\n\n    :returns: the newly created resource view\n    :rtype: dictionary\n\n    '''\n    model = context['model']\n\n    resource_id = _get_or_bust(data_dict, 'resource_id')\n    view_type = _get_or_bust(data_dict, 'view_type')\n    view_plugin = ckan.lib.datapreview.get_view_plugin(view_type)\n\n    if not view_plugin:\n        raise ValidationError(\n            {\"view_type\": \"No plugin found for view_type {view_type}\".format(\n                view_type=view_type\n            )}\n        )\n\n    default = logic.schema.default_create_resource_view_schema(view_plugin)\n    schema = context.get('schema', default)\n    plugin_schema = view_plugin.info().get('schema', {})\n    schema.update(plugin_schema)\n\n    data, errors = _validate(data_dict, schema, context)\n    if errors:\n        model.Session.rollback()\n        raise ValidationError(errors)\n\n    _check_access('resource_view_create', context, data_dict)\n\n    if context.get('preview'):\n        return data\n\n    max_order = model.Session.query(\n        func.max(model.ResourceView.order)\n        ).filter_by(resource_id=resource_id).first()\n\n    order = 0\n    if max_order[0] is not None:\n        order = max_order[0] + 1\n    data['order'] = order\n\n    resource_view = model_save.resource_view_dict_save(data, context)\n    if not context.get('defer_commit'):\n        model.repo.commit()\n    return model_dictize.resource_view_dictize(resource_view, context)\n\n\ndef resource_create_default_resource_views(context, data_dict):\n    '''\n    Creates the default views (if necessary) on the provided resource\n\n    The function will get the plugins for the default views defined in\n    the configuration, and if some were found the `can_view` method of\n    each one of them will be called to determine if a resource view should\n    be created. Resource views extensions get the resource dict and the\n    parent dataset dict.\n\n    If the latter is not provided, `package_show` is called to get it.\n\n    By default only view plugins that don't require the resource data to be in\n    the DataStore are called. See\n    :py:func:`ckan.logic.action.create.package_create_default_resource_views.``\n    for details on the ``create_datastore_views`` parameter.\n\n    :param resource: full resource dict\n    :type resource: dict\n    :param package: full dataset dict (optional, if not provided\n        :py:func:`~ckan.logic.action.get.package_show` will be called).\n    :type package: dict\n    :param create_datastore_views: whether to create views that rely on data\n        being on the DataStore (optional, defaults to False)\n    :type create_datastore_views: bool\n\n    :returns: a list of resource views created (empty if none were created)\n    :rtype: list of dictionaries\n    '''\n\n    resource_dict = _get_or_bust(data_dict, 'resource')\n\n    _check_access('resource_create_default_resource_views', context, data_dict)\n\n    dataset_dict = data_dict.get('package')\n\n    create_datastore_views = paste.deploy.converters.asbool(\n        data_dict.get('create_datastore_views', False))\n\n    return ckan.lib.datapreview.add_views_to_resource(\n        context,\n        resource_dict,\n        dataset_dict,\n        view_types=[],\n        create_datastore_views=create_datastore_views)\n\n\ndef package_create_default_resource_views(context, data_dict):\n    '''\n    Creates the default views on all resources of the provided dataset\n\n    By default only view plugins that don't require the resource data to be in\n    the DataStore are called. Passing `create_datastore_views` as True will\n    only create views that require data to be in the DataStore. The first case\n    happens when the function is called from `package_create` or\n    `package_update`, the second when it's called from the DataPusher when\n    data was uploaded to the DataStore.\n\n    :param package: full dataset dict (ie the one obtained\n        calling :py:func:`~ckan.logic.action.get.package_show`).\n    :type package: dict\n    :param create_datastore_views: whether to create views that rely on data\n        being on the DataStore (optional, defaults to False)\n    :type create_datastore_views: bool\n\n    :returns: a list of resource views created (empty if none were created)\n    :rtype: list of dictionaries\n    '''\n\n    dataset_dict = _get_or_bust(data_dict, 'package')\n\n    _check_access('package_create_default_resource_views', context, data_dict)\n\n    create_datastore_views = paste.deploy.converters.asbool(\n        data_dict.get('create_datastore_views', False))\n\n    return ckan.lib.datapreview.add_views_to_dataset_resources(\n        context,\n        dataset_dict,\n        view_types=[],\n        create_datastore_views=create_datastore_views)\n\n\ndef package_relationship_create(context, data_dict):\n    '''Create a relationship between two datasets (packages).\n\n    You must be authorized to edit both the subject and the object datasets.\n\n    :param subject: the id or name of the dataset that is the subject of the\n        relationship\n    :type subject: string\n    :param object: the id or name of the dataset that is the object of the\n        relationship\n    :param type: the type of the relationship, one of ``'depends_on'``,\n        ``'dependency_of'``, ``'derives_from'``, ``'has_derivation'``,\n        ``'links_to'``, ``'linked_from'``, ``'child_of'`` or ``'parent_of'``\n    :type type: string\n    :param comment: a comment about the relationship (optional)\n    :type comment: string\n\n    :returns: the newly created package relationship\n    :rtype: dictionary\n\n    '''\n    model = context['model']\n    user = context['user']\n    schema = context.get('schema') \\\n        or ckan.logic.schema.default_create_relationship_schema()\n    api = context.get('api_version')\n    ref_package_by = 'id' if api == 2 else 'name'\n\n    id, id2, rel_type = _get_or_bust(data_dict, ['subject', 'object', 'type'])\n    comment = data_dict.get('comment', u'')\n\n    pkg1 = model.Package.get(id)\n    pkg2 = model.Package.get(id2)\n    if not pkg1:\n        raise NotFound('Subject package %r was not found.' % id)\n    if not pkg2:\n        return NotFound('Object package %r was not found.' % id2)\n\n    data, errors = _validate(data_dict, schema, context)\n    if errors:\n        model.Session.rollback()\n        raise ValidationError(errors)\n\n    _check_access('package_relationship_create', context, data_dict)\n\n    # Create a Package Relationship.\n    existing_rels = pkg1.get_relationships_with(pkg2, rel_type)\n    if existing_rels:\n        return _update_package_relationship(existing_rels[0],\n                                            comment, context)\n    rev = model.repo.new_revision()\n    rev.author = user\n    rev.message = _(u'REST API: Create package relationship: %s %s %s') \\\n        % (pkg1, rel_type, pkg2)\n    rel = pkg1.add_relationship(rel_type, pkg2, comment=comment)\n    if not context.get('defer_commit'):\n        model.repo.commit_and_remove()\n    context['relationship'] = rel\n\n    relationship_dicts = rel.as_dict(ref_package_by=ref_package_by)\n    return relationship_dicts\n\n\ndef member_create(context, data_dict=None):\n    '''Make an object (e.g. a user, dataset or group) a member of a group.\n\n    If the object is already a member of the group then the capacity of the\n    membership will be updated.\n\n    You must be authorized to edit the group.\n\n    :param id: the id or name of the group to add the object to\n    :type id: string\n    :param object: the id or name of the object to add\n    :type object: string\n    :param object_type: the type of the object being added, e.g. ``'package'``\n        or ``'user'``\n    :type object_type: string\n    :param capacity: the capacity of the membership\n    :type capacity: string\n\n    :returns: the newly created (or updated) membership\n    :rtype: dictionary\n\n    '''\n    model = context['model']\n    user = context['user']\n\n    rev = model.repo.new_revision()\n    rev.author = user\n    if 'message' in context:\n        rev.message = context['message']\n    else:\n        rev.message = _(u'REST API: Create member object %s') \\\n            % data_dict.get('name', '')\n\n    group_id, obj_id, obj_type, capacity = \\\n        _get_or_bust(data_dict, ['id', 'object', 'object_type', 'capacity'])\n\n    group = model.Group.get(group_id)\n    if not group:\n        raise NotFound('Group was not found.')\n\n    obj_class = ckan.logic.model_name_to_class(model, obj_type)\n    obj = obj_class.get(obj_id)\n    if not obj:\n        raise NotFound('%s was not found.' % obj_type.title())\n\n    _check_access('member_create', context, data_dict)\n\n    # Look up existing, in case it exists\n    member = model.Session.query(model.Member).\\\n        filter(model.Member.table_name == obj_type).\\\n        filter(model.Member.table_id == obj.id).\\\n        filter(model.Member.group_id == group.id).\\\n        filter(model.Member.state == 'active').first()\n    if not member:\n        member = model.Member(table_name=obj_type,\n                              table_id=obj.id,\n                              group_id=group.id,\n                              state='active')\n        member.group = group\n    member.capacity = capacity\n\n    model.Session.add(member)\n    model.repo.commit()\n\n    return model_dictize.member_dictize(member, context)\n\n\ndef _group_or_org_create(context, data_dict, is_org=False):\n    model = context['model']\n    user = context['user']\n    session = context['session']\n    data_dict['is_organization'] = is_org\n\n    upload = uploader.get_uploader('group')\n    upload.update_data_dict(data_dict, 'image_url',\n                            'image_upload', 'clear_upload')\n    # get the schema\n    group_type = data_dict.get('type', 'organization' if is_org else 'group')\n    group_plugin = lib_plugins.lookup_group_plugin(group_type)\n    try:\n        schema = group_plugin.form_to_db_schema_options({\n            'type': 'create', 'api': 'api_version' in context,\n            'context': context})\n    except AttributeError:\n        schema = group_plugin.form_to_db_schema()\n\n    if 'api_version' not in context:\n        # old plugins do not support passing the schema so we need\n        # to ensure they still work\n        try:\n            group_plugin.check_data_dict(data_dict, schema)\n        except TypeError:\n            group_plugin.check_data_dict(data_dict)\n\n    data, errors = lib_plugins.plugin_validate(\n        group_plugin, context, data_dict, schema,\n        'organization_create' if is_org else 'group_create')\n    log.debug('group_create validate_errs=%r user=%s group=%s data_dict=%r',\n              errors, context.get('user'), data_dict.get('name'), data_dict)\n\n    if errors:\n        session.rollback()\n        raise ValidationError(errors)\n\n    rev = model.repo.new_revision()\n    rev.author = user\n\n    if 'message' in context:\n        rev.message = context['message']\n    else:\n        rev.message = _(u'REST API: Create object %s') % data.get(\"name\")\n\n    group = model_save.group_dict_save(data, context)\n\n    # Needed to let extensions know the group id\n    session.flush()\n\n    if is_org:\n        plugin_type = plugins.IOrganizationController\n    else:\n        plugin_type = plugins.IGroupController\n\n    for item in plugins.PluginImplementations(plugin_type):\n        item.create(group)\n\n    if is_org:\n        activity_type = 'new organization'\n    else:\n        activity_type = 'new group'\n\n    user_id = model.User.by_name(user.decode('utf8')).id\n\n    activity_dict = {\n        'user_id': user_id,\n        'object_id': group.id,\n        'activity_type': activity_type,\n    }\n    activity_dict['data'] = {\n        'group': ckan.lib.dictization.table_dictize(group, context)\n    }\n    activity_create_context = {\n        'model': model,\n        'user': user,\n        'defer_commit': True,\n        'ignore_auth': True,\n        'session': session\n    }\n    logic.get_action('activity_create')(activity_create_context, activity_dict)\n\n    upload.upload(uploader.get_max_image_size())\n\n    if not context.get('defer_commit'):\n        model.repo.commit()\n    context[\"group\"] = group\n    context[\"id\"] = group.id\n\n    # creator of group/org becomes an admin\n    # this needs to be after the repo.commit or else revisions break\n    member_dict = {\n        'id': group.id,\n        'object': user_id,\n        'object_type': 'user',\n        'capacity': 'admin',\n    }\n    member_create_context = {\n        'model': model,\n        'user': user,\n        'ignore_auth': True,  # we are not a member of the group at this point\n        'session': session\n    }\n    logic.get_action('member_create')(member_create_context, member_dict)\n\n    log.debug('Created object %s' % group.name)\n\n    return_id_only = context.get('return_id_only', False)\n    action = 'organization_show' if is_org else 'group_show'\n\n    output = context['id'] if return_id_only \\\n        else _get_action(action)(context, {'id': group.id})\n\n    return output\n\n\ndef group_create(context, data_dict):\n    '''Create a new group.\n\n    You must be authorized to create groups.\n\n    Plugins may change the parameters of this function depending on the value\n    of the ``type`` parameter, see the\n    :py:class:`~ckan.plugins.interfaces.IGroupForm` plugin interface.\n\n    :param name: the name of the group, a string between 2 and 100 characters\n        long, containing only lowercase alphanumeric characters, ``-`` and\n        ``_``\n    :type name: string\n    :param id: the id of the group (optional)\n    :type id: string\n    :param title: the title of the group (optional)\n    :type title: string\n    :param description: the description of the group (optional)\n    :type description: string\n    :param image_url: the URL to an image to be displayed on the group's page\n        (optional)\n    :type image_url: string\n    :param type: the type of the group (optional, default: ``'group'``),\n        :py:class:`~ckan.plugins.interfaces.IGroupForm` plugins\n        associate themselves with different group types and provide custom\n        group handling behaviour for these types\n        Cannot be 'organization'\n    :type type: string\n    :param state: the current state of the group, e.g. ``'active'`` or\n        ``'deleted'``, only active groups show up in search results and\n        other lists of groups, this parameter will be ignored if you are not\n        authorized to change the state of the group (optional, default:\n        ``'active'``)\n    :type state: string\n    :param approval_status: (optional)\n    :type approval_status: string\n    :param extras: the group's extras (optional), extras are arbitrary\n        (key: value) metadata items that can be added to groups, each extra\n        dictionary should have keys ``'key'`` (a string), ``'value'`` (a\n        string), and optionally ``'deleted'``\n    :type extras: list of dataset extra dictionaries\n    :param packages: the datasets (packages) that belong to the group, a list\n        of dictionaries each with keys ``'name'`` (string, the id or name of\n        the dataset) and optionally ``'title'`` (string, the title of the\n        dataset)\n    :type packages: list of dictionaries\n    :param groups: the groups that belong to the group, a list of dictionaries\n        each with key ``'name'`` (string, the id or name of the group) and\n        optionally ``'capacity'`` (string, the capacity in which the group is\n        a member of the group)\n    :type groups: list of dictionaries\n    :param users: the users that belong to the group, a list of dictionaries\n        each with key ``'name'`` (string, the id or name of the user) and\n        optionally ``'capacity'`` (string, the capacity in which the user is\n        a member of the group)\n    :type users: list of dictionaries\n\n    :returns: the newly created group (unless 'return_id_only' is set to True\n              in the context, in which case just the group id will\n              be returned)\n    :rtype: dictionary\n\n    '''\n    # wrapper for creating groups\n    if data_dict.get('type') == 'organization':\n        # FIXME better exception?\n        raise Exception(_('Trying to create an organization as a group'))\n    _check_access('group_create', context, data_dict)\n    return _group_or_org_create(context, data_dict)\n\n\ndef organization_create(context, data_dict):\n    '''Create a new organization.\n\n    You must be authorized to create organizations.\n\n    Plugins may change the parameters of this function depending on the value\n    of the ``type`` parameter, see the\n    :py:class:`~ckan.plugins.interfaces.IGroupForm` plugin interface.\n\n    :param name: the name of the organization, a string between 2 and\n        100 characters long, containing only lowercase alphanumeric\n        characters, ``-`` and ``_``\n    :type name: string\n    :param id: the id of the organization (optional)\n    :type id: string\n    :param title: the title of the organization (optional)\n    :type title: string\n    :param description: the description of the organization (optional)\n    :type description: string\n    :param image_url: the URL to an image to be displayed on the\n        organization's page (optional)\n    :type image_url: string\n    :param state: the current state of the organization, e.g. ``'active'`` or\n        ``'deleted'``, only active organizations show up in search results and\n        other lists of organizations, this parameter will be ignored if you\n        are not authorized to change the state of the organization\n        (optional, default: ``'active'``)\n    :type state: string\n    :param approval_status: (optional)\n    :type approval_status: string\n    :param extras: the organization's extras (optional), extras are arbitrary\n        (key: value) metadata items that can be added to organizations,\n        each extra\n        dictionary should have keys ``'key'`` (a string), ``'value'`` (a\n        string), and optionally ``'deleted'``\n    :type extras: list of dataset extra dictionaries\n    :param packages: the datasets (packages) that belong to the organization,\n        a list of dictionaries each with keys ``'name'`` (string, the id\n        or name of the dataset) and optionally ``'title'`` (string, the\n        title of the dataset)\n    :type packages: list of dictionaries\n    :param users: the users that belong to the organization, a list\n        of dictionaries each with key ``'name'`` (string, the id or name\n        of the user) and optionally ``'capacity'`` (string, the capacity\n        in which the user is a member of the organization)\n    :type users: list of dictionaries\n\n    :returns: the newly created organization (unless 'return_id_only' is set\n              to True in the context, in which case just the organization id\n              will be returned)\n    :rtype: dictionary\n\n    '''\n    # wrapper for creating organizations\n    data_dict.setdefault('type', 'organization')\n    _check_access('organization_create', context, data_dict)\n    return _group_or_org_create(context, data_dict, is_org=True)\n\n\n@logic.auth_audit_exempt\ndef rating_create(context, data_dict):\n    '''Rate a dataset (package).\n\n    You must provide your API key in the Authorization header.\n\n    :param package: the name or id of the dataset to rate\n    :type package: string\n    :param rating: the rating to give to the dataset, an integer between 1 and\n        5\n    :type rating: int\n\n    :returns: a dictionary with two keys: ``'rating average'`` (the average\n        rating of the dataset you rated) and ``'rating count'`` (the number of\n        times the dataset has been rated)\n    :rtype: dictionary\n\n    '''\n    model = context['model']\n    user = context.get(\"user\")\n\n    package_ref = data_dict.get('package')\n    rating = data_dict.get('rating')\n    opts_err = None\n    if not package_ref:\n        opts_err = _('You must supply a package id or name '\n                     '(parameter \"package\").')\n    elif not rating:\n        opts_err = _('You must supply a rating (parameter \"rating\").')\n    else:\n        try:\n            rating_int = int(rating)\n        except ValueError:\n            opts_err = _('Rating must be an integer value.')\n        else:\n            package = model.Package.get(package_ref)\n            if rating < model.MIN_RATING or rating > model.MAX_RATING:\n                opts_err = _('Rating must be between %i and %i.') \\\n                    % (model.MIN_RATING, model.MAX_RATING)\n            elif not package:\n                opts_err = _('Not found') + ': %r' % package_ref\n    if opts_err:\n        raise ValidationError(opts_err)\n\n    user = model.User.by_name(user)\n    package.set_rating(user, rating_int)\n    model.repo.commit()\n\n    package = model.Package.get(package_ref)\n    ret_dict = {'rating average': package.get_average_rating(),\n                'rating count': len(package.ratings)}\n    return ret_dict\n\n\ndef user_create(context, data_dict):\n    '''Create a new user.\n\n    You must be authorized to create users.\n\n    :param name: the name of the new user, a string between 2 and 100\n        characters in length, containing only lowercase alphanumeric\n        characters, ``-`` and ``_``\n    :type name: string\n    :param email: the email address for the new user\n    :type email: string\n    :param password: the password of the new user, a string of at least 4\n        characters\n    :type password: string\n    :param id: the id of the new user (optional)\n    :type id: string\n    :param fullname: the full name of the new user (optional)\n    :type fullname: string\n    :param about: a description of the new user (optional)\n    :type about: string\n\n    :returns: the newly created user\n    :rtype: dictionary\n\n    '''\n    model = context['model']\n    schema = context.get('schema') or ckan.logic.schema.default_user_schema()\n    session = context['session']\n\n    _check_access('user_create', context, data_dict)\n\n    author_obj = model.User.get(context.get('user'))\n    if data_dict.get(\"id\"):\n        is_sysadmin = (author_obj and author_obj.sysadmin)\n        if not is_sysadmin or model.User.get(data_dict[\"id\"]):\n            data_dict.pop(\"id\", None)\n    context.pop(\"user_obj\", None)\n\n    data, errors = _validate(data_dict, schema, context)\n\n    if errors:\n        session.rollback()\n        raise ValidationError(errors)\n\n    # user schema prevents non-sysadmins from providing password_hash\n    if 'password_hash' in data:\n        data['_password'] = data.pop('password_hash')\n\n    user = model_save.user_dict_save(data, context)\n\n    # Flush the session to cause user.id to be initialised, because\n    # activity_create() (below) needs it.\n    session.flush()\n\n    activity_create_context = {\n        'model': model,\n        'user': context['user'],\n        'defer_commit': True,\n        'ignore_auth': True,\n        'session': session\n    }\n    activity_dict = {\n        'user_id': user.id,\n        'object_id': user.id,\n        'activity_type': 'new user',\n    }\n    logic.get_action('activity_create')(activity_create_context, activity_dict)\n\n    if not context.get('defer_commit'):\n        model.repo.commit()\n\n    # A new context is required for dictizing the newly constructed user in\n    # order that all the new user's data is returned, in particular, the\n    # api_key.\n    #\n    # The context is copied so as not to clobber the caller's context dict.\n    user_dictize_context = context.copy()\n    user_dictize_context['keep_apikey'] = True\n    user_dictize_context['keep_email'] = True\n    user_dict = model_dictize.user_dictize(user, user_dictize_context)\n\n    context['user_obj'] = user\n    context['id'] = user.id\n\n    model.Dashboard.get(user.id)  # Create dashboard for user.\n\n    log.debug('Created user {name}'.format(name=user.name))\n    return user_dict\n\n\ndef user_invite(context, data_dict):\n    '''Invite a new user.\n\n    You must be authorized to create group members.\n\n    :param email: the email of the user to be invited to the group\n    :type email: string\n    :param group_id: the id or name of the group\n    :type group_id: string\n    :param role: role of the user in the group. One of ``member``, ``editor``,\n        or ``admin``\n    :type role: string\n\n    :returns: the newly created user\n    :rtype: dictionary\n    '''\n    import string\n    _check_access('user_invite', context, data_dict)\n\n    schema = context.get('schema',\n                         ckan.logic.schema.default_user_invite_schema())\n    data, errors = _validate(data_dict, schema, context)\n    if errors:\n        raise ValidationError(errors)\n\n    model = context['model']\n    group = model.Group.get(data['group_id'])\n    if not group:\n        raise NotFound()\n\n    name = _get_random_username_from_email(data['email'])\n    # Choose a password. However it will not be used - the invitee will not be\n    # told it - they will need to reset it\n    while True:\n        password = ''.join(random.SystemRandom().choice(\n            string.ascii_lowercase + string.ascii_uppercase + string.digits)\n            for _ in range(12))\n        # Occasionally it won't meet the constraints, so check\n        errors = {}\n        logic.validators.user_password_validator(\n            'password', {'password': password}, errors, None)\n        if not errors:\n            break\n\n    data['name'] = name\n    data['password'] = password\n    data['state'] = ckan.model.State.PENDING\n    user_dict = _get_action('user_create')(context, data)\n    user = ckan.model.User.get(user_dict['id'])\n    member_dict = {\n        'username': user.id,\n        'id': data['group_id'],\n        'role': data['role']\n    }\n\n    if group.is_organization:\n        _get_action('organization_member_create')(context, member_dict)\n        group_dict = _get_action('organization_show')(context,\n                                                      {'id': data['group_id']})\n    else:\n        _get_action('group_member_create')(context, member_dict)\n        group_dict = _get_action('group_show')(context,\n                                               {'id': data['group_id']})\n    try:\n        mailer.send_invite(user, group_dict, data['role'])\n    except (socket_error, mailer.MailerException) as error:\n        # Email could not be sent, delete the pending user\n\n        _get_action('user_delete')(context, {'id': user.id})\n\n        msg = _('Error sending the invite email, ' +\n                'the user was not created: {0}').format(error)\n        raise ValidationError({'message': msg}, error_summary=msg)\n\n    return model_dictize.user_dictize(user, context)\n\n\ndef _get_random_username_from_email(email):\n    localpart = email.split('@')[0]\n    cleaned_localpart = re.sub(r'[^\\w]', '-', localpart).lower()\n\n    # if we can't create a unique user name within this many attempts\n    # then something else is probably wrong and we should give up\n    max_name_creation_attempts = 100\n\n    for i in range(max_name_creation_attempts):\n        random_number = random.SystemRandom().random() * 10000\n        name = '%s-%d' % (cleaned_localpart, random_number)\n        if not ckan.model.User.get(name):\n            return name\n\n    return cleaned_localpart\n\n\ndef vocabulary_create(context, data_dict):\n    '''Create a new tag vocabulary.\n\n    You must be a sysadmin to create vocabularies.\n\n    :param name: the name of the new vocabulary, e.g. ``'Genre'``\n    :type name: string\n    :param tags: the new tags to add to the new vocabulary, for the format of\n        tag dictionaries see :py:func:`tag_create`\n    :type tags: list of tag dictionaries\n\n    :returns: the newly-created vocabulary\n    :rtype: dictionary\n\n    '''\n    model = context['model']\n    schema = context.get('schema') or \\\n        ckan.logic.schema.default_create_vocabulary_schema()\n\n    _check_access('vocabulary_create', context, data_dict)\n\n    data, errors = _validate(data_dict, schema, context)\n\n    if errors:\n        model.Session.rollback()\n        raise ValidationError(errors)\n\n    vocabulary = model_save.vocabulary_dict_save(data, context)\n\n    if not context.get('defer_commit'):\n        model.repo.commit()\n\n    log.debug('Created Vocabulary %s' % vocabulary.name)\n\n    return model_dictize.vocabulary_dictize(vocabulary, context)\n\n\ndef activity_create(context, activity_dict, **kw):\n    '''Create a new activity stream activity.\n\n    You must be a sysadmin to create new activities.\n\n    :param user_id: the name or id of the user who carried out the activity,\n        e.g. ``'seanh'``\n    :type user_id: string\n    :param object_id: the name or id of the object of the activity, e.g.\n        ``'my_dataset'``\n    :param activity_type: the type of the activity, this must be an activity\n        type that CKAN knows how to render, e.g. ``'new package'``,\n        ``'changed user'``, ``'deleted group'`` etc.\n    :type activity_type: string\n    :param data: any additional data about the activity\n    :type data: dictionary\n\n    :returns: the newly created activity\n    :rtype: dictionary\n\n    '''\n\n    _check_access('activity_create', context, activity_dict)\n\n    # this action had a ignore_auth param which has been removed\n    # removed in 2.2\n    if 'ignore_auth' in kw:\n        raise Exception('Activity Stream calling parameters have changed '\n                        'ignore_auth must be passed in the context not as '\n                        'a param')\n\n    if not paste.deploy.converters.asbool(\n            config.get('ckan.activity_streams_enabled', 'true')):\n        return\n\n    model = context['model']\n\n    # Any revision_id that the caller attempts to pass in the activity_dict is\n    # ignored and overwritten here.\n    if getattr(model.Session, 'revision', None):\n        activity_dict['revision_id'] = model.Session.revision.id\n    else:\n        activity_dict['revision_id'] = None\n\n    schema = context.get('schema') or \\\n        ckan.logic.schema.default_create_activity_schema()\n\n    data, errors = _validate(activity_dict, schema, context)\n    if errors:\n        raise ValidationError(errors)\n\n    activity = model_save.activity_dict_save(data, context)\n\n    if not context.get('defer_commit'):\n        model.repo.commit()\n\n    log.debug(\"Created '%s' activity\" % activity.activity_type)\n    return model_dictize.activity_dictize(activity, context)\n\n\ndef tag_create(context, data_dict):\n    '''Create a new vocabulary tag.\n\n    You must be a sysadmin to create vocabulary tags.\n\n    You can only use this function to create tags that belong to a vocabulary,\n    not to create free tags. (To create a new free tag simply add the tag to\n    a package, e.g. using the\n    :py:func:`~ckan.logic.action.update.package_update` function.)\n\n    :param name: the name for the new tag, a string between 2 and 100\n        characters long containing only alphanumeric characters and ``-``,\n        ``_`` and ``.``, e.g. ``'Jazz'``\n    :type name: string\n    :param vocabulary_id: the id of the vocabulary that the new tag\n        should be added to, e.g. the id of vocabulary ``'Genre'``\n    :type vocabulary_id: string\n\n    :returns: the newly-created tag\n    :rtype: dictionary\n\n    '''\n    model = context['model']\n\n    _check_access('tag_create', context, data_dict)\n\n    schema = context.get('schema') or \\\n        ckan.logic.schema.default_create_tag_schema()\n    data, errors = _validate(data_dict, schema, context)\n    if errors:\n        raise ValidationError(errors)\n\n    tag = model_save.tag_dict_save(data_dict, context)\n\n    if not context.get('defer_commit'):\n        model.repo.commit()\n\n    log.debug(\"Created tag '%s' \" % tag)\n    return model_dictize.tag_dictize(tag, context)\n\n\ndef follow_user(context, data_dict):\n    '''Start following another user.\n\n    You must provide your API key in the Authorization header.\n\n    :param id: the id or name of the user to follow, e.g. ``'joeuser'``\n    :type id: string\n\n    :returns: a representation of the 'follower' relationship between yourself\n        and the other user\n    :rtype: dictionary\n\n    '''\n    if 'user' not in context:\n        raise logic.NotAuthorized(_(\"You must be logged in to follow users\"))\n\n    model = context['model']\n    session = context['session']\n\n    userobj = model.User.get(context['user'])\n    if not userobj:\n        raise logic.NotAuthorized(_(\"You must be logged in to follow users\"))\n\n    schema = (context.get('schema')\n              or ckan.logic.schema.default_follow_user_schema())\n\n    validated_data_dict, errors = _validate(data_dict, schema, context)\n\n    if errors:\n        model.Session.rollback()\n        raise ValidationError(errors)\n\n    # Don't let a user follow herself.\n    if userobj.id == validated_data_dict['id']:\n        message = _('You cannot follow yourself')\n        raise ValidationError({'message': message}, error_summary=message)\n\n    # Don't let a user follow someone she is already following.\n    if model.UserFollowingUser.is_following(userobj.id,\n                                            validated_data_dict['id']):\n        followeduserobj = model.User.get(validated_data_dict['id'])\n        name = followeduserobj.display_name\n        message = _('You are already following {0}').format(name)\n        raise ValidationError({'message': message}, error_summary=message)\n\n    follower = model_save.follower_dict_save(\n        validated_data_dict, context, model.UserFollowingUser)\n\n    if not context.get('defer_commit'):\n        model.repo.commit()\n\n    log.debug(u'User {follower} started following user {object}'.format(\n        follower=follower.follower_id, object=follower.object_id))\n\n    return model_dictize.user_following_user_dictize(follower, context)\n\n\ndef follow_dataset(context, data_dict):\n    '''Start following a dataset.\n\n    You must provide your API key in the Authorization header.\n\n    :param id: the id or name of the dataset to follow, e.g. ``'warandpeace'``\n    :type id: string\n\n    :returns: a representation of the 'follower' relationship between yourself\n        and the dataset\n    :rtype: dictionary\n\n    '''\n\n    if 'user' not in context:\n        raise logic.NotAuthorized(\n            _(\"You must be logged in to follow a dataset.\"))\n\n    model = context['model']\n    session = context['session']\n\n    userobj = model.User.get(context['user'])\n    if not userobj:\n        raise logic.NotAuthorized(\n            _(\"You must be logged in to follow a dataset.\"))\n\n    schema = (context.get('schema')\n              or ckan.logic.schema.default_follow_dataset_schema())\n\n    validated_data_dict, errors = _validate(data_dict, schema, context)\n\n    if errors:\n        model.Session.rollback()\n        raise ValidationError(errors)\n\n    # Don't let a user follow a dataset she is already following.\n    if model.UserFollowingDataset.is_following(userobj.id,\n                                               validated_data_dict['id']):\n        # FIXME really package model should have this logic and provide\n        # 'display_name' like users and groups\n        pkgobj = model.Package.get(validated_data_dict['id'])\n        name = pkgobj.title or pkgobj.name or pkgobj.id\n        message = _(\n            'You are already following {0}').format(name)\n        raise ValidationError({'message': message}, error_summary=message)\n\n    follower = model_save.follower_dict_save(validated_data_dict, context,\n                                             model.UserFollowingDataset)\n\n    if not context.get('defer_commit'):\n        model.repo.commit()\n\n    log.debug(u'User {follower} started following dataset {object}'.format(\n        follower=follower.follower_id, object=follower.object_id))\n\n    return model_dictize.user_following_dataset_dictize(follower, context)\n\n\ndef _group_or_org_member_create(context, data_dict, is_org=False):\n    # creator of group/org becomes an admin\n    # this needs to be after the repo.commit or else revisions break\n    model = context['model']\n    user = context['user']\n    session = context['session']\n\n    schema = ckan.logic.schema.member_schema()\n    data, errors = _validate(data_dict, schema, context)\n    if errors:\n        model.Session.rollback()\n        raise ValidationError(errors)\n\n    username = _get_or_bust(data_dict, 'username')\n    role = data_dict.get('role')\n    group_id = data_dict.get('id')\n    group = model.Group.get(group_id)\n    if not group:\n        msg = _('Organization not found') if is_org else _('Group not found')\n        raise NotFound(msg)\n    result = model.User.get(username)\n    if result:\n        user_id = result.id\n    else:\n        message = _(u'User {username} does not exist.').format(\n            username=username)\n        raise ValidationError({'message': message}, error_summary=message)\n    member_dict = {\n        'id': group.id,\n        'object': user_id,\n        'object_type': 'user',\n        'capacity': role,\n    }\n    member_create_context = {\n        'model': model,\n        'user': user,\n        'session': session,\n        'ignore_auth': context.get('ignore_auth'),\n    }\n    return logic.get_action('member_create')(member_create_context,\n                                             member_dict)\n\n\ndef group_member_create(context, data_dict):\n    '''Make a user a member of a group.\n\n    You must be authorized to edit the group.\n\n    :param id: the id or name of the group\n    :type id: string\n    :param username: name or id of the user to be made member of the group\n    :type username: string\n    :param role: role of the user in the group. One of ``member``, ``editor``,\n        or ``admin``\n    :type role: string\n\n    :returns: the newly created (or updated) membership\n    :rtype: dictionary\n    '''\n    _check_access('group_member_create', context, data_dict)\n    return _group_or_org_member_create(context, data_dict)\n\n\ndef organization_member_create(context, data_dict):\n    '''Make a user a member of an organization.\n\n    You must be authorized to edit the organization.\n\n    :param id: the id or name of the organization\n    :type id: string\n    :param username: name or id of the user to be made member of the\n        organization\n    :type username: string\n    :param role: role of the user in the organization. One of ``member``,\n        ``editor``, or ``admin``\n    :type role: string\n\n    :returns: the newly created (or updated) membership\n    :rtype: dictionary\n    '''\n    _check_access('organization_member_create', context, data_dict)\n    return _group_or_org_member_create(context, data_dict, is_org=True)\n\n\ndef follow_group(context, data_dict):\n    '''Start following a group.\n\n    You must provide your API key in the Authorization header.\n\n    :param id: the id or name of the group to follow, e.g. ``'roger'``\n    :type id: string\n\n    :returns: a representation of the 'follower' relationship between yourself\n        and the group\n    :rtype: dictionary\n\n    '''\n    if 'user' not in context:\n        raise logic.NotAuthorized(\n            _(\"You must be logged in to follow a group.\"))\n\n    model = context['model']\n    session = context['session']\n\n    userobj = model.User.get(context['user'])\n    if not userobj:\n        raise logic.NotAuthorized(\n            _(\"You must be logged in to follow a group.\"))\n\n    schema = context.get('schema',\n                         ckan.logic.schema.default_follow_group_schema())\n\n    validated_data_dict, errors = _validate(data_dict, schema, context)\n\n    if errors:\n        model.Session.rollback()\n        raise ValidationError(errors)\n\n    # Don't let a user follow a group she is already following.\n    if model.UserFollowingGroup.is_following(userobj.id,\n                                             validated_data_dict['id']):\n        groupobj = model.Group.get(validated_data_dict['id'])\n        name = groupobj.display_name\n        message = _(\n            'You are already following {0}').format(name)\n        raise ValidationError({'message': message}, error_summary=message)\n\n    follower = model_save.follower_dict_save(validated_data_dict, context,\n                                             model.UserFollowingGroup)\n\n    if not context.get('defer_commit'):\n        model.repo.commit()\n\n    log.debug(u'User {follower} started following group {object}'.format(\n        follower=follower.follower_id, object=follower.object_id))\n\n    return model_dictize.user_following_group_dictize(follower, context)\n", "# encoding: utf-8\n\n'''Unit tests for ckan/logic/auth/create.py.\n\n'''\nimport __builtin__ as builtins\n\nimport ckan\nimport ckan.logic as logic\nimport ckan.model as model\nimport ckan.plugins as p\nimport ckan.tests.factories as factories\nimport ckan.tests.helpers as helpers\nimport mock\nimport nose.tools\nfrom ckan.common import config\nfrom pyfakefs import fake_filesystem\n\nassert_equals = nose.tools.assert_equals\nassert_raises = nose.tools.assert_raises\nassert_not_equals = nose.tools.assert_not_equals\n\nreal_open = open\nfs = fake_filesystem.FakeFilesystem()\nfake_os = fake_filesystem.FakeOsModule(fs)\nfake_open = fake_filesystem.FakeFileOpen(fs)\n\n\ndef mock_open_if_open_fails(*args, **kwargs):\n    try:\n        return real_open(*args, **kwargs)\n    except (OSError, IOError):\n        return fake_open(*args, **kwargs)\n\n\nclass TestUserInvite(object):\n\n    def setup(self):\n        helpers.reset_db()\n\n    @mock.patch('ckan.lib.mailer.send_invite')\n    def test_invited_user_is_created_as_pending(self, _):\n        invited_user = self._invite_user_to_group()\n\n        assert invited_user is not None\n        assert invited_user.is_pending()\n\n    @mock.patch('ckan.lib.mailer.send_invite')\n    def test_creates_user_with_valid_username(self, _):\n        email = 'user$%+abc@email.com'\n        invited_user = self._invite_user_to_group(email)\n\n        assert invited_user.name.startswith('user---abc'), invited_user\n\n    @mock.patch('ckan.lib.mailer.send_invite')\n    def test_assigns_user_to_group_in_expected_role(self, _):\n        role = 'admin'\n        invited_user = self._invite_user_to_group(role=role)\n\n        group_ids = invited_user.get_group_ids(capacity=role)\n        assert len(group_ids) == 1, group_ids\n\n    @mock.patch('ckan.lib.mailer.send_invite')\n    def test_sends_invite(self, send_invite):\n        invited_user = self._invite_user_to_group()\n\n        assert send_invite.called\n        assert send_invite.call_args[0][0].id == invited_user.id\n\n    @mock.patch('ckan.lib.mailer.send_invite')\n    @mock.patch('random.SystemRandom')\n    def test_works_even_if_username_already_exists(self, rand, _):\n        # usernames\n        rand.return_value.random.side_effect = [1000, 1000, 2000, 3000]\n        # passwords (need to set something, otherwise choice will break)\n        rand.return_value.choice.side_effect = 'TestPassword1' * 3\n\n        for _ in range(3):\n            invited_user = self._invite_user_to_group(email='same@email.com')\n            assert invited_user is not None, invited_user\n\n    @mock.patch('ckan.lib.mailer.send_invite')\n    @nose.tools.raises(logic.ValidationError)\n    def test_requires_email(self, _):\n        self._invite_user_to_group(email=None)\n\n    @mock.patch('ckan.lib.mailer.send_invite')\n    @nose.tools.raises(logic.ValidationError)\n    def test_requires_role(self, _):\n        self._invite_user_to_group(role=None)\n\n    @mock.patch('ckan.lib.mailer.send_invite')\n    @nose.tools.raises(logic.NotFound)\n    def test_raises_not_found(self, _):\n        user = factories.User()\n\n        context = {\n            'user': user['name']\n        }\n        params = {\n            'email': 'a@example.com',\n            'group_id': 'group_not_found',\n            'role': 'admin'\n        }\n\n        helpers.call_action('user_invite', context, **params)\n\n    @mock.patch('ckan.lib.mailer.send_invite')\n    @nose.tools.raises(logic.ValidationError)\n    def test_requires_group_id(self, _):\n        self._invite_user_to_group(group={'id': None})\n\n    @mock.patch('ckan.lib.mailer.send_invite')\n    def test_user_name_lowercase_when_email_is_uppercase(self, _):\n        invited_user = self._invite_user_to_group(email='Maria@example.com')\n\n        assert_equals(invited_user.name.split('-')[0], 'maria')\n\n    @helpers.change_config('smtp.server', 'email.example.com')\n    def test_smtp_error_returns_error_message(self):\n\n        sysadmin = factories.Sysadmin()\n        group = factories.Group()\n\n        context = {\n            'user': sysadmin['name']\n        }\n        params = {\n            'email': 'example-invited-user@example.com',\n            'group_id': group['id'],\n            'role': 'editor'\n        }\n\n        assert_raises(logic.ValidationError, helpers.call_action,\n                      'user_invite', context, **params)\n\n        # Check that the pending user was deleted\n        user = model.Session.query(model.User).filter(\n            model.User.name.like('example-invited-user%')).all()\n\n        assert_equals(user[0].state, 'deleted')\n\n    def _invite_user_to_group(self, email='user@email.com',\n                              group=None, role='member'):\n        user = factories.User()\n        group = group or factories.Group(user=user)\n\n        context = {\n            'user': user['name']\n        }\n        params = {\n            'email': email,\n            'group_id': group['id'],\n            'role': role\n        }\n\n        result = helpers.call_action('user_invite', context, **params)\n\n        return model.User.get(result['id'])\n\n\nclass TestResourceViewCreate(object):\n\n    @classmethod\n    def setup_class(cls):\n        if not p.plugin_loaded('image_view'):\n            p.load('image_view')\n\n    @classmethod\n    def teardown_class(cls):\n        p.unload('image_view')\n        helpers.reset_db()\n\n    def setup(self):\n        helpers.reset_db()\n\n    def test_resource_view_create(self):\n        context = {}\n        params = self._default_resource_view_attributes()\n\n        result = helpers.call_action('resource_view_create', context, **params)\n\n        result.pop('id')\n        result.pop('package_id')\n\n        assert_equals(params, result)\n\n    def test_requires_resource_id(self):\n        context = {}\n        params = self._default_resource_view_attributes()\n        params.pop('resource_id')\n\n        assert_raises(logic.ValidationError, helpers.call_action,\n                      'resource_view_create', context, **params)\n\n    def test_requires_title(self):\n        context = {}\n        params = self._default_resource_view_attributes()\n        params.pop('title')\n\n        assert_raises(logic.ValidationError, helpers.call_action,\n                      'resource_view_create', context, **params)\n\n    @mock.patch('ckan.lib.datapreview.get_view_plugin')\n    def test_requires_view_type(self, get_view_plugin):\n        context = {}\n        params = self._default_resource_view_attributes()\n        params.pop('view_type')\n\n        get_view_plugin.return_value = 'mock_view_plugin'\n\n        assert_raises(logic.ValidationError, helpers.call_action,\n                      'resource_view_create', context, **params)\n\n    def test_raises_if_couldnt_find_resource(self):\n        context = {}\n        params = self._default_resource_view_attributes(resource_id='unknown')\n        assert_raises(logic.ValidationError, helpers.call_action,\n                      'resource_view_create', context, **params)\n\n    def test_raises_if_couldnt_find_view_extension(self):\n        context = {}\n        params = self._default_resource_view_attributes(view_type='unknown')\n        assert_raises(logic.ValidationError, helpers.call_action,\n                      'resource_view_create', context, **params)\n\n    @mock.patch('ckan.lib.datapreview')\n    def test_filterable_views_dont_require_any_extra_fields(self, datapreview_mock):\n        self._configure_datapreview_to_return_filterable_view(datapreview_mock)\n        context = {}\n        params = self._default_resource_view_attributes()\n\n        result = helpers.call_action('resource_view_create', context, **params)\n\n        result.pop('id')\n        result.pop('package_id')\n\n        assert_equals(params, result)\n\n    @mock.patch('ckan.lib.datapreview')\n    def test_filterable_views_converts_filter_fields_and_values_into_filters_dict(self, datapreview_mock):\n        self._configure_datapreview_to_return_filterable_view(datapreview_mock)\n        context = {}\n        filters = {\n            'filter_fields': ['country', 'weather', 'country'],\n            'filter_values': ['Brazil', 'warm', 'Argentina']\n        }\n        params = self._default_resource_view_attributes(**filters)\n        result = helpers.call_action('resource_view_create', context, **params)\n        expected_filters = {\n            'country': ['Brazil', 'Argentina'],\n            'weather': ['warm']\n        }\n        assert_equals(result['filters'], expected_filters)\n\n    @mock.patch('ckan.lib.datapreview')\n    def test_filterable_views_converts_filter_fields_and_values_to_list(self, datapreview_mock):\n        self._configure_datapreview_to_return_filterable_view(datapreview_mock)\n        context = {}\n        filters = {\n            'filter_fields': 'country',\n            'filter_values': 'Brazil'\n        }\n        params = self._default_resource_view_attributes(**filters)\n        result = helpers.call_action('resource_view_create', context, **params)\n        assert_equals(result['filter_fields'], ['country'])\n        assert_equals(result['filter_values'], ['Brazil'])\n        assert_equals(result['filters'], {'country': ['Brazil']})\n\n    @mock.patch('ckan.lib.datapreview')\n    def test_filterable_views_require_filter_fields_and_values_to_have_same_length(self, datapreview_mock):\n        self._configure_datapreview_to_return_filterable_view(datapreview_mock)\n        context = {}\n        filters = {\n            'filter_fields': ['country', 'country'],\n            'filter_values': 'Brazil'\n        }\n        params = self._default_resource_view_attributes(**filters)\n        assert_raises(logic.ValidationError, helpers.call_action,\n                      'resource_view_create', context, **params)\n\n    def test_non_filterable_views_dont_accept_filter_fields_and_values(self):\n        context = {}\n        filters = {\n            'filter_fields': 'country',\n            'filter_values': 'Brazil'\n        }\n        params = self._default_resource_view_attributes(**filters)\n        assert_raises(logic.ValidationError, helpers.call_action,\n                      'resource_view_create', context, **params)\n\n    def _default_resource_view_attributes(self, **kwargs):\n        default_attributes = {\n            'resource_id': factories.Resource()['id'],\n            'view_type': 'image_view',\n            'title': 'View',\n            'description': 'A nice view'\n        }\n\n        default_attributes.update(kwargs)\n\n        return default_attributes\n\n    def _configure_datapreview_to_return_filterable_view(self, datapreview_mock):\n        filterable_view = mock.MagicMock()\n        filterable_view.info.return_value = {'filterable': True}\n        datapreview_mock.get_view_plugin.return_value = filterable_view\n\n\nclass TestCreateDefaultResourceViews(object):\n\n    @classmethod\n    def setup_class(cls):\n        if not p.plugin_loaded('image_view'):\n            p.load('image_view')\n\n    @classmethod\n    def teardown_class(cls):\n        p.unload('image_view')\n\n        helpers.reset_db()\n\n    def setup(self):\n        helpers.reset_db()\n\n    @helpers.change_config('ckan.views.default_views', '')\n    def test_add_default_views_to_dataset_resources(self):\n\n        # New resources have no views\n        dataset_dict = factories.Dataset(resources=[\n            {\n                'url': 'http://some.image.png',\n                'format': 'png',\n                'name': 'Image 1',\n            },\n            {\n                'url': 'http://some.image.png',\n                'format': 'png',\n                'name': 'Image 2',\n            },\n        ])\n\n        # Change default views config setting\n        config['ckan.views.default_views'] = 'image_view'\n\n        context = {\n            'user': helpers.call_action('get_site_user')['name']\n        }\n        created_views = helpers.call_action(\n            'package_create_default_resource_views',\n            context,\n            package=dataset_dict)\n\n        assert_equals(len(created_views), 2)\n\n        assert_equals(created_views[0]['view_type'], 'image_view')\n        assert_equals(created_views[1]['view_type'], 'image_view')\n\n    @helpers.change_config('ckan.views.default_views', '')\n    def test_add_default_views_to_resource(self):\n\n        # New resources have no views\n        dataset_dict = factories.Dataset()\n        resource_dict = factories.Resource(\n            package_id=dataset_dict['id'],\n            url='http://some.image.png',\n            format='png',\n        )\n\n        # Change default views config setting\n        config['ckan.views.default_views'] = 'image_view'\n\n        context = {\n            'user': helpers.call_action('get_site_user')['name']\n        }\n        created_views = helpers.call_action(\n            'resource_create_default_resource_views',\n            context,\n            resource=resource_dict,\n            package=dataset_dict)\n\n        assert_equals(len(created_views), 1)\n\n        assert_equals(created_views[0]['view_type'], 'image_view')\n\n    @helpers.change_config('ckan.views.default_views', '')\n    def test_add_default_views_to_resource_no_dataset_passed(self):\n\n        # New resources have no views\n        dataset_dict = factories.Dataset()\n        resource_dict = factories.Resource(\n            package_id=dataset_dict['id'],\n            url='http://some.image.png',\n            format='png',\n        )\n\n        # Change default views config setting\n        config['ckan.views.default_views'] = 'image_view'\n\n        context = {\n            'user': helpers.call_action('get_site_user')['name']\n        }\n        created_views = helpers.call_action(\n            'resource_create_default_resource_views',\n            context,\n            resource=resource_dict)\n\n        assert_equals(len(created_views), 1)\n\n        assert_equals(created_views[0]['view_type'], 'image_view')\n\n\nclass TestResourceCreate(object):\n    import cgi\n\n    class FakeFileStorage(cgi.FieldStorage):\n        def __init__(self, fp, filename):\n            self.file = fp\n            self.filename = filename\n            self.name = 'upload'\n\n    @classmethod\n    def setup_class(cls):\n        helpers.reset_db()\n\n    def setup(self):\n        model.repo.rebuild_db()\n\n    def test_resource_create(self):\n        context = {}\n        params = {\n            'package_id': factories.Dataset()['id'],\n            'url': 'http://data',\n            'name': 'A nice resource',\n        }\n        result = helpers.call_action('resource_create', context, **params)\n\n        id = result.pop('id')\n\n        assert id\n\n        params.pop('package_id')\n        for key in params.keys():\n            assert_equals(params[key], result[key])\n\n    def test_it_requires_package_id(self):\n\n        data_dict = {\n            'url': 'http://data',\n        }\n\n        assert_raises(logic.ValidationError, helpers.call_action,\n                      'resource_create', **data_dict)\n\n    def test_doesnt_require_url(self):\n        user = factories.User()\n        dataset = factories.Dataset(user=user)\n        data_dict = {\n            'package_id': dataset['id']\n        }\n        new_resouce = helpers.call_action('resource_create', **data_dict)\n\n        data_dict = {\n            'id': new_resouce['id']\n        }\n        stored_resource = helpers.call_action('resource_show', **data_dict)\n\n        assert not stored_resource['url']\n\n    @helpers.change_config('ckan.storage_path', '/doesnt_exist')\n    @mock.patch.object(ckan.lib.uploader, 'os', fake_os)\n    @mock.patch.object(builtins, 'open', side_effect=mock_open_if_open_fails)\n    @mock.patch.object(ckan.lib.uploader, '_storage_path', new='/doesnt_exist')\n    def test_mimetype_by_url(self, mock_open):\n        '''\n        The mimetype is guessed from the url\n\n        Real world usage would be externally linking the resource and the mimetype would\n        be guessed, based on the url\n        '''\n        context = {}\n        params = {\n            'package_id': factories.Dataset()['id'],\n            'url': 'http://localhost/data.csv',\n            'name': 'A nice resource',\n        }\n        result = helpers.call_action('resource_create', context, **params)\n\n        mimetype = result.pop('mimetype')\n\n        assert mimetype\n        assert_equals(mimetype, 'text/csv')\n\n    def test_mimetype_by_url_without_path(self):\n        \"\"\"\n        The mimetype should not be guessed from url if url contains only domain\n        \"\"\"\n        context = {}\n        params = {\n            \"package_id\": factories.Dataset()[\"id\"],\n            \"url\": \"http://example.com\",\n            \"name\": \"A nice resource\",\n        }\n        result = helpers.call_action(\"resource_create\", context, **params)\n\n        mimetype = result.pop(\"mimetype\")\n        assert mimetype is None\n\n    def test_mimetype_by_user(self):\n        '''\n        The mimetype is supplied by the user\n\n        Real world usage would be using the FileStore API or web UI form to create a resource\n        and the user wanted to specify the mimetype themselves\n        '''\n        context = {}\n        params = {\n            'package_id': factories.Dataset()['id'],\n            'url': 'http://localhost/data.csv',\n            'name': 'A nice resource',\n            'mimetype': 'application/csv'\n        }\n        result = helpers.call_action('resource_create', context, **params)\n\n        mimetype = result.pop('mimetype')\n        assert_equals(mimetype, 'application/csv')\n\n    @helpers.change_config('ckan.storage_path', '/doesnt_exist')\n    @mock.patch.object(ckan.lib.uploader, 'os', fake_os)\n    @mock.patch.object(builtins, 'open', side_effect=mock_open_if_open_fails)\n    @mock.patch.object(ckan.lib.uploader, '_storage_path', new='/doesnt_exist')\n    def test_mimetype_by_upload_by_filename(self, mock_open):\n        '''\n        The mimetype is guessed from an uploaded file with a filename\n\n        Real world usage would be using the FileStore API or web UI form to upload a file, with a filename plus extension\n        If there's no url or the mimetype can't be guessed by the url, mimetype will be guessed by the extension in the filename\n        '''\n        import StringIO\n        test_file = StringIO.StringIO()\n        test_file.write('''\n        \"info\": {\n            \"title\": \"BC Data Catalogue API\",\n            \"description\": \"This API provides information about datasets in the BC Data Catalogue.\",\n            \"termsOfService\": \"http://www.data.gov.bc.ca/local/dbc/docs/license/API_Terms_of_Use.pdf\",\n            \"contact\": {\n                \"name\": \"Data BC\",\n                \"url\": \"http://data.gov.bc.ca/\",\n                \"email\": \"\"\n            },\n            \"license\": {\n                \"name\": \"Open Government License - British Columbia\",\n                \"url\": \"http://www.data.gov.bc.ca/local/dbc/docs/license/OGL-vbc2.0.pdf\"\n            },\n            \"version\": \"3.0.0\"\n        }\n        ''')\n        test_resource = TestResourceCreate.FakeFileStorage(test_file, 'test.json')\n\n        context = {}\n        params = {\n            'package_id': factories.Dataset()['id'],\n            'url': 'http://data',\n            'name': 'A nice resource',\n            'upload': test_resource\n        }\n\n        # Mock url_for as using a test request context interferes with the FS mocking\n        with mock.patch('ckan.lib.helpers.url_for'):\n            result = helpers.call_action('resource_create', context, **params)\n\n        mimetype = result.pop('mimetype')\n\n        assert mimetype\n        assert_equals(mimetype, 'application/json')\n\n    @helpers.change_config('ckan.mimetype_guess', 'file_contents')\n    @helpers.change_config('ckan.storage_path', '/doesnt_exist')\n    @mock.patch.object(ckan.lib.uploader, 'os', fake_os)\n    @mock.patch.object(builtins, 'open', side_effect=mock_open_if_open_fails)\n    @mock.patch.object(ckan.lib.uploader, '_storage_path', new='/doesnt_exist')\n    def test_mimetype_by_upload_by_file(self, mock_open):\n        '''\n        The mimetype is guessed from an uploaded file by the contents inside\n\n        Real world usage would be using the FileStore API or web UI form to upload a file, that has no extension\n        If the mimetype can't be guessed by the url or filename, mimetype will be guessed by the contents inside the file\n        '''\n        import StringIO\n        test_file = StringIO.StringIO()\n        test_file.write('''\n        Snow Course Name, Number, Elev. metres, Date of Survey, Snow Depth cm, Water Equiv. mm, Survey Code, % of Normal, Density %, Survey Period, Normal mm\n        SKINS LAKE,1B05,890,2015/12/30,34,53,,98,16,JAN-01,54\n        MCGILLIVRAY PASS,1C05,1725,2015/12/31,88,239,,87,27,JAN-01,274\n        NAZKO,1C08,1070,2016/01/05,20,31,,76,16,JAN-01,41\n        ''')\n        test_resource = TestResourceCreate.FakeFileStorage(test_file, '')\n\n        context = {}\n        params = {\n            'package_id': factories.Dataset()['id'],\n            'url': 'http://data',\n            'name': 'A nice resource',\n            'upload': test_resource\n        }\n\n        # Mock url_for as using a test request context interferes with the FS mocking\n        with mock.patch('ckan.lib.helpers.url_for'):\n            result = helpers.call_action('resource_create', context, **params)\n\n        mimetype = result.pop('mimetype')\n\n        assert mimetype\n        assert_equals(mimetype, 'text/plain')\n\n    @helpers.change_config('ckan.storage_path', '/doesnt_exist')\n    @mock.patch.object(ckan.lib.uploader, 'os', fake_os)\n    @mock.patch.object(builtins, 'open', side_effect=mock_open_if_open_fails)\n    @mock.patch.object(ckan.lib.uploader, '_storage_path', new='/doesnt_exist')\n    def test_size_of_resource_by_upload(self, mock_open):\n        '''\n        The size of the resource determined by the uploaded file\n        '''\n        import StringIO\n        test_file = StringIO.StringIO()\n        test_file.write('''\n        Snow Course Name, Number, Elev. metres, Date of Survey, Snow Depth cm, Water Equiv. mm, Survey Code, % of Normal, Density %, Survey Period, Normal mm\n        SKINS LAKE,1B05,890,2015/12/30,34,53,,98,16,JAN-01,54\n        MCGILLIVRAY PASS,1C05,1725,2015/12/31,88,239,,87,27,JAN-01,274\n        NAZKO,1C08,1070,2016/01/05,20,31,,76,16,JAN-01,41\n        ''')\n        test_resource = TestResourceCreate.FakeFileStorage(test_file, 'test.csv')\n\n        context = {}\n        params = {\n            'package_id': factories.Dataset()['id'],\n            'url': 'http://data',\n            'name': 'A nice resource',\n            'upload': test_resource\n        }\n\n        # Mock url_for as using a test request context interferes with the FS mocking\n        with mock.patch('ckan.lib.helpers.url_for'):\n            result = helpers.call_action('resource_create', context, **params)\n\n        size = result.pop('size')\n\n        assert size\n        assert size > 0\n\n    def test_size_of_resource_by_user(self):\n        '''\n        The size of the resource is provided by the users\n\n        Real world usage would be using the FileStore API and the user provides a size for the resource\n        '''\n        context = {}\n        params = {\n            'package_id': factories.Dataset()['id'],\n            'url': 'http://data',\n            'name': 'A nice resource',\n            'size': 500\n        }\n        result = helpers.call_action('resource_create', context, **params)\n\n        size = int(result.pop('size'))\n        assert_equals(size, 500)\n\n    def test_extras(self):\n        user = factories.User()\n        dataset = factories.Dataset(\n            user=user)\n\n        resource = helpers.call_action(\n            \"resource_create\",\n            package_id=dataset[\"id\"],\n            somekey=\"somevalue\",  # this is how to do resource extras\n            extras={u\"someotherkey\": u\"alt234\"},  # this isnt\n            subobject={u'hello': u'there'},  # JSON objects supported\n            sublist=[1, 2, 3],  # JSON lists suppoted\n            format=u\"plain text\",\n            url=u\"http://datahub.io/download/\",\n        )\n\n        assert resource[\"somekey\"] == \"somevalue\"\n        assert \"extras\" not in resource\n        assert \"someotherkey\" not in resource\n        assert resource[\"subobject\"] == {u\"hello\": u\"there\"}\n        assert resource[\"sublist\"] == [1, 2, 3]\n        resource = helpers.call_action(\"package_show\", id=dataset[\"id\"])[\n            \"resources\"\n        ][0]\n        assert resource[\"somekey\"] == \"somevalue\"\n        assert \"extras\" not in resource\n        assert \"someotherkey\" not in resource\n        assert resource[\"subobject\"] == {u\"hello\": u\"there\"}\n        assert resource[\"sublist\"] == [1, 2, 3]\n\n\nclass TestMemberCreate(object):\n    @classmethod\n    def setup_class(cls):\n        helpers.reset_db()\n\n    def setup(self):\n        model.repo.rebuild_db()\n\n    def test_group_member_creation(self):\n        user = factories.User()\n        group = factories.Group()\n\n        new_membership = helpers.call_action(\n            'group_member_create',\n            id=group['id'],\n            username=user['name'],\n            role='member',\n        )\n\n        assert_equals(new_membership['group_id'], group['id'])\n        assert_equals(new_membership['table_name'], 'user')\n        assert_equals(new_membership['table_id'], user['id'])\n        assert_equals(new_membership['capacity'], 'member')\n\n    def test_organization_member_creation(self):\n        user = factories.User()\n        organization = factories.Organization()\n\n        new_membership = helpers.call_action(\n            'organization_member_create',\n            id=organization['id'],\n            username=user['name'],\n            role='member',\n        )\n\n        assert_equals(new_membership['group_id'], organization['id'])\n        assert_equals(new_membership['table_name'], 'user')\n        assert_equals(new_membership['table_id'], user['id'])\n        assert_equals(new_membership['capacity'], 'member')\n\n    def test_group_member_creation_raises_validation_error_if_id_missing(self):\n\n        assert_raises(logic.ValidationError,\n                      helpers.call_action, 'group_member_create',\n                      username='someuser',\n                      role='member',)\n\n    def test_group_member_creation_raises_validation_error_if_username_missing(self):\n\n        assert_raises(logic.ValidationError,\n                      helpers.call_action, 'group_member_create',\n                      id='someid',\n                      role='member',)\n\n    def test_group_member_creation_raises_validation_error_if_role_missing(self):\n\n        assert_raises(logic.ValidationError,\n                      helpers.call_action, 'group_member_create',\n                      id='someid',\n                      username='someuser',)\n\n    def test_org_member_creation_raises_validation_error_if_id_missing(self):\n\n        assert_raises(logic.ValidationError,\n                      helpers.call_action, 'organization_member_create',\n                      username='someuser',\n                      role='member',)\n\n    def test_org_member_creation_raises_validation_error_if_username_missing(self):\n\n        assert_raises(logic.ValidationError,\n                      helpers.call_action, 'organization_member_create',\n                      id='someid',\n                      role='member',)\n\n    def test_org_member_creation_raises_validation_error_if_role_missing(self):\n\n        assert_raises(logic.ValidationError,\n                      helpers.call_action, 'organization_member_create',\n                      id='someid',\n                      username='someuser',)\n\n\nclass TestDatasetCreate(helpers.FunctionalTestBase):\n\n    def test_normal_user_cant_set_id(self):\n        user = factories.User()\n        context = {\n            'user': user['name'],\n            'ignore_auth': False,\n        }\n        assert_raises(\n            logic.ValidationError,\n            helpers.call_action,\n            'package_create',\n            context=context,\n            id='1234',\n            name='test-dataset',\n        )\n\n    def test_sysadmin_can_set_id(self):\n        user = factories.Sysadmin()\n        context = {\n            'user': user['name'],\n            'ignore_auth': False,\n        }\n        dataset = helpers.call_action(\n            'package_create',\n            context=context,\n            id='1234',\n            name='test-dataset',\n        )\n        assert_equals(dataset['id'], '1234')\n\n    def test_id_cant_already_exist(self):\n        dataset = factories.Dataset()\n        user = factories.Sysadmin()\n        assert_raises(\n            logic.ValidationError,\n            helpers.call_action,\n            'package_create',\n            id=dataset['id'],\n            name='test-dataset',\n        )\n\n    def test_name_not_changed_during_deletion(self):\n        dataset = factories.Dataset()\n        helpers.call_action('package_delete', id=dataset['id'])\n        deleted_dataset = helpers.call_action('package_show', id=dataset['id'])\n        assert_equals(deleted_dataset['name'], dataset['name'])\n\n    def test_name_not_changed_after_restoring(self):\n        dataset = factories.Dataset()\n        context = {\n            'user': factories.Sysadmin()['name']\n        }\n        helpers.call_action('package_delete', id=dataset['id'])\n        deleted_dataset = helpers.call_action('package_show', id=dataset['id'])\n        restored_dataset = helpers.call_action(\n            'package_patch', context=context, id=dataset['id'], state='active')\n        assert_equals(deleted_dataset['name'], restored_dataset['name'])\n        assert_equals(deleted_dataset['id'], restored_dataset['id'])\n\n    def test_creation_of_dataset_with_name_same_as_of_previously_removed(self):\n        dataset = factories.Dataset()\n        initial_name = dataset['name']\n        helpers.call_action('package_delete', id=dataset['id'])\n        new_dataset = helpers.call_action(\n            'package_create',\n            name=initial_name\n        )\n        assert_equals(new_dataset['name'], initial_name)\n        deleted_dataset = helpers.call_action('package_show', id=dataset['id'])\n\n        assert_not_equals(new_dataset['id'], deleted_dataset['id'])\n        assert_equals(deleted_dataset['name'], deleted_dataset['id'])\n\n    def test_missing_id(self):\n        assert_raises(\n            logic.ValidationError, helpers.call_action,\n            'package_create'\n        )\n\n    def test_name(self):\n        dataset = helpers.call_action(\n            'package_create',\n            name='some-name',\n        )\n\n        assert_equals(dataset['name'], 'some-name')\n        assert_equals(\n            helpers.call_action('package_show', id=dataset['id'])['name'],\n            'some-name')\n\n    def test_title(self):\n        dataset = helpers.call_action(\n            'package_create',\n            name='test_title',\n            title='New Title',\n        )\n\n        assert_equals(dataset['title'], 'New Title')\n        assert_equals(\n            helpers.call_action('package_show', id=dataset['id'])['title'],\n            'New Title')\n\n    def test_extras(self):\n        dataset = helpers.call_action(\n            'package_create',\n            name='test-extras',\n            title='Test Extras',\n            extras=[{'key': u'original media',\n                     'value': u'\"book\"'}],\n        )\n\n        assert_equals(dataset['extras'][0]['key'], 'original media')\n        assert_equals(dataset['extras'][0]['value'], '\"book\"')\n        dataset = helpers.call_action('package_show', id=dataset['id'])\n        assert_equals(dataset['extras'][0]['key'], 'original media')\n        assert_equals(dataset['extras'][0]['value'], '\"book\"')\n\n    def test_license(self):\n        dataset = helpers.call_action(\n            'package_create',\n            name='test-license',\n            title='Test License',\n            license_id='other-open',\n        )\n\n        assert_equals(dataset['license_id'], 'other-open')\n        dataset = helpers.call_action('package_show', id=dataset['id'])\n        assert_equals(dataset['license_id'], 'other-open')\n\n    def test_notes(self):\n        dataset = helpers.call_action(\n            'package_create',\n            name='test-notes',\n            title='Test Notes',\n            notes='some notes',\n        )\n\n        assert_equals(dataset['notes'], 'some notes')\n        dataset = helpers.call_action('package_show', id=dataset['id'])\n        assert_equals(dataset['notes'], 'some notes')\n\n    def test_resources(self):\n        dataset = helpers.call_action(\n            'package_create',\n            name='test-resources',\n            title='Test Resources',\n            resources=[\n                {'alt_url': u'alt123',\n                 'description': u'Full text.',\n                 'somekey': 'somevalue',  # this is how to do resource extras\n                 'extras': {u'someotherkey': u'alt234'},  # this isnt\n                 'format': u'plain text',\n                 'hash': u'abc123',\n                 'position': 0,\n                 'url': u'http://datahub.io/download/'},\n                {'description': u'Index of the novel',\n                 'format': u'JSON',\n                 'position': 1,\n                 'url': u'http://datahub.io/index.json'}\n            ],\n        )\n\n        resources = dataset['resources']\n        assert_equals(resources[0]['alt_url'], 'alt123')\n        assert_equals(resources[0]['description'], 'Full text.')\n        assert_equals(resources[0]['somekey'], 'somevalue')\n        assert 'extras' not in resources[0]\n        assert 'someotherkey' not in resources[0]\n        assert_equals(resources[0]['format'], 'plain text')\n        assert_equals(resources[0]['hash'], 'abc123')\n        assert_equals(resources[0]['position'], 0)\n        assert_equals(resources[0]['url'], 'http://datahub.io/download/')\n        assert_equals(resources[1]['description'], 'Index of the novel')\n        assert_equals(resources[1]['format'], 'JSON')\n        assert_equals(resources[1]['url'], 'http://datahub.io/index.json')\n        assert_equals(resources[1]['position'], 1)\n        resources = helpers.call_action(\n            'package_show', id=dataset['id'])['resources']\n        assert_equals(resources[0]['alt_url'], 'alt123')\n        assert_equals(resources[0]['description'], 'Full text.')\n        assert_equals(resources[0]['somekey'], 'somevalue')\n        assert 'extras' not in resources[0]\n        assert 'someotherkey' not in resources[0]\n        assert_equals(resources[0]['format'], 'plain text')\n        assert_equals(resources[0]['hash'], 'abc123')\n        assert_equals(resources[0]['position'], 0)\n        assert_equals(resources[0]['url'], 'http://datahub.io/download/')\n        assert_equals(resources[1]['description'], 'Index of the novel')\n        assert_equals(resources[1]['format'], 'JSON')\n        assert_equals(resources[1]['url'], 'http://datahub.io/index.json')\n        assert_equals(resources[1]['position'], 1)\n\n    def test_tags(self):\n        dataset = helpers.call_action(\n            'package_create',\n            name='test-tags',\n            title='Test Tags',\n            tags=[{'name': u'russian'}, {'name': u'tolstoy'}],\n        )\n\n        tag_names = sorted([tag_dict['name']\n                            for tag_dict in dataset['tags']])\n        assert_equals(tag_names, ['russian', 'tolstoy'])\n        dataset = helpers.call_action('package_show', id=dataset['id'])\n        tag_names = sorted([tag_dict['name']\n                            for tag_dict in dataset['tags']])\n        assert_equals(tag_names, ['russian', 'tolstoy'])\n\n\nclass TestGroupCreate(helpers.FunctionalTestBase):\n\n    def test_create_group(self):\n        user = factories.User()\n        context = {\n            'user': user['name'],\n            'ignore_auth': True,\n        }\n\n        group = helpers.call_action(\n            'group_create',\n            context=context,\n            name='test-group',\n        )\n\n        assert len(group['users']) == 1\n        assert group['display_name'] == u'test-group'\n        assert group['package_count'] == 0\n        assert not group['is_organization']\n        assert group['type'] == 'group'\n\n    @nose.tools.raises(logic.ValidationError)\n    def test_create_group_validation_fail(self):\n        user = factories.User()\n        context = {\n            'user': user['name'],\n            'ignore_auth': True,\n        }\n\n        group = helpers.call_action(\n            'group_create',\n            context=context,\n            name='',\n        )\n\n    def test_create_group_return_id(self):\n        import re\n\n        user = factories.User()\n        context = {\n            'user': user['name'],\n            'ignore_auth': True,\n            'return_id_only': True\n        }\n\n        group = helpers.call_action(\n            'group_create',\n            context=context,\n            name='test-group',\n        )\n\n        assert isinstance(group, str)\n        assert re.match('([a-f\\d]{8}(-[a-f\\d]{4}){3}-[a-f\\d]{12}?)', group)\n\n    def test_create_matches_show(self):\n        user = factories.User()\n        context = {\n            'user': user['name'],\n            'ignore_auth': True,\n        }\n\n        created = helpers.call_action(\n            'organization_create',\n            context=context,\n            name='test-organization',\n        )\n\n        shown = helpers.call_action(\n            'organization_show',\n            context=context,\n            id='test-organization',\n        )\n\n        assert sorted(created.keys()) == sorted(shown.keys())\n        for k in created.keys():\n            assert created[k] == shown[k], k\n\n\nclass TestOrganizationCreate(helpers.FunctionalTestBase):\n\n    def test_create_organization(self):\n        user = factories.User()\n        context = {\n            'user': user['name'],\n            'ignore_auth': True,\n        }\n\n        org = helpers.call_action(\n            'organization_create',\n            context=context,\n            name='test-organization',\n        )\n\n        assert len(org['users']) == 1\n        assert org['display_name'] == u'test-organization'\n        assert org['package_count'] == 0\n        assert org['is_organization']\n        assert org['type'] == 'organization'\n\n    @nose.tools.raises(logic.ValidationError)\n    def test_create_organization_validation_fail(self):\n        user = factories.User()\n        context = {\n            'user': user['name'],\n            'ignore_auth': True,\n        }\n\n        org = helpers.call_action(\n            'organization_create',\n            context=context,\n            name='',\n        )\n\n    def test_create_organization_return_id(self):\n        import re\n\n        user = factories.User()\n        context = {\n            'user': user['name'],\n            'ignore_auth': True,\n            'return_id_only': True\n        }\n\n        org = helpers.call_action(\n            'organization_create',\n            context=context,\n            name='test-organization',\n        )\n\n        assert isinstance(org, str)\n        assert re.match('([a-f\\d]{8}(-[a-f\\d]{4}){3}-[a-f\\d]{12}?)', org)\n\n    def test_create_matches_show(self):\n        user = factories.User()\n        context = {\n            'user': user['name'],\n            'ignore_auth': True,\n        }\n\n        created = helpers.call_action(\n            'organization_create',\n            context=context,\n            name='test-organization',\n        )\n\n        shown = helpers.call_action(\n            'organization_show',\n            context=context,\n            id='test-organization',\n        )\n\n        assert sorted(created.keys()) == sorted(shown.keys())\n        for k in created.keys():\n            assert created[k] == shown[k], k\n\n    def test_create_organization_custom_type(self):\n        custom_org_type = 'some-custom-type'\n        user = factories.User()\n        context = {\n            'user': user['name'],\n            'ignore_auth': True,\n        }\n\n        org = helpers.call_action(\n            'organization_create',\n            context=context,\n            name='test-organization',\n            type=custom_org_type\n        )\n\n        assert len(org['users']) == 1\n        assert org['display_name'] == u'test-organization'\n        assert org['package_count'] == 0\n        assert org['is_organization']\n        assert org['type'] == custom_org_type\n\n\nclass TestUserCreate(helpers.FunctionalTestBase):\n\n    def test_user_create_with_password_hash(self):\n        sysadmin = factories.Sysadmin()\n        context = {\n            'user': sysadmin['name'],\n        }\n\n        user = helpers.call_action(\n            'user_create',\n            context=context,\n            email='test@example.com',\n            name='test',\n            password_hash='pretend-this-is-a-valid-hash')\n\n        user_obj = model.User.get(user['id'])\n        assert user_obj.password == 'pretend-this-is-a-valid-hash'\n\n    def test_user_create_password_hash_not_for_normal_users(self):\n        normal_user = factories.User()\n        context = {\n            'user': normal_user['name'],\n        }\n\n        user = helpers.call_action(\n            'user_create',\n            context=context,\n            email='test@example.com',\n            name='test',\n            password='required',\n            password_hash='pretend-this-is-a-valid-hash')\n\n        user_obj = model.User.get(user['id'])\n        assert user_obj.password != 'pretend-this-is-a-valid-hash'\n\n    def test_anon_user_create_does_not_update(self):\n\n        user1 = factories.User(about=\"This is user 1\")\n        user_dict = {\n            \"id\": user1[\"id\"],\n            \"name\": \"some_name\",\n            \"email\": \"some_email@example.com\",\n            \"password\": \"test1234\",\n        }\n\n        context = {\n            \"user\": None,\n            \"ignore_auth\": False,\n        }\n\n        user2 = helpers.call_action(\"user_create\", context=context, **user_dict)\n        assert user2[\"id\"] != user1[\"id\"]\n        assert user2[\"about\"] != \"This is user 1\"\n\n    def test_normal_user_create_does_not_update(self):\n\n        user1 = factories.User(about=\"This is user 1\")\n        user_dict = {\n            \"id\": user1[\"id\"],\n            \"name\": \"some_name\",\n            \"email\": \"some_email@example.com\",\n            \"password\": \"test1234\",\n        }\n\n        context = {\n            \"user\": factories.User()[\"name\"],\n            \"ignore_auth\": False,\n        }\n\n        user2 = helpers.call_action(\"user_create\", context=context, **user_dict)\n        assert user2[\"id\"] != user1[\"id\"]\n        assert user2[\"about\"] != \"This is user 1\"\n\n    def test_sysadmin_user_create_does_not_update(self):\n\n        user1 = factories.User(about=\"This is user 1\")\n        user_dict = {\n            \"id\": user1[\"id\"],\n            \"name\": \"some_name\",\n            \"email\": \"some_email@example.com\",\n            \"password\": \"test1234\",\n        }\n\n        context = {\n            \"user\": factories.Sysadmin()[\"name\"],\n            \"ignore_auth\": False,\n        }\n\n        user2 = helpers.call_action(\"user_create\", context=context, **user_dict)\n        assert user2[\"id\"] != user1[\"id\"]\n        assert user2[\"about\"] != \"This is user 1\"\n\n    def test_anon_user_can_not_provide_id(self):\n\n        user_dict = {\n            \"id\": \"custom_id\",\n            \"name\": \"some_name\",\n            \"email\": \"some_email@example.com\",\n            \"password\": \"test1234\",\n        }\n\n        context = {\n            \"user\": None,\n            \"ignore_auth\": False,\n        }\n\n        user = helpers.call_action(\"user_create\", context=context, **user_dict)\n        assert user[\"id\"] != \"custom_id\"\n\n    def test_normal_user_can_not_provide_id(self):\n\n        user_dict = {\n            \"id\": \"custom_id\",\n            \"name\": \"some_name\",\n            \"email\": \"some_email@example.com\",\n            \"password\": \"test1234\",\n        }\n\n        context = {\n            \"user\": None,\n            \"ignore_auth\": False,\n        }\n\n        user = helpers.call_action(\"user_create\", context=context, **user_dict)\n        assert user[\"id\"] != \"custom_id\"\n\n    def test_sysadmin_can_provide_custom_id(self):\n\n        sysadmin = factories.Sysadmin()\n\n        user_dict = {\n            \"id\": \"custom_id\",\n            \"name\": \"some_name\",\n            \"email\": \"some_email@example.com\",\n            \"password\": \"test1234\",\n        }\n        context = {\n            \"user\": sysadmin[\"name\"],\n            \"ignore_auth\": False,\n        }\n\n        user = helpers.call_action(\"user_create\", context=context, **user_dict)\n        assert user[\"id\"] == \"custom_id\"\n"], "filenames": ["ckan/logic/action/create.py", "ckan/tests/logic/action/test_create.py"], "buggy_code_start_loc": [955, 1203], "buggy_code_end_loc": [955, 1203], "fixing_code_start_loc": [956, 1204], "fixing_code_end_loc": [963, 1313], "type": "CWE-330", "message": "CKAN is an open-source DMS (data management system) for powering data hubs and data portals. When creating a new container based on one of the Docker images listed below, the same secret key was being used by default. If the users didn't set a custom value via environment variables in the `.env` file, that key was shared across different CKAN instances, making it easy to forge authentication requests. Users overriding the default secret key in their own `.env` file are not affected by this issue. Note that the legacy images (ckan/ckan) located in the main CKAN repo are not affected by this issue. The affected images are ckan/ckan-docker, (ckan/ckan-base images), okfn/docker-ckan (openknowledge/ckan-base and openknowledge/ckan-dev images) keitaroinc/docker-ckan (keitaro/ckan images).", "other": {"cve": {"id": "CVE-2023-22746", "sourceIdentifier": "security-advisories@github.com", "published": "2023-02-03T22:15:11.733", "lastModified": "2023-02-14T15:39:41.820", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "CKAN is an open-source DMS (data management system) for powering data hubs and data portals. When creating a new container based on one of the Docker images listed below, the same secret key was being used by default. If the users didn't set a custom value via environment variables in the `.env` file, that key was shared across different CKAN instances, making it easy to forge authentication requests. Users overriding the default secret key in their own `.env` file are not affected by this issue. Note that the legacy images (ckan/ckan) located in the main CKAN repo are not affected by this issue. The affected images are ckan/ckan-docker, (ckan/ckan-base images), okfn/docker-ckan (openknowledge/ckan-base and openknowledge/ckan-dev images) keitaroinc/docker-ckan (keitaro/ckan images)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-330"}, {"lang": "en", "value": "CWE-344"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:okfn:ckan:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.8.12", "matchCriteriaId": "94E736ED-CD0F-4634-B739-AEF507A62808"}, {"vulnerable": true, "criteria": "cpe:2.3:a:okfn:ckan:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.9.0", "versionEndExcluding": "2.9.7", "matchCriteriaId": "3960F8B4-0768-4C32-855E-D62384B25511"}]}]}], "references": [{"url": "https://github.com/ckan/ckan/commit/44af0f0a148fcc0e0fbcf02fe69b7db13459a84b", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/ckan/ckan/commit/4c22c135fa486afa13855d1cdb9765eaf418d2aa", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/ckan/ckan/security/advisories/GHSA-pr8j-v4c8-h62x", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ckan/ckan/commit/44af0f0a148fcc0e0fbcf02fe69b7db13459a84b"}}