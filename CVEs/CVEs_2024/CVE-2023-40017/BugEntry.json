{"buggy_code": ["#########################################################################\n#\n# Copyright (C) 2016 OSGeo\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program. If not, see <http://www.gnu.org/licenses/>.\n#\n#########################################################################\n\n\"\"\"\nThis file demonstrates two different styles of tests (one doctest and one\nunittest). These will both pass when you run \"manage.py test\".\n\nReplace these with more appropriate tests for your application.\n\"\"\"\nimport json\nimport io\nimport zipfile\n\nfrom urllib.parse import urljoin\n\nfrom django.conf import settings\nfrom geonode.proxy.templatetags.proxy_lib_tags import original_link_available\nfrom django.test.client import RequestFactory\nfrom django.core.files.uploadedfile import SimpleUploadedFile\nfrom unittest.mock import patch\n\nfrom geonode.upload.models import Upload\n\ntry:\n    from unittest.mock import MagicMock\nexcept ImportError:\n    from unittest.mock import MagicMock\n\nfrom django.urls import reverse\nfrom django.contrib.auth import get_user_model\nfrom django.test.utils import override_settings\n\nfrom geonode import geoserver\nfrom geonode.base.models import Link\nfrom geonode.layers.models import Dataset\nfrom geonode.decorators import on_ogc_backend\nfrom geonode.tests.base import GeoNodeBaseTestSupport\nfrom geonode.base.populate_test_data import create_models, create_single_dataset\n\nTEST_DOMAIN = \".github.com\"\nTEST_URL = f\"https://help{TEST_DOMAIN}/\"\n\n\nclass ProxyTest(GeoNodeBaseTestSupport):\n    def setUp(self):\n        super().setUp()\n        self.maxDiff = None\n        self.admin = get_user_model().objects.get(username=\"admin\")\n\n        # FIXME(Ariel): These tests do not work when the computer is offline.\n        self.proxy_url = \"/proxy/\"\n        self.url = TEST_URL\n\n    @override_settings(DEBUG=True, PROXY_ALLOWED_HOSTS=())\n    def test_validate_host_disabled_in_debug(self):\n        \"\"\"If PROXY_ALLOWED_HOSTS is empty and DEBUG is True, all hosts pass the proxy.\"\"\"\n        response = self.client.get(f\"{self.proxy_url}?url={self.url}\")\n        if response.status_code != 404:  # 404 - NOT FOUND\n            self.assertTrue(response.status_code in (200, 301), response.status_code)\n\n    @override_settings(DEBUG=False, PROXY_ALLOWED_HOSTS=())\n    def test_validate_host_disabled_not_in_debug(self):\n        \"\"\"If PROXY_ALLOWED_HOSTS is empty and DEBUG is False requests should return 403.\"\"\"\n        response = self.client.get(f\"{self.proxy_url}?url={self.url}\")\n        if response.status_code != 404:  # 404 - NOT FOUND\n            self.assertEqual(response.status_code, 403, response.status_code)\n\n    @override_settings(DEBUG=False, PROXY_ALLOWED_HOSTS=(TEST_DOMAIN,))\n    def test_proxy_allowed_host(self):\n        \"\"\"If PROXY_ALLOWED_HOSTS is not empty and DEBUG is False requests should return no error.\"\"\"\n        self.client.login(username=\"admin\", password=\"admin\")\n        response = self.client.get(f\"{self.proxy_url}?url={self.url}\")\n        if response.status_code != 404:  # 404 - NOT FOUND\n            self.assertEqual(response.status_code, 200, response.status_code)\n\n    @override_settings(DEBUG=False, PROXY_ALLOWED_HOSTS=())\n    def test_validate_remote_services_hosts(self):\n        \"\"\"If PROXY_ALLOWED_HOSTS is empty and DEBUG is False requests should return 200\n        for Remote Services hosts.\"\"\"\n        from geonode.services.models import Service\n        from geonode.services.enumerations import WMS, INDEXED\n\n        Service.objects.get_or_create(\n            type=WMS,\n            name=\"Bogus\",\n            title=\"Pocus\",\n            owner=self.admin,\n            method=INDEXED,\n            base_url=\"http://bogus.pocus.com/ows\",\n        )\n        response = self.client.get(f\"{self.proxy_url}?url=http://bogus.pocus.com/ows/wms?request=GetCapabilities\")\n        # 200 - FOUND\n        self.assertTrue(response.status_code in (200, 301))\n\n    @override_settings(DEBUG=False, PROXY_ALLOWED_HOSTS=(\".example.org\",))\n    def test_relative_urls(self):\n        \"\"\"Proxying to a URL with a relative path element should normalise the path into\n        an absolute path before calling the remote URL.\"\"\"\n        import geonode.proxy.views\n\n        class Response:\n            status_code = 200\n            content = \"Hello World\"\n            headers = {\"Content-Type\": \"text/html\"}\n\n        request_mock = MagicMock()\n        request_mock.return_value = (Response(), None)\n\n        geonode.proxy.views.http_client.request = request_mock\n        url = \"http://example.org/test/test/../../index.html\"\n\n        self.client.get(f\"{self.proxy_url}?url={url}\")\n        assert request_mock.call_args[0][0] == \"http://example.org/index.html\"\n\n    def test_proxy_preserve_headers(self):\n        \"\"\"The GeoNode Proxy should preserve the original request headers.\"\"\"\n        import geonode.proxy.views\n\n        _test_headers = {\n            \"Access-Control-Allow-Credentials\": False,\n            \"Access-Control-Allow-Headers\": \"Content-Type, Accept, Authorization, Origin, User-Agent\",\n            \"Access-Control-Allow-Methods\": \"GET, POST, PUT, PATCH, OPTIONS\",\n            \"Cache-Control\": \"public, must-revalidate, max-age = 30\",\n            \"Connection\": \"keep-alive\",\n            \"Content-Language\": \"en\",\n            \"Content-Length\": 116559,\n            \"Content-Type\": \"image/tiff\",\n            \"Content-Disposition\": 'attachment; filename=\"filename.tif\"',\n            \"Date\": \"Fri, 05 Nov 2021 17: 19: 11 GMT\",\n            \"Server\": \"nginx/1.17.2\",\n            \"Set-Cookie\": \"sessionid = bogus-pocus; HttpOnly; Path=/; SameSite=Lax\",\n            \"Strict-Transport-Security\": \"max-age=3600; includeSubDomains\",\n            \"Vary\": \"Authorization, Accept-Language, Cookie, origin\",\n            \"X-Content-Type-Options\": \"nosniff\",\n            \"X-XSS-Protection\": \"1; mode=block\",\n        }\n\n        class Response:\n            status_code = 200\n            content = \"Hello World\"\n            headers = _test_headers\n\n        request_mock = MagicMock()\n        request_mock.return_value = (Response(), None)\n\n        geonode.proxy.views.http_client.request = request_mock\n        url = \"http://example.org/test/test/../../image.tiff\"\n\n        response = self.client.get(f\"{self.proxy_url}?url={url}\")\n        self.assertDictContainsSubset(\n            dict(response.headers.copy()),\n            {\n                \"Content-Type\": \"text/plain\",\n                \"Vary\": \"Authorization, Accept-Language, Cookie, origin\",\n                \"X-Content-Type-Options\": \"nosniff\",\n                \"X-XSS-Protection\": \"1; mode=block\",\n                \"Referrer-Policy\": \"same-origin\",\n                \"X-Frame-Options\": \"SAMEORIGIN\",\n                \"Content-Language\": \"en-us\",\n                \"Content-Length\": \"119\",\n                \"Content-Disposition\": 'attachment; filename=\"filename.tif\"',\n            },\n        )\n\n\nclass DownloadResourceTestCase(GeoNodeBaseTestSupport):\n    def setUp(self):\n        super().setUp()\n        self.maxDiff = None\n        create_models(type=\"dataset\")\n\n    @on_ogc_backend(geoserver.BACKEND_PACKAGE)\n    def test_download_url_with_not_existing_file(self):\n        dataset = Dataset.objects.all().first()\n        self.client.login(username=\"admin\", password=\"admin\")\n        # ... all should be good\n        response = self.client.get(reverse(\"download\", args=(dataset.id,)))\n        # Espected 404 since there are no files available for this layer\n        self.assertEqual(response.status_code, 404)\n        content = response.content\n        if isinstance(content, bytes):\n            content = content.decode(\"UTF-8\")\n        data = content\n        self.assertTrue(\"No files have been found for this resource. Please, contact a system administrator.\" in data)\n\n    @patch(\"geonode.storage.manager.storage_manager.exists\")\n    @patch(\"geonode.storage.manager.storage_manager.open\")\n    @on_ogc_backend(geoserver.BACKEND_PACKAGE)\n    def test_download_url_with_existing_files(self, fopen, fexists):\n        fexists.return_value = True\n        fopen.return_value = SimpleUploadedFile(\"foo_file.shp\", b\"scc\")\n        dataset = Dataset.objects.all().first()\n\n        dataset.files = [\n            \"/tmpe1exb9e9/foo_file.dbf\",\n            \"/tmpe1exb9e9/foo_file.prj\",\n            \"/tmpe1exb9e9/foo_file.shp\",\n            \"/tmpe1exb9e9/foo_file.shx\",\n        ]\n\n        dataset.save()\n\n        dataset.refresh_from_db()\n\n        upload = Upload.objects.create(state=\"RUNNING\", resource=dataset)\n\n        assert upload\n\n        self.client.login(username=\"admin\", password=\"admin\")\n        # ... all should be good\n        response = self.client.get(reverse(\"download\", args=(dataset.id,)))\n        # Espected 404 since there are no files available for this layer\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(\"application/zip\", response.headers.get(\"Content-Type\"))\n        self.assertEqual('attachment; filename=\"CA.zip\"', response.headers.get(\"Content-Disposition\"))\n\n    @patch(\"geonode.storage.manager.storage_manager.exists\")\n    @patch(\"geonode.storage.manager.storage_manager.open\")\n    @on_ogc_backend(geoserver.BACKEND_PACKAGE)\n    def test_download_files(self, fopen, fexists):\n        fexists.return_value = True\n        fopen.return_value = SimpleUploadedFile(\"foo_file.shp\", b\"scc\")\n        dataset = Dataset.objects.all().first()\n\n        dataset.files = [\n            \"/tmpe1exb9e9/foo_file.dbf\",\n            \"/tmpe1exb9e9/foo_file.prj\",\n            \"/tmpe1exb9e9/foo_file.shp\",\n            \"/tmpe1exb9e9/foo_file.shx\",\n        ]\n\n        dataset.save()\n\n        dataset.refresh_from_db()\n\n        Upload.objects.create(state=\"COMPLETE\", resource=dataset)\n\n        self.client.login(username=\"admin\", password=\"admin\")\n        response = self.client.get(reverse(\"download\", args=(dataset.id,)))\n        # headers and status assertions\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.get(\"content-type\"), \"application/zip\")\n        self.assertEqual(response.get(\"content-disposition\"), f'attachment; filename=\"{dataset.name}.zip\"')\n        # Inspect content\n        zip_content = io.BytesIO(b\"\".join(response.streaming_content))\n        zip = zipfile.ZipFile(zip_content)\n        zip_files = zip.namelist()\n        self.assertEqual(len(zip_files), 4)\n        self.assertIn(\".shp\", \"\".join(zip_files))\n        self.assertIn(\".dbf\", \"\".join(zip_files))\n        self.assertIn(\".shx\", \"\".join(zip_files))\n        self.assertIn(\".prj\", \"\".join(zip_files))\n\n\nclass OWSApiTestCase(GeoNodeBaseTestSupport):\n    def setUp(self):\n        super().setUp()\n        self.maxDiff = None\n        create_models(type=\"dataset\")\n        # prepare some WMS endpoints\n        q = Link.objects.all()\n        for lyr in q[:3]:\n            lyr.link_type = \"OGC:WMS\"\n            lyr.save()\n\n    def test_ows_api(self):\n        url = \"/api/ows_endpoints/\"\n        q = Link.objects.filter(link_type__startswith=\"OGC:\")\n        resp = self.client.get(url)\n        self.assertEqual(resp.status_code, 200)\n        content = resp.content\n        if isinstance(content, bytes):\n            content = content.decode(\"UTF-8\")\n        data = json.loads(content)\n        self.assertTrue(len(data[\"data\"]), q.count())\n\n\n@override_settings(SITEURL=\"http://localhost:8000\")\nclass TestProxyTags(GeoNodeBaseTestSupport):\n    def setUp(self):\n        self.maxDiff = None\n        self.resource = create_single_dataset(\"foo_dataset\")\n        r = RequestFactory()\n        self.url = urljoin(settings.SITEURL, reverse(\"download\", args={self.resource.id}))\n        r.get(self.url)\n        admin = get_user_model().objects.get(username=\"admin\")\n        r.user = admin\n        self.context = {\"request\": r}\n\n    def test_tag_original_link_available_with_different_netlock_should_return_true(self):\n        actual = original_link_available(self.context, self.resource.resourcebase_ptr_id, \"http://url.com/\")\n        self.assertTrue(actual)\n\n    def test_should_return_false_if_no_files_are_available(self):\n        _ = Upload.objects.create(state=\"RUNNING\", resource=self.resource)\n\n        actual = original_link_available(self.context, self.resource.resourcebase_ptr_id, self.url)\n        self.assertFalse(actual)\n\n    @patch(\"geonode.storage.manager.storage_manager.exists\", return_value=True)\n    def test_should_return_true_if_files_are_available(self, fexists):\n        upload = Upload.objects.create(state=\"RUNNING\", resource=self.resource)\n\n        assert upload\n\n        self.resource.files = [\n            \"/tmpe1exb9e9/foo_file.dbf\",\n            \"/tmpe1exb9e9/foo_file.prj\",\n            \"/tmpe1exb9e9/foo_file.shp\",\n            \"/tmpe1exb9e9/foo_file.shx\",\n        ]\n\n        self.resource.save()\n\n        self.resource.refresh_from_db()\n\n        actual = original_link_available(self.context, self.resource.resourcebase_ptr_id, self.url)\n        self.assertTrue(actual)\n", "#########################################################################\n#\n# Copyright (C) 2016 OSGeo\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program. If not, see <http://www.gnu.org/licenses/>.\n#\n#########################################################################\nimport io\nimport os\nimport re\nimport gzip\nimport logging\nimport traceback\nimport zipstream\n\nfrom hyperlink import URL\nfrom urllib.parse import urlparse, urlsplit, urljoin\n\nfrom django.conf import settings\nfrom django.template import loader\nfrom django.http import HttpResponse, StreamingHttpResponse\nfrom django.views.generic import View\nfrom distutils.version import StrictVersion\nfrom django.http.request import validate_host\nfrom django.utils.translation import ugettext as _\nfrom django.views.decorators.csrf import requires_csrf_token\n\nfrom geonode.layers.models import Dataset\nfrom geonode.upload.models import Upload\nfrom geonode.base.models import ResourceBase\nfrom geonode.storage.manager import storage_manager\nfrom geonode.utils import resolve_object, check_ogc_backend, get_headers, http_client, json_response\nfrom geonode.base.enumerations import LINK_TYPES as _LT\n\nfrom geonode import geoserver  # noqa\nfrom geonode.base import register_event\nfrom geonode.base.auth import get_auth_user, get_token_from_auth_header\n\nBUFFER_CHUNK_SIZE = 64 * 1024\n\nTIMEOUT = 30\n\nLINK_TYPES = [L for L in _LT if L.startswith(\"OGC:\")]\n\nlogger = logging.getLogger(__name__)\n\n\nows_regexp = re.compile(r\"^(?i)(version)=(\\d\\.\\d\\.\\d)(?i)&(?i)request=(?i)(GetCapabilities)&(?i)service=(?i)(\\w\\w\\w)$\")\n\n\n@requires_csrf_token\ndef proxy(\n    request,\n    url=None,\n    response_callback=None,\n    sec_chk_hosts=True,\n    sec_chk_rules=True,\n    timeout=None,\n    allowed_hosts=[],\n    headers=None,\n    access_token=None,\n    **kwargs,\n):\n    # Request default timeout\n    from geonode.geoserver.helpers import ogc_server_settings\n\n    if not timeout:\n        timeout = getattr(ogc_server_settings, \"TIMEOUT\", TIMEOUT)\n\n    # Security rules and settings\n    PROXY_ALLOWED_HOSTS = getattr(settings, \"PROXY_ALLOWED_HOSTS\", ())\n\n    # Sanity url checks\n    if \"url\" not in request.GET and not url:\n        return HttpResponse(\n            \"The proxy service requires a URL-encoded URL as a parameter.\", status=400, content_type=\"text/plain\"\n        )\n\n    raw_url = url or request.GET[\"url\"]\n    raw_url = urljoin(settings.SITEURL, raw_url) if raw_url.startswith(\"/\") else raw_url\n    url = urlsplit(raw_url)\n    scheme = str(url.scheme)\n    locator = str(url.path)\n    if url.query != \"\":\n        locator += f\"?{url.query}\"\n    if url.fragment != \"\":\n        locator += f\"#{url.fragment}\"\n\n    # White-Black Listing Hosts\n    site_url = urlsplit(settings.SITEURL)\n    if sec_chk_hosts and not settings.DEBUG:\n        # Attach current SITEURL\n        if site_url.hostname not in PROXY_ALLOWED_HOSTS:\n            PROXY_ALLOWED_HOSTS += (site_url.hostname,)\n\n        # Attach current hostname\n        hostname = (ogc_server_settings.hostname,) if ogc_server_settings else ()\n        if hostname not in PROXY_ALLOWED_HOSTS:\n            PROXY_ALLOWED_HOSTS += hostname\n\n        # Check OWS regexp\n        if url.query and ows_regexp.match(url.query):\n            ows_tokens = ows_regexp.match(url.query).groups()\n            if (\n                len(ows_tokens) == 4\n                and \"version\" == ows_tokens[0]\n                and StrictVersion(ows_tokens[1]) >= StrictVersion(\"1.0.0\")\n                and StrictVersion(ows_tokens[1]) <= StrictVersion(\"3.0.0\")\n                and ows_tokens[2].lower() in (\"getcapabilities\")\n                and ows_tokens[3].upper() in (\"OWS\", \"WCS\", \"WFS\", \"WMS\", \"WPS\", \"CSW\")\n            ):\n                if url.hostname not in PROXY_ALLOWED_HOSTS:\n                    PROXY_ALLOWED_HOSTS += (url.hostname,)\n\n        # Check Remote Services base_urls\n        from geonode.services.models import Service\n\n        for _s in Service.objects.all():\n            _remote_host = urlsplit(_s.base_url).hostname\n            PROXY_ALLOWED_HOSTS += (_remote_host,)\n\n        if not validate_host(url.hostname, PROXY_ALLOWED_HOSTS):\n            return HttpResponse(\n                \"DEBUG is set to False but the host of the path provided to the proxy service\"\n                \" is not in the PROXY_ALLOWED_HOSTS setting.\",\n                status=403,\n                content_type=\"text/plain\",\n            )\n\n    # Security checks based on rules; allow only specific requests\n    if sec_chk_rules:\n        # TODO: Not yet implemented\n        pass\n\n    # Collecting headers and cookies\n    if not headers:\n        headers, access_token = get_headers(request, url, raw_url, allowed_hosts=allowed_hosts)\n    if not access_token:\n        auth_header = None\n        if \"Authorization\" in headers:\n            auth_header = headers[\"Authorization\"]\n        elif \"HTTP_AUTHORIZATION\" in request.META:\n            auth_header = request.META.get(\"HTTP_AUTHORIZATION\", request.META.get(\"HTTP_AUTHORIZATION2\"))\n        if auth_header:\n            access_token = get_token_from_auth_header(auth_header, create_if_not_exists=True)\n    user = get_auth_user(access_token)\n\n    # Inject access_token if necessary\n    parsed = urlparse(raw_url)\n    parsed._replace(path=locator.encode(\"utf8\"))\n    if parsed.netloc == site_url.netloc and scheme != site_url.scheme:\n        parsed = parsed._replace(scheme=site_url.scheme)\n\n    _url = parsed.geturl()\n\n    # Some clients / JS libraries generate URLs with relative URL paths, e.g.\n    # \"http://host/path/path/../file.css\", which the requests library cannot\n    # currently handle (https://github.com/kennethreitz/requests/issues/2982).\n    # We parse and normalise such URLs into absolute paths before attempting\n    # to proxy the request.\n    _url = URL.from_text(_url).normalize().to_text()\n\n    if request.method == \"GET\" and access_token and \"access_token\" not in _url:\n        query_separator = \"&\" if \"?\" in _url else \"?\"\n        _url = f\"{_url}{query_separator}access_token={access_token}\"\n\n    _data = request.body.decode(\"utf-8\")\n\n    # Avoid translating local geoserver calls into external ones\n    if check_ogc_backend(geoserver.BACKEND_PACKAGE):\n        from geonode.geoserver.helpers import ogc_server_settings\n\n        _url = _url.replace(f\"{settings.SITEURL}geoserver\", ogc_server_settings.LOCATION.rstrip(\"/\"))\n        _data = _data.replace(f\"{settings.SITEURL}geoserver\", ogc_server_settings.LOCATION.rstrip(\"/\"))\n\n    response, content = http_client.request(\n        _url, method=request.method, data=_data.encode(\"utf-8\"), headers=headers, timeout=timeout, user=user\n    )\n    if response is None:\n        return HttpResponse(content=content, reason=content, status=500)\n    content = response.content or response.reason\n    status = response.status_code\n    response_headers = response.headers\n    content_type = response.headers.get(\"Content-Type\")\n\n    if status >= 400:\n        _response = HttpResponse(content=content, reason=content, status=status, content_type=content_type)\n        return fetch_response_headers(_response, response_headers)\n\n    # decompress GZipped responses if not enabled\n    # if content and response and response.getheader('Content-Encoding') == 'gzip':\n    if content and content_type and content_type == \"gzip\":\n        buf = io.BytesIO(content)\n        with gzip.GzipFile(fileobj=buf) as f:\n            content = f.read()\n        buf.close()\n\n    PLAIN_CONTENT_TYPES = [\"text\", \"plain\", \"html\", \"json\", \"xml\", \"gml\"]\n    for _ct in PLAIN_CONTENT_TYPES:\n        if content_type and _ct in content_type and not isinstance(content, str):\n            try:\n                content = content.decode()\n                break\n            except Exception:\n                pass\n\n    if response and response_callback:\n        kwargs = {} if not kwargs else kwargs\n        kwargs.update(\n            {\n                \"response\": response,\n                \"content\": content,\n                \"status\": status,\n                \"response_headers\": response_headers,\n                \"content_type\": content_type,\n            }\n        )\n        return response_callback(**kwargs)\n    else:\n        # If we get a redirect, let's add a useful message.\n        if status and status in (301, 302, 303, 307):\n            _response = HttpResponse(\n                (\n                    f\"This proxy does not support redirects. The server in '{url}' \"\n                    f\"asked for a redirect to '{response.getheader('Location')}'\"\n                ),\n                status=status,\n                content_type=content_type,\n            )\n            _response[\"Location\"] = response.getheader(\"Location\")\n            return fetch_response_headers(_response, response_headers)\n        else:\n\n            def _get_message(text):\n                _s = text\n                if isinstance(text, bytes):\n                    _s = text.decode(\"utf-8\", \"replace\")\n                try:\n                    found = re.search(\"<b>Message</b>(.+?)</p>\", _s).group(1).strip()\n                except Exception:\n                    found = _s\n                return found\n\n            _response = HttpResponse(\n                content=content,\n                reason=_get_message(content) if status not in (200, 201) else None,\n                status=status,\n                content_type=content_type,\n            )\n            return fetch_response_headers(_response, response_headers)\n\n\ndef download(request, resourceid, sender=Dataset):\n    _not_authorized = _(\"You are not authorized to download this resource.\")\n    _not_permitted = _(\"You are not permitted to save or edit this resource.\")\n    _no_files_found = _(\"No files have been found for this resource. Please, contact a system administrator.\")\n\n    instance = resolve_object(\n        request, sender, {\"pk\": resourceid}, permission=\"base.download_resourcebase\", permission_msg=_not_permitted\n    )\n\n    if isinstance(instance, ResourceBase):\n        dataset_files = []\n        file_list = []  # Store file info to be returned\n        try:\n            files = instance.resourcebase_ptr.files\n            # Copy all Dataset related files into a temporary folder\n            for file_path in files:\n                if storage_manager.exists(file_path):\n                    dataset_files.append(file_path)\n                    filename = os.path.basename(file_path)\n                    file_list.append(\n                        {\n                            \"name\": filename,\n                            \"data_iter\": storage_manager.open(file_path),\n                        }\n                    )\n                else:\n                    return HttpResponse(\n                        loader.render_to_string(\n                            \"401.html\",\n                            context={\"error_title\": _(\"No files found.\"), \"error_message\": _no_files_found},\n                            request=request,\n                        ),\n                        status=404,\n                    )\n\n            # Check we can access the original files\n            if not dataset_files:\n                return HttpResponse(\n                    loader.render_to_string(\n                        \"401.html\",\n                        context={\"error_title\": _(\"No files found.\"), \"error_message\": _no_files_found},\n                        request=request,\n                    ),\n                    status=404,\n                )\n\n            # ZIP everything and return\n            target_file_name = \"\".join([instance.name, \".zip\"])\n\n            target_zip = zipstream.ZipFile(mode=\"w\", compression=zipstream.ZIP_DEFLATED, allowZip64=True)\n\n            # Iterable: Needed when the file_info has it's data as a stream\n            def _iterable(source_iter):\n                while True:\n                    buf = source_iter.read(BUFFER_CHUNK_SIZE)\n                    if not buf:\n                        break\n                    yield buf\n\n            # Add files to zip\n            for file_info in file_list:\n                target_zip.write_iter(arcname=file_info[\"name\"], iterable=_iterable(file_info[\"data_iter\"]))\n\n            register_event(request, \"download\", instance)\n\n            # Streaming content response\n            response = StreamingHttpResponse(target_zip, content_type=\"application/zip\")\n            response[\"Content-Disposition\"] = f'attachment; filename=\"{target_file_name}\"'\n            return response\n        except (NotImplementedError, Upload.DoesNotExist):\n            traceback.print_exc()\n            tb = traceback.format_exc()\n            logger.debug(tb)\n            return HttpResponse(\n                loader.render_to_string(\n                    \"401.html\",\n                    context={\"error_title\": _(\"No files found.\"), \"error_message\": _no_files_found},\n                    request=request,\n                ),\n                status=404,\n            )\n    return HttpResponse(\n        loader.render_to_string(\n            \"401.html\", context={\"error_title\": _(\"Not Authorized\"), \"error_message\": _not_authorized}, request=request\n        ),\n        status=403,\n    )\n\n\nclass OWSListView(View):\n    def get(self, request):\n        from geonode.geoserver import ows\n\n        out = {\"success\": True}\n        data = []\n        out[\"data\"] = data\n        # WMS\n        _raw_url = ows._wms_get_capabilities()\n        _url = urlsplit(_raw_url)\n        headers, access_token = get_headers(request, _url, _raw_url)\n        if access_token:\n            _j = \"&\" if _url.query else \"?\"\n            _raw_url = _j.join([_raw_url, f\"access_token={access_token}\"])\n        data.append({\"url\": _raw_url, \"type\": \"OGC:WMS\"})\n\n        # WCS\n        _raw_url = ows._wcs_get_capabilities()\n        _url = urlsplit(_raw_url)\n        headers, access_token = get_headers(request, _url, _raw_url)\n        if access_token:\n            _j = \"&\" if _url.query else \"?\"\n            _raw_url = _j.join([_raw_url, f\"access_token={access_token}\"])\n        data.append({\"url\": _raw_url, \"type\": \"OGC:WCS\"})\n\n        # WFS\n        _raw_url = ows._wfs_get_capabilities()\n        _url = urlsplit(_raw_url)\n        headers, access_token = get_headers(request, _url, _raw_url)\n        if access_token:\n            _j = \"&\" if _url.query else \"?\"\n            _raw_url = _j.join([_raw_url, f\"access_token={access_token}\"])\n        data.append({\"url\": _raw_url, \"type\": \"OGC:WFS\"})\n\n        # catalogue from configuration\n        for catname, catconf in settings.CATALOGUE.items():\n            # CSW\n            _raw_url = catconf[\"URL\"]\n            _url = urlsplit(_raw_url)\n            headers, access_token = get_headers(request, _url, _raw_url)\n            if access_token:\n                _j = \"&\" if _url.query else \"?\"\n                _raw_url = _j.join([_raw_url, f\"access_token={access_token}\"])\n            data.append({\"url\": _raw_url, \"type\": \"OGC:CSW\"})\n\n        # main site url\n        data.append({\"url\": settings.SITEURL, \"type\": \"WWW:LINK\"})\n        return json_response(out)\n\n\n_hoppish = {\n    \"connection\",\n    \"keep-alive\",\n    \"proxy-authenticate\",\n    \"proxy-authorization\",\n    \"te\",\n    \"trailers\",\n    \"transfer-encoding\",\n    \"upgrade\",\n    \"content-length\",\n    \"content-encoding\",\n}.__contains__\n\n\ndef is_hop_by_hop(header_name):\n    \"\"\"Return true if 'header_name' is an HTTP/1.1 \"Hop-by-Hop\" header\"\"\"\n    return _hoppish(header_name.lower())\n\n\ndef fetch_response_headers(response, response_headers):\n    if response_headers:\n        for _header in response_headers:\n            if not is_hop_by_hop(_header):\n                if hasattr(response, \"headers\") and _header.lower() not in [\n                    _k.lower() for _k in response.headers.keys()\n                ]:\n                    response.headers[_header] = response_headers.get(_header)\n                elif hasattr(response, \"_headers\") and _header.lower() not in [\n                    _k.lower() for _k in response._headers.keys()\n                ]:\n                    response._headers[_header] = (_header, response_headers.get(_header))\n    return response\n", "#########################################################################\n#\n# Copyright (C) 2016 OSGeo\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program. If not, see <http://www.gnu.org/licenses/>.\n#\n#########################################################################\n\nimport os\nimport gc\nimport re\nimport json\nimport time\nimport base64\nimport ntpath\nimport select\nimport shutil\nimport string\nimport typing\nimport logging\nimport tarfile\nimport datetime\nimport requests\nimport tempfile\nimport importlib\nimport itertools\nimport traceback\nimport subprocess\n\nfrom lxml import etree\nfrom osgeo import ogr\nfrom PIL import Image\nfrom urllib3 import Retry\nfrom io import BytesIO, StringIO\nfrom decimal import Decimal\nfrom threading import local\nfrom slugify import slugify\nfrom contextlib import closing\nfrom requests.exceptions import RetryError\nfrom collections import namedtuple, defaultdict\nfrom rest_framework.exceptions import APIException\nfrom math import atan, exp, log, pi, sin, tan, floor\nfrom zipfile import ZipFile, is_zipfile, ZIP_DEFLATED\nfrom pathvalidate import ValidationError, validate_filepath, validate_filename\nfrom geonode.upload.api.exceptions import GeneralUploadException\n\nfrom django.conf import settings\nfrom django.db.models import signals\nfrom django.utils.http import is_safe_url\nfrom django.apps import apps as django_apps\nfrom django.middleware.csrf import get_token\nfrom django.http import HttpResponse\nfrom django.forms.models import model_to_dict\nfrom django.contrib.auth import get_user_model\nfrom django.shortcuts import get_object_or_404\nfrom django.core.exceptions import PermissionDenied\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.serializers.json import DjangoJSONEncoder\nfrom django.db import models, connection, transaction\nfrom django.utils.translation import ugettext_lazy as _\n\nfrom geonode import geoserver, GeoNodeException  # noqa\nfrom geonode.compat import ensure_string\nfrom geonode.layers.enumerations import GXP_PTYPES\nfrom geonode.storage.manager import storage_manager\nfrom geonode.services.serviceprocessors import get_available_service_types\nfrom geonode.base.auth import (\n    extend_token,\n    get_or_create_token,\n    get_token_from_auth_header,\n    get_token_object_from_session,\n)\n\nfrom urllib.parse import (\n    urljoin,\n    unquote,\n    urlparse,\n    urlsplit,\n    urlencode,\n    parse_qsl,\n    ParseResult,\n)\n\nMAX_EXTENT = 20037508.34\nFULL_ROTATION_DEG = 360.0\nHALF_ROTATION_DEG = 180.0\nDEFAULT_TITLE = \"\"\nDEFAULT_ABSTRACT = \"\"\n\nINVALID_PERMISSION_MESSAGE = _(\"Invalid permission level.\")\n\nALPHABET = f\"{string.ascii_uppercase + string.ascii_lowercase + string.digits}-_\"\nALPHABET_REVERSE = {c: i for (i, c) in enumerate(ALPHABET)}\nBASE = len(ALPHABET)\nSIGN_CHARACTER = \"$\"\nSQL_PARAMS_RE = re.compile(r\"%\\(([\\w_\\-]+)\\)s\")\n\nFORWARDED_HEADERS = [\"content-type\", \"content-disposition\"]\n\n# explicitly disable resolving XML entities in order to prevent malicious attacks\nXML_PARSER: typing.Final = etree.XMLParser(resolve_entities=False)\n\nrequests.packages.urllib3.disable_warnings()\n\nsignalnames = [\n    \"class_prepared\",\n    \"m2m_changed\",\n    \"post_delete\",\n    \"post_init\",\n    \"post_save\",\n    \"post_syncdb\",\n    \"pre_delete\",\n    \"pre_init\",\n    \"pre_save\",\n]\nsignals_store = {}\n\nid_none = id(None)\n\nlogger = logging.getLogger(\"geonode.utils\")\n\n\nclass ServerDoesNotExist(Exception):\n    pass\n\n\nclass OGC_Server(object):  # LGTM: @property will not work in old-style classes\n\n    \"\"\"\n    OGC Server object.\n    \"\"\"\n\n    def __init__(self, ogc_server, alias):\n        self.alias = alias\n        self.server = ogc_server\n\n    def __getattr__(self, item):\n        return self.server.get(item)\n\n    @property\n    def credentials(self):\n        \"\"\"\n        Returns a tuple of the server's credentials.\n        \"\"\"\n        creds = namedtuple(\"OGC_SERVER_CREDENTIALS\", [\"username\", \"password\"])\n        return creds(username=self.USER, password=self.PASSWORD)\n\n    @property\n    def datastore_db(self):\n        \"\"\"\n        Returns the server's datastore dict or None.\n        \"\"\"\n        if self.DATASTORE and settings.DATABASES.get(self.DATASTORE, None):\n            datastore_dict = settings.DATABASES.get(self.DATASTORE, dict())\n            return datastore_dict\n        else:\n            return dict()\n\n    @property\n    def ows(self):\n        \"\"\"\n        The Open Web Service url for the server.\n        \"\"\"\n        location = self.PUBLIC_LOCATION if self.PUBLIC_LOCATION else self.LOCATION\n        return self.OWS_LOCATION if self.OWS_LOCATION else urljoin(location, \"ows\")\n\n    @property\n    def rest(self):\n        \"\"\"\n        The REST endpoint for the server.\n        \"\"\"\n        return urljoin(self.LOCATION, \"rest\") if not self.REST_LOCATION else self.REST_LOCATION\n\n    @property\n    def public_url(self):\n        \"\"\"\n        The global public endpoint for the server.\n        \"\"\"\n        return self.LOCATION if not self.PUBLIC_LOCATION else self.PUBLIC_LOCATION\n\n    @property\n    def internal_ows(self):\n        \"\"\"\n        The Open Web Service url for the server used by GeoNode internally.\n        \"\"\"\n        location = self.LOCATION\n        return urljoin(location, \"ows\")\n\n    @property\n    def hostname(self):\n        return urlsplit(self.LOCATION).hostname\n\n    @property\n    def netloc(self):\n        return urlsplit(self.LOCATION).netloc\n\n    def __str__(self):\n        return str(self.alias)\n\n\nclass OGC_Servers_Handler:\n\n    \"\"\"\n    OGC Server Settings Convenience dict.\n    \"\"\"\n\n    def __init__(self, ogc_server_dict):\n        self.servers = ogc_server_dict\n        # FIXME(Ariel): Are there better ways to do this without involving\n        # local?\n        self._servers = local()\n\n    def ensure_valid_configuration(self, alias):\n        \"\"\"\n        Ensures the settings are valid.\n        \"\"\"\n        try:\n            server = self.servers[alias]\n        except KeyError:\n            raise ServerDoesNotExist(f\"The server {alias} doesn't exist\")\n\n        if \"PRINTNG_ENABLED\" in server:\n            raise ImproperlyConfigured(\"The PRINTNG_ENABLED setting has been removed, use 'PRINT_NG_ENABLED' instead.\")\n\n    def ensure_defaults(self, alias):\n        \"\"\"\n        Puts the defaults into the settings dictionary for a given connection where no settings is provided.\n        \"\"\"\n        try:\n            server = self.servers[alias]\n        except KeyError:\n            raise ServerDoesNotExist(f\"The server {alias} doesn't exist\")\n\n        server.setdefault(\"BACKEND\", \"geonode.geoserver\")\n        server.setdefault(\"LOCATION\", \"http://localhost:8080/geoserver/\")\n        server.setdefault(\"USER\", \"admin\")\n        server.setdefault(\"PASSWORD\", \"geoserver\")\n        server.setdefault(\"DATASTORE\", \"\")\n\n        for option in [\n            \"MAPFISH_PRINT_ENABLED\",\n            \"PRINT_NG_ENABLED\",\n            \"GEONODE_SECURITY_ENABLED\",\n            \"GEOFENCE_SECURITY_ENABLED\",\n            \"BACKEND_WRITE_ENABLED\",\n        ]:\n            server.setdefault(option, True)\n\n        for option in [\"WMST_ENABLED\", \"WPS_ENABLED\"]:\n            server.setdefault(option, False)\n\n        for option in [\"TIMEOUT\", \"GEOFENCE_TIMEOUT\"]:\n            server.setdefault(option, 60)\n\n    def __getitem__(self, alias):\n        if hasattr(self._servers, alias):\n            return getattr(self._servers, alias)\n\n        self.ensure_defaults(alias)\n        self.ensure_valid_configuration(alias)\n        server = self.servers[alias]\n        server = OGC_Server(alias=alias, ogc_server=server)\n        setattr(self._servers, alias, server)\n        return server\n\n    def __setitem__(self, key, value):\n        setattr(self._servers, key, value)\n\n    def __iter__(self):\n        return iter(self.servers)\n\n    def all(self):\n        return [self[alias] for alias in self]\n\n\ndef mkdtemp(dir=settings.MEDIA_ROOT):\n    if not os.path.exists(dir):\n        os.makedirs(dir, exist_ok=True)\n    tempdir = None\n    while not tempdir:\n        try:\n            tempdir = tempfile.mkdtemp(dir=dir)\n            if os.path.exists(tempdir) and os.path.isdir(tempdir):\n                if os.listdir(tempdir):\n                    raise Exception(\"Directory is not empty\")\n            else:\n                raise Exception(\"Directory does not exist or is not accessible\")\n        except Exception as e:\n            logger.exception(e)\n            tempdir = None\n    return tempdir\n\n\ndef unzip_file(upload_file, extension=\".shp\", tempdir=None):\n    \"\"\"\n    Unzips a zipfile into a temporary directory and returns the full path of the .shp file inside (if any)\n    \"\"\"\n    absolute_base_file = None\n    if tempdir is None:\n        tempdir = mkdtemp()\n\n    the_zip = ZipFile(upload_file, allowZip64=True)\n    the_zip.extractall(tempdir)\n    for item in the_zip.namelist():\n        if item.endswith(extension):\n            absolute_base_file = os.path.join(tempdir, item)\n\n    return absolute_base_file\n\n\ndef extract_tarfile(upload_file, extension=\".shp\", tempdir=None):\n    \"\"\"\n    Extracts a tarfile into a temporary directory and returns the full path of the .shp file inside (if any)\n    \"\"\"\n    absolute_base_file = None\n    if tempdir is None:\n        tempdir = mkdtemp()\n\n    the_tar = tarfile.open(upload_file)\n    the_tar.extractall(tempdir)\n    for item in the_tar.getnames():\n        if item.endswith(extension):\n            absolute_base_file = os.path.join(tempdir, item)\n\n    return absolute_base_file\n\n\ndef get_dataset_name(dataset):\n    \"\"\"Get the workspace where the input layer belongs\"\"\"\n    _name = dataset.name\n    if _name and \":\" in _name:\n        _name = _name.split(\":\")[1]\n    try:\n        if not _name and dataset.alternate:\n            if \":\" in dataset.alternate:\n                _name = dataset.alternate.split(\":\")[1]\n            else:\n                _name = dataset.alternate\n    except Exception:\n        pass\n    return _name\n\n\ndef get_dataset_workspace(dataset):\n    \"\"\"Get the workspace where the input layer belongs\"\"\"\n    try:\n        alternate = dataset.alternate\n    except Exception:\n        alternate = dataset.name\n    try:\n        workspace = dataset.workspace\n    except Exception:\n        workspace = None\n    if not workspace and alternate and \":\" in alternate:\n        workspace = alternate.split(\":\")[0]\n    if not workspace:\n        default_workspace = getattr(settings, \"DEFAULT_WORKSPACE\", \"geonode\")\n        try:\n            from geonode.services.enumerations import CASCADED\n\n            if dataset.remote_service.method == CASCADED:\n                workspace = getattr(settings, \"CASCADE_WORKSPACE\", default_workspace)\n            else:\n                raise RuntimeError(\"Dataset is not cascaded\")\n        except Exception:  # layer does not have a service\n            workspace = default_workspace\n    return workspace\n\n\ndef get_headers(request, url, raw_url, allowed_hosts=[]):\n    cookies = None\n    csrftoken = None\n    headers = {}\n\n    for _header_key, _header_value in dict(request.headers.copy()).items():\n        if _header_key.lower() in FORWARDED_HEADERS:\n            headers[_header_key] = _header_value\n    if settings.SESSION_COOKIE_NAME in request.COOKIES and is_safe_url(url=raw_url, allowed_hosts=url.hostname):\n        cookies = request.META[\"HTTP_COOKIE\"]\n\n    for cook in request.COOKIES:\n        name = str(cook)\n        value = request.COOKIES.get(name)\n        if name == \"csrftoken\":\n            csrftoken = value\n        cook = f\"{name}={value}\"\n        cookies = cook if not cookies else (f\"{cookies}; {cook}\")\n\n    csrftoken = get_token(request) if not csrftoken else csrftoken\n\n    if csrftoken:\n        headers[\"X-Requested-With\"] = \"XMLHttpRequest\"\n        headers[\"X-CSRFToken\"] = csrftoken\n        cook = f\"csrftoken={csrftoken}\"\n        cookies = cook if not cookies else (f\"{cookies}; {cook}\")\n\n    if cookies and request and hasattr(request, \"session\"):\n        if \"JSESSIONID\" in request.session and request.session[\"JSESSIONID\"]:\n            cookies = f\"{cookies}; JSESSIONID={request.session['JSESSIONID']}\"\n        headers[\"Cookie\"] = cookies\n\n    if request.method in (\"POST\", \"PUT\") and \"CONTENT_TYPE\" in request.META:\n        headers[\"Content-Type\"] = request.META[\"CONTENT_TYPE\"]\n\n    access_token = None\n    site_url = urlsplit(settings.SITEURL)\n    # We want to convert HTTP_AUTH into a Beraer Token only when hitting the local GeoServer\n    if site_url.hostname in (allowed_hosts + [url.hostname]):\n        # we give precedence to obtained from Aithorization headers\n        if \"HTTP_AUTHORIZATION\" in request.META:\n            auth_header = request.META.get(\"HTTP_AUTHORIZATION\", request.META.get(\"HTTP_AUTHORIZATION2\"))\n            if auth_header:\n                headers[\"Authorization\"] = auth_header\n                access_token = get_token_from_auth_header(auth_header, create_if_not_exists=True)\n        # otherwise we check if a session is active\n        elif request and request.user.is_authenticated:\n            access_token = get_token_object_from_session(request.session)\n\n            # we extend the token in case the session is active but the token expired\n            if access_token and access_token.is_expired():\n                extend_token(access_token)\n            else:\n                access_token = get_or_create_token(request.user)\n\n    if access_token:\n        headers[\"Authorization\"] = f\"Bearer {access_token}\"\n\n    pragma = \"no-cache\"\n    referer = (\n        request.META[\"HTTP_REFERER\"] if \"HTTP_REFERER\" in request.META else f\"{site_url.scheme}://{site_url.netloc}/\"\n    )\n    encoding = request.META[\"HTTP_ACCEPT_ENCODING\"] if \"HTTP_ACCEPT_ENCODING\" in request.META else \"gzip\"\n    headers.update(\n        {\n            \"Pragma\": pragma,\n            \"Referer\": referer,\n            \"Accept-encoding\": encoding,\n        }\n    )\n\n    return (headers, access_token)\n\n\ndef _get_basic_auth_info(request):\n    \"\"\"\n    grab basic auth info\n    \"\"\"\n    meth, auth = request.META[\"HTTP_AUTHORIZATION\"].split()\n    if meth.lower() != \"basic\":\n        raise ValueError\n    username, password = base64.b64decode(auth.encode()).decode().split(\":\")\n    return username, password\n\n\ndef batch_delete(request):\n    # TODO\n    pass\n\n\ndef _split_query(query):\n    \"\"\"\n    split and strip keywords, preserve space\n    separated quoted blocks.\n    \"\"\"\n\n    qq = query.split(\" \")\n    keywords = []\n    accum = None\n    for kw in qq:\n        if accum is None:\n            if kw.startswith('\"'):\n                accum = kw[1:]\n            elif kw:\n                keywords.append(kw)\n        else:\n            accum += f\" {kw}\"\n            if kw.endswith('\"'):\n                keywords.append(accum[0:-1])\n                accum = None\n    if accum is not None:\n        keywords.append(accum)\n    return [kw.strip() for kw in keywords if kw.strip()]\n\n\ndef bbox_to_wkt(x0, x1, y0, y1, srid=\"4326\", include_srid=True):\n    if srid and str(srid).startswith(\"EPSG:\"):\n        srid = srid[5:]\n    if None not in {x0, x1, y0, y1}:\n        polys = []\n\n        # We assume that if x1 is smaller then x0 we're crossing the date line\n        crossing_idl = x1 < x0\n        if crossing_idl:\n            polys.append(\n                [\n                    (float(x0), float(y0)),\n                    (float(x0), float(y1)),\n                    (180.0, float(y1)),\n                    (180.0, float(y0)),\n                    (float(x0), float(y0)),\n                ]\n            )\n            polys.append(\n                [\n                    (-180.0, float(y0)),\n                    (-180.0, float(y1)),\n                    (float(x1), float(y1)),\n                    (float(x1), float(y0)),\n                    (-180.0, float(y0)),\n                ]\n            )\n        else:\n            polys.append(\n                [\n                    (float(x0), float(y0)),\n                    (float(x0), float(y1)),\n                    (float(x1), float(y1)),\n                    (float(x1), float(y0)),\n                    (float(x0), float(y0)),\n                ]\n            )\n\n        poly_wkts = \",\".join(\n            [\"(({}))\".format(\",\".join([\"{:f} {:f}\".format(coords[0], coords[1]) for coords in poly])) for poly in polys]\n        )\n        wkt = f\"MULTIPOLYGON({poly_wkts})\" if len(polys) > 1 else f\"POLYGON{poly_wkts}\"\n        if include_srid:\n            wkt = f\"SRID={srid};{wkt}\"\n    else:\n        wkt = \"POLYGON((-180 -90,-180 90,180 90,180 -90,-180 -90))\"\n        if include_srid:\n            wkt = f\"SRID=4326;{wkt}\"\n    return wkt\n\n\ndef _v(coord, x, source_srid=4326, target_srid=3857):\n    if source_srid == 4326 and x and abs(coord) != HALF_ROTATION_DEG:\n        coord -= round(coord / FULL_ROTATION_DEG) * FULL_ROTATION_DEG\n    if source_srid == 4326 and target_srid != 4326:\n        if x and float(coord) >= 179.999:\n            return 179.999\n        elif x and float(coord) <= -179.999:\n            return -179.999\n\n        if not x and float(coord) >= 89.999:\n            return 89.999\n        elif not x and float(coord) <= -89.999:\n            return -89.999\n    return coord\n\n\ndef bbox_to_projection(native_bbox, target_srid=4326):\n    \"\"\"\n    native_bbox must be in the form\n        ('-81.3962935', '-81.3490249', '13.3202891', '13.3859614', 'EPSG:4326')\n    \"\"\"\n    box = native_bbox[:4]\n    proj = native_bbox[-1]\n    minx, maxx, miny, maxy = [float(a) for a in box]\n    try:\n        source_srid = int(proj.split(\":\")[1]) if proj and \":\" in proj else int(proj)\n    except Exception:\n        source_srid = target_srid\n\n    if source_srid != target_srid:\n        wkt = bbox_to_wkt(\n            _v(minx, x=True, source_srid=source_srid, target_srid=target_srid),\n            _v(maxx, x=True, source_srid=source_srid, target_srid=target_srid),\n            _v(miny, x=False, source_srid=source_srid, target_srid=target_srid),\n            _v(maxy, x=False, source_srid=source_srid, target_srid=target_srid),\n            srid=source_srid,\n            include_srid=False,\n        )\n        # AF: This causses error with GDAL 3.0.4 due to a breaking change on GDAL\n        #     https://code.djangoproject.com/ticket/30645\n        import osgeo.gdal\n\n        _gdal_ver = osgeo.gdal.__version__.split(\".\", 2)\n        from osgeo import ogr\n        from osgeo.osr import SpatialReference, CoordinateTransformation\n\n        g = ogr.Geometry(wkt=wkt)\n        source = SpatialReference()\n        source.ImportFromEPSG(source_srid)\n        dest = SpatialReference()\n        dest.ImportFromEPSG(target_srid)\n        if int(_gdal_ver[0]) >= 3 and ((int(_gdal_ver[1]) == 0 and int(_gdal_ver[2]) >= 4) or int(_gdal_ver[1]) > 0):\n            source.SetAxisMappingStrategy(0)\n            dest.SetAxisMappingStrategy(0)\n        g.Transform(CoordinateTransformation(source, dest))\n        projected_bbox = [str(x) for x in g.GetEnvelope()]\n        # Must be in the form : [x0, x1, y0, y1, EPSG:<target_srid>)\n        return tuple(\n            [float(projected_bbox[0]), float(projected_bbox[1]), float(projected_bbox[2]), float(projected_bbox[3])]\n        ) + (f\"EPSG:{target_srid}\",)\n\n    return native_bbox\n\n\ndef bounds_to_zoom_level(bounds, width, height):\n    WORLD_DIM = {\"height\": 256.0, \"width\": 256.0}\n    ZOOM_MAX = 21\n\n    def latRad(lat):\n        _sin = sin(lat * pi / HALF_ROTATION_DEG)\n        if abs(_sin) != 1.0:\n            radX2 = log((1.0 + _sin) / (1.0 - _sin)) / 2.0\n        else:\n            radX2 = log(1.0) / 2.0\n        return max(min(radX2, pi), -pi) / 2.0\n\n    def zoom(mapPx, worldPx, fraction):\n        try:\n            return floor(log(mapPx / worldPx / fraction) / log(2.0))\n        except Exception:\n            return 0\n\n    ne = [float(bounds[2]), float(bounds[3])]\n    sw = [float(bounds[0]), float(bounds[1])]\n    latFraction = (latRad(ne[1]) - latRad(sw[1])) / pi\n    lngDiff = ne[0] - sw[0]\n    lngFraction = ((lngDiff + FULL_ROTATION_DEG) if lngDiff < 0 else lngDiff) / FULL_ROTATION_DEG\n    latZoom = zoom(float(height), WORLD_DIM[\"height\"], latFraction)\n    lngZoom = zoom(float(width), WORLD_DIM[\"width\"], lngFraction)\n    # ratio = float(max(width, height)) / float(min(width, height))\n    # z_offset = 0 if ratio >= 2 else -1\n    z_offset = 0\n    zoom = int(max(latZoom, lngZoom) + z_offset)\n    zoom = 0 if zoom > ZOOM_MAX else zoom\n    return max(zoom, 0)\n\n\ndef llbbox_to_mercator(llbbox):\n    minlonlat = forward_mercator([llbbox[0], llbbox[2]])\n    maxlonlat = forward_mercator([llbbox[1], llbbox[3]])\n    return [minlonlat[0], minlonlat[1], maxlonlat[0], maxlonlat[1]]\n\n\ndef mercator_to_llbbox(bbox):\n    minlonlat = inverse_mercator([bbox[0], bbox[2]])\n    maxlonlat = inverse_mercator([bbox[1], bbox[3]])\n    return [minlonlat[0], minlonlat[1], maxlonlat[0], maxlonlat[1]]\n\n\ndef forward_mercator(lonlat):\n    \"\"\"\n    Given geographic coordinates, return a x,y tuple in spherical mercator.\n\n    If the lat value is out of range, -inf will be returned as the y value\n    \"\"\"\n    x = lonlat[0] * MAX_EXTENT / HALF_ROTATION_DEG\n    try:\n        # With data sets that only have one point the value of this\n        # expression becomes negative infinity. In order to continue,\n        # we wrap this in a try catch block.\n        n = tan((90 + lonlat[1]) * pi / FULL_ROTATION_DEG)\n    except ValueError:\n        n = 0\n    if n <= 0:\n        y = float(\"-inf\")\n    else:\n        y = log(n) / pi * MAX_EXTENT\n    return (x, y)\n\n\ndef inverse_mercator(xy):\n    \"\"\"\n    Given coordinates in spherical mercator, return a lon,lat tuple.\n    \"\"\"\n    lon = (xy[0] / MAX_EXTENT) * HALF_ROTATION_DEG\n    lat = (xy[1] / MAX_EXTENT) * HALF_ROTATION_DEG\n    lat = HALF_ROTATION_DEG / pi * (2 * atan(exp(lat * pi / HALF_ROTATION_DEG)) - pi / 2)\n    return (lon, lat)\n\n\ndef resolve_object(\n    request, model, query, permission=\"base.view_resourcebase\", user=None, permission_required=True, permission_msg=None\n):\n    \"\"\"Resolve an object using the provided query and check the optional\n    permission. Model views should wrap this function as a shortcut.\n\n    query - a dict to use for querying the model\n    permission - an optional permission to check\n    permission_required - if False, allow get methods to proceed\n    permission_msg - optional message to use in 403\n    \"\"\"\n    user = request.user if request and request.user else user\n    obj = get_object_or_404(model, **query)\n    obj_to_check = obj.get_self_resource()\n\n    from guardian.shortcuts import get_groups_with_perms\n    from geonode.groups.models import GroupProfile\n\n    groups = get_groups_with_perms(obj_to_check, attach_perms=True)\n\n    if obj_to_check.group and obj_to_check.group not in groups:\n        groups[obj_to_check.group] = obj_to_check.group\n\n    obj_group_managers = []\n    obj_group_members = []\n    if groups:\n        for group in groups:\n            try:\n                group_profile = GroupProfile.objects.get(slug=group.name)\n                managers = group_profile.get_managers()\n                if managers:\n                    for manager in managers:\n                        if manager not in obj_group_managers and not manager.is_superuser:\n                            obj_group_managers.append(manager)\n                if group_profile.user_is_member(user) and user not in obj_group_members:\n                    obj_group_members.append(user)\n            except GroupProfile.DoesNotExist:\n                pass\n\n    allowed = True\n    if permission.split(\".\")[-1] in [\"change_dataset_data\", \"change_dataset_style\"]:\n        if obj.__class__.__name__ == \"Dataset\":\n            obj_to_check = obj\n    if permission:\n        if permission_required or request.method != \"GET\":\n            if user in obj_group_managers:\n                allowed = True\n            else:\n                allowed = user.has_perm(permission, obj_to_check)\n    if not allowed:\n        mesg = permission_msg or _(\"Permission Denied\")\n        raise PermissionDenied(mesg)\n    return obj\n\n\ndef json_response(body=None, errors=None, url=None, redirect_to=None, exception=None, content_type=None, status=None):\n    \"\"\"Create a proper JSON response. If body is provided, this is the response.\n    If errors is not None, the response is a success/errors json object.\n    If redirect_to is not None, the response is a success=True, redirect_to object\n    If the exception is provided, it will be logged. If body is a string, the\n    exception message will be used as a format option to that string and the\n    result will be a success=False, errors = body % exception\n    \"\"\"\n    if isinstance(body, HttpResponse):\n        return body\n    if content_type is None:\n        content_type = \"application/json\"\n    if errors:\n        if isinstance(errors, str):\n            errors = [errors]\n        body = {\"success\": False, \"errors\": errors}\n    elif redirect_to:\n        body = {\"success\": True, \"redirect_to\": redirect_to}\n    elif url:\n        body = {\"success\": True, \"url\": url}\n    elif exception:\n        if isinstance(exception, APIException):\n            raise exception\n        if body is None:\n            body = f\"Unexpected exception {exception}\"\n        else:\n            body = body % exception\n        body = {\"success\": False, \"errors\": [body]}\n        raise GeneralUploadException(detail=body)\n    elif body:\n        pass\n    else:\n        raise Exception(\"must call with body, errors or redirect_to\")\n\n    if status is None:\n        status = 200\n\n    if not isinstance(body, str):\n        try:\n            body = json.dumps(body, cls=DjangoJSONEncoder)\n        except Exception:\n            body = str(body)\n    return HttpResponse(body, content_type=content_type, status=status)\n\n\ndef num_encode(n):\n    if n < 0:\n        return SIGN_CHARACTER + num_encode(-n)\n    s = []\n    while True:\n        n, r = divmod(n, BASE)\n        s.append(ALPHABET[r])\n        if n == 0:\n            break\n    return \"\".join(reversed(s))\n\n\ndef num_decode(s):\n    if s[0] == SIGN_CHARACTER:\n        return -num_decode(s[1:])\n    n = 0\n    for c in s:\n        n = n * BASE + ALPHABET_REVERSE[c]\n    return n\n\n\ndef format_urls(a, values):\n    b = []\n    for i in a:\n        j = i.copy()\n        try:\n            j[\"url\"] = str(j[\"url\"]).format(**values)\n        except KeyError:\n            j[\"url\"] = None\n        b.append(j)\n    return b\n\n\ndef build_abstract(resourcebase, url=None, includeURL=True):\n    if resourcebase.abstract and url and includeURL:\n        return f\"{resourcebase.abstract} -- [{url}]({url})\"\n    else:\n        return resourcebase.abstract\n\n\ndef build_caveats(resourcebase):\n    caveats = []\n    if resourcebase.maintenance_frequency:\n        caveats.append(resourcebase.maintenance_frequency_title())\n    if resourcebase.license:\n        caveats.append(resourcebase.license_verbose)\n    if resourcebase.data_quality_statement:\n        caveats.append(resourcebase.data_quality_statement)\n    if len(caveats) > 0:\n        return f\"- {'%0A- '.join(caveats)}\"\n    else:\n        return \"\"\n\n\ndef build_social_links(request, resourcebase):\n    netschema = \"https\" if request.is_secure() else \"http\"\n    host = request.get_host()\n    path = request.get_full_path()\n    social_url = f\"{netschema}://{host}{path}\"\n    # Don't use datetime strftime() because it requires year >= 1900\n    # see\n    # https://docs.python.org/2/library/datetime.html#strftime-strptime-behavior\n    date = \"{0.month:02d}/{0.day:02d}/{0.year:4d}\".format(resourcebase.date) if resourcebase.date else None\n    abstract = build_abstract(resourcebase, url=social_url, includeURL=True)\n    caveats = build_caveats(resourcebase)\n    hashtags = \",\".join(getattr(settings, \"TWITTER_HASHTAGS\", []))\n    return format_urls(\n        settings.SOCIAL_ORIGINS,\n        {\n            \"name\": resourcebase.title,\n            \"date\": date,\n            \"abstract\": abstract,\n            \"caveats\": caveats,\n            \"hashtags\": hashtags,\n            \"url\": social_url,\n        },\n    )\n\n\ndef check_shp_columnnames(layer):\n    \"\"\"Check if shapefile for a given layer has valid column names.\n    If not, try to fix column names and warn the user\n    \"\"\"\n    # TODO we may add in a better location this method\n    inShapefile = \"\"\n    for f in layer.upload_session.layerfile_set.all():\n        if os.path.splitext(f.file.name)[1] == \".shp\":\n            inShapefile = f.file.path\n    if inShapefile:\n        return fixup_shp_columnnames(inShapefile, layer.charset)\n\n\ndef clone_shp_field_defn(srcFieldDefn, name):\n    \"\"\"\n    Clone an existing ogr.FieldDefn with a new name\n    \"\"\"\n    dstFieldDefn = ogr.FieldDefn(name, srcFieldDefn.GetType())\n    dstFieldDefn.SetWidth(srcFieldDefn.GetWidth())\n    dstFieldDefn.SetPrecision(srcFieldDefn.GetPrecision())\n\n    return dstFieldDefn\n\n\ndef rename_shp_columnnames(inLayer, fieldnames):\n    \"\"\"\n    Rename columns in a layer to those specified in the given mapping\n    \"\"\"\n    inLayerDefn = inLayer.GetLayerDefn()\n\n    for i in range(inLayerDefn.GetFieldCount()):\n        srcFieldDefn = inLayerDefn.GetFieldDefn(i)\n        dstFieldName = fieldnames.get(srcFieldDefn.GetName())\n\n        if dstFieldName is not None:\n            dstFieldDefn = clone_shp_field_defn(srcFieldDefn, dstFieldName)\n            inLayer.AlterFieldDefn(i, dstFieldDefn, ogr.ALTER_NAME_FLAG)\n\n\ndef fixup_shp_columnnames(inShapefile, charset, tempdir=None):\n    \"\"\"Try to fix column names and warn the user\"\"\"\n    charset = charset if charset and \"undefined\" not in charset else \"UTF-8\"\n    if not tempdir:\n        tempdir = mkdtemp()\n\n    if is_zipfile(inShapefile):\n        inShapefile = unzip_file(inShapefile, \".shp\", tempdir=tempdir)\n\n    inDriver = ogr.GetDriverByName(\"ESRI Shapefile\")\n    try:\n        inDataSource = inDriver.Open(inShapefile, 1)\n    except Exception:\n        tb = traceback.format_exc()\n        logger.debug(tb)\n        inDataSource = None\n\n    if inDataSource is None:\n        logger.debug(f\"Could not open {inShapefile}\")\n        return False, None, None\n    else:\n        inLayer = inDataSource.GetLayer()\n\n    # TODO we may need to improve this regexp\n    # first character must be any letter or \"_\"\n    # following characters can be any letter, number, \"#\", \":\"\n    regex = r\"^[a-zA-Z,_][a-zA-Z,_#:\\d]*$\"\n    a = re.compile(regex)\n    regex_first_char = r\"[a-zA-Z,_]{1}\"\n    b = re.compile(regex_first_char)\n    inLayerDefn = inLayer.GetLayerDefn()\n\n    list_col_original = []\n    list_col = {}\n\n    for i in range(inLayerDefn.GetFieldCount()):\n        try:\n            field_name = inLayerDefn.GetFieldDefn(i).GetName()\n            if a.match(field_name):\n                list_col_original.append(field_name)\n        except Exception as e:\n            logger.exception(e)\n            return True, None, None\n\n    for i in range(inLayerDefn.GetFieldCount()):\n        try:\n            field_name = inLayerDefn.GetFieldDefn(i).GetName()\n            if not a.match(field_name):\n                # once the field_name contains Chinese, to use slugify_zh\n                if any(\"\\u4e00\" <= ch <= \"\\u9fff\" for ch in field_name):\n                    new_field_name = slugify_zh(field_name, separator=\"_\")\n                else:\n                    new_field_name = slugify(field_name)\n                if not b.match(new_field_name):\n                    new_field_name = f\"_{new_field_name}\"\n                j = 0\n                while new_field_name in list_col_original or new_field_name in list_col.values():\n                    if j == 0:\n                        new_field_name += \"_0\"\n                    if new_field_name.endswith(f\"_{str(j)}\"):\n                        j += 1\n                        new_field_name = f\"{new_field_name[:-2]}_{str(j)}\"\n                if field_name != new_field_name:\n                    list_col[field_name] = new_field_name\n        except Exception as e:\n            logger.exception(e)\n            return True, None, None\n\n    if len(list_col) == 0:\n        return True, None, None\n    else:\n        try:\n            rename_shp_columnnames(inLayer, list_col)\n            inDataSource.SyncToDisk()\n            inDataSource.Destroy()\n        except Exception as e:\n            logger.exception(e)\n            raise GeoNodeException(f\"Could not decode SHAPEFILE attributes by using the specified charset '{charset}'.\")\n    return True, None, list_col\n\n\ndef id_to_obj(id_):\n    if id_ == id_none:\n        return None\n\n    for obj in gc.get_objects():\n        if id(obj) == id_:\n            return obj\n    raise Exception(\"Not found\")\n\n\ndef printsignals():\n    for signalname in signalnames:\n        logger.debug(f\"SIGNALNAME: {signalname}\")\n        signaltype = getattr(models.signals, signalname)\n        signals = signaltype.receivers[:]\n        for signal in signals:\n            logger.debug(signal)\n\n\nclass DisableDjangoSignals:\n    \"\"\"\n    Python3 class temporarily disabling django signals on model creation.\n\n    usage:\n    with DisableDjangoSignals():\n        # do some fancy stuff here\n    \"\"\"\n\n    def __init__(self, disabled_signals=None, skip=False):\n        self.skip = skip\n        self.stashed_signals = defaultdict(list)\n        self.disabled_signals = disabled_signals or [\n            signals.pre_init,\n            signals.post_init,\n            signals.pre_save,\n            signals.post_save,\n            signals.pre_delete,\n            signals.post_delete,\n            signals.pre_migrate,\n            signals.post_migrate,\n            signals.m2m_changed,\n        ]\n\n    def __enter__(self):\n        if not self.skip:\n            for signal in self.disabled_signals:\n                self.disconnect(signal)\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if not self.skip:\n            for signal in list(self.stashed_signals):\n                self.reconnect(signal)\n\n    def disconnect(self, signal):\n        self.stashed_signals[signal] = signal.receivers\n        signal.receivers = []\n\n    def reconnect(self, signal):\n        signal.receivers = self.stashed_signals.get(signal, [])\n        del self.stashed_signals[signal]\n\n\ndef run_subprocess(*cmd, **kwargs):\n    p = subprocess.Popen(\" \".join(cmd), stdout=subprocess.PIPE, stderr=subprocess.PIPE, **kwargs)\n    stdout = StringIO()\n    stderr = StringIO()\n    buff_size = 1024\n    while p.poll() is None:\n        inr = [p.stdout.fileno(), p.stderr.fileno()]\n        inw = []\n        rlist, wlist, xlist = select.select(inr, inw, [])\n\n        for r in rlist:\n            if r == p.stdout.fileno():\n                readfrom = p.stdout\n                readto = stdout\n            else:\n                readfrom = p.stderr\n                readto = stderr\n            readto.write(readfrom.read(buff_size))\n\n        for w in wlist:\n            w.write(\"\")\n\n    return p.returncode, stdout.getvalue(), stderr.getvalue()\n\n\ndef parse_datetime(value):\n    for patt in settings.DATETIME_INPUT_FORMATS:\n        try:\n            if isinstance(value, dict):\n                value_obj = value[\"$\"] if \"$\" in value else value[\"content\"]\n                return datetime.datetime.strptime(value_obj, patt)\n            else:\n                return datetime.datetime.strptime(value, patt)\n        except Exception:\n            tb = traceback.format_exc()\n            logger.debug(tb)\n    raise ValueError(f\"Invalid datetime input: {value}\")\n\n\ndef _convert_sql_params(cur, query):\n    # sqlite driver doesn't support %(key)s notation,\n    # use :key instead.\n    if cur.db.vendor in (\n        \"sqlite\",\n        \"sqlite3\",\n        \"spatialite\",\n    ):\n        return SQL_PARAMS_RE.sub(r\":\\1\", query)\n    return query\n\n\n@transaction.atomic\ndef raw_sql(query, params=None, ret=True):\n    \"\"\"\n    Execute raw query\n    param ret=True returns data from cursor as iterator\n    \"\"\"\n    with connection.cursor() as c:\n        query = _convert_sql_params(c, query)\n        c.execute(query, params)\n        if ret:\n            desc = [r[0] for r in c.description]\n            for row in c:\n                yield dict(zip(desc, row))\n\n\ndef get_client_ip(request):\n    x_forwarded_for = request.META.get(\"HTTP_X_FORWARDED_FOR\")\n    if x_forwarded_for:\n        ip = x_forwarded_for.split(\",\")[0]\n    else:\n        ip = request.META.get(\"REMOTE_ADDR\")\n    return ip\n\n\ndef get_client_host(request):\n    hostname = None\n    http_host = request.META.get(\"HTTP_HOST\")\n    if http_host:\n        hostname = http_host.split(\":\")[0]\n    return hostname\n\n\ndef check_ogc_backend(backend_package):\n    \"\"\"Check that geonode use a particular OGC Backend integration\n\n    :param backend_package: django app of backend to use\n    :type backend_package: str\n\n    :return: bool\n    :rtype: bool\n    \"\"\"\n    ogc_conf = settings.OGC_SERVER[\"default\"]\n    is_configured = ogc_conf.get(\"BACKEND\") == backend_package\n\n    # Check environment variables\n    _backend = os.environ.get(\"BACKEND\", None)\n    if _backend:\n        return backend_package == _backend and is_configured\n\n    # Check exists in INSTALLED_APPS\n    try:\n        in_installed_apps = backend_package in settings.INSTALLED_APPS\n        return in_installed_apps and is_configured\n    except Exception:\n        pass\n    return False\n\n\nclass HttpClient:\n    def __init__(self):\n        self.timeout = 5\n        self.retries = 1\n        self.pool_maxsize = 10\n        self.backoff_factor = 0.3\n        self.pool_connections = 10\n        self.status_forcelist = (500, 502, 503, 504)\n        self.username = \"admin\"\n        self.password = \"admin\"\n        if check_ogc_backend(geoserver.BACKEND_PACKAGE):\n            ogc_server_settings = settings.OGC_SERVER[\"default\"]\n            self.timeout = ogc_server_settings.get(\"TIMEOUT\", 5)\n            self.retries = ogc_server_settings.get(\"MAX_RETRIES\", 1)\n            self.backoff_factor = ogc_server_settings.get(\"BACKOFF_FACTOR\", 0.3)\n            self.pool_maxsize = ogc_server_settings.get(\"POOL_MAXSIZE\", 10)\n            self.pool_connections = ogc_server_settings.get(\"POOL_CONNECTIONS\", 10)\n            self.username = ogc_server_settings.get(\"USER\", \"admin\")\n            self.password = ogc_server_settings.get(\"PASSWORD\", \"geoserver\")\n\n    def request(\n        self,\n        url,\n        method=\"GET\",\n        data=None,\n        headers={},\n        stream=False,\n        timeout=None,\n        retries=None,\n        user=None,\n        verify=False,\n    ):\n        if (\n            (user or self.username != \"admin\")\n            and check_ogc_backend(geoserver.BACKEND_PACKAGE)\n            and \"Authorization\" not in headers\n        ):\n            if connection.cursor().db.vendor not in (\"sqlite\", \"sqlite3\", \"spatialite\"):\n                try:\n                    if user and isinstance(user, str):\n                        user = get_user_model().objects.get(username=user)\n                    _u = user or get_user_model().objects.get(username=self.username)\n                    access_token = get_or_create_token(_u)\n                    if access_token and not access_token.is_expired():\n                        headers[\"Authorization\"] = f\"Bearer {access_token.token}\"\n                except Exception:\n                    tb = traceback.format_exc()\n                    logger.debug(tb)\n            elif user == self.username:\n                valid_uname_pw = base64.b64encode(f\"{self.username}:{self.password}\".encode()).decode()\n                headers[\"Authorization\"] = f\"Basic {valid_uname_pw}\"\n\n        headers[\"User-Agent\"] = \"GeoNode\"\n        response = None\n        content = None\n        session = requests.Session()\n        retry = Retry(\n            total=retries or self.retries,\n            read=retries or self.retries,\n            connect=retries or self.retries,\n            backoff_factor=self.backoff_factor,\n            status_forcelist=self.status_forcelist,\n        )\n        adapter = requests.adapters.HTTPAdapter(\n            max_retries=retry, pool_maxsize=self.pool_maxsize, pool_connections=self.pool_connections\n        )\n        scheme = urlsplit(url).scheme\n        session.mount(f\"{scheme}://\", adapter)\n        session.verify = False\n        action = getattr(session, method.lower(), None)\n        if action:\n            _req_tout = timeout or self.timeout\n            try:\n                response = action(url=url, data=data, headers=headers, timeout=_req_tout, stream=stream, verify=verify)\n            except (\n                requests.exceptions.ConnectTimeout,\n                requests.exceptions.RequestException,\n                ValueError,\n                RetryError,\n            ) as e:\n                msg = f\"Request exception [{e}] - TOUT [{_req_tout}] to URL: {url} - headers: {headers}\"\n                logger.exception(Exception(msg))\n                response = None\n                content = str(e)\n        else:\n            response = session.get(url, headers=headers, timeout=self.timeout)\n        if response:\n            try:\n                content = ensure_string(response.content) if not stream else response.raw\n            except Exception as e:\n                content = str(e)\n\n        return (response, content)\n\n    def get(self, url, data=None, headers={}, stream=False, timeout=None, user=None, verify=False):\n        return self.request(\n            url,\n            method=\"GET\",\n            data=data,\n            headers=headers,\n            timeout=timeout or self.timeout,\n            stream=stream,\n            user=user,\n            verify=verify,\n        )\n\n    def post(self, url, data=None, headers={}, stream=False, timeout=None, user=None, verify=False):\n        return self.request(\n            url,\n            method=\"POST\",\n            data=data,\n            headers=headers,\n            timeout=timeout or self.timeout,\n            stream=stream,\n            user=user,\n            verify=verify,\n        )\n\n\nhttp_client = HttpClient()\n\n\ndef get_dir_time_suffix():\n    \"\"\"Returns the name of a folder with the 'now' time as suffix\"\"\"\n    dirfmt = \"%4d-%02d-%02d_%02d%02d%02d\"\n    now = time.localtime()[0:6]\n    dirname = dirfmt % now\n\n    return dirname\n\n\ndef zip_dir(basedir, archivename):\n    assert os.path.isdir(basedir)\n    with closing(ZipFile(archivename, \"w\", ZIP_DEFLATED, allowZip64=True)) as z:\n        for root, dirs, files in os.walk(basedir):\n            # NOTE: ignore empty directories\n            for fn in files:\n                absfn = os.path.join(root, fn)\n                zfn = absfn[len(basedir) + len(os.sep) :]  # XXX: relative path\n                z.write(absfn, zfn)\n\n\ndef copy_tree(src, dst, symlinks=False, ignore=None):\n    try:\n        for item in os.listdir(src):\n            s = os.path.join(src, item)\n            d = os.path.join(dst, item)\n            if os.path.isdir(s):\n                if os.path.exists(d):\n                    try:\n                        os.remove(d)\n                    except Exception:\n                        shutil.rmtree(d, ignore_errors=True)\n                try:\n                    shutil.copytree(s, d, symlinks=symlinks, ignore=ignore)\n                except Exception:\n                    pass\n            else:\n                try:\n                    if ignore and s in ignore(dst, [s]):\n                        return\n                    shutil.copy2(s, d)\n                except Exception:\n                    pass\n    except Exception:\n        traceback.print_exc()\n\n\ndef extract_archive(zip_file, dst):\n    target_folder = os.path.join(dst, os.path.splitext(os.path.basename(zip_file))[0])\n    if not os.path.exists(target_folder):\n        os.makedirs(target_folder, exist_ok=True)\n\n    with ZipFile(zip_file, \"r\", allowZip64=True) as z:\n        z.extractall(target_folder)\n\n    return target_folder\n\n\ndef chmod_tree(dst, permissions=0o777):\n    for dirpath, dirnames, filenames in os.walk(dst):\n        for filename in filenames:\n            path = os.path.join(dirpath, filename)\n            os.chmod(path, permissions)\n            status = os.stat(path)\n            if oct(status.st_mode & 0o777) != str(oct(permissions)):\n                raise Exception(f\"Could not update permissions of {path}\")\n\n        for dirname in dirnames:\n            path = os.path.join(dirpath, dirname)\n            os.chmod(path, permissions)\n            status = os.stat(path)\n            if oct(status.st_mode & 0o777) != str(oct(permissions)):\n                raise Exception(f\"Could not update permissions of {path}\")\n\n\ndef slugify_zh(text, separator=\"_\"):\n    \"\"\"\n    Make a slug from the given text, which is simplified from slugify.\n    It remove the other args and do not convert Chinese into Pinyin\n    :param text (str): initial text\n    :param separator (str): separator between words\n    :return (str):\n    \"\"\"\n\n    QUOTE_PATTERN = re.compile(r\"[\\']+\")\n    ALLOWED_CHARS_PATTERN = re.compile(\"[^\\u4e00-\\u9fa5a-z0-9]+\")\n    DUPLICATE_DASH_PATTERN = re.compile(\"-{2,}\")\n    NUMBERS_PATTERN = re.compile(r\"(?<=\\d),(?=\\d)\")\n    DEFAULT_SEPARATOR = \"-\"\n\n    # if not isinstance(text, types.UnicodeType):\n    #    text = unicode(text, 'utf-8', 'ignore')\n    # replace quotes with dashes - pre-process\n    text = QUOTE_PATTERN.sub(DEFAULT_SEPARATOR, text)\n    # make the text lowercase\n    text = text.lower()\n    # remove generated quotes -- post-process\n    text = QUOTE_PATTERN.sub(\"\", text)\n    # cleanup numbers\n    text = NUMBERS_PATTERN.sub(\"\", text)\n    # replace all other unwanted characters\n    text = re.sub(ALLOWED_CHARS_PATTERN, DEFAULT_SEPARATOR, text)\n    # remove redundant\n    text = re.sub(DUPLICATE_DASH_PATTERN, DEFAULT_SEPARATOR, text).strip(DEFAULT_SEPARATOR)\n    if separator != DEFAULT_SEPARATOR:\n        text = text.replace(DEFAULT_SEPARATOR, separator)\n    return text\n\n\ndef get_legend_url(\n    instance,\n    style_name,\n    /,\n    service_url=None,\n    dataset_name=None,\n    version=\"1.3.0\",\n    sld_version=\"1.1.0\",\n    width=20,\n    height=20,\n    params=None,\n):\n    from geonode.geoserver.helpers import ogc_server_settings\n\n    _service_url = service_url or f\"{ogc_server_settings.PUBLIC_LOCATION}ows\"\n    _dataset_name = dataset_name or instance.alternate\n    _params = f\"&{params}\" if params else \"\"\n    return (\n        f\"{_service_url}?\"\n        f\"service=WMS&request=GetLegendGraphic&format=image/png&WIDTH={width}&HEIGHT={height}&\"\n        f\"LAYER={_dataset_name}&STYLE={style_name}&version={version}&\"\n        f\"sld_version={sld_version}&legend_options=fontAntiAliasing:true;fontSize:12;forceLabels:on{_params}\"\n    )\n\n\ndef set_resource_default_links(instance, layer, prune=False, **kwargs):\n    from geonode.base.models import Link\n    from django.urls import reverse\n    from django.utils.translation import ugettext\n    from geonode.layers.models import Dataset\n    from geonode.documents.models import Document\n\n    # Prune old links\n    if prune:\n        logger.debug(\" -- Resource Links[Prune old links]...\")\n        _def_link_types = (\"data\", \"image\", \"original\", \"html\", \"OGC:WMS\", \"OGC:WFS\", \"OGC:WCS\")\n        Link.objects.filter(resource=instance.resourcebase_ptr, link_type__in=_def_link_types).delete()\n        logger.debug(\" -- Resource Links[Prune old links]...done!\")\n\n    if check_ogc_backend(geoserver.BACKEND_PACKAGE):\n        from geonode.geoserver.ows import wcs_links, wfs_links, wms_links\n        from geonode.geoserver.helpers import ogc_server_settings, gs_catalog\n\n        # Compute parameters for the new links\n        logger.debug(\" -- Resource Links[Compute parameters for the new links]...\")\n        height = 550\n        width = 550\n\n        # Parse Dataset BBOX and SRID\n        bbox = None\n        srid = instance.srid if instance.srid else getattr(settings, \"DEFAULT_MAP_CRS\", \"EPSG:4326\")\n        if not prune and instance.srid and instance.bbox_polygon:\n            bbox = instance.bbox_string\n        else:\n            try:\n                gs_resource = gs_catalog.get_resource(\n                    name=instance.name, store=instance.store, workspace=instance.workspace\n                )\n                if not gs_resource:\n                    gs_resource = gs_catalog.get_resource(name=instance.name, workspace=instance.workspace)\n                if not gs_resource:\n                    gs_resource = gs_catalog.get_resource(name=instance.name)\n\n                if gs_resource:\n                    srid = gs_resource.projection\n                    bbox = gs_resource.native_bbox\n                    ll_bbox = gs_resource.latlon_bbox\n                    try:\n                        instance.set_bbox_polygon([bbox[0], bbox[2], bbox[1], bbox[3]], srid)\n                    except GeoNodeException as e:\n                        if not ll_bbox:\n                            raise\n                        else:\n                            logger.exception(e)\n                            instance.srid = \"EPSG:4326\"\n                    instance.set_ll_bbox_polygon([ll_bbox[0], ll_bbox[2], ll_bbox[1], ll_bbox[3]])\n                    if instance.srid:\n                        instance.srid_url = (\n                            f\"http://www.spatialreference.org/ref/{instance.srid.replace(':', '/').lower()}/\"\n                        )\n                    elif instance.bbox_polygon is not None:\n                        # Guessing 'EPSG:4326' by default\n                        instance.srid = \"EPSG:4326\"\n                    else:\n                        raise GeoNodeException(_(\"Invalid Projection. Dataset is missing CRS!\"))\n                    dx = float(bbox[1]) - float(bbox[0])\n                    dy = float(bbox[3]) - float(bbox[2])\n                    dataAspect = 1 if dy == 0 else dx / dy\n                    width = int(height * dataAspect)\n                    # Rewriting BBOX as a plain string\n                    bbox = \",\".join(str(x) for x in [bbox[0], bbox[2], bbox[1], bbox[3]])\n                else:\n                    bbox = instance.bbox_string\n            except Exception as e:\n                logger.exception(e)\n                bbox = instance.bbox_string\n\n        # Create Raw Data download link\n        if settings.DISPLAY_ORIGINAL_DATASET_LINK:\n            logger.debug(\" -- Resource Links[Create Raw Data download link]...\")\n            if isinstance(instance, Dataset):\n                download_url = build_absolute_uri(reverse(\"dataset_download\", args=(instance.alternate,)))\n            elif isinstance(instance, Document):\n                download_url = build_absolute_uri(reverse(\"document_download\", args=(instance.id,)))\n            else:\n                download_url = None\n\n            while Link.objects.filter(resource=instance.resourcebase_ptr, link_type=\"original\").exists():\n                Link.objects.filter(resource=instance.resourcebase_ptr, link_type=\"original\").delete()\n            Link.objects.update_or_create(\n                resource=instance.resourcebase_ptr,\n                url=download_url,\n                defaults=dict(\n                    extension=\"zip\",\n                    name=\"Original Dataset\",\n                    mime=\"application/octet-stream\",\n                    link_type=\"original\",\n                ),\n            )\n            logger.debug(\" -- Resource Links[Create Raw Data download link]...done!\")\n        else:\n            Link.objects.filter(resource=instance.resourcebase_ptr, name=\"Original Dataset\").delete()\n\n        # Set download links for WMS, WCS or WFS and KML\n        logger.debug(\" -- Resource Links[Set download links for WMS, WCS or WFS and KML]...\")\n        instance_ows_url = f\"{instance.ows_url}?\" if instance.ows_url else f\"{ogc_server_settings.public_url}ows?\"\n        links = wms_links(instance_ows_url, instance.alternate, bbox, srid, height, width)\n\n        for ext, name, mime, wms_url in links:\n            try:\n                Link.objects.update_or_create(\n                    resource=instance.resourcebase_ptr,\n                    name=ugettext(name),\n                    defaults=dict(\n                        extension=ext,\n                        url=wms_url,\n                        mime=mime,\n                        link_type=\"image\",\n                    ),\n                )\n            except Link.MultipleObjectsReturned:\n                _d = dict(extension=ext, url=wms_url, mime=mime, link_type=\"image\")\n                Link.objects.filter(resource=instance.resourcebase_ptr, name=ugettext(name), link_type=\"image\").update(\n                    **_d\n                )\n\n        if instance.subtype == \"vector\":\n            links = wfs_links(\n                instance_ows_url,\n                instance.alternate,\n                bbox=None,  # bbox filter should be set at runtime otherwise conflicting with CQL\n                srid=srid,\n            )\n            for ext, name, mime, wfs_url in links:\n                if mime == \"SHAPE-ZIP\":\n                    name = \"Zipped Shapefile\"\n                if (\n                    Link.objects.filter(\n                        resource=instance.resourcebase_ptr, url=wfs_url, name=name, link_type=\"data\"\n                    ).count()\n                    < 2\n                ):\n                    Link.objects.update_or_create(\n                        resource=instance.resourcebase_ptr,\n                        url=wfs_url,\n                        name=name,\n                        link_type=\"data\",\n                        defaults=dict(\n                            extension=ext,\n                            mime=mime,\n                        ),\n                    )\n\n        elif instance.subtype == \"raster\":\n            \"\"\"\n            Going to create the WCS GetCoverage Default download links.\n            By providing 'None' bbox and srid, we are going to ask to the WCS to\n            skip subsetting, i.e. output the whole coverage in the netive SRS.\n\n            Notice that the \"wcs_links\" method also generates 1 default \"outputFormat\":\n             - \"geotiff\"; GeoTIFF which will be compressed and tiled by passing to the WCS the default query params compression='DEFLATE' and tile_size=512\n            \"\"\"\n            links = wcs_links(instance_ows_url, instance.alternate)\n            for ext, name, mime, wcs_url in links:\n                if (\n                    Link.objects.filter(\n                        resource=instance.resourcebase_ptr, url=wcs_url, name=name, link_type=\"data\"\n                    ).count()\n                    < 2\n                ):\n                    Link.objects.update_or_create(\n                        resource=instance.resourcebase_ptr,\n                        url=wcs_url,\n                        name=name,\n                        link_type=\"data\",\n                        defaults=dict(\n                            extension=ext,\n                            mime=mime,\n                        ),\n                    )\n\n        site_url = settings.SITEURL.rstrip(\"/\") if settings.SITEURL.startswith(\"http\") else settings.SITEURL\n        html_link_url = f\"{site_url}{instance.get_absolute_url()}\"\n\n        if (\n            Link.objects.filter(\n                resource=instance.resourcebase_ptr, url=html_link_url, name=instance.alternate, link_type=\"html\"\n            ).count()\n            < 2\n        ):\n            Link.objects.update_or_create(\n                resource=instance.resourcebase_ptr,\n                url=html_link_url,\n                name=instance.alternate or instance.name,\n                link_type=\"html\",\n                defaults=dict(\n                    extension=\"html\",\n                    mime=\"text/html\",\n                ),\n            )\n        logger.debug(\" -- Resource Links[Set download links for WMS, WCS or WFS and KML]...done!\")\n\n        # Legend link\n        logger.debug(\" -- Resource Links[Legend link]...\")\n        try:\n            if instance.subtype not in [\"tileStore\", \"remote\"]:\n                for style in set(\n                    list(instance.styles.all())\n                    + [\n                        instance.default_style,\n                    ]\n                ):\n                    if style:\n                        style_name = os.path.basename(urlparse(style.sld_url).path).split(\".\")[0]\n                        legend_url = get_legend_url(instance, style_name)\n                        if Link.objects.filter(resource=instance.resourcebase_ptr, url=legend_url).count() < 2:\n                            Link.objects.update_or_create(\n                                resource=instance.resourcebase_ptr,\n                                name=\"Legend\",\n                                url=legend_url,\n                                defaults=dict(\n                                    extension=\"png\",\n                                    url=legend_url,\n                                    mime=\"image/png\",\n                                    link_type=\"image\",\n                                ),\n                            )\n            else:\n                from geonode.services.serviceprocessors import get_service_handler\n\n                handler = get_service_handler(\n                    instance.remote_service.service_url, service_type=instance.remote_service.type\n                )\n                if handler and hasattr(handler, \"_create_dataset_legend_link\"):\n                    handler._create_dataset_legend_link(instance)\n\n            logger.debug(\" -- Resource Links[Legend link]...done!\")\n        except Exception as e:\n            logger.debug(f\" -- Resource Links[Legend link]...error: {e}\")\n\n        # Thumbnail link\n        if instance.get_thumbnail_url():\n            logger.debug(\" -- Resource Links[Thumbnail link]...\")\n            if (\n                Link.objects.filter(\n                    resource=instance.resourcebase_ptr, url=instance.get_thumbnail_url(), name=\"Thumbnail\"\n                ).count()\n                < 2\n            ):\n                Link.objects.update_or_create(\n                    resource=instance.resourcebase_ptr,\n                    url=instance.get_thumbnail_url(),\n                    name=\"Thumbnail\",\n                    defaults=dict(\n                        extension=\"png\",\n                        mime=\"image/png\",\n                        link_type=\"image\",\n                    ),\n                )\n            logger.debug(\" -- Resource Links[Thumbnail link]...done!\")\n\n        logger.debug(\" -- Resource Links[OWS Links]...\")\n        try:\n            if (\n                not hasattr(instance.get_real_instance(), \"ptype\")\n                or instance.get_real_instance().ptype == GXP_PTYPES[\"WMS\"]\n            ):\n                ogc_wms_url = instance.ows_url or urljoin(ogc_server_settings.public_url, \"ows\")\n                ogc_wms_name = f\"OGC WMS: {instance.workspace} Service\"\n                if (\n                    Link.objects.filter(resource=instance.resourcebase_ptr, name=ogc_wms_name, url=ogc_wms_url).count()\n                    < 2\n                ):\n                    Link.objects.get_or_create(\n                        resource=instance.resourcebase_ptr,\n                        url=ogc_wms_url,\n                        name=ogc_wms_name,\n                        defaults=dict(\n                            extension=\"html\",\n                            url=ogc_wms_url,\n                            mime=\"text/html\",\n                            link_type=\"OGC:WMS\",\n                        ),\n                    )\n\n                if instance.subtype == \"vector\":\n                    ogc_wfs_url = instance.ows_url or urljoin(ogc_server_settings.public_url, \"ows\")\n                    ogc_wfs_name = f\"OGC WFS: {instance.workspace} Service\"\n                    if (\n                        Link.objects.filter(\n                            resource=instance.resourcebase_ptr, name=ogc_wfs_name, url=ogc_wfs_url\n                        ).count()\n                        < 2\n                    ):\n                        Link.objects.get_or_create(\n                            resource=instance.resourcebase_ptr,\n                            url=ogc_wfs_url,\n                            name=ogc_wfs_name,\n                            defaults=dict(\n                                extension=\"html\",\n                                url=ogc_wfs_url,\n                                mime=\"text/html\",\n                                link_type=\"OGC:WFS\",\n                            ),\n                        )\n\n                if instance.subtype == \"raster\":\n                    ogc_wcs_url = instance.ows_url or urljoin(ogc_server_settings.public_url, \"ows\")\n                    ogc_wcs_name = f\"OGC WCS: {instance.workspace} Service\"\n                    if (\n                        Link.objects.filter(\n                            resource=instance.resourcebase_ptr, name=ogc_wcs_name, url=ogc_wcs_url\n                        ).count()\n                        < 2\n                    ):\n                        Link.objects.get_or_create(\n                            resource=instance.resourcebase_ptr,\n                            url=ogc_wcs_url,\n                            name=ogc_wcs_name,\n                            defaults=dict(\n                                extension=\"html\",\n                                url=ogc_wcs_url,\n                                mime=\"text/html\",\n                                link_type=\"OGC:WCS\",\n                            ),\n                        )\n\n            elif hasattr(instance.get_real_instance(), \"ptype\") and instance.get_real_instance().ptype:\n                ptype_link = dict((v, k) for k, v in GXP_PTYPES.items()).get(instance.get_real_instance().ptype)\n                ptype_link_name = get_available_service_types().get(ptype_link)\n                ptype_link_url = instance.ows_url\n                if (\n                    Link.objects.filter(\n                        resource=instance.resourcebase_ptr, name=ptype_link_name, url=ptype_link_url\n                    ).count()\n                    < 2\n                ):\n                    Link.objects.get_or_create(\n                        resource=instance.resourcebase_ptr,\n                        url=ptype_link_url,\n                        name=ptype_link_name,\n                        defaults=dict(\n                            extension=\"html\",\n                            url=ptype_link_url,\n                            mime=\"text/html\",\n                            link_type=\"image\",\n                        ),\n                    )\n            logger.debug(\" -- Resource Links[OWS Links]...done!\")\n        except Exception as e:\n            logger.error(\" -- Resource Links[OWS Links]...error!\")\n            logger.exception(e)\n\n\ndef add_url_params(url, params):\n    \"\"\"Add GET params to provided URL being aware of existing.\n\n    :param url: string of target URL\n    :param params: dict containing requested params to be added\n    :return: string with updated URL\n\n    >> url = 'http://stackoverflow.com/test?answers=true'\n    >> new_params = {'answers': False, 'data': ['some','values']}\n    >> add_url_params(url, new_params)\n    'http://stackoverflow.com/test?data=some&data=values&answers=false'\n    \"\"\"\n    # Unquoting URL first so we don't loose existing args\n    url = unquote(url)\n    # Extracting url info\n    parsed_url = urlparse(url)\n    # Extracting URL arguments from parsed URL\n    get_args = parsed_url.query\n    # Converting URL arguments to dict\n    parsed_get_args = dict(parse_qsl(get_args))\n    # Merging URL arguments dict with new params\n    parsed_get_args.update(params)\n\n    # Bool and Dict values should be converted to json-friendly values\n    # you may throw this part away if you don't like it :)\n    parsed_get_args.update({k: json.dumps(v) for k, v in parsed_get_args.items() if isinstance(v, (bool, dict))})\n\n    # Converting URL argument to proper query string\n    encoded_get_args = urlencode(parsed_get_args, doseq=True)\n    # Creating new parsed result object based on provided with new\n    # URL arguments. Same thing happens inside of urlparse.\n    new_url = ParseResult(\n        parsed_url.scheme, parsed_url.netloc, parsed_url.path, parsed_url.params, encoded_get_args, parsed_url.fragment\n    ).geturl()\n\n    return new_url\n\n\njson_serializer_k_map = {\n    \"user\": settings.AUTH_USER_MODEL,\n    \"owner\": settings.AUTH_USER_MODEL,\n    \"restriction_code_type\": \"base.RestrictionCodeType\",\n    \"license\": \"base.License\",\n    \"category\": \"base.TopicCategory\",\n    \"spatial_representation_type\": \"base.SpatialRepresentationType\",\n    \"group\": \"auth.Group\",\n    \"default_style\": \"datasets.Style\",\n}\n\n\ndef json_serializer_producer(dictionary):\n    \"\"\"\n    - usage:\n           serialized_obj =\n               json_serializer_producer(model_to_dict(instance))\n\n    - dump to file:\n       with open('data.json', 'w') as outfile:\n           json.dump(serialized_obj, outfile)\n\n    - read from file:\n       with open('data.json', 'r') as infile:\n           serialized_obj = json.load(infile)\n    \"\"\"\n\n    def to_json(keys):\n        if isinstance(keys, datetime.datetime):\n            return str(keys)\n        elif isinstance(keys, str) or isinstance(keys, int):\n            return keys\n        elif isinstance(keys, dict):\n            return json_serializer_producer(keys)\n        elif isinstance(keys, list):\n            return [json_serializer_producer(model_to_dict(k)) for k in keys]\n        elif isinstance(keys, models.Model):\n            return json_serializer_producer(model_to_dict(keys))\n        elif isinstance(keys, Decimal):\n            return float(keys)\n        else:\n            return str(keys)\n\n    output = {}\n\n    _keys_to_skip = [\n        \"email\",\n        \"password\",\n        \"last_login\",\n        \"date_joined\",\n        \"is_staff\",\n        \"is_active\",\n        \"is_superuser\",\n        \"permissions\",\n        \"user_permissions\",\n    ]\n\n    for x, y in dictionary.items():\n        if x not in _keys_to_skip:\n            if x in json_serializer_k_map.keys():\n                instance = django_apps.get_model(json_serializer_k_map[x], require_ready=False)\n                if instance.objects.filter(id=y):\n                    _obj = instance.objects.get(id=y)\n                    y = model_to_dict(_obj)\n            output[x] = to_json(y)\n    return output\n\n\ndef is_monochromatic_image(image_url, image_data=None):\n    def is_local_static(url):\n        if url.startswith(settings.STATIC_URL) or (url.startswith(settings.SITEURL) and settings.STATIC_URL in url):\n            return True\n        return False\n\n    def is_absolute(url):\n        return bool(urlparse(url).netloc)\n\n    def get_thumb_handler(url):\n        _index = url.find(settings.STATIC_URL)\n        _thumb_path = urlparse(url[_index + len(settings.STATIC_URL) :]).path\n        if storage_manager.exists(_thumb_path):\n            return storage_manager.open(_thumb_path)\n        return None\n\n    def verify_image(stream):\n        with Image.open(stream) as _stream:\n            img = _stream.convert(\"L\")\n            img.verify()  # verify that it is, in fact an image\n            extr = img.getextrema()\n            a = 0\n            for i in extr:\n                if isinstance(i, tuple):\n                    a += abs(i[0] - i[1])\n                else:\n                    a = abs(extr[0] - extr[1])\n                    break\n            return a == 0\n\n    try:\n        if image_data:\n            logger.debug(\"...Checking if image is a blank image\")\n            with BytesIO(image_data) as stream:\n                return verify_image(stream)\n        elif image_url:\n            logger.debug(f\"...Checking if '{image_url}' is a blank image\")\n            url = image_url if is_absolute(image_url) else urljoin(settings.SITEURL, image_url)\n            if not is_local_static(url):\n                req, stream_content = http_client.get(url, timeout=5)\n                with BytesIO(stream_content) as stream:\n                    return verify_image(stream)\n            else:\n                with get_thumb_handler(url) as stream:\n                    return verify_image(stream)\n        return True\n    except Exception as e:\n        logger.debug(e)\n        return False\n\n\ndef find_by_attr(lst, val, attr=\"id\"):\n    \"\"\"Returns an object if the id matches in any list of objects\"\"\"\n    for item in lst:\n        if attr in item and item[attr] == val:\n            return item\n\n    return None\n\n\ndef build_absolute_uri(url):\n    if url and \"http\" not in url:\n        url = urljoin(settings.SITEURL, url)\n    return url\n\n\ndef get_xpath_value(\n    element: etree.Element, xpath_expression: str, nsmap: typing.Optional[dict] = None\n) -> typing.Optional[str]:\n    if not nsmap:\n        nsmap = element.nsmap\n    values = element.xpath(f\"{xpath_expression}//text()\", namespaces=nsmap)\n    return \"\".join(values).strip() or None\n\n\ndef get_geonode_app_types():\n    from geonode.geoapps.models import GeoApp\n\n    return list(set(GeoApp.objects.values_list(\"resource_type\", flat=True)))\n\n\ndef get_supported_datasets_file_types():\n    from django.conf import settings as gn_settings\n\n    \"\"\"\n    Return a list of all supported file type in geonode\n    If one of the type provided in the custom type exists in the default\n    is going to override it\n    \"\"\"\n    default_types = settings.SUPPORTED_DATASET_FILE_TYPES\n    types_module = (\n        gn_settings.ADDITIONAL_DATASET_FILE_TYPES if hasattr(gn_settings, \"ADDITIONAL_DATASET_FILE_TYPES\") else []\n    )\n    supported_types = default_types.copy()\n    default_types_id = [t.get(\"id\") for t in default_types]\n    for _type in types_module:\n        if _type.get(\"id\") in default_types_id:\n            supported_types[default_types_id.index(_type.get(\"id\"))] = _type\n        else:\n            supported_types.extend([_type])\n\n    # Order the formats (to support their visualization)\n    formats_order = [(\"vector\", 0), (\"raster\", 1), (\"archive\", 2)]\n    ordered_payload = (\n        (weight[1], resource_type)\n        for resource_type in supported_types\n        for weight in formats_order\n        if resource_type.get(\"format\") in weight[0]\n    )\n\n    # Flatten the list\n    ordered_resource_types = [x[1] for x in sorted(ordered_payload, key=lambda x: x[0])]\n    other_resource_types = [\n        resource_type\n        for resource_type in supported_types\n        if resource_type.get(\"format\") is None or resource_type.get(\"format\") not in [f[0] for f in formats_order]\n    ]\n    return ordered_resource_types + other_resource_types\n\n\ndef get_allowed_extensions():\n    return list(itertools.chain.from_iterable([_type[\"ext\"] for _type in get_supported_datasets_file_types()]))\n\n\ndef safe_path_leaf(path):\n    \"\"\"A view that is not vulnerable to malicious file access.\"\"\"\n    base_path = settings.MEDIA_ROOT\n    try:\n        validate_filepath(path, platform=\"auto\")\n        head, tail = ntpath.split(path)\n        filename = tail or ntpath.basename(head)\n        validate_filename(filename, platform=\"auto\")\n    except ValidationError as e:\n        logger.error(f\"{e}\")\n        raise e\n    # GOOD -- Verify with normalised version of path\n    fullpath = os.path.normpath(os.path.join(head, filename))\n    if not fullpath.startswith(base_path) or path != fullpath:\n        raise GeoNodeException(\n            f\"The provided path '{path}' is not safe. The file is outside the MEDIA_ROOT '{base_path}' base path!\"\n        )\n    return fullpath\n\n\ndef import_class_module(full_class_string):\n    \"\"\"\n    Dynamically load a class from a string\n\n    >>> klass = import_class_module(\"module.submodule.ClassName\")\n    >>> klass2 = import_class_module(\"myfile.Class2\")\n    \"\"\"\n    try:\n        module_path, class_name = full_class_string.rsplit(\".\", 1)\n        module = importlib.import_module(module_path)\n        class_obj = getattr(module, class_name)\n        return class_obj\n    except Exception:\n        return None\n", "# native dependencies\nPillow==10.0.0\nlxml==4.9.3\npsycopg2==2.9.7\nDjango==3.2.20\n\n# Other\namqp==5.1.1\nbeautifulsoup4==4.12.2\nhttplib2<0.22.1\nhyperlink==21.0.0\nidna>=2.5,<3.5\nurllib3==1.26.15\nPaver==1.3.4\npython-slugify==8.0.1\ndecorator==5.1.1\ncelery==5.3.1\nkombu==5.3.1\nvine==5.0.0\ntqdm==4.66.1\nDeprecated==1.2.14\nwrapt==1.15.0\njsonschema==4.19.0\nzipstream-new==1.1.8\nschema==0.7.5\nrdflib==6.3.2\nsmart_open==6.3.0\nPyMuPDF==1.22.5\npathvalidate==3.1.0\n\n# Django Apps\ndjango-allauth==0.54.0\ndjango-appconf==1.0.5\ndjango-celery-results==2.5.1\ndjango-filter==23.2\ndjango-imagekit==4.1.0\ndjango-taggit==1.5.1\ndjango-markdownify==0.9.3\ndjango-mptt==0.14.0\ndjango-modeltranslation>=0.11,<0.19.0\ndjango-treebeard==4.7\ndjango-guardian<2.4.1\ndjango-downloadview==2.3.0\ndjango-polymorphic==3.1.0\ndjango-tastypie<0.15.0\ndjango-tinymce==3.6.1\ndjango-grappelli==3.0.7\ndjango-uuid-upload-path==1.0.0\ndjango-widget-tweaks==1.4.12\ndjango-sequences==2.8\noauthlib==3.2.2\npyopenssl==23.2.0\npyjwt==2.8.0\n\n# geopython dependencies\npyproj<3.7.0\nOWSLib==0.29.2\npycsw==2.6.1\nSQLAlchemy==2.0.20 # required by PyCSW\nShapely==1.8.5.post1\nmercantile==1.2.1\ngeoip2==4.7.0\nnumpy==1.25.*\n\n# # Apps with packages provided in GeoNode's PPA on Launchpad.\n\n# Django Apps\ndj-database-url==2.1.0\ndj-pagination==2.5.0\ndjango-select2==8.1.2\ndjango-floppyforms<1.10.0\ndjango-forms-bootstrap<=3.1.0\ndjango-autocomplete-light==3.5.1\ndjango-invitations<2.0.1\ndjango-recaptcha==3.0.0\n\n# REST\ndjangorestframework==3.12.0\ndjangorestframework-gis==1.0\ndjangorestframework-guardian==0.3.0\ndrf-extensions==0.7.1\ndrf-writable-nested==0.7.0\ndrf-spectacular==0.26.4\ndynamic-rest==2.1.2\nMarkdown==3.4.4\n\npinax-notifications==6.0.0\npinax-ratings==4.0.0\n\n# GeoNode org maintained apps.\n# django-geonode-mapstore-client==4.0.5\n-e git+https://github.com/GeoNode/geonode-mapstore-client.git@master#egg=django_geonode_mapstore_client\n-e git+https://github.com/GeoNode/geonode-importer.git@master#egg=geonode-importer\ndjango-avatar==7.1.1\ngeonode-oauth-toolkit==2.2.2\ngeonode-user-messages==2.0.2\ngeonode-announcements==2.0.2\ngeonode-django-activity-stream==0.10.0\ngn-arcrest==10.5.6\ngeoserver-restconfig==2.0.9\ngn-gsimporter==2.0.4\ngisdata==0.5.4\n\n# haystack/elasticsearch\ndjango-haystack==3.2.1\nelasticsearch>=2.0.0,<9.0.0\n\n# datetimepicker widget\ndjango-bootstrap3-datetimepicker-2==2.8.3\n\n# storage manager dependencies\ndjango-storages==1.13.2\ndropbox==11.36.2\ngoogle-cloud-storage==2.10.0\ngoogle-cloud-core==2.3.3\nboto3==1.28.32\n\n# Django Caches\npython-memcached<=1.59\nwhitenoise==6.5.0\nBrotli==1.0.9\n\n# Contribs\nxmltodict<0.13.1\ninflection>=0.4.0\njdcal==1.4.1\nmock<6.0.0\npython-dateutil==2.8.2\npytz==2023.3\nrequests==2.31.0\ntimeout-decorator==0.5.0\npylibmc==1.6.3\nsherlock==0.4.1\n\n# required by monitoring\npsutil==5.9.5\ndjango-cors-headers==4.2.0\nuser-agents\ndjango-user-agents\nxmljson\ndjango-ipware<5.1\n# no version here, use latest one with fresh data\npycountry\n\n# production\nuWSGI==2.0.22\ngunicorn==21.2.0\nipython==8.14.0\ndocker==6.1.3\ninvoke==2.2.0\n\n# tests\ncoverage==7.3.0\nrequests-toolbelt==1.0.0\nflake8==6.1.0\nblack==23.7.0\npytest==7.4.0\npytest-bdd==6.1.1\nsplinter==0.19.0\npytest-splinter==3.3.2\npytest-django==4.5.2\nsetuptools>=59.1.1,<68.2.0\npip==23.2.1\nTwisted==22.10.0\npixelmatch==0.3.0\nfactory-boy==3.3.0\nflaky==3.7.0\nselenium>=4.1.0,<5.0.0\nselenium-requests==2.0.3\nwebdriver_manager==4.0.0\n\n# Security and audit\nmistune==3.0.1\nprotobuf==3.20.3\nmako==1.2.4\nparamiko==3.3.1 # not directly required, fixes Blowfish deprecation warning\ncertifi>=2022.12.7 # not directly required, pinned by Snyk to avoid a vulnerability\njwcrypto>=1.4 # not directly required, pinned by Snyk to avoid a vulnerability\ncryptography>=41.0.0 # not directly required, pinned by Snyk to avoid a vulnerability\n", "[metadata]\nname = GeoNode\ndescription = Application for serving and sharing geospatial data\nlicense = GPL\nauthor = GeoNode Developers\nauthor_email = dev@geonode.org\nurl = http://geonode.org\ndownload_url = https://github.com/GeoNode/geonode/archive/master.zip\nkeywords = django, geonode\nclassifiers =\n    Development Status :: 5 - Production/Stable\n    Environment :: Web Environment\n    Framework :: Django\n    Intended Audience :: Developers\n    Operating System :: OS Independent\n    Topic :: Internet :: WWW/HTTP\n    Programming Language :: Python :: 3.10\n\n[options]\nzip_safe = False\ninclude_package_data = True\npython_requires = >= 3.10\npackages = find:\nsetup_requires =\n    setuptools\ninstall_requires =\n    # native dependencies\n    Pillow==10.0.0\n    lxml==4.9.3\n    psycopg2==2.9.7\n    Django==3.2.20\n\n    # Other\n    amqp==5.1.1\n    beautifulsoup4==4.12.2\n    httplib2<0.22.1\n    hyperlink==21.0.0\n    idna>=2.5,<3.5\n    urllib3==1.26.15\n    Paver==1.3.4\n    python-slugify==8.0.1\n    decorator==5.1.1\n    celery==5.3.1\n    kombu==5.3.1\n    vine==5.0.0\n    tqdm==4.66.1\n    Deprecated==1.2.14\n    wrapt==1.15.0\n    jsonschema==4.19.0\n    zipstream-new==1.1.8\n    schema==0.7.5\n    rdflib==6.3.2\n    smart_open==6.3.0\n    PyMuPDF==1.22.5\n    pathvalidate==3.1.0\n\n    # Django Apps\n    django-allauth==0.54.0\n    django-appconf==1.0.5\n    django-celery-results==2.5.1\n    django-filter==23.2\n    django-imagekit==4.1.0\n    django-taggit==1.5.1\n    django-markdownify==0.9.3\n    django-mptt==0.14.0\n    django-modeltranslation>=0.11,<0.19.0\n    django-treebeard==4.7\n    django-guardian<2.4.1\n    django-downloadview==2.3.0\n    django-polymorphic==3.1.0\n    django-tastypie<0.15.0\n    django-tinymce==3.6.1\n    django-grappelli==3.0.7\n    django-uuid-upload-path==1.0.0\n    django-widget-tweaks==1.4.12\n    django-sequences==2.8\n    oauthlib==3.2.2\n    pyopenssl==23.2.0\n    pyjwt==2.8.0\n\n    # geopython dependencies\n    pyproj<3.7.0\n    OWSLib==0.29.2\n    pycsw==2.6.1\n    SQLAlchemy==2.0.20 # required by PyCSW\n    Shapely==1.8.5.post1\n    mercantile==1.2.1\n    geoip2==4.7.0\n    numpy==1.25.*\n\n    # # Apps with packages provided in GeoNode's PPA on Launchpad.\n\n    # Django Apps\n    dj-database-url==2.1.0\n    dj-pagination==2.5.0\n    django-select2==8.1.2\n    django-floppyforms<1.10.0\n    django-forms-bootstrap<=3.1.0\n    django-autocomplete-light==3.5.1\n    django-invitations<2.0.1\n    django-recaptcha==3.0.0\n\n    # REST\n    djangorestframework==3.12.0\n    djangorestframework-gis==1.0\n    djangorestframework-guardian==0.3.0\n    drf-extensions==0.7.1\n    drf-writable-nested==0.7.0\n    drf-spectacular==0.26.4\n    dynamic-rest==2.1.2\n    Markdown==3.4.4\n\n    pinax-notifications==6.0.0\n    pinax-ratings==4.0.0\n\n    # GeoNode org maintained apps.\n    django-geonode-mapstore-client>=4.0.5,<5.0.0\n    geonode-importer>=1.0.2\n    django-avatar==7.1.1\n    geonode-oauth-toolkit==2.2.2\n    geonode-user-messages==2.0.2\n    geonode-announcements==2.0.2\n    geonode-django-activity-stream==0.10.0\n    gn-arcrest==10.5.6\n    geoserver-restconfig==2.0.9\n    gn-gsimporter==2.0.4\n    gisdata==0.5.4\n\n    # haystack/elasticsearch\n    django-haystack==3.2.1\n    elasticsearch>=2.0.0,<9.0.0\n\n    # datetimepicker widget\n    django-bootstrap3-datetimepicker-2==2.8.3\n\n    # storage manager dependencies\n    django-storages==1.13.2\n    dropbox==11.36.2\n    google-cloud-storage==2.10.0\n    google-cloud-core==2.3.3\n    boto3==1.28.32\n\n    # Django Caches\n    python-memcached<=1.59\n    whitenoise==6.5.0\n    Brotli==1.0.9\n\n    # Contribs\n    xmltodict<0.13.1\n    inflection>=0.4.0\n    jdcal==1.4.1\n    mock<6.0.0\n    python-dateutil==2.8.2\n    pytz==2023.3\n    requests==2.31.0\n    timeout-decorator==0.5.0\n    pylibmc==1.6.3\n    sherlock==0.4.1\n\n    # required by monitoring\n    psutil==5.9.5\n    django-cors-headers==4.2.0\n    user-agents\n    django-user-agents\n    xmljson\n    django-ipware<5.1\n    # no version here, use latest one with fresh data\n    pycountry\n\n    # production\n    uWSGI==2.0.22\n    gunicorn==21.2.0\n    ipython==8.14.0\n    docker==6.1.3\n    invoke==2.2.0\n\n    # tests\n    coverage==7.3.0\n    requests-toolbelt==1.0.0\n    flake8==6.1.0\n    black==23.7.0\n    pytest==7.4.0\n    pytest-bdd==6.1.1\n    splinter==0.19.0\n    pytest-splinter==3.3.2\n    pytest-django==4.5.2\n    setuptools>=59.1.1,<68.2.0\n    pip==23.2.1\n    Twisted==22.10.0\n    pixelmatch==0.3.0\n    factory-boy==3.3.0\n    flaky==3.7.0\n    selenium>=4.1.0,<5.0.0\n    selenium-requests==2.0.3\n    webdriver_manager==4.0.0\n\n    # Security and audit\n    mistune==3.0.1\n    protobuf==3.20.3\n    mako==1.2.4\n    paramiko==3.3.1 # not directly required, fixes Blowfish deprecation warning\n    certifi>=2022.12.7 # not directly required, pinned by Snyk to avoid a vulnerability\n    jwcrypto>=1.4 # not directly required, pinned by Snyk to avoid a vulnerability\n    cryptography>=41.0.0 # not directly required, pinned by Snyk to avoid a vulnerability\n\n[options.packages.find]\nexclude = tests\n\n[bdist_wheel]\nuniversal = 1\n\n[flake8]\nmax-line-length = 200\nexclude=geonode/*/migrations/*,scripts,docs,static,migrations,node_modules\nextend-ignore=E122,E124,E203,E731\n"], "fixing_code": ["#########################################################################\n#\n# Copyright (C) 2016 OSGeo\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program. If not, see <http://www.gnu.org/licenses/>.\n#\n#########################################################################\n\n\"\"\"\nThis file demonstrates two different styles of tests (one doctest and one\nunittest). These will both pass when you run \"manage.py test\".\n\nReplace these with more appropriate tests for your application.\n\"\"\"\nimport json\nimport io\nimport zipfile\n\nfrom urllib.parse import urljoin\n\nfrom django.conf import settings\nfrom geonode.proxy.templatetags.proxy_lib_tags import original_link_available\nfrom django.test.client import RequestFactory\nfrom django.core.files.uploadedfile import SimpleUploadedFile\nfrom unittest.mock import patch\n\nfrom geonode.upload.models import Upload\n\ntry:\n    from unittest.mock import MagicMock\nexcept ImportError:\n    from unittest.mock import MagicMock\n\nfrom django.urls import reverse\nfrom django.contrib.auth import get_user_model\nfrom django.test.utils import override_settings\n\nfrom geonode import geoserver\nfrom geonode.base.models import Link\nfrom geonode.layers.models import Dataset\nfrom geonode.decorators import on_ogc_backend\nfrom geonode.tests.base import GeoNodeBaseTestSupport\nfrom geonode.base.populate_test_data import create_models, create_single_dataset\n\nTEST_DOMAIN = \".github.com\"\nTEST_URL = f\"https://help{TEST_DOMAIN}/\"\n\n\nclass ProxyTest(GeoNodeBaseTestSupport):\n    def setUp(self):\n        super().setUp()\n        self.maxDiff = None\n        self.admin = get_user_model().objects.get(username=\"admin\")\n\n        # FIXME(Ariel): These tests do not work when the computer is offline.\n        self.proxy_url = \"/proxy/\"\n        self.url = TEST_URL\n\n    @override_settings(DEBUG=True, PROXY_ALLOWED_HOSTS=())\n    def test_validate_host_disabled_in_debug(self):\n        \"\"\"If PROXY_ALLOWED_HOSTS is empty and DEBUG is True, all hosts pass the proxy.\"\"\"\n        response = self.client.get(f\"{self.proxy_url}?url={self.url}\")\n        if response.status_code != 404:  # 404 - NOT FOUND\n            self.assertTrue(response.status_code in (200, 301), response.status_code)\n\n    @override_settings(DEBUG=False, PROXY_ALLOWED_HOSTS=())\n    def test_validate_host_disabled_not_in_debug(self):\n        \"\"\"If PROXY_ALLOWED_HOSTS is empty and DEBUG is False requests should return 403.\"\"\"\n        response = self.client.get(f\"{self.proxy_url}?url={self.url}\")\n        if response.status_code != 404:  # 404 - NOT FOUND\n            self.assertEqual(response.status_code, 403, response.status_code)\n\n    @override_settings(DEBUG=False, PROXY_ALLOWED_HOSTS=(TEST_DOMAIN,))\n    def test_proxy_allowed_host(self):\n        \"\"\"If PROXY_ALLOWED_HOSTS is not empty and DEBUG is False requests should return no error.\"\"\"\n        self.client.login(username=\"admin\", password=\"admin\")\n        response = self.client.get(f\"{self.proxy_url}?url={self.url}\")\n        if response.status_code != 404:  # 404 - NOT FOUND\n            self.assertEqual(response.status_code, 200, response.status_code)\n\n    @override_settings(DEBUG=False, PROXY_ALLOWED_HOSTS=())\n    def test_validate_remote_services_hosts(self):\n        \"\"\"If PROXY_ALLOWED_HOSTS is empty and DEBUG is False requests should return 200\n        for Remote Services hosts.\"\"\"\n        from geonode.services.models import Service\n        from geonode.services.enumerations import WMS, INDEXED\n\n        Service.objects.get_or_create(\n            type=WMS,\n            name=\"Bogus\",\n            title=\"Pocus\",\n            owner=self.admin,\n            method=INDEXED,\n            base_url=\"http://bogus.pocus.com/ows\",\n        )\n        response = self.client.get(f\"{self.proxy_url}?url=http://bogus.pocus.com/ows/wms?request=GetCapabilities\")\n        # 200 - FOUND\n        self.assertTrue(response.status_code in (200, 301))\n\n    @override_settings(DEBUG=False, PROXY_ALLOWED_HOSTS=(\".example.org\",))\n    def test_relative_urls(self):\n        \"\"\"Proxying to a URL with a relative path element should normalise the path into\n        an absolute path before calling the remote URL.\"\"\"\n        import geonode.proxy.views\n\n        class Response:\n            status_code = 200\n            content = \"Hello World\"\n            headers = {\"Content-Type\": \"text/html\"}\n\n        request_mock = MagicMock()\n        request_mock.return_value = (Response(), None)\n\n        geonode.proxy.views.http_client.request = request_mock\n        url = \"http://example.org/test/test/../../index.html\"\n\n        self.client.get(f\"{self.proxy_url}?url={url}\")\n        assert request_mock.call_args[0][0] == \"http://example.org/index.html\"\n\n    def test_proxy_preserve_headers(self):\n        \"\"\"The GeoNode Proxy should preserve the original request headers.\"\"\"\n        import geonode.proxy.views\n\n        _test_headers = {\n            \"Access-Control-Allow-Credentials\": False,\n            \"Access-Control-Allow-Headers\": \"Content-Type, Accept, Authorization, Origin, User-Agent\",\n            \"Access-Control-Allow-Methods\": \"GET, POST, PUT, PATCH, OPTIONS\",\n            \"Cache-Control\": \"public, must-revalidate, max-age = 30\",\n            \"Connection\": \"keep-alive\",\n            \"Content-Language\": \"en\",\n            \"Content-Length\": 116559,\n            \"Content-Type\": \"image/tiff\",\n            \"Content-Disposition\": 'attachment; filename=\"filename.tif\"',\n            \"Date\": \"Fri, 05 Nov 2021 17: 19: 11 GMT\",\n            \"Server\": \"nginx/1.17.2\",\n            \"Set-Cookie\": \"sessionid = bogus-pocus; HttpOnly; Path=/; SameSite=Lax\",\n            \"Strict-Transport-Security\": \"max-age=3600; includeSubDomains\",\n            \"Vary\": \"Authorization, Accept-Language, Cookie, origin\",\n            \"X-Content-Type-Options\": \"nosniff\",\n            \"X-XSS-Protection\": \"1; mode=block\",\n        }\n\n        class Response:\n            status_code = 200\n            content = \"Hello World\"\n            headers = _test_headers\n\n        request_mock = MagicMock()\n        request_mock.return_value = (Response(), None)\n\n        geonode.proxy.views.http_client.request = request_mock\n        url = \"http://example.org/test/test/../../image.tiff\"\n\n        response = self.client.get(f\"{self.proxy_url}?url={url}\")\n        self.assertDictContainsSubset(\n            dict(response.headers.copy()),\n            {\n                \"Content-Type\": \"text/plain\",\n                \"Vary\": \"Authorization, Accept-Language, Cookie, origin\",\n                \"X-Content-Type-Options\": \"nosniff\",\n                \"X-XSS-Protection\": \"1; mode=block\",\n                \"Referrer-Policy\": \"same-origin\",\n                \"X-Frame-Options\": \"SAMEORIGIN\",\n                \"Content-Language\": \"en-us\",\n                \"Content-Length\": \"119\",\n                \"Content-Disposition\": 'attachment; filename=\"filename.tif\"',\n            },\n        )\n\n    def test_proxy_url_forgery(self):\n        \"\"\"The GeoNode Proxy should preserve the original request headers.\"\"\"\n        import geonode.proxy.views\n        from urllib.parse import urlsplit\n\n        class Response:\n            status_code = 200\n            content = \"Hello World\"\n            headers = {\n                \"Content-Type\": \"text/plain\",\n                \"Vary\": \"Authorization, Accept-Language, Cookie, origin\",\n                \"X-Content-Type-Options\": \"nosniff\",\n                \"X-XSS-Protection\": \"1; mode=block\",\n                \"Referrer-Policy\": \"same-origin\",\n                \"X-Frame-Options\": \"SAMEORIGIN\",\n                \"Content-Language\": \"en-us\",\n                \"Content-Length\": \"119\",\n                \"Content-Disposition\": 'attachment; filename=\"filename.tif\"',\n            }\n\n        request_mock = MagicMock()\n        request_mock.return_value = (Response(), None)\n\n        # Non-Legit requests attempting SSRF\n        geonode.proxy.views.http_client.request = request_mock\n        url = f\"http://example.org\\@%23{urlsplit(settings.SITEURL).hostname}\"\n\n        response = self.client.get(f\"{self.proxy_url}?url={url}\")\n        self.assertEqual(response.status_code, 403)\n\n        url = f\"http://125.126.127.128\\@%23{urlsplit(settings.SITEURL).hostname}\"\n\n        response = self.client.get(f\"{self.proxy_url}?url={url}\")\n        self.assertEqual(response.status_code, 403)\n\n        # Legit requests using the local host (SITEURL)\n        url = f\"/\\@%23{urlsplit(settings.SITEURL).hostname}\"\n\n        response = self.client.get(f\"{self.proxy_url}?url={url}\")\n        self.assertEqual(response.status_code, 200)\n\n        url = f\"{settings.SITEURL}\\@%23{urlsplit(settings.SITEURL).hostname}\"\n\n        response = self.client.get(f\"{self.proxy_url}?url={url}\")\n        self.assertEqual(response.status_code, 200)\n\n\nclass DownloadResourceTestCase(GeoNodeBaseTestSupport):\n    def setUp(self):\n        super().setUp()\n        self.maxDiff = None\n        create_models(type=\"dataset\")\n\n    @on_ogc_backend(geoserver.BACKEND_PACKAGE)\n    def test_download_url_with_not_existing_file(self):\n        dataset = Dataset.objects.all().first()\n        self.client.login(username=\"admin\", password=\"admin\")\n        # ... all should be good\n        response = self.client.get(reverse(\"download\", args=(dataset.id,)))\n        # Espected 404 since there are no files available for this layer\n        self.assertEqual(response.status_code, 404)\n        content = response.content\n        if isinstance(content, bytes):\n            content = content.decode(\"UTF-8\")\n        data = content\n        self.assertTrue(\"No files have been found for this resource. Please, contact a system administrator.\" in data)\n\n    @patch(\"geonode.storage.manager.storage_manager.exists\")\n    @patch(\"geonode.storage.manager.storage_manager.open\")\n    @on_ogc_backend(geoserver.BACKEND_PACKAGE)\n    def test_download_url_with_existing_files(self, fopen, fexists):\n        fexists.return_value = True\n        fopen.return_value = SimpleUploadedFile(\"foo_file.shp\", b\"scc\")\n        dataset = Dataset.objects.all().first()\n\n        dataset.files = [\n            \"/tmpe1exb9e9/foo_file.dbf\",\n            \"/tmpe1exb9e9/foo_file.prj\",\n            \"/tmpe1exb9e9/foo_file.shp\",\n            \"/tmpe1exb9e9/foo_file.shx\",\n        ]\n\n        dataset.save()\n\n        dataset.refresh_from_db()\n\n        upload = Upload.objects.create(state=\"RUNNING\", resource=dataset)\n\n        assert upload\n\n        self.client.login(username=\"admin\", password=\"admin\")\n        # ... all should be good\n        response = self.client.get(reverse(\"download\", args=(dataset.id,)))\n        # Espected 404 since there are no files available for this layer\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(\"application/zip\", response.headers.get(\"Content-Type\"))\n        self.assertEqual('attachment; filename=\"CA.zip\"', response.headers.get(\"Content-Disposition\"))\n\n    @patch(\"geonode.storage.manager.storage_manager.exists\")\n    @patch(\"geonode.storage.manager.storage_manager.open\")\n    @on_ogc_backend(geoserver.BACKEND_PACKAGE)\n    def test_download_files(self, fopen, fexists):\n        fexists.return_value = True\n        fopen.return_value = SimpleUploadedFile(\"foo_file.shp\", b\"scc\")\n        dataset = Dataset.objects.all().first()\n\n        dataset.files = [\n            \"/tmpe1exb9e9/foo_file.dbf\",\n            \"/tmpe1exb9e9/foo_file.prj\",\n            \"/tmpe1exb9e9/foo_file.shp\",\n            \"/tmpe1exb9e9/foo_file.shx\",\n        ]\n\n        dataset.save()\n\n        dataset.refresh_from_db()\n\n        Upload.objects.create(state=\"COMPLETE\", resource=dataset)\n\n        self.client.login(username=\"admin\", password=\"admin\")\n        response = self.client.get(reverse(\"download\", args=(dataset.id,)))\n        # headers and status assertions\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.get(\"content-type\"), \"application/zip\")\n        self.assertEqual(response.get(\"content-disposition\"), f'attachment; filename=\"{dataset.name}.zip\"')\n        # Inspect content\n        zip_content = io.BytesIO(b\"\".join(response.streaming_content))\n        zip = zipfile.ZipFile(zip_content)\n        zip_files = zip.namelist()\n        self.assertEqual(len(zip_files), 4)\n        self.assertIn(\".shp\", \"\".join(zip_files))\n        self.assertIn(\".dbf\", \"\".join(zip_files))\n        self.assertIn(\".shx\", \"\".join(zip_files))\n        self.assertIn(\".prj\", \"\".join(zip_files))\n\n\nclass OWSApiTestCase(GeoNodeBaseTestSupport):\n    def setUp(self):\n        super().setUp()\n        self.maxDiff = None\n        create_models(type=\"dataset\")\n        # prepare some WMS endpoints\n        q = Link.objects.all()\n        for lyr in q[:3]:\n            lyr.link_type = \"OGC:WMS\"\n            lyr.save()\n\n    def test_ows_api(self):\n        url = \"/api/ows_endpoints/\"\n        q = Link.objects.filter(link_type__startswith=\"OGC:\")\n        resp = self.client.get(url)\n        self.assertEqual(resp.status_code, 200)\n        content = resp.content\n        if isinstance(content, bytes):\n            content = content.decode(\"UTF-8\")\n        data = json.loads(content)\n        self.assertTrue(len(data[\"data\"]), q.count())\n\n\n@override_settings(SITEURL=\"http://localhost:8000\")\nclass TestProxyTags(GeoNodeBaseTestSupport):\n    def setUp(self):\n        self.maxDiff = None\n        self.resource = create_single_dataset(\"foo_dataset\")\n        r = RequestFactory()\n        self.url = urljoin(settings.SITEURL, reverse(\"download\", args={self.resource.id}))\n        r.get(self.url)\n        admin = get_user_model().objects.get(username=\"admin\")\n        r.user = admin\n        self.context = {\"request\": r}\n\n    def test_tag_original_link_available_with_different_netlock_should_return_true(self):\n        actual = original_link_available(self.context, self.resource.resourcebase_ptr_id, \"http://url.com/\")\n        self.assertTrue(actual)\n\n    def test_should_return_false_if_no_files_are_available(self):\n        _ = Upload.objects.create(state=\"RUNNING\", resource=self.resource)\n\n        actual = original_link_available(self.context, self.resource.resourcebase_ptr_id, self.url)\n        self.assertFalse(actual)\n\n    @patch(\"geonode.storage.manager.storage_manager.exists\", return_value=True)\n    def test_should_return_true_if_files_are_available(self, fexists):\n        upload = Upload.objects.create(state=\"RUNNING\", resource=self.resource)\n\n        assert upload\n\n        self.resource.files = [\n            \"/tmpe1exb9e9/foo_file.dbf\",\n            \"/tmpe1exb9e9/foo_file.prj\",\n            \"/tmpe1exb9e9/foo_file.shp\",\n            \"/tmpe1exb9e9/foo_file.shx\",\n        ]\n\n        self.resource.save()\n\n        self.resource.refresh_from_db()\n\n        actual = original_link_available(self.context, self.resource.resourcebase_ptr_id, self.url)\n        self.assertTrue(actual)\n", "#########################################################################\n#\n# Copyright (C) 2016 OSGeo\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program. If not, see <http://www.gnu.org/licenses/>.\n#\n#########################################################################\nimport io\nimport os\nimport re\nimport gzip\nimport logging\nimport traceback\nimport zipstream\n\nfrom hyperlink import URL\nfrom urllib.parse import urlparse, urlsplit, urljoin\n\nfrom django.conf import settings\nfrom django.template import loader\nfrom django.http import HttpResponse, StreamingHttpResponse\nfrom django.views.generic import View\nfrom distutils.version import StrictVersion\nfrom django.http.request import validate_host\nfrom django.utils.translation import ugettext as _\nfrom django.views.decorators.csrf import requires_csrf_token\n\nfrom geonode.layers.models import Dataset\nfrom geonode.upload.models import Upload\nfrom geonode.base.models import ResourceBase\nfrom geonode.storage.manager import storage_manager\nfrom geonode.utils import (\n    resolve_object,\n    check_ogc_backend,\n    get_headers,\n    http_client,\n    json_response,\n    extract_ip_or_domain,\n)\nfrom geonode.base.enumerations import LINK_TYPES as _LT\n\nfrom geonode import geoserver  # noqa\nfrom geonode.base import register_event\nfrom geonode.base.auth import get_auth_user, get_token_from_auth_header\n\nBUFFER_CHUNK_SIZE = 64 * 1024\n\nTIMEOUT = 30\n\nLINK_TYPES = [L for L in _LT if L.startswith(\"OGC:\")]\n\nlogger = logging.getLogger(__name__)\n\n\nows_regexp = re.compile(r\"^(?i)(version)=(\\d\\.\\d\\.\\d)(?i)&(?i)request=(?i)(GetCapabilities)&(?i)service=(?i)(\\w\\w\\w)$\")\n\n\n@requires_csrf_token\ndef proxy(\n    request,\n    url=None,\n    response_callback=None,\n    sec_chk_hosts=True,\n    sec_chk_rules=True,\n    timeout=None,\n    allowed_hosts=[],\n    headers=None,\n    access_token=None,\n    **kwargs,\n):\n    # Request default timeout\n    from geonode.geoserver.helpers import ogc_server_settings\n\n    if not timeout:\n        timeout = getattr(ogc_server_settings, \"TIMEOUT\", TIMEOUT)\n\n    # Security rules and settings\n    PROXY_ALLOWED_HOSTS = getattr(settings, \"PROXY_ALLOWED_HOSTS\", ())\n\n    # Sanity url checks\n    if \"url\" not in request.GET and not url:\n        return HttpResponse(\n            \"The proxy service requires a URL-encoded URL as a parameter.\", status=400, content_type=\"text/plain\"\n        )\n\n    raw_url = url or request.GET[\"url\"]\n    raw_url = urljoin(settings.SITEURL, raw_url) if raw_url.startswith(\"/\") else raw_url\n    url = urlsplit(raw_url)\n    scheme = str(url.scheme)\n    locator = str(url.path)\n    if url.query != \"\":\n        locator += f\"?{url.query}\"\n    if url.fragment != \"\":\n        locator += f\"#{url.fragment}\"\n\n    # White-Black Listing Hosts\n    site_url = urlsplit(settings.SITEURL)\n    if sec_chk_hosts and not settings.DEBUG:\n        # Attach current SITEURL\n        if site_url.hostname not in PROXY_ALLOWED_HOSTS:\n            PROXY_ALLOWED_HOSTS += (site_url.hostname,)\n\n        # Attach current hostname\n        hostname = (ogc_server_settings.hostname,) if ogc_server_settings else ()\n        if hostname not in PROXY_ALLOWED_HOSTS:\n            PROXY_ALLOWED_HOSTS += hostname\n\n        # Check OWS regexp\n        if url.query and ows_regexp.match(url.query):\n            ows_tokens = ows_regexp.match(url.query).groups()\n            if (\n                len(ows_tokens) == 4\n                and \"version\" == ows_tokens[0]\n                and StrictVersion(ows_tokens[1]) >= StrictVersion(\"1.0.0\")\n                and StrictVersion(ows_tokens[1]) <= StrictVersion(\"3.0.0\")\n                and ows_tokens[2].lower() in (\"getcapabilities\")\n                and ows_tokens[3].upper() in (\"OWS\", \"WCS\", \"WFS\", \"WMS\", \"WPS\", \"CSW\")\n            ):\n                if url.hostname not in PROXY_ALLOWED_HOSTS:\n                    PROXY_ALLOWED_HOSTS += (url.hostname,)\n\n        # Check Remote Services base_urls\n        from geonode.services.models import Service\n\n        for _s in Service.objects.all():\n            _remote_host = urlsplit(_s.base_url).hostname\n            PROXY_ALLOWED_HOSTS += (_remote_host,)\n\n        if not validate_host(extract_ip_or_domain(raw_url), PROXY_ALLOWED_HOSTS):\n            return HttpResponse(\n                \"DEBUG is set to False but the host of the path provided to the proxy service\"\n                \" is not in the PROXY_ALLOWED_HOSTS setting.\",\n                status=403,\n                content_type=\"text/plain\",\n            )\n\n    # Security checks based on rules; allow only specific requests\n    if sec_chk_rules:\n        # TODO: Not yet implemented\n        pass\n\n    # Collecting headers and cookies\n    if not headers:\n        headers, access_token = get_headers(request, url, raw_url, allowed_hosts=allowed_hosts)\n    if not access_token:\n        auth_header = None\n        if \"Authorization\" in headers:\n            auth_header = headers[\"Authorization\"]\n        elif \"HTTP_AUTHORIZATION\" in request.META:\n            auth_header = request.META.get(\"HTTP_AUTHORIZATION\", request.META.get(\"HTTP_AUTHORIZATION2\"))\n        if auth_header:\n            access_token = get_token_from_auth_header(auth_header, create_if_not_exists=True)\n    user = get_auth_user(access_token)\n\n    # Inject access_token if necessary\n    parsed = urlparse(raw_url)\n    parsed._replace(path=locator.encode(\"utf8\"))\n    if parsed.netloc == site_url.netloc and scheme != site_url.scheme:\n        parsed = parsed._replace(scheme=site_url.scheme)\n\n    _url = parsed.geturl()\n\n    # Some clients / JS libraries generate URLs with relative URL paths, e.g.\n    # \"http://host/path/path/../file.css\", which the requests library cannot\n    # currently handle (https://github.com/kennethreitz/requests/issues/2982).\n    # We parse and normalise such URLs into absolute paths before attempting\n    # to proxy the request.\n    _url = URL.from_text(_url).normalize().to_text()\n\n    if request.method == \"GET\" and access_token and \"access_token\" not in _url:\n        query_separator = \"&\" if \"?\" in _url else \"?\"\n        _url = f\"{_url}{query_separator}access_token={access_token}\"\n\n    _data = request.body.decode(\"utf-8\")\n\n    # Avoid translating local geoserver calls into external ones\n    if check_ogc_backend(geoserver.BACKEND_PACKAGE):\n        from geonode.geoserver.helpers import ogc_server_settings\n\n        _url = _url.replace(f\"{settings.SITEURL}geoserver\", ogc_server_settings.LOCATION.rstrip(\"/\"))\n        _data = _data.replace(f\"{settings.SITEURL}geoserver\", ogc_server_settings.LOCATION.rstrip(\"/\"))\n\n    response, content = http_client.request(\n        _url, method=request.method, data=_data.encode(\"utf-8\"), headers=headers, timeout=timeout, user=user\n    )\n    if response is None:\n        return HttpResponse(content=content, reason=content, status=500)\n    content = response.content or response.reason\n    status = response.status_code\n    response_headers = response.headers\n    content_type = response.headers.get(\"Content-Type\")\n\n    if status >= 400:\n        _response = HttpResponse(content=content, reason=content, status=status, content_type=content_type)\n        return fetch_response_headers(_response, response_headers)\n\n    # decompress GZipped responses if not enabled\n    # if content and response and response.getheader('Content-Encoding') == 'gzip':\n    if content and content_type and content_type == \"gzip\":\n        buf = io.BytesIO(content)\n        with gzip.GzipFile(fileobj=buf) as f:\n            content = f.read()\n        buf.close()\n\n    PLAIN_CONTENT_TYPES = [\"text\", \"plain\", \"html\", \"json\", \"xml\", \"gml\"]\n    for _ct in PLAIN_CONTENT_TYPES:\n        if content_type and _ct in content_type and not isinstance(content, str):\n            try:\n                content = content.decode()\n                break\n            except Exception:\n                pass\n\n    if response and response_callback:\n        kwargs = {} if not kwargs else kwargs\n        kwargs.update(\n            {\n                \"response\": response,\n                \"content\": content,\n                \"status\": status,\n                \"response_headers\": response_headers,\n                \"content_type\": content_type,\n            }\n        )\n        return response_callback(**kwargs)\n    else:\n        # If we get a redirect, let's add a useful message.\n        if status and status in (301, 302, 303, 307):\n            _response = HttpResponse(\n                (\n                    f\"This proxy does not support redirects. The server in '{url}' \"\n                    f\"asked for a redirect to '{response.getheader('Location')}'\"\n                ),\n                status=status,\n                content_type=content_type,\n            )\n            _response[\"Location\"] = response.getheader(\"Location\")\n            return fetch_response_headers(_response, response_headers)\n        else:\n\n            def _get_message(text):\n                _s = text\n                if isinstance(text, bytes):\n                    _s = text.decode(\"utf-8\", \"replace\")\n                try:\n                    found = re.search(\"<b>Message</b>(.+?)</p>\", _s).group(1).strip()\n                except Exception:\n                    found = _s\n                return found\n\n            _response = HttpResponse(\n                content=content,\n                reason=_get_message(content) if status not in (200, 201) else None,\n                status=status,\n                content_type=content_type,\n            )\n            return fetch_response_headers(_response, response_headers)\n\n\ndef download(request, resourceid, sender=Dataset):\n    _not_authorized = _(\"You are not authorized to download this resource.\")\n    _not_permitted = _(\"You are not permitted to save or edit this resource.\")\n    _no_files_found = _(\"No files have been found for this resource. Please, contact a system administrator.\")\n\n    instance = resolve_object(\n        request, sender, {\"pk\": resourceid}, permission=\"base.download_resourcebase\", permission_msg=_not_permitted\n    )\n\n    if isinstance(instance, ResourceBase):\n        dataset_files = []\n        file_list = []  # Store file info to be returned\n        try:\n            files = instance.resourcebase_ptr.files\n            # Copy all Dataset related files into a temporary folder\n            for file_path in files:\n                if storage_manager.exists(file_path):\n                    dataset_files.append(file_path)\n                    filename = os.path.basename(file_path)\n                    file_list.append(\n                        {\n                            \"name\": filename,\n                            \"data_iter\": storage_manager.open(file_path),\n                        }\n                    )\n                else:\n                    return HttpResponse(\n                        loader.render_to_string(\n                            \"401.html\",\n                            context={\"error_title\": _(\"No files found.\"), \"error_message\": _no_files_found},\n                            request=request,\n                        ),\n                        status=404,\n                    )\n\n            # Check we can access the original files\n            if not dataset_files:\n                return HttpResponse(\n                    loader.render_to_string(\n                        \"401.html\",\n                        context={\"error_title\": _(\"No files found.\"), \"error_message\": _no_files_found},\n                        request=request,\n                    ),\n                    status=404,\n                )\n\n            # ZIP everything and return\n            target_file_name = \"\".join([instance.name, \".zip\"])\n\n            target_zip = zipstream.ZipFile(mode=\"w\", compression=zipstream.ZIP_DEFLATED, allowZip64=True)\n\n            # Iterable: Needed when the file_info has it's data as a stream\n            def _iterable(source_iter):\n                while True:\n                    buf = source_iter.read(BUFFER_CHUNK_SIZE)\n                    if not buf:\n                        break\n                    yield buf\n\n            # Add files to zip\n            for file_info in file_list:\n                target_zip.write_iter(arcname=file_info[\"name\"], iterable=_iterable(file_info[\"data_iter\"]))\n\n            register_event(request, \"download\", instance)\n\n            # Streaming content response\n            response = StreamingHttpResponse(target_zip, content_type=\"application/zip\")\n            response[\"Content-Disposition\"] = f'attachment; filename=\"{target_file_name}\"'\n            return response\n        except (NotImplementedError, Upload.DoesNotExist):\n            traceback.print_exc()\n            tb = traceback.format_exc()\n            logger.debug(tb)\n            return HttpResponse(\n                loader.render_to_string(\n                    \"401.html\",\n                    context={\"error_title\": _(\"No files found.\"), \"error_message\": _no_files_found},\n                    request=request,\n                ),\n                status=404,\n            )\n    return HttpResponse(\n        loader.render_to_string(\n            \"401.html\", context={\"error_title\": _(\"Not Authorized\"), \"error_message\": _not_authorized}, request=request\n        ),\n        status=403,\n    )\n\n\nclass OWSListView(View):\n    def get(self, request):\n        from geonode.geoserver import ows\n\n        out = {\"success\": True}\n        data = []\n        out[\"data\"] = data\n        # WMS\n        _raw_url = ows._wms_get_capabilities()\n        _url = urlsplit(_raw_url)\n        headers, access_token = get_headers(request, _url, _raw_url)\n        if access_token:\n            _j = \"&\" if _url.query else \"?\"\n            _raw_url = _j.join([_raw_url, f\"access_token={access_token}\"])\n        data.append({\"url\": _raw_url, \"type\": \"OGC:WMS\"})\n\n        # WCS\n        _raw_url = ows._wcs_get_capabilities()\n        _url = urlsplit(_raw_url)\n        headers, access_token = get_headers(request, _url, _raw_url)\n        if access_token:\n            _j = \"&\" if _url.query else \"?\"\n            _raw_url = _j.join([_raw_url, f\"access_token={access_token}\"])\n        data.append({\"url\": _raw_url, \"type\": \"OGC:WCS\"})\n\n        # WFS\n        _raw_url = ows._wfs_get_capabilities()\n        _url = urlsplit(_raw_url)\n        headers, access_token = get_headers(request, _url, _raw_url)\n        if access_token:\n            _j = \"&\" if _url.query else \"?\"\n            _raw_url = _j.join([_raw_url, f\"access_token={access_token}\"])\n        data.append({\"url\": _raw_url, \"type\": \"OGC:WFS\"})\n\n        # catalogue from configuration\n        for catname, catconf in settings.CATALOGUE.items():\n            # CSW\n            _raw_url = catconf[\"URL\"]\n            _url = urlsplit(_raw_url)\n            headers, access_token = get_headers(request, _url, _raw_url)\n            if access_token:\n                _j = \"&\" if _url.query else \"?\"\n                _raw_url = _j.join([_raw_url, f\"access_token={access_token}\"])\n            data.append({\"url\": _raw_url, \"type\": \"OGC:CSW\"})\n\n        # main site url\n        data.append({\"url\": settings.SITEURL, \"type\": \"WWW:LINK\"})\n        return json_response(out)\n\n\n_hoppish = {\n    \"connection\",\n    \"keep-alive\",\n    \"proxy-authenticate\",\n    \"proxy-authorization\",\n    \"te\",\n    \"trailers\",\n    \"transfer-encoding\",\n    \"upgrade\",\n    \"content-length\",\n    \"content-encoding\",\n}.__contains__\n\n\ndef is_hop_by_hop(header_name):\n    \"\"\"Return true if 'header_name' is an HTTP/1.1 \"Hop-by-Hop\" header\"\"\"\n    return _hoppish(header_name.lower())\n\n\ndef fetch_response_headers(response, response_headers):\n    if response_headers:\n        for _header in response_headers:\n            if not is_hop_by_hop(_header):\n                if hasattr(response, \"headers\") and _header.lower() not in [\n                    _k.lower() for _k in response.headers.keys()\n                ]:\n                    response.headers[_header] = response_headers.get(_header)\n                elif hasattr(response, \"_headers\") and _header.lower() not in [\n                    _k.lower() for _k in response._headers.keys()\n                ]:\n                    response._headers[_header] = (_header, response_headers.get(_header))\n    return response\n", "#########################################################################\n#\n# Copyright (C) 2016 OSGeo\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program. If not, see <http://www.gnu.org/licenses/>.\n#\n#########################################################################\n\nimport os\nimport gc\nimport re\nimport json\nimport time\nimport base64\nimport ntpath\nimport select\nimport shutil\nimport string\nimport typing\nimport logging\nimport tarfile\nimport datetime\nimport requests\nimport tempfile\nimport importlib\nimport ipaddress\nimport itertools\nimport traceback\nimport subprocess\n\nfrom lxml import etree\nfrom osgeo import ogr\nfrom PIL import Image\nfrom urllib3 import Retry\nfrom io import BytesIO, StringIO\nfrom decimal import Decimal\nfrom threading import local\nfrom slugify import slugify\nfrom contextlib import closing\nfrom requests.exceptions import RetryError\nfrom collections import namedtuple, defaultdict\nfrom rest_framework.exceptions import APIException\nfrom math import atan, exp, log, pi, sin, tan, floor\nfrom zipfile import ZipFile, is_zipfile, ZIP_DEFLATED\nfrom pathvalidate import ValidationError, validate_filepath, validate_filename\nfrom geonode.upload.api.exceptions import GeneralUploadException\n\nfrom django.conf import settings\nfrom django.db.models import signals\nfrom django.utils.http import is_safe_url\nfrom django.apps import apps as django_apps\nfrom django.middleware.csrf import get_token\nfrom django.http import HttpResponse\nfrom django.forms.models import model_to_dict\nfrom django.contrib.auth import get_user_model\nfrom django.shortcuts import get_object_or_404\nfrom django.core.exceptions import PermissionDenied\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.serializers.json import DjangoJSONEncoder\nfrom django.db import models, connection, transaction\nfrom django.utils.translation import ugettext_lazy as _\n\nfrom geonode import geoserver, GeoNodeException  # noqa\nfrom geonode.compat import ensure_string\nfrom geonode.layers.enumerations import GXP_PTYPES\nfrom geonode.storage.manager import storage_manager\nfrom geonode.services.serviceprocessors import get_available_service_types\nfrom geonode.base.auth import (\n    extend_token,\n    get_or_create_token,\n    get_token_from_auth_header,\n    get_token_object_from_session,\n)\n\nfrom urllib.parse import (\n    urljoin,\n    unquote,\n    urlparse,\n    urlsplit,\n    urlencode,\n    parse_qsl,\n    ParseResult,\n)\n\nMAX_EXTENT = 20037508.34\nFULL_ROTATION_DEG = 360.0\nHALF_ROTATION_DEG = 180.0\nDEFAULT_TITLE = \"\"\nDEFAULT_ABSTRACT = \"\"\n\nINVALID_PERMISSION_MESSAGE = _(\"Invalid permission level.\")\n\nALPHABET = f\"{string.ascii_uppercase + string.ascii_lowercase + string.digits}-_\"\nALPHABET_REVERSE = {c: i for (i, c) in enumerate(ALPHABET)}\nBASE = len(ALPHABET)\nSIGN_CHARACTER = \"$\"\nSQL_PARAMS_RE = re.compile(r\"%\\(([\\w_\\-]+)\\)s\")\n\nFORWARDED_HEADERS = [\"content-type\", \"content-disposition\"]\n\n# explicitly disable resolving XML entities in order to prevent malicious attacks\nXML_PARSER: typing.Final = etree.XMLParser(resolve_entities=False)\n\nrequests.packages.urllib3.disable_warnings()\n\nsignalnames = [\n    \"class_prepared\",\n    \"m2m_changed\",\n    \"post_delete\",\n    \"post_init\",\n    \"post_save\",\n    \"post_syncdb\",\n    \"pre_delete\",\n    \"pre_init\",\n    \"pre_save\",\n]\nsignals_store = {}\n\nid_none = id(None)\n\nlogger = logging.getLogger(\"geonode.utils\")\n\n\nclass ServerDoesNotExist(Exception):\n    pass\n\n\nclass OGC_Server(object):  # LGTM: @property will not work in old-style classes\n\n    \"\"\"\n    OGC Server object.\n    \"\"\"\n\n    def __init__(self, ogc_server, alias):\n        self.alias = alias\n        self.server = ogc_server\n\n    def __getattr__(self, item):\n        return self.server.get(item)\n\n    @property\n    def credentials(self):\n        \"\"\"\n        Returns a tuple of the server's credentials.\n        \"\"\"\n        creds = namedtuple(\"OGC_SERVER_CREDENTIALS\", [\"username\", \"password\"])\n        return creds(username=self.USER, password=self.PASSWORD)\n\n    @property\n    def datastore_db(self):\n        \"\"\"\n        Returns the server's datastore dict or None.\n        \"\"\"\n        if self.DATASTORE and settings.DATABASES.get(self.DATASTORE, None):\n            datastore_dict = settings.DATABASES.get(self.DATASTORE, dict())\n            return datastore_dict\n        else:\n            return dict()\n\n    @property\n    def ows(self):\n        \"\"\"\n        The Open Web Service url for the server.\n        \"\"\"\n        location = self.PUBLIC_LOCATION if self.PUBLIC_LOCATION else self.LOCATION\n        return self.OWS_LOCATION if self.OWS_LOCATION else urljoin(location, \"ows\")\n\n    @property\n    def rest(self):\n        \"\"\"\n        The REST endpoint for the server.\n        \"\"\"\n        return urljoin(self.LOCATION, \"rest\") if not self.REST_LOCATION else self.REST_LOCATION\n\n    @property\n    def public_url(self):\n        \"\"\"\n        The global public endpoint for the server.\n        \"\"\"\n        return self.LOCATION if not self.PUBLIC_LOCATION else self.PUBLIC_LOCATION\n\n    @property\n    def internal_ows(self):\n        \"\"\"\n        The Open Web Service url for the server used by GeoNode internally.\n        \"\"\"\n        location = self.LOCATION\n        return urljoin(location, \"ows\")\n\n    @property\n    def hostname(self):\n        return urlsplit(self.LOCATION).hostname\n\n    @property\n    def netloc(self):\n        return urlsplit(self.LOCATION).netloc\n\n    def __str__(self):\n        return str(self.alias)\n\n\nclass OGC_Servers_Handler:\n\n    \"\"\"\n    OGC Server Settings Convenience dict.\n    \"\"\"\n\n    def __init__(self, ogc_server_dict):\n        self.servers = ogc_server_dict\n        # FIXME(Ariel): Are there better ways to do this without involving\n        # local?\n        self._servers = local()\n\n    def ensure_valid_configuration(self, alias):\n        \"\"\"\n        Ensures the settings are valid.\n        \"\"\"\n        try:\n            server = self.servers[alias]\n        except KeyError:\n            raise ServerDoesNotExist(f\"The server {alias} doesn't exist\")\n\n        if \"PRINTNG_ENABLED\" in server:\n            raise ImproperlyConfigured(\"The PRINTNG_ENABLED setting has been removed, use 'PRINT_NG_ENABLED' instead.\")\n\n    def ensure_defaults(self, alias):\n        \"\"\"\n        Puts the defaults into the settings dictionary for a given connection where no settings is provided.\n        \"\"\"\n        try:\n            server = self.servers[alias]\n        except KeyError:\n            raise ServerDoesNotExist(f\"The server {alias} doesn't exist\")\n\n        server.setdefault(\"BACKEND\", \"geonode.geoserver\")\n        server.setdefault(\"LOCATION\", \"http://localhost:8080/geoserver/\")\n        server.setdefault(\"USER\", \"admin\")\n        server.setdefault(\"PASSWORD\", \"geoserver\")\n        server.setdefault(\"DATASTORE\", \"\")\n\n        for option in [\n            \"MAPFISH_PRINT_ENABLED\",\n            \"PRINT_NG_ENABLED\",\n            \"GEONODE_SECURITY_ENABLED\",\n            \"GEOFENCE_SECURITY_ENABLED\",\n            \"BACKEND_WRITE_ENABLED\",\n        ]:\n            server.setdefault(option, True)\n\n        for option in [\"WMST_ENABLED\", \"WPS_ENABLED\"]:\n            server.setdefault(option, False)\n\n        for option in [\"TIMEOUT\", \"GEOFENCE_TIMEOUT\"]:\n            server.setdefault(option, 60)\n\n    def __getitem__(self, alias):\n        if hasattr(self._servers, alias):\n            return getattr(self._servers, alias)\n\n        self.ensure_defaults(alias)\n        self.ensure_valid_configuration(alias)\n        server = self.servers[alias]\n        server = OGC_Server(alias=alias, ogc_server=server)\n        setattr(self._servers, alias, server)\n        return server\n\n    def __setitem__(self, key, value):\n        setattr(self._servers, key, value)\n\n    def __iter__(self):\n        return iter(self.servers)\n\n    def all(self):\n        return [self[alias] for alias in self]\n\n\ndef mkdtemp(dir=settings.MEDIA_ROOT):\n    if not os.path.exists(dir):\n        os.makedirs(dir, exist_ok=True)\n    tempdir = None\n    while not tempdir:\n        try:\n            tempdir = tempfile.mkdtemp(dir=dir)\n            if os.path.exists(tempdir) and os.path.isdir(tempdir):\n                if os.listdir(tempdir):\n                    raise Exception(\"Directory is not empty\")\n            else:\n                raise Exception(\"Directory does not exist or is not accessible\")\n        except Exception as e:\n            logger.exception(e)\n            tempdir = None\n    return tempdir\n\n\ndef unzip_file(upload_file, extension=\".shp\", tempdir=None):\n    \"\"\"\n    Unzips a zipfile into a temporary directory and returns the full path of the .shp file inside (if any)\n    \"\"\"\n    absolute_base_file = None\n    if tempdir is None:\n        tempdir = mkdtemp()\n\n    the_zip = ZipFile(upload_file, allowZip64=True)\n    the_zip.extractall(tempdir)\n    for item in the_zip.namelist():\n        if item.endswith(extension):\n            absolute_base_file = os.path.join(tempdir, item)\n\n    return absolute_base_file\n\n\ndef extract_tarfile(upload_file, extension=\".shp\", tempdir=None):\n    \"\"\"\n    Extracts a tarfile into a temporary directory and returns the full path of the .shp file inside (if any)\n    \"\"\"\n    absolute_base_file = None\n    if tempdir is None:\n        tempdir = mkdtemp()\n\n    the_tar = tarfile.open(upload_file)\n    the_tar.extractall(tempdir)\n    for item in the_tar.getnames():\n        if item.endswith(extension):\n            absolute_base_file = os.path.join(tempdir, item)\n\n    return absolute_base_file\n\n\ndef get_dataset_name(dataset):\n    \"\"\"Get the workspace where the input layer belongs\"\"\"\n    _name = dataset.name\n    if _name and \":\" in _name:\n        _name = _name.split(\":\")[1]\n    try:\n        if not _name and dataset.alternate:\n            if \":\" in dataset.alternate:\n                _name = dataset.alternate.split(\":\")[1]\n            else:\n                _name = dataset.alternate\n    except Exception:\n        pass\n    return _name\n\n\ndef get_dataset_workspace(dataset):\n    \"\"\"Get the workspace where the input layer belongs\"\"\"\n    try:\n        alternate = dataset.alternate\n    except Exception:\n        alternate = dataset.name\n    try:\n        workspace = dataset.workspace\n    except Exception:\n        workspace = None\n    if not workspace and alternate and \":\" in alternate:\n        workspace = alternate.split(\":\")[0]\n    if not workspace:\n        default_workspace = getattr(settings, \"DEFAULT_WORKSPACE\", \"geonode\")\n        try:\n            from geonode.services.enumerations import CASCADED\n\n            if dataset.remote_service.method == CASCADED:\n                workspace = getattr(settings, \"CASCADE_WORKSPACE\", default_workspace)\n            else:\n                raise RuntimeError(\"Dataset is not cascaded\")\n        except Exception:  # layer does not have a service\n            workspace = default_workspace\n    return workspace\n\n\ndef get_headers(request, url, raw_url, allowed_hosts=[]):\n    cookies = None\n    csrftoken = None\n    headers = {}\n\n    for _header_key, _header_value in dict(request.headers.copy()).items():\n        if _header_key.lower() in FORWARDED_HEADERS:\n            headers[_header_key] = _header_value\n    if settings.SESSION_COOKIE_NAME in request.COOKIES and is_safe_url(url=raw_url, allowed_hosts=url.hostname):\n        cookies = request.META[\"HTTP_COOKIE\"]\n\n    for cook in request.COOKIES:\n        name = str(cook)\n        value = request.COOKIES.get(name)\n        if name == \"csrftoken\":\n            csrftoken = value\n        cook = f\"{name}={value}\"\n        cookies = cook if not cookies else (f\"{cookies}; {cook}\")\n\n    csrftoken = get_token(request) if not csrftoken else csrftoken\n\n    if csrftoken:\n        headers[\"X-Requested-With\"] = \"XMLHttpRequest\"\n        headers[\"X-CSRFToken\"] = csrftoken\n        cook = f\"csrftoken={csrftoken}\"\n        cookies = cook if not cookies else (f\"{cookies}; {cook}\")\n\n    if cookies and request and hasattr(request, \"session\"):\n        if \"JSESSIONID\" in request.session and request.session[\"JSESSIONID\"]:\n            cookies = f\"{cookies}; JSESSIONID={request.session['JSESSIONID']}\"\n        headers[\"Cookie\"] = cookies\n\n    if request.method in (\"POST\", \"PUT\") and \"CONTENT_TYPE\" in request.META:\n        headers[\"Content-Type\"] = request.META[\"CONTENT_TYPE\"]\n\n    access_token = None\n    site_url = urlsplit(settings.SITEURL)\n    # We want to convert HTTP_AUTH into a Beraer Token only when hitting the local GeoServer\n    if site_url.hostname in (allowed_hosts + [url.hostname]):\n        # we give precedence to obtained from Aithorization headers\n        if \"HTTP_AUTHORIZATION\" in request.META:\n            auth_header = request.META.get(\"HTTP_AUTHORIZATION\", request.META.get(\"HTTP_AUTHORIZATION2\"))\n            if auth_header:\n                headers[\"Authorization\"] = auth_header\n                access_token = get_token_from_auth_header(auth_header, create_if_not_exists=True)\n        # otherwise we check if a session is active\n        elif request and request.user.is_authenticated:\n            access_token = get_token_object_from_session(request.session)\n\n            # we extend the token in case the session is active but the token expired\n            if access_token and access_token.is_expired():\n                extend_token(access_token)\n            else:\n                access_token = get_or_create_token(request.user)\n\n    if access_token:\n        headers[\"Authorization\"] = f\"Bearer {access_token}\"\n\n    pragma = \"no-cache\"\n    referer = (\n        request.META[\"HTTP_REFERER\"] if \"HTTP_REFERER\" in request.META else f\"{site_url.scheme}://{site_url.netloc}/\"\n    )\n    encoding = request.META[\"HTTP_ACCEPT_ENCODING\"] if \"HTTP_ACCEPT_ENCODING\" in request.META else \"gzip\"\n    headers.update(\n        {\n            \"Pragma\": pragma,\n            \"Referer\": referer,\n            \"Accept-encoding\": encoding,\n        }\n    )\n\n    return (headers, access_token)\n\n\ndef _get_basic_auth_info(request):\n    \"\"\"\n    grab basic auth info\n    \"\"\"\n    meth, auth = request.META[\"HTTP_AUTHORIZATION\"].split()\n    if meth.lower() != \"basic\":\n        raise ValueError\n    username, password = base64.b64decode(auth.encode()).decode().split(\":\")\n    return username, password\n\n\ndef batch_delete(request):\n    # TODO\n    pass\n\n\ndef _split_query(query):\n    \"\"\"\n    split and strip keywords, preserve space\n    separated quoted blocks.\n    \"\"\"\n\n    qq = query.split(\" \")\n    keywords = []\n    accum = None\n    for kw in qq:\n        if accum is None:\n            if kw.startswith('\"'):\n                accum = kw[1:]\n            elif kw:\n                keywords.append(kw)\n        else:\n            accum += f\" {kw}\"\n            if kw.endswith('\"'):\n                keywords.append(accum[0:-1])\n                accum = None\n    if accum is not None:\n        keywords.append(accum)\n    return [kw.strip() for kw in keywords if kw.strip()]\n\n\ndef bbox_to_wkt(x0, x1, y0, y1, srid=\"4326\", include_srid=True):\n    if srid and str(srid).startswith(\"EPSG:\"):\n        srid = srid[5:]\n    if None not in {x0, x1, y0, y1}:\n        polys = []\n\n        # We assume that if x1 is smaller then x0 we're crossing the date line\n        crossing_idl = x1 < x0\n        if crossing_idl:\n            polys.append(\n                [\n                    (float(x0), float(y0)),\n                    (float(x0), float(y1)),\n                    (180.0, float(y1)),\n                    (180.0, float(y0)),\n                    (float(x0), float(y0)),\n                ]\n            )\n            polys.append(\n                [\n                    (-180.0, float(y0)),\n                    (-180.0, float(y1)),\n                    (float(x1), float(y1)),\n                    (float(x1), float(y0)),\n                    (-180.0, float(y0)),\n                ]\n            )\n        else:\n            polys.append(\n                [\n                    (float(x0), float(y0)),\n                    (float(x0), float(y1)),\n                    (float(x1), float(y1)),\n                    (float(x1), float(y0)),\n                    (float(x0), float(y0)),\n                ]\n            )\n\n        poly_wkts = \",\".join(\n            [\"(({}))\".format(\",\".join([\"{:f} {:f}\".format(coords[0], coords[1]) for coords in poly])) for poly in polys]\n        )\n        wkt = f\"MULTIPOLYGON({poly_wkts})\" if len(polys) > 1 else f\"POLYGON{poly_wkts}\"\n        if include_srid:\n            wkt = f\"SRID={srid};{wkt}\"\n    else:\n        wkt = \"POLYGON((-180 -90,-180 90,180 90,180 -90,-180 -90))\"\n        if include_srid:\n            wkt = f\"SRID=4326;{wkt}\"\n    return wkt\n\n\ndef _v(coord, x, source_srid=4326, target_srid=3857):\n    if source_srid == 4326 and x and abs(coord) != HALF_ROTATION_DEG:\n        coord -= round(coord / FULL_ROTATION_DEG) * FULL_ROTATION_DEG\n    if source_srid == 4326 and target_srid != 4326:\n        if x and float(coord) >= 179.999:\n            return 179.999\n        elif x and float(coord) <= -179.999:\n            return -179.999\n\n        if not x and float(coord) >= 89.999:\n            return 89.999\n        elif not x and float(coord) <= -89.999:\n            return -89.999\n    return coord\n\n\ndef bbox_to_projection(native_bbox, target_srid=4326):\n    \"\"\"\n    native_bbox must be in the form\n        ('-81.3962935', '-81.3490249', '13.3202891', '13.3859614', 'EPSG:4326')\n    \"\"\"\n    box = native_bbox[:4]\n    proj = native_bbox[-1]\n    minx, maxx, miny, maxy = [float(a) for a in box]\n    try:\n        source_srid = int(proj.split(\":\")[1]) if proj and \":\" in proj else int(proj)\n    except Exception:\n        source_srid = target_srid\n\n    if source_srid != target_srid:\n        wkt = bbox_to_wkt(\n            _v(minx, x=True, source_srid=source_srid, target_srid=target_srid),\n            _v(maxx, x=True, source_srid=source_srid, target_srid=target_srid),\n            _v(miny, x=False, source_srid=source_srid, target_srid=target_srid),\n            _v(maxy, x=False, source_srid=source_srid, target_srid=target_srid),\n            srid=source_srid,\n            include_srid=False,\n        )\n        # AF: This causses error with GDAL 3.0.4 due to a breaking change on GDAL\n        #     https://code.djangoproject.com/ticket/30645\n        import osgeo.gdal\n\n        _gdal_ver = osgeo.gdal.__version__.split(\".\", 2)\n        from osgeo import ogr\n        from osgeo.osr import SpatialReference, CoordinateTransformation\n\n        g = ogr.Geometry(wkt=wkt)\n        source = SpatialReference()\n        source.ImportFromEPSG(source_srid)\n        dest = SpatialReference()\n        dest.ImportFromEPSG(target_srid)\n        if int(_gdal_ver[0]) >= 3 and ((int(_gdal_ver[1]) == 0 and int(_gdal_ver[2]) >= 4) or int(_gdal_ver[1]) > 0):\n            source.SetAxisMappingStrategy(0)\n            dest.SetAxisMappingStrategy(0)\n        g.Transform(CoordinateTransformation(source, dest))\n        projected_bbox = [str(x) for x in g.GetEnvelope()]\n        # Must be in the form : [x0, x1, y0, y1, EPSG:<target_srid>)\n        return tuple(\n            [float(projected_bbox[0]), float(projected_bbox[1]), float(projected_bbox[2]), float(projected_bbox[3])]\n        ) + (f\"EPSG:{target_srid}\",)\n\n    return native_bbox\n\n\ndef bounds_to_zoom_level(bounds, width, height):\n    WORLD_DIM = {\"height\": 256.0, \"width\": 256.0}\n    ZOOM_MAX = 21\n\n    def latRad(lat):\n        _sin = sin(lat * pi / HALF_ROTATION_DEG)\n        if abs(_sin) != 1.0:\n            radX2 = log((1.0 + _sin) / (1.0 - _sin)) / 2.0\n        else:\n            radX2 = log(1.0) / 2.0\n        return max(min(radX2, pi), -pi) / 2.0\n\n    def zoom(mapPx, worldPx, fraction):\n        try:\n            return floor(log(mapPx / worldPx / fraction) / log(2.0))\n        except Exception:\n            return 0\n\n    ne = [float(bounds[2]), float(bounds[3])]\n    sw = [float(bounds[0]), float(bounds[1])]\n    latFraction = (latRad(ne[1]) - latRad(sw[1])) / pi\n    lngDiff = ne[0] - sw[0]\n    lngFraction = ((lngDiff + FULL_ROTATION_DEG) if lngDiff < 0 else lngDiff) / FULL_ROTATION_DEG\n    latZoom = zoom(float(height), WORLD_DIM[\"height\"], latFraction)\n    lngZoom = zoom(float(width), WORLD_DIM[\"width\"], lngFraction)\n    # ratio = float(max(width, height)) / float(min(width, height))\n    # z_offset = 0 if ratio >= 2 else -1\n    z_offset = 0\n    zoom = int(max(latZoom, lngZoom) + z_offset)\n    zoom = 0 if zoom > ZOOM_MAX else zoom\n    return max(zoom, 0)\n\n\ndef llbbox_to_mercator(llbbox):\n    minlonlat = forward_mercator([llbbox[0], llbbox[2]])\n    maxlonlat = forward_mercator([llbbox[1], llbbox[3]])\n    return [minlonlat[0], minlonlat[1], maxlonlat[0], maxlonlat[1]]\n\n\ndef mercator_to_llbbox(bbox):\n    minlonlat = inverse_mercator([bbox[0], bbox[2]])\n    maxlonlat = inverse_mercator([bbox[1], bbox[3]])\n    return [minlonlat[0], minlonlat[1], maxlonlat[0], maxlonlat[1]]\n\n\ndef forward_mercator(lonlat):\n    \"\"\"\n    Given geographic coordinates, return a x,y tuple in spherical mercator.\n\n    If the lat value is out of range, -inf will be returned as the y value\n    \"\"\"\n    x = lonlat[0] * MAX_EXTENT / HALF_ROTATION_DEG\n    try:\n        # With data sets that only have one point the value of this\n        # expression becomes negative infinity. In order to continue,\n        # we wrap this in a try catch block.\n        n = tan((90 + lonlat[1]) * pi / FULL_ROTATION_DEG)\n    except ValueError:\n        n = 0\n    if n <= 0:\n        y = float(\"-inf\")\n    else:\n        y = log(n) / pi * MAX_EXTENT\n    return (x, y)\n\n\ndef inverse_mercator(xy):\n    \"\"\"\n    Given coordinates in spherical mercator, return a lon,lat tuple.\n    \"\"\"\n    lon = (xy[0] / MAX_EXTENT) * HALF_ROTATION_DEG\n    lat = (xy[1] / MAX_EXTENT) * HALF_ROTATION_DEG\n    lat = HALF_ROTATION_DEG / pi * (2 * atan(exp(lat * pi / HALF_ROTATION_DEG)) - pi / 2)\n    return (lon, lat)\n\n\ndef resolve_object(\n    request, model, query, permission=\"base.view_resourcebase\", user=None, permission_required=True, permission_msg=None\n):\n    \"\"\"Resolve an object using the provided query and check the optional\n    permission. Model views should wrap this function as a shortcut.\n\n    query - a dict to use for querying the model\n    permission - an optional permission to check\n    permission_required - if False, allow get methods to proceed\n    permission_msg - optional message to use in 403\n    \"\"\"\n    user = request.user if request and request.user else user\n    obj = get_object_or_404(model, **query)\n    obj_to_check = obj.get_self_resource()\n\n    from guardian.shortcuts import get_groups_with_perms\n    from geonode.groups.models import GroupProfile\n\n    groups = get_groups_with_perms(obj_to_check, attach_perms=True)\n\n    if obj_to_check.group and obj_to_check.group not in groups:\n        groups[obj_to_check.group] = obj_to_check.group\n\n    obj_group_managers = []\n    obj_group_members = []\n    if groups:\n        for group in groups:\n            try:\n                group_profile = GroupProfile.objects.get(slug=group.name)\n                managers = group_profile.get_managers()\n                if managers:\n                    for manager in managers:\n                        if manager not in obj_group_managers and not manager.is_superuser:\n                            obj_group_managers.append(manager)\n                if group_profile.user_is_member(user) and user not in obj_group_members:\n                    obj_group_members.append(user)\n            except GroupProfile.DoesNotExist:\n                pass\n\n    allowed = True\n    if permission.split(\".\")[-1] in [\"change_dataset_data\", \"change_dataset_style\"]:\n        if obj.__class__.__name__ == \"Dataset\":\n            obj_to_check = obj\n    if permission:\n        if permission_required or request.method != \"GET\":\n            if user in obj_group_managers:\n                allowed = True\n            else:\n                allowed = user.has_perm(permission, obj_to_check)\n    if not allowed:\n        mesg = permission_msg or _(\"Permission Denied\")\n        raise PermissionDenied(mesg)\n    return obj\n\n\ndef json_response(body=None, errors=None, url=None, redirect_to=None, exception=None, content_type=None, status=None):\n    \"\"\"Create a proper JSON response. If body is provided, this is the response.\n    If errors is not None, the response is a success/errors json object.\n    If redirect_to is not None, the response is a success=True, redirect_to object\n    If the exception is provided, it will be logged. If body is a string, the\n    exception message will be used as a format option to that string and the\n    result will be a success=False, errors = body % exception\n    \"\"\"\n    if isinstance(body, HttpResponse):\n        return body\n    if content_type is None:\n        content_type = \"application/json\"\n    if errors:\n        if isinstance(errors, str):\n            errors = [errors]\n        body = {\"success\": False, \"errors\": errors}\n    elif redirect_to:\n        body = {\"success\": True, \"redirect_to\": redirect_to}\n    elif url:\n        body = {\"success\": True, \"url\": url}\n    elif exception:\n        if isinstance(exception, APIException):\n            raise exception\n        if body is None:\n            body = f\"Unexpected exception {exception}\"\n        else:\n            body = body % exception\n        body = {\"success\": False, \"errors\": [body]}\n        raise GeneralUploadException(detail=body)\n    elif body:\n        pass\n    else:\n        raise Exception(\"must call with body, errors or redirect_to\")\n\n    if status is None:\n        status = 200\n\n    if not isinstance(body, str):\n        try:\n            body = json.dumps(body, cls=DjangoJSONEncoder)\n        except Exception:\n            body = str(body)\n    return HttpResponse(body, content_type=content_type, status=status)\n\n\ndef num_encode(n):\n    if n < 0:\n        return SIGN_CHARACTER + num_encode(-n)\n    s = []\n    while True:\n        n, r = divmod(n, BASE)\n        s.append(ALPHABET[r])\n        if n == 0:\n            break\n    return \"\".join(reversed(s))\n\n\ndef num_decode(s):\n    if s[0] == SIGN_CHARACTER:\n        return -num_decode(s[1:])\n    n = 0\n    for c in s:\n        n = n * BASE + ALPHABET_REVERSE[c]\n    return n\n\n\ndef format_urls(a, values):\n    b = []\n    for i in a:\n        j = i.copy()\n        try:\n            j[\"url\"] = str(j[\"url\"]).format(**values)\n        except KeyError:\n            j[\"url\"] = None\n        b.append(j)\n    return b\n\n\ndef build_abstract(resourcebase, url=None, includeURL=True):\n    if resourcebase.abstract and url and includeURL:\n        return f\"{resourcebase.abstract} -- [{url}]({url})\"\n    else:\n        return resourcebase.abstract\n\n\ndef build_caveats(resourcebase):\n    caveats = []\n    if resourcebase.maintenance_frequency:\n        caveats.append(resourcebase.maintenance_frequency_title())\n    if resourcebase.license:\n        caveats.append(resourcebase.license_verbose)\n    if resourcebase.data_quality_statement:\n        caveats.append(resourcebase.data_quality_statement)\n    if len(caveats) > 0:\n        return f\"- {'%0A- '.join(caveats)}\"\n    else:\n        return \"\"\n\n\ndef build_social_links(request, resourcebase):\n    netschema = \"https\" if request.is_secure() else \"http\"\n    host = request.get_host()\n    path = request.get_full_path()\n    social_url = f\"{netschema}://{host}{path}\"\n    # Don't use datetime strftime() because it requires year >= 1900\n    # see\n    # https://docs.python.org/2/library/datetime.html#strftime-strptime-behavior\n    date = \"{0.month:02d}/{0.day:02d}/{0.year:4d}\".format(resourcebase.date) if resourcebase.date else None\n    abstract = build_abstract(resourcebase, url=social_url, includeURL=True)\n    caveats = build_caveats(resourcebase)\n    hashtags = \",\".join(getattr(settings, \"TWITTER_HASHTAGS\", []))\n    return format_urls(\n        settings.SOCIAL_ORIGINS,\n        {\n            \"name\": resourcebase.title,\n            \"date\": date,\n            \"abstract\": abstract,\n            \"caveats\": caveats,\n            \"hashtags\": hashtags,\n            \"url\": social_url,\n        },\n    )\n\n\ndef check_shp_columnnames(layer):\n    \"\"\"Check if shapefile for a given layer has valid column names.\n    If not, try to fix column names and warn the user\n    \"\"\"\n    # TODO we may add in a better location this method\n    inShapefile = \"\"\n    for f in layer.upload_session.layerfile_set.all():\n        if os.path.splitext(f.file.name)[1] == \".shp\":\n            inShapefile = f.file.path\n    if inShapefile:\n        return fixup_shp_columnnames(inShapefile, layer.charset)\n\n\ndef clone_shp_field_defn(srcFieldDefn, name):\n    \"\"\"\n    Clone an existing ogr.FieldDefn with a new name\n    \"\"\"\n    dstFieldDefn = ogr.FieldDefn(name, srcFieldDefn.GetType())\n    dstFieldDefn.SetWidth(srcFieldDefn.GetWidth())\n    dstFieldDefn.SetPrecision(srcFieldDefn.GetPrecision())\n\n    return dstFieldDefn\n\n\ndef rename_shp_columnnames(inLayer, fieldnames):\n    \"\"\"\n    Rename columns in a layer to those specified in the given mapping\n    \"\"\"\n    inLayerDefn = inLayer.GetLayerDefn()\n\n    for i in range(inLayerDefn.GetFieldCount()):\n        srcFieldDefn = inLayerDefn.GetFieldDefn(i)\n        dstFieldName = fieldnames.get(srcFieldDefn.GetName())\n\n        if dstFieldName is not None:\n            dstFieldDefn = clone_shp_field_defn(srcFieldDefn, dstFieldName)\n            inLayer.AlterFieldDefn(i, dstFieldDefn, ogr.ALTER_NAME_FLAG)\n\n\ndef fixup_shp_columnnames(inShapefile, charset, tempdir=None):\n    \"\"\"Try to fix column names and warn the user\"\"\"\n    charset = charset if charset and \"undefined\" not in charset else \"UTF-8\"\n    if not tempdir:\n        tempdir = mkdtemp()\n\n    if is_zipfile(inShapefile):\n        inShapefile = unzip_file(inShapefile, \".shp\", tempdir=tempdir)\n\n    inDriver = ogr.GetDriverByName(\"ESRI Shapefile\")\n    try:\n        inDataSource = inDriver.Open(inShapefile, 1)\n    except Exception:\n        tb = traceback.format_exc()\n        logger.debug(tb)\n        inDataSource = None\n\n    if inDataSource is None:\n        logger.debug(f\"Could not open {inShapefile}\")\n        return False, None, None\n    else:\n        inLayer = inDataSource.GetLayer()\n\n    # TODO we may need to improve this regexp\n    # first character must be any letter or \"_\"\n    # following characters can be any letter, number, \"#\", \":\"\n    regex = r\"^[a-zA-Z,_][a-zA-Z,_#:\\d]*$\"\n    a = re.compile(regex)\n    regex_first_char = r\"[a-zA-Z,_]{1}\"\n    b = re.compile(regex_first_char)\n    inLayerDefn = inLayer.GetLayerDefn()\n\n    list_col_original = []\n    list_col = {}\n\n    for i in range(inLayerDefn.GetFieldCount()):\n        try:\n            field_name = inLayerDefn.GetFieldDefn(i).GetName()\n            if a.match(field_name):\n                list_col_original.append(field_name)\n        except Exception as e:\n            logger.exception(e)\n            return True, None, None\n\n    for i in range(inLayerDefn.GetFieldCount()):\n        try:\n            field_name = inLayerDefn.GetFieldDefn(i).GetName()\n            if not a.match(field_name):\n                # once the field_name contains Chinese, to use slugify_zh\n                if any(\"\\u4e00\" <= ch <= \"\\u9fff\" for ch in field_name):\n                    new_field_name = slugify_zh(field_name, separator=\"_\")\n                else:\n                    new_field_name = slugify(field_name)\n                if not b.match(new_field_name):\n                    new_field_name = f\"_{new_field_name}\"\n                j = 0\n                while new_field_name in list_col_original or new_field_name in list_col.values():\n                    if j == 0:\n                        new_field_name += \"_0\"\n                    if new_field_name.endswith(f\"_{str(j)}\"):\n                        j += 1\n                        new_field_name = f\"{new_field_name[:-2]}_{str(j)}\"\n                if field_name != new_field_name:\n                    list_col[field_name] = new_field_name\n        except Exception as e:\n            logger.exception(e)\n            return True, None, None\n\n    if len(list_col) == 0:\n        return True, None, None\n    else:\n        try:\n            rename_shp_columnnames(inLayer, list_col)\n            inDataSource.SyncToDisk()\n            inDataSource.Destroy()\n        except Exception as e:\n            logger.exception(e)\n            raise GeoNodeException(f\"Could not decode SHAPEFILE attributes by using the specified charset '{charset}'.\")\n    return True, None, list_col\n\n\ndef id_to_obj(id_):\n    if id_ == id_none:\n        return None\n\n    for obj in gc.get_objects():\n        if id(obj) == id_:\n            return obj\n    raise Exception(\"Not found\")\n\n\ndef printsignals():\n    for signalname in signalnames:\n        logger.debug(f\"SIGNALNAME: {signalname}\")\n        signaltype = getattr(models.signals, signalname)\n        signals = signaltype.receivers[:]\n        for signal in signals:\n            logger.debug(signal)\n\n\nclass DisableDjangoSignals:\n    \"\"\"\n    Python3 class temporarily disabling django signals on model creation.\n\n    usage:\n    with DisableDjangoSignals():\n        # do some fancy stuff here\n    \"\"\"\n\n    def __init__(self, disabled_signals=None, skip=False):\n        self.skip = skip\n        self.stashed_signals = defaultdict(list)\n        self.disabled_signals = disabled_signals or [\n            signals.pre_init,\n            signals.post_init,\n            signals.pre_save,\n            signals.post_save,\n            signals.pre_delete,\n            signals.post_delete,\n            signals.pre_migrate,\n            signals.post_migrate,\n            signals.m2m_changed,\n        ]\n\n    def __enter__(self):\n        if not self.skip:\n            for signal in self.disabled_signals:\n                self.disconnect(signal)\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if not self.skip:\n            for signal in list(self.stashed_signals):\n                self.reconnect(signal)\n\n    def disconnect(self, signal):\n        self.stashed_signals[signal] = signal.receivers\n        signal.receivers = []\n\n    def reconnect(self, signal):\n        signal.receivers = self.stashed_signals.get(signal, [])\n        del self.stashed_signals[signal]\n\n\ndef run_subprocess(*cmd, **kwargs):\n    p = subprocess.Popen(\" \".join(cmd), stdout=subprocess.PIPE, stderr=subprocess.PIPE, **kwargs)\n    stdout = StringIO()\n    stderr = StringIO()\n    buff_size = 1024\n    while p.poll() is None:\n        inr = [p.stdout.fileno(), p.stderr.fileno()]\n        inw = []\n        rlist, wlist, xlist = select.select(inr, inw, [])\n\n        for r in rlist:\n            if r == p.stdout.fileno():\n                readfrom = p.stdout\n                readto = stdout\n            else:\n                readfrom = p.stderr\n                readto = stderr\n            readto.write(readfrom.read(buff_size))\n\n        for w in wlist:\n            w.write(\"\")\n\n    return p.returncode, stdout.getvalue(), stderr.getvalue()\n\n\ndef parse_datetime(value):\n    for patt in settings.DATETIME_INPUT_FORMATS:\n        try:\n            if isinstance(value, dict):\n                value_obj = value[\"$\"] if \"$\" in value else value[\"content\"]\n                return datetime.datetime.strptime(value_obj, patt)\n            else:\n                return datetime.datetime.strptime(value, patt)\n        except Exception:\n            tb = traceback.format_exc()\n            logger.debug(tb)\n    raise ValueError(f\"Invalid datetime input: {value}\")\n\n\ndef _convert_sql_params(cur, query):\n    # sqlite driver doesn't support %(key)s notation,\n    # use :key instead.\n    if cur.db.vendor in (\n        \"sqlite\",\n        \"sqlite3\",\n        \"spatialite\",\n    ):\n        return SQL_PARAMS_RE.sub(r\":\\1\", query)\n    return query\n\n\n@transaction.atomic\ndef raw_sql(query, params=None, ret=True):\n    \"\"\"\n    Execute raw query\n    param ret=True returns data from cursor as iterator\n    \"\"\"\n    with connection.cursor() as c:\n        query = _convert_sql_params(c, query)\n        c.execute(query, params)\n        if ret:\n            desc = [r[0] for r in c.description]\n            for row in c:\n                yield dict(zip(desc, row))\n\n\ndef get_client_ip(request):\n    x_forwarded_for = request.META.get(\"HTTP_X_FORWARDED_FOR\")\n    if x_forwarded_for:\n        ip = x_forwarded_for.split(\",\")[0]\n    else:\n        ip = request.META.get(\"REMOTE_ADDR\")\n    return ip\n\n\ndef get_client_host(request):\n    hostname = None\n    http_host = request.META.get(\"HTTP_HOST\")\n    if http_host:\n        hostname = http_host.split(\":\")[0]\n    return hostname\n\n\ndef check_ogc_backend(backend_package):\n    \"\"\"Check that geonode use a particular OGC Backend integration\n\n    :param backend_package: django app of backend to use\n    :type backend_package: str\n\n    :return: bool\n    :rtype: bool\n    \"\"\"\n    ogc_conf = settings.OGC_SERVER[\"default\"]\n    is_configured = ogc_conf.get(\"BACKEND\") == backend_package\n\n    # Check environment variables\n    _backend = os.environ.get(\"BACKEND\", None)\n    if _backend:\n        return backend_package == _backend and is_configured\n\n    # Check exists in INSTALLED_APPS\n    try:\n        in_installed_apps = backend_package in settings.INSTALLED_APPS\n        return in_installed_apps and is_configured\n    except Exception:\n        pass\n    return False\n\n\nclass HttpClient:\n    def __init__(self):\n        self.timeout = 5\n        self.retries = 1\n        self.pool_maxsize = 10\n        self.backoff_factor = 0.3\n        self.pool_connections = 10\n        self.status_forcelist = (500, 502, 503, 504)\n        self.username = \"admin\"\n        self.password = \"admin\"\n        if check_ogc_backend(geoserver.BACKEND_PACKAGE):\n            ogc_server_settings = settings.OGC_SERVER[\"default\"]\n            self.timeout = ogc_server_settings.get(\"TIMEOUT\", 5)\n            self.retries = ogc_server_settings.get(\"MAX_RETRIES\", 1)\n            self.backoff_factor = ogc_server_settings.get(\"BACKOFF_FACTOR\", 0.3)\n            self.pool_maxsize = ogc_server_settings.get(\"POOL_MAXSIZE\", 10)\n            self.pool_connections = ogc_server_settings.get(\"POOL_CONNECTIONS\", 10)\n            self.username = ogc_server_settings.get(\"USER\", \"admin\")\n            self.password = ogc_server_settings.get(\"PASSWORD\", \"geoserver\")\n\n    def request(\n        self,\n        url,\n        method=\"GET\",\n        data=None,\n        headers={},\n        stream=False,\n        timeout=None,\n        retries=None,\n        user=None,\n        verify=False,\n    ):\n        if (\n            (user or self.username != \"admin\")\n            and check_ogc_backend(geoserver.BACKEND_PACKAGE)\n            and \"Authorization\" not in headers\n        ):\n            if connection.cursor().db.vendor not in (\"sqlite\", \"sqlite3\", \"spatialite\"):\n                try:\n                    if user and isinstance(user, str):\n                        user = get_user_model().objects.get(username=user)\n                    _u = user or get_user_model().objects.get(username=self.username)\n                    access_token = get_or_create_token(_u)\n                    if access_token and not access_token.is_expired():\n                        headers[\"Authorization\"] = f\"Bearer {access_token.token}\"\n                except Exception:\n                    tb = traceback.format_exc()\n                    logger.debug(tb)\n            elif user == self.username:\n                valid_uname_pw = base64.b64encode(f\"{self.username}:{self.password}\".encode()).decode()\n                headers[\"Authorization\"] = f\"Basic {valid_uname_pw}\"\n\n        headers[\"User-Agent\"] = \"GeoNode\"\n        response = None\n        content = None\n        session = requests.Session()\n        retry = Retry(\n            total=retries or self.retries,\n            read=retries or self.retries,\n            connect=retries or self.retries,\n            backoff_factor=self.backoff_factor,\n            status_forcelist=self.status_forcelist,\n        )\n        adapter = requests.adapters.HTTPAdapter(\n            max_retries=retry, pool_maxsize=self.pool_maxsize, pool_connections=self.pool_connections\n        )\n        scheme = urlsplit(url).scheme\n        session.mount(f\"{scheme}://\", adapter)\n        session.verify = False\n        action = getattr(session, method.lower(), None)\n        if action:\n            _req_tout = timeout or self.timeout\n            try:\n                response = action(url=url, data=data, headers=headers, timeout=_req_tout, stream=stream, verify=verify)\n            except (\n                requests.exceptions.ConnectTimeout,\n                requests.exceptions.RequestException,\n                ValueError,\n                RetryError,\n            ) as e:\n                msg = f\"Request exception [{e}] - TOUT [{_req_tout}] to URL: {url} - headers: {headers}\"\n                logger.exception(Exception(msg))\n                response = None\n                content = str(e)\n        else:\n            response = session.get(url, headers=headers, timeout=self.timeout)\n        if response:\n            try:\n                content = ensure_string(response.content) if not stream else response.raw\n            except Exception as e:\n                content = str(e)\n\n        return (response, content)\n\n    def get(self, url, data=None, headers={}, stream=False, timeout=None, user=None, verify=False):\n        return self.request(\n            url,\n            method=\"GET\",\n            data=data,\n            headers=headers,\n            timeout=timeout or self.timeout,\n            stream=stream,\n            user=user,\n            verify=verify,\n        )\n\n    def post(self, url, data=None, headers={}, stream=False, timeout=None, user=None, verify=False):\n        return self.request(\n            url,\n            method=\"POST\",\n            data=data,\n            headers=headers,\n            timeout=timeout or self.timeout,\n            stream=stream,\n            user=user,\n            verify=verify,\n        )\n\n\nhttp_client = HttpClient()\n\n\ndef get_dir_time_suffix():\n    \"\"\"Returns the name of a folder with the 'now' time as suffix\"\"\"\n    dirfmt = \"%4d-%02d-%02d_%02d%02d%02d\"\n    now = time.localtime()[0:6]\n    dirname = dirfmt % now\n\n    return dirname\n\n\ndef zip_dir(basedir, archivename):\n    assert os.path.isdir(basedir)\n    with closing(ZipFile(archivename, \"w\", ZIP_DEFLATED, allowZip64=True)) as z:\n        for root, dirs, files in os.walk(basedir):\n            # NOTE: ignore empty directories\n            for fn in files:\n                absfn = os.path.join(root, fn)\n                zfn = absfn[len(basedir) + len(os.sep) :]  # XXX: relative path\n                z.write(absfn, zfn)\n\n\ndef copy_tree(src, dst, symlinks=False, ignore=None):\n    try:\n        for item in os.listdir(src):\n            s = os.path.join(src, item)\n            d = os.path.join(dst, item)\n            if os.path.isdir(s):\n                if os.path.exists(d):\n                    try:\n                        os.remove(d)\n                    except Exception:\n                        shutil.rmtree(d, ignore_errors=True)\n                try:\n                    shutil.copytree(s, d, symlinks=symlinks, ignore=ignore)\n                except Exception:\n                    pass\n            else:\n                try:\n                    if ignore and s in ignore(dst, [s]):\n                        return\n                    shutil.copy2(s, d)\n                except Exception:\n                    pass\n    except Exception:\n        traceback.print_exc()\n\n\ndef extract_archive(zip_file, dst):\n    target_folder = os.path.join(dst, os.path.splitext(os.path.basename(zip_file))[0])\n    if not os.path.exists(target_folder):\n        os.makedirs(target_folder, exist_ok=True)\n\n    with ZipFile(zip_file, \"r\", allowZip64=True) as z:\n        z.extractall(target_folder)\n\n    return target_folder\n\n\ndef chmod_tree(dst, permissions=0o777):\n    for dirpath, dirnames, filenames in os.walk(dst):\n        for filename in filenames:\n            path = os.path.join(dirpath, filename)\n            os.chmod(path, permissions)\n            status = os.stat(path)\n            if oct(status.st_mode & 0o777) != str(oct(permissions)):\n                raise Exception(f\"Could not update permissions of {path}\")\n\n        for dirname in dirnames:\n            path = os.path.join(dirpath, dirname)\n            os.chmod(path, permissions)\n            status = os.stat(path)\n            if oct(status.st_mode & 0o777) != str(oct(permissions)):\n                raise Exception(f\"Could not update permissions of {path}\")\n\n\ndef slugify_zh(text, separator=\"_\"):\n    \"\"\"\n    Make a slug from the given text, which is simplified from slugify.\n    It remove the other args and do not convert Chinese into Pinyin\n    :param text (str): initial text\n    :param separator (str): separator between words\n    :return (str):\n    \"\"\"\n\n    QUOTE_PATTERN = re.compile(r\"[\\']+\")\n    ALLOWED_CHARS_PATTERN = re.compile(\"[^\\u4e00-\\u9fa5a-z0-9]+\")\n    DUPLICATE_DASH_PATTERN = re.compile(\"-{2,}\")\n    NUMBERS_PATTERN = re.compile(r\"(?<=\\d),(?=\\d)\")\n    DEFAULT_SEPARATOR = \"-\"\n\n    # if not isinstance(text, types.UnicodeType):\n    #    text = unicode(text, 'utf-8', 'ignore')\n    # replace quotes with dashes - pre-process\n    text = QUOTE_PATTERN.sub(DEFAULT_SEPARATOR, text)\n    # make the text lowercase\n    text = text.lower()\n    # remove generated quotes -- post-process\n    text = QUOTE_PATTERN.sub(\"\", text)\n    # cleanup numbers\n    text = NUMBERS_PATTERN.sub(\"\", text)\n    # replace all other unwanted characters\n    text = re.sub(ALLOWED_CHARS_PATTERN, DEFAULT_SEPARATOR, text)\n    # remove redundant\n    text = re.sub(DUPLICATE_DASH_PATTERN, DEFAULT_SEPARATOR, text).strip(DEFAULT_SEPARATOR)\n    if separator != DEFAULT_SEPARATOR:\n        text = text.replace(DEFAULT_SEPARATOR, separator)\n    return text\n\n\ndef get_legend_url(\n    instance,\n    style_name,\n    /,\n    service_url=None,\n    dataset_name=None,\n    version=\"1.3.0\",\n    sld_version=\"1.1.0\",\n    width=20,\n    height=20,\n    params=None,\n):\n    from geonode.geoserver.helpers import ogc_server_settings\n\n    _service_url = service_url or f\"{ogc_server_settings.PUBLIC_LOCATION}ows\"\n    _dataset_name = dataset_name or instance.alternate\n    _params = f\"&{params}\" if params else \"\"\n    return (\n        f\"{_service_url}?\"\n        f\"service=WMS&request=GetLegendGraphic&format=image/png&WIDTH={width}&HEIGHT={height}&\"\n        f\"LAYER={_dataset_name}&STYLE={style_name}&version={version}&\"\n        f\"sld_version={sld_version}&legend_options=fontAntiAliasing:true;fontSize:12;forceLabels:on{_params}\"\n    )\n\n\ndef set_resource_default_links(instance, layer, prune=False, **kwargs):\n    from geonode.base.models import Link\n    from django.urls import reverse\n    from django.utils.translation import ugettext\n    from geonode.layers.models import Dataset\n    from geonode.documents.models import Document\n\n    # Prune old links\n    if prune:\n        logger.debug(\" -- Resource Links[Prune old links]...\")\n        _def_link_types = (\"data\", \"image\", \"original\", \"html\", \"OGC:WMS\", \"OGC:WFS\", \"OGC:WCS\")\n        Link.objects.filter(resource=instance.resourcebase_ptr, link_type__in=_def_link_types).delete()\n        logger.debug(\" -- Resource Links[Prune old links]...done!\")\n\n    if check_ogc_backend(geoserver.BACKEND_PACKAGE):\n        from geonode.geoserver.ows import wcs_links, wfs_links, wms_links\n        from geonode.geoserver.helpers import ogc_server_settings, gs_catalog\n\n        # Compute parameters for the new links\n        logger.debug(\" -- Resource Links[Compute parameters for the new links]...\")\n        height = 550\n        width = 550\n\n        # Parse Dataset BBOX and SRID\n        bbox = None\n        srid = instance.srid if instance.srid else getattr(settings, \"DEFAULT_MAP_CRS\", \"EPSG:4326\")\n        if not prune and instance.srid and instance.bbox_polygon:\n            bbox = instance.bbox_string\n        else:\n            try:\n                gs_resource = gs_catalog.get_resource(\n                    name=instance.name, store=instance.store, workspace=instance.workspace\n                )\n                if not gs_resource:\n                    gs_resource = gs_catalog.get_resource(name=instance.name, workspace=instance.workspace)\n                if not gs_resource:\n                    gs_resource = gs_catalog.get_resource(name=instance.name)\n\n                if gs_resource:\n                    srid = gs_resource.projection\n                    bbox = gs_resource.native_bbox\n                    ll_bbox = gs_resource.latlon_bbox\n                    try:\n                        instance.set_bbox_polygon([bbox[0], bbox[2], bbox[1], bbox[3]], srid)\n                    except GeoNodeException as e:\n                        if not ll_bbox:\n                            raise\n                        else:\n                            logger.exception(e)\n                            instance.srid = \"EPSG:4326\"\n                    instance.set_ll_bbox_polygon([ll_bbox[0], ll_bbox[2], ll_bbox[1], ll_bbox[3]])\n                    if instance.srid:\n                        instance.srid_url = (\n                            f\"http://www.spatialreference.org/ref/{instance.srid.replace(':', '/').lower()}/\"\n                        )\n                    elif instance.bbox_polygon is not None:\n                        # Guessing 'EPSG:4326' by default\n                        instance.srid = \"EPSG:4326\"\n                    else:\n                        raise GeoNodeException(_(\"Invalid Projection. Dataset is missing CRS!\"))\n                    dx = float(bbox[1]) - float(bbox[0])\n                    dy = float(bbox[3]) - float(bbox[2])\n                    dataAspect = 1 if dy == 0 else dx / dy\n                    width = int(height * dataAspect)\n                    # Rewriting BBOX as a plain string\n                    bbox = \",\".join(str(x) for x in [bbox[0], bbox[2], bbox[1], bbox[3]])\n                else:\n                    bbox = instance.bbox_string\n            except Exception as e:\n                logger.exception(e)\n                bbox = instance.bbox_string\n\n        # Create Raw Data download link\n        if settings.DISPLAY_ORIGINAL_DATASET_LINK:\n            logger.debug(\" -- Resource Links[Create Raw Data download link]...\")\n            if isinstance(instance, Dataset):\n                download_url = build_absolute_uri(reverse(\"dataset_download\", args=(instance.alternate,)))\n            elif isinstance(instance, Document):\n                download_url = build_absolute_uri(reverse(\"document_download\", args=(instance.id,)))\n            else:\n                download_url = None\n\n            while Link.objects.filter(resource=instance.resourcebase_ptr, link_type=\"original\").exists():\n                Link.objects.filter(resource=instance.resourcebase_ptr, link_type=\"original\").delete()\n            Link.objects.update_or_create(\n                resource=instance.resourcebase_ptr,\n                url=download_url,\n                defaults=dict(\n                    extension=\"zip\",\n                    name=\"Original Dataset\",\n                    mime=\"application/octet-stream\",\n                    link_type=\"original\",\n                ),\n            )\n            logger.debug(\" -- Resource Links[Create Raw Data download link]...done!\")\n        else:\n            Link.objects.filter(resource=instance.resourcebase_ptr, name=\"Original Dataset\").delete()\n\n        # Set download links for WMS, WCS or WFS and KML\n        logger.debug(\" -- Resource Links[Set download links for WMS, WCS or WFS and KML]...\")\n        instance_ows_url = f\"{instance.ows_url}?\" if instance.ows_url else f\"{ogc_server_settings.public_url}ows?\"\n        links = wms_links(instance_ows_url, instance.alternate, bbox, srid, height, width)\n\n        for ext, name, mime, wms_url in links:\n            try:\n                Link.objects.update_or_create(\n                    resource=instance.resourcebase_ptr,\n                    name=ugettext(name),\n                    defaults=dict(\n                        extension=ext,\n                        url=wms_url,\n                        mime=mime,\n                        link_type=\"image\",\n                    ),\n                )\n            except Link.MultipleObjectsReturned:\n                _d = dict(extension=ext, url=wms_url, mime=mime, link_type=\"image\")\n                Link.objects.filter(resource=instance.resourcebase_ptr, name=ugettext(name), link_type=\"image\").update(\n                    **_d\n                )\n\n        if instance.subtype == \"vector\":\n            links = wfs_links(\n                instance_ows_url,\n                instance.alternate,\n                bbox=None,  # bbox filter should be set at runtime otherwise conflicting with CQL\n                srid=srid,\n            )\n            for ext, name, mime, wfs_url in links:\n                if mime == \"SHAPE-ZIP\":\n                    name = \"Zipped Shapefile\"\n                if (\n                    Link.objects.filter(\n                        resource=instance.resourcebase_ptr, url=wfs_url, name=name, link_type=\"data\"\n                    ).count()\n                    < 2\n                ):\n                    Link.objects.update_or_create(\n                        resource=instance.resourcebase_ptr,\n                        url=wfs_url,\n                        name=name,\n                        link_type=\"data\",\n                        defaults=dict(\n                            extension=ext,\n                            mime=mime,\n                        ),\n                    )\n\n        elif instance.subtype == \"raster\":\n            \"\"\"\n            Going to create the WCS GetCoverage Default download links.\n            By providing 'None' bbox and srid, we are going to ask to the WCS to\n            skip subsetting, i.e. output the whole coverage in the netive SRS.\n\n            Notice that the \"wcs_links\" method also generates 1 default \"outputFormat\":\n             - \"geotiff\"; GeoTIFF which will be compressed and tiled by passing to the WCS the default query params compression='DEFLATE' and tile_size=512\n            \"\"\"\n            links = wcs_links(instance_ows_url, instance.alternate)\n            for ext, name, mime, wcs_url in links:\n                if (\n                    Link.objects.filter(\n                        resource=instance.resourcebase_ptr, url=wcs_url, name=name, link_type=\"data\"\n                    ).count()\n                    < 2\n                ):\n                    Link.objects.update_or_create(\n                        resource=instance.resourcebase_ptr,\n                        url=wcs_url,\n                        name=name,\n                        link_type=\"data\",\n                        defaults=dict(\n                            extension=ext,\n                            mime=mime,\n                        ),\n                    )\n\n        site_url = settings.SITEURL.rstrip(\"/\") if settings.SITEURL.startswith(\"http\") else settings.SITEURL\n        html_link_url = f\"{site_url}{instance.get_absolute_url()}\"\n\n        if (\n            Link.objects.filter(\n                resource=instance.resourcebase_ptr, url=html_link_url, name=instance.alternate, link_type=\"html\"\n            ).count()\n            < 2\n        ):\n            Link.objects.update_or_create(\n                resource=instance.resourcebase_ptr,\n                url=html_link_url,\n                name=instance.alternate or instance.name,\n                link_type=\"html\",\n                defaults=dict(\n                    extension=\"html\",\n                    mime=\"text/html\",\n                ),\n            )\n        logger.debug(\" -- Resource Links[Set download links for WMS, WCS or WFS and KML]...done!\")\n\n        # Legend link\n        logger.debug(\" -- Resource Links[Legend link]...\")\n        try:\n            if instance.subtype not in [\"tileStore\", \"remote\"]:\n                for style in set(\n                    list(instance.styles.all())\n                    + [\n                        instance.default_style,\n                    ]\n                ):\n                    if style:\n                        style_name = os.path.basename(urlparse(style.sld_url).path).split(\".\")[0]\n                        legend_url = get_legend_url(instance, style_name)\n                        if Link.objects.filter(resource=instance.resourcebase_ptr, url=legend_url).count() < 2:\n                            Link.objects.update_or_create(\n                                resource=instance.resourcebase_ptr,\n                                name=\"Legend\",\n                                url=legend_url,\n                                defaults=dict(\n                                    extension=\"png\",\n                                    url=legend_url,\n                                    mime=\"image/png\",\n                                    link_type=\"image\",\n                                ),\n                            )\n            else:\n                from geonode.services.serviceprocessors import get_service_handler\n\n                handler = get_service_handler(\n                    instance.remote_service.service_url, service_type=instance.remote_service.type\n                )\n                if handler and hasattr(handler, \"_create_dataset_legend_link\"):\n                    handler._create_dataset_legend_link(instance)\n\n            logger.debug(\" -- Resource Links[Legend link]...done!\")\n        except Exception as e:\n            logger.debug(f\" -- Resource Links[Legend link]...error: {e}\")\n\n        # Thumbnail link\n        if instance.get_thumbnail_url():\n            logger.debug(\" -- Resource Links[Thumbnail link]...\")\n            if (\n                Link.objects.filter(\n                    resource=instance.resourcebase_ptr, url=instance.get_thumbnail_url(), name=\"Thumbnail\"\n                ).count()\n                < 2\n            ):\n                Link.objects.update_or_create(\n                    resource=instance.resourcebase_ptr,\n                    url=instance.get_thumbnail_url(),\n                    name=\"Thumbnail\",\n                    defaults=dict(\n                        extension=\"png\",\n                        mime=\"image/png\",\n                        link_type=\"image\",\n                    ),\n                )\n            logger.debug(\" -- Resource Links[Thumbnail link]...done!\")\n\n        logger.debug(\" -- Resource Links[OWS Links]...\")\n        try:\n            if (\n                not hasattr(instance.get_real_instance(), \"ptype\")\n                or instance.get_real_instance().ptype == GXP_PTYPES[\"WMS\"]\n            ):\n                ogc_wms_url = instance.ows_url or urljoin(ogc_server_settings.public_url, \"ows\")\n                ogc_wms_name = f\"OGC WMS: {instance.workspace} Service\"\n                if (\n                    Link.objects.filter(resource=instance.resourcebase_ptr, name=ogc_wms_name, url=ogc_wms_url).count()\n                    < 2\n                ):\n                    Link.objects.get_or_create(\n                        resource=instance.resourcebase_ptr,\n                        url=ogc_wms_url,\n                        name=ogc_wms_name,\n                        defaults=dict(\n                            extension=\"html\",\n                            url=ogc_wms_url,\n                            mime=\"text/html\",\n                            link_type=\"OGC:WMS\",\n                        ),\n                    )\n\n                if instance.subtype == \"vector\":\n                    ogc_wfs_url = instance.ows_url or urljoin(ogc_server_settings.public_url, \"ows\")\n                    ogc_wfs_name = f\"OGC WFS: {instance.workspace} Service\"\n                    if (\n                        Link.objects.filter(\n                            resource=instance.resourcebase_ptr, name=ogc_wfs_name, url=ogc_wfs_url\n                        ).count()\n                        < 2\n                    ):\n                        Link.objects.get_or_create(\n                            resource=instance.resourcebase_ptr,\n                            url=ogc_wfs_url,\n                            name=ogc_wfs_name,\n                            defaults=dict(\n                                extension=\"html\",\n                                url=ogc_wfs_url,\n                                mime=\"text/html\",\n                                link_type=\"OGC:WFS\",\n                            ),\n                        )\n\n                if instance.subtype == \"raster\":\n                    ogc_wcs_url = instance.ows_url or urljoin(ogc_server_settings.public_url, \"ows\")\n                    ogc_wcs_name = f\"OGC WCS: {instance.workspace} Service\"\n                    if (\n                        Link.objects.filter(\n                            resource=instance.resourcebase_ptr, name=ogc_wcs_name, url=ogc_wcs_url\n                        ).count()\n                        < 2\n                    ):\n                        Link.objects.get_or_create(\n                            resource=instance.resourcebase_ptr,\n                            url=ogc_wcs_url,\n                            name=ogc_wcs_name,\n                            defaults=dict(\n                                extension=\"html\",\n                                url=ogc_wcs_url,\n                                mime=\"text/html\",\n                                link_type=\"OGC:WCS\",\n                            ),\n                        )\n\n            elif hasattr(instance.get_real_instance(), \"ptype\") and instance.get_real_instance().ptype:\n                ptype_link = dict((v, k) for k, v in GXP_PTYPES.items()).get(instance.get_real_instance().ptype)\n                ptype_link_name = get_available_service_types().get(ptype_link)\n                ptype_link_url = instance.ows_url\n                if (\n                    Link.objects.filter(\n                        resource=instance.resourcebase_ptr, name=ptype_link_name, url=ptype_link_url\n                    ).count()\n                    < 2\n                ):\n                    Link.objects.get_or_create(\n                        resource=instance.resourcebase_ptr,\n                        url=ptype_link_url,\n                        name=ptype_link_name,\n                        defaults=dict(\n                            extension=\"html\",\n                            url=ptype_link_url,\n                            mime=\"text/html\",\n                            link_type=\"image\",\n                        ),\n                    )\n            logger.debug(\" -- Resource Links[OWS Links]...done!\")\n        except Exception as e:\n            logger.error(\" -- Resource Links[OWS Links]...error!\")\n            logger.exception(e)\n\n\ndef add_url_params(url, params):\n    \"\"\"Add GET params to provided URL being aware of existing.\n\n    :param url: string of target URL\n    :param params: dict containing requested params to be added\n    :return: string with updated URL\n\n    >> url = 'http://stackoverflow.com/test?answers=true'\n    >> new_params = {'answers': False, 'data': ['some','values']}\n    >> add_url_params(url, new_params)\n    'http://stackoverflow.com/test?data=some&data=values&answers=false'\n    \"\"\"\n    # Unquoting URL first so we don't loose existing args\n    url = unquote(url)\n    # Extracting url info\n    parsed_url = urlparse(url)\n    # Extracting URL arguments from parsed URL\n    get_args = parsed_url.query\n    # Converting URL arguments to dict\n    parsed_get_args = dict(parse_qsl(get_args))\n    # Merging URL arguments dict with new params\n    parsed_get_args.update(params)\n\n    # Bool and Dict values should be converted to json-friendly values\n    # you may throw this part away if you don't like it :)\n    parsed_get_args.update({k: json.dumps(v) for k, v in parsed_get_args.items() if isinstance(v, (bool, dict))})\n\n    # Converting URL argument to proper query string\n    encoded_get_args = urlencode(parsed_get_args, doseq=True)\n    # Creating new parsed result object based on provided with new\n    # URL arguments. Same thing happens inside of urlparse.\n    new_url = ParseResult(\n        parsed_url.scheme, parsed_url.netloc, parsed_url.path, parsed_url.params, encoded_get_args, parsed_url.fragment\n    ).geturl()\n\n    return new_url\n\n\njson_serializer_k_map = {\n    \"user\": settings.AUTH_USER_MODEL,\n    \"owner\": settings.AUTH_USER_MODEL,\n    \"restriction_code_type\": \"base.RestrictionCodeType\",\n    \"license\": \"base.License\",\n    \"category\": \"base.TopicCategory\",\n    \"spatial_representation_type\": \"base.SpatialRepresentationType\",\n    \"group\": \"auth.Group\",\n    \"default_style\": \"datasets.Style\",\n}\n\n\ndef json_serializer_producer(dictionary):\n    \"\"\"\n    - usage:\n           serialized_obj =\n               json_serializer_producer(model_to_dict(instance))\n\n    - dump to file:\n       with open('data.json', 'w') as outfile:\n           json.dump(serialized_obj, outfile)\n\n    - read from file:\n       with open('data.json', 'r') as infile:\n           serialized_obj = json.load(infile)\n    \"\"\"\n\n    def to_json(keys):\n        if isinstance(keys, datetime.datetime):\n            return str(keys)\n        elif isinstance(keys, str) or isinstance(keys, int):\n            return keys\n        elif isinstance(keys, dict):\n            return json_serializer_producer(keys)\n        elif isinstance(keys, list):\n            return [json_serializer_producer(model_to_dict(k)) for k in keys]\n        elif isinstance(keys, models.Model):\n            return json_serializer_producer(model_to_dict(keys))\n        elif isinstance(keys, Decimal):\n            return float(keys)\n        else:\n            return str(keys)\n\n    output = {}\n\n    _keys_to_skip = [\n        \"email\",\n        \"password\",\n        \"last_login\",\n        \"date_joined\",\n        \"is_staff\",\n        \"is_active\",\n        \"is_superuser\",\n        \"permissions\",\n        \"user_permissions\",\n    ]\n\n    for x, y in dictionary.items():\n        if x not in _keys_to_skip:\n            if x in json_serializer_k_map.keys():\n                instance = django_apps.get_model(json_serializer_k_map[x], require_ready=False)\n                if instance.objects.filter(id=y):\n                    _obj = instance.objects.get(id=y)\n                    y = model_to_dict(_obj)\n            output[x] = to_json(y)\n    return output\n\n\ndef is_monochromatic_image(image_url, image_data=None):\n    def is_local_static(url):\n        if url.startswith(settings.STATIC_URL) or (url.startswith(settings.SITEURL) and settings.STATIC_URL in url):\n            return True\n        return False\n\n    def is_absolute(url):\n        return bool(urlparse(url).netloc)\n\n    def get_thumb_handler(url):\n        _index = url.find(settings.STATIC_URL)\n        _thumb_path = urlparse(url[_index + len(settings.STATIC_URL) :]).path\n        if storage_manager.exists(_thumb_path):\n            return storage_manager.open(_thumb_path)\n        return None\n\n    def verify_image(stream):\n        with Image.open(stream) as _stream:\n            img = _stream.convert(\"L\")\n            img.verify()  # verify that it is, in fact an image\n            extr = img.getextrema()\n            a = 0\n            for i in extr:\n                if isinstance(i, tuple):\n                    a += abs(i[0] - i[1])\n                else:\n                    a = abs(extr[0] - extr[1])\n                    break\n            return a == 0\n\n    try:\n        if image_data:\n            logger.debug(\"...Checking if image is a blank image\")\n            with BytesIO(image_data) as stream:\n                return verify_image(stream)\n        elif image_url:\n            logger.debug(f\"...Checking if '{image_url}' is a blank image\")\n            url = image_url if is_absolute(image_url) else urljoin(settings.SITEURL, image_url)\n            if not is_local_static(url):\n                req, stream_content = http_client.get(url, timeout=5)\n                with BytesIO(stream_content) as stream:\n                    return verify_image(stream)\n            else:\n                with get_thumb_handler(url) as stream:\n                    return verify_image(stream)\n        return True\n    except Exception as e:\n        logger.debug(e)\n        return False\n\n\ndef find_by_attr(lst, val, attr=\"id\"):\n    \"\"\"Returns an object if the id matches in any list of objects\"\"\"\n    for item in lst:\n        if attr in item and item[attr] == val:\n            return item\n\n    return None\n\n\ndef build_absolute_uri(url):\n    if url and \"http\" not in url:\n        url = urljoin(settings.SITEURL, url)\n    return url\n\n\ndef extract_ip_or_domain(url):\n    ip_regex = re.compile(\"^(?:http\\:\\/\\/|https\\:\\/\\/)(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})\")\n    domain_regex = re.compile(\"^(?:http\\:\\/\\/|https\\:\\/\\/)([a-zA-Z0-9.-]+)\")\n\n    match = ip_regex.findall(url)\n    if len(match):\n        ip_address = match[0]\n        try:\n            ipaddress.ip_address(ip_address)  # Validate the IP address\n            return ip_address\n        except ValueError:\n            pass\n\n    match = domain_regex.findall(url)\n    if len(match):\n        return match[0]\n\n    return None\n\n\ndef get_xpath_value(\n    element: etree.Element, xpath_expression: str, nsmap: typing.Optional[dict] = None\n) -> typing.Optional[str]:\n    if not nsmap:\n        nsmap = element.nsmap\n    values = element.xpath(f\"{xpath_expression}//text()\", namespaces=nsmap)\n    return \"\".join(values).strip() or None\n\n\ndef get_geonode_app_types():\n    from geonode.geoapps.models import GeoApp\n\n    return list(set(GeoApp.objects.values_list(\"resource_type\", flat=True)))\n\n\ndef get_supported_datasets_file_types():\n    from django.conf import settings as gn_settings\n\n    \"\"\"\n    Return a list of all supported file type in geonode\n    If one of the type provided in the custom type exists in the default\n    is going to override it\n    \"\"\"\n    default_types = settings.SUPPORTED_DATASET_FILE_TYPES\n    types_module = (\n        gn_settings.ADDITIONAL_DATASET_FILE_TYPES if hasattr(gn_settings, \"ADDITIONAL_DATASET_FILE_TYPES\") else []\n    )\n    supported_types = default_types.copy()\n    default_types_id = [t.get(\"id\") for t in default_types]\n    for _type in types_module:\n        if _type.get(\"id\") in default_types_id:\n            supported_types[default_types_id.index(_type.get(\"id\"))] = _type\n        else:\n            supported_types.extend([_type])\n\n    # Order the formats (to support their visualization)\n    formats_order = [(\"vector\", 0), (\"raster\", 1), (\"archive\", 2)]\n    ordered_payload = (\n        (weight[1], resource_type)\n        for resource_type in supported_types\n        for weight in formats_order\n        if resource_type.get(\"format\") in weight[0]\n    )\n\n    # Flatten the list\n    ordered_resource_types = [x[1] for x in sorted(ordered_payload, key=lambda x: x[0])]\n    other_resource_types = [\n        resource_type\n        for resource_type in supported_types\n        if resource_type.get(\"format\") is None or resource_type.get(\"format\") not in [f[0] for f in formats_order]\n    ]\n    return ordered_resource_types + other_resource_types\n\n\ndef get_allowed_extensions():\n    return list(itertools.chain.from_iterable([_type[\"ext\"] for _type in get_supported_datasets_file_types()]))\n\n\ndef safe_path_leaf(path):\n    \"\"\"A view that is not vulnerable to malicious file access.\"\"\"\n    base_path = settings.MEDIA_ROOT\n    try:\n        validate_filepath(path, platform=\"auto\")\n        head, tail = ntpath.split(path)\n        filename = tail or ntpath.basename(head)\n        validate_filename(filename, platform=\"auto\")\n    except ValidationError as e:\n        logger.error(f\"{e}\")\n        raise e\n    # GOOD -- Verify with normalised version of path\n    fullpath = os.path.normpath(os.path.join(head, filename))\n    if not fullpath.startswith(base_path) or path != fullpath:\n        raise GeoNodeException(\n            f\"The provided path '{path}' is not safe. The file is outside the MEDIA_ROOT '{base_path}' base path!\"\n        )\n    return fullpath\n\n\ndef import_class_module(full_class_string):\n    \"\"\"\n    Dynamically load a class from a string\n\n    >>> klass = import_class_module(\"module.submodule.ClassName\")\n    >>> klass2 = import_class_module(\"myfile.Class2\")\n    \"\"\"\n    try:\n        module_path, class_name = full_class_string.rsplit(\".\", 1)\n        module = importlib.import_module(module_path)\n        class_obj = getattr(module, class_name)\n        return class_obj\n    except Exception:\n        return None\n", "# native dependencies\nPillow==10.0.0\nlxml==4.9.3\npsycopg2==2.9.7\nDjango==3.2.20\n\n# Other\namqp==5.1.1\nbeautifulsoup4==4.12.2\nhttplib2<0.22.1\nhyperlink==21.0.0\nidna>=2.5,<3.5\nurllib3==1.26.15\nPaver==1.3.4\npython-slugify==8.0.1\ndecorator==5.1.1\ncelery==5.3.1\nkombu==5.3.1\nvine==5.0.0\ntqdm==4.66.1\nDeprecated==1.2.14\nwrapt==1.15.0\njsonschema==4.19.0\nzipstream-new==1.1.8\nschema==0.7.5\nrdflib==6.3.2\nsmart_open==6.3.0\nPyMuPDF==1.22.5\npathvalidate==3.1.0\nipaddress==1.0.23\n\n# Django Apps\ndjango-allauth==0.54.0\ndjango-appconf==1.0.5\ndjango-celery-results==2.5.1\ndjango-filter==23.2\ndjango-imagekit==4.1.0\ndjango-taggit==1.5.1\ndjango-markdownify==0.9.3\ndjango-mptt==0.14.0\ndjango-modeltranslation>=0.11,<0.19.0\ndjango-treebeard==4.7\ndjango-guardian<2.4.1\ndjango-downloadview==2.3.0\ndjango-polymorphic==3.1.0\ndjango-tastypie<0.15.0\ndjango-tinymce==3.6.1\ndjango-grappelli==3.0.7\ndjango-uuid-upload-path==1.0.0\ndjango-widget-tweaks==1.4.12\ndjango-sequences==2.8\noauthlib==3.2.2\npyopenssl==23.2.0\npyjwt==2.8.0\n\n# geopython dependencies\npyproj<3.7.0\nOWSLib==0.29.2\npycsw==2.6.1\nSQLAlchemy==2.0.20 # required by PyCSW\nShapely==1.8.5.post1\nmercantile==1.2.1\ngeoip2==4.7.0\nnumpy==1.25.*\n\n# # Apps with packages provided in GeoNode's PPA on Launchpad.\n\n# Django Apps\ndj-database-url==2.1.0\ndj-pagination==2.5.0\ndjango-select2==8.1.2\ndjango-floppyforms<1.10.0\ndjango-forms-bootstrap<=3.1.0\ndjango-autocomplete-light==3.5.1\ndjango-invitations<2.0.1\ndjango-recaptcha==3.0.0\n\n# REST\ndjangorestframework==3.12.0\ndjangorestframework-gis==1.0\ndjangorestframework-guardian==0.3.0\ndrf-extensions==0.7.1\ndrf-writable-nested==0.7.0\ndrf-spectacular==0.26.4\ndynamic-rest==2.1.2\nMarkdown==3.4.4\n\npinax-notifications==6.0.0\npinax-ratings==4.0.0\n\n# GeoNode org maintained apps.\n# django-geonode-mapstore-client==4.0.5\n-e git+https://github.com/GeoNode/geonode-mapstore-client.git@master#egg=django_geonode_mapstore_client\n-e git+https://github.com/GeoNode/geonode-importer.git@master#egg=geonode-importer\ndjango-avatar==7.1.1\ngeonode-oauth-toolkit==2.2.2\ngeonode-user-messages==2.0.2\ngeonode-announcements==2.0.2\ngeonode-django-activity-stream==0.10.0\ngn-arcrest==10.5.6\ngeoserver-restconfig==2.0.9\ngn-gsimporter==2.0.4\ngisdata==0.5.4\n\n# haystack/elasticsearch\ndjango-haystack==3.2.1\nelasticsearch>=2.0.0,<9.0.0\n\n# datetimepicker widget\ndjango-bootstrap3-datetimepicker-2==2.8.3\n\n# storage manager dependencies\ndjango-storages==1.13.2\ndropbox==11.36.2\ngoogle-cloud-storage==2.10.0\ngoogle-cloud-core==2.3.3\nboto3==1.28.32\n\n# Django Caches\npython-memcached<=1.59\nwhitenoise==6.5.0\nBrotli==1.0.9\n\n# Contribs\nxmltodict<0.13.1\ninflection>=0.4.0\njdcal==1.4.1\nmock<6.0.0\npython-dateutil==2.8.2\npytz==2023.3\nrequests==2.31.0\ntimeout-decorator==0.5.0\npylibmc==1.6.3\nsherlock==0.4.1\n\n# required by monitoring\npsutil==5.9.5\ndjango-cors-headers==4.2.0\nuser-agents\ndjango-user-agents\nxmljson\ndjango-ipware<5.1\n# no version here, use latest one with fresh data\npycountry\n\n# production\nuWSGI==2.0.22\ngunicorn==21.2.0\nipython==8.14.0\ndocker==6.1.3\ninvoke==2.2.0\n\n# tests\ncoverage==7.3.0\nrequests-toolbelt==1.0.0\nflake8==6.1.0\nblack==23.7.0\npytest==7.4.0\npytest-bdd==6.1.1\nsplinter==0.19.0\npytest-splinter==3.3.2\npytest-django==4.5.2\nsetuptools>=59.1.1,<68.2.0\npip==23.2.1\nTwisted==22.10.0\npixelmatch==0.3.0\nfactory-boy==3.3.0\nflaky==3.7.0\nselenium>=4.1.0,<5.0.0\nselenium-requests==2.0.3\nwebdriver_manager==4.0.0\n\n# Security and audit\nmistune==3.0.1\nprotobuf==3.20.3\nmako==1.2.4\nparamiko==3.3.1 # not directly required, fixes Blowfish deprecation warning\ncertifi>=2022.12.7 # not directly required, pinned by Snyk to avoid a vulnerability\njwcrypto>=1.4 # not directly required, pinned by Snyk to avoid a vulnerability\ncryptography>=41.0.0 # not directly required, pinned by Snyk to avoid a vulnerability\n", "[metadata]\nname = GeoNode\ndescription = Application for serving and sharing geospatial data\nlicense = GPL\nauthor = GeoNode Developers\nauthor_email = dev@geonode.org\nurl = http://geonode.org\ndownload_url = https://github.com/GeoNode/geonode/archive/master.zip\nkeywords = django, geonode\nclassifiers =\n    Development Status :: 5 - Production/Stable\n    Environment :: Web Environment\n    Framework :: Django\n    Intended Audience :: Developers\n    Operating System :: OS Independent\n    Topic :: Internet :: WWW/HTTP\n    Programming Language :: Python :: 3.10\n\n[options]\nzip_safe = False\ninclude_package_data = True\npython_requires = >= 3.10\npackages = find:\nsetup_requires =\n    setuptools\ninstall_requires =\n    # native dependencies\n    Pillow==10.0.0\n    lxml==4.9.3\n    psycopg2==2.9.7\n    Django==3.2.20\n\n    # Other\n    amqp==5.1.1\n    beautifulsoup4==4.12.2\n    httplib2<0.22.1\n    hyperlink==21.0.0\n    idna>=2.5,<3.5\n    urllib3==1.26.15\n    Paver==1.3.4\n    python-slugify==8.0.1\n    decorator==5.1.1\n    celery==5.3.1\n    kombu==5.3.1\n    vine==5.0.0\n    tqdm==4.66.1\n    Deprecated==1.2.14\n    wrapt==1.15.0\n    jsonschema==4.19.0\n    zipstream-new==1.1.8\n    schema==0.7.5\n    rdflib==6.3.2\n    smart_open==6.3.0\n    PyMuPDF==1.22.5\n    pathvalidate==3.1.0\n    ipaddress==1.0.23\n\n    # Django Apps\n    django-allauth==0.54.0\n    django-appconf==1.0.5\n    django-celery-results==2.5.1\n    django-filter==23.2\n    django-imagekit==4.1.0\n    django-taggit==1.5.1\n    django-markdownify==0.9.3\n    django-mptt==0.14.0\n    django-modeltranslation>=0.11,<0.19.0\n    django-treebeard==4.7\n    django-guardian<2.4.1\n    django-downloadview==2.3.0\n    django-polymorphic==3.1.0\n    django-tastypie<0.15.0\n    django-tinymce==3.6.1\n    django-grappelli==3.0.7\n    django-uuid-upload-path==1.0.0\n    django-widget-tweaks==1.4.12\n    django-sequences==2.8\n    oauthlib==3.2.2\n    pyopenssl==23.2.0\n    pyjwt==2.8.0\n\n    # geopython dependencies\n    pyproj<3.7.0\n    OWSLib==0.29.2\n    pycsw==2.6.1\n    SQLAlchemy==2.0.20 # required by PyCSW\n    Shapely==1.8.5.post1\n    mercantile==1.2.1\n    geoip2==4.7.0\n    numpy==1.25.*\n\n    # # Apps with packages provided in GeoNode's PPA on Launchpad.\n\n    # Django Apps\n    dj-database-url==2.1.0\n    dj-pagination==2.5.0\n    django-select2==8.1.2\n    django-floppyforms<1.10.0\n    django-forms-bootstrap<=3.1.0\n    django-autocomplete-light==3.5.1\n    django-invitations<2.0.1\n    django-recaptcha==3.0.0\n\n    # REST\n    djangorestframework==3.12.0\n    djangorestframework-gis==1.0\n    djangorestframework-guardian==0.3.0\n    drf-extensions==0.7.1\n    drf-writable-nested==0.7.0\n    drf-spectacular==0.26.4\n    dynamic-rest==2.1.2\n    Markdown==3.4.4\n\n    pinax-notifications==6.0.0\n    pinax-ratings==4.0.0\n\n    # GeoNode org maintained apps.\n    django-geonode-mapstore-client>=4.0.5,<5.0.0\n    geonode-importer>=1.0.2\n    django-avatar==7.1.1\n    geonode-oauth-toolkit==2.2.2\n    geonode-user-messages==2.0.2\n    geonode-announcements==2.0.2\n    geonode-django-activity-stream==0.10.0\n    gn-arcrest==10.5.6\n    geoserver-restconfig==2.0.9\n    gn-gsimporter==2.0.4\n    gisdata==0.5.4\n\n    # haystack/elasticsearch\n    django-haystack==3.2.1\n    elasticsearch>=2.0.0,<9.0.0\n\n    # datetimepicker widget\n    django-bootstrap3-datetimepicker-2==2.8.3\n\n    # storage manager dependencies\n    django-storages==1.13.2\n    dropbox==11.36.2\n    google-cloud-storage==2.10.0\n    google-cloud-core==2.3.3\n    boto3==1.28.32\n\n    # Django Caches\n    python-memcached<=1.59\n    whitenoise==6.5.0\n    Brotli==1.0.9\n\n    # Contribs\n    xmltodict<0.13.1\n    inflection>=0.4.0\n    jdcal==1.4.1\n    mock<6.0.0\n    python-dateutil==2.8.2\n    pytz==2023.3\n    requests==2.31.0\n    timeout-decorator==0.5.0\n    pylibmc==1.6.3\n    sherlock==0.4.1\n\n    # required by monitoring\n    psutil==5.9.5\n    django-cors-headers==4.2.0\n    user-agents\n    django-user-agents\n    xmljson\n    django-ipware<5.1\n    # no version here, use latest one with fresh data\n    pycountry\n\n    # production\n    uWSGI==2.0.22\n    gunicorn==21.2.0\n    ipython==8.14.0\n    docker==6.1.3\n    invoke==2.2.0\n\n    # tests\n    coverage==7.3.0\n    requests-toolbelt==1.0.0\n    flake8==6.1.0\n    black==23.7.0\n    pytest==7.4.0\n    pytest-bdd==6.1.1\n    splinter==0.19.0\n    pytest-splinter==3.3.2\n    pytest-django==4.5.2\n    setuptools>=59.1.1,<68.2.0\n    pip==23.2.1\n    Twisted==22.10.0\n    pixelmatch==0.3.0\n    factory-boy==3.3.0\n    flaky==3.7.0\n    selenium>=4.1.0,<5.0.0\n    selenium-requests==2.0.3\n    webdriver_manager==4.0.0\n\n    # Security and audit\n    mistune==3.0.1\n    protobuf==3.20.3\n    mako==1.2.4\n    paramiko==3.3.1 # not directly required, fixes Blowfish deprecation warning\n    certifi>=2022.12.7 # not directly required, pinned by Snyk to avoid a vulnerability\n    jwcrypto>=1.4 # not directly required, pinned by Snyk to avoid a vulnerability\n    cryptography>=41.0.0 # not directly required, pinned by Snyk to avoid a vulnerability\n\n[options.packages.find]\nexclude = tests\n\n[bdist_wheel]\nuniversal = 1\n\n[flake8]\nmax-line-length = 200\nexclude=geonode/*/migrations/*,scripts,docs,static,migrations,node_modules\nextend-ignore=E122,E124,E203,E731\n"], "filenames": ["geonode/proxy/tests.py", "geonode/proxy/views.py", "geonode/utils.py", "requirements.txt", "setup.cfg"], "buggy_code_start_loc": [180, 43, 36, 29, 55], "buggy_code_end_loc": [180, 134, 1932, 29, 55], "fixing_code_start_loc": [181, 43, 37, 30, 56], "fixing_code_end_loc": [227, 141, 1954, 31, 57], "type": "CWE-918", "message": "GeoNode is an open source platform that facilitates the creation, sharing, and collaborative use of geospatial data. In versions 3.2.0 through 4.1.2, the endpoint `/proxy/?url=` does not properly protect against server-side request forgery. This allows an attacker to port scan internal hosts and request information from internal hosts. A patch is available at commit a9eebae80cb362009660a1fd49e105e7cdb499b9.", "other": {"cve": {"id": "CVE-2023-40017", "sourceIdentifier": "security-advisories@github.com", "published": "2023-08-24T23:15:09.097", "lastModified": "2023-08-30T17:48:12.503", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "GeoNode is an open source platform that facilitates the creation, sharing, and collaborative use of geospatial data. In versions 3.2.0 through 4.1.2, the endpoint `/proxy/?url=` does not properly protect against server-side request forgery. This allows an attacker to port scan internal hosts and request information from internal hosts. A patch is available at commit a9eebae80cb362009660a1fd49e105e7cdb499b9."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:geosolutionsgroup:geonode:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.2.0", "versionEndIncluding": "4.1.2", "matchCriteriaId": "4F4E6891-B6D9-4280-8C88-3928E7AA2B79"}]}]}], "references": [{"url": "https://github.com/GeoNode/geonode/commit/a9eebae80cb362009660a1fd49e105e7cdb499b9", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/GeoNode/geonode/security/advisories/GHSA-rmxg-6qqf-x8mr", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/GeoNode/geonode/commit/a9eebae80cb362009660a1fd49e105e7cdb499b9"}}