{"buggy_code": ["/*\n * Copyright (c) 2016 Hisilicon Limited.\n * Copyright (c) 2007, 2008 Mellanox Technologies. All rights reserved.\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * OpenIB.org BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#include <linux/acpi.h>\n#include <linux/of_platform.h>\n#include <linux/module.h>\n#include <rdma/ib_addr.h>\n#include <rdma/ib_smi.h>\n#include <rdma/ib_user_verbs.h>\n#include <rdma/ib_cache.h>\n#include \"hns_roce_common.h\"\n#include \"hns_roce_device.h\"\n#include <rdma/hns-abi.h>\n#include \"hns_roce_hem.h\"\n\n/**\n * hns_get_gid_index - Get gid index.\n * @hr_dev: pointer to structure hns_roce_dev.\n * @port:  port, value range: 0 ~ MAX\n * @gid_index:  gid_index, value range: 0 ~ MAX\n * Description:\n *    N ports shared gids, allocation method as follow:\n *\t\tGID[0][0], GID[1][0],.....GID[N - 1][0],\n *\t\tGID[0][0], GID[1][0],.....GID[N - 1][0],\n *\t\tAnd so on\n */\nint hns_get_gid_index(struct hns_roce_dev *hr_dev, u8 port, int gid_index)\n{\n\treturn gid_index * hr_dev->caps.num_ports + port;\n}\nEXPORT_SYMBOL_GPL(hns_get_gid_index);\n\nstatic int hns_roce_set_mac(struct hns_roce_dev *hr_dev, u8 port, u8 *addr)\n{\n\tu8 phy_port;\n\tu32 i = 0;\n\n\tif (!memcmp(hr_dev->dev_addr[port], addr, MAC_ADDR_OCTET_NUM))\n\t\treturn 0;\n\n\tfor (i = 0; i < MAC_ADDR_OCTET_NUM; i++)\n\t\thr_dev->dev_addr[port][i] = addr[i];\n\n\tphy_port = hr_dev->iboe.phy_port[port];\n\treturn hr_dev->hw->set_mac(hr_dev, phy_port, addr);\n}\n\nstatic int hns_roce_add_gid(struct ib_device *device, u8 port_num,\n\t\t\t    unsigned int index, const union ib_gid *gid,\n\t\t\t    const struct ib_gid_attr *attr, void **context)\n{\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(device);\n\tu8 port = port_num - 1;\n\tunsigned long flags;\n\tint ret;\n\n\tif (port >= hr_dev->caps.num_ports)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&hr_dev->iboe.lock, flags);\n\n\tret = hr_dev->hw->set_gid(hr_dev, port, index, (union ib_gid *)gid,\n\t\t\t\t   attr);\n\n\tspin_unlock_irqrestore(&hr_dev->iboe.lock, flags);\n\n\treturn ret;\n}\n\nstatic int hns_roce_del_gid(struct ib_device *device, u8 port_num,\n\t\t\t    unsigned int index, void **context)\n{\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(device);\n\tstruct ib_gid_attr zattr = { };\n\tunion ib_gid zgid = { {0} };\n\tu8 port = port_num - 1;\n\tunsigned long flags;\n\tint ret;\n\n\tif (port >= hr_dev->caps.num_ports)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&hr_dev->iboe.lock, flags);\n\n\tret = hr_dev->hw->set_gid(hr_dev, port, index, &zgid, &zattr);\n\n\tspin_unlock_irqrestore(&hr_dev->iboe.lock, flags);\n\n\treturn ret;\n}\n\nstatic int handle_en_event(struct hns_roce_dev *hr_dev, u8 port,\n\t\t\t   unsigned long event)\n{\n\tstruct device *dev = hr_dev->dev;\n\tstruct net_device *netdev;\n\tint ret = 0;\n\n\tnetdev = hr_dev->iboe.netdevs[port];\n\tif (!netdev) {\n\t\tdev_err(dev, \"port(%d) can't find netdev\\n\", port);\n\t\treturn -ENODEV;\n\t}\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\tcase NETDEV_CHANGE:\n\tcase NETDEV_REGISTER:\n\tcase NETDEV_CHANGEADDR:\n\t\tret = hns_roce_set_mac(hr_dev, port, netdev->dev_addr);\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\t/*\n\t\t * In v1 engine, only support all ports closed together.\n\t\t */\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, \"NETDEV event = 0x%x!\\n\", (u32)(event));\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int hns_roce_netdev_event(struct notifier_block *self,\n\t\t\t\t unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct hns_roce_ib_iboe *iboe = NULL;\n\tstruct hns_roce_dev *hr_dev = NULL;\n\tu8 port = 0;\n\tint ret = 0;\n\n\thr_dev = container_of(self, struct hns_roce_dev, iboe.nb);\n\tiboe = &hr_dev->iboe;\n\n\tfor (port = 0; port < hr_dev->caps.num_ports; port++) {\n\t\tif (dev == iboe->netdevs[port]) {\n\t\t\tret = handle_en_event(hr_dev, port, event);\n\t\t\tif (ret)\n\t\t\t\treturn NOTIFY_DONE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int hns_roce_setup_mtu_mac(struct hns_roce_dev *hr_dev)\n{\n\tint ret;\n\tu8 i;\n\n\tfor (i = 0; i < hr_dev->caps.num_ports; i++) {\n\t\tif (hr_dev->hw->set_mtu)\n\t\t\thr_dev->hw->set_mtu(hr_dev, hr_dev->iboe.phy_port[i],\n\t\t\t\t\t    hr_dev->caps.max_mtu);\n\t\tret = hns_roce_set_mac(hr_dev, i,\n\t\t\t\t       hr_dev->iboe.netdevs[i]->dev_addr);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int hns_roce_query_device(struct ib_device *ib_dev,\n\t\t\t\t struct ib_device_attr *props,\n\t\t\t\t struct ib_udata *uhw)\n{\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);\n\n\tmemset(props, 0, sizeof(*props));\n\n\tprops->sys_image_guid = cpu_to_be32(hr_dev->sys_image_guid);\n\tprops->max_mr_size = (u64)(~(0ULL));\n\tprops->page_size_cap = hr_dev->caps.page_size_cap;\n\tprops->vendor_id = hr_dev->vendor_id;\n\tprops->vendor_part_id = hr_dev->vendor_part_id;\n\tprops->hw_ver = hr_dev->hw_rev;\n\tprops->max_qp = hr_dev->caps.num_qps;\n\tprops->max_qp_wr = hr_dev->caps.max_wqes;\n\tprops->device_cap_flags = IB_DEVICE_PORT_ACTIVE_EVENT |\n\t\t\t\t  IB_DEVICE_RC_RNR_NAK_GEN;\n\tprops->max_sge = max(hr_dev->caps.max_sq_sg, hr_dev->caps.max_rq_sg);\n\tprops->max_sge_rd = 1;\n\tprops->max_cq = hr_dev->caps.num_cqs;\n\tprops->max_cqe = hr_dev->caps.max_cqes;\n\tprops->max_mr = hr_dev->caps.num_mtpts;\n\tprops->max_pd = hr_dev->caps.num_pds;\n\tprops->max_qp_rd_atom = hr_dev->caps.max_qp_dest_rdma;\n\tprops->max_qp_init_rd_atom = hr_dev->caps.max_qp_init_rdma;\n\tprops->atomic_cap = IB_ATOMIC_NONE;\n\tprops->max_pkeys = 1;\n\tprops->local_ca_ack_delay = hr_dev->caps.local_ca_ack_delay;\n\n\treturn 0;\n}\n\nstatic struct net_device *hns_roce_get_netdev(struct ib_device *ib_dev,\n\t\t\t\t\t      u8 port_num)\n{\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);\n\tstruct net_device *ndev;\n\n\tif (port_num < 1 || port_num > hr_dev->caps.num_ports)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\n\tndev = hr_dev->iboe.netdevs[port_num - 1];\n\tif (ndev)\n\t\tdev_hold(ndev);\n\n\trcu_read_unlock();\n\treturn ndev;\n}\n\nstatic int hns_roce_query_port(struct ib_device *ib_dev, u8 port_num,\n\t\t\t       struct ib_port_attr *props)\n{\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);\n\tstruct device *dev = hr_dev->dev;\n\tstruct net_device *net_dev;\n\tunsigned long flags;\n\tenum ib_mtu mtu;\n\tu8 port;\n\n\tassert(port_num > 0);\n\tport = port_num - 1;\n\n\t/* props being zeroed by the caller, avoid zeroing it here */\n\n\tprops->max_mtu = hr_dev->caps.max_mtu;\n\tprops->gid_tbl_len = hr_dev->caps.gid_table_len[port];\n\tprops->port_cap_flags = IB_PORT_CM_SUP | IB_PORT_REINIT_SUP |\n\t\t\t\tIB_PORT_VENDOR_CLASS_SUP |\n\t\t\t\tIB_PORT_BOOT_MGMT_SUP;\n\tprops->max_msg_sz = HNS_ROCE_MAX_MSG_LEN;\n\tprops->pkey_tbl_len = 1;\n\tprops->active_width = IB_WIDTH_4X;\n\tprops->active_speed = 1;\n\n\tspin_lock_irqsave(&hr_dev->iboe.lock, flags);\n\n\tnet_dev = hr_dev->iboe.netdevs[port];\n\tif (!net_dev) {\n\t\tspin_unlock_irqrestore(&hr_dev->iboe.lock, flags);\n\t\tdev_err(dev, \"find netdev %d failed!\\r\\n\", port);\n\t\treturn -EINVAL;\n\t}\n\n\tmtu = iboe_get_mtu(net_dev->mtu);\n\tprops->active_mtu = mtu ? min(props->max_mtu, mtu) : IB_MTU_256;\n\tprops->state = (netif_running(net_dev) && netif_carrier_ok(net_dev)) ?\n\t\t\tIB_PORT_ACTIVE : IB_PORT_DOWN;\n\tprops->phys_state = (props->state == IB_PORT_ACTIVE) ? 5 : 3;\n\n\tspin_unlock_irqrestore(&hr_dev->iboe.lock, flags);\n\n\treturn 0;\n}\n\nstatic enum rdma_link_layer hns_roce_get_link_layer(struct ib_device *device,\n\t\t\t\t\t\t    u8 port_num)\n{\n\treturn IB_LINK_LAYER_ETHERNET;\n}\n\nstatic int hns_roce_query_gid(struct ib_device *ib_dev, u8 port_num, int index,\n\t\t\t      union ib_gid *gid)\n{\n\treturn 0;\n}\n\nstatic int hns_roce_query_pkey(struct ib_device *ib_dev, u8 port, u16 index,\n\t\t\t       u16 *pkey)\n{\n\t*pkey = PKEY_ID;\n\n\treturn 0;\n}\n\nstatic int hns_roce_modify_device(struct ib_device *ib_dev, int mask,\n\t\t\t\t  struct ib_device_modify *props)\n{\n\tunsigned long flags;\n\n\tif (mask & ~IB_DEVICE_MODIFY_NODE_DESC)\n\t\treturn -EOPNOTSUPP;\n\n\tif (mask & IB_DEVICE_MODIFY_NODE_DESC) {\n\t\tspin_lock_irqsave(&to_hr_dev(ib_dev)->sm_lock, flags);\n\t\tmemcpy(ib_dev->node_desc, props->node_desc, NODE_DESC_SIZE);\n\t\tspin_unlock_irqrestore(&to_hr_dev(ib_dev)->sm_lock, flags);\n\t}\n\n\treturn 0;\n}\n\nstatic int hns_roce_modify_port(struct ib_device *ib_dev, u8 port_num, int mask,\n\t\t\t\tstruct ib_port_modify *props)\n{\n\treturn 0;\n}\n\nstatic struct ib_ucontext *hns_roce_alloc_ucontext(struct ib_device *ib_dev,\n\t\t\t\t\t\t   struct ib_udata *udata)\n{\n\tint ret = 0;\n\tstruct hns_roce_ucontext *context;\n\tstruct hns_roce_ib_alloc_ucontext_resp resp;\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);\n\n\tresp.qp_tab_size = hr_dev->caps.num_qps;\n\n\tcontext = kmalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = hns_roce_uar_alloc(hr_dev, &context->uar);\n\tif (ret)\n\t\tgoto error_fail_uar_alloc;\n\n\tif (hr_dev->caps.flags & HNS_ROCE_CAP_FLAG_RECORD_DB) {\n\t\tINIT_LIST_HEAD(&context->page_list);\n\t\tmutex_init(&context->page_mutex);\n\t}\n\n\tret = ib_copy_to_udata(udata, &resp, sizeof(resp));\n\tif (ret)\n\t\tgoto error_fail_copy_to_udata;\n\n\treturn &context->ibucontext;\n\nerror_fail_copy_to_udata:\n\thns_roce_uar_free(hr_dev, &context->uar);\n\nerror_fail_uar_alloc:\n\tkfree(context);\n\n\treturn ERR_PTR(ret);\n}\n\nstatic int hns_roce_dealloc_ucontext(struct ib_ucontext *ibcontext)\n{\n\tstruct hns_roce_ucontext *context = to_hr_ucontext(ibcontext);\n\n\thns_roce_uar_free(to_hr_dev(ibcontext->device), &context->uar);\n\tkfree(context);\n\n\treturn 0;\n}\n\nstatic int hns_roce_mmap(struct ib_ucontext *context,\n\t\t\t struct vm_area_struct *vma)\n{\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(context->device);\n\n\tif (((vma->vm_end - vma->vm_start) % PAGE_SIZE) != 0)\n\t\treturn -EINVAL;\n\n\tif (vma->vm_pgoff == 0) {\n\t\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\t\tif (io_remap_pfn_range(vma, vma->vm_start,\n\t\t\t\t       to_hr_ucontext(context)->uar.pfn,\n\t\t\t\t       PAGE_SIZE, vma->vm_page_prot))\n\t\t\treturn -EAGAIN;\n\t} else if (vma->vm_pgoff == 1 && hr_dev->tptr_dma_addr &&\n\t\t   hr_dev->tptr_size) {\n\t\t/* vm_pgoff: 1 -- TPTR */\n\t\tif (io_remap_pfn_range(vma, vma->vm_start,\n\t\t\t\t       hr_dev->tptr_dma_addr >> PAGE_SHIFT,\n\t\t\t\t       hr_dev->tptr_size,\n\t\t\t\t       vma->vm_page_prot))\n\t\t\treturn -EAGAIN;\n\t} else\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int hns_roce_port_immutable(struct ib_device *ib_dev, u8 port_num,\n\t\t\t\t   struct ib_port_immutable *immutable)\n{\n\tstruct ib_port_attr attr;\n\tint ret;\n\n\tret = ib_query_port(ib_dev, port_num, &attr);\n\tif (ret)\n\t\treturn ret;\n\n\timmutable->pkey_tbl_len = attr.pkey_tbl_len;\n\timmutable->gid_tbl_len = attr.gid_tbl_len;\n\n\timmutable->max_mad_size = IB_MGMT_MAD_SIZE;\n\timmutable->core_cap_flags = RDMA_CORE_PORT_IBA_ROCE;\n\tif (to_hr_dev(ib_dev)->caps.flags & HNS_ROCE_CAP_FLAG_ROCE_V1_V2)\n\t\timmutable->core_cap_flags |= RDMA_CORE_PORT_IBA_ROCE_UDP_ENCAP;\n\n\treturn 0;\n}\n\nstatic void hns_roce_unregister_device(struct hns_roce_dev *hr_dev)\n{\n\tstruct hns_roce_ib_iboe *iboe = &hr_dev->iboe;\n\n\tunregister_netdevice_notifier(&iboe->nb);\n\tib_unregister_device(&hr_dev->ib_dev);\n}\n\nstatic int hns_roce_register_device(struct hns_roce_dev *hr_dev)\n{\n\tint ret;\n\tstruct hns_roce_ib_iboe *iboe = NULL;\n\tstruct ib_device *ib_dev = NULL;\n\tstruct device *dev = hr_dev->dev;\n\n\tiboe = &hr_dev->iboe;\n\tspin_lock_init(&iboe->lock);\n\n\tib_dev = &hr_dev->ib_dev;\n\tstrlcpy(ib_dev->name, \"hns_%d\", IB_DEVICE_NAME_MAX);\n\n\tib_dev->owner\t\t\t= THIS_MODULE;\n\tib_dev->node_type\t\t= RDMA_NODE_IB_CA;\n\tib_dev->dev.parent\t\t= dev;\n\n\tib_dev->phys_port_cnt\t\t= hr_dev->caps.num_ports;\n\tib_dev->local_dma_lkey\t\t= hr_dev->caps.reserved_lkey;\n\tib_dev->num_comp_vectors\t= hr_dev->caps.num_comp_vectors;\n\tib_dev->uverbs_abi_ver\t\t= 1;\n\tib_dev->uverbs_cmd_mask\t\t=\n\t\t(1ULL << IB_USER_VERBS_CMD_GET_CONTEXT) |\n\t\t(1ULL << IB_USER_VERBS_CMD_QUERY_DEVICE) |\n\t\t(1ULL << IB_USER_VERBS_CMD_QUERY_PORT) |\n\t\t(1ULL << IB_USER_VERBS_CMD_ALLOC_PD) |\n\t\t(1ULL << IB_USER_VERBS_CMD_DEALLOC_PD) |\n\t\t(1ULL << IB_USER_VERBS_CMD_REG_MR) |\n\t\t(1ULL << IB_USER_VERBS_CMD_DEREG_MR) |\n\t\t(1ULL << IB_USER_VERBS_CMD_CREATE_COMP_CHANNEL) |\n\t\t(1ULL << IB_USER_VERBS_CMD_CREATE_CQ) |\n\t\t(1ULL << IB_USER_VERBS_CMD_DESTROY_CQ) |\n\t\t(1ULL << IB_USER_VERBS_CMD_CREATE_QP) |\n\t\t(1ULL << IB_USER_VERBS_CMD_MODIFY_QP) |\n\t\t(1ULL << IB_USER_VERBS_CMD_QUERY_QP) |\n\t\t(1ULL << IB_USER_VERBS_CMD_DESTROY_QP);\n\n\t/* HCA||device||port */\n\tib_dev->modify_device\t\t= hns_roce_modify_device;\n\tib_dev->query_device\t\t= hns_roce_query_device;\n\tib_dev->query_port\t\t= hns_roce_query_port;\n\tib_dev->modify_port\t\t= hns_roce_modify_port;\n\tib_dev->get_link_layer\t\t= hns_roce_get_link_layer;\n\tib_dev->get_netdev\t\t= hns_roce_get_netdev;\n\tib_dev->query_gid\t\t= hns_roce_query_gid;\n\tib_dev->add_gid\t\t\t= hns_roce_add_gid;\n\tib_dev->del_gid\t\t\t= hns_roce_del_gid;\n\tib_dev->query_pkey\t\t= hns_roce_query_pkey;\n\tib_dev->alloc_ucontext\t\t= hns_roce_alloc_ucontext;\n\tib_dev->dealloc_ucontext\t= hns_roce_dealloc_ucontext;\n\tib_dev->mmap\t\t\t= hns_roce_mmap;\n\n\t/* PD */\n\tib_dev->alloc_pd\t\t= hns_roce_alloc_pd;\n\tib_dev->dealloc_pd\t\t= hns_roce_dealloc_pd;\n\n\t/* AH */\n\tib_dev->create_ah\t\t= hns_roce_create_ah;\n\tib_dev->query_ah\t\t= hns_roce_query_ah;\n\tib_dev->destroy_ah\t\t= hns_roce_destroy_ah;\n\n\t/* QP */\n\tib_dev->create_qp\t\t= hns_roce_create_qp;\n\tib_dev->modify_qp\t\t= hns_roce_modify_qp;\n\tib_dev->query_qp\t\t= hr_dev->hw->query_qp;\n\tib_dev->destroy_qp\t\t= hr_dev->hw->destroy_qp;\n\tib_dev->post_send\t\t= hr_dev->hw->post_send;\n\tib_dev->post_recv\t\t= hr_dev->hw->post_recv;\n\n\t/* CQ */\n\tib_dev->create_cq\t\t= hns_roce_ib_create_cq;\n\tib_dev->modify_cq\t\t= hr_dev->hw->modify_cq;\n\tib_dev->destroy_cq\t\t= hns_roce_ib_destroy_cq;\n\tib_dev->req_notify_cq\t\t= hr_dev->hw->req_notify_cq;\n\tib_dev->poll_cq\t\t\t= hr_dev->hw->poll_cq;\n\n\t/* MR */\n\tib_dev->get_dma_mr\t\t= hns_roce_get_dma_mr;\n\tib_dev->reg_user_mr\t\t= hns_roce_reg_user_mr;\n\tib_dev->dereg_mr\t\t= hns_roce_dereg_mr;\n\tif (hr_dev->caps.flags & HNS_ROCE_CAP_FLAG_REREG_MR) {\n\t\tib_dev->rereg_user_mr\t= hns_roce_rereg_user_mr;\n\t\tib_dev->uverbs_cmd_mask |= (1ULL << IB_USER_VERBS_CMD_REREG_MR);\n\t}\n\n\t/* OTHERS */\n\tib_dev->get_port_immutable\t= hns_roce_port_immutable;\n\n\tret = ib_register_device(ib_dev, NULL);\n\tif (ret) {\n\t\tdev_err(dev, \"ib_register_device failed!\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hns_roce_setup_mtu_mac(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"setup_mtu_mac failed!\\n\");\n\t\tgoto error_failed_setup_mtu_mac;\n\t}\n\n\tiboe->nb.notifier_call = hns_roce_netdev_event;\n\tret = register_netdevice_notifier(&iboe->nb);\n\tif (ret) {\n\t\tdev_err(dev, \"register_netdevice_notifier failed!\\n\");\n\t\tgoto error_failed_setup_mtu_mac;\n\t}\n\n\treturn 0;\n\nerror_failed_setup_mtu_mac:\n\tib_unregister_device(ib_dev);\n\n\treturn ret;\n}\n\nstatic int hns_roce_init_hem(struct hns_roce_dev *hr_dev)\n{\n\tint ret;\n\tstruct device *dev = hr_dev->dev;\n\n\tret = hns_roce_init_hem_table(hr_dev, &hr_dev->mr_table.mtt_table,\n\t\t\t\t      HEM_TYPE_MTT, hr_dev->caps.mtt_entry_sz,\n\t\t\t\t      hr_dev->caps.num_mtt_segs, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to init MTT context memory, aborting.\\n\");\n\t\treturn ret;\n\t}\n\n\tif (hns_roce_check_whether_mhop(hr_dev, HEM_TYPE_CQE)) {\n\t\tret = hns_roce_init_hem_table(hr_dev,\n\t\t\t\t      &hr_dev->mr_table.mtt_cqe_table,\n\t\t\t\t      HEM_TYPE_CQE, hr_dev->caps.mtt_entry_sz,\n\t\t\t\t      hr_dev->caps.num_cqe_segs, 1);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to init MTT CQE context memory, aborting.\\n\");\n\t\t\tgoto err_unmap_cqe;\n\t\t}\n\t}\n\n\tret = hns_roce_init_hem_table(hr_dev, &hr_dev->mr_table.mtpt_table,\n\t\t\t\t      HEM_TYPE_MTPT, hr_dev->caps.mtpt_entry_sz,\n\t\t\t\t      hr_dev->caps.num_mtpts, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to init MTPT context memory, aborting.\\n\");\n\t\tgoto err_unmap_mtt;\n\t}\n\n\tret = hns_roce_init_hem_table(hr_dev, &hr_dev->qp_table.qp_table,\n\t\t\t\t      HEM_TYPE_QPC, hr_dev->caps.qpc_entry_sz,\n\t\t\t\t      hr_dev->caps.num_qps, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to init QP context memory, aborting.\\n\");\n\t\tgoto err_unmap_dmpt;\n\t}\n\n\tret = hns_roce_init_hem_table(hr_dev, &hr_dev->qp_table.irrl_table,\n\t\t\t\t      HEM_TYPE_IRRL,\n\t\t\t\t      hr_dev->caps.irrl_entry_sz *\n\t\t\t\t      hr_dev->caps.max_qp_init_rdma,\n\t\t\t\t      hr_dev->caps.num_qps, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to init irrl_table memory, aborting.\\n\");\n\t\tgoto err_unmap_qp;\n\t}\n\n\tif (hr_dev->caps.trrl_entry_sz) {\n\t\tret = hns_roce_init_hem_table(hr_dev,\n\t\t\t\t\t      &hr_dev->qp_table.trrl_table,\n\t\t\t\t\t      HEM_TYPE_TRRL,\n\t\t\t\t\t      hr_dev->caps.trrl_entry_sz *\n\t\t\t\t\t      hr_dev->caps.max_qp_dest_rdma,\n\t\t\t\t\t      hr_dev->caps.num_qps, 1);\n\t\tif (ret) {\n\t\t\tdev_err(dev,\n\t\t\t       \"Failed to init trrl_table memory, aborting.\\n\");\n\t\t\tgoto err_unmap_irrl;\n\t\t}\n\t}\n\n\tret = hns_roce_init_hem_table(hr_dev, &hr_dev->cq_table.table,\n\t\t\t\t      HEM_TYPE_CQC, hr_dev->caps.cqc_entry_sz,\n\t\t\t\t      hr_dev->caps.num_cqs, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to init CQ context memory, aborting.\\n\");\n\t\tgoto err_unmap_trrl;\n\t}\n\n\treturn 0;\n\nerr_unmap_trrl:\n\tif (hr_dev->caps.trrl_entry_sz)\n\t\thns_roce_cleanup_hem_table(hr_dev,\n\t\t\t\t\t   &hr_dev->qp_table.trrl_table);\n\nerr_unmap_irrl:\n\thns_roce_cleanup_hem_table(hr_dev, &hr_dev->qp_table.irrl_table);\n\nerr_unmap_qp:\n\thns_roce_cleanup_hem_table(hr_dev, &hr_dev->qp_table.qp_table);\n\nerr_unmap_dmpt:\n\thns_roce_cleanup_hem_table(hr_dev, &hr_dev->mr_table.mtpt_table);\n\nerr_unmap_mtt:\n\tif (hns_roce_check_whether_mhop(hr_dev, HEM_TYPE_CQE))\n\t\thns_roce_cleanup_hem_table(hr_dev,\n\t\t\t\t\t   &hr_dev->mr_table.mtt_cqe_table);\n\nerr_unmap_cqe:\n\thns_roce_cleanup_hem_table(hr_dev, &hr_dev->mr_table.mtt_table);\n\n\treturn ret;\n}\n\n/**\n * hns_roce_setup_hca - setup host channel adapter\n * @hr_dev: pointer to hns roce device\n * Return : int\n */\nstatic int hns_roce_setup_hca(struct hns_roce_dev *hr_dev)\n{\n\tint ret;\n\tstruct device *dev = hr_dev->dev;\n\n\tspin_lock_init(&hr_dev->sm_lock);\n\tspin_lock_init(&hr_dev->bt_cmd_lock);\n\n\tif (hr_dev->caps.flags & HNS_ROCE_CAP_FLAG_RECORD_DB) {\n\t\tINIT_LIST_HEAD(&hr_dev->pgdir_list);\n\t\tmutex_init(&hr_dev->pgdir_mutex);\n\t}\n\n\tret = hns_roce_init_uar_table(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to initialize uar table. aborting\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hns_roce_uar_alloc(hr_dev, &hr_dev->priv_uar);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to allocate priv_uar.\\n\");\n\t\tgoto err_uar_table_free;\n\t}\n\n\tret = hns_roce_init_pd_table(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to init protected domain table.\\n\");\n\t\tgoto err_uar_alloc_free;\n\t}\n\n\tret = hns_roce_init_mr_table(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to init memory region table.\\n\");\n\t\tgoto err_pd_table_free;\n\t}\n\n\tret = hns_roce_init_cq_table(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to init completion queue table.\\n\");\n\t\tgoto err_mr_table_free;\n\t}\n\n\tret = hns_roce_init_qp_table(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to init queue pair table.\\n\");\n\t\tgoto err_cq_table_free;\n\t}\n\n\treturn 0;\n\nerr_cq_table_free:\n\thns_roce_cleanup_cq_table(hr_dev);\n\nerr_mr_table_free:\n\thns_roce_cleanup_mr_table(hr_dev);\n\nerr_pd_table_free:\n\thns_roce_cleanup_pd_table(hr_dev);\n\nerr_uar_alloc_free:\n\thns_roce_uar_free(hr_dev, &hr_dev->priv_uar);\n\nerr_uar_table_free:\n\thns_roce_cleanup_uar_table(hr_dev);\n\treturn ret;\n}\n\nint hns_roce_init(struct hns_roce_dev *hr_dev)\n{\n\tint ret;\n\tstruct device *dev = hr_dev->dev;\n\n\tif (hr_dev->hw->reset) {\n\t\tret = hr_dev->hw->reset(hr_dev, true);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Reset RoCE engine failed!\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (hr_dev->hw->cmq_init) {\n\t\tret = hr_dev->hw->cmq_init(hr_dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Init RoCE Command Queue failed!\\n\");\n\t\t\tgoto error_failed_cmq_init;\n\t\t}\n\t}\n\n\tret = hr_dev->hw->hw_profile(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Get RoCE engine profile failed!\\n\");\n\t\tgoto error_failed_cmd_init;\n\t}\n\n\tret = hns_roce_cmd_init(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"cmd init failed!\\n\");\n\t\tgoto error_failed_cmd_init;\n\t}\n\n\tret = hr_dev->hw->init_eq(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"eq init failed!\\n\");\n\t\tgoto error_failed_eq_table;\n\t}\n\n\tif (hr_dev->cmd_mod) {\n\t\tret = hns_roce_cmd_use_events(hr_dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Switch to event-driven cmd failed!\\n\");\n\t\t\tgoto error_failed_use_event;\n\t\t}\n\t}\n\n\tret = hns_roce_init_hem(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"init HEM(Hardware Entry Memory) failed!\\n\");\n\t\tgoto error_failed_init_hem;\n\t}\n\n\tret = hns_roce_setup_hca(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"setup hca failed!\\n\");\n\t\tgoto error_failed_setup_hca;\n\t}\n\n\tif (hr_dev->hw->hw_init) {\n\t\tret = hr_dev->hw->hw_init(hr_dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"hw_init failed!\\n\");\n\t\t\tgoto error_failed_engine_init;\n\t\t}\n\t}\n\n\tret = hns_roce_register_device(hr_dev);\n\tif (ret)\n\t\tgoto error_failed_register_device;\n\n\treturn 0;\n\nerror_failed_register_device:\n\tif (hr_dev->hw->hw_exit)\n\t\thr_dev->hw->hw_exit(hr_dev);\n\nerror_failed_engine_init:\n\thns_roce_cleanup_bitmap(hr_dev);\n\nerror_failed_setup_hca:\n\thns_roce_cleanup_hem(hr_dev);\n\nerror_failed_init_hem:\n\tif (hr_dev->cmd_mod)\n\t\thns_roce_cmd_use_polling(hr_dev);\n\nerror_failed_use_event:\n\thr_dev->hw->cleanup_eq(hr_dev);\n\nerror_failed_eq_table:\n\thns_roce_cmd_cleanup(hr_dev);\n\nerror_failed_cmd_init:\n\tif (hr_dev->hw->cmq_exit)\n\t\thr_dev->hw->cmq_exit(hr_dev);\n\nerror_failed_cmq_init:\n\tif (hr_dev->hw->reset) {\n\t\tret = hr_dev->hw->reset(hr_dev, false);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"Dereset RoCE engine failed!\\n\");\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hns_roce_init);\n\nvoid hns_roce_exit(struct hns_roce_dev *hr_dev)\n{\n\thns_roce_unregister_device(hr_dev);\n\tif (hr_dev->hw->hw_exit)\n\t\thr_dev->hw->hw_exit(hr_dev);\n\thns_roce_cleanup_bitmap(hr_dev);\n\thns_roce_cleanup_hem(hr_dev);\n\n\tif (hr_dev->cmd_mod)\n\t\thns_roce_cmd_use_polling(hr_dev);\n\n\thr_dev->hw->cleanup_eq(hr_dev);\n\thns_roce_cmd_cleanup(hr_dev);\n\tif (hr_dev->hw->cmq_exit)\n\t\thr_dev->hw->cmq_exit(hr_dev);\n\tif (hr_dev->hw->reset)\n\t\thr_dev->hw->reset(hr_dev, false);\n}\nEXPORT_SYMBOL_GPL(hns_roce_exit);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Wei Hu <xavier.huwei@huawei.com>\");\nMODULE_AUTHOR(\"Nenglong Zhao <zhaonenglong@hisilicon.com>\");\nMODULE_AUTHOR(\"Lijun Ou <oulijun@huawei.com>\");\nMODULE_DESCRIPTION(\"HNS RoCE Driver\");\n"], "fixing_code": ["/*\n * Copyright (c) 2016 Hisilicon Limited.\n * Copyright (c) 2007, 2008 Mellanox Technologies. All rights reserved.\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * OpenIB.org BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#include <linux/acpi.h>\n#include <linux/of_platform.h>\n#include <linux/module.h>\n#include <rdma/ib_addr.h>\n#include <rdma/ib_smi.h>\n#include <rdma/ib_user_verbs.h>\n#include <rdma/ib_cache.h>\n#include \"hns_roce_common.h\"\n#include \"hns_roce_device.h\"\n#include <rdma/hns-abi.h>\n#include \"hns_roce_hem.h\"\n\n/**\n * hns_get_gid_index - Get gid index.\n * @hr_dev: pointer to structure hns_roce_dev.\n * @port:  port, value range: 0 ~ MAX\n * @gid_index:  gid_index, value range: 0 ~ MAX\n * Description:\n *    N ports shared gids, allocation method as follow:\n *\t\tGID[0][0], GID[1][0],.....GID[N - 1][0],\n *\t\tGID[0][0], GID[1][0],.....GID[N - 1][0],\n *\t\tAnd so on\n */\nint hns_get_gid_index(struct hns_roce_dev *hr_dev, u8 port, int gid_index)\n{\n\treturn gid_index * hr_dev->caps.num_ports + port;\n}\nEXPORT_SYMBOL_GPL(hns_get_gid_index);\n\nstatic int hns_roce_set_mac(struct hns_roce_dev *hr_dev, u8 port, u8 *addr)\n{\n\tu8 phy_port;\n\tu32 i = 0;\n\n\tif (!memcmp(hr_dev->dev_addr[port], addr, MAC_ADDR_OCTET_NUM))\n\t\treturn 0;\n\n\tfor (i = 0; i < MAC_ADDR_OCTET_NUM; i++)\n\t\thr_dev->dev_addr[port][i] = addr[i];\n\n\tphy_port = hr_dev->iboe.phy_port[port];\n\treturn hr_dev->hw->set_mac(hr_dev, phy_port, addr);\n}\n\nstatic int hns_roce_add_gid(struct ib_device *device, u8 port_num,\n\t\t\t    unsigned int index, const union ib_gid *gid,\n\t\t\t    const struct ib_gid_attr *attr, void **context)\n{\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(device);\n\tu8 port = port_num - 1;\n\tunsigned long flags;\n\tint ret;\n\n\tif (port >= hr_dev->caps.num_ports)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&hr_dev->iboe.lock, flags);\n\n\tret = hr_dev->hw->set_gid(hr_dev, port, index, (union ib_gid *)gid,\n\t\t\t\t   attr);\n\n\tspin_unlock_irqrestore(&hr_dev->iboe.lock, flags);\n\n\treturn ret;\n}\n\nstatic int hns_roce_del_gid(struct ib_device *device, u8 port_num,\n\t\t\t    unsigned int index, void **context)\n{\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(device);\n\tstruct ib_gid_attr zattr = { };\n\tunion ib_gid zgid = { {0} };\n\tu8 port = port_num - 1;\n\tunsigned long flags;\n\tint ret;\n\n\tif (port >= hr_dev->caps.num_ports)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&hr_dev->iboe.lock, flags);\n\n\tret = hr_dev->hw->set_gid(hr_dev, port, index, &zgid, &zattr);\n\n\tspin_unlock_irqrestore(&hr_dev->iboe.lock, flags);\n\n\treturn ret;\n}\n\nstatic int handle_en_event(struct hns_roce_dev *hr_dev, u8 port,\n\t\t\t   unsigned long event)\n{\n\tstruct device *dev = hr_dev->dev;\n\tstruct net_device *netdev;\n\tint ret = 0;\n\n\tnetdev = hr_dev->iboe.netdevs[port];\n\tif (!netdev) {\n\t\tdev_err(dev, \"port(%d) can't find netdev\\n\", port);\n\t\treturn -ENODEV;\n\t}\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\tcase NETDEV_CHANGE:\n\tcase NETDEV_REGISTER:\n\tcase NETDEV_CHANGEADDR:\n\t\tret = hns_roce_set_mac(hr_dev, port, netdev->dev_addr);\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\t/*\n\t\t * In v1 engine, only support all ports closed together.\n\t\t */\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, \"NETDEV event = 0x%x!\\n\", (u32)(event));\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int hns_roce_netdev_event(struct notifier_block *self,\n\t\t\t\t unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct hns_roce_ib_iboe *iboe = NULL;\n\tstruct hns_roce_dev *hr_dev = NULL;\n\tu8 port = 0;\n\tint ret = 0;\n\n\thr_dev = container_of(self, struct hns_roce_dev, iboe.nb);\n\tiboe = &hr_dev->iboe;\n\n\tfor (port = 0; port < hr_dev->caps.num_ports; port++) {\n\t\tif (dev == iboe->netdevs[port]) {\n\t\t\tret = handle_en_event(hr_dev, port, event);\n\t\t\tif (ret)\n\t\t\t\treturn NOTIFY_DONE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int hns_roce_setup_mtu_mac(struct hns_roce_dev *hr_dev)\n{\n\tint ret;\n\tu8 i;\n\n\tfor (i = 0; i < hr_dev->caps.num_ports; i++) {\n\t\tif (hr_dev->hw->set_mtu)\n\t\t\thr_dev->hw->set_mtu(hr_dev, hr_dev->iboe.phy_port[i],\n\t\t\t\t\t    hr_dev->caps.max_mtu);\n\t\tret = hns_roce_set_mac(hr_dev, i,\n\t\t\t\t       hr_dev->iboe.netdevs[i]->dev_addr);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int hns_roce_query_device(struct ib_device *ib_dev,\n\t\t\t\t struct ib_device_attr *props,\n\t\t\t\t struct ib_udata *uhw)\n{\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);\n\n\tmemset(props, 0, sizeof(*props));\n\n\tprops->sys_image_guid = cpu_to_be32(hr_dev->sys_image_guid);\n\tprops->max_mr_size = (u64)(~(0ULL));\n\tprops->page_size_cap = hr_dev->caps.page_size_cap;\n\tprops->vendor_id = hr_dev->vendor_id;\n\tprops->vendor_part_id = hr_dev->vendor_part_id;\n\tprops->hw_ver = hr_dev->hw_rev;\n\tprops->max_qp = hr_dev->caps.num_qps;\n\tprops->max_qp_wr = hr_dev->caps.max_wqes;\n\tprops->device_cap_flags = IB_DEVICE_PORT_ACTIVE_EVENT |\n\t\t\t\t  IB_DEVICE_RC_RNR_NAK_GEN;\n\tprops->max_sge = max(hr_dev->caps.max_sq_sg, hr_dev->caps.max_rq_sg);\n\tprops->max_sge_rd = 1;\n\tprops->max_cq = hr_dev->caps.num_cqs;\n\tprops->max_cqe = hr_dev->caps.max_cqes;\n\tprops->max_mr = hr_dev->caps.num_mtpts;\n\tprops->max_pd = hr_dev->caps.num_pds;\n\tprops->max_qp_rd_atom = hr_dev->caps.max_qp_dest_rdma;\n\tprops->max_qp_init_rd_atom = hr_dev->caps.max_qp_init_rdma;\n\tprops->atomic_cap = IB_ATOMIC_NONE;\n\tprops->max_pkeys = 1;\n\tprops->local_ca_ack_delay = hr_dev->caps.local_ca_ack_delay;\n\n\treturn 0;\n}\n\nstatic struct net_device *hns_roce_get_netdev(struct ib_device *ib_dev,\n\t\t\t\t\t      u8 port_num)\n{\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);\n\tstruct net_device *ndev;\n\n\tif (port_num < 1 || port_num > hr_dev->caps.num_ports)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\n\tndev = hr_dev->iboe.netdevs[port_num - 1];\n\tif (ndev)\n\t\tdev_hold(ndev);\n\n\trcu_read_unlock();\n\treturn ndev;\n}\n\nstatic int hns_roce_query_port(struct ib_device *ib_dev, u8 port_num,\n\t\t\t       struct ib_port_attr *props)\n{\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);\n\tstruct device *dev = hr_dev->dev;\n\tstruct net_device *net_dev;\n\tunsigned long flags;\n\tenum ib_mtu mtu;\n\tu8 port;\n\n\tassert(port_num > 0);\n\tport = port_num - 1;\n\n\t/* props being zeroed by the caller, avoid zeroing it here */\n\n\tprops->max_mtu = hr_dev->caps.max_mtu;\n\tprops->gid_tbl_len = hr_dev->caps.gid_table_len[port];\n\tprops->port_cap_flags = IB_PORT_CM_SUP | IB_PORT_REINIT_SUP |\n\t\t\t\tIB_PORT_VENDOR_CLASS_SUP |\n\t\t\t\tIB_PORT_BOOT_MGMT_SUP;\n\tprops->max_msg_sz = HNS_ROCE_MAX_MSG_LEN;\n\tprops->pkey_tbl_len = 1;\n\tprops->active_width = IB_WIDTH_4X;\n\tprops->active_speed = 1;\n\n\tspin_lock_irqsave(&hr_dev->iboe.lock, flags);\n\n\tnet_dev = hr_dev->iboe.netdevs[port];\n\tif (!net_dev) {\n\t\tspin_unlock_irqrestore(&hr_dev->iboe.lock, flags);\n\t\tdev_err(dev, \"find netdev %d failed!\\r\\n\", port);\n\t\treturn -EINVAL;\n\t}\n\n\tmtu = iboe_get_mtu(net_dev->mtu);\n\tprops->active_mtu = mtu ? min(props->max_mtu, mtu) : IB_MTU_256;\n\tprops->state = (netif_running(net_dev) && netif_carrier_ok(net_dev)) ?\n\t\t\tIB_PORT_ACTIVE : IB_PORT_DOWN;\n\tprops->phys_state = (props->state == IB_PORT_ACTIVE) ? 5 : 3;\n\n\tspin_unlock_irqrestore(&hr_dev->iboe.lock, flags);\n\n\treturn 0;\n}\n\nstatic enum rdma_link_layer hns_roce_get_link_layer(struct ib_device *device,\n\t\t\t\t\t\t    u8 port_num)\n{\n\treturn IB_LINK_LAYER_ETHERNET;\n}\n\nstatic int hns_roce_query_gid(struct ib_device *ib_dev, u8 port_num, int index,\n\t\t\t      union ib_gid *gid)\n{\n\treturn 0;\n}\n\nstatic int hns_roce_query_pkey(struct ib_device *ib_dev, u8 port, u16 index,\n\t\t\t       u16 *pkey)\n{\n\t*pkey = PKEY_ID;\n\n\treturn 0;\n}\n\nstatic int hns_roce_modify_device(struct ib_device *ib_dev, int mask,\n\t\t\t\t  struct ib_device_modify *props)\n{\n\tunsigned long flags;\n\n\tif (mask & ~IB_DEVICE_MODIFY_NODE_DESC)\n\t\treturn -EOPNOTSUPP;\n\n\tif (mask & IB_DEVICE_MODIFY_NODE_DESC) {\n\t\tspin_lock_irqsave(&to_hr_dev(ib_dev)->sm_lock, flags);\n\t\tmemcpy(ib_dev->node_desc, props->node_desc, NODE_DESC_SIZE);\n\t\tspin_unlock_irqrestore(&to_hr_dev(ib_dev)->sm_lock, flags);\n\t}\n\n\treturn 0;\n}\n\nstatic int hns_roce_modify_port(struct ib_device *ib_dev, u8 port_num, int mask,\n\t\t\t\tstruct ib_port_modify *props)\n{\n\treturn 0;\n}\n\nstatic struct ib_ucontext *hns_roce_alloc_ucontext(struct ib_device *ib_dev,\n\t\t\t\t\t\t   struct ib_udata *udata)\n{\n\tint ret = 0;\n\tstruct hns_roce_ucontext *context;\n\tstruct hns_roce_ib_alloc_ucontext_resp resp = {};\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);\n\n\tresp.qp_tab_size = hr_dev->caps.num_qps;\n\n\tcontext = kmalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = hns_roce_uar_alloc(hr_dev, &context->uar);\n\tif (ret)\n\t\tgoto error_fail_uar_alloc;\n\n\tif (hr_dev->caps.flags & HNS_ROCE_CAP_FLAG_RECORD_DB) {\n\t\tINIT_LIST_HEAD(&context->page_list);\n\t\tmutex_init(&context->page_mutex);\n\t}\n\n\tret = ib_copy_to_udata(udata, &resp, sizeof(resp));\n\tif (ret)\n\t\tgoto error_fail_copy_to_udata;\n\n\treturn &context->ibucontext;\n\nerror_fail_copy_to_udata:\n\thns_roce_uar_free(hr_dev, &context->uar);\n\nerror_fail_uar_alloc:\n\tkfree(context);\n\n\treturn ERR_PTR(ret);\n}\n\nstatic int hns_roce_dealloc_ucontext(struct ib_ucontext *ibcontext)\n{\n\tstruct hns_roce_ucontext *context = to_hr_ucontext(ibcontext);\n\n\thns_roce_uar_free(to_hr_dev(ibcontext->device), &context->uar);\n\tkfree(context);\n\n\treturn 0;\n}\n\nstatic int hns_roce_mmap(struct ib_ucontext *context,\n\t\t\t struct vm_area_struct *vma)\n{\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(context->device);\n\n\tif (((vma->vm_end - vma->vm_start) % PAGE_SIZE) != 0)\n\t\treturn -EINVAL;\n\n\tif (vma->vm_pgoff == 0) {\n\t\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\t\tif (io_remap_pfn_range(vma, vma->vm_start,\n\t\t\t\t       to_hr_ucontext(context)->uar.pfn,\n\t\t\t\t       PAGE_SIZE, vma->vm_page_prot))\n\t\t\treturn -EAGAIN;\n\t} else if (vma->vm_pgoff == 1 && hr_dev->tptr_dma_addr &&\n\t\t   hr_dev->tptr_size) {\n\t\t/* vm_pgoff: 1 -- TPTR */\n\t\tif (io_remap_pfn_range(vma, vma->vm_start,\n\t\t\t\t       hr_dev->tptr_dma_addr >> PAGE_SHIFT,\n\t\t\t\t       hr_dev->tptr_size,\n\t\t\t\t       vma->vm_page_prot))\n\t\t\treturn -EAGAIN;\n\t} else\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int hns_roce_port_immutable(struct ib_device *ib_dev, u8 port_num,\n\t\t\t\t   struct ib_port_immutable *immutable)\n{\n\tstruct ib_port_attr attr;\n\tint ret;\n\n\tret = ib_query_port(ib_dev, port_num, &attr);\n\tif (ret)\n\t\treturn ret;\n\n\timmutable->pkey_tbl_len = attr.pkey_tbl_len;\n\timmutable->gid_tbl_len = attr.gid_tbl_len;\n\n\timmutable->max_mad_size = IB_MGMT_MAD_SIZE;\n\timmutable->core_cap_flags = RDMA_CORE_PORT_IBA_ROCE;\n\tif (to_hr_dev(ib_dev)->caps.flags & HNS_ROCE_CAP_FLAG_ROCE_V1_V2)\n\t\timmutable->core_cap_flags |= RDMA_CORE_PORT_IBA_ROCE_UDP_ENCAP;\n\n\treturn 0;\n}\n\nstatic void hns_roce_unregister_device(struct hns_roce_dev *hr_dev)\n{\n\tstruct hns_roce_ib_iboe *iboe = &hr_dev->iboe;\n\n\tunregister_netdevice_notifier(&iboe->nb);\n\tib_unregister_device(&hr_dev->ib_dev);\n}\n\nstatic int hns_roce_register_device(struct hns_roce_dev *hr_dev)\n{\n\tint ret;\n\tstruct hns_roce_ib_iboe *iboe = NULL;\n\tstruct ib_device *ib_dev = NULL;\n\tstruct device *dev = hr_dev->dev;\n\n\tiboe = &hr_dev->iboe;\n\tspin_lock_init(&iboe->lock);\n\n\tib_dev = &hr_dev->ib_dev;\n\tstrlcpy(ib_dev->name, \"hns_%d\", IB_DEVICE_NAME_MAX);\n\n\tib_dev->owner\t\t\t= THIS_MODULE;\n\tib_dev->node_type\t\t= RDMA_NODE_IB_CA;\n\tib_dev->dev.parent\t\t= dev;\n\n\tib_dev->phys_port_cnt\t\t= hr_dev->caps.num_ports;\n\tib_dev->local_dma_lkey\t\t= hr_dev->caps.reserved_lkey;\n\tib_dev->num_comp_vectors\t= hr_dev->caps.num_comp_vectors;\n\tib_dev->uverbs_abi_ver\t\t= 1;\n\tib_dev->uverbs_cmd_mask\t\t=\n\t\t(1ULL << IB_USER_VERBS_CMD_GET_CONTEXT) |\n\t\t(1ULL << IB_USER_VERBS_CMD_QUERY_DEVICE) |\n\t\t(1ULL << IB_USER_VERBS_CMD_QUERY_PORT) |\n\t\t(1ULL << IB_USER_VERBS_CMD_ALLOC_PD) |\n\t\t(1ULL << IB_USER_VERBS_CMD_DEALLOC_PD) |\n\t\t(1ULL << IB_USER_VERBS_CMD_REG_MR) |\n\t\t(1ULL << IB_USER_VERBS_CMD_DEREG_MR) |\n\t\t(1ULL << IB_USER_VERBS_CMD_CREATE_COMP_CHANNEL) |\n\t\t(1ULL << IB_USER_VERBS_CMD_CREATE_CQ) |\n\t\t(1ULL << IB_USER_VERBS_CMD_DESTROY_CQ) |\n\t\t(1ULL << IB_USER_VERBS_CMD_CREATE_QP) |\n\t\t(1ULL << IB_USER_VERBS_CMD_MODIFY_QP) |\n\t\t(1ULL << IB_USER_VERBS_CMD_QUERY_QP) |\n\t\t(1ULL << IB_USER_VERBS_CMD_DESTROY_QP);\n\n\t/* HCA||device||port */\n\tib_dev->modify_device\t\t= hns_roce_modify_device;\n\tib_dev->query_device\t\t= hns_roce_query_device;\n\tib_dev->query_port\t\t= hns_roce_query_port;\n\tib_dev->modify_port\t\t= hns_roce_modify_port;\n\tib_dev->get_link_layer\t\t= hns_roce_get_link_layer;\n\tib_dev->get_netdev\t\t= hns_roce_get_netdev;\n\tib_dev->query_gid\t\t= hns_roce_query_gid;\n\tib_dev->add_gid\t\t\t= hns_roce_add_gid;\n\tib_dev->del_gid\t\t\t= hns_roce_del_gid;\n\tib_dev->query_pkey\t\t= hns_roce_query_pkey;\n\tib_dev->alloc_ucontext\t\t= hns_roce_alloc_ucontext;\n\tib_dev->dealloc_ucontext\t= hns_roce_dealloc_ucontext;\n\tib_dev->mmap\t\t\t= hns_roce_mmap;\n\n\t/* PD */\n\tib_dev->alloc_pd\t\t= hns_roce_alloc_pd;\n\tib_dev->dealloc_pd\t\t= hns_roce_dealloc_pd;\n\n\t/* AH */\n\tib_dev->create_ah\t\t= hns_roce_create_ah;\n\tib_dev->query_ah\t\t= hns_roce_query_ah;\n\tib_dev->destroy_ah\t\t= hns_roce_destroy_ah;\n\n\t/* QP */\n\tib_dev->create_qp\t\t= hns_roce_create_qp;\n\tib_dev->modify_qp\t\t= hns_roce_modify_qp;\n\tib_dev->query_qp\t\t= hr_dev->hw->query_qp;\n\tib_dev->destroy_qp\t\t= hr_dev->hw->destroy_qp;\n\tib_dev->post_send\t\t= hr_dev->hw->post_send;\n\tib_dev->post_recv\t\t= hr_dev->hw->post_recv;\n\n\t/* CQ */\n\tib_dev->create_cq\t\t= hns_roce_ib_create_cq;\n\tib_dev->modify_cq\t\t= hr_dev->hw->modify_cq;\n\tib_dev->destroy_cq\t\t= hns_roce_ib_destroy_cq;\n\tib_dev->req_notify_cq\t\t= hr_dev->hw->req_notify_cq;\n\tib_dev->poll_cq\t\t\t= hr_dev->hw->poll_cq;\n\n\t/* MR */\n\tib_dev->get_dma_mr\t\t= hns_roce_get_dma_mr;\n\tib_dev->reg_user_mr\t\t= hns_roce_reg_user_mr;\n\tib_dev->dereg_mr\t\t= hns_roce_dereg_mr;\n\tif (hr_dev->caps.flags & HNS_ROCE_CAP_FLAG_REREG_MR) {\n\t\tib_dev->rereg_user_mr\t= hns_roce_rereg_user_mr;\n\t\tib_dev->uverbs_cmd_mask |= (1ULL << IB_USER_VERBS_CMD_REREG_MR);\n\t}\n\n\t/* OTHERS */\n\tib_dev->get_port_immutable\t= hns_roce_port_immutable;\n\n\tret = ib_register_device(ib_dev, NULL);\n\tif (ret) {\n\t\tdev_err(dev, \"ib_register_device failed!\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hns_roce_setup_mtu_mac(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"setup_mtu_mac failed!\\n\");\n\t\tgoto error_failed_setup_mtu_mac;\n\t}\n\n\tiboe->nb.notifier_call = hns_roce_netdev_event;\n\tret = register_netdevice_notifier(&iboe->nb);\n\tif (ret) {\n\t\tdev_err(dev, \"register_netdevice_notifier failed!\\n\");\n\t\tgoto error_failed_setup_mtu_mac;\n\t}\n\n\treturn 0;\n\nerror_failed_setup_mtu_mac:\n\tib_unregister_device(ib_dev);\n\n\treturn ret;\n}\n\nstatic int hns_roce_init_hem(struct hns_roce_dev *hr_dev)\n{\n\tint ret;\n\tstruct device *dev = hr_dev->dev;\n\n\tret = hns_roce_init_hem_table(hr_dev, &hr_dev->mr_table.mtt_table,\n\t\t\t\t      HEM_TYPE_MTT, hr_dev->caps.mtt_entry_sz,\n\t\t\t\t      hr_dev->caps.num_mtt_segs, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to init MTT context memory, aborting.\\n\");\n\t\treturn ret;\n\t}\n\n\tif (hns_roce_check_whether_mhop(hr_dev, HEM_TYPE_CQE)) {\n\t\tret = hns_roce_init_hem_table(hr_dev,\n\t\t\t\t      &hr_dev->mr_table.mtt_cqe_table,\n\t\t\t\t      HEM_TYPE_CQE, hr_dev->caps.mtt_entry_sz,\n\t\t\t\t      hr_dev->caps.num_cqe_segs, 1);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to init MTT CQE context memory, aborting.\\n\");\n\t\t\tgoto err_unmap_cqe;\n\t\t}\n\t}\n\n\tret = hns_roce_init_hem_table(hr_dev, &hr_dev->mr_table.mtpt_table,\n\t\t\t\t      HEM_TYPE_MTPT, hr_dev->caps.mtpt_entry_sz,\n\t\t\t\t      hr_dev->caps.num_mtpts, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to init MTPT context memory, aborting.\\n\");\n\t\tgoto err_unmap_mtt;\n\t}\n\n\tret = hns_roce_init_hem_table(hr_dev, &hr_dev->qp_table.qp_table,\n\t\t\t\t      HEM_TYPE_QPC, hr_dev->caps.qpc_entry_sz,\n\t\t\t\t      hr_dev->caps.num_qps, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to init QP context memory, aborting.\\n\");\n\t\tgoto err_unmap_dmpt;\n\t}\n\n\tret = hns_roce_init_hem_table(hr_dev, &hr_dev->qp_table.irrl_table,\n\t\t\t\t      HEM_TYPE_IRRL,\n\t\t\t\t      hr_dev->caps.irrl_entry_sz *\n\t\t\t\t      hr_dev->caps.max_qp_init_rdma,\n\t\t\t\t      hr_dev->caps.num_qps, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to init irrl_table memory, aborting.\\n\");\n\t\tgoto err_unmap_qp;\n\t}\n\n\tif (hr_dev->caps.trrl_entry_sz) {\n\t\tret = hns_roce_init_hem_table(hr_dev,\n\t\t\t\t\t      &hr_dev->qp_table.trrl_table,\n\t\t\t\t\t      HEM_TYPE_TRRL,\n\t\t\t\t\t      hr_dev->caps.trrl_entry_sz *\n\t\t\t\t\t      hr_dev->caps.max_qp_dest_rdma,\n\t\t\t\t\t      hr_dev->caps.num_qps, 1);\n\t\tif (ret) {\n\t\t\tdev_err(dev,\n\t\t\t       \"Failed to init trrl_table memory, aborting.\\n\");\n\t\t\tgoto err_unmap_irrl;\n\t\t}\n\t}\n\n\tret = hns_roce_init_hem_table(hr_dev, &hr_dev->cq_table.table,\n\t\t\t\t      HEM_TYPE_CQC, hr_dev->caps.cqc_entry_sz,\n\t\t\t\t      hr_dev->caps.num_cqs, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to init CQ context memory, aborting.\\n\");\n\t\tgoto err_unmap_trrl;\n\t}\n\n\treturn 0;\n\nerr_unmap_trrl:\n\tif (hr_dev->caps.trrl_entry_sz)\n\t\thns_roce_cleanup_hem_table(hr_dev,\n\t\t\t\t\t   &hr_dev->qp_table.trrl_table);\n\nerr_unmap_irrl:\n\thns_roce_cleanup_hem_table(hr_dev, &hr_dev->qp_table.irrl_table);\n\nerr_unmap_qp:\n\thns_roce_cleanup_hem_table(hr_dev, &hr_dev->qp_table.qp_table);\n\nerr_unmap_dmpt:\n\thns_roce_cleanup_hem_table(hr_dev, &hr_dev->mr_table.mtpt_table);\n\nerr_unmap_mtt:\n\tif (hns_roce_check_whether_mhop(hr_dev, HEM_TYPE_CQE))\n\t\thns_roce_cleanup_hem_table(hr_dev,\n\t\t\t\t\t   &hr_dev->mr_table.mtt_cqe_table);\n\nerr_unmap_cqe:\n\thns_roce_cleanup_hem_table(hr_dev, &hr_dev->mr_table.mtt_table);\n\n\treturn ret;\n}\n\n/**\n * hns_roce_setup_hca - setup host channel adapter\n * @hr_dev: pointer to hns roce device\n * Return : int\n */\nstatic int hns_roce_setup_hca(struct hns_roce_dev *hr_dev)\n{\n\tint ret;\n\tstruct device *dev = hr_dev->dev;\n\n\tspin_lock_init(&hr_dev->sm_lock);\n\tspin_lock_init(&hr_dev->bt_cmd_lock);\n\n\tif (hr_dev->caps.flags & HNS_ROCE_CAP_FLAG_RECORD_DB) {\n\t\tINIT_LIST_HEAD(&hr_dev->pgdir_list);\n\t\tmutex_init(&hr_dev->pgdir_mutex);\n\t}\n\n\tret = hns_roce_init_uar_table(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to initialize uar table. aborting\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hns_roce_uar_alloc(hr_dev, &hr_dev->priv_uar);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to allocate priv_uar.\\n\");\n\t\tgoto err_uar_table_free;\n\t}\n\n\tret = hns_roce_init_pd_table(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to init protected domain table.\\n\");\n\t\tgoto err_uar_alloc_free;\n\t}\n\n\tret = hns_roce_init_mr_table(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to init memory region table.\\n\");\n\t\tgoto err_pd_table_free;\n\t}\n\n\tret = hns_roce_init_cq_table(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to init completion queue table.\\n\");\n\t\tgoto err_mr_table_free;\n\t}\n\n\tret = hns_roce_init_qp_table(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to init queue pair table.\\n\");\n\t\tgoto err_cq_table_free;\n\t}\n\n\treturn 0;\n\nerr_cq_table_free:\n\thns_roce_cleanup_cq_table(hr_dev);\n\nerr_mr_table_free:\n\thns_roce_cleanup_mr_table(hr_dev);\n\nerr_pd_table_free:\n\thns_roce_cleanup_pd_table(hr_dev);\n\nerr_uar_alloc_free:\n\thns_roce_uar_free(hr_dev, &hr_dev->priv_uar);\n\nerr_uar_table_free:\n\thns_roce_cleanup_uar_table(hr_dev);\n\treturn ret;\n}\n\nint hns_roce_init(struct hns_roce_dev *hr_dev)\n{\n\tint ret;\n\tstruct device *dev = hr_dev->dev;\n\n\tif (hr_dev->hw->reset) {\n\t\tret = hr_dev->hw->reset(hr_dev, true);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Reset RoCE engine failed!\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (hr_dev->hw->cmq_init) {\n\t\tret = hr_dev->hw->cmq_init(hr_dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Init RoCE Command Queue failed!\\n\");\n\t\t\tgoto error_failed_cmq_init;\n\t\t}\n\t}\n\n\tret = hr_dev->hw->hw_profile(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Get RoCE engine profile failed!\\n\");\n\t\tgoto error_failed_cmd_init;\n\t}\n\n\tret = hns_roce_cmd_init(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"cmd init failed!\\n\");\n\t\tgoto error_failed_cmd_init;\n\t}\n\n\tret = hr_dev->hw->init_eq(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"eq init failed!\\n\");\n\t\tgoto error_failed_eq_table;\n\t}\n\n\tif (hr_dev->cmd_mod) {\n\t\tret = hns_roce_cmd_use_events(hr_dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Switch to event-driven cmd failed!\\n\");\n\t\t\tgoto error_failed_use_event;\n\t\t}\n\t}\n\n\tret = hns_roce_init_hem(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"init HEM(Hardware Entry Memory) failed!\\n\");\n\t\tgoto error_failed_init_hem;\n\t}\n\n\tret = hns_roce_setup_hca(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"setup hca failed!\\n\");\n\t\tgoto error_failed_setup_hca;\n\t}\n\n\tif (hr_dev->hw->hw_init) {\n\t\tret = hr_dev->hw->hw_init(hr_dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"hw_init failed!\\n\");\n\t\t\tgoto error_failed_engine_init;\n\t\t}\n\t}\n\n\tret = hns_roce_register_device(hr_dev);\n\tif (ret)\n\t\tgoto error_failed_register_device;\n\n\treturn 0;\n\nerror_failed_register_device:\n\tif (hr_dev->hw->hw_exit)\n\t\thr_dev->hw->hw_exit(hr_dev);\n\nerror_failed_engine_init:\n\thns_roce_cleanup_bitmap(hr_dev);\n\nerror_failed_setup_hca:\n\thns_roce_cleanup_hem(hr_dev);\n\nerror_failed_init_hem:\n\tif (hr_dev->cmd_mod)\n\t\thns_roce_cmd_use_polling(hr_dev);\n\nerror_failed_use_event:\n\thr_dev->hw->cleanup_eq(hr_dev);\n\nerror_failed_eq_table:\n\thns_roce_cmd_cleanup(hr_dev);\n\nerror_failed_cmd_init:\n\tif (hr_dev->hw->cmq_exit)\n\t\thr_dev->hw->cmq_exit(hr_dev);\n\nerror_failed_cmq_init:\n\tif (hr_dev->hw->reset) {\n\t\tret = hr_dev->hw->reset(hr_dev, false);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"Dereset RoCE engine failed!\\n\");\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hns_roce_init);\n\nvoid hns_roce_exit(struct hns_roce_dev *hr_dev)\n{\n\thns_roce_unregister_device(hr_dev);\n\tif (hr_dev->hw->hw_exit)\n\t\thr_dev->hw->hw_exit(hr_dev);\n\thns_roce_cleanup_bitmap(hr_dev);\n\thns_roce_cleanup_hem(hr_dev);\n\n\tif (hr_dev->cmd_mod)\n\t\thns_roce_cmd_use_polling(hr_dev);\n\n\thr_dev->hw->cleanup_eq(hr_dev);\n\thns_roce_cmd_cleanup(hr_dev);\n\tif (hr_dev->hw->cmq_exit)\n\t\thr_dev->hw->cmq_exit(hr_dev);\n\tif (hr_dev->hw->reset)\n\t\thr_dev->hw->reset(hr_dev, false);\n}\nEXPORT_SYMBOL_GPL(hns_roce_exit);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Wei Hu <xavier.huwei@huawei.com>\");\nMODULE_AUTHOR(\"Nenglong Zhao <zhaonenglong@hisilicon.com>\");\nMODULE_AUTHOR(\"Lijun Ou <oulijun@huawei.com>\");\nMODULE_DESCRIPTION(\"HNS RoCE Driver\");\n"], "filenames": ["drivers/infiniband/hw/hns/hns_roce_main.c"], "buggy_code_start_loc": [341], "buggy_code_end_loc": [342], "fixing_code_start_loc": [341], "fixing_code_end_loc": [342], "type": "CWE-665", "message": "In the Linux kernel before 4.17, hns_roce_alloc_ucontext in drivers/infiniband/hw/hns/hns_roce_main.c does not initialize the resp data structure, which might allow attackers to obtain sensitive information from kernel stack memory, aka CID-df7e40425813.", "other": {"cve": {"id": "CVE-2019-16921", "sourceIdentifier": "cve@mitre.org", "published": "2019-09-27T13:15:10.553", "lastModified": "2019-09-27T20:22:06.173", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 4.17, hns_roce_alloc_ucontext in drivers/infiniband/hw/hns/hns_roce_main.c does not initialize the resp data structure, which might allow attackers to obtain sensitive information from kernel stack memory, aka CID-df7e40425813."}, {"lang": "es", "value": "En el kernel de Linux versiones anteriores a 4.17, la funci\u00f3n hns_roce_alloc_ucontext en el archivo drivers/infiniband/hw/hns/hns_roce_main.c no inicializa la estructura de datos resp, lo que podr\u00eda permitir a atacantes obtener informaci\u00f3n confidencial de la memoria de la pila del kernel, tambi\u00e9n se conoce como CID-df7e40425813."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-665"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.17", "matchCriteriaId": "0667D0B1-8AC7-46D8-BB4B-68157115D405"}]}]}], "references": [{"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=df7e40425813c50cd252e6f5e348a81ef1acae56", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/df7e40425813c50cd252e6f5e348a81ef1acae56", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/df7e40425813c50cd252e6f5e348a81ef1acae56"}}