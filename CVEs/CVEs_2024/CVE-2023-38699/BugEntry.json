{"buggy_code": ["from typing import Optional\nfrom collections import OrderedDict\n\nimport json\nimport time\nimport requests\nimport pandas as pd\n\nfrom mindsdb_sql import parse_sql\nfrom mindsdb_sql.render.sqlalchemy_render import SqlalchemyRender\nfrom mindsdb.integrations.libs.base import DatabaseHandler\nfrom sqlalchemy_dremio.base import DremioDialect\n\nfrom mindsdb_sql.parser.ast.base import ASTNode\n\nfrom mindsdb.utilities import log\nfrom mindsdb.integrations.libs.response import (\n    HandlerStatusResponse as StatusResponse,\n    HandlerResponse as Response,\n    RESPONSE_TYPE\n)\nfrom mindsdb.integrations.libs.const import HANDLER_CONNECTION_ARG_TYPE as ARG_TYPE\n\n\nclass DremioHandler(DatabaseHandler):\n    \"\"\"\n    This handler handles connection and execution of the Dremio statements.\n    \"\"\"\n\n    name = 'dremio'\n\n    def __init__(self, name: str, connection_data: Optional[dict], **kwargs):\n        \"\"\"\n        Initialize the handler.\n        Args:\n            name (str): name of particular handler instance\n            connection_data (dict): parameters for connecting to the database\n            **kwargs: arbitrary keyword arguments.\n        \"\"\"\n        super().__init__(name)\n        self.parser = parse_sql\n        self.dialect = 'dremio'\n\n        self.connection_data = connection_data\n        self.kwargs = kwargs\n\n        self.base_url = f\"http://{self.connection_data['host']}:{self.connection_data['port']}\"\n\n        self.connection = None\n        self.is_connected = False\n\n    def __del__(self):\n        if self.is_connected is True:\n            self.disconnect()\n\n    def connect(self) -> dict:\n        \"\"\"\n        Set up the connection required by the handler.\n        Returns:\n            HandlerStatusResponse\n        \"\"\"\n\n        headers = {\n            'Content-Type': 'application/json',\n        }\n\n        data = '{' + f'\"userName\": \"{self.connection_data[\"username\"]}\",\"password\": \"{self.connection_data[\"password\"]}\"' + '}'\n\n        response = requests.post(self.base_url + '/apiv2/login', headers=headers, data=data, verify=False)\n\n        return {\n            'Authorization': '_dremio' + response.json()['token'],\n            'Content-Type': 'application/json',\n        }\n\n    def disconnect(self):\n        \"\"\"\n        Close any existing connections.\n        \"\"\"\n\n        self.is_connected = False\n        return\n\n    def check_connection(self) -> StatusResponse:\n        \"\"\"\n        Check connection to the handler.\n        Returns:\n            HandlerStatusResponse\n        \"\"\"\n\n        response = StatusResponse(False)\n        need_to_close = self.is_connected is False\n\n        try:\n            self.connect()\n            response.success = True\n        except Exception as e:\n            log.logger.error(f'Error connecting to Dremio, {e}!')\n            response.error_message = str(e)\n        finally:\n            if response.success is True and need_to_close:\n                self.disconnect()\n            if response.success is False and self.is_connected is True:\n                self.is_connected = False\n\n        return response\n\n    def native_query(self, query: str) -> StatusResponse:\n        \"\"\"\n        Receive raw query and act upon it somehow.\n        Args:\n            query (str): query in native format\n        Returns:\n            HandlerResponse\n        \"\"\"\n\n        query = query.replace('\"', '\\\\\"').replace('\\n', ' ')\n\n        need_to_close = self.is_connected is False\n\n        auth_headers = self.connect()\n        data = '{' + f'\"sql\": \"{query}\"' + '}'\n\n        try:\n            sql_result = requests.post(self.base_url + '/api/v3/sql', headers=auth_headers, data=data)\n\n            job_id = sql_result.json()['id']\n\n            if sql_result.status_code == 200:\n                log.logger.info('Job creation successful. Job id is: ' + job_id)\n            else:\n                log.logger.info('Job creation failed.')\n\n            log.logger.info('Waiting for the job to complete...')\n\n            job_status = requests.request(\"GET\", self.base_url + \"/api/v3/job/\" + job_id, headers=auth_headers).json()[\n                'jobState']\n\n            while job_status != 'COMPLETED':\n                time.sleep(2)\n                job_status = requests.request(\"GET\", self.base_url + \"/api/v3/job/\" + job_id, headers=auth_headers).json()[\n                    'jobState']\n\n            job_result = json.loads(requests.request(\"GET\", self.base_url + \"/api/v3/job/\" + job_id + \"/results\", headers=auth_headers).text)\n\n            if 'errorMessage' not in job_result:\n                response = Response(\n                    RESPONSE_TYPE.TABLE,\n                    data_frame=pd.DataFrame(\n                        job_result['rows']\n                    )\n                )\n            else:\n                response = Response(\n                    RESPONSE_TYPE.ERROR,\n                    error_message=str(job_result['errorMessage'])\n                )\n\n        except Exception as e:\n            log.logger.error(f'Error running query: {query} on Dremio!')\n            response = Response(\n                RESPONSE_TYPE.ERROR,\n                error_message=str(e)\n            )\n\n        if need_to_close is True:\n            self.disconnect()\n\n        return response\n\n    def query(self, query: ASTNode) -> StatusResponse:\n        \"\"\"\n        Receive query as AST (abstract syntax tree) and act upon it somehow.\n        Args:\n            query (ASTNode): sql query represented as AST. May be any kind\n                of query: SELECT, INTSERT, DELETE, etc\n        Returns:\n            HandlerResponse\n        \"\"\"\n\n        renderer = SqlalchemyRender(DremioDialect)\n        query_str = renderer.get_string(query, with_failback=True)\n        return self.native_query(query_str)\n\n    def get_tables(self) -> StatusResponse:\n        \"\"\"\n        Return list of entities that will be accessible as tables.\n        Returns:\n            HandlerResponse\n        \"\"\"\n\n        query = 'SELECT * FROM INFORMATION_SCHEMA.\\\\\"TABLES\\\\\"'\n        result = self.native_query(query)\n        df = result.data_frame\n        result.data_frame = df.rename(columns={df.columns[0]: 'table_name'})\n        return result\n\n    def get_columns(self, table_name: str) -> StatusResponse:\n        \"\"\"\n        Returns a list of entity columns.\n        Args:\n            table_name (str): name of one of tables returned by self.get_tables()\n        Returns:\n            HandlerResponse\n        \"\"\"\n\n        query = f\"DESCRIBE {table_name}\"\n        result = self.native_query(query)\n        df = result.data_frame\n        result.data_frame = df.rename(columns={'COLUMN_NAME': 'column_name', 'DATA_TYPE': 'data_type'})\n        return result\n\n\nconnection_args = OrderedDict(\n    host={\n        'type': ARG_TYPE.STR,\n        'description': 'The host name or IP address of the Dremio server.'\n    },\n    port={\n        'type': ARG_TYPE.INT,\n        'description': 'The port that Dremio is running on.'\n    },\n    username={\n        'type': ARG_TYPE.STR,\n        'description': 'The username used to authenticate with the Dremio server.'\n    },\n    password={\n        'type': ARG_TYPE.STR,\n        'description': 'The password to authenticate the user with the Dremio server.'\n    }\n)\n\nconnection_args_example = OrderedDict(\n    host='localhost',\n    database=9047,\n    username='admin',\n    password='password'\n)"], "fixing_code": ["from typing import Optional\nfrom collections import OrderedDict\n\nimport json\nimport time\nimport requests\nimport pandas as pd\n\nfrom mindsdb_sql import parse_sql\nfrom mindsdb_sql.render.sqlalchemy_render import SqlalchemyRender\nfrom mindsdb.integrations.libs.base import DatabaseHandler\nfrom sqlalchemy_dremio.base import DremioDialect\n\nfrom mindsdb_sql.parser.ast.base import ASTNode\n\nfrom mindsdb.utilities import log\nfrom mindsdb.integrations.libs.response import (\n    HandlerStatusResponse as StatusResponse,\n    HandlerResponse as Response,\n    RESPONSE_TYPE\n)\nfrom mindsdb.integrations.libs.const import HANDLER_CONNECTION_ARG_TYPE as ARG_TYPE\n\n\nclass DremioHandler(DatabaseHandler):\n    \"\"\"\n    This handler handles connection and execution of the Dremio statements.\n    \"\"\"\n\n    name = 'dremio'\n\n    def __init__(self, name: str, connection_data: Optional[dict], **kwargs):\n        \"\"\"\n        Initialize the handler.\n        Args:\n            name (str): name of particular handler instance\n            connection_data (dict): parameters for connecting to the database\n            **kwargs: arbitrary keyword arguments.\n        \"\"\"\n        super().__init__(name)\n        self.parser = parse_sql\n        self.dialect = 'dremio'\n\n        self.connection_data = connection_data\n        self.kwargs = kwargs\n\n        self.base_url = f\"http://{self.connection_data['host']}:{self.connection_data['port']}\"\n\n        self.connection = None\n        self.is_connected = False\n\n    def __del__(self):\n        if self.is_connected is True:\n            self.disconnect()\n\n    def connect(self) -> dict:\n        \"\"\"\n        Set up the connection required by the handler.\n        Returns:\n            HandlerStatusResponse\n        \"\"\"\n\n        headers = {\n            'Content-Type': 'application/json',\n        }\n\n        data = '{' + f'\"userName\": \"{self.connection_data[\"username\"]}\",\"password\": \"{self.connection_data[\"password\"]}\"' + '}'\n\n        response = requests.post(self.base_url + '/apiv2/login', headers=headers, data=data)\n\n        return {\n            'Authorization': '_dremio' + response.json()['token'],\n            'Content-Type': 'application/json',\n        }\n\n    def disconnect(self):\n        \"\"\"\n        Close any existing connections.\n        \"\"\"\n\n        self.is_connected = False\n        return\n\n    def check_connection(self) -> StatusResponse:\n        \"\"\"\n        Check connection to the handler.\n        Returns:\n            HandlerStatusResponse\n        \"\"\"\n\n        response = StatusResponse(False)\n        need_to_close = self.is_connected is False\n\n        try:\n            self.connect()\n            response.success = True\n        except Exception as e:\n            log.logger.error(f'Error connecting to Dremio, {e}!')\n            response.error_message = str(e)\n        finally:\n            if response.success is True and need_to_close:\n                self.disconnect()\n            if response.success is False and self.is_connected is True:\n                self.is_connected = False\n\n        return response\n\n    def native_query(self, query: str) -> StatusResponse:\n        \"\"\"\n        Receive raw query and act upon it somehow.\n        Args:\n            query (str): query in native format\n        Returns:\n            HandlerResponse\n        \"\"\"\n\n        query = query.replace('\"', '\\\\\"').replace('\\n', ' ')\n\n        need_to_close = self.is_connected is False\n\n        auth_headers = self.connect()\n        data = '{' + f'\"sql\": \"{query}\"' + '}'\n\n        try:\n            sql_result = requests.post(self.base_url + '/api/v3/sql', headers=auth_headers, data=data)\n\n            job_id = sql_result.json()['id']\n\n            if sql_result.status_code == 200:\n                log.logger.info('Job creation successful. Job id is: ' + job_id)\n            else:\n                log.logger.info('Job creation failed.')\n\n            log.logger.info('Waiting for the job to complete...')\n\n            job_status = requests.request(\"GET\", self.base_url + \"/api/v3/job/\" + job_id, headers=auth_headers).json()[\n                'jobState']\n\n            while job_status != 'COMPLETED':\n                time.sleep(2)\n                job_status = requests.request(\"GET\", self.base_url + \"/api/v3/job/\" + job_id, headers=auth_headers).json()[\n                    'jobState']\n\n            job_result = json.loads(requests.request(\"GET\", self.base_url + \"/api/v3/job/\" + job_id + \"/results\", headers=auth_headers).text)\n\n            if 'errorMessage' not in job_result:\n                response = Response(\n                    RESPONSE_TYPE.TABLE,\n                    data_frame=pd.DataFrame(\n                        job_result['rows']\n                    )\n                )\n            else:\n                response = Response(\n                    RESPONSE_TYPE.ERROR,\n                    error_message=str(job_result['errorMessage'])\n                )\n\n        except Exception as e:\n            log.logger.error(f'Error running query: {query} on Dremio!')\n            response = Response(\n                RESPONSE_TYPE.ERROR,\n                error_message=str(e)\n            )\n\n        if need_to_close is True:\n            self.disconnect()\n\n        return response\n\n    def query(self, query: ASTNode) -> StatusResponse:\n        \"\"\"\n        Receive query as AST (abstract syntax tree) and act upon it somehow.\n        Args:\n            query (ASTNode): sql query represented as AST. May be any kind\n                of query: SELECT, INTSERT, DELETE, etc\n        Returns:\n            HandlerResponse\n        \"\"\"\n\n        renderer = SqlalchemyRender(DremioDialect)\n        query_str = renderer.get_string(query, with_failback=True)\n        return self.native_query(query_str)\n\n    def get_tables(self) -> StatusResponse:\n        \"\"\"\n        Return list of entities that will be accessible as tables.\n        Returns:\n            HandlerResponse\n        \"\"\"\n\n        query = 'SELECT * FROM INFORMATION_SCHEMA.\\\\\"TABLES\\\\\"'\n        result = self.native_query(query)\n        df = result.data_frame\n        result.data_frame = df.rename(columns={df.columns[0]: 'table_name'})\n        return result\n\n    def get_columns(self, table_name: str) -> StatusResponse:\n        \"\"\"\n        Returns a list of entity columns.\n        Args:\n            table_name (str): name of one of tables returned by self.get_tables()\n        Returns:\n            HandlerResponse\n        \"\"\"\n\n        query = f\"DESCRIBE {table_name}\"\n        result = self.native_query(query)\n        df = result.data_frame\n        result.data_frame = df.rename(columns={'COLUMN_NAME': 'column_name', 'DATA_TYPE': 'data_type'})\n        return result\n\n\nconnection_args = OrderedDict(\n    host={\n        'type': ARG_TYPE.STR,\n        'description': 'The host name or IP address of the Dremio server.'\n    },\n    port={\n        'type': ARG_TYPE.INT,\n        'description': 'The port that Dremio is running on.'\n    },\n    username={\n        'type': ARG_TYPE.STR,\n        'description': 'The username used to authenticate with the Dremio server.'\n    },\n    password={\n        'type': ARG_TYPE.STR,\n        'description': 'The password to authenticate the user with the Dremio server.'\n    }\n)\n\nconnection_args_example = OrderedDict(\n    host='localhost',\n    database=9047,\n    username='admin',\n    password='password'\n)\n"], "filenames": ["mindsdb/integrations/handlers/dremio_handler/dremio_handler.py"], "buggy_code_start_loc": [69], "buggy_code_end_loc": [239], "fixing_code_start_loc": [69], "fixing_code_end_loc": [239], "type": "CWE-311", "message": "MindsDB's AI Virtual Database allows developers to connect any AI/ML model to any datasource. Prior to version 23.7.4.0, a call to requests with `verify=False` disables SSL certificate checks. This rule enforces always verifying SSL certificates for methods in the Requests library. In version 23.7.4.0, certificates are validated by default, which is the desired behavior.", "other": {"cve": {"id": "CVE-2023-38699", "sourceIdentifier": "security-advisories@github.com", "published": "2023-08-04T18:15:15.797", "lastModified": "2023-08-10T15:25:49.587", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "MindsDB's AI Virtual Database allows developers to connect any AI/ML model to any datasource. Prior to version 23.7.4.0, a call to requests with `verify=False` disables SSL certificate checks. This rule enforces always verifying SSL certificates for methods in the Requests library. In version 23.7.4.0, certificates are validated by default, which is the desired behavior."}, {"lang": "es", "value": "AI Virtual Database de MindsDB permite a los desarrolladores conectar cualquier modelo AI/ML a cualquier fuente de datos. Antes de la versi\u00f3n 23.7.4.0, una llamada a requests con `verify=False` deshabilitaba la comprobaci\u00f3n de certificados SSL. Esta regla obliga a comprobar siempre los certificados SSL de los m\u00e9todos de la biblioteca de peticiones. En la versi\u00f3n 23.7.4.0, los certificados se validan por defecto, que es el comportamiento deseado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-311"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mindsdb:mindsdb:*:*:*:*:*:*:*:*", "versionEndExcluding": "23.7.4.0", "matchCriteriaId": "D2B4378B-7832-46DE-B197-7037D54CDDCC"}]}]}], "references": [{"url": "https://github.com/mindsdb/mindsdb/commit/083afcf6567cf51aa7d89ea892fd97689919053b", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/mindsdb/mindsdb/releases/tag/v23.7.4.0", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/mindsdb/mindsdb/security/advisories/GHSA-8hx6-qv6f-xgcw", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/mindsdb/mindsdb/commit/083afcf6567cf51aa7d89ea892fd97689919053b"}}