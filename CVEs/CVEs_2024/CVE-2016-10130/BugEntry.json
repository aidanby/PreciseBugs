{"buggy_code": ["/*\n * Copyright (C) the libgit2 contributors. All rights reserved.\n *\n * This file is part of libgit2, distributed under the GNU GPL v2 with\n * a Linking Exception. For full terms see the included COPYING file.\n */\n#ifndef GIT_WINHTTP\n\n#include \"git2.h\"\n#include \"http_parser.h\"\n#include \"buffer.h\"\n#include \"netops.h\"\n#include \"global.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"auth.h\"\n#include \"auth_negotiate.h\"\n#include \"tls_stream.h\"\n#include \"socket_stream.h\"\n#include \"curl_stream.h\"\n\ngit_http_auth_scheme auth_schemes[] = {\n\t{ GIT_AUTHTYPE_NEGOTIATE, \"Negotiate\", GIT_CREDTYPE_DEFAULT, git_http_auth_negotiate },\n\t{ GIT_AUTHTYPE_BASIC, \"Basic\", GIT_CREDTYPE_USERPASS_PLAINTEXT, git_http_auth_basic },\n};\n\nstatic const char *upload_pack_service = \"upload-pack\";\nstatic const char *upload_pack_ls_service_url = \"/info/refs?service=git-upload-pack\";\nstatic const char *upload_pack_service_url = \"/git-upload-pack\";\nstatic const char *receive_pack_service = \"receive-pack\";\nstatic const char *receive_pack_ls_service_url = \"/info/refs?service=git-receive-pack\";\nstatic const char *receive_pack_service_url = \"/git-receive-pack\";\nstatic const char *get_verb = \"GET\";\nstatic const char *post_verb = \"POST\";\n\n#define OWNING_SUBTRANSPORT(s) ((http_subtransport *)(s)->parent.subtransport)\n\n#define PARSE_ERROR_GENERIC\t-1\n#define PARSE_ERROR_REPLAY\t-2\n/** Look at the user field */\n#define PARSE_ERROR_EXT         -3\n\n#define CHUNK_SIZE\t4096\n\nenum last_cb {\n\tNONE,\n\tFIELD,\n\tVALUE\n};\n\ntypedef struct {\n\tgit_smart_subtransport_stream parent;\n\tconst char *service;\n\tconst char *service_url;\n\tchar *redirect_url;\n\tconst char *verb;\n\tchar *chunk_buffer;\n\tunsigned chunk_buffer_len;\n\tunsigned sent_request : 1,\n\t\treceived_response : 1,\n\t\tchunked : 1,\n\t\tredirect_count : 3;\n} http_stream;\n\ntypedef struct {\n\tgit_smart_subtransport parent;\n\ttransport_smart *owner;\n\tgit_stream *io;\n\tgitno_connection_data connection_data;\n\tbool connected;\n\n\t/* Parser structures */\n\thttp_parser parser;\n\thttp_parser_settings settings;\n\tgitno_buffer parse_buffer;\n\tgit_buf parse_header_name;\n\tgit_buf parse_header_value;\n\tchar parse_buffer_data[NETIO_BUFSIZE];\n\tchar *content_type;\n\tchar *location;\n\tgit_vector www_authenticate;\n\tenum last_cb last_cb;\n\tint parse_error;\n\tint error;\n\tunsigned parse_finished : 1;\n\n\t/* Authentication */\n\tgit_cred *cred;\n\tgit_cred *url_cred;\n\tgit_vector auth_contexts;\n} http_subtransport;\n\ntypedef struct {\n\thttp_stream *s;\n\thttp_subtransport *t;\n\n\t/* Target buffer details from read() */\n\tchar *buffer;\n\tsize_t buf_size;\n\tsize_t *bytes_read;\n} parser_context;\n\nstatic bool credtype_match(git_http_auth_scheme *scheme, void *data)\n{\n\tunsigned int credtype = *(unsigned int *)data;\n\n\treturn !!(scheme->credtypes & credtype);\n}\n\nstatic bool challenge_match(git_http_auth_scheme *scheme, void *data)\n{\n\tconst char *scheme_name = scheme->name;\n\tconst char *challenge = (const char *)data;\n\tsize_t scheme_len;\n\n\tscheme_len = strlen(scheme_name);\n\treturn (strncasecmp(challenge, scheme_name, scheme_len) == 0 &&\n\t\t(challenge[scheme_len] == '\\0' || challenge[scheme_len] == ' '));\n}\n\nstatic int auth_context_match(\n\tgit_http_auth_context **out,\n\thttp_subtransport *t,\n\tbool (*scheme_match)(git_http_auth_scheme *scheme, void *data),\n\tvoid *data)\n{\n\tgit_http_auth_scheme *scheme = NULL;\n\tgit_http_auth_context *context = NULL, *c;\n\tsize_t i;\n\n\t*out = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(auth_schemes); i++) {\n\t\tif (scheme_match(&auth_schemes[i], data)) {\n\t\t\tscheme = &auth_schemes[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!scheme)\n\t\treturn 0;\n\n\t/* See if authentication has already started for this scheme */\n\tgit_vector_foreach(&t->auth_contexts, i, c) {\n\t\tif (c->type == scheme->type) {\n\t\t\tcontext = c;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!context) {\n\t\tif (scheme->init_context(&context, &t->connection_data) < 0)\n\t\t\treturn -1;\n\t\telse if (!context)\n\t\t\treturn 0;\n\t\telse if (git_vector_insert(&t->auth_contexts, context) < 0)\n\t\t\treturn -1;\n\t}\n\n\t*out = context;\n\n\treturn 0;\n}\n\nstatic int apply_credentials(git_buf *buf, http_subtransport *t)\n{\n\tgit_cred *cred = t->cred;\n\tgit_http_auth_context *context;\n\n\t/* Apply the credentials given to us in the URL */\n\tif (!cred && t->connection_data.user && t->connection_data.pass) {\n\t\tif (!t->url_cred &&\n\t\t\tgit_cred_userpass_plaintext_new(&t->url_cred,\n\t\t\t\tt->connection_data.user, t->connection_data.pass) < 0)\n\t\t\treturn -1;\n\n\t\tcred = t->url_cred;\n\t}\n\n\tif (!cred)\n\t\treturn 0;\n\n\t/* Get or create a context for the best scheme for this cred type */\n\tif (auth_context_match(&context, t, credtype_match, &cred->credtype) < 0)\n\t\treturn -1;\n\n\treturn context->next_token(buf, context, cred);\n}\n\nstatic const char *user_agent(void)\n{\n\tconst char *custom = git_libgit2__user_agent();\n\n\tif (custom)\n\t\treturn custom;\n\n\treturn \"libgit2 \" LIBGIT2_VERSION;\n}\n\nstatic int gen_request(\n\tgit_buf *buf,\n\thttp_stream *s,\n\tsize_t content_length)\n{\n\thttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tconst char *path = t->connection_data.path ? t->connection_data.path : \"/\";\n\tsize_t i;\n\n\tgit_buf_printf(buf, \"%s %s%s HTTP/1.1\\r\\n\", s->verb, path, s->service_url);\n\n\tgit_buf_printf(buf, \"User-Agent: git/2.0 (%s)\\r\\n\", user_agent());\n\tgit_buf_printf(buf, \"Host: %s\\r\\n\", t->connection_data.host);\n\n\tif (s->chunked || content_length > 0) {\n\t\tgit_buf_printf(buf, \"Accept: application/x-git-%s-result\\r\\n\", s->service);\n\t\tgit_buf_printf(buf, \"Content-Type: application/x-git-%s-request\\r\\n\", s->service);\n\n\t\tif (s->chunked)\n\t\t\tgit_buf_puts(buf, \"Transfer-Encoding: chunked\\r\\n\");\n\t\telse\n\t\t\tgit_buf_printf(buf, \"Content-Length: %\"PRIuZ \"\\r\\n\", content_length);\n\t} else\n\t\tgit_buf_puts(buf, \"Accept: */*\\r\\n\");\n\n\tfor (i = 0; i < t->owner->custom_headers.count; i++) {\n\t\tif (t->owner->custom_headers.strings[i])\n\t\t\tgit_buf_printf(buf, \"%s\\r\\n\", t->owner->custom_headers.strings[i]);\n\t}\n\n\t/* Apply credentials to the request */\n\tif (apply_credentials(buf, t) < 0)\n\t\treturn -1;\n\n\tgit_buf_puts(buf, \"\\r\\n\");\n\n\tif (git_buf_oom(buf))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int parse_authenticate_response(\n\tgit_vector *www_authenticate,\n\thttp_subtransport *t,\n\tint *allowed_types)\n{\n\tgit_http_auth_context *context;\n\tchar *challenge;\n\tsize_t i;\n\n\tgit_vector_foreach(www_authenticate, i, challenge) {\n\t\tif (auth_context_match(&context, t, challenge_match, challenge) < 0)\n\t\t\treturn -1;\n\t\telse if (!context)\n\t\t\tcontinue;\n\n\t\tif (context->set_challenge &&\n\t\t\tcontext->set_challenge(context, challenge) < 0)\n\t\t\treturn -1;\n\n\t\t*allowed_types |= context->credtypes;\n\t}\n\n\treturn 0;\n}\n\nstatic int on_header_ready(http_subtransport *t)\n{\n\tgit_buf *name = &t->parse_header_name;\n\tgit_buf *value = &t->parse_header_value;\n\n\tif (!strcasecmp(\"Content-Type\", git_buf_cstr(name))) {\n\t\tif (!t->content_type) {\n\t\t\tt->content_type = git__strdup(git_buf_cstr(value));\n\t\t\tGITERR_CHECK_ALLOC(t->content_type);\n\t\t}\n\t}\n\telse if (!strcasecmp(\"WWW-Authenticate\", git_buf_cstr(name))) {\n\t\tchar *dup = git__strdup(git_buf_cstr(value));\n\t\tGITERR_CHECK_ALLOC(dup);\n\n\t\tgit_vector_insert(&t->www_authenticate, dup);\n\t}\n\telse if (!strcasecmp(\"Location\", git_buf_cstr(name))) {\n\t\tif (!t->location) {\n\t\t\tt->location = git__strdup(git_buf_cstr(value));\n\t\t\tGITERR_CHECK_ALLOC(t->location);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int on_header_field(http_parser *parser, const char *str, size_t len)\n{\n\tparser_context *ctx = (parser_context *) parser->data;\n\thttp_subtransport *t = ctx->t;\n\n\t/* Both parse_header_name and parse_header_value are populated\n\t * and ready for consumption */\n\tif (VALUE == t->last_cb)\n\t\tif (on_header_ready(t) < 0)\n\t\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\tif (NONE == t->last_cb || VALUE == t->last_cb)\n\t\tgit_buf_clear(&t->parse_header_name);\n\n\tif (git_buf_put(&t->parse_header_name, str, len) < 0)\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\tt->last_cb = FIELD;\n\treturn 0;\n}\n\nstatic int on_header_value(http_parser *parser, const char *str, size_t len)\n{\n\tparser_context *ctx = (parser_context *) parser->data;\n\thttp_subtransport *t = ctx->t;\n\n\tassert(NONE != t->last_cb);\n\n\tif (FIELD == t->last_cb)\n\t\tgit_buf_clear(&t->parse_header_value);\n\n\tif (git_buf_put(&t->parse_header_value, str, len) < 0)\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\tt->last_cb = VALUE;\n\treturn 0;\n}\n\nstatic int on_headers_complete(http_parser *parser)\n{\n\tparser_context *ctx = (parser_context *) parser->data;\n\thttp_subtransport *t = ctx->t;\n\thttp_stream *s = ctx->s;\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error = 0, no_callback = 0, allowed_auth_types = 0;\n\n\t/* Both parse_header_name and parse_header_value are populated\n\t * and ready for consumption. */\n\tif (VALUE == t->last_cb)\n\t\tif (on_header_ready(t) < 0)\n\t\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\t/* Capture authentication headers which may be a 401 (authentication\n\t * is not complete) or a 200 (simply informing us that auth *is*\n\t * complete.)\n\t */\n\tif (parse_authenticate_response(&t->www_authenticate, t,\n\t\t\t&allowed_auth_types) < 0)\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\t/* Check for an authentication failure. */\n\tif (parser->status_code == 401 && get_verb == s->verb) {\n\t\tif (!t->owner->cred_acquire_cb) {\n\t\t\tno_callback = 1;\n\t\t} else {\n\t\t\tif (allowed_auth_types) {\n\t\t\t\tif (t->cred) {\n\t\t\t\t\tt->cred->free(t->cred);\n\t\t\t\t\tt->cred = NULL;\n\t\t\t\t}\n\n\t\t\t\terror = t->owner->cred_acquire_cb(&t->cred,\n\t\t\t\t\t\t\t\t  t->owner->url,\n\t\t\t\t\t\t\t\t  t->connection_data.user,\n\t\t\t\t\t\t\t\t  allowed_auth_types,\n\t\t\t\t\t\t\t\t  t->owner->cred_acquire_payload);\n\n\t\t\t\tif (error == GIT_PASSTHROUGH) {\n\t\t\t\t\tno_callback = 1;\n\t\t\t\t} else if (error < 0) {\n\t\t\t\t\tt->error = error;\n\t\t\t\t\treturn t->parse_error = PARSE_ERROR_EXT;\n\t\t\t\t} else {\n\t\t\t\t\tassert(t->cred);\n\n\t\t\t\t\tif (!(t->cred->credtype & allowed_auth_types)) {\n\t\t\t\t\t\tgiterr_set(GITERR_NET, \"credentials callback returned an invalid cred type\");\n\t\t\t\t\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Successfully acquired a credential. */\n\t\t\t\t\tt->parse_error = PARSE_ERROR_REPLAY;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (no_callback) {\n\t\t\tgiterr_set(GITERR_NET, \"authentication required but no callback set\");\n\t\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t\t}\n\t}\n\n\t/* Check for a redirect.\n\t * Right now we only permit a redirect to the same hostname. */\n\tif ((parser->status_code == 301 ||\n\t     parser->status_code == 302 ||\n\t     (parser->status_code == 303 && get_verb == s->verb) ||\n\t     parser->status_code == 307) &&\n\t    t->location) {\n\n\t\tif (s->redirect_count >= 7) {\n\t\t\tgiterr_set(GITERR_NET, \"Too many redirects\");\n\t\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t\t}\n\n\t\tif (gitno_connection_data_from_url(&t->connection_data, t->location, s->service_url) < 0)\n\t\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\t\t/* Set the redirect URL on the stream. This is a transfer of\n\t\t * ownership of the memory. */\n\t\tif (s->redirect_url)\n\t\t\tgit__free(s->redirect_url);\n\n\t\ts->redirect_url = t->location;\n\t\tt->location = NULL;\n\n\t\tt->connected = 0;\n\t\ts->redirect_count++;\n\n\t\tt->parse_error = PARSE_ERROR_REPLAY;\n\t\treturn 0;\n\t}\n\n\t/* Check for a 200 HTTP status code. */\n\tif (parser->status_code != 200) {\n\t\tgiterr_set(GITERR_NET,\n\t\t\t\"Unexpected HTTP status code: %d\",\n\t\t\tparser->status_code);\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t}\n\n\t/* The response must contain a Content-Type header. */\n\tif (!t->content_type) {\n\t\tgiterr_set(GITERR_NET, \"No Content-Type header in response\");\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t}\n\n\t/* The Content-Type header must match our expectation. */\n\tif (get_verb == s->verb)\n\t\tgit_buf_printf(&buf,\n\t\t\t\"application/x-git-%s-advertisement\",\n\t\t\tctx->s->service);\n\telse\n\t\tgit_buf_printf(&buf,\n\t\t\t\"application/x-git-%s-result\",\n\t\t\tctx->s->service);\n\n\tif (git_buf_oom(&buf))\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\tif (strcmp(t->content_type, git_buf_cstr(&buf))) {\n\t\tgit_buf_free(&buf);\n\t\tgiterr_set(GITERR_NET,\n\t\t\t\"Invalid Content-Type: %s\",\n\t\t\tt->content_type);\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t}\n\n\tgit_buf_free(&buf);\n\n\treturn 0;\n}\n\nstatic int on_message_complete(http_parser *parser)\n{\n\tparser_context *ctx = (parser_context *) parser->data;\n\thttp_subtransport *t = ctx->t;\n\n\tt->parse_finished = 1;\n\n\treturn 0;\n}\n\nstatic int on_body_fill_buffer(http_parser *parser, const char *str, size_t len)\n{\n\tparser_context *ctx = (parser_context *) parser->data;\n\thttp_subtransport *t = ctx->t;\n\n\t/* If our goal is to replay the request (either an auth failure or\n\t * a redirect) then don't bother buffering since we're ignoring the\n\t * content anyway.\n\t */\n\tif (t->parse_error == PARSE_ERROR_REPLAY)\n\t\treturn 0;\n\n\tif (ctx->buf_size < len) {\n\t\tgiterr_set(GITERR_NET, \"Can't fit data in the buffer\");\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t}\n\n\tmemcpy(ctx->buffer, str, len);\n\t*(ctx->bytes_read) += len;\n\tctx->buffer += len;\n\tctx->buf_size -= len;\n\n\treturn 0;\n}\n\nstatic void clear_parser_state(http_subtransport *t)\n{\n\thttp_parser_init(&t->parser, HTTP_RESPONSE);\n\tgitno_buffer_setup_fromstream(t->io,\n\t\t&t->parse_buffer,\n\t\tt->parse_buffer_data,\n\t\tsizeof(t->parse_buffer_data));\n\n\tt->last_cb = NONE;\n\tt->parse_error = 0;\n\tt->parse_finished = 0;\n\n\tgit_buf_free(&t->parse_header_name);\n\tgit_buf_init(&t->parse_header_name, 0);\n\n\tgit_buf_free(&t->parse_header_value);\n\tgit_buf_init(&t->parse_header_value, 0);\n\n\tgit__free(t->content_type);\n\tt->content_type = NULL;\n\n\tgit__free(t->location);\n\tt->location = NULL;\n\n\tgit_vector_free_deep(&t->www_authenticate);\n}\n\nstatic int write_chunk(git_stream *io, const char *buffer, size_t len)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\n\t/* Chunk header */\n\tgit_buf_printf(&buf, \"%\" PRIxZ \"\\r\\n\", len);\n\n\tif (git_buf_oom(&buf))\n\t\treturn -1;\n\n\tif (git_stream_write(io, buf.ptr, buf.size, 0) < 0) {\n\t\tgit_buf_free(&buf);\n\t\treturn -1;\n\t}\n\n\tgit_buf_free(&buf);\n\n\t/* Chunk body */\n\tif (len > 0 && git_stream_write(io, buffer, len, 0) < 0)\n\t\treturn -1;\n\n\t/* Chunk footer */\n\tif (git_stream_write(io, \"\\r\\n\", 2, 0) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int apply_proxy_config(http_subtransport *t)\n{\n\tint error;\n\tgit_proxy_t proxy_type;\n\n\tif (!git_stream_supports_proxy(t->io))\n\t\treturn 0;\n\n\tproxy_type = t->owner->proxy.type;\n\n\tif (proxy_type == GIT_PROXY_NONE)\n\t\treturn 0;\n\n\tif (proxy_type == GIT_PROXY_AUTO) {\n\t\tchar *url;\n\t\tgit_proxy_options opts = GIT_PROXY_OPTIONS_INIT;\n\n\t\tif ((error = git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &url)) < 0)\n\t\t\treturn error;\n\n\t\topts.type = GIT_PROXY_SPECIFIED;\n\t\topts.url = url;\n\t\terror = git_stream_set_proxy(t->io, &opts);\n\t\tgit__free(url);\n\n\t\treturn error;\n\t}\n\n\treturn git_stream_set_proxy(t->io, &t->owner->proxy);\n}\n\nstatic int http_connect(http_subtransport *t)\n{\n\tint error;\n\n\tif (t->connected &&\n\t\thttp_should_keep_alive(&t->parser) &&\n\t\tt->parse_finished)\n\t\treturn 0;\n\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t\tt->connected = 0;\n\t}\n\n\tif (t->connection_data.use_ssl) {\n\t\terror = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n\t} else {\n#ifdef GIT_CURL\n\t\terror = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n#else\n\t\terror = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);\n#endif\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\tGITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, \"git_stream\");\n\n\tapply_proxy_config(t);\n\n\terror = git_stream_connect(t->io);\n\n\tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n\t    git_stream_is_encrypted(t->io)) {\n\t\tgit_cert *cert;\n\t\tint is_valid;\n\n\t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n\t\t\treturn error;\n\n\t\tgiterr_clear();\n\t\tis_valid = error != GIT_ECERTIFICATE;\n\t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n\n\t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled certificate check\");\n\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\tt->connected = 1;\n\treturn 0;\n}\n\nstatic int http_stream_read(\n\tgit_smart_subtransport_stream *stream,\n\tchar *buffer,\n\tsize_t buf_size,\n\tsize_t *bytes_read)\n{\n\thttp_stream *s = (http_stream *)stream;\n\thttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tparser_context ctx;\n\tsize_t bytes_parsed;\n\nreplay:\n\t*bytes_read = 0;\n\n\tassert(t->connected);\n\n\tif (!s->sent_request) {\n\t\tgit_buf request = GIT_BUF_INIT;\n\n\t\tclear_parser_state(t);\n\n\t\tif (gen_request(&request, s, 0) < 0)\n\t\t\treturn -1;\n\n\t\tif (git_stream_write(t->io, request.ptr, request.size, 0) < 0) {\n\t\t\tgit_buf_free(&request);\n\t\t\treturn -1;\n\t\t}\n\n\t\tgit_buf_free(&request);\n\n\t\ts->sent_request = 1;\n\t}\n\n\tif (!s->received_response) {\n\t\tif (s->chunked) {\n\t\t\tassert(s->verb == post_verb);\n\n\t\t\t/* Flush, if necessary */\n\t\t\tif (s->chunk_buffer_len > 0 &&\n\t\t\t\twrite_chunk(t->io, s->chunk_buffer, s->chunk_buffer_len) < 0)\n\t\t\t\treturn -1;\n\n\t\t\ts->chunk_buffer_len = 0;\n\n\t\t\t/* Write the final chunk. */\n\t\t\tif (git_stream_write(t->io, \"0\\r\\n\\r\\n\", 5, 0) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\ts->received_response = 1;\n\t}\n\n\twhile (!*bytes_read && !t->parse_finished) {\n\t\tsize_t data_offset;\n\t\tint error;\n\n\t\t/*\n\t\t * Make the parse_buffer think it's as full of data as\n\t\t * the buffer, so it won't try to recv more data than\n\t\t * we can put into it.\n\t\t *\n\t\t * data_offset is the actual data offset from which we\n\t\t * should tell the parser to start reading.\n\t\t */\n\t\tif (buf_size >= t->parse_buffer.len) {\n\t\t\tt->parse_buffer.offset = 0;\n\t\t} else {\n\t\t\tt->parse_buffer.offset = t->parse_buffer.len - buf_size;\n\t\t}\n\n\t\tdata_offset = t->parse_buffer.offset;\n\n\t\tif (gitno_recv(&t->parse_buffer) < 0)\n\t\t\treturn -1;\n\n\t\t/* This call to http_parser_execute will result in invocations of the\n\t\t * on_* family of callbacks. The most interesting of these is\n\t\t * on_body_fill_buffer, which is called when data is ready to be copied\n\t\t * into the target buffer. We need to marshal the buffer, buf_size, and\n\t\t * bytes_read parameters to this callback. */\n\t\tctx.t = t;\n\t\tctx.s = s;\n\t\tctx.buffer = buffer;\n\t\tctx.buf_size = buf_size;\n\t\tctx.bytes_read = bytes_read;\n\n\t\t/* Set the context, call the parser, then unset the context. */\n\t\tt->parser.data = &ctx;\n\n\t\tbytes_parsed = http_parser_execute(&t->parser,\n\t\t\t&t->settings,\n\t\t\tt->parse_buffer.data + data_offset,\n\t\t\tt->parse_buffer.offset - data_offset);\n\n\t\tt->parser.data = NULL;\n\n\t\t/* If there was a handled authentication failure, then parse_error\n\t\t * will have signaled us that we should replay the request. */\n\t\tif (PARSE_ERROR_REPLAY == t->parse_error) {\n\t\t\ts->sent_request = 0;\n\n\t\t\tif ((error = http_connect(t)) < 0)\n\t\t\t\treturn error;\n\n\t\t\tgoto replay;\n\t\t}\n\n\t\tif (t->parse_error == PARSE_ERROR_EXT) {\n\t\t\treturn t->error;\n\t\t}\n\n\t\tif (t->parse_error < 0)\n\t\t\treturn -1;\n\n\t\tif (bytes_parsed != t->parse_buffer.offset - data_offset) {\n\t\t\tgiterr_set(GITERR_NET,\n\t\t\t\t\"HTTP parser error: %s\",\n\t\t\t\thttp_errno_description((enum http_errno)t->parser.http_errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int http_stream_write_chunked(\n\tgit_smart_subtransport_stream *stream,\n\tconst char *buffer,\n\tsize_t len)\n{\n\thttp_stream *s = (http_stream *)stream;\n\thttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\n\tassert(t->connected);\n\n\t/* Send the request, if necessary */\n\tif (!s->sent_request) {\n\t\tgit_buf request = GIT_BUF_INIT;\n\n\t\tclear_parser_state(t);\n\n\t\tif (gen_request(&request, s, 0) < 0)\n\t\t\treturn -1;\n\n\t\tif (git_stream_write(t->io, request.ptr, request.size, 0) < 0) {\n\t\t\tgit_buf_free(&request);\n\t\t\treturn -1;\n\t\t}\n\n\t\tgit_buf_free(&request);\n\n\t\ts->sent_request = 1;\n\t}\n\n\tif (len > CHUNK_SIZE) {\n\t\t/* Flush, if necessary */\n\t\tif (s->chunk_buffer_len > 0) {\n\t\t\tif (write_chunk(t->io, s->chunk_buffer, s->chunk_buffer_len) < 0)\n\t\t\t\treturn -1;\n\n\t\t\ts->chunk_buffer_len = 0;\n\t\t}\n\n\t\t/* Write chunk directly */\n\t\tif (write_chunk(t->io, buffer, len) < 0)\n\t\t\treturn -1;\n\t}\n\telse {\n\t\t/* Append as much to the buffer as we can */\n\t\tint count = min(CHUNK_SIZE - s->chunk_buffer_len, len);\n\n\t\tif (!s->chunk_buffer)\n\t\t\ts->chunk_buffer = git__malloc(CHUNK_SIZE);\n\n\t\tmemcpy(s->chunk_buffer + s->chunk_buffer_len, buffer, count);\n\t\ts->chunk_buffer_len += count;\n\t\tbuffer += count;\n\t\tlen -= count;\n\n\t\t/* Is the buffer full? If so, then flush */\n\t\tif (CHUNK_SIZE == s->chunk_buffer_len) {\n\t\t\tif (write_chunk(t->io, s->chunk_buffer, s->chunk_buffer_len) < 0)\n\t\t\t\treturn -1;\n\n\t\t\ts->chunk_buffer_len = 0;\n\n\t\t\tif (len > 0) {\n\t\t\t\tmemcpy(s->chunk_buffer, buffer, len);\n\t\t\t\ts->chunk_buffer_len = len;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int http_stream_write_single(\n\tgit_smart_subtransport_stream *stream,\n\tconst char *buffer,\n\tsize_t len)\n{\n\thttp_stream *s = (http_stream *)stream;\n\thttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tgit_buf request = GIT_BUF_INIT;\n\n\tassert(t->connected);\n\n\tif (s->sent_request) {\n\t\tgiterr_set(GITERR_NET, \"Subtransport configured for only one write\");\n\t\treturn -1;\n\t}\n\n\tclear_parser_state(t);\n\n\tif (gen_request(&request, s, len) < 0)\n\t\treturn -1;\n\n\tif (git_stream_write(t->io, request.ptr, request.size, 0) < 0)\n\t\tgoto on_error;\n\n\tif (len && git_stream_write(t->io, buffer, len, 0) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_free(&request);\n\ts->sent_request = 1;\n\n\treturn 0;\n\non_error:\n\tgit_buf_free(&request);\n\treturn -1;\n}\n\nstatic void http_stream_free(git_smart_subtransport_stream *stream)\n{\n\thttp_stream *s = (http_stream *)stream;\n\n\tif (s->chunk_buffer)\n\t\tgit__free(s->chunk_buffer);\n\n\tif (s->redirect_url)\n\t\tgit__free(s->redirect_url);\n\n\tgit__free(s);\n}\n\nstatic int http_stream_alloc(http_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (!stream)\n\t\treturn -1;\n\n\ts = git__calloc(sizeof(http_stream), 1);\n\tGITERR_CHECK_ALLOC(s);\n\n\ts->parent.subtransport = &t->parent;\n\ts->parent.read = http_stream_read;\n\ts->parent.write = http_stream_write_single;\n\ts->parent.free = http_stream_free;\n\n\t*stream = (git_smart_subtransport_stream *)s;\n\treturn 0;\n}\n\nstatic int http_uploadpack_ls(\n\thttp_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (http_stream_alloc(t, stream) < 0)\n\t\treturn -1;\n\n\ts = (http_stream *)*stream;\n\n\ts->service = upload_pack_service;\n\ts->service_url = upload_pack_ls_service_url;\n\ts->verb = get_verb;\n\n\treturn 0;\n}\n\nstatic int http_uploadpack(\n\thttp_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (http_stream_alloc(t, stream) < 0)\n\t\treturn -1;\n\n\ts = (http_stream *)*stream;\n\n\ts->service = upload_pack_service;\n\ts->service_url = upload_pack_service_url;\n\ts->verb = post_verb;\n\n\treturn 0;\n}\n\nstatic int http_receivepack_ls(\n\thttp_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (http_stream_alloc(t, stream) < 0)\n\t\treturn -1;\n\n\ts = (http_stream *)*stream;\n\n\ts->service = receive_pack_service;\n\ts->service_url = receive_pack_ls_service_url;\n\ts->verb = get_verb;\n\n\treturn 0;\n}\n\nstatic int http_receivepack(\n\thttp_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (http_stream_alloc(t, stream) < 0)\n\t\treturn -1;\n\n\ts = (http_stream *)*stream;\n\n\t/* Use Transfer-Encoding: chunked for this request */\n\ts->chunked = 1;\n\ts->parent.write = http_stream_write_chunked;\n\n\ts->service = receive_pack_service;\n\ts->service_url = receive_pack_service_url;\n\ts->verb = post_verb;\n\n\treturn 0;\n}\n\nstatic int http_action(\n\tgit_smart_subtransport_stream **stream,\n\tgit_smart_subtransport *subtransport,\n\tconst char *url,\n\tgit_smart_service_t action)\n{\n\thttp_subtransport *t = (http_subtransport *)subtransport;\n\tint ret;\n\n\tif (!stream)\n\t\treturn -1;\n\n\tif ((!t->connection_data.host || !t->connection_data.port || !t->connection_data.path) &&\n\t\t (ret = gitno_connection_data_from_url(&t->connection_data, url, NULL)) < 0)\n\t\treturn ret;\n\n\tif ((ret = http_connect(t)) < 0)\n\t\treturn ret;\n\n\tswitch (action) {\n\tcase GIT_SERVICE_UPLOADPACK_LS:\n\t\treturn http_uploadpack_ls(t, stream);\n\n\tcase GIT_SERVICE_UPLOADPACK:\n\t\treturn http_uploadpack(t, stream);\n\n\tcase GIT_SERVICE_RECEIVEPACK_LS:\n\t\treturn http_receivepack_ls(t, stream);\n\n\tcase GIT_SERVICE_RECEIVEPACK:\n\t\treturn http_receivepack(t, stream);\n\t}\n\n\t*stream = NULL;\n\treturn -1;\n}\n\nstatic int http_close(git_smart_subtransport *subtransport)\n{\n\thttp_subtransport *t = (http_subtransport *) subtransport;\n\tgit_http_auth_context *context;\n\tsize_t i;\n\n\tclear_parser_state(t);\n\n\tt->connected = 0;\n\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t}\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\tgit_vector_foreach(&t->auth_contexts, i, context) {\n\t\tif (context->free)\n\t\t\tcontext->free(context);\n\t}\n\n\tgit_vector_clear(&t->auth_contexts);\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\treturn 0;\n}\n\nstatic void http_free(git_smart_subtransport *subtransport)\n{\n\thttp_subtransport *t = (http_subtransport *) subtransport;\n\n\thttp_close(subtransport);\n\n\tgit_vector_free(&t->auth_contexts);\n\tgit__free(t);\n}\n\nint git_smart_subtransport_http(git_smart_subtransport **out, git_transport *owner, void *param)\n{\n\thttp_subtransport *t;\n\n\tGIT_UNUSED(param);\n\n\tif (!out)\n\t\treturn -1;\n\n\tt = git__calloc(sizeof(http_subtransport), 1);\n\tGITERR_CHECK_ALLOC(t);\n\n\tt->owner = (transport_smart *)owner;\n\tt->parent.action = http_action;\n\tt->parent.close = http_close;\n\tt->parent.free = http_free;\n\n\tt->settings.on_header_field = on_header_field;\n\tt->settings.on_header_value = on_header_value;\n\tt->settings.on_headers_complete = on_headers_complete;\n\tt->settings.on_body = on_body_fill_buffer;\n\tt->settings.on_message_complete = on_message_complete;\n\n\t*out = (git_smart_subtransport *) t;\n\treturn 0;\n}\n\n#endif /* !GIT_WINHTTP */\n"], "fixing_code": ["/*\n * Copyright (C) the libgit2 contributors. All rights reserved.\n *\n * This file is part of libgit2, distributed under the GNU GPL v2 with\n * a Linking Exception. For full terms see the included COPYING file.\n */\n#ifndef GIT_WINHTTP\n\n#include \"git2.h\"\n#include \"http_parser.h\"\n#include \"buffer.h\"\n#include \"netops.h\"\n#include \"global.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"auth.h\"\n#include \"auth_negotiate.h\"\n#include \"tls_stream.h\"\n#include \"socket_stream.h\"\n#include \"curl_stream.h\"\n\ngit_http_auth_scheme auth_schemes[] = {\n\t{ GIT_AUTHTYPE_NEGOTIATE, \"Negotiate\", GIT_CREDTYPE_DEFAULT, git_http_auth_negotiate },\n\t{ GIT_AUTHTYPE_BASIC, \"Basic\", GIT_CREDTYPE_USERPASS_PLAINTEXT, git_http_auth_basic },\n};\n\nstatic const char *upload_pack_service = \"upload-pack\";\nstatic const char *upload_pack_ls_service_url = \"/info/refs?service=git-upload-pack\";\nstatic const char *upload_pack_service_url = \"/git-upload-pack\";\nstatic const char *receive_pack_service = \"receive-pack\";\nstatic const char *receive_pack_ls_service_url = \"/info/refs?service=git-receive-pack\";\nstatic const char *receive_pack_service_url = \"/git-receive-pack\";\nstatic const char *get_verb = \"GET\";\nstatic const char *post_verb = \"POST\";\n\n#define OWNING_SUBTRANSPORT(s) ((http_subtransport *)(s)->parent.subtransport)\n\n#define PARSE_ERROR_GENERIC\t-1\n#define PARSE_ERROR_REPLAY\t-2\n/** Look at the user field */\n#define PARSE_ERROR_EXT         -3\n\n#define CHUNK_SIZE\t4096\n\nenum last_cb {\n\tNONE,\n\tFIELD,\n\tVALUE\n};\n\ntypedef struct {\n\tgit_smart_subtransport_stream parent;\n\tconst char *service;\n\tconst char *service_url;\n\tchar *redirect_url;\n\tconst char *verb;\n\tchar *chunk_buffer;\n\tunsigned chunk_buffer_len;\n\tunsigned sent_request : 1,\n\t\treceived_response : 1,\n\t\tchunked : 1,\n\t\tredirect_count : 3;\n} http_stream;\n\ntypedef struct {\n\tgit_smart_subtransport parent;\n\ttransport_smart *owner;\n\tgit_stream *io;\n\tgitno_connection_data connection_data;\n\tbool connected;\n\n\t/* Parser structures */\n\thttp_parser parser;\n\thttp_parser_settings settings;\n\tgitno_buffer parse_buffer;\n\tgit_buf parse_header_name;\n\tgit_buf parse_header_value;\n\tchar parse_buffer_data[NETIO_BUFSIZE];\n\tchar *content_type;\n\tchar *location;\n\tgit_vector www_authenticate;\n\tenum last_cb last_cb;\n\tint parse_error;\n\tint error;\n\tunsigned parse_finished : 1;\n\n\t/* Authentication */\n\tgit_cred *cred;\n\tgit_cred *url_cred;\n\tgit_vector auth_contexts;\n} http_subtransport;\n\ntypedef struct {\n\thttp_stream *s;\n\thttp_subtransport *t;\n\n\t/* Target buffer details from read() */\n\tchar *buffer;\n\tsize_t buf_size;\n\tsize_t *bytes_read;\n} parser_context;\n\nstatic bool credtype_match(git_http_auth_scheme *scheme, void *data)\n{\n\tunsigned int credtype = *(unsigned int *)data;\n\n\treturn !!(scheme->credtypes & credtype);\n}\n\nstatic bool challenge_match(git_http_auth_scheme *scheme, void *data)\n{\n\tconst char *scheme_name = scheme->name;\n\tconst char *challenge = (const char *)data;\n\tsize_t scheme_len;\n\n\tscheme_len = strlen(scheme_name);\n\treturn (strncasecmp(challenge, scheme_name, scheme_len) == 0 &&\n\t\t(challenge[scheme_len] == '\\0' || challenge[scheme_len] == ' '));\n}\n\nstatic int auth_context_match(\n\tgit_http_auth_context **out,\n\thttp_subtransport *t,\n\tbool (*scheme_match)(git_http_auth_scheme *scheme, void *data),\n\tvoid *data)\n{\n\tgit_http_auth_scheme *scheme = NULL;\n\tgit_http_auth_context *context = NULL, *c;\n\tsize_t i;\n\n\t*out = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(auth_schemes); i++) {\n\t\tif (scheme_match(&auth_schemes[i], data)) {\n\t\t\tscheme = &auth_schemes[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!scheme)\n\t\treturn 0;\n\n\t/* See if authentication has already started for this scheme */\n\tgit_vector_foreach(&t->auth_contexts, i, c) {\n\t\tif (c->type == scheme->type) {\n\t\t\tcontext = c;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!context) {\n\t\tif (scheme->init_context(&context, &t->connection_data) < 0)\n\t\t\treturn -1;\n\t\telse if (!context)\n\t\t\treturn 0;\n\t\telse if (git_vector_insert(&t->auth_contexts, context) < 0)\n\t\t\treturn -1;\n\t}\n\n\t*out = context;\n\n\treturn 0;\n}\n\nstatic int apply_credentials(git_buf *buf, http_subtransport *t)\n{\n\tgit_cred *cred = t->cred;\n\tgit_http_auth_context *context;\n\n\t/* Apply the credentials given to us in the URL */\n\tif (!cred && t->connection_data.user && t->connection_data.pass) {\n\t\tif (!t->url_cred &&\n\t\t\tgit_cred_userpass_plaintext_new(&t->url_cred,\n\t\t\t\tt->connection_data.user, t->connection_data.pass) < 0)\n\t\t\treturn -1;\n\n\t\tcred = t->url_cred;\n\t}\n\n\tif (!cred)\n\t\treturn 0;\n\n\t/* Get or create a context for the best scheme for this cred type */\n\tif (auth_context_match(&context, t, credtype_match, &cred->credtype) < 0)\n\t\treturn -1;\n\n\treturn context->next_token(buf, context, cred);\n}\n\nstatic const char *user_agent(void)\n{\n\tconst char *custom = git_libgit2__user_agent();\n\n\tif (custom)\n\t\treturn custom;\n\n\treturn \"libgit2 \" LIBGIT2_VERSION;\n}\n\nstatic int gen_request(\n\tgit_buf *buf,\n\thttp_stream *s,\n\tsize_t content_length)\n{\n\thttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tconst char *path = t->connection_data.path ? t->connection_data.path : \"/\";\n\tsize_t i;\n\n\tgit_buf_printf(buf, \"%s %s%s HTTP/1.1\\r\\n\", s->verb, path, s->service_url);\n\n\tgit_buf_printf(buf, \"User-Agent: git/2.0 (%s)\\r\\n\", user_agent());\n\tgit_buf_printf(buf, \"Host: %s\\r\\n\", t->connection_data.host);\n\n\tif (s->chunked || content_length > 0) {\n\t\tgit_buf_printf(buf, \"Accept: application/x-git-%s-result\\r\\n\", s->service);\n\t\tgit_buf_printf(buf, \"Content-Type: application/x-git-%s-request\\r\\n\", s->service);\n\n\t\tif (s->chunked)\n\t\t\tgit_buf_puts(buf, \"Transfer-Encoding: chunked\\r\\n\");\n\t\telse\n\t\t\tgit_buf_printf(buf, \"Content-Length: %\"PRIuZ \"\\r\\n\", content_length);\n\t} else\n\t\tgit_buf_puts(buf, \"Accept: */*\\r\\n\");\n\n\tfor (i = 0; i < t->owner->custom_headers.count; i++) {\n\t\tif (t->owner->custom_headers.strings[i])\n\t\t\tgit_buf_printf(buf, \"%s\\r\\n\", t->owner->custom_headers.strings[i]);\n\t}\n\n\t/* Apply credentials to the request */\n\tif (apply_credentials(buf, t) < 0)\n\t\treturn -1;\n\n\tgit_buf_puts(buf, \"\\r\\n\");\n\n\tif (git_buf_oom(buf))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int parse_authenticate_response(\n\tgit_vector *www_authenticate,\n\thttp_subtransport *t,\n\tint *allowed_types)\n{\n\tgit_http_auth_context *context;\n\tchar *challenge;\n\tsize_t i;\n\n\tgit_vector_foreach(www_authenticate, i, challenge) {\n\t\tif (auth_context_match(&context, t, challenge_match, challenge) < 0)\n\t\t\treturn -1;\n\t\telse if (!context)\n\t\t\tcontinue;\n\n\t\tif (context->set_challenge &&\n\t\t\tcontext->set_challenge(context, challenge) < 0)\n\t\t\treturn -1;\n\n\t\t*allowed_types |= context->credtypes;\n\t}\n\n\treturn 0;\n}\n\nstatic int on_header_ready(http_subtransport *t)\n{\n\tgit_buf *name = &t->parse_header_name;\n\tgit_buf *value = &t->parse_header_value;\n\n\tif (!strcasecmp(\"Content-Type\", git_buf_cstr(name))) {\n\t\tif (!t->content_type) {\n\t\t\tt->content_type = git__strdup(git_buf_cstr(value));\n\t\t\tGITERR_CHECK_ALLOC(t->content_type);\n\t\t}\n\t}\n\telse if (!strcasecmp(\"WWW-Authenticate\", git_buf_cstr(name))) {\n\t\tchar *dup = git__strdup(git_buf_cstr(value));\n\t\tGITERR_CHECK_ALLOC(dup);\n\n\t\tgit_vector_insert(&t->www_authenticate, dup);\n\t}\n\telse if (!strcasecmp(\"Location\", git_buf_cstr(name))) {\n\t\tif (!t->location) {\n\t\t\tt->location = git__strdup(git_buf_cstr(value));\n\t\t\tGITERR_CHECK_ALLOC(t->location);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int on_header_field(http_parser *parser, const char *str, size_t len)\n{\n\tparser_context *ctx = (parser_context *) parser->data;\n\thttp_subtransport *t = ctx->t;\n\n\t/* Both parse_header_name and parse_header_value are populated\n\t * and ready for consumption */\n\tif (VALUE == t->last_cb)\n\t\tif (on_header_ready(t) < 0)\n\t\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\tif (NONE == t->last_cb || VALUE == t->last_cb)\n\t\tgit_buf_clear(&t->parse_header_name);\n\n\tif (git_buf_put(&t->parse_header_name, str, len) < 0)\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\tt->last_cb = FIELD;\n\treturn 0;\n}\n\nstatic int on_header_value(http_parser *parser, const char *str, size_t len)\n{\n\tparser_context *ctx = (parser_context *) parser->data;\n\thttp_subtransport *t = ctx->t;\n\n\tassert(NONE != t->last_cb);\n\n\tif (FIELD == t->last_cb)\n\t\tgit_buf_clear(&t->parse_header_value);\n\n\tif (git_buf_put(&t->parse_header_value, str, len) < 0)\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\tt->last_cb = VALUE;\n\treturn 0;\n}\n\nstatic int on_headers_complete(http_parser *parser)\n{\n\tparser_context *ctx = (parser_context *) parser->data;\n\thttp_subtransport *t = ctx->t;\n\thttp_stream *s = ctx->s;\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error = 0, no_callback = 0, allowed_auth_types = 0;\n\n\t/* Both parse_header_name and parse_header_value are populated\n\t * and ready for consumption. */\n\tif (VALUE == t->last_cb)\n\t\tif (on_header_ready(t) < 0)\n\t\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\t/* Capture authentication headers which may be a 401 (authentication\n\t * is not complete) or a 200 (simply informing us that auth *is*\n\t * complete.)\n\t */\n\tif (parse_authenticate_response(&t->www_authenticate, t,\n\t\t\t&allowed_auth_types) < 0)\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\t/* Check for an authentication failure. */\n\tif (parser->status_code == 401 && get_verb == s->verb) {\n\t\tif (!t->owner->cred_acquire_cb) {\n\t\t\tno_callback = 1;\n\t\t} else {\n\t\t\tif (allowed_auth_types) {\n\t\t\t\tif (t->cred) {\n\t\t\t\t\tt->cred->free(t->cred);\n\t\t\t\t\tt->cred = NULL;\n\t\t\t\t}\n\n\t\t\t\terror = t->owner->cred_acquire_cb(&t->cred,\n\t\t\t\t\t\t\t\t  t->owner->url,\n\t\t\t\t\t\t\t\t  t->connection_data.user,\n\t\t\t\t\t\t\t\t  allowed_auth_types,\n\t\t\t\t\t\t\t\t  t->owner->cred_acquire_payload);\n\n\t\t\t\tif (error == GIT_PASSTHROUGH) {\n\t\t\t\t\tno_callback = 1;\n\t\t\t\t} else if (error < 0) {\n\t\t\t\t\tt->error = error;\n\t\t\t\t\treturn t->parse_error = PARSE_ERROR_EXT;\n\t\t\t\t} else {\n\t\t\t\t\tassert(t->cred);\n\n\t\t\t\t\tif (!(t->cred->credtype & allowed_auth_types)) {\n\t\t\t\t\t\tgiterr_set(GITERR_NET, \"credentials callback returned an invalid cred type\");\n\t\t\t\t\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Successfully acquired a credential. */\n\t\t\t\t\tt->parse_error = PARSE_ERROR_REPLAY;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (no_callback) {\n\t\t\tgiterr_set(GITERR_NET, \"authentication required but no callback set\");\n\t\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t\t}\n\t}\n\n\t/* Check for a redirect.\n\t * Right now we only permit a redirect to the same hostname. */\n\tif ((parser->status_code == 301 ||\n\t     parser->status_code == 302 ||\n\t     (parser->status_code == 303 && get_verb == s->verb) ||\n\t     parser->status_code == 307) &&\n\t    t->location) {\n\n\t\tif (s->redirect_count >= 7) {\n\t\t\tgiterr_set(GITERR_NET, \"Too many redirects\");\n\t\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t\t}\n\n\t\tif (gitno_connection_data_from_url(&t->connection_data, t->location, s->service_url) < 0)\n\t\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\t\t/* Set the redirect URL on the stream. This is a transfer of\n\t\t * ownership of the memory. */\n\t\tif (s->redirect_url)\n\t\t\tgit__free(s->redirect_url);\n\n\t\ts->redirect_url = t->location;\n\t\tt->location = NULL;\n\n\t\tt->connected = 0;\n\t\ts->redirect_count++;\n\n\t\tt->parse_error = PARSE_ERROR_REPLAY;\n\t\treturn 0;\n\t}\n\n\t/* Check for a 200 HTTP status code. */\n\tif (parser->status_code != 200) {\n\t\tgiterr_set(GITERR_NET,\n\t\t\t\"Unexpected HTTP status code: %d\",\n\t\t\tparser->status_code);\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t}\n\n\t/* The response must contain a Content-Type header. */\n\tif (!t->content_type) {\n\t\tgiterr_set(GITERR_NET, \"No Content-Type header in response\");\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t}\n\n\t/* The Content-Type header must match our expectation. */\n\tif (get_verb == s->verb)\n\t\tgit_buf_printf(&buf,\n\t\t\t\"application/x-git-%s-advertisement\",\n\t\t\tctx->s->service);\n\telse\n\t\tgit_buf_printf(&buf,\n\t\t\t\"application/x-git-%s-result\",\n\t\t\tctx->s->service);\n\n\tif (git_buf_oom(&buf))\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\tif (strcmp(t->content_type, git_buf_cstr(&buf))) {\n\t\tgit_buf_free(&buf);\n\t\tgiterr_set(GITERR_NET,\n\t\t\t\"Invalid Content-Type: %s\",\n\t\t\tt->content_type);\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t}\n\n\tgit_buf_free(&buf);\n\n\treturn 0;\n}\n\nstatic int on_message_complete(http_parser *parser)\n{\n\tparser_context *ctx = (parser_context *) parser->data;\n\thttp_subtransport *t = ctx->t;\n\n\tt->parse_finished = 1;\n\n\treturn 0;\n}\n\nstatic int on_body_fill_buffer(http_parser *parser, const char *str, size_t len)\n{\n\tparser_context *ctx = (parser_context *) parser->data;\n\thttp_subtransport *t = ctx->t;\n\n\t/* If our goal is to replay the request (either an auth failure or\n\t * a redirect) then don't bother buffering since we're ignoring the\n\t * content anyway.\n\t */\n\tif (t->parse_error == PARSE_ERROR_REPLAY)\n\t\treturn 0;\n\n\tif (ctx->buf_size < len) {\n\t\tgiterr_set(GITERR_NET, \"Can't fit data in the buffer\");\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t}\n\n\tmemcpy(ctx->buffer, str, len);\n\t*(ctx->bytes_read) += len;\n\tctx->buffer += len;\n\tctx->buf_size -= len;\n\n\treturn 0;\n}\n\nstatic void clear_parser_state(http_subtransport *t)\n{\n\thttp_parser_init(&t->parser, HTTP_RESPONSE);\n\tgitno_buffer_setup_fromstream(t->io,\n\t\t&t->parse_buffer,\n\t\tt->parse_buffer_data,\n\t\tsizeof(t->parse_buffer_data));\n\n\tt->last_cb = NONE;\n\tt->parse_error = 0;\n\tt->parse_finished = 0;\n\n\tgit_buf_free(&t->parse_header_name);\n\tgit_buf_init(&t->parse_header_name, 0);\n\n\tgit_buf_free(&t->parse_header_value);\n\tgit_buf_init(&t->parse_header_value, 0);\n\n\tgit__free(t->content_type);\n\tt->content_type = NULL;\n\n\tgit__free(t->location);\n\tt->location = NULL;\n\n\tgit_vector_free_deep(&t->www_authenticate);\n}\n\nstatic int write_chunk(git_stream *io, const char *buffer, size_t len)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\n\t/* Chunk header */\n\tgit_buf_printf(&buf, \"%\" PRIxZ \"\\r\\n\", len);\n\n\tif (git_buf_oom(&buf))\n\t\treturn -1;\n\n\tif (git_stream_write(io, buf.ptr, buf.size, 0) < 0) {\n\t\tgit_buf_free(&buf);\n\t\treturn -1;\n\t}\n\n\tgit_buf_free(&buf);\n\n\t/* Chunk body */\n\tif (len > 0 && git_stream_write(io, buffer, len, 0) < 0)\n\t\treturn -1;\n\n\t/* Chunk footer */\n\tif (git_stream_write(io, \"\\r\\n\", 2, 0) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int apply_proxy_config(http_subtransport *t)\n{\n\tint error;\n\tgit_proxy_t proxy_type;\n\n\tif (!git_stream_supports_proxy(t->io))\n\t\treturn 0;\n\n\tproxy_type = t->owner->proxy.type;\n\n\tif (proxy_type == GIT_PROXY_NONE)\n\t\treturn 0;\n\n\tif (proxy_type == GIT_PROXY_AUTO) {\n\t\tchar *url;\n\t\tgit_proxy_options opts = GIT_PROXY_OPTIONS_INIT;\n\n\t\tif ((error = git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &url)) < 0)\n\t\t\treturn error;\n\n\t\topts.type = GIT_PROXY_SPECIFIED;\n\t\topts.url = url;\n\t\terror = git_stream_set_proxy(t->io, &opts);\n\t\tgit__free(url);\n\n\t\treturn error;\n\t}\n\n\treturn git_stream_set_proxy(t->io, &t->owner->proxy);\n}\n\nstatic int http_connect(http_subtransport *t)\n{\n\tint error;\n\n\tif (t->connected &&\n\t\thttp_should_keep_alive(&t->parser) &&\n\t\tt->parse_finished)\n\t\treturn 0;\n\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t\tt->connected = 0;\n\t}\n\n\tif (t->connection_data.use_ssl) {\n\t\terror = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n\t} else {\n#ifdef GIT_CURL\n\t\terror = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n#else\n\t\terror = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);\n#endif\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\tGITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, \"git_stream\");\n\n\tapply_proxy_config(t);\n\n\terror = git_stream_connect(t->io);\n\n\tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n\t    git_stream_is_encrypted(t->io)) {\n\t\tgit_cert *cert;\n\t\tint is_valid = (error == GIT_OK);\n\n\t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n\t\t\treturn error;\n\n\t\tgiterr_clear();\n\t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n\n\t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled certificate check\");\n\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\tt->connected = 1;\n\treturn 0;\n}\n\nstatic int http_stream_read(\n\tgit_smart_subtransport_stream *stream,\n\tchar *buffer,\n\tsize_t buf_size,\n\tsize_t *bytes_read)\n{\n\thttp_stream *s = (http_stream *)stream;\n\thttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tparser_context ctx;\n\tsize_t bytes_parsed;\n\nreplay:\n\t*bytes_read = 0;\n\n\tassert(t->connected);\n\n\tif (!s->sent_request) {\n\t\tgit_buf request = GIT_BUF_INIT;\n\n\t\tclear_parser_state(t);\n\n\t\tif (gen_request(&request, s, 0) < 0)\n\t\t\treturn -1;\n\n\t\tif (git_stream_write(t->io, request.ptr, request.size, 0) < 0) {\n\t\t\tgit_buf_free(&request);\n\t\t\treturn -1;\n\t\t}\n\n\t\tgit_buf_free(&request);\n\n\t\ts->sent_request = 1;\n\t}\n\n\tif (!s->received_response) {\n\t\tif (s->chunked) {\n\t\t\tassert(s->verb == post_verb);\n\n\t\t\t/* Flush, if necessary */\n\t\t\tif (s->chunk_buffer_len > 0 &&\n\t\t\t\twrite_chunk(t->io, s->chunk_buffer, s->chunk_buffer_len) < 0)\n\t\t\t\treturn -1;\n\n\t\t\ts->chunk_buffer_len = 0;\n\n\t\t\t/* Write the final chunk. */\n\t\t\tif (git_stream_write(t->io, \"0\\r\\n\\r\\n\", 5, 0) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\ts->received_response = 1;\n\t}\n\n\twhile (!*bytes_read && !t->parse_finished) {\n\t\tsize_t data_offset;\n\t\tint error;\n\n\t\t/*\n\t\t * Make the parse_buffer think it's as full of data as\n\t\t * the buffer, so it won't try to recv more data than\n\t\t * we can put into it.\n\t\t *\n\t\t * data_offset is the actual data offset from which we\n\t\t * should tell the parser to start reading.\n\t\t */\n\t\tif (buf_size >= t->parse_buffer.len) {\n\t\t\tt->parse_buffer.offset = 0;\n\t\t} else {\n\t\t\tt->parse_buffer.offset = t->parse_buffer.len - buf_size;\n\t\t}\n\n\t\tdata_offset = t->parse_buffer.offset;\n\n\t\tif (gitno_recv(&t->parse_buffer) < 0)\n\t\t\treturn -1;\n\n\t\t/* This call to http_parser_execute will result in invocations of the\n\t\t * on_* family of callbacks. The most interesting of these is\n\t\t * on_body_fill_buffer, which is called when data is ready to be copied\n\t\t * into the target buffer. We need to marshal the buffer, buf_size, and\n\t\t * bytes_read parameters to this callback. */\n\t\tctx.t = t;\n\t\tctx.s = s;\n\t\tctx.buffer = buffer;\n\t\tctx.buf_size = buf_size;\n\t\tctx.bytes_read = bytes_read;\n\n\t\t/* Set the context, call the parser, then unset the context. */\n\t\tt->parser.data = &ctx;\n\n\t\tbytes_parsed = http_parser_execute(&t->parser,\n\t\t\t&t->settings,\n\t\t\tt->parse_buffer.data + data_offset,\n\t\t\tt->parse_buffer.offset - data_offset);\n\n\t\tt->parser.data = NULL;\n\n\t\t/* If there was a handled authentication failure, then parse_error\n\t\t * will have signaled us that we should replay the request. */\n\t\tif (PARSE_ERROR_REPLAY == t->parse_error) {\n\t\t\ts->sent_request = 0;\n\n\t\t\tif ((error = http_connect(t)) < 0)\n\t\t\t\treturn error;\n\n\t\t\tgoto replay;\n\t\t}\n\n\t\tif (t->parse_error == PARSE_ERROR_EXT) {\n\t\t\treturn t->error;\n\t\t}\n\n\t\tif (t->parse_error < 0)\n\t\t\treturn -1;\n\n\t\tif (bytes_parsed != t->parse_buffer.offset - data_offset) {\n\t\t\tgiterr_set(GITERR_NET,\n\t\t\t\t\"HTTP parser error: %s\",\n\t\t\t\thttp_errno_description((enum http_errno)t->parser.http_errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int http_stream_write_chunked(\n\tgit_smart_subtransport_stream *stream,\n\tconst char *buffer,\n\tsize_t len)\n{\n\thttp_stream *s = (http_stream *)stream;\n\thttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\n\tassert(t->connected);\n\n\t/* Send the request, if necessary */\n\tif (!s->sent_request) {\n\t\tgit_buf request = GIT_BUF_INIT;\n\n\t\tclear_parser_state(t);\n\n\t\tif (gen_request(&request, s, 0) < 0)\n\t\t\treturn -1;\n\n\t\tif (git_stream_write(t->io, request.ptr, request.size, 0) < 0) {\n\t\t\tgit_buf_free(&request);\n\t\t\treturn -1;\n\t\t}\n\n\t\tgit_buf_free(&request);\n\n\t\ts->sent_request = 1;\n\t}\n\n\tif (len > CHUNK_SIZE) {\n\t\t/* Flush, if necessary */\n\t\tif (s->chunk_buffer_len > 0) {\n\t\t\tif (write_chunk(t->io, s->chunk_buffer, s->chunk_buffer_len) < 0)\n\t\t\t\treturn -1;\n\n\t\t\ts->chunk_buffer_len = 0;\n\t\t}\n\n\t\t/* Write chunk directly */\n\t\tif (write_chunk(t->io, buffer, len) < 0)\n\t\t\treturn -1;\n\t}\n\telse {\n\t\t/* Append as much to the buffer as we can */\n\t\tint count = min(CHUNK_SIZE - s->chunk_buffer_len, len);\n\n\t\tif (!s->chunk_buffer)\n\t\t\ts->chunk_buffer = git__malloc(CHUNK_SIZE);\n\n\t\tmemcpy(s->chunk_buffer + s->chunk_buffer_len, buffer, count);\n\t\ts->chunk_buffer_len += count;\n\t\tbuffer += count;\n\t\tlen -= count;\n\n\t\t/* Is the buffer full? If so, then flush */\n\t\tif (CHUNK_SIZE == s->chunk_buffer_len) {\n\t\t\tif (write_chunk(t->io, s->chunk_buffer, s->chunk_buffer_len) < 0)\n\t\t\t\treturn -1;\n\n\t\t\ts->chunk_buffer_len = 0;\n\n\t\t\tif (len > 0) {\n\t\t\t\tmemcpy(s->chunk_buffer, buffer, len);\n\t\t\t\ts->chunk_buffer_len = len;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int http_stream_write_single(\n\tgit_smart_subtransport_stream *stream,\n\tconst char *buffer,\n\tsize_t len)\n{\n\thttp_stream *s = (http_stream *)stream;\n\thttp_subtransport *t = OWNING_SUBTRANSPORT(s);\n\tgit_buf request = GIT_BUF_INIT;\n\n\tassert(t->connected);\n\n\tif (s->sent_request) {\n\t\tgiterr_set(GITERR_NET, \"Subtransport configured for only one write\");\n\t\treturn -1;\n\t}\n\n\tclear_parser_state(t);\n\n\tif (gen_request(&request, s, len) < 0)\n\t\treturn -1;\n\n\tif (git_stream_write(t->io, request.ptr, request.size, 0) < 0)\n\t\tgoto on_error;\n\n\tif (len && git_stream_write(t->io, buffer, len, 0) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_free(&request);\n\ts->sent_request = 1;\n\n\treturn 0;\n\non_error:\n\tgit_buf_free(&request);\n\treturn -1;\n}\n\nstatic void http_stream_free(git_smart_subtransport_stream *stream)\n{\n\thttp_stream *s = (http_stream *)stream;\n\n\tif (s->chunk_buffer)\n\t\tgit__free(s->chunk_buffer);\n\n\tif (s->redirect_url)\n\t\tgit__free(s->redirect_url);\n\n\tgit__free(s);\n}\n\nstatic int http_stream_alloc(http_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (!stream)\n\t\treturn -1;\n\n\ts = git__calloc(sizeof(http_stream), 1);\n\tGITERR_CHECK_ALLOC(s);\n\n\ts->parent.subtransport = &t->parent;\n\ts->parent.read = http_stream_read;\n\ts->parent.write = http_stream_write_single;\n\ts->parent.free = http_stream_free;\n\n\t*stream = (git_smart_subtransport_stream *)s;\n\treturn 0;\n}\n\nstatic int http_uploadpack_ls(\n\thttp_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (http_stream_alloc(t, stream) < 0)\n\t\treturn -1;\n\n\ts = (http_stream *)*stream;\n\n\ts->service = upload_pack_service;\n\ts->service_url = upload_pack_ls_service_url;\n\ts->verb = get_verb;\n\n\treturn 0;\n}\n\nstatic int http_uploadpack(\n\thttp_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (http_stream_alloc(t, stream) < 0)\n\t\treturn -1;\n\n\ts = (http_stream *)*stream;\n\n\ts->service = upload_pack_service;\n\ts->service_url = upload_pack_service_url;\n\ts->verb = post_verb;\n\n\treturn 0;\n}\n\nstatic int http_receivepack_ls(\n\thttp_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (http_stream_alloc(t, stream) < 0)\n\t\treturn -1;\n\n\ts = (http_stream *)*stream;\n\n\ts->service = receive_pack_service;\n\ts->service_url = receive_pack_ls_service_url;\n\ts->verb = get_verb;\n\n\treturn 0;\n}\n\nstatic int http_receivepack(\n\thttp_subtransport *t,\n\tgit_smart_subtransport_stream **stream)\n{\n\thttp_stream *s;\n\n\tif (http_stream_alloc(t, stream) < 0)\n\t\treturn -1;\n\n\ts = (http_stream *)*stream;\n\n\t/* Use Transfer-Encoding: chunked for this request */\n\ts->chunked = 1;\n\ts->parent.write = http_stream_write_chunked;\n\n\ts->service = receive_pack_service;\n\ts->service_url = receive_pack_service_url;\n\ts->verb = post_verb;\n\n\treturn 0;\n}\n\nstatic int http_action(\n\tgit_smart_subtransport_stream **stream,\n\tgit_smart_subtransport *subtransport,\n\tconst char *url,\n\tgit_smart_service_t action)\n{\n\thttp_subtransport *t = (http_subtransport *)subtransport;\n\tint ret;\n\n\tif (!stream)\n\t\treturn -1;\n\n\tif ((!t->connection_data.host || !t->connection_data.port || !t->connection_data.path) &&\n\t\t (ret = gitno_connection_data_from_url(&t->connection_data, url, NULL)) < 0)\n\t\treturn ret;\n\n\tif ((ret = http_connect(t)) < 0)\n\t\treturn ret;\n\n\tswitch (action) {\n\tcase GIT_SERVICE_UPLOADPACK_LS:\n\t\treturn http_uploadpack_ls(t, stream);\n\n\tcase GIT_SERVICE_UPLOADPACK:\n\t\treturn http_uploadpack(t, stream);\n\n\tcase GIT_SERVICE_RECEIVEPACK_LS:\n\t\treturn http_receivepack_ls(t, stream);\n\n\tcase GIT_SERVICE_RECEIVEPACK:\n\t\treturn http_receivepack(t, stream);\n\t}\n\n\t*stream = NULL;\n\treturn -1;\n}\n\nstatic int http_close(git_smart_subtransport *subtransport)\n{\n\thttp_subtransport *t = (http_subtransport *) subtransport;\n\tgit_http_auth_context *context;\n\tsize_t i;\n\n\tclear_parser_state(t);\n\n\tt->connected = 0;\n\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t}\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\tgit_vector_foreach(&t->auth_contexts, i, context) {\n\t\tif (context->free)\n\t\t\tcontext->free(context);\n\t}\n\n\tgit_vector_clear(&t->auth_contexts);\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\treturn 0;\n}\n\nstatic void http_free(git_smart_subtransport *subtransport)\n{\n\thttp_subtransport *t = (http_subtransport *) subtransport;\n\n\thttp_close(subtransport);\n\n\tgit_vector_free(&t->auth_contexts);\n\tgit__free(t);\n}\n\nint git_smart_subtransport_http(git_smart_subtransport **out, git_transport *owner, void *param)\n{\n\thttp_subtransport *t;\n\n\tGIT_UNUSED(param);\n\n\tif (!out)\n\t\treturn -1;\n\n\tt = git__calloc(sizeof(http_subtransport), 1);\n\tGITERR_CHECK_ALLOC(t);\n\n\tt->owner = (transport_smart *)owner;\n\tt->parent.action = http_action;\n\tt->parent.close = http_close;\n\tt->parent.free = http_free;\n\n\tt->settings.on_header_field = on_header_field;\n\tt->settings.on_header_value = on_header_value;\n\tt->settings.on_headers_complete = on_headers_complete;\n\tt->settings.on_body = on_body_fill_buffer;\n\tt->settings.on_message_complete = on_message_complete;\n\n\t*out = (git_smart_subtransport *) t;\n\treturn 0;\n}\n\n#endif /* !GIT_WINHTTP */\n"], "filenames": ["src/transports/http.c"], "buggy_code_start_loc": [627], "buggy_code_end_loc": [634], "fixing_code_start_loc": [627], "fixing_code_end_loc": [632], "type": "CWE-284", "message": "The http_connect function in transports/http.c in libgit2 before 0.24.6 and 0.25.x before 0.25.1 might allow man-in-the-middle attackers to spoof servers by leveraging clobbering of the error variable.", "other": {"cve": {"id": "CVE-2016-10130", "sourceIdentifier": "security@debian.org", "published": "2017-03-24T15:59:00.263", "lastModified": "2017-03-28T01:59:00.553", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The http_connect function in transports/http.c in libgit2 before 0.24.6 and 0.25.x before 0.25.1 might allow man-in-the-middle attackers to spoof servers by leveraging clobbering of the error variable."}, {"lang": "es", "value": "La funci\u00f3n http_connect en transports/http.c en libgit2 en versiones anteriores a 0.24.6 y 0.25.x en versiones anteriores a 0.25.1 podr\u00eda permitir a atacantes man-in-the-middle suplantar servidores a provechando el clobbering de la variable de error."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libgit2_project:libgit2:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.24.5", "matchCriteriaId": "6747DEC6-17F3-45F9-B98B-5161469D89F7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libgit2_project:libgit2:0.25.0:*:*:*:*:*:*:*", "matchCriteriaId": "157A6552-8A3B-42B7-8BA3-24B03BD7812E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libgit2_project:libgit2:0.25.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "EB081C3A-79B4-48A9-B6C2-46641293244B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libgit2_project:libgit2:0.25.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "D0A1B2E8-B0EC-41B9-A8B2-DD6A0A8DF14C"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2017-02/msg00030.html", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2017-02/msg00036.html", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2017-02/msg00072.html", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/01/10/5", "source": "security@debian.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/01/11/6", "source": "security@debian.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/95359", "source": "security@debian.org"}, {"url": "https://github.com/libgit2/libgit2/commit/9a64e62f0f20c9cf9b2e1609f037060eb2d8eb22", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/libgit2/libgit2/commit/b5c6a1b407b7f8b952bded2789593b68b1876211", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://libgit2.github.com/security/", "source": "security@debian.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/libgit2/libgit2/commit/9a64e62f0f20c9cf9b2e1609f037060eb2d8eb22"}}