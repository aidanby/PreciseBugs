{"buggy_code": ["# frozen_string_literal: true\n\nclass NotificationsController < ApplicationController\n  requires_login\n  before_action :ensure_admin, only: %i[create update destroy]\n  before_action :set_notification, only: %i[update destroy]\n\n  INDEX_LIMIT = 50\n\n  def index\n    user =\n      if params[:username] && !params[:recent]\n        user_record = User.find_by(username: params[:username].to_s)\n        raise Discourse::NotFound if !user_record\n        user_record\n      else\n        current_user\n      end\n\n    guardian.ensure_can_see_notifications!(user)\n\n    if notification_types = params[:filter_by_types]&.split(\",\").presence\n      notification_types.map! do |type|\n        Notification.types[type.to_sym] ||\n          (raise Discourse::InvalidParameters.new(\"invalid notification type: #{type}\"))\n      end\n    end\n\n    if params[:recent].present?\n      limit = fetch_limit_from_params(default: 15, max: INDEX_LIMIT)\n\n      include_reviewables = false\n\n      notifications =\n        Notification.prioritized_list(current_user, count: limit, types: notification_types)\n      # notification_types is blank for the \"all notifications\" user menu tab\n      include_reviewables = notification_types.blank? && guardian.can_see_review_queue?\n\n      if notifications.present? && !(params.has_key?(:silent) || @readonly_mode)\n        if current_user.bump_last_seen_notification!\n          current_user.reload\n          current_user.publish_notifications_state\n        end\n      end\n\n      if !params.has_key?(:silent) && params[:bump_last_seen_reviewable] && !@readonly_mode &&\n           include_reviewables\n        current_user_id = current_user.id\n        Scheduler::Defer.later \"bump last seen reviewable for user\" do\n          # we lookup current_user again in the background thread to avoid\n          # concurrency issues where the user object returned by the\n          # current_user controller method is changed by the time the deferred\n          # block is executed\n          User.find_by(id: current_user_id)&.bump_last_seen_reviewable!\n        end\n      end\n\n      notifications = filter_inaccessible_notifications(notifications)\n\n      json = {\n        notifications: serialize_data(notifications, NotificationSerializer),\n        seen_notification_id: current_user.seen_notification_id,\n      }\n\n      if include_reviewables\n        json[:pending_reviewables] = Reviewable.basic_serializers_for_list(\n          Reviewable.user_menu_list_for(current_user),\n          current_user,\n        ).as_json\n      end\n\n      render_json_dump(json)\n    else\n      offset = params[:offset].to_i\n\n      notifications =\n        Notification.where(user_id: user.id).visible.includes(:topic).order(created_at: :desc)\n\n      notifications = notifications.where(read: true) if params[:filter] == \"read\"\n\n      notifications = notifications.where(read: false) if params[:filter] == \"unread\"\n\n      total_rows = notifications.dup.count\n      notifications = notifications.offset(offset).limit(60)\n      notifications = filter_inaccessible_notifications(notifications)\n      render_json_dump(\n        notifications: serialize_data(notifications, NotificationSerializer),\n        total_rows_notifications: total_rows,\n        seen_notification_id: user.seen_notification_id,\n        load_more_notifications:\n          notifications_path(username: user.username, offset: offset + 60, filter: params[:filter]),\n      )\n    end\n  end\n\n  def mark_read\n    if params[:id]\n      Notification.read(current_user, [params[:id].to_i])\n    else\n      if types = params[:dismiss_types]&.split(\",\").presence\n        invalid = []\n        types.map! do |type|\n          type_id = Notification.types[type.to_sym]\n          invalid << type if !type_id\n          type_id\n        end\n        if invalid.size > 0\n          raise Discourse::InvalidParameters.new(\"invalid notification types: #{invalid.inspect}\")\n        end\n      end\n\n      Notification.read_types(current_user, types)\n      current_user.bump_last_seen_notification!\n    end\n\n    current_user.reload\n    current_user.publish_notifications_state\n\n    render json: success_json\n  end\n\n  def create\n    @notification = Notification.consolidate_or_create!(notification_params)\n    render_notification\n  end\n\n  def update\n    @notification.update!(notification_params)\n    render_notification\n  end\n\n  def destroy\n    @notification.destroy!\n    render json: success_json\n  end\n\n  private\n\n  def set_notification\n    @notification = Notification.find(params[:id])\n  end\n\n  def notification_params\n    params.permit(\n      :notification_type,\n      :user_id,\n      :data,\n      :read,\n      :topic_id,\n      :post_number,\n      :post_action_id,\n    )\n  end\n\n  def render_notification\n    render_json_dump(NotificationSerializer.new(@notification, scope: guardian, root: false))\n  end\n\n  def filter_inaccessible_notifications(notifications)\n    topic_ids = notifications.map { |n| n.topic_id }.compact.uniq\n    accessible_topic_ids = guardian.can_see_topic_ids(topic_ids: topic_ids)\n    notifications.select { |n| n.topic_id.blank? || accessible_topic_ids.include?(n.topic_id) }\n  end\nend\n", "# frozen_string_literal: true\n\nclass UsersController < ApplicationController\n  skip_before_action :authorize_mini_profiler, only: [:avatar]\n\n  requires_login only: %i[\n                   username\n                   update\n                   upload_user_image\n                   pick_avatar\n                   destroy_user_image\n                   destroy\n                   check_emails\n                   topic_tracking_state\n                   preferences\n                   create_second_factor_totp\n                   enable_second_factor_totp\n                   disable_second_factor\n                   list_second_factors\n                   update_second_factor\n                   create_second_factor_backup\n                   select_avatar\n                   notification_level\n                   revoke_auth_token\n                   register_second_factor_security_key\n                   create_second_factor_security_key\n                   feature_topic\n                   clear_featured_topic\n                   bookmarks\n                   invited\n                   check_sso_email\n                   check_sso_payload\n                   recent_searches\n                   reset_recent_searches\n                   user_menu_bookmarks\n                   user_menu_messages\n                 ]\n\n  skip_before_action :check_xhr,\n                     only: %i[\n                       show\n                       badges\n                       password_reset_show\n                       password_reset_update\n                       update\n                       account_created\n                       activate_account\n                       perform_account_activation\n                       avatar\n                       my_redirect\n                       toggle_anon\n                       admin_login\n                       confirm_admin\n                       email_login\n                       summary\n                       feature_topic\n                       clear_featured_topic\n                       bookmarks\n                       user_menu_bookmarks\n                       user_menu_messages\n                     ]\n\n  before_action :second_factor_check_confirmed_password,\n                only: %i[\n                  create_second_factor_totp\n                  enable_second_factor_totp\n                  disable_second_factor\n                  update_second_factor\n                  create_second_factor_backup\n                  register_second_factor_security_key\n                  create_second_factor_security_key\n                ]\n\n  before_action :respond_to_suspicious_request, only: [:create]\n\n  # we need to allow account creation with bad CSRF tokens, if people are caching, the CSRF token on the\n  #  page is going to be empty, this means that server will see an invalid CSRF and blow the session\n  #  once that happens you can't log in with social\n  skip_before_action :verify_authenticity_token, only: [:create]\n  skip_before_action :redirect_to_login_if_required,\n                     only: %i[\n                       check_username\n                       check_email\n                       create\n                       account_created\n                       activate_account\n                       perform_account_activation\n                       send_activation_email\n                       update_activation_email\n                       password_reset_show\n                       password_reset_update\n                       confirm_email_token\n                       email_login\n                       admin_login\n                       confirm_admin\n                     ]\n\n  after_action :add_noindex_header, only: %i[show my_redirect]\n\n  allow_in_staff_writes_only_mode :admin_login\n  allow_in_staff_writes_only_mode :email_login\n\n  MAX_RECENT_SEARCHES = 5\n\n  def index\n  end\n\n  def show(for_card: false)\n    return redirect_to path(\"/login\") if !guardian.public_can_see_profiles?\n\n    @user =\n      fetch_user_from_params(\n        include_inactive: current_user&.staff? || for_card || SiteSetting.show_inactive_accounts,\n      )\n\n    user_serializer = nil\n    if !current_user&.staff? && !@user.active?\n      user_serializer = InactiveUserSerializer.new(@user, scope: guardian, root: \"user\")\n    elsif !guardian.can_see_profile?(@user)\n      user_serializer = HiddenProfileSerializer.new(@user, scope: guardian, root: \"user\")\n    else\n      serializer_class = for_card ? UserCardSerializer : UserSerializer\n      user_serializer = serializer_class.new(@user, scope: guardian, root: \"user\")\n\n      topic_id = params[:include_post_count_for].to_i\n      if topic_id != 0 && guardian.can_see?(Topic.find_by_id(topic_id))\n        user_serializer.topic_post_count = {\n          topic_id => Post.secured(guardian).where(topic_id: topic_id, user_id: @user.id).count,\n        }\n      end\n    end\n\n    track_visit_to_user_profile if !params[:skip_track_visit] && (@user != current_user)\n\n    # This is a hack to get around a Rails issue where values with periods aren't handled correctly\n    # when used as part of a route.\n    if params[:external_id] && params[:external_id].ends_with?(\".json\")\n      return render_json_dump(user_serializer)\n    end\n\n    respond_to do |format|\n      format.html do\n        @restrict_fields = guardian.restrict_user_fields?(@user)\n        store_preloaded(\"user_#{@user.username}\", MultiJson.dump(user_serializer))\n        render :show\n      end\n\n      format.json { render_json_dump(user_serializer) }\n    end\n  end\n\n  def show_card\n    show(for_card: true)\n  end\n\n  # This route is not used in core, but is used by theme components (e.g. https://meta.discourse.org/t/144479)\n  def cards\n    return redirect_to path(\"/login\") if !guardian.public_can_see_profiles?\n\n    user_ids = params.require(:user_ids).split(\",\").map(&:to_i)\n    raise Discourse::InvalidParameters.new(:user_ids) if user_ids.length > 50\n\n    users =\n      User.where(id: user_ids).includes(\n        :user_option,\n        :user_stat,\n        :default_featured_user_badges,\n        :user_profile,\n        :card_background_upload,\n        :primary_group,\n        :flair_group,\n        :primary_email,\n        :user_status,\n      )\n\n    users = users.filter { |u| guardian.can_see_profile?(u) }\n\n    preload_fields =\n      User.allowed_user_custom_fields(guardian) +\n        UserField.all.pluck(:id).map { |fid| \"#{User::USER_FIELD_PREFIX}#{fid}\" }\n    User.preload_custom_fields(users, preload_fields)\n    User.preload_recent_time_read(users)\n\n    render json: users, each_serializer: UserCardSerializer\n  end\n\n  def badges\n    raise Discourse::NotFound unless SiteSetting.enable_badges?\n    show\n  end\n\n  def update\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n    attributes = user_params\n\n    # We can't update the username via this route. Use the username route\n    attributes.delete(:username)\n\n    if params[:user_fields].present?\n      attributes[:custom_fields] ||= {}\n\n      fields = UserField.all\n      fields = fields.where(editable: true) unless current_user.staff?\n      fields.each do |field|\n        field_id = field.id.to_s\n        next unless params[:user_fields].has_key?(field_id)\n\n        value = clean_custom_field_values(field)\n        value = nil if value === \"false\"\n        value = value[0...UserField.max_length] if value\n\n        if value.blank? && field.required?\n          return render_json_error(I18n.t(\"login.missing_user_field\"))\n        end\n        attributes[:custom_fields][\"#{User::USER_FIELD_PREFIX}#{field.id}\"] = value\n      end\n    end\n\n    if params[:external_ids]&.is_a?(ActionController::Parameters) && current_user&.admin? && is_api?\n      attributes[:user_associated_accounts] = []\n\n      params[:external_ids].each do |provider_name, provider_uid|\n        if provider_name == \"discourse_connect\"\n          unless SiteSetting.enable_discourse_connect\n            raise Discourse::InvalidParameters.new(:external_ids)\n          end\n\n          attributes[:discourse_connect] = { external_id: provider_uid }\n\n          next\n        end\n\n        authenticator = Discourse.enabled_authenticators.find { |a| a.name == provider_name }\n        raise Discourse::InvalidParameters.new(:external_ids) if !authenticator&.is_managed?\n\n        attributes[:user_associated_accounts] << {\n          provider_name: provider_name,\n          provider_uid: provider_uid,\n        }\n      end\n    end\n\n    json_result(\n      user,\n      serializer: UserSerializer,\n      additional_errors: %i[user_profile user_option],\n    ) do |u|\n      updater = UserUpdater.new(current_user, user)\n      updater.update(attributes.permit!)\n    end\n  end\n\n  def username\n    params.require(:new_username)\n\n    if clashing_with_existing_route?(params[:new_username]) ||\n         User.reserved_username?(params[:new_username])\n      return render_json_error(I18n.t(\"login.reserved_username\"))\n    end\n\n    user = fetch_user_from_params\n    guardian.ensure_can_edit_username!(user)\n\n    result = UsernameChanger.change(user, params[:new_username], current_user)\n\n    if result\n      render json: { id: user.id, username: user.username }\n    else\n      render_json_error(user.errors.full_messages.join(\",\"))\n    end\n  rescue Discourse::InvalidAccess\n    if current_user&.staff?\n      render_json_error(I18n.t(\"errors.messages.auth_overrides_username\"))\n    else\n      render json: failed_json, status: 403\n    end\n  end\n\n  def check_emails\n    user = fetch_user_from_params(include_inactive: true)\n\n    unless user == current_user\n      guardian.ensure_can_check_emails!(user)\n      StaffActionLogger.new(current_user).log_check_email(user, context: params[:context])\n    end\n\n    email, *secondary_emails = user.emails\n    unconfirmed_emails = user.unconfirmed_emails\n\n    render json: {\n             email: email,\n             secondary_emails: secondary_emails,\n             unconfirmed_emails: unconfirmed_emails,\n             associated_accounts: user.associated_accounts,\n           }\n  rescue Discourse::InvalidAccess\n    render json: failed_json, status: 403\n  end\n\n  def check_sso_email\n    user = fetch_user_from_params(include_inactive: true)\n\n    unless user == current_user\n      guardian.ensure_can_check_sso_details!(user)\n      StaffActionLogger.new(current_user).log_check_email(user, context: params[:context])\n    end\n\n    email = user&.single_sign_on_record&.external_email\n    email = I18n.t(\"user.email.does_not_exist\") if email.blank?\n\n    render json: { email: email }\n  rescue Discourse::InvalidAccess\n    render json: failed_json, status: 403\n  end\n\n  def check_sso_payload\n    user = fetch_user_from_params(include_inactive: true)\n\n    guardian.ensure_can_check_sso_details!(user)\n    unless user == current_user\n      StaffActionLogger.new(current_user).log_check_email(user, context: params[:context])\n    end\n\n    payload = user&.single_sign_on_record&.last_payload\n    payload = I18n.t(\"user.email.does_not_exist\") if payload.blank?\n\n    render json: { payload: payload }\n  rescue Discourse::InvalidAccess\n    render json: failed_json, status: 403\n  end\n\n  def update_primary_email\n    return render json: failed_json, status: 410 if !SiteSetting.enable_secondary_emails\n\n    params.require(:email)\n\n    user = fetch_user_from_params\n    guardian.ensure_can_edit_email!(user)\n\n    old_primary = user.primary_email\n    return render json: success_json if old_primary.email == params[:email]\n\n    new_primary = user.user_emails.find_by(email: params[:email])\n    if new_primary.blank?\n      return(\n        render json: failed_json.merge(errors: [I18n.t(\"change_email.doesnt_exist\")]), status: 428\n      )\n    end\n\n    User.transaction do\n      old_primary.update!(primary: false)\n      new_primary.update!(primary: true)\n      DiscourseEvent.trigger(:user_updated, user)\n\n      if current_user.staff? && current_user != user\n        StaffActionLogger.new(current_user).log_update_email(user)\n      else\n        UserHistory.create!(action: UserHistory.actions[:update_email], acting_user_id: user.id)\n      end\n    end\n\n    render json: success_json\n  end\n\n  def destroy_email\n    return render json: failed_json, status: 410 if !SiteSetting.enable_secondary_emails\n\n    params.require(:email)\n\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    ActiveRecord::Base.transaction do\n      if change_requests = user.email_change_requests.where(new_email: params[:email]).presence\n        change_requests.destroy_all\n      elsif user.user_emails.where(email: params[:email], primary: false).destroy_all.present?\n        DiscourseEvent.trigger(:user_updated, user)\n      else\n        return render json: failed_json, status: 428\n      end\n\n      if current_user.staff? && current_user != user\n        StaffActionLogger.new(current_user).log_destroy_email(user)\n      else\n        UserHistory.create(action: UserHistory.actions[:destroy_email], acting_user_id: user.id)\n      end\n    end\n\n    render json: success_json\n  end\n\n  def topic_tracking_state\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    report = TopicTrackingState.report(user)\n    serializer = TopicTrackingStateSerializer.new(report, scope: guardian, root: false)\n\n    render json: MultiJson.dump(serializer.as_json[:data])\n  end\n\n  def private_message_topic_tracking_state\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    report = PrivateMessageTopicTrackingState.report(user)\n\n    serializer =\n      ActiveModel::ArraySerializer.new(\n        report,\n        each_serializer: PrivateMessageTopicTrackingStateSerializer,\n        scope: guardian,\n      )\n\n    render json: MultiJson.dump(serializer)\n  end\n\n  def badge_title\n    params.require(:user_badge_id)\n\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    user_badge = UserBadge.find_by(id: params[:user_badge_id])\n    previous_title = user.title\n    if user_badge && user_badge.user == user && user_badge.badge.allow_title?\n      user.title = user_badge.badge.display_name\n      user.save!\n\n      log_params = {\n        details: \"title matching badge id #{user_badge.badge.id}\",\n        previous_value: previous_title,\n        new_value: user.title,\n      }\n\n      if current_user.staff? && current_user != user\n        StaffActionLogger.new(current_user).log_title_change(user, log_params)\n      else\n        UserHistory.create!(\n          log_params.merge(target_user_id: user.id, action: UserHistory.actions[:change_title]),\n        )\n      end\n    else\n      user.title = \"\"\n      user.save!\n\n      log_params = { previous_value: previous_title }\n\n      if current_user.staff? && current_user != user\n        StaffActionLogger.new(current_user).log_title_revoke(\n          user,\n          log_params.merge(\n            revoke_reason: \"user title was same as revoked badge name or custom badge name\",\n          ),\n        )\n      else\n        UserHistory.create!(\n          log_params.merge(target_user_id: user.id, action: UserHistory.actions[:revoke_title]),\n        )\n      end\n    end\n\n    render body: nil\n  end\n\n  def preferences\n    render body: nil\n  end\n\n  def my_redirect\n    raise Discourse::NotFound if params[:path] !~ %r{\\A[a-z_\\-/]+\\z}\n\n    if current_user.blank?\n      cookies[:destination_url] = path(\"/my/#{params[:path]}\")\n      redirect_to path(\"/login-preferences\")\n    else\n      redirect_to(path(\"/u/#{current_user.encoded_username}/#{params[:path]}\"))\n    end\n  end\n\n  def profile_hidden\n    render nothing: true\n  end\n\n  def summary\n    return redirect_to path(\"/login\") if !guardian.public_can_see_profiles?\n\n    @user =\n      fetch_user_from_params(\n        include_inactive:\n          current_user.try(:staff?) || (current_user && SiteSetting.show_inactive_accounts),\n      )\n    raise Discourse::NotFound unless guardian.can_see_profile?(@user)\n\n    response.headers[\"X-Robots-Tag\"] = \"noindex\"\n\n    respond_to do |format|\n      format.html do\n        @restrict_fields = guardian.restrict_user_fields?(@user)\n        render :show\n      end\n      format.json do\n        summary_json =\n          Discourse\n            .cache\n            .fetch(summary_cache_key(@user), expires_in: 1.hour) do\n              summary = UserSummary.new(@user, guardian)\n              serializer = UserSummarySerializer.new(summary, scope: guardian)\n              MultiJson.dump(serializer)\n            end\n        render json: summary_json\n      end\n    end\n  end\n\n  def invited\n    if guardian.can_invite_to_forum?\n      filter = params[:filter] || \"redeemed\"\n      inviter =\n        fetch_user_from_params(\n          include_inactive: current_user.staff? || SiteSetting.show_inactive_accounts,\n        )\n\n      invites =\n        if filter == \"pending\" && guardian.can_see_invite_details?(inviter)\n          Invite.includes(:topics, :groups).pending(inviter)\n        elsif filter == \"expired\"\n          Invite.expired(inviter)\n        elsif filter == \"redeemed\"\n          Invite.redeemed_users(inviter)\n        else\n          Invite.none\n        end\n\n      invites = invites.offset(params[:offset].to_i || 0).limit(SiteSetting.invites_per_page)\n\n      show_emails = guardian.can_see_invite_emails?(inviter)\n      if params[:search].present? && invites.present?\n        filter_sql = \"(LOWER(users.username) LIKE :filter)\"\n        filter_sql =\n          \"(LOWER(invites.email) LIKE :filter) or (LOWER(users.username) LIKE :filter)\" if show_emails\n        invites = invites.where(filter_sql, filter: \"%#{params[:search].downcase}%\")\n      end\n\n      pending_count = Invite.pending(inviter).reorder(nil).count.to_i\n      expired_count = Invite.expired(inviter).reorder(nil).count.to_i\n      redeemed_count = Invite.redeemed_users(inviter).reorder(nil).count.to_i\n\n      render json:\n               MultiJson.dump(\n                 InvitedSerializer.new(\n                   OpenStruct.new(\n                     invite_list: invites.to_a,\n                     show_emails: show_emails,\n                     inviter: inviter,\n                     type: filter,\n                     counts: {\n                       pending: pending_count,\n                       expired: expired_count,\n                       redeemed: redeemed_count,\n                       total: pending_count + expired_count,\n                     },\n                   ),\n                   scope: guardian,\n                   root: false,\n                 ),\n               )\n    elsif current_user&.staff?\n      message =\n        if SiteSetting.enable_discourse_connect\n          I18n.t(\"invite.disabled_errors.discourse_connect_enabled\")\n        end\n\n      render_invite_error(message)\n    else\n      render_json_error(I18n.t(\"invite.disabled_errors.invalid_access\"))\n    end\n  end\n\n  def render_available_true\n    render(json: { available: true })\n  end\n\n  def changing_case_of_own_username(target_user, username)\n    target_user && username.downcase == (target_user.username.downcase)\n  end\n\n  # Used for checking availability of a username and will return suggestions\n  # if the username is not available.\n  def check_username\n    if !params[:username].present?\n      params.require(:username) if !params[:email].present?\n      return render(json: success_json)\n    end\n    username = params[:username]&.unicode_normalize\n\n    target_user = user_from_params_or_current_user\n\n    # The special case where someone is changing the case of their own username\n    return render_available_true if changing_case_of_own_username(target_user, username)\n\n    checker = UsernameCheckerService.new\n    email = params[:email] || target_user.try(:email)\n    render json: checker.check_username(username, email)\n  end\n\n  def check_email\n    begin\n      RateLimiter.new(nil, \"check-email-#{request.remote_ip}\", 10, 1.minute).performed!\n    rescue RateLimiter::LimitExceeded\n      return render json: success_json\n    end\n\n    email = Email.downcase((params[:email] || \"\").strip)\n\n    return render json: success_json if email.blank? || SiteSetting.hide_email_address_taken?\n\n    if !EmailAddressValidator.valid_value?(email)\n      error = User.new.errors.full_message(:email, I18n.t(:\"user.email.invalid\"))\n      return render json: failed_json.merge(errors: [error])\n    end\n\n    if !EmailValidator.allowed?(email)\n      error = User.new.errors.full_message(:email, I18n.t(:\"user.email.not_allowed\"))\n      return render json: failed_json.merge(errors: [error])\n    end\n\n    if ScreenedEmail.should_block?(email)\n      error = User.new.errors.full_message(:email, I18n.t(:\"user.email.blocked\"))\n      return render json: failed_json.merge(errors: [error])\n    end\n\n    if User.where(staged: false).find_by_email(email).present?\n      error = User.new.errors.full_message(:email, I18n.t(:\"errors.messages.taken\"))\n      return render json: failed_json.merge(errors: [error])\n    end\n\n    render json: success_json\n  end\n\n  def user_from_params_or_current_user\n    params[:for_user_id] ? User.find(params[:for_user_id]) : current_user\n  end\n\n  def create\n    params.require(:email)\n    params.require(:username)\n    params.require(:invite_code) if SiteSetting.require_invite_code\n    params.permit(:user_fields)\n    params.permit(:external_ids)\n\n    return fail_with(\"login.new_registrations_disabled\") unless SiteSetting.allow_new_registrations\n\n    if params[:password] && params[:password].length > User.max_password_length\n      return fail_with(\"login.password_too_long\")\n    end\n\n    return fail_with(\"login.email_too_long\") if params[:email].length > 254 + 1 + 253\n\n    if SiteSetting.require_invite_code &&\n         SiteSetting.invite_code.strip.downcase != params[:invite_code].strip.downcase\n      return fail_with(\"login.wrong_invite_code\")\n    end\n\n    if clashing_with_existing_route?(params[:username]) ||\n         User.reserved_username?(params[:username])\n      return fail_with(\"login.reserved_username\")\n    end\n\n    params[:locale] ||= I18n.locale unless current_user\n\n    new_user_params = user_params.except(:timezone)\n\n    user = User.where(staged: true).with_email(new_user_params[:email].strip.downcase).first\n\n    if user\n      user.active = false\n      user.unstage!\n    end\n\n    user ||= User.new\n    user.attributes = new_user_params\n\n    # Handle API approval and\n    # auto approve users based on auto_approve_email_domains setting\n    if user.approved? || EmailValidator.can_auto_approve_user?(user.email)\n      ReviewableUser.set_approved_fields!(user, current_user)\n    end\n\n    # Handle custom fields\n    user_fields = UserField.all\n    if user_fields.present?\n      field_params = params[:user_fields] || {}\n      fields = user.custom_fields\n\n      user_fields.each do |f|\n        field_val = field_params[f.id.to_s]\n        if field_val.blank?\n          return fail_with(\"login.missing_user_field\") if f.required?\n        else\n          fields[\"#{User::USER_FIELD_PREFIX}#{f.id}\"] = field_val[0...UserField.max_length]\n        end\n      end\n\n      user.custom_fields = fields\n    end\n\n    # Handle associated accounts\n    associations = []\n    if params[:external_ids]&.is_a?(ActionController::Parameters) && current_user&.admin? && is_api?\n      params[:external_ids].each do |provider_name, provider_uid|\n        authenticator = Discourse.enabled_authenticators.find { |a| a.name == provider_name }\n        raise Discourse::InvalidParameters.new(:external_ids) if !authenticator&.is_managed?\n\n        association =\n          UserAssociatedAccount.find_or_initialize_by(\n            provider_name: provider_name,\n            provider_uid: provider_uid,\n          )\n        associations << association\n      end\n    end\n\n    authentication = UserAuthenticator.new(user, session)\n\n    if !authentication.has_authenticator? && !SiteSetting.enable_local_logins &&\n         !(current_user&.admin? && is_api?)\n      return render body: nil, status: :forbidden\n    end\n\n    authentication.start\n\n    if authentication.email_valid? && !authentication.authenticated?\n      # posted email is different that the already validated one?\n      return fail_with(\"login.incorrect_username_email_or_password\")\n    end\n\n    activation = UserActivator.new(user, request, session, cookies)\n    activation.start\n\n    # just assign a password if we have an authenticator and no password\n    # this is the case for Twitter\n    user.password = SecureRandom.hex if user.password.blank? &&\n      (authentication.has_authenticator? || associations.present?)\n\n    if user.save\n      authentication.finish\n      activation.finish\n      associations.each { |a| a.update!(user: user) }\n      user.update_timezone_if_missing(params[:timezone])\n\n      secure_session[HONEYPOT_KEY] = nil\n      secure_session[CHALLENGE_KEY] = nil\n\n      # save user email in session, to show on account-created page\n      session[\"user_created_message\"] = activation.message\n      session[SessionController::ACTIVATE_USER_KEY] = user.id\n\n      # If the user was created as active this will\n      # ensure their email is confirmed and\n      # add them to the review queue if they need to be approved\n      user.activate if user.active?\n\n      render json: { success: true, active: user.active?, message: activation.message }.merge(\n               SiteSetting.hide_email_address_taken ? {} : { user_id: user.id },\n             )\n    elsif SiteSetting.hide_email_address_taken &&\n          user.errors[:primary_email]&.include?(I18n.t(\"errors.messages.taken\"))\n      session[\"user_created_message\"] = activation.success_message\n\n      if existing_user = User.find_by_email(user.primary_email&.email)\n        Jobs.enqueue(:critical_user_email, type: \"account_exists\", user_id: existing_user.id)\n      end\n\n      render json: { success: true, active: false, message: activation.success_message }\n    else\n      errors = user.errors.to_hash\n      errors[:email] = errors.delete(:primary_email) if errors[:primary_email]\n\n      render json: {\n               success: false,\n               message: I18n.t(\"login.errors\", errors: user.errors.full_messages.join(\"\\n\")),\n               errors: errors,\n               values: {\n                 name: user.name,\n                 username: user.username,\n                 email: user.primary_email&.email,\n               },\n               is_developer: UsernameCheckerService.is_developer?(user.email),\n             }\n    end\n  rescue ActiveRecord::StatementInvalid\n    render json: { success: false, message: I18n.t(\"login.something_already_taken\") }\n  end\n\n  def password_reset_show\n    expires_now\n    token = params[:token]\n\n    password_reset_find_user(token, committing_change: false)\n\n    if !@error\n      security_params = {\n        is_developer: UsernameCheckerService.is_developer?(@user.email),\n        admin: @user.admin?,\n        second_factor_required: @user.totp_enabled?,\n        security_key_required: @user.security_keys_enabled?,\n        backup_enabled: @user.backup_codes_enabled?,\n        multiple_second_factor_methods: @user.has_multiple_second_factor_methods?,\n      }\n    end\n\n    respond_to do |format|\n      format.html do\n        return render \"password_reset\", layout: \"no_ember\" if @error\n\n        Webauthn.stage_challenge(@user, secure_session)\n        store_preloaded(\n          \"password_reset\",\n          MultiJson.dump(\n            security_params.merge(Webauthn.allowed_credentials(@user, secure_session)),\n          ),\n        )\n\n        render \"password_reset\"\n      end\n\n      format.json do\n        return render json: { message: @error } if @error\n\n        Webauthn.stage_challenge(@user, secure_session)\n        render json: security_params.merge(Webauthn.allowed_credentials(@user, secure_session))\n      end\n    end\n  end\n\n  def password_reset_update\n    expires_now\n    token = params[:token]\n    password_reset_find_user(token, committing_change: true)\n\n    rate_limit_second_factor!(@user)\n\n    # no point doing anything else if we can't even find\n    # a user from the token\n    if @user\n      if !secure_session[\"second-factor-#{token}\"]\n        second_factor_authentication_result =\n          @user.authenticate_second_factor(params, secure_session)\n        if !second_factor_authentication_result.ok\n          user_error_key =\n            (\n              if second_factor_authentication_result.reason == \"invalid_security_key\"\n                :user_second_factors\n              else\n                :security_keys\n              end\n            )\n          @user.errors.add(user_error_key, :invalid)\n          @error = second_factor_authentication_result.error\n        else\n          # this must be set because the first call we authenticate e.g. TOTP, and we do\n          # not want to re-authenticate on the second call to change the password as this\n          # will cause a TOTP error saying the code has already been used\n          secure_session[\"second-factor-#{token}\"] = true\n        end\n      end\n\n      if @invalid_password =\n           params[:password].blank? || params[:password].size > User.max_password_length\n        @user.errors.add(:password, :invalid)\n      end\n\n      # if we have run into no errors then the user is a-ok to\n      # change the password\n      if @user.errors.empty?\n        @user.update_timezone_if_missing(params[:timezone]) if params[:timezone]\n        @user.password = params[:password]\n        @user.password_required!\n        @user.user_auth_tokens.destroy_all\n        if @user.save\n          Invite.invalidate_for_email(@user.email) # invite link can't be used to log in anymore\n          secure_session[\"password-#{token}\"] = nil\n          secure_session[\"second-factor-#{token}\"] = nil\n          UserHistory.create!(\n            target_user: @user,\n            acting_user: @user,\n            action: UserHistory.actions[:change_password],\n          )\n          logon_after_password_reset\n        end\n      end\n    end\n\n    respond_to do |format|\n      format.html do\n        return render \"password_reset\", layout: \"no_ember\" if @error\n\n        Webauthn.stage_challenge(@user, secure_session)\n\n        security_params = {\n          is_developer: UsernameCheckerService.is_developer?(@user.email),\n          admin: @user.admin?,\n          second_factor_required: @user.totp_enabled?,\n          security_key_required: @user.security_keys_enabled?,\n          backup_enabled: @user.backup_codes_enabled?,\n          multiple_second_factor_methods: @user.has_multiple_second_factor_methods?,\n        }.merge(Webauthn.allowed_credentials(@user, secure_session))\n\n        store_preloaded(\"password_reset\", MultiJson.dump(security_params))\n\n        return redirect_to(wizard_path) if Wizard.user_requires_completion?(@user)\n\n        render \"password_reset\"\n      end\n\n      format.json do\n        if @error || @user&.errors&.any?\n          render json: {\n                   success: false,\n                   message: @error,\n                   errors: @user&.errors&.to_hash,\n                   is_developer: UsernameCheckerService.is_developer?(@user&.email),\n                   admin: @user&.admin?,\n                 }\n        else\n          render json: {\n                   success: true,\n                   message: @success,\n                   requires_approval: !Guardian.new(@user).can_access_forum?,\n                   redirect_to: Wizard.user_requires_completion?(@user) ? wizard_path : nil,\n                 }\n        end\n      end\n    end\n  end\n\n  def confirm_email_token\n    expires_now\n    EmailToken.confirm(params[:token], scope: EmailToken.scopes[:signup])\n    render json: success_json\n  end\n\n  def logon_after_password_reset\n    message =\n      if Guardian.new(@user).can_access_forum?\n        # Log in the user\n        log_on_user(@user)\n        \"password_reset.success\"\n      else\n        @requires_approval = true\n        \"password_reset.success_unapproved\"\n      end\n\n    @success = I18n.t(message)\n  end\n\n  def admin_login\n    return redirect_to(path(\"/\")) if current_user\n\n    if request.put? && params[:email].present?\n      RateLimiter.new(nil, \"admin-login-hr-#{request.remote_ip}\", 6, 1.hour).performed!\n      RateLimiter.new(nil, \"admin-login-min-#{request.remote_ip}\", 3, 1.minute).performed!\n\n      if user = User.with_email(params[:email]).admins.human_users.first\n        email_token =\n          user.email_tokens.create!(email: user.email, scope: EmailToken.scopes[:email_login])\n        token_string = email_token.token\n        token_string += \"?safe_mode=no_plugins,no_themes\" if params[\"use_safe_mode\"]\n        Jobs.enqueue(\n          :critical_user_email,\n          type: \"admin_login\",\n          user_id: user.id,\n          email_token: token_string,\n        )\n        @message = I18n.t(\"admin_login.success\")\n      else\n        @message = I18n.t(\"admin_login.errors.unknown_email_address\")\n      end\n    end\n\n    render layout: \"no_ember\"\n  rescue RateLimiter::LimitExceeded\n    @message = I18n.t(\"rate_limiter.slow_down\")\n    render layout: \"no_ember\"\n  end\n\n  def email_login\n    raise Discourse::NotFound if !SiteSetting.enable_local_logins_via_email\n    return redirect_to path(\"/\") if current_user\n\n    expires_now\n    params.require(:login)\n\n    RateLimiter.new(nil, \"email-login-hour-#{request.remote_ip}\", 6, 1.hour).performed!\n    RateLimiter.new(nil, \"email-login-min-#{request.remote_ip}\", 3, 1.minute).performed!\n    user = User.human_users.find_by_username_or_email(params[:login])\n    user_presence = user.present? && !user.staged\n\n    if user\n      RateLimiter.new(nil, \"email-login-hour-#{user.id}\", 6, 1.hour).performed!\n      RateLimiter.new(nil, \"email-login-min-#{user.id}\", 3, 1.minute).performed!\n\n      if user_presence\n        DiscourseEvent.trigger(:before_email_login, user)\n\n        email_token =\n          user.email_tokens.create!(email: user.email, scope: EmailToken.scopes[:email_login])\n\n        Jobs.enqueue(\n          :critical_user_email,\n          type: \"email_login\",\n          user_id: user.id,\n          email_token: email_token.token,\n        )\n      end\n    end\n\n    json = success_json\n    json[:hide_taken] = SiteSetting.hide_email_address_taken\n    json[:user_found] = user_presence unless SiteSetting.hide_email_address_taken\n    render json: json\n  rescue RateLimiter::LimitExceeded\n    render_json_error(I18n.t(\"rate_limiter.slow_down\"))\n  end\n\n  def toggle_anon\n    user =\n      AnonymousShadowCreator.get_master(current_user) || AnonymousShadowCreator.get(current_user)\n\n    if user\n      log_on_user(user)\n      render json: success_json\n    else\n      render json: failed_json, status: 403\n    end\n  end\n\n  def account_created\n    if current_user.present?\n      if SiteSetting.enable_discourse_connect_provider && payload = cookies.delete(:sso_payload)\n        return redirect_to(session_sso_provider_url + \"?\" + payload)\n      elsif destination_url = cookies.delete(:destination_url)\n        return redirect_to(destination_url, allow_other_host: true)\n      else\n        return redirect_to(path(\"/\"))\n      end\n    end\n\n    @custom_body_class = \"static-account-created\"\n    @message = session[\"user_created_message\"] || I18n.t(\"activation.missing_session\")\n    @account_created = { message: @message, show_controls: false }\n\n    if session_user_id = session[SessionController::ACTIVATE_USER_KEY]\n      if user = User.where(id: session_user_id.to_i).first\n        @account_created[:username] = user.username\n        @account_created[:email] = user.email\n        @account_created[:show_controls] = !user.from_staged?\n      end\n    end\n\n    store_preloaded(\"accountCreated\", MultiJson.dump(@account_created))\n    expires_now\n\n    respond_to do |format|\n      format.html { render \"default/empty\" }\n      format.json { render json: success_json }\n    end\n  end\n\n  def activate_account\n    expires_now\n    render layout: \"no_ember\"\n  end\n\n  def perform_account_activation\n    raise Discourse::InvalidAccess.new if honeypot_or_challenge_fails?(params)\n\n    if @user = EmailToken.confirm(params[:token], scope: EmailToken.scopes[:signup])\n      # Log in the user unless they need to be approved\n      if Guardian.new(@user).can_access_forum?\n        @user.enqueue_welcome_message(\"welcome_user\") if @user.send_welcome_message\n        log_on_user(@user)\n\n        # invites#perform_accept_invitation already sets destination_url, but\n        # sometimes it is lost (user changes browser, uses incognito, etc)\n        #\n        # The code below checks if the user was invited and redirects them to\n        # the topic they were originally invited to.\n        destination_url = cookies.delete(:destination_url)\n        if destination_url.blank?\n          topic =\n            Invite\n              .joins(:invited_users)\n              .find_by(invited_users: { user_id: @user.id })\n              &.topics\n              &.first\n\n          destination_url = path(topic.relative_url) if @user.guardian.can_see?(topic)\n        end\n\n        if Wizard.user_requires_completion?(@user)\n          return redirect_to(wizard_path)\n        elsif destination_url.present?\n          return redirect_to(destination_url, allow_other_host: true)\n        elsif SiteSetting.enable_discourse_connect_provider &&\n              payload = cookies.delete(:sso_payload)\n          return redirect_to(session_sso_provider_url + \"?\" + payload)\n        end\n      else\n        @needs_approval = true\n      end\n    else\n      flash.now[:error] = I18n.t(\"activation.already_done\")\n    end\n\n    render layout: \"no_ember\"\n  end\n\n  def update_activation_email\n    RateLimiter.new(nil, \"activate-edit-email-hr-#{request.remote_ip}\", 5, 1.hour).performed!\n\n    if params[:username].present?\n      RateLimiter.new(\n        nil,\n        \"activate-edit-email-hr-username-#{params[:username]}\",\n        5,\n        1.hour,\n      ).performed!\n      @user = User.find_by_username_or_email(params[:username])\n      raise Discourse::InvalidAccess.new unless @user.present?\n      raise Discourse::InvalidAccess.new unless @user.confirm_password?(params[:password])\n    elsif user_key = session[SessionController::ACTIVATE_USER_KEY]\n      RateLimiter.new(nil, \"activate-edit-email-hr-user-key-#{user_key}\", 5, 1.hour).performed!\n      @user = User.where(id: user_key.to_i).first\n    end\n\n    if @user.blank? || @user.active? || current_user.present? || @user.from_staged?\n      raise Discourse::InvalidAccess.new\n    end\n\n    User.transaction do\n      primary_email = @user.primary_email\n      primary_email.email = params[:email]\n      primary_email.skip_validate_email = false\n\n      if primary_email.save\n        @email_token =\n          @user.email_tokens.create!(email: @user.email, scope: EmailToken.scopes[:signup])\n        EmailToken.enqueue_signup_email(@email_token, to_address: @user.email)\n        render json: success_json\n      else\n        render_json_error(primary_email)\n      end\n    end\n  end\n\n  def send_activation_email\n    if current_user.blank? || !current_user.staff?\n      RateLimiter.new(nil, \"activate-hr-#{request.remote_ip}\", 30, 1.hour).performed!\n      RateLimiter.new(nil, \"activate-min-#{request.remote_ip}\", 6, 1.minute).performed!\n    end\n\n    raise Discourse::InvalidAccess.new if SiteSetting.must_approve_users?\n\n    @user = User.find_by_username_or_email(params[:username].to_s) if params[:username].present?\n\n    raise Discourse::NotFound unless @user\n\n    if !current_user&.staff? && @user.id != session[SessionController::ACTIVATE_USER_KEY]\n      raise Discourse::InvalidAccess.new\n    end\n\n    session.delete(SessionController::ACTIVATE_USER_KEY)\n\n    if @user.active && @user.email_confirmed?\n      render_json_error(I18n.t(\"activation.activated\"), status: 409)\n    else\n      @email_token =\n        @user.email_tokens.create!(email: @user.email, scope: EmailToken.scopes[:signup])\n      EmailToken.enqueue_signup_email(@email_token, to_address: @user.email)\n      render body: nil\n    end\n  end\n\n  SEARCH_USERS_LIMIT = 50\n\n  def search_users\n    term = params[:term].to_s.strip\n\n    topic_id = params[:topic_id].to_i if params[:topic_id].present?\n    category_id = params[:category_id].to_i if params[:category_id].present?\n\n    topic_allowed_users = params[:topic_allowed_users] || false\n\n    group_names = params[:groups] || []\n    group_names << params[:group] if params[:group]\n    @groups = Group.where(name: group_names) if group_names.present?\n\n    options = {\n      topic_allowed_users: topic_allowed_users,\n      searching_user: current_user,\n      groups: @groups,\n    }\n\n    options[:include_staged_users] = !!ActiveModel::Type::Boolean.new.cast(\n      params[:include_staged_users],\n    )\n    options[:last_seen_users] = !!ActiveModel::Type::Boolean.new.cast(params[:last_seen_users])\n\n    if limit = fetch_limit_from_params(default: nil, max: SEARCH_USERS_LIMIT)\n      options[:limit] = limit\n    end\n\n    options[:topic_id] = topic_id if topic_id\n    options[:category_id] = category_id if category_id\n\n    results = UserSearch.new(term, options).search\n    to_render = serialize_found_users(results)\n\n    # blank term is only handy for in-topic search of users after @\n    # we do not want group results ever if term is blank\n    groups =\n      if term.present? && current_user\n        if params[:include_groups] == \"true\"\n          Group.visible_groups(current_user)\n        elsif params[:include_mentionable_groups] == \"true\"\n          Group.mentionable(current_user)\n        elsif params[:include_messageable_groups] == \"true\"\n          Group.messageable(current_user)\n        end\n      end\n\n    if groups\n      DiscoursePluginRegistry\n        .groups_callback_for_users_search_controller_action\n        .each do |param_name, block|\n        groups = block.call(groups, current_user) if params[param_name.to_s]\n      end\n\n      # the plugin registry callbacks above are only evaluated when a param\n      # is present matching the name of the callback. Any modifier registered using\n      # register_modifier(:groups_for_users_search) will be evaluated without needing the\n      # param.\n      groups = DiscoursePluginRegistry.apply_modifier(:groups_for_users_search, groups)\n      groups = Group.search_groups(term, groups: groups, sort: :auto)\n\n      to_render[:groups] = groups.map { |m| { name: m.name, full_name: m.full_name } }\n    end\n\n    render json: to_render\n  end\n\n  AVATAR_TYPES_WITH_UPLOAD ||= %w[uploaded custom gravatar]\n\n  def pick_avatar\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    return render json: failed_json, status: 422 if SiteSetting.discourse_connect_overrides_avatar\n\n    type = params[:type]\n\n    invalid_type = type.present? && !AVATAR_TYPES_WITH_UPLOAD.include?(type) && type != \"system\"\n    return render json: failed_json, status: 422 if invalid_type\n\n    if type.blank? || type == \"system\"\n      upload_id = nil\n    elsif !TrustLevelAndStaffAndDisabledSetting.matches?(SiteSetting.allow_uploaded_avatars, user)\n      return render json: failed_json, status: 422\n    else\n      upload_id = params[:upload_id]\n      upload = Upload.find_by(id: upload_id)\n\n      return render_json_error I18n.t(\"avatar.missing\") if upload.nil?\n\n      # old safeguard\n      user.create_user_avatar unless user.user_avatar\n\n      guardian.ensure_can_pick_avatar!(user.user_avatar, upload)\n\n      if type == \"gravatar\"\n        user.user_avatar.gravatar_upload_id = upload_id\n      else\n        user.user_avatar.custom_upload_id = upload_id\n      end\n    end\n\n    SiteSetting.use_site_small_logo_as_system_avatar = false if user.is_system_user?\n\n    user.uploaded_avatar_id = upload_id\n    user.save!\n    user.user_avatar.save!\n\n    render json: success_json\n  end\n\n  def select_avatar\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    url = params[:url]\n\n    return render json: failed_json, status: 422 if url.blank?\n\n    if SiteSetting.selectable_avatars_mode == \"disabled\"\n      return render json: failed_json, status: 422\n    end\n\n    return render json: failed_json, status: 422 if SiteSetting.selectable_avatars.blank?\n\n    unless upload = Upload.get_from_url(url)\n      return render json: failed_json, status: 422\n    end\n\n    unless SiteSetting.selectable_avatars.include?(upload)\n      return render json: failed_json, status: 422\n    end\n\n    user.uploaded_avatar_id = upload.id\n\n    SiteSetting.use_site_small_logo_as_system_avatar = false if user.is_system_user?\n\n    user.save!\n\n    avatar = user.user_avatar || user.create_user_avatar\n    avatar.custom_upload_id = upload.id\n    avatar.save!\n\n    render json: {\n             avatar_template: user.avatar_template,\n             custom_avatar_template: user.avatar_template,\n             uploaded_avatar_id: upload.id,\n           }\n  end\n\n  def destroy_user_image\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    case params.require(:type)\n    when \"profile_background\"\n      user.user_profile.clear_profile_background\n    when \"card_background\"\n      user.user_profile.clear_card_background\n    else\n      raise Discourse::InvalidParameters.new(:type)\n    end\n\n    render json: success_json\n  end\n\n  def destroy\n    @user = fetch_user_from_params\n    guardian.ensure_can_delete_user!(@user)\n\n    UserDestroyer.new(current_user).destroy(@user, delete_posts: true, context: params[:context])\n\n    render json: success_json\n  end\n\n  def notification_level\n    target_user = fetch_user_from_params\n    acting_user = current_user\n\n    # the admin should be able to change notification levels\n    # on behalf of other users, so we cannot rely on current_user\n    # for this case\n    if params[:acting_user_id].present? && params[:acting_user_id].to_i != current_user.id\n      if current_user.staff?\n        acting_user = User.find(params[:acting_user_id])\n      else\n        @error_message = \"error\"\n        raise Discourse::InvalidAccess\n      end\n    end\n\n    if params[:notification_level] == \"ignore\"\n      @error_message = \"ignore_error\"\n      guardian.ensure_can_ignore_user!(target_user)\n      MutedUser.where(user: acting_user, muted_user: target_user).delete_all\n      ignored_user = IgnoredUser.find_by(user: acting_user, ignored_user: target_user)\n      if ignored_user.present?\n        ignored_user.update(expiring_at: DateTime.parse(params[:expiring_at]))\n      else\n        IgnoredUser.create!(\n          user: acting_user,\n          ignored_user: target_user,\n          expiring_at: Time.parse(params[:expiring_at]),\n        )\n      end\n    elsif params[:notification_level] == \"mute\"\n      @error_message = \"mute_error\"\n      guardian.ensure_can_mute_user!(target_user)\n      IgnoredUser.where(user: acting_user, ignored_user: target_user).delete_all\n      MutedUser.find_or_create_by!(user: acting_user, muted_user: target_user)\n    elsif params[:notification_level] == \"normal\"\n      MutedUser.where(user: acting_user, muted_user: target_user).delete_all\n      IgnoredUser.where(user: acting_user, ignored_user: target_user).delete_all\n    else\n      return(\n        render_json_error(\n          I18n.t(\"notification_level.invalid_value\", value: params[:notification_level]),\n        )\n      )\n    end\n\n    render json: success_json\n  rescue Discourse::InvalidAccess\n    render_json_error(I18n.t(\"notification_level.#{@error_message}\"))\n  end\n\n  def read_faq\n    if user = current_user\n      user.user_stat.read_faq = 1.second.ago\n      user.user_stat.save\n    end\n\n    render json: success_json\n  end\n\n  def recent_searches\n    if !SiteSetting.log_search_queries\n      return(\n        render json: failed_json.merge(error: I18n.t(\"user_activity.no_log_search_queries\")),\n               status: 403\n      )\n    end\n\n    query = SearchLog.where(user_id: current_user.id)\n\n    if current_user.user_option.oldest_search_log_date\n      query = query.where(\"created_at > ?\", current_user.user_option.oldest_search_log_date)\n    end\n\n    results =\n      query.group(:term).order(\"max(created_at) DESC\").limit(MAX_RECENT_SEARCHES).pluck(:term)\n\n    render json: success_json.merge(recent_searches: results)\n  end\n\n  def reset_recent_searches\n    current_user.user_option.update!(oldest_search_log_date: 1.second.ago)\n    render json: success_json\n  end\n\n  def staff_info\n    @user = fetch_user_from_params(include_inactive: true)\n    guardian.ensure_can_see_staff_info!(@user)\n\n    result = {}\n\n    %W[\n      number_of_deleted_posts\n      number_of_flagged_posts\n      number_of_flags_given\n      number_of_suspensions\n      warnings_received_count\n      number_of_rejected_posts\n    ].each { |info| result[info] = @user.public_send(info) }\n\n    render json: result\n  end\n\n  def confirm_admin\n    @confirmation = AdminConfirmation.find_by_code(params[:token])\n\n    raise Discourse::NotFound unless @confirmation\n    unless @confirmation.performed_by.id == (current_user&.id || @confirmation.performed_by.id)\n      raise Discourse::InvalidAccess.new\n    end\n\n    if request.post?\n      @confirmation.email_confirmed!\n      @confirmed = true\n    end\n\n    respond_to do |format|\n      format.json { render json: success_json }\n      format.html { render layout: \"no_ember\" }\n    end\n  end\n\n  def list_second_factors\n    if SiteSetting.enable_discourse_connect || !SiteSetting.enable_local_logins\n      raise Discourse::NotFound\n    end\n\n    unless params[:password].empty?\n      RateLimiter.new(\n        nil,\n        \"login-hr-#{request.remote_ip}\",\n        SiteSetting.max_logins_per_ip_per_hour,\n        1.hour,\n      ).performed!\n      RateLimiter.new(\n        nil,\n        \"login-min-#{request.remote_ip}\",\n        SiteSetting.max_logins_per_ip_per_minute,\n        1.minute,\n      ).performed!\n      unless current_user.confirm_password?(params[:password])\n        return render json: failed_json.merge(error: I18n.t(\"login.incorrect_password\"))\n      end\n      confirm_secure_session\n    end\n\n    if secure_session_confirmed?\n      totp_second_factors =\n        current_user\n          .totps\n          .select(:id, :name, :last_used, :created_at, :method)\n          .where(enabled: true)\n          .order(:created_at)\n\n      security_keys =\n        current_user\n          .security_keys\n          .where(factor_type: UserSecurityKey.factor_types[:second_factor])\n          .order(:created_at)\n\n      render json: success_json.merge(totps: totp_second_factors, security_keys: security_keys)\n    else\n      render json: success_json.merge(password_required: true)\n    end\n  end\n\n  def create_second_factor_backup\n    backup_codes = current_user.generate_backup_codes\n\n    render json: success_json.merge(backup_codes: backup_codes)\n  end\n\n  def create_second_factor_totp\n    require \"rotp\" if !defined?(ROTP)\n    totp_data = ROTP::Base32.random\n    secure_session[\"staged-totp-#{current_user.id}\"] = totp_data\n    qrcode_png =\n      RQRCode::QRCode.new(current_user.totp_provisioning_uri(totp_data)).as_png(\n        border_modules: 1,\n        size: 240,\n      )\n\n    render json:\n             success_json.merge(key: totp_data.scan(/.{4}/).join(\" \"), qr: qrcode_png.to_data_url)\n  end\n\n  def create_second_factor_security_key\n    if current_user.all_security_keys.count >= UserSecurityKey::MAX_KEYS_PER_USER\n      render_json_error(I18n.t(\"login.too_many_security_keys\"), status: 422)\n      return\n    end\n\n    challenge_session = Webauthn.stage_challenge(current_user, secure_session)\n    render json:\n             success_json.merge(\n               challenge: challenge_session.challenge,\n               rp_id: challenge_session.rp_id,\n               rp_name: challenge_session.rp_name,\n               supported_algorithms: ::Webauthn::SUPPORTED_ALGORITHMS,\n               user_secure_id: current_user.create_or_fetch_secure_identifier,\n               existing_active_credential_ids:\n                 current_user.second_factor_security_key_credential_ids,\n             )\n  end\n\n  def register_second_factor_security_key\n    params.require(:name)\n    params.require(:attestation)\n    params.require(:clientData)\n\n    ::Webauthn::SecurityKeyRegistrationService.new(\n      current_user,\n      params,\n      challenge: Webauthn.challenge(current_user, secure_session),\n      rp_id: Webauthn.rp_id(current_user, secure_session),\n      origin: Discourse.base_url,\n    ).register_second_factor_security_key\n    render json: success_json\n  rescue ::Webauthn::SecurityKeyError => err\n    render json: failed_json.merge(error: err.message)\n  end\n\n  def update_security_key\n    user_security_key = current_user.security_keys.find_by(id: params[:id].to_i)\n    raise Discourse::InvalidParameters unless user_security_key\n\n    user_security_key.update!(name: params[:name]) if params[:name] && !params[:name].blank?\n    user_security_key.update!(enabled: false) if params[:disable] == \"true\"\n\n    render json: success_json\n  end\n\n  def enable_second_factor_totp\n    if params[:second_factor_token].blank?\n      return render json: failed_json.merge(error: I18n.t(\"login.missing_second_factor_code\"))\n    end\n    if params[:name].blank?\n      return render json: failed_json.merge(error: I18n.t(\"login.missing_second_factor_name\"))\n    end\n    auth_token = params[:second_factor_token]\n\n    totp_data = secure_session[\"staged-totp-#{current_user.id}\"]\n    totp_object = current_user.get_totp_object(totp_data)\n\n    rate_limit_second_factor!(current_user)\n\n    authenticated =\n      !auth_token.blank? &&\n        totp_object.verify(\n          auth_token,\n          drift_ahead: SecondFactorManager::TOTP_ALLOWED_DRIFT_SECONDS,\n          drift_behind: SecondFactorManager::TOTP_ALLOWED_DRIFT_SECONDS,\n        )\n    unless authenticated\n      return render json: failed_json.merge(error: I18n.t(\"login.invalid_second_factor_code\"))\n    end\n    current_user.create_totp(data: totp_data, name: params[:name], enabled: true)\n    render json: success_json\n  end\n\n  def disable_second_factor\n    # delete all second factors for a user\n    current_user.user_second_factors.destroy_all\n    current_user.security_keys.destroy_all\n\n    Jobs.enqueue(\n      :critical_user_email,\n      type: \"account_second_factor_disabled\",\n      user_id: current_user.id,\n    )\n\n    render json: success_json\n  end\n\n  def update_second_factor\n    params.require(:second_factor_target)\n    update_second_factor_method = params[:second_factor_target].to_i\n\n    if update_second_factor_method == UserSecondFactor.methods[:totp]\n      params.require(:id)\n      second_factor_id = params[:id].to_i\n      user_second_factor = current_user.user_second_factors.totps.find_by(id: second_factor_id)\n    elsif update_second_factor_method == UserSecondFactor.methods[:backup_codes]\n      user_second_factor = current_user.user_second_factors.backup_codes\n    end\n\n    raise Discourse::InvalidParameters unless user_second_factor\n\n    user_second_factor.update!(name: params[:name]) if params[:name] && !params[:name].blank?\n    if params[:disable] == \"true\"\n      # Disabling backup codes deletes *all* backup codes\n      if update_second_factor_method == UserSecondFactor.methods[:backup_codes]\n        current_user\n          .user_second_factors\n          .where(method: UserSecondFactor.methods[:backup_codes])\n          .destroy_all\n      else\n        user_second_factor.update!(enabled: false)\n      end\n    end\n\n    render json: success_json\n  end\n\n  def second_factor_check_confirmed_password\n    if SiteSetting.enable_discourse_connect || !SiteSetting.enable_local_logins\n      raise Discourse::NotFound\n    end\n\n    raise Discourse::InvalidAccess.new unless current_user && secure_session_confirmed?\n  end\n\n  def revoke_account\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n    provider_name = params.require(:provider_name)\n\n    # Using Discourse.authenticators rather than Discourse.enabled_authenticators so users can\n    # revoke permissions even if the admin has temporarily disabled that type of login\n    authenticator = Discourse.authenticators.find { |a| a.name == provider_name }\n    raise Discourse::NotFound if authenticator.nil? || !authenticator.can_revoke?\n\n    skip_remote = params.permit(:skip_remote)\n\n    # We're likely going to contact the remote auth provider, so hijack request\n    hijack do\n      DiscourseEvent.trigger(:before_auth_revoke, authenticator, user)\n      result = authenticator.revoke(user, skip_remote: skip_remote)\n      if result\n        render json: success_json\n      else\n        render json: {\n                 success: false,\n                 message: I18n.t(\"associated_accounts.revoke_failed\", provider_name: provider_name),\n               }\n      end\n    end\n  end\n\n  def revoke_auth_token\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    if params[:token_id]\n      token = UserAuthToken.find_by(id: params[:token_id], user_id: user.id)\n      # The user should not be able to revoke the auth token of current session.\n      if !token || guardian.auth_token == token.auth_token\n        raise Discourse::InvalidParameters.new(:token_id)\n      end\n      UserAuthToken.where(id: params[:token_id], user_id: user.id).each(&:destroy!)\n\n      MessageBus.publish \"/file-change\", [\"refresh\"], user_ids: [user.id]\n    else\n      UserAuthToken.where(user_id: user.id).each(&:destroy!)\n    end\n\n    render json: success_json\n  end\n\n  def feature_topic\n    user = fetch_user_from_params\n    topic = Topic.find(params[:topic_id].to_i)\n\n    if !guardian.can_feature_topic?(user, topic)\n      return(\n        render_json_error(\n          I18n.t(\"activerecord.errors.models.user_profile.attributes.featured_topic_id.invalid\"),\n          403,\n        )\n      )\n    end\n\n    user.user_profile.update(featured_topic_id: topic.id)\n    render json: success_json\n  end\n\n  def clear_featured_topic\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n    user.user_profile.update(featured_topic_id: nil)\n    render json: success_json\n  end\n\n  BOOKMARKS_LIMIT = 20\n\n  def bookmarks\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n    user_guardian = Guardian.new(user)\n\n    respond_to do |format|\n      format.json do\n        bookmark_list =\n          UserBookmarkList.new(\n            user: user,\n            guardian: guardian,\n            search_term: params[:q],\n            page: params[:page],\n            per_page: fetch_limit_from_params(default: nil, max: BOOKMARKS_LIMIT),\n          )\n\n        bookmark_list.load\n\n        if bookmark_list.bookmarks.empty?\n          render json: { bookmarks: [] }\n        else\n          page = params[:page].to_i + 1\n          bookmark_list.more_bookmarks_url =\n            \"#{Discourse.base_path}/u/#{params[:username]}/bookmarks.json?page=#{page}\"\n          render_serialized(bookmark_list, UserBookmarkListSerializer)\n        end\n      end\n      format.ics do\n        @bookmark_reminders =\n          Bookmark\n            .with_reminders\n            .where(user_id: user.id)\n            .order(:reminder_at)\n            .map do |bookmark|\n              bookmark.registered_bookmarkable.serializer.new(\n                bookmark,\n                scope: user_guardian,\n                root: false,\n              )\n            end\n      end\n    end\n  end\n\n  USER_MENU_LIST_LIMIT = 20\n  def user_menu_bookmarks\n    if !current_user.username_equals_to?(params[:username])\n      raise Discourse::InvalidAccess.new(\"username doesn't match current_user's username\")\n    end\n\n    reminder_notifications =\n      Notification\n        .for_user_menu(current_user.id, limit: USER_MENU_LIST_LIMIT)\n        .unread\n        .where(notification_type: Notification.types[:bookmark_reminder])\n\n    if reminder_notifications.size < USER_MENU_LIST_LIMIT\n      exclude_bookmark_ids =\n        reminder_notifications.filter_map { |notification| notification.data_hash[:bookmark_id] }\n\n      bookmark_list =\n        UserBookmarkList.new(\n          user: current_user,\n          guardian: guardian,\n          per_page: USER_MENU_LIST_LIMIT - reminder_notifications.size,\n        )\n\n      bookmark_list.load do |query|\n        if exclude_bookmark_ids.present?\n          query.where(\"bookmarks.id NOT IN (?)\", exclude_bookmark_ids)\n        end\n      end\n    end\n\n    if reminder_notifications.present?\n      serialized_notifications =\n        ActiveModel::ArraySerializer.new(\n          reminder_notifications,\n          each_serializer: NotificationSerializer,\n          scope: guardian,\n        )\n    end\n\n    if bookmark_list\n      bookmark_list.bookmark_serializer_opts = { link_to_first_unread_post: true }\n      serialized_bookmarks =\n        serialize_data(bookmark_list, UserBookmarkListSerializer, scope: guardian, root: false)[\n          :bookmarks\n        ]\n    end\n\n    render json: {\n             notifications: serialized_notifications || [],\n             bookmarks: serialized_bookmarks || [],\n           }\n  end\n\n  def user_menu_messages\n    if !current_user.username_equals_to?(params[:username])\n      raise Discourse::InvalidAccess.new(\"username doesn't match current_user's username\")\n    end\n\n    if !current_user.staff? &&\n         !current_user.in_any_groups?(SiteSetting.personal_message_enabled_groups_map)\n      raise Discourse::InvalidAccess.new(\"personal messages are disabled.\")\n    end\n\n    unread_notifications =\n      Notification\n        .for_user_menu(current_user.id, limit: USER_MENU_LIST_LIMIT)\n        .unread\n        .where(\n          notification_type: [\n            Notification.types[:private_message],\n            Notification.types[:group_message_summary],\n          ],\n        )\n        .to_a\n\n    if unread_notifications.size < USER_MENU_LIST_LIMIT\n      exclude_topic_ids = unread_notifications.filter_map(&:topic_id).uniq\n      limit = USER_MENU_LIST_LIMIT - unread_notifications.size\n\n      messages_list =\n        TopicQuery\n          .new(current_user, per_page: limit)\n          .list_private_messages_direct_and_groups(\n            current_user,\n            groups_messages_notification_level: :watching,\n          ) do |query|\n            if exclude_topic_ids.present?\n              query.where(\"topics.id NOT IN (?)\", exclude_topic_ids)\n            else\n              query\n            end\n          end\n\n      read_notifications =\n        Notification\n          .for_user_menu(current_user.id, limit: limit)\n          .where(read: true, notification_type: Notification.types[:group_message_summary])\n          .to_a\n    end\n\n    if unread_notifications.present?\n      serialized_unread_notifications =\n        ActiveModel::ArraySerializer.new(\n          unread_notifications,\n          each_serializer: NotificationSerializer,\n          scope: guardian,\n        )\n    end\n\n    if messages_list\n      serialized_messages =\n        serialize_data(messages_list, TopicListSerializer, scope: guardian, root: false)[:topics]\n    end\n\n    if read_notifications.present?\n      serialized_read_notifications =\n        ActiveModel::ArraySerializer.new(\n          read_notifications,\n          each_serializer: NotificationSerializer,\n          scope: guardian,\n        )\n    end\n\n    render json: {\n             unread_notifications: serialized_unread_notifications || [],\n             read_notifications: serialized_read_notifications || [],\n             topics: serialized_messages || [],\n           }\n  end\n\n  private\n\n  def clean_custom_field_values(field)\n    field_values = params[:user_fields][field.id.to_s]\n\n    return field_values if field_values.nil? || field_values.empty?\n\n    if field.field_type == \"dropdown\"\n      field.user_field_options.find_by_value(field_values)&.value\n    elsif field.field_type == \"multiselect\"\n      field_values = Array.wrap(field_values)\n      bad_values = field_values - field.user_field_options.map(&:value)\n      field_values - bad_values\n    else\n      field_values\n    end\n  end\n\n  def password_reset_find_user(token, committing_change:)\n    @user =\n      if committing_change\n        EmailToken.confirm(token, scope: EmailToken.scopes[:password_reset])\n      else\n        EmailToken.confirmable(token, scope: EmailToken.scopes[:password_reset])&.user\n      end\n\n    if @user\n      secure_session[\"password-#{token}\"] = @user.id\n    else\n      user_id = secure_session[\"password-#{token}\"].to_i\n      @user = User.find(user_id) if user_id > 0\n    end\n\n    @error = I18n.t(\"password_reset.no_token\", base_url: Discourse.base_url) if !@user\n  end\n\n  def respond_to_suspicious_request\n    if suspicious?(params)\n      render json: {\n               success: true,\n               active: false,\n               message: I18n.t(\"login.activate_email\", email: params[:email]),\n             }\n    end\n  end\n\n  def suspicious?(params)\n    return false if current_user && is_api? && current_user.admin?\n    honeypot_or_challenge_fails?(params) || SiteSetting.invite_only?\n  end\n\n  def honeypot_or_challenge_fails?(params)\n    return false if is_api?\n    params[:password_confirmation] != honeypot_value ||\n      params[:challenge] != challenge_value.try(:reverse)\n  end\n\n  def user_params\n    permitted = %i[\n      name\n      email\n      password\n      username\n      title\n      date_of_birth\n      muted_usernames\n      allowed_pm_usernames\n      theme_ids\n      locale\n      bio_raw\n      location\n      website\n      dismissed_banner_key\n      profile_background_upload_url\n      card_background_upload_url\n      primary_group_id\n      flair_group_id\n      featured_topic_id\n    ]\n\n    editable_custom_fields = User.editable_user_custom_fields(by_staff: current_user.try(:staff?))\n    permitted << { custom_fields: editable_custom_fields } unless editable_custom_fields.blank?\n    permitted.concat UserUpdater::OPTION_ATTR\n    permitted.concat UserUpdater::CATEGORY_IDS.keys.map { |k| { k => [] } }\n    permitted.concat UserUpdater::TAG_NAMES.keys\n    permitted << UserUpdater::NOTIFICATION_SCHEDULE_ATTRS\n\n    if !SiteSetting.legacy_navigation_menu?\n      if params.has_key?(:sidebar_category_ids) && params[:sidebar_category_ids].blank?\n        params[:sidebar_category_ids] = []\n      end\n\n      permitted << { sidebar_category_ids: [] }\n\n      if SiteSetting.tagging_enabled\n        if params.has_key?(:sidebar_tag_names) && params[:sidebar_tag_names].blank?\n          params[:sidebar_tag_names] = []\n        end\n\n        permitted << { sidebar_tag_names: [] }\n      end\n    end\n\n    if SiteSetting.enable_user_status\n      permitted << :status\n      permitted << { status: %i[emoji description ends_at] }\n    end\n\n    result =\n      params.permit(permitted, theme_ids: [], seen_popups: []).reverse_merge(\n        ip_address: request.remote_ip,\n        registration_ip_address: request.remote_ip,\n      )\n\n    if !UsernameCheckerService.is_developer?(result[\"email\"]) && is_api? && current_user.present? &&\n         current_user.admin?\n      result.merge!(params.permit(:active, :staged, :approved))\n    end\n\n    deprecate_modify_user_params_method\n    result = modify_user_params(result)\n    DiscoursePluginRegistry.apply_modifier(\n      :users_controller_update_user_params,\n      result,\n      current_user,\n      params,\n    )\n  end\n\n  # Plugins can use this to modify user parameters\n  def modify_user_params(attrs)\n    attrs\n  end\n\n  def deprecate_modify_user_params_method\n    # only issue a deprecation warning if the method is overriden somewhere\n    if method(:modify_user_params).source_location[0] !=\n         \"#{Rails.root}/app/controllers/users_controller.rb\"\n      Discourse.deprecate(\n        \"`UsersController#modify_user_params` method is deprecated. Please use the `users_controller_update_user_params` modifier instead.\",\n        since: \"3.1.0.beta4\",\n        drop_from: \"3.2.0\",\n      )\n    end\n  end\n\n  def fail_with(key)\n    render json: { success: false, message: I18n.t(key) }\n  end\n\n  def track_visit_to_user_profile\n    user_profile_id = @user.user_profile.id\n    ip = request.remote_ip\n    user_id = (current_user.id if current_user)\n\n    Scheduler::Defer.later \"Track profile view visit\" do\n      UserProfileView.add(user_profile_id, ip, user_id)\n    end\n  end\n\n  def clashing_with_existing_route?(username)\n    normalized_username = User.normalize_username(username)\n    http_verbs = %w[GET POST PUT DELETE PATCH]\n    allowed_actions = %w[show update destroy]\n\n    http_verbs.any? do |verb|\n      begin\n        path = Rails.application.routes.recognize_path(\"/u/#{normalized_username}\", method: verb)\n        allowed_actions.exclude?(path[:action])\n      rescue ActionController::RoutingError\n        false\n      end\n    end\n  end\n\n  def confirm_secure_session\n    secure_session[\"confirmed-password-#{current_user.id}\"] = \"true\"\n  end\n\n  def secure_session_confirmed?\n    secure_session[\"confirmed-password-#{current_user.id}\"] == \"true\"\n  end\n\n  def summary_cache_key(user)\n    \"user_summary:#{user.id}:#{current_user ? current_user.id : 0}\"\n  end\n\n  def render_invite_error(message)\n    render json: { invites: [], can_see_invite_details: false, error: message }\n  end\n\n  def serialize_found_users(users)\n    each_serializer =\n      SiteSetting.enable_user_status? ? FoundUserWithStatusSerializer : FoundUserSerializer\n\n    { users: ActiveModel::ArraySerializer.new(users, each_serializer: each_serializer).as_json }\n  end\nend\n", "# frozen_string_literal: true\n\nclass Notification < ActiveRecord::Base\n  belongs_to :user\n  belongs_to :topic\n\n  has_one :shelved_notification\n\n  MEMBERSHIP_REQUEST_CONSOLIDATION_WINDOW_HOURS = 24\n\n  validates_presence_of :data\n  validates_presence_of :notification_type\n\n  scope :unread, lambda { where(read: false) }\n  scope :recent,\n        lambda { |n = nil|\n          n ||= 10\n          order(\"notifications.created_at desc\").limit(n)\n        }\n  scope :visible,\n        lambda {\n          joins(\"LEFT JOIN topics ON notifications.topic_id = topics.id\").where(\n            \"topics.id IS NULL OR topics.deleted_at IS NULL\",\n          )\n        }\n  scope :unread_type, ->(user, type, limit = 30) { unread_types(user, [type], limit) }\n  scope :unread_types,\n        ->(user, types, limit = 30) {\n          where(user_id: user.id, read: false, notification_type: types)\n            .visible\n            .includes(:topic)\n            .limit(limit)\n        }\n  scope :prioritized,\n        ->(deprioritized_types = []) {\n          scope = order(\"notifications.high_priority AND NOT notifications.read DESC\")\n          if deprioritized_types.present?\n            scope =\n              scope.order(\n                DB.sql_fragment(\n                  \"NOT notifications.read AND notifications.notification_type NOT IN (?) DESC\",\n                  deprioritized_types,\n                ),\n              )\n          else\n            scope = scope.order(\"NOT notifications.read DESC\")\n          end\n          scope.order(\"notifications.created_at DESC\")\n        }\n  scope :for_user_menu,\n        ->(user_id, limit: 30) {\n          where(user_id: user_id).visible.prioritized.includes(:topic).limit(limit)\n        }\n\n  attr_accessor :skip_send_email\n\n  after_commit :refresh_notification_count, on: %i[create update destroy]\n  after_commit :send_email, on: :create\n\n  after_commit(on: :create) { DiscourseEvent.trigger(:notification_created, self) }\n\n  before_create do\n    # if we have manually set the notification to high_priority on create then\n    # make sure that is respected\n    self.high_priority =\n      self.high_priority || Notification.high_priority_types.include?(self.notification_type)\n  end\n\n  def self.consolidate_or_create!(notification_params)\n    notification = new(notification_params)\n    consolidation_planner = Notifications::ConsolidationPlanner.new\n\n    consolidated_notification = consolidation_planner.consolidate_or_save!(notification)\n\n    consolidated_notification == :no_plan ? notification.tap(&:save!) : consolidated_notification\n  end\n\n  def self.purge_old!\n    return if SiteSetting.max_notifications_per_user == 0\n\n    DB.exec(<<~SQL, SiteSetting.max_notifications_per_user)\n      DELETE FROM notifications n1\n      USING (\n        SELECT * FROM (\n          SELECT\n            user_id,\n            id,\n            rank() OVER (PARTITION BY user_id ORDER BY id DESC)\n          FROM notifications\n        ) AS X\n        WHERE rank = ?\n      ) n2\n      WHERE n1.user_id = n2.user_id AND n1.id < n2.id\n    SQL\n  end\n\n  def self.ensure_consistency!\n    DB.exec(<<~SQL)\n      DELETE\n        FROM notifications n\n       WHERE high_priority\n         AND n.topic_id IS NOT NULL\n         AND NOT EXISTS (\n            SELECT 1\n              FROM posts p\n              JOIN topics t ON t.id = p.topic_id\n             WHERE p.deleted_at IS NULL\n               AND t.deleted_at IS NULL\n               AND p.post_number = n.post_number\n               AND t.id = n.topic_id\n          )\n    SQL\n  end\n\n  def self.types\n    @types ||=\n      Enum.new(\n        mentioned: 1,\n        replied: 2,\n        quoted: 3,\n        edited: 4,\n        liked: 5,\n        private_message: 6,\n        invited_to_private_message: 7,\n        invitee_accepted: 8,\n        posted: 9,\n        moved_post: 10,\n        linked: 11,\n        granted_badge: 12,\n        invited_to_topic: 13,\n        custom: 14,\n        group_mentioned: 15,\n        group_message_summary: 16,\n        watching_first_post: 17,\n        topic_reminder: 18,\n        liked_consolidated: 19,\n        post_approved: 20,\n        code_review_commit_approved: 21,\n        membership_request_accepted: 22,\n        membership_request_consolidated: 23,\n        bookmark_reminder: 24,\n        reaction: 25,\n        votes_released: 26,\n        event_reminder: 27,\n        event_invitation: 28,\n        chat_mention: 29,\n        chat_message: 30,\n        chat_invitation: 31,\n        chat_group_mention: 32, # March 2022 - This is obsolete, as all chat_mentions use `chat_mention` type\n        chat_quoted: 33,\n        assigned: 34,\n        question_answer_user_commented: 35, # Used by https://github.com/discourse/discourse-question-answer\n        watching_category_or_tag: 36,\n        new_features: 37,\n        admin_problems: 38,\n        following: 800, # Used by https://github.com/discourse/discourse-follow\n        following_created_topic: 801, # Used by https://github.com/discourse/discourse-follow\n        following_replied: 802, # Used by https://github.com/discourse/discourse-follow\n        circles_activity: 900, # Used by https://github.com/discourse/discourse-circles\n      )\n  end\n\n  def self.high_priority_types\n    @high_priority_types ||= [types[:private_message], types[:bookmark_reminder]]\n  end\n\n  def self.normal_priority_types\n    @normal_priority_types ||= types.reject { |_k, v| high_priority_types.include?(v) }.values\n  end\n\n  def self.mark_posts_read(user, topic_id, post_numbers)\n    Notification.where(\n      user_id: user.id,\n      topic_id: topic_id,\n      post_number: post_numbers,\n      read: false,\n    ).update_all(read: true)\n  end\n\n  def self.read(user, notification_ids)\n    Notification.where(id: notification_ids, user_id: user.id, read: false).update_all(read: true)\n  end\n\n  def self.read_types(user, types = nil)\n    query = Notification.where(user_id: user.id, read: false)\n    query = query.where(notification_type: types) if types\n    query.update_all(read: true)\n  end\n\n  def self.interesting_after(min_date)\n    result =\n      where(\"created_at > ?\", min_date)\n        .includes(:topic)\n        .visible\n        .unread\n        .limit(20)\n        .order(\n          \"CASE WHEN notification_type = #{Notification.types[:replied]} THEN 1\n                           WHEN notification_type = #{Notification.types[:mentioned]} THEN 2\n                           ELSE 3\n                      END, created_at DESC\",\n        )\n        .to_a\n\n    # Remove any duplicates by type and topic\n    if result.present?\n      seen = {}\n      to_remove = Set.new\n\n      result.each do |r|\n        seen[r.notification_type] ||= Set.new\n        if seen[r.notification_type].include?(r.topic_id)\n          to_remove << r.id\n        else\n          seen[r.notification_type] << r.topic_id\n        end\n      end\n      result.reject! { |r| to_remove.include?(r.id) }\n    end\n\n    result\n  end\n\n  # Clean up any notifications the user can no longer see. For example, if a topic was previously\n  # public then turns private.\n  def self.remove_for(user_id, topic_id)\n    Notification.where(user_id: user_id, topic_id: topic_id).delete_all\n  end\n\n  # Be wary of calling this frequently. O(n) JSON parsing can suck.\n  def data_hash\n    @data_hash ||=\n      begin\n        return {} if data.blank?\n\n        parsed = JSON.parse(data)\n        return {} if parsed.blank?\n\n        parsed.with_indifferent_access\n      end\n  end\n\n  def url\n    topic.relative_url(post_number) if topic.present?\n  end\n\n  def post\n    return if topic_id.blank? || post_number.blank?\n    Post.find_by(topic_id: topic_id, post_number: post_number)\n  end\n\n  def self.like_types\n    [\n      Notification.types[:liked],\n      Notification.types[:liked_consolidated],\n      Notification.types[:reaction],\n    ]\n  end\n\n  def self.prioritized_list(user, count: 30, types: [])\n    return [] if !user&.user_option\n\n    notifications =\n      user\n        .notifications\n        .includes(:topic)\n        .visible\n        .prioritized(types.present? ? [] : like_types)\n        .limit(count)\n\n    if types.present?\n      notifications = notifications.where(notification_type: types)\n    elsif user.user_option.like_notification_frequency ==\n          UserOption.like_notification_frequency_type[:never]\n      like_types.each do |notification_type|\n        notifications = notifications.where(\"notification_type <> ?\", notification_type)\n      end\n    end\n    notifications.to_a\n  end\n\n  def self.recent_report(user, count = nil, types = [])\n    return unless user && user.user_option\n\n    count ||= 10\n    notifications = user.notifications.visible.recent(count).includes(:topic)\n\n    notifications = notifications.where(notification_type: types) if types.present?\n    if user.user_option.like_notification_frequency ==\n         UserOption.like_notification_frequency_type[:never]\n      [\n        Notification.types[:liked],\n        Notification.types[:liked_consolidated],\n      ].each do |notification_type|\n        notifications = notifications.where(\"notification_type <> ?\", notification_type)\n      end\n    end\n\n    notifications = notifications.to_a\n\n    if notifications.present?\n      builder = DB.build(<<~SQL)\n         SELECT n.id FROM notifications n\n         /*where*/\n        ORDER BY n.id ASC\n        /*limit*/\n      SQL\n\n      builder.where(<<~SQL, user_id: user.id)\n        n.high_priority = TRUE AND\n        n.user_id = :user_id AND\n        NOT read\n      SQL\n      builder.where(\"notification_type IN (:types)\", types: types) if types.present?\n      builder.limit(count.to_i)\n\n      ids = builder.query_single\n\n      if ids.length > 0\n        notifications +=\n          user\n            .notifications\n            .order(\"notifications.created_at DESC\")\n            .where(id: ids)\n            .joins(:topic)\n            .limit(count)\n      end\n\n      notifications\n        .uniq(&:id)\n        .sort do |x, y|\n          if x.unread_high_priority? && !y.unread_high_priority?\n            -1\n          elsif y.unread_high_priority? && !x.unread_high_priority?\n            1\n          else\n            y.created_at <=> x.created_at\n          end\n        end\n        .take(count)\n    else\n      []\n    end\n  end\n\n  def unread_high_priority?\n    self.high_priority? && !read\n  end\n\n  def post_id\n    Post.where(topic: topic_id, post_number: post_number).pick(:id)\n  end\n\n  protected\n\n  def refresh_notification_count\n    User.find_by(id: user_id)&.publish_notifications_state if user_id\n  end\n\n  def send_email\n    return if skip_send_email\n\n    if user.do_not_disturb?\n      ShelvedNotification.create(notification_id: self.id)\n    else\n      NotificationEmailer.process_notification(self)\n    end\n  end\nend\n\n# == Schema Information\n#\n# Table name: notifications\n#\n#  id                :integer          not null, primary key\n#  notification_type :integer          not null\n#  user_id           :integer          not null\n#  data              :string(1000)     not null\n#  read              :boolean          default(FALSE), not null\n#  created_at        :datetime         not null\n#  updated_at        :datetime         not null\n#  topic_id          :integer\n#  post_number       :integer\n#  post_action_id    :integer\n#  high_priority     :boolean          default(FALSE), not null\n#\n# Indexes\n#\n#  idx_notifications_speedup_unread_count                       (user_id,notification_type) WHERE (NOT read)\n#  index_notifications_on_post_action_id                        (post_action_id)\n#  index_notifications_on_topic_id_and_post_number              (topic_id,post_number)\n#  index_notifications_on_user_id_and_created_at                (user_id,created_at)\n#  index_notifications_on_user_id_and_topic_id_and_post_number  (user_id,topic_id,post_number)\n#  index_notifications_read_or_not_high_priority                (user_id,id DESC,read,topic_id) WHERE (read OR (high_priority = false))\n#  index_notifications_unique_unread_high_priority              (user_id,id) UNIQUE WHERE ((NOT read) AND (high_priority = true))\n#\n", "# frozen_string_literal: true\n\nclass PostBookmarkable < BaseBookmarkable\n  include TopicPostBookmarkableHelper\n\n  def self.model\n    Post\n  end\n\n  def self.serializer\n    UserPostBookmarkSerializer\n  end\n\n  def self.preload_associations\n    [{ topic: [:tags] }, :user]\n  end\n\n  def self.list_query(user, guardian)\n    topics = Topic.listable_topics.secured(guardian)\n    pms = Topic.private_messages_for_user(user)\n    post_bookmarks =\n      user\n        .bookmarks_of_type(\"Post\")\n        .joins(\n          \"INNER JOIN posts ON posts.id = bookmarks.bookmarkable_id AND bookmarks.bookmarkable_type = 'Post'\",\n        )\n        .joins(\"LEFT JOIN topics ON topics.id = posts.topic_id\")\n        .joins(\"LEFT JOIN topic_users ON topic_users.topic_id = topics.id\")\n        .where(\"topic_users.user_id = ?\", user.id)\n    guardian.filter_allowed_categories(\n      post_bookmarks.merge(topics.or(pms)).merge(Post.secured(guardian)),\n    )\n  end\n\n  def self.search_query(bookmarks, query, ts_query, &bookmarkable_search)\n    bookmarkable_search.call(\n      bookmarks.joins(\n        \"LEFT JOIN post_search_data ON post_search_data.post_id = bookmarks.bookmarkable_id AND bookmarks.bookmarkable_type = 'Post'\",\n      ),\n      \"#{ts_query} @@ post_search_data.search_data\",\n    )\n  end\n\n  def self.reminder_handler(bookmark)\n    send_reminder_notification(\n      bookmark,\n      topic_id: bookmark.bookmarkable.topic_id,\n      post_number: bookmark.bookmarkable.post_number,\n      data: {\n        title: bookmark.bookmarkable.topic.title,\n        bookmarkable_url: bookmark.bookmarkable.url,\n      },\n    )\n  end\n\n  def self.reminder_conditions(bookmark)\n    bookmark.bookmarkable.present? && bookmark.bookmarkable.topic.present?\n  end\n\n  def self.can_see?(guardian, bookmark)\n    guardian.can_see_post?(bookmark.bookmarkable)\n  end\n\n  def self.bookmark_metadata(bookmark, user)\n    {\n      topic_bookmarked: Bookmark.for_user_in_topic(user.id, bookmark.bookmarkable.topic_id).exists?,\n    }\n  end\n\n  def self.validate_before_create(guardian, bookmarkable)\n    if bookmarkable.blank? || bookmarkable.topic.blank? ||\n         !guardian.can_see_topic?(bookmarkable.topic) || !guardian.can_see_post?(bookmarkable)\n      raise Discourse::InvalidAccess\n    end\n  end\n\n  def self.after_create(guardian, bookmark, opts)\n    sync_topic_user_bookmarked(guardian.user, bookmark.bookmarkable.topic, opts)\n  end\n\n  def self.after_destroy(guardian, bookmark, opts)\n    sync_topic_user_bookmarked(guardian.user, bookmark.bookmarkable.topic, opts)\n  end\n\n  def self.cleanup_deleted\n    related_topics = DB.query(<<~SQL, grace_time: 3.days.ago)\n      DELETE FROM bookmarks b\n      USING topics t, posts p\n      WHERE t.id = p.topic_id AND b.bookmarkable_id = p.id AND b.bookmarkable_type = 'Post'\n      AND (t.deleted_at < :grace_time OR p.deleted_at < :grace_time)\n      RETURNING t.id AS topic_id\n    SQL\n\n    related_topics_ids = related_topics.map(&:topic_id).uniq\n    related_topics_ids.each do |topic_id|\n      Jobs.enqueue(:sync_topic_user_bookmarked, topic_id: topic_id)\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nclass TopicBookmarkable < BaseBookmarkable\n  include TopicPostBookmarkableHelper\n\n  def self.model\n    Topic\n  end\n\n  def self.serializer\n    UserTopicBookmarkSerializer\n  end\n\n  def self.preload_associations\n    [:tags, { first_post: :user }]\n  end\n\n  def self.perform_custom_preload!(topic_bookmarks, guardian)\n    topics = topic_bookmarks.map(&:bookmarkable)\n    topic_user_lookup = TopicUser.lookup_for(guardian.user, topics)\n\n    topics.each { |topic| topic.user_data = topic_user_lookup[topic.id] }\n  end\n\n  def self.list_query(user, guardian)\n    topics = Topic.listable_topics.secured(guardian)\n    pms = Topic.private_messages_for_user(user)\n    topic_bookmarks =\n      user\n        .bookmarks_of_type(\"Topic\")\n        .joins(\n          \"INNER JOIN topics ON topics.id = bookmarks.bookmarkable_id AND bookmarks.bookmarkable_type = 'Topic'\",\n        )\n        .joins(\"LEFT JOIN topic_users ON topic_users.topic_id = topics.id\")\n        .where(\"topic_users.user_id = ?\", user.id)\n    guardian.filter_allowed_categories(topic_bookmarks.merge(topics.or(pms)))\n  end\n\n  def self.search_query(bookmarks, query, ts_query, &bookmarkable_search)\n    bookmarkable_search.call(\n      bookmarks.joins(\n        \"LEFT JOIN posts ON posts.topic_id = topics.id AND posts.post_number = 1\",\n      ).joins(\"LEFT JOIN post_search_data ON post_search_data.post_id = posts.id\"),\n      \"#{ts_query} @@ post_search_data.search_data\",\n    )\n  end\n\n  def self.reminder_handler(bookmark)\n    send_reminder_notification(\n      bookmark,\n      topic_id: bookmark.bookmarkable_id,\n      post_number: 1,\n      data: {\n        title: bookmark.bookmarkable.title,\n        bookmarkable_url: bookmark.bookmarkable.first_post.url,\n      },\n    )\n  end\n\n  def self.reminder_conditions(bookmark)\n    bookmark.bookmarkable.present?\n  end\n\n  def self.can_see?(guardian, bookmark)\n    guardian.can_see_topic?(bookmark.bookmarkable)\n  end\n\n  def self.bookmark_metadata(bookmark, user)\n    { topic_bookmarked: Bookmark.for_user_in_topic(user.id, bookmark.bookmarkable.id).exists? }\n  end\n\n  def self.validate_before_create(guardian, bookmarkable)\n    raise Discourse::InvalidAccess if bookmarkable.blank? || !guardian.can_see_topic?(bookmarkable)\n  end\n\n  def self.after_create(guardian, bookmark, opts)\n    sync_topic_user_bookmarked(guardian.user, bookmark.bookmarkable, opts)\n  end\n\n  def self.after_destroy(guardian, bookmark, opts)\n    sync_topic_user_bookmarked(guardian.user, bookmark.bookmarkable, opts)\n  end\n\n  def self.cleanup_deleted\n    related_topics = DB.query(<<~SQL, grace_time: 3.days.ago)\n      DELETE FROM bookmarks b\n      USING topics t\n      WHERE b.bookmarkable_id = t.id AND b.bookmarkable_type = 'Topic'\n      AND (t.deleted_at < :grace_time)\n      RETURNING t.id AS topic_id\n    SQL\n\n    related_topics_ids = related_topics.map(&:topic_id).uniq\n    related_topics_ids.each do |topic_id|\n      Jobs.enqueue(:sync_topic_user_bookmarked, topic_id: topic_id)\n    end\n  end\nend\n", "# frozen_string_literal: true\n\n##\n# Allows us to query Bookmark records for lists. Used mainly\n# in the user/activity/bookmarks page.\n\nclass BookmarkQuery\n  def self.on_preload(&blk)\n    (@preload ||= Set.new) << blk\n  end\n\n  def self.preload(bookmarks, object)\n    preload_polymorphic_associations(bookmarks, object.guardian)\n    @preload.each { |preload| preload.call(bookmarks, object) } if @preload\n  end\n\n  # These polymorphic associations are loaded to make the UserBookmarkListSerializer's\n  # life easier, which conditionally chooses the bookmark serializer to use based\n  # on the type, and we want the associations all loaded ahead of time to make\n  # sure we are not doing N+1s.\n  def self.preload_polymorphic_associations(bookmarks, guardian)\n    Bookmark.registered_bookmarkables.each do |registered_bookmarkable|\n      registered_bookmarkable.perform_preload(bookmarks, guardian)\n    end\n  end\n\n  attr_reader :guardian, :count\n\n  def initialize(user:, guardian: nil, search_term: nil, page: nil, per_page: nil)\n    @user = user\n    @search_term = search_term\n    @guardian = guardian || Guardian.new(@user)\n    @page = page ? page.to_i : 0\n    @per_page = per_page ? per_page.to_i : 20\n    @count = 0\n  end\n\n  def list_all(&blk)\n    ts_query = @search_term.present? ? Search.ts_query(term: @search_term) : nil\n    search_term_wildcard = @search_term.present? ? \"%#{@search_term}%\" : nil\n\n    queries =\n      Bookmark\n        .registered_bookmarkables\n        .map do |bookmarkable|\n          interim_results = bookmarkable.perform_list_query(@user, @guardian)\n\n          # this could occur if there is some security reason that the user cannot\n          # access the bookmarkables that they have bookmarked, e.g. if they had 1 bookmark\n          # on a topic and that topic was moved into a private category\n          next if interim_results.blank?\n\n          if @search_term.present?\n            interim_results =\n              bookmarkable.perform_search_query(interim_results, search_term_wildcard, ts_query)\n          end\n\n          # this is purely to make the query easy to read and debug, otherwise it's\n          # all mashed up into a massive ball in MiniProfiler :)\n          \"---- #{bookmarkable.model.to_s} bookmarkable ---\\n\\n #{interim_results.to_sql}\"\n        end\n        .compact\n\n    # same for interim results being blank, the user might have been locked out\n    # from all their various bookmarks, in which case they will see nothing and\n    # no further pagination/ordering/etc is required\n    return [] if queries.empty?\n\n    union_sql = queries.join(\"\\n\\nUNION\\n\\n\")\n    results = Bookmark.select(\"bookmarks.*\").from(\"(\\n\\n#{union_sql}\\n\\n) as bookmarks\")\n    results =\n      results.order(\n        \"(CASE WHEN bookmarks.pinned THEN 0 ELSE 1 END),\n        bookmarks.reminder_at ASC,\n        bookmarks.updated_at DESC\",\n      )\n\n    @count = results.count\n\n    results = results.offset(@page * @per_page) if @page.positive?\n\n    if updated_results = blk&.call(results)\n      results = updated_results\n    end\n\n    results = results.limit(@per_page).to_a\n\n    BookmarkQuery.preload(results, self)\n    results\n  end\nend\n", "# frozen_string_literal: true\n\nmodule Chat\n  class MessageBookmarkable < BaseBookmarkable\n    def self.model\n      Chat::Message\n    end\n\n    def self.serializer\n      Chat::UserMessageBookmarkSerializer\n    end\n\n    def self.preload_associations\n      [:chat_channel]\n    end\n\n    def self.list_query(user, guardian)\n      accessible_channel_ids = Chat::ChannelFetcher.all_secured_channel_ids(guardian)\n      return if accessible_channel_ids.empty?\n\n      joins =\n        ActiveRecord::Base.public_send(\n          :sanitize_sql_array,\n          [\n            \"INNER JOIN chat_messages ON chat_messages.id = bookmarks.bookmarkable_id AND chat_messages.deleted_at IS NULL AND bookmarks.bookmarkable_type = ?\",\n            Chat::Message.polymorphic_name,\n          ],\n        )\n\n      user\n        .bookmarks_of_type(Chat::Message.polymorphic_name)\n        .joins(joins)\n        .where(\"chat_messages.chat_channel_id IN (?)\", accessible_channel_ids)\n    end\n\n    def self.search_query(bookmarks, query, ts_query, &bookmarkable_search)\n      bookmarkable_search.call(bookmarks, \"chat_messages.message ILIKE :q\")\n    end\n\n    def self.validate_before_create(guardian, bookmarkable)\n      if bookmarkable.blank? || !guardian.can_join_chat_channel?(bookmarkable.chat_channel)\n        raise Discourse::InvalidAccess\n      end\n    end\n\n    def self.reminder_handler(bookmark)\n      send_reminder_notification(\n        bookmark,\n        data: {\n          title:\n            I18n.t(\n              \"chat.bookmarkable.notification_title\",\n              channel_name: bookmark.bookmarkable.chat_channel.title(bookmark.user),\n            ),\n          bookmarkable_url: bookmark.bookmarkable.url,\n        },\n      )\n    end\n\n    def self.reminder_conditions(bookmark)\n      bookmark.bookmarkable.present? && bookmark.bookmarkable.chat_channel.present?\n    end\n\n    def self.can_see?(guardian, bookmark)\n      guardian.can_join_chat_channel?(bookmark.bookmarkable.chat_channel)\n    end\n\n    def self.cleanup_deleted\n      DB.query(<<~SQL, grace_time: 3.days.ago, bookmarkable_type: Chat::Message.polymorphic_name)\n      DELETE FROM bookmarks b\n      USING chat_messages cm\n      WHERE b.bookmarkable_id = cm.id\n      AND b.bookmarkable_type = :bookmarkable_type\n      AND (cm.deleted_at < :grace_time)\n    SQL\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\ndescribe Chat::MessageBookmarkable do\n  subject(:registered_bookmarkable) { RegisteredBookmarkable.new(described_class) }\n\n  fab!(:chatters) { Fabricate(:group) }\n  fab!(:user) { Fabricate(:user, group_ids: [chatters.id]) }\n  fab!(:guardian) { Guardian.new(user) }\n  fab!(:other_category) { Fabricate(:private_category, group: Fabricate(:group)) }\n  fab!(:category_channel) { Fabricate(:category_channel, chatable: other_category) }\n  fab!(:private_category) { Fabricate(:private_category, group: Fabricate(:group)) }\n  fab!(:channel) { Fabricate(:category_channel) }\n\n  before do\n    register_test_bookmarkable(described_class)\n    Chat::UserChatChannelMembership.create(chat_channel: channel, user: user, following: true)\n    SiteSetting.chat_allowed_groups = [chatters]\n  end\n\n  after { DiscoursePluginRegistry.reset_register!(:bookmarkables) }\n\n  let!(:message1) { Fabricate(:chat_message, chat_channel: channel) }\n  let!(:message2) { Fabricate(:chat_message, chat_channel: channel) }\n  let!(:bookmark1) do\n    Fabricate(:bookmark, user: user, bookmarkable: message1, name: \"something i gotta do\")\n  end\n  let!(:bookmark2) { Fabricate(:bookmark, user: user, bookmarkable: message2) }\n  let!(:bookmark3) { Fabricate(:bookmark) }\n\n  describe \"#perform_list_query\" do\n    it \"returns all the user's bookmarks\" do\n      expect(registered_bookmarkable.perform_list_query(user, guardian).map(&:id)).to match_array(\n        [bookmark1.id, bookmark2.id],\n      )\n    end\n\n    it \"does not return bookmarks for messages inside category chat channels the user cannot access\" do\n      channel.update(chatable: other_category)\n      expect(registered_bookmarkable.perform_list_query(user, guardian)).to eq(nil)\n      other_category.groups.last.add(user)\n      bookmark1.reload\n      user.reload\n      guardian = Guardian.new(user)\n      expect(registered_bookmarkable.perform_list_query(user, guardian).map(&:id)).to match_array(\n        [bookmark1.id, bookmark2.id],\n      )\n    end\n\n    it \"does not return bookmarks for messages inside direct message chat channels the user cannot access\" do\n      direct_message = Fabricate(:direct_message)\n      channel.update(chatable: direct_message)\n      expect(registered_bookmarkable.perform_list_query(user, guardian)).to eq(nil)\n      Chat::DirectMessageUser.create(user: user, direct_message: direct_message)\n      bookmark1.reload\n      user.reload\n      guardian = Guardian.new(user)\n      expect(registered_bookmarkable.perform_list_query(user, guardian).map(&:id)).to match_array(\n        [bookmark1.id, bookmark2.id],\n      )\n    end\n\n    it \"does not return bookmarks for deleted messages\" do\n      message1.trash!\n      guardian = Guardian.new(user)\n      expect(registered_bookmarkable.perform_list_query(user, guardian).map(&:id)).to match_array(\n        [bookmark2.id],\n      )\n    end\n  end\n\n  describe \"#perform_search_query\" do\n    before { SearchIndexer.enable }\n\n    it \"returns bookmarks that match by name\" do\n      ts_query = Search.ts_query(term: \"gotta\", ts_config: \"simple\")\n      expect(\n        registered_bookmarkable.perform_search_query(\n          registered_bookmarkable.perform_list_query(user, guardian),\n          \"%gotta%\",\n          ts_query,\n        ).map(&:id),\n      ).to match_array([bookmark1.id])\n    end\n\n    it \"returns bookmarks that match by chat message message content\" do\n      message2.update(message: \"some good soup\")\n\n      ts_query = Search.ts_query(term: \"good soup\", ts_config: \"simple\")\n      expect(\n        registered_bookmarkable.perform_search_query(\n          registered_bookmarkable.perform_list_query(user, guardian),\n          \"%good soup%\",\n          ts_query,\n        ).map(&:id),\n      ).to match_array([bookmark2.id])\n\n      ts_query = Search.ts_query(term: \"blah\", ts_config: \"simple\")\n      expect(\n        registered_bookmarkable.perform_search_query(\n          registered_bookmarkable.perform_list_query(user, guardian),\n          \"%blah%\",\n          ts_query,\n        ).map(&:id),\n      ).to eq([])\n    end\n  end\n\n  describe \"#can_send_reminder?\" do\n    it \"cannot send the reminder if the message or channel is deleted\" do\n      expect(registered_bookmarkable.can_send_reminder?(bookmark1)).to eq(true)\n      bookmark1.bookmarkable.trash!\n      bookmark1.reload\n      expect(registered_bookmarkable.can_send_reminder?(bookmark1)).to eq(false)\n      Chat::Message.with_deleted.find_by(id: bookmark1.bookmarkable_id).recover!\n      bookmark1.reload\n      bookmark1.bookmarkable.chat_channel.trash!\n      bookmark1.reload\n      expect(registered_bookmarkable.can_send_reminder?(bookmark1)).to eq(false)\n    end\n  end\n\n  describe \"#reminder_handler\" do\n    it \"creates a notification for the user with the correct details\" do\n      expect { registered_bookmarkable.send_reminder_notification(bookmark1) }.to change {\n        Notification.count\n      }.by(1)\n      notification = user.notifications.last\n      expect(notification.notification_type).to eq(Notification.types[:bookmark_reminder])\n      expect(notification.data).to eq(\n        {\n          title:\n            I18n.t(\n              \"chat.bookmarkable.notification_title\",\n              channel_name: bookmark1.bookmarkable.chat_channel.title(bookmark1.user),\n            ),\n          bookmarkable_url: bookmark1.bookmarkable.url,\n          display_username: bookmark1.user.username,\n          bookmark_name: bookmark1.name,\n          bookmark_id: bookmark1.id,\n        }.to_json,\n      )\n    end\n  end\n\n  describe \"#can_see?\" do\n    it \"returns false if the chat message is in a channel the user cannot see\" do\n      expect(registered_bookmarkable.can_see?(guardian, bookmark1)).to eq(true)\n      bookmark1.bookmarkable.chat_channel.update!(chatable: private_category)\n      expect(registered_bookmarkable.can_see?(guardian, bookmark1)).to eq(false)\n      private_category.groups.last.add(user)\n      bookmark1.reload\n      user.reload\n      guardian = Guardian.new(user)\n      expect(registered_bookmarkable.can_see?(guardian, bookmark1)).to eq(true)\n    end\n  end\n\n  describe \"#validate_before_create\" do\n    it \"raises InvalidAccess if the user cannot see the chat channel\" do\n      expect {\n        registered_bookmarkable.validate_before_create(guardian, bookmark1.bookmarkable)\n      }.not_to raise_error\n      bookmark1.bookmarkable.chat_channel.update!(chatable: private_category)\n      expect {\n        registered_bookmarkable.validate_before_create(guardian, bookmark1.bookmarkable)\n      }.to raise_error(Discourse::InvalidAccess)\n      private_category.groups.last.add(user)\n      bookmark1.reload\n      user.reload\n      guardian = Guardian.new(user)\n      expect {\n        registered_bookmarkable.validate_before_create(guardian, bookmark1.bookmarkable)\n      }.not_to raise_error\n    end\n\n    it \"raises InvalidAccess if the chat message is deleted\" do\n      expect {\n        registered_bookmarkable.validate_before_create(guardian, bookmark1.bookmarkable)\n      }.not_to raise_error\n      bookmark1.bookmarkable.trash!\n      bookmark1.reload\n      expect {\n        registered_bookmarkable.validate_before_create(guardian, bookmark1.bookmarkable)\n      }.to raise_error(Discourse::InvalidAccess)\n    end\n  end\n\n  describe \"#cleanup_deleted\" do\n    it \"deletes bookmarks for chat messages deleted more than 3 days ago\" do\n      bookmark_post = Fabricate(:bookmark, bookmarkable: Fabricate(:post))\n      bookmark1.bookmarkable.trash!\n      bookmark1.bookmarkable.update!(deleted_at: 4.days.ago)\n      registered_bookmarkable.cleanup_deleted\n      expect(Bookmark.exists?(id: bookmark1.id)).to eq(false)\n      expect(Bookmark.exists?(id: bookmark2.id)).to eq(true)\n      expect(Bookmark.exists?(id: bookmark_post.id)).to eq(true)\n    end\n  end\nend\n", "# frozen_string_literal: true\n\ndescribe UsersController do\n  describe \"#perform_account_activation\" do\n    let!(:channel) { Fabricate(:category_channel, auto_join_users: true) }\n\n    before do\n      Jobs.run_immediately!\n      UsersController.any_instance.stubs(:honeypot_or_challenge_fails?).returns(false)\n      SiteSetting.send_welcome_message = false\n      SiteSetting.chat_enabled = true\n    end\n\n    it \"triggers the auto-join process\" do\n      user = Fabricate(:user, last_seen_at: 1.minute.ago, active: false)\n      email_token = Fabricate(:email_token, user: user)\n\n      put \"/u/activate-account/#{email_token.token}\"\n\n      expect(response.status).to eq(200)\n      membership = Chat::UserChatChannelMembership.find_by(user: user, chat_channel: channel)\n      expect(membership.following).to eq(true)\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nRSpec.describe BookmarkQuery do\n  before { SearchIndexer.enable }\n\n  fab!(:user) { Fabricate(:user) }\n\n  def bookmark_query(user: nil, search_term: nil, per_page: nil)\n    BookmarkQuery.new(user: user || self.user, search_term:, per_page:)\n  end\n\n  describe \"#list_all\" do\n    before do\n      register_test_bookmarkable\n\n      Fabricate(:topic_user, user: user, topic: post_bookmark.bookmarkable.topic)\n      Fabricate(:topic_user, user: user, topic: topic_bookmark.bookmarkable)\n      user_bookmark\n    end\n\n    after { DiscoursePluginRegistry.reset! }\n\n    let(:post_bookmark) { Fabricate(:bookmark, user: user, bookmarkable: Fabricate(:post)) }\n    let(:topic_bookmark) { Fabricate(:bookmark, user: user, bookmarkable: Fabricate(:topic)) }\n    let(:user_bookmark) do\n      Fabricate(:bookmark, user: user, bookmarkable: Fabricate(:user, username: \"bookmarkqueen\"))\n    end\n\n    it \"returns all the bookmarks for a user\" do\n      expect(bookmark_query.list_all.count).to eq(3)\n    end\n\n    it \"does not return deleted bookmarkables\" do\n      post_bookmark.bookmarkable.trash!\n      topic_bookmark.bookmarkable.trash!\n      expect(bookmark_query.list_all.count).to eq(1)\n    end\n\n    it \"runs the on_preload block provided passing in bookmarks\" do\n      preloaded_bookmarks = []\n      BookmarkQuery.on_preload { |bookmarks, bq| (preloaded_bookmarks << bookmarks).flatten }\n      bookmark_query.list_all\n      expect(preloaded_bookmarks.any?).to eq(true)\n    end\n\n    it \"returns a mixture of post, topic, and custom bookmarkable type bookmarks\" do\n      bookmarks = bookmark_query.list_all\n      expect(bookmarks.map(&:id)).to match_array(\n        [post_bookmark.id, topic_bookmark.id, user_bookmark.id],\n      )\n    end\n\n    it \"handles the user not having permission for all of the bookmarks of a certain bookmarkable\" do\n      UserTestBookmarkable.expects(:list_query).returns(nil)\n      bookmarks = bookmark_query.list_all\n      expect(bookmarks.map(&:id)).to match_array([post_bookmark.id, topic_bookmark.id])\n    end\n\n    it \"handles the user not having permission to see any of their bookmarks\" do\n      topic_bookmark.bookmarkable.update(\n        category: Fabricate(:private_category, group: Fabricate(:group)),\n      )\n      post_bookmark.bookmarkable.topic.update(category: topic_bookmark.bookmarkable.category)\n      UserTestBookmarkable.expects(:list_query).returns(nil)\n      bookmarks = bookmark_query.list_all\n      expect(bookmarks.map(&:id)).to eq([])\n    end\n\n    context \"when search_term is provided\" do\n      let!(:post) do\n        Fabricate(\n          :post,\n          raw: \"Some post content here\",\n          topic: Fabricate(:topic, title: \"Bugfix game for devs\"),\n        )\n      end\n\n      after { DiscoursePluginRegistry.reset! }\n\n      let(:bookmark3) do\n        Fabricate(:bookmark, user: user, name: \"Check up later\", bookmarkable: Fabricate(:post))\n      end\n      let(:bookmark4) { Fabricate(:bookmark, user: user, bookmarkable: post) }\n\n      before do\n        Fabricate(:topic_user, user: user, topic: bookmark3.bookmarkable.topic)\n        Fabricate(:topic_user, user: user, topic: bookmark4.bookmarkable.topic)\n      end\n\n      it \"can search by bookmark name\" do\n        bookmarks = bookmark_query(search_term: \"check\").list_all\n        expect(bookmarks.map(&:id)).to eq([bookmark3.id])\n      end\n\n      it \"can search by post content\" do\n        bookmarks = bookmark_query(search_term: \"content\").list_all\n        expect(bookmarks.map(&:id)).to eq([bookmark4.id])\n      end\n\n      it \"can search by topic title\" do\n        bookmarks = bookmark_query(search_term: \"bugfix\").list_all\n        expect(bookmarks.map(&:id)).to eq([bookmark4.id])\n      end\n\n      context \"with custom bookmarkable fitering\" do\n        before { register_test_bookmarkable }\n\n        let!(:bookmark5) do\n          Fabricate(:bookmark, user: user, bookmarkable: Fabricate(:user, username: \"bookmarkking\"))\n        end\n\n        it \"allows searching bookmarkables by fields in other tables\" do\n          bookmarks = bookmark_query(search_term: \"bookmarkk\").list_all\n          expect(bookmarks.map(&:id)).to eq([bookmark5.id])\n        end\n      end\n    end\n\n    context \"for a whispered post\" do\n      before do\n        post_bookmark.bookmarkable.update(post_type: Post.types[:whisper])\n        SiteSetting.whispers_allowed_groups = \"#{Group::AUTO_GROUPS[:staff]}\"\n      end\n      fab!(:whisperers_group) { Fabricate(:group) }\n\n      context \"when the user is moderator\" do\n        it \"does return the whispered post\" do\n          user.grant_moderation!\n          expect(bookmark_query.list_all.count).to eq(3)\n        end\n      end\n      context \"when the user is admin\" do\n        it \"does return the whispered post\" do\n          user.grant_admin!\n          expect(bookmark_query.list_all.count).to eq(3)\n        end\n      end\n      context \"when the user is a member of whisperers group\" do\n        it \"returns the whispered post\" do\n          SiteSetting.whispers_allowed_groups = \"#{whisperers_group.id}\"\n          user.update!(groups: [whisperers_group])\n          expect(bookmark_query.list_all.count).to eq(3)\n        end\n      end\n      context \"when the user is not staff\" do\n        it \"does not return the whispered post\" do\n          expect(bookmark_query.list_all.count).to eq(2)\n        end\n      end\n    end\n\n    context \"for a private message topic bookmark\" do\n      let(:pm_topic) { Fabricate(:private_message_topic) }\n      before do\n        post_bookmark.update(bookmarkable: Fabricate(:post, topic: pm_topic))\n        TopicUser.change(user.id, pm_topic.id, total_msecs_viewed: 1)\n      end\n\n      context \"when the user is a topic_allowed_user\" do\n        before { TopicAllowedUser.create(topic: pm_topic, user: user) }\n        it \"shows the user the bookmark in the PM\" do\n          expect(bookmark_query.list_all.map(&:id).count).to eq(3)\n        end\n      end\n\n      context \"when the user is in a topic_allowed_group\" do\n        before do\n          group = Fabricate(:group)\n          GroupUser.create(group: group, user: user)\n          TopicAllowedGroup.create(topic: pm_topic, group: group)\n        end\n        it \"shows the user the bookmark in the PM\" do\n          expect(bookmark_query.list_all.map(&:id).count).to eq(3)\n        end\n      end\n\n      context \"when the user is not a topic_allowed_user\" do\n        it \"does not show the user a bookmarked post in a PM where they are not an allowed user\" do\n          expect(bookmark_query.list_all.map(&:id).count).to eq(2)\n        end\n      end\n\n      context \"when the user is not in a topic_allowed_group\" do\n        it \"does not show the user a bookmarked post in a PM where they are not in an allowed group\" do\n          expect(bookmark_query.list_all.map(&:id).count).to eq(2)\n        end\n      end\n    end\n\n    context \"when the topic category is private\" do\n      let(:group) { Fabricate(:group) }\n      before do\n        post_bookmark.bookmarkable.topic.update(\n          category: Fabricate(:private_category, group: group),\n        )\n        post_bookmark.reload\n      end\n      it \"does not show the user a post/topic in a private category they cannot see\" do\n        expect(bookmark_query.list_all.map(&:id)).not_to include(post_bookmark.id)\n      end\n      it \"does show the user a post/topic in a private category they can see\" do\n        GroupUser.create(user: user, group: group)\n        expect(bookmark_query.list_all.map(&:id)).to include(post_bookmark.id)\n      end\n    end\n\n    context \"when the per_page is provided\" do\n      it \"is respected\" do\n        expect(bookmark_query(per_page: 1).list_all.count).to eq(1)\n      end\n    end\n  end\n\n  describe \"#list_all ordering\" do\n    let!(:bookmark1) { Fabricate(:bookmark, user: user, updated_at: 1.day.ago, reminder_at: nil) }\n    let!(:bookmark2) { Fabricate(:bookmark, user: user, updated_at: 2.days.ago, reminder_at: nil) }\n    let!(:bookmark3) { Fabricate(:bookmark, user: user, updated_at: 6.days.ago, reminder_at: nil) }\n    let!(:bookmark4) { Fabricate(:bookmark, user: user, updated_at: 4.days.ago, reminder_at: nil) }\n    let!(:bookmark5) { Fabricate(:bookmark, user: user, updated_at: 3.days.ago, reminder_at: nil) }\n\n    before do\n      [bookmark1, bookmark2, bookmark3, bookmark4, bookmark5].each do |bm|\n        Fabricate(:topic_user, topic: bm.bookmarkable.topic, user: user)\n        bm.reload\n      end\n    end\n\n    it \"order defaults to updated_at DESC\" do\n      expect(bookmark_query.list_all.map(&:id)).to eq(\n        [bookmark1.id, bookmark2.id, bookmark5.id, bookmark4.id, bookmark3.id],\n      )\n    end\n\n    it \"orders by reminder_at, then updated_at\" do\n      bookmark4.update_column(:reminder_at, 1.day.from_now)\n      bookmark5.update_column(:reminder_at, 26.hours.from_now)\n\n      expect(bookmark_query.list_all.map(&:id)).to eq(\n        [bookmark4.id, bookmark5.id, bookmark1.id, bookmark2.id, bookmark3.id],\n      )\n    end\n\n    it \"shows pinned bookmarks first ordered by reminder_at ASC then updated_at DESC\" do\n      bookmark3.update_column(:pinned, true)\n      bookmark3.update_column(:reminder_at, 1.day.from_now)\n\n      bookmark4.update_column(:pinned, true)\n      bookmark4.update_column(:reminder_at, 28.hours.from_now)\n\n      bookmark1.update_column(:pinned, true)\n      bookmark2.update_column(:pinned, true)\n\n      bookmark5.update_column(:reminder_at, 1.day.from_now)\n\n      expect(bookmark_query.list_all.map(&:id)).to eq(\n        [bookmark3.id, bookmark4.id, bookmark1.id, bookmark2.id, bookmark5.id],\n      )\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rotp\"\n\nRSpec.describe UsersController do\n  fab!(:user) { Fabricate(:user) }\n  fab!(:user1) { Fabricate(:user, username: \"someusername\") }\n  fab!(:another_user) { Fabricate(:user) }\n  fab!(:invitee) { Fabricate(:user) }\n  fab!(:inviter) { Fabricate(:user) }\n\n  fab!(:admin) { Fabricate(:admin) }\n  fab!(:moderator) { Fabricate(:moderator) }\n  fab!(:inactive_user) { Fabricate(:inactive_user) }\n\n  before { Group.refresh_automatic_groups! }\n\n  # Unfortunately, there are tests that depend on the user being created too\n  # late for fab! to work.\n  let(:user_deferred) { Fabricate(:user) }\n\n  describe \"#full account registration flow\" do\n    it \"will correctly handle honeypot and challenge\" do\n      get \"/session/hp.json\"\n      expect(response.status).to eq(200)\n\n      json = response.parsed_body\n\n      params = {\n        email: \"jane@jane.com\",\n        name: \"jane\",\n        username: \"jane\",\n        password_confirmation: json[\"value\"],\n        challenge: json[\"challenge\"].reverse,\n        password: SecureRandom.hex,\n      }\n\n      secure_session = SecureSession.new(session[\"secure_session_id\"])\n\n      expect(secure_session[UsersController::HONEYPOT_KEY]).to eq(json[\"value\"])\n      expect(secure_session[UsersController::CHALLENGE_KEY]).to eq(json[\"challenge\"])\n\n      post \"/u.json\", params: params\n\n      expect(response.status).to eq(200)\n\n      jane = User.find_by(username: \"jane\")\n\n      expect(jane.email).to eq(\"jane@jane.com\")\n\n      expect(secure_session[UsersController::HONEYPOT_KEY]).to eq(nil)\n      expect(secure_session[UsersController::CHALLENGE_KEY]).to eq(nil)\n    end\n  end\n\n  describe \"#perform_account_activation\" do\n    let(:email_token) { Fabricate(:email_token, user: user_deferred) }\n\n    before { UsersController.any_instance.stubs(:honeypot_or_challenge_fails?).returns(false) }\n\n    context \"with invalid token\" do\n      it \"return success\" do\n        put \"/u/activate-account/invalid-tooken\"\n        expect(response.status).to eq(200)\n        expect(flash[:error]).to be_present\n      end\n    end\n\n    context \"with valid token\" do\n      context \"with welcome message\" do\n        it \"enqueues a welcome message if the user object indicates so\" do\n          SiteSetting.send_welcome_message = true\n          user_deferred.update(active: false)\n          put \"/u/activate-account/#{email_token.token}\"\n          expect(response.status).to eq(200)\n          expect(Jobs::SendSystemMessage.jobs.size).to eq(1)\n          expect(Jobs::SendSystemMessage.jobs.first[\"args\"].first[\"message_type\"]).to eq(\n            \"welcome_user\",\n          )\n        end\n\n        it \"doesn't enqueue the welcome message if the object returns false\" do\n          user_deferred.update(active: true)\n          put \"/u/activate-account/#{email_token.token}\"\n          expect(response.status).to eq(200)\n          expect(Jobs::SendSystemMessage.jobs.size).to eq(0)\n        end\n      end\n\n      context \"with honeypot\" do\n        it \"raises an error if the honeypot is invalid\" do\n          UsersController.any_instance.stubs(:honeypot_or_challenge_fails?).returns(true)\n          put \"/u/activate-account/#{email_token.token}\"\n          expect(response.status).to eq(403)\n        end\n      end\n\n      context \"with response\" do\n        it \"correctly logs on user\" do\n          email_token\n\n          events = DiscourseEvent.track_events { put \"/u/activate-account/#{email_token.token}\" }\n\n          expect(events.map { |event| event[:event_name] }).to contain_exactly(\n            :user_confirmed_email,\n            :user_first_logged_in,\n            :user_logged_in,\n          )\n\n          expect(response.status).to eq(200)\n          expect(flash[:error]).to be_blank\n          expect(session[:current_user_id]).to be_present\n\n          expect(CGI.unescapeHTML(response.body)).to_not include(\n            I18n.t(\"activation.approval_required\"),\n          )\n        end\n      end\n\n      context \"when user is not approved\" do\n        before { SiteSetting.must_approve_users = true }\n\n        it \"should return the right response\" do\n          put \"/u/activate-account/#{email_token.token}\"\n          expect(response.status).to eq(200)\n\n          expect(CGI.unescapeHTML(response.body)).to include(I18n.t(\"activation.approval_required\"))\n\n          expect(response.body).to_not have_tag(:script, with: { src: \"/assets/application.js\" })\n\n          expect(flash[:error]).to be_blank\n          expect(session[:current_user_id]).to be_blank\n        end\n      end\n    end\n\n    context \"when cookies contains a destination URL\" do\n      it \"should redirect to the URL\" do\n        destination_url = \"http://thisisasite.com/somepath\"\n        cookies[:destination_url] = destination_url\n\n        put \"/u/activate-account/#{email_token.token}\"\n\n        expect(response).to redirect_to(destination_url)\n      end\n    end\n\n    context \"when cookies does not contain a destination URL but users was invited to topic\" do\n      let(:invite) { Fabricate(:invite) }\n      let(:topic) { Fabricate(:topic) }\n\n      before do\n        TopicInvite.create!(topic: topic, invite: invite)\n        Fabricate(:invited_user, invite: invite, user: email_token.user)\n        invite.reload\n      end\n\n      it \"should redirect to the topic\" do\n        put \"/u/activate-account/#{email_token.token}\"\n\n        expect(response).to redirect_to(topic.relative_url)\n      end\n    end\n  end\n\n  describe \"#password_reset\" do\n    let(:token) { SecureRandom.hex }\n\n    context \"when login is required\" do\n      it \"returns success\" do\n        SiteSetting.login_required = true\n        get \"/u/password-reset/#{token}\"\n        expect(response.status).to eq(200)\n        expect(CGI.unescapeHTML(response.body)).to include(\n          I18n.t(\"password_reset.no_token\", base_url: Discourse.base_url),\n        )\n      end\n    end\n\n    context \"with missing token\" do\n      it \"disallows login\" do\n        get \"/u/password-reset/#{token}\"\n\n        expect(response.status).to eq(200)\n\n        expect(CGI.unescapeHTML(response.body)).to include(\n          I18n.t(\"password_reset.no_token\", base_url: Discourse.base_url),\n        )\n\n        expect(response.body).to_not have_tag(:script, with: { src: \"/assets/application.js\" })\n\n        expect(session[:current_user_id]).to be_blank\n      end\n\n      it \"responds with proper error message\" do\n        get \"/u/password-reset/#{token}.json\"\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"message\"]).to eq(\n          I18n.t(\"password_reset.no_token\", base_url: Discourse.base_url),\n        )\n        expect(session[:current_user_id]).to be_blank\n      end\n    end\n\n    context \"with invalid token\" do\n      it \"disallows login\" do\n        get \"/u/password-reset/ev!l_trout@!\"\n\n        expect(response.status).to eq(200)\n\n        expect(CGI.unescapeHTML(response.body)).to include(\n          I18n.t(\"password_reset.no_token\", base_url: Discourse.base_url),\n        )\n\n        expect(response.body).to_not have_tag(:script, with: { src: \"/assets/application.js\" })\n\n        expect(session[:current_user_id]).to be_blank\n      end\n\n      it \"responds with proper error message\" do\n        put \"/u/password-reset/evil_trout!.json\", params: { password: \"awesomeSecretPassword\" }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"message\"]).to eq(\n          I18n.t(\"password_reset.no_token\", base_url: Discourse.base_url),\n        )\n        expect(session[:current_user_id]).to be_blank\n      end\n    end\n\n    context \"with valid token\" do\n      let!(:user_auth_token) { UserAuthToken.generate!(user_id: user1.id) }\n      let!(:email_token) do\n        Fabricate(:email_token, user: user1, scope: EmailToken.scopes[:password_reset])\n      end\n\n      context \"when rendered\" do\n        it \"renders referrer never on get requests\" do\n          get \"/u/password-reset/#{email_token.token}\"\n          expect(response.status).to eq(200)\n          expect(response.body).to include('<meta name=\"referrer\" content=\"never\">')\n        end\n      end\n\n      it \"returns success\" do\n        events =\n          DiscourseEvent.track_events do\n            put \"/u/password-reset/#{email_token.token}\", params: { password: \"hg9ow8yhg98o\" }\n          end\n\n        expect(events.map { |event| event[:event_name] }).to contain_exactly(\n          :user_logged_in,\n          :user_first_logged_in,\n          :user_confirmed_email,\n        )\n\n        expect(response.status).to eq(200)\n        expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n          json = JSON.parse(element.current_scope.attribute(\"data-preloaded\").value)\n          expect(json[\"password_reset\"]).to include(\n            '{\"is_developer\":false,\"admin\":false,\"second_factor_required\":false,\"security_key_required\":false,\"backup_enabled\":false,\"multiple_second_factor_methods\":false}',\n          )\n        end\n\n        expect(session[\"password-#{email_token.token}\"]).to be_blank\n        expect(UserAuthToken.where(id: user_auth_token.id).count).to eq(0)\n      end\n\n      it \"disallows double password reset\" do\n        put \"/u/password-reset/#{email_token.token}\", params: { password: \"hg9ow8yHG32O\" }\n        put \"/u/password-reset/#{email_token.token}\", params: { password: \"test123987AsdfXYZ\" }\n        expect(user1.reload.confirm_password?(\"hg9ow8yHG32O\")).to eq(true)\n        expect(user1.user_auth_tokens.count).to eq(1)\n      end\n\n      it \"doesn't redirect to wizard on get\" do\n        user1.update!(admin: true)\n\n        get \"/u/password-reset/#{email_token.token}.json\"\n        expect(response).not_to redirect_to(wizard_path)\n      end\n\n      it \"redirects to the wizard if you're the first admin\" do\n        user1.update!(admin: true)\n\n        get \"/u/password-reset/#{email_token.token}\"\n        put \"/u/password-reset/#{email_token.token}\",\n            params: {\n              password: \"hg9ow8yhg98oadminlonger\",\n            }\n        expect(response).to redirect_to(wizard_path)\n      end\n\n      it \"sets the users timezone if the param is present\" do\n        get \"/u/password-reset/#{email_token.token}\"\n        expect(user1.user_option.timezone).to eq(nil)\n\n        put \"/u/password-reset/#{email_token.token}\",\n            params: {\n              password: \"hg9ow8yhg98oadminlonger\",\n              timezone: \"America/Chicago\",\n            }\n        expect(user1.user_option.reload.timezone).to eq(\"America/Chicago\")\n      end\n\n      it \"logs the password change\" do\n        get \"/u/password-reset/#{email_token.token}\"\n\n        expect do\n          put \"/u/password-reset/#{email_token.token}\",\n              params: {\n                password: \"hg9ow8yhg98oadminlonger\",\n              }\n        end.to change { UserHistory.count }.by (1)\n\n        user_history = UserHistory.last\n        expect(user_history.target_user_id).to eq(user1.id)\n        expect(user_history.action).to eq(UserHistory.actions[:change_password])\n      end\n\n      it \"doesn't invalidate the token when loading the page\" do\n        get \"/u/password-reset/#{email_token.token}.json\"\n        expect(response.status).to eq(200)\n        expect(email_token.reload.confirmed).to eq(false)\n        expect(UserAuthToken.where(id: user_auth_token.id).count).to eq(1)\n      end\n\n      context \"with rate limiting\" do\n        before { RateLimiter.enable }\n\n        use_redis_snapshotting\n\n        it \"rate limits reset passwords\" do\n          freeze_time\n\n          6.times do\n            put \"/u/password-reset/#{email_token.token}\",\n                params: {\n                  second_factor_token: 123_456,\n                  second_factor_method: 1,\n                }\n\n            expect(response.status).to eq(200)\n          end\n\n          put \"/u/password-reset/#{email_token.token}\",\n              params: {\n                second_factor_token: 123_456,\n                second_factor_method: 1,\n              }\n\n          expect(response.status).to eq(429)\n        end\n\n        it \"rate limits reset passwords by username\" do\n          freeze_time\n\n          6.times do |x|\n            put \"/u/password-reset/#{email_token.token}\",\n                params: {\n                  second_factor_token: 123_456,\n                  second_factor_method: 1,\n                },\n                env: {\n                  REMOTE_ADDR: \"1.2.3.#{x}\",\n                }\n\n            expect(response.status).to eq(200)\n          end\n\n          put \"/u/password-reset/#{email_token.token}\",\n              params: {\n                second_factor_token: 123_456,\n                second_factor_method: 1,\n              },\n              env: {\n                REMOTE_ADDR: \"1.2.3.4\",\n              }\n\n          expect(response.status).to eq(429)\n        end\n      end\n\n      context \"when 2 factor authentication is required\" do\n        fab!(:second_factor) { Fabricate(:user_second_factor_totp, user: user1) }\n\n        it \"does not change with an invalid token\" do\n          user1.user_auth_tokens.destroy_all\n\n          get \"/u/password-reset/#{email_token.token}\"\n\n          expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n            json = JSON.parse(element.current_scope.attribute(\"data-preloaded\").value)\n            expect(json[\"password_reset\"]).to include(\n              '{\"is_developer\":false,\"admin\":false,\"second_factor_required\":true,\"security_key_required\":false,\"backup_enabled\":false,\"multiple_second_factor_methods\":false}',\n            )\n          end\n\n          put \"/u/password-reset/#{email_token.token}\",\n              params: {\n                password: \"hg9ow8yHG32O\",\n                second_factor_token: \"000000\",\n                second_factor_method: UserSecondFactor.methods[:totp],\n              }\n\n          expect(response.body).to include(I18n.t(\"login.invalid_second_factor_code\"))\n\n          user1.reload\n          expect(user1.confirm_password?(\"hg9ow8yHG32O\")).not_to eq(true)\n          expect(user1.user_auth_tokens.count).not_to eq(1)\n        end\n\n        it \"changes password with valid 2-factor tokens\" do\n          get \"/u/password-reset/#{email_token.token}\"\n\n          put \"/u/password-reset/#{email_token.token}\",\n              params: {\n                password: \"hg9ow8yHG32O\",\n                second_factor_token: ROTP::TOTP.new(second_factor.data).now,\n                second_factor_method: UserSecondFactor.methods[:totp],\n              }\n\n          user1.reload\n          expect(response.status).to eq(200)\n          expect(user1.confirm_password?(\"hg9ow8yHG32O\")).to eq(true)\n          expect(user1.user_auth_tokens.count).to eq(1)\n        end\n      end\n\n      context \"when security key authentication is required\" do\n        let!(:user_security_key) do\n          Fabricate(\n            :user_security_key,\n            user: user1,\n            credential_id: valid_security_key_data[:credential_id],\n            public_key: valid_security_key_data[:public_key],\n          )\n        end\n\n        before do\n          simulate_localhost_webauthn_challenge\n\n          # store challenge in secure session by visiting the email login page\n          get \"/u/password-reset/#{email_token.token}\"\n        end\n\n        it \"preloads with a security key challenge and allowed credential ids\" do\n          expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n            json = JSON.parse(element.current_scope.attribute(\"data-preloaded\").value)\n            password_reset = JSON.parse(json[\"password_reset\"])\n            expect(password_reset[\"challenge\"]).not_to eq(nil)\n            expect(password_reset[\"allowed_credential_ids\"]).to eq(\n              [user_security_key.credential_id],\n            )\n            expect(password_reset[\"security_key_required\"]).to eq(true)\n          end\n        end\n\n        it \"stages a webauthn challenge and rp-id for the user\" do\n          secure_session = SecureSession.new(session[\"secure_session_id\"])\n          expect(Webauthn.challenge(user1, secure_session)).not_to eq(nil)\n          expect(Webauthn.rp_id(user1, secure_session)).to eq(Discourse.current_hostname)\n        end\n\n        it \"changes password with valid security key challenge and authentication\" do\n          put \"/u/password-reset/#{email_token.token}.json\",\n              params: {\n                password: \"hg9ow8yHG32O\",\n                second_factor_token: valid_security_key_auth_post_data,\n                second_factor_method: UserSecondFactor.methods[:security_key],\n              }\n\n          expect(response.status).to eq(200)\n          user1.reload\n          expect(user1.confirm_password?(\"hg9ow8yHG32O\")).to eq(true)\n          expect(user1.user_auth_tokens.count).to eq(1)\n        end\n\n        it \"does not change a password if a fake TOTP token is provided\" do\n          put \"/u/password-reset/#{email_token.token}.json\",\n              params: {\n                password: \"hg9ow8yHG32O\",\n                second_factor_token: \"blah\",\n                second_factor_method: UserSecondFactor.methods[:security_key],\n              }\n\n          expect(response.status).to eq(200)\n          expect(user1.reload.confirm_password?(\"hg9ow8yHG32O\")).to eq(false)\n        end\n\n        context \"when security key authentication fails\" do\n          it \"shows an error message and does not change password\" do\n            put \"/u/password-reset/#{email_token.token}\",\n                params: {\n                  password: \"hg9ow8yHG32O\",\n                  second_factor_token: {\n                    signature: \"bad\",\n                    clientData: \"bad\",\n                    authenticatorData: \"bad\",\n                    credentialId: \"bad\",\n                  },\n                  second_factor_method: UserSecondFactor.methods[:security_key],\n                }\n\n            expect(response.status).to eq(200)\n            expect(response.body).to include(I18n.t(\"webauthn.validation.not_found_error\"))\n            expect(user1.reload.confirm_password?(\"hg9ow8yHG32O\")).to eq(false)\n          end\n        end\n      end\n    end\n\n    context \"with submit change\" do\n      let(:email_token) do\n        Fabricate(:email_token, user: user1, scope: EmailToken.scopes[:password_reset])\n      end\n\n      it \"fails when the password is blank\" do\n        put \"/u/password-reset/#{email_token.token}.json\", params: { password: \"\" }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"errors\"]).to be_present\n        expect(session[:current_user_id]).to be_blank\n      end\n\n      it \"fails when the password is too long\" do\n        put \"/u/password-reset/#{email_token.token}.json\",\n            params: {\n              password: (\"x\" * (User.max_password_length + 1)),\n            }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"errors\"]).to be_present\n        expect(session[:current_user_id]).to be_blank\n      end\n\n      it \"logs in the user\" do\n        put \"/u/password-reset/#{email_token.token}.json\", params: { password: \"ksjafh928r\" }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"errors\"]).to be_blank\n        expect(session[:current_user_id]).to be_present\n      end\n\n      it \"doesn't log in the user when not approved\" do\n        SiteSetting.must_approve_users = true\n        user1.update!(approved: false)\n\n        put \"/u/password-reset/#{email_token.token}.json\", params: { password: \"ksjafh928r\" }\n        expect(response.parsed_body[\"errors\"]).to be_blank\n        expect(session[:current_user_id]).to be_blank\n      end\n    end\n  end\n\n  describe \"#confirm_email_token\" do\n    let!(:email_token) { Fabricate(:email_token, user: user1) }\n\n    it \"token doesn't match any records\" do\n      get \"/u/confirm-email-token/#{SecureRandom.hex}.json\"\n      expect(response.status).to eq(200)\n      expect(email_token.reload.confirmed).to eq(false)\n    end\n\n    it \"token matches\" do\n      get \"/u/confirm-email-token/#{email_token.token}.json\"\n      expect(response.status).to eq(200)\n      expect(email_token.reload.confirmed).to eq(true)\n    end\n  end\n\n  describe \"#admin_login\" do\n    it \"enqueues mail with admin email and sso enabled\" do\n      put \"/u/admin-login\", params: { email: admin.email }\n      expect(response.status).to eq(200)\n      expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n      args = Jobs::CriticalUserEmail.jobs.first[\"args\"].first\n      expect(args[\"user_id\"]).to eq(admin.id)\n    end\n\n    it \"passes through safe mode\" do\n      put \"/u/admin-login\", params: { email: admin.email, use_safe_mode: true }\n      expect(response.status).to eq(200)\n      expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n      args = Jobs::CriticalUserEmail.jobs.first[\"args\"].first\n      expect(args[\"email_token\"]).to end_with(\"?safe_mode=no_plugins,no_themes\")\n    end\n\n    context \"when email is incorrect\" do\n      it \"should return the right response\" do\n        put \"/u/admin-login\", params: { email: \"random\" }\n\n        expect(response.status).to eq(200)\n\n        response_body = response.body\n\n        expect(response_body).to match(I18n.t(\"admin_login.errors.unknown_email_address\"))\n        expect(response_body).to_not match(I18n.t(\"login.second_factor_description\"))\n      end\n    end\n  end\n\n  describe \"#toggle_anon\" do\n    it \"allows you to toggle anon if enabled\" do\n      SiteSetting.allow_anonymous_posting = true\n\n      user = sign_in(Fabricate(:user))\n      user.trust_level = 1\n      user.save!\n\n      post \"/u/toggle-anon.json\"\n      expect(response.status).to eq(200)\n      expect(session[:current_user_id]).to eq(AnonymousShadowCreator.get(user).id)\n\n      post \"/u/toggle-anon.json\"\n      expect(response.status).to eq(200)\n      expect(session[:current_user_id]).to eq(user.id)\n    end\n  end\n\n  describe \"#create\" do\n    def honeypot_magic(params)\n      get \"/session/hp.json\"\n      json = response.parsed_body\n      params[:password_confirmation] = json[\"value\"]\n      params[:challenge] = json[\"challenge\"].reverse\n      params\n    end\n\n    before do\n      UsersController.any_instance.stubs(:honeypot_value).returns(nil)\n      UsersController.any_instance.stubs(:challenge_value).returns(nil)\n      SiteSetting.allow_new_registrations = true\n      @user = Fabricate.build(:user, email: \"foobar@example.com\", password: \"strongpassword\")\n    end\n\n    let(:post_user_params) do\n      { name: @user.name, username: @user.username, password: \"strongpassword\", email: @user.email }\n    end\n\n    def post_user(extra_params = {})\n      post \"/u.json\", params: post_user_params.merge(extra_params)\n    end\n\n    context \"when email params is missing\" do\n      it \"should raise the right error\" do\n        post \"/u.json\",\n             params: {\n               name: @user.name,\n               username: @user.username,\n               password: \"testing12352343\",\n             }\n        expect(response.status).to eq(400)\n      end\n    end\n\n    context \"when creating a user\" do\n      it \"sets the user locale to I18n.locale\" do\n        SiteSetting.default_locale = \"en\"\n        I18n.stubs(:locale).returns(:fr)\n        post_user\n        expect(User.find_by(username: @user.username).locale).to eq(\"fr\")\n      end\n\n      it \"requires invite code when specified\" do\n        expect(SiteSetting.require_invite_code).to eq(false)\n        SiteSetting.invite_code = \"abc def\"\n        expect(SiteSetting.require_invite_code).to eq(true)\n\n        post_user(invite_code: \"abcd\")\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"success\"]).to eq(false)\n\n        # case insensitive and stripped of leading/ending spaces\n        post_user(invite_code: \" AbC deF \")\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"success\"]).to eq(true)\n      end\n\n      context \"when timezone is provided as a guess on signup\" do\n        it \"sets the timezone\" do\n          post_user(timezone: \"Australia/Brisbane\")\n          expect(response.status).to eq(200)\n          expect(User.find_by(username: @user.username).user_option.timezone).to eq(\n            \"Australia/Brisbane\",\n          )\n        end\n      end\n\n      context \"with local logins disabled\" do\n        before do\n          SiteSetting.enable_local_logins = false\n          SiteSetting.enable_google_oauth2_logins = true\n        end\n\n        it \"blocks registration without authenticator information\" do\n          post_user\n          expect(response.status).to eq(403)\n        end\n\n        it \"blocks with a regular api key\" do\n          api_key = Fabricate(:api_key, user: user1)\n          post \"/u.json\", params: post_user_params, headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(403)\n        end\n\n        it \"works with an admin api key\" do\n          api_key = Fabricate(:api_key, user: admin)\n          post \"/u.json\", params: post_user_params, headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(200)\n        end\n      end\n\n      context \"with external_ids\" do\n        fab!(:api_key, refind: false) { Fabricate(:api_key, user: admin) }\n\n        let(:plugin_auth_provider) do\n          authenticator_class =\n            Class.new(Auth::ManagedAuthenticator) do\n              def name\n                \"pluginauth\"\n              end\n\n              def enabled?\n                true\n              end\n            end\n\n          provider = Auth::AuthProvider.new\n          provider.authenticator = authenticator_class.new\n          provider\n        end\n\n        before { DiscoursePluginRegistry.register_auth_provider(plugin_auth_provider) }\n\n        after { DiscoursePluginRegistry.reset! }\n\n        it \"creates User record\" do\n          params = {\n            username: \"foobar\",\n            email: \"test@example.com\",\n            external_ids: {\n              \"pluginauth\" => \"pluginauth_uid\",\n            },\n          }\n\n          expect {\n            post \"/u.json\", params: params, headers: { HTTP_API_KEY: api_key.key }\n          }.to change { UserAssociatedAccount.count }.by(1).and change { User.count }.by(1)\n\n          expect(response.status).to eq(200)\n\n          user = User.last\n          user_associated_account = UserAssociatedAccount.last\n\n          expect(user.username).to eq(\"foobar\")\n          expect(user.email).to eq(\"test@example.com\")\n          expect(user.user_associated_account_ids).to contain_exactly(user_associated_account.id)\n          expect(user_associated_account.provider_name).to eq(\"pluginauth\")\n          expect(user_associated_account.provider_uid).to eq(\"pluginauth_uid\")\n          expect(user_associated_account.user_id).to eq(user.id)\n        end\n\n        it \"returns error if external ID provider does not exist\" do\n          params = {\n            username: \"foobar\",\n            email: \"test@example.com\",\n            external_ids: {\n              \"pluginauth2\" => \"pluginauth_uid\",\n            },\n          }\n\n          post \"/u.json\", params: params, headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(400)\n        end\n      end\n    end\n\n    context \"when creating a non active user (unconfirmed email)\" do\n      it \"returns 403 forbidden when local logins are disabled\" do\n        SiteSetting.enable_local_logins = false\n        post_user\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"returns an error when new registrations are disabled\" do\n        SiteSetting.allow_new_registrations = false\n\n        post_user\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n        expect(json[\"success\"]).to eq(false)\n        expect(json[\"message\"]).to be_present\n      end\n\n      it \"creates a user correctly\" do\n        post_user\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"active\"]).to be_falsey\n\n        # should save user_created_message in session\n        expect(session[\"user_created_message\"]).to be_present\n        expect(session[SessionController::ACTIVATE_USER_KEY]).to be_present\n\n        expect(Jobs::SendSystemMessage.jobs.size).to eq(0)\n\n        expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n        args = Jobs::CriticalUserEmail.jobs.first[\"args\"].first\n        expect(args[\"type\"]).to eq(\"signup\")\n      end\n\n      context \"when `must approve users` site setting is enabled\" do\n        before { SiteSetting.must_approve_users = true }\n\n        it \"creates a user correctly\" do\n          post_user\n          expect(response.status).to eq(200)\n\n          expect(response.parsed_body[\"active\"]).to be_falsey\n\n          # should save user_created_message in session\n          expect(session[\"user_created_message\"]).to be_present\n          expect(session[SessionController::ACTIVATE_USER_KEY]).to be_present\n\n          expect(Jobs::SendSystemMessage.jobs.size).to eq(0)\n\n          expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n          args = Jobs::CriticalUserEmail.jobs.first[\"args\"].first\n          expect(args[\"type\"]).to eq(\"signup\")\n        end\n      end\n\n      context \"when users already exists with given email\" do\n        let!(:existing) { Fabricate(:user, email: post_user_params[:email]) }\n\n        it \"returns an error if hide_email_address_taken is disabled\" do\n          SiteSetting.hide_email_address_taken = false\n\n          post_user\n          expect(response.status).to eq(200)\n\n          json = response.parsed_body\n          expect(json[\"success\"]).to eq(false)\n          expect(json[\"message\"]).to be_present\n        end\n\n        it \"returns success if hide_email_address_taken is enabled\" do\n          SiteSetting.hide_email_address_taken = true\n          expect { post_user }.to_not change { User.count }\n\n          expect(response.status).to eq(200)\n          expect(session[\"user_created_message\"]).to be_present\n\n          json = response.parsed_body\n          expect(json[\"active\"]).to be_falsey\n          expect(json[\"message\"]).to eq(\n            I18n.t(\"login.activate_email\", email: post_user_params[:email]),\n          )\n          expect(json[\"user_id\"]).not_to be_present\n\n          existing.destroy!\n          expect { post_user }.to change { User.count }\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n\n          expect(json[\"active\"]).to be_falsey\n          expect(json[\"message\"]).to eq(\n            I18n.t(\"login.activate_email\", email: post_user_params[:email]),\n          )\n          expect(json[\"user_id\"]).not_to be_present\n        end\n      end\n    end\n\n    context \"when creating as active\" do\n      it \"won't create the user as active\" do\n        post \"/u.json\", params: post_user_params.merge(active: true)\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"active\"]).to be_falsey\n      end\n\n      context \"with a regular api key\" do\n        fab!(:api_key, refind: false) { Fabricate(:api_key, user: user1) }\n\n        it \"won't create the user as active with a regular key\" do\n          post \"/u.json\",\n               params: post_user_params.merge(active: true),\n               headers: {\n                 HTTP_API_KEY: api_key.key,\n               }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"active\"]).to be_falsey\n        end\n      end\n\n      context \"with an admin api key\" do\n        fab!(:api_key, refind: false) { Fabricate(:api_key, user: admin) }\n\n        it \"creates the user as active with a an admin key\" do\n          SiteSetting.send_welcome_message = true\n          SiteSetting.must_approve_users = true\n\n          # Sidekiq::Client.expects(:enqueue).never\n          post \"/u.json\",\n               params: post_user_params.merge(approved: true, active: true),\n               headers: {\n                 HTTP_API_KEY: api_key.key,\n               }\n\n          expect(Jobs::CriticalUserEmail.jobs.size).to eq(0)\n          expect(Jobs::SendSystemMessage.jobs.size).to eq(0)\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"active\"]).to be_truthy\n          new_user = User.find(response.parsed_body[\"user_id\"])\n          expect(new_user.active).to eq(true)\n          expect(new_user.approved).to eq(true)\n          expect(new_user.approved_by_id).to eq(admin.id)\n          expect(new_user.approved_at).to_not eq(nil)\n          expect(new_user.email_tokens.where(confirmed: true, email: new_user.email)).to exist\n        end\n\n        it \"will create a reviewable when a user is created as active but not approved\" do\n          Jobs.run_immediately!\n          SiteSetting.must_approve_users = true\n\n          post \"/u.json\",\n               params: post_user_params.merge(active: true),\n               headers: {\n                 HTTP_API_KEY: api_key.key,\n               }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n\n          new_user = User.find(json[\"user_id\"])\n          expect(json[\"active\"]).to be_truthy\n          expect(new_user.approved).to eq(false)\n          expect(ReviewableUser.pending.find_by(target: new_user)).to be_present\n        end\n\n        it \"won't create a reviewable when a user is not active\" do\n          Jobs.run_immediately!\n          SiteSetting.must_approve_users = true\n\n          post \"/u.json\", params: post_user_params, headers: { HTTP_API_KEY: api_key.key }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n\n          new_user = User.find(json[\"user_id\"])\n          expect(json[\"active\"]).to eq(false)\n          expect(new_user.approved).to eq(false)\n          expect(ReviewableUser.pending.find_by(target: new_user)).to be_blank\n        end\n\n        it \"won't create the developer as active\" do\n          UsernameCheckerService.expects(:is_developer?).returns(true)\n\n          post \"/u.json\",\n               params: post_user_params.merge(active: true),\n               headers: {\n                 HTTP_API_KEY: api_key.key,\n               }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"active\"]).to be_falsy\n        end\n\n        it \"won't set the new user's locale to the admin's locale\" do\n          SiteSetting.allow_user_locale = true\n          admin.update!(locale: :fr)\n\n          post \"/u.json\",\n               params: post_user_params.merge(active: true),\n               headers: {\n                 HTTP_API_KEY: api_key.key,\n               }\n          expect(response.status).to eq(200)\n\n          json = response.parsed_body\n          new_user = User.find(json[\"user_id\"])\n          expect(new_user.locale).not_to eq(\"fr\")\n        end\n\n        it \"will auto approve user if the user email domain matches auto_approve_email_domains setting\" do\n          Jobs.run_immediately!\n          SiteSetting.must_approve_users = true\n          SiteSetting.auto_approve_email_domains = \"example.com\"\n\n          post \"/u.json\",\n               params: post_user_params.merge(active: true),\n               headers: {\n                 HTTP_API_KEY: api_key.key,\n               }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n\n          new_user = User.find(json[\"user_id\"])\n          expect(json[\"active\"]).to be_truthy\n          expect(new_user.approved).to be_truthy\n          expect(ReviewableUser.pending.find_by(target: new_user)).to be_blank\n        end\n      end\n    end\n\n    context \"when creating as staged\" do\n      it \"won't create the user as staged\" do\n        post \"/u.json\", params: post_user_params.merge(staged: true)\n        expect(response.status).to eq(200)\n        new_user = User.where(username: post_user_params[:username]).first\n        expect(new_user.staged?).to eq(false)\n      end\n\n      context \"with a regular api key\" do\n        fab!(:api_key, refind: false) { Fabricate(:api_key, user: user1) }\n\n        it \"won't create the user as staged with a regular key\" do\n          post \"/u.json\",\n               params: post_user_params.merge(staged: true),\n               headers: {\n                 HTTP_API_KEY: api_key.key,\n               }\n          expect(response.status).to eq(200)\n\n          new_user = User.where(username: post_user_params[:username]).first\n          expect(new_user.staged?).to eq(false)\n        end\n      end\n\n      context \"with an admin api key\" do\n        fab!(:user) { admin }\n        fab!(:api_key, refind: false) { Fabricate(:api_key, user: user) }\n\n        it \"creates the user as staged with a regular key\" do\n          post \"/u.json\",\n               params: post_user_params.merge(staged: true),\n               headers: {\n                 HTTP_API_KEY: api_key.key,\n               }\n          expect(response.status).to eq(200)\n\n          new_user = User.where(username: post_user_params[:username]).first\n          expect(new_user.staged?).to eq(true)\n        end\n\n        it \"won't create the developer as staged\" do\n          UsernameCheckerService.expects(:is_developer?).returns(true)\n          post \"/u.json\",\n               params: post_user_params.merge(staged: true),\n               headers: {\n                 HTTP_API_KEY: api_key.key,\n               }\n          expect(response.status).to eq(200)\n\n          new_user = User.where(username: post_user_params[:username]).first\n          expect(new_user.staged?).to eq(false)\n        end\n      end\n    end\n\n    context \"when creating an active user (confirmed email)\" do\n      before { User.any_instance.stubs(:active?).returns(true) }\n\n      it \"enqueues a welcome email\" do\n        User.any_instance.expects(:enqueue_welcome_message).with(\"welcome_user\")\n\n        post_user\n        expect(response.status).to eq(200)\n\n        # should save user_created_message in session\n        expect(session[\"user_created_message\"]).to be_present\n        expect(session[SessionController::ACTIVATE_USER_KEY]).to be_present\n      end\n\n      it \"shows the 'active' message\" do\n        User.any_instance.expects(:enqueue_welcome_message)\n        post_user\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"message\"]).to eq(I18n.t \"login.active\")\n      end\n\n      it \"should be logged in\" do\n        User.any_instance.expects(:enqueue_welcome_message)\n        post_user\n        expect(response.status).to eq(200)\n        expect(session[:current_user_id]).to be_present\n      end\n\n      it \"indicates the user is active in the response\" do\n        User.any_instance.expects(:enqueue_welcome_message)\n        post_user\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"active\"]).to be_truthy\n      end\n\n      it 'doesn\\'t succeed when new registrations are disabled' do\n        SiteSetting.allow_new_registrations = false\n\n        post_user\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n        expect(json[\"success\"]).to eq(false)\n        expect(json[\"message\"]).to be_present\n      end\n\n      context \"with authentication records for\" do\n        before do\n          OmniAuth.config.test_mode = true\n\n          OmniAuth.config.mock_auth[:twitter] = OmniAuth::AuthHash.new(\n            provider: \"twitter\",\n            uid: \"123545\",\n            info:\n              OmniAuth::AuthHash::InfoHash.new(\n                email: \"osama@mail.com\",\n                nickname: \"testosama\",\n                name: \"Osama Test\",\n              ),\n          )\n\n          Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[:twitter]\n          SiteSetting.enable_twitter_logins = true\n          get \"/auth/twitter/callback.json\"\n        end\n\n        after do\n          Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[:twitter] = nil\n          OmniAuth.config.test_mode = false\n        end\n\n        it \"should create twitter user info if required\" do\n          post \"/u.json\",\n               params: {\n                 name: \"Test Osama\",\n                 username: \"testosama\",\n                 password: \"strongpassword\",\n                 email: \"osama@mail.com\",\n               }\n\n          expect(response.status).to eq(200)\n          expect(UserAssociatedAccount.where(provider_name: \"twitter\").count).to eq(1)\n        end\n\n        it \"returns an error when email has been changed from the validated email address\" do\n          post \"/u.json\",\n               params: {\n                 name: \"Test Osama\",\n                 username: \"testosama\",\n                 password: \"strongpassword\",\n                 email: \"unvalidatedemail@mail.com\",\n               }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json[\"success\"]).to eq(false)\n          expect(json[\"message\"]).to be_present\n        end\n\n        it \"will create the user successfully if email validation is required\" do\n          post \"/u.json\",\n               params: {\n                 name: \"Test Osama\",\n                 username: \"testosama\",\n                 password: \"strongpassword\",\n                 email: \"osama@mail.com\",\n               }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json[\"success\"]).to eq(true)\n        end\n\n        it \"doesn't use provided username/name if sso_overrides is enabled\" do\n          SiteSetting.auth_overrides_username = true\n          SiteSetting.auth_overrides_name = true\n          post \"/u.json\",\n               params: {\n                 username: \"attemptednewname\",\n                 name: \"Attempt At New Name\",\n                 password: \"strongpassword\",\n                 email: \"osama@mail.com\",\n               }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json[\"success\"]).to eq(true)\n\n          user = User.last\n\n          expect(user.username).to eq(\"testosama\")\n          expect(user.name).to eq(\"Osama Test\")\n        end\n      end\n\n      context \"with no email in the auth payload\" do\n        before do\n          OmniAuth.config.test_mode = true\n          OmniAuth.config.mock_auth[:twitter] = OmniAuth::AuthHash.new(\n            provider: \"twitter\",\n            uid: \"123545\",\n            info: OmniAuth::AuthHash::InfoHash.new(nickname: \"testosama\", name: \"Osama Test\"),\n          )\n          Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[:twitter]\n          SiteSetting.enable_twitter_logins = true\n          get \"/auth/twitter/callback.json\"\n        end\n\n        after do\n          Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[:twitter] = nil\n          OmniAuth.config.test_mode = false\n        end\n\n        it \"will create the user successfully\" do\n          Rails.application.env_config[\"omniauth.auth\"].info.email = nil\n\n          post \"/u.json\",\n               params: {\n                 name: \"Test Osama\",\n                 username: \"testosama\",\n                 password: \"strongpassword\",\n                 email: \"osama@mail.com\",\n               }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json[\"success\"]).to eq(true)\n        end\n      end\n    end\n\n    it \"creates user successfully but doesn't activate the account\" do\n      post_user\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"success\"]).to eq(true)\n      expect(User.find_by(username: @user.username).active).to eq(false)\n    end\n\n    shared_examples \"honeypot fails\" do\n      it \"should not create a new user\" do\n        User.any_instance.expects(:enqueue_welcome_message).never\n\n        expect { post \"/u.json\", params: create_params }.to_not change { User.count }\n\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n        expect(json[\"success\"]).to eq(true)\n\n        # should not change the session\n        expect(session[\"user_created_message\"]).to be_blank\n        expect(session[SessionController::ACTIVATE_USER_KEY]).to be_blank\n      end\n    end\n\n    context \"when honeypot value is wrong\" do\n      before { UsersController.any_instance.stubs(:honeypot_value).returns(\"abc\") }\n      let(:create_params) do\n        {\n          name: @user.name,\n          username: @user.username,\n          password: \"strongpassword\",\n          email: @user.email,\n          password_confirmation: \"wrong\",\n        }\n      end\n      include_examples \"honeypot fails\"\n    end\n\n    context \"when challenge answer is wrong\" do\n      before { UsersController.any_instance.stubs(:challenge_value).returns(\"abc\") }\n      let(:create_params) do\n        {\n          name: @user.name,\n          username: @user.username,\n          password: \"strongpassword\",\n          email: @user.email,\n          challenge: \"abc\",\n        }\n      end\n      include_examples \"honeypot fails\"\n    end\n\n    context \"when 'invite only' setting is enabled\" do\n      before { SiteSetting.invite_only = true }\n\n      let(:create_params) do\n        {\n          name: @user.name,\n          username: @user.username,\n          password: \"strongpassword\",\n          email: @user.email,\n        }\n      end\n\n      include_examples \"honeypot fails\"\n    end\n\n    shared_examples \"failed signup\" do\n      it \"should not create a new User\" do\n        expect { post \"/u.json\", params: create_params }.to_not change { User.count }\n        expect(response.status).to eq(200)\n      end\n\n      it \"should report failed\" do\n        post \"/u.json\", params: create_params\n        json = response.parsed_body\n        expect(json[\"success\"]).not_to eq(true)\n\n        # should not change the session\n        expect(session[\"user_created_message\"]).to be_blank\n        expect(session[SessionController::ACTIVATE_USER_KEY]).to be_blank\n      end\n    end\n\n    context \"when password is blank\" do\n      let(:create_params) do\n        { name: @user.name, username: @user.username, password: \"\", email: @user.email }\n      end\n      include_examples \"failed signup\"\n    end\n\n    context \"when password is too long\" do\n      let(:create_params) do\n        {\n          name: @user.name,\n          username: @user.username,\n          password: \"x\" * (User.max_password_length + 1),\n          email: @user.email,\n        }\n      end\n      include_examples \"failed signup\"\n    end\n\n    context \"when password param is missing\" do\n      let(:create_params) { { name: @user.name, username: @user.username, email: @user.email } }\n      include_examples \"failed signup\"\n    end\n\n    context \"with a reserved username\" do\n      let(:create_params) do\n        { name: @user.name, username: \"Reserved\", email: @user.email, password: \"strongpassword\" }\n      end\n      before { SiteSetting.reserved_usernames = \"a|reserved|b\" }\n      include_examples \"failed signup\"\n    end\n\n    context \"with a username that matches a user route\" do\n      let(:create_params) do\n        {\n          name: @user.name,\n          username: \"account-created\",\n          email: @user.email,\n          password: \"strongpassword\",\n        }\n      end\n      include_examples \"failed signup\"\n    end\n\n    context \"with a missing username\" do\n      let(:create_params) { { name: @user.name, email: @user.email, password: \"x\" * 20 } }\n\n      it \"should not create a new User\" do\n        expect { post \"/u.json\", params: create_params }.to_not change { User.count }\n        expect(response.status).to eq(400)\n      end\n    end\n\n    context \"when an Exception is raised\" do\n      before { User.any_instance.stubs(:save).raises(ActiveRecord::StatementInvalid.new(\"Oh no\")) }\n\n      let(:create_params) do\n        {\n          name: @user.name,\n          username: @user.username,\n          password: \"strongpassword\",\n          email: @user.email,\n        }\n      end\n\n      include_examples \"failed signup\"\n    end\n\n    context \"with custom fields\" do\n      fab!(:user_field) { Fabricate(:user_field) }\n      fab!(:another_field) { Fabricate(:user_field) }\n      fab!(:optional_field) { Fabricate(:user_field, required: false) }\n\n      context \"without a value for the fields\" do\n        let(:create_params) do\n          { name: @user.name, password: \"watwatwat\", username: @user.username, email: @user.email }\n        end\n        include_examples \"failed signup\"\n      end\n\n      context \"with values for the fields\" do\n        let(:update_user_url) { \"/u/#{user1.username}.json\" }\n        let(:field_id) { user_field.id.to_s }\n\n        before { sign_in(user1) }\n\n        context \"with multple select fields\" do\n          let(:valid_options) { %w[Axe Sword] }\n\n          fab!(:user_field) do\n            Fabricate(:user_field, field_type: \"multiselect\") do\n              user_field_options do\n                [\n                  Fabricate(:user_field_option, value: \"Axe\"),\n                  Fabricate(:user_field_option, value: \"Sword\"),\n                ]\n              end\n            end\n          end\n\n          it \"should allow single values and not just arrays\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => \"Axe\" } }\n            end.to change { user1.reload.user_fields[field_id] }.from(nil).to(\"Axe\")\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => %w[Axe Juice Sword] } }\n            end.to change { user1.reload.user_fields[field_id] }.from(\"Axe\").to(%w[Axe Sword])\n          end\n\n          it \"shouldn't allow unregistered field values\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => %w[Juice] } }\n            end.not_to change { user1.reload.user_fields[field_id] }\n          end\n\n          it \"should filter valid values\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => %w[Axe Juice Sword] } }\n            end.to change { user1.reload.user_fields[field_id] }.from(nil).to(valid_options)\n          end\n\n          it \"allows registered field values\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => valid_options } }\n            end.to change { user1.reload.user_fields[field_id] }.from(nil).to(valid_options)\n          end\n\n          it \"value can't be nil or empty if the field is required\" do\n            put update_user_url, params: { user_fields: { field_id => valid_options } }\n\n            user_field.update!(required: true)\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => nil } }\n            end.not_to change { user1.reload.user_fields[field_id] }\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => \"\" } }\n            end.not_to change { user1.reload.user_fields[field_id] }\n          end\n\n          it \"value can nil or empty if the field is not required\" do\n            put update_user_url, params: { user_fields: { field_id => valid_options } }\n\n            user_field.update!(required: false)\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => nil } }\n            end.to change { user1.reload.user_fields[field_id] }.from(valid_options).to(nil)\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => \"\" } }\n            end.to change { user1.reload.user_fields[field_id] }.from(nil).to(\"\")\n          end\n        end\n\n        context \"with dropdown fields\" do\n          let(:valid_options) { [\"Black Mesa\", \"Fox Hound\"] }\n\n          fab!(:user_field) do\n            Fabricate(:user_field, field_type: \"dropdown\") do\n              user_field_options do\n                [\n                  Fabricate(:user_field_option, value: \"Black Mesa\"),\n                  Fabricate(:user_field_option, value: \"Fox Hound\"),\n                ]\n              end\n            end\n          end\n\n          it \"shouldn't allow unregistered field values\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => \"Umbrella Corporation\" } }\n            end.not_to change { user1.reload.user_fields[field_id] }\n          end\n\n          it \"allows registered field values\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => valid_options.first } }\n            end.to change { user1.reload.user_fields[field_id] }.from(nil).to(valid_options.first)\n          end\n\n          it \"value can't be nil if the field is required\" do\n            put update_user_url, params: { user_fields: { field_id => valid_options.first } }\n\n            user_field.update!(required: true)\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => nil } }\n            end.not_to change { user1.reload.user_fields[field_id] }\n          end\n\n          it \"value can be set to nil if the field is not required\" do\n            put update_user_url, params: { user_fields: { field_id => valid_options.last } }\n\n            user_field.update!(required: false)\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => nil } }\n            end.to change { user1.reload.user_fields[field_id] }.from(valid_options.last).to(nil)\n          end\n        end\n\n        let(:create_params) do\n          {\n            name: @user.name,\n            password: \"suChS3cuRi7y\",\n            username: @user.username,\n            email: @user.email,\n            user_fields: {\n              user_field.id.to_s => \"value1\",\n              another_field.id.to_s => \"value2\",\n            },\n          }\n        end\n\n        it \"should succeed without the optional field\" do\n          post \"/u.json\", params: create_params\n          expect(response.status).to eq(200)\n          inserted = User.find_by_email(@user.email)\n          expect(inserted).to be_present\n          expect(inserted.custom_fields).to be_present\n          expect(inserted.custom_fields[\"user_field_#{user_field.id}\"]).to eq(\"value1\")\n          expect(inserted.custom_fields[\"user_field_#{another_field.id}\"]).to eq(\"value2\")\n          expect(inserted.custom_fields[\"user_field_#{optional_field.id}\"]).to be_blank\n        end\n\n        it \"should succeed with the optional field\" do\n          create_params[:user_fields][optional_field.id.to_s] = \"value3\"\n          post \"/u.json\", params: create_params.merge(create_params)\n          expect(response.status).to eq(200)\n          inserted = User.find_by_email(@user.email)\n          expect(inserted).to be_present\n          expect(inserted.custom_fields).to be_present\n          expect(inserted.custom_fields[\"user_field_#{user_field.id}\"]).to eq(\"value1\")\n          expect(inserted.custom_fields[\"user_field_#{another_field.id}\"]).to eq(\"value2\")\n          expect(inserted.custom_fields[\"user_field_#{optional_field.id}\"]).to eq(\"value3\")\n        end\n\n        it \"trims excessively long fields\" do\n          create_params[:user_fields][optional_field.id.to_s] = (\"x\" * 3000)\n          post \"/u.json\", params: create_params.merge(create_params)\n          expect(response.status).to eq(200)\n          inserted = User.find_by_email(@user.email)\n\n          val = inserted.custom_fields[\"user_field_#{optional_field.id}\"]\n          expect(val.length).to eq(UserField.max_length)\n        end\n      end\n    end\n\n    context \"with only optional custom fields\" do\n      fab!(:user_field) { Fabricate(:user_field, required: false) }\n\n      context \"without values for the fields\" do\n        let(:create_params) do\n          {\n            name: @user.name,\n            password: \"suChS3cuRi7y\",\n            username: @user.username,\n            email: @user.email,\n          }\n        end\n\n        it \"should succeed\" do\n          post \"/u.json\", params: create_params\n          expect(response.status).to eq(200)\n          inserted = User.find_by_email(@user.email)\n          expect(inserted).to be_present\n          expect(inserted.custom_fields).not_to be_present\n          expect(inserted.custom_fields[\"user_field_#{user_field.id}\"]).to be_blank\n        end\n      end\n    end\n\n    context \"when taking over a staged account\" do\n      before do\n        UsersController.any_instance.stubs(:honeypot_value).returns(\"abc\")\n        UsersController.any_instance.stubs(:challenge_value).returns(\"efg\")\n        SessionController.any_instance.stubs(:honeypot_value).returns(\"abc\")\n        SessionController.any_instance.stubs(:challenge_value).returns(\"efg\")\n      end\n\n      fab!(:staged) { Fabricate(:staged, email: \"staged@account.com\", active: true) }\n\n      it \"succeeds\" do\n        post \"/u.json\",\n             params:\n               honeypot_magic(email: staged.email, username: \"zogstrip\", password: \"P4ssw0rd$$\")\n\n        expect(response.status).to eq(200)\n        result = response.parsed_body\n        expect(result[\"success\"]).to eq(true)\n\n        created_user = User.find_by_email(staged.email)\n        expect(created_user.staged).to eq(false)\n        expect(created_user.active).to eq(false)\n        expect(created_user.registration_ip_address).to be_present\n        expect(!!created_user.custom_fields[\"from_staged\"]).to eq(true)\n\n        # do not allow emails changes please\n\n        put \"/u/update-activation-email.json\", params: { email: \"bob@bob.com\" }\n\n        created_user.reload\n        expect(created_user.email).to eq(\"staged@account.com\")\n        expect(response.status).to eq(403)\n      end\n\n      it \"works with custom fields\" do\n        tennis_field = Fabricate(:user_field, show_on_profile: true, name: \"Favorite tennis player\")\n\n        post \"/u.json\",\n             params:\n               honeypot_magic(\n                 email: staged.email,\n                 username: \"dude\",\n                 password: \"P4ssw0rd$$\",\n                 user_fields: {\n                   [tennis_field.id] => \"Nadal\",\n                 },\n               )\n\n        expect(response.status).to eq(200)\n        result = response.parsed_body\n        expect(result[\"success\"]).to eq(true)\n\n        created_user = User.find_by_email(staged.email)\n        expect(created_user.staged).to eq(false)\n        expect(created_user.active).to eq(false)\n        expect(created_user.registration_ip_address).to be_present\n        expect(!!created_user.custom_fields[\"from_staged\"]).to eq(true)\n\n        expect(created_user.custom_fields[\"user_field_#{tennis_field.id}\"]).to eq(\"Nadal\")\n      end\n    end\n  end\n\n  describe \"#username\" do\n    it \"raises an error when not logged in\" do\n      put \"/u/somename/preferences/username.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      let(:old_username) { \"OrigUsername\" }\n      let(:new_username) { \"#{old_username}1234\" }\n      fab!(:user) { Fabricate(:user, username: \"OrigUsername\") }\n\n      before do\n        user.username = old_username\n        sign_in(user)\n      end\n\n      it \"raises an error without a new_username param\" do\n        put \"/u/#{user.username}/preferences/username.json\", params: { username: user.username }\n        expect(response.status).to eq(400)\n        expect(user.reload.username).to eq(old_username)\n      end\n\n      it 'raises an error when you don\\'t have permission to change the username' do\n        Guardian.any_instance.expects(:can_edit_username?).with(user).returns(false)\n\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response).to be_forbidden\n        expect(user.reload.username).to eq(old_username)\n      end\n\n      it \"raises an error when change_username fails\" do\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: \"@\" }\n\n        expect(response.status).to eq(422)\n\n        body = response.parsed_body\n\n        expect(body[\"errors\"].first).to include(\n          I18n.t(\"user.username.short\", min: User.username_length.begin),\n        )\n\n        expect(user.reload.username).to eq(old_username)\n      end\n\n      it \"should succeed in normal circumstances\" do\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response.status).to eq(200)\n        expect(user.reload.username).to eq(new_username)\n      end\n\n      it \"raises an error when the username clashes with an existing user route\" do\n        put \"/u/#{user.username}/preferences/username.json\",\n            params: {\n              new_username: \"account-created\",\n            }\n\n        body = response.parsed_body\n\n        expect(body[\"errors\"].first).to include(I18n.t(\"login.reserved_username\"))\n      end\n\n      it \"raises an error when the username is in the reserved list\" do\n        SiteSetting.reserved_usernames = \"reserved\"\n\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: \"reserved\" }\n        body = response.parsed_body\n\n        expect(body[\"errors\"].first).to include(I18n.t(\"login.reserved_username\"))\n      end\n\n      it \"should fail if the user is old\" do\n        # Older than the change period and >1 post\n        user.created_at = Time.now - (SiteSetting.username_change_period + 1).days\n        PostCreator.new(\n          user,\n          title: \"This is a test topic\",\n          raw: \"This is a test this is a test\",\n        ).create\n\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response).to be_forbidden\n        expect(user.reload.username).to eq(old_username)\n      end\n\n      it \"should create a staff action log when a staff member changes the username\" do\n        acting_user = admin\n        sign_in(acting_user)\n\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response.status).to eq(200)\n        expect(\n          UserHistory.where(\n            action: UserHistory.actions[:change_username],\n            target_user_id: user.id,\n            acting_user_id: acting_user.id,\n          ),\n        ).to be_present\n        expect(user.reload.username).to eq(new_username)\n      end\n\n      it \"should return a JSON response with the updated username\" do\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response.parsed_body[\"username\"]).to eq(new_username)\n      end\n\n      it \"should respond with proper error message if auth_overrides_username is enabled\" do\n        SiteSetting.discourse_connect_url = \"http://someurl.com\"\n        SiteSetting.enable_discourse_connect = true\n        SiteSetting.auth_overrides_username = true\n        acting_user = admin\n        sign_in(acting_user)\n\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response.status).to eq(422)\n        expect(response.parsed_body[\"errors\"].first).to include(\n          I18n.t(\"errors.messages.auth_overrides_username\"),\n        )\n      end\n    end\n  end\n\n  describe \"#check_username\" do\n    it \"raises an error without any parameters\" do\n      get \"/u/check_username.json\"\n      expect(response.status).to eq(400)\n    end\n\n    shared_examples \"when username is unavailable\" do\n      it \"should return available as false in the JSON and return a suggested username\" do\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"available\"]).to eq(false)\n        expect(response.parsed_body[\"suggestion\"]).to be_present\n      end\n    end\n\n    shared_examples \"when username is available\" do\n      it \"should return available in the JSON\" do\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"available\"]).to eq(true)\n      end\n    end\n\n    it \"returns nothing when given an email param but no username\" do\n      get \"/u/check_username.json\", params: { email: \"dood@example.com\" }\n      expect(response.status).to eq(200)\n    end\n\n    context \"when username is available\" do\n      before { get \"/u/check_username.json\", params: { username: \"BruceWayne\" } }\n      include_examples \"when username is available\"\n    end\n\n    context \"when username is unavailable\" do\n      before { get \"/u/check_username.json\", params: { username: user1.username } }\n      include_examples \"when username is unavailable\"\n    end\n\n    shared_examples \"checking an invalid username\" do\n      it \"should not return an available key but should return an error message\" do\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"available\"]).to eq(nil)\n        expect(response.parsed_body[\"errors\"]).to be_present\n      end\n    end\n\n    context \"when has invalid characters\" do\n      before { get \"/u/check_username.json\", params: { username: \"bad username\" } }\n      include_examples \"checking an invalid username\"\n\n      it \"should return the invalid characters message\" do\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"errors\"]).to include(I18n.t(:\"user.username.characters\"))\n      end\n    end\n\n    context \"when is too long\" do\n      before do\n        get \"/u/check_username.json\",\n            params: {\n              username: SecureRandom.alphanumeric(SiteSetting.max_username_length.to_i + 1),\n            }\n      end\n      include_examples \"checking an invalid username\"\n\n      it 'should return the \"too long\" message' do\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"errors\"]).to include(\n          I18n.t(:\"user.username.long\", max: SiteSetting.max_username_length),\n        )\n      end\n    end\n\n    describe \"different case of existing username\" do\n      context \"when it's my username\" do\n        fab!(:user) { Fabricate(:user, username: \"hansolo\") }\n        before do\n          sign_in(user)\n\n          get \"/u/check_username.json\", params: { username: \"HanSolo\" }\n        end\n        include_examples \"when username is available\"\n      end\n\n      context \"when it's someone else's username\" do\n        fab!(:user) { Fabricate(:user, username: \"hansolo\") }\n        fab!(:someone_else) { Fabricate(:user) }\n        before do\n          sign_in(someone_else)\n\n          get \"/u/check_username.json\", params: { username: \"HanSolo\" }\n        end\n        include_examples \"when username is unavailable\"\n      end\n\n      context \"when an admin changing it for someone else\" do\n        fab!(:user) { Fabricate(:user, username: \"hansolo\") }\n        before do\n          sign_in(admin)\n\n          get \"/u/check_username.json\", params: { username: \"HanSolo\", for_user_id: user.id }\n        end\n        include_examples \"when username is available\"\n      end\n    end\n  end\n\n  describe \"#check_email\" do\n    it \"returns success if hide_email_address_taken is true\" do\n      SiteSetting.hide_email_address_taken = true\n\n      get \"/u/check_email.json\", params: { email: user1.email }\n      expect(response.parsed_body[\"success\"]).to be_present\n    end\n\n    it \"returns success if email is empty\" do\n      get \"/u/check_email.json\"\n      expect(response.parsed_body[\"success\"]).to be_present\n    end\n\n    it \"returns failure if email is not valid\" do\n      get \"/u/check_email.json\", params: { email: \"invalid\" }\n      expect(response.parsed_body[\"failed\"]).to be_present\n    end\n\n    it \"returns failure if email exists\" do\n      get \"/u/check_email.json\", params: { email: user1.email }\n      expect(response.parsed_body[\"failed\"]).to be_present\n\n      get \"/u/check_email.json\", params: { email: user1.email.upcase }\n      expect(response.parsed_body[\"failed\"]).to be_present\n    end\n\n    it \"returns success if email does not exists\" do\n      get \"/u/check_email.json\", params: { email: \"available@example.com\" }\n      expect(response.parsed_body[\"success\"]).to be_present\n    end\n\n    it \"return success if user email is taken by staged user\" do\n      get \"/u/check_email.json\", params: { email: Fabricate(:staged).email }\n      expect(response.parsed_body[\"success\"]).to be_present\n    end\n  end\n\n  describe \"#invited\" do\n    it \"fails for anonymous users\" do\n      get \"/u/#{user1.username}/invited.json\", params: { username: user1.username }\n\n      expect(response.status).to eq(403)\n    end\n\n    it \"returns success\" do\n      user = Fabricate(:user, trust_level: 2)\n      Fabricate(:invite, invited_by: user)\n\n      sign_in(user)\n      get \"/u/#{user.username}/invited.json\", params: { username: user.username }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"counts\"][\"pending\"]).to eq(1)\n      expect(response.parsed_body[\"counts\"][\"total\"]).to eq(1)\n    end\n\n    it \"filters by all if viewing self\" do\n      inviter = Fabricate(:user, trust_level: 2)\n      sign_in(inviter)\n\n      Fabricate(:invite, email: \"billybob@example.com\", invited_by: inviter)\n      redeemed_invite = Fabricate(:invite, email: \"jimtom@example.com\", invited_by: inviter)\n      Fabricate(:invited_user, invite: redeemed_invite, user: invitee)\n\n      get \"/u/#{inviter.username}/invited.json\", params: { filter: \"pending\", search: \"billybob\" }\n      expect(response.status).to eq(200)\n\n      invites = response.parsed_body[\"invites\"]\n      expect(invites.size).to eq(1)\n      expect(invites.first).to include(\"email\" => \"billybob@example.com\")\n\n      get \"/u/#{inviter.username}/invited.json\",\n          params: {\n            filter: \"redeemed\",\n            search: invitee.username,\n          }\n      expect(response.status).to eq(200)\n\n      invites = response.parsed_body[\"invites\"]\n      expect(invites.size).to eq(1)\n      expect(invites[0][\"user\"]).to be_present\n    end\n\n    it \"doesn't filter by email if another regular user\" do\n      inviter = Fabricate(:user, trust_level: 2)\n      sign_in(Fabricate(:user, trust_level: 2))\n\n      Fabricate(:invite, email: \"billybob@example.com\", invited_by: inviter)\n      redeemed_invite = Fabricate(:invite, email: \"jimtom@example.com\", invited_by: inviter)\n      Fabricate(:invited_user, invite: redeemed_invite, user: invitee)\n\n      get \"/u/#{inviter.username}/invited.json\", params: { filter: \"pending\", search: \"billybob\" }\n      expect(response.status).to eq(200)\n\n      invites = response.parsed_body[\"invites\"]\n      expect(invites.size).to eq(0)\n\n      get \"/u/#{inviter.username}/invited.json\",\n          params: {\n            filter: \"redeemed\",\n            search: invitee.username,\n          }\n      expect(response.status).to eq(200)\n\n      invites = response.parsed_body[\"invites\"]\n      expect(invites.size).to eq(1)\n      expect(invites[0][\"user\"]).to be_present\n    end\n\n    it \"filters by email if staff\" do\n      inviter = Fabricate(:user, trust_level: 2)\n      sign_in(moderator)\n\n      invite_1 = Fabricate(:invite, email: \"billybob@example.com\", invited_by: inviter)\n      invitee_1 = Fabricate(:user)\n      Fabricate(:invited_user, invite: invite_1, user: invitee_1)\n      invite_2 = Fabricate(:invite, email: \"jimtom@example.com\", invited_by: inviter)\n      invitee_2 = Fabricate(:user)\n      Fabricate(:invited_user, invite: invite_2, user: invitee_2)\n\n      get \"/u/#{inviter.username}/invited.json\", params: { search: \"billybob\" }\n      expect(response.status).to eq(200)\n\n      invites = response.parsed_body[\"invites\"]\n      expect(invites.size).to eq(1)\n      expect(invites[0][\"user\"]).to include(\"id\" => invitee_1.id)\n    end\n\n    context \"with guest\" do\n      context \"with pending invites\" do\n        it \"does not return invites\" do\n          Fabricate(:invite, invited_by: inviter)\n\n          get \"/u/#{user1.username}/invited/pending.json\"\n          expect(response.status).to eq(403)\n        end\n      end\n\n      context \"with redeemed invites\" do\n        it \"returns invited_users\" do\n          inviter = Fabricate(:user, trust_level: 2)\n          sign_in(inviter)\n          invite = Fabricate(:invite, invited_by: inviter)\n          _invited_user = Fabricate(:invited_user, invite: invite, user: invitee)\n\n          get \"/u/#{inviter.username}/invited.json\"\n          expect(response.status).to eq(200)\n\n          invites = response.parsed_body[\"invites\"]\n          expect(invites.size).to eq(1)\n          expect(invites[0]).to include(\"id\" => invite.id)\n        end\n      end\n    end\n\n    context \"with authenticated user\" do\n      context \"with pending invites\" do\n        context \"with permission to see pending invites\" do\n          it \"returns invites\" do\n            inviter = Fabricate(:user, trust_level: 2)\n            invite = Fabricate(:invite, invited_by: inviter)\n            sign_in(inviter)\n\n            get \"/u/#{inviter.username}/invited/pending.json\"\n            expect(response.status).to eq(200)\n\n            invites = response.parsed_body[\"invites\"]\n            expect(invites.size).to eq(1)\n            expect(invites.first).to include(\"email\" => invite.email)\n            expect(response.parsed_body[\"can_see_invite_details\"]).to eq(true)\n          end\n        end\n\n        context \"without permission to see pending invites\" do\n          it \"does not return invites\" do\n            user = sign_in(Fabricate(:user))\n            Fabricate(:invite, invited_by: inviter)\n            stub_guardian(user) do |guardian|\n              guardian.stubs(:can_see_invite_details?).with(inviter).returns(false)\n            end\n\n            get \"/u/#{inviter.username}/invited/pending.json\"\n            expect(response.status).to eq(422)\n          end\n        end\n\n        context \"with permission to see invite links\" do\n          it \"returns own invites\" do\n            inviter = sign_in(Fabricate(:user, trust_level: 2))\n            invite =\n              Fabricate(\n                :invite,\n                invited_by: inviter,\n                email: nil,\n                max_redemptions_allowed: 5,\n                expires_at: 1.month.from_now,\n                emailed_status: Invite.emailed_status_types[:not_required],\n              )\n\n            get \"/u/#{inviter.username}/invited/pending.json\"\n            expect(response.status).to eq(200)\n\n            invites = response.parsed_body[\"invites\"]\n            expect(invites.size).to eq(1)\n            expect(invites.first).to include(\"id\" => invite.id)\n            expect(response.parsed_body[\"can_see_invite_details\"]).to eq(true)\n          end\n\n          it \"allows admin to see invites\" do\n            inviter = Fabricate(:user, trust_level: 2)\n            _admin = sign_in(Fabricate(:admin))\n            invite =\n              Fabricate(\n                :invite,\n                invited_by: inviter,\n                email: nil,\n                max_redemptions_allowed: 5,\n                expires_at: 1.month.from_now,\n                emailed_status: Invite.emailed_status_types[:not_required],\n              )\n\n            get \"/u/#{inviter.username}/invited/pending.json\"\n            expect(response.status).to eq(200)\n\n            invites = response.parsed_body[\"invites\"]\n            expect(invites.size).to eq(1)\n            expect(invites.first).to include(\"id\" => invite.id)\n            expect(response.parsed_body[\"can_see_invite_details\"]).to eq(true)\n          end\n        end\n\n        context \"without permission to see invite links\" do\n          it \"does not return invites\" do\n            _user = Fabricate(:user, trust_level: 2)\n            inviter = admin\n            Fabricate(\n              :invite,\n              invited_by: inviter,\n              email: nil,\n              max_redemptions_allowed: 5,\n              expires_at: 1.month.from_now,\n              emailed_status: Invite.emailed_status_types[:not_required],\n            )\n\n            get \"/u/#{inviter.username}/invited/pending.json\"\n            expect(response.status).to eq(403)\n          end\n        end\n      end\n\n      context \"with redeemed invites\" do\n        it \"returns invites\" do\n          sign_in(moderator)\n          invite = Fabricate(:invite, invited_by: inviter)\n          Fabricate(:invited_user, invite: invite, user: invitee)\n\n          get \"/u/#{inviter.username}/invited.json\"\n          expect(response.status).to eq(200)\n\n          invites = response.parsed_body[\"invites\"]\n          expect(invites.size).to eq(1)\n          expect(invites[0]).to include(\"id\" => invite.id)\n        end\n      end\n    end\n  end\n\n  describe \"#update\" do\n    context \"with guest\" do\n      it \"raises an error\" do\n        put \"/u/guest.json\"\n        expect(response.status).to eq(403)\n      end\n    end\n\n    it \"does not allow name to be updated if auth auth_overrides_name is enabled\" do\n      SiteSetting.auth_overrides_name = true\n\n      sign_in(user1)\n\n      put \"/u/#{user1.username}\", params: { name: \"test.test\" }\n\n      expect(response.status).to eq(200)\n      expect(user1.reload.name).to_not eq(\"test.test\")\n    end\n\n    context \"when username contains a period\" do\n      before { sign_in(user) }\n\n      fab!(:user) { Fabricate(:user, username: \"test.test\", name: \"Test User\") }\n\n      it \"should be able to update a user\" do\n        put \"/u/#{user.username}\", params: { name: \"test.test\" }\n\n        expect(response.status).to eq(200)\n        expect(user.reload.name).to eq(\"test.test\")\n      end\n    end\n\n    context \"as a staff user\" do\n      context \"with uneditable field\" do\n        fab!(:user_field) { Fabricate(:user_field, editable: false) }\n\n        it \"allows staff to edit the field\" do\n          sign_in(admin)\n          put \"/u/#{user.username}.json\",\n              params: {\n                name: \"Jim Tom\",\n                title: \"foobar\",\n                user_fields: {\n                  user_field.id.to_s => \"happy\",\n                },\n              }\n\n          expect(response.status).to eq(200)\n\n          user.reload\n\n          expect(user.user_fields[user_field.id.to_s]).to eq(\"happy\")\n          expect(user.title).to eq(\"foobar\")\n        end\n      end\n    end\n\n    context \"with authenticated user\" do\n      context \"with permission to update\" do\n        fab!(:upload) { Fabricate(:upload) }\n        fab!(:user) { Fabricate(:user) }\n\n        before { sign_in(user) }\n\n        it \"allows the update\" do\n          SiteSetting.tagging_enabled = true\n          user2 = Fabricate(:user)\n          user3 = Fabricate(:user)\n          tags = [Fabricate(:tag), Fabricate(:tag)]\n          tag_synonym = Fabricate(:tag, target_tag: tags[1])\n\n          put \"/u/#{user.username}.json\",\n              params: {\n                name: \"Jim Tom\",\n                muted_usernames: \"#{user2.username},#{user3.username}\",\n                watched_tags: \"#{tags[0].name},#{tag_synonym.name}\",\n                card_background_upload_url: upload.url,\n                profile_background_upload_url: upload.url,\n              }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"user\"][\"watched_tags\"].count).to eq(2)\n\n          user.reload\n\n          expect(user.name).to eq \"Jim Tom\"\n          expect(user.muted_users.pluck(:username).sort).to eq [user2.username, user3.username].sort\n\n          expect(\n            TagUser.where(\n              user: user,\n              notification_level: TagUser.notification_levels[:watching],\n            ).pluck(:tag_id),\n          ).to contain_exactly(tags[0].id, tags[1].id)\n\n          theme = Fabricate(:theme, user_selectable: true)\n\n          put \"/u/#{user.username}.json\",\n              params: {\n                muted_usernames: \"\",\n                theme_ids: [theme.id],\n                email_level: UserOption.email_level_types[:always],\n              }\n\n          user.reload\n\n          expect(user.muted_users.pluck(:username).sort).to be_empty\n          expect(user.user_option.theme_ids).to eq([theme.id])\n          expect(user.user_option.email_level).to eq(UserOption.email_level_types[:always])\n          expect(user.profile_background_upload).to eq(upload)\n          expect(user.card_background_upload).to eq(upload)\n        end\n\n        it \"updates watched tags in everyone tag group\" do\n          SiteSetting.tagging_enabled = true\n          tags = [Fabricate(:tag), Fabricate(:tag)]\n          group =\n            Fabricate(:group, name: \"group\", mentionable_level: Group::ALIAS_LEVELS[:everyone])\n          tag_group = Fabricate(:tag_group, tags: tags)\n          Fabricate(:tag_group_permission, tag_group: tag_group, group: group)\n          tag_synonym = Fabricate(:tag, target_tag: tags[1])\n\n          put \"/u/#{user.username}.json\",\n              params: {\n                watched_tags: \"#{tags[0].name},#{tag_synonym.name}\",\n              }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"user\"][\"watched_tags\"].count).to eq(2)\n        end\n\n        context \"when a locale is chosen that differs from I18n.locale\" do\n          before { SiteSetting.allow_user_locale = true }\n\n          it \"updates the user's locale\" do\n            I18n.locale = :fr\n            put \"/u/#{user.username}.json\", params: { locale: :fa_IR }\n            expect(user.reload.locale).to eq(\"fa_IR\")\n          end\n\n          it \"updates the title\" do\n            BadgeGranter.enable_queue\n            user.update!(locale: :fr)\n            user.change_trust_level!(TrustLevel[4])\n            BadgeGranter.process_queue!\n\n            leader_title = I18n.t(\"badges.leader.name\", locale: :fr)\n            put \"/u/#{user.username}.json\", params: { title: leader_title }\n            expect(user.reload.title).to eq(leader_title)\n          ensure\n            BadgeGranter.disable_queue\n            BadgeGranter.clear_queue!\n          end\n        end\n\n        context \"with user fields\" do\n          context \"with an editable field\" do\n            fab!(:user_field) { Fabricate(:user_field) }\n            fab!(:optional_field) { Fabricate(:user_field, required: false) }\n\n            it \"should update the user field\" do\n              put \"/u/#{user.username}.json\",\n                  params: {\n                    name: \"Jim Tom\",\n                    user_fields: {\n                      user_field.id.to_s => \"happy\",\n                    },\n                  }\n\n              expect(response.status).to eq(200)\n              expect(user.user_fields[user_field.id.to_s]).to eq \"happy\"\n            end\n\n            it \"cannot be updated to blank\" do\n              put \"/u/#{user.username}.json\",\n                  params: {\n                    name: \"Jim Tom\",\n                    user_fields: {\n                      user_field.id.to_s => \"\",\n                    },\n                  }\n\n              expect(response.status).to eq(422)\n              expect(user.user_fields[user_field.id.to_s]).not_to eq(\"happy\")\n            end\n\n            it \"trims excessively large fields\" do\n              put \"/u/#{user.username}.json\",\n                  params: {\n                    name: \"Jim Tom\",\n                    user_fields: {\n                      user_field.id.to_s => (\"x\" * 3000),\n                    },\n                  }\n\n              expect(user.user_fields[user_field.id.to_s].size).to eq(UserField.max_length)\n            end\n\n            it \"should retain existing user fields\" do\n              put \"/u/#{user.username}.json\",\n                  params: {\n                    name: \"Jim Tom\",\n                    user_fields: {\n                      user_field.id.to_s => \"happy\",\n                      optional_field.id.to_s => \"feet\",\n                    },\n                  }\n\n              expect(response.status).to eq(200)\n              expect(user.user_fields[user_field.id.to_s]).to eq(\"happy\")\n              expect(user.user_fields[optional_field.id.to_s]).to eq(\"feet\")\n\n              put \"/u/#{user.username}.json\",\n                  params: {\n                    name: \"Jim Tom\",\n                    user_fields: {\n                      user_field.id.to_s => \"sad\",\n                    },\n                  }\n\n              expect(response.status).to eq(200)\n\n              user.reload\n\n              expect(user.user_fields[user_field.id.to_s]).to eq(\"sad\")\n              expect(user.user_fields[optional_field.id.to_s]).to eq(\"feet\")\n            end\n          end\n\n          context \"with user_notification_schedule attributes\" do\n            it \"updates the user's notification schedule\" do\n              params = {\n                user_notification_schedule: {\n                  enabled: true,\n                  day_0_start_time: 30,\n                  day_0_end_time: 60,\n                  day_1_start_time: 30,\n                  day_1_end_time: 60,\n                  day_2_start_time: 30,\n                  day_2_end_time: 60,\n                  day_3_start_time: 30,\n                  day_3_end_time: 60,\n                  day_4_start_time: 30,\n                  day_4_end_time: 60,\n                  day_5_start_time: 30,\n                  day_5_end_time: 60,\n                  day_6_start_time: 30,\n                  day_6_end_time: 60,\n                },\n              }\n              put \"/u/#{user.username}.json\", params: params\n\n              user.reload\n              expect(user.user_notification_schedule.enabled).to eq(true)\n              expect(user.user_notification_schedule.day_0_start_time).to eq(30)\n              expect(user.user_notification_schedule.day_0_end_time).to eq(60)\n              expect(user.user_notification_schedule.day_6_start_time).to eq(30)\n              expect(user.user_notification_schedule.day_6_end_time).to eq(60)\n            end\n          end\n\n          context \"with uneditable field\" do\n            fab!(:user_field) { Fabricate(:user_field, editable: false) }\n\n            it \"does not update the user field\" do\n              put \"/u/#{user.username}.json\",\n                  params: {\n                    name: \"Jim Tom\",\n                    user_fields: {\n                      user_field.id.to_s => \"happy\",\n                    },\n                  }\n\n              expect(response.status).to eq(200)\n              expect(user.user_fields[user_field.id.to_s]).to be_blank\n            end\n          end\n\n          context \"with custom_field\" do\n            before do\n              plugin = Plugin::Instance.new\n              plugin.register_editable_user_custom_field :test2\n              plugin.register_editable_user_custom_field :test3, staff_only: true\n            end\n\n            after { DiscoursePluginRegistry.reset! }\n\n            it \"only updates allowed user fields\" do\n              put \"/u/#{user.username}.json\",\n                  params: {\n                    custom_fields: {\n                      test1: :hello1,\n                      test2: :hello2,\n                      test3: :hello3,\n                    },\n                  }\n\n              expect(response.status).to eq(200)\n              expect(user.custom_fields[\"test1\"]).to be_blank\n              expect(user.custom_fields[\"test2\"]).to eq(\"hello2\")\n              expect(user.custom_fields[\"test3\"]).to be_blank\n            end\n\n            it \"works alongside a user field\" do\n              user_field = Fabricate(:user_field, editable: true)\n              put \"/u/#{user.username}.json\",\n                  params: {\n                    custom_fields: {\n                      test1: :hello1,\n                      test2: :hello2,\n                      test3: :hello3,\n                    },\n                    user_fields: {\n                      user_field.id.to_s => \"happy\",\n                    },\n                  }\n              expect(response.status).to eq(200)\n              expect(user.custom_fields[\"test1\"]).to be_blank\n              expect(user.custom_fields[\"test2\"]).to eq(\"hello2\")\n              expect(user.custom_fields[\"test3\"]).to eq(nil)\n              expect(user.user_fields[user_field.id.to_s]).to eq(\"happy\")\n            end\n\n            it \"works alongside a user field during creation\" do\n              api_key = Fabricate(:api_key, user: admin)\n              user_field = Fabricate(:user_field, editable: true)\n              post \"/u.json\",\n                   params: {\n                     name: \"Test User\",\n                     username: \"testuser\",\n                     email: \"user@mail.com\",\n                     password: \"supersecure\",\n                     active: true,\n                     custom_fields: {\n                       test2: \"custom field value\",\n                     },\n                     user_fields: {\n                       user_field.id.to_s => \"user field value\",\n                     },\n                   },\n                   headers: {\n                     HTTP_API_KEY: api_key.key,\n                   }\n              expect(response.status).to eq(200)\n              u = User.find_by_email(\"user@mail.com\")\n\n              val = u.custom_fields[\"user_field_#{user_field.id}\"]\n              expect(val).to eq(\"user field value\")\n\n              val = u.custom_fields[\"test2\"]\n              expect(val).to eq(\"custom field value\")\n            end\n\n            it \"is secure when there are no registered editable fields\" do\n              DiscoursePluginRegistry.reset!\n              put \"/u/#{user.username}.json\",\n                  params: {\n                    custom_fields: {\n                      test1: :hello1,\n                      test2: :hello2,\n                      test3: :hello3,\n                    },\n                  }\n              expect(response.status).to eq(200)\n              expect(user.custom_fields[\"test1\"]).to be_blank\n              expect(user.custom_fields[\"test2\"]).to be_blank\n              expect(user.custom_fields[\"test3\"]).to be_blank\n\n              put \"/u/#{user.username}.json\", params: { custom_fields: %w[arrayitem1 arrayitem2] }\n              expect(response.status).to eq(200)\n            end\n\n            it \"allows staff to edit staff-editable fields\" do\n              sign_in(admin)\n              put \"/u/#{user.username}.json\",\n                  params: {\n                    custom_fields: {\n                      test1: :hello1,\n                      test2: :hello2,\n                      test3: :hello3,\n                    },\n                  }\n\n              expect(response.status).to eq(200)\n              expect(user.custom_fields[\"test1\"]).to be_blank\n              expect(user.custom_fields[\"test2\"]).to eq(\"hello2\")\n              expect(user.custom_fields[\"test3\"]).to eq(\"hello3\")\n            end\n          end\n        end\n\n        it \"returns user JSON\" do\n          put \"/u/#{user.username}.json\"\n\n          json = response.parsed_body\n          expect(json[\"user\"][\"id\"]).to eq user.id\n        end\n\n        context \"with sidebar\" do\n          before { SiteSetting.navigation_menu = \"sidebar\" }\n\n          it \"does not remove category or tag sidebar section links when params are not present\" do\n            Fabricate(:category_sidebar_section_link, user: user)\n            Fabricate(:tag_sidebar_section_link, user: user)\n\n            expect do\n              put \"/u/#{user.username}.json\"\n\n              expect(response.status).to eq(200)\n            end.to_not change { user.sidebar_section_links.count }\n          end\n\n          it \"should allow user to remove all category sidebar section links\" do\n            Fabricate(:category_sidebar_section_link, user: user)\n\n            expect do\n              put \"/u/#{user.username}.json\", params: { sidebar_category_ids: nil }\n\n              expect(response.status).to eq(200)\n            end.to change { user.sidebar_section_links.count }.from(1).to(0)\n          end\n\n          it \"should allow user to only modify category sidebar section links for categories they have access to\" do\n            category = Fabricate(:category)\n            group = Fabricate(:group)\n            restricted_category = Fabricate(:private_category, group: group)\n            category_sidebar_section_link = Fabricate(:category_sidebar_section_link, user: user)\n\n            put \"/u/#{user.username}.json\",\n                params: {\n                  sidebar_category_ids: [category.id, restricted_category.id],\n                }\n\n            expect(response.status).to eq(200)\n            expect(user.sidebar_section_links.count).to eq(1)\n            expect(SidebarSectionLink.exists?(id: category_sidebar_section_link.id)).to eq(false)\n\n            sidebar_section_link = user.sidebar_section_links.first\n\n            expect(sidebar_section_link.linkable).to eq(category)\n\n            group.add(user)\n\n            expect do\n              put \"/u/#{user.username}.json\",\n                  params: {\n                    sidebar_category_ids: [category.id, restricted_category.id],\n                  }\n\n              expect(response.status).to eq(200)\n            end.to change { user.sidebar_section_links.count }.from(1).to(2)\n\n            expect(SidebarSectionLink.exists?(user: user, linkable: restricted_category)).to eq(\n              true,\n            )\n          end\n\n          it \"should allow user to remove all tag sidebar section links\" do\n            SiteSetting.tagging_enabled = true\n\n            Fabricate(:tag_sidebar_section_link, user: user)\n\n            expect do\n              put \"/u/#{user.username}.json\", params: { sidebar_tag_names: nil }\n\n              expect(response.status).to eq(200)\n            end.to change { user.sidebar_section_links.count }.from(1).to(0)\n          end\n\n          it \"should not allow user to add tag sidebar section links when tagging is disabled\" do\n            SiteSetting.tagging_enabled = false\n\n            tag = Fabricate(:tag)\n\n            put \"/u/#{user.username}.json\", params: { sidebar_tag_names: [tag.name] }\n\n            expect(response.status).to eq(200)\n            expect(user.reload.sidebar_section_links.count).to eq(0)\n          end\n\n          it \"should allow user to add tag sidebar section links only for tags that are visible to the user\" do\n            SiteSetting.tagging_enabled = true\n\n            tag = Fabricate(:tag)\n            tag_sidebar_section_link = Fabricate(:tag_sidebar_section_link, user: user)\n\n            hidden_tag = Fabricate(:tag)\n            Fabricate(:tag_group, permissions: { \"staff\" => 1 }, tag_names: [hidden_tag.name])\n\n            put \"/u/#{user.username}.json\",\n                params: {\n                  sidebar_tag_names: [tag.name, \"somerandomtag\", hidden_tag.name],\n                }\n\n            expect(response.status).to eq(200)\n            expect(user.sidebar_section_links.count).to eq(1)\n            expect(SidebarSectionLink.exists?(id: tag_sidebar_section_link.id)).to eq(false)\n\n            sidebar_section_link = user.sidebar_section_links.first\n\n            expect(sidebar_section_link.linkable).to eq(tag)\n\n            user.update!(admin: true)\n\n            expect do\n              put \"/u/#{user.username}.json\",\n                  params: {\n                    sidebar_tag_names: [tag.name, \"somerandomtag\", hidden_tag.name],\n                  }\n\n              expect(response.status).to eq(200)\n            end.to change { user.sidebar_section_links.count }.from(1).to(2)\n\n            expect(SidebarSectionLink.exists?(user: user, linkable: hidden_tag)).to eq(true)\n          end\n        end\n      end\n\n      context \"without permission to update\" do\n        it \"does not allow the update\" do\n          user = Fabricate(:user, name: \"Billy Bob\")\n          sign_in(Fabricate(:user))\n\n          put \"/u/#{user.username}.json\", params: { name: \"Jim Tom\" }\n\n          expect(response).to be_forbidden\n          expect(user.reload.name).not_to eq \"Jim Tom\"\n        end\n      end\n    end\n\n    context \"with external_ids\" do\n      fab!(:api_key, refind: false) { Fabricate(:api_key, user: admin) }\n\n      let(:plugin_auth_provider) do\n        authenticator_class =\n          Class.new(Auth::ManagedAuthenticator) do\n            def name\n              \"pluginauth\"\n            end\n\n            def enabled?\n              true\n            end\n          end\n\n        provider = Auth::AuthProvider.new\n        provider.authenticator = authenticator_class.new\n        provider\n      end\n\n      before do\n        DiscoursePluginRegistry.register_auth_provider(plugin_auth_provider)\n        SiteSetting.discourse_connect_url = \"http://localhost\"\n        SiteSetting.enable_discourse_connect = true\n      end\n\n      after { DiscoursePluginRegistry.reset! }\n\n      it \"can create UserAssociatedAccount records\" do\n        params = { external_ids: { \"pluginauth\" => \"pluginauth_uid\" } }\n\n        expect {\n          put \"/u/#{user.username}.json\", params: params, headers: { HTTP_API_KEY: api_key.key }\n        }.to change { UserAssociatedAccount.count }.by(1)\n\n        expect(response.status).to eq(200)\n\n        user_associated_account = UserAssociatedAccount.last\n        expect(user.reload.user_associated_account_ids).to contain_exactly(\n          user_associated_account.id,\n        )\n        expect(user_associated_account.provider_name).to eq(\"pluginauth\")\n        expect(user_associated_account.provider_uid).to eq(\"pluginauth_uid\")\n        expect(user_associated_account.user_id).to eq(user.id)\n      end\n\n      it \"can destroy UserAssociatedAccount records\" do\n        user.user_associated_accounts.create!(\n          provider_name: \"pluginauth\",\n          provider_uid: \"pluginauth_uid\",\n        )\n\n        params = { external_ids: { \"pluginauth\" => nil } }\n\n        expect {\n          put \"/u/#{user.username}.json\", params: params, headers: { HTTP_API_KEY: api_key.key }\n        }.to change { UserAssociatedAccount.count }.by(-1)\n\n        expect(response.status).to eq(200)\n        expect(user.reload.user_associated_account_ids).to be_blank\n      end\n\n      it \"can create SingleSignOnRecord records\" do\n        params = { external_ids: { discourse_connect: \"discourse_connect_uid\" } }\n\n        expect {\n          put \"/u/#{user.username}.json\", params: params, headers: { HTTP_API_KEY: api_key.key }\n        }.to change { SingleSignOnRecord.count }.by(1)\n\n        expect(response.status).to eq(200)\n\n        single_sign_on_record = SingleSignOnRecord.last\n        expect(user.reload.single_sign_on_record).to eq(single_sign_on_record)\n        expect(single_sign_on_record.external_id).to eq(\"discourse_connect_uid\")\n      end\n\n      it \"can update SingleSignOnRecord records\" do\n        user = Fabricate(:user)\n        SingleSignOnRecord.create!(\n          user_id: user.id,\n          external_id: \"discourse_connect_uid\",\n          last_payload: \"discourse_connect_uid\",\n        )\n\n        params = { external_ids: { discourse_connect: \"discourse_connect_uid_2\" } }\n\n        expect {\n          put \"/u/#{user.username}.json\", params: params, headers: { HTTP_API_KEY: api_key.key }\n        }.not_to change { SingleSignOnRecord.count }\n\n        expect(response.status).to eq(200)\n        expect(user.reload.single_sign_on_record.external_id).to eq(\"discourse_connect_uid_2\")\n      end\n\n      it \"can delete SingleSignOnRecord records\" do\n        user = Fabricate(:user)\n        SingleSignOnRecord.create!(\n          user_id: user.id,\n          external_id: \"discourse_connect_uid\",\n          last_payload: \"discourse_connect_uid\",\n        )\n\n        params = { external_ids: { discourse_connect: nil } }\n\n        expect {\n          put \"/u/#{user.username}.json\", params: params, headers: { HTTP_API_KEY: api_key.key }\n        }.to change { SingleSignOnRecord.count }.by(-1)\n\n        expect(response.status).to eq(200)\n        expect(user.reload.single_sign_on_record).to be_blank\n      end\n\n      it \"can update SingleSignOnRecord and UserAssociatedAccount records in a single call\" do\n        user = Fabricate(:user)\n        user.user_associated_accounts.create!(\n          provider_name: \"pluginauth\",\n          provider_uid: \"pluginauth_uid\",\n        )\n        SingleSignOnRecord.create!(\n          user_id: user.id,\n          external_id: \"discourse_connect_uid\",\n          last_payload: \"discourse_connect_uid\",\n        )\n\n        params = {\n          external_ids: {\n            discourse_connect: \"discourse_connect_uid_2\",\n            pluginauth: \"pluginauth_uid_2\",\n          },\n        }\n\n        expect {\n          put \"/u/#{user.username}.json\", params: params, headers: { HTTP_API_KEY: api_key.key }\n        }.to change { SingleSignOnRecord.count + UserAssociatedAccount.count }.by(0)\n\n        expect(response.status).to eq(200)\n        expect(user.reload.single_sign_on_record.external_id).to eq(\"discourse_connect_uid_2\")\n        user_associated_account = UserAssociatedAccount.last\n        expect(user.reload.user_associated_account_ids).to contain_exactly(\n          user_associated_account.id,\n        )\n        expect(user_associated_account.provider_name).to eq(\"pluginauth\")\n        expect(user_associated_account.provider_uid).to eq(\"pluginauth_uid_2\")\n        expect(user_associated_account.user_id).to eq(user.id)\n      end\n\n      it \"returns error if external ID provider does not exist\" do\n        params = { external_ids: { \"pluginauth2\" => \"pluginauth_uid\" } }\n\n        put \"/u/#{user.username}.json\", params: params, headers: { HTTP_API_KEY: api_key.key }\n        expect(response.status).to eq(400)\n      end\n    end\n\n    context \"with user status\" do\n      context \"as a regular user\" do\n        before do\n          SiteSetting.enable_user_status = true\n          sign_in(user)\n        end\n\n        it \"sets user status\" do\n          status = { emoji: \"tooth\", description: \"off to dentist\" }\n\n          put \"/u/#{user.username}.json\", params: { status: status }\n          expect(response.status).to eq(200)\n\n          user.reload\n          expect(user.user_status).not_to be_nil\n          expect(user.user_status.emoji).to eq(status[:emoji])\n          expect(user.user_status.description).to eq(status[:description])\n        end\n\n        it \"updates user status\" do\n          user.set_status!(\"off to dentist\", \"tooth\")\n          user.reload\n\n          new_status = { emoji: \"surfing_man\", description: \"surfing\" }\n          put \"/u/#{user.username}.json\", params: { status: new_status }\n          expect(response.status).to eq(200)\n\n          user.reload\n          expect(user.user_status).not_to be_nil\n          expect(user.user_status.emoji).to eq(new_status[:emoji])\n          expect(user.user_status.description).to eq(new_status[:description])\n        end\n\n        it \"clears user status\" do\n          user.set_status!(\"off to dentist\", \"tooth\")\n          user.reload\n\n          put \"/u/#{user.username}.json\", params: { status: nil }\n          expect(response.status).to eq(200)\n\n          user.reload\n          expect(user.user_status).to be_nil\n        end\n\n        it \"can't set status of another user\" do\n          put \"/u/#{user1.username}.json\",\n              params: {\n                status: {\n                  emoji: \"tooth\",\n                  description: \"off to dentist\",\n                },\n              }\n          expect(response.status).to eq(403)\n\n          user1.reload\n          expect(user1.user_status).to be_nil\n        end\n\n        it \"can't update status of another user\" do\n          old_status = { emoji: \"tooth\", description: \"off to dentist\" }\n          user1.set_status!(old_status[:description], old_status[:emoji])\n          user1.reload\n\n          new_status = { emoji: \"surfing_man\", description: \"surfing\" }\n          put \"/u/#{user1.username}.json\", params: { status: new_status }\n          expect(response.status).to eq(403)\n\n          user1.reload\n          expect(user1.user_status).not_to be_nil\n          expect(user1.user_status.emoji).to eq(old_status[:emoji])\n          expect(user1.user_status.description).to eq(old_status[:description])\n        end\n\n        it \"can't clear status of another user\" do\n          user1.set_status!(\"off to dentist\", \"tooth\")\n          user1.reload\n\n          put \"/u/#{user1.username}.json\", params: { status: nil }\n          expect(response.status).to eq(403)\n\n          user1.reload\n          expect(user1.user_status).not_to be_nil\n        end\n\n        it \"doesn't clear user status if it wasn't sent in the payload\" do\n          new_status = { emoji: \"tooth\", description: \"off to dentist\" }\n          user.set_status!(new_status[:description], new_status[:emoji])\n          user.reload\n\n          put \"/u/#{user.username}.json\", params: { bio_raw: \"new bio\" }\n          expect(response.status).to eq(200)\n\n          user.reload\n          expect(user.user_status).not_to be_nil\n          expect(user.user_status.emoji).to eq(new_status[:emoji])\n          expect(user.user_status.description).to eq(new_status[:description])\n        end\n\n        context \"when user status is disabled\" do\n          before { SiteSetting.enable_user_status = false }\n\n          it \"doesn't set user status\" do\n            put \"/u/#{user.username}.json\",\n                params: {\n                  status: {\n                    emoji: \"tooth\",\n                    description: \"off to dentist\",\n                  },\n                }\n            expect(response.status).to eq(200)\n\n            user.reload\n            expect(user.user_status).to be_nil\n          end\n\n          it \"doesn't update user status\" do\n            old_status = { emoji: \"tooth\", description: \"off to dentist\" }\n            user.set_status!(old_status[:description], old_status[:emoji])\n            user.reload\n\n            new_status = { emoji: \"surfing_man\", description: \"surfing\" }\n            put \"/u/#{user.username}.json\", params: { status: new_status }\n            expect(response.status).to eq(200)\n\n            user.reload\n            expect(user.user_status).not_to be_nil\n            expect(user.user_status.emoji).to eq(old_status[:emoji])\n            expect(user.user_status.description).to eq(old_status[:description])\n          end\n\n          it \"doesn't clear user status\" do\n            user.set_status!(\"off to dentist\", \"tooth\")\n            user.reload\n\n            put \"/u/#{user.username}.json\", params: { status: nil }\n            expect(response.status).to eq(200)\n\n            user.reload\n            expect(user.user_status).not_to be_nil\n          end\n        end\n      end\n\n      context \"as a staff user\" do\n        before do\n          SiteSetting.enable_user_status = true\n          sign_in(moderator)\n        end\n\n        it \"sets another user's status\" do\n          status = { emoji: \"tooth\", description: \"off to dentist\" }\n\n          put \"/u/#{user.username}.json\", params: { status: status }\n          expect(response.status).to eq(200)\n\n          user.reload\n          expect(user.user_status).not_to be_nil\n          expect(user.user_status.emoji).to eq(status[:emoji])\n          expect(user.user_status.description).to eq(status[:description])\n        end\n\n        it \"updates another user's status\" do\n          user.set_status!(\"off to dentist\", \"tooth\")\n          user.reload\n\n          new_status = { emoji: \"surfing_man\", description: \"surfing\" }\n          put \"/u/#{user.username}.json\", params: { status: new_status }\n          expect(response.status).to eq(200)\n\n          user.reload\n          expect(user.user_status).not_to be_nil\n          expect(user.user_status.emoji).to eq(new_status[:emoji])\n          expect(user.user_status.description).to eq(new_status[:description])\n        end\n\n        it \"clears another user's status\" do\n          user.set_status!(\"off to dentist\", \"tooth\")\n          user.reload\n\n          put \"/u/#{user.username}.json\", params: { status: nil }\n          expect(response.status).to eq(200)\n\n          user.reload\n          expect(user.user_status).to be_nil\n        end\n      end\n    end\n\n    context \"when a plugin introduces a users_controller_update_user_params modifier\" do\n      before { sign_in(user) }\n\n      after { DiscoursePluginRegistry.clear_modifiers! }\n\n      it \"allows the plugin to modify the user params\" do\n        block_called = false\n\n        plugin = Plugin::Instance.new\n        plugin.register_modifier(\n          :users_controller_update_user_params,\n        ) do |result, current_user, params|\n          block_called = true\n          expect(current_user.id).to eq(user.id)\n          result[:location] = params[:plugin_location_alias]\n          result\n        end\n\n        put \"/u/#{user.username}.json\", params: { location: \"abc\", plugin_location_alias: \"xyz\" }\n\n        expect(response.status).to eq(200)\n        expect(user.reload.user_profile.location).to eq(\"xyz\")\n        expect(block_called).to eq(true)\n      end\n    end\n  end\n\n  describe \"#badge_title\" do\n    fab!(:badge) { Fabricate(:badge) }\n    let(:user_badge) { BadgeGranter.grant(badge, user1) }\n\n    it \"sets the user's title to the badge name if it is titleable\" do\n      sign_in(user1)\n\n      put \"/u/#{user1.username}/preferences/badge_title.json\",\n          params: {\n            user_badge_id: user_badge.id,\n          }\n\n      expect(user1.reload.title).not_to eq(badge.display_name)\n      badge.update allow_title: true\n\n      put \"/u/#{user1.username}/preferences/badge_title.json\",\n          params: {\n            user_badge_id: user_badge.id,\n          }\n\n      expect(user1.reload.title).to eq(badge.display_name)\n      expect(user1.user_profile.granted_title_badge_id).to eq(badge.id)\n\n      badge.update allow_title: false\n\n      put \"/u/#{user1.username}/preferences/badge_title.json\",\n          params: {\n            user_badge_id: user_badge.id,\n          }\n\n      user1.reload\n      user1.user_profile.reload\n      expect(user1.title).to eq(\"\")\n      expect(user1.user_profile.granted_title_badge_id).to eq(nil)\n    end\n\n    it \"is not raising an erroring when user revokes title\" do\n      sign_in(user1)\n      badge.update allow_title: true\n      put \"/u/#{user1.username}/preferences/badge_title.json\",\n          params: {\n            user_badge_id: user_badge.id,\n          }\n      put \"/u/#{user1.username}/preferences/badge_title.json\", params: { user_badge_id: 0 }\n      expect(response.status).to eq(200)\n    end\n\n    context \"with overridden name\" do\n      fab!(:badge) { Fabricate(:badge, name: \"Demogorgon\", allow_title: true) }\n      let(:user_badge) { BadgeGranter.grant(badge, user1) }\n\n      before { TranslationOverride.upsert!(\"en\", \"badges.demogorgon.name\", \"Boss\") }\n\n      after { TranslationOverride.revert!(\"en\", [\"badges.demogorgon.name\"]) }\n\n      it \"uses the badge display name as user title\" do\n        sign_in(user1)\n\n        put \"/u/#{user1.username}/preferences/badge_title.json\",\n            params: {\n              user_badge_id: user_badge.id,\n            }\n        expect(user1.reload.title).to eq(badge.display_name)\n      end\n    end\n  end\n\n  describe \"#send_activation_email\" do\n    before do\n      UsersController.any_instance.stubs(:honeypot_value).returns(nil)\n      UsersController.any_instance.stubs(:challenge_value).returns(nil)\n    end\n\n    let(:post_user) do\n      post \"/u.json\",\n           params: {\n             username: \"osamatest\",\n             password: \"strongpassword\",\n             email: \"dsdsds@sasa.com\",\n           }\n\n      User.find_by(username: \"osamatest\")\n    end\n\n    context \"for an existing user\" do\n      context \"for an activated account with email confirmed\" do\n        it \"fails\" do\n          user = post_user\n          email_token = Fabricate(:email_token, user: user).token\n          EmailToken.confirm(email_token)\n\n          post \"/u/action/send_activation_email.json\", params: { username: user.username }\n\n          expect(response.status).to eq(409)\n          expect(response.parsed_body[\"errors\"]).to include(I18n.t(\"activation.activated\"))\n          expect(session[SessionController::ACTIVATE_USER_KEY]).to eq(nil)\n        end\n      end\n\n      context \"for an activated account with unconfirmed email\" do\n        it \"should send an email\" do\n          user = post_user\n          user.update!(active: true)\n          Fabricate(:email_token, user: user)\n\n          expect_enqueued_with(\n            job: :critical_user_email,\n            args: {\n              type: :signup,\n              to_address: user.email,\n            },\n          ) { post \"/u/action/send_activation_email.json\", params: { username: user.username } }\n\n          expect(response.status).to eq(200)\n\n          expect(session[SessionController::ACTIVATE_USER_KEY]).to eq(nil)\n        end\n      end\n\n      context \"when approval is enabled\" do\n        before { SiteSetting.must_approve_users = true }\n\n        it \"should raise an error\" do\n          user = post_user\n          user.update(active: true)\n          user.save!\n          Fabricate(:email_token, user: user1)\n          post \"/u/action/send_activation_email.json\", params: { username: user.username }\n\n          expect(response.status).to eq(403)\n        end\n      end\n\n      describe \"when user does not have a valid session\" do\n        it \"should not be valid\" do\n          post \"/u/action/send_activation_email.json\", params: { username: user.username }\n          expect(response.status).to eq(403)\n        end\n\n        it \"should allow staff regardless\" do\n          sign_in(admin)\n          user = Fabricate(:user, active: false)\n          post \"/u/action/send_activation_email.json\", params: { username: user.username }\n          expect(response.status).to eq(200)\n        end\n      end\n\n      context \"with a valid email_token\" do\n        it \"should send the activation email\" do\n          user = post_user\n\n          expect_enqueued_with(job: :critical_user_email, args: { type: :signup }) do\n            post \"/u/action/send_activation_email.json\", params: { username: user.username }\n          end\n\n          expect(response.status).to eq(200)\n          expect(session[SessionController::ACTIVATE_USER_KEY]).to eq(nil)\n        end\n      end\n\n      context \"without an existing email_token\" do\n        let(:user) { post_user }\n        before do\n          user.email_tokens.each { |t| t.destroy }\n          user.reload\n        end\n\n        it \"should generate a new token\" do\n          expect {\n            post \"/u/action/send_activation_email.json\", params: { username: user.username }\n          }.to change { user.reload.email_tokens.count }.by(1)\n        end\n\n        it \"should send an email\" do\n          expect do\n            post \"/u/action/send_activation_email.json\", params: { username: user.username }\n          end.to change { Jobs::CriticalUserEmail.jobs.size }.by(1)\n\n          expect(session[SessionController::ACTIVATE_USER_KEY]).to eq(nil)\n        end\n      end\n    end\n\n    context \"when username does not exist\" do\n      it \"should not send an email\" do\n        post \"/u/action/send_activation_email.json\", params: { username: \"nopenopenopenope\" }\n        expect(response.status).to eq(404)\n        expect(Jobs::CriticalUserEmail.jobs.size).to eq(0)\n      end\n    end\n  end\n\n  describe \"#pick_avatar\" do\n    it \"raises an error when not logged in\" do\n      put \"/u/asdf/preferences/avatar/pick.json\", params: { avatar_id: 1, type: \"custom\" }\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      before { sign_in(user1) }\n\n      fab!(:upload) { Fabricate(:upload, user: user1) }\n\n      it \"raises an error when you don't have permission to toggle the avatar\" do\n        put \"/u/#{another_user.username}/preferences/avatar/pick.json\",\n            params: {\n              upload_id: upload.id,\n              type: \"custom\",\n            }\n\n        expect(response).to be_forbidden\n      end\n\n      it \"raises an error when discourse_connect_overrides_avatar is disabled\" do\n        SiteSetting.discourse_connect_overrides_avatar = true\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\",\n            params: {\n              upload_id: upload.id,\n              type: \"custom\",\n            }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"raises an error when selecting the custom/uploaded avatar and allow_uploaded_avatars is disabled\" do\n        SiteSetting.allow_uploaded_avatars = \"disabled\"\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\",\n            params: {\n              upload_id: upload.id,\n              type: \"custom\",\n            }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"raises an error when selecting the custom/uploaded avatar and allow_uploaded_avatars is admin\" do\n        SiteSetting.allow_uploaded_avatars = \"admin\"\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\",\n            params: {\n              upload_id: upload.id,\n              type: \"custom\",\n            }\n        expect(response.status).to eq(422)\n\n        user1.update!(admin: true)\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\",\n            params: {\n              upload_id: upload.id,\n              type: \"custom\",\n            }\n        expect(response.status).to eq(200)\n      end\n\n      it \"raises an error when selecting the custom/uploaded avatar and allow_uploaded_avatars is staff\" do\n        SiteSetting.allow_uploaded_avatars = \"staff\"\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\",\n            params: {\n              upload_id: upload.id,\n              type: \"custom\",\n            }\n        expect(response.status).to eq(422)\n\n        user1.update!(moderator: true)\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\",\n            params: {\n              upload_id: upload.id,\n              type: \"custom\",\n            }\n        expect(response.status).to eq(200)\n      end\n\n      it \"raises an error when selecting the custom/uploaded avatar and allow_uploaded_avatars is a trust level\" do\n        SiteSetting.allow_uploaded_avatars = \"3\"\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\",\n            params: {\n              upload_id: upload.id,\n              type: \"custom\",\n            }\n        expect(response.status).to eq(422)\n\n        user1.update!(trust_level: 3)\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\",\n            params: {\n              upload_id: upload.id,\n              type: \"custom\",\n            }\n        expect(response.status).to eq(200)\n      end\n\n      it \"ignores the upload if picking a system avatar\" do\n        SiteSetting.allow_uploaded_avatars = \"disabled\"\n        another_upload = Fabricate(:upload)\n\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\",\n            params: {\n              upload_id: another_upload.id,\n              type: \"system\",\n            }\n\n        expect(response.status).to eq(200)\n        expect(user1.reload.uploaded_avatar_id).to eq(nil)\n      end\n\n      it \"raises an error if the type is invalid\" do\n        SiteSetting.allow_uploaded_avatars = \"disabled\"\n        another_upload = Fabricate(:upload)\n\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\",\n            params: {\n              upload_id: another_upload.id,\n              type: \"x\",\n            }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"can successfully pick the system avatar\" do\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\"\n\n        expect(response.status).to eq(200)\n        expect(user1.reload.uploaded_avatar_id).to eq(nil)\n      end\n\n      it \"disables the use_site_small_logo_as_system_avatar setting when picking an avatar for the system user\" do\n        system_user = Discourse.system_user\n        SiteSetting.use_site_small_logo_as_system_avatar = true\n        another_upload = Fabricate(:upload, user: system_user)\n        sign_in(system_user)\n\n        put \"/u/#{system_user.username}/preferences/avatar/pick.json\",\n            params: {\n              upload_id: another_upload.id,\n              type: \"uploaded\",\n            }\n\n        expect(response.status).to eq(200)\n        expect(SiteSetting.use_site_small_logo_as_system_avatar).to eq(false)\n      end\n\n      it \"can successfully pick a gravatar\" do\n        user1.user_avatar.update_columns(gravatar_upload_id: upload.id)\n\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\",\n            params: {\n              upload_id: upload.id,\n              type: \"gravatar\",\n            }\n\n        expect(response.status).to eq(200)\n        expect(user1.reload.uploaded_avatar_id).to eq(upload.id)\n        expect(user1.user_avatar.reload.gravatar_upload_id).to eq(upload.id)\n      end\n\n      it \"can not pick uploads that were not created by user\" do\n        upload2 = Fabricate(:upload)\n\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\",\n            params: {\n              upload_id: upload2.id,\n              type: \"custom\",\n            }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"can successfully pick a custom avatar\" do\n        events =\n          DiscourseEvent.track_events do\n            put \"/u/#{user1.username}/preferences/avatar/pick.json\",\n                params: {\n                  upload_id: upload.id,\n                  type: \"custom\",\n                }\n          end\n\n        expect(events.map { |event| event[:event_name] }).to include(:user_updated)\n        expect(response.status).to eq(200)\n        expect(user1.reload.uploaded_avatar_id).to eq(upload.id)\n        expect(user1.user_avatar.reload.custom_upload_id).to eq(upload.id)\n      end\n    end\n  end\n\n  describe \"#select_avatar\" do\n    it \"raises an error when not logged in\" do\n      put \"/u/asdf/preferences/avatar/select.json\", params: { url: \"https://meta.discourse.org\" }\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      before { sign_in(user1) }\n\n      fab!(:avatar1) { Fabricate(:upload) }\n      fab!(:avatar2) { Fabricate(:upload) }\n      let(:url) { \"https://www.discourse.org\" }\n\n      it \"raises an error when url is blank\" do\n        put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: \"\" }\n        expect(response.status).to eq(422)\n      end\n\n      it \"raises an error when selectable avatars is disabled\" do\n        put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: url }\n        expect(response.status).to eq(422)\n      end\n\n      context \"when selectable avatars is enabled\" do\n        before do\n          SiteSetting.selectable_avatars = [avatar1, avatar2]\n          SiteSetting.selectable_avatars_mode = \"no_one\"\n        end\n\n        it \"raises an error when selectable avatars is empty\" do\n          SiteSetting.selectable_avatars = \"\"\n          put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: url }\n          expect(response.status).to eq(422)\n        end\n\n        context \"when selectable avatars is properly setup\" do\n          it \"raises an error when url is not in selectable avatars list\" do\n            put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: url }\n            expect(response.status).to eq(422)\n          end\n\n          it \"can successfully select an avatar\" do\n            events =\n              DiscourseEvent.track_events do\n                put \"/u/#{user1.username}/preferences/avatar/select.json\",\n                    params: {\n                      url: avatar1.url,\n                    }\n              end\n\n            expect(events.map { |event| event[:event_name] }).to include(:user_updated)\n            expect(response.status).to eq(200)\n            expect(user1.reload.uploaded_avatar_id).to eq(avatar1.id)\n            expect(user1.user_avatar.reload.custom_upload_id).to eq(avatar1.id)\n          end\n\n          it \"can successfully select an avatar using a cooked URL\" do\n            events =\n              DiscourseEvent.track_events do\n                put \"/u/#{user1.username}/preferences/avatar/select.json\",\n                    params: {\n                      url: UrlHelper.cook_url(avatar1.url),\n                    }\n              end\n\n            expect(events.map { |event| event[:event_name] }).to include(:user_updated)\n            expect(response.status).to eq(200)\n            expect(user1.reload.uploaded_avatar_id).to eq(avatar1.id)\n            expect(user1.user_avatar.reload.custom_upload_id).to eq(avatar1.id)\n          end\n\n          it \"disables the use_site_small_logo_as_system_avatar setting when picking an avatar for the system user\" do\n            system_user = Discourse.system_user\n            SiteSetting.use_site_small_logo_as_system_avatar = true\n            sign_in(system_user)\n\n            put \"/u/#{system_user.username}/preferences/avatar/select.json\",\n                params: {\n                  url: UrlHelper.cook_url(avatar1.url),\n                }\n\n            expect(response.status).to eq(200)\n            expect(SiteSetting.use_site_small_logo_as_system_avatar).to eq(false)\n          end\n        end\n      end\n    end\n  end\n\n  describe \"#destroy_user_image\" do\n    it \"raises an error when not logged in\" do\n      delete \"/u/asdf/preferences/user_image.json\", params: { type: \"profile_background\" }\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      before { sign_in(user1) }\n\n      it 'raises an error when you don\\'t have permission to clear the profile background' do\n        delete \"/u/#{another_user.username}/preferences/user_image.json\",\n               params: {\n                 type: \"profile_background\",\n               }\n        expect(response).to be_forbidden\n      end\n\n      it \"requires the `type` param\" do\n        delete \"/u/#{user1.username}/preferences/user_image.json\"\n        expect(response.status).to eq(400)\n      end\n\n      it \"only allows certain `types`\" do\n        delete \"/u/#{user1.username}/preferences/user_image.json\", params: { type: \"wat\" }\n        expect(response.status).to eq(400)\n      end\n\n      it \"can clear the profile background\" do\n        delete \"/u/#{user1.username}/preferences/user_image.json\",\n               params: {\n                 type: \"profile_background\",\n               }\n\n        expect(user1.reload.profile_background_upload).to eq(nil)\n        expect(response.status).to eq(200)\n      end\n    end\n  end\n\n  describe \"#destroy\" do\n    it \"raises an error when not logged in\" do\n      delete \"/u/nobody.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      before { sign_in(user1) }\n\n      it \"raises an error when you cannot delete your account\" do\n        UserDestroyer.any_instance.expects(:destroy).never\n        stat = user1.user_stat\n        stat.post_count = 3\n        stat.save!\n        delete \"/u/#{user1.username}.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"raises an error when you try to delete someone else's account\" do\n        UserDestroyer.any_instance.expects(:destroy).never\n        delete \"/u/#{another_user.username}.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"deletes your account when you're allowed to\" do\n        UserDestroyer.any_instance.expects(:destroy).with(user1, anything).returns(user1)\n        delete \"/u/#{user1.username}.json\"\n        expect(response.status).to eq(200)\n      end\n    end\n  end\n\n  describe \"#notification_level\" do\n    it \"raises an error when `notification_level` param is not a valid value\" do\n      sign_in(user)\n      invalid_arg = \"invalid\"\n      put \"/u/#{user.username}/notification_level.json\", params: { notification_level: invalid_arg }\n      expect(response.status).to eq(422)\n      expect(response.parsed_body[\"errors\"].first).to eq(\n        I18n.t(\"notification_level.invalid_value\", value: invalid_arg),\n      )\n    end\n  end\n\n  describe \"#ignore\" do\n    it \"raises an error when not logged in\" do\n      put \"/u/#{user1.username}/notification_level.json\", params: { notification_level: \"\" }\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      fab!(:user) { Fabricate(:user, trust_level: 2) }\n      before { sign_in(user) }\n\n      fab!(:ignored_user) { Fabricate(:ignored_user, user: user, ignored_user: another_user) }\n      fab!(:muted_user) { Fabricate(:muted_user, user: user, muted_user: another_user) }\n\n      context \"when you can't change the notification\" do\n        fab!(:staff_user) { admin }\n\n        it \"ignoring includes a helpful error message\" do\n          put \"/u/#{staff_user.username}/notification_level.json\",\n              params: {\n                notification_level: \"ignore\",\n              }\n          expect(response.status).to eq(422)\n          expect(response.parsed_body[\"errors\"][0]).to eq(I18n.t(\"notification_level.ignore_error\"))\n        end\n\n        it \"muting includes a helpful error message\" do\n          put \"/u/#{staff_user.username}/notification_level.json\",\n              params: {\n                notification_level: \"mute\",\n              }\n          expect(response.status).to eq(422)\n          expect(response.parsed_body[\"errors\"][0]).to eq(I18n.t(\"notification_level.mute_error\"))\n        end\n      end\n\n      context \"when changing notification level to normal\" do\n        it \"changes notification level to normal\" do\n          put \"/u/#{another_user.username}/notification_level.json\",\n              params: {\n                notification_level: \"normal\",\n              }\n          expect(IgnoredUser.count).to eq(0)\n          expect(MutedUser.count).to eq(0)\n        end\n      end\n\n      context \"when changing notification level to mute\" do\n        it \"changes notification level to mute\" do\n          put \"/u/#{another_user.username}/notification_level.json\",\n              params: {\n                notification_level: \"mute\",\n              }\n          expect(IgnoredUser.count).to eq(0)\n          expect(MutedUser.find_by(user_id: user.id, muted_user_id: another_user.id)).to be_present\n        end\n      end\n\n      context \"when changing notification level to ignore\" do\n        it \"changes notification level to ignore\" do\n          put \"/u/#{another_user.username}/notification_level.json\",\n              params: {\n                notification_level: \"ignore\",\n                expiring_at: 3.days.from_now,\n              }\n          expect(response.status).to eq(200)\n          expect(MutedUser.count).to eq(0)\n          expect(\n            IgnoredUser.find_by(user_id: user.id, ignored_user_id: another_user.id),\n          ).to be_present\n        end\n\n        it \"allows admin to change the ignore status for a source user\" do\n          ignored_user.destroy!\n          sign_in(Fabricate(:user, admin: true))\n          put \"/u/#{another_user.username}/notification_level.json\",\n              params: {\n                notification_level: \"ignore\",\n                acting_user_id: user.id,\n                expiring_at: 3.days.from_now,\n              }\n          expect(response.status).to eq(200)\n          expect(\n            IgnoredUser.find_by(user_id: user.id, ignored_user_id: another_user.id),\n          ).to be_present\n        end\n\n        it \"does not allow a regular user to change the ignore status for anyone but themself\" do\n          ignored_user.destroy!\n          acting_user = Fabricate(:user)\n          put \"/u/#{another_user.username}/notification_level.json\",\n              params: {\n                notification_level: \"ignore\",\n                acting_user_id: acting_user.id,\n                expiring_at: 3.days.from_now,\n              }\n          expect(response.status).to eq(422)\n          expect(\n            IgnoredUser.find_by(user_id: acting_user.id, ignored_user_id: another_user.id),\n          ).to eq(nil)\n\n          put \"/u/#{another_user.username}/notification_level.json\",\n              params: {\n                notification_level: \"ignore\",\n                expiring_at: 3.days.from_now,\n              }\n          expect(response.status).to eq(200)\n          expect(\n            IgnoredUser.find_by(user_id: user.id, ignored_user_id: another_user.id),\n          ).to be_present\n        end\n\n        context \"when expiring_at param is set\" do\n          it \"changes notification level to ignore\" do\n            freeze_time(Time.now) do\n              expiring_at = 3.days.from_now\n              put \"/u/#{another_user.username}/notification_level.json\",\n                  params: {\n                    notification_level: \"ignore\",\n                    expiring_at: expiring_at,\n                  }\n\n              ignored_user = IgnoredUser.find_by(user_id: user.id, ignored_user_id: another_user.id)\n              expect(ignored_user).to be_present\n              expect(ignored_user.expiring_at.to_i).to eq(expiring_at.to_i)\n              expect(MutedUser.count).to eq(0)\n            end\n          end\n        end\n      end\n    end\n  end\n\n  describe \"for user with period in username\" do\n    fab!(:user_with_period) { Fabricate(:user, username: \"myname.test\") }\n\n    it \"still works\" do\n      sign_in(user_with_period)\n      UserDestroyer\n        .any_instance\n        .expects(:destroy)\n        .with(user_with_period, anything)\n        .returns(user_with_period)\n      delete \"/u/#{user_with_period.username}\", xhr: true\n      expect(response.status).to eq(200)\n    end\n  end\n\n  describe \"#my_redirect\" do\n    it \"redirects if the user is not logged in\" do\n      get \"/my/wat\"\n      expect(response).to redirect_to(\"/login-preferences\")\n      expect(response.cookies).to have_key(\"destination_url\")\n      expect(response.cookies[\"destination_url\"]).to eq(\"/my/wat\")\n      expect(response.headers[\"X-Robots-Tag\"]).to eq(\"noindex\")\n    end\n\n    context \"when the user is logged in\" do\n      before { sign_in(user1) }\n\n      it \"will not redirect to an invalid path\" do\n        get \"/my/wat/..password.txt\"\n        expect(response).not_to be_redirect\n      end\n\n      it \"will redirect to an valid path\" do\n        get \"/my/preferences\"\n        expect(response).to redirect_to(\"/u/#{user1.username}/preferences\")\n      end\n\n      it \"permits forward slashes\" do\n        get \"/my/activity/posts\"\n        expect(response).to redirect_to(\"/u/#{user1.username}/activity/posts\")\n      end\n\n      it \"correctly redirects for Unicode usernames\" do\n        SiteSetting.unicode_usernames = true\n        user = sign_in(Fabricate(:unicode_user))\n\n        get \"/my/preferences\"\n        expect(response).to redirect_to(\"/u/#{user.encoded_username}/preferences\")\n      end\n    end\n  end\n\n  describe \"#check_emails\" do\n    it \"raises an error when not logged in\" do\n      get \"/u/zogstrip/emails.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      let(:sign_in_admin) { sign_in(admin) }\n\n      it \"raises an error when you aren't allowed to check emails\" do\n        sign_in(Fabricate(:user))\n        get \"/u/#{Fabricate(:user).username}/emails.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"returns emails and associated_accounts for self\" do\n        Fabricate(:email_change_request, user: user1)\n        sign_in(user)\n\n        get \"/u/#{user.username}/emails.json\"\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"email\"]).to eq(user.email)\n        expect(json[\"secondary_emails\"]).to eq(user.secondary_emails)\n        expect(json[\"unconfirmed_emails\"]).to eq(user.unconfirmed_emails)\n        expect(json[\"associated_accounts\"]).to eq([])\n      end\n\n      it \"returns emails and associated_accounts when you're allowed to see them\" do\n        Fabricate(:email_change_request, user: user1)\n        sign_in_admin\n\n        get \"/u/#{user.username}/emails.json\"\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"email\"]).to eq(user.email)\n        expect(json[\"secondary_emails\"]).to eq(user.secondary_emails)\n        expect(json[\"unconfirmed_emails\"]).to eq(user.unconfirmed_emails)\n        expect(json[\"associated_accounts\"]).to eq([])\n      end\n\n      it \"works on inactive users\" do\n        inactive_user = Fabricate(:user, active: false)\n        Fabricate(:email_change_request, user: inactive_user)\n        sign_in_admin\n\n        get \"/u/#{inactive_user.username}/emails.json\"\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"email\"]).to eq(inactive_user.email)\n        expect(json[\"secondary_emails\"]).to eq(inactive_user.secondary_emails)\n        expect(json[\"unconfirmed_emails\"]).to eq(inactive_user.unconfirmed_emails)\n        expect(json[\"associated_accounts\"]).to eq([])\n      end\n    end\n  end\n\n  describe \"#check_sso_email\" do\n    it \"raises an error when not logged in\" do\n      get \"/u/zogstrip/sso-email.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      let(:sign_in_admin) { sign_in(admin) }\n\n      it \"raises an error when you aren't allowed to check sso email\" do\n        sign_in(Fabricate(:user))\n        get \"/u/#{user1.username}/sso-email.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"returns emails and associated_accounts when you're allowed to see them\" do\n        user1.single_sign_on_record =\n          SingleSignOnRecord.create(\n            user_id: user1.id,\n            external_email: \"foobar@example.com\",\n            external_id: \"example\",\n            last_payload: \"looks good\",\n          )\n        sign_in_admin\n\n        get \"/u/#{user1.username}/sso-email.json\"\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"email\"]).to eq(\"foobar@example.com\")\n      end\n    end\n  end\n\n  describe \"#check_sso_payload\" do\n    it \"raises an error when not logged in\" do\n      get \"/u/zogstrip/sso-payload.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      let(:sign_in_admin) { sign_in(admin) }\n\n      it \"raises an error when you aren't allowed to check sso payload\" do\n        sign_in(Fabricate(:user))\n        get \"/u/#{user1.username}/sso-payload.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"returns SSO payload when you're allowed to see\" do\n        user1.single_sign_on_record =\n          SingleSignOnRecord.create(\n            user_id: user1.id,\n            external_email: \"foobar@example.com\",\n            external_id: \"example\",\n            last_payload: \"foobar\",\n          )\n        sign_in_admin\n\n        get \"/u/#{user1.username}/sso-payload.json\"\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"payload\"]).to eq(\"foobar\")\n      end\n    end\n  end\n\n  describe \"#update_primary_email\" do\n    let(:user_email) { user1.primary_email }\n    fab!(:other_email) { Fabricate(:secondary_email, user: user1) }\n\n    before do\n      SiteSetting.email_editable = true\n\n      sign_in(user1)\n    end\n\n    it \"changes user's primary email\" do\n      put \"/u/#{user1.username}/preferences/primary-email.json\", params: { email: user_email.email }\n      expect(response.status).to eq(200)\n      expect(user_email.reload.primary).to eq(true)\n      expect(other_email.reload.primary).to eq(false)\n\n      event =\n        DiscourseEvent\n          .track_events do\n            expect {\n              put \"/u/#{user1.username}/preferences/primary-email.json\",\n                  params: {\n                    email: other_email.email,\n                  }\n            }.to change {\n              UserHistory.where(\n                action: UserHistory.actions[:update_email],\n                acting_user_id: user1.id,\n              ).count\n            }.by(1)\n          end\n          .last\n\n      expect(response.status).to eq(200)\n      expect(user_email.reload.primary).to eq(false)\n      expect(other_email.reload.primary).to eq(true)\n\n      expect(event[:event_name]).to eq(:user_updated)\n      expect(event[:params].first).to eq(user1)\n    end\n  end\n\n  describe \"#destroy_email\" do\n    fab!(:user_email) { user1.primary_email }\n    fab!(:other_email) { Fabricate(:secondary_email, user: user1) }\n\n    before do\n      SiteSetting.email_editable = true\n\n      sign_in(user1)\n    end\n\n    it \"can destroy secondary emails\" do\n      delete \"/u/#{user1.username}/preferences/email.json\", params: { email: user_email.email }\n      expect(response.status).to eq(428)\n      expect(user1.reload.user_emails.pluck(:email)).to contain_exactly(\n        user_email.email,\n        other_email.email,\n      )\n\n      event =\n        DiscourseEvent\n          .track_events do\n            expect {\n              delete \"/u/#{user1.username}/preferences/email.json\",\n                     params: {\n                       email: other_email.email,\n                     }\n            }.to change {\n              UserHistory.where(\n                action: UserHistory.actions[:destroy_email],\n                acting_user_id: user1.id,\n              ).count\n            }.by(1)\n          end\n          .last\n\n      expect(response.status).to eq(200)\n      expect(user1.reload.user_emails.pluck(:email)).to contain_exactly(user_email.email)\n\n      expect(event[:event_name]).to eq(:user_updated)\n      expect(event[:params].first).to eq(user1)\n    end\n\n    it \"can destroy unconfirmed emails\" do\n      request_1 =\n        EmailChangeRequest.create!(\n          user: user1,\n          new_email: user_email.email,\n          change_state: EmailChangeRequest.states[:authorizing_new],\n        )\n\n      EmailChangeRequest.create!(\n        user: user1,\n        new_email: other_email.email,\n        change_state: EmailChangeRequest.states[:authorizing_new],\n      )\n\n      EmailChangeRequest.create!(\n        user: user1,\n        new_email: other_email.email,\n        change_state: EmailChangeRequest.states[:authorizing_new],\n      )\n\n      delete \"/u/#{user1.username}/preferences/email.json\", params: { email: other_email.email }\n\n      expect(user1.user_emails.pluck(:email)).to contain_exactly(\n        user_email.email,\n        other_email.email,\n      )\n      expect(user1.email_change_requests).to contain_exactly(request_1)\n    end\n\n    it \"destroys associated email tokens and email change requests\" do\n      new_email = \"new.n.cool@example.com\"\n      updater = EmailUpdater.new(guardian: user1.guardian, user: user1)\n      updater.change_to(new_email)\n\n      email_token = updater.change_req.new_email_token\n      expect(email_token).to be_present\n\n      delete \"/u/#{user1.username}/preferences/email.json\", params: { email: new_email }\n\n      expect(EmailToken.find_by(id: email_token.id)).to eq(nil)\n      expect(EmailChangeRequest.find_by(id: updater.change_req.id)).to eq(nil)\n    end\n  end\n\n  describe \"#topic_tracking_state\" do\n    context \"when anon\" do\n      it \"raises an error on anon for topic_tracking_state\" do\n        get \"/u/#{user1.username}/topic-tracking-state.json\"\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context \"when logged on\" do\n      it \"detects new topic\" do\n        sign_in(user1)\n\n        topic = Fabricate(:topic)\n        get \"/u/#{user1.username}/topic-tracking-state.json\"\n\n        expect(response.status).to eq(200)\n        states = response.parsed_body\n        expect(states[0][\"topic_id\"]).to eq(topic.id)\n      end\n    end\n  end\n\n  describe \"#summary\" do\n    it \"generates summary info\" do\n      create_post(user: user)\n\n      get \"/u/#{user.username_lower}/summary.json\"\n      expect(response.headers[\"X-Robots-Tag\"]).to eq(\"noindex\")\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n\n      expect(json[\"user_summary\"][\"topic_count\"]).to eq(1)\n      expect(json[\"user_summary\"][\"post_count\"]).to eq(0)\n    end\n\n    context \"when `hide_user_profiles_from_public` site setting is enabled\" do\n      before { SiteSetting.hide_user_profiles_from_public = true }\n\n      it \"returns 200 for logged in users\" do\n        sign_in(Fabricate(:user))\n\n        get \"/u/#{user.username_lower}/summary.json\"\n\n        expect(response.status).to eq(200)\n      end\n\n      it \"returns 403 for anonymous users\" do\n        get \"/u/#{user.username_lower}/summary.json\"\n\n        expect(response).to redirect_to \"/login\"\n      end\n    end\n\n    context \"when `hide_profile_and_presence` user option is checked\" do\n      before_all { user1.user_option.update_columns(hide_profile_and_presence: true) }\n\n      it \"returns 404\" do\n        get \"/u/#{user1.username_lower}/summary.json\"\n        expect(response.status).to eq(404)\n      end\n\n      it \"returns summary info if `allow_users_to_hide_profile` is false\" do\n        SiteSetting.allow_users_to_hide_profile = false\n\n        get \"/u/#{user1.username_lower}/summary.json\"\n        expect(response.status).to eq(200)\n      end\n    end\n\n    context \"with avatar flair in Most... sections\" do\n      it \"returns data for automatic groups flair\" do\n        liker = Fabricate(:user, admin: true, moderator: true, trust_level: 1)\n        create_and_like_post(user_deferred, liker)\n\n        get \"/u/#{user_deferred.username_lower}/summary.json\"\n        json = response.parsed_body\n\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"admin\"]).to eq(true)\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"moderator\"]).to eq(true)\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"trust_level\"]).to eq(1)\n      end\n\n      it \"returns data for flair when an icon is used\" do\n        group =\n          Fabricate(\n            :group,\n            name: \"Groupie\",\n            flair_bg_color: \"#111111\",\n            flair_color: \"#999999\",\n            flair_icon: \"icon\",\n          )\n        liker = Fabricate(:user, flair_group: group)\n        create_and_like_post(user_deferred, liker)\n\n        get \"/u/#{user_deferred.username_lower}/summary.json\"\n        json = response.parsed_body\n\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_name\"]).to eq(\"Groupie\")\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_url\"]).to eq(\"icon\")\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_bg_color\"]).to eq(\"#111111\")\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_color\"]).to eq(\"#999999\")\n      end\n\n      it \"returns data for flair when an image is used\" do\n        upload = Fabricate(:upload)\n        group = Fabricate(:group, name: \"Groupie\", flair_bg_color: \"#111111\", flair_upload: upload)\n        liker = Fabricate(:user, flair_group: group)\n        create_and_like_post(user_deferred, liker)\n\n        get \"/u/#{user_deferred.username_lower}/summary.json\"\n        json = response.parsed_body\n\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_name\"]).to eq(\"Groupie\")\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_url\"]).to eq(upload.url)\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_bg_color\"]).to eq(\"#111111\")\n      end\n\n      def create_and_like_post(likee, liker)\n        UserActionManager.enable\n        post = create_post(user: likee)\n        PostActionCreator.like(liker, post)\n      end\n    end\n  end\n\n  describe \"#confirm_admin\" do\n    it \"fails without a valid token\" do\n      get \"/u/confirm-admin/invalid-token.json\"\n      expect(response).not_to be_successful\n    end\n\n    it \"fails with a missing token\" do\n      get \"/u/confirm-admin/a0a0a0a0a0.json\"\n      expect(response).to_not be_successful\n    end\n\n    it \"succeeds with a valid code as anonymous\" do\n      ac = AdminConfirmation.new(user1, admin)\n      ac.create_confirmation\n      get \"/u/confirm-admin/#{ac.token}.json\"\n      expect(response.status).to eq(200)\n\n      user1.reload\n      expect(user1.admin?).to eq(false)\n    end\n\n    it \"succeeds with a valid code when logged in as that user\" do\n      sign_in(admin)\n\n      ac = AdminConfirmation.new(user1, admin)\n      ac.create_confirmation\n      get \"/u/confirm-admin/#{ac.token}.json\", params: { token: ac.token }\n      expect(response.status).to eq(200)\n\n      user1.reload\n      expect(user1.admin?).to eq(false)\n    end\n\n    it \"fails if you're logged in as a different account\" do\n      sign_in(admin)\n\n      ac = AdminConfirmation.new(user1, Fabricate(:admin))\n      ac.create_confirmation\n      get \"/u/confirm-admin/#{ac.token}.json\"\n      expect(response).to_not be_successful\n\n      user1.reload\n      expect(user1.admin?).to eq(false)\n    end\n\n    describe \"post\" do\n      it \"gives the user admin access when POSTed\" do\n        ac = AdminConfirmation.new(user1, admin)\n        ac.create_confirmation\n        post \"/u/confirm-admin/#{ac.token}.json\"\n        expect(response.status).to eq(200)\n\n        user1.reload\n        expect(user1.admin?).to eq(true)\n      end\n    end\n  end\n\n  describe \"#update_activation_email\" do\n    before do\n      UsersController.any_instance.stubs(:honeypot_value).returns(nil)\n      UsersController.any_instance.stubs(:challenge_value).returns(nil)\n    end\n\n    let(:post_user) do\n      post \"/u.json\",\n           params: {\n             username: \"osamatest\",\n             password: \"strongpassword\",\n             email: \"osama@example.com\",\n           }\n      user = User.where(username: \"osamatest\").first\n      user.active = false\n      user.save!\n      user\n    end\n\n    context \"with a session variable\" do\n      use_redis_snapshotting\n\n      it \"raises an error with an invalid session value\" do\n        post_user\n\n        post \"/u.json\",\n             params: {\n               username: \"osamatest2\",\n               password: \"strongpassword2\",\n               email: \"osama22@example.com\",\n             }\n        user = User.where(username: \"osamatest2\").first\n        user.destroy\n\n        put \"/u/update-activation-email.json\", params: { email: \"osamaupdated@example.com\" }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error for an active user\" do\n        user = post_user\n        user.update(active: true)\n        user.save!\n\n        put \"/u/update-activation-email.json\", params: { email: \"osama@example.com\" }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error when logged in\" do\n        sign_in(moderator)\n        post_user\n\n        put \"/u/update-activation-email.json\", params: { email: \"updatedemail@example.com\" }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error when the new email is taken\" do\n        active_user = Fabricate(:user)\n        post_user\n\n        put \"/u/update-activation-email.json\", params: { email: active_user.email }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"raises an error when the email is blocklisted\" do\n        post_user\n        SiteSetting.blocked_email_domains = \"example.com\"\n        put \"/u/update-activation-email.json\", params: { email: \"test@example.com\" }\n        expect(response.status).to eq(422)\n      end\n\n      it \"can be updated\" do\n        user = post_user\n        token = user.email_tokens.first\n\n        put \"/u/update-activation-email.json\", params: { email: \"updatedemail@example.com\" }\n\n        expect(response.status).to eq(200)\n\n        user.reload\n        expect(user.email).to eq(\"updatedemail@example.com\")\n        expect(\n          user.email_tokens.where(email: \"updatedemail@example.com\", expired: false),\n        ).to be_present\n\n        expect(EmailToken.find_by(id: token.id)).to eq(nil)\n      end\n\n      it \"tells the user to slow down after many requests\" do\n        RateLimiter.enable\n        freeze_time\n\n        user = post_user\n        token = user.email_tokens.first\n\n        6.times do |n|\n          put \"/u/update-activation-email.json\",\n              params: {\n                email: \"updatedemail#{n}@example.com\",\n              },\n              env: {\n                REMOTE_ADDR: \"1.2.3.#{n}\",\n              }\n        end\n\n        expect(response.status).to eq(429)\n      end\n    end\n\n    context \"with a username and password\" do\n      it \"raises an error with an invalid username\" do\n        put \"/u/update-activation-email.json\",\n            params: {\n              username: \"eviltrout\",\n              password: \"invalid-password\",\n              email: \"updatedemail@example.com\",\n            }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error with an invalid password\" do\n        put \"/u/update-activation-email.json\",\n            params: {\n              username: inactive_user.username,\n              password: \"invalid-password\",\n              email: \"updatedemail@example.com\",\n            }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error for an active user\" do\n        put \"/u/update-activation-email.json\",\n            params: {\n              username: Fabricate(:walter_white).username,\n              password: \"letscook\",\n              email: \"updatedemail@example.com\",\n            }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error when logged in\" do\n        sign_in(moderator)\n\n        put \"/u/update-activation-email.json\",\n            params: {\n              username: inactive_user.username,\n              password: \"qwerqwer123\",\n              email: \"updatedemail@example.com\",\n            }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error when the new email is taken\" do\n        put \"/u/update-activation-email.json\",\n            params: {\n              username: inactive_user.username,\n              password: \"qwerqwer123\",\n              email: user.email,\n            }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"can be updated\" do\n        user = inactive_user\n        token = user.email_tokens.first\n\n        put \"/u/update-activation-email.json\",\n            params: {\n              username: user.username,\n              password: \"qwerqwer123\",\n              email: \"updatedemail@example.com\",\n            }\n\n        expect(response.status).to eq(200)\n\n        user.reload\n        expect(user.email).to eq(\"updatedemail@example.com\")\n        expect(\n          user.email_tokens.where(email: \"updatedemail@example.com\", expired: false),\n        ).to be_present\n\n        expect(EmailToken.find_by(id: token.id)).to eq(nil)\n      end\n\n      it \"tells the user to slow down after many requests\" do\n        RateLimiter.enable\n        freeze_time\n\n        user = inactive_user\n        token = user.email_tokens.first\n\n        6.times do |n|\n          put \"/u/update-activation-email.json\",\n              params: {\n                username: user.username,\n                password: \"qwerqwer123\",\n                email: \"updatedemail#{n}@example.com\",\n              },\n              env: {\n                REMOTE_ADDR: \"1.2.3.#{n}\",\n              }\n        end\n\n        expect(response.status).to eq(429)\n      end\n    end\n  end\n\n  describe \"#show\" do\n    context \"when anon\" do\n      let(:user) { Discourse.system_user }\n\n      it \"returns success\" do\n        get \"/u/#{user.username}.json\"\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body[\"user\"]\n\n        expect(parsed[\"username\"]).to eq(user.username)\n        expect(parsed[\"profile_hidden\"]).to be_blank\n        expect(parsed[\"trust_level\"]).to be_present\n      end\n\n      it \"returns a hidden profile\" do\n        user.user_option.update_column(:hide_profile_and_presence, true)\n\n        get \"/u/#{user.username}.json\"\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body[\"user\"]\n\n        expect(parsed[\"username\"]).to eq(user.username)\n        expect(parsed[\"profile_hidden\"]).to eq(true)\n        expect(parsed[\"trust_level\"]).to be_blank\n      end\n\n      it \"should redirect to login page for anonymous user when profiles are hidden\" do\n        SiteSetting.hide_user_profiles_from_public = true\n        get \"/u/#{user.username}.json\"\n        expect(response).to redirect_to \"/login\"\n      end\n\n      describe \"user profile views\" do\n        it \"should track a user profile view for an anon user\" do\n          get \"/\"\n          UserProfileView.expects(:add).with(another_user.user_profile.id, request.remote_ip, nil)\n          get \"/u/#{another_user.username}.json\"\n        end\n\n        it \"skips tracking\" do\n          UserProfileView.expects(:add).never\n          get \"/u/#{user.username}.json\", params: { skip_track_visit: true }\n        end\n      end\n    end\n\n    context \"when logged in\" do\n      before { sign_in(user1) }\n\n      it \"returns success\" do\n        get \"/u/#{user1.username}.json\"\n        expect(response.status).to eq(200)\n        expect(response.headers[\"X-Robots-Tag\"]).to eq(\"noindex\")\n\n        json = response.parsed_body\n\n        expect(json[\"user\"][\"has_title_badges\"]).to eq(false)\n      end\n\n      it \"returns not found when the username doesn't exist\" do\n        get \"/u/madeuppity.json\"\n        expect(response).not_to be_successful\n      end\n\n      it \"returns not found when the user is inactive\" do\n        inactive = Fabricate(:user, active: false)\n        get \"/u/#{inactive.username}.json\"\n        expect(response).not_to be_successful\n      end\n\n      it \"returns success when show_inactive_accounts is true and user is logged in\" do\n        SiteSetting.show_inactive_accounts = true\n        inactive = Fabricate(:user, active: false)\n        get \"/u/#{inactive.username}.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"raises an error on invalid access\" do\n        Guardian.any_instance.expects(:can_see?).with(user1).returns(false)\n        get \"/u/#{user1.username}.json\"\n        expect(response).to be_forbidden\n      end\n\n      describe \"user profile views\" do\n        it \"should track a user profile view for a signed in user\" do\n          UserProfileView.expects(:add).with(\n            another_user.user_profile.id,\n            request.remote_ip,\n            user1.id,\n          )\n          get \"/u/#{another_user.username}.json\"\n        end\n\n        it \"should not track a user profile view for a user viewing his own profile\" do\n          UserProfileView.expects(:add).never\n          get \"/u/#{user1.username}.json\"\n        end\n\n        it \"skips tracking\" do\n          UserProfileView.expects(:add).never\n          get \"/u/#{user1.username}.json\", params: { skip_track_visit: true }\n        end\n      end\n\n      context \"when fetching a user by external_id\" do\n        before { user1.create_single_sign_on_record(external_id: \"997\", last_payload: \"\") }\n\n        it \"returns fetch for a matching external_id\" do\n          get \"/u/by-external/997.json\"\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"user\"][\"username\"]).to eq(user1.username)\n        end\n\n        it \"returns not found when external_id doesn't match\" do\n          get \"/u/by-external/99.json\"\n          expect(response).not_to be_successful\n        end\n\n        context \"for an external provider\" do\n          before do\n            sign_in(admin)\n            SiteSetting.enable_google_oauth2_logins = true\n            UserAssociatedAccount.create!(\n              user: user1,\n              provider_uid: \"myuid\",\n              provider_name: \"google_oauth2\",\n            )\n          end\n\n          it \"doesn't work for non-admin\" do\n            sign_in(user1)\n            get \"/u/by-external/google_oauth2/myuid.json\"\n            expect(response.status).to eq(403)\n          end\n\n          it \"can fetch the user\" do\n            get \"/u/by-external/google_oauth2/myuid.json\"\n            expect(response.status).to eq(200)\n            expect(response.parsed_body[\"user\"][\"username\"]).to eq(user1.username)\n          end\n\n          it \"fails for disabled provider\" do\n            SiteSetting.enable_google_oauth2_logins = false\n            get \"/u/by-external/google_oauth2/myuid.json\"\n            expect(response.status).to eq(404)\n          end\n\n          it \"returns 404 for missing user\" do\n            get \"/u/by-external/google_oauth2/myotheruid.json\"\n            expect(response.status).to eq(404)\n          end\n        end\n      end\n\n      describe \"include_post_count_for\" do\n        fab!(:topic) { Fabricate(:topic) }\n\n        before_all do\n          Fabricate(:post, user: user1, topic: topic)\n          Fabricate(:post, user: admin, topic: topic)\n          Fabricate(:post, user: admin, topic: topic, post_type: Post.types[:whisper])\n        end\n\n        it \"includes only visible posts\" do\n          get \"/u/#{admin.username}.json\", params: { include_post_count_for: topic.id }\n          topic_post_count = response.parsed_body.dig(\"user\", \"topic_post_count\")\n          expect(topic_post_count[topic.id.to_s]).to eq(1)\n        end\n\n        it \"doesn't include the post count when the signed in user doesn't have access\" do\n          c = Fabricate(:category, read_restricted: true)\n          topic.update(category_id: c.id)\n          expect(Guardian.new(user1).can_see?(topic)).to eq(false)\n          get \"/u/#{admin.username}.json\", params: { include_post_count_for: topic.id }\n          topic_post_count = response.parsed_body.dig(\"user\", \"topic_post_count\")\n          expect(topic_post_count).to eq(nil)\n        end\n\n        it \"includes all post types for staff members\" do\n          SiteSetting.whispers_allowed_groups = \"#{Group::AUTO_GROUPS[:staff]}\"\n          sign_in(admin)\n\n          get \"/u/#{admin.username}.json\", params: { include_post_count_for: topic.id }\n          topic_post_count = response.parsed_body.dig(\"user\", \"topic_post_count\")\n          expect(topic_post_count[topic.id.to_s]).to eq(2)\n        end\n      end\n    end\n\n    it \"should be able to view a user\" do\n      get \"/u/#{user1.username}\"\n\n      expect(response.status).to eq(200)\n      expect(response.body).to include(user1.username)\n    end\n\n    it \"should not be able to view a private user profile\" do\n      user1.user_profile.update!(bio_raw: \"Hello world!\")\n      user1.user_option.update!(hide_profile_and_presence: true)\n\n      get \"/u/#{user1.username}\"\n\n      expect(response.status).to eq(200)\n      expect(response.body).not_to include(\"Hello world!\")\n    end\n\n    describe \"when username contains a period\" do\n      before_all { user1.update!(username: \"test.test\") }\n\n      it \"should be able to view a user\" do\n        get \"/u/#{user1.username}\"\n\n        expect(response.status).to eq(200)\n        expect(response.body).to include(user1.username)\n      end\n    end\n  end\n\n  describe \"#show_card\" do\n    context \"when anon\" do\n      let(:user) { Discourse.system_user }\n\n      it \"returns success\" do\n        get \"/u/#{user.username}/card.json\"\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body[\"user\"]\n\n        expect(parsed[\"username\"]).to eq(user.username)\n        expect(parsed[\"profile_hidden\"]).to be_blank\n        expect(parsed[\"trust_level\"]).to be_present\n      end\n\n      it \"should redirect to login page for anonymous user when profiles are hidden\" do\n        SiteSetting.hide_user_profiles_from_public = true\n        get \"/u/#{user.username}/card.json\"\n        expect(response).to redirect_to \"/login\"\n      end\n    end\n\n    context \"when logged in\" do\n      before { sign_in(user1) }\n\n      it \"works correctly\" do\n        get \"/u/#{user.username}/card.json\"\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n\n        expect(json[\"user\"][\"associated_accounts\"]).to eq(nil) # Not serialized in card\n        expect(json[\"user\"][\"username\"]).to eq(user.username)\n      end\n\n      it \"returns not found when the username doesn't exist\" do\n        get \"/u/madeuppity/card.json\"\n        expect(response).not_to be_successful\n      end\n\n      it \"returns partial response when inactive user\" do\n        user.update!(active: false)\n        get \"/u/#{user.username}/card.json\"\n        expect(response).to be_successful\n        expect(response.parsed_body[\"user\"][\"inactive\"]).to eq(true)\n      end\n\n      it \"returns partial response when hidden users\" do\n        user.user_option.update!(hide_profile_and_presence: true)\n        get \"/u/#{user.username}/card.json\"\n        expect(response).to be_successful\n        expect(response.parsed_body[\"user\"][\"profile_hidden\"]).to eq(true)\n      end\n\n      it \"raises an error on invalid access\" do\n        Guardian.any_instance.expects(:can_see?).with(user).returns(false)\n        get \"/u/#{user.username}/card.json\"\n        expect(response).to be_forbidden\n      end\n    end\n  end\n\n  describe \"#cards\" do\n    fab!(:user) { Discourse.system_user }\n    fab!(:user2) { Fabricate(:user) }\n\n    it \"returns success\" do\n      get \"/user-cards.json?user_ids=#{user.id},#{user2.id}\"\n      expect(response.status).to eq(200)\n      parsed = response.parsed_body[\"users\"]\n\n      expect(parsed.map { |u| u[\"username\"] }).to contain_exactly(user.username, user2.username)\n    end\n\n    it \"should redirect to login page for anonymous user when profiles are hidden\" do\n      SiteSetting.hide_user_profiles_from_public = true\n      get \"/user-cards.json?user_ids=#{user.id},#{user2.id}\"\n      expect(response).to redirect_to \"/login\"\n    end\n\n    context \"when `hide_profile_and_presence` user option is checked\" do\n      before { user2.user_option.update_columns(hide_profile_and_presence: true) }\n\n      it \"does not include hidden profiles\" do\n        get \"/user-cards.json?user_ids=#{user.id},#{user2.id}\"\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body[\"users\"]\n\n        expect(parsed.map { |u| u[\"username\"] }).to contain_exactly(user.username)\n      end\n\n      it \"does include hidden profiles when `allow_users_to_hide_profile` is false\" do\n        SiteSetting.allow_users_to_hide_profile = false\n\n        get \"/user-cards.json?user_ids=#{user.id},#{user2.id}\"\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body[\"users\"]\n\n        expect(parsed.map { |u| u[\"username\"] }).to contain_exactly(user.username, user2.username)\n      end\n    end\n  end\n\n  describe \"#badges\" do\n    it \"renders fine by default\" do\n      get \"/u/#{user1.username}/badges\"\n      expect(response.status).to eq(200)\n    end\n\n    it \"fails if badges are disabled\" do\n      SiteSetting.enable_badges = false\n      get \"/u/#{user1.username}/badges\"\n      expect(response.status).to eq(404)\n    end\n  end\n\n  describe \"#account_created\" do\n    it \"returns a message when no session is present\" do\n      get \"/u/account-created\"\n\n      expect(response.status).to eq(200)\n\n      body = response.body\n\n      expect(body).to match(I18n.t(\"activation.missing_session\"))\n    end\n\n    it \"redirects when the user is logged in\" do\n      sign_in(user1)\n\n      get \"/u/account-created\"\n\n      expect(response).to redirect_to(\"/\")\n    end\n\n    context \"when cookies contains a destination URL\" do\n      it \"should redirect to the URL\" do\n        sign_in(user1)\n\n        destination_url = \"http://thisisasite.com/somepath\"\n        cookies[:destination_url] = destination_url\n\n        get \"/u/account-created\"\n\n        expect(response).to redirect_to(destination_url)\n      end\n    end\n\n    context \"when the user account is created\" do\n      include ApplicationHelper\n\n      it \"returns the message when set in the session\" do\n        user1 = create_user\n        get \"/u/account-created\"\n\n        expect(response.status).to eq(200)\n\n        expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n          json = JSON.parse(element.current_scope.attribute(\"data-preloaded\").value)\n          expect(json[\"accountCreated\"]).to include(\n            \"{\\\"message\\\":\\\"#{I18n.t(\"login.activate_email\", email: user1.email).gsub!(\"</\", \"<\\\\/\")}\\\",\\\"show_controls\\\":true,\\\"username\\\":\\\"#{user1.username}\\\",\\\"email\\\":\\\"#{user1.email}\\\"}\",\n          )\n        end\n      end\n    end\n  end\n\n  describe \"#search_users\" do\n    fab!(:topic) { Fabricate :topic }\n    let(:user) { Fabricate :user, username: \"joecabot\", name: \"Lawrence Tierney\" }\n    let(:post1) { Fabricate(:post, user: user, topic: topic) }\n    let(:staged_user) { Fabricate(:user, staged: true) }\n\n    before do\n      SearchIndexer.enable\n      post1\n    end\n\n    it \"searches when provided the term only\" do\n      get \"/u/search/users.json\", params: { term: user.name.split(\" \").last }\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"users\"].map { |u| u[\"username\"] }).to include(user.username)\n    end\n\n    it \"searches when provided the topic only\" do\n      get \"/u/search/users.json\", params: { topic_id: topic.id }\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"users\"].map { |u| u[\"username\"] }).to include(user.username)\n    end\n\n    it \"searches when provided the term and topic\" do\n      get \"/u/search/users.json\", params: { term: user.name.split(\" \").last, topic_id: topic.id }\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"users\"].map { |u| u[\"username\"] }).to include(user.username)\n    end\n\n    it \"searches only for users who have access to private topic\" do\n      searching_user = Fabricate(:user)\n      privileged_user =\n        Fabricate(:user, trust_level: 4, username: \"joecabit\", name: \"Lawrence Tierney\")\n      privileged_group = Fabricate(:group)\n      privileged_group.add(searching_user)\n      privileged_group.add(privileged_user)\n      privileged_group.save\n\n      category = Fabricate(:category)\n      category.set_permissions(privileged_group => :readonly)\n      category.save\n\n      private_topic = Fabricate(:topic, category: category)\n\n      sign_in(searching_user)\n      get \"/u/search/users.json\",\n          params: {\n            term: user.name.split(\" \").last,\n            topic_id: private_topic.id,\n            topic_allowed_users: \"true\",\n          }\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"users\"].map { |u| u[\"username\"] }).to_not include(user.username)\n      expect(json[\"users\"].map { |u| u[\"username\"] }).to include(privileged_user.username)\n    end\n\n    it \"interprets blank category id correctly\" do\n      pm_topic = Fabricate(:private_message_post).topic\n      sign_in(pm_topic.user)\n      get \"/u/search/users.json\", params: { term: \"\", topic_id: pm_topic.id, category_id: \"\" }\n      expect(response.status).to eq(200)\n    end\n\n    describe \"when limit params is invalid\" do\n      include_examples \"invalid limit params\",\n                       \"/u/search/users.json\",\n                       described_class::SEARCH_USERS_LIMIT\n    end\n\n    context \"when `enable_names` is true\" do\n      before { SiteSetting.enable_names = true }\n\n      it \"returns names\" do\n        get \"/u/search/users.json\", params: { term: user.name }\n        json = response.parsed_body\n        expect(json[\"users\"].map { |u| u[\"name\"] }).to include(user.name)\n      end\n    end\n\n    context \"when `enable_names` is false\" do\n      before { SiteSetting.enable_names = false }\n\n      it \"returns names\" do\n        get \"/u/search/users.json\", params: { term: user.name }\n        json = response.parsed_body\n        expect(json[\"users\"].map { |u| u[\"name\"] }).not_to include(user.name)\n      end\n    end\n\n    context \"with groups\" do\n      fab!(:mentionable_group) do\n        Fabricate(\n          :group,\n          mentionable_level: Group::ALIAS_LEVELS[:everyone],\n          messageable_level: Group::ALIAS_LEVELS[:nobody],\n          visibility_level: Group.visibility_levels[:public],\n          name: \"aaa1bbb\",\n        )\n      end\n\n      fab!(:mentionable_group_2) do\n        Fabricate(\n          :group,\n          mentionable_level: Group::ALIAS_LEVELS[:everyone],\n          messageable_level: Group::ALIAS_LEVELS[:nobody],\n          visibility_level: Group.visibility_levels[:logged_on_users],\n          name: \"bbb1aaa\",\n        )\n      end\n\n      fab!(:messageable_group) do\n        Fabricate(\n          :group,\n          mentionable_level: Group::ALIAS_LEVELS[:nobody],\n          messageable_level: Group::ALIAS_LEVELS[:everyone],\n          visibility_level: Group.visibility_levels[:logged_on_users],\n          name: \"ccc1aaa\",\n        )\n      end\n\n      fab!(:private_group) do\n        Fabricate(\n          :group,\n          mentionable_level: Group::ALIAS_LEVELS[:members_mods_and_admins],\n          messageable_level: Group::ALIAS_LEVELS[:members_mods_and_admins],\n          visibility_level: Group.visibility_levels[:members],\n          name: \"ddd1aaa\",\n        )\n      end\n\n      describe \"when signed in\" do\n        before { sign_in(user) }\n\n        it \"correctly sorts on prefix\" do\n          get \"/u/search/users.json\", params: { include_groups: \"true\", term: \"bbb\" }\n\n          expect(response.status).to eq(200)\n          groups = response.parsed_body[\"groups\"]\n\n          expect(groups.map { |g| g[\"name\"] }).to eq(%w[bbb1aaa aaa1bbb])\n        end\n\n        it \"does not search for groups if there is no term\" do\n          get \"/u/search/users.json\", params: { include_groups: \"true\" }\n\n          expect(response.status).to eq(200)\n\n          groups = response.parsed_body[\"groups\"]\n          expect(groups).to eq(nil)\n        end\n\n        it \"only returns visible groups\" do\n          get \"/u/search/users.json\", params: { include_groups: \"true\", term: \"a\" }\n\n          expect(response.status).to eq(200)\n\n          groups = response.parsed_body[\"groups\"]\n\n          expect(groups.map { |group| group[\"name\"] }).to_not include(private_group.name)\n        end\n\n        it \"allows plugins to register custom groups filter\" do\n          get \"/u/search/users.json\", params: { include_groups: \"true\", term: \"a\" }\n\n          expect(response.status).to eq(200)\n          groups = response.parsed_body[\"groups\"]\n          expect(groups.count).to eq(6)\n\n          plugin = Plugin::Instance.new\n          plugin.register_groups_callback_for_users_search_controller_action(\n            :admins_filter,\n          ) { |original_groups, user| original_groups.where(name: \"admins\") }\n          get \"/u/search/users.json\",\n              params: {\n                include_groups: \"true\",\n                admins_filter: \"true\",\n                term: \"a\",\n              }\n          expect(response.status).to eq(200)\n          groups = response.parsed_body[\"groups\"]\n          expect(groups).to eq([{ \"name\" => \"admins\", \"full_name\" => nil }])\n\n          DiscoursePluginRegistry.reset!\n        end\n\n        it \"allows plugins to use apply modifiers to the groups filter\" do\n          get \"/u/search/users.json\", params: { include_groups: \"true\", term: \"a\" }\n\n          expect(response.status).to eq(200)\n          initial_groups = response.parsed_body[\"groups\"]\n          expect(initial_groups.count).to eq(6)\n\n          Plugin::Instance\n            .new\n            .register_modifier(:groups_for_users_search) do |groups|\n              groups.where(name: initial_groups.first[\"name\"])\n            end\n\n          get \"/u/search/users.json\", params: { include_groups: \"true\", term: \"a\" }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"groups\"].count).to eq(1)\n\n          DiscoursePluginRegistry.reset!\n        end\n\n        it \"works when the modifier to the groups filter introduces a join with a conflicting name fields like `id` for example\" do\n          %i[\n            include_groups\n            include_mentionable_groups\n            include_messageable_groups\n          ].each do |param_name|\n            get \"/u/search/users.json\", params: { param_name => \"true\", :term => \"a\" }\n\n            expect(response.status).to eq(200)\n\n            Plugin::Instance\n              .new\n              .register_modifier(:groups_for_users_search) do |groups|\n                # a join with a conflicting name field (id) is introduced here\n                # we expect the query to work correctly\n                groups.left_joins(:users).where(users: { admin: true })\n              end\n\n            get \"/u/search/users.json\", params: { param_name => \"true\", :term => \"a\" }\n            expect(response.status).to eq(200) # the conflict would cause a 500 error\n\n            DiscoursePluginRegistry.reset!\n          end\n        end\n\n        it \"doesn't search for groups\" do\n          get \"/u/search/users.json\",\n              params: {\n                include_mentionable_groups: \"false\",\n                include_messageable_groups: \"false\",\n                term: \"a\",\n              }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body).not_to have_key(:groups)\n        end\n\n        it \"searches for messageable groups\" do\n          get \"/u/search/users.json\",\n              params: {\n                include_mentionable_groups: \"false\",\n                include_messageable_groups: \"true\",\n                term: \"a\",\n              }\n\n          expect(response.status).to eq(200)\n\n          expect(response.parsed_body[\"groups\"].map { |group| group[\"name\"] }).to contain_exactly(\n            messageable_group.name,\n            Group.find(Group::AUTO_GROUPS[:moderators]).name,\n          )\n        end\n\n        it \"searches for mentionable groups\" do\n          get \"/u/search/users.json\",\n              params: {\n                include_messageable_groups: \"false\",\n                include_mentionable_groups: \"true\",\n                term: \"a\",\n              }\n\n          expect(response.status).to eq(200)\n\n          groups = response.parsed_body[\"groups\"]\n\n          expect(groups.map { |group| group[\"name\"] }).to contain_exactly(\n            mentionable_group.name,\n            mentionable_group_2.name,\n          )\n        end\n      end\n\n      describe \"when not signed in\" do\n        it \"should not include mentionable/messageable groups\" do\n          get \"/u/search/users.json\",\n              params: {\n                include_mentionable_groups: \"false\",\n                include_messageable_groups: \"false\",\n                term: \"a\",\n              }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body).not_to have_key(:groups)\n\n          get \"/u/search/users.json\",\n              params: {\n                include_mentionable_groups: \"false\",\n                include_messageable_groups: \"true\",\n                term: \"a\",\n              }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body).not_to have_key(:groups)\n\n          get \"/u/search/users.json\",\n              params: {\n                include_messageable_groups: \"false\",\n                include_mentionable_groups: \"true\",\n                term: \"a\",\n              }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body).not_to have_key(:groups)\n        end\n      end\n\n      describe \"when searching by group name\" do\n        fab!(:exclusive_group) { Fabricate(:group) }\n\n        it \"return results if the user is a group member\" do\n          exclusive_group.add(user)\n\n          get \"/u/search/users.json\", params: { group: exclusive_group.name, term: user.username }\n\n          expect(users_found).to contain_exactly(user.username)\n        end\n\n        it \"does not return results if the user is not a group member\" do\n          get \"/u/search/users.json\", params: { group: exclusive_group.name, term: user.username }\n\n          expect(users_found).to be_empty\n        end\n\n        it \"returns results if the user is member of one of the groups\" do\n          exclusive_group.add(user)\n\n          get \"/u/search/users.json\",\n              params: {\n                groups: [exclusive_group.name],\n                term: user.username,\n              }\n\n          expect(users_found).to contain_exactly(user.username)\n        end\n\n        it \"does not return results if the user is not a member of the groups\" do\n          get \"/u/search/users.json\",\n              params: {\n                groups: [exclusive_group.name],\n                term: user.username,\n              }\n\n          expect(users_found).to be_empty\n        end\n\n        def users_found\n          response.parsed_body[\"users\"].map { |u| u[\"username\"] }\n        end\n      end\n    end\n\n    context \"with `include_staged_users`\" do\n      it \"includes staged users when the param is true\" do\n        get \"/u/search/users.json\", params: { term: staged_user.name, include_staged_users: true }\n        json = response.parsed_body\n        expect(json[\"users\"].map { |u| u[\"name\"] }).to include(staged_user.name)\n      end\n\n      it \"doesn't include staged users when the param is not passed\" do\n        get \"/u/search/users.json\", params: { term: staged_user.name }\n        json = response.parsed_body\n        expect(json[\"users\"].map { |u| u[\"name\"] }).not_to include(staged_user.name)\n      end\n\n      it \"doesn't include staged users when the param explicitly set to false\" do\n        get \"/u/search/users.json\", params: { term: staged_user.name, include_staged_users: false }\n        json = response.parsed_body\n        expect(json[\"users\"].map { |u| u[\"name\"] }).not_to include(staged_user.name)\n      end\n    end\n\n    context \"with `last_seen_users`\" do\n      it \"returns results when the param is true\" do\n        get \"/u/search/users.json\", params: { last_seen_users: true }\n\n        json = response.parsed_body\n        expect(json[\"users\"]).not_to be_empty\n      end\n\n      it \"respects limit parameter at the same time\" do\n        limit = 3\n        get \"/u/search/users.json\", params: { last_seen_users: true, limit: limit }\n\n        json = response.parsed_body\n        expect(json[\"users\"]).not_to be_empty\n        expect(json[\"users\"].size).to eq(limit)\n      end\n    end\n\n    it \"returns avatar_template\" do\n      get \"/u/search/users.json\", params: { term: user.username }\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"users\"][0]).to have_key(\"avatar_template\")\n      expect(json[\"users\"][0][\"avatar_template\"]).to eq(\n        \"/letter_avatar_proxy/v4/letter/j/f475e1/{size}.png\",\n      )\n    end\n\n    describe \"#status\" do\n      it \"returns user status if enabled in site settings\" do\n        SiteSetting.enable_user_status = true\n        emoji = \"tooth\"\n        description = \"off to dentist\"\n        user.set_status!(description, emoji)\n\n        get \"/u/search/users.json\", params: { term: user.name }\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"users\"][0]).to have_key(\"status\")\n        expect(json[\"users\"][0][\"status\"][\"description\"]).to eq(description)\n        expect(json[\"users\"][0][\"status\"][\"emoji\"]).to eq(emoji)\n      end\n\n      it \"doesn't return user status if disabled in site settings\" do\n        SiteSetting.enable_user_status = false\n        user.set_status!(\"off to dentist\", \"tooth\")\n\n        get \"/u/search/users.json\", params: { term: user.name }\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"users\"][0]).not_to have_key(\"status\")\n      end\n    end\n  end\n\n  describe \"#email_login\" do\n    before { SiteSetting.enable_local_logins_via_email = true }\n\n    it \"enqueues the right email\" do\n      post \"/u/email-login.json\", params: { login: user1.email }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"user_found\"]).to eq(true)\n\n      job_args = Jobs::CriticalUserEmail.jobs.last[\"args\"].first\n      expect(job_args[\"user_id\"]).to eq(user1.id)\n      expect(job_args[\"type\"]).to eq(\"email_login\")\n      expect(EmailToken.hash_token(job_args[\"email_token\"])).to eq(\n        user1.email_tokens.last.token_hash,\n      )\n    end\n\n    describe \"when enable_local_logins_via_email is disabled\" do\n      before { SiteSetting.enable_local_logins_via_email = false }\n\n      it \"should return the right response\" do\n        post \"/u/email-login.json\", params: { login: user1.email }\n        expect(response.status).to eq(404)\n      end\n    end\n\n    describe \"when username or email is not valid\" do\n      it \"should not enqueue the email to login\" do\n        post \"/u/email-login.json\", params: { login: \"@random\" }\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"user_found\"]).to eq(false)\n        expect(json[\"hide_taken\"]).to eq(false)\n        expect(Jobs::CriticalUserEmail.jobs).to eq([])\n      end\n    end\n\n    describe \"when hide_email_address_taken is true\" do\n      it \"should return the right response\" do\n        SiteSetting.hide_email_address_taken = true\n        post \"/u/email-login.json\", params: { login: user1.email }\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json.has_key?(\"user_found\")).to eq(false)\n        expect(json[\"hide_taken\"]).to eq(true)\n      end\n    end\n\n    describe \"when user is already logged in\" do\n      it \"should redirect to the root path\" do\n        sign_in(user1)\n        post \"/u/email-login.json\", params: { login: user1.email }\n\n        expect(response).to redirect_to(\"/\")\n      end\n    end\n  end\n\n  describe \"#create_second_factor_totp\" do\n    context \"when not logged in\" do\n      it \"should return the right response\" do\n        post \"/users/second_factors.json\", params: { password: \"wrongpassword\" }\n\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context \"when logged in\" do\n      before { sign_in(user1) }\n\n      describe \"create 2fa request\" do\n        it \"fails on incorrect password\" do\n          ApplicationController\n            .any_instance\n            .expects(:secure_session)\n            .returns(\"confirmed-password-#{user1.id}\" => \"false\")\n          post \"/users/create_second_factor_totp.json\"\n\n          expect(response.status).to eq(403)\n        end\n\n        describe \"when local logins are disabled\" do\n          it \"should return the right response\" do\n            SiteSetting.enable_local_logins = false\n\n            post \"/users/create_second_factor_totp.json\"\n\n            expect(response.status).to eq(404)\n          end\n        end\n\n        describe \"when SSO is enabled\" do\n          it \"should return the right response\" do\n            SiteSetting.discourse_connect_url = \"http://someurl.com\"\n            SiteSetting.enable_discourse_connect = true\n\n            post \"/users/create_second_factor_totp.json\"\n\n            expect(response.status).to eq(404)\n          end\n        end\n\n        it \"succeeds on correct password\" do\n          ApplicationController\n            .any_instance\n            .stubs(:secure_session)\n            .returns(\"confirmed-password-#{user1.id}\" => \"true\")\n          post \"/users/create_second_factor_totp.json\"\n\n          expect(response.status).to eq(200)\n\n          response_body = response.parsed_body\n\n          expect(response_body[\"key\"]).to be_present\n          expect(response_body[\"qr\"]).to be_present\n        end\n      end\n    end\n  end\n\n  describe \"#enable_second_factor_totp\" do\n    before { sign_in(user1) }\n\n    use_redis_snapshotting\n\n    def create_totp\n      stub_secure_session_confirmed\n      post \"/users/create_second_factor_totp.json\"\n    end\n\n    it \"creates a totp for the user successfully\" do\n      create_totp\n      staged_totp_key = read_secure_session[\"staged-totp-#{user1.id}\"]\n      token = ROTP::TOTP.new(staged_totp_key).now\n\n      post \"/users/enable_second_factor_totp.json\",\n           params: {\n             name: \"test\",\n             second_factor_token: token,\n           }\n\n      expect(response.status).to eq(200)\n      expect(user1.user_second_factors.count).to eq(1)\n    end\n\n    it \"rate limits by IP address\" do\n      RateLimiter.enable\n\n      create_totp\n      staged_totp_key = read_secure_session[\"staged-totp-#{user1.id}\"]\n      token = ROTP::TOTP.new(staged_totp_key).now\n\n      7.times do |x|\n        post \"/users/enable_second_factor_totp.json\",\n             params: {\n               name: \"test\",\n               second_factor_token: token,\n             }\n      end\n\n      expect(response.status).to eq(429)\n    end\n\n    it \"rate limits by username\" do\n      RateLimiter.enable\n\n      create_totp\n      staged_totp_key = read_secure_session[\"staged-totp-#{user1.id}\"]\n      token = ROTP::TOTP.new(staged_totp_key).now\n\n      7.times do |x|\n        post \"/users/enable_second_factor_totp.json\",\n             params: {\n               name: \"test\",\n               second_factor_token: token,\n             },\n             env: {\n               REMOTE_ADDR: \"1.2.3.#{x}\",\n             }\n      end\n\n      expect(response.status).to eq(429)\n    end\n\n    context \"when an incorrect token is provided\" do\n      before do\n        create_totp\n        post \"/users/enable_second_factor_totp.json\",\n             params: {\n               name: \"test\",\n               second_factor_token: \"123456\",\n             }\n      end\n      it \"shows a helpful error message to the user\" do\n        expect(response.parsed_body[\"error\"]).to eq(I18n.t(\"login.invalid_second_factor_code\"))\n      end\n    end\n\n    context \"when a name is not provided\" do\n      before do\n        create_totp\n        post \"/users/enable_second_factor_totp.json\", params: { second_factor_token: \"123456\" }\n      end\n      it \"shows a helpful error message to the user\" do\n        expect(response.parsed_body[\"error\"]).to eq(I18n.t(\"login.missing_second_factor_name\"))\n      end\n    end\n\n    context \"when a token is not provided\" do\n      before do\n        create_totp\n        post \"/users/enable_second_factor_totp.json\", params: { name: \"test\" }\n      end\n      it \"shows a helpful error message to the user\" do\n        expect(response.parsed_body[\"error\"]).to eq(I18n.t(\"login.missing_second_factor_code\"))\n      end\n    end\n\n    it \"doesn't allow creating too many TOTPs\" do\n      Fabricate(:user_second_factor_totp, user: user1)\n\n      create_totp\n      staged_totp_key = read_secure_session[\"staged-totp-#{user1.id}\"]\n      token = ROTP::TOTP.new(staged_totp_key).now\n\n      stub_const(UserSecondFactor, \"MAX_TOTPS_PER_USER\", 1) do\n        post \"/users/enable_second_factor_totp.json\",\n             params: {\n               name: \"test\",\n               second_factor_token: token,\n             }\n      end\n\n      expect(response.status).to eq(422)\n      expect(response.parsed_body[\"errors\"]).to include(I18n.t(\"login.too_many_authenticators\"))\n\n      expect(user1.user_second_factors.count).to eq(1)\n    end\n\n    it \"doesn't allow the TOTP name to exceed the limit\" do\n      create_totp\n      staged_totp_key = read_secure_session[\"staged-totp-#{user1.id}\"]\n      token = ROTP::TOTP.new(staged_totp_key).now\n\n      post \"/users/enable_second_factor_totp.json\",\n           params: {\n             name: \"a\" * (UserSecondFactor::MAX_NAME_LENGTH + 1),\n             second_factor_token: token,\n           }\n\n      expect(response.status).to eq(422)\n      expect(response.parsed_body[\"errors\"]).to include(\n        \"Name is too long (maximum is 300 characters)\",\n      )\n\n      expect(user1.user_second_factors.count).to eq(0)\n    end\n  end\n\n  describe \"#update_second_factor\" do\n    fab!(:user_second_factor) { Fabricate(:user_second_factor_totp, user: user1) }\n\n    context \"when not logged in\" do\n      it \"should return the right response\" do\n        put \"/users/second_factor.json\"\n\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context \"when logged in\" do\n      before { sign_in(user1) }\n\n      context \"when user has totp setup\" do\n        context \"when token is missing\" do\n          it \"returns the right response\" do\n            put \"/users/second_factor.json\",\n                params: {\n                  disable: \"true\",\n                  second_factor_target: UserSecondFactor.methods[:totp],\n                  id: user_second_factor.id,\n                }\n\n            expect(response.status).to eq(403)\n          end\n        end\n\n        context \"when token is valid\" do\n          before { stub_secure_session_confirmed }\n          it \"should allow second factor for the user to be renamed\" do\n            put \"/users/second_factor.json\",\n                params: {\n                  name: \"renamed\",\n                  second_factor_target: UserSecondFactor.methods[:totp],\n                  id: user_second_factor.id,\n                }\n\n            expect(response.status).to eq(200)\n            expect(user1.reload.user_second_factors.totps.first.name).to eq(\"renamed\")\n          end\n\n          it \"should allow second factor for the user to be disabled\" do\n            put \"/users/second_factor.json\",\n                params: {\n                  disable: \"true\",\n                  second_factor_target: UserSecondFactor.methods[:totp],\n                  id: user_second_factor.id,\n                }\n\n            expect(response.status).to eq(200)\n            expect(user1.reload.user_second_factors.totps.first).to eq(nil)\n          end\n        end\n      end\n\n      context \"when user is updating backup codes\" do\n        context \"when token is missing\" do\n          it \"returns the right response\" do\n            put \"/users/second_factor.json\",\n                params: {\n                  second_factor_target: UserSecondFactor.methods[:backup_codes],\n                }\n\n            expect(response.status).to eq(403)\n          end\n        end\n\n        context \"when token is valid\" do\n          before do\n            ApplicationController\n              .any_instance\n              .stubs(:secure_session)\n              .returns(\"confirmed-password-#{user1.id}\" => \"true\")\n          end\n          it \"should allow second factor backup for the user to be disabled\" do\n            put \"/users/second_factor.json\",\n                params: {\n                  second_factor_target: UserSecondFactor.methods[:backup_codes],\n                  disable: \"true\",\n                }\n\n            expect(response.status).to eq(200)\n            expect(user1.reload.user_second_factors.backup_codes).to be_empty\n          end\n        end\n      end\n    end\n  end\n\n  describe \"#create_second_factor_backup\" do\n    fab!(:user_second_factor) { Fabricate(:user_second_factor_totp, user: user1) }\n\n    context \"when not logged in\" do\n      it \"should return the right response\" do\n        put \"/users/second_factors_backup.json\",\n            params: {\n              second_factor_token: \"wrongtoken\",\n              second_factor_method: UserSecondFactor.methods[:totp],\n            }\n\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context \"when logged in\" do\n      before { sign_in(user1) }\n\n      describe \"create 2fa request\" do\n        it \"fails on incorrect password\" do\n          ApplicationController\n            .any_instance\n            .expects(:secure_session)\n            .returns(\"confirmed-password-#{user1.id}\" => \"false\")\n          put \"/users/second_factors_backup.json\"\n\n          expect(response.status).to eq(403)\n        end\n\n        describe \"when local logins are disabled\" do\n          it \"should return the right response\" do\n            SiteSetting.enable_local_logins = false\n\n            put \"/users/second_factors_backup.json\"\n\n            expect(response.status).to eq(404)\n          end\n        end\n\n        describe \"when SSO is enabled\" do\n          it \"should return the right response\" do\n            SiteSetting.discourse_connect_url = \"http://someurl.com\"\n            SiteSetting.enable_discourse_connect = true\n\n            put \"/users/second_factors_backup.json\"\n\n            expect(response.status).to eq(404)\n          end\n        end\n\n        it \"succeeds on correct password\" do\n          ApplicationController\n            .any_instance\n            .expects(:secure_session)\n            .returns(\"confirmed-password-#{user1.id}\" => \"true\")\n\n          put \"/users/second_factors_backup.json\"\n\n          expect(response.status).to eq(200)\n\n          response_body = response.parsed_body\n\n          # we use SecureRandom.hex(16) for backup codes, ensure this continues to be the case\n          expect(response_body[\"backup_codes\"].map(&:length)).to eq([32] * 10)\n        end\n      end\n    end\n  end\n\n  describe \"#create_second_factor_security_key\" do\n    it \"stores the challenge in the session and returns challenge data, user id, and supported algorithms\" do\n      create_second_factor_security_key\n      secure_session = read_secure_session\n      response_parsed = response.parsed_body\n      expect(response_parsed[\"challenge\"]).to eq(Webauthn.challenge(user1, secure_session))\n      expect(response_parsed[\"rp_id\"]).to eq(Webauthn.rp_id(user1, secure_session))\n      expect(response_parsed[\"rp_name\"]).to eq(Webauthn.rp_name(user1, secure_session))\n      expect(response_parsed[\"user_secure_id\"]).to eq(\n        user1.reload.create_or_fetch_secure_identifier,\n      )\n      expect(response_parsed[\"supported_algorithms\"]).to eq(::Webauthn::SUPPORTED_ALGORITHMS)\n    end\n\n    it \"doesn't create a challenge if the user has the maximum number allowed of security keys\" do\n      Fabricate(:user_security_key_with_random_credential, user: user1)\n      stub_const(UserSecurityKey, \"MAX_KEYS_PER_USER\", 1) { create_second_factor_security_key }\n      expect(response.status).to eq(422)\n      expect(response.parsed_body[\"errors\"]).to include(I18n.t(\"login.too_many_security_keys\"))\n    end\n\n    context \"if the user has security key credentials already\" do\n      fab!(:user_security_key) { Fabricate(:user_security_key_with_random_credential, user: user1) }\n\n      it \"returns those existing active credentials\" do\n        create_second_factor_security_key\n        response_parsed = response.parsed_body\n        expect(response_parsed[\"existing_active_credential_ids\"]).to eq(\n          [user_security_key.credential_id],\n        )\n      end\n    end\n  end\n\n  describe \"#register_second_factor_security_key\" do\n    context \"when creation parameters are valid\" do\n      it \"creates a security key for the user\" do\n        simulate_localhost_webauthn_challenge\n        create_second_factor_security_key\n        _response_parsed = response.parsed_body\n\n        post \"/u/register_second_factor_security_key.json\",\n             params: valid_security_key_create_post_data\n\n        expect(user1.security_keys.count).to eq(1)\n        expect(user1.security_keys.last.credential_id).to eq(\n          valid_security_key_create_post_data[:rawId],\n        )\n        expect(user1.security_keys.last.name).to eq(valid_security_key_create_post_data[:name])\n      end\n\n      it \"doesn't allow creating too many security keys\" do\n        simulate_localhost_webauthn_challenge\n        create_second_factor_security_key\n        _response_parsed = response.parsed_body\n\n        Fabricate(:user_security_key_with_random_credential, user: user1)\n\n        stub_const(UserSecurityKey, \"MAX_KEYS_PER_USER\", 1) do\n          post \"/u/register_second_factor_security_key.json\",\n               params: valid_security_key_create_post_data\n        end\n\n        expect(response.status).to eq(422)\n        expect(response.parsed_body[\"errors\"]).to include(I18n.t(\"login.too_many_security_keys\"))\n\n        expect(user1.security_keys.count).to eq(1)\n      end\n\n      it \"doesn't allow the security key name to exceed the limit\" do\n        simulate_localhost_webauthn_challenge\n        create_second_factor_security_key\n        _response_parsed = response.parsed_body\n\n        post \"/u/register_second_factor_security_key.json\",\n             params:\n               valid_security_key_create_post_data.merge(\n                 name: \"a\" * (UserSecurityKey::MAX_NAME_LENGTH + 1),\n               )\n\n        expect(response.status).to eq(422)\n        expect(response.parsed_body[\"errors\"]).to include(\n          \"Name is too long (maximum is 300 characters)\",\n        )\n\n        expect(user1.security_keys.count).to eq(0)\n      end\n    end\n\n    context \"when the creation parameters are invalid\" do\n      it \"shows a security key error and does not create a key\" do\n        stub_as_dev_localhost\n        create_second_factor_security_key\n        _response_parsed = response.parsed_body\n\n        post \"/u/register_second_factor_security_key.json\",\n             params: {\n               id: \"bad id\",\n               rawId: \"bad rawId\",\n               type: \"public-key\",\n               attestation: \"bad attestation\",\n               clientData: Base64.encode64('{\"bad\": \"json\"}'),\n               name: \"My Bad Key\",\n             }\n\n        expect(user1.security_keys.count).to eq(0)\n        expect(response.parsed_body[\"error\"]).to eq(\n          I18n.t(\"webauthn.validation.invalid_type_error\"),\n        )\n      end\n    end\n  end\n\n  describe \"#disable_second_factor\" do\n    context \"when logged in with secure session\" do\n      before do\n        sign_in(user1)\n        stub_secure_session_confirmed\n      end\n      context \"when user has a registered totp and security key\" do\n        before do\n          _totp_second_factor = Fabricate(:user_second_factor_totp, user: user1)\n          _security_key_second_factor =\n            Fabricate(\n              :user_security_key,\n              user: user1,\n              factor_type: UserSecurityKey.factor_types[:second_factor],\n            )\n        end\n\n        it \"should disable all totp and security keys\" do\n          expect_enqueued_with(\n            job: :critical_user_email,\n            args: {\n              type: :account_second_factor_disabled,\n              user_id: user1.id,\n            },\n          ) do\n            put \"/u/disable_second_factor.json\"\n\n            expect(response.status).to eq(200)\n\n            expect(user1.reload.user_second_factors).to be_empty\n            expect(user1.security_keys).to be_empty\n          end\n        end\n      end\n    end\n  end\n\n  describe \"#revoke_account\" do\n    it \"errors for unauthorised users\" do\n      post \"/u/#{user1.username}/preferences/revoke-account.json\",\n           params: {\n             provider_name: \"facebook\",\n           }\n      expect(response.status).to eq(403)\n\n      sign_in(another_user)\n\n      post \"/u/#{user1.username}/preferences/revoke-account.json\",\n           params: {\n             provider_name: \"facebook\",\n           }\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      before { sign_in(user1) }\n\n      it \"returns an error when there is no matching account\" do\n        post \"/u/#{user1.username}/preferences/revoke-account.json\",\n             params: {\n               provider_name: \"facebook\",\n             }\n        expect(response.status).to eq(404)\n      end\n\n      context \"with fake provider\" do\n        let(:authenticator) do\n          Class\n            .new(Auth::Authenticator) do\n              attr_accessor :can_revoke\n\n              def name\n                \"testprovider\"\n              end\n\n              def enabled?\n                true\n              end\n\n              def description_for_user(user)\n                \"an account\"\n              end\n\n              def can_revoke?\n                can_revoke\n              end\n\n              def revoke(user, skip_remote: false)\n                true\n              end\n            end\n            .new\n        end\n\n        before do\n          DiscoursePluginRegistry.register_auth_provider(\n            Auth::AuthProvider.new(authenticator: authenticator),\n          )\n        end\n\n        after { DiscoursePluginRegistry.reset! }\n\n        it \"returns an error when revoking is not allowed\" do\n          authenticator.can_revoke = false\n\n          post \"/u/#{user1.username}/preferences/revoke-account.json\",\n               params: {\n                 provider_name: \"testprovider\",\n               }\n          expect(response.status).to eq(404)\n\n          authenticator.can_revoke = true\n          post \"/u/#{user1.username}/preferences/revoke-account.json\",\n               params: {\n                 provider_name: \"testprovider\",\n               }\n          expect(response.status).to eq(200)\n        end\n\n        it \"works\" do\n          authenticator.can_revoke = true\n\n          post \"/u/#{user1.username}/preferences/revoke-account.json\",\n               params: {\n                 provider_name: \"testprovider\",\n               }\n          expect(response.status).to eq(200)\n        end\n      end\n    end\n  end\n\n  describe \"#revoke_auth_token\" do\n    context \"while logged in\" do\n      before { 2.times { sign_in(user1) } }\n\n      it \"logs user out\" do\n        ids = user1.user_auth_tokens.order(:created_at).pluck(:id)\n\n        post \"/u/#{user1.username}/preferences/revoke-auth-token.json\", params: { token_id: ids[0] }\n\n        expect(response.status).to eq(200)\n\n        user1.user_auth_tokens.reload\n        expect(user1.user_auth_tokens.count).to eq(1)\n        expect(user1.user_auth_tokens.first.id).to eq(ids[1])\n      end\n\n      it \"checks if token exists\" do\n        ids = user1.user_auth_tokens.order(:created_at).pluck(:id)\n\n        post \"/u/#{user1.username}/preferences/revoke-auth-token.json\", params: { token_id: ids[0] }\n\n        expect(response.status).to eq(200)\n\n        post \"/u/#{user1.username}/preferences/revoke-auth-token.json\", params: { token_id: ids[0] }\n\n        expect(response.status).to eq(400)\n      end\n\n      it \"does not let user log out of current session\" do\n        token = UserAuthToken.generate!(user_id: user1.id)\n        cookie =\n          create_auth_cookie(\n            token: token.unhashed_auth_token,\n            user_id: user1.id,\n            trust_level: user1.trust_level,\n            issued_at: 5.minutes.ago,\n          )\n\n        post \"/u/#{user1.username}/preferences/revoke-auth-token.json\",\n             params: {\n               token_id: token.id,\n             },\n             headers: {\n               \"HTTP_COOKIE\" => \"_t=#{cookie}\",\n             }\n\n        expect(token.reload.id).to be_present\n        expect(response.status).to eq(400)\n      end\n\n      it \"logs user out from everywhere if token_id is not present\" do\n        post \"/u/#{user1.username}/preferences/revoke-auth-token.json\"\n\n        expect(response.status).to eq(200)\n        expect(user1.user_auth_tokens.count).to eq(0)\n      end\n    end\n  end\n\n  describe \"#list_second_factors\" do\n    let(:user) { user1 }\n\n    before { sign_in(user) }\n\n    context \"when SSO is enabled\" do\n      before do\n        SiteSetting.discourse_connect_url = \"https://discourse.test/sso\"\n        SiteSetting.enable_discourse_connect = true\n      end\n\n      it \"does not allow access\" do\n        post \"/u/second_factors.json\"\n        expect(response.status).to eq(404)\n      end\n    end\n\n    context \"when local logins are not enabled\" do\n      before { SiteSetting.enable_local_logins = false }\n\n      it \"does not allow access\" do\n        post \"/u/second_factors.json\"\n        expect(response.status).to eq(404)\n      end\n    end\n\n    context \"when the site settings allow second factors\" do\n      before do\n        SiteSetting.enable_local_logins = true\n        SiteSetting.enable_discourse_connect = false\n      end\n\n      context \"when the password parameter is not provided\" do\n        let(:password) { \"\" }\n\n        before { post \"/u/second_factors.json\", params: { password: password } }\n\n        it \"returns password required response\" do\n          expect(response.status).to eq(200)\n          response_body = response.parsed_body\n          expect(response_body[\"password_required\"]).to eq(true)\n        end\n      end\n\n      context \"when the password is provided\" do\n        fab!(:user) { Fabricate(:user, password: \"8555039dd212cc66ec68\") }\n\n        context \"when the password is correct\" do\n          let(:password) { \"8555039dd212cc66ec68\" }\n\n          it \"returns a list of enabled totps and security_key second factors\" do\n            totp_second_factor = Fabricate(:user_second_factor_totp, user: user)\n            security_key_second_factor =\n              Fabricate(\n                :user_security_key,\n                user: user,\n                factor_type: UserSecurityKey.factor_types[:second_factor],\n              )\n\n            post \"/u/second_factors.json\", params: { password: password }\n\n            expect(response.status).to eq(200)\n            response_body = response.parsed_body\n            expect(response_body[\"totps\"].map { |second_factor| second_factor[\"id\"] }).to include(\n              totp_second_factor.id,\n            )\n            expect(\n              response_body[\"security_keys\"].map { |second_factor| second_factor[\"id\"] },\n            ).to include(security_key_second_factor.id)\n          end\n        end\n\n        context \"when the password is not correct\" do\n          let(:password) { \"wrongpassword\" }\n\n          it \"returns the incorrect password response\" do\n            post \"/u/second_factors.json\", params: { password: password }\n\n            response_body = response.parsed_body\n            expect(response_body[\"error\"]).to eq(I18n.t(\"login.incorrect_password\"))\n          end\n        end\n      end\n    end\n  end\n\n  describe \"#feature_topic\" do\n    fab!(:topic) { Fabricate(:topic) }\n    fab!(:other_topic) { Fabricate(:topic) }\n    fab!(:private_message) { Fabricate(:private_message_topic, user: another_user) }\n    fab!(:category) { Fabricate(:category_with_definition) }\n\n    describe \"site setting enabled\" do\n      before { SiteSetting.allow_featured_topic_on_user_profiles = true }\n\n      it \"requires the user to be logged in\" do\n        put \"/u/#{user1.username}/feature-topic.json\", params: { topic_id: topic.id }\n        expect(response.status).to eq(403)\n      end\n\n      it \"returns an error if the user tries to set for another user\" do\n        sign_in(user1)\n        topic.update(user_id: another_user.id)\n        put \"/u/#{another_user.username}/feature-topic.json\", params: { topic_id: topic.id }\n        expect(response.status).to eq(403)\n      end\n\n      it \"returns an error if the topic is a PM\" do\n        sign_in(another_user)\n        put \"/u/#{another_user.username}/feature-topic.json\",\n            params: {\n              topic_id: private_message.id,\n            }\n        expect(response.status).to eq(403)\n      end\n\n      it \"returns an error if the topic is not visible\" do\n        sign_in(user1)\n        topic.update_status(\"visible\", false, user1)\n        put \"/u/#{user1.username}/feature-topic.json\", params: { topic_id: topic.id }\n        expect(response.status).to eq(403)\n      end\n\n      it \"returns an error if the topic's category is read_restricted\" do\n        sign_in(user1)\n        category.set_permissions({})\n        topic.update(category_id: category.id)\n        put \"/u/#{another_user.username}/feature-topic.json\", params: { topic_id: topic.id }\n        expect(response.status).to eq(403)\n      end\n\n      it \"sets featured_topic correctly for user created topic\" do\n        sign_in(user1)\n        topic.update(user_id: user1.id)\n        put \"/u/#{user1.username}/feature-topic.json\", params: { topic_id: topic.id }\n        expect(response.status).to eq(200)\n        expect(user1.user_profile.featured_topic).to eq topic\n      end\n\n      it \"sets featured_topic correctly for non-user-created topic\" do\n        sign_in(user1)\n        put \"/u/#{user1.username}/feature-topic.json\", params: { topic_id: other_topic.id }\n        expect(response.status).to eq(200)\n        expect(user1.user_profile.featured_topic).to eq other_topic\n      end\n\n      describe \"site setting disabled\" do\n        before { SiteSetting.allow_featured_topic_on_user_profiles = false }\n\n        it \"does not allow setting featured_topic for user_profiles\" do\n          sign_in(user1)\n          topic.update(user_id: user1.id)\n          put \"/u/#{user1.username}/feature-topic.json\", params: { topic_id: topic.id }\n          expect(response.status).to eq(403)\n        end\n      end\n    end\n  end\n\n  describe \"#clear_featured_topic\" do\n    fab!(:topic) { Fabricate(:topic) }\n\n    it \"requires the user to be logged in\" do\n      put \"/u/#{user1.username}/clear-featured-topic.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it \"returns an error if the the current user does not have access\" do\n      sign_in(user1)\n      topic.update(user_id: another_user.id)\n      put \"/u/#{another_user.username}/clear-featured-topic.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it \"clears the user_profiles featured_topic correctly\" do\n      sign_in(user1)\n      topic.update(user: user1)\n      put \"/u/#{user1.username}/clear-featured-topic.json\"\n      expect(response.status).to eq(200)\n      expect(user1.user_profile.featured_topic).to eq nil\n    end\n  end\n\n  describe \"#bookmarks\" do\n    before do\n      register_test_bookmarkable\n      TopicUser.change(user1.id, bookmark1.bookmarkable.topic_id, total_msecs_viewed: 1)\n      TopicUser.change(user1.id, bookmark2.bookmarkable_id, total_msecs_viewed: 1)\n      Fabricate(:post, topic: bookmark2.bookmarkable)\n      bookmark3 && bookmark4\n    end\n\n    after { DiscoursePluginRegistry.reset! }\n\n    let(:bookmark1) { Fabricate(:bookmark, user: user1, bookmarkable: Fabricate(:post)) }\n    let(:bookmark2) { Fabricate(:bookmark, user: user1, bookmarkable: Fabricate(:topic)) }\n    let(:bookmark3) { Fabricate(:bookmark, user: user1, bookmarkable: Fabricate(:user)) }\n    let(:bookmark4) { Fabricate(:bookmark) }\n\n    it \"returns a list of serialized bookmarks for the user\" do\n      sign_in(user1)\n      get \"/u/#{user1.username}/bookmarks.json\"\n      expect(response.status).to eq(200)\n      expect(\n        response.parsed_body[\"user_bookmark_list\"][\"bookmarks\"].map { |b| b[\"id\"] },\n      ).to match_array([bookmark1.id, bookmark2.id, bookmark3.id])\n    end\n\n    it \"returns a list of serialized bookmarks for the user including custom registered bookmarkables\" do\n      sign_in(user1)\n      bookmark3.bookmarkable.user_profile.update!(bio_raw: \"<p>Something cooked</p>\")\n      bookmark3.bookmarkable.user_profile.rebake!\n      get \"/u/#{user1.username}/bookmarks.json\"\n      expect(response.status).to eq(200)\n      response_bookmarks = response.parsed_body[\"user_bookmark_list\"][\"bookmarks\"]\n      expect(response_bookmarks.map { |b| b[\"id\"] }).to match_array(\n        [bookmark1.id, bookmark2.id, bookmark3.id],\n      )\n      expect(response_bookmarks.find { |b| b[\"id\"] == bookmark3.id }[\"excerpt\"]).to eq(\n        \"Something cooked\",\n      )\n    end\n\n    it \"returns an .ics file of bookmark reminders for the user in date order\" do\n      bookmark1.update!(name: nil, reminder_at: 1.day.from_now)\n      bookmark2.update!(name: \"Some bookmark note\", reminder_at: 1.week.from_now)\n      bookmark3.update!(name: nil, reminder_at: 2.weeks.from_now)\n\n      sign_in(user1)\n      get \"/u/#{user1.username}/bookmarks.ics\"\n      expect(response.status).to eq(200)\n      expect(response.body).to eq(<<~ICS)\n        BEGIN:VCALENDAR\n        VERSION:2.0\n        PRODID:-//Discourse//#{Discourse.current_hostname}//#{Discourse.full_version}//EN\n        BEGIN:VEVENT\n        UID:bookmark_reminder_##{bookmark1.id}@#{Discourse.current_hostname}\n        DTSTAMP:#{bookmark1.updated_at.strftime(I18n.t(\"datetime_formats.formats.calendar_ics\"))}\n        DTSTART:#{bookmark1.reminder_at_ics}\n        DTEND:#{bookmark1.reminder_at_ics(offset: 1.hour)}\n        SUMMARY:#{bookmark1.bookmarkable.topic.title}\n        DESCRIPTION:#{bookmark1.bookmarkable.full_url}\n        URL:#{bookmark1.bookmarkable.full_url}\n        END:VEVENT\n        BEGIN:VEVENT\n        UID:bookmark_reminder_##{bookmark2.id}@#{Discourse.current_hostname}\n        DTSTAMP:#{bookmark2.updated_at.strftime(I18n.t(\"datetime_formats.formats.calendar_ics\"))}\n        DTSTART:#{bookmark2.reminder_at_ics}\n        DTEND:#{bookmark2.reminder_at_ics(offset: 1.hour)}\n        SUMMARY:Some bookmark note\n        DESCRIPTION:#{bookmark2.bookmarkable.url}\n        URL:#{bookmark2.bookmarkable.url}\n        END:VEVENT\n        BEGIN:VEVENT\n        UID:bookmark_reminder_##{bookmark3.id}@#{Discourse.current_hostname}\n        DTSTAMP:#{bookmark3.updated_at.strftime(I18n.t(\"datetime_formats.formats.calendar_ics\"))}\n        DTSTART:#{bookmark3.reminder_at_ics}\n        DTEND:#{bookmark3.reminder_at_ics(offset: 1.hour)}\n        SUMMARY:#{bookmark3.bookmarkable.username}\n        DESCRIPTION:#{Discourse.base_url}/u/#{bookmark3.bookmarkable.username}\n        URL:#{Discourse.base_url}/u/#{bookmark3.bookmarkable.username}\n        END:VEVENT\n        END:VCALENDAR\n      ICS\n    end\n\n    it \"does not show another user's bookmarks\" do\n      sign_in(Fabricate(:user))\n      get \"/u/#{bookmark3.user.username}/bookmarks.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it \"shows a helpful message if no bookmarks are found\" do\n      bookmark1.destroy\n      bookmark2.destroy\n      bookmark3.destroy\n      sign_in(user1)\n      get \"/u/#{user1.username}/bookmarks.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"bookmarks\"]).to eq([])\n    end\n\n    it \"shows a helpful message if no bookmarks are found for the search\" do\n      sign_in(user1)\n      get \"/u/#{user1.username}/bookmarks.json\", params: { q: \"badsearch\" }\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"bookmarks\"]).to eq([])\n    end\n\n    describe \"when limit params is invalid\" do\n      before { sign_in(user1) }\n\n      include_examples \"invalid limit params\",\n                       \"/u/someusername/bookmarks.json\",\n                       described_class::BOOKMARKS_LIMIT\n    end\n  end\n\n  describe \"#bookmarks excerpts\" do\n    fab!(:user) { Fabricate(:user) }\n    let!(:topic) { Fabricate(:topic, user: user) }\n    let!(:post) { Fabricate(:post, topic: topic) }\n    let!(:bookmark) { Fabricate(:bookmark, name: \"Test\", user: user, bookmarkable: topic) }\n\n    it \"uses the first post of the topic for the bookmarks excerpt\" do\n      TopicUser.change(\n        user.id,\n        bookmark.bookmarkable.id,\n        { last_read_post_number: post.post_number },\n      )\n\n      sign_in(user)\n\n      get \"/u/#{user.username}/bookmarks.json\"\n      expect(response.status).to eq(200)\n      bookmark_list = response.parsed_body[\"user_bookmark_list\"][\"bookmarks\"]\n      expected_excerpt = PrettyText.excerpt(topic.first_post.cooked, 300, keep_emoji_images: true)\n      expect(bookmark_list.first[\"excerpt\"]).to eq(expected_excerpt)\n    end\n\n    describe \"bookmarkable_url\" do\n      context \"with the link_to_first_unread_post option\" do\n        it \"is a full topic URL to the first unread post in the topic when the option is set\" do\n          TopicUser.change(\n            user.id,\n            bookmark.bookmarkable.id,\n            { last_read_post_number: post.post_number },\n          )\n\n          sign_in(user)\n\n          get \"/u/#{user.username}/user-menu-bookmarks.json\"\n          expect(response.status).to eq(200)\n          bookmark_list = response.parsed_body[\"bookmarks\"]\n\n          expect(bookmark_list.first[\"bookmarkable_url\"]).to end_with(\n            \"/t/#{topic.slug}/#{topic.id}/#{post.post_number + 1}\",\n          )\n        end\n\n        it \"is a full topic URL to the first post in the topic when the option isn't set\" do\n          TopicUser.change(\n            user.id,\n            bookmark.bookmarkable.id,\n            { last_read_post_number: post.post_number },\n          )\n\n          sign_in(user)\n\n          get \"/u/#{user.username}/bookmarks.json\"\n          expect(response.status).to eq(200)\n          bookmark_list = response.parsed_body[\"user_bookmark_list\"][\"bookmarks\"]\n\n          expect(bookmark_list.first[\"bookmarkable_url\"]).to end_with(\n            \"/t/#{topic.slug}/#{topic.id}\",\n          )\n        end\n      end\n    end\n  end\n\n  describe \"#private_message_topic_tracking_state\" do\n    fab!(:user_2) { Fabricate(:user) }\n\n    fab!(:private_message) do\n      Group.refresh_automatic_groups!\n      create_post(\n        user: user1,\n        target_usernames: [user_2.username],\n        archetype: Archetype.private_message,\n      ).topic\n    end\n\n    before { sign_in(user_2) }\n\n    it \"does not allow an unauthorized user to access the state of another user\" do\n      get \"/u/#{user1.username}/private-message-topic-tracking-state.json\"\n\n      expect(response.status).to eq(403)\n    end\n\n    it \"returns the right response\" do\n      get \"/u/#{user_2.username}/private-message-topic-tracking-state.json\"\n\n      expect(response.status).to eq(200)\n\n      topic_state = response.parsed_body.first\n\n      expect(topic_state[\"topic_id\"]).to eq(private_message.id)\n      expect(topic_state[\"highest_post_number\"]).to eq(1)\n      expect(topic_state[\"last_read_post_number\"]).to eq(nil)\n      expect(topic_state[\"notification_level\"]).to eq(NotificationLevels.all[:watching])\n      expect(topic_state[\"group_ids\"]).to eq([])\n    end\n  end\n\n  describe \"#reset_recent_searches\" do\n    it \"does nothing for anon\" do\n      delete \"/u/recent-searches.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it \"works for logged in user\" do\n      freeze_time\n      sign_in(user1)\n      delete \"/u/recent-searches.json\"\n\n      expect(response.status).to eq(200)\n      user1.reload\n      expect(user1.user_option.oldest_search_log_date).to be_within(5.seconds).of(1.second.ago)\n    end\n  end\n\n  describe \"#recent_searches\" do\n    it \"does nothing for anon\" do\n      get \"/u/recent-searches.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it \"works for logged in user\" do\n      freeze_time\n      sign_in(user1)\n      SiteSetting.log_search_queries = true\n      user1.user_option.update!(oldest_search_log_date: nil)\n\n      get \"/u/recent-searches.json\"\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"recent_searches\"]).to eq([])\n\n      SearchLog.create!(\n        term: \"old one\",\n        user_id: user1.id,\n        search_type: 1,\n        ip_address: \"192.168.0.1\",\n        created_at: 5.minutes.ago,\n      )\n      SearchLog.create!(\n        term: \"also old\",\n        user_id: user1.id,\n        search_type: 1,\n        ip_address: \"192.168.0.1\",\n        created_at: 15.minutes.ago,\n      )\n\n      get \"/u/recent-searches.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"recent_searches\"]).to eq([\"old one\", \"also old\"])\n\n      user1.user_option.update!(oldest_search_log_date: 20.minutes.ago)\n\n      get \"/u/recent-searches.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"recent_searches\"]).to eq([\"old one\", \"also old\"])\n\n      user1.user_option.update!(oldest_search_log_date: 10.seconds.ago)\n\n      get \"/u/recent-searches.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"recent_searches\"]).to eq([])\n\n      SearchLog.create!(\n        term: \"new search\",\n        user_id: user1.id,\n        search_type: 1,\n        ip_address: \"192.168.0.1\",\n        created_at: 2.seconds.ago,\n      )\n\n      get \"/u/recent-searches.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"recent_searches\"]).to eq([\"new search\"])\n    end\n\n    it \"shows an error message when log_search_queries are off\" do\n      sign_in(user1)\n      SiteSetting.log_search_queries = false\n\n      get \"/u/recent-searches.json\"\n\n      expect(response.status).to eq(403)\n      expect(response.parsed_body[\"error\"]).to eq(I18n.t(\"user_activity.no_log_search_queries\"))\n    end\n  end\n\n  describe \"#user_menu_bookmarks\" do\n    fab!(:post) { Fabricate(:post) }\n    fab!(:topic) { Fabricate(:post).topic }\n    fab!(:bookmark_with_reminder) { Fabricate(:bookmark, user: user, bookmarkable: post) }\n    fab!(:bookmark_without_reminder) { Fabricate(:bookmark, user: user, bookmarkable: topic) }\n\n    before do\n      TopicUser.change(user.id, post.topic.id, total_msecs_viewed: 1)\n      TopicUser.change(user.id, topic.id, total_msecs_viewed: 1)\n      BookmarkReminderNotificationHandler.new(bookmark_with_reminder).send_notification\n    end\n\n    context \"when logged out\" do\n      it \"responds with 404\" do\n        get \"/u/#{user.username}/user-menu-bookmarks\"\n        expect(response.status).to eq(404)\n      end\n    end\n\n    context \"when logged in\" do\n      before { sign_in(user) }\n\n      it \"responds with 403 when requesting bookmarks list of another user\" do\n        get \"/u/#{user1.username}/user-menu-bookmarks\"\n        expect(response.status).to eq(403)\n      end\n\n      it \"sends an array of unread bookmark_reminder notifications\" do\n        bookmark_with_reminder2 = Fabricate(:bookmark, user: user, bookmarkable: Fabricate(:post))\n        TopicUser.change(user.id, bookmark_with_reminder2.bookmarkable.topic, total_msecs_viewed: 1)\n        BookmarkReminderNotificationHandler.new(bookmark_with_reminder2).send_notification\n\n        user\n          .notifications\n          .where(notification_type: Notification.types[:bookmark_reminder])\n          .where(\"data::json ->> 'bookmark_id' = ?\", bookmark_with_reminder2.id.to_s)\n          .first\n          .update!(read: true)\n\n        get \"/u/#{user.username}/user-menu-bookmarks\"\n        expect(response.status).to eq(200)\n\n        notifications = response.parsed_body[\"notifications\"]\n        expect(notifications.size).to eq(1)\n        expect(notifications.first[\"data\"][\"bookmark_id\"]).to eq(bookmark_with_reminder.id)\n      end\n\n      it \"responds with an array of bookmarks that are not associated with any of the unread bookmark_reminder notifications\" do\n        get \"/u/#{user.username}/user-menu-bookmarks\"\n        expect(response.status).to eq(200)\n\n        bookmarks = response.parsed_body[\"bookmarks\"]\n        expect(bookmarks.size).to eq(1)\n        expect(bookmarks.first[\"id\"]).to eq(bookmark_without_reminder.id)\n\n        bookmark_reminder =\n          user\n            .notifications\n            .where(notification_type: Notification.types[:bookmark_reminder])\n            .where(\"data::json ->> 'bookmark_id' = ?\", bookmark_with_reminder.id.to_s)\n            .first\n\n        bookmark_reminder.update!(read: true)\n        get \"/u/#{user.username}/user-menu-bookmarks\"\n        expect(response.status).to eq(200)\n\n        bookmarks = response.parsed_body[\"bookmarks\"]\n        expect(bookmarks.map { |bookmark| bookmark[\"id\"] }).to contain_exactly(\n          bookmark_with_reminder.id,\n          bookmark_without_reminder.id,\n        )\n\n        data = bookmark_reminder.data_hash\n        data.delete(:bookmark_id)\n        bookmark_reminder.update!(data: data.to_json, read: false)\n\n        get \"/u/#{user.username}/user-menu-bookmarks\"\n        expect(response.status).to eq(200)\n\n        notifications = response.parsed_body[\"notifications\"]\n        expect(notifications.size).to eq(1)\n        expect(notifications.first[\"data\"][\"bookmark_id\"]).to be_nil\n\n        bookmarks = response.parsed_body[\"bookmarks\"]\n        expect(bookmarks.map { |bookmark| bookmark[\"id\"] }).to contain_exactly(\n          bookmark_with_reminder.id,\n          bookmark_without_reminder.id,\n        )\n      end\n\n      it \"fills up the remaining of the USER_MENU_LIST_LIMIT limit with bookmarks\" do\n        bookmark2 = Fabricate(:bookmark, user: user, bookmarkable: Fabricate(:post, topic: topic))\n\n        stub_const(UsersController, \"USER_MENU_LIST_LIMIT\", 2) do\n          get \"/u/#{user.username}/user-menu-bookmarks\"\n        end\n        expect(response.status).to eq(200)\n\n        notifications = response.parsed_body[\"notifications\"]\n        expect(notifications.size).to eq(1)\n\n        bookmarks = response.parsed_body[\"bookmarks\"]\n        expect(bookmarks.size).to eq(1)\n\n        stub_const(UsersController, \"USER_MENU_LIST_LIMIT\", 3) do\n          get \"/u/#{user.username}/user-menu-bookmarks\"\n        end\n        expect(response.status).to eq(200)\n\n        notifications = response.parsed_body[\"notifications\"]\n        expect(notifications.size).to eq(1)\n\n        bookmarks = response.parsed_body[\"bookmarks\"]\n        expect(bookmarks.size).to eq(2)\n\n        BookmarkReminderNotificationHandler.new(bookmark2).send_notification\n\n        stub_const(UsersController, \"USER_MENU_LIST_LIMIT\", 3) do\n          get \"/u/#{user.username}/user-menu-bookmarks\"\n        end\n        expect(response.status).to eq(200)\n\n        notifications = response.parsed_body[\"notifications\"]\n        expect(notifications.size).to eq(2)\n\n        bookmarks = response.parsed_body[\"bookmarks\"]\n        expect(bookmarks.size).to eq(1)\n      end\n    end\n  end\n\n  describe \"#user_menu_messages\" do\n    fab!(:group1) { Fabricate(:group, has_messages: true, users: [user]) }\n    fab!(:group2) { Fabricate(:group, has_messages: true, users: [user, user1]) }\n    fab!(:group3) { Fabricate(:group, has_messages: true, users: [user1]) }\n\n    fab!(:message_without_notification) { Fabricate(:private_message_post, recipient: user).topic }\n    fab!(:message_with_read_notification) do\n      Fabricate(:private_message_post, recipient: user).topic\n    end\n    fab!(:message_with_unread_notification) do\n      Fabricate(:private_message_post, recipient: user).topic\n    end\n    fab!(:archived_message) { Fabricate(:private_message_post, recipient: user).topic }\n\n    fab!(:group_message1) { Fabricate(:group_private_message_post, recipients: group1).topic }\n    fab!(:group_message2) { Fabricate(:group_private_message_post, recipients: group2).topic }\n    fab!(:group_message3) { Fabricate(:group_private_message_post, recipients: group3).topic }\n\n    fab!(:archived_group_message1) do\n      Fabricate(:group_private_message_post, recipients: group1).topic\n    end\n    fab!(:archived_group_message2) do\n      Fabricate(:group_private_message_post, recipients: group2).topic\n    end\n\n    fab!(:user1_message_without_notification) do\n      Fabricate(:private_message_post, recipient: user1).topic\n    end\n    fab!(:user1_message_with_read_notification) do\n      Fabricate(:private_message_post, recipient: user1).topic\n    end\n    fab!(:user1_message_with_unread_notification) do\n      Fabricate(:private_message_post, recipient: user1).topic\n    end\n    fab!(:user1_archived_message) { Fabricate(:private_message_post, recipient: user1).topic }\n\n    fab!(:unread_pm_notification) do\n      Fabricate(\n        :private_message_notification,\n        read: false,\n        user: user,\n        topic: message_with_unread_notification,\n        created_at: 4.minutes.ago,\n      )\n    end\n    fab!(:read_pm_notification) do\n      Fabricate(\n        :private_message_notification,\n        read: true,\n        user: user,\n        topic: message_with_read_notification,\n      )\n    end\n\n    fab!(:unread_group_message_summary_notification) do\n      Fabricate(\n        :notification,\n        read: false,\n        user: user,\n        notification_type: Notification.types[:group_message_summary],\n        created_at: 2.minutes.ago,\n      )\n    end\n\n    fab!(:read_group_message_summary_notification) do\n      Fabricate(\n        :notification,\n        read: true,\n        user: user,\n        notification_type: Notification.types[:group_message_summary],\n        created_at: 1.minutes.ago,\n      )\n    end\n\n    fab!(:user1_unread_pm_notification) do\n      Fabricate(\n        :private_message_notification,\n        read: false,\n        user: user1,\n        topic: user1_message_with_unread_notification,\n      )\n    end\n    fab!(:user1_read_pm_notification) do\n      Fabricate(\n        :private_message_notification,\n        read: true,\n        user: user1,\n        topic: user1_message_with_read_notification,\n      )\n    end\n\n    fab!(:user1_unread_group_message_summary_notification) do\n      Fabricate(\n        :notification,\n        read: false,\n        user: user1,\n        notification_type: Notification.types[:group_message_summary],\n      )\n    end\n    fab!(:user1_read_group_message_summary_notification) do\n      Fabricate(\n        :notification,\n        read: true,\n        user: user1,\n        notification_type: Notification.types[:group_message_summary],\n      )\n    end\n\n    before do\n      UserArchivedMessage.archive!(user.id, archived_message)\n      UserArchivedMessage.archive!(user1.id, user1_archived_message)\n      GroupArchivedMessage.archive!(group1.id, archived_group_message1)\n      GroupArchivedMessage.archive!(group2.id, archived_group_message2)\n    end\n\n    context \"when logged out\" do\n      it \"responds with 404\" do\n        get \"/u/#{user.username}/user-menu-private-messages\"\n        expect(response.status).to eq(404)\n      end\n    end\n\n    context \"when logged in\" do\n      before { sign_in(user) }\n\n      it \"responds with 403 when requesting messages list of another user\" do\n        get \"/u/#{user1.username}/user-menu-private-messages\"\n        expect(response.status).to eq(403)\n      end\n\n      it \"responds with 403 if personal_message_enabled_groups does not include the user and the user isn't staff\" do\n        SiteSetting.personal_message_enabled_groups = Group::AUTO_GROUPS[:trust_level_4]\n        user.update(trust_level: 1)\n        get \"/u/#{user.username}/user-menu-private-messages\"\n        expect(response.status).to eq(403)\n      end\n\n      it \"sends an array of unread private_message notifications\" do\n        get \"/u/#{user.username}/user-menu-private-messages\"\n        expect(response.status).to eq(200)\n\n        unread_notifications = response.parsed_body[\"unread_notifications\"]\n        expect(unread_notifications.map { |notification| notification[\"id\"] }).to eq(\n          [unread_pm_notification.id, unread_group_message_summary_notification.id],\n        )\n      end\n\n      it \"sends an array of read group_message_summary notifications\" do\n        read_group_message_summary_notification2 =\n          Fabricate(\n            :notification,\n            read: true,\n            user: user,\n            notification_type: Notification.types[:group_message_summary],\n            created_at: 5.minutes.ago,\n          )\n        get \"/u/#{user.username}/user-menu-private-messages\"\n        expect(response.status).to eq(200)\n\n        read_notifications = response.parsed_body[\"read_notifications\"]\n        expect(read_notifications.map { |notification| notification[\"id\"] }).to eq(\n          [read_group_message_summary_notification.id, read_group_message_summary_notification2.id],\n        )\n      end\n\n      it \"responds with an array of personal messages and user watching group messages that are not associated with any of the unread private_message notifications\" do\n        group_message1.update!(bumped_at: 1.minutes.ago)\n        message_without_notification.update!(bumped_at: 3.minutes.ago)\n        group_message2.update!(bumped_at: 6.minutes.ago)\n        message_with_read_notification.update!(bumped_at: 10.minutes.ago)\n        read_group_message_summary_notification.destroy!\n\n        TopicUser.create!(\n          user: user,\n          topic: group_message1,\n          notification_level: TopicUser.notification_levels[:watching],\n        )\n        TopicUser.create!(\n          user: user,\n          topic: group_message2,\n          notification_level: TopicUser.notification_levels[:regular],\n        )\n\n        get \"/u/#{user.username}/user-menu-private-messages\"\n        expect(response.status).to eq(200)\n\n        topics = response.parsed_body[\"topics\"]\n\n        expect(topics.map { |topic| topic[\"id\"] }).to eq(\n          [group_message1.id, message_without_notification.id, message_with_read_notification.id],\n        )\n      end\n\n      it \"fills up the remaining of the USER_MENU_LIST_LIMIT limit with PM topics\" do\n        stub_const(UsersController, \"USER_MENU_LIST_LIMIT\", 3) do\n          get \"/u/#{user.username}/user-menu-private-messages\"\n        end\n        expect(response.status).to eq(200)\n        unread_notifications = response.parsed_body[\"unread_notifications\"]\n        expect(unread_notifications.size).to eq(2)\n\n        topics = response.parsed_body[\"topics\"]\n        read_notifications = response.parsed_body[\"read_notifications\"]\n        expect(topics.size).to eq(1)\n        expect(read_notifications.size).to eq(1)\n\n        message2 = Fabricate(:private_message_post, recipient: user).topic\n        Fabricate(:private_message_notification, read: false, user: user, topic: message2)\n\n        stub_const(UsersController, \"USER_MENU_LIST_LIMIT\", 2) do\n          get \"/u/#{user.username}/user-menu-private-messages\"\n        end\n        expect(response.status).to eq(200)\n        unread_notifications = response.parsed_body[\"unread_notifications\"]\n        expect(unread_notifications.size).to eq(2)\n\n        topics = response.parsed_body[\"topics\"]\n        read_notifications = response.parsed_body[\"read_notifications\"]\n        expect(topics.size).to eq(0)\n        expect(read_notifications.size).to eq(0)\n      end\n    end\n  end\n\n  def create_second_factor_security_key\n    sign_in(user1)\n    stub_secure_session_confirmed\n    post \"/u/create_second_factor_security_key.json\"\n  end\n\n  def stub_secure_session_confirmed\n    UsersController.any_instance.stubs(:secure_session_confirmed?).returns(true)\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\nRSpec.describe PostBookmarkable do\n  subject(:registered_bookmarkable) { RegisteredBookmarkable.new(PostBookmarkable) }\n\n  fab!(:user) { Fabricate(:user) }\n  fab!(:private_category) { Fabricate(:private_category, group: Fabricate(:group)) }\n\n  let(:guardian) { Guardian.new(user) }\n\n  let!(:post1) { Fabricate(:post) }\n  let!(:post2) { Fabricate(:post) }\n  let!(:bookmark1) do\n    Fabricate(:bookmark, user: user, bookmarkable: post1, name: \"something i gotta do\")\n  end\n  let!(:bookmark2) { Fabricate(:bookmark, user: user, bookmarkable: post2) }\n  let!(:bookmark3) { Fabricate(:bookmark) }\n  let!(:topic_user1) { Fabricate(:topic_user, user: user, topic: post1.topic) }\n  let!(:topic_user2) { Fabricate(:topic_user, user: user, topic: post2.topic) }\n\n  describe \"#perform_list_query\" do\n    it \"returns all the user's bookmarks\" do\n      expect(registered_bookmarkable.perform_list_query(user, guardian).map(&:id)).to match_array(\n        [bookmark1.id, bookmark2.id],\n      )\n    end\n\n    it \"does not return bookmarks for posts where the user does not have access to the topic category\" do\n      bookmark1.bookmarkable.topic.update(category: private_category)\n      expect(registered_bookmarkable.perform_list_query(user, guardian).map(&:id)).to match_array(\n        [bookmark2.id],\n      )\n    end\n\n    it \"does not return bookmarks for posts where the user does not have access to the private message\" do\n      bookmark1.bookmarkable.update(topic: Fabricate(:private_message_topic))\n      expect(registered_bookmarkable.perform_list_query(user, guardian).map(&:id)).to match_array(\n        [bookmark2.id],\n      )\n    end\n  end\n\n  describe \"#perform_search_query\" do\n    before { SearchIndexer.enable }\n\n    it \"returns bookmarks that match by name\" do\n      ts_query = Search.ts_query(term: \"gotta\", ts_config: \"simple\")\n      expect(\n        registered_bookmarkable.perform_search_query(\n          registered_bookmarkable.perform_list_query(user, guardian),\n          \"%gotta%\",\n          ts_query,\n        ).map(&:id),\n      ).to match_array([bookmark1.id])\n    end\n\n    it \"returns bookmarks that match by post search data (topic title or post content)\" do\n      post2.update(raw: \"some post content\")\n      post2.topic.update(title: \"a great topic title\")\n\n      ts_query = Search.ts_query(term: \"post content\", ts_config: \"simple\")\n      expect(\n        registered_bookmarkable.perform_search_query(\n          registered_bookmarkable.perform_list_query(user, guardian),\n          \"%post content%\",\n          ts_query,\n        ).map(&:id),\n      ).to match_array([bookmark2.id])\n\n      ts_query = Search.ts_query(term: \"great topic\", ts_config: \"simple\")\n      expect(\n        registered_bookmarkable.perform_search_query(\n          registered_bookmarkable.perform_list_query(user, guardian),\n          \"%great topic%\",\n          ts_query,\n        ).map(&:id),\n      ).to match_array([bookmark2.id])\n\n      ts_query = Search.ts_query(term: \"blah\", ts_config: \"simple\")\n      expect(\n        registered_bookmarkable.perform_search_query(\n          registered_bookmarkable.perform_list_query(user, guardian),\n          \"%blah%\",\n          ts_query,\n        ).map(&:id),\n      ).to eq([])\n    end\n  end\n\n  describe \"#can_send_reminder?\" do\n    it \"cannot send reminder if the post or topic is deleted\" do\n      expect(registered_bookmarkable.can_send_reminder?(bookmark1)).to eq(true)\n      bookmark1.bookmarkable.trash!\n      bookmark1.reload\n      expect(registered_bookmarkable.can_send_reminder?(bookmark1)).to eq(false)\n      Post.with_deleted.find_by(id: bookmark1.bookmarkable_id).recover!\n      bookmark1.reload\n      bookmark1.bookmarkable.topic.trash!\n      bookmark1.reload\n      expect(registered_bookmarkable.can_send_reminder?(bookmark1)).to eq(false)\n    end\n  end\n\n  describe \"#reminder_handler\" do\n    it \"creates a notification for the user with the correct details\" do\n      expect { registered_bookmarkable.send_reminder_notification(bookmark1) }.to change {\n        Notification.count\n      }.by(1)\n      notif = user.notifications.last\n      expect(notif.notification_type).to eq(Notification.types[:bookmark_reminder])\n      expect(notif.topic_id).to eq(bookmark1.bookmarkable.topic_id)\n      expect(notif.post_number).to eq(bookmark1.bookmarkable.post_number)\n      expect(notif.data).to eq(\n        {\n          title: bookmark1.bookmarkable.topic.title,\n          bookmarkable_url: bookmark1.bookmarkable.url,\n          display_username: bookmark1.user.username,\n          bookmark_name: bookmark1.name,\n          bookmark_id: bookmark1.id,\n        }.to_json,\n      )\n    end\n  end\n\n  describe \"#can_see?\" do\n    it \"returns false if the post is in a private category or private message the user cannot see\" do\n      expect(registered_bookmarkable.can_see?(guardian, bookmark1)).to eq(true)\n      bookmark1.bookmarkable.topic.update(category: private_category)\n      expect(registered_bookmarkable.can_see?(guardian, bookmark1)).to eq(false)\n      bookmark1.bookmarkable.update(topic: Fabricate(:private_message_topic))\n      expect(registered_bookmarkable.can_see?(guardian, bookmark1)).to eq(false)\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\nRSpec.describe TopicBookmarkable do\n  subject(:registered_bookmarkable) { RegisteredBookmarkable.new(TopicBookmarkable) }\n\n  fab!(:user) { Fabricate(:user) }\n  fab!(:private_category) { Fabricate(:private_category, group: Fabricate(:group)) }\n\n  let(:guardian) { Guardian.new(user) }\n\n  let!(:topic1) { Fabricate(:topic) }\n  let!(:topic2) { Fabricate(:topic) }\n  let!(:post) { Fabricate(:post, topic: topic1) }\n  let!(:bookmark1) do\n    Fabricate(:bookmark, user: user, bookmarkable: topic1, name: \"something i gotta do\")\n  end\n  let!(:bookmark2) { Fabricate(:bookmark, user: user, bookmarkable: topic2) }\n  let!(:bookmark3) { Fabricate(:bookmark) }\n  let!(:topic_user1) { Fabricate(:topic_user, user: user, topic: topic1) }\n  let!(:topic_user2) { Fabricate(:topic_user, user: user, topic: topic2) }\n\n  describe \"#perform_list_query\" do\n    it \"returns all the user's bookmarks\" do\n      expect(registered_bookmarkable.perform_list_query(user, guardian).map(&:id)).to match_array(\n        [bookmark1.id, bookmark2.id],\n      )\n    end\n\n    it \"does not return bookmarks for posts where the user does not have access to the topic category\" do\n      bookmark1.bookmarkable.update!(category: private_category)\n      expect(registered_bookmarkable.perform_list_query(user, guardian).map(&:id)).to match_array(\n        [bookmark2.id],\n      )\n    end\n\n    it \"does not return bookmarks for posts where the user does not have access to the private message\" do\n      bookmark1.update!(bookmarkable: Fabricate(:private_message_topic))\n      expect(registered_bookmarkable.perform_list_query(user, guardian).map(&:id)).to match_array(\n        [bookmark2.id],\n      )\n    end\n  end\n\n  describe \"#perform_search_query\" do\n    before { SearchIndexer.enable }\n\n    it \"returns bookmarks that match by name\" do\n      ts_query = Search.ts_query(term: \"gotta\", ts_config: \"simple\")\n      expect(\n        registered_bookmarkable.perform_search_query(\n          registered_bookmarkable.perform_list_query(user, guardian),\n          \"%gotta%\",\n          ts_query,\n        ).map(&:id),\n      ).to match_array([bookmark1.id])\n    end\n\n    it \"returns bookmarks that match by post search data (topic title or post content)\" do\n      post.update(raw: \"some post content\")\n      topic1.update(title: \"a great topic title\")\n\n      ts_query = Search.ts_query(term: \"post content\", ts_config: \"simple\")\n      expect(\n        registered_bookmarkable.perform_search_query(\n          registered_bookmarkable.perform_list_query(user, guardian),\n          \"%post content%\",\n          ts_query,\n        ).map(&:id),\n      ).to match_array([bookmark1.id])\n\n      ts_query = Search.ts_query(term: \"great topic\", ts_config: \"simple\")\n      expect(\n        registered_bookmarkable.perform_search_query(\n          registered_bookmarkable.perform_list_query(user, guardian),\n          \"%great topic%\",\n          ts_query,\n        ).map(&:id),\n      ).to match_array([bookmark1.id])\n\n      ts_query = Search.ts_query(term: \"blah\", ts_config: \"simple\")\n      expect(\n        registered_bookmarkable.perform_search_query(\n          registered_bookmarkable.perform_list_query(user, guardian),\n          \"%blah%\",\n          ts_query,\n        ).map(&:id),\n      ).to eq([])\n    end\n  end\n\n  describe \"#can_send_reminder?\" do\n    it \"cannot send reminder if the topic is deleted\" do\n      expect(registered_bookmarkable.can_send_reminder?(bookmark1)).to eq(true)\n      bookmark1.bookmarkable.trash!\n      bookmark1.reload\n      expect(registered_bookmarkable.can_send_reminder?(bookmark1)).to eq(false)\n    end\n  end\n\n  describe \"#reminder_handler\" do\n    it \"creates a notification for the user with the correct details\" do\n      expect { registered_bookmarkable.send_reminder_notification(bookmark1) }.to change {\n        Notification.count\n      }.by(1)\n      notif = user.notifications.last\n      expect(notif.notification_type).to eq(Notification.types[:bookmark_reminder])\n      expect(notif.topic_id).to eq(bookmark1.bookmarkable_id)\n      expect(notif.post_number).to eq(1)\n      expect(notif.data).to eq(\n        {\n          title: bookmark1.bookmarkable.title,\n          bookmarkable_url: bookmark1.bookmarkable.first_post.url,\n          display_username: bookmark1.user.username,\n          bookmark_name: bookmark1.name,\n          bookmark_id: bookmark1.id,\n        }.to_json,\n      )\n    end\n  end\n\n  describe \"#can_see?\" do\n    it \"returns false if the post is in a private category or private message the user cannot see\" do\n      expect(registered_bookmarkable.can_see?(guardian, bookmark1)).to eq(true)\n      bookmark1.bookmarkable.update!(category: private_category)\n      expect(registered_bookmarkable.can_see?(guardian, bookmark1)).to eq(false)\n      bookmark1.update!(bookmarkable: Fabricate(:private_message_topic))\n      expect(registered_bookmarkable.can_see?(guardian, bookmark1)).to eq(false)\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nclass NotificationsController < ApplicationController\n  requires_login\n  before_action :ensure_admin, only: %i[create update destroy]\n  before_action :set_notification, only: %i[update destroy]\n\n  INDEX_LIMIT = 50\n\n  def index\n    user =\n      if params[:username] && !params[:recent]\n        user_record = User.find_by(username: params[:username].to_s)\n        raise Discourse::NotFound if !user_record\n        user_record\n      else\n        current_user\n      end\n\n    guardian.ensure_can_see_notifications!(user)\n\n    if notification_types = params[:filter_by_types]&.split(\",\").presence\n      notification_types.map! do |type|\n        Notification.types[type.to_sym] ||\n          (raise Discourse::InvalidParameters.new(\"invalid notification type: #{type}\"))\n      end\n    end\n\n    if params[:recent].present?\n      limit = fetch_limit_from_params(default: 15, max: INDEX_LIMIT)\n\n      include_reviewables = false\n\n      notifications =\n        Notification.prioritized_list(current_user, count: limit, types: notification_types)\n      # notification_types is blank for the \"all notifications\" user menu tab\n      include_reviewables = notification_types.blank? && guardian.can_see_review_queue?\n\n      if notifications.present? && !(params.has_key?(:silent) || @readonly_mode)\n        if current_user.bump_last_seen_notification!\n          current_user.reload\n          current_user.publish_notifications_state\n        end\n      end\n\n      if !params.has_key?(:silent) && params[:bump_last_seen_reviewable] && !@readonly_mode &&\n           include_reviewables\n        current_user_id = current_user.id\n        Scheduler::Defer.later \"bump last seen reviewable for user\" do\n          # we lookup current_user again in the background thread to avoid\n          # concurrency issues where the user object returned by the\n          # current_user controller method is changed by the time the deferred\n          # block is executed\n          User.find_by(id: current_user_id)&.bump_last_seen_reviewable!\n        end\n      end\n\n      notifications =\n        Notification.filter_inaccessible_topic_notifications(current_user.guardian, notifications)\n\n      json = {\n        notifications: serialize_data(notifications, NotificationSerializer),\n        seen_notification_id: current_user.seen_notification_id,\n      }\n\n      if include_reviewables\n        json[:pending_reviewables] = Reviewable.basic_serializers_for_list(\n          Reviewable.user_menu_list_for(current_user),\n          current_user,\n        ).as_json\n      end\n\n      render_json_dump(json)\n    else\n      offset = params[:offset].to_i\n\n      notifications =\n        Notification.where(user_id: user.id).visible.includes(:topic).order(created_at: :desc)\n\n      notifications = notifications.where(read: true) if params[:filter] == \"read\"\n\n      notifications = notifications.where(read: false) if params[:filter] == \"unread\"\n\n      total_rows = notifications.dup.count\n      notifications = notifications.offset(offset).limit(60)\n      notifications =\n        Notification.filter_inaccessible_topic_notifications(current_user.guardian, notifications)\n      render_json_dump(\n        notifications: serialize_data(notifications, NotificationSerializer),\n        total_rows_notifications: total_rows,\n        seen_notification_id: user.seen_notification_id,\n        load_more_notifications:\n          notifications_path(username: user.username, offset: offset + 60, filter: params[:filter]),\n      )\n    end\n  end\n\n  def mark_read\n    if params[:id]\n      Notification.read(current_user, [params[:id].to_i])\n    else\n      if types = params[:dismiss_types]&.split(\",\").presence\n        invalid = []\n        types.map! do |type|\n          type_id = Notification.types[type.to_sym]\n          invalid << type if !type_id\n          type_id\n        end\n        if invalid.size > 0\n          raise Discourse::InvalidParameters.new(\"invalid notification types: #{invalid.inspect}\")\n        end\n      end\n\n      Notification.read_types(current_user, types)\n      current_user.bump_last_seen_notification!\n    end\n\n    current_user.reload\n    current_user.publish_notifications_state\n\n    render json: success_json\n  end\n\n  def create\n    @notification = Notification.consolidate_or_create!(notification_params)\n    render_notification\n  end\n\n  def update\n    @notification.update!(notification_params)\n    render_notification\n  end\n\n  def destroy\n    @notification.destroy!\n    render json: success_json\n  end\n\n  private\n\n  def set_notification\n    @notification = Notification.find(params[:id])\n  end\n\n  def notification_params\n    params.permit(\n      :notification_type,\n      :user_id,\n      :data,\n      :read,\n      :topic_id,\n      :post_number,\n      :post_action_id,\n    )\n  end\n\n  def render_notification\n    render_json_dump(NotificationSerializer.new(@notification, scope: guardian, root: false))\n  end\nend\n", "# frozen_string_literal: true\n\nclass UsersController < ApplicationController\n  skip_before_action :authorize_mini_profiler, only: [:avatar]\n\n  requires_login only: %i[\n                   username\n                   update\n                   upload_user_image\n                   pick_avatar\n                   destroy_user_image\n                   destroy\n                   check_emails\n                   topic_tracking_state\n                   preferences\n                   create_second_factor_totp\n                   enable_second_factor_totp\n                   disable_second_factor\n                   list_second_factors\n                   update_second_factor\n                   create_second_factor_backup\n                   select_avatar\n                   notification_level\n                   revoke_auth_token\n                   register_second_factor_security_key\n                   create_second_factor_security_key\n                   feature_topic\n                   clear_featured_topic\n                   bookmarks\n                   invited\n                   check_sso_email\n                   check_sso_payload\n                   recent_searches\n                   reset_recent_searches\n                   user_menu_bookmarks\n                   user_menu_messages\n                 ]\n\n  skip_before_action :check_xhr,\n                     only: %i[\n                       show\n                       badges\n                       password_reset_show\n                       password_reset_update\n                       update\n                       account_created\n                       activate_account\n                       perform_account_activation\n                       avatar\n                       my_redirect\n                       toggle_anon\n                       admin_login\n                       confirm_admin\n                       email_login\n                       summary\n                       feature_topic\n                       clear_featured_topic\n                       bookmarks\n                       user_menu_bookmarks\n                       user_menu_messages\n                     ]\n\n  before_action :second_factor_check_confirmed_password,\n                only: %i[\n                  create_second_factor_totp\n                  enable_second_factor_totp\n                  disable_second_factor\n                  update_second_factor\n                  create_second_factor_backup\n                  register_second_factor_security_key\n                  create_second_factor_security_key\n                ]\n\n  before_action :respond_to_suspicious_request, only: [:create]\n\n  # we need to allow account creation with bad CSRF tokens, if people are caching, the CSRF token on the\n  #  page is going to be empty, this means that server will see an invalid CSRF and blow the session\n  #  once that happens you can't log in with social\n  skip_before_action :verify_authenticity_token, only: [:create]\n  skip_before_action :redirect_to_login_if_required,\n                     only: %i[\n                       check_username\n                       check_email\n                       create\n                       account_created\n                       activate_account\n                       perform_account_activation\n                       send_activation_email\n                       update_activation_email\n                       password_reset_show\n                       password_reset_update\n                       confirm_email_token\n                       email_login\n                       admin_login\n                       confirm_admin\n                     ]\n\n  after_action :add_noindex_header, only: %i[show my_redirect]\n\n  allow_in_staff_writes_only_mode :admin_login\n  allow_in_staff_writes_only_mode :email_login\n\n  MAX_RECENT_SEARCHES = 5\n\n  def index\n  end\n\n  def show(for_card: false)\n    return redirect_to path(\"/login\") if !guardian.public_can_see_profiles?\n\n    @user =\n      fetch_user_from_params(\n        include_inactive: current_user&.staff? || for_card || SiteSetting.show_inactive_accounts,\n      )\n\n    user_serializer = nil\n    if !current_user&.staff? && !@user.active?\n      user_serializer = InactiveUserSerializer.new(@user, scope: guardian, root: \"user\")\n    elsif !guardian.can_see_profile?(@user)\n      user_serializer = HiddenProfileSerializer.new(@user, scope: guardian, root: \"user\")\n    else\n      serializer_class = for_card ? UserCardSerializer : UserSerializer\n      user_serializer = serializer_class.new(@user, scope: guardian, root: \"user\")\n\n      topic_id = params[:include_post_count_for].to_i\n      if topic_id != 0 && guardian.can_see?(Topic.find_by_id(topic_id))\n        user_serializer.topic_post_count = {\n          topic_id => Post.secured(guardian).where(topic_id: topic_id, user_id: @user.id).count,\n        }\n      end\n    end\n\n    track_visit_to_user_profile if !params[:skip_track_visit] && (@user != current_user)\n\n    # This is a hack to get around a Rails issue where values with periods aren't handled correctly\n    # when used as part of a route.\n    if params[:external_id] && params[:external_id].ends_with?(\".json\")\n      return render_json_dump(user_serializer)\n    end\n\n    respond_to do |format|\n      format.html do\n        @restrict_fields = guardian.restrict_user_fields?(@user)\n        store_preloaded(\"user_#{@user.username}\", MultiJson.dump(user_serializer))\n        render :show\n      end\n\n      format.json { render_json_dump(user_serializer) }\n    end\n  end\n\n  def show_card\n    show(for_card: true)\n  end\n\n  # This route is not used in core, but is used by theme components (e.g. https://meta.discourse.org/t/144479)\n  def cards\n    return redirect_to path(\"/login\") if !guardian.public_can_see_profiles?\n\n    user_ids = params.require(:user_ids).split(\",\").map(&:to_i)\n    raise Discourse::InvalidParameters.new(:user_ids) if user_ids.length > 50\n\n    users =\n      User.where(id: user_ids).includes(\n        :user_option,\n        :user_stat,\n        :default_featured_user_badges,\n        :user_profile,\n        :card_background_upload,\n        :primary_group,\n        :flair_group,\n        :primary_email,\n        :user_status,\n      )\n\n    users = users.filter { |u| guardian.can_see_profile?(u) }\n\n    preload_fields =\n      User.allowed_user_custom_fields(guardian) +\n        UserField.all.pluck(:id).map { |fid| \"#{User::USER_FIELD_PREFIX}#{fid}\" }\n    User.preload_custom_fields(users, preload_fields)\n    User.preload_recent_time_read(users)\n\n    render json: users, each_serializer: UserCardSerializer\n  end\n\n  def badges\n    raise Discourse::NotFound unless SiteSetting.enable_badges?\n    show\n  end\n\n  def update\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n    attributes = user_params\n\n    # We can't update the username via this route. Use the username route\n    attributes.delete(:username)\n\n    if params[:user_fields].present?\n      attributes[:custom_fields] ||= {}\n\n      fields = UserField.all\n      fields = fields.where(editable: true) unless current_user.staff?\n      fields.each do |field|\n        field_id = field.id.to_s\n        next unless params[:user_fields].has_key?(field_id)\n\n        value = clean_custom_field_values(field)\n        value = nil if value === \"false\"\n        value = value[0...UserField.max_length] if value\n\n        if value.blank? && field.required?\n          return render_json_error(I18n.t(\"login.missing_user_field\"))\n        end\n        attributes[:custom_fields][\"#{User::USER_FIELD_PREFIX}#{field.id}\"] = value\n      end\n    end\n\n    if params[:external_ids]&.is_a?(ActionController::Parameters) && current_user&.admin? && is_api?\n      attributes[:user_associated_accounts] = []\n\n      params[:external_ids].each do |provider_name, provider_uid|\n        if provider_name == \"discourse_connect\"\n          unless SiteSetting.enable_discourse_connect\n            raise Discourse::InvalidParameters.new(:external_ids)\n          end\n\n          attributes[:discourse_connect] = { external_id: provider_uid }\n\n          next\n        end\n\n        authenticator = Discourse.enabled_authenticators.find { |a| a.name == provider_name }\n        raise Discourse::InvalidParameters.new(:external_ids) if !authenticator&.is_managed?\n\n        attributes[:user_associated_accounts] << {\n          provider_name: provider_name,\n          provider_uid: provider_uid,\n        }\n      end\n    end\n\n    json_result(\n      user,\n      serializer: UserSerializer,\n      additional_errors: %i[user_profile user_option],\n    ) do |u|\n      updater = UserUpdater.new(current_user, user)\n      updater.update(attributes.permit!)\n    end\n  end\n\n  def username\n    params.require(:new_username)\n\n    if clashing_with_existing_route?(params[:new_username]) ||\n         User.reserved_username?(params[:new_username])\n      return render_json_error(I18n.t(\"login.reserved_username\"))\n    end\n\n    user = fetch_user_from_params\n    guardian.ensure_can_edit_username!(user)\n\n    result = UsernameChanger.change(user, params[:new_username], current_user)\n\n    if result\n      render json: { id: user.id, username: user.username }\n    else\n      render_json_error(user.errors.full_messages.join(\",\"))\n    end\n  rescue Discourse::InvalidAccess\n    if current_user&.staff?\n      render_json_error(I18n.t(\"errors.messages.auth_overrides_username\"))\n    else\n      render json: failed_json, status: 403\n    end\n  end\n\n  def check_emails\n    user = fetch_user_from_params(include_inactive: true)\n\n    unless user == current_user\n      guardian.ensure_can_check_emails!(user)\n      StaffActionLogger.new(current_user).log_check_email(user, context: params[:context])\n    end\n\n    email, *secondary_emails = user.emails\n    unconfirmed_emails = user.unconfirmed_emails\n\n    render json: {\n             email: email,\n             secondary_emails: secondary_emails,\n             unconfirmed_emails: unconfirmed_emails,\n             associated_accounts: user.associated_accounts,\n           }\n  rescue Discourse::InvalidAccess\n    render json: failed_json, status: 403\n  end\n\n  def check_sso_email\n    user = fetch_user_from_params(include_inactive: true)\n\n    unless user == current_user\n      guardian.ensure_can_check_sso_details!(user)\n      StaffActionLogger.new(current_user).log_check_email(user, context: params[:context])\n    end\n\n    email = user&.single_sign_on_record&.external_email\n    email = I18n.t(\"user.email.does_not_exist\") if email.blank?\n\n    render json: { email: email }\n  rescue Discourse::InvalidAccess\n    render json: failed_json, status: 403\n  end\n\n  def check_sso_payload\n    user = fetch_user_from_params(include_inactive: true)\n\n    guardian.ensure_can_check_sso_details!(user)\n    unless user == current_user\n      StaffActionLogger.new(current_user).log_check_email(user, context: params[:context])\n    end\n\n    payload = user&.single_sign_on_record&.last_payload\n    payload = I18n.t(\"user.email.does_not_exist\") if payload.blank?\n\n    render json: { payload: payload }\n  rescue Discourse::InvalidAccess\n    render json: failed_json, status: 403\n  end\n\n  def update_primary_email\n    return render json: failed_json, status: 410 if !SiteSetting.enable_secondary_emails\n\n    params.require(:email)\n\n    user = fetch_user_from_params\n    guardian.ensure_can_edit_email!(user)\n\n    old_primary = user.primary_email\n    return render json: success_json if old_primary.email == params[:email]\n\n    new_primary = user.user_emails.find_by(email: params[:email])\n    if new_primary.blank?\n      return(\n        render json: failed_json.merge(errors: [I18n.t(\"change_email.doesnt_exist\")]), status: 428\n      )\n    end\n\n    User.transaction do\n      old_primary.update!(primary: false)\n      new_primary.update!(primary: true)\n      DiscourseEvent.trigger(:user_updated, user)\n\n      if current_user.staff? && current_user != user\n        StaffActionLogger.new(current_user).log_update_email(user)\n      else\n        UserHistory.create!(action: UserHistory.actions[:update_email], acting_user_id: user.id)\n      end\n    end\n\n    render json: success_json\n  end\n\n  def destroy_email\n    return render json: failed_json, status: 410 if !SiteSetting.enable_secondary_emails\n\n    params.require(:email)\n\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    ActiveRecord::Base.transaction do\n      if change_requests = user.email_change_requests.where(new_email: params[:email]).presence\n        change_requests.destroy_all\n      elsif user.user_emails.where(email: params[:email], primary: false).destroy_all.present?\n        DiscourseEvent.trigger(:user_updated, user)\n      else\n        return render json: failed_json, status: 428\n      end\n\n      if current_user.staff? && current_user != user\n        StaffActionLogger.new(current_user).log_destroy_email(user)\n      else\n        UserHistory.create(action: UserHistory.actions[:destroy_email], acting_user_id: user.id)\n      end\n    end\n\n    render json: success_json\n  end\n\n  def topic_tracking_state\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    report = TopicTrackingState.report(user)\n    serializer = TopicTrackingStateSerializer.new(report, scope: guardian, root: false)\n\n    render json: MultiJson.dump(serializer.as_json[:data])\n  end\n\n  def private_message_topic_tracking_state\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    report = PrivateMessageTopicTrackingState.report(user)\n\n    serializer =\n      ActiveModel::ArraySerializer.new(\n        report,\n        each_serializer: PrivateMessageTopicTrackingStateSerializer,\n        scope: guardian,\n      )\n\n    render json: MultiJson.dump(serializer)\n  end\n\n  def badge_title\n    params.require(:user_badge_id)\n\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    user_badge = UserBadge.find_by(id: params[:user_badge_id])\n    previous_title = user.title\n    if user_badge && user_badge.user == user && user_badge.badge.allow_title?\n      user.title = user_badge.badge.display_name\n      user.save!\n\n      log_params = {\n        details: \"title matching badge id #{user_badge.badge.id}\",\n        previous_value: previous_title,\n        new_value: user.title,\n      }\n\n      if current_user.staff? && current_user != user\n        StaffActionLogger.new(current_user).log_title_change(user, log_params)\n      else\n        UserHistory.create!(\n          log_params.merge(target_user_id: user.id, action: UserHistory.actions[:change_title]),\n        )\n      end\n    else\n      user.title = \"\"\n      user.save!\n\n      log_params = { previous_value: previous_title }\n\n      if current_user.staff? && current_user != user\n        StaffActionLogger.new(current_user).log_title_revoke(\n          user,\n          log_params.merge(\n            revoke_reason: \"user title was same as revoked badge name or custom badge name\",\n          ),\n        )\n      else\n        UserHistory.create!(\n          log_params.merge(target_user_id: user.id, action: UserHistory.actions[:revoke_title]),\n        )\n      end\n    end\n\n    render body: nil\n  end\n\n  def preferences\n    render body: nil\n  end\n\n  def my_redirect\n    raise Discourse::NotFound if params[:path] !~ %r{\\A[a-z_\\-/]+\\z}\n\n    if current_user.blank?\n      cookies[:destination_url] = path(\"/my/#{params[:path]}\")\n      redirect_to path(\"/login-preferences\")\n    else\n      redirect_to(path(\"/u/#{current_user.encoded_username}/#{params[:path]}\"))\n    end\n  end\n\n  def profile_hidden\n    render nothing: true\n  end\n\n  def summary\n    return redirect_to path(\"/login\") if !guardian.public_can_see_profiles?\n\n    @user =\n      fetch_user_from_params(\n        include_inactive:\n          current_user.try(:staff?) || (current_user && SiteSetting.show_inactive_accounts),\n      )\n    raise Discourse::NotFound unless guardian.can_see_profile?(@user)\n\n    response.headers[\"X-Robots-Tag\"] = \"noindex\"\n\n    respond_to do |format|\n      format.html do\n        @restrict_fields = guardian.restrict_user_fields?(@user)\n        render :show\n      end\n      format.json do\n        summary_json =\n          Discourse\n            .cache\n            .fetch(summary_cache_key(@user), expires_in: 1.hour) do\n              summary = UserSummary.new(@user, guardian)\n              serializer = UserSummarySerializer.new(summary, scope: guardian)\n              MultiJson.dump(serializer)\n            end\n        render json: summary_json\n      end\n    end\n  end\n\n  def invited\n    if guardian.can_invite_to_forum?\n      filter = params[:filter] || \"redeemed\"\n      inviter =\n        fetch_user_from_params(\n          include_inactive: current_user.staff? || SiteSetting.show_inactive_accounts,\n        )\n\n      invites =\n        if filter == \"pending\" && guardian.can_see_invite_details?(inviter)\n          Invite.includes(:topics, :groups).pending(inviter)\n        elsif filter == \"expired\"\n          Invite.expired(inviter)\n        elsif filter == \"redeemed\"\n          Invite.redeemed_users(inviter)\n        else\n          Invite.none\n        end\n\n      invites = invites.offset(params[:offset].to_i || 0).limit(SiteSetting.invites_per_page)\n\n      show_emails = guardian.can_see_invite_emails?(inviter)\n      if params[:search].present? && invites.present?\n        filter_sql = \"(LOWER(users.username) LIKE :filter)\"\n        filter_sql =\n          \"(LOWER(invites.email) LIKE :filter) or (LOWER(users.username) LIKE :filter)\" if show_emails\n        invites = invites.where(filter_sql, filter: \"%#{params[:search].downcase}%\")\n      end\n\n      pending_count = Invite.pending(inviter).reorder(nil).count.to_i\n      expired_count = Invite.expired(inviter).reorder(nil).count.to_i\n      redeemed_count = Invite.redeemed_users(inviter).reorder(nil).count.to_i\n\n      render json:\n               MultiJson.dump(\n                 InvitedSerializer.new(\n                   OpenStruct.new(\n                     invite_list: invites.to_a,\n                     show_emails: show_emails,\n                     inviter: inviter,\n                     type: filter,\n                     counts: {\n                       pending: pending_count,\n                       expired: expired_count,\n                       redeemed: redeemed_count,\n                       total: pending_count + expired_count,\n                     },\n                   ),\n                   scope: guardian,\n                   root: false,\n                 ),\n               )\n    elsif current_user&.staff?\n      message =\n        if SiteSetting.enable_discourse_connect\n          I18n.t(\"invite.disabled_errors.discourse_connect_enabled\")\n        end\n\n      render_invite_error(message)\n    else\n      render_json_error(I18n.t(\"invite.disabled_errors.invalid_access\"))\n    end\n  end\n\n  def render_available_true\n    render(json: { available: true })\n  end\n\n  def changing_case_of_own_username(target_user, username)\n    target_user && username.downcase == (target_user.username.downcase)\n  end\n\n  # Used for checking availability of a username and will return suggestions\n  # if the username is not available.\n  def check_username\n    if !params[:username].present?\n      params.require(:username) if !params[:email].present?\n      return render(json: success_json)\n    end\n    username = params[:username]&.unicode_normalize\n\n    target_user = user_from_params_or_current_user\n\n    # The special case where someone is changing the case of their own username\n    return render_available_true if changing_case_of_own_username(target_user, username)\n\n    checker = UsernameCheckerService.new\n    email = params[:email] || target_user.try(:email)\n    render json: checker.check_username(username, email)\n  end\n\n  def check_email\n    begin\n      RateLimiter.new(nil, \"check-email-#{request.remote_ip}\", 10, 1.minute).performed!\n    rescue RateLimiter::LimitExceeded\n      return render json: success_json\n    end\n\n    email = Email.downcase((params[:email] || \"\").strip)\n\n    return render json: success_json if email.blank? || SiteSetting.hide_email_address_taken?\n\n    if !EmailAddressValidator.valid_value?(email)\n      error = User.new.errors.full_message(:email, I18n.t(:\"user.email.invalid\"))\n      return render json: failed_json.merge(errors: [error])\n    end\n\n    if !EmailValidator.allowed?(email)\n      error = User.new.errors.full_message(:email, I18n.t(:\"user.email.not_allowed\"))\n      return render json: failed_json.merge(errors: [error])\n    end\n\n    if ScreenedEmail.should_block?(email)\n      error = User.new.errors.full_message(:email, I18n.t(:\"user.email.blocked\"))\n      return render json: failed_json.merge(errors: [error])\n    end\n\n    if User.where(staged: false).find_by_email(email).present?\n      error = User.new.errors.full_message(:email, I18n.t(:\"errors.messages.taken\"))\n      return render json: failed_json.merge(errors: [error])\n    end\n\n    render json: success_json\n  end\n\n  def user_from_params_or_current_user\n    params[:for_user_id] ? User.find(params[:for_user_id]) : current_user\n  end\n\n  def create\n    params.require(:email)\n    params.require(:username)\n    params.require(:invite_code) if SiteSetting.require_invite_code\n    params.permit(:user_fields)\n    params.permit(:external_ids)\n\n    return fail_with(\"login.new_registrations_disabled\") unless SiteSetting.allow_new_registrations\n\n    if params[:password] && params[:password].length > User.max_password_length\n      return fail_with(\"login.password_too_long\")\n    end\n\n    return fail_with(\"login.email_too_long\") if params[:email].length > 254 + 1 + 253\n\n    if SiteSetting.require_invite_code &&\n         SiteSetting.invite_code.strip.downcase != params[:invite_code].strip.downcase\n      return fail_with(\"login.wrong_invite_code\")\n    end\n\n    if clashing_with_existing_route?(params[:username]) ||\n         User.reserved_username?(params[:username])\n      return fail_with(\"login.reserved_username\")\n    end\n\n    params[:locale] ||= I18n.locale unless current_user\n\n    new_user_params = user_params.except(:timezone)\n\n    user = User.where(staged: true).with_email(new_user_params[:email].strip.downcase).first\n\n    if user\n      user.active = false\n      user.unstage!\n    end\n\n    user ||= User.new\n    user.attributes = new_user_params\n\n    # Handle API approval and\n    # auto approve users based on auto_approve_email_domains setting\n    if user.approved? || EmailValidator.can_auto_approve_user?(user.email)\n      ReviewableUser.set_approved_fields!(user, current_user)\n    end\n\n    # Handle custom fields\n    user_fields = UserField.all\n    if user_fields.present?\n      field_params = params[:user_fields] || {}\n      fields = user.custom_fields\n\n      user_fields.each do |f|\n        field_val = field_params[f.id.to_s]\n        if field_val.blank?\n          return fail_with(\"login.missing_user_field\") if f.required?\n        else\n          fields[\"#{User::USER_FIELD_PREFIX}#{f.id}\"] = field_val[0...UserField.max_length]\n        end\n      end\n\n      user.custom_fields = fields\n    end\n\n    # Handle associated accounts\n    associations = []\n    if params[:external_ids]&.is_a?(ActionController::Parameters) && current_user&.admin? && is_api?\n      params[:external_ids].each do |provider_name, provider_uid|\n        authenticator = Discourse.enabled_authenticators.find { |a| a.name == provider_name }\n        raise Discourse::InvalidParameters.new(:external_ids) if !authenticator&.is_managed?\n\n        association =\n          UserAssociatedAccount.find_or_initialize_by(\n            provider_name: provider_name,\n            provider_uid: provider_uid,\n          )\n        associations << association\n      end\n    end\n\n    authentication = UserAuthenticator.new(user, session)\n\n    if !authentication.has_authenticator? && !SiteSetting.enable_local_logins &&\n         !(current_user&.admin? && is_api?)\n      return render body: nil, status: :forbidden\n    end\n\n    authentication.start\n\n    if authentication.email_valid? && !authentication.authenticated?\n      # posted email is different that the already validated one?\n      return fail_with(\"login.incorrect_username_email_or_password\")\n    end\n\n    activation = UserActivator.new(user, request, session, cookies)\n    activation.start\n\n    # just assign a password if we have an authenticator and no password\n    # this is the case for Twitter\n    user.password = SecureRandom.hex if user.password.blank? &&\n      (authentication.has_authenticator? || associations.present?)\n\n    if user.save\n      authentication.finish\n      activation.finish\n      associations.each { |a| a.update!(user: user) }\n      user.update_timezone_if_missing(params[:timezone])\n\n      secure_session[HONEYPOT_KEY] = nil\n      secure_session[CHALLENGE_KEY] = nil\n\n      # save user email in session, to show on account-created page\n      session[\"user_created_message\"] = activation.message\n      session[SessionController::ACTIVATE_USER_KEY] = user.id\n\n      # If the user was created as active this will\n      # ensure their email is confirmed and\n      # add them to the review queue if they need to be approved\n      user.activate if user.active?\n\n      render json: { success: true, active: user.active?, message: activation.message }.merge(\n               SiteSetting.hide_email_address_taken ? {} : { user_id: user.id },\n             )\n    elsif SiteSetting.hide_email_address_taken &&\n          user.errors[:primary_email]&.include?(I18n.t(\"errors.messages.taken\"))\n      session[\"user_created_message\"] = activation.success_message\n\n      if existing_user = User.find_by_email(user.primary_email&.email)\n        Jobs.enqueue(:critical_user_email, type: \"account_exists\", user_id: existing_user.id)\n      end\n\n      render json: { success: true, active: false, message: activation.success_message }\n    else\n      errors = user.errors.to_hash\n      errors[:email] = errors.delete(:primary_email) if errors[:primary_email]\n\n      render json: {\n               success: false,\n               message: I18n.t(\"login.errors\", errors: user.errors.full_messages.join(\"\\n\")),\n               errors: errors,\n               values: {\n                 name: user.name,\n                 username: user.username,\n                 email: user.primary_email&.email,\n               },\n               is_developer: UsernameCheckerService.is_developer?(user.email),\n             }\n    end\n  rescue ActiveRecord::StatementInvalid\n    render json: { success: false, message: I18n.t(\"login.something_already_taken\") }\n  end\n\n  def password_reset_show\n    expires_now\n    token = params[:token]\n\n    password_reset_find_user(token, committing_change: false)\n\n    if !@error\n      security_params = {\n        is_developer: UsernameCheckerService.is_developer?(@user.email),\n        admin: @user.admin?,\n        second_factor_required: @user.totp_enabled?,\n        security_key_required: @user.security_keys_enabled?,\n        backup_enabled: @user.backup_codes_enabled?,\n        multiple_second_factor_methods: @user.has_multiple_second_factor_methods?,\n      }\n    end\n\n    respond_to do |format|\n      format.html do\n        return render \"password_reset\", layout: \"no_ember\" if @error\n\n        Webauthn.stage_challenge(@user, secure_session)\n        store_preloaded(\n          \"password_reset\",\n          MultiJson.dump(\n            security_params.merge(Webauthn.allowed_credentials(@user, secure_session)),\n          ),\n        )\n\n        render \"password_reset\"\n      end\n\n      format.json do\n        return render json: { message: @error } if @error\n\n        Webauthn.stage_challenge(@user, secure_session)\n        render json: security_params.merge(Webauthn.allowed_credentials(@user, secure_session))\n      end\n    end\n  end\n\n  def password_reset_update\n    expires_now\n    token = params[:token]\n    password_reset_find_user(token, committing_change: true)\n\n    rate_limit_second_factor!(@user)\n\n    # no point doing anything else if we can't even find\n    # a user from the token\n    if @user\n      if !secure_session[\"second-factor-#{token}\"]\n        second_factor_authentication_result =\n          @user.authenticate_second_factor(params, secure_session)\n        if !second_factor_authentication_result.ok\n          user_error_key =\n            (\n              if second_factor_authentication_result.reason == \"invalid_security_key\"\n                :user_second_factors\n              else\n                :security_keys\n              end\n            )\n          @user.errors.add(user_error_key, :invalid)\n          @error = second_factor_authentication_result.error\n        else\n          # this must be set because the first call we authenticate e.g. TOTP, and we do\n          # not want to re-authenticate on the second call to change the password as this\n          # will cause a TOTP error saying the code has already been used\n          secure_session[\"second-factor-#{token}\"] = true\n        end\n      end\n\n      if @invalid_password =\n           params[:password].blank? || params[:password].size > User.max_password_length\n        @user.errors.add(:password, :invalid)\n      end\n\n      # if we have run into no errors then the user is a-ok to\n      # change the password\n      if @user.errors.empty?\n        @user.update_timezone_if_missing(params[:timezone]) if params[:timezone]\n        @user.password = params[:password]\n        @user.password_required!\n        @user.user_auth_tokens.destroy_all\n        if @user.save\n          Invite.invalidate_for_email(@user.email) # invite link can't be used to log in anymore\n          secure_session[\"password-#{token}\"] = nil\n          secure_session[\"second-factor-#{token}\"] = nil\n          UserHistory.create!(\n            target_user: @user,\n            acting_user: @user,\n            action: UserHistory.actions[:change_password],\n          )\n          logon_after_password_reset\n        end\n      end\n    end\n\n    respond_to do |format|\n      format.html do\n        return render \"password_reset\", layout: \"no_ember\" if @error\n\n        Webauthn.stage_challenge(@user, secure_session)\n\n        security_params = {\n          is_developer: UsernameCheckerService.is_developer?(@user.email),\n          admin: @user.admin?,\n          second_factor_required: @user.totp_enabled?,\n          security_key_required: @user.security_keys_enabled?,\n          backup_enabled: @user.backup_codes_enabled?,\n          multiple_second_factor_methods: @user.has_multiple_second_factor_methods?,\n        }.merge(Webauthn.allowed_credentials(@user, secure_session))\n\n        store_preloaded(\"password_reset\", MultiJson.dump(security_params))\n\n        return redirect_to(wizard_path) if Wizard.user_requires_completion?(@user)\n\n        render \"password_reset\"\n      end\n\n      format.json do\n        if @error || @user&.errors&.any?\n          render json: {\n                   success: false,\n                   message: @error,\n                   errors: @user&.errors&.to_hash,\n                   is_developer: UsernameCheckerService.is_developer?(@user&.email),\n                   admin: @user&.admin?,\n                 }\n        else\n          render json: {\n                   success: true,\n                   message: @success,\n                   requires_approval: !Guardian.new(@user).can_access_forum?,\n                   redirect_to: Wizard.user_requires_completion?(@user) ? wizard_path : nil,\n                 }\n        end\n      end\n    end\n  end\n\n  def confirm_email_token\n    expires_now\n    EmailToken.confirm(params[:token], scope: EmailToken.scopes[:signup])\n    render json: success_json\n  end\n\n  def logon_after_password_reset\n    message =\n      if Guardian.new(@user).can_access_forum?\n        # Log in the user\n        log_on_user(@user)\n        \"password_reset.success\"\n      else\n        @requires_approval = true\n        \"password_reset.success_unapproved\"\n      end\n\n    @success = I18n.t(message)\n  end\n\n  def admin_login\n    return redirect_to(path(\"/\")) if current_user\n\n    if request.put? && params[:email].present?\n      RateLimiter.new(nil, \"admin-login-hr-#{request.remote_ip}\", 6, 1.hour).performed!\n      RateLimiter.new(nil, \"admin-login-min-#{request.remote_ip}\", 3, 1.minute).performed!\n\n      if user = User.with_email(params[:email]).admins.human_users.first\n        email_token =\n          user.email_tokens.create!(email: user.email, scope: EmailToken.scopes[:email_login])\n        token_string = email_token.token\n        token_string += \"?safe_mode=no_plugins,no_themes\" if params[\"use_safe_mode\"]\n        Jobs.enqueue(\n          :critical_user_email,\n          type: \"admin_login\",\n          user_id: user.id,\n          email_token: token_string,\n        )\n        @message = I18n.t(\"admin_login.success\")\n      else\n        @message = I18n.t(\"admin_login.errors.unknown_email_address\")\n      end\n    end\n\n    render layout: \"no_ember\"\n  rescue RateLimiter::LimitExceeded\n    @message = I18n.t(\"rate_limiter.slow_down\")\n    render layout: \"no_ember\"\n  end\n\n  def email_login\n    raise Discourse::NotFound if !SiteSetting.enable_local_logins_via_email\n    return redirect_to path(\"/\") if current_user\n\n    expires_now\n    params.require(:login)\n\n    RateLimiter.new(nil, \"email-login-hour-#{request.remote_ip}\", 6, 1.hour).performed!\n    RateLimiter.new(nil, \"email-login-min-#{request.remote_ip}\", 3, 1.minute).performed!\n    user = User.human_users.find_by_username_or_email(params[:login])\n    user_presence = user.present? && !user.staged\n\n    if user\n      RateLimiter.new(nil, \"email-login-hour-#{user.id}\", 6, 1.hour).performed!\n      RateLimiter.new(nil, \"email-login-min-#{user.id}\", 3, 1.minute).performed!\n\n      if user_presence\n        DiscourseEvent.trigger(:before_email_login, user)\n\n        email_token =\n          user.email_tokens.create!(email: user.email, scope: EmailToken.scopes[:email_login])\n\n        Jobs.enqueue(\n          :critical_user_email,\n          type: \"email_login\",\n          user_id: user.id,\n          email_token: email_token.token,\n        )\n      end\n    end\n\n    json = success_json\n    json[:hide_taken] = SiteSetting.hide_email_address_taken\n    json[:user_found] = user_presence unless SiteSetting.hide_email_address_taken\n    render json: json\n  rescue RateLimiter::LimitExceeded\n    render_json_error(I18n.t(\"rate_limiter.slow_down\"))\n  end\n\n  def toggle_anon\n    user =\n      AnonymousShadowCreator.get_master(current_user) || AnonymousShadowCreator.get(current_user)\n\n    if user\n      log_on_user(user)\n      render json: success_json\n    else\n      render json: failed_json, status: 403\n    end\n  end\n\n  def account_created\n    if current_user.present?\n      if SiteSetting.enable_discourse_connect_provider && payload = cookies.delete(:sso_payload)\n        return redirect_to(session_sso_provider_url + \"?\" + payload)\n      elsif destination_url = cookies.delete(:destination_url)\n        return redirect_to(destination_url, allow_other_host: true)\n      else\n        return redirect_to(path(\"/\"))\n      end\n    end\n\n    @custom_body_class = \"static-account-created\"\n    @message = session[\"user_created_message\"] || I18n.t(\"activation.missing_session\")\n    @account_created = { message: @message, show_controls: false }\n\n    if session_user_id = session[SessionController::ACTIVATE_USER_KEY]\n      if user = User.where(id: session_user_id.to_i).first\n        @account_created[:username] = user.username\n        @account_created[:email] = user.email\n        @account_created[:show_controls] = !user.from_staged?\n      end\n    end\n\n    store_preloaded(\"accountCreated\", MultiJson.dump(@account_created))\n    expires_now\n\n    respond_to do |format|\n      format.html { render \"default/empty\" }\n      format.json { render json: success_json }\n    end\n  end\n\n  def activate_account\n    expires_now\n    render layout: \"no_ember\"\n  end\n\n  def perform_account_activation\n    raise Discourse::InvalidAccess.new if honeypot_or_challenge_fails?(params)\n\n    if @user = EmailToken.confirm(params[:token], scope: EmailToken.scopes[:signup])\n      # Log in the user unless they need to be approved\n      if Guardian.new(@user).can_access_forum?\n        @user.enqueue_welcome_message(\"welcome_user\") if @user.send_welcome_message\n        log_on_user(@user)\n\n        # invites#perform_accept_invitation already sets destination_url, but\n        # sometimes it is lost (user changes browser, uses incognito, etc)\n        #\n        # The code below checks if the user was invited and redirects them to\n        # the topic they were originally invited to.\n        destination_url = cookies.delete(:destination_url)\n        if destination_url.blank?\n          topic =\n            Invite\n              .joins(:invited_users)\n              .find_by(invited_users: { user_id: @user.id })\n              &.topics\n              &.first\n\n          destination_url = path(topic.relative_url) if @user.guardian.can_see?(topic)\n        end\n\n        if Wizard.user_requires_completion?(@user)\n          return redirect_to(wizard_path)\n        elsif destination_url.present?\n          return redirect_to(destination_url, allow_other_host: true)\n        elsif SiteSetting.enable_discourse_connect_provider &&\n              payload = cookies.delete(:sso_payload)\n          return redirect_to(session_sso_provider_url + \"?\" + payload)\n        end\n      else\n        @needs_approval = true\n      end\n    else\n      flash.now[:error] = I18n.t(\"activation.already_done\")\n    end\n\n    render layout: \"no_ember\"\n  end\n\n  def update_activation_email\n    RateLimiter.new(nil, \"activate-edit-email-hr-#{request.remote_ip}\", 5, 1.hour).performed!\n\n    if params[:username].present?\n      RateLimiter.new(\n        nil,\n        \"activate-edit-email-hr-username-#{params[:username]}\",\n        5,\n        1.hour,\n      ).performed!\n      @user = User.find_by_username_or_email(params[:username])\n      raise Discourse::InvalidAccess.new unless @user.present?\n      raise Discourse::InvalidAccess.new unless @user.confirm_password?(params[:password])\n    elsif user_key = session[SessionController::ACTIVATE_USER_KEY]\n      RateLimiter.new(nil, \"activate-edit-email-hr-user-key-#{user_key}\", 5, 1.hour).performed!\n      @user = User.where(id: user_key.to_i).first\n    end\n\n    if @user.blank? || @user.active? || current_user.present? || @user.from_staged?\n      raise Discourse::InvalidAccess.new\n    end\n\n    User.transaction do\n      primary_email = @user.primary_email\n      primary_email.email = params[:email]\n      primary_email.skip_validate_email = false\n\n      if primary_email.save\n        @email_token =\n          @user.email_tokens.create!(email: @user.email, scope: EmailToken.scopes[:signup])\n        EmailToken.enqueue_signup_email(@email_token, to_address: @user.email)\n        render json: success_json\n      else\n        render_json_error(primary_email)\n      end\n    end\n  end\n\n  def send_activation_email\n    if current_user.blank? || !current_user.staff?\n      RateLimiter.new(nil, \"activate-hr-#{request.remote_ip}\", 30, 1.hour).performed!\n      RateLimiter.new(nil, \"activate-min-#{request.remote_ip}\", 6, 1.minute).performed!\n    end\n\n    raise Discourse::InvalidAccess.new if SiteSetting.must_approve_users?\n\n    @user = User.find_by_username_or_email(params[:username].to_s) if params[:username].present?\n\n    raise Discourse::NotFound unless @user\n\n    if !current_user&.staff? && @user.id != session[SessionController::ACTIVATE_USER_KEY]\n      raise Discourse::InvalidAccess.new\n    end\n\n    session.delete(SessionController::ACTIVATE_USER_KEY)\n\n    if @user.active && @user.email_confirmed?\n      render_json_error(I18n.t(\"activation.activated\"), status: 409)\n    else\n      @email_token =\n        @user.email_tokens.create!(email: @user.email, scope: EmailToken.scopes[:signup])\n      EmailToken.enqueue_signup_email(@email_token, to_address: @user.email)\n      render body: nil\n    end\n  end\n\n  SEARCH_USERS_LIMIT = 50\n\n  def search_users\n    term = params[:term].to_s.strip\n\n    topic_id = params[:topic_id].to_i if params[:topic_id].present?\n    category_id = params[:category_id].to_i if params[:category_id].present?\n\n    topic_allowed_users = params[:topic_allowed_users] || false\n\n    group_names = params[:groups] || []\n    group_names << params[:group] if params[:group]\n    @groups = Group.where(name: group_names) if group_names.present?\n\n    options = {\n      topic_allowed_users: topic_allowed_users,\n      searching_user: current_user,\n      groups: @groups,\n    }\n\n    options[:include_staged_users] = !!ActiveModel::Type::Boolean.new.cast(\n      params[:include_staged_users],\n    )\n    options[:last_seen_users] = !!ActiveModel::Type::Boolean.new.cast(params[:last_seen_users])\n\n    if limit = fetch_limit_from_params(default: nil, max: SEARCH_USERS_LIMIT)\n      options[:limit] = limit\n    end\n\n    options[:topic_id] = topic_id if topic_id\n    options[:category_id] = category_id if category_id\n\n    results = UserSearch.new(term, options).search\n    to_render = serialize_found_users(results)\n\n    # blank term is only handy for in-topic search of users after @\n    # we do not want group results ever if term is blank\n    groups =\n      if term.present? && current_user\n        if params[:include_groups] == \"true\"\n          Group.visible_groups(current_user)\n        elsif params[:include_mentionable_groups] == \"true\"\n          Group.mentionable(current_user)\n        elsif params[:include_messageable_groups] == \"true\"\n          Group.messageable(current_user)\n        end\n      end\n\n    if groups\n      DiscoursePluginRegistry\n        .groups_callback_for_users_search_controller_action\n        .each do |param_name, block|\n        groups = block.call(groups, current_user) if params[param_name.to_s]\n      end\n\n      # the plugin registry callbacks above are only evaluated when a param\n      # is present matching the name of the callback. Any modifier registered using\n      # register_modifier(:groups_for_users_search) will be evaluated without needing the\n      # param.\n      groups = DiscoursePluginRegistry.apply_modifier(:groups_for_users_search, groups)\n      groups = Group.search_groups(term, groups: groups, sort: :auto)\n\n      to_render[:groups] = groups.map { |m| { name: m.name, full_name: m.full_name } }\n    end\n\n    render json: to_render\n  end\n\n  AVATAR_TYPES_WITH_UPLOAD ||= %w[uploaded custom gravatar]\n\n  def pick_avatar\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    return render json: failed_json, status: 422 if SiteSetting.discourse_connect_overrides_avatar\n\n    type = params[:type]\n\n    invalid_type = type.present? && !AVATAR_TYPES_WITH_UPLOAD.include?(type) && type != \"system\"\n    return render json: failed_json, status: 422 if invalid_type\n\n    if type.blank? || type == \"system\"\n      upload_id = nil\n    elsif !TrustLevelAndStaffAndDisabledSetting.matches?(SiteSetting.allow_uploaded_avatars, user)\n      return render json: failed_json, status: 422\n    else\n      upload_id = params[:upload_id]\n      upload = Upload.find_by(id: upload_id)\n\n      return render_json_error I18n.t(\"avatar.missing\") if upload.nil?\n\n      # old safeguard\n      user.create_user_avatar unless user.user_avatar\n\n      guardian.ensure_can_pick_avatar!(user.user_avatar, upload)\n\n      if type == \"gravatar\"\n        user.user_avatar.gravatar_upload_id = upload_id\n      else\n        user.user_avatar.custom_upload_id = upload_id\n      end\n    end\n\n    SiteSetting.use_site_small_logo_as_system_avatar = false if user.is_system_user?\n\n    user.uploaded_avatar_id = upload_id\n    user.save!\n    user.user_avatar.save!\n\n    render json: success_json\n  end\n\n  def select_avatar\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    url = params[:url]\n\n    return render json: failed_json, status: 422 if url.blank?\n\n    if SiteSetting.selectable_avatars_mode == \"disabled\"\n      return render json: failed_json, status: 422\n    end\n\n    return render json: failed_json, status: 422 if SiteSetting.selectable_avatars.blank?\n\n    unless upload = Upload.get_from_url(url)\n      return render json: failed_json, status: 422\n    end\n\n    unless SiteSetting.selectable_avatars.include?(upload)\n      return render json: failed_json, status: 422\n    end\n\n    user.uploaded_avatar_id = upload.id\n\n    SiteSetting.use_site_small_logo_as_system_avatar = false if user.is_system_user?\n\n    user.save!\n\n    avatar = user.user_avatar || user.create_user_avatar\n    avatar.custom_upload_id = upload.id\n    avatar.save!\n\n    render json: {\n             avatar_template: user.avatar_template,\n             custom_avatar_template: user.avatar_template,\n             uploaded_avatar_id: upload.id,\n           }\n  end\n\n  def destroy_user_image\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    case params.require(:type)\n    when \"profile_background\"\n      user.user_profile.clear_profile_background\n    when \"card_background\"\n      user.user_profile.clear_card_background\n    else\n      raise Discourse::InvalidParameters.new(:type)\n    end\n\n    render json: success_json\n  end\n\n  def destroy\n    @user = fetch_user_from_params\n    guardian.ensure_can_delete_user!(@user)\n\n    UserDestroyer.new(current_user).destroy(@user, delete_posts: true, context: params[:context])\n\n    render json: success_json\n  end\n\n  def notification_level\n    target_user = fetch_user_from_params\n    acting_user = current_user\n\n    # the admin should be able to change notification levels\n    # on behalf of other users, so we cannot rely on current_user\n    # for this case\n    if params[:acting_user_id].present? && params[:acting_user_id].to_i != current_user.id\n      if current_user.staff?\n        acting_user = User.find(params[:acting_user_id])\n      else\n        @error_message = \"error\"\n        raise Discourse::InvalidAccess\n      end\n    end\n\n    if params[:notification_level] == \"ignore\"\n      @error_message = \"ignore_error\"\n      guardian.ensure_can_ignore_user!(target_user)\n      MutedUser.where(user: acting_user, muted_user: target_user).delete_all\n      ignored_user = IgnoredUser.find_by(user: acting_user, ignored_user: target_user)\n      if ignored_user.present?\n        ignored_user.update(expiring_at: DateTime.parse(params[:expiring_at]))\n      else\n        IgnoredUser.create!(\n          user: acting_user,\n          ignored_user: target_user,\n          expiring_at: Time.parse(params[:expiring_at]),\n        )\n      end\n    elsif params[:notification_level] == \"mute\"\n      @error_message = \"mute_error\"\n      guardian.ensure_can_mute_user!(target_user)\n      IgnoredUser.where(user: acting_user, ignored_user: target_user).delete_all\n      MutedUser.find_or_create_by!(user: acting_user, muted_user: target_user)\n    elsif params[:notification_level] == \"normal\"\n      MutedUser.where(user: acting_user, muted_user: target_user).delete_all\n      IgnoredUser.where(user: acting_user, ignored_user: target_user).delete_all\n    else\n      return(\n        render_json_error(\n          I18n.t(\"notification_level.invalid_value\", value: params[:notification_level]),\n        )\n      )\n    end\n\n    render json: success_json\n  rescue Discourse::InvalidAccess\n    render_json_error(I18n.t(\"notification_level.#{@error_message}\"))\n  end\n\n  def read_faq\n    if user = current_user\n      user.user_stat.read_faq = 1.second.ago\n      user.user_stat.save\n    end\n\n    render json: success_json\n  end\n\n  def recent_searches\n    if !SiteSetting.log_search_queries\n      return(\n        render json: failed_json.merge(error: I18n.t(\"user_activity.no_log_search_queries\")),\n               status: 403\n      )\n    end\n\n    query = SearchLog.where(user_id: current_user.id)\n\n    if current_user.user_option.oldest_search_log_date\n      query = query.where(\"created_at > ?\", current_user.user_option.oldest_search_log_date)\n    end\n\n    results =\n      query.group(:term).order(\"max(created_at) DESC\").limit(MAX_RECENT_SEARCHES).pluck(:term)\n\n    render json: success_json.merge(recent_searches: results)\n  end\n\n  def reset_recent_searches\n    current_user.user_option.update!(oldest_search_log_date: 1.second.ago)\n    render json: success_json\n  end\n\n  def staff_info\n    @user = fetch_user_from_params(include_inactive: true)\n    guardian.ensure_can_see_staff_info!(@user)\n\n    result = {}\n\n    %W[\n      number_of_deleted_posts\n      number_of_flagged_posts\n      number_of_flags_given\n      number_of_suspensions\n      warnings_received_count\n      number_of_rejected_posts\n    ].each { |info| result[info] = @user.public_send(info) }\n\n    render json: result\n  end\n\n  def confirm_admin\n    @confirmation = AdminConfirmation.find_by_code(params[:token])\n\n    raise Discourse::NotFound unless @confirmation\n    unless @confirmation.performed_by.id == (current_user&.id || @confirmation.performed_by.id)\n      raise Discourse::InvalidAccess.new\n    end\n\n    if request.post?\n      @confirmation.email_confirmed!\n      @confirmed = true\n    end\n\n    respond_to do |format|\n      format.json { render json: success_json }\n      format.html { render layout: \"no_ember\" }\n    end\n  end\n\n  def list_second_factors\n    if SiteSetting.enable_discourse_connect || !SiteSetting.enable_local_logins\n      raise Discourse::NotFound\n    end\n\n    unless params[:password].empty?\n      RateLimiter.new(\n        nil,\n        \"login-hr-#{request.remote_ip}\",\n        SiteSetting.max_logins_per_ip_per_hour,\n        1.hour,\n      ).performed!\n      RateLimiter.new(\n        nil,\n        \"login-min-#{request.remote_ip}\",\n        SiteSetting.max_logins_per_ip_per_minute,\n        1.minute,\n      ).performed!\n      unless current_user.confirm_password?(params[:password])\n        return render json: failed_json.merge(error: I18n.t(\"login.incorrect_password\"))\n      end\n      confirm_secure_session\n    end\n\n    if secure_session_confirmed?\n      totp_second_factors =\n        current_user\n          .totps\n          .select(:id, :name, :last_used, :created_at, :method)\n          .where(enabled: true)\n          .order(:created_at)\n\n      security_keys =\n        current_user\n          .security_keys\n          .where(factor_type: UserSecurityKey.factor_types[:second_factor])\n          .order(:created_at)\n\n      render json: success_json.merge(totps: totp_second_factors, security_keys: security_keys)\n    else\n      render json: success_json.merge(password_required: true)\n    end\n  end\n\n  def create_second_factor_backup\n    backup_codes = current_user.generate_backup_codes\n\n    render json: success_json.merge(backup_codes: backup_codes)\n  end\n\n  def create_second_factor_totp\n    require \"rotp\" if !defined?(ROTP)\n    totp_data = ROTP::Base32.random\n    secure_session[\"staged-totp-#{current_user.id}\"] = totp_data\n    qrcode_png =\n      RQRCode::QRCode.new(current_user.totp_provisioning_uri(totp_data)).as_png(\n        border_modules: 1,\n        size: 240,\n      )\n\n    render json:\n             success_json.merge(key: totp_data.scan(/.{4}/).join(\" \"), qr: qrcode_png.to_data_url)\n  end\n\n  def create_second_factor_security_key\n    if current_user.all_security_keys.count >= UserSecurityKey::MAX_KEYS_PER_USER\n      render_json_error(I18n.t(\"login.too_many_security_keys\"), status: 422)\n      return\n    end\n\n    challenge_session = Webauthn.stage_challenge(current_user, secure_session)\n    render json:\n             success_json.merge(\n               challenge: challenge_session.challenge,\n               rp_id: challenge_session.rp_id,\n               rp_name: challenge_session.rp_name,\n               supported_algorithms: ::Webauthn::SUPPORTED_ALGORITHMS,\n               user_secure_id: current_user.create_or_fetch_secure_identifier,\n               existing_active_credential_ids:\n                 current_user.second_factor_security_key_credential_ids,\n             )\n  end\n\n  def register_second_factor_security_key\n    params.require(:name)\n    params.require(:attestation)\n    params.require(:clientData)\n\n    ::Webauthn::SecurityKeyRegistrationService.new(\n      current_user,\n      params,\n      challenge: Webauthn.challenge(current_user, secure_session),\n      rp_id: Webauthn.rp_id(current_user, secure_session),\n      origin: Discourse.base_url,\n    ).register_second_factor_security_key\n    render json: success_json\n  rescue ::Webauthn::SecurityKeyError => err\n    render json: failed_json.merge(error: err.message)\n  end\n\n  def update_security_key\n    user_security_key = current_user.security_keys.find_by(id: params[:id].to_i)\n    raise Discourse::InvalidParameters unless user_security_key\n\n    user_security_key.update!(name: params[:name]) if params[:name] && !params[:name].blank?\n    user_security_key.update!(enabled: false) if params[:disable] == \"true\"\n\n    render json: success_json\n  end\n\n  def enable_second_factor_totp\n    if params[:second_factor_token].blank?\n      return render json: failed_json.merge(error: I18n.t(\"login.missing_second_factor_code\"))\n    end\n    if params[:name].blank?\n      return render json: failed_json.merge(error: I18n.t(\"login.missing_second_factor_name\"))\n    end\n    auth_token = params[:second_factor_token]\n\n    totp_data = secure_session[\"staged-totp-#{current_user.id}\"]\n    totp_object = current_user.get_totp_object(totp_data)\n\n    rate_limit_second_factor!(current_user)\n\n    authenticated =\n      !auth_token.blank? &&\n        totp_object.verify(\n          auth_token,\n          drift_ahead: SecondFactorManager::TOTP_ALLOWED_DRIFT_SECONDS,\n          drift_behind: SecondFactorManager::TOTP_ALLOWED_DRIFT_SECONDS,\n        )\n    unless authenticated\n      return render json: failed_json.merge(error: I18n.t(\"login.invalid_second_factor_code\"))\n    end\n    current_user.create_totp(data: totp_data, name: params[:name], enabled: true)\n    render json: success_json\n  end\n\n  def disable_second_factor\n    # delete all second factors for a user\n    current_user.user_second_factors.destroy_all\n    current_user.security_keys.destroy_all\n\n    Jobs.enqueue(\n      :critical_user_email,\n      type: \"account_second_factor_disabled\",\n      user_id: current_user.id,\n    )\n\n    render json: success_json\n  end\n\n  def update_second_factor\n    params.require(:second_factor_target)\n    update_second_factor_method = params[:second_factor_target].to_i\n\n    if update_second_factor_method == UserSecondFactor.methods[:totp]\n      params.require(:id)\n      second_factor_id = params[:id].to_i\n      user_second_factor = current_user.user_second_factors.totps.find_by(id: second_factor_id)\n    elsif update_second_factor_method == UserSecondFactor.methods[:backup_codes]\n      user_second_factor = current_user.user_second_factors.backup_codes\n    end\n\n    raise Discourse::InvalidParameters unless user_second_factor\n\n    user_second_factor.update!(name: params[:name]) if params[:name] && !params[:name].blank?\n    if params[:disable] == \"true\"\n      # Disabling backup codes deletes *all* backup codes\n      if update_second_factor_method == UserSecondFactor.methods[:backup_codes]\n        current_user\n          .user_second_factors\n          .where(method: UserSecondFactor.methods[:backup_codes])\n          .destroy_all\n      else\n        user_second_factor.update!(enabled: false)\n      end\n    end\n\n    render json: success_json\n  end\n\n  def second_factor_check_confirmed_password\n    if SiteSetting.enable_discourse_connect || !SiteSetting.enable_local_logins\n      raise Discourse::NotFound\n    end\n\n    raise Discourse::InvalidAccess.new unless current_user && secure_session_confirmed?\n  end\n\n  def revoke_account\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n    provider_name = params.require(:provider_name)\n\n    # Using Discourse.authenticators rather than Discourse.enabled_authenticators so users can\n    # revoke permissions even if the admin has temporarily disabled that type of login\n    authenticator = Discourse.authenticators.find { |a| a.name == provider_name }\n    raise Discourse::NotFound if authenticator.nil? || !authenticator.can_revoke?\n\n    skip_remote = params.permit(:skip_remote)\n\n    # We're likely going to contact the remote auth provider, so hijack request\n    hijack do\n      DiscourseEvent.trigger(:before_auth_revoke, authenticator, user)\n      result = authenticator.revoke(user, skip_remote: skip_remote)\n      if result\n        render json: success_json\n      else\n        render json: {\n                 success: false,\n                 message: I18n.t(\"associated_accounts.revoke_failed\", provider_name: provider_name),\n               }\n      end\n    end\n  end\n\n  def revoke_auth_token\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    if params[:token_id]\n      token = UserAuthToken.find_by(id: params[:token_id], user_id: user.id)\n      # The user should not be able to revoke the auth token of current session.\n      if !token || guardian.auth_token == token.auth_token\n        raise Discourse::InvalidParameters.new(:token_id)\n      end\n      UserAuthToken.where(id: params[:token_id], user_id: user.id).each(&:destroy!)\n\n      MessageBus.publish \"/file-change\", [\"refresh\"], user_ids: [user.id]\n    else\n      UserAuthToken.where(user_id: user.id).each(&:destroy!)\n    end\n\n    render json: success_json\n  end\n\n  def feature_topic\n    user = fetch_user_from_params\n    topic = Topic.find(params[:topic_id].to_i)\n\n    if !guardian.can_feature_topic?(user, topic)\n      return(\n        render_json_error(\n          I18n.t(\"activerecord.errors.models.user_profile.attributes.featured_topic_id.invalid\"),\n          403,\n        )\n      )\n    end\n\n    user.user_profile.update(featured_topic_id: topic.id)\n    render json: success_json\n  end\n\n  def clear_featured_topic\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n    user.user_profile.update(featured_topic_id: nil)\n    render json: success_json\n  end\n\n  BOOKMARKS_LIMIT = 20\n\n  def bookmarks\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n    user_guardian = Guardian.new(user)\n\n    respond_to do |format|\n      format.json do\n        bookmark_list =\n          UserBookmarkList.new(\n            user: user,\n            guardian: guardian,\n            search_term: params[:q],\n            page: params[:page],\n            per_page: fetch_limit_from_params(default: nil, max: BOOKMARKS_LIMIT),\n          )\n\n        bookmark_list.load\n\n        if bookmark_list.bookmarks.empty?\n          render json: { bookmarks: [] }\n        else\n          page = params[:page].to_i + 1\n          bookmark_list.more_bookmarks_url =\n            \"#{Discourse.base_path}/u/#{params[:username]}/bookmarks.json?page=#{page}\"\n          render_serialized(bookmark_list, UserBookmarkListSerializer)\n        end\n      end\n      format.ics do\n        @bookmark_reminders =\n          Bookmark\n            .with_reminders\n            .where(user_id: user.id)\n            .order(:reminder_at)\n            .map do |bookmark|\n              bookmark.registered_bookmarkable.serializer.new(\n                bookmark,\n                scope: user_guardian,\n                root: false,\n              )\n            end\n      end\n    end\n  end\n\n  USER_MENU_LIST_LIMIT = 20\n  def user_menu_bookmarks\n    if !current_user.username_equals_to?(params[:username])\n      raise Discourse::InvalidAccess.new(\"username doesn't match current_user's username\")\n    end\n\n    reminder_notifications =\n      BookmarkQuery.new(user: current_user).unread_notifications(limit: USER_MENU_LIST_LIMIT)\n    if reminder_notifications.size < USER_MENU_LIST_LIMIT\n      exclude_bookmark_ids =\n        reminder_notifications.filter_map { |notification| notification.data_hash[:bookmark_id] }\n\n      bookmark_list =\n        UserBookmarkList.new(\n          user: current_user,\n          guardian: guardian,\n          per_page: USER_MENU_LIST_LIMIT - reminder_notifications.size,\n        )\n\n      bookmark_list.load do |query|\n        if exclude_bookmark_ids.present?\n          query.where(\"bookmarks.id NOT IN (?)\", exclude_bookmark_ids)\n        end\n      end\n    end\n\n    if reminder_notifications.present?\n      serialized_notifications =\n        ActiveModel::ArraySerializer.new(\n          reminder_notifications,\n          each_serializer: NotificationSerializer,\n          scope: guardian,\n        )\n    end\n\n    if bookmark_list\n      bookmark_list.bookmark_serializer_opts = { link_to_first_unread_post: true }\n      serialized_bookmarks =\n        serialize_data(bookmark_list, UserBookmarkListSerializer, scope: guardian, root: false)[\n          :bookmarks\n        ]\n    end\n\n    render json: {\n             notifications: serialized_notifications || [],\n             bookmarks: serialized_bookmarks || [],\n           }\n  end\n\n  def user_menu_messages\n    if !current_user.username_equals_to?(params[:username])\n      raise Discourse::InvalidAccess.new(\"username doesn't match current_user's username\")\n    end\n\n    if !current_user.staff? &&\n         !current_user.in_any_groups?(SiteSetting.personal_message_enabled_groups_map)\n      raise Discourse::InvalidAccess.new(\"personal messages are disabled.\")\n    end\n\n    unread_notifications =\n      Notification\n        .for_user_menu(current_user.id, limit: USER_MENU_LIST_LIMIT)\n        .unread\n        .where(\n          notification_type: [\n            Notification.types[:private_message],\n            Notification.types[:group_message_summary],\n          ],\n        )\n        .to_a\n\n    if unread_notifications.size < USER_MENU_LIST_LIMIT\n      exclude_topic_ids = unread_notifications.filter_map(&:topic_id).uniq\n      limit = USER_MENU_LIST_LIMIT - unread_notifications.size\n\n      messages_list =\n        TopicQuery\n          .new(current_user, per_page: limit)\n          .list_private_messages_direct_and_groups(\n            current_user,\n            groups_messages_notification_level: :watching,\n          ) do |query|\n            if exclude_topic_ids.present?\n              query.where(\"topics.id NOT IN (?)\", exclude_topic_ids)\n            else\n              query\n            end\n          end\n\n      read_notifications =\n        Notification\n          .for_user_menu(current_user.id, limit: limit)\n          .where(read: true, notification_type: Notification.types[:group_message_summary])\n          .to_a\n    end\n\n    if unread_notifications.present?\n      serialized_unread_notifications =\n        ActiveModel::ArraySerializer.new(\n          unread_notifications,\n          each_serializer: NotificationSerializer,\n          scope: guardian,\n        )\n    end\n\n    if messages_list\n      serialized_messages =\n        serialize_data(messages_list, TopicListSerializer, scope: guardian, root: false)[:topics]\n    end\n\n    if read_notifications.present?\n      serialized_read_notifications =\n        ActiveModel::ArraySerializer.new(\n          read_notifications,\n          each_serializer: NotificationSerializer,\n          scope: guardian,\n        )\n    end\n\n    render json: {\n             unread_notifications: serialized_unread_notifications || [],\n             read_notifications: serialized_read_notifications || [],\n             topics: serialized_messages || [],\n           }\n  end\n\n  private\n\n  def clean_custom_field_values(field)\n    field_values = params[:user_fields][field.id.to_s]\n\n    return field_values if field_values.nil? || field_values.empty?\n\n    if field.field_type == \"dropdown\"\n      field.user_field_options.find_by_value(field_values)&.value\n    elsif field.field_type == \"multiselect\"\n      field_values = Array.wrap(field_values)\n      bad_values = field_values - field.user_field_options.map(&:value)\n      field_values - bad_values\n    else\n      field_values\n    end\n  end\n\n  def password_reset_find_user(token, committing_change:)\n    @user =\n      if committing_change\n        EmailToken.confirm(token, scope: EmailToken.scopes[:password_reset])\n      else\n        EmailToken.confirmable(token, scope: EmailToken.scopes[:password_reset])&.user\n      end\n\n    if @user\n      secure_session[\"password-#{token}\"] = @user.id\n    else\n      user_id = secure_session[\"password-#{token}\"].to_i\n      @user = User.find(user_id) if user_id > 0\n    end\n\n    @error = I18n.t(\"password_reset.no_token\", base_url: Discourse.base_url) if !@user\n  end\n\n  def respond_to_suspicious_request\n    if suspicious?(params)\n      render json: {\n               success: true,\n               active: false,\n               message: I18n.t(\"login.activate_email\", email: params[:email]),\n             }\n    end\n  end\n\n  def suspicious?(params)\n    return false if current_user && is_api? && current_user.admin?\n    honeypot_or_challenge_fails?(params) || SiteSetting.invite_only?\n  end\n\n  def honeypot_or_challenge_fails?(params)\n    return false if is_api?\n    params[:password_confirmation] != honeypot_value ||\n      params[:challenge] != challenge_value.try(:reverse)\n  end\n\n  def user_params\n    permitted = %i[\n      name\n      email\n      password\n      username\n      title\n      date_of_birth\n      muted_usernames\n      allowed_pm_usernames\n      theme_ids\n      locale\n      bio_raw\n      location\n      website\n      dismissed_banner_key\n      profile_background_upload_url\n      card_background_upload_url\n      primary_group_id\n      flair_group_id\n      featured_topic_id\n    ]\n\n    editable_custom_fields = User.editable_user_custom_fields(by_staff: current_user.try(:staff?))\n    permitted << { custom_fields: editable_custom_fields } unless editable_custom_fields.blank?\n    permitted.concat UserUpdater::OPTION_ATTR\n    permitted.concat UserUpdater::CATEGORY_IDS.keys.map { |k| { k => [] } }\n    permitted.concat UserUpdater::TAG_NAMES.keys\n    permitted << UserUpdater::NOTIFICATION_SCHEDULE_ATTRS\n\n    if !SiteSetting.legacy_navigation_menu?\n      if params.has_key?(:sidebar_category_ids) && params[:sidebar_category_ids].blank?\n        params[:sidebar_category_ids] = []\n      end\n\n      permitted << { sidebar_category_ids: [] }\n\n      if SiteSetting.tagging_enabled\n        if params.has_key?(:sidebar_tag_names) && params[:sidebar_tag_names].blank?\n          params[:sidebar_tag_names] = []\n        end\n\n        permitted << { sidebar_tag_names: [] }\n      end\n    end\n\n    if SiteSetting.enable_user_status\n      permitted << :status\n      permitted << { status: %i[emoji description ends_at] }\n    end\n\n    result =\n      params.permit(permitted, theme_ids: [], seen_popups: []).reverse_merge(\n        ip_address: request.remote_ip,\n        registration_ip_address: request.remote_ip,\n      )\n\n    if !UsernameCheckerService.is_developer?(result[\"email\"]) && is_api? && current_user.present? &&\n         current_user.admin?\n      result.merge!(params.permit(:active, :staged, :approved))\n    end\n\n    deprecate_modify_user_params_method\n    result = modify_user_params(result)\n    DiscoursePluginRegistry.apply_modifier(\n      :users_controller_update_user_params,\n      result,\n      current_user,\n      params,\n    )\n  end\n\n  # Plugins can use this to modify user parameters\n  def modify_user_params(attrs)\n    attrs\n  end\n\n  def deprecate_modify_user_params_method\n    # only issue a deprecation warning if the method is overriden somewhere\n    if method(:modify_user_params).source_location[0] !=\n         \"#{Rails.root}/app/controllers/users_controller.rb\"\n      Discourse.deprecate(\n        \"`UsersController#modify_user_params` method is deprecated. Please use the `users_controller_update_user_params` modifier instead.\",\n        since: \"3.1.0.beta4\",\n        drop_from: \"3.2.0\",\n      )\n    end\n  end\n\n  def fail_with(key)\n    render json: { success: false, message: I18n.t(key) }\n  end\n\n  def track_visit_to_user_profile\n    user_profile_id = @user.user_profile.id\n    ip = request.remote_ip\n    user_id = (current_user.id if current_user)\n\n    Scheduler::Defer.later \"Track profile view visit\" do\n      UserProfileView.add(user_profile_id, ip, user_id)\n    end\n  end\n\n  def clashing_with_existing_route?(username)\n    normalized_username = User.normalize_username(username)\n    http_verbs = %w[GET POST PUT DELETE PATCH]\n    allowed_actions = %w[show update destroy]\n\n    http_verbs.any? do |verb|\n      begin\n        path = Rails.application.routes.recognize_path(\"/u/#{normalized_username}\", method: verb)\n        allowed_actions.exclude?(path[:action])\n      rescue ActionController::RoutingError\n        false\n      end\n    end\n  end\n\n  def confirm_secure_session\n    secure_session[\"confirmed-password-#{current_user.id}\"] = \"true\"\n  end\n\n  def secure_session_confirmed?\n    secure_session[\"confirmed-password-#{current_user.id}\"] == \"true\"\n  end\n\n  def summary_cache_key(user)\n    \"user_summary:#{user.id}:#{current_user ? current_user.id : 0}\"\n  end\n\n  def render_invite_error(message)\n    render json: { invites: [], can_see_invite_details: false, error: message }\n  end\n\n  def serialize_found_users(users)\n    each_serializer =\n      SiteSetting.enable_user_status? ? FoundUserWithStatusSerializer : FoundUserSerializer\n\n    { users: ActiveModel::ArraySerializer.new(users, each_serializer: each_serializer).as_json }\n  end\nend\n", "# frozen_string_literal: true\n\nclass Notification < ActiveRecord::Base\n  belongs_to :user\n  belongs_to :topic\n\n  has_one :shelved_notification\n\n  MEMBERSHIP_REQUEST_CONSOLIDATION_WINDOW_HOURS = 24\n\n  validates_presence_of :data\n  validates_presence_of :notification_type\n\n  scope :unread, lambda { where(read: false) }\n  scope :recent,\n        lambda { |n = nil|\n          n ||= 10\n          order(\"notifications.created_at desc\").limit(n)\n        }\n  scope :visible,\n        lambda {\n          joins(\"LEFT JOIN topics ON notifications.topic_id = topics.id\").where(\n            \"topics.id IS NULL OR topics.deleted_at IS NULL\",\n          )\n        }\n  scope :unread_type, ->(user, type, limit = 30) { unread_types(user, [type], limit) }\n  scope :unread_types,\n        ->(user, types, limit = 30) {\n          where(user_id: user.id, read: false, notification_type: types)\n            .visible\n            .includes(:topic)\n            .limit(limit)\n        }\n  scope :prioritized,\n        ->(deprioritized_types = []) {\n          scope = order(\"notifications.high_priority AND NOT notifications.read DESC\")\n          if deprioritized_types.present?\n            scope =\n              scope.order(\n                DB.sql_fragment(\n                  \"NOT notifications.read AND notifications.notification_type NOT IN (?) DESC\",\n                  deprioritized_types,\n                ),\n              )\n          else\n            scope = scope.order(\"NOT notifications.read DESC\")\n          end\n          scope.order(\"notifications.created_at DESC\")\n        }\n  scope :for_user_menu,\n        ->(user_id, limit: 30) {\n          where(user_id: user_id).visible.prioritized.includes(:topic).limit(limit)\n        }\n\n  attr_accessor :skip_send_email\n\n  after_commit :refresh_notification_count, on: %i[create update destroy]\n  after_commit :send_email, on: :create\n\n  after_commit(on: :create) { DiscourseEvent.trigger(:notification_created, self) }\n\n  before_create do\n    # if we have manually set the notification to high_priority on create then\n    # make sure that is respected\n    self.high_priority =\n      self.high_priority || Notification.high_priority_types.include?(self.notification_type)\n  end\n\n  def self.consolidate_or_create!(notification_params)\n    notification = new(notification_params)\n    consolidation_planner = Notifications::ConsolidationPlanner.new\n\n    consolidated_notification = consolidation_planner.consolidate_or_save!(notification)\n\n    consolidated_notification == :no_plan ? notification.tap(&:save!) : consolidated_notification\n  end\n\n  def self.purge_old!\n    return if SiteSetting.max_notifications_per_user == 0\n\n    DB.exec(<<~SQL, SiteSetting.max_notifications_per_user)\n      DELETE FROM notifications n1\n      USING (\n        SELECT * FROM (\n          SELECT\n            user_id,\n            id,\n            rank() OVER (PARTITION BY user_id ORDER BY id DESC)\n          FROM notifications\n        ) AS X\n        WHERE rank = ?\n      ) n2\n      WHERE n1.user_id = n2.user_id AND n1.id < n2.id\n    SQL\n  end\n\n  def self.ensure_consistency!\n    DB.exec(<<~SQL)\n      DELETE\n        FROM notifications n\n       WHERE high_priority\n         AND n.topic_id IS NOT NULL\n         AND NOT EXISTS (\n            SELECT 1\n              FROM posts p\n              JOIN topics t ON t.id = p.topic_id\n             WHERE p.deleted_at IS NULL\n               AND t.deleted_at IS NULL\n               AND p.post_number = n.post_number\n               AND t.id = n.topic_id\n          )\n    SQL\n  end\n\n  def self.types\n    @types ||=\n      Enum.new(\n        mentioned: 1,\n        replied: 2,\n        quoted: 3,\n        edited: 4,\n        liked: 5,\n        private_message: 6,\n        invited_to_private_message: 7,\n        invitee_accepted: 8,\n        posted: 9,\n        moved_post: 10,\n        linked: 11,\n        granted_badge: 12,\n        invited_to_topic: 13,\n        custom: 14,\n        group_mentioned: 15,\n        group_message_summary: 16,\n        watching_first_post: 17,\n        topic_reminder: 18,\n        liked_consolidated: 19,\n        post_approved: 20,\n        code_review_commit_approved: 21,\n        membership_request_accepted: 22,\n        membership_request_consolidated: 23,\n        bookmark_reminder: 24,\n        reaction: 25,\n        votes_released: 26,\n        event_reminder: 27,\n        event_invitation: 28,\n        chat_mention: 29,\n        chat_message: 30,\n        chat_invitation: 31,\n        chat_group_mention: 32, # March 2022 - This is obsolete, as all chat_mentions use `chat_mention` type\n        chat_quoted: 33,\n        assigned: 34,\n        question_answer_user_commented: 35, # Used by https://github.com/discourse/discourse-question-answer\n        watching_category_or_tag: 36,\n        new_features: 37,\n        admin_problems: 38,\n        following: 800, # Used by https://github.com/discourse/discourse-follow\n        following_created_topic: 801, # Used by https://github.com/discourse/discourse-follow\n        following_replied: 802, # Used by https://github.com/discourse/discourse-follow\n        circles_activity: 900, # Used by https://github.com/discourse/discourse-circles\n      )\n  end\n\n  def self.high_priority_types\n    @high_priority_types ||= [types[:private_message], types[:bookmark_reminder]]\n  end\n\n  def self.normal_priority_types\n    @normal_priority_types ||= types.reject { |_k, v| high_priority_types.include?(v) }.values\n  end\n\n  def self.mark_posts_read(user, topic_id, post_numbers)\n    Notification.where(\n      user_id: user.id,\n      topic_id: topic_id,\n      post_number: post_numbers,\n      read: false,\n    ).update_all(read: true)\n  end\n\n  def self.read(user, notification_ids)\n    Notification.where(id: notification_ids, user_id: user.id, read: false).update_all(read: true)\n  end\n\n  def self.read_types(user, types = nil)\n    query = Notification.where(user_id: user.id, read: false)\n    query = query.where(notification_type: types) if types\n    query.update_all(read: true)\n  end\n\n  def self.interesting_after(min_date)\n    result =\n      where(\"created_at > ?\", min_date)\n        .includes(:topic)\n        .visible\n        .unread\n        .limit(20)\n        .order(\n          \"CASE WHEN notification_type = #{Notification.types[:replied]} THEN 1\n                           WHEN notification_type = #{Notification.types[:mentioned]} THEN 2\n                           ELSE 3\n                      END, created_at DESC\",\n        )\n        .to_a\n\n    # Remove any duplicates by type and topic\n    if result.present?\n      seen = {}\n      to_remove = Set.new\n\n      result.each do |r|\n        seen[r.notification_type] ||= Set.new\n        if seen[r.notification_type].include?(r.topic_id)\n          to_remove << r.id\n        else\n          seen[r.notification_type] << r.topic_id\n        end\n      end\n      result.reject! { |r| to_remove.include?(r.id) }\n    end\n\n    result\n  end\n\n  # Clean up any notifications the user can no longer see. For example, if a topic was previously\n  # public then turns private.\n  def self.remove_for(user_id, topic_id)\n    Notification.where(user_id: user_id, topic_id: topic_id).delete_all\n  end\n\n  def self.filter_inaccessible_topic_notifications(guardian, notifications)\n    topic_ids = notifications.map { |n| n.topic_id }.compact.uniq\n    accessible_topic_ids = guardian.can_see_topic_ids(topic_ids: topic_ids)\n    notifications.select { |n| n.topic_id.blank? || accessible_topic_ids.include?(n.topic_id) }\n  end\n\n  # Be wary of calling this frequently. O(n) JSON parsing can suck.\n  def data_hash\n    @data_hash ||=\n      begin\n        return {} if data.blank?\n\n        parsed = JSON.parse(data)\n        return {} if parsed.blank?\n\n        parsed.with_indifferent_access\n      end\n  end\n\n  def url\n    topic.relative_url(post_number) if topic.present?\n  end\n\n  def post\n    return if topic_id.blank? || post_number.blank?\n    Post.find_by(topic_id: topic_id, post_number: post_number)\n  end\n\n  def self.like_types\n    [\n      Notification.types[:liked],\n      Notification.types[:liked_consolidated],\n      Notification.types[:reaction],\n    ]\n  end\n\n  def self.prioritized_list(user, count: 30, types: [])\n    return [] if !user&.user_option\n\n    notifications =\n      user\n        .notifications\n        .includes(:topic)\n        .visible\n        .prioritized(types.present? ? [] : like_types)\n        .limit(count)\n\n    if types.present?\n      notifications = notifications.where(notification_type: types)\n    elsif user.user_option.like_notification_frequency ==\n          UserOption.like_notification_frequency_type[:never]\n      like_types.each do |notification_type|\n        notifications = notifications.where(\"notification_type <> ?\", notification_type)\n      end\n    end\n    notifications.to_a\n  end\n\n  def self.recent_report(user, count = nil, types = [])\n    return unless user && user.user_option\n\n    count ||= 10\n    notifications = user.notifications.visible.recent(count).includes(:topic)\n\n    notifications = notifications.where(notification_type: types) if types.present?\n    if user.user_option.like_notification_frequency ==\n         UserOption.like_notification_frequency_type[:never]\n      [\n        Notification.types[:liked],\n        Notification.types[:liked_consolidated],\n      ].each do |notification_type|\n        notifications = notifications.where(\"notification_type <> ?\", notification_type)\n      end\n    end\n\n    notifications = notifications.to_a\n\n    if notifications.present?\n      builder = DB.build(<<~SQL)\n         SELECT n.id FROM notifications n\n         /*where*/\n        ORDER BY n.id ASC\n        /*limit*/\n      SQL\n\n      builder.where(<<~SQL, user_id: user.id)\n        n.high_priority = TRUE AND\n        n.user_id = :user_id AND\n        NOT read\n      SQL\n      builder.where(\"notification_type IN (:types)\", types: types) if types.present?\n      builder.limit(count.to_i)\n\n      ids = builder.query_single\n\n      if ids.length > 0\n        notifications +=\n          user\n            .notifications\n            .order(\"notifications.created_at DESC\")\n            .where(id: ids)\n            .joins(:topic)\n            .limit(count)\n      end\n\n      notifications\n        .uniq(&:id)\n        .sort do |x, y|\n          if x.unread_high_priority? && !y.unread_high_priority?\n            -1\n          elsif y.unread_high_priority? && !x.unread_high_priority?\n            1\n          else\n            y.created_at <=> x.created_at\n          end\n        end\n        .take(count)\n    else\n      []\n    end\n  end\n\n  def unread_high_priority?\n    self.high_priority? && !read\n  end\n\n  def post_id\n    Post.where(topic: topic_id, post_number: post_number).pick(:id)\n  end\n\n  protected\n\n  def refresh_notification_count\n    User.find_by(id: user_id)&.publish_notifications_state if user_id\n  end\n\n  def send_email\n    return if skip_send_email\n\n    if user.do_not_disturb?\n      ShelvedNotification.create(notification_id: self.id)\n    else\n      NotificationEmailer.process_notification(self)\n    end\n  end\nend\n\n# == Schema Information\n#\n# Table name: notifications\n#\n#  id                :integer          not null, primary key\n#  notification_type :integer          not null\n#  user_id           :integer          not null\n#  data              :string(1000)     not null\n#  read              :boolean          default(FALSE), not null\n#  created_at        :datetime         not null\n#  updated_at        :datetime         not null\n#  topic_id          :integer\n#  post_number       :integer\n#  post_action_id    :integer\n#  high_priority     :boolean          default(FALSE), not null\n#\n# Indexes\n#\n#  idx_notifications_speedup_unread_count                       (user_id,notification_type) WHERE (NOT read)\n#  index_notifications_on_post_action_id                        (post_action_id)\n#  index_notifications_on_topic_id_and_post_number              (topic_id,post_number)\n#  index_notifications_on_user_id_and_created_at                (user_id,created_at)\n#  index_notifications_on_user_id_and_topic_id_and_post_number  (user_id,topic_id,post_number)\n#  index_notifications_read_or_not_high_priority                (user_id,id DESC,read,topic_id) WHERE (read OR (high_priority = false))\n#  index_notifications_unique_unread_high_priority              (user_id,id) UNIQUE WHERE ((NOT read) AND (high_priority = true))\n#\n", "# frozen_string_literal: true\n\nclass PostBookmarkable < BaseBookmarkable\n  include TopicPostBookmarkableHelper\n\n  def self.model\n    Post\n  end\n\n  def self.serializer\n    UserPostBookmarkSerializer\n  end\n\n  def self.preload_associations\n    [{ topic: %i[tags category] }, :user]\n  end\n\n  def self.list_query(user, guardian)\n    topics = Topic.listable_topics.secured(guardian)\n    pms = Topic.private_messages_for_user(user)\n    post_bookmarks =\n      user\n        .bookmarks_of_type(\"Post\")\n        .joins(\n          \"INNER JOIN posts ON posts.id = bookmarks.bookmarkable_id AND bookmarks.bookmarkable_type = 'Post'\",\n        )\n        .joins(\"LEFT JOIN topics ON topics.id = posts.topic_id\")\n        .joins(\"LEFT JOIN topic_users ON topic_users.topic_id = topics.id\")\n        .where(\"topic_users.user_id = ?\", user.id)\n    guardian.filter_allowed_categories(\n      post_bookmarks.merge(topics.or(pms)).merge(Post.secured(guardian)),\n    )\n  end\n\n  def self.search_query(bookmarks, query, ts_query, &bookmarkable_search)\n    bookmarkable_search.call(\n      bookmarks.joins(\n        \"LEFT JOIN post_search_data ON post_search_data.post_id = bookmarks.bookmarkable_id AND bookmarks.bookmarkable_type = 'Post'\",\n      ),\n      \"#{ts_query} @@ post_search_data.search_data\",\n    )\n  end\n\n  def self.reminder_handler(bookmark)\n    send_reminder_notification(\n      bookmark,\n      topic_id: bookmark.bookmarkable.topic_id,\n      post_number: bookmark.bookmarkable.post_number,\n      data: {\n        title: bookmark.bookmarkable.topic.title,\n        bookmarkable_url: bookmark.bookmarkable.url,\n      },\n    )\n  end\n\n  def self.reminder_conditions(bookmark)\n    bookmark.bookmarkable.present? && bookmark.bookmarkable.topic.present? &&\n      self.can_see?(bookmark.user.guardian, bookmark)\n  end\n\n  def self.can_see?(guardian, bookmark)\n    guardian.can_see_post?(bookmark.bookmarkable)\n  end\n\n  def self.bookmark_metadata(bookmark, user)\n    {\n      topic_bookmarked: Bookmark.for_user_in_topic(user.id, bookmark.bookmarkable.topic_id).exists?,\n    }\n  end\n\n  def self.validate_before_create(guardian, bookmarkable)\n    if bookmarkable.blank? || bookmarkable.topic.blank? ||\n         !guardian.can_see_topic?(bookmarkable.topic) || !guardian.can_see_post?(bookmarkable)\n      raise Discourse::InvalidAccess\n    end\n  end\n\n  def self.after_create(guardian, bookmark, opts)\n    sync_topic_user_bookmarked(guardian.user, bookmark.bookmarkable.topic, opts)\n  end\n\n  def self.after_destroy(guardian, bookmark, opts)\n    sync_topic_user_bookmarked(guardian.user, bookmark.bookmarkable.topic, opts)\n  end\n\n  def self.cleanup_deleted\n    related_topics = DB.query(<<~SQL, grace_time: 3.days.ago)\n      DELETE FROM bookmarks b\n      USING topics t, posts p\n      WHERE t.id = p.topic_id AND b.bookmarkable_id = p.id AND b.bookmarkable_type = 'Post'\n      AND (t.deleted_at < :grace_time OR p.deleted_at < :grace_time)\n      RETURNING t.id AS topic_id\n    SQL\n\n    related_topics_ids = related_topics.map(&:topic_id).uniq\n    related_topics_ids.each do |topic_id|\n      Jobs.enqueue(:sync_topic_user_bookmarked, topic_id: topic_id)\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nclass TopicBookmarkable < BaseBookmarkable\n  include TopicPostBookmarkableHelper\n\n  def self.model\n    Topic\n  end\n\n  def self.serializer\n    UserTopicBookmarkSerializer\n  end\n\n  def self.preload_associations\n    [:category, :tags, { first_post: :user }]\n  end\n\n  def self.perform_custom_preload!(topic_bookmarks, guardian)\n    topics = topic_bookmarks.map(&:bookmarkable)\n    topic_user_lookup = TopicUser.lookup_for(guardian.user, topics)\n\n    topics.each { |topic| topic.user_data = topic_user_lookup[topic.id] }\n  end\n\n  def self.list_query(user, guardian)\n    topics = Topic.listable_topics.secured(guardian)\n    pms = Topic.private_messages_for_user(user)\n    topic_bookmarks =\n      user\n        .bookmarks_of_type(\"Topic\")\n        .joins(\n          \"INNER JOIN topics ON topics.id = bookmarks.bookmarkable_id AND bookmarks.bookmarkable_type = 'Topic'\",\n        )\n        .joins(\"LEFT JOIN topic_users ON topic_users.topic_id = topics.id\")\n        .where(\"topic_users.user_id = ?\", user.id)\n    guardian.filter_allowed_categories(topic_bookmarks.merge(topics.or(pms)))\n  end\n\n  def self.search_query(bookmarks, query, ts_query, &bookmarkable_search)\n    bookmarkable_search.call(\n      bookmarks.joins(\n        \"LEFT JOIN posts ON posts.topic_id = topics.id AND posts.post_number = 1\",\n      ).joins(\"LEFT JOIN post_search_data ON post_search_data.post_id = posts.id\"),\n      \"#{ts_query} @@ post_search_data.search_data\",\n    )\n  end\n\n  def self.reminder_handler(bookmark)\n    send_reminder_notification(\n      bookmark,\n      topic_id: bookmark.bookmarkable_id,\n      post_number: 1,\n      data: {\n        title: bookmark.bookmarkable.title,\n        bookmarkable_url: bookmark.bookmarkable.first_post.url,\n      },\n    )\n  end\n\n  def self.reminder_conditions(bookmark)\n    bookmark.bookmarkable.present? && self.can_see?(bookmark.user.guardian, bookmark)\n  end\n\n  def self.can_see?(guardian, bookmark)\n    guardian.can_see_topic?(bookmark.bookmarkable)\n  end\n\n  def self.bookmark_metadata(bookmark, user)\n    { topic_bookmarked: Bookmark.for_user_in_topic(user.id, bookmark.bookmarkable.id).exists? }\n  end\n\n  def self.validate_before_create(guardian, bookmarkable)\n    raise Discourse::InvalidAccess if bookmarkable.blank? || !guardian.can_see_topic?(bookmarkable)\n  end\n\n  def self.after_create(guardian, bookmark, opts)\n    sync_topic_user_bookmarked(guardian.user, bookmark.bookmarkable, opts)\n  end\n\n  def self.after_destroy(guardian, bookmark, opts)\n    sync_topic_user_bookmarked(guardian.user, bookmark.bookmarkable, opts)\n  end\n\n  def self.cleanup_deleted\n    related_topics = DB.query(<<~SQL, grace_time: 3.days.ago)\n      DELETE FROM bookmarks b\n      USING topics t\n      WHERE b.bookmarkable_id = t.id AND b.bookmarkable_type = 'Topic'\n      AND (t.deleted_at < :grace_time)\n      RETURNING t.id AS topic_id\n    SQL\n\n    related_topics_ids = related_topics.map(&:topic_id).uniq\n    related_topics_ids.each do |topic_id|\n      Jobs.enqueue(:sync_topic_user_bookmarked, topic_id: topic_id)\n    end\n  end\nend\n", "# frozen_string_literal: true\n\n##\n# Allows us to query Bookmark records for lists. Used mainly\n# in the user/activity/bookmarks page.\n\nclass BookmarkQuery\n  def self.on_preload(&blk)\n    (@preload ||= Set.new) << blk\n  end\n\n  def self.preload(bookmarks, object)\n    preload_polymorphic_associations(bookmarks, object.guardian)\n    @preload.each { |preload| preload.call(bookmarks, object) } if @preload\n  end\n\n  # These polymorphic associations are loaded to make the UserBookmarkListSerializer's\n  # life easier, which conditionally chooses the bookmark serializer to use based\n  # on the type, and we want the associations all loaded ahead of time to make\n  # sure we are not doing N+1s.\n  def self.preload_polymorphic_associations(bookmarks, guardian)\n    Bookmark.registered_bookmarkables.each do |registered_bookmarkable|\n      registered_bookmarkable.perform_preload(bookmarks, guardian)\n    end\n  end\n\n  attr_reader :guardian, :count\n\n  def initialize(user:, guardian: nil, search_term: nil, page: nil, per_page: nil)\n    @user = user\n    @search_term = search_term\n    @guardian = guardian || Guardian.new(@user)\n    @page = page ? page.to_i : 0\n    @per_page = per_page ? per_page.to_i : 20\n    @count = 0\n  end\n\n  def list_all(&blk)\n    ts_query = @search_term.present? ? Search.ts_query(term: @search_term) : nil\n    search_term_wildcard = @search_term.present? ? \"%#{@search_term}%\" : nil\n\n    queries =\n      Bookmark\n        .registered_bookmarkables\n        .map do |bookmarkable|\n          interim_results = bookmarkable.perform_list_query(@user, @guardian)\n\n          # this could occur if there is some security reason that the user cannot\n          # access the bookmarkables that they have bookmarked, e.g. if they had 1 bookmark\n          # on a topic and that topic was moved into a private category\n          next if interim_results.blank?\n\n          if @search_term.present?\n            interim_results =\n              bookmarkable.perform_search_query(interim_results, search_term_wildcard, ts_query)\n          end\n\n          # this is purely to make the query easy to read and debug, otherwise it's\n          # all mashed up into a massive ball in MiniProfiler :)\n          \"---- #{bookmarkable.model.to_s} bookmarkable ---\\n\\n #{interim_results.to_sql}\"\n        end\n        .compact\n\n    # same for interim results being blank, the user might have been locked out\n    # from all their various bookmarks, in which case they will see nothing and\n    # no further pagination/ordering/etc is required\n    return [] if queries.empty?\n\n    union_sql = queries.join(\"\\n\\nUNION\\n\\n\")\n    results = Bookmark.select(\"bookmarks.*\").from(\"(\\n\\n#{union_sql}\\n\\n) as bookmarks\")\n    results =\n      results.order(\n        \"(CASE WHEN bookmarks.pinned THEN 0 ELSE 1 END),\n        bookmarks.reminder_at ASC,\n        bookmarks.updated_at DESC\",\n      )\n\n    @count = results.count\n\n    results = results.offset(@page * @per_page) if @page.positive?\n\n    if updated_results = blk&.call(results)\n      results = updated_results\n    end\n\n    results = results.limit(@per_page).to_a\n\n    BookmarkQuery.preload(results, self)\n    results\n  end\n\n  def unread_notifications(limit: 20)\n    reminder_notifications =\n      Notification\n        .for_user_menu(@user.id, limit: [limit, 100].min)\n        .unread\n        .where(notification_type: Notification.types[:bookmark_reminder])\n\n    # We preload associations like we do above for the list to avoid\n    # N1s in the can_see? guardian calls for each bookmark.\n    bookmarks =\n      Bookmark.where(\n        id: reminder_notifications.map { |n| n.data_hash[:bookmark_id] }.compact,\n        user: @user,\n      )\n    BookmarkQuery.preload(bookmarks, self)\n\n    reminder_notifications.select do |n|\n      bookmark = bookmarks.find { |bm| bm.id == n.data_hash[:bookmark_id] }\n      next if bookmark.blank?\n      bookmarkable = Bookmark.registered_bookmarkable_from_type(bookmark.bookmarkable_type)\n      bookmarkable.can_see?(@guardian, bookmark)\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nmodule Chat\n  class MessageBookmarkable < BaseBookmarkable\n    def self.model\n      Chat::Message\n    end\n\n    def self.serializer\n      Chat::UserMessageBookmarkSerializer\n    end\n\n    def self.preload_associations\n      [{ chat_channel: :chatable }]\n    end\n\n    def self.list_query(user, guardian)\n      accessible_channel_ids = Chat::ChannelFetcher.all_secured_channel_ids(guardian)\n      return if accessible_channel_ids.empty?\n\n      joins =\n        ActiveRecord::Base.public_send(\n          :sanitize_sql_array,\n          [\n            \"INNER JOIN chat_messages ON chat_messages.id = bookmarks.bookmarkable_id AND chat_messages.deleted_at IS NULL AND bookmarks.bookmarkable_type = ?\",\n            Chat::Message.polymorphic_name,\n          ],\n        )\n\n      user\n        .bookmarks_of_type(Chat::Message.polymorphic_name)\n        .joins(joins)\n        .where(\"chat_messages.chat_channel_id IN (?)\", accessible_channel_ids)\n    end\n\n    def self.search_query(bookmarks, query, ts_query, &bookmarkable_search)\n      bookmarkable_search.call(bookmarks, \"chat_messages.message ILIKE :q\")\n    end\n\n    def self.validate_before_create(guardian, bookmarkable)\n      if bookmarkable.blank? || !guardian.can_join_chat_channel?(bookmarkable.chat_channel)\n        raise Discourse::InvalidAccess\n      end\n    end\n\n    def self.reminder_handler(bookmark)\n      send_reminder_notification(\n        bookmark,\n        data: {\n          title:\n            I18n.t(\n              \"chat.bookmarkable.notification_title\",\n              channel_name: bookmark.bookmarkable.chat_channel.title(bookmark.user),\n            ),\n          bookmarkable_url: bookmark.bookmarkable.url,\n        },\n      )\n    end\n\n    def self.reminder_conditions(bookmark)\n      bookmark.bookmarkable.present? && bookmark.bookmarkable.chat_channel.present? &&\n        self.can_see?(bookmark.user.guardian, bookmark)\n    end\n\n    def self.can_see?(guardian, bookmark)\n      guardian.can_join_chat_channel?(bookmark.bookmarkable.chat_channel)\n    end\n\n    def self.cleanup_deleted\n      DB.query(<<~SQL, grace_time: 3.days.ago, bookmarkable_type: Chat::Message.polymorphic_name)\n      DELETE FROM bookmarks b\n      USING chat_messages cm\n      WHERE b.bookmarkable_id = cm.id\n      AND b.bookmarkable_type = :bookmarkable_type\n      AND (cm.deleted_at < :grace_time)\n    SQL\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\ndescribe Chat::MessageBookmarkable do\n  subject(:registered_bookmarkable) { RegisteredBookmarkable.new(described_class) }\n\n  fab!(:chatters) { Fabricate(:group) }\n  fab!(:user) { Fabricate(:user, group_ids: [chatters.id]) }\n  fab!(:guardian) { Guardian.new(user) }\n  fab!(:other_category) { Fabricate(:private_category, group: Fabricate(:group)) }\n  fab!(:category_channel) { Fabricate(:category_channel, chatable: other_category) }\n  fab!(:private_category) { Fabricate(:private_category, group: Fabricate(:group)) }\n  fab!(:channel) { Fabricate(:category_channel) }\n\n  before do\n    register_test_bookmarkable(described_class)\n    Chat::UserChatChannelMembership.create(chat_channel: channel, user: user, following: true)\n    SiteSetting.chat_allowed_groups = [chatters]\n  end\n\n  after { DiscoursePluginRegistry.reset_register!(:bookmarkables) }\n\n  let!(:message1) { Fabricate(:chat_message, chat_channel: channel) }\n  let!(:message2) { Fabricate(:chat_message, chat_channel: channel) }\n  let!(:bookmark1) do\n    Fabricate(:bookmark, user: user, bookmarkable: message1, name: \"something i gotta do\")\n  end\n  let!(:bookmark2) { Fabricate(:bookmark, user: user, bookmarkable: message2) }\n  let!(:bookmark3) { Fabricate(:bookmark) }\n\n  describe \"#perform_list_query\" do\n    it \"returns all the user's bookmarks\" do\n      expect(registered_bookmarkable.perform_list_query(user, guardian).map(&:id)).to match_array(\n        [bookmark1.id, bookmark2.id],\n      )\n    end\n\n    it \"does not return bookmarks for messages inside category chat channels the user cannot access\" do\n      channel.update(chatable: other_category)\n      expect(registered_bookmarkable.perform_list_query(user, guardian)).to eq(nil)\n      other_category.groups.last.add(user)\n      bookmark1.reload\n      user.reload\n      guardian = Guardian.new(user)\n      expect(registered_bookmarkable.perform_list_query(user, guardian).map(&:id)).to match_array(\n        [bookmark1.id, bookmark2.id],\n      )\n    end\n\n    it \"does not return bookmarks for messages inside direct message chat channels the user cannot access\" do\n      direct_message = Fabricate(:direct_message)\n      channel.update(chatable: direct_message)\n      expect(registered_bookmarkable.perform_list_query(user, guardian)).to eq(nil)\n      Chat::DirectMessageUser.create(user: user, direct_message: direct_message)\n      bookmark1.reload\n      user.reload\n      guardian = Guardian.new(user)\n      expect(registered_bookmarkable.perform_list_query(user, guardian).map(&:id)).to match_array(\n        [bookmark1.id, bookmark2.id],\n      )\n    end\n\n    it \"does not return bookmarks for deleted messages\" do\n      message1.trash!\n      guardian = Guardian.new(user)\n      expect(registered_bookmarkable.perform_list_query(user, guardian).map(&:id)).to match_array(\n        [bookmark2.id],\n      )\n    end\n  end\n\n  describe \"#perform_search_query\" do\n    before { SearchIndexer.enable }\n\n    it \"returns bookmarks that match by name\" do\n      ts_query = Search.ts_query(term: \"gotta\", ts_config: \"simple\")\n      expect(\n        registered_bookmarkable.perform_search_query(\n          registered_bookmarkable.perform_list_query(user, guardian),\n          \"%gotta%\",\n          ts_query,\n        ).map(&:id),\n      ).to match_array([bookmark1.id])\n    end\n\n    it \"returns bookmarks that match by chat message message content\" do\n      message2.update(message: \"some good soup\")\n\n      ts_query = Search.ts_query(term: \"good soup\", ts_config: \"simple\")\n      expect(\n        registered_bookmarkable.perform_search_query(\n          registered_bookmarkable.perform_list_query(user, guardian),\n          \"%good soup%\",\n          ts_query,\n        ).map(&:id),\n      ).to match_array([bookmark2.id])\n\n      ts_query = Search.ts_query(term: \"blah\", ts_config: \"simple\")\n      expect(\n        registered_bookmarkable.perform_search_query(\n          registered_bookmarkable.perform_list_query(user, guardian),\n          \"%blah%\",\n          ts_query,\n        ).map(&:id),\n      ).to eq([])\n    end\n  end\n\n  describe \"#can_send_reminder?\" do\n    it \"cannot send the reminder if the message or channel is deleted\" do\n      expect(registered_bookmarkable.can_send_reminder?(bookmark1)).to eq(true)\n      bookmark1.bookmarkable.trash!\n      bookmark1.reload\n      expect(registered_bookmarkable.can_send_reminder?(bookmark1)).to eq(false)\n      Chat::Message.with_deleted.find_by(id: bookmark1.bookmarkable_id).recover!\n      bookmark1.reload\n      bookmark1.bookmarkable.chat_channel.trash!\n      bookmark1.reload\n      expect(registered_bookmarkable.can_send_reminder?(bookmark1)).to eq(false)\n    end\n\n    it \"cannot send reminder if the user cannot access the channel\" do\n      expect(registered_bookmarkable.can_send_reminder?(bookmark1)).to eq(true)\n      bookmark1.bookmarkable.update!(chat_channel: Fabricate(:private_category_channel))\n      bookmark1.reload\n      expect(registered_bookmarkable.can_send_reminder?(bookmark1)).to eq(false)\n    end\n  end\n\n  describe \"#reminder_handler\" do\n    it \"creates a notification for the user with the correct details\" do\n      expect { registered_bookmarkable.send_reminder_notification(bookmark1) }.to change {\n        Notification.count\n      }.by(1)\n      notification = user.notifications.last\n      expect(notification.notification_type).to eq(Notification.types[:bookmark_reminder])\n      expect(notification.data).to eq(\n        {\n          title:\n            I18n.t(\n              \"chat.bookmarkable.notification_title\",\n              channel_name: bookmark1.bookmarkable.chat_channel.title(bookmark1.user),\n            ),\n          bookmarkable_url: bookmark1.bookmarkable.url,\n          display_username: bookmark1.user.username,\n          bookmark_name: bookmark1.name,\n          bookmark_id: bookmark1.id,\n        }.to_json,\n      )\n    end\n  end\n\n  describe \"#can_see?\" do\n    it \"returns false if the chat message is in a channel the user cannot see\" do\n      expect(registered_bookmarkable.can_see?(guardian, bookmark1)).to eq(true)\n      bookmark1.bookmarkable.chat_channel.update!(chatable: private_category)\n      expect(registered_bookmarkable.can_see?(guardian, bookmark1)).to eq(false)\n      private_category.groups.last.add(user)\n      bookmark1.reload\n      user.reload\n      guardian = Guardian.new(user)\n      expect(registered_bookmarkable.can_see?(guardian, bookmark1)).to eq(true)\n    end\n  end\n\n  describe \"#validate_before_create\" do\n    it \"raises InvalidAccess if the user cannot see the chat channel\" do\n      expect {\n        registered_bookmarkable.validate_before_create(guardian, bookmark1.bookmarkable)\n      }.not_to raise_error\n      bookmark1.bookmarkable.chat_channel.update!(chatable: private_category)\n      expect {\n        registered_bookmarkable.validate_before_create(guardian, bookmark1.bookmarkable)\n      }.to raise_error(Discourse::InvalidAccess)\n      private_category.groups.last.add(user)\n      bookmark1.reload\n      user.reload\n      guardian = Guardian.new(user)\n      expect {\n        registered_bookmarkable.validate_before_create(guardian, bookmark1.bookmarkable)\n      }.not_to raise_error\n    end\n\n    it \"raises InvalidAccess if the chat message is deleted\" do\n      expect {\n        registered_bookmarkable.validate_before_create(guardian, bookmark1.bookmarkable)\n      }.not_to raise_error\n      bookmark1.bookmarkable.trash!\n      bookmark1.reload\n      expect {\n        registered_bookmarkable.validate_before_create(guardian, bookmark1.bookmarkable)\n      }.to raise_error(Discourse::InvalidAccess)\n    end\n  end\n\n  describe \"#cleanup_deleted\" do\n    it \"deletes bookmarks for chat messages deleted more than 3 days ago\" do\n      bookmark_post = Fabricate(:bookmark, bookmarkable: Fabricate(:post))\n      bookmark1.bookmarkable.trash!\n      bookmark1.bookmarkable.update!(deleted_at: 4.days.ago)\n      registered_bookmarkable.cleanup_deleted\n      expect(Bookmark.exists?(id: bookmark1.id)).to eq(false)\n      expect(Bookmark.exists?(id: bookmark2.id)).to eq(true)\n      expect(Bookmark.exists?(id: bookmark_post.id)).to eq(true)\n    end\n  end\nend\n", "# frozen_string_literal: true\n\ndescribe UsersController do\n  describe \"#perform_account_activation\" do\n    let!(:channel) { Fabricate(:category_channel, auto_join_users: true) }\n\n    before do\n      Jobs.run_immediately!\n      UsersController.any_instance.stubs(:honeypot_or_challenge_fails?).returns(false)\n      SiteSetting.send_welcome_message = false\n      SiteSetting.chat_enabled = true\n    end\n\n    it \"triggers the auto-join process\" do\n      user = Fabricate(:user, last_seen_at: 1.minute.ago, active: false)\n      email_token = Fabricate(:email_token, user: user)\n\n      put \"/u/activate-account/#{email_token.token}\"\n\n      expect(response.status).to eq(200)\n      membership = Chat::UserChatChannelMembership.find_by(user: user, chat_channel: channel)\n      expect(membership.following).to eq(true)\n    end\n  end\n\n  describe \"#user_menu_bookmarks\" do\n    fab!(:chatters) { Fabricate(:group) }\n    let(:current_user) { Fabricate(:user, group_ids: [chatters.id]) }\n    let(:bookmark_message) { Fabricate(:chat_message) }\n    let(:bookmark_user) { current_user }\n\n    before do\n      register_test_bookmarkable(Chat::MessageBookmarkable)\n      SiteSetting.chat_allowed_groups = [chatters]\n      sign_in(current_user)\n    end\n\n    it \"does not return any unread notifications for chat bookmarks that the user no longer has access to\" do\n      bookmark_with_reminder =\n        Fabricate(:bookmark, user: current_user, bookmarkable: bookmark_message)\n      BookmarkReminderNotificationHandler.new(bookmark_with_reminder).send_notification\n\n      bookmark_with_reminder.bookmarkable.update!(\n        chat_channel: Fabricate(:private_category_channel),\n      )\n\n      get \"/u/#{current_user.username}/user-menu-bookmarks\"\n      expect(response.status).to eq(200)\n\n      notifications = response.parsed_body[\"notifications\"]\n      expect(notifications.size).to eq(0)\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nRSpec.describe BookmarkQuery do\n  before { SearchIndexer.enable }\n\n  fab!(:user) { Fabricate(:user) }\n\n  def bookmark_query(user: nil, search_term: nil, per_page: nil)\n    BookmarkQuery.new(user: user || self.user, search_term:, per_page:)\n  end\n\n  describe \"#list_all\" do\n    before do\n      register_test_bookmarkable\n\n      Fabricate(:topic_user, user: user, topic: post_bookmark.bookmarkable.topic)\n      Fabricate(:topic_user, user: user, topic: topic_bookmark.bookmarkable)\n      user_bookmark\n    end\n\n    after { DiscoursePluginRegistry.reset! }\n\n    let(:post_bookmark) { Fabricate(:bookmark, user: user, bookmarkable: Fabricate(:post)) }\n    let(:topic_bookmark) { Fabricate(:bookmark, user: user, bookmarkable: Fabricate(:topic)) }\n    let(:user_bookmark) do\n      Fabricate(:bookmark, user: user, bookmarkable: Fabricate(:user, username: \"bookmarkqueen\"))\n    end\n\n    it \"returns all the bookmarks for a user\" do\n      expect(bookmark_query.list_all.count).to eq(3)\n    end\n\n    it \"does not return deleted bookmarkables\" do\n      post_bookmark.bookmarkable.trash!\n      topic_bookmark.bookmarkable.trash!\n      expect(bookmark_query.list_all.count).to eq(1)\n    end\n\n    it \"runs the on_preload block provided passing in bookmarks\" do\n      preloaded_bookmarks = []\n      BookmarkQuery.on_preload { |bookmarks, bq| (preloaded_bookmarks << bookmarks).flatten }\n      bookmark_query.list_all\n      expect(preloaded_bookmarks.any?).to eq(true)\n    end\n\n    it \"returns a mixture of post, topic, and custom bookmarkable type bookmarks\" do\n      bookmarks = bookmark_query.list_all\n      expect(bookmarks.map(&:id)).to match_array(\n        [post_bookmark.id, topic_bookmark.id, user_bookmark.id],\n      )\n    end\n\n    it \"handles the user not having permission for all of the bookmarks of a certain bookmarkable\" do\n      UserTestBookmarkable.expects(:list_query).returns(nil)\n      bookmarks = bookmark_query.list_all\n      expect(bookmarks.map(&:id)).to match_array([post_bookmark.id, topic_bookmark.id])\n    end\n\n    it \"handles the user not having permission to see any of their bookmarks\" do\n      topic_bookmark.bookmarkable.update(\n        category: Fabricate(:private_category, group: Fabricate(:group)),\n      )\n      post_bookmark.bookmarkable.topic.update(category: topic_bookmark.bookmarkable.category)\n      UserTestBookmarkable.expects(:list_query).returns(nil)\n      bookmarks = bookmark_query.list_all\n      expect(bookmarks.map(&:id)).to eq([])\n    end\n\n    context \"when search_term is provided\" do\n      let!(:post) do\n        Fabricate(\n          :post,\n          raw: \"Some post content here\",\n          topic: Fabricate(:topic, title: \"Bugfix game for devs\"),\n        )\n      end\n\n      after { DiscoursePluginRegistry.reset! }\n\n      let(:bookmark3) do\n        Fabricate(:bookmark, user: user, name: \"Check up later\", bookmarkable: Fabricate(:post))\n      end\n      let(:bookmark4) { Fabricate(:bookmark, user: user, bookmarkable: post) }\n\n      before do\n        Fabricate(:topic_user, user: user, topic: bookmark3.bookmarkable.topic)\n        Fabricate(:topic_user, user: user, topic: bookmark4.bookmarkable.topic)\n      end\n\n      it \"can search by bookmark name\" do\n        bookmarks = bookmark_query(search_term: \"check\").list_all\n        expect(bookmarks.map(&:id)).to eq([bookmark3.id])\n      end\n\n      it \"can search by post content\" do\n        bookmarks = bookmark_query(search_term: \"content\").list_all\n        expect(bookmarks.map(&:id)).to eq([bookmark4.id])\n      end\n\n      it \"can search by topic title\" do\n        bookmarks = bookmark_query(search_term: \"bugfix\").list_all\n        expect(bookmarks.map(&:id)).to eq([bookmark4.id])\n      end\n\n      context \"with custom bookmarkable fitering\" do\n        before { register_test_bookmarkable }\n\n        after { DiscoursePluginRegistry.reset! }\n\n        let!(:bookmark5) do\n          Fabricate(:bookmark, user: user, bookmarkable: Fabricate(:user, username: \"bookmarkking\"))\n        end\n\n        it \"allows searching bookmarkables by fields in other tables\" do\n          bookmarks = bookmark_query(search_term: \"bookmarkk\").list_all\n          expect(bookmarks.map(&:id)).to eq([bookmark5.id])\n        end\n      end\n    end\n\n    context \"for a whispered post\" do\n      before do\n        post_bookmark.bookmarkable.update(post_type: Post.types[:whisper])\n        SiteSetting.whispers_allowed_groups = \"#{Group::AUTO_GROUPS[:staff]}\"\n      end\n      fab!(:whisperers_group) { Fabricate(:group) }\n\n      context \"when the user is moderator\" do\n        it \"does return the whispered post\" do\n          user.grant_moderation!\n          expect(bookmark_query.list_all.count).to eq(3)\n        end\n      end\n      context \"when the user is admin\" do\n        it \"does return the whispered post\" do\n          user.grant_admin!\n          expect(bookmark_query.list_all.count).to eq(3)\n        end\n      end\n      context \"when the user is a member of whisperers group\" do\n        it \"returns the whispered post\" do\n          SiteSetting.whispers_allowed_groups = \"#{whisperers_group.id}\"\n          user.update!(groups: [whisperers_group])\n          expect(bookmark_query.list_all.count).to eq(3)\n        end\n      end\n      context \"when the user is not staff\" do\n        it \"does not return the whispered post\" do\n          expect(bookmark_query.list_all.count).to eq(2)\n        end\n      end\n    end\n\n    context \"for a private message topic bookmark\" do\n      let(:pm_topic) { Fabricate(:private_message_topic) }\n      before do\n        post_bookmark.update(bookmarkable: Fabricate(:post, topic: pm_topic))\n        TopicUser.change(user.id, pm_topic.id, total_msecs_viewed: 1)\n      end\n\n      context \"when the user is a topic_allowed_user\" do\n        before { TopicAllowedUser.create(topic: pm_topic, user: user) }\n        it \"shows the user the bookmark in the PM\" do\n          expect(bookmark_query.list_all.map(&:id).count).to eq(3)\n        end\n      end\n\n      context \"when the user is in a topic_allowed_group\" do\n        before do\n          group = Fabricate(:group)\n          GroupUser.create(group: group, user: user)\n          TopicAllowedGroup.create(topic: pm_topic, group: group)\n        end\n        it \"shows the user the bookmark in the PM\" do\n          expect(bookmark_query.list_all.map(&:id).count).to eq(3)\n        end\n      end\n\n      context \"when the user is not a topic_allowed_user\" do\n        it \"does not show the user a bookmarked post in a PM where they are not an allowed user\" do\n          expect(bookmark_query.list_all.map(&:id).count).to eq(2)\n        end\n      end\n\n      context \"when the user is not in a topic_allowed_group\" do\n        it \"does not show the user a bookmarked post in a PM where they are not in an allowed group\" do\n          expect(bookmark_query.list_all.map(&:id).count).to eq(2)\n        end\n      end\n    end\n\n    context \"when the topic category is private\" do\n      let(:group) { Fabricate(:group) }\n      before do\n        post_bookmark.bookmarkable.topic.update(\n          category: Fabricate(:private_category, group: group),\n        )\n        post_bookmark.reload\n      end\n      it \"does not show the user a post/topic in a private category they cannot see\" do\n        expect(bookmark_query.list_all.map(&:id)).not_to include(post_bookmark.id)\n      end\n      it \"does show the user a post/topic in a private category they can see\" do\n        GroupUser.create(user: user, group: group)\n        expect(bookmark_query.list_all.map(&:id)).to include(post_bookmark.id)\n      end\n    end\n\n    context \"when the per_page is provided\" do\n      it \"is respected\" do\n        expect(bookmark_query(per_page: 1).list_all.count).to eq(1)\n      end\n    end\n  end\n\n  describe \"#list_all ordering\" do\n    let!(:bookmark1) { Fabricate(:bookmark, user: user, updated_at: 1.day.ago, reminder_at: nil) }\n    let!(:bookmark2) { Fabricate(:bookmark, user: user, updated_at: 2.days.ago, reminder_at: nil) }\n    let!(:bookmark3) { Fabricate(:bookmark, user: user, updated_at: 6.days.ago, reminder_at: nil) }\n    let!(:bookmark4) { Fabricate(:bookmark, user: user, updated_at: 4.days.ago, reminder_at: nil) }\n    let!(:bookmark5) { Fabricate(:bookmark, user: user, updated_at: 3.days.ago, reminder_at: nil) }\n\n    before do\n      [bookmark1, bookmark2, bookmark3, bookmark4, bookmark5].each do |bm|\n        Fabricate(:topic_user, topic: bm.bookmarkable.topic, user: user)\n        bm.reload\n      end\n    end\n\n    it \"order defaults to updated_at DESC\" do\n      expect(bookmark_query.list_all.map(&:id)).to eq(\n        [bookmark1.id, bookmark2.id, bookmark5.id, bookmark4.id, bookmark3.id],\n      )\n    end\n\n    it \"orders by reminder_at, then updated_at\" do\n      bookmark4.update_column(:reminder_at, 1.day.from_now)\n      bookmark5.update_column(:reminder_at, 26.hours.from_now)\n\n      expect(bookmark_query.list_all.map(&:id)).to eq(\n        [bookmark4.id, bookmark5.id, bookmark1.id, bookmark2.id, bookmark3.id],\n      )\n    end\n\n    it \"shows pinned bookmarks first ordered by reminder_at ASC then updated_at DESC\" do\n      bookmark3.update_column(:pinned, true)\n      bookmark3.update_column(:reminder_at, 1.day.from_now)\n\n      bookmark4.update_column(:pinned, true)\n      bookmark4.update_column(:reminder_at, 28.hours.from_now)\n\n      bookmark1.update_column(:pinned, true)\n      bookmark2.update_column(:pinned, true)\n\n      bookmark5.update_column(:reminder_at, 1.day.from_now)\n\n      expect(bookmark_query.list_all.map(&:id)).to eq(\n        [bookmark3.id, bookmark4.id, bookmark1.id, bookmark2.id, bookmark5.id],\n      )\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rotp\"\n\nRSpec.describe UsersController do\n  fab!(:user) { Fabricate(:user) }\n  fab!(:user1) { Fabricate(:user, username: \"someusername\") }\n  fab!(:another_user) { Fabricate(:user) }\n  fab!(:invitee) { Fabricate(:user) }\n  fab!(:inviter) { Fabricate(:user) }\n\n  fab!(:admin) { Fabricate(:admin) }\n  fab!(:moderator) { Fabricate(:moderator) }\n  fab!(:inactive_user) { Fabricate(:inactive_user) }\n\n  before { Group.refresh_automatic_groups! }\n\n  # Unfortunately, there are tests that depend on the user being created too\n  # late for fab! to work.\n  let(:user_deferred) { Fabricate(:user) }\n\n  describe \"#full account registration flow\" do\n    it \"will correctly handle honeypot and challenge\" do\n      get \"/session/hp.json\"\n      expect(response.status).to eq(200)\n\n      json = response.parsed_body\n\n      params = {\n        email: \"jane@jane.com\",\n        name: \"jane\",\n        username: \"jane\",\n        password_confirmation: json[\"value\"],\n        challenge: json[\"challenge\"].reverse,\n        password: SecureRandom.hex,\n      }\n\n      secure_session = SecureSession.new(session[\"secure_session_id\"])\n\n      expect(secure_session[UsersController::HONEYPOT_KEY]).to eq(json[\"value\"])\n      expect(secure_session[UsersController::CHALLENGE_KEY]).to eq(json[\"challenge\"])\n\n      post \"/u.json\", params: params\n\n      expect(response.status).to eq(200)\n\n      jane = User.find_by(username: \"jane\")\n\n      expect(jane.email).to eq(\"jane@jane.com\")\n\n      expect(secure_session[UsersController::HONEYPOT_KEY]).to eq(nil)\n      expect(secure_session[UsersController::CHALLENGE_KEY]).to eq(nil)\n    end\n  end\n\n  describe \"#perform_account_activation\" do\n    let(:email_token) { Fabricate(:email_token, user: user_deferred) }\n\n    before { UsersController.any_instance.stubs(:honeypot_or_challenge_fails?).returns(false) }\n\n    context \"with invalid token\" do\n      it \"return success\" do\n        put \"/u/activate-account/invalid-tooken\"\n        expect(response.status).to eq(200)\n        expect(flash[:error]).to be_present\n      end\n    end\n\n    context \"with valid token\" do\n      context \"with welcome message\" do\n        it \"enqueues a welcome message if the user object indicates so\" do\n          SiteSetting.send_welcome_message = true\n          user_deferred.update(active: false)\n          put \"/u/activate-account/#{email_token.token}\"\n          expect(response.status).to eq(200)\n          expect(Jobs::SendSystemMessage.jobs.size).to eq(1)\n          expect(Jobs::SendSystemMessage.jobs.first[\"args\"].first[\"message_type\"]).to eq(\n            \"welcome_user\",\n          )\n        end\n\n        it \"doesn't enqueue the welcome message if the object returns false\" do\n          user_deferred.update(active: true)\n          put \"/u/activate-account/#{email_token.token}\"\n          expect(response.status).to eq(200)\n          expect(Jobs::SendSystemMessage.jobs.size).to eq(0)\n        end\n      end\n\n      context \"with honeypot\" do\n        it \"raises an error if the honeypot is invalid\" do\n          UsersController.any_instance.stubs(:honeypot_or_challenge_fails?).returns(true)\n          put \"/u/activate-account/#{email_token.token}\"\n          expect(response.status).to eq(403)\n        end\n      end\n\n      context \"with response\" do\n        it \"correctly logs on user\" do\n          email_token\n\n          events = DiscourseEvent.track_events { put \"/u/activate-account/#{email_token.token}\" }\n\n          expect(events.map { |event| event[:event_name] }).to contain_exactly(\n            :user_confirmed_email,\n            :user_first_logged_in,\n            :user_logged_in,\n          )\n\n          expect(response.status).to eq(200)\n          expect(flash[:error]).to be_blank\n          expect(session[:current_user_id]).to be_present\n\n          expect(CGI.unescapeHTML(response.body)).to_not include(\n            I18n.t(\"activation.approval_required\"),\n          )\n        end\n      end\n\n      context \"when user is not approved\" do\n        before { SiteSetting.must_approve_users = true }\n\n        it \"should return the right response\" do\n          put \"/u/activate-account/#{email_token.token}\"\n          expect(response.status).to eq(200)\n\n          expect(CGI.unescapeHTML(response.body)).to include(I18n.t(\"activation.approval_required\"))\n\n          expect(response.body).to_not have_tag(:script, with: { src: \"/assets/application.js\" })\n\n          expect(flash[:error]).to be_blank\n          expect(session[:current_user_id]).to be_blank\n        end\n      end\n    end\n\n    context \"when cookies contains a destination URL\" do\n      it \"should redirect to the URL\" do\n        destination_url = \"http://thisisasite.com/somepath\"\n        cookies[:destination_url] = destination_url\n\n        put \"/u/activate-account/#{email_token.token}\"\n\n        expect(response).to redirect_to(destination_url)\n      end\n    end\n\n    context \"when cookies does not contain a destination URL but users was invited to topic\" do\n      let(:invite) { Fabricate(:invite) }\n      let(:topic) { Fabricate(:topic) }\n\n      before do\n        TopicInvite.create!(topic: topic, invite: invite)\n        Fabricate(:invited_user, invite: invite, user: email_token.user)\n        invite.reload\n      end\n\n      it \"should redirect to the topic\" do\n        put \"/u/activate-account/#{email_token.token}\"\n\n        expect(response).to redirect_to(topic.relative_url)\n      end\n    end\n  end\n\n  describe \"#password_reset\" do\n    let(:token) { SecureRandom.hex }\n\n    context \"when login is required\" do\n      it \"returns success\" do\n        SiteSetting.login_required = true\n        get \"/u/password-reset/#{token}\"\n        expect(response.status).to eq(200)\n        expect(CGI.unescapeHTML(response.body)).to include(\n          I18n.t(\"password_reset.no_token\", base_url: Discourse.base_url),\n        )\n      end\n    end\n\n    context \"with missing token\" do\n      it \"disallows login\" do\n        get \"/u/password-reset/#{token}\"\n\n        expect(response.status).to eq(200)\n\n        expect(CGI.unescapeHTML(response.body)).to include(\n          I18n.t(\"password_reset.no_token\", base_url: Discourse.base_url),\n        )\n\n        expect(response.body).to_not have_tag(:script, with: { src: \"/assets/application.js\" })\n\n        expect(session[:current_user_id]).to be_blank\n      end\n\n      it \"responds with proper error message\" do\n        get \"/u/password-reset/#{token}.json\"\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"message\"]).to eq(\n          I18n.t(\"password_reset.no_token\", base_url: Discourse.base_url),\n        )\n        expect(session[:current_user_id]).to be_blank\n      end\n    end\n\n    context \"with invalid token\" do\n      it \"disallows login\" do\n        get \"/u/password-reset/ev!l_trout@!\"\n\n        expect(response.status).to eq(200)\n\n        expect(CGI.unescapeHTML(response.body)).to include(\n          I18n.t(\"password_reset.no_token\", base_url: Discourse.base_url),\n        )\n\n        expect(response.body).to_not have_tag(:script, with: { src: \"/assets/application.js\" })\n\n        expect(session[:current_user_id]).to be_blank\n      end\n\n      it \"responds with proper error message\" do\n        put \"/u/password-reset/evil_trout!.json\", params: { password: \"awesomeSecretPassword\" }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"message\"]).to eq(\n          I18n.t(\"password_reset.no_token\", base_url: Discourse.base_url),\n        )\n        expect(session[:current_user_id]).to be_blank\n      end\n    end\n\n    context \"with valid token\" do\n      let!(:user_auth_token) { UserAuthToken.generate!(user_id: user1.id) }\n      let!(:email_token) do\n        Fabricate(:email_token, user: user1, scope: EmailToken.scopes[:password_reset])\n      end\n\n      context \"when rendered\" do\n        it \"renders referrer never on get requests\" do\n          get \"/u/password-reset/#{email_token.token}\"\n          expect(response.status).to eq(200)\n          expect(response.body).to include('<meta name=\"referrer\" content=\"never\">')\n        end\n      end\n\n      it \"returns success\" do\n        events =\n          DiscourseEvent.track_events do\n            put \"/u/password-reset/#{email_token.token}\", params: { password: \"hg9ow8yhg98o\" }\n          end\n\n        expect(events.map { |event| event[:event_name] }).to contain_exactly(\n          :user_logged_in,\n          :user_first_logged_in,\n          :user_confirmed_email,\n        )\n\n        expect(response.status).to eq(200)\n        expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n          json = JSON.parse(element.current_scope.attribute(\"data-preloaded\").value)\n          expect(json[\"password_reset\"]).to include(\n            '{\"is_developer\":false,\"admin\":false,\"second_factor_required\":false,\"security_key_required\":false,\"backup_enabled\":false,\"multiple_second_factor_methods\":false}',\n          )\n        end\n\n        expect(session[\"password-#{email_token.token}\"]).to be_blank\n        expect(UserAuthToken.where(id: user_auth_token.id).count).to eq(0)\n      end\n\n      it \"disallows double password reset\" do\n        put \"/u/password-reset/#{email_token.token}\", params: { password: \"hg9ow8yHG32O\" }\n        put \"/u/password-reset/#{email_token.token}\", params: { password: \"test123987AsdfXYZ\" }\n        expect(user1.reload.confirm_password?(\"hg9ow8yHG32O\")).to eq(true)\n        expect(user1.user_auth_tokens.count).to eq(1)\n      end\n\n      it \"doesn't redirect to wizard on get\" do\n        user1.update!(admin: true)\n\n        get \"/u/password-reset/#{email_token.token}.json\"\n        expect(response).not_to redirect_to(wizard_path)\n      end\n\n      it \"redirects to the wizard if you're the first admin\" do\n        user1.update!(admin: true)\n\n        get \"/u/password-reset/#{email_token.token}\"\n        put \"/u/password-reset/#{email_token.token}\",\n            params: {\n              password: \"hg9ow8yhg98oadminlonger\",\n            }\n        expect(response).to redirect_to(wizard_path)\n      end\n\n      it \"sets the users timezone if the param is present\" do\n        get \"/u/password-reset/#{email_token.token}\"\n        expect(user1.user_option.timezone).to eq(nil)\n\n        put \"/u/password-reset/#{email_token.token}\",\n            params: {\n              password: \"hg9ow8yhg98oadminlonger\",\n              timezone: \"America/Chicago\",\n            }\n        expect(user1.user_option.reload.timezone).to eq(\"America/Chicago\")\n      end\n\n      it \"logs the password change\" do\n        get \"/u/password-reset/#{email_token.token}\"\n\n        expect do\n          put \"/u/password-reset/#{email_token.token}\",\n              params: {\n                password: \"hg9ow8yhg98oadminlonger\",\n              }\n        end.to change { UserHistory.count }.by (1)\n\n        user_history = UserHistory.last\n        expect(user_history.target_user_id).to eq(user1.id)\n        expect(user_history.action).to eq(UserHistory.actions[:change_password])\n      end\n\n      it \"doesn't invalidate the token when loading the page\" do\n        get \"/u/password-reset/#{email_token.token}.json\"\n        expect(response.status).to eq(200)\n        expect(email_token.reload.confirmed).to eq(false)\n        expect(UserAuthToken.where(id: user_auth_token.id).count).to eq(1)\n      end\n\n      context \"with rate limiting\" do\n        before { RateLimiter.enable }\n\n        use_redis_snapshotting\n\n        it \"rate limits reset passwords\" do\n          freeze_time\n\n          6.times do\n            put \"/u/password-reset/#{email_token.token}\",\n                params: {\n                  second_factor_token: 123_456,\n                  second_factor_method: 1,\n                }\n\n            expect(response.status).to eq(200)\n          end\n\n          put \"/u/password-reset/#{email_token.token}\",\n              params: {\n                second_factor_token: 123_456,\n                second_factor_method: 1,\n              }\n\n          expect(response.status).to eq(429)\n        end\n\n        it \"rate limits reset passwords by username\" do\n          freeze_time\n\n          6.times do |x|\n            put \"/u/password-reset/#{email_token.token}\",\n                params: {\n                  second_factor_token: 123_456,\n                  second_factor_method: 1,\n                },\n                env: {\n                  REMOTE_ADDR: \"1.2.3.#{x}\",\n                }\n\n            expect(response.status).to eq(200)\n          end\n\n          put \"/u/password-reset/#{email_token.token}\",\n              params: {\n                second_factor_token: 123_456,\n                second_factor_method: 1,\n              },\n              env: {\n                REMOTE_ADDR: \"1.2.3.4\",\n              }\n\n          expect(response.status).to eq(429)\n        end\n      end\n\n      context \"when 2 factor authentication is required\" do\n        fab!(:second_factor) { Fabricate(:user_second_factor_totp, user: user1) }\n\n        it \"does not change with an invalid token\" do\n          user1.user_auth_tokens.destroy_all\n\n          get \"/u/password-reset/#{email_token.token}\"\n\n          expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n            json = JSON.parse(element.current_scope.attribute(\"data-preloaded\").value)\n            expect(json[\"password_reset\"]).to include(\n              '{\"is_developer\":false,\"admin\":false,\"second_factor_required\":true,\"security_key_required\":false,\"backup_enabled\":false,\"multiple_second_factor_methods\":false}',\n            )\n          end\n\n          put \"/u/password-reset/#{email_token.token}\",\n              params: {\n                password: \"hg9ow8yHG32O\",\n                second_factor_token: \"000000\",\n                second_factor_method: UserSecondFactor.methods[:totp],\n              }\n\n          expect(response.body).to include(I18n.t(\"login.invalid_second_factor_code\"))\n\n          user1.reload\n          expect(user1.confirm_password?(\"hg9ow8yHG32O\")).not_to eq(true)\n          expect(user1.user_auth_tokens.count).not_to eq(1)\n        end\n\n        it \"changes password with valid 2-factor tokens\" do\n          get \"/u/password-reset/#{email_token.token}\"\n\n          put \"/u/password-reset/#{email_token.token}\",\n              params: {\n                password: \"hg9ow8yHG32O\",\n                second_factor_token: ROTP::TOTP.new(second_factor.data).now,\n                second_factor_method: UserSecondFactor.methods[:totp],\n              }\n\n          user1.reload\n          expect(response.status).to eq(200)\n          expect(user1.confirm_password?(\"hg9ow8yHG32O\")).to eq(true)\n          expect(user1.user_auth_tokens.count).to eq(1)\n        end\n      end\n\n      context \"when security key authentication is required\" do\n        let!(:user_security_key) do\n          Fabricate(\n            :user_security_key,\n            user: user1,\n            credential_id: valid_security_key_data[:credential_id],\n            public_key: valid_security_key_data[:public_key],\n          )\n        end\n\n        before do\n          simulate_localhost_webauthn_challenge\n\n          # store challenge in secure session by visiting the email login page\n          get \"/u/password-reset/#{email_token.token}\"\n        end\n\n        it \"preloads with a security key challenge and allowed credential ids\" do\n          expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n            json = JSON.parse(element.current_scope.attribute(\"data-preloaded\").value)\n            password_reset = JSON.parse(json[\"password_reset\"])\n            expect(password_reset[\"challenge\"]).not_to eq(nil)\n            expect(password_reset[\"allowed_credential_ids\"]).to eq(\n              [user_security_key.credential_id],\n            )\n            expect(password_reset[\"security_key_required\"]).to eq(true)\n          end\n        end\n\n        it \"stages a webauthn challenge and rp-id for the user\" do\n          secure_session = SecureSession.new(session[\"secure_session_id\"])\n          expect(Webauthn.challenge(user1, secure_session)).not_to eq(nil)\n          expect(Webauthn.rp_id(user1, secure_session)).to eq(Discourse.current_hostname)\n        end\n\n        it \"changes password with valid security key challenge and authentication\" do\n          put \"/u/password-reset/#{email_token.token}.json\",\n              params: {\n                password: \"hg9ow8yHG32O\",\n                second_factor_token: valid_security_key_auth_post_data,\n                second_factor_method: UserSecondFactor.methods[:security_key],\n              }\n\n          expect(response.status).to eq(200)\n          user1.reload\n          expect(user1.confirm_password?(\"hg9ow8yHG32O\")).to eq(true)\n          expect(user1.user_auth_tokens.count).to eq(1)\n        end\n\n        it \"does not change a password if a fake TOTP token is provided\" do\n          put \"/u/password-reset/#{email_token.token}.json\",\n              params: {\n                password: \"hg9ow8yHG32O\",\n                second_factor_token: \"blah\",\n                second_factor_method: UserSecondFactor.methods[:security_key],\n              }\n\n          expect(response.status).to eq(200)\n          expect(user1.reload.confirm_password?(\"hg9ow8yHG32O\")).to eq(false)\n        end\n\n        context \"when security key authentication fails\" do\n          it \"shows an error message and does not change password\" do\n            put \"/u/password-reset/#{email_token.token}\",\n                params: {\n                  password: \"hg9ow8yHG32O\",\n                  second_factor_token: {\n                    signature: \"bad\",\n                    clientData: \"bad\",\n                    authenticatorData: \"bad\",\n                    credentialId: \"bad\",\n                  },\n                  second_factor_method: UserSecondFactor.methods[:security_key],\n                }\n\n            expect(response.status).to eq(200)\n            expect(response.body).to include(I18n.t(\"webauthn.validation.not_found_error\"))\n            expect(user1.reload.confirm_password?(\"hg9ow8yHG32O\")).to eq(false)\n          end\n        end\n      end\n    end\n\n    context \"with submit change\" do\n      let(:email_token) do\n        Fabricate(:email_token, user: user1, scope: EmailToken.scopes[:password_reset])\n      end\n\n      it \"fails when the password is blank\" do\n        put \"/u/password-reset/#{email_token.token}.json\", params: { password: \"\" }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"errors\"]).to be_present\n        expect(session[:current_user_id]).to be_blank\n      end\n\n      it \"fails when the password is too long\" do\n        put \"/u/password-reset/#{email_token.token}.json\",\n            params: {\n              password: (\"x\" * (User.max_password_length + 1)),\n            }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"errors\"]).to be_present\n        expect(session[:current_user_id]).to be_blank\n      end\n\n      it \"logs in the user\" do\n        put \"/u/password-reset/#{email_token.token}.json\", params: { password: \"ksjafh928r\" }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"errors\"]).to be_blank\n        expect(session[:current_user_id]).to be_present\n      end\n\n      it \"doesn't log in the user when not approved\" do\n        SiteSetting.must_approve_users = true\n        user1.update!(approved: false)\n\n        put \"/u/password-reset/#{email_token.token}.json\", params: { password: \"ksjafh928r\" }\n        expect(response.parsed_body[\"errors\"]).to be_blank\n        expect(session[:current_user_id]).to be_blank\n      end\n    end\n  end\n\n  describe \"#confirm_email_token\" do\n    let!(:email_token) { Fabricate(:email_token, user: user1) }\n\n    it \"token doesn't match any records\" do\n      get \"/u/confirm-email-token/#{SecureRandom.hex}.json\"\n      expect(response.status).to eq(200)\n      expect(email_token.reload.confirmed).to eq(false)\n    end\n\n    it \"token matches\" do\n      get \"/u/confirm-email-token/#{email_token.token}.json\"\n      expect(response.status).to eq(200)\n      expect(email_token.reload.confirmed).to eq(true)\n    end\n  end\n\n  describe \"#admin_login\" do\n    it \"enqueues mail with admin email and sso enabled\" do\n      put \"/u/admin-login\", params: { email: admin.email }\n      expect(response.status).to eq(200)\n      expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n      args = Jobs::CriticalUserEmail.jobs.first[\"args\"].first\n      expect(args[\"user_id\"]).to eq(admin.id)\n    end\n\n    it \"passes through safe mode\" do\n      put \"/u/admin-login\", params: { email: admin.email, use_safe_mode: true }\n      expect(response.status).to eq(200)\n      expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n      args = Jobs::CriticalUserEmail.jobs.first[\"args\"].first\n      expect(args[\"email_token\"]).to end_with(\"?safe_mode=no_plugins,no_themes\")\n    end\n\n    context \"when email is incorrect\" do\n      it \"should return the right response\" do\n        put \"/u/admin-login\", params: { email: \"random\" }\n\n        expect(response.status).to eq(200)\n\n        response_body = response.body\n\n        expect(response_body).to match(I18n.t(\"admin_login.errors.unknown_email_address\"))\n        expect(response_body).to_not match(I18n.t(\"login.second_factor_description\"))\n      end\n    end\n  end\n\n  describe \"#toggle_anon\" do\n    it \"allows you to toggle anon if enabled\" do\n      SiteSetting.allow_anonymous_posting = true\n\n      user = sign_in(Fabricate(:user))\n      user.trust_level = 1\n      user.save!\n\n      post \"/u/toggle-anon.json\"\n      expect(response.status).to eq(200)\n      expect(session[:current_user_id]).to eq(AnonymousShadowCreator.get(user).id)\n\n      post \"/u/toggle-anon.json\"\n      expect(response.status).to eq(200)\n      expect(session[:current_user_id]).to eq(user.id)\n    end\n  end\n\n  describe \"#create\" do\n    def honeypot_magic(params)\n      get \"/session/hp.json\"\n      json = response.parsed_body\n      params[:password_confirmation] = json[\"value\"]\n      params[:challenge] = json[\"challenge\"].reverse\n      params\n    end\n\n    before do\n      UsersController.any_instance.stubs(:honeypot_value).returns(nil)\n      UsersController.any_instance.stubs(:challenge_value).returns(nil)\n      SiteSetting.allow_new_registrations = true\n      @user = Fabricate.build(:user, email: \"foobar@example.com\", password: \"strongpassword\")\n    end\n\n    let(:post_user_params) do\n      { name: @user.name, username: @user.username, password: \"strongpassword\", email: @user.email }\n    end\n\n    def post_user(extra_params = {})\n      post \"/u.json\", params: post_user_params.merge(extra_params)\n    end\n\n    context \"when email params is missing\" do\n      it \"should raise the right error\" do\n        post \"/u.json\",\n             params: {\n               name: @user.name,\n               username: @user.username,\n               password: \"testing12352343\",\n             }\n        expect(response.status).to eq(400)\n      end\n    end\n\n    context \"when creating a user\" do\n      it \"sets the user locale to I18n.locale\" do\n        SiteSetting.default_locale = \"en\"\n        I18n.stubs(:locale).returns(:fr)\n        post_user\n        expect(User.find_by(username: @user.username).locale).to eq(\"fr\")\n      end\n\n      it \"requires invite code when specified\" do\n        expect(SiteSetting.require_invite_code).to eq(false)\n        SiteSetting.invite_code = \"abc def\"\n        expect(SiteSetting.require_invite_code).to eq(true)\n\n        post_user(invite_code: \"abcd\")\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"success\"]).to eq(false)\n\n        # case insensitive and stripped of leading/ending spaces\n        post_user(invite_code: \" AbC deF \")\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"success\"]).to eq(true)\n      end\n\n      context \"when timezone is provided as a guess on signup\" do\n        it \"sets the timezone\" do\n          post_user(timezone: \"Australia/Brisbane\")\n          expect(response.status).to eq(200)\n          expect(User.find_by(username: @user.username).user_option.timezone).to eq(\n            \"Australia/Brisbane\",\n          )\n        end\n      end\n\n      context \"with local logins disabled\" do\n        before do\n          SiteSetting.enable_local_logins = false\n          SiteSetting.enable_google_oauth2_logins = true\n        end\n\n        it \"blocks registration without authenticator information\" do\n          post_user\n          expect(response.status).to eq(403)\n        end\n\n        it \"blocks with a regular api key\" do\n          api_key = Fabricate(:api_key, user: user1)\n          post \"/u.json\", params: post_user_params, headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(403)\n        end\n\n        it \"works with an admin api key\" do\n          api_key = Fabricate(:api_key, user: admin)\n          post \"/u.json\", params: post_user_params, headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(200)\n        end\n      end\n\n      context \"with external_ids\" do\n        fab!(:api_key, refind: false) { Fabricate(:api_key, user: admin) }\n\n        let(:plugin_auth_provider) do\n          authenticator_class =\n            Class.new(Auth::ManagedAuthenticator) do\n              def name\n                \"pluginauth\"\n              end\n\n              def enabled?\n                true\n              end\n            end\n\n          provider = Auth::AuthProvider.new\n          provider.authenticator = authenticator_class.new\n          provider\n        end\n\n        before { DiscoursePluginRegistry.register_auth_provider(plugin_auth_provider) }\n\n        after { DiscoursePluginRegistry.reset! }\n\n        it \"creates User record\" do\n          params = {\n            username: \"foobar\",\n            email: \"test@example.com\",\n            external_ids: {\n              \"pluginauth\" => \"pluginauth_uid\",\n            },\n          }\n\n          expect {\n            post \"/u.json\", params: params, headers: { HTTP_API_KEY: api_key.key }\n          }.to change { UserAssociatedAccount.count }.by(1).and change { User.count }.by(1)\n\n          expect(response.status).to eq(200)\n\n          user = User.last\n          user_associated_account = UserAssociatedAccount.last\n\n          expect(user.username).to eq(\"foobar\")\n          expect(user.email).to eq(\"test@example.com\")\n          expect(user.user_associated_account_ids).to contain_exactly(user_associated_account.id)\n          expect(user_associated_account.provider_name).to eq(\"pluginauth\")\n          expect(user_associated_account.provider_uid).to eq(\"pluginauth_uid\")\n          expect(user_associated_account.user_id).to eq(user.id)\n        end\n\n        it \"returns error if external ID provider does not exist\" do\n          params = {\n            username: \"foobar\",\n            email: \"test@example.com\",\n            external_ids: {\n              \"pluginauth2\" => \"pluginauth_uid\",\n            },\n          }\n\n          post \"/u.json\", params: params, headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(400)\n        end\n      end\n    end\n\n    context \"when creating a non active user (unconfirmed email)\" do\n      it \"returns 403 forbidden when local logins are disabled\" do\n        SiteSetting.enable_local_logins = false\n        post_user\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"returns an error when new registrations are disabled\" do\n        SiteSetting.allow_new_registrations = false\n\n        post_user\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n        expect(json[\"success\"]).to eq(false)\n        expect(json[\"message\"]).to be_present\n      end\n\n      it \"creates a user correctly\" do\n        post_user\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"active\"]).to be_falsey\n\n        # should save user_created_message in session\n        expect(session[\"user_created_message\"]).to be_present\n        expect(session[SessionController::ACTIVATE_USER_KEY]).to be_present\n\n        expect(Jobs::SendSystemMessage.jobs.size).to eq(0)\n\n        expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n        args = Jobs::CriticalUserEmail.jobs.first[\"args\"].first\n        expect(args[\"type\"]).to eq(\"signup\")\n      end\n\n      context \"when `must approve users` site setting is enabled\" do\n        before { SiteSetting.must_approve_users = true }\n\n        it \"creates a user correctly\" do\n          post_user\n          expect(response.status).to eq(200)\n\n          expect(response.parsed_body[\"active\"]).to be_falsey\n\n          # should save user_created_message in session\n          expect(session[\"user_created_message\"]).to be_present\n          expect(session[SessionController::ACTIVATE_USER_KEY]).to be_present\n\n          expect(Jobs::SendSystemMessage.jobs.size).to eq(0)\n\n          expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n          args = Jobs::CriticalUserEmail.jobs.first[\"args\"].first\n          expect(args[\"type\"]).to eq(\"signup\")\n        end\n      end\n\n      context \"when users already exists with given email\" do\n        let!(:existing) { Fabricate(:user, email: post_user_params[:email]) }\n\n        it \"returns an error if hide_email_address_taken is disabled\" do\n          SiteSetting.hide_email_address_taken = false\n\n          post_user\n          expect(response.status).to eq(200)\n\n          json = response.parsed_body\n          expect(json[\"success\"]).to eq(false)\n          expect(json[\"message\"]).to be_present\n        end\n\n        it \"returns success if hide_email_address_taken is enabled\" do\n          SiteSetting.hide_email_address_taken = true\n          expect { post_user }.to_not change { User.count }\n\n          expect(response.status).to eq(200)\n          expect(session[\"user_created_message\"]).to be_present\n\n          json = response.parsed_body\n          expect(json[\"active\"]).to be_falsey\n          expect(json[\"message\"]).to eq(\n            I18n.t(\"login.activate_email\", email: post_user_params[:email]),\n          )\n          expect(json[\"user_id\"]).not_to be_present\n\n          existing.destroy!\n          expect { post_user }.to change { User.count }\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n\n          expect(json[\"active\"]).to be_falsey\n          expect(json[\"message\"]).to eq(\n            I18n.t(\"login.activate_email\", email: post_user_params[:email]),\n          )\n          expect(json[\"user_id\"]).not_to be_present\n        end\n      end\n    end\n\n    context \"when creating as active\" do\n      it \"won't create the user as active\" do\n        post \"/u.json\", params: post_user_params.merge(active: true)\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"active\"]).to be_falsey\n      end\n\n      context \"with a regular api key\" do\n        fab!(:api_key, refind: false) { Fabricate(:api_key, user: user1) }\n\n        it \"won't create the user as active with a regular key\" do\n          post \"/u.json\",\n               params: post_user_params.merge(active: true),\n               headers: {\n                 HTTP_API_KEY: api_key.key,\n               }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"active\"]).to be_falsey\n        end\n      end\n\n      context \"with an admin api key\" do\n        fab!(:api_key, refind: false) { Fabricate(:api_key, user: admin) }\n\n        it \"creates the user as active with a an admin key\" do\n          SiteSetting.send_welcome_message = true\n          SiteSetting.must_approve_users = true\n\n          # Sidekiq::Client.expects(:enqueue).never\n          post \"/u.json\",\n               params: post_user_params.merge(approved: true, active: true),\n               headers: {\n                 HTTP_API_KEY: api_key.key,\n               }\n\n          expect(Jobs::CriticalUserEmail.jobs.size).to eq(0)\n          expect(Jobs::SendSystemMessage.jobs.size).to eq(0)\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"active\"]).to be_truthy\n          new_user = User.find(response.parsed_body[\"user_id\"])\n          expect(new_user.active).to eq(true)\n          expect(new_user.approved).to eq(true)\n          expect(new_user.approved_by_id).to eq(admin.id)\n          expect(new_user.approved_at).to_not eq(nil)\n          expect(new_user.email_tokens.where(confirmed: true, email: new_user.email)).to exist\n        end\n\n        it \"will create a reviewable when a user is created as active but not approved\" do\n          Jobs.run_immediately!\n          SiteSetting.must_approve_users = true\n\n          post \"/u.json\",\n               params: post_user_params.merge(active: true),\n               headers: {\n                 HTTP_API_KEY: api_key.key,\n               }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n\n          new_user = User.find(json[\"user_id\"])\n          expect(json[\"active\"]).to be_truthy\n          expect(new_user.approved).to eq(false)\n          expect(ReviewableUser.pending.find_by(target: new_user)).to be_present\n        end\n\n        it \"won't create a reviewable when a user is not active\" do\n          Jobs.run_immediately!\n          SiteSetting.must_approve_users = true\n\n          post \"/u.json\", params: post_user_params, headers: { HTTP_API_KEY: api_key.key }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n\n          new_user = User.find(json[\"user_id\"])\n          expect(json[\"active\"]).to eq(false)\n          expect(new_user.approved).to eq(false)\n          expect(ReviewableUser.pending.find_by(target: new_user)).to be_blank\n        end\n\n        it \"won't create the developer as active\" do\n          UsernameCheckerService.expects(:is_developer?).returns(true)\n\n          post \"/u.json\",\n               params: post_user_params.merge(active: true),\n               headers: {\n                 HTTP_API_KEY: api_key.key,\n               }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"active\"]).to be_falsy\n        end\n\n        it \"won't set the new user's locale to the admin's locale\" do\n          SiteSetting.allow_user_locale = true\n          admin.update!(locale: :fr)\n\n          post \"/u.json\",\n               params: post_user_params.merge(active: true),\n               headers: {\n                 HTTP_API_KEY: api_key.key,\n               }\n          expect(response.status).to eq(200)\n\n          json = response.parsed_body\n          new_user = User.find(json[\"user_id\"])\n          expect(new_user.locale).not_to eq(\"fr\")\n        end\n\n        it \"will auto approve user if the user email domain matches auto_approve_email_domains setting\" do\n          Jobs.run_immediately!\n          SiteSetting.must_approve_users = true\n          SiteSetting.auto_approve_email_domains = \"example.com\"\n\n          post \"/u.json\",\n               params: post_user_params.merge(active: true),\n               headers: {\n                 HTTP_API_KEY: api_key.key,\n               }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n\n          new_user = User.find(json[\"user_id\"])\n          expect(json[\"active\"]).to be_truthy\n          expect(new_user.approved).to be_truthy\n          expect(ReviewableUser.pending.find_by(target: new_user)).to be_blank\n        end\n      end\n    end\n\n    context \"when creating as staged\" do\n      it \"won't create the user as staged\" do\n        post \"/u.json\", params: post_user_params.merge(staged: true)\n        expect(response.status).to eq(200)\n        new_user = User.where(username: post_user_params[:username]).first\n        expect(new_user.staged?).to eq(false)\n      end\n\n      context \"with a regular api key\" do\n        fab!(:api_key, refind: false) { Fabricate(:api_key, user: user1) }\n\n        it \"won't create the user as staged with a regular key\" do\n          post \"/u.json\",\n               params: post_user_params.merge(staged: true),\n               headers: {\n                 HTTP_API_KEY: api_key.key,\n               }\n          expect(response.status).to eq(200)\n\n          new_user = User.where(username: post_user_params[:username]).first\n          expect(new_user.staged?).to eq(false)\n        end\n      end\n\n      context \"with an admin api key\" do\n        fab!(:user) { admin }\n        fab!(:api_key, refind: false) { Fabricate(:api_key, user: user) }\n\n        it \"creates the user as staged with a regular key\" do\n          post \"/u.json\",\n               params: post_user_params.merge(staged: true),\n               headers: {\n                 HTTP_API_KEY: api_key.key,\n               }\n          expect(response.status).to eq(200)\n\n          new_user = User.where(username: post_user_params[:username]).first\n          expect(new_user.staged?).to eq(true)\n        end\n\n        it \"won't create the developer as staged\" do\n          UsernameCheckerService.expects(:is_developer?).returns(true)\n          post \"/u.json\",\n               params: post_user_params.merge(staged: true),\n               headers: {\n                 HTTP_API_KEY: api_key.key,\n               }\n          expect(response.status).to eq(200)\n\n          new_user = User.where(username: post_user_params[:username]).first\n          expect(new_user.staged?).to eq(false)\n        end\n      end\n    end\n\n    context \"when creating an active user (confirmed email)\" do\n      before { User.any_instance.stubs(:active?).returns(true) }\n\n      it \"enqueues a welcome email\" do\n        User.any_instance.expects(:enqueue_welcome_message).with(\"welcome_user\")\n\n        post_user\n        expect(response.status).to eq(200)\n\n        # should save user_created_message in session\n        expect(session[\"user_created_message\"]).to be_present\n        expect(session[SessionController::ACTIVATE_USER_KEY]).to be_present\n      end\n\n      it \"shows the 'active' message\" do\n        User.any_instance.expects(:enqueue_welcome_message)\n        post_user\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"message\"]).to eq(I18n.t \"login.active\")\n      end\n\n      it \"should be logged in\" do\n        User.any_instance.expects(:enqueue_welcome_message)\n        post_user\n        expect(response.status).to eq(200)\n        expect(session[:current_user_id]).to be_present\n      end\n\n      it \"indicates the user is active in the response\" do\n        User.any_instance.expects(:enqueue_welcome_message)\n        post_user\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"active\"]).to be_truthy\n      end\n\n      it 'doesn\\'t succeed when new registrations are disabled' do\n        SiteSetting.allow_new_registrations = false\n\n        post_user\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n        expect(json[\"success\"]).to eq(false)\n        expect(json[\"message\"]).to be_present\n      end\n\n      context \"with authentication records for\" do\n        before do\n          OmniAuth.config.test_mode = true\n\n          OmniAuth.config.mock_auth[:twitter] = OmniAuth::AuthHash.new(\n            provider: \"twitter\",\n            uid: \"123545\",\n            info:\n              OmniAuth::AuthHash::InfoHash.new(\n                email: \"osama@mail.com\",\n                nickname: \"testosama\",\n                name: \"Osama Test\",\n              ),\n          )\n\n          Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[:twitter]\n          SiteSetting.enable_twitter_logins = true\n          get \"/auth/twitter/callback.json\"\n        end\n\n        after do\n          Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[:twitter] = nil\n          OmniAuth.config.test_mode = false\n        end\n\n        it \"should create twitter user info if required\" do\n          post \"/u.json\",\n               params: {\n                 name: \"Test Osama\",\n                 username: \"testosama\",\n                 password: \"strongpassword\",\n                 email: \"osama@mail.com\",\n               }\n\n          expect(response.status).to eq(200)\n          expect(UserAssociatedAccount.where(provider_name: \"twitter\").count).to eq(1)\n        end\n\n        it \"returns an error when email has been changed from the validated email address\" do\n          post \"/u.json\",\n               params: {\n                 name: \"Test Osama\",\n                 username: \"testosama\",\n                 password: \"strongpassword\",\n                 email: \"unvalidatedemail@mail.com\",\n               }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json[\"success\"]).to eq(false)\n          expect(json[\"message\"]).to be_present\n        end\n\n        it \"will create the user successfully if email validation is required\" do\n          post \"/u.json\",\n               params: {\n                 name: \"Test Osama\",\n                 username: \"testosama\",\n                 password: \"strongpassword\",\n                 email: \"osama@mail.com\",\n               }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json[\"success\"]).to eq(true)\n        end\n\n        it \"doesn't use provided username/name if sso_overrides is enabled\" do\n          SiteSetting.auth_overrides_username = true\n          SiteSetting.auth_overrides_name = true\n          post \"/u.json\",\n               params: {\n                 username: \"attemptednewname\",\n                 name: \"Attempt At New Name\",\n                 password: \"strongpassword\",\n                 email: \"osama@mail.com\",\n               }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json[\"success\"]).to eq(true)\n\n          user = User.last\n\n          expect(user.username).to eq(\"testosama\")\n          expect(user.name).to eq(\"Osama Test\")\n        end\n      end\n\n      context \"with no email in the auth payload\" do\n        before do\n          OmniAuth.config.test_mode = true\n          OmniAuth.config.mock_auth[:twitter] = OmniAuth::AuthHash.new(\n            provider: \"twitter\",\n            uid: \"123545\",\n            info: OmniAuth::AuthHash::InfoHash.new(nickname: \"testosama\", name: \"Osama Test\"),\n          )\n          Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[:twitter]\n          SiteSetting.enable_twitter_logins = true\n          get \"/auth/twitter/callback.json\"\n        end\n\n        after do\n          Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[:twitter] = nil\n          OmniAuth.config.test_mode = false\n        end\n\n        it \"will create the user successfully\" do\n          Rails.application.env_config[\"omniauth.auth\"].info.email = nil\n\n          post \"/u.json\",\n               params: {\n                 name: \"Test Osama\",\n                 username: \"testosama\",\n                 password: \"strongpassword\",\n                 email: \"osama@mail.com\",\n               }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json[\"success\"]).to eq(true)\n        end\n      end\n    end\n\n    it \"creates user successfully but doesn't activate the account\" do\n      post_user\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"success\"]).to eq(true)\n      expect(User.find_by(username: @user.username).active).to eq(false)\n    end\n\n    shared_examples \"honeypot fails\" do\n      it \"should not create a new user\" do\n        User.any_instance.expects(:enqueue_welcome_message).never\n\n        expect { post \"/u.json\", params: create_params }.to_not change { User.count }\n\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n        expect(json[\"success\"]).to eq(true)\n\n        # should not change the session\n        expect(session[\"user_created_message\"]).to be_blank\n        expect(session[SessionController::ACTIVATE_USER_KEY]).to be_blank\n      end\n    end\n\n    context \"when honeypot value is wrong\" do\n      before { UsersController.any_instance.stubs(:honeypot_value).returns(\"abc\") }\n      let(:create_params) do\n        {\n          name: @user.name,\n          username: @user.username,\n          password: \"strongpassword\",\n          email: @user.email,\n          password_confirmation: \"wrong\",\n        }\n      end\n      include_examples \"honeypot fails\"\n    end\n\n    context \"when challenge answer is wrong\" do\n      before { UsersController.any_instance.stubs(:challenge_value).returns(\"abc\") }\n      let(:create_params) do\n        {\n          name: @user.name,\n          username: @user.username,\n          password: \"strongpassword\",\n          email: @user.email,\n          challenge: \"abc\",\n        }\n      end\n      include_examples \"honeypot fails\"\n    end\n\n    context \"when 'invite only' setting is enabled\" do\n      before { SiteSetting.invite_only = true }\n\n      let(:create_params) do\n        {\n          name: @user.name,\n          username: @user.username,\n          password: \"strongpassword\",\n          email: @user.email,\n        }\n      end\n\n      include_examples \"honeypot fails\"\n    end\n\n    shared_examples \"failed signup\" do\n      it \"should not create a new User\" do\n        expect { post \"/u.json\", params: create_params }.to_not change { User.count }\n        expect(response.status).to eq(200)\n      end\n\n      it \"should report failed\" do\n        post \"/u.json\", params: create_params\n        json = response.parsed_body\n        expect(json[\"success\"]).not_to eq(true)\n\n        # should not change the session\n        expect(session[\"user_created_message\"]).to be_blank\n        expect(session[SessionController::ACTIVATE_USER_KEY]).to be_blank\n      end\n    end\n\n    context \"when password is blank\" do\n      let(:create_params) do\n        { name: @user.name, username: @user.username, password: \"\", email: @user.email }\n      end\n      include_examples \"failed signup\"\n    end\n\n    context \"when password is too long\" do\n      let(:create_params) do\n        {\n          name: @user.name,\n          username: @user.username,\n          password: \"x\" * (User.max_password_length + 1),\n          email: @user.email,\n        }\n      end\n      include_examples \"failed signup\"\n    end\n\n    context \"when password param is missing\" do\n      let(:create_params) { { name: @user.name, username: @user.username, email: @user.email } }\n      include_examples \"failed signup\"\n    end\n\n    context \"with a reserved username\" do\n      let(:create_params) do\n        { name: @user.name, username: \"Reserved\", email: @user.email, password: \"strongpassword\" }\n      end\n      before { SiteSetting.reserved_usernames = \"a|reserved|b\" }\n      include_examples \"failed signup\"\n    end\n\n    context \"with a username that matches a user route\" do\n      let(:create_params) do\n        {\n          name: @user.name,\n          username: \"account-created\",\n          email: @user.email,\n          password: \"strongpassword\",\n        }\n      end\n      include_examples \"failed signup\"\n    end\n\n    context \"with a missing username\" do\n      let(:create_params) { { name: @user.name, email: @user.email, password: \"x\" * 20 } }\n\n      it \"should not create a new User\" do\n        expect { post \"/u.json\", params: create_params }.to_not change { User.count }\n        expect(response.status).to eq(400)\n      end\n    end\n\n    context \"when an Exception is raised\" do\n      before { User.any_instance.stubs(:save).raises(ActiveRecord::StatementInvalid.new(\"Oh no\")) }\n\n      let(:create_params) do\n        {\n          name: @user.name,\n          username: @user.username,\n          password: \"strongpassword\",\n          email: @user.email,\n        }\n      end\n\n      include_examples \"failed signup\"\n    end\n\n    context \"with custom fields\" do\n      fab!(:user_field) { Fabricate(:user_field) }\n      fab!(:another_field) { Fabricate(:user_field) }\n      fab!(:optional_field) { Fabricate(:user_field, required: false) }\n\n      context \"without a value for the fields\" do\n        let(:create_params) do\n          { name: @user.name, password: \"watwatwat\", username: @user.username, email: @user.email }\n        end\n        include_examples \"failed signup\"\n      end\n\n      context \"with values for the fields\" do\n        let(:update_user_url) { \"/u/#{user1.username}.json\" }\n        let(:field_id) { user_field.id.to_s }\n\n        before { sign_in(user1) }\n\n        context \"with multple select fields\" do\n          let(:valid_options) { %w[Axe Sword] }\n\n          fab!(:user_field) do\n            Fabricate(:user_field, field_type: \"multiselect\") do\n              user_field_options do\n                [\n                  Fabricate(:user_field_option, value: \"Axe\"),\n                  Fabricate(:user_field_option, value: \"Sword\"),\n                ]\n              end\n            end\n          end\n\n          it \"should allow single values and not just arrays\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => \"Axe\" } }\n            end.to change { user1.reload.user_fields[field_id] }.from(nil).to(\"Axe\")\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => %w[Axe Juice Sword] } }\n            end.to change { user1.reload.user_fields[field_id] }.from(\"Axe\").to(%w[Axe Sword])\n          end\n\n          it \"shouldn't allow unregistered field values\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => %w[Juice] } }\n            end.not_to change { user1.reload.user_fields[field_id] }\n          end\n\n          it \"should filter valid values\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => %w[Axe Juice Sword] } }\n            end.to change { user1.reload.user_fields[field_id] }.from(nil).to(valid_options)\n          end\n\n          it \"allows registered field values\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => valid_options } }\n            end.to change { user1.reload.user_fields[field_id] }.from(nil).to(valid_options)\n          end\n\n          it \"value can't be nil or empty if the field is required\" do\n            put update_user_url, params: { user_fields: { field_id => valid_options } }\n\n            user_field.update!(required: true)\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => nil } }\n            end.not_to change { user1.reload.user_fields[field_id] }\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => \"\" } }\n            end.not_to change { user1.reload.user_fields[field_id] }\n          end\n\n          it \"value can nil or empty if the field is not required\" do\n            put update_user_url, params: { user_fields: { field_id => valid_options } }\n\n            user_field.update!(required: false)\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => nil } }\n            end.to change { user1.reload.user_fields[field_id] }.from(valid_options).to(nil)\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => \"\" } }\n            end.to change { user1.reload.user_fields[field_id] }.from(nil).to(\"\")\n          end\n        end\n\n        context \"with dropdown fields\" do\n          let(:valid_options) { [\"Black Mesa\", \"Fox Hound\"] }\n\n          fab!(:user_field) do\n            Fabricate(:user_field, field_type: \"dropdown\") do\n              user_field_options do\n                [\n                  Fabricate(:user_field_option, value: \"Black Mesa\"),\n                  Fabricate(:user_field_option, value: \"Fox Hound\"),\n                ]\n              end\n            end\n          end\n\n          it \"shouldn't allow unregistered field values\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => \"Umbrella Corporation\" } }\n            end.not_to change { user1.reload.user_fields[field_id] }\n          end\n\n          it \"allows registered field values\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => valid_options.first } }\n            end.to change { user1.reload.user_fields[field_id] }.from(nil).to(valid_options.first)\n          end\n\n          it \"value can't be nil if the field is required\" do\n            put update_user_url, params: { user_fields: { field_id => valid_options.first } }\n\n            user_field.update!(required: true)\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => nil } }\n            end.not_to change { user1.reload.user_fields[field_id] }\n          end\n\n          it \"value can be set to nil if the field is not required\" do\n            put update_user_url, params: { user_fields: { field_id => valid_options.last } }\n\n            user_field.update!(required: false)\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => nil } }\n            end.to change { user1.reload.user_fields[field_id] }.from(valid_options.last).to(nil)\n          end\n        end\n\n        let(:create_params) do\n          {\n            name: @user.name,\n            password: \"suChS3cuRi7y\",\n            username: @user.username,\n            email: @user.email,\n            user_fields: {\n              user_field.id.to_s => \"value1\",\n              another_field.id.to_s => \"value2\",\n            },\n          }\n        end\n\n        it \"should succeed without the optional field\" do\n          post \"/u.json\", params: create_params\n          expect(response.status).to eq(200)\n          inserted = User.find_by_email(@user.email)\n          expect(inserted).to be_present\n          expect(inserted.custom_fields).to be_present\n          expect(inserted.custom_fields[\"user_field_#{user_field.id}\"]).to eq(\"value1\")\n          expect(inserted.custom_fields[\"user_field_#{another_field.id}\"]).to eq(\"value2\")\n          expect(inserted.custom_fields[\"user_field_#{optional_field.id}\"]).to be_blank\n        end\n\n        it \"should succeed with the optional field\" do\n          create_params[:user_fields][optional_field.id.to_s] = \"value3\"\n          post \"/u.json\", params: create_params.merge(create_params)\n          expect(response.status).to eq(200)\n          inserted = User.find_by_email(@user.email)\n          expect(inserted).to be_present\n          expect(inserted.custom_fields).to be_present\n          expect(inserted.custom_fields[\"user_field_#{user_field.id}\"]).to eq(\"value1\")\n          expect(inserted.custom_fields[\"user_field_#{another_field.id}\"]).to eq(\"value2\")\n          expect(inserted.custom_fields[\"user_field_#{optional_field.id}\"]).to eq(\"value3\")\n        end\n\n        it \"trims excessively long fields\" do\n          create_params[:user_fields][optional_field.id.to_s] = (\"x\" * 3000)\n          post \"/u.json\", params: create_params.merge(create_params)\n          expect(response.status).to eq(200)\n          inserted = User.find_by_email(@user.email)\n\n          val = inserted.custom_fields[\"user_field_#{optional_field.id}\"]\n          expect(val.length).to eq(UserField.max_length)\n        end\n      end\n    end\n\n    context \"with only optional custom fields\" do\n      fab!(:user_field) { Fabricate(:user_field, required: false) }\n\n      context \"without values for the fields\" do\n        let(:create_params) do\n          {\n            name: @user.name,\n            password: \"suChS3cuRi7y\",\n            username: @user.username,\n            email: @user.email,\n          }\n        end\n\n        it \"should succeed\" do\n          post \"/u.json\", params: create_params\n          expect(response.status).to eq(200)\n          inserted = User.find_by_email(@user.email)\n          expect(inserted).to be_present\n          expect(inserted.custom_fields).not_to be_present\n          expect(inserted.custom_fields[\"user_field_#{user_field.id}\"]).to be_blank\n        end\n      end\n    end\n\n    context \"when taking over a staged account\" do\n      before do\n        UsersController.any_instance.stubs(:honeypot_value).returns(\"abc\")\n        UsersController.any_instance.stubs(:challenge_value).returns(\"efg\")\n        SessionController.any_instance.stubs(:honeypot_value).returns(\"abc\")\n        SessionController.any_instance.stubs(:challenge_value).returns(\"efg\")\n      end\n\n      fab!(:staged) { Fabricate(:staged, email: \"staged@account.com\", active: true) }\n\n      it \"succeeds\" do\n        post \"/u.json\",\n             params:\n               honeypot_magic(email: staged.email, username: \"zogstrip\", password: \"P4ssw0rd$$\")\n\n        expect(response.status).to eq(200)\n        result = response.parsed_body\n        expect(result[\"success\"]).to eq(true)\n\n        created_user = User.find_by_email(staged.email)\n        expect(created_user.staged).to eq(false)\n        expect(created_user.active).to eq(false)\n        expect(created_user.registration_ip_address).to be_present\n        expect(!!created_user.custom_fields[\"from_staged\"]).to eq(true)\n\n        # do not allow emails changes please\n\n        put \"/u/update-activation-email.json\", params: { email: \"bob@bob.com\" }\n\n        created_user.reload\n        expect(created_user.email).to eq(\"staged@account.com\")\n        expect(response.status).to eq(403)\n      end\n\n      it \"works with custom fields\" do\n        tennis_field = Fabricate(:user_field, show_on_profile: true, name: \"Favorite tennis player\")\n\n        post \"/u.json\",\n             params:\n               honeypot_magic(\n                 email: staged.email,\n                 username: \"dude\",\n                 password: \"P4ssw0rd$$\",\n                 user_fields: {\n                   [tennis_field.id] => \"Nadal\",\n                 },\n               )\n\n        expect(response.status).to eq(200)\n        result = response.parsed_body\n        expect(result[\"success\"]).to eq(true)\n\n        created_user = User.find_by_email(staged.email)\n        expect(created_user.staged).to eq(false)\n        expect(created_user.active).to eq(false)\n        expect(created_user.registration_ip_address).to be_present\n        expect(!!created_user.custom_fields[\"from_staged\"]).to eq(true)\n\n        expect(created_user.custom_fields[\"user_field_#{tennis_field.id}\"]).to eq(\"Nadal\")\n      end\n    end\n  end\n\n  describe \"#username\" do\n    it \"raises an error when not logged in\" do\n      put \"/u/somename/preferences/username.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      let(:old_username) { \"OrigUsername\" }\n      let(:new_username) { \"#{old_username}1234\" }\n      fab!(:user) { Fabricate(:user, username: \"OrigUsername\") }\n\n      before do\n        user.username = old_username\n        sign_in(user)\n      end\n\n      it \"raises an error without a new_username param\" do\n        put \"/u/#{user.username}/preferences/username.json\", params: { username: user.username }\n        expect(response.status).to eq(400)\n        expect(user.reload.username).to eq(old_username)\n      end\n\n      it 'raises an error when you don\\'t have permission to change the username' do\n        Guardian.any_instance.expects(:can_edit_username?).with(user).returns(false)\n\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response).to be_forbidden\n        expect(user.reload.username).to eq(old_username)\n      end\n\n      it \"raises an error when change_username fails\" do\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: \"@\" }\n\n        expect(response.status).to eq(422)\n\n        body = response.parsed_body\n\n        expect(body[\"errors\"].first).to include(\n          I18n.t(\"user.username.short\", min: User.username_length.begin),\n        )\n\n        expect(user.reload.username).to eq(old_username)\n      end\n\n      it \"should succeed in normal circumstances\" do\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response.status).to eq(200)\n        expect(user.reload.username).to eq(new_username)\n      end\n\n      it \"raises an error when the username clashes with an existing user route\" do\n        put \"/u/#{user.username}/preferences/username.json\",\n            params: {\n              new_username: \"account-created\",\n            }\n\n        body = response.parsed_body\n\n        expect(body[\"errors\"].first).to include(I18n.t(\"login.reserved_username\"))\n      end\n\n      it \"raises an error when the username is in the reserved list\" do\n        SiteSetting.reserved_usernames = \"reserved\"\n\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: \"reserved\" }\n        body = response.parsed_body\n\n        expect(body[\"errors\"].first).to include(I18n.t(\"login.reserved_username\"))\n      end\n\n      it \"should fail if the user is old\" do\n        # Older than the change period and >1 post\n        user.created_at = Time.now - (SiteSetting.username_change_period + 1).days\n        PostCreator.new(\n          user,\n          title: \"This is a test topic\",\n          raw: \"This is a test this is a test\",\n        ).create\n\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response).to be_forbidden\n        expect(user.reload.username).to eq(old_username)\n      end\n\n      it \"should create a staff action log when a staff member changes the username\" do\n        acting_user = admin\n        sign_in(acting_user)\n\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response.status).to eq(200)\n        expect(\n          UserHistory.where(\n            action: UserHistory.actions[:change_username],\n            target_user_id: user.id,\n            acting_user_id: acting_user.id,\n          ),\n        ).to be_present\n        expect(user.reload.username).to eq(new_username)\n      end\n\n      it \"should return a JSON response with the updated username\" do\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response.parsed_body[\"username\"]).to eq(new_username)\n      end\n\n      it \"should respond with proper error message if auth_overrides_username is enabled\" do\n        SiteSetting.discourse_connect_url = \"http://someurl.com\"\n        SiteSetting.enable_discourse_connect = true\n        SiteSetting.auth_overrides_username = true\n        acting_user = admin\n        sign_in(acting_user)\n\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response.status).to eq(422)\n        expect(response.parsed_body[\"errors\"].first).to include(\n          I18n.t(\"errors.messages.auth_overrides_username\"),\n        )\n      end\n    end\n  end\n\n  describe \"#check_username\" do\n    it \"raises an error without any parameters\" do\n      get \"/u/check_username.json\"\n      expect(response.status).to eq(400)\n    end\n\n    shared_examples \"when username is unavailable\" do\n      it \"should return available as false in the JSON and return a suggested username\" do\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"available\"]).to eq(false)\n        expect(response.parsed_body[\"suggestion\"]).to be_present\n      end\n    end\n\n    shared_examples \"when username is available\" do\n      it \"should return available in the JSON\" do\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"available\"]).to eq(true)\n      end\n    end\n\n    it \"returns nothing when given an email param but no username\" do\n      get \"/u/check_username.json\", params: { email: \"dood@example.com\" }\n      expect(response.status).to eq(200)\n    end\n\n    context \"when username is available\" do\n      before { get \"/u/check_username.json\", params: { username: \"BruceWayne\" } }\n      include_examples \"when username is available\"\n    end\n\n    context \"when username is unavailable\" do\n      before { get \"/u/check_username.json\", params: { username: user1.username } }\n      include_examples \"when username is unavailable\"\n    end\n\n    shared_examples \"checking an invalid username\" do\n      it \"should not return an available key but should return an error message\" do\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"available\"]).to eq(nil)\n        expect(response.parsed_body[\"errors\"]).to be_present\n      end\n    end\n\n    context \"when has invalid characters\" do\n      before { get \"/u/check_username.json\", params: { username: \"bad username\" } }\n      include_examples \"checking an invalid username\"\n\n      it \"should return the invalid characters message\" do\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"errors\"]).to include(I18n.t(:\"user.username.characters\"))\n      end\n    end\n\n    context \"when is too long\" do\n      before do\n        get \"/u/check_username.json\",\n            params: {\n              username: SecureRandom.alphanumeric(SiteSetting.max_username_length.to_i + 1),\n            }\n      end\n      include_examples \"checking an invalid username\"\n\n      it 'should return the \"too long\" message' do\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"errors\"]).to include(\n          I18n.t(:\"user.username.long\", max: SiteSetting.max_username_length),\n        )\n      end\n    end\n\n    describe \"different case of existing username\" do\n      context \"when it's my username\" do\n        fab!(:user) { Fabricate(:user, username: \"hansolo\") }\n        before do\n          sign_in(user)\n\n          get \"/u/check_username.json\", params: { username: \"HanSolo\" }\n        end\n        include_examples \"when username is available\"\n      end\n\n      context \"when it's someone else's username\" do\n        fab!(:user) { Fabricate(:user, username: \"hansolo\") }\n        fab!(:someone_else) { Fabricate(:user) }\n        before do\n          sign_in(someone_else)\n\n          get \"/u/check_username.json\", params: { username: \"HanSolo\" }\n        end\n        include_examples \"when username is unavailable\"\n      end\n\n      context \"when an admin changing it for someone else\" do\n        fab!(:user) { Fabricate(:user, username: \"hansolo\") }\n        before do\n          sign_in(admin)\n\n          get \"/u/check_username.json\", params: { username: \"HanSolo\", for_user_id: user.id }\n        end\n        include_examples \"when username is available\"\n      end\n    end\n  end\n\n  describe \"#check_email\" do\n    it \"returns success if hide_email_address_taken is true\" do\n      SiteSetting.hide_email_address_taken = true\n\n      get \"/u/check_email.json\", params: { email: user1.email }\n      expect(response.parsed_body[\"success\"]).to be_present\n    end\n\n    it \"returns success if email is empty\" do\n      get \"/u/check_email.json\"\n      expect(response.parsed_body[\"success\"]).to be_present\n    end\n\n    it \"returns failure if email is not valid\" do\n      get \"/u/check_email.json\", params: { email: \"invalid\" }\n      expect(response.parsed_body[\"failed\"]).to be_present\n    end\n\n    it \"returns failure if email exists\" do\n      get \"/u/check_email.json\", params: { email: user1.email }\n      expect(response.parsed_body[\"failed\"]).to be_present\n\n      get \"/u/check_email.json\", params: { email: user1.email.upcase }\n      expect(response.parsed_body[\"failed\"]).to be_present\n    end\n\n    it \"returns success if email does not exists\" do\n      get \"/u/check_email.json\", params: { email: \"available@example.com\" }\n      expect(response.parsed_body[\"success\"]).to be_present\n    end\n\n    it \"return success if user email is taken by staged user\" do\n      get \"/u/check_email.json\", params: { email: Fabricate(:staged).email }\n      expect(response.parsed_body[\"success\"]).to be_present\n    end\n  end\n\n  describe \"#invited\" do\n    it \"fails for anonymous users\" do\n      get \"/u/#{user1.username}/invited.json\", params: { username: user1.username }\n\n      expect(response.status).to eq(403)\n    end\n\n    it \"returns success\" do\n      user = Fabricate(:user, trust_level: 2)\n      Fabricate(:invite, invited_by: user)\n\n      sign_in(user)\n      get \"/u/#{user.username}/invited.json\", params: { username: user.username }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"counts\"][\"pending\"]).to eq(1)\n      expect(response.parsed_body[\"counts\"][\"total\"]).to eq(1)\n    end\n\n    it \"filters by all if viewing self\" do\n      inviter = Fabricate(:user, trust_level: 2)\n      sign_in(inviter)\n\n      Fabricate(:invite, email: \"billybob@example.com\", invited_by: inviter)\n      redeemed_invite = Fabricate(:invite, email: \"jimtom@example.com\", invited_by: inviter)\n      Fabricate(:invited_user, invite: redeemed_invite, user: invitee)\n\n      get \"/u/#{inviter.username}/invited.json\", params: { filter: \"pending\", search: \"billybob\" }\n      expect(response.status).to eq(200)\n\n      invites = response.parsed_body[\"invites\"]\n      expect(invites.size).to eq(1)\n      expect(invites.first).to include(\"email\" => \"billybob@example.com\")\n\n      get \"/u/#{inviter.username}/invited.json\",\n          params: {\n            filter: \"redeemed\",\n            search: invitee.username,\n          }\n      expect(response.status).to eq(200)\n\n      invites = response.parsed_body[\"invites\"]\n      expect(invites.size).to eq(1)\n      expect(invites[0][\"user\"]).to be_present\n    end\n\n    it \"doesn't filter by email if another regular user\" do\n      inviter = Fabricate(:user, trust_level: 2)\n      sign_in(Fabricate(:user, trust_level: 2))\n\n      Fabricate(:invite, email: \"billybob@example.com\", invited_by: inviter)\n      redeemed_invite = Fabricate(:invite, email: \"jimtom@example.com\", invited_by: inviter)\n      Fabricate(:invited_user, invite: redeemed_invite, user: invitee)\n\n      get \"/u/#{inviter.username}/invited.json\", params: { filter: \"pending\", search: \"billybob\" }\n      expect(response.status).to eq(200)\n\n      invites = response.parsed_body[\"invites\"]\n      expect(invites.size).to eq(0)\n\n      get \"/u/#{inviter.username}/invited.json\",\n          params: {\n            filter: \"redeemed\",\n            search: invitee.username,\n          }\n      expect(response.status).to eq(200)\n\n      invites = response.parsed_body[\"invites\"]\n      expect(invites.size).to eq(1)\n      expect(invites[0][\"user\"]).to be_present\n    end\n\n    it \"filters by email if staff\" do\n      inviter = Fabricate(:user, trust_level: 2)\n      sign_in(moderator)\n\n      invite_1 = Fabricate(:invite, email: \"billybob@example.com\", invited_by: inviter)\n      invitee_1 = Fabricate(:user)\n      Fabricate(:invited_user, invite: invite_1, user: invitee_1)\n      invite_2 = Fabricate(:invite, email: \"jimtom@example.com\", invited_by: inviter)\n      invitee_2 = Fabricate(:user)\n      Fabricate(:invited_user, invite: invite_2, user: invitee_2)\n\n      get \"/u/#{inviter.username}/invited.json\", params: { search: \"billybob\" }\n      expect(response.status).to eq(200)\n\n      invites = response.parsed_body[\"invites\"]\n      expect(invites.size).to eq(1)\n      expect(invites[0][\"user\"]).to include(\"id\" => invitee_1.id)\n    end\n\n    context \"with guest\" do\n      context \"with pending invites\" do\n        it \"does not return invites\" do\n          Fabricate(:invite, invited_by: inviter)\n\n          get \"/u/#{user1.username}/invited/pending.json\"\n          expect(response.status).to eq(403)\n        end\n      end\n\n      context \"with redeemed invites\" do\n        it \"returns invited_users\" do\n          inviter = Fabricate(:user, trust_level: 2)\n          sign_in(inviter)\n          invite = Fabricate(:invite, invited_by: inviter)\n          _invited_user = Fabricate(:invited_user, invite: invite, user: invitee)\n\n          get \"/u/#{inviter.username}/invited.json\"\n          expect(response.status).to eq(200)\n\n          invites = response.parsed_body[\"invites\"]\n          expect(invites.size).to eq(1)\n          expect(invites[0]).to include(\"id\" => invite.id)\n        end\n      end\n    end\n\n    context \"with authenticated user\" do\n      context \"with pending invites\" do\n        context \"with permission to see pending invites\" do\n          it \"returns invites\" do\n            inviter = Fabricate(:user, trust_level: 2)\n            invite = Fabricate(:invite, invited_by: inviter)\n            sign_in(inviter)\n\n            get \"/u/#{inviter.username}/invited/pending.json\"\n            expect(response.status).to eq(200)\n\n            invites = response.parsed_body[\"invites\"]\n            expect(invites.size).to eq(1)\n            expect(invites.first).to include(\"email\" => invite.email)\n            expect(response.parsed_body[\"can_see_invite_details\"]).to eq(true)\n          end\n        end\n\n        context \"without permission to see pending invites\" do\n          it \"does not return invites\" do\n            user = sign_in(Fabricate(:user))\n            Fabricate(:invite, invited_by: inviter)\n            stub_guardian(user) do |guardian|\n              guardian.stubs(:can_see_invite_details?).with(inviter).returns(false)\n            end\n\n            get \"/u/#{inviter.username}/invited/pending.json\"\n            expect(response.status).to eq(422)\n          end\n        end\n\n        context \"with permission to see invite links\" do\n          it \"returns own invites\" do\n            inviter = sign_in(Fabricate(:user, trust_level: 2))\n            invite =\n              Fabricate(\n                :invite,\n                invited_by: inviter,\n                email: nil,\n                max_redemptions_allowed: 5,\n                expires_at: 1.month.from_now,\n                emailed_status: Invite.emailed_status_types[:not_required],\n              )\n\n            get \"/u/#{inviter.username}/invited/pending.json\"\n            expect(response.status).to eq(200)\n\n            invites = response.parsed_body[\"invites\"]\n            expect(invites.size).to eq(1)\n            expect(invites.first).to include(\"id\" => invite.id)\n            expect(response.parsed_body[\"can_see_invite_details\"]).to eq(true)\n          end\n\n          it \"allows admin to see invites\" do\n            inviter = Fabricate(:user, trust_level: 2)\n            _admin = sign_in(Fabricate(:admin))\n            invite =\n              Fabricate(\n                :invite,\n                invited_by: inviter,\n                email: nil,\n                max_redemptions_allowed: 5,\n                expires_at: 1.month.from_now,\n                emailed_status: Invite.emailed_status_types[:not_required],\n              )\n\n            get \"/u/#{inviter.username}/invited/pending.json\"\n            expect(response.status).to eq(200)\n\n            invites = response.parsed_body[\"invites\"]\n            expect(invites.size).to eq(1)\n            expect(invites.first).to include(\"id\" => invite.id)\n            expect(response.parsed_body[\"can_see_invite_details\"]).to eq(true)\n          end\n        end\n\n        context \"without permission to see invite links\" do\n          it \"does not return invites\" do\n            _user = Fabricate(:user, trust_level: 2)\n            inviter = admin\n            Fabricate(\n              :invite,\n              invited_by: inviter,\n              email: nil,\n              max_redemptions_allowed: 5,\n              expires_at: 1.month.from_now,\n              emailed_status: Invite.emailed_status_types[:not_required],\n            )\n\n            get \"/u/#{inviter.username}/invited/pending.json\"\n            expect(response.status).to eq(403)\n          end\n        end\n      end\n\n      context \"with redeemed invites\" do\n        it \"returns invites\" do\n          sign_in(moderator)\n          invite = Fabricate(:invite, invited_by: inviter)\n          Fabricate(:invited_user, invite: invite, user: invitee)\n\n          get \"/u/#{inviter.username}/invited.json\"\n          expect(response.status).to eq(200)\n\n          invites = response.parsed_body[\"invites\"]\n          expect(invites.size).to eq(1)\n          expect(invites[0]).to include(\"id\" => invite.id)\n        end\n      end\n    end\n  end\n\n  describe \"#update\" do\n    context \"with guest\" do\n      it \"raises an error\" do\n        put \"/u/guest.json\"\n        expect(response.status).to eq(403)\n      end\n    end\n\n    it \"does not allow name to be updated if auth auth_overrides_name is enabled\" do\n      SiteSetting.auth_overrides_name = true\n\n      sign_in(user1)\n\n      put \"/u/#{user1.username}\", params: { name: \"test.test\" }\n\n      expect(response.status).to eq(200)\n      expect(user1.reload.name).to_not eq(\"test.test\")\n    end\n\n    context \"when username contains a period\" do\n      before { sign_in(user) }\n\n      fab!(:user) { Fabricate(:user, username: \"test.test\", name: \"Test User\") }\n\n      it \"should be able to update a user\" do\n        put \"/u/#{user.username}\", params: { name: \"test.test\" }\n\n        expect(response.status).to eq(200)\n        expect(user.reload.name).to eq(\"test.test\")\n      end\n    end\n\n    context \"as a staff user\" do\n      context \"with uneditable field\" do\n        fab!(:user_field) { Fabricate(:user_field, editable: false) }\n\n        it \"allows staff to edit the field\" do\n          sign_in(admin)\n          put \"/u/#{user.username}.json\",\n              params: {\n                name: \"Jim Tom\",\n                title: \"foobar\",\n                user_fields: {\n                  user_field.id.to_s => \"happy\",\n                },\n              }\n\n          expect(response.status).to eq(200)\n\n          user.reload\n\n          expect(user.user_fields[user_field.id.to_s]).to eq(\"happy\")\n          expect(user.title).to eq(\"foobar\")\n        end\n      end\n    end\n\n    context \"with authenticated user\" do\n      context \"with permission to update\" do\n        fab!(:upload) { Fabricate(:upload) }\n        fab!(:user) { Fabricate(:user) }\n\n        before { sign_in(user) }\n\n        it \"allows the update\" do\n          SiteSetting.tagging_enabled = true\n          user2 = Fabricate(:user)\n          user3 = Fabricate(:user)\n          tags = [Fabricate(:tag), Fabricate(:tag)]\n          tag_synonym = Fabricate(:tag, target_tag: tags[1])\n\n          put \"/u/#{user.username}.json\",\n              params: {\n                name: \"Jim Tom\",\n                muted_usernames: \"#{user2.username},#{user3.username}\",\n                watched_tags: \"#{tags[0].name},#{tag_synonym.name}\",\n                card_background_upload_url: upload.url,\n                profile_background_upload_url: upload.url,\n              }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"user\"][\"watched_tags\"].count).to eq(2)\n\n          user.reload\n\n          expect(user.name).to eq \"Jim Tom\"\n          expect(user.muted_users.pluck(:username).sort).to eq [user2.username, user3.username].sort\n\n          expect(\n            TagUser.where(\n              user: user,\n              notification_level: TagUser.notification_levels[:watching],\n            ).pluck(:tag_id),\n          ).to contain_exactly(tags[0].id, tags[1].id)\n\n          theme = Fabricate(:theme, user_selectable: true)\n\n          put \"/u/#{user.username}.json\",\n              params: {\n                muted_usernames: \"\",\n                theme_ids: [theme.id],\n                email_level: UserOption.email_level_types[:always],\n              }\n\n          user.reload\n\n          expect(user.muted_users.pluck(:username).sort).to be_empty\n          expect(user.user_option.theme_ids).to eq([theme.id])\n          expect(user.user_option.email_level).to eq(UserOption.email_level_types[:always])\n          expect(user.profile_background_upload).to eq(upload)\n          expect(user.card_background_upload).to eq(upload)\n        end\n\n        it \"updates watched tags in everyone tag group\" do\n          SiteSetting.tagging_enabled = true\n          tags = [Fabricate(:tag), Fabricate(:tag)]\n          group =\n            Fabricate(:group, name: \"group\", mentionable_level: Group::ALIAS_LEVELS[:everyone])\n          tag_group = Fabricate(:tag_group, tags: tags)\n          Fabricate(:tag_group_permission, tag_group: tag_group, group: group)\n          tag_synonym = Fabricate(:tag, target_tag: tags[1])\n\n          put \"/u/#{user.username}.json\",\n              params: {\n                watched_tags: \"#{tags[0].name},#{tag_synonym.name}\",\n              }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"user\"][\"watched_tags\"].count).to eq(2)\n        end\n\n        context \"when a locale is chosen that differs from I18n.locale\" do\n          before { SiteSetting.allow_user_locale = true }\n\n          it \"updates the user's locale\" do\n            I18n.locale = :fr\n            put \"/u/#{user.username}.json\", params: { locale: :fa_IR }\n            expect(user.reload.locale).to eq(\"fa_IR\")\n          end\n\n          it \"updates the title\" do\n            BadgeGranter.enable_queue\n            user.update!(locale: :fr)\n            user.change_trust_level!(TrustLevel[4])\n            BadgeGranter.process_queue!\n\n            leader_title = I18n.t(\"badges.leader.name\", locale: :fr)\n            put \"/u/#{user.username}.json\", params: { title: leader_title }\n            expect(user.reload.title).to eq(leader_title)\n          ensure\n            BadgeGranter.disable_queue\n            BadgeGranter.clear_queue!\n          end\n        end\n\n        context \"with user fields\" do\n          context \"with an editable field\" do\n            fab!(:user_field) { Fabricate(:user_field) }\n            fab!(:optional_field) { Fabricate(:user_field, required: false) }\n\n            it \"should update the user field\" do\n              put \"/u/#{user.username}.json\",\n                  params: {\n                    name: \"Jim Tom\",\n                    user_fields: {\n                      user_field.id.to_s => \"happy\",\n                    },\n                  }\n\n              expect(response.status).to eq(200)\n              expect(user.user_fields[user_field.id.to_s]).to eq \"happy\"\n            end\n\n            it \"cannot be updated to blank\" do\n              put \"/u/#{user.username}.json\",\n                  params: {\n                    name: \"Jim Tom\",\n                    user_fields: {\n                      user_field.id.to_s => \"\",\n                    },\n                  }\n\n              expect(response.status).to eq(422)\n              expect(user.user_fields[user_field.id.to_s]).not_to eq(\"happy\")\n            end\n\n            it \"trims excessively large fields\" do\n              put \"/u/#{user.username}.json\",\n                  params: {\n                    name: \"Jim Tom\",\n                    user_fields: {\n                      user_field.id.to_s => (\"x\" * 3000),\n                    },\n                  }\n\n              expect(user.user_fields[user_field.id.to_s].size).to eq(UserField.max_length)\n            end\n\n            it \"should retain existing user fields\" do\n              put \"/u/#{user.username}.json\",\n                  params: {\n                    name: \"Jim Tom\",\n                    user_fields: {\n                      user_field.id.to_s => \"happy\",\n                      optional_field.id.to_s => \"feet\",\n                    },\n                  }\n\n              expect(response.status).to eq(200)\n              expect(user.user_fields[user_field.id.to_s]).to eq(\"happy\")\n              expect(user.user_fields[optional_field.id.to_s]).to eq(\"feet\")\n\n              put \"/u/#{user.username}.json\",\n                  params: {\n                    name: \"Jim Tom\",\n                    user_fields: {\n                      user_field.id.to_s => \"sad\",\n                    },\n                  }\n\n              expect(response.status).to eq(200)\n\n              user.reload\n\n              expect(user.user_fields[user_field.id.to_s]).to eq(\"sad\")\n              expect(user.user_fields[optional_field.id.to_s]).to eq(\"feet\")\n            end\n          end\n\n          context \"with user_notification_schedule attributes\" do\n            it \"updates the user's notification schedule\" do\n              params = {\n                user_notification_schedule: {\n                  enabled: true,\n                  day_0_start_time: 30,\n                  day_0_end_time: 60,\n                  day_1_start_time: 30,\n                  day_1_end_time: 60,\n                  day_2_start_time: 30,\n                  day_2_end_time: 60,\n                  day_3_start_time: 30,\n                  day_3_end_time: 60,\n                  day_4_start_time: 30,\n                  day_4_end_time: 60,\n                  day_5_start_time: 30,\n                  day_5_end_time: 60,\n                  day_6_start_time: 30,\n                  day_6_end_time: 60,\n                },\n              }\n              put \"/u/#{user.username}.json\", params: params\n\n              user.reload\n              expect(user.user_notification_schedule.enabled).to eq(true)\n              expect(user.user_notification_schedule.day_0_start_time).to eq(30)\n              expect(user.user_notification_schedule.day_0_end_time).to eq(60)\n              expect(user.user_notification_schedule.day_6_start_time).to eq(30)\n              expect(user.user_notification_schedule.day_6_end_time).to eq(60)\n            end\n          end\n\n          context \"with uneditable field\" do\n            fab!(:user_field) { Fabricate(:user_field, editable: false) }\n\n            it \"does not update the user field\" do\n              put \"/u/#{user.username}.json\",\n                  params: {\n                    name: \"Jim Tom\",\n                    user_fields: {\n                      user_field.id.to_s => \"happy\",\n                    },\n                  }\n\n              expect(response.status).to eq(200)\n              expect(user.user_fields[user_field.id.to_s]).to be_blank\n            end\n          end\n\n          context \"with custom_field\" do\n            before do\n              plugin = Plugin::Instance.new\n              plugin.register_editable_user_custom_field :test2\n              plugin.register_editable_user_custom_field :test3, staff_only: true\n            end\n\n            after { DiscoursePluginRegistry.reset! }\n\n            it \"only updates allowed user fields\" do\n              put \"/u/#{user.username}.json\",\n                  params: {\n                    custom_fields: {\n                      test1: :hello1,\n                      test2: :hello2,\n                      test3: :hello3,\n                    },\n                  }\n\n              expect(response.status).to eq(200)\n              expect(user.custom_fields[\"test1\"]).to be_blank\n              expect(user.custom_fields[\"test2\"]).to eq(\"hello2\")\n              expect(user.custom_fields[\"test3\"]).to be_blank\n            end\n\n            it \"works alongside a user field\" do\n              user_field = Fabricate(:user_field, editable: true)\n              put \"/u/#{user.username}.json\",\n                  params: {\n                    custom_fields: {\n                      test1: :hello1,\n                      test2: :hello2,\n                      test3: :hello3,\n                    },\n                    user_fields: {\n                      user_field.id.to_s => \"happy\",\n                    },\n                  }\n              expect(response.status).to eq(200)\n              expect(user.custom_fields[\"test1\"]).to be_blank\n              expect(user.custom_fields[\"test2\"]).to eq(\"hello2\")\n              expect(user.custom_fields[\"test3\"]).to eq(nil)\n              expect(user.user_fields[user_field.id.to_s]).to eq(\"happy\")\n            end\n\n            it \"works alongside a user field during creation\" do\n              api_key = Fabricate(:api_key, user: admin)\n              user_field = Fabricate(:user_field, editable: true)\n              post \"/u.json\",\n                   params: {\n                     name: \"Test User\",\n                     username: \"testuser\",\n                     email: \"user@mail.com\",\n                     password: \"supersecure\",\n                     active: true,\n                     custom_fields: {\n                       test2: \"custom field value\",\n                     },\n                     user_fields: {\n                       user_field.id.to_s => \"user field value\",\n                     },\n                   },\n                   headers: {\n                     HTTP_API_KEY: api_key.key,\n                   }\n              expect(response.status).to eq(200)\n              u = User.find_by_email(\"user@mail.com\")\n\n              val = u.custom_fields[\"user_field_#{user_field.id}\"]\n              expect(val).to eq(\"user field value\")\n\n              val = u.custom_fields[\"test2\"]\n              expect(val).to eq(\"custom field value\")\n            end\n\n            it \"is secure when there are no registered editable fields\" do\n              DiscoursePluginRegistry.reset!\n              put \"/u/#{user.username}.json\",\n                  params: {\n                    custom_fields: {\n                      test1: :hello1,\n                      test2: :hello2,\n                      test3: :hello3,\n                    },\n                  }\n              expect(response.status).to eq(200)\n              expect(user.custom_fields[\"test1\"]).to be_blank\n              expect(user.custom_fields[\"test2\"]).to be_blank\n              expect(user.custom_fields[\"test3\"]).to be_blank\n\n              put \"/u/#{user.username}.json\", params: { custom_fields: %w[arrayitem1 arrayitem2] }\n              expect(response.status).to eq(200)\n            end\n\n            it \"allows staff to edit staff-editable fields\" do\n              sign_in(admin)\n              put \"/u/#{user.username}.json\",\n                  params: {\n                    custom_fields: {\n                      test1: :hello1,\n                      test2: :hello2,\n                      test3: :hello3,\n                    },\n                  }\n\n              expect(response.status).to eq(200)\n              expect(user.custom_fields[\"test1\"]).to be_blank\n              expect(user.custom_fields[\"test2\"]).to eq(\"hello2\")\n              expect(user.custom_fields[\"test3\"]).to eq(\"hello3\")\n            end\n          end\n        end\n\n        it \"returns user JSON\" do\n          put \"/u/#{user.username}.json\"\n\n          json = response.parsed_body\n          expect(json[\"user\"][\"id\"]).to eq user.id\n        end\n\n        context \"with sidebar\" do\n          before { SiteSetting.navigation_menu = \"sidebar\" }\n\n          it \"does not remove category or tag sidebar section links when params are not present\" do\n            Fabricate(:category_sidebar_section_link, user: user)\n            Fabricate(:tag_sidebar_section_link, user: user)\n\n            expect do\n              put \"/u/#{user.username}.json\"\n\n              expect(response.status).to eq(200)\n            end.to_not change { user.sidebar_section_links.count }\n          end\n\n          it \"should allow user to remove all category sidebar section links\" do\n            Fabricate(:category_sidebar_section_link, user: user)\n\n            expect do\n              put \"/u/#{user.username}.json\", params: { sidebar_category_ids: nil }\n\n              expect(response.status).to eq(200)\n            end.to change { user.sidebar_section_links.count }.from(1).to(0)\n          end\n\n          it \"should allow user to only modify category sidebar section links for categories they have access to\" do\n            category = Fabricate(:category)\n            group = Fabricate(:group)\n            restricted_category = Fabricate(:private_category, group: group)\n            category_sidebar_section_link = Fabricate(:category_sidebar_section_link, user: user)\n\n            put \"/u/#{user.username}.json\",\n                params: {\n                  sidebar_category_ids: [category.id, restricted_category.id],\n                }\n\n            expect(response.status).to eq(200)\n            expect(user.sidebar_section_links.count).to eq(1)\n            expect(SidebarSectionLink.exists?(id: category_sidebar_section_link.id)).to eq(false)\n\n            sidebar_section_link = user.sidebar_section_links.first\n\n            expect(sidebar_section_link.linkable).to eq(category)\n\n            group.add(user)\n\n            expect do\n              put \"/u/#{user.username}.json\",\n                  params: {\n                    sidebar_category_ids: [category.id, restricted_category.id],\n                  }\n\n              expect(response.status).to eq(200)\n            end.to change { user.sidebar_section_links.count }.from(1).to(2)\n\n            expect(SidebarSectionLink.exists?(user: user, linkable: restricted_category)).to eq(\n              true,\n            )\n          end\n\n          it \"should allow user to remove all tag sidebar section links\" do\n            SiteSetting.tagging_enabled = true\n\n            Fabricate(:tag_sidebar_section_link, user: user)\n\n            expect do\n              put \"/u/#{user.username}.json\", params: { sidebar_tag_names: nil }\n\n              expect(response.status).to eq(200)\n            end.to change { user.sidebar_section_links.count }.from(1).to(0)\n          end\n\n          it \"should not allow user to add tag sidebar section links when tagging is disabled\" do\n            SiteSetting.tagging_enabled = false\n\n            tag = Fabricate(:tag)\n\n            put \"/u/#{user.username}.json\", params: { sidebar_tag_names: [tag.name] }\n\n            expect(response.status).to eq(200)\n            expect(user.reload.sidebar_section_links.count).to eq(0)\n          end\n\n          it \"should allow user to add tag sidebar section links only for tags that are visible to the user\" do\n            SiteSetting.tagging_enabled = true\n\n            tag = Fabricate(:tag)\n            tag_sidebar_section_link = Fabricate(:tag_sidebar_section_link, user: user)\n\n            hidden_tag = Fabricate(:tag)\n            Fabricate(:tag_group, permissions: { \"staff\" => 1 }, tag_names: [hidden_tag.name])\n\n            put \"/u/#{user.username}.json\",\n                params: {\n                  sidebar_tag_names: [tag.name, \"somerandomtag\", hidden_tag.name],\n                }\n\n            expect(response.status).to eq(200)\n            expect(user.sidebar_section_links.count).to eq(1)\n            expect(SidebarSectionLink.exists?(id: tag_sidebar_section_link.id)).to eq(false)\n\n            sidebar_section_link = user.sidebar_section_links.first\n\n            expect(sidebar_section_link.linkable).to eq(tag)\n\n            user.update!(admin: true)\n\n            expect do\n              put \"/u/#{user.username}.json\",\n                  params: {\n                    sidebar_tag_names: [tag.name, \"somerandomtag\", hidden_tag.name],\n                  }\n\n              expect(response.status).to eq(200)\n            end.to change { user.sidebar_section_links.count }.from(1).to(2)\n\n            expect(SidebarSectionLink.exists?(user: user, linkable: hidden_tag)).to eq(true)\n          end\n        end\n      end\n\n      context \"without permission to update\" do\n        it \"does not allow the update\" do\n          user = Fabricate(:user, name: \"Billy Bob\")\n          sign_in(Fabricate(:user))\n\n          put \"/u/#{user.username}.json\", params: { name: \"Jim Tom\" }\n\n          expect(response).to be_forbidden\n          expect(user.reload.name).not_to eq \"Jim Tom\"\n        end\n      end\n    end\n\n    context \"with external_ids\" do\n      fab!(:api_key, refind: false) { Fabricate(:api_key, user: admin) }\n\n      let(:plugin_auth_provider) do\n        authenticator_class =\n          Class.new(Auth::ManagedAuthenticator) do\n            def name\n              \"pluginauth\"\n            end\n\n            def enabled?\n              true\n            end\n          end\n\n        provider = Auth::AuthProvider.new\n        provider.authenticator = authenticator_class.new\n        provider\n      end\n\n      before do\n        DiscoursePluginRegistry.register_auth_provider(plugin_auth_provider)\n        SiteSetting.discourse_connect_url = \"http://localhost\"\n        SiteSetting.enable_discourse_connect = true\n      end\n\n      after { DiscoursePluginRegistry.reset! }\n\n      it \"can create UserAssociatedAccount records\" do\n        params = { external_ids: { \"pluginauth\" => \"pluginauth_uid\" } }\n\n        expect {\n          put \"/u/#{user.username}.json\", params: params, headers: { HTTP_API_KEY: api_key.key }\n        }.to change { UserAssociatedAccount.count }.by(1)\n\n        expect(response.status).to eq(200)\n\n        user_associated_account = UserAssociatedAccount.last\n        expect(user.reload.user_associated_account_ids).to contain_exactly(\n          user_associated_account.id,\n        )\n        expect(user_associated_account.provider_name).to eq(\"pluginauth\")\n        expect(user_associated_account.provider_uid).to eq(\"pluginauth_uid\")\n        expect(user_associated_account.user_id).to eq(user.id)\n      end\n\n      it \"can destroy UserAssociatedAccount records\" do\n        user.user_associated_accounts.create!(\n          provider_name: \"pluginauth\",\n          provider_uid: \"pluginauth_uid\",\n        )\n\n        params = { external_ids: { \"pluginauth\" => nil } }\n\n        expect {\n          put \"/u/#{user.username}.json\", params: params, headers: { HTTP_API_KEY: api_key.key }\n        }.to change { UserAssociatedAccount.count }.by(-1)\n\n        expect(response.status).to eq(200)\n        expect(user.reload.user_associated_account_ids).to be_blank\n      end\n\n      it \"can create SingleSignOnRecord records\" do\n        params = { external_ids: { discourse_connect: \"discourse_connect_uid\" } }\n\n        expect {\n          put \"/u/#{user.username}.json\", params: params, headers: { HTTP_API_KEY: api_key.key }\n        }.to change { SingleSignOnRecord.count }.by(1)\n\n        expect(response.status).to eq(200)\n\n        single_sign_on_record = SingleSignOnRecord.last\n        expect(user.reload.single_sign_on_record).to eq(single_sign_on_record)\n        expect(single_sign_on_record.external_id).to eq(\"discourse_connect_uid\")\n      end\n\n      it \"can update SingleSignOnRecord records\" do\n        user = Fabricate(:user)\n        SingleSignOnRecord.create!(\n          user_id: user.id,\n          external_id: \"discourse_connect_uid\",\n          last_payload: \"discourse_connect_uid\",\n        )\n\n        params = { external_ids: { discourse_connect: \"discourse_connect_uid_2\" } }\n\n        expect {\n          put \"/u/#{user.username}.json\", params: params, headers: { HTTP_API_KEY: api_key.key }\n        }.not_to change { SingleSignOnRecord.count }\n\n        expect(response.status).to eq(200)\n        expect(user.reload.single_sign_on_record.external_id).to eq(\"discourse_connect_uid_2\")\n      end\n\n      it \"can delete SingleSignOnRecord records\" do\n        user = Fabricate(:user)\n        SingleSignOnRecord.create!(\n          user_id: user.id,\n          external_id: \"discourse_connect_uid\",\n          last_payload: \"discourse_connect_uid\",\n        )\n\n        params = { external_ids: { discourse_connect: nil } }\n\n        expect {\n          put \"/u/#{user.username}.json\", params: params, headers: { HTTP_API_KEY: api_key.key }\n        }.to change { SingleSignOnRecord.count }.by(-1)\n\n        expect(response.status).to eq(200)\n        expect(user.reload.single_sign_on_record).to be_blank\n      end\n\n      it \"can update SingleSignOnRecord and UserAssociatedAccount records in a single call\" do\n        user = Fabricate(:user)\n        user.user_associated_accounts.create!(\n          provider_name: \"pluginauth\",\n          provider_uid: \"pluginauth_uid\",\n        )\n        SingleSignOnRecord.create!(\n          user_id: user.id,\n          external_id: \"discourse_connect_uid\",\n          last_payload: \"discourse_connect_uid\",\n        )\n\n        params = {\n          external_ids: {\n            discourse_connect: \"discourse_connect_uid_2\",\n            pluginauth: \"pluginauth_uid_2\",\n          },\n        }\n\n        expect {\n          put \"/u/#{user.username}.json\", params: params, headers: { HTTP_API_KEY: api_key.key }\n        }.to change { SingleSignOnRecord.count + UserAssociatedAccount.count }.by(0)\n\n        expect(response.status).to eq(200)\n        expect(user.reload.single_sign_on_record.external_id).to eq(\"discourse_connect_uid_2\")\n        user_associated_account = UserAssociatedAccount.last\n        expect(user.reload.user_associated_account_ids).to contain_exactly(\n          user_associated_account.id,\n        )\n        expect(user_associated_account.provider_name).to eq(\"pluginauth\")\n        expect(user_associated_account.provider_uid).to eq(\"pluginauth_uid_2\")\n        expect(user_associated_account.user_id).to eq(user.id)\n      end\n\n      it \"returns error if external ID provider does not exist\" do\n        params = { external_ids: { \"pluginauth2\" => \"pluginauth_uid\" } }\n\n        put \"/u/#{user.username}.json\", params: params, headers: { HTTP_API_KEY: api_key.key }\n        expect(response.status).to eq(400)\n      end\n    end\n\n    context \"with user status\" do\n      context \"as a regular user\" do\n        before do\n          SiteSetting.enable_user_status = true\n          sign_in(user)\n        end\n\n        it \"sets user status\" do\n          status = { emoji: \"tooth\", description: \"off to dentist\" }\n\n          put \"/u/#{user.username}.json\", params: { status: status }\n          expect(response.status).to eq(200)\n\n          user.reload\n          expect(user.user_status).not_to be_nil\n          expect(user.user_status.emoji).to eq(status[:emoji])\n          expect(user.user_status.description).to eq(status[:description])\n        end\n\n        it \"updates user status\" do\n          user.set_status!(\"off to dentist\", \"tooth\")\n          user.reload\n\n          new_status = { emoji: \"surfing_man\", description: \"surfing\" }\n          put \"/u/#{user.username}.json\", params: { status: new_status }\n          expect(response.status).to eq(200)\n\n          user.reload\n          expect(user.user_status).not_to be_nil\n          expect(user.user_status.emoji).to eq(new_status[:emoji])\n          expect(user.user_status.description).to eq(new_status[:description])\n        end\n\n        it \"clears user status\" do\n          user.set_status!(\"off to dentist\", \"tooth\")\n          user.reload\n\n          put \"/u/#{user.username}.json\", params: { status: nil }\n          expect(response.status).to eq(200)\n\n          user.reload\n          expect(user.user_status).to be_nil\n        end\n\n        it \"can't set status of another user\" do\n          put \"/u/#{user1.username}.json\",\n              params: {\n                status: {\n                  emoji: \"tooth\",\n                  description: \"off to dentist\",\n                },\n              }\n          expect(response.status).to eq(403)\n\n          user1.reload\n          expect(user1.user_status).to be_nil\n        end\n\n        it \"can't update status of another user\" do\n          old_status = { emoji: \"tooth\", description: \"off to dentist\" }\n          user1.set_status!(old_status[:description], old_status[:emoji])\n          user1.reload\n\n          new_status = { emoji: \"surfing_man\", description: \"surfing\" }\n          put \"/u/#{user1.username}.json\", params: { status: new_status }\n          expect(response.status).to eq(403)\n\n          user1.reload\n          expect(user1.user_status).not_to be_nil\n          expect(user1.user_status.emoji).to eq(old_status[:emoji])\n          expect(user1.user_status.description).to eq(old_status[:description])\n        end\n\n        it \"can't clear status of another user\" do\n          user1.set_status!(\"off to dentist\", \"tooth\")\n          user1.reload\n\n          put \"/u/#{user1.username}.json\", params: { status: nil }\n          expect(response.status).to eq(403)\n\n          user1.reload\n          expect(user1.user_status).not_to be_nil\n        end\n\n        it \"doesn't clear user status if it wasn't sent in the payload\" do\n          new_status = { emoji: \"tooth\", description: \"off to dentist\" }\n          user.set_status!(new_status[:description], new_status[:emoji])\n          user.reload\n\n          put \"/u/#{user.username}.json\", params: { bio_raw: \"new bio\" }\n          expect(response.status).to eq(200)\n\n          user.reload\n          expect(user.user_status).not_to be_nil\n          expect(user.user_status.emoji).to eq(new_status[:emoji])\n          expect(user.user_status.description).to eq(new_status[:description])\n        end\n\n        context \"when user status is disabled\" do\n          before { SiteSetting.enable_user_status = false }\n\n          it \"doesn't set user status\" do\n            put \"/u/#{user.username}.json\",\n                params: {\n                  status: {\n                    emoji: \"tooth\",\n                    description: \"off to dentist\",\n                  },\n                }\n            expect(response.status).to eq(200)\n\n            user.reload\n            expect(user.user_status).to be_nil\n          end\n\n          it \"doesn't update user status\" do\n            old_status = { emoji: \"tooth\", description: \"off to dentist\" }\n            user.set_status!(old_status[:description], old_status[:emoji])\n            user.reload\n\n            new_status = { emoji: \"surfing_man\", description: \"surfing\" }\n            put \"/u/#{user.username}.json\", params: { status: new_status }\n            expect(response.status).to eq(200)\n\n            user.reload\n            expect(user.user_status).not_to be_nil\n            expect(user.user_status.emoji).to eq(old_status[:emoji])\n            expect(user.user_status.description).to eq(old_status[:description])\n          end\n\n          it \"doesn't clear user status\" do\n            user.set_status!(\"off to dentist\", \"tooth\")\n            user.reload\n\n            put \"/u/#{user.username}.json\", params: { status: nil }\n            expect(response.status).to eq(200)\n\n            user.reload\n            expect(user.user_status).not_to be_nil\n          end\n        end\n      end\n\n      context \"as a staff user\" do\n        before do\n          SiteSetting.enable_user_status = true\n          sign_in(moderator)\n        end\n\n        it \"sets another user's status\" do\n          status = { emoji: \"tooth\", description: \"off to dentist\" }\n\n          put \"/u/#{user.username}.json\", params: { status: status }\n          expect(response.status).to eq(200)\n\n          user.reload\n          expect(user.user_status).not_to be_nil\n          expect(user.user_status.emoji).to eq(status[:emoji])\n          expect(user.user_status.description).to eq(status[:description])\n        end\n\n        it \"updates another user's status\" do\n          user.set_status!(\"off to dentist\", \"tooth\")\n          user.reload\n\n          new_status = { emoji: \"surfing_man\", description: \"surfing\" }\n          put \"/u/#{user.username}.json\", params: { status: new_status }\n          expect(response.status).to eq(200)\n\n          user.reload\n          expect(user.user_status).not_to be_nil\n          expect(user.user_status.emoji).to eq(new_status[:emoji])\n          expect(user.user_status.description).to eq(new_status[:description])\n        end\n\n        it \"clears another user's status\" do\n          user.set_status!(\"off to dentist\", \"tooth\")\n          user.reload\n\n          put \"/u/#{user.username}.json\", params: { status: nil }\n          expect(response.status).to eq(200)\n\n          user.reload\n          expect(user.user_status).to be_nil\n        end\n      end\n    end\n\n    context \"when a plugin introduces a users_controller_update_user_params modifier\" do\n      before { sign_in(user) }\n\n      after { DiscoursePluginRegistry.clear_modifiers! }\n\n      it \"allows the plugin to modify the user params\" do\n        block_called = false\n\n        plugin = Plugin::Instance.new\n        plugin.register_modifier(\n          :users_controller_update_user_params,\n        ) do |result, current_user, params|\n          block_called = true\n          expect(current_user.id).to eq(user.id)\n          result[:location] = params[:plugin_location_alias]\n          result\n        end\n\n        put \"/u/#{user.username}.json\", params: { location: \"abc\", plugin_location_alias: \"xyz\" }\n\n        expect(response.status).to eq(200)\n        expect(user.reload.user_profile.location).to eq(\"xyz\")\n        expect(block_called).to eq(true)\n      end\n    end\n  end\n\n  describe \"#badge_title\" do\n    fab!(:badge) { Fabricate(:badge) }\n    let(:user_badge) { BadgeGranter.grant(badge, user1) }\n\n    it \"sets the user's title to the badge name if it is titleable\" do\n      sign_in(user1)\n\n      put \"/u/#{user1.username}/preferences/badge_title.json\",\n          params: {\n            user_badge_id: user_badge.id,\n          }\n\n      expect(user1.reload.title).not_to eq(badge.display_name)\n      badge.update allow_title: true\n\n      put \"/u/#{user1.username}/preferences/badge_title.json\",\n          params: {\n            user_badge_id: user_badge.id,\n          }\n\n      expect(user1.reload.title).to eq(badge.display_name)\n      expect(user1.user_profile.granted_title_badge_id).to eq(badge.id)\n\n      badge.update allow_title: false\n\n      put \"/u/#{user1.username}/preferences/badge_title.json\",\n          params: {\n            user_badge_id: user_badge.id,\n          }\n\n      user1.reload\n      user1.user_profile.reload\n      expect(user1.title).to eq(\"\")\n      expect(user1.user_profile.granted_title_badge_id).to eq(nil)\n    end\n\n    it \"is not raising an erroring when user revokes title\" do\n      sign_in(user1)\n      badge.update allow_title: true\n      put \"/u/#{user1.username}/preferences/badge_title.json\",\n          params: {\n            user_badge_id: user_badge.id,\n          }\n      put \"/u/#{user1.username}/preferences/badge_title.json\", params: { user_badge_id: 0 }\n      expect(response.status).to eq(200)\n    end\n\n    context \"with overridden name\" do\n      fab!(:badge) { Fabricate(:badge, name: \"Demogorgon\", allow_title: true) }\n      let(:user_badge) { BadgeGranter.grant(badge, user1) }\n\n      before { TranslationOverride.upsert!(\"en\", \"badges.demogorgon.name\", \"Boss\") }\n\n      after { TranslationOverride.revert!(\"en\", [\"badges.demogorgon.name\"]) }\n\n      it \"uses the badge display name as user title\" do\n        sign_in(user1)\n\n        put \"/u/#{user1.username}/preferences/badge_title.json\",\n            params: {\n              user_badge_id: user_badge.id,\n            }\n        expect(user1.reload.title).to eq(badge.display_name)\n      end\n    end\n  end\n\n  describe \"#send_activation_email\" do\n    before do\n      UsersController.any_instance.stubs(:honeypot_value).returns(nil)\n      UsersController.any_instance.stubs(:challenge_value).returns(nil)\n    end\n\n    let(:post_user) do\n      post \"/u.json\",\n           params: {\n             username: \"osamatest\",\n             password: \"strongpassword\",\n             email: \"dsdsds@sasa.com\",\n           }\n\n      User.find_by(username: \"osamatest\")\n    end\n\n    context \"for an existing user\" do\n      context \"for an activated account with email confirmed\" do\n        it \"fails\" do\n          user = post_user\n          email_token = Fabricate(:email_token, user: user).token\n          EmailToken.confirm(email_token)\n\n          post \"/u/action/send_activation_email.json\", params: { username: user.username }\n\n          expect(response.status).to eq(409)\n          expect(response.parsed_body[\"errors\"]).to include(I18n.t(\"activation.activated\"))\n          expect(session[SessionController::ACTIVATE_USER_KEY]).to eq(nil)\n        end\n      end\n\n      context \"for an activated account with unconfirmed email\" do\n        it \"should send an email\" do\n          user = post_user\n          user.update!(active: true)\n          Fabricate(:email_token, user: user)\n\n          expect_enqueued_with(\n            job: :critical_user_email,\n            args: {\n              type: :signup,\n              to_address: user.email,\n            },\n          ) { post \"/u/action/send_activation_email.json\", params: { username: user.username } }\n\n          expect(response.status).to eq(200)\n\n          expect(session[SessionController::ACTIVATE_USER_KEY]).to eq(nil)\n        end\n      end\n\n      context \"when approval is enabled\" do\n        before { SiteSetting.must_approve_users = true }\n\n        it \"should raise an error\" do\n          user = post_user\n          user.update(active: true)\n          user.save!\n          Fabricate(:email_token, user: user1)\n          post \"/u/action/send_activation_email.json\", params: { username: user.username }\n\n          expect(response.status).to eq(403)\n        end\n      end\n\n      describe \"when user does not have a valid session\" do\n        it \"should not be valid\" do\n          post \"/u/action/send_activation_email.json\", params: { username: user.username }\n          expect(response.status).to eq(403)\n        end\n\n        it \"should allow staff regardless\" do\n          sign_in(admin)\n          user = Fabricate(:user, active: false)\n          post \"/u/action/send_activation_email.json\", params: { username: user.username }\n          expect(response.status).to eq(200)\n        end\n      end\n\n      context \"with a valid email_token\" do\n        it \"should send the activation email\" do\n          user = post_user\n\n          expect_enqueued_with(job: :critical_user_email, args: { type: :signup }) do\n            post \"/u/action/send_activation_email.json\", params: { username: user.username }\n          end\n\n          expect(response.status).to eq(200)\n          expect(session[SessionController::ACTIVATE_USER_KEY]).to eq(nil)\n        end\n      end\n\n      context \"without an existing email_token\" do\n        let(:user) { post_user }\n        before do\n          user.email_tokens.each { |t| t.destroy }\n          user.reload\n        end\n\n        it \"should generate a new token\" do\n          expect {\n            post \"/u/action/send_activation_email.json\", params: { username: user.username }\n          }.to change { user.reload.email_tokens.count }.by(1)\n        end\n\n        it \"should send an email\" do\n          expect do\n            post \"/u/action/send_activation_email.json\", params: { username: user.username }\n          end.to change { Jobs::CriticalUserEmail.jobs.size }.by(1)\n\n          expect(session[SessionController::ACTIVATE_USER_KEY]).to eq(nil)\n        end\n      end\n    end\n\n    context \"when username does not exist\" do\n      it \"should not send an email\" do\n        post \"/u/action/send_activation_email.json\", params: { username: \"nopenopenopenope\" }\n        expect(response.status).to eq(404)\n        expect(Jobs::CriticalUserEmail.jobs.size).to eq(0)\n      end\n    end\n  end\n\n  describe \"#pick_avatar\" do\n    it \"raises an error when not logged in\" do\n      put \"/u/asdf/preferences/avatar/pick.json\", params: { avatar_id: 1, type: \"custom\" }\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      before { sign_in(user1) }\n\n      fab!(:upload) { Fabricate(:upload, user: user1) }\n\n      it \"raises an error when you don't have permission to toggle the avatar\" do\n        put \"/u/#{another_user.username}/preferences/avatar/pick.json\",\n            params: {\n              upload_id: upload.id,\n              type: \"custom\",\n            }\n\n        expect(response).to be_forbidden\n      end\n\n      it \"raises an error when discourse_connect_overrides_avatar is disabled\" do\n        SiteSetting.discourse_connect_overrides_avatar = true\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\",\n            params: {\n              upload_id: upload.id,\n              type: \"custom\",\n            }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"raises an error when selecting the custom/uploaded avatar and allow_uploaded_avatars is disabled\" do\n        SiteSetting.allow_uploaded_avatars = \"disabled\"\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\",\n            params: {\n              upload_id: upload.id,\n              type: \"custom\",\n            }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"raises an error when selecting the custom/uploaded avatar and allow_uploaded_avatars is admin\" do\n        SiteSetting.allow_uploaded_avatars = \"admin\"\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\",\n            params: {\n              upload_id: upload.id,\n              type: \"custom\",\n            }\n        expect(response.status).to eq(422)\n\n        user1.update!(admin: true)\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\",\n            params: {\n              upload_id: upload.id,\n              type: \"custom\",\n            }\n        expect(response.status).to eq(200)\n      end\n\n      it \"raises an error when selecting the custom/uploaded avatar and allow_uploaded_avatars is staff\" do\n        SiteSetting.allow_uploaded_avatars = \"staff\"\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\",\n            params: {\n              upload_id: upload.id,\n              type: \"custom\",\n            }\n        expect(response.status).to eq(422)\n\n        user1.update!(moderator: true)\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\",\n            params: {\n              upload_id: upload.id,\n              type: \"custom\",\n            }\n        expect(response.status).to eq(200)\n      end\n\n      it \"raises an error when selecting the custom/uploaded avatar and allow_uploaded_avatars is a trust level\" do\n        SiteSetting.allow_uploaded_avatars = \"3\"\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\",\n            params: {\n              upload_id: upload.id,\n              type: \"custom\",\n            }\n        expect(response.status).to eq(422)\n\n        user1.update!(trust_level: 3)\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\",\n            params: {\n              upload_id: upload.id,\n              type: \"custom\",\n            }\n        expect(response.status).to eq(200)\n      end\n\n      it \"ignores the upload if picking a system avatar\" do\n        SiteSetting.allow_uploaded_avatars = \"disabled\"\n        another_upload = Fabricate(:upload)\n\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\",\n            params: {\n              upload_id: another_upload.id,\n              type: \"system\",\n            }\n\n        expect(response.status).to eq(200)\n        expect(user1.reload.uploaded_avatar_id).to eq(nil)\n      end\n\n      it \"raises an error if the type is invalid\" do\n        SiteSetting.allow_uploaded_avatars = \"disabled\"\n        another_upload = Fabricate(:upload)\n\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\",\n            params: {\n              upload_id: another_upload.id,\n              type: \"x\",\n            }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"can successfully pick the system avatar\" do\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\"\n\n        expect(response.status).to eq(200)\n        expect(user1.reload.uploaded_avatar_id).to eq(nil)\n      end\n\n      it \"disables the use_site_small_logo_as_system_avatar setting when picking an avatar for the system user\" do\n        system_user = Discourse.system_user\n        SiteSetting.use_site_small_logo_as_system_avatar = true\n        another_upload = Fabricate(:upload, user: system_user)\n        sign_in(system_user)\n\n        put \"/u/#{system_user.username}/preferences/avatar/pick.json\",\n            params: {\n              upload_id: another_upload.id,\n              type: \"uploaded\",\n            }\n\n        expect(response.status).to eq(200)\n        expect(SiteSetting.use_site_small_logo_as_system_avatar).to eq(false)\n      end\n\n      it \"can successfully pick a gravatar\" do\n        user1.user_avatar.update_columns(gravatar_upload_id: upload.id)\n\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\",\n            params: {\n              upload_id: upload.id,\n              type: \"gravatar\",\n            }\n\n        expect(response.status).to eq(200)\n        expect(user1.reload.uploaded_avatar_id).to eq(upload.id)\n        expect(user1.user_avatar.reload.gravatar_upload_id).to eq(upload.id)\n      end\n\n      it \"can not pick uploads that were not created by user\" do\n        upload2 = Fabricate(:upload)\n\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\",\n            params: {\n              upload_id: upload2.id,\n              type: \"custom\",\n            }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"can successfully pick a custom avatar\" do\n        events =\n          DiscourseEvent.track_events do\n            put \"/u/#{user1.username}/preferences/avatar/pick.json\",\n                params: {\n                  upload_id: upload.id,\n                  type: \"custom\",\n                }\n          end\n\n        expect(events.map { |event| event[:event_name] }).to include(:user_updated)\n        expect(response.status).to eq(200)\n        expect(user1.reload.uploaded_avatar_id).to eq(upload.id)\n        expect(user1.user_avatar.reload.custom_upload_id).to eq(upload.id)\n      end\n    end\n  end\n\n  describe \"#select_avatar\" do\n    it \"raises an error when not logged in\" do\n      put \"/u/asdf/preferences/avatar/select.json\", params: { url: \"https://meta.discourse.org\" }\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      before { sign_in(user1) }\n\n      fab!(:avatar1) { Fabricate(:upload) }\n      fab!(:avatar2) { Fabricate(:upload) }\n      let(:url) { \"https://www.discourse.org\" }\n\n      it \"raises an error when url is blank\" do\n        put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: \"\" }\n        expect(response.status).to eq(422)\n      end\n\n      it \"raises an error when selectable avatars is disabled\" do\n        put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: url }\n        expect(response.status).to eq(422)\n      end\n\n      context \"when selectable avatars is enabled\" do\n        before do\n          SiteSetting.selectable_avatars = [avatar1, avatar2]\n          SiteSetting.selectable_avatars_mode = \"no_one\"\n        end\n\n        it \"raises an error when selectable avatars is empty\" do\n          SiteSetting.selectable_avatars = \"\"\n          put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: url }\n          expect(response.status).to eq(422)\n        end\n\n        context \"when selectable avatars is properly setup\" do\n          it \"raises an error when url is not in selectable avatars list\" do\n            put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: url }\n            expect(response.status).to eq(422)\n          end\n\n          it \"can successfully select an avatar\" do\n            events =\n              DiscourseEvent.track_events do\n                put \"/u/#{user1.username}/preferences/avatar/select.json\",\n                    params: {\n                      url: avatar1.url,\n                    }\n              end\n\n            expect(events.map { |event| event[:event_name] }).to include(:user_updated)\n            expect(response.status).to eq(200)\n            expect(user1.reload.uploaded_avatar_id).to eq(avatar1.id)\n            expect(user1.user_avatar.reload.custom_upload_id).to eq(avatar1.id)\n          end\n\n          it \"can successfully select an avatar using a cooked URL\" do\n            events =\n              DiscourseEvent.track_events do\n                put \"/u/#{user1.username}/preferences/avatar/select.json\",\n                    params: {\n                      url: UrlHelper.cook_url(avatar1.url),\n                    }\n              end\n\n            expect(events.map { |event| event[:event_name] }).to include(:user_updated)\n            expect(response.status).to eq(200)\n            expect(user1.reload.uploaded_avatar_id).to eq(avatar1.id)\n            expect(user1.user_avatar.reload.custom_upload_id).to eq(avatar1.id)\n          end\n\n          it \"disables the use_site_small_logo_as_system_avatar setting when picking an avatar for the system user\" do\n            system_user = Discourse.system_user\n            SiteSetting.use_site_small_logo_as_system_avatar = true\n            sign_in(system_user)\n\n            put \"/u/#{system_user.username}/preferences/avatar/select.json\",\n                params: {\n                  url: UrlHelper.cook_url(avatar1.url),\n                }\n\n            expect(response.status).to eq(200)\n            expect(SiteSetting.use_site_small_logo_as_system_avatar).to eq(false)\n          end\n        end\n      end\n    end\n  end\n\n  describe \"#destroy_user_image\" do\n    it \"raises an error when not logged in\" do\n      delete \"/u/asdf/preferences/user_image.json\", params: { type: \"profile_background\" }\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      before { sign_in(user1) }\n\n      it 'raises an error when you don\\'t have permission to clear the profile background' do\n        delete \"/u/#{another_user.username}/preferences/user_image.json\",\n               params: {\n                 type: \"profile_background\",\n               }\n        expect(response).to be_forbidden\n      end\n\n      it \"requires the `type` param\" do\n        delete \"/u/#{user1.username}/preferences/user_image.json\"\n        expect(response.status).to eq(400)\n      end\n\n      it \"only allows certain `types`\" do\n        delete \"/u/#{user1.username}/preferences/user_image.json\", params: { type: \"wat\" }\n        expect(response.status).to eq(400)\n      end\n\n      it \"can clear the profile background\" do\n        delete \"/u/#{user1.username}/preferences/user_image.json\",\n               params: {\n                 type: \"profile_background\",\n               }\n\n        expect(user1.reload.profile_background_upload).to eq(nil)\n        expect(response.status).to eq(200)\n      end\n    end\n  end\n\n  describe \"#destroy\" do\n    it \"raises an error when not logged in\" do\n      delete \"/u/nobody.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      before { sign_in(user1) }\n\n      it \"raises an error when you cannot delete your account\" do\n        UserDestroyer.any_instance.expects(:destroy).never\n        stat = user1.user_stat\n        stat.post_count = 3\n        stat.save!\n        delete \"/u/#{user1.username}.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"raises an error when you try to delete someone else's account\" do\n        UserDestroyer.any_instance.expects(:destroy).never\n        delete \"/u/#{another_user.username}.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"deletes your account when you're allowed to\" do\n        UserDestroyer.any_instance.expects(:destroy).with(user1, anything).returns(user1)\n        delete \"/u/#{user1.username}.json\"\n        expect(response.status).to eq(200)\n      end\n    end\n  end\n\n  describe \"#notification_level\" do\n    it \"raises an error when `notification_level` param is not a valid value\" do\n      sign_in(user)\n      invalid_arg = \"invalid\"\n      put \"/u/#{user.username}/notification_level.json\", params: { notification_level: invalid_arg }\n      expect(response.status).to eq(422)\n      expect(response.parsed_body[\"errors\"].first).to eq(\n        I18n.t(\"notification_level.invalid_value\", value: invalid_arg),\n      )\n    end\n  end\n\n  describe \"#ignore\" do\n    it \"raises an error when not logged in\" do\n      put \"/u/#{user1.username}/notification_level.json\", params: { notification_level: \"\" }\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      fab!(:user) { Fabricate(:user, trust_level: 2) }\n      before { sign_in(user) }\n\n      fab!(:ignored_user) { Fabricate(:ignored_user, user: user, ignored_user: another_user) }\n      fab!(:muted_user) { Fabricate(:muted_user, user: user, muted_user: another_user) }\n\n      context \"when you can't change the notification\" do\n        fab!(:staff_user) { admin }\n\n        it \"ignoring includes a helpful error message\" do\n          put \"/u/#{staff_user.username}/notification_level.json\",\n              params: {\n                notification_level: \"ignore\",\n              }\n          expect(response.status).to eq(422)\n          expect(response.parsed_body[\"errors\"][0]).to eq(I18n.t(\"notification_level.ignore_error\"))\n        end\n\n        it \"muting includes a helpful error message\" do\n          put \"/u/#{staff_user.username}/notification_level.json\",\n              params: {\n                notification_level: \"mute\",\n              }\n          expect(response.status).to eq(422)\n          expect(response.parsed_body[\"errors\"][0]).to eq(I18n.t(\"notification_level.mute_error\"))\n        end\n      end\n\n      context \"when changing notification level to normal\" do\n        it \"changes notification level to normal\" do\n          put \"/u/#{another_user.username}/notification_level.json\",\n              params: {\n                notification_level: \"normal\",\n              }\n          expect(IgnoredUser.count).to eq(0)\n          expect(MutedUser.count).to eq(0)\n        end\n      end\n\n      context \"when changing notification level to mute\" do\n        it \"changes notification level to mute\" do\n          put \"/u/#{another_user.username}/notification_level.json\",\n              params: {\n                notification_level: \"mute\",\n              }\n          expect(IgnoredUser.count).to eq(0)\n          expect(MutedUser.find_by(user_id: user.id, muted_user_id: another_user.id)).to be_present\n        end\n      end\n\n      context \"when changing notification level to ignore\" do\n        it \"changes notification level to ignore\" do\n          put \"/u/#{another_user.username}/notification_level.json\",\n              params: {\n                notification_level: \"ignore\",\n                expiring_at: 3.days.from_now,\n              }\n          expect(response.status).to eq(200)\n          expect(MutedUser.count).to eq(0)\n          expect(\n            IgnoredUser.find_by(user_id: user.id, ignored_user_id: another_user.id),\n          ).to be_present\n        end\n\n        it \"allows admin to change the ignore status for a source user\" do\n          ignored_user.destroy!\n          sign_in(Fabricate(:user, admin: true))\n          put \"/u/#{another_user.username}/notification_level.json\",\n              params: {\n                notification_level: \"ignore\",\n                acting_user_id: user.id,\n                expiring_at: 3.days.from_now,\n              }\n          expect(response.status).to eq(200)\n          expect(\n            IgnoredUser.find_by(user_id: user.id, ignored_user_id: another_user.id),\n          ).to be_present\n        end\n\n        it \"does not allow a regular user to change the ignore status for anyone but themself\" do\n          ignored_user.destroy!\n          acting_user = Fabricate(:user)\n          put \"/u/#{another_user.username}/notification_level.json\",\n              params: {\n                notification_level: \"ignore\",\n                acting_user_id: acting_user.id,\n                expiring_at: 3.days.from_now,\n              }\n          expect(response.status).to eq(422)\n          expect(\n            IgnoredUser.find_by(user_id: acting_user.id, ignored_user_id: another_user.id),\n          ).to eq(nil)\n\n          put \"/u/#{another_user.username}/notification_level.json\",\n              params: {\n                notification_level: \"ignore\",\n                expiring_at: 3.days.from_now,\n              }\n          expect(response.status).to eq(200)\n          expect(\n            IgnoredUser.find_by(user_id: user.id, ignored_user_id: another_user.id),\n          ).to be_present\n        end\n\n        context \"when expiring_at param is set\" do\n          it \"changes notification level to ignore\" do\n            freeze_time(Time.now) do\n              expiring_at = 3.days.from_now\n              put \"/u/#{another_user.username}/notification_level.json\",\n                  params: {\n                    notification_level: \"ignore\",\n                    expiring_at: expiring_at,\n                  }\n\n              ignored_user = IgnoredUser.find_by(user_id: user.id, ignored_user_id: another_user.id)\n              expect(ignored_user).to be_present\n              expect(ignored_user.expiring_at.to_i).to eq(expiring_at.to_i)\n              expect(MutedUser.count).to eq(0)\n            end\n          end\n        end\n      end\n    end\n  end\n\n  describe \"for user with period in username\" do\n    fab!(:user_with_period) { Fabricate(:user, username: \"myname.test\") }\n\n    it \"still works\" do\n      sign_in(user_with_period)\n      UserDestroyer\n        .any_instance\n        .expects(:destroy)\n        .with(user_with_period, anything)\n        .returns(user_with_period)\n      delete \"/u/#{user_with_period.username}\", xhr: true\n      expect(response.status).to eq(200)\n    end\n  end\n\n  describe \"#my_redirect\" do\n    it \"redirects if the user is not logged in\" do\n      get \"/my/wat\"\n      expect(response).to redirect_to(\"/login-preferences\")\n      expect(response.cookies).to have_key(\"destination_url\")\n      expect(response.cookies[\"destination_url\"]).to eq(\"/my/wat\")\n      expect(response.headers[\"X-Robots-Tag\"]).to eq(\"noindex\")\n    end\n\n    context \"when the user is logged in\" do\n      before { sign_in(user1) }\n\n      it \"will not redirect to an invalid path\" do\n        get \"/my/wat/..password.txt\"\n        expect(response).not_to be_redirect\n      end\n\n      it \"will redirect to an valid path\" do\n        get \"/my/preferences\"\n        expect(response).to redirect_to(\"/u/#{user1.username}/preferences\")\n      end\n\n      it \"permits forward slashes\" do\n        get \"/my/activity/posts\"\n        expect(response).to redirect_to(\"/u/#{user1.username}/activity/posts\")\n      end\n\n      it \"correctly redirects for Unicode usernames\" do\n        SiteSetting.unicode_usernames = true\n        user = sign_in(Fabricate(:unicode_user))\n\n        get \"/my/preferences\"\n        expect(response).to redirect_to(\"/u/#{user.encoded_username}/preferences\")\n      end\n    end\n  end\n\n  describe \"#check_emails\" do\n    it \"raises an error when not logged in\" do\n      get \"/u/zogstrip/emails.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      let(:sign_in_admin) { sign_in(admin) }\n\n      it \"raises an error when you aren't allowed to check emails\" do\n        sign_in(Fabricate(:user))\n        get \"/u/#{Fabricate(:user).username}/emails.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"returns emails and associated_accounts for self\" do\n        Fabricate(:email_change_request, user: user1)\n        sign_in(user)\n\n        get \"/u/#{user.username}/emails.json\"\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"email\"]).to eq(user.email)\n        expect(json[\"secondary_emails\"]).to eq(user.secondary_emails)\n        expect(json[\"unconfirmed_emails\"]).to eq(user.unconfirmed_emails)\n        expect(json[\"associated_accounts\"]).to eq([])\n      end\n\n      it \"returns emails and associated_accounts when you're allowed to see them\" do\n        Fabricate(:email_change_request, user: user1)\n        sign_in_admin\n\n        get \"/u/#{user.username}/emails.json\"\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"email\"]).to eq(user.email)\n        expect(json[\"secondary_emails\"]).to eq(user.secondary_emails)\n        expect(json[\"unconfirmed_emails\"]).to eq(user.unconfirmed_emails)\n        expect(json[\"associated_accounts\"]).to eq([])\n      end\n\n      it \"works on inactive users\" do\n        inactive_user = Fabricate(:user, active: false)\n        Fabricate(:email_change_request, user: inactive_user)\n        sign_in_admin\n\n        get \"/u/#{inactive_user.username}/emails.json\"\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"email\"]).to eq(inactive_user.email)\n        expect(json[\"secondary_emails\"]).to eq(inactive_user.secondary_emails)\n        expect(json[\"unconfirmed_emails\"]).to eq(inactive_user.unconfirmed_emails)\n        expect(json[\"associated_accounts\"]).to eq([])\n      end\n    end\n  end\n\n  describe \"#check_sso_email\" do\n    it \"raises an error when not logged in\" do\n      get \"/u/zogstrip/sso-email.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      let(:sign_in_admin) { sign_in(admin) }\n\n      it \"raises an error when you aren't allowed to check sso email\" do\n        sign_in(Fabricate(:user))\n        get \"/u/#{user1.username}/sso-email.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"returns emails and associated_accounts when you're allowed to see them\" do\n        user1.single_sign_on_record =\n          SingleSignOnRecord.create(\n            user_id: user1.id,\n            external_email: \"foobar@example.com\",\n            external_id: \"example\",\n            last_payload: \"looks good\",\n          )\n        sign_in_admin\n\n        get \"/u/#{user1.username}/sso-email.json\"\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"email\"]).to eq(\"foobar@example.com\")\n      end\n    end\n  end\n\n  describe \"#check_sso_payload\" do\n    it \"raises an error when not logged in\" do\n      get \"/u/zogstrip/sso-payload.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      let(:sign_in_admin) { sign_in(admin) }\n\n      it \"raises an error when you aren't allowed to check sso payload\" do\n        sign_in(Fabricate(:user))\n        get \"/u/#{user1.username}/sso-payload.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"returns SSO payload when you're allowed to see\" do\n        user1.single_sign_on_record =\n          SingleSignOnRecord.create(\n            user_id: user1.id,\n            external_email: \"foobar@example.com\",\n            external_id: \"example\",\n            last_payload: \"foobar\",\n          )\n        sign_in_admin\n\n        get \"/u/#{user1.username}/sso-payload.json\"\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"payload\"]).to eq(\"foobar\")\n      end\n    end\n  end\n\n  describe \"#update_primary_email\" do\n    let(:user_email) { user1.primary_email }\n    fab!(:other_email) { Fabricate(:secondary_email, user: user1) }\n\n    before do\n      SiteSetting.email_editable = true\n\n      sign_in(user1)\n    end\n\n    it \"changes user's primary email\" do\n      put \"/u/#{user1.username}/preferences/primary-email.json\", params: { email: user_email.email }\n      expect(response.status).to eq(200)\n      expect(user_email.reload.primary).to eq(true)\n      expect(other_email.reload.primary).to eq(false)\n\n      event =\n        DiscourseEvent\n          .track_events do\n            expect {\n              put \"/u/#{user1.username}/preferences/primary-email.json\",\n                  params: {\n                    email: other_email.email,\n                  }\n            }.to change {\n              UserHistory.where(\n                action: UserHistory.actions[:update_email],\n                acting_user_id: user1.id,\n              ).count\n            }.by(1)\n          end\n          .last\n\n      expect(response.status).to eq(200)\n      expect(user_email.reload.primary).to eq(false)\n      expect(other_email.reload.primary).to eq(true)\n\n      expect(event[:event_name]).to eq(:user_updated)\n      expect(event[:params].first).to eq(user1)\n    end\n  end\n\n  describe \"#destroy_email\" do\n    fab!(:user_email) { user1.primary_email }\n    fab!(:other_email) { Fabricate(:secondary_email, user: user1) }\n\n    before do\n      SiteSetting.email_editable = true\n\n      sign_in(user1)\n    end\n\n    it \"can destroy secondary emails\" do\n      delete \"/u/#{user1.username}/preferences/email.json\", params: { email: user_email.email }\n      expect(response.status).to eq(428)\n      expect(user1.reload.user_emails.pluck(:email)).to contain_exactly(\n        user_email.email,\n        other_email.email,\n      )\n\n      event =\n        DiscourseEvent\n          .track_events do\n            expect {\n              delete \"/u/#{user1.username}/preferences/email.json\",\n                     params: {\n                       email: other_email.email,\n                     }\n            }.to change {\n              UserHistory.where(\n                action: UserHistory.actions[:destroy_email],\n                acting_user_id: user1.id,\n              ).count\n            }.by(1)\n          end\n          .last\n\n      expect(response.status).to eq(200)\n      expect(user1.reload.user_emails.pluck(:email)).to contain_exactly(user_email.email)\n\n      expect(event[:event_name]).to eq(:user_updated)\n      expect(event[:params].first).to eq(user1)\n    end\n\n    it \"can destroy unconfirmed emails\" do\n      request_1 =\n        EmailChangeRequest.create!(\n          user: user1,\n          new_email: user_email.email,\n          change_state: EmailChangeRequest.states[:authorizing_new],\n        )\n\n      EmailChangeRequest.create!(\n        user: user1,\n        new_email: other_email.email,\n        change_state: EmailChangeRequest.states[:authorizing_new],\n      )\n\n      EmailChangeRequest.create!(\n        user: user1,\n        new_email: other_email.email,\n        change_state: EmailChangeRequest.states[:authorizing_new],\n      )\n\n      delete \"/u/#{user1.username}/preferences/email.json\", params: { email: other_email.email }\n\n      expect(user1.user_emails.pluck(:email)).to contain_exactly(\n        user_email.email,\n        other_email.email,\n      )\n      expect(user1.email_change_requests).to contain_exactly(request_1)\n    end\n\n    it \"destroys associated email tokens and email change requests\" do\n      new_email = \"new.n.cool@example.com\"\n      updater = EmailUpdater.new(guardian: user1.guardian, user: user1)\n      updater.change_to(new_email)\n\n      email_token = updater.change_req.new_email_token\n      expect(email_token).to be_present\n\n      delete \"/u/#{user1.username}/preferences/email.json\", params: { email: new_email }\n\n      expect(EmailToken.find_by(id: email_token.id)).to eq(nil)\n      expect(EmailChangeRequest.find_by(id: updater.change_req.id)).to eq(nil)\n    end\n  end\n\n  describe \"#topic_tracking_state\" do\n    context \"when anon\" do\n      it \"raises an error on anon for topic_tracking_state\" do\n        get \"/u/#{user1.username}/topic-tracking-state.json\"\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context \"when logged on\" do\n      it \"detects new topic\" do\n        sign_in(user1)\n\n        topic = Fabricate(:topic)\n        get \"/u/#{user1.username}/topic-tracking-state.json\"\n\n        expect(response.status).to eq(200)\n        states = response.parsed_body\n        expect(states[0][\"topic_id\"]).to eq(topic.id)\n      end\n    end\n  end\n\n  describe \"#summary\" do\n    it \"generates summary info\" do\n      create_post(user: user)\n\n      get \"/u/#{user.username_lower}/summary.json\"\n      expect(response.headers[\"X-Robots-Tag\"]).to eq(\"noindex\")\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n\n      expect(json[\"user_summary\"][\"topic_count\"]).to eq(1)\n      expect(json[\"user_summary\"][\"post_count\"]).to eq(0)\n    end\n\n    context \"when `hide_user_profiles_from_public` site setting is enabled\" do\n      before { SiteSetting.hide_user_profiles_from_public = true }\n\n      it \"returns 200 for logged in users\" do\n        sign_in(Fabricate(:user))\n\n        get \"/u/#{user.username_lower}/summary.json\"\n\n        expect(response.status).to eq(200)\n      end\n\n      it \"returns 403 for anonymous users\" do\n        get \"/u/#{user.username_lower}/summary.json\"\n\n        expect(response).to redirect_to \"/login\"\n      end\n    end\n\n    context \"when `hide_profile_and_presence` user option is checked\" do\n      before_all { user1.user_option.update_columns(hide_profile_and_presence: true) }\n\n      it \"returns 404\" do\n        get \"/u/#{user1.username_lower}/summary.json\"\n        expect(response.status).to eq(404)\n      end\n\n      it \"returns summary info if `allow_users_to_hide_profile` is false\" do\n        SiteSetting.allow_users_to_hide_profile = false\n\n        get \"/u/#{user1.username_lower}/summary.json\"\n        expect(response.status).to eq(200)\n      end\n    end\n\n    context \"with avatar flair in Most... sections\" do\n      it \"returns data for automatic groups flair\" do\n        liker = Fabricate(:user, admin: true, moderator: true, trust_level: 1)\n        create_and_like_post(user_deferred, liker)\n\n        get \"/u/#{user_deferred.username_lower}/summary.json\"\n        json = response.parsed_body\n\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"admin\"]).to eq(true)\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"moderator\"]).to eq(true)\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"trust_level\"]).to eq(1)\n      end\n\n      it \"returns data for flair when an icon is used\" do\n        group =\n          Fabricate(\n            :group,\n            name: \"Groupie\",\n            flair_bg_color: \"#111111\",\n            flair_color: \"#999999\",\n            flair_icon: \"icon\",\n          )\n        liker = Fabricate(:user, flair_group: group)\n        create_and_like_post(user_deferred, liker)\n\n        get \"/u/#{user_deferred.username_lower}/summary.json\"\n        json = response.parsed_body\n\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_name\"]).to eq(\"Groupie\")\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_url\"]).to eq(\"icon\")\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_bg_color\"]).to eq(\"#111111\")\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_color\"]).to eq(\"#999999\")\n      end\n\n      it \"returns data for flair when an image is used\" do\n        upload = Fabricate(:upload)\n        group = Fabricate(:group, name: \"Groupie\", flair_bg_color: \"#111111\", flair_upload: upload)\n        liker = Fabricate(:user, flair_group: group)\n        create_and_like_post(user_deferred, liker)\n\n        get \"/u/#{user_deferred.username_lower}/summary.json\"\n        json = response.parsed_body\n\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_name\"]).to eq(\"Groupie\")\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_url\"]).to eq(upload.url)\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_bg_color\"]).to eq(\"#111111\")\n      end\n\n      def create_and_like_post(likee, liker)\n        UserActionManager.enable\n        post = create_post(user: likee)\n        PostActionCreator.like(liker, post)\n      end\n    end\n  end\n\n  describe \"#confirm_admin\" do\n    it \"fails without a valid token\" do\n      get \"/u/confirm-admin/invalid-token.json\"\n      expect(response).not_to be_successful\n    end\n\n    it \"fails with a missing token\" do\n      get \"/u/confirm-admin/a0a0a0a0a0.json\"\n      expect(response).to_not be_successful\n    end\n\n    it \"succeeds with a valid code as anonymous\" do\n      ac = AdminConfirmation.new(user1, admin)\n      ac.create_confirmation\n      get \"/u/confirm-admin/#{ac.token}.json\"\n      expect(response.status).to eq(200)\n\n      user1.reload\n      expect(user1.admin?).to eq(false)\n    end\n\n    it \"succeeds with a valid code when logged in as that user\" do\n      sign_in(admin)\n\n      ac = AdminConfirmation.new(user1, admin)\n      ac.create_confirmation\n      get \"/u/confirm-admin/#{ac.token}.json\", params: { token: ac.token }\n      expect(response.status).to eq(200)\n\n      user1.reload\n      expect(user1.admin?).to eq(false)\n    end\n\n    it \"fails if you're logged in as a different account\" do\n      sign_in(admin)\n\n      ac = AdminConfirmation.new(user1, Fabricate(:admin))\n      ac.create_confirmation\n      get \"/u/confirm-admin/#{ac.token}.json\"\n      expect(response).to_not be_successful\n\n      user1.reload\n      expect(user1.admin?).to eq(false)\n    end\n\n    describe \"post\" do\n      it \"gives the user admin access when POSTed\" do\n        ac = AdminConfirmation.new(user1, admin)\n        ac.create_confirmation\n        post \"/u/confirm-admin/#{ac.token}.json\"\n        expect(response.status).to eq(200)\n\n        user1.reload\n        expect(user1.admin?).to eq(true)\n      end\n    end\n  end\n\n  describe \"#update_activation_email\" do\n    before do\n      UsersController.any_instance.stubs(:honeypot_value).returns(nil)\n      UsersController.any_instance.stubs(:challenge_value).returns(nil)\n    end\n\n    let(:post_user) do\n      post \"/u.json\",\n           params: {\n             username: \"osamatest\",\n             password: \"strongpassword\",\n             email: \"osama@example.com\",\n           }\n      user = User.where(username: \"osamatest\").first\n      user.active = false\n      user.save!\n      user\n    end\n\n    context \"with a session variable\" do\n      use_redis_snapshotting\n\n      it \"raises an error with an invalid session value\" do\n        post_user\n\n        post \"/u.json\",\n             params: {\n               username: \"osamatest2\",\n               password: \"strongpassword2\",\n               email: \"osama22@example.com\",\n             }\n        user = User.where(username: \"osamatest2\").first\n        user.destroy\n\n        put \"/u/update-activation-email.json\", params: { email: \"osamaupdated@example.com\" }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error for an active user\" do\n        user = post_user\n        user.update(active: true)\n        user.save!\n\n        put \"/u/update-activation-email.json\", params: { email: \"osama@example.com\" }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error when logged in\" do\n        sign_in(moderator)\n        post_user\n\n        put \"/u/update-activation-email.json\", params: { email: \"updatedemail@example.com\" }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error when the new email is taken\" do\n        active_user = Fabricate(:user)\n        post_user\n\n        put \"/u/update-activation-email.json\", params: { email: active_user.email }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"raises an error when the email is blocklisted\" do\n        post_user\n        SiteSetting.blocked_email_domains = \"example.com\"\n        put \"/u/update-activation-email.json\", params: { email: \"test@example.com\" }\n        expect(response.status).to eq(422)\n      end\n\n      it \"can be updated\" do\n        user = post_user\n        token = user.email_tokens.first\n\n        put \"/u/update-activation-email.json\", params: { email: \"updatedemail@example.com\" }\n\n        expect(response.status).to eq(200)\n\n        user.reload\n        expect(user.email).to eq(\"updatedemail@example.com\")\n        expect(\n          user.email_tokens.where(email: \"updatedemail@example.com\", expired: false),\n        ).to be_present\n\n        expect(EmailToken.find_by(id: token.id)).to eq(nil)\n      end\n\n      it \"tells the user to slow down after many requests\" do\n        RateLimiter.enable\n        freeze_time\n\n        user = post_user\n        token = user.email_tokens.first\n\n        6.times do |n|\n          put \"/u/update-activation-email.json\",\n              params: {\n                email: \"updatedemail#{n}@example.com\",\n              },\n              env: {\n                REMOTE_ADDR: \"1.2.3.#{n}\",\n              }\n        end\n\n        expect(response.status).to eq(429)\n      end\n    end\n\n    context \"with a username and password\" do\n      it \"raises an error with an invalid username\" do\n        put \"/u/update-activation-email.json\",\n            params: {\n              username: \"eviltrout\",\n              password: \"invalid-password\",\n              email: \"updatedemail@example.com\",\n            }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error with an invalid password\" do\n        put \"/u/update-activation-email.json\",\n            params: {\n              username: inactive_user.username,\n              password: \"invalid-password\",\n              email: \"updatedemail@example.com\",\n            }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error for an active user\" do\n        put \"/u/update-activation-email.json\",\n            params: {\n              username: Fabricate(:walter_white).username,\n              password: \"letscook\",\n              email: \"updatedemail@example.com\",\n            }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error when logged in\" do\n        sign_in(moderator)\n\n        put \"/u/update-activation-email.json\",\n            params: {\n              username: inactive_user.username,\n              password: \"qwerqwer123\",\n              email: \"updatedemail@example.com\",\n            }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error when the new email is taken\" do\n        put \"/u/update-activation-email.json\",\n            params: {\n              username: inactive_user.username,\n              password: \"qwerqwer123\",\n              email: user.email,\n            }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"can be updated\" do\n        user = inactive_user\n        token = user.email_tokens.first\n\n        put \"/u/update-activation-email.json\",\n            params: {\n              username: user.username,\n              password: \"qwerqwer123\",\n              email: \"updatedemail@example.com\",\n            }\n\n        expect(response.status).to eq(200)\n\n        user.reload\n        expect(user.email).to eq(\"updatedemail@example.com\")\n        expect(\n          user.email_tokens.where(email: \"updatedemail@example.com\", expired: false),\n        ).to be_present\n\n        expect(EmailToken.find_by(id: token.id)).to eq(nil)\n      end\n\n      it \"tells the user to slow down after many requests\" do\n        RateLimiter.enable\n        freeze_time\n\n        user = inactive_user\n        token = user.email_tokens.first\n\n        6.times do |n|\n          put \"/u/update-activation-email.json\",\n              params: {\n                username: user.username,\n                password: \"qwerqwer123\",\n                email: \"updatedemail#{n}@example.com\",\n              },\n              env: {\n                REMOTE_ADDR: \"1.2.3.#{n}\",\n              }\n        end\n\n        expect(response.status).to eq(429)\n      end\n    end\n  end\n\n  describe \"#show\" do\n    context \"when anon\" do\n      let(:user) { Discourse.system_user }\n\n      it \"returns success\" do\n        get \"/u/#{user.username}.json\"\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body[\"user\"]\n\n        expect(parsed[\"username\"]).to eq(user.username)\n        expect(parsed[\"profile_hidden\"]).to be_blank\n        expect(parsed[\"trust_level\"]).to be_present\n      end\n\n      it \"returns a hidden profile\" do\n        user.user_option.update_column(:hide_profile_and_presence, true)\n\n        get \"/u/#{user.username}.json\"\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body[\"user\"]\n\n        expect(parsed[\"username\"]).to eq(user.username)\n        expect(parsed[\"profile_hidden\"]).to eq(true)\n        expect(parsed[\"trust_level\"]).to be_blank\n      end\n\n      it \"should redirect to login page for anonymous user when profiles are hidden\" do\n        SiteSetting.hide_user_profiles_from_public = true\n        get \"/u/#{user.username}.json\"\n        expect(response).to redirect_to \"/login\"\n      end\n\n      describe \"user profile views\" do\n        it \"should track a user profile view for an anon user\" do\n          get \"/\"\n          UserProfileView.expects(:add).with(another_user.user_profile.id, request.remote_ip, nil)\n          get \"/u/#{another_user.username}.json\"\n        end\n\n        it \"skips tracking\" do\n          UserProfileView.expects(:add).never\n          get \"/u/#{user.username}.json\", params: { skip_track_visit: true }\n        end\n      end\n    end\n\n    context \"when logged in\" do\n      before { sign_in(user1) }\n\n      it \"returns success\" do\n        get \"/u/#{user1.username}.json\"\n        expect(response.status).to eq(200)\n        expect(response.headers[\"X-Robots-Tag\"]).to eq(\"noindex\")\n\n        json = response.parsed_body\n\n        expect(json[\"user\"][\"has_title_badges\"]).to eq(false)\n      end\n\n      it \"returns not found when the username doesn't exist\" do\n        get \"/u/madeuppity.json\"\n        expect(response).not_to be_successful\n      end\n\n      it \"returns not found when the user is inactive\" do\n        inactive = Fabricate(:user, active: false)\n        get \"/u/#{inactive.username}.json\"\n        expect(response).not_to be_successful\n      end\n\n      it \"returns success when show_inactive_accounts is true and user is logged in\" do\n        SiteSetting.show_inactive_accounts = true\n        inactive = Fabricate(:user, active: false)\n        get \"/u/#{inactive.username}.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"raises an error on invalid access\" do\n        Guardian.any_instance.expects(:can_see?).with(user1).returns(false)\n        get \"/u/#{user1.username}.json\"\n        expect(response).to be_forbidden\n      end\n\n      describe \"user profile views\" do\n        it \"should track a user profile view for a signed in user\" do\n          UserProfileView.expects(:add).with(\n            another_user.user_profile.id,\n            request.remote_ip,\n            user1.id,\n          )\n          get \"/u/#{another_user.username}.json\"\n        end\n\n        it \"should not track a user profile view for a user viewing his own profile\" do\n          UserProfileView.expects(:add).never\n          get \"/u/#{user1.username}.json\"\n        end\n\n        it \"skips tracking\" do\n          UserProfileView.expects(:add).never\n          get \"/u/#{user1.username}.json\", params: { skip_track_visit: true }\n        end\n      end\n\n      context \"when fetching a user by external_id\" do\n        before { user1.create_single_sign_on_record(external_id: \"997\", last_payload: \"\") }\n\n        it \"returns fetch for a matching external_id\" do\n          get \"/u/by-external/997.json\"\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"user\"][\"username\"]).to eq(user1.username)\n        end\n\n        it \"returns not found when external_id doesn't match\" do\n          get \"/u/by-external/99.json\"\n          expect(response).not_to be_successful\n        end\n\n        context \"for an external provider\" do\n          before do\n            sign_in(admin)\n            SiteSetting.enable_google_oauth2_logins = true\n            UserAssociatedAccount.create!(\n              user: user1,\n              provider_uid: \"myuid\",\n              provider_name: \"google_oauth2\",\n            )\n          end\n\n          it \"doesn't work for non-admin\" do\n            sign_in(user1)\n            get \"/u/by-external/google_oauth2/myuid.json\"\n            expect(response.status).to eq(403)\n          end\n\n          it \"can fetch the user\" do\n            get \"/u/by-external/google_oauth2/myuid.json\"\n            expect(response.status).to eq(200)\n            expect(response.parsed_body[\"user\"][\"username\"]).to eq(user1.username)\n          end\n\n          it \"fails for disabled provider\" do\n            SiteSetting.enable_google_oauth2_logins = false\n            get \"/u/by-external/google_oauth2/myuid.json\"\n            expect(response.status).to eq(404)\n          end\n\n          it \"returns 404 for missing user\" do\n            get \"/u/by-external/google_oauth2/myotheruid.json\"\n            expect(response.status).to eq(404)\n          end\n        end\n      end\n\n      describe \"include_post_count_for\" do\n        fab!(:topic) { Fabricate(:topic) }\n\n        before_all do\n          Fabricate(:post, user: user1, topic: topic)\n          Fabricate(:post, user: admin, topic: topic)\n          Fabricate(:post, user: admin, topic: topic, post_type: Post.types[:whisper])\n        end\n\n        it \"includes only visible posts\" do\n          get \"/u/#{admin.username}.json\", params: { include_post_count_for: topic.id }\n          topic_post_count = response.parsed_body.dig(\"user\", \"topic_post_count\")\n          expect(topic_post_count[topic.id.to_s]).to eq(1)\n        end\n\n        it \"doesn't include the post count when the signed in user doesn't have access\" do\n          c = Fabricate(:category, read_restricted: true)\n          topic.update(category_id: c.id)\n          expect(Guardian.new(user1).can_see?(topic)).to eq(false)\n          get \"/u/#{admin.username}.json\", params: { include_post_count_for: topic.id }\n          topic_post_count = response.parsed_body.dig(\"user\", \"topic_post_count\")\n          expect(topic_post_count).to eq(nil)\n        end\n\n        it \"includes all post types for staff members\" do\n          SiteSetting.whispers_allowed_groups = \"#{Group::AUTO_GROUPS[:staff]}\"\n          sign_in(admin)\n\n          get \"/u/#{admin.username}.json\", params: { include_post_count_for: topic.id }\n          topic_post_count = response.parsed_body.dig(\"user\", \"topic_post_count\")\n          expect(topic_post_count[topic.id.to_s]).to eq(2)\n        end\n      end\n    end\n\n    it \"should be able to view a user\" do\n      get \"/u/#{user1.username}\"\n\n      expect(response.status).to eq(200)\n      expect(response.body).to include(user1.username)\n    end\n\n    it \"should not be able to view a private user profile\" do\n      user1.user_profile.update!(bio_raw: \"Hello world!\")\n      user1.user_option.update!(hide_profile_and_presence: true)\n\n      get \"/u/#{user1.username}\"\n\n      expect(response.status).to eq(200)\n      expect(response.body).not_to include(\"Hello world!\")\n    end\n\n    describe \"when username contains a period\" do\n      before_all { user1.update!(username: \"test.test\") }\n\n      it \"should be able to view a user\" do\n        get \"/u/#{user1.username}\"\n\n        expect(response.status).to eq(200)\n        expect(response.body).to include(user1.username)\n      end\n    end\n  end\n\n  describe \"#show_card\" do\n    context \"when anon\" do\n      let(:user) { Discourse.system_user }\n\n      it \"returns success\" do\n        get \"/u/#{user.username}/card.json\"\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body[\"user\"]\n\n        expect(parsed[\"username\"]).to eq(user.username)\n        expect(parsed[\"profile_hidden\"]).to be_blank\n        expect(parsed[\"trust_level\"]).to be_present\n      end\n\n      it \"should redirect to login page for anonymous user when profiles are hidden\" do\n        SiteSetting.hide_user_profiles_from_public = true\n        get \"/u/#{user.username}/card.json\"\n        expect(response).to redirect_to \"/login\"\n      end\n    end\n\n    context \"when logged in\" do\n      before { sign_in(user1) }\n\n      it \"works correctly\" do\n        get \"/u/#{user.username}/card.json\"\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n\n        expect(json[\"user\"][\"associated_accounts\"]).to eq(nil) # Not serialized in card\n        expect(json[\"user\"][\"username\"]).to eq(user.username)\n      end\n\n      it \"returns not found when the username doesn't exist\" do\n        get \"/u/madeuppity/card.json\"\n        expect(response).not_to be_successful\n      end\n\n      it \"returns partial response when inactive user\" do\n        user.update!(active: false)\n        get \"/u/#{user.username}/card.json\"\n        expect(response).to be_successful\n        expect(response.parsed_body[\"user\"][\"inactive\"]).to eq(true)\n      end\n\n      it \"returns partial response when hidden users\" do\n        user.user_option.update!(hide_profile_and_presence: true)\n        get \"/u/#{user.username}/card.json\"\n        expect(response).to be_successful\n        expect(response.parsed_body[\"user\"][\"profile_hidden\"]).to eq(true)\n      end\n\n      it \"raises an error on invalid access\" do\n        Guardian.any_instance.expects(:can_see?).with(user).returns(false)\n        get \"/u/#{user.username}/card.json\"\n        expect(response).to be_forbidden\n      end\n    end\n  end\n\n  describe \"#cards\" do\n    fab!(:user) { Discourse.system_user }\n    fab!(:user2) { Fabricate(:user) }\n\n    it \"returns success\" do\n      get \"/user-cards.json?user_ids=#{user.id},#{user2.id}\"\n      expect(response.status).to eq(200)\n      parsed = response.parsed_body[\"users\"]\n\n      expect(parsed.map { |u| u[\"username\"] }).to contain_exactly(user.username, user2.username)\n    end\n\n    it \"should redirect to login page for anonymous user when profiles are hidden\" do\n      SiteSetting.hide_user_profiles_from_public = true\n      get \"/user-cards.json?user_ids=#{user.id},#{user2.id}\"\n      expect(response).to redirect_to \"/login\"\n    end\n\n    context \"when `hide_profile_and_presence` user option is checked\" do\n      before { user2.user_option.update_columns(hide_profile_and_presence: true) }\n\n      it \"does not include hidden profiles\" do\n        get \"/user-cards.json?user_ids=#{user.id},#{user2.id}\"\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body[\"users\"]\n\n        expect(parsed.map { |u| u[\"username\"] }).to contain_exactly(user.username)\n      end\n\n      it \"does include hidden profiles when `allow_users_to_hide_profile` is false\" do\n        SiteSetting.allow_users_to_hide_profile = false\n\n        get \"/user-cards.json?user_ids=#{user.id},#{user2.id}\"\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body[\"users\"]\n\n        expect(parsed.map { |u| u[\"username\"] }).to contain_exactly(user.username, user2.username)\n      end\n    end\n  end\n\n  describe \"#badges\" do\n    it \"renders fine by default\" do\n      get \"/u/#{user1.username}/badges\"\n      expect(response.status).to eq(200)\n    end\n\n    it \"fails if badges are disabled\" do\n      SiteSetting.enable_badges = false\n      get \"/u/#{user1.username}/badges\"\n      expect(response.status).to eq(404)\n    end\n  end\n\n  describe \"#account_created\" do\n    it \"returns a message when no session is present\" do\n      get \"/u/account-created\"\n\n      expect(response.status).to eq(200)\n\n      body = response.body\n\n      expect(body).to match(I18n.t(\"activation.missing_session\"))\n    end\n\n    it \"redirects when the user is logged in\" do\n      sign_in(user1)\n\n      get \"/u/account-created\"\n\n      expect(response).to redirect_to(\"/\")\n    end\n\n    context \"when cookies contains a destination URL\" do\n      it \"should redirect to the URL\" do\n        sign_in(user1)\n\n        destination_url = \"http://thisisasite.com/somepath\"\n        cookies[:destination_url] = destination_url\n\n        get \"/u/account-created\"\n\n        expect(response).to redirect_to(destination_url)\n      end\n    end\n\n    context \"when the user account is created\" do\n      include ApplicationHelper\n\n      it \"returns the message when set in the session\" do\n        user1 = create_user\n        get \"/u/account-created\"\n\n        expect(response.status).to eq(200)\n\n        expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n          json = JSON.parse(element.current_scope.attribute(\"data-preloaded\").value)\n          expect(json[\"accountCreated\"]).to include(\n            \"{\\\"message\\\":\\\"#{I18n.t(\"login.activate_email\", email: user1.email).gsub!(\"</\", \"<\\\\/\")}\\\",\\\"show_controls\\\":true,\\\"username\\\":\\\"#{user1.username}\\\",\\\"email\\\":\\\"#{user1.email}\\\"}\",\n          )\n        end\n      end\n    end\n  end\n\n  describe \"#search_users\" do\n    fab!(:topic) { Fabricate :topic }\n    let(:user) { Fabricate :user, username: \"joecabot\", name: \"Lawrence Tierney\" }\n    let(:post1) { Fabricate(:post, user: user, topic: topic) }\n    let(:staged_user) { Fabricate(:user, staged: true) }\n\n    before do\n      SearchIndexer.enable\n      post1\n    end\n\n    it \"searches when provided the term only\" do\n      get \"/u/search/users.json\", params: { term: user.name.split(\" \").last }\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"users\"].map { |u| u[\"username\"] }).to include(user.username)\n    end\n\n    it \"searches when provided the topic only\" do\n      get \"/u/search/users.json\", params: { topic_id: topic.id }\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"users\"].map { |u| u[\"username\"] }).to include(user.username)\n    end\n\n    it \"searches when provided the term and topic\" do\n      get \"/u/search/users.json\", params: { term: user.name.split(\" \").last, topic_id: topic.id }\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"users\"].map { |u| u[\"username\"] }).to include(user.username)\n    end\n\n    it \"searches only for users who have access to private topic\" do\n      searching_user = Fabricate(:user)\n      privileged_user =\n        Fabricate(:user, trust_level: 4, username: \"joecabit\", name: \"Lawrence Tierney\")\n      privileged_group = Fabricate(:group)\n      privileged_group.add(searching_user)\n      privileged_group.add(privileged_user)\n      privileged_group.save\n\n      category = Fabricate(:category)\n      category.set_permissions(privileged_group => :readonly)\n      category.save\n\n      private_topic = Fabricate(:topic, category: category)\n\n      sign_in(searching_user)\n      get \"/u/search/users.json\",\n          params: {\n            term: user.name.split(\" \").last,\n            topic_id: private_topic.id,\n            topic_allowed_users: \"true\",\n          }\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"users\"].map { |u| u[\"username\"] }).to_not include(user.username)\n      expect(json[\"users\"].map { |u| u[\"username\"] }).to include(privileged_user.username)\n    end\n\n    it \"interprets blank category id correctly\" do\n      pm_topic = Fabricate(:private_message_post).topic\n      sign_in(pm_topic.user)\n      get \"/u/search/users.json\", params: { term: \"\", topic_id: pm_topic.id, category_id: \"\" }\n      expect(response.status).to eq(200)\n    end\n\n    describe \"when limit params is invalid\" do\n      include_examples \"invalid limit params\",\n                       \"/u/search/users.json\",\n                       described_class::SEARCH_USERS_LIMIT\n    end\n\n    context \"when `enable_names` is true\" do\n      before { SiteSetting.enable_names = true }\n\n      it \"returns names\" do\n        get \"/u/search/users.json\", params: { term: user.name }\n        json = response.parsed_body\n        expect(json[\"users\"].map { |u| u[\"name\"] }).to include(user.name)\n      end\n    end\n\n    context \"when `enable_names` is false\" do\n      before { SiteSetting.enable_names = false }\n\n      it \"returns names\" do\n        get \"/u/search/users.json\", params: { term: user.name }\n        json = response.parsed_body\n        expect(json[\"users\"].map { |u| u[\"name\"] }).not_to include(user.name)\n      end\n    end\n\n    context \"with groups\" do\n      fab!(:mentionable_group) do\n        Fabricate(\n          :group,\n          mentionable_level: Group::ALIAS_LEVELS[:everyone],\n          messageable_level: Group::ALIAS_LEVELS[:nobody],\n          visibility_level: Group.visibility_levels[:public],\n          name: \"aaa1bbb\",\n        )\n      end\n\n      fab!(:mentionable_group_2) do\n        Fabricate(\n          :group,\n          mentionable_level: Group::ALIAS_LEVELS[:everyone],\n          messageable_level: Group::ALIAS_LEVELS[:nobody],\n          visibility_level: Group.visibility_levels[:logged_on_users],\n          name: \"bbb1aaa\",\n        )\n      end\n\n      fab!(:messageable_group) do\n        Fabricate(\n          :group,\n          mentionable_level: Group::ALIAS_LEVELS[:nobody],\n          messageable_level: Group::ALIAS_LEVELS[:everyone],\n          visibility_level: Group.visibility_levels[:logged_on_users],\n          name: \"ccc1aaa\",\n        )\n      end\n\n      fab!(:private_group) do\n        Fabricate(\n          :group,\n          mentionable_level: Group::ALIAS_LEVELS[:members_mods_and_admins],\n          messageable_level: Group::ALIAS_LEVELS[:members_mods_and_admins],\n          visibility_level: Group.visibility_levels[:members],\n          name: \"ddd1aaa\",\n        )\n      end\n\n      describe \"when signed in\" do\n        before { sign_in(user) }\n\n        it \"correctly sorts on prefix\" do\n          get \"/u/search/users.json\", params: { include_groups: \"true\", term: \"bbb\" }\n\n          expect(response.status).to eq(200)\n          groups = response.parsed_body[\"groups\"]\n\n          expect(groups.map { |g| g[\"name\"] }).to eq(%w[bbb1aaa aaa1bbb])\n        end\n\n        it \"does not search for groups if there is no term\" do\n          get \"/u/search/users.json\", params: { include_groups: \"true\" }\n\n          expect(response.status).to eq(200)\n\n          groups = response.parsed_body[\"groups\"]\n          expect(groups).to eq(nil)\n        end\n\n        it \"only returns visible groups\" do\n          get \"/u/search/users.json\", params: { include_groups: \"true\", term: \"a\" }\n\n          expect(response.status).to eq(200)\n\n          groups = response.parsed_body[\"groups\"]\n\n          expect(groups.map { |group| group[\"name\"] }).to_not include(private_group.name)\n        end\n\n        it \"allows plugins to register custom groups filter\" do\n          get \"/u/search/users.json\", params: { include_groups: \"true\", term: \"a\" }\n\n          expect(response.status).to eq(200)\n          groups = response.parsed_body[\"groups\"]\n          expect(groups.count).to eq(6)\n\n          plugin = Plugin::Instance.new\n          plugin.register_groups_callback_for_users_search_controller_action(\n            :admins_filter,\n          ) { |original_groups, user| original_groups.where(name: \"admins\") }\n          get \"/u/search/users.json\",\n              params: {\n                include_groups: \"true\",\n                admins_filter: \"true\",\n                term: \"a\",\n              }\n          expect(response.status).to eq(200)\n          groups = response.parsed_body[\"groups\"]\n          expect(groups).to eq([{ \"name\" => \"admins\", \"full_name\" => nil }])\n\n          DiscoursePluginRegistry.reset!\n        end\n\n        it \"allows plugins to use apply modifiers to the groups filter\" do\n          get \"/u/search/users.json\", params: { include_groups: \"true\", term: \"a\" }\n\n          expect(response.status).to eq(200)\n          initial_groups = response.parsed_body[\"groups\"]\n          expect(initial_groups.count).to eq(6)\n\n          Plugin::Instance\n            .new\n            .register_modifier(:groups_for_users_search) do |groups|\n              groups.where(name: initial_groups.first[\"name\"])\n            end\n\n          get \"/u/search/users.json\", params: { include_groups: \"true\", term: \"a\" }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"groups\"].count).to eq(1)\n\n          DiscoursePluginRegistry.reset!\n        end\n\n        it \"works when the modifier to the groups filter introduces a join with a conflicting name fields like `id` for example\" do\n          %i[\n            include_groups\n            include_mentionable_groups\n            include_messageable_groups\n          ].each do |param_name|\n            get \"/u/search/users.json\", params: { param_name => \"true\", :term => \"a\" }\n\n            expect(response.status).to eq(200)\n\n            Plugin::Instance\n              .new\n              .register_modifier(:groups_for_users_search) do |groups|\n                # a join with a conflicting name field (id) is introduced here\n                # we expect the query to work correctly\n                groups.left_joins(:users).where(users: { admin: true })\n              end\n\n            get \"/u/search/users.json\", params: { param_name => \"true\", :term => \"a\" }\n            expect(response.status).to eq(200) # the conflict would cause a 500 error\n\n            DiscoursePluginRegistry.reset!\n          end\n        end\n\n        it \"doesn't search for groups\" do\n          get \"/u/search/users.json\",\n              params: {\n                include_mentionable_groups: \"false\",\n                include_messageable_groups: \"false\",\n                term: \"a\",\n              }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body).not_to have_key(:groups)\n        end\n\n        it \"searches for messageable groups\" do\n          get \"/u/search/users.json\",\n              params: {\n                include_mentionable_groups: \"false\",\n                include_messageable_groups: \"true\",\n                term: \"a\",\n              }\n\n          expect(response.status).to eq(200)\n\n          expect(response.parsed_body[\"groups\"].map { |group| group[\"name\"] }).to contain_exactly(\n            messageable_group.name,\n            Group.find(Group::AUTO_GROUPS[:moderators]).name,\n          )\n        end\n\n        it \"searches for mentionable groups\" do\n          get \"/u/search/users.json\",\n              params: {\n                include_messageable_groups: \"false\",\n                include_mentionable_groups: \"true\",\n                term: \"a\",\n              }\n\n          expect(response.status).to eq(200)\n\n          groups = response.parsed_body[\"groups\"]\n\n          expect(groups.map { |group| group[\"name\"] }).to contain_exactly(\n            mentionable_group.name,\n            mentionable_group_2.name,\n          )\n        end\n      end\n\n      describe \"when not signed in\" do\n        it \"should not include mentionable/messageable groups\" do\n          get \"/u/search/users.json\",\n              params: {\n                include_mentionable_groups: \"false\",\n                include_messageable_groups: \"false\",\n                term: \"a\",\n              }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body).not_to have_key(:groups)\n\n          get \"/u/search/users.json\",\n              params: {\n                include_mentionable_groups: \"false\",\n                include_messageable_groups: \"true\",\n                term: \"a\",\n              }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body).not_to have_key(:groups)\n\n          get \"/u/search/users.json\",\n              params: {\n                include_messageable_groups: \"false\",\n                include_mentionable_groups: \"true\",\n                term: \"a\",\n              }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body).not_to have_key(:groups)\n        end\n      end\n\n      describe \"when searching by group name\" do\n        fab!(:exclusive_group) { Fabricate(:group) }\n\n        it \"return results if the user is a group member\" do\n          exclusive_group.add(user)\n\n          get \"/u/search/users.json\", params: { group: exclusive_group.name, term: user.username }\n\n          expect(users_found).to contain_exactly(user.username)\n        end\n\n        it \"does not return results if the user is not a group member\" do\n          get \"/u/search/users.json\", params: { group: exclusive_group.name, term: user.username }\n\n          expect(users_found).to be_empty\n        end\n\n        it \"returns results if the user is member of one of the groups\" do\n          exclusive_group.add(user)\n\n          get \"/u/search/users.json\",\n              params: {\n                groups: [exclusive_group.name],\n                term: user.username,\n              }\n\n          expect(users_found).to contain_exactly(user.username)\n        end\n\n        it \"does not return results if the user is not a member of the groups\" do\n          get \"/u/search/users.json\",\n              params: {\n                groups: [exclusive_group.name],\n                term: user.username,\n              }\n\n          expect(users_found).to be_empty\n        end\n\n        def users_found\n          response.parsed_body[\"users\"].map { |u| u[\"username\"] }\n        end\n      end\n    end\n\n    context \"with `include_staged_users`\" do\n      it \"includes staged users when the param is true\" do\n        get \"/u/search/users.json\", params: { term: staged_user.name, include_staged_users: true }\n        json = response.parsed_body\n        expect(json[\"users\"].map { |u| u[\"name\"] }).to include(staged_user.name)\n      end\n\n      it \"doesn't include staged users when the param is not passed\" do\n        get \"/u/search/users.json\", params: { term: staged_user.name }\n        json = response.parsed_body\n        expect(json[\"users\"].map { |u| u[\"name\"] }).not_to include(staged_user.name)\n      end\n\n      it \"doesn't include staged users when the param explicitly set to false\" do\n        get \"/u/search/users.json\", params: { term: staged_user.name, include_staged_users: false }\n        json = response.parsed_body\n        expect(json[\"users\"].map { |u| u[\"name\"] }).not_to include(staged_user.name)\n      end\n    end\n\n    context \"with `last_seen_users`\" do\n      it \"returns results when the param is true\" do\n        get \"/u/search/users.json\", params: { last_seen_users: true }\n\n        json = response.parsed_body\n        expect(json[\"users\"]).not_to be_empty\n      end\n\n      it \"respects limit parameter at the same time\" do\n        limit = 3\n        get \"/u/search/users.json\", params: { last_seen_users: true, limit: limit }\n\n        json = response.parsed_body\n        expect(json[\"users\"]).not_to be_empty\n        expect(json[\"users\"].size).to eq(limit)\n      end\n    end\n\n    it \"returns avatar_template\" do\n      get \"/u/search/users.json\", params: { term: user.username }\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"users\"][0]).to have_key(\"avatar_template\")\n      expect(json[\"users\"][0][\"avatar_template\"]).to eq(\n        \"/letter_avatar_proxy/v4/letter/j/f475e1/{size}.png\",\n      )\n    end\n\n    describe \"#status\" do\n      it \"returns user status if enabled in site settings\" do\n        SiteSetting.enable_user_status = true\n        emoji = \"tooth\"\n        description = \"off to dentist\"\n        user.set_status!(description, emoji)\n\n        get \"/u/search/users.json\", params: { term: user.name }\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"users\"][0]).to have_key(\"status\")\n        expect(json[\"users\"][0][\"status\"][\"description\"]).to eq(description)\n        expect(json[\"users\"][0][\"status\"][\"emoji\"]).to eq(emoji)\n      end\n\n      it \"doesn't return user status if disabled in site settings\" do\n        SiteSetting.enable_user_status = false\n        user.set_status!(\"off to dentist\", \"tooth\")\n\n        get \"/u/search/users.json\", params: { term: user.name }\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"users\"][0]).not_to have_key(\"status\")\n      end\n    end\n  end\n\n  describe \"#email_login\" do\n    before { SiteSetting.enable_local_logins_via_email = true }\n\n    it \"enqueues the right email\" do\n      post \"/u/email-login.json\", params: { login: user1.email }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"user_found\"]).to eq(true)\n\n      job_args = Jobs::CriticalUserEmail.jobs.last[\"args\"].first\n      expect(job_args[\"user_id\"]).to eq(user1.id)\n      expect(job_args[\"type\"]).to eq(\"email_login\")\n      expect(EmailToken.hash_token(job_args[\"email_token\"])).to eq(\n        user1.email_tokens.last.token_hash,\n      )\n    end\n\n    describe \"when enable_local_logins_via_email is disabled\" do\n      before { SiteSetting.enable_local_logins_via_email = false }\n\n      it \"should return the right response\" do\n        post \"/u/email-login.json\", params: { login: user1.email }\n        expect(response.status).to eq(404)\n      end\n    end\n\n    describe \"when username or email is not valid\" do\n      it \"should not enqueue the email to login\" do\n        post \"/u/email-login.json\", params: { login: \"@random\" }\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"user_found\"]).to eq(false)\n        expect(json[\"hide_taken\"]).to eq(false)\n        expect(Jobs::CriticalUserEmail.jobs).to eq([])\n      end\n    end\n\n    describe \"when hide_email_address_taken is true\" do\n      it \"should return the right response\" do\n        SiteSetting.hide_email_address_taken = true\n        post \"/u/email-login.json\", params: { login: user1.email }\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json.has_key?(\"user_found\")).to eq(false)\n        expect(json[\"hide_taken\"]).to eq(true)\n      end\n    end\n\n    describe \"when user is already logged in\" do\n      it \"should redirect to the root path\" do\n        sign_in(user1)\n        post \"/u/email-login.json\", params: { login: user1.email }\n\n        expect(response).to redirect_to(\"/\")\n      end\n    end\n  end\n\n  describe \"#create_second_factor_totp\" do\n    context \"when not logged in\" do\n      it \"should return the right response\" do\n        post \"/users/second_factors.json\", params: { password: \"wrongpassword\" }\n\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context \"when logged in\" do\n      before { sign_in(user1) }\n\n      describe \"create 2fa request\" do\n        it \"fails on incorrect password\" do\n          ApplicationController\n            .any_instance\n            .expects(:secure_session)\n            .returns(\"confirmed-password-#{user1.id}\" => \"false\")\n          post \"/users/create_second_factor_totp.json\"\n\n          expect(response.status).to eq(403)\n        end\n\n        describe \"when local logins are disabled\" do\n          it \"should return the right response\" do\n            SiteSetting.enable_local_logins = false\n\n            post \"/users/create_second_factor_totp.json\"\n\n            expect(response.status).to eq(404)\n          end\n        end\n\n        describe \"when SSO is enabled\" do\n          it \"should return the right response\" do\n            SiteSetting.discourse_connect_url = \"http://someurl.com\"\n            SiteSetting.enable_discourse_connect = true\n\n            post \"/users/create_second_factor_totp.json\"\n\n            expect(response.status).to eq(404)\n          end\n        end\n\n        it \"succeeds on correct password\" do\n          ApplicationController\n            .any_instance\n            .stubs(:secure_session)\n            .returns(\"confirmed-password-#{user1.id}\" => \"true\")\n          post \"/users/create_second_factor_totp.json\"\n\n          expect(response.status).to eq(200)\n\n          response_body = response.parsed_body\n\n          expect(response_body[\"key\"]).to be_present\n          expect(response_body[\"qr\"]).to be_present\n        end\n      end\n    end\n  end\n\n  describe \"#enable_second_factor_totp\" do\n    before { sign_in(user1) }\n\n    use_redis_snapshotting\n\n    def create_totp\n      stub_secure_session_confirmed\n      post \"/users/create_second_factor_totp.json\"\n    end\n\n    it \"creates a totp for the user successfully\" do\n      create_totp\n      staged_totp_key = read_secure_session[\"staged-totp-#{user1.id}\"]\n      token = ROTP::TOTP.new(staged_totp_key).now\n\n      post \"/users/enable_second_factor_totp.json\",\n           params: {\n             name: \"test\",\n             second_factor_token: token,\n           }\n\n      expect(response.status).to eq(200)\n      expect(user1.user_second_factors.count).to eq(1)\n    end\n\n    it \"rate limits by IP address\" do\n      RateLimiter.enable\n\n      create_totp\n      staged_totp_key = read_secure_session[\"staged-totp-#{user1.id}\"]\n      token = ROTP::TOTP.new(staged_totp_key).now\n\n      7.times do |x|\n        post \"/users/enable_second_factor_totp.json\",\n             params: {\n               name: \"test\",\n               second_factor_token: token,\n             }\n      end\n\n      expect(response.status).to eq(429)\n    end\n\n    it \"rate limits by username\" do\n      RateLimiter.enable\n\n      create_totp\n      staged_totp_key = read_secure_session[\"staged-totp-#{user1.id}\"]\n      token = ROTP::TOTP.new(staged_totp_key).now\n\n      7.times do |x|\n        post \"/users/enable_second_factor_totp.json\",\n             params: {\n               name: \"test\",\n               second_factor_token: token,\n             },\n             env: {\n               REMOTE_ADDR: \"1.2.3.#{x}\",\n             }\n      end\n\n      expect(response.status).to eq(429)\n    end\n\n    context \"when an incorrect token is provided\" do\n      before do\n        create_totp\n        post \"/users/enable_second_factor_totp.json\",\n             params: {\n               name: \"test\",\n               second_factor_token: \"123456\",\n             }\n      end\n      it \"shows a helpful error message to the user\" do\n        expect(response.parsed_body[\"error\"]).to eq(I18n.t(\"login.invalid_second_factor_code\"))\n      end\n    end\n\n    context \"when a name is not provided\" do\n      before do\n        create_totp\n        post \"/users/enable_second_factor_totp.json\", params: { second_factor_token: \"123456\" }\n      end\n      it \"shows a helpful error message to the user\" do\n        expect(response.parsed_body[\"error\"]).to eq(I18n.t(\"login.missing_second_factor_name\"))\n      end\n    end\n\n    context \"when a token is not provided\" do\n      before do\n        create_totp\n        post \"/users/enable_second_factor_totp.json\", params: { name: \"test\" }\n      end\n      it \"shows a helpful error message to the user\" do\n        expect(response.parsed_body[\"error\"]).to eq(I18n.t(\"login.missing_second_factor_code\"))\n      end\n    end\n\n    it \"doesn't allow creating too many TOTPs\" do\n      Fabricate(:user_second_factor_totp, user: user1)\n\n      create_totp\n      staged_totp_key = read_secure_session[\"staged-totp-#{user1.id}\"]\n      token = ROTP::TOTP.new(staged_totp_key).now\n\n      stub_const(UserSecondFactor, \"MAX_TOTPS_PER_USER\", 1) do\n        post \"/users/enable_second_factor_totp.json\",\n             params: {\n               name: \"test\",\n               second_factor_token: token,\n             }\n      end\n\n      expect(response.status).to eq(422)\n      expect(response.parsed_body[\"errors\"]).to include(I18n.t(\"login.too_many_authenticators\"))\n\n      expect(user1.user_second_factors.count).to eq(1)\n    end\n\n    it \"doesn't allow the TOTP name to exceed the limit\" do\n      create_totp\n      staged_totp_key = read_secure_session[\"staged-totp-#{user1.id}\"]\n      token = ROTP::TOTP.new(staged_totp_key).now\n\n      post \"/users/enable_second_factor_totp.json\",\n           params: {\n             name: \"a\" * (UserSecondFactor::MAX_NAME_LENGTH + 1),\n             second_factor_token: token,\n           }\n\n      expect(response.status).to eq(422)\n      expect(response.parsed_body[\"errors\"]).to include(\n        \"Name is too long (maximum is 300 characters)\",\n      )\n\n      expect(user1.user_second_factors.count).to eq(0)\n    end\n  end\n\n  describe \"#update_second_factor\" do\n    fab!(:user_second_factor) { Fabricate(:user_second_factor_totp, user: user1) }\n\n    context \"when not logged in\" do\n      it \"should return the right response\" do\n        put \"/users/second_factor.json\"\n\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context \"when logged in\" do\n      before { sign_in(user1) }\n\n      context \"when user has totp setup\" do\n        context \"when token is missing\" do\n          it \"returns the right response\" do\n            put \"/users/second_factor.json\",\n                params: {\n                  disable: \"true\",\n                  second_factor_target: UserSecondFactor.methods[:totp],\n                  id: user_second_factor.id,\n                }\n\n            expect(response.status).to eq(403)\n          end\n        end\n\n        context \"when token is valid\" do\n          before { stub_secure_session_confirmed }\n          it \"should allow second factor for the user to be renamed\" do\n            put \"/users/second_factor.json\",\n                params: {\n                  name: \"renamed\",\n                  second_factor_target: UserSecondFactor.methods[:totp],\n                  id: user_second_factor.id,\n                }\n\n            expect(response.status).to eq(200)\n            expect(user1.reload.user_second_factors.totps.first.name).to eq(\"renamed\")\n          end\n\n          it \"should allow second factor for the user to be disabled\" do\n            put \"/users/second_factor.json\",\n                params: {\n                  disable: \"true\",\n                  second_factor_target: UserSecondFactor.methods[:totp],\n                  id: user_second_factor.id,\n                }\n\n            expect(response.status).to eq(200)\n            expect(user1.reload.user_second_factors.totps.first).to eq(nil)\n          end\n        end\n      end\n\n      context \"when user is updating backup codes\" do\n        context \"when token is missing\" do\n          it \"returns the right response\" do\n            put \"/users/second_factor.json\",\n                params: {\n                  second_factor_target: UserSecondFactor.methods[:backup_codes],\n                }\n\n            expect(response.status).to eq(403)\n          end\n        end\n\n        context \"when token is valid\" do\n          before do\n            ApplicationController\n              .any_instance\n              .stubs(:secure_session)\n              .returns(\"confirmed-password-#{user1.id}\" => \"true\")\n          end\n          it \"should allow second factor backup for the user to be disabled\" do\n            put \"/users/second_factor.json\",\n                params: {\n                  second_factor_target: UserSecondFactor.methods[:backup_codes],\n                  disable: \"true\",\n                }\n\n            expect(response.status).to eq(200)\n            expect(user1.reload.user_second_factors.backup_codes).to be_empty\n          end\n        end\n      end\n    end\n  end\n\n  describe \"#create_second_factor_backup\" do\n    fab!(:user_second_factor) { Fabricate(:user_second_factor_totp, user: user1) }\n\n    context \"when not logged in\" do\n      it \"should return the right response\" do\n        put \"/users/second_factors_backup.json\",\n            params: {\n              second_factor_token: \"wrongtoken\",\n              second_factor_method: UserSecondFactor.methods[:totp],\n            }\n\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context \"when logged in\" do\n      before { sign_in(user1) }\n\n      describe \"create 2fa request\" do\n        it \"fails on incorrect password\" do\n          ApplicationController\n            .any_instance\n            .expects(:secure_session)\n            .returns(\"confirmed-password-#{user1.id}\" => \"false\")\n          put \"/users/second_factors_backup.json\"\n\n          expect(response.status).to eq(403)\n        end\n\n        describe \"when local logins are disabled\" do\n          it \"should return the right response\" do\n            SiteSetting.enable_local_logins = false\n\n            put \"/users/second_factors_backup.json\"\n\n            expect(response.status).to eq(404)\n          end\n        end\n\n        describe \"when SSO is enabled\" do\n          it \"should return the right response\" do\n            SiteSetting.discourse_connect_url = \"http://someurl.com\"\n            SiteSetting.enable_discourse_connect = true\n\n            put \"/users/second_factors_backup.json\"\n\n            expect(response.status).to eq(404)\n          end\n        end\n\n        it \"succeeds on correct password\" do\n          ApplicationController\n            .any_instance\n            .expects(:secure_session)\n            .returns(\"confirmed-password-#{user1.id}\" => \"true\")\n\n          put \"/users/second_factors_backup.json\"\n\n          expect(response.status).to eq(200)\n\n          response_body = response.parsed_body\n\n          # we use SecureRandom.hex(16) for backup codes, ensure this continues to be the case\n          expect(response_body[\"backup_codes\"].map(&:length)).to eq([32] * 10)\n        end\n      end\n    end\n  end\n\n  describe \"#create_second_factor_security_key\" do\n    it \"stores the challenge in the session and returns challenge data, user id, and supported algorithms\" do\n      create_second_factor_security_key\n      secure_session = read_secure_session\n      response_parsed = response.parsed_body\n      expect(response_parsed[\"challenge\"]).to eq(Webauthn.challenge(user1, secure_session))\n      expect(response_parsed[\"rp_id\"]).to eq(Webauthn.rp_id(user1, secure_session))\n      expect(response_parsed[\"rp_name\"]).to eq(Webauthn.rp_name(user1, secure_session))\n      expect(response_parsed[\"user_secure_id\"]).to eq(\n        user1.reload.create_or_fetch_secure_identifier,\n      )\n      expect(response_parsed[\"supported_algorithms\"]).to eq(::Webauthn::SUPPORTED_ALGORITHMS)\n    end\n\n    it \"doesn't create a challenge if the user has the maximum number allowed of security keys\" do\n      Fabricate(:user_security_key_with_random_credential, user: user1)\n      stub_const(UserSecurityKey, \"MAX_KEYS_PER_USER\", 1) { create_second_factor_security_key }\n      expect(response.status).to eq(422)\n      expect(response.parsed_body[\"errors\"]).to include(I18n.t(\"login.too_many_security_keys\"))\n    end\n\n    context \"if the user has security key credentials already\" do\n      fab!(:user_security_key) { Fabricate(:user_security_key_with_random_credential, user: user1) }\n\n      it \"returns those existing active credentials\" do\n        create_second_factor_security_key\n        response_parsed = response.parsed_body\n        expect(response_parsed[\"existing_active_credential_ids\"]).to eq(\n          [user_security_key.credential_id],\n        )\n      end\n    end\n  end\n\n  describe \"#register_second_factor_security_key\" do\n    context \"when creation parameters are valid\" do\n      it \"creates a security key for the user\" do\n        simulate_localhost_webauthn_challenge\n        create_second_factor_security_key\n        _response_parsed = response.parsed_body\n\n        post \"/u/register_second_factor_security_key.json\",\n             params: valid_security_key_create_post_data\n\n        expect(user1.security_keys.count).to eq(1)\n        expect(user1.security_keys.last.credential_id).to eq(\n          valid_security_key_create_post_data[:rawId],\n        )\n        expect(user1.security_keys.last.name).to eq(valid_security_key_create_post_data[:name])\n      end\n\n      it \"doesn't allow creating too many security keys\" do\n        simulate_localhost_webauthn_challenge\n        create_second_factor_security_key\n        _response_parsed = response.parsed_body\n\n        Fabricate(:user_security_key_with_random_credential, user: user1)\n\n        stub_const(UserSecurityKey, \"MAX_KEYS_PER_USER\", 1) do\n          post \"/u/register_second_factor_security_key.json\",\n               params: valid_security_key_create_post_data\n        end\n\n        expect(response.status).to eq(422)\n        expect(response.parsed_body[\"errors\"]).to include(I18n.t(\"login.too_many_security_keys\"))\n\n        expect(user1.security_keys.count).to eq(1)\n      end\n\n      it \"doesn't allow the security key name to exceed the limit\" do\n        simulate_localhost_webauthn_challenge\n        create_second_factor_security_key\n        _response_parsed = response.parsed_body\n\n        post \"/u/register_second_factor_security_key.json\",\n             params:\n               valid_security_key_create_post_data.merge(\n                 name: \"a\" * (UserSecurityKey::MAX_NAME_LENGTH + 1),\n               )\n\n        expect(response.status).to eq(422)\n        expect(response.parsed_body[\"errors\"]).to include(\n          \"Name is too long (maximum is 300 characters)\",\n        )\n\n        expect(user1.security_keys.count).to eq(0)\n      end\n    end\n\n    context \"when the creation parameters are invalid\" do\n      it \"shows a security key error and does not create a key\" do\n        stub_as_dev_localhost\n        create_second_factor_security_key\n        _response_parsed = response.parsed_body\n\n        post \"/u/register_second_factor_security_key.json\",\n             params: {\n               id: \"bad id\",\n               rawId: \"bad rawId\",\n               type: \"public-key\",\n               attestation: \"bad attestation\",\n               clientData: Base64.encode64('{\"bad\": \"json\"}'),\n               name: \"My Bad Key\",\n             }\n\n        expect(user1.security_keys.count).to eq(0)\n        expect(response.parsed_body[\"error\"]).to eq(\n          I18n.t(\"webauthn.validation.invalid_type_error\"),\n        )\n      end\n    end\n  end\n\n  describe \"#disable_second_factor\" do\n    context \"when logged in with secure session\" do\n      before do\n        sign_in(user1)\n        stub_secure_session_confirmed\n      end\n      context \"when user has a registered totp and security key\" do\n        before do\n          _totp_second_factor = Fabricate(:user_second_factor_totp, user: user1)\n          _security_key_second_factor =\n            Fabricate(\n              :user_security_key,\n              user: user1,\n              factor_type: UserSecurityKey.factor_types[:second_factor],\n            )\n        end\n\n        it \"should disable all totp and security keys\" do\n          expect_enqueued_with(\n            job: :critical_user_email,\n            args: {\n              type: :account_second_factor_disabled,\n              user_id: user1.id,\n            },\n          ) do\n            put \"/u/disable_second_factor.json\"\n\n            expect(response.status).to eq(200)\n\n            expect(user1.reload.user_second_factors).to be_empty\n            expect(user1.security_keys).to be_empty\n          end\n        end\n      end\n    end\n  end\n\n  describe \"#revoke_account\" do\n    it \"errors for unauthorised users\" do\n      post \"/u/#{user1.username}/preferences/revoke-account.json\",\n           params: {\n             provider_name: \"facebook\",\n           }\n      expect(response.status).to eq(403)\n\n      sign_in(another_user)\n\n      post \"/u/#{user1.username}/preferences/revoke-account.json\",\n           params: {\n             provider_name: \"facebook\",\n           }\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      before { sign_in(user1) }\n\n      it \"returns an error when there is no matching account\" do\n        post \"/u/#{user1.username}/preferences/revoke-account.json\",\n             params: {\n               provider_name: \"facebook\",\n             }\n        expect(response.status).to eq(404)\n      end\n\n      context \"with fake provider\" do\n        let(:authenticator) do\n          Class\n            .new(Auth::Authenticator) do\n              attr_accessor :can_revoke\n\n              def name\n                \"testprovider\"\n              end\n\n              def enabled?\n                true\n              end\n\n              def description_for_user(user)\n                \"an account\"\n              end\n\n              def can_revoke?\n                can_revoke\n              end\n\n              def revoke(user, skip_remote: false)\n                true\n              end\n            end\n            .new\n        end\n\n        before do\n          DiscoursePluginRegistry.register_auth_provider(\n            Auth::AuthProvider.new(authenticator: authenticator),\n          )\n        end\n\n        after { DiscoursePluginRegistry.reset! }\n\n        it \"returns an error when revoking is not allowed\" do\n          authenticator.can_revoke = false\n\n          post \"/u/#{user1.username}/preferences/revoke-account.json\",\n               params: {\n                 provider_name: \"testprovider\",\n               }\n          expect(response.status).to eq(404)\n\n          authenticator.can_revoke = true\n          post \"/u/#{user1.username}/preferences/revoke-account.json\",\n               params: {\n                 provider_name: \"testprovider\",\n               }\n          expect(response.status).to eq(200)\n        end\n\n        it \"works\" do\n          authenticator.can_revoke = true\n\n          post \"/u/#{user1.username}/preferences/revoke-account.json\",\n               params: {\n                 provider_name: \"testprovider\",\n               }\n          expect(response.status).to eq(200)\n        end\n      end\n    end\n  end\n\n  describe \"#revoke_auth_token\" do\n    context \"while logged in\" do\n      before { 2.times { sign_in(user1) } }\n\n      it \"logs user out\" do\n        ids = user1.user_auth_tokens.order(:created_at).pluck(:id)\n\n        post \"/u/#{user1.username}/preferences/revoke-auth-token.json\", params: { token_id: ids[0] }\n\n        expect(response.status).to eq(200)\n\n        user1.user_auth_tokens.reload\n        expect(user1.user_auth_tokens.count).to eq(1)\n        expect(user1.user_auth_tokens.first.id).to eq(ids[1])\n      end\n\n      it \"checks if token exists\" do\n        ids = user1.user_auth_tokens.order(:created_at).pluck(:id)\n\n        post \"/u/#{user1.username}/preferences/revoke-auth-token.json\", params: { token_id: ids[0] }\n\n        expect(response.status).to eq(200)\n\n        post \"/u/#{user1.username}/preferences/revoke-auth-token.json\", params: { token_id: ids[0] }\n\n        expect(response.status).to eq(400)\n      end\n\n      it \"does not let user log out of current session\" do\n        token = UserAuthToken.generate!(user_id: user1.id)\n        cookie =\n          create_auth_cookie(\n            token: token.unhashed_auth_token,\n            user_id: user1.id,\n            trust_level: user1.trust_level,\n            issued_at: 5.minutes.ago,\n          )\n\n        post \"/u/#{user1.username}/preferences/revoke-auth-token.json\",\n             params: {\n               token_id: token.id,\n             },\n             headers: {\n               \"HTTP_COOKIE\" => \"_t=#{cookie}\",\n             }\n\n        expect(token.reload.id).to be_present\n        expect(response.status).to eq(400)\n      end\n\n      it \"logs user out from everywhere if token_id is not present\" do\n        post \"/u/#{user1.username}/preferences/revoke-auth-token.json\"\n\n        expect(response.status).to eq(200)\n        expect(user1.user_auth_tokens.count).to eq(0)\n      end\n    end\n  end\n\n  describe \"#list_second_factors\" do\n    let(:user) { user1 }\n\n    before { sign_in(user) }\n\n    context \"when SSO is enabled\" do\n      before do\n        SiteSetting.discourse_connect_url = \"https://discourse.test/sso\"\n        SiteSetting.enable_discourse_connect = true\n      end\n\n      it \"does not allow access\" do\n        post \"/u/second_factors.json\"\n        expect(response.status).to eq(404)\n      end\n    end\n\n    context \"when local logins are not enabled\" do\n      before { SiteSetting.enable_local_logins = false }\n\n      it \"does not allow access\" do\n        post \"/u/second_factors.json\"\n        expect(response.status).to eq(404)\n      end\n    end\n\n    context \"when the site settings allow second factors\" do\n      before do\n        SiteSetting.enable_local_logins = true\n        SiteSetting.enable_discourse_connect = false\n      end\n\n      context \"when the password parameter is not provided\" do\n        let(:password) { \"\" }\n\n        before { post \"/u/second_factors.json\", params: { password: password } }\n\n        it \"returns password required response\" do\n          expect(response.status).to eq(200)\n          response_body = response.parsed_body\n          expect(response_body[\"password_required\"]).to eq(true)\n        end\n      end\n\n      context \"when the password is provided\" do\n        fab!(:user) { Fabricate(:user, password: \"8555039dd212cc66ec68\") }\n\n        context \"when the password is correct\" do\n          let(:password) { \"8555039dd212cc66ec68\" }\n\n          it \"returns a list of enabled totps and security_key second factors\" do\n            totp_second_factor = Fabricate(:user_second_factor_totp, user: user)\n            security_key_second_factor =\n              Fabricate(\n                :user_security_key,\n                user: user,\n                factor_type: UserSecurityKey.factor_types[:second_factor],\n              )\n\n            post \"/u/second_factors.json\", params: { password: password }\n\n            expect(response.status).to eq(200)\n            response_body = response.parsed_body\n            expect(response_body[\"totps\"].map { |second_factor| second_factor[\"id\"] }).to include(\n              totp_second_factor.id,\n            )\n            expect(\n              response_body[\"security_keys\"].map { |second_factor| second_factor[\"id\"] },\n            ).to include(security_key_second_factor.id)\n          end\n        end\n\n        context \"when the password is not correct\" do\n          let(:password) { \"wrongpassword\" }\n\n          it \"returns the incorrect password response\" do\n            post \"/u/second_factors.json\", params: { password: password }\n\n            response_body = response.parsed_body\n            expect(response_body[\"error\"]).to eq(I18n.t(\"login.incorrect_password\"))\n          end\n        end\n      end\n    end\n  end\n\n  describe \"#feature_topic\" do\n    fab!(:topic) { Fabricate(:topic) }\n    fab!(:other_topic) { Fabricate(:topic) }\n    fab!(:private_message) { Fabricate(:private_message_topic, user: another_user) }\n    fab!(:category) { Fabricate(:category_with_definition) }\n\n    describe \"site setting enabled\" do\n      before { SiteSetting.allow_featured_topic_on_user_profiles = true }\n\n      it \"requires the user to be logged in\" do\n        put \"/u/#{user1.username}/feature-topic.json\", params: { topic_id: topic.id }\n        expect(response.status).to eq(403)\n      end\n\n      it \"returns an error if the user tries to set for another user\" do\n        sign_in(user1)\n        topic.update(user_id: another_user.id)\n        put \"/u/#{another_user.username}/feature-topic.json\", params: { topic_id: topic.id }\n        expect(response.status).to eq(403)\n      end\n\n      it \"returns an error if the topic is a PM\" do\n        sign_in(another_user)\n        put \"/u/#{another_user.username}/feature-topic.json\",\n            params: {\n              topic_id: private_message.id,\n            }\n        expect(response.status).to eq(403)\n      end\n\n      it \"returns an error if the topic is not visible\" do\n        sign_in(user1)\n        topic.update_status(\"visible\", false, user1)\n        put \"/u/#{user1.username}/feature-topic.json\", params: { topic_id: topic.id }\n        expect(response.status).to eq(403)\n      end\n\n      it \"returns an error if the topic's category is read_restricted\" do\n        sign_in(user1)\n        category.set_permissions({})\n        topic.update(category_id: category.id)\n        put \"/u/#{another_user.username}/feature-topic.json\", params: { topic_id: topic.id }\n        expect(response.status).to eq(403)\n      end\n\n      it \"sets featured_topic correctly for user created topic\" do\n        sign_in(user1)\n        topic.update(user_id: user1.id)\n        put \"/u/#{user1.username}/feature-topic.json\", params: { topic_id: topic.id }\n        expect(response.status).to eq(200)\n        expect(user1.user_profile.featured_topic).to eq topic\n      end\n\n      it \"sets featured_topic correctly for non-user-created topic\" do\n        sign_in(user1)\n        put \"/u/#{user1.username}/feature-topic.json\", params: { topic_id: other_topic.id }\n        expect(response.status).to eq(200)\n        expect(user1.user_profile.featured_topic).to eq other_topic\n      end\n\n      describe \"site setting disabled\" do\n        before { SiteSetting.allow_featured_topic_on_user_profiles = false }\n\n        it \"does not allow setting featured_topic for user_profiles\" do\n          sign_in(user1)\n          topic.update(user_id: user1.id)\n          put \"/u/#{user1.username}/feature-topic.json\", params: { topic_id: topic.id }\n          expect(response.status).to eq(403)\n        end\n      end\n    end\n  end\n\n  describe \"#clear_featured_topic\" do\n    fab!(:topic) { Fabricate(:topic) }\n\n    it \"requires the user to be logged in\" do\n      put \"/u/#{user1.username}/clear-featured-topic.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it \"returns an error if the the current user does not have access\" do\n      sign_in(user1)\n      topic.update(user_id: another_user.id)\n      put \"/u/#{another_user.username}/clear-featured-topic.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it \"clears the user_profiles featured_topic correctly\" do\n      sign_in(user1)\n      topic.update(user: user1)\n      put \"/u/#{user1.username}/clear-featured-topic.json\"\n      expect(response.status).to eq(200)\n      expect(user1.user_profile.featured_topic).to eq nil\n    end\n  end\n\n  describe \"#bookmarks\" do\n    before do\n      register_test_bookmarkable\n      TopicUser.change(user1.id, bookmark1.bookmarkable.topic_id, total_msecs_viewed: 1)\n      TopicUser.change(user1.id, bookmark2.bookmarkable_id, total_msecs_viewed: 1)\n      Fabricate(:post, topic: bookmark2.bookmarkable)\n      bookmark3 && bookmark4\n    end\n\n    after { DiscoursePluginRegistry.reset! }\n\n    let(:bookmark1) { Fabricate(:bookmark, user: user1, bookmarkable: Fabricate(:post)) }\n    let(:bookmark2) { Fabricate(:bookmark, user: user1, bookmarkable: Fabricate(:topic)) }\n    let(:bookmark3) { Fabricate(:bookmark, user: user1, bookmarkable: Fabricate(:user)) }\n    let(:bookmark4) { Fabricate(:bookmark) }\n\n    it \"returns a list of serialized bookmarks for the user\" do\n      sign_in(user1)\n      get \"/u/#{user1.username}/bookmarks.json\"\n      expect(response.status).to eq(200)\n      expect(\n        response.parsed_body[\"user_bookmark_list\"][\"bookmarks\"].map { |b| b[\"id\"] },\n      ).to match_array([bookmark1.id, bookmark2.id, bookmark3.id])\n    end\n\n    it \"returns a list of serialized bookmarks for the user including custom registered bookmarkables\" do\n      sign_in(user1)\n      bookmark3.bookmarkable.user_profile.update!(bio_raw: \"<p>Something cooked</p>\")\n      bookmark3.bookmarkable.user_profile.rebake!\n      get \"/u/#{user1.username}/bookmarks.json\"\n      expect(response.status).to eq(200)\n      response_bookmarks = response.parsed_body[\"user_bookmark_list\"][\"bookmarks\"]\n      expect(response_bookmarks.map { |b| b[\"id\"] }).to match_array(\n        [bookmark1.id, bookmark2.id, bookmark3.id],\n      )\n      expect(response_bookmarks.find { |b| b[\"id\"] == bookmark3.id }[\"excerpt\"]).to eq(\n        \"Something cooked\",\n      )\n    end\n\n    it \"returns an .ics file of bookmark reminders for the user in date order\" do\n      bookmark1.update!(name: nil, reminder_at: 1.day.from_now)\n      bookmark2.update!(name: \"Some bookmark note\", reminder_at: 1.week.from_now)\n      bookmark3.update!(name: nil, reminder_at: 2.weeks.from_now)\n\n      sign_in(user1)\n      get \"/u/#{user1.username}/bookmarks.ics\"\n      expect(response.status).to eq(200)\n      expect(response.body).to eq(<<~ICS)\n        BEGIN:VCALENDAR\n        VERSION:2.0\n        PRODID:-//Discourse//#{Discourse.current_hostname}//#{Discourse.full_version}//EN\n        BEGIN:VEVENT\n        UID:bookmark_reminder_##{bookmark1.id}@#{Discourse.current_hostname}\n        DTSTAMP:#{bookmark1.updated_at.strftime(I18n.t(\"datetime_formats.formats.calendar_ics\"))}\n        DTSTART:#{bookmark1.reminder_at_ics}\n        DTEND:#{bookmark1.reminder_at_ics(offset: 1.hour)}\n        SUMMARY:#{bookmark1.bookmarkable.topic.title}\n        DESCRIPTION:#{bookmark1.bookmarkable.full_url}\n        URL:#{bookmark1.bookmarkable.full_url}\n        END:VEVENT\n        BEGIN:VEVENT\n        UID:bookmark_reminder_##{bookmark2.id}@#{Discourse.current_hostname}\n        DTSTAMP:#{bookmark2.updated_at.strftime(I18n.t(\"datetime_formats.formats.calendar_ics\"))}\n        DTSTART:#{bookmark2.reminder_at_ics}\n        DTEND:#{bookmark2.reminder_at_ics(offset: 1.hour)}\n        SUMMARY:Some bookmark note\n        DESCRIPTION:#{bookmark2.bookmarkable.url}\n        URL:#{bookmark2.bookmarkable.url}\n        END:VEVENT\n        BEGIN:VEVENT\n        UID:bookmark_reminder_##{bookmark3.id}@#{Discourse.current_hostname}\n        DTSTAMP:#{bookmark3.updated_at.strftime(I18n.t(\"datetime_formats.formats.calendar_ics\"))}\n        DTSTART:#{bookmark3.reminder_at_ics}\n        DTEND:#{bookmark3.reminder_at_ics(offset: 1.hour)}\n        SUMMARY:#{bookmark3.bookmarkable.username}\n        DESCRIPTION:#{Discourse.base_url}/u/#{bookmark3.bookmarkable.username}\n        URL:#{Discourse.base_url}/u/#{bookmark3.bookmarkable.username}\n        END:VEVENT\n        END:VCALENDAR\n      ICS\n    end\n\n    it \"does not show another user's bookmarks\" do\n      sign_in(Fabricate(:user))\n      get \"/u/#{bookmark3.user.username}/bookmarks.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it \"shows a helpful message if no bookmarks are found\" do\n      bookmark1.destroy\n      bookmark2.destroy\n      bookmark3.destroy\n      sign_in(user1)\n      get \"/u/#{user1.username}/bookmarks.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"bookmarks\"]).to eq([])\n    end\n\n    it \"shows a helpful message if no bookmarks are found for the search\" do\n      sign_in(user1)\n      get \"/u/#{user1.username}/bookmarks.json\", params: { q: \"badsearch\" }\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"bookmarks\"]).to eq([])\n    end\n\n    describe \"when limit params is invalid\" do\n      before { sign_in(user1) }\n\n      include_examples \"invalid limit params\",\n                       \"/u/someusername/bookmarks.json\",\n                       described_class::BOOKMARKS_LIMIT\n    end\n  end\n\n  describe \"#bookmarks excerpts\" do\n    fab!(:user) { Fabricate(:user) }\n    let!(:topic) { Fabricate(:topic, user: user) }\n    let!(:post) { Fabricate(:post, topic: topic) }\n    let!(:bookmark) { Fabricate(:bookmark, name: \"Test\", user: user, bookmarkable: topic) }\n\n    it \"uses the first post of the topic for the bookmarks excerpt\" do\n      TopicUser.change(\n        user.id,\n        bookmark.bookmarkable.id,\n        { last_read_post_number: post.post_number },\n      )\n\n      sign_in(user)\n\n      get \"/u/#{user.username}/bookmarks.json\"\n      expect(response.status).to eq(200)\n      bookmark_list = response.parsed_body[\"user_bookmark_list\"][\"bookmarks\"]\n      expected_excerpt = PrettyText.excerpt(topic.first_post.cooked, 300, keep_emoji_images: true)\n      expect(bookmark_list.first[\"excerpt\"]).to eq(expected_excerpt)\n    end\n\n    describe \"bookmarkable_url\" do\n      context \"with the link_to_first_unread_post option\" do\n        it \"is a full topic URL to the first unread post in the topic when the option is set\" do\n          TopicUser.change(\n            user.id,\n            bookmark.bookmarkable.id,\n            { last_read_post_number: post.post_number },\n          )\n\n          sign_in(user)\n\n          get \"/u/#{user.username}/user-menu-bookmarks.json\"\n          expect(response.status).to eq(200)\n          bookmark_list = response.parsed_body[\"bookmarks\"]\n\n          expect(bookmark_list.first[\"bookmarkable_url\"]).to end_with(\n            \"/t/#{topic.slug}/#{topic.id}/#{post.post_number + 1}\",\n          )\n        end\n\n        it \"is a full topic URL to the first post in the topic when the option isn't set\" do\n          TopicUser.change(\n            user.id,\n            bookmark.bookmarkable.id,\n            { last_read_post_number: post.post_number },\n          )\n\n          sign_in(user)\n\n          get \"/u/#{user.username}/bookmarks.json\"\n          expect(response.status).to eq(200)\n          bookmark_list = response.parsed_body[\"user_bookmark_list\"][\"bookmarks\"]\n\n          expect(bookmark_list.first[\"bookmarkable_url\"]).to end_with(\n            \"/t/#{topic.slug}/#{topic.id}\",\n          )\n        end\n      end\n    end\n  end\n\n  describe \"#private_message_topic_tracking_state\" do\n    fab!(:user_2) { Fabricate(:user) }\n\n    fab!(:private_message) do\n      Group.refresh_automatic_groups!\n      create_post(\n        user: user1,\n        target_usernames: [user_2.username],\n        archetype: Archetype.private_message,\n      ).topic\n    end\n\n    before { sign_in(user_2) }\n\n    it \"does not allow an unauthorized user to access the state of another user\" do\n      get \"/u/#{user1.username}/private-message-topic-tracking-state.json\"\n\n      expect(response.status).to eq(403)\n    end\n\n    it \"returns the right response\" do\n      get \"/u/#{user_2.username}/private-message-topic-tracking-state.json\"\n\n      expect(response.status).to eq(200)\n\n      topic_state = response.parsed_body.first\n\n      expect(topic_state[\"topic_id\"]).to eq(private_message.id)\n      expect(topic_state[\"highest_post_number\"]).to eq(1)\n      expect(topic_state[\"last_read_post_number\"]).to eq(nil)\n      expect(topic_state[\"notification_level\"]).to eq(NotificationLevels.all[:watching])\n      expect(topic_state[\"group_ids\"]).to eq([])\n    end\n  end\n\n  describe \"#reset_recent_searches\" do\n    it \"does nothing for anon\" do\n      delete \"/u/recent-searches.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it \"works for logged in user\" do\n      freeze_time\n      sign_in(user1)\n      delete \"/u/recent-searches.json\"\n\n      expect(response.status).to eq(200)\n      user1.reload\n      expect(user1.user_option.oldest_search_log_date).to be_within(5.seconds).of(1.second.ago)\n    end\n  end\n\n  describe \"#recent_searches\" do\n    it \"does nothing for anon\" do\n      get \"/u/recent-searches.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it \"works for logged in user\" do\n      freeze_time\n      sign_in(user1)\n      SiteSetting.log_search_queries = true\n      user1.user_option.update!(oldest_search_log_date: nil)\n\n      get \"/u/recent-searches.json\"\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"recent_searches\"]).to eq([])\n\n      SearchLog.create!(\n        term: \"old one\",\n        user_id: user1.id,\n        search_type: 1,\n        ip_address: \"192.168.0.1\",\n        created_at: 5.minutes.ago,\n      )\n      SearchLog.create!(\n        term: \"also old\",\n        user_id: user1.id,\n        search_type: 1,\n        ip_address: \"192.168.0.1\",\n        created_at: 15.minutes.ago,\n      )\n\n      get \"/u/recent-searches.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"recent_searches\"]).to eq([\"old one\", \"also old\"])\n\n      user1.user_option.update!(oldest_search_log_date: 20.minutes.ago)\n\n      get \"/u/recent-searches.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"recent_searches\"]).to eq([\"old one\", \"also old\"])\n\n      user1.user_option.update!(oldest_search_log_date: 10.seconds.ago)\n\n      get \"/u/recent-searches.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"recent_searches\"]).to eq([])\n\n      SearchLog.create!(\n        term: \"new search\",\n        user_id: user1.id,\n        search_type: 1,\n        ip_address: \"192.168.0.1\",\n        created_at: 2.seconds.ago,\n      )\n\n      get \"/u/recent-searches.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"recent_searches\"]).to eq([\"new search\"])\n    end\n\n    it \"shows an error message when log_search_queries are off\" do\n      sign_in(user1)\n      SiteSetting.log_search_queries = false\n\n      get \"/u/recent-searches.json\"\n\n      expect(response.status).to eq(403)\n      expect(response.parsed_body[\"error\"]).to eq(I18n.t(\"user_activity.no_log_search_queries\"))\n    end\n  end\n\n  describe \"#user_menu_bookmarks\" do\n    fab!(:post) { Fabricate(:post) }\n    fab!(:topic) { Fabricate(:post).topic }\n    fab!(:bookmark_with_reminder) { Fabricate(:bookmark, user: user, bookmarkable: post) }\n    fab!(:bookmark_without_reminder) { Fabricate(:bookmark, user: user, bookmarkable: topic) }\n\n    before do\n      TopicUser.change(user.id, post.topic.id, total_msecs_viewed: 1)\n      TopicUser.change(user.id, topic.id, total_msecs_viewed: 1)\n      BookmarkReminderNotificationHandler.new(bookmark_with_reminder).send_notification\n    end\n\n    context \"when logged out\" do\n      it \"responds with 404\" do\n        get \"/u/#{user.username}/user-menu-bookmarks\"\n        expect(response.status).to eq(404)\n      end\n    end\n\n    context \"when logged in\" do\n      before { sign_in(user) }\n\n      it \"responds with 403 when requesting bookmarks list of another user\" do\n        get \"/u/#{user1.username}/user-menu-bookmarks\"\n        expect(response.status).to eq(403)\n      end\n\n      it \"sends an array of unread bookmark_reminder notifications\" do\n        bookmark_with_reminder2 = Fabricate(:bookmark, user: user, bookmarkable: Fabricate(:post))\n        TopicUser.change(user.id, bookmark_with_reminder2.bookmarkable.topic, total_msecs_viewed: 1)\n        BookmarkReminderNotificationHandler.new(bookmark_with_reminder2).send_notification\n\n        user\n          .notifications\n          .where(notification_type: Notification.types[:bookmark_reminder])\n          .where(\"data::json ->> 'bookmark_id' = ?\", bookmark_with_reminder2.id.to_s)\n          .first\n          .update!(read: true)\n\n        get \"/u/#{user.username}/user-menu-bookmarks\"\n        expect(response.status).to eq(200)\n\n        notifications = response.parsed_body[\"notifications\"]\n        expect(notifications.size).to eq(1)\n        expect(notifications.first[\"data\"][\"bookmark_id\"]).to eq(bookmark_with_reminder.id)\n      end\n\n      it \"responds with an array of bookmarks that are not associated with any of the unread bookmark_reminder notifications\" do\n        get \"/u/#{user.username}/user-menu-bookmarks\"\n        expect(response.status).to eq(200)\n\n        bookmarks = response.parsed_body[\"bookmarks\"]\n        expect(bookmarks.size).to eq(1)\n        expect(bookmarks.first[\"id\"]).to eq(bookmark_without_reminder.id)\n\n        bookmark_reminder =\n          user\n            .notifications\n            .where(notification_type: Notification.types[:bookmark_reminder])\n            .where(\"data::json ->> 'bookmark_id' = ?\", bookmark_with_reminder.id.to_s)\n            .first\n\n        bookmark_reminder.update!(read: true)\n        get \"/u/#{user.username}/user-menu-bookmarks\"\n        expect(response.status).to eq(200)\n\n        bookmarks = response.parsed_body[\"bookmarks\"]\n        expect(bookmarks.map { |bookmark| bookmark[\"id\"] }).to contain_exactly(\n          bookmark_with_reminder.id,\n          bookmark_without_reminder.id,\n        )\n\n        data = bookmark_reminder.data_hash\n        data.delete(:bookmark_id)\n        bookmark_reminder.update!(data: data.to_json, read: false)\n\n        get \"/u/#{user.username}/user-menu-bookmarks\"\n        expect(response.status).to eq(200)\n\n        notifications = response.parsed_body[\"notifications\"]\n        expect(notifications.size).to eq(0)\n\n        bookmarks = response.parsed_body[\"bookmarks\"]\n        expect(bookmarks.map { |bookmark| bookmark[\"id\"] }).to contain_exactly(\n          bookmark_with_reminder.id,\n          bookmark_without_reminder.id,\n        )\n      end\n\n      it \"fills up the remaining of the USER_MENU_LIST_LIMIT limit with bookmarks\" do\n        bookmark2 = Fabricate(:bookmark, user: user, bookmarkable: Fabricate(:post, topic: topic))\n\n        stub_const(UsersController, \"USER_MENU_LIST_LIMIT\", 2) do\n          get \"/u/#{user.username}/user-menu-bookmarks\"\n        end\n        expect(response.status).to eq(200)\n\n        notifications = response.parsed_body[\"notifications\"]\n        expect(notifications.size).to eq(1)\n\n        bookmarks = response.parsed_body[\"bookmarks\"]\n        expect(bookmarks.size).to eq(1)\n\n        stub_const(UsersController, \"USER_MENU_LIST_LIMIT\", 3) do\n          get \"/u/#{user.username}/user-menu-bookmarks\"\n        end\n        expect(response.status).to eq(200)\n\n        notifications = response.parsed_body[\"notifications\"]\n        expect(notifications.size).to eq(1)\n\n        bookmarks = response.parsed_body[\"bookmarks\"]\n        expect(bookmarks.size).to eq(2)\n\n        BookmarkReminderNotificationHandler.new(bookmark2).send_notification\n\n        stub_const(UsersController, \"USER_MENU_LIST_LIMIT\", 3) do\n          get \"/u/#{user.username}/user-menu-bookmarks\"\n        end\n        expect(response.status).to eq(200)\n\n        notifications = response.parsed_body[\"notifications\"]\n        expect(notifications.size).to eq(2)\n\n        bookmarks = response.parsed_body[\"bookmarks\"]\n        expect(bookmarks.size).to eq(1)\n      end\n\n      it \"does not return any unread notifications for bookmarks that the user no longer has access to\" do\n        bookmark_with_reminder2 = Fabricate(:bookmark, user: user, bookmarkable: Fabricate(:post))\n        TopicUser.change(user.id, bookmark_with_reminder2.bookmarkable.topic, total_msecs_viewed: 1)\n        BookmarkReminderNotificationHandler.new(bookmark_with_reminder2).send_notification\n\n        bookmark_with_reminder2.bookmarkable.topic.update!(\n          archetype: Archetype.private_message,\n          category: nil,\n        )\n\n        get \"/u/#{user.username}/user-menu-bookmarks\"\n        expect(response.status).to eq(200)\n\n        notifications = response.parsed_body[\"notifications\"]\n        expect(notifications.size).to eq(1)\n        expect(notifications.first[\"data\"][\"bookmark_id\"]).to eq(bookmark_with_reminder.id)\n      end\n    end\n  end\n\n  describe \"#user_menu_messages\" do\n    fab!(:group1) { Fabricate(:group, has_messages: true, users: [user]) }\n    fab!(:group2) { Fabricate(:group, has_messages: true, users: [user, user1]) }\n    fab!(:group3) { Fabricate(:group, has_messages: true, users: [user1]) }\n\n    fab!(:message_without_notification) { Fabricate(:private_message_post, recipient: user).topic }\n    fab!(:message_with_read_notification) do\n      Fabricate(:private_message_post, recipient: user).topic\n    end\n    fab!(:message_with_unread_notification) do\n      Fabricate(:private_message_post, recipient: user).topic\n    end\n    fab!(:archived_message) { Fabricate(:private_message_post, recipient: user).topic }\n\n    fab!(:group_message1) { Fabricate(:group_private_message_post, recipients: group1).topic }\n    fab!(:group_message2) { Fabricate(:group_private_message_post, recipients: group2).topic }\n    fab!(:group_message3) { Fabricate(:group_private_message_post, recipients: group3).topic }\n\n    fab!(:archived_group_message1) do\n      Fabricate(:group_private_message_post, recipients: group1).topic\n    end\n    fab!(:archived_group_message2) do\n      Fabricate(:group_private_message_post, recipients: group2).topic\n    end\n\n    fab!(:user1_message_without_notification) do\n      Fabricate(:private_message_post, recipient: user1).topic\n    end\n    fab!(:user1_message_with_read_notification) do\n      Fabricate(:private_message_post, recipient: user1).topic\n    end\n    fab!(:user1_message_with_unread_notification) do\n      Fabricate(:private_message_post, recipient: user1).topic\n    end\n    fab!(:user1_archived_message) { Fabricate(:private_message_post, recipient: user1).topic }\n\n    fab!(:unread_pm_notification) do\n      Fabricate(\n        :private_message_notification,\n        read: false,\n        user: user,\n        topic: message_with_unread_notification,\n        created_at: 4.minutes.ago,\n      )\n    end\n    fab!(:read_pm_notification) do\n      Fabricate(\n        :private_message_notification,\n        read: true,\n        user: user,\n        topic: message_with_read_notification,\n      )\n    end\n\n    fab!(:unread_group_message_summary_notification) do\n      Fabricate(\n        :notification,\n        read: false,\n        user: user,\n        notification_type: Notification.types[:group_message_summary],\n        created_at: 2.minutes.ago,\n      )\n    end\n\n    fab!(:read_group_message_summary_notification) do\n      Fabricate(\n        :notification,\n        read: true,\n        user: user,\n        notification_type: Notification.types[:group_message_summary],\n        created_at: 1.minutes.ago,\n      )\n    end\n\n    fab!(:user1_unread_pm_notification) do\n      Fabricate(\n        :private_message_notification,\n        read: false,\n        user: user1,\n        topic: user1_message_with_unread_notification,\n      )\n    end\n    fab!(:user1_read_pm_notification) do\n      Fabricate(\n        :private_message_notification,\n        read: true,\n        user: user1,\n        topic: user1_message_with_read_notification,\n      )\n    end\n\n    fab!(:user1_unread_group_message_summary_notification) do\n      Fabricate(\n        :notification,\n        read: false,\n        user: user1,\n        notification_type: Notification.types[:group_message_summary],\n      )\n    end\n    fab!(:user1_read_group_message_summary_notification) do\n      Fabricate(\n        :notification,\n        read: true,\n        user: user1,\n        notification_type: Notification.types[:group_message_summary],\n      )\n    end\n\n    before do\n      UserArchivedMessage.archive!(user.id, archived_message)\n      UserArchivedMessage.archive!(user1.id, user1_archived_message)\n      GroupArchivedMessage.archive!(group1.id, archived_group_message1)\n      GroupArchivedMessage.archive!(group2.id, archived_group_message2)\n    end\n\n    context \"when logged out\" do\n      it \"responds with 404\" do\n        get \"/u/#{user.username}/user-menu-private-messages\"\n        expect(response.status).to eq(404)\n      end\n    end\n\n    context \"when logged in\" do\n      before { sign_in(user) }\n\n      it \"responds with 403 when requesting messages list of another user\" do\n        get \"/u/#{user1.username}/user-menu-private-messages\"\n        expect(response.status).to eq(403)\n      end\n\n      it \"responds with 403 if personal_message_enabled_groups does not include the user and the user isn't staff\" do\n        SiteSetting.personal_message_enabled_groups = Group::AUTO_GROUPS[:trust_level_4]\n        user.update(trust_level: 1)\n        get \"/u/#{user.username}/user-menu-private-messages\"\n        expect(response.status).to eq(403)\n      end\n\n      it \"sends an array of unread private_message notifications\" do\n        get \"/u/#{user.username}/user-menu-private-messages\"\n        expect(response.status).to eq(200)\n\n        unread_notifications = response.parsed_body[\"unread_notifications\"]\n        expect(unread_notifications.map { |notification| notification[\"id\"] }).to eq(\n          [unread_pm_notification.id, unread_group_message_summary_notification.id],\n        )\n      end\n\n      it \"sends an array of read group_message_summary notifications\" do\n        read_group_message_summary_notification2 =\n          Fabricate(\n            :notification,\n            read: true,\n            user: user,\n            notification_type: Notification.types[:group_message_summary],\n            created_at: 5.minutes.ago,\n          )\n        get \"/u/#{user.username}/user-menu-private-messages\"\n        expect(response.status).to eq(200)\n\n        read_notifications = response.parsed_body[\"read_notifications\"]\n        expect(read_notifications.map { |notification| notification[\"id\"] }).to eq(\n          [read_group_message_summary_notification.id, read_group_message_summary_notification2.id],\n        )\n      end\n\n      it \"responds with an array of personal messages and user watching group messages that are not associated with any of the unread private_message notifications\" do\n        group_message1.update!(bumped_at: 1.minutes.ago)\n        message_without_notification.update!(bumped_at: 3.minutes.ago)\n        group_message2.update!(bumped_at: 6.minutes.ago)\n        message_with_read_notification.update!(bumped_at: 10.minutes.ago)\n        read_group_message_summary_notification.destroy!\n\n        TopicUser.create!(\n          user: user,\n          topic: group_message1,\n          notification_level: TopicUser.notification_levels[:watching],\n        )\n        TopicUser.create!(\n          user: user,\n          topic: group_message2,\n          notification_level: TopicUser.notification_levels[:regular],\n        )\n\n        get \"/u/#{user.username}/user-menu-private-messages\"\n        expect(response.status).to eq(200)\n\n        topics = response.parsed_body[\"topics\"]\n\n        expect(topics.map { |topic| topic[\"id\"] }).to eq(\n          [group_message1.id, message_without_notification.id, message_with_read_notification.id],\n        )\n      end\n\n      it \"fills up the remaining of the USER_MENU_LIST_LIMIT limit with PM topics\" do\n        stub_const(UsersController, \"USER_MENU_LIST_LIMIT\", 3) do\n          get \"/u/#{user.username}/user-menu-private-messages\"\n        end\n        expect(response.status).to eq(200)\n        unread_notifications = response.parsed_body[\"unread_notifications\"]\n        expect(unread_notifications.size).to eq(2)\n\n        topics = response.parsed_body[\"topics\"]\n        read_notifications = response.parsed_body[\"read_notifications\"]\n        expect(topics.size).to eq(1)\n        expect(read_notifications.size).to eq(1)\n\n        message2 = Fabricate(:private_message_post, recipient: user).topic\n        Fabricate(:private_message_notification, read: false, user: user, topic: message2)\n\n        stub_const(UsersController, \"USER_MENU_LIST_LIMIT\", 2) do\n          get \"/u/#{user.username}/user-menu-private-messages\"\n        end\n        expect(response.status).to eq(200)\n        unread_notifications = response.parsed_body[\"unread_notifications\"]\n        expect(unread_notifications.size).to eq(2)\n\n        topics = response.parsed_body[\"topics\"]\n        read_notifications = response.parsed_body[\"read_notifications\"]\n        expect(topics.size).to eq(0)\n        expect(read_notifications.size).to eq(0)\n      end\n    end\n  end\n\n  def create_second_factor_security_key\n    sign_in(user1)\n    stub_secure_session_confirmed\n    post \"/u/create_second_factor_security_key.json\"\n  end\n\n  def stub_secure_session_confirmed\n    UsersController.any_instance.stubs(:secure_session_confirmed?).returns(true)\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\nRSpec.describe PostBookmarkable do\n  subject(:registered_bookmarkable) { RegisteredBookmarkable.new(PostBookmarkable) }\n\n  fab!(:user) { Fabricate(:user) }\n  fab!(:private_category) { Fabricate(:private_category, group: Fabricate(:group)) }\n\n  let(:guardian) { Guardian.new(user) }\n\n  let!(:post1) { Fabricate(:post) }\n  let!(:post2) { Fabricate(:post) }\n  let!(:bookmark1) do\n    Fabricate(:bookmark, user: user, bookmarkable: post1, name: \"something i gotta do\")\n  end\n  let!(:bookmark2) { Fabricate(:bookmark, user: user, bookmarkable: post2) }\n  let!(:bookmark3) { Fabricate(:bookmark) }\n  let!(:topic_user1) { Fabricate(:topic_user, user: user, topic: post1.topic) }\n  let!(:topic_user2) { Fabricate(:topic_user, user: user, topic: post2.topic) }\n\n  describe \"#perform_list_query\" do\n    it \"returns all the user's bookmarks\" do\n      expect(registered_bookmarkable.perform_list_query(user, guardian).map(&:id)).to match_array(\n        [bookmark1.id, bookmark2.id],\n      )\n    end\n\n    it \"does not return bookmarks for posts where the user does not have access to the topic category\" do\n      bookmark1.bookmarkable.topic.update(category: private_category)\n      expect(registered_bookmarkable.perform_list_query(user, guardian).map(&:id)).to match_array(\n        [bookmark2.id],\n      )\n    end\n\n    it \"does not return bookmarks for posts where the user does not have access to the private message\" do\n      bookmark1.bookmarkable.update(topic: Fabricate(:private_message_topic))\n      expect(registered_bookmarkable.perform_list_query(user, guardian).map(&:id)).to match_array(\n        [bookmark2.id],\n      )\n    end\n  end\n\n  describe \"#perform_search_query\" do\n    before { SearchIndexer.enable }\n\n    it \"returns bookmarks that match by name\" do\n      ts_query = Search.ts_query(term: \"gotta\", ts_config: \"simple\")\n      expect(\n        registered_bookmarkable.perform_search_query(\n          registered_bookmarkable.perform_list_query(user, guardian),\n          \"%gotta%\",\n          ts_query,\n        ).map(&:id),\n      ).to match_array([bookmark1.id])\n    end\n\n    it \"returns bookmarks that match by post search data (topic title or post content)\" do\n      post2.update(raw: \"some post content\")\n      post2.topic.update(title: \"a great topic title\")\n\n      ts_query = Search.ts_query(term: \"post content\", ts_config: \"simple\")\n      expect(\n        registered_bookmarkable.perform_search_query(\n          registered_bookmarkable.perform_list_query(user, guardian),\n          \"%post content%\",\n          ts_query,\n        ).map(&:id),\n      ).to match_array([bookmark2.id])\n\n      ts_query = Search.ts_query(term: \"great topic\", ts_config: \"simple\")\n      expect(\n        registered_bookmarkable.perform_search_query(\n          registered_bookmarkable.perform_list_query(user, guardian),\n          \"%great topic%\",\n          ts_query,\n        ).map(&:id),\n      ).to match_array([bookmark2.id])\n\n      ts_query = Search.ts_query(term: \"blah\", ts_config: \"simple\")\n      expect(\n        registered_bookmarkable.perform_search_query(\n          registered_bookmarkable.perform_list_query(user, guardian),\n          \"%blah%\",\n          ts_query,\n        ).map(&:id),\n      ).to eq([])\n    end\n  end\n\n  describe \"#can_send_reminder?\" do\n    it \"cannot send reminder if the post or topic is deleted\" do\n      expect(registered_bookmarkable.can_send_reminder?(bookmark1)).to eq(true)\n      bookmark1.bookmarkable.trash!\n      bookmark1.reload\n      expect(registered_bookmarkable.can_send_reminder?(bookmark1)).to eq(false)\n      Post.with_deleted.find_by(id: bookmark1.bookmarkable_id).recover!\n      bookmark1.reload\n      bookmark1.bookmarkable.topic.trash!\n      bookmark1.reload\n      expect(registered_bookmarkable.can_send_reminder?(bookmark1)).to eq(false)\n    end\n\n    it \"cannot send reminder if the user cannot access the topic\" do\n      expect(registered_bookmarkable.can_send_reminder?(bookmark1)).to eq(true)\n      bookmark1.bookmarkable.topic.update!(category: private_category)\n      bookmark1.reload\n      expect(registered_bookmarkable.can_send_reminder?(bookmark1)).to eq(false)\n    end\n  end\n\n  describe \"#reminder_handler\" do\n    it \"creates a notification for the user with the correct details\" do\n      expect { registered_bookmarkable.send_reminder_notification(bookmark1) }.to change {\n        Notification.count\n      }.by(1)\n      notif = user.notifications.last\n      expect(notif.notification_type).to eq(Notification.types[:bookmark_reminder])\n      expect(notif.topic_id).to eq(bookmark1.bookmarkable.topic_id)\n      expect(notif.post_number).to eq(bookmark1.bookmarkable.post_number)\n      expect(notif.data).to eq(\n        {\n          title: bookmark1.bookmarkable.topic.title,\n          bookmarkable_url: bookmark1.bookmarkable.url,\n          display_username: bookmark1.user.username,\n          bookmark_name: bookmark1.name,\n          bookmark_id: bookmark1.id,\n        }.to_json,\n      )\n    end\n  end\n\n  describe \"#can_see?\" do\n    it \"returns false if the post is in a private category or private message the user cannot see\" do\n      expect(registered_bookmarkable.can_see?(guardian, bookmark1)).to eq(true)\n      bookmark1.bookmarkable.topic.update(category: private_category)\n      expect(registered_bookmarkable.can_see?(guardian, bookmark1)).to eq(false)\n      bookmark1.bookmarkable.update(topic: Fabricate(:private_message_topic))\n      expect(registered_bookmarkable.can_see?(guardian, bookmark1)).to eq(false)\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\nRSpec.describe TopicBookmarkable do\n  subject(:registered_bookmarkable) { RegisteredBookmarkable.new(TopicBookmarkable) }\n\n  fab!(:user) { Fabricate(:user) }\n  fab!(:private_category) { Fabricate(:private_category, group: Fabricate(:group)) }\n\n  let(:guardian) { Guardian.new(user) }\n\n  let!(:topic1) { Fabricate(:topic) }\n  let!(:topic2) { Fabricate(:topic) }\n  let!(:post) { Fabricate(:post, topic: topic1) }\n  let!(:bookmark1) do\n    Fabricate(:bookmark, user: user, bookmarkable: topic1, name: \"something i gotta do\")\n  end\n  let!(:bookmark2) { Fabricate(:bookmark, user: user, bookmarkable: topic2) }\n  let!(:bookmark3) { Fabricate(:bookmark) }\n  let!(:topic_user1) { Fabricate(:topic_user, user: user, topic: topic1) }\n  let!(:topic_user2) { Fabricate(:topic_user, user: user, topic: topic2) }\n\n  describe \"#perform_list_query\" do\n    it \"returns all the user's bookmarks\" do\n      expect(registered_bookmarkable.perform_list_query(user, guardian).map(&:id)).to match_array(\n        [bookmark1.id, bookmark2.id],\n      )\n    end\n\n    it \"does not return bookmarks for posts where the user does not have access to the topic category\" do\n      bookmark1.bookmarkable.update!(category: private_category)\n      expect(registered_bookmarkable.perform_list_query(user, guardian).map(&:id)).to match_array(\n        [bookmark2.id],\n      )\n    end\n\n    it \"does not return bookmarks for posts where the user does not have access to the private message\" do\n      bookmark1.update!(bookmarkable: Fabricate(:private_message_topic))\n      expect(registered_bookmarkable.perform_list_query(user, guardian).map(&:id)).to match_array(\n        [bookmark2.id],\n      )\n    end\n  end\n\n  describe \"#perform_search_query\" do\n    before { SearchIndexer.enable }\n\n    it \"returns bookmarks that match by name\" do\n      ts_query = Search.ts_query(term: \"gotta\", ts_config: \"simple\")\n      expect(\n        registered_bookmarkable.perform_search_query(\n          registered_bookmarkable.perform_list_query(user, guardian),\n          \"%gotta%\",\n          ts_query,\n        ).map(&:id),\n      ).to match_array([bookmark1.id])\n    end\n\n    it \"returns bookmarks that match by post search data (topic title or post content)\" do\n      post.update(raw: \"some post content\")\n      topic1.update(title: \"a great topic title\")\n\n      ts_query = Search.ts_query(term: \"post content\", ts_config: \"simple\")\n      expect(\n        registered_bookmarkable.perform_search_query(\n          registered_bookmarkable.perform_list_query(user, guardian),\n          \"%post content%\",\n          ts_query,\n        ).map(&:id),\n      ).to match_array([bookmark1.id])\n\n      ts_query = Search.ts_query(term: \"great topic\", ts_config: \"simple\")\n      expect(\n        registered_bookmarkable.perform_search_query(\n          registered_bookmarkable.perform_list_query(user, guardian),\n          \"%great topic%\",\n          ts_query,\n        ).map(&:id),\n      ).to match_array([bookmark1.id])\n\n      ts_query = Search.ts_query(term: \"blah\", ts_config: \"simple\")\n      expect(\n        registered_bookmarkable.perform_search_query(\n          registered_bookmarkable.perform_list_query(user, guardian),\n          \"%blah%\",\n          ts_query,\n        ).map(&:id),\n      ).to eq([])\n    end\n  end\n\n  describe \"#can_send_reminder?\" do\n    it \"cannot send reminder if the topic is deleted\" do\n      expect(registered_bookmarkable.can_send_reminder?(bookmark1)).to eq(true)\n      bookmark1.bookmarkable.trash!\n      bookmark1.reload\n      expect(registered_bookmarkable.can_send_reminder?(bookmark1)).to eq(false)\n    end\n\n    it \"cannot send reminder if the user cannot access the topic\" do\n      expect(registered_bookmarkable.can_send_reminder?(bookmark1)).to eq(true)\n      bookmark1.bookmarkable.update!(category: private_category)\n      bookmark1.reload\n      expect(registered_bookmarkable.can_send_reminder?(bookmark1)).to eq(false)\n    end\n  end\n\n  describe \"#reminder_handler\" do\n    it \"creates a notification for the user with the correct details\" do\n      expect { registered_bookmarkable.send_reminder_notification(bookmark1) }.to change {\n        Notification.count\n      }.by(1)\n      notif = user.notifications.last\n      expect(notif.notification_type).to eq(Notification.types[:bookmark_reminder])\n      expect(notif.topic_id).to eq(bookmark1.bookmarkable_id)\n      expect(notif.post_number).to eq(1)\n      expect(notif.data).to eq(\n        {\n          title: bookmark1.bookmarkable.title,\n          bookmarkable_url: bookmark1.bookmarkable.first_post.url,\n          display_username: bookmark1.user.username,\n          bookmark_name: bookmark1.name,\n          bookmark_id: bookmark1.id,\n        }.to_json,\n      )\n    end\n  end\n\n  describe \"#can_see?\" do\n    it \"returns false if the post is in a private category or private message the user cannot see\" do\n      expect(registered_bookmarkable.can_see?(guardian, bookmark1)).to eq(true)\n      bookmark1.bookmarkable.update!(category: private_category)\n      expect(registered_bookmarkable.can_see?(guardian, bookmark1)).to eq(false)\n      bookmark1.update!(bookmarkable: Fabricate(:private_message_topic))\n      expect(registered_bookmarkable.can_see?(guardian, bookmark1)).to eq(false)\n    end\n  end\nend\n"], "filenames": ["app/controllers/notifications_controller.rb", "app/controllers/users_controller.rb", "app/models/notification.rb", "app/services/post_bookmarkable.rb", "app/services/topic_bookmarkable.rb", "lib/bookmark_query.rb", "plugins/chat/lib/chat/message_bookmarkable.rb", "plugins/chat/spec/lib/chat/message_bookmarkable_spec.rb", "plugins/chat/spec/requests/core_ext/users_controller_spec.rb", "spec/lib/bookmark_query_spec.rb", "spec/requests/users_controller_spec.rb", "spec/services/post_bookmarkable_spec.rb", "spec/services/topic_bookmarkable_spec.rb"], "buggy_code_start_loc": [58, 1799, 229, 15, 15, 90, 14, 118, 24, 107, 6566, 103, 99], "buggy_code_end_loc": [164, 1804, 229, 58, 62, 90, 62, 118, 24, 107, 6612, 103, 99], "fixing_code_start_loc": [58, 1799, 230, 15, 15, 91, 14, 119, 25, 108, 6566, 104, 100], "fixing_code_end_loc": [159, 1800, 236, 59, 62, 115, 63, 126, 54, 110, 6630, 111, 107], "type": "CWE-200", "message": "Discourse is an open source platform for community discussion. Prior to version 3.1.3 of the `stable` branch and version 3.2.0.beta3 of the `beta` and `tests-passed` branches, there is an edge case where a bookmark reminder is sent and an unread notification is generated, but the underlying bookmarkable (e.g. post, topic, chat message) security has changed, making it so the user can no longer access the underlying resource. As of version 3.1.3 of the `stable` branch and version 3.2.0.beta3 of the `beta` and `tests-passed` branches, bookmark reminders are now no longer sent if the user does not have access to the underlying bookmarkable, and also the unread bookmark notifications are always filtered by access. There are no known workarounds.", "other": {"cve": {"id": "CVE-2023-45816", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-10T15:15:08.667", "lastModified": "2023-11-16T19:38:00.193", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse is an open source platform for community discussion. Prior to version 3.1.3 of the `stable` branch and version 3.2.0.beta3 of the `beta` and `tests-passed` branches, there is an edge case where a bookmark reminder is sent and an unread notification is generated, but the underlying bookmarkable (e.g. post, topic, chat message) security has changed, making it so the user can no longer access the underlying resource. As of version 3.1.3 of the `stable` branch and version 3.2.0.beta3 of the `beta` and `tests-passed` branches, bookmark reminders are now no longer sent if the user does not have access to the underlying bookmarkable, and also the unread bookmark notifications are always filtered by access. There are no known workarounds."}, {"lang": "es", "value": "Discourse es una plataforma de c\u00f3digo abierto para el debate comunitario. Antes de la versi\u00f3n 3.1.3 de la rama \"stable\" y la versi\u00f3n 3.2.0.beta3 de las ramas \"beta\" y \"tests-passed\", existe un caso extremo en el que se env\u00eda un recordatorio de marcador y se genera una notificaci\u00f3n de no le\u00eddos. pero la seguridad subyacente de los marcadores (por ejemplo, publicaci\u00f3n, tema, mensaje de chat) ha cambiado, por lo que el usuario ya no puede acceder al recurso subyacente. A partir de la versi\u00f3n 3.1.3 de la rama \"stable\" y la versi\u00f3n 3.2.0.beta3 de las ramas \"beta\" y \"tests-passed\", los recordatorios de marcadores ya no se env\u00edan si el usuario no tiene acceso al marcador subyacente, y adem\u00e1s las notificaciones de marcadores no le\u00eddos siempre se filtran por acceso. No se conocen workarounds."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:stable:*:*:*", "versionEndExcluding": "3.1.3", "matchCriteriaId": "8E31336C-750D-4039-A89F-FF602B59098C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:beta:*:*:*", "versionEndExcluding": "3.2.0", "matchCriteriaId": "E10444D1-B4E6-4EA7-A56E-95BD0FA3E39D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.2.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "1BFF647B-6CEF-43BF-BF5E-C82B557F78E2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.2.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "10D931DE-F8F5-4A34-A30A-FDD4420ABD1A"}]}]}], "references": [{"url": "https://github.com/discourse/discourse/commit/2c45b949ea0e9d6fa8e5af2dd07f6521ede08bf1", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/discourse/discourse/commit/3c5fb871c0f54af47679ae71ad449666b01d8216", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/discourse/discourse/security/advisories/GHSA-v9r6-92wp-f6cf", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse/commit/2c45b949ea0e9d6fa8e5af2dd07f6521ede08bf1"}}