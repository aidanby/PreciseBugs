{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *  pxa3xx-gcu.c - Linux kernel module for PXA3xx graphics controllers\n *\n *  This driver needs a DirectFB counterpart in user space, communication\n *  is handled via mmap()ed memory areas and an ioctl.\n *\n *  Copyright (c) 2009 Daniel Mack <daniel@caiaq.de>\n *  Copyright (c) 2009 Janine Kropp <nin@directfb.org>\n *  Copyright (c) 2009 Denis Oliver Kropp <dok@directfb.org>\n */\n\n/*\n * WARNING: This controller is attached to System Bus 2 of the PXA which\n * needs its arbiter to be enabled explicitly (CKENB & 1<<9).\n * There is currently no way to do this from Linux, so you need to teach\n * your bootloader for now.\n */\n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/miscdevice.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/uaccess.h>\n#include <linux/ioctl.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/fs.h>\n#include <linux/io.h>\n#include <linux/of.h>\n\n#include \"pxa3xx-gcu.h\"\n\n#define DRV_NAME\t\"pxa3xx-gcu\"\n\n#define REG_GCCR\t0x00\n#define GCCR_SYNC_CLR\t(1 << 9)\n#define GCCR_BP_RST\t(1 << 8)\n#define GCCR_ABORT\t(1 << 6)\n#define GCCR_STOP\t(1 << 4)\n\n#define REG_GCISCR\t0x04\n#define REG_GCIECR\t0x08\n#define REG_GCRBBR\t0x20\n#define REG_GCRBLR\t0x24\n#define REG_GCRBHR\t0x28\n#define REG_GCRBTR\t0x2C\n#define REG_GCRBEXHR\t0x30\n\n#define IE_EOB\t\t(1 << 0)\n#define IE_EEOB\t\t(1 << 5)\n#define IE_ALL\t\t0xff\n\n#define SHARED_SIZE\tPAGE_ALIGN(sizeof(struct pxa3xx_gcu_shared))\n\n/* #define PXA3XX_GCU_DEBUG */\n/* #define PXA3XX_GCU_DEBUG_TIMER */\n\n#ifdef PXA3XX_GCU_DEBUG\n#define QDUMP(msg)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tQPRINT(priv, KERN_DEBUG, msg);\t\t\\\n\t} while (0)\n#else\n#define QDUMP(msg)\tdo {} while (0)\n#endif\n\n#define QERROR(msg)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tQPRINT(priv, KERN_ERR, msg);\t\t\\\n\t} while (0)\n\nstruct pxa3xx_gcu_batch {\n\tstruct pxa3xx_gcu_batch *next;\n\tu32\t\t\t*ptr;\n\tdma_addr_t\t\t phys;\n\tunsigned long\t\t length;\n};\n\nstruct pxa3xx_gcu_priv {\n\tstruct device\t\t *dev;\n\tvoid __iomem\t\t *mmio_base;\n\tstruct clk\t\t *clk;\n\tstruct pxa3xx_gcu_shared *shared;\n\tdma_addr_t\t\t  shared_phys;\n\tstruct resource\t\t *resource_mem;\n\tstruct miscdevice\t  misc_dev;\n\twait_queue_head_t\t  wait_idle;\n\twait_queue_head_t\t  wait_free;\n\tspinlock_t\t\t  spinlock;\n\tstruct timespec64\t  base_time;\n\n\tstruct pxa3xx_gcu_batch *free;\n\tstruct pxa3xx_gcu_batch *ready;\n\tstruct pxa3xx_gcu_batch *ready_last;\n\tstruct pxa3xx_gcu_batch *running;\n};\n\nstatic inline unsigned long\ngc_readl(struct pxa3xx_gcu_priv *priv, unsigned int off)\n{\n\treturn __raw_readl(priv->mmio_base + off);\n}\n\nstatic inline void\ngc_writel(struct pxa3xx_gcu_priv *priv, unsigned int off, unsigned long val)\n{\n\t__raw_writel(val, priv->mmio_base + off);\n}\n\n#define QPRINT(priv, level, msg)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tstruct timespec64 ts;\t\t\t\t\t\\\n\t\tstruct pxa3xx_gcu_shared *shared = priv->shared;\t\\\n\t\tu32 base = gc_readl(priv, REG_GCRBBR);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tktime_get_ts64(&ts);\t\t\t\t\t\\\n\t\tts = timespec64_sub(ts, priv->base_time);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tprintk(level \"%lld.%03ld.%03ld - %-17s: %-21s (%s, \"\t\\\n\t\t\t\"STATUS \"\t\t\t\t\t\\\n\t\t\t\"0x%02lx, B 0x%08lx [%ld], E %5ld, H %5ld, \"\t\\\n\t\t\t\"T %5ld)\\n\",\t\t\t\t\t\\\n\t\t\t(s64)(ts.tv_sec),\t\t\t\t\\\n\t\t\tts.tv_nsec / NSEC_PER_MSEC,\t\t\t\\\n\t\t\t(ts.tv_nsec % NSEC_PER_MSEC) / USEC_PER_MSEC,\t\\\n\t\t\t__func__, msg,\t\t\t\t\t\\\n\t\t\tshared->hw_running ? \"running\" : \"   idle\",\t\\\n\t\t\tgc_readl(priv, REG_GCISCR),\t\t\t\\\n\t\t\tgc_readl(priv, REG_GCRBBR),\t\t\t\\\n\t\t\tgc_readl(priv, REG_GCRBLR),\t\t\t\\\n\t\t\t(gc_readl(priv, REG_GCRBEXHR) - base) / 4,\t\\\n\t\t\t(gc_readl(priv, REG_GCRBHR) - base) / 4,\t\\\n\t\t\t(gc_readl(priv, REG_GCRBTR) - base) / 4);\t\\\n\t} while (0)\n\nstatic void\npxa3xx_gcu_reset(struct pxa3xx_gcu_priv *priv)\n{\n\tQDUMP(\"RESET\");\n\n\t/* disable interrupts */\n\tgc_writel(priv, REG_GCIECR, 0);\n\n\t/* reset hardware */\n\tgc_writel(priv, REG_GCCR, GCCR_ABORT);\n\tgc_writel(priv, REG_GCCR, 0);\n\n\tmemset(priv->shared, 0, SHARED_SIZE);\n\tpriv->shared->buffer_phys = priv->shared_phys;\n\tpriv->shared->magic = PXA3XX_GCU_SHARED_MAGIC;\n\n\tktime_get_ts64(&priv->base_time);\n\n\t/* set up the ring buffer pointers */\n\tgc_writel(priv, REG_GCRBLR, 0);\n\tgc_writel(priv, REG_GCRBBR, priv->shared_phys);\n\tgc_writel(priv, REG_GCRBTR, priv->shared_phys);\n\n\t/* enable all IRQs except EOB */\n\tgc_writel(priv, REG_GCIECR, IE_ALL & ~IE_EOB);\n}\n\nstatic void\ndump_whole_state(struct pxa3xx_gcu_priv *priv)\n{\n\tstruct pxa3xx_gcu_shared *sh = priv->shared;\n\tu32 base = gc_readl(priv, REG_GCRBBR);\n\n\tQDUMP(\"DUMP\");\n\n\tprintk(KERN_DEBUG \"== PXA3XX-GCU DUMP ==\\n\"\n\t\t\"%s, STATUS 0x%02lx, B 0x%08lx [%ld], E %5ld, H %5ld, T %5ld\\n\",\n\t\tsh->hw_running ? \"running\" : \"idle   \",\n\t\tgc_readl(priv, REG_GCISCR),\n\t\tgc_readl(priv, REG_GCRBBR),\n\t\tgc_readl(priv, REG_GCRBLR),\n\t\t(gc_readl(priv, REG_GCRBEXHR) - base) / 4,\n\t\t(gc_readl(priv, REG_GCRBHR) - base) / 4,\n\t\t(gc_readl(priv, REG_GCRBTR) - base) / 4);\n}\n\nstatic void\nflush_running(struct pxa3xx_gcu_priv *priv)\n{\n\tstruct pxa3xx_gcu_batch *running = priv->running;\n\tstruct pxa3xx_gcu_batch *next;\n\n\twhile (running) {\n\t\tnext = running->next;\n\t\trunning->next = priv->free;\n\t\tpriv->free = running;\n\t\trunning = next;\n\t}\n\n\tpriv->running = NULL;\n}\n\nstatic void\nrun_ready(struct pxa3xx_gcu_priv *priv)\n{\n\tunsigned int num = 0;\n\tstruct pxa3xx_gcu_shared *shared = priv->shared;\n\tstruct pxa3xx_gcu_batch\t*ready = priv->ready;\n\n\tQDUMP(\"Start\");\n\n\tBUG_ON(!ready);\n\n\tshared->buffer[num++] = 0x05000000;\n\n\twhile (ready) {\n\t\tshared->buffer[num++] = 0x00000001;\n\t\tshared->buffer[num++] = ready->phys;\n\t\tready = ready->next;\n\t}\n\n\tshared->buffer[num++] = 0x05000000;\n\tpriv->running = priv->ready;\n\tpriv->ready = priv->ready_last = NULL;\n\tgc_writel(priv, REG_GCRBLR, 0);\n\tshared->hw_running = 1;\n\n\t/* ring base address */\n\tgc_writel(priv, REG_GCRBBR, shared->buffer_phys);\n\n\t/* ring tail address */\n\tgc_writel(priv, REG_GCRBTR, shared->buffer_phys + num * 4);\n\n\t/* ring length */\n\tgc_writel(priv, REG_GCRBLR, ((num + 63) & ~63) * 4);\n}\n\nstatic irqreturn_t\npxa3xx_gcu_handle_irq(int irq, void *ctx)\n{\n\tstruct pxa3xx_gcu_priv *priv = ctx;\n\tstruct pxa3xx_gcu_shared *shared = priv->shared;\n\tu32 status = gc_readl(priv, REG_GCISCR) & IE_ALL;\n\n\tQDUMP(\"-Interrupt\");\n\n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&priv->spinlock);\n\tshared->num_interrupts++;\n\n\tif (status & IE_EEOB) {\n\t\tQDUMP(\" [EEOB]\");\n\n\t\tflush_running(priv);\n\t\twake_up_all(&priv->wait_free);\n\n\t\tif (priv->ready) {\n\t\t\trun_ready(priv);\n\t\t} else {\n\t\t\t/* There is no more data prepared by the userspace.\n\t\t\t * Set hw_running = 0 and wait for the next userspace\n\t\t\t * kick-off */\n\t\t\tshared->num_idle++;\n\t\t\tshared->hw_running = 0;\n\n\t\t\tQDUMP(\" '-> Idle.\");\n\n\t\t\t/* set ring buffer length to zero */\n\t\t\tgc_writel(priv, REG_GCRBLR, 0);\n\n\t\t\twake_up_all(&priv->wait_idle);\n\t\t}\n\n\t\tshared->num_done++;\n\t} else {\n\t\tQERROR(\" [???]\");\n\t\tdump_whole_state(priv);\n\t}\n\n\t/* Clear the interrupt */\n\tgc_writel(priv, REG_GCISCR, status);\n\tspin_unlock(&priv->spinlock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int\npxa3xx_gcu_wait_idle(struct pxa3xx_gcu_priv *priv)\n{\n\tint ret = 0;\n\n\tQDUMP(\"Waiting for idle...\");\n\n\t/* Does not need to be atomic. There's a lock in user space,\n\t * but anyhow, this is just for statistics. */\n\tpriv->shared->num_wait_idle++;\n\n\twhile (priv->shared->hw_running) {\n\t\tint num = priv->shared->num_interrupts;\n\t\tu32 rbexhr = gc_readl(priv, REG_GCRBEXHR);\n\n\t\tret = wait_event_interruptible_timeout(priv->wait_idle,\n\t\t\t\t\t!priv->shared->hw_running, HZ*4);\n\n\t\tif (ret != 0)\n\t\t\tbreak;\n\n\t\tif (gc_readl(priv, REG_GCRBEXHR) == rbexhr &&\n\t\t    priv->shared->num_interrupts == num) {\n\t\t\tQERROR(\"TIMEOUT\");\n\t\t\tret = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tQDUMP(\"done\");\n\n\treturn ret;\n}\n\nstatic int\npxa3xx_gcu_wait_free(struct pxa3xx_gcu_priv *priv)\n{\n\tint ret = 0;\n\n\tQDUMP(\"Waiting for free...\");\n\n\t/* Does not need to be atomic. There's a lock in user space,\n\t * but anyhow, this is just for statistics. */\n\tpriv->shared->num_wait_free++;\n\n\twhile (!priv->free) {\n\t\tu32 rbexhr = gc_readl(priv, REG_GCRBEXHR);\n\n\t\tret = wait_event_interruptible_timeout(priv->wait_free,\n\t\t\t\t\t\t       priv->free, HZ*4);\n\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tif (ret > 0)\n\t\t\tcontinue;\n\n\t\tif (gc_readl(priv, REG_GCRBEXHR) == rbexhr) {\n\t\t\tQERROR(\"TIMEOUT\");\n\t\t\tret = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tQDUMP(\"done\");\n\n\treturn ret;\n}\n\n/* Misc device layer */\n\nstatic inline struct pxa3xx_gcu_priv *to_pxa3xx_gcu_priv(struct file *file)\n{\n\tstruct miscdevice *dev = file->private_data;\n\treturn container_of(dev, struct pxa3xx_gcu_priv, misc_dev);\n}\n\n/*\n * provide an empty .open callback, so the core sets file->private_data\n * for us.\n */\nstatic int pxa3xx_gcu_open(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}\n\nstatic ssize_t\npxa3xx_gcu_write(struct file *file, const char *buff,\n\t\t size_t count, loff_t *offp)\n{\n\tint ret;\n\tunsigned long flags;\n\tstruct pxa3xx_gcu_batch\t*buffer;\n\tstruct pxa3xx_gcu_priv *priv = to_pxa3xx_gcu_priv(file);\n\n\tint words = count / 4;\n\n\t/* Does not need to be atomic. There's a lock in user space,\n\t * but anyhow, this is just for statistics. */\n\tpriv->shared->num_writes++;\n\tpriv->shared->num_words += words;\n\n\t/* Last word reserved for batch buffer end command */\n\tif (words >= PXA3XX_GCU_BATCH_WORDS)\n\t\treturn -E2BIG;\n\n\t/* Wait for a free buffer */\n\tif (!priv->free) {\n\t\tret = pxa3xx_gcu_wait_free(priv);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * Get buffer from free list\n\t */\n\tspin_lock_irqsave(&priv->spinlock, flags);\n\tbuffer = priv->free;\n\tpriv->free = buffer->next;\n\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\n\n\t/* Copy data from user into buffer */\n\tret = copy_from_user(buffer->ptr, buff, words * 4);\n\tif (ret) {\n\t\tspin_lock_irqsave(&priv->spinlock, flags);\n\t\tbuffer->next = priv->free;\n\t\tpriv->free = buffer;\n\t\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\t\treturn -EFAULT;\n\t}\n\n\tbuffer->length = words;\n\n\t/* Append batch buffer end command */\n\tbuffer->ptr[words] = 0x01000000;\n\n\t/*\n\t * Add buffer to ready list\n\t */\n\tspin_lock_irqsave(&priv->spinlock, flags);\n\n\tbuffer->next = NULL;\n\n\tif (priv->ready) {\n\t\tBUG_ON(priv->ready_last == NULL);\n\n\t\tpriv->ready_last->next = buffer;\n\t} else\n\t\tpriv->ready = buffer;\n\n\tpriv->ready_last = buffer;\n\n\tif (!priv->shared->hw_running)\n\t\trun_ready(priv);\n\n\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\n\treturn words * 4;\n}\n\n\nstatic long\npxa3xx_gcu_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tunsigned long flags;\n\tstruct pxa3xx_gcu_priv *priv = to_pxa3xx_gcu_priv(file);\n\n\tswitch (cmd) {\n\tcase PXA3XX_GCU_IOCTL_RESET:\n\t\tspin_lock_irqsave(&priv->spinlock, flags);\n\t\tpxa3xx_gcu_reset(priv);\n\t\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\t\treturn 0;\n\n\tcase PXA3XX_GCU_IOCTL_WAIT_IDLE:\n\t\treturn pxa3xx_gcu_wait_idle(priv);\n\t}\n\n\treturn -ENOSYS;\n}\n\nstatic int\npxa3xx_gcu_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tunsigned int size = vma->vm_end - vma->vm_start;\n\tstruct pxa3xx_gcu_priv *priv = to_pxa3xx_gcu_priv(file);\n\n\tswitch (vma->vm_pgoff) {\n\tcase 0:\n\t\t/* hand out the shared data area */\n\t\tif (size != SHARED_SIZE)\n\t\t\treturn -EINVAL;\n\n\t\treturn dma_mmap_coherent(priv->dev, vma,\n\t\t\tpriv->shared, priv->shared_phys, size);\n\n\tcase SHARED_SIZE >> PAGE_SHIFT:\n\t\t/* hand out the MMIO base for direct register access\n\t\t * from userspace */\n\t\tif (size != resource_size(priv->resource_mem))\n\t\t\treturn -EINVAL;\n\n\t\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\n\t\treturn io_remap_pfn_range(vma, vma->vm_start,\n\t\t\t\tpriv->resource_mem->start >> PAGE_SHIFT,\n\t\t\t\tsize, vma->vm_page_prot);\n\t}\n\n\treturn -EINVAL;\n}\n\n\n#ifdef PXA3XX_GCU_DEBUG_TIMER\nstatic struct timer_list pxa3xx_gcu_debug_timer;\nstatic struct pxa3xx_gcu_priv *debug_timer_priv;\n\nstatic void pxa3xx_gcu_debug_timedout(struct timer_list *unused)\n{\n\tstruct pxa3xx_gcu_priv *priv = debug_timer_priv;\n\n\tQERROR(\"Timer DUMP\");\n\n\tmod_timer(&pxa3xx_gcu_debug_timer, jiffies + 5 * HZ);\n}\n\nstatic void pxa3xx_gcu_init_debug_timer(struct pxa3xx_gcu_priv *priv)\n{\n\t/* init the timer structure */\n\tdebug_timer_priv = priv;\n\ttimer_setup(&pxa3xx_gcu_debug_timer, pxa3xx_gcu_debug_timedout, 0);\n\tpxa3xx_gcu_debug_timedout(NULL);\n}\n#else\nstatic inline void pxa3xx_gcu_init_debug_timer(struct pxa3xx_gcu_priv *priv) {}\n#endif\n\nstatic int\npxa3xx_gcu_add_buffer(struct device *dev,\n\t\t      struct pxa3xx_gcu_priv *priv)\n{\n\tstruct pxa3xx_gcu_batch *buffer;\n\n\tbuffer = kzalloc(sizeof(struct pxa3xx_gcu_batch), GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tbuffer->ptr = dma_alloc_coherent(dev, PXA3XX_GCU_BATCH_WORDS * 4,\n\t\t\t\t\t &buffer->phys, GFP_KERNEL);\n\tif (!buffer->ptr) {\n\t\tkfree(buffer);\n\t\treturn -ENOMEM;\n\t}\n\n\tbuffer->next = priv->free;\n\tpriv->free = buffer;\n\n\treturn 0;\n}\n\nstatic void\npxa3xx_gcu_free_buffers(struct device *dev,\n\t\t\tstruct pxa3xx_gcu_priv *priv)\n{\n\tstruct pxa3xx_gcu_batch *next, *buffer = priv->free;\n\n\twhile (buffer) {\n\t\tnext = buffer->next;\n\n\t\tdma_free_coherent(dev, PXA3XX_GCU_BATCH_WORDS * 4,\n\t\t\t\t  buffer->ptr, buffer->phys);\n\n\t\tkfree(buffer);\n\t\tbuffer = next;\n\t}\n\n\tpriv->free = NULL;\n}\n\nstatic const struct file_operations pxa3xx_gcu_miscdev_fops = {\n\t.owner =\t\tTHIS_MODULE,\n\t.open =\t\t\tpxa3xx_gcu_open,\n\t.write =\t\tpxa3xx_gcu_write,\n\t.unlocked_ioctl =\tpxa3xx_gcu_ioctl,\n\t.mmap =\t\t\tpxa3xx_gcu_mmap,\n};\n\nstatic int pxa3xx_gcu_probe(struct platform_device *pdev)\n{\n\tint i, ret, irq;\n\tstruct resource *r;\n\tstruct pxa3xx_gcu_priv *priv;\n\tstruct device *dev = &pdev->dev;\n\n\tpriv = devm_kzalloc(dev, sizeof(struct pxa3xx_gcu_priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tinit_waitqueue_head(&priv->wait_idle);\n\tinit_waitqueue_head(&priv->wait_free);\n\tspin_lock_init(&priv->spinlock);\n\n\t/* we allocate the misc device structure as part of our own allocation,\n\t * so we can get a pointer to our priv structure later on with\n\t * container_of(). This isn't really necessary as we have a fixed minor\n\t * number anyway, but this is to avoid statics. */\n\n\tpriv->misc_dev.minor\t= PXA3XX_GCU_MINOR,\n\tpriv->misc_dev.name\t= DRV_NAME,\n\tpriv->misc_dev.fops\t= &pxa3xx_gcu_miscdev_fops;\n\n\t/* handle IO resources */\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tpriv->mmio_base = devm_ioremap_resource(dev, r);\n\tif (IS_ERR(priv->mmio_base))\n\t\treturn PTR_ERR(priv->mmio_base);\n\n\t/* enable the clock */\n\tpriv->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(priv->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->clk), \"failed to get clock\\n\");\n\n\t/* request the IRQ */\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(dev, irq, pxa3xx_gcu_handle_irq,\n\t\t\t       0, DRV_NAME, priv);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"request_irq failed\\n\");\n\t\treturn ret;\n\t}\n\n\t/* allocate dma memory */\n\tpriv->shared = dma_alloc_coherent(dev, SHARED_SIZE,\n\t\t\t\t\t  &priv->shared_phys, GFP_KERNEL);\n\tif (!priv->shared) {\n\t\tdev_err(dev, \"failed to allocate DMA memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* register misc device */\n\tret = misc_register(&priv->misc_dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"misc_register() for minor %d failed\\n\",\n\t\t\tPXA3XX_GCU_MINOR);\n\t\tgoto err_free_dma;\n\t}\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to enable clock\\n\");\n\t\tgoto err_misc_deregister;\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tret = pxa3xx_gcu_add_buffer(dev, priv);\n\t\tif (ret) {\n\t\t\tpxa3xx_gcu_free_buffers(dev, priv);\n\t\t\tdev_err(dev, \"failed to allocate DMA memory\\n\");\n\t\t\tgoto err_disable_clk;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\tpriv->resource_mem = r;\n\tpriv->dev = dev;\n\tpxa3xx_gcu_reset(priv);\n\tpxa3xx_gcu_init_debug_timer(priv);\n\n\tdev_info(dev, \"registered @0x%p, DMA 0x%p (%d bytes), IRQ %d\\n\",\n\t\t\t(void *) r->start, (void *) priv->shared_phys,\n\t\t\tSHARED_SIZE, irq);\n\treturn 0;\n\nerr_disable_clk:\n\tclk_disable_unprepare(priv->clk);\n\nerr_misc_deregister:\n\tmisc_deregister(&priv->misc_dev);\n\nerr_free_dma:\n\tdma_free_coherent(dev, SHARED_SIZE,\n\t\t\t  priv->shared, priv->shared_phys);\n\n\treturn ret;\n}\n\nstatic int pxa3xx_gcu_remove(struct platform_device *pdev)\n{\n\tstruct pxa3xx_gcu_priv *priv = platform_get_drvdata(pdev);\n\tstruct device *dev = &pdev->dev;\n\n\tpxa3xx_gcu_wait_idle(priv);\n\tmisc_deregister(&priv->misc_dev);\n\tdma_free_coherent(dev, SHARED_SIZE, priv->shared, priv->shared_phys);\n\tclk_disable_unprepare(priv->clk);\n\tpxa3xx_gcu_free_buffers(dev, priv);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id pxa3xx_gcu_of_match[] = {\n\t{ .compatible = \"marvell,pxa300-gcu\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, pxa3xx_gcu_of_match);\n#endif\n\nstatic struct platform_driver pxa3xx_gcu_driver = {\n\t.probe\t  = pxa3xx_gcu_probe,\n\t.remove\t = pxa3xx_gcu_remove,\n\t.driver\t = {\n\t\t.name   = DRV_NAME,\n\t\t.of_match_table = of_match_ptr(pxa3xx_gcu_of_match),\n\t},\n};\n\nmodule_platform_driver(pxa3xx_gcu_driver);\n\nMODULE_DESCRIPTION(\"PXA3xx graphics controller unit driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_MISCDEV(PXA3XX_GCU_MINOR);\nMODULE_AUTHOR(\"Janine Kropp <nin@directfb.org>, \"\n\t\t\"Denis Oliver Kropp <dok@directfb.org>, \"\n\t\t\"Daniel Mack <daniel@caiaq.de>\");\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *  pxa3xx-gcu.c - Linux kernel module for PXA3xx graphics controllers\n *\n *  This driver needs a DirectFB counterpart in user space, communication\n *  is handled via mmap()ed memory areas and an ioctl.\n *\n *  Copyright (c) 2009 Daniel Mack <daniel@caiaq.de>\n *  Copyright (c) 2009 Janine Kropp <nin@directfb.org>\n *  Copyright (c) 2009 Denis Oliver Kropp <dok@directfb.org>\n */\n\n/*\n * WARNING: This controller is attached to System Bus 2 of the PXA which\n * needs its arbiter to be enabled explicitly (CKENB & 1<<9).\n * There is currently no way to do this from Linux, so you need to teach\n * your bootloader for now.\n */\n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/miscdevice.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/uaccess.h>\n#include <linux/ioctl.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/fs.h>\n#include <linux/io.h>\n#include <linux/of.h>\n\n#include \"pxa3xx-gcu.h\"\n\n#define DRV_NAME\t\"pxa3xx-gcu\"\n\n#define REG_GCCR\t0x00\n#define GCCR_SYNC_CLR\t(1 << 9)\n#define GCCR_BP_RST\t(1 << 8)\n#define GCCR_ABORT\t(1 << 6)\n#define GCCR_STOP\t(1 << 4)\n\n#define REG_GCISCR\t0x04\n#define REG_GCIECR\t0x08\n#define REG_GCRBBR\t0x20\n#define REG_GCRBLR\t0x24\n#define REG_GCRBHR\t0x28\n#define REG_GCRBTR\t0x2C\n#define REG_GCRBEXHR\t0x30\n\n#define IE_EOB\t\t(1 << 0)\n#define IE_EEOB\t\t(1 << 5)\n#define IE_ALL\t\t0xff\n\n#define SHARED_SIZE\tPAGE_ALIGN(sizeof(struct pxa3xx_gcu_shared))\n\n/* #define PXA3XX_GCU_DEBUG */\n/* #define PXA3XX_GCU_DEBUG_TIMER */\n\n#ifdef PXA3XX_GCU_DEBUG\n#define QDUMP(msg)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tQPRINT(priv, KERN_DEBUG, msg);\t\t\\\n\t} while (0)\n#else\n#define QDUMP(msg)\tdo {} while (0)\n#endif\n\n#define QERROR(msg)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tQPRINT(priv, KERN_ERR, msg);\t\t\\\n\t} while (0)\n\nstruct pxa3xx_gcu_batch {\n\tstruct pxa3xx_gcu_batch *next;\n\tu32\t\t\t*ptr;\n\tdma_addr_t\t\t phys;\n\tunsigned long\t\t length;\n};\n\nstruct pxa3xx_gcu_priv {\n\tstruct device\t\t *dev;\n\tvoid __iomem\t\t *mmio_base;\n\tstruct clk\t\t *clk;\n\tstruct pxa3xx_gcu_shared *shared;\n\tdma_addr_t\t\t  shared_phys;\n\tstruct resource\t\t *resource_mem;\n\tstruct miscdevice\t  misc_dev;\n\twait_queue_head_t\t  wait_idle;\n\twait_queue_head_t\t  wait_free;\n\tspinlock_t\t\t  spinlock;\n\tstruct timespec64\t  base_time;\n\n\tstruct pxa3xx_gcu_batch *free;\n\tstruct pxa3xx_gcu_batch *ready;\n\tstruct pxa3xx_gcu_batch *ready_last;\n\tstruct pxa3xx_gcu_batch *running;\n};\n\nstatic inline unsigned long\ngc_readl(struct pxa3xx_gcu_priv *priv, unsigned int off)\n{\n\treturn __raw_readl(priv->mmio_base + off);\n}\n\nstatic inline void\ngc_writel(struct pxa3xx_gcu_priv *priv, unsigned int off, unsigned long val)\n{\n\t__raw_writel(val, priv->mmio_base + off);\n}\n\n#define QPRINT(priv, level, msg)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tstruct timespec64 ts;\t\t\t\t\t\\\n\t\tstruct pxa3xx_gcu_shared *shared = priv->shared;\t\\\n\t\tu32 base = gc_readl(priv, REG_GCRBBR);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tktime_get_ts64(&ts);\t\t\t\t\t\\\n\t\tts = timespec64_sub(ts, priv->base_time);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tprintk(level \"%lld.%03ld.%03ld - %-17s: %-21s (%s, \"\t\\\n\t\t\t\"STATUS \"\t\t\t\t\t\\\n\t\t\t\"0x%02lx, B 0x%08lx [%ld], E %5ld, H %5ld, \"\t\\\n\t\t\t\"T %5ld)\\n\",\t\t\t\t\t\\\n\t\t\t(s64)(ts.tv_sec),\t\t\t\t\\\n\t\t\tts.tv_nsec / NSEC_PER_MSEC,\t\t\t\\\n\t\t\t(ts.tv_nsec % NSEC_PER_MSEC) / USEC_PER_MSEC,\t\\\n\t\t\t__func__, msg,\t\t\t\t\t\\\n\t\t\tshared->hw_running ? \"running\" : \"   idle\",\t\\\n\t\t\tgc_readl(priv, REG_GCISCR),\t\t\t\\\n\t\t\tgc_readl(priv, REG_GCRBBR),\t\t\t\\\n\t\t\tgc_readl(priv, REG_GCRBLR),\t\t\t\\\n\t\t\t(gc_readl(priv, REG_GCRBEXHR) - base) / 4,\t\\\n\t\t\t(gc_readl(priv, REG_GCRBHR) - base) / 4,\t\\\n\t\t\t(gc_readl(priv, REG_GCRBTR) - base) / 4);\t\\\n\t} while (0)\n\nstatic void\npxa3xx_gcu_reset(struct pxa3xx_gcu_priv *priv)\n{\n\tQDUMP(\"RESET\");\n\n\t/* disable interrupts */\n\tgc_writel(priv, REG_GCIECR, 0);\n\n\t/* reset hardware */\n\tgc_writel(priv, REG_GCCR, GCCR_ABORT);\n\tgc_writel(priv, REG_GCCR, 0);\n\n\tmemset(priv->shared, 0, SHARED_SIZE);\n\tpriv->shared->buffer_phys = priv->shared_phys;\n\tpriv->shared->magic = PXA3XX_GCU_SHARED_MAGIC;\n\n\tktime_get_ts64(&priv->base_time);\n\n\t/* set up the ring buffer pointers */\n\tgc_writel(priv, REG_GCRBLR, 0);\n\tgc_writel(priv, REG_GCRBBR, priv->shared_phys);\n\tgc_writel(priv, REG_GCRBTR, priv->shared_phys);\n\n\t/* enable all IRQs except EOB */\n\tgc_writel(priv, REG_GCIECR, IE_ALL & ~IE_EOB);\n}\n\nstatic void\ndump_whole_state(struct pxa3xx_gcu_priv *priv)\n{\n\tstruct pxa3xx_gcu_shared *sh = priv->shared;\n\tu32 base = gc_readl(priv, REG_GCRBBR);\n\n\tQDUMP(\"DUMP\");\n\n\tprintk(KERN_DEBUG \"== PXA3XX-GCU DUMP ==\\n\"\n\t\t\"%s, STATUS 0x%02lx, B 0x%08lx [%ld], E %5ld, H %5ld, T %5ld\\n\",\n\t\tsh->hw_running ? \"running\" : \"idle   \",\n\t\tgc_readl(priv, REG_GCISCR),\n\t\tgc_readl(priv, REG_GCRBBR),\n\t\tgc_readl(priv, REG_GCRBLR),\n\t\t(gc_readl(priv, REG_GCRBEXHR) - base) / 4,\n\t\t(gc_readl(priv, REG_GCRBHR) - base) / 4,\n\t\t(gc_readl(priv, REG_GCRBTR) - base) / 4);\n}\n\nstatic void\nflush_running(struct pxa3xx_gcu_priv *priv)\n{\n\tstruct pxa3xx_gcu_batch *running = priv->running;\n\tstruct pxa3xx_gcu_batch *next;\n\n\twhile (running) {\n\t\tnext = running->next;\n\t\trunning->next = priv->free;\n\t\tpriv->free = running;\n\t\trunning = next;\n\t}\n\n\tpriv->running = NULL;\n}\n\nstatic void\nrun_ready(struct pxa3xx_gcu_priv *priv)\n{\n\tunsigned int num = 0;\n\tstruct pxa3xx_gcu_shared *shared = priv->shared;\n\tstruct pxa3xx_gcu_batch\t*ready = priv->ready;\n\n\tQDUMP(\"Start\");\n\n\tBUG_ON(!ready);\n\n\tshared->buffer[num++] = 0x05000000;\n\n\twhile (ready) {\n\t\tshared->buffer[num++] = 0x00000001;\n\t\tshared->buffer[num++] = ready->phys;\n\t\tready = ready->next;\n\t}\n\n\tshared->buffer[num++] = 0x05000000;\n\tpriv->running = priv->ready;\n\tpriv->ready = priv->ready_last = NULL;\n\tgc_writel(priv, REG_GCRBLR, 0);\n\tshared->hw_running = 1;\n\n\t/* ring base address */\n\tgc_writel(priv, REG_GCRBBR, shared->buffer_phys);\n\n\t/* ring tail address */\n\tgc_writel(priv, REG_GCRBTR, shared->buffer_phys + num * 4);\n\n\t/* ring length */\n\tgc_writel(priv, REG_GCRBLR, ((num + 63) & ~63) * 4);\n}\n\nstatic irqreturn_t\npxa3xx_gcu_handle_irq(int irq, void *ctx)\n{\n\tstruct pxa3xx_gcu_priv *priv = ctx;\n\tstruct pxa3xx_gcu_shared *shared = priv->shared;\n\tu32 status = gc_readl(priv, REG_GCISCR) & IE_ALL;\n\n\tQDUMP(\"-Interrupt\");\n\n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&priv->spinlock);\n\tshared->num_interrupts++;\n\n\tif (status & IE_EEOB) {\n\t\tQDUMP(\" [EEOB]\");\n\n\t\tflush_running(priv);\n\t\twake_up_all(&priv->wait_free);\n\n\t\tif (priv->ready) {\n\t\t\trun_ready(priv);\n\t\t} else {\n\t\t\t/* There is no more data prepared by the userspace.\n\t\t\t * Set hw_running = 0 and wait for the next userspace\n\t\t\t * kick-off */\n\t\t\tshared->num_idle++;\n\t\t\tshared->hw_running = 0;\n\n\t\t\tQDUMP(\" '-> Idle.\");\n\n\t\t\t/* set ring buffer length to zero */\n\t\t\tgc_writel(priv, REG_GCRBLR, 0);\n\n\t\t\twake_up_all(&priv->wait_idle);\n\t\t}\n\n\t\tshared->num_done++;\n\t} else {\n\t\tQERROR(\" [???]\");\n\t\tdump_whole_state(priv);\n\t}\n\n\t/* Clear the interrupt */\n\tgc_writel(priv, REG_GCISCR, status);\n\tspin_unlock(&priv->spinlock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int\npxa3xx_gcu_wait_idle(struct pxa3xx_gcu_priv *priv)\n{\n\tint ret = 0;\n\n\tQDUMP(\"Waiting for idle...\");\n\n\t/* Does not need to be atomic. There's a lock in user space,\n\t * but anyhow, this is just for statistics. */\n\tpriv->shared->num_wait_idle++;\n\n\twhile (priv->shared->hw_running) {\n\t\tint num = priv->shared->num_interrupts;\n\t\tu32 rbexhr = gc_readl(priv, REG_GCRBEXHR);\n\n\t\tret = wait_event_interruptible_timeout(priv->wait_idle,\n\t\t\t\t\t!priv->shared->hw_running, HZ*4);\n\n\t\tif (ret != 0)\n\t\t\tbreak;\n\n\t\tif (gc_readl(priv, REG_GCRBEXHR) == rbexhr &&\n\t\t    priv->shared->num_interrupts == num) {\n\t\t\tQERROR(\"TIMEOUT\");\n\t\t\tret = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tQDUMP(\"done\");\n\n\treturn ret;\n}\n\nstatic int\npxa3xx_gcu_wait_free(struct pxa3xx_gcu_priv *priv)\n{\n\tint ret = 0;\n\n\tQDUMP(\"Waiting for free...\");\n\n\t/* Does not need to be atomic. There's a lock in user space,\n\t * but anyhow, this is just for statistics. */\n\tpriv->shared->num_wait_free++;\n\n\twhile (!priv->free) {\n\t\tu32 rbexhr = gc_readl(priv, REG_GCRBEXHR);\n\n\t\tret = wait_event_interruptible_timeout(priv->wait_free,\n\t\t\t\t\t\t       priv->free, HZ*4);\n\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tif (ret > 0)\n\t\t\tcontinue;\n\n\t\tif (gc_readl(priv, REG_GCRBEXHR) == rbexhr) {\n\t\t\tQERROR(\"TIMEOUT\");\n\t\t\tret = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tQDUMP(\"done\");\n\n\treturn ret;\n}\n\n/* Misc device layer */\n\nstatic inline struct pxa3xx_gcu_priv *to_pxa3xx_gcu_priv(struct file *file)\n{\n\tstruct miscdevice *dev = file->private_data;\n\treturn container_of(dev, struct pxa3xx_gcu_priv, misc_dev);\n}\n\n/*\n * provide an empty .open callback, so the core sets file->private_data\n * for us.\n */\nstatic int pxa3xx_gcu_open(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}\n\nstatic ssize_t\npxa3xx_gcu_write(struct file *file, const char *buff,\n\t\t size_t count, loff_t *offp)\n{\n\tint ret;\n\tunsigned long flags;\n\tstruct pxa3xx_gcu_batch\t*buffer;\n\tstruct pxa3xx_gcu_priv *priv = to_pxa3xx_gcu_priv(file);\n\n\tsize_t words = count / 4;\n\n\t/* Does not need to be atomic. There's a lock in user space,\n\t * but anyhow, this is just for statistics. */\n\tpriv->shared->num_writes++;\n\tpriv->shared->num_words += words;\n\n\t/* Last word reserved for batch buffer end command */\n\tif (words >= PXA3XX_GCU_BATCH_WORDS)\n\t\treturn -E2BIG;\n\n\t/* Wait for a free buffer */\n\tif (!priv->free) {\n\t\tret = pxa3xx_gcu_wait_free(priv);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * Get buffer from free list\n\t */\n\tspin_lock_irqsave(&priv->spinlock, flags);\n\tbuffer = priv->free;\n\tpriv->free = buffer->next;\n\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\n\n\t/* Copy data from user into buffer */\n\tret = copy_from_user(buffer->ptr, buff, words * 4);\n\tif (ret) {\n\t\tspin_lock_irqsave(&priv->spinlock, flags);\n\t\tbuffer->next = priv->free;\n\t\tpriv->free = buffer;\n\t\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\t\treturn -EFAULT;\n\t}\n\n\tbuffer->length = words;\n\n\t/* Append batch buffer end command */\n\tbuffer->ptr[words] = 0x01000000;\n\n\t/*\n\t * Add buffer to ready list\n\t */\n\tspin_lock_irqsave(&priv->spinlock, flags);\n\n\tbuffer->next = NULL;\n\n\tif (priv->ready) {\n\t\tBUG_ON(priv->ready_last == NULL);\n\n\t\tpriv->ready_last->next = buffer;\n\t} else\n\t\tpriv->ready = buffer;\n\n\tpriv->ready_last = buffer;\n\n\tif (!priv->shared->hw_running)\n\t\trun_ready(priv);\n\n\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\n\treturn words * 4;\n}\n\n\nstatic long\npxa3xx_gcu_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tunsigned long flags;\n\tstruct pxa3xx_gcu_priv *priv = to_pxa3xx_gcu_priv(file);\n\n\tswitch (cmd) {\n\tcase PXA3XX_GCU_IOCTL_RESET:\n\t\tspin_lock_irqsave(&priv->spinlock, flags);\n\t\tpxa3xx_gcu_reset(priv);\n\t\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\t\treturn 0;\n\n\tcase PXA3XX_GCU_IOCTL_WAIT_IDLE:\n\t\treturn pxa3xx_gcu_wait_idle(priv);\n\t}\n\n\treturn -ENOSYS;\n}\n\nstatic int\npxa3xx_gcu_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tunsigned int size = vma->vm_end - vma->vm_start;\n\tstruct pxa3xx_gcu_priv *priv = to_pxa3xx_gcu_priv(file);\n\n\tswitch (vma->vm_pgoff) {\n\tcase 0:\n\t\t/* hand out the shared data area */\n\t\tif (size != SHARED_SIZE)\n\t\t\treturn -EINVAL;\n\n\t\treturn dma_mmap_coherent(priv->dev, vma,\n\t\t\tpriv->shared, priv->shared_phys, size);\n\n\tcase SHARED_SIZE >> PAGE_SHIFT:\n\t\t/* hand out the MMIO base for direct register access\n\t\t * from userspace */\n\t\tif (size != resource_size(priv->resource_mem))\n\t\t\treturn -EINVAL;\n\n\t\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\n\t\treturn io_remap_pfn_range(vma, vma->vm_start,\n\t\t\t\tpriv->resource_mem->start >> PAGE_SHIFT,\n\t\t\t\tsize, vma->vm_page_prot);\n\t}\n\n\treturn -EINVAL;\n}\n\n\n#ifdef PXA3XX_GCU_DEBUG_TIMER\nstatic struct timer_list pxa3xx_gcu_debug_timer;\nstatic struct pxa3xx_gcu_priv *debug_timer_priv;\n\nstatic void pxa3xx_gcu_debug_timedout(struct timer_list *unused)\n{\n\tstruct pxa3xx_gcu_priv *priv = debug_timer_priv;\n\n\tQERROR(\"Timer DUMP\");\n\n\tmod_timer(&pxa3xx_gcu_debug_timer, jiffies + 5 * HZ);\n}\n\nstatic void pxa3xx_gcu_init_debug_timer(struct pxa3xx_gcu_priv *priv)\n{\n\t/* init the timer structure */\n\tdebug_timer_priv = priv;\n\ttimer_setup(&pxa3xx_gcu_debug_timer, pxa3xx_gcu_debug_timedout, 0);\n\tpxa3xx_gcu_debug_timedout(NULL);\n}\n#else\nstatic inline void pxa3xx_gcu_init_debug_timer(struct pxa3xx_gcu_priv *priv) {}\n#endif\n\nstatic int\npxa3xx_gcu_add_buffer(struct device *dev,\n\t\t      struct pxa3xx_gcu_priv *priv)\n{\n\tstruct pxa3xx_gcu_batch *buffer;\n\n\tbuffer = kzalloc(sizeof(struct pxa3xx_gcu_batch), GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tbuffer->ptr = dma_alloc_coherent(dev, PXA3XX_GCU_BATCH_WORDS * 4,\n\t\t\t\t\t &buffer->phys, GFP_KERNEL);\n\tif (!buffer->ptr) {\n\t\tkfree(buffer);\n\t\treturn -ENOMEM;\n\t}\n\n\tbuffer->next = priv->free;\n\tpriv->free = buffer;\n\n\treturn 0;\n}\n\nstatic void\npxa3xx_gcu_free_buffers(struct device *dev,\n\t\t\tstruct pxa3xx_gcu_priv *priv)\n{\n\tstruct pxa3xx_gcu_batch *next, *buffer = priv->free;\n\n\twhile (buffer) {\n\t\tnext = buffer->next;\n\n\t\tdma_free_coherent(dev, PXA3XX_GCU_BATCH_WORDS * 4,\n\t\t\t\t  buffer->ptr, buffer->phys);\n\n\t\tkfree(buffer);\n\t\tbuffer = next;\n\t}\n\n\tpriv->free = NULL;\n}\n\nstatic const struct file_operations pxa3xx_gcu_miscdev_fops = {\n\t.owner =\t\tTHIS_MODULE,\n\t.open =\t\t\tpxa3xx_gcu_open,\n\t.write =\t\tpxa3xx_gcu_write,\n\t.unlocked_ioctl =\tpxa3xx_gcu_ioctl,\n\t.mmap =\t\t\tpxa3xx_gcu_mmap,\n};\n\nstatic int pxa3xx_gcu_probe(struct platform_device *pdev)\n{\n\tint i, ret, irq;\n\tstruct resource *r;\n\tstruct pxa3xx_gcu_priv *priv;\n\tstruct device *dev = &pdev->dev;\n\n\tpriv = devm_kzalloc(dev, sizeof(struct pxa3xx_gcu_priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tinit_waitqueue_head(&priv->wait_idle);\n\tinit_waitqueue_head(&priv->wait_free);\n\tspin_lock_init(&priv->spinlock);\n\n\t/* we allocate the misc device structure as part of our own allocation,\n\t * so we can get a pointer to our priv structure later on with\n\t * container_of(). This isn't really necessary as we have a fixed minor\n\t * number anyway, but this is to avoid statics. */\n\n\tpriv->misc_dev.minor\t= PXA3XX_GCU_MINOR,\n\tpriv->misc_dev.name\t= DRV_NAME,\n\tpriv->misc_dev.fops\t= &pxa3xx_gcu_miscdev_fops;\n\n\t/* handle IO resources */\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tpriv->mmio_base = devm_ioremap_resource(dev, r);\n\tif (IS_ERR(priv->mmio_base))\n\t\treturn PTR_ERR(priv->mmio_base);\n\n\t/* enable the clock */\n\tpriv->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(priv->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->clk), \"failed to get clock\\n\");\n\n\t/* request the IRQ */\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(dev, irq, pxa3xx_gcu_handle_irq,\n\t\t\t       0, DRV_NAME, priv);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"request_irq failed\\n\");\n\t\treturn ret;\n\t}\n\n\t/* allocate dma memory */\n\tpriv->shared = dma_alloc_coherent(dev, SHARED_SIZE,\n\t\t\t\t\t  &priv->shared_phys, GFP_KERNEL);\n\tif (!priv->shared) {\n\t\tdev_err(dev, \"failed to allocate DMA memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* register misc device */\n\tret = misc_register(&priv->misc_dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"misc_register() for minor %d failed\\n\",\n\t\t\tPXA3XX_GCU_MINOR);\n\t\tgoto err_free_dma;\n\t}\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to enable clock\\n\");\n\t\tgoto err_misc_deregister;\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tret = pxa3xx_gcu_add_buffer(dev, priv);\n\t\tif (ret) {\n\t\t\tpxa3xx_gcu_free_buffers(dev, priv);\n\t\t\tdev_err(dev, \"failed to allocate DMA memory\\n\");\n\t\t\tgoto err_disable_clk;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\tpriv->resource_mem = r;\n\tpriv->dev = dev;\n\tpxa3xx_gcu_reset(priv);\n\tpxa3xx_gcu_init_debug_timer(priv);\n\n\tdev_info(dev, \"registered @0x%p, DMA 0x%p (%d bytes), IRQ %d\\n\",\n\t\t\t(void *) r->start, (void *) priv->shared_phys,\n\t\t\tSHARED_SIZE, irq);\n\treturn 0;\n\nerr_disable_clk:\n\tclk_disable_unprepare(priv->clk);\n\nerr_misc_deregister:\n\tmisc_deregister(&priv->misc_dev);\n\nerr_free_dma:\n\tdma_free_coherent(dev, SHARED_SIZE,\n\t\t\t  priv->shared, priv->shared_phys);\n\n\treturn ret;\n}\n\nstatic int pxa3xx_gcu_remove(struct platform_device *pdev)\n{\n\tstruct pxa3xx_gcu_priv *priv = platform_get_drvdata(pdev);\n\tstruct device *dev = &pdev->dev;\n\n\tpxa3xx_gcu_wait_idle(priv);\n\tmisc_deregister(&priv->misc_dev);\n\tdma_free_coherent(dev, SHARED_SIZE, priv->shared, priv->shared_phys);\n\tclk_disable_unprepare(priv->clk);\n\tpxa3xx_gcu_free_buffers(dev, priv);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id pxa3xx_gcu_of_match[] = {\n\t{ .compatible = \"marvell,pxa300-gcu\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, pxa3xx_gcu_of_match);\n#endif\n\nstatic struct platform_driver pxa3xx_gcu_driver = {\n\t.probe\t  = pxa3xx_gcu_probe,\n\t.remove\t = pxa3xx_gcu_remove,\n\t.driver\t = {\n\t\t.name   = DRV_NAME,\n\t\t.of_match_table = of_match_ptr(pxa3xx_gcu_of_match),\n\t},\n};\n\nmodule_platform_driver(pxa3xx_gcu_driver);\n\nMODULE_DESCRIPTION(\"PXA3xx graphics controller unit driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_MISCDEV(PXA3XX_GCU_MINOR);\nMODULE_AUTHOR(\"Janine Kropp <nin@directfb.org>, \"\n\t\t\"Denis Oliver Kropp <dok@directfb.org>, \"\n\t\t\"Daniel Mack <daniel@caiaq.de>\");\n"], "filenames": ["drivers/video/fbdev/pxa3xx-gcu.c"], "buggy_code_start_loc": [384], "buggy_code_end_loc": [385], "fixing_code_start_loc": [384], "fixing_code_end_loc": [385], "type": "CWE-190", "message": "** DISPUTED ** An issue was discovered in the Linux kernel before 5.19. In pxa3xx_gcu_write in drivers/video/fbdev/pxa3xx-gcu.c, the count parameter has a type conflict of size_t versus int, causing an integer overflow and bypassing the size check. After that, because it is used as the third argument to copy_from_user(), a heap overflow may occur. NOTE: the original discoverer disputes that the overflow can actually happen.", "other": {"cve": {"id": "CVE-2022-39842", "sourceIdentifier": "cve@mitre.org", "published": "2022-09-05T07:15:08.170", "lastModified": "2023-03-01T16:31:15.527", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "** DISPUTED ** An issue was discovered in the Linux kernel before 5.19. In pxa3xx_gcu_write in drivers/video/fbdev/pxa3xx-gcu.c, the count parameter has a type conflict of size_t versus int, causing an integer overflow and bypassing the size check. After that, because it is used as the third argument to copy_from_user(), a heap overflow may occur. NOTE: the original discoverer disputes that the overflow can actually happen."}, {"lang": "es", "value": "Se ha detectado un problema en el kernel de Linux versiones anteriores a 5.19. En la funci\u00f3n pxa3xx_gcu_write en el archivo drivers/video/fbdev/pxa3xx-gcu.c, el par\u00e1metro count presenta un conflicto de tipo size_t frente a int, causando un desbordamiento de enteros y omite la comprobaci\u00f3n de tama\u00f1o. Adem\u00e1s, al ser usado como tercer argumento de copy_from_user(), puede producirse un desbordamiento de pila"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 4.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.19", "matchCriteriaId": "E74E9AF8-BDF5-4917-A9CA-0AAD8E13149B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.19:rc1:*:*:*:*:*:*", "matchCriteriaId": "A8C30C2D-F82D-4D37-AB48-D76ABFBD5377"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.19:rc2:*:*:*:*:*:*", "matchCriteriaId": "BF8547FC-C849-4F1B-804B-A93AE2F04A92"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.19:rc3:*:*:*:*:*:*", "matchCriteriaId": "F3068028-F453-4A1C-B80F-3F5609ACEF60"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.19", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/a09d2d00af53b43c6f11e6ab3cb58443c2cac8a7", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/10/msg00000.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00001.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lore.kernel.org/all/YylaC1wHHyLw22D3@kadam/T/", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5257", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/a09d2d00af53b43c6f11e6ab3cb58443c2cac8a7"}}