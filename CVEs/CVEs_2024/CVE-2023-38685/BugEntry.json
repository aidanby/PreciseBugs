{"buggy_code": ["# frozen_string_literal: true\n\nclass Topic < ActiveRecord::Base\n  class UserExists < StandardError\n  end\n  class NotAllowed < StandardError\n  end\n  include RateLimiter::OnCreateRecord\n  include HasCustomFields\n  include Trashable\n  include Searchable\n  include LimitedEdit\n  extend Forwardable\n\n  EXTERNAL_ID_MAX_LENGTH = 50\n\n  self.ignored_columns = [\n    \"avg_time\", # TODO(2021-01-04): remove\n    \"image_url\", # TODO(2021-06-01): remove\n  ]\n\n  def_delegator :featured_users, :user_ids, :featured_user_ids\n  def_delegator :featured_users, :choose, :feature_topic_users\n\n  def_delegator :notifier, :watch!, :notify_watch!\n  def_delegator :notifier, :track!, :notify_tracking!\n  def_delegator :notifier, :regular!, :notify_regular!\n  def_delegator :notifier, :mute!, :notify_muted!\n  def_delegator :notifier, :toggle_mute, :toggle_mute\n\n  attr_accessor :allowed_user_ids, :allowed_group_ids, :tags_changed, :includes_destination_category\n\n  def self.max_fancy_title_length\n    400\n  end\n\n  def self.share_thumbnail_size\n    [1024, 1024]\n  end\n\n  def self.thumbnail_sizes\n    [self.share_thumbnail_size] + DiscoursePluginRegistry.topic_thumbnail_sizes\n  end\n\n  def thumbnail_job_redis_key(sizes)\n    \"generate_topic_thumbnail_enqueue_#{id}_#{sizes.inspect}\"\n  end\n\n  def filtered_topic_thumbnails(extra_sizes: [])\n    return nil unless original = image_upload\n    return nil unless original.read_attribute(:width) && original.read_attribute(:height)\n\n    thumbnail_sizes = Topic.thumbnail_sizes + extra_sizes\n    topic_thumbnails.filter do |record|\n      thumbnail_sizes.include?([record.max_width, record.max_height])\n    end\n  end\n\n  def thumbnail_info(enqueue_if_missing: false, extra_sizes: [])\n    return nil unless original = image_upload\n    return nil if original.filesize >= SiteSetting.max_image_size_kb.kilobytes\n    return nil unless original.read_attribute(:width) && original.read_attribute(:height)\n\n    infos = []\n    infos << { # Always add original\n      max_width: nil,\n      max_height: nil,\n      width: original.width,\n      height: original.height,\n      url: original.url,\n    }\n\n    records = filtered_topic_thumbnails(extra_sizes: extra_sizes)\n\n    records.each do |record|\n      next unless record.optimized_image # Only serialize successful thumbnails\n\n      infos << {\n        max_width: record.max_width,\n        max_height: record.max_height,\n        width: record.optimized_image&.width,\n        height: record.optimized_image&.height,\n        url: record.optimized_image&.url,\n      }\n    end\n\n    thumbnail_sizes = Topic.thumbnail_sizes + extra_sizes\n    if SiteSetting.create_thumbnails && enqueue_if_missing &&\n         records.length < thumbnail_sizes.length &&\n         Discourse.redis.set(thumbnail_job_redis_key(extra_sizes), 1, nx: true, ex: 1.minute)\n      Jobs.enqueue(:generate_topic_thumbnails, { topic_id: id, extra_sizes: extra_sizes })\n    end\n\n    infos.each { |i| i[:url] = UrlHelper.cook_url(i[:url], secure: original.secure?, local: true) }\n\n    infos.sort_by! { |i| -i[:width] * i[:height] }\n  end\n\n  def generate_thumbnails!(extra_sizes: [])\n    return nil unless SiteSetting.create_thumbnails\n    return nil unless original = image_upload\n    return nil if original.filesize >= SiteSetting.max_image_size_kb.kilobytes\n    return nil unless original.width && original.height\n    extra_sizes = [] unless extra_sizes.kind_of?(Array)\n\n    (Topic.thumbnail_sizes + extra_sizes).each do |dim|\n      TopicThumbnail.find_or_create_for!(original, max_width: dim[0], max_height: dim[1])\n    end\n  end\n\n  def image_url(enqueue_if_missing: false)\n    thumbnail =\n      topic_thumbnails.detect do |record|\n        record.max_width == Topic.share_thumbnail_size[0] &&\n          record.max_height == Topic.share_thumbnail_size[1]\n      end\n\n    if thumbnail.nil? && image_upload && SiteSetting.create_thumbnails &&\n         image_upload.filesize < SiteSetting.max_image_size_kb.kilobytes &&\n         image_upload.read_attribute(:width) && image_upload.read_attribute(:height) &&\n         enqueue_if_missing &&\n         Discourse.redis.set(thumbnail_job_redis_key([]), 1, nx: true, ex: 1.minute)\n      Jobs.enqueue(:generate_topic_thumbnails, { topic_id: id })\n    end\n\n    raw_url = thumbnail&.optimized_image&.url || image_upload&.url\n    UrlHelper.cook_url(raw_url, secure: image_upload&.secure?, local: true) if raw_url\n  end\n\n  def featured_users\n    @featured_users ||= TopicFeaturedUsers.new(self)\n  end\n\n  def trash!(trashed_by = nil)\n    trigger_event = false\n\n    if deleted_at.nil?\n      update_category_topic_count_by(-1) if visible?\n      CategoryTagStat.topic_deleted(self) if self.tags.present?\n      trigger_event = true\n    end\n\n    super(trashed_by)\n\n    DiscourseEvent.trigger(:topic_trashed, self) if trigger_event\n\n    self.topic_embed.trash! if has_topic_embed?\n  end\n\n  def recover!(recovered_by = nil)\n    trigger_event = false\n\n    unless deleted_at.nil?\n      update_category_topic_count_by(1) if visible?\n      CategoryTagStat.topic_recovered(self) if self.tags.present?\n      trigger_event = true\n    end\n\n    # Note parens are required because superclass doesn't take `recovered_by`\n    super()\n\n    DiscourseEvent.trigger(:topic_recovered, self) if trigger_event\n\n    unless (topic_embed = TopicEmbed.with_deleted.find_by_topic_id(id)).nil?\n      topic_embed.recover!\n    end\n  end\n\n  rate_limit :default_rate_limiter\n  rate_limit :limit_topics_per_day\n  rate_limit :limit_private_messages_per_day\n\n  validates :title,\n            if: Proc.new { |t| t.new_record? || t.title_changed? },\n            presence: true,\n            topic_title_length: true,\n            censored_words: true,\n            watched_words: true,\n            quality_title: {\n              unless: :private_message?,\n            },\n            max_emojis: true,\n            unique_among: {\n              unless:\n                Proc.new { |t| (SiteSetting.allow_duplicate_topic_titles? || t.private_message?) },\n              message: :has_already_been_used,\n              allow_blank: true,\n              case_sensitive: false,\n              collection:\n                Proc.new { |t|\n                  if SiteSetting.allow_duplicate_topic_titles_category?\n                    Topic.listable_topics.where(\"category_id = ?\", t.category_id)\n                  else\n                    Topic.listable_topics\n                  end\n                },\n            }\n\n  validates :category_id,\n            presence: true,\n            exclusion: {\n              in: Proc.new { [SiteSetting.uncategorized_category_id] },\n            },\n            if:\n              Proc.new { |t|\n                (t.new_record? || t.category_id_changed?) &&\n                  !SiteSetting.allow_uncategorized_topics && (t.archetype.nil? || t.regular?)\n              }\n\n  validates :featured_link, allow_nil: true, url: true\n  validate if: :featured_link do\n    if featured_link_changed? && !Guardian.new(user).can_edit_featured_link?(category_id)\n      errors.add(:featured_link)\n    end\n  end\n\n  validates :external_id,\n            allow_nil: true,\n            uniqueness: {\n              case_sensitive: false,\n            },\n            length: {\n              maximum: EXTERNAL_ID_MAX_LENGTH,\n            },\n            format: {\n              with: /\\A[\\w-]+\\z/,\n            }\n\n  before_validation do\n    self.title = TextCleaner.clean_title(TextSentinel.title_sentinel(title).text) if errors[\n      :title\n    ].empty?\n    self.featured_link = self.featured_link.strip.presence if self.featured_link\n  end\n\n  belongs_to :category\n  has_many :category_users, through: :category\n  has_many :posts\n\n  # NOTE: To get all Post _and_ Topic bookmarks for a topic by user,\n  # use the Bookmark.for_user_in_topic scope.\n  has_many :bookmarks, as: :bookmarkable\n\n  has_many :ordered_posts, -> { order(post_number: :asc) }, class_name: \"Post\"\n  has_many :topic_allowed_users\n  has_many :topic_allowed_groups\n  has_many :incoming_email\n\n  has_many :group_archived_messages, dependent: :destroy\n  has_many :user_archived_messages, dependent: :destroy\n\n  has_many :allowed_groups, through: :topic_allowed_groups, source: :group\n  has_many :allowed_group_users, through: :allowed_groups, source: :users\n  has_many :allowed_users, through: :topic_allowed_users, source: :user\n\n  has_many :topic_tags\n  has_many :tags, through: :topic_tags, dependent: :destroy # dependent destroy applies to the topic_tags records\n  has_many :tag_users, through: :tags\n\n  has_one :top_topic\n  has_one :shared_draft, dependent: :destroy\n  has_one :published_page\n\n  belongs_to :user\n  belongs_to :last_poster, class_name: \"User\", foreign_key: :last_post_user_id\n  belongs_to :featured_user1, class_name: \"User\", foreign_key: :featured_user1_id\n  belongs_to :featured_user2, class_name: \"User\", foreign_key: :featured_user2_id\n  belongs_to :featured_user3, class_name: \"User\", foreign_key: :featured_user3_id\n  belongs_to :featured_user4, class_name: \"User\", foreign_key: :featured_user4_id\n\n  has_many :topic_users\n  has_many :dismissed_topic_users\n  has_many :topic_links\n  has_many :topic_invites\n  has_many :invites, through: :topic_invites, source: :invite\n  has_many :topic_timers, dependent: :destroy\n  has_many :reviewables\n  has_many :user_profiles\n\n  has_one :user_warning\n  has_one :first_post, -> { where post_number: 1 }, class_name: \"Post\"\n  has_one :topic_search_data\n  has_one :topic_embed, dependent: :destroy\n  has_one :linked_topic, dependent: :destroy\n\n  belongs_to :image_upload, class_name: \"Upload\"\n  has_many :topic_thumbnails, through: :image_upload\n\n  # When we want to temporarily attach some data to a forum topic (usually before serialization)\n  attr_accessor :user_data\n  attr_accessor :category_user_data\n  attr_accessor :dismissed\n\n  attr_accessor :posters # TODO: can replace with posters_summary once we remove old list code\n  attr_accessor :participants\n  attr_accessor :participant_groups\n  attr_accessor :topic_list\n  attr_accessor :meta_data\n  attr_accessor :include_last_poster\n  attr_accessor :import_mode # set to true to optimize creation and save for imports\n\n  # The regular order\n  scope :topic_list_order, -> { order(\"topics.bumped_at desc\") }\n\n  # Return private message topics\n  scope :private_messages, -> { where(archetype: Archetype.private_message) }\n\n  PRIVATE_MESSAGES_SQL_USER = <<~SQL\n    SELECT topic_id\n    FROM topic_allowed_users\n    WHERE user_id = :user_id\n  SQL\n\n  PRIVATE_MESSAGES_SQL_GROUP = <<~SQL\n    SELECT tg.topic_id\n    FROM topic_allowed_groups tg\n    JOIN group_users gu ON gu.user_id = :user_id AND gu.group_id = tg.group_id\n  SQL\n\n  scope :private_messages_for_user,\n        ->(user) {\n          private_messages.where(\n            \"topics.id IN (#{PRIVATE_MESSAGES_SQL_USER})\n      OR topics.id IN (#{PRIVATE_MESSAGES_SQL_GROUP})\",\n            user_id: user.id,\n          )\n        }\n\n  scope :listable_topics, -> { where(\"topics.archetype <> ?\", Archetype.private_message) }\n\n  scope :by_newest, -> { order(\"topics.created_at desc, topics.id desc\") }\n\n  scope :visible, -> { where(visible: true) }\n\n  scope :created_since, lambda { |time_ago| where(\"topics.created_at > ?\", time_ago) }\n\n  scope :exclude_scheduled_bump_topics, -> { where.not(id: TopicTimer.scheduled_bump_topics) }\n\n  scope :secured,\n        lambda { |guardian = nil|\n          ids = guardian.secure_category_ids if guardian\n\n          # Query conditions\n          condition =\n            if ids.present?\n              [\"NOT read_restricted OR id IN (:cats)\", cats: ids]\n            else\n              [\"NOT read_restricted\"]\n            end\n\n          where(\n            \"topics.category_id IS NULL OR topics.category_id IN (SELECT id FROM categories WHERE #{condition[0]})\",\n            condition[1],\n          )\n        }\n\n  scope :in_category_and_subcategories,\n        lambda { |category_id|\n          if category_id\n            where(\"topics.category_id IN (?)\", Category.subcategory_ids(category_id.to_i))\n          end\n        }\n\n  scope :with_subtype, ->(subtype) { where(\"topics.subtype = ?\", subtype) }\n\n  attr_accessor :ignore_category_auto_close\n  attr_accessor :skip_callbacks\n  attr_accessor :advance_draft\n\n  before_create { initialize_default_values }\n\n  after_create do\n    unless skip_callbacks\n      changed_to_category(category)\n      advance_draft_sequence if advance_draft\n    end\n  end\n\n  before_save do\n    ensure_topic_has_a_category unless skip_callbacks\n\n    write_attribute(:fancy_title, Topic.fancy_title(title)) if title_changed?\n\n    if category_id_changed? || new_record?\n      inherit_auto_close_from_category\n      inherit_slow_mode_from_category\n    end\n  end\n\n  after_save do\n    banner = \"banner\"\n\n    if archetype_before_last_save == banner || archetype == banner\n      ApplicationController.banner_json_cache.clear\n    end\n\n    if tags_changed || saved_change_to_attribute?(:category_id) ||\n         saved_change_to_attribute?(:title)\n      SearchIndexer.queue_post_reindex(self.id)\n\n      if tags_changed\n        TagUser.auto_watch(topic_id: id)\n        TagUser.auto_track(topic_id: id)\n        self.tags_changed = false\n      end\n    end\n\n    SearchIndexer.index(self)\n  end\n\n  after_update do\n    if saved_changes[:category_id] && self.tags.present?\n      CategoryTagStat.topic_moved(self, *saved_changes[:category_id])\n    elsif saved_changes[:category_id] && self.category&.read_restricted?\n      UserProfile.remove_featured_topic_from_all_profiles(self)\n    end\n  end\n\n  def initialize_default_values\n    self.bumped_at ||= Time.now\n    self.last_post_user_id ||= user_id\n  end\n\n  def advance_draft_sequence\n    if self.private_message?\n      DraftSequence.next!(user, Draft::NEW_PRIVATE_MESSAGE)\n    else\n      DraftSequence.next!(user, Draft::NEW_TOPIC)\n    end\n  end\n\n  def ensure_topic_has_a_category\n    if category_id.nil? && (archetype.nil? || self.regular?)\n      self.category_id = category&.id || SiteSetting.uncategorized_category_id\n    end\n  end\n\n  def self.visible_post_types(viewed_by = nil, include_moderator_actions: true)\n    types = Post.types\n    result = [types[:regular]]\n    result += [types[:moderator_action], types[:small_action]] if include_moderator_actions\n    result << types[:whisper] if viewed_by&.whisperer?\n    result\n  end\n\n  def self.top_viewed(max = 10)\n    Topic.listable_topics.visible.secured.order(\"views desc\").limit(max)\n  end\n\n  def self.recent(max = 10)\n    Topic.listable_topics.visible.secured.order(\"created_at desc\").limit(max)\n  end\n\n  def self.count_exceeds_minimum?\n    count > SiteSetting.minimum_topics_similar\n  end\n\n  def best_post\n    posts\n      .where(post_type: Post.types[:regular], user_deleted: false)\n      .order(\"score desc nulls last\")\n      .limit(1)\n      .first\n  end\n\n  def self.has_flag_scope\n    ReviewableFlaggedPost.pending_and_default_visible\n  end\n\n  def has_flags?\n    self.class.has_flag_scope.exists?(topic_id: self.id)\n  end\n\n  def is_official_warning?\n    subtype == TopicSubtype.moderator_warning\n  end\n\n  # all users (in groups or directly targeted) that are going to get the pm\n  def all_allowed_users\n    moderators_sql = \" UNION #{User.moderators.to_sql}\" if private_message? &&\n      (has_flags? || is_official_warning?)\n    User.from(\n      \"(#{allowed_users.to_sql} UNION #{allowed_group_users.to_sql}#{moderators_sql}) as users\",\n    )\n  end\n\n  # Additional rate limits on topics: per day and private messages per day\n  def limit_topics_per_day\n    return unless regular?\n    if user && user.new_user_posting_on_first_day?\n      limit_first_day_topics_per_day\n    else\n      apply_per_day_rate_limit_for(\"topics\", :max_topics_per_day)\n    end\n  end\n\n  def limit_private_messages_per_day\n    return unless private_message?\n    apply_per_day_rate_limit_for(\"pms\", :max_personal_messages_per_day)\n  end\n\n  def self.fancy_title(title)\n    return unless escaped = ERB::Util.html_escape(title)\n    fancy_title = Emoji.unicode_unescape(HtmlPrettify.render(escaped))\n    fancy_title.length > Topic.max_fancy_title_length ? escaped : fancy_title\n  end\n\n  def fancy_title\n    return ERB::Util.html_escape(title) unless SiteSetting.title_fancy_entities?\n\n    unless fancy_title = read_attribute(:fancy_title)\n      fancy_title = Topic.fancy_title(title)\n      write_attribute(:fancy_title, fancy_title)\n\n      if !new_record? && !Discourse.readonly_mode?\n        # make sure data is set in table, this also allows us to change algorithm\n        # by simply nulling this column\n        DB.exec(\n          \"UPDATE topics SET fancy_title = :fancy_title where id = :id\",\n          id: self.id,\n          fancy_title: fancy_title,\n        )\n      end\n    end\n\n    fancy_title\n  end\n\n  # Returns hot topics since a date for display in email digest.\n  def self.for_digest(user, since, opts = nil)\n    opts = opts || {}\n    period = ListController.best_period_for(since)\n\n    topics =\n      Topic\n        .visible\n        .secured(Guardian.new(user))\n        .joins(\n          \"LEFT OUTER JOIN topic_users ON topic_users.topic_id = topics.id AND topic_users.user_id = #{user.id.to_i}\",\n        )\n        .joins(\n          \"LEFT OUTER JOIN category_users ON category_users.category_id = topics.category_id AND category_users.user_id = #{user.id.to_i}\",\n        )\n        .joins(\"LEFT OUTER JOIN users ON users.id = topics.user_id\")\n        .where(closed: false, archived: false)\n        .where(\n          \"COALESCE(topic_users.notification_level, 1) <> ?\",\n          TopicUser.notification_levels[:muted],\n        )\n        .created_since(since)\n        .where(\"topics.created_at < ?\", (SiteSetting.editing_grace_period || 0).seconds.ago)\n        .listable_topics\n        .includes(:category)\n\n    unless opts[:include_tl0] || user.user_option.try(:include_tl0_in_digests)\n      topics = topics.where(\"COALESCE(users.trust_level, 0) > 0\")\n    end\n\n    if !!opts[:top_order]\n      topics =\n        topics.joins(\"LEFT OUTER JOIN top_topics ON top_topics.topic_id = topics.id\").order(<<~SQL)\n          COALESCE(topic_users.notification_level, 1) DESC,\n          COALESCE(category_users.notification_level, 1) DESC,\n          COALESCE(top_topics.#{TopTopic.score_column_for_period(period)}, 0) DESC,\n          topics.bumped_at DESC\n      SQL\n    end\n\n    topics = topics.limit(opts[:limit]) if opts[:limit]\n\n    # Remove category topics\n    category_topic_ids = Category.pluck(:topic_id).compact!\n    topics = topics.where(\"topics.id NOT IN (?)\", category_topic_ids) if category_topic_ids.present?\n\n    # Remove muted and shared draft categories\n    remove_category_ids =\n      CategoryUser.where(\n        user_id: user.id,\n        notification_level: CategoryUser.notification_levels[:muted],\n      ).pluck(:category_id)\n    if SiteSetting.digest_suppress_categories.present?\n      topics =\n        topics.where(\n          \"topics.category_id NOT IN (?)\",\n          SiteSetting.digest_suppress_categories.split(\"|\").map(&:to_i),\n        )\n    end\n    remove_category_ids << SiteSetting.shared_drafts_category if SiteSetting.shared_drafts_enabled?\n    if remove_category_ids.present?\n      remove_category_ids.uniq!\n      topics =\n        topics.where(\n          \"topic_users.notification_level != ? OR topics.category_id NOT IN (?)\",\n          TopicUser.notification_levels[:muted],\n          remove_category_ids,\n        )\n    end\n\n    # Remove muted tags\n    muted_tag_ids = TagUser.lookup(user, :muted).pluck(:tag_id)\n    unless muted_tag_ids.empty?\n      # If multiple tags per topic, include topics with tags that aren't muted,\n      # and don't forget untagged topics.\n      topics =\n        topics.where(\n          \"EXISTS ( SELECT 1 FROM topic_tags WHERE topic_tags.topic_id = topics.id AND tag_id NOT IN (?) )\n        OR NOT EXISTS (SELECT 1 FROM topic_tags WHERE topic_tags.topic_id = topics.id)\",\n          muted_tag_ids,\n        )\n    end\n\n    topics\n  end\n\n  def meta_data=(data)\n    custom_fields.replace(data)\n  end\n\n  def meta_data\n    custom_fields\n  end\n\n  def update_meta_data(data)\n    custom_fields.update(data)\n    save\n  end\n\n  def reload(options = nil)\n    @post_numbers = nil\n    @public_topic_timer = nil\n    @slow_mode_topic_timer = nil\n    @is_category_topic = nil\n    super(options)\n  end\n\n  def post_numbers\n    @post_numbers ||= posts.order(:post_number).pluck(:post_number)\n  end\n\n  def age_in_minutes\n    ((Time.zone.now - created_at) / 1.minute).round\n  end\n\n  def self.listable_count_per_day(\n    start_date,\n    end_date,\n    category_id = nil,\n    include_subcategories = false\n  )\n    result =\n      listable_topics.where(\n        \"topics.created_at >= ? AND topics.created_at <= ?\",\n        start_date,\n        end_date,\n      )\n    result = result.group(\"date(topics.created_at)\").order(\"date(topics.created_at)\")\n    result =\n      result.where(\n        category_id: include_subcategories ? Category.subcategory_ids(category_id) : category_id,\n      ) if category_id\n    result.count\n  end\n\n  def private_message?\n    self.archetype == Archetype.private_message\n  end\n\n  def regular?\n    self.archetype == Archetype.default\n  end\n\n  def open?\n    !self.closed?\n  end\n\n  MAX_SIMILAR_BODY_LENGTH ||= 200\n\n  def self.similar_to(title, raw, user = nil)\n    return [] if title.blank?\n    raw = raw.presence || \"\"\n    search_data = Search.prepare_data(title.strip)\n\n    return [] if search_data.blank?\n\n    tsquery = Search.set_tsquery_weight_filter(search_data, \"A\")\n\n    if raw.present?\n      cooked =\n        SearchIndexer::HtmlScrubber.scrub(PrettyText.cook(raw[0...MAX_SIMILAR_BODY_LENGTH].strip))\n\n      prepared_data = cooked.present? && Search.prepare_data(cooked)\n\n      if prepared_data.present?\n        raw_tsquery = Search.set_tsquery_weight_filter(prepared_data, \"B\")\n\n        tsquery = \"#{tsquery} & #{raw_tsquery}\"\n      end\n    end\n\n    tsquery = Search.to_tsquery(term: tsquery, joiner: \"|\")\n\n    guardian = Guardian.new(user)\n\n    excluded_category_ids_sql =\n      Category\n        .secured(guardian)\n        .where(search_priority: Searchable::PRIORITIES[:ignore])\n        .select(:id)\n        .to_sql\n\n    excluded_category_ids_sql = <<~SQL if user\n      #{excluded_category_ids_sql}\n      UNION\n      #{CategoryUser.muted_category_ids_query(user, include_direct: true).select(\"categories.id\").to_sql}\n      SQL\n\n    candidates =\n      Topic\n        .visible\n        .listable_topics\n        .secured(guardian)\n        .joins(\"JOIN topic_search_data s ON topics.id = s.topic_id\")\n        .joins(\"LEFT JOIN categories c ON topics.id = c.topic_id\")\n        .where(\"search_data @@ #{tsquery}\")\n        .where(\"c.topic_id IS NULL\")\n        .where(\"topics.category_id NOT IN (#{excluded_category_ids_sql})\")\n        .order(\"ts_rank(search_data, #{tsquery}) DESC\")\n        .limit(SiteSetting.max_similar_results * 3)\n\n    candidate_ids = candidates.pluck(:id)\n\n    return [] if candidate_ids.blank?\n\n    similars =\n      Topic\n        .joins(\"JOIN posts AS p ON p.topic_id = topics.id AND p.post_number = 1\")\n        .where(\"topics.id IN (?)\", candidate_ids)\n        .order(\"similarity DESC\")\n        .limit(SiteSetting.max_similar_results)\n\n    if raw.present?\n      similars.select(\n        DB.sql_fragment(\n          \"topics.*, similarity(topics.title, :title) + similarity(p.raw, :raw) AS similarity, p.cooked AS blurb\",\n          title: title,\n          raw: raw,\n        ),\n      ).where(\n        \"similarity(topics.title, :title) + similarity(p.raw, :raw) > 0.2\",\n        title: title,\n        raw: raw,\n      )\n    else\n      similars.select(\n        DB.sql_fragment(\n          \"topics.*, similarity(topics.title, :title) AS similarity, p.cooked AS blurb\",\n          title: title,\n        ),\n      ).where(\"similarity(topics.title, :title) > 0.2\", title: title)\n    end\n  end\n\n  def update_status(status, enabled, user, opts = {})\n    TopicStatusUpdater.new(self, user).update!(status, enabled, opts)\n    DiscourseEvent.trigger(:topic_status_updated, self, status, enabled)\n\n    if status == \"closed\"\n      StaffActionLogger.new(user).log_topic_closed(self, closed: enabled)\n    elsif status == \"archived\"\n      StaffActionLogger.new(user).log_topic_archived(self, archived: enabled)\n    end\n\n    if enabled && private_message? && status.to_s[\"closed\"]\n      group_ids = user.groups.pluck(:id)\n      if group_ids.present?\n        allowed_group_ids =\n          self.allowed_groups.where(\"topic_allowed_groups.group_id IN (?)\", group_ids).pluck(:id)\n        allowed_group_ids.each { |id| GroupArchivedMessage.archive!(id, self) }\n      end\n    end\n  end\n\n  # Atomically creates the next post number\n  def self.next_post_number(topic_id, opts = {})\n    highest =\n      DB\n        .query_single(\n          \"SELECT coalesce(max(post_number),0) AS max FROM posts WHERE topic_id = ?\",\n          topic_id,\n        )\n        .first\n        .to_i\n\n    if opts[:whisper]\n      result = DB.query_single(<<~SQL, highest, topic_id)\n        UPDATE topics\n        SET highest_staff_post_number = ? + 1\n        WHERE id = ?\n        RETURNING highest_staff_post_number\n      SQL\n\n      result.first.to_i\n    else\n      reply_sql = opts[:reply] ? \", reply_count = reply_count + 1\" : \"\"\n      posts_sql = opts[:post] ? \", posts_count = posts_count + 1\" : \"\"\n\n      result = DB.query_single(<<~SQL, highest: highest, topic_id: topic_id)\n        UPDATE topics\n        SET highest_staff_post_number = :highest + 1,\n            highest_post_number = :highest + 1\n            #{reply_sql}\n            #{posts_sql}\n        WHERE id = :topic_id\n        RETURNING highest_post_number\n      SQL\n\n      result.first.to_i\n    end\n  end\n\n  def self.reset_all_highest!\n    DB.exec <<~SQL\n      WITH\n      X as (\n        SELECT topic_id,\n               COALESCE(MAX(post_number), 0) highest_post_number\n        FROM posts\n        WHERE deleted_at IS NULL\n        GROUP BY topic_id\n      ),\n      Y as (\n        SELECT topic_id,\n               coalesce(MAX(post_number), 0) highest_post_number,\n               count(*) posts_count,\n               max(created_at) last_posted_at\n        FROM posts\n        WHERE deleted_at IS NULL AND post_type <> 4\n        GROUP BY topic_id\n      )\n      UPDATE topics\n      SET\n        highest_staff_post_number = X.highest_post_number,\n        highest_post_number = Y.highest_post_number,\n        last_posted_at = Y.last_posted_at,\n        posts_count = Y.posts_count\n      FROM X, Y\n      WHERE\n        topics.archetype <> 'private_message' AND\n        X.topic_id = topics.id AND\n        Y.topic_id = topics.id AND (\n          topics.highest_staff_post_number <> X.highest_post_number OR\n          topics.highest_post_number <> Y.highest_post_number OR\n          topics.last_posted_at <> Y.last_posted_at OR\n          topics.posts_count <> Y.posts_count\n        )\n    SQL\n\n    DB.exec <<~SQL\n      WITH\n      X as (\n        SELECT topic_id,\n               COALESCE(MAX(post_number), 0) highest_post_number\n        FROM posts\n        WHERE deleted_at IS NULL\n        GROUP BY topic_id\n      ),\n      Y as (\n        SELECT topic_id,\n               coalesce(MAX(post_number), 0) highest_post_number,\n               count(*) posts_count,\n               max(created_at) last_posted_at\n        FROM posts\n        WHERE deleted_at IS NULL AND post_type <> 3 AND post_type <> 4\n        GROUP BY topic_id\n      )\n      UPDATE topics\n      SET\n        highest_staff_post_number = X.highest_post_number,\n        highest_post_number = Y.highest_post_number,\n        last_posted_at = Y.last_posted_at,\n        posts_count = Y.posts_count\n      FROM X, Y\n      WHERE\n        topics.archetype = 'private_message' AND\n        X.topic_id = topics.id AND\n        Y.topic_id = topics.id AND (\n          topics.highest_staff_post_number <> X.highest_post_number OR\n          topics.highest_post_number <> Y.highest_post_number OR\n          topics.last_posted_at <> Y.last_posted_at OR\n          topics.posts_count <> Y.posts_count\n        )\n    SQL\n  end\n\n  # If a post is deleted we have to update our highest post counters and last post information\n  def self.reset_highest(topic_id)\n    archetype = Topic.where(id: topic_id).pick(:archetype)\n\n    # ignore small_action replies for private messages\n    post_type =\n      archetype == Archetype.private_message ? \" AND post_type <> #{Post.types[:small_action]}\" : \"\"\n\n    result = DB.query_single(<<~SQL, topic_id: topic_id)\n      UPDATE topics\n      SET\n        highest_staff_post_number = (\n          SELECT COALESCE(MAX(post_number), 0) FROM posts\n          WHERE topic_id = :topic_id AND\n                deleted_at IS NULL\n        ),\n        highest_post_number = (\n          SELECT COALESCE(MAX(post_number), 0) FROM posts\n          WHERE topic_id = :topic_id AND\n                deleted_at IS NULL AND\n                post_type <> 4\n                #{post_type}\n        ),\n        posts_count = (\n          SELECT count(*) FROM posts\n          WHERE deleted_at IS NULL AND\n                topic_id = :topic_id AND\n                post_type <> 4\n                #{post_type}\n        ),\n        last_posted_at = (\n          SELECT MAX(created_at) FROM posts\n          WHERE topic_id = :topic_id AND\n                deleted_at IS NULL AND\n                post_type <> 4\n                #{post_type}\n        ),\n        last_post_user_id = COALESCE((\n          SELECT user_id FROM posts\n          WHERE topic_id = :topic_id AND\n                deleted_at IS NULL AND\n                post_type <> 4\n                #{post_type}\n          ORDER BY created_at desc\n          LIMIT 1\n        ), last_post_user_id)\n      WHERE id = :topic_id\n      RETURNING highest_post_number\n    SQL\n\n    highest_post_number = result.first.to_i\n\n    # Update the forum topic user records\n    DB.exec(<<~SQL, highest: highest_post_number, topic_id: topic_id)\n      UPDATE topic_users\n      SET last_read_post_number = CASE\n                                  WHEN last_read_post_number > :highest THEN :highest\n                                  ELSE last_read_post_number\n                                  END\n      WHERE topic_id = :topic_id\n    SQL\n  end\n\n  cattr_accessor :update_featured_topics\n\n  def changed_to_category(new_category)\n    return true if new_category.blank? || Category.exists?(topic_id: id)\n\n    if new_category.id == SiteSetting.uncategorized_category_id &&\n         !SiteSetting.allow_uncategorized_topics\n      return false\n    end\n\n    Topic.transaction do\n      old_category = category\n\n      if self.category_id != new_category.id\n        self.update(category_id: new_category.id)\n\n        if old_category\n          Category.where(id: old_category.id).update_all(\"topic_count = topic_count - 1\")\n\n          count =\n            if old_category.read_restricted && !new_category.read_restricted\n              1\n            elsif !old_category.read_restricted && new_category.read_restricted\n              -1\n            end\n\n          Tag.update_counters(self.tags, { public_topic_count: count }) if count\n        end\n\n        # when a topic changes category we may have to start watching it\n        # if we happen to have read state for it\n        CategoryUser.auto_watch(category_id: new_category.id, topic_id: self.id)\n        CategoryUser.auto_track(category_id: new_category.id, topic_id: self.id)\n\n        if !SiteSetting.disable_category_edit_notifications && (post = self.ordered_posts.first)\n          notified_user_ids = [post.user_id, post.last_editor_id].uniq\n          DB.after_commit do\n            Jobs.enqueue(\n              :notify_category_change,\n              post_id: post.id,\n              notified_user_ids: notified_user_ids,\n            )\n          end\n        end\n\n        # when a topic changes category we may need to make uploads\n        # linked to posts secure/not secure depending on whether the\n        # category is private. this is only done if the category\n        # has actually changed to avoid noise.\n        DB.after_commit { Jobs.enqueue(:update_topic_upload_security, topic_id: self.id) }\n      end\n\n      Category.where(id: new_category.id).update_all(\"topic_count = topic_count + 1\")\n\n      if Topic.update_featured_topics != false\n        CategoryFeaturedTopic.feature_topics_for(old_category) unless @import_mode\n        unless @import_mode || old_category.try(:id) == new_category.id\n          CategoryFeaturedTopic.feature_topics_for(new_category)\n        end\n      end\n    end\n\n    true\n  end\n\n  def add_small_action(user, action_code, who = nil, opts = {})\n    custom_fields = {}\n    custom_fields[\"action_code_who\"] = who if who.present?\n    opts =\n      opts.merge(\n        post_type: Post.types[:small_action],\n        action_code: action_code,\n        custom_fields: custom_fields,\n      )\n\n    add_moderator_post(user, nil, opts)\n  end\n\n  def add_moderator_post(user, text, opts = nil)\n    opts ||= {}\n    new_post = nil\n    creator =\n      PostCreator.new(\n        user,\n        raw: text,\n        post_type: opts[:post_type] || Post.types[:moderator_action],\n        action_code: opts[:action_code],\n        no_bump: opts[:bump].blank?,\n        topic_id: self.id,\n        silent: opts[:silent],\n        skip_validations: true,\n        custom_fields: opts[:custom_fields],\n        import_mode: opts[:import_mode],\n      )\n\n    if (new_post = creator.create) && new_post.present?\n      increment!(:moderator_posts_count) if new_post.persisted?\n      # If we are moving posts, we want to insert the moderator post where the previous posts were\n      # in the stream, not at the end.\n      if opts[:post_number].present?\n        new_post.update!(post_number: opts[:post_number], sort_order: opts[:post_number])\n      end\n\n      # Grab any links that are present\n      TopicLink.extract_from(new_post)\n      QuotedPost.extract_from(new_post)\n    end\n\n    new_post\n  end\n\n  def change_category_to_id(category_id)\n    return false if private_message?\n\n    new_category_id = category_id.to_i\n    # if the category name is blank, reset the attribute\n    new_category_id = SiteSetting.uncategorized_category_id if new_category_id == 0\n\n    return true if self.category_id == new_category_id\n\n    cat = Category.find_by(id: new_category_id)\n    return false unless cat\n\n    reviewables.update_all(category_id: new_category_id)\n\n    changed_to_category(cat)\n  end\n\n  def remove_allowed_group(removed_by, name)\n    if group = Group.find_by(name: name)\n      group_user = topic_allowed_groups.find_by(group_id: group.id)\n      if group_user\n        group_user.destroy\n        allowed_groups.reload\n        add_small_action(removed_by, \"removed_group\", group.name)\n        return true\n      end\n    end\n\n    false\n  end\n\n  def remove_allowed_user(removed_by, username)\n    user = username.is_a?(User) ? username : User.find_by(username: username)\n\n    if user\n      topic_user = topic_allowed_users.find_by(user_id: user.id)\n\n      if topic_user\n        if user.id == removed_by&.id\n          add_small_action(removed_by, \"user_left\", user.username)\n        else\n          add_small_action(removed_by, \"removed_user\", user.username)\n        end\n\n        topic_user.destroy\n        return true\n      end\n    end\n\n    false\n  end\n\n  def reached_recipients_limit?\n    return false unless private_message?\n    topic_allowed_users.count + topic_allowed_groups.count >=\n      SiteSetting.max_allowed_message_recipients\n  end\n\n  def invite_group(user, group)\n    TopicAllowedGroup.create!(topic_id: self.id, group_id: group.id)\n    self.allowed_groups.reload\n\n    last_post =\n      self.posts.order(\"post_number desc\").where(\"not hidden AND posts.deleted_at IS NULL\").first\n    if last_post\n      Jobs.enqueue(:post_alert, post_id: last_post.id)\n      add_small_action(user, \"invited_group\", group.name)\n      Jobs.enqueue(:group_pm_alert, user_id: user.id, group_id: group.id, post_id: last_post.id)\n    end\n\n    # If the group invited includes the OP of the topic as one of is members,\n    # we cannot strip the topic_allowed_user record since it will be more\n    # complicated to recover the topic_allowed_user record for the OP if the\n    # group is removed.\n    allowed_user_where_clause = <<~SQL\n      users.id IN (\n        SELECT topic_allowed_users.user_id\n        FROM topic_allowed_users\n        INNER JOIN group_users ON group_users.user_id = topic_allowed_users.user_id\n        INNER JOIN topic_allowed_groups ON topic_allowed_groups.group_id = group_users.group_id\n        WHERE topic_allowed_groups.group_id = :group_id AND\n              topic_allowed_users.topic_id = :topic_id AND\n              topic_allowed_users.user_id != :op_user_id\n      )\n    SQL\n    User\n      .where(\n        [\n          allowed_user_where_clause,\n          { group_id: group.id, topic_id: self.id, op_user_id: self.user_id },\n        ],\n      )\n      .find_each { |allowed_user| remove_allowed_user(Discourse.system_user, allowed_user) }\n\n    true\n  end\n\n  def invite(invited_by, username_or_email, group_ids = nil, custom_message = nil)\n    guardian = Guardian.new(invited_by)\n\n    if target_user = User.find_by_username_or_email(username_or_email)\n      if topic_allowed_users.exists?(user_id: target_user.id)\n        raise UserExists.new(I18n.t(\"topic_invite.user_exists\"))\n      end\n\n      comm_screener = UserCommScreener.new(acting_user: invited_by, target_user_ids: target_user.id)\n      if comm_screener.ignoring_or_muting_actor?(target_user.id)\n        raise NotAllowed.new(I18n.t(\"not_accepting_pms\", username: target_user.username))\n      end\n\n      if TopicUser.where(\n           topic: self,\n           user: target_user,\n           notification_level: TopicUser.notification_levels[:muted],\n         ).exists?\n        raise NotAllowed.new(I18n.t(\"topic_invite.muted_topic\"))\n      end\n\n      if comm_screener.disallowing_pms_from_actor?(target_user.id)\n        raise NotAllowed.new(I18n.t(\"topic_invite.receiver_does_not_allow_pm\"))\n      end\n\n      if UserCommScreener.new(\n           acting_user: target_user,\n           target_user_ids: invited_by.id,\n         ).disallowing_pms_from_actor?(invited_by.id)\n        raise NotAllowed.new(I18n.t(\"topic_invite.sender_does_not_allow_pm\"))\n      end\n\n      if private_message?\n        !!invite_to_private_message(invited_by, target_user, guardian)\n      else\n        !!invite_to_topic(invited_by, target_user, group_ids, guardian)\n      end\n    elsif username_or_email =~ /\\A.+@.+\\z/ && guardian.can_invite_via_email?(self)\n      !!Invite.generate(\n        invited_by,\n        email: username_or_email,\n        topic: self,\n        group_ids: group_ids,\n        custom_message: custom_message,\n        invite_to_topic: true,\n      )\n    end\n  end\n\n  def email_already_exists_for?(invite)\n    invite.email_already_exists && private_message?\n  end\n\n  def grant_permission_to_user(lower_email)\n    user = User.find_by_email(lower_email)\n    unless topic_allowed_users.exists?(user_id: user.id)\n      topic_allowed_users.create!(user_id: user.id)\n    end\n  end\n\n  def max_post_number\n    posts.with_deleted.maximum(:post_number).to_i\n  end\n\n  def move_posts(moved_by, post_ids, opts)\n    post_mover =\n      PostMover.new(\n        self,\n        moved_by,\n        post_ids,\n        move_to_pm: opts[:archetype].present? && opts[:archetype] == \"private_message\",\n      )\n\n    if opts[:destination_topic_id]\n      topic =\n        post_mover.to_topic(\n          opts[:destination_topic_id],\n          **opts.slice(:participants, :chronological_order),\n        )\n\n      DiscourseEvent.trigger(:topic_merged, post_mover.original_topic, post_mover.destination_topic)\n\n      topic\n    elsif opts[:title]\n      post_mover.to_new_topic(opts[:title], opts[:category_id], opts[:tags])\n    end\n  end\n\n  # Updates the denormalized statistics of a topic including featured posters. They shouldn't\n  # go out of sync unless you do something drastic live move posts from one topic to another.\n  # this recalculates everything.\n  def update_statistics\n    feature_topic_users\n    update_action_counts\n    Topic.reset_highest(id)\n  end\n\n  def update_action_counts\n    update_column(\n      :like_count,\n      Post.where.not(post_type: Post.types[:whisper]).where(topic_id: id).sum(:like_count),\n    )\n  end\n\n  def posters_summary(options = {}) # avatar lookup in options\n    @posters_summary ||= TopicPostersSummary.new(self, options).summary\n  end\n\n  def participants_summary(options = {})\n    @participants_summary ||= TopicParticipantsSummary.new(self, options).summary\n  end\n\n  def participant_groups_summary(options = {})\n    @participant_groups_summary ||= TopicParticipantGroupsSummary.new(self, options).summary\n  end\n\n  def make_banner!(user, bannered_until = nil)\n    if bannered_until\n      bannered_until =\n        begin\n          Time.parse(bannered_until)\n        rescue ArgumentError\n          raise Discourse::InvalidParameters.new(:bannered_until)\n        end\n    end\n\n    # only one banner at the same time\n    previous_banner = Topic.where(archetype: Archetype.banner).first\n    previous_banner.remove_banner!(user) if previous_banner.present?\n\n    UserProfile.where(\"dismissed_banner_key IS NOT NULL\").update_all(dismissed_banner_key: nil)\n\n    self.archetype = Archetype.banner\n    self.bannered_until = bannered_until\n    self.add_small_action(user, \"banner.enabled\")\n    self.save\n\n    MessageBus.publish(\"/site/banner\", banner)\n\n    Jobs.cancel_scheduled_job(:remove_banner, topic_id: self.id)\n    Jobs.enqueue_at(bannered_until, :remove_banner, topic_id: self.id) if bannered_until\n  end\n\n  def remove_banner!(user)\n    self.archetype = Archetype.default\n    self.bannered_until = nil\n    self.add_small_action(user, \"banner.disabled\")\n    self.save\n\n    MessageBus.publish(\"/site/banner\", nil)\n\n    Jobs.cancel_scheduled_job(:remove_banner, topic_id: self.id)\n  end\n\n  def banner\n    post = self.ordered_posts.first\n\n    { html: post.cooked, key: self.id, url: self.url }\n  end\n\n  cattr_accessor :slug_computed_callbacks\n  self.slug_computed_callbacks = []\n\n  def slug_for_topic(title)\n    return \"\" unless title.present?\n    slug = Slug.for(title)\n\n    # this is a hook for plugins that need to modify the generated slug\n    self.class.slug_computed_callbacks.each { |callback| slug = callback.call(self, slug, title) }\n\n    slug\n  end\n\n  # Even if the slug column in the database is null, topic.slug will return something:\n  def slug\n    unless slug = read_attribute(:slug)\n      return \"\" unless title.present?\n      slug = slug_for_topic(title)\n      if new_record?\n        write_attribute(:slug, slug)\n      else\n        update_column(:slug, slug)\n      end\n    end\n\n    slug\n  end\n\n  def self.find_by_slug(slug)\n    if SiteSetting.slug_generation_method != \"encoded\"\n      Topic.find_by(slug: slug.downcase)\n    else\n      encoded_slug = CGI.escape(slug)\n      Topic.find_by(slug: encoded_slug)\n    end\n  end\n\n  def title=(t)\n    slug = slug_for_topic(t.to_s)\n    write_attribute(:slug, slug)\n    write_attribute(:fancy_title, nil)\n    write_attribute(:title, t)\n  end\n\n  # NOTE: These are probably better off somewhere else.\n  #       Having a model know about URLs seems a bit strange.\n  def last_post_url\n    \"#{Discourse.base_path}/t/#{slug}/#{id}/#{posts_count}\"\n  end\n\n  def self.url(id, slug, post_number = nil)\n    url = +\"#{Discourse.base_url}/t/#{slug}/#{id}\"\n    url << \"/#{post_number}\" if post_number.to_i > 1\n    url\n  end\n\n  def url(post_number = nil)\n    self.class.url id, slug, post_number\n  end\n\n  def self.relative_url(id, slug, post_number = nil)\n    url = +\"#{Discourse.base_path}/t/\"\n    url << \"#{slug}/\" if slug.present?\n    url << id.to_s\n    url << \"/#{post_number}\" if post_number.to_i > 1\n    url\n  end\n\n  def slugless_url(post_number = nil)\n    Topic.relative_url(id, nil, post_number)\n  end\n\n  def relative_url(post_number = nil)\n    Topic.relative_url(id, slug, post_number)\n  end\n\n  def clear_pin_for(user)\n    return unless user.present?\n    TopicUser.change(user.id, id, cleared_pinned_at: Time.now)\n  end\n\n  def re_pin_for(user)\n    return unless user.present?\n    TopicUser.change(user.id, id, cleared_pinned_at: nil)\n  end\n\n  def update_pinned(status, global = false, pinned_until = nil)\n    if pinned_until\n      pinned_until =\n        begin\n          Time.parse(pinned_until)\n        rescue ArgumentError\n          raise Discourse::InvalidParameters.new(:pinned_until)\n        end\n    end\n\n    update_columns(\n      pinned_at: status ? Time.zone.now : nil,\n      pinned_globally: global,\n      pinned_until: pinned_until,\n    )\n\n    Jobs.cancel_scheduled_job(:unpin_topic, topic_id: self.id)\n    Jobs.enqueue_at(pinned_until, :unpin_topic, topic_id: self.id) if pinned_until\n  end\n\n  def draft_key\n    \"#{Draft::EXISTING_TOPIC}#{id}\"\n  end\n\n  def notifier\n    @topic_notifier ||= TopicNotifier.new(self)\n  end\n\n  def muted?(user)\n    notifier.muted?(user.id) if user && user.id\n  end\n\n  def self.ensure_consistency!\n    # unpin topics that might have been missed\n    Topic.where(\"pinned_until < ?\", Time.now).update_all(\n      pinned_at: nil,\n      pinned_globally: false,\n      pinned_until: nil,\n    )\n    Topic\n      .where(\"bannered_until < ?\", Time.now)\n      .find_each { |topic| topic.remove_banner!(Discourse.system_user) }\n  end\n\n  def inherit_slow_mode_from_category\n    if self.category&.default_slow_mode_seconds\n      self.slow_mode_seconds = self.category&.default_slow_mode_seconds\n    end\n  end\n\n  def inherit_auto_close_from_category(timer_type: :close)\n    auto_close_hours = self.category&.auto_close_hours\n\n    if self.open? && !@ignore_category_auto_close && auto_close_hours.present? &&\n         public_topic_timer&.execute_at.blank?\n      based_on_last_post = self.category.auto_close_based_on_last_post\n      duration_minutes = based_on_last_post ? auto_close_hours * 60 : nil\n\n      # the timer time can be a timestamp or an integer based\n      # on the number of hours\n      auto_close_time = auto_close_hours\n\n      if !based_on_last_post\n        # set auto close to the original time it should have been\n        # when the topic was first created.\n        start_time = self.created_at || Time.zone.now\n        auto_close_time = start_time + auto_close_hours.hours\n\n        # if we have already passed the original close time then\n        # we should not recreate the auto-close timer for the topic\n        return if auto_close_time < Time.zone.now\n\n        # timestamp must be a string for set_or_create_timer\n        auto_close_time = auto_close_time.to_s\n      end\n\n      self.set_or_create_timer(\n        TopicTimer.types[timer_type],\n        auto_close_time,\n        by_user: Discourse.system_user,\n        based_on_last_post: based_on_last_post,\n        duration_minutes: duration_minutes,\n      )\n    end\n  end\n\n  def public_topic_timer\n    @public_topic_timer ||= topic_timers.find_by(public_type: true)\n  end\n\n  def slow_mode_topic_timer\n    @slow_mode_topic_timer ||= topic_timers.find_by(status_type: TopicTimer.types[:clear_slow_mode])\n  end\n\n  def delete_topic_timer(status_type, by_user: Discourse.system_user)\n    options = { status_type: status_type }\n    options.merge!(user: by_user) unless TopicTimer.public_types[status_type]\n    self.topic_timers.find_by(options)&.trash!(by_user)\n    @public_topic_timer = nil\n    nil\n  end\n\n  # Valid arguments for the time:\n  #  * An integer, which is the number of hours from now to update the topic's status.\n  #  * A timestamp, like \"2013-11-25 13:00\", when the topic's status should update.\n  #  * A timestamp with timezone in JSON format. (e.g., \"2013-11-26T21:00:00.000Z\")\n  #  * `nil` to delete the topic's status update.\n  # Options:\n  #  * by_user: User who is setting the topic's status update.\n  #  * based_on_last_post: True if time should be based on timestamp of the last post.\n  #  * category_id: Category that the update will apply to.\n  #  * duration_minutes: The duration of the timer in minutes, which is used if the timer is based\n  #                      on the last post or if the timer type is delete_replies.\n  #  * silent: Affects whether the close topic timer status change will be silent or not.\n  def set_or_create_timer(\n    status_type,\n    time,\n    by_user: nil,\n    based_on_last_post: false,\n    category_id: SiteSetting.uncategorized_category_id,\n    duration_minutes: nil,\n    silent: nil\n  )\n    if time.blank? && duration_minutes.blank?\n      return delete_topic_timer(status_type, by_user: by_user)\n    end\n\n    duration_minutes = duration_minutes ? duration_minutes.to_i : 0\n    public_topic_timer = !!TopicTimer.public_types[status_type]\n    topic_timer_options = { topic: self, public_type: public_topic_timer }\n    topic_timer_options.merge!(user: by_user) unless public_topic_timer\n    topic_timer_options.merge!(silent: silent) if silent\n    topic_timer = TopicTimer.find_or_initialize_by(topic_timer_options)\n    topic_timer.status_type = status_type\n\n    time_now = Time.zone.now\n    topic_timer.based_on_last_post = !based_on_last_post.blank?\n\n    if status_type == TopicTimer.types[:publish_to_category]\n      topic_timer.category = Category.find_by(id: category_id)\n    end\n\n    if topic_timer.based_on_last_post\n      if duration_minutes > 0\n        last_post_created_at =\n          self.ordered_posts.last.present? ? self.ordered_posts.last.created_at : time_now\n        topic_timer.duration_minutes = duration_minutes\n        topic_timer.execute_at = last_post_created_at + duration_minutes.minutes\n        topic_timer.created_at = last_post_created_at\n      end\n    elsif topic_timer.status_type == TopicTimer.types[:delete_replies]\n      if duration_minutes > 0\n        first_reply_created_at =\n          (self.ordered_posts.where(\"post_number > 1\").minimum(:created_at) || time_now)\n        topic_timer.duration_minutes = duration_minutes\n        topic_timer.execute_at = first_reply_created_at + duration_minutes.minutes\n        topic_timer.created_at = first_reply_created_at\n      end\n    else\n      utc = Time.find_zone(\"UTC\")\n      is_float =\n        (\n          begin\n            Float(time)\n          rescue StandardError\n            nil\n          end\n        )\n\n      if is_float\n        num_hours = time.to_f\n        topic_timer.execute_at = num_hours.hours.from_now if num_hours > 0\n      else\n        timestamp = utc.parse(time)\n        raise Discourse::InvalidParameters unless timestamp && timestamp > utc.now\n        # a timestamp in client's time zone, like \"2015-5-27 12:00\"\n        topic_timer.execute_at = timestamp\n      end\n    end\n\n    if topic_timer.execute_at\n      if by_user&.staff? || by_user&.trust_level == TrustLevel[4]\n        topic_timer.user = by_user\n      else\n        topic_timer.user ||=\n          (\n            if self.user.staff? || self.user.trust_level == TrustLevel[4]\n              self.user\n            else\n              Discourse.system_user\n            end\n          )\n      end\n\n      if self.persisted?\n        # See TopicTimer.after_save for additional context; the topic\n        # status may be changed by saving.\n        topic_timer.save!\n      else\n        self.topic_timers << topic_timer\n      end\n\n      topic_timer\n    end\n  end\n\n  def read_restricted_category?\n    category && category.read_restricted\n  end\n\n  def category_allows_unlimited_owner_edits_on_first_post?\n    category && category.allow_unlimited_owner_edits_on_first_post?\n  end\n\n  def acting_user\n    @acting_user || user\n  end\n\n  def acting_user=(u)\n    @acting_user = u\n  end\n\n  def secure_group_ids\n    @secure_group_ids ||=\n      (self.category.secure_group_ids if self.category && self.category.read_restricted?)\n  end\n\n  def has_topic_embed?\n    TopicEmbed.where(topic_id: id).exists?\n  end\n\n  def expandable_first_post?\n    SiteSetting.embed_truncate? && has_topic_embed?\n  end\n\n  def message_archived?(user)\n    return false unless user && user.id\n\n    # tricky query but this checks to see if message is archived for ALL groups you belong to\n    # OR if you have it archived as a user explicitly\n\n    sql = <<~SQL\n      SELECT 1\n      WHERE\n        (\n        SELECT count(*) FROM topic_allowed_groups tg\n        JOIN group_archived_messages gm\n              ON gm.topic_id = tg.topic_id AND\n                 gm.group_id = tg.group_id\n          WHERE tg.group_id IN (SELECT g.group_id FROM group_users g WHERE g.user_id = :user_id)\n            AND tg.topic_id = :topic_id\n        ) =\n        (\n          SELECT case when count(*) = 0 then -1 else count(*) end FROM topic_allowed_groups tg\n          WHERE tg.group_id IN (SELECT g.group_id FROM group_users g WHERE g.user_id = :user_id)\n            AND tg.topic_id = :topic_id\n        )\n\n        UNION ALL\n\n        SELECT 1 FROM topic_allowed_users tu\n        JOIN user_archived_messages um ON um.user_id = tu.user_id AND um.topic_id = tu.topic_id\n        WHERE tu.user_id = :user_id AND tu.topic_id = :topic_id\n    SQL\n\n    DB.exec(sql, user_id: user.id, topic_id: id) > 0\n  end\n\n  TIME_TO_FIRST_RESPONSE_SQL ||= <<-SQL\n    SELECT AVG(t.hours)::float AS \"hours\", t.created_at AS \"date\"\n    FROM (\n      SELECT t.id, t.created_at::date AS created_at, EXTRACT(EPOCH FROM MIN(p.created_at) - t.created_at)::float / 3600.0 AS \"hours\"\n      FROM topics t\n      LEFT JOIN posts p ON p.topic_id = t.id\n      /*where*/\n      GROUP BY t.id\n    ) t\n    GROUP BY t.created_at\n    ORDER BY t.created_at\n  SQL\n\n  TIME_TO_FIRST_RESPONSE_TOTAL_SQL ||= <<-SQL\n    SELECT AVG(t.hours)::float AS \"hours\"\n    FROM (\n      SELECT t.id, EXTRACT(EPOCH FROM MIN(p.created_at) - t.created_at)::float / 3600.0 AS \"hours\"\n      FROM topics t\n      LEFT JOIN posts p ON p.topic_id = t.id\n      /*where*/\n      GROUP BY t.id\n    ) t\n  SQL\n\n  def self.time_to_first_response(sql, opts = nil)\n    opts ||= {}\n    builder = DB.build(sql)\n    builder.where(\"t.created_at >= :start_date\", start_date: opts[:start_date]) if opts[:start_date]\n    builder.where(\"t.created_at < :end_date\", end_date: opts[:end_date]) if opts[:end_date]\n    if opts[:category_id]\n      if opts[:include_subcategories]\n        builder.where(\"t.category_id IN (?)\", Category.subcategory_ids(opts[:category_id]))\n      else\n        builder.where(\"t.category_id = ?\", opts[:category_id])\n      end\n    end\n    builder.where(\"t.archetype <> '#{Archetype.private_message}'\")\n    builder.where(\"t.deleted_at IS NULL\")\n    builder.where(\"p.deleted_at IS NULL\")\n    builder.where(\"p.post_number > 1\")\n    builder.where(\"p.user_id != t.user_id\")\n    builder.where(\"p.user_id in (:user_ids)\", user_ids: opts[:user_ids]) if opts[:user_ids]\n    builder.where(\"p.post_type = :post_type\", post_type: Post.types[:regular])\n    builder.where(\"EXTRACT(EPOCH FROM p.created_at - t.created_at) > 0\")\n    builder.query_hash\n  end\n\n  def self.time_to_first_response_per_day(start_date, end_date, opts = {})\n    time_to_first_response(\n      TIME_TO_FIRST_RESPONSE_SQL,\n      opts.merge(start_date: start_date, end_date: end_date),\n    )\n  end\n\n  def self.time_to_first_response_total(opts = nil)\n    total = time_to_first_response(TIME_TO_FIRST_RESPONSE_TOTAL_SQL, opts)\n    total.first[\"hours\"].to_f.round(2)\n  end\n\n  WITH_NO_RESPONSE_SQL ||= <<-SQL\n    SELECT COUNT(*) as count, tt.created_at AS \"date\"\n    FROM (\n      SELECT t.id, t.created_at::date AS created_at, MIN(p.post_number) first_reply\n      FROM topics t\n      LEFT JOIN posts p ON p.topic_id = t.id AND p.user_id != t.user_id AND p.deleted_at IS NULL AND p.post_type = #{Post.types[:regular]}\n      /*where*/\n      GROUP BY t.id\n    ) tt\n    WHERE tt.first_reply IS NULL OR tt.first_reply < 2\n    GROUP BY tt.created_at\n    ORDER BY tt.created_at\n  SQL\n\n  def self.with_no_response_per_day(\n    start_date,\n    end_date,\n    category_id = nil,\n    include_subcategories = nil\n  )\n    builder = DB.build(WITH_NO_RESPONSE_SQL)\n    builder.where(\"t.created_at >= :start_date\", start_date: start_date) if start_date\n    builder.where(\"t.created_at < :end_date\", end_date: end_date) if end_date\n    if category_id\n      if include_subcategories\n        builder.where(\"t.category_id IN (?)\", Category.subcategory_ids(category_id))\n      else\n        builder.where(\"t.category_id = ?\", category_id)\n      end\n    end\n    builder.where(\"t.archetype <> '#{Archetype.private_message}'\")\n    builder.where(\"t.deleted_at IS NULL\")\n    builder.query_hash\n  end\n\n  WITH_NO_RESPONSE_TOTAL_SQL ||= <<-SQL\n    SELECT COUNT(*) as count\n    FROM (\n      SELECT t.id, MIN(p.post_number) first_reply\n      FROM topics t\n      LEFT JOIN posts p ON p.topic_id = t.id AND p.user_id != t.user_id AND p.deleted_at IS NULL AND p.post_type = #{Post.types[:regular]}\n      /*where*/\n      GROUP BY t.id\n    ) tt\n    WHERE tt.first_reply IS NULL OR tt.first_reply < 2\n  SQL\n\n  def self.with_no_response_total(opts = {})\n    builder = DB.build(WITH_NO_RESPONSE_TOTAL_SQL)\n    if opts[:category_id]\n      if opts[:include_subcategories]\n        builder.where(\"t.category_id IN (?)\", Category.subcategory_ids(opts[:category_id]))\n      else\n        builder.where(\"t.category_id = ?\", opts[:category_id])\n      end\n    end\n    builder.where(\"t.archetype <> '#{Archetype.private_message}'\")\n    builder.where(\"t.deleted_at IS NULL\")\n    builder.query_single.first.to_i\n  end\n\n  def convert_to_public_topic(user, category_id: nil)\n    public_topic = TopicConverter.new(self, user).convert_to_public_topic(category_id)\n    Tag.update_counters(public_topic.tags, { public_topic_count: 1 }) if !category.read_restricted\n    add_small_action(user, \"public_topic\") if public_topic\n    public_topic\n  end\n\n  def convert_to_private_message(user)\n    read_restricted = category.read_restricted\n    private_topic = TopicConverter.new(self, user).convert_to_private_message\n    Tag.update_counters(private_topic.tags, { public_topic_count: -1 }) if !read_restricted\n    add_small_action(user, \"private_topic\") if private_topic\n    private_topic\n  end\n\n  def update_excerpt(excerpt)\n    update_column(:excerpt, excerpt)\n    ApplicationController.banner_json_cache.clear if archetype == \"banner\"\n  end\n\n  def pm_with_non_human_user?\n    sql = <<~SQL\n    SELECT 1 FROM topics\n    LEFT JOIN topic_allowed_groups ON topics.id = topic_allowed_groups.topic_id\n    WHERE topic_allowed_groups.topic_id IS NULL\n    AND topics.archetype = :private_message\n    AND topics.id = :topic_id\n    AND (\n      SELECT COUNT(*) FROM topic_allowed_users\n      WHERE topic_allowed_users.topic_id = :topic_id\n      AND topic_allowed_users.user_id > 0\n    ) = 1\n    SQL\n\n    result = DB.exec(sql, private_message: Archetype.private_message, topic_id: self.id)\n    result != 0\n  end\n\n  def featured_link_root_domain\n    MiniSuffix.domain(UrlHelper.encode_and_parse(self.featured_link).hostname)\n  end\n\n  def self.private_message_topics_count_per_day(start_date, end_date, topic_subtype)\n    private_messages\n      .with_subtype(topic_subtype)\n      .where(\"topics.created_at >= ? AND topics.created_at <= ?\", start_date, end_date)\n      .group(\"date(topics.created_at)\")\n      .order(\"date(topics.created_at)\")\n      .count\n  end\n\n  def is_category_topic?\n    @is_category_topic ||= Category.exists?(topic_id: self.id.to_i)\n  end\n\n  def reset_bumped_at\n    post =\n      ordered_posts.where(\n        user_deleted: false,\n        hidden: false,\n        post_type: Post.types[:regular],\n      ).last || first_post\n\n    self.bumped_at = post.created_at\n    self.save(validate: false)\n  end\n\n  def auto_close_threshold_reached?\n    return if user&.staff?\n\n    scores =\n      ReviewableScore\n        .pending\n        .joins(:reviewable)\n        .where(\"reviewable_scores.score >= ?\", Reviewable.min_score_for_priority)\n        .where(\"reviewables.topic_id = ?\", self.id)\n        .pluck(\n          \"COUNT(DISTINCT reviewable_scores.user_id), COALESCE(SUM(reviewable_scores.score), 0.0)\",\n        )\n        .first\n\n    scores[0] >= SiteSetting.num_flaggers_to_close_topic &&\n      scores[1] >= Reviewable.score_to_auto_close_topic\n  end\n\n  def update_category_topic_count_by(num)\n    if category_id.present?\n      Category\n        .where(\"id = ?\", category_id)\n        .where(\"topic_id != ? OR topic_id IS NULL\", self.id)\n        .update_all(\"topic_count = topic_count + #{num.to_i}\")\n    end\n  end\n\n  def access_topic_via_group\n    Group\n      .joins(:category_groups)\n      .where(\"category_groups.category_id = ?\", self.category_id)\n      .where(\"groups.public_admission OR groups.allow_membership_requests\")\n      .order(:allow_membership_requests)\n      .first\n  end\n\n  def incoming_email_addresses(group: nil, received_before: Time.zone.now)\n    email_addresses = Set.new\n\n    self\n      .incoming_email\n      .where(\"created_at <= ?\", received_before)\n      .each do |incoming_email|\n        to_addresses = incoming_email.to_addresses_split\n        cc_addresses = incoming_email.cc_addresses_split\n        combined_addresses = [to_addresses, cc_addresses].flatten\n\n        # We only care about the emails addressed to the group or CC'd to the\n        # group if the group is present. If combined addresses is empty we do\n        # not need to do this check, and instead can proceed on to adding the\n        # from address.\n        #\n        # Will not include test1@gmail.com if the only IncomingEmail\n        # is:\n        #\n        # from: test1@gmail.com\n        # to: test+support@discoursemail.com\n        #\n        # Because we don't care about the from addresses and also the to address\n        # is not the email_username, which will be something like test1@gmail.com.\n        if group.present? && combined_addresses.any?\n          next if combined_addresses.none? { |address| address =~ group.email_username_regex }\n        end\n\n        email_addresses.add(incoming_email.from_address)\n        email_addresses.merge(combined_addresses)\n      end\n\n    email_addresses.subtract([nil, \"\"])\n    email_addresses.delete(group.email_username) if group.present?\n\n    email_addresses.to_a\n  end\n\n  def create_invite_notification!(target_user, notification_type, invited_by, post_number: 1)\n    if UserCommScreener.new(\n         acting_user: invited_by,\n         target_user_ids: target_user.id,\n       ).ignoring_or_muting_actor?(target_user.id)\n      raise NotAllowed.new(I18n.t(\"not_accepting_pms\", username: target_user.username))\n    end\n\n    target_user.notifications.create!(\n      notification_type: notification_type,\n      topic_id: self.id,\n      post_number: post_number,\n      data: {\n        topic_title: self.title,\n        display_username: invited_by.username,\n        original_user_id: user.id,\n        original_username: user.username,\n      }.to_json,\n    )\n  end\n\n  def rate_limit_topic_invitation(invited_by)\n    RateLimiter.new(\n      invited_by,\n      \"topic-invitations-per-day\",\n      SiteSetting.max_topic_invitations_per_day,\n      1.day.to_i,\n    ).performed!\n\n    RateLimiter.new(\n      invited_by,\n      \"topic-invitations-per-minute\",\n      SiteSetting.max_topic_invitations_per_minute,\n      1.day.to_i,\n    ).performed!\n  end\n\n  def cannot_permanently_delete_reason(user)\n    all_posts_count =\n      Post\n        .with_deleted\n        .where(topic_id: self.id)\n        .where(\n          post_type: [Post.types[:regular], Post.types[:moderator_action], Post.types[:whisper]],\n        )\n        .count\n\n    if posts_count > 0 || all_posts_count > 1\n      I18n.t(\"post.cannot_permanently_delete.many_posts\")\n    elsif self.deleted_by_id == user&.id && self.deleted_at >= Post::PERMANENT_DELETE_TIMER.ago\n      time_left =\n        RateLimiter.time_left(\n          Post::PERMANENT_DELETE_TIMER.to_i - Time.zone.now.to_i + self.deleted_at.to_i,\n        )\n      I18n.t(\"post.cannot_permanently_delete.wait_or_different_admin\", time_left: time_left)\n    end\n  end\n\n  def first_smtp_enabled_group\n    self.allowed_groups.where(smtp_enabled: true).first\n  end\n\n  def secure_audience_publish_messages\n    target_audience = {}\n\n    if private_message?\n      target_audience[:user_ids] = User.human_users.where(\"admin OR moderator\").pluck(:id)\n      target_audience[:user_ids] |= allowed_users.pluck(:id)\n      target_audience[:user_ids] |= allowed_group_users.pluck(:id)\n    else\n      target_audience[:group_ids] = secure_group_ids\n    end\n\n    target_audience\n  end\n\n  def self.publish_stats_to_clients!(topic_id, type, opts = {})\n    topic = Topic.find_by(id: topic_id)\n    return unless topic.present?\n\n    case type\n    when :liked, :unliked\n      stats = { like_count: topic.like_count }\n    when :created, :destroyed, :deleted, :recovered\n      stats = {\n        posts_count: topic.posts_count,\n        last_posted_at: topic.last_posted_at.as_json,\n        last_poster: BasicUserSerializer.new(topic.last_poster, root: false).as_json,\n      }\n    else\n      stats = nil\n    end\n\n    if stats\n      secure_audience = topic.secure_audience_publish_messages\n\n      if secure_audience[:user_ids] != [] && secure_audience[:group_ids] != []\n        message = stats.merge({ id: topic_id, updated_at: Time.now, type: :stats })\n        MessageBus.publish(\"/topic/#{topic_id}\", message, opts.merge(secure_audience))\n      end\n    end\n  end\n\n  def group_pm?\n    private_message? && all_allowed_users.count > 2\n  end\n\n  private\n\n  def invite_to_private_message(invited_by, target_user, guardian)\n    if !guardian.can_send_private_message?(target_user)\n      raise UserExists.new(I18n.t(\"activerecord.errors.models.topic.attributes.base.cant_send_pm\"))\n    end\n\n    rate_limit_topic_invitation(invited_by)\n\n    Topic.transaction do\n      unless topic_allowed_users.exists?(user_id: target_user.id)\n        topic_allowed_users.create!(user_id: target_user.id)\n      end\n\n      user_in_allowed_group = (user.group_ids & topic_allowed_groups.map(&:group_id)).present?\n      add_small_action(invited_by, \"invited_user\", target_user.username) if !user_in_allowed_group\n\n      create_invite_notification!(\n        target_user,\n        Notification.types[:invited_to_private_message],\n        invited_by,\n      )\n    end\n  end\n\n  def invite_to_topic(invited_by, target_user, group_ids, guardian)\n    Topic.transaction do\n      rate_limit_topic_invitation(invited_by)\n\n      if group_ids.present?\n        (\n          self.category.groups.where(id: group_ids).where(automatic: false) -\n            target_user.groups.where(automatic: false)\n        ).each do |group|\n          if guardian.can_edit_group?(group)\n            group.add(target_user)\n\n            GroupActionLogger.new(invited_by, group).log_add_user_to_group(target_user)\n          end\n        end\n      end\n\n      if Guardian.new(target_user).can_see_topic?(self)\n        create_invite_notification!(target_user, Notification.types[:invited_to_topic], invited_by)\n      end\n    end\n  end\n\n  def limit_first_day_topics_per_day\n    apply_per_day_rate_limit_for(\"first-day-topics\", :max_topics_in_first_day)\n  end\n\n  def apply_per_day_rate_limit_for(key, method_name)\n    RateLimiter.new(user, \"#{key}-per-day\", SiteSetting.get(method_name), 1.day.to_i)\n  end\nend\n\n# == Schema Information\n#\n# Table name: topics\n#\n#  id                        :integer          not null, primary key\n#  title                     :string           not null\n#  last_posted_at            :datetime\n#  created_at                :datetime         not null\n#  updated_at                :datetime         not null\n#  views                     :integer          default(0), not null\n#  posts_count               :integer          default(0), not null\n#  user_id                   :integer\n#  last_post_user_id         :integer          not null\n#  reply_count               :integer          default(0), not null\n#  featured_user1_id         :integer\n#  featured_user2_id         :integer\n#  featured_user3_id         :integer\n#  deleted_at                :datetime\n#  highest_post_number       :integer          default(0), not null\n#  like_count                :integer          default(0), not null\n#  incoming_link_count       :integer          default(0), not null\n#  category_id               :integer\n#  visible                   :boolean          default(TRUE), not null\n#  moderator_posts_count     :integer          default(0), not null\n#  closed                    :boolean          default(FALSE), not null\n#  archived                  :boolean          default(FALSE), not null\n#  bumped_at                 :datetime         not null\n#  has_summary               :boolean          default(FALSE), not null\n#  archetype                 :string           default(\"regular\"), not null\n#  featured_user4_id         :integer\n#  notify_moderators_count   :integer          default(0), not null\n#  spam_count                :integer          default(0), not null\n#  pinned_at                 :datetime\n#  score                     :float\n#  percent_rank              :float            default(1.0), not null\n#  subtype                   :string\n#  slug                      :string\n#  deleted_by_id             :integer\n#  participant_count         :integer          default(1)\n#  word_count                :integer\n#  excerpt                   :string\n#  pinned_globally           :boolean          default(FALSE), not null\n#  pinned_until              :datetime\n#  fancy_title               :string\n#  highest_staff_post_number :integer          default(0), not null\n#  featured_link             :string\n#  reviewable_score          :float            default(0.0), not null\n#  image_upload_id           :bigint\n#  slow_mode_seconds         :integer          default(0), not null\n#  bannered_until            :datetime\n#  external_id               :string\n#\n# Indexes\n#\n#  idx_topics_front_page                   (deleted_at,visible,archetype,category_id,id)\n#  idx_topics_user_id_deleted_at           (user_id) WHERE (deleted_at IS NULL)\n#  idxtopicslug                            (slug) WHERE ((deleted_at IS NULL) AND (slug IS NOT NULL))\n#  index_topics_on_bannered_until          (bannered_until) WHERE (bannered_until IS NOT NULL)\n#  index_topics_on_bumped_at_public        (bumped_at) WHERE ((deleted_at IS NULL) AND ((archetype)::text <> 'private_message'::text))\n#  index_topics_on_created_at_and_visible  (created_at,visible) WHERE ((deleted_at IS NULL) AND ((archetype)::text <> 'private_message'::text))\n#  index_topics_on_external_id             (external_id) UNIQUE WHERE (external_id IS NOT NULL)\n#  index_topics_on_id_and_deleted_at       (id,deleted_at)\n#  index_topics_on_id_filtered_banner      (id) UNIQUE WHERE (((archetype)::text = 'banner'::text) AND (deleted_at IS NULL))\n#  index_topics_on_image_upload_id         (image_upload_id)\n#  index_topics_on_lower_title             (lower((title)::text))\n#  index_topics_on_pinned_at               (pinned_at) WHERE (pinned_at IS NOT NULL)\n#  index_topics_on_pinned_globally         (pinned_globally) WHERE pinned_globally\n#  index_topics_on_pinned_until            (pinned_until) WHERE (pinned_until IS NOT NULL)\n#  index_topics_on_timestamps_private      (bumped_at,created_at,updated_at) WHERE ((deleted_at IS NULL) AND ((archetype)::text = 'private_message'::text))\n#  index_topics_on_updated_at_public       (updated_at,visible,highest_staff_post_number,highest_post_number,category_id,created_at,id) WHERE (((archetype)::text <> 'private_message'::text) AND (deleted_at IS NULL))\n#\n", "# frozen_string_literal: true\n\nmodule TopicTagsMixin\n  def self.included(klass)\n    klass.attributes :tags\n    klass.attributes :tags_descriptions\n  end\n\n  def include_tags?\n    scope.can_see_tags?(topic)\n  end\n\n  def tags\n    all_tags.map(&:name)\n  end\n\n  def tags_descriptions\n    all_tags.each.with_object({}) { |tag, acc| acc[tag.name] = tag.description }.compact\n  end\n\n  def topic\n    object.is_a?(Topic) ? object : object.topic\n  end\n\n  private\n\n  def all_tags\n    return @tags if defined?(@tags)\n    # Calling method `pluck` or `order` along with `includes` causing N+1 queries\n    tags =\n      (\n        if SiteSetting.tags_sort_alphabetically\n          topic.tags.sort_by(&:name)\n        else\n          topic_count_column = Tag.topic_count_column(scope)\n          topic.tags.sort_by { |tag| tag.public_send(topic_count_column) }.reverse\n        end\n      )\n    tags = tags.reject { |tag| scope.hidden_tag_names.include?(tag[:name]) } if !scope.is_staff?\n    @tags = tags\n  end\nend\n", "<%- if include_crawler_content? %>\n\n<%= server_plugin_outlet \"topic_list_header\" %>\n\n<%- if SiteSetting.tagging_enabled && @tag_id %>\n  <h1>\n    <%= link_to \"#{Discourse.base_url}/tag/#{@tag_id}\", itemprop: 'item' do %>\n      <span itemprop='name'><%= @tag_id %></span>\n    <% end %>\n  </h1>\n<% end %>\n\n<% if @category %>\n  <h1>\n    <% if @category.parent_category %>\n      <%= link_to @category.parent_category.url, itemprop: 'item' do %>\n        <span itemprop='name'><%= @category.parent_category.name %></span>\n      <% end %>\n      &nbsp;\n    <% end %>\n\n    <%= link_to @category.url, itemprop: 'item' do %>\n      <span itemprop='name'><%= @category.name %></span>\n    <% end %>\n  </h1>\n  <br/>\n\n  <% if params[:page].to_i == 0 && @subcategories.present? %>\n    <% @subcategories.each do |subcategory| %>\n      <a href='<%= subcategory.url %>'>\n        <span itemprop='name'><%= subcategory.name %></span>\n      </a>\n      <% if subcategory.description.present? %>\n        <span itemprop='description'><%= subcategory.description_text %></span>\n      <% end %>\n    <% end %>\n    <br/>\n  <% end %>\n<% end %>\n\n<div class=\"topic-list-container\" itemscope itemtype='http://schema.org/ItemList'>\n  <meta itemprop='itemListOrder' content='http://schema.org/ItemListOrderDescending'>\n\n  <table class='topic-list'>\n\n    <thead>\n      <tr>\n        <th><%= t 'js.topic.title' %></th>\n        <th></th>\n        <th class=\"replies\"><%= t 'js.replies' %></th>\n        <th class=\"views\"><%= t 'js.views' %></th>\n        <th><%= t 'js.activity' %></th>\n      </tr>\n    </thead>\n\n    <tbody>\n      <% @list.topics.each_with_index do |t,i| %>\n        <tr class=\"topic-list-item\">\n          <td class=\"main-link\" itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>\n            <meta itemprop='position' content='<%= i + 1 %>'>\n            <span class=\"link-top-line\">\n              <a itemprop='url' href='<%= t.url %>' class='title raw-link raw-topic-link'><%= t.title %></a>\n            </span>\n            <div class=\"link-bottom-line\">\n              <% if (!@category || @category.has_children?) && t.category && !t.category.uncategorized? %>\n                <a href='<%= t.category.url %>' class='badge-wrapper bullet'>\n                  <span class='badge-category-bg' style='background-color: #<%= t.category.color %>'></span>\n                  <span class='badge-category clear-badge'>\n                    <span class='category-name'><%= t.category.name %></span>\n                  </span>\n                </a>\n              <% end %>\n              <% if t.tags %>\n                <div class=\"discourse-tags\">\n                  <% t.tags.each_with_index do |tag, index| %>\n                    <a href='<%= tag.full_url %>' class='discourse-tag'><%= tag.name %></a>\n                    <% if index < t.tags.size - 1 %>,&nbsp;<% end %>\n                  <% end %>\n                </div>\n              <% end %>\n            </div>\n            <% if t.pinned_until && (t.pinned_until > Time.zone.now) && (t.pinned_globally || @list.category) && t.excerpt %>\n              <p class='excerpt'>\n                <%= t.excerpt.html_safe %>\n              </p>\n            <% end %>\n          </td>\n          <td class='posters'>\n            <% t.posters.each do |poster| %>\n              <a href=\"<%= Discourse.base_url %>/u/<%= poster.user.username %>\" class=\"<%= poster.extras %>\">\n                <img width=\"25\" height=\"25\" src=\"<%= poster.user.avatar_template.gsub('{size}', '25') %>\" class=\"avatar\" title='<%= h(poster.name_and_description) %>' aria-label='<%= h(poster.name_and_description) %>'>\n              </a>\n            <% end %>\n          </td>\n          <td class=\"replies\">\n            <span class='posts' title='<%= t 'posts' %>'><%= t.posts_count - 1 %></span>\n          </td>\n          <td class=\"views\">\n            <span class='views' title='<%= t 'views' %>'><%= t.views %></span>\n          </td>\n          <td>\n            <%= I18n.l(t.last_posted_at || t.created_at, format: :date_only) %>\n          </td>\n        </tr>\n      <% end %>\n    </tbody>\n\n  </table>\n</div>\n\n<% if @list.topics.length > 0 && @list.more_topics_url %>\n  <div class=\"navigation\" role='navigation' itemscope itemtype='http://schema.org/SiteNavigationElement'>\n    <% if params[:page].to_i > 0 %>\n      <span itemprop='name'><a href='<%= @list.prev_topics_url %>' rel='prev' itemprop='url'><%= t 'prev_page' %></a> &nbsp;</span>\n    <% end %>\n    <% if @list.topics.size == @list.per_page %>\n      <span itemprop='name'><b><a href='<%= @list.more_topics_url %>' rel='next' itemprop='url'><%= t 'next_page' %></a></b></span>\n    <% end %>\n  </div>\n\n  <% content_for :head do %>\n    <% if params[:page].to_i > 0 %>\n      <link rel=\"prev\" href=\"<%= @list.prev_topics_url -%>\">\n    <% end %>\n    <link rel=\"next\" href=\"<%= @list.more_topics_url -%>\">\n  <% end %>\n<% end %>\n\n<%- end %> <!-- include_crawler_content? -->\n\n<% if @rss %>\n  <% content_for :head do %>\n    <%= auto_discovery_link_tag(:rss, \"#{Discourse.base_url}/posts.rss\", title: I18n.t(\"rss_description.posts\")) %>\n    <%= auto_discovery_link_tag(:rss, { action: \"#{@rss}_feed\", params: @params || {} }, title: I18n.t(\"rss_description.#{@rss_description}\")) %>\n  <% end %>\n<% end %>\n\n<% if @category %>\n  <% content_for :head do %>\n    <%= auto_discovery_link_tag(:rss, { action: :category_feed }, rel: 'alternate nofollow', title: t('rss_topics_in_category', category: @category.name)) %>\n    <%= raw crawlable_meta_data(title: @category.name, description: @category.description, image: @category.uploaded_logo&.url.presence) %>\n  <% end %>\n<% elsif @tag_id %>\n  <% content_for :head do %>\n    <%= raw crawlable_meta_data(title: @title, description: @description_meta) %>\n  <% end %>\n<% else %>\n  <% content_for :head do %>\n    <%= raw crawlable_meta_data(title: SiteSetting.title, description: SiteSetting.site_description) %>\n  <% end %>\n<% end %>\n\n<% if @title %>\n  <% content_for :title do %><%= @title %><% end %>\n<% elsif @category %>\n  <% content_for :title do %><%= @category.name %> - <%= SiteSetting.title %><% end %>\n<% elsif params[:page].to_i > 1 %>\n  <% content_for :title do %><%=t 'page_num', num: params[:page].to_i + 1 %> - <%= SiteSetting.title %><% end %>\n<% end %>\n", "# frozen_string_literal: true\n\nRSpec.describe ListController do\n  fab!(:user) { Fabricate(:user) }\n  fab!(:topic) { Fabricate(:topic, user: user) }\n  fab!(:group) { Fabricate(:group, name: \"AwesomeGroup\") }\n  fab!(:admin) { Fabricate(:admin) }\n\n  before do\n    admin # to skip welcome wizard at home page `/`\n    SiteSetting.top_menu = \"latest|new|unread|categories\"\n  end\n\n  describe \"#index\" do\n    it \"does not return a 500 for invalid input\" do\n      get \"/latest?min_posts=bob\"\n      expect(response.status).to eq(400)\n\n      get \"/latest?max_posts=bob\"\n      expect(response.status).to eq(400)\n\n      get \"/latest?max_posts=1111111111111111111111111111111111111111\"\n      expect(response.status).to eq(400)\n\n      get \"/latest?page=-1\"\n      expect(response.status).to eq(400)\n\n      get \"/latest?page=2147483648\"\n      expect(response.status).to eq(400)\n\n      get \"/latest?page=1111111111111111111111111111111111111111\"\n      expect(response.status).to eq(400)\n\n      get \"/latest?tags[1]=hello\"\n      expect(response.status).to eq(400)\n    end\n\n    it \"returns 200 for legit requests\" do\n      get \"/latest.json?no_definitions=true&no_subcategories=false&page=1&_=1534296100767\"\n      expect(response.status).to eq(200)\n\n      get \"/latest.json?max_posts=12\"\n      expect(response.status).to eq(200)\n\n      get \"/latest.json?min_posts=0\"\n      expect(response.status).to eq(200)\n\n      get \"/latest?page=0\"\n      expect(response.status).to eq(200)\n\n      get \"/latest?page=1\"\n      expect(response.status).to eq(200)\n\n      get \"/latest.json?page=2147483647\"\n      expect(response.status).to eq(200)\n\n      get \"/latest?search=\"\n      expect(response.status).to eq(200)\n\n      get \"/latest.json?topic_ids%5B%5D=14583&topic_ids%5B%5D=14584\"\n      expect(response.status).to eq(200)\n\n      get \"/latest.json?topic_ids=14583%2C14584\"\n      expect(response.status).to eq(200)\n\n      get \"/latest?tags[]=hello\"\n      expect(response.status).to eq(200)\n    end\n\n    (Discourse.anonymous_filters - [:categories]).each do |filter|\n      context \"with #{filter}\" do\n        it \"succeeds\" do\n          get \"/#{filter}\"\n          expect(response.status).to eq(200)\n        end\n      end\n    end\n\n    it \"allows users to filter on a set of topic ids\" do\n      p = create_post\n\n      get \"/latest.json\", params: { topic_ids: \"#{p.topic_id}\" }\n      expect(response.status).to eq(200)\n      parsed = response.parsed_body\n      expect(parsed[\"topic_list\"][\"topics\"].length).to eq(1)\n    end\n\n    it \"shows correct title if topic list is set for homepage\" do\n      get \"/latest\"\n\n      expect(response.body).to have_tag \"title\", text: \"Discourse\"\n\n      SiteSetting.short_site_description = \"Best community\"\n      get \"/latest\"\n\n      expect(response.body).to have_tag \"title\", text: \"Discourse - Best community\"\n    end\n\n    it \"returns structured data\" do\n      get \"/latest\"\n\n      expect(response.status).to eq(200)\n      topic_list = Nokogiri.HTML5(response.body).css(\".topic-list\")\n      first_item = topic_list.css('[itemprop=\"itemListElement\"]')\n      expect(first_item.css('[itemprop=\"position\"]')[0][\"content\"]).to eq(\"1\")\n      expect(first_item.css('[itemprop=\"url\"]')[0][\"href\"]).to eq(topic.url)\n    end\n\n    it \"does not result in N+1 queries when topics have tags and tagging_enabled site setting is enabled\" do\n      SiteSetting.tagging_enabled = true\n      tag = Fabricate(:tag)\n      topic.tags << tag\n\n      # warm up\n      get \"/latest.json\"\n      expect(response.status).to eq(200)\n\n      initial_sql_queries_count =\n        track_sql_queries do\n          get \"/latest.json\"\n\n          expect(response.status).to eq(200)\n\n          body = response.parsed_body\n\n          expect(body[\"topic_list\"][\"topics\"].map { |t| t[\"id\"] }).to contain_exactly(topic.id)\n          expect(body[\"topic_list\"][\"topics\"][0][\"tags\"]).to contain_exactly(tag.name)\n        end.count\n\n      tag2 = Fabricate(:tag)\n      topic2 = Fabricate(:topic, tags: [tag2])\n\n      new_sql_queries_count =\n        track_sql_queries do\n          get \"/latest.json\"\n\n          expect(response.status).to eq(200)\n\n          body = response.parsed_body\n\n          expect(body[\"topic_list\"][\"topics\"].map { |t| t[\"id\"] }).to contain_exactly(\n            topic.id,\n            topic2.id,\n          )\n\n          expect(body[\"topic_list\"][\"topics\"][0][\"tags\"]).to contain_exactly(tag2.name)\n          expect(body[\"topic_list\"][\"topics\"][1][\"tags\"]).to contain_exactly(tag.name)\n        end.count\n\n      expect(new_sql_queries_count).to eq(initial_sql_queries_count)\n    end\n\n    it \"does not N+1 queries when topic featured users have different primary groups\" do\n      user.update!(primary_group: group)\n\n      # warm up\n      get \"/latest.json\"\n      expect(response.status).to eq(200)\n\n      initial_sql_queries_count =\n        track_sql_queries do\n          get \"/latest.json\"\n\n          expect(response.status).to eq(200)\n\n          body = response.parsed_body\n\n          expect(body[\"topic_list\"][\"topics\"].map { |t| t[\"id\"] }).to contain_exactly(topic.id)\n          expect(\n            body[\"topic_list\"][\"topics\"][0][\"posters\"].map { |p| p[\"user_id\"] },\n          ).to contain_exactly(user.id)\n        end.count\n\n      group2 = Fabricate(:group)\n      user2 = Fabricate(:user, primary_group: group2)\n      topic.update!(last_post_user_id: user2.id)\n\n      group3 = Fabricate(:group)\n      user3 = Fabricate(:user, flair_group: group3)\n      topic.update!(featured_user3_id: user3.id)\n\n      new_sql_queries_count =\n        track_sql_queries do\n          get \"/latest.json\"\n\n          expect(response.status).to eq(200)\n\n          body = response.parsed_body\n\n          expect(body[\"topic_list\"][\"topics\"].map { |t| t[\"id\"] }).to contain_exactly(topic.id)\n          expect(\n            body[\"topic_list\"][\"topics\"][0][\"posters\"].map { |p| p[\"user_id\"] },\n          ).to contain_exactly(user.id, user2.id, user3.id)\n        end.count\n\n      expect(new_sql_queries_count).to be <= initial_sql_queries_count\n    end\n  end\n\n  describe \"categories and X\" do\n    let(:category) { Fabricate(:category_with_definition) }\n    let(:sub_category) { Fabricate(:category_with_definition, parent_category: category) }\n\n    it \"returns top topics\" do\n      Fabricate(:topic, like_count: 1000, posts_count: 100)\n      TopTopic.refresh!\n\n      get \"/categories_and_top.json\"\n      data = response.parsed_body\n      expect(data[\"topic_list\"][\"topics\"].length).to eq(1)\n\n      get \"/categories_and_latest.json\"\n      data = response.parsed_body\n      expect(data[\"topic_list\"][\"topics\"].length).to eq(2)\n    end\n\n    it \"returns topics from subcategories when no_subcategories=false\" do\n      Fabricate(:topic, category: sub_category)\n      get \"/c/#{category.slug}/#{category.id}/l/latest.json?no_subcategories=false\"\n      expect(response.parsed_body[\"topic_list\"][\"topics\"].length).to eq(2)\n    end\n  end\n\n  describe \"titles for crawler layout\" do\n    it \"has no title for the default URL\" do\n      topic\n      filter = Discourse.anonymous_filters[0]\n      get \"/#{filter}\", params: { _escaped_fragment_: \"true\" }\n\n      expect(response.body).to include(I18n.t(\"rss_description.posts\"))\n\n      expect(response.body).to_not include(I18n.t(\"js.filters.with_topics\", filter: filter))\n    end\n\n    it \"has a title for non-default URLs\" do\n      topic\n      filter = Discourse.anonymous_filters[1]\n      get \"/#{filter}\", params: { _escaped_fragment_: \"true\" }\n\n      expect(response.body).to include(I18n.t(\"js.filters.with_topics\", filter: filter))\n    end\n  end\n\n  describe \"filter private messages by tag\" do\n    fab!(:user) { Fabricate(:user) }\n    fab!(:moderator) { Fabricate(:moderator) }\n    fab!(:admin) { Fabricate(:admin) }\n    let(:tag) { Fabricate(:tag) }\n    let(:private_message) { Fabricate(:private_message_topic, user: admin) }\n\n    before do\n      SiteSetting.tagging_enabled = true\n      SiteSetting.pm_tags_allowed_for_groups = \"1|2|3\"\n      Fabricate(:topic_tag, tag: tag, topic: private_message)\n    end\n\n    it \"should fail for non-staff users\" do\n      sign_in(user)\n      get \"/topics/private-messages-tags/#{user.username}/#{tag.name}.json\"\n      expect(response.status).to eq(404)\n    end\n\n    it \"should fail for staff users if empty\" do\n      SiteSetting.pm_tags_allowed_for_groups = \"\"\n\n      [moderator, admin].each do |user|\n        sign_in(user)\n        get \"/topics/private-messages-tags/#{user.username}/#{tag.name}.json\"\n        expect(response.status).to eq(404)\n      end\n    end\n\n    it \"should be success for staff users\" do\n      [moderator, admin].each do |user|\n        sign_in(user)\n        get \"/topics/private-messages-tags/#{user.username}/#{tag.name}.json\"\n        expect(response.status).to eq(200)\n      end\n    end\n\n    it \"should work for tag with unicode name\" do\n      unicode_tag = Fabricate(:tag, name: \"hello-\ud83c\uddfa\ud83c\uddf8\")\n      Fabricate(:topic_tag, tag: unicode_tag, topic: private_message)\n\n      sign_in(admin)\n      get \"/topics/private-messages-tags/#{admin.username}/#{UrlHelper.encode_component(unicode_tag.name)}.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"topic_list\"][\"topics\"].first[\"id\"]).to eq(private_message.id)\n    end\n\n    it \"should work for users who are allowed and direct links\" do\n      SiteSetting.pm_tags_allowed_for_groups = group.name\n      group.add(user)\n      sign_in(user)\n\n      get \"/u/#{user.username}/messages/tags/#{tag.name}\"\n\n      expect(response.status).to eq(200)\n    end\n  end\n\n  describe \"#private_messages_group\" do\n    describe \"when user not in personal_message_enabled_groups group\" do\n      let!(:topic) { Fabricate(:private_message_topic, allowed_groups: [group]) }\n\n      before do\n        group.add(user)\n        SiteSetting.personal_message_enabled_groups = Group::AUTO_GROUPS[:staff]\n        Group.refresh_automatic_groups!\n      end\n\n      it \"should display group private messages for an admin\" do\n        sign_in(Fabricate(:admin))\n\n        get \"/topics/private-messages-group/#{user.username}/#{group.name}.json\"\n\n        expect(response.status).to eq(200)\n\n        expect(response.parsed_body[\"topic_list\"][\"topics\"].first[\"id\"]).to eq(topic.id)\n      end\n\n      it \"should display moderator group private messages for a moderator\" do\n        moderator = Fabricate(:moderator)\n        group = Group.find(Group::AUTO_GROUPS[:moderators])\n        topic = Fabricate(:private_message_topic, allowed_groups: [group])\n\n        sign_in(moderator)\n\n        get \"/topics/private-messages-group/#{moderator.username}/#{group.name}.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"should not display group private messages for a moderator's group\" do\n        moderator = Fabricate(:moderator)\n        sign_in(moderator)\n\n        get \"/topics/private-messages-group/#{user.username}/#{group.name}.json\"\n\n        expect(response.status).to eq(404)\n      end\n    end\n\n    describe \"with unicode_usernames\" do\n      before do\n        group.add(user)\n        sign_in(user)\n        SiteSetting.unicode_usernames = false\n        Group.refresh_automatic_groups!\n      end\n\n      it \"should return the right response when user does not belong to group\" do\n        Fabricate(:private_message_topic, allowed_groups: [group])\n\n        group.remove(user)\n\n        get \"/topics/private-messages-group/#{user.username}/#{group.name}.json\"\n\n        expect(response.status).to eq(404)\n      end\n\n      it \"should return the right response\" do\n        topic = Fabricate(:private_message_topic, allowed_groups: [group])\n        get \"/topics/private-messages-group/#{user.username}/awesomegroup.json\"\n\n        expect(response.status).to eq(200)\n\n        expect(response.parsed_body[\"topic_list\"][\"topics\"].first[\"id\"]).to eq(topic.id)\n      end\n    end\n\n    describe \"with unicode_usernames\" do\n      before do\n        sign_in(user)\n        SiteSetting.unicode_usernames = true\n        Group.refresh_automatic_groups!\n      end\n\n      it \"Returns a 200 with unicode group name\" do\n        unicode_group = Fabricate(:group, name: \"\u7fa4\u7fa4\u7ec4\")\n        unicode_group.add(user)\n        topic = Fabricate(:private_message_topic, allowed_groups: [unicode_group])\n        get \"/topics/private-messages-group/#{user.username}/#{UrlHelper.encode_component(unicode_group.name)}.json\"\n        expect(response.status).to eq(200)\n\n        expect(response.parsed_body[\"topic_list\"][\"topics\"].first[\"id\"]).to eq(topic.id)\n      end\n    end\n  end\n\n  describe \"#group_topics\" do\n    %i[user user2].each do |user|\n      let(user) do\n        user = Fabricate(:user)\n        group.add(user)\n        user\n      end\n    end\n\n    let!(:topic) { Fabricate(:topic, user: user) }\n    let!(:topic2) { Fabricate(:topic, user: user2) }\n    let!(:another_topic) { Fabricate(:topic) }\n\n    describe \"when an invalid group name is given\" do\n      it \"should return the right response\" do\n        get \"/topics/groups/something.json\"\n\n        expect(response.status).to eq(404)\n      end\n    end\n\n    describe \"for an anon user\" do\n      describe \"public visible group\" do\n        it \"should return the right response\" do\n          get \"/topics/groups/#{group.name}.json\"\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"topic_list\"]).to be_present\n        end\n      end\n\n      describe \"group restricted to logged-on-users\" do\n        before { group.update!(visibility_level: Group.visibility_levels[:logged_on_users]) }\n\n        it \"should return the right response\" do\n          get \"/topics/groups/#{group.name}.json\"\n\n          expect(response.status).to eq(403)\n        end\n      end\n\n      describe \"restricted group\" do\n        before { group.update!(visibility_level: Group.visibility_levels[:staff]) }\n\n        it \"should return the right response\" do\n          get \"/topics/groups/#{group.name}.json\"\n\n          expect(response.status).to eq(403)\n        end\n      end\n\n      describe \"group members visibility restricted to logged-on-users\" do\n        before do\n          group.update!(members_visibility_level: Group.visibility_levels[:logged_on_users])\n        end\n\n        it \"should return the right response\" do\n          get \"/topics/groups/#{group.name}.json\"\n\n          expect(response.status).to eq(403)\n        end\n      end\n    end\n\n    describe \"for a normal user\" do\n      before { sign_in(Fabricate(:user)) }\n\n      describe \"restricted group\" do\n        before { group.update!(visibility_level: Group.visibility_levels[:staff]) }\n\n        it \"should return the right response\" do\n          get \"/topics/groups/#{group.name}.json\"\n\n          expect(response.status).to eq(403)\n        end\n      end\n\n      describe \"group restricted to logged-on-users\" do\n        before { group.update!(visibility_level: Group.visibility_levels[:logged_on_users]) }\n\n        it \"should return the right response\" do\n          get \"/topics/groups/#{group.name}.json\"\n\n          expect(response.status).to eq(200)\n        end\n      end\n    end\n\n    describe \"for a group user\" do\n      before { sign_in(user) }\n\n      it \"should be able to view the topics started by group users\" do\n        get \"/topics/groups/#{group.name}.json\"\n\n        expect(response.status).to eq(200)\n\n        topics = response.parsed_body[\"topic_list\"][\"topics\"]\n\n        expect(topics.map { |topic| topic[\"id\"] }).to contain_exactly(topic.id, topic2.id)\n      end\n    end\n  end\n\n  describe \"RSS feeds\" do\n    it \"renders latest RSS\" do\n      get \"/latest.rss\"\n      expect(response.status).to eq(200)\n      expect(response.media_type).to eq(\"application/rss+xml\")\n      expect(response.headers[\"X-Robots-Tag\"]).to eq(\"noindex\")\n    end\n\n    it \"renders latest RSS with query params\" do\n      get \"/latest.rss?status=closed\"\n      expect(response.status).to eq(200)\n      expect(response.media_type).to eq(\"application/rss+xml\")\n      expect(response.body).to_not include(\"<item>\")\n    end\n\n    it \"renders links correctly with subfolder\" do\n      set_subfolder \"/forum\"\n      _post = Fabricate(:post, topic: topic, user: user)\n      get \"/latest.rss\"\n      expect(response.status).to eq(200)\n      expect(response.body).to_not include(\"/forum/forum\")\n      expect(response.body).to include(\"http://test.localhost/forum/t/#{topic.slug}\")\n    end\n\n    it \"renders top RSS\" do\n      get \"/top.rss\"\n      expect(response.status).to eq(200)\n      expect(response.media_type).to eq(\"application/rss+xml\")\n    end\n\n    it \"errors for invalid periods on top RSS\" do\n      get \"/top.rss?period=decadely\"\n      expect(response.status).to eq(400)\n    end\n\n    TopTopic.periods.each do |period|\n      it \"renders #{period} top RSS\" do\n        get \"/top.rss?period=#{period}\"\n        expect(response.status).to eq(200)\n        expect(response.media_type).to eq(\"application/rss+xml\")\n      end\n    end\n  end\n\n  describe \"Top\" do\n    it \"renders top\" do\n      get \"/top\"\n      expect(response.status).to eq(200)\n    end\n\n    it \"renders top with a period\" do\n      get \"/top?period=weekly\"\n      expect(response.status).to eq(200)\n    end\n\n    it \"errors for invalid periods on top\" do\n      get \"/top?period=decadely\"\n      expect(response.status).to eq(400)\n    end\n  end\n\n  describe \"category\" do\n    context \"when in a category\" do\n      let(:category) { Fabricate(:category_with_definition) }\n      let(:group) { Fabricate(:group) }\n      let(:private_category) { Fabricate(:private_category, group: group) }\n\n      context \"without access to see the category\" do\n        it \"responds with a 404 error\" do\n          get \"/c/#{private_category.slug}/l/latest\"\n          expect(response.status).to eq(404)\n        end\n      end\n\n      context \"with access to see the category\" do\n        it \"succeeds\" do\n          get \"/c/#{category.slug}/#{category.id}/l/latest\"\n          expect(response.status).to eq(200)\n        end\n      end\n\n      context \"with encoded slug in the category\" do\n        let(:category) { Fabricate(:category, slug: \"\u0ba4\u0bae\u0bbf\u0bb4\u0bcd\") }\n\n        before { SiteSetting.slug_generation_method = \"encoded\" }\n\n        it \"succeeds\" do\n          get \"/c/#{category.slug}/#{category.id}/l/latest\"\n          expect(response.status).to eq(200)\n        end\n      end\n\n      context \"with a link that has a parent slug, slug and id in its path\" do\n        let(:child_category) { Fabricate(:category_with_definition, parent_category: category) }\n\n        context \"with valid slug\" do\n          it \"succeeds\" do\n            get \"/c/#{category.slug}/#{child_category.slug}/#{child_category.id}/l/latest\"\n            expect(response.status).to eq(200)\n          end\n        end\n\n        context \"with invalid slug\" do\n          it \"redirects\" do\n            get \"/c/random_slug/another_random_slug/#{child_category.id}/l/latest\"\n            expect(response).to redirect_to(\"#{child_category.url}/l/latest\")\n          end\n        end\n      end\n\n      context \"when another category exists with a number at the beginning of its name\" do\n        # One category has another category's id at the beginning of its name\n        let!(:other_category) do\n          # Our validations don't allow this to happen now, but did historically\n          Fabricate(\n            :category_with_definition,\n            name: \"#{category.id} name\",\n            slug: \"will-be-changed\",\n          ).tap { |category| category.update_column(:slug, \"#{category.id}-name\") }\n        end\n\n        it \"uses the correct category\" do\n          get \"/c/#{other_category.slug}/#{other_category.id}/l/latest.json\"\n          expect(response.status).to eq(200)\n          body = response.parsed_body\n          expect(body[\"topic_list\"][\"topics\"].first[\"category_id\"]).to eq(other_category.id)\n        end\n      end\n\n      context \"with a child category\" do\n        let(:sub_category) { Fabricate(:category_with_definition, parent_category_id: category.id) }\n\n        context \"when parent and child are requested\" do\n          it \"succeeds\" do\n            get \"/c/#{category.slug}/#{sub_category.slug}/#{sub_category.id}/l/latest\"\n            expect(response.status).to eq(200)\n          end\n        end\n\n        context \"when child is requested with the wrong parent\" do\n          it \"responds with a 404 error\" do\n            get \"/c/not-the-right-slug/#{sub_category.slug}/l/latest\"\n            expect(response.status).to eq(404)\n          end\n        end\n      end\n\n      describe \"feed\" do\n        it \"renders RSS\" do\n          get \"/c/#{category.slug}/#{category.id}.rss\"\n          expect(response.status).to eq(200)\n          expect(response.media_type).to eq(\"application/rss+xml\")\n        end\n\n        it \"renders RSS in subfolder correctly\" do\n          set_subfolder \"/forum\"\n          get \"/c/#{category.slug}/#{category.id}.rss\"\n          expect(response.status).to eq(200)\n          expect(response.body).to_not include(\"/forum/forum\")\n          expect(response.body).to include(\"http://test.localhost/forum/c/#{category.slug}\")\n        end\n      end\n\n      describe \"category default views\" do\n        it \"has a top default view\" do\n          category.update!(default_view: \"top\", default_top_period: \"monthly\")\n          get \"/c/#{category.slug}/#{category.id}.json\"\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json[\"topic_list\"][\"for_period\"]).to eq(\"monthly\")\n        end\n\n        it \"has a default view of nil\" do\n          category.update!(default_view: nil)\n          get \"/c/#{category.slug}/#{category.id}.json\"\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json[\"topic_list\"][\"for_period\"]).to be_blank\n        end\n\n        it \"has a default view of ''\" do\n          category.update!(default_view: \"\")\n          get \"/c/#{category.slug}/#{category.id}.json\"\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json[\"topic_list\"][\"for_period\"]).to be_blank\n        end\n\n        it \"has a default view of latest\" do\n          category.update!(default_view: \"latest\")\n          get \"/c/#{category.slug}/#{category.id}.json\"\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json[\"topic_list\"][\"for_period\"]).to be_blank\n        end\n      end\n\n      describe \"renders canonical tag\" do\n        it \"for category default view\" do\n          get \"/c/#{category.slug}/#{category.id}\"\n          expect(response.status).to eq(200)\n          expect(css_select(\"link[rel=canonical]\").length).to eq(1)\n        end\n\n        it \"for category latest view\" do\n          get \"/c/#{category.slug}/#{category.id}/l/latest\"\n          expect(response.status).to eq(200)\n          expect(css_select(\"link[rel=canonical]\").length).to eq(1)\n        end\n      end\n\n      context \"for category default view\" do\n        let!(:amazing_category) { Fabricate(:category_with_definition, name: \"Amazing Category\") }\n\n        it \"renders correct title\" do\n          get \"/c/#{amazing_category.slug}/#{amazing_category.id}\"\n\n          expect(response.body).to have_tag \"title\", text: \"Amazing Category - Discourse\"\n        end\n      end\n\n      context \"for category latest view\" do\n        let!(:amazing_category) { Fabricate(:category_with_definition, name: \"Amazing Category\") }\n\n        it \"renders correct title\" do\n          SiteSetting.short_site_description = \"Best community\"\n          get \"/c/#{amazing_category.slug}/#{amazing_category.id}/l/latest\"\n\n          expect(response.body).to have_tag \"title\", text: \"Amazing Category - Discourse\"\n        end\n      end\n    end\n  end\n\n  describe \"topics_by\" do\n    fab!(:topic2) { Fabricate(:topic, user: user) }\n    fab!(:user2) { Fabricate(:user) }\n\n    before { sign_in(user2) }\n\n    it \"should respond with a list\" do\n      get \"/topics/created-by/#{user.username}.json\"\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"topic_list\"][\"topics\"].size).to eq(2)\n    end\n\n    it \"should work with period in username\" do\n      user.update!(username: \"myname.test\")\n      get \"/topics/created-by/#{user.username}\", xhr: true\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"topic_list\"][\"topics\"].size).to eq(2)\n    end\n\n    context \"with unicode usernames\" do\n      before { SiteSetting.unicode_usernames = true }\n\n      it \"should return the more_topics_url in the encoded form\" do\n        stub_const(TopicQuery, \"DEFAULT_PER_PAGE_COUNT\", 1) do\n          user.update!(username: \"\u5feb\u5feb\u5feb\")\n\n          get \"/topics/created-by/#{UrlHelper.encode(user.username)}.json\"\n\n          expect(response.status).to eq(200)\n\n          json = response.parsed_body\n\n          expect(json[\"topic_list\"][\"more_topics_url\"]).to eq(\n            \"/topics/created-by/%E5%BF%AB%E5%BF%AB%E5%BF%AB?page=1\",\n          )\n        end\n      end\n    end\n\n    context \"when `hide_profile_and_presence` is true\" do\n      before { user.user_option.update_columns(hide_profile_and_presence: true) }\n\n      it \"returns 404\" do\n        get \"/topics/created-by/#{user.username}.json\"\n        expect(response.status).to eq(404)\n      end\n\n      it \"should respond with a list when `allow_users_to_hide_profile` is false\" do\n        SiteSetting.allow_users_to_hide_profile = false\n        get \"/topics/created-by/#{user.username}.json\"\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"topic_list\"][\"topics\"].size).to eq(2)\n      end\n    end\n  end\n\n  describe \"private_messages\" do\n    it \"returns 403 error when the user can't see private message\" do\n      sign_in(Fabricate(:user))\n      get \"/topics/private-messages/#{user.username}.json\"\n      expect(response).to be_forbidden\n    end\n\n    it \"succeeds when the user can see private messages\" do\n      pm = Fabricate(:private_message_topic, user: Fabricate(:user))\n      pm.topic_allowed_users.create!(user: user)\n      sign_in(user)\n      get \"/topics/private-messages/#{user.username}.json\"\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"topic_list\"][\"topics\"].size).to eq(1)\n    end\n  end\n\n  describe \"private_messages_sent\" do\n    before do\n      pm = Fabricate(:private_message_topic, user: user)\n      Fabricate(:post, user: user, topic: pm, post_number: 1)\n    end\n\n    it \"returns 403 error when the user can't see private message\" do\n      sign_in(Fabricate(:user))\n      get \"/topics/private-messages-sent/#{user.username}.json\"\n      expect(response).to be_forbidden\n    end\n\n    it \"succeeds when the user can see private messages\" do\n      sign_in(user)\n      get \"/topics/private-messages-sent/#{user.username}.json\"\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"topic_list\"][\"topics\"].size).to eq(1)\n    end\n  end\n\n  describe \"#private_messages_unread\" do\n    fab!(:pm_user) { Fabricate(:user) }\n\n    fab!(:pm) do\n      Fabricate(:private_message_topic).tap do |t|\n        t.allowed_users << pm_user\n        create_post(user: pm_user, topic_id: t.id)\n      end\n    end\n\n    it \"returns 404 when the user can't see private message\" do\n      sign_in(Fabricate(:user))\n      get \"/topics/private-messages-unread/#{pm_user.username}.json\"\n      expect(response.status).to eq(404)\n    end\n\n    it \"succeeds when the user can see private messages\" do\n      TopicUser.find_by(topic: pm, user: pm_user).update!(\n        notification_level: TopicUser.notification_levels[:tracking],\n        last_read_post_number: 0,\n      )\n\n      sign_in(pm_user)\n      get \"/topics/private-messages-unread/#{pm_user.username}.json\"\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"topic_list\"][\"topics\"].size).to eq(1)\n      expect(json[\"topic_list\"][\"topics\"][0][\"id\"]).to eq(pm.id)\n    end\n  end\n\n  describe \"#private_messages_warnings\" do\n    fab!(:target_user) { Fabricate(:user) }\n    fab!(:admin) { Fabricate(:admin) }\n    fab!(:moderator1) { Fabricate(:moderator) }\n    fab!(:moderator2) { Fabricate(:moderator) }\n\n    let(:create_args) do\n      {\n        title: \"you need a warning buddy!\",\n        raw: \"you did something bad and I'm telling you about it!\",\n        is_warning: true,\n        target_usernames: target_user.username,\n        archetype: Archetype.private_message,\n      }\n    end\n\n    let(:warning_post) do\n      creator = PostCreator.new(moderator1, create_args)\n      creator.create\n    end\n    let(:warning_topic) { warning_post.topic }\n\n    before { warning_topic }\n\n    it \"returns 403 error for unrelated users\" do\n      sign_in(Fabricate(:user))\n      get \"/topics/private-messages-warnings/#{target_user.username}.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it \"shows the warning to moderators and admins\" do\n      [moderator1, moderator2, admin].each do |viewer|\n        sign_in(viewer)\n        get \"/topics/private-messages-warnings/#{target_user.username}.json\"\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"topic_list\"][\"topics\"].size).to eq(1)\n        expect(json[\"topic_list\"][\"topics\"][0][\"id\"]).to eq(warning_topic.id)\n      end\n    end\n\n    it \"does not show the warning as applying to the authoring moderator\" do\n      sign_in(admin)\n      get \"/topics/private-messages-warnings/#{moderator1.username}.json\"\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"topic_list\"][\"topics\"].size).to eq(0)\n    end\n  end\n\n  describe \"read\" do\n    it \"raises an error when not logged in\" do\n      get \"/read\"\n      expect(response.status).to eq(404)\n    end\n\n    context \"when logged in\" do\n      it \"succeeds\" do\n        sign_in(user)\n        get \"/read\"\n        expect(response.status).to eq(200)\n      end\n    end\n  end\n\n  describe \"best_periods_for\" do\n    it \"works\" do\n      expect(ListController.best_periods_for(nil)).to eq([:all])\n      expect(ListController.best_periods_for(5.years.ago)).to eq([:all])\n      expect(ListController.best_periods_for(2.years.ago)).to eq(%i[yearly all])\n      expect(ListController.best_periods_for(6.months.ago)).to eq(%i[quarterly yearly all])\n      expect(ListController.best_periods_for(2.months.ago)).to eq(%i[monthly quarterly yearly all])\n      expect(ListController.best_periods_for(2.weeks.ago)).to eq(\n        %i[weekly monthly quarterly yearly all],\n      )\n      expect(ListController.best_periods_for(2.days.ago)).to eq(\n        %i[daily weekly monthly quarterly yearly all],\n      )\n    end\n\n    it \"supports default period\" do\n      expect(ListController.best_periods_for(nil, :yearly)).to eq(%i[yearly all])\n      expect(ListController.best_periods_for(nil, :quarterly)).to eq(%i[quarterly all])\n      expect(ListController.best_periods_for(nil, :monthly)).to eq(%i[monthly all])\n      expect(ListController.best_periods_for(nil, :weekly)).to eq(%i[weekly all])\n      expect(ListController.best_periods_for(nil, :daily)).to eq(%i[daily all])\n    end\n  end\n\n  describe \"user_topics_feed\" do\n    it \"returns 404 if `hide_profile_and_presence` user option is checked\" do\n      user.user_option.update_columns(hide_profile_and_presence: true)\n      get \"/u/#{user.username}/activity/topics.rss\"\n      expect(response.status).to eq(404)\n    end\n  end\n\n  describe \"set_category\" do\n    let(:category) { Fabricate(:category_with_definition) }\n    let(:subcategory) { Fabricate(:category_with_definition, parent_category_id: category.id) }\n    let(:subsubcategory) do\n      Fabricate(:category_with_definition, parent_category_id: subcategory.id)\n    end\n\n    before { SiteSetting.max_category_nesting = 3 }\n\n    it \"redirects to URL with the updated slug\" do\n      get \"/c/hello/world/bye/#{subsubcategory.id}\"\n      expect(response.status).to eq(301)\n      expect(response).to redirect_to(\n        \"/c/#{category.slug}/#{subcategory.slug}/#{subsubcategory.slug}/#{subsubcategory.id}\",\n      )\n\n      get \"/c/#{category.slug}/#{subcategory.slug}/#{subsubcategory.slug}/#{subsubcategory.id}\"\n      expect(response.status).to eq(200)\n    end\n\n    it \"redirects to URL with correct case slug\" do\n      category.update!(slug: \"hello\")\n\n      get \"/c/Hello/#{category.id}\"\n      expect(response).to redirect_to(\"/c/hello/#{category.id}\")\n\n      get \"/c/hello/#{category.id}\"\n      expect(response.status).to eq(200)\n    end\n\n    context \"with encoded slugs\" do\n      it \"does not create a redirect loop\" do\n        category = Fabricate(:category)\n        category.update_columns(slug: CGI.escape(\"syst\u00e8mes\"))\n\n        get \"/c/syst%C3%A8mes/#{category.id}\"\n        expect(response.status).to eq(200)\n      end\n    end\n\n    context \"with lowercase encoded slugs\" do\n      it \"does not create a redirect loop\" do\n        category = Fabricate(:category)\n        category.update_columns(slug: CGI.escape(\"syst\u00e8mes\").downcase)\n\n        get \"/c/syst%C3%A8mes/#{category.id}\"\n        expect(response.status).to eq(200)\n      end\n    end\n\n    context \"with subfolder\" do\n      it \"main category redirects to URL containing the updated slug\" do\n        set_subfolder \"/forum\"\n        get \"/c/#{category.slug}\"\n\n        expect(response.status).to eq(301)\n        expect(response).to redirect_to(\"/forum/c/#{category.slug}/#{category.id}\")\n      end\n\n      it \"sub-sub-category redirects to URL containing the updated slug\" do\n        set_subfolder \"/forum\"\n        get \"/c/hello/world/bye/#{subsubcategory.id}\"\n\n        expect(response.status).to eq(301)\n        expect(response).to redirect_to(\n          \"/forum/c/#{category.slug}/#{subcategory.slug}/#{subsubcategory.slug}/#{subsubcategory.id}\",\n        )\n      end\n    end\n  end\n\n  describe \"shared drafts\" do\n    fab!(:category1) { Fabricate(:category) }\n    fab!(:category2) { Fabricate(:category) }\n\n    fab!(:topic1) { Fabricate(:topic, category: category1) }\n    fab!(:topic2) { Fabricate(:topic, category: category2) }\n\n    fab!(:shared_draft_topic) { Fabricate(:topic, category: category1) }\n    fab!(:shared_draft) { Fabricate(:shared_draft, topic: shared_draft_topic, category: category2) }\n\n    it \"are not displayed if they are disabled\" do\n      SiteSetting.shared_drafts_category = \"\"\n      sign_in(admin)\n\n      get \"/c/#{category1.slug}/#{category1.id}.json\"\n      expect(response.parsed_body[\"topic_list\"][\"shared_drafts\"]).to eq(nil)\n      expect(response.parsed_body[\"topic_list\"][\"topics\"].map { |t| t[\"id\"] }).to contain_exactly(\n        topic1.id,\n        shared_draft_topic.id,\n      )\n    end\n\n    it \"are displayed in both shared drafts category and target category\" do\n      SiteSetting.shared_drafts_category = category1.id\n      sign_in(admin)\n\n      get \"/c/#{category1.slug}/#{category1.id}.json\"\n      expect(response.parsed_body[\"topic_list\"][\"shared_drafts\"]).to be_nil\n      expect(response.parsed_body[\"topic_list\"][\"topics\"].map { |t| t[\"id\"] }).to contain_exactly(\n        topic1.id,\n        shared_draft_topic.id,\n      )\n\n      get \"/c/#{category2.slug}/#{category2.id}.json\"\n      expect(\n        response.parsed_body[\"topic_list\"][\"shared_drafts\"].map { |t| t[\"id\"] },\n      ).to contain_exactly(shared_draft_topic.id)\n      expect(response.parsed_body[\"topic_list\"][\"topics\"].map { |t| t[\"id\"] }).to contain_exactly(\n        topic2.id,\n      )\n    end\n  end\n\n  describe \"body class\" do\n    it \"pre-renders the correct body class for categories\" do\n      c = Fabricate(:category, slug: \"myparentslug\")\n      sub_c = Fabricate(:category, parent_category: c, slug: \"mychildslug\")\n\n      get \"/c/#{c.slug}/#{sub_c.slug}/#{sub_c.id}\"\n\n      expect(response.body).to have_tag \"body\", with: { class: \"category-myparentslug-mychildslug\" }\n    end\n  end\n\n  describe \"#filter\" do\n    fab!(:category) { Fabricate(:category, slug: \"category-slug\") }\n    fab!(:tag) { Fabricate(:tag, name: \"tag1\") }\n    fab!(:group) { Fabricate(:group) }\n    fab!(:private_category) { Fabricate(:private_category, group:, slug: \"private-category-slug\") }\n    fab!(:private_message_topic) { Fabricate(:private_message_topic) }\n    fab!(:topic_in_private_category) { Fabricate(:topic, category: private_category) }\n\n    before { SiteSetting.experimental_topics_filter = true }\n\n    it \"should not return topics that the user is not allowed to view\" do\n      sign_in(user)\n\n      get \"/filter.json\"\n\n      expect(response.status).to eq(200)\n\n      expect(\n        response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] },\n      ).to contain_exactly(topic.id)\n    end\n\n    it \"should respond with 403 response code for an anonymous user\" do\n      get \"/filter.json\"\n\n      expect(response.status).to eq(403)\n    end\n\n    it \"should respond with 404 response code when `experimental_topics_filter` site setting has not been enabled\" do\n      SiteSetting.experimental_topics_filter = false\n\n      sign_in(user)\n\n      get \"/filter.json\"\n\n      expect(response.status).to eq(404)\n    end\n\n    it \"returns category definition topics if `show_category_definitions_in_topic_lists` site setting is enabled\" do\n      category_topic = Fabricate(:topic, category: category)\n      category.update!(topic: category_topic)\n\n      SiteSetting.show_category_definitions_in_topic_lists = true\n\n      sign_in(user)\n\n      get \"/filter.json\"\n\n      expect(response.status).to eq(200)\n\n      expect(\n        response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] },\n      ).to contain_exactly(topic.id, category_topic.id)\n    end\n\n    it \"does not return category definition topics if `show_category_definitions_in_topic_lists` site setting is disabled\" do\n      category_topic = Fabricate(:topic, category: category)\n      category.update!(topic: category_topic)\n\n      SiteSetting.show_category_definitions_in_topic_lists = false\n\n      sign_in(user)\n\n      get \"/filter.json\"\n\n      expect(response.status).to eq(200)\n\n      expect(\n        response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] },\n      ).to contain_exactly(topic.id)\n    end\n\n    it \"should accept the `page` query parameter\" do\n      topic_with_tag = Fabricate(:topic, tags: [tag])\n      topic2_with_tag = Fabricate(:topic, tags: [tag])\n\n      stub_const(TopicQuery, \"DEFAULT_PER_PAGE_COUNT\", 1) do\n        sign_in(user)\n\n        get \"/filter.json\", params: { q: \"tags:tag1\" }\n\n        expect(response.status).to eq(200)\n\n        parsed = response.parsed_body\n\n        expect(parsed[\"topic_list\"][\"topics\"].length).to eq(1)\n        expect(parsed[\"topic_list\"][\"topics\"].first[\"id\"]).to eq(topic2_with_tag.id)\n\n        get \"/filter.json\", params: { q: \"tags:tag1\", page: 1 }\n\n        expect(response.status).to eq(200)\n\n        parsed = response.parsed_body\n\n        expect(parsed[\"topic_list\"][\"topics\"].length).to eq(1)\n        expect(parsed[\"topic_list\"][\"topics\"].first[\"id\"]).to eq(topic_with_tag.id)\n      end\n    end\n\n    describe \"when filtering with the `created-by:<username>` filter\" do\n      fab!(:topic2) { Fabricate(:topic, user: admin) }\n\n      before do\n        topic.update!(user: user)\n        user.update!(username: \"username\")\n        admin.update!(username: \"username2\")\n      end\n\n      it \"returns only topics created by the user when `q` query param is `created-by:username`\" do\n        sign_in(user)\n\n        get \"/filter.json\", params: { q: \"created-by:username\" }\n\n        expect(response.status).to eq(200)\n\n        expect(\n          response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] },\n        ).to contain_exactly(topic.id)\n      end\n\n      it \"returns only topics created by either user when `q` query param is `created-by:username,username2`\" do\n        sign_in(user)\n\n        get \"/filter.json\", params: { q: \"created-by:username,username2\" }\n\n        expect(response.status).to eq(200)\n\n        expect(\n          response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] },\n        ).to contain_exactly(topic.id, topic2.id)\n      end\n    end\n\n    describe \"when filtering with the `category:<category_slug>` filter\" do\n      fab!(:topic_in_category) { Fabricate(:topic, category:) }\n\n      it \"does not return any topics when `q` query param is `category:private-category-slug` and user is not allowed to see category\" do\n        sign_in(user)\n\n        get \"/filter.json\", params: { q: \"category:private-category-slug\" }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] }).to eq([])\n      end\n\n      it \"returns only topics in the category when `q` query param is `category:private-category-slug` and user can see category\" do\n        group.add(user)\n\n        sign_in(user)\n\n        get \"/filter.json\", params: { q: \"category:private-category-slug\" }\n\n        expect(response.status).to eq(200)\n\n        expect(\n          response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] },\n        ).to contain_exactly(topic_in_private_category.id)\n      end\n    end\n\n    describe \"when filtering with the `in:<topic_notification_level>` filter\" do\n      fab!(:user_muted_topic) do\n        Fabricate(:topic).tap do |topic|\n          TopicUser.change(\n            user.id,\n            topic.id,\n            notification_level: TopicUser.notification_levels[:muted],\n          )\n        end\n      end\n\n      fab!(:user_tracking_topic) do\n        Fabricate(:topic).tap do |topic|\n          TopicUser.change(\n            user.id,\n            topic.id,\n            notification_level: TopicUser.notification_levels[:tracking],\n          )\n        end\n      end\n\n      it \"does not return topics that are muted by the user when `q` query param does not include `in:muted`\" do\n        sign_in(user)\n\n        get \"/filter.json\", params: { q: \"in:tracking\" }\n\n        expect(response.status).to eq(200)\n\n        expect(response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] }).to eq(\n          [user_tracking_topic.id],\n        )\n      end\n\n      it \"only return topics that are muted by the user when `q` query param is `in:muted`\" do\n        sign_in(user)\n\n        get \"/filter.json\", params: { q: \"in:muted\" }\n\n        expect(response.status).to eq(200)\n\n        expect(response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] }).to eq(\n          [user_muted_topic.id],\n        )\n      end\n    end\n\n    describe \"when ordering using the `order:` filter\" do\n      fab!(:topic2) { Fabricate(:topic, views: 2) }\n      fab!(:topic3) { Fabricate(:topic, views: 3) }\n      fab!(:topic4) { Fabricate(:topic, views: 1) }\n\n      it \"return topics ordered by topic bumped at date in descending order when `q` query param is not present\" do\n        sign_in(user)\n\n        get \"/filter.json\"\n\n        expect(response.status).to eq(200)\n\n        expect(response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] }).to eq(\n          [topic4.id, topic3.id, topic2.id, topic.id],\n        )\n      end\n\n      it \"return topics ordered by views when `q` query param is `order:views`\" do\n        sign_in(user)\n\n        get \"/filter.json\", params: { q: \"order:views\" }\n\n        expect(response.status).to eq(200)\n\n        expect(response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] }).to eq(\n          [topic3.id, topic2.id, topic4.id, topic.id],\n        )\n      end\n    end\n\n    describe \"when filtering by status\" do\n      fab!(:group) { Fabricate(:group) }\n      fab!(:private_category) { Fabricate(:private_category, group: group) }\n      fab!(:topic_in_private_category) { Fabricate(:topic, category: private_category) }\n\n      it \"does not return topics that are unlisted when `q` query param is `status:unlisted` for a user that cannot view unlisted topics\" do\n        Topic.update_all(deleted_at: true)\n        topic.update!(visible: false)\n\n        sign_in(user)\n\n        get \"/filter.json\", params: { q: \"status:unlisted\" }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] }).to eq([])\n      end\n\n      it \"returns topics that are unlisted when `q` query param is `status:unlisted` for a user that can view unlisted topics\" do\n        Topic.update_all(visible: true)\n        topic.update!(visible: false)\n\n        sign_in(admin)\n\n        get \"/filter.json\", params: { q: \"status:unlisted\" }\n\n        expect(response.status).to eq(200)\n\n        expect(\n          response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] },\n        ).to contain_exactly(topic.id)\n      end\n\n      it \"ignores the `status` filter for a user that cannot view deleted topics when `q` query param is `status:deleted`\" do\n        Topic.update_all(deleted_at: nil)\n        topic.update!(deleted_at: Time.zone.now)\n\n        sign_in(user)\n\n        get \"/filter.json\", params: { q: \"status:deleted\" }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] }).to eq([])\n      end\n\n      it \"returns topics that are deleted when `q` query param is `status:deleted` for a user that can view deleted topics\" do\n        Topic.update_all(deleted_at: nil)\n        topic.update!(deleted_at: Time.zone.now)\n\n        sign_in(admin)\n\n        get \"/filter.json\", params: { q: \"status:deleted\" }\n\n        expect(response.status).to eq(200)\n\n        expect(\n          response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] },\n        ).to contain_exactly(topic.id)\n      end\n\n      it \"does not return topics from read restricted categories when `q` query param is `status:public`\" do\n        group.add(user)\n\n        sign_in(user)\n\n        get \"/filter.json\", params: { q: \"status:public\" }\n\n        expect(response.status).to eq(200)\n\n        expect(\n          response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] },\n        ).to contain_exactly(topic.id)\n      end\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nclass Topic < ActiveRecord::Base\n  class UserExists < StandardError\n  end\n  class NotAllowed < StandardError\n  end\n  include RateLimiter::OnCreateRecord\n  include HasCustomFields\n  include Trashable\n  include Searchable\n  include LimitedEdit\n  extend Forwardable\n\n  EXTERNAL_ID_MAX_LENGTH = 50\n\n  self.ignored_columns = [\n    \"avg_time\", # TODO(2021-01-04): remove\n    \"image_url\", # TODO(2021-06-01): remove\n  ]\n\n  def_delegator :featured_users, :user_ids, :featured_user_ids\n  def_delegator :featured_users, :choose, :feature_topic_users\n\n  def_delegator :notifier, :watch!, :notify_watch!\n  def_delegator :notifier, :track!, :notify_tracking!\n  def_delegator :notifier, :regular!, :notify_regular!\n  def_delegator :notifier, :mute!, :notify_muted!\n  def_delegator :notifier, :toggle_mute, :toggle_mute\n\n  attr_accessor :allowed_user_ids, :allowed_group_ids, :tags_changed, :includes_destination_category\n\n  def self.max_fancy_title_length\n    400\n  end\n\n  def self.share_thumbnail_size\n    [1024, 1024]\n  end\n\n  def self.thumbnail_sizes\n    [self.share_thumbnail_size] + DiscoursePluginRegistry.topic_thumbnail_sizes\n  end\n\n  def thumbnail_job_redis_key(sizes)\n    \"generate_topic_thumbnail_enqueue_#{id}_#{sizes.inspect}\"\n  end\n\n  def filtered_topic_thumbnails(extra_sizes: [])\n    return nil unless original = image_upload\n    return nil unless original.read_attribute(:width) && original.read_attribute(:height)\n\n    thumbnail_sizes = Topic.thumbnail_sizes + extra_sizes\n    topic_thumbnails.filter do |record|\n      thumbnail_sizes.include?([record.max_width, record.max_height])\n    end\n  end\n\n  def thumbnail_info(enqueue_if_missing: false, extra_sizes: [])\n    return nil unless original = image_upload\n    return nil if original.filesize >= SiteSetting.max_image_size_kb.kilobytes\n    return nil unless original.read_attribute(:width) && original.read_attribute(:height)\n\n    infos = []\n    infos << { # Always add original\n      max_width: nil,\n      max_height: nil,\n      width: original.width,\n      height: original.height,\n      url: original.url,\n    }\n\n    records = filtered_topic_thumbnails(extra_sizes: extra_sizes)\n\n    records.each do |record|\n      next unless record.optimized_image # Only serialize successful thumbnails\n\n      infos << {\n        max_width: record.max_width,\n        max_height: record.max_height,\n        width: record.optimized_image&.width,\n        height: record.optimized_image&.height,\n        url: record.optimized_image&.url,\n      }\n    end\n\n    thumbnail_sizes = Topic.thumbnail_sizes + extra_sizes\n    if SiteSetting.create_thumbnails && enqueue_if_missing &&\n         records.length < thumbnail_sizes.length &&\n         Discourse.redis.set(thumbnail_job_redis_key(extra_sizes), 1, nx: true, ex: 1.minute)\n      Jobs.enqueue(:generate_topic_thumbnails, { topic_id: id, extra_sizes: extra_sizes })\n    end\n\n    infos.each { |i| i[:url] = UrlHelper.cook_url(i[:url], secure: original.secure?, local: true) }\n\n    infos.sort_by! { |i| -i[:width] * i[:height] }\n  end\n\n  def generate_thumbnails!(extra_sizes: [])\n    return nil unless SiteSetting.create_thumbnails\n    return nil unless original = image_upload\n    return nil if original.filesize >= SiteSetting.max_image_size_kb.kilobytes\n    return nil unless original.width && original.height\n    extra_sizes = [] unless extra_sizes.kind_of?(Array)\n\n    (Topic.thumbnail_sizes + extra_sizes).each do |dim|\n      TopicThumbnail.find_or_create_for!(original, max_width: dim[0], max_height: dim[1])\n    end\n  end\n\n  def image_url(enqueue_if_missing: false)\n    thumbnail =\n      topic_thumbnails.detect do |record|\n        record.max_width == Topic.share_thumbnail_size[0] &&\n          record.max_height == Topic.share_thumbnail_size[1]\n      end\n\n    if thumbnail.nil? && image_upload && SiteSetting.create_thumbnails &&\n         image_upload.filesize < SiteSetting.max_image_size_kb.kilobytes &&\n         image_upload.read_attribute(:width) && image_upload.read_attribute(:height) &&\n         enqueue_if_missing &&\n         Discourse.redis.set(thumbnail_job_redis_key([]), 1, nx: true, ex: 1.minute)\n      Jobs.enqueue(:generate_topic_thumbnails, { topic_id: id })\n    end\n\n    raw_url = thumbnail&.optimized_image&.url || image_upload&.url\n    UrlHelper.cook_url(raw_url, secure: image_upload&.secure?, local: true) if raw_url\n  end\n\n  def featured_users\n    @featured_users ||= TopicFeaturedUsers.new(self)\n  end\n\n  def trash!(trashed_by = nil)\n    trigger_event = false\n\n    if deleted_at.nil?\n      update_category_topic_count_by(-1) if visible?\n      CategoryTagStat.topic_deleted(self) if self.tags.present?\n      trigger_event = true\n    end\n\n    super(trashed_by)\n\n    DiscourseEvent.trigger(:topic_trashed, self) if trigger_event\n\n    self.topic_embed.trash! if has_topic_embed?\n  end\n\n  def recover!(recovered_by = nil)\n    trigger_event = false\n\n    unless deleted_at.nil?\n      update_category_topic_count_by(1) if visible?\n      CategoryTagStat.topic_recovered(self) if self.tags.present?\n      trigger_event = true\n    end\n\n    # Note parens are required because superclass doesn't take `recovered_by`\n    super()\n\n    DiscourseEvent.trigger(:topic_recovered, self) if trigger_event\n\n    unless (topic_embed = TopicEmbed.with_deleted.find_by_topic_id(id)).nil?\n      topic_embed.recover!\n    end\n  end\n\n  rate_limit :default_rate_limiter\n  rate_limit :limit_topics_per_day\n  rate_limit :limit_private_messages_per_day\n\n  validates :title,\n            if: Proc.new { |t| t.new_record? || t.title_changed? },\n            presence: true,\n            topic_title_length: true,\n            censored_words: true,\n            watched_words: true,\n            quality_title: {\n              unless: :private_message?,\n            },\n            max_emojis: true,\n            unique_among: {\n              unless:\n                Proc.new { |t| (SiteSetting.allow_duplicate_topic_titles? || t.private_message?) },\n              message: :has_already_been_used,\n              allow_blank: true,\n              case_sensitive: false,\n              collection:\n                Proc.new { |t|\n                  if SiteSetting.allow_duplicate_topic_titles_category?\n                    Topic.listable_topics.where(\"category_id = ?\", t.category_id)\n                  else\n                    Topic.listable_topics\n                  end\n                },\n            }\n\n  validates :category_id,\n            presence: true,\n            exclusion: {\n              in: Proc.new { [SiteSetting.uncategorized_category_id] },\n            },\n            if:\n              Proc.new { |t|\n                (t.new_record? || t.category_id_changed?) &&\n                  !SiteSetting.allow_uncategorized_topics && (t.archetype.nil? || t.regular?)\n              }\n\n  validates :featured_link, allow_nil: true, url: true\n  validate if: :featured_link do\n    if featured_link_changed? && !Guardian.new(user).can_edit_featured_link?(category_id)\n      errors.add(:featured_link)\n    end\n  end\n\n  validates :external_id,\n            allow_nil: true,\n            uniqueness: {\n              case_sensitive: false,\n            },\n            length: {\n              maximum: EXTERNAL_ID_MAX_LENGTH,\n            },\n            format: {\n              with: /\\A[\\w-]+\\z/,\n            }\n\n  before_validation do\n    self.title = TextCleaner.clean_title(TextSentinel.title_sentinel(title).text) if errors[\n      :title\n    ].empty?\n    self.featured_link = self.featured_link.strip.presence if self.featured_link\n  end\n\n  belongs_to :category\n  has_many :category_users, through: :category\n  has_many :posts\n\n  # NOTE: To get all Post _and_ Topic bookmarks for a topic by user,\n  # use the Bookmark.for_user_in_topic scope.\n  has_many :bookmarks, as: :bookmarkable\n\n  has_many :ordered_posts, -> { order(post_number: :asc) }, class_name: \"Post\"\n  has_many :topic_allowed_users\n  has_many :topic_allowed_groups\n  has_many :incoming_email\n\n  has_many :group_archived_messages, dependent: :destroy\n  has_many :user_archived_messages, dependent: :destroy\n\n  has_many :allowed_groups, through: :topic_allowed_groups, source: :group\n  has_many :allowed_group_users, through: :allowed_groups, source: :users\n  has_many :allowed_users, through: :topic_allowed_users, source: :user\n\n  has_many :topic_tags\n  has_many :tags, through: :topic_tags, dependent: :destroy # dependent destroy applies to the topic_tags records\n  has_many :tag_users, through: :tags\n\n  has_one :top_topic\n  has_one :shared_draft, dependent: :destroy\n  has_one :published_page\n\n  belongs_to :user\n  belongs_to :last_poster, class_name: \"User\", foreign_key: :last_post_user_id\n  belongs_to :featured_user1, class_name: \"User\", foreign_key: :featured_user1_id\n  belongs_to :featured_user2, class_name: \"User\", foreign_key: :featured_user2_id\n  belongs_to :featured_user3, class_name: \"User\", foreign_key: :featured_user3_id\n  belongs_to :featured_user4, class_name: \"User\", foreign_key: :featured_user4_id\n\n  has_many :topic_users\n  has_many :dismissed_topic_users\n  has_many :topic_links\n  has_many :topic_invites\n  has_many :invites, through: :topic_invites, source: :invite\n  has_many :topic_timers, dependent: :destroy\n  has_many :reviewables\n  has_many :user_profiles\n\n  has_one :user_warning\n  has_one :first_post, -> { where post_number: 1 }, class_name: \"Post\"\n  has_one :topic_search_data\n  has_one :topic_embed, dependent: :destroy\n  has_one :linked_topic, dependent: :destroy\n\n  belongs_to :image_upload, class_name: \"Upload\"\n  has_many :topic_thumbnails, through: :image_upload\n\n  # When we want to temporarily attach some data to a forum topic (usually before serialization)\n  attr_accessor :user_data\n  attr_accessor :category_user_data\n  attr_accessor :dismissed\n\n  attr_accessor :posters # TODO: can replace with posters_summary once we remove old list code\n  attr_accessor :participants\n  attr_accessor :participant_groups\n  attr_accessor :topic_list\n  attr_accessor :meta_data\n  attr_accessor :include_last_poster\n  attr_accessor :import_mode # set to true to optimize creation and save for imports\n\n  # The regular order\n  scope :topic_list_order, -> { order(\"topics.bumped_at desc\") }\n\n  # Return private message topics\n  scope :private_messages, -> { where(archetype: Archetype.private_message) }\n\n  PRIVATE_MESSAGES_SQL_USER = <<~SQL\n    SELECT topic_id\n    FROM topic_allowed_users\n    WHERE user_id = :user_id\n  SQL\n\n  PRIVATE_MESSAGES_SQL_GROUP = <<~SQL\n    SELECT tg.topic_id\n    FROM topic_allowed_groups tg\n    JOIN group_users gu ON gu.user_id = :user_id AND gu.group_id = tg.group_id\n  SQL\n\n  scope :private_messages_for_user,\n        ->(user) {\n          private_messages.where(\n            \"topics.id IN (#{PRIVATE_MESSAGES_SQL_USER})\n      OR topics.id IN (#{PRIVATE_MESSAGES_SQL_GROUP})\",\n            user_id: user.id,\n          )\n        }\n\n  scope :listable_topics, -> { where(\"topics.archetype <> ?\", Archetype.private_message) }\n\n  scope :by_newest, -> { order(\"topics.created_at desc, topics.id desc\") }\n\n  scope :visible, -> { where(visible: true) }\n\n  scope :created_since, lambda { |time_ago| where(\"topics.created_at > ?\", time_ago) }\n\n  scope :exclude_scheduled_bump_topics, -> { where.not(id: TopicTimer.scheduled_bump_topics) }\n\n  scope :secured,\n        lambda { |guardian = nil|\n          ids = guardian.secure_category_ids if guardian\n\n          # Query conditions\n          condition =\n            if ids.present?\n              [\"NOT read_restricted OR id IN (:cats)\", cats: ids]\n            else\n              [\"NOT read_restricted\"]\n            end\n\n          where(\n            \"topics.category_id IS NULL OR topics.category_id IN (SELECT id FROM categories WHERE #{condition[0]})\",\n            condition[1],\n          )\n        }\n\n  scope :in_category_and_subcategories,\n        lambda { |category_id|\n          if category_id\n            where(\"topics.category_id IN (?)\", Category.subcategory_ids(category_id.to_i))\n          end\n        }\n\n  scope :with_subtype, ->(subtype) { where(\"topics.subtype = ?\", subtype) }\n\n  attr_accessor :ignore_category_auto_close\n  attr_accessor :skip_callbacks\n  attr_accessor :advance_draft\n\n  before_create { initialize_default_values }\n\n  after_create do\n    unless skip_callbacks\n      changed_to_category(category)\n      advance_draft_sequence if advance_draft\n    end\n  end\n\n  before_save do\n    ensure_topic_has_a_category unless skip_callbacks\n\n    write_attribute(:fancy_title, Topic.fancy_title(title)) if title_changed?\n\n    if category_id_changed? || new_record?\n      inherit_auto_close_from_category\n      inherit_slow_mode_from_category\n    end\n  end\n\n  after_save do\n    banner = \"banner\"\n\n    if archetype_before_last_save == banner || archetype == banner\n      ApplicationController.banner_json_cache.clear\n    end\n\n    if tags_changed || saved_change_to_attribute?(:category_id) ||\n         saved_change_to_attribute?(:title)\n      SearchIndexer.queue_post_reindex(self.id)\n\n      if tags_changed\n        TagUser.auto_watch(topic_id: id)\n        TagUser.auto_track(topic_id: id)\n        self.tags_changed = false\n      end\n    end\n\n    SearchIndexer.index(self)\n  end\n\n  after_update do\n    if saved_changes[:category_id] && self.tags.present?\n      CategoryTagStat.topic_moved(self, *saved_changes[:category_id])\n    elsif saved_changes[:category_id] && self.category&.read_restricted?\n      UserProfile.remove_featured_topic_from_all_profiles(self)\n    end\n  end\n\n  def initialize_default_values\n    self.bumped_at ||= Time.now\n    self.last_post_user_id ||= user_id\n  end\n\n  def advance_draft_sequence\n    if self.private_message?\n      DraftSequence.next!(user, Draft::NEW_PRIVATE_MESSAGE)\n    else\n      DraftSequence.next!(user, Draft::NEW_TOPIC)\n    end\n  end\n\n  def ensure_topic_has_a_category\n    if category_id.nil? && (archetype.nil? || self.regular?)\n      self.category_id = category&.id || SiteSetting.uncategorized_category_id\n    end\n  end\n\n  def self.visible_post_types(viewed_by = nil, include_moderator_actions: true)\n    types = Post.types\n    result = [types[:regular]]\n    result += [types[:moderator_action], types[:small_action]] if include_moderator_actions\n    result << types[:whisper] if viewed_by&.whisperer?\n    result\n  end\n\n  def self.top_viewed(max = 10)\n    Topic.listable_topics.visible.secured.order(\"views desc\").limit(max)\n  end\n\n  def self.recent(max = 10)\n    Topic.listable_topics.visible.secured.order(\"created_at desc\").limit(max)\n  end\n\n  def self.count_exceeds_minimum?\n    count > SiteSetting.minimum_topics_similar\n  end\n\n  def best_post\n    posts\n      .where(post_type: Post.types[:regular], user_deleted: false)\n      .order(\"score desc nulls last\")\n      .limit(1)\n      .first\n  end\n\n  def self.has_flag_scope\n    ReviewableFlaggedPost.pending_and_default_visible\n  end\n\n  def has_flags?\n    self.class.has_flag_scope.exists?(topic_id: self.id)\n  end\n\n  def is_official_warning?\n    subtype == TopicSubtype.moderator_warning\n  end\n\n  # all users (in groups or directly targeted) that are going to get the pm\n  def all_allowed_users\n    moderators_sql = \" UNION #{User.moderators.to_sql}\" if private_message? &&\n      (has_flags? || is_official_warning?)\n    User.from(\n      \"(#{allowed_users.to_sql} UNION #{allowed_group_users.to_sql}#{moderators_sql}) as users\",\n    )\n  end\n\n  # Additional rate limits on topics: per day and private messages per day\n  def limit_topics_per_day\n    return unless regular?\n    if user && user.new_user_posting_on_first_day?\n      limit_first_day_topics_per_day\n    else\n      apply_per_day_rate_limit_for(\"topics\", :max_topics_per_day)\n    end\n  end\n\n  def limit_private_messages_per_day\n    return unless private_message?\n    apply_per_day_rate_limit_for(\"pms\", :max_personal_messages_per_day)\n  end\n\n  def self.fancy_title(title)\n    return unless escaped = ERB::Util.html_escape(title)\n    fancy_title = Emoji.unicode_unescape(HtmlPrettify.render(escaped))\n    fancy_title.length > Topic.max_fancy_title_length ? escaped : fancy_title\n  end\n\n  def fancy_title\n    return ERB::Util.html_escape(title) unless SiteSetting.title_fancy_entities?\n\n    unless fancy_title = read_attribute(:fancy_title)\n      fancy_title = Topic.fancy_title(title)\n      write_attribute(:fancy_title, fancy_title)\n\n      if !new_record? && !Discourse.readonly_mode?\n        # make sure data is set in table, this also allows us to change algorithm\n        # by simply nulling this column\n        DB.exec(\n          \"UPDATE topics SET fancy_title = :fancy_title where id = :id\",\n          id: self.id,\n          fancy_title: fancy_title,\n        )\n      end\n    end\n\n    fancy_title\n  end\n\n  # Returns hot topics since a date for display in email digest.\n  def self.for_digest(user, since, opts = nil)\n    opts = opts || {}\n    period = ListController.best_period_for(since)\n\n    topics =\n      Topic\n        .visible\n        .secured(Guardian.new(user))\n        .joins(\n          \"LEFT OUTER JOIN topic_users ON topic_users.topic_id = topics.id AND topic_users.user_id = #{user.id.to_i}\",\n        )\n        .joins(\n          \"LEFT OUTER JOIN category_users ON category_users.category_id = topics.category_id AND category_users.user_id = #{user.id.to_i}\",\n        )\n        .joins(\"LEFT OUTER JOIN users ON users.id = topics.user_id\")\n        .where(closed: false, archived: false)\n        .where(\n          \"COALESCE(topic_users.notification_level, 1) <> ?\",\n          TopicUser.notification_levels[:muted],\n        )\n        .created_since(since)\n        .where(\"topics.created_at < ?\", (SiteSetting.editing_grace_period || 0).seconds.ago)\n        .listable_topics\n        .includes(:category)\n\n    unless opts[:include_tl0] || user.user_option.try(:include_tl0_in_digests)\n      topics = topics.where(\"COALESCE(users.trust_level, 0) > 0\")\n    end\n\n    if !!opts[:top_order]\n      topics =\n        topics.joins(\"LEFT OUTER JOIN top_topics ON top_topics.topic_id = topics.id\").order(<<~SQL)\n          COALESCE(topic_users.notification_level, 1) DESC,\n          COALESCE(category_users.notification_level, 1) DESC,\n          COALESCE(top_topics.#{TopTopic.score_column_for_period(period)}, 0) DESC,\n          topics.bumped_at DESC\n      SQL\n    end\n\n    topics = topics.limit(opts[:limit]) if opts[:limit]\n\n    # Remove category topics\n    category_topic_ids = Category.pluck(:topic_id).compact!\n    topics = topics.where(\"topics.id NOT IN (?)\", category_topic_ids) if category_topic_ids.present?\n\n    # Remove muted and shared draft categories\n    remove_category_ids =\n      CategoryUser.where(\n        user_id: user.id,\n        notification_level: CategoryUser.notification_levels[:muted],\n      ).pluck(:category_id)\n    if SiteSetting.digest_suppress_categories.present?\n      topics =\n        topics.where(\n          \"topics.category_id NOT IN (?)\",\n          SiteSetting.digest_suppress_categories.split(\"|\").map(&:to_i),\n        )\n    end\n    remove_category_ids << SiteSetting.shared_drafts_category if SiteSetting.shared_drafts_enabled?\n    if remove_category_ids.present?\n      remove_category_ids.uniq!\n      topics =\n        topics.where(\n          \"topic_users.notification_level != ? OR topics.category_id NOT IN (?)\",\n          TopicUser.notification_levels[:muted],\n          remove_category_ids,\n        )\n    end\n\n    # Remove muted tags\n    muted_tag_ids = TagUser.lookup(user, :muted).pluck(:tag_id)\n    unless muted_tag_ids.empty?\n      # If multiple tags per topic, include topics with tags that aren't muted,\n      # and don't forget untagged topics.\n      topics =\n        topics.where(\n          \"EXISTS ( SELECT 1 FROM topic_tags WHERE topic_tags.topic_id = topics.id AND tag_id NOT IN (?) )\n        OR NOT EXISTS (SELECT 1 FROM topic_tags WHERE topic_tags.topic_id = topics.id)\",\n          muted_tag_ids,\n        )\n    end\n\n    topics\n  end\n\n  def meta_data=(data)\n    custom_fields.replace(data)\n  end\n\n  def meta_data\n    custom_fields\n  end\n\n  def update_meta_data(data)\n    custom_fields.update(data)\n    save\n  end\n\n  def reload(options = nil)\n    @post_numbers = nil\n    @public_topic_timer = nil\n    @slow_mode_topic_timer = nil\n    @is_category_topic = nil\n    super(options)\n  end\n\n  def post_numbers\n    @post_numbers ||= posts.order(:post_number).pluck(:post_number)\n  end\n\n  def age_in_minutes\n    ((Time.zone.now - created_at) / 1.minute).round\n  end\n\n  def self.listable_count_per_day(\n    start_date,\n    end_date,\n    category_id = nil,\n    include_subcategories = false\n  )\n    result =\n      listable_topics.where(\n        \"topics.created_at >= ? AND topics.created_at <= ?\",\n        start_date,\n        end_date,\n      )\n    result = result.group(\"date(topics.created_at)\").order(\"date(topics.created_at)\")\n    result =\n      result.where(\n        category_id: include_subcategories ? Category.subcategory_ids(category_id) : category_id,\n      ) if category_id\n    result.count\n  end\n\n  def private_message?\n    self.archetype == Archetype.private_message\n  end\n\n  def regular?\n    self.archetype == Archetype.default\n  end\n\n  def open?\n    !self.closed?\n  end\n\n  MAX_SIMILAR_BODY_LENGTH ||= 200\n\n  def self.similar_to(title, raw, user = nil)\n    return [] if title.blank?\n    raw = raw.presence || \"\"\n    search_data = Search.prepare_data(title.strip)\n\n    return [] if search_data.blank?\n\n    tsquery = Search.set_tsquery_weight_filter(search_data, \"A\")\n\n    if raw.present?\n      cooked =\n        SearchIndexer::HtmlScrubber.scrub(PrettyText.cook(raw[0...MAX_SIMILAR_BODY_LENGTH].strip))\n\n      prepared_data = cooked.present? && Search.prepare_data(cooked)\n\n      if prepared_data.present?\n        raw_tsquery = Search.set_tsquery_weight_filter(prepared_data, \"B\")\n\n        tsquery = \"#{tsquery} & #{raw_tsquery}\"\n      end\n    end\n\n    tsquery = Search.to_tsquery(term: tsquery, joiner: \"|\")\n\n    guardian = Guardian.new(user)\n\n    excluded_category_ids_sql =\n      Category\n        .secured(guardian)\n        .where(search_priority: Searchable::PRIORITIES[:ignore])\n        .select(:id)\n        .to_sql\n\n    excluded_category_ids_sql = <<~SQL if user\n      #{excluded_category_ids_sql}\n      UNION\n      #{CategoryUser.muted_category_ids_query(user, include_direct: true).select(\"categories.id\").to_sql}\n      SQL\n\n    candidates =\n      Topic\n        .visible\n        .listable_topics\n        .secured(guardian)\n        .joins(\"JOIN topic_search_data s ON topics.id = s.topic_id\")\n        .joins(\"LEFT JOIN categories c ON topics.id = c.topic_id\")\n        .where(\"search_data @@ #{tsquery}\")\n        .where(\"c.topic_id IS NULL\")\n        .where(\"topics.category_id NOT IN (#{excluded_category_ids_sql})\")\n        .order(\"ts_rank(search_data, #{tsquery}) DESC\")\n        .limit(SiteSetting.max_similar_results * 3)\n\n    candidate_ids = candidates.pluck(:id)\n\n    return [] if candidate_ids.blank?\n\n    similars =\n      Topic\n        .joins(\"JOIN posts AS p ON p.topic_id = topics.id AND p.post_number = 1\")\n        .where(\"topics.id IN (?)\", candidate_ids)\n        .order(\"similarity DESC\")\n        .limit(SiteSetting.max_similar_results)\n\n    if raw.present?\n      similars.select(\n        DB.sql_fragment(\n          \"topics.*, similarity(topics.title, :title) + similarity(p.raw, :raw) AS similarity, p.cooked AS blurb\",\n          title: title,\n          raw: raw,\n        ),\n      ).where(\n        \"similarity(topics.title, :title) + similarity(p.raw, :raw) > 0.2\",\n        title: title,\n        raw: raw,\n      )\n    else\n      similars.select(\n        DB.sql_fragment(\n          \"topics.*, similarity(topics.title, :title) AS similarity, p.cooked AS blurb\",\n          title: title,\n        ),\n      ).where(\"similarity(topics.title, :title) > 0.2\", title: title)\n    end\n  end\n\n  def update_status(status, enabled, user, opts = {})\n    TopicStatusUpdater.new(self, user).update!(status, enabled, opts)\n    DiscourseEvent.trigger(:topic_status_updated, self, status, enabled)\n\n    if status == \"closed\"\n      StaffActionLogger.new(user).log_topic_closed(self, closed: enabled)\n    elsif status == \"archived\"\n      StaffActionLogger.new(user).log_topic_archived(self, archived: enabled)\n    end\n\n    if enabled && private_message? && status.to_s[\"closed\"]\n      group_ids = user.groups.pluck(:id)\n      if group_ids.present?\n        allowed_group_ids =\n          self.allowed_groups.where(\"topic_allowed_groups.group_id IN (?)\", group_ids).pluck(:id)\n        allowed_group_ids.each { |id| GroupArchivedMessage.archive!(id, self) }\n      end\n    end\n  end\n\n  # Atomically creates the next post number\n  def self.next_post_number(topic_id, opts = {})\n    highest =\n      DB\n        .query_single(\n          \"SELECT coalesce(max(post_number),0) AS max FROM posts WHERE topic_id = ?\",\n          topic_id,\n        )\n        .first\n        .to_i\n\n    if opts[:whisper]\n      result = DB.query_single(<<~SQL, highest, topic_id)\n        UPDATE topics\n        SET highest_staff_post_number = ? + 1\n        WHERE id = ?\n        RETURNING highest_staff_post_number\n      SQL\n\n      result.first.to_i\n    else\n      reply_sql = opts[:reply] ? \", reply_count = reply_count + 1\" : \"\"\n      posts_sql = opts[:post] ? \", posts_count = posts_count + 1\" : \"\"\n\n      result = DB.query_single(<<~SQL, highest: highest, topic_id: topic_id)\n        UPDATE topics\n        SET highest_staff_post_number = :highest + 1,\n            highest_post_number = :highest + 1\n            #{reply_sql}\n            #{posts_sql}\n        WHERE id = :topic_id\n        RETURNING highest_post_number\n      SQL\n\n      result.first.to_i\n    end\n  end\n\n  def self.reset_all_highest!\n    DB.exec <<~SQL\n      WITH\n      X as (\n        SELECT topic_id,\n               COALESCE(MAX(post_number), 0) highest_post_number\n        FROM posts\n        WHERE deleted_at IS NULL\n        GROUP BY topic_id\n      ),\n      Y as (\n        SELECT topic_id,\n               coalesce(MAX(post_number), 0) highest_post_number,\n               count(*) posts_count,\n               max(created_at) last_posted_at\n        FROM posts\n        WHERE deleted_at IS NULL AND post_type <> 4\n        GROUP BY topic_id\n      )\n      UPDATE topics\n      SET\n        highest_staff_post_number = X.highest_post_number,\n        highest_post_number = Y.highest_post_number,\n        last_posted_at = Y.last_posted_at,\n        posts_count = Y.posts_count\n      FROM X, Y\n      WHERE\n        topics.archetype <> 'private_message' AND\n        X.topic_id = topics.id AND\n        Y.topic_id = topics.id AND (\n          topics.highest_staff_post_number <> X.highest_post_number OR\n          topics.highest_post_number <> Y.highest_post_number OR\n          topics.last_posted_at <> Y.last_posted_at OR\n          topics.posts_count <> Y.posts_count\n        )\n    SQL\n\n    DB.exec <<~SQL\n      WITH\n      X as (\n        SELECT topic_id,\n               COALESCE(MAX(post_number), 0) highest_post_number\n        FROM posts\n        WHERE deleted_at IS NULL\n        GROUP BY topic_id\n      ),\n      Y as (\n        SELECT topic_id,\n               coalesce(MAX(post_number), 0) highest_post_number,\n               count(*) posts_count,\n               max(created_at) last_posted_at\n        FROM posts\n        WHERE deleted_at IS NULL AND post_type <> 3 AND post_type <> 4\n        GROUP BY topic_id\n      )\n      UPDATE topics\n      SET\n        highest_staff_post_number = X.highest_post_number,\n        highest_post_number = Y.highest_post_number,\n        last_posted_at = Y.last_posted_at,\n        posts_count = Y.posts_count\n      FROM X, Y\n      WHERE\n        topics.archetype = 'private_message' AND\n        X.topic_id = topics.id AND\n        Y.topic_id = topics.id AND (\n          topics.highest_staff_post_number <> X.highest_post_number OR\n          topics.highest_post_number <> Y.highest_post_number OR\n          topics.last_posted_at <> Y.last_posted_at OR\n          topics.posts_count <> Y.posts_count\n        )\n    SQL\n  end\n\n  # If a post is deleted we have to update our highest post counters and last post information\n  def self.reset_highest(topic_id)\n    archetype = Topic.where(id: topic_id).pick(:archetype)\n\n    # ignore small_action replies for private messages\n    post_type =\n      archetype == Archetype.private_message ? \" AND post_type <> #{Post.types[:small_action]}\" : \"\"\n\n    result = DB.query_single(<<~SQL, topic_id: topic_id)\n      UPDATE topics\n      SET\n        highest_staff_post_number = (\n          SELECT COALESCE(MAX(post_number), 0) FROM posts\n          WHERE topic_id = :topic_id AND\n                deleted_at IS NULL\n        ),\n        highest_post_number = (\n          SELECT COALESCE(MAX(post_number), 0) FROM posts\n          WHERE topic_id = :topic_id AND\n                deleted_at IS NULL AND\n                post_type <> 4\n                #{post_type}\n        ),\n        posts_count = (\n          SELECT count(*) FROM posts\n          WHERE deleted_at IS NULL AND\n                topic_id = :topic_id AND\n                post_type <> 4\n                #{post_type}\n        ),\n        last_posted_at = (\n          SELECT MAX(created_at) FROM posts\n          WHERE topic_id = :topic_id AND\n                deleted_at IS NULL AND\n                post_type <> 4\n                #{post_type}\n        ),\n        last_post_user_id = COALESCE((\n          SELECT user_id FROM posts\n          WHERE topic_id = :topic_id AND\n                deleted_at IS NULL AND\n                post_type <> 4\n                #{post_type}\n          ORDER BY created_at desc\n          LIMIT 1\n        ), last_post_user_id)\n      WHERE id = :topic_id\n      RETURNING highest_post_number\n    SQL\n\n    highest_post_number = result.first.to_i\n\n    # Update the forum topic user records\n    DB.exec(<<~SQL, highest: highest_post_number, topic_id: topic_id)\n      UPDATE topic_users\n      SET last_read_post_number = CASE\n                                  WHEN last_read_post_number > :highest THEN :highest\n                                  ELSE last_read_post_number\n                                  END\n      WHERE topic_id = :topic_id\n    SQL\n  end\n\n  cattr_accessor :update_featured_topics\n\n  def changed_to_category(new_category)\n    return true if new_category.blank? || Category.exists?(topic_id: id)\n\n    if new_category.id == SiteSetting.uncategorized_category_id &&\n         !SiteSetting.allow_uncategorized_topics\n      return false\n    end\n\n    Topic.transaction do\n      old_category = category\n\n      if self.category_id != new_category.id\n        self.update(category_id: new_category.id)\n\n        if old_category\n          Category.where(id: old_category.id).update_all(\"topic_count = topic_count - 1\")\n\n          count =\n            if old_category.read_restricted && !new_category.read_restricted\n              1\n            elsif !old_category.read_restricted && new_category.read_restricted\n              -1\n            end\n\n          Tag.update_counters(self.tags, { public_topic_count: count }) if count\n        end\n\n        # when a topic changes category we may have to start watching it\n        # if we happen to have read state for it\n        CategoryUser.auto_watch(category_id: new_category.id, topic_id: self.id)\n        CategoryUser.auto_track(category_id: new_category.id, topic_id: self.id)\n\n        if !SiteSetting.disable_category_edit_notifications && (post = self.ordered_posts.first)\n          notified_user_ids = [post.user_id, post.last_editor_id].uniq\n          DB.after_commit do\n            Jobs.enqueue(\n              :notify_category_change,\n              post_id: post.id,\n              notified_user_ids: notified_user_ids,\n            )\n          end\n        end\n\n        # when a topic changes category we may need to make uploads\n        # linked to posts secure/not secure depending on whether the\n        # category is private. this is only done if the category\n        # has actually changed to avoid noise.\n        DB.after_commit { Jobs.enqueue(:update_topic_upload_security, topic_id: self.id) }\n      end\n\n      Category.where(id: new_category.id).update_all(\"topic_count = topic_count + 1\")\n\n      if Topic.update_featured_topics != false\n        CategoryFeaturedTopic.feature_topics_for(old_category) unless @import_mode\n        unless @import_mode || old_category.try(:id) == new_category.id\n          CategoryFeaturedTopic.feature_topics_for(new_category)\n        end\n      end\n    end\n\n    true\n  end\n\n  def add_small_action(user, action_code, who = nil, opts = {})\n    custom_fields = {}\n    custom_fields[\"action_code_who\"] = who if who.present?\n    opts =\n      opts.merge(\n        post_type: Post.types[:small_action],\n        action_code: action_code,\n        custom_fields: custom_fields,\n      )\n\n    add_moderator_post(user, nil, opts)\n  end\n\n  def add_moderator_post(user, text, opts = nil)\n    opts ||= {}\n    new_post = nil\n    creator =\n      PostCreator.new(\n        user,\n        raw: text,\n        post_type: opts[:post_type] || Post.types[:moderator_action],\n        action_code: opts[:action_code],\n        no_bump: opts[:bump].blank?,\n        topic_id: self.id,\n        silent: opts[:silent],\n        skip_validations: true,\n        custom_fields: opts[:custom_fields],\n        import_mode: opts[:import_mode],\n      )\n\n    if (new_post = creator.create) && new_post.present?\n      increment!(:moderator_posts_count) if new_post.persisted?\n      # If we are moving posts, we want to insert the moderator post where the previous posts were\n      # in the stream, not at the end.\n      if opts[:post_number].present?\n        new_post.update!(post_number: opts[:post_number], sort_order: opts[:post_number])\n      end\n\n      # Grab any links that are present\n      TopicLink.extract_from(new_post)\n      QuotedPost.extract_from(new_post)\n    end\n\n    new_post\n  end\n\n  def change_category_to_id(category_id)\n    return false if private_message?\n\n    new_category_id = category_id.to_i\n    # if the category name is blank, reset the attribute\n    new_category_id = SiteSetting.uncategorized_category_id if new_category_id == 0\n\n    return true if self.category_id == new_category_id\n\n    cat = Category.find_by(id: new_category_id)\n    return false unless cat\n\n    reviewables.update_all(category_id: new_category_id)\n\n    changed_to_category(cat)\n  end\n\n  def remove_allowed_group(removed_by, name)\n    if group = Group.find_by(name: name)\n      group_user = topic_allowed_groups.find_by(group_id: group.id)\n      if group_user\n        group_user.destroy\n        allowed_groups.reload\n        add_small_action(removed_by, \"removed_group\", group.name)\n        return true\n      end\n    end\n\n    false\n  end\n\n  def remove_allowed_user(removed_by, username)\n    user = username.is_a?(User) ? username : User.find_by(username: username)\n\n    if user\n      topic_user = topic_allowed_users.find_by(user_id: user.id)\n\n      if topic_user\n        if user.id == removed_by&.id\n          add_small_action(removed_by, \"user_left\", user.username)\n        else\n          add_small_action(removed_by, \"removed_user\", user.username)\n        end\n\n        topic_user.destroy\n        return true\n      end\n    end\n\n    false\n  end\n\n  def reached_recipients_limit?\n    return false unless private_message?\n    topic_allowed_users.count + topic_allowed_groups.count >=\n      SiteSetting.max_allowed_message_recipients\n  end\n\n  def invite_group(user, group)\n    TopicAllowedGroup.create!(topic_id: self.id, group_id: group.id)\n    self.allowed_groups.reload\n\n    last_post =\n      self.posts.order(\"post_number desc\").where(\"not hidden AND posts.deleted_at IS NULL\").first\n    if last_post\n      Jobs.enqueue(:post_alert, post_id: last_post.id)\n      add_small_action(user, \"invited_group\", group.name)\n      Jobs.enqueue(:group_pm_alert, user_id: user.id, group_id: group.id, post_id: last_post.id)\n    end\n\n    # If the group invited includes the OP of the topic as one of is members,\n    # we cannot strip the topic_allowed_user record since it will be more\n    # complicated to recover the topic_allowed_user record for the OP if the\n    # group is removed.\n    allowed_user_where_clause = <<~SQL\n      users.id IN (\n        SELECT topic_allowed_users.user_id\n        FROM topic_allowed_users\n        INNER JOIN group_users ON group_users.user_id = topic_allowed_users.user_id\n        INNER JOIN topic_allowed_groups ON topic_allowed_groups.group_id = group_users.group_id\n        WHERE topic_allowed_groups.group_id = :group_id AND\n              topic_allowed_users.topic_id = :topic_id AND\n              topic_allowed_users.user_id != :op_user_id\n      )\n    SQL\n    User\n      .where(\n        [\n          allowed_user_where_clause,\n          { group_id: group.id, topic_id: self.id, op_user_id: self.user_id },\n        ],\n      )\n      .find_each { |allowed_user| remove_allowed_user(Discourse.system_user, allowed_user) }\n\n    true\n  end\n\n  def invite(invited_by, username_or_email, group_ids = nil, custom_message = nil)\n    guardian = Guardian.new(invited_by)\n\n    if target_user = User.find_by_username_or_email(username_or_email)\n      if topic_allowed_users.exists?(user_id: target_user.id)\n        raise UserExists.new(I18n.t(\"topic_invite.user_exists\"))\n      end\n\n      comm_screener = UserCommScreener.new(acting_user: invited_by, target_user_ids: target_user.id)\n      if comm_screener.ignoring_or_muting_actor?(target_user.id)\n        raise NotAllowed.new(I18n.t(\"not_accepting_pms\", username: target_user.username))\n      end\n\n      if TopicUser.where(\n           topic: self,\n           user: target_user,\n           notification_level: TopicUser.notification_levels[:muted],\n         ).exists?\n        raise NotAllowed.new(I18n.t(\"topic_invite.muted_topic\"))\n      end\n\n      if comm_screener.disallowing_pms_from_actor?(target_user.id)\n        raise NotAllowed.new(I18n.t(\"topic_invite.receiver_does_not_allow_pm\"))\n      end\n\n      if UserCommScreener.new(\n           acting_user: target_user,\n           target_user_ids: invited_by.id,\n         ).disallowing_pms_from_actor?(invited_by.id)\n        raise NotAllowed.new(I18n.t(\"topic_invite.sender_does_not_allow_pm\"))\n      end\n\n      if private_message?\n        !!invite_to_private_message(invited_by, target_user, guardian)\n      else\n        !!invite_to_topic(invited_by, target_user, group_ids, guardian)\n      end\n    elsif username_or_email =~ /\\A.+@.+\\z/ && guardian.can_invite_via_email?(self)\n      !!Invite.generate(\n        invited_by,\n        email: username_or_email,\n        topic: self,\n        group_ids: group_ids,\n        custom_message: custom_message,\n        invite_to_topic: true,\n      )\n    end\n  end\n\n  def email_already_exists_for?(invite)\n    invite.email_already_exists && private_message?\n  end\n\n  def grant_permission_to_user(lower_email)\n    user = User.find_by_email(lower_email)\n    unless topic_allowed_users.exists?(user_id: user.id)\n      topic_allowed_users.create!(user_id: user.id)\n    end\n  end\n\n  def max_post_number\n    posts.with_deleted.maximum(:post_number).to_i\n  end\n\n  def move_posts(moved_by, post_ids, opts)\n    post_mover =\n      PostMover.new(\n        self,\n        moved_by,\n        post_ids,\n        move_to_pm: opts[:archetype].present? && opts[:archetype] == \"private_message\",\n      )\n\n    if opts[:destination_topic_id]\n      topic =\n        post_mover.to_topic(\n          opts[:destination_topic_id],\n          **opts.slice(:participants, :chronological_order),\n        )\n\n      DiscourseEvent.trigger(:topic_merged, post_mover.original_topic, post_mover.destination_topic)\n\n      topic\n    elsif opts[:title]\n      post_mover.to_new_topic(opts[:title], opts[:category_id], opts[:tags])\n    end\n  end\n\n  # Updates the denormalized statistics of a topic including featured posters. They shouldn't\n  # go out of sync unless you do something drastic live move posts from one topic to another.\n  # this recalculates everything.\n  def update_statistics\n    feature_topic_users\n    update_action_counts\n    Topic.reset_highest(id)\n  end\n\n  def update_action_counts\n    update_column(\n      :like_count,\n      Post.where.not(post_type: Post.types[:whisper]).where(topic_id: id).sum(:like_count),\n    )\n  end\n\n  def posters_summary(options = {}) # avatar lookup in options\n    @posters_summary ||= TopicPostersSummary.new(self, options).summary\n  end\n\n  def participants_summary(options = {})\n    @participants_summary ||= TopicParticipantsSummary.new(self, options).summary\n  end\n\n  def participant_groups_summary(options = {})\n    @participant_groups_summary ||= TopicParticipantGroupsSummary.new(self, options).summary\n  end\n\n  def make_banner!(user, bannered_until = nil)\n    if bannered_until\n      bannered_until =\n        begin\n          Time.parse(bannered_until)\n        rescue ArgumentError\n          raise Discourse::InvalidParameters.new(:bannered_until)\n        end\n    end\n\n    # only one banner at the same time\n    previous_banner = Topic.where(archetype: Archetype.banner).first\n    previous_banner.remove_banner!(user) if previous_banner.present?\n\n    UserProfile.where(\"dismissed_banner_key IS NOT NULL\").update_all(dismissed_banner_key: nil)\n\n    self.archetype = Archetype.banner\n    self.bannered_until = bannered_until\n    self.add_small_action(user, \"banner.enabled\")\n    self.save\n\n    MessageBus.publish(\"/site/banner\", banner)\n\n    Jobs.cancel_scheduled_job(:remove_banner, topic_id: self.id)\n    Jobs.enqueue_at(bannered_until, :remove_banner, topic_id: self.id) if bannered_until\n  end\n\n  def remove_banner!(user)\n    self.archetype = Archetype.default\n    self.bannered_until = nil\n    self.add_small_action(user, \"banner.disabled\")\n    self.save\n\n    MessageBus.publish(\"/site/banner\", nil)\n\n    Jobs.cancel_scheduled_job(:remove_banner, topic_id: self.id)\n  end\n\n  def banner\n    post = self.ordered_posts.first\n\n    { html: post.cooked, key: self.id, url: self.url }\n  end\n\n  cattr_accessor :slug_computed_callbacks\n  self.slug_computed_callbacks = []\n\n  def slug_for_topic(title)\n    return \"\" unless title.present?\n    slug = Slug.for(title)\n\n    # this is a hook for plugins that need to modify the generated slug\n    self.class.slug_computed_callbacks.each { |callback| slug = callback.call(self, slug, title) }\n\n    slug\n  end\n\n  # Even if the slug column in the database is null, topic.slug will return something:\n  def slug\n    unless slug = read_attribute(:slug)\n      return \"\" unless title.present?\n      slug = slug_for_topic(title)\n      if new_record?\n        write_attribute(:slug, slug)\n      else\n        update_column(:slug, slug)\n      end\n    end\n\n    slug\n  end\n\n  def self.find_by_slug(slug)\n    if SiteSetting.slug_generation_method != \"encoded\"\n      Topic.find_by(slug: slug.downcase)\n    else\n      encoded_slug = CGI.escape(slug)\n      Topic.find_by(slug: encoded_slug)\n    end\n  end\n\n  def title=(t)\n    slug = slug_for_topic(t.to_s)\n    write_attribute(:slug, slug)\n    write_attribute(:fancy_title, nil)\n    write_attribute(:title, t)\n  end\n\n  # NOTE: These are probably better off somewhere else.\n  #       Having a model know about URLs seems a bit strange.\n  def last_post_url\n    \"#{Discourse.base_path}/t/#{slug}/#{id}/#{posts_count}\"\n  end\n\n  def self.url(id, slug, post_number = nil)\n    url = +\"#{Discourse.base_url}/t/#{slug}/#{id}\"\n    url << \"/#{post_number}\" if post_number.to_i > 1\n    url\n  end\n\n  def url(post_number = nil)\n    self.class.url id, slug, post_number\n  end\n\n  def self.relative_url(id, slug, post_number = nil)\n    url = +\"#{Discourse.base_path}/t/\"\n    url << \"#{slug}/\" if slug.present?\n    url << id.to_s\n    url << \"/#{post_number}\" if post_number.to_i > 1\n    url\n  end\n\n  def slugless_url(post_number = nil)\n    Topic.relative_url(id, nil, post_number)\n  end\n\n  def relative_url(post_number = nil)\n    Topic.relative_url(id, slug, post_number)\n  end\n\n  def clear_pin_for(user)\n    return unless user.present?\n    TopicUser.change(user.id, id, cleared_pinned_at: Time.now)\n  end\n\n  def re_pin_for(user)\n    return unless user.present?\n    TopicUser.change(user.id, id, cleared_pinned_at: nil)\n  end\n\n  def update_pinned(status, global = false, pinned_until = nil)\n    if pinned_until\n      pinned_until =\n        begin\n          Time.parse(pinned_until)\n        rescue ArgumentError\n          raise Discourse::InvalidParameters.new(:pinned_until)\n        end\n    end\n\n    update_columns(\n      pinned_at: status ? Time.zone.now : nil,\n      pinned_globally: global,\n      pinned_until: pinned_until,\n    )\n\n    Jobs.cancel_scheduled_job(:unpin_topic, topic_id: self.id)\n    Jobs.enqueue_at(pinned_until, :unpin_topic, topic_id: self.id) if pinned_until\n  end\n\n  def draft_key\n    \"#{Draft::EXISTING_TOPIC}#{id}\"\n  end\n\n  def notifier\n    @topic_notifier ||= TopicNotifier.new(self)\n  end\n\n  def muted?(user)\n    notifier.muted?(user.id) if user && user.id\n  end\n\n  def self.ensure_consistency!\n    # unpin topics that might have been missed\n    Topic.where(\"pinned_until < ?\", Time.now).update_all(\n      pinned_at: nil,\n      pinned_globally: false,\n      pinned_until: nil,\n    )\n    Topic\n      .where(\"bannered_until < ?\", Time.now)\n      .find_each { |topic| topic.remove_banner!(Discourse.system_user) }\n  end\n\n  def inherit_slow_mode_from_category\n    if self.category&.default_slow_mode_seconds\n      self.slow_mode_seconds = self.category&.default_slow_mode_seconds\n    end\n  end\n\n  def inherit_auto_close_from_category(timer_type: :close)\n    auto_close_hours = self.category&.auto_close_hours\n\n    if self.open? && !@ignore_category_auto_close && auto_close_hours.present? &&\n         public_topic_timer&.execute_at.blank?\n      based_on_last_post = self.category.auto_close_based_on_last_post\n      duration_minutes = based_on_last_post ? auto_close_hours * 60 : nil\n\n      # the timer time can be a timestamp or an integer based\n      # on the number of hours\n      auto_close_time = auto_close_hours\n\n      if !based_on_last_post\n        # set auto close to the original time it should have been\n        # when the topic was first created.\n        start_time = self.created_at || Time.zone.now\n        auto_close_time = start_time + auto_close_hours.hours\n\n        # if we have already passed the original close time then\n        # we should not recreate the auto-close timer for the topic\n        return if auto_close_time < Time.zone.now\n\n        # timestamp must be a string for set_or_create_timer\n        auto_close_time = auto_close_time.to_s\n      end\n\n      self.set_or_create_timer(\n        TopicTimer.types[timer_type],\n        auto_close_time,\n        by_user: Discourse.system_user,\n        based_on_last_post: based_on_last_post,\n        duration_minutes: duration_minutes,\n      )\n    end\n  end\n\n  def public_topic_timer\n    @public_topic_timer ||= topic_timers.find_by(public_type: true)\n  end\n\n  def slow_mode_topic_timer\n    @slow_mode_topic_timer ||= topic_timers.find_by(status_type: TopicTimer.types[:clear_slow_mode])\n  end\n\n  def delete_topic_timer(status_type, by_user: Discourse.system_user)\n    options = { status_type: status_type }\n    options.merge!(user: by_user) unless TopicTimer.public_types[status_type]\n    self.topic_timers.find_by(options)&.trash!(by_user)\n    @public_topic_timer = nil\n    nil\n  end\n\n  # Valid arguments for the time:\n  #  * An integer, which is the number of hours from now to update the topic's status.\n  #  * A timestamp, like \"2013-11-25 13:00\", when the topic's status should update.\n  #  * A timestamp with timezone in JSON format. (e.g., \"2013-11-26T21:00:00.000Z\")\n  #  * `nil` to delete the topic's status update.\n  # Options:\n  #  * by_user: User who is setting the topic's status update.\n  #  * based_on_last_post: True if time should be based on timestamp of the last post.\n  #  * category_id: Category that the update will apply to.\n  #  * duration_minutes: The duration of the timer in minutes, which is used if the timer is based\n  #                      on the last post or if the timer type is delete_replies.\n  #  * silent: Affects whether the close topic timer status change will be silent or not.\n  def set_or_create_timer(\n    status_type,\n    time,\n    by_user: nil,\n    based_on_last_post: false,\n    category_id: SiteSetting.uncategorized_category_id,\n    duration_minutes: nil,\n    silent: nil\n  )\n    if time.blank? && duration_minutes.blank?\n      return delete_topic_timer(status_type, by_user: by_user)\n    end\n\n    duration_minutes = duration_minutes ? duration_minutes.to_i : 0\n    public_topic_timer = !!TopicTimer.public_types[status_type]\n    topic_timer_options = { topic: self, public_type: public_topic_timer }\n    topic_timer_options.merge!(user: by_user) unless public_topic_timer\n    topic_timer_options.merge!(silent: silent) if silent\n    topic_timer = TopicTimer.find_or_initialize_by(topic_timer_options)\n    topic_timer.status_type = status_type\n\n    time_now = Time.zone.now\n    topic_timer.based_on_last_post = !based_on_last_post.blank?\n\n    if status_type == TopicTimer.types[:publish_to_category]\n      topic_timer.category = Category.find_by(id: category_id)\n    end\n\n    if topic_timer.based_on_last_post\n      if duration_minutes > 0\n        last_post_created_at =\n          self.ordered_posts.last.present? ? self.ordered_posts.last.created_at : time_now\n        topic_timer.duration_minutes = duration_minutes\n        topic_timer.execute_at = last_post_created_at + duration_minutes.minutes\n        topic_timer.created_at = last_post_created_at\n      end\n    elsif topic_timer.status_type == TopicTimer.types[:delete_replies]\n      if duration_minutes > 0\n        first_reply_created_at =\n          (self.ordered_posts.where(\"post_number > 1\").minimum(:created_at) || time_now)\n        topic_timer.duration_minutes = duration_minutes\n        topic_timer.execute_at = first_reply_created_at + duration_minutes.minutes\n        topic_timer.created_at = first_reply_created_at\n      end\n    else\n      utc = Time.find_zone(\"UTC\")\n      is_float =\n        (\n          begin\n            Float(time)\n          rescue StandardError\n            nil\n          end\n        )\n\n      if is_float\n        num_hours = time.to_f\n        topic_timer.execute_at = num_hours.hours.from_now if num_hours > 0\n      else\n        timestamp = utc.parse(time)\n        raise Discourse::InvalidParameters unless timestamp && timestamp > utc.now\n        # a timestamp in client's time zone, like \"2015-5-27 12:00\"\n        topic_timer.execute_at = timestamp\n      end\n    end\n\n    if topic_timer.execute_at\n      if by_user&.staff? || by_user&.trust_level == TrustLevel[4]\n        topic_timer.user = by_user\n      else\n        topic_timer.user ||=\n          (\n            if self.user.staff? || self.user.trust_level == TrustLevel[4]\n              self.user\n            else\n              Discourse.system_user\n            end\n          )\n      end\n\n      if self.persisted?\n        # See TopicTimer.after_save for additional context; the topic\n        # status may be changed by saving.\n        topic_timer.save!\n      else\n        self.topic_timers << topic_timer\n      end\n\n      topic_timer\n    end\n  end\n\n  def read_restricted_category?\n    category && category.read_restricted\n  end\n\n  def category_allows_unlimited_owner_edits_on_first_post?\n    category && category.allow_unlimited_owner_edits_on_first_post?\n  end\n\n  def acting_user\n    @acting_user || user\n  end\n\n  def acting_user=(u)\n    @acting_user = u\n  end\n\n  def secure_group_ids\n    @secure_group_ids ||=\n      (self.category.secure_group_ids if self.category && self.category.read_restricted?)\n  end\n\n  def has_topic_embed?\n    TopicEmbed.where(topic_id: id).exists?\n  end\n\n  def expandable_first_post?\n    SiteSetting.embed_truncate? && has_topic_embed?\n  end\n\n  def message_archived?(user)\n    return false unless user && user.id\n\n    # tricky query but this checks to see if message is archived for ALL groups you belong to\n    # OR if you have it archived as a user explicitly\n\n    sql = <<~SQL\n      SELECT 1\n      WHERE\n        (\n        SELECT count(*) FROM topic_allowed_groups tg\n        JOIN group_archived_messages gm\n              ON gm.topic_id = tg.topic_id AND\n                 gm.group_id = tg.group_id\n          WHERE tg.group_id IN (SELECT g.group_id FROM group_users g WHERE g.user_id = :user_id)\n            AND tg.topic_id = :topic_id\n        ) =\n        (\n          SELECT case when count(*) = 0 then -1 else count(*) end FROM topic_allowed_groups tg\n          WHERE tg.group_id IN (SELECT g.group_id FROM group_users g WHERE g.user_id = :user_id)\n            AND tg.topic_id = :topic_id\n        )\n\n        UNION ALL\n\n        SELECT 1 FROM topic_allowed_users tu\n        JOIN user_archived_messages um ON um.user_id = tu.user_id AND um.topic_id = tu.topic_id\n        WHERE tu.user_id = :user_id AND tu.topic_id = :topic_id\n    SQL\n\n    DB.exec(sql, user_id: user.id, topic_id: id) > 0\n  end\n\n  TIME_TO_FIRST_RESPONSE_SQL ||= <<-SQL\n    SELECT AVG(t.hours)::float AS \"hours\", t.created_at AS \"date\"\n    FROM (\n      SELECT t.id, t.created_at::date AS created_at, EXTRACT(EPOCH FROM MIN(p.created_at) - t.created_at)::float / 3600.0 AS \"hours\"\n      FROM topics t\n      LEFT JOIN posts p ON p.topic_id = t.id\n      /*where*/\n      GROUP BY t.id\n    ) t\n    GROUP BY t.created_at\n    ORDER BY t.created_at\n  SQL\n\n  TIME_TO_FIRST_RESPONSE_TOTAL_SQL ||= <<-SQL\n    SELECT AVG(t.hours)::float AS \"hours\"\n    FROM (\n      SELECT t.id, EXTRACT(EPOCH FROM MIN(p.created_at) - t.created_at)::float / 3600.0 AS \"hours\"\n      FROM topics t\n      LEFT JOIN posts p ON p.topic_id = t.id\n      /*where*/\n      GROUP BY t.id\n    ) t\n  SQL\n\n  def self.time_to_first_response(sql, opts = nil)\n    opts ||= {}\n    builder = DB.build(sql)\n    builder.where(\"t.created_at >= :start_date\", start_date: opts[:start_date]) if opts[:start_date]\n    builder.where(\"t.created_at < :end_date\", end_date: opts[:end_date]) if opts[:end_date]\n    if opts[:category_id]\n      if opts[:include_subcategories]\n        builder.where(\"t.category_id IN (?)\", Category.subcategory_ids(opts[:category_id]))\n      else\n        builder.where(\"t.category_id = ?\", opts[:category_id])\n      end\n    end\n    builder.where(\"t.archetype <> '#{Archetype.private_message}'\")\n    builder.where(\"t.deleted_at IS NULL\")\n    builder.where(\"p.deleted_at IS NULL\")\n    builder.where(\"p.post_number > 1\")\n    builder.where(\"p.user_id != t.user_id\")\n    builder.where(\"p.user_id in (:user_ids)\", user_ids: opts[:user_ids]) if opts[:user_ids]\n    builder.where(\"p.post_type = :post_type\", post_type: Post.types[:regular])\n    builder.where(\"EXTRACT(EPOCH FROM p.created_at - t.created_at) > 0\")\n    builder.query_hash\n  end\n\n  def self.time_to_first_response_per_day(start_date, end_date, opts = {})\n    time_to_first_response(\n      TIME_TO_FIRST_RESPONSE_SQL,\n      opts.merge(start_date: start_date, end_date: end_date),\n    )\n  end\n\n  def self.time_to_first_response_total(opts = nil)\n    total = time_to_first_response(TIME_TO_FIRST_RESPONSE_TOTAL_SQL, opts)\n    total.first[\"hours\"].to_f.round(2)\n  end\n\n  WITH_NO_RESPONSE_SQL ||= <<-SQL\n    SELECT COUNT(*) as count, tt.created_at AS \"date\"\n    FROM (\n      SELECT t.id, t.created_at::date AS created_at, MIN(p.post_number) first_reply\n      FROM topics t\n      LEFT JOIN posts p ON p.topic_id = t.id AND p.user_id != t.user_id AND p.deleted_at IS NULL AND p.post_type = #{Post.types[:regular]}\n      /*where*/\n      GROUP BY t.id\n    ) tt\n    WHERE tt.first_reply IS NULL OR tt.first_reply < 2\n    GROUP BY tt.created_at\n    ORDER BY tt.created_at\n  SQL\n\n  def self.with_no_response_per_day(\n    start_date,\n    end_date,\n    category_id = nil,\n    include_subcategories = nil\n  )\n    builder = DB.build(WITH_NO_RESPONSE_SQL)\n    builder.where(\"t.created_at >= :start_date\", start_date: start_date) if start_date\n    builder.where(\"t.created_at < :end_date\", end_date: end_date) if end_date\n    if category_id\n      if include_subcategories\n        builder.where(\"t.category_id IN (?)\", Category.subcategory_ids(category_id))\n      else\n        builder.where(\"t.category_id = ?\", category_id)\n      end\n    end\n    builder.where(\"t.archetype <> '#{Archetype.private_message}'\")\n    builder.where(\"t.deleted_at IS NULL\")\n    builder.query_hash\n  end\n\n  WITH_NO_RESPONSE_TOTAL_SQL ||= <<-SQL\n    SELECT COUNT(*) as count\n    FROM (\n      SELECT t.id, MIN(p.post_number) first_reply\n      FROM topics t\n      LEFT JOIN posts p ON p.topic_id = t.id AND p.user_id != t.user_id AND p.deleted_at IS NULL AND p.post_type = #{Post.types[:regular]}\n      /*where*/\n      GROUP BY t.id\n    ) tt\n    WHERE tt.first_reply IS NULL OR tt.first_reply < 2\n  SQL\n\n  def self.with_no_response_total(opts = {})\n    builder = DB.build(WITH_NO_RESPONSE_TOTAL_SQL)\n    if opts[:category_id]\n      if opts[:include_subcategories]\n        builder.where(\"t.category_id IN (?)\", Category.subcategory_ids(opts[:category_id]))\n      else\n        builder.where(\"t.category_id = ?\", opts[:category_id])\n      end\n    end\n    builder.where(\"t.archetype <> '#{Archetype.private_message}'\")\n    builder.where(\"t.deleted_at IS NULL\")\n    builder.query_single.first.to_i\n  end\n\n  def convert_to_public_topic(user, category_id: nil)\n    public_topic = TopicConverter.new(self, user).convert_to_public_topic(category_id)\n    Tag.update_counters(public_topic.tags, { public_topic_count: 1 }) if !category.read_restricted\n    add_small_action(user, \"public_topic\") if public_topic\n    public_topic\n  end\n\n  def convert_to_private_message(user)\n    read_restricted = category.read_restricted\n    private_topic = TopicConverter.new(self, user).convert_to_private_message\n    Tag.update_counters(private_topic.tags, { public_topic_count: -1 }) if !read_restricted\n    add_small_action(user, \"private_topic\") if private_topic\n    private_topic\n  end\n\n  def update_excerpt(excerpt)\n    update_column(:excerpt, excerpt)\n    ApplicationController.banner_json_cache.clear if archetype == \"banner\"\n  end\n\n  def pm_with_non_human_user?\n    sql = <<~SQL\n    SELECT 1 FROM topics\n    LEFT JOIN topic_allowed_groups ON topics.id = topic_allowed_groups.topic_id\n    WHERE topic_allowed_groups.topic_id IS NULL\n    AND topics.archetype = :private_message\n    AND topics.id = :topic_id\n    AND (\n      SELECT COUNT(*) FROM topic_allowed_users\n      WHERE topic_allowed_users.topic_id = :topic_id\n      AND topic_allowed_users.user_id > 0\n    ) = 1\n    SQL\n\n    result = DB.exec(sql, private_message: Archetype.private_message, topic_id: self.id)\n    result != 0\n  end\n\n  def featured_link_root_domain\n    MiniSuffix.domain(UrlHelper.encode_and_parse(self.featured_link).hostname)\n  end\n\n  def self.private_message_topics_count_per_day(start_date, end_date, topic_subtype)\n    private_messages\n      .with_subtype(topic_subtype)\n      .where(\"topics.created_at >= ? AND topics.created_at <= ?\", start_date, end_date)\n      .group(\"date(topics.created_at)\")\n      .order(\"date(topics.created_at)\")\n      .count\n  end\n\n  def is_category_topic?\n    @is_category_topic ||= Category.exists?(topic_id: self.id.to_i)\n  end\n\n  def reset_bumped_at\n    post =\n      ordered_posts.where(\n        user_deleted: false,\n        hidden: false,\n        post_type: Post.types[:regular],\n      ).last || first_post\n\n    self.bumped_at = post.created_at\n    self.save(validate: false)\n  end\n\n  def auto_close_threshold_reached?\n    return if user&.staff?\n\n    scores =\n      ReviewableScore\n        .pending\n        .joins(:reviewable)\n        .where(\"reviewable_scores.score >= ?\", Reviewable.min_score_for_priority)\n        .where(\"reviewables.topic_id = ?\", self.id)\n        .pluck(\n          \"COUNT(DISTINCT reviewable_scores.user_id), COALESCE(SUM(reviewable_scores.score), 0.0)\",\n        )\n        .first\n\n    scores[0] >= SiteSetting.num_flaggers_to_close_topic &&\n      scores[1] >= Reviewable.score_to_auto_close_topic\n  end\n\n  def update_category_topic_count_by(num)\n    if category_id.present?\n      Category\n        .where(\"id = ?\", category_id)\n        .where(\"topic_id != ? OR topic_id IS NULL\", self.id)\n        .update_all(\"topic_count = topic_count + #{num.to_i}\")\n    end\n  end\n\n  def access_topic_via_group\n    Group\n      .joins(:category_groups)\n      .where(\"category_groups.category_id = ?\", self.category_id)\n      .where(\"groups.public_admission OR groups.allow_membership_requests\")\n      .order(:allow_membership_requests)\n      .first\n  end\n\n  def incoming_email_addresses(group: nil, received_before: Time.zone.now)\n    email_addresses = Set.new\n\n    self\n      .incoming_email\n      .where(\"created_at <= ?\", received_before)\n      .each do |incoming_email|\n        to_addresses = incoming_email.to_addresses_split\n        cc_addresses = incoming_email.cc_addresses_split\n        combined_addresses = [to_addresses, cc_addresses].flatten\n\n        # We only care about the emails addressed to the group or CC'd to the\n        # group if the group is present. If combined addresses is empty we do\n        # not need to do this check, and instead can proceed on to adding the\n        # from address.\n        #\n        # Will not include test1@gmail.com if the only IncomingEmail\n        # is:\n        #\n        # from: test1@gmail.com\n        # to: test+support@discoursemail.com\n        #\n        # Because we don't care about the from addresses and also the to address\n        # is not the email_username, which will be something like test1@gmail.com.\n        if group.present? && combined_addresses.any?\n          next if combined_addresses.none? { |address| address =~ group.email_username_regex }\n        end\n\n        email_addresses.add(incoming_email.from_address)\n        email_addresses.merge(combined_addresses)\n      end\n\n    email_addresses.subtract([nil, \"\"])\n    email_addresses.delete(group.email_username) if group.present?\n\n    email_addresses.to_a\n  end\n\n  def create_invite_notification!(target_user, notification_type, invited_by, post_number: 1)\n    if UserCommScreener.new(\n         acting_user: invited_by,\n         target_user_ids: target_user.id,\n       ).ignoring_or_muting_actor?(target_user.id)\n      raise NotAllowed.new(I18n.t(\"not_accepting_pms\", username: target_user.username))\n    end\n\n    target_user.notifications.create!(\n      notification_type: notification_type,\n      topic_id: self.id,\n      post_number: post_number,\n      data: {\n        topic_title: self.title,\n        display_username: invited_by.username,\n        original_user_id: user.id,\n        original_username: user.username,\n      }.to_json,\n    )\n  end\n\n  def rate_limit_topic_invitation(invited_by)\n    RateLimiter.new(\n      invited_by,\n      \"topic-invitations-per-day\",\n      SiteSetting.max_topic_invitations_per_day,\n      1.day.to_i,\n    ).performed!\n\n    RateLimiter.new(\n      invited_by,\n      \"topic-invitations-per-minute\",\n      SiteSetting.max_topic_invitations_per_minute,\n      1.day.to_i,\n    ).performed!\n  end\n\n  def cannot_permanently_delete_reason(user)\n    all_posts_count =\n      Post\n        .with_deleted\n        .where(topic_id: self.id)\n        .where(\n          post_type: [Post.types[:regular], Post.types[:moderator_action], Post.types[:whisper]],\n        )\n        .count\n\n    if posts_count > 0 || all_posts_count > 1\n      I18n.t(\"post.cannot_permanently_delete.many_posts\")\n    elsif self.deleted_by_id == user&.id && self.deleted_at >= Post::PERMANENT_DELETE_TIMER.ago\n      time_left =\n        RateLimiter.time_left(\n          Post::PERMANENT_DELETE_TIMER.to_i - Time.zone.now.to_i + self.deleted_at.to_i,\n        )\n      I18n.t(\"post.cannot_permanently_delete.wait_or_different_admin\", time_left: time_left)\n    end\n  end\n\n  def first_smtp_enabled_group\n    self.allowed_groups.where(smtp_enabled: true).first\n  end\n\n  def secure_audience_publish_messages\n    target_audience = {}\n\n    if private_message?\n      target_audience[:user_ids] = User.human_users.where(\"admin OR moderator\").pluck(:id)\n      target_audience[:user_ids] |= allowed_users.pluck(:id)\n      target_audience[:user_ids] |= allowed_group_users.pluck(:id)\n    else\n      target_audience[:group_ids] = secure_group_ids\n    end\n\n    target_audience\n  end\n\n  def self.publish_stats_to_clients!(topic_id, type, opts = {})\n    topic = Topic.find_by(id: topic_id)\n    return unless topic.present?\n\n    case type\n    when :liked, :unliked\n      stats = { like_count: topic.like_count }\n    when :created, :destroyed, :deleted, :recovered\n      stats = {\n        posts_count: topic.posts_count,\n        last_posted_at: topic.last_posted_at.as_json,\n        last_poster: BasicUserSerializer.new(topic.last_poster, root: false).as_json,\n      }\n    else\n      stats = nil\n    end\n\n    if stats\n      secure_audience = topic.secure_audience_publish_messages\n\n      if secure_audience[:user_ids] != [] && secure_audience[:group_ids] != []\n        message = stats.merge({ id: topic_id, updated_at: Time.now, type: :stats })\n        MessageBus.publish(\"/topic/#{topic_id}\", message, opts.merge(secure_audience))\n      end\n    end\n  end\n\n  def group_pm?\n    private_message? && all_allowed_users.count > 2\n  end\n\n  def visible_tags(guardian)\n    tags.reject { |tag| guardian.hidden_tag_names.include?(tag[:name]) }\n  end\n\n  private\n\n  def invite_to_private_message(invited_by, target_user, guardian)\n    if !guardian.can_send_private_message?(target_user)\n      raise UserExists.new(I18n.t(\"activerecord.errors.models.topic.attributes.base.cant_send_pm\"))\n    end\n\n    rate_limit_topic_invitation(invited_by)\n\n    Topic.transaction do\n      unless topic_allowed_users.exists?(user_id: target_user.id)\n        topic_allowed_users.create!(user_id: target_user.id)\n      end\n\n      user_in_allowed_group = (user.group_ids & topic_allowed_groups.map(&:group_id)).present?\n      add_small_action(invited_by, \"invited_user\", target_user.username) if !user_in_allowed_group\n\n      create_invite_notification!(\n        target_user,\n        Notification.types[:invited_to_private_message],\n        invited_by,\n      )\n    end\n  end\n\n  def invite_to_topic(invited_by, target_user, group_ids, guardian)\n    Topic.transaction do\n      rate_limit_topic_invitation(invited_by)\n\n      if group_ids.present?\n        (\n          self.category.groups.where(id: group_ids).where(automatic: false) -\n            target_user.groups.where(automatic: false)\n        ).each do |group|\n          if guardian.can_edit_group?(group)\n            group.add(target_user)\n\n            GroupActionLogger.new(invited_by, group).log_add_user_to_group(target_user)\n          end\n        end\n      end\n\n      if Guardian.new(target_user).can_see_topic?(self)\n        create_invite_notification!(target_user, Notification.types[:invited_to_topic], invited_by)\n      end\n    end\n  end\n\n  def limit_first_day_topics_per_day\n    apply_per_day_rate_limit_for(\"first-day-topics\", :max_topics_in_first_day)\n  end\n\n  def apply_per_day_rate_limit_for(key, method_name)\n    RateLimiter.new(user, \"#{key}-per-day\", SiteSetting.get(method_name), 1.day.to_i)\n  end\nend\n\n# == Schema Information\n#\n# Table name: topics\n#\n#  id                        :integer          not null, primary key\n#  title                     :string           not null\n#  last_posted_at            :datetime\n#  created_at                :datetime         not null\n#  updated_at                :datetime         not null\n#  views                     :integer          default(0), not null\n#  posts_count               :integer          default(0), not null\n#  user_id                   :integer\n#  last_post_user_id         :integer          not null\n#  reply_count               :integer          default(0), not null\n#  featured_user1_id         :integer\n#  featured_user2_id         :integer\n#  featured_user3_id         :integer\n#  deleted_at                :datetime\n#  highest_post_number       :integer          default(0), not null\n#  like_count                :integer          default(0), not null\n#  incoming_link_count       :integer          default(0), not null\n#  category_id               :integer\n#  visible                   :boolean          default(TRUE), not null\n#  moderator_posts_count     :integer          default(0), not null\n#  closed                    :boolean          default(FALSE), not null\n#  archived                  :boolean          default(FALSE), not null\n#  bumped_at                 :datetime         not null\n#  has_summary               :boolean          default(FALSE), not null\n#  archetype                 :string           default(\"regular\"), not null\n#  featured_user4_id         :integer\n#  notify_moderators_count   :integer          default(0), not null\n#  spam_count                :integer          default(0), not null\n#  pinned_at                 :datetime\n#  score                     :float\n#  percent_rank              :float            default(1.0), not null\n#  subtype                   :string\n#  slug                      :string\n#  deleted_by_id             :integer\n#  participant_count         :integer          default(1)\n#  word_count                :integer\n#  excerpt                   :string\n#  pinned_globally           :boolean          default(FALSE), not null\n#  pinned_until              :datetime\n#  fancy_title               :string\n#  highest_staff_post_number :integer          default(0), not null\n#  featured_link             :string\n#  reviewable_score          :float            default(0.0), not null\n#  image_upload_id           :bigint\n#  slow_mode_seconds         :integer          default(0), not null\n#  bannered_until            :datetime\n#  external_id               :string\n#\n# Indexes\n#\n#  idx_topics_front_page                   (deleted_at,visible,archetype,category_id,id)\n#  idx_topics_user_id_deleted_at           (user_id) WHERE (deleted_at IS NULL)\n#  idxtopicslug                            (slug) WHERE ((deleted_at IS NULL) AND (slug IS NOT NULL))\n#  index_topics_on_bannered_until          (bannered_until) WHERE (bannered_until IS NOT NULL)\n#  index_topics_on_bumped_at_public        (bumped_at) WHERE ((deleted_at IS NULL) AND ((archetype)::text <> 'private_message'::text))\n#  index_topics_on_created_at_and_visible  (created_at,visible) WHERE ((deleted_at IS NULL) AND ((archetype)::text <> 'private_message'::text))\n#  index_topics_on_external_id             (external_id) UNIQUE WHERE (external_id IS NOT NULL)\n#  index_topics_on_id_and_deleted_at       (id,deleted_at)\n#  index_topics_on_id_filtered_banner      (id) UNIQUE WHERE (((archetype)::text = 'banner'::text) AND (deleted_at IS NULL))\n#  index_topics_on_image_upload_id         (image_upload_id)\n#  index_topics_on_lower_title             (lower((title)::text))\n#  index_topics_on_pinned_at               (pinned_at) WHERE (pinned_at IS NOT NULL)\n#  index_topics_on_pinned_globally         (pinned_globally) WHERE pinned_globally\n#  index_topics_on_pinned_until            (pinned_until) WHERE (pinned_until IS NOT NULL)\n#  index_topics_on_timestamps_private      (bumped_at,created_at,updated_at) WHERE ((deleted_at IS NULL) AND ((archetype)::text = 'private_message'::text))\n#  index_topics_on_updated_at_public       (updated_at,visible,highest_staff_post_number,highest_post_number,category_id,created_at,id) WHERE (((archetype)::text <> 'private_message'::text) AND (deleted_at IS NULL))\n#\n", "# frozen_string_literal: true\n\nmodule TopicTagsMixin\n  def self.included(klass)\n    klass.attributes :tags\n    klass.attributes :tags_descriptions\n  end\n\n  def include_tags?\n    scope.can_see_tags?(topic)\n  end\n\n  def tags\n    all_tags.map(&:name)\n  end\n\n  def tags_descriptions\n    all_tags.each.with_object({}) { |tag, acc| acc[tag.name] = tag.description }.compact\n  end\n\n  def topic\n    object.is_a?(Topic) ? object : object.topic\n  end\n\n  private\n\n  def all_tags\n    return @tags if defined?(@tags)\n\n    tags = topic.visible_tags(scope)\n\n    # Calling method `pluck` or `order` along with `includes` causing N+1 queries\n    tags =\n      (\n        if SiteSetting.tags_sort_alphabetically\n          tags.sort_by(&:name)\n        else\n          topic_count_column = Tag.topic_count_column(scope)\n          tags.sort_by { |tag| tag.public_send(topic_count_column) }.reverse\n        end\n      )\n\n    @tags = tags\n  end\nend\n", "<%- if include_crawler_content? %>\n\n<%= server_plugin_outlet \"topic_list_header\" %>\n\n<%- if SiteSetting.tagging_enabled && @tag_id %>\n  <h1>\n    <%= link_to \"#{Discourse.base_url}/tag/#{@tag_id}\", itemprop: 'item' do %>\n      <span itemprop='name'><%= @tag_id %></span>\n    <% end %>\n  </h1>\n<% end %>\n\n<% if @category %>\n  <h1>\n    <% if @category.parent_category %>\n      <%= link_to @category.parent_category.url, itemprop: 'item' do %>\n        <span itemprop='name'><%= @category.parent_category.name %></span>\n      <% end %>\n      &nbsp;\n    <% end %>\n\n    <%= link_to @category.url, itemprop: 'item' do %>\n      <span itemprop='name'><%= @category.name %></span>\n    <% end %>\n  </h1>\n  <br/>\n\n  <% if params[:page].to_i == 0 && @subcategories.present? %>\n    <% @subcategories.each do |subcategory| %>\n      <a href='<%= subcategory.url %>'>\n        <span itemprop='name'><%= subcategory.name %></span>\n      </a>\n      <% if subcategory.description.present? %>\n        <span itemprop='description'><%= subcategory.description_text %></span>\n      <% end %>\n    <% end %>\n    <br/>\n  <% end %>\n<% end %>\n\n<div class=\"topic-list-container\" itemscope itemtype='http://schema.org/ItemList'>\n  <meta itemprop='itemListOrder' content='http://schema.org/ItemListOrderDescending'>\n\n  <table class='topic-list'>\n\n    <thead>\n      <tr>\n        <th><%= t 'js.topic.title' %></th>\n        <th></th>\n        <th class=\"replies\"><%= t 'js.replies' %></th>\n        <th class=\"views\"><%= t 'js.views' %></th>\n        <th><%= t 'js.activity' %></th>\n      </tr>\n    </thead>\n\n    <tbody>\n      <% @list.topics.each_with_index do |t,i| %>\n        <tr class=\"topic-list-item\">\n          <td class=\"main-link\" itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>\n            <meta itemprop='position' content='<%= i + 1 %>'>\n            <span class=\"link-top-line\">\n              <a itemprop='url' href='<%= t.url %>' class='title raw-link raw-topic-link'><%= t.title %></a>\n            </span>\n            <div class=\"link-bottom-line\">\n              <% if (!@category || @category.has_children?) && t.category && !t.category.uncategorized? %>\n                <a href='<%= t.category.url %>' class='badge-wrapper bullet'>\n                  <span class='badge-category-bg' style='background-color: #<%= t.category.color %>'></span>\n                  <span class='badge-category clear-badge'>\n                    <span class='category-name'><%= t.category.name %></span>\n                  </span>\n                </a>\n              <% end %>\n              <% if tags = t.visible_tags(guardian) %>\n                <div class=\"discourse-tags\">\n                  <% tags.each_with_index do |tag, index| %>\n                    <a href='<%= tag.full_url %>' class='discourse-tag'><%= tag.name %></a>\n                    <% if index < tags.size - 1 %>,&nbsp;<% end %>\n                  <% end %>\n                </div>\n              <% end %>\n            </div>\n            <% if t.pinned_until && (t.pinned_until > Time.zone.now) && (t.pinned_globally || @list.category) && t.excerpt %>\n              <p class='excerpt'>\n                <%= t.excerpt.html_safe %>\n              </p>\n            <% end %>\n          </td>\n          <td class='posters'>\n            <% t.posters.each do |poster| %>\n              <a href=\"<%= Discourse.base_url %>/u/<%= poster.user.username %>\" class=\"<%= poster.extras %>\">\n                <img width=\"25\" height=\"25\" src=\"<%= poster.user.avatar_template.gsub('{size}', '25') %>\" class=\"avatar\" title='<%= h(poster.name_and_description) %>' aria-label='<%= h(poster.name_and_description) %>'>\n              </a>\n            <% end %>\n          </td>\n          <td class=\"replies\">\n            <span class='posts' title='<%= t 'posts' %>'><%= t.posts_count - 1 %></span>\n          </td>\n          <td class=\"views\">\n            <span class='views' title='<%= t 'views' %>'><%= t.views %></span>\n          </td>\n          <td>\n            <%= I18n.l(t.last_posted_at || t.created_at, format: :date_only) %>\n          </td>\n        </tr>\n      <% end %>\n    </tbody>\n\n  </table>\n</div>\n\n<% if @list.topics.length > 0 && @list.more_topics_url %>\n  <div class=\"navigation\" role='navigation' itemscope itemtype='http://schema.org/SiteNavigationElement'>\n    <% if params[:page].to_i > 0 %>\n      <span itemprop='name'><a href='<%= @list.prev_topics_url %>' rel='prev' itemprop='url'><%= t 'prev_page' %></a> &nbsp;</span>\n    <% end %>\n    <% if @list.topics.size == @list.per_page %>\n      <span itemprop='name'><b><a href='<%= @list.more_topics_url %>' rel='next' itemprop='url'><%= t 'next_page' %></a></b></span>\n    <% end %>\n  </div>\n\n  <% content_for :head do %>\n    <% if params[:page].to_i > 0 %>\n      <link rel=\"prev\" href=\"<%= @list.prev_topics_url -%>\">\n    <% end %>\n    <link rel=\"next\" href=\"<%= @list.more_topics_url -%>\">\n  <% end %>\n<% end %>\n\n<%- end %> <!-- include_crawler_content? -->\n\n<% if @rss %>\n  <% content_for :head do %>\n    <%= auto_discovery_link_tag(:rss, \"#{Discourse.base_url}/posts.rss\", title: I18n.t(\"rss_description.posts\")) %>\n    <%= auto_discovery_link_tag(:rss, { action: \"#{@rss}_feed\", params: @params || {} }, title: I18n.t(\"rss_description.#{@rss_description}\")) %>\n  <% end %>\n<% end %>\n\n<% if @category %>\n  <% content_for :head do %>\n    <%= auto_discovery_link_tag(:rss, { action: :category_feed }, rel: 'alternate nofollow', title: t('rss_topics_in_category', category: @category.name)) %>\n    <%= raw crawlable_meta_data(title: @category.name, description: @category.description, image: @category.uploaded_logo&.url.presence) %>\n  <% end %>\n<% elsif @tag_id %>\n  <% content_for :head do %>\n    <%= raw crawlable_meta_data(title: @title, description: @description_meta) %>\n  <% end %>\n<% else %>\n  <% content_for :head do %>\n    <%= raw crawlable_meta_data(title: SiteSetting.title, description: SiteSetting.site_description) %>\n  <% end %>\n<% end %>\n\n<% if @title %>\n  <% content_for :title do %><%= @title %><% end %>\n<% elsif @category %>\n  <% content_for :title do %><%= @category.name %> - <%= SiteSetting.title %><% end %>\n<% elsif params[:page].to_i > 1 %>\n  <% content_for :title do %><%=t 'page_num', num: params[:page].to_i + 1 %> - <%= SiteSetting.title %><% end %>\n<% end %>\n", "# frozen_string_literal: true\n\nRSpec.describe ListController do\n  fab!(:user) { Fabricate(:user) }\n  fab!(:topic) { Fabricate(:topic, user: user) }\n  fab!(:group) { Fabricate(:group, name: \"AwesomeGroup\") }\n  fab!(:admin) { Fabricate(:admin) }\n\n  before do\n    admin # to skip welcome wizard at home page `/`\n    SiteSetting.top_menu = \"latest|new|unread|categories\"\n  end\n\n  describe \"#index\" do\n    it \"does not return a 500 for invalid input\" do\n      get \"/latest?min_posts=bob\"\n      expect(response.status).to eq(400)\n\n      get \"/latest?max_posts=bob\"\n      expect(response.status).to eq(400)\n\n      get \"/latest?max_posts=1111111111111111111111111111111111111111\"\n      expect(response.status).to eq(400)\n\n      get \"/latest?page=-1\"\n      expect(response.status).to eq(400)\n\n      get \"/latest?page=2147483648\"\n      expect(response.status).to eq(400)\n\n      get \"/latest?page=1111111111111111111111111111111111111111\"\n      expect(response.status).to eq(400)\n\n      get \"/latest?tags[1]=hello\"\n      expect(response.status).to eq(400)\n    end\n\n    it \"returns 200 for legit requests\" do\n      get \"/latest.json?no_definitions=true&no_subcategories=false&page=1&_=1534296100767\"\n      expect(response.status).to eq(200)\n\n      get \"/latest.json?max_posts=12\"\n      expect(response.status).to eq(200)\n\n      get \"/latest.json?min_posts=0\"\n      expect(response.status).to eq(200)\n\n      get \"/latest?page=0\"\n      expect(response.status).to eq(200)\n\n      get \"/latest?page=1\"\n      expect(response.status).to eq(200)\n\n      get \"/latest.json?page=2147483647\"\n      expect(response.status).to eq(200)\n\n      get \"/latest?search=\"\n      expect(response.status).to eq(200)\n\n      get \"/latest.json?topic_ids%5B%5D=14583&topic_ids%5B%5D=14584\"\n      expect(response.status).to eq(200)\n\n      get \"/latest.json?topic_ids=14583%2C14584\"\n      expect(response.status).to eq(200)\n\n      get \"/latest?tags[]=hello\"\n      expect(response.status).to eq(200)\n    end\n\n    (Discourse.anonymous_filters - [:categories]).each do |filter|\n      context \"with #{filter}\" do\n        it \"succeeds\" do\n          get \"/#{filter}\"\n          expect(response.status).to eq(200)\n        end\n      end\n    end\n\n    it \"allows users to filter on a set of topic ids\" do\n      p = create_post\n\n      get \"/latest.json\", params: { topic_ids: \"#{p.topic_id}\" }\n      expect(response.status).to eq(200)\n      parsed = response.parsed_body\n      expect(parsed[\"topic_list\"][\"topics\"].length).to eq(1)\n    end\n\n    it \"shows correct title if topic list is set for homepage\" do\n      get \"/latest\"\n\n      expect(response.body).to have_tag \"title\", text: \"Discourse\"\n\n      SiteSetting.short_site_description = \"Best community\"\n      get \"/latest\"\n\n      expect(response.body).to have_tag \"title\", text: \"Discourse - Best community\"\n    end\n\n    it \"returns structured data\" do\n      get \"/latest\"\n\n      expect(response.status).to eq(200)\n      topic_list = Nokogiri.HTML5(response.body).css(\".topic-list\")\n      first_item = topic_list.css('[itemprop=\"itemListElement\"]')\n      expect(first_item.css('[itemprop=\"position\"]')[0][\"content\"]).to eq(\"1\")\n      expect(first_item.css('[itemprop=\"url\"]')[0][\"href\"]).to eq(topic.url)\n    end\n\n    it \"does not result in N+1 queries when topics have tags and tagging_enabled site setting is enabled\" do\n      SiteSetting.tagging_enabled = true\n      tag = Fabricate(:tag)\n      topic.tags << tag\n\n      # warm up\n      get \"/latest.json\"\n      expect(response.status).to eq(200)\n\n      initial_sql_queries_count =\n        track_sql_queries do\n          get \"/latest.json\"\n\n          expect(response.status).to eq(200)\n\n          body = response.parsed_body\n\n          expect(body[\"topic_list\"][\"topics\"].map { |t| t[\"id\"] }).to contain_exactly(topic.id)\n          expect(body[\"topic_list\"][\"topics\"][0][\"tags\"]).to contain_exactly(tag.name)\n        end.count\n\n      tag2 = Fabricate(:tag)\n      topic2 = Fabricate(:topic, tags: [tag2])\n\n      new_sql_queries_count =\n        track_sql_queries do\n          get \"/latest.json\"\n\n          expect(response.status).to eq(200)\n\n          body = response.parsed_body\n\n          expect(body[\"topic_list\"][\"topics\"].map { |t| t[\"id\"] }).to contain_exactly(\n            topic.id,\n            topic2.id,\n          )\n\n          expect(body[\"topic_list\"][\"topics\"][0][\"tags\"]).to contain_exactly(tag2.name)\n          expect(body[\"topic_list\"][\"topics\"][1][\"tags\"]).to contain_exactly(tag.name)\n        end.count\n\n      expect(new_sql_queries_count).to eq(initial_sql_queries_count)\n    end\n\n    it \"does not N+1 queries when topic featured users have different primary groups\" do\n      user.update!(primary_group: group)\n\n      # warm up\n      get \"/latest.json\"\n      expect(response.status).to eq(200)\n\n      initial_sql_queries_count =\n        track_sql_queries do\n          get \"/latest.json\"\n\n          expect(response.status).to eq(200)\n\n          body = response.parsed_body\n\n          expect(body[\"topic_list\"][\"topics\"].map { |t| t[\"id\"] }).to contain_exactly(topic.id)\n          expect(\n            body[\"topic_list\"][\"topics\"][0][\"posters\"].map { |p| p[\"user_id\"] },\n          ).to contain_exactly(user.id)\n        end.count\n\n      group2 = Fabricate(:group)\n      user2 = Fabricate(:user, primary_group: group2)\n      topic.update!(last_post_user_id: user2.id)\n\n      group3 = Fabricate(:group)\n      user3 = Fabricate(:user, flair_group: group3)\n      topic.update!(featured_user3_id: user3.id)\n\n      new_sql_queries_count =\n        track_sql_queries do\n          get \"/latest.json\"\n\n          expect(response.status).to eq(200)\n\n          body = response.parsed_body\n\n          expect(body[\"topic_list\"][\"topics\"].map { |t| t[\"id\"] }).to contain_exactly(topic.id)\n          expect(\n            body[\"topic_list\"][\"topics\"][0][\"posters\"].map { |p| p[\"user_id\"] },\n          ).to contain_exactly(user.id, user2.id, user3.id)\n        end.count\n\n      expect(new_sql_queries_count).to be <= initial_sql_queries_count\n    end\n\n    context \"with topics with tags\" do\n      let(:tag_group) { Fabricate.build(:tag_group) }\n      let(:tag_group_permission) { Fabricate.build(:tag_group_permission, tag_group: tag_group) }\n      let(:restricted_tag) { Fabricate(:tag) }\n      let(:public_tag) { Fabricate(:tag) }\n\n      before do\n        tag_group.tag_group_permissions << tag_group_permission\n        tag_group.save!\n        tag_group_permission.tag_group.tags << restricted_tag\n        topic.tags << [public_tag, restricted_tag]\n      end\n\n      it \"does not show hidden tags\" do\n        get \"/latest\"\n\n        expect(response.status).to eq(200)\n        expect(response.body).to include(public_tag.name)\n        expect(response.body).not_to include(restricted_tag.name)\n      end\n    end\n  end\n\n  describe \"categories and X\" do\n    let(:category) { Fabricate(:category_with_definition) }\n    let(:sub_category) { Fabricate(:category_with_definition, parent_category: category) }\n\n    it \"returns top topics\" do\n      Fabricate(:topic, like_count: 1000, posts_count: 100)\n      TopTopic.refresh!\n\n      get \"/categories_and_top.json\"\n      data = response.parsed_body\n      expect(data[\"topic_list\"][\"topics\"].length).to eq(1)\n\n      get \"/categories_and_latest.json\"\n      data = response.parsed_body\n      expect(data[\"topic_list\"][\"topics\"].length).to eq(2)\n    end\n\n    it \"returns topics from subcategories when no_subcategories=false\" do\n      Fabricate(:topic, category: sub_category)\n      get \"/c/#{category.slug}/#{category.id}/l/latest.json?no_subcategories=false\"\n      expect(response.parsed_body[\"topic_list\"][\"topics\"].length).to eq(2)\n    end\n  end\n\n  describe \"titles for crawler layout\" do\n    it \"has no title for the default URL\" do\n      topic\n      filter = Discourse.anonymous_filters[0]\n      get \"/#{filter}\", params: { _escaped_fragment_: \"true\" }\n\n      expect(response.body).to include(I18n.t(\"rss_description.posts\"))\n\n      expect(response.body).to_not include(I18n.t(\"js.filters.with_topics\", filter: filter))\n    end\n\n    it \"has a title for non-default URLs\" do\n      topic\n      filter = Discourse.anonymous_filters[1]\n      get \"/#{filter}\", params: { _escaped_fragment_: \"true\" }\n\n      expect(response.body).to include(I18n.t(\"js.filters.with_topics\", filter: filter))\n    end\n  end\n\n  describe \"filter private messages by tag\" do\n    fab!(:user) { Fabricate(:user) }\n    fab!(:moderator) { Fabricate(:moderator) }\n    fab!(:admin) { Fabricate(:admin) }\n    let(:tag) { Fabricate(:tag) }\n    let(:private_message) { Fabricate(:private_message_topic, user: admin) }\n\n    before do\n      SiteSetting.tagging_enabled = true\n      SiteSetting.pm_tags_allowed_for_groups = \"1|2|3\"\n      Fabricate(:topic_tag, tag: tag, topic: private_message)\n    end\n\n    it \"should fail for non-staff users\" do\n      sign_in(user)\n      get \"/topics/private-messages-tags/#{user.username}/#{tag.name}.json\"\n      expect(response.status).to eq(404)\n    end\n\n    it \"should fail for staff users if empty\" do\n      SiteSetting.pm_tags_allowed_for_groups = \"\"\n\n      [moderator, admin].each do |user|\n        sign_in(user)\n        get \"/topics/private-messages-tags/#{user.username}/#{tag.name}.json\"\n        expect(response.status).to eq(404)\n      end\n    end\n\n    it \"should be success for staff users\" do\n      [moderator, admin].each do |user|\n        sign_in(user)\n        get \"/topics/private-messages-tags/#{user.username}/#{tag.name}.json\"\n        expect(response.status).to eq(200)\n      end\n    end\n\n    it \"should work for tag with unicode name\" do\n      unicode_tag = Fabricate(:tag, name: \"hello-\ud83c\uddfa\ud83c\uddf8\")\n      Fabricate(:topic_tag, tag: unicode_tag, topic: private_message)\n\n      sign_in(admin)\n      get \"/topics/private-messages-tags/#{admin.username}/#{UrlHelper.encode_component(unicode_tag.name)}.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"topic_list\"][\"topics\"].first[\"id\"]).to eq(private_message.id)\n    end\n\n    it \"should work for users who are allowed and direct links\" do\n      SiteSetting.pm_tags_allowed_for_groups = group.name\n      group.add(user)\n      sign_in(user)\n\n      get \"/u/#{user.username}/messages/tags/#{tag.name}\"\n\n      expect(response.status).to eq(200)\n    end\n  end\n\n  describe \"#private_messages_group\" do\n    describe \"when user not in personal_message_enabled_groups group\" do\n      let!(:topic) { Fabricate(:private_message_topic, allowed_groups: [group]) }\n\n      before do\n        group.add(user)\n        SiteSetting.personal_message_enabled_groups = Group::AUTO_GROUPS[:staff]\n        Group.refresh_automatic_groups!\n      end\n\n      it \"should display group private messages for an admin\" do\n        sign_in(Fabricate(:admin))\n\n        get \"/topics/private-messages-group/#{user.username}/#{group.name}.json\"\n\n        expect(response.status).to eq(200)\n\n        expect(response.parsed_body[\"topic_list\"][\"topics\"].first[\"id\"]).to eq(topic.id)\n      end\n\n      it \"should display moderator group private messages for a moderator\" do\n        moderator = Fabricate(:moderator)\n        group = Group.find(Group::AUTO_GROUPS[:moderators])\n        topic = Fabricate(:private_message_topic, allowed_groups: [group])\n\n        sign_in(moderator)\n\n        get \"/topics/private-messages-group/#{moderator.username}/#{group.name}.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"should not display group private messages for a moderator's group\" do\n        moderator = Fabricate(:moderator)\n        sign_in(moderator)\n\n        get \"/topics/private-messages-group/#{user.username}/#{group.name}.json\"\n\n        expect(response.status).to eq(404)\n      end\n    end\n\n    describe \"with unicode_usernames\" do\n      before do\n        group.add(user)\n        sign_in(user)\n        SiteSetting.unicode_usernames = false\n        Group.refresh_automatic_groups!\n      end\n\n      it \"should return the right response when user does not belong to group\" do\n        Fabricate(:private_message_topic, allowed_groups: [group])\n\n        group.remove(user)\n\n        get \"/topics/private-messages-group/#{user.username}/#{group.name}.json\"\n\n        expect(response.status).to eq(404)\n      end\n\n      it \"should return the right response\" do\n        topic = Fabricate(:private_message_topic, allowed_groups: [group])\n        get \"/topics/private-messages-group/#{user.username}/awesomegroup.json\"\n\n        expect(response.status).to eq(200)\n\n        expect(response.parsed_body[\"topic_list\"][\"topics\"].first[\"id\"]).to eq(topic.id)\n      end\n    end\n\n    describe \"with unicode_usernames\" do\n      before do\n        sign_in(user)\n        SiteSetting.unicode_usernames = true\n        Group.refresh_automatic_groups!\n      end\n\n      it \"Returns a 200 with unicode group name\" do\n        unicode_group = Fabricate(:group, name: \"\u7fa4\u7fa4\u7ec4\")\n        unicode_group.add(user)\n        topic = Fabricate(:private_message_topic, allowed_groups: [unicode_group])\n        get \"/topics/private-messages-group/#{user.username}/#{UrlHelper.encode_component(unicode_group.name)}.json\"\n        expect(response.status).to eq(200)\n\n        expect(response.parsed_body[\"topic_list\"][\"topics\"].first[\"id\"]).to eq(topic.id)\n      end\n    end\n  end\n\n  describe \"#group_topics\" do\n    %i[user user2].each do |user|\n      let(user) do\n        user = Fabricate(:user)\n        group.add(user)\n        user\n      end\n    end\n\n    let!(:topic) { Fabricate(:topic, user: user) }\n    let!(:topic2) { Fabricate(:topic, user: user2) }\n    let!(:another_topic) { Fabricate(:topic) }\n\n    describe \"when an invalid group name is given\" do\n      it \"should return the right response\" do\n        get \"/topics/groups/something.json\"\n\n        expect(response.status).to eq(404)\n      end\n    end\n\n    describe \"for an anon user\" do\n      describe \"public visible group\" do\n        it \"should return the right response\" do\n          get \"/topics/groups/#{group.name}.json\"\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"topic_list\"]).to be_present\n        end\n      end\n\n      describe \"group restricted to logged-on-users\" do\n        before { group.update!(visibility_level: Group.visibility_levels[:logged_on_users]) }\n\n        it \"should return the right response\" do\n          get \"/topics/groups/#{group.name}.json\"\n\n          expect(response.status).to eq(403)\n        end\n      end\n\n      describe \"restricted group\" do\n        before { group.update!(visibility_level: Group.visibility_levels[:staff]) }\n\n        it \"should return the right response\" do\n          get \"/topics/groups/#{group.name}.json\"\n\n          expect(response.status).to eq(403)\n        end\n      end\n\n      describe \"group members visibility restricted to logged-on-users\" do\n        before do\n          group.update!(members_visibility_level: Group.visibility_levels[:logged_on_users])\n        end\n\n        it \"should return the right response\" do\n          get \"/topics/groups/#{group.name}.json\"\n\n          expect(response.status).to eq(403)\n        end\n      end\n    end\n\n    describe \"for a normal user\" do\n      before { sign_in(Fabricate(:user)) }\n\n      describe \"restricted group\" do\n        before { group.update!(visibility_level: Group.visibility_levels[:staff]) }\n\n        it \"should return the right response\" do\n          get \"/topics/groups/#{group.name}.json\"\n\n          expect(response.status).to eq(403)\n        end\n      end\n\n      describe \"group restricted to logged-on-users\" do\n        before { group.update!(visibility_level: Group.visibility_levels[:logged_on_users]) }\n\n        it \"should return the right response\" do\n          get \"/topics/groups/#{group.name}.json\"\n\n          expect(response.status).to eq(200)\n        end\n      end\n    end\n\n    describe \"for a group user\" do\n      before { sign_in(user) }\n\n      it \"should be able to view the topics started by group users\" do\n        get \"/topics/groups/#{group.name}.json\"\n\n        expect(response.status).to eq(200)\n\n        topics = response.parsed_body[\"topic_list\"][\"topics\"]\n\n        expect(topics.map { |topic| topic[\"id\"] }).to contain_exactly(topic.id, topic2.id)\n      end\n    end\n  end\n\n  describe \"RSS feeds\" do\n    it \"renders latest RSS\" do\n      get \"/latest.rss\"\n      expect(response.status).to eq(200)\n      expect(response.media_type).to eq(\"application/rss+xml\")\n      expect(response.headers[\"X-Robots-Tag\"]).to eq(\"noindex\")\n    end\n\n    it \"renders latest RSS with query params\" do\n      get \"/latest.rss?status=closed\"\n      expect(response.status).to eq(200)\n      expect(response.media_type).to eq(\"application/rss+xml\")\n      expect(response.body).to_not include(\"<item>\")\n    end\n\n    it \"renders links correctly with subfolder\" do\n      set_subfolder \"/forum\"\n      _post = Fabricate(:post, topic: topic, user: user)\n      get \"/latest.rss\"\n      expect(response.status).to eq(200)\n      expect(response.body).to_not include(\"/forum/forum\")\n      expect(response.body).to include(\"http://test.localhost/forum/t/#{topic.slug}\")\n    end\n\n    it \"renders top RSS\" do\n      get \"/top.rss\"\n      expect(response.status).to eq(200)\n      expect(response.media_type).to eq(\"application/rss+xml\")\n    end\n\n    it \"errors for invalid periods on top RSS\" do\n      get \"/top.rss?period=decadely\"\n      expect(response.status).to eq(400)\n    end\n\n    TopTopic.periods.each do |period|\n      it \"renders #{period} top RSS\" do\n        get \"/top.rss?period=#{period}\"\n        expect(response.status).to eq(200)\n        expect(response.media_type).to eq(\"application/rss+xml\")\n      end\n    end\n  end\n\n  describe \"Top\" do\n    it \"renders top\" do\n      get \"/top\"\n      expect(response.status).to eq(200)\n    end\n\n    it \"renders top with a period\" do\n      get \"/top?period=weekly\"\n      expect(response.status).to eq(200)\n    end\n\n    it \"errors for invalid periods on top\" do\n      get \"/top?period=decadely\"\n      expect(response.status).to eq(400)\n    end\n  end\n\n  describe \"category\" do\n    context \"when in a category\" do\n      let(:category) { Fabricate(:category_with_definition) }\n      let(:group) { Fabricate(:group) }\n      let(:private_category) { Fabricate(:private_category, group: group) }\n\n      context \"without access to see the category\" do\n        it \"responds with a 404 error\" do\n          get \"/c/#{private_category.slug}/l/latest\"\n          expect(response.status).to eq(404)\n        end\n      end\n\n      context \"with access to see the category\" do\n        it \"succeeds\" do\n          get \"/c/#{category.slug}/#{category.id}/l/latest\"\n          expect(response.status).to eq(200)\n        end\n      end\n\n      context \"with encoded slug in the category\" do\n        let(:category) { Fabricate(:category, slug: \"\u0ba4\u0bae\u0bbf\u0bb4\u0bcd\") }\n\n        before { SiteSetting.slug_generation_method = \"encoded\" }\n\n        it \"succeeds\" do\n          get \"/c/#{category.slug}/#{category.id}/l/latest\"\n          expect(response.status).to eq(200)\n        end\n      end\n\n      context \"with a link that has a parent slug, slug and id in its path\" do\n        let(:child_category) { Fabricate(:category_with_definition, parent_category: category) }\n\n        context \"with valid slug\" do\n          it \"succeeds\" do\n            get \"/c/#{category.slug}/#{child_category.slug}/#{child_category.id}/l/latest\"\n            expect(response.status).to eq(200)\n          end\n        end\n\n        context \"with invalid slug\" do\n          it \"redirects\" do\n            get \"/c/random_slug/another_random_slug/#{child_category.id}/l/latest\"\n            expect(response).to redirect_to(\"#{child_category.url}/l/latest\")\n          end\n        end\n      end\n\n      context \"when another category exists with a number at the beginning of its name\" do\n        # One category has another category's id at the beginning of its name\n        let!(:other_category) do\n          # Our validations don't allow this to happen now, but did historically\n          Fabricate(\n            :category_with_definition,\n            name: \"#{category.id} name\",\n            slug: \"will-be-changed\",\n          ).tap { |category| category.update_column(:slug, \"#{category.id}-name\") }\n        end\n\n        it \"uses the correct category\" do\n          get \"/c/#{other_category.slug}/#{other_category.id}/l/latest.json\"\n          expect(response.status).to eq(200)\n          body = response.parsed_body\n          expect(body[\"topic_list\"][\"topics\"].first[\"category_id\"]).to eq(other_category.id)\n        end\n      end\n\n      context \"with a child category\" do\n        let(:sub_category) { Fabricate(:category_with_definition, parent_category_id: category.id) }\n\n        context \"when parent and child are requested\" do\n          it \"succeeds\" do\n            get \"/c/#{category.slug}/#{sub_category.slug}/#{sub_category.id}/l/latest\"\n            expect(response.status).to eq(200)\n          end\n        end\n\n        context \"when child is requested with the wrong parent\" do\n          it \"responds with a 404 error\" do\n            get \"/c/not-the-right-slug/#{sub_category.slug}/l/latest\"\n            expect(response.status).to eq(404)\n          end\n        end\n      end\n\n      describe \"feed\" do\n        it \"renders RSS\" do\n          get \"/c/#{category.slug}/#{category.id}.rss\"\n          expect(response.status).to eq(200)\n          expect(response.media_type).to eq(\"application/rss+xml\")\n        end\n\n        it \"renders RSS in subfolder correctly\" do\n          set_subfolder \"/forum\"\n          get \"/c/#{category.slug}/#{category.id}.rss\"\n          expect(response.status).to eq(200)\n          expect(response.body).to_not include(\"/forum/forum\")\n          expect(response.body).to include(\"http://test.localhost/forum/c/#{category.slug}\")\n        end\n      end\n\n      describe \"category default views\" do\n        it \"has a top default view\" do\n          category.update!(default_view: \"top\", default_top_period: \"monthly\")\n          get \"/c/#{category.slug}/#{category.id}.json\"\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json[\"topic_list\"][\"for_period\"]).to eq(\"monthly\")\n        end\n\n        it \"has a default view of nil\" do\n          category.update!(default_view: nil)\n          get \"/c/#{category.slug}/#{category.id}.json\"\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json[\"topic_list\"][\"for_period\"]).to be_blank\n        end\n\n        it \"has a default view of ''\" do\n          category.update!(default_view: \"\")\n          get \"/c/#{category.slug}/#{category.id}.json\"\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json[\"topic_list\"][\"for_period\"]).to be_blank\n        end\n\n        it \"has a default view of latest\" do\n          category.update!(default_view: \"latest\")\n          get \"/c/#{category.slug}/#{category.id}.json\"\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json[\"topic_list\"][\"for_period\"]).to be_blank\n        end\n      end\n\n      describe \"renders canonical tag\" do\n        it \"for category default view\" do\n          get \"/c/#{category.slug}/#{category.id}\"\n          expect(response.status).to eq(200)\n          expect(css_select(\"link[rel=canonical]\").length).to eq(1)\n        end\n\n        it \"for category latest view\" do\n          get \"/c/#{category.slug}/#{category.id}/l/latest\"\n          expect(response.status).to eq(200)\n          expect(css_select(\"link[rel=canonical]\").length).to eq(1)\n        end\n      end\n\n      context \"for category default view\" do\n        let!(:amazing_category) { Fabricate(:category_with_definition, name: \"Amazing Category\") }\n\n        it \"renders correct title\" do\n          get \"/c/#{amazing_category.slug}/#{amazing_category.id}\"\n\n          expect(response.body).to have_tag \"title\", text: \"Amazing Category - Discourse\"\n        end\n      end\n\n      context \"for category latest view\" do\n        let!(:amazing_category) { Fabricate(:category_with_definition, name: \"Amazing Category\") }\n\n        it \"renders correct title\" do\n          SiteSetting.short_site_description = \"Best community\"\n          get \"/c/#{amazing_category.slug}/#{amazing_category.id}/l/latest\"\n\n          expect(response.body).to have_tag \"title\", text: \"Amazing Category - Discourse\"\n        end\n      end\n    end\n  end\n\n  describe \"topics_by\" do\n    fab!(:topic2) { Fabricate(:topic, user: user) }\n    fab!(:user2) { Fabricate(:user) }\n\n    before { sign_in(user2) }\n\n    it \"should respond with a list\" do\n      get \"/topics/created-by/#{user.username}.json\"\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"topic_list\"][\"topics\"].size).to eq(2)\n    end\n\n    it \"should work with period in username\" do\n      user.update!(username: \"myname.test\")\n      get \"/topics/created-by/#{user.username}\", xhr: true\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"topic_list\"][\"topics\"].size).to eq(2)\n    end\n\n    context \"with unicode usernames\" do\n      before { SiteSetting.unicode_usernames = true }\n\n      it \"should return the more_topics_url in the encoded form\" do\n        stub_const(TopicQuery, \"DEFAULT_PER_PAGE_COUNT\", 1) do\n          user.update!(username: \"\u5feb\u5feb\u5feb\")\n\n          get \"/topics/created-by/#{UrlHelper.encode(user.username)}.json\"\n\n          expect(response.status).to eq(200)\n\n          json = response.parsed_body\n\n          expect(json[\"topic_list\"][\"more_topics_url\"]).to eq(\n            \"/topics/created-by/%E5%BF%AB%E5%BF%AB%E5%BF%AB?page=1\",\n          )\n        end\n      end\n    end\n\n    context \"when `hide_profile_and_presence` is true\" do\n      before { user.user_option.update_columns(hide_profile_and_presence: true) }\n\n      it \"returns 404\" do\n        get \"/topics/created-by/#{user.username}.json\"\n        expect(response.status).to eq(404)\n      end\n\n      it \"should respond with a list when `allow_users_to_hide_profile` is false\" do\n        SiteSetting.allow_users_to_hide_profile = false\n        get \"/topics/created-by/#{user.username}.json\"\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"topic_list\"][\"topics\"].size).to eq(2)\n      end\n    end\n  end\n\n  describe \"private_messages\" do\n    it \"returns 403 error when the user can't see private message\" do\n      sign_in(Fabricate(:user))\n      get \"/topics/private-messages/#{user.username}.json\"\n      expect(response).to be_forbidden\n    end\n\n    it \"succeeds when the user can see private messages\" do\n      pm = Fabricate(:private_message_topic, user: Fabricate(:user))\n      pm.topic_allowed_users.create!(user: user)\n      sign_in(user)\n      get \"/topics/private-messages/#{user.username}.json\"\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"topic_list\"][\"topics\"].size).to eq(1)\n    end\n  end\n\n  describe \"private_messages_sent\" do\n    before do\n      pm = Fabricate(:private_message_topic, user: user)\n      Fabricate(:post, user: user, topic: pm, post_number: 1)\n    end\n\n    it \"returns 403 error when the user can't see private message\" do\n      sign_in(Fabricate(:user))\n      get \"/topics/private-messages-sent/#{user.username}.json\"\n      expect(response).to be_forbidden\n    end\n\n    it \"succeeds when the user can see private messages\" do\n      sign_in(user)\n      get \"/topics/private-messages-sent/#{user.username}.json\"\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"topic_list\"][\"topics\"].size).to eq(1)\n    end\n  end\n\n  describe \"#private_messages_unread\" do\n    fab!(:pm_user) { Fabricate(:user) }\n\n    fab!(:pm) do\n      Fabricate(:private_message_topic).tap do |t|\n        t.allowed_users << pm_user\n        create_post(user: pm_user, topic_id: t.id)\n      end\n    end\n\n    it \"returns 404 when the user can't see private message\" do\n      sign_in(Fabricate(:user))\n      get \"/topics/private-messages-unread/#{pm_user.username}.json\"\n      expect(response.status).to eq(404)\n    end\n\n    it \"succeeds when the user can see private messages\" do\n      TopicUser.find_by(topic: pm, user: pm_user).update!(\n        notification_level: TopicUser.notification_levels[:tracking],\n        last_read_post_number: 0,\n      )\n\n      sign_in(pm_user)\n      get \"/topics/private-messages-unread/#{pm_user.username}.json\"\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"topic_list\"][\"topics\"].size).to eq(1)\n      expect(json[\"topic_list\"][\"topics\"][0][\"id\"]).to eq(pm.id)\n    end\n  end\n\n  describe \"#private_messages_warnings\" do\n    fab!(:target_user) { Fabricate(:user) }\n    fab!(:admin) { Fabricate(:admin) }\n    fab!(:moderator1) { Fabricate(:moderator) }\n    fab!(:moderator2) { Fabricate(:moderator) }\n\n    let(:create_args) do\n      {\n        title: \"you need a warning buddy!\",\n        raw: \"you did something bad and I'm telling you about it!\",\n        is_warning: true,\n        target_usernames: target_user.username,\n        archetype: Archetype.private_message,\n      }\n    end\n\n    let(:warning_post) do\n      creator = PostCreator.new(moderator1, create_args)\n      creator.create\n    end\n    let(:warning_topic) { warning_post.topic }\n\n    before { warning_topic }\n\n    it \"returns 403 error for unrelated users\" do\n      sign_in(Fabricate(:user))\n      get \"/topics/private-messages-warnings/#{target_user.username}.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it \"shows the warning to moderators and admins\" do\n      [moderator1, moderator2, admin].each do |viewer|\n        sign_in(viewer)\n        get \"/topics/private-messages-warnings/#{target_user.username}.json\"\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"topic_list\"][\"topics\"].size).to eq(1)\n        expect(json[\"topic_list\"][\"topics\"][0][\"id\"]).to eq(warning_topic.id)\n      end\n    end\n\n    it \"does not show the warning as applying to the authoring moderator\" do\n      sign_in(admin)\n      get \"/topics/private-messages-warnings/#{moderator1.username}.json\"\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"topic_list\"][\"topics\"].size).to eq(0)\n    end\n  end\n\n  describe \"read\" do\n    it \"raises an error when not logged in\" do\n      get \"/read\"\n      expect(response.status).to eq(404)\n    end\n\n    context \"when logged in\" do\n      it \"succeeds\" do\n        sign_in(user)\n        get \"/read\"\n        expect(response.status).to eq(200)\n      end\n    end\n  end\n\n  describe \"best_periods_for\" do\n    it \"works\" do\n      expect(ListController.best_periods_for(nil)).to eq([:all])\n      expect(ListController.best_periods_for(5.years.ago)).to eq([:all])\n      expect(ListController.best_periods_for(2.years.ago)).to eq(%i[yearly all])\n      expect(ListController.best_periods_for(6.months.ago)).to eq(%i[quarterly yearly all])\n      expect(ListController.best_periods_for(2.months.ago)).to eq(%i[monthly quarterly yearly all])\n      expect(ListController.best_periods_for(2.weeks.ago)).to eq(\n        %i[weekly monthly quarterly yearly all],\n      )\n      expect(ListController.best_periods_for(2.days.ago)).to eq(\n        %i[daily weekly monthly quarterly yearly all],\n      )\n    end\n\n    it \"supports default period\" do\n      expect(ListController.best_periods_for(nil, :yearly)).to eq(%i[yearly all])\n      expect(ListController.best_periods_for(nil, :quarterly)).to eq(%i[quarterly all])\n      expect(ListController.best_periods_for(nil, :monthly)).to eq(%i[monthly all])\n      expect(ListController.best_periods_for(nil, :weekly)).to eq(%i[weekly all])\n      expect(ListController.best_periods_for(nil, :daily)).to eq(%i[daily all])\n    end\n  end\n\n  describe \"user_topics_feed\" do\n    it \"returns 404 if `hide_profile_and_presence` user option is checked\" do\n      user.user_option.update_columns(hide_profile_and_presence: true)\n      get \"/u/#{user.username}/activity/topics.rss\"\n      expect(response.status).to eq(404)\n    end\n  end\n\n  describe \"set_category\" do\n    let(:category) { Fabricate(:category_with_definition) }\n    let(:subcategory) { Fabricate(:category_with_definition, parent_category_id: category.id) }\n    let(:subsubcategory) do\n      Fabricate(:category_with_definition, parent_category_id: subcategory.id)\n    end\n\n    before { SiteSetting.max_category_nesting = 3 }\n\n    it \"redirects to URL with the updated slug\" do\n      get \"/c/hello/world/bye/#{subsubcategory.id}\"\n      expect(response.status).to eq(301)\n      expect(response).to redirect_to(\n        \"/c/#{category.slug}/#{subcategory.slug}/#{subsubcategory.slug}/#{subsubcategory.id}\",\n      )\n\n      get \"/c/#{category.slug}/#{subcategory.slug}/#{subsubcategory.slug}/#{subsubcategory.id}\"\n      expect(response.status).to eq(200)\n    end\n\n    it \"redirects to URL with correct case slug\" do\n      category.update!(slug: \"hello\")\n\n      get \"/c/Hello/#{category.id}\"\n      expect(response).to redirect_to(\"/c/hello/#{category.id}\")\n\n      get \"/c/hello/#{category.id}\"\n      expect(response.status).to eq(200)\n    end\n\n    context \"with encoded slugs\" do\n      it \"does not create a redirect loop\" do\n        category = Fabricate(:category)\n        category.update_columns(slug: CGI.escape(\"syst\u00e8mes\"))\n\n        get \"/c/syst%C3%A8mes/#{category.id}\"\n        expect(response.status).to eq(200)\n      end\n    end\n\n    context \"with lowercase encoded slugs\" do\n      it \"does not create a redirect loop\" do\n        category = Fabricate(:category)\n        category.update_columns(slug: CGI.escape(\"syst\u00e8mes\").downcase)\n\n        get \"/c/syst%C3%A8mes/#{category.id}\"\n        expect(response.status).to eq(200)\n      end\n    end\n\n    context \"with subfolder\" do\n      it \"main category redirects to URL containing the updated slug\" do\n        set_subfolder \"/forum\"\n        get \"/c/#{category.slug}\"\n\n        expect(response.status).to eq(301)\n        expect(response).to redirect_to(\"/forum/c/#{category.slug}/#{category.id}\")\n      end\n\n      it \"sub-sub-category redirects to URL containing the updated slug\" do\n        set_subfolder \"/forum\"\n        get \"/c/hello/world/bye/#{subsubcategory.id}\"\n\n        expect(response.status).to eq(301)\n        expect(response).to redirect_to(\n          \"/forum/c/#{category.slug}/#{subcategory.slug}/#{subsubcategory.slug}/#{subsubcategory.id}\",\n        )\n      end\n    end\n  end\n\n  describe \"shared drafts\" do\n    fab!(:category1) { Fabricate(:category) }\n    fab!(:category2) { Fabricate(:category) }\n\n    fab!(:topic1) { Fabricate(:topic, category: category1) }\n    fab!(:topic2) { Fabricate(:topic, category: category2) }\n\n    fab!(:shared_draft_topic) { Fabricate(:topic, category: category1) }\n    fab!(:shared_draft) { Fabricate(:shared_draft, topic: shared_draft_topic, category: category2) }\n\n    it \"are not displayed if they are disabled\" do\n      SiteSetting.shared_drafts_category = \"\"\n      sign_in(admin)\n\n      get \"/c/#{category1.slug}/#{category1.id}.json\"\n      expect(response.parsed_body[\"topic_list\"][\"shared_drafts\"]).to eq(nil)\n      expect(response.parsed_body[\"topic_list\"][\"topics\"].map { |t| t[\"id\"] }).to contain_exactly(\n        topic1.id,\n        shared_draft_topic.id,\n      )\n    end\n\n    it \"are displayed in both shared drafts category and target category\" do\n      SiteSetting.shared_drafts_category = category1.id\n      sign_in(admin)\n\n      get \"/c/#{category1.slug}/#{category1.id}.json\"\n      expect(response.parsed_body[\"topic_list\"][\"shared_drafts\"]).to be_nil\n      expect(response.parsed_body[\"topic_list\"][\"topics\"].map { |t| t[\"id\"] }).to contain_exactly(\n        topic1.id,\n        shared_draft_topic.id,\n      )\n\n      get \"/c/#{category2.slug}/#{category2.id}.json\"\n      expect(\n        response.parsed_body[\"topic_list\"][\"shared_drafts\"].map { |t| t[\"id\"] },\n      ).to contain_exactly(shared_draft_topic.id)\n      expect(response.parsed_body[\"topic_list\"][\"topics\"].map { |t| t[\"id\"] }).to contain_exactly(\n        topic2.id,\n      )\n    end\n  end\n\n  describe \"body class\" do\n    it \"pre-renders the correct body class for categories\" do\n      c = Fabricate(:category, slug: \"myparentslug\")\n      sub_c = Fabricate(:category, parent_category: c, slug: \"mychildslug\")\n\n      get \"/c/#{c.slug}/#{sub_c.slug}/#{sub_c.id}\"\n\n      expect(response.body).to have_tag \"body\", with: { class: \"category-myparentslug-mychildslug\" }\n    end\n  end\n\n  describe \"#filter\" do\n    fab!(:category) { Fabricate(:category, slug: \"category-slug\") }\n    fab!(:tag) { Fabricate(:tag, name: \"tag1\") }\n    fab!(:group) { Fabricate(:group) }\n    fab!(:private_category) { Fabricate(:private_category, group:, slug: \"private-category-slug\") }\n    fab!(:private_message_topic) { Fabricate(:private_message_topic) }\n    fab!(:topic_in_private_category) { Fabricate(:topic, category: private_category) }\n\n    before { SiteSetting.experimental_topics_filter = true }\n\n    it \"should not return topics that the user is not allowed to view\" do\n      sign_in(user)\n\n      get \"/filter.json\"\n\n      expect(response.status).to eq(200)\n\n      expect(\n        response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] },\n      ).to contain_exactly(topic.id)\n    end\n\n    it \"should respond with 403 response code for an anonymous user\" do\n      get \"/filter.json\"\n\n      expect(response.status).to eq(403)\n    end\n\n    it \"should respond with 404 response code when `experimental_topics_filter` site setting has not been enabled\" do\n      SiteSetting.experimental_topics_filter = false\n\n      sign_in(user)\n\n      get \"/filter.json\"\n\n      expect(response.status).to eq(404)\n    end\n\n    it \"returns category definition topics if `show_category_definitions_in_topic_lists` site setting is enabled\" do\n      category_topic = Fabricate(:topic, category: category)\n      category.update!(topic: category_topic)\n\n      SiteSetting.show_category_definitions_in_topic_lists = true\n\n      sign_in(user)\n\n      get \"/filter.json\"\n\n      expect(response.status).to eq(200)\n\n      expect(\n        response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] },\n      ).to contain_exactly(topic.id, category_topic.id)\n    end\n\n    it \"does not return category definition topics if `show_category_definitions_in_topic_lists` site setting is disabled\" do\n      category_topic = Fabricate(:topic, category: category)\n      category.update!(topic: category_topic)\n\n      SiteSetting.show_category_definitions_in_topic_lists = false\n\n      sign_in(user)\n\n      get \"/filter.json\"\n\n      expect(response.status).to eq(200)\n\n      expect(\n        response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] },\n      ).to contain_exactly(topic.id)\n    end\n\n    it \"should accept the `page` query parameter\" do\n      topic_with_tag = Fabricate(:topic, tags: [tag])\n      topic2_with_tag = Fabricate(:topic, tags: [tag])\n\n      stub_const(TopicQuery, \"DEFAULT_PER_PAGE_COUNT\", 1) do\n        sign_in(user)\n\n        get \"/filter.json\", params: { q: \"tags:tag1\" }\n\n        expect(response.status).to eq(200)\n\n        parsed = response.parsed_body\n\n        expect(parsed[\"topic_list\"][\"topics\"].length).to eq(1)\n        expect(parsed[\"topic_list\"][\"topics\"].first[\"id\"]).to eq(topic2_with_tag.id)\n\n        get \"/filter.json\", params: { q: \"tags:tag1\", page: 1 }\n\n        expect(response.status).to eq(200)\n\n        parsed = response.parsed_body\n\n        expect(parsed[\"topic_list\"][\"topics\"].length).to eq(1)\n        expect(parsed[\"topic_list\"][\"topics\"].first[\"id\"]).to eq(topic_with_tag.id)\n      end\n    end\n\n    describe \"when filtering with the `created-by:<username>` filter\" do\n      fab!(:topic2) { Fabricate(:topic, user: admin) }\n\n      before do\n        topic.update!(user: user)\n        user.update!(username: \"username\")\n        admin.update!(username: \"username2\")\n      end\n\n      it \"returns only topics created by the user when `q` query param is `created-by:username`\" do\n        sign_in(user)\n\n        get \"/filter.json\", params: { q: \"created-by:username\" }\n\n        expect(response.status).to eq(200)\n\n        expect(\n          response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] },\n        ).to contain_exactly(topic.id)\n      end\n\n      it \"returns only topics created by either user when `q` query param is `created-by:username,username2`\" do\n        sign_in(user)\n\n        get \"/filter.json\", params: { q: \"created-by:username,username2\" }\n\n        expect(response.status).to eq(200)\n\n        expect(\n          response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] },\n        ).to contain_exactly(topic.id, topic2.id)\n      end\n    end\n\n    describe \"when filtering with the `category:<category_slug>` filter\" do\n      fab!(:topic_in_category) { Fabricate(:topic, category:) }\n\n      it \"does not return any topics when `q` query param is `category:private-category-slug` and user is not allowed to see category\" do\n        sign_in(user)\n\n        get \"/filter.json\", params: { q: \"category:private-category-slug\" }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] }).to eq([])\n      end\n\n      it \"returns only topics in the category when `q` query param is `category:private-category-slug` and user can see category\" do\n        group.add(user)\n\n        sign_in(user)\n\n        get \"/filter.json\", params: { q: \"category:private-category-slug\" }\n\n        expect(response.status).to eq(200)\n\n        expect(\n          response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] },\n        ).to contain_exactly(topic_in_private_category.id)\n      end\n    end\n\n    describe \"when filtering with the `in:<topic_notification_level>` filter\" do\n      fab!(:user_muted_topic) do\n        Fabricate(:topic).tap do |topic|\n          TopicUser.change(\n            user.id,\n            topic.id,\n            notification_level: TopicUser.notification_levels[:muted],\n          )\n        end\n      end\n\n      fab!(:user_tracking_topic) do\n        Fabricate(:topic).tap do |topic|\n          TopicUser.change(\n            user.id,\n            topic.id,\n            notification_level: TopicUser.notification_levels[:tracking],\n          )\n        end\n      end\n\n      it \"does not return topics that are muted by the user when `q` query param does not include `in:muted`\" do\n        sign_in(user)\n\n        get \"/filter.json\", params: { q: \"in:tracking\" }\n\n        expect(response.status).to eq(200)\n\n        expect(response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] }).to eq(\n          [user_tracking_topic.id],\n        )\n      end\n\n      it \"only return topics that are muted by the user when `q` query param is `in:muted`\" do\n        sign_in(user)\n\n        get \"/filter.json\", params: { q: \"in:muted\" }\n\n        expect(response.status).to eq(200)\n\n        expect(response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] }).to eq(\n          [user_muted_topic.id],\n        )\n      end\n    end\n\n    describe \"when ordering using the `order:` filter\" do\n      fab!(:topic2) { Fabricate(:topic, views: 2) }\n      fab!(:topic3) { Fabricate(:topic, views: 3) }\n      fab!(:topic4) { Fabricate(:topic, views: 1) }\n\n      it \"return topics ordered by topic bumped at date in descending order when `q` query param is not present\" do\n        sign_in(user)\n\n        get \"/filter.json\"\n\n        expect(response.status).to eq(200)\n\n        expect(response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] }).to eq(\n          [topic4.id, topic3.id, topic2.id, topic.id],\n        )\n      end\n\n      it \"return topics ordered by views when `q` query param is `order:views`\" do\n        sign_in(user)\n\n        get \"/filter.json\", params: { q: \"order:views\" }\n\n        expect(response.status).to eq(200)\n\n        expect(response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] }).to eq(\n          [topic3.id, topic2.id, topic4.id, topic.id],\n        )\n      end\n    end\n\n    describe \"when filtering by status\" do\n      fab!(:group) { Fabricate(:group) }\n      fab!(:private_category) { Fabricate(:private_category, group: group) }\n      fab!(:topic_in_private_category) { Fabricate(:topic, category: private_category) }\n\n      it \"does not return topics that are unlisted when `q` query param is `status:unlisted` for a user that cannot view unlisted topics\" do\n        Topic.update_all(deleted_at: true)\n        topic.update!(visible: false)\n\n        sign_in(user)\n\n        get \"/filter.json\", params: { q: \"status:unlisted\" }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] }).to eq([])\n      end\n\n      it \"returns topics that are unlisted when `q` query param is `status:unlisted` for a user that can view unlisted topics\" do\n        Topic.update_all(visible: true)\n        topic.update!(visible: false)\n\n        sign_in(admin)\n\n        get \"/filter.json\", params: { q: \"status:unlisted\" }\n\n        expect(response.status).to eq(200)\n\n        expect(\n          response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] },\n        ).to contain_exactly(topic.id)\n      end\n\n      it \"ignores the `status` filter for a user that cannot view deleted topics when `q` query param is `status:deleted`\" do\n        Topic.update_all(deleted_at: nil)\n        topic.update!(deleted_at: Time.zone.now)\n\n        sign_in(user)\n\n        get \"/filter.json\", params: { q: \"status:deleted\" }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] }).to eq([])\n      end\n\n      it \"returns topics that are deleted when `q` query param is `status:deleted` for a user that can view deleted topics\" do\n        Topic.update_all(deleted_at: nil)\n        topic.update!(deleted_at: Time.zone.now)\n\n        sign_in(admin)\n\n        get \"/filter.json\", params: { q: \"status:deleted\" }\n\n        expect(response.status).to eq(200)\n\n        expect(\n          response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] },\n        ).to contain_exactly(topic.id)\n      end\n\n      it \"does not return topics from read restricted categories when `q` query param is `status:public`\" do\n        group.add(user)\n\n        sign_in(user)\n\n        get \"/filter.json\", params: { q: \"status:public\" }\n\n        expect(response.status).to eq(200)\n\n        expect(\n          response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] },\n        ).to contain_exactly(topic.id)\n      end\n    end\n  end\nend\n"], "filenames": ["app/models/topic.rb", "app/serializers/concerns/topic_tags_mixin.rb", "app/views/list/list.erb", "spec/requests/list_controller_spec.rb"], "buggy_code_start_loc": [2045, 28, 73, 196], "buggy_code_end_loc": [2045, 40, 78, 196], "fixing_code_start_loc": [2046, 29, 73, 197], "fixing_code_end_loc": [2050, 43, 78, 219], "type": "NVD-CWE-noinfo", "message": "Discourse is an open source discussion platform. Prior to version 3.0.6 of the `stable` branch and version 3.1.0.beta7 of the `beta` and `tests-passed` branches, information about restricted-visibility topic tags could be obtained by unauthorized users. The issue is patched in version 3.0.6 of the `stable` branch and version 3.1.0.beta7 of the `beta` and `tests-passed` branches.", "other": {"cve": {"id": "CVE-2023-38685", "sourceIdentifier": "security-advisories@github.com", "published": "2023-07-28T16:15:12.613", "lastModified": "2023-08-03T17:35:33.533", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse is an open source discussion platform. Prior to version 3.0.6 of the `stable` branch and version 3.1.0.beta7 of the `beta` and `tests-passed` branches, information about restricted-visibility topic tags could be obtained by unauthorized users. The issue is patched in version 3.0.6 of the `stable` branch and version 3.1.0.beta7 of the `beta` and `tests-passed` branches."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:stable:*:*:*", "versionEndExcluding": "3.0.6", "matchCriteriaId": "8706E13A-141F-4E47-AA17-8DA913CE2020"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "BF272688-1B08-4ABC-8002-66B59690F9A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "A29A2465-B21D-4147-8292-DCF864D385B4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "BBC3511E-3D68-42E2-B521-966FB429B640"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "EC8B99C2-E267-4EC2-AF09-C9AD1EEE76D9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "F21A22EE-081A-4489-A7F8-22E2DBC5B00E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "6E6C8FB3-4B19-4510-B9A8-BCF9ED8ED7C9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta6b:*:*:beta:*:*:*", "matchCriteriaId": "5B827291-6483-4BB7-AF76-530B669B3ED5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "551E70ED-34FF-4989-91C9-6312DE4AB4DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "204FB99A-8F11-4F04-9ED9-D94551790116"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "46A8705C-0DF6-45D7-A38C-D2AB69194C59"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "F59B0D8E-CFFB-4EBA-9D6A-526F9541BA17"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "D801A898-27D0-4076-8AF9-2B574FA11723"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "E7CBBD4A-4FDB-49E0-A5B6-22701C12BDF2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "9E7328DF-1924-4D0D-AC6B-1BA2D9CF1D4D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "9421CE10-F226-4F2C-9DA7-EBB44B73C304"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "1E71FBB6-ECAD-4581-9982-4C330D55FEAF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "1B631CCC-D456-49FF-B626-59C40BD4E167"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "BE83F98D-F7AA-434B-8438-5B1FB96681B9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "EB93F19B-9087-44CE-B884-45F434B7906F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "5A88A5A3-EF1A-4E86-B074-CE0AC4325484"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "0650B4C7-BCFE-4180-8FEF-4170A67E8BD3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "388F376E-46C9-4163-992D-95E3E4548D0F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "D661090A-DA61-4BBE-85C3-6F48C053C84B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "4A458242-D6DD-46E3-AF09-66BC87C5D7A6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "A8FACCBA-0D3B-4E6F-85A0-1CBD2B367F71"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "F1D83D80-A0BE-4794-91A1-599AF558FB67"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "BD15B6B2-BFB3-4271-A507-48E9B827FA02"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "E0003042-9B14-4E1B-800F-3D154FFE8A1A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "E449EA29-81C8-4477-977E-746EACDBED86"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "6FC6D4DF-8686-4054-A0C1-784E194171E6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "C574C37D-3D99-4430-A3D5-199883556B64"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "F344E950-EFF9-4405-99D7-0B615C32873F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta12:*:*:beta:*:*:*", "matchCriteriaId": "0A50DE1B-29EB-4014-B5B6-46CF493485F2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "638B3E17-9F0A-4A96-B8D3-DDFEA518DBE9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "6D3E3AEB-8CD4-4EE7-9C81-2F74512071DD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "254FF9D9-E696-41C8-B15B-DA089D2C6597"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "2A5001E1-E716-43AA-8093-E0EED9E07909"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "7FD16B13-516A-4D03-B1EF-A11156471A06"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "E886D9EF-7FBD-4A24-A8B6-54E4B15403C6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "369A83D1-AB7E-488D-9D74-26A69DFC1AD9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "3189CAC1-8970-4A33-B1E4-EB9EC3C19A25"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "A8733438-7625-400E-8237-BAE3D9F147AB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "E87F1ED0-FD0D-4767-8E7C-325D920B79BD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "97811266-A13C-4441-A1B5-BFA4B0862DFE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta12:*:*:beta:*:*:*", "matchCriteriaId": "3D09D157-4B19-4561-AB20-952F2EA9BA0C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta13:*:*:beta:*:*:*", "matchCriteriaId": "789087AF-0011-4E8F-A5AB-432A5F91BBA8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta13b:*:*:beta:*:*:*", "matchCriteriaId": "8EC9DC8C-56DC-482B-8847-BD0CFACA6F8D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta14:*:*:beta:*:*:*", "matchCriteriaId": "F63B3D13-24F6-4EFA-9528-DBF59D973A9A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "7F3A2388-18DE-46B0-BC13-7714E25D1B1C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "940B11CB-053F-4D60-8BC4-81CA659D2F7B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "83684DCB-B201-43B8-8B6E-6D0B13B7E437"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "DF92E1FD-9B41-4A41-8B13-9D789C5729D6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "351D224A-E67C-454C-AF43-8AD6CD44C685"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "E058CA6D-A295-4CAD-8C85-E8C83BAFEBD2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "FF99C114-1BCA-4400-BC7E-EDA1F55559CE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "BBA1EFBA-5A26-46A0-B2A6-53B9924253BF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "FE5B90B0-B6CC-4189-9C98-CF29017A47B5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "A1818628-5F4E-4E5D-974A-0BEBCE821209"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "14785840-3BC0-4030-AE44-E3013DF19AD7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta12:*:*:beta:*:*:*", "matchCriteriaId": "90444209-684C-4BF8-9BCF-6B29EA0A0593"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "668E15DE-8CF2-4AF3-B13A-9080046B1E03"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "1191861C-1B2C-4762-805D-FCDC20F84D05"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "3CB518E5-CCC0-46B8-848E-C492BCF7E9BB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "CA1F68FE-67EA-4408-8E0F-558B0FAFFF32"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "66E9F05C-799A-43D3-9367-FCA86166BD65"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "85DB4097-6EFC-4017-ADFD-56EE49BB2F34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "AD283EA2-9026-497F-A7DE-E16CE0764ED0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "ED19DDDF-A29E-4C3F-A818-23D7E37B6974"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "508D0052-B7D7-4A08-8BB0-7D7A1EDAB96D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "3E50BFB0-67D3-4EDE-93FE-85EAF605461E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "D7EE0134-6AD7-4695-B536-1959FE3A9672"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "25DFFB5C-277F-4436-9BCE-643E98721C5A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "B8B80EB2-0B48-4AFA-8A09-26006CCDB022"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "AC8705E0-23ED-4817-8B69-21A4963C27F8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "BAA156A9-A9FB-4D03-B0EE-4AA303D7A9CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "F733E585-075C-402A-9B34-1FE79DE4137E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "05C43439-C694-47AA-90AF-0AC2277E3D3B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "B391F8A1-F102-4C88-864C-1386452CDAB0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "0BC33C93-9947-4983-96A3-7DE223929817"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "B46DE141-1224-499E-AAE0-6CC0D5249B2C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "D8D07501-A07E-4743-A188-2E5BBC3C8F97"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "64FD2A30-EE33-4680-9DCF-29283DBA3C4F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta12:*:*:beta:*:*:*", "matchCriteriaId": "B517F7A2-6FD1-4A7B-80E7-1167EC296591"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta13:*:*:beta:*:*:*", "matchCriteriaId": "E6CA6EA5-DDAD-4882-AD1B-634C0CD741BE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "F14DCB07-9464-4DDE-98A1-FAE85DD60FBC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "6EDFD679-4710-4A62-B254-E658EED4295B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "A1B81072-08A5-4EC6-B737-E35C505C1E47"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "A0748A9E-5737-48F9-BB66-6576AFE16198"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "453E51D9-89A1-4A91-B218-05C45CC4E329"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "51542BA7-8151-4FC9-9C86-36CEB476B912"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "5F95391C-0B75-47D2-9770-561E05414CEF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "10384675-B949-4B50-AF42-B5A3EE27250B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "7C0DB1C0-5749-4508-A265-C2138F7852E9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "CA9977CF-575C-4A19-84C8-EBB68EBE88C9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "87C525C5-E282-4EC6-956F-0C94DC11FC69"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta12:*:*:beta:*:*:*", "matchCriteriaId": "7F02A2A8-6312-4F6D-ABBF-952CA4C5E02E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta13:*:*:beta:*:*:*", "matchCriteriaId": "DE54D1A3-FC2A-40DE-9177-50332208B0B2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta14:*:*:beta:*:*:*", "matchCriteriaId": "170AE3DA-92C1-4D1D-9CAC-543C01FFF479"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta15:*:*:beta:*:*:*", "matchCriteriaId": "2130C3C5-E4A5-41C3-89F0-C6FB4E47D096"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta16:*:*:beta:*:*:*", "matchCriteriaId": "74248527-B884-4134-95C8-DEAF3D774A9A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta17:*:*:beta:*:*:*", "matchCriteriaId": "01A8AF9C-8BF6-4ADC-A85A-A5C1F9FFB2C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "B4038D09-467C-4815-A429-F0E1E3E545E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "6F273237-7223-4047-83B7-16A49B7E554A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "CF26EE13-554C-4180-98A2-238D84E40927"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "12688C9C-291D-4BF2-93F9-09AA323C52A9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "A7F7A437-D538-4B44-AC41-C95641A11A35"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "9BB61DCF-52DB-498D-8779-D565E548C285"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "EE56BB77-B7F7-4BE7-AD9C-33888C5D01FE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "9DB49E1D-BCC8-4984-A81D-5DAC5E3DF168"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "F775EA72-CCE3-4230-A666-EFDAA61F71FE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "5E65BDEE-850A-41C6-8CFB-BD8B3A105CD1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "AF196429-FDED-4C3F-9F7D-0A2BF7DCAD1E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "64B84326-5397-4C60-8007-F7E7D81DC661"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "9A0A526A-9662-4E39-8BF6-E464BE1A2B6F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "712DACC2-A21E-429F-8A7B-86D8F7CE3468"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "6E93F9F6-5B03-4F77-B8B4-AEC9E4011692"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "C5B2B98E-804F-4525-B726-3F1DF2693F79"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "582E339F-678A-4377-8EE0-8F4208E3EF78"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "1BF1D945-6EAA-4FA7-8252-2FED079587F0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.1.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "9325DFF5-EA7B-4B8D-A227-4B1A59449CE1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.1.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "0ECB28DA-3CA1-4011-9170-BFBF2ED3E091"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.1.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "2A6399B0-471B-4B26-859C-3836F2A6B7D1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.1.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "131E2AE4-E35D-495D-8907-3B899BB8AC41"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.1.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "83601528-0DD9-4835-B6C0-0F341871CC15"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.1.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "4AEB5AAF-73EB-4356-8C53-10E22B2F910E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "9EB199D6-E253-4EC2-BF0B-059F7B6662ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "94A586EB-B0E0-4190-88DF-3BCC04E5EF84"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "0BF27B44-9AA7-4B91-9B4B-0E84418F5632"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "461744BD-3974-4C33-8514-0A917DC90C6C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "6A86FB2B-6915-49C0-B993-0711AAECA5FE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "9EF3DD36-2776-4CD2-A3F1-88872024D223"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "D91D71ED-F08F-4DB5-B7DD-062E7C11435F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "62B5812A-FB52-4F4B-9A15-3AA5CD6562E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "83231EC0-E3F7-4E35-B165-487C2725B4F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "A53AFFA6-7B98-47F2-9BD7-71C83A69CE26"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "A42D3FB9-9197-4101-A729-876C490BD572"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "A5DE0C47-0C66-4EFE-AF82-1B22F4F54A44"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "E587D10F-BEF8-4923-AF76-6DC3172880EE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "155568EF-6A7E-423A-B5EA-D20E407B271B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "7E94B119-8C75-43DF-A2DF-A5B3E04F0778"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "5348F94F-F6AE-4400-8AC7-036111EF43D9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "57948A73-C9C5-4C24-947D-0A4659C7002E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "3532EE37-2D0F-496C-B5A8-F9315FFB4552"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "2CAE7CC9-B91D-494C-B91A-497D6FE6B14B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "623BBBF8-4121-466A-82C8-D179B02B3E34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "648D010A-8B8D-42AA-8888-09E4E0FAA954"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "8ADC7613-25E3-4CB8-A962-2775C20E4D4F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "1B0099F0-A275-4C65-9B79-041374F183DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "FE69800E-5CB5-4916-879C-51DE5E94489F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "8C64EAFE-2B60-4D95-869F-4A2FC98B99C8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "AB2045F1-AC39-4738-B3F0-33F00D23C921"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "E32589F8-2E87-40D2-BAD3-E6C1C088CA60"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "4868BAFD-BFE5-4361-855A-644B040E7233"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "4B6C25BF-5B2A-43C4-8918-E32BA9DD8A22"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "EB9917D3-D848-4D2B-8A44-B3723BA377DA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "7046D95B-73CE-406B-ACC3-FD71F7DEC7CE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "D3BA5033-2C06-42FF-962E-48EBA2EBB469"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "630D29DE-0FD7-4306-BA80-20D0791D334B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "08F94E42-07A1-480D-B6DD-D96AE38F1EBA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "FA4B3DE5-21DA-4185-AF74-AAA6DD89FB3D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "E602BEF9-E89D-40F7-BC6F-5C6F9F25BA97"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "C06A8627-683D-4328-BE7A-4A33A4B736F2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "E3EF8240-D3F5-422C-B70A-90C6CBA4E622"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "93CC792D-AE0B-498E-8374-5D09EF4E28FF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.6.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "093D4EA8-B002-4AB4-97C9-CEE4D70BF3C8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.6.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "4C778180-E7BF-4EF2-8B19-0388E23E1424"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.6.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "0C0B2BC1-35F1-4A1D-B9B2-54426B4ADF34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.6.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "6BCAB620-465A-41FF-A064-FB638DD3A557"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.6.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "6AFCB802-A275-444C-8245-D0397322125F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.6.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "9F9B70E2-AAAD-4E61-AEB2-E5F635F6AAD5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "6182074E-C467-448C-9299-B92CFE4EEBE0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "09EA8F36-7647-42D0-8675-34C002E0754D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "9CE2276A-9680-4B14-9636-806F7E4C1669"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "AD150166-4C8D-47E3-989A-1A71A46C36A1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "CF5CA6AD-FA4D-47DF-A684-5DAD7662EA13"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "B94F75B8-7C84-4727-9D18-114A815E1906"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "4D94E03A-32EE-408F-81FA-4B9C25AA7DDF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "AD495875-007C-4A90-B940-B62E6FA492CC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "05F1B84E-8AF8-46E8-9DE9-00D1DE348C2C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "BCCEFDFB-61E6-4846-8093-B5CEB0D8450C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "0BC63647-B692-4BB9-9A3D-6F8DF19C3494"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "05F0ED55-C8C6-47C1-859A-60046838B6F7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "6A2D59BC-2EE8-4F9C-AB5B-B9D01B44F7CD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "933DFEBC-5568-431B-809D-AFAEFD08E985"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "BE920E80-C02B-4EC8-982F-ADE89C936684"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "CDAE3441-12BA-41F4-8A5A-B2EE844C86BF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "1443EA1B-D210-4219-8452-CBFD5FACBC77"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "948A4B4A-A11F-477E-BEC5-0D60C7E3570C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "98B2A052-5427-4B72-9F59-82F430836CB4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "CB6D636E-B51F-4648-A637-62B2603BA18F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "3DA17871-7ED7-4D68-A46D-D15DC5B3235F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "705FE965-0415-4382-8CA1-A19DF3B5EF35"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "BC6EDCE3-D564-434F-9A7F-D4A6D579F8F7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta12:*:*:beta:*:*:*", "matchCriteriaId": "FB05E54B-9CF6-45A7-8D47-C98DB6D19E7E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta13:*:*:beta:*:*:*", "matchCriteriaId": "03CD1C5E-18F5-4C6D-B92C-C511C8C12D0B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta14:*:*:beta:*:*:*", "matchCriteriaId": "FF4ABB9D-69DF-42D5-AD60-F9CEEC1B6730"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "7B4DCCF5-E290-4BDA-AAB9-DF362A2EB7B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "3AE1F3A2-8340-4ED7-B943-ACDA9617DF64"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "5E033AB7-9987-4C30-849F-2495376CA4F2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "D87E9338-C7F6-43BA-886F-C30987ADBA1D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "E24EB90F-FE81-4746-8741-8DC9346F79C1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "D237956F-FC90-467E-A493-24EFDA1A9F2D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "F7AA9AB8-AB6F-43E2-B3E5-685EE9BFE7D4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "5BC240A1-431E-4A50-88DC-7AC9BC674254"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.0.0:beta15:*:*:beta:*:*:*", "matchCriteriaId": "3F85AFD4-D397-4FDB-B762-521BD5FF14C1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.0.0:beta16:*:*:beta:*:*:*", "matchCriteriaId": "D40CDCE1-3462-4D6C-A3C7-487F175264CA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.1.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "B9BBED17-A6BA-4F17-8814-8D8521F28375"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.1.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "888B8ECF-EBE0-4821-82F6-B0026E95E407"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.1.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "FD0302B1-C0BA-49EE-8E1B-E8A43879BFC2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.1.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "9FE11D4E-32EE-48F4-8082-B37D2F804450"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.1.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "9D797DA5-1AE5-4D49-B133-AF45D7FB0A4A"}]}]}], "references": [{"url": "https://github.com/discourse/discourse/commit/073661142369a0a66c25775cc3870582a679ef8b", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/discourse/discourse/security/advisories/GHSA-wx6x-q4gp-mgv5", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse/commit/073661142369a0a66c25775cc3870582a679ef8b"}}