{"buggy_code": ["const http = require('http');\nconst express = require('express');\nconst req = require('../lib/request');\nconst fetch = require('node-fetch');\nconst FormData = require('form-data');\nconst ws = require('ws');\nrequire('./helper');\nconst { updateCLP } = require('./dev');\n\nconst pluralize = require('pluralize');\nconst { getMainDefinition } = require('apollo-utilities');\nconst { ApolloLink, split } = require('apollo-link');\nconst { createHttpLink } = require('apollo-link-http');\nconst { InMemoryCache } = require('apollo-cache-inmemory');\nconst { createUploadLink } = require('apollo-upload-client');\nconst { SubscriptionClient } = require('subscriptions-transport-ws');\nconst { WebSocketLink } = require('apollo-link-ws');\nconst ApolloClient = require('apollo-client').default;\nconst gql = require('graphql-tag');\nconst { toGlobalId } = require('graphql-relay');\nconst {\n  GraphQLObjectType,\n  GraphQLString,\n  GraphQLNonNull,\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLSchema,\n} = require('graphql');\nconst { ParseServer } = require('../');\nconst { ParseGraphQLServer } = require('../lib/GraphQL/ParseGraphQLServer');\nconst ReadPreference = require('mongodb').ReadPreference;\nconst { v4: uuidv4 } = require('uuid');\n\nfunction handleError(e) {\n  if (\n    e &&\n    e.networkError &&\n    e.networkError.result &&\n    e.networkError.result.errors\n  ) {\n    fail(e.networkError.result.errors);\n  } else {\n    fail(e);\n  }\n}\n\ndescribe('ParseGraphQLServer', () => {\n  let parseServer;\n  let parseGraphQLServer;\n\n  beforeAll(async () => {\n    parseServer = await global.reconfigureServer({});\n    parseGraphQLServer = new ParseGraphQLServer(parseServer, {\n      graphQLPath: '/graphql',\n      playgroundPath: '/playground',\n      subscriptionsPath: '/subscriptions',\n    });\n  });\n\n  describe('constructor', () => {\n    it('should require a parseServer instance', () => {\n      expect(() => new ParseGraphQLServer()).toThrow(\n        'You must provide a parseServer instance!'\n      );\n    });\n\n    it('should require config.graphQLPath', () => {\n      expect(() => new ParseGraphQLServer(parseServer)).toThrow(\n        'You must provide a config.graphQLPath!'\n      );\n      expect(() => new ParseGraphQLServer(parseServer, {})).toThrow(\n        'You must provide a config.graphQLPath!'\n      );\n    });\n\n    it('should only require parseServer and config.graphQLPath args', () => {\n      let parseGraphQLServer;\n      expect(() => {\n        parseGraphQLServer = new ParseGraphQLServer(parseServer, {\n          graphQLPath: 'graphql',\n        });\n      }).not.toThrow();\n      expect(parseGraphQLServer.parseGraphQLSchema).toBeDefined();\n      expect(parseGraphQLServer.parseGraphQLSchema.databaseController).toEqual(\n        parseServer.config.databaseController\n      );\n    });\n\n    it('should initialize parseGraphQLSchema with a log controller', async () => {\n      const loggerAdapter = {\n        log: () => {},\n        error: () => {},\n      };\n      const parseServer = await global.reconfigureServer({\n        loggerAdapter,\n      });\n      const parseGraphQLServer = new ParseGraphQLServer(parseServer, {\n        graphQLPath: 'graphql',\n      });\n      expect(parseGraphQLServer.parseGraphQLSchema.log.adapter).toBe(\n        loggerAdapter\n      );\n    });\n  });\n\n  describe('_getGraphQLOptions', () => {\n    const req = {\n      info: new Object(),\n      config: new Object(),\n      auth: new Object(),\n    };\n\n    it(\"should return schema and context with req's info, config and auth\", async () => {\n      const options = await parseGraphQLServer._getGraphQLOptions(req);\n      expect(options.schema).toEqual(\n        parseGraphQLServer.parseGraphQLSchema.graphQLSchema\n      );\n      expect(options.context.info).toEqual(req.info);\n      expect(options.context.config).toEqual(req.config);\n      expect(options.context.auth).toEqual(req.auth);\n    });\n\n    it('should load GraphQL schema in every call', async () => {\n      const originalLoad = parseGraphQLServer.parseGraphQLSchema.load;\n      let counter = 0;\n      parseGraphQLServer.parseGraphQLSchema.load = () => ++counter;\n      expect((await parseGraphQLServer._getGraphQLOptions(req)).schema).toEqual(\n        1\n      );\n      expect((await parseGraphQLServer._getGraphQLOptions(req)).schema).toEqual(\n        2\n      );\n      expect((await parseGraphQLServer._getGraphQLOptions(req)).schema).toEqual(\n        3\n      );\n      parseGraphQLServer.parseGraphQLSchema.load = originalLoad;\n    });\n  });\n\n  describe('_transformMaxUploadSizeToBytes', () => {\n    it('should transform to bytes', () => {\n      expect(parseGraphQLServer._transformMaxUploadSizeToBytes('20mb')).toBe(\n        20971520\n      );\n      expect(parseGraphQLServer._transformMaxUploadSizeToBytes('333Gb')).toBe(\n        357556027392\n      );\n      expect(\n        parseGraphQLServer._transformMaxUploadSizeToBytes('123456KB')\n      ).toBe(126418944);\n    });\n  });\n\n  describe('applyGraphQL', () => {\n    it('should require an Express.js app instance', () => {\n      expect(() => parseGraphQLServer.applyGraphQL()).toThrow(\n        'You must provide an Express.js app instance!'\n      );\n      expect(() => parseGraphQLServer.applyGraphQL({})).toThrow(\n        'You must provide an Express.js app instance!'\n      );\n      expect(() =>\n        parseGraphQLServer.applyGraphQL(new express())\n      ).not.toThrow();\n    });\n\n    it('should apply middlewares at config.graphQLPath', () => {\n      let useCount = 0;\n      expect(() =>\n        new ParseGraphQLServer(parseServer, {\n          graphQLPath: 'somepath',\n        }).applyGraphQL({\n          use: (path) => {\n            useCount++;\n            expect(path).toEqual('somepath');\n          },\n        })\n      ).not.toThrow();\n      expect(useCount).toBeGreaterThan(0);\n    });\n  });\n\n  describe('applyPlayground', () => {\n    it('should require an Express.js app instance', () => {\n      expect(() => parseGraphQLServer.applyPlayground()).toThrow(\n        'You must provide an Express.js app instance!'\n      );\n      expect(() => parseGraphQLServer.applyPlayground({})).toThrow(\n        'You must provide an Express.js app instance!'\n      );\n      expect(() =>\n        parseGraphQLServer.applyPlayground(new express())\n      ).not.toThrow();\n    });\n\n    it('should require initialization with config.playgroundPath', () => {\n      expect(() =>\n        new ParseGraphQLServer(parseServer, {\n          graphQLPath: 'graphql',\n        }).applyPlayground(new express())\n      ).toThrow('You must provide a config.playgroundPath to applyPlayground!');\n    });\n\n    it('should apply middlewares at config.playgroundPath', () => {\n      let useCount = 0;\n      expect(() =>\n        new ParseGraphQLServer(parseServer, {\n          graphQLPath: 'graphQL',\n          playgroundPath: 'somepath',\n        }).applyPlayground({\n          get: (path) => {\n            useCount++;\n            expect(path).toEqual('somepath');\n          },\n        })\n      ).not.toThrow();\n      expect(useCount).toBeGreaterThan(0);\n    });\n  });\n\n  describe('createSubscriptions', () => {\n    it('should require initialization with config.subscriptionsPath', () => {\n      expect(() =>\n        new ParseGraphQLServer(parseServer, {\n          graphQLPath: 'graphql',\n        }).createSubscriptions({})\n      ).toThrow(\n        'You must provide a config.subscriptionsPath to createSubscriptions!'\n      );\n    });\n  });\n\n  describe('setGraphQLConfig', () => {\n    let parseGraphQLServer;\n    beforeEach(() => {\n      parseGraphQLServer = new ParseGraphQLServer(parseServer, {\n        graphQLPath: 'graphql',\n      });\n    });\n    it('should pass the graphQLConfig onto the parseGraphQLController', async () => {\n      let received;\n      parseGraphQLServer.parseGraphQLController = {\n        async updateGraphQLConfig(graphQLConfig) {\n          received = graphQLConfig;\n          return {};\n        },\n      };\n      const graphQLConfig = { enabledForClasses: [] };\n      await parseGraphQLServer.setGraphQLConfig(graphQLConfig);\n      expect(received).toBe(graphQLConfig);\n    });\n    it('should not absorb exceptions from parseGraphQLController', async () => {\n      parseGraphQLServer.parseGraphQLController = {\n        async updateGraphQLConfig() {\n          throw new Error('Network request failed');\n        },\n      };\n      await expectAsync(\n        parseGraphQLServer.setGraphQLConfig({})\n      ).toBeRejectedWith(new Error('Network request failed'));\n    });\n    it('should return the response from parseGraphQLController', async () => {\n      parseGraphQLServer.parseGraphQLController = {\n        async updateGraphQLConfig() {\n          return { response: { result: true } };\n        },\n      };\n      await expectAsync(\n        parseGraphQLServer.setGraphQLConfig({})\n      ).toBeResolvedTo({ response: { result: true } });\n    });\n  });\n\n  describe('Auto API', () => {\n    let httpServer;\n    let parseLiveQueryServer;\n    const headers = {\n      'X-Parse-Application-Id': 'test',\n      'X-Parse-Javascript-Key': 'test',\n    };\n\n    let apolloClient;\n\n    let user1;\n    let user2;\n    let user3;\n    let user4;\n    let user5;\n    let role;\n    let object1;\n    let object2;\n    let object3;\n    let object4;\n    let objects = [];\n\n    async function prepareData() {\n      user1 = new Parse.User();\n      user1.setUsername('user1');\n      user1.setPassword('user1');\n      user1.setEmail('user1@user1.user1');\n      await user1.signUp();\n\n      user2 = new Parse.User();\n      user2.setUsername('user2');\n      user2.setPassword('user2');\n      await user2.signUp();\n\n      user3 = new Parse.User();\n      user3.setUsername('user3');\n      user3.setPassword('user3');\n      await user3.signUp();\n\n      user4 = new Parse.User();\n      user4.setUsername('user4');\n      user4.setPassword('user4');\n      await user4.signUp();\n\n      user5 = new Parse.User();\n      user5.setUsername('user5');\n      user5.setPassword('user5');\n      await user5.signUp();\n\n      const roleACL = new Parse.ACL();\n      roleACL.setPublicReadAccess(true);\n      role = new Parse.Role();\n      role.setName('role');\n      role.setACL(roleACL);\n      role.getUsers().add(user1);\n      role.getUsers().add(user3);\n      role = await role.save();\n\n      const schemaController = await parseServer.config.databaseController.loadSchema();\n      try {\n        await schemaController.addClassIfNotExists(\n          'GraphQLClass',\n          {\n            someField: { type: 'String' },\n            pointerToUser: { type: 'Pointer', targetClass: '_User' },\n          },\n          {\n            find: {\n              'role:role': true,\n              [user1.id]: true,\n              [user2.id]: true,\n            },\n            create: {\n              'role:role': true,\n              [user1.id]: true,\n              [user2.id]: true,\n            },\n            get: {\n              'role:role': true,\n              [user1.id]: true,\n              [user2.id]: true,\n            },\n            update: {\n              'role:role': true,\n              [user1.id]: true,\n              [user2.id]: true,\n            },\n            addField: {\n              'role:role': true,\n              [user1.id]: true,\n              [user2.id]: true,\n            },\n            delete: {\n              'role:role': true,\n              [user1.id]: true,\n              [user2.id]: true,\n            },\n            readUserFields: ['pointerToUser'],\n            writeUserFields: ['pointerToUser'],\n          },\n          {}\n        );\n      } catch (err) {\n        if (\n          !(err instanceof Parse.Error) ||\n          err.message !== 'Class GraphQLClass already exists.'\n        ) {\n          throw err;\n        }\n      }\n\n      object1 = new Parse.Object('GraphQLClass');\n      object1.set('someField', 'someValue1');\n      object1.set('someOtherField', 'A');\n      const object1ACL = new Parse.ACL();\n      object1ACL.setPublicReadAccess(false);\n      object1ACL.setPublicWriteAccess(false);\n      object1ACL.setRoleReadAccess(role, true);\n      object1ACL.setRoleWriteAccess(role, true);\n      object1ACL.setReadAccess(user1.id, true);\n      object1ACL.setWriteAccess(user1.id, true);\n      object1ACL.setReadAccess(user2.id, true);\n      object1ACL.setWriteAccess(user2.id, true);\n      object1.setACL(object1ACL);\n      await object1.save(undefined, { useMasterKey: true });\n\n      object2 = new Parse.Object('GraphQLClass');\n      object2.set('someField', 'someValue2');\n      object2.set('someOtherField', 'A');\n      const object2ACL = new Parse.ACL();\n      object2ACL.setPublicReadAccess(false);\n      object2ACL.setPublicWriteAccess(false);\n      object2ACL.setReadAccess(user1.id, true);\n      object2ACL.setWriteAccess(user1.id, true);\n      object2ACL.setReadAccess(user2.id, true);\n      object2ACL.setWriteAccess(user2.id, true);\n      object2ACL.setReadAccess(user5.id, true);\n      object2ACL.setWriteAccess(user5.id, true);\n      object2.setACL(object2ACL);\n      await object2.save(undefined, { useMasterKey: true });\n\n      object3 = new Parse.Object('GraphQLClass');\n      object3.set('someField', 'someValue3');\n      object3.set('someOtherField', 'B');\n      object3.set('pointerToUser', user5);\n      await object3.save(undefined, { useMasterKey: true });\n\n      object4 = new Parse.Object('PublicClass');\n      object4.set('someField', 'someValue4');\n      await object4.save();\n\n      objects = [];\n      objects.push(object1, object2, object3, object4);\n    }\n\n    beforeAll(async () => {\n      const expressApp = express();\n      httpServer = http.createServer(expressApp);\n      expressApp.use('/parse', parseServer.app);\n      parseLiveQueryServer = ParseServer.createLiveQueryServer(httpServer, {\n        port: 1338,\n      });\n      parseGraphQLServer.applyGraphQL(expressApp);\n      parseGraphQLServer.applyPlayground(expressApp);\n      parseGraphQLServer.createSubscriptions(httpServer);\n      await new Promise((resolve) =>\n        httpServer.listen({ port: 13377 }, resolve)\n      );\n\n      const subscriptionClient = new SubscriptionClient(\n        'ws://localhost:13377/subscriptions',\n        {\n          reconnect: true,\n          connectionParams: headers,\n        },\n        ws\n      );\n      const wsLink = new WebSocketLink(subscriptionClient);\n      const httpLink = createUploadLink({\n        uri: 'http://localhost:13377/graphql',\n        fetch,\n        headers,\n      });\n      apolloClient = new ApolloClient({\n        link: split(\n          ({ query }) => {\n            const { kind, operation } = getMainDefinition(query);\n            return (\n              kind === 'OperationDefinition' && operation === 'subscription'\n            );\n          },\n          wsLink,\n          httpLink\n        ),\n        cache: new InMemoryCache(),\n        defaultOptions: {\n          query: {\n            fetchPolicy: 'no-cache',\n          },\n        },\n      });\n    });\n\n    beforeEach(() => {\n      spyOn(console, 'warn').and.callFake(() => {});\n      spyOn(console, 'error').and.callFake(() => {});\n    });\n\n    afterAll(async () => {\n      await parseLiveQueryServer.server.close();\n      await httpServer.close();\n    });\n\n    describe('GraphQL', () => {\n      it('should be healthy', async () => {\n        try {\n          const health = (\n            await apolloClient.query({\n              query: gql`\n                query Health {\n                  health\n                }\n              `,\n            })\n          ).data.health;\n          expect(health).toBeTruthy();\n        } catch (e) {\n          handleError(e);\n        }\n      });\n\n      it('should be cors enabled', async () => {\n        let checked = false;\n        const apolloClient = new ApolloClient({\n          link: new ApolloLink((operation, forward) => {\n            return forward(operation).map((response) => {\n              const context = operation.getContext();\n              const {\n                response: { headers },\n              } = context;\n              expect(headers.get('access-control-allow-origin')).toEqual('*');\n              checked = true;\n              return response;\n            });\n          }).concat(\n            createHttpLink({\n              uri: 'http://localhost:13377/graphql',\n              fetch,\n              headers: {\n                ...headers,\n                Origin: 'http://someorigin.com',\n              },\n            })\n          ),\n          cache: new InMemoryCache(),\n        });\n        const healthResponse = await apolloClient.query({\n          query: gql`\n            query Health {\n              health\n            }\n          `,\n        });\n        expect(healthResponse.data.health).toBeTruthy();\n        expect(checked).toBeTruthy();\n      });\n\n      it('should handle Parse headers', async () => {\n        let checked = false;\n        const originalGetGraphQLOptions = parseGraphQLServer._getGraphQLOptions;\n        parseGraphQLServer._getGraphQLOptions = async (req) => {\n          expect(req.info).toBeDefined();\n          expect(req.config).toBeDefined();\n          expect(req.auth).toBeDefined();\n          checked = true;\n          return await originalGetGraphQLOptions.bind(parseGraphQLServer)(req);\n        };\n        const health = (\n          await apolloClient.query({\n            query: gql`\n              query Health {\n                health\n              }\n            `,\n          })\n        ).data.health;\n        expect(health).toBeTruthy();\n        expect(checked).toBeTruthy();\n        parseGraphQLServer._getGraphQLOptions = originalGetGraphQLOptions;\n      });\n    });\n\n    describe('Playground', () => {\n      it('should mount playground', async () => {\n        const res = await req({\n          method: 'GET',\n          url: 'http://localhost:13377/playground',\n        });\n        expect(res.status).toEqual(200);\n      });\n    });\n\n    describe('Schema', () => {\n      const resetGraphQLCache = async () => {\n        await Promise.all([\n          parseGraphQLServer.parseGraphQLController.cacheController.graphQL.clear(),\n          parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear(),\n        ]);\n      };\n\n      describe('Default Types', () => {\n        it('should have Object scalar type', async () => {\n          const objectType = (\n            await apolloClient.query({\n              query: gql`\n                query ObjectType {\n                  __type(name: \"Object\") {\n                    kind\n                  }\n                }\n              `,\n            })\n          ).data['__type'];\n          expect(objectType.kind).toEqual('SCALAR');\n        });\n\n        it('should have Date scalar type', async () => {\n          const dateType = (\n            await apolloClient.query({\n              query: gql`\n                query DateType {\n                  __type(name: \"Date\") {\n                    kind\n                  }\n                }\n              `,\n            })\n          ).data['__type'];\n          expect(dateType.kind).toEqual('SCALAR');\n        });\n\n        it('should have ArrayResult type', async () => {\n          const arrayResultType = (\n            await apolloClient.query({\n              query: gql`\n                query ArrayResultType {\n                  __type(name: \"ArrayResult\") {\n                    kind\n                  }\n                }\n              `,\n            })\n          ).data['__type'];\n          expect(arrayResultType.kind).toEqual('UNION');\n        });\n\n        it('should have File object type', async () => {\n          const fileType = (\n            await apolloClient.query({\n              query: gql`\n                query FileType {\n                  __type(name: \"FileInfo\") {\n                    kind\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'];\n          expect(fileType.kind).toEqual('OBJECT');\n          expect(fileType.fields.map((field) => field.name).sort()).toEqual([\n            'name',\n            'url',\n          ]);\n        });\n\n        it('should have Class interface type', async () => {\n          const classType = (\n            await apolloClient.query({\n              query: gql`\n                query ClassType {\n                  __type(name: \"ParseObject\") {\n                    kind\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'];\n          expect(classType.kind).toEqual('INTERFACE');\n          expect(classType.fields.map((field) => field.name).sort()).toEqual([\n            'ACL',\n            'createdAt',\n            'objectId',\n            'updatedAt',\n          ]);\n        });\n\n        it('should have ReadPreference enum type', async () => {\n          const readPreferenceType = (\n            await apolloClient.query({\n              query: gql`\n                query ReadPreferenceType {\n                  __type(name: \"ReadPreference\") {\n                    kind\n                    enumValues {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'];\n          expect(readPreferenceType.kind).toEqual('ENUM');\n          expect(\n            readPreferenceType.enumValues.map((value) => value.name).sort()\n          ).toEqual([\n            'NEAREST',\n            'PRIMARY',\n            'PRIMARY_PREFERRED',\n            'SECONDARY',\n            'SECONDARY_PREFERRED',\n          ]);\n        });\n\n        it('should have GraphQLUpload object type', async () => {\n          const graphQLUploadType = (\n            await apolloClient.query({\n              query: gql`\n                query GraphQLUploadType {\n                  __type(name: \"Upload\") {\n                    kind\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'];\n          expect(graphQLUploadType.kind).toEqual('SCALAR');\n        });\n\n        it('should have all expected types', async () => {\n          const schemaTypes = (\n            await apolloClient.query({\n              query: gql`\n                query SchemaTypes {\n                  __schema {\n                    types {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__schema'].types.map((type) => type.name);\n\n          const expectedTypes = [\n            'ParseObject',\n            'Date',\n            'FileInfo',\n            'ReadPreference',\n            'Upload',\n          ];\n          expect(\n            expectedTypes.every((type) => schemaTypes.indexOf(type) !== -1)\n          ).toBeTruthy(JSON.stringify(schemaTypes.types));\n        });\n      });\n\n      describe('Relay Specific Types', () => {\n        beforeAll(async () => {\n          await resetGraphQLCache();\n        });\n\n        afterAll(async () => {\n          await resetGraphQLCache();\n        });\n\n        it('should have Node interface', async () => {\n          const schemaTypes = (\n            await apolloClient.query({\n              query: gql`\n                query SchemaTypes {\n                  __schema {\n                    types {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__schema'].types.map((type) => type.name);\n\n          expect(schemaTypes).toContain('Node');\n        });\n\n        it('should have node query', async () => {\n          const queryFields = (\n            await apolloClient.query({\n              query: gql`\n                query UserType {\n                  __type(name: \"Query\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].fields.map((field) => field.name);\n\n          expect(queryFields).toContain('node');\n        });\n\n        it('should return global id', async () => {\n          const userFields = (\n            await apolloClient.query({\n              query: gql`\n                query UserType {\n                  __type(name: \"User\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].fields.map((field) => field.name);\n\n          expect(userFields).toContain('id');\n          expect(userFields).toContain('objectId');\n        });\n\n        it('should have clientMutationId in create file input', async () => {\n          const createFileInputFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"CreateFileInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].inputFields\n            .map((field) => field.name)\n            .sort();\n\n          expect(createFileInputFields).toEqual(['clientMutationId', 'upload']);\n        });\n\n        it('should have clientMutationId in create file payload', async () => {\n          const createFilePayloadFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"CreateFilePayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].fields\n            .map((field) => field.name)\n            .sort();\n\n          expect(createFilePayloadFields).toEqual([\n            'clientMutationId',\n            'fileInfo',\n          ]);\n        });\n\n        it('should have clientMutationId in call function input', async () => {\n          Parse.Cloud.define('hello', () => {});\n\n          const callFunctionInputFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"CallCloudCodeInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].inputFields\n            .map((field) => field.name)\n            .sort();\n\n          expect(callFunctionInputFields).toEqual([\n            'clientMutationId',\n            'functionName',\n            'params',\n          ]);\n        });\n\n        it('should have clientMutationId in call function payload', async () => {\n          Parse.Cloud.define('hello', () => {});\n\n          const callFunctionPayloadFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"CallCloudCodePayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].fields\n            .map((field) => field.name)\n            .sort();\n\n          expect(callFunctionPayloadFields).toEqual([\n            'clientMutationId',\n            'result',\n          ]);\n        });\n\n        it('should have clientMutationId in sign up mutation input', async () => {\n          const inputFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"SignUpInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].inputFields\n            .map((field) => field.name)\n            .sort();\n\n          expect(inputFields).toEqual(['clientMutationId', 'fields']);\n        });\n\n        it('should have clientMutationId in sign up mutation payload', async () => {\n          const payloadFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"SignUpPayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].fields\n            .map((field) => field.name)\n            .sort();\n\n          expect(payloadFields).toEqual(['clientMutationId', 'viewer']);\n        });\n\n        it('should have clientMutationId in log in mutation input', async () => {\n          const inputFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"LogInInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].inputFields\n            .map((field) => field.name)\n            .sort();\n\n          expect(inputFields).toEqual([\n            'clientMutationId',\n            'password',\n            'username',\n          ]);\n        });\n\n        it('should have clientMutationId in log in mutation payload', async () => {\n          const payloadFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"LogInPayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].fields\n            .map((field) => field.name)\n            .sort();\n\n          expect(payloadFields).toEqual(['clientMutationId', 'viewer']);\n        });\n\n        it('should have clientMutationId in log out mutation input', async () => {\n          const inputFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"LogOutInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].inputFields\n            .map((field) => field.name)\n            .sort();\n\n          expect(inputFields).toEqual(['clientMutationId']);\n        });\n\n        it('should have clientMutationId in log out mutation payload', async () => {\n          const payloadFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"LogOutPayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].fields\n            .map((field) => field.name)\n            .sort();\n\n          expect(payloadFields).toEqual(['clientMutationId', 'viewer']);\n        });\n\n        it('should have clientMutationId in createClass mutation input', async () => {\n          const inputFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"CreateClassInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].inputFields\n            .map((field) => field.name)\n            .sort();\n\n          expect(inputFields).toEqual([\n            'clientMutationId',\n            'name',\n            'schemaFields',\n          ]);\n        });\n\n        it('should have clientMutationId in createClass mutation payload', async () => {\n          const payloadFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"CreateClassPayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].fields\n            .map((field) => field.name)\n            .sort();\n\n          expect(payloadFields).toEqual(['class', 'clientMutationId']);\n        });\n\n        it('should have clientMutationId in updateClass mutation input', async () => {\n          const inputFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"UpdateClassInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].inputFields\n            .map((field) => field.name)\n            .sort();\n\n          expect(inputFields).toEqual([\n            'clientMutationId',\n            'name',\n            'schemaFields',\n          ]);\n        });\n\n        it('should have clientMutationId in updateClass mutation payload', async () => {\n          const payloadFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"UpdateClassPayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].fields\n            .map((field) => field.name)\n            .sort();\n\n          expect(payloadFields).toEqual(['class', 'clientMutationId']);\n        });\n\n        it('should have clientMutationId in deleteClass mutation input', async () => {\n          const inputFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"DeleteClassInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].inputFields\n            .map((field) => field.name)\n            .sort();\n\n          expect(inputFields).toEqual(['clientMutationId', 'name']);\n        });\n\n        it('should have clientMutationId in deleteClass mutation payload', async () => {\n          const payloadFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"UpdateClassPayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].fields\n            .map((field) => field.name)\n            .sort();\n\n          expect(payloadFields).toEqual(['class', 'clientMutationId']);\n        });\n\n        it('should have clientMutationId in custom create object mutation input', async () => {\n          const obj = new Parse.Object('SomeClass');\n          await obj.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const createObjectInputFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"CreateSomeClassInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].inputFields\n            .map((field) => field.name)\n            .sort();\n\n          expect(createObjectInputFields).toEqual([\n            'clientMutationId',\n            'fields',\n          ]);\n        });\n\n        it('should have clientMutationId in custom create object mutation payload', async () => {\n          const obj = new Parse.Object('SomeClass');\n          await obj.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const createObjectPayloadFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"CreateSomeClassPayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].fields\n            .map((field) => field.name)\n            .sort();\n\n          expect(createObjectPayloadFields).toEqual([\n            'clientMutationId',\n            'someClass',\n          ]);\n        });\n\n        it('should have clientMutationId in custom update object mutation input', async () => {\n          const obj = new Parse.Object('SomeClass');\n          await obj.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const createObjectInputFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"UpdateSomeClassInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].inputFields\n            .map((field) => field.name)\n            .sort();\n\n          expect(createObjectInputFields).toEqual([\n            'clientMutationId',\n            'fields',\n            'id',\n          ]);\n        });\n\n        it('should have clientMutationId in custom update object mutation payload', async () => {\n          const obj = new Parse.Object('SomeClass');\n          await obj.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const createObjectPayloadFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"UpdateSomeClassPayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].fields\n            .map((field) => field.name)\n            .sort();\n\n          expect(createObjectPayloadFields).toEqual([\n            'clientMutationId',\n            'someClass',\n          ]);\n        });\n\n        it('should have clientMutationId in custom delete object mutation input', async () => {\n          const obj = new Parse.Object('SomeClass');\n          await obj.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const createObjectInputFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"DeleteSomeClassInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].inputFields\n            .map((field) => field.name)\n            .sort();\n\n          expect(createObjectInputFields).toEqual(['clientMutationId', 'id']);\n        });\n\n        it('should have clientMutationId in custom delete object mutation payload', async () => {\n          const obj = new Parse.Object('SomeClass');\n          await obj.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const createObjectPayloadFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"DeleteSomeClassPayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].fields\n            .map((field) => field.name)\n            .sort();\n\n          expect(createObjectPayloadFields).toEqual([\n            'clientMutationId',\n            'someClass',\n          ]);\n        });\n      });\n\n      describe('Parse Class Types', () => {\n        it('should have all expected types', async () => {\n          await parseServer.config.databaseController.loadSchema();\n\n          const schemaTypes = (\n            await apolloClient.query({\n              query: gql`\n                query SchemaTypes {\n                  __schema {\n                    types {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__schema'].types.map((type) => type.name);\n\n          const expectedTypes = [\n            'Role',\n            'RoleWhereInput',\n            'CreateRoleFieldsInput',\n            'UpdateRoleFieldsInput',\n            'RoleConnection',\n            'User',\n            'UserWhereInput',\n            'UserConnection',\n            'CreateUserFieldsInput',\n            'UpdateUserFieldsInput',\n          ];\n          expect(\n            expectedTypes.every((type) => schemaTypes.indexOf(type) !== -1)\n          ).toBeTruthy(JSON.stringify(schemaTypes));\n        });\n\n        it('should ArrayResult contains all types', async () => {\n          const objectType = (\n            await apolloClient.query({\n              query: gql`\n                query ObjectType {\n                  __type(name: \"ArrayResult\") {\n                    kind\n                    possibleTypes {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'];\n          const possibleTypes = objectType.possibleTypes.map((o) => o.name);\n          expect(possibleTypes).toContain('User');\n          expect(possibleTypes).toContain('Role');\n          expect(possibleTypes).toContain('Element');\n        });\n\n        it('should update schema when it changes', async () => {\n          const schemaController = await parseServer.config.databaseController.loadSchema();\n          await schemaController.updateClass('_User', {\n            foo: { type: 'String' },\n          });\n\n          const userFields = (\n            await apolloClient.query({\n              query: gql`\n                query UserType {\n                  __type(name: \"User\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].fields.map((field) => field.name);\n          expect(userFields.indexOf('foo') !== -1).toBeTruthy();\n        });\n\n        it('should not contain password field from _User class', async () => {\n          const userFields = (\n            await apolloClient.query({\n              query: gql`\n                query UserType {\n                  __type(name: \"User\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].fields.map((field) => field.name);\n          expect(userFields.includes('password')).toBeFalsy();\n        });\n      });\n\n      describe('Configuration', function () {\n        const resetGraphQLCache = async () => {\n          await Promise.all([\n            parseGraphQLServer.parseGraphQLController.cacheController.graphQL.clear(),\n            parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear(),\n          ]);\n        };\n\n        beforeEach(async () => {\n          await parseGraphQLServer.setGraphQLConfig({});\n          await resetGraphQLCache();\n        });\n\n        it('should only include types in the enabledForClasses list', async () => {\n          const schemaController = await parseServer.config.databaseController.loadSchema();\n          await schemaController.addClassIfNotExists('SuperCar', {\n            foo: { type: 'String' },\n          });\n\n          const graphQLConfig = {\n            enabledForClasses: ['SuperCar'],\n          };\n          await parseGraphQLServer.setGraphQLConfig(graphQLConfig);\n          await resetGraphQLCache();\n\n          const { data } = await apolloClient.query({\n            query: gql`\n              query UserType {\n                userType: __type(name: \"User\") {\n                  fields {\n                    name\n                  }\n                }\n                superCarType: __type(name: \"SuperCar\") {\n                  fields {\n                    name\n                  }\n                }\n              }\n            `,\n          });\n          expect(data.userType).toBeNull();\n          expect(data.superCarType).toBeTruthy();\n        });\n        it('should not include types in the disabledForClasses list', async () => {\n          const schemaController = await parseServer.config.databaseController.loadSchema();\n          await schemaController.addClassIfNotExists('SuperCar', {\n            foo: { type: 'String' },\n          });\n\n          const graphQLConfig = {\n            disabledForClasses: ['SuperCar'],\n          };\n          await parseGraphQLServer.setGraphQLConfig(graphQLConfig);\n          await resetGraphQLCache();\n\n          const { data } = await apolloClient.query({\n            query: gql`\n              query UserType {\n                userType: __type(name: \"User\") {\n                  fields {\n                    name\n                  }\n                }\n                superCarType: __type(name: \"SuperCar\") {\n                  fields {\n                    name\n                  }\n                }\n              }\n            `,\n          });\n          expect(data.superCarType).toBeNull();\n          expect(data.userType).toBeTruthy();\n        });\n        it('should remove query operations when disabled', async () => {\n          const superCar = new Parse.Object('SuperCar');\n          await superCar.save({ foo: 'bar' });\n          const customer = new Parse.Object('Customer');\n          await customer.save({ foo: 'bar' });\n\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                query GetSuperCar($id: ID!) {\n                  superCar(id: $id) {\n                    id\n                  }\n                }\n              `,\n              variables: {\n                id: superCar.id,\n              },\n            })\n          ).toBeResolved();\n\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                query FindCustomer {\n                  customers {\n                    count\n                  }\n                }\n              `,\n            })\n          ).toBeResolved();\n\n          const graphQLConfig = {\n            classConfigs: [\n              {\n                className: 'SuperCar',\n                query: {\n                  get: false,\n                  find: true,\n                },\n              },\n              {\n                className: 'Customer',\n                query: {\n                  get: true,\n                  find: false,\n                },\n              },\n            ],\n          };\n          await parseGraphQLServer.setGraphQLConfig(graphQLConfig);\n          await resetGraphQLCache();\n\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                query GetSuperCar($id: ID!) {\n                  superCar(id: $id) {\n                    id\n                  }\n                }\n              `,\n              variables: {\n                id: superCar.id,\n              },\n            })\n          ).toBeRejected();\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                query GetCustomer($id: ID!) {\n                  customer(id: $id) {\n                    id\n                  }\n                }\n              `,\n              variables: {\n                id: customer.id,\n              },\n            })\n          ).toBeResolved();\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                query FindSuperCar {\n                  superCars {\n                    count\n                  }\n                }\n              `,\n            })\n          ).toBeResolved();\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                query FindCustomer {\n                  customers {\n                    count\n                  }\n                }\n              `,\n            })\n          ).toBeRejected();\n        });\n\n        it('should remove mutation operations, create, update and delete, when disabled', async () => {\n          const superCar1 = new Parse.Object('SuperCar');\n          await superCar1.save({ foo: 'bar' });\n          const customer1 = new Parse.Object('Customer');\n          await customer1.save({ foo: 'bar' });\n\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                mutation UpdateSuperCar($id: ID!, $foo: String!) {\n                  updateSuperCar(input: { id: $id, fields: { foo: $foo } }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                id: superCar1.id,\n                foo: 'lah',\n              },\n            })\n          ).toBeResolved();\n\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                mutation DeleteCustomer($id: ID!) {\n                  deleteCustomer(input: { id: $id }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                id: customer1.id,\n              },\n            })\n          ).toBeResolved();\n\n          const { data: customerData } = await apolloClient.query({\n            query: gql`\n              mutation CreateCustomer($foo: String!) {\n                createCustomer(input: { fields: { foo: $foo } }) {\n                  customer {\n                    id\n                  }\n                }\n              }\n            `,\n            variables: {\n              foo: 'rah',\n            },\n          });\n          expect(customerData.createCustomer.customer).toBeTruthy();\n\n          // used later\n          const customer2Id = customerData.createCustomer.customer.id;\n\n          await parseGraphQLServer.setGraphQLConfig({\n            classConfigs: [\n              {\n                className: 'SuperCar',\n                mutation: {\n                  create: true,\n                  update: false,\n                  destroy: true,\n                },\n              },\n              {\n                className: 'Customer',\n                mutation: {\n                  create: false,\n                  update: true,\n                  destroy: false,\n                },\n              },\n            ],\n          });\n          await resetGraphQLCache();\n\n          const { data: superCarData } = await apolloClient.query({\n            query: gql`\n              mutation CreateSuperCar($foo: String!) {\n                createSuperCar(input: { fields: { foo: $foo } }) {\n                  superCar {\n                    id\n                  }\n                }\n              }\n            `,\n            variables: {\n              foo: 'mah',\n            },\n          });\n          expect(superCarData.createSuperCar).toBeTruthy();\n          const superCar3Id = superCarData.createSuperCar.superCar.id;\n\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                mutation UpdateSupercar($id: ID!, $foo: String!) {\n                  updateSuperCar(input: { id: $id, fields: { foo: $foo } }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                id: superCar3Id,\n              },\n            })\n          ).toBeRejected();\n\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                mutation DeleteSuperCar($id: ID!) {\n                  deleteSuperCar(input: { id: $id }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                id: superCar3Id,\n              },\n            })\n          ).toBeResolved();\n\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                mutation CreateCustomer($foo: String!) {\n                  createCustomer(input: { fields: { foo: $foo } }) {\n                    customer {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                foo: 'rah',\n              },\n            })\n          ).toBeRejected();\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                mutation UpdateCustomer($id: ID!, $foo: String!) {\n                  updateCustomer(input: { id: $id, fields: { foo: $foo } }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                id: customer2Id,\n                foo: 'tah',\n              },\n            })\n          ).toBeResolved();\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                mutation DeleteCustomer($id: ID!, $foo: String!) {\n                  deleteCustomer(input: { id: $id }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                id: customer2Id,\n              },\n            })\n          ).toBeRejected();\n        });\n\n        it('should only allow the supplied create and update fields for a class', async () => {\n          const schemaController = await parseServer.config.databaseController.loadSchema();\n          await schemaController.addClassIfNotExists('SuperCar', {\n            engine: { type: 'String' },\n            doors: { type: 'Number' },\n            price: { type: 'String' },\n            mileage: { type: 'Number' },\n          });\n\n          await parseGraphQLServer.setGraphQLConfig({\n            classConfigs: [\n              {\n                className: 'SuperCar',\n                type: {\n                  inputFields: {\n                    create: ['engine', 'doors', 'price'],\n                    update: ['price', 'mileage'],\n                  },\n                },\n              },\n            ],\n          });\n\n          await resetGraphQLCache();\n\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                mutation InvalidCreateSuperCar {\n                  createSuperCar(\n                    input: { fields: { engine: \"diesel\", mileage: 1000 } }\n                  ) {\n                    superCar {\n                      id\n                    }\n                  }\n                }\n              `,\n            })\n          ).toBeRejected();\n          const { id: superCarId } = (\n            await apolloClient.query({\n              query: gql`\n                mutation ValidCreateSuperCar {\n                  createSuperCar(\n                    input: {\n                      fields: { engine: \"diesel\", doors: 5, price: \"\u00a310000\" }\n                    }\n                  ) {\n                    superCar {\n                      id\n                    }\n                  }\n                }\n              `,\n            })\n          ).data.createSuperCar.superCar;\n\n          expect(superCarId).toBeTruthy();\n\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                mutation InvalidUpdateSuperCar($id: ID!) {\n                  updateSuperCar(\n                    input: { id: $id, fields: { engine: \"petrol\" } }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                id: superCarId,\n              },\n            })\n          ).toBeRejected();\n\n          const updatedSuperCar = (\n            await apolloClient.query({\n              query: gql`\n                mutation ValidUpdateSuperCar($id: ID!) {\n                  updateSuperCar(\n                    input: { id: $id, fields: { mileage: 2000 } }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                id: superCarId,\n              },\n            })\n          ).data.updateSuperCar;\n          expect(updatedSuperCar).toBeTruthy();\n        });\n\n        it('should handle required fields from the Parse class', async () => {\n          const schemaController = await parseServer.config.databaseController.loadSchema();\n          await schemaController.addClassIfNotExists('SuperCar', {\n            engine: { type: 'String', required: true },\n            doors: { type: 'Number', required: true },\n            price: { type: 'String' },\n            mileage: { type: 'Number' },\n          });\n\n          await resetGraphQLCache();\n\n          const {\n            data: { __type },\n          } = await apolloClient.query({\n            query: gql`\n              query requiredFields {\n                __type(name: \"CreateSuperCarFieldsInput\") {\n                  inputFields {\n                    name\n                    type {\n                      kind\n                    }\n                  }\n                }\n              }\n            `,\n          });\n          expect(\n            __type.inputFields.find((o) => o.name === 'price').type.kind\n          ).toEqual('SCALAR');\n          expect(\n            __type.inputFields.find((o) => o.name === 'engine').type.kind\n          ).toEqual('NON_NULL');\n          expect(\n            __type.inputFields.find((o) => o.name === 'doors').type.kind\n          ).toEqual('NON_NULL');\n\n          const {\n            data: { __type: __type2 },\n          } = await apolloClient.query({\n            query: gql`\n              query requiredFields {\n                __type(name: \"SuperCar\") {\n                  fields {\n                    name\n                    type {\n                      kind\n                    }\n                  }\n                }\n              }\n            `,\n          });\n          expect(\n            __type2.fields.find((o) => o.name === 'price').type.kind\n          ).toEqual('SCALAR');\n          expect(\n            __type2.fields.find((o) => o.name === 'engine').type.kind\n          ).toEqual('NON_NULL');\n          expect(\n            __type2.fields.find((o) => o.name === 'doors').type.kind\n          ).toEqual('NON_NULL');\n        });\n\n        it('should only allow the supplied output fields for a class', async () => {\n          const schemaController = await parseServer.config.databaseController.loadSchema();\n\n          await schemaController.addClassIfNotExists('SuperCar', {\n            engine: { type: 'String' },\n            doors: { type: 'Number' },\n            price: { type: 'String' },\n            mileage: { type: 'Number' },\n            insuranceClaims: { type: 'Number' },\n          });\n\n          const superCar = await new Parse.Object('SuperCar').save({\n            engine: 'petrol',\n            doors: 3,\n            price: '\u00a37500',\n            mileage: 0,\n            insuranceCertificate: 'private-file.pdf',\n          });\n\n          await parseGraphQLServer.setGraphQLConfig({\n            classConfigs: [\n              {\n                className: 'SuperCar',\n                type: {\n                  outputFields: ['engine', 'doors', 'price', 'mileage'],\n                },\n              },\n            ],\n          });\n\n          await resetGraphQLCache();\n\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                query GetSuperCar($id: ID!) {\n                  superCar(id: $id) {\n                    id\n                    objectId\n                    engine\n                    doors\n                    price\n                    mileage\n                    insuranceCertificate\n                  }\n                }\n              `,\n              variables: {\n                id: superCar.id,\n              },\n            })\n          ).toBeRejected();\n          let getSuperCar = (\n            await apolloClient.query({\n              query: gql`\n                query GetSuperCar($id: ID!) {\n                  superCar(id: $id) {\n                    id\n                    objectId\n                    engine\n                    doors\n                    price\n                    mileage\n                  }\n                }\n              `,\n              variables: {\n                id: superCar.id,\n              },\n            })\n          ).data.superCar;\n          expect(getSuperCar).toBeTruthy();\n\n          await parseGraphQLServer.setGraphQLConfig({\n            classConfigs: [\n              {\n                className: 'SuperCar',\n                type: {\n                  outputFields: [],\n                },\n              },\n            ],\n          });\n\n          await resetGraphQLCache();\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                query GetSuperCar($id: ID!) {\n                  superCar(id: $id) {\n                    engine\n                  }\n                }\n              `,\n              variables: {\n                id: superCar.id,\n              },\n            })\n          ).toBeRejected();\n          getSuperCar = (\n            await apolloClient.query({\n              query: gql`\n                query GetSuperCar($id: ID!) {\n                  superCar(id: $id) {\n                    id\n                    objectId\n                  }\n                }\n              `,\n              variables: {\n                id: superCar.id,\n              },\n            })\n          ).data.superCar;\n          expect(getSuperCar.objectId).toBe(superCar.id);\n        });\n\n        it('should only allow the supplied constraint fields for a class', async () => {\n          try {\n            const schemaController = await parseServer.config.databaseController.loadSchema();\n\n            await schemaController.addClassIfNotExists('SuperCar', {\n              model: { type: 'String' },\n              engine: { type: 'String' },\n              doors: { type: 'Number' },\n              price: { type: 'String' },\n              mileage: { type: 'Number' },\n              insuranceCertificate: { type: 'String' },\n            });\n\n            await new Parse.Object('SuperCar').save({\n              model: 'McLaren',\n              engine: 'petrol',\n              doors: 3,\n              price: '\u00a37500',\n              mileage: 0,\n              insuranceCertificate: 'private-file.pdf',\n            });\n\n            await parseGraphQLServer.setGraphQLConfig({\n              classConfigs: [\n                {\n                  className: 'SuperCar',\n                  type: {\n                    constraintFields: ['engine', 'doors', 'price'],\n                  },\n                },\n              ],\n            });\n\n            await resetGraphQLCache();\n\n            await expectAsync(\n              apolloClient.query({\n                query: gql`\n                  query FindSuperCar {\n                    superCars(\n                      where: {\n                        insuranceCertificate: { equalTo: \"private-file.pdf\" }\n                      }\n                    ) {\n                      count\n                    }\n                  }\n                `,\n              })\n            ).toBeRejected();\n\n            await expectAsync(\n              apolloClient.query({\n                query: gql`\n                  query FindSuperCar {\n                    superCars(where: { mileage: { equalTo: 0 } }) {\n                      count\n                    }\n                  }\n                `,\n              })\n            ).toBeRejected();\n\n            await expectAsync(\n              apolloClient.query({\n                query: gql`\n                  query FindSuperCar {\n                    superCars(where: { engine: { equalTo: \"petrol\" } }) {\n                      count\n                    }\n                  }\n                `,\n              })\n            ).toBeResolved();\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should only allow the supplied sort fields for a class', async () => {\n          const schemaController = await parseServer.config.databaseController.loadSchema();\n\n          await schemaController.addClassIfNotExists('SuperCar', {\n            engine: { type: 'String' },\n            doors: { type: 'Number' },\n            price: { type: 'String' },\n            mileage: { type: 'Number' },\n          });\n\n          await new Parse.Object('SuperCar').save({\n            engine: 'petrol',\n            doors: 3,\n            price: '\u00a37500',\n            mileage: 0,\n          });\n\n          await parseGraphQLServer.setGraphQLConfig({\n            classConfigs: [\n              {\n                className: 'SuperCar',\n                type: {\n                  sortFields: [\n                    {\n                      field: 'doors',\n                      asc: true,\n                      desc: true,\n                    },\n                    {\n                      field: 'price',\n                      asc: true,\n                      desc: true,\n                    },\n                    {\n                      field: 'mileage',\n                      asc: true,\n                      desc: false,\n                    },\n                  ],\n                },\n              },\n            ],\n          });\n\n          await resetGraphQLCache();\n\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                query FindSuperCar {\n                  superCars(order: [engine_ASC]) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `,\n            })\n          ).toBeRejected();\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                query FindSuperCar {\n                  superCars(order: [engine_DESC]) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `,\n            })\n          ).toBeRejected();\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                query FindSuperCar {\n                  superCars(order: [mileage_DESC]) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `,\n            })\n          ).toBeRejected();\n\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                query FindSuperCar {\n                  superCars(order: [mileage_ASC]) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `,\n            })\n          ).toBeResolved();\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                query FindSuperCar {\n                  superCars(order: [doors_ASC]) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `,\n            })\n          ).toBeResolved();\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                query FindSuperCar {\n                  superCars(order: [price_DESC]) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `,\n            })\n          ).toBeResolved();\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                query FindSuperCar {\n                  superCars(order: [price_ASC, doors_DESC]) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `,\n            })\n          ).toBeResolved();\n        });\n      });\n\n      describe('Relay Spec', () => {\n        beforeAll(async () => {\n          await resetGraphQLCache();\n        });\n\n        afterAll(async () => {\n          await resetGraphQLCache();\n        });\n\n        describe('Object Identification', () => {\n          it('Class get custom method should return valid gobal id', async () => {\n            const obj = new Parse.Object('SomeClass');\n            obj.set('someField', 'some value');\n            await obj.save();\n\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeClass($objectId: ID!) {\n                  someClass(id: $objectId) {\n                    id\n                    objectId\n                  }\n                }\n              `,\n              variables: {\n                objectId: obj.id,\n              },\n            });\n\n            expect(getResult.data.someClass.objectId).toBe(obj.id);\n\n            const nodeResult = await apolloClient.query({\n              query: gql`\n                query Node($id: ID!) {\n                  node(id: $id) {\n                    id\n                    ... on SomeClass {\n                      objectId\n                      someField\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: getResult.data.someClass.id,\n              },\n            });\n\n            expect(nodeResult.data.node.id).toBe(getResult.data.someClass.id);\n            expect(nodeResult.data.node.objectId).toBe(obj.id);\n            expect(nodeResult.data.node.someField).toBe('some value');\n          });\n\n          it('Class find custom method should return valid gobal id', async () => {\n            const obj1 = new Parse.Object('SomeClass');\n            obj1.set('someField', 'some value 1');\n            await obj1.save();\n\n            const obj2 = new Parse.Object('SomeClass');\n            obj2.set('someField', 'some value 2');\n            await obj2.save();\n\n            const findResult = await apolloClient.query({\n              query: gql`\n                query FindSomeClass {\n                  someClasses(order: [createdAt_ASC]) {\n                    edges {\n                      node {\n                        id\n                        objectId\n                      }\n                    }\n                  }\n                }\n              `,\n            });\n\n            expect(findResult.data.someClasses.edges[0].node.objectId).toBe(\n              obj1.id\n            );\n            expect(findResult.data.someClasses.edges[1].node.objectId).toBe(\n              obj2.id\n            );\n\n            const nodeResult = await apolloClient.query({\n              query: gql`\n                query Node($id1: ID!, $id2: ID!) {\n                  node1: node(id: $id1) {\n                    id\n                    ... on SomeClass {\n                      objectId\n                      someField\n                    }\n                  }\n                  node2: node(id: $id2) {\n                    id\n                    ... on SomeClass {\n                      objectId\n                      someField\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id1: findResult.data.someClasses.edges[0].node.id,\n                id2: findResult.data.someClasses.edges[1].node.id,\n              },\n            });\n\n            expect(nodeResult.data.node1.id).toBe(\n              findResult.data.someClasses.edges[0].node.id\n            );\n            expect(nodeResult.data.node1.objectId).toBe(obj1.id);\n            expect(nodeResult.data.node1.someField).toBe('some value 1');\n            expect(nodeResult.data.node2.id).toBe(\n              findResult.data.someClasses.edges[1].node.id\n            );\n            expect(nodeResult.data.node2.objectId).toBe(obj2.id);\n            expect(nodeResult.data.node2.someField).toBe('some value 2');\n          });\n\n          it_only_db('mongo')(\n            'Id inputs should work either with global id or object id',\n            async () => {\n              try {\n                await apolloClient.mutate({\n                  mutation: gql`\n                    mutation CreateClasses {\n                      secondaryObject: createClass(\n                        input: {\n                          name: \"SecondaryObject\"\n                          schemaFields: { addStrings: [{ name: \"someField\" }] }\n                        }\n                      ) {\n                        clientMutationId\n                      }\n                      primaryObject: createClass(\n                        input: {\n                          name: \"PrimaryObject\"\n                          schemaFields: {\n                            addStrings: [{ name: \"stringField\" }]\n                            addArrays: [{ name: \"arrayField\" }]\n                            addPointers: [\n                              {\n                                name: \"pointerField\"\n                                targetClassName: \"SecondaryObject\"\n                              }\n                            ]\n                            addRelations: [\n                              {\n                                name: \"relationField\"\n                                targetClassName: \"SecondaryObject\"\n                              }\n                            ]\n                          }\n                        }\n                      ) {\n                        clientMutationId\n                      }\n                    }\n                  `,\n                  context: {\n                    headers: {\n                      'X-Parse-Master-Key': 'test',\n                    },\n                  },\n                });\n\n                await resetGraphQLCache();\n\n                const createSecondaryObjectsResult = await apolloClient.mutate({\n                  mutation: gql`\n                    mutation CreateSecondaryObjects {\n                      secondaryObject1: createSecondaryObject(\n                        input: { fields: { someField: \"some value 1\" } }\n                      ) {\n                        secondaryObject {\n                          id\n                          objectId\n                          someField\n                        }\n                      }\n                      secondaryObject2: createSecondaryObject(\n                        input: { fields: { someField: \"some value 2\" } }\n                      ) {\n                        secondaryObject {\n                          id\n                          someField\n                        }\n                      }\n                      secondaryObject3: createSecondaryObject(\n                        input: { fields: { someField: \"some value 3\" } }\n                      ) {\n                        secondaryObject {\n                          objectId\n                          someField\n                        }\n                      }\n                      secondaryObject4: createSecondaryObject(\n                        input: { fields: { someField: \"some value 4\" } }\n                      ) {\n                        secondaryObject {\n                          id\n                          objectId\n                        }\n                      }\n                      secondaryObject5: createSecondaryObject(\n                        input: { fields: { someField: \"some value 5\" } }\n                      ) {\n                        secondaryObject {\n                          id\n                        }\n                      }\n                      secondaryObject6: createSecondaryObject(\n                        input: { fields: { someField: \"some value 6\" } }\n                      ) {\n                        secondaryObject {\n                          objectId\n                        }\n                      }\n                      secondaryObject7: createSecondaryObject(\n                        input: { fields: { someField: \"some value 7\" } }\n                      ) {\n                        secondaryObject {\n                          someField\n                        }\n                      }\n                    }\n                  `,\n                  context: {\n                    headers: {\n                      'X-Parse-Master-Key': 'test',\n                    },\n                  },\n                });\n\n                const updateSecondaryObjectsResult = await apolloClient.mutate({\n                  mutation: gql`\n                    mutation UpdateSecondaryObjects(\n                      $id1: ID!\n                      $id2: ID!\n                      $id3: ID!\n                      $id4: ID!\n                      $id5: ID!\n                      $id6: ID!\n                    ) {\n                      secondaryObject1: updateSecondaryObject(\n                        input: {\n                          id: $id1\n                          fields: { someField: \"some value 11\" }\n                        }\n                      ) {\n                        secondaryObject {\n                          id\n                          objectId\n                          someField\n                        }\n                      }\n                      secondaryObject2: updateSecondaryObject(\n                        input: {\n                          id: $id2\n                          fields: { someField: \"some value 22\" }\n                        }\n                      ) {\n                        secondaryObject {\n                          id\n                          someField\n                        }\n                      }\n                      secondaryObject3: updateSecondaryObject(\n                        input: {\n                          id: $id3\n                          fields: { someField: \"some value 33\" }\n                        }\n                      ) {\n                        secondaryObject {\n                          objectId\n                          someField\n                        }\n                      }\n                      secondaryObject4: updateSecondaryObject(\n                        input: {\n                          id: $id4\n                          fields: { someField: \"some value 44\" }\n                        }\n                      ) {\n                        secondaryObject {\n                          id\n                          objectId\n                        }\n                      }\n                      secondaryObject5: updateSecondaryObject(\n                        input: {\n                          id: $id5\n                          fields: { someField: \"some value 55\" }\n                        }\n                      ) {\n                        secondaryObject {\n                          id\n                        }\n                      }\n                      secondaryObject6: updateSecondaryObject(\n                        input: {\n                          id: $id6\n                          fields: { someField: \"some value 66\" }\n                        }\n                      ) {\n                        secondaryObject {\n                          objectId\n                        }\n                      }\n                    }\n                  `,\n                  variables: {\n                    id1:\n                      createSecondaryObjectsResult.data.secondaryObject1\n                        .secondaryObject.id,\n                    id2:\n                      createSecondaryObjectsResult.data.secondaryObject2\n                        .secondaryObject.id,\n                    id3:\n                      createSecondaryObjectsResult.data.secondaryObject3\n                        .secondaryObject.objectId,\n                    id4:\n                      createSecondaryObjectsResult.data.secondaryObject4\n                        .secondaryObject.objectId,\n                    id5:\n                      createSecondaryObjectsResult.data.secondaryObject5\n                        .secondaryObject.id,\n                    id6:\n                      createSecondaryObjectsResult.data.secondaryObject6\n                        .secondaryObject.objectId,\n                  },\n                  context: {\n                    headers: {\n                      'X-Parse-Master-Key': 'test',\n                    },\n                  },\n                });\n\n                const deleteSecondaryObjectsResult = await apolloClient.mutate({\n                  mutation: gql`\n                    mutation DeleteSecondaryObjects(\n                      $id1: ID!\n                      $id3: ID!\n                      $id5: ID!\n                      $id6: ID!\n                    ) {\n                      secondaryObject1: deleteSecondaryObject(\n                        input: { id: $id1 }\n                      ) {\n                        secondaryObject {\n                          id\n                          objectId\n                          someField\n                        }\n                      }\n                      secondaryObject3: deleteSecondaryObject(\n                        input: { id: $id3 }\n                      ) {\n                        secondaryObject {\n                          objectId\n                          someField\n                        }\n                      }\n                      secondaryObject5: deleteSecondaryObject(\n                        input: { id: $id5 }\n                      ) {\n                        secondaryObject {\n                          id\n                        }\n                      }\n                      secondaryObject6: deleteSecondaryObject(\n                        input: { id: $id6 }\n                      ) {\n                        secondaryObject {\n                          objectId\n                        }\n                      }\n                    }\n                  `,\n                  variables: {\n                    id1:\n                      updateSecondaryObjectsResult.data.secondaryObject1\n                        .secondaryObject.id,\n                    id3:\n                      updateSecondaryObjectsResult.data.secondaryObject3\n                        .secondaryObject.objectId,\n                    id5:\n                      updateSecondaryObjectsResult.data.secondaryObject5\n                        .secondaryObject.id,\n                    id6:\n                      updateSecondaryObjectsResult.data.secondaryObject6\n                        .secondaryObject.objectId,\n                  },\n                  context: {\n                    headers: {\n                      'X-Parse-Master-Key': 'test',\n                    },\n                  },\n                });\n\n                const getSecondaryObjectsResult = await apolloClient.query({\n                  query: gql`\n                    query GetSecondaryObjects($id2: ID!, $id4: ID!) {\n                      secondaryObject2: secondaryObject(id: $id2) {\n                        id\n                        objectId\n                        someField\n                      }\n                      secondaryObject4: secondaryObject(id: $id4) {\n                        objectId\n                        someField\n                      }\n                    }\n                  `,\n                  variables: {\n                    id2:\n                      updateSecondaryObjectsResult.data.secondaryObject2\n                        .secondaryObject.id,\n                    id4:\n                      updateSecondaryObjectsResult.data.secondaryObject4\n                        .secondaryObject.objectId,\n                  },\n                  context: {\n                    headers: {\n                      'X-Parse-Master-Key': 'test',\n                    },\n                  },\n                });\n\n                const findSecondaryObjectsResult = await apolloClient.query({\n                  query: gql`\n                    query FindSecondaryObjects(\n                      $id1: ID!\n                      $id2: ID!\n                      $id3: ID!\n                      $id4: ID!\n                      $id5: ID!\n                      $id6: ID!\n                    ) {\n                      secondaryObjects(\n                        where: {\n                          AND: [\n                            {\n                              OR: [\n                                { id: { equalTo: $id2 } }\n                                {\n                                  AND: [\n                                    { id: { equalTo: $id4 } }\n                                    { objectId: { equalTo: $id4 } }\n                                  ]\n                                }\n                              ]\n                            }\n                            { id: { notEqualTo: $id1 } }\n                            { id: { notEqualTo: $id3 } }\n                            { objectId: { notEqualTo: $id2 } }\n                            { objectId: { notIn: [$id5, $id6] } }\n                            { id: { in: [$id2, $id4] } }\n                          ]\n                        }\n                        order: [id_ASC, objectId_ASC]\n                      ) {\n                        edges {\n                          node {\n                            id\n                            objectId\n                            someField\n                          }\n                        }\n                        count\n                      }\n                    }\n                  `,\n                  variables: {\n                    id1:\n                      deleteSecondaryObjectsResult.data.secondaryObject1\n                        .secondaryObject.objectId,\n                    id2: getSecondaryObjectsResult.data.secondaryObject2.id,\n                    id3:\n                      deleteSecondaryObjectsResult.data.secondaryObject3\n                        .secondaryObject.objectId,\n                    id4:\n                      getSecondaryObjectsResult.data.secondaryObject4.objectId,\n                    id5:\n                      deleteSecondaryObjectsResult.data.secondaryObject5\n                        .secondaryObject.id,\n                    id6:\n                      deleteSecondaryObjectsResult.data.secondaryObject6\n                        .secondaryObject.objectId,\n                  },\n                  context: {\n                    headers: {\n                      'X-Parse-Master-Key': 'test',\n                    },\n                  },\n                });\n\n                expect(\n                  findSecondaryObjectsResult.data.secondaryObjects.count\n                ).toEqual(2);\n                expect(\n                  findSecondaryObjectsResult.data.secondaryObjects.edges\n                    .map((value) => value.node.someField)\n                    .sort()\n                ).toEqual(['some value 22', 'some value 44']);\n                expect(\n                  findSecondaryObjectsResult.data.secondaryObjects.edges[0].node\n                    .id\n                ).toBeLessThan(\n                  findSecondaryObjectsResult.data.secondaryObjects.edges[1].node\n                    .id\n                );\n                expect(\n                  findSecondaryObjectsResult.data.secondaryObjects.edges[0].node\n                    .objectId\n                ).toBeLessThan(\n                  findSecondaryObjectsResult.data.secondaryObjects.edges[1].node\n                    .objectId\n                );\n\n                const createPrimaryObjectResult = await apolloClient.mutate({\n                  mutation: gql`\n                    mutation CreatePrimaryObject(\n                      $pointer: Any\n                      $secondaryObject2: ID!\n                      $secondaryObject4: ID!\n                    ) {\n                      createPrimaryObject(\n                        input: {\n                          fields: {\n                            stringField: \"some value\"\n                            arrayField: [1, \"abc\", $pointer]\n                            pointerField: { link: $secondaryObject2 }\n                            relationField: {\n                              add: [$secondaryObject2, $secondaryObject4]\n                            }\n                          }\n                        }\n                      ) {\n                        primaryObject {\n                          id\n                          stringField\n                          arrayField {\n                            ... on Element {\n                              value\n                            }\n                            ... on SecondaryObject {\n                              someField\n                            }\n                          }\n                          pointerField {\n                            id\n                            objectId\n                            someField\n                          }\n                          relationField {\n                            edges {\n                              node {\n                                id\n                                objectId\n                                someField\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  `,\n                  variables: {\n                    pointer: {\n                      __type: 'Pointer',\n                      className: 'SecondaryObject',\n                      objectId:\n                        getSecondaryObjectsResult.data.secondaryObject4\n                          .objectId,\n                    },\n                    secondaryObject2:\n                      getSecondaryObjectsResult.data.secondaryObject2.id,\n                    secondaryObject4:\n                      getSecondaryObjectsResult.data.secondaryObject4.objectId,\n                  },\n                  context: {\n                    headers: {\n                      'X-Parse-Master-Key': 'test',\n                    },\n                  },\n                });\n\n                const updatePrimaryObjectResult = await apolloClient.mutate({\n                  mutation: gql`\n                    mutation UpdatePrimaryObject(\n                      $id: ID!\n                      $secondaryObject2: ID!\n                      $secondaryObject4: ID!\n                    ) {\n                      updatePrimaryObject(\n                        input: {\n                          id: $id\n                          fields: {\n                            pointerField: { link: $secondaryObject4 }\n                            relationField: {\n                              remove: [$secondaryObject2, $secondaryObject4]\n                            }\n                          }\n                        }\n                      ) {\n                        primaryObject {\n                          id\n                          stringField\n                          arrayField {\n                            ... on Element {\n                              value\n                            }\n                            ... on SecondaryObject {\n                              someField\n                            }\n                          }\n                          pointerField {\n                            id\n                            objectId\n                            someField\n                          }\n                          relationField {\n                            edges {\n                              node {\n                                id\n                                objectId\n                                someField\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  `,\n                  variables: {\n                    id:\n                      createPrimaryObjectResult.data.createPrimaryObject\n                        .primaryObject.id,\n                    secondaryObject2:\n                      getSecondaryObjectsResult.data.secondaryObject2.id,\n                    secondaryObject4:\n                      getSecondaryObjectsResult.data.secondaryObject4.objectId,\n                  },\n                  context: {\n                    headers: {\n                      'X-Parse-Master-Key': 'test',\n                    },\n                  },\n                });\n\n                expect(\n                  createPrimaryObjectResult.data.createPrimaryObject\n                    .primaryObject.stringField\n                ).toEqual('some value');\n                expect(\n                  createPrimaryObjectResult.data.createPrimaryObject\n                    .primaryObject.arrayField\n                ).toEqual([\n                  { __typename: 'Element', value: 1 },\n                  { __typename: 'Element', value: 'abc' },\n                  { __typename: 'SecondaryObject', someField: 'some value 44' },\n                ]);\n                expect(\n                  createPrimaryObjectResult.data.createPrimaryObject\n                    .primaryObject.pointerField.someField\n                ).toEqual('some value 22');\n                expect(\n                  createPrimaryObjectResult.data.createPrimaryObject.primaryObject.relationField.edges\n                    .map((value) => value.node.someField)\n                    .sort()\n                ).toEqual(['some value 22', 'some value 44']);\n                expect(\n                  updatePrimaryObjectResult.data.updatePrimaryObject\n                    .primaryObject.stringField\n                ).toEqual('some value');\n                expect(\n                  updatePrimaryObjectResult.data.updatePrimaryObject\n                    .primaryObject.arrayField\n                ).toEqual([\n                  { __typename: 'Element', value: 1 },\n                  { __typename: 'Element', value: 'abc' },\n                  { __typename: 'SecondaryObject', someField: 'some value 44' },\n                ]);\n                expect(\n                  updatePrimaryObjectResult.data.updatePrimaryObject\n                    .primaryObject.pointerField.someField\n                ).toEqual('some value 44');\n                expect(\n                  updatePrimaryObjectResult.data.updatePrimaryObject\n                    .primaryObject.relationField.edges\n                ).toEqual([]);\n              } catch (e) {\n                handleError(e);\n              }\n            }\n          );\n        });\n      });\n\n      describe('Class Schema Mutations', () => {\n        it('should create a new class', async () => {\n          try {\n            const result = await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  class1: createClass(\n                    input: { name: \"Class1\", clientMutationId: \"cmid1\" }\n                  ) {\n                    clientMutationId\n                    class {\n                      name\n                      schemaFields {\n                        name\n                        __typename\n                      }\n                    }\n                  }\n                  class2: createClass(\n                    input: {\n                      name: \"Class2\"\n                      schemaFields: null\n                      clientMutationId: \"cmid2\"\n                    }\n                  ) {\n                    clientMutationId\n                    class {\n                      name\n                      schemaFields {\n                        name\n                        __typename\n                      }\n                    }\n                  }\n                  class3: createClass(\n                    input: {\n                      name: \"Class3\"\n                      schemaFields: {}\n                      clientMutationId: \"cmid3\"\n                    }\n                  ) {\n                    clientMutationId\n                    class {\n                      name\n                      schemaFields {\n                        name\n                        __typename\n                      }\n                    }\n                  }\n                  class4: createClass(\n                    input: {\n                      name: \"Class4\"\n                      schemaFields: {\n                        addStrings: null\n                        addNumbers: null\n                        addBooleans: null\n                        addArrays: null\n                        addObjects: null\n                        addDates: null\n                        addFiles: null\n                        addGeoPoint: null\n                        addPolygons: null\n                        addBytes: null\n                        addPointers: null\n                        addRelations: null\n                      }\n                      clientMutationId: \"cmid4\"\n                    }\n                  ) {\n                    clientMutationId\n                    class {\n                      name\n                      schemaFields {\n                        name\n                        __typename\n                      }\n                    }\n                  }\n                  class5: createClass(\n                    input: {\n                      name: \"Class5\"\n                      schemaFields: {\n                        addStrings: []\n                        addNumbers: []\n                        addBooleans: []\n                        addArrays: []\n                        addObjects: []\n                        addDates: []\n                        addFiles: []\n                        addPolygons: []\n                        addBytes: []\n                        addPointers: []\n                        addRelations: []\n                      }\n                      clientMutationId: \"cmid5\"\n                    }\n                  ) {\n                    clientMutationId\n                    class {\n                      name\n                      schemaFields {\n                        name\n                        __typename\n                      }\n                    }\n                  }\n                  class6: createClass(\n                    input: {\n                      name: \"Class6\"\n                      schemaFields: {\n                        addStrings: [\n                          { name: \"stringField1\" }\n                          { name: \"stringField2\" }\n                          { name: \"stringField3\" }\n                        ]\n                        addNumbers: [\n                          { name: \"numberField1\" }\n                          { name: \"numberField2\" }\n                          { name: \"numberField3\" }\n                        ]\n                        addBooleans: [\n                          { name: \"booleanField1\" }\n                          { name: \"booleanField2\" }\n                          { name: \"booleanField3\" }\n                        ]\n                        addArrays: [\n                          { name: \"arrayField1\" }\n                          { name: \"arrayField2\" }\n                          { name: \"arrayField3\" }\n                        ]\n                        addObjects: [\n                          { name: \"objectField1\" }\n                          { name: \"objectField2\" }\n                          { name: \"objectField3\" }\n                        ]\n                        addDates: [\n                          { name: \"dateField1\" }\n                          { name: \"dateField2\" }\n                          { name: \"dateField3\" }\n                        ]\n                        addFiles: [\n                          { name: \"fileField1\" }\n                          { name: \"fileField2\" }\n                          { name: \"fileField3\" }\n                        ]\n                        addGeoPoint: { name: \"geoPointField\" }\n                        addPolygons: [\n                          { name: \"polygonField1\" }\n                          { name: \"polygonField2\" }\n                          { name: \"polygonField3\" }\n                        ]\n                        addBytes: [\n                          { name: \"bytesField1\" }\n                          { name: \"bytesField2\" }\n                          { name: \"bytesField3\" }\n                        ]\n                        addPointers: [\n                          { name: \"pointerField1\", targetClassName: \"Class1\" }\n                          { name: \"pointerField2\", targetClassName: \"Class6\" }\n                          { name: \"pointerField3\", targetClassName: \"Class2\" }\n                        ]\n                        addRelations: [\n                          { name: \"relationField1\", targetClassName: \"Class1\" }\n                          { name: \"relationField2\", targetClassName: \"Class6\" }\n                          { name: \"relationField3\", targetClassName: \"Class2\" }\n                        ]\n                        remove: [\n                          { name: \"stringField3\" }\n                          { name: \"numberField3\" }\n                          { name: \"booleanField3\" }\n                          { name: \"arrayField3\" }\n                          { name: \"objectField3\" }\n                          { name: \"dateField3\" }\n                          { name: \"fileField3\" }\n                          { name: \"polygonField3\" }\n                          { name: \"bytesField3\" }\n                          { name: \"pointerField3\" }\n                          { name: \"relationField3\" }\n                          { name: \"doesNotExist\" }\n                        ]\n                      }\n                      clientMutationId: \"cmid6\"\n                    }\n                  ) {\n                    clientMutationId\n                    class {\n                      name\n                      schemaFields {\n                        name\n                        __typename\n                        ... on SchemaPointerField {\n                          targetClassName\n                        }\n                        ... on SchemaRelationField {\n                          targetClassName\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n            const classes = Object.keys(result.data).map((fieldName) => ({\n              clientMutationId: result.data[fieldName].clientMutationId,\n              class: {\n                name: result.data[fieldName].class.name,\n                schemaFields: result.data[\n                  fieldName\n                ].class.schemaFields.sort((a, b) => (a.name > b.name ? 1 : -1)),\n                __typename: result.data[fieldName].class.__typename,\n              },\n              __typename: result.data[fieldName].__typename,\n            }));\n            expect(classes).toEqual([\n              {\n                clientMutationId: 'cmid1',\n                class: {\n                  name: 'Class1',\n                  schemaFields: [\n                    { name: 'ACL', __typename: 'SchemaACLField' },\n                    { name: 'createdAt', __typename: 'SchemaDateField' },\n                    { name: 'objectId', __typename: 'SchemaStringField' },\n                    { name: 'updatedAt', __typename: 'SchemaDateField' },\n                  ],\n                  __typename: 'Class',\n                },\n                __typename: 'CreateClassPayload',\n              },\n              {\n                clientMutationId: 'cmid2',\n                class: {\n                  name: 'Class2',\n                  schemaFields: [\n                    { name: 'ACL', __typename: 'SchemaACLField' },\n                    { name: 'createdAt', __typename: 'SchemaDateField' },\n                    { name: 'objectId', __typename: 'SchemaStringField' },\n                    { name: 'updatedAt', __typename: 'SchemaDateField' },\n                  ],\n                  __typename: 'Class',\n                },\n                __typename: 'CreateClassPayload',\n              },\n              {\n                clientMutationId: 'cmid3',\n                class: {\n                  name: 'Class3',\n                  schemaFields: [\n                    { name: 'ACL', __typename: 'SchemaACLField' },\n                    { name: 'createdAt', __typename: 'SchemaDateField' },\n                    { name: 'objectId', __typename: 'SchemaStringField' },\n                    { name: 'updatedAt', __typename: 'SchemaDateField' },\n                  ],\n                  __typename: 'Class',\n                },\n                __typename: 'CreateClassPayload',\n              },\n              {\n                clientMutationId: 'cmid4',\n                class: {\n                  name: 'Class4',\n                  schemaFields: [\n                    { name: 'ACL', __typename: 'SchemaACLField' },\n                    { name: 'createdAt', __typename: 'SchemaDateField' },\n                    { name: 'objectId', __typename: 'SchemaStringField' },\n                    { name: 'updatedAt', __typename: 'SchemaDateField' },\n                  ],\n                  __typename: 'Class',\n                },\n                __typename: 'CreateClassPayload',\n              },\n              {\n                clientMutationId: 'cmid5',\n                class: {\n                  name: 'Class5',\n                  schemaFields: [\n                    { name: 'ACL', __typename: 'SchemaACLField' },\n                    { name: 'createdAt', __typename: 'SchemaDateField' },\n                    { name: 'objectId', __typename: 'SchemaStringField' },\n                    { name: 'updatedAt', __typename: 'SchemaDateField' },\n                  ],\n                  __typename: 'Class',\n                },\n                __typename: 'CreateClassPayload',\n              },\n              {\n                clientMutationId: 'cmid6',\n                class: {\n                  name: 'Class6',\n                  schemaFields: [\n                    { name: 'ACL', __typename: 'SchemaACLField' },\n                    { name: 'arrayField1', __typename: 'SchemaArrayField' },\n                    { name: 'arrayField2', __typename: 'SchemaArrayField' },\n                    { name: 'booleanField1', __typename: 'SchemaBooleanField' },\n                    { name: 'booleanField2', __typename: 'SchemaBooleanField' },\n                    { name: 'bytesField1', __typename: 'SchemaBytesField' },\n                    { name: 'bytesField2', __typename: 'SchemaBytesField' },\n                    { name: 'createdAt', __typename: 'SchemaDateField' },\n                    { name: 'dateField1', __typename: 'SchemaDateField' },\n                    { name: 'dateField2', __typename: 'SchemaDateField' },\n                    { name: 'fileField1', __typename: 'SchemaFileField' },\n                    { name: 'fileField2', __typename: 'SchemaFileField' },\n                    {\n                      name: 'geoPointField',\n                      __typename: 'SchemaGeoPointField',\n                    },\n                    { name: 'numberField1', __typename: 'SchemaNumberField' },\n                    { name: 'numberField2', __typename: 'SchemaNumberField' },\n                    { name: 'objectField1', __typename: 'SchemaObjectField' },\n                    { name: 'objectField2', __typename: 'SchemaObjectField' },\n                    { name: 'objectId', __typename: 'SchemaStringField' },\n                    {\n                      name: 'pointerField1',\n                      __typename: 'SchemaPointerField',\n                      targetClassName: 'Class1',\n                    },\n                    {\n                      name: 'pointerField2',\n                      __typename: 'SchemaPointerField',\n                      targetClassName: 'Class6',\n                    },\n                    { name: 'polygonField1', __typename: 'SchemaPolygonField' },\n                    { name: 'polygonField2', __typename: 'SchemaPolygonField' },\n                    {\n                      name: 'relationField1',\n                      __typename: 'SchemaRelationField',\n                      targetClassName: 'Class1',\n                    },\n                    {\n                      name: 'relationField2',\n                      __typename: 'SchemaRelationField',\n                      targetClassName: 'Class6',\n                    },\n                    { name: 'stringField1', __typename: 'SchemaStringField' },\n                    { name: 'stringField2', __typename: 'SchemaStringField' },\n                    { name: 'updatedAt', __typename: 'SchemaDateField' },\n                  ],\n                  __typename: 'Class',\n                },\n                __typename: 'CreateClassPayload',\n              },\n            ]);\n\n            const findResult = await apolloClient.query({\n              query: gql`\n                query {\n                  classes {\n                    name\n                    schemaFields {\n                      name\n                      __typename\n                      ... on SchemaPointerField {\n                        targetClassName\n                      }\n                      ... on SchemaRelationField {\n                        targetClassName\n                      }\n                    }\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n            findResult.data.classes = findResult.data.classes\n              .filter((schemaClass) => !schemaClass.name.startsWith('_'))\n              .sort((a, b) => (a.name > b.name ? 1 : -1));\n            findResult.data.classes.forEach((schemaClass) => {\n              schemaClass.schemaFields = schemaClass.schemaFields.sort((a, b) =>\n                a.name > b.name ? 1 : -1\n              );\n            });\n            expect(findResult.data.classes).toEqual([\n              {\n                name: 'Class1',\n                schemaFields: [\n                  { name: 'ACL', __typename: 'SchemaACLField' },\n                  { name: 'createdAt', __typename: 'SchemaDateField' },\n                  { name: 'objectId', __typename: 'SchemaStringField' },\n                  { name: 'updatedAt', __typename: 'SchemaDateField' },\n                ],\n                __typename: 'Class',\n              },\n              {\n                name: 'Class2',\n                schemaFields: [\n                  { name: 'ACL', __typename: 'SchemaACLField' },\n                  { name: 'createdAt', __typename: 'SchemaDateField' },\n                  { name: 'objectId', __typename: 'SchemaStringField' },\n                  { name: 'updatedAt', __typename: 'SchemaDateField' },\n                ],\n                __typename: 'Class',\n              },\n              {\n                name: 'Class3',\n                schemaFields: [\n                  { name: 'ACL', __typename: 'SchemaACLField' },\n                  { name: 'createdAt', __typename: 'SchemaDateField' },\n                  { name: 'objectId', __typename: 'SchemaStringField' },\n                  { name: 'updatedAt', __typename: 'SchemaDateField' },\n                ],\n                __typename: 'Class',\n              },\n              {\n                name: 'Class4',\n                schemaFields: [\n                  { name: 'ACL', __typename: 'SchemaACLField' },\n                  { name: 'createdAt', __typename: 'SchemaDateField' },\n                  { name: 'objectId', __typename: 'SchemaStringField' },\n                  { name: 'updatedAt', __typename: 'SchemaDateField' },\n                ],\n                __typename: 'Class',\n              },\n              {\n                name: 'Class5',\n                schemaFields: [\n                  { name: 'ACL', __typename: 'SchemaACLField' },\n                  { name: 'createdAt', __typename: 'SchemaDateField' },\n                  { name: 'objectId', __typename: 'SchemaStringField' },\n                  { name: 'updatedAt', __typename: 'SchemaDateField' },\n                ],\n                __typename: 'Class',\n              },\n              {\n                name: 'Class6',\n                schemaFields: [\n                  { name: 'ACL', __typename: 'SchemaACLField' },\n                  { name: 'arrayField1', __typename: 'SchemaArrayField' },\n                  { name: 'arrayField2', __typename: 'SchemaArrayField' },\n                  { name: 'booleanField1', __typename: 'SchemaBooleanField' },\n                  { name: 'booleanField2', __typename: 'SchemaBooleanField' },\n                  { name: 'bytesField1', __typename: 'SchemaBytesField' },\n                  { name: 'bytesField2', __typename: 'SchemaBytesField' },\n                  { name: 'createdAt', __typename: 'SchemaDateField' },\n                  { name: 'dateField1', __typename: 'SchemaDateField' },\n                  { name: 'dateField2', __typename: 'SchemaDateField' },\n                  { name: 'fileField1', __typename: 'SchemaFileField' },\n                  { name: 'fileField2', __typename: 'SchemaFileField' },\n                  {\n                    name: 'geoPointField',\n                    __typename: 'SchemaGeoPointField',\n                  },\n                  { name: 'numberField1', __typename: 'SchemaNumberField' },\n                  { name: 'numberField2', __typename: 'SchemaNumberField' },\n                  { name: 'objectField1', __typename: 'SchemaObjectField' },\n                  { name: 'objectField2', __typename: 'SchemaObjectField' },\n                  { name: 'objectId', __typename: 'SchemaStringField' },\n                  {\n                    name: 'pointerField1',\n                    __typename: 'SchemaPointerField',\n                    targetClassName: 'Class1',\n                  },\n                  {\n                    name: 'pointerField2',\n                    __typename: 'SchemaPointerField',\n                    targetClassName: 'Class6',\n                  },\n                  { name: 'polygonField1', __typename: 'SchemaPolygonField' },\n                  { name: 'polygonField2', __typename: 'SchemaPolygonField' },\n                  {\n                    name: 'relationField1',\n                    __typename: 'SchemaRelationField',\n                    targetClassName: 'Class1',\n                  },\n                  {\n                    name: 'relationField2',\n                    __typename: 'SchemaRelationField',\n                    targetClassName: 'Class6',\n                  },\n                  { name: 'stringField1', __typename: 'SchemaStringField' },\n                  { name: 'stringField2', __typename: 'SchemaStringField' },\n                  { name: 'updatedAt', __typename: 'SchemaDateField' },\n                ],\n                __typename: 'Class',\n              },\n            ]);\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should require master key to create a new class', async () => {\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  createClass(input: { name: \"SomeClass\" }) {\n                    clientMutationId\n                  }\n                }\n              `,\n            });\n            fail('should fail');\n          } catch (e) {\n            expect(e.graphQLErrors[0].extensions.code).toEqual(\n              Parse.Error.OPERATION_FORBIDDEN\n            );\n            expect(e.graphQLErrors[0].message).toEqual(\n              'unauthorized: master key is required'\n            );\n          }\n        });\n\n        it('should not allow duplicated field names when creating', async () => {\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  createClass(\n                    input: {\n                      name: \"SomeClass\"\n                      schemaFields: {\n                        addStrings: [{ name: \"someField\" }]\n                        addNumbers: [{ name: \"someField\" }]\n                      }\n                    }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n            fail('should fail');\n          } catch (e) {\n            expect(e.graphQLErrors[0].extensions.code).toEqual(\n              Parse.Error.INVALID_KEY_NAME\n            );\n            expect(e.graphQLErrors[0].message).toEqual(\n              'Duplicated field name: someField'\n            );\n          }\n        });\n\n        it('should update an existing class', async () => {\n          try {\n            const clientMutationId = uuidv4();\n            const result = await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  createClass(\n                    input: {\n                      name: \"MyNewClass\"\n                      schemaFields: { addStrings: [{ name: \"willBeRemoved\" }] }\n                    }\n                  ) {\n                    class {\n                      name\n                      schemaFields {\n                        name\n                        __typename\n                      }\n                    }\n                  }\n                  updateClass(input: {\n                    clientMutationId: \"${clientMutationId}\"\n                    name: \"MyNewClass\"\n                    schemaFields: {\n                      addStrings: [\n                        { name: \"stringField1\" }\n                        { name: \"stringField2\" }\n                        { name: \"stringField3\" }\n                      ]\n                      addNumbers: [\n                        { name: \"numberField1\" }\n                        { name: \"numberField2\" }\n                        { name: \"numberField3\" }\n                      ]\n                      addBooleans: [\n                        { name: \"booleanField1\" }\n                        { name: \"booleanField2\" }\n                        { name: \"booleanField3\" }\n                      ]\n                      addArrays: [\n                        { name: \"arrayField1\" }\n                        { name: \"arrayField2\" }\n                        { name: \"arrayField3\" }\n                      ]\n                      addObjects: [\n                        { name: \"objectField1\" }\n                        { name: \"objectField2\" }\n                        { name: \"objectField3\" }\n                      ]\n                      addDates: [\n                        { name: \"dateField1\" }\n                        { name: \"dateField2\" }\n                        { name: \"dateField3\" }\n                      ]\n                      addFiles: [\n                        { name: \"fileField1\" }\n                        { name: \"fileField2\" }\n                        { name: \"fileField3\" }\n                      ]\n                      addGeoPoint: { name: \"geoPointField\" }\n                      addPolygons: [\n                        { name: \"polygonField1\" }\n                        { name: \"polygonField2\" }\n                        { name: \"polygonField3\" }\n                      ]\n                      addBytes: [\n                        { name: \"bytesField1\" }\n                        { name: \"bytesField2\" }\n                        { name: \"bytesField3\" }\n                      ]\n                      addPointers: [\n                        { name: \"pointerField1\", targetClassName: \"Class1\" }\n                        { name: \"pointerField2\", targetClassName: \"Class6\" }\n                        { name: \"pointerField3\", targetClassName: \"Class2\" }\n                      ]\n                      addRelations: [\n                        { name: \"relationField1\", targetClassName: \"Class1\" }\n                        { name: \"relationField2\", targetClassName: \"Class6\" }\n                        { name: \"relationField3\", targetClassName: \"Class2\" }\n                      ]\n                      remove: [\n                        { name: \"willBeRemoved\" }\n                        { name: \"stringField3\" }\n                        { name: \"numberField3\" }\n                        { name: \"booleanField3\" }\n                        { name: \"arrayField3\" }\n                        { name: \"objectField3\" }\n                        { name: \"dateField3\" }\n                        { name: \"fileField3\" }\n                        { name: \"polygonField3\" }\n                        { name: \"bytesField3\" }\n                        { name: \"pointerField3\" }\n                        { name: \"relationField3\" }\n                        { name: \"doesNotExist\" }\n                      ]\n                    }\n                  }) {\n                    clientMutationId\n                    class {\n                      name\n                      schemaFields {\n                        name\n                        __typename\n                        ... on SchemaPointerField {\n                          targetClassName\n                        }\n                        ... on SchemaRelationField {\n                          targetClassName\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n            result.data.createClass.class.schemaFields = result.data.createClass.class.schemaFields.sort(\n              (a, b) => (a.name > b.name ? 1 : -1)\n            );\n            result.data.updateClass.class.schemaFields = result.data.updateClass.class.schemaFields.sort(\n              (a, b) => (a.name > b.name ? 1 : -1)\n            );\n            expect(result).toEqual({\n              data: {\n                createClass: {\n                  class: {\n                    name: 'MyNewClass',\n                    schemaFields: [\n                      { name: 'ACL', __typename: 'SchemaACLField' },\n                      { name: 'createdAt', __typename: 'SchemaDateField' },\n                      { name: 'objectId', __typename: 'SchemaStringField' },\n                      { name: 'updatedAt', __typename: 'SchemaDateField' },\n                      {\n                        name: 'willBeRemoved',\n                        __typename: 'SchemaStringField',\n                      },\n                    ],\n                    __typename: 'Class',\n                  },\n                  __typename: 'CreateClassPayload',\n                },\n                updateClass: {\n                  clientMutationId,\n                  class: {\n                    name: 'MyNewClass',\n                    schemaFields: [\n                      { name: 'ACL', __typename: 'SchemaACLField' },\n                      { name: 'arrayField1', __typename: 'SchemaArrayField' },\n                      { name: 'arrayField2', __typename: 'SchemaArrayField' },\n                      {\n                        name: 'booleanField1',\n                        __typename: 'SchemaBooleanField',\n                      },\n                      {\n                        name: 'booleanField2',\n                        __typename: 'SchemaBooleanField',\n                      },\n                      { name: 'bytesField1', __typename: 'SchemaBytesField' },\n                      { name: 'bytesField2', __typename: 'SchemaBytesField' },\n                      { name: 'createdAt', __typename: 'SchemaDateField' },\n                      { name: 'dateField1', __typename: 'SchemaDateField' },\n                      { name: 'dateField2', __typename: 'SchemaDateField' },\n                      { name: 'fileField1', __typename: 'SchemaFileField' },\n                      { name: 'fileField2', __typename: 'SchemaFileField' },\n                      {\n                        name: 'geoPointField',\n                        __typename: 'SchemaGeoPointField',\n                      },\n                      { name: 'numberField1', __typename: 'SchemaNumberField' },\n                      { name: 'numberField2', __typename: 'SchemaNumberField' },\n                      { name: 'objectField1', __typename: 'SchemaObjectField' },\n                      { name: 'objectField2', __typename: 'SchemaObjectField' },\n                      { name: 'objectId', __typename: 'SchemaStringField' },\n                      {\n                        name: 'pointerField1',\n                        __typename: 'SchemaPointerField',\n                        targetClassName: 'Class1',\n                      },\n                      {\n                        name: 'pointerField2',\n                        __typename: 'SchemaPointerField',\n                        targetClassName: 'Class6',\n                      },\n                      {\n                        name: 'polygonField1',\n                        __typename: 'SchemaPolygonField',\n                      },\n                      {\n                        name: 'polygonField2',\n                        __typename: 'SchemaPolygonField',\n                      },\n                      {\n                        name: 'relationField1',\n                        __typename: 'SchemaRelationField',\n                        targetClassName: 'Class1',\n                      },\n                      {\n                        name: 'relationField2',\n                        __typename: 'SchemaRelationField',\n                        targetClassName: 'Class6',\n                      },\n                      { name: 'stringField1', __typename: 'SchemaStringField' },\n                      { name: 'stringField2', __typename: 'SchemaStringField' },\n                      { name: 'updatedAt', __typename: 'SchemaDateField' },\n                    ],\n                    __typename: 'Class',\n                  },\n                  __typename: 'UpdateClassPayload',\n                },\n              },\n            });\n\n            const getResult = await apolloClient.query({\n              query: gql`\n                query {\n                  class(name: \"MyNewClass\") {\n                    name\n                    schemaFields {\n                      name\n                      __typename\n                      ... on SchemaPointerField {\n                        targetClassName\n                      }\n                      ... on SchemaRelationField {\n                        targetClassName\n                      }\n                    }\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n            getResult.data.class.schemaFields = getResult.data.class.schemaFields.sort(\n              (a, b) => (a.name > b.name ? 1 : -1)\n            );\n            expect(getResult.data).toEqual({\n              class: {\n                name: 'MyNewClass',\n                schemaFields: [\n                  { name: 'ACL', __typename: 'SchemaACLField' },\n                  { name: 'arrayField1', __typename: 'SchemaArrayField' },\n                  { name: 'arrayField2', __typename: 'SchemaArrayField' },\n                  { name: 'booleanField1', __typename: 'SchemaBooleanField' },\n                  { name: 'booleanField2', __typename: 'SchemaBooleanField' },\n                  { name: 'bytesField1', __typename: 'SchemaBytesField' },\n                  { name: 'bytesField2', __typename: 'SchemaBytesField' },\n                  { name: 'createdAt', __typename: 'SchemaDateField' },\n                  { name: 'dateField1', __typename: 'SchemaDateField' },\n                  { name: 'dateField2', __typename: 'SchemaDateField' },\n                  { name: 'fileField1', __typename: 'SchemaFileField' },\n                  { name: 'fileField2', __typename: 'SchemaFileField' },\n                  {\n                    name: 'geoPointField',\n                    __typename: 'SchemaGeoPointField',\n                  },\n                  { name: 'numberField1', __typename: 'SchemaNumberField' },\n                  { name: 'numberField2', __typename: 'SchemaNumberField' },\n                  { name: 'objectField1', __typename: 'SchemaObjectField' },\n                  { name: 'objectField2', __typename: 'SchemaObjectField' },\n                  { name: 'objectId', __typename: 'SchemaStringField' },\n                  {\n                    name: 'pointerField1',\n                    __typename: 'SchemaPointerField',\n                    targetClassName: 'Class1',\n                  },\n                  {\n                    name: 'pointerField2',\n                    __typename: 'SchemaPointerField',\n                    targetClassName: 'Class6',\n                  },\n                  { name: 'polygonField1', __typename: 'SchemaPolygonField' },\n                  { name: 'polygonField2', __typename: 'SchemaPolygonField' },\n                  {\n                    name: 'relationField1',\n                    __typename: 'SchemaRelationField',\n                    targetClassName: 'Class1',\n                  },\n                  {\n                    name: 'relationField2',\n                    __typename: 'SchemaRelationField',\n                    targetClassName: 'Class6',\n                  },\n                  { name: 'stringField1', __typename: 'SchemaStringField' },\n                  { name: 'stringField2', __typename: 'SchemaStringField' },\n                  { name: 'updatedAt', __typename: 'SchemaDateField' },\n                ],\n                __typename: 'Class',\n              },\n            });\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should require master key to update an existing class', async () => {\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  createClass(input: { name: \"SomeClass\" }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n          } catch (e) {\n            handleError(e);\n          }\n\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  updateClass(input: { name: \"SomeClass\" }) {\n                    clientMutationId\n                  }\n                }\n              `,\n            });\n            fail('should fail');\n          } catch (e) {\n            expect(e.graphQLErrors[0].extensions.code).toEqual(\n              Parse.Error.OPERATION_FORBIDDEN\n            );\n            expect(e.graphQLErrors[0].message).toEqual(\n              'unauthorized: master key is required'\n            );\n          }\n        });\n\n        it('should not allow duplicated field names when updating', async () => {\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  createClass(\n                    input: {\n                      name: \"SomeClass\"\n                      schemaFields: { addStrings: [{ name: \"someField\" }] }\n                    }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n          } catch (e) {\n            handleError(e);\n          }\n\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  updateClass(\n                    input: {\n                      name: \"SomeClass\"\n                      schemaFields: { addNumbers: [{ name: \"someField\" }] }\n                    }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n            fail('should fail');\n          } catch (e) {\n            expect(e.graphQLErrors[0].extensions.code).toEqual(\n              Parse.Error.INVALID_KEY_NAME\n            );\n            expect(e.graphQLErrors[0].message).toEqual(\n              'Duplicated field name: someField'\n            );\n          }\n        });\n\n        it('should fail if updating an inexistent class', async () => {\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  updateClass(\n                    input: {\n                      name: \"SomeInexistentClass\"\n                      schemaFields: { addNumbers: [{ name: \"someField\" }] }\n                    }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n            fail('should fail');\n          } catch (e) {\n            expect(e.graphQLErrors[0].extensions.code).toEqual(\n              Parse.Error.INVALID_CLASS_NAME\n            );\n            expect(e.graphQLErrors[0].message).toEqual(\n              'Class SomeInexistentClass does not exist.'\n            );\n          }\n        });\n\n        it('should delete an existing class', async () => {\n          try {\n            const clientMutationId = uuidv4();\n            const result = await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  createClass(\n                    input: {\n                      name: \"MyNewClass\"\n                      schemaFields: { addStrings: [{ name: \"willBeRemoved\" }] }\n                    }\n                  ) {\n                    class {\n                      name\n                      schemaFields {\n                        name\n                        __typename\n                      }\n                    }\n                  }\n                  deleteClass(input: { clientMutationId: \"${clientMutationId}\" name: \"MyNewClass\" }) {\n                    clientMutationId\n                    class {\n                      name\n                      schemaFields {\n                        name\n                      }\n                    }\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n            result.data.createClass.class.schemaFields = result.data.createClass.class.schemaFields.sort(\n              (a, b) => (a.name > b.name ? 1 : -1)\n            );\n            result.data.deleteClass.class.schemaFields = result.data.deleteClass.class.schemaFields.sort(\n              (a, b) => (a.name > b.name ? 1 : -1)\n            );\n            expect(result).toEqual({\n              data: {\n                createClass: {\n                  class: {\n                    name: 'MyNewClass',\n                    schemaFields: [\n                      { name: 'ACL', __typename: 'SchemaACLField' },\n                      { name: 'createdAt', __typename: 'SchemaDateField' },\n                      { name: 'objectId', __typename: 'SchemaStringField' },\n                      { name: 'updatedAt', __typename: 'SchemaDateField' },\n                      {\n                        name: 'willBeRemoved',\n                        __typename: 'SchemaStringField',\n                      },\n                    ],\n                    __typename: 'Class',\n                  },\n                  __typename: 'CreateClassPayload',\n                },\n                deleteClass: {\n                  clientMutationId,\n                  class: {\n                    name: 'MyNewClass',\n                    schemaFields: [\n                      { name: 'ACL', __typename: 'SchemaACLField' },\n                      { name: 'createdAt', __typename: 'SchemaDateField' },\n                      { name: 'objectId', __typename: 'SchemaStringField' },\n                      { name: 'updatedAt', __typename: 'SchemaDateField' },\n                      {\n                        name: 'willBeRemoved',\n                        __typename: 'SchemaStringField',\n                      },\n                    ],\n                    __typename: 'Class',\n                  },\n                  __typename: 'DeleteClassPayload',\n                },\n              },\n            });\n\n            try {\n              await apolloClient.query({\n                query: gql`\n                  query {\n                    class(name: \"MyNewClass\") {\n                      name\n                    }\n                  }\n                `,\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test',\n                  },\n                },\n              });\n              fail('should fail');\n            } catch (e) {\n              expect(e.graphQLErrors[0].extensions.code).toEqual(\n                Parse.Error.INVALID_CLASS_NAME\n              );\n              expect(e.graphQLErrors[0].message).toEqual(\n                'Class MyNewClass does not exist.'\n              );\n            }\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should require master key to delete an existing class', async () => {\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  createClass(input: { name: \"SomeClass\" }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n          } catch (e) {\n            handleError(e);\n          }\n\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  deleteClass(input: { name: \"SomeClass\" }) {\n                    clientMutationId\n                  }\n                }\n              `,\n            });\n            fail('should fail');\n          } catch (e) {\n            expect(e.graphQLErrors[0].extensions.code).toEqual(\n              Parse.Error.OPERATION_FORBIDDEN\n            );\n            expect(e.graphQLErrors[0].message).toEqual(\n              'unauthorized: master key is required'\n            );\n          }\n        });\n\n        it('should fail if deleting an inexistent class', async () => {\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  deleteClass(input: { name: \"SomeInexistentClass\" }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n            fail('should fail');\n          } catch (e) {\n            expect(e.graphQLErrors[0].extensions.code).toEqual(\n              Parse.Error.INVALID_CLASS_NAME\n            );\n            expect(e.graphQLErrors[0].message).toEqual(\n              'Class SomeInexistentClass does not exist.'\n            );\n          }\n        });\n\n        it('should require master key to get an existing class', async () => {\n          try {\n            await apolloClient.query({\n              query: gql`\n                query {\n                  class(name: \"_User\") {\n                    name\n                  }\n                }\n              `,\n            });\n            fail('should fail');\n          } catch (e) {\n            expect(e.graphQLErrors[0].extensions.code).toEqual(\n              Parse.Error.OPERATION_FORBIDDEN\n            );\n            expect(e.graphQLErrors[0].message).toEqual(\n              'unauthorized: master key is required'\n            );\n          }\n        });\n\n        it('should require master key to find the existing classes', async () => {\n          try {\n            await apolloClient.query({\n              query: gql`\n                query {\n                  classes {\n                    name\n                  }\n                }\n              `,\n            });\n            fail('should fail');\n          } catch (e) {\n            expect(e.graphQLErrors[0].extensions.code).toEqual(\n              Parse.Error.OPERATION_FORBIDDEN\n            );\n            expect(e.graphQLErrors[0].message).toEqual(\n              'unauthorized: master key is required'\n            );\n          }\n        });\n      });\n\n      describe('Objects Queries', () => {\n        describe('Get', () => {\n          it('should return a class object using class specific query', async () => {\n            const obj = new Parse.Object('Customer');\n            obj.set('someField', 'someValue');\n            await obj.save();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const result = (\n              await apolloClient.query({\n                query: gql`\n                  query GetCustomer($id: ID!) {\n                    customer(id: $id) {\n                      id\n                      objectId\n                      someField\n                      createdAt\n                      updatedAt\n                    }\n                  }\n                `,\n                variables: {\n                  id: obj.id,\n                },\n              })\n            ).data.customer;\n\n            expect(result.objectId).toEqual(obj.id);\n            expect(result.someField).toEqual('someValue');\n            expect(new Date(result.createdAt)).toEqual(obj.createdAt);\n            expect(new Date(result.updatedAt)).toEqual(obj.updatedAt);\n          });\n\n          it_only_db('mongo')(\n            'should return child objects in array fields',\n            async () => {\n              const obj1 = new Parse.Object('Customer');\n              const obj2 = new Parse.Object('SomeClass');\n              const obj3 = new Parse.Object('Customer');\n\n              obj1.set('someCustomerField', 'imCustomerOne');\n              const arrayField = [42.42, 42, 'string', true];\n              obj1.set('arrayField', arrayField);\n              await obj1.save();\n\n              obj2.set('someClassField', 'imSomeClassTwo');\n              await obj2.save();\n\n              obj3.set('manyRelations', [obj1, obj2]);\n              await obj3.save();\n\n              await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n              const result = (\n                await apolloClient.query({\n                  query: gql`\n                    query GetCustomer($id: ID!) {\n                      customer(id: $id) {\n                        objectId\n                        manyRelations {\n                          ... on Customer {\n                            objectId\n                            someCustomerField\n                            arrayField {\n                              ... on Element {\n                                value\n                              }\n                            }\n                          }\n                          ... on SomeClass {\n                            objectId\n                            someClassField\n                          }\n                        }\n                        createdAt\n                        updatedAt\n                      }\n                    }\n                  `,\n                  variables: {\n                    id: obj3.id,\n                  },\n                })\n              ).data.customer;\n\n              expect(result.objectId).toEqual(obj3.id);\n              expect(result.manyRelations.length).toEqual(2);\n\n              const customerSubObject = result.manyRelations.find(\n                (o) => o.objectId === obj1.id\n              );\n              const someClassSubObject = result.manyRelations.find(\n                (o) => o.objectId === obj2.id\n              );\n\n              expect(customerSubObject).toBeDefined();\n              expect(someClassSubObject).toBeDefined();\n              expect(customerSubObject.someCustomerField).toEqual(\n                'imCustomerOne'\n              );\n              const formatedArrayField = customerSubObject.arrayField.map(\n                (elem) => elem.value\n              );\n              expect(formatedArrayField).toEqual(arrayField);\n              expect(someClassSubObject.someClassField).toEqual(\n                'imSomeClassTwo'\n              );\n            }\n          );\n\n          it_only_db('mongo')(\n            'should return many child objects in allow cyclic query',\n            async () => {\n              const obj1 = new Parse.Object('Employee');\n              const obj2 = new Parse.Object('Team');\n              const obj3 = new Parse.Object('Company');\n              const obj4 = new Parse.Object('Country');\n\n              obj1.set('name', 'imAnEmployee');\n              await obj1.save();\n\n              obj2.set('name', 'imATeam');\n              obj2.set('employees', [obj1]);\n              await obj2.save();\n\n              obj3.set('name', 'imACompany');\n              obj3.set('teams', [obj2]);\n              obj3.set('employees', [obj1]);\n              await obj3.save();\n\n              obj4.set('name', 'imACountry');\n              obj4.set('companies', [obj3]);\n              await obj4.save();\n\n              obj1.set('country', obj4);\n              await obj1.save();\n\n              await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n              const result = (\n                await apolloClient.query({\n                  query: gql`\n                    query DeepComplexGraphQLQuery($id: ID!) {\n                      country(id: $id) {\n                        objectId\n                        name\n                        companies {\n                          ... on Company {\n                            objectId\n                            name\n                            employees {\n                              ... on Employee {\n                                objectId\n                                name\n                              }\n                            }\n                            teams {\n                              ... on Team {\n                                objectId\n                                name\n                                employees {\n                                  ... on Employee {\n                                    objectId\n                                    name\n                                    country {\n                                      objectId\n                                      name\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  `,\n                  variables: {\n                    id: obj4.id,\n                  },\n                })\n              ).data.country;\n\n              const expectedResult = {\n                objectId: obj4.id,\n                name: 'imACountry',\n                __typename: 'Country',\n                companies: [\n                  {\n                    objectId: obj3.id,\n                    name: 'imACompany',\n                    __typename: 'Company',\n                    employees: [\n                      {\n                        objectId: obj1.id,\n                        name: 'imAnEmployee',\n                        __typename: 'Employee',\n                      },\n                    ],\n                    teams: [\n                      {\n                        objectId: obj2.id,\n                        name: 'imATeam',\n                        __typename: 'Team',\n                        employees: [\n                          {\n                            objectId: obj1.id,\n                            name: 'imAnEmployee',\n                            __typename: 'Employee',\n                            country: {\n                              objectId: obj4.id,\n                              name: 'imACountry',\n                              __typename: 'Country',\n                            },\n                          },\n                        ],\n                      },\n                    ],\n                  },\n                ],\n              };\n              expect(result).toEqual(expectedResult);\n            }\n          );\n\n          it('should respect level permissions', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            async function getObject(className, id, headers) {\n              const alias =\n                className.charAt(0).toLowerCase() + className.slice(1);\n              const specificQueryResult = await apolloClient.query({\n                query: gql`\n                  query GetSomeObject($id: ID!) {\n                    get: ${alias}(id: $id) {\n                      id\n                      createdAt\n                      someField\n                    }\n                  }\n                `,\n                variables: {\n                  id,\n                },\n                context: {\n                  headers,\n                },\n              });\n\n              return specificQueryResult;\n            }\n\n            await Promise.all(\n              objects\n                .slice(0, 3)\n                .map((obj) =>\n                  expectAsync(\n                    getObject(obj.className, obj.id)\n                  ).toBeRejectedWith(jasmine.stringMatching('Object not found'))\n                )\n            );\n            expect(\n              (await getObject(object4.className, object4.id)).data.get\n                .someField\n            ).toEqual('someValue4');\n            await Promise.all(\n              objects.map(async (obj) =>\n                expect(\n                  (\n                    await getObject(obj.className, obj.id, {\n                      'X-Parse-Master-Key': 'test',\n                    })\n                  ).data.get.someField\n                ).toEqual(obj.get('someField'))\n              )\n            );\n            await Promise.all(\n              objects.map(async (obj) =>\n                expect(\n                  (\n                    await getObject(obj.className, obj.id, {\n                      'X-Parse-Session-Token': user1.getSessionToken(),\n                    })\n                  ).data.get.someField\n                ).toEqual(obj.get('someField'))\n              )\n            );\n            await Promise.all(\n              objects.map(async (obj) =>\n                expect(\n                  (\n                    await getObject(obj.className, obj.id, {\n                      'X-Parse-Session-Token': user2.getSessionToken(),\n                    })\n                  ).data.get.someField\n                ).toEqual(obj.get('someField'))\n              )\n            );\n            await expectAsync(\n              getObject(object2.className, object2.id, {\n                'X-Parse-Session-Token': user3.getSessionToken(),\n              })\n            ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n            await Promise.all(\n              [object1, object3, object4].map(async (obj) =>\n                expect(\n                  (\n                    await getObject(obj.className, obj.id, {\n                      'X-Parse-Session-Token': user3.getSessionToken(),\n                    })\n                  ).data.get.someField\n                ).toEqual(obj.get('someField'))\n              )\n            );\n            await Promise.all(\n              objects.slice(0, 3).map((obj) =>\n                expectAsync(\n                  getObject(obj.className, obj.id, {\n                    'X-Parse-Session-Token': user4.getSessionToken(),\n                  })\n                ).toBeRejectedWith(jasmine.stringMatching('Object not found'))\n              )\n            );\n            expect(\n              (\n                await getObject(object4.className, object4.id, {\n                  'X-Parse-Session-Token': user4.getSessionToken(),\n                })\n              ).data.get.someField\n            ).toEqual('someValue4');\n            await Promise.all(\n              objects.slice(0, 2).map((obj) =>\n                expectAsync(\n                  getObject(obj.className, obj.id, {\n                    'X-Parse-Session-Token': user5.getSessionToken(),\n                  })\n                ).toBeRejectedWith(jasmine.stringMatching('Object not found'))\n              )\n            );\n            expect(\n              (\n                await getObject(object3.className, object3.id, {\n                  'X-Parse-Session-Token': user5.getSessionToken(),\n                })\n              ).data.get.someField\n            ).toEqual('someValue3');\n            expect(\n              (\n                await getObject(object4.className, object4.id, {\n                  'X-Parse-Session-Token': user5.getSessionToken(),\n                })\n              ).data.get.someField\n            ).toEqual('someValue4');\n          });\n\n          it('should support keys argument', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const result1 = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!) {\n                  get: graphQLClass(id: $id) {\n                    someField\n                  }\n                }\n              `,\n              variables: {\n                id: object3.id,\n              },\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': user1.getSessionToken(),\n                },\n              },\n            });\n\n            const result2 = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!) {\n                  get: graphQLClass(id: $id) {\n                    someField\n                    pointerToUser {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: object3.id,\n              },\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': user1.getSessionToken(),\n                },\n              },\n            });\n\n            expect(result1.data.get.someField).toBeDefined();\n            expect(result1.data.get.pointerToUser).toBeUndefined();\n            expect(result2.data.get.someField).toBeDefined();\n            expect(result2.data.get.pointerToUser).toBeDefined();\n          });\n\n          it('should support include argument', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const result1 = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!) {\n                  get: graphQLClass(id: $id) {\n                    pointerToUser {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: object3.id,\n              },\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': user1.getSessionToken(),\n                },\n              },\n            });\n\n            const result2 = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!) {\n                  graphQLClass(id: $id) {\n                    pointerToUser {\n                      username\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: object3.id,\n              },\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': user1.getSessionToken(),\n                },\n              },\n            });\n\n            expect(result1.data.get.pointerToUser.username).toBeUndefined();\n            expect(\n              result2.data.graphQLClass.pointerToUser.username\n            ).toBeDefined();\n          });\n\n          it('should respect protectedFields', async (done) => {\n            await prepareData();\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const className = 'GraphQLClass';\n\n            await updateCLP(\n              {\n                get: { '*': true },\n                find: { '*': true },\n\n                protectedFields: {\n                  '*': ['someField', 'someOtherField'],\n                  authenticated: ['someField'],\n                  'userField:pointerToUser': [],\n                  [user2.id]: [],\n                },\n              },\n              className\n            );\n\n            const getObject = async (className, id, user) => {\n              const headers = user\n                ? { ['X-Parse-Session-Token']: user.getSessionToken() }\n                : undefined;\n\n              const specificQueryResult = await apolloClient.query({\n                query: gql`\n                  query GetSomeObject($id: ID!) {\n                    get: graphQLClass(id: $id) {\n                      pointerToUser {\n                        username\n                        id\n                      }\n                      someField\n                      someOtherField\n                    }\n                  }\n                `,\n                variables: {\n                  id: id,\n                },\n                context: {\n                  headers: headers,\n                },\n              });\n\n              return specificQueryResult.data.get;\n            };\n\n            const id = object3.id;\n\n            /* not authenticated */\n            const objectPublic = await getObject(className, id, undefined);\n\n            expect(objectPublic.someField).toBeNull();\n            expect(objectPublic.someOtherField).toBeNull();\n\n            /* authenticated */\n            const objectAuth = await getObject(className, id, user1);\n\n            expect(objectAuth.someField).toBeNull();\n            expect(objectAuth.someOtherField).toBe('B');\n\n            /* pointer field */\n            const objectPointed = await getObject(className, id, user5);\n\n            expect(objectPointed.someField).toBe('someValue3');\n            expect(objectPointed.someOtherField).toBe('B');\n\n            /* for user id */\n            const objectForUser = await getObject(className, id, user2);\n\n            expect(objectForUser.someField).toBe('someValue3');\n            expect(objectForUser.someOtherField).toBe('B');\n\n            done();\n          });\n          describe_only_db('mongo')('read preferences', () => {\n            it('should read from primary by default', async () => {\n              try {\n                await prepareData();\n\n                await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n                const databaseAdapter =\n                  parseServer.config.databaseController.adapter;\n                spyOn(\n                  databaseAdapter.database.serverConfig,\n                  'cursor'\n                ).and.callThrough();\n\n                await apolloClient.query({\n                  query: gql`\n                    query GetSomeObject($id: ID!) {\n                      graphQLClass(id: $id) {\n                        pointerToUser {\n                          username\n                        }\n                      }\n                    }\n                  `,\n                  variables: {\n                    id: object3.id,\n                  },\n                  context: {\n                    headers: {\n                      'X-Parse-Session-Token': user1.getSessionToken(),\n                    },\n                  },\n                });\n\n                let foundGraphQLClassReadPreference = false;\n                let foundUserClassReadPreference = false;\n                databaseAdapter.database.serverConfig.cursor.calls\n                  .all()\n                  .forEach((call) => {\n                    if (\n                      call.args[0].ns.collection.indexOf('GraphQLClass') >= 0\n                    ) {\n                      foundGraphQLClassReadPreference = true;\n                      expect(call.args[0].options.readPreference.mode).toBe(\n                        ReadPreference.PRIMARY\n                      );\n                    } else if (\n                      call.args[0].ns.collection.indexOf('_User') >= 0\n                    ) {\n                      foundUserClassReadPreference = true;\n                      expect(call.args[0].options.readPreference.mode).toBe(\n                        ReadPreference.PRIMARY\n                      );\n                    }\n                  });\n\n                expect(foundGraphQLClassReadPreference).toBe(true);\n                expect(foundUserClassReadPreference).toBe(true);\n              } catch (e) {\n                handleError(e);\n              }\n            });\n\n            it('should support readPreference argument', async () => {\n              await prepareData();\n\n              await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n              const databaseAdapter =\n                parseServer.config.databaseController.adapter;\n              spyOn(\n                databaseAdapter.database.serverConfig,\n                'cursor'\n              ).and.callThrough();\n\n              await apolloClient.query({\n                query: gql`\n                  query GetSomeObject($id: ID!) {\n                    graphQLClass(\n                      id: $id\n                      options: { readPreference: SECONDARY }\n                    ) {\n                      pointerToUser {\n                        username\n                      }\n                    }\n                  }\n                `,\n                variables: {\n                  id: object3.id,\n                },\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test',\n                  },\n                },\n              });\n\n              let foundGraphQLClassReadPreference = false;\n              let foundUserClassReadPreference = false;\n              databaseAdapter.database.serverConfig.cursor.calls\n                .all()\n                .forEach((call) => {\n                  if (call.args[0].ns.collection.indexOf('GraphQLClass') >= 0) {\n                    foundGraphQLClassReadPreference = true;\n                    expect(call.args[0].options.readPreference.mode).toBe(\n                      ReadPreference.SECONDARY\n                    );\n                  } else if (call.args[0].ns.collection.indexOf('_User') >= 0) {\n                    foundUserClassReadPreference = true;\n                    expect(call.args[0].options.readPreference.mode).toBe(\n                      ReadPreference.SECONDARY\n                    );\n                  }\n                });\n\n              expect(foundGraphQLClassReadPreference).toBe(true);\n              expect(foundUserClassReadPreference).toBe(true);\n            });\n\n            it('should support includeReadPreference argument', async () => {\n              await prepareData();\n\n              await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n              const databaseAdapter =\n                parseServer.config.databaseController.adapter;\n              spyOn(\n                databaseAdapter.database.serverConfig,\n                'cursor'\n              ).and.callThrough();\n\n              await apolloClient.query({\n                query: gql`\n                  query GetSomeObject($id: ID!) {\n                    graphQLClass(\n                      id: $id\n                      options: {\n                        readPreference: SECONDARY\n                        includeReadPreference: NEAREST\n                      }\n                    ) {\n                      pointerToUser {\n                        username\n                      }\n                    }\n                  }\n                `,\n                variables: {\n                  id: object3.id,\n                },\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test',\n                  },\n                },\n              });\n\n              let foundGraphQLClassReadPreference = false;\n              let foundUserClassReadPreference = false;\n              databaseAdapter.database.serverConfig.cursor.calls\n                .all()\n                .forEach((call) => {\n                  if (call.args[0].ns.collection.indexOf('GraphQLClass') >= 0) {\n                    foundGraphQLClassReadPreference = true;\n                    expect(call.args[0].options.readPreference.mode).toBe(\n                      ReadPreference.SECONDARY\n                    );\n                  } else if (call.args[0].ns.collection.indexOf('_User') >= 0) {\n                    foundUserClassReadPreference = true;\n                    expect(call.args[0].options.readPreference.mode).toBe(\n                      ReadPreference.NEAREST\n                    );\n                  }\n                });\n\n              expect(foundGraphQLClassReadPreference).toBe(true);\n              expect(foundUserClassReadPreference).toBe(true);\n            });\n          });\n        });\n\n        describe('Find', () => {\n          it('should return class objects using class specific query', async () => {\n            const obj1 = new Parse.Object('Customer');\n            obj1.set('someField', 'someValue1');\n            await obj1.save();\n            const obj2 = new Parse.Object('Customer');\n            obj2.set('someField', 'someValue1');\n            await obj2.save();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const result = await apolloClient.query({\n              query: gql`\n                query FindCustomer {\n                  customers {\n                    edges {\n                      node {\n                        objectId\n                        someField\n                        createdAt\n                        updatedAt\n                      }\n                    }\n                  }\n                }\n              `,\n            });\n\n            expect(result.data.customers.edges.length).toEqual(2);\n\n            result.data.customers.edges.forEach((resultObj) => {\n              const obj = resultObj.node.objectId === obj1.id ? obj1 : obj2;\n              expect(resultObj.node.objectId).toEqual(obj.id);\n              expect(resultObj.node.someField).toEqual(obj.get('someField'));\n              expect(new Date(resultObj.node.createdAt)).toEqual(obj.createdAt);\n              expect(new Date(resultObj.node.updatedAt)).toEqual(obj.updatedAt);\n            });\n          });\n\n          it('should respect level permissions', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            async function findObjects(className, headers) {\n              const graphqlClassName = pluralize(\n                className.charAt(0).toLowerCase() + className.slice(1)\n              );\n              const result = await apolloClient.query({\n                query: gql`\n                  query FindSomeObjects {\n                    find: ${graphqlClassName} {\n                      edges {\n                        node {\n                          id\n                          someField\n                        }\n                      }\n                    }\n                  }\n                `,\n                context: {\n                  headers,\n                },\n              });\n\n              return result;\n            }\n\n            expect(\n              (await findObjects('GraphQLClass')).data.find.edges.map(\n                (object) => object.node.someField\n              )\n            ).toEqual([]);\n            expect(\n              (await findObjects('PublicClass')).data.find.edges.map(\n                (object) => object.node.someField\n              )\n            ).toEqual(['someValue4']);\n            expect(\n              (\n                await findObjects('GraphQLClass', {\n                  'X-Parse-Master-Key': 'test',\n                })\n              ).data.find.edges\n                .map((object) => object.node.someField)\n                .sort()\n            ).toEqual(['someValue1', 'someValue2', 'someValue3']);\n            expect(\n              (\n                await findObjects('PublicClass', {\n                  'X-Parse-Master-Key': 'test',\n                })\n              ).data.find.edges.map((object) => object.node.someField)\n            ).toEqual(['someValue4']);\n            expect(\n              (\n                await findObjects('GraphQLClass', {\n                  'X-Parse-Session-Token': user1.getSessionToken(),\n                })\n              ).data.find.edges\n                .map((object) => object.node.someField)\n                .sort()\n            ).toEqual(['someValue1', 'someValue2', 'someValue3']);\n            expect(\n              (\n                await findObjects('PublicClass', {\n                  'X-Parse-Session-Token': user1.getSessionToken(),\n                })\n              ).data.find.edges.map((object) => object.node.someField)\n            ).toEqual(['someValue4']);\n            expect(\n              (\n                await findObjects('GraphQLClass', {\n                  'X-Parse-Session-Token': user2.getSessionToken(),\n                })\n              ).data.find.edges\n                .map((object) => object.node.someField)\n                .sort()\n            ).toEqual(['someValue1', 'someValue2', 'someValue3']);\n            expect(\n              (\n                await findObjects('GraphQLClass', {\n                  'X-Parse-Session-Token': user3.getSessionToken(),\n                })\n              ).data.find.edges\n                .map((object) => object.node.someField)\n                .sort()\n            ).toEqual(['someValue1', 'someValue3']);\n            expect(\n              (\n                await findObjects('GraphQLClass', {\n                  'X-Parse-Session-Token': user4.getSessionToken(),\n                })\n              ).data.find.edges.map((object) => object.node.someField)\n            ).toEqual([]);\n            expect(\n              (\n                await findObjects('GraphQLClass', {\n                  'X-Parse-Session-Token': user5.getSessionToken(),\n                })\n              ).data.find.edges.map((object) => object.node.someField)\n            ).toEqual(['someValue3']);\n          });\n\n          it('should support where argument using class specific query', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const result = await apolloClient.query({\n              query: gql`\n                query FindSomeObjects($where: GraphQLClassWhereInput) {\n                  graphQLClasses(where: $where) {\n                    edges {\n                      node {\n                        someField\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where: {\n                  someField: {\n                    in: ['someValue1', 'someValue2', 'someValue3'],\n                  },\n                  OR: [\n                    {\n                      pointerToUser: {\n                        have: {\n                          objectId: {\n                            equalTo: user5.id,\n                          },\n                        },\n                      },\n                    },\n                    {\n                      id: {\n                        equalTo: object1.id,\n                      },\n                    },\n                  ],\n                },\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            expect(\n              result.data.graphQLClasses.edges\n                .map((object) => object.node.someField)\n                .sort()\n            ).toEqual(['someValue1', 'someValue3']);\n          });\n\n          it('should support in pointer operator using class specific query', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const result = await apolloClient.query({\n              query: gql`\n                query FindSomeObjects($where: GraphQLClassWhereInput) {\n                  graphQLClasses(where: $where) {\n                    edges {\n                      node {\n                        someField\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where: {\n                  pointerToUser: {\n                    have: {\n                      objectId: {\n                        in: [user5.id],\n                      },\n                    },\n                  },\n                },\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            const { edges } = result.data.graphQLClasses;\n            expect(edges.length).toBe(1);\n            expect(edges[0].node.someField).toEqual('someValue3');\n          });\n\n          it('should support OR operation', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const result = await apolloClient.query({\n              query: gql`\n                query {\n                  graphQLClasses(\n                    where: {\n                      OR: [\n                        { someField: { equalTo: \"someValue1\" } }\n                        { someField: { equalTo: \"someValue2\" } }\n                      ]\n                    }\n                  ) {\n                    edges {\n                      node {\n                        someField\n                      }\n                    }\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            expect(\n              result.data.graphQLClasses.edges\n                .map((object) => object.node.someField)\n                .sort()\n            ).toEqual(['someValue1', 'someValue2']);\n          });\n\n          it('should support full text search', async () => {\n            try {\n              const obj = new Parse.Object('FullTextSearchTest');\n              obj.set('field1', 'Parse GraphQL Server');\n              obj.set('field2', 'It rocks!');\n              await obj.save();\n\n              await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n              const result = await apolloClient.query({\n                query: gql`\n                  query FullTextSearchTests(\n                    $where: FullTextSearchTestWhereInput\n                  ) {\n                    fullTextSearchTests(where: $where) {\n                      edges {\n                        node {\n                          objectId\n                        }\n                      }\n                    }\n                  }\n                `,\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test',\n                  },\n                },\n                variables: {\n                  where: {\n                    field1: {\n                      text: {\n                        search: {\n                          term: 'graphql',\n                        },\n                      },\n                    },\n                  },\n                },\n              });\n\n              expect(\n                result.data.fullTextSearchTests.edges[0].node.objectId\n              ).toEqual(obj.id);\n            } catch (e) {\n              handleError(e);\n            }\n          });\n\n          it('should support in query key', async () => {\n            try {\n              const country = new Parse.Object('Country');\n              country.set('code', 'FR');\n              await country.save();\n\n              const country2 = new Parse.Object('Country');\n              country2.set('code', 'US');\n              await country2.save();\n\n              const city = new Parse.Object('City');\n              city.set('country', 'FR');\n              city.set('name', 'city1');\n              await city.save();\n\n              const city2 = new Parse.Object('City');\n              city2.set('country', 'US');\n              city2.set('name', 'city2');\n              await city2.save();\n\n              await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n              const {\n                data: {\n                  cities: { edges: result },\n                },\n              } = await apolloClient.query({\n                query: gql`\n                  query inQueryKey($where: CityWhereInput) {\n                    cities(where: $where) {\n                      edges {\n                        node {\n                          country\n                          name\n                        }\n                      }\n                    }\n                  }\n                `,\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test',\n                  },\n                },\n                variables: {\n                  where: {\n                    country: {\n                      inQueryKey: {\n                        query: {\n                          className: 'Country',\n                          where: { code: { equalTo: 'US' } },\n                        },\n                        key: 'code',\n                      },\n                    },\n                  },\n                },\n              });\n\n              expect(result.length).toEqual(1);\n              expect(result[0].node.name).toEqual('city2');\n            } catch (e) {\n              handleError(e);\n            }\n          });\n\n          it('should support order, skip and first arguments', async () => {\n            const promises = [];\n            for (let i = 0; i < 100; i++) {\n              const obj = new Parse.Object('SomeClass');\n              obj.set('someField', `someValue${i < 10 ? '0' : ''}${i}`);\n              obj.set('numberField', i % 3);\n              promises.push(obj.save());\n            }\n            await Promise.all(promises);\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const result = await apolloClient.query({\n              query: gql`\n                query FindSomeObjects(\n                  $where: SomeClassWhereInput\n                  $order: [SomeClassOrder!]\n                  $skip: Int\n                  $first: Int\n                ) {\n                  find: someClasses(\n                    where: $where\n                    order: $order\n                    skip: $skip\n                    first: $first\n                  ) {\n                    edges {\n                      node {\n                        someField\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where: {\n                  someField: {\n                    matchesRegex: '^someValue',\n                  },\n                },\n                order: ['numberField_DESC', 'someField_ASC'],\n                skip: 4,\n                first: 2,\n              },\n            });\n\n            expect(\n              result.data.find.edges.map((obj) => obj.node.someField)\n            ).toEqual(['someValue14', 'someValue17']);\n          });\n\n          it('should support pagination', async () => {\n            const numberArray = (first, last) => {\n              const array = [];\n              for (let i = first; i <= last; i++) {\n                array.push(i);\n              }\n              return array;\n            };\n\n            const promises = [];\n            for (let i = 0; i < 100; i++) {\n              const obj = new Parse.Object('SomeClass');\n              obj.set('numberField', i);\n              promises.push(obj.save());\n            }\n            await Promise.all(promises);\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const find = async ({ skip, after, first, before, last } = {}) => {\n              return await apolloClient.query({\n                query: gql`\n                  query FindSomeObjects(\n                    $order: [SomeClassOrder!]\n                    $skip: Int\n                    $after: String\n                    $first: Int\n                    $before: String\n                    $last: Int\n                  ) {\n                    someClasses(\n                      order: $order\n                      skip: $skip\n                      after: $after\n                      first: $first\n                      before: $before\n                      last: $last\n                    ) {\n                      edges {\n                        cursor\n                        node {\n                          numberField\n                        }\n                      }\n                      count\n                      pageInfo {\n                        hasPreviousPage\n                        startCursor\n                        endCursor\n                        hasNextPage\n                      }\n                    }\n                  }\n                `,\n                variables: {\n                  order: ['numberField_ASC'],\n                  skip,\n                  after,\n                  first,\n                  before,\n                  last,\n                },\n              });\n            };\n\n            let result = await find();\n            expect(\n              result.data.someClasses.edges.map((edge) => edge.node.numberField)\n            ).toEqual(numberArray(0, 99));\n            expect(result.data.someClasses.count).toEqual(100);\n            expect(result.data.someClasses.pageInfo.hasPreviousPage).toEqual(\n              false\n            );\n            expect(result.data.someClasses.pageInfo.startCursor).toEqual(\n              result.data.someClasses.edges[0].cursor\n            );\n            expect(result.data.someClasses.pageInfo.endCursor).toEqual(\n              result.data.someClasses.edges[99].cursor\n            );\n            expect(result.data.someClasses.pageInfo.hasNextPage).toEqual(false);\n\n            result = await find({ first: 10 });\n            expect(\n              result.data.someClasses.edges.map((edge) => edge.node.numberField)\n            ).toEqual(numberArray(0, 9));\n            expect(result.data.someClasses.count).toEqual(100);\n            expect(result.data.someClasses.pageInfo.hasPreviousPage).toEqual(\n              false\n            );\n            expect(result.data.someClasses.pageInfo.startCursor).toEqual(\n              result.data.someClasses.edges[0].cursor\n            );\n            expect(result.data.someClasses.pageInfo.endCursor).toEqual(\n              result.data.someClasses.edges[9].cursor\n            );\n            expect(result.data.someClasses.pageInfo.hasNextPage).toEqual(true);\n\n            result = await find({\n              first: 10,\n              after: result.data.someClasses.pageInfo.endCursor,\n            });\n            expect(\n              result.data.someClasses.edges.map((edge) => edge.node.numberField)\n            ).toEqual(numberArray(10, 19));\n            expect(result.data.someClasses.count).toEqual(100);\n            expect(result.data.someClasses.pageInfo.hasPreviousPage).toEqual(\n              true\n            );\n            expect(result.data.someClasses.pageInfo.startCursor).toEqual(\n              result.data.someClasses.edges[0].cursor\n            );\n            expect(result.data.someClasses.pageInfo.endCursor).toEqual(\n              result.data.someClasses.edges[9].cursor\n            );\n            expect(result.data.someClasses.pageInfo.hasNextPage).toEqual(true);\n\n            result = await find({ last: 10 });\n            expect(\n              result.data.someClasses.edges.map((edge) => edge.node.numberField)\n            ).toEqual(numberArray(90, 99));\n            expect(result.data.someClasses.count).toEqual(100);\n            expect(result.data.someClasses.pageInfo.hasPreviousPage).toEqual(\n              true\n            );\n            expect(result.data.someClasses.pageInfo.startCursor).toEqual(\n              result.data.someClasses.edges[0].cursor\n            );\n            expect(result.data.someClasses.pageInfo.endCursor).toEqual(\n              result.data.someClasses.edges[9].cursor\n            );\n            expect(result.data.someClasses.pageInfo.hasNextPage).toEqual(false);\n\n            result = await find({\n              last: 10,\n              before: result.data.someClasses.pageInfo.startCursor,\n            });\n            expect(\n              result.data.someClasses.edges.map((edge) => edge.node.numberField)\n            ).toEqual(numberArray(80, 89));\n            expect(result.data.someClasses.count).toEqual(100);\n            expect(result.data.someClasses.pageInfo.hasPreviousPage).toEqual(\n              true\n            );\n            expect(result.data.someClasses.pageInfo.startCursor).toEqual(\n              result.data.someClasses.edges[0].cursor\n            );\n            expect(result.data.someClasses.pageInfo.endCursor).toEqual(\n              result.data.someClasses.edges[9].cursor\n            );\n            expect(result.data.someClasses.pageInfo.hasNextPage).toEqual(true);\n          });\n\n          it('should support count', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const where = {\n              someField: {\n                in: ['someValue1', 'someValue2', 'someValue3'],\n              },\n              OR: [\n                {\n                  pointerToUser: {\n                    have: {\n                      objectId: {\n                        equalTo: user5.id,\n                      },\n                    },\n                  },\n                },\n                {\n                  id: {\n                    equalTo: object1.id,\n                  },\n                },\n              ],\n            };\n\n            const result = await apolloClient.query({\n              query: gql`\n                query FindSomeObjects(\n                  $where: GraphQLClassWhereInput\n                  $first: Int\n                ) {\n                  find: graphQLClasses(where: $where, first: $first) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                    count\n                  }\n                }\n              `,\n              variables: {\n                where,\n                first: 0,\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            expect(result.data.find.edges).toEqual([]);\n            expect(result.data.find.count).toEqual(2);\n          });\n\n          it('should only count', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const where = {\n              someField: {\n                in: ['someValue1', 'someValue2', 'someValue3'],\n              },\n              OR: [\n                {\n                  pointerToUser: {\n                    have: {\n                      objectId: {\n                        equalTo: user5.id,\n                      },\n                    },\n                  },\n                },\n                {\n                  id: {\n                    equalTo: object1.id,\n                  },\n                },\n              ],\n            };\n\n            const result = await apolloClient.query({\n              query: gql`\n                query FindSomeObjects($where: GraphQLClassWhereInput) {\n                  find: graphQLClasses(where: $where) {\n                    count\n                  }\n                }\n              `,\n              variables: {\n                where,\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            expect(result.data.find.edges).toBeUndefined();\n            expect(result.data.find.count).toEqual(2);\n          });\n\n          it('should respect max limit', async () => {\n            parseServer = await global.reconfigureServer({\n              maxLimit: 10,\n            });\n\n            const promises = [];\n            for (let i = 0; i < 100; i++) {\n              const obj = new Parse.Object('SomeClass');\n              promises.push(obj.save());\n            }\n            await Promise.all(promises);\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const result = await apolloClient.query({\n              query: gql`\n                query FindSomeObjects($limit: Int) {\n                  find: someClasses(\n                    where: { id: { exists: true } }\n                    first: $limit\n                  ) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                    count\n                  }\n                }\n              `,\n              variables: {\n                limit: 50,\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            expect(result.data.find.edges.length).toEqual(10);\n            expect(result.data.find.count).toEqual(100);\n          });\n\n          it('should support keys argument', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const result1 = await apolloClient.query({\n              query: gql`\n                query FindSomeObject($where: GraphQLClassWhereInput) {\n                  find: graphQLClasses(where: $where) {\n                    edges {\n                      node {\n                        someField\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where: {\n                  id: { equalTo: object3.id },\n                },\n              },\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': user1.getSessionToken(),\n                },\n              },\n            });\n\n            const result2 = await apolloClient.query({\n              query: gql`\n                query FindSomeObject($where: GraphQLClassWhereInput) {\n                  find: graphQLClasses(where: $where) {\n                    edges {\n                      node {\n                        someField\n                        pointerToUser {\n                          username\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where: {\n                  id: { equalTo: object3.id },\n                },\n              },\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': user1.getSessionToken(),\n                },\n              },\n            });\n\n            expect(result1.data.find.edges[0].node.someField).toBeDefined();\n            expect(\n              result1.data.find.edges[0].node.pointerToUser\n            ).toBeUndefined();\n            expect(result2.data.find.edges[0].node.someField).toBeDefined();\n            expect(result2.data.find.edges[0].node.pointerToUser).toBeDefined();\n          });\n\n          it('should support include argument', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const where = {\n              id: {\n                equalTo: object3.id,\n              },\n            };\n\n            const result1 = await apolloClient.query({\n              query: gql`\n                query FindSomeObject($where: GraphQLClassWhereInput) {\n                  find: graphQLClasses(where: $where) {\n                    edges {\n                      node {\n                        pointerToUser {\n                          id\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where,\n              },\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': user1.getSessionToken(),\n                },\n              },\n            });\n\n            const result2 = await apolloClient.query({\n              query: gql`\n                query FindSomeObject($where: GraphQLClassWhereInput) {\n                  find: graphQLClasses(where: $where) {\n                    edges {\n                      node {\n                        pointerToUser {\n                          username\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where,\n              },\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': user1.getSessionToken(),\n                },\n              },\n            });\n            expect(\n              result1.data.find.edges[0].node.pointerToUser.username\n            ).toBeUndefined();\n            expect(\n              result2.data.find.edges[0].node.pointerToUser.username\n            ).toBeDefined();\n          });\n\n          describe_only_db('mongo')('read preferences', () => {\n            it('should read from primary by default', async () => {\n              await prepareData();\n\n              await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n              const databaseAdapter =\n                parseServer.config.databaseController.adapter;\n              spyOn(\n                databaseAdapter.database.serverConfig,\n                'cursor'\n              ).and.callThrough();\n\n              await apolloClient.query({\n                query: gql`\n                  query FindSomeObjects {\n                    find: graphQLClasses {\n                      edges {\n                        node {\n                          pointerToUser {\n                            username\n                          }\n                        }\n                      }\n                    }\n                  }\n                `,\n                context: {\n                  headers: {\n                    'X-Parse-Session-Token': user1.getSessionToken(),\n                  },\n                },\n              });\n\n              let foundGraphQLClassReadPreference = false;\n              let foundUserClassReadPreference = false;\n              databaseAdapter.database.serverConfig.cursor.calls\n                .all()\n                .forEach((call) => {\n                  if (call.args[0].ns.collection.indexOf('GraphQLClass') >= 0) {\n                    foundGraphQLClassReadPreference = true;\n                    expect(call.args[0].options.readPreference.mode).toBe(\n                      ReadPreference.PRIMARY\n                    );\n                  } else if (call.args[0].ns.collection.indexOf('_User') >= 0) {\n                    foundUserClassReadPreference = true;\n                    expect(call.args[0].options.readPreference.mode).toBe(\n                      ReadPreference.PRIMARY\n                    );\n                  }\n                });\n\n              expect(foundGraphQLClassReadPreference).toBe(true);\n              expect(foundUserClassReadPreference).toBe(true);\n            });\n\n            it('should support readPreference argument', async () => {\n              await prepareData();\n\n              await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n              const databaseAdapter =\n                parseServer.config.databaseController.adapter;\n              spyOn(\n                databaseAdapter.database.serverConfig,\n                'cursor'\n              ).and.callThrough();\n\n              await apolloClient.query({\n                query: gql`\n                  query FindSomeObjects {\n                    find: graphQLClasses(\n                      options: { readPreference: SECONDARY }\n                    ) {\n                      edges {\n                        node {\n                          pointerToUser {\n                            username\n                          }\n                        }\n                      }\n                    }\n                  }\n                `,\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test',\n                  },\n                },\n              });\n\n              let foundGraphQLClassReadPreference = false;\n              let foundUserClassReadPreference = false;\n              databaseAdapter.database.serverConfig.cursor.calls\n                .all()\n                .forEach((call) => {\n                  if (call.args[0].ns.collection.indexOf('GraphQLClass') >= 0) {\n                    foundGraphQLClassReadPreference = true;\n                    expect(call.args[0].options.readPreference.mode).toBe(\n                      ReadPreference.SECONDARY\n                    );\n                  } else if (call.args[0].ns.collection.indexOf('_User') >= 0) {\n                    foundUserClassReadPreference = true;\n                    expect(call.args[0].options.readPreference.mode).toBe(\n                      ReadPreference.SECONDARY\n                    );\n                  }\n                });\n\n              expect(foundGraphQLClassReadPreference).toBe(true);\n              expect(foundUserClassReadPreference).toBe(true);\n            });\n\n            it('should support includeReadPreference argument', async () => {\n              await prepareData();\n\n              await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n              const databaseAdapter =\n                parseServer.config.databaseController.adapter;\n              spyOn(\n                databaseAdapter.database.serverConfig,\n                'cursor'\n              ).and.callThrough();\n\n              await apolloClient.query({\n                query: gql`\n                  query FindSomeObjects {\n                    graphQLClasses(\n                      options: {\n                        readPreference: SECONDARY\n                        includeReadPreference: NEAREST\n                      }\n                    ) {\n                      edges {\n                        node {\n                          pointerToUser {\n                            username\n                          }\n                        }\n                      }\n                    }\n                  }\n                `,\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test',\n                  },\n                },\n              });\n\n              let foundGraphQLClassReadPreference = false;\n              let foundUserClassReadPreference = false;\n              databaseAdapter.database.serverConfig.cursor.calls\n                .all()\n                .forEach((call) => {\n                  if (call.args[0].ns.collection.indexOf('GraphQLClass') >= 0) {\n                    foundGraphQLClassReadPreference = true;\n                    expect(call.args[0].options.readPreference.mode).toBe(\n                      ReadPreference.SECONDARY\n                    );\n                  } else if (call.args[0].ns.collection.indexOf('_User') >= 0) {\n                    foundUserClassReadPreference = true;\n                    expect(call.args[0].options.readPreference.mode).toBe(\n                      ReadPreference.NEAREST\n                    );\n                  }\n                });\n\n              expect(foundGraphQLClassReadPreference).toBe(true);\n              expect(foundUserClassReadPreference).toBe(true);\n            });\n\n            it('should support subqueryReadPreference argument', async () => {\n              try {\n                await prepareData();\n\n                await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n                const databaseAdapter =\n                  parseServer.config.databaseController.adapter;\n                spyOn(\n                  databaseAdapter.database.serverConfig,\n                  'cursor'\n                ).and.callThrough();\n\n                await apolloClient.query({\n                  query: gql`\n                    query FindSomeObjects($where: GraphQLClassWhereInput) {\n                      find: graphQLClasses(\n                        where: $where\n                        options: {\n                          readPreference: SECONDARY\n                          subqueryReadPreference: NEAREST\n                        }\n                      ) {\n                        edges {\n                          node {\n                            id\n                          }\n                        }\n                      }\n                    }\n                  `,\n                  variables: {\n                    where: {\n                      pointerToUser: {\n                        have: {\n                          objectId: {\n                            equalTo: 'xxxx',\n                          },\n                        },\n                      },\n                    },\n                  },\n                  context: {\n                    headers: {\n                      'X-Parse-Master-Key': 'test',\n                    },\n                  },\n                });\n\n                let foundGraphQLClassReadPreference = false;\n                let foundUserClassReadPreference = false;\n                databaseAdapter.database.serverConfig.cursor.calls\n                  .all()\n                  .forEach((call) => {\n                    if (\n                      call.args[0].ns.collection.indexOf('GraphQLClass') >= 0\n                    ) {\n                      foundGraphQLClassReadPreference = true;\n                      expect(call.args[0].options.readPreference.mode).toBe(\n                        ReadPreference.SECONDARY\n                      );\n                    } else if (\n                      call.args[0].ns.collection.indexOf('_User') >= 0\n                    ) {\n                      foundUserClassReadPreference = true;\n                      expect(call.args[0].options.readPreference.mode).toBe(\n                        ReadPreference.NEAREST\n                      );\n                    }\n                  });\n\n                expect(foundGraphQLClassReadPreference).toBe(true);\n                expect(foundUserClassReadPreference).toBe(true);\n              } catch (e) {\n                handleError(e);\n              }\n            });\n          });\n\n          it('should order by multiple fields', async () => {\n            await prepareData();\n\n            await resetGraphQLCache();\n\n            let result;\n            try {\n              result = await apolloClient.query({\n                query: gql`\n                  query OrderByMultipleFields($order: [GraphQLClassOrder!]) {\n                    graphQLClasses(order: $order) {\n                      edges {\n                        node {\n                          objectId\n                        }\n                      }\n                    }\n                  }\n                `,\n                variables: {\n                  order: ['someOtherField_DESC', 'someField_ASC'],\n                },\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test',\n                  },\n                },\n              });\n            } catch (e) {\n              handleError(e);\n            }\n\n            expect(\n              result.data.graphQLClasses.edges.map((edge) => edge.node.objectId)\n            ).toEqual([object3.id, object1.id, object2.id]);\n          });\n\n          it_only_db('mongo')(\n            'should order by multiple fields on a relation field',\n            async () => {\n              await prepareData();\n\n              const parentObject = new Parse.Object('ParentClass');\n              const relation = parentObject.relation('graphQLClasses');\n              relation.add(object1);\n              relation.add(object2);\n              relation.add(object3);\n              await parentObject.save();\n\n              await resetGraphQLCache();\n\n              let result;\n              try {\n                result = await apolloClient.query({\n                  query: gql`\n                    query OrderByMultipleFieldsOnRelation(\n                      $id: ID!\n                      $order: [GraphQLClassOrder!]\n                    ) {\n                      parentClass(id: $id) {\n                        graphQLClasses(order: $order) {\n                          edges {\n                            node {\n                              objectId\n                            }\n                          }\n                        }\n                      }\n                    }\n                  `,\n                  variables: {\n                    id: parentObject.id,\n                    order: ['someOtherField_DESC', 'someField_ASC'],\n                  },\n                  context: {\n                    headers: {\n                      'X-Parse-Master-Key': 'test',\n                    },\n                  },\n                });\n              } catch (e) {\n                handleError(e);\n              }\n\n              expect(\n                result.data.parentClass.graphQLClasses.edges.map(\n                  (edge) => edge.node.objectId\n                )\n              ).toEqual([object3.id, object1.id, object2.id]);\n            }\n          );\n        });\n      });\n\n      describe('Objects Mutations', () => {\n        describe('Create', () => {\n          it('should return specific type object using class specific mutation', async () => {\n            const clientMutationId = uuidv4();\n            const customerSchema = new Parse.Schema('Customer');\n            customerSchema.addString('someField');\n            await customerSchema.save();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const result = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateCustomer($input: CreateCustomerInput!) {\n                  createCustomer(input: $input) {\n                    clientMutationId\n                    customer {\n                      id\n                      objectId\n                      createdAt\n                      someField\n                    }\n                  }\n                }\n              `,\n              variables: {\n                input: {\n                  clientMutationId,\n                  fields: {\n                    someField: 'someValue',\n                  },\n                },\n              },\n            });\n\n            expect(result.data.createCustomer.clientMutationId).toEqual(\n              clientMutationId\n            );\n            expect(result.data.createCustomer.customer.id).toBeDefined();\n            expect(result.data.createCustomer.customer.someField).toEqual(\n              'someValue'\n            );\n\n            const customer = await new Parse.Query('Customer').get(\n              result.data.createCustomer.customer.objectId\n            );\n\n            expect(customer.createdAt).toEqual(\n              new Date(result.data.createCustomer.customer.createdAt)\n            );\n            expect(customer.get('someField')).toEqual('someValue');\n          });\n\n          it('should respect level permissions', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            async function createObject(className, headers) {\n              const getClassName =\n                className.charAt(0).toLowerCase() + className.slice(1);\n              const result = await apolloClient.mutate({\n                mutation: gql`\n                  mutation CreateSomeObject {\n                    create${className}(input: {}) {\n                      ${getClassName} {\n                        id\n                        createdAt\n                      }\n                    }\n                  }\n                `,\n                context: {\n                  headers,\n                },\n              });\n\n              const specificCreate =\n                result.data[`create${className}`][getClassName];\n              expect(specificCreate.id).toBeDefined();\n              expect(specificCreate.createdAt).toBeDefined();\n\n              return result;\n            }\n\n            await expectAsync(createObject('GraphQLClass')).toBeRejectedWith(\n              jasmine.stringMatching(\n                'Permission denied for action create on class GraphQLClass'\n              )\n            );\n            await expectAsync(createObject('PublicClass')).toBeResolved();\n            await expectAsync(\n              createObject('GraphQLClass', { 'X-Parse-Master-Key': 'test' })\n            ).toBeResolved();\n            await expectAsync(\n              createObject('PublicClass', { 'X-Parse-Master-Key': 'test' })\n            ).toBeResolved();\n            await expectAsync(\n              createObject('GraphQLClass', {\n                'X-Parse-Session-Token': user1.getSessionToken(),\n              })\n            ).toBeResolved();\n            await expectAsync(\n              createObject('PublicClass', {\n                'X-Parse-Session-Token': user1.getSessionToken(),\n              })\n            ).toBeResolved();\n            await expectAsync(\n              createObject('GraphQLClass', {\n                'X-Parse-Session-Token': user2.getSessionToken(),\n              })\n            ).toBeResolved();\n            await expectAsync(\n              createObject('PublicClass', {\n                'X-Parse-Session-Token': user2.getSessionToken(),\n              })\n            ).toBeResolved();\n            await expectAsync(\n              createObject('GraphQLClass', {\n                'X-Parse-Session-Token': user4.getSessionToken(),\n              })\n            ).toBeRejectedWith(\n              jasmine.stringMatching(\n                'Permission denied for action create on class GraphQLClass'\n              )\n            );\n            await expectAsync(\n              createObject('PublicClass', {\n                'X-Parse-Session-Token': user4.getSessionToken(),\n              })\n            ).toBeResolved();\n          });\n        });\n\n        describe('Update', () => {\n          it('should return specific type object using class specific mutation', async () => {\n            const clientMutationId = uuidv4();\n            const obj = new Parse.Object('Customer');\n            obj.set('someField1', 'someField1Value1');\n            obj.set('someField2', 'someField2Value1');\n            await obj.save();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const result = await apolloClient.mutate({\n              mutation: gql`\n                mutation UpdateCustomer($input: UpdateCustomerInput!) {\n                  updateCustomer(input: $input) {\n                    clientMutationId\n                    customer {\n                      updatedAt\n                      someField1\n                      someField2\n                    }\n                  }\n                }\n              `,\n              variables: {\n                input: {\n                  clientMutationId,\n                  id: obj.id,\n                  fields: {\n                    someField1: 'someField1Value2',\n                  },\n                },\n              },\n            });\n\n            expect(result.data.updateCustomer.clientMutationId).toEqual(\n              clientMutationId\n            );\n            expect(result.data.updateCustomer.customer.updatedAt).toBeDefined();\n            expect(result.data.updateCustomer.customer.someField1).toEqual(\n              'someField1Value2'\n            );\n            expect(result.data.updateCustomer.customer.someField2).toEqual(\n              'someField2Value1'\n            );\n\n            await obj.fetch();\n\n            expect(obj.get('someField1')).toEqual('someField1Value2');\n            expect(obj.get('someField2')).toEqual('someField2Value1');\n          });\n\n          it('should return only id using class specific mutation', async () => {\n            const obj = new Parse.Object('Customer');\n            obj.set('someField1', 'someField1Value1');\n            obj.set('someField2', 'someField2Value1');\n            await obj.save();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const result = await apolloClient.mutate({\n              mutation: gql`\n                mutation UpdateCustomer(\n                  $id: ID!\n                  $fields: UpdateCustomerFieldsInput\n                ) {\n                  updateCustomer(input: { id: $id, fields: $fields }) {\n                    customer {\n                      id\n                      objectId\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: obj.id,\n                fields: {\n                  someField1: 'someField1Value2',\n                },\n              },\n            });\n\n            expect(result.data.updateCustomer.customer.objectId).toEqual(\n              obj.id\n            );\n\n            await obj.fetch();\n\n            expect(obj.get('someField1')).toEqual('someField1Value2');\n            expect(obj.get('someField2')).toEqual('someField2Value1');\n          });\n\n          it('should respect level permissions', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            async function updateObject(className, id, fields, headers) {\n              return await apolloClient.mutate({\n                mutation: gql`\n                  mutation UpdateSomeObject(\n                    $id: ID!\n                    $fields: Update${className}FieldsInput\n                  ) {\n                    update: update${className}(input: {\n                      id: $id\n                      fields: $fields\n                      clientMutationId: \"someid\"\n                    }) {\n                      clientMutationId\n                    }\n                  }\n                `,\n                variables: {\n                  id,\n                  fields,\n                },\n                context: {\n                  headers,\n                },\n              });\n            }\n\n            await Promise.all(\n              objects.slice(0, 3).map(async (obj) => {\n                const originalFieldValue = obj.get('someField');\n                await expectAsync(\n                  updateObject(obj.className, obj.id, {\n                    someField: 'changedValue1',\n                  })\n                ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual(originalFieldValue);\n              })\n            );\n            expect(\n              (\n                await updateObject(object4.className, object4.id, {\n                  someField: 'changedValue1',\n                })\n              ).data.update.clientMutationId\n            ).toBeDefined();\n            await object4.fetch({ useMasterKey: true });\n            expect(object4.get('someField')).toEqual('changedValue1');\n            await Promise.all(\n              objects.map(async (obj) => {\n                expect(\n                  (\n                    await updateObject(\n                      obj.className,\n                      obj.id,\n                      { someField: 'changedValue2' },\n                      { 'X-Parse-Master-Key': 'test' }\n                    )\n                  ).data.update.clientMutationId\n                ).toBeDefined();\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual('changedValue2');\n              })\n            );\n            await Promise.all(\n              objects.map(async (obj) => {\n                expect(\n                  (\n                    await updateObject(\n                      obj.className,\n                      obj.id,\n                      { someField: 'changedValue3' },\n                      { 'X-Parse-Session-Token': user1.getSessionToken() }\n                    )\n                  ).data.update.clientMutationId\n                ).toBeDefined();\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual('changedValue3');\n              })\n            );\n            await Promise.all(\n              objects.map(async (obj) => {\n                expect(\n                  (\n                    await updateObject(\n                      obj.className,\n                      obj.id,\n                      { someField: 'changedValue4' },\n                      { 'X-Parse-Session-Token': user2.getSessionToken() }\n                    )\n                  ).data.update.clientMutationId\n                ).toBeDefined();\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual('changedValue4');\n              })\n            );\n            await Promise.all(\n              [object1, object3, object4].map(async (obj) => {\n                expect(\n                  (\n                    await updateObject(\n                      obj.className,\n                      obj.id,\n                      { someField: 'changedValue5' },\n                      { 'X-Parse-Session-Token': user3.getSessionToken() }\n                    )\n                  ).data.update.clientMutationId\n                ).toBeDefined();\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual('changedValue5');\n              })\n            );\n            const originalFieldValue = object2.get('someField');\n            await expectAsync(\n              updateObject(\n                object2.className,\n                object2.id,\n                { someField: 'changedValue5' },\n                { 'X-Parse-Session-Token': user3.getSessionToken() }\n              )\n            ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n            await object2.fetch({ useMasterKey: true });\n            expect(object2.get('someField')).toEqual(originalFieldValue);\n            await Promise.all(\n              objects.slice(0, 3).map(async (obj) => {\n                const originalFieldValue = obj.get('someField');\n                await expectAsync(\n                  updateObject(\n                    obj.className,\n                    obj.id,\n                    { someField: 'changedValue6' },\n                    { 'X-Parse-Session-Token': user4.getSessionToken() }\n                  )\n                ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual(originalFieldValue);\n              })\n            );\n            expect(\n              (\n                await updateObject(\n                  object4.className,\n                  object4.id,\n                  { someField: 'changedValue6' },\n                  { 'X-Parse-Session-Token': user4.getSessionToken() }\n                )\n              ).data.update.clientMutationId\n            ).toBeDefined();\n            await object4.fetch({ useMasterKey: true });\n            expect(object4.get('someField')).toEqual('changedValue6');\n            await Promise.all(\n              objects.slice(0, 2).map(async (obj) => {\n                const originalFieldValue = obj.get('someField');\n                await expectAsync(\n                  updateObject(\n                    obj.className,\n                    obj.id,\n                    { someField: 'changedValue7' },\n                    { 'X-Parse-Session-Token': user5.getSessionToken() }\n                  )\n                ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual(originalFieldValue);\n              })\n            );\n            expect(\n              (\n                await updateObject(\n                  object3.className,\n                  object3.id,\n                  { someField: 'changedValue7' },\n                  { 'X-Parse-Session-Token': user5.getSessionToken() }\n                )\n              ).data.update.clientMutationId\n            ).toBeDefined();\n            await object3.fetch({ useMasterKey: true });\n            expect(object3.get('someField')).toEqual('changedValue7');\n            expect(\n              (\n                await updateObject(\n                  object4.className,\n                  object4.id,\n                  { someField: 'changedValue7' },\n                  { 'X-Parse-Session-Token': user5.getSessionToken() }\n                )\n              ).data.update.clientMutationId\n            ).toBeDefined();\n            await object4.fetch({ useMasterKey: true });\n            expect(object4.get('someField')).toEqual('changedValue7');\n          });\n\n          it('should respect level permissions with specific class mutation', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            function updateObject(className, id, fields, headers) {\n              const mutationName =\n                className.charAt(0).toLowerCase() + className.slice(1);\n\n              return apolloClient.mutate({\n                mutation: gql`\n                  mutation UpdateSomeObject(\n                    $id: ID!\n                    $fields: Update${className}FieldsInput\n                  ) {\n                    update${className}(input: {\n                      id: $id\n                      fields: $fields\n                    }) {\n                      ${mutationName} {\n                        updatedAt\n                      }\n                    }\n                  }\n                `,\n                variables: {\n                  id,\n                  fields,\n                },\n                context: {\n                  headers,\n                },\n              });\n            }\n\n            await Promise.all(\n              objects.slice(0, 3).map(async (obj) => {\n                const originalFieldValue = obj.get('someField');\n                await expectAsync(\n                  updateObject(obj.className, obj.id, {\n                    someField: 'changedValue1',\n                  })\n                ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual(originalFieldValue);\n              })\n            );\n            expect(\n              (\n                await updateObject(object4.className, object4.id, {\n                  someField: 'changedValue1',\n                })\n              ).data[`update${object4.className}`][\n                object4.className.charAt(0).toLowerCase() +\n                  object4.className.slice(1)\n              ].updatedAt\n            ).toBeDefined();\n            await object4.fetch({ useMasterKey: true });\n            expect(object4.get('someField')).toEqual('changedValue1');\n            await Promise.all(\n              objects.map(async (obj) => {\n                expect(\n                  (\n                    await updateObject(\n                      obj.className,\n                      obj.id,\n                      { someField: 'changedValue2' },\n                      { 'X-Parse-Master-Key': 'test' }\n                    )\n                  ).data[`update${obj.className}`][\n                    obj.className.charAt(0).toLowerCase() +\n                      obj.className.slice(1)\n                  ].updatedAt\n                ).toBeDefined();\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual('changedValue2');\n              })\n            );\n            await Promise.all(\n              objects.map(async (obj) => {\n                expect(\n                  (\n                    await updateObject(\n                      obj.className,\n                      obj.id,\n                      { someField: 'changedValue3' },\n                      { 'X-Parse-Session-Token': user1.getSessionToken() }\n                    )\n                  ).data[`update${obj.className}`][\n                    obj.className.charAt(0).toLowerCase() +\n                      obj.className.slice(1)\n                  ].updatedAt\n                ).toBeDefined();\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual('changedValue3');\n              })\n            );\n            await Promise.all(\n              objects.map(async (obj) => {\n                expect(\n                  (\n                    await updateObject(\n                      obj.className,\n                      obj.id,\n                      { someField: 'changedValue4' },\n                      { 'X-Parse-Session-Token': user2.getSessionToken() }\n                    )\n                  ).data[`update${obj.className}`][\n                    obj.className.charAt(0).toLowerCase() +\n                      obj.className.slice(1)\n                  ].updatedAt\n                ).toBeDefined();\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual('changedValue4');\n              })\n            );\n            await Promise.all(\n              [object1, object3, object4].map(async (obj) => {\n                expect(\n                  (\n                    await updateObject(\n                      obj.className,\n                      obj.id,\n                      { someField: 'changedValue5' },\n                      { 'X-Parse-Session-Token': user3.getSessionToken() }\n                    )\n                  ).data[`update${obj.className}`][\n                    obj.className.charAt(0).toLowerCase() +\n                      obj.className.slice(1)\n                  ].updatedAt\n                ).toBeDefined();\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual('changedValue5');\n              })\n            );\n            const originalFieldValue = object2.get('someField');\n            await expectAsync(\n              updateObject(\n                object2.className,\n                object2.id,\n                { someField: 'changedValue5' },\n                { 'X-Parse-Session-Token': user3.getSessionToken() }\n              )\n            ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n            await object2.fetch({ useMasterKey: true });\n            expect(object2.get('someField')).toEqual(originalFieldValue);\n            await Promise.all(\n              objects.slice(0, 3).map(async (obj) => {\n                const originalFieldValue = obj.get('someField');\n                await expectAsync(\n                  updateObject(\n                    obj.className,\n                    obj.id,\n                    { someField: 'changedValue6' },\n                    { 'X-Parse-Session-Token': user4.getSessionToken() }\n                  )\n                ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual(originalFieldValue);\n              })\n            );\n            expect(\n              (\n                await updateObject(\n                  object4.className,\n                  object4.id,\n                  { someField: 'changedValue6' },\n                  { 'X-Parse-Session-Token': user4.getSessionToken() }\n                )\n              ).data[`update${object4.className}`][\n                object4.className.charAt(0).toLowerCase() +\n                  object4.className.slice(1)\n              ].updatedAt\n            ).toBeDefined();\n            await object4.fetch({ useMasterKey: true });\n            expect(object4.get('someField')).toEqual('changedValue6');\n            await Promise.all(\n              objects.slice(0, 2).map(async (obj) => {\n                const originalFieldValue = obj.get('someField');\n                await expectAsync(\n                  updateObject(\n                    obj.className,\n                    obj.id,\n                    { someField: 'changedValue7' },\n                    { 'X-Parse-Session-Token': user5.getSessionToken() }\n                  )\n                ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual(originalFieldValue);\n              })\n            );\n            expect(\n              (\n                await updateObject(\n                  object3.className,\n                  object3.id,\n                  { someField: 'changedValue7' },\n                  { 'X-Parse-Session-Token': user5.getSessionToken() }\n                )\n              ).data[`update${object3.className}`][\n                object3.className.charAt(0).toLowerCase() +\n                  object3.className.slice(1)\n              ].updatedAt\n            ).toBeDefined();\n            await object3.fetch({ useMasterKey: true });\n            expect(object3.get('someField')).toEqual('changedValue7');\n            expect(\n              (\n                await updateObject(\n                  object4.className,\n                  object4.id,\n                  { someField: 'changedValue7' },\n                  { 'X-Parse-Session-Token': user5.getSessionToken() }\n                )\n              ).data[`update${object4.className}`][\n                object4.className.charAt(0).toLowerCase() +\n                  object4.className.slice(1)\n              ].updatedAt\n            ).toBeDefined();\n            await object4.fetch({ useMasterKey: true });\n            expect(object4.get('someField')).toEqual('changedValue7');\n          });\n        });\n\n        describe('Delete', () => {\n          it('should return a specific type using class specific mutation', async () => {\n            const clientMutationId = uuidv4();\n            const obj = new Parse.Object('Customer');\n            obj.set('someField1', 'someField1Value1');\n            obj.set('someField2', 'someField2Value1');\n            await obj.save();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const result = await apolloClient.mutate({\n              mutation: gql`\n                mutation DeleteCustomer($input: DeleteCustomerInput!) {\n                  deleteCustomer(input: $input) {\n                    clientMutationId\n                    customer {\n                      id\n                      objectId\n                      someField1\n                      someField2\n                    }\n                  }\n                }\n              `,\n              variables: {\n                input: {\n                  clientMutationId,\n                  id: obj.id,\n                },\n              },\n            });\n\n            expect(result.data.deleteCustomer.clientMutationId).toEqual(\n              clientMutationId\n            );\n            expect(result.data.deleteCustomer.customer.objectId).toEqual(\n              obj.id\n            );\n            expect(result.data.deleteCustomer.customer.someField1).toEqual(\n              'someField1Value1'\n            );\n            expect(result.data.deleteCustomer.customer.someField2).toEqual(\n              'someField2Value1'\n            );\n\n            await expectAsync(\n              obj.fetch({ useMasterKey: true })\n            ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n          });\n\n          it('should respect level permissions', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            function deleteObject(className, id, headers) {\n              const mutationName =\n                className.charAt(0).toLowerCase() + className.slice(1);\n              return apolloClient.mutate({\n                mutation: gql`\n                  mutation DeleteSomeObject(\n                    $id: ID!\n                  ) {\n                    delete: delete${className}(input: { id: $id }) {\n                      ${mutationName} {\n                        objectId\n                      }\n                    }\n                  }\n                `,\n                variables: {\n                  id,\n                },\n                context: {\n                  headers,\n                },\n              });\n            }\n\n            await Promise.all(\n              objects.slice(0, 3).map(async (obj) => {\n                const originalFieldValue = obj.get('someField');\n                await expectAsync(\n                  deleteObject(obj.className, obj.id)\n                ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual(originalFieldValue);\n              })\n            );\n            await Promise.all(\n              objects.slice(0, 3).map(async (obj) => {\n                const originalFieldValue = obj.get('someField');\n                await expectAsync(\n                  deleteObject(obj.className, obj.id, {\n                    'X-Parse-Session-Token': user4.getSessionToken(),\n                  })\n                ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual(originalFieldValue);\n              })\n            );\n            expect(\n              (await deleteObject(object4.className, object4.id)).data.delete[\n                object4.className.charAt(0).toLowerCase() +\n                  object4.className.slice(1)\n              ]\n            ).toEqual({ objectId: object4.id, __typename: 'PublicClass' });\n            await expectAsync(\n              object4.fetch({ useMasterKey: true })\n            ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n            expect(\n              (\n                await deleteObject(object1.className, object1.id, {\n                  'X-Parse-Master-Key': 'test',\n                })\n              ).data.delete[\n                object1.className.charAt(0).toLowerCase() +\n                  object1.className.slice(1)\n              ]\n            ).toEqual({ objectId: object1.id, __typename: 'GraphQLClass' });\n            await expectAsync(\n              object1.fetch({ useMasterKey: true })\n            ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n            expect(\n              (\n                await deleteObject(object2.className, object2.id, {\n                  'X-Parse-Session-Token': user2.getSessionToken(),\n                })\n              ).data.delete[\n                object2.className.charAt(0).toLowerCase() +\n                  object2.className.slice(1)\n              ]\n            ).toEqual({ objectId: object2.id, __typename: 'GraphQLClass' });\n            await expectAsync(\n              object2.fetch({ useMasterKey: true })\n            ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n            expect(\n              (\n                await deleteObject(object3.className, object3.id, {\n                  'X-Parse-Session-Token': user5.getSessionToken(),\n                })\n              ).data.delete[\n                object3.className.charAt(0).toLowerCase() +\n                  object3.className.slice(1)\n              ]\n            ).toEqual({ objectId: object3.id, __typename: 'GraphQLClass' });\n            await expectAsync(\n              object3.fetch({ useMasterKey: true })\n            ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n          });\n\n          it('should respect level permissions with specific class mutation', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            function deleteObject(className, id, headers) {\n              const mutationName =\n                className.charAt(0).toLowerCase() + className.slice(1);\n              return apolloClient.mutate({\n                mutation: gql`\n                  mutation DeleteSomeObject(\n                    $id: ID!\n                  ) {\n                    delete${className}(input: { id: $id }) {\n                      ${mutationName} {\n                        objectId\n                      }\n                    }\n                  }\n                `,\n                variables: {\n                  id,\n                },\n                context: {\n                  headers,\n                },\n              });\n            }\n\n            await Promise.all(\n              objects.slice(0, 3).map(async (obj) => {\n                const originalFieldValue = obj.get('someField');\n                await expectAsync(\n                  deleteObject(obj.className, obj.id)\n                ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual(originalFieldValue);\n              })\n            );\n            await Promise.all(\n              objects.slice(0, 3).map(async (obj) => {\n                const originalFieldValue = obj.get('someField');\n                await expectAsync(\n                  deleteObject(obj.className, obj.id, {\n                    'X-Parse-Session-Token': user4.getSessionToken(),\n                  })\n                ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual(originalFieldValue);\n              })\n            );\n            expect(\n              (await deleteObject(object4.className, object4.id)).data[\n                `delete${object4.className}`\n              ][\n                object4.className.charAt(0).toLowerCase() +\n                  object4.className.slice(1)\n              ].objectId\n            ).toEqual(object4.id);\n            await expectAsync(\n              object4.fetch({ useMasterKey: true })\n            ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n            expect(\n              (\n                await deleteObject(object1.className, object1.id, {\n                  'X-Parse-Master-Key': 'test',\n                })\n              ).data[`delete${object1.className}`][\n                object1.className.charAt(0).toLowerCase() +\n                  object1.className.slice(1)\n              ].objectId\n            ).toEqual(object1.id);\n            await expectAsync(\n              object1.fetch({ useMasterKey: true })\n            ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n            expect(\n              (\n                await deleteObject(object2.className, object2.id, {\n                  'X-Parse-Session-Token': user2.getSessionToken(),\n                })\n              ).data[`delete${object2.className}`][\n                object2.className.charAt(0).toLowerCase() +\n                  object2.className.slice(1)\n              ].objectId\n            ).toEqual(object2.id);\n            await expectAsync(\n              object2.fetch({ useMasterKey: true })\n            ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n            expect(\n              (\n                await deleteObject(object3.className, object3.id, {\n                  'X-Parse-Session-Token': user5.getSessionToken(),\n                })\n              ).data[`delete${object3.className}`][\n                object3.className.charAt(0).toLowerCase() +\n                  object3.className.slice(1)\n              ].objectId\n            ).toEqual(object3.id);\n            await expectAsync(\n              object3.fetch({ useMasterKey: true })\n            ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n          });\n        });\n      });\n\n      describe('Files Mutations', () => {\n        describe('Create', () => {\n          it('should return File object', async () => {\n            const clientMutationId = uuidv4();\n\n            parseServer = await global.reconfigureServer({\n              publicServerURL: 'http://localhost:13377/parse',\n            });\n\n            const body = new FormData();\n            body.append(\n              'operations',\n              JSON.stringify({\n                query: `\n                  mutation CreateFile($input: CreateFileInput!) {\n                    createFile(input: $input) {\n                      clientMutationId\n                      fileInfo {\n                        name\n                        url\n                      }\n                    }\n                  }\n                `,\n                variables: {\n                  input: {\n                    clientMutationId,\n                    upload: null,\n                  },\n                },\n              })\n            );\n            body.append(\n              'map',\n              JSON.stringify({ 1: ['variables.input.upload'] })\n            );\n            body.append('1', 'My File Content', {\n              filename: 'myFileName.txt',\n              contentType: 'text/plain',\n            });\n\n            let res = await fetch('http://localhost:13377/graphql', {\n              method: 'POST',\n              headers,\n              body,\n            });\n\n            expect(res.status).toEqual(200);\n\n            const result = JSON.parse(await res.text());\n\n            expect(result.data.createFile.clientMutationId).toEqual(\n              clientMutationId\n            );\n            expect(result.data.createFile.fileInfo.name).toEqual(\n              jasmine.stringMatching(/_myFileName.txt$/)\n            );\n            expect(result.data.createFile.fileInfo.url).toEqual(\n              jasmine.stringMatching(/_myFileName.txt$/)\n            );\n\n            res = await fetch(result.data.createFile.fileInfo.url);\n\n            expect(res.status).toEqual(200);\n            expect(await res.text()).toEqual('My File Content');\n          });\n        });\n      });\n\n      describe('Users Queries', () => {\n        it('should return current logged user', async () => {\n          const userName = 'user1',\n            password = 'user1',\n            email = 'emailUser1@parse.com';\n\n          const user = new Parse.User();\n          user.setUsername(userName);\n          user.setPassword(password);\n          user.setEmail(email);\n          await user.signUp();\n\n          const session = await Parse.Session.current();\n          const result = await apolloClient.query({\n            query: gql`\n              query GetCurrentUser {\n                viewer {\n                  user {\n                    id\n                    username\n                    email\n                  }\n                }\n              }\n            `,\n            context: {\n              headers: {\n                'X-Parse-Session-Token': session.getSessionToken(),\n              },\n            },\n          });\n\n          const {\n            id,\n            username: resultUserName,\n            email: resultEmail,\n          } = result.data.viewer.user;\n          expect(id).toBeDefined();\n          expect(resultUserName).toEqual(userName);\n          expect(resultEmail).toEqual(email);\n        });\n\n        it('should return logged user including pointer', async () => {\n          const foo = new Parse.Object('Foo');\n          foo.set('bar', 'hello');\n\n          const userName = 'user1',\n            password = 'user1',\n            email = 'emailUser1@parse.com';\n\n          const user = new Parse.User();\n          user.setUsername(userName);\n          user.setPassword(password);\n          user.setEmail(email);\n          user.set('userFoo', foo);\n          await user.signUp();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const session = await Parse.Session.current();\n          const result = await apolloClient.query({\n            query: gql`\n              query GetCurrentUser {\n                viewer {\n                  sessionToken\n                  user {\n                    id\n                    objectId\n                    userFoo {\n                      bar\n                    }\n                  }\n                }\n              }\n            `,\n            context: {\n              headers: {\n                'X-Parse-Session-Token': session.getSessionToken(),\n              },\n            },\n          });\n\n          const sessionToken = result.data.viewer.sessionToken;\n          const { objectId, userFoo: resultFoo } = result.data.viewer.user;\n          expect(objectId).toEqual(user.id);\n          expect(sessionToken).toBeDefined();\n          expect(resultFoo).toBeDefined();\n          expect(resultFoo.bar).toEqual('hello');\n        });\n      });\n\n      describe('Users Mutations', () => {\n        it('should sign user up', async () => {\n          const clientMutationId = uuidv4();\n          const userSchema = new Parse.Schema('_User');\n          userSchema.addString('someField');\n          await userSchema.update();\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n          const result = await apolloClient.mutate({\n            mutation: gql`\n              mutation SignUp($input: SignUpInput!) {\n                signUp(input: $input) {\n                  clientMutationId\n                  viewer {\n                    sessionToken\n                    user {\n                      someField\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              input: {\n                clientMutationId,\n                fields: {\n                  username: 'user1',\n                  password: 'user1',\n                  someField: 'someValue',\n                },\n              },\n            },\n          });\n\n          expect(result.data.signUp.clientMutationId).toEqual(clientMutationId);\n          expect(result.data.signUp.viewer.sessionToken).toBeDefined();\n          expect(result.data.signUp.viewer.user.someField).toEqual('someValue');\n          expect(typeof result.data.signUp.viewer.sessionToken).toBe('string');\n        });\n\n        it('should login with user', async () => {\n          const clientMutationId = uuidv4();\n          const userSchema = new Parse.Schema('_User');\n          parseServer = await global.reconfigureServer({\n            publicServerURL: 'http://localhost:13377/parse',\n            auth: {\n              myAuth: {\n                module: global.mockCustomAuthenticator('parse', 'graphql'),\n              },\n            },\n          });\n\n          userSchema.addString('someField');\n          await userSchema.update();\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n          const result = await apolloClient.mutate({\n            mutation: gql`\n              mutation LogInWith($input: LogInWithInput!) {\n                logInWith(input: $input) {\n                  clientMutationId\n                  viewer {\n                    sessionToken\n                    user {\n                      someField\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              input: {\n                clientMutationId,\n                authData: {\n                  myAuth: {\n                    id: 'parse',\n                    password: 'graphql',\n                  },\n                },\n                fields: {\n                  someField: 'someValue',\n                },\n              },\n            },\n          });\n\n          expect(result.data.logInWith.clientMutationId).toEqual(\n            clientMutationId\n          );\n          expect(result.data.logInWith.viewer.sessionToken).toBeDefined();\n          expect(result.data.logInWith.viewer.user.someField).toEqual(\n            'someValue'\n          );\n          expect(typeof result.data.logInWith.viewer.sessionToken).toBe(\n            'string'\n          );\n        });\n\n        it('should log the user in', async () => {\n          const clientMutationId = uuidv4();\n          const user = new Parse.User();\n          user.setUsername('user1');\n          user.setPassword('user1');\n          user.set('someField', 'someValue');\n          await user.signUp();\n          await Parse.User.logOut();\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n          const result = await apolloClient.mutate({\n            mutation: gql`\n              mutation LogInUser($input: LogInInput!) {\n                logIn(input: $input) {\n                  clientMutationId\n                  viewer {\n                    sessionToken\n                    user {\n                      someField\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              input: {\n                clientMutationId,\n                username: 'user1',\n                password: 'user1',\n              },\n            },\n          });\n\n          expect(result.data.logIn.clientMutationId).toEqual(clientMutationId);\n          expect(result.data.logIn.viewer.sessionToken).toBeDefined();\n          expect(result.data.logIn.viewer.user.someField).toEqual('someValue');\n          expect(typeof result.data.logIn.viewer.sessionToken).toBe('string');\n        });\n\n        it('should log the user out', async () => {\n          const clientMutationId = uuidv4();\n          const user = new Parse.User();\n          user.setUsername('user1');\n          user.setPassword('user1');\n          await user.signUp();\n          await Parse.User.logOut();\n\n          const logIn = await apolloClient.mutate({\n            mutation: gql`\n              mutation LogInUser($input: LogInInput!) {\n                logIn(input: $input) {\n                  viewer {\n                    sessionToken\n                  }\n                }\n              }\n            `,\n            variables: {\n              input: {\n                username: 'user1',\n                password: 'user1',\n              },\n            },\n          });\n\n          const sessionToken = logIn.data.logIn.viewer.sessionToken;\n\n          const logOut = await apolloClient.mutate({\n            mutation: gql`\n              mutation LogOutUser($input: LogOutInput!) {\n                logOut(input: $input) {\n                  clientMutationId\n                  viewer {\n                    sessionToken\n                  }\n                }\n              }\n            `,\n            context: {\n              headers: {\n                'X-Parse-Session-Token': sessionToken,\n              },\n            },\n            variables: {\n              input: {\n                clientMutationId,\n              },\n            },\n          });\n          expect(logOut.data.logOut.clientMutationId).toEqual(clientMutationId);\n          expect(logOut.data.logOut.viewer.sessionToken).toEqual(sessionToken);\n\n          try {\n            await apolloClient.query({\n              query: gql`\n                query GetCurrentUser {\n                  viewer {\n                    username\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': sessionToken,\n                },\n              },\n            });\n            fail('should not retrieve current user due to session token');\n          } catch (err) {\n            const { statusCode, result } = err.networkError;\n            expect(statusCode).toBe(400);\n            expect(result).toEqual({\n              code: 209,\n              error: 'Invalid session token',\n            });\n          }\n        });\n\n        it('should send reset password', async () => {\n          const clientMutationId = uuidv4();\n          const emailAdapter = {\n            sendVerificationEmail: () => {},\n            sendPasswordResetEmail: () => Promise.resolve(),\n            sendMail: () => {},\n          };\n          parseServer = await global.reconfigureServer({\n            appName: 'test',\n            emailAdapter: emailAdapter,\n            publicServerURL: 'http://test.test',\n          });\n          const user = new Parse.User();\n          user.setUsername('user1');\n          user.setPassword('user1');\n          user.setEmail('user1@user1.user1');\n          await user.signUp();\n          await Parse.User.logOut();\n          const result = await apolloClient.mutate({\n            mutation: gql`\n              mutation ResetPassword($input: ResetPasswordInput!) {\n                resetPassword(input: $input) {\n                  clientMutationId\n                  ok\n                }\n              }\n            `,\n            variables: {\n              input: {\n                clientMutationId,\n                email: 'user1@user1.user1',\n              },\n            },\n          });\n\n          expect(result.data.resetPassword.clientMutationId).toEqual(\n            clientMutationId\n          );\n          expect(result.data.resetPassword.ok).toBeTruthy();\n        });\n        it('should send verification email again', async () => {\n          const clientMutationId = uuidv4();\n          const emailAdapter = {\n            sendVerificationEmail: () => {},\n            sendPasswordResetEmail: () => Promise.resolve(),\n            sendMail: () => {},\n          };\n          parseServer = await global.reconfigureServer({\n            appName: 'test',\n            emailAdapter: emailAdapter,\n            publicServerURL: 'http://test.test',\n          });\n          const user = new Parse.User();\n          user.setUsername('user1');\n          user.setPassword('user1');\n          user.setEmail('user1@user1.user1');\n          await user.signUp();\n          await Parse.User.logOut();\n          const result = await apolloClient.mutate({\n            mutation: gql`\n              mutation SendVerificationEmail(\n                $input: SendVerificationEmailInput!\n              ) {\n                sendVerificationEmail(input: $input) {\n                  clientMutationId\n                  ok\n                }\n              }\n            `,\n            variables: {\n              input: {\n                clientMutationId,\n                email: 'user1@user1.user1',\n              },\n            },\n          });\n\n          expect(result.data.sendVerificationEmail.clientMutationId).toEqual(\n            clientMutationId\n          );\n          expect(result.data.sendVerificationEmail.ok).toBeTruthy();\n        });\n      });\n\n      describe('Session Token', () => {\n        it('should fail due to invalid session token', async () => {\n          try {\n            await apolloClient.query({\n              query: gql`\n                query GetCurrentUser {\n                  me {\n                    username\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': 'foo',\n                },\n              },\n            });\n            fail('should not retrieve current user due to session token');\n          } catch (err) {\n            const { statusCode, result } = err.networkError;\n            expect(statusCode).toBe(400);\n            expect(result).toEqual({\n              code: 209,\n              error: 'Invalid session token',\n            });\n          }\n        });\n\n        it('should fail due to empty session token', async () => {\n          try {\n            await apolloClient.query({\n              query: gql`\n                query GetCurrentUser {\n                  viewer {\n                    user {\n                      username\n                    }\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': '',\n                },\n              },\n            });\n            fail('should not retrieve current user due to session token');\n          } catch (err) {\n            const { graphQLErrors } = err;\n            expect(graphQLErrors.length).toBe(1);\n            expect(graphQLErrors[0].message).toBe('Invalid session token');\n          }\n        });\n\n        it('should find a user and fail due to empty session token', async () => {\n          const car = new Parse.Object('Car');\n          await car.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          try {\n            await apolloClient.query({\n              query: gql`\n                query GetCurrentUser {\n                  viewer {\n                    user {\n                      username\n                    }\n                  }\n                  cars {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': '',\n                },\n              },\n            });\n            fail('should not retrieve current user due to session token');\n          } catch (err) {\n            const { graphQLErrors } = err;\n            expect(graphQLErrors.length).toBe(1);\n            expect(graphQLErrors[0].message).toBe('Invalid session token');\n          }\n        });\n      });\n\n      describe('Functions Mutations', () => {\n        it('can be called', async () => {\n          try {\n            const clientMutationId = uuidv4();\n\n            Parse.Cloud.define('hello', async () => {\n              return 'Hello world!';\n            });\n\n            const result = await apolloClient.mutate({\n              mutation: gql`\n                mutation CallFunction($input: CallCloudCodeInput!) {\n                  callCloudCode(input: $input) {\n                    clientMutationId\n                    result\n                  }\n                }\n              `,\n              variables: {\n                input: {\n                  clientMutationId,\n                  functionName: 'hello',\n                },\n              },\n            });\n\n            expect(result.data.callCloudCode.clientMutationId).toEqual(\n              clientMutationId\n            );\n            expect(result.data.callCloudCode.result).toEqual('Hello world!');\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('can throw errors', async () => {\n          Parse.Cloud.define('hello', async () => {\n            throw new Error('Some error message.');\n          });\n\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CallFunction {\n                  callCloudCode(input: { functionName: hello }) {\n                    result\n                  }\n                }\n              `,\n            });\n            fail('Should throw an error');\n          } catch (e) {\n            const { graphQLErrors } = e;\n            expect(graphQLErrors.length).toBe(1);\n            expect(graphQLErrors[0].message).toBe('Some error message.');\n          }\n        });\n\n        it('should accept different params', (done) => {\n          Parse.Cloud.define('hello', async (req) => {\n            expect(req.params.date instanceof Date).toBe(true);\n            expect(req.params.date.getTime()).toBe(1463907600000);\n            expect(req.params.dateList[0] instanceof Date).toBe(true);\n            expect(req.params.dateList[0].getTime()).toBe(1463907600000);\n            expect(req.params.complexStructure.date[0] instanceof Date).toBe(\n              true\n            );\n            expect(req.params.complexStructure.date[0].getTime()).toBe(\n              1463907600000\n            );\n            expect(\n              req.params.complexStructure.deepDate.date[0] instanceof Date\n            ).toBe(true);\n            expect(req.params.complexStructure.deepDate.date[0].getTime()).toBe(\n              1463907600000\n            );\n            expect(\n              req.params.complexStructure.deepDate2[0].date instanceof Date\n            ).toBe(true);\n            expect(\n              req.params.complexStructure.deepDate2[0].date.getTime()\n            ).toBe(1463907600000);\n            // Regression for #2294\n            expect(req.params.file instanceof Parse.File).toBe(true);\n            expect(req.params.file.url()).toEqual('https://some.url');\n            // Regression for #2204\n            expect(req.params.array).toEqual(['a', 'b', 'c']);\n            expect(Array.isArray(req.params.array)).toBe(true);\n            expect(req.params.arrayOfArray).toEqual([\n              ['a', 'b', 'c'],\n              ['d', 'e', 'f'],\n            ]);\n            expect(Array.isArray(req.params.arrayOfArray)).toBe(true);\n            expect(Array.isArray(req.params.arrayOfArray[0])).toBe(true);\n            expect(Array.isArray(req.params.arrayOfArray[1])).toBe(true);\n\n            done();\n          });\n\n          const params = {\n            date: {\n              __type: 'Date',\n              iso: '2016-05-22T09:00:00.000Z',\n            },\n            dateList: [\n              {\n                __type: 'Date',\n                iso: '2016-05-22T09:00:00.000Z',\n              },\n            ],\n            lol: 'hello',\n            complexStructure: {\n              date: [\n                {\n                  __type: 'Date',\n                  iso: '2016-05-22T09:00:00.000Z',\n                },\n              ],\n              deepDate: {\n                date: [\n                  {\n                    __type: 'Date',\n                    iso: '2016-05-22T09:00:00.000Z',\n                  },\n                ],\n              },\n              deepDate2: [\n                {\n                  date: {\n                    __type: 'Date',\n                    iso: '2016-05-22T09:00:00.000Z',\n                  },\n                },\n              ],\n            },\n            file: Parse.File.fromJSON({\n              __type: 'File',\n              name: 'name',\n              url: 'https://some.url',\n            }),\n            array: ['a', 'b', 'c'],\n            arrayOfArray: [\n              ['a', 'b', 'c'],\n              ['d', 'e', 'f'],\n            ],\n          };\n\n          apolloClient.mutate({\n            mutation: gql`\n              mutation CallFunction($params: Object) {\n                callCloudCode(input: { functionName: hello, params: $params }) {\n                  result\n                }\n              }\n            `,\n            variables: {\n              params,\n            },\n          });\n        });\n\n        it('should list all functions in the enum type', async () => {\n          try {\n            Parse.Cloud.define('a', async () => {\n              return 'hello a';\n            });\n\n            Parse.Cloud.define('b', async () => {\n              return 'hello b';\n            });\n\n            Parse.Cloud.define('_underscored', async () => {\n              return 'hello _underscored';\n            });\n\n            Parse.Cloud.define('contains1Number', async () => {\n              return 'hello contains1Number';\n            });\n\n            const functionEnum = (\n              await apolloClient.query({\n                query: gql`\n                  query ObjectType {\n                    __type(name: \"CloudCodeFunction\") {\n                      kind\n                      enumValues {\n                        name\n                      }\n                    }\n                  }\n                `,\n              })\n            ).data['__type'];\n            expect(functionEnum.kind).toEqual('ENUM');\n            expect(\n              functionEnum.enumValues.map((value) => value.name).sort()\n            ).toEqual(['_underscored', 'a', 'b', 'contains1Number']);\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should warn functions not matching GraphQL allowed names', async () => {\n          try {\n            spyOn(\n              parseGraphQLServer.parseGraphQLSchema.log,\n              'warn'\n            ).and.callThrough();\n\n            Parse.Cloud.define('a', async () => {\n              return 'hello a';\n            });\n\n            Parse.Cloud.define('double-barrelled', async () => {\n              return 'hello b';\n            });\n\n            Parse.Cloud.define('1NumberInTheBeggning', async () => {\n              return 'hello contains1Number';\n            });\n\n            const functionEnum = (\n              await apolloClient.query({\n                query: gql`\n                  query ObjectType {\n                    __type(name: \"CloudCodeFunction\") {\n                      kind\n                      enumValues {\n                        name\n                      }\n                    }\n                  }\n                `,\n              })\n            ).data['__type'];\n            expect(functionEnum.kind).toEqual('ENUM');\n            expect(\n              functionEnum.enumValues.map((value) => value.name).sort()\n            ).toEqual(['a']);\n            expect(\n              parseGraphQLServer.parseGraphQLSchema.log.warn.calls\n                .all()\n                .map((call) => call.args[0])\n                .sort()\n            ).toEqual([\n              'Function 1NumberInTheBeggning could not be added to the auto schema because GraphQL names must match /^[_a-zA-Z][_a-zA-Z0-9]*$/.',\n              'Function double-barrelled could not be added to the auto schema because GraphQL names must match /^[_a-zA-Z][_a-zA-Z0-9]*$/.',\n            ]);\n          } catch (e) {\n            handleError(e);\n          }\n        });\n      });\n\n      describe('Data Types', () => {\n        it('should support String', async () => {\n          try {\n            const someFieldValue = 'some string';\n\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(\n                    input: { name: \"SomeClass\", schemaFields: $schemaFields }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addStrings: [{ name: 'someField' }],\n                },\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.someField.type).toEqual('String');\n\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                  createSomeClass(input: { fields: $fields }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  someField: someFieldValue,\n                },\n              },\n            });\n\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!, $someFieldValue: String) {\n                  someClass(id: $id) {\n                    someField\n                  }\n                  someClasses(\n                    where: { someField: { equalTo: $someFieldValue } }\n                  ) {\n                    edges {\n                      node {\n                        someField\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id,\n                someFieldValue,\n              },\n            });\n\n            expect(typeof getResult.data.someClass.someField).toEqual('string');\n            expect(getResult.data.someClass.someField).toEqual(someFieldValue);\n            expect(getResult.data.someClasses.edges.length).toEqual(1);\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should support Int numbers', async () => {\n          try {\n            const someFieldValue = 123;\n\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(\n                    input: { name: \"SomeClass\", schemaFields: $schemaFields }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addNumbers: [{ name: 'someField' }],\n                },\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                  createSomeClass(input: { fields: $fields }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  someField: someFieldValue,\n                },\n              },\n            });\n\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.someField.type).toEqual('Number');\n\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!, $someFieldValue: Float) {\n                  someClass(id: $id) {\n                    someField\n                  }\n                  someClasses(\n                    where: { someField: { equalTo: $someFieldValue } }\n                  ) {\n                    edges {\n                      node {\n                        someField\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id,\n                someFieldValue,\n              },\n            });\n\n            expect(typeof getResult.data.someClass.someField).toEqual('number');\n            expect(getResult.data.someClass.someField).toEqual(someFieldValue);\n            expect(getResult.data.someClasses.edges.length).toEqual(1);\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should support Float numbers', async () => {\n          try {\n            const someFieldValue = 123.4;\n\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(\n                    input: { name: \"SomeClass\", schemaFields: $schemaFields }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addNumbers: [{ name: 'someField' }],\n                },\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.someField.type).toEqual('Number');\n\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                  createSomeClass(input: { fields: $fields }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  someField: someFieldValue,\n                },\n              },\n            });\n\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!, $someFieldValue: Float) {\n                  someClass(id: $id) {\n                    someField\n                  }\n                  someClasses(\n                    where: { someField: { equalTo: $someFieldValue } }\n                  ) {\n                    edges {\n                      node {\n                        someField\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id,\n                someFieldValue,\n              },\n            });\n\n            expect(typeof getResult.data.someClass.someField).toEqual('number');\n            expect(getResult.data.someClass.someField).toEqual(someFieldValue);\n            expect(getResult.data.someClasses.edges.length).toEqual(1);\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should support Boolean', async () => {\n          try {\n            const someFieldValueTrue = true;\n            const someFieldValueFalse = false;\n\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(\n                    input: { name: \"SomeClass\", schemaFields: $schemaFields }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addBooleans: [\n                    { name: 'someFieldTrue' },\n                    { name: 'someFieldFalse' },\n                  ],\n                },\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.someFieldTrue.type).toEqual('Boolean');\n            expect(schema.fields.someFieldFalse.type).toEqual('Boolean');\n\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                  createSomeClass(input: { fields: $fields }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  someFieldTrue: someFieldValueTrue,\n                  someFieldFalse: someFieldValueFalse,\n                },\n              },\n            });\n\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject(\n                  $id: ID!\n                  $someFieldValueTrue: Boolean\n                  $someFieldValueFalse: Boolean\n                ) {\n                  someClass(id: $id) {\n                    someFieldTrue\n                    someFieldFalse\n                  }\n                  someClasses(\n                    where: {\n                      someFieldTrue: { equalTo: $someFieldValueTrue }\n                      someFieldFalse: { equalTo: $someFieldValueFalse }\n                    }\n                  ) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id,\n                someFieldValueTrue,\n                someFieldValueFalse,\n              },\n            });\n\n            expect(typeof getResult.data.someClass.someFieldTrue).toEqual(\n              'boolean'\n            );\n            expect(typeof getResult.data.someClass.someFieldFalse).toEqual(\n              'boolean'\n            );\n            expect(getResult.data.someClass.someFieldTrue).toEqual(true);\n            expect(getResult.data.someClass.someFieldFalse).toEqual(false);\n            expect(getResult.data.someClasses.edges.length).toEqual(1);\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should support Date', async () => {\n          try {\n            const someFieldValue = new Date();\n\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(\n                    input: { name: \"SomeClass\", schemaFields: $schemaFields }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addDates: [{ name: 'someField' }],\n                },\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.someField.type).toEqual('Date');\n\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                  createSomeClass(input: { fields: $fields }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  someField: someFieldValue,\n                },\n              },\n            });\n\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!) {\n                  someClass(id: $id) {\n                    someField\n                  }\n                  someClasses(where: { someField: { exists: true } }) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id,\n              },\n            });\n\n            expect(new Date(getResult.data.someClass.someField)).toEqual(\n              someFieldValue\n            );\n            expect(getResult.data.someClasses.edges.length).toEqual(1);\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should support createdAt and updatedAt', async () => {\n          await apolloClient.mutate({\n            mutation: gql`\n              mutation CreateClass {\n                createClass(input: { name: \"SomeClass\" }) {\n                  clientMutationId\n                }\n              }\n            `,\n            context: {\n              headers: {\n                'X-Parse-Master-Key': 'test',\n              },\n            },\n          });\n\n          const schema = await new Parse.Schema('SomeClass').get();\n          expect(schema.fields.createdAt.type).toEqual('Date');\n          expect(schema.fields.updatedAt.type).toEqual('Date');\n        });\n\n        it('should support ACL', async () => {\n          const someClass = new Parse.Object('SomeClass');\n          await someClass.save();\n\n          const user = new Parse.User();\n          user.set('username', 'username');\n          user.set('password', 'password');\n          await user.signUp();\n\n          const user2 = new Parse.User();\n          user2.set('username', 'username2');\n          user2.set('password', 'password2');\n          await user2.signUp();\n\n          const roleACL = new Parse.ACL();\n          roleACL.setPublicReadAccess(true);\n\n          const role = new Parse.Role('aRole', roleACL);\n          await role.save();\n\n          const role2 = new Parse.Role('aRole2', roleACL);\n          await role2.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const gqlUser = (\n            await apolloClient.query({\n              query: gql`\n                query getUser($id: ID!) {\n                  user(id: $id) {\n                    id\n                  }\n                }\n              `,\n              variables: { id: user.id },\n            })\n          ).data.user;\n          const {\n            data: { createSomeClass },\n          } = await apolloClient.mutate({\n            mutation: gql`\n              mutation Create($fields: CreateSomeClassFieldsInput) {\n                createSomeClass(input: { fields: $fields }) {\n                  someClass {\n                    id\n                    objectId\n                    ACL {\n                      users {\n                        userId\n                        read\n                        write\n                      }\n                      roles {\n                        roleName\n                        read\n                        write\n                      }\n                      public {\n                        read\n                        write\n                      }\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              fields: {\n                ACL: {\n                  users: [\n                    { userId: gqlUser.id, read: true, write: true },\n                    { userId: user2.id, read: true, write: false },\n                  ],\n                  roles: [\n                    { roleName: 'aRole', read: true, write: false },\n                    { roleName: 'aRole2', read: false, write: true },\n                  ],\n                  public: { read: true, write: true },\n                },\n              },\n            },\n          });\n\n          const expectedCreateACL = {\n            __typename: 'ACL',\n            users: [\n              {\n                userId: toGlobalId('_User', user.id),\n                read: true,\n                write: true,\n                __typename: 'UserACL',\n              },\n              {\n                userId: toGlobalId('_User', user2.id),\n                read: true,\n                write: false,\n                __typename: 'UserACL',\n              },\n            ],\n            roles: [\n              {\n                roleName: 'aRole',\n                read: true,\n                write: false,\n                __typename: 'RoleACL',\n              },\n              {\n                roleName: 'aRole2',\n                read: false,\n                write: true,\n                __typename: 'RoleACL',\n              },\n            ],\n            public: { read: true, write: true, __typename: 'PublicACL' },\n          };\n          const query1 = new Parse.Query('SomeClass');\n          const obj1 = (\n            await query1.get(createSomeClass.someClass.objectId, {\n              useMasterKey: true,\n            })\n          ).toJSON();\n          expect(obj1.ACL[user.id]).toEqual({ read: true, write: true });\n          expect(obj1.ACL[user2.id]).toEqual({ read: true });\n          expect(obj1.ACL['role:aRole']).toEqual({ read: true });\n          expect(obj1.ACL['role:aRole2']).toEqual({ write: true });\n          expect(obj1.ACL['*']).toEqual({ read: true, write: true });\n          expect(createSomeClass.someClass.ACL).toEqual(expectedCreateACL);\n\n          const {\n            data: { updateSomeClass },\n          } = await apolloClient.mutate({\n            mutation: gql`\n              mutation Update($id: ID!, $fields: UpdateSomeClassFieldsInput) {\n                updateSomeClass(input: { id: $id, fields: $fields }) {\n                  someClass {\n                    id\n                    objectId\n                    ACL {\n                      users {\n                        userId\n                        read\n                        write\n                      }\n                      roles {\n                        roleName\n                        read\n                        write\n                      }\n                      public {\n                        read\n                        write\n                      }\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              id: createSomeClass.someClass.id,\n              fields: {\n                ACL: {\n                  roles: [{ roleName: 'aRole', write: true, read: true }],\n                  public: { read: true, write: false },\n                },\n              },\n            },\n          });\n\n          const expectedUpdateACL = {\n            __typename: 'ACL',\n            users: null,\n            roles: [\n              {\n                roleName: 'aRole',\n                read: true,\n                write: true,\n                __typename: 'RoleACL',\n              },\n            ],\n            public: { read: true, write: false, __typename: 'PublicACL' },\n          };\n\n          const query2 = new Parse.Query('SomeClass');\n          const obj2 = (\n            await query2.get(createSomeClass.someClass.objectId, {\n              useMasterKey: true,\n            })\n          ).toJSON();\n\n          expect(obj2.ACL['role:aRole']).toEqual({ write: true, read: true });\n          expect(obj2.ACL[user.id]).toBeUndefined();\n          expect(obj2.ACL['*']).toEqual({ read: true });\n          expect(updateSomeClass.someClass.ACL).toEqual(expectedUpdateACL);\n        });\n\n        it('should support pointer on create', async () => {\n          const company = new Parse.Object('Company');\n          company.set('name', 'imACompany1');\n          await company.save();\n\n          const country = new Parse.Object('Country');\n          country.set('name', 'imACountry');\n          country.set('company', company);\n          await country.save();\n\n          const company2 = new Parse.Object('Company');\n          company2.set('name', 'imACompany2');\n          await company2.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const {\n            data: {\n              createCountry: { country: result },\n            },\n          } = await apolloClient.mutate({\n            mutation: gql`\n              mutation Create($fields: CreateCountryFieldsInput) {\n                createCountry(input: { fields: $fields }) {\n                  country {\n                    id\n                    objectId\n                    company {\n                      id\n                      objectId\n                      name\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              fields: {\n                name: 'imCountry2',\n                company: { link: company2.id },\n              },\n            },\n          });\n\n          expect(result.id).toBeDefined();\n          expect(result.company.objectId).toEqual(company2.id);\n          expect(result.company.name).toEqual('imACompany2');\n        });\n\n        it('should support nested pointer on create', async () => {\n          const company = new Parse.Object('Company');\n          company.set('name', 'imACompany1');\n          await company.save();\n\n          const country = new Parse.Object('Country');\n          country.set('name', 'imACountry');\n          country.set('company', company);\n          await country.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const {\n            data: {\n              createCountry: { country: result },\n            },\n          } = await apolloClient.mutate({\n            mutation: gql`\n              mutation Create($fields: CreateCountryFieldsInput) {\n                createCountry(input: { fields: $fields }) {\n                  country {\n                    id\n                    company {\n                      id\n                      name\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              fields: {\n                name: 'imCountry2',\n                company: {\n                  createAndLink: {\n                    name: 'imACompany2',\n                  },\n                },\n              },\n            },\n          });\n\n          expect(result.id).toBeDefined();\n          expect(result.company.id).toBeDefined();\n          expect(result.company.name).toEqual('imACompany2');\n        });\n\n        it('should support pointer on update', async () => {\n          const company = new Parse.Object('Company');\n          company.set('name', 'imACompany1');\n          await company.save();\n\n          const country = new Parse.Object('Country');\n          country.set('name', 'imACountry');\n          country.set('company', company);\n          await country.save();\n\n          const company2 = new Parse.Object('Company');\n          company2.set('name', 'imACompany2');\n          await company2.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const {\n            data: {\n              updateCountry: { country: result },\n            },\n          } = await apolloClient.mutate({\n            mutation: gql`\n              mutation Update($id: ID!, $fields: UpdateCountryFieldsInput) {\n                updateCountry(input: { id: $id, fields: $fields }) {\n                  country {\n                    id\n                    objectId\n                    company {\n                      id\n                      objectId\n                      name\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              id: country.id,\n              fields: {\n                company: { link: company2.id },\n              },\n            },\n          });\n\n          expect(result.id).toBeDefined();\n          expect(result.company.objectId).toEqual(company2.id);\n          expect(result.company.name).toEqual('imACompany2');\n        });\n\n        it('should support nested pointer on update', async () => {\n          const company = new Parse.Object('Company');\n          company.set('name', 'imACompany1');\n          await company.save();\n\n          const country = new Parse.Object('Country');\n          country.set('name', 'imACountry');\n          country.set('company', company);\n          await country.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const {\n            data: {\n              updateCountry: { country: result },\n            },\n          } = await apolloClient.mutate({\n            mutation: gql`\n              mutation Update($id: ID!, $fields: UpdateCountryFieldsInput) {\n                updateCountry(input: { id: $id, fields: $fields }) {\n                  country {\n                    id\n                    company {\n                      id\n                      name\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              id: country.id,\n              fields: {\n                company: {\n                  createAndLink: {\n                    name: 'imACompany2',\n                  },\n                },\n              },\n            },\n          });\n\n          expect(result.id).toBeDefined();\n          expect(result.company.id).toBeDefined();\n          expect(result.company.name).toEqual('imACompany2');\n        });\n\n        it_only_db('mongo')(\n          'should support relation and nested relation on create',\n          async () => {\n            const company = new Parse.Object('Company');\n            company.set('name', 'imACompany1');\n            await company.save();\n\n            const country = new Parse.Object('Country');\n            country.set('name', 'imACountry');\n            country.relation('companies').add(company);\n            await country.save();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const {\n              data: {\n                createCountry: { country: result },\n              },\n            } = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateCountry($fields: CreateCountryFieldsInput) {\n                  createCountry(input: { fields: $fields }) {\n                    country {\n                      id\n                      objectId\n                      name\n                      companies {\n                        edges {\n                          node {\n                            id\n                            objectId\n                            name\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  name: 'imACountry2',\n                  companies: {\n                    add: [company.id],\n                    createAndAdd: [\n                      {\n                        name: 'imACompany2',\n                      },\n                      {\n                        name: 'imACompany3',\n                      },\n                    ],\n                  },\n                },\n              },\n            });\n\n            expect(result.id).toBeDefined();\n            expect(result.name).toEqual('imACountry2');\n            expect(result.companies.edges.length).toEqual(3);\n            expect(\n              result.companies.edges.some((o) => o.node.objectId === company.id)\n            ).toBeTruthy();\n            expect(\n              result.companies.edges.some((o) => o.node.name === 'imACompany2')\n            ).toBeTruthy();\n            expect(\n              result.companies.edges.some((o) => o.node.name === 'imACompany3')\n            ).toBeTruthy();\n          }\n        );\n\n        it_only_db('mongo')('should support deep nested creation', async () => {\n          const team = new Parse.Object('Team');\n          team.set('name', 'imATeam1');\n          await team.save();\n\n          const company = new Parse.Object('Company');\n          company.set('name', 'imACompany1');\n          company.relation('teams').add(team);\n          await company.save();\n\n          const country = new Parse.Object('Country');\n          country.set('name', 'imACountry');\n          country.relation('companies').add(company);\n          await country.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const {\n            data: {\n              createCountry: { country: result },\n            },\n          } = await apolloClient.mutate({\n            mutation: gql`\n              mutation CreateCountry($fields: CreateCountryFieldsInput) {\n                createCountry(input: { fields: $fields }) {\n                  country {\n                    id\n                    name\n                    companies {\n                      edges {\n                        node {\n                          id\n                          name\n                          teams {\n                            edges {\n                              node {\n                                id\n                                name\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              fields: {\n                name: 'imACountry2',\n                companies: {\n                  createAndAdd: [\n                    {\n                      name: 'imACompany2',\n                      teams: {\n                        createAndAdd: {\n                          name: 'imATeam2',\n                        },\n                      },\n                    },\n                    {\n                      name: 'imACompany3',\n                      teams: {\n                        createAndAdd: {\n                          name: 'imATeam3',\n                        },\n                      },\n                    },\n                  ],\n                },\n              },\n            },\n          });\n\n          expect(result.id).toBeDefined();\n          expect(result.name).toEqual('imACountry2');\n          expect(result.companies.edges.length).toEqual(2);\n          expect(\n            result.companies.edges.some(\n              (c) =>\n                c.node.name === 'imACompany2' &&\n                c.node.teams.edges.some((t) => t.node.name === 'imATeam2')\n            )\n          ).toBeTruthy();\n          expect(\n            result.companies.edges.some(\n              (c) =>\n                c.node.name === 'imACompany3' &&\n                c.node.teams.edges.some((t) => t.node.name === 'imATeam3')\n            )\n          ).toBeTruthy();\n        });\n\n        it_only_db('mongo')(\n          'should support relation and nested relation on update',\n          async () => {\n            const company1 = new Parse.Object('Company');\n            company1.set('name', 'imACompany1');\n            await company1.save();\n\n            const company2 = new Parse.Object('Company');\n            company2.set('name', 'imACompany2');\n            await company2.save();\n\n            const country = new Parse.Object('Country');\n            country.set('name', 'imACountry');\n            country.relation('companies').add(company1);\n            await country.save();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const {\n              data: {\n                updateCountry: { country: result },\n              },\n            } = await apolloClient.mutate({\n              mutation: gql`\n                mutation UpdateCountry(\n                  $id: ID!\n                  $fields: UpdateCountryFieldsInput\n                ) {\n                  updateCountry(input: { id: $id, fields: $fields }) {\n                    country {\n                      id\n                      objectId\n                      companies {\n                        edges {\n                          node {\n                            id\n                            objectId\n                            name\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: country.id,\n                fields: {\n                  companies: {\n                    add: [company2.id],\n                    remove: [company1.id],\n                    createAndAdd: [\n                      {\n                        name: 'imACompany3',\n                      },\n                    ],\n                  },\n                },\n              },\n            });\n\n            expect(result.objectId).toEqual(country.id);\n            expect(result.companies.edges.length).toEqual(2);\n            expect(\n              result.companies.edges.some(\n                (o) => o.node.objectId === company2.id\n              )\n            ).toBeTruthy();\n            expect(\n              result.companies.edges.some((o) => o.node.name === 'imACompany3')\n            ).toBeTruthy();\n            expect(\n              result.companies.edges.some(\n                (o) => o.node.objectId === company1.id\n              )\n            ).toBeFalsy();\n          }\n        );\n\n        it_only_db('mongo')(\n          'should support nested relation on create with filter',\n          async () => {\n            const company = new Parse.Object('Company');\n            company.set('name', 'imACompany1');\n            await company.save();\n\n            const country = new Parse.Object('Country');\n            country.set('name', 'imACountry');\n            country.relation('companies').add(company);\n            await country.save();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const {\n              data: {\n                createCountry: { country: result },\n              },\n            } = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateCountry(\n                  $fields: CreateCountryFieldsInput\n                  $where: CompanyWhereInput\n                ) {\n                  createCountry(input: { fields: $fields }) {\n                    country {\n                      id\n                      name\n                      companies(where: $where) {\n                        edges {\n                          node {\n                            id\n                            name\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where: {\n                  name: {\n                    equalTo: 'imACompany2',\n                  },\n                },\n                fields: {\n                  name: 'imACountry2',\n                  companies: {\n                    add: [company.id],\n                    createAndAdd: [\n                      {\n                        name: 'imACompany2',\n                      },\n                      {\n                        name: 'imACompany3',\n                      },\n                    ],\n                  },\n                },\n              },\n            });\n\n            expect(result.id).toBeDefined();\n            expect(result.name).toEqual('imACountry2');\n            expect(result.companies.edges.length).toEqual(1);\n            expect(\n              result.companies.edges.some((o) => o.node.name === 'imACompany2')\n            ).toBeTruthy();\n          }\n        );\n\n        it_only_db('mongo')('should support relation on query', async () => {\n          const company1 = new Parse.Object('Company');\n          company1.set('name', 'imACompany1');\n          await company1.save();\n\n          const company2 = new Parse.Object('Company');\n          company2.set('name', 'imACompany2');\n          await company2.save();\n\n          const country = new Parse.Object('Country');\n          country.set('name', 'imACountry');\n          country.relation('companies').add([company1, company2]);\n          await country.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          // Without where\n          const {\n            data: { country: result1 },\n          } = await apolloClient.query({\n            query: gql`\n              query getCountry($id: ID!) {\n                country(id: $id) {\n                  id\n                  objectId\n                  companies {\n                    edges {\n                      node {\n                        id\n                        objectId\n                        name\n                      }\n                    }\n                    count\n                  }\n                }\n              }\n            `,\n            variables: {\n              id: country.id,\n            },\n          });\n\n          expect(result1.objectId).toEqual(country.id);\n          expect(result1.companies.edges.length).toEqual(2);\n          expect(\n            result1.companies.edges.some((o) => o.node.objectId === company1.id)\n          ).toBeTruthy();\n          expect(\n            result1.companies.edges.some((o) => o.node.objectId === company2.id)\n          ).toBeTruthy();\n\n          // With where\n          const {\n            data: { country: result2 },\n          } = await apolloClient.query({\n            query: gql`\n              query getCountry($id: ID!, $where: CompanyWhereInput) {\n                country(id: $id) {\n                  id\n                  objectId\n                  companies(where: $where) {\n                    edges {\n                      node {\n                        id\n                        objectId\n                        name\n                      }\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              id: country.id,\n              where: {\n                name: { equalTo: 'imACompany1' },\n              },\n            },\n          });\n          expect(result2.objectId).toEqual(country.id);\n          expect(result2.companies.edges.length).toEqual(1);\n          expect(result2.companies.edges[0].node.objectId).toEqual(company1.id);\n        });\n\n        it_only_db('mongo')(\n          'should support relational where query',\n          async () => {\n            const president = new Parse.Object('President');\n            president.set('name', 'James');\n            await president.save();\n\n            const employee = new Parse.Object('Employee');\n            employee.set('name', 'John');\n            await employee.save();\n\n            const company1 = new Parse.Object('Company');\n            company1.set('name', 'imACompany1');\n            await company1.save();\n\n            const company2 = new Parse.Object('Company');\n            company2.set('name', 'imACompany2');\n            company2.relation('employees').add([employee]);\n            await company2.save();\n\n            const country = new Parse.Object('Country');\n            country.set('name', 'imACountry');\n            country.relation('companies').add([company1, company2]);\n            await country.save();\n\n            const country2 = new Parse.Object('Country');\n            country2.set('name', 'imACountry2');\n            country2.relation('companies').add([company1]);\n            await country2.save();\n\n            const country3 = new Parse.Object('Country');\n            country3.set('name', 'imACountry3');\n            country3.set('president', president);\n            await country3.save();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            let {\n              data: {\n                countries: { edges: result },\n              },\n            } = await apolloClient.query({\n              query: gql`\n                query findCountry($where: CountryWhereInput) {\n                  countries(where: $where) {\n                    edges {\n                      node {\n                        id\n                        objectId\n                        companies {\n                          edges {\n                            node {\n                              id\n                              objectId\n                              name\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where: {\n                  companies: {\n                    have: {\n                      employees: { have: { name: { equalTo: 'John' } } },\n                    },\n                  },\n                },\n              },\n            });\n            expect(result.length).toEqual(1);\n            result = result[0].node;\n            expect(result.objectId).toEqual(country.id);\n            expect(result.companies.edges.length).toEqual(2);\n\n            const {\n              data: {\n                countries: { edges: result2 },\n              },\n            } = await apolloClient.query({\n              query: gql`\n                query findCountry($where: CountryWhereInput) {\n                  countries(where: $where) {\n                    edges {\n                      node {\n                        id\n                        objectId\n                        companies {\n                          edges {\n                            node {\n                              id\n                              objectId\n                              name\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where: {\n                  companies: {\n                    have: {\n                      OR: [\n                        { name: { equalTo: 'imACompany1' } },\n                        { name: { equalTo: 'imACompany2' } },\n                      ],\n                    },\n                  },\n                },\n              },\n            });\n            expect(result2.length).toEqual(2);\n\n            const {\n              data: {\n                countries: { edges: result3 },\n              },\n            } = await apolloClient.query({\n              query: gql`\n                query findCountry($where: CountryWhereInput) {\n                  countries(where: $where) {\n                    edges {\n                      node {\n                        id\n                        name\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where: {\n                  companies: { exists: false },\n                },\n              },\n            });\n            expect(result3.length).toEqual(1);\n            expect(result3[0].node.name).toEqual('imACountry3');\n\n            const {\n              data: {\n                countries: { edges: result4 },\n              },\n            } = await apolloClient.query({\n              query: gql`\n                query findCountry($where: CountryWhereInput) {\n                  countries(where: $where) {\n                    edges {\n                      node {\n                        id\n                        name\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where: {\n                  president: { exists: false },\n                },\n              },\n            });\n            expect(result4.length).toEqual(2);\n            const {\n              data: {\n                countries: { edges: result5 },\n              },\n            } = await apolloClient.query({\n              query: gql`\n                query findCountry($where: CountryWhereInput) {\n                  countries(where: $where) {\n                    edges {\n                      node {\n                        id\n                        name\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where: {\n                  president: { exists: true },\n                },\n              },\n            });\n            expect(result5.length).toEqual(1);\n            const {\n              data: {\n                countries: { edges: result6 },\n              },\n            } = await apolloClient.query({\n              query: gql`\n                query findCountry($where: CountryWhereInput) {\n                  countries(where: $where) {\n                    edges {\n                      node {\n                        id\n                        objectId\n                        name\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where: {\n                  companies: {\n                    haveNot: {\n                      OR: [\n                        { name: { equalTo: 'imACompany1' } },\n                        { name: { equalTo: 'imACompany2' } },\n                      ],\n                    },\n                  },\n                },\n              },\n            });\n            expect(result6.length).toEqual(1);\n            expect(result6.length).toEqual(1);\n            expect(result6[0].node.name).toEqual('imACountry3');\n          }\n        );\n\n        it('should support files', async () => {\n          try {\n            parseServer = await global.reconfigureServer({\n              publicServerURL: 'http://localhost:13377/parse',\n            });\n\n            const body = new FormData();\n            body.append(\n              'operations',\n              JSON.stringify({\n                query: `\n                  mutation CreateFile($input: CreateFileInput!) {\n                    createFile(input: $input) {\n                      fileInfo {\n                        name\n                        url\n                      }\n                    }\n                  }\n                `,\n                variables: {\n                  input: {\n                    upload: null,\n                  },\n                },\n              })\n            );\n            body.append(\n              'map',\n              JSON.stringify({ 1: ['variables.input.upload'] })\n            );\n            body.append('1', 'My File Content', {\n              filename: 'myFileName.txt',\n              contentType: 'text/plain',\n            });\n\n            let res = await fetch('http://localhost:13377/graphql', {\n              method: 'POST',\n              headers,\n              body,\n            });\n\n            expect(res.status).toEqual(200);\n\n            const result = JSON.parse(await res.text());\n\n            expect(result.data.createFile.fileInfo.name).toEqual(\n              jasmine.stringMatching(/_myFileName.txt$/)\n            );\n            expect(result.data.createFile.fileInfo.url).toEqual(\n              jasmine.stringMatching(/_myFileName.txt$/)\n            );\n\n            const someFieldValue = result.data.createFile.fileInfo.name;\n            const someFieldObjectValue = result.data.createFile.fileInfo;\n\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(\n                    input: { name: \"SomeClass\", schemaFields: $schemaFields }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addFiles: [{ name: 'someField' }],\n                },\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const body2 = new FormData();\n            body2.append(\n              'operations',\n              JSON.stringify({\n                query: `\n                mutation CreateSomeObject(\n                  $fields1: CreateSomeClassFieldsInput\n                  $fields2: CreateSomeClassFieldsInput\n                  $fields3: CreateSomeClassFieldsInput\n                ) {\n                  createSomeClass1: createSomeClass(\n                    input: { fields: $fields1 }\n                  ) {\n                    someClass {\n                      id\n                      someField {\n                        name\n                        url\n                      }\n                    }\n                  }\n                  createSomeClass2: createSomeClass(\n                    input: { fields: $fields2 }\n                  ) {\n                    someClass {\n                      id\n                      someField {\n                        name\n                        url\n                      }\n                    }\n                  }\n                  createSomeClass3: createSomeClass(\n                    input: { fields: $fields3 }\n                  ) {\n                    someClass {\n                      id\n                      someField {\n                        name\n                        url\n                      }\n                    }\n                  }\n                }\n                `,\n                variables: {\n                  fields1: {\n                    someField: { file: someFieldValue },\n                  },\n                  fields2: {\n                    someField: {\n                      file: {\n                        name: someFieldObjectValue.name,\n                        url: someFieldObjectValue.url,\n                        __type: 'File',\n                      },\n                    },\n                  },\n                  fields3: {\n                    someField: { upload: null },\n                  },\n                },\n              })\n            );\n            body2.append(\n              'map',\n              JSON.stringify({ 1: ['variables.fields3.someField.upload'] })\n            );\n            body2.append('1', 'My File Content', {\n              filename: 'myFileName.txt',\n              contentType: 'text/plain',\n            });\n\n            res = await fetch('http://localhost:13377/graphql', {\n              method: 'POST',\n              headers,\n              body: body2,\n            });\n            expect(res.status).toEqual(200);\n            const result2 = JSON.parse(await res.text());\n            expect(\n              result2.data.createSomeClass1.someClass.someField.name\n            ).toEqual(jasmine.stringMatching(/_myFileName.txt$/));\n            expect(\n              result2.data.createSomeClass1.someClass.someField.url\n            ).toEqual(jasmine.stringMatching(/_myFileName.txt$/));\n            expect(\n              result2.data.createSomeClass2.someClass.someField.name\n            ).toEqual(jasmine.stringMatching(/_myFileName.txt$/));\n            expect(\n              result2.data.createSomeClass2.someClass.someField.url\n            ).toEqual(jasmine.stringMatching(/_myFileName.txt$/));\n            expect(\n              result2.data.createSomeClass3.someClass.someField.name\n            ).toEqual(jasmine.stringMatching(/_myFileName.txt$/));\n            expect(\n              result2.data.createSomeClass3.someClass.someField.url\n            ).toEqual(jasmine.stringMatching(/_myFileName.txt$/));\n\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.someField.type).toEqual('File');\n\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!) {\n                  someClass(id: $id) {\n                    someField {\n                      name\n                      url\n                    }\n                  }\n                  findSomeClass1: someClasses(\n                    where: { someField: { exists: true } }\n                  ) {\n                    edges {\n                      node {\n                        someField {\n                          name\n                          url\n                        }\n                      }\n                    }\n                  }\n                  findSomeClass2: someClasses(\n                    where: { someField: { exists: true } }\n                  ) {\n                    edges {\n                      node {\n                        someField {\n                          name\n                          url\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: result2.data.createSomeClass1.someClass.id,\n              },\n            });\n\n            expect(typeof getResult.data.someClass.someField).toEqual('object');\n            expect(getResult.data.someClass.someField.name).toEqual(\n              result.data.createFile.fileInfo.name\n            );\n            expect(getResult.data.someClass.someField.url).toEqual(\n              result.data.createFile.fileInfo.url\n            );\n            expect(getResult.data.findSomeClass1.edges.length).toEqual(3);\n            expect(getResult.data.findSomeClass2.edges.length).toEqual(3);\n\n            res = await fetch(getResult.data.someClass.someField.url);\n\n            expect(res.status).toEqual(200);\n            expect(await res.text()).toEqual('My File Content');\n\n            const mutationResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation UnlinkFile($id: ID!) {\n                  updateSomeClass(\n                    input: { id: $id, fields: { someField: { file: null } } }\n                  ) {\n                    someClass {\n                      someField {\n                        name\n                        url\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: result2.data.createSomeClass3.someClass.id,\n              },\n            });\n            expect(\n              mutationResult.data.updateSomeClass.someClass.someField\n            ).toEqual(null);\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should support object values', async () => {\n          try {\n            const someFieldValue = {\n              foo: { bar: 'baz' },\n              number: 10,\n            };\n\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(\n                    input: { name: \"SomeClass\", schemaFields: $schemaFields }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addObjects: [{ name: 'someField' }],\n                },\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.someField.type).toEqual('Object');\n\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                  createSomeClass(input: { fields: $fields }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  someField: someFieldValue,\n                },\n              },\n            });\n\n            const where = {\n              someField: {\n                equalTo: { key: 'foo.bar', value: 'baz' },\n                notEqualTo: { key: 'foo.bar', value: 'bat' },\n                greaterThan: { key: 'number', value: 9 },\n                lessThan: { key: 'number', value: 11 },\n              },\n            };\n            const queryResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!, $where: SomeClassWhereInput) {\n                  someClass(id: $id) {\n                    id\n                    someField\n                  }\n                  someClasses(where: $where) {\n                    edges {\n                      node {\n                        id\n                        someField\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id,\n                where,\n              },\n            });\n\n            const { someClass: getResult, someClasses } = queryResult.data;\n\n            const { someField } = getResult;\n            expect(typeof someField).toEqual('object');\n            expect(someField).toEqual(someFieldValue);\n\n            // Checks class query results\n            expect(someClasses.edges.length).toEqual(1);\n            expect(someClasses.edges[0].node.someField).toEqual(someFieldValue);\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should support object composed queries', async () => {\n          try {\n            const someFieldValue = {\n              lorem: 'ipsum',\n              number: 10,\n            };\n            const someFieldValue2 = {\n              foo: {\n                test: 'bar',\n              },\n              number: 10,\n            };\n\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass {\n                  createClass(\n                    input: {\n                      name: \"SomeClass\"\n                      schemaFields: { addObjects: [{ name: \"someField\" }] }\n                    }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject(\n                  $fields1: CreateSomeClassFieldsInput\n                  $fields2: CreateSomeClassFieldsInput\n                ) {\n                  create1: createSomeClass(input: { fields: $fields1 }) {\n                    someClass {\n                      id\n                    }\n                  }\n                  create2: createSomeClass(input: { fields: $fields2 }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields1: {\n                  someField: someFieldValue,\n                },\n                fields2: {\n                  someField: someFieldValue2,\n                },\n              },\n            });\n\n            const where = {\n              AND: [\n                {\n                  someField: {\n                    greaterThan: { key: 'number', value: 9 },\n                  },\n                },\n                {\n                  someField: {\n                    lessThan: { key: 'number', value: 11 },\n                  },\n                },\n                {\n                  OR: [\n                    {\n                      someField: {\n                        equalTo: { key: 'lorem', value: 'ipsum' },\n                      },\n                    },\n                    {\n                      someField: {\n                        equalTo: { key: 'foo.test', value: 'bar' },\n                      },\n                    },\n                  ],\n                },\n              ],\n            };\n            const findResult = await apolloClient.query({\n              query: gql`\n                query FindSomeObject($where: SomeClassWhereInput) {\n                  someClasses(where: $where) {\n                    edges {\n                      node {\n                        id\n                        someField\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where,\n              },\n            });\n\n            const { create1, create2 } = createResult.data;\n            const { someClasses } = findResult.data;\n\n            // Checks class query results\n            const { edges } = someClasses;\n            expect(edges.length).toEqual(2);\n            expect(\n              edges.find((result) => result.node.id === create1.someClass.id)\n                .node.someField\n            ).toEqual(someFieldValue);\n            expect(\n              edges.find((result) => result.node.id === create2.someClass.id)\n                .node.someField\n            ).toEqual(someFieldValue2);\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should support array values', async () => {\n          try {\n            const someFieldValue = [\n              1,\n              'foo',\n              ['bar'],\n              { lorem: 'ipsum' },\n              true,\n            ];\n\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(\n                    input: { name: \"SomeClass\", schemaFields: $schemaFields }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addArrays: [{ name: 'someField' }],\n                },\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.someField.type).toEqual('Array');\n\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                  createSomeClass(input: { fields: $fields }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  someField: someFieldValue,\n                },\n              },\n            });\n\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!) {\n                  someClass(id: $id) {\n                    someField {\n                      ... on Element {\n                        value\n                      }\n                    }\n                  }\n                  someClasses(where: { someField: { exists: true } }) {\n                    edges {\n                      node {\n                        id\n                        someField {\n                          ... on Element {\n                            value\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id,\n              },\n            });\n\n            const { someField } = getResult.data.someClass;\n            expect(Array.isArray(someField)).toBeTruthy();\n            expect(someField.map((element) => element.value)).toEqual(\n              someFieldValue\n            );\n            expect(getResult.data.someClasses.edges.length).toEqual(1);\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should support undefined array', async () => {\n          const schema = await new Parse.Schema('SomeClass');\n          schema.addArray('someArray');\n          await schema.save();\n\n          const obj = new Parse.Object('SomeClass');\n          await obj.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const getResult = await apolloClient.query({\n            query: gql`\n              query GetSomeObject($id: ID!) {\n                someClass(id: $id) {\n                  id\n                  someArray {\n                    ... on Element {\n                      value\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              id: obj.id,\n            },\n          });\n          expect(getResult.data.someClass.someArray).toEqual(null);\n        });\n\n        it('should support null values', async () => {\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass {\n                  createClass(\n                    input: {\n                      name: \"SomeClass\"\n                      schemaFields: {\n                        addStrings: [\n                          { name: \"someStringField\" }\n                          { name: \"someNullField\" }\n                        ]\n                        addNumbers: [{ name: \"someNumberField\" }]\n                        addBooleans: [{ name: \"someBooleanField\" }]\n                        addObjects: [{ name: \"someObjectField\" }]\n                      }\n                    }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                  createSomeClass(input: { fields: $fields }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  someStringField: 'some string',\n                  someNumberField: 123,\n                  someBooleanField: true,\n                  someObjectField: { someField: 'some value' },\n                  someNullField: null,\n                },\n              },\n            });\n\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation UpdateSomeObject(\n                  $id: ID!\n                  $fields: UpdateSomeClassFieldsInput\n                ) {\n                  updateSomeClass(input: { id: $id, fields: $fields }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id,\n                fields: {\n                  someStringField: null,\n                  someNumberField: null,\n                  someBooleanField: null,\n                  someObjectField: null,\n                  someNullField: 'now it has a string',\n                },\n              },\n            });\n\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!) {\n                  someClass(id: $id) {\n                    someStringField\n                    someNumberField\n                    someBooleanField\n                    someObjectField\n                    someNullField\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id,\n              },\n            });\n\n            expect(getResult.data.someClass.someStringField).toBeFalsy();\n            expect(getResult.data.someClass.someNumberField).toBeFalsy();\n            expect(getResult.data.someClass.someBooleanField).toBeFalsy();\n            expect(getResult.data.someClass.someObjectField).toBeFalsy();\n            expect(getResult.data.someClass.someNullField).toEqual(\n              'now it has a string'\n            );\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should support Bytes', async () => {\n          try {\n            const someFieldValue = 'aGVsbG8gd29ybGQ=';\n\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(\n                    input: { name: \"SomeClass\", schemaFields: $schemaFields }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addBytes: [{ name: 'someField' }],\n                },\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.someField.type).toEqual('Bytes');\n\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject(\n                  $fields1: CreateSomeClassFieldsInput\n                  $fields2: CreateSomeClassFieldsInput\n                ) {\n                  createSomeClass1: createSomeClass(\n                    input: { fields: $fields1 }\n                  ) {\n                    someClass {\n                      id\n                    }\n                  }\n                  createSomeClass2: createSomeClass(\n                    input: { fields: $fields2 }\n                  ) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields1: {\n                  someField: someFieldValue,\n                },\n                fields2: {\n                  someField: someFieldValue,\n                },\n              },\n            });\n\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!, $someFieldValue: Bytes) {\n                  someClass(id: $id) {\n                    someField\n                  }\n                  someClasses(\n                    where: { someField: { equalTo: $someFieldValue } }\n                  ) {\n                    edges {\n                      node {\n                        id\n                        someField\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass1.someClass.id,\n                someFieldValue,\n              },\n            });\n\n            expect(typeof getResult.data.someClass.someField).toEqual('string');\n            expect(getResult.data.someClass.someField).toEqual(someFieldValue);\n            expect(getResult.data.someClasses.edges.length).toEqual(2);\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should support Geo Points', async () => {\n          try {\n            const someFieldValue = {\n              __typename: 'GeoPoint',\n              latitude: 45,\n              longitude: 45,\n            };\n\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(\n                    input: { name: \"SomeClass\", schemaFields: $schemaFields }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addGeoPoint: { name: 'someField' },\n                },\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.someField.type).toEqual('GeoPoint');\n\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                  createSomeClass(input: { fields: $fields }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  someField: {\n                    latitude: someFieldValue.latitude,\n                    longitude: someFieldValue.longitude,\n                  },\n                },\n              },\n            });\n\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!) {\n                  someClass(id: $id) {\n                    someField {\n                      latitude\n                      longitude\n                    }\n                  }\n                  someClasses(where: { someField: { exists: true } }) {\n                    edges {\n                      node {\n                        id\n                        someField {\n                          latitude\n                          longitude\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id,\n              },\n            });\n\n            expect(typeof getResult.data.someClass.someField).toEqual('object');\n            expect(getResult.data.someClass.someField).toEqual(someFieldValue);\n            expect(getResult.data.someClasses.edges.length).toEqual(1);\n\n            const getGeoWhere = await apolloClient.query({\n              query: gql`\n                query GeoQuery($latitude: Float!, $longitude: Float!) {\n                  nearSphere: someClasses(\n                    where: {\n                      someField: {\n                        nearSphere: {\n                          latitude: $latitude\n                          longitude: $longitude\n                        }\n                      }\n                    }\n                  ) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                  geoWithin: someClasses(\n                    where: {\n                      someField: {\n                        geoWithin: {\n                          centerSphere: {\n                            distance: 10\n                            center: {\n                              latitude: $latitude\n                              longitude: $longitude\n                            }\n                          }\n                        }\n                      }\n                    }\n                  ) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                  within: someClasses(\n                    where: {\n                      someField: {\n                        within: {\n                          box: {\n                            bottomLeft: {\n                              latitude: $latitude\n                              longitude: $longitude\n                            }\n                            upperRight: {\n                              latitude: $latitude\n                              longitude: $longitude\n                            }\n                          }\n                        }\n                      }\n                    }\n                  ) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                latitude: 45,\n                longitude: 45,\n              },\n            });\n            expect(getGeoWhere.data.nearSphere.edges[0].node.id).toEqual(\n              createResult.data.createSomeClass.someClass.id\n            );\n            expect(getGeoWhere.data.geoWithin.edges[0].node.id).toEqual(\n              createResult.data.createSomeClass.someClass.id\n            );\n            expect(getGeoWhere.data.within.edges[0].node.id).toEqual(\n              createResult.data.createSomeClass.someClass.id\n            );\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should support Polygons', async () => {\n          try {\n            const somePolygonFieldValue = [\n              [44, 45],\n              [46, 47],\n              [48, 49],\n              [44, 45],\n            ].map((point) => ({\n              latitude: point[0],\n              longitude: point[1],\n            }));\n\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(\n                    input: { name: \"SomeClass\", schemaFields: $schemaFields }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addPolygons: [{ name: 'somePolygonField' }],\n                },\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.somePolygonField.type).toEqual('Polygon');\n\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                  createSomeClass(input: { fields: $fields }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  somePolygonField: somePolygonFieldValue,\n                },\n              },\n            });\n\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!) {\n                  someClass(id: $id) {\n                    somePolygonField {\n                      latitude\n                      longitude\n                    }\n                  }\n                  someClasses(where: { somePolygonField: { exists: true } }) {\n                    edges {\n                      node {\n                        id\n                        somePolygonField {\n                          latitude\n                          longitude\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id,\n              },\n            });\n\n            expect(typeof getResult.data.someClass.somePolygonField).toEqual(\n              'object'\n            );\n            expect(getResult.data.someClass.somePolygonField).toEqual(\n              somePolygonFieldValue.map((geoPoint) => ({\n                ...geoPoint,\n                __typename: 'GeoPoint',\n              }))\n            );\n            expect(getResult.data.someClasses.edges.length).toEqual(1);\n            const getIntersect = await apolloClient.query({\n              query: gql`\n                query IntersectQuery($point: GeoPointInput!) {\n                  someClasses(\n                    where: {\n                      somePolygonField: { geoIntersects: { point: $point } }\n                    }\n                  ) {\n                    edges {\n                      node {\n                        id\n                        somePolygonField {\n                          latitude\n                          longitude\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                point: { latitude: 44, longitude: 45 },\n              },\n            });\n            expect(getIntersect.data.someClasses.edges.length).toEqual(1);\n            expect(getIntersect.data.someClasses.edges[0].node.id).toEqual(\n              createResult.data.createSomeClass.someClass.id\n            );\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it_only_db('mongo')('should support bytes values', async () => {\n          const SomeClass = Parse.Object.extend('SomeClass');\n          const someClass = new SomeClass();\n          someClass.set('someField', {\n            __type: 'Bytes',\n            base64: 'foo',\n          });\n          await someClass.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n          const schema = await new Parse.Schema('SomeClass').get();\n          expect(schema.fields.someField.type).toEqual('Bytes');\n\n          const someFieldValue = {\n            __type: 'Bytes',\n            base64: 'bytesContent',\n          };\n\n          const createResult = await apolloClient.mutate({\n            mutation: gql`\n              mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                createSomeClass(input: { fields: $fields }) {\n                  someClass {\n                    id\n                  }\n                }\n              }\n            `,\n            variables: {\n              fields: {\n                someField: someFieldValue,\n              },\n            },\n          });\n\n          const getResult = await apolloClient.query({\n            query: gql`\n              query GetSomeObject($id: ID!) {\n                someClass(id: $id) {\n                  someField\n                }\n              }\n            `,\n            variables: {\n              id: createResult.data.createSomeClass.someClass.id,\n            },\n          });\n\n          expect(getResult.data.someClass.someField).toEqual(\n            someFieldValue.base64\n          );\n\n          const updatedSomeFieldValue = {\n            __type: 'Bytes',\n            base64: 'newBytesContent',\n          };\n\n          const updatedResult = await apolloClient.mutate({\n            mutation: gql`\n              mutation UpdateSomeObject(\n                $id: ID!\n                $fields: UpdateSomeClassFieldsInput\n              ) {\n                updateSomeClass(input: { id: $id, fields: $fields }) {\n                  someClass {\n                    updatedAt\n                  }\n                }\n              }\n            `,\n            variables: {\n              id: createResult.data.createSomeClass.someClass.id,\n              fields: {\n                someField: updatedSomeFieldValue,\n              },\n            },\n          });\n\n          const { updatedAt } = updatedResult.data.updateSomeClass.someClass;\n          expect(updatedAt).toBeDefined();\n\n          const findResult = await apolloClient.query({\n            query: gql`\n              query FindSomeObject($where: SomeClassWhereInput!) {\n                someClasses(where: $where) {\n                  edges {\n                    node {\n                      id\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              where: {\n                someField: {\n                  equalTo: updatedSomeFieldValue.base64,\n                },\n              },\n            },\n          });\n          const findResults = findResult.data.someClasses.edges;\n          expect(findResults.length).toBe(1);\n          expect(findResults[0].node.id).toBe(\n            createResult.data.createSomeClass.someClass.id\n          );\n        });\n      });\n\n      describe('Special Classes', () => {\n        it('should support User class', async () => {\n          const user = new Parse.User();\n          user.setUsername('user1');\n          user.setPassword('user1');\n          await user.signUp();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const getResult = await apolloClient.query({\n            query: gql`\n              query GetSomeObject($id: ID!) {\n                get: user(id: $id) {\n                  objectId\n                }\n              }\n            `,\n            variables: {\n              id: user.id,\n            },\n          });\n\n          expect(getResult.data.get.objectId).toEqual(user.id);\n        });\n\n        it('should support Installation class', async () => {\n          const installation = new Parse.Installation();\n          await installation.save({\n            deviceType: 'foo',\n          });\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const getResult = await apolloClient.query({\n            query: gql`\n              query GetSomeObject($id: ID!) {\n                get: installation(id: $id) {\n                  objectId\n                }\n              }\n            `,\n            variables: {\n              id: installation.id,\n            },\n          });\n\n          expect(getResult.data.get.objectId).toEqual(installation.id);\n        });\n\n        it('should support Role class', async () => {\n          const roleACL = new Parse.ACL();\n          roleACL.setPublicReadAccess(true);\n          const role = new Parse.Role('MyRole', roleACL);\n          await role.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const getResult = await apolloClient.query({\n            query: gql`\n              query GetSomeObject($id: ID!) {\n                get: role(id: $id) {\n                  objectId\n                }\n              }\n            `,\n            variables: {\n              id: role.id,\n            },\n          });\n\n          expect(getResult.data.get.objectId).toEqual(role.id);\n        });\n\n        it('should support Session class', async () => {\n          const user = new Parse.User();\n          user.setUsername('user1');\n          user.setPassword('user1');\n          await user.signUp();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const session = await Parse.Session.current();\n          const getResult = await apolloClient.query({\n            query: gql`\n              query GetSomeObject($id: ID!) {\n                get: session(id: $id) {\n                  id\n                  objectId\n                }\n              }\n            `,\n            variables: {\n              id: session.id,\n            },\n            context: {\n              headers: {\n                'X-Parse-Session-Token': session.getSessionToken(),\n              },\n            },\n          });\n\n          expect(getResult.data.get.objectId).toEqual(session.id);\n        });\n\n        it('should support Product class', async () => {\n          const Product = Parse.Object.extend('_Product');\n          const product = new Product();\n          await product.save(\n            {\n              productIdentifier: 'foo',\n              icon: new Parse.File('icon', ['foo']),\n              order: 1,\n              title: 'Foo',\n              subtitle: 'My product',\n            },\n            { useMasterKey: true }\n          );\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const getResult = await apolloClient.query({\n            query: gql`\n              query GetSomeObject($id: ID!) {\n                get: product(id: $id) {\n                  objectId\n                }\n              }\n            `,\n            variables: {\n              id: product.id,\n            },\n            context: {\n              headers: {\n                'X-Parse-Master-Key': 'test',\n              },\n            },\n          });\n\n          expect(getResult.data.get.objectId).toEqual(product.id);\n        });\n      });\n    });\n  });\n\n  describe('Custom API', () => {\n    describe('GraphQL Schema Based', () => {\n      let httpServer;\n      const headers = {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-Javascript-Key': 'test',\n      };\n      let apolloClient;\n      beforeAll(async () => {\n        const expressApp = express();\n        httpServer = http.createServer(expressApp);\n        parseGraphQLServer = new ParseGraphQLServer(parseServer, {\n          graphQLPath: '/graphql',\n          graphQLCustomTypeDefs: gql`\n            extend type Query {\n              hello: String @resolve\n              hello2: String @resolve(to: \"hello\")\n              userEcho(user: CreateUserFieldsInput!): User! @resolve\n              hello3: String! @mock(with: \"Hello world!\")\n              hello4: User! @mock(with: { username: \"somefolk\" })\n            }\n          `,\n        });\n        parseGraphQLServer.applyGraphQL(expressApp);\n        await new Promise((resolve) =>\n          httpServer.listen({ port: 13377 }, resolve)\n        );\n        const httpLink = createUploadLink({\n          uri: 'http://localhost:13377/graphql',\n          fetch,\n          headers,\n        });\n        apolloClient = new ApolloClient({\n          link: httpLink,\n          cache: new InMemoryCache(),\n          defaultOptions: {\n            query: {\n              fetchPolicy: 'no-cache',\n            },\n          },\n        });\n      });\n\n      afterAll(async () => {\n        await httpServer.close();\n      });\n\n      it('can resolve a custom query using default function name', async () => {\n        Parse.Cloud.define('hello', async () => {\n          return 'Hello world!';\n        });\n\n        const result = await apolloClient.query({\n          query: gql`\n            query Hello {\n              hello\n            }\n          `,\n        });\n\n        expect(result.data.hello).toEqual('Hello world!');\n      });\n\n      it('can resolve a custom query using function name set by \"to\" argument', async () => {\n        Parse.Cloud.define('hello', async () => {\n          return 'Hello world!';\n        });\n\n        const result = await apolloClient.query({\n          query: gql`\n            query Hello {\n              hello2\n            }\n          `,\n        });\n\n        expect(result.data.hello2).toEqual('Hello world!');\n      });\n\n      it('order option should continue working', async () => {\n        const schemaController = await parseServer.config.databaseController.loadSchema();\n\n        await schemaController.addClassIfNotExists('SuperCar', {\n          engine: { type: 'String' },\n          doors: { type: 'Number' },\n          price: { type: 'String' },\n          mileage: { type: 'Number' },\n        });\n\n        await new Parse.Object('SuperCar').save({\n          engine: 'petrol',\n          doors: 3,\n          price: '\u00a37500',\n          mileage: 0,\n        });\n\n        await new Parse.Object('SuperCar').save({\n          engine: 'petrol',\n          doors: 3,\n          price: '\u00a37500',\n          mileage: 10000,\n        });\n\n        await Promise.all([\n          parseGraphQLServer.parseGraphQLController.cacheController.graphQL.clear(),\n          parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear(),\n        ]);\n\n        await expectAsync(\n          apolloClient.query({\n            query: gql`\n              query FindSuperCar {\n                superCars(order: [mileage_ASC]) {\n                  edges {\n                    node {\n                      id\n                    }\n                  }\n                }\n              }\n            `,\n          })\n        ).toBeResolved();\n      });\n    });\n\n    describe('SDL Based', () => {\n      let httpServer;\n      const headers = {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-Javascript-Key': 'test',\n      };\n      let apolloClient;\n\n      beforeAll(async () => {\n        const expressApp = express();\n        httpServer = http.createServer(expressApp);\n        const TypeEnum = new GraphQLEnumType({\n          name: 'TypeEnum',\n          values: {\n            human: { value: 'human' },\n            robot: { value: 'robot' },\n          },\n        });\n        const SomeClassType = new GraphQLObjectType({\n            name: 'SomeClass',\n            fields: {\n              nameUpperCase: {\n                type: new GraphQLNonNull(GraphQLString),\n                resolve: (p) => p.name.toUpperCase(),\n              },\n              type: { type: TypeEnum },\n              language: {\n                type: new GraphQLEnumType({\n                  name: 'LanguageEnum',\n                  values: {\n                    fr: { value: 'fr' },\n                    en: { value: 'en' },\n                  },\n                }),\n                resolve: () => 'fr',\n              },\n            },\n          }),\n          parseGraphQLServer = new ParseGraphQLServer(parseServer, {\n            graphQLPath: '/graphql',\n            graphQLCustomTypeDefs: new GraphQLSchema({\n              query: new GraphQLObjectType({\n                name: 'Query',\n                fields: {\n                  customQuery: {\n                    type: new GraphQLNonNull(GraphQLString),\n                    args: {\n                      message: { type: new GraphQLNonNull(GraphQLString) },\n                    },\n                    resolve: (p, { message }) => message,\n                  },\n                  customQueryWithAutoTypeReturn: {\n                    type: SomeClassType,\n                    args: {\n                      id: { type: new GraphQLNonNull(GraphQLString) },\n                    },\n                    resolve: async (p, { id }) => {\n                      const obj = new Parse.Object('SomeClass');\n                      obj.id = id;\n                      await obj.fetch();\n                      return obj.toJSON();\n                    },\n                  },\n                },\n              }),\n              types: [\n                new GraphQLInputObjectType({\n                  name: 'CreateSomeClassFieldsInput',\n                  fields: {\n                    type: { type: TypeEnum },\n                  },\n                }),\n                new GraphQLInputObjectType({\n                  name: 'UpdateSomeClassFieldsInput',\n                  fields: {\n                    type: { type: TypeEnum },\n                  },\n                }),\n                SomeClassType,\n              ],\n            }),\n          });\n\n        parseGraphQLServer.applyGraphQL(expressApp);\n        await new Promise((resolve) =>\n          httpServer.listen({ port: 13377 }, resolve)\n        );\n        const httpLink = createUploadLink({\n          uri: 'http://localhost:13377/graphql',\n          fetch,\n          headers,\n        });\n        apolloClient = new ApolloClient({\n          link: httpLink,\n          cache: new InMemoryCache(),\n          defaultOptions: {\n            query: {\n              fetchPolicy: 'no-cache',\n            },\n          },\n        });\n      });\n\n      afterAll(async () => {\n        await httpServer.close();\n      });\n\n      it('can resolve a custom query', async () => {\n        const result = await apolloClient.query({\n          variables: { message: 'hello' },\n          query: gql`\n            query CustomQuery($message: String!) {\n              customQuery(message: $message)\n            }\n          `,\n        });\n        expect(result.data.customQuery).toEqual('hello');\n      });\n\n      it('can resolve a custom query with auto type return', async () => {\n        const obj = new Parse.Object('SomeClass');\n        await obj.save({ name: 'aname', type: 'robot' });\n        await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n        const result = await apolloClient.query({\n          variables: { id: obj.id },\n          query: gql`\n            query CustomQuery($id: String!) {\n              customQueryWithAutoTypeReturn(id: $id) {\n                objectId\n                nameUpperCase\n                name\n                type\n              }\n            }\n          `,\n        });\n        expect(result.data.customQueryWithAutoTypeReturn.objectId).toEqual(\n          obj.id\n        );\n        expect(result.data.customQueryWithAutoTypeReturn.name).toEqual('aname');\n        expect(result.data.customQueryWithAutoTypeReturn.nameUpperCase).toEqual(\n          'ANAME'\n        );\n        expect(result.data.customQueryWithAutoTypeReturn.type).toEqual('robot');\n      });\n\n      it('can resolve a custom extend type', async () => {\n        const obj = new Parse.Object('SomeClass');\n        await obj.save({ name: 'aname', type: 'robot' });\n        await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n        const result = await apolloClient.query({\n          variables: { id: obj.id },\n          query: gql`\n            query someClass($id: ID!) {\n              someClass(id: $id) {\n                nameUpperCase\n                language\n                type\n              }\n            }\n          `,\n        });\n        expect(result.data.someClass.nameUpperCase).toEqual('ANAME');\n        expect(result.data.someClass.language).toEqual('fr');\n        expect(result.data.someClass.type).toEqual('robot');\n\n        const result2 = await apolloClient.query({\n          variables: { id: obj.id },\n          query: gql`\n            query someClass($id: ID!) {\n              someClass(id: $id) {\n                name\n                language\n              }\n            }\n          `,\n        });\n        expect(result2.data.someClass.name).toEqual('aname');\n        expect(result.data.someClass.language).toEqual('fr');\n        const result3 = await apolloClient.mutate({\n          variables: { id: obj.id, name: 'anewname', type: 'human' },\n          mutation: gql`\n            mutation someClass($id: ID!, $name: String!, $type: TypeEnum!) {\n              updateSomeClass(\n                input: { id: $id, fields: { name: $name, type: $type } }\n              ) {\n                someClass {\n                  nameUpperCase\n                  type\n                }\n              }\n            }\n          `,\n        });\n        expect(result3.data.updateSomeClass.someClass.nameUpperCase).toEqual(\n          'ANEWNAME'\n        );\n        expect(result3.data.updateSomeClass.someClass.type).toEqual('human');\n      });\n    });\n    describe('Async Function Based Merge', () => {\n      let httpServer;\n      const headers = {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-Javascript-Key': 'test',\n      };\n      let apolloClient;\n\n      beforeAll(async () => {\n        const expressApp = express();\n        httpServer = http.createServer(expressApp);\n        parseGraphQLServer = new ParseGraphQLServer(parseServer, {\n          graphQLPath: '/graphql',\n          graphQLCustomTypeDefs: ({ autoSchema, stitchSchemas }) =>\n            stitchSchemas({ subschemas: [autoSchema] }),\n        });\n\n        parseGraphQLServer.applyGraphQL(expressApp);\n        await new Promise((resolve) =>\n          httpServer.listen({ port: 13377 }, resolve)\n        );\n        const httpLink = createUploadLink({\n          uri: 'http://localhost:13377/graphql',\n          fetch,\n          headers,\n        });\n        apolloClient = new ApolloClient({\n          link: httpLink,\n          cache: new InMemoryCache(),\n          defaultOptions: {\n            query: {\n              fetchPolicy: 'no-cache',\n            },\n          },\n        });\n      });\n\n      afterAll(async () => {\n        await httpServer.close();\n      });\n\n      it('can resolve a query', async () => {\n        const result = await apolloClient.query({\n          query: gql`\n            query Health {\n              health\n            }\n          `,\n        });\n        expect(result.data.health).toEqual(true);\n      });\n    });\n  });\n});\n", "import {\n  GraphQLNonNull,\n  GraphQLString,\n  GraphQLBoolean,\n  GraphQLInputObjectType,\n} from 'graphql';\nimport { mutationWithClientMutationId } from 'graphql-relay';\nimport UsersRouter from '../../Routers/UsersRouter';\nimport * as objectsMutations from '../helpers/objectsMutations';\nimport { OBJECT } from './defaultGraphQLTypes';\nimport { getUserFromSessionToken } from './usersQueries';\n\nconst usersRouter = new UsersRouter();\n\nconst load = parseGraphQLSchema => {\n  if (parseGraphQLSchema.isUsersClassDisabled) {\n    return;\n  }\n\n  const signUpMutation = mutationWithClientMutationId({\n    name: 'SignUp',\n    description:\n      'The signUp mutation can be used to create and sign up a new user.',\n    inputFields: {\n      fields: {\n        descriptions:\n          'These are the fields of the new user to be created and signed up.',\n        type:\n          parseGraphQLSchema.parseClassTypes['_User'].classGraphQLCreateType,\n      },\n    },\n    outputFields: {\n      viewer: {\n        description:\n          'This is the new user that was created, signed up and returned as a viewer.',\n        type: new GraphQLNonNull(parseGraphQLSchema.viewerType),\n      },\n    },\n    mutateAndGetPayload: async (args, context, mutationInfo) => {\n      try {\n        const { fields } = args;\n        const { config, auth, info } = context;\n\n        const { sessionToken } = await objectsMutations.createObject(\n          '_User',\n          fields,\n          config,\n          auth,\n          info\n        );\n\n        info.sessionToken = sessionToken;\n\n        return {\n          viewer: await getUserFromSessionToken(\n            config,\n            info,\n            mutationInfo,\n            'viewer.user.',\n            true\n          ),\n        };\n      } catch (e) {\n        parseGraphQLSchema.handleError(e);\n      }\n    },\n  });\n\n  parseGraphQLSchema.addGraphQLType(\n    signUpMutation.args.input.type.ofType,\n    true,\n    true\n  );\n  parseGraphQLSchema.addGraphQLType(signUpMutation.type, true, true);\n  parseGraphQLSchema.addGraphQLMutation('signUp', signUpMutation, true, true);\n  const logInWithMutation = mutationWithClientMutationId({\n    name: 'LogInWith',\n    description:\n      'The logInWith mutation can be used to signup, login user with 3rd party authentication system. This mutation create a user if the authData do not correspond to an existing one.',\n    inputFields: {\n      authData: {\n        descriptions: 'This is the auth data of your custom auth provider',\n        type: new GraphQLNonNull(OBJECT),\n      },\n      fields: {\n        descriptions:\n          'These are the fields of the user to be created/updated and logged in.',\n        type: new GraphQLInputObjectType({\n          name: 'UserLoginWithInput',\n          fields: () => {\n            const classGraphQLCreateFields = parseGraphQLSchema.parseClassTypes[\n              '_User'\n            ].classGraphQLCreateType.getFields();\n            return Object.keys(classGraphQLCreateFields).reduce(\n              (fields, fieldName) => {\n                if (\n                  fieldName !== 'password' &&\n                  fieldName !== 'username' &&\n                  fieldName !== 'authData'\n                ) {\n                  fields[fieldName] = classGraphQLCreateFields[fieldName];\n                }\n                return fields;\n              },\n              {}\n            );\n          },\n        }),\n      },\n    },\n    outputFields: {\n      viewer: {\n        description:\n          'This is the new user that was created, signed up and returned as a viewer.',\n        type: new GraphQLNonNull(parseGraphQLSchema.viewerType),\n      },\n    },\n    mutateAndGetPayload: async (args, context, mutationInfo) => {\n      try {\n        const { fields, authData } = args;\n        const { config, auth, info } = context;\n\n        const { sessionToken } = await objectsMutations.createObject(\n          '_User',\n          { ...fields, authData },\n          config,\n          auth,\n          info\n        );\n\n        info.sessionToken = sessionToken;\n\n        return {\n          viewer: await getUserFromSessionToken(\n            config,\n            info,\n            mutationInfo,\n            'viewer.user.',\n            true\n          ),\n        };\n      } catch (e) {\n        parseGraphQLSchema.handleError(e);\n      }\n    },\n  });\n\n  parseGraphQLSchema.addGraphQLType(\n    logInWithMutation.args.input.type.ofType,\n    true,\n    true\n  );\n  parseGraphQLSchema.addGraphQLType(logInWithMutation.type, true, true);\n  parseGraphQLSchema.addGraphQLMutation(\n    'logInWith',\n    logInWithMutation,\n    true,\n    true\n  );\n\n  const logInMutation = mutationWithClientMutationId({\n    name: 'LogIn',\n    description: 'The logIn mutation can be used to log in an existing user.',\n    inputFields: {\n      username: {\n        description: 'This is the username used to log in the user.',\n        type: new GraphQLNonNull(GraphQLString),\n      },\n      password: {\n        description: 'This is the password used to log in the user.',\n        type: new GraphQLNonNull(GraphQLString),\n      },\n    },\n    outputFields: {\n      viewer: {\n        description:\n          'This is the existing user that was logged in and returned as a viewer.',\n        type: new GraphQLNonNull(parseGraphQLSchema.viewerType),\n      },\n    },\n    mutateAndGetPayload: async (args, context, mutationInfo) => {\n      try {\n        const { username, password } = args;\n        const { config, auth, info } = context;\n\n        const { sessionToken } = (\n          await usersRouter.handleLogIn({\n            body: {\n              username,\n              password,\n            },\n            query: {},\n            config,\n            auth,\n            info,\n          })\n        ).response;\n\n        info.sessionToken = sessionToken;\n\n        return {\n          viewer: await getUserFromSessionToken(\n            config,\n            info,\n            mutationInfo,\n            'viewer.user.',\n            true\n          ),\n        };\n      } catch (e) {\n        parseGraphQLSchema.handleError(e);\n      }\n    },\n  });\n\n  parseGraphQLSchema.addGraphQLType(\n    logInMutation.args.input.type.ofType,\n    true,\n    true\n  );\n  parseGraphQLSchema.addGraphQLType(logInMutation.type, true, true);\n  parseGraphQLSchema.addGraphQLMutation('logIn', logInMutation, true, true);\n\n  const logOutMutation = mutationWithClientMutationId({\n    name: 'LogOut',\n    description: 'The logOut mutation can be used to log out an existing user.',\n    outputFields: {\n      viewer: {\n        description:\n          'This is the existing user that was logged out and returned as a viewer.',\n        type: new GraphQLNonNull(parseGraphQLSchema.viewerType),\n      },\n    },\n    mutateAndGetPayload: async (_args, context, mutationInfo) => {\n      try {\n        const { config, auth, info } = context;\n\n        const viewer = await getUserFromSessionToken(\n          config,\n          info,\n          mutationInfo,\n          'viewer.user.',\n          true\n        );\n\n        await usersRouter.handleLogOut({\n          config,\n          auth,\n          info,\n        });\n\n        return { viewer };\n      } catch (e) {\n        parseGraphQLSchema.handleError(e);\n      }\n    },\n  });\n\n  parseGraphQLSchema.addGraphQLType(\n    logOutMutation.args.input.type.ofType,\n    true,\n    true\n  );\n  parseGraphQLSchema.addGraphQLType(logOutMutation.type, true, true);\n  parseGraphQLSchema.addGraphQLMutation('logOut', logOutMutation, true, true);\n\n  const resetPasswordMutation = mutationWithClientMutationId({\n    name: 'ResetPassword',\n    description:\n      'The resetPassword mutation can be used to reset the password of an existing user.',\n    inputFields: {\n      email: {\n        descriptions: 'Email of the user that should receive the reset email',\n        type: new GraphQLNonNull(GraphQLString),\n      },\n    },\n    outputFields: {\n      ok: {\n        description: \"It's always true.\",\n        type: new GraphQLNonNull(GraphQLBoolean),\n      },\n    },\n    mutateAndGetPayload: async ({ email }, context) => {\n      const { config, auth, info } = context;\n\n      await usersRouter.handleResetRequest({\n        body: {\n          email,\n        },\n        config,\n        auth,\n        info,\n      });\n\n      return { ok: true };\n    },\n  });\n\n  parseGraphQLSchema.addGraphQLType(\n    resetPasswordMutation.args.input.type.ofType,\n    true,\n    true\n  );\n  parseGraphQLSchema.addGraphQLType(resetPasswordMutation.type, true, true);\n  parseGraphQLSchema.addGraphQLMutation(\n    'resetPassword',\n    resetPasswordMutation,\n    true,\n    true\n  );\n\n  const sendVerificationEmailMutation = mutationWithClientMutationId({\n    name: 'SendVerificationEmail',\n    description:\n      'The sendVerificationEmail mutation can be used to send the verification email again.',\n    inputFields: {\n      email: {\n        descriptions:\n          'Email of the user that should receive the verification email',\n        type: new GraphQLNonNull(GraphQLString),\n      },\n    },\n    outputFields: {\n      ok: {\n        description: \"It's always true.\",\n        type: new GraphQLNonNull(GraphQLBoolean),\n      },\n    },\n    mutateAndGetPayload: async ({ email }, context) => {\n      try {\n        const { config, auth, info } = context;\n\n        await usersRouter.handleVerificationEmailRequest({\n          body: {\n            email,\n          },\n          config,\n          auth,\n          info,\n        });\n\n        return { ok: true };\n      } catch (e) {\n        parseGraphQLSchema.handleError(e);\n      }\n    },\n  });\n\n  parseGraphQLSchema.addGraphQLType(\n    sendVerificationEmailMutation.args.input.type.ofType,\n    true,\n    true\n  );\n  parseGraphQLSchema.addGraphQLType(\n    sendVerificationEmailMutation.type,\n    true,\n    true\n  );\n  parseGraphQLSchema.addGraphQLMutation(\n    'sendVerificationEmail',\n    sendVerificationEmailMutation,\n    true,\n    true\n  );\n};\n\nexport { load };\n", "import { GraphQLNonNull } from 'graphql';\nimport getFieldNames from 'graphql-list-fields';\nimport Parse from 'parse/node';\nimport rest from '../../rest';\nimport Auth from '../../Auth';\nimport { extractKeysAndInclude } from './parseClassTypes';\n\nconst getUserFromSessionToken = async (\n  config,\n  info,\n  queryInfo,\n  keysPrefix,\n  validatedToken\n) => {\n  if (!info || !info.sessionToken) {\n    throw new Parse.Error(\n      Parse.Error.INVALID_SESSION_TOKEN,\n      'Invalid session token'\n    );\n  }\n  const sessionToken = info.sessionToken;\n  const selectedFields = getFieldNames(queryInfo)\n    .filter(field => field.startsWith(keysPrefix))\n    .map(field => field.replace(keysPrefix, ''));\n\n  const keysAndInclude = extractKeysAndInclude(selectedFields);\n  const { keys } = keysAndInclude;\n  let { include } = keysAndInclude;\n\n  if (validatedToken && !keys && !include) {\n    return {\n      sessionToken,\n    };\n  } else if (keys && !include) {\n    include = 'user';\n  }\n\n  const options = {};\n  if (keys) {\n    options.keys = keys\n      .split(',')\n      .map(key => `user.${key}`)\n      .join(',');\n  }\n  if (include) {\n    options.include = include\n      .split(',')\n      .map(included => `user.${included}`)\n      .join(',');\n  }\n\n  const response = await rest.find(\n    config,\n    Auth.master(config),\n    '_Session',\n    { sessionToken },\n    options,\n    info.clientVersion,\n    info.context,\n  );\n  if (\n    !response.results ||\n    response.results.length == 0 ||\n    !response.results[0].user\n  ) {\n    throw new Parse.Error(\n      Parse.Error.INVALID_SESSION_TOKEN,\n      'Invalid session token'\n    );\n  } else {\n    const user = response.results[0].user;\n    return {\n      sessionToken,\n      user,\n    };\n  }\n};\n\nconst load = parseGraphQLSchema => {\n  if (parseGraphQLSchema.isUsersClassDisabled) {\n    return;\n  }\n\n  parseGraphQLSchema.addGraphQLQuery(\n    'viewer',\n    {\n      description:\n        'The viewer query can be used to return the current user data.',\n      type: new GraphQLNonNull(parseGraphQLSchema.viewerType),\n      async resolve(_source, _args, context, queryInfo) {\n        try {\n          const { config, info } = context;\n          return await getUserFromSessionToken(\n            config,\n            info,\n            queryInfo,\n            'user.',\n            false\n          );\n        } catch (e) {\n          parseGraphQLSchema.handleError(e);\n        }\n      },\n    },\n    true,\n    true\n  );\n};\n\nexport { load, getUserFromSessionToken };\n"], "fixing_code": ["const http = require('http');\nconst express = require('express');\nconst req = require('../lib/request');\nconst fetch = require('node-fetch');\nconst FormData = require('form-data');\nconst ws = require('ws');\nrequire('./helper');\nconst { updateCLP } = require('./dev');\n\nconst pluralize = require('pluralize');\nconst { getMainDefinition } = require('apollo-utilities');\nconst { ApolloLink, split } = require('apollo-link');\nconst { createHttpLink } = require('apollo-link-http');\nconst { InMemoryCache } = require('apollo-cache-inmemory');\nconst { createUploadLink } = require('apollo-upload-client');\nconst { SubscriptionClient } = require('subscriptions-transport-ws');\nconst { WebSocketLink } = require('apollo-link-ws');\nconst ApolloClient = require('apollo-client').default;\nconst gql = require('graphql-tag');\nconst { toGlobalId } = require('graphql-relay');\nconst {\n  GraphQLObjectType,\n  GraphQLString,\n  GraphQLNonNull,\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLSchema,\n} = require('graphql');\nconst { ParseServer } = require('../');\nconst { ParseGraphQLServer } = require('../lib/GraphQL/ParseGraphQLServer');\nconst ReadPreference = require('mongodb').ReadPreference;\nconst { v4: uuidv4 } = require('uuid');\n\nfunction handleError(e) {\n  if (\n    e &&\n    e.networkError &&\n    e.networkError.result &&\n    e.networkError.result.errors\n  ) {\n    fail(e.networkError.result.errors);\n  } else {\n    fail(e);\n  }\n}\n\ndescribe('ParseGraphQLServer', () => {\n  let parseServer;\n  let parseGraphQLServer;\n\n  beforeAll(async () => {\n    parseServer = await global.reconfigureServer({});\n    parseGraphQLServer = new ParseGraphQLServer(parseServer, {\n      graphQLPath: '/graphql',\n      playgroundPath: '/playground',\n      subscriptionsPath: '/subscriptions',\n    });\n  });\n\n  describe('constructor', () => {\n    it('should require a parseServer instance', () => {\n      expect(() => new ParseGraphQLServer()).toThrow(\n        'You must provide a parseServer instance!'\n      );\n    });\n\n    it('should require config.graphQLPath', () => {\n      expect(() => new ParseGraphQLServer(parseServer)).toThrow(\n        'You must provide a config.graphQLPath!'\n      );\n      expect(() => new ParseGraphQLServer(parseServer, {})).toThrow(\n        'You must provide a config.graphQLPath!'\n      );\n    });\n\n    it('should only require parseServer and config.graphQLPath args', () => {\n      let parseGraphQLServer;\n      expect(() => {\n        parseGraphQLServer = new ParseGraphQLServer(parseServer, {\n          graphQLPath: 'graphql',\n        });\n      }).not.toThrow();\n      expect(parseGraphQLServer.parseGraphQLSchema).toBeDefined();\n      expect(parseGraphQLServer.parseGraphQLSchema.databaseController).toEqual(\n        parseServer.config.databaseController\n      );\n    });\n\n    it('should initialize parseGraphQLSchema with a log controller', async () => {\n      const loggerAdapter = {\n        log: () => {},\n        error: () => {},\n      };\n      const parseServer = await global.reconfigureServer({\n        loggerAdapter,\n      });\n      const parseGraphQLServer = new ParseGraphQLServer(parseServer, {\n        graphQLPath: 'graphql',\n      });\n      expect(parseGraphQLServer.parseGraphQLSchema.log.adapter).toBe(\n        loggerAdapter\n      );\n    });\n  });\n\n  describe('_getGraphQLOptions', () => {\n    const req = {\n      info: new Object(),\n      config: new Object(),\n      auth: new Object(),\n    };\n\n    it(\"should return schema and context with req's info, config and auth\", async () => {\n      const options = await parseGraphQLServer._getGraphQLOptions(req);\n      expect(options.schema).toEqual(\n        parseGraphQLServer.parseGraphQLSchema.graphQLSchema\n      );\n      expect(options.context.info).toEqual(req.info);\n      expect(options.context.config).toEqual(req.config);\n      expect(options.context.auth).toEqual(req.auth);\n    });\n\n    it('should load GraphQL schema in every call', async () => {\n      const originalLoad = parseGraphQLServer.parseGraphQLSchema.load;\n      let counter = 0;\n      parseGraphQLServer.parseGraphQLSchema.load = () => ++counter;\n      expect((await parseGraphQLServer._getGraphQLOptions(req)).schema).toEqual(\n        1\n      );\n      expect((await parseGraphQLServer._getGraphQLOptions(req)).schema).toEqual(\n        2\n      );\n      expect((await parseGraphQLServer._getGraphQLOptions(req)).schema).toEqual(\n        3\n      );\n      parseGraphQLServer.parseGraphQLSchema.load = originalLoad;\n    });\n  });\n\n  describe('_transformMaxUploadSizeToBytes', () => {\n    it('should transform to bytes', () => {\n      expect(parseGraphQLServer._transformMaxUploadSizeToBytes('20mb')).toBe(\n        20971520\n      );\n      expect(parseGraphQLServer._transformMaxUploadSizeToBytes('333Gb')).toBe(\n        357556027392\n      );\n      expect(\n        parseGraphQLServer._transformMaxUploadSizeToBytes('123456KB')\n      ).toBe(126418944);\n    });\n  });\n\n  describe('applyGraphQL', () => {\n    it('should require an Express.js app instance', () => {\n      expect(() => parseGraphQLServer.applyGraphQL()).toThrow(\n        'You must provide an Express.js app instance!'\n      );\n      expect(() => parseGraphQLServer.applyGraphQL({})).toThrow(\n        'You must provide an Express.js app instance!'\n      );\n      expect(() =>\n        parseGraphQLServer.applyGraphQL(new express())\n      ).not.toThrow();\n    });\n\n    it('should apply middlewares at config.graphQLPath', () => {\n      let useCount = 0;\n      expect(() =>\n        new ParseGraphQLServer(parseServer, {\n          graphQLPath: 'somepath',\n        }).applyGraphQL({\n          use: path => {\n            useCount++;\n            expect(path).toEqual('somepath');\n          },\n        })\n      ).not.toThrow();\n      expect(useCount).toBeGreaterThan(0);\n    });\n  });\n\n  describe('applyPlayground', () => {\n    it('should require an Express.js app instance', () => {\n      expect(() => parseGraphQLServer.applyPlayground()).toThrow(\n        'You must provide an Express.js app instance!'\n      );\n      expect(() => parseGraphQLServer.applyPlayground({})).toThrow(\n        'You must provide an Express.js app instance!'\n      );\n      expect(() =>\n        parseGraphQLServer.applyPlayground(new express())\n      ).not.toThrow();\n    });\n\n    it('should require initialization with config.playgroundPath', () => {\n      expect(() =>\n        new ParseGraphQLServer(parseServer, {\n          graphQLPath: 'graphql',\n        }).applyPlayground(new express())\n      ).toThrow('You must provide a config.playgroundPath to applyPlayground!');\n    });\n\n    it('should apply middlewares at config.playgroundPath', () => {\n      let useCount = 0;\n      expect(() =>\n        new ParseGraphQLServer(parseServer, {\n          graphQLPath: 'graphQL',\n          playgroundPath: 'somepath',\n        }).applyPlayground({\n          get: path => {\n            useCount++;\n            expect(path).toEqual('somepath');\n          },\n        })\n      ).not.toThrow();\n      expect(useCount).toBeGreaterThan(0);\n    });\n  });\n\n  describe('createSubscriptions', () => {\n    it('should require initialization with config.subscriptionsPath', () => {\n      expect(() =>\n        new ParseGraphQLServer(parseServer, {\n          graphQLPath: 'graphql',\n        }).createSubscriptions({})\n      ).toThrow(\n        'You must provide a config.subscriptionsPath to createSubscriptions!'\n      );\n    });\n  });\n\n  describe('setGraphQLConfig', () => {\n    let parseGraphQLServer;\n    beforeEach(() => {\n      parseGraphQLServer = new ParseGraphQLServer(parseServer, {\n        graphQLPath: 'graphql',\n      });\n    });\n    it('should pass the graphQLConfig onto the parseGraphQLController', async () => {\n      let received;\n      parseGraphQLServer.parseGraphQLController = {\n        async updateGraphQLConfig(graphQLConfig) {\n          received = graphQLConfig;\n          return {};\n        },\n      };\n      const graphQLConfig = { enabledForClasses: [] };\n      await parseGraphQLServer.setGraphQLConfig(graphQLConfig);\n      expect(received).toBe(graphQLConfig);\n    });\n    it('should not absorb exceptions from parseGraphQLController', async () => {\n      parseGraphQLServer.parseGraphQLController = {\n        async updateGraphQLConfig() {\n          throw new Error('Network request failed');\n        },\n      };\n      await expectAsync(\n        parseGraphQLServer.setGraphQLConfig({})\n      ).toBeRejectedWith(new Error('Network request failed'));\n    });\n    it('should return the response from parseGraphQLController', async () => {\n      parseGraphQLServer.parseGraphQLController = {\n        async updateGraphQLConfig() {\n          return { response: { result: true } };\n        },\n      };\n      await expectAsync(\n        parseGraphQLServer.setGraphQLConfig({})\n      ).toBeResolvedTo({ response: { result: true } });\n    });\n  });\n\n  describe('Auto API', () => {\n    let httpServer;\n    let parseLiveQueryServer;\n    const headers = {\n      'X-Parse-Application-Id': 'test',\n      'X-Parse-Javascript-Key': 'test',\n    };\n\n    let apolloClient;\n\n    let user1;\n    let user2;\n    let user3;\n    let user4;\n    let user5;\n    let role;\n    let object1;\n    let object2;\n    let object3;\n    let object4;\n    let objects = [];\n\n    async function prepareData() {\n      user1 = new Parse.User();\n      user1.setUsername('user1');\n      user1.setPassword('user1');\n      user1.setEmail('user1@user1.user1');\n      await user1.signUp();\n\n      user2 = new Parse.User();\n      user2.setUsername('user2');\n      user2.setPassword('user2');\n      await user2.signUp();\n\n      user3 = new Parse.User();\n      user3.setUsername('user3');\n      user3.setPassword('user3');\n      await user3.signUp();\n\n      user4 = new Parse.User();\n      user4.setUsername('user4');\n      user4.setPassword('user4');\n      await user4.signUp();\n\n      user5 = new Parse.User();\n      user5.setUsername('user5');\n      user5.setPassword('user5');\n      await user5.signUp();\n\n      const roleACL = new Parse.ACL();\n      roleACL.setPublicReadAccess(true);\n      role = new Parse.Role();\n      role.setName('role');\n      role.setACL(roleACL);\n      role.getUsers().add(user1);\n      role.getUsers().add(user3);\n      role = await role.save();\n\n      const schemaController = await parseServer.config.databaseController.loadSchema();\n      try {\n        await schemaController.addClassIfNotExists(\n          'GraphQLClass',\n          {\n            someField: { type: 'String' },\n            pointerToUser: { type: 'Pointer', targetClass: '_User' },\n          },\n          {\n            find: {\n              'role:role': true,\n              [user1.id]: true,\n              [user2.id]: true,\n            },\n            create: {\n              'role:role': true,\n              [user1.id]: true,\n              [user2.id]: true,\n            },\n            get: {\n              'role:role': true,\n              [user1.id]: true,\n              [user2.id]: true,\n            },\n            update: {\n              'role:role': true,\n              [user1.id]: true,\n              [user2.id]: true,\n            },\n            addField: {\n              'role:role': true,\n              [user1.id]: true,\n              [user2.id]: true,\n            },\n            delete: {\n              'role:role': true,\n              [user1.id]: true,\n              [user2.id]: true,\n            },\n            readUserFields: ['pointerToUser'],\n            writeUserFields: ['pointerToUser'],\n          },\n          {}\n        );\n      } catch (err) {\n        if (\n          !(err instanceof Parse.Error) ||\n          err.message !== 'Class GraphQLClass already exists.'\n        ) {\n          throw err;\n        }\n      }\n\n      object1 = new Parse.Object('GraphQLClass');\n      object1.set('someField', 'someValue1');\n      object1.set('someOtherField', 'A');\n      const object1ACL = new Parse.ACL();\n      object1ACL.setPublicReadAccess(false);\n      object1ACL.setPublicWriteAccess(false);\n      object1ACL.setRoleReadAccess(role, true);\n      object1ACL.setRoleWriteAccess(role, true);\n      object1ACL.setReadAccess(user1.id, true);\n      object1ACL.setWriteAccess(user1.id, true);\n      object1ACL.setReadAccess(user2.id, true);\n      object1ACL.setWriteAccess(user2.id, true);\n      object1.setACL(object1ACL);\n      await object1.save(undefined, { useMasterKey: true });\n\n      object2 = new Parse.Object('GraphQLClass');\n      object2.set('someField', 'someValue2');\n      object2.set('someOtherField', 'A');\n      const object2ACL = new Parse.ACL();\n      object2ACL.setPublicReadAccess(false);\n      object2ACL.setPublicWriteAccess(false);\n      object2ACL.setReadAccess(user1.id, true);\n      object2ACL.setWriteAccess(user1.id, true);\n      object2ACL.setReadAccess(user2.id, true);\n      object2ACL.setWriteAccess(user2.id, true);\n      object2ACL.setReadAccess(user5.id, true);\n      object2ACL.setWriteAccess(user5.id, true);\n      object2.setACL(object2ACL);\n      await object2.save(undefined, { useMasterKey: true });\n\n      object3 = new Parse.Object('GraphQLClass');\n      object3.set('someField', 'someValue3');\n      object3.set('someOtherField', 'B');\n      object3.set('pointerToUser', user5);\n      await object3.save(undefined, { useMasterKey: true });\n\n      object4 = new Parse.Object('PublicClass');\n      object4.set('someField', 'someValue4');\n      await object4.save();\n\n      objects = [];\n      objects.push(object1, object2, object3, object4);\n    }\n\n    beforeAll(async () => {\n      const expressApp = express();\n      httpServer = http.createServer(expressApp);\n      expressApp.use('/parse', parseServer.app);\n      parseLiveQueryServer = ParseServer.createLiveQueryServer(httpServer, {\n        port: 1338,\n      });\n      parseGraphQLServer.applyGraphQL(expressApp);\n      parseGraphQLServer.applyPlayground(expressApp);\n      parseGraphQLServer.createSubscriptions(httpServer);\n      await new Promise(resolve => httpServer.listen({ port: 13377 }, resolve));\n\n      const subscriptionClient = new SubscriptionClient(\n        'ws://localhost:13377/subscriptions',\n        {\n          reconnect: true,\n          connectionParams: headers,\n        },\n        ws\n      );\n      const wsLink = new WebSocketLink(subscriptionClient);\n      const httpLink = createUploadLink({\n        uri: 'http://localhost:13377/graphql',\n        fetch,\n        headers,\n      });\n      apolloClient = new ApolloClient({\n        link: split(\n          ({ query }) => {\n            const { kind, operation } = getMainDefinition(query);\n            return (\n              kind === 'OperationDefinition' && operation === 'subscription'\n            );\n          },\n          wsLink,\n          httpLink\n        ),\n        cache: new InMemoryCache(),\n        defaultOptions: {\n          query: {\n            fetchPolicy: 'no-cache',\n          },\n        },\n      });\n    });\n\n    beforeEach(() => {\n      spyOn(console, 'warn').and.callFake(() => {});\n      spyOn(console, 'error').and.callFake(() => {});\n    });\n\n    afterAll(async () => {\n      await parseLiveQueryServer.server.close();\n      await httpServer.close();\n    });\n\n    describe('GraphQL', () => {\n      it('should be healthy', async () => {\n        try {\n          const health = (\n            await apolloClient.query({\n              query: gql`\n                query Health {\n                  health\n                }\n              `,\n            })\n          ).data.health;\n          expect(health).toBeTruthy();\n        } catch (e) {\n          handleError(e);\n        }\n      });\n\n      it('should be cors enabled', async () => {\n        let checked = false;\n        const apolloClient = new ApolloClient({\n          link: new ApolloLink((operation, forward) => {\n            return forward(operation).map(response => {\n              const context = operation.getContext();\n              const {\n                response: { headers },\n              } = context;\n              expect(headers.get('access-control-allow-origin')).toEqual('*');\n              checked = true;\n              return response;\n            });\n          }).concat(\n            createHttpLink({\n              uri: 'http://localhost:13377/graphql',\n              fetch,\n              headers: {\n                ...headers,\n                Origin: 'http://someorigin.com',\n              },\n            })\n          ),\n          cache: new InMemoryCache(),\n        });\n        const healthResponse = await apolloClient.query({\n          query: gql`\n            query Health {\n              health\n            }\n          `,\n        });\n        expect(healthResponse.data.health).toBeTruthy();\n        expect(checked).toBeTruthy();\n      });\n\n      it('should handle Parse headers', async () => {\n        let checked = false;\n        const originalGetGraphQLOptions = parseGraphQLServer._getGraphQLOptions;\n        parseGraphQLServer._getGraphQLOptions = async req => {\n          expect(req.info).toBeDefined();\n          expect(req.config).toBeDefined();\n          expect(req.auth).toBeDefined();\n          checked = true;\n          return await originalGetGraphQLOptions.bind(parseGraphQLServer)(req);\n        };\n        const health = (\n          await apolloClient.query({\n            query: gql`\n              query Health {\n                health\n              }\n            `,\n          })\n        ).data.health;\n        expect(health).toBeTruthy();\n        expect(checked).toBeTruthy();\n        parseGraphQLServer._getGraphQLOptions = originalGetGraphQLOptions;\n      });\n    });\n\n    describe('Playground', () => {\n      it('should mount playground', async () => {\n        const res = await req({\n          method: 'GET',\n          url: 'http://localhost:13377/playground',\n        });\n        expect(res.status).toEqual(200);\n      });\n    });\n\n    describe('Schema', () => {\n      const resetGraphQLCache = async () => {\n        await Promise.all([\n          parseGraphQLServer.parseGraphQLController.cacheController.graphQL.clear(),\n          parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear(),\n        ]);\n      };\n\n      describe('Default Types', () => {\n        it('should have Object scalar type', async () => {\n          const objectType = (\n            await apolloClient.query({\n              query: gql`\n                query ObjectType {\n                  __type(name: \"Object\") {\n                    kind\n                  }\n                }\n              `,\n            })\n          ).data['__type'];\n          expect(objectType.kind).toEqual('SCALAR');\n        });\n\n        it('should have Date scalar type', async () => {\n          const dateType = (\n            await apolloClient.query({\n              query: gql`\n                query DateType {\n                  __type(name: \"Date\") {\n                    kind\n                  }\n                }\n              `,\n            })\n          ).data['__type'];\n          expect(dateType.kind).toEqual('SCALAR');\n        });\n\n        it('should have ArrayResult type', async () => {\n          const arrayResultType = (\n            await apolloClient.query({\n              query: gql`\n                query ArrayResultType {\n                  __type(name: \"ArrayResult\") {\n                    kind\n                  }\n                }\n              `,\n            })\n          ).data['__type'];\n          expect(arrayResultType.kind).toEqual('UNION');\n        });\n\n        it('should have File object type', async () => {\n          const fileType = (\n            await apolloClient.query({\n              query: gql`\n                query FileType {\n                  __type(name: \"FileInfo\") {\n                    kind\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'];\n          expect(fileType.kind).toEqual('OBJECT');\n          expect(fileType.fields.map(field => field.name).sort()).toEqual([\n            'name',\n            'url',\n          ]);\n        });\n\n        it('should have Class interface type', async () => {\n          const classType = (\n            await apolloClient.query({\n              query: gql`\n                query ClassType {\n                  __type(name: \"ParseObject\") {\n                    kind\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'];\n          expect(classType.kind).toEqual('INTERFACE');\n          expect(classType.fields.map(field => field.name).sort()).toEqual([\n            'ACL',\n            'createdAt',\n            'objectId',\n            'updatedAt',\n          ]);\n        });\n\n        it('should have ReadPreference enum type', async () => {\n          const readPreferenceType = (\n            await apolloClient.query({\n              query: gql`\n                query ReadPreferenceType {\n                  __type(name: \"ReadPreference\") {\n                    kind\n                    enumValues {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'];\n          expect(readPreferenceType.kind).toEqual('ENUM');\n          expect(\n            readPreferenceType.enumValues.map(value => value.name).sort()\n          ).toEqual([\n            'NEAREST',\n            'PRIMARY',\n            'PRIMARY_PREFERRED',\n            'SECONDARY',\n            'SECONDARY_PREFERRED',\n          ]);\n        });\n\n        it('should have GraphQLUpload object type', async () => {\n          const graphQLUploadType = (\n            await apolloClient.query({\n              query: gql`\n                query GraphQLUploadType {\n                  __type(name: \"Upload\") {\n                    kind\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'];\n          expect(graphQLUploadType.kind).toEqual('SCALAR');\n        });\n\n        it('should have all expected types', async () => {\n          const schemaTypes = (\n            await apolloClient.query({\n              query: gql`\n                query SchemaTypes {\n                  __schema {\n                    types {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__schema'].types.map(type => type.name);\n\n          const expectedTypes = [\n            'ParseObject',\n            'Date',\n            'FileInfo',\n            'ReadPreference',\n            'Upload',\n          ];\n          expect(\n            expectedTypes.every(type => schemaTypes.indexOf(type) !== -1)\n          ).toBeTruthy(JSON.stringify(schemaTypes.types));\n        });\n      });\n\n      describe('Relay Specific Types', () => {\n        beforeAll(async () => {\n          await resetGraphQLCache();\n        });\n\n        afterAll(async () => {\n          await resetGraphQLCache();\n        });\n\n        it('should have Node interface', async () => {\n          const schemaTypes = (\n            await apolloClient.query({\n              query: gql`\n                query SchemaTypes {\n                  __schema {\n                    types {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__schema'].types.map(type => type.name);\n\n          expect(schemaTypes).toContain('Node');\n        });\n\n        it('should have node query', async () => {\n          const queryFields = (\n            await apolloClient.query({\n              query: gql`\n                query UserType {\n                  __type(name: \"Query\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].fields.map(field => field.name);\n\n          expect(queryFields).toContain('node');\n        });\n\n        it('should return global id', async () => {\n          const userFields = (\n            await apolloClient.query({\n              query: gql`\n                query UserType {\n                  __type(name: \"User\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].fields.map(field => field.name);\n\n          expect(userFields).toContain('id');\n          expect(userFields).toContain('objectId');\n        });\n\n        it('should have clientMutationId in create file input', async () => {\n          const createFileInputFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"CreateFileInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].inputFields\n            .map(field => field.name)\n            .sort();\n\n          expect(createFileInputFields).toEqual(['clientMutationId', 'upload']);\n        });\n\n        it('should have clientMutationId in create file payload', async () => {\n          const createFilePayloadFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"CreateFilePayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].fields\n            .map(field => field.name)\n            .sort();\n\n          expect(createFilePayloadFields).toEqual([\n            'clientMutationId',\n            'fileInfo',\n          ]);\n        });\n\n        it('should have clientMutationId in call function input', async () => {\n          Parse.Cloud.define('hello', () => {});\n\n          const callFunctionInputFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"CallCloudCodeInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].inputFields\n            .map(field => field.name)\n            .sort();\n\n          expect(callFunctionInputFields).toEqual([\n            'clientMutationId',\n            'functionName',\n            'params',\n          ]);\n        });\n\n        it('should have clientMutationId in call function payload', async () => {\n          Parse.Cloud.define('hello', () => {});\n\n          const callFunctionPayloadFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"CallCloudCodePayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].fields\n            .map(field => field.name)\n            .sort();\n\n          expect(callFunctionPayloadFields).toEqual([\n            'clientMutationId',\n            'result',\n          ]);\n        });\n\n        it('should have clientMutationId in sign up mutation input', async () => {\n          const inputFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"SignUpInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].inputFields\n            .map(field => field.name)\n            .sort();\n\n          expect(inputFields).toEqual(['clientMutationId', 'fields']);\n        });\n\n        it('should have clientMutationId in sign up mutation payload', async () => {\n          const payloadFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"SignUpPayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].fields\n            .map(field => field.name)\n            .sort();\n\n          expect(payloadFields).toEqual(['clientMutationId', 'viewer']);\n        });\n\n        it('should have clientMutationId in log in mutation input', async () => {\n          const inputFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"LogInInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].inputFields\n            .map(field => field.name)\n            .sort();\n\n          expect(inputFields).toEqual([\n            'clientMutationId',\n            'password',\n            'username',\n          ]);\n        });\n\n        it('should have clientMutationId in log in mutation payload', async () => {\n          const payloadFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"LogInPayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].fields\n            .map(field => field.name)\n            .sort();\n\n          expect(payloadFields).toEqual(['clientMutationId', 'viewer']);\n        });\n\n        it('should have clientMutationId in log out mutation input', async () => {\n          const inputFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"LogOutInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].inputFields\n            .map(field => field.name)\n            .sort();\n\n          expect(inputFields).toEqual(['clientMutationId']);\n        });\n\n        it('should have clientMutationId in log out mutation payload', async () => {\n          const payloadFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"LogOutPayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].fields\n            .map(field => field.name)\n            .sort();\n\n          expect(payloadFields).toEqual(['clientMutationId', 'viewer']);\n        });\n\n        it('should have clientMutationId in createClass mutation input', async () => {\n          const inputFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"CreateClassInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].inputFields\n            .map(field => field.name)\n            .sort();\n\n          expect(inputFields).toEqual([\n            'clientMutationId',\n            'name',\n            'schemaFields',\n          ]);\n        });\n\n        it('should have clientMutationId in createClass mutation payload', async () => {\n          const payloadFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"CreateClassPayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].fields\n            .map(field => field.name)\n            .sort();\n\n          expect(payloadFields).toEqual(['class', 'clientMutationId']);\n        });\n\n        it('should have clientMutationId in updateClass mutation input', async () => {\n          const inputFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"UpdateClassInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].inputFields\n            .map(field => field.name)\n            .sort();\n\n          expect(inputFields).toEqual([\n            'clientMutationId',\n            'name',\n            'schemaFields',\n          ]);\n        });\n\n        it('should have clientMutationId in updateClass mutation payload', async () => {\n          const payloadFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"UpdateClassPayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].fields\n            .map(field => field.name)\n            .sort();\n\n          expect(payloadFields).toEqual(['class', 'clientMutationId']);\n        });\n\n        it('should have clientMutationId in deleteClass mutation input', async () => {\n          const inputFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"DeleteClassInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].inputFields\n            .map(field => field.name)\n            .sort();\n\n          expect(inputFields).toEqual(['clientMutationId', 'name']);\n        });\n\n        it('should have clientMutationId in deleteClass mutation payload', async () => {\n          const payloadFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"UpdateClassPayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].fields\n            .map(field => field.name)\n            .sort();\n\n          expect(payloadFields).toEqual(['class', 'clientMutationId']);\n        });\n\n        it('should have clientMutationId in custom create object mutation input', async () => {\n          const obj = new Parse.Object('SomeClass');\n          await obj.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const createObjectInputFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"CreateSomeClassInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].inputFields\n            .map(field => field.name)\n            .sort();\n\n          expect(createObjectInputFields).toEqual([\n            'clientMutationId',\n            'fields',\n          ]);\n        });\n\n        it('should have clientMutationId in custom create object mutation payload', async () => {\n          const obj = new Parse.Object('SomeClass');\n          await obj.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const createObjectPayloadFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"CreateSomeClassPayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].fields\n            .map(field => field.name)\n            .sort();\n\n          expect(createObjectPayloadFields).toEqual([\n            'clientMutationId',\n            'someClass',\n          ]);\n        });\n\n        it('should have clientMutationId in custom update object mutation input', async () => {\n          const obj = new Parse.Object('SomeClass');\n          await obj.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const createObjectInputFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"UpdateSomeClassInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].inputFields\n            .map(field => field.name)\n            .sort();\n\n          expect(createObjectInputFields).toEqual([\n            'clientMutationId',\n            'fields',\n            'id',\n          ]);\n        });\n\n        it('should have clientMutationId in custom update object mutation payload', async () => {\n          const obj = new Parse.Object('SomeClass');\n          await obj.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const createObjectPayloadFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"UpdateSomeClassPayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].fields\n            .map(field => field.name)\n            .sort();\n\n          expect(createObjectPayloadFields).toEqual([\n            'clientMutationId',\n            'someClass',\n          ]);\n        });\n\n        it('should have clientMutationId in custom delete object mutation input', async () => {\n          const obj = new Parse.Object('SomeClass');\n          await obj.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const createObjectInputFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"DeleteSomeClassInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].inputFields\n            .map(field => field.name)\n            .sort();\n\n          expect(createObjectInputFields).toEqual(['clientMutationId', 'id']);\n        });\n\n        it('should have clientMutationId in custom delete object mutation payload', async () => {\n          const obj = new Parse.Object('SomeClass');\n          await obj.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const createObjectPayloadFields = (\n            await apolloClient.query({\n              query: gql`\n                query {\n                  __type(name: \"DeleteSomeClassPayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].fields\n            .map(field => field.name)\n            .sort();\n\n          expect(createObjectPayloadFields).toEqual([\n            'clientMutationId',\n            'someClass',\n          ]);\n        });\n      });\n\n      describe('Parse Class Types', () => {\n        it('should have all expected types', async () => {\n          await parseServer.config.databaseController.loadSchema();\n\n          const schemaTypes = (\n            await apolloClient.query({\n              query: gql`\n                query SchemaTypes {\n                  __schema {\n                    types {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__schema'].types.map(type => type.name);\n\n          const expectedTypes = [\n            'Role',\n            'RoleWhereInput',\n            'CreateRoleFieldsInput',\n            'UpdateRoleFieldsInput',\n            'RoleConnection',\n            'User',\n            'UserWhereInput',\n            'UserConnection',\n            'CreateUserFieldsInput',\n            'UpdateUserFieldsInput',\n          ];\n          expect(\n            expectedTypes.every(type => schemaTypes.indexOf(type) !== -1)\n          ).toBeTruthy(JSON.stringify(schemaTypes));\n        });\n\n        it('should ArrayResult contains all types', async () => {\n          const objectType = (\n            await apolloClient.query({\n              query: gql`\n                query ObjectType {\n                  __type(name: \"ArrayResult\") {\n                    kind\n                    possibleTypes {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'];\n          const possibleTypes = objectType.possibleTypes.map(o => o.name);\n          expect(possibleTypes).toContain('User');\n          expect(possibleTypes).toContain('Role');\n          expect(possibleTypes).toContain('Element');\n        });\n\n        it('should update schema when it changes', async () => {\n          const schemaController = await parseServer.config.databaseController.loadSchema();\n          await schemaController.updateClass('_User', {\n            foo: { type: 'String' },\n          });\n\n          const userFields = (\n            await apolloClient.query({\n              query: gql`\n                query UserType {\n                  __type(name: \"User\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].fields.map(field => field.name);\n          expect(userFields.indexOf('foo') !== -1).toBeTruthy();\n        });\n\n        it('should not contain password field from _User class', async () => {\n          const userFields = (\n            await apolloClient.query({\n              query: gql`\n                query UserType {\n                  __type(name: \"User\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `,\n            })\n          ).data['__type'].fields.map(field => field.name);\n          expect(userFields.includes('password')).toBeFalsy();\n        });\n      });\n\n      describe('Configuration', function () {\n        const resetGraphQLCache = async () => {\n          await Promise.all([\n            parseGraphQLServer.parseGraphQLController.cacheController.graphQL.clear(),\n            parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear(),\n          ]);\n        };\n\n        beforeEach(async () => {\n          await parseGraphQLServer.setGraphQLConfig({});\n          await resetGraphQLCache();\n        });\n\n        it('should only include types in the enabledForClasses list', async () => {\n          const schemaController = await parseServer.config.databaseController.loadSchema();\n          await schemaController.addClassIfNotExists('SuperCar', {\n            foo: { type: 'String' },\n          });\n\n          const graphQLConfig = {\n            enabledForClasses: ['SuperCar'],\n          };\n          await parseGraphQLServer.setGraphQLConfig(graphQLConfig);\n          await resetGraphQLCache();\n\n          const { data } = await apolloClient.query({\n            query: gql`\n              query UserType {\n                userType: __type(name: \"User\") {\n                  fields {\n                    name\n                  }\n                }\n                superCarType: __type(name: \"SuperCar\") {\n                  fields {\n                    name\n                  }\n                }\n              }\n            `,\n          });\n          expect(data.userType).toBeNull();\n          expect(data.superCarType).toBeTruthy();\n        });\n        it('should not include types in the disabledForClasses list', async () => {\n          const schemaController = await parseServer.config.databaseController.loadSchema();\n          await schemaController.addClassIfNotExists('SuperCar', {\n            foo: { type: 'String' },\n          });\n\n          const graphQLConfig = {\n            disabledForClasses: ['SuperCar'],\n          };\n          await parseGraphQLServer.setGraphQLConfig(graphQLConfig);\n          await resetGraphQLCache();\n\n          const { data } = await apolloClient.query({\n            query: gql`\n              query UserType {\n                userType: __type(name: \"User\") {\n                  fields {\n                    name\n                  }\n                }\n                superCarType: __type(name: \"SuperCar\") {\n                  fields {\n                    name\n                  }\n                }\n              }\n            `,\n          });\n          expect(data.superCarType).toBeNull();\n          expect(data.userType).toBeTruthy();\n        });\n        it('should remove query operations when disabled', async () => {\n          const superCar = new Parse.Object('SuperCar');\n          await superCar.save({ foo: 'bar' });\n          const customer = new Parse.Object('Customer');\n          await customer.save({ foo: 'bar' });\n\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                query GetSuperCar($id: ID!) {\n                  superCar(id: $id) {\n                    id\n                  }\n                }\n              `,\n              variables: {\n                id: superCar.id,\n              },\n            })\n          ).toBeResolved();\n\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                query FindCustomer {\n                  customers {\n                    count\n                  }\n                }\n              `,\n            })\n          ).toBeResolved();\n\n          const graphQLConfig = {\n            classConfigs: [\n              {\n                className: 'SuperCar',\n                query: {\n                  get: false,\n                  find: true,\n                },\n              },\n              {\n                className: 'Customer',\n                query: {\n                  get: true,\n                  find: false,\n                },\n              },\n            ],\n          };\n          await parseGraphQLServer.setGraphQLConfig(graphQLConfig);\n          await resetGraphQLCache();\n\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                query GetSuperCar($id: ID!) {\n                  superCar(id: $id) {\n                    id\n                  }\n                }\n              `,\n              variables: {\n                id: superCar.id,\n              },\n            })\n          ).toBeRejected();\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                query GetCustomer($id: ID!) {\n                  customer(id: $id) {\n                    id\n                  }\n                }\n              `,\n              variables: {\n                id: customer.id,\n              },\n            })\n          ).toBeResolved();\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                query FindSuperCar {\n                  superCars {\n                    count\n                  }\n                }\n              `,\n            })\n          ).toBeResolved();\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                query FindCustomer {\n                  customers {\n                    count\n                  }\n                }\n              `,\n            })\n          ).toBeRejected();\n        });\n\n        it('should remove mutation operations, create, update and delete, when disabled', async () => {\n          const superCar1 = new Parse.Object('SuperCar');\n          await superCar1.save({ foo: 'bar' });\n          const customer1 = new Parse.Object('Customer');\n          await customer1.save({ foo: 'bar' });\n\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                mutation UpdateSuperCar($id: ID!, $foo: String!) {\n                  updateSuperCar(input: { id: $id, fields: { foo: $foo } }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                id: superCar1.id,\n                foo: 'lah',\n              },\n            })\n          ).toBeResolved();\n\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                mutation DeleteCustomer($id: ID!) {\n                  deleteCustomer(input: { id: $id }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                id: customer1.id,\n              },\n            })\n          ).toBeResolved();\n\n          const { data: customerData } = await apolloClient.query({\n            query: gql`\n              mutation CreateCustomer($foo: String!) {\n                createCustomer(input: { fields: { foo: $foo } }) {\n                  customer {\n                    id\n                  }\n                }\n              }\n            `,\n            variables: {\n              foo: 'rah',\n            },\n          });\n          expect(customerData.createCustomer.customer).toBeTruthy();\n\n          // used later\n          const customer2Id = customerData.createCustomer.customer.id;\n\n          await parseGraphQLServer.setGraphQLConfig({\n            classConfigs: [\n              {\n                className: 'SuperCar',\n                mutation: {\n                  create: true,\n                  update: false,\n                  destroy: true,\n                },\n              },\n              {\n                className: 'Customer',\n                mutation: {\n                  create: false,\n                  update: true,\n                  destroy: false,\n                },\n              },\n            ],\n          });\n          await resetGraphQLCache();\n\n          const { data: superCarData } = await apolloClient.query({\n            query: gql`\n              mutation CreateSuperCar($foo: String!) {\n                createSuperCar(input: { fields: { foo: $foo } }) {\n                  superCar {\n                    id\n                  }\n                }\n              }\n            `,\n            variables: {\n              foo: 'mah',\n            },\n          });\n          expect(superCarData.createSuperCar).toBeTruthy();\n          const superCar3Id = superCarData.createSuperCar.superCar.id;\n\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                mutation UpdateSupercar($id: ID!, $foo: String!) {\n                  updateSuperCar(input: { id: $id, fields: { foo: $foo } }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                id: superCar3Id,\n              },\n            })\n          ).toBeRejected();\n\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                mutation DeleteSuperCar($id: ID!) {\n                  deleteSuperCar(input: { id: $id }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                id: superCar3Id,\n              },\n            })\n          ).toBeResolved();\n\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                mutation CreateCustomer($foo: String!) {\n                  createCustomer(input: { fields: { foo: $foo } }) {\n                    customer {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                foo: 'rah',\n              },\n            })\n          ).toBeRejected();\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                mutation UpdateCustomer($id: ID!, $foo: String!) {\n                  updateCustomer(input: { id: $id, fields: { foo: $foo } }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                id: customer2Id,\n                foo: 'tah',\n              },\n            })\n          ).toBeResolved();\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                mutation DeleteCustomer($id: ID!, $foo: String!) {\n                  deleteCustomer(input: { id: $id }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                id: customer2Id,\n              },\n            })\n          ).toBeRejected();\n        });\n\n        it('should only allow the supplied create and update fields for a class', async () => {\n          const schemaController = await parseServer.config.databaseController.loadSchema();\n          await schemaController.addClassIfNotExists('SuperCar', {\n            engine: { type: 'String' },\n            doors: { type: 'Number' },\n            price: { type: 'String' },\n            mileage: { type: 'Number' },\n          });\n\n          await parseGraphQLServer.setGraphQLConfig({\n            classConfigs: [\n              {\n                className: 'SuperCar',\n                type: {\n                  inputFields: {\n                    create: ['engine', 'doors', 'price'],\n                    update: ['price', 'mileage'],\n                  },\n                },\n              },\n            ],\n          });\n\n          await resetGraphQLCache();\n\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                mutation InvalidCreateSuperCar {\n                  createSuperCar(\n                    input: { fields: { engine: \"diesel\", mileage: 1000 } }\n                  ) {\n                    superCar {\n                      id\n                    }\n                  }\n                }\n              `,\n            })\n          ).toBeRejected();\n          const { id: superCarId } = (\n            await apolloClient.query({\n              query: gql`\n                mutation ValidCreateSuperCar {\n                  createSuperCar(\n                    input: {\n                      fields: { engine: \"diesel\", doors: 5, price: \"\u00a310000\" }\n                    }\n                  ) {\n                    superCar {\n                      id\n                    }\n                  }\n                }\n              `,\n            })\n          ).data.createSuperCar.superCar;\n\n          expect(superCarId).toBeTruthy();\n\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                mutation InvalidUpdateSuperCar($id: ID!) {\n                  updateSuperCar(\n                    input: { id: $id, fields: { engine: \"petrol\" } }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                id: superCarId,\n              },\n            })\n          ).toBeRejected();\n\n          const updatedSuperCar = (\n            await apolloClient.query({\n              query: gql`\n                mutation ValidUpdateSuperCar($id: ID!) {\n                  updateSuperCar(\n                    input: { id: $id, fields: { mileage: 2000 } }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                id: superCarId,\n              },\n            })\n          ).data.updateSuperCar;\n          expect(updatedSuperCar).toBeTruthy();\n        });\n\n        it('should handle required fields from the Parse class', async () => {\n          const schemaController = await parseServer.config.databaseController.loadSchema();\n          await schemaController.addClassIfNotExists('SuperCar', {\n            engine: { type: 'String', required: true },\n            doors: { type: 'Number', required: true },\n            price: { type: 'String' },\n            mileage: { type: 'Number' },\n          });\n\n          await resetGraphQLCache();\n\n          const {\n            data: { __type },\n          } = await apolloClient.query({\n            query: gql`\n              query requiredFields {\n                __type(name: \"CreateSuperCarFieldsInput\") {\n                  inputFields {\n                    name\n                    type {\n                      kind\n                    }\n                  }\n                }\n              }\n            `,\n          });\n          expect(\n            __type.inputFields.find(o => o.name === 'price').type.kind\n          ).toEqual('SCALAR');\n          expect(\n            __type.inputFields.find(o => o.name === 'engine').type.kind\n          ).toEqual('NON_NULL');\n          expect(\n            __type.inputFields.find(o => o.name === 'doors').type.kind\n          ).toEqual('NON_NULL');\n\n          const {\n            data: { __type: __type2 },\n          } = await apolloClient.query({\n            query: gql`\n              query requiredFields {\n                __type(name: \"SuperCar\") {\n                  fields {\n                    name\n                    type {\n                      kind\n                    }\n                  }\n                }\n              }\n            `,\n          });\n          expect(\n            __type2.fields.find(o => o.name === 'price').type.kind\n          ).toEqual('SCALAR');\n          expect(\n            __type2.fields.find(o => o.name === 'engine').type.kind\n          ).toEqual('NON_NULL');\n          expect(\n            __type2.fields.find(o => o.name === 'doors').type.kind\n          ).toEqual('NON_NULL');\n        });\n\n        it('should only allow the supplied output fields for a class', async () => {\n          const schemaController = await parseServer.config.databaseController.loadSchema();\n\n          await schemaController.addClassIfNotExists('SuperCar', {\n            engine: { type: 'String' },\n            doors: { type: 'Number' },\n            price: { type: 'String' },\n            mileage: { type: 'Number' },\n            insuranceClaims: { type: 'Number' },\n          });\n\n          const superCar = await new Parse.Object('SuperCar').save({\n            engine: 'petrol',\n            doors: 3,\n            price: '\u00a37500',\n            mileage: 0,\n            insuranceCertificate: 'private-file.pdf',\n          });\n\n          await parseGraphQLServer.setGraphQLConfig({\n            classConfigs: [\n              {\n                className: 'SuperCar',\n                type: {\n                  outputFields: ['engine', 'doors', 'price', 'mileage'],\n                },\n              },\n            ],\n          });\n\n          await resetGraphQLCache();\n\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                query GetSuperCar($id: ID!) {\n                  superCar(id: $id) {\n                    id\n                    objectId\n                    engine\n                    doors\n                    price\n                    mileage\n                    insuranceCertificate\n                  }\n                }\n              `,\n              variables: {\n                id: superCar.id,\n              },\n            })\n          ).toBeRejected();\n          let getSuperCar = (\n            await apolloClient.query({\n              query: gql`\n                query GetSuperCar($id: ID!) {\n                  superCar(id: $id) {\n                    id\n                    objectId\n                    engine\n                    doors\n                    price\n                    mileage\n                  }\n                }\n              `,\n              variables: {\n                id: superCar.id,\n              },\n            })\n          ).data.superCar;\n          expect(getSuperCar).toBeTruthy();\n\n          await parseGraphQLServer.setGraphQLConfig({\n            classConfigs: [\n              {\n                className: 'SuperCar',\n                type: {\n                  outputFields: [],\n                },\n              },\n            ],\n          });\n\n          await resetGraphQLCache();\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                query GetSuperCar($id: ID!) {\n                  superCar(id: $id) {\n                    engine\n                  }\n                }\n              `,\n              variables: {\n                id: superCar.id,\n              },\n            })\n          ).toBeRejected();\n          getSuperCar = (\n            await apolloClient.query({\n              query: gql`\n                query GetSuperCar($id: ID!) {\n                  superCar(id: $id) {\n                    id\n                    objectId\n                  }\n                }\n              `,\n              variables: {\n                id: superCar.id,\n              },\n            })\n          ).data.superCar;\n          expect(getSuperCar.objectId).toBe(superCar.id);\n        });\n\n        it('should only allow the supplied constraint fields for a class', async () => {\n          try {\n            const schemaController = await parseServer.config.databaseController.loadSchema();\n\n            await schemaController.addClassIfNotExists('SuperCar', {\n              model: { type: 'String' },\n              engine: { type: 'String' },\n              doors: { type: 'Number' },\n              price: { type: 'String' },\n              mileage: { type: 'Number' },\n              insuranceCertificate: { type: 'String' },\n            });\n\n            await new Parse.Object('SuperCar').save({\n              model: 'McLaren',\n              engine: 'petrol',\n              doors: 3,\n              price: '\u00a37500',\n              mileage: 0,\n              insuranceCertificate: 'private-file.pdf',\n            });\n\n            await parseGraphQLServer.setGraphQLConfig({\n              classConfigs: [\n                {\n                  className: 'SuperCar',\n                  type: {\n                    constraintFields: ['engine', 'doors', 'price'],\n                  },\n                },\n              ],\n            });\n\n            await resetGraphQLCache();\n\n            await expectAsync(\n              apolloClient.query({\n                query: gql`\n                  query FindSuperCar {\n                    superCars(\n                      where: {\n                        insuranceCertificate: { equalTo: \"private-file.pdf\" }\n                      }\n                    ) {\n                      count\n                    }\n                  }\n                `,\n              })\n            ).toBeRejected();\n\n            await expectAsync(\n              apolloClient.query({\n                query: gql`\n                  query FindSuperCar {\n                    superCars(where: { mileage: { equalTo: 0 } }) {\n                      count\n                    }\n                  }\n                `,\n              })\n            ).toBeRejected();\n\n            await expectAsync(\n              apolloClient.query({\n                query: gql`\n                  query FindSuperCar {\n                    superCars(where: { engine: { equalTo: \"petrol\" } }) {\n                      count\n                    }\n                  }\n                `,\n              })\n            ).toBeResolved();\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should only allow the supplied sort fields for a class', async () => {\n          const schemaController = await parseServer.config.databaseController.loadSchema();\n\n          await schemaController.addClassIfNotExists('SuperCar', {\n            engine: { type: 'String' },\n            doors: { type: 'Number' },\n            price: { type: 'String' },\n            mileage: { type: 'Number' },\n          });\n\n          await new Parse.Object('SuperCar').save({\n            engine: 'petrol',\n            doors: 3,\n            price: '\u00a37500',\n            mileage: 0,\n          });\n\n          await parseGraphQLServer.setGraphQLConfig({\n            classConfigs: [\n              {\n                className: 'SuperCar',\n                type: {\n                  sortFields: [\n                    {\n                      field: 'doors',\n                      asc: true,\n                      desc: true,\n                    },\n                    {\n                      field: 'price',\n                      asc: true,\n                      desc: true,\n                    },\n                    {\n                      field: 'mileage',\n                      asc: true,\n                      desc: false,\n                    },\n                  ],\n                },\n              },\n            ],\n          });\n\n          await resetGraphQLCache();\n\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                query FindSuperCar {\n                  superCars(order: [engine_ASC]) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `,\n            })\n          ).toBeRejected();\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                query FindSuperCar {\n                  superCars(order: [engine_DESC]) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `,\n            })\n          ).toBeRejected();\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                query FindSuperCar {\n                  superCars(order: [mileage_DESC]) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `,\n            })\n          ).toBeRejected();\n\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                query FindSuperCar {\n                  superCars(order: [mileage_ASC]) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `,\n            })\n          ).toBeResolved();\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                query FindSuperCar {\n                  superCars(order: [doors_ASC]) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `,\n            })\n          ).toBeResolved();\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                query FindSuperCar {\n                  superCars(order: [price_DESC]) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `,\n            })\n          ).toBeResolved();\n          await expectAsync(\n            apolloClient.query({\n              query: gql`\n                query FindSuperCar {\n                  superCars(order: [price_ASC, doors_DESC]) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `,\n            })\n          ).toBeResolved();\n        });\n      });\n\n      describe('Relay Spec', () => {\n        beforeAll(async () => {\n          await resetGraphQLCache();\n        });\n\n        afterAll(async () => {\n          await resetGraphQLCache();\n        });\n\n        describe('Object Identification', () => {\n          it('Class get custom method should return valid gobal id', async () => {\n            const obj = new Parse.Object('SomeClass');\n            obj.set('someField', 'some value');\n            await obj.save();\n\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeClass($objectId: ID!) {\n                  someClass(id: $objectId) {\n                    id\n                    objectId\n                  }\n                }\n              `,\n              variables: {\n                objectId: obj.id,\n              },\n            });\n\n            expect(getResult.data.someClass.objectId).toBe(obj.id);\n\n            const nodeResult = await apolloClient.query({\n              query: gql`\n                query Node($id: ID!) {\n                  node(id: $id) {\n                    id\n                    ... on SomeClass {\n                      objectId\n                      someField\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: getResult.data.someClass.id,\n              },\n            });\n\n            expect(nodeResult.data.node.id).toBe(getResult.data.someClass.id);\n            expect(nodeResult.data.node.objectId).toBe(obj.id);\n            expect(nodeResult.data.node.someField).toBe('some value');\n          });\n\n          it('Class find custom method should return valid gobal id', async () => {\n            const obj1 = new Parse.Object('SomeClass');\n            obj1.set('someField', 'some value 1');\n            await obj1.save();\n\n            const obj2 = new Parse.Object('SomeClass');\n            obj2.set('someField', 'some value 2');\n            await obj2.save();\n\n            const findResult = await apolloClient.query({\n              query: gql`\n                query FindSomeClass {\n                  someClasses(order: [createdAt_ASC]) {\n                    edges {\n                      node {\n                        id\n                        objectId\n                      }\n                    }\n                  }\n                }\n              `,\n            });\n\n            expect(findResult.data.someClasses.edges[0].node.objectId).toBe(\n              obj1.id\n            );\n            expect(findResult.data.someClasses.edges[1].node.objectId).toBe(\n              obj2.id\n            );\n\n            const nodeResult = await apolloClient.query({\n              query: gql`\n                query Node($id1: ID!, $id2: ID!) {\n                  node1: node(id: $id1) {\n                    id\n                    ... on SomeClass {\n                      objectId\n                      someField\n                    }\n                  }\n                  node2: node(id: $id2) {\n                    id\n                    ... on SomeClass {\n                      objectId\n                      someField\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id1: findResult.data.someClasses.edges[0].node.id,\n                id2: findResult.data.someClasses.edges[1].node.id,\n              },\n            });\n\n            expect(nodeResult.data.node1.id).toBe(\n              findResult.data.someClasses.edges[0].node.id\n            );\n            expect(nodeResult.data.node1.objectId).toBe(obj1.id);\n            expect(nodeResult.data.node1.someField).toBe('some value 1');\n            expect(nodeResult.data.node2.id).toBe(\n              findResult.data.someClasses.edges[1].node.id\n            );\n            expect(nodeResult.data.node2.objectId).toBe(obj2.id);\n            expect(nodeResult.data.node2.someField).toBe('some value 2');\n          });\n\n          it_only_db('mongo')(\n            'Id inputs should work either with global id or object id',\n            async () => {\n              try {\n                await apolloClient.mutate({\n                  mutation: gql`\n                    mutation CreateClasses {\n                      secondaryObject: createClass(\n                        input: {\n                          name: \"SecondaryObject\"\n                          schemaFields: { addStrings: [{ name: \"someField\" }] }\n                        }\n                      ) {\n                        clientMutationId\n                      }\n                      primaryObject: createClass(\n                        input: {\n                          name: \"PrimaryObject\"\n                          schemaFields: {\n                            addStrings: [{ name: \"stringField\" }]\n                            addArrays: [{ name: \"arrayField\" }]\n                            addPointers: [\n                              {\n                                name: \"pointerField\"\n                                targetClassName: \"SecondaryObject\"\n                              }\n                            ]\n                            addRelations: [\n                              {\n                                name: \"relationField\"\n                                targetClassName: \"SecondaryObject\"\n                              }\n                            ]\n                          }\n                        }\n                      ) {\n                        clientMutationId\n                      }\n                    }\n                  `,\n                  context: {\n                    headers: {\n                      'X-Parse-Master-Key': 'test',\n                    },\n                  },\n                });\n\n                await resetGraphQLCache();\n\n                const createSecondaryObjectsResult = await apolloClient.mutate({\n                  mutation: gql`\n                    mutation CreateSecondaryObjects {\n                      secondaryObject1: createSecondaryObject(\n                        input: { fields: { someField: \"some value 1\" } }\n                      ) {\n                        secondaryObject {\n                          id\n                          objectId\n                          someField\n                        }\n                      }\n                      secondaryObject2: createSecondaryObject(\n                        input: { fields: { someField: \"some value 2\" } }\n                      ) {\n                        secondaryObject {\n                          id\n                          someField\n                        }\n                      }\n                      secondaryObject3: createSecondaryObject(\n                        input: { fields: { someField: \"some value 3\" } }\n                      ) {\n                        secondaryObject {\n                          objectId\n                          someField\n                        }\n                      }\n                      secondaryObject4: createSecondaryObject(\n                        input: { fields: { someField: \"some value 4\" } }\n                      ) {\n                        secondaryObject {\n                          id\n                          objectId\n                        }\n                      }\n                      secondaryObject5: createSecondaryObject(\n                        input: { fields: { someField: \"some value 5\" } }\n                      ) {\n                        secondaryObject {\n                          id\n                        }\n                      }\n                      secondaryObject6: createSecondaryObject(\n                        input: { fields: { someField: \"some value 6\" } }\n                      ) {\n                        secondaryObject {\n                          objectId\n                        }\n                      }\n                      secondaryObject7: createSecondaryObject(\n                        input: { fields: { someField: \"some value 7\" } }\n                      ) {\n                        secondaryObject {\n                          someField\n                        }\n                      }\n                    }\n                  `,\n                  context: {\n                    headers: {\n                      'X-Parse-Master-Key': 'test',\n                    },\n                  },\n                });\n\n                const updateSecondaryObjectsResult = await apolloClient.mutate({\n                  mutation: gql`\n                    mutation UpdateSecondaryObjects(\n                      $id1: ID!\n                      $id2: ID!\n                      $id3: ID!\n                      $id4: ID!\n                      $id5: ID!\n                      $id6: ID!\n                    ) {\n                      secondaryObject1: updateSecondaryObject(\n                        input: {\n                          id: $id1\n                          fields: { someField: \"some value 11\" }\n                        }\n                      ) {\n                        secondaryObject {\n                          id\n                          objectId\n                          someField\n                        }\n                      }\n                      secondaryObject2: updateSecondaryObject(\n                        input: {\n                          id: $id2\n                          fields: { someField: \"some value 22\" }\n                        }\n                      ) {\n                        secondaryObject {\n                          id\n                          someField\n                        }\n                      }\n                      secondaryObject3: updateSecondaryObject(\n                        input: {\n                          id: $id3\n                          fields: { someField: \"some value 33\" }\n                        }\n                      ) {\n                        secondaryObject {\n                          objectId\n                          someField\n                        }\n                      }\n                      secondaryObject4: updateSecondaryObject(\n                        input: {\n                          id: $id4\n                          fields: { someField: \"some value 44\" }\n                        }\n                      ) {\n                        secondaryObject {\n                          id\n                          objectId\n                        }\n                      }\n                      secondaryObject5: updateSecondaryObject(\n                        input: {\n                          id: $id5\n                          fields: { someField: \"some value 55\" }\n                        }\n                      ) {\n                        secondaryObject {\n                          id\n                        }\n                      }\n                      secondaryObject6: updateSecondaryObject(\n                        input: {\n                          id: $id6\n                          fields: { someField: \"some value 66\" }\n                        }\n                      ) {\n                        secondaryObject {\n                          objectId\n                        }\n                      }\n                    }\n                  `,\n                  variables: {\n                    id1:\n                      createSecondaryObjectsResult.data.secondaryObject1\n                        .secondaryObject.id,\n                    id2:\n                      createSecondaryObjectsResult.data.secondaryObject2\n                        .secondaryObject.id,\n                    id3:\n                      createSecondaryObjectsResult.data.secondaryObject3\n                        .secondaryObject.objectId,\n                    id4:\n                      createSecondaryObjectsResult.data.secondaryObject4\n                        .secondaryObject.objectId,\n                    id5:\n                      createSecondaryObjectsResult.data.secondaryObject5\n                        .secondaryObject.id,\n                    id6:\n                      createSecondaryObjectsResult.data.secondaryObject6\n                        .secondaryObject.objectId,\n                  },\n                  context: {\n                    headers: {\n                      'X-Parse-Master-Key': 'test',\n                    },\n                  },\n                });\n\n                const deleteSecondaryObjectsResult = await apolloClient.mutate({\n                  mutation: gql`\n                    mutation DeleteSecondaryObjects(\n                      $id1: ID!\n                      $id3: ID!\n                      $id5: ID!\n                      $id6: ID!\n                    ) {\n                      secondaryObject1: deleteSecondaryObject(\n                        input: { id: $id1 }\n                      ) {\n                        secondaryObject {\n                          id\n                          objectId\n                          someField\n                        }\n                      }\n                      secondaryObject3: deleteSecondaryObject(\n                        input: { id: $id3 }\n                      ) {\n                        secondaryObject {\n                          objectId\n                          someField\n                        }\n                      }\n                      secondaryObject5: deleteSecondaryObject(\n                        input: { id: $id5 }\n                      ) {\n                        secondaryObject {\n                          id\n                        }\n                      }\n                      secondaryObject6: deleteSecondaryObject(\n                        input: { id: $id6 }\n                      ) {\n                        secondaryObject {\n                          objectId\n                        }\n                      }\n                    }\n                  `,\n                  variables: {\n                    id1:\n                      updateSecondaryObjectsResult.data.secondaryObject1\n                        .secondaryObject.id,\n                    id3:\n                      updateSecondaryObjectsResult.data.secondaryObject3\n                        .secondaryObject.objectId,\n                    id5:\n                      updateSecondaryObjectsResult.data.secondaryObject5\n                        .secondaryObject.id,\n                    id6:\n                      updateSecondaryObjectsResult.data.secondaryObject6\n                        .secondaryObject.objectId,\n                  },\n                  context: {\n                    headers: {\n                      'X-Parse-Master-Key': 'test',\n                    },\n                  },\n                });\n\n                const getSecondaryObjectsResult = await apolloClient.query({\n                  query: gql`\n                    query GetSecondaryObjects($id2: ID!, $id4: ID!) {\n                      secondaryObject2: secondaryObject(id: $id2) {\n                        id\n                        objectId\n                        someField\n                      }\n                      secondaryObject4: secondaryObject(id: $id4) {\n                        objectId\n                        someField\n                      }\n                    }\n                  `,\n                  variables: {\n                    id2:\n                      updateSecondaryObjectsResult.data.secondaryObject2\n                        .secondaryObject.id,\n                    id4:\n                      updateSecondaryObjectsResult.data.secondaryObject4\n                        .secondaryObject.objectId,\n                  },\n                  context: {\n                    headers: {\n                      'X-Parse-Master-Key': 'test',\n                    },\n                  },\n                });\n\n                const findSecondaryObjectsResult = await apolloClient.query({\n                  query: gql`\n                    query FindSecondaryObjects(\n                      $id1: ID!\n                      $id2: ID!\n                      $id3: ID!\n                      $id4: ID!\n                      $id5: ID!\n                      $id6: ID!\n                    ) {\n                      secondaryObjects(\n                        where: {\n                          AND: [\n                            {\n                              OR: [\n                                { id: { equalTo: $id2 } }\n                                {\n                                  AND: [\n                                    { id: { equalTo: $id4 } }\n                                    { objectId: { equalTo: $id4 } }\n                                  ]\n                                }\n                              ]\n                            }\n                            { id: { notEqualTo: $id1 } }\n                            { id: { notEqualTo: $id3 } }\n                            { objectId: { notEqualTo: $id2 } }\n                            { objectId: { notIn: [$id5, $id6] } }\n                            { id: { in: [$id2, $id4] } }\n                          ]\n                        }\n                        order: [id_ASC, objectId_ASC]\n                      ) {\n                        edges {\n                          node {\n                            id\n                            objectId\n                            someField\n                          }\n                        }\n                        count\n                      }\n                    }\n                  `,\n                  variables: {\n                    id1:\n                      deleteSecondaryObjectsResult.data.secondaryObject1\n                        .secondaryObject.objectId,\n                    id2: getSecondaryObjectsResult.data.secondaryObject2.id,\n                    id3:\n                      deleteSecondaryObjectsResult.data.secondaryObject3\n                        .secondaryObject.objectId,\n                    id4:\n                      getSecondaryObjectsResult.data.secondaryObject4.objectId,\n                    id5:\n                      deleteSecondaryObjectsResult.data.secondaryObject5\n                        .secondaryObject.id,\n                    id6:\n                      deleteSecondaryObjectsResult.data.secondaryObject6\n                        .secondaryObject.objectId,\n                  },\n                  context: {\n                    headers: {\n                      'X-Parse-Master-Key': 'test',\n                    },\n                  },\n                });\n\n                expect(\n                  findSecondaryObjectsResult.data.secondaryObjects.count\n                ).toEqual(2);\n                expect(\n                  findSecondaryObjectsResult.data.secondaryObjects.edges\n                    .map(value => value.node.someField)\n                    .sort()\n                ).toEqual(['some value 22', 'some value 44']);\n                expect(\n                  findSecondaryObjectsResult.data.secondaryObjects.edges[0].node\n                    .id\n                ).toBeLessThan(\n                  findSecondaryObjectsResult.data.secondaryObjects.edges[1].node\n                    .id\n                );\n                expect(\n                  findSecondaryObjectsResult.data.secondaryObjects.edges[0].node\n                    .objectId\n                ).toBeLessThan(\n                  findSecondaryObjectsResult.data.secondaryObjects.edges[1].node\n                    .objectId\n                );\n\n                const createPrimaryObjectResult = await apolloClient.mutate({\n                  mutation: gql`\n                    mutation CreatePrimaryObject(\n                      $pointer: Any\n                      $secondaryObject2: ID!\n                      $secondaryObject4: ID!\n                    ) {\n                      createPrimaryObject(\n                        input: {\n                          fields: {\n                            stringField: \"some value\"\n                            arrayField: [1, \"abc\", $pointer]\n                            pointerField: { link: $secondaryObject2 }\n                            relationField: {\n                              add: [$secondaryObject2, $secondaryObject4]\n                            }\n                          }\n                        }\n                      ) {\n                        primaryObject {\n                          id\n                          stringField\n                          arrayField {\n                            ... on Element {\n                              value\n                            }\n                            ... on SecondaryObject {\n                              someField\n                            }\n                          }\n                          pointerField {\n                            id\n                            objectId\n                            someField\n                          }\n                          relationField {\n                            edges {\n                              node {\n                                id\n                                objectId\n                                someField\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  `,\n                  variables: {\n                    pointer: {\n                      __type: 'Pointer',\n                      className: 'SecondaryObject',\n                      objectId:\n                        getSecondaryObjectsResult.data.secondaryObject4\n                          .objectId,\n                    },\n                    secondaryObject2:\n                      getSecondaryObjectsResult.data.secondaryObject2.id,\n                    secondaryObject4:\n                      getSecondaryObjectsResult.data.secondaryObject4.objectId,\n                  },\n                  context: {\n                    headers: {\n                      'X-Parse-Master-Key': 'test',\n                    },\n                  },\n                });\n\n                const updatePrimaryObjectResult = await apolloClient.mutate({\n                  mutation: gql`\n                    mutation UpdatePrimaryObject(\n                      $id: ID!\n                      $secondaryObject2: ID!\n                      $secondaryObject4: ID!\n                    ) {\n                      updatePrimaryObject(\n                        input: {\n                          id: $id\n                          fields: {\n                            pointerField: { link: $secondaryObject4 }\n                            relationField: {\n                              remove: [$secondaryObject2, $secondaryObject4]\n                            }\n                          }\n                        }\n                      ) {\n                        primaryObject {\n                          id\n                          stringField\n                          arrayField {\n                            ... on Element {\n                              value\n                            }\n                            ... on SecondaryObject {\n                              someField\n                            }\n                          }\n                          pointerField {\n                            id\n                            objectId\n                            someField\n                          }\n                          relationField {\n                            edges {\n                              node {\n                                id\n                                objectId\n                                someField\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  `,\n                  variables: {\n                    id:\n                      createPrimaryObjectResult.data.createPrimaryObject\n                        .primaryObject.id,\n                    secondaryObject2:\n                      getSecondaryObjectsResult.data.secondaryObject2.id,\n                    secondaryObject4:\n                      getSecondaryObjectsResult.data.secondaryObject4.objectId,\n                  },\n                  context: {\n                    headers: {\n                      'X-Parse-Master-Key': 'test',\n                    },\n                  },\n                });\n\n                expect(\n                  createPrimaryObjectResult.data.createPrimaryObject\n                    .primaryObject.stringField\n                ).toEqual('some value');\n                expect(\n                  createPrimaryObjectResult.data.createPrimaryObject\n                    .primaryObject.arrayField\n                ).toEqual([\n                  { __typename: 'Element', value: 1 },\n                  { __typename: 'Element', value: 'abc' },\n                  { __typename: 'SecondaryObject', someField: 'some value 44' },\n                ]);\n                expect(\n                  createPrimaryObjectResult.data.createPrimaryObject\n                    .primaryObject.pointerField.someField\n                ).toEqual('some value 22');\n                expect(\n                  createPrimaryObjectResult.data.createPrimaryObject.primaryObject.relationField.edges\n                    .map(value => value.node.someField)\n                    .sort()\n                ).toEqual(['some value 22', 'some value 44']);\n                expect(\n                  updatePrimaryObjectResult.data.updatePrimaryObject\n                    .primaryObject.stringField\n                ).toEqual('some value');\n                expect(\n                  updatePrimaryObjectResult.data.updatePrimaryObject\n                    .primaryObject.arrayField\n                ).toEqual([\n                  { __typename: 'Element', value: 1 },\n                  { __typename: 'Element', value: 'abc' },\n                  { __typename: 'SecondaryObject', someField: 'some value 44' },\n                ]);\n                expect(\n                  updatePrimaryObjectResult.data.updatePrimaryObject\n                    .primaryObject.pointerField.someField\n                ).toEqual('some value 44');\n                expect(\n                  updatePrimaryObjectResult.data.updatePrimaryObject\n                    .primaryObject.relationField.edges\n                ).toEqual([]);\n              } catch (e) {\n                handleError(e);\n              }\n            }\n          );\n        });\n      });\n\n      describe('Class Schema Mutations', () => {\n        it('should create a new class', async () => {\n          try {\n            const result = await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  class1: createClass(\n                    input: { name: \"Class1\", clientMutationId: \"cmid1\" }\n                  ) {\n                    clientMutationId\n                    class {\n                      name\n                      schemaFields {\n                        name\n                        __typename\n                      }\n                    }\n                  }\n                  class2: createClass(\n                    input: {\n                      name: \"Class2\"\n                      schemaFields: null\n                      clientMutationId: \"cmid2\"\n                    }\n                  ) {\n                    clientMutationId\n                    class {\n                      name\n                      schemaFields {\n                        name\n                        __typename\n                      }\n                    }\n                  }\n                  class3: createClass(\n                    input: {\n                      name: \"Class3\"\n                      schemaFields: {}\n                      clientMutationId: \"cmid3\"\n                    }\n                  ) {\n                    clientMutationId\n                    class {\n                      name\n                      schemaFields {\n                        name\n                        __typename\n                      }\n                    }\n                  }\n                  class4: createClass(\n                    input: {\n                      name: \"Class4\"\n                      schemaFields: {\n                        addStrings: null\n                        addNumbers: null\n                        addBooleans: null\n                        addArrays: null\n                        addObjects: null\n                        addDates: null\n                        addFiles: null\n                        addGeoPoint: null\n                        addPolygons: null\n                        addBytes: null\n                        addPointers: null\n                        addRelations: null\n                      }\n                      clientMutationId: \"cmid4\"\n                    }\n                  ) {\n                    clientMutationId\n                    class {\n                      name\n                      schemaFields {\n                        name\n                        __typename\n                      }\n                    }\n                  }\n                  class5: createClass(\n                    input: {\n                      name: \"Class5\"\n                      schemaFields: {\n                        addStrings: []\n                        addNumbers: []\n                        addBooleans: []\n                        addArrays: []\n                        addObjects: []\n                        addDates: []\n                        addFiles: []\n                        addPolygons: []\n                        addBytes: []\n                        addPointers: []\n                        addRelations: []\n                      }\n                      clientMutationId: \"cmid5\"\n                    }\n                  ) {\n                    clientMutationId\n                    class {\n                      name\n                      schemaFields {\n                        name\n                        __typename\n                      }\n                    }\n                  }\n                  class6: createClass(\n                    input: {\n                      name: \"Class6\"\n                      schemaFields: {\n                        addStrings: [\n                          { name: \"stringField1\" }\n                          { name: \"stringField2\" }\n                          { name: \"stringField3\" }\n                        ]\n                        addNumbers: [\n                          { name: \"numberField1\" }\n                          { name: \"numberField2\" }\n                          { name: \"numberField3\" }\n                        ]\n                        addBooleans: [\n                          { name: \"booleanField1\" }\n                          { name: \"booleanField2\" }\n                          { name: \"booleanField3\" }\n                        ]\n                        addArrays: [\n                          { name: \"arrayField1\" }\n                          { name: \"arrayField2\" }\n                          { name: \"arrayField3\" }\n                        ]\n                        addObjects: [\n                          { name: \"objectField1\" }\n                          { name: \"objectField2\" }\n                          { name: \"objectField3\" }\n                        ]\n                        addDates: [\n                          { name: \"dateField1\" }\n                          { name: \"dateField2\" }\n                          { name: \"dateField3\" }\n                        ]\n                        addFiles: [\n                          { name: \"fileField1\" }\n                          { name: \"fileField2\" }\n                          { name: \"fileField3\" }\n                        ]\n                        addGeoPoint: { name: \"geoPointField\" }\n                        addPolygons: [\n                          { name: \"polygonField1\" }\n                          { name: \"polygonField2\" }\n                          { name: \"polygonField3\" }\n                        ]\n                        addBytes: [\n                          { name: \"bytesField1\" }\n                          { name: \"bytesField2\" }\n                          { name: \"bytesField3\" }\n                        ]\n                        addPointers: [\n                          { name: \"pointerField1\", targetClassName: \"Class1\" }\n                          { name: \"pointerField2\", targetClassName: \"Class6\" }\n                          { name: \"pointerField3\", targetClassName: \"Class2\" }\n                        ]\n                        addRelations: [\n                          { name: \"relationField1\", targetClassName: \"Class1\" }\n                          { name: \"relationField2\", targetClassName: \"Class6\" }\n                          { name: \"relationField3\", targetClassName: \"Class2\" }\n                        ]\n                        remove: [\n                          { name: \"stringField3\" }\n                          { name: \"numberField3\" }\n                          { name: \"booleanField3\" }\n                          { name: \"arrayField3\" }\n                          { name: \"objectField3\" }\n                          { name: \"dateField3\" }\n                          { name: \"fileField3\" }\n                          { name: \"polygonField3\" }\n                          { name: \"bytesField3\" }\n                          { name: \"pointerField3\" }\n                          { name: \"relationField3\" }\n                          { name: \"doesNotExist\" }\n                        ]\n                      }\n                      clientMutationId: \"cmid6\"\n                    }\n                  ) {\n                    clientMutationId\n                    class {\n                      name\n                      schemaFields {\n                        name\n                        __typename\n                        ... on SchemaPointerField {\n                          targetClassName\n                        }\n                        ... on SchemaRelationField {\n                          targetClassName\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n            const classes = Object.keys(result.data).map(fieldName => ({\n              clientMutationId: result.data[fieldName].clientMutationId,\n              class: {\n                name: result.data[fieldName].class.name,\n                schemaFields: result.data[\n                  fieldName\n                ].class.schemaFields.sort((a, b) => (a.name > b.name ? 1 : -1)),\n                __typename: result.data[fieldName].class.__typename,\n              },\n              __typename: result.data[fieldName].__typename,\n            }));\n            expect(classes).toEqual([\n              {\n                clientMutationId: 'cmid1',\n                class: {\n                  name: 'Class1',\n                  schemaFields: [\n                    { name: 'ACL', __typename: 'SchemaACLField' },\n                    { name: 'createdAt', __typename: 'SchemaDateField' },\n                    { name: 'objectId', __typename: 'SchemaStringField' },\n                    { name: 'updatedAt', __typename: 'SchemaDateField' },\n                  ],\n                  __typename: 'Class',\n                },\n                __typename: 'CreateClassPayload',\n              },\n              {\n                clientMutationId: 'cmid2',\n                class: {\n                  name: 'Class2',\n                  schemaFields: [\n                    { name: 'ACL', __typename: 'SchemaACLField' },\n                    { name: 'createdAt', __typename: 'SchemaDateField' },\n                    { name: 'objectId', __typename: 'SchemaStringField' },\n                    { name: 'updatedAt', __typename: 'SchemaDateField' },\n                  ],\n                  __typename: 'Class',\n                },\n                __typename: 'CreateClassPayload',\n              },\n              {\n                clientMutationId: 'cmid3',\n                class: {\n                  name: 'Class3',\n                  schemaFields: [\n                    { name: 'ACL', __typename: 'SchemaACLField' },\n                    { name: 'createdAt', __typename: 'SchemaDateField' },\n                    { name: 'objectId', __typename: 'SchemaStringField' },\n                    { name: 'updatedAt', __typename: 'SchemaDateField' },\n                  ],\n                  __typename: 'Class',\n                },\n                __typename: 'CreateClassPayload',\n              },\n              {\n                clientMutationId: 'cmid4',\n                class: {\n                  name: 'Class4',\n                  schemaFields: [\n                    { name: 'ACL', __typename: 'SchemaACLField' },\n                    { name: 'createdAt', __typename: 'SchemaDateField' },\n                    { name: 'objectId', __typename: 'SchemaStringField' },\n                    { name: 'updatedAt', __typename: 'SchemaDateField' },\n                  ],\n                  __typename: 'Class',\n                },\n                __typename: 'CreateClassPayload',\n              },\n              {\n                clientMutationId: 'cmid5',\n                class: {\n                  name: 'Class5',\n                  schemaFields: [\n                    { name: 'ACL', __typename: 'SchemaACLField' },\n                    { name: 'createdAt', __typename: 'SchemaDateField' },\n                    { name: 'objectId', __typename: 'SchemaStringField' },\n                    { name: 'updatedAt', __typename: 'SchemaDateField' },\n                  ],\n                  __typename: 'Class',\n                },\n                __typename: 'CreateClassPayload',\n              },\n              {\n                clientMutationId: 'cmid6',\n                class: {\n                  name: 'Class6',\n                  schemaFields: [\n                    { name: 'ACL', __typename: 'SchemaACLField' },\n                    { name: 'arrayField1', __typename: 'SchemaArrayField' },\n                    { name: 'arrayField2', __typename: 'SchemaArrayField' },\n                    { name: 'booleanField1', __typename: 'SchemaBooleanField' },\n                    { name: 'booleanField2', __typename: 'SchemaBooleanField' },\n                    { name: 'bytesField1', __typename: 'SchemaBytesField' },\n                    { name: 'bytesField2', __typename: 'SchemaBytesField' },\n                    { name: 'createdAt', __typename: 'SchemaDateField' },\n                    { name: 'dateField1', __typename: 'SchemaDateField' },\n                    { name: 'dateField2', __typename: 'SchemaDateField' },\n                    { name: 'fileField1', __typename: 'SchemaFileField' },\n                    { name: 'fileField2', __typename: 'SchemaFileField' },\n                    {\n                      name: 'geoPointField',\n                      __typename: 'SchemaGeoPointField',\n                    },\n                    { name: 'numberField1', __typename: 'SchemaNumberField' },\n                    { name: 'numberField2', __typename: 'SchemaNumberField' },\n                    { name: 'objectField1', __typename: 'SchemaObjectField' },\n                    { name: 'objectField2', __typename: 'SchemaObjectField' },\n                    { name: 'objectId', __typename: 'SchemaStringField' },\n                    {\n                      name: 'pointerField1',\n                      __typename: 'SchemaPointerField',\n                      targetClassName: 'Class1',\n                    },\n                    {\n                      name: 'pointerField2',\n                      __typename: 'SchemaPointerField',\n                      targetClassName: 'Class6',\n                    },\n                    { name: 'polygonField1', __typename: 'SchemaPolygonField' },\n                    { name: 'polygonField2', __typename: 'SchemaPolygonField' },\n                    {\n                      name: 'relationField1',\n                      __typename: 'SchemaRelationField',\n                      targetClassName: 'Class1',\n                    },\n                    {\n                      name: 'relationField2',\n                      __typename: 'SchemaRelationField',\n                      targetClassName: 'Class6',\n                    },\n                    { name: 'stringField1', __typename: 'SchemaStringField' },\n                    { name: 'stringField2', __typename: 'SchemaStringField' },\n                    { name: 'updatedAt', __typename: 'SchemaDateField' },\n                  ],\n                  __typename: 'Class',\n                },\n                __typename: 'CreateClassPayload',\n              },\n            ]);\n\n            const findResult = await apolloClient.query({\n              query: gql`\n                query {\n                  classes {\n                    name\n                    schemaFields {\n                      name\n                      __typename\n                      ... on SchemaPointerField {\n                        targetClassName\n                      }\n                      ... on SchemaRelationField {\n                        targetClassName\n                      }\n                    }\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n            findResult.data.classes = findResult.data.classes\n              .filter(schemaClass => !schemaClass.name.startsWith('_'))\n              .sort((a, b) => (a.name > b.name ? 1 : -1));\n            findResult.data.classes.forEach(schemaClass => {\n              schemaClass.schemaFields = schemaClass.schemaFields.sort((a, b) =>\n                a.name > b.name ? 1 : -1\n              );\n            });\n            expect(findResult.data.classes).toEqual([\n              {\n                name: 'Class1',\n                schemaFields: [\n                  { name: 'ACL', __typename: 'SchemaACLField' },\n                  { name: 'createdAt', __typename: 'SchemaDateField' },\n                  { name: 'objectId', __typename: 'SchemaStringField' },\n                  { name: 'updatedAt', __typename: 'SchemaDateField' },\n                ],\n                __typename: 'Class',\n              },\n              {\n                name: 'Class2',\n                schemaFields: [\n                  { name: 'ACL', __typename: 'SchemaACLField' },\n                  { name: 'createdAt', __typename: 'SchemaDateField' },\n                  { name: 'objectId', __typename: 'SchemaStringField' },\n                  { name: 'updatedAt', __typename: 'SchemaDateField' },\n                ],\n                __typename: 'Class',\n              },\n              {\n                name: 'Class3',\n                schemaFields: [\n                  { name: 'ACL', __typename: 'SchemaACLField' },\n                  { name: 'createdAt', __typename: 'SchemaDateField' },\n                  { name: 'objectId', __typename: 'SchemaStringField' },\n                  { name: 'updatedAt', __typename: 'SchemaDateField' },\n                ],\n                __typename: 'Class',\n              },\n              {\n                name: 'Class4',\n                schemaFields: [\n                  { name: 'ACL', __typename: 'SchemaACLField' },\n                  { name: 'createdAt', __typename: 'SchemaDateField' },\n                  { name: 'objectId', __typename: 'SchemaStringField' },\n                  { name: 'updatedAt', __typename: 'SchemaDateField' },\n                ],\n                __typename: 'Class',\n              },\n              {\n                name: 'Class5',\n                schemaFields: [\n                  { name: 'ACL', __typename: 'SchemaACLField' },\n                  { name: 'createdAt', __typename: 'SchemaDateField' },\n                  { name: 'objectId', __typename: 'SchemaStringField' },\n                  { name: 'updatedAt', __typename: 'SchemaDateField' },\n                ],\n                __typename: 'Class',\n              },\n              {\n                name: 'Class6',\n                schemaFields: [\n                  { name: 'ACL', __typename: 'SchemaACLField' },\n                  { name: 'arrayField1', __typename: 'SchemaArrayField' },\n                  { name: 'arrayField2', __typename: 'SchemaArrayField' },\n                  { name: 'booleanField1', __typename: 'SchemaBooleanField' },\n                  { name: 'booleanField2', __typename: 'SchemaBooleanField' },\n                  { name: 'bytesField1', __typename: 'SchemaBytesField' },\n                  { name: 'bytesField2', __typename: 'SchemaBytesField' },\n                  { name: 'createdAt', __typename: 'SchemaDateField' },\n                  { name: 'dateField1', __typename: 'SchemaDateField' },\n                  { name: 'dateField2', __typename: 'SchemaDateField' },\n                  { name: 'fileField1', __typename: 'SchemaFileField' },\n                  { name: 'fileField2', __typename: 'SchemaFileField' },\n                  {\n                    name: 'geoPointField',\n                    __typename: 'SchemaGeoPointField',\n                  },\n                  { name: 'numberField1', __typename: 'SchemaNumberField' },\n                  { name: 'numberField2', __typename: 'SchemaNumberField' },\n                  { name: 'objectField1', __typename: 'SchemaObjectField' },\n                  { name: 'objectField2', __typename: 'SchemaObjectField' },\n                  { name: 'objectId', __typename: 'SchemaStringField' },\n                  {\n                    name: 'pointerField1',\n                    __typename: 'SchemaPointerField',\n                    targetClassName: 'Class1',\n                  },\n                  {\n                    name: 'pointerField2',\n                    __typename: 'SchemaPointerField',\n                    targetClassName: 'Class6',\n                  },\n                  { name: 'polygonField1', __typename: 'SchemaPolygonField' },\n                  { name: 'polygonField2', __typename: 'SchemaPolygonField' },\n                  {\n                    name: 'relationField1',\n                    __typename: 'SchemaRelationField',\n                    targetClassName: 'Class1',\n                  },\n                  {\n                    name: 'relationField2',\n                    __typename: 'SchemaRelationField',\n                    targetClassName: 'Class6',\n                  },\n                  { name: 'stringField1', __typename: 'SchemaStringField' },\n                  { name: 'stringField2', __typename: 'SchemaStringField' },\n                  { name: 'updatedAt', __typename: 'SchemaDateField' },\n                ],\n                __typename: 'Class',\n              },\n            ]);\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should require master key to create a new class', async () => {\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  createClass(input: { name: \"SomeClass\" }) {\n                    clientMutationId\n                  }\n                }\n              `,\n            });\n            fail('should fail');\n          } catch (e) {\n            expect(e.graphQLErrors[0].extensions.code).toEqual(\n              Parse.Error.OPERATION_FORBIDDEN\n            );\n            expect(e.graphQLErrors[0].message).toEqual(\n              'unauthorized: master key is required'\n            );\n          }\n        });\n\n        it('should not allow duplicated field names when creating', async () => {\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  createClass(\n                    input: {\n                      name: \"SomeClass\"\n                      schemaFields: {\n                        addStrings: [{ name: \"someField\" }]\n                        addNumbers: [{ name: \"someField\" }]\n                      }\n                    }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n            fail('should fail');\n          } catch (e) {\n            expect(e.graphQLErrors[0].extensions.code).toEqual(\n              Parse.Error.INVALID_KEY_NAME\n            );\n            expect(e.graphQLErrors[0].message).toEqual(\n              'Duplicated field name: someField'\n            );\n          }\n        });\n\n        it('should update an existing class', async () => {\n          try {\n            const clientMutationId = uuidv4();\n            const result = await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  createClass(\n                    input: {\n                      name: \"MyNewClass\"\n                      schemaFields: { addStrings: [{ name: \"willBeRemoved\" }] }\n                    }\n                  ) {\n                    class {\n                      name\n                      schemaFields {\n                        name\n                        __typename\n                      }\n                    }\n                  }\n                  updateClass(input: {\n                    clientMutationId: \"${clientMutationId}\"\n                    name: \"MyNewClass\"\n                    schemaFields: {\n                      addStrings: [\n                        { name: \"stringField1\" }\n                        { name: \"stringField2\" }\n                        { name: \"stringField3\" }\n                      ]\n                      addNumbers: [\n                        { name: \"numberField1\" }\n                        { name: \"numberField2\" }\n                        { name: \"numberField3\" }\n                      ]\n                      addBooleans: [\n                        { name: \"booleanField1\" }\n                        { name: \"booleanField2\" }\n                        { name: \"booleanField3\" }\n                      ]\n                      addArrays: [\n                        { name: \"arrayField1\" }\n                        { name: \"arrayField2\" }\n                        { name: \"arrayField3\" }\n                      ]\n                      addObjects: [\n                        { name: \"objectField1\" }\n                        { name: \"objectField2\" }\n                        { name: \"objectField3\" }\n                      ]\n                      addDates: [\n                        { name: \"dateField1\" }\n                        { name: \"dateField2\" }\n                        { name: \"dateField3\" }\n                      ]\n                      addFiles: [\n                        { name: \"fileField1\" }\n                        { name: \"fileField2\" }\n                        { name: \"fileField3\" }\n                      ]\n                      addGeoPoint: { name: \"geoPointField\" }\n                      addPolygons: [\n                        { name: \"polygonField1\" }\n                        { name: \"polygonField2\" }\n                        { name: \"polygonField3\" }\n                      ]\n                      addBytes: [\n                        { name: \"bytesField1\" }\n                        { name: \"bytesField2\" }\n                        { name: \"bytesField3\" }\n                      ]\n                      addPointers: [\n                        { name: \"pointerField1\", targetClassName: \"Class1\" }\n                        { name: \"pointerField2\", targetClassName: \"Class6\" }\n                        { name: \"pointerField3\", targetClassName: \"Class2\" }\n                      ]\n                      addRelations: [\n                        { name: \"relationField1\", targetClassName: \"Class1\" }\n                        { name: \"relationField2\", targetClassName: \"Class6\" }\n                        { name: \"relationField3\", targetClassName: \"Class2\" }\n                      ]\n                      remove: [\n                        { name: \"willBeRemoved\" }\n                        { name: \"stringField3\" }\n                        { name: \"numberField3\" }\n                        { name: \"booleanField3\" }\n                        { name: \"arrayField3\" }\n                        { name: \"objectField3\" }\n                        { name: \"dateField3\" }\n                        { name: \"fileField3\" }\n                        { name: \"polygonField3\" }\n                        { name: \"bytesField3\" }\n                        { name: \"pointerField3\" }\n                        { name: \"relationField3\" }\n                        { name: \"doesNotExist\" }\n                      ]\n                    }\n                  }) {\n                    clientMutationId\n                    class {\n                      name\n                      schemaFields {\n                        name\n                        __typename\n                        ... on SchemaPointerField {\n                          targetClassName\n                        }\n                        ... on SchemaRelationField {\n                          targetClassName\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n            result.data.createClass.class.schemaFields = result.data.createClass.class.schemaFields.sort(\n              (a, b) => (a.name > b.name ? 1 : -1)\n            );\n            result.data.updateClass.class.schemaFields = result.data.updateClass.class.schemaFields.sort(\n              (a, b) => (a.name > b.name ? 1 : -1)\n            );\n            expect(result).toEqual({\n              data: {\n                createClass: {\n                  class: {\n                    name: 'MyNewClass',\n                    schemaFields: [\n                      { name: 'ACL', __typename: 'SchemaACLField' },\n                      { name: 'createdAt', __typename: 'SchemaDateField' },\n                      { name: 'objectId', __typename: 'SchemaStringField' },\n                      { name: 'updatedAt', __typename: 'SchemaDateField' },\n                      {\n                        name: 'willBeRemoved',\n                        __typename: 'SchemaStringField',\n                      },\n                    ],\n                    __typename: 'Class',\n                  },\n                  __typename: 'CreateClassPayload',\n                },\n                updateClass: {\n                  clientMutationId,\n                  class: {\n                    name: 'MyNewClass',\n                    schemaFields: [\n                      { name: 'ACL', __typename: 'SchemaACLField' },\n                      { name: 'arrayField1', __typename: 'SchemaArrayField' },\n                      { name: 'arrayField2', __typename: 'SchemaArrayField' },\n                      {\n                        name: 'booleanField1',\n                        __typename: 'SchemaBooleanField',\n                      },\n                      {\n                        name: 'booleanField2',\n                        __typename: 'SchemaBooleanField',\n                      },\n                      { name: 'bytesField1', __typename: 'SchemaBytesField' },\n                      { name: 'bytesField2', __typename: 'SchemaBytesField' },\n                      { name: 'createdAt', __typename: 'SchemaDateField' },\n                      { name: 'dateField1', __typename: 'SchemaDateField' },\n                      { name: 'dateField2', __typename: 'SchemaDateField' },\n                      { name: 'fileField1', __typename: 'SchemaFileField' },\n                      { name: 'fileField2', __typename: 'SchemaFileField' },\n                      {\n                        name: 'geoPointField',\n                        __typename: 'SchemaGeoPointField',\n                      },\n                      { name: 'numberField1', __typename: 'SchemaNumberField' },\n                      { name: 'numberField2', __typename: 'SchemaNumberField' },\n                      { name: 'objectField1', __typename: 'SchemaObjectField' },\n                      { name: 'objectField2', __typename: 'SchemaObjectField' },\n                      { name: 'objectId', __typename: 'SchemaStringField' },\n                      {\n                        name: 'pointerField1',\n                        __typename: 'SchemaPointerField',\n                        targetClassName: 'Class1',\n                      },\n                      {\n                        name: 'pointerField2',\n                        __typename: 'SchemaPointerField',\n                        targetClassName: 'Class6',\n                      },\n                      {\n                        name: 'polygonField1',\n                        __typename: 'SchemaPolygonField',\n                      },\n                      {\n                        name: 'polygonField2',\n                        __typename: 'SchemaPolygonField',\n                      },\n                      {\n                        name: 'relationField1',\n                        __typename: 'SchemaRelationField',\n                        targetClassName: 'Class1',\n                      },\n                      {\n                        name: 'relationField2',\n                        __typename: 'SchemaRelationField',\n                        targetClassName: 'Class6',\n                      },\n                      { name: 'stringField1', __typename: 'SchemaStringField' },\n                      { name: 'stringField2', __typename: 'SchemaStringField' },\n                      { name: 'updatedAt', __typename: 'SchemaDateField' },\n                    ],\n                    __typename: 'Class',\n                  },\n                  __typename: 'UpdateClassPayload',\n                },\n              },\n            });\n\n            const getResult = await apolloClient.query({\n              query: gql`\n                query {\n                  class(name: \"MyNewClass\") {\n                    name\n                    schemaFields {\n                      name\n                      __typename\n                      ... on SchemaPointerField {\n                        targetClassName\n                      }\n                      ... on SchemaRelationField {\n                        targetClassName\n                      }\n                    }\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n            getResult.data.class.schemaFields = getResult.data.class.schemaFields.sort(\n              (a, b) => (a.name > b.name ? 1 : -1)\n            );\n            expect(getResult.data).toEqual({\n              class: {\n                name: 'MyNewClass',\n                schemaFields: [\n                  { name: 'ACL', __typename: 'SchemaACLField' },\n                  { name: 'arrayField1', __typename: 'SchemaArrayField' },\n                  { name: 'arrayField2', __typename: 'SchemaArrayField' },\n                  { name: 'booleanField1', __typename: 'SchemaBooleanField' },\n                  { name: 'booleanField2', __typename: 'SchemaBooleanField' },\n                  { name: 'bytesField1', __typename: 'SchemaBytesField' },\n                  { name: 'bytesField2', __typename: 'SchemaBytesField' },\n                  { name: 'createdAt', __typename: 'SchemaDateField' },\n                  { name: 'dateField1', __typename: 'SchemaDateField' },\n                  { name: 'dateField2', __typename: 'SchemaDateField' },\n                  { name: 'fileField1', __typename: 'SchemaFileField' },\n                  { name: 'fileField2', __typename: 'SchemaFileField' },\n                  {\n                    name: 'geoPointField',\n                    __typename: 'SchemaGeoPointField',\n                  },\n                  { name: 'numberField1', __typename: 'SchemaNumberField' },\n                  { name: 'numberField2', __typename: 'SchemaNumberField' },\n                  { name: 'objectField1', __typename: 'SchemaObjectField' },\n                  { name: 'objectField2', __typename: 'SchemaObjectField' },\n                  { name: 'objectId', __typename: 'SchemaStringField' },\n                  {\n                    name: 'pointerField1',\n                    __typename: 'SchemaPointerField',\n                    targetClassName: 'Class1',\n                  },\n                  {\n                    name: 'pointerField2',\n                    __typename: 'SchemaPointerField',\n                    targetClassName: 'Class6',\n                  },\n                  { name: 'polygonField1', __typename: 'SchemaPolygonField' },\n                  { name: 'polygonField2', __typename: 'SchemaPolygonField' },\n                  {\n                    name: 'relationField1',\n                    __typename: 'SchemaRelationField',\n                    targetClassName: 'Class1',\n                  },\n                  {\n                    name: 'relationField2',\n                    __typename: 'SchemaRelationField',\n                    targetClassName: 'Class6',\n                  },\n                  { name: 'stringField1', __typename: 'SchemaStringField' },\n                  { name: 'stringField2', __typename: 'SchemaStringField' },\n                  { name: 'updatedAt', __typename: 'SchemaDateField' },\n                ],\n                __typename: 'Class',\n              },\n            });\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should require master key to update an existing class', async () => {\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  createClass(input: { name: \"SomeClass\" }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n          } catch (e) {\n            handleError(e);\n          }\n\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  updateClass(input: { name: \"SomeClass\" }) {\n                    clientMutationId\n                  }\n                }\n              `,\n            });\n            fail('should fail');\n          } catch (e) {\n            expect(e.graphQLErrors[0].extensions.code).toEqual(\n              Parse.Error.OPERATION_FORBIDDEN\n            );\n            expect(e.graphQLErrors[0].message).toEqual(\n              'unauthorized: master key is required'\n            );\n          }\n        });\n\n        it('should not allow duplicated field names when updating', async () => {\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  createClass(\n                    input: {\n                      name: \"SomeClass\"\n                      schemaFields: { addStrings: [{ name: \"someField\" }] }\n                    }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n          } catch (e) {\n            handleError(e);\n          }\n\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  updateClass(\n                    input: {\n                      name: \"SomeClass\"\n                      schemaFields: { addNumbers: [{ name: \"someField\" }] }\n                    }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n            fail('should fail');\n          } catch (e) {\n            expect(e.graphQLErrors[0].extensions.code).toEqual(\n              Parse.Error.INVALID_KEY_NAME\n            );\n            expect(e.graphQLErrors[0].message).toEqual(\n              'Duplicated field name: someField'\n            );\n          }\n        });\n\n        it('should fail if updating an inexistent class', async () => {\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  updateClass(\n                    input: {\n                      name: \"SomeInexistentClass\"\n                      schemaFields: { addNumbers: [{ name: \"someField\" }] }\n                    }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n            fail('should fail');\n          } catch (e) {\n            expect(e.graphQLErrors[0].extensions.code).toEqual(\n              Parse.Error.INVALID_CLASS_NAME\n            );\n            expect(e.graphQLErrors[0].message).toEqual(\n              'Class SomeInexistentClass does not exist.'\n            );\n          }\n        });\n\n        it('should delete an existing class', async () => {\n          try {\n            const clientMutationId = uuidv4();\n            const result = await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  createClass(\n                    input: {\n                      name: \"MyNewClass\"\n                      schemaFields: { addStrings: [{ name: \"willBeRemoved\" }] }\n                    }\n                  ) {\n                    class {\n                      name\n                      schemaFields {\n                        name\n                        __typename\n                      }\n                    }\n                  }\n                  deleteClass(input: { clientMutationId: \"${clientMutationId}\" name: \"MyNewClass\" }) {\n                    clientMutationId\n                    class {\n                      name\n                      schemaFields {\n                        name\n                      }\n                    }\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n            result.data.createClass.class.schemaFields = result.data.createClass.class.schemaFields.sort(\n              (a, b) => (a.name > b.name ? 1 : -1)\n            );\n            result.data.deleteClass.class.schemaFields = result.data.deleteClass.class.schemaFields.sort(\n              (a, b) => (a.name > b.name ? 1 : -1)\n            );\n            expect(result).toEqual({\n              data: {\n                createClass: {\n                  class: {\n                    name: 'MyNewClass',\n                    schemaFields: [\n                      { name: 'ACL', __typename: 'SchemaACLField' },\n                      { name: 'createdAt', __typename: 'SchemaDateField' },\n                      { name: 'objectId', __typename: 'SchemaStringField' },\n                      { name: 'updatedAt', __typename: 'SchemaDateField' },\n                      {\n                        name: 'willBeRemoved',\n                        __typename: 'SchemaStringField',\n                      },\n                    ],\n                    __typename: 'Class',\n                  },\n                  __typename: 'CreateClassPayload',\n                },\n                deleteClass: {\n                  clientMutationId,\n                  class: {\n                    name: 'MyNewClass',\n                    schemaFields: [\n                      { name: 'ACL', __typename: 'SchemaACLField' },\n                      { name: 'createdAt', __typename: 'SchemaDateField' },\n                      { name: 'objectId', __typename: 'SchemaStringField' },\n                      { name: 'updatedAt', __typename: 'SchemaDateField' },\n                      {\n                        name: 'willBeRemoved',\n                        __typename: 'SchemaStringField',\n                      },\n                    ],\n                    __typename: 'Class',\n                  },\n                  __typename: 'DeleteClassPayload',\n                },\n              },\n            });\n\n            try {\n              await apolloClient.query({\n                query: gql`\n                  query {\n                    class(name: \"MyNewClass\") {\n                      name\n                    }\n                  }\n                `,\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test',\n                  },\n                },\n              });\n              fail('should fail');\n            } catch (e) {\n              expect(e.graphQLErrors[0].extensions.code).toEqual(\n                Parse.Error.INVALID_CLASS_NAME\n              );\n              expect(e.graphQLErrors[0].message).toEqual(\n                'Class MyNewClass does not exist.'\n              );\n            }\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should require master key to delete an existing class', async () => {\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  createClass(input: { name: \"SomeClass\" }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n          } catch (e) {\n            handleError(e);\n          }\n\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  deleteClass(input: { name: \"SomeClass\" }) {\n                    clientMutationId\n                  }\n                }\n              `,\n            });\n            fail('should fail');\n          } catch (e) {\n            expect(e.graphQLErrors[0].extensions.code).toEqual(\n              Parse.Error.OPERATION_FORBIDDEN\n            );\n            expect(e.graphQLErrors[0].message).toEqual(\n              'unauthorized: master key is required'\n            );\n          }\n        });\n\n        it('should fail if deleting an inexistent class', async () => {\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  deleteClass(input: { name: \"SomeInexistentClass\" }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n            fail('should fail');\n          } catch (e) {\n            expect(e.graphQLErrors[0].extensions.code).toEqual(\n              Parse.Error.INVALID_CLASS_NAME\n            );\n            expect(e.graphQLErrors[0].message).toEqual(\n              'Class SomeInexistentClass does not exist.'\n            );\n          }\n        });\n\n        it('should require master key to get an existing class', async () => {\n          try {\n            await apolloClient.query({\n              query: gql`\n                query {\n                  class(name: \"_User\") {\n                    name\n                  }\n                }\n              `,\n            });\n            fail('should fail');\n          } catch (e) {\n            expect(e.graphQLErrors[0].extensions.code).toEqual(\n              Parse.Error.OPERATION_FORBIDDEN\n            );\n            expect(e.graphQLErrors[0].message).toEqual(\n              'unauthorized: master key is required'\n            );\n          }\n        });\n\n        it('should require master key to find the existing classes', async () => {\n          try {\n            await apolloClient.query({\n              query: gql`\n                query {\n                  classes {\n                    name\n                  }\n                }\n              `,\n            });\n            fail('should fail');\n          } catch (e) {\n            expect(e.graphQLErrors[0].extensions.code).toEqual(\n              Parse.Error.OPERATION_FORBIDDEN\n            );\n            expect(e.graphQLErrors[0].message).toEqual(\n              'unauthorized: master key is required'\n            );\n          }\n        });\n      });\n\n      describe('Objects Queries', () => {\n        describe('Get', () => {\n          it('should return a class object using class specific query', async () => {\n            const obj = new Parse.Object('Customer');\n            obj.set('someField', 'someValue');\n            await obj.save();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const result = (\n              await apolloClient.query({\n                query: gql`\n                  query GetCustomer($id: ID!) {\n                    customer(id: $id) {\n                      id\n                      objectId\n                      someField\n                      createdAt\n                      updatedAt\n                    }\n                  }\n                `,\n                variables: {\n                  id: obj.id,\n                },\n              })\n            ).data.customer;\n\n            expect(result.objectId).toEqual(obj.id);\n            expect(result.someField).toEqual('someValue');\n            expect(new Date(result.createdAt)).toEqual(obj.createdAt);\n            expect(new Date(result.updatedAt)).toEqual(obj.updatedAt);\n          });\n\n          it_only_db('mongo')(\n            'should return child objects in array fields',\n            async () => {\n              const obj1 = new Parse.Object('Customer');\n              const obj2 = new Parse.Object('SomeClass');\n              const obj3 = new Parse.Object('Customer');\n\n              obj1.set('someCustomerField', 'imCustomerOne');\n              const arrayField = [42.42, 42, 'string', true];\n              obj1.set('arrayField', arrayField);\n              await obj1.save();\n\n              obj2.set('someClassField', 'imSomeClassTwo');\n              await obj2.save();\n\n              obj3.set('manyRelations', [obj1, obj2]);\n              await obj3.save();\n\n              await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n              const result = (\n                await apolloClient.query({\n                  query: gql`\n                    query GetCustomer($id: ID!) {\n                      customer(id: $id) {\n                        objectId\n                        manyRelations {\n                          ... on Customer {\n                            objectId\n                            someCustomerField\n                            arrayField {\n                              ... on Element {\n                                value\n                              }\n                            }\n                          }\n                          ... on SomeClass {\n                            objectId\n                            someClassField\n                          }\n                        }\n                        createdAt\n                        updatedAt\n                      }\n                    }\n                  `,\n                  variables: {\n                    id: obj3.id,\n                  },\n                })\n              ).data.customer;\n\n              expect(result.objectId).toEqual(obj3.id);\n              expect(result.manyRelations.length).toEqual(2);\n\n              const customerSubObject = result.manyRelations.find(\n                o => o.objectId === obj1.id\n              );\n              const someClassSubObject = result.manyRelations.find(\n                o => o.objectId === obj2.id\n              );\n\n              expect(customerSubObject).toBeDefined();\n              expect(someClassSubObject).toBeDefined();\n              expect(customerSubObject.someCustomerField).toEqual(\n                'imCustomerOne'\n              );\n              const formatedArrayField = customerSubObject.arrayField.map(\n                elem => elem.value\n              );\n              expect(formatedArrayField).toEqual(arrayField);\n              expect(someClassSubObject.someClassField).toEqual(\n                'imSomeClassTwo'\n              );\n            }\n          );\n\n          it_only_db('mongo')(\n            'should return many child objects in allow cyclic query',\n            async () => {\n              const obj1 = new Parse.Object('Employee');\n              const obj2 = new Parse.Object('Team');\n              const obj3 = new Parse.Object('Company');\n              const obj4 = new Parse.Object('Country');\n\n              obj1.set('name', 'imAnEmployee');\n              await obj1.save();\n\n              obj2.set('name', 'imATeam');\n              obj2.set('employees', [obj1]);\n              await obj2.save();\n\n              obj3.set('name', 'imACompany');\n              obj3.set('teams', [obj2]);\n              obj3.set('employees', [obj1]);\n              await obj3.save();\n\n              obj4.set('name', 'imACountry');\n              obj4.set('companies', [obj3]);\n              await obj4.save();\n\n              obj1.set('country', obj4);\n              await obj1.save();\n\n              await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n              const result = (\n                await apolloClient.query({\n                  query: gql`\n                    query DeepComplexGraphQLQuery($id: ID!) {\n                      country(id: $id) {\n                        objectId\n                        name\n                        companies {\n                          ... on Company {\n                            objectId\n                            name\n                            employees {\n                              ... on Employee {\n                                objectId\n                                name\n                              }\n                            }\n                            teams {\n                              ... on Team {\n                                objectId\n                                name\n                                employees {\n                                  ... on Employee {\n                                    objectId\n                                    name\n                                    country {\n                                      objectId\n                                      name\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  `,\n                  variables: {\n                    id: obj4.id,\n                  },\n                })\n              ).data.country;\n\n              const expectedResult = {\n                objectId: obj4.id,\n                name: 'imACountry',\n                __typename: 'Country',\n                companies: [\n                  {\n                    objectId: obj3.id,\n                    name: 'imACompany',\n                    __typename: 'Company',\n                    employees: [\n                      {\n                        objectId: obj1.id,\n                        name: 'imAnEmployee',\n                        __typename: 'Employee',\n                      },\n                    ],\n                    teams: [\n                      {\n                        objectId: obj2.id,\n                        name: 'imATeam',\n                        __typename: 'Team',\n                        employees: [\n                          {\n                            objectId: obj1.id,\n                            name: 'imAnEmployee',\n                            __typename: 'Employee',\n                            country: {\n                              objectId: obj4.id,\n                              name: 'imACountry',\n                              __typename: 'Country',\n                            },\n                          },\n                        ],\n                      },\n                    ],\n                  },\n                ],\n              };\n              expect(result).toEqual(expectedResult);\n            }\n          );\n\n          it('should respect level permissions', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            async function getObject(className, id, headers) {\n              const alias =\n                className.charAt(0).toLowerCase() + className.slice(1);\n              const specificQueryResult = await apolloClient.query({\n                query: gql`\n                  query GetSomeObject($id: ID!) {\n                    get: ${alias}(id: $id) {\n                      id\n                      createdAt\n                      someField\n                    }\n                  }\n                `,\n                variables: {\n                  id,\n                },\n                context: {\n                  headers,\n                },\n              });\n\n              return specificQueryResult;\n            }\n\n            await Promise.all(\n              objects\n                .slice(0, 3)\n                .map(obj =>\n                  expectAsync(\n                    getObject(obj.className, obj.id)\n                  ).toBeRejectedWith(jasmine.stringMatching('Object not found'))\n                )\n            );\n            expect(\n              (await getObject(object4.className, object4.id)).data.get\n                .someField\n            ).toEqual('someValue4');\n            await Promise.all(\n              objects.map(async obj =>\n                expect(\n                  (\n                    await getObject(obj.className, obj.id, {\n                      'X-Parse-Master-Key': 'test',\n                    })\n                  ).data.get.someField\n                ).toEqual(obj.get('someField'))\n              )\n            );\n            await Promise.all(\n              objects.map(async obj =>\n                expect(\n                  (\n                    await getObject(obj.className, obj.id, {\n                      'X-Parse-Session-Token': user1.getSessionToken(),\n                    })\n                  ).data.get.someField\n                ).toEqual(obj.get('someField'))\n              )\n            );\n            await Promise.all(\n              objects.map(async obj =>\n                expect(\n                  (\n                    await getObject(obj.className, obj.id, {\n                      'X-Parse-Session-Token': user2.getSessionToken(),\n                    })\n                  ).data.get.someField\n                ).toEqual(obj.get('someField'))\n              )\n            );\n            await expectAsync(\n              getObject(object2.className, object2.id, {\n                'X-Parse-Session-Token': user3.getSessionToken(),\n              })\n            ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n            await Promise.all(\n              [object1, object3, object4].map(async obj =>\n                expect(\n                  (\n                    await getObject(obj.className, obj.id, {\n                      'X-Parse-Session-Token': user3.getSessionToken(),\n                    })\n                  ).data.get.someField\n                ).toEqual(obj.get('someField'))\n              )\n            );\n            await Promise.all(\n              objects.slice(0, 3).map(obj =>\n                expectAsync(\n                  getObject(obj.className, obj.id, {\n                    'X-Parse-Session-Token': user4.getSessionToken(),\n                  })\n                ).toBeRejectedWith(jasmine.stringMatching('Object not found'))\n              )\n            );\n            expect(\n              (\n                await getObject(object4.className, object4.id, {\n                  'X-Parse-Session-Token': user4.getSessionToken(),\n                })\n              ).data.get.someField\n            ).toEqual('someValue4');\n            await Promise.all(\n              objects.slice(0, 2).map(obj =>\n                expectAsync(\n                  getObject(obj.className, obj.id, {\n                    'X-Parse-Session-Token': user5.getSessionToken(),\n                  })\n                ).toBeRejectedWith(jasmine.stringMatching('Object not found'))\n              )\n            );\n            expect(\n              (\n                await getObject(object3.className, object3.id, {\n                  'X-Parse-Session-Token': user5.getSessionToken(),\n                })\n              ).data.get.someField\n            ).toEqual('someValue3');\n            expect(\n              (\n                await getObject(object4.className, object4.id, {\n                  'X-Parse-Session-Token': user5.getSessionToken(),\n                })\n              ).data.get.someField\n            ).toEqual('someValue4');\n          });\n\n          it('should support keys argument', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const result1 = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!) {\n                  get: graphQLClass(id: $id) {\n                    someField\n                  }\n                }\n              `,\n              variables: {\n                id: object3.id,\n              },\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': user1.getSessionToken(),\n                },\n              },\n            });\n\n            const result2 = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!) {\n                  get: graphQLClass(id: $id) {\n                    someField\n                    pointerToUser {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: object3.id,\n              },\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': user1.getSessionToken(),\n                },\n              },\n            });\n\n            expect(result1.data.get.someField).toBeDefined();\n            expect(result1.data.get.pointerToUser).toBeUndefined();\n            expect(result2.data.get.someField).toBeDefined();\n            expect(result2.data.get.pointerToUser).toBeDefined();\n          });\n\n          it('should support include argument', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const result1 = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!) {\n                  get: graphQLClass(id: $id) {\n                    pointerToUser {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: object3.id,\n              },\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': user1.getSessionToken(),\n                },\n              },\n            });\n\n            const result2 = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!) {\n                  graphQLClass(id: $id) {\n                    pointerToUser {\n                      username\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: object3.id,\n              },\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': user1.getSessionToken(),\n                },\n              },\n            });\n\n            expect(result1.data.get.pointerToUser.username).toBeUndefined();\n            expect(\n              result2.data.graphQLClass.pointerToUser.username\n            ).toBeDefined();\n          });\n\n          it('should respect protectedFields', async done => {\n            await prepareData();\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const className = 'GraphQLClass';\n\n            await updateCLP(\n              {\n                get: { '*': true },\n                find: { '*': true },\n\n                protectedFields: {\n                  '*': ['someField', 'someOtherField'],\n                  authenticated: ['someField'],\n                  'userField:pointerToUser': [],\n                  [user2.id]: [],\n                },\n              },\n              className\n            );\n\n            const getObject = async (className, id, user) => {\n              const headers = user\n                ? { ['X-Parse-Session-Token']: user.getSessionToken() }\n                : undefined;\n\n              const specificQueryResult = await apolloClient.query({\n                query: gql`\n                  query GetSomeObject($id: ID!) {\n                    get: graphQLClass(id: $id) {\n                      pointerToUser {\n                        username\n                        id\n                      }\n                      someField\n                      someOtherField\n                    }\n                  }\n                `,\n                variables: {\n                  id: id,\n                },\n                context: {\n                  headers: headers,\n                },\n              });\n\n              return specificQueryResult.data.get;\n            };\n\n            const id = object3.id;\n\n            /* not authenticated */\n            const objectPublic = await getObject(className, id, undefined);\n\n            expect(objectPublic.someField).toBeNull();\n            expect(objectPublic.someOtherField).toBeNull();\n\n            /* authenticated */\n            const objectAuth = await getObject(className, id, user1);\n\n            expect(objectAuth.someField).toBeNull();\n            expect(objectAuth.someOtherField).toBe('B');\n\n            /* pointer field */\n            const objectPointed = await getObject(className, id, user5);\n\n            expect(objectPointed.someField).toBe('someValue3');\n            expect(objectPointed.someOtherField).toBe('B');\n\n            /* for user id */\n            const objectForUser = await getObject(className, id, user2);\n\n            expect(objectForUser.someField).toBe('someValue3');\n            expect(objectForUser.someOtherField).toBe('B');\n\n            done();\n          });\n          describe_only_db('mongo')('read preferences', () => {\n            it('should read from primary by default', async () => {\n              try {\n                await prepareData();\n\n                await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n                const databaseAdapter =\n                  parseServer.config.databaseController.adapter;\n                spyOn(\n                  databaseAdapter.database.serverConfig,\n                  'cursor'\n                ).and.callThrough();\n\n                await apolloClient.query({\n                  query: gql`\n                    query GetSomeObject($id: ID!) {\n                      graphQLClass(id: $id) {\n                        pointerToUser {\n                          username\n                        }\n                      }\n                    }\n                  `,\n                  variables: {\n                    id: object3.id,\n                  },\n                  context: {\n                    headers: {\n                      'X-Parse-Session-Token': user1.getSessionToken(),\n                    },\n                  },\n                });\n\n                let foundGraphQLClassReadPreference = false;\n                let foundUserClassReadPreference = false;\n                databaseAdapter.database.serverConfig.cursor.calls\n                  .all()\n                  .forEach(call => {\n                    if (\n                      call.args[0].ns.collection.indexOf('GraphQLClass') >= 0\n                    ) {\n                      foundGraphQLClassReadPreference = true;\n                      expect(call.args[0].options.readPreference.mode).toBe(\n                        ReadPreference.PRIMARY\n                      );\n                    } else if (\n                      call.args[0].ns.collection.indexOf('_User') >= 0\n                    ) {\n                      foundUserClassReadPreference = true;\n                      expect(call.args[0].options.readPreference.mode).toBe(\n                        ReadPreference.PRIMARY\n                      );\n                    }\n                  });\n\n                expect(foundGraphQLClassReadPreference).toBe(true);\n                expect(foundUserClassReadPreference).toBe(true);\n              } catch (e) {\n                handleError(e);\n              }\n            });\n\n            it('should support readPreference argument', async () => {\n              await prepareData();\n\n              await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n              const databaseAdapter =\n                parseServer.config.databaseController.adapter;\n              spyOn(\n                databaseAdapter.database.serverConfig,\n                'cursor'\n              ).and.callThrough();\n\n              await apolloClient.query({\n                query: gql`\n                  query GetSomeObject($id: ID!) {\n                    graphQLClass(\n                      id: $id\n                      options: { readPreference: SECONDARY }\n                    ) {\n                      pointerToUser {\n                        username\n                      }\n                    }\n                  }\n                `,\n                variables: {\n                  id: object3.id,\n                },\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test',\n                  },\n                },\n              });\n\n              let foundGraphQLClassReadPreference = false;\n              let foundUserClassReadPreference = false;\n              databaseAdapter.database.serverConfig.cursor.calls\n                .all()\n                .forEach(call => {\n                  if (call.args[0].ns.collection.indexOf('GraphQLClass') >= 0) {\n                    foundGraphQLClassReadPreference = true;\n                    expect(call.args[0].options.readPreference.mode).toBe(\n                      ReadPreference.SECONDARY\n                    );\n                  } else if (call.args[0].ns.collection.indexOf('_User') >= 0) {\n                    foundUserClassReadPreference = true;\n                    expect(call.args[0].options.readPreference.mode).toBe(\n                      ReadPreference.SECONDARY\n                    );\n                  }\n                });\n\n              expect(foundGraphQLClassReadPreference).toBe(true);\n              expect(foundUserClassReadPreference).toBe(true);\n            });\n\n            it('should support includeReadPreference argument', async () => {\n              await prepareData();\n\n              await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n              const databaseAdapter =\n                parseServer.config.databaseController.adapter;\n              spyOn(\n                databaseAdapter.database.serverConfig,\n                'cursor'\n              ).and.callThrough();\n\n              await apolloClient.query({\n                query: gql`\n                  query GetSomeObject($id: ID!) {\n                    graphQLClass(\n                      id: $id\n                      options: {\n                        readPreference: SECONDARY\n                        includeReadPreference: NEAREST\n                      }\n                    ) {\n                      pointerToUser {\n                        username\n                      }\n                    }\n                  }\n                `,\n                variables: {\n                  id: object3.id,\n                },\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test',\n                  },\n                },\n              });\n\n              let foundGraphQLClassReadPreference = false;\n              let foundUserClassReadPreference = false;\n              databaseAdapter.database.serverConfig.cursor.calls\n                .all()\n                .forEach(call => {\n                  if (call.args[0].ns.collection.indexOf('GraphQLClass') >= 0) {\n                    foundGraphQLClassReadPreference = true;\n                    expect(call.args[0].options.readPreference.mode).toBe(\n                      ReadPreference.SECONDARY\n                    );\n                  } else if (call.args[0].ns.collection.indexOf('_User') >= 0) {\n                    foundUserClassReadPreference = true;\n                    expect(call.args[0].options.readPreference.mode).toBe(\n                      ReadPreference.NEAREST\n                    );\n                  }\n                });\n\n              expect(foundGraphQLClassReadPreference).toBe(true);\n              expect(foundUserClassReadPreference).toBe(true);\n            });\n          });\n        });\n\n        describe('Find', () => {\n          it('should return class objects using class specific query', async () => {\n            const obj1 = new Parse.Object('Customer');\n            obj1.set('someField', 'someValue1');\n            await obj1.save();\n            const obj2 = new Parse.Object('Customer');\n            obj2.set('someField', 'someValue1');\n            await obj2.save();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const result = await apolloClient.query({\n              query: gql`\n                query FindCustomer {\n                  customers {\n                    edges {\n                      node {\n                        objectId\n                        someField\n                        createdAt\n                        updatedAt\n                      }\n                    }\n                  }\n                }\n              `,\n            });\n\n            expect(result.data.customers.edges.length).toEqual(2);\n\n            result.data.customers.edges.forEach(resultObj => {\n              const obj = resultObj.node.objectId === obj1.id ? obj1 : obj2;\n              expect(resultObj.node.objectId).toEqual(obj.id);\n              expect(resultObj.node.someField).toEqual(obj.get('someField'));\n              expect(new Date(resultObj.node.createdAt)).toEqual(obj.createdAt);\n              expect(new Date(resultObj.node.updatedAt)).toEqual(obj.updatedAt);\n            });\n          });\n\n          it('should respect level permissions', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            async function findObjects(className, headers) {\n              const graphqlClassName = pluralize(\n                className.charAt(0).toLowerCase() + className.slice(1)\n              );\n              const result = await apolloClient.query({\n                query: gql`\n                  query FindSomeObjects {\n                    find: ${graphqlClassName} {\n                      edges {\n                        node {\n                          id\n                          someField\n                        }\n                      }\n                    }\n                  }\n                `,\n                context: {\n                  headers,\n                },\n              });\n\n              return result;\n            }\n\n            expect(\n              (await findObjects('GraphQLClass')).data.find.edges.map(\n                object => object.node.someField\n              )\n            ).toEqual([]);\n            expect(\n              (await findObjects('PublicClass')).data.find.edges.map(\n                object => object.node.someField\n              )\n            ).toEqual(['someValue4']);\n            expect(\n              (\n                await findObjects('GraphQLClass', {\n                  'X-Parse-Master-Key': 'test',\n                })\n              ).data.find.edges\n                .map(object => object.node.someField)\n                .sort()\n            ).toEqual(['someValue1', 'someValue2', 'someValue3']);\n            expect(\n              (\n                await findObjects('PublicClass', {\n                  'X-Parse-Master-Key': 'test',\n                })\n              ).data.find.edges.map(object => object.node.someField)\n            ).toEqual(['someValue4']);\n            expect(\n              (\n                await findObjects('GraphQLClass', {\n                  'X-Parse-Session-Token': user1.getSessionToken(),\n                })\n              ).data.find.edges\n                .map(object => object.node.someField)\n                .sort()\n            ).toEqual(['someValue1', 'someValue2', 'someValue3']);\n            expect(\n              (\n                await findObjects('PublicClass', {\n                  'X-Parse-Session-Token': user1.getSessionToken(),\n                })\n              ).data.find.edges.map(object => object.node.someField)\n            ).toEqual(['someValue4']);\n            expect(\n              (\n                await findObjects('GraphQLClass', {\n                  'X-Parse-Session-Token': user2.getSessionToken(),\n                })\n              ).data.find.edges\n                .map(object => object.node.someField)\n                .sort()\n            ).toEqual(['someValue1', 'someValue2', 'someValue3']);\n            expect(\n              (\n                await findObjects('GraphQLClass', {\n                  'X-Parse-Session-Token': user3.getSessionToken(),\n                })\n              ).data.find.edges\n                .map(object => object.node.someField)\n                .sort()\n            ).toEqual(['someValue1', 'someValue3']);\n            expect(\n              (\n                await findObjects('GraphQLClass', {\n                  'X-Parse-Session-Token': user4.getSessionToken(),\n                })\n              ).data.find.edges.map(object => object.node.someField)\n            ).toEqual([]);\n            expect(\n              (\n                await findObjects('GraphQLClass', {\n                  'X-Parse-Session-Token': user5.getSessionToken(),\n                })\n              ).data.find.edges.map(object => object.node.someField)\n            ).toEqual(['someValue3']);\n          });\n\n          it('should support where argument using class specific query', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const result = await apolloClient.query({\n              query: gql`\n                query FindSomeObjects($where: GraphQLClassWhereInput) {\n                  graphQLClasses(where: $where) {\n                    edges {\n                      node {\n                        someField\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where: {\n                  someField: {\n                    in: ['someValue1', 'someValue2', 'someValue3'],\n                  },\n                  OR: [\n                    {\n                      pointerToUser: {\n                        have: {\n                          objectId: {\n                            equalTo: user5.id,\n                          },\n                        },\n                      },\n                    },\n                    {\n                      id: {\n                        equalTo: object1.id,\n                      },\n                    },\n                  ],\n                },\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            expect(\n              result.data.graphQLClasses.edges\n                .map(object => object.node.someField)\n                .sort()\n            ).toEqual(['someValue1', 'someValue3']);\n          });\n\n          it('should support in pointer operator using class specific query', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const result = await apolloClient.query({\n              query: gql`\n                query FindSomeObjects($where: GraphQLClassWhereInput) {\n                  graphQLClasses(where: $where) {\n                    edges {\n                      node {\n                        someField\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where: {\n                  pointerToUser: {\n                    have: {\n                      objectId: {\n                        in: [user5.id],\n                      },\n                    },\n                  },\n                },\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            const { edges } = result.data.graphQLClasses;\n            expect(edges.length).toBe(1);\n            expect(edges[0].node.someField).toEqual('someValue3');\n          });\n\n          it('should support OR operation', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const result = await apolloClient.query({\n              query: gql`\n                query {\n                  graphQLClasses(\n                    where: {\n                      OR: [\n                        { someField: { equalTo: \"someValue1\" } }\n                        { someField: { equalTo: \"someValue2\" } }\n                      ]\n                    }\n                  ) {\n                    edges {\n                      node {\n                        someField\n                      }\n                    }\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            expect(\n              result.data.graphQLClasses.edges\n                .map(object => object.node.someField)\n                .sort()\n            ).toEqual(['someValue1', 'someValue2']);\n          });\n\n          it('should support full text search', async () => {\n            try {\n              const obj = new Parse.Object('FullTextSearchTest');\n              obj.set('field1', 'Parse GraphQL Server');\n              obj.set('field2', 'It rocks!');\n              await obj.save();\n\n              await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n              const result = await apolloClient.query({\n                query: gql`\n                  query FullTextSearchTests(\n                    $where: FullTextSearchTestWhereInput\n                  ) {\n                    fullTextSearchTests(where: $where) {\n                      edges {\n                        node {\n                          objectId\n                        }\n                      }\n                    }\n                  }\n                `,\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test',\n                  },\n                },\n                variables: {\n                  where: {\n                    field1: {\n                      text: {\n                        search: {\n                          term: 'graphql',\n                        },\n                      },\n                    },\n                  },\n                },\n              });\n\n              expect(\n                result.data.fullTextSearchTests.edges[0].node.objectId\n              ).toEqual(obj.id);\n            } catch (e) {\n              handleError(e);\n            }\n          });\n\n          it('should support in query key', async () => {\n            try {\n              const country = new Parse.Object('Country');\n              country.set('code', 'FR');\n              await country.save();\n\n              const country2 = new Parse.Object('Country');\n              country2.set('code', 'US');\n              await country2.save();\n\n              const city = new Parse.Object('City');\n              city.set('country', 'FR');\n              city.set('name', 'city1');\n              await city.save();\n\n              const city2 = new Parse.Object('City');\n              city2.set('country', 'US');\n              city2.set('name', 'city2');\n              await city2.save();\n\n              await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n              const {\n                data: {\n                  cities: { edges: result },\n                },\n              } = await apolloClient.query({\n                query: gql`\n                  query inQueryKey($where: CityWhereInput) {\n                    cities(where: $where) {\n                      edges {\n                        node {\n                          country\n                          name\n                        }\n                      }\n                    }\n                  }\n                `,\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test',\n                  },\n                },\n                variables: {\n                  where: {\n                    country: {\n                      inQueryKey: {\n                        query: {\n                          className: 'Country',\n                          where: { code: { equalTo: 'US' } },\n                        },\n                        key: 'code',\n                      },\n                    },\n                  },\n                },\n              });\n\n              expect(result.length).toEqual(1);\n              expect(result[0].node.name).toEqual('city2');\n            } catch (e) {\n              handleError(e);\n            }\n          });\n\n          it('should support order, skip and first arguments', async () => {\n            const promises = [];\n            for (let i = 0; i < 100; i++) {\n              const obj = new Parse.Object('SomeClass');\n              obj.set('someField', `someValue${i < 10 ? '0' : ''}${i}`);\n              obj.set('numberField', i % 3);\n              promises.push(obj.save());\n            }\n            await Promise.all(promises);\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const result = await apolloClient.query({\n              query: gql`\n                query FindSomeObjects(\n                  $where: SomeClassWhereInput\n                  $order: [SomeClassOrder!]\n                  $skip: Int\n                  $first: Int\n                ) {\n                  find: someClasses(\n                    where: $where\n                    order: $order\n                    skip: $skip\n                    first: $first\n                  ) {\n                    edges {\n                      node {\n                        someField\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where: {\n                  someField: {\n                    matchesRegex: '^someValue',\n                  },\n                },\n                order: ['numberField_DESC', 'someField_ASC'],\n                skip: 4,\n                first: 2,\n              },\n            });\n\n            expect(\n              result.data.find.edges.map(obj => obj.node.someField)\n            ).toEqual(['someValue14', 'someValue17']);\n          });\n\n          it('should support pagination', async () => {\n            const numberArray = (first, last) => {\n              const array = [];\n              for (let i = first; i <= last; i++) {\n                array.push(i);\n              }\n              return array;\n            };\n\n            const promises = [];\n            for (let i = 0; i < 100; i++) {\n              const obj = new Parse.Object('SomeClass');\n              obj.set('numberField', i);\n              promises.push(obj.save());\n            }\n            await Promise.all(promises);\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const find = async ({ skip, after, first, before, last } = {}) => {\n              return await apolloClient.query({\n                query: gql`\n                  query FindSomeObjects(\n                    $order: [SomeClassOrder!]\n                    $skip: Int\n                    $after: String\n                    $first: Int\n                    $before: String\n                    $last: Int\n                  ) {\n                    someClasses(\n                      order: $order\n                      skip: $skip\n                      after: $after\n                      first: $first\n                      before: $before\n                      last: $last\n                    ) {\n                      edges {\n                        cursor\n                        node {\n                          numberField\n                        }\n                      }\n                      count\n                      pageInfo {\n                        hasPreviousPage\n                        startCursor\n                        endCursor\n                        hasNextPage\n                      }\n                    }\n                  }\n                `,\n                variables: {\n                  order: ['numberField_ASC'],\n                  skip,\n                  after,\n                  first,\n                  before,\n                  last,\n                },\n              });\n            };\n\n            let result = await find();\n            expect(\n              result.data.someClasses.edges.map(edge => edge.node.numberField)\n            ).toEqual(numberArray(0, 99));\n            expect(result.data.someClasses.count).toEqual(100);\n            expect(result.data.someClasses.pageInfo.hasPreviousPage).toEqual(\n              false\n            );\n            expect(result.data.someClasses.pageInfo.startCursor).toEqual(\n              result.data.someClasses.edges[0].cursor\n            );\n            expect(result.data.someClasses.pageInfo.endCursor).toEqual(\n              result.data.someClasses.edges[99].cursor\n            );\n            expect(result.data.someClasses.pageInfo.hasNextPage).toEqual(false);\n\n            result = await find({ first: 10 });\n            expect(\n              result.data.someClasses.edges.map(edge => edge.node.numberField)\n            ).toEqual(numberArray(0, 9));\n            expect(result.data.someClasses.count).toEqual(100);\n            expect(result.data.someClasses.pageInfo.hasPreviousPage).toEqual(\n              false\n            );\n            expect(result.data.someClasses.pageInfo.startCursor).toEqual(\n              result.data.someClasses.edges[0].cursor\n            );\n            expect(result.data.someClasses.pageInfo.endCursor).toEqual(\n              result.data.someClasses.edges[9].cursor\n            );\n            expect(result.data.someClasses.pageInfo.hasNextPage).toEqual(true);\n\n            result = await find({\n              first: 10,\n              after: result.data.someClasses.pageInfo.endCursor,\n            });\n            expect(\n              result.data.someClasses.edges.map(edge => edge.node.numberField)\n            ).toEqual(numberArray(10, 19));\n            expect(result.data.someClasses.count).toEqual(100);\n            expect(result.data.someClasses.pageInfo.hasPreviousPage).toEqual(\n              true\n            );\n            expect(result.data.someClasses.pageInfo.startCursor).toEqual(\n              result.data.someClasses.edges[0].cursor\n            );\n            expect(result.data.someClasses.pageInfo.endCursor).toEqual(\n              result.data.someClasses.edges[9].cursor\n            );\n            expect(result.data.someClasses.pageInfo.hasNextPage).toEqual(true);\n\n            result = await find({ last: 10 });\n            expect(\n              result.data.someClasses.edges.map(edge => edge.node.numberField)\n            ).toEqual(numberArray(90, 99));\n            expect(result.data.someClasses.count).toEqual(100);\n            expect(result.data.someClasses.pageInfo.hasPreviousPage).toEqual(\n              true\n            );\n            expect(result.data.someClasses.pageInfo.startCursor).toEqual(\n              result.data.someClasses.edges[0].cursor\n            );\n            expect(result.data.someClasses.pageInfo.endCursor).toEqual(\n              result.data.someClasses.edges[9].cursor\n            );\n            expect(result.data.someClasses.pageInfo.hasNextPage).toEqual(false);\n\n            result = await find({\n              last: 10,\n              before: result.data.someClasses.pageInfo.startCursor,\n            });\n            expect(\n              result.data.someClasses.edges.map(edge => edge.node.numberField)\n            ).toEqual(numberArray(80, 89));\n            expect(result.data.someClasses.count).toEqual(100);\n            expect(result.data.someClasses.pageInfo.hasPreviousPage).toEqual(\n              true\n            );\n            expect(result.data.someClasses.pageInfo.startCursor).toEqual(\n              result.data.someClasses.edges[0].cursor\n            );\n            expect(result.data.someClasses.pageInfo.endCursor).toEqual(\n              result.data.someClasses.edges[9].cursor\n            );\n            expect(result.data.someClasses.pageInfo.hasNextPage).toEqual(true);\n          });\n\n          it('should support count', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const where = {\n              someField: {\n                in: ['someValue1', 'someValue2', 'someValue3'],\n              },\n              OR: [\n                {\n                  pointerToUser: {\n                    have: {\n                      objectId: {\n                        equalTo: user5.id,\n                      },\n                    },\n                  },\n                },\n                {\n                  id: {\n                    equalTo: object1.id,\n                  },\n                },\n              ],\n            };\n\n            const result = await apolloClient.query({\n              query: gql`\n                query FindSomeObjects(\n                  $where: GraphQLClassWhereInput\n                  $first: Int\n                ) {\n                  find: graphQLClasses(where: $where, first: $first) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                    count\n                  }\n                }\n              `,\n              variables: {\n                where,\n                first: 0,\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            expect(result.data.find.edges).toEqual([]);\n            expect(result.data.find.count).toEqual(2);\n          });\n\n          it('should only count', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const where = {\n              someField: {\n                in: ['someValue1', 'someValue2', 'someValue3'],\n              },\n              OR: [\n                {\n                  pointerToUser: {\n                    have: {\n                      objectId: {\n                        equalTo: user5.id,\n                      },\n                    },\n                  },\n                },\n                {\n                  id: {\n                    equalTo: object1.id,\n                  },\n                },\n              ],\n            };\n\n            const result = await apolloClient.query({\n              query: gql`\n                query FindSomeObjects($where: GraphQLClassWhereInput) {\n                  find: graphQLClasses(where: $where) {\n                    count\n                  }\n                }\n              `,\n              variables: {\n                where,\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            expect(result.data.find.edges).toBeUndefined();\n            expect(result.data.find.count).toEqual(2);\n          });\n\n          it('should respect max limit', async () => {\n            parseServer = await global.reconfigureServer({\n              maxLimit: 10,\n            });\n\n            const promises = [];\n            for (let i = 0; i < 100; i++) {\n              const obj = new Parse.Object('SomeClass');\n              promises.push(obj.save());\n            }\n            await Promise.all(promises);\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const result = await apolloClient.query({\n              query: gql`\n                query FindSomeObjects($limit: Int) {\n                  find: someClasses(\n                    where: { id: { exists: true } }\n                    first: $limit\n                  ) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                    count\n                  }\n                }\n              `,\n              variables: {\n                limit: 50,\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            expect(result.data.find.edges.length).toEqual(10);\n            expect(result.data.find.count).toEqual(100);\n          });\n\n          it('should support keys argument', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const result1 = await apolloClient.query({\n              query: gql`\n                query FindSomeObject($where: GraphQLClassWhereInput) {\n                  find: graphQLClasses(where: $where) {\n                    edges {\n                      node {\n                        someField\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where: {\n                  id: { equalTo: object3.id },\n                },\n              },\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': user1.getSessionToken(),\n                },\n              },\n            });\n\n            const result2 = await apolloClient.query({\n              query: gql`\n                query FindSomeObject($where: GraphQLClassWhereInput) {\n                  find: graphQLClasses(where: $where) {\n                    edges {\n                      node {\n                        someField\n                        pointerToUser {\n                          username\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where: {\n                  id: { equalTo: object3.id },\n                },\n              },\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': user1.getSessionToken(),\n                },\n              },\n            });\n\n            expect(result1.data.find.edges[0].node.someField).toBeDefined();\n            expect(\n              result1.data.find.edges[0].node.pointerToUser\n            ).toBeUndefined();\n            expect(result2.data.find.edges[0].node.someField).toBeDefined();\n            expect(result2.data.find.edges[0].node.pointerToUser).toBeDefined();\n          });\n\n          it('should support include argument', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const where = {\n              id: {\n                equalTo: object3.id,\n              },\n            };\n\n            const result1 = await apolloClient.query({\n              query: gql`\n                query FindSomeObject($where: GraphQLClassWhereInput) {\n                  find: graphQLClasses(where: $where) {\n                    edges {\n                      node {\n                        pointerToUser {\n                          id\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where,\n              },\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': user1.getSessionToken(),\n                },\n              },\n            });\n\n            const result2 = await apolloClient.query({\n              query: gql`\n                query FindSomeObject($where: GraphQLClassWhereInput) {\n                  find: graphQLClasses(where: $where) {\n                    edges {\n                      node {\n                        pointerToUser {\n                          username\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where,\n              },\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': user1.getSessionToken(),\n                },\n              },\n            });\n            expect(\n              result1.data.find.edges[0].node.pointerToUser.username\n            ).toBeUndefined();\n            expect(\n              result2.data.find.edges[0].node.pointerToUser.username\n            ).toBeDefined();\n          });\n\n          describe_only_db('mongo')('read preferences', () => {\n            it('should read from primary by default', async () => {\n              await prepareData();\n\n              await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n              const databaseAdapter =\n                parseServer.config.databaseController.adapter;\n              spyOn(\n                databaseAdapter.database.serverConfig,\n                'cursor'\n              ).and.callThrough();\n\n              await apolloClient.query({\n                query: gql`\n                  query FindSomeObjects {\n                    find: graphQLClasses {\n                      edges {\n                        node {\n                          pointerToUser {\n                            username\n                          }\n                        }\n                      }\n                    }\n                  }\n                `,\n                context: {\n                  headers: {\n                    'X-Parse-Session-Token': user1.getSessionToken(),\n                  },\n                },\n              });\n\n              let foundGraphQLClassReadPreference = false;\n              let foundUserClassReadPreference = false;\n              databaseAdapter.database.serverConfig.cursor.calls\n                .all()\n                .forEach(call => {\n                  if (call.args[0].ns.collection.indexOf('GraphQLClass') >= 0) {\n                    foundGraphQLClassReadPreference = true;\n                    expect(call.args[0].options.readPreference.mode).toBe(\n                      ReadPreference.PRIMARY\n                    );\n                  } else if (call.args[0].ns.collection.indexOf('_User') >= 0) {\n                    foundUserClassReadPreference = true;\n                    expect(call.args[0].options.readPreference.mode).toBe(\n                      ReadPreference.PRIMARY\n                    );\n                  }\n                });\n\n              expect(foundGraphQLClassReadPreference).toBe(true);\n              expect(foundUserClassReadPreference).toBe(true);\n            });\n\n            it('should support readPreference argument', async () => {\n              await prepareData();\n\n              await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n              const databaseAdapter =\n                parseServer.config.databaseController.adapter;\n              spyOn(\n                databaseAdapter.database.serverConfig,\n                'cursor'\n              ).and.callThrough();\n\n              await apolloClient.query({\n                query: gql`\n                  query FindSomeObjects {\n                    find: graphQLClasses(\n                      options: { readPreference: SECONDARY }\n                    ) {\n                      edges {\n                        node {\n                          pointerToUser {\n                            username\n                          }\n                        }\n                      }\n                    }\n                  }\n                `,\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test',\n                  },\n                },\n              });\n\n              let foundGraphQLClassReadPreference = false;\n              let foundUserClassReadPreference = false;\n              databaseAdapter.database.serverConfig.cursor.calls\n                .all()\n                .forEach(call => {\n                  if (call.args[0].ns.collection.indexOf('GraphQLClass') >= 0) {\n                    foundGraphQLClassReadPreference = true;\n                    expect(call.args[0].options.readPreference.mode).toBe(\n                      ReadPreference.SECONDARY\n                    );\n                  } else if (call.args[0].ns.collection.indexOf('_User') >= 0) {\n                    foundUserClassReadPreference = true;\n                    expect(call.args[0].options.readPreference.mode).toBe(\n                      ReadPreference.SECONDARY\n                    );\n                  }\n                });\n\n              expect(foundGraphQLClassReadPreference).toBe(true);\n              expect(foundUserClassReadPreference).toBe(true);\n            });\n\n            it('should support includeReadPreference argument', async () => {\n              await prepareData();\n\n              await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n              const databaseAdapter =\n                parseServer.config.databaseController.adapter;\n              spyOn(\n                databaseAdapter.database.serverConfig,\n                'cursor'\n              ).and.callThrough();\n\n              await apolloClient.query({\n                query: gql`\n                  query FindSomeObjects {\n                    graphQLClasses(\n                      options: {\n                        readPreference: SECONDARY\n                        includeReadPreference: NEAREST\n                      }\n                    ) {\n                      edges {\n                        node {\n                          pointerToUser {\n                            username\n                          }\n                        }\n                      }\n                    }\n                  }\n                `,\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test',\n                  },\n                },\n              });\n\n              let foundGraphQLClassReadPreference = false;\n              let foundUserClassReadPreference = false;\n              databaseAdapter.database.serverConfig.cursor.calls\n                .all()\n                .forEach(call => {\n                  if (call.args[0].ns.collection.indexOf('GraphQLClass') >= 0) {\n                    foundGraphQLClassReadPreference = true;\n                    expect(call.args[0].options.readPreference.mode).toBe(\n                      ReadPreference.SECONDARY\n                    );\n                  } else if (call.args[0].ns.collection.indexOf('_User') >= 0) {\n                    foundUserClassReadPreference = true;\n                    expect(call.args[0].options.readPreference.mode).toBe(\n                      ReadPreference.NEAREST\n                    );\n                  }\n                });\n\n              expect(foundGraphQLClassReadPreference).toBe(true);\n              expect(foundUserClassReadPreference).toBe(true);\n            });\n\n            it('should support subqueryReadPreference argument', async () => {\n              try {\n                await prepareData();\n\n                await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n                const databaseAdapter =\n                  parseServer.config.databaseController.adapter;\n                spyOn(\n                  databaseAdapter.database.serverConfig,\n                  'cursor'\n                ).and.callThrough();\n\n                await apolloClient.query({\n                  query: gql`\n                    query FindSomeObjects($where: GraphQLClassWhereInput) {\n                      find: graphQLClasses(\n                        where: $where\n                        options: {\n                          readPreference: SECONDARY\n                          subqueryReadPreference: NEAREST\n                        }\n                      ) {\n                        edges {\n                          node {\n                            id\n                          }\n                        }\n                      }\n                    }\n                  `,\n                  variables: {\n                    where: {\n                      pointerToUser: {\n                        have: {\n                          objectId: {\n                            equalTo: 'xxxx',\n                          },\n                        },\n                      },\n                    },\n                  },\n                  context: {\n                    headers: {\n                      'X-Parse-Master-Key': 'test',\n                    },\n                  },\n                });\n\n                let foundGraphQLClassReadPreference = false;\n                let foundUserClassReadPreference = false;\n                databaseAdapter.database.serverConfig.cursor.calls\n                  .all()\n                  .forEach(call => {\n                    if (\n                      call.args[0].ns.collection.indexOf('GraphQLClass') >= 0\n                    ) {\n                      foundGraphQLClassReadPreference = true;\n                      expect(call.args[0].options.readPreference.mode).toBe(\n                        ReadPreference.SECONDARY\n                      );\n                    } else if (\n                      call.args[0].ns.collection.indexOf('_User') >= 0\n                    ) {\n                      foundUserClassReadPreference = true;\n                      expect(call.args[0].options.readPreference.mode).toBe(\n                        ReadPreference.NEAREST\n                      );\n                    }\n                  });\n\n                expect(foundGraphQLClassReadPreference).toBe(true);\n                expect(foundUserClassReadPreference).toBe(true);\n              } catch (e) {\n                handleError(e);\n              }\n            });\n          });\n\n          it('should order by multiple fields', async () => {\n            await prepareData();\n\n            await resetGraphQLCache();\n\n            let result;\n            try {\n              result = await apolloClient.query({\n                query: gql`\n                  query OrderByMultipleFields($order: [GraphQLClassOrder!]) {\n                    graphQLClasses(order: $order) {\n                      edges {\n                        node {\n                          objectId\n                        }\n                      }\n                    }\n                  }\n                `,\n                variables: {\n                  order: ['someOtherField_DESC', 'someField_ASC'],\n                },\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test',\n                  },\n                },\n              });\n            } catch (e) {\n              handleError(e);\n            }\n\n            expect(\n              result.data.graphQLClasses.edges.map(edge => edge.node.objectId)\n            ).toEqual([object3.id, object1.id, object2.id]);\n          });\n\n          it_only_db('mongo')(\n            'should order by multiple fields on a relation field',\n            async () => {\n              await prepareData();\n\n              const parentObject = new Parse.Object('ParentClass');\n              const relation = parentObject.relation('graphQLClasses');\n              relation.add(object1);\n              relation.add(object2);\n              relation.add(object3);\n              await parentObject.save();\n\n              await resetGraphQLCache();\n\n              let result;\n              try {\n                result = await apolloClient.query({\n                  query: gql`\n                    query OrderByMultipleFieldsOnRelation(\n                      $id: ID!\n                      $order: [GraphQLClassOrder!]\n                    ) {\n                      parentClass(id: $id) {\n                        graphQLClasses(order: $order) {\n                          edges {\n                            node {\n                              objectId\n                            }\n                          }\n                        }\n                      }\n                    }\n                  `,\n                  variables: {\n                    id: parentObject.id,\n                    order: ['someOtherField_DESC', 'someField_ASC'],\n                  },\n                  context: {\n                    headers: {\n                      'X-Parse-Master-Key': 'test',\n                    },\n                  },\n                });\n              } catch (e) {\n                handleError(e);\n              }\n\n              expect(\n                result.data.parentClass.graphQLClasses.edges.map(\n                  edge => edge.node.objectId\n                )\n              ).toEqual([object3.id, object1.id, object2.id]);\n            }\n          );\n        });\n      });\n\n      describe('Objects Mutations', () => {\n        describe('Create', () => {\n          it('should return specific type object using class specific mutation', async () => {\n            const clientMutationId = uuidv4();\n            const customerSchema = new Parse.Schema('Customer');\n            customerSchema.addString('someField');\n            await customerSchema.save();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const result = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateCustomer($input: CreateCustomerInput!) {\n                  createCustomer(input: $input) {\n                    clientMutationId\n                    customer {\n                      id\n                      objectId\n                      createdAt\n                      someField\n                    }\n                  }\n                }\n              `,\n              variables: {\n                input: {\n                  clientMutationId,\n                  fields: {\n                    someField: 'someValue',\n                  },\n                },\n              },\n            });\n\n            expect(result.data.createCustomer.clientMutationId).toEqual(\n              clientMutationId\n            );\n            expect(result.data.createCustomer.customer.id).toBeDefined();\n            expect(result.data.createCustomer.customer.someField).toEqual(\n              'someValue'\n            );\n\n            const customer = await new Parse.Query('Customer').get(\n              result.data.createCustomer.customer.objectId\n            );\n\n            expect(customer.createdAt).toEqual(\n              new Date(result.data.createCustomer.customer.createdAt)\n            );\n            expect(customer.get('someField')).toEqual('someValue');\n          });\n\n          it('should respect level permissions', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            async function createObject(className, headers) {\n              const getClassName =\n                className.charAt(0).toLowerCase() + className.slice(1);\n              const result = await apolloClient.mutate({\n                mutation: gql`\n                  mutation CreateSomeObject {\n                    create${className}(input: {}) {\n                      ${getClassName} {\n                        id\n                        createdAt\n                      }\n                    }\n                  }\n                `,\n                context: {\n                  headers,\n                },\n              });\n\n              const specificCreate =\n                result.data[`create${className}`][getClassName];\n              expect(specificCreate.id).toBeDefined();\n              expect(specificCreate.createdAt).toBeDefined();\n\n              return result;\n            }\n\n            await expectAsync(createObject('GraphQLClass')).toBeRejectedWith(\n              jasmine.stringMatching(\n                'Permission denied for action create on class GraphQLClass'\n              )\n            );\n            await expectAsync(createObject('PublicClass')).toBeResolved();\n            await expectAsync(\n              createObject('GraphQLClass', { 'X-Parse-Master-Key': 'test' })\n            ).toBeResolved();\n            await expectAsync(\n              createObject('PublicClass', { 'X-Parse-Master-Key': 'test' })\n            ).toBeResolved();\n            await expectAsync(\n              createObject('GraphQLClass', {\n                'X-Parse-Session-Token': user1.getSessionToken(),\n              })\n            ).toBeResolved();\n            await expectAsync(\n              createObject('PublicClass', {\n                'X-Parse-Session-Token': user1.getSessionToken(),\n              })\n            ).toBeResolved();\n            await expectAsync(\n              createObject('GraphQLClass', {\n                'X-Parse-Session-Token': user2.getSessionToken(),\n              })\n            ).toBeResolved();\n            await expectAsync(\n              createObject('PublicClass', {\n                'X-Parse-Session-Token': user2.getSessionToken(),\n              })\n            ).toBeResolved();\n            await expectAsync(\n              createObject('GraphQLClass', {\n                'X-Parse-Session-Token': user4.getSessionToken(),\n              })\n            ).toBeRejectedWith(\n              jasmine.stringMatching(\n                'Permission denied for action create on class GraphQLClass'\n              )\n            );\n            await expectAsync(\n              createObject('PublicClass', {\n                'X-Parse-Session-Token': user4.getSessionToken(),\n              })\n            ).toBeResolved();\n          });\n        });\n\n        describe('Update', () => {\n          it('should return specific type object using class specific mutation', async () => {\n            const clientMutationId = uuidv4();\n            const obj = new Parse.Object('Customer');\n            obj.set('someField1', 'someField1Value1');\n            obj.set('someField2', 'someField2Value1');\n            await obj.save();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const result = await apolloClient.mutate({\n              mutation: gql`\n                mutation UpdateCustomer($input: UpdateCustomerInput!) {\n                  updateCustomer(input: $input) {\n                    clientMutationId\n                    customer {\n                      updatedAt\n                      someField1\n                      someField2\n                    }\n                  }\n                }\n              `,\n              variables: {\n                input: {\n                  clientMutationId,\n                  id: obj.id,\n                  fields: {\n                    someField1: 'someField1Value2',\n                  },\n                },\n              },\n            });\n\n            expect(result.data.updateCustomer.clientMutationId).toEqual(\n              clientMutationId\n            );\n            expect(result.data.updateCustomer.customer.updatedAt).toBeDefined();\n            expect(result.data.updateCustomer.customer.someField1).toEqual(\n              'someField1Value2'\n            );\n            expect(result.data.updateCustomer.customer.someField2).toEqual(\n              'someField2Value1'\n            );\n\n            await obj.fetch();\n\n            expect(obj.get('someField1')).toEqual('someField1Value2');\n            expect(obj.get('someField2')).toEqual('someField2Value1');\n          });\n\n          it('should return only id using class specific mutation', async () => {\n            const obj = new Parse.Object('Customer');\n            obj.set('someField1', 'someField1Value1');\n            obj.set('someField2', 'someField2Value1');\n            await obj.save();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const result = await apolloClient.mutate({\n              mutation: gql`\n                mutation UpdateCustomer(\n                  $id: ID!\n                  $fields: UpdateCustomerFieldsInput\n                ) {\n                  updateCustomer(input: { id: $id, fields: $fields }) {\n                    customer {\n                      id\n                      objectId\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: obj.id,\n                fields: {\n                  someField1: 'someField1Value2',\n                },\n              },\n            });\n\n            expect(result.data.updateCustomer.customer.objectId).toEqual(\n              obj.id\n            );\n\n            await obj.fetch();\n\n            expect(obj.get('someField1')).toEqual('someField1Value2');\n            expect(obj.get('someField2')).toEqual('someField2Value1');\n          });\n\n          it('should respect level permissions', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            async function updateObject(className, id, fields, headers) {\n              return await apolloClient.mutate({\n                mutation: gql`\n                  mutation UpdateSomeObject(\n                    $id: ID!\n                    $fields: Update${className}FieldsInput\n                  ) {\n                    update: update${className}(input: {\n                      id: $id\n                      fields: $fields\n                      clientMutationId: \"someid\"\n                    }) {\n                      clientMutationId\n                    }\n                  }\n                `,\n                variables: {\n                  id,\n                  fields,\n                },\n                context: {\n                  headers,\n                },\n              });\n            }\n\n            await Promise.all(\n              objects.slice(0, 3).map(async obj => {\n                const originalFieldValue = obj.get('someField');\n                await expectAsync(\n                  updateObject(obj.className, obj.id, {\n                    someField: 'changedValue1',\n                  })\n                ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual(originalFieldValue);\n              })\n            );\n            expect(\n              (\n                await updateObject(object4.className, object4.id, {\n                  someField: 'changedValue1',\n                })\n              ).data.update.clientMutationId\n            ).toBeDefined();\n            await object4.fetch({ useMasterKey: true });\n            expect(object4.get('someField')).toEqual('changedValue1');\n            await Promise.all(\n              objects.map(async obj => {\n                expect(\n                  (\n                    await updateObject(\n                      obj.className,\n                      obj.id,\n                      { someField: 'changedValue2' },\n                      { 'X-Parse-Master-Key': 'test' }\n                    )\n                  ).data.update.clientMutationId\n                ).toBeDefined();\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual('changedValue2');\n              })\n            );\n            await Promise.all(\n              objects.map(async obj => {\n                expect(\n                  (\n                    await updateObject(\n                      obj.className,\n                      obj.id,\n                      { someField: 'changedValue3' },\n                      { 'X-Parse-Session-Token': user1.getSessionToken() }\n                    )\n                  ).data.update.clientMutationId\n                ).toBeDefined();\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual('changedValue3');\n              })\n            );\n            await Promise.all(\n              objects.map(async obj => {\n                expect(\n                  (\n                    await updateObject(\n                      obj.className,\n                      obj.id,\n                      { someField: 'changedValue4' },\n                      { 'X-Parse-Session-Token': user2.getSessionToken() }\n                    )\n                  ).data.update.clientMutationId\n                ).toBeDefined();\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual('changedValue4');\n              })\n            );\n            await Promise.all(\n              [object1, object3, object4].map(async obj => {\n                expect(\n                  (\n                    await updateObject(\n                      obj.className,\n                      obj.id,\n                      { someField: 'changedValue5' },\n                      { 'X-Parse-Session-Token': user3.getSessionToken() }\n                    )\n                  ).data.update.clientMutationId\n                ).toBeDefined();\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual('changedValue5');\n              })\n            );\n            const originalFieldValue = object2.get('someField');\n            await expectAsync(\n              updateObject(\n                object2.className,\n                object2.id,\n                { someField: 'changedValue5' },\n                { 'X-Parse-Session-Token': user3.getSessionToken() }\n              )\n            ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n            await object2.fetch({ useMasterKey: true });\n            expect(object2.get('someField')).toEqual(originalFieldValue);\n            await Promise.all(\n              objects.slice(0, 3).map(async obj => {\n                const originalFieldValue = obj.get('someField');\n                await expectAsync(\n                  updateObject(\n                    obj.className,\n                    obj.id,\n                    { someField: 'changedValue6' },\n                    { 'X-Parse-Session-Token': user4.getSessionToken() }\n                  )\n                ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual(originalFieldValue);\n              })\n            );\n            expect(\n              (\n                await updateObject(\n                  object4.className,\n                  object4.id,\n                  { someField: 'changedValue6' },\n                  { 'X-Parse-Session-Token': user4.getSessionToken() }\n                )\n              ).data.update.clientMutationId\n            ).toBeDefined();\n            await object4.fetch({ useMasterKey: true });\n            expect(object4.get('someField')).toEqual('changedValue6');\n            await Promise.all(\n              objects.slice(0, 2).map(async obj => {\n                const originalFieldValue = obj.get('someField');\n                await expectAsync(\n                  updateObject(\n                    obj.className,\n                    obj.id,\n                    { someField: 'changedValue7' },\n                    { 'X-Parse-Session-Token': user5.getSessionToken() }\n                  )\n                ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual(originalFieldValue);\n              })\n            );\n            expect(\n              (\n                await updateObject(\n                  object3.className,\n                  object3.id,\n                  { someField: 'changedValue7' },\n                  { 'X-Parse-Session-Token': user5.getSessionToken() }\n                )\n              ).data.update.clientMutationId\n            ).toBeDefined();\n            await object3.fetch({ useMasterKey: true });\n            expect(object3.get('someField')).toEqual('changedValue7');\n            expect(\n              (\n                await updateObject(\n                  object4.className,\n                  object4.id,\n                  { someField: 'changedValue7' },\n                  { 'X-Parse-Session-Token': user5.getSessionToken() }\n                )\n              ).data.update.clientMutationId\n            ).toBeDefined();\n            await object4.fetch({ useMasterKey: true });\n            expect(object4.get('someField')).toEqual('changedValue7');\n          });\n\n          it('should respect level permissions with specific class mutation', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            function updateObject(className, id, fields, headers) {\n              const mutationName =\n                className.charAt(0).toLowerCase() + className.slice(1);\n\n              return apolloClient.mutate({\n                mutation: gql`\n                  mutation UpdateSomeObject(\n                    $id: ID!\n                    $fields: Update${className}FieldsInput\n                  ) {\n                    update${className}(input: {\n                      id: $id\n                      fields: $fields\n                    }) {\n                      ${mutationName} {\n                        updatedAt\n                      }\n                    }\n                  }\n                `,\n                variables: {\n                  id,\n                  fields,\n                },\n                context: {\n                  headers,\n                },\n              });\n            }\n\n            await Promise.all(\n              objects.slice(0, 3).map(async obj => {\n                const originalFieldValue = obj.get('someField');\n                await expectAsync(\n                  updateObject(obj.className, obj.id, {\n                    someField: 'changedValue1',\n                  })\n                ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual(originalFieldValue);\n              })\n            );\n            expect(\n              (\n                await updateObject(object4.className, object4.id, {\n                  someField: 'changedValue1',\n                })\n              ).data[`update${object4.className}`][\n                object4.className.charAt(0).toLowerCase() +\n                  object4.className.slice(1)\n              ].updatedAt\n            ).toBeDefined();\n            await object4.fetch({ useMasterKey: true });\n            expect(object4.get('someField')).toEqual('changedValue1');\n            await Promise.all(\n              objects.map(async obj => {\n                expect(\n                  (\n                    await updateObject(\n                      obj.className,\n                      obj.id,\n                      { someField: 'changedValue2' },\n                      { 'X-Parse-Master-Key': 'test' }\n                    )\n                  ).data[`update${obj.className}`][\n                    obj.className.charAt(0).toLowerCase() +\n                      obj.className.slice(1)\n                  ].updatedAt\n                ).toBeDefined();\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual('changedValue2');\n              })\n            );\n            await Promise.all(\n              objects.map(async obj => {\n                expect(\n                  (\n                    await updateObject(\n                      obj.className,\n                      obj.id,\n                      { someField: 'changedValue3' },\n                      { 'X-Parse-Session-Token': user1.getSessionToken() }\n                    )\n                  ).data[`update${obj.className}`][\n                    obj.className.charAt(0).toLowerCase() +\n                      obj.className.slice(1)\n                  ].updatedAt\n                ).toBeDefined();\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual('changedValue3');\n              })\n            );\n            await Promise.all(\n              objects.map(async obj => {\n                expect(\n                  (\n                    await updateObject(\n                      obj.className,\n                      obj.id,\n                      { someField: 'changedValue4' },\n                      { 'X-Parse-Session-Token': user2.getSessionToken() }\n                    )\n                  ).data[`update${obj.className}`][\n                    obj.className.charAt(0).toLowerCase() +\n                      obj.className.slice(1)\n                  ].updatedAt\n                ).toBeDefined();\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual('changedValue4');\n              })\n            );\n            await Promise.all(\n              [object1, object3, object4].map(async obj => {\n                expect(\n                  (\n                    await updateObject(\n                      obj.className,\n                      obj.id,\n                      { someField: 'changedValue5' },\n                      { 'X-Parse-Session-Token': user3.getSessionToken() }\n                    )\n                  ).data[`update${obj.className}`][\n                    obj.className.charAt(0).toLowerCase() +\n                      obj.className.slice(1)\n                  ].updatedAt\n                ).toBeDefined();\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual('changedValue5');\n              })\n            );\n            const originalFieldValue = object2.get('someField');\n            await expectAsync(\n              updateObject(\n                object2.className,\n                object2.id,\n                { someField: 'changedValue5' },\n                { 'X-Parse-Session-Token': user3.getSessionToken() }\n              )\n            ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n            await object2.fetch({ useMasterKey: true });\n            expect(object2.get('someField')).toEqual(originalFieldValue);\n            await Promise.all(\n              objects.slice(0, 3).map(async obj => {\n                const originalFieldValue = obj.get('someField');\n                await expectAsync(\n                  updateObject(\n                    obj.className,\n                    obj.id,\n                    { someField: 'changedValue6' },\n                    { 'X-Parse-Session-Token': user4.getSessionToken() }\n                  )\n                ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual(originalFieldValue);\n              })\n            );\n            expect(\n              (\n                await updateObject(\n                  object4.className,\n                  object4.id,\n                  { someField: 'changedValue6' },\n                  { 'X-Parse-Session-Token': user4.getSessionToken() }\n                )\n              ).data[`update${object4.className}`][\n                object4.className.charAt(0).toLowerCase() +\n                  object4.className.slice(1)\n              ].updatedAt\n            ).toBeDefined();\n            await object4.fetch({ useMasterKey: true });\n            expect(object4.get('someField')).toEqual('changedValue6');\n            await Promise.all(\n              objects.slice(0, 2).map(async obj => {\n                const originalFieldValue = obj.get('someField');\n                await expectAsync(\n                  updateObject(\n                    obj.className,\n                    obj.id,\n                    { someField: 'changedValue7' },\n                    { 'X-Parse-Session-Token': user5.getSessionToken() }\n                  )\n                ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual(originalFieldValue);\n              })\n            );\n            expect(\n              (\n                await updateObject(\n                  object3.className,\n                  object3.id,\n                  { someField: 'changedValue7' },\n                  { 'X-Parse-Session-Token': user5.getSessionToken() }\n                )\n              ).data[`update${object3.className}`][\n                object3.className.charAt(0).toLowerCase() +\n                  object3.className.slice(1)\n              ].updatedAt\n            ).toBeDefined();\n            await object3.fetch({ useMasterKey: true });\n            expect(object3.get('someField')).toEqual('changedValue7');\n            expect(\n              (\n                await updateObject(\n                  object4.className,\n                  object4.id,\n                  { someField: 'changedValue7' },\n                  { 'X-Parse-Session-Token': user5.getSessionToken() }\n                )\n              ).data[`update${object4.className}`][\n                object4.className.charAt(0).toLowerCase() +\n                  object4.className.slice(1)\n              ].updatedAt\n            ).toBeDefined();\n            await object4.fetch({ useMasterKey: true });\n            expect(object4.get('someField')).toEqual('changedValue7');\n          });\n        });\n\n        describe('Delete', () => {\n          it('should return a specific type using class specific mutation', async () => {\n            const clientMutationId = uuidv4();\n            const obj = new Parse.Object('Customer');\n            obj.set('someField1', 'someField1Value1');\n            obj.set('someField2', 'someField2Value1');\n            await obj.save();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const result = await apolloClient.mutate({\n              mutation: gql`\n                mutation DeleteCustomer($input: DeleteCustomerInput!) {\n                  deleteCustomer(input: $input) {\n                    clientMutationId\n                    customer {\n                      id\n                      objectId\n                      someField1\n                      someField2\n                    }\n                  }\n                }\n              `,\n              variables: {\n                input: {\n                  clientMutationId,\n                  id: obj.id,\n                },\n              },\n            });\n\n            expect(result.data.deleteCustomer.clientMutationId).toEqual(\n              clientMutationId\n            );\n            expect(result.data.deleteCustomer.customer.objectId).toEqual(\n              obj.id\n            );\n            expect(result.data.deleteCustomer.customer.someField1).toEqual(\n              'someField1Value1'\n            );\n            expect(result.data.deleteCustomer.customer.someField2).toEqual(\n              'someField2Value1'\n            );\n\n            await expectAsync(\n              obj.fetch({ useMasterKey: true })\n            ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n          });\n\n          it('should respect level permissions', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            function deleteObject(className, id, headers) {\n              const mutationName =\n                className.charAt(0).toLowerCase() + className.slice(1);\n              return apolloClient.mutate({\n                mutation: gql`\n                  mutation DeleteSomeObject(\n                    $id: ID!\n                  ) {\n                    delete: delete${className}(input: { id: $id }) {\n                      ${mutationName} {\n                        objectId\n                      }\n                    }\n                  }\n                `,\n                variables: {\n                  id,\n                },\n                context: {\n                  headers,\n                },\n              });\n            }\n\n            await Promise.all(\n              objects.slice(0, 3).map(async obj => {\n                const originalFieldValue = obj.get('someField');\n                await expectAsync(\n                  deleteObject(obj.className, obj.id)\n                ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual(originalFieldValue);\n              })\n            );\n            await Promise.all(\n              objects.slice(0, 3).map(async obj => {\n                const originalFieldValue = obj.get('someField');\n                await expectAsync(\n                  deleteObject(obj.className, obj.id, {\n                    'X-Parse-Session-Token': user4.getSessionToken(),\n                  })\n                ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual(originalFieldValue);\n              })\n            );\n            expect(\n              (await deleteObject(object4.className, object4.id)).data.delete[\n                object4.className.charAt(0).toLowerCase() +\n                  object4.className.slice(1)\n              ]\n            ).toEqual({ objectId: object4.id, __typename: 'PublicClass' });\n            await expectAsync(\n              object4.fetch({ useMasterKey: true })\n            ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n            expect(\n              (\n                await deleteObject(object1.className, object1.id, {\n                  'X-Parse-Master-Key': 'test',\n                })\n              ).data.delete[\n                object1.className.charAt(0).toLowerCase() +\n                  object1.className.slice(1)\n              ]\n            ).toEqual({ objectId: object1.id, __typename: 'GraphQLClass' });\n            await expectAsync(\n              object1.fetch({ useMasterKey: true })\n            ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n            expect(\n              (\n                await deleteObject(object2.className, object2.id, {\n                  'X-Parse-Session-Token': user2.getSessionToken(),\n                })\n              ).data.delete[\n                object2.className.charAt(0).toLowerCase() +\n                  object2.className.slice(1)\n              ]\n            ).toEqual({ objectId: object2.id, __typename: 'GraphQLClass' });\n            await expectAsync(\n              object2.fetch({ useMasterKey: true })\n            ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n            expect(\n              (\n                await deleteObject(object3.className, object3.id, {\n                  'X-Parse-Session-Token': user5.getSessionToken(),\n                })\n              ).data.delete[\n                object3.className.charAt(0).toLowerCase() +\n                  object3.className.slice(1)\n              ]\n            ).toEqual({ objectId: object3.id, __typename: 'GraphQLClass' });\n            await expectAsync(\n              object3.fetch({ useMasterKey: true })\n            ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n          });\n\n          it('should respect level permissions with specific class mutation', async () => {\n            await prepareData();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            function deleteObject(className, id, headers) {\n              const mutationName =\n                className.charAt(0).toLowerCase() + className.slice(1);\n              return apolloClient.mutate({\n                mutation: gql`\n                  mutation DeleteSomeObject(\n                    $id: ID!\n                  ) {\n                    delete${className}(input: { id: $id }) {\n                      ${mutationName} {\n                        objectId\n                      }\n                    }\n                  }\n                `,\n                variables: {\n                  id,\n                },\n                context: {\n                  headers,\n                },\n              });\n            }\n\n            await Promise.all(\n              objects.slice(0, 3).map(async obj => {\n                const originalFieldValue = obj.get('someField');\n                await expectAsync(\n                  deleteObject(obj.className, obj.id)\n                ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual(originalFieldValue);\n              })\n            );\n            await Promise.all(\n              objects.slice(0, 3).map(async obj => {\n                const originalFieldValue = obj.get('someField');\n                await expectAsync(\n                  deleteObject(obj.className, obj.id, {\n                    'X-Parse-Session-Token': user4.getSessionToken(),\n                  })\n                ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n                await obj.fetch({ useMasterKey: true });\n                expect(obj.get('someField')).toEqual(originalFieldValue);\n              })\n            );\n            expect(\n              (await deleteObject(object4.className, object4.id)).data[\n                `delete${object4.className}`\n              ][\n                object4.className.charAt(0).toLowerCase() +\n                  object4.className.slice(1)\n              ].objectId\n            ).toEqual(object4.id);\n            await expectAsync(\n              object4.fetch({ useMasterKey: true })\n            ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n            expect(\n              (\n                await deleteObject(object1.className, object1.id, {\n                  'X-Parse-Master-Key': 'test',\n                })\n              ).data[`delete${object1.className}`][\n                object1.className.charAt(0).toLowerCase() +\n                  object1.className.slice(1)\n              ].objectId\n            ).toEqual(object1.id);\n            await expectAsync(\n              object1.fetch({ useMasterKey: true })\n            ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n            expect(\n              (\n                await deleteObject(object2.className, object2.id, {\n                  'X-Parse-Session-Token': user2.getSessionToken(),\n                })\n              ).data[`delete${object2.className}`][\n                object2.className.charAt(0).toLowerCase() +\n                  object2.className.slice(1)\n              ].objectId\n            ).toEqual(object2.id);\n            await expectAsync(\n              object2.fetch({ useMasterKey: true })\n            ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n            expect(\n              (\n                await deleteObject(object3.className, object3.id, {\n                  'X-Parse-Session-Token': user5.getSessionToken(),\n                })\n              ).data[`delete${object3.className}`][\n                object3.className.charAt(0).toLowerCase() +\n                  object3.className.slice(1)\n              ].objectId\n            ).toEqual(object3.id);\n            await expectAsync(\n              object3.fetch({ useMasterKey: true })\n            ).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n          });\n        });\n      });\n\n      describe('Files Mutations', () => {\n        describe('Create', () => {\n          it('should return File object', async () => {\n            const clientMutationId = uuidv4();\n\n            parseServer = await global.reconfigureServer({\n              publicServerURL: 'http://localhost:13377/parse',\n            });\n\n            const body = new FormData();\n            body.append(\n              'operations',\n              JSON.stringify({\n                query: `\n                  mutation CreateFile($input: CreateFileInput!) {\n                    createFile(input: $input) {\n                      clientMutationId\n                      fileInfo {\n                        name\n                        url\n                      }\n                    }\n                  }\n                `,\n                variables: {\n                  input: {\n                    clientMutationId,\n                    upload: null,\n                  },\n                },\n              })\n            );\n            body.append(\n              'map',\n              JSON.stringify({ 1: ['variables.input.upload'] })\n            );\n            body.append('1', 'My File Content', {\n              filename: 'myFileName.txt',\n              contentType: 'text/plain',\n            });\n\n            let res = await fetch('http://localhost:13377/graphql', {\n              method: 'POST',\n              headers,\n              body,\n            });\n\n            expect(res.status).toEqual(200);\n\n            const result = JSON.parse(await res.text());\n\n            expect(result.data.createFile.clientMutationId).toEqual(\n              clientMutationId\n            );\n            expect(result.data.createFile.fileInfo.name).toEqual(\n              jasmine.stringMatching(/_myFileName.txt$/)\n            );\n            expect(result.data.createFile.fileInfo.url).toEqual(\n              jasmine.stringMatching(/_myFileName.txt$/)\n            );\n\n            res = await fetch(result.data.createFile.fileInfo.url);\n\n            expect(res.status).toEqual(200);\n            expect(await res.text()).toEqual('My File Content');\n          });\n        });\n      });\n\n      describe('Users Queries', () => {\n        it('should return current logged user', async () => {\n          const userName = 'user1',\n            password = 'user1',\n            email = 'emailUser1@parse.com';\n\n          const user = new Parse.User();\n          user.setUsername(userName);\n          user.setPassword(password);\n          user.setEmail(email);\n          await user.signUp();\n\n          const session = await Parse.Session.current();\n          const result = await apolloClient.query({\n            query: gql`\n              query GetCurrentUser {\n                viewer {\n                  user {\n                    id\n                    username\n                    email\n                  }\n                }\n              }\n            `,\n            context: {\n              headers: {\n                'X-Parse-Session-Token': session.getSessionToken(),\n              },\n            },\n          });\n\n          const {\n            id,\n            username: resultUserName,\n            email: resultEmail,\n          } = result.data.viewer.user;\n          expect(id).toBeDefined();\n          expect(resultUserName).toEqual(userName);\n          expect(resultEmail).toEqual(email);\n        });\n\n        it('should return logged user including pointer', async () => {\n          const foo = new Parse.Object('Foo');\n          foo.set('bar', 'hello');\n\n          const userName = 'user1',\n            password = 'user1',\n            email = 'emailUser1@parse.com';\n\n          const user = new Parse.User();\n          user.setUsername(userName);\n          user.setPassword(password);\n          user.setEmail(email);\n          user.set('userFoo', foo);\n          await user.signUp();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const session = await Parse.Session.current();\n          const result = await apolloClient.query({\n            query: gql`\n              query GetCurrentUser {\n                viewer {\n                  sessionToken\n                  user {\n                    id\n                    objectId\n                    userFoo {\n                      bar\n                    }\n                  }\n                }\n              }\n            `,\n            context: {\n              headers: {\n                'X-Parse-Session-Token': session.getSessionToken(),\n              },\n            },\n          });\n\n          const sessionToken = result.data.viewer.sessionToken;\n          const { objectId, userFoo: resultFoo } = result.data.viewer.user;\n          expect(objectId).toEqual(user.id);\n          expect(sessionToken).toBeDefined();\n          expect(resultFoo).toBeDefined();\n          expect(resultFoo.bar).toEqual('hello');\n        });\n        it('should return logged user and do not by pass pointer security', async () => {\n          const masterKeyOnlyACL = new Parse.ACL();\n          masterKeyOnlyACL.setPublicReadAccess(false);\n          masterKeyOnlyACL.setPublicWriteAccess(false);\n          const foo = new Parse.Object('Foo');\n          foo.setACL(masterKeyOnlyACL);\n          foo.set('bar', 'hello');\n          await foo.save(null, { useMasterKey: true });\n          const userName = 'userx1',\n            password = 'user1',\n            email = 'emailUserx1@parse.com';\n\n          const user = new Parse.User();\n          user.setUsername(userName);\n          user.setPassword(password);\n          user.setEmail(email);\n          user.set('userFoo', foo);\n          await user.signUp();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const session = await Parse.Session.current();\n          const result = await apolloClient.query({\n            query: gql`\n              query GetCurrentUser {\n                viewer {\n                  sessionToken\n                  user {\n                    id\n                    objectId\n                    userFoo {\n                      bar\n                    }\n                  }\n                }\n              }\n            `,\n            context: {\n              headers: {\n                'X-Parse-Session-Token': session.getSessionToken(),\n              },\n            },\n          });\n\n          const sessionToken = result.data.viewer.sessionToken;\n          const { objectId, userFoo: resultFoo } = result.data.viewer.user;\n          expect(objectId).toEqual(user.id);\n          expect(sessionToken).toBeDefined();\n          expect(resultFoo).toEqual(null);\n        });\n      });\n\n      describe('Users Mutations', () => {\n        it('should sign user up', async () => {\n          const clientMutationId = uuidv4();\n          const userSchema = new Parse.Schema('_User');\n          userSchema.addString('someField');\n          await userSchema.update();\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n          const result = await apolloClient.mutate({\n            mutation: gql`\n              mutation SignUp($input: SignUpInput!) {\n                signUp(input: $input) {\n                  clientMutationId\n                  viewer {\n                    sessionToken\n                    user {\n                      someField\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              input: {\n                clientMutationId,\n                fields: {\n                  username: 'user1',\n                  password: 'user1',\n                  someField: 'someValue',\n                },\n              },\n            },\n          });\n\n          expect(result.data.signUp.clientMutationId).toEqual(clientMutationId);\n          expect(result.data.signUp.viewer.sessionToken).toBeDefined();\n          expect(result.data.signUp.viewer.user.someField).toEqual('someValue');\n          expect(typeof result.data.signUp.viewer.sessionToken).toBe('string');\n        });\n\n        it('should login with user', async () => {\n          const clientMutationId = uuidv4();\n          const userSchema = new Parse.Schema('_User');\n          parseServer = await global.reconfigureServer({\n            publicServerURL: 'http://localhost:13377/parse',\n            auth: {\n              myAuth: {\n                module: global.mockCustomAuthenticator('parse', 'graphql'),\n              },\n            },\n          });\n\n          userSchema.addString('someField');\n          await userSchema.update();\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n          const result = await apolloClient.mutate({\n            mutation: gql`\n              mutation LogInWith($input: LogInWithInput!) {\n                logInWith(input: $input) {\n                  clientMutationId\n                  viewer {\n                    sessionToken\n                    user {\n                      someField\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              input: {\n                clientMutationId,\n                authData: {\n                  myAuth: {\n                    id: 'parse',\n                    password: 'graphql',\n                  },\n                },\n                fields: {\n                  someField: 'someValue',\n                },\n              },\n            },\n          });\n\n          expect(result.data.logInWith.clientMutationId).toEqual(\n            clientMutationId\n          );\n          expect(result.data.logInWith.viewer.sessionToken).toBeDefined();\n          expect(result.data.logInWith.viewer.user.someField).toEqual(\n            'someValue'\n          );\n          expect(typeof result.data.logInWith.viewer.sessionToken).toBe(\n            'string'\n          );\n        });\n\n        it('should log the user in', async () => {\n          const clientMutationId = uuidv4();\n          const user = new Parse.User();\n          user.setUsername('user1');\n          user.setPassword('user1');\n          user.set('someField', 'someValue');\n          await user.signUp();\n          await Parse.User.logOut();\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n          const result = await apolloClient.mutate({\n            mutation: gql`\n              mutation LogInUser($input: LogInInput!) {\n                logIn(input: $input) {\n                  clientMutationId\n                  viewer {\n                    sessionToken\n                    user {\n                      someField\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              input: {\n                clientMutationId,\n                username: 'user1',\n                password: 'user1',\n              },\n            },\n          });\n\n          expect(result.data.logIn.clientMutationId).toEqual(clientMutationId);\n          expect(result.data.logIn.viewer.sessionToken).toBeDefined();\n          expect(result.data.logIn.viewer.user.someField).toEqual('someValue');\n          expect(typeof result.data.logIn.viewer.sessionToken).toBe('string');\n        });\n\n        it('should log the user out', async () => {\n          const clientMutationId = uuidv4();\n          const user = new Parse.User();\n          user.setUsername('user1');\n          user.setPassword('user1');\n          await user.signUp();\n          await Parse.User.logOut();\n\n          const logIn = await apolloClient.mutate({\n            mutation: gql`\n              mutation LogInUser($input: LogInInput!) {\n                logIn(input: $input) {\n                  viewer {\n                    sessionToken\n                  }\n                }\n              }\n            `,\n            variables: {\n              input: {\n                username: 'user1',\n                password: 'user1',\n              },\n            },\n          });\n\n          const sessionToken = logIn.data.logIn.viewer.sessionToken;\n\n          const logOut = await apolloClient.mutate({\n            mutation: gql`\n              mutation LogOutUser($input: LogOutInput!) {\n                logOut(input: $input) {\n                  clientMutationId\n                  viewer {\n                    sessionToken\n                  }\n                }\n              }\n            `,\n            context: {\n              headers: {\n                'X-Parse-Session-Token': sessionToken,\n              },\n            },\n            variables: {\n              input: {\n                clientMutationId,\n              },\n            },\n          });\n          expect(logOut.data.logOut.clientMutationId).toEqual(clientMutationId);\n          expect(logOut.data.logOut.viewer.sessionToken).toEqual(sessionToken);\n\n          try {\n            await apolloClient.query({\n              query: gql`\n                query GetCurrentUser {\n                  viewer {\n                    username\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': sessionToken,\n                },\n              },\n            });\n            fail('should not retrieve current user due to session token');\n          } catch (err) {\n            const { statusCode, result } = err.networkError;\n            expect(statusCode).toBe(400);\n            expect(result).toEqual({\n              code: 209,\n              error: 'Invalid session token',\n            });\n          }\n        });\n\n        it('should send reset password', async () => {\n          const clientMutationId = uuidv4();\n          const emailAdapter = {\n            sendVerificationEmail: () => {},\n            sendPasswordResetEmail: () => Promise.resolve(),\n            sendMail: () => {},\n          };\n          parseServer = await global.reconfigureServer({\n            appName: 'test',\n            emailAdapter: emailAdapter,\n            publicServerURL: 'http://test.test',\n          });\n          const user = new Parse.User();\n          user.setUsername('user1');\n          user.setPassword('user1');\n          user.setEmail('user1@user1.user1');\n          await user.signUp();\n          await Parse.User.logOut();\n          const result = await apolloClient.mutate({\n            mutation: gql`\n              mutation ResetPassword($input: ResetPasswordInput!) {\n                resetPassword(input: $input) {\n                  clientMutationId\n                  ok\n                }\n              }\n            `,\n            variables: {\n              input: {\n                clientMutationId,\n                email: 'user1@user1.user1',\n              },\n            },\n          });\n\n          expect(result.data.resetPassword.clientMutationId).toEqual(\n            clientMutationId\n          );\n          expect(result.data.resetPassword.ok).toBeTruthy();\n        });\n        it('should send verification email again', async () => {\n          const clientMutationId = uuidv4();\n          const emailAdapter = {\n            sendVerificationEmail: () => {},\n            sendPasswordResetEmail: () => Promise.resolve(),\n            sendMail: () => {},\n          };\n          parseServer = await global.reconfigureServer({\n            appName: 'test',\n            emailAdapter: emailAdapter,\n            publicServerURL: 'http://test.test',\n          });\n          const user = new Parse.User();\n          user.setUsername('user1');\n          user.setPassword('user1');\n          user.setEmail('user1@user1.user1');\n          await user.signUp();\n          await Parse.User.logOut();\n          const result = await apolloClient.mutate({\n            mutation: gql`\n              mutation SendVerificationEmail(\n                $input: SendVerificationEmailInput!\n              ) {\n                sendVerificationEmail(input: $input) {\n                  clientMutationId\n                  ok\n                }\n              }\n            `,\n            variables: {\n              input: {\n                clientMutationId,\n                email: 'user1@user1.user1',\n              },\n            },\n          });\n\n          expect(result.data.sendVerificationEmail.clientMutationId).toEqual(\n            clientMutationId\n          );\n          expect(result.data.sendVerificationEmail.ok).toBeTruthy();\n        });\n      });\n\n      describe('Session Token', () => {\n        it('should fail due to invalid session token', async () => {\n          try {\n            await apolloClient.query({\n              query: gql`\n                query GetCurrentUser {\n                  me {\n                    username\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': 'foo',\n                },\n              },\n            });\n            fail('should not retrieve current user due to session token');\n          } catch (err) {\n            const { statusCode, result } = err.networkError;\n            expect(statusCode).toBe(400);\n            expect(result).toEqual({\n              code: 209,\n              error: 'Invalid session token',\n            });\n          }\n        });\n\n        it('should fail due to empty session token', async () => {\n          try {\n            await apolloClient.query({\n              query: gql`\n                query GetCurrentUser {\n                  viewer {\n                    user {\n                      username\n                    }\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': '',\n                },\n              },\n            });\n            fail('should not retrieve current user due to session token');\n          } catch (err) {\n            const { graphQLErrors } = err;\n            expect(graphQLErrors.length).toBe(1);\n            expect(graphQLErrors[0].message).toBe('Invalid session token');\n          }\n        });\n\n        it('should find a user and fail due to empty session token', async () => {\n          const car = new Parse.Object('Car');\n          await car.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          try {\n            await apolloClient.query({\n              query: gql`\n                query GetCurrentUser {\n                  viewer {\n                    user {\n                      username\n                    }\n                  }\n                  cars {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': '',\n                },\n              },\n            });\n            fail('should not retrieve current user due to session token');\n          } catch (err) {\n            const { graphQLErrors } = err;\n            expect(graphQLErrors.length).toBe(1);\n            expect(graphQLErrors[0].message).toBe('Invalid session token');\n          }\n        });\n      });\n\n      describe('Functions Mutations', () => {\n        it('can be called', async () => {\n          try {\n            const clientMutationId = uuidv4();\n\n            Parse.Cloud.define('hello', async () => {\n              return 'Hello world!';\n            });\n\n            const result = await apolloClient.mutate({\n              mutation: gql`\n                mutation CallFunction($input: CallCloudCodeInput!) {\n                  callCloudCode(input: $input) {\n                    clientMutationId\n                    result\n                  }\n                }\n              `,\n              variables: {\n                input: {\n                  clientMutationId,\n                  functionName: 'hello',\n                },\n              },\n            });\n\n            expect(result.data.callCloudCode.clientMutationId).toEqual(\n              clientMutationId\n            );\n            expect(result.data.callCloudCode.result).toEqual('Hello world!');\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('can throw errors', async () => {\n          Parse.Cloud.define('hello', async () => {\n            throw new Error('Some error message.');\n          });\n\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CallFunction {\n                  callCloudCode(input: { functionName: hello }) {\n                    result\n                  }\n                }\n              `,\n            });\n            fail('Should throw an error');\n          } catch (e) {\n            const { graphQLErrors } = e;\n            expect(graphQLErrors.length).toBe(1);\n            expect(graphQLErrors[0].message).toBe('Some error message.');\n          }\n        });\n\n        it('should accept different params', done => {\n          Parse.Cloud.define('hello', async req => {\n            expect(req.params.date instanceof Date).toBe(true);\n            expect(req.params.date.getTime()).toBe(1463907600000);\n            expect(req.params.dateList[0] instanceof Date).toBe(true);\n            expect(req.params.dateList[0].getTime()).toBe(1463907600000);\n            expect(req.params.complexStructure.date[0] instanceof Date).toBe(\n              true\n            );\n            expect(req.params.complexStructure.date[0].getTime()).toBe(\n              1463907600000\n            );\n            expect(\n              req.params.complexStructure.deepDate.date[0] instanceof Date\n            ).toBe(true);\n            expect(req.params.complexStructure.deepDate.date[0].getTime()).toBe(\n              1463907600000\n            );\n            expect(\n              req.params.complexStructure.deepDate2[0].date instanceof Date\n            ).toBe(true);\n            expect(\n              req.params.complexStructure.deepDate2[0].date.getTime()\n            ).toBe(1463907600000);\n            // Regression for #2294\n            expect(req.params.file instanceof Parse.File).toBe(true);\n            expect(req.params.file.url()).toEqual('https://some.url');\n            // Regression for #2204\n            expect(req.params.array).toEqual(['a', 'b', 'c']);\n            expect(Array.isArray(req.params.array)).toBe(true);\n            expect(req.params.arrayOfArray).toEqual([\n              ['a', 'b', 'c'],\n              ['d', 'e', 'f'],\n            ]);\n            expect(Array.isArray(req.params.arrayOfArray)).toBe(true);\n            expect(Array.isArray(req.params.arrayOfArray[0])).toBe(true);\n            expect(Array.isArray(req.params.arrayOfArray[1])).toBe(true);\n\n            done();\n          });\n\n          const params = {\n            date: {\n              __type: 'Date',\n              iso: '2016-05-22T09:00:00.000Z',\n            },\n            dateList: [\n              {\n                __type: 'Date',\n                iso: '2016-05-22T09:00:00.000Z',\n              },\n            ],\n            lol: 'hello',\n            complexStructure: {\n              date: [\n                {\n                  __type: 'Date',\n                  iso: '2016-05-22T09:00:00.000Z',\n                },\n              ],\n              deepDate: {\n                date: [\n                  {\n                    __type: 'Date',\n                    iso: '2016-05-22T09:00:00.000Z',\n                  },\n                ],\n              },\n              deepDate2: [\n                {\n                  date: {\n                    __type: 'Date',\n                    iso: '2016-05-22T09:00:00.000Z',\n                  },\n                },\n              ],\n            },\n            file: Parse.File.fromJSON({\n              __type: 'File',\n              name: 'name',\n              url: 'https://some.url',\n            }),\n            array: ['a', 'b', 'c'],\n            arrayOfArray: [\n              ['a', 'b', 'c'],\n              ['d', 'e', 'f'],\n            ],\n          };\n\n          apolloClient.mutate({\n            mutation: gql`\n              mutation CallFunction($params: Object) {\n                callCloudCode(input: { functionName: hello, params: $params }) {\n                  result\n                }\n              }\n            `,\n            variables: {\n              params,\n            },\n          });\n        });\n\n        it('should list all functions in the enum type', async () => {\n          try {\n            Parse.Cloud.define('a', async () => {\n              return 'hello a';\n            });\n\n            Parse.Cloud.define('b', async () => {\n              return 'hello b';\n            });\n\n            Parse.Cloud.define('_underscored', async () => {\n              return 'hello _underscored';\n            });\n\n            Parse.Cloud.define('contains1Number', async () => {\n              return 'hello contains1Number';\n            });\n\n            const functionEnum = (\n              await apolloClient.query({\n                query: gql`\n                  query ObjectType {\n                    __type(name: \"CloudCodeFunction\") {\n                      kind\n                      enumValues {\n                        name\n                      }\n                    }\n                  }\n                `,\n              })\n            ).data['__type'];\n            expect(functionEnum.kind).toEqual('ENUM');\n            expect(\n              functionEnum.enumValues.map(value => value.name).sort()\n            ).toEqual(['_underscored', 'a', 'b', 'contains1Number']);\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should warn functions not matching GraphQL allowed names', async () => {\n          try {\n            spyOn(\n              parseGraphQLServer.parseGraphQLSchema.log,\n              'warn'\n            ).and.callThrough();\n\n            Parse.Cloud.define('a', async () => {\n              return 'hello a';\n            });\n\n            Parse.Cloud.define('double-barrelled', async () => {\n              return 'hello b';\n            });\n\n            Parse.Cloud.define('1NumberInTheBeggning', async () => {\n              return 'hello contains1Number';\n            });\n\n            const functionEnum = (\n              await apolloClient.query({\n                query: gql`\n                  query ObjectType {\n                    __type(name: \"CloudCodeFunction\") {\n                      kind\n                      enumValues {\n                        name\n                      }\n                    }\n                  }\n                `,\n              })\n            ).data['__type'];\n            expect(functionEnum.kind).toEqual('ENUM');\n            expect(\n              functionEnum.enumValues.map(value => value.name).sort()\n            ).toEqual(['a']);\n            expect(\n              parseGraphQLServer.parseGraphQLSchema.log.warn.calls\n                .all()\n                .map(call => call.args[0])\n                .sort()\n            ).toEqual([\n              'Function 1NumberInTheBeggning could not be added to the auto schema because GraphQL names must match /^[_a-zA-Z][_a-zA-Z0-9]*$/.',\n              'Function double-barrelled could not be added to the auto schema because GraphQL names must match /^[_a-zA-Z][_a-zA-Z0-9]*$/.',\n            ]);\n          } catch (e) {\n            handleError(e);\n          }\n        });\n      });\n\n      describe('Data Types', () => {\n        it('should support String', async () => {\n          try {\n            const someFieldValue = 'some string';\n\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(\n                    input: { name: \"SomeClass\", schemaFields: $schemaFields }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addStrings: [{ name: 'someField' }],\n                },\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.someField.type).toEqual('String');\n\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                  createSomeClass(input: { fields: $fields }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  someField: someFieldValue,\n                },\n              },\n            });\n\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!, $someFieldValue: String) {\n                  someClass(id: $id) {\n                    someField\n                  }\n                  someClasses(\n                    where: { someField: { equalTo: $someFieldValue } }\n                  ) {\n                    edges {\n                      node {\n                        someField\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id,\n                someFieldValue,\n              },\n            });\n\n            expect(typeof getResult.data.someClass.someField).toEqual('string');\n            expect(getResult.data.someClass.someField).toEqual(someFieldValue);\n            expect(getResult.data.someClasses.edges.length).toEqual(1);\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should support Int numbers', async () => {\n          try {\n            const someFieldValue = 123;\n\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(\n                    input: { name: \"SomeClass\", schemaFields: $schemaFields }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addNumbers: [{ name: 'someField' }],\n                },\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                  createSomeClass(input: { fields: $fields }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  someField: someFieldValue,\n                },\n              },\n            });\n\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.someField.type).toEqual('Number');\n\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!, $someFieldValue: Float) {\n                  someClass(id: $id) {\n                    someField\n                  }\n                  someClasses(\n                    where: { someField: { equalTo: $someFieldValue } }\n                  ) {\n                    edges {\n                      node {\n                        someField\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id,\n                someFieldValue,\n              },\n            });\n\n            expect(typeof getResult.data.someClass.someField).toEqual('number');\n            expect(getResult.data.someClass.someField).toEqual(someFieldValue);\n            expect(getResult.data.someClasses.edges.length).toEqual(1);\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should support Float numbers', async () => {\n          try {\n            const someFieldValue = 123.4;\n\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(\n                    input: { name: \"SomeClass\", schemaFields: $schemaFields }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addNumbers: [{ name: 'someField' }],\n                },\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.someField.type).toEqual('Number');\n\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                  createSomeClass(input: { fields: $fields }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  someField: someFieldValue,\n                },\n              },\n            });\n\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!, $someFieldValue: Float) {\n                  someClass(id: $id) {\n                    someField\n                  }\n                  someClasses(\n                    where: { someField: { equalTo: $someFieldValue } }\n                  ) {\n                    edges {\n                      node {\n                        someField\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id,\n                someFieldValue,\n              },\n            });\n\n            expect(typeof getResult.data.someClass.someField).toEqual('number');\n            expect(getResult.data.someClass.someField).toEqual(someFieldValue);\n            expect(getResult.data.someClasses.edges.length).toEqual(1);\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should support Boolean', async () => {\n          try {\n            const someFieldValueTrue = true;\n            const someFieldValueFalse = false;\n\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(\n                    input: { name: \"SomeClass\", schemaFields: $schemaFields }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addBooleans: [\n                    { name: 'someFieldTrue' },\n                    { name: 'someFieldFalse' },\n                  ],\n                },\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.someFieldTrue.type).toEqual('Boolean');\n            expect(schema.fields.someFieldFalse.type).toEqual('Boolean');\n\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                  createSomeClass(input: { fields: $fields }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  someFieldTrue: someFieldValueTrue,\n                  someFieldFalse: someFieldValueFalse,\n                },\n              },\n            });\n\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject(\n                  $id: ID!\n                  $someFieldValueTrue: Boolean\n                  $someFieldValueFalse: Boolean\n                ) {\n                  someClass(id: $id) {\n                    someFieldTrue\n                    someFieldFalse\n                  }\n                  someClasses(\n                    where: {\n                      someFieldTrue: { equalTo: $someFieldValueTrue }\n                      someFieldFalse: { equalTo: $someFieldValueFalse }\n                    }\n                  ) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id,\n                someFieldValueTrue,\n                someFieldValueFalse,\n              },\n            });\n\n            expect(typeof getResult.data.someClass.someFieldTrue).toEqual(\n              'boolean'\n            );\n            expect(typeof getResult.data.someClass.someFieldFalse).toEqual(\n              'boolean'\n            );\n            expect(getResult.data.someClass.someFieldTrue).toEqual(true);\n            expect(getResult.data.someClass.someFieldFalse).toEqual(false);\n            expect(getResult.data.someClasses.edges.length).toEqual(1);\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should support Date', async () => {\n          try {\n            const someFieldValue = new Date();\n\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(\n                    input: { name: \"SomeClass\", schemaFields: $schemaFields }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addDates: [{ name: 'someField' }],\n                },\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.someField.type).toEqual('Date');\n\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                  createSomeClass(input: { fields: $fields }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  someField: someFieldValue,\n                },\n              },\n            });\n\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!) {\n                  someClass(id: $id) {\n                    someField\n                  }\n                  someClasses(where: { someField: { exists: true } }) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id,\n              },\n            });\n\n            expect(new Date(getResult.data.someClass.someField)).toEqual(\n              someFieldValue\n            );\n            expect(getResult.data.someClasses.edges.length).toEqual(1);\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should support createdAt and updatedAt', async () => {\n          await apolloClient.mutate({\n            mutation: gql`\n              mutation CreateClass {\n                createClass(input: { name: \"SomeClass\" }) {\n                  clientMutationId\n                }\n              }\n            `,\n            context: {\n              headers: {\n                'X-Parse-Master-Key': 'test',\n              },\n            },\n          });\n\n          const schema = await new Parse.Schema('SomeClass').get();\n          expect(schema.fields.createdAt.type).toEqual('Date');\n          expect(schema.fields.updatedAt.type).toEqual('Date');\n        });\n\n        it('should support ACL', async () => {\n          const someClass = new Parse.Object('SomeClass');\n          await someClass.save();\n\n          const user = new Parse.User();\n          user.set('username', 'username');\n          user.set('password', 'password');\n          await user.signUp();\n\n          const user2 = new Parse.User();\n          user2.set('username', 'username2');\n          user2.set('password', 'password2');\n          await user2.signUp();\n\n          const roleACL = new Parse.ACL();\n          roleACL.setPublicReadAccess(true);\n\n          const role = new Parse.Role('aRole', roleACL);\n          await role.save();\n\n          const role2 = new Parse.Role('aRole2', roleACL);\n          await role2.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const gqlUser = (\n            await apolloClient.query({\n              query: gql`\n                query getUser($id: ID!) {\n                  user(id: $id) {\n                    id\n                  }\n                }\n              `,\n              variables: { id: user.id },\n            })\n          ).data.user;\n          const {\n            data: { createSomeClass },\n          } = await apolloClient.mutate({\n            mutation: gql`\n              mutation Create($fields: CreateSomeClassFieldsInput) {\n                createSomeClass(input: { fields: $fields }) {\n                  someClass {\n                    id\n                    objectId\n                    ACL {\n                      users {\n                        userId\n                        read\n                        write\n                      }\n                      roles {\n                        roleName\n                        read\n                        write\n                      }\n                      public {\n                        read\n                        write\n                      }\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              fields: {\n                ACL: {\n                  users: [\n                    { userId: gqlUser.id, read: true, write: true },\n                    { userId: user2.id, read: true, write: false },\n                  ],\n                  roles: [\n                    { roleName: 'aRole', read: true, write: false },\n                    { roleName: 'aRole2', read: false, write: true },\n                  ],\n                  public: { read: true, write: true },\n                },\n              },\n            },\n          });\n\n          const expectedCreateACL = {\n            __typename: 'ACL',\n            users: [\n              {\n                userId: toGlobalId('_User', user.id),\n                read: true,\n                write: true,\n                __typename: 'UserACL',\n              },\n              {\n                userId: toGlobalId('_User', user2.id),\n                read: true,\n                write: false,\n                __typename: 'UserACL',\n              },\n            ],\n            roles: [\n              {\n                roleName: 'aRole',\n                read: true,\n                write: false,\n                __typename: 'RoleACL',\n              },\n              {\n                roleName: 'aRole2',\n                read: false,\n                write: true,\n                __typename: 'RoleACL',\n              },\n            ],\n            public: { read: true, write: true, __typename: 'PublicACL' },\n          };\n          const query1 = new Parse.Query('SomeClass');\n          const obj1 = (\n            await query1.get(createSomeClass.someClass.objectId, {\n              useMasterKey: true,\n            })\n          ).toJSON();\n          expect(obj1.ACL[user.id]).toEqual({ read: true, write: true });\n          expect(obj1.ACL[user2.id]).toEqual({ read: true });\n          expect(obj1.ACL['role:aRole']).toEqual({ read: true });\n          expect(obj1.ACL['role:aRole2']).toEqual({ write: true });\n          expect(obj1.ACL['*']).toEqual({ read: true, write: true });\n          expect(createSomeClass.someClass.ACL).toEqual(expectedCreateACL);\n\n          const {\n            data: { updateSomeClass },\n          } = await apolloClient.mutate({\n            mutation: gql`\n              mutation Update($id: ID!, $fields: UpdateSomeClassFieldsInput) {\n                updateSomeClass(input: { id: $id, fields: $fields }) {\n                  someClass {\n                    id\n                    objectId\n                    ACL {\n                      users {\n                        userId\n                        read\n                        write\n                      }\n                      roles {\n                        roleName\n                        read\n                        write\n                      }\n                      public {\n                        read\n                        write\n                      }\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              id: createSomeClass.someClass.id,\n              fields: {\n                ACL: {\n                  roles: [{ roleName: 'aRole', write: true, read: true }],\n                  public: { read: true, write: false },\n                },\n              },\n            },\n          });\n\n          const expectedUpdateACL = {\n            __typename: 'ACL',\n            users: null,\n            roles: [\n              {\n                roleName: 'aRole',\n                read: true,\n                write: true,\n                __typename: 'RoleACL',\n              },\n            ],\n            public: { read: true, write: false, __typename: 'PublicACL' },\n          };\n\n          const query2 = new Parse.Query('SomeClass');\n          const obj2 = (\n            await query2.get(createSomeClass.someClass.objectId, {\n              useMasterKey: true,\n            })\n          ).toJSON();\n\n          expect(obj2.ACL['role:aRole']).toEqual({ write: true, read: true });\n          expect(obj2.ACL[user.id]).toBeUndefined();\n          expect(obj2.ACL['*']).toEqual({ read: true });\n          expect(updateSomeClass.someClass.ACL).toEqual(expectedUpdateACL);\n        });\n\n        it('should support pointer on create', async () => {\n          const company = new Parse.Object('Company');\n          company.set('name', 'imACompany1');\n          await company.save();\n\n          const country = new Parse.Object('Country');\n          country.set('name', 'imACountry');\n          country.set('company', company);\n          await country.save();\n\n          const company2 = new Parse.Object('Company');\n          company2.set('name', 'imACompany2');\n          await company2.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const {\n            data: {\n              createCountry: { country: result },\n            },\n          } = await apolloClient.mutate({\n            mutation: gql`\n              mutation Create($fields: CreateCountryFieldsInput) {\n                createCountry(input: { fields: $fields }) {\n                  country {\n                    id\n                    objectId\n                    company {\n                      id\n                      objectId\n                      name\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              fields: {\n                name: 'imCountry2',\n                company: { link: company2.id },\n              },\n            },\n          });\n\n          expect(result.id).toBeDefined();\n          expect(result.company.objectId).toEqual(company2.id);\n          expect(result.company.name).toEqual('imACompany2');\n        });\n\n        it('should support nested pointer on create', async () => {\n          const company = new Parse.Object('Company');\n          company.set('name', 'imACompany1');\n          await company.save();\n\n          const country = new Parse.Object('Country');\n          country.set('name', 'imACountry');\n          country.set('company', company);\n          await country.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const {\n            data: {\n              createCountry: { country: result },\n            },\n          } = await apolloClient.mutate({\n            mutation: gql`\n              mutation Create($fields: CreateCountryFieldsInput) {\n                createCountry(input: { fields: $fields }) {\n                  country {\n                    id\n                    company {\n                      id\n                      name\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              fields: {\n                name: 'imCountry2',\n                company: {\n                  createAndLink: {\n                    name: 'imACompany2',\n                  },\n                },\n              },\n            },\n          });\n\n          expect(result.id).toBeDefined();\n          expect(result.company.id).toBeDefined();\n          expect(result.company.name).toEqual('imACompany2');\n        });\n\n        it('should support pointer on update', async () => {\n          const company = new Parse.Object('Company');\n          company.set('name', 'imACompany1');\n          await company.save();\n\n          const country = new Parse.Object('Country');\n          country.set('name', 'imACountry');\n          country.set('company', company);\n          await country.save();\n\n          const company2 = new Parse.Object('Company');\n          company2.set('name', 'imACompany2');\n          await company2.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const {\n            data: {\n              updateCountry: { country: result },\n            },\n          } = await apolloClient.mutate({\n            mutation: gql`\n              mutation Update($id: ID!, $fields: UpdateCountryFieldsInput) {\n                updateCountry(input: { id: $id, fields: $fields }) {\n                  country {\n                    id\n                    objectId\n                    company {\n                      id\n                      objectId\n                      name\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              id: country.id,\n              fields: {\n                company: { link: company2.id },\n              },\n            },\n          });\n\n          expect(result.id).toBeDefined();\n          expect(result.company.objectId).toEqual(company2.id);\n          expect(result.company.name).toEqual('imACompany2');\n        });\n\n        it('should support nested pointer on update', async () => {\n          const company = new Parse.Object('Company');\n          company.set('name', 'imACompany1');\n          await company.save();\n\n          const country = new Parse.Object('Country');\n          country.set('name', 'imACountry');\n          country.set('company', company);\n          await country.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const {\n            data: {\n              updateCountry: { country: result },\n            },\n          } = await apolloClient.mutate({\n            mutation: gql`\n              mutation Update($id: ID!, $fields: UpdateCountryFieldsInput) {\n                updateCountry(input: { id: $id, fields: $fields }) {\n                  country {\n                    id\n                    company {\n                      id\n                      name\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              id: country.id,\n              fields: {\n                company: {\n                  createAndLink: {\n                    name: 'imACompany2',\n                  },\n                },\n              },\n            },\n          });\n\n          expect(result.id).toBeDefined();\n          expect(result.company.id).toBeDefined();\n          expect(result.company.name).toEqual('imACompany2');\n        });\n\n        it_only_db('mongo')(\n          'should support relation and nested relation on create',\n          async () => {\n            const company = new Parse.Object('Company');\n            company.set('name', 'imACompany1');\n            await company.save();\n\n            const country = new Parse.Object('Country');\n            country.set('name', 'imACountry');\n            country.relation('companies').add(company);\n            await country.save();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const {\n              data: {\n                createCountry: { country: result },\n              },\n            } = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateCountry($fields: CreateCountryFieldsInput) {\n                  createCountry(input: { fields: $fields }) {\n                    country {\n                      id\n                      objectId\n                      name\n                      companies {\n                        edges {\n                          node {\n                            id\n                            objectId\n                            name\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  name: 'imACountry2',\n                  companies: {\n                    add: [company.id],\n                    createAndAdd: [\n                      {\n                        name: 'imACompany2',\n                      },\n                      {\n                        name: 'imACompany3',\n                      },\n                    ],\n                  },\n                },\n              },\n            });\n\n            expect(result.id).toBeDefined();\n            expect(result.name).toEqual('imACountry2');\n            expect(result.companies.edges.length).toEqual(3);\n            expect(\n              result.companies.edges.some(o => o.node.objectId === company.id)\n            ).toBeTruthy();\n            expect(\n              result.companies.edges.some(o => o.node.name === 'imACompany2')\n            ).toBeTruthy();\n            expect(\n              result.companies.edges.some(o => o.node.name === 'imACompany3')\n            ).toBeTruthy();\n          }\n        );\n\n        it_only_db('mongo')('should support deep nested creation', async () => {\n          const team = new Parse.Object('Team');\n          team.set('name', 'imATeam1');\n          await team.save();\n\n          const company = new Parse.Object('Company');\n          company.set('name', 'imACompany1');\n          company.relation('teams').add(team);\n          await company.save();\n\n          const country = new Parse.Object('Country');\n          country.set('name', 'imACountry');\n          country.relation('companies').add(company);\n          await country.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const {\n            data: {\n              createCountry: { country: result },\n            },\n          } = await apolloClient.mutate({\n            mutation: gql`\n              mutation CreateCountry($fields: CreateCountryFieldsInput) {\n                createCountry(input: { fields: $fields }) {\n                  country {\n                    id\n                    name\n                    companies {\n                      edges {\n                        node {\n                          id\n                          name\n                          teams {\n                            edges {\n                              node {\n                                id\n                                name\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              fields: {\n                name: 'imACountry2',\n                companies: {\n                  createAndAdd: [\n                    {\n                      name: 'imACompany2',\n                      teams: {\n                        createAndAdd: {\n                          name: 'imATeam2',\n                        },\n                      },\n                    },\n                    {\n                      name: 'imACompany3',\n                      teams: {\n                        createAndAdd: {\n                          name: 'imATeam3',\n                        },\n                      },\n                    },\n                  ],\n                },\n              },\n            },\n          });\n\n          expect(result.id).toBeDefined();\n          expect(result.name).toEqual('imACountry2');\n          expect(result.companies.edges.length).toEqual(2);\n          expect(\n            result.companies.edges.some(\n              c =>\n                c.node.name === 'imACompany2' &&\n                c.node.teams.edges.some(t => t.node.name === 'imATeam2')\n            )\n          ).toBeTruthy();\n          expect(\n            result.companies.edges.some(\n              c =>\n                c.node.name === 'imACompany3' &&\n                c.node.teams.edges.some(t => t.node.name === 'imATeam3')\n            )\n          ).toBeTruthy();\n        });\n\n        it_only_db('mongo')(\n          'should support relation and nested relation on update',\n          async () => {\n            const company1 = new Parse.Object('Company');\n            company1.set('name', 'imACompany1');\n            await company1.save();\n\n            const company2 = new Parse.Object('Company');\n            company2.set('name', 'imACompany2');\n            await company2.save();\n\n            const country = new Parse.Object('Country');\n            country.set('name', 'imACountry');\n            country.relation('companies').add(company1);\n            await country.save();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const {\n              data: {\n                updateCountry: { country: result },\n              },\n            } = await apolloClient.mutate({\n              mutation: gql`\n                mutation UpdateCountry(\n                  $id: ID!\n                  $fields: UpdateCountryFieldsInput\n                ) {\n                  updateCountry(input: { id: $id, fields: $fields }) {\n                    country {\n                      id\n                      objectId\n                      companies {\n                        edges {\n                          node {\n                            id\n                            objectId\n                            name\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: country.id,\n                fields: {\n                  companies: {\n                    add: [company2.id],\n                    remove: [company1.id],\n                    createAndAdd: [\n                      {\n                        name: 'imACompany3',\n                      },\n                    ],\n                  },\n                },\n              },\n            });\n\n            expect(result.objectId).toEqual(country.id);\n            expect(result.companies.edges.length).toEqual(2);\n            expect(\n              result.companies.edges.some(o => o.node.objectId === company2.id)\n            ).toBeTruthy();\n            expect(\n              result.companies.edges.some(o => o.node.name === 'imACompany3')\n            ).toBeTruthy();\n            expect(\n              result.companies.edges.some(o => o.node.objectId === company1.id)\n            ).toBeFalsy();\n          }\n        );\n\n        it_only_db('mongo')(\n          'should support nested relation on create with filter',\n          async () => {\n            const company = new Parse.Object('Company');\n            company.set('name', 'imACompany1');\n            await company.save();\n\n            const country = new Parse.Object('Country');\n            country.set('name', 'imACountry');\n            country.relation('companies').add(company);\n            await country.save();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const {\n              data: {\n                createCountry: { country: result },\n              },\n            } = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateCountry(\n                  $fields: CreateCountryFieldsInput\n                  $where: CompanyWhereInput\n                ) {\n                  createCountry(input: { fields: $fields }) {\n                    country {\n                      id\n                      name\n                      companies(where: $where) {\n                        edges {\n                          node {\n                            id\n                            name\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where: {\n                  name: {\n                    equalTo: 'imACompany2',\n                  },\n                },\n                fields: {\n                  name: 'imACountry2',\n                  companies: {\n                    add: [company.id],\n                    createAndAdd: [\n                      {\n                        name: 'imACompany2',\n                      },\n                      {\n                        name: 'imACompany3',\n                      },\n                    ],\n                  },\n                },\n              },\n            });\n\n            expect(result.id).toBeDefined();\n            expect(result.name).toEqual('imACountry2');\n            expect(result.companies.edges.length).toEqual(1);\n            expect(\n              result.companies.edges.some(o => o.node.name === 'imACompany2')\n            ).toBeTruthy();\n          }\n        );\n\n        it_only_db('mongo')('should support relation on query', async () => {\n          const company1 = new Parse.Object('Company');\n          company1.set('name', 'imACompany1');\n          await company1.save();\n\n          const company2 = new Parse.Object('Company');\n          company2.set('name', 'imACompany2');\n          await company2.save();\n\n          const country = new Parse.Object('Country');\n          country.set('name', 'imACountry');\n          country.relation('companies').add([company1, company2]);\n          await country.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          // Without where\n          const {\n            data: { country: result1 },\n          } = await apolloClient.query({\n            query: gql`\n              query getCountry($id: ID!) {\n                country(id: $id) {\n                  id\n                  objectId\n                  companies {\n                    edges {\n                      node {\n                        id\n                        objectId\n                        name\n                      }\n                    }\n                    count\n                  }\n                }\n              }\n            `,\n            variables: {\n              id: country.id,\n            },\n          });\n\n          expect(result1.objectId).toEqual(country.id);\n          expect(result1.companies.edges.length).toEqual(2);\n          expect(\n            result1.companies.edges.some(o => o.node.objectId === company1.id)\n          ).toBeTruthy();\n          expect(\n            result1.companies.edges.some(o => o.node.objectId === company2.id)\n          ).toBeTruthy();\n\n          // With where\n          const {\n            data: { country: result2 },\n          } = await apolloClient.query({\n            query: gql`\n              query getCountry($id: ID!, $where: CompanyWhereInput) {\n                country(id: $id) {\n                  id\n                  objectId\n                  companies(where: $where) {\n                    edges {\n                      node {\n                        id\n                        objectId\n                        name\n                      }\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              id: country.id,\n              where: {\n                name: { equalTo: 'imACompany1' },\n              },\n            },\n          });\n          expect(result2.objectId).toEqual(country.id);\n          expect(result2.companies.edges.length).toEqual(1);\n          expect(result2.companies.edges[0].node.objectId).toEqual(company1.id);\n        });\n\n        it_only_db('mongo')(\n          'should support relational where query',\n          async () => {\n            const president = new Parse.Object('President');\n            president.set('name', 'James');\n            await president.save();\n\n            const employee = new Parse.Object('Employee');\n            employee.set('name', 'John');\n            await employee.save();\n\n            const company1 = new Parse.Object('Company');\n            company1.set('name', 'imACompany1');\n            await company1.save();\n\n            const company2 = new Parse.Object('Company');\n            company2.set('name', 'imACompany2');\n            company2.relation('employees').add([employee]);\n            await company2.save();\n\n            const country = new Parse.Object('Country');\n            country.set('name', 'imACountry');\n            country.relation('companies').add([company1, company2]);\n            await country.save();\n\n            const country2 = new Parse.Object('Country');\n            country2.set('name', 'imACountry2');\n            country2.relation('companies').add([company1]);\n            await country2.save();\n\n            const country3 = new Parse.Object('Country');\n            country3.set('name', 'imACountry3');\n            country3.set('president', president);\n            await country3.save();\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            let {\n              data: {\n                countries: { edges: result },\n              },\n            } = await apolloClient.query({\n              query: gql`\n                query findCountry($where: CountryWhereInput) {\n                  countries(where: $where) {\n                    edges {\n                      node {\n                        id\n                        objectId\n                        companies {\n                          edges {\n                            node {\n                              id\n                              objectId\n                              name\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where: {\n                  companies: {\n                    have: {\n                      employees: { have: { name: { equalTo: 'John' } } },\n                    },\n                  },\n                },\n              },\n            });\n            expect(result.length).toEqual(1);\n            result = result[0].node;\n            expect(result.objectId).toEqual(country.id);\n            expect(result.companies.edges.length).toEqual(2);\n\n            const {\n              data: {\n                countries: { edges: result2 },\n              },\n            } = await apolloClient.query({\n              query: gql`\n                query findCountry($where: CountryWhereInput) {\n                  countries(where: $where) {\n                    edges {\n                      node {\n                        id\n                        objectId\n                        companies {\n                          edges {\n                            node {\n                              id\n                              objectId\n                              name\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where: {\n                  companies: {\n                    have: {\n                      OR: [\n                        { name: { equalTo: 'imACompany1' } },\n                        { name: { equalTo: 'imACompany2' } },\n                      ],\n                    },\n                  },\n                },\n              },\n            });\n            expect(result2.length).toEqual(2);\n\n            const {\n              data: {\n                countries: { edges: result3 },\n              },\n            } = await apolloClient.query({\n              query: gql`\n                query findCountry($where: CountryWhereInput) {\n                  countries(where: $where) {\n                    edges {\n                      node {\n                        id\n                        name\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where: {\n                  companies: { exists: false },\n                },\n              },\n            });\n            expect(result3.length).toEqual(1);\n            expect(result3[0].node.name).toEqual('imACountry3');\n\n            const {\n              data: {\n                countries: { edges: result4 },\n              },\n            } = await apolloClient.query({\n              query: gql`\n                query findCountry($where: CountryWhereInput) {\n                  countries(where: $where) {\n                    edges {\n                      node {\n                        id\n                        name\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where: {\n                  president: { exists: false },\n                },\n              },\n            });\n            expect(result4.length).toEqual(2);\n            const {\n              data: {\n                countries: { edges: result5 },\n              },\n            } = await apolloClient.query({\n              query: gql`\n                query findCountry($where: CountryWhereInput) {\n                  countries(where: $where) {\n                    edges {\n                      node {\n                        id\n                        name\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where: {\n                  president: { exists: true },\n                },\n              },\n            });\n            expect(result5.length).toEqual(1);\n            const {\n              data: {\n                countries: { edges: result6 },\n              },\n            } = await apolloClient.query({\n              query: gql`\n                query findCountry($where: CountryWhereInput) {\n                  countries(where: $where) {\n                    edges {\n                      node {\n                        id\n                        objectId\n                        name\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where: {\n                  companies: {\n                    haveNot: {\n                      OR: [\n                        { name: { equalTo: 'imACompany1' } },\n                        { name: { equalTo: 'imACompany2' } },\n                      ],\n                    },\n                  },\n                },\n              },\n            });\n            expect(result6.length).toEqual(1);\n            expect(result6.length).toEqual(1);\n            expect(result6[0].node.name).toEqual('imACountry3');\n          }\n        );\n\n        it('should support files', async () => {\n          try {\n            parseServer = await global.reconfigureServer({\n              publicServerURL: 'http://localhost:13377/parse',\n            });\n\n            const body = new FormData();\n            body.append(\n              'operations',\n              JSON.stringify({\n                query: `\n                  mutation CreateFile($input: CreateFileInput!) {\n                    createFile(input: $input) {\n                      fileInfo {\n                        name\n                        url\n                      }\n                    }\n                  }\n                `,\n                variables: {\n                  input: {\n                    upload: null,\n                  },\n                },\n              })\n            );\n            body.append(\n              'map',\n              JSON.stringify({ 1: ['variables.input.upload'] })\n            );\n            body.append('1', 'My File Content', {\n              filename: 'myFileName.txt',\n              contentType: 'text/plain',\n            });\n\n            let res = await fetch('http://localhost:13377/graphql', {\n              method: 'POST',\n              headers,\n              body,\n            });\n\n            expect(res.status).toEqual(200);\n\n            const result = JSON.parse(await res.text());\n\n            expect(result.data.createFile.fileInfo.name).toEqual(\n              jasmine.stringMatching(/_myFileName.txt$/)\n            );\n            expect(result.data.createFile.fileInfo.url).toEqual(\n              jasmine.stringMatching(/_myFileName.txt$/)\n            );\n\n            const someFieldValue = result.data.createFile.fileInfo.name;\n            const someFieldObjectValue = result.data.createFile.fileInfo;\n\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(\n                    input: { name: \"SomeClass\", schemaFields: $schemaFields }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addFiles: [{ name: 'someField' }],\n                },\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const body2 = new FormData();\n            body2.append(\n              'operations',\n              JSON.stringify({\n                query: `\n                mutation CreateSomeObject(\n                  $fields1: CreateSomeClassFieldsInput\n                  $fields2: CreateSomeClassFieldsInput\n                  $fields3: CreateSomeClassFieldsInput\n                ) {\n                  createSomeClass1: createSomeClass(\n                    input: { fields: $fields1 }\n                  ) {\n                    someClass {\n                      id\n                      someField {\n                        name\n                        url\n                      }\n                    }\n                  }\n                  createSomeClass2: createSomeClass(\n                    input: { fields: $fields2 }\n                  ) {\n                    someClass {\n                      id\n                      someField {\n                        name\n                        url\n                      }\n                    }\n                  }\n                  createSomeClass3: createSomeClass(\n                    input: { fields: $fields3 }\n                  ) {\n                    someClass {\n                      id\n                      someField {\n                        name\n                        url\n                      }\n                    }\n                  }\n                }\n                `,\n                variables: {\n                  fields1: {\n                    someField: { file: someFieldValue },\n                  },\n                  fields2: {\n                    someField: {\n                      file: {\n                        name: someFieldObjectValue.name,\n                        url: someFieldObjectValue.url,\n                        __type: 'File',\n                      },\n                    },\n                  },\n                  fields3: {\n                    someField: { upload: null },\n                  },\n                },\n              })\n            );\n            body2.append(\n              'map',\n              JSON.stringify({ 1: ['variables.fields3.someField.upload'] })\n            );\n            body2.append('1', 'My File Content', {\n              filename: 'myFileName.txt',\n              contentType: 'text/plain',\n            });\n\n            res = await fetch('http://localhost:13377/graphql', {\n              method: 'POST',\n              headers,\n              body: body2,\n            });\n            expect(res.status).toEqual(200);\n            const result2 = JSON.parse(await res.text());\n            expect(\n              result2.data.createSomeClass1.someClass.someField.name\n            ).toEqual(jasmine.stringMatching(/_myFileName.txt$/));\n            expect(\n              result2.data.createSomeClass1.someClass.someField.url\n            ).toEqual(jasmine.stringMatching(/_myFileName.txt$/));\n            expect(\n              result2.data.createSomeClass2.someClass.someField.name\n            ).toEqual(jasmine.stringMatching(/_myFileName.txt$/));\n            expect(\n              result2.data.createSomeClass2.someClass.someField.url\n            ).toEqual(jasmine.stringMatching(/_myFileName.txt$/));\n            expect(\n              result2.data.createSomeClass3.someClass.someField.name\n            ).toEqual(jasmine.stringMatching(/_myFileName.txt$/));\n            expect(\n              result2.data.createSomeClass3.someClass.someField.url\n            ).toEqual(jasmine.stringMatching(/_myFileName.txt$/));\n\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.someField.type).toEqual('File');\n\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!) {\n                  someClass(id: $id) {\n                    someField {\n                      name\n                      url\n                    }\n                  }\n                  findSomeClass1: someClasses(\n                    where: { someField: { exists: true } }\n                  ) {\n                    edges {\n                      node {\n                        someField {\n                          name\n                          url\n                        }\n                      }\n                    }\n                  }\n                  findSomeClass2: someClasses(\n                    where: { someField: { exists: true } }\n                  ) {\n                    edges {\n                      node {\n                        someField {\n                          name\n                          url\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: result2.data.createSomeClass1.someClass.id,\n              },\n            });\n\n            expect(typeof getResult.data.someClass.someField).toEqual('object');\n            expect(getResult.data.someClass.someField.name).toEqual(\n              result.data.createFile.fileInfo.name\n            );\n            expect(getResult.data.someClass.someField.url).toEqual(\n              result.data.createFile.fileInfo.url\n            );\n            expect(getResult.data.findSomeClass1.edges.length).toEqual(3);\n            expect(getResult.data.findSomeClass2.edges.length).toEqual(3);\n\n            res = await fetch(getResult.data.someClass.someField.url);\n\n            expect(res.status).toEqual(200);\n            expect(await res.text()).toEqual('My File Content');\n\n            const mutationResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation UnlinkFile($id: ID!) {\n                  updateSomeClass(\n                    input: { id: $id, fields: { someField: { file: null } } }\n                  ) {\n                    someClass {\n                      someField {\n                        name\n                        url\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: result2.data.createSomeClass3.someClass.id,\n              },\n            });\n            expect(\n              mutationResult.data.updateSomeClass.someClass.someField\n            ).toEqual(null);\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should support object values', async () => {\n          try {\n            const someFieldValue = {\n              foo: { bar: 'baz' },\n              number: 10,\n            };\n\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(\n                    input: { name: \"SomeClass\", schemaFields: $schemaFields }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addObjects: [{ name: 'someField' }],\n                },\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.someField.type).toEqual('Object');\n\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                  createSomeClass(input: { fields: $fields }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  someField: someFieldValue,\n                },\n              },\n            });\n\n            const where = {\n              someField: {\n                equalTo: { key: 'foo.bar', value: 'baz' },\n                notEqualTo: { key: 'foo.bar', value: 'bat' },\n                greaterThan: { key: 'number', value: 9 },\n                lessThan: { key: 'number', value: 11 },\n              },\n            };\n            const queryResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!, $where: SomeClassWhereInput) {\n                  someClass(id: $id) {\n                    id\n                    someField\n                  }\n                  someClasses(where: $where) {\n                    edges {\n                      node {\n                        id\n                        someField\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id,\n                where,\n              },\n            });\n\n            const { someClass: getResult, someClasses } = queryResult.data;\n\n            const { someField } = getResult;\n            expect(typeof someField).toEqual('object');\n            expect(someField).toEqual(someFieldValue);\n\n            // Checks class query results\n            expect(someClasses.edges.length).toEqual(1);\n            expect(someClasses.edges[0].node.someField).toEqual(someFieldValue);\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should support object composed queries', async () => {\n          try {\n            const someFieldValue = {\n              lorem: 'ipsum',\n              number: 10,\n            };\n            const someFieldValue2 = {\n              foo: {\n                test: 'bar',\n              },\n              number: 10,\n            };\n\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass {\n                  createClass(\n                    input: {\n                      name: \"SomeClass\"\n                      schemaFields: { addObjects: [{ name: \"someField\" }] }\n                    }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject(\n                  $fields1: CreateSomeClassFieldsInput\n                  $fields2: CreateSomeClassFieldsInput\n                ) {\n                  create1: createSomeClass(input: { fields: $fields1 }) {\n                    someClass {\n                      id\n                    }\n                  }\n                  create2: createSomeClass(input: { fields: $fields2 }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields1: {\n                  someField: someFieldValue,\n                },\n                fields2: {\n                  someField: someFieldValue2,\n                },\n              },\n            });\n\n            const where = {\n              AND: [\n                {\n                  someField: {\n                    greaterThan: { key: 'number', value: 9 },\n                  },\n                },\n                {\n                  someField: {\n                    lessThan: { key: 'number', value: 11 },\n                  },\n                },\n                {\n                  OR: [\n                    {\n                      someField: {\n                        equalTo: { key: 'lorem', value: 'ipsum' },\n                      },\n                    },\n                    {\n                      someField: {\n                        equalTo: { key: 'foo.test', value: 'bar' },\n                      },\n                    },\n                  ],\n                },\n              ],\n            };\n            const findResult = await apolloClient.query({\n              query: gql`\n                query FindSomeObject($where: SomeClassWhereInput) {\n                  someClasses(where: $where) {\n                    edges {\n                      node {\n                        id\n                        someField\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where,\n              },\n            });\n\n            const { create1, create2 } = createResult.data;\n            const { someClasses } = findResult.data;\n\n            // Checks class query results\n            const { edges } = someClasses;\n            expect(edges.length).toEqual(2);\n            expect(\n              edges.find(result => result.node.id === create1.someClass.id).node\n                .someField\n            ).toEqual(someFieldValue);\n            expect(\n              edges.find(result => result.node.id === create2.someClass.id).node\n                .someField\n            ).toEqual(someFieldValue2);\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should support array values', async () => {\n          try {\n            const someFieldValue = [\n              1,\n              'foo',\n              ['bar'],\n              { lorem: 'ipsum' },\n              true,\n            ];\n\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(\n                    input: { name: \"SomeClass\", schemaFields: $schemaFields }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addArrays: [{ name: 'someField' }],\n                },\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.someField.type).toEqual('Array');\n\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                  createSomeClass(input: { fields: $fields }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  someField: someFieldValue,\n                },\n              },\n            });\n\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!) {\n                  someClass(id: $id) {\n                    someField {\n                      ... on Element {\n                        value\n                      }\n                    }\n                  }\n                  someClasses(where: { someField: { exists: true } }) {\n                    edges {\n                      node {\n                        id\n                        someField {\n                          ... on Element {\n                            value\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id,\n              },\n            });\n\n            const { someField } = getResult.data.someClass;\n            expect(Array.isArray(someField)).toBeTruthy();\n            expect(someField.map(element => element.value)).toEqual(\n              someFieldValue\n            );\n            expect(getResult.data.someClasses.edges.length).toEqual(1);\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should support undefined array', async () => {\n          const schema = await new Parse.Schema('SomeClass');\n          schema.addArray('someArray');\n          await schema.save();\n\n          const obj = new Parse.Object('SomeClass');\n          await obj.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const getResult = await apolloClient.query({\n            query: gql`\n              query GetSomeObject($id: ID!) {\n                someClass(id: $id) {\n                  id\n                  someArray {\n                    ... on Element {\n                      value\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              id: obj.id,\n            },\n          });\n          expect(getResult.data.someClass.someArray).toEqual(null);\n        });\n\n        it('should support null values', async () => {\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass {\n                  createClass(\n                    input: {\n                      name: \"SomeClass\"\n                      schemaFields: {\n                        addStrings: [\n                          { name: \"someStringField\" }\n                          { name: \"someNullField\" }\n                        ]\n                        addNumbers: [{ name: \"someNumberField\" }]\n                        addBooleans: [{ name: \"someBooleanField\" }]\n                        addObjects: [{ name: \"someObjectField\" }]\n                      }\n                    }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                  createSomeClass(input: { fields: $fields }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  someStringField: 'some string',\n                  someNumberField: 123,\n                  someBooleanField: true,\n                  someObjectField: { someField: 'some value' },\n                  someNullField: null,\n                },\n              },\n            });\n\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation UpdateSomeObject(\n                  $id: ID!\n                  $fields: UpdateSomeClassFieldsInput\n                ) {\n                  updateSomeClass(input: { id: $id, fields: $fields }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id,\n                fields: {\n                  someStringField: null,\n                  someNumberField: null,\n                  someBooleanField: null,\n                  someObjectField: null,\n                  someNullField: 'now it has a string',\n                },\n              },\n            });\n\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!) {\n                  someClass(id: $id) {\n                    someStringField\n                    someNumberField\n                    someBooleanField\n                    someObjectField\n                    someNullField\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id,\n              },\n            });\n\n            expect(getResult.data.someClass.someStringField).toBeFalsy();\n            expect(getResult.data.someClass.someNumberField).toBeFalsy();\n            expect(getResult.data.someClass.someBooleanField).toBeFalsy();\n            expect(getResult.data.someClass.someObjectField).toBeFalsy();\n            expect(getResult.data.someClass.someNullField).toEqual(\n              'now it has a string'\n            );\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should support Bytes', async () => {\n          try {\n            const someFieldValue = 'aGVsbG8gd29ybGQ=';\n\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(\n                    input: { name: \"SomeClass\", schemaFields: $schemaFields }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addBytes: [{ name: 'someField' }],\n                },\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.someField.type).toEqual('Bytes');\n\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject(\n                  $fields1: CreateSomeClassFieldsInput\n                  $fields2: CreateSomeClassFieldsInput\n                ) {\n                  createSomeClass1: createSomeClass(\n                    input: { fields: $fields1 }\n                  ) {\n                    someClass {\n                      id\n                    }\n                  }\n                  createSomeClass2: createSomeClass(\n                    input: { fields: $fields2 }\n                  ) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields1: {\n                  someField: someFieldValue,\n                },\n                fields2: {\n                  someField: someFieldValue,\n                },\n              },\n            });\n\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!, $someFieldValue: Bytes) {\n                  someClass(id: $id) {\n                    someField\n                  }\n                  someClasses(\n                    where: { someField: { equalTo: $someFieldValue } }\n                  ) {\n                    edges {\n                      node {\n                        id\n                        someField\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass1.someClass.id,\n                someFieldValue,\n              },\n            });\n\n            expect(typeof getResult.data.someClass.someField).toEqual('string');\n            expect(getResult.data.someClass.someField).toEqual(someFieldValue);\n            expect(getResult.data.someClasses.edges.length).toEqual(2);\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should support Geo Points', async () => {\n          try {\n            const someFieldValue = {\n              __typename: 'GeoPoint',\n              latitude: 45,\n              longitude: 45,\n            };\n\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(\n                    input: { name: \"SomeClass\", schemaFields: $schemaFields }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addGeoPoint: { name: 'someField' },\n                },\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.someField.type).toEqual('GeoPoint');\n\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                  createSomeClass(input: { fields: $fields }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  someField: {\n                    latitude: someFieldValue.latitude,\n                    longitude: someFieldValue.longitude,\n                  },\n                },\n              },\n            });\n\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!) {\n                  someClass(id: $id) {\n                    someField {\n                      latitude\n                      longitude\n                    }\n                  }\n                  someClasses(where: { someField: { exists: true } }) {\n                    edges {\n                      node {\n                        id\n                        someField {\n                          latitude\n                          longitude\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id,\n              },\n            });\n\n            expect(typeof getResult.data.someClass.someField).toEqual('object');\n            expect(getResult.data.someClass.someField).toEqual(someFieldValue);\n            expect(getResult.data.someClasses.edges.length).toEqual(1);\n\n            const getGeoWhere = await apolloClient.query({\n              query: gql`\n                query GeoQuery($latitude: Float!, $longitude: Float!) {\n                  nearSphere: someClasses(\n                    where: {\n                      someField: {\n                        nearSphere: {\n                          latitude: $latitude\n                          longitude: $longitude\n                        }\n                      }\n                    }\n                  ) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                  geoWithin: someClasses(\n                    where: {\n                      someField: {\n                        geoWithin: {\n                          centerSphere: {\n                            distance: 10\n                            center: {\n                              latitude: $latitude\n                              longitude: $longitude\n                            }\n                          }\n                        }\n                      }\n                    }\n                  ) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                  within: someClasses(\n                    where: {\n                      someField: {\n                        within: {\n                          box: {\n                            bottomLeft: {\n                              latitude: $latitude\n                              longitude: $longitude\n                            }\n                            upperRight: {\n                              latitude: $latitude\n                              longitude: $longitude\n                            }\n                          }\n                        }\n                      }\n                    }\n                  ) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                latitude: 45,\n                longitude: 45,\n              },\n            });\n            expect(getGeoWhere.data.nearSphere.edges[0].node.id).toEqual(\n              createResult.data.createSomeClass.someClass.id\n            );\n            expect(getGeoWhere.data.geoWithin.edges[0].node.id).toEqual(\n              createResult.data.createSomeClass.someClass.id\n            );\n            expect(getGeoWhere.data.within.edges[0].node.id).toEqual(\n              createResult.data.createSomeClass.someClass.id\n            );\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it('should support Polygons', async () => {\n          try {\n            const somePolygonFieldValue = [\n              [44, 45],\n              [46, 47],\n              [48, 49],\n              [44, 45],\n            ].map(point => ({\n              latitude: point[0],\n              longitude: point[1],\n            }));\n\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(\n                    input: { name: \"SomeClass\", schemaFields: $schemaFields }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addPolygons: [{ name: 'somePolygonField' }],\n                },\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test',\n                },\n              },\n            });\n\n            await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.somePolygonField.type).toEqual('Polygon');\n\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                  createSomeClass(input: { fields: $fields }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  somePolygonField: somePolygonFieldValue,\n                },\n              },\n            });\n\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!) {\n                  someClass(id: $id) {\n                    somePolygonField {\n                      latitude\n                      longitude\n                    }\n                  }\n                  someClasses(where: { somePolygonField: { exists: true } }) {\n                    edges {\n                      node {\n                        id\n                        somePolygonField {\n                          latitude\n                          longitude\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id,\n              },\n            });\n\n            expect(typeof getResult.data.someClass.somePolygonField).toEqual(\n              'object'\n            );\n            expect(getResult.data.someClass.somePolygonField).toEqual(\n              somePolygonFieldValue.map(geoPoint => ({\n                ...geoPoint,\n                __typename: 'GeoPoint',\n              }))\n            );\n            expect(getResult.data.someClasses.edges.length).toEqual(1);\n            const getIntersect = await apolloClient.query({\n              query: gql`\n                query IntersectQuery($point: GeoPointInput!) {\n                  someClasses(\n                    where: {\n                      somePolygonField: { geoIntersects: { point: $point } }\n                    }\n                  ) {\n                    edges {\n                      node {\n                        id\n                        somePolygonField {\n                          latitude\n                          longitude\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                point: { latitude: 44, longitude: 45 },\n              },\n            });\n            expect(getIntersect.data.someClasses.edges.length).toEqual(1);\n            expect(getIntersect.data.someClasses.edges[0].node.id).toEqual(\n              createResult.data.createSomeClass.someClass.id\n            );\n          } catch (e) {\n            handleError(e);\n          }\n        });\n\n        it_only_db('mongo')('should support bytes values', async () => {\n          const SomeClass = Parse.Object.extend('SomeClass');\n          const someClass = new SomeClass();\n          someClass.set('someField', {\n            __type: 'Bytes',\n            base64: 'foo',\n          });\n          await someClass.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n          const schema = await new Parse.Schema('SomeClass').get();\n          expect(schema.fields.someField.type).toEqual('Bytes');\n\n          const someFieldValue = {\n            __type: 'Bytes',\n            base64: 'bytesContent',\n          };\n\n          const createResult = await apolloClient.mutate({\n            mutation: gql`\n              mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                createSomeClass(input: { fields: $fields }) {\n                  someClass {\n                    id\n                  }\n                }\n              }\n            `,\n            variables: {\n              fields: {\n                someField: someFieldValue,\n              },\n            },\n          });\n\n          const getResult = await apolloClient.query({\n            query: gql`\n              query GetSomeObject($id: ID!) {\n                someClass(id: $id) {\n                  someField\n                }\n              }\n            `,\n            variables: {\n              id: createResult.data.createSomeClass.someClass.id,\n            },\n          });\n\n          expect(getResult.data.someClass.someField).toEqual(\n            someFieldValue.base64\n          );\n\n          const updatedSomeFieldValue = {\n            __type: 'Bytes',\n            base64: 'newBytesContent',\n          };\n\n          const updatedResult = await apolloClient.mutate({\n            mutation: gql`\n              mutation UpdateSomeObject(\n                $id: ID!\n                $fields: UpdateSomeClassFieldsInput\n              ) {\n                updateSomeClass(input: { id: $id, fields: $fields }) {\n                  someClass {\n                    updatedAt\n                  }\n                }\n              }\n            `,\n            variables: {\n              id: createResult.data.createSomeClass.someClass.id,\n              fields: {\n                someField: updatedSomeFieldValue,\n              },\n            },\n          });\n\n          const { updatedAt } = updatedResult.data.updateSomeClass.someClass;\n          expect(updatedAt).toBeDefined();\n\n          const findResult = await apolloClient.query({\n            query: gql`\n              query FindSomeObject($where: SomeClassWhereInput!) {\n                someClasses(where: $where) {\n                  edges {\n                    node {\n                      id\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              where: {\n                someField: {\n                  equalTo: updatedSomeFieldValue.base64,\n                },\n              },\n            },\n          });\n          const findResults = findResult.data.someClasses.edges;\n          expect(findResults.length).toBe(1);\n          expect(findResults[0].node.id).toBe(\n            createResult.data.createSomeClass.someClass.id\n          );\n        });\n      });\n\n      describe('Special Classes', () => {\n        it('should support User class', async () => {\n          const user = new Parse.User();\n          user.setUsername('user1');\n          user.setPassword('user1');\n          await user.signUp();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const getResult = await apolloClient.query({\n            query: gql`\n              query GetSomeObject($id: ID!) {\n                get: user(id: $id) {\n                  objectId\n                }\n              }\n            `,\n            variables: {\n              id: user.id,\n            },\n          });\n\n          expect(getResult.data.get.objectId).toEqual(user.id);\n        });\n\n        it('should support Installation class', async () => {\n          const installation = new Parse.Installation();\n          await installation.save({\n            deviceType: 'foo',\n          });\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const getResult = await apolloClient.query({\n            query: gql`\n              query GetSomeObject($id: ID!) {\n                get: installation(id: $id) {\n                  objectId\n                }\n              }\n            `,\n            variables: {\n              id: installation.id,\n            },\n          });\n\n          expect(getResult.data.get.objectId).toEqual(installation.id);\n        });\n\n        it('should support Role class', async () => {\n          const roleACL = new Parse.ACL();\n          roleACL.setPublicReadAccess(true);\n          const role = new Parse.Role('MyRole', roleACL);\n          await role.save();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const getResult = await apolloClient.query({\n            query: gql`\n              query GetSomeObject($id: ID!) {\n                get: role(id: $id) {\n                  objectId\n                }\n              }\n            `,\n            variables: {\n              id: role.id,\n            },\n          });\n\n          expect(getResult.data.get.objectId).toEqual(role.id);\n        });\n\n        it('should support Session class', async () => {\n          const user = new Parse.User();\n          user.setUsername('user1');\n          user.setPassword('user1');\n          await user.signUp();\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const session = await Parse.Session.current();\n          const getResult = await apolloClient.query({\n            query: gql`\n              query GetSomeObject($id: ID!) {\n                get: session(id: $id) {\n                  id\n                  objectId\n                }\n              }\n            `,\n            variables: {\n              id: session.id,\n            },\n            context: {\n              headers: {\n                'X-Parse-Session-Token': session.getSessionToken(),\n              },\n            },\n          });\n\n          expect(getResult.data.get.objectId).toEqual(session.id);\n        });\n\n        it('should support Product class', async () => {\n          const Product = Parse.Object.extend('_Product');\n          const product = new Product();\n          await product.save(\n            {\n              productIdentifier: 'foo',\n              icon: new Parse.File('icon', ['foo']),\n              order: 1,\n              title: 'Foo',\n              subtitle: 'My product',\n            },\n            { useMasterKey: true }\n          );\n\n          await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n\n          const getResult = await apolloClient.query({\n            query: gql`\n              query GetSomeObject($id: ID!) {\n                get: product(id: $id) {\n                  objectId\n                }\n              }\n            `,\n            variables: {\n              id: product.id,\n            },\n            context: {\n              headers: {\n                'X-Parse-Master-Key': 'test',\n              },\n            },\n          });\n\n          expect(getResult.data.get.objectId).toEqual(product.id);\n        });\n      });\n    });\n  });\n\n  describe('Custom API', () => {\n    describe('GraphQL Schema Based', () => {\n      let httpServer;\n      const headers = {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-Javascript-Key': 'test',\n      };\n      let apolloClient;\n      beforeAll(async () => {\n        const expressApp = express();\n        httpServer = http.createServer(expressApp);\n        parseGraphQLServer = new ParseGraphQLServer(parseServer, {\n          graphQLPath: '/graphql',\n          graphQLCustomTypeDefs: gql`\n            extend type Query {\n              hello: String @resolve\n              hello2: String @resolve(to: \"hello\")\n              userEcho(user: CreateUserFieldsInput!): User! @resolve\n              hello3: String! @mock(with: \"Hello world!\")\n              hello4: User! @mock(with: { username: \"somefolk\" })\n            }\n          `,\n        });\n        parseGraphQLServer.applyGraphQL(expressApp);\n        await new Promise(resolve =>\n          httpServer.listen({ port: 13377 }, resolve)\n        );\n        const httpLink = createUploadLink({\n          uri: 'http://localhost:13377/graphql',\n          fetch,\n          headers,\n        });\n        apolloClient = new ApolloClient({\n          link: httpLink,\n          cache: new InMemoryCache(),\n          defaultOptions: {\n            query: {\n              fetchPolicy: 'no-cache',\n            },\n          },\n        });\n      });\n\n      afterAll(async () => {\n        await httpServer.close();\n      });\n\n      it('can resolve a custom query using default function name', async () => {\n        Parse.Cloud.define('hello', async () => {\n          return 'Hello world!';\n        });\n\n        const result = await apolloClient.query({\n          query: gql`\n            query Hello {\n              hello\n            }\n          `,\n        });\n\n        expect(result.data.hello).toEqual('Hello world!');\n      });\n\n      it('can resolve a custom query using function name set by \"to\" argument', async () => {\n        Parse.Cloud.define('hello', async () => {\n          return 'Hello world!';\n        });\n\n        const result = await apolloClient.query({\n          query: gql`\n            query Hello {\n              hello2\n            }\n          `,\n        });\n\n        expect(result.data.hello2).toEqual('Hello world!');\n      });\n\n      it('order option should continue working', async () => {\n        const schemaController = await parseServer.config.databaseController.loadSchema();\n\n        await schemaController.addClassIfNotExists('SuperCar', {\n          engine: { type: 'String' },\n          doors: { type: 'Number' },\n          price: { type: 'String' },\n          mileage: { type: 'Number' },\n        });\n\n        await new Parse.Object('SuperCar').save({\n          engine: 'petrol',\n          doors: 3,\n          price: '\u00a37500',\n          mileage: 0,\n        });\n\n        await new Parse.Object('SuperCar').save({\n          engine: 'petrol',\n          doors: 3,\n          price: '\u00a37500',\n          mileage: 10000,\n        });\n\n        await Promise.all([\n          parseGraphQLServer.parseGraphQLController.cacheController.graphQL.clear(),\n          parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear(),\n        ]);\n\n        await expectAsync(\n          apolloClient.query({\n            query: gql`\n              query FindSuperCar {\n                superCars(order: [mileage_ASC]) {\n                  edges {\n                    node {\n                      id\n                    }\n                  }\n                }\n              }\n            `,\n          })\n        ).toBeResolved();\n      });\n    });\n\n    describe('SDL Based', () => {\n      let httpServer;\n      const headers = {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-Javascript-Key': 'test',\n      };\n      let apolloClient;\n\n      beforeAll(async () => {\n        const expressApp = express();\n        httpServer = http.createServer(expressApp);\n        const TypeEnum = new GraphQLEnumType({\n          name: 'TypeEnum',\n          values: {\n            human: { value: 'human' },\n            robot: { value: 'robot' },\n          },\n        });\n        const SomeClassType = new GraphQLObjectType({\n            name: 'SomeClass',\n            fields: {\n              nameUpperCase: {\n                type: new GraphQLNonNull(GraphQLString),\n                resolve: p => p.name.toUpperCase(),\n              },\n              type: { type: TypeEnum },\n              language: {\n                type: new GraphQLEnumType({\n                  name: 'LanguageEnum',\n                  values: {\n                    fr: { value: 'fr' },\n                    en: { value: 'en' },\n                  },\n                }),\n                resolve: () => 'fr',\n              },\n            },\n          }),\n          parseGraphQLServer = new ParseGraphQLServer(parseServer, {\n            graphQLPath: '/graphql',\n            graphQLCustomTypeDefs: new GraphQLSchema({\n              query: new GraphQLObjectType({\n                name: 'Query',\n                fields: {\n                  customQuery: {\n                    type: new GraphQLNonNull(GraphQLString),\n                    args: {\n                      message: { type: new GraphQLNonNull(GraphQLString) },\n                    },\n                    resolve: (p, { message }) => message,\n                  },\n                  customQueryWithAutoTypeReturn: {\n                    type: SomeClassType,\n                    args: {\n                      id: { type: new GraphQLNonNull(GraphQLString) },\n                    },\n                    resolve: async (p, { id }) => {\n                      const obj = new Parse.Object('SomeClass');\n                      obj.id = id;\n                      await obj.fetch();\n                      return obj.toJSON();\n                    },\n                  },\n                },\n              }),\n              types: [\n                new GraphQLInputObjectType({\n                  name: 'CreateSomeClassFieldsInput',\n                  fields: {\n                    type: { type: TypeEnum },\n                  },\n                }),\n                new GraphQLInputObjectType({\n                  name: 'UpdateSomeClassFieldsInput',\n                  fields: {\n                    type: { type: TypeEnum },\n                  },\n                }),\n                SomeClassType,\n              ],\n            }),\n          });\n\n        parseGraphQLServer.applyGraphQL(expressApp);\n        await new Promise(resolve =>\n          httpServer.listen({ port: 13377 }, resolve)\n        );\n        const httpLink = createUploadLink({\n          uri: 'http://localhost:13377/graphql',\n          fetch,\n          headers,\n        });\n        apolloClient = new ApolloClient({\n          link: httpLink,\n          cache: new InMemoryCache(),\n          defaultOptions: {\n            query: {\n              fetchPolicy: 'no-cache',\n            },\n          },\n        });\n      });\n\n      afterAll(async () => {\n        await httpServer.close();\n      });\n\n      it('can resolve a custom query', async () => {\n        const result = await apolloClient.query({\n          variables: { message: 'hello' },\n          query: gql`\n            query CustomQuery($message: String!) {\n              customQuery(message: $message)\n            }\n          `,\n        });\n        expect(result.data.customQuery).toEqual('hello');\n      });\n\n      it('can resolve a custom query with auto type return', async () => {\n        const obj = new Parse.Object('SomeClass');\n        await obj.save({ name: 'aname', type: 'robot' });\n        await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n        const result = await apolloClient.query({\n          variables: { id: obj.id },\n          query: gql`\n            query CustomQuery($id: String!) {\n              customQueryWithAutoTypeReturn(id: $id) {\n                objectId\n                nameUpperCase\n                name\n                type\n              }\n            }\n          `,\n        });\n        expect(result.data.customQueryWithAutoTypeReturn.objectId).toEqual(\n          obj.id\n        );\n        expect(result.data.customQueryWithAutoTypeReturn.name).toEqual('aname');\n        expect(result.data.customQueryWithAutoTypeReturn.nameUpperCase).toEqual(\n          'ANAME'\n        );\n        expect(result.data.customQueryWithAutoTypeReturn.type).toEqual('robot');\n      });\n\n      it('can resolve a custom extend type', async () => {\n        const obj = new Parse.Object('SomeClass');\n        await obj.save({ name: 'aname', type: 'robot' });\n        await parseGraphQLServer.parseGraphQLSchema.databaseController.schemaCache.clear();\n        const result = await apolloClient.query({\n          variables: { id: obj.id },\n          query: gql`\n            query someClass($id: ID!) {\n              someClass(id: $id) {\n                nameUpperCase\n                language\n                type\n              }\n            }\n          `,\n        });\n        expect(result.data.someClass.nameUpperCase).toEqual('ANAME');\n        expect(result.data.someClass.language).toEqual('fr');\n        expect(result.data.someClass.type).toEqual('robot');\n\n        const result2 = await apolloClient.query({\n          variables: { id: obj.id },\n          query: gql`\n            query someClass($id: ID!) {\n              someClass(id: $id) {\n                name\n                language\n              }\n            }\n          `,\n        });\n        expect(result2.data.someClass.name).toEqual('aname');\n        expect(result.data.someClass.language).toEqual('fr');\n        const result3 = await apolloClient.mutate({\n          variables: { id: obj.id, name: 'anewname', type: 'human' },\n          mutation: gql`\n            mutation someClass($id: ID!, $name: String!, $type: TypeEnum!) {\n              updateSomeClass(\n                input: { id: $id, fields: { name: $name, type: $type } }\n              ) {\n                someClass {\n                  nameUpperCase\n                  type\n                }\n              }\n            }\n          `,\n        });\n        expect(result3.data.updateSomeClass.someClass.nameUpperCase).toEqual(\n          'ANEWNAME'\n        );\n        expect(result3.data.updateSomeClass.someClass.type).toEqual('human');\n      });\n    });\n    describe('Async Function Based Merge', () => {\n      let httpServer;\n      const headers = {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-Javascript-Key': 'test',\n      };\n      let apolloClient;\n\n      beforeAll(async () => {\n        const expressApp = express();\n        httpServer = http.createServer(expressApp);\n        parseGraphQLServer = new ParseGraphQLServer(parseServer, {\n          graphQLPath: '/graphql',\n          graphQLCustomTypeDefs: ({ autoSchema, stitchSchemas }) =>\n            stitchSchemas({ subschemas: [autoSchema] }),\n        });\n\n        parseGraphQLServer.applyGraphQL(expressApp);\n        await new Promise(resolve =>\n          httpServer.listen({ port: 13377 }, resolve)\n        );\n        const httpLink = createUploadLink({\n          uri: 'http://localhost:13377/graphql',\n          fetch,\n          headers,\n        });\n        apolloClient = new ApolloClient({\n          link: httpLink,\n          cache: new InMemoryCache(),\n          defaultOptions: {\n            query: {\n              fetchPolicy: 'no-cache',\n            },\n          },\n        });\n      });\n\n      afterAll(async () => {\n        await httpServer.close();\n      });\n\n      it('can resolve a query', async () => {\n        const result = await apolloClient.query({\n          query: gql`\n            query Health {\n              health\n            }\n          `,\n        });\n        expect(result.data.health).toEqual(true);\n      });\n    });\n  });\n});\n", "import {\n  GraphQLNonNull,\n  GraphQLString,\n  GraphQLBoolean,\n  GraphQLInputObjectType,\n} from 'graphql';\nimport { mutationWithClientMutationId } from 'graphql-relay';\nimport UsersRouter from '../../Routers/UsersRouter';\nimport * as objectsMutations from '../helpers/objectsMutations';\nimport { OBJECT } from './defaultGraphQLTypes';\nimport { getUserFromSessionToken } from './usersQueries';\n\nconst usersRouter = new UsersRouter();\n\nconst load = parseGraphQLSchema => {\n  if (parseGraphQLSchema.isUsersClassDisabled) {\n    return;\n  }\n\n  const signUpMutation = mutationWithClientMutationId({\n    name: 'SignUp',\n    description:\n      'The signUp mutation can be used to create and sign up a new user.',\n    inputFields: {\n      fields: {\n        descriptions:\n          'These are the fields of the new user to be created and signed up.',\n        type:\n          parseGraphQLSchema.parseClassTypes['_User'].classGraphQLCreateType,\n      },\n    },\n    outputFields: {\n      viewer: {\n        description:\n          'This is the new user that was created, signed up and returned as a viewer.',\n        type: new GraphQLNonNull(parseGraphQLSchema.viewerType),\n      },\n    },\n    mutateAndGetPayload: async (args, context, mutationInfo) => {\n      try {\n        const { fields } = args;\n        const { config, auth, info } = context;\n\n        const { sessionToken, objectId } = await objectsMutations.createObject(\n          '_User',\n          fields,\n          config,\n          auth,\n          info\n        );\n\n        context.info.sessionToken = sessionToken;\n\n        return {\n          viewer: await getUserFromSessionToken(\n            context,\n            mutationInfo,\n            'viewer.user.',\n            objectId\n          ),\n        };\n      } catch (e) {\n        parseGraphQLSchema.handleError(e);\n      }\n    },\n  });\n\n  parseGraphQLSchema.addGraphQLType(\n    signUpMutation.args.input.type.ofType,\n    true,\n    true\n  );\n  parseGraphQLSchema.addGraphQLType(signUpMutation.type, true, true);\n  parseGraphQLSchema.addGraphQLMutation('signUp', signUpMutation, true, true);\n  const logInWithMutation = mutationWithClientMutationId({\n    name: 'LogInWith',\n    description:\n      'The logInWith mutation can be used to signup, login user with 3rd party authentication system. This mutation create a user if the authData do not correspond to an existing one.',\n    inputFields: {\n      authData: {\n        descriptions: 'This is the auth data of your custom auth provider',\n        type: new GraphQLNonNull(OBJECT),\n      },\n      fields: {\n        descriptions:\n          'These are the fields of the user to be created/updated and logged in.',\n        type: new GraphQLInputObjectType({\n          name: 'UserLoginWithInput',\n          fields: () => {\n            const classGraphQLCreateFields = parseGraphQLSchema.parseClassTypes[\n              '_User'\n            ].classGraphQLCreateType.getFields();\n            return Object.keys(classGraphQLCreateFields).reduce(\n              (fields, fieldName) => {\n                if (\n                  fieldName !== 'password' &&\n                  fieldName !== 'username' &&\n                  fieldName !== 'authData'\n                ) {\n                  fields[fieldName] = classGraphQLCreateFields[fieldName];\n                }\n                return fields;\n              },\n              {}\n            );\n          },\n        }),\n      },\n    },\n    outputFields: {\n      viewer: {\n        description:\n          'This is the new user that was created, signed up and returned as a viewer.',\n        type: new GraphQLNonNull(parseGraphQLSchema.viewerType),\n      },\n    },\n    mutateAndGetPayload: async (args, context, mutationInfo) => {\n      try {\n        const { fields, authData } = args;\n        const { config, auth, info } = context;\n\n        const { sessionToken, objectId } = await objectsMutations.createObject(\n          '_User',\n          { ...fields, authData },\n          config,\n          auth,\n          info\n        );\n\n        context.info.sessionToken = sessionToken;\n\n        return {\n          viewer: await getUserFromSessionToken(\n            context,\n            mutationInfo,\n            'viewer.user.',\n            objectId\n          ),\n        };\n      } catch (e) {\n        parseGraphQLSchema.handleError(e);\n      }\n    },\n  });\n\n  parseGraphQLSchema.addGraphQLType(\n    logInWithMutation.args.input.type.ofType,\n    true,\n    true\n  );\n  parseGraphQLSchema.addGraphQLType(logInWithMutation.type, true, true);\n  parseGraphQLSchema.addGraphQLMutation(\n    'logInWith',\n    logInWithMutation,\n    true,\n    true\n  );\n\n  const logInMutation = mutationWithClientMutationId({\n    name: 'LogIn',\n    description: 'The logIn mutation can be used to log in an existing user.',\n    inputFields: {\n      username: {\n        description: 'This is the username used to log in the user.',\n        type: new GraphQLNonNull(GraphQLString),\n      },\n      password: {\n        description: 'This is the password used to log in the user.',\n        type: new GraphQLNonNull(GraphQLString),\n      },\n    },\n    outputFields: {\n      viewer: {\n        description:\n          'This is the existing user that was logged in and returned as a viewer.',\n        type: new GraphQLNonNull(parseGraphQLSchema.viewerType),\n      },\n    },\n    mutateAndGetPayload: async (args, context, mutationInfo) => {\n      try {\n        const { username, password } = args;\n        const { config, auth, info } = context;\n\n        const { sessionToken, objectId } = (\n          await usersRouter.handleLogIn({\n            body: {\n              username,\n              password,\n            },\n            query: {},\n            config,\n            auth,\n            info,\n          })\n        ).response;\n\n        context.info.sessionToken = sessionToken;\n\n        return {\n          viewer: await getUserFromSessionToken(\n            context,\n            mutationInfo,\n            'viewer.user.',\n            objectId\n          ),\n        };\n      } catch (e) {\n        parseGraphQLSchema.handleError(e);\n      }\n    },\n  });\n\n  parseGraphQLSchema.addGraphQLType(\n    logInMutation.args.input.type.ofType,\n    true,\n    true\n  );\n  parseGraphQLSchema.addGraphQLType(logInMutation.type, true, true);\n  parseGraphQLSchema.addGraphQLMutation('logIn', logInMutation, true, true);\n\n  const logOutMutation = mutationWithClientMutationId({\n    name: 'LogOut',\n    description: 'The logOut mutation can be used to log out an existing user.',\n    outputFields: {\n      viewer: {\n        description:\n          'This is the existing user that was logged out and returned as a viewer.',\n        type: new GraphQLNonNull(parseGraphQLSchema.viewerType),\n      },\n    },\n    mutateAndGetPayload: async (_args, context, mutationInfo) => {\n      try {\n        const { config, auth, info } = context;\n\n        const viewer = await getUserFromSessionToken(\n          context,\n          mutationInfo,\n          'viewer.user.',\n          auth.user.id\n        );\n\n        await usersRouter.handleLogOut({\n          config,\n          auth,\n          info,\n        });\n\n        return { viewer };\n      } catch (e) {\n        parseGraphQLSchema.handleError(e);\n      }\n    },\n  });\n\n  parseGraphQLSchema.addGraphQLType(\n    logOutMutation.args.input.type.ofType,\n    true,\n    true\n  );\n  parseGraphQLSchema.addGraphQLType(logOutMutation.type, true, true);\n  parseGraphQLSchema.addGraphQLMutation('logOut', logOutMutation, true, true);\n\n  const resetPasswordMutation = mutationWithClientMutationId({\n    name: 'ResetPassword',\n    description:\n      'The resetPassword mutation can be used to reset the password of an existing user.',\n    inputFields: {\n      email: {\n        descriptions: 'Email of the user that should receive the reset email',\n        type: new GraphQLNonNull(GraphQLString),\n      },\n    },\n    outputFields: {\n      ok: {\n        description: \"It's always true.\",\n        type: new GraphQLNonNull(GraphQLBoolean),\n      },\n    },\n    mutateAndGetPayload: async ({ email }, context) => {\n      const { config, auth, info } = context;\n\n      await usersRouter.handleResetRequest({\n        body: {\n          email,\n        },\n        config,\n        auth,\n        info,\n      });\n\n      return { ok: true };\n    },\n  });\n\n  parseGraphQLSchema.addGraphQLType(\n    resetPasswordMutation.args.input.type.ofType,\n    true,\n    true\n  );\n  parseGraphQLSchema.addGraphQLType(resetPasswordMutation.type, true, true);\n  parseGraphQLSchema.addGraphQLMutation(\n    'resetPassword',\n    resetPasswordMutation,\n    true,\n    true\n  );\n\n  const sendVerificationEmailMutation = mutationWithClientMutationId({\n    name: 'SendVerificationEmail',\n    description:\n      'The sendVerificationEmail mutation can be used to send the verification email again.',\n    inputFields: {\n      email: {\n        descriptions:\n          'Email of the user that should receive the verification email',\n        type: new GraphQLNonNull(GraphQLString),\n      },\n    },\n    outputFields: {\n      ok: {\n        description: \"It's always true.\",\n        type: new GraphQLNonNull(GraphQLBoolean),\n      },\n    },\n    mutateAndGetPayload: async ({ email }, context) => {\n      try {\n        const { config, auth, info } = context;\n\n        await usersRouter.handleVerificationEmailRequest({\n          body: {\n            email,\n          },\n          config,\n          auth,\n          info,\n        });\n\n        return { ok: true };\n      } catch (e) {\n        parseGraphQLSchema.handleError(e);\n      }\n    },\n  });\n\n  parseGraphQLSchema.addGraphQLType(\n    sendVerificationEmailMutation.args.input.type.ofType,\n    true,\n    true\n  );\n  parseGraphQLSchema.addGraphQLType(\n    sendVerificationEmailMutation.type,\n    true,\n    true\n  );\n  parseGraphQLSchema.addGraphQLMutation(\n    'sendVerificationEmail',\n    sendVerificationEmailMutation,\n    true,\n    true\n  );\n};\n\nexport { load };\n", "import { GraphQLNonNull } from 'graphql';\nimport getFieldNames from 'graphql-list-fields';\nimport Parse from 'parse/node';\nimport rest from '../../rest';\nimport { extractKeysAndInclude } from './parseClassTypes';\nimport { Auth } from '../../Auth';\n\nconst getUserFromSessionToken = async (\n  context,\n  queryInfo,\n  keysPrefix,\n  userId\n) => {\n  const { info, config } = context;\n  if (!info || !info.sessionToken) {\n    throw new Parse.Error(\n      Parse.Error.INVALID_SESSION_TOKEN,\n      'Invalid session token'\n    );\n  }\n  const sessionToken = info.sessionToken;\n  const selectedFields = getFieldNames(queryInfo)\n    .filter(field => field.startsWith(keysPrefix))\n    .map(field => field.replace(keysPrefix, ''));\n\n  const keysAndInclude = extractKeysAndInclude(selectedFields);\n  const { keys } = keysAndInclude;\n  let { include } = keysAndInclude;\n\n  if (userId && !keys && !include) {\n    return {\n      sessionToken,\n    };\n  } else if (keys && !include) {\n    include = 'user';\n  }\n\n  if (userId) {\n    // We need to re create the auth context\n    // to avoid security breach if userId is provided\n    context.auth = new Auth({\n      config,\n      isMaster: context.auth.isMaster,\n      user: { id: userId },\n    });\n  }\n\n  const options = {};\n  if (keys) {\n    options.keys = keys\n      .split(',')\n      .map(key => `${key}`)\n      .join(',');\n  }\n  if (include) {\n    options.include = include\n      .split(',')\n      .map(included => `${included}`)\n      .join(',');\n  }\n\n  const response = await rest.find(\n    config,\n    context.auth,\n    '_User',\n    // Get the user it self from auth object\n    { objectId: context.auth.user.id },\n    options,\n    info.clientVersion,\n    info.context\n  );\n  if (!response.results || response.results.length == 0) {\n    throw new Parse.Error(\n      Parse.Error.INVALID_SESSION_TOKEN,\n      'Invalid session token'\n    );\n  } else {\n    const user = response.results[0];\n    return {\n      sessionToken,\n      user,\n    };\n  }\n};\n\nconst load = parseGraphQLSchema => {\n  if (parseGraphQLSchema.isUsersClassDisabled) {\n    return;\n  }\n\n  parseGraphQLSchema.addGraphQLQuery(\n    'viewer',\n    {\n      description:\n        'The viewer query can be used to return the current user data.',\n      type: new GraphQLNonNull(parseGraphQLSchema.viewerType),\n      async resolve(_source, _args, context, queryInfo) {\n        try {\n          return await getUserFromSessionToken(\n            context,\n            queryInfo,\n            'user.',\n            false\n          );\n        } catch (e) {\n          parseGraphQLSchema.handleError(e);\n        }\n      },\n    },\n    true,\n    true\n  );\n};\n\nexport { load, getUserFromSessionToken };\n"], "filenames": ["spec/ParseGraphQLServer.spec.js", "src/GraphQL/loaders/usersMutations.js", "src/GraphQL/loaders/usersQueries.js"], "buggy_code_start_loc": [173, 44, 5], "buggy_code_end_loc": [10996, 244, 96], "fixing_code_start_loc": [173, 44, 4], "fixing_code_end_loc": [11040, 240, 101], "type": "CWE-863", "message": "In parser-server from version 3.5.0 and before 4.3.0, an authenticated user using the viewer GraphQL query can by pass all read security on his User object and can also by pass all objects linked via relation or Pointer on his User object.", "other": {"cve": {"id": "CVE-2020-15126", "sourceIdentifier": "security-advisories@github.com", "published": "2020-07-22T23:15:11.207", "lastModified": "2020-07-28T17:30:03.817", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In parser-server from version 3.5.0 and before 4.3.0, an authenticated user using the viewer GraphQL query can by pass all read security on his User object and can also by pass all objects linked via relation or Pointer on his User object."}, {"lang": "es", "value": "En parser-server desde la versi\u00f3n 3.5.0 y anteriores a 4.3.0, un usuario autenticado que use la consulta GraphQL del visualizador puede pasar toda la seguridad de lectura en su objeto Usuario y tambi\u00e9n puede pasar todos los objetos vinculados por medio de una relaci\u00f3n o Puntero en su objeto de Usuario"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:parseplatform:parse_server:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.5.0", "versionEndExcluding": "4.3.0", "matchCriteriaId": "58698788-8FFD-4933-9B83-9B675261A24F"}]}]}], "references": [{"url": "https://github.com/parse-community/parse-server/blob/master/CHANGELOG.md#430", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/parse-community/parse-server/commit/78239ac9071167fdf243c55ae4bc9a2c0b0d89aa", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/parse-community/parse-server/security/advisories/GHSA-236h-rqv8-8q73", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/parse-community/parse-server/commit/78239ac9071167fdf243c55ae4bc9a2c0b0d89aa"}}