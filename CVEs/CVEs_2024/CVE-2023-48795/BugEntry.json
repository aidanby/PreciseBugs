{"buggy_code": ["/*\r\n * (C) 2011- TeraTerm Project\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions\r\n * are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright\r\n *    notice, this list of conditions and the following disclaimer.\r\n * 2. Redistributions in binary form must reproduce the above copyright\r\n *    notice, this list of conditions and the following disclaimer in the\r\n *    documentation and/or other materials provided with the distribution.\r\n * 3. The name of the author may not be used to endorse or promote products\r\n *    derived from this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\r\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,\r\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\r\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n#include \"ttxssh.h\"\r\n#include \"kex.h\"\r\n\r\n\r\nchar *myproposal[PROPOSAL_MAX] = {\r\n\tKEX_DEFAULT_KEX,\r\n\tKEX_DEFAULT_PK_ALG,\r\n\tKEX_DEFAULT_ENCRYPT,\r\n\tKEX_DEFAULT_ENCRYPT,\r\n\tKEX_DEFAULT_MAC,\r\n\tKEX_DEFAULT_MAC,\r\n\tKEX_DEFAULT_COMP,\r\n\tKEX_DEFAULT_COMP,\r\n\tKEX_DEFAULT_LANG,\r\n\tKEX_DEFAULT_LANG,\r\n};\r\n\r\nstruct ssh2_kex_algorithm_t {\r\n\tkex_algorithm kextype;\r\n\tchar *name;\r\n\tconst EVP_MD *(*evp_md)(void);\r\n};\r\n\r\nstatic const struct ssh2_kex_algorithm_t ssh2_kex_algorithms[] = {\r\n\t{KEX_DH_GRP1_SHA1,  \"diffie-hellman-group1-sha1\",           EVP_sha1},   // RFC4253\r\n\t{KEX_DH_GRP14_SHA1, \"diffie-hellman-group14-sha1\",          EVP_sha1},   // RFC4253\r\n\t{KEX_DH_GEX_SHA1,   \"diffie-hellman-group-exchange-sha1\",   EVP_sha1},   // RFC4419\r\n\t{KEX_DH_GEX_SHA256, \"diffie-hellman-group-exchange-sha256\", EVP_sha256}, // RFC4419\r\n\t{KEX_ECDH_SHA2_256, \"ecdh-sha2-nistp256\",                   EVP_sha256}, // RFC5656\r\n\t{KEX_ECDH_SHA2_384, \"ecdh-sha2-nistp384\",                   EVP_sha384}, // RFC5656\r\n\t{KEX_ECDH_SHA2_521, \"ecdh-sha2-nistp521\",                   EVP_sha512}, // RFC5656\r\n\t{KEX_DH_GRP14_SHA256, \"diffie-hellman-group14-sha256\",      EVP_sha256}, // RFC8268\r\n\t{KEX_DH_GRP16_SHA512, \"diffie-hellman-group16-sha512\",      EVP_sha512}, // RFC8268\r\n\t{KEX_DH_GRP18_SHA512, \"diffie-hellman-group18-sha512\",      EVP_sha512}, // RFC8268\r\n\t{KEX_DH_NONE      , NULL,                                   NULL},\r\n};\r\n\r\n\r\nchar* get_kex_algorithm_name(kex_algorithm kextype)\r\n{\r\n\tconst struct ssh2_kex_algorithm_t *ptr = ssh2_kex_algorithms;\r\n\r\n\twhile (ptr->name != NULL) {\r\n\t\tif (kextype == ptr->kextype) {\r\n\t\t\treturn ptr->name;\r\n\t\t}\r\n\t\tptr++;\r\n\t}\r\n\r\n\t// not found.\r\n\treturn \"unknown\";\r\n}\r\n\r\nconst EVP_MD* get_kex_algorithm_EVP_MD(kex_algorithm kextype)\r\n{\r\n\tconst struct ssh2_kex_algorithm_t *ptr = ssh2_kex_algorithms;\r\n\r\n\twhile (ptr->name != NULL) {\r\n\t\tif (kextype == ptr->kextype) {\r\n\t\t\treturn ptr->evp_md();\r\n\t\t}\r\n\t\tptr++;\r\n\t}\r\n\r\n\t// not found.\r\n\treturn EVP_md_null();\r\n}\r\n\r\nvoid normalize_kex_order(char *buf)\r\n{\r\n\tstatic char default_strings[] = {\r\n\t\tKEX_ECDH_SHA2_256,\r\n\t\tKEX_ECDH_SHA2_384,\r\n\t\tKEX_ECDH_SHA2_521,\r\n\t\tKEX_DH_GRP18_SHA512,\r\n\t\tKEX_DH_GRP16_SHA512,\r\n\t\tKEX_DH_GRP14_SHA256,\r\n\t\tKEX_DH_GEX_SHA256,\r\n\t\tKEX_DH_GRP14_SHA1,\r\n\t\tKEX_DH_NONE,\r\n\t\tKEX_DH_GEX_SHA1,\r\n\t\tKEX_DH_GRP1_SHA1,\r\n\t};\r\n\r\n\tnormalize_generic_order(buf, default_strings, NUM_ELEM(default_strings));\r\n}\r\n\r\nkex_algorithm choose_SSH2_kex_algorithm(char *server_proposal, char *my_proposal)\r\n{\r\n\tkex_algorithm type = KEX_DH_UNKNOWN;\r\n\tchar str_kextype[40];\r\n\tconst struct ssh2_kex_algorithm_t *ptr = ssh2_kex_algorithms;\r\n\r\n\tchoose_SSH2_proposal(server_proposal, my_proposal, str_kextype, sizeof(str_kextype));\r\n\r\n\twhile (ptr->name != NULL) {\r\n\t\tif (strcmp(ptr->name, str_kextype) == 0) {\r\n\t\t\ttype = ptr->kextype;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tptr++;\r\n\t}\r\n\r\n\treturn (type);\r\n}\r\n\r\n// KEX\ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd\ufffdD\ufffd\u63c7\ufffd\u0282\u0249\ufffd\ufffd\ufffd\ufffd\u0101Amyproposal[]\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n// (2011.2.28 yutaka)\r\nvoid SSH2_update_kex_myproposal(PTInstVar pvar)\r\n{\r\n\tstatic char buf[512]; // TODO: malloc()\ufffd\u0242\ufffd\ufffd\u05c2\ufffd\r\n\tint index;\r\n\tint i;\r\n\r\n\t// \ufffd\u0290M\ufffd\ufffd\ufffd\u024c\u0102\u0382\ufffd\ufffd\u0182\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0182\u0343L\ufffd[\ufffd\u010d\uc42c\r\n\tif (pvar->socket != INVALID_SOCKET) {\r\n\t\tif (pvar->kex_status & KEX_FLAG_REKEYING) {\r\n\t\t\t// \ufffdL\ufffd[\ufffd\u010d\uc42c\ufffd\u030f\ua347\ufffd\u0242\u0341A\ufffd\u0691\ufffd\ufffd\ufffd\ufffd\ufffd pvar->settings \ufffd\ufffd\ufffd\ufffdg\ufffd\u0757\ufffd\ufffd\u0102\ufffd\ua0bd myproposal \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\t\t//   pvar->settings \ufffd\ufffd \ufffd\u0691\ufffd\ufffd\ufffd\ufffd\ufffd myproposal \ufffd\ufffd\ufffd\uc42c\ufffd\ufffd\ufffd\ufffd\ufffd\u0182\ufffd\ufffd\u0312l\ufffd\ufffd\ufffd\ufffd\u03c2\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0202\ufffd\ufffd\u06cf\u0602\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t\t\t//   \ufffd\u0113x\ufffdg\ufffd\u0757\ufffd\ufffd\u0102\ufffd\u0302\u0142\u0342\u0202\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd myproposal \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u90b1\ufffd\u0182\u0242\ufffd\ufffd\ufffd\ufffdB\r\n\t\t\tint pos = strlen(myproposal[PROPOSAL_KEX_ALGS]) - strlen(\",ext-info-c\");\r\n\t\t\tif (strcmp(myproposal[PROPOSAL_KEX_ALGS] + pos, \",ext-info-c\") == 0) {\r\n\t\t\t\tmyproposal[PROPOSAL_KEX_ALGS][pos] = '\\0';\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\r\n\tbuf[0] = '\\0';\r\n\tfor (i = 0 ; pvar->settings.KexOrder[i] != 0 ; i++) {\r\n\t\tindex = pvar->settings.KexOrder[i] - '0';\r\n\t\tif (index == KEX_DH_NONE) // disabled line\r\n\t\t\tbreak;\r\n\t\tstrncat_s(buf, sizeof(buf), get_kex_algorithm_name(index), _TRUNCATE);\r\n\t\tstrncat_s(buf, sizeof(buf), \",\", _TRUNCATE);\r\n\t}\r\n\r\n\t// RFC 8308 Extension Negotiation\r\n\tstrncat_s(buf, sizeof(buf), \"ext-info-c\", _TRUNCATE);\r\n\r\n\tmyproposal[PROPOSAL_KEX_ALGS] = buf; \r\n}\r\n\r\n\r\nstatic DH *dh_new_group_asc(const char *gen, const char *modulus)\r\n{\r\n\tDH *dh = NULL;\r\n\tBIGNUM *p = NULL, *g = NULL;\r\n\r\n\tif ((dh = DH_new()) == NULL) {\r\n\t\tprintf(\"dh_new_group_asc: DH_new\");\r\n\t\tgoto error;\r\n\t}\r\n\r\n\t// P\ufffd\ufffdG\ufffd\u034c\ufffd\ufffdJ\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u60a2\ufffdf\ufffd\ufffd\ufffd\u0311g\ufffd\u074d\ufffd\ufffd\ud0b9\r\n\tif (BN_hex2bn(&p, modulus) == 0) {\r\n\t\tprintf(\"BN_hex2bn p\");\r\n\t\tgoto error;\r\n\t}\r\n\r\n\tif (BN_hex2bn(&g, gen) == 0) {\r\n\t\tprintf(\"BN_hex2bn g\");\r\n\t\tgoto error;\r\n\t}\r\n\r\n\t// BN_hex2bn()\ufffd\u0155\u03ca\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd|\ufffdC\ufffd\ufffd\ufffd^\ufffd\ufffdDH\ufffd\\\ufffd\ufffd\ufffd\u0302\u0243Z\ufffdb\ufffdg\ufffd\ufffd\ufffd\ufffdB\r\n\tDH_set0_pqg(dh, p, NULL, g);\r\n\r\n\treturn (dh);\r\n\r\nerror:\r\n    BN_free(g);\r\n    BN_free(p);\r\n\tDH_free(dh);\r\n\treturn (NULL);\r\n}\r\n\r\n\r\nDH *dh_new_group1(void)\r\n{\r\n\tstatic char *gen = \"2\", *group1 =\r\n\t    \"FFFFFFFF\" \"FFFFFFFF\" \"C90FDAA2\" \"2168C234\" \"C4C6628B\" \"80DC1CD1\"\r\n\t    \"29024E08\" \"8A67CC74\" \"020BBEA6\" \"3B139B22\" \"514A0879\" \"8E3404DD\"\r\n\t    \"EF9519B3\" \"CD3A431B\" \"302B0A6D\" \"F25F1437\" \"4FE1356D\" \"6D51C245\"\r\n\t    \"E485B576\" \"625E7EC6\" \"F44C42E9\" \"A637ED6B\" \"0BFF5CB6\" \"F406B7ED\"\r\n\t    \"EE386BFB\" \"5A899FA5\" \"AE9F2411\" \"7C4B1FE6\" \"49286651\" \"ECE65381\"\r\n\t    \"FFFFFFFF\" \"FFFFFFFF\";\r\n\r\n\treturn (dh_new_group_asc(gen, group1));\r\n}\r\n\r\n\r\nDH *dh_new_group14(void)\r\n{\r\n    static char *gen = \"2\", *group14 =\r\n        \"FFFFFFFF\" \"FFFFFFFF\" \"C90FDAA2\" \"2168C234\" \"C4C6628B\" \"80DC1CD1\"\r\n        \"29024E08\" \"8A67CC74\" \"020BBEA6\" \"3B139B22\" \"514A0879\" \"8E3404DD\"\r\n        \"EF9519B3\" \"CD3A431B\" \"302B0A6D\" \"F25F1437\" \"4FE1356D\" \"6D51C245\"\r\n        \"E485B576\" \"625E7EC6\" \"F44C42E9\" \"A637ED6B\" \"0BFF5CB6\" \"F406B7ED\"\r\n        \"EE386BFB\" \"5A899FA5\" \"AE9F2411\" \"7C4B1FE6\" \"49286651\" \"ECE45B3D\"\r\n        \"C2007CB8\" \"A163BF05\" \"98DA4836\" \"1C55D39A\" \"69163FA8\" \"FD24CF5F\"\r\n        \"83655D23\" \"DCA3AD96\" \"1C62F356\" \"208552BB\" \"9ED52907\" \"7096966D\"\r\n        \"670C354E\" \"4ABC9804\" \"F1746C08\" \"CA18217C\" \"32905E46\" \"2E36CE3B\"\r\n        \"E39E772C\" \"180E8603\" \"9B2783A2\" \"EC07A28F\" \"B5C55DF0\" \"6F4C52C9\"\r\n        \"DE2BCBF6\" \"95581718\" \"3995497C\" \"EA956AE5\" \"15D22618\" \"98FA0510\"\r\n        \"15728E5A\" \"8AACAA68\" \"FFFFFFFF\" \"FFFFFFFF\";\r\n\r\n\treturn (dh_new_group_asc(gen, group14));\r\n}\r\n\r\n// \ufffd\ufffd\ufffdg\ufffdp\r\nDH *dh_new_group15(void)\r\n{\r\n    static char *gen = \"2\", *group15 =\r\n\t\"FFFFFFFF\" \"FFFFFFFF\" \"C90FDAA2\" \"2168C234\" \"C4C6628B\" \"80DC1CD1\"\r\n\t\"29024E08\" \"8A67CC74\" \"020BBEA6\" \"3B139B22\" \"514A0879\" \"8E3404DD\"\r\n\t\"EF9519B3\" \"CD3A431B\" \"302B0A6D\" \"F25F1437\" \"4FE1356D\" \"6D51C245\"\r\n\t\"E485B576\" \"625E7EC6\" \"F44C42E9\" \"A637ED6B\" \"0BFF5CB6\" \"F406B7ED\"\r\n\t\"EE386BFB\" \"5A899FA5\" \"AE9F2411\" \"7C4B1FE6\" \"49286651\" \"ECE45B3D\"\r\n\t\"C2007CB8\" \"A163BF05\" \"98DA4836\" \"1C55D39A\" \"69163FA8\" \"FD24CF5F\"\r\n\t\"83655D23\" \"DCA3AD96\" \"1C62F356\" \"208552BB\" \"9ED52907\" \"7096966D\"\r\n\t\"670C354E\" \"4ABC9804\" \"F1746C08\" \"CA18217C\" \"32905E46\" \"2E36CE3B\"\r\n\t\"E39E772C\" \"180E8603\" \"9B2783A2\" \"EC07A28F\" \"B5C55DF0\" \"6F4C52C9\"\r\n\t\"DE2BCBF6\" \"95581718\" \"3995497C\" \"EA956AE5\" \"15D22618\" \"98FA0510\"\r\n\t\"15728E5A\" \"8AAAC42D\" \"AD33170D\" \"04507A33\" \"A85521AB\" \"DF1CBA64\"\r\n\t\"ECFB8504\" \"58DBEF0A\" \"8AEA7157\" \"5D060C7D\" \"B3970F85\" \"A6E1E4C7\"\r\n\t\"ABF5AE8C\" \"DB0933D7\" \"1E8C94E0\" \"4A25619D\" \"CEE3D226\" \"1AD2EE6B\"\r\n\t\"F12FFA06\" \"D98A0864\" \"D8760273\" \"3EC86A64\" \"521F2B18\" \"177B200C\"\r\n\t\"BBE11757\" \"7A615D6C\" \"770988C0\" \"BAD946E2\" \"08E24FA0\" \"74E5AB31\"\r\n\t\"43DB5BFC\" \"E0FD108E\" \"4B82D120\" \"A93AD2CA\" \"FFFFFFFF\" \"FFFFFFFF\";\r\n\treturn (dh_new_group_asc(gen, group15));\r\n}\r\n\r\nDH *dh_new_group16(void)\r\n{\r\n    static char *gen = \"2\", *group16 =\r\n\t\"FFFFFFFF\" \"FFFFFFFF\" \"C90FDAA2\" \"2168C234\" \"C4C6628B\" \"80DC1CD1\"\r\n\t\"29024E08\" \"8A67CC74\" \"020BBEA6\" \"3B139B22\" \"514A0879\" \"8E3404DD\"\r\n\t\"EF9519B3\" \"CD3A431B\" \"302B0A6D\" \"F25F1437\" \"4FE1356D\" \"6D51C245\"\r\n\t\"E485B576\" \"625E7EC6\" \"F44C42E9\" \"A637ED6B\" \"0BFF5CB6\" \"F406B7ED\"\r\n\t\"EE386BFB\" \"5A899FA5\" \"AE9F2411\" \"7C4B1FE6\" \"49286651\" \"ECE45B3D\"\r\n\t\"C2007CB8\" \"A163BF05\" \"98DA4836\" \"1C55D39A\" \"69163FA8\" \"FD24CF5F\"\r\n\t\"83655D23\" \"DCA3AD96\" \"1C62F356\" \"208552BB\" \"9ED52907\" \"7096966D\"\r\n\t\"670C354E\" \"4ABC9804\" \"F1746C08\" \"CA18217C\" \"32905E46\" \"2E36CE3B\"\r\n\t\"E39E772C\" \"180E8603\" \"9B2783A2\" \"EC07A28F\" \"B5C55DF0\" \"6F4C52C9\"\r\n\t\"DE2BCBF6\" \"95581718\" \"3995497C\" \"EA956AE5\" \"15D22618\" \"98FA0510\"\r\n\t\"15728E5A\" \"8AAAC42D\" \"AD33170D\" \"04507A33\" \"A85521AB\" \"DF1CBA64\"\r\n\t\"ECFB8504\" \"58DBEF0A\" \"8AEA7157\" \"5D060C7D\" \"B3970F85\" \"A6E1E4C7\"\r\n\t\"ABF5AE8C\" \"DB0933D7\" \"1E8C94E0\" \"4A25619D\" \"CEE3D226\" \"1AD2EE6B\"\r\n\t\"F12FFA06\" \"D98A0864\" \"D8760273\" \"3EC86A64\" \"521F2B18\" \"177B200C\"\r\n\t\"BBE11757\" \"7A615D6C\" \"770988C0\" \"BAD946E2\" \"08E24FA0\" \"74E5AB31\"\r\n\t\"43DB5BFC\" \"E0FD108E\" \"4B82D120\" \"A9210801\" \"1A723C12\" \"A787E6D7\"\r\n\t\"88719A10\" \"BDBA5B26\" \"99C32718\" \"6AF4E23C\" \"1A946834\" \"B6150BDA\"\r\n\t\"2583E9CA\" \"2AD44CE8\" \"DBBBC2DB\" \"04DE8EF9\" \"2E8EFC14\" \"1FBECAA6\"\r\n\t\"287C5947\" \"4E6BC05D\" \"99B2964F\" \"A090C3A2\" \"233BA186\" \"515BE7ED\"\r\n\t\"1F612970\" \"CEE2D7AF\" \"B81BDD76\" \"2170481C\" \"D0069127\" \"D5B05AA9\"\r\n\t\"93B4EA98\" \"8D8FDDC1\" \"86FFB7DC\" \"90A6C08F\" \"4DF435C9\" \"34063199\"\r\n\t\"FFFFFFFF\" \"FFFFFFFF\";\r\n\treturn (dh_new_group_asc(gen, group16));\r\n}\r\n\r\n// \ufffd\ufffd\ufffdg\ufffdp\r\nDH *dh_new_group17(void)\r\n{\r\n    static char *gen = \"2\", *group17 =\r\n\t\"FFFFFFFF\" \"FFFFFFFF\" \"C90FDAA2\" \"2168C234\" \"C4C6628B\" \"80DC1CD1\" \"29024E08\"\r\n\t\"8A67CC74\" \"020BBEA6\" \"3B139B22\" \"514A0879\" \"8E3404DD\" \"EF9519B3\" \"CD3A431B\"\r\n\t\"302B0A6D\" \"F25F1437\" \"4FE1356D\" \"6D51C245\" \"E485B576\" \"625E7EC6\" \"F44C42E9\"\r\n\t\"A637ED6B\" \"0BFF5CB6\" \"F406B7ED\" \"EE386BFB\" \"5A899FA5\" \"AE9F2411\" \"7C4B1FE6\"\r\n\t\"49286651\" \"ECE45B3D\" \"C2007CB8\" \"A163BF05\" \"98DA4836\" \"1C55D39A\" \"69163FA8\"\r\n\t\"FD24CF5F\" \"83655D23\" \"DCA3AD96\" \"1C62F356\" \"208552BB\" \"9ED52907\" \"7096966D\"\r\n\t\"670C354E\" \"4ABC9804\" \"F1746C08\" \"CA18217C\" \"32905E46\" \"2E36CE3B\" \"E39E772C\"\r\n\t\"180E8603\" \"9B2783A2\" \"EC07A28F\" \"B5C55DF0\" \"6F4C52C9\" \"DE2BCBF6\" \"95581718\"\r\n\t\"3995497C\" \"EA956AE5\" \"15D22618\" \"98FA0510\" \"15728E5A\" \"8AAAC42D\" \"AD33170D\"\r\n\t\"04507A33\" \"A85521AB\" \"DF1CBA64\" \"ECFB8504\" \"58DBEF0A\" \"8AEA7157\" \"5D060C7D\"\r\n\t\"B3970F85\" \"A6E1E4C7\" \"ABF5AE8C\" \"DB0933D7\" \"1E8C94E0\" \"4A25619D\" \"CEE3D226\"\r\n\t\"1AD2EE6B\" \"F12FFA06\" \"D98A0864\" \"D8760273\" \"3EC86A64\" \"521F2B18\" \"177B200C\"\r\n\t\"BBE11757\" \"7A615D6C\" \"770988C0\" \"BAD946E2\" \"08E24FA0\" \"74E5AB31\" \"43DB5BFC\"\r\n\t\"E0FD108E\" \"4B82D120\" \"A9210801\" \"1A723C12\" \"A787E6D7\" \"88719A10\" \"BDBA5B26\"\r\n\t\"99C32718\" \"6AF4E23C\" \"1A946834\" \"B6150BDA\" \"2583E9CA\" \"2AD44CE8\" \"DBBBC2DB\"\r\n\t\"04DE8EF9\" \"2E8EFC14\" \"1FBECAA6\" \"287C5947\" \"4E6BC05D\" \"99B2964F\" \"A090C3A2\"\r\n\t\"233BA186\" \"515BE7ED\" \"1F612970\" \"CEE2D7AF\" \"B81BDD76\" \"2170481C\" \"D0069127\"\r\n\t\"D5B05AA9\" \"93B4EA98\" \"8D8FDDC1\" \"86FFB7DC\" \"90A6C08F\" \"4DF435C9\" \"34028492\"\r\n\t\"36C3FAB4\" \"D27C7026\" \"C1D4DCB2\" \"602646DE\" \"C9751E76\" \"3DBA37BD\" \"F8FF9406\"\r\n\t\"AD9E530E\" \"E5DB382F\" \"413001AE\" \"B06A53ED\" \"9027D831\" \"179727B0\" \"865A8918\"\r\n\t\"DA3EDBEB\" \"CF9B14ED\" \"44CE6CBA\" \"CED4BB1B\" \"DB7F1447\" \"E6CC254B\" \"33205151\"\r\n\t\"2BD7AF42\" \"6FB8F401\" \"378CD2BF\" \"5983CA01\" \"C64B92EC\" \"F032EA15\" \"D1721D03\"\r\n\t\"F482D7CE\" \"6E74FEF6\" \"D55E702F\" \"46980C82\" \"B5A84031\" \"900B1C9E\" \"59E7C97F\"\r\n\t\"BEC7E8F3\" \"23A97A7E\" \"36CC88BE\" \"0F1D45B7\" \"FF585AC5\" \"4BD407B2\" \"2B4154AA\"\r\n\t\"CC8F6D7E\" \"BF48E1D8\" \"14CC5ED2\" \"0F8037E0\" \"A79715EE\" \"F29BE328\" \"06A1D58B\"\r\n\t\"B7C5DA76\" \"F550AA3D\" \"8A1FBFF0\" \"EB19CCB1\" \"A313D55C\" \"DA56C9EC\" \"2EF29632\"\r\n\t\"387FE8D7\" \"6E3C0468\" \"043E8F66\" \"3F4860EE\" \"12BF2D5B\" \"0B7474D6\" \"E694F91E\"\r\n\t\"6DCC4024\" \"FFFFFFFF\" \"FFFFFFFF\";\r\n\treturn (dh_new_group_asc(gen, group17));\r\n}\r\n\r\nDH *dh_new_group18(void)\r\n{\r\n    static char *gen = \"2\", *group18 =\r\n\t\"FFFFFFFF\" \"FFFFFFFF\" \"C90FDAA2\" \"2168C234\" \"C4C6628B\" \"80DC1CD1\"\r\n\t\"29024E08\" \"8A67CC74\" \"020BBEA6\" \"3B139B22\" \"514A0879\" \"8E3404DD\"\r\n\t\"EF9519B3\" \"CD3A431B\" \"302B0A6D\" \"F25F1437\" \"4FE1356D\" \"6D51C245\"\r\n\t\"E485B576\" \"625E7EC6\" \"F44C42E9\" \"A637ED6B\" \"0BFF5CB6\" \"F406B7ED\"\r\n\t\"EE386BFB\" \"5A899FA5\" \"AE9F2411\" \"7C4B1FE6\" \"49286651\" \"ECE45B3D\"\r\n\t\"C2007CB8\" \"A163BF05\" \"98DA4836\" \"1C55D39A\" \"69163FA8\" \"FD24CF5F\"\r\n\t\"83655D23\" \"DCA3AD96\" \"1C62F356\" \"208552BB\" \"9ED52907\" \"7096966D\"\r\n\t\"670C354E\" \"4ABC9804\" \"F1746C08\" \"CA18217C\" \"32905E46\" \"2E36CE3B\"\r\n\t\"E39E772C\" \"180E8603\" \"9B2783A2\" \"EC07A28F\" \"B5C55DF0\" \"6F4C52C9\"\r\n\t\"DE2BCBF6\" \"95581718\" \"3995497C\" \"EA956AE5\" \"15D22618\" \"98FA0510\"\r\n\t\"15728E5A\" \"8AAAC42D\" \"AD33170D\" \"04507A33\" \"A85521AB\" \"DF1CBA64\"\r\n\t\"ECFB8504\" \"58DBEF0A\" \"8AEA7157\" \"5D060C7D\" \"B3970F85\" \"A6E1E4C7\"\r\n\t\"ABF5AE8C\" \"DB0933D7\" \"1E8C94E0\" \"4A25619D\" \"CEE3D226\" \"1AD2EE6B\"\r\n\t\"F12FFA06\" \"D98A0864\" \"D8760273\" \"3EC86A64\" \"521F2B18\" \"177B200C\"\r\n\t\"BBE11757\" \"7A615D6C\" \"770988C0\" \"BAD946E2\" \"08E24FA0\" \"74E5AB31\"\r\n\t\"43DB5BFC\" \"E0FD108E\" \"4B82D120\" \"A9210801\" \"1A723C12\" \"A787E6D7\"\r\n\t\"88719A10\" \"BDBA5B26\" \"99C32718\" \"6AF4E23C\" \"1A946834\" \"B6150BDA\"\r\n\t\"2583E9CA\" \"2AD44CE8\" \"DBBBC2DB\" \"04DE8EF9\" \"2E8EFC14\" \"1FBECAA6\"\r\n\t\"287C5947\" \"4E6BC05D\" \"99B2964F\" \"A090C3A2\" \"233BA186\" \"515BE7ED\"\r\n\t\"1F612970\" \"CEE2D7AF\" \"B81BDD76\" \"2170481C\" \"D0069127\" \"D5B05AA9\"\r\n\t\"93B4EA98\" \"8D8FDDC1\" \"86FFB7DC\" \"90A6C08F\" \"4DF435C9\" \"34028492\"\r\n\t\"36C3FAB4\" \"D27C7026\" \"C1D4DCB2\" \"602646DE\" \"C9751E76\" \"3DBA37BD\"\r\n\t\"F8FF9406\" \"AD9E530E\" \"E5DB382F\" \"413001AE\" \"B06A53ED\" \"9027D831\"\r\n\t\"179727B0\" \"865A8918\" \"DA3EDBEB\" \"CF9B14ED\" \"44CE6CBA\" \"CED4BB1B\"\r\n\t\"DB7F1447\" \"E6CC254B\" \"33205151\" \"2BD7AF42\" \"6FB8F401\" \"378CD2BF\"\r\n\t\"5983CA01\" \"C64B92EC\" \"F032EA15\" \"D1721D03\" \"F482D7CE\" \"6E74FEF6\"\r\n\t\"D55E702F\" \"46980C82\" \"B5A84031\" \"900B1C9E\" \"59E7C97F\" \"BEC7E8F3\"\r\n\t\"23A97A7E\" \"36CC88BE\" \"0F1D45B7\" \"FF585AC5\" \"4BD407B2\" \"2B4154AA\"\r\n\t\"CC8F6D7E\" \"BF48E1D8\" \"14CC5ED2\" \"0F8037E0\" \"A79715EE\" \"F29BE328\"\r\n\t\"06A1D58B\" \"B7C5DA76\" \"F550AA3D\" \"8A1FBFF0\" \"EB19CCB1\" \"A313D55C\"\r\n\t\"DA56C9EC\" \"2EF29632\" \"387FE8D7\" \"6E3C0468\" \"043E8F66\" \"3F4860EE\"\r\n\t\"12BF2D5B\" \"0B7474D6\" \"E694F91E\" \"6DBE1159\" \"74A3926F\" \"12FEE5E4\"\r\n\t\"38777CB6\" \"A932DF8C\" \"D8BEC4D0\" \"73B931BA\" \"3BC832B6\" \"8D9DD300\"\r\n\t\"741FA7BF\" \"8AFC47ED\" \"2576F693\" \"6BA42466\" \"3AAB639C\" \"5AE4F568\"\r\n\t\"3423B474\" \"2BF1C978\" \"238F16CB\" \"E39D652D\" \"E3FDB8BE\" \"FC848AD9\"\r\n\t\"22222E04\" \"A4037C07\" \"13EB57A8\" \"1A23F0C7\" \"3473FC64\" \"6CEA306B\"\r\n\t\"4BCBC886\" \"2F8385DD\" \"FA9D4B7F\" \"A2C087E8\" \"79683303\" \"ED5BDD3A\"\r\n\t\"062B3CF5\" \"B3A278A6\" \"6D2A13F8\" \"3F44F82D\" \"DF310EE0\" \"74AB6A36\"\r\n\t\"4597E899\" \"A0255DC1\" \"64F31CC5\" \"0846851D\" \"F9AB4819\" \"5DED7EA1\"\r\n\t\"B1D510BD\" \"7EE74D73\" \"FAF36BC3\" \"1ECFA268\" \"359046F4\" \"EB879F92\"\r\n\t\"4009438B\" \"481C6CD7\" \"889A002E\" \"D5EE382B\" \"C9190DA6\" \"FC026E47\"\r\n\t\"9558E447\" \"5677E9AA\" \"9E3050E2\" \"765694DF\" \"C81F56E8\" \"80B96E71\"\r\n\t\"60C980DD\" \"98EDD3DF\" \"FFFFFFFF\" \"FFFFFFFF\";\r\n\treturn (dh_new_group_asc(gen, group18));\r\n}\r\n\r\n\r\n// DH\ufffd\ufffd\ufffd\ud803\udd90\ufffd\ufffd\ufffd\ufffd\ufffd\r\nvoid dh_gen_key(PTInstVar pvar, DH *dh, int we_need /* bytes */ )\r\n{\r\n\tint i;\r\n\tBIGNUM *pub_key;\r\n\tBIGNUM *priv_key;\r\n\r\n\tpriv_key = NULL;\r\n\r\n\t// \ufffd\u95a7\ufffd\u0242\ufffd\ufffd\u05c2\ufffd\ufffd\ufffd\ufffd\ufffd(X)\ufffd\ud803\udd90\ufffd\r\n\tfor (i = 0 ; i < 10 ; i++) { // retry counter\r\n\t\tif (priv_key != NULL) {\r\n\t\t\tBN_clear_free(priv_key);\r\n\t\t}\r\n\t\tpriv_key = BN_new();\r\n\t\tDH_set0_key(dh, NULL, priv_key);\r\n\t\tif (priv_key == NULL)\r\n\t\t\tgoto error;\r\n\t\tif (BN_rand(priv_key, 2*(we_need*8), 0, 0) == 0)\r\n\t\t\tgoto error;\r\n\t\tif (DH_generate_key(dh) == 0)\r\n\t\t\tgoto error;\r\n\t\tDH_get0_key(dh, &pub_key, NULL);\r\n\t\tif (dh_pub_is_valid(dh, pub_key))\r\n\t\t\tbreak;\r\n\t}\r\n\tif (i >= 10) {\r\n\t\tgoto error;\r\n\t}\r\n\treturn;\r\n\r\nerror:;\r\n\tnotify_fatal_error(pvar, \"error occurred @ dh_gen_key()\", TRUE);\r\n\r\n}\r\n\r\n\r\nint dh_estimate(int bits)\r\n{\r\n\tif (bits <= 112)\r\n\t\treturn 2048;\r\n\tif (bits <= 128)\r\n\t\treturn 3072;\r\n\tif (bits <= 192)\r\n\t\treturn 7680;\r\n\treturn 8192;\r\n}\r\n\r\n\r\n// shared secret \ufffd\ufffd\ufffdv\ufffdZ\ufffd\ufffd\ufffd\ufffd (DH \ufffd\u0152\ufffdO\ufffd\ufffd\ufffd[\ufffdv\ufffdp)\r\nunsigned char *kex_dh_hash(const EVP_MD *evp_md,\r\n                           char *client_version_string,\r\n                           char *server_version_string,\r\n                           char *ckexinit, int ckexinitlen,\r\n                           char *skexinit, int skexinitlen,\r\n                           u_char *serverhostkeyblob, int sbloblen,\r\n                           BIGNUM *client_dh_pub,\r\n                           BIGNUM *server_dh_pub,\r\n                           BIGNUM *shared_secret,\r\n                           unsigned int *hashlen)\r\n{\r\n\tbuffer_t *b;\r\n\tstatic unsigned char digest[EVP_MAX_MD_SIZE];\r\n\tEVP_MD_CTX *md = NULL;\r\n\r\n\tmd = EVP_MD_CTX_new();\r\n\tif (md == NULL)\r\n\t\tgoto error;\r\n\r\n\tb = buffer_init();\r\n\tbuffer_put_string(b, client_version_string, strlen(client_version_string));\r\n\tbuffer_put_string(b, server_version_string, strlen(server_version_string));\r\n\r\n\t/* kexinit messages: fake header: len+SSH2_MSG_KEXINIT */\r\n\tbuffer_put_int(b, ckexinitlen+1);\r\n\tbuffer_put_char(b, SSH2_MSG_KEXINIT);\r\n\tbuffer_append(b, ckexinit, ckexinitlen);\r\n\tbuffer_put_int(b, skexinitlen+1);\r\n\tbuffer_put_char(b, SSH2_MSG_KEXINIT);\r\n\tbuffer_append(b, skexinit, skexinitlen);\r\n\r\n\tbuffer_put_string(b, serverhostkeyblob, sbloblen);\r\n\tbuffer_put_bignum2(b, client_dh_pub);\r\n\tbuffer_put_bignum2(b, server_dh_pub);\r\n\tbuffer_put_bignum2(b, shared_secret);\r\n\r\n\t// yutaka\r\n\t//debug_print(38, buffer_ptr(b), buffer_len(b));\r\n\r\n\tEVP_DigestInit(md, evp_md);\r\n\tEVP_DigestUpdate(md, buffer_ptr(b), buffer_len(b));\r\n\tEVP_DigestFinal(md, digest, NULL);\r\n\r\n\tbuffer_free(b);\r\n\r\n\t//write_buffer_file(digest, EVP_MD_size(evp_md));\r\n\r\n\t*hashlen = EVP_MD_size(evp_md);\r\n\r\nerror:\r\n\tif (md)\r\n\t\tEVP_MD_CTX_free(md);\r\n\r\n\treturn digest;\r\n}\r\n\r\n\r\n// shared secret \ufffd\ufffd\ufffdv\ufffdZ\ufffd\ufffd\ufffd\ufffd (DH GEX\ufffdp)\r\nunsigned char *kex_dh_gex_hash(const EVP_MD *evp_md,\r\n                               char *client_version_string,\r\n                               char *server_version_string,\r\n                               char *ckexinit, int ckexinitlen,\r\n                               char *skexinit, int skexinitlen,\r\n                               u_char *serverhostkeyblob, int sbloblen,\r\n                               int kexgex_min,\r\n                               int kexgex_bits,\r\n                               int kexgex_max,\r\n                               BIGNUM *kexgex_p,\r\n                               BIGNUM *kexgex_g,\r\n                               BIGNUM *client_dh_pub,\r\n                               BIGNUM *server_dh_pub,\r\n                               BIGNUM *shared_secret,\r\n                               unsigned int *hashlen)\r\n{\r\n\tbuffer_t *b;\r\n\tstatic unsigned char digest[EVP_MAX_MD_SIZE];\r\n\tEVP_MD_CTX *md = NULL;\r\n\r\n\tmd = EVP_MD_CTX_new();\r\n\tif (md == NULL)\r\n\t\tgoto error;\r\n\r\n\tb = buffer_init();\r\n\tbuffer_put_string(b, client_version_string, strlen(client_version_string));\r\n\tbuffer_put_string(b, server_version_string, strlen(server_version_string));\r\n\r\n\t/* kexinit messages: fake header: len+SSH2_MSG_KEXINIT */\r\n\tbuffer_put_int(b, ckexinitlen+1);\r\n\tbuffer_put_char(b, SSH2_MSG_KEXINIT);\r\n\tbuffer_append(b, ckexinit, ckexinitlen);\r\n\tbuffer_put_int(b, skexinitlen+1);\r\n\tbuffer_put_char(b, SSH2_MSG_KEXINIT);\r\n\tbuffer_append(b, skexinit, skexinitlen);\r\n\r\n\tbuffer_put_string(b, serverhostkeyblob, sbloblen);\r\n\r\n\t// DH group size\ufffd\u0303r\ufffdb\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdZ\ufffd\ufffd\ufffd\ufffd\r\n\tbuffer_put_int(b, kexgex_min);\r\n\tbuffer_put_int(b, kexgex_bits);\r\n\tbuffer_put_int(b, kexgex_max);\r\n\r\n\t// DH\ufffd\ufffd\ufffd\u0311f\ufffd\ufffd\ufffd\u0190\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdZ\ufffd\ufffd\ufffd\ufffd\r\n\tbuffer_put_bignum2(b, kexgex_p);\r\n\tbuffer_put_bignum2(b, kexgex_g);\r\n\r\n\tbuffer_put_bignum2(b, client_dh_pub);\r\n\tbuffer_put_bignum2(b, server_dh_pub);\r\n\tbuffer_put_bignum2(b, shared_secret);\r\n\r\n\t// yutaka\r\n\t//debug_print(38, buffer_ptr(b), buffer_len(b));\r\n\r\n\tEVP_DigestInit(md, evp_md);\r\n\tEVP_DigestUpdate(md, buffer_ptr(b), buffer_len(b));\r\n\tEVP_DigestFinal(md, digest, NULL);\r\n\r\n\tbuffer_free(b);\r\n\r\n\t//write_buffer_file(digest, EVP_MD_size(evp_md));\r\n\r\n\t*hashlen = EVP_MD_size(evp_md);\r\n\r\nerror:\r\n\tif (md)\r\n\t\tEVP_MD_CTX_free(md);\r\n\r\n\treturn digest;\r\n}\r\n\r\n\r\nunsigned char *kex_ecdh_hash(const EVP_MD *evp_md,\r\n                             const EC_GROUP *ec_group,\r\n                             char *client_version_string,\r\n                             char *server_version_string,\r\n                             char *ckexinit, int ckexinitlen,\r\n                             char *skexinit, int skexinitlen,\r\n                             u_char *serverhostkeyblob, int sbloblen,\r\n                             const EC_POINT *client_dh_pub,\r\n                             const EC_POINT *server_dh_pub,\r\n                             BIGNUM *shared_secret,\r\n                             unsigned int *hashlen)\r\n{\r\n\tbuffer_t *b;\r\n\tstatic unsigned char digest[EVP_MAX_MD_SIZE];\r\n\tEVP_MD_CTX *md = NULL;\r\n\r\n\tmd = EVP_MD_CTX_new();\r\n\tif (md == NULL)\r\n\t\tgoto error;\r\n\r\n\tb = buffer_init();\r\n\tbuffer_put_string(b, client_version_string, strlen(client_version_string));\r\n\tbuffer_put_string(b, server_version_string, strlen(server_version_string));\r\n\r\n\t/* kexinit messages: fake header: len+SSH2_MSG_KEXINIT */\r\n\tbuffer_put_int(b, ckexinitlen+1);\r\n\tbuffer_put_char(b, SSH2_MSG_KEXINIT);\r\n\tbuffer_append(b, ckexinit, ckexinitlen);\r\n\tbuffer_put_int(b, skexinitlen+1);\r\n\tbuffer_put_char(b, SSH2_MSG_KEXINIT);\r\n\tbuffer_append(b, skexinit, skexinitlen);\r\n\r\n\tbuffer_put_string(b, serverhostkeyblob, sbloblen);\r\n\r\n\tbuffer_put_ecpoint(b, ec_group, client_dh_pub);\r\n\tbuffer_put_ecpoint(b, ec_group, server_dh_pub);\r\n\tbuffer_put_bignum2(b, shared_secret);\r\n\r\n\t// yutaka\r\n\t//debug_print(38, buffer_ptr(b), buffer_len(b));\r\n\r\n\tEVP_DigestInit(md, evp_md);\r\n\tEVP_DigestUpdate(md, buffer_ptr(b), buffer_len(b));\r\n\tEVP_DigestFinal(md, digest, NULL);\r\n\r\n\tbuffer_free(b);\r\n\r\n\t//write_buffer_file(digest, EVP_MD_size(evp_md));\r\n\r\n\t*hashlen = EVP_MD_size(evp_md);\r\n\r\nerror:\r\n\tif (md)\r\n\t\tEVP_MD_CTX_free(md);\r\n\r\n\treturn digest;\r\n}\r\n\r\n\r\nint dh_pub_is_valid(DH *dh, BIGNUM *dh_pub)\r\n{\r\n\tint i;\r\n\tint n = BN_num_bits(dh_pub);\r\n\tint bits_set = 0;\r\n\tconst BIGNUM *p;\r\n\r\n\t// OpenSSL 1.1.0\ufffd\u0141ABIGNUM\ufffd\\\ufffd\ufffd\ufffd\u0302\ufffdneg\ufffd\ufffd\ufffd\ufffd\ufffdo\ufffd[\ufffd\u0252\ufffd\ufffd\u0683A\ufffdN\ufffdZ\ufffdX\ufffd\u0142\ufffd\ufffd\u0202\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u07c1A\r\n\t// BN_is_negative\ufffd\u0590\ufffd\ufffd\u0252u\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdBOpenSSL 1.0.2\ufffd\u0142\u0343}\ufffdN\ufffd\ufffd\ufffd\ufffd`\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\u0302\u0141A\r\n\t// OpenSSL 1.0.2\ufffd\u0142\ufffd\ufffdA\ufffd\ufffd\ufffd\u030f\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0142\u60a2\ufffdB\r\n\tif (BN_is_negative(dh_pub)) {\r\n\t\t//logit(\"invalid public DH value: negativ\");\r\n\t\treturn 0;\r\n\t}\r\n\tfor (i = 0; i <= n; i++)\r\n\t\tif (BN_is_bit_set(dh_pub, i))\r\n\t\t\tbits_set++;\r\n\t//debug2(\"bits set: %d/%d\", bits_set, BN_num_bits(dh->p));\r\n\r\n\t/* if g==2 and bits_set==1 then computing log_g(dh_pub) is trivial */\r\n\tDH_get0_pqg(dh, &p, NULL, NULL);\r\n\tif (bits_set > 1 && (BN_cmp(dh_pub, p) == -1))\r\n\t\treturn 1;\r\n\t//logit(\"invalid public DH value (%d/%d)\", bits_set, BN_num_bits(dh->p));\r\n\treturn 0;\r\n}\r\n\r\n\r\nstatic u_char *derive_key(int id, int need, u_char *hash, BIGNUM *shared_secret,\r\n                          char *session_id, int session_id_len,\r\n                          const EVP_MD *evp_md)\r\n{\r\n\tbuffer_t *b;\r\n\tEVP_MD_CTX *md = NULL;\r\n\tchar c = id;\r\n\tint have;\r\n\tint mdsz = EVP_MD_size(evp_md);\r\n\tu_char *digest = malloc(roundup(need, mdsz));\r\n\r\n\tmd = EVP_MD_CTX_new();\r\n\tif (md == NULL)\r\n\t\tgoto skip;\r\n\r\n\tif (digest == NULL)\r\n\t\tgoto skip;\r\n\r\n\tb = buffer_init();\r\n\tif (b == NULL)\r\n\t\tgoto skip;\r\n\r\n\tbuffer_put_bignum2(b, shared_secret);\r\n\r\n\t/* K1 = HASH(K || H || \"A\" || session_id) */\r\n\tEVP_DigestInit(md, evp_md);\r\n\tEVP_DigestUpdate(md, buffer_ptr(b), buffer_len(b));\r\n\tEVP_DigestUpdate(md, hash, mdsz);\r\n\tEVP_DigestUpdate(md, &c, 1);\r\n\tEVP_DigestUpdate(md, session_id, session_id_len);\r\n\tEVP_DigestFinal(md, digest, NULL);\r\n\r\n\t/*\r\n\t * expand key:\r\n\t * Kn = HASH(K || H || K1 || K2 || ... || Kn-1)\r\n\t * Key = K1 || K2 || ... || Kn\r\n\t */\r\n\tfor (have = mdsz; need > have; have += mdsz) {\r\n\t\tEVP_DigestInit(md, evp_md);\r\n\t\tEVP_DigestUpdate(md, buffer_ptr(b), buffer_len(b));\r\n\t\tEVP_DigestUpdate(md, hash, mdsz);\r\n\t\tEVP_DigestUpdate(md, digest, have);\r\n\t\tEVP_DigestFinal(md, digest + have, NULL);\r\n\t}\r\n\tbuffer_free(b);\r\n\r\nskip:;\r\n\tif (md)\r\n\t\tEVP_MD_CTX_free(md);\r\n\r\n\treturn digest;\r\n}\r\n\r\n/*\r\n * \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u030c\ufffd\ufffd\u0282\ufffd\ufffd\ufffde\ufffd\ufffd\ufffd\ud803\udd90\ufffd\ufffd\ufffd newkeys \ufffd\u0243Z\ufffdb\ufffdg\ufffd\ufffd\ufffd\u0116\u07c2\ufffd\ufffdB\r\n */\r\nvoid kex_derive_keys(PTInstVar pvar, SSHKeys *newkeys, int need, u_char *hash, BIGNUM *shared_secret,\r\n                     char *session_id, int session_id_len)\r\n{\r\n#define NKEYS\t6\r\n\tu_char *keys[NKEYS];\r\n\tint i, mode, ctos;\r\n\r\n\tfor (i = 0; i < NKEYS; i++) {\r\n\t\tkeys[i] = derive_key('A'+i, need, hash, shared_secret, session_id, session_id_len,\r\n\t\t                     get_kex_algorithm_EVP_MD(pvar->kex_type));\r\n\t\t//debug_print(i, keys[i], need);\r\n\t}\r\n\r\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\r\n\t\tif (mode == MODE_OUT)\r\n\t\t\tctos = 1;\r\n\t\telse\r\n\t\t\tctos = 0;\r\n\r\n\t\t// setting\r\n\t\tnewkeys[mode].enc.iv  = keys[ctos ? 0 : 1];\r\n\t\tnewkeys[mode].enc.key = keys[ctos ? 2 : 3];\r\n\t\tnewkeys[mode].mac.key = keys[ctos ? 4 : 5];\r\n\r\n\t\t//debug_print(20 + mode*3, newkeys[mode]->enc.iv, 8);\r\n\t\t//debug_print(21 + mode*3, newkeys[mode]->enc.key, 24);\r\n\t\t//debug_print(22 + mode*3, newkeys[mode]->mac.key, 24);\r\n\t}\r\n}\r\n", "/*\r\n * Copyright (c) 1998-2001, Robert O'Callahan\r\n * (C) 2004- TeraTerm Project\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions\r\n * are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright\r\n *    notice, this list of conditions and the following disclaimer.\r\n * 2. Redistributions in binary form must reproduce the above copyright\r\n *    notice, this list of conditions and the following disclaimer in the\r\n *    documentation and/or other materials provided with the distribution.\r\n * 3. The name of the author may not be used to endorse or promote products\r\n *    derived from this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\r\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,\r\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\r\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n#include \"ttxssh.h\"\r\n#include \"util.h\"\r\n#include \"resource.h\"\r\n#include \"libputty.h\"\r\n#include \"key.h\"\r\n#include \"ttcommon.h\"\r\n#include \"codeconv.h\"\r\n#include \"ttxssh-version.h\"\r\n\r\n#include <openssl/bn.h>\r\n#include <openssl/evp.h>\r\n#include <openssl/dh.h>\r\n#include <openssl/engine.h>\r\n#include <openssl/rsa.h>\r\n#include <openssl/dsa.h>\r\n#include <openssl/md5.h>\r\n\r\n#include <limits.h>\r\n#include <malloc.h>\r\n#include <string.h>\r\n#if !defined(_CRTDBG_MAP_ALLOC)\r\n#define _CRTDBG_MAP_ALLOC\r\n#endif\r\n#include <stdlib.h>\r\n#include <crtdbg.h>\r\n#include <process.h>\r\n#include <time.h>\r\n#include <commctrl.h>\r\n#include <sys/types.h>\r\n#include <sys/stat.h>\r\n#include <sys/utime.h>\r\n#include <assert.h>\r\n\r\n#include <direct.h>\r\n#include <io.h>\r\n#ifdef _DEBUG\t// KEX logging\r\n#include <fcntl.h>\r\n#endif\r\n\r\n\r\n#include \"buffer.h\"\r\n#include \"ssh.h\"\r\n#include \"crypt.h\"\r\n#include \"fwd.h\"\r\n#include \"sftp.h\"\r\n#include \"kex.h\"\r\n#include \"dlglib.h\"\r\n#include \"win32helper.h\"\r\n\r\n#ifndef MAX\r\n# define MAX(a,b) (((a)>(b))?(a):(b))\r\n# define MIN(a,b) (((a)<(b))?(a):(b))\r\n#endif\r\n\r\n// SSH2 macro\r\n#ifdef _DEBUG\r\n#define SSH2_DEBUG\r\n#endif\r\n\r\n//#define DONT_WANTCONFIRM 1  // (2005.3.28 yutaka)\r\n#undef DONT_WANTCONFIRM // (2008.11.25 maya)\r\n\r\n//\r\n// SSH2 data structure\r\n//\r\n\r\n// channel data structure\r\n#define CHANNEL_MAX 100\r\n\r\n//\r\n// msg \ufffd\ufffd NULL \ufffd\u0142\u0356\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0315\u06cf\u0601BNULL \ufffd\u030f\ua347\ufffd\ufffd \"(null)\" \ufffd\ufffd\u0502\ufffd\ufffdB\r\n//\r\n#define NonNull(msg) ((msg)?(msg):\"(null)\")\r\n\r\ntypedef enum {\r\n\tGetPayloadError = 0,\r\n\tGetPayloadOK = 1,\r\n\tGetPayloadTruncate = 2\r\n} PayloadStat;\r\n\r\nstatic struct global_confirm global_confirms;\r\n\r\nstatic Channel_t channels[CHANNEL_MAX];\r\n\r\nstatic char ssh_ttymodes[] = \"\\x01\\x03\\x02\\x1c\\x03\\x08\\x04\\x15\\x05\\x04\";\r\n\r\nstatic CRITICAL_SECTION g_ssh_scp_lock;   /* SCP\ufffd\ufffdM\ufffdp\ufffd\ufffd\ufffdb\ufffdN */\r\n\r\nstatic int g_scp_sending;  /* SCP\ufffd\ufffd\ufffdM\ufffd\ufffd\ufffd\ufffd? */\r\n\r\nstatic void try_send_credentials(PTInstVar pvar);\r\nstatic void prep_compression(PTInstVar pvar);\r\n\r\n// \ufffd\u0590\ufffd\ufffdv\ufffd\ufffd\ufffdg\ufffd^\ufffdC\ufffdv\ufffd\u933e\r\nvoid SSH2_send_kexinit(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_kexinit(PTInstVar pvar);\r\nstatic void SSH2_dh_kex_init(PTInstVar pvar);\r\nstatic void SSH2_dh_gex_kex_init(PTInstVar pvar);\r\nstatic void SSH2_ecdh_kex_init(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_dh_common_reply(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_dh_gex_reply(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_newkeys(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_service_accept(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_ext_info(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_userauth_success(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_userauth_failure(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_userauth_banner(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_open_confirm(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_open_failure(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_client_global_request(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_request_success(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_request_failure(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_channel_success(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_channel_failure(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_channel_data(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_channel_extended_data(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_channel_eof(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_channel_close(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_channel_open(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_window_adjust(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_channel_request(PTInstVar pvar);\r\nvoid SSH2_dispatch_init(int stage);\r\nint SSH2_dispatch_enabled_check(unsigned char message);\r\nvoid SSH2_dispatch_add_message(unsigned char message);\r\nvoid SSH2_dispatch_add_range_message(unsigned char begin, unsigned char end);\r\nint dh_pub_is_valid(DH *dh, BIGNUM *dh_pub);\r\nstatic void start_ssh_heartbeat_thread(PTInstVar pvar);\r\nvoid ssh2_channel_send_close(PTInstVar pvar, Channel_t *c);\r\nstatic BOOL SSH_agent_response(PTInstVar pvar, Channel_t *c, int local_channel_num, unsigned char *data, unsigned int buflen);\r\nstatic void ssh2_scp_get_packetlist(PTInstVar pvar, Channel_t *c, unsigned char **buf, unsigned int *buflen);\r\nstatic void ssh2_scp_free_packetlist(PTInstVar pvar, Channel_t *c);\r\nstatic void get_window_pixel_size(PTInstVar pvar, int *x, int *y);\r\nstatic void do_SSH2_dispatch_setup_for_transfer(PTInstVar pvar);\r\nstatic void ssh2_prep_userauth(PTInstVar pvar);\r\nstatic void ssh2_send_newkeys(PTInstVar pvar);\r\n\r\n// \ufffd}\ufffdN\ufffd\ufffd\r\n#define remained_payload(pvar) ((pvar)->ssh_state.payload + payload_current_offset(pvar))\r\n#define remained_payloadlen(pvar) ((pvar)->ssh_state.payloadlen - (pvar)->ssh_state.payload_grabbed)\r\n#define payload_current_offset(pvar) ((pvar)->ssh_state.payload_grabbed - 1)\r\n\r\n//\r\n// Global request confirm\r\n//\r\nstatic void client_init_global_confirm(void)\r\n{\r\n\tmemset(&global_confirms, 0, sizeof(global_confirms));\r\n\tglobal_confirms.ref_count = 0;\r\n}\r\n\r\nvoid client_register_global_confirm(global_confirm_cb *cb, void *ctx)\r\n{\r\n\tstruct global_confirm *gc = &global_confirms;\r\n\r\n\tif (gc->ref_count == 0) {\r\n\t\tgc->cb = cb;\r\n\t\tgc->ctx = ctx;\r\n\t\tgc->ref_count = 1;\r\n\t}\r\n}\r\n\r\nstatic int client_global_request_reply(PTInstVar pvar, int type, unsigned int seq, void *ctxt)\r\n{\r\n\tstruct global_confirm *gc = &global_confirms;\r\n\r\n\tif (gc->ref_count >= 1) {\r\n\t\tif (gc->cb)\r\n\t\t\tgc->cb(pvar, type, seq, gc->ctx);\r\n\t\tgc->ref_count = 0;\r\n\t}\r\n\r\n\treturn 0;\r\n}\r\n\r\n//\r\n// channel function\r\n//\r\nstatic Channel_t *ssh2_channel_new(unsigned int window, unsigned int maxpack,\r\n                                   enum channel_type type, int local_num)\r\n{\r\n\tint i, found;\r\n\tChannel_t *c;\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: local_num %d\", __FUNCTION__, local_num);\r\n\r\n\tfound = -1;\r\n\tfor (i = 0 ; i < CHANNEL_MAX ; i++) {\r\n\t\tif (channels[i].used == 0) { // free channel\r\n\t\t\tfound = i;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tif (found == -1) { // not free channel\r\n\t\treturn (NULL);\r\n\t}\r\n\r\n\t// setup\r\n\tc = &channels[found];\r\n\tmemset(c, 0, sizeof(Channel_t));\r\n\tc->used = 1;\r\n\tc->self_id = i;\r\n\tc->remote_id = SSH_CHANNEL_INVALID;\r\n\tc->local_window = window;\r\n\tc->local_window_max = window;\r\n\tc->local_consumed = 0;\r\n\tc->local_maxpacket = maxpack;\r\n\tc->remote_window = 0;\r\n\tc->remote_maxpacket = 0;\r\n\tc->type = type;\r\n\tc->local_num = local_num;  // alloc_channel()\ufffd\u0315\u0512l\ufffd\ufffd\u06d1\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\r\n\tc->bufchain = NULL;\r\n\tc->bufchain_amount = 0;\r\n\tc->bufchain_recv_suspended = FALSE;\r\n\tif (type == TYPE_SCP) {\r\n\t\tc->scp.state = SCP_INIT;\r\n\t\tc->scp.progress_window = NULL;\r\n\t\tc->scp.thread = INVALID_HANDLE_VALUE;\r\n\t\tc->scp.localfp = NULL;\r\n\t\tc->scp.filemtime = 0;\r\n\t\tc->scp.fileatime = 0;\r\n\t\tc->scp.pktlist_cursize = 0;\r\n\t}\r\n\tif (type == TYPE_AGENT) {\r\n\t\tc->agent_msg = buffer_init();\r\n\t\tc->agent_request_len = 0;\r\n\t}\r\n\tc->state = 0;\r\n\r\n\treturn (c);\r\n}\r\n\r\n// remote_window\ufffd\u030b\udaca\udec2\ufffd\ufffd\u0202\ufffd\ufffd\ua347\ufffd\u0241A\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdo\ufffdb\ufffdt\ufffd@\ufffd\ufffd\ufffd\ufffd\ufffdX\ufffdg\ufffdi\ufffd\ufffd\ufffd\u034f\ufffd\ufffdj\ufffd\u0582\u0082\u0202\ufffd\ufffd\u0142\ufffd\ufffd\ufffd\ufffdB\r\n// \ufffd\ufffd\ufffd\ufffd\ufffd\u014am\ufffd\u06c2\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd ssh2_channel_retry_send_bufchain() \ufffd\u0149\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\nstatic void ssh2_channel_add_bufchain(PTInstVar pvar, Channel_t *c, unsigned char *buf, unsigned int buflen)\r\n{\r\n\tbufchain_t *p, *old;\r\n\r\n\t// allocate new buffer\r\n\tp = malloc(sizeof(bufchain_t));\r\n\tif (p == NULL)\r\n\t\treturn;\r\n\tp->msg = buffer_init();\r\n\tif (p == NULL) {\r\n\t\tfree(p);\r\n\t\treturn;\r\n\t}\r\n\tbuffer_put_raw(p->msg, buf, buflen);\r\n\tp->next = NULL;\r\n\r\n\tif (c->bufchain == NULL) {\r\n\t\tc->bufchain = p;\r\n\t} else {\r\n\t\told = c->bufchain;\r\n\t\twhile (old->next)\r\n\t\t\told = old->next;\r\n\t\told->next = p;\r\n\t}\r\n\r\n\t// \ufffdo\ufffdb\ufffdt\ufffd@\ufffdT\ufffdC\ufffdY\ufffd\u030d\ufffd\ufffdv\ufffd\ufffd\ufffdX\ufffdV\ufffd\ufffd\ufffd\ufffd(\ufffdL\ufffd^\ufffdp)\r\n\tc->bufchain_amount += buflen;\r\n\r\n\t// remote_window\ufffd\u030b\udaca\udec2\ufffd\ufffd\u0202\ufffd\ufffd\u0302\u0141Alocal connection\ufffd\ufffd\ufffd\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffd\ufffdM\ufffd\ufffd\r\n\t// \ufffd\ufffd~\ufffdw\ufffd\ufffd\ufffd\ufffd\ufffdo\ufffd\ufffd\ufffdB\ufffd\ufffd\ufffd\ufffd\ufffd\u0252\u0292m\ufffd\ufffd\ufffd~\ufffd\u0702\ufffd\ud0af\ufffd\u0142\u0342\u0202\ufffd\ufffdB\r\n\tFWD_suspend_resume_local_connection(pvar, c, FALSE);\r\n}\r\n\r\n// remote_window\ufffd\u030b\udaca\udec2\ufffd\ufffd\u0142\ufffd\ufffd\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffdX\ufffdg\ufffd\u024ec\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffdf\ufffd[\ufffd^\ufffd\ufffd\ufffd\ufffd\ufffd\u0502\u0251\ufffd\ufffd\ufffdB\r\n// \ufffd\ufffd\ufffdM\ufffd\ufffd\ufffd\u0142\ufffd\ufffd\ufffd\ufffd\u70c1\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\nstatic void ssh2_channel_retry_send_bufchain(PTInstVar pvar, Channel_t *c)\r\n{\r\n\tbufchain_t *ch;\r\n\tunsigned int size;\r\n\tbufchain_t* ch_origin = c->bufchain;\r\n\r\n\twhile (c->bufchain) {\r\n\t\t// \ufffd\u64ea\ufffd\ufffd\ufffd\ufffd\ufffd\u0251\ufffd\ufffd\ufffd\r\n\t\tch = c->bufchain;\r\n\t\tsize = buffer_len(ch->msg);\r\n\t\tif (size >= c->remote_window)\r\n\t\t\tbreak;\r\n\r\n\t\tif (c->local_num == -1) { // shell or SCP\r\n\t\t\tSSH2_send_channel_data(pvar, c, buffer_ptr(ch->msg), size, TRUE);\r\n\t\t} else { // port-forwarding\r\n\t\t\tSSH_channel_send(pvar, c->local_num, -1, buffer_ptr(ch->msg), size, TRUE);\r\n\t\t}\r\n\r\n\t\tc->bufchain = ch->next;\r\n\r\n\t\tbuffer_free(ch->msg);\r\n\t\tfree(ch);\r\n\r\n\t\t// \ufffdo\ufffdb\ufffdt\ufffd@\ufffdT\ufffdC\ufffdY\ufffd\u030d\ufffd\ufffdv\ufffd\ufffd\ufffdX\ufffdV\ufffd\ufffd\ufffd\ufffd(\ufffdL\ufffd^\ufffdp)\r\n\t\tc->bufchain_amount -= size;\r\n\t}\r\n\r\n\t// \ufffd\ufffd\ufffdX\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdX\ufffdg\ufffd\ufffd\ufffd\ufffd\u0242\u0202\ufffd\ufffd\ufffd\ufffd\ufffdA\r\n\t// local connection\ufffd\ufffd\ufffd\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffd\u0292m\ufffd\ufffd\ufffd\u010aJ\ufffd\ufffd\ufffd\ufffdB\r\n\tif (ch_origin && c->bufchain == NULL) {\r\n\t\tFWD_suspend_resume_local_connection(pvar, c, TRUE);\r\n\t}\r\n}\r\n\r\n// channel close\ufffd\ufffd\ufffd\u0243`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\\\ufffd\ufffd\ufffd\u0302\ufffd\ufffd\ufffd\ufffdX\ufffdg\ufffd\u0595\u050bp\ufffd\ufffd\ufffd\ufffd\r\n// (2007.4.26 yutaka)\r\nstatic void ssh2_channel_delete(Channel_t *c)\r\n{\r\n\tbufchain_t *ch, *ptr;\r\n\tenum scp_state prev_state;\r\n\r\n\tch = c->bufchain;\r\n\twhile (ch) {\r\n\t\tif (ch->msg)\r\n\t\t\tbuffer_free(ch->msg);\r\n\t\tptr = ch;\r\n\t\tch = ch->next;\r\n\t\tfree(ptr);\r\n\t}\r\n\r\n\tif (c->type == TYPE_SCP) {\r\n\t\t// SCP\ufffd\ufffd\ufffd\ufffd\ufffd\u030d\u014c\ufffd\u030f\ufffd\u0502\ufffd\u06d1\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\tprev_state = c->scp.state;\r\n\r\n\t\tc->scp.state = SCP_CLOSING;\r\n\t\tif (c->scp.localfp != NULL) {\r\n\t\t\tfclose(c->scp.localfp);\r\n\t\t\tif (c->scp.dir == FROMREMOTE) {\r\n\t\t\t\tif (c->scp.fileatime > 0 && c->scp.filemtime > 0) {\r\n\t\t\t\t\tstruct _utimbuf filetime;\r\n\t\t\t\t\tfiletime.actime = c->scp.fileatime;\r\n\t\t\t\t\tfiletime.modtime = c->scp.filemtime;\r\n\t\t\t\t\t_utime(c->scp.localfilefull, &filetime);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// SCP\ufffd\ufffdM\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\u0381A\ufffd\ufffd\ufffd[\ufffdJ\ufffd\ufffd\ufffd\u024d\ufffd\ufffd\ufffd\ufffd\ufffdt\ufffd@\ufffdC\ufffd\ufffd\ufffd\u030ec\ufffd[\ufffd\ufffd\ufffd\ud3dc\ufffd\ufffd\ufffd\ufffdB\r\n\t\t\t\t// (2017.2.12 yutaka)\r\n\t\t\t\tif (prev_state != SCP_CLOSING)\r\n\t\t\t\t\tremove(c->scp.localfilefull);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (c->scp.progress_window != NULL) {\r\n\t\t\tDestroyWindow(c->scp.progress_window);\r\n\t\t\tc->scp.progress_window = NULL;\r\n\t\t}\r\n\t\tif (c->scp.thread != INVALID_HANDLE_VALUE) {\r\n\t\t\tWaitForSingleObject(c->scp.thread, INFINITE);\r\n\t\t\tCloseHandle(c->scp.thread);\r\n\t\t\tc->scp.thread = INVALID_HANDLE_VALUE;\r\n\t\t}\r\n\r\n\t\t// SCP\ufffd\ufffdM\ufffd\u030f\ua347\ufffd\u0302\u0741ASCP\ufffdp\ufffd\ufffd\ufffdX\ufffdg\ufffd\u030aJ\ufffd\ufffd\ufffd\ufffd\ufffds\ufffd\ufffd\ufffdB\r\n\t\t// Windows9x\ufffd\u0157\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdC\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\tif (c->scp.dir == FROMREMOTE) {\r\n\t\t\tPTInstVar pvar = c->scp.pvar;\r\n\t\t\tssh2_scp_free_packetlist(pvar, c);\r\n\t\t}\r\n\r\n\t\tg_scp_sending = FALSE;\r\n\t}\r\n\tif (c->type == TYPE_AGENT) {\r\n\t\tbuffer_free(c->agent_msg);\r\n\t}\r\n\r\n\tmemset(c, 0, sizeof(Channel_t));\r\n\tc->used = 0;\r\n}\r\n\r\n// connection close\ufffd\ufffd\ufffd\u024c\u0102\u0382\ufffd\ufffd\r\nvoid ssh2_channel_free(void)\r\n{\r\n\tint i;\r\n\tChannel_t *c;\r\n\r\n\tfor (i = 0 ; i < CHANNEL_MAX ; i++) {\r\n\t\tc = &channels[i];\r\n\t\tssh2_channel_delete(c);\r\n\t}\r\n}\r\n\r\nstatic Channel_t *ssh2_channel_lookup(int id)\r\n{\r\n\tChannel_t *c;\r\n\r\n\tif (id < 0 || id >= CHANNEL_MAX) {\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: invalid channel id. (%d)\", __FUNCTION__, id);\r\n\t\treturn (NULL);\r\n\t}\r\n\tc = &channels[id];\r\n\tif (c->used == 0) { // already freed\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: channel was already freed. id:%d\", __FUNCTION__, id);\r\n\t\treturn (NULL);\r\n\t}\r\n\treturn (c);\r\n}\r\n\r\n// SSH1\ufffd\u014a\u01d7\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffdchannel\ufffd\\\ufffd\ufffd\ufffd\u0302\ufffd\ufffd\ufffdASSH2\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdChannel_t\ufffd\u0595\u03ca\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n// TODO: \ufffd\ufffd\ufffd\ufffd\ufffdI\ufffd\u0242\u0343`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\\\ufffd\ufffd\ufffd\u0302\ufffd1\ufffd\u0082\u0253\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n// (2005.6.12 yutaka)\r\nChannel_t *ssh2_local_channel_lookup(int local_num)\r\n{\r\n\tint i;\r\n\tChannel_t *c;\r\n\r\n\tfor (i = 0 ; i < CHANNEL_MAX ; i++) {\r\n\t\tc = &channels[i];\r\n\t\tif (c->type != TYPE_PORTFWD)\r\n\t\t\tcontinue;\r\n\t\tif (c->local_num == local_num)\r\n\t\t\treturn (c);\r\n\t}\r\n\treturn (NULL);\r\n}\r\n\r\n//\r\n// SSH heartbeat mutex\r\n//\r\n// TTSSH\ufffd\ufffd thread-safe \ufffd\u0142\u0342\u0202\ufffd\ufffd\ufffd\ufffd\u07c1A\ufffd}\ufffd\ufffd\ufffd`\ufffdX\ufffd\ufffd\ufffdb\ufffdh\ufffd\ufffd\ufffd\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffdM\ufffd\u0342\u0142\ufffd\ufffd\u0202\ufffd\ufffdB\r\n// \ufffdV\ufffd\ufffd\ufffdO\ufffd\ufffd\ufffdX\ufffd\ufffd\ufffdb\ufffdh\ufffd\u0142\u0343R\ufffd\ufffd\ufffde\ufffdL\ufffdX\ufffdg\ufffdX\ufffdC\ufffdb\ufffd`\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u90b1\ufffd\u0182\u0342\u0202\ufffd\ufffd\ufffd\ufffd\u07c1A\r\n// \ufffd\ufffd\ufffdb\ufffdN\ufffd\ufffd\ufffd\ufffd\ufffdK\ufffdv\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffd\u07c1A\ufffd\ud3dc\ufffd\ufffd\ufffd\ufffdB(2007.12.26 yutaka)\r\n//\r\nstatic CRITICAL_SECTION g_ssh_heartbeat_lock;   /* \ufffd\ufffd\ufffd\ufffdM\ufffdp\ufffd\ufffd\ufffdb\ufffdN */\r\n\r\nvoid ssh_heartbeat_lock_initialize(void)\r\n{\r\n\t//InitializeCriticalSection(&g_ssh_heartbeat_lock);\r\n}\r\n\r\nvoid ssh_heartbeat_lock_finalize(void)\r\n{\r\n\t//DeleteCriticalSection(&g_ssh_heartbeat_lock);\r\n}\r\n\r\nvoid ssh_heartbeat_lock(void)\r\n{\r\n\t//EnterCriticalSection(&g_ssh_heartbeat_lock);\r\n}\r\n\r\nvoid ssh_heartbeat_unlock(void)\r\n{\r\n\t//LeaveCriticalSection(&g_ssh_heartbeat_lock);\r\n}\r\n\r\n//\r\n// SSH memory dump (for debug)\r\n//\r\n// (2005.3.7 yutaka)\r\n//\r\n#define MEMTAG_MAX 300\r\n#define LOGDUMP L\"ssh2connect.log\"\r\n#define LOG_PACKET_DUMP L\"ssh2packet.log\"\r\n#define SENDTOME L\"Please send '\" LOGDUMP L\"' file to Tera Term developer team.\"\r\n\r\ntypedef struct memtag {\r\n\tchar *name;\r\n\tchar *desc;\r\n\ttime_t time;\r\n\tint len;\r\n\tchar *data;\r\n} memtag_t;\r\n\r\nstatic memtag_t memtags[MEMTAG_MAX];\r\nstatic int memtag_count = 0;\r\nstatic int memtag_use = 0;\r\n\r\n/* \ufffd_\ufffd\ufffd\ufffdv\ufffd\ufffd\ufffdC\ufffd\ufffd\ufffd\ufffd\ufffdt\ufffdH\ufffd[\ufffd}\ufffdb\ufffdg\ufffd\\\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd */\r\nstatic void displine_memdump(FILE *fp, int addr, int *bytes, int byte_cnt)\r\n{\r\n\tint i, c;\r\n\r\n\t/* \ufffd\u64ea\ufffd\u0303A\ufffdh\ufffd\ufffd\ufffdX\ufffd\\\ufffd\ufffd */\r\n\tfprintf(fp, \"%08X : \", addr);\r\n\r\n\t/* \ufffdo\ufffdC\ufffdi\ufffd\ufffd\ufffd\\\ufffd\ufffd\ufffdi4\ufffdo\ufffdC\ufffdg\ufffd\ufffd\ufffd\u0182\u024b\udb11\udc82\ufffd}\ufffd\ufffd\ufffdj*/\r\n\tfor (i = 0 ; i < byte_cnt ; i++) {\r\n\t\tif (i > 0 && i % 4 == 0)\r\n\t\t\tfprintf(fp, \" \");\r\n\r\n\t\tfprintf(fp, \"%02X\", bytes[i]);\r\n\t}\r\n\r\n\t/* ASCII\ufffd\\\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0702\u0142\u030b\udb11\udc82\ufffd\u20a4 */\r\n\tfprintf(fp, \"   %*s%*s\", (16-byte_cnt)*2+1, \" \", (16-byte_cnt+3)/4, \" \");\r\n\r\n\t/* ASCII\ufffd\\\ufffd\ufffd */\r\n\tfor (i = 0 ; i < byte_cnt ; i++) {\r\n\t\tc = bytes[i];\r\n\t\tif (isprint(c)) {\r\n\t\t\tfprintf(fp, \"%c\", c);\r\n\t\t} else {\r\n\t\t\tfprintf(fp, \".\");\r\n\t\t}\r\n\t}\r\n\r\n\tfprintf(fp, \"\\n\");\r\n}\r\n\r\n\r\n/* \ufffd_\ufffd\ufffd\ufffdv\ufffd\ufffd\ufffd[\ufffd`\ufffd\ufffd */\r\nstatic void dump_memdump(FILE *fp, char *data, int len)\r\n{\r\n\tint c, addr;\r\n\tint bytes[16], *ptr;\r\n\tint byte_cnt;\r\n\tint i;\r\n\r\n\taddr = 0;\r\n\tbyte_cnt = 0;\r\n\tptr = bytes;\r\n\tfor (i = 0 ; i < len ; i++) {\r\n\t\tc = data[i];\r\n\t\t*ptr++ = c & 0xff;\r\n\t\tbyte_cnt++;\r\n\r\n\t\tif (byte_cnt == 16) {\r\n\t\t\tdispline_memdump(fp, addr, bytes, byte_cnt);\r\n\r\n\t\t\taddr += 16;\r\n\t\t\tbyte_cnt = 0;\r\n\t\t\tptr = bytes;\r\n\t\t}\r\n\t}\r\n\r\n\tif (byte_cnt > 0) {\r\n\t\tdispline_memdump(fp, addr, bytes, byte_cnt);\r\n\t}\r\n}\r\n\r\nvoid init_memdump(void)\r\n{\r\n\tint i;\r\n\r\n\tif (memtag_use > 0)\r\n\t\treturn;\r\n\r\n\tfor (i = 0 ; i < MEMTAG_MAX ; i++) {\r\n\t\tmemtags[i].name = NULL;\r\n\t\tmemtags[i].desc = NULL;\r\n\t\tmemtags[i].data = NULL;\r\n\t\tmemtags[i].len = 0;\r\n\t}\r\n\tmemtag_use++;\r\n}\r\n\r\nvoid finish_memdump(void)\r\n{\r\n\tint i;\r\n\r\n\t// initialize\ufffd\ufffd\ufffd\ufffd\u0102\u0202\ufffd\ufffd\u0182\ufffd\ufffd\u0349\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0256\u07c2\ufffdB(2005.4.3 yutaka)\r\n\tif (memtag_use <= 0)\r\n\t\treturn;\r\n\tmemtag_use--;\r\n\r\n\tfor (i = 0 ; i < MEMTAG_MAX ; i++) {\r\n\t\tfree(memtags[i].name);\r\n\t\tfree(memtags[i].desc);\r\n\t\tfree(memtags[i].data);\r\n\t\tmemtags[i].len = 0;\r\n\t}\r\n\tmemtag_count = 0;\r\n}\r\n\r\nvoid save_memdump(wchar_t *filename)\r\n{\r\n\tFILE *fp;\r\n\tint i;\r\n\ttime_t t;\r\n\tstruct tm *tm;\r\n\twchar_t *dumpfile = NULL;\r\n\r\n\tdumpfile = get_log_dir_relative_nameW(filename);\r\n\t_wfopen_s(&fp, dumpfile, L\"w\");\r\n\tfree(dumpfile);\r\n\tif (fp == NULL)\r\n\t\treturn;\r\n\r\n\tt = time(NULL);\r\n\ttm = localtime(&t);\r\n\r\n\tfprintf(fp, \"<<< Tera Term SSH2 log dump >>>\\n\");\r\n\tfprintf(fp, \"saved time: %04d/%02d/%02d %02d:%02d:%02d\\n\",\r\n\t        tm->tm_year + 1900,\r\n\t        tm->tm_mon + 1,\r\n\t        tm->tm_mday,\r\n\t        tm->tm_hour,\r\n\t        tm->tm_min,\r\n\t        tm->tm_sec);\r\n\tfprintf(fp, \"\\n\");\r\n\r\n\tfor (i = 0 ; i < memtag_count ; i++) {\r\n\t\tfprintf(fp, \"============================================\\n\");\r\n\t\tfprintf(fp, \"name: %s\\n\", memtags[i].name);\r\n\t\tfprintf(fp, \"--------------------------------------------\\n\");\r\n\t\tfprintf(fp, \"description: %s\\n\", memtags[i].desc);\r\n\t\tfprintf(fp, \"--------------------------------------------\\n\");\r\n\t\tfprintf(fp, \"time: %s\", ctime(&memtags[i].time));\r\n\t\tfprintf(fp, \"============================================\\n\");\r\n\t\tdump_memdump(fp, memtags[i].data, memtags[i].len);\r\n\t\tfprintf(fp, \"\\n\\n\\n\");\r\n\t}\r\n\r\n\tfprintf(fp, \"[EOF]\\n\");\r\n\r\n\tfclose(fp);\r\n}\r\n\r\nvoid push_memdump(char *name, char *desc, char *data, int len)\r\n{\r\n\tmemtag_t *ptr;\r\n\tchar *dp;\r\n\r\n\tdp = malloc(len);\r\n\tif (dp == NULL)\r\n\t\treturn;\r\n\tmemcpy(dp, data, len);\r\n\r\n\tif (memtag_count >= MEMTAG_MAX)\r\n\t\treturn;\r\n\r\n\tptr = &memtags[memtag_count];\r\n\tmemtag_count++;\r\n\tptr->name = _strdup(name);\r\n\tptr->desc = _strdup(desc);\r\n\tptr->time = time(NULL);\r\n\tptr->data = dp;\r\n\tptr->len = len;\r\n}\r\n\r\nvoid push_bignum_memdump(char *name, char *desc, BIGNUM *bignum)\r\n{\r\n\tint len;\r\n\tchar *buf;\r\n\r\n\tlen = BN_num_bytes(bignum);\r\n\tbuf = malloc(len); // allocate\r\n\tif (buf == NULL)\r\n\t\treturn;\r\n\tBN_bn2bin(bignum, buf);\r\n\tpush_memdump(name, desc, buf, len); // at push_bignum_memdump()\r\n\tfree(buf); // free\r\n}\r\n\r\nvoid log_kex_key(PTInstVar pvar, const BIGNUM *secret)\r\n{\r\n#ifdef _DEBUG\t// KEX logging\r\n\tint fd, i;\r\n\tunsigned char buff[4], *cookie;\r\n\tchar *hexstr;\r\n\twchar_t *fname;\r\n\r\n\tif (pvar->settings.KexKeyLogging && pvar->settings.KexKeyLogFile[0] != 0) {\r\n\t\thexstr = BN_bn2hex(secret);\r\n\t\tif (hexstr == NULL) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfname = get_log_dir_relative_nameW(pvar->settings.KexKeyLogFile);\r\n\t\tif (fname == NULL) {\r\n\t\t\tOPENSSL_free(hexstr);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfd = _wopen(fname,\r\n\t\t\t_O_RDWR | _O_APPEND | _O_CREAT | _O_TEXT,\r\n\t\t\t_S_IREAD | _S_IWRITE);\r\n\t\tif (fd >= 0) {\r\n\t\t\tcookie = pvar->crypt_state.client_cookie;\r\n\t\t\tfor (i=0; i<16; i++) {\r\n\t\t\t\t_snprintf_s(buff, sizeof(buff), _TRUNCATE, \"%02x\", cookie[i]);\r\n\t\t\t\t_write(fd, buff, 2);\r\n\t\t\t}\r\n\t\t\t_write(fd, \" \", 1);\r\n\t\t\t_write(fd, hexstr, strlen(hexstr));\r\n\t\t\t_write(fd, \"\\n\", 1);\r\n\t\t\t_close(fd);\r\n\t\t}\r\n\t\tfree(fname);\r\n\t\tOPENSSL_free(hexstr);\r\n\t}\r\n#endif\r\n}\r\n\r\nstatic unsigned int get_predecryption_amount(PTInstVar pvar)\r\n{\r\n\tstatic int small_block_decryption_sizes[] = { 5, 5, 6, 6, 8 };\r\n\r\n\tif (SSHv1(pvar)) {\r\n\t\treturn 0;\r\n\t} else {\r\n\t\tunsigned int block_size = CRYPT_get_decryption_block_size(pvar);\r\n\r\n\t\tif (block_size < 5) {\r\n\t\t\treturn small_block_decryption_sizes[block_size];\r\n\t\t} else {\r\n\t\t\treturn block_size;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/* Get up to 'limit' bytes into the payload buffer.\r\n   'limit' is counted from the start of the payload data.\r\n   Returns the amount of data in the payload buffer, or\r\n   -1 if there is an error.\r\n   We can return more than limit in some cases. */\r\nstatic int buffer_packet_data(PTInstVar pvar, int limit)\r\n{\r\n\tif (pvar->ssh_state.payloadlen >= 0) {\r\n\t\treturn pvar->ssh_state.payloadlen;\r\n\t} else {\r\n\t\tint cur_decompressed_bytes =\r\n\t\t\tpvar->ssh_state.decompress_stream.next_out - pvar->ssh_state.postdecompress_inbuf;\r\n\r\n\t\twhile (limit > cur_decompressed_bytes) {\r\n\t\t\tint result;\r\n\r\n\t\t\tpvar->ssh_state.payload = pvar->ssh_state.postdecompress_inbuf + 1;\r\n\t\t\tif (pvar->ssh_state.postdecompress_inbuflen == cur_decompressed_bytes) {\r\n\t\t\t\tbuf_ensure_size(&pvar->ssh_state.postdecompress_inbuf,\r\n\t\t\t\t                &pvar->ssh_state.postdecompress_inbuflen,\r\n\t\t\t\t                min(limit, cur_decompressed_bytes * 2));\r\n\t\t\t}\r\n\r\n\t\t\tpvar->ssh_state.decompress_stream.next_out =\r\n\t\t\t\tpvar->ssh_state.postdecompress_inbuf + cur_decompressed_bytes;\r\n\t\t\tpvar->ssh_state.decompress_stream.avail_out =\r\n\t\t\t\tmin(limit, pvar->ssh_state.postdecompress_inbuflen) - cur_decompressed_bytes;\r\n\r\n\t\t\tresult = inflate(&pvar->ssh_state.decompress_stream, Z_SYNC_FLUSH);\r\n\t\t\tcur_decompressed_bytes =\r\n\t\t\t\tpvar->ssh_state.decompress_stream.next_out - pvar->ssh_state.postdecompress_inbuf;\r\n\r\n\t\t\tswitch (result) {\r\n\t\t\tcase Z_OK:\r\n\t\t\t\tbreak;\r\n\t\t\tcase Z_BUF_ERROR:\r\n\t\t\t\tpvar->ssh_state.payloadlen = cur_decompressed_bytes;\r\n\t\t\t\treturn cur_decompressed_bytes;\r\n\t\t\tdefault:\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_INVALID_COMPDATA_ERROR\", pvar,\r\n\t\t\t\t                  \"Invalid compressed data in received packet\");\r\n\t\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\t\treturn -1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn cur_decompressed_bytes;\r\n\t}\r\n}\r\n\r\n/* For use by the protocol processing code.\r\n   Gets N bytes of uncompressed payload. Returns FALSE if data not available\r\n   and a fatal error has been signaled.\r\n   The data is available in the payload buffer. This buffer address\r\n   can change during a call to grab_payload, so take care!\r\n   The payload pointer is set to point to the first byte of the actual data\r\n   (after the packet type byte).\r\n*/\r\nstatic BOOL grab_payload(PTInstVar pvar, int num_bytes)\r\n{\r\n\t/* Accept maximum of 4MB of payload data */\r\n\tint in_buffer = buffer_packet_data(pvar, PACKET_MAX_SIZE);\r\n\r\n\tif (in_buffer < 0) {\r\n\t\treturn FALSE;\r\n\t} else {\r\n\t\tpvar->ssh_state.payload_grabbed += num_bytes;\r\n\t\tif (pvar->ssh_state.payload_grabbed > in_buffer) {\r\n\t\t\tchar buf[128];\r\n\t\t\tUTIL_get_lang_msg(\"MSG_SSH_TRUNCATED_PKT_ERROR\", pvar,\r\n\t\t\t                  \"Received truncated packet (%ld > %d) @ grab_payload()\");\r\n\t\t\t_snprintf_s(buf, sizeof(buf), _TRUNCATE, pvar->UIMsg,\r\n\t\t\t            pvar->ssh_state.payload_grabbed, in_buffer);\r\n\t\t\tnotify_fatal_error(pvar, buf, TRUE);\r\n\t\t\treturn FALSE;\r\n\t\t} else {\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstatic BOOL grab_payload_limited(PTInstVar pvar, int num_bytes)\r\n{\r\n\tint in_buffer;\r\n\r\n\tpvar->ssh_state.payload_grabbed += num_bytes;\r\n\tin_buffer = buffer_packet_data(pvar, pvar->ssh_state.payload_grabbed);\r\n\r\n\tif (in_buffer < 0) {\r\n\t\treturn FALSE;\r\n\t} else {\r\n\t\tif (pvar->ssh_state.payload_grabbed > in_buffer) {\r\n\t\t\tchar buf[128];\r\n\t\t\tUTIL_get_lang_msg(\"MSG_SSH_TRUNCATED_PKT_LIM_ERROR\", pvar,\r\n\t\t\t                  \"Received truncated packet (%ld > %d) @ grab_payload_limited()\");\r\n\t\t\t_snprintf_s(buf, sizeof(buf), _TRUNCATE, pvar->UIMsg,\r\n\t\t\t            pvar->ssh_state.payload_grabbed, in_buffer);\r\n\t\t\tnotify_fatal_error(pvar, buf, TRUE);\r\n\t\t\treturn FALSE;\r\n\t\t} else {\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstatic PayloadStat get_byte_from_payload(PTInstVar pvar, unsigned char *val)\r\n{\r\n\tunsigned char *data;\r\n\r\n\tdata = remained_payload(pvar);\r\n\tif (!grab_payload(pvar, 1)) {\r\n\t\treturn GetPayloadError;\r\n\t}\r\n\r\n\t*val = *data;\r\n\treturn GetPayloadOK;\r\n}\r\n#define get_boolean_from_payload(pvar, val) get_byte_from_payload(pvar, val)\r\n\r\nstatic PayloadStat get_bytearray_from_payload(PTInstVar pvar, unsigned char *buff, unsigned int len)\r\n{\r\n\tunsigned char *data;\r\n\r\n\tdata = remained_payload(pvar);\r\n\tif (!grab_payload(pvar, len)) {\r\n\t\treturn GetPayloadError;\r\n\t}\r\n\r\n\tmemcpy_s(buff, len, data, len);\r\n\treturn GetPayloadOK;\r\n}\r\n\r\nstatic PayloadStat get_uint32_from_payload(PTInstVar pvar, unsigned int *val)\r\n{\r\n\tunsigned char *data;\r\n\r\n\tdata = remained_payload(pvar);\r\n\tif (!grab_payload(pvar, 4)) {\r\n\t\treturn  GetPayloadError;\r\n\t}\r\n\r\n\t*val = get_uint32(data);\r\n\treturn GetPayloadOK;\r\n}\r\n\r\nstatic PayloadStat get_string_from_payload(\r\n\tPTInstVar pvar, unsigned char *buff, unsigned int bufflen, unsigned int *len, BOOL null_terminate)\r\n{\r\n\tunsigned int size;\r\n\tunsigned char *data;\r\n\r\n\tif (!get_uint32_from_payload(pvar, &size)) {\r\n\t\treturn GetPayloadError;\r\n\t}\r\n\r\n\tdata = remained_payload(pvar);\r\n\tif (!grab_payload(pvar, size)) {\r\n\t\treturn GetPayloadError;\r\n\t}\r\n\r\n\t*len = size;\r\n\r\n\tif (size < bufflen) {\r\n\t\tmemcpy_s(buff, bufflen, data, size);\r\n\t\tif (null_terminate) {\r\n\t\t\tbuff[size] = 0;\r\n\t\t}\r\n\t\treturn GetPayloadOK;\r\n\t}\r\n\telse if (size == bufflen) {\r\n\t\tmemcpy_s(buff, bufflen, data, bufflen);\r\n\t\tif (null_terminate) {\r\n\t\t\tbuff[bufflen-1] = 0;\r\n\t\t\treturn GetPayloadTruncate;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn GetPayloadOK;\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\tmemcpy_s(buff, bufflen, data, bufflen);\r\n\t\tif (null_terminate) {\r\n\t\t\tbuff[bufflen-1] = 0;\r\n\t\t}\r\n\t\treturn GetPayloadTruncate;\r\n\t}\r\n}\r\n#define get_namelist_from_payload(pvar, buff, bufflen, size) get_string_from_payload(pvar, buff, bufflen, size, TRUE)\r\n\r\nstatic PayloadStat get_mpint_from_payload(PTInstVar pvar, BIGNUM *bn)\r\n{\r\n\tunsigned int len;\r\n\tunsigned char *data;\r\n\r\n\tif (!get_uint32_from_payload(pvar, &len)) {\r\n\t\treturn GetPayloadError;\r\n\t}\r\n\r\n\tdata = remained_payload(pvar);\r\n\tif (!grab_payload(pvar, len)) {\r\n\t\treturn GetPayloadError;\r\n\t}\r\n\r\n\tBN_bin2bn(data, len, bn);\r\n\r\n\treturn GetPayloadOK;\r\n}\r\n\r\n#define do_crc(buf, len) (~(uint32)crc32(0xFFFFFFFF, (buf), (len)))\r\n\r\n/*\r\n * Decrypt the payload, checksum it, eat the padding, get the packet type and return it.\r\n * 'data' points to the start of the packet --- its length field.\r\n * 'len' is the length of the * payload + padding (+ length of CRC for SSHv1).\r\n * 'padding' is the length of the padding alone.\r\n */\r\nstatic int prep_packet_ssh1(PTInstVar pvar, char *data, unsigned int len, unsigned int padding)\r\n{\r\n\tpvar->ssh_state.payload = data + 4;\r\n\tpvar->ssh_state.payloadlen = len;\r\n\r\n\tif (CRYPT_detect_attack(pvar, pvar->ssh_state.payload, len)) {\r\n\t\tUTIL_get_lang_msg(\"MSG_SSH_COREINS_ERROR\", pvar, \"'CORE insertion attack' detected.  Aborting connection.\");\r\n\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t}\r\n\r\n\tCRYPT_decrypt(pvar, pvar->ssh_state.payload, len);\r\n\t/* PKT guarantees that the data is always 4-byte aligned */\r\n\tif (do_crc(pvar->ssh_state.payload, len - 4) != get_uint32_MSBfirst(pvar->ssh_state.payload + len - 4)) {\r\n\t\tUTIL_get_lang_msg(\"MSG_SSH_CORRUPTDATA_ERROR\", pvar, \"Detected corrupted data; connection terminating.\");\r\n\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\treturn SSH_MSG_NONE;\r\n\t}\r\n\r\n\tpvar->ssh_state.payload += padding;\r\n\tpvar->ssh_state.payloadlen -= padding + 4;\r\n\r\n\tpvar->ssh_state.payload_grabbed = 0;\r\n\r\n\tif (pvar->ssh_state.decompressing) {\r\n\t\tif (pvar->ssh_state.decompress_stream.avail_in != 0) {\r\n\t\t\tUTIL_get_lang_msg(\"MSG_SSH_DECOMPRESS_ERROR\", pvar,\r\n\t\t\t                  \"Internal error: a packet was not fully decompressed.\\n\"\r\n\t\t\t                  \"This is a bug, please report it.\");\r\n\t\t\tnotify_nonfatal_error(pvar, pvar->UIMsg);\r\n\t\t}\r\n\r\n\t\tpvar->ssh_state.decompress_stream.next_in = pvar->ssh_state.payload;\r\n\t\tpvar->ssh_state.decompress_stream.avail_in = pvar->ssh_state.payloadlen;\r\n\t\tpvar->ssh_state.decompress_stream.next_out = pvar->ssh_state.postdecompress_inbuf;\r\n\t\tpvar->ssh_state.payloadlen = -1;\r\n\t} else {\r\n\t\tpvar->ssh_state.payload++;\r\n\t}\r\n\r\n\tif (!grab_payload_limited(pvar, 1)) {\r\n\t\treturn SSH_MSG_NONE;\r\n\t}\r\n\r\n\tpvar->ssh_state.receiver_sequence_number++;\r\n\r\n\treturn pvar->ssh_state.payload[-1];\r\n}\r\n\r\n/*\r\n * \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\u0308\u05c2\u0308\u0209\ufffd\ufffd\u030f\ufffd\ufffd\ufffd\ufffd\ufffd\ufffds\ufffd\ufffd\ufffdB(SSHv2\ufffdp)\r\n * \ufffdE\ufffdf\ufffd[\ufffd^\ufffd\ufffd\ufffd\ufffd\r\n * \ufffdEMAC \ufffd\u030c\ufffd\ufffd\ufffd\r\n * \ufffdEpadding \ufffd\ufffd\ufffd\ufffd\u83dc\ufffd\ufffd\r\n * \ufffdE\ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd^\ufffdC\ufffdv\ufffd\ud813\uded5\u0282\ufffd\ufffd\u0115\u0502\ufffd\r\n *\r\n * \ufffd\ufffd\ufffd\ufffd:\r\n *   data - ssh \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\u0310\u64ea\ufffd\ufffd\ufffdw\ufffd\ufffd\ufffd|\ufffdC\ufffd\ufffd\ufffd^\r\n *   len - \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd (\ufffd\u64ea\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffd\u0308\ufffd(4\ufffdo\ufffdC\ufffdg)\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdl)\r\n *   aadlen - \ufffd\u00cd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffdF\ufffd\u0602\u0311\u038f\u06c2\u0182\u0202\ufffd\ufffd\u0102\ufffd\ufffd\ufffdf\ufffd[\ufffd^\ufffd\u0312\ufffd\ufffd\ufffd\r\n *            chacha20-poly1305 \ufffd\u0142\u0348\u00cd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0312\ufffd\ufffd\ufffd\r\n *   authlen - \ufffdF\ufffd\u0603f\ufffd[\ufffd^(AEAD tag)\ufffd\ufffd\r\n */\r\n\r\nstatic int prep_packet_ssh2(PTInstVar pvar, char *data, unsigned int len, unsigned int aadlen, unsigned int authlen)\r\n{\r\n\tunsigned int padding;\r\n\r\n\tif (authlen > 0) {\r\n\t\tif (!CRYPT_decrypt_aead(pvar, data, len, aadlen, authlen)) {\r\n\t\t\tUTIL_get_lang_msg(\"MSG_SSH_CORRUPTDATA_ERROR\", pvar, \"Detected corrupted data; connection terminating.\");\r\n\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\treturn SSH_MSG_NONE;\r\n\t\t}\r\n\t}\r\n\telse if (aadlen > 0) {\r\n\t\t// EtM \ufffd\u030f\ua347\ufffd\u0350\ufffd\ufffd MAC \ufffd\u030c\ufffd\ufffd\u0602\ufffd\ufffds\ufffd\ufffd\r\n\t\tif (!CRYPT_verify_receiver_MAC(pvar, pvar->ssh_state.receiver_sequence_number, data, len + 4, data + len + 4)) {\r\n\t\t\tUTIL_get_lang_msg(\"MSG_SSH_CORRUPTDATA_ERROR\", pvar, \"Detected corrupted data; connection terminating.\");\r\n\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\treturn SSH_MSG_NONE;\r\n\t\t}\r\n\r\n\t\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd(\ufffd\u64ea4\ufffdo\ufffdC\ufffdg)\ufffd\u0348\u00cd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0202\ufffd\ufffd\u0302\u0141A\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdX\ufffdL\ufffdb\ufffdv\ufffd\ufffd\ufffd\u0115\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\tCRYPT_decrypt(pvar, data + 4, len);\r\n\t}\r\n\telse {\r\n\t\t// E&M \ufffd\u0142\u0350\u64ea\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdO\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffdB\r\n\t\t// \ufffd\ufffd\ufffdO\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ua0bd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u64fe\ufffd\ufffd\ufffd\ufffdB\r\n\t\tunsigned int already_decrypted = get_predecryption_amount(pvar);\r\n\r\n\t\t// \ufffd\ufffd\ufffdO\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ua0bd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdX\ufffdL\ufffdb\ufffdv\ufffd\ufffd\ufffd\u0101A\ufffdc\ufffd\ufffd\u0315\ufffd\ufffd\ufffd\ufffd\ud815\udf0d\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\tCRYPT_decrypt(pvar, data + already_decrypted, (4 + len) - already_decrypted);\r\n\r\n\t\t// E&M \ufffd\u0142\u0355\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd MAC \ufffd\u030c\ufffd\ufffd\u0602\ufffd\ufffds\ufffd\ufffd\ufffdB\r\n\t\tif (!CRYPT_verify_receiver_MAC(pvar, pvar->ssh_state.receiver_sequence_number, data, len + 4, data + len + 4)) {\r\n\t\t\tUTIL_get_lang_msg(\"MSG_SSH_CORRUPTDATA_ERROR\", pvar, \"Detected corrupted data; connection terminating.\");\r\n\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\treturn SSH_MSG_NONE;\r\n\t\t}\r\n\t}\r\n\r\n\t// \ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd\ufffd\ufffd\u030e\u64fe\r\n\tpadding = (unsigned int) data[4];\r\n\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd(4\ufffdo\ufffdC\ufffdg) \ufffd\ufffd\ufffd\ufffd\ufffd\u0183p\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd\ufffd(1\ufffdo\ufffdC\ufffdg)\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdX\ufffdL\ufffdb\ufffdv\ufffd\ufffd\ufffd\ufffd SSH \ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\u0310\u64ea\r\n\tpvar->ssh_state.payload = data + 4 + 1;\r\n\r\n\t// \ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd(1\ufffdo\ufffdC\ufffdg)\ufffd\u0183p\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u06c2\u0303y\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\ufffd\r\n\tpvar->ssh_state.payloadlen = len - 1 - padding;\r\n\r\n\tpvar->ssh_state.payload_grabbed = 0;\r\n\r\n\t// data compression\r\n\tif (pvar->ssh2_keys[MODE_IN].comp.enabled &&\r\n\t   (pvar->stoc_compression == COMP_ZLIB ||\r\n\t    pvar->stoc_compression == COMP_DELAYED && pvar->userauth_success)) {\r\n\r\n\t\tif (pvar->decomp_buffer == NULL) {\r\n\t\t\tpvar->decomp_buffer = buffer_init();\r\n\t\t\tif (pvar->decomp_buffer == NULL)\r\n\t\t\t\treturn SSH_MSG_NONE;\r\n\t\t}\r\n\t\t// \ufffd\ufffdx\ufffdm\ufffd\u06c2\ufffd\ufffd\ufffd\ufffdo\ufffdb\ufffdt\ufffd@\ufffd\u034eg\ufffd\ufffd\ufffd\ud8cb\uddc2\u0302\u014f\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdY\ufffd\ua0b8\ufffd\u0241B\r\n\t\tbuffer_clear(pvar->decomp_buffer);\r\n\r\n\t\t// packet size\ufffd\ufffdpadding\ufffd\ufffd\ufffd\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0742\ufffdW\ufffdJ\ufffd\ufffd\ufffd\ufffdB\r\n\t\tbuffer_decompress(&pvar->ssh_state.decompress_stream,\r\n\t\t                  pvar->ssh_state.payload,\r\n\t\t                  pvar->ssh_state.payloadlen,\r\n\t\t                  pvar->decomp_buffer);\r\n\r\n\t\t// \ufffd|\ufffdC\ufffd\ufffd\ufffd^\ufffd\u030dX\ufffdV\ufffdB\r\n\t\tpvar->ssh_state.payload = buffer_ptr(pvar->decomp_buffer);\r\n\t\tpvar->ssh_state.payload++;\r\n\t\tpvar->ssh_state.payloadlen = buffer_len(pvar->decomp_buffer);\r\n\t} else {\r\n\t\tpvar->ssh_state.payload++;\r\n\t}\r\n\r\n\tif (!grab_payload_limited(pvar, 1)) {\r\n\t\treturn SSH_MSG_NONE;\r\n\t}\r\n\r\n\tpvar->ssh_state.receiver_sequence_number++;\r\n\r\n\treturn pvar->ssh_state.payload[-1];\r\n}\r\n\r\n/* Create a packet to be sent. The SSH protocol packet type is in 'type';\r\n   'len' contains the length of the packet payload, in bytes (this\r\n   does not include the space for any of the packet headers or padding,\r\n   or for the packet type byte).\r\n   Returns a pointer to the payload data area, a region of length 'len',\r\n   to be filled by the caller. */\r\nunsigned char *begin_send_packet(PTInstVar pvar, int type, int len)\r\n{\r\n\tunsigned char *buf;\r\n\r\n\tpvar->ssh_state.outgoing_packet_len = len + 1;\r\n\r\n\tif (pvar->ssh_state.compressing) {\r\n\t\tbuf_ensure_size(&pvar->ssh_state.precompress_outbuf,\r\n\t\t                &pvar->ssh_state.precompress_outbuflen, 1 + len);\r\n\t\tbuf = pvar->ssh_state.precompress_outbuf;\r\n\t} else {\r\n\t\t/* For SSHv2,\r\n\t\t   Encrypted_length is 4(packetlength) + 1(paddinglength) + 1(packettype)\r\n\t\t   + len(payload) + 4(minpadding), rounded up to nearest block_size\r\n\t\t   We only need a reasonable upper bound for the buffer size */\r\n\t\tbuf_ensure_size(&pvar->ssh_state.outbuf,\r\n\t\t                &pvar->ssh_state.outbuflen,\r\n\t\t                (int)(len + 30 + CRYPT_get_sender_MAC_size(pvar) +\r\n\t\t                CRYPT_get_encryption_block_size(pvar)));\r\n\t\tbuf = pvar->ssh_state.outbuf + 12;\r\n\t}\r\n\r\n\tbuf[0] = (unsigned char) type;\r\n\treturn buf + 1;\r\n}\r\n\r\n\r\n// \ufffd\ufffd\ufffdM\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffdC\ufffd\u0590\ufffd\ufffd\u0312\u01c9\ufffd\r\n//\r\n// WinSock\ufffd\ufffd send() \ufffd\u0343o\ufffdb\ufffdt\ufffd@\ufffdT\ufffdC\ufffdY(len)\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffdl\ufffd\ud803\udccf\ud39e\ufffd\u0255\u0502\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\r\n// \ufffd\ufffd\ufffd\u0182\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\ufffd\ufffd\u030f\ua347\ufffd\u0343G\ufffd\ufffd\ufffd[\ufffd\u0182\ufffd\ufffd\u0202\ufffd\ufffdB\r\n// \ufffd\ufffd\ufffd\ufffd\u0242\ufffd\ufffdATCP\ufffdR\ufffdl\ufffdN\ufffdV\ufffd\ufffd\ufffd\ufffd\ufffd\u0612f\ufffd\u030c\ub31f\ufffdo\ufffd\ufffdh\ufffd\ufffd\ufffdB\r\n// (2006.12.9 yutaka)\r\nstatic int retry_send_packet(PTInstVar pvar, char *data, int len)\r\n{\r\n\tint n;\r\n\tint err;\r\n\r\n\twhile (len > 0) {\r\n\t\tn = (pvar->Psend)(pvar->socket, data, len, 0);\r\n\r\n\t\tif (n < 0) {\r\n\t\t\terr = WSAGetLastError();\r\n\t\t\tif (err < WSABASEERR || err == WSAEWOULDBLOCK) {\r\n\t\t\t\t// send()\ufffd\u0315\u0512l\ufffd\ufffd0\ufffd\ufffd\ufffd\ufffd\ufffd\u0141A\ufffd\ufffd\ufffd\u0083G\ufffd\ufffd\ufffd[\ufffd\u050d\ufffd\ufffd\ufffd 10000 \ufffd\ufffd\ufffd\ufffd\ufffd\u030f\ua347\ufffd\u0341A\r\n\t\t\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u018c\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t\t\t\t// PuTTY 0.58\ufffd\u030e\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdQ\ufffdl\ufffdB\r\n\t\t\t\t// (2007.2.4 yutak)\r\n\t\t\t\treturn 0; // success\r\n\t\t\t}\r\n\t\t\treturn 1; // error\r\n\t\t}\r\n\r\n\t\tlen -= n;\r\n\t\tdata += n;\r\n\t}\r\n\r\n\treturn 0; // success\r\n}\r\n\r\nstatic BOOL send_packet_blocking(PTInstVar pvar, char *data, int len)\r\n{\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffdM\ufffd\ufffd\u0243o\ufffdb\ufffdt\ufffd@\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffd\u0702\ud0b7\ufffd\ufffd\ufffd\u07c1A\ufffdu\ufffd\ufffd\ufffdb\ufffdL\ufffd\ufffd\ufffdO\ufffd\u0151\ufffd\ufffdM\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0702\ufffd\ufffdK\ufffdv\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t// \ufffdm\ufffd\ufffd\ufffdu\ufffd\ufffd\ufffdb\ufffdL\ufffd\ufffd\ufffdO\ufffd\u0151\ufffd\ufffdM\ufffd\ufffd\ufffd\ufffdWSAEWOULDBLOCK\ufffd\ufffd\ufffd\u0502\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffd\ua347\ufffdA\ufffd\ufffd\ufffd\u0303o\ufffdb\ufffdt\ufffd@\ufffd\u0351\ufffd\ufffdM\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\t// \ufffd\u0702\u0155\u06ce\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\u0102\u0342\u0202\ufffd\u0202\ufffd\ufffdB(2007.10.30 yutaka)\r\n\tu_long do_block = 0;\r\n\tint code = 0;\r\n\tchar *kind = NULL, buf[256];\r\n\r\n\tif ((pvar->PWSAAsyncSelect) (pvar->socket, pvar->NotificationWindow, 0, 0) == SOCKET_ERROR) {\r\n\t\tcode = WSAGetLastError();\r\n\t\tkind = \"WSAAsyncSelect1\";\r\n\t\tgoto error;\r\n\t}\r\n\tif (ioctlsocket(pvar->socket, FIONBIO, &do_block) == SOCKET_ERROR) {\r\n\t\tcode = WSAGetLastError();\r\n\t\tkind = \"ioctlsocket\";\r\n\t\tgoto error;\r\n\t}\r\n\tif (retry_send_packet(pvar, data, len) != 0) {\r\n\t\tcode = WSAGetLastError();\r\n\t\tkind = \"retry_send_packet\";\r\n\t\tgoto error;\r\n\t}\r\n\tif ((pvar->PWSAAsyncSelect) (pvar->socket, pvar->NotificationWindow,\r\n\t                             pvar->notification_msg,\r\n\t                             pvar->notification_events) == SOCKET_ERROR) {\r\n\t\tcode = WSAGetLastError();\r\n\t\tkind = \"WSAAsyncSelect2\";\r\n\t\tgoto error;\r\n\t}\r\n\treturn TRUE;\r\n\r\nerror:\r\n\tUTIL_get_lang_msg(\"MSG_SSH_SEND_PKT_ERROR\", pvar,\r\n\t                  \"A communications error occurred while sending an SSH packet.\\n\"\r\n\t                  \"The connection will close. (%s:%d)\");\r\n\t_snprintf_s(buf, sizeof(buf), _TRUNCATE, pvar->UIMsg,\r\n\t            kind, code);\r\n\tnotify_fatal_error(pvar, buf, TRUE);\r\n\treturn FALSE;\r\n}\r\n\r\n/* if skip_compress is true, then the data has already been compressed\r\n   into outbuf + 12 */\r\nvoid finish_send_packet_special(PTInstVar pvar, int skip_compress)\r\n{\r\n\tunsigned int len = pvar->ssh_state.outgoing_packet_len;\r\n\tunsigned char *data;\r\n\tunsigned int data_length;\r\n\tbuffer_t *msg = NULL; // for SSH2 packet compression\r\n\r\n\tif (pvar->ssh_state.compressing) {\r\n\t\tif (!skip_compress) {\r\n\t\t\tbuf_ensure_size(&pvar->ssh_state.outbuf,\r\n\t\t\t                &pvar->ssh_state.outbuflen,\r\n\t\t\t                (int)(len + (len >> 6) + 50 + CRYPT_get_sender_MAC_size(pvar)));\r\n\t\t\tpvar->ssh_state.compress_stream.next_in = pvar->ssh_state.precompress_outbuf;\r\n\t\t\tpvar->ssh_state.compress_stream.avail_in = len;\r\n\t\t\tpvar->ssh_state.compress_stream.next_out = pvar->ssh_state.outbuf + 12;\r\n\t\t\tpvar->ssh_state.compress_stream.avail_out = pvar->ssh_state.outbuflen - 12;\r\n\r\n\t\t\tif (deflate(&pvar->ssh_state.compress_stream, Z_SYNC_FLUSH) != Z_OK) {\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_COMP_ERROR\", pvar,\r\n\t\t\t\t                  \"An error occurred while compressing packet data.\\n\"\r\n\t\t\t\t                  \"The connection will close.\");\r\n\t\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlen = pvar->ssh_state.outbuflen - 12 - pvar->ssh_state.compress_stream.avail_out;\r\n\t}\r\n\r\n\tif (SSHv1(pvar)) {\r\n\t\tunsigned int padding = 8 - ((len + 4) % 8);\r\n\r\n\t\tdata = pvar->ssh_state.outbuf + 8 - padding;\r\n\t\tdata_length = padding + len + 8;\r\n\r\n\t\tset_uint32(data, len + 4);\r\n\t\tif (CRYPT_get_receiver_cipher(pvar) != SSH_CIPHER_NONE) {\r\n\t\t\tCRYPT_set_random_data(pvar, data + 4, padding);\r\n\t\t} else {\r\n\t\t\tmemset(data + 4, 0, padding);\r\n\t\t}\r\n\t\tset_uint32(data + data_length - 4, do_crc(data + 4, data_length - 8));\r\n\t\tCRYPT_encrypt(pvar, data + 4, data_length - 4);\r\n\t} else { //for SSH2(yutaka)\r\n\t\tunsigned int block_size = CRYPT_get_encryption_block_size(pvar);\r\n\t\tunsigned int packet_length;\r\n\t\tunsigned int encryption_size;\r\n\t\tunsigned int padding_size;\r\n\t\tBOOL ret;\r\n\t\tstruct Mac *mac = &pvar->ssh2_keys[MODE_OUT].mac;\r\n\t\tstruct Enc *enc = &pvar->ssh2_keys[MODE_OUT].enc;\r\n\t\tunsigned int aadlen = 0, maclen = 0, authlen = 0;\r\n\r\n\t\t/*\r\n\t\t \ufffdf\ufffd[\ufffd^\ufffd\\\ufffd\ufffd\r\n\t\t pvar->ssh_state.outbuf:\r\n\t\t offset: 0 1 2 3 4 5 6 7 8 9 10 11 12 ...         EOD\r\n\t\t         <--ignore---> ^^^^^^^^    <---- payload --->\r\n\t\t                       packet length\r\n\r\n\t\t                                ^^padding_size\r\n\r\n\t\t                       <---------------------------->\r\n\t\t                          SSH2 sending data on TCP\r\n\r\n\t\t NOTE:\r\n\t\t   payload = type(1) + raw-data\r\n\t\t   len = ssh_state.outgoing_packet_len = payload size\r\n\t\t */\r\n\t\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffdk\ufffd\ufffd\ufffdL\ufffd\ufffd\ufffd\u030f\ua347\ufffdA\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffdk\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u7457\ufffdM\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffd\\\ufffdz\ufffd\ufffd\ufffd\ufffdB(2005.7.9 yutaka)\r\n\t\t// support of \"Compression delayed\" (2006.6.23 maya)\r\n\t\tif ((pvar->ctos_compression == COMP_ZLIB ||\r\n\t\t     pvar->ctos_compression == COMP_DELAYED && pvar->userauth_success) &&\r\n\t\t    pvar->ssh2_keys[MODE_OUT].comp.enabled) {\r\n\t\t\t// \ufffd\ufffd\ufffd\u0303o\ufffdb\ufffdt\ufffd@\ufffd\ufffd packet-length(4) + padding(1) + payload(any) \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\t\tmsg = buffer_init();\r\n\t\t\tif (msg == NULL) {\r\n\t\t\t\t// TODO: error check\r\n\t\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// \ufffd\ufffd\ufffdk\ufffd\u038f\u06c2\u0343w\ufffdb\ufffd_\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\u0302\u0741B\r\n\t\t\tbuffer_append(msg, \"\\0\\0\\0\\0\\0\", 5);  // 5 = packet-length(4) + padding(1)\r\n\t\t\tif (buffer_compress(&pvar->ssh_state.compress_stream, pvar->ssh_state.outbuf + 12, len, msg) == -1) {\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_COMP_ERROR\", pvar,\r\n\t\t\t\t                  \"An error occurred while compressing packet data.\\n\"\r\n\t\t\t\t                  \"The connection will close.\");\r\n\t\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tdata = buffer_ptr(msg);\r\n\t\t\tlen = buffer_len(msg) - 5;  // 'len' is overwritten.\r\n\r\n\t\t} else {\r\n\t\t\t// \ufffd\ufffd\ufffd\ufffd\ufffdk\r\n\t\t\tdata = pvar->ssh_state.outbuf + 7;\r\n\t\t}\r\n\r\n\t\t// \ufffd\ufffd\ufffdM\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\\\ufffdz(input parameter: data, len)\r\n\t\tif (block_size < 8) {\r\n\t\t\tblock_size = 8;\r\n\t\t}\r\n\r\n\t\tif (enc) {\r\n\t\t\tauthlen = enc->auth_len;\r\n\t\t}\r\n\r\n\t\tif (mac && mac->etm || authlen > 0) {\r\n\t\t\t// \ufffd\u00cd\ufffd\ufffd\ufffd\ufffd\u038f\u06c2\u0142\u0342\u0202\ufffd\ufffd\ufffd\ufffdAMAC \ufffd\u0311\u038f\u06c2\u0182\u0202\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0312\ufffd\ufffd\ufffd\r\n\t\t\t// \ufffd\u0702\ufffd\ufffd\ufffd chacha20-poly1305 \ufffd\u0148\u00cd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0312\ufffd\ufffd\ufffd\r\n\t\t\t// cf. PKT_recv \ufffd\ufffd\ufffd\u0303R\ufffd\ufffd\ufffd\ufffd\ufffdg\r\n\t\t\taadlen = 4;\r\n\t\t}\r\n\r\n\t\tpacket_length = 1 + len; // \ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd\ufffd\ufffd\u0303T\ufffdC\ufffdY + \ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\ufffd\r\n\t\tencryption_size = 4 + packet_length - aadlen; // \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffd\u0303T\ufffdC\ufffdY + packet_length - addlen\r\n\t\tpadding_size = block_size - (encryption_size % block_size);\r\n\t\tif (padding_size < 4)\r\n\t\t\tpadding_size += block_size;\r\n\t\tpacket_length += padding_size;\r\n\t\tencryption_size += padding_size;\r\n\t\tset_uint32(data, packet_length);\r\n\t\tdata[4] = (unsigned char) padding_size;\r\n\t\tif (msg) {\r\n\t\t\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffdk\ufffd\u030f\ua347\ufffdA\ufffdo\ufffdb\ufffdt\ufffd@\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB(2011.6.10 yutaka)\r\n\t\t\tbuffer_append_space(msg, padding_size + EVP_MAX_MD_SIZE);\r\n\t\t\t// realloc()\ufffd\ufffd\ufffd\ufffd\ufffd\u0181A\ufffd|\ufffdC\ufffd\ufffd\ufffd^\ufffd\ufffd\ufffd\u03c2\ufffd\ufffd\u0094\\\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\u0113x\ufffd\ufffd\u84bc\ufffd\ufffd\ufffdB\r\n\t\t\tdata = buffer_ptr(msg);\r\n\t\t}\r\n\r\n\t\tCRYPT_set_random_data(pvar, data + 5 + len, padding_size);\r\n\r\n\t\tif (authlen > 0) {\r\n\t\t\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\u00cd\ufffd\ufffd\ufffd\ufffd\ufffd MAC \ufffd\u030cv\ufffdZ\r\n\t\t\tCRYPT_encrypt_aead(pvar, data, encryption_size, aadlen, authlen);\r\n\t\t\tmaclen = authlen;\r\n\t\t}\r\n\t\telse if (aadlen) {\r\n\t\t\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\u00cd\ufffd\ufffd\ufffd\ufffdiaadlen\ufffd\ufffd\ufffd\ufffd\ub0be\ufffd\ufffd\ufffdj\r\n\t\t\tCRYPT_encrypt(pvar, data + aadlen, encryption_size);\r\n\r\n\t\t\t// EtM \ufffd\u0142\u0348\u00cd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd MAC \ufffd\ufffd\ufffdv\ufffdZ\ufffd\ufffd\ufffd\ufffd\r\n\t\t\tret = CRYPT_build_sender_MAC(pvar, pvar->ssh_state.sender_sequence_number,\r\n\t\t\t                             data, aadlen + encryption_size, data + aadlen + encryption_size);\r\n\t\t\tif (ret) {\r\n\t\t\t\tmaclen = CRYPT_get_sender_MAC_size(pvar);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// E&M \ufffd\u0142\u0348\u00cd\ufffd\ufffd\ufffd\ufffdO\ufffd\ufffd MAC \ufffd\ufffd\ufffdv\ufffdZ\ufffd\ufffd\ufffd\ufffd\r\n\t\t\tret = CRYPT_build_sender_MAC(pvar, pvar->ssh_state.sender_sequence_number,\r\n\t\t\t                             data, encryption_size, data + encryption_size);\r\n\t\t\tif (ret) {\r\n\t\t\t\tmaclen = CRYPT_get_sender_MAC_size(pvar);\r\n\t\t\t}\r\n\r\n\t\t\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\u00cd\ufffd\ufffd\ufffd\r\n\t\t\tCRYPT_encrypt(pvar, data, encryption_size);\r\n\t\t}\r\n\r\n\t\tdata_length = encryption_size + aadlen + maclen;\r\n\r\n\t\tlogprintf(150,\r\n\t\t          \"%s: built packet info: \"\r\n\t\t          \"aadlen:%d, enclen:%d, padlen:%d, datalen:%d, maclen:%d, \"\r\n\t\t          \"Encrypt Mode:%s, MAC mode:%s\",\r\n\t\t          __FUNCTION__,\r\n\t\t          aadlen, encryption_size, padding_size, data_length, maclen,\r\n\t\t          authlen ? \"AEAD\" : \"not AEAD\", aadlen ? \"EtM\" : \"E&M\");\r\n\t}\r\n\r\n\tsend_packet_blocking(pvar, data, data_length);\r\n\r\n\tbuffer_free(msg);\r\n\r\n\tpvar->ssh_state.sender_sequence_number++;\r\n\r\n\t// \ufffd\ufffd\ufffdM\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdL\ufffd^\r\n\tpvar->ssh_heartbeat_tick = time(NULL);\r\n}\r\n\r\nstatic void destroy_packet_buf(PTInstVar pvar)\r\n{\r\n\tmemset(pvar->ssh_state.outbuf, 0, pvar->ssh_state.outbuflen);\r\n\tif (pvar->ssh_state.compressing) {\r\n\t\tmemset(pvar->ssh_state.precompress_outbuf, 0,\r\n\t\t       pvar->ssh_state.precompress_outbuflen);\r\n\t}\r\n}\r\n\r\n/* The handlers are added to the queue for each message. When one of the\r\n   handlers fires, if it returns FALSE, then all handlers in the set are\r\n   removed from their queues. */\r\nstatic void enque_handlers(PTInstVar pvar, int num_msgs,\r\n                           const int *messages,\r\n                           const SSHPacketHandler *handlers)\r\n{\r\n\tSSHPacketHandlerItem *first_item;\r\n\tSSHPacketHandlerItem *last_item = NULL;\r\n\tint i;\r\n\r\n\tfor (i = 0; i < num_msgs; i++) {\r\n\t\tSSHPacketHandlerItem *item =\r\n\t\t\t(SSHPacketHandlerItem *)\r\n\t\t\tmalloc(sizeof(SSHPacketHandlerItem));\r\n\t\tSSHPacketHandlerItem *cur_item =\r\n\t\t\tpvar->ssh_state.packet_handlers[messages[i]];\r\n\r\n\t\titem->handler = handlers[i];\r\n\r\n\t\tif (cur_item == NULL) {\r\n\t\t\tpvar->ssh_state.packet_handlers[messages[i]] = item;\r\n\t\t\titem->next_for_message = item;\r\n\t\t\titem->last_for_message = item;\r\n\t\t\titem->active_for_message = messages[i];\r\n\t\t} else {\r\n\t\t\titem->next_for_message = cur_item;\r\n\t\t\titem->last_for_message = cur_item->last_for_message;\r\n\t\t\tcur_item->last_for_message->next_for_message = item;\r\n\t\t\tcur_item->last_for_message = item;\r\n\t\t\titem->active_for_message = -1;\r\n\t\t}\r\n\r\n\t\tif (last_item != NULL) {\r\n\t\t\tlast_item->next_in_set = item;\r\n\t\t} else {\r\n\t\t\tfirst_item = item;\r\n\t\t}\r\n\t\tlast_item = item;\r\n\t}\r\n\r\n\tif (last_item != NULL) {\r\n\t\tlast_item->next_in_set = first_item;\r\n\t}\r\n}\r\n\r\nstatic SSHPacketHandler get_handler(PTInstVar pvar, int message)\r\n{\r\n\tSSHPacketHandlerItem *cur_item =\r\n\t\tpvar->ssh_state.packet_handlers[message];\r\n\r\n\tif (cur_item == NULL) {\r\n\t\treturn NULL;\r\n\t} else {\r\n\t\treturn cur_item->handler;\r\n\t}\r\n}\r\n\r\n/* Called only by SSH_handle_packet */\r\nstatic void deque_handlers(PTInstVar pvar, int message)\r\n{\r\n\tSSHPacketHandlerItem *cur_item =\r\n\t\tpvar->ssh_state.packet_handlers[message];\r\n\tSSHPacketHandlerItem *first_item_in_set = cur_item;\r\n\r\n\tif (cur_item == NULL)\r\n\t\treturn;\r\n\r\n\tdo {\r\n\t\tSSHPacketHandlerItem *next_in_set = cur_item->next_in_set;\r\n\r\n\t\tif (cur_item->active_for_message >= 0) {\r\n\t\t\tSSHPacketHandlerItem *replacement =\r\n\t\t\t\tcur_item->next_for_message;\r\n\r\n\t\t\tif (replacement == cur_item) {\r\n\t\t\t\treplacement = NULL;\r\n\t\t\t} else {\r\n\t\t\t\treplacement->active_for_message =\r\n\t\t\t\t\tcur_item->active_for_message;\r\n\t\t\t}\r\n\t\t\tpvar->ssh_state.packet_handlers[cur_item->active_for_message] =\r\n\t\t\t\treplacement;\r\n\t\t}\r\n\t\tcur_item->next_for_message->last_for_message =\r\n\t\t\tcur_item->last_for_message;\r\n\t\tcur_item->last_for_message->next_for_message =\r\n\t\t\tcur_item->next_for_message;\r\n\r\n\t\tfree(cur_item);\r\n\t\tcur_item = next_in_set;\r\n\t} while (cur_item != first_item_in_set);\r\n}\r\n\r\nstatic void enque_handler(PTInstVar pvar, int message,\r\n                          SSHPacketHandler handler)\r\n{\r\n\tenque_handlers(pvar, 1, &message, &handler);\r\n}\r\n\r\nstatic void chop_newlines(char *buf)\r\n{\r\n\tint len = strlen(buf);\r\n\r\n\twhile (len > 0 && (buf[len - 1] == '\\n' || buf[len - 1] == '\\r')) {\r\n\t\tbuf[len - 1] = 0;\r\n\t\tlen--;\r\n\t}\r\n}\r\n\r\n/********************/\r\n/* Message handlers */\r\n/********************/\r\n\r\nstatic BOOL handle_forwarding_success(PTInstVar pvar)\r\n{\r\n\treturn FALSE;\r\n}\r\n\r\nstatic BOOL handle_forwarding_failure(PTInstVar pvar)\r\n{\r\n\treturn FALSE;\r\n}\r\n\r\nstatic void enque_forwarding_request_handlers(PTInstVar pvar)\r\n{\r\n\tstatic const int msgs[] = { SSH_SMSG_SUCCESS, SSH_SMSG_FAILURE };\r\n\tstatic const SSHPacketHandler handlers[]\r\n\t= { handle_forwarding_success, handle_forwarding_failure };\r\n\r\n\tenque_handlers(pvar, 2, msgs, handlers);\r\n}\r\n\r\nstatic BOOL handle_auth_failure(PTInstVar pvar)\r\n{\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"Authentication failed\");\r\n\r\n\t// retry count\ufffd\u0312\u01c9\ufffd (2005.7.15 yutaka)\r\n\tpvar->userauth_retry_count++;\r\n\r\n\tAUTH_set_generic_mode(pvar);\r\n\tAUTH_advance_to_next_cred(pvar);\r\n\tpvar->ssh_state.status_flags &= ~STATUS_DONT_SEND_CREDENTIALS;\r\n\ttry_send_credentials(pvar);\r\n\treturn FALSE;\r\n}\r\n\r\nstatic BOOL handle_rsa_auth_refused(PTInstVar pvar)\r\n{\r\n\tif (pvar->auth_state.cur_cred.method == SSH_AUTH_PAGEANT) {\r\n\t\tif (pvar->pageant_keycount <= pvar->pageant_keycurrent) {\r\n\t\t\t// \ufffdS\ufffd\u0102\u030c\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdI\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\t\t\tsafefree(pvar->pageant_key);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// \ufffd\u0702\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\t\t\tpvar->ssh_state.status_flags &= ~STATUS_DONT_SEND_CREDENTIALS;\r\n\t\t\ttry_send_credentials(pvar);\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t}\r\n\tAUTH_destroy_cur_cred(pvar);\r\n\treturn handle_auth_failure(pvar);\r\n}\r\n\r\nstatic BOOL handle_TIS_challenge(PTInstVar pvar)\r\n{\r\n\tif (grab_payload(pvar, 4)) {\r\n\t\tint len = get_payload_uint32(pvar, 0);\r\n\r\n\t\tif (grab_payload(pvar, len)) {\r\n\t\t\tlogputs(LOG_LEVEL_VERBOSE, \"Received TIS challenge\");\r\n\r\n\t\t\tAUTH_set_TIS_mode(pvar, pvar->ssh_state.payload + 4, len, 0);\r\n\t\t\tAUTH_advance_to_next_cred(pvar);\r\n\t\t\tpvar->ssh_state.status_flags &= ~STATUS_DONT_SEND_CREDENTIALS;\r\n\t\t\ttry_send_credentials(pvar);\r\n\t\t}\r\n\t}\r\n\treturn FALSE;\r\n}\r\n\r\nstatic BOOL handle_auth_required(PTInstVar pvar)\r\n{\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"Server requires authentication\");\r\n\r\n\tpvar->ssh_state.status_flags &= ~STATUS_DONT_SEND_CREDENTIALS;\r\n\ttry_send_credentials(pvar);\r\n\t/* the first AUTH_advance_to_next_cred is issued early by ttxssh.c */\r\n\r\n\treturn FALSE;\r\n}\r\n\r\nstatic BOOL handle_ignore(PTInstVar pvar)\r\n{\r\n\tif (SSHv1(pvar)) {\r\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"SSH_MSG_IGNORE was received.\");\r\n\r\n\t\tif (grab_payload(pvar, 4)\r\n\t\t && grab_payload(pvar, get_payload_uint32(pvar, 0))) {\r\n\t\t\t/* ignore it! but it must be decompressed */\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_IGNORE was received.\");\r\n\r\n\t\t// \ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd\ufffd SSH2_MSG_IGNORE \ufffd\u030e\ufffd\ufffd\u0349\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\r\n\t\t// Cisco \ufffd\ufffd\ufffd[\ufffd^\ufffd\u038d\ufffd (2006.11.28 maya)\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_debug(PTInstVar pvar)\r\n{\r\n\tBOOL always_display;\r\n\tchar *description;\r\n\tint description_len;\r\n\tchar buf[2048];\r\n\r\n\tif (SSHv1(pvar)) {\r\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"SSH_MSG_DEBUG was received.\");\r\n\r\n\t\tif (grab_payload(pvar, 4)\r\n\t\t && grab_payload(pvar, description_len =\r\n\t\t                 get_payload_uint32(pvar, 0))) {\r\n\t\t\talways_display = FALSE;\r\n\t\t\tdescription = pvar->ssh_state.payload + 4;\r\n\t\t\tdescription[description_len] = 0;\r\n\t\t} else {\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t} else {\r\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_DEBUG was received.\");\r\n\r\n\t\tif (grab_payload(pvar, 5)\r\n\t\t && grab_payload(pvar,\r\n\t\t                 (description_len = get_payload_uint32(pvar, 1)) + 4)\r\n\t\t && grab_payload(pvar,\r\n\t\t                 get_payload_uint32(pvar, 5 + description_len))) {\r\n\t\t\talways_display = pvar->ssh_state.payload[0] != 0;\r\n\t\t\tdescription = pvar->ssh_state.payload + 5;\r\n\t\t\tdescription[description_len] = 0;\r\n\t\t} else {\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t}\r\n\r\n\tchop_newlines(description);\r\n\t_snprintf_s(buf, sizeof(buf), _TRUNCATE, \"DEBUG message from server: %s\",\r\n\t            description);\r\n\tif (always_display) {\r\n\t\tnotify_nonfatal_error(pvar, buf);\r\n\t} else {\r\n\t\tlogputs(LOG_LEVEL_VERBOSE, buf);\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_disconnect(PTInstVar pvar)\r\n{\r\n\tint reason_code;\r\n\tchar *description;\r\n\tint description_len;\r\n\tchar buf[2048];\r\n\tchar *explanation = \"\";\r\n\tchar uimsg[MAX_UIMSG];\r\n\r\n\tif (SSHv1(pvar)) {\r\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"SSH_MSG_DISCONNECT was received.\");\r\n\r\n\t\tif (grab_payload(pvar, 4)\r\n\t\t && grab_payload(pvar, description_len = get_payload_uint32(pvar, 0))) {\r\n\t\t\treason_code = -1;\r\n\t\t\tdescription = pvar->ssh_state.payload + 4;\r\n\t\t\tdescription[description_len] = 0;\r\n\t\t} else {\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t} else {\r\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_DISCONNECT was received.\");\r\n\r\n\t\tif (grab_payload(pvar, 8)\r\n\t\t && grab_payload(pvar,\r\n\t\t                 (description_len = get_payload_uint32(pvar, 4)) + 4)\r\n\t\t && grab_payload(pvar,\r\n\t\t                 get_payload_uint32(pvar, 8 + description_len))) {\r\n\t\t\treason_code = get_payload_uint32(pvar, 0);\r\n\t\t\tdescription = pvar->ssh_state.payload + 8;\r\n\t\t\tdescription[description_len] = 0;\r\n\t\t} else {\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t}\r\n\r\n\tchop_newlines(description);\r\n\tif (description[0] == 0) {\r\n\t\tdescription = NULL;\r\n\t}\r\n\r\n\tif (get_handler(pvar, SSH_SMSG_FAILURE) == handle_forwarding_failure) {\r\n\t\tUTIL_get_lang_msg(\"MSG_SSH_UNABLE_FWD_ERROR\", pvar,\r\n\t\t                  \"\\nIt may have disconnected because it was unable to forward a port you requested to be forwarded from the server.\\n\"\r\n\t\t                  \"This often happens when someone is already forwarding that port from the server.\");\r\n\t\tstrncpy_s(uimsg, sizeof(uimsg), pvar->UIMsg, _TRUNCATE);\r\n\t\texplanation = uimsg;\r\n\t}\r\n\r\n\tif (description != NULL) {\r\n\t\tUTIL_get_lang_msg(\"MSG_SSH_SERVER_DISCON_ERROR\", pvar,\r\n\t\t                  \"Server disconnected with message '%s'%s\");\r\n\t\t_snprintf_s(buf, sizeof(buf), _TRUNCATE,\r\n\t\t            pvar->UIMsg, description,\r\n\t\t            explanation);\r\n\t} else {\r\n\t\tUTIL_get_lang_msg(\"MSG_SSH_SERVER_DISCON_NORES_ERROR\", pvar,\r\n\t\t                  \"Server disconnected (no reason given).%s\");\r\n\t\t_snprintf_s(buf, sizeof(buf), _TRUNCATE,\r\n\t\t            pvar->UIMsg, explanation);\r\n\t}\r\n\r\n\tif (SSHv2(pvar)) {\r\n\t\t// SSH2_MSG_DISCONNECT \ufffd\ufffd\ufffd\udaca\udfce\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0182\u0349\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdM\ufffd\ufffd\ufffd\u0102\u0342\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\r\n\t\tnotify_fatal_error(pvar, buf, FALSE);\r\n\t}\r\n\telse {\r\n\t\t// SSH1 \ufffd\u030f\ua347\ufffd\u030ed\ufffdl\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\u0302\u0141A\ufffd\u0211O\ufffd\u0302\u0702\u0702\u0242\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\r\n\t\tnotify_fatal_error(pvar, buf, TRUE);\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_unimplemented(PTInstVar pvar)\r\n{\r\n\t/* Should never receive this since we only send base 2.0 protocol messages */\r\n\tgrab_payload(pvar, 4);\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_crypt_success(PTInstVar pvar)\r\n{\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"Secure mode successfully achieved\");\r\n\treturn FALSE;\r\n}\r\n\r\nstatic BOOL handle_noauth_success(PTInstVar pvar)\r\n{\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"Server does not require authentication\");\r\n\tprep_compression(pvar);\r\n\treturn FALSE;\r\n}\r\n\r\nstatic BOOL handle_auth_success(PTInstVar pvar)\r\n{\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"Authentication accepted\");\r\n\tprep_compression(pvar);\r\n\r\n\t// \ufffdn\ufffd[\ufffdg\ufffdr\ufffd[\ufffdg\ufffdE\ufffdX\ufffd\ufffd\ufffdb\ufffdh\ufffd\u030aJ\ufffdn (2004.12.11 yutaka)\r\n\tstart_ssh_heartbeat_thread(pvar);\r\n\r\n\treturn FALSE;\r\n}\r\n\r\n/*\r\n * SSH1\ufffdT\ufffd[\ufffdo\ufffd\ufffd\ufffd\u7457\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd`\ufffdF\ufffdb\ufffdN\ufffd\ufffd\ufffd\u0101A\ufffd\u014c\ufffd\ufffdknown_hosts\ufffd_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\ufffd\\\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n */\r\nstatic BOOL handle_server_public_key(PTInstVar pvar)\r\n{\r\n\tint server_key_public_exponent_len;\r\n\tint server_key_public_modulus_pos;\r\n\tint server_key_public_modulus_len;\r\n\tint host_key_bits_pos;\r\n\tint host_key_public_exponent_len;\r\n\tint host_key_public_modulus_pos;\r\n\tint host_key_public_modulus_len;\r\n\tint protocol_flags_pos;\r\n\tint supported_ciphers;\r\n\tchar *inmsg;\r\n\tKey hostkey;\r\n\tint supported_types;\r\n\tint ret;\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH_SMSG_PUBLIC_KEY was received.\");\r\n\r\n\tif (!grab_payload(pvar, 14))\r\n\t\treturn FALSE;\r\n\tserver_key_public_exponent_len = get_mpint_len(pvar, 12);\r\n\r\n\tif (!grab_payload(pvar, server_key_public_exponent_len + 2))\r\n\t\treturn FALSE;\r\n\tserver_key_public_modulus_pos = 14 + server_key_public_exponent_len;\r\n\tserver_key_public_modulus_len =\r\n\t\tget_mpint_len(pvar, server_key_public_modulus_pos);\r\n\r\n\tif (!grab_payload(pvar, server_key_public_modulus_len + 6))\r\n\t\treturn FALSE;\r\n\thost_key_bits_pos =\r\n\t\tserver_key_public_modulus_pos + 2 + server_key_public_modulus_len;\r\n\thost_key_public_exponent_len =\r\n\t\tget_mpint_len(pvar, host_key_bits_pos + 4);\r\n\r\n\tif (!grab_payload(pvar, host_key_public_exponent_len + 2))\r\n\t\treturn FALSE;\r\n\thost_key_public_modulus_pos =\r\n\t\thost_key_bits_pos + 6 + host_key_public_exponent_len;\r\n\thost_key_public_modulus_len =\r\n\t\tget_mpint_len(pvar, host_key_public_modulus_pos);\r\n\r\n\tif (!grab_payload(pvar, host_key_public_modulus_len + 12))\r\n\t\treturn FALSE;\r\n\tprotocol_flags_pos =\r\n\t\thost_key_public_modulus_pos + 2 + host_key_public_modulus_len;\r\n\r\n\tinmsg = pvar->ssh_state.payload;\r\n\r\n\tCRYPT_set_server_cookie(pvar, inmsg);\r\n\tif (!CRYPT_set_server_RSA_key(pvar,\r\n\t                              get_uint32(inmsg + 8),\r\n\t                              pvar->ssh_state.payload + 12,\r\n\t                              inmsg + server_key_public_modulus_pos))\r\n\t\treturn FALSE;\r\n\tif (!CRYPT_set_host_RSA_key(pvar,\r\n\t                            get_uint32(inmsg + host_key_bits_pos),\r\n\t                            inmsg + host_key_bits_pos + 4,\r\n\t                            inmsg + host_key_public_modulus_pos))\r\n\t\treturn FALSE;\r\n\tpvar->ssh_state.server_protocol_flags =\r\n\t\tget_uint32(inmsg + protocol_flags_pos);\r\n\r\n\tsupported_ciphers = get_uint32(inmsg + protocol_flags_pos + 4);\r\n\tif (!CRYPT_set_supported_ciphers(pvar,\r\n\t                                 supported_ciphers,\r\n\t                                 supported_ciphers))\r\n\t\treturn FALSE;\r\n\r\n\t// SSH1 \ufffdT\ufffd[\ufffdo\ufffd\u0341A\ufffdT\ufffd|\ufffd[\ufffdg\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffdF\ufffd\u0615\ufffd\ufffd\ufffd\ufffd\ud805\uddc2\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\r\n\t// RSA \ufffd\ufffd\ufffdL\ufffd\ufffd\ufffd\u0202\ufffd PAGEANT \ufffd\ufffdL\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\ufffd\r\n\tsupported_types = get_uint32(inmsg + protocol_flags_pos + 8);\r\n\tif ((supported_types & (1 << SSH_AUTH_RSA)) > 0) {\r\n\t\tsupported_types |= (1 << SSH_AUTH_PAGEANT);\r\n\t}\r\n\tif (!AUTH_set_supported_auth_types(pvar,\r\n\t                                   supported_types))\r\n\t\treturn FALSE;\r\n\r\n\t/* this must be the LAST THING in this function, since it can cause\r\n\t   host_is_OK to be called. */\r\n\thostkey.type = KEY_RSA1;\r\n\thostkey.bits = get_uint32(inmsg + host_key_bits_pos);\r\n\thostkey.exp = inmsg + host_key_bits_pos + 4;\r\n\thostkey.mod = inmsg + host_key_public_modulus_pos;\r\n\r\n\tret = HOSTS_check_host_key(pvar, pvar->ssh_state.hostname, pvar->ssh_state.tcpport, &hostkey);\r\n\tif (ret == TRUE) {\r\n\t\t// known_hosts\ufffd_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\u030c\u0102\u044fo\ufffd\ufffd\ufffd\u0355s\ufffdv\ufffd\u0202\u0302\u0141A\ufffd\ufffd\ufffd\ufffd\ufffd\u030f\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffds\ufffd\ufffd\ufffd\ufffdB\r\n\t\tSSH_notify_host_OK(pvar);\r\n\r\n\t} else {\r\n\t\t// known_hosts\ufffd_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\u030c\u0102\u044fo\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\u020d~\ufffdA\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\r\n\t}\r\n\r\n\treturn FALSE;\r\n}\r\n\r\n/*\r\nThe ID must have already been found to start with \"SSH-\". It must\r\nbe null-terminated.\r\n*/\r\nstatic BOOL parse_protocol_ID(PTInstVar pvar, char *ID)\r\n{\r\n\tchar *str;\r\n\r\n\tfor (str = ID + 4; *str >= '0' && *str <= '9'; str++) {\r\n\t}\r\n\r\n\tif (*str != '.') {\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tpvar->protocol_major = atoi(ID + 4);\r\n\tpvar->protocol_minor = atoi(str + 1);\r\n\r\n\tfor (str = str + 1; *str >= '0' && *str <= '9'; str++) {\r\n\t}\r\n\r\n\treturn *str == '-';\r\n}\r\n\r\n/*\r\nOn entry, the pvar->protocol_xxx fields hold the server's advertised\r\nprotocol number. We replace the fields with the protocol number we will\r\nactually use, or return FALSE if there is no usable protocol version.\r\n*/\r\nstatic int negotiate_protocol(PTInstVar pvar)\r\n{\r\n\tswitch (pvar->protocol_major) {\r\n\tcase 1:\r\n\t\tif (pvar->protocol_minor == 99 &&\r\n\t\t    pvar->settings.ssh_protocol_version == 2) {\r\n\t\t\t// \ufffdT\ufffd[\ufffdo\ufffd\ufffd 1.99 \ufffd\u0143\ufffd\ufffd[\ufffdU\ufffd\ufffd SSH2 \ufffd\ufffdI\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\u0302\u0202\ufffd\ufffd\r\n\t\t\t// 2.0 \ufffd\u0691\ufffd\ufffd\u0182\ufffd\ufffd\ufffd\r\n\t\t\tpvar->protocol_major = 2;\r\n\t\t\tpvar->protocol_minor = 0;\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tif (pvar->settings.ssh_protocol_version == 2) {\r\n\t\t\t// \ufffdo\ufffd[\ufffdW\ufffd\ufffd\ufffd\ufffd\ufffd\u10a2\r\n\t\t\treturn -1;\r\n\t\t}\r\n\r\n\t\tif (pvar->protocol_minor > 5) {\r\n\t\t\tpvar->protocol_minor = 5;\r\n\t\t}\r\n\r\n\t\treturn 0;\r\n\r\n\t// for SSH2(yutaka)\r\n\tcase 2:\r\n\t\tif (pvar->settings.ssh_protocol_version == 1) {\r\n\t\t\t// \ufffdo\ufffd[\ufffdW\ufffd\ufffd\ufffd\ufffd\ufffd\u10a2\r\n\t\t\treturn -1;\r\n\t\t}\r\n\r\n\t\treturn 0;\t\t\t// SSH2 support\r\n\r\n\tdefault:\r\n\t\treturn 1;\r\n\t}\r\n}\r\n\r\nstatic void init_protocol(PTInstVar pvar)\r\n{\r\n\tCRYPT_initialize_random_numbers(pvar);\r\n\r\n\t// known_hosts\ufffdt\ufffd@\ufffdC\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdz\ufffdX\ufffdg\ufffd\ufffd\ufffdJ\ufffd\ufffd\ufffd\ufffd\ufffd\u01c2\u0742\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\r\n\tHOSTS_prefetch_host_key(pvar, pvar->ssh_state.hostname, pvar->ssh_state.tcpport);\r\n\r\n\t/* while we wait for a response from the server... */\r\n\r\n\tif (SSHv1(pvar)) {\r\n\t\tenque_handler(pvar, SSH_MSG_DISCONNECT, handle_disconnect);\r\n\t\tenque_handler(pvar, SSH_MSG_IGNORE, handle_ignore);\r\n\t\tenque_handler(pvar, SSH_MSG_DEBUG, handle_debug);\r\n\t\tenque_handler(pvar, SSH_SMSG_PUBLIC_KEY, handle_server_public_key);\r\n\r\n\t} else {  // for SSH2(yutaka)\r\n\t\tenque_handler(pvar, SSH2_MSG_DISCONNECT, handle_disconnect);\r\n\t\tenque_handler(pvar, SSH2_MSG_IGNORE, handle_ignore);\r\n\t\tenque_handler(pvar, SSH2_MSG_DEBUG, handle_debug);\r\n\t\tenque_handler(pvar, SSH2_MSG_KEXINIT, handle_SSH2_kexinit);\r\n\t\tenque_handler(pvar, SSH2_MSG_KEXDH_INIT, handle_unimplemented);\r\n\t\tenque_handler(pvar, SSH2_MSG_KEXDH_REPLY, handle_SSH2_dh_common_reply);\r\n\t\tenque_handler(pvar, SSH2_MSG_KEX_DH_GEX_REPLY, handle_SSH2_dh_gex_reply);\r\n\t\tenque_handler(pvar, SSH2_MSG_NEWKEYS, handle_SSH2_newkeys);\r\n\t\tenque_handler(pvar, SSH2_MSG_SERVICE_ACCEPT, handle_SSH2_service_accept);\r\n\t\tenque_handler(pvar, SSH2_MSG_EXT_INFO, handle_SSH2_ext_info);\r\n\t\tenque_handler(pvar, SSH2_MSG_USERAUTH_SUCCESS, handle_SSH2_userauth_success);\r\n\t\tenque_handler(pvar, SSH2_MSG_USERAUTH_FAILURE, handle_SSH2_userauth_failure);\r\n\t\tenque_handler(pvar, SSH2_MSG_USERAUTH_BANNER, handle_SSH2_userauth_banner);\r\n\t\tenque_handler(pvar, SSH2_MSG_USERAUTH_INFO_REQUEST, handle_SSH2_userauth_msg60);\r\n\r\n\t\tenque_handler(pvar, SSH2_MSG_UNIMPLEMENTED, handle_unimplemented);\r\n\r\n\t\t// \ufffd\ufffd\ufffd[\ufffdU\ufffdF\ufffd\u060c\ufffd\u0303f\ufffdB\ufffdX\ufffdp\ufffdb\ufffd`\ufffd\ufffd\ufffd[\ufffd`\ufffd\ufffd\r\n\t\tenque_handler(pvar, SSH2_MSG_CHANNEL_CLOSE, handle_SSH2_channel_close);\r\n\t\tenque_handler(pvar, SSH2_MSG_CHANNEL_DATA, handle_SSH2_channel_data);\r\n\t\tenque_handler(pvar, SSH2_MSG_CHANNEL_EOF, handle_SSH2_channel_eof);\r\n\t\tenque_handler(pvar, SSH2_MSG_CHANNEL_EXTENDED_DATA, handle_SSH2_channel_extended_data);\r\n\t\tenque_handler(pvar, SSH2_MSG_CHANNEL_OPEN, handle_SSH2_channel_open);\r\n\t\tenque_handler(pvar, SSH2_MSG_CHANNEL_OPEN_CONFIRMATION, handle_SSH2_open_confirm);\r\n\t\tenque_handler(pvar, SSH2_MSG_CHANNEL_OPEN_FAILURE, handle_SSH2_open_failure);\r\n\t\tenque_handler(pvar, SSH2_MSG_CHANNEL_REQUEST, handle_SSH2_channel_request);\r\n\t\tenque_handler(pvar, SSH2_MSG_CHANNEL_WINDOW_ADJUST, handle_SSH2_window_adjust);\r\n\t\tenque_handler(pvar, SSH2_MSG_CHANNEL_SUCCESS, handle_SSH2_channel_success);\r\n\t\tenque_handler(pvar, SSH2_MSG_CHANNEL_FAILURE, handle_SSH2_channel_failure);\r\n\t\tenque_handler(pvar, SSH2_MSG_GLOBAL_REQUEST, handle_SSH2_client_global_request);\r\n\t\tenque_handler(pvar, SSH2_MSG_REQUEST_FAILURE, handle_SSH2_request_failure);\r\n\t\tenque_handler(pvar, SSH2_MSG_REQUEST_SUCCESS, handle_SSH2_request_success);\r\n\r\n\t\tclient_init_global_confirm();\r\n\r\n\t}\r\n}\r\n\r\nvoid server_version_check(PTInstVar pvar)\r\n{\r\n\tchar *server_swver;\r\n\r\n\tpvar->server_compat_flag = 0;\r\n\r\n\tif ((server_swver = strchr(pvar->server_version_string+4, '-')) == NULL) {\r\n\t\tlogputs(LOG_LEVEL_WARNING, \"Can't get server software version string.\");\r\n\t\treturn;\r\n\t}\r\n\tserver_swver++;\r\n\r\n\tif (strncmp(server_swver, \"Cisco-1\", 7) == 0) {\r\n\t\tpvar->server_compat_flag |= SSH_BUG_DHGEX_LARGE;\r\n\t\tlogputs(LOG_LEVEL_INFO, \"Server version string is matched to \\\"Cisco-1\\\", compatibility flag SSH_BUG_DHGEX_LARGE is enabled.\");\r\n\t}\r\n}\r\n\r\nBOOL SSH_handle_server_ID(PTInstVar pvar, char *ID, int ID_len)\r\n{\r\n\tstatic char prefix[64];\r\n\tint negotiate;\r\n\tchar uimsg[MAX_UIMSG];\r\n\r\n\t// initialize SSH2 memory dump (2005.3.7 yutaka)\r\n\tinit_memdump();\r\n\tpush_memdump(\"pure server ID\", \"start protocol version exchange\", ID, ID_len);\r\n\r\n\tif (ID_len <= 0) {\r\n\t\treturn FALSE;\r\n\t} else {\r\n\t\tint buf_len;\r\n\t\tchar *buf;\r\n\r\n\t\tstrncpy_s(prefix, sizeof(prefix), \"Received server identification string: \", _TRUNCATE);\r\n\t\tbuf_len = strlen(prefix) + ID_len + 1;\r\n\t\tbuf = (char *) malloc(buf_len);\r\n\t\tstrncpy_s(buf, buf_len, prefix, _TRUNCATE);\r\n\t\tstrncat_s(buf, buf_len, ID, _TRUNCATE);\r\n\t\tchop_newlines(buf);\r\n\t\tlogputs(LOG_LEVEL_VERBOSE, buf);\r\n\t\tfree(buf);\r\n\r\n\t\tif (ID[ID_len - 1] != '\\n') {\r\n\t\t\tpvar->ssh_state.status_flags |= STATUS_IN_PARTIAL_ID_STRING;\r\n\t\t\treturn FALSE;\r\n\t\t} else if ((pvar->ssh_state.status_flags & STATUS_IN_PARTIAL_ID_STRING) != 0) {\r\n\t\t\tpvar->ssh_state.status_flags &= ~STATUS_IN_PARTIAL_ID_STRING;\r\n\t\t\treturn FALSE;\r\n\t\t} else if (strncmp(ID, \"SSH-\", 4) != 0) {\r\n\t\t\treturn FALSE;\r\n\t\t} else {\r\n\t\t\tID[ID_len - 1] = 0;\r\n\r\n\t\t\tif (ID_len > 1 && ID[ID_len - 2] == '\\r') {\r\n\t\t\t\tID[ID_len - 2] = 0;\r\n\t\t\t}\r\n\r\n\t\t\tpvar->ssh_state.server_ID = _strdup(ID);\r\n\r\n\t\t\tif (!parse_protocol_ID(pvar, ID)) {\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_VERSION_ERROR\", pvar,\r\n\t\t\t\t                  \"This program does not understand the server's version of the protocol.\");\r\n\t\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\t}\r\n\t\t\telse if ((negotiate = negotiate_protocol(pvar)) == 1) {\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_VERSION_ERROR\", pvar,\r\n\t\t\t\t                  \"This program does not understand the server's version of the protocol.\");\r\n\t\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\t}\r\n\t\t\telse if (negotiate == -1) {\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_VERSION_MISMATCH\", pvar,\r\n\t\t\t\t                  \"Protocol version mismatch. server:%d.%d client:%d\");\r\n\t\t\t\t_snprintf_s(uimsg, sizeof(uimsg), _TRUNCATE, pvar->UIMsg,\r\n\t\t\t\t            pvar->protocol_major, pvar->protocol_minor, pvar->settings.ssh_protocol_version);\r\n\t\t\t\tnotify_fatal_error(pvar, uimsg, TRUE);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tchar TTSSH_ID[1024];\r\n\t\t\t\tint TTSSH_ID_len;\r\n\r\n\t\t\t\t// SSH \ufffdo\ufffd[\ufffdW\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd teraterm \ufffd\ufffd\ufffd\u0243Z\ufffdb\ufffdg\ufffd\ufffd\ufffd\ufffd\r\n\t\t\t\t// SCP \ufffdR\ufffd}\ufffd\ufffd\ufffdh\ufffd\u0302\ufffd\ufffd\ufffd (2008.2.3 maya)\r\n\t\t\t\tpvar->cv->isSSH = pvar->protocol_major;\r\n\r\n\t\t\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdg\ufffd\u0303o\ufffd[\ufffdW\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u64fe\ufffd\ufffd\ufffd\ufffd (2005.3.3 yutaka)\r\n\t\t\t\t_snprintf_s(TTSSH_ID, sizeof(TTSSH_ID), _TRUNCATE,\r\n\t\t\t\t            \"SSH-%d.%d-TTSSH/%d.%d Win32\\r\\n\",\r\n\t\t\t\t            pvar->protocol_major, pvar->protocol_minor,\r\n\t\t\t\t            TTSSH_VERSION_MAJOR, TTSSH_VERSION_MINOR);\r\n\t\t\t\tTTSSH_ID_len = strlen(TTSSH_ID);\r\n\r\n\t\t\t\t// for SSH2(yutaka)\r\n\t\t\t\t// \ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg\ufffdo\ufffd[\ufffdW\ufffd\ufffd\ufffd\ufffd\ufffd\u0315\u06d1\ufffd\ufffdi\ufffd\ufffd\ufffds\ufffd\u034e\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffd\u0181j\r\n\t\t\t\tstrncpy_s(pvar->client_version_string, sizeof(pvar->client_version_string),\r\n\t\t\t\t          TTSSH_ID, _TRUNCATE);\r\n\r\n\t\t\t\t// \ufffdT\ufffd[\ufffdo\ufffdo\ufffd[\ufffdW\ufffd\ufffd\ufffd\ufffd\ufffd\u0315\u06d1\ufffd\ufffdi\ufffd\ufffd\ufffds\ufffd\u034e\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffd\u0181j(2005.3.9 yutaka)\r\n\t\t\t\t_snprintf_s(pvar->server_version_string,\r\n\t\t\t\t            sizeof(pvar->server_version_string), _TRUNCATE,\r\n\t\t\t\t            \"%s\", pvar->ssh_state.server_ID);\r\n\r\n\t\t\t\t// \ufffdT\ufffd[\ufffdo\ufffdo\ufffd[\ufffdW\ufffd\ufffd\ufffd\ufffd\ufffd\u0303`\ufffdF\ufffdb\ufffdN\r\n\t\t\t\tserver_version_check(pvar);\r\n\r\n\t\t\t\tif ((pvar->Psend) (pvar->socket, TTSSH_ID, TTSSH_ID_len, 0) != TTSSH_ID_len) {\r\n\t\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_SEND_ID_ERROR\", pvar,\r\n\t\t\t\t\t                  \"An error occurred while sending the SSH ID string.\\n\"\r\n\t\t\t\t\t                  \"The connection will close.\");\r\n\t\t\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// \ufffd\ufffd\ufffds\ufffd\u030f\ufffd\ufffd\ufffd\r\n\t\t\t\t\tchop_newlines(pvar->client_version_string);\r\n\t\t\t\t\tlogprintf(LOG_LEVEL_VERBOSE, \"Sent client identification string: %s\", pvar->client_version_string);\r\n\r\n\t\t\t\t\tpush_memdump(\"server ID\", NULL, pvar->server_version_string, strlen(pvar->server_version_string));\r\n\t\t\t\t\tpush_memdump(\"client ID\", NULL, pvar->client_version_string, strlen(pvar->client_version_string));\r\n\r\n\t\t\t\t\t// SSH\ufffdn\ufffd\ufffd\ufffdh\ufffd\ufffd\ufffd\u0313o\ufffd^\ufffd\ufffd\ufffds\ufffd\ufffd\r\n\t\t\t\t\tinit_protocol(pvar);\r\n\r\n\t\t\t\t\tSSH2_dispatch_init(1);\r\n\t\t\t\t\tSSH2_dispatch_add_message(SSH2_MSG_KEXINIT);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstatic BOOL handle_exit(PTInstVar pvar)\r\n{\r\n\tif (grab_payload(pvar, 4)) {\r\n\t\tbegin_send_packet(pvar, SSH_CMSG_EXIT_CONFIRMATION, 0);\r\n\t\tfinish_send_packet(pvar);\r\n\t\tnotify_closed_connection(pvar, \"disconnected by server request\");\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_data(PTInstVar pvar)\r\n{\r\n\tif (grab_payload_limited(pvar, 4)) {\r\n\t\tpvar->ssh_state.payload_datalen = get_payload_uint32(pvar, 0);\r\n\t\tpvar->ssh_state.payload_datastart = 4;\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_channel_open(PTInstVar pvar)\r\n{\r\n\tint host_len;\r\n\tint originator_len;\r\n\r\n\tif ((pvar->ssh_state.\r\n\t\t server_protocol_flags & SSH_PROTOFLAG_HOST_IN_FWD_OPEN) != 0) {\r\n\t\tif (grab_payload(pvar, 8)\r\n\t\t && grab_payload(pvar,\r\n\t\t                 8 + (host_len = get_payload_uint32(pvar, 4)))\r\n\t\t && grab_payload(pvar, originator_len =\r\n\t\t                 get_payload_uint32(pvar, host_len + 12))) {\r\n\t\t\tint local_port = get_payload_uint32(pvar, 8 + host_len);\r\n\r\n\t\t\tpvar->ssh_state.payload[8 + host_len] = 0;\r\n\t\t\tFWD_open(pvar, get_payload_uint32(pvar, 0),\r\n\t\t\t         pvar->ssh_state.payload + 8, local_port,\r\n\t\t\t         pvar->ssh_state.payload + 16 + host_len,\r\n\t\t\t         originator_len,\r\n\t\t\t         NULL);\r\n\t\t}\r\n\t} else {\r\n\t\tif (grab_payload(pvar, 8)\r\n\t\t && grab_payload(pvar,\r\n\t\t                 4 + (host_len = get_payload_uint32(pvar, 4)))) {\r\n\t\t\tint local_port = get_payload_uint32(pvar, 8 + host_len);\r\n\r\n\t\t\tpvar->ssh_state.payload[8 + host_len] = 0;\r\n\t\t\tFWD_open(pvar, get_payload_uint32(pvar, 0),\r\n\t\t\t         pvar->ssh_state.payload + 8, local_port, NULL, 0,\r\n\t\t\t         NULL);\r\n\t\t}\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_X11_channel_open(PTInstVar pvar)\r\n{\r\n\tint originator_len;\r\n\r\n\tif ((pvar->ssh_state.server_protocol_flags & SSH_PROTOFLAG_HOST_IN_FWD_OPEN) != 0) {\r\n\t\tif (grab_payload(pvar, 8)\r\n\t\t && grab_payload(pvar, originator_len = get_payload_uint32(pvar, 4))) {\r\n\t\t\tFWD_X11_open(pvar, get_payload_uint32(pvar, 0),\r\n\t\t\t             pvar->ssh_state.payload + 8, originator_len, NULL);\r\n\t\t}\r\n\t} else {\r\n\t\tif (grab_payload(pvar, 4)) {\r\n\t\t\tFWD_X11_open(pvar, get_payload_uint32(pvar, 0), NULL, 0, NULL);\r\n\t\t}\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_channel_open_confirmation(PTInstVar pvar)\r\n{\r\n\tif (grab_payload(pvar, 8)) {\r\n\t\tFWD_confirmed_open(pvar, get_payload_uint32(pvar, 0),\r\n\t\t                   get_payload_uint32(pvar, 4));\r\n\t}\r\n\treturn FALSE;\r\n}\r\n\r\nstatic BOOL handle_channel_open_failure(PTInstVar pvar)\r\n{\r\n\tif (grab_payload(pvar, 4)) {\r\n\t\tFWD_failed_open(pvar, get_payload_uint32(pvar, 0), -1);\r\n\t}\r\n\treturn FALSE;\r\n}\r\n\r\nstatic BOOL handle_channel_data(PTInstVar pvar)\r\n{\r\n\tint len;\r\n\r\n\tif (grab_payload(pvar, 8)\r\n\t && grab_payload(pvar, len = get_payload_uint32(pvar, 4))) {\r\n\t\tFWDChannel *channel;\r\n\t\tint local_channel_num = get_payload_uint32(pvar, 0);\r\n\t\tif (!FWD_check_local_channel_num(pvar, local_channel_num)) {\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\tchannel = pvar->fwd_state.channels + local_channel_num;\r\n\t\tif (channel->type == TYPE_AGENT) {\r\n\t\t\tSSH_agent_response(pvar, NULL, local_channel_num,\r\n\t\t\t                   pvar->ssh_state.payload + 8, len);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tFWD_received_data(pvar, local_channel_num,\r\n\t\t\t                  pvar->ssh_state.payload + 8, len);\r\n\t\t}\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_channel_input_eof(PTInstVar pvar)\r\n{\r\n\tif (grab_payload(pvar, 4)) {\r\n\t\tint local_channel_num = get_payload_uint32(pvar, 0);\r\n\t\tFWDChannel *channel;\r\n\t\tif (!FWD_check_local_channel_num(pvar, local_channel_num)) {\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\tchannel = pvar->fwd_state.channels + local_channel_num;\r\n\t\tif (channel->type == TYPE_AGENT) {\r\n\t\t\tchannel->status |= FWD_CLOSED_REMOTE_IN;\r\n\t\t\tSSH_channel_input_eof(pvar, channel->remote_num, local_channel_num);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tFWD_channel_input_eof(pvar, local_channel_num);\r\n\t\t}\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_channel_output_eof(PTInstVar pvar)\r\n{\r\n\tif (grab_payload(pvar, 4)) {\r\n\t\tint local_channel_num = get_payload_uint32(pvar, 0);\r\n\t\tFWDChannel *channel;\r\n\t\tif (!FWD_check_local_channel_num(pvar, local_channel_num)) {\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\tchannel = pvar->fwd_state.channels + local_channel_num;\r\n\t\tif (channel->type == TYPE_AGENT) {\r\n\t\t\tchannel->status |= FWD_CLOSED_REMOTE_OUT;\r\n\t\t\tSSH_channel_output_eof(pvar, channel->remote_num);\r\n\t\t\tFWD_free_channel(pvar, local_channel_num);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tFWD_channel_output_eof(pvar, local_channel_num);\r\n\t\t}\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_agent_open(PTInstVar pvar)\r\n{\r\n\tif (grab_payload(pvar, 4)) {\r\n\t\tint remote_id = get_payload_uint32(pvar, 0);\r\n\t\tint local_id;\r\n\r\n\t\tif (pvar->agentfwd_enable && FWD_agent_forward_confirm(pvar)) {\r\n\t\t\tlocal_id = FWD_agent_open(pvar, remote_id);\r\n\t\t\tif (local_id == -1) {\r\n\t\t\t\tSSH_fail_channel_open(pvar, remote_id);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tSSH_confirm_channel_open(pvar, remote_id, local_id);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tSSH_fail_channel_open(pvar, remote_id);\r\n\t\t}\r\n\t}\r\n\t/*\r\n\telse {\r\n\t\t// \ufffd\u0292m\ufffd\ufffd\ufffd\u944a\ufffd\ufffdchannel\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\u0302\u0149\ufffd\ufffd\ufffd\ufffd\u0142\ufffd\ufffd\u0202\ufffd\r\n\t}\r\n\t*/\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n\r\n\r\n// \ufffdn\ufffd\ufffd\ufffdh\ufffd\ufffd\ufffd\ufffd\ufffdO\ufffd\ufffd\ufffd\u90c1\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd\ufffd\ufffd\ufffd\ufffd\u80b7\ufffd\ufffd\r\n\r\n#define HANDLE_MESSAGE_MAX 30\r\nstatic unsigned char handle_messages[HANDLE_MESSAGE_MAX];\r\nstatic int handle_message_count = 0;\r\nstatic int handle_message_stage = 0;\r\n\r\nvoid SSH2_dispatch_init(int stage)\r\n{\r\n\thandle_message_count = 0;\r\n\thandle_message_stage = stage;\r\n\r\n\tSSH2_dispatch_add_message(SSH2_MSG_IGNORE);\r\n\tSSH2_dispatch_add_message(SSH2_MSG_DEBUG);\r\n\tSSH2_dispatch_add_message(SSH2_MSG_DISCONNECT);\r\n\tSSH2_dispatch_add_message(SSH2_MSG_UNIMPLEMENTED);\r\n}\r\n\r\nint SSH2_dispatch_enabled_check(unsigned char message)\r\n{\r\n\tint i;\r\n\r\n\tfor (i = 0 ; i < handle_message_count ; i++) {\r\n\t\tif (handle_messages[i] == message)\r\n\t\t\treturn 1;\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\nvoid SSH2_dispatch_add_message(unsigned char message)\r\n{\r\n\tint i;\r\n\r\n\tif (handle_message_count >= HANDLE_MESSAGE_MAX) {\r\n\t\t// TODO: error check\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: too many handlers. handlers:%d, max:%d\", __FUNCTION__,\r\n\t\t\thandle_message_count, HANDLE_MESSAGE_MAX);\r\n\t\treturn;\r\n\t}\r\n\r\n\t// \ufffd\ufffd\ufffd\u0142\u0253o\ufffd^\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u90c1\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd\u0352\u01c9\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\r\n\tfor (i=0; i<handle_message_count; i++) {\r\n\t\tif (handle_messages[i] == message) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\r\n\thandle_messages[handle_message_count++] = message;\r\n}\r\n\r\nvoid SSH2_dispatch_add_range_message(unsigned char begin, unsigned char end)\r\n{\r\n\tunsigned char c;\r\n\r\n\tfor (c = begin ; c <= end ; c++) {\r\n\t\tSSH2_dispatch_add_message(c);\r\n\t}\r\n}\r\n\r\nvoid SSH1_handle_packet(PTInstVar pvar, char *data, unsigned int len, unsigned int padding)\r\n{\r\n\tunsigned char message = prep_packet_ssh1(pvar, data, len, padding);\r\n\r\n\t// SSH\ufffd\u0303\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd^\ufffdC\ufffdv\ufffd\ufffd\ufffd`\ufffdF\ufffdb\ufffdN\r\n\tif (message != SSH_MSG_NONE) {\r\n\t\t// \ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd^\ufffdC\ufffdv\ufffd\u0249\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdn\ufffd\ufffd\ufffdh\ufffd\ufffd\ufffd\ufffd\ufffdN\ufffd\ufffd\r\n\t\tSSHPacketHandler handler = get_handler(pvar, message);\r\n\r\n\t\tif (handler == NULL) {\r\n\t\t\tchar buf[1024];\r\n\r\n\t\t\tUTIL_get_lang_msg(\"MSG_SSH_UNEXP_MSG_ERROR\", pvar, \"Unexpected packet type received: %d\");\r\n\t\t\t_snprintf_s(buf, sizeof(buf), _TRUNCATE, pvar->UIMsg, message, handle_message_stage);\r\n\t\t\tnotify_fatal_error(pvar, buf, TRUE);\r\n\t\t} else {\r\n\t\t\tif (!handler(pvar)) {\r\n\t\t\t\tdeque_handlers(pvar, message);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid SSH2_handle_packet(PTInstVar pvar, char *data, unsigned int len, unsigned int aadlen, unsigned int authlen)\r\n{\r\n\tunsigned char message = prep_packet_ssh2(pvar, data, len, aadlen, authlen);\r\n\r\n\t// SSH\ufffd\u0303\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd^\ufffdC\ufffdv\ufffd\ufffd\ufffd`\ufffdF\ufffdb\ufffdN\r\n\tif (message != SSH_MSG_NONE) {\r\n\t\t// \ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd^\ufffdC\ufffdv\ufffd\u0249\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdn\ufffd\ufffd\ufffdh\ufffd\ufffd\ufffd\ufffd\ufffdN\ufffd\ufffd\r\n\t\tSSHPacketHandler handler = get_handler(pvar, message);\r\n\r\n\t\t// \ufffdz\ufffd\ufffdO\ufffd\u0303\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd^\ufffdC\ufffdv\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdA\ufffd{\ufffd[\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\tif (!SSH2_dispatch_enabled_check(message) || handler == NULL) {\r\n\t\t\tchar buf[1024];\r\n\r\n\t\t\tUTIL_get_lang_msg(\"MSG_SSH_UNEXP_MSG2_ERROR\", pvar, \"Unexpected SSH2 message(%d) on current stage(%d)\");\r\n\t\t\t_snprintf_s(buf, sizeof(buf), _TRUNCATE, pvar->UIMsg, message, handle_message_stage);\r\n\t\t\tnotify_fatal_error(pvar, buf, TRUE);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (handler == NULL) {\r\n\t\t\tunsigned char *outmsg = begin_send_packet(pvar, SSH2_MSG_UNIMPLEMENTED, 4);\r\n\r\n\t\t\tset_uint32(outmsg, pvar->ssh_state.receiver_sequence_number - 1);\r\n\t\t\tfinish_send_packet(pvar);\r\n\r\n\t\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: SSH2_MSG_UNIMPLEMENTED was sent.\", __FUNCTION__);\r\n\t\t\t/* XXX need to decompress incoming packet, but how? */\r\n\t\t} else {\r\n\t\t\tif (!handler(pvar)) {\r\n\t\t\t\tdeque_handlers(pvar, message);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstatic BOOL handle_pty_success(PTInstVar pvar)\r\n{\r\n\tFWD_enter_interactive_mode(pvar);\r\n\tenque_handler(pvar, SSH_SMSG_EXITSTATUS, handle_exit);\r\n\tenque_handler(pvar, SSH_SMSG_STDOUT_DATA, handle_data);\r\n\tenque_handler(pvar, SSH_SMSG_STDERR_DATA, handle_data);\r\n\tenque_handler(pvar, SSH_MSG_CHANNEL_DATA, handle_channel_data);\r\n\tenque_handler(pvar, SSH_MSG_CHANNEL_INPUT_EOF, handle_channel_input_eof);\r\n\tenque_handler(pvar, SSH_MSG_CHANNEL_OUTPUT_CLOSED, handle_channel_output_eof);\r\n\tenque_handler(pvar, SSH_MSG_PORT_OPEN, handle_channel_open);\r\n\tenque_handler(pvar, SSH_SMSG_X11_OPEN, handle_X11_channel_open);\r\n\tenque_handler(pvar, SSH_SMSG_AGENT_OPEN, handle_agent_open);\r\n\treturn FALSE;\r\n}\r\n\r\nstatic BOOL handle_pty_failure(PTInstVar pvar)\r\n{\r\n\tUTIL_get_lang_msg(\"MSG_SSH_ALLOC_TERMINAL_ERROR\", pvar,\r\n\t                  \"The server cannot allocate a pseudo-terminal. \"\r\n\t                  \"You may encounter some problems with the terminal.\");\r\n\tnotify_nonfatal_error(pvar, pvar->UIMsg);\r\n\treturn handle_pty_success(pvar);\r\n}\r\n\r\nstatic void prep_pty(PTInstVar pvar)\r\n{\r\n\tint len = strlen(pvar->ts->TermType);\r\n\tunsigned char *outmsg = begin_send_packet(pvar, SSH_CMSG_REQUEST_PTY, 4 + len + 16 + sizeof(ssh_ttymodes));\r\n\tstatic const int msgs[] = { SSH_SMSG_SUCCESS, SSH_SMSG_FAILURE };\r\n\tstatic const SSHPacketHandler handlers[]\r\n\t= { handle_pty_success, handle_pty_failure };\r\n\tint x, y;\r\n\r\n\tget_window_pixel_size(pvar, &x, &y);\r\n\r\n\tset_uint32(outmsg, len);\r\n\tmemcpy(outmsg + 4, pvar->ts->TermType, len);\r\n\tset_uint32(outmsg + 4 + len, pvar->ssh_state.win_rows);\r\n\tset_uint32(outmsg + 4 + len + 4, pvar->ssh_state.win_cols);\r\n\tset_uint32(outmsg + 4 + len + 8, x);\r\n\tset_uint32(outmsg + 4 + len + 12, y);\r\n\tmemcpy(outmsg + 4 + len + 16, ssh_ttymodes, sizeof(ssh_ttymodes));\r\n\tfinish_send_packet(pvar);\r\n\r\n\tenque_handlers(pvar, 2, msgs, handlers);\r\n\r\n\tbegin_send_packet(pvar, SSH_CMSG_EXEC_SHELL, 0);\r\n\tfinish_send_packet(pvar);\r\n}\r\n\r\nstatic BOOL handle_agent_request_success(PTInstVar pvar)\r\n{\r\n\tpvar->agentfwd_enable = TRUE;\r\n\tprep_pty(pvar);\r\n\treturn FALSE;\r\n}\r\n\r\nstatic BOOL handle_agent_request_failure(PTInstVar pvar)\r\n{\r\n\tprep_pty(pvar);\r\n\treturn FALSE;\r\n}\r\n\r\nstatic void prep_agent_request(PTInstVar pvar)\r\n{\r\n\tstatic const int msgs[] = { SSH_SMSG_SUCCESS, SSH_SMSG_FAILURE };\r\n\tstatic const SSHPacketHandler handlers[] = { handle_agent_request_success, handle_agent_request_failure };\r\n\r\n\tenque_handlers(pvar, 2, msgs, handlers);\r\n\r\n\tbegin_send_packet(pvar, SSH_CMSG_AGENT_REQUEST_FORWARDING, 0);\r\n\tfinish_send_packet(pvar);\r\n}\r\n\r\nstatic void prep_forwarding(PTInstVar pvar)\r\n{\r\n\tFWD_prep_forwarding(pvar);\r\n\r\n\tif (pvar->session_settings.ForwardAgent) {\r\n\t\tprep_agent_request(pvar);\r\n\t}\r\n\telse {\r\n\t\tprep_pty(pvar);\r\n\t}\r\n}\r\n\r\n//\r\n//\r\n// (2005.7.10 yutaka)\r\nstatic void enable_send_compression(PTInstVar pvar)\r\n{\r\n\tstatic int initialize = 0;\r\n\r\n\tif (initialize) {\r\n\t\tdeflateEnd(&pvar->ssh_state.compress_stream);\r\n\t}\r\n\tinitialize = 1;\r\n\r\n\tpvar->ssh_state.compress_stream.zalloc = NULL;\r\n\tpvar->ssh_state.compress_stream.zfree = NULL;\r\n\tpvar->ssh_state.compress_stream.opaque = NULL;\r\n\tif (deflateInit(&pvar->ssh_state.compress_stream, pvar->ssh_state.compression_level) != Z_OK) {\r\n\t\tUTIL_get_lang_msg(\"MSG_SSH_SETUP_COMP_ERROR\", pvar,\r\n\t\t                  \"An error occurred while setting up compression.\\n\"\r\n\t\t                  \"The connection will close.\");\r\n\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\treturn;\r\n\t} else {\r\n\t\t// SSH2\ufffd\u0142\u0348\ufffd\ufffdk\ufffdE\ufffdW\ufffdJ\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdSSH1\ufffd\u0182\u0355\u0282\u024ds\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\ufffd\ufffdL\ufffdt\ufffd\ufffd\ufffdO\ufffd\u0357\ufffd\ufffd\u0182\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffdB(2005.7.9 yutaka)\r\n\t\tif (SSHv2(pvar)) {\r\n\t\t\tpvar->ssh_state.compressing = FALSE;\r\n\t\t} else {\r\n\t\t\tpvar->ssh_state.compressing = TRUE;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstatic void enable_recv_compression(PTInstVar pvar)\r\n{\r\n\tstatic int initialize = 0;\r\n\r\n\tif (initialize) {\r\n\t\tdeflateEnd(&pvar->ssh_state.decompress_stream);\r\n\t}\r\n\tinitialize = 1;\r\n\r\n\tpvar->ssh_state.decompress_stream.zalloc = NULL;\r\n\tpvar->ssh_state.decompress_stream.zfree = NULL;\r\n\tpvar->ssh_state.decompress_stream.opaque = NULL;\r\n\tif (inflateInit(&pvar->ssh_state.decompress_stream) != Z_OK) {\r\n\t\tdeflateEnd(&pvar->ssh_state.compress_stream);\r\n\t\tUTIL_get_lang_msg(\"MSG_SSH_SETUP_COMP_ERROR\", pvar,\r\n\t\t                  \"An error occurred while setting up compression.\\n\"\r\n\t\t                  \"The connection will close.\");\r\n\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\treturn;\r\n\t} else {\r\n\t\t// SSH2\ufffd\u0142\u0348\ufffd\ufffdk\ufffdE\ufffdW\ufffdJ\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdSSH1\ufffd\u0182\u0355\u0282\u024ds\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\ufffd\ufffdL\ufffdt\ufffd\ufffd\ufffdO\ufffd\u0357\ufffd\ufffd\u0182\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffdB(2005.7.9 yutaka)\r\n\t\tif (SSHv2(pvar)) {\r\n\t\t\tpvar->ssh_state.decompressing = FALSE;\r\n\t\t} else {\r\n\t\t\tpvar->ssh_state.decompressing = TRUE;\r\n\t\t}\r\n\r\n\t\tbuf_ensure_size(&pvar->ssh_state.postdecompress_inbuf, &pvar->ssh_state.postdecompress_inbuflen, 1000);\r\n\t}\r\n}\r\n\r\nstatic void enable_compression(PTInstVar pvar)\r\n{\r\n\tenable_send_compression(pvar);\r\n\tenable_recv_compression(pvar);\r\n\r\n\t// SSH2\ufffd\u0142\u0348\ufffd\ufffdk\ufffdE\ufffdW\ufffdJ\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdSSH1\ufffd\u0182\u0355\u0282\u024ds\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\ufffd\ufffdL\ufffdt\ufffd\ufffd\ufffdO\ufffd\u0357\ufffd\ufffd\u0182\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffdB(2005.7.9 yutaka)\r\n\tif (SSHv2(pvar)) {\r\n\t\tpvar->ssh_state.compressing = FALSE;\r\n\t\tpvar->ssh_state.decompressing = FALSE;\r\n\t}\r\n}\r\n\r\nstatic BOOL handle_enable_compression(PTInstVar pvar)\r\n{\r\n\tenable_compression(pvar);\r\n\tprep_forwarding(pvar);\r\n\treturn FALSE;\r\n}\r\n\r\nstatic BOOL handle_disable_compression(PTInstVar pvar)\r\n{\r\n\tprep_forwarding(pvar);\r\n\treturn FALSE;\r\n}\r\n\r\nstatic void prep_compression(PTInstVar pvar)\r\n{\r\n\tif (pvar->session_settings.CompressionLevel > 0) {\r\n\t\t// added if statement (2005.7.10 yutaka)\r\n\t\tif (SSHv1(pvar)) {\r\n\t\t\tstatic const int msgs[] = { SSH_SMSG_SUCCESS, SSH_SMSG_FAILURE };\r\n\t\t\tstatic const SSHPacketHandler handlers[] = { handle_enable_compression, handle_disable_compression };\r\n\r\n\t\t\tunsigned char *outmsg = begin_send_packet(pvar, SSH_CMSG_REQUEST_COMPRESSION, 4);\r\n\r\n\t\t\tset_uint32(outmsg, pvar->session_settings.CompressionLevel);\r\n\t\t\tfinish_send_packet(pvar);\r\n\r\n\t\t\tenque_handlers(pvar, 2, msgs, handlers);\r\n\t\t}\r\n\r\n\t\tpvar->ssh_state.compression_level = pvar->session_settings.CompressionLevel;\r\n\r\n\t} else {\r\n\t\t// added if statement (2005.7.10 yutaka)\r\n\t\tif (SSHv1(pvar)) {\r\n\t\t\tprep_forwarding(pvar);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstatic void enque_simple_auth_handlers(PTInstVar pvar)\r\n{\r\n\tstatic const int msgs[] = { SSH_SMSG_SUCCESS, SSH_SMSG_FAILURE };\r\n\tstatic const SSHPacketHandler handlers[] = { handle_auth_success, handle_auth_failure };\r\n\r\n\tenque_handlers(pvar, 2, msgs, handlers);\r\n}\r\n\r\nstatic BOOL handle_rsa_challenge(PTInstVar pvar)\r\n{\r\n\tint challenge_bytes;\r\n\r\n\tif (!grab_payload(pvar, 2)) {\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tchallenge_bytes = get_mpint_len(pvar, 0);\r\n\r\n\tif (grab_payload(pvar, challenge_bytes)) {\r\n\t\tunsigned char *outmsg = begin_send_packet(pvar, SSH_CMSG_AUTH_RSA_RESPONSE, 16);\r\n\r\n\t\t// rhosts\ufffdF\ufffd\ufffd(SSH1)\ufffd\ufffd\ufffd\u0142\ufffd\ufffd\ufffd\u60a4\ufffd\ufffd SSH_AUTH_RHOSTS_RSA \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0252\u01c9\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\tif (pvar->auth_state.cur_cred.method == SSH_AUTH_RSA ||\r\n\t\t\tpvar->auth_state.cur_cred.method == SSH_AUTH_RHOSTS_RSA\r\n\t\t\t) {\r\n\t\t\tif (CRYPT_generate_RSA_challenge_response\r\n\t\t\t\t(pvar, pvar->ssh_state.payload + 2, challenge_bytes, outmsg)) {\r\n\r\n\t\t\t\t// \ufffdZ\ufffdb\ufffdV\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0243p\ufffdX\ufffd\ufffd\ufffd[\ufffdh\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffd\ud8cb\udd42\ufffd\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\ufffd\ufffd\ufffd\ufffd\u0142\u0303\ufffd\ufffd\\\ufffd[\ufffdX\ufffd\ufffd\ufffd\ufffd\u0342\ufffd\u07c2\ufffdB\r\n\t\t\t\t// socket close\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\ufffd\ufffd\u030a\u0590\ufffd\ufffd\u034c\u0102\u0382\ufffd\u0102\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\ufffd\ufffd\u0502\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB(2005.4.8 yutaka)\r\n\t\t\t\t//AUTH_destroy_cur_cred(pvar);\r\n\r\n\t\t\t\tfinish_send_packet(pvar);\r\n\r\n\t\t\t\tenque_simple_auth_handlers(pvar);\r\n\t\t\t} else {\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_DECRYPT_RSA_ERROR\", pvar,\r\n\t\t\t\t\t\t\t\t  \"An error occurred while decrypting the RSA challenge.\\n\"\r\n\t\t\t\t\t\t\t\t  \"Perhaps the key file is corrupted.\");\r\n\t\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (pvar->auth_state.cur_cred.method == SSH_AUTH_PAGEANT) {\r\n\t\t\tint server_key_bits;\r\n\t\t\tint host_key_bits;\r\n\t\t\tint server_key_bytes;\r\n\t\t\tint host_key_bytes;\r\n\t\t\tint session_buf_len;\r\n\t\t\tchar *session_buf;\r\n\t\t\tunsigned char session_id[16];\r\n\r\n\t\t\tunsigned char *hash;\r\n\t\t\tint pubkeylen, hashlen;\r\n\t\t\tBIGNUM *server_n, *host_n;\r\n\r\n\t\t\tRSA_get0_key(pvar->crypt_state.server_key.RSA_key, &server_n, NULL, NULL);\r\n\t\t\tRSA_get0_key(pvar->crypt_state.host_key.RSA_key, &host_n, NULL, NULL);\r\n\t\t\tserver_key_bits = BN_num_bits(server_n);\r\n\t\t\thost_key_bits = BN_num_bits(host_n);\r\n\t\t\tserver_key_bytes = (server_key_bits + 7) / 8;\r\n\t\t\thost_key_bytes = (host_key_bits + 7) / 8;\r\n\t\t\tsession_buf_len = server_key_bytes + host_key_bytes + 8;\r\n\t\t\tsession_buf = (char *) malloc(session_buf_len);\r\n\r\n\t\t\t/* Pageant \ufffd\u0243n\ufffdb\ufffdV\ufffd\ufffd\ufffd\ufffd\ufffdv\ufffdZ\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u70a4 */\r\n\t\t\t// \ufffd\ufffd\ufffdJ\ufffd\ufffd\ufffd\u0312\ufffd\ufffd\ufffd\r\n\t\t\tpubkeylen = putty_get_ssh1_keylen(pvar->pageant_curkey, pvar->pageant_keylistlen);\r\n\t\t\t// \ufffdZ\ufffdb\ufffdV\ufffd\ufffd\ufffd\ufffdID\ufffd\ufffd\ufffd\uc42c\r\n\t\t\tBN_bn2bin(host_n, session_buf);\r\n\t\t\tBN_bn2bin(server_n, session_buf + host_key_bytes);\r\n\t\t\tmemcpy(session_buf + server_key_bytes + host_key_bytes, pvar->crypt_state.server_cookie, 8);\r\n\t\t\tMD5(session_buf, session_buf_len, session_id);\r\n\t\t\t// \ufffdn\ufffdb\ufffdV\ufffd\ufffd\ufffd\ufffd\ufffd\udaca\udfce\ufffd\ufffd\r\n\t\t\thash = putty_hash_ssh1_challenge(pvar->pageant_curkey,\r\n\t\t\t                                 pubkeylen,\r\n\t\t\t                                 pvar->ssh_state.payload,\r\n\t\t\t                                 challenge_bytes + 2,\r\n\t\t\t                                 session_id,\r\n\t\t\t                                 &hashlen);\r\n\r\n\t\t\t// \ufffdn\ufffdb\ufffdV\ufffd\ufffd\ufffd\ud805\uddd0M\r\n\t\t\tmemcpy(outmsg, hash, 16);\r\n\t\t\tfree(hash);\r\n\r\n\t\t\tfinish_send_packet(pvar);\r\n\r\n\t\t\tenque_simple_auth_handlers(pvar);\r\n\t\t}\r\n\t}\r\n\r\n\treturn FALSE;\r\n}\r\n\r\nstatic void try_send_credentials(PTInstVar pvar)\r\n{\r\n\tBIGNUM *e, *n;\r\n\r\n\tif ((pvar->ssh_state.status_flags & STATUS_DONT_SEND_CREDENTIALS) == 0) {\r\n\t\tAUTHCred *cred = AUTH_get_cur_cred(pvar);\r\n\t\tstatic const int RSA_msgs[] =\r\n\t\t\t{ SSH_SMSG_AUTH_RSA_CHALLENGE, SSH_SMSG_FAILURE };\r\n\t\tstatic const SSHPacketHandler RSA_handlers[]\r\n\t\t= { handle_rsa_challenge, handle_rsa_auth_refused };\r\n\t\tstatic const int TIS_msgs[] =\r\n\t\t\t{ SSH_SMSG_AUTH_TIS_CHALLENGE, SSH_SMSG_FAILURE };\r\n\t\tstatic const SSHPacketHandler TIS_handlers[]\r\n\t\t= { handle_TIS_challenge, handle_auth_failure };\r\n\r\n\t\t// SSH2\ufffd\u030f\ua347\ufffd\u0348\u0209\ufffd\ufffd\u030f\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdX\ufffdL\ufffdb\ufffdv\r\n\t\tif (SSHv2(pvar))\r\n\t\t\tgoto skip_ssh2;\r\n\r\n\t\tswitch (cred->method) {\r\n\t\tcase SSH_AUTH_NONE:\r\n\t\t\treturn;\r\n\t\tcase SSH_AUTH_PASSWORD:{\r\n\t\t\t\tint len = strlen(cred->password);\r\n\t\t\t\tunsigned char *outmsg =\r\n\t\t\t\t\tbegin_send_packet(pvar, SSH_CMSG_AUTH_PASSWORD,\r\n\t\t\t\t\t                  4 + len);\r\n\r\n\t\t\t\tlogputs(LOG_LEVEL_VERBOSE, \"Trying PASSWORD authentication...\");\r\n\r\n\t\t\t\tset_uint32(outmsg, len);\r\n\t\t\t\tmemcpy(outmsg + 4, cred->password, len);\r\n\r\n\t\t\t\t// \ufffdZ\ufffdb\ufffdV\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0243p\ufffdX\ufffd\ufffd\ufffd[\ufffdh\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffd\ud8cb\udd42\ufffd\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\ufffd\ufffd\ufffd\ufffd\u0142\u0303\ufffd\ufffd\\\ufffd[\ufffdX\ufffd\ufffd\ufffd\ufffd\u0342\ufffd\u07c2\ufffdB\r\n\t\t\t\t// socket close\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\ufffd\ufffd\u030a\u0590\ufffd\ufffd\u034c\u0102\u0382\ufffd\u0102\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\ufffd\ufffd\u0502\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB(2005.4.8 yutaka)\r\n\t\t\t\t//AUTH_destroy_cur_cred(pvar);\r\n\r\n\t\t\t\tenque_simple_auth_handlers(pvar);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\tcase SSH_AUTH_RHOSTS:{\r\n\t\t\t\tint len = strlen(cred->rhosts_client_user);\r\n\t\t\t\tunsigned char *outmsg =\r\n\t\t\t\t\tbegin_send_packet(pvar, SSH_CMSG_AUTH_RHOSTS, 4 + len);\r\n\r\n\t\t\t\tlogputs(LOG_LEVEL_VERBOSE, \"Trying RHOSTS authentication...\");\r\n\r\n\t\t\t\tset_uint32(outmsg, len);\r\n\t\t\t\tmemcpy(outmsg + 4, cred->rhosts_client_user, len);\r\n\t\t\t\tAUTH_destroy_cur_cred(pvar);\r\n\t\t\t\tenque_simple_auth_handlers(pvar);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\tcase SSH_AUTH_RSA:{\r\n\t\t\t\tint len;\r\n\t\t\t\tunsigned char *outmsg;\r\n\r\n\t\t\t\tRSA_get0_key(cred->key_pair->rsa, &n, NULL, NULL);\r\n\t\t\t\tlen = BN_num_bytes(n);\r\n\t\t\t\toutmsg = begin_send_packet(pvar, SSH_CMSG_AUTH_RSA, 2 + len);\r\n\r\n\t\t\t\tlogputs(LOG_LEVEL_VERBOSE, \"Trying RSA authentication...\");\r\n\r\n\t\t\t\tset_ushort16_MSBfirst(outmsg, len * 8);\r\n\t\t\t\tBN_bn2bin(n, outmsg + 2);\r\n\t\t\t\t/* don't destroy the current credentials yet */\r\n\t\t\t\tenque_handlers(pvar, 2, RSA_msgs, RSA_handlers);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\tcase SSH_AUTH_RHOSTS_RSA:{\r\n\t\t\t\tint mod_len;\r\n\t\t\t\tint name_len;\r\n\t\t\t\tint exp_len;\r\n\t\t\t\tint index;\r\n\t\t\t\tunsigned char *outmsg;\r\n\r\n\t\t\t\tRSA_get0_key(cred->key_pair->rsa, &n, &e, NULL);\r\n\t\t\t\tmod_len = BN_num_bytes(n);\r\n\t\t\t\tname_len = strlen(cred->rhosts_client_user);\r\n\t\t\t\texp_len = BN_num_bytes(e);\r\n\t\t\t\toutmsg = begin_send_packet(pvar, SSH_CMSG_AUTH_RHOSTS_RSA,\r\n\t\t\t\t\t                       12 + mod_len + name_len + exp_len);\r\n\r\n\t\t\t\tlogputs(LOG_LEVEL_VERBOSE, \"Trying RHOSTS+RSA authentication...\");\r\n\r\n\t\t\t\tset_uint32(outmsg, name_len);\r\n\t\t\t\tmemcpy(outmsg + 4, cred->rhosts_client_user, name_len);\r\n\t\t\t\tindex = 4 + name_len;\r\n\r\n\t\t\t\tset_uint32(outmsg + index, 8 * mod_len);\r\n\t\t\t\tset_ushort16_MSBfirst(outmsg + index + 4, 8 * exp_len);\r\n\t\t\t\tBN_bn2bin(e, outmsg + index + 6);\r\n\t\t\t\tindex += 6 + exp_len;\r\n\r\n\t\t\t\tset_ushort16_MSBfirst(outmsg + index, 8 * mod_len);\r\n\t\t\t\tBN_bn2bin(n, outmsg + index + 2);\r\n\t\t\t\t/* don't destroy the current credentials yet */\r\n\t\t\t\tenque_handlers(pvar, 2, RSA_msgs, RSA_handlers);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\tcase SSH_AUTH_PAGEANT:{\r\n\t\t\t\tunsigned char *outmsg;\r\n\t\t\t\tunsigned char *pubkey;\r\n\t\t\t\tint len, bn_bytes;\r\n\r\n\t\t\t\tif (pvar->pageant_keycurrent != 0) {\r\n\t\t\t\t\t// \ufffd\ufffd\ufffdO\ufffd\u030c\ufffd\ufffd\ufffd\ufffdX\ufffdL\ufffdb\ufffdv\r\n\t\t\t\t\tpvar->pageant_curkey += 4;\r\n\t\t\t\t\tlen = get_ushort16_MSBfirst(pvar->pageant_curkey);\r\n\t\t\t\t\tbn_bytes = (len + 7) / 8;\r\n\t\t\t\t\tpvar->pageant_curkey += 2 + bn_bytes;\r\n\t\t\t\t\tlen = get_ushort16_MSBfirst(pvar->pageant_curkey);\r\n\t\t\t\t\tbn_bytes = (len + 7) / 8;\r\n\t\t\t\t\tpvar->pageant_curkey += 2 + bn_bytes;\r\n\t\t\t\t\t// \ufffd\ufffd\ufffdO\ufffd\u030c\ufffd\ufffd\u0303R\ufffd\ufffd\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffdX\ufffdL\ufffdb\ufffdv\r\n\t\t\t\t\tlen = get_uint32_MSBfirst(pvar->pageant_curkey);\r\n\t\t\t\t\tpvar->pageant_curkey += 4 + len;\r\n\t\t\t\t\t// \ufffd\ufffd\ufffd\u030c\ufffd\ufffd\u0308\u0292u\ufffd\u0597\ufffd\ufffd\ufffd\r\n\t\t\t\t}\r\n\t\t\t\tpubkey = pvar->pageant_curkey + 4;\r\n\t\t\t\tlen = get_ushort16_MSBfirst(pubkey);\r\n\t\t\t\tbn_bytes = (len + 7) / 8;\r\n\t\t\t\tpubkey += 2 + bn_bytes;\r\n\t\t\t\tlen = get_ushort16_MSBfirst(pubkey);\r\n\t\t\t\tbn_bytes = (len + 7) / 8;\r\n\t\t\t\tpubkey += 2;\r\n\t\t\t\toutmsg = begin_send_packet(pvar, SSH_CMSG_AUTH_RSA, 2 + bn_bytes);\r\n\r\n\t\t\t\tlogputs(LOG_LEVEL_VERBOSE, \"Trying RSA authentication...\");\r\n\r\n\t\t\t\tset_ushort16_MSBfirst(outmsg, bn_bytes * 8);\r\n\t\t\t\tmemcpy(outmsg + 2, pubkey, bn_bytes);\r\n\t\t\t\t/* don't destroy the current credentials yet */\r\n\r\n\t\t\t\tpvar->pageant_keycurrent++;\r\n\r\n\t\t\t\tenque_handlers(pvar, 2, RSA_msgs, RSA_handlers);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\tcase SSH_AUTH_TIS:{\r\n\t\t\t\tif (cred->password == NULL) {\r\n\t\t\t\t\tunsigned char *outmsg =\r\n\t\t\t\t\t\tbegin_send_packet(pvar, SSH_CMSG_AUTH_TIS, 0);\r\n\r\n\t\t\t\t\tlogputs(LOG_LEVEL_VERBOSE, \"Trying TIS authentication...\");\r\n\t\t\t\t\tenque_handlers(pvar, 2, TIS_msgs, TIS_handlers);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tint len = strlen(cred->password);\r\n\t\t\t\t\tunsigned char *outmsg =\r\n\t\t\t\t\t\tbegin_send_packet(pvar, SSH_CMSG_AUTH_TIS_RESPONSE,\r\n\t\t\t\t\t\t                  4 + len);\r\n\r\n\t\t\t\t\tlogputs(LOG_LEVEL_VERBOSE, \"Sending TIS response\");\r\n\r\n\t\t\t\t\tset_uint32(outmsg, len);\r\n\t\t\t\t\tmemcpy(outmsg + 4, cred->password, len);\r\n\t\t\t\t\tenque_simple_auth_handlers(pvar);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tAUTH_destroy_cur_cred(pvar);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\tdefault:\r\n\t\t\tUTIL_get_lang_msg(\"MSG_SSH_UNSUPPORT_AUTH_METHOD_ERROR\", pvar,\r\n\t\t\t                  \"Internal error: unsupported authentication method\");\r\n\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfinish_send_packet(pvar);\r\n\r\nskip_ssh2:;\r\n\t\tdestroy_packet_buf(pvar);\r\n\r\n\t\tpvar->ssh_state.status_flags |= STATUS_DONT_SEND_CREDENTIALS;\r\n\t}\r\n}\r\n\r\nstatic void try_send_user_name(PTInstVar pvar)\r\n{\r\n\tif ((pvar->ssh_state.status_flags & STATUS_DONT_SEND_USER_NAME) == 0) {\r\n\t\tchar *username = AUTH_get_user_name(pvar);\r\n\r\n\t\tif (username != NULL) {\r\n\t\t\tint len = strlen(username);\r\n\t\t\tunsigned char *outmsg =\r\n\t\t\t\tbegin_send_packet(pvar, SSH_CMSG_USER, 4 + len);\r\n\t\t\tstatic const int msgs[] =\r\n\t\t\t\t{ SSH_SMSG_SUCCESS, SSH_SMSG_FAILURE };\r\n\t\t\tstatic const SSHPacketHandler handlers[]\r\n\t\t\t= { handle_noauth_success, handle_auth_required };\r\n\r\n\t\t\tset_uint32(outmsg, len);\r\n\t\t\tmemcpy(outmsg + 4, username, len);\r\n\t\t\tfinish_send_packet(pvar);\r\n\r\n\t\t\tpvar->ssh_state.status_flags |= STATUS_DONT_SEND_USER_NAME;\r\n\r\n\t\t\tlogprintf(LOG_LEVEL_VERBOSE, \"Sending user name: %s\", username);\r\n\r\n\t\t\tenque_handlers(pvar, 2, msgs, handlers);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstatic void send_session_key(PTInstVar pvar)\r\n{\r\n\tint encrypted_session_key_len;\r\n\tunsigned char *outmsg;\r\n\r\n\tif (SSHv1(pvar)) {\r\n\t\tencrypted_session_key_len =\r\n\t\t\tCRYPT_get_encrypted_session_key_len(pvar);\r\n\t}\r\n\r\n\tif (!CRYPT_choose_ciphers(pvar))\r\n\t\treturn;\r\n\r\n\tif (SSHv1(pvar)) {\r\n\t\toutmsg =\r\n\t\t\tbegin_send_packet(pvar, SSH_CMSG_SESSION_KEY,\r\n\t\t\t                  15 + encrypted_session_key_len);\r\n\t\toutmsg[0] = (unsigned char) CRYPT_get_sender_cipher(pvar);\r\n\t\tmemcpy(outmsg + 1, CRYPT_get_server_cookie(pvar), 8);\t/* antispoofing cookie */\r\n\t\toutmsg[9] = (unsigned char) (encrypted_session_key_len >> 5);\r\n\t\toutmsg[10] = (unsigned char) (encrypted_session_key_len << 3);\r\n\t\tif (!CRYPT_choose_session_key(pvar, outmsg + 11))\r\n\t\t\treturn;\r\n\t\tset_uint32(outmsg + 11 + encrypted_session_key_len,\r\n\t\t           SSH_PROTOFLAG_SCREEN_NUMBER |\r\n\t\t           SSH_PROTOFLAG_HOST_IN_FWD_OPEN);\r\n\t\tfinish_send_packet(pvar);\r\n\t}\r\n\r\n\tif (!CRYPT_start_encryption(pvar, 1, 1))\r\n\t\treturn;\r\n\tnotify_established_secure_connection(pvar);\r\n\r\n\tif (SSHv1(pvar)) {\r\n\t\tenque_handler(pvar, SSH_SMSG_SUCCESS, handle_crypt_success);\r\n\t}\r\n\r\n\tpvar->ssh_state.status_flags &= ~STATUS_DONT_SEND_USER_NAME;\r\n\r\n\tif (SSHv1(pvar)) {\r\n\t\ttry_send_user_name(pvar);\r\n\t}\r\n}\r\n\r\n/*************************\r\n   END of message handlers\r\n   ************************/\r\n\r\nvoid SSH_init(PTInstVar pvar)\r\n{\r\n\tint i;\r\n\r\n\tbuf_create(&pvar->ssh_state.outbuf, &pvar->ssh_state.outbuflen);\r\n\tbuf_create(&pvar->ssh_state.precompress_outbuf,\r\n\t           &pvar->ssh_state.precompress_outbuflen);\r\n\tbuf_create(&pvar->ssh_state.postdecompress_inbuf,\r\n\t           &pvar->ssh_state.postdecompress_inbuflen);\r\n\tpvar->ssh_state.payload = NULL;\r\n\tpvar->ssh_state.compressing = FALSE;\r\n\tpvar->ssh_state.decompressing = FALSE;\r\n\tpvar->ssh_state.status_flags =\r\n\t\tSTATUS_DONT_SEND_USER_NAME | STATUS_DONT_SEND_CREDENTIALS;\r\n\tpvar->ssh_state.payload_datalen = 0;\r\n\tpvar->ssh_state.hostname = NULL;\r\n\tpvar->ssh_state.server_ID = NULL;\r\n\tpvar->ssh_state.receiver_sequence_number = 0;\r\n\tpvar->ssh_state.sender_sequence_number = 0;\r\n\tfor (i = 0; i < NUM_ELEM(pvar->ssh_state.packet_handlers); i++) {\r\n\t\tpvar->ssh_state.packet_handlers[i] = NULL;\r\n\t}\r\n\r\n\t// for SSH2(yutaka)\r\n\tmemset(pvar->ssh2_keys, 0, sizeof(pvar->ssh2_keys));\r\n\tpvar->userauth_success = 0;\r\n\tpvar->shell_id = SSH_CHANNEL_INVALID;\r\n\tpvar->session_nego_status = 0;\r\n\tpvar->settings.ssh_protocol_version = 2;  // SSH2(default)\r\n\tpvar->kex_status = 0;\r\n\tpvar->ssh2_autologin = 0;  // autologin disabled(default)\r\n\tpvar->ask4passwd = 0; // disabled(default) (2006.9.18 maya)\r\n\tpvar->userauth_retry_count = 0;\r\n\tpvar->decomp_buffer = NULL;\r\n\tpvar->authbanner_buffer = NULL;\r\n\tpvar->ssh2_authlist = NULL; // (2007.4.27 yutaka)\r\n\tpvar->tryed_ssh2_authlist = FALSE;\r\n\tpvar->agentfwd_enable = FALSE;\r\n\tpvar->use_subsystem = FALSE;\r\n\tpvar->nosession = FALSE;\r\n\tpvar->server_sig_algs = NULL;\r\n\r\n}\r\n\r\nvoid SSH_open(PTInstVar pvar)\r\n{\r\n\tpvar->ssh_state.hostname = _strdup(pvar->ts->HostName);\r\n\tpvar->ssh_state.tcpport  = pvar->ts->TCPPort;\r\n\tpvar->ssh_state.win_cols = pvar->ts->TerminalWidth;\r\n\tpvar->ssh_state.win_rows = pvar->ts->TerminalHeight;\r\n}\r\n\r\nvoid SSH_notify_disconnecting(PTInstVar pvar, char *reason)\r\n{\r\n\tif (SSHv1(pvar)) {\r\n\t\tint len = reason == NULL ? 0 : strlen(reason);\r\n\t\tunsigned char *outmsg =\r\n\t\t\tbegin_send_packet(pvar, SSH_MSG_DISCONNECT, len + 4);\r\n\r\n\t\tset_uint32(outmsg, len);\r\n\t\tif (reason != NULL) {\r\n\t\t\tmemcpy(outmsg + 4, reason, len);\r\n\t\t}\r\n\t\tfinish_send_packet(pvar);\r\n\r\n\t} else { // for SSH2(yutaka)\r\n\t\tbuffer_t *msg;\r\n\t\tunsigned char *outmsg;\r\n\t\tchar *s;\r\n\t\tint len;\r\n\r\n\t\t// SSH2 server\ufffd\ufffddisconnect\ufffd\ufffd`\ufffd\ufffd\ufffd\ufffd\r\n\t\tmsg = buffer_init();\r\n\t\tif (msg == NULL) {\r\n\t\t\t// TODO: error check\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbuffer_put_int(msg, SSH2_DISCONNECT_BY_APPLICATION);\r\n\t\tbuffer_put_string(msg, reason, strlen(reason));\r\n\t\ts = \"\";\r\n\t\tbuffer_put_string(msg, s, strlen(s));\r\n\r\n\t\tlen = buffer_len(msg);\r\n\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_DISCONNECT, len);\r\n\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\tfinish_send_packet(pvar);\r\n\t\tbuffer_free(msg);\r\n\r\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_DISCONNECT was sent at SSH_notify_disconnecting().\");\r\n\t}\r\n}\r\n\r\nvoid ssh2_finish_encryption_setup(PTInstVar pvar)\r\n{\r\n\tnotify_established_secure_connection(pvar);\r\n\tpvar->ssh_state.status_flags &= ~STATUS_DONT_SEND_USER_NAME;\r\n}\r\n\r\nvoid SSH_notify_host_OK(PTInstVar pvar)\r\n{\r\n\tif ((pvar->ssh_state.status_flags & STATUS_HOST_OK) == 0) {\r\n\t\tpvar->ssh_state.status_flags |= STATUS_HOST_OK;\r\n\r\n\t\tif (SSHv1(pvar)) {\r\n\t\t\tsend_session_key(pvar);\r\n\t\t\t// \ufffd\ufffd\ufffd[\ufffdU\ufffdF\ufffd\u0602\ufffd\ufffds\ufffd\ufffd\ufffd\u0102\u60a2\ufffd^\ufffdC\ufffd~\ufffd\ufffd\ufffdO\ufffd\u0242\u0202\ufffd\ufffd\u0102\ufffd\ufffd\ufffdA\ufffdF\ufffd\u0603_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\ufffd\ufffdo\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\t\t// STATUS_HOST_OK\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdASTATUS_DONT_SEND_USER_NAME\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0202\ufffd\ufffd\u0181A\r\n\t\t\t// \ufffdF\ufffd\u0603_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\u034e\ufffd\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\u0302\u0141A\ufffd\ufffd\ufffd\u0303^\ufffdC\ufffd~\ufffd\ufffd\ufffdO\ufffd\u0156\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t\t\tAUTH_advance_to_next_cred(pvar);\r\n\t\t}\r\n\t}\r\n\r\n\tif (SSHv2(pvar)) {\r\n\t\t// SSH2_MSG_NEWKEYS \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdM\ufffd\u0202\ufffd\u0391\ufffd\ufffd\ufffd\r\n\t\tif ((pvar->kex_status & KEX_FLAG_NEWKEYS_SENT) == 0) {\r\n\t\t\tssh2_send_newkeys(pvar);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstatic void get_window_pixel_size(PTInstVar pvar, int *x, int *y)\r\n{\r\n\tRECT r;\r\n\r\n\tif (pvar->cv->HWin && GetWindowRect(pvar->cv->HWin, &r)) {\r\n\t\t*x = r.right - r.left;\r\n\t\t*y = r.bottom - r.top;\r\n\t}\r\n\telse {\r\n\t\t*x = 0;\r\n\t\t*y = 0;\r\n\t}\r\n\r\n\treturn;\r\n}\r\n\r\nvoid SSH_notify_win_size(PTInstVar pvar, int cols, int rows)\r\n{\r\n\tint x, y;\r\n\r\n\tpvar->ssh_state.win_cols = cols;\r\n\tpvar->ssh_state.win_rows = rows;\r\n\r\n\tget_window_pixel_size(pvar, &x, &y);\r\n\r\n\tif (SSHv1(pvar)) {\r\n\t\tif (get_handler(pvar, SSH_SMSG_STDOUT_DATA) == handle_data) {\r\n\t\t\tunsigned char *outmsg =\r\n\t\t\t\tbegin_send_packet(pvar, SSH_CMSG_WINDOW_SIZE, 16);\r\n\r\n\t\t\tset_uint32(outmsg, rows);     // window height (characters)\r\n\t\t\tset_uint32(outmsg + 4, cols); // window width  (characters)\r\n\t\t\tset_uint32(outmsg + 8, x);    // window width  (pixels)\r\n\t\t\tset_uint32(outmsg + 12, y);   // window height (pixels)\r\n\t\t\tfinish_send_packet(pvar);\r\n\t\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: sending SSH_CMSG_WINDOW_SIZE. \"\r\n\t\t\t          \"cols: %d, rows: %d, x: %d, y: %d\", __FUNCTION__, cols, rows, x, y);\r\n\t\t}\r\n\r\n\t} else if (SSHv2(pvar)) {\r\n\t\t// \ufffd^\ufffd[\ufffd~\ufffdi\ufffd\ufffd\ufffdT\ufffdC\ufffdY\ufffd\u03cdX\ufffd\u0292m\ufffd\u0312\u01c9\ufffd (2005.1.4 yutaka)\r\n\t\t// SSH2\ufffd\ufffd\ufffd\u01c2\ufffd\ufffd\ufffd\ufffd\u0303`\ufffdF\ufffdb\ufffdN\ufffd\ufffd\ufffds\ufffd\ufffd\ufffdB(2005.1.5 yutaka)\r\n\t\tbuffer_t *msg;\r\n\t\tchar *req_type = \"window-change\";\r\n\t\tunsigned char *outmsg;\r\n\t\tint len;\r\n\t\tChannel_t *c;\r\n\r\n\t\tc = ssh2_channel_lookup(pvar->shell_id);\r\n\t\tif (c == NULL) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: shell channel not found.\", __FUNCTION__);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (c->remote_id == SSH_CHANNEL_INVALID) {\r\n\t\t\t// \ufffd\ufffd\ufffd\u030f\udaef\udd42\u0354F\ufffd\u060a\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0243E\ufffdB\ufffd\ufffd\ufffdh\ufffdE\ufffdT\ufffdC\ufffdY\ufffd\ufffd\u03cdX\ufffd\ufffd\ufffd\ufffd\u0194\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\t\t// \ufffd\u0702\ufffd\ufffdV\ufffdF\ufffd\ufffd\ufffd\u0303`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\u0251\u0382\ufffd\ufffd\ufffd SSH_MSG_OPEN_CONFIRMATION \ufffd\ufffd\ufffd\udaca\udfc2\u0102\ufffd\ufffd\u0202\ufffd\ufffd\u0302\u0141A\r\n\t\t\t// \ufffd\ufffd\ufffd\u8464\ufffd\u0303`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\u050d\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\u0302\ufffd window-change \ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd\u0351\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: remote shell channel number is unknown.\", __FUNCTION__);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tmsg = buffer_init();\r\n\t\tif (msg == NULL) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbuffer_put_int(msg, c->remote_id);\r\n\t\tbuffer_put_string(msg, req_type, strlen(req_type));\r\n\t\tbuffer_put_char(msg, 0);    // want_reply\r\n\t\tbuffer_put_int(msg, cols);  // columns\r\n\t\tbuffer_put_int(msg, rows);  // lines\r\n\t\tbuffer_put_int(msg, x);     // window width (pixel):\r\n\t\tbuffer_put_int(msg, y);     // window height (pixel):\r\n\t\tlen = buffer_len(msg);\r\n\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_REQUEST, len);\r\n\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\tfinish_send_packet(pvar);\r\n\t\tbuffer_free(msg);\r\n\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: sending SSH2_MSG_CHANNEL_REQUEST. \"\r\n\t\t          \"local: %d, remote: %d, request-type: %s, cols: %d, rows: %d, x: %d, y: %d\", __FUNCTION__,\r\n\t\t          c->self_id, c->remote_id, req_type, cols, rows, x, y);\r\n\r\n\t} else {\r\n\t\t// SSH\ufffd\u0142\u0202\ufffd\ufffd\ua347\ufffd\u0349\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t}\r\n}\r\n\r\n// \ufffdu\ufffd\ufffd\ufffd[\ufffdN\ufffdM\ufffd\ufffd\ufffd\ud805\uddc2\ufffd -- RFC 4335\r\n// OpenSSH \ufffd\ufffd\"~B\"\ufffd\u0251\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n// (2010.9.27 yutaka)\r\nint SSH_notify_break_signal(PTInstVar pvar)\r\n{\r\n\tint ret = 0;\r\n\r\n\tif (SSHv2(pvar)) { // SSH2 \ufffd\u0302\u0751\u0389\ufffd\r\n\t\tbuffer_t *msg;\r\n\t\tchar *req_type = \"break\";\r\n\t\tunsigned char *outmsg;\r\n\t\tint len;\r\n\t\tChannel_t *c;\r\n\r\n\t\tc = ssh2_channel_lookup(pvar->shell_id);\r\n\t\tif (c == NULL) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: shell channel not found.\", __FUNCTION__);\r\n\t\t\tgoto error;\r\n\t\t}\r\n\t\tif (c->remote_id == SSH_CHANNEL_INVALID) {\r\n\t\t\t// \ufffdF\ufffd\u0612\ufffd\ufffd\ufffd\ufffd send break \ufffd\ufffd\ufffds\ufffd\ufffd\ufffd\u0194\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\t\t\t// \ufffd\u0702\ufffd\ufffdV\ufffdF\ufffd\ufffd\ufffd\u0303`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\u0251\u0382\ufffd\ufffd\ufffd SSH_MSG_OPEN_CONFIRMATION \ufffd\ufffd\ufffd\udaca\udfc2\u0102\ufffd\ufffd\u0202\ufffd\ufffd\u0302\u0141A\r\n\t\t\t// \ufffd\ufffd\ufffd\u8464\ufffd\u0303`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\u050d\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\u0302\ufffd break \ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd\u0351\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: remote shell channel number is unknown.\", __FUNCTION__);\r\n\t\t\tgoto error;\r\n\t\t}\r\n\r\n\t\tmsg = buffer_init();\r\n\t\tif (msg == NULL) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\tgoto error;\r\n\t\t}\r\n\t\tbuffer_put_int(msg, c->remote_id);\r\n\t\tbuffer_put_string(msg, req_type, strlen(req_type));\r\n\t\tbuffer_put_char(msg, 0);  // want_reply\r\n\t\tbuffer_put_int(msg, 1000);  // break-length (msec)\r\n\t\tlen = buffer_len(msg);\r\n\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_REQUEST, len);\r\n\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\tfinish_send_packet(pvar);\r\n\t\tbuffer_free(msg);\r\n\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: sending SSH2_MSG_CHANNEL_REQUEST. \"\r\n\t\t          \"local: %d, remote: %d, request-type: %s, break-length: %d\", __FUNCTION__,\r\n\t\t          c->self_id, c->remote_id, req_type, 1000);\r\n\r\n\t\tret = 1;\r\n\t}\r\n\r\nerror:\r\n\treturn (ret);\r\n}\r\n\r\nunsigned int SSH_get_min_packet_size(PTInstVar pvar)\r\n{\r\n\tif (SSHv1(pvar)) {\r\n\t\treturn 12;\r\n\t} else {\r\n\t\treturn max(16, CRYPT_get_decryption_block_size(pvar));\r\n\t}\r\n}\r\n\r\n/* data is guaranteed to be at least SSH_get_min_packet_size bytes long\r\n   at least 5 bytes must be decrypted */\r\nvoid SSH_predecrypt_packet(PTInstVar pvar, char *data)\r\n{\r\n\tif (SSHv2(pvar)) {\r\n\t\tCRYPT_decrypt(pvar, data, get_predecryption_amount(pvar));\r\n\t}\r\n}\r\n\r\nunsigned int SSH_get_clear_MAC_size(PTInstVar pvar)\r\n{\r\n\tif (SSHv1(pvar)) {\r\n\t\treturn 0;\r\n\t} else {\r\n\t\treturn CRYPT_get_receiver_MAC_size(pvar);\r\n\t}\r\n}\r\n\r\nunsigned int SSH_get_authdata_size(PTInstVar pvar, int direction)\r\n{\r\n\tif (SSHv1(pvar)) {\r\n\t\treturn 0;\r\n\t}\r\n\telse {\r\n\t\tstruct Mac *mac = &pvar->ssh2_keys[direction].mac;\r\n\t\tstruct Enc *enc = &pvar->ssh2_keys[direction].enc;\r\n\r\n\t\tif (enc && enc->auth_len > 0) {\r\n\t\t\t// AEAD\r\n\t\t\treturn enc->auth_len;\r\n\t\t}\r\n\t\telse if (mac && mac->enabled) {\r\n\t\t\treturn mac->mac_len;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid SSH_notify_user_name(PTInstVar pvar)\r\n{\r\n\ttry_send_user_name(pvar);\r\n}\r\n\r\nvoid SSH_notify_cred(PTInstVar pvar)\r\n{\r\n\ttry_send_credentials(pvar);\r\n}\r\n\r\nvoid SSH_send(PTInstVar pvar, unsigned char const *buf, unsigned int buflen)\r\n{\r\n\t// RAW\ufffdp\ufffdP\ufffdb\ufffdg\ufffd_\ufffd\ufffd\ufffdv\ufffd\ufffd\u01c9\ufffd (2008.8.15 yutaka)\r\n\tif (LogLevel(pvar, LOG_LEVEL_SSHDUMP)) {\r\n\t\tinit_memdump();\r\n\t\tpush_memdump(\"SSH sending packet\", \"SSH_send\", (char *)buf, buflen);\r\n\t}\r\n\r\n\tif (SSHv1(pvar)) {\r\n\t\tif (get_handler(pvar, SSH_SMSG_STDOUT_DATA) != handle_data) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\twhile (buflen > 0) {\r\n\t\t\tint len =\r\n\t\t\t\tbuflen >\r\n\t\t\t\tSSH_MAX_SEND_PACKET_SIZE ? SSH_MAX_SEND_PACKET_SIZE : buflen;\r\n\t\t\tunsigned char *outmsg =\r\n\t\t\t\tbegin_send_packet(pvar, SSH_CMSG_STDIN_DATA, 4 + len);\r\n\r\n\t\t\tset_uint32(outmsg, len);\r\n\r\n\t\t\tif (pvar->ssh_state.compressing) {\r\n\t\t\t\tbuf_ensure_size(&pvar->ssh_state.outbuf,\r\n\t\t\t\t                &pvar->ssh_state.outbuflen,\r\n\t\t\t\t                len + (len >> 6) + 50);\r\n\t\t\t\tpvar->ssh_state.compress_stream.next_in =\r\n\t\t\t\t\tpvar->ssh_state.precompress_outbuf;\r\n\t\t\t\tpvar->ssh_state.compress_stream.avail_in = 5;\r\n\t\t\t\tpvar->ssh_state.compress_stream.next_out =\r\n\t\t\t\t\tpvar->ssh_state.outbuf + 12;\r\n\t\t\t\tpvar->ssh_state.compress_stream.avail_out =\r\n\t\t\t\t\tpvar->ssh_state.outbuflen - 12;\r\n\r\n\t\t\t\tif (deflate(&pvar->ssh_state.compress_stream, Z_NO_FLUSH) != Z_OK) {\r\n\t\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_COMP_ERROR\", pvar,\r\n\t\t\t\t\t\t\t\t\t  \"Error compressing packet data\");\r\n\t\t\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tpvar->ssh_state.compress_stream.next_in =\r\n\t\t\t\t\t(unsigned char *) buf;\r\n\t\t\t\tpvar->ssh_state.compress_stream.avail_in = len;\r\n\r\n\t\t\t\tif (deflate(&pvar->ssh_state.compress_stream, Z_SYNC_FLUSH) != Z_OK) {\r\n\t\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_COMP_ERROR\", pvar,\r\n\t\t\t\t\t                  \"Error compressing packet data\");\r\n\t\t\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tmemcpy(outmsg + 4, buf, len);\r\n\t\t\t}\r\n\r\n\t\t\tfinish_send_packet_special(pvar, 1);\r\n\r\n\t\t\tbuflen -= len;\r\n\t\t\tbuf += len;\r\n\t\t}\r\n\r\n\t} else { // for SSH2(yutaka)\r\n\t\tChannel_t *c = ssh2_channel_lookup(pvar->shell_id);\r\n\t\tif (c == NULL || c->remote_id == SSH_CHANNEL_INVALID) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: shell channel not found.\", __FUNCTION__);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tSSH2_send_channel_data(pvar, c, (unsigned char *)buf, buflen, 0);\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\nint SSH_extract_payload(PTInstVar pvar, unsigned char *dest, int len)\r\n{\r\n\tint num_bytes = pvar->ssh_state.payload_datalen;\r\n\r\n\tif (num_bytes > len) {\r\n\t\tnum_bytes = len;\r\n\t}\r\n\r\n\tif (!pvar->ssh_state.decompressing) {\r\n\t\tmemcpy(dest,\r\n\t\t       pvar->ssh_state.payload + pvar->ssh_state.payload_datastart,\r\n\t\t       num_bytes);\r\n\t\tpvar->ssh_state.payload_datastart += num_bytes;\r\n\t} else if (num_bytes > 0) {\r\n\t\tpvar->ssh_state.decompress_stream.next_out = dest;\r\n\t\tpvar->ssh_state.decompress_stream.avail_out = num_bytes;\r\n\r\n\t\tif (inflate(&pvar->ssh_state.decompress_stream, Z_SYNC_FLUSH) != Z_OK) {\r\n\t\t\tUTIL_get_lang_msg(\"MSG_SSH_INVALID_COMPDATA_ERROR\", pvar,\r\n\t\t\t                  \"Invalid compressed data in received packet\");\r\n\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\r\n\tpvar->ssh_state.payload_datalen -= num_bytes;\r\n\r\n\treturn num_bytes;\r\n}\r\n\r\nvoid SSH_get_compression_info(PTInstVar pvar, char *dest, int len)\r\n{\r\n\tchar buf[1024];\r\n\tchar buf2[1024];\r\n\r\n\t// added support of SSH2 packet compression (2005.7.10 yutaka)\r\n\t// support of \"Compression delayed\" (2006.6.23 maya)\r\n\tif (pvar->ssh_state.compressing ||\r\n\t\tpvar->ctos_compression == COMP_ZLIB ||\r\n\t\tpvar->ctos_compression == COMP_DELAYED && pvar->userauth_success) {\r\n\t\tunsigned long total_in = pvar->ssh_state.compress_stream.total_in;\r\n\t\tunsigned long total_out =\r\n\t\t\tpvar->ssh_state.compress_stream.total_out;\r\n\r\n\t\tif (total_out > 0) {\r\n\t\t\tUTIL_get_lang_msgU8(\"DLG_ABOUT_COMP_INFO\", pvar,\r\n\t\t\t\t\t\t\t\t\"level %d; ratio %.1f (%ld:%ld)\");\r\n\t\t\t_snprintf_s(buf, sizeof(buf), _TRUNCATE, pvar->UIMsg,\r\n\t\t\t            pvar->ssh_state.compression_level,\r\n\t\t\t            ((double) total_in) / total_out, total_in,\r\n\t\t\t            total_out);\r\n\t\t} else {\r\n\t\t\tUTIL_get_lang_msgU8(\"DLG_ABOUT_COMP_INFO2\", pvar, \"level %d\");\r\n\t\t\t_snprintf_s(buf, sizeof(buf), _TRUNCATE, pvar->UIMsg,\r\n\t\t\t            pvar->ssh_state.compression_level);\r\n\t\t}\r\n\t} else {\r\n\t\tUTIL_get_lang_msgU8(\"DLG_ABOUT_COMP_NONE\", pvar, \"none\");\r\n\t\tstrncpy_s(buf, sizeof(buf), pvar->UIMsg, _TRUNCATE);\r\n\t}\r\n\r\n\t// support of \"Compression delayed\" (2006.6.23 maya)\r\n\tif (pvar->ssh_state.decompressing ||\r\n\t\tpvar->stoc_compression == COMP_ZLIB ||\r\n\t\tpvar->stoc_compression == COMP_DELAYED && pvar->userauth_success) {\r\n\t\tunsigned long total_in =\r\n\t\t\tpvar->ssh_state.decompress_stream.total_in;\r\n\t\tunsigned long total_out =\r\n\t\t\tpvar->ssh_state.decompress_stream.total_out;\r\n\r\n\t\tif (total_in > 0) {\r\n\t\t\tUTIL_get_lang_msgU8(\"DLG_ABOUT_COMP_INFO\", pvar,\r\n\t\t\t\t\t\t\t\t\"level %d; ratio %.1f (%ld:%ld)\");\r\n\t\t\t_snprintf_s(buf2, sizeof(buf2), _TRUNCATE, pvar->UIMsg,\r\n\t\t\t            pvar->ssh_state.compression_level,\r\n\t\t\t            ((double) total_out) / total_in, total_out,\r\n\t\t\t            total_in);\r\n\t\t} else {\r\n\t\t\tUTIL_get_lang_msgU8(\"DLG_ABOUT_COMP_INFO2\", pvar, \"level %d\");\r\n\t\t\t_snprintf_s(buf2, sizeof(buf2), _TRUNCATE, pvar->UIMsg,\r\n\t\t\t            pvar->ssh_state.compression_level);\r\n\t\t}\r\n\t} else {\r\n\t\tUTIL_get_lang_msgU8(\"DLG_ABOUT_COMP_NONE\", pvar, \"none\");\r\n\t\tstrncpy_s(buf2, sizeof(buf2), pvar->UIMsg, _TRUNCATE);\r\n\t}\r\n\r\n\tUTIL_get_lang_msgU8(\"DLG_ABOUT_COMP_UPDOWN\", pvar,\r\n\t\t\t\t\t\t\"Upstream %s; Downstream %s\");\r\n\t_snprintf_s(dest, len, _TRUNCATE, pvar->UIMsg, buf, buf2);\r\n}\r\n\r\nvoid SSH_get_server_ID_info(PTInstVar pvar, char *dest, int len)\r\n{\r\n\tstrncpy_s(dest, len,\r\n\t          pvar->ssh_state.server_ID == NULL ? \"Unknown\"\r\n\t                                            : pvar->ssh_state.server_ID,\r\n\t          _TRUNCATE);\r\n}\r\n\r\nvoid SSH_get_protocol_version_info(PTInstVar pvar, char *dest,\r\n                                   int len)\r\n{\r\n\tif (pvar->protocol_major == 0) {\r\n\t\tstrncpy_s(dest, len, \"Unknown\", _TRUNCATE);\r\n\t} else {\r\n\t\t_snprintf_s(dest, len, _TRUNCATE, \"%d.%d\", pvar->protocol_major,\r\n\t\t            pvar->protocol_minor);\r\n\t}\r\n}\r\n\r\nvoid SSH_get_mac_info(PTInstVar pvar, char *dest, int len)\r\n{\r\n\tUTIL_get_lang_msgU8(\"DLG_ABOUT_MAC_INFO\", pvar,\r\n\t\t\t\t\t\t\"%s to server, %s from server\");\r\n\t_snprintf_s(dest, len, _TRUNCATE, pvar->UIMsg,\r\n\t            get_ssh2_mac_name(pvar->macs[MODE_OUT]),\r\n\t            get_ssh2_mac_name(pvar->macs[MODE_IN]));\r\n}\r\n\r\nvoid SSH_end(PTInstVar pvar)\r\n{\r\n\tint i;\r\n\tint mode;\r\n\r\n\tfor (i = 0; i < 256; i++) {\r\n\t\tSSHPacketHandlerItem *first_item =\r\n\t\t\tpvar->ssh_state.packet_handlers[i];\r\n\r\n\t\tif (first_item != NULL) {\r\n\t\t\tSSHPacketHandlerItem *item = first_item;\r\n\r\n\t\t\tdo {\r\n\t\t\t\tSSHPacketHandlerItem *cur_item = item;\r\n\r\n\t\t\t\titem = item->next_for_message;\r\n\t\t\t\tfree(cur_item);\r\n\t\t\t} while (item != first_item);\r\n\t\t}\r\n\t\tpvar->ssh_state.packet_handlers[i] = NULL;\r\n\t}\r\n\r\n\tfree(pvar->ssh_state.hostname);\r\n\tpvar->ssh_state.hostname = NULL;\r\n\tfree(pvar->ssh_state.server_ID);\r\n\tpvar->ssh_state.server_ID = NULL;\r\n\tbuf_destroy(&pvar->ssh_state.outbuf, &pvar->ssh_state.outbuflen);\r\n\tbuf_destroy(&pvar->ssh_state.precompress_outbuf,\r\n\t            &pvar->ssh_state.precompress_outbuflen);\r\n\tbuf_destroy(&pvar->ssh_state.postdecompress_inbuf,\r\n\t            &pvar->ssh_state.postdecompress_inbuflen);\r\n\tpvar->agentfwd_enable = FALSE;\r\n\tpvar->use_subsystem = FALSE;\r\n\tpvar->nosession = FALSE;\r\n\r\n\t// support of \"Compression delayed\" (2006.6.23 maya)\r\n\tif (pvar->ssh_state.compressing ||\r\n\t\tpvar->ctos_compression == COMP_ZLIB || // add SSH2 flag (2005.7.10 yutaka)\r\n\t\tpvar->ctos_compression == COMP_DELAYED && pvar->userauth_success) {\r\n\t\tdeflateEnd(&pvar->ssh_state.compress_stream);\r\n\t\tpvar->ssh_state.compressing = FALSE;\r\n\t}\r\n\t// support of \"Compression delayed\" (2006.6.23 maya)\r\n\tif (pvar->ssh_state.decompressing ||\r\n\t\tpvar->stoc_compression == COMP_ZLIB || // add SSH2 flag (2005.7.10 yutaka)\r\n\t\tpvar->stoc_compression == COMP_DELAYED && pvar->userauth_success) {\r\n\t\tinflateEnd(&pvar->ssh_state.decompress_stream);\r\n\t\tpvar->ssh_state.decompressing = FALSE;\r\n\t}\r\n\r\n\t// SSH2\ufffd\u0303f\ufffd[\ufffd^\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd (2004.12.27 yutaka)\r\n\tif (SSHv2(pvar)) {\r\n\t\tif (pvar->kexdh) {\r\n\t\t\tDH_free(pvar->kexdh);\r\n\t\t\tpvar->kexdh = NULL;\r\n\t\t}\r\n\t\tif (pvar->ecdh_client_key) {\r\n\t\t\tEC_KEY_free(pvar->ecdh_client_key);\r\n\t\t\tpvar->ecdh_client_key = NULL;\r\n\t\t}\r\n\t\tmemset(pvar->server_version_string, 0, sizeof(pvar->server_version_string));\r\n\t\tmemset(pvar->client_version_string, 0, sizeof(pvar->client_version_string));\r\n\r\n\t\tif (pvar->my_kex != NULL) {\r\n\t\t\tbuffer_free(pvar->my_kex);\r\n\t\t\tpvar->my_kex = NULL;\r\n\t\t}\r\n\t\tif (pvar->peer_kex != NULL) {\r\n\t\t\tbuffer_free(pvar->peer_kex);\r\n\t\t\tpvar->peer_kex = NULL;\r\n\t\t}\r\n\r\n\t\tpvar->we_need = 0;\r\n\t\tpvar->kex_status = 0;\r\n\r\n\t\tif (pvar->session_id != NULL) {\r\n\t\t\tfree(pvar->session_id);\r\n\t\t\tpvar->session_id = NULL;\r\n\t\t}\r\n\t\tpvar->session_id_len = 0;\r\n\r\n\t\tpvar->userauth_success = 0;\r\n\t\tpvar->shell_id = SSH_CHANNEL_INVALID;\r\n\t\tpvar->session_nego_status = 0;\r\n\r\n\t\tpvar->ssh_heartbeat_tick = 0;\r\n\r\n\t\tif (pvar->decomp_buffer != NULL) {\r\n\t\t\tbuffer_free(pvar->decomp_buffer);\r\n\t\t\tpvar->decomp_buffer = NULL;\r\n\t\t}\r\n\r\n\t\tif (pvar->authbanner_buffer != NULL) {\r\n\t\t\tbuffer_free(pvar->authbanner_buffer);\r\n\t\t\tpvar->authbanner_buffer = NULL;\r\n\t\t}\r\n\r\n\t\tif (pvar->ssh2_authlist != NULL) { // (2007.4.27 yutaka)\r\n\t\t\tfree(pvar->ssh2_authlist);\r\n\t\t\tpvar->ssh2_authlist = NULL;\r\n\t\t}\r\n\r\n\t\tpvar->tryed_ssh2_authlist = FALSE;\r\n\r\n\t\tfree(pvar->server_sig_algs);\r\n\t\tpvar->server_sig_algs = NULL;\r\n\r\n\t\t// add (2008.3.2 yutaka)\r\n\t\tfor (mode = 0 ; mode < MODE_MAX ; mode++) {\r\n\t\t\tif (pvar->ssh2_keys[mode].enc.iv != NULL) {\r\n\t\t\t\tfree(pvar->ssh2_keys[mode].enc.iv);\r\n\t\t\t\tpvar->ssh2_keys[mode].enc.iv = NULL;\r\n\t\t\t}\r\n\t\t\tif (pvar->ssh2_keys[mode].enc.key != NULL) {\r\n\t\t\t\tfree(pvar->ssh2_keys[mode].enc.key);\r\n\t\t\t\tpvar->ssh2_keys[mode].enc.key = NULL;\r\n\t\t\t}\r\n\t\t\tif (pvar->ssh2_keys[mode].mac.key != NULL) {\r\n\t\t\t\tfree(pvar->ssh2_keys[mode].mac.key);\r\n\t\t\t\tpvar->ssh2_keys[mode].mac.key = NULL;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid SSH2_send_channel_data(PTInstVar pvar, Channel_t *c, unsigned char *buf, unsigned int buflen, int retry)\r\n{\r\n\tbuffer_t *msg;\r\n\tunsigned char *outmsg;\r\n\tunsigned int len;\r\n\r\n\t// SSH2\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u030f\ua347\ufffd\u0341A\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ud805\uddc2\ufffd\u0202\ufffd\ufffd\u0302\u0142\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u06d1\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\r\n\tif (pvar->kex_status & KEX_FLAG_REKEYING) {\r\n\t\tssh2_channel_add_bufchain(pvar, c, buf, buflen);\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (c == NULL)\r\n\t\treturn;\r\n\r\n\t// \ufffd\ufffd\ufffdg\ufffd\ufffd\ufffdC\ufffd\u0142\u0342\u0202\ufffd\ufffdA\ufffd\u028f\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffdM\ufffd\u030d\u06c1A\ufffd\u0211O\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdf\ufffd[\ufffd^\ufffd\ufffd\r\n\t// \ufffd\ufffd\ufffd\ufffd\ufffdN\ufffdh\ufffd\ufffd\ufffdX\ufffdg\ufffd\u024ec\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\u60a4\ufffd\u0142\ufffd\ufffd\ufffd\u0381A\ufffd\ufffd\ufffdX\ufffdg\ufffd\u0316\ufffd\ufffd\ufffd\ufffd\u024cq\ufffd\ufffd\ufffdB\r\n\t// \ufffd\ufffd\ufffd\ufffd\u0242\ufffd\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffd\ufffd\ua0bd\ufffd\u60a4\ufffd\u024c\ufffd\ufffd\ufffd\ufffd\u933b\ufffd\u06c2\ufffd\ufffd\ufffd\ufffdP\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t// (2012.10.14 yutaka)\r\n\tif (retry == 0 && c->bufchain) {\r\n\t\tssh2_channel_add_bufchain(pvar, c, buf, buflen);\r\n\t\treturn;\r\n\t}\r\n\r\n\tif ((unsigned int)buflen > c->remote_window) {\r\n\t\tunsigned int offset = 0;\r\n\t\t// \ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffdf\ufffd[\ufffd^\ufffd\u0342\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u06d1\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\r\n\t\tssh2_channel_add_bufchain(pvar, c, buf + offset, buflen - offset);\r\n\t\tbuflen = offset;\r\n\t\treturn;\r\n\t}\r\n\tif (buflen > 0) {\r\n\t\tmsg = buffer_init();\r\n\t\tif (msg == NULL) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbuffer_put_int(msg, c->remote_id);\r\n\t\tbuffer_put_string(msg, (char *)buf, buflen);\r\n\r\n\t\tlen = buffer_len(msg);\r\n\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_DATA, len);\r\n\t\t//if (len + 12 >= pvar->ssh_state.outbuflen) *(int *)0 = 0;\r\n\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\tfinish_send_packet(pvar);\r\n\t\tbuffer_free(msg);\r\n\r\n\t\tlogprintf(LOG_LEVEL_SSHDUMP, \"%s: sending SSH2_MSG_CHANNEL_DATA. \"\r\n\t\t\t\t  \"local:%d remote:%d len:%d\", __FUNCTION__, c->self_id, c->remote_id, buflen);\r\n\r\n\t\t// remote window size\ufffd\u0312\ufffd\ufffd\ufffd\r\n\t\tif (buflen <= c->remote_window) {\r\n\t\t\tc->remote_window -= buflen;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tc->remote_window = 0;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/* support for port forwarding */\r\nvoid SSH_channel_send(PTInstVar pvar, int channel_num,\r\n                      uint32 remote_channel_num,\r\n                      unsigned char *buf, int len, int retry)\r\n{\r\n\tif (SSHv1(pvar)) {\r\n\t\tunsigned char *outmsg =\r\n\t\t\tbegin_send_packet(pvar, SSH_MSG_CHANNEL_DATA, 8 + len);\r\n\r\n\t\tset_uint32(outmsg, remote_channel_num);\r\n\t\tset_uint32(outmsg + 4, len);\r\n\r\n\t\tif (pvar->ssh_state.compressing) {\r\n\t\t\tbuf_ensure_size(&pvar->ssh_state.outbuf,\r\n\t\t\t                &pvar->ssh_state.outbuflen, len + (len >> 6) + 50);\r\n\t\t\tpvar->ssh_state.compress_stream.next_in =\r\n\t\t\t\tpvar->ssh_state.precompress_outbuf;\r\n\t\t\tpvar->ssh_state.compress_stream.avail_in = 9;\r\n\t\t\tpvar->ssh_state.compress_stream.next_out =\r\n\t\t\t\tpvar->ssh_state.outbuf + 12;\r\n\t\t\tpvar->ssh_state.compress_stream.avail_out =\r\n\t\t\t\tpvar->ssh_state.outbuflen - 12;\r\n\r\n\t\t\tif (deflate(&pvar->ssh_state.compress_stream, Z_NO_FLUSH) != Z_OK) {\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_COMP_ERROR\", pvar,\r\n\t\t\t\t                  \"Error compressing packet data\");\r\n\t\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tpvar->ssh_state.compress_stream.next_in =\r\n\t\t\t\t(unsigned char *) buf;\r\n\t\t\tpvar->ssh_state.compress_stream.avail_in = len;\r\n\r\n\t\t\tif (deflate(&pvar->ssh_state.compress_stream, Z_SYNC_FLUSH) !=\r\n\t\t\t\tZ_OK) {\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_COMP_ERROR\", pvar,\r\n\t\t\t\t                  \"Error compressing packet data\");\r\n\t\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tmemcpy(outmsg + 8, buf, len);\r\n\t\t}\r\n\r\n\t\tfinish_send_packet_special(pvar, 1);\r\n\r\n\t} else {\r\n\t\t// \ufffd|\ufffd[\ufffdg\ufffdt\ufffdH\ufffd\ufffd\ufffd[\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd\u0242\ufffd\ufffd\ufffd\ufffd\u0103N\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffd\ufffd\u0311\ufffd\ufffdM\ufffdv\ufffd\ufffd\ufffd\ufffd\ufffdASSH\ufffd\u0290M\ufffd\u024f\u60b9\ufffd\u0103T\ufffd[\ufffdo\ufffd\u0702\u0151\ufffd\ufffd\ufffd\u0342\ufffd\ufffd\ufffdB\r\n\t\tChannel_t *c = ssh2_local_channel_lookup(channel_num);\r\n\t\tSSH2_send_channel_data(pvar, c, buf, len, retry);\r\n\t}\r\n\r\n}\r\n\r\nvoid SSH_fail_channel_open(PTInstVar pvar, uint32 remote_channel_num)\r\n{\r\n\tif (SSHv1(pvar)) {\r\n\t\tunsigned char *outmsg =\r\n\t\t\tbegin_send_packet(pvar, SSH_MSG_CHANNEL_OPEN_FAILURE, 4);\r\n\r\n\t\tset_uint32(outmsg, remote_channel_num);\r\n\t\tfinish_send_packet(pvar);\r\n\r\n\t} else { // SSH2 (2005.6.26 yutaka)\r\n\t\tint len;\r\n\t\tChannel_t *c = NULL;\r\n\t\tbuffer_t *msg;\r\n\t\tunsigned char *outmsg;\r\n\r\n\t\tmsg = buffer_init();\r\n\t\tif (msg == NULL) {\r\n\t\t\t// TODO: error check\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbuffer_put_int(msg, remote_channel_num);\r\n\t\tbuffer_put_int(msg, SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED);\r\n\t\tbuffer_put_string(msg, \"\", 0); // description\r\n\t\tbuffer_put_string(msg, \"\", 0); // language tag\r\n\r\n\t\tlen = buffer_len(msg);\r\n\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_OPEN_FAILURE, len);\r\n\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\tfinish_send_packet(pvar);\r\n\t\tbuffer_free(msg);\r\n\r\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_CHANNEL_OPEN_FAILURE was sent at SSH_fail_channel_open().\");\r\n\t}\r\n}\r\n\r\nvoid SSH2_confirm_channel_open(PTInstVar pvar, Channel_t *c)\r\n{\r\n\tbuffer_t *msg;\r\n\tunsigned char *outmsg;\r\n\tint len;\r\n\r\n\tif (c == NULL)\r\n\t\treturn;\r\n\r\n\tmsg = buffer_init();\r\n\tif (msg == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\treturn;\r\n\t}\r\n\tbuffer_put_int(msg, c->remote_id);\r\n\tbuffer_put_int(msg, c->self_id);\r\n\tbuffer_put_int(msg, c->local_window);\r\n\tbuffer_put_int(msg, c->local_maxpacket);\r\n\r\n\tlen = buffer_len(msg);\r\n\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_OPEN_CONFIRMATION, len);\r\n\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\tfinish_send_packet(pvar);\r\n\tbuffer_free(msg);\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"SSH2_MSG_CHANNEL_OPEN_CONFIRMATION was sent at SSH_confirm_channel_open(). local:%d remote:%d\", c->self_id, c->remote_id);\r\n}\r\n\r\nvoid SSH_confirm_channel_open(PTInstVar pvar, uint32 remote_channel_num,\r\n\t\t\t\t\t\t\t  uint32 local_channel_num)\r\n{\r\n\tif (SSHv1(pvar)) {\r\n\t\tunsigned char *outmsg =\r\n\t\t\tbegin_send_packet(pvar, SSH_MSG_CHANNEL_OPEN_CONFIRMATION, 8);\r\n\r\n\t\tset_uint32(outmsg, remote_channel_num);\r\n\t\tset_uint32(outmsg + 4, local_channel_num);\r\n\t\tfinish_send_packet(pvar);\r\n\r\n\t} else {\r\n\t\tChannel_t *c;\r\n\r\n\t\t// port-forwarding(remote to local)\ufffd\u0303\ufffd\ufffd[\ufffdJ\ufffd\ufffd\ufffd\u0691\ufffd\ufffd\u0582\u0310\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdT\ufffd[\ufffdo\ufffd\u0595\u0502\ufffd\ufffdB(2005.7.2 yutaka)\r\n\t\tc = ssh2_local_channel_lookup(local_channel_num);\r\n\t\tif (c == NULL) {\r\n\t\t\t// It is sure to be successful as long as it's not a program bug either.\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tSSH2_confirm_channel_open(pvar, c);\r\n\t}\r\n}\r\n\r\nvoid SSH_channel_output_eof(PTInstVar pvar, uint32 remote_channel_num)\r\n{\r\n\tif (SSHv1(pvar)){\r\n\t\tunsigned char *outmsg =\r\n\t\t\tbegin_send_packet(pvar, SSH_MSG_CHANNEL_OUTPUT_CLOSED, 4);\r\n\r\n\t\tset_uint32(outmsg, remote_channel_num);\r\n\t\tfinish_send_packet(pvar);\r\n\r\n\t} else {\r\n\t\t// SSH2: \ufffd\ufffd\ufffd\u0242\u0202\ufffd\ufffdB\r\n\r\n\t}\r\n}\r\n\r\nvoid SSH2_channel_input_eof(PTInstVar pvar, Channel_t *c)\r\n{\r\n\tbuffer_t *msg;\r\n\tunsigned char *outmsg;\r\n\tint len;\r\n\r\n\tif (c == NULL)\r\n\t\treturn;\r\n\r\n\t// SSH2\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u030f\ua347\ufffdA\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffd\u0302\u0102\ufffdB(2005.6.21 yutaka)\r\n\tif (pvar->kex_status & KEX_FLAG_REKEYING) {\r\n\t\t// TODO: \ufffd\ufffd\ufffdz\ufffd\u0182\ufffd\ufffd\u0102\u0343p\ufffdP\ufffdb\ufffdg\ufffdj\ufffd\ufffd\ufffd\u0142\u0342\u0202\ufffd\ufffdA\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\u01c2\u074e\ufffd\ufffdx\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0182\ufffd\ufffd\ub0be\ufffd\ufffd\ufffdA\r\n\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0182\u0242\ufffd\ufffd\ufffdB\r\n\t\tlogprintf(LOG_LEVEL_INFO, \"%s: now rekeying. data is not sent.\", __FUNCTION__);\r\n\r\n\t\tc = NULL;\r\n\r\n\t\treturn;\r\n\t}\r\n\r\n\tmsg = buffer_init();\r\n\tif (msg == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\treturn;\r\n\t}\r\n\tbuffer_put_int(msg, c->remote_id);  // remote ID\r\n\r\n\tlen = buffer_len(msg);\r\n\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_EOF, len);\r\n\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\tfinish_send_packet(pvar);\r\n\tbuffer_free(msg);\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"SSH2_MSG_CHANNEL_EOF was sent at SSH2_channel_input_eof(). local:%d remote:%d\", c->self_id, c->remote_id);\r\n}\r\n\r\nvoid SSH_channel_input_eof(PTInstVar pvar, uint32 remote_channel_num, uint32 local_channel_num)\r\n{\r\n\tif (SSHv1(pvar)){\r\n\t\tunsigned char *outmsg =\r\n\t\t\tbegin_send_packet(pvar, SSH_MSG_CHANNEL_INPUT_EOF, 4);\r\n\r\n\t\tset_uint32(outmsg, remote_channel_num);\r\n\t\tfinish_send_packet(pvar);\r\n\r\n\t} else {\r\n\t\t// SSH2: \ufffd`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffdN\ufffd\ufffd\ufffd[\ufffdY\ufffd\ufffd\ufffdT\ufffd[\ufffdo\ufffd\u0592\u0292m\r\n\t\tChannel_t *c;\r\n\r\n\t\tc = ssh2_local_channel_lookup(local_channel_num);\r\n\t\tif (c == NULL)\r\n\t\t\treturn;\r\n\r\n\t\tSSH2_channel_input_eof(pvar, c);\r\n\t}\r\n}\r\n\r\nvoid SSH_request_forwarding(PTInstVar pvar, char *bind_address, int from_server_port,\r\n                            char *to_local_host, int to_local_port)\r\n{\r\n\tif (SSHv1(pvar)) {\r\n\t\tint host_len = strlen(to_local_host);\r\n\t\tunsigned char *outmsg =\r\n\t\t\tbegin_send_packet(pvar, SSH_CMSG_PORT_FORWARD_REQUEST, 12 + host_len);\r\n\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: Forwarding request (SSH1 RtoL): \"\r\n\t\t\t\t  \"remote_port=%d, to_host=%s, to_port=%d\", __FUNCTION__,\r\n\t\t\tfrom_server_port, to_local_host, to_local_port);\r\n\r\n\t\tset_uint32(outmsg, from_server_port);\r\n\t\tset_uint32(outmsg + 4, host_len);\r\n\t\tmemcpy(outmsg + 8, to_local_host, host_len);\r\n\t\tset_uint32(outmsg + 8 + host_len, to_local_port);\r\n\t\tfinish_send_packet(pvar);\r\n\r\n\t\tenque_forwarding_request_handlers(pvar);\r\n\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: sending SSH_CMSG_PORT_FORWARD_REQUEST.\"\r\n\t\t\t\t  \"remote_port=%d, to_host=%s, to_port=%d\", __FUNCTION__,\r\n\t\t\tfrom_server_port, to_local_host, to_local_port);\r\n\r\n\t} else {\r\n\t\t// SSH2 port-forwading remote to local (2005.6.21 yutaka)\r\n\t\tbuffer_t *msg;\r\n\t\tchar *req;\r\n\t\tunsigned char *outmsg;\r\n\t\tint len;\r\n\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: Forwarding request (SSH2 RtoL): \"\r\n\t\t\t\t  \"bind_addr=%s, remote_port=%d, to_host=%s, to_port=%d\", __FUNCTION__,\r\n\t\t\tbind_address, from_server_port, to_local_host, to_local_port);\r\n\r\n\t\tmsg = buffer_init();\r\n\t\tif (msg == NULL) {\r\n\t\t\t// TODO: error check\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\treq = \"tcpip-forward\";\r\n\t\tbuffer_put_string(msg, req, strlen(req)); // ctype\r\n\t\tbuffer_put_char(msg, 1);  // want reply\r\n\t\tbuffer_put_string(msg, bind_address, strlen(bind_address));\r\n\r\n\t\tbuffer_put_int(msg, from_server_port);  // listening port\r\n\r\n\t\tlen = buffer_len(msg);\r\n\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_GLOBAL_REQUEST, len);\r\n\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\tfinish_send_packet(pvar);\r\n\t\tbuffer_free(msg);\r\n\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: sending SSH2_MSG_GLOBAL_REQUEST. \"\r\n\t\t\t\t  \"request=%s, want_reply=%d, bind_address=%s, remote_port=%d\", __FUNCTION__,\r\n\t\t\treq, 1, bind_address, from_server_port);\r\n\t}\r\n}\r\n\r\nvoid SSH_cancel_request_forwarding(PTInstVar pvar, char *bind_address, int from_server_port, int reply)\r\n{\r\n\tif (SSHv2(pvar)) {\r\n\t\tbuffer_t *msg;\r\n\t\tchar *s;\r\n\t\tunsigned char *outmsg;\r\n\t\tint len;\r\n\r\n\t\tmsg = buffer_init();\r\n\t\tif (msg == NULL) {\r\n\t\t\t// TODO: error check\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\ts = \"cancel-tcpip-forward\";\r\n\t\tbuffer_put_string(msg, s, strlen(s)); // ctype\r\n\t\tbuffer_put_char(msg, reply);  // want reply\r\n\t\tbuffer_put_string(msg, bind_address, strlen(bind_address));\r\n\r\n\t\tbuffer_put_int(msg, from_server_port);  // listening port\r\n\r\n\t\tlen = buffer_len(msg);\r\n\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_GLOBAL_REQUEST, len);\r\n\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\tfinish_send_packet(pvar);\r\n\t\tbuffer_free(msg);\r\n\r\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_GLOBAL_REQUEST was sent at SSH_cancel_request_forwarding().\");\r\n\t}\r\n}\r\n\r\nvoid SSH_request_X11_forwarding(PTInstVar pvar,\r\n                                char *auth_protocol,\r\n                                unsigned char *auth_data,\r\n                                int auth_data_len, int screen_num)\r\n{\r\n\tif (SSHv1(pvar)) {\r\n\t\tint protocol_len = strlen(auth_protocol);\r\n\t\tint data_len = auth_data_len * 2;\r\n\t\tint outmsg_len = 12 + protocol_len + data_len;\r\n\t\tunsigned char *outmsg =\r\n\t\t\tbegin_send_packet(pvar, SSH_CMSG_X11_REQUEST_FORWARDING, outmsg_len);\r\n\t\tint i;\r\n\t\tchar *auth_data_ptr;\r\n\r\n\t\tset_uint32(outmsg, protocol_len);\r\n\t\tmemcpy(outmsg + 4, auth_protocol, protocol_len);\r\n\t\tset_uint32(outmsg + 4 + protocol_len, data_len);\r\n\t\tauth_data_ptr = outmsg + 8 + protocol_len;\r\n\t\tfor (i = 0; i < auth_data_len; i++) {\r\n\t\t\t_snprintf_s(auth_data_ptr + i * 2,\r\n\t\t\t            outmsg_len - ((UINT_PTR)auth_data_ptr - (UINT_PTR)outmsg) - i * 2,\r\n\t\t\t            _TRUNCATE, \"%.2x\", auth_data[i]);\r\n\t\t}\r\n\t\tset_uint32(outmsg + 8 + protocol_len + data_len, screen_num);\r\n\r\n\t\tfinish_send_packet(pvar);\r\n\r\n\t\tenque_forwarding_request_handlers(pvar);\r\n\r\n\t} else {\r\n\t\t// SSH2: X11 port-forwarding (2005.7.2 yutaka)\r\n\t\tbuffer_t *msg;\r\n\t\tchar *req_type = \"x11-req\";\r\n\t\tunsigned char *outmsg;\r\n\t\tint len;\r\n\t\tChannel_t *c;\r\n\t\tint newlen;\r\n\t\tchar *newdata;\r\n\t\tint i;\r\n\r\n\t\tmsg = buffer_init();\r\n\t\tif (msg == NULL) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tc = ssh2_channel_lookup(pvar->shell_id);\r\n\t\tif (c == NULL) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: shell channel not found.\", __FUNCTION__);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (c->remote_id == SSH_CHANNEL_INVALID) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: remote shell channel number is unknown.\", __FUNCTION__);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// making the fake data\r\n\t\tnewlen = 2 * auth_data_len + 1;\r\n\t\tnewdata = malloc(newlen);\r\n\t\tif (newdata == NULL)\r\n\t\t\treturn;\r\n\t\tfor (i = 0 ; i < auth_data_len ; i++) {\r\n\t\t\t_snprintf_s(newdata + i*2, newlen - i*2, _TRUNCATE, \"%02x\", auth_data[i]);\r\n\t\t}\r\n\t\tnewdata[newlen - 1] = '\\0';\r\n\r\n\t\tbuffer_put_int(msg, c->remote_id);\r\n\t\tbuffer_put_string(msg, req_type, strlen(req_type)); // service name\r\n\t\tbuffer_put_char(msg, 0);  // want_reply (false)\r\n\t\tbuffer_put_char(msg, 0);  // single connection\r\n\r\n\t\tbuffer_put_string(msg, auth_protocol, strlen(auth_protocol)); // protocol (\"MIT-MAGIC-COOKIE-1\")\r\n\t\tbuffer_put_string(msg, newdata, strlen(newdata)); // cookie\r\n\r\n\t\tbuffer_put_int(msg, screen_num);\r\n\r\n\t\tlen = buffer_len(msg);\r\n\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_REQUEST, len);\r\n\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\tfinish_send_packet(pvar);\r\n\t\tbuffer_free(msg);\r\n\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: sending SSH2_MSG_CHANNEL_REQUEST. \"\r\n\t\t          \"local: %d, remote: %d, request-type: %s, proto: %s, cookie: %s, screen: %d\", __FUNCTION__,\r\n\t\t          c->self_id, c->remote_id, req_type, auth_protocol, newdata, screen_num);\r\n\r\n\t\tfree(newdata);\r\n\t}\r\n\r\n}\r\n\r\nvoid SSH_open_channel(PTInstVar pvar, uint32 local_channel_num,\r\n                      char *to_remote_host, int to_remote_port,\r\n                      char *originator, unsigned short originator_port)\r\n{\r\n\tstatic const int msgs[]\r\n\t= { SSH_MSG_CHANNEL_OPEN_CONFIRMATION, SSH_MSG_CHANNEL_OPEN_FAILURE };\r\n\tstatic const SSHPacketHandler handlers[]\r\n\t= { handle_channel_open_confirmation, handle_channel_open_failure };\r\n\r\n\tint host_len = strlen(to_remote_host);\r\n\r\n\tif ((pvar->ssh_state.\r\n\t\t server_protocol_flags & SSH_PROTOFLAG_HOST_IN_FWD_OPEN) != 0) {\r\n\t\tint originator_len = strlen(originator);\r\n\t\tunsigned char *outmsg =\r\n\t\t\tbegin_send_packet(pvar, SSH_MSG_PORT_OPEN,\r\n\t\t\t                  16 + host_len + originator_len);\r\n\r\n\t\tset_uint32(outmsg, local_channel_num);\r\n\t\tset_uint32(outmsg + 4, host_len);\r\n\t\tmemcpy(outmsg + 8, to_remote_host, host_len);\r\n\t\tset_uint32(outmsg + 8 + host_len, to_remote_port);\r\n\t\tset_uint32(outmsg + 12 + host_len, originator_len);\r\n\t\tmemcpy(outmsg + 16 + host_len, originator, originator_len);\r\n\t} else {\r\n\r\n\t\tif (SSHv1(pvar)) {\r\n\t\t\tunsigned char *outmsg =\r\n\t\t\t\tbegin_send_packet(pvar, SSH_MSG_PORT_OPEN,\r\n\t\t\t\t                  12 + host_len);\r\n\r\n\t\t\tset_uint32(outmsg, local_channel_num);\r\n\t\t\tset_uint32(outmsg + 4, host_len);\r\n\t\t\tmemcpy(outmsg + 8, to_remote_host, host_len);\r\n\t\t\tset_uint32(outmsg + 8 + host_len, to_remote_port);\r\n\r\n\t\t} else {\r\n\t\t\t// SSH2 port-fowarding (2005.2.26 yutaka)\r\n\t\t\tbuffer_t *msg;\r\n\t\t\tchar *s;\r\n\t\t\tunsigned char *outmsg;\r\n\t\t\tint len;\r\n\t\t\tChannel_t *c;\r\n\r\n\t\t\t// SSH2\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u030f\ua347\ufffdA\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffd\u0302\u0102\ufffdB(2005.6.21 yutaka)\r\n\t\t\tif (pvar->kex_status & KEX_FLAG_REKEYING) {\r\n\t\t\t\t// TODO: \ufffd\ufffd\ufffdz\ufffd\u0182\ufffd\ufffd\u0102\u0343p\ufffdP\ufffdb\ufffdg\ufffdj\ufffd\ufffd\ufffd\u0142\u0342\u0202\ufffd\ufffdA\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\u01c2\u074e\ufffd\ufffdx\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0182\ufffd\ufffd\ub0be\ufffd\ufffd\ufffdA\r\n\t\t\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0182\u0242\ufffd\ufffd\ufffdB\r\n\t\t\t\tlogprintf(LOG_LEVEL_INFO, \"%s: now rekeying. channel open request is not sent.\", __FUNCTION__);\r\n\r\n\t\t\t\tc = NULL;\r\n\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// changed window size from 128KB to 32KB. (2006.3.6 yutaka)\r\n\t\t\t// changed window size from 32KB to 128KB. (2007.10.29 maya)\r\n\t\t\tc = ssh2_channel_new(CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, TYPE_PORTFWD, local_channel_num);\r\n\t\t\tif (c == NULL) {\r\n\t\t\t\t// \ufffd]\ufffd\ufffd\ufffd`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\ufffd\\\ufffdP\ufffdb\ufffdg\ufffd\u0309\ufffd\ufffd\ufffdR\ufffd\ufffd\ufffd\ufffdC\ufffd\ufffd (2007.7.26 maya)\r\n\t\t\t\tFWD_free_channel(pvar, local_channel_num);\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_NO_FREE_CHANNEL\", pvar,\r\n\t\t\t\t                  \"Could not open new channel. TTSSH is already opening too many channels.\");\r\n\t\t\t\tnotify_nonfatal_error(pvar, pvar->UIMsg);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tmsg = buffer_init();\r\n\t\t\tif (msg == NULL) {\r\n\t\t\t\t// TODO: error check\r\n\t\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\ts = \"direct-tcpip\";\r\n\t\t\tbuffer_put_string(msg, s, strlen(s)); // ctype\r\n\t\t\tbuffer_put_int(msg, c->self_id);  // self\r\n\t\t\tbuffer_put_int(msg, c->local_window);  // local_window\r\n\t\t\tbuffer_put_int(msg, c->local_maxpacket);  // local_maxpacket\r\n\r\n\t\t\ts = to_remote_host;\r\n\t\t\tbuffer_put_string(msg, s, strlen(s)); // target host\r\n\t\t\tbuffer_put_int(msg, to_remote_port);  // target port\r\n\r\n\t\t\ts = originator;\r\n\t\t\tbuffer_put_string(msg, s, strlen(s)); // originator host\r\n\t\t\tbuffer_put_int(msg, originator_port);  // originator port\r\n\r\n\t\t\tlen = buffer_len(msg);\r\n\t\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_OPEN, len);\r\n\t\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\t\tfinish_send_packet(pvar);\r\n\t\t\tbuffer_free(msg);\r\n\r\n\t\t\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_CHANNEL_OPEN was sent at SSH_open_channel().\");\r\n\r\n\t\t\treturn;\r\n\r\n\t\t\t/* NOT REACHED */\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif (SSHv1(pvar)) { // SSH1\ufffd\u0302\ufffd\r\n\t\tfinish_send_packet(pvar);\r\n\t\tenque_handlers(pvar, 2, msgs, handlers);\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n *\tfopen utf-8 wrapper\r\n */\r\nstatic FILE *fopenU8(const char *filenameU8, const char *mode)\r\n{\r\n\twchar_t *filenameW = ToWcharU8(filenameU8);\r\n\twchar_t *modeW = ToWcharU8(mode);\r\n\tFILE *fp;\r\n\t_wfopen_s(&fp, filenameW, modeW);\r\n\tfree(modeW);\r\n\tfree(filenameW);\r\n\treturn fp;\r\n}\r\n\r\n/**\r\n * stat UTF-8 wrapper\r\n */\r\nstatic int statU8(const char *filenameU8, struct __stat64 *st)\r\n{\r\n\twchar_t *filenameW = ToWcharU8(filenameU8);\r\n\tint r = _wstat64(filenameW, st);\r\n\tfree(filenameW);\r\n\treturn r;\r\n}\r\n\r\n/**\r\n *\tExtractFileName() UTF-8\ufffd\ufffd\r\n */\r\nstatic void ExtractFileNameU8(const char *PathName, char *FileName, size_t destlen)\r\n{\r\n\tconst char *sep = strrchr(PathName, '/');\r\n\tif (sep == NULL) {\r\n\t\tsep = strrchr(PathName, '\\\\');\r\n\t}\r\n\tif (sep != NULL) {\r\n\t\tstrncpy_s(FileName, destlen, sep + 1, _TRUNCATE);\r\n\t}\r\n\telse {\r\n\t\tstrncpy_s(FileName, destlen, PathName, _TRUNCATE);\r\n\t}\r\n}\r\n\r\nstatic int accessU8(const char *pathU8, int mode)\r\n{\r\n\twchar_t *pathW = ToWcharU8(pathU8);\r\n\tint r = _waccess(pathW, mode);\r\n\tfree(pathW);\r\n\treturn r;\r\n}\r\n\r\n/**\r\n *\tSCP support\r\n *\r\n *\t@param sendfile\t\t\ufffdt\ufffd@\ufffdC\ufffd\ufffd\ufffd\ufffd,UTF-8\r\n *\t@param dstfile\t\t\ufffdt\ufffd@\ufffdC\ufffd\ufffd\ufffd\ufffd,UTF-8\r\n *\t\t\t\t\t\tTOREMOTE \ufffd\u0302\u0182\ufffd\ufffdA\r\n *\t\t\t\t\t\t\tNULL \ufffd\u0302\u0182\ufffd\ufffdA\ufffdz\ufffd[\ufffd\ufffd\ufffdt\ufffdH\ufffd\ufffd\ufffd_\r\n *\t\t\t\t\t\t\t\ufffd\ufffd\ufffd\u0383p\ufffdX\ufffdA\ufffdz\ufffd[\ufffd\ufffd\ufffdt\ufffdH\ufffd\ufffd\ufffd_\ufffd\ufffd\ufffd\ufffd\u0311\ufffd\ufffd\ufffd?\r\n *\t\t\t\t\t\t\t\ufffd\ufffd\u0383p\ufffdX\r\n *\t\t\t\t\t\tTOLOCAL \ufffd\u0302\u0182\ufffd\r\n *\t\t\t\t\t\t\tNULL \ufffd\u0302\u0182\ufffd\ufffdA\ufffd_\ufffdE\ufffd\ufffd\ufffd\ufffd\ufffd[\ufffdh\ufffdt\ufffdH\ufffd\ufffd\ufffd_\r\n *\t\t\t\t\t\t\t\ufffd\ufffd\ufffd\u0383p\ufffdX\ufffdA\ufffdJ\ufffd\ufffd\ufffd\ufffd\ufffdg\ufffdt\ufffdH\ufffd\ufffd\ufffd_\ufffd\ufffd\ufffd\ufffd\u0311\ufffd\ufffd\ufffd?\r\n *\t\t\t\t\t\t\t\ufffd\ufffd\u0383p\ufffdX\r\n *\t@param direction\tTOREMOTE\tcopy local to remote\r\n *\t\t\t\t\t\tFROMREMOTE\tcopy remote to local\r\n *\r\n */\r\nint SSH_scp_transaction(PTInstVar pvar, const char *sendfile, const char *dstfile, enum scp_dir direction)\r\n{\r\n\tChannel_t *c = NULL;\r\n\tFILE *fp = NULL;\r\n\r\n\t// \ufffd\\\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffdN\ufffd\ufffd\ufffd[\ufffdY\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ua347\ufffd\u0349\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\tif (pvar->socket == INVALID_SOCKET)\r\n\t\tgoto error;\r\n\r\n\tif (SSHv1(pvar))      // SSH1\ufffdT\ufffd|\ufffd[\ufffdg\ufffd\ufffdTBD\r\n\t\tgoto error;\r\n\r\n\t// \ufffd`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\u0752\ufffd\r\n\tc = ssh2_channel_new(CHAN_SES_WINDOW_DEFAULT, CHAN_SES_PACKET_DEFAULT, TYPE_SCP, -1);\r\n\tif (c == NULL) {\r\n\t\tUTIL_get_lang_msg(\"MSG_SSH_NO_FREE_CHANNEL\", pvar,\r\n\t\t                  \"Could not open new channel. TTSSH is already opening too many channels.\");\r\n\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\tgoto error;\r\n\t}\r\n\tif (c->type == TYPE_SCP) {\r\n\t\tc->scp.pvar = pvar;\r\n\t\tpvar->recv.suspended = FALSE;\r\n\t\tpvar->recv.data_finished = FALSE;\r\n\t}\r\n\r\n\tif (direction == TOREMOTE) {  // copy local to remote\r\n\t\tstruct __stat64 st;\r\n\t\tfp = fopenU8(sendfile, \"rb\");\r\n\t\tif (fp == NULL) {\r\n\t\t\tstatic const TTMessageBoxInfoW info = {\r\n\t\t\t\t\"TTSSH\",\r\n\t\t\t\t\"MSG_SSH_SCP_FILEOPEN_ERROR_TITLE\", L\"TTSSH: file open error\",\r\n\t\t\t\t\"MSG_SSH_SCP_FILEOPEN_READ_ERROR\", L\"Can't open file for reading: %s %s\",\r\n\t\t\t\tMB_OK | MB_ICONERROR\r\n\t\t\t};\r\n\t\t\tDWORD error = GetLastError();\r\n\t\t\twchar_t *err_str;\r\n\t\t\thFormatMessageW(error, &err_str);\r\n\t\t\twchar_t *fname = ToWcharU8(sendfile);\r\n\t\t\tTTMessageBoxW(NULL, &info, pvar->ts->UILanguageFileW, err_str, fname);\r\n\t\t\tfree(fname);\r\n\t\t\tfree(err_str);\r\n\t\t\tgoto error;\r\n\t\t}\r\n\r\n\t\tstrncpy_s(c->scp.localfilefull, sizeof(c->scp.localfilefull), sendfile, _TRUNCATE);  // full path\r\n\t\tExtractFileNameU8(sendfile, c->scp.localfile, sizeof(c->scp.localfile));   // file name only\r\n\t\tif (dstfile == NULL || dstfile[0] == '\\0') { // remote file path\r\n\t\t\tstrncpy_s(c->scp.remotefile, sizeof(c->scp.remotefile), \".\", _TRUNCATE);  // full path\r\n\t\t} else {\r\n\t\t\tstrncpy_s(c->scp.remotefile, sizeof(c->scp.remotefile), dstfile, _TRUNCATE);  // full path\r\n\t\t}\r\n\t\tc->scp.localfp = fp;     // file pointer\r\n\r\n\t\tif (statU8(c->scp.localfilefull, &st) == 0) {\r\n\t\t\tc->scp.filestat = st;\r\n\t\t} else {\r\n\t\t\tgoto error;\r\n\t\t}\r\n\t} else { // copy remote to local\r\n\t\tstrncpy_s(c->scp.remotefile, sizeof(c->scp.remotefile), sendfile, _TRUNCATE);\r\n\r\n\t\tif (dstfile == NULL || dstfile[0] == '\\0') { // local file path is empty.\r\n\t\t\tchar *fn;\r\n\t\t\twchar_t *FileDirExpanded;\r\n\t\t\tchar *FileDirExpandedU8;\r\n\r\n\t\t\tfn = strrchr(sendfile, '/');\r\n\t\t\tif (fn && fn[1] == '\\0')\r\n\t\t\t\tgoto error;\r\n\r\n\t\t\thExpandEnvironmentStringsW(pvar->ts->FileDirW, &FileDirExpanded);\r\n\t\t\tFileDirExpandedU8 = ToU8W(FileDirExpanded);\r\n\t\t\t_snprintf_s(c->scp.localfilefull, sizeof(c->scp.localfilefull), _TRUNCATE, \"%s\\\\%s\", FileDirExpandedU8, fn ? fn : sendfile);\r\n\t\t\tfree(FileDirExpanded);\r\n\t\t\tfree(FileDirExpandedU8);\r\n\t\t\tExtractFileName(c->scp.localfilefull, c->scp.localfile, sizeof(c->scp.localfile));   // file name only\r\n\t\t} else {\r\n\t\t\t_snprintf_s(c->scp.localfilefull, sizeof(c->scp.localfilefull), _TRUNCATE, \"%s\", dstfile);\r\n\t\t\tExtractFileName(dstfile, c->scp.localfile, sizeof(c->scp.localfile));   // file name only\r\n\t\t}\r\n\r\n\t\tif (accessU8(c->scp.localfilefull, 0x00) == 0) {\r\n\t\t\tint dlgresult;\r\n\t\t\tif (accessU8(c->scp.localfilefull, 0x02) == -1) { // 0x02 == writable\r\n\t\t\t\tstatic const TTMessageBoxInfoW info = {\r\n\t\t\t\t\t\"TTSSH\",\r\n\t\t\t\t\t\"MSG_SSH_SCP_FILEOPEN_ERROR_TITLE\", L\"TTSSH: file open error\",\r\n\t\t\t\t\t\"MSG_SSH_SCP_FILEOPEN_READONLY_ERROR\", L\"`%s' file is read only.\",\r\n\t\t\t\t\tMB_OK | MB_ICONERROR\r\n\t\t\t\t};\r\n\t\t\t\twchar_t *fname = ToWcharU8(c->scp.localfilefull);\r\n\t\t\t\tTTMessageBoxW(NULL, &info, pvar->ts->UILanguageFileW, fname);\r\n\t\t\t\tfree(fname);\r\n\t\t\t\tgoto error;\r\n\t\t\t}\r\n\t\t\tstatic const TTMessageBoxInfoW info = {\r\n\t\t\t\t\"TTSSH\",\r\n\t\t\t\t\"MSG_SSH_SCP_CONFIRM_TITLE\", L\"TTSSH: confirm\",\r\n\t\t\t\t\"MSG_SSH_SCP_FILEOPEN_OVERWRITE_CONFIRM\", L\"`%s' file exists.\\noverwrite it?\",\r\n\t\t\t\tMB_YESNO | MB_ICONQUESTION\r\n\t\t\t};\r\n\t\t\twchar_t *fname = ToWcharU8(c->scp.localfilefull);\r\n\t\t\tdlgresult = TTMessageBoxW(NULL, &info, pvar->ts->UILanguageFileW, fname);\r\n\t\t\tfree(fname);\r\n\t\t\tif (dlgresult == IDNO) {\r\n\t\t\t\tgoto error;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfp = fopenU8(c->scp.localfilefull, \"wb\");\r\n\t\tif (fp == NULL) {\r\n\t\t\tstatic const TTMessageBoxInfoW info = {\r\n\t\t\t\t\"TTSSH\",\r\n\t\t\t\t\"MSG_SSH_SCP_FILEOPEN_ERROR_TITLE\", L\"TTSSH: file open error\",\r\n\t\t\t\t\"MSG_SSH_SCP_FILEOPEN_WRITE_ERROR\", L\"Can't open file for writing: %s %s\",\r\n\t\t\t\tMB_OK | MB_ICONERROR\r\n\t\t\t};\r\n\t\t\tDWORD error = GetLastError();\r\n\t\t\twchar_t *err_str;\r\n\t\t\thFormatMessageW(error, &err_str);\r\n\t\t\twchar_t *fname = ToWcharU8(c->scp.localfilefull);\r\n\t\t\tTTMessageBoxW(NULL, &info, pvar->ts->UILanguageFileW, err_str, fname);\r\n\t\t\tfree(fname);\r\n\t\t\tfree(err_str);\r\n\t\t\tgoto error;\r\n\t\t}\r\n\r\n\t\tc->scp.localfp = fp;     // file pointer\r\n\t}\r\n\r\n\t// setup SCP data\r\n\tc->scp.dir = direction;\r\n\tc->scp.state = SCP_INIT;\r\n\r\n\t{\r\n\t\tbuffer_t *msg;\r\n\t\tchar *s;\r\n\t\tunsigned char *outmsg;\r\n\t\tint len;\r\n\r\n\t\t// session open\r\n\t\tmsg = buffer_init();\r\n\t\tif (msg == NULL) {\r\n\t\t\tgoto error;\r\n\t\t}\r\n\t\ts = \"session\";\r\n\t\tbuffer_put_string(msg, s, strlen(s));  // ctype\r\n\t\tbuffer_put_int(msg, c->self_id);  // self(channel number)\r\n\t\tbuffer_put_int(msg, c->local_window);  // local_window\r\n\t\tbuffer_put_int(msg, c->local_maxpacket);  // local_maxpacket\r\n\t\tlen = buffer_len(msg);\r\n\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_OPEN, len);\r\n\t\tmemcpy(outmsg, buffer_ptr (msg), len);\r\n\t\tfinish_send_packet(pvar);\r\n\t\tbuffer_free(msg);\r\n\t}\r\n\r\n\tg_scp_sending = TRUE;\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_CHANNEL_OPEN was sent at SSH_scp_transaction().\");\r\n\r\n\treturn TRUE;\r\n\r\nerror:\r\n\tif (c != NULL)\r\n\t\tssh2_channel_delete(c);\r\n\tif (fp != NULL)\r\n\t\tfclose(fp);\r\n\r\n\treturn FALSE;\r\n}\r\n\r\nint SSH_start_scp(PTInstVar pvar, char *sendfile, char *dstfile)\r\n{\r\n\treturn SSH_scp_transaction(pvar, sendfile, dstfile, TOREMOTE);\r\n}\r\n\r\nint SSH_scp_sending_status(void)\r\n{\r\n\treturn g_scp_sending;\r\n}\r\n\r\nint SSH_start_scp_receive(PTInstVar pvar, char *filename)\r\n{\r\n\treturn SSH_scp_transaction(pvar, filename, NULL, FROMREMOTE);\r\n}\r\n\r\n\r\nint SSH_sftp_transaction(PTInstVar pvar)\r\n{\r\n\tbuffer_t *msg;\r\n\tchar *s;\r\n\tunsigned char *outmsg;\r\n\tint len;\r\n\tChannel_t *c = NULL;\r\n//\tFILE *fp = NULL;\r\n//\tstruct __stat64 st;\r\n\r\n\t// \ufffd\\\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffdN\ufffd\ufffd\ufffd[\ufffdY\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ua347\ufffd\u0349\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\tif (pvar->socket == INVALID_SOCKET)\r\n\t\tgoto error;\r\n\r\n\tif (SSHv1(pvar))      // SSH1\ufffdT\ufffd|\ufffd[\ufffdg\ufffd\ufffdTBD\r\n\t\tgoto error;\r\n\r\n\t// \ufffd`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\u0752\ufffd\r\n\tc = ssh2_channel_new(CHAN_SES_WINDOW_DEFAULT, CHAN_SES_PACKET_DEFAULT, TYPE_SFTP, -1);\r\n\tif (c == NULL) {\r\n\t\tUTIL_get_lang_msg(\"MSG_SSH_NO_FREE_CHANNEL\", pvar,\r\n\t\t                  \"Could not open new channel. TTSSH is already opening too many channels.\");\r\n\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\tgoto error;\r\n\t}\r\n\r\n\t// session open\r\n\tmsg = buffer_init();\r\n\tif (msg == NULL) {\r\n\t\tgoto error;\r\n\t}\r\n\ts = \"session\";\r\n\tbuffer_put_string(msg, s, strlen(s));  // ctype\r\n\tbuffer_put_int(msg, c->self_id);  // self(channel number)\r\n\tbuffer_put_int(msg, c->local_window);  // local_window\r\n\tbuffer_put_int(msg, c->local_maxpacket);  // local_maxpacket\r\n\tlen = buffer_len(msg);\r\n\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_OPEN, len);\r\n\tmemcpy(outmsg, buffer_ptr (msg), len);\r\n\tfinish_send_packet(pvar);\r\n\tbuffer_free(msg);\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_CHANNEL_OPEN was sent at SSH_sftp_transaction().\");\r\n\r\n\treturn TRUE;\r\n\r\nerror:\r\n\tif (c != NULL)\r\n\t\tssh2_channel_delete(c);\r\n\r\n\treturn FALSE;\r\n}\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// SSH2 protocol procedure in the following code:\r\n//\r\n/////////////////////////////////////////////////////////////////////////////\r\n\r\nvoid debug_print(int no, char *msg, int len)\r\n{\r\n#ifdef _DEBUG\r\n\tFILE *fp;\r\n\tchar file[128];\r\n\r\n\t_snprintf_s(file, sizeof(file), _TRUNCATE, \"dump%d.bin\", no);\r\n\r\n\tfp = fopen(file, \"wb\");\r\n\tif (fp == NULL)\r\n\t\treturn;\r\n\r\n\tfwrite(msg, 1, len, fp);\r\n\r\n\tfclose(fp);\r\n#endif\r\n}\r\n\r\n\r\n/*\r\n * \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0150\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0312u\ufffd\ufffd\ufffd\ufffdB\ufffd\ufffd\ufffd\u06c2\u0312\u0290M\ufffd\u024eg\ufffd\ufffd\ufffd\ufffd\u0302\ufffdpvar->ssh2_keys[]\ufffd\u0142\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffd\ufffd\ufffd\u0252u\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0142\u034eg\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB\r\n * \ufffdL\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\ufffd^\ufffdC\ufffd~\ufffd\ufffd\ufffdO\ufffd\u0141Apvar->ssh2_keys \ufffd\u0243R\ufffds\ufffd[\ufffd\ufffd\ufffd\ufffdB\r\n */\r\nstatic SSHKeys current_keys[MODE_MAX];\r\n\r\n\r\n#define write_buffer_file(buf,len) do_write_buffer_file(buf,len,__FILE__,__LINE__)\r\n\r\n\r\nstatic void do_write_buffer_file(void *buf, int len, char *file, int lineno)\r\n{\r\n\tFILE *fp;\r\n\tchar filename[256];\r\n\r\n\t_snprintf_s(filename, sizeof(filename), _TRUNCATE, \"data%d.bin\", lineno);\r\n\r\n\tfp = fopen(filename, \"wb\");\r\n\tif (fp == NULL)\r\n\t\treturn;\r\n\r\n\tfwrite(buf, 1, len, fp);\r\n\r\n\tfclose(fp);\r\n}\r\n\r\nvoid SSH2_packet_start(buffer_t *msg, unsigned char type)\r\n{\r\n\tunsigned char buf[9];\r\n\tint len = 6;\r\n\r\n\tmemset(buf, 0, sizeof(buf));\r\n\tbuf[len - 1] = type;\r\n\tbuffer_clear(msg);\r\n\tbuffer_append(msg, buf, len);\r\n}\r\n\r\n// \ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffd\ufffdT\ufffd[\ufffdo\ufffd\u0582\u0303L\ufffd[\ufffd\ufffd\ufffd\ufffd\ufffdJ\ufffdn\ufffdv\ufffd\ufffd\r\nvoid SSH2_send_kexinit(PTInstVar pvar)\r\n{\r\n\tchar cookie[SSH2_COOKIE_LENGTH];\r\n\tbuffer_t *msg;\r\n\tunsigned char *outmsg;\r\n\tint len, i;\r\n\r\n\tmsg = buffer_init();\r\n\tif (msg == NULL) {\r\n\t\t// TODO: error check\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\treturn;\r\n\t}\r\n\tif (pvar->my_kex != NULL)\r\n\t\tbuffer_free(pvar->my_kex);\r\n\tpvar->my_kex = msg;\r\n\r\n\t// \ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd^\ufffdC\ufffdv\r\n\t//SSH2_packet_start(msg, SSH2_MSG_KEXINIT);\r\n\r\n\t// cookie\ufffd\u0303Z\ufffdb\ufffdg\r\n\tCRYPT_set_random_data(pvar, cookie, sizeof(cookie));\r\n\tCRYPT_set_client_cookie(pvar, cookie);\r\n\tbuffer_append(msg, cookie, sizeof(cookie));\r\n\r\n\t// \ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg\ufffd\u0303L\ufffd[\ufffd\ufffd\ufffd\r\n\tfor (i = 0 ; i < PROPOSAL_MAX ; i++) {\r\n\t\tbuffer_put_string(msg, myproposal[i], strlen(myproposal[i]));\r\n\t}\r\n\tbuffer_put_char(msg, 0);\r\n\tbuffer_put_int(msg, 0);\r\n\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE,\r\n\t\t\"client proposal: KEX algorithm: %s\",\r\n\t\tmyproposal[0]);\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE,\r\n\t\t\"client proposal: server host key algorithm: %s\",\r\n\t\tmyproposal[1]);\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE,\r\n\t\t\"client proposal: encryption algorithm client to server: %s\",\r\n\t\tmyproposal[2]);\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE,\r\n\t\t\"client proposal: encryption algorithm server to client: %s\",\r\n\t\tmyproposal[3]);\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE,\r\n\t\t\"client proposal: MAC algorithm client to server: %s\",\r\n\t\tmyproposal[4]);\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE,\r\n\t\t\"client proposal: MAC algorithm server to client: %s\",\r\n\t\tmyproposal[5]);\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE,\r\n\t\t\"client proposal: compression algorithm client to server: %s\",\r\n\t\tmyproposal[6]);\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE,\r\n\t\t\"client proposal: compression algorithm server to client: %s\",\r\n\t\tmyproposal[7]);\r\n\r\n\r\n\tlen = buffer_len(msg);\r\n\toutmsg = begin_send_packet(pvar, SSH2_MSG_KEXINIT, len);\r\n\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\tfinish_send_packet(pvar);\r\n\r\n\t// my_kex\ufffd\u024e\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u07c1A\ufffdt\ufffd\ufffd\ufffd[\ufffd\ufffd\ufffd\u0102\u0342\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t//buffer_free(msg);\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_KEXINIT was sent at SSH2_send_kexinit().\");\r\n}\r\n\r\n\r\nvoid normalize_generic_order(char *buf, char default_strings[], int default_strings_len)\r\n{\r\n\tchar listed[max(KEX_DH_MAX,max(SSH_CIPHER_MAX,max(KEY_ALGO_MAX,max(HMAC_MAX,COMP_MAX)))) + 1];\r\n\tchar allowed[max(KEX_DH_MAX,max(SSH_CIPHER_MAX,max(KEY_ALGO_MAX,max(HMAC_MAX,COMP_MAX)))) + 1];\r\n\tint i, j, k=-1;\r\n\r\n\tmemset(listed, 0, sizeof(listed));\r\n\tmemset(allowed, 0, sizeof(allowed));\r\n\r\n\t// \ufffd\ufffd\ufffd\u0082\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u9576\ufffd\ufffd\ufffd\u0303\ufffd\ufffdX\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\tfor (i = 0; i < default_strings_len ; i++) {\r\n\t\tallowed[default_strings[i]] = 1;\r\n\t}\r\n\r\n\t// \ufffdw\ufffd\u80b3\ufffd\ua0bd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ud805\udd8d\ufffd\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffd\u0082\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdA\ufffdd\ufffd\ufffd\ufffd\ufffd\ufffd\u9576\ufffd\ufffd\ufffd\u034d\ud3dc\ufffd\ufffd\ufffd\ufffdB\r\n\t//\r\n\t// ex. (i=5 \ufffd\u0315\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ud3dc\ufffd\ufffd\ufffd\ufffd)\r\n\t// i=012345\r\n\t//   >:=9<87;A@?B3026(\\0)\r\n\t//         i+1\r\n\t//         <------------>\r\n\t//       \ufffd\ufffd\r\n\t//   >:=9<7;A@?B3026(\\0)\r\n\t//\r\n\tfor (i = 0; buf[i] != 0; i++) {\r\n\t\tint num = buf[i] - '0';\r\n\r\n\t\tif (num < 0 || num > default_strings_len\r\n\t\t\t|| !allowed[num]\r\n\t\t\t|| listed[num]) {\r\n\t\t\tmemmove(buf + i, buf + i + 1, strlen(buf + i + 1) + 1);\r\n\t\t\ti--;\r\n\t\t} else {\r\n\t\t\tlisted[num] = 1;\r\n\t\t}\r\n\r\n\t\t// disabled line\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0381A\ufffd\u0292u\ufffd\ufffd\ufffdo\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffdB\r\n\t\tif (num == 0) {\r\n\t\t\tk = i;\r\n\t\t}\r\n\t}\r\n\r\n\t// \ufffdw\ufffd\u80b3\ufffd\ufffd\u0102\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0381Adisabled line\ufffd\u0312\ufffd\ufffdO\ufffd\u0251}\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t//\r\n\t// ex. (Z\ufffd\ufffd}\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd)\r\n\t//                k\r\n\t//   >:=9<87;A@?B3026(\\0)\r\n\t//                 k+1\r\n\t//                 <---->\r\n\t//       \ufffd\ufffd       k\r\n\t//   >:=9<87;A@?B30026(\\0)\r\n\t//       \ufffd\ufffd        k\r\n\t//   >:=9<87;A@?B3Z026(\\0)\r\n\t//\r\n\tfor (j = 0; j < default_strings_len && default_strings[j] != 0; j++) {\r\n\t\tint num = default_strings[j];\r\n\r\n\t\tif (!listed[num] && k >= 0) {\r\n\t\t\tint copylen = strlen(buf + k + 1) + 1;\r\n\r\n\t\t\tmemmove(buf + k + 1, buf + k, copylen);\r\n\t\t\tbuf[k + 1 + copylen] = '\\0';   // \ufffdI\ufffd[\ufffd\ufffdY\ufffd\ua0b8\ufffd\u0255t\ufffd\ufffd\ufffd\ufffdB\r\n\t\t\tbuf[k] = num + '0';\r\n\t\t\tk++;\r\n\t\t\ti++;\r\n\t\t}\r\n\t}\r\n\tif (k < 0) {\r\n\t\tj = 0;\r\n\t}\r\n\telse {\r\n\t\tj++;\r\n\t}\r\n\r\n\t// disabled line\ufffd\ufffd\ufffd\ufffd\ufffd\u0742\ufffd\ufffd\u0202\ufffd\ufffd\ua347\ufffd\u0341A\ufffd\ufffd\ufffd\u0302\u0702\u0716\ufffd\ufffd\ufffd\ufffd\u0252\u01c9\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\tfor (; j < default_strings_len ; j++) {\r\n\t\tint num = default_strings[j];\r\n\r\n\t\tif (!listed[num]) {\r\n\t\t\tbuf[i] = num + '0';\r\n\t\t\tlisted[num] = 1;\r\n\t\t\ti++;\r\n\t\t}\r\n\t}\r\n\r\n\tbuf[i] = 0;\r\n}\r\n\r\nvoid choose_SSH2_proposal(char *server_proposal,\r\n                          char *my_proposal,\r\n                          char *dest,\r\n                          int dest_len)\r\n{\r\n\tchar tmp_cli[1024], *ptr_cli, *ctc_cli;\r\n\tchar tmp_svr[1024], *ptr_svr, *ctc_svr;\r\n\r\n\tstrncpy_s(tmp_cli, sizeof(tmp_cli), my_proposal, _TRUNCATE);\r\n\tptr_cli = strtok_s(tmp_cli, \",\", &ctc_cli);\r\n\twhile (ptr_cli != NULL) {\r\n\t\t// server_proposal\ufffd\u0242\u0343T\ufffd[\ufffdo\ufffd\ufffdproposal\ufffd\ufffd\ufffdJ\ufffd\ufffd\ufffd}\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u014ai\ufffd[\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\r\n\t\tstrncpy_s(tmp_svr, sizeof(tmp_svr), server_proposal, _TRUNCATE);\r\n\t\tptr_svr = strtok_s(tmp_svr, \",\", &ctc_svr);\r\n\t\twhile (ptr_svr != NULL) {\r\n\t\t\tif (strcmp(ptr_svr, ptr_cli) == 0) { // match\r\n\t\t\t\tgoto found;\r\n\t\t\t}\r\n\t\t\tptr_svr = strtok_s(NULL, \",\", &ctc_svr);\r\n\t\t}\r\n\t\tptr_cli = strtok_s(NULL, \",\", &ctc_cli);\r\n\t}\r\n\r\nfound:\r\n\tif (ptr_cli != NULL) {\r\n\t\tstrncpy_s(dest, dest_len, ptr_cli, _TRUNCATE);\r\n\t}\r\n\telse {\r\n\t\tstrncpy_s(dest, dest_len, \"\", _TRUNCATE);\r\n\t}\r\n}\r\n\r\n// \ufffd\u00cd\ufffd\ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd\ufffd\u0303L\ufffd[\ufffdT\ufffdC\ufffdY\ufffdA\ufffdu\ufffd\ufffd\ufffdb\ufffdN\ufffdT\ufffdC\ufffdY\ufffdAMAC\ufffdT\ufffdC\ufffdY\ufffd\u0302\ufffd\ufffd\ufffd\ufffd\u0151\ufffdl(we_need)\ufffd\ufffd\ufffd\ufffd\ufffd\u80b7\ufffd\ufffdB\r\nstatic void choose_SSH2_key_maxlength(PTInstVar pvar)\r\n{\r\n\tint mode, val;\r\n\tunsigned int need = 0;\r\n\tconst EVP_MD *md;\r\n\tconst struct ssh2cipher *cipher;\r\n\tconst struct SSH2Mac *mac;\r\n\r\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\r\n\t\tcipher = pvar->ciphers[mode];\r\n\t\tmac = pvar->macs[mode];\r\n\r\n\t\t// current_keys[]\ufffd\u0250\u0752\u80b5\ufffd\u0102\ufffd\ufffd\ufffd\ufffd\u0101A\ufffd\ufffd\ufffd\u0182\ufffd pvar->ssh2_keys[] \ufffd\u0583R\ufffds\ufffd[\ufffd\ufffd\ufffd\ufffdB\r\n\t\tmd = get_ssh2_mac_EVP_MD(mac);\r\n\t\tcurrent_keys[mode].mac.md = md;\r\n\t\tcurrent_keys[mode].mac.key_len = current_keys[mode].mac.mac_len = EVP_MD_size(md);\r\n\t\tval = get_ssh2_mac_truncatebits(mac);\r\n\t\tif (val != 0) {\r\n\t\t\tcurrent_keys[mode].mac.mac_len = val / 8;\r\n\t\t}\r\n\t\tcurrent_keys[mode].mac.etm = get_ssh2_mac_etm(mac);\r\n\r\n\t\t// \ufffdL\ufffd[\ufffdT\ufffdC\ufffdY\ufffd\u0183u\ufffd\ufffd\ufffdb\ufffdN\ufffdT\ufffdC\ufffdY\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0150\u0752\u80b5\ufffd\u0102\ufffd\ufffd\ufffd (2004.11.7 yutaka)\r\n\t\tcurrent_keys[mode].enc.key_len = get_cipher_key_len(cipher);\r\n\t\tcurrent_keys[mode].enc.block_size = get_cipher_block_size(cipher);\r\n\t\tcurrent_keys[mode].enc.iv_len = get_cipher_iv_len(cipher);\r\n\t\tcurrent_keys[mode].enc.auth_len = get_cipher_auth_len(cipher);\r\n\r\n\t\tcurrent_keys[mode].mac.enabled = 0;\r\n\t\tcurrent_keys[mode].comp.enabled = 0; // (2005.7.9 yutaka)\r\n\r\n\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd_\ufffd\u0142\ufffdMAC\ufffd\ufffddisable\r\n\t\tpvar->ssh2_keys[mode].mac.enabled = 0;\r\n\t\tpvar->ssh2_keys[mode].comp.enabled = 0; // (2005.7.9 yutaka)\r\n\r\n\t\tneed = max(need, current_keys[mode].enc.key_len);\r\n\t\tneed = max(need, current_keys[mode].enc.block_size);\r\n\t\tneed = max(need, current_keys[mode].enc.iv_len);\r\n\t\tneed = max(need, current_keys[mode].mac.key_len);\r\n\t}\r\n\tpvar->we_need = need;\r\n}\r\n\r\n\r\n/*\r\n * \ufffdL\ufffd[\ufffd\ufffd\ufffd\ufffd\ufffdJ\ufffdn\ufffdO\ufffd\u0303`\ufffdF\ufffdb\ufffdN (SSH2_MSG_KEXINIT)\r\n * \ufffd\ufffd\ufffd\ufffd\ufffdY\ufffd\u0590\ufffd\ufffd\u0343f\ufffd[\ufffd^\ufffd\u0290M\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\u0102\u0382\ufffd\u0102\ufffd\ufffd\ufffd\u0094\\\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\r\n *\r\n * SSH2_MSG_KEXINIT:\r\n *   byte         SSH_MSG_KEXINIT\r\n *   byte[16]     cookie (random bytes)\r\n *   name-list    kex_algorithms\r\n *   name-list    server_host_key_algorithms\r\n *   name-list    encryption_algorithms (c2s)\r\n *   name-list    encryption_algorithms (s2c)\r\n *   name-list    mac_algorithms (c2s)\r\n *   name-list    mac_algorithms (s2c)\r\n *   name-list    compression_algorithms (c2s)\r\n *   name-list    compression_algorithms (s2c)\r\n *   name-list    languages (c2s)\r\n *   name-list    languages (s2c)\r\n *   boolean      first_kex_packet_follows\r\n *   uint32       0 (reserved for future extension)\r\n */\r\nstatic BOOL handle_SSH2_kexinit(PTInstVar pvar)\r\n{\r\n\tchar buf[1024];\r\n\tchar *data;\r\n\tint len, size;\r\n\tchar *msg = NULL;\r\n\tchar tmp[1024+512];\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_KEXINIT was received.\");\r\n\r\n\t// \ufffd\ufffd\ufffd\u0142\u0243L\ufffd[\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdI\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\u0582\ufffd\u70b8\ufffdA\ufffdT\ufffd[\ufffdo\ufffd\ufffd\ufffd\ufffd SSH2_MSG_KEXINIT \ufffd\ufffd\r\n\t// \ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ua347\ufffd\u0341A\ufffdL\ufffd[\ufffd\u010d\uc42c\ufffd\ufffd\ufffds\ufffd\ufffd\ufffdB(2004.10.24 yutaka)\r\n\tif (pvar->kex_status == KEX_FLAG_KEXDONE) {\r\n\t\tpvar->kex_status = KEX_FLAG_REKEYING;\r\n\r\n\t\t// \ufffdL\ufffd[\ufffd\u010d\uc42c\ufffd\ufffd\ufffd\ufffd myproposal \ufffd\ufffd\ufffd\ufffd \",ext-info-c\" \ufffd\ufffd\ufffd\ud3dc\ufffd\ufffd\ufffd\ufffd\r\n\t\t// \ufffdX\ufffdV\ufffd\ufffd\ufffd\ufffd\u0302\ufffd KEX \ufffd\u0302\u0742\u0142\u60a2\r\n\t\tSSH2_update_kex_myproposal(pvar);\r\n\r\n\t\t// \ufffdT\ufffd[\ufffdo\ufffd\ufffdSSH2_MSG_KEXINIT \ufffd\ud805\uddc2\ufffd\r\n\t\tSSH2_send_kexinit(pvar);\r\n\t}\r\n\r\n\tdata = remained_payload(pvar);\r\n\tlen = remained_payloadlen(pvar);\r\n\r\n\t// KEX \ufffd\u030d\u014c\ufffd\ufffd exchange-hash (session-id) \ufffd\ufffd\ufffdv\ufffdZ\ufffd\ufffd\ufffd\ufffd\u0302\u024eg\ufffd\ufffd\ufffd\u0302\u0155\u06d1\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\r\n\tif (pvar->peer_kex != NULL) {\r\n\t\t// already allocated\r\n\t\tbuffer_clear(pvar->peer_kex);\r\n\t}\r\n\telse {\r\n\t\tpvar->peer_kex = buffer_init();\r\n\t\tif (pvar->peer_kex == NULL) {\r\n\t\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\r\n\t\t\t\t\t\t\"%s: Out of memory\", __FUNCTION__);\r\n\t\t\tmsg = tmp;\r\n\t\t\tgoto error;\r\n\t\t}\r\n\t}\r\n\tbuffer_append(pvar->peer_kex, data, len);\r\n\r\n\tpush_memdump(\"KEXINIT\", \"exchange algorithm list: receiving\", data, len);\r\n\r\n\t// cookie\r\n\tif (! get_bytearray_from_payload(pvar, buf, SSH2_COOKIE_LENGTH)) {\r\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: truncated packet (cookie)\", __FUNCTION__);\r\n\t\tmsg = tmp;\r\n\t\tgoto error;\r\n\t}\r\n\tCRYPT_set_server_cookie(pvar, buf);\r\n\r\n\t// \ufffde\ufffdv\ufffdf(\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd,\ufffd\u00cd\ufffd\ufffd\ufffd\ufffd\ufffd)\ufffd\u014eg\ufffdp\ufffd\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd\ufffd\u030c\ufffd\ufffd\ufffdB\r\n\t// \ufffdT\ufffd[\ufffdo\ufffd\ufffd\ufffd\ufffd\u0343J\ufffd\ufffd\ufffd}\ufffd\ufffd\u0602\ufffd\u0142\u0303\ufffd\ufffdX\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0117\ufffd\ufffd\ufffdB\r\n\t// \ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg\ufffd\u0183T\ufffd[\ufffdo\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdT\ufffd|\ufffd[\ufffdg\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u9568\ufffd\u0302\ufffd\ufffd\ufffd\ufffdA\r\n\t// \ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffd\u014d\u0142\ufffd\ufffdO\ufffd\u024ew\ufffd\u80b5\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffd\ufffdB\r\n\r\n\t// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd\r\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\r\n\tcase GetPayloadError:\r\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: truncated packet (kex algorithms)\", __FUNCTION__);\r\n\t\tmsg = tmp;\r\n\t\tgoto error;\r\n\tcase GetPayloadTruncate:\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed kex algorithms is too long.\", __FUNCTION__);\r\n\t\tbreak;\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: KEX algorithm: %s\", buf);\r\n\r\n\tpvar->kex_type = choose_SSH2_kex_algorithm(buf, myproposal[PROPOSAL_KEX_ALGS]);\r\n\tif (pvar->kex_type == KEX_DH_UNKNOWN) { // not match\r\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown KEX algorithm: \", _TRUNCATE);\r\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\r\n\t\tmsg = tmp;\r\n\t\tgoto error;\r\n\t}\r\n\r\n\t// \ufffdz\ufffdX\ufffdg\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd\r\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\r\n\tcase GetPayloadError:\r\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: truncated packet (hostkey algorithms)\", __FUNCTION__);\r\n\t\tmsg = tmp;\r\n\t\tgoto error;\r\n\tcase GetPayloadTruncate:\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed hostkey algorithms is too long.\", __FUNCTION__);\r\n\t\tbreak;\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: server host key algorithm: %s\", buf);\r\n\r\n\tpvar->hostkey_type = choose_SSH2_host_key_algorithm(buf, myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS]);\r\n\tif (pvar->hostkey_type == KEY_ALGO_UNSPEC) {\r\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown host KEY algorithm: \", _TRUNCATE);\r\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\r\n\t\tmsg = tmp;\r\n\t\tgoto error;\r\n\t}\r\n\r\n\t// \ufffd\u00cd\ufffd\ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd(\ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg -> \ufffdT\ufffd[\ufffdo)\r\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\r\n\tcase GetPayloadError:\r\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: truncated packet (encryption algorithms client to server)\", __FUNCTION__);\r\n\t\tmsg = tmp;\r\n\t\tgoto error;\r\n\tcase GetPayloadTruncate:\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed encryption algorithms (client to server) is too long.\", __FUNCTION__);\r\n\t\tbreak;\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: encryption algorithm client to server: %s\", buf);\r\n\r\n\tpvar->ciphers[MODE_OUT] = choose_SSH2_cipher_algorithm(buf, myproposal[PROPOSAL_ENC_ALGS_CTOS]);\r\n\tif (pvar->ciphers[MODE_OUT] == NULL) {\r\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown Encrypt algorithm(client to server): \", _TRUNCATE);\r\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\r\n\t\tmsg = tmp;\r\n\t\tgoto error;\r\n\t}\r\n\r\n\t// \ufffd\u00cd\ufffd\ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd(\ufffdT\ufffd[\ufffdo -> \ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg)\r\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\r\n\tcase GetPayloadError:\r\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: truncated packet (encryption algorithms server to client)\", __FUNCTION__);\r\n\t\tmsg = tmp;\r\n\t\tgoto error;\r\n\tcase GetPayloadTruncate:\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed encryption algorithms (server to client) is too long.\", __FUNCTION__);\r\n\t\tbreak;\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: encryption algorithm server to client: %s\", buf);\r\n\r\n\tpvar->ciphers[MODE_IN] = choose_SSH2_cipher_algorithm(buf, myproposal[PROPOSAL_ENC_ALGS_STOC]);\r\n\tif (pvar->ciphers[MODE_IN] == NULL) {\r\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown Encrypt algorithm(server to client): \", _TRUNCATE);\r\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\r\n\t\tmsg = tmp;\r\n\t\tgoto error;\r\n\t}\r\n\r\n\t// MAC\ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd(\ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg -> \ufffdT\ufffd[\ufffdo)\r\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\r\n\tcase GetPayloadError:\r\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: truncated packet (MAC algorithms client to server)\", __FUNCTION__);\r\n\t\tmsg = tmp;\r\n\t\tgoto error;\r\n\tcase GetPayloadTruncate:\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed MAC algorithms (client to server) is too long.\", __FUNCTION__);\r\n\t\tbreak;\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: MAC algorithm client to server: %s\", buf);\r\n\r\n\tif (get_cipher_auth_len(pvar->ciphers[MODE_OUT]) > 0) {\r\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"AEAD cipher is selected, ignoring MAC algorithms. (client to server)\");\r\n\t\tpvar->macs[MODE_OUT] = get_ssh2_mac(HMAC_IMPLICIT);\r\n\t}\r\n\telse {\r\n\t\tpvar->macs[MODE_OUT] = choose_SSH2_mac_algorithm(buf, myproposal[PROPOSAL_MAC_ALGS_CTOS]);\r\n\t\tif (pvar->macs[MODE_OUT] == NULL) { // not match\r\n\t\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown MAC algorithm: \", _TRUNCATE);\r\n\t\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\r\n\t\t\tmsg = tmp;\r\n\t\t\tgoto error;\r\n\t\t}\r\n\t}\r\n\r\n\t// MAC\ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd(\ufffdT\ufffd[\ufffdo -> \ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg)\r\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\r\n\tcase GetPayloadError:\r\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: truncated packet (MAC algorithms server to client)\", __FUNCTION__);\r\n\t\tmsg = tmp;\r\n\t\tgoto error;\r\n\tcase GetPayloadTruncate:\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed MAC algorithms (server to client) is too long.\", __FUNCTION__);\r\n\t\tbreak;\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: MAC algorithm server to client: %s\", buf);\r\n\r\n\tif (get_cipher_auth_len(pvar->ciphers[MODE_IN]) > 0) {\r\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"AEAD cipher is selected, ignoring MAC algorithms. (server to client)\");\r\n\t\tpvar->macs[MODE_IN] = get_ssh2_mac(HMAC_IMPLICIT);\r\n\t}\r\n\telse {\r\n\t\tpvar->macs[MODE_IN] = choose_SSH2_mac_algorithm(buf, myproposal[PROPOSAL_MAC_ALGS_STOC]);\r\n\t\tif (pvar->macs[MODE_IN] == NULL) { // not match\r\n\t\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown MAC algorithm: \", _TRUNCATE);\r\n\t\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\r\n\t\t\tmsg = tmp;\r\n\t\t\tgoto error;\r\n\t\t}\r\n\t}\r\n\r\n\t// \ufffd\ufffd\ufffdk\ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd(\ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg -> \ufffdT\ufffd[\ufffdo)\r\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\r\n\tcase GetPayloadError:\r\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: truncated packet (compression algorithms client to server)\", __FUNCTION__);\r\n\t\tmsg = tmp;\r\n\t\tgoto error;\r\n\tcase GetPayloadTruncate:\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed compression algorithms (client to server) is too long.\", __FUNCTION__);\r\n\t\tbreak;\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: compression algorithm client to server: %s\", buf);\r\n\r\n\tpvar->ctos_compression = choose_SSH2_compression_algorithm(buf, myproposal[PROPOSAL_COMP_ALGS_CTOS]);\r\n\tif (pvar->ctos_compression == COMP_UNKNOWN) { // not match\r\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown Packet Compression algorithm: \", _TRUNCATE);\r\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\r\n\t\tmsg = tmp;\r\n\t\tgoto error;\r\n\t}\r\n\r\n\t// \ufffd\ufffd\ufffdk\ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd(\ufffdT\ufffd[\ufffdo -> \ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg)\r\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\r\n\tcase GetPayloadError:\r\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: truncated packet (compression algorithms server to client)\", __FUNCTION__);\r\n\t\tmsg = tmp;\r\n\t\tgoto error;\r\n\tcase GetPayloadTruncate:\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed compression algorithms (server to client) is too long.\", __FUNCTION__);\r\n\t\tbreak;\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: compression algorithm server to client: %s\", buf);\r\n\r\n\tpvar->stoc_compression = choose_SSH2_compression_algorithm(buf, myproposal[PROPOSAL_COMP_ALGS_STOC]);\r\n\tif (pvar->stoc_compression == COMP_UNKNOWN) { // not match\r\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown Packet Compression algorithm: \", _TRUNCATE);\r\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\r\n\t\tmsg = tmp;\r\n\t\tgoto error;\r\n\t}\r\n\r\n\t// \ufffd\ufffd\ufffd\ufffd(\ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg -> \ufffdT\ufffd[\ufffdo)\r\n\t// \ufffd\ufffd\ufffd\ufffd\u0142\u0356\ufffd\ufffdg\ufffdp\ufffdB\ufffd\ufffd\ufffdO\ufffd\u024bL\ufffd^\ufffd\ufffd\ufffd\u90be\ufffd\ufffd\ufffdB\r\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\r\n\tcase GetPayloadError:\r\n\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd name-list \ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\u0182\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd KEXINIT \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\u0303t\ufffdH\ufffd[\ufffd}\ufffdb\ufffdg\ufffd\ufffd\ufffd\u0302\ufffd\ufffdz\ufffd\ufffdO\ufffd\u0142\ufffd\ufffd\ufffd\r\n\t\t// \ufffd\u064f\ufffd\u020f\ufffd\u0502\u0142\ufffd\ufffd\u90aa\ufffdA\ufffd\u0290M\ufffd\u0255K\ufffdv\ufffd\u0203A\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd\ufffd\u0342\ufffd\ufffd\u0142\u0243l\ufffdS\ufffd\u03c2\u0742\u0152\u0290M\ufffd\ufffd\ufffd\u0302\u034ds\ufffd\ufffd\ufffd\ufffdB\r\n\t\t// \ufffd\ufffd\ufffd\u0702\u0142\u0342\ufffd\ufffd\u0315\ufffd\ufffd\ufffd\ufffd\u0303`\ufffdF\ufffdb\ufffdN\ufffd\ufffd\ufffds\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0141A\ufffdx\ufffd\ufffd\ufffd\ufffd\ufffdL\ufffd^\ufffd\ufffd\ufffd\ufffd\u0302\u0742\u014f\ufffd\ufffd\ufffd\ufffd\ud807\udc4ds\ufffd\ufffd\ufffd\ufffdB\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: truncated packet (language client to server)\", __FUNCTION__);\r\n\t\tgoto skip;\r\n\tcase GetPayloadTruncate:\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed language (client to server) is too long.\", __FUNCTION__);\r\n\t\tbreak;\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: language client to server: %s\", buf);\r\n\r\n\t// \ufffd\ufffd\ufffd\ufffd(\ufffdT\ufffd[\ufffdo -> \ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg)\r\n\t// \ufffd\ufffd\ufffd\ufffd\u0142\u0356\ufffd\ufffdg\ufffdp\ufffdB\ufffd\ufffd\ufffdO\ufffd\u024bL\ufffd^\ufffd\ufffd\ufffd\u90be\ufffd\ufffd\ufffdB\r\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\r\n\tcase GetPayloadError:\r\n\t\t// \ufffd\ufffd\ufffd\ufffd(\ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg -> \ufffdT\ufffd[\ufffdo) \ufffd\u0193\ufffd\ufffdl\ufffd\u0241A\ufffd\ufffd\u80aa\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffdx\ufffd\ufffd\ufffd\u0302\u0742\u0182\ufffd\ufffd\ufffdB\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: truncated packet (language server to client)\", __FUNCTION__);\r\n\t\tgoto error;\r\n\tcase GetPayloadTruncate:\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed language (server to client) is too long.\", __FUNCTION__);\r\n\t\tbreak;\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: language server to client: %s\", buf);\r\n\r\n\t// first_kex_packet_follows:\r\n\t// KEXINIT \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\u030c\ufffd\u0241A\ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd\ufffd\u0303l\ufffdS\ufffd\ufffd\ufffd\u0282\ud800\udd11\ufffd\ufffd\ufffd\ufffd\u010c\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ud805\uddc2\ufffd\ufffd\u0102\ufffd\ufffd\u90a9\ufffdB\r\n\t// SSH_MSG_KEXINIT \ufffd\u030c\ufffd\u030c\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0343N\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\u7457\ufffd\ufffd\u0302\u0143T\ufffd[\ufffdo\ufffd\ufffd\ufffd\ufffd 1 \ufffd\u0242\ufffd\ufffd\u9396\ufffd\u0342\u0202\ufffd\ufffd\u0342\ufffd\ufffdB\r\n\tif (!get_boolean_from_payload(pvar, buf)) {\r\n\t\t// \ufffd\ufffd\ufffd\ufffd(\ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg -> \ufffdT\ufffd[\ufffdo) \ufffd\u0193\ufffd\ufffdl\ufffd\u0241A\ufffd\ufffd\u80aa\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffdx\ufffd\ufffd\ufffd\u0302\u0742\u0182\ufffd\ufffd\ufffdB\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: truncated packet (first_kex_packet_follows)\", __FUNCTION__);\r\n\t\tgoto skip;\r\n\t}\r\n\tif (buf[0] != 0) {\r\n\t\t// \ufffdO\ufffdq\ufffd\u0302\u60a4\ufffd\u0243T\ufffd[\ufffdo\ufffd\ufffd\ufffd\ufffd 0 \ufffd\u020aO\ufffd\u0242\ufffd\ufffd\u9396\ufffd\u0342\u0202\ufffd\ufffd\u0342\ufffd\ufffd\u0202\u0302\u0141A\ufffdx\ufffd\ufffd\ufffd\ufffd\ufffdL\ufffd^\ufffd\ufffd\ufffd\ufffdB\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: first_kex_packet_follows is not 0. (%d)\", __FUNCTION__, buf[0]);\r\n\t}\r\n\r\n\t// reserved: \ufffd\ufffd\ufffd\ufffd\u034f\ufffd\ufffd 0 \ufffd\u0182\u0202\ufffdB\r\n\tif (!get_uint32_from_payload(pvar, &size)) {\r\n\t\t// \ufffd\ufffd\ufffd\ufffd(\ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg -> \ufffdT\ufffd[\ufffdo) \ufffd\u0193\ufffd\ufffdl\ufffd\u0241A\ufffd\ufffd\u80aa\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffdx\ufffd\ufffd\ufffd\u0302\u0742\u0182\ufffd\ufffd\ufffdB\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: truncated packet (reserved)\", __FUNCTION__ );\r\n\t\tgoto skip;\r\n\t}\r\n\tif (size != 0) {\r\n\t\tlogprintf(LOG_LEVEL_INFO, \"%s: reserved data is not 0. (%d)\", __FUNCTION__, size);\r\n\t}\r\n\r\nskip:\r\n\t// \ufffd\ufffd\ufffd\u80b5\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdO\ufffd\u024fo\ufffd\ufffd\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"KEX algorithm: %s\",\r\n\t\tget_kex_algorithm_name(pvar->kex_type));\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server host key algorithm: %s\",\r\n\t\tget_ssh2_hostkey_algorithm_name(pvar->hostkey_type));\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"encryption algorithm client to server: %s\",\r\n\t\tget_cipher_string(pvar->ciphers[MODE_OUT]));\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"encryption algorithm server to client: %s\",\r\n\t\tget_cipher_string(pvar->ciphers[MODE_IN]));\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"MAC algorithm client to server: %s\",\r\n\t\tget_ssh2_mac_name(pvar->macs[MODE_OUT]));\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"MAC algorithm server to client: %s\",\r\n\t\tget_ssh2_mac_name(pvar->macs[MODE_IN]));\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"compression algorithm client to server: %s\",\r\n\t\tget_ssh2_comp_name(pvar->ctos_compression));\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"compression algorithm server to client: %s\",\r\n\t\tget_ssh2_comp_name(pvar->stoc_compression));\r\n\r\n\t// we_need\ufffd\u030c\ufffd\ufffd\ufffd (2004.11.6 yutaka)\r\n\t// \ufffdL\ufffd[\ufffd\u010d\uc42c\ufffd\u030f\ua347\ufffd\u0343X\ufffdL\ufffdb\ufffdv\ufffd\ufffd\ufffd\ufffdB\r\n\tif ((pvar->kex_status & KEX_FLAG_REKEYING) == 0) {\r\n\t\tchoose_SSH2_key_maxlength(pvar);\r\n\t}\r\n\r\n\t// send DH kex init\r\n\tswitch (pvar->kex_type) {\r\n\t\tcase KEX_DH_GRP1_SHA1:\r\n\t\tcase KEX_DH_GRP14_SHA1:\r\n\t\tcase KEX_DH_GRP14_SHA256:\r\n\t\tcase KEX_DH_GRP16_SHA512:\r\n\t\tcase KEX_DH_GRP18_SHA512:\r\n\t\t\tSSH2_dh_kex_init(pvar);\r\n\t\t\tbreak;\r\n\t\tcase KEX_DH_GEX_SHA1:\r\n\t\tcase KEX_DH_GEX_SHA256:\r\n\t\t\tSSH2_dh_gex_kex_init(pvar);\r\n\t\t\tbreak;\r\n\t\tcase KEX_ECDH_SHA2_256:\r\n\t\tcase KEX_ECDH_SHA2_384:\r\n\t\tcase KEX_ECDH_SHA2_521:\r\n\t\t\tSSH2_ecdh_kex_init(pvar);\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\t// TODO\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\treturn TRUE;\r\n\r\nerror:;\r\n\tbuffer_free(pvar->peer_kex);\r\n\tpvar->peer_kex = NULL;\r\n\r\n\tnotify_fatal_error(pvar, msg, TRUE);\r\n\r\n\treturn FALSE;\r\n}\r\n\r\n\r\n//\r\n// \ufffd\u0152\ufffd DH Groups (RFC 4253, draft-baushke-ssh-dh-group-sha2-04)\r\n//\r\nstatic void SSH2_dh_kex_init(PTInstVar pvar)\r\n{\r\n\tDH *dh = NULL;\r\n\tbuffer_t *msg = NULL;\r\n\tunsigned char *outmsg;\r\n\tint len;\r\n\tBIGNUM *pub_key, *priv_key;\r\n\r\n\t// Diffie-Hellman key agreement\r\n\tswitch (pvar->kex_type) {\r\n\tcase KEX_DH_GRP1_SHA1:\r\n\t\tdh = dh_new_group1();\r\n\t\tbreak;\r\n\tcase KEX_DH_GRP14_SHA1:\r\n\tcase KEX_DH_GRP14_SHA256:\r\n\t\tdh = dh_new_group14();\r\n\t\tbreak;\r\n\tcase KEX_DH_GRP16_SHA512:\r\n\t\tdh = dh_new_group16();\r\n\t\tbreak;\r\n\tcase KEX_DH_GRP18_SHA512:\r\n\t\tdh = dh_new_group18();\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tgoto error;\r\n\t}\r\n\r\n\t// \ufffd\u95a7\ufffd\u0242\ufffd\ufffd\u05c2\ufffd\ufffd\ufffd\ufffd\ufffd(X)\ufffd\ud803\udd90\ufffd\r\n\tdh_gen_key(pvar, dh, pvar->we_need);\r\n\tDH_get0_key(dh, NULL, &priv_key);\r\n\tlog_kex_key(pvar, priv_key);\r\n\r\n\tmsg = buffer_init();\r\n\tif (msg == NULL) {\r\n\t\t// TODO: error check\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\treturn;\r\n\t}\r\n\r\n\tDH_get0_key(dh, &pub_key, NULL);\r\n\tbuffer_put_bignum2(msg, pub_key);\r\n\r\n\tlen = buffer_len(msg);\r\n\toutmsg = begin_send_packet(pvar, SSH2_MSG_KEXDH_INIT, len);\r\n\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\tfinish_send_packet(pvar);\r\n\r\n\tif (pvar->kexdh != NULL) {\r\n\t\tDH_free(pvar->kexdh);\r\n\t}\r\n\tpvar->kexdh = dh;\r\n\r\n\tSSH2_dispatch_init(2);\r\n\tSSH2_dispatch_add_message(SSH2_MSG_KEXDH_REPLY);\r\n\r\n\tbuffer_free(msg);\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_KEXDH_INIT was sent at SSH2_dh_kex_init().\");\r\n\r\n\treturn;\r\n\r\nerror:;\r\n\tDH_free(dh);\r\n\tbuffer_free(msg);\r\n\r\n\tnotify_fatal_error(pvar, \"error occurred @ SSH2_dh_kex_init()\", TRUE);\r\n}\r\n\r\n\r\n\r\n/*\r\n * DH-GEX (RFC 4419)\r\n *\r\n * SSH_MSG_KEY_DH_GEX_REQUEST:\r\n *   byte    SSH_MSG_KEY_DH_GEX_REQUEST (34)\r\n *   uint32  min, minimal size in bits of an acceptable group\r\n *   uint32  n, preferred size in bits of the group the server will send\r\n *   uint32  max, maximal size in bits of an acceptable group\r\n */\r\n\r\nstatic void SSH2_dh_gex_kex_init(PTInstVar pvar)\r\n{\r\n\tbuffer_t *msg = NULL;\r\n\tunsigned char *outmsg;\r\n\tint len;\r\n\tint bits, min, max;\r\n\r\n\tmsg = buffer_init();\r\n\tif (msg == NULL) {\r\n\t\tgoto error;\r\n\t}\r\n\r\n\t// \ufffdT\ufffd[\ufffdo\ufffd\u0257v\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd group size \ufffd\ufffd min, n(preferred), max \ufffd\ufffd\ufffd\ufffd\ufffd\u80b7\ufffd\ufffdB\r\n\tif (pvar->settings.GexMinimalGroupSize == 0) {\r\n\t\t// 0 (\ufffd\ufffd\ufffd\u0752\ufffd) \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u034d\u0150V\ufffd\u0310\ufffd\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffdg\ufffd\ufffd\r\n\t\tmin = GEX_GRP_DEFAULT_MIN;\r\n\t}\r\n\telse if (pvar->settings.GexMinimalGroupSize < GEX_GRP_LIMIT_MIN) {\r\n\t\tmin = GEX_GRP_LIMIT_MIN;\r\n\t\tlogprintf(LOG_LEVEL_NOTICE,\r\n\t\t\t\"%s: small GexMinimalGroupSize is too small (%d), use minimum limit (%d)\", __FUNCTION__,\r\n\t\t\tpvar->settings.GexMinimalGroupSize, GEX_GRP_LIMIT_MIN);\r\n\t}\r\n\telse if (pvar->settings.GexMinimalGroupSize > GEX_GRP_LIMIT_MAX) {\r\n\t\tmin = GEX_GRP_LIMIT_MAX;\r\n\t\tlogprintf(LOG_LEVEL_NOTICE,\r\n\t\t\t\"%s: small GexMinimalGroupSize is too large (%d), use maximum limit (%d)\", __FUNCTION__,\r\n\t\t\tpvar->settings.GexMinimalGroupSize, GEX_GRP_LIMIT_MAX);\r\n\t}\r\n\telse {\r\n\t\tmin = pvar->settings.GexMinimalGroupSize;\r\n\t}\r\n\r\n\t// max \ufffd\u034f\ufffd\u024f\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u03c2\ufffd\r\n\tmax = GEX_GRP_LIMIT_MAX;\r\n\r\n\t// preferred \ufffd\u034eg\ufffdp\ufffd\ufffd\ufffd\ufffde\ufffd\u00cd\ufffd\ufffdv\ufffdf\ufffd\u030c\ufffd\ufffd\ufffd/\ufffdu\ufffd\ufffd\ufffdb\ufffdN\ufffd\ufffd\ufffd\u0302\ufffd\ufffd\ufffd\ufffdA\ufffd\u0151\ufffd\u0302\ufffd\ufffd\u0302\ufffd\ufffdg\ufffd\ufffd\r\n\tbits = dh_estimate(pvar->we_need * 8);\r\n\tif (bits < min) {\r\n\t\tbits = min;\r\n\t}\r\n\telse if (bits > max) {\r\n\t\tbits = max;\r\n\t}\r\n\tif (pvar->server_compat_flag & SSH_BUG_DHGEX_LARGE && bits > 4096) {\r\n\t\tlogprintf(LOG_LEVEL_NOTICE,\r\n\t\t\t\"SSH_BUG_DHGEX_LARGE is enabled. DH-GEX group size is limited to 4096. \"\r\n\t\t\t\"(Original size is %d)\", bits);\r\n\t\tbits = 4096;\r\n\t}\r\n\r\n\t// \ufffdT\ufffd[\ufffdo\ufffd\ufffdgroup size\ufffd\ud805\uddc2\ufffd\ufffd\u0101Ap \ufffd\ufffd g \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u70a4\ufffdB\r\n\tbuffer_put_int(msg, min);\r\n\tbuffer_put_int(msg, bits);\r\n\tbuffer_put_int(msg, max);\r\n\tlen = buffer_len(msg);\r\n\toutmsg = begin_send_packet(pvar, SSH2_MSG_KEX_DH_GEX_REQUEST, len);\r\n\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\tfinish_send_packet(pvar);\r\n\r\n\t// \ufffd\ufffd\ufffd\u0182\u0143n\ufffdb\ufffdV\ufffd\ufffd\ufffdv\ufffdZ\ufffd\u024eg\ufffd\ufffd\ufffd\u0302\u014e\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffdB\r\n\tpvar->kexgex_min = min;\r\n\tpvar->kexgex_bits = bits;\r\n\tpvar->kexgex_max = max;\r\n\r\n\t{\r\n\t\tchar tmp[128];\r\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\r\n\t\t            \"we_need %d min %d bits %d max %d\",\r\n\t\t            pvar->we_need, min, bits, max);\r\n\t\tpush_memdump(\"DH_GEX_REQUEST\", \"requested key bits\", tmp, strlen(tmp));\r\n\t}\r\n\r\n\tSSH2_dispatch_init(2);\r\n\tSSH2_dispatch_add_message(SSH2_MSG_KEX_DH_GEX_GROUP);\r\n\r\n\tbuffer_free(msg);\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_KEX_DH_GEX_REQUEST was sent at SSH2_dh_gex_kex_init().\");\r\n\r\n\treturn;\r\n\r\nerror:;\r\n\tbuffer_free(msg);\r\n\r\n\tnotify_fatal_error(pvar, \"error occurred @ SSH2_dh_gex_kex_init()\", TRUE);\r\n}\r\n\r\n/*\r\n * SSH2_MSG_KEX_DH_GEX_GROUP:\r\n *   byte    SSH_MSG_KEX_DH_GEX_GROUP\r\n *   mpint   p, safe prime\r\n *   mpint   g, generator for subgroup in GF(p)\r\n */\r\nstatic BOOL handle_SSH2_dh_gex_group(PTInstVar pvar)\r\n{\r\n\tint len, grp_bits;\r\n\tBIGNUM *p = NULL, *g = NULL;\r\n\tDH *dh = NULL;\r\n\tbuffer_t *msg = NULL;\r\n\tunsigned char *outmsg;\r\n\tchar tmpbuf[256];\r\n\tBIGNUM *pub_key, *priv_key;\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_KEX_DH_GEX_GROUP was received.\");\r\n\r\n\tp = BN_new();\r\n\tg = BN_new();\r\n\tif (p == NULL || g == NULL)\r\n\t\tgoto error;\r\n\r\n\tif (!get_mpint_from_payload(pvar, p) || !get_mpint_from_payload(pvar, g)) {\r\n\t\t_snprintf_s(tmpbuf, sizeof(tmpbuf), _TRUNCATE,\r\n\t\t\t\t\t\"%s:truncated packet (mpint)\", __FUNCTION__);\r\n\t\tnotify_fatal_error(pvar, tmpbuf, FALSE);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tgrp_bits = BN_num_bits(p);\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"DH-GEX: Request: %d / %d / %d, Received: %d\",\r\n\t            pvar->kexgex_min, pvar->kexgex_bits, pvar->kexgex_max, BN_num_bits(p));\r\n\r\n\t//\r\n\t// (1) < GEX_GRP_LIMIT_MIN <= (2) < kexgex_min <= (3) < kexgex_bits <= (4) <= kexgex_max < (5) <= GEX_GRP_LIMIT_MAX < (6)\r\n\t//\r\n\tif (grp_bits < GEX_GRP_LIMIT_MIN || grp_bits > GEX_GRP_LIMIT_MAX) {\r\n\t// (1), (6) \ufffdv\ufffd\ufffd\ufffdg\ufffdR\ufffd\ufffd\ufffd\u0154F\ufffd\u07c2\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\u0348\ufffd(1024 <= grp_bits <= 8192)\ufffd\u030aO\ufffdB\ufffd\ufffd\ufffd\ufffd\ufffd\u0612f\ufffdB\r\n\t\tUTIL_get_lang_msg(\"MSG_SSH_GEX_SIZE_OUTOFRANGE\", pvar,\r\n\t\t                  \"Received group size is out of range: %d\");\r\n\t\t_snprintf_s(tmpbuf, sizeof(tmpbuf), _TRUNCATE, pvar->UIMsg, grp_bits);\r\n\t\tnotify_fatal_error(pvar, tmpbuf, FALSE);\r\n\t\tgoto error;\r\n\t}\r\n\telse if (grp_bits < pvar->kexgex_min) {\r\n\t// (2) \ufffdv\ufffd\ufffd\ufffdg\ufffdR\ufffd\ufffd\ufffd\u0154F\ufffd\u07c2\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\u0348\u0353\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0310\u0752\u80b5\ufffd\ufffd\ufffd\u014f\ufffd\ufffdl\ufffd\ufffd\u83ec\ufffd\ufffd\ufffd\ufffd\ufffdB\ufffdm\ufffdF\ufffd_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\ufffd\ufffdo\ufffd\ufffd\ufffdB\r\n\t\tlogprintf(LOG_LEVEL_WARNING,\r\n\t\t    \"DH-GEX: grp_bits(%d) < kexgex_min(%d)\", grp_bits, pvar->kexgex_min);\r\n\t\tUTIL_get_lang_msg(\"MSG_SSH_GEX_SIZE_SMALLER\", pvar,\r\n\t\t                  \"Received group size is smaller than the requested minimal size.\\nrequested: %d, received: %d\\nAre you sure that you want to accecpt received group?\");\r\n\t\t_snprintf_s(tmpbuf, sizeof(tmpbuf), _TRUNCATE,\r\n\t\t\tpvar->UIMsg, pvar->kexgex_min, grp_bits);\r\n\t}\r\n\telse if (grp_bits < pvar->kexgex_bits) {\r\n\t// (3) \ufffdv\ufffd\ufffd\ufffd\u030d\u014f\ufffd\ufffdl\ufffd\u0356\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdA\ufffdv\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\u034f\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\ufffdm\ufffdF\ufffd_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\u034fo\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t\tlogprintf(LOG_LEVEL_NOTICE,\r\n\t\t\t\"DH-GEX: grp_bits(%d) < kexgex_bits(%d)\", grp_bits, pvar->kexgex_bits);\r\n\t\ttmpbuf[0] = 0; // no message\r\n\t}\r\n\telse if (grp_bits <= pvar->kexgex_max) {\r\n\t// (4) \ufffdv\ufffd\ufffd\ufffdl\ufffd\u020f\ufffdA\ufffd\ufffd\ufffd\u0097v\ufffd\ufffd\ufffd\u030d\u0151\ufffdl\ufffd\u0209\ufffd\ufffdB\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t\ttmpbuf[0] = 0; // no message\r\n\t}\r\n\telse {\r\n\t// (5) \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0310\u0752\u80b5\ufffd\ufffd\ufffd\u0151\ufffdl\ufffd\ufffd\ufffd\u50ab\ufffd\ufffd\ufffdB\ufffdm\ufffdF\ufffd_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\ufffd\ufffdo\ufffd\ufffd\ufffdB\r\n\t//     \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0142\ufffd kexgex_max == GEX_GRP_LIMIT_MAX(8192) \ufffd\u0142\ufffd\ufffd\ufffd\u05c2\ufffd\ufffd\u030f\udaef\udd42\u0242\u0202\u9396\ufffd\u0356\ufffd\ufffd\ufffd\ufffdB\r\n\t\tlogprintf(LOG_LEVEL_WARNING,\r\n\t\t\t\"DH-GEX: grp_bits(%d) > kexgex_max(%d)\", grp_bits, pvar->kexgex_max);\r\n\t\tUTIL_get_lang_msg(\"MSG_SSH_GEX_SIZE_LARGER\", pvar,\r\n\t\t                  \"Received group size is larger than the requested maximal size.\\nrequested: %d, received: %d\\nAre you sure that you want to accecpt received group?\");\r\n\t\t_snprintf_s(tmpbuf, sizeof(tmpbuf), _TRUNCATE,\r\n\t\t\tpvar->UIMsg, pvar->kexgex_max, grp_bits);\r\n\t}\r\n\r\n\tif (tmpbuf[0] != 0) {\r\n\t\tUTIL_get_lang_msg(\"MSG_SSH_GEX_SIZE_TITLE\", pvar,\r\n\t\t                  \"TTSSH: Confirm GEX group size\");\r\n\t\tif (MessageBox(NULL, tmpbuf, pvar->UIMsg, MB_YESNO | MB_ICONERROR) == IDNO) {\r\n\t\t\tUTIL_get_lang_msg(\"MSG_SSH_GEX_SIZE_CANCEL\", pvar,\r\n\t\t\t                  \"New connection is cancelled.\");\r\n\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, FALSE);\r\n\t\t\tgoto error;\r\n\t\t}\r\n\t}\r\n\r\n\tdh = DH_new();\r\n\tif (dh == NULL)\r\n\t\tgoto error;\r\n\tDH_set0_pqg(dh, p, NULL, g);\r\n\r\n\t// \ufffd\u95a7\ufffd\u0242\ufffd\ufffd\u05c2\ufffd\ufffd\ufffd\ufffd\ufffd(X)\ufffd\ud803\udd90\ufffd\r\n\tdh_gen_key(pvar, dh, pvar->we_need);\r\n\tDH_get0_key(dh, NULL, &priv_key);\r\n\tlog_kex_key(pvar, priv_key);\r\n\r\n\t// \ufffd\ufffd\ufffdJ\ufffd\ufffd\ufffd\ufffd\ufffdT\ufffd[\ufffdo\ufffd\u0591\ufffd\ufffdM\r\n\tmsg = buffer_init();\r\n\tif (msg == NULL) {\r\n\t\tgoto error;\r\n\t}\r\n\tDH_get0_key(dh, &pub_key, NULL);\r\n\tbuffer_put_bignum2(msg, pub_key);\r\n\tlen = buffer_len(msg);\r\n\toutmsg = begin_send_packet(pvar, SSH2_MSG_KEX_DH_GEX_INIT, len);\r\n\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\tfinish_send_packet(pvar);\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_KEX_DH_GEX_INIT was sent at handle_SSH2_dh_gex_group().\");\r\n\r\n\t// \ufffd\ufffd\ufffd\ufffd\ufffd\u014d\uc42c\ufffd\ufffd\ufffd\ufffdDH\ufffd\ufffd\ufffd\u0341A\ufffd\ufffd\ufffd\u0182\u0143n\ufffdb\ufffdV\ufffd\ufffd\ufffdv\ufffdZ\ufffd\u024eg\ufffd\ufffd\ufffd\ufffd\ufffd\u07ce\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffdB(2004.10.31 yutaka)\r\n\tif (pvar->kexdh != NULL) {\r\n\t\tDH_free(pvar->kexdh);\r\n\t}\r\n\tpvar->kexdh = dh;\r\n\r\n\t{\r\n\t\tBIGNUM *p, *q, *pub_key;\r\n\r\n\t\tDH_get0_pqg(dh, &p, &q, NULL);\r\n\t\tDH_get0_key(dh, &pub_key, NULL);\r\n\r\n\t\tpush_bignum_memdump(\"DH_GEX_GROUP\", \"p\", p);\r\n\t\tpush_bignum_memdump(\"DH_GEX_GROUP\", \"g\", g);\r\n\t\tpush_bignum_memdump(\"DH_GEX_GROUP\", \"pub_key\", pub_key);\r\n\t}\r\n\r\n\tSSH2_dispatch_init(2);\r\n\tSSH2_dispatch_add_message(SSH2_MSG_KEX_DH_GEX_REPLY);\r\n\r\n\tbuffer_free(msg);\r\n\r\n\treturn TRUE;\r\n\r\nerror:;\r\n\tBN_free(p);\r\n\tBN_free(g);\r\n\tDH_free(dh);\r\n\r\n\treturn FALSE;\r\n}\r\n\r\n\r\n//\r\n// KEX_ECDH_SHA2_256 or KEX_ECDH_SHA2_384 or KEX_ECDH_SHA2_521\r\n//\r\n\r\nstatic void SSH2_ecdh_kex_init(PTInstVar pvar)\r\n{\r\n\tEC_KEY *client_key = NULL;\r\n\tconst EC_GROUP *group;\r\n\tbuffer_t *msg = NULL;\r\n\tunsigned char *outmsg;\r\n\tint len, ret;\r\n\tchar buf[128];\r\n\r\n\tclient_key = EC_KEY_new();\r\n\tif (client_key == NULL) {\r\n\t\t_snprintf_s(buf, sizeof(buf), _TRUNCATE, \"%s: EC_KEY_new was failed\", __FUNCTION__);\r\n\t\tgoto error;\r\n\t}\r\n\tclient_key = EC_KEY_new_by_curve_name(kextype_to_cipher_nid(pvar->kex_type));\r\n\tif (client_key == NULL) {\r\n\t\t_snprintf_s(buf, sizeof(buf), _TRUNCATE, \"%s: EC_KEY_new_by_curve_name was failed\", __FUNCTION__);\r\n\t\tgoto error;\r\n\t}\r\n\tret = EC_KEY_generate_key(client_key);\r\n\tif (ret != 1) {\r\n\t\t_snprintf_s(buf, sizeof(buf), _TRUNCATE, \"%s: EC_KEY_generate_key was failed(ret %d)\", __FUNCTION__, ret);\r\n\t\tgoto error;\r\n\t}\r\n\tgroup = EC_KEY_get0_group(client_key);\r\n\tlog_kex_key(pvar, EC_KEY_get0_private_key(client_key));\r\n\r\n\tmsg = buffer_init();\r\n\tif (msg == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t_snprintf_s(buf, sizeof(buf), _TRUNCATE, \"%s: buffer_init was failed\", __FUNCTION__);\r\n\t\tgoto error;\r\n\t}\r\n\r\n\tbuffer_put_ecpoint(msg, group, EC_KEY_get0_public_key(client_key));\r\n\r\n\tlen = buffer_len(msg);\r\n\toutmsg = begin_send_packet(pvar, SSH2_MSG_KEX_ECDH_INIT, len);\r\n\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\tfinish_send_packet(pvar);\r\n\r\n\t// \ufffd\ufffd\ufffd\ufffd\ufffd\u014d\uc42c\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0341A\ufffd\ufffd\ufffd\u0182\u0143n\ufffdb\ufffdV\ufffd\ufffd\ufffdv\ufffdZ\ufffd\u024eg\ufffd\ufffd\ufffd\ufffd\ufffd\u07ce\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffdB\r\n\tif (pvar->ecdh_client_key) {\r\n\t\tEC_KEY_free(pvar->ecdh_client_key);\r\n\t}\r\n\tpvar->ecdh_client_key = client_key;\r\n\r\n\tSSH2_dispatch_init(2);\r\n\tSSH2_dispatch_add_message(SSH2_MSG_KEX_ECDH_REPLY);\r\n\r\n\tbuffer_free(msg);\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_KEX_ECDH_INIT was sent at SSH2_ecdh_kex_init().\");\r\n\r\n\treturn;\r\n\r\nerror:;\r\n\tEC_KEY_free(client_key);\r\n\tbuffer_free(msg);\r\n\r\n\tnotify_fatal_error(pvar, buf, TRUE);\r\n}\r\n\r\n\r\nstatic void ssh2_set_newkeys(PTInstVar pvar, int mode)\r\n{\r\n\t// free already allocated buffer\r\n\tif (pvar->ssh2_keys[mode].enc.iv != NULL) {\r\n\t\tfree(pvar->ssh2_keys[mode].enc.iv);\r\n\t}\r\n\tif (pvar->ssh2_keys[mode].enc.key != NULL) {\r\n\t\tfree(pvar->ssh2_keys[mode].enc.key);\r\n\t}\r\n\tif (pvar->ssh2_keys[mode].mac.key != NULL) {\r\n\t\tfree(pvar->ssh2_keys[mode].mac.key);\r\n\t}\r\n\r\n\tpvar->ssh2_keys[mode] = current_keys[mode];\r\n}\r\n\r\nstatic BOOL ssh2_kex_finish(PTInstVar pvar, char *hash, int hashlen, BIGNUM *share_key, Key *hostkey, char *signature, int siglen)\r\n{\r\n\tint ret;\r\n\tchar emsg[1024];  // error message\r\n\r\n\t//debug_print(30, hash, hashlen);\r\n\t//debug_print(31, pvar->client_version_string, strlen(pvar->client_version_string));\r\n\t//debug_print(32, pvar->server_version_string, strlen(pvar->server_version_string));\r\n\t//debug_print(33, buffer_ptr(pvar->my_kex), buffer_len(pvar->my_kex));\r\n\t//debug_print(34, buffer_ptr(pvar->peer_kex), buffer_len(pvar->peer_kex));\r\n\t//debug_print(35, server_host_key_blob, bloblen);\r\n\r\n\t// session id\ufffd\u0315\u06d1\ufffd\ufffdi\ufffd\ufffd\ufffd\ufffd\u0691\ufffd\ufffd\ufffd\ufffd\u0302\u0741j\r\n\tif (pvar->session_id == NULL) {\r\n\t\tpvar->session_id_len = hashlen;\r\n\t\tpvar->session_id = malloc(pvar->session_id_len);\r\n\t\tif (pvar->session_id != NULL) {\r\n\t\t\tmemcpy(pvar->session_id, hash, pvar->session_id_len);\r\n\t\t} else {\r\n\t\t\t// TODO:\r\n\t\t}\r\n\t}\r\n\r\n\tif ((ret = key_verify(hostkey, signature, siglen, hash, hashlen, pvar->hostkey_type)) != 1) {\r\n\t\tif (ret == -3 && hostkey->type == KEY_RSA) {\r\n\t\t\tif (!pvar->settings.EnableRsaShortKeyServer) {\r\n\t\t\t\tBIGNUM *n;\r\n\t\t\t\tRSA_get0_key(hostkey->rsa, &n, NULL, NULL);\r\n\t\t\t\t_snprintf_s(emsg, sizeof(emsg), _TRUNCATE,\r\n\t\t\t\t\t\"%s: key verify error. remote rsa key length is too short (%d-bit)\", __FUNCTION__,\r\n\t\t\t\t\tBN_num_bits(n));\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tgoto cont;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tchar *buf = NULL;\r\n\t\t\tbuf = ToCharW(SENDTOME);\r\n\t\t\t_snprintf_s(emsg, sizeof(emsg), _TRUNCATE, \"%s: key verify error (%d)\\r\\n%s\", __FUNCTION__, ret, buf);\r\n\t\t\tfree(buf);\r\n\t\t}\r\n\r\n\t\tsave_memdump(LOGDUMP);\r\n\t\tnotify_fatal_error(pvar, emsg, TRUE);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\ncont:\r\n\tkex_derive_keys(pvar, current_keys, pvar->we_need, hash, share_key, pvar->session_id, pvar->session_id_len);\r\n\r\n\tprep_compression(pvar);\r\n\r\n\tSSH2_dispatch_init(3);\r\n\tSSH2_dispatch_add_message(SSH2_MSG_NEWKEYS);\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nstatic void ssh2_send_newkeys(PTInstVar pvar)\r\n{\r\n\t// send SSH2_MSG_NEWKEYS\r\n\tbegin_send_packet(pvar, SSH2_MSG_NEWKEYS, 0);\r\n\tfinish_send_packet(pvar);\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: SSH2_MSG_NEWKEYS was sent.\", __FUNCTION__);\r\n\r\n\t// SSH2_MSG_NEWKEYS \ufffd\ud805\uddc2\ufffdI\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u020d~\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffd\u0348\u00cd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdK\ufffdv\ufffd\ufffd\ufffdL\ufffd\ufffd\u05c1A\r\n\t// \ufffd\ufffd\ufffd\u030e\ufffd\ufffd_\ufffd\u0151\ufffd\ufffdM\ufffd\ufffd\ufffd\ufffd\ufffd\u0308\u00cd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdJ\ufffdn\ufffd\ufffd\ufffd\ufffdB\r\n\tssh2_set_newkeys(pvar, MODE_OUT);\r\n\tif (!CRYPT_start_encryption(pvar, 1, 0)) {\r\n\t\t// TODO: error\r\n\t}\r\n\r\n\r\n\t// \ufffd\ufffd\ufffdl\ufffd\u0241AMAC\ufffd\u0183p\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffdk\ufffd\ufffd\ufffd\ufffd\ufffd\u030e\ufffd\ufffd_\ufffd\u0157L\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\ufffdB\r\n\tpvar->ssh2_keys[MODE_OUT].mac.enabled = 1;\r\n\tpvar->ssh2_keys[MODE_OUT].comp.enabled = 1;\r\n\tenable_send_compression(pvar);\r\n\r\n\tpvar->kex_status |= KEX_FLAG_NEWKEYS_SENT;\r\n\r\n\t// SSH2_MSG_NEWKEYS \ufffd\ufffd\ufffd\ufffd\ufffd\u024e\udaca\udfce\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffd\ufffdKEX\ufffd\u034a\ufffd\ufffd\ufffd\ufffdB\ufffd\ufffd\ufffd\u030f\ufffd\ufffd\ufffd\ufffd\u0248\u0682\ufffdB\r\n\tif (pvar->kex_status & KEX_FLAG_NEWKEYS_RECEIVED) {\r\n\t\tif ((pvar->kex_status & KEX_FLAG_REKEYING)) {\r\n\t\t\tdo_SSH2_dispatch_setup_for_transfer(pvar);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd SSH2_MSG_NEWKEYS \ufffd\u0311\ufffd\ufffd\ufffdM\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdA\ufffd\u020d~\ufffd\u0312\u0290M\ufffd\u0348\u00cd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ua0bd\ufffd\ufffd\u0502\u0242\u0202\ufffd\r\n\t\t\tssh2_finish_encryption_setup(pvar);\r\n\r\n\t\t\t// \ufffd\ufffd\ufffd\ufffd\u030c\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0343\ufffd\ufffd[\ufffdU\ufffdF\ufffd\u0602\ufffd\ufffdJ\ufffdn\ufffd\ufffd\ufffd\ufffd\r\n\t\t\tssh2_prep_userauth(pvar);\r\n\t\t}\r\n\t\tpvar->kex_status = KEX_FLAG_KEXDONE;\r\n\t}\r\n\r\n\treturn;\r\n}\r\n\r\n/*\r\n * Diffie-Hellman Key Exchange Reply (SSH2_MSG_KEXDH_REPLY:31)\r\n *\r\n * return TRUE: \ufffd\ufffd\ufffd\ufffd\r\n *        FALSE: \ufffd\ufffd\ufffds\r\n */\r\nstatic BOOL handle_SSH2_dh_kex_reply(PTInstVar pvar)\r\n{\r\n\tchar *data;\r\n\tint len;\r\n\tchar *server_host_key_blob;\r\n\tint bloblen, siglen;\r\n\tBIGNUM *server_public = NULL;\r\n\tchar *signature;\r\n\tint dh_len, share_len;\r\n\tchar *dh_buf = NULL;\r\n\tBIGNUM *share_key = NULL;\r\n\tchar *hash;\r\n\tchar *emsg = NULL, emsg_tmp[1024];  // error message\r\n\tint hashlen;\r\n\tKey *hostkey = NULL;  // hostkey\r\n\tBOOL result = FALSE;\r\n\tBIGNUM *pub_key;\r\n\tint ret;\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_KEXDH_REPLY was received.\");\r\n\r\n\tmemset(&hostkey, 0, sizeof(hostkey));\r\n\r\n\t// \ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd^\ufffdC\ufffdv\ufffd\u030c\ufffd\u0251\ufffd\ufffd\ufffd\ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\u0310\u64ea\r\n\tdata = pvar->ssh_state.payload;\r\n\t// \ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\u0312\ufffd\ufffd\ufffd; \ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd^\ufffdC\ufffdv\ufffd\ufffd\ufffd\ufffd 1 \ufffdo\ufffdC\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\u70b7\r\n\tlen = pvar->ssh_state.payloadlen - 1;\r\n\r\n\t// for debug\r\n\tpush_memdump(\"KEXDH_REPLY\", \"key exchange: receiving\", data, len);\r\n\r\n\tbloblen = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\tserver_host_key_blob = data; // for hash\r\n\r\n\tpush_memdump(\"KEXDH_REPLY\", \"server_host_key_blob\", server_host_key_blob, bloblen);\r\n\r\n\thostkey = key_from_blob(data, bloblen);\r\n\tif (hostkey == NULL) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: key_from_blob error\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\tdata += bloblen;\r\n\r\n\t// known_hosts\ufffd\u0389\ufffd (2006.3.20 yutaka)\r\n\tif (hostkey->type != get_ssh2_hostkey_type_from_algorithm(pvar->hostkey_type)) {  // \ufffdz\ufffdX\ufffdg\ufffdL\ufffd[\ufffd\u030e\ufffd\u0294\ufffdr\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t            \"%s: type mismatch for decoded server_host_key_blob (kex:%s(%s) blob:%s)\",\r\n\t\t            /*__FUNCTION__*/\"handle_SSH2_dh_kex_reply\",\r\n\t\t            get_ssh2_hostkey_type_name_from_algorithm(pvar->hostkey_type),\r\n\t\t            get_ssh2_hostkey_algorithm_name(pvar->hostkey_type),\r\n\t\t            get_ssh2_hostkey_type_name(hostkey->type));\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\r\n\tserver_public = BN_new();\r\n\tif (server_public == NULL) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: Out of memory (1)\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\r\n\tbuffer_get_bignum2(&data, server_public);\r\n\r\n\tsiglen = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\tsignature = data;\r\n\tdata += siglen;\r\n\r\n\tpush_memdump(\"KEXDH_REPLY\", \"signature\", signature, siglen);\r\n\r\n\t// check public key\r\n\tif (!dh_pub_is_valid(pvar->kexdh, server_public)) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: invalid server public key\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\t// \ufffd\ufffd\ufffd\u028c\ufffd\ufffd\u0310\ufffd\ufffd\ufffd\r\n\tdh_len = DH_size(pvar->kexdh);\r\n\tdh_buf = malloc(dh_len);\r\n\tif (dh_buf == NULL) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: Out of memory (2)\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\tshare_len = DH_compute_key(dh_buf, server_public, pvar->kexdh);\r\n\tshare_key = BN_new();\r\n\tif (share_key == NULL) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: Out of memory (3)\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\t// 'share_key'\ufffd\ufffd\ufffdT\ufffd[\ufffdo\ufffd\u0183N\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg\ufffd\u014b\ufffd\ufffdL\ufffd\ufffd\ufffd\u932e\ufffdiG^A\ufffd~B mod P\ufffdj\ufffd\u0182\u0202\ufffdB\r\n\tBN_bin2bn(dh_buf, share_len, share_key);\r\n\t//debug_print(40, dh_buf, share_len);\r\n\r\n\t// \ufffdn\ufffdb\ufffdV\ufffd\ufffd\ufffd\u030cv\ufffdZ\r\n\t/* calc and verify H */\r\n\tDH_get0_key(pvar->kexdh, &pub_key, NULL);\r\n\thash = kex_dh_hash(\r\n\t\tget_kex_algorithm_EVP_MD(pvar->kex_type),\r\n\t\tpvar->client_version_string,\r\n\t\tpvar->server_version_string,\r\n\t\tbuffer_ptr(pvar->my_kex), buffer_len(pvar->my_kex),\r\n\t\tbuffer_ptr(pvar->peer_kex), buffer_len(pvar->peer_kex),\r\n\t\tserver_host_key_blob, bloblen,\r\n\t\tpub_key,\r\n\t\tserver_public,\r\n\t\tshare_key,\r\n\t\t&hashlen);\r\n\r\n\t{\r\n\t\tpush_memdump(\"KEXDH_REPLY kex_dh_kex_hash\", \"my_kex\", buffer_ptr(pvar->my_kex), buffer_len(pvar->my_kex));\r\n\t\tpush_memdump(\"KEXDH_REPLY kex_dh_kex_hash\", \"peer_kex\", buffer_ptr(pvar->peer_kex), buffer_len(pvar->peer_kex));\r\n\r\n\t\tpush_bignum_memdump(\"KEXDH_REPLY kex_dh_kex_hash\", \"server_public\", server_public);\r\n\t\tpush_bignum_memdump(\"KEXDH_REPLY kex_dh_kex_hash\", \"share_key\", share_key);\r\n\r\n\t\tpush_memdump(\"KEXDH_REPLY kex_dh_kex_hash\", \"hash\", hash, hashlen);\r\n\t}\r\n\r\n\t// TTSSH\ufffdo\ufffd[\ufffdW\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0255\\\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdL\ufffd[\ufffdr\ufffdb\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u07c2\u0102\ufffd\ufffd\ufffd\r\n\tDH_get0_key(pvar->kexdh, &pub_key, NULL);\r\n\tpvar->client_key_bits = BN_num_bits(pub_key);\r\n\tpvar->server_key_bits = BN_num_bits(server_public);\r\n\r\n\tresult = ssh2_kex_finish(pvar, hash, hashlen, share_key, hostkey, signature, siglen);\r\n\r\n\tret = HOSTS_check_host_key(pvar, pvar->ssh_state.hostname, pvar->ssh_state.tcpport, hostkey);\r\n\tif (ret == TRUE) {\r\n\t\t// \ufffdz\ufffdX\ufffdg\ufffd\ufffd\ufffd\u030am\ufffdF\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\u3471\ufffd\u030f\ufffd\ufffd\ufffd\ufffd\ufffd\ufffds\ufffd\ufffd\r\n\t\tSSH_notify_host_OK(pvar);\r\n\t\t// known_hosts\ufffd_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\u030c\u0102\u044fo\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\u020d~\ufffdA\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t}\r\n\r\nerror:\r\n\tBN_free(server_public);\r\n\tDH_free(pvar->kexdh); pvar->kexdh = NULL;\r\n\tkey_free(hostkey);\r\n\tfree(dh_buf);\r\n\tBN_free(share_key);\r\n\r\n\tif (emsg)\r\n\t\tnotify_fatal_error(pvar, emsg, TRUE);\r\n\r\n\treturn result;\r\n}\r\n\r\n/*\r\n * Diffie-Hellman Group and Key Exchange Reply (SSH2_MSG_KEX_DH_GEX_REPLY:33)\r\n *\r\n * return TRUE: \ufffd\ufffd\ufffd\ufffd\r\n *        FALSE: \ufffd\ufffd\ufffds\r\n */\r\nstatic BOOL handle_SSH2_dh_gex_reply(PTInstVar pvar)\r\n{\r\n\tchar *data;\r\n\tint len;\r\n\tchar *server_host_key_blob;\r\n\tint bloblen, siglen;\r\n\tBIGNUM *server_public = NULL;\r\n\tchar *signature;\r\n\tint dh_len, share_len;\r\n\tchar *dh_buf = NULL;\r\n\tBIGNUM *share_key = NULL;\r\n\tchar *hash;\r\n\tchar *emsg = NULL, emsg_tmp[1024];  // error message\r\n\tint hashlen;\r\n\tKey *hostkey = NULL;  // hostkey\r\n\tBOOL result = FALSE;\r\n\tint ret;\r\n\tBIGNUM *p, *g;\r\n\tBIGNUM *pub_key;\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_KEX_DH_GEX_REPLY was received.\");\r\n\r\n\tmemset(&hostkey, 0, sizeof(hostkey));\r\n\r\n\t// \ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd^\ufffdC\ufffdv\ufffd\u030c\ufffd\u0251\ufffd\ufffd\ufffd\ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\u0310\u64ea\r\n\tdata = pvar->ssh_state.payload;\r\n\t// \ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\u0312\ufffd\ufffd\ufffd; \ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd^\ufffdC\ufffdv\ufffd\ufffd\ufffd\ufffd 1 \ufffdo\ufffdC\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\u70b7\r\n\tlen = pvar->ssh_state.payloadlen - 1;\r\n\r\n\t// for debug\r\n\tpush_memdump(\"DH_GEX_REPLY\", \"key exchange: receiving\", data, len);\r\n\r\n\tbloblen = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\tserver_host_key_blob = data; // for hash\r\n\r\n\tpush_memdump(\"DH_GEX_REPLY\", \"server_host_key_blob\", server_host_key_blob, bloblen);\r\n\r\n\thostkey = key_from_blob(data, bloblen);\r\n\tif (hostkey == NULL) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: key_from_blob error\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\tdata += bloblen;\r\n\r\n\t// known_hosts\ufffd\u0389\ufffd (2006.3.20 yutaka)\r\n\tif (hostkey->type != get_ssh2_hostkey_type_from_algorithm(pvar->hostkey_type)) {  // \ufffdz\ufffdX\ufffdg\ufffdL\ufffd[\ufffd\u030e\ufffd\u0294\ufffdr\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t            \"%s: type mismatch for decoded server_host_key_blob (kex:%s(%s) blob:%s)\",\r\n\t\t            /*__FUNCTION__*/\"handle_SSH2_dh_gex_reply\",\r\n\t\t            get_ssh2_hostkey_type_name_from_algorithm(pvar->hostkey_type),\r\n\t\t            get_ssh2_hostkey_algorithm_name(pvar->hostkey_type),\r\n\t\t            get_ssh2_hostkey_type_name(hostkey->type));\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\r\n\tserver_public = BN_new();\r\n\tif (server_public == NULL) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: Out of memory (1)\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\r\n\tbuffer_get_bignum2(&data, server_public);\r\n\r\n\tsiglen = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\tsignature = data;\r\n\tdata += siglen;\r\n\r\n\tpush_memdump(\"DH_GEX_REPLY\", \"signature\", signature, siglen);\r\n\r\n\t// check public key\r\n\tif (!dh_pub_is_valid(pvar->kexdh, server_public)) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: invalid server public key\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\t// \ufffd\ufffd\ufffd\u028c\ufffd\ufffd\u0310\ufffd\ufffd\ufffd\r\n\tdh_len = DH_size(pvar->kexdh);\r\n\tdh_buf = malloc(dh_len);\r\n\tif (dh_buf == NULL) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: Out of memory (2)\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\tshare_len = DH_compute_key(dh_buf, server_public, pvar->kexdh);\r\n\tshare_key = BN_new();\r\n\tif (share_key == NULL) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: Out of memory (3)\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\t// 'share_key'\ufffd\ufffd\ufffdT\ufffd[\ufffdo\ufffd\u0183N\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg\ufffd\u014b\ufffd\ufffdL\ufffd\ufffd\ufffd\u932e\ufffdiG^A\ufffd~B mod P\ufffdj\ufffd\u0182\u0202\ufffdB\r\n\tBN_bin2bn(dh_buf, share_len, share_key);\r\n\t//debug_print(40, dh_buf, share_len);\r\n\r\n\t// \ufffdn\ufffdb\ufffdV\ufffd\ufffd\ufffd\u030cv\ufffdZ\r\n\t/* calc and verify H */\r\n\tDH_get0_pqg(pvar->kexdh, &p, NULL, &g);\r\n\tDH_get0_key(pvar->kexdh, &pub_key, NULL);\r\n\thash = kex_dh_gex_hash(\r\n\t\tget_kex_algorithm_EVP_MD(pvar->kex_type),\r\n\t\tpvar->client_version_string,\r\n\t\tpvar->server_version_string,\r\n\t\tbuffer_ptr(pvar->my_kex), buffer_len(pvar->my_kex),\r\n\t\tbuffer_ptr(pvar->peer_kex), buffer_len(pvar->peer_kex),\r\n\t\tserver_host_key_blob, bloblen,\r\n\t\tpvar->kexgex_min,\r\n\t\tpvar->kexgex_bits,\r\n\t\tpvar->kexgex_max,\r\n\t\tp,\r\n\t\tg,\r\n\t\tpub_key,\r\n\t\tserver_public,\r\n\t\tshare_key,\r\n\t\t&hashlen);\r\n\r\n\t{\r\n\t\tpush_memdump(\"DH_GEX_REPLY kex_dh_gex_hash\", \"my_kex\", buffer_ptr(pvar->my_kex), buffer_len(pvar->my_kex));\r\n\t\tpush_memdump(\"DH_GEX_REPLY kex_dh_gex_hash\", \"peer_kex\", buffer_ptr(pvar->peer_kex), buffer_len(pvar->peer_kex));\r\n\r\n\t\tpush_bignum_memdump(\"DH_GEX_REPLY kex_dh_gex_hash\", \"server_public\", server_public);\r\n\t\tpush_bignum_memdump(\"DH_GEX_REPLY kex_dh_gex_hash\", \"share_key\", share_key);\r\n\r\n\t\tpush_memdump(\"DH_GEX_REPLY kex_dh_gex_hash\", \"hash\", hash, hashlen);\r\n\t}\r\n\r\n\t// TTSSH\ufffdo\ufffd[\ufffdW\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0255\\\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdL\ufffd[\ufffdr\ufffdb\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u07c2\u0102\ufffd\ufffd\ufffd\r\n\tDH_get0_key(pvar->kexdh, &pub_key, NULL);\r\n\tpvar->client_key_bits = BN_num_bits(pub_key);\r\n\tpvar->server_key_bits = BN_num_bits(server_public);\r\n\r\n\tresult = ssh2_kex_finish(pvar, hash, hashlen, share_key, hostkey, signature, siglen);\r\n\r\n\tret = HOSTS_check_host_key(pvar, pvar->ssh_state.hostname, pvar->ssh_state.tcpport, hostkey);\r\n\tif (ret == TRUE) {\r\n\t\t// \ufffdz\ufffdX\ufffdg\ufffd\ufffd\ufffd\u030am\ufffdF\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\u3471\ufffd\u030f\ufffd\ufffd\ufffd\ufffd\ufffd\ufffds\ufffd\ufffd\r\n\t\tSSH_notify_host_OK(pvar);\r\n\t\t// known_hosts\ufffd_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\u030c\u0102\u044fo\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\u020d~\ufffdA\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t}\r\n\r\nerror:\r\n\tBN_free(server_public);\r\n\tDH_free(pvar->kexdh); pvar->kexdh = NULL;\r\n\tkey_free(hostkey);\r\n\tfree(dh_buf);\r\n\tBN_free(share_key);\r\n\r\n\tif (emsg)\r\n\t\tnotify_fatal_error(pvar, emsg, TRUE);\r\n\r\n\treturn result;\r\n}\r\n\r\n\r\n/*\r\n * Elliptic Curve Diffie-Hellman Key Exchange Reply (SSH2_MSG_KEX_ECDH_REPLY:31)\r\n *\r\n * return TRUE: \ufffd\ufffd\ufffd\ufffd\r\n *        FALSE: \ufffd\ufffd\ufffds\r\n */\r\nstatic BOOL handle_SSH2_ecdh_kex_reply(PTInstVar pvar)\r\n{\r\n\tchar *data;\r\n\tint len;\r\n\tchar *server_host_key_blob;\r\n\tint bloblen, siglen;\r\n\tEC_POINT *server_public = NULL;\r\n\tconst EC_GROUP *group;\r\n\tchar *signature;\r\n\tint ecdh_len;\r\n\tchar *ecdh_buf = NULL;\r\n\tBIGNUM *share_key = NULL;\r\n\tchar *hash;\r\n\tchar *emsg = NULL, emsg_tmp[1024];  // error message\r\n\tint hashlen;\r\n\tKey *hostkey = NULL;  // hostkey\r\n\tBOOL result = FALSE;\r\n\tint ret;\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_KEX_ECDH_REPLY was received.\");\r\n\r\n\tmemset(&hostkey, 0, sizeof(hostkey));\r\n\r\n\t// \ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd^\ufffdC\ufffdv\ufffd\u030c\ufffd\u0251\ufffd\ufffd\ufffd\ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\u0310\u64ea\r\n\tdata = pvar->ssh_state.payload;\r\n\t// \ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\u0312\ufffd\ufffd\ufffd; \ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd^\ufffdC\ufffdv\ufffd\ufffd\ufffd\ufffd 1 \ufffdo\ufffdC\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\u70b7\r\n\tlen = pvar->ssh_state.payloadlen - 1;\r\n\r\n\t// for debug\r\n\tpush_memdump(\"KEX_ECDH_REPLY\", \"key exchange: receiving\", data, len);\r\n\r\n\tbloblen = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\tserver_host_key_blob = data; // for hash\r\n\r\n\tpush_memdump(\"KEX_ECDH_REPLY\", \"server_host_key_blob\", server_host_key_blob, bloblen);\r\n\r\n\thostkey = key_from_blob(data, bloblen);\r\n\tif (hostkey == NULL) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: key_from_blob error\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\tdata += bloblen;\r\n\r\n\t// known_hosts\ufffd\u0389\ufffd (2006.3.20 yutaka)\r\n\tif (hostkey->type != get_ssh2_hostkey_type_from_algorithm(pvar->hostkey_type)) {  // \ufffdz\ufffdX\ufffdg\ufffdL\ufffd[\ufffd\u030e\ufffd\u0294\ufffdr\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t            \"%s: type mismatch for decoded server_host_key_blob (kex:%s(%s) blob:%s)\",\r\n\t\t            /*__FUNCTION__*/\"handle_SSH2_ecdh_kex_reply\",\r\n\t\t            get_ssh2_hostkey_type_name_from_algorithm(pvar->hostkey_type),\r\n\t\t            get_ssh2_hostkey_algorithm_name(pvar->hostkey_type),\r\n\t\t            get_ssh2_hostkey_type_name(hostkey->type));\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\r\n\t/* Q_S, server public key */\r\n\tgroup = EC_KEY_get0_group(pvar->ecdh_client_key);\r\n\tserver_public = EC_POINT_new(group);\r\n\tif (server_public == NULL) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: Out of memory (1)\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\r\n\tbuffer_get_ecpoint(&data, group, server_public);\r\n\r\n\tsiglen = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\tsignature = data;\r\n\tdata += siglen;\r\n\r\n\tpush_memdump(\"KEX_ECDH_REPLY\", \"signature\", signature, siglen);\r\n\r\n\t// check public key\r\n\tif (key_ec_validate_public(group, server_public) != 0) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: invalid server public key\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\t// \ufffd\ufffd\ufffd\u028c\ufffd\ufffd\u0310\ufffd\ufffd\ufffd\r\n\tecdh_len = (EC_GROUP_get_degree(group) + 7) / 8;\r\n\tecdh_buf = malloc(ecdh_len);\r\n\tif (ecdh_buf == NULL) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: Out of memory (2)\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\tif (ECDH_compute_key(ecdh_buf, ecdh_len, server_public,\r\n\t                     pvar->ecdh_client_key, NULL) != (int)ecdh_len) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: Out of memory (3)\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\tshare_key = BN_new();\r\n\tif (share_key == NULL) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: Out of memory (4)\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\t// 'share_key'\ufffd\ufffd\ufffdT\ufffd[\ufffdo\ufffd\u0183N\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg\ufffd\u014b\ufffd\ufffdL\ufffd\ufffd\ufffd\u932e\ufffdiG^A\ufffd~B mod P\ufffdj\ufffd\u0182\u0202\ufffdB\r\n\tBN_bin2bn(ecdh_buf, ecdh_len, share_key);\r\n\t//debug_print(40, ecdh_buf, ecdh_len);\r\n\r\n\t// \ufffdn\ufffdb\ufffdV\ufffd\ufffd\ufffd\u030cv\ufffdZ\r\n\t/* calc and verify H */\r\n\thash = kex_ecdh_hash(\r\n\t\tget_kex_algorithm_EVP_MD(pvar->kex_type),\r\n\t\tgroup,\r\n\t\tpvar->client_version_string,\r\n\t\tpvar->server_version_string,\r\n\t\tbuffer_ptr(pvar->my_kex), buffer_len(pvar->my_kex),\r\n\t\tbuffer_ptr(pvar->peer_kex), buffer_len(pvar->peer_kex),\r\n\t\tserver_host_key_blob, bloblen,\r\n\t\tEC_KEY_get0_public_key(pvar->ecdh_client_key),\r\n\t\tserver_public,\r\n\t\tshare_key,\r\n\t\t&hashlen);\r\n\r\n\t{\r\n\t\tpush_memdump(\"KEX_ECDH_REPLY ecdh_kex_reply\", \"my_kex\", buffer_ptr(pvar->my_kex), buffer_len(pvar->my_kex));\r\n\t\tpush_memdump(\"KEX_ECDH_REPLY ecdh_kex_reply\", \"peer_kex\", buffer_ptr(pvar->peer_kex), buffer_len(pvar->peer_kex));\r\n\r\n\t\tpush_bignum_memdump(\"KEX_ECDH_REPLY ecdh_kex_reply\", \"share_key\", share_key);\r\n\r\n\t\tpush_memdump(\"KEX_ECDH_REPLY ecdh_kex_reply\", \"hash\", hash, hashlen);\r\n\t}\r\n\r\n\t// TTSSH\ufffdo\ufffd[\ufffdW\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0255\\\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdL\ufffd[\ufffdr\ufffdb\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u07c2\u0102\ufffd\ufffd\ufffd\r\n\tswitch (pvar->kex_type) {\r\n\t\tcase KEX_ECDH_SHA2_256:\r\n\t\t\tpvar->client_key_bits = 256;\r\n\t\t\tpvar->server_key_bits = 256;\r\n\t\t\tbreak;\r\n\t\tcase KEX_ECDH_SHA2_384:\r\n\t\t\tpvar->client_key_bits = 384;\r\n\t\t\tpvar->server_key_bits = 384;\r\n\t\t\tbreak;\r\n\t\tcase KEX_ECDH_SHA2_521:\r\n\t\t\tpvar->client_key_bits = 521;\r\n\t\t\tpvar->server_key_bits = 521;\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\t// TODO\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\tresult = ssh2_kex_finish(pvar, hash, hashlen, share_key, hostkey, signature, siglen);\r\n\r\n\tret = HOSTS_check_host_key(pvar, pvar->ssh_state.hostname, pvar->ssh_state.tcpport, hostkey);\r\n\tif (ret == TRUE) {\r\n\t\t// \ufffdz\ufffdX\ufffdg\ufffd\ufffd\ufffd\u030am\ufffdF\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\u3471\ufffd\u030f\ufffd\ufffd\ufffd\ufffd\ufffd\ufffds\ufffd\ufffd\r\n\t\tSSH_notify_host_OK(pvar);\r\n\t\t// known_hosts\ufffd_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\u030c\u0102\u044fo\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\u020d~\ufffdA\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t}\r\n\r\nerror:\r\n\tEC_POINT_clear_free(server_public);\r\n\tEC_KEY_free(pvar->ecdh_client_key); pvar->ecdh_client_key = NULL;\r\n\tkey_free(hostkey);\r\n\tfree(ecdh_buf);\r\n\tBN_free(share_key);\r\n\r\n\tif (emsg)\r\n\t\tnotify_fatal_error(pvar, emsg, TRUE);\r\n\r\n\treturn result;\r\n}\r\n\r\n\r\n// KEX\ufffd\u0242\ufffd\ufffd\ufffd\ufffd\u0103T\ufffd[\ufffdo\ufffd\ufffd\ufffd\ufffd\u0502\ufffd\ufffd\u0102\ufffd\ufffd\ufffd 31 \ufffd\u0503\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd\u0251\u0382\ufffd\ufffd\ufffdn\ufffd\ufffd\ufffdh\ufffd\ufffd\r\nstatic BOOL handle_SSH2_dh_common_reply(PTInstVar pvar)\r\n{\r\n\tswitch (pvar->kex_type) {\r\n\t\tcase KEX_DH_GRP1_SHA1:\r\n\t\tcase KEX_DH_GRP14_SHA1:\r\n\t\tcase KEX_DH_GRP14_SHA256:\r\n\t\tcase KEX_DH_GRP16_SHA512:\r\n\t\tcase KEX_DH_GRP18_SHA512:\r\n\t\t\thandle_SSH2_dh_kex_reply(pvar);\r\n\t\t\tbreak;\r\n\t\tcase KEX_DH_GEX_SHA1:\r\n\t\tcase KEX_DH_GEX_SHA256:\r\n\t\t\thandle_SSH2_dh_gex_group(pvar);\r\n\t\t\tbreak;\r\n\t\tcase KEX_ECDH_SHA2_256:\r\n\t\tcase KEX_ECDH_SHA2_384:\r\n\t\tcase KEX_ECDH_SHA2_521:\r\n\t\t\thandle_SSH2_ecdh_kex_reply(pvar);\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\t// TODO\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n\r\nstatic void do_SSH2_dispatch_setup_for_transfer(PTInstVar pvar)\r\n{\r\n\tpvar->kex_status = KEX_FLAG_KEXDONE;\r\n\r\n\tSSH2_dispatch_init(6);\r\n\tSSH2_dispatch_add_range_message(SSH2_MSG_GLOBAL_REQUEST, SSH2_MSG_CHANNEL_FAILURE);\r\n\tSSH2_dispatch_add_message(SSH2_MSG_KEXINIT);\r\n}\r\n\r\n\r\nstatic BOOL handle_SSH2_newkeys(PTInstVar pvar)\r\n{\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_NEWKEYS was received(DH key generation is completed).\");\r\n\r\n\t// \ufffd\ufffd\ufffdO\ufffd\u030e\ufffd\u030fI\ufffd\ufffd (2005.3.7 yutaka)\r\n\tif (LogLevel(pvar, LOG_LEVEL_SSHDUMP)) {\r\n\t\tsave_memdump(LOGDUMP);\r\n\t}\r\n\tfinish_memdump();\r\n\r\n\tpvar->kex_status |= KEX_FLAG_NEWKEYS_RECEIVED;\r\n\r\n\t// SSH2_MSG_NEWKEYS \ufffd\ufffdM\ufffd\ufffd\u0351\ufffd\ufffd\u80a9\ufffd\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffd\u0348\u00cd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\u0302\u0141A\r\n\t// \ufffd\ufffdM\ufffd\ufffd\ufffd\ufffd\ufffd\u0308\u00cd\ufffd\ufffd\ufffd(\ufffd\ufffd\ufffd\ufffd)\ufffd\ufffdL\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\ufffdB\r\n\tssh2_set_newkeys(pvar, MODE_IN);\r\n\tif (!CRYPT_start_encryption(pvar, 0, 1)) {\r\n\t\t// TODO: error\r\n\t}\r\n\r\n\t// \ufffd\ufffd\ufffdl\ufffd\u0241AMAC\ufffd\ufffd\ufffd\ufffd\u0448\ufffd\ufffdk\ufffd\ufffdL\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\ufffdB\r\n\tpvar->ssh2_keys[MODE_IN].mac.enabled = 1;\r\n\tpvar->ssh2_keys[MODE_IN].comp.enabled = 1;\r\n\tenable_recv_compression(pvar);\r\n\r\n\tSSH2_dispatch_add_message(SSH2_MSG_EXT_INFO);\r\n\r\n\t// SSH2_MSG_NEWKEYS \ufffd\ufffd\ufffd\ufffd\ufffd\u0251\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffd\ufffdKEX\ufffd\u034a\ufffd\ufffd\ufffd\ufffdB\ufffd\ufffd\ufffd\u030f\ufffd\ufffd\ufffd\ufffd\u0248\u0682\ufffdB\r\n\tif (pvar->kex_status & KEX_FLAG_NEWKEYS_SENT) {\r\n\t\tif (pvar->kex_status & KEX_FLAG_REKEYING) {\r\n\t\t\tint i;\r\n\t\t\tChannel_t *c;\r\n\r\n\t\t\tdo_SSH2_dispatch_setup_for_transfer(pvar);\r\n\r\n\t\t\t// \ufffd\ufffd\ufffd\u70b8\ufffdo\ufffdb\ufffdt\ufffd@\ufffd\u0255\u06d1\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdf\ufffd[\ufffd^\ufffd\ud805\uddc2\ufffd\r\n\t\t\tfor (i = 0 ; i < CHANNEL_MAX ; i++) {\r\n\t\t\t\tc = &channels[i];\r\n\t\t\t\tif (c->used) {\r\n\t\t\t\t\tssh2_channel_retry_send_bufchain(pvar, c);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd SSH2_MSG_NEWKEYS \ufffd\u0311\ufffd\ufffd\ufffdM\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdA\ufffd\u020d~\ufffd\u0312\u0290M\ufffd\u0348\u00cd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ua0bd\ufffd\ufffd\u0502\u0242\u0202\ufffd\r\n\t\t\tssh2_finish_encryption_setup(pvar);\r\n\r\n\t\t\t// \ufffd\ufffd\ufffd\ufffd\u030c\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0343\ufffd\ufffd[\ufffdU\ufffdF\ufffd\u0602\ufffd\ufffdJ\ufffdn\ufffd\ufffd\ufffd\ufffd\r\n\t\t\tssh2_prep_userauth(pvar);\r\n\t\t}\r\n\t\tpvar->kex_status = KEX_FLAG_KEXDONE;\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nstatic void ssh2_prep_userauth(PTInstVar pvar)\r\n{\r\n\tint type = (1 << SSH_AUTH_PASSWORD) | (1 << SSH_AUTH_RSA) |\r\n\t           (1 << SSH_AUTH_TIS) | (1 << SSH_AUTH_PAGEANT);\r\n\r\n\t// \ufffdF\ufffd\u0615\ufffd\ufffd\ufffd\ufffd\u0310\u0752\ufffd\r\n\tAUTH_set_supported_auth_types(pvar, type);\r\n\r\n\t// \ufffdF\ufffd\u0603_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\ufffd\\\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\tAUTH_advance_to_next_cred(pvar);\r\n}\r\n\r\n// \ufffd\ufffd\ufffd[\ufffdU\ufffdF\ufffd\u0602\u030aJ\ufffdn\r\nBOOL do_SSH2_userauth(PTInstVar pvar)\r\n{\r\n\tbuffer_t *msg;\r\n\tchar *s;\r\n\tunsigned char *outmsg;\r\n\tint len;\r\n\r\n\t// \ufffdp\ufffdX\ufffd\ufffd\ufffd[\ufffdh\ufffd\ufffd\ufffd\ufffd\ufffd\u0342\ufffd\ufffd\ua0bd\ufffd\ufffd 1 \ufffd\ud81e\uddc2\u0102\ufffd (2005.3.12 yutaka)\r\n\tpvar->keyboard_interactive_password_input = 0;\r\n\r\n\t// \ufffd\ufffd\ufffd\u0142\u0243\ufffd\ufffdO\ufffdC\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffds\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ua347\ufffd\u0341ASSH2_MSG_SERVICE_REQUEST\ufffd\u0311\ufffd\ufffdM\ufffd\ufffd\r\n\t// \ufffd\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffd\u0182\u0242\ufffd\ufffd\ufffdBOpenSSH\ufffd\u0142\u034ex\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffdATru64 UNIX\ufffd\u0142\u0343T\ufffd[\ufffdo\ufffdG\ufffd\ufffd\ufffd[\ufffd\u0182\u0202\ufffd\ufffd\u0102\ufffd\ufffd\u0702\ufffd\ufffd\ufffd\ufffd\u07c1B\r\n\t// (2005.3.10 yutaka)\r\n\t// Cisco 12.4.11T \ufffd\u0142\ufffd\ufffd\ufffd\ufffd\u030c\ufffd\ufffd\u06c2\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0357l\ufffdB\r\n\t// \ufffdF\ufffd\u0603\ufffd\ufffd\\\ufffdb\ufffdh none \ufffd\u030e\ufffd\ufffd_\ufffd\ufffd SSH2_MSG_SERVICE_REQUEST \ufffd\ud805\uddd0M\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffdB\r\n\t// (2007.10.26 maya)\r\n\tif (pvar->userauth_retry_count > 0\r\n\t || pvar->tryed_ssh2_authlist == TRUE) {\r\n\t\treturn do_SSH2_authrequest(pvar);\r\n\t\t/* NOT REACHED */\r\n\t}\r\n\r\n\t// start user authentication\r\n\tmsg = buffer_init();\r\n\tif (msg == NULL) {\r\n\t\t// TODO: error check\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\treturn FALSE;\r\n\t}\r\n\ts = \"ssh-userauth\";\r\n\tbuffer_put_string(msg, s, strlen(s));\r\n\t//buffer_put_padding(msg, 32); // XXX:\r\n\tlen = buffer_len(msg);\r\n\toutmsg = begin_send_packet(pvar, SSH2_MSG_SERVICE_REQUEST, len);\r\n\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\tfinish_send_packet(pvar);\r\n\tbuffer_free(msg);\r\n\r\n\tSSH2_dispatch_init(4);\r\n\tSSH2_dispatch_add_message(SSH2_MSG_SERVICE_ACCEPT);\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_SERVICE_REQUEST was sent at do_SSH2_userauth().\");\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n\r\nstatic BOOL handle_SSH2_service_accept(PTInstVar pvar)\r\n{\r\n\tchar *data, *svc;\r\n\r\n\t// 6byte\ufffdi\ufffdT\ufffdC\ufffdY\ufffd{\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd{\ufffd^\ufffdC\ufffdv\ufffdj\ufffd\ufffd\ufffd\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffd\u020d~\ufffd\u0303y\ufffdC\ufffd\ufffd\ufffd[\ufffdh\r\n\tdata = pvar->ssh_state.payload;\r\n\r\n\tif ((svc = buffer_get_string(&data, NULL)) == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_get_string returns NULL.\", __FUNCTION__);\r\n\t}\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"SSH2_MSG_SERVICE_ACCEPT was received. service-name=%s\", NonNull(svc));\r\n\tfree(svc);\r\n\r\n\tSSH2_dispatch_init(5);\r\n\tif (pvar->auth_state.cur_cred.method == SSH_AUTH_TIS) {\r\n\t\t// keyboard-interactive method\r\n\t\tSSH2_dispatch_add_message(SSH2_MSG_USERAUTH_INFO_REQUEST);\r\n\t}\r\n\telse if (pvar->auth_state.cur_cred.method == SSH_AUTH_PAGEANT) {\r\n\t\t// Pageant\r\n\t\tSSH2_dispatch_add_message(SSH2_MSG_USERAUTH_PK_OK);\r\n\t}\r\n\telse if (pvar->auth_state.cur_cred.method == SSH_AUTH_PASSWORD) {\r\n\t\tSSH2_dispatch_add_message(SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ);\r\n\t}\r\n\tSSH2_dispatch_add_message(SSH2_MSG_USERAUTH_SUCCESS);\r\n\tSSH2_dispatch_add_message(SSH2_MSG_USERAUTH_FAILURE);\r\n\tSSH2_dispatch_add_message(SSH2_MSG_USERAUTH_BANNER);\r\n\tSSH2_dispatch_add_message(SSH2_MSG_EXT_INFO);\r\n\r\n\treturn do_SSH2_authrequest(pvar);\r\n}\r\n\r\n\r\n/*\r\n * SSH_MSG_EXT_INFO:\r\n *     byte       SSH_MSG_EXT_INFO (value 7)\r\n *     uint32     nr-extensions\r\n *     repeat the following 2 fields \"nr-extensions\" times:\r\n *       string   extension-name\r\n *       string   extension-value (binary)\r\n */\r\n\r\nstatic BOOL handle_SSH2_ext_info(PTInstVar pvar)\r\n{\r\n\tunsigned int num_of_exts, i, len;\r\n\tunsigned char ext_name[256], ext_val[2048];\r\n\tchar *new_payload_buffer = NULL;\r\n\r\n\tlogputs(LOG_LEVEL_INFO, \"SSH2_EXT_INFO was received.\");\r\n\r\n\tif (!get_uint32_from_payload(pvar, &num_of_exts)) {\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: ext info payload was corrupted\", __FUNCTION__);\r\n\t\treturn FALSE;\r\n\t}\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: %d extensions\", __FUNCTION__, num_of_exts);\r\n\r\n\tfor (i=0; i<num_of_exts; i++) {\r\n\t\tif (!get_string_from_payload(pvar, ext_name, sizeof(ext_name), &len, TRUE)) {\r\n\t\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: can't get extension name\", __FUNCTION__);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\tif (strcmp(ext_name, \"server-sig-algs\") == 0) {\r\n\t\t\tif (!get_namelist_from_payload(pvar, ext_val, sizeof(ext_val), &len)) {\r\n\t\t\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: can't get extension value\", __FUNCTION__);\r\n\t\t\t\treturn FALSE;\r\n\t\t\t}\r\n\t\t\tif (pvar->server_sig_algs) {\r\n\t\t\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: update server-sig-algs, old=%s, new=%s\",\r\n\t\t\t\t          __FUNCTION__, pvar->server_sig_algs, ext_val);\r\n\t\t\t\tfree(pvar->server_sig_algs);\r\n\t\t\t}\r\n\t\t\tpvar->server_sig_algs = _strdup(ext_val);\r\n\t\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: extension: server-sig-algs, value: %s\", __FUNCTION__, ext_val);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (!get_string_from_payload(pvar, ext_val, sizeof(ext_val), &len, TRUE)) {\r\n\t\t\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: can't get extension value\", __FUNCTION__);\r\n\t\t\t\treturn FALSE;\r\n\t\t\t}\r\n\t\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: extension: ext_name\", __FUNCTION__, ext_name);\r\n\t\t}\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n// \ufffd\ufffd\ufffd[\ufffdU\ufffdF\ufffd\u0603p\ufffdP\ufffdb\ufffdg\ufffd\u030d\\\ufffdz\r\nBOOL do_SSH2_authrequest(PTInstVar pvar)\r\n{\r\n\tbuffer_t *msg = NULL;\r\n\tchar *s, *username;\r\n\tunsigned char *outmsg;\r\n\tint len;\r\n\tchar *connect_id = \"ssh-connection\";\r\n\r\n\tmsg = buffer_init();\r\n\tif (msg == NULL) {\r\n\t\t// TODO: error check\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\t// \ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\u030d\\\ufffdz\r\n\tusername = pvar->auth_state.user;  // \ufffd\ufffd\ufffd[\ufffdU\ufffd\ufffd\r\n\tbuffer_put_string(msg, username, strlen(username));\r\n\tbuffer_put_string(msg, connect_id, strlen(connect_id));\r\n\r\n\tif (!pvar->tryed_ssh2_authlist) { // \"none\"\ufffd\ufffd\ufffd\\\ufffdb\ufffdh\ufffd\u0311\ufffd\ufffdM\r\n\t\t// \ufffdF\ufffd\u0603\ufffd\ufffdX\ufffdg\ufffd\ufffd\ufffdT\ufffd[\ufffdo\ufffd\ufffd\ufffd\ufffd\u64fe\ufffd\ufffd\ufffd\ufffdB\r\n\t\t// SSH2_MSG_USERAUTH_FAILURE\ufffd\ufffd\ufffd\u0502\u90aa\ufffdA\ufffdT\ufffd[\ufffdo\ufffd\u0242\u0343\ufffd\ufffdO\ufffd\u034ec\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t\t// (2007.4.27 yutaka)\r\n\t\ts = \"none\";  // method name\r\n\t\tbuffer_put_string(msg, s, strlen(s));\r\n\r\n\t} else if (pvar->auth_state.cur_cred.method == SSH_AUTH_PASSWORD) { // \ufffdp\ufffdX\ufffd\ufffd\ufffd[\ufffdh\ufffdF\ufffd\ufffd\r\n\t\t// password authentication method\r\n\t\ts = \"password\";\r\n\t\tbuffer_put_string(msg, s, strlen(s));\r\n\t\tbuffer_put_char(msg, 0); // 0\r\n\r\n\t\tif (pvar->ssh2_autologin == 1) { // SSH2\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdO\ufffdC\ufffd\ufffd\r\n\t\t\ts = pvar->ssh2_password;\r\n\t\t} else {\r\n\t\t\ts = pvar->auth_state.cur_cred.password;  // \ufffdp\ufffdX\ufffd\ufffd\ufffd[\ufffdh\r\n\t\t}\r\n\t\tbuffer_put_string(msg, s, strlen(s));\r\n\r\n\t} else if (pvar->auth_state.cur_cred.method == SSH_AUTH_TIS) { // keyboard-interactive (2005.3.12 yutaka)\r\n\t\ts = \"keyboard-interactive\";  // method name\r\n\t\tbuffer_put_string(msg, s, strlen(s));\r\n\t\ts = \"\";  // language tag\r\n\t\tbuffer_put_string(msg, s, strlen(s));\r\n\t\ts = \"\";  // submethods\r\n\t\tbuffer_put_string(msg, s, strlen(s));\r\n\r\n\t\tSSH2_dispatch_add_message(SSH2_MSG_USERAUTH_INFO_REQUEST);\r\n\r\n\t} else if (pvar->auth_state.cur_cred.method == SSH_AUTH_RSA) { // \ufffd\ufffd\ufffdJ\ufffd\ufffd\ufffdF\ufffd\ufffd\r\n\t\tbuffer_t *signbuf = NULL;\r\n\t\tbuffer_t *blob = NULL;\r\n\t\tint bloblen;\r\n\t\tchar *signature = NULL;\r\n\t\tint siglen;\r\n\t\tKey *keypair = pvar->auth_state.cur_cred.key_pair;\r\n\t\tssh_keyalgo keyalgo;\r\n\t\tchar *keyalgo_name;\r\n\r\n\t\tif (get_SSH2_publickey_blob(pvar, &blob, &bloblen) == FALSE) {\r\n\t\t\tgoto error;\r\n\t\t}\r\n\r\n\t\tkeyalgo = choose_SSH2_keysign_algorithm(pvar, keypair->type);\r\n\t\tkeyalgo_name = get_ssh2_hostkey_algorithm_name(keyalgo);\r\n\r\n\t\t// step1\r\n\t\tsignbuf = buffer_init();\r\n\t\tif (signbuf == NULL) {\r\n\t\t\tbuffer_free(blob);\r\n\t\t\tgoto error;\r\n\t\t}\r\n\t\t// \ufffdZ\ufffdb\ufffdV\ufffd\ufffd\ufffd\ufffdID\r\n\t\tbuffer_append_length(signbuf, pvar->session_id, pvar->session_id_len);\r\n\t\tbuffer_put_char(signbuf, SSH2_MSG_USERAUTH_REQUEST);\r\n\t\ts = username;  // \ufffd\ufffd\ufffd[\ufffdU\ufffd\ufffd\r\n\t\tbuffer_put_string(signbuf, s, strlen(s));\r\n\t\ts = connect_id;\r\n\t\tbuffer_put_string(signbuf, s, strlen(s));\r\n\t\ts = \"publickey\";\r\n\t\tbuffer_put_string(signbuf, s, strlen(s));\r\n\t\tbuffer_put_char(signbuf, 1); // true\r\n\r\n\t\ts = keyalgo_name;\r\n\t\tbuffer_put_string(signbuf, s, strlen(s));\r\n\r\n\t\ts = buffer_ptr(blob);\r\n\t\tbuffer_append_length(signbuf, s, bloblen);\r\n\r\n\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd\u030d\uc42c\r\n\t\tif (generate_SSH2_keysign(keypair, &signature, &siglen, buffer_ptr(signbuf), buffer_len(signbuf), keyalgo) == FALSE) {\r\n\t\t\tbuffer_free(blob);\r\n\t\t\tbuffer_free(signbuf);\r\n\t\t\tgoto error;\r\n\t\t}\r\n\r\n\t\t// step3\r\n\t\ts = \"publickey\";\r\n\t\tbuffer_put_string(msg, s, strlen(s));\r\n\t\tbuffer_put_char(msg, 1); // true\r\n\r\n\t\ts = keyalgo_name;\r\n\t\tbuffer_put_string(msg, s, strlen(s));\r\n\r\n\t\ts = buffer_ptr(blob);\r\n\t\tbuffer_append_length(msg, s, bloblen);\r\n\t\tbuffer_append_length(msg, signature, siglen);\r\n\r\n\t\tbuffer_free(blob);\r\n\t\tbuffer_free(signbuf);\r\n\t\tfree(signature);\r\n\r\n\t} else if (pvar->auth_state.cur_cred.method == SSH_AUTH_PAGEANT) { // Pageant\r\n\t\tunsigned char *puttykey;\r\n\t\tunsigned char *keytype_name, *keyalgo_name;\r\n\t\tssh_keytype keytype;\r\n\t\tssh_keyalgo keyalgo;\r\n\r\n\t\ts = \"publickey\";\r\n\t\tbuffer_put_string(msg, s, strlen(s));\r\n\t\tbuffer_put_char(msg, 0); // false\r\n\r\n\t\tif (pvar->pageant_keycurrent != 0) {\r\n\t\t\t// \ufffd\ufffd\ufffdO\ufffd\u030c\ufffd\ufffd\ufffd\ufffdX\ufffdL\ufffdb\ufffdv\r\n\t\t\tlen = get_uint32_MSBfirst(pvar->pageant_curkey);\r\n\t\t\tpvar->pageant_curkey += 4 + len;\r\n\t\t\t// \ufffd\ufffd\ufffdO\ufffd\u030c\ufffd\ufffd\u0303R\ufffd\ufffd\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffdX\ufffdL\ufffdb\ufffdv\r\n\t\t\tlen = get_uint32_MSBfirst(pvar->pageant_curkey);\r\n\t\t\tpvar->pageant_curkey += 4 + len;\r\n\t\t\t// \ufffd\ufffd\ufffd\u030c\ufffd\ufffd\u0308\u0292u\ufffd\u0597\ufffd\ufffd\ufffd\r\n\t\t}\r\n\t\tputtykey = pvar->pageant_curkey;\r\n\r\n\t\t// \ufffd\ufffd\ufffd\ufffd\u0282\ufffd\ufffd\u75d8\ufffdp\ufffd\ufffd\ufffd\u93d0\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u80b7\ufffd\ufffd\r\n\t\tlen = get_uint32_MSBfirst(puttykey+4);\r\n\t\tkeytype_name = puttykey + 8;\r\n\t\tkeytype = get_hostkey_type_from_name(keytype_name);\r\n\t\tkeyalgo = choose_SSH2_keysign_algorithm(pvar, keytype);\r\n\t\tkeyalgo_name = get_ssh2_hostkey_algorithm_name(keyalgo);\r\n\r\n\t\t// \ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd\ufffd\ufffd\ufffdR\ufffds\ufffd[\ufffd\ufffd\ufffd\ufffd\r\n\t\tlen = strlen(keyalgo_name);\r\n\t\tbuffer_put_string(msg, keyalgo_name, len);\r\n\r\n\t\t// \ufffd\ufffd\ufffd\ufffd\ufffdR\ufffds\ufffd[\ufffd\ufffd\ufffd\ufffd\r\n\t\tlen = get_uint32_MSBfirst(puttykey);\r\n\t\tputtykey += 4;\r\n\t\tbuffer_put_string(msg, puttykey, len);\r\n\t\tputtykey += len;\r\n\r\n\t\tpvar->pageant_keycurrent++;\r\n\r\n\t\tSSH2_dispatch_add_message(SSH2_MSG_USERAUTH_PK_OK);\r\n\r\n\t} else {\r\n\t\tgoto error;\r\n\r\n\t}\r\n\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffdM\r\n\tlen = buffer_len(msg);\r\n\toutmsg = begin_send_packet(pvar, SSH2_MSG_USERAUTH_REQUEST, len);\r\n\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\tfinish_send_packet(pvar);\r\n\tbuffer_free(msg);\r\n\r\n\t{\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE,\r\n\t\t\t\"SSH2_MSG_USERAUTH_REQUEST was sent do_SSH2_authrequest(). (method %d)\",\r\n\t\t\tpvar->auth_state.cur_cred.method);\r\n\t}\r\n\r\n\treturn TRUE;\r\n\r\nerror:\r\n\tbuffer_free(msg);\r\n\r\n\treturn FALSE;\r\n}\r\n\r\n\r\n//\r\n// SSH2 heartbeat procedure\r\n//\r\n// NAT\ufffd\u008b\ufffd\ufffd\u0242\ufffd\ufffd\ufffd\ufffd\u0101ASSH\ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg\ufffd\u0183T\ufffd[\ufffdo\ufffd\u0502\u0152\u0290M\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ua347\ufffdA\r\n// \ufffd\ufffd\ufffd[\ufffd^\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdNAT\ufffde\ufffd[\ufffdu\ufffd\ufffd\ufffd\ufffd\ufffdN\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffd\u90b1\ufffd\u0182\ufffd\ufffd\ufffd\ufffd\ufffdASSH\ufffdR\ufffdl\ufffdN\ufffdV\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\r\n// \ufffd\u0602\ufffd\u0102\ufffd\ufffd\u0702\ufffd\ufffd\ufffd\ufffd\u0182\ufffd\ufffd\ufffd\ufffd\ufffdB\ufffd\ufffd\ufffd\ufffdI\ufffd\u0241A\ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffd\ufffd_\ufffd~\ufffd[\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\r\n// \ufffd\ufffd\ufffdM\ufffd\ufffd\ufffd\u90b1\ufffd\u0182\u0151\u038f\ufffd\ufffd\ufffd\ufffd\ufffdB(2004.12.10 yutaka)\r\n//\r\n// \ufffd\ufffd\ufffd[\ufffdh\ufffd\ufffd\ufffdX\ufffd_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\ufffd\ufffd\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffdM\ufffd\ufffd\ufffd\ufffd\u60a4\ufffd\u0255\u03cdX\ufffdB(2007.12.26 yutaka)\r\n//\r\n#define WM_SEND_HEARTBEAT (WM_USER + 1)\r\n\r\nstatic LRESULT CALLBACK ssh_heartbeat_dlg_proc(HWND hWnd, UINT msg, WPARAM wp, LPARAM lp)\r\n{\r\n\r\n\tswitch (msg) {\r\n\t\tcase WM_INITDIALOG:\r\n\t\t\treturn FALSE;\r\n\r\n\t\tcase WM_SEND_HEARTBEAT:\r\n\t\t\t{\r\n\t\t\tPTInstVar pvar = (PTInstVar)wp;\r\n\t\t\tbuffer_t *msg;\r\n\t\t\tchar *s;\r\n\t\t\tunsigned char *outmsg;\r\n\t\t\tint len;\r\n\r\n\t\t\tmsg = buffer_init();\r\n\t\t\tif (msg == NULL) {\r\n\t\t\t\t// TODO: error check\r\n\t\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\t\treturn FALSE;\r\n\t\t\t}\r\n\t\t\ts = \"ssh-heartbeat\";\r\n\t\t\tbuffer_put_string(msg, s, strlen(s));\r\n\t\t\tlen = buffer_len(msg);\r\n\t\t\tif (SSHv1(pvar)) {\r\n\t\t\t\toutmsg = begin_send_packet(pvar, SSH_MSG_IGNORE, len);\r\n\t\t\t} else {\r\n\t\t\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_IGNORE, len);\r\n\t\t\t}\r\n\t\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\t\tfinish_send_packet(pvar);\r\n\t\t\tbuffer_free(msg);\r\n\t\t\tif (SSHv1(pvar)) {\r\n\t\t\t\tlogputs(LOG_LEVEL_SSHDUMP, \"SSH_MSG_IGNORE was sent at ssh_heartbeat_dlg_proc().\");\r\n\t\t\t} else {\r\n\t\t\t\tlogputs(LOG_LEVEL_SSHDUMP, \"SSH2_MSG_IGNORE was sent at ssh_heartbeat_dlg_proc().\");\r\n\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn TRUE;\r\n\t\t\tbreak;\r\n\r\n\t\tcase WM_COMMAND:\r\n\t\t\tswitch (wp) {\r\n\t\t\t}\r\n\r\n\t\t\tswitch (LOWORD(wp)) {\r\n\t\t\t\tcase IDOK:\r\n\t\t\t\t\t{\r\n\t\t\t\t\treturn TRUE;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\tcase IDCANCEL:\r\n\t\t\t\t\tEndDialog(hWnd, 0);\r\n\t\t\t\t\treturn TRUE;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\treturn FALSE;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\t\tcase WM_CLOSE:\r\n\t\t\t// close\ufffd{\ufffd^\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd window \ufffd\ufffd\ufffd\u0082\ufffd\ufffd\u0202\ufffd\ufffd\u60a4\ufffd\u0242\ufffd\ufffd\ufffdB\r\n\t\t\treturn TRUE;\r\n\r\n\t\tcase WM_DESTROY:\r\n\t\t\treturn TRUE;\r\n\r\n\t\tdefault:\r\n\t\t\treturn FALSE;\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\n\r\nstatic unsigned __stdcall ssh_heartbeat_thread(void *p)\r\n{\r\n\tstatic int instance = 0;\r\n\tPTInstVar pvar = (PTInstVar)p;\r\n\ttime_t tick;\r\n\r\n\t// \ufffd\ufffd\ufffd\u0142\u024e\ufffd\ufffds\ufffd\ufffd\ufffd\u0202\u727d\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0255\u0502\ufffdB\r\n\tif (instance > 0)\r\n\t\treturn 0;\r\n\tinstance++;\r\n\r\n\tfor (;;) {\r\n\t\t// \ufffd\\\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffdN\ufffd\ufffd\ufffd[\ufffdY\ufffd\ufffd\ufffd\ua0bd\ufffd\ufffdX\ufffd\ufffd\ufffdb\ufffdh\ufffd\ufffd\ufffdI\ufffd\ufffd\ufffd\r\n\t\tif (pvar->socket == INVALID_SOCKET)\r\n\t\t\tbreak;\r\n\r\n\t\t// \ufffd\ufffd\u839e\ufffd\u0516\ufffd\ufffd\u0290M\ufffd\u0142\ufffd\ufffd\ufffd\u0381A\ufffdT\ufffd[\ufffdo\ufffd\u0583_\ufffd~\ufffd[\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ud805\uddc2\ufffd\r\n\t\t// \u81d2l\ufffd\ufffd0\ufffd\u0142\ufffd\ufffd\ufffd\u0389\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t\ttick = time(NULL) - pvar->ssh_heartbeat_tick;\r\n\t\tif (pvar->session_settings.ssh_heartbeat_overtime > 0 &&\r\n\t\t\ttick > pvar->session_settings.ssh_heartbeat_overtime) {\r\n\r\n\t\t\tSendMessage(pvar->ssh_hearbeat_dialog, WM_SEND_HEARTBEAT, (WPARAM)pvar, 0);\r\n\t\t}\r\n\r\n\t\tSleep(100); // yield\r\n\t}\r\n\r\n\tinstance = 0;\r\n\r\n\treturn 0;\r\n}\r\n\r\nstatic void start_ssh_heartbeat_thread(PTInstVar pvar)\r\n{\r\n\tHANDLE thread = INVALID_HANDLE_VALUE;\r\n\tunsigned tid;\r\n\tHWND hDlgWnd;\r\n\r\n\t// \ufffd\ufffd\ufffd[\ufffdh\ufffd\ufffd\ufffdX\ufffd_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\ufffd\ufffd\uc42c\ufffdB\ufffdn\ufffd[\ufffdg\ufffdr\ufffd[\ufffdg\ufffdp\ufffd\u0202\u0302\u0143_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\u0354\ufffd\\\ufffd\ufffd\ufffd\u0302\u0702\u0702\ufffd\r\n\t// \ufffd\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\ufffd\ufffd\\\ufffd[\ufffdXID\ufffd\u0342\u0202\ufffd\u0142\ufffd\ufffd\u60a2\ufffdB\r\n\thDlgWnd = CreateDialog(hInst, MAKEINTRESOURCE(IDD_SSHSCP_PROGRESS),\r\n               pvar->cv->HWin, (DLGPROC)ssh_heartbeat_dlg_proc);\r\n\tpvar->ssh_hearbeat_dialog = hDlgWnd;\r\n\r\n\t// TTSSH\ufffd\ufffd thread-safe \ufffd\u0142\u0342\u0202\ufffd\ufffd\u0302\u0143X\ufffd\ufffd\ufffdb\ufffdh\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffdM\ufffd\u0355s\ufffd\u0081B(2007.12.26 yutaka)\r\n\tthread = (HANDLE)_beginthreadex(NULL, 0, ssh_heartbeat_thread, pvar, 0, &tid);\r\n\tif (thread == 0) {\r\n\t\t// TODO:\r\n\t\tthread = INVALID_HANDLE_VALUE;\r\n\t}\r\n\tpvar->ssh_heartbeat_thread = thread;\r\n}\r\n\r\n// \ufffdX\ufffd\ufffd\ufffdb\ufffdh\ufffd\u0312\ufffd~ (2004.12.27 yutaka)\r\nvoid halt_ssh_heartbeat_thread(PTInstVar pvar)\r\n{\r\n\tif (pvar->ssh_heartbeat_thread != INVALID_HANDLE_VALUE) {\r\n\t\tWaitForSingleObject(pvar->ssh_heartbeat_thread, INFINITE);\r\n\t\tCloseHandle(pvar->ssh_heartbeat_thread);\r\n\t\tpvar->ssh_heartbeat_thread = INVALID_HANDLE_VALUE;\r\n\r\n\t\tDestroyWindow(pvar->ssh_hearbeat_dialog);\r\n\t}\r\n}\r\n\r\n\r\nstatic BOOL handle_SSH2_userauth_success(PTInstVar pvar)\r\n{\r\n\tbuffer_t *msg;\r\n\tchar *s;\r\n\tunsigned char *outmsg;\r\n\tint len;\r\n\tChannel_t *c;\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_USERAUTH_SUCCESS was received.\");\r\n\r\n\t// \ufffdp\ufffdX\ufffd\ufffd\ufffd[\ufffdh\ufffd\u0314j\ufffd\ufffd (2006.8.22 yutaka)\r\n\tif (pvar->settings.remember_password == 0) {\r\n\t\tdestroy_malloced_string(&pvar->auth_state.cur_cred.password);\r\n\t}\r\n\r\n\t// \ufffdF\ufffd\ufffdOK\r\n\tpvar->userauth_success = 1;\r\n\r\n\t// \ufffdf\ufffdB\ufffdX\ufffdp\ufffdb\ufffd`\ufffd\ufffd\ufffd[\ufffd`\ufffd\ufffd\ufffd\u030d\u0110\u0752\ufffd\r\n\tdo_SSH2_dispatch_setup_for_transfer(pvar);\r\n\r\n\tif (pvar->nosession) {\r\n\t\t// start forwarding\r\n\t\tFWD_prep_forwarding(pvar);\r\n\t\tFWD_enter_interactive_mode(pvar);\r\n\t}\r\n\telse {\r\n\t\t// \ufffd`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\u0752\ufffd\r\n\t\t// FWD_prep_forwarding()\ufffd\ufffdshell ID\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\ufffd\u0250\u0752\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffdB(2005.7.3 yutaka)\r\n\t\t// changed window size from 64KB to 32KB. (2006.3.6 yutaka)\r\n\t\t// changed window size from 32KB to 128KB. (2007.10.29 maya)\r\n\t\tif (pvar->use_subsystem) {\r\n\t\t\tc = ssh2_channel_new(CHAN_SES_WINDOW_DEFAULT, CHAN_SES_PACKET_DEFAULT, TYPE_SUBSYSTEM_GEN, -1);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tc = ssh2_channel_new(CHAN_SES_WINDOW_DEFAULT, CHAN_SES_PACKET_DEFAULT, TYPE_SHELL, -1);\r\n\t\t}\r\n\r\n\t\tif (c == NULL) {\r\n\t\t\tUTIL_get_lang_msg(\"MSG_SSH_NO_FREE_CHANNEL\", pvar,\r\n\t\t\t\t\t  \"Could not open new channel. TTSSH is already opening too many channels.\");\r\n\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\t// \ufffdV\ufffdF\ufffd\ufffd\ufffd\ufffdID\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\r\n\t\tpvar->shell_id = c->self_id;\r\n\r\n\t\t// \ufffdV\ufffdF\ufffd\ufffd\ufffdI\ufffd[\ufffdv\ufffd\ufffd\r\n\t\tmsg = buffer_init();\r\n\t\tif (msg == NULL) {\r\n\t\t\t// TODO: error check\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\ts = \"session\";\r\n\t\tbuffer_put_string(msg, s, strlen(s));  // ctype\r\n\t\tbuffer_put_int(msg, c->self_id);  // self(channel number)\r\n\t\tbuffer_put_int(msg, c->local_window);  // local_window\r\n\t\tbuffer_put_int(msg, c->local_maxpacket);  // local_maxpacket\r\n\t\tlen = buffer_len(msg);\r\n\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_OPEN, len);\r\n\t\tmemcpy(outmsg, buffer_ptr (msg), len);\r\n\t\tfinish_send_packet(pvar);\r\n\t\tbuffer_free(msg);\r\n\r\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_CHANNEL_OPEN was sent at handle_SSH2_userauth_success().\");\r\n\t}\r\n\r\n\t// \ufffdn\ufffd[\ufffdg\ufffdr\ufffd[\ufffdg\ufffdE\ufffdX\ufffd\ufffd\ufffdb\ufffdh\ufffd\u030aJ\ufffdn (2004.12.11 yutaka)\r\n\tstart_ssh_heartbeat_thread(pvar);\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"User authentication is successful and SSH heartbeat thread is starting.\");\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n\r\nstatic BOOL handle_SSH2_userauth_failure(PTInstVar pvar)\r\n{\r\n\tint len;\r\n\tchar *data;\r\n\tchar *cstring;\r\n\tint partial;\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_USERAUTH_FAILURE was received.\");\r\n\r\n\t// 6byte\ufffdi\ufffdT\ufffdC\ufffdY\ufffd{\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd{\ufffd^\ufffdC\ufffdv\ufffdj\ufffd\ufffd\ufffd\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffd\u020d~\ufffd\u0303y\ufffdC\ufffd\ufffd\ufffd[\ufffdh\r\n\tdata = pvar->ssh_state.payload;\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY - (\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffdT\ufffdC\ufffdY+1)\ufffdG\ufffd^\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY\r\n\tlen = pvar->ssh_state.payloadlen;\r\n\r\n\tcstring = buffer_get_string(&data, NULL); // \ufffdF\ufffd\u0603\ufffd\ufffdX\ufffdg\ufffd\u030e\u64fe\r\n\tpartial = data[0];\r\n\tdata += 1;\r\n\r\n\t// \ufffdL\ufffd\ufffd\ufffd\u0214F\ufffd\u0615\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\ua347\r\n\tif (cstring == NULL) {\r\n\t\tUTIL_get_lang_msg(\"MSG_SSH_SERVER_NO_AUTH_METHOD_ERROR\", pvar,\r\n\t\t                  \"The server doesn't have valid authentication method.\");\r\n\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\t// tryed_ssh2_authlist \ufffd\ufffd FALSE \ufffd\u030f\ua347\ufffd\u0341A\ufffd\u0702\ufffd\ufffdF\ufffd\u0602\ufffd\ufffd\ufffd\ufffds\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\tif (!pvar->tryed_ssh2_authlist) {\r\n\t\tint type = 0;\r\n\r\n\t\tpvar->tryed_ssh2_authlist = TRUE;\r\n\r\n\t\t// \ufffdF\ufffd\u0603_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\u0303\ufffd\ufffdW\ufffdI\ufffd{\ufffd^\ufffd\ufffd\ufffd\ufffd\ufffdX\ufffdV\r\n\t\tif (strstr(cstring, \"password\")) {\r\n\t\t\ttype |= (1 << SSH_AUTH_PASSWORD);\r\n\t\t}\r\n\t\tif (strstr(cstring, \"publickey\")) {\r\n\t\t\ttype |= (1 << SSH_AUTH_RSA);\r\n\t\t\ttype |= (1 << SSH_AUTH_PAGEANT);\r\n\t\t}\r\n\t\tif (strstr(cstring, \"keyboard-interactive\")) {\r\n\t\t\ttype |= (1 << SSH_AUTH_TIS);\r\n\t\t}\r\n\t\tif (!AUTH_set_supported_auth_types(pvar, type))\r\n\t\t\treturn FALSE;\r\n\r\n\t\tpvar->ssh2_authlist = cstring; // \ufffds\ufffdv\ufffd\u0242\u0202\ufffd\ufffd\ufffd\ufffd\ufffdt\ufffd\ufffd\ufffd[\ufffd\ufffd\ufffd\u90b1\ufffd\ufffd\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"method list from server: %s\", cstring);\r\n\r\n\t\tif (pvar->ssh2_authmethod == SSH_AUTH_TIS &&\r\n\t\t    pvar->ask4passwd &&\r\n\t\t    pvar->session_settings.CheckAuthListFirst &&\r\n\t\t    pvar->auth_state.auth_dialog != NULL) {\r\n\t\t\t// challenge \ufffd\ufffd ask4passwd \ufffd\u0302\u0182\ufffd\ufffdA\ufffdF\ufffd\u0603\ufffd\ufffd\\\ufffdb\ufffdh\ufffd\ua5d7\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u64fe\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\t\t\t// \ufffd\ufffd\ufffd\ufffd\ufffdI\ufffd\ufffd TIS \ufffd_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\ufffd\ufffdo\ufffd\ufffd\ufffd\ufffd\ufffd\u07c2\ufffd OK \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\t\t\tSendMessage(pvar->auth_state.auth_dialog, WM_COMMAND, IDOK, 0);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// \ufffd\u0402\u0182\u0702\ufffd none \ufffd\u014e\ufffd\ufffds\ufffd\ufffd\ufffd\u0115\u0502\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffd\u0182\ufffd\ufffd\ufffd\u0202\u0302\u0141A\ufffd\ufffd\ufffd\u06c2\u0303\ufffd\ufffdO\ufffdC\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\t\t\tdo_SSH2_authrequest(pvar);\r\n\t\t}\r\n\r\n\t\treturn TRUE;\r\n\t}\r\n\r\n\t// TCP connection closed\r\n\t//notify_closed_connection(pvar);\r\n\r\n\t// retry count\ufffd\u0312\u01c9\ufffd (2005.3.10 yutaka)\r\n\tif (pvar->auth_state.cur_cred.method != SSH_AUTH_PAGEANT) {\r\n\t\tpvar->userauth_retry_count++;\r\n\t}\r\n\telse {\r\n\t\tif (pvar->pageant_keycount <= pvar->pageant_keycurrent ||\r\n\t\t    pvar->pageant_keyfinal) {\r\n\t\t\t// \ufffdS\ufffd\u0102\u030c\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdI\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\t\t\t// \ufffd\u0702\ufffd\ufffd\u0341ATRUE \ufffd\u0142\u0303\ufffd\ufffdO\ufffdC\ufffd\ufffd\ufffd\u024e\ufffd\ufffds\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffd\u0257\ufffd\ufffd\ufffd\r\n\t\t\tsafefree(pvar->pageant_key);\r\n\t\t\tpvar->userauth_retry_count++;\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// \ufffd\u0702\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\t\t\tdo_SSH2_authrequest(pvar);\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t}\r\n\r\n\tif (pvar->ssh2_autologin == 1) {\r\n\t\tchar uimsg[MAX_UIMSG];\r\n\t\t// SSH2\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdO\ufffdC\ufffd\ufffd\ufffd\ufffd\ufffdL\ufffd\ufffd\ufffd\u030f\ua347\ufffd\u0341A\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffdC\ufffd\u034ds\ufffd\ufffd\u0202\ufffd\ufffdB(2004.12.4 yutaka)\r\n\t\tUTIL_get_lang_msg(\"MSG_SSH_AUTH_FAILURE_ERROR\", pvar,\r\n\t\t                  \"SSH2 auto-login error: user authentication failed.\");\r\n\t\tstrncpy_s(uimsg, sizeof(uimsg), pvar->UIMsg, _TRUNCATE);\r\n\r\n\t\tif (pvar->ssh2_authlist != NULL || strlen(pvar->ssh2_authlist) != 0) {\r\n\t\t\tif ((pvar->auth_state.supported_types & (1 << pvar->ssh2_authmethod)) == 0) {\r\n\t\t\t\t// \ufffdg\ufffdp\ufffd\ufffd\ufffd\ufffd\ufffdF\ufffd\u0603\ufffd\ufffd\\\ufffdb\ufffdh\ufffd\u0343T\ufffd|\ufffd[\ufffdg\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_SERVER_UNSUPPORT_AUTH_METHOD_ERROR\", pvar,\r\n\t\t\t\t                  \"\\nAuthentication method is not supported by server.\");\r\n\t\t\t\tstrncat_s(uimsg, sizeof(uimsg), pvar->UIMsg, _TRUNCATE);\r\n\t\t\t}\r\n\t\t}\r\n\t\tnotify_fatal_error(pvar, uimsg, TRUE);\r\n\t\treturn TRUE;\r\n\t}\r\n\r\n\t// \ufffd\ufffd\ufffd[\ufffdU\ufffdF\ufffd\u0602\u024e\ufffd\ufffds\ufffd\ufffd\ufffd\ufffd\ufffd\u0182\ufffd\ufffd\u0341A\ufffd\ufffd\ufffd[\ufffdU\ufffd\ufffd\ufffd\u034c\u0152\u80b5\ufffd\u0101A\ufffdp\ufffdX\ufffd\ufffd\ufffd[\ufffdh\ufffd\u030d\u0113\ufffd\ufffd\u0342\ufffd\r\n\t// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\ufffd\ufffd\ufffd\ufffd\ufffd\u030f\ufffd\ufffd\ufffd\ufffd\ufffd SSH1 \ufffd\u0193\ufffd\ufffd\ufffd\ufffdB(2004.10.3 yutaka)\r\n\tAUTH_set_generic_mode(pvar);\r\n\tAUTH_advance_to_next_cred(pvar);\r\n\tpvar->ssh_state.status_flags &= ~STATUS_DONT_SEND_CREDENTIALS;\r\n\ttry_send_credentials(pvar);\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nvoid sanitize_str(buffer_t *buff, unsigned char *src, size_t srclen)\r\n{\r\n\tunsigned char *start = src;\r\n\tint cplen = 0;\r\n\tunsigned int i;\r\n\r\n\tif (srclen == 0)\r\n\t\treturn;\r\n\r\n\tfor (i=0; i<srclen; i++) {\r\n\t\tif (src[i] < 0x20 && src[i] != '\\t') {\r\n\t\t\tif (cplen > 0) {\r\n\t\t\t\tbuffer_append(buff, start, cplen);\r\n\t\t\t}\r\n\r\n\t\t\tif (src[i] == '\\r') {\r\n\t\t\t\tbuffer_append(buff, \"\\r\\n\", 2);\r\n\r\n\t\t\t\tif (i < srclen - 1 && src[i+1] == '\\n') {\r\n\t\t\t\t\ti++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (src[i] == '\\n') {\r\n\t\t\t\tbuffer_append(buff, \"\\r\\n\", 2);\r\n\t\t\t}\r\n\r\n\t\t\tstart = src + i + 1;\r\n\t\t\tcplen = 0;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcplen++;\r\n\t\t}\r\n\t}\r\n\r\n\tif (cplen > 0) {\r\n\t\tbuffer_append(buff, start, cplen);\r\n\t}\r\n\r\n\tbuffer_append(buff, \"\\0\", 1);\r\n}\r\n\r\n/*\r\n * SSH_MSG_USERAUTH_BANNER:\r\n *    byte      SSH_MSG_USERAUTH_BANNER\r\n *    string    message in ISO-10646 UTF-8 encoding\r\n *    string    language tag\r\n */\r\nstatic BOOL handle_SSH2_userauth_banner(PTInstVar pvar)\r\n{\r\n\tint msglen, ltaglen;\r\n\tchar buff[2048];\r\n\tchar *new_payload_buffer = NULL;\r\n\r\n\tlogputs(LOG_LEVEL_INFO, \"SSH2_MSG_USERAUTH_BANNER was received.\");\r\n\r\n\tif (!get_string_from_payload(pvar, buff, sizeof(buff), &msglen, TRUE)) {\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: banner payload corrupted.\", __FUNCTION__);\r\n\t\treturn TRUE;\r\n\t}\r\n\r\n\tif (msglen > 0) {\r\n\t\tchar *msg, *msgA;\r\n\t\twchar_t *msgW;\r\n\r\n\t\tif (pvar->authbanner_buffer == NULL) {\r\n\t\t\tpvar->authbanner_buffer = buffer_init();\r\n\t\t}\r\n\t\telse {\r\n\t\t\tbuffer_clear(pvar->authbanner_buffer);\r\n\t\t}\r\n\r\n\t\tif (pvar->authbanner_buffer != NULL) {\r\n\t\t\tsanitize_str(pvar->authbanner_buffer, buff, MIN(msglen, sizeof(buff)));\r\n\t\t\tmsg = buffer_ptr(pvar->authbanner_buffer);\r\n\t\t\tmsglen = buffer_len(pvar->authbanner_buffer) - 1; // NUL Terminate \ufffd\ufffd\ufffd\u0350\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdm\ufffd\u06ce\ufffd\ufffds\ufffd\ufffd\ufffd\u0355\u03ca\ufffd\ufffdO\ufffd\u0315\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\\\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\t\t// \ufffd\ufffd\ufffd\ufffd\ufffdAC0 \ufffd\ufffd\ufffd\u4576\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0702\u0715\\\ufffd\ufffd\ufffd\ufffd\ufffd\u60a4\ufffd\u0182\ufffd\ufffd\ufffd\u0302\u0156]\ufffd\u0702\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\t\tmsg = buff;\r\n\t\t}\r\n\r\n\t\tswitch (pvar->settings.AuthBanner) {\r\n\t\tcase 0:\r\n\t\t\tbreak;\r\n\t\tcase 1:\r\n\t\t\tif (pvar->authbanner_buffer != NULL) {\r\n\t\t\t\tif (pvar->ts->Language == IdJapanese) { // \ufffd\u0182\u80a0\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd{\ufffd\ua0c2\ufffd[\ufffdh\ufffd\u0302\u0751\u0389\ufffd\r\n\t\t\t\t\tswitch (pvar->ts->KanjiCode) {\r\n\t\t\t\t\tcase IdSJIS:\r\n\t\t\t\t\t\tmsgA = ToCharU8(msg);\r\n\t\t\t\t\t\tif (msgA) {\r\n\t\t\t\t\t\t\tmsg = msgA;\r\n\t\t\t\t\t\t\tmsglen = strlen(msg);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase IdEUC:\r\n\t\t\t\t\t\t// CP51932 \ufffd\u0582\u0315\u03ca\ufffd\ufffd\u014e\u8532\ufffd\ufffd\ufffd\ufffd\ufffd\u60a4\ufffd\u0182\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\t\t\t\t\t\t// \ufffdg\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0142\u0182\u80a0\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0389\ufffd\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase IdJIS:\r\n\t\t\t\t\t\t// \ufffdg\ufffd\ufffd\ufffd\u9396\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\u0302\u0196\u0293|\ufffd\u0202\u0302\u0142\u0182\u80a0\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0389\ufffd\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t// nothing to do\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tnew_payload_buffer = msg;\r\n\t\t\t\tpvar->ssh_state.payload_datastart = 0;\r\n\t\t\t\tpvar->ssh_state.payload_datalen = msglen;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tpvar->ssh_state.payload_datastart = 4;\r\n\t\t\t\tpvar->ssh_state.payload_datalen = msglen;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\tmsgW = ToWcharU8(msg);\r\n\t\t\tif (msgW) {\r\n\t\t\t\tMessageBoxW(pvar->cv->HWin, msgW, L\"Authentication Banner\", MB_OK | MB_ICONINFORMATION);\r\n\t\t\t\tfree(msgW);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 3:\r\n\t\t\tmsgW = ToWcharU8(msg);\r\n\t\t\tif (msgW) {\r\n\t\t\t\tNotifySetIconID(pvar->cv, hInst, pvar->settings.IconID);\r\n\t\t\t\tNotifyInfoMessageW(pvar->cv, msgW, L\"Authentication Banner\");\r\n\t\t\t\tNotifySetIconID(pvar->cv, NULL, 0);\r\n\t\t\t\tfree(msgW);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tlogprintf(LOG_LEVEL_NOTICE, \"Banner len: %d, Banner message: %s.\", msglen, msg);\r\n\t}\r\n\telse {\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"Empty banner\");\r\n\t}\r\n\r\n\tif (!get_string_from_payload(pvar, buff, sizeof(buff), &ltaglen, TRUE)) {\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: langtag payload corrupted.\", __FUNCTION__);\r\n\t\treturn TRUE;\r\n\t}\r\n\r\n\tif (ltaglen > 0) {\r\n\t\tlogprintf(LOG_LEVEL_NOTICE, \"Banner ltag len: %d, Banner Language Tag: %s\", ltaglen, buff);\r\n\t}\r\n\telse {\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"Empty Language Tag\");\r\n\t}\r\n\r\n\tif (new_payload_buffer) {\r\n\t\tpvar->ssh_state.payload = new_payload_buffer;\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n\r\n// SSH2 \ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW 60 \ufffd\u0502\u030f\ufffd\ufffd\ufffd\ufffd\u0590\ufffd\r\n//\r\n// SSH2 \ufffd\u0142\u0348\u0209\ufffd\ufffd\u0303\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd\ufffd 60 \ufffd\u0502\u058fd\ufffd\ufffd\ufffd\ufffd\ufffd\u010a\ufffd\ufffd\u84d6\ufffd\u0102\ufffd\ufffd\u0102\ufffd\ufffd\ufffdB\r\n//\r\n// * SSH2_MSG_USERAUTH_INFO_REQUEST (keyboard-interactive)\r\n// * SSH2_MSG_USERAUTH_PK_OK (publickey / Tera Term \ufffd\u0142\ufffd Pageant \ufffdF\ufffd\u0602\u0302\ufffd)\r\n// * SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ (password)\r\n//\r\n// \ufffd\ufffd\ufffd\ufffd\u030e\ufffd\ufffd\ufffd\ufffd\u0142\u0353\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd\u050d\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0742\u0142\ufffd\ufffd\u0202\ufffd\ufffd\u0302\u0141A\r\n// 60 \ufffd\u0502\u0342\ufffd\ufffd\u030a\u0590\ufffd\ufffd\u014e\udaca\udfc1Amethod \ufffd\u0242\ufffd\ufffd\ufffd\u0111\u0389\ufffd\ufffd\ufffd\ufffd\ufffdn\ufffd\ufffd\ufffdh\ufffd\ufffd\ufffd\u0590\ufffd\ufffd\u0250U\ufffd\u856a\ufffd\ufffd\ufffd\ufffdB\r\n//\r\nBOOL handle_SSH2_userauth_msg60(PTInstVar pvar)\r\n{\r\n\tif (pvar->auth_state.cur_cred.method == SSH_AUTH_TIS) {\r\n\t\treturn handle_SSH2_userauth_inforeq(pvar);\r\n\t}\r\n\telse if (pvar->auth_state.cur_cred.method == SSH_AUTH_PAGEANT) {\r\n\t\treturn handle_SSH2_userauth_pkok(pvar);\r\n\t}\r\n\telse if (pvar->auth_state.cur_cred.method == SSH_AUTH_PASSWORD) {\r\n\t\treturn handle_SSH2_userauth_passwd_changereq(pvar);\r\n\t}\r\n\telse {\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\treturn TRUE; // not reached\r\n}\r\n\r\nBOOL handle_SSH2_userauth_inforeq(PTInstVar pvar)\r\n{\r\n\t// SSH2_MSG_USERAUTH_INFO_REQUEST\r\n\tint len;\r\n\tchar *data;\r\n\tint slen = 0, num, echo;\r\n\tchar *s, *prompt = NULL;\r\n\tbuffer_t *msg;\r\n\tunsigned char *outmsg;\r\n\tint i;\r\n\tchar *name, *inst, *lang;\r\n\tchar lprompt[512];\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_USERAUTH_INFO_REQUEST was received.\");\r\n\r\n\t// 6byte\ufffdi\ufffdT\ufffdC\ufffdY\ufffd{\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd{\ufffd^\ufffdC\ufffdv\ufffdj\ufffd\ufffd\ufffd\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffd\u020d~\ufffd\u0303y\ufffdC\ufffd\ufffd\ufffd[\ufffdh\r\n\tdata = pvar->ssh_state.payload;\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY - (\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffdT\ufffdC\ufffdY+1)\ufffdG\ufffd^\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY\r\n\tlen = pvar->ssh_state.payloadlen;\r\n\r\n\t//debug_print(10, data, len);\r\n\r\n\t///////// step1\r\n\t// get string\r\n\tname = buffer_get_string(&data, NULL);\r\n\tinst = buffer_get_string(&data, NULL);\r\n\tlang = buffer_get_string(&data, NULL);\r\n\tlprompt[0] = 0;\r\n\tif (inst == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_get_string returns NULL. (inst)\", __FUNCTION__);\r\n\t}\r\n\telse if (strlen(inst) > 0) {\r\n\t\tstrncat_s(lprompt, sizeof(lprompt), inst, _TRUNCATE);\r\n\t\tstrncat_s(lprompt, sizeof(lprompt), \"\\r\\n\", _TRUNCATE);\r\n\t}\r\n\tif (lang == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_get_string returns NULL. (lang)\", __FUNCTION__);\r\n\t}\r\n\telse if (strlen(lang) > 0) {\r\n\t\tstrncat_s(lprompt, sizeof(lprompt), lang, _TRUNCATE);\r\n\t\tstrncat_s(lprompt, sizeof(lprompt), \"\\r\\n\", _TRUNCATE);\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: user=%s, inst=%s, lang=%s\", __FUNCTION__,\r\n\t\tNonNull(name), NonNull(inst), NonNull(lang));\r\n\r\n\tfree(name);\r\n\tfree(inst);\r\n\tfree(lang);\r\n\r\n\t// num-prompts\r\n\tnum = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: prompts=%d\", __FUNCTION__, num);\r\n\r\n\t///////// step2\r\n\t// \ufffdT\ufffd[\ufffdo\ufffd\u0583p\ufffdX\ufffdt\ufffd\ufffd\ufffd[\ufffdY\ufffd\ud805\uddc2\ufffd\r\n\tmsg = buffer_init();\r\n\tif (msg == NULL) {\r\n\t\t// TODO: error check\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\treturn FALSE;\r\n\t}\r\n\tbuffer_put_int(msg, num);\r\n\r\n\t// \ufffdp\ufffdX\ufffd\ufffd\ufffd[\ufffdh\ufffd\u03cdX\ufffd\u030f\ua347\ufffdA\ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0381A\ufffd\\\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB(2010.11.11 yutaka)\r\n\tif (num == 0) {\r\n\t\tif (strlen(lprompt) > 0)\r\n\t\t\tMessageBox(pvar->cv->HWin, lprompt, \"USERAUTH INFO_REQUEST\", MB_OK | MB_ICONINFORMATION);\r\n\t}\r\n\r\n\t// \ufffdv\ufffd\ufffd\ufffd\ufffd\ufffdv\ufffdg\ufffd\u0310\ufffd\ufffd\ufffd\ufffd\ufffd prompt & echo \ufffd\ufffd\ufffdJ\ufffd\ufffd\u0502\ufffd\ufffd\ufffd\ufffdB\r\n\tfor (i = 0 ; i < num ; i++) {\r\n\t\t// get string\r\n\t\tslen = get_uint32_MSBfirst(data);\r\n\t\tdata += 4;\r\n\t\tprompt = data;  // prompt\r\n\t\tdata += slen;\r\n\r\n\t\t// get boolean\r\n\t\techo = data[0];\r\n\t\tdata[0] = '\\0'; // \ufffd\ufffd\ufffdO\ufffdo\ufffd\u0342\u0308\u05c1A\ufffd\ua39e\ufffdI\ufffd\ufffd NUL Terminate \ufffd\ufffd\ufffd\ufffd\r\n\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s:   prompt[%d]=\\\"%s\\\", echo=%d, pass-state=%d\", __FUNCTION__,\r\n\t\t\ti, prompt, slen, pvar->keyboard_interactive_password_input);\r\n\r\n\t\tdata[0] = echo; // \ufffd\ufffd\ufffdO\ufffdo\ufffd\u0342\ufffd\ufffds\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\ufffd\ufffd\u0312l\ufffd\u024f\ufffd\ufffd\ufffd\ufffd\u07c2\ufffd\r\n\t\tdata += 1;\r\n\r\n\t\t// keyboard-interactive method (2005.3.12 yutaka)\r\n\t\tif (pvar->keyboard_interactive_password_input == 0 &&\r\n\t\t\tpvar->auth_state.cur_cred.method == SSH_AUTH_TIS) {\r\n\t\t\tAUTH_set_TIS_mode(pvar, prompt, slen, echo);\r\n\t\t\tAUTH_advance_to_next_cred(pvar);\r\n\t\t\tpvar->ssh_state.status_flags &= ~STATUS_DONT_SEND_CREDENTIALS;\r\n\t\t\t//try_send_credentials(pvar);\r\n\t\t\tbuffer_free(msg);\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\r\n\t\t// TODO: \ufffd\ufffd\ufffd\ufffd\ufffd\u0143v\ufffd\ufffd\ufffd\ufffd\ufffdv\ufffdg\ufffd\ufffd\\\ufffd\ufffd\ufffd\ufffd\ufffd\u0103\ufffd\ufffd[\ufffdU\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0342\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\ts = pvar->auth_state.cur_cred.password;\r\n\t\tbuffer_put_string(msg, s, strlen(s));\r\n\r\n\t\t// \ufffd\ufffd\ufffdg\ufffd\ufffd\ufffdC\ufffd\u0251\u0389\ufffd\ufffd\u0142\ufffd\ufffd\ufffd\u60a4\ufffdA\ufffdt\ufffd\ufffd\ufffdO\ufffd\ufffd\ufffdN\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffd\ufffdB(2010.11.11 yutaka)\r\n\t\tpvar->keyboard_interactive_password_input = 0;\r\n\t}\r\n\r\n\tlen = buffer_len(msg);\r\n\toutmsg = begin_send_packet(pvar, SSH2_MSG_USERAUTH_INFO_RESPONSE, len);\r\n\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\tfinish_send_packet(pvar);\r\n\tbuffer_free(msg);\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: sending SSH2_MSG_USERAUTH_INFO_RESPONSE.\", __FUNCTION__);\r\n\treturn TRUE;\r\n}\r\n\r\nBOOL handle_SSH2_userauth_pkok(PTInstVar pvar)\r\n{\r\n\t\t// SSH2_MSG_USERAUTH_PK_OK\r\n\t\tbuffer_t *msg = NULL;\r\n\t\tchar *s, *username;\r\n\t\tunsigned char *outmsg;\r\n\t\tint len;\r\n\t\tchar *connect_id = \"ssh-connection\";\r\n\r\n\t\tunsigned char *puttykey;\r\n\t\tbuffer_t *signbuf;\r\n\t\tunsigned char *signedmsg;\r\n\t\tint signedlen;\r\n\r\n\t\tunsigned char *keytype_name, *keyalgo_name;\r\n\t\tssh_keytype keytype;\r\n\t\tssh_keyalgo keyalgo;\r\n\t\tssh_agentflag signflag;\r\n\r\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_USERAUTH_PK_OK was received.\");\r\n\r\n\t\tusername = pvar->auth_state.user;  // \ufffd\ufffd\ufffd[\ufffdU\ufffd\ufffd\r\n\r\n\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdf\ufffd[\ufffd^\ufffd\ufffd\ufffd\uc42c\r\n\t\tsignbuf = buffer_init();\r\n\t\tif (signbuf == NULL) {\r\n\t\t\tsafefree(pvar->pageant_key);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\tbuffer_append_length(signbuf, pvar->session_id, pvar->session_id_len);\r\n\t\tbuffer_put_char(signbuf, SSH2_MSG_USERAUTH_REQUEST);\r\n\t\ts = username;  // \ufffd\ufffd\ufffd[\ufffdU\ufffd\ufffd\r\n\t\tbuffer_put_string(signbuf, s, strlen(s));\r\n\t\ts = connect_id;\r\n\t\tbuffer_put_string(signbuf, s, strlen(s));\r\n\t\ts = \"publickey\";\r\n\t\tbuffer_put_string(signbuf, s, strlen(s));\r\n\t\tbuffer_put_char(signbuf, 1); // true\r\n\r\n\t\tputtykey = pvar->pageant_curkey;\r\n\r\n\t\t// \ufffd\ufffd\ufffd\ufffd\u0282\ufffd\ufffd\u75d8\ufffdp\ufffd\ufffd\ufffd\u93d0\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u80b7\ufffd\ufffd\r\n\t\tlen = get_uint32_MSBfirst(puttykey+4);\r\n\t\tkeytype_name = puttykey + 8;\r\n\t\tkeytype = get_hostkey_type_from_name(keytype_name);\r\n\t\tkeyalgo = choose_SSH2_keysign_algorithm(pvar, keytype);\r\n\t\tkeyalgo_name = get_ssh2_hostkey_algorithm_name(keyalgo);\r\n\t\tsignflag = get_ssh2_agent_flag(keyalgo);\r\n\r\n\t\t// \ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd\ufffd\ufffd\ufffdR\ufffds\ufffd[\ufffd\ufffd\ufffd\ufffd\r\n\t\tlen = strlen(keyalgo_name);\r\n\t\tbuffer_put_string(signbuf, keyalgo_name, len);\r\n\r\n\t\t// \ufffd\ufffd\ufffd\ufffd\ufffdR\ufffds\ufffd[\ufffd\ufffd\ufffd\ufffd\r\n\t\tlen = get_uint32_MSBfirst(puttykey);\r\n\t\tputtykey += 4;\r\n\t\tbuffer_put_string(signbuf, puttykey, len);\r\n\t\tputtykey += len;\r\n\r\n\t\t// Pageant \ufffd\u024f\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u70a4\r\n\t\tsignedmsg = putty_sign_ssh2_key(pvar->pageant_curkey,\r\n\t\t                                signbuf->buf, signbuf->len,\r\n\t\t                                &signedlen, signflag);\r\n\t\tbuffer_free(signbuf);\r\n\t\tif (signedmsg == NULL) {\r\n\t\t\tsafefree(pvar->pageant_key);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\r\n\r\n\t\t// \ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\u030d\\\ufffdz\r\n\t\tmsg = buffer_init();\r\n\t\tif (msg == NULL) {\r\n\t\t\tsafefree(pvar->pageant_key);\r\n\t\t\tsafefree(signedmsg);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\ts = username;  // \ufffd\ufffd\ufffd[\ufffdU\ufffd\ufffd\r\n\t\tbuffer_put_string(msg, s, strlen(s));\r\n\t\ts = connect_id;\r\n\t\tbuffer_put_string(msg, s, strlen(s));\r\n\t\ts = \"publickey\";\r\n\t\tbuffer_put_string(msg, s, strlen(s));\r\n\t\tbuffer_put_char(msg, 1); // true\r\n\r\n\t\tputtykey = pvar->pageant_curkey;\r\n\r\n\t\t// \ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd\ufffd\ufffd\ufffdR\ufffds\ufffd[\ufffd\ufffd\ufffd\ufffd\r\n\t\tlen = strlen(keyalgo_name);\r\n\t\tbuffer_put_string(msg, keyalgo_name, len);\r\n\r\n\t\t// \ufffd\ufffd\ufffd\ufffd\ufffdR\ufffds\ufffd[\ufffd\ufffd\ufffd\ufffd\r\n\t\tlen = get_uint32_MSBfirst(puttykey);\r\n\t\tputtykey += 4;\r\n\t\tbuffer_put_string(msg, puttykey, len);\r\n\t\tputtykey += len;\r\n\r\n\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ua0bd\ufffdf\ufffd[\ufffd^\r\n\t\tlen  = get_uint32_MSBfirst(signedmsg);\r\n\t\tbuffer_put_string(msg, signedmsg + 4, len);\r\n\t\tfree(signedmsg);\r\n\r\n\t\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffdM\r\n\t\tlen = buffer_len(msg);\r\n\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_USERAUTH_REQUEST, len);\r\n\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\tfinish_send_packet(pvar);\r\n\t\tbuffer_free(msg);\r\n\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: sending SSH2_MSG_USERAUTH_REQUEST method=publickey\", __FUNCTION__);\r\n\r\n\t\tpvar->pageant_keyfinal = TRUE;\r\n\r\n\t\treturn TRUE;\r\n\t}\r\n\r\n#define PASSWD_MAXLEN 150\r\n\r\nstruct change_password {\r\n\tPTInstVar pvar;\r\n\tchar passwd[PASSWD_MAXLEN];\r\n\tchar new_passwd[PASSWD_MAXLEN];\r\n};\r\n\r\nstatic INT_PTR CALLBACK passwd_change_dialog(HWND dlg, UINT msg, WPARAM wParam, LPARAM lParam)\r\n{\r\n\tchar old_passwd[PASSWD_MAXLEN];\r\n\tchar new_passwd[PASSWD_MAXLEN];\r\n\tchar retype_passwd[PASSWD_MAXLEN];\r\n\tstatic struct change_password *cp;\r\n\tchar uimsg[MAX_UIMSG];\r\n\tstatic PTInstVar pvar;\r\n\r\n\tswitch (msg) {\r\n\tcase WM_INITDIALOG:\r\n\t\tcp = (struct change_password *)lParam;\r\n\t\tpvar = cp->pvar;\r\n\r\n\t\tGetWindowText(dlg, uimsg, sizeof(uimsg));\r\n\t\tUTIL_get_lang_msg(\"DLG_PASSCHG_TITLE\", pvar, uimsg);\r\n\t\tSetWindowText(dlg, pvar->UIMsg);\r\n\r\n\t\tGetDlgItemText(dlg, IDC_PASSWD_CHANGEREQ_MSG, uimsg, sizeof(uimsg));\r\n\t\tUTIL_get_lang_msg(\"DLG_PASSCHG_MESSAGE\", pvar, uimsg);\r\n\t\tSetDlgItemText(dlg, IDC_PASSWD_CHANGEREQ_MSG, pvar->UIMsg);\r\n\r\n\t\tGetDlgItemText(dlg, IDC_OLD_PASSWD_LABEL, uimsg, sizeof(uimsg));\r\n\t\tUTIL_get_lang_msg(\"DLG_PASSCHG_OLDPASSWD\", pvar, uimsg);\r\n\t\tSetDlgItemText(dlg, IDC_OLD_PASSWD_LABEL, pvar->UIMsg);\r\n\r\n\t\tGetDlgItemText(dlg, IDC_NEW_PASSWD_LABEL, uimsg, sizeof(uimsg));\r\n\t\tUTIL_get_lang_msg(\"DLG_PASSCHG_NEWPASSWD\", pvar, uimsg);\r\n\t\tSetDlgItemText(dlg, IDC_NEW_PASSWD_LABEL, pvar->UIMsg);\r\n\r\n\t\tGetDlgItemText(dlg, IDC_CONFIRM_PASSWD_LABEL, uimsg, sizeof(uimsg));\r\n\t\tUTIL_get_lang_msg(\"DLG_PASSCHG_CONFIRMPASSWD\", pvar, uimsg);\r\n\t\tSetDlgItemText(dlg, IDC_CONFIRM_PASSWD_LABEL, pvar->UIMsg);\r\n\r\n\t\tSetFocus(GetDlgItem(dlg, IDC_OLD_PASSWD));\r\n\r\n\t\tCenterWindow(dlg, GetParent(dlg));\r\n\r\n\t\treturn FALSE;\r\n\r\n\tcase WM_COMMAND:\r\n\t\tswitch (LOWORD(wParam)) {\r\n\t\tcase IDOK:\r\n\t\t\tSendMessage(GetDlgItem(dlg, IDC_OLD_PASSWD), WM_GETTEXT , sizeof(old_passwd), (LPARAM)old_passwd);\r\n\t\t\tSendMessage(GetDlgItem(dlg, IDC_NEW_PASSWD), WM_GETTEXT , sizeof(new_passwd), (LPARAM)new_passwd);\r\n\t\t\tSendMessage(GetDlgItem(dlg, IDC_CONFIRM_PASSWD), WM_GETTEXT , sizeof(retype_passwd), (LPARAM)retype_passwd);\r\n\r\n\t\t\tif (strcmp(new_passwd, retype_passwd) == 1) {\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_PASSCHG_MISMATCH\", pvar, \"Mismatch; try again.\");\r\n\t\t\t\tMessageBox(NULL, pvar->UIMsg, \"ERROR\", MB_OK | MB_ICONEXCLAMATION);\r\n\t\t\t\treturn FALSE;\r\n\t\t\t}\r\n\r\n\t\t\tif (new_passwd[0] == 0) {\r\n\t\t\t\t// \ufffd_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\ufffd\ufffdJ\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffd\ufffd Return \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0702\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0311\u038d\ufffd\u0308\u05c1A\r\n\t\t\t\t// \ufffd\u0182\u80a0\ufffd\ufffd\ufffd\ufffd\ufffdV\ufffdp\ufffdX\ufffd\ufffd\ufffd[\ufffdh\ufffd\ufffd\ufffd\ufffd\u030f\ua347\ufffd\ufffd\ufffd\u0342\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffdB\r\n\t\t\t\t// c.f. Ticket: #38970\r\n\t\t\t\treturn FALSE;\r\n\t\t\t}\r\n\r\n\t\t\tstrncpy_s(cp->passwd, sizeof(cp->passwd), old_passwd, _TRUNCATE);\r\n\t\t\tstrncpy_s(cp->new_passwd, sizeof(cp->new_passwd), new_passwd, _TRUNCATE);\r\n\r\n\t\t\tEndDialog(dlg, 1); // dialog close\r\n\t\t\treturn TRUE;\r\n\r\n\t\tcase IDCANCEL:\r\n\t\t\t// \ufffd\u0691\ufffd\ufffd\ufffd\u0602\ufffd\r\n\t\t\tnotify_closed_connection(pvar, \"authentication cancelled\");\r\n\t\t\tEndDialog(dlg, 0); // dialog close\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t}\r\n\r\n\treturn FALSE;\r\n}\r\n\r\nBOOL handle_SSH2_userauth_passwd_changereq(PTInstVar pvar)\r\n{\r\n\tint len;\r\n\tINT_PTR ret;\r\n\tchar *data;\r\n\tbuffer_t *msg = NULL;\r\n\tchar *s, *username;\r\n\tunsigned char *outmsg;\r\n\tchar *connect_id = \"ssh-connection\";\r\n\tchar *info, *lang;\r\n\tstruct change_password cp;\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ was received.\");\r\n\r\n\tmemset(&cp, 0, sizeof(cp));\r\n\tcp.pvar = pvar;\r\n\tret = DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_SSHPASSWD_INPUT), pvar->cv->HWin, passwd_change_dialog, (LPARAM)&cp);\r\n\r\n\tif (ret == -1) {\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: DialogBoxParam failed.\", __FUNCTION__);\r\n\t\treturn FALSE;\r\n\t}\r\n\telse if (ret == 0) {\r\n\t\tlogprintf(LOG_LEVEL_NOTICE, \"%s: dialog cancelled.\", __FUNCTION__);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\t// 6byte\ufffdi\ufffdT\ufffdC\ufffdY\ufffd{\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd{\ufffd^\ufffdC\ufffdv\ufffdj\ufffd\ufffd\ufffd\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffd\u020d~\ufffd\u0303y\ufffdC\ufffd\ufffd\ufffd[\ufffdh\r\n\tdata = pvar->ssh_state.payload;\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY - (\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffdT\ufffdC\ufffdY+1)\ufffdG\ufffd^\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY\r\n\tlen = pvar->ssh_state.payloadlen;\r\n\r\n\tinfo = buffer_get_string(&data, NULL);\r\n\tlang = buffer_get_string(&data, NULL);\r\n\tif (info == NULL || lang == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR,\r\n\t\t\t\"%s: buffer_get_string returns NULL. info=%s, lang=%s\", __FUNCTION__,\r\n\t\t\tNonNull(info), NonNull(lang));\r\n\t}\r\n\telse {\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: info=%s, lang=%s\\n\", __FUNCTION__, info, lang);\r\n\t}\r\n\tfree(info);\r\n\tfree(lang);\r\n\r\n\tmsg = buffer_init();\r\n\tif (msg == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\t// \ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\u030d\\\ufffdz\r\n\tusername = pvar->auth_state.user;  // \ufffd\ufffd\ufffd[\ufffdU\ufffd\ufffd\r\n\tbuffer_put_string(msg, username, strlen(username));\r\n\r\n\t// password authentication method\r\n\ts = connect_id;\r\n\tbuffer_put_string(msg, s, strlen(s));\r\n\ts = \"password\";\r\n\tbuffer_put_string(msg, s, strlen(s));\r\n\r\n\tbuffer_put_char(msg, 1); // additional info\r\n\r\n\ts = cp.passwd;\r\n\tbuffer_put_string(msg, s, strlen(s));\r\n\r\n\ts = cp.new_passwd;\r\n\tbuffer_put_string(msg, s, strlen(s));\r\n\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffdM\r\n\tlen = buffer_len(msg);\r\n\toutmsg = begin_send_packet(pvar, SSH2_MSG_USERAUTH_REQUEST, len);\r\n\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\tfinish_send_packet(pvar);\r\n\tbuffer_free(msg);\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n/*\r\n * SSH_MSG_CHANNEL_REQUEST \ufffd\ufffd\ufffdM\ufffd\u0590\ufffd\r\n * type-specific data \ufffd\ufffd string \ufffd\ufffd 0 \ufffd` 2 \ufffd\u0315\ufffd\ufffd\u0251\u0389\ufffd\ufffdB\r\n * \ufffdg\ufffdp\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd\ufffd NULL \ufffd\u0242\ufffd\ufffd\ufffdB\r\n * type-specific data \ufffd\ufffd\ufffd\ufffd\ufffd\u030c`\ufffd\ufffd\ufffd\u0242\u0351\u0389\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0202\ufffd\ufffd\u0302\u0141A\ufffd\ufffd\ufffdO\ufffd\u0151\ufffd\ufffd\u9396\ufffdB\r\n */\r\nstatic BOOL send_channel_request_gen(PTInstVar pvar, Channel_t *c, unsigned char *req, int want_reply, unsigned char *msg1, unsigned char *msg2)\r\n{\r\n\tbuffer_t *msg;\r\n\tunsigned char *outmsg;\r\n\tint len;\r\n\r\n\tmsg = buffer_init();\r\n\tif (msg == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\treturn FALSE;\r\n\t}\r\n\tif (c->remote_id == SSH_CHANNEL_INVALID) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: invalid remote channel number (%d).\", __FUNCTION__, c->remote_id);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tbuffer_put_int(msg, c->remote_id);\r\n\tbuffer_put_string(msg, req, strlen(req));\r\n\r\n\tbuffer_put_char(msg, want_reply);\r\n\r\n\tif (msg1) {\r\n\t\tbuffer_put_string(msg, msg1, strlen(msg1));\r\n\t}\r\n\tif (msg2) {\r\n\t\tbuffer_put_string(msg, msg1, strlen(msg1));\r\n\t}\r\n\r\n\tlen = buffer_len(msg);\r\n\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_REQUEST, len);\r\n\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\tfinish_send_packet(pvar);\r\n\tbuffer_free(msg);\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: sending SSH2_MSG_CHANNEL_REQUEST. \"\r\n\t          \"local: %d, remote: %d, request-type: %s, msg1=%s, msg2=%s\", __FUNCTION__,\r\n\t          c->self_id, c->remote_id, req, msg1 ? msg1 : \"none\", msg2 ? msg2 : \"none\");\r\n\treturn TRUE;\r\n}\r\n\r\nBOOL send_pty_request(PTInstVar pvar, Channel_t *c)\r\n{\r\n\tbuffer_t *msg, *ttymsg;\r\n\tchar *req_type = \"pty-req\";  // pseudo terminal\ufffd\u0303\ufffd\ufffdN\ufffdG\ufffdX\ufffdg\r\n\tunsigned char *outmsg;\r\n\tint len, x, y;\r\n#ifdef DONT_WANTCONFIRM\r\n\tint want_reply = 0; // false\r\n#else\r\n\tint want_reply = 1; // true\r\n#endif\r\n\r\n\t// pty open\r\n\tmsg = buffer_init();\r\n\tif (msg == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL. (msg)\", __FUNCTION__);\r\n\t\treturn FALSE;\r\n\t}\r\n\tttymsg = buffer_init();\r\n\tif (ttymsg == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL. (ttymsg)\", __FUNCTION__);\r\n\t\tbuffer_free(msg);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tbuffer_put_int(msg, c->remote_id);\r\n\tbuffer_put_string(msg, req_type, strlen(req_type));\r\n\tbuffer_put_char(msg, want_reply);  // want_reply (disable\ufffd\u0255\u03cdX 2005/3/28 yutaka)\r\n\r\n\tbuffer_put_string(msg, pvar->ts->TermType, strlen(pvar->ts->TermType));\r\n\tbuffer_put_int(msg, pvar->ssh_state.win_cols);  // columns\r\n\tbuffer_put_int(msg, pvar->ssh_state.win_rows);  // lines\r\n\tget_window_pixel_size(pvar, &x, &y);\r\n\tbuffer_put_int(msg, x);  // window width (pixel):\r\n\tbuffer_put_int(msg, y);  // window height (pixel):\r\n\r\n\t// TTY mode\ufffd\u0342\ufffd\ufffd\ufffd\ufffd\u0153n\ufffd\ufffd (2005.7.17 yutaka)\r\n\tbuffer_put_char(ttymsg, SSH2_TTY_OP_OSPEED);\r\n\tbuffer_put_int(ttymsg, pvar->ts->TerminalOutputSpeed);  // baud rate\r\n\tbuffer_put_char(ttymsg, SSH2_TTY_OP_ISPEED);\r\n\tbuffer_put_int(ttymsg, pvar->ts->TerminalInputSpeed);  // baud rate\r\n\r\n\t// VERASE\r\n\tbuffer_put_char(ttymsg, SSH2_TTY_KEY_VERASE);\r\n\tif (pvar->ts->BSKey == IdBS) {\r\n\t\tbuffer_put_int(ttymsg, 0x08); // BS key\r\n\t} else {\r\n\t\tbuffer_put_int(ttymsg, 0x7F); // DEL key\r\n\t}\r\n\r\n\tswitch (pvar->ts->CRReceive) {\r\n\t  case IdLF:\r\n\t\tbuffer_put_char(ttymsg, SSH2_TTY_OP_ONLCR);\r\n\t\tbuffer_put_int(ttymsg, 0);\r\n\t\tbreak;\r\n\t  case IdCR:\r\n\t\tbuffer_put_char(ttymsg, SSH2_TTY_OP_ONLCR);\r\n\t\tbuffer_put_int(ttymsg, 1);\r\n\t\tbreak;\r\n\t  default:\r\n\t\tbreak;\r\n\t}\r\n\r\n\tbuffer_put_char(ttymsg, SSH2_TTY_OP_END); // End of terminal modes\r\n\r\n\t// SSH2\ufffd\u0142\u0355\ufffd\ufffd\ufffd\ufffd\ufffd\u0182\ufffd\ufffd\u010f\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0781B\r\n\tbuffer_put_string(msg, buffer_ptr(ttymsg), buffer_len(ttymsg));\r\n\r\n\tlen = buffer_len(msg);\r\n\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_REQUEST, len);\r\n\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\tfinish_send_packet(pvar);\r\n\tbuffer_free(msg);\r\n\tbuffer_free(ttymsg);\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: sending SSH2_MSG_CHANNEL_REQUEST. \"\r\n\t          \"local: %d, remote: %d, request-type: %s, \"\r\n\t          \"term: %s, cols: %d, rows: %d, x: %d, y: %d, \"\r\n\t          \"out-speed: %d, in-speed: %d, verase: %s, onlcr: %s\", __FUNCTION__,\r\n\t          c->self_id, c->remote_id, req_type, pvar->ts->TermType,\r\n\t          pvar->ssh_state.win_cols, pvar->ssh_state.win_rows, x, y,\r\n\t          pvar->ts->TerminalOutputSpeed, pvar->ts->TerminalInputSpeed,\r\n\t          (pvar->ts->BSKey==IdBS)?\"^h\":\"^?\", (pvar->ts->CRReceive==IdBS)?\"on\":\"off\");\r\n\r\n\tpvar->session_nego_status = 2;\r\n\r\n\tif (want_reply == 0) {\r\n\t\thandle_SSH2_channel_success(pvar);\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_SSH2_open_confirm(PTInstVar pvar)\r\n{\r\n\tint len;\r\n\tchar *data;\r\n\tint id, remote_id;\r\n\tChannel_t *c;\r\n\tchar buff[MAX_PATH + 30];\r\n\r\n#ifdef DONT_WANTCONFIRM\r\n\tint want_reply = 0; // false\r\n#else\r\n\tint want_reply = 1; // true\r\n#endif\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_CHANNEL_OPEN_CONFIRMATION was received.\");\r\n\r\n\t// 6byte\ufffdi\ufffdT\ufffdC\ufffdY\ufffd{\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd{\ufffd^\ufffdC\ufffdv\ufffdj\ufffd\ufffd\ufffd\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffd\u020d~\ufffd\u0303y\ufffdC\ufffd\ufffd\ufffd[\ufffdh\r\n\tdata = pvar->ssh_state.payload;\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY - (\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffdT\ufffdC\ufffdY+1)\ufffdG\ufffd^\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY\r\n\tlen = pvar->ssh_state.payloadlen;\r\n\r\n\tid = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\r\n\tc = ssh2_channel_lookup(id);\r\n\tif (c == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: channel not found. (%d)\", __FUNCTION__, id);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tremote_id = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\r\n\tc->remote_id = remote_id;\r\n\tif (c->self_id == pvar->shell_id) {\r\n\t\t// \ufffd\u014f\ufffd\ufffd\u0303`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\u020aO\ufffd\u0143\ufffd\ufffdZ\ufffdb\ufffdg\ufffd\ufffd\ufffd\u0102\u0342\ufffd\ufffd\ufffd\ufffd\u0202\ufffd (2008.12.19 maya)\r\n\t\tpvar->session_nego_status = 1;\r\n\t}\r\n\r\n\t// remote window size\r\n\tc->remote_window = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\tc->remote_maxpacket = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\r\n\tswitch (c->type) {\r\n\tcase TYPE_PORTFWD:\r\n\t\t// port-forwading\ufffd\ufffd\"direct-tcpip\"\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\tFWD_confirmed_open(pvar, c->local_num, -1);\r\n\t\tbreak;\r\n\r\n\tcase TYPE_SHELL:\r\n\t\t// \ufffd|\ufffd[\ufffdg\ufffdt\ufffdH\ufffd\ufffd\ufffd[\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd\u030f\ufffd\ufffd\ufffd (2005.2.26, 2005.6.21 yutaka)\r\n\t\t// \ufffdV\ufffdF\ufffd\ufffd\ufffdI\ufffd[\ufffdv\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0182\ufffd X11 \ufffd\u0317v\ufffd\ufffd\ufffd\ufffd\ufffdo\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\u0102\u0342\u0202\ufffd\u0202\ufffd\ufffdB(2005.7.3 yutaka)\r\n\t\tFWD_prep_forwarding(pvar);\r\n\t\tFWD_enter_interactive_mode(pvar);\r\n\r\n\t\t// \ufffdG\ufffd[\ufffdW\ufffdF\ufffd\ufffd\ufffdg\ufffd]\ufffd\ufffd (2008.11.25 maya)\r\n\t\tif (pvar->session_settings.ForwardAgent) {\r\n\t\t\t// pty-req \ufffd\ufffd\ufffdO\ufffd\u0243\ufffd\ufffdN\ufffdG\ufffdX\ufffdg\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\u0183G\ufffd\ufffd\ufffd[\ufffd\u0242\u0202\ufffd\u0357l\r\n\t\t\treturn send_channel_request_gen(pvar, c, \"auth-agent-req@openssh.com\", 1, NULL, NULL);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn send_pty_request(pvar, c);\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase TYPE_SCP:\r\n\t\tif (c->scp.dir == TOREMOTE) {\r\n\t\t\t_snprintf_s(buff, sizeof(buff), _TRUNCATE, \"scp -t %s\", c->scp.remotefile);\r\n\r\n\t\t} else {\r\n\t\t\t// \ufffdt\ufffd@\ufffdC\ufffd\ufffd\ufffd\ufffd\ufffd\u024b\udb11\udc82\ufffd\ufffd\u0702\u0702\ufffd\u0102\ufffd\ufffd\u0102\ufffd\ufffd\u60a2\ufffd\u60a4\ufffd\u0241A\ufffdt\ufffd@\ufffdC\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdd\ufffd\ufffd\ufffdp\ufffd\ufffd\ufffd\u0148\u0342\u0781B\r\n\t\t\t// (2014.7.13 yutaka)\r\n\t\t\t_snprintf_s(buff, sizeof(buff), _TRUNCATE, \"scp -p -f \\\"%s\\\"\", c->scp.remotefile);\r\n\t\t}\r\n\r\n\t\tif (!send_channel_request_gen(pvar, c, \"exec\", want_reply, buff, NULL)) {\r\n\t\t\treturn FALSE;;\r\n\t\t}\r\n\r\n\t\t// SCP\ufffd\ufffd remote-to-local \ufffd\u030f\ua347\ufffd\u0341A\ufffdT\ufffd[\ufffdo\ufffd\ufffd\ufffd\ufffd\u0303t\ufffd@\ufffdC\ufffd\ufffd\ufffd\ufffd\ufffdM\ufffdv\ufffd\ufffd\ufffd\ufffd\ufffdo\ufffd\ufffd\ufffdB\r\n\t\t// \ufffd\ufffd\ufffd\u030e\ufffd\ufffd_\ufffd\u0142\ufffd remote window size \ufffd\ufffd\"0\"\ufffd\u0202\u0302\u0141A\ufffd\ufffd\ufffd\ufffd\ufffd\u0242\u0351\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffdA\ufffdx\ufffd\ufffd\ufffd\ufffd\ufffdM\ufffd\ufffd\ufffd\ufffd\ufffd\u0151\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\t// (2007.12.27 yutaka)\r\n\t\tif (c->scp.dir == FROMREMOTE) {\r\n\t\t\tchar ch = '\\0';\r\n\t\t\tSSH2_send_channel_data(pvar, c, &ch, 1, 0);\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase TYPE_SFTP:\r\n\t\tif (!send_channel_request_gen(pvar, c, \"subsystem\", want_reply, \"sftp\", NULL)) {\r\n\t\t\treturn FALSE;;\r\n\t\t}\r\n\r\n\t\t// SFTP\ufffdZ\ufffdb\ufffdV\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdJ\ufffdn\ufffd\ufffd\ufffd\u90bd\ufffd\u07c2\u0303l\ufffdS\ufffdV\ufffdG\ufffd[\ufffdV\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffds\ufffd\ufffd\ufffdB\r\n\t\t// (2012.5.3 yutaka)\r\n\t\tsftp_do_init(pvar, c);\r\n\t\tbreak;\r\n\r\n\tcase TYPE_SUBSYSTEM_GEN:\r\n\t\tif (!send_channel_request_gen(pvar, c, \"subsystem\", want_reply, pvar->subsystem_name, NULL)) {\r\n\t\t\treturn FALSE;;\r\n\t\t}\r\n\t\tpvar->session_nego_status = 0;\r\n\t\tbreak;\r\n\r\n\tdefault: // NOT REACHED\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: Invalid channel-type. (%d)\", __FUNCTION__, c->type);\r\n\t\treturn FALSE;\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\n// SSH2 port-forwarding \ufffd\u0242\ufffd\ufffd\ufffd\ufffd\u0103Z\ufffdb\ufffdV\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdI\ufffd[\ufffdv\ufffd\ufffd\ufffd\u0142\ufffd\ufffd\u0202\ufffd\ufffd\ua347\ufffd\u0303T\ufffd[\ufffdo\ufffd\ufffd\ufffd\ufffd\u0303\ufffd\ufffdv\ufffd\ufffd\ufffdC\ufffdi\ufffd\ufffd\ufffds\ufffdj\r\nstatic BOOL handle_SSH2_open_failure(PTInstVar pvar)\r\n{\r\n\tint len;\r\n\tchar *data;\r\n\tint id;\r\n\tChannel_t *c;\r\n\tint reason;\r\n\tchar *cstring;\r\n\tchar tmpbuf[256];\r\n\tchar *rmsg;\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_CHANNEL_OPEN_FAILURE was received.\");\r\n\r\n\t// 6byte\ufffdi\ufffdT\ufffdC\ufffdY\ufffd{\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd{\ufffd^\ufffdC\ufffdv\ufffdj\ufffd\ufffd\ufffd\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffd\u020d~\ufffd\u0303y\ufffdC\ufffd\ufffd\ufffd[\ufffdh\r\n\tdata = pvar->ssh_state.payload;\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY - (\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffdT\ufffdC\ufffdY+1)\ufffdG\ufffd^\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY\r\n\tlen = pvar->ssh_state.payloadlen;\r\n\r\n\tid = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\r\n\tc = ssh2_channel_lookup(id);\r\n\tif (c == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: channel not found. (%d)\", __FUNCTION__, id);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\treason = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\r\n\tif (reason == SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED) {\r\n\t\trmsg = \"administratively prohibited\";\r\n\t} else if (reason == SSH2_OPEN_CONNECT_FAILED) {\r\n\t\trmsg = \"connect failed\";\r\n\t} else if (reason == SSH2_OPEN_UNKNOWN_CHANNEL_TYPE) {\r\n\t\trmsg = \"unknown channel type\";\r\n\t} else if (reason == SSH2_OPEN_RESOURCE_SHORTAGE) {\r\n\t\trmsg = \"resource shortage\";\r\n\t} else {\r\n\t\trmsg = \"unknown reason\";\r\n\t}\r\n\r\n\tcstring = buffer_get_string(&data, NULL);\r\n\r\n\tif (cstring == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_get_string returns NULL\", __FUNCTION__);\r\n\t}\r\n\tUTIL_get_lang_msg(\"MSG_SSH_CHANNEL_OPEN_ERROR\", pvar,\r\n\t                  \"SSH2_MSG_CHANNEL_OPEN_FAILURE was received.\\r\\nchannel [%d]: reason: %s(%d) message: %s\");\r\n\t_snprintf_s(tmpbuf, sizeof(tmpbuf), _TRUNCATE, pvar->UIMsg,\r\n\t            id, rmsg, reason, NonNull(cstring));\r\n\tif ((pvar->settings.DisablePopupMessage & POPUP_MSG_FWD_channel_open) == 0) {\r\n\t\tnotify_nonfatal_error(pvar, tmpbuf);\r\n\t}\r\n\telse {\r\n\t\tlogputs(LOG_LEVEL_ERROR, tmpbuf);\r\n\t}\r\n\r\n\tfree(cstring);\r\n\r\n\tif (c->type == TYPE_PORTFWD) {\r\n\t\tFWD_failed_open(pvar, c->local_num, reason);\r\n\t}\r\n\r\n\t// \ufffd`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\u0309\ufffd\ufffd\ufffdR\ufffd\ufffd\ufffd\ufffdC\ufffd\ufffd (2007.5.1 maya)\r\n\tssh2_channel_delete(c);\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n// SSH2_MSG_GLOBAL_REQUEST for OpenSSH 6.8\r\nstatic BOOL handle_SSH2_client_global_request(PTInstVar pvar)\r\n{\r\n\tint len, n;\r\n\tchar *data;\r\n\tchar *rtype;\r\n\tint want_reply;\r\n\tint success = 0;\r\n\tbuffer_t *msg;\r\n\tunsigned char *outmsg;\r\n\tint type;\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_GLOBAL_REQUEST was received.\");\r\n\r\n\t// SSH2 packet format:\r\n\t// size(4) + padding size(1) + type(1) + payload(N) + padding(X)\r\n\t//                                       ^data\r\n\t//           <-----------------size---------------------------->\r\n\t//                             <--------len------->\r\n\t//\r\n\t// data: \ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd^\ufffdC\ufffdv\ufffd\u0251\ufffd\ufffd\ufffd\ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\u0310\u64ea\ufffd\ufffd\ufffdw\ufffd\ufffd\ufffd|\ufffdC\ufffd\ufffd\ufffd^\r\n\tdata = pvar->ssh_state.payload;\r\n\t// len = size - (padding size + sizeof(padding size)) = sizeof(type) + sizeof(payload):\r\n\t// \ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\ufffd\ufffd\ufffd\ufffd\u0312\ufffd\ufffd\ufffd\ufffdBtype \ufffd\ufffd\ufffd\ufffd\ufffd\u0702\ufffd\r\n\tlen = pvar->ssh_state.payloadlen;\r\n\r\n\tlen--;   // type \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\r\n\trtype = buffer_get_string(&data, &n);\r\n\tlen -= (n + 4);\r\n\r\n\twant_reply = data[0];\r\n\tdata++;\r\n\tlen--;\r\n\r\n\tif (rtype == NULL) {\r\n\t\t// rtype \ufffd\ufffd NULL \ufffd\u0156\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0315\u06cf\ufffd\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_get_string returns NULL.\", __FUNCTION__);\r\n\t}\r\n\telse if (strcmp(rtype, \"hostkeys-00@openssh.com\") == 0) {\r\n\t\t// OpenSSH 6.8\ufffd\u0142\u0341A\ufffdT\ufffd[\ufffdo\ufffd\u0303z\ufffdX\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffdX\ufffdV\ufffd\ufffd\ufffd\ufffd\ufffd\u0181A\ufffd\ufffd\ufffd\u0312\u0292m\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\t// OpenSSH 6.8\ufffd\u030e\ufffd\ufffd\ufffd\ufffd\u0142\u0341A\ufffd\ufffd\u0250\ufffd\ufffd\ufffd\ufffd\u0155\u0502\ufffd\ufffd\u60a4\ufffd\u0242\u0202\ufffd\ufffd\u0102\ufffd\ufffd\u90bd\ufffd\u07c1A\r\n\t\t// \ufffd\ufffd\ufffd\ufffd\u024d\ufffd\ufffd\ud0b9\ufffd\ufffd Tera Term \ufffd\u0142\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0195\u0502\ufffd\ufffd\ufffd\ufffd\u0182\u0242\ufffd\ufffd\ufffdB\r\n\t\tsuccess = update_client_input_hostkeys(pvar, data, len);\r\n\r\n\t}\r\n\tfree(rtype);\r\n\r\n\tif (want_reply) {\r\n\t\tmsg = buffer_init();\r\n\t\tif (msg) {\r\n\t\t\tlen = buffer_len(msg);\r\n\t\t\ttype = success ? SSH2_MSG_REQUEST_SUCCESS : SSH2_MSG_REQUEST_FAILURE;\r\n\t\t\toutmsg = begin_send_packet(pvar, type, len);\r\n\t\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\t\tfinish_send_packet(pvar);\r\n\t\t\tbuffer_free(msg);\r\n\t\t}\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n\r\n// SSH2 port-forwarding (remote -> local)\ufffd\u0251\u0382\ufffd\ufffd\u90ca\ufffdv\ufffd\ufffd\ufffdC\ufffdi\ufffd\ufffd\ufffd\ufffd\ufffdj\r\nstatic BOOL handle_SSH2_request_success(PTInstVar pvar)\r\n{\r\n\t// \ufffdK\ufffdv\ufffd\u0142\ufffd\ufffd\ufffd\u0383\ufffd\ufffdO\ufffd\ufffd\ufffd\ufffd\ufffdB\ufffd\ufffd\ufffd\u0249\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\u0102\ufffd\ufffd\u60a2\ufffdB\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_REQUEST_SUCCESS was received.\");\r\n\r\n\tclient_global_request_reply(pvar, SSH2_MSG_REQUEST_SUCCESS, 0, NULL);\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n// SSH2 port-forwarding (remote -> local)\ufffd\u0251\u0382\ufffd\ufffd\u90ca\ufffdv\ufffd\ufffd\ufffdC\ufffdi\ufffd\ufffd\ufffds\ufffdj\r\nstatic BOOL handle_SSH2_request_failure(PTInstVar pvar)\r\n{\r\n\t// \ufffdK\ufffdv\ufffd\u0142\ufffd\ufffd\ufffd\u0383\ufffd\ufffdO\ufffd\ufffd\ufffd\ufffd\ufffdB\ufffd\ufffd\ufffd\u0249\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\u0102\ufffd\ufffd\u60a2\ufffdB\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_REQUEST_FAILURE was received.\");\r\n\r\n\tclient_global_request_reply(pvar, SSH2_MSG_REQUEST_FAILURE, 0, NULL);\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_SSH2_channel_success(PTInstVar pvar)\r\n{\r\n\tChannel_t *c;\r\n#ifdef DONT_WANTCONFIRM\r\n\tint want_reply = 0; // false\r\n#else\r\n\tint want_reply = 1; // true\r\n#endif\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE,\r\n\t\t\"SSH2_MSG_CHANNEL_SUCCESS was received(nego_status %d).\",\r\n\t\tpvar->session_nego_status);\r\n\r\n\tif (pvar->session_nego_status == 1) {\r\n\t\tc = ssh2_channel_lookup(pvar->shell_id);\r\n\t\tif (c == NULL) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: shell channel not found.\", __FUNCTION__);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\tif (c->remote_id == SSH_CHANNEL_INVALID) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: remote shell channel number is unknown.\", __FUNCTION__);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\tpvar->agentfwd_enable = TRUE;\r\n\t\treturn send_pty_request(pvar, c);\r\n\r\n\t} else if (pvar->session_nego_status == 2) {\r\n\t\tpvar->session_nego_status = 3;\r\n\r\n\t\tc = ssh2_channel_lookup(pvar->shell_id);\r\n\t\tif (c == NULL) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: shell channel not found.\", __FUNCTION__);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\tif (c->remote_id == SSH_CHANNEL_INVALID) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: remote shell channel number is unknown.\", __FUNCTION__);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\r\n\t\tif (!send_channel_request_gen(pvar, c, \"shell\", want_reply, NULL, NULL)) {\r\n\t\t\treturn FALSE;;\r\n\t\t}\r\n\r\n\t\tif (want_reply == 0) {\r\n\t\t\thandle_SSH2_channel_success(pvar);\r\n\t\t}\r\n\r\n\t} else if (pvar->session_nego_status == 3) {\r\n\t\tpvar->session_nego_status = 4;\r\n\r\n\t} else {\r\n\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_SSH2_channel_failure(PTInstVar pvar)\r\n{\r\n\tChannel_t *c;\r\n\tchar *data;\r\n\tint channel_id;\r\n\r\n\tdata = pvar->ssh_state.payload;\r\n\tchannel_id = get_uint32_MSBfirst(data);\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_CHANNEL_FAILURE was received.\");\r\n\r\n\tc = ssh2_channel_lookup(channel_id);\r\n\tif (c == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: channel not found. (%d)\", __FUNCTION__, channel_id);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tif (pvar->shell_id == channel_id) {\r\n\t\tif (c->type == TYPE_SUBSYSTEM_GEN) {\r\n\t\t\t// \ufffdT\ufffdu\ufffdV\ufffdX\ufffde\ufffd\ufffd\ufffd\u030bN\ufffd\ufffd\ufffd\u024e\ufffd\ufffds\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0150\u0602\ufffdB\r\n\t\t\tchar errmsg[MAX_UIMSG];\r\n\t\t\tUTIL_get_lang_msg(\"MSG_SSH_SUBSYSTEM_REQUEST_ERROR\", pvar, \"subsystem request failed. (%s)\");\r\n\t\t\t_snprintf_s(errmsg, sizeof(errmsg), _TRUNCATE, pvar->UIMsg, pvar->subsystem_name);\r\n\t\t\tnotify_fatal_error(pvar, errmsg, TRUE);\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t\telse { // TYPE_SHELL\r\n\t\t\tif (pvar->session_nego_status == 1) {\r\n\t\t\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd[\ufffdg\ufffd\ufffd auth-agent-req@openssh.com \ufffd\ufffd\ufffdT\ufffd|\ufffd[\ufffdg\ufffd\ufffd\ufffd\ufffd\u0102\u0202\ufffd\ufffd\u0302\ufffd\r\n\t\t\t\t// \ufffdG\ufffd\ufffd\ufffd[\ufffd\u034bC\ufffd\u0242\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0590i\ufffd\ufffd\r\n\t\t\t\tlogputs(LOG_LEVEL_VERBOSE, \"auth-agent-req@openssh.com is not supported by remote host.\");\r\n\r\n\t\t\t\treturn send_pty_request(pvar, c);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tssh2_channel_delete(c);\r\n\treturn TRUE;\r\n}\r\n\r\n\r\n\r\n// \ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg\ufffd\ufffdwindow size\ufffd\ufffd\ufffdT\ufffd[\ufffdo\ufffd\u0592m\ufffd\u70b9\ufffd\ufffd\r\nstatic void do_SSH2_adjust_window_size(PTInstVar pvar, Channel_t *c)\r\n{\r\n\t// window size\ufffd\ufffd32KB\ufffd\u0595\u03cdX\ufffd\ufffd\ufffdAlocal window\ufffd\u0314\ufffd\ufffd\u0282\ufffd\ufffdC\ufffd\ufffd\ufffdB\r\n\t// \ufffd\ufffd\ufffd\ufffd\u0242\ufffd\ufffdSSH2\ufffd\u0303X\ufffd\ufffd\ufffd[\ufffdv\ufffdb\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\u30b7\ufffd\ufffdB(2006.3.6 yutaka)\r\n\tbuffer_t *msg;\r\n\tunsigned char *outmsg;\r\n\tint len;\r\n\r\n\t// \ufffd\ufffd\ufffd[\ufffdJ\ufffd\ufffd\ufffd\ufffdwindow size\ufffd\u0242\u0702\ufffd\ufffd]\ufffdT\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffdA\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t// added /2 (2006.3.6 yutaka)\r\n\tif (c->local_window > c->local_window_max/2)\r\n\t\treturn;\r\n\r\n\t{\r\n\t\t// pty open\r\n\t\tmsg = buffer_init();\r\n\t\tif (msg == NULL) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbuffer_put_int(msg, c->remote_id);\r\n\t\tbuffer_put_int(msg, c->local_window_max - c->local_window);\r\n\r\n\t\tlen = buffer_len(msg);\r\n\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_WINDOW_ADJUST, len);\r\n\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\tfinish_send_packet(pvar);\r\n\t\tbuffer_free(msg);\r\n\r\n\t\tlogputs(LOG_LEVEL_SSHDUMP, \"SSH2_MSG_CHANNEL_WINDOW_ADJUST was sent at do_SSH2_adjust_window_size().\");\r\n\t\t// \ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg\ufffd\ufffdwindow size\ufffd\ud805\udf42\u20b7\r\n\t\tc->local_window = c->local_window_max;\r\n\t}\r\n\r\n}\r\n\r\n\r\nvoid ssh2_channel_send_close(PTInstVar pvar, Channel_t *c)\r\n{\r\n\tif (SSHv2(pvar)) {\r\n\t\tbuffer_t *msg;\r\n\t\tunsigned char *outmsg;\r\n\t\tint len;\r\n\r\n\t\t// \ufffd\ufffd\ufffd\ufffdchannel\ufffd\u0242\u0082\ufffd\ufffd\ufffdclose\ufffd\ud805\uddd0M\ufffd\u03c2\u0742\u0202\u7457\ufffd\ufffd\u0202\ufffd\r\n\t\tif (c->state & SSH_CHANNEL_STATE_CLOSE_SENT) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// SSH2 server\ufffd\ufffdchannel close\ufffd\ufffd`\ufffd\ufffd\ufffd\ufffd\r\n\t\tmsg = buffer_init();\r\n\t\tif (msg == NULL) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbuffer_put_int(msg, c->remote_id);\r\n\r\n\t\tlen = buffer_len(msg);\r\n\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_CLOSE, len);\r\n\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\tfinish_send_packet(pvar);\r\n\t\tbuffer_free(msg);\r\n\r\n\t\tc->state |= SSH_CHANNEL_STATE_CLOSE_SENT;\r\n\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"SSH2_MSG_CHANNEL_CLOSE was sent at ssh2_channel_send_close(). local:%d remote:%d\", c->self_id, c->remote_id);\r\n\t}\r\n}\r\n\r\n\r\n#define WM_SENDING_FILE (WM_USER + 1)\r\n#define WM_CHANNEL_CLOSE (WM_USER + 2)\r\n#define WM_GET_CLOSED_STATUS (WM_USER + 3)\r\n\r\ntypedef struct scp_dlg_parm {\r\n\tChannel_t *c;\r\n\tPTInstVar pvar;\r\n\tchar *buf;\r\n\tsize_t buflen;\r\n} scp_dlg_parm_t;\r\n\r\nstatic INT_PTR CALLBACK ssh_scp_dlg_proc(HWND hWnd, UINT msg, WPARAM wp, LPARAM lp)\r\n{\r\n\tstatic int closed = 0;\r\n\r\n\tswitch (msg) {\r\n\t\tcase WM_INITDIALOG:\r\n\t\t\tclosed = 0;\r\n\t\t\tCenterWindow(hWnd, GetParent(hWnd));\r\n\t\t\treturn FALSE;\r\n\r\n\t\t// SCP\ufffdt\ufffd@\ufffdC\ufffd\ufffd\ufffd\ufffdM(remote-to-local)\ufffd\ufffd\ufffdA\ufffdg\ufffdp\ufffd\ufffd\ufffd\ufffdB\r\n\t\tcase WM_CHANNEL_CLOSE:\r\n\t\t\t{\r\n\t\t\tscp_dlg_parm_t *parm = (scp_dlg_parm_t *)wp;\r\n\r\n\t\t\tssh2_channel_send_close(parm->pvar, parm->c);\r\n\t\t\t}\r\n\t\t\treturn TRUE;\r\n\t\t\tbreak;\r\n\r\n\t\tcase WM_SENDING_FILE:\r\n\t\t\t{\r\n\t\t\tscp_dlg_parm_t *parm = (scp_dlg_parm_t *)wp;\r\n\r\n\t\t\tSSH2_send_channel_data(parm->pvar, parm->c, parm->buf, parm->buflen, 0);\r\n\t\t\t}\r\n\t\t\treturn TRUE;\r\n\t\t\tbreak;\r\n\r\n\t\tcase WM_COMMAND:\r\n\t\t\tswitch (wp) {\r\n\t\t\t}\r\n\r\n\t\t\tswitch (LOWORD(wp)) {\r\n\t\t\t\tcase IDOK:\r\n\t\t\t\t\t{\r\n\t\t\t\t\treturn TRUE;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\tcase IDCANCEL:\r\n\t\t\t\t\t// \ufffdE\ufffdB\ufffd\ufffd\ufffdh\ufffdE\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffdj\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0142\u0342\u0202\ufffd\ufffdA\ufffd\ufffd\\\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\ufffd\u0302\u0742\u0182\ufffd\ufffd\u0101A\r\n\t\t\t\t\t// \ufffdX\ufffd\ufffd\ufffdb\ufffdh\ufffd\ufffd\ufffd\ufffd\u0303\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0142\ufffd\ufffd\ufffd\u60a4\ufffd\u0242\ufffd\ufffd\ufffdB\r\n\t\t\t\t\t// (2011.6.8 yutaka)\r\n\t\t\t\t\t//EndDialog(hWnd, 0);\r\n\t\t\t\t\t//DestroyWindow(hWnd);\r\n\t\t\t\t\tShowWindow(hWnd, SW_HIDE);\r\n\t\t\t\t\tclosed = 1;\r\n\t\t\t\t\treturn TRUE;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\treturn FALSE;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\t\tcase WM_CLOSE:\r\n\t\t\t// close\ufffd{\ufffd^\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd window \ufffd\ufffd\ufffd\u0082\ufffd\ufffd\u0202\ufffd\ufffd\u60a4\ufffd\u0242\ufffd\ufffd\ufffdB\r\n\t\t\treturn TRUE;\r\n\r\n\t\tcase WM_DESTROY:\r\n\t\t\treturn TRUE;\r\n\r\n\t\tcase WM_GET_CLOSED_STATUS:\r\n\t\t\t{\r\n\t\t\tint *flag = (int *)wp;\r\n\r\n\r\n\r\n\t\t\t*flag = closed;\r\n\t\t\t}\r\n\t\t\treturn TRUE;\r\n\r\n\t\tdefault:\r\n\t\t\treturn FALSE;\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\nstatic int is_canceled_window(HWND hd)\r\n{\r\n\tint closed = 0;\r\n\r\n\tSendMessage(hd, WM_GET_CLOSED_STATUS, (WPARAM)&closed, 0);\r\n\tif (closed)\r\n\t\treturn 1;\r\n\telse\r\n\t\treturn 0;\r\n}\r\n\r\nstatic BOOL SetDlgItemTextU8(HWND hDlg, int nIDDlgItem, const char *strU8)\r\n{\r\n\twchar_t *strW = ToWcharU8(strU8);\r\n\tBOOL retval = SetDlgItemTextW(hDlg, nIDDlgItem, strW);\r\n\tfree(strW);\r\n\treturn retval;\r\n}\r\n\r\nstatic unsigned __stdcall ssh_scp_thread(void *p)\r\n{\r\n\tChannel_t *c = (Channel_t *)p;\r\n\tPTInstVar pvar = c->scp.pvar;\r\n\tlong long total_size = 0;\r\n\tchar *buf = NULL;\r\n\tsize_t buflen;\r\n\tchar s[80];\r\n\tsize_t ret;\r\n\tHWND hWnd = c->scp.progress_window;\r\n\tscp_dlg_parm_t parm;\r\n\tint rate, ProgStat;\r\n\tDWORD stime;\r\n\tint elapsed, prev_elapsed;\r\n\r\n\tbuflen = min(c->remote_window, 8192*4); // max 32KB\r\n\tbuf = malloc(buflen);\r\n\r\n\tSetDlgItemTextU8(hWnd, IDC_FILENAME, c->scp.localfilefull);\r\n\r\n\tInitDlgProgress(hWnd, IDC_PROGBAR, &ProgStat);\r\n\r\n\tstime = GetTickCount();\r\n\tprev_elapsed = 0;\r\n\r\n\tdo {\r\n\t\tint readlen, count=0;\r\n\r\n\t\t// Cancel\ufffd{\ufffd^\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ua0bd\ufffd\ufffdE\ufffdB\ufffd\ufffd\ufffdh\ufffdE\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\tif (is_canceled_window(hWnd))\r\n\t\t\tgoto cancel_abort;\r\n\r\n\t\t// \ufffdt\ufffd@\ufffdC\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u01c2\u074d\ufffd\ufffd\ud8cb\udf83f\ufffd[\ufffd^\ufffd\u0342\ufffd\ufffd\u0202\u70b8\ufffdT\ufffd[\ufffdo\ufffd\u0591\ufffd\ufffdM\ufffd\ufffd\ufffd\ufffdB\r\n\t\treadlen = max(4096, min(buflen, c->remote_window)); // min 4KB\r\n\t\tret = fread(buf, 1, readlen, c->scp.localfp);\r\n\t\tif (ret == 0)\r\n\t\t\tbreak;\r\n\r\n\t\t// remote_window \ufffd\ufffd\ufffd\ud915\udf02\ufffd\ufffd\ufffd\u0702\u0151\u0482\ufffd\r\n\t\tdo {\r\n\t\t\t// socket or channel\ufffd\ufffd\ufffdN\ufffd\ufffd\ufffd[\ufffdY\ufffd\ufffd\ufffd\ua0bd\ufffd\ufffdX\ufffd\ufffd\ufffdb\ufffdh\ufffd\ufffd\ufffdI\ufffd\ufffd\ufffd\r\n\t\t\tif (pvar->socket == INVALID_SOCKET || c->scp.state == SCP_CLOSING || c->used == 0)\r\n\t\t\t\tgoto abort;\r\n\r\n\t\t\tif (ret > c->remote_window) {\r\n\t\t\t\tSleep(100);\r\n\t\t\t}\r\n\r\n\t\t\t// 100\ufffd\ud913\udc82\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u7532\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0702\ufffd\r\n\t\t\tcount++;\r\n\t\t\tif (count > 100) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t} while (ret > c->remote_window);\r\n\r\n\t\t// sending data\r\n\t\tparm.buf = buf;\r\n\t\tparm.buflen = ret;\r\n\t\tparm.c = c;\r\n\t\tparm.pvar = pvar;\r\n\t\tSendMessage(hWnd, WM_SENDING_FILE, (WPARAM)&parm, 0);\r\n\r\n\t\ttotal_size += ret;\r\n\r\n\t\trate = (int)(100 * total_size / c->scp.filestat.st_size);\r\n\t\t_snprintf_s(s, sizeof(s), _TRUNCATE, \"%lld / %lld (%d%%)\", total_size, c->scp.filestat.st_size, rate);\r\n\t\tSendMessage(GetDlgItem(hWnd, IDC_PROGRESS), WM_SETTEXT, 0, (LPARAM)s);\r\n\t\tif (ProgStat != rate) {\r\n\t\t\tProgStat = rate;\r\n\t\t\tSendDlgItemMessage(hWnd, IDC_PROGBAR, PBM_SETPOS, (WPARAM)ProgStat, 0);\r\n\t\t}\r\n\r\n\t\telapsed = (GetTickCount() - stime) / 1000;\r\n\t\tif (elapsed > prev_elapsed) {\r\n\t\t\tif (elapsed > 2) {\r\n\t\t\t\trate = (int)(total_size / elapsed);\r\n\t\t\t\tif (rate < 1200) {\r\n\t\t\t\t\t_snprintf_s(s, sizeof(s), _TRUNCATE, \"%d:%02d (%d %s)\", elapsed / 60, elapsed % 60, rate, \"Bytes/s\");\r\n\t\t\t\t}\r\n\t\t\t\telse if (rate < 1200000) {\r\n\t\t\t\t\t_snprintf_s(s, sizeof(s), _TRUNCATE, \"%d:%02d (%d.%02d %s)\", elapsed / 60, elapsed % 60, rate / 1000, rate / 10 % 100, \"KBytes/s\");\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t_snprintf_s(s, sizeof(s), _TRUNCATE, \"%d:%02d (%d.%02d %s)\", elapsed / 60, elapsed % 60, rate / (1000 * 1000), rate / 10000 % 100, \"MBytes/s\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t_snprintf_s(s, sizeof(s), _TRUNCATE, \"%d:%02d\", elapsed / 60, elapsed % 60);\r\n\t\t\t}\r\n\t\t\tSendDlgItemMessage(hWnd, IDC_PROGTIME, WM_SETTEXT, 0, (LPARAM)s);\r\n\t\t\tprev_elapsed = elapsed;\r\n\t\t}\r\n\r\n\t} while (ret <= buflen);\r\n\r\n\t// eof\r\n\tc->scp.state = SCP_DATA;\r\n\r\n\tbuf[0] = '\\0';\r\n\tparm.buf = buf;\r\n\tparm.buflen = 1;\r\n\tparm.c = c;\r\n\tparm.pvar = pvar;\r\n\tSendMessage(hWnd, WM_SENDING_FILE, (WPARAM)&parm, 0);\r\n\r\n\tShowWindow(hWnd, SW_HIDE);\r\n\r\n\tfree(buf);\r\n\r\n\treturn 0;\r\n\r\ncancel_abort:\r\n\t// \ufffd`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\u0303N\ufffd\ufffd\ufffd[\ufffdY\ufffd\ufffd\ufffds\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffd\ufffd ssh2_channel_send_close() \ufffd\ufffd\ufffd\u0102\u044fo\ufffd\ufffd\ufffd\u0181A\r\n\t// \ufffd\ufffd\ufffdY\ufffd\u0590\ufffd\ufffd\ufffd\ufffdX\ufffd\ufffd\ufffdb\ufffdh\ufffdZ\ufffd[\ufffdt\ufffd\u0142\u0342\u0202\ufffd\ufffd\ufffd\ufffd\u07c1ASCP\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u024fI\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\ua347\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t// (2011.6.8 yutaka)\r\n\tparm.c = c;\r\n\tparm.pvar = pvar;\r\n\tSendMessage(hWnd, WM_CHANNEL_CLOSE, (WPARAM)&parm, 0);\r\n\r\nabort:\r\n\r\n\tfree(buf);\r\n\r\n\treturn 0;\r\n}\r\n\r\n\r\nstatic void SSH2_scp_toremote(PTInstVar pvar, Channel_t *c, unsigned char *data, unsigned int buflen)\r\n{\r\n\tif (c->scp.state == SCP_INIT) {\r\n\t\tchar buf[128];\r\n\r\n\t\t_snprintf_s(buf, sizeof(buf), _TRUNCATE, \"T%lu 0 %lu 0\\n\",\r\n\t\t\t(unsigned long)c->scp.filestat.st_mtime,  (unsigned long)c->scp.filestat.st_atime);\r\n\r\n\t\tc->scp.state = SCP_TIMESTAMP;\r\n\t\tSSH2_send_channel_data(pvar, c, buf, strlen(buf), 0);\r\n\r\n\t} else if (c->scp.state == SCP_TIMESTAMP) {\r\n\t\tchar buf[128];\r\n\r\n\t\t_snprintf_s(buf, sizeof(buf), _TRUNCATE, \"C0644 %lld %s\\n\",\r\n\t\t\tc->scp.filestat.st_size, c->scp.localfile);\r\n\r\n\t\tc->scp.state = SCP_FILEINFO;\r\n\t\tSSH2_send_channel_data(pvar, c, buf, strlen(buf), 0);\r\n\r\n\t} else if (c->scp.state == SCP_FILEINFO) {\r\n\t\tHWND hDlgWnd;\r\n\t\tHANDLE thread;\r\n\t\tunsigned int tid;\r\n\r\n\t\thDlgWnd = TTCreateDialog(hInst, MAKEINTRESOURCE(IDD_SSHSCP_PROGRESS),\r\n\t\t\t\t\t\t\t\t pvar->cv->HWin, ssh_scp_dlg_proc);\r\n\t\tif (hDlgWnd != NULL) {\r\n\t\t\tstatic const DlgTextInfo text_info[] = {\r\n\t\t\t\t{ 0, \"DLG_SCP_PROGRESS_TITLE_SENDFILE\" },\r\n\t\t\t\t{ IDC_SCP_PROGRESS_FILENAME_LABEL, \"DLG_SCP_PROGRESS_FILENAME_LABEL\" },\r\n\t\t\t\t{ IDC_SCP_PROGRESS_BYTE_LABEL, \"DLG_SCP_PROGRESS_BYTES_LABEL\" },\r\n\t\t\t\t{ IDC_SCP_PROGRESS_TIME_LABEL, \"DLG_SCP_PROGRESS_TIME_LABEL\" },\r\n\t\t\t};\r\n\t\t\tSetI18nDlgStrsW(hDlgWnd, \"TTSSH\", text_info, _countof(text_info), pvar->ts->UILanguageFileW);\r\n\r\n\t\t\tc->scp.progress_window = hDlgWnd;\r\n\t\t\tShowWindow(hDlgWnd, SW_SHOW);\r\n\t\t}\r\n\r\n\t\tthread = (HANDLE)_beginthreadex(NULL, 0, ssh_scp_thread, c, 0, &tid);\r\n\t\tif (thread == 0) {\r\n\t\t\t// TODO:\r\n\t\t\tthread = INVALID_HANDLE_VALUE;\r\n\t\t}\r\n\t\tc->scp.thread = thread;\r\n\r\n\r\n\t} else if (c->scp.state == SCP_DATA) {\r\n\t\t// \ufffd\ufffd\ufffdM\ufffd\ufffd\ufffd\ufffd\r\n\t\tssh2_channel_send_close(pvar, c);\r\n\t\t//ssh2_channel_delete(c);  // free channel\r\n\r\n\t\t//MessageBox(NULL, \"SCP sending done.\", \"TTSSH\", MB_OK);\r\n\t}\r\n}\r\n\r\n\r\n#define WM_RECEIVING_FILE (WM_USER + 2)\r\n\r\nstatic unsigned __stdcall ssh_scp_receive_thread(void *p)\r\n{\r\n\tChannel_t *c = (Channel_t *)p;\r\n\tPTInstVar pvar = c->scp.pvar;\r\n\tlong long total_size = 0;\r\n\tchar s[80];\r\n\tHWND hWnd = c->scp.progress_window;\r\n\tMSG msg;\r\n\tunsigned char *data;\r\n\tunsigned int buflen;\r\n\tint eof;\r\n\tint rate, ProgStat;\r\n\tDWORD stime;\r\n\tint elapsed, prev_elapsed;\r\n\tscp_dlg_parm_t parm;\r\n\r\n\tInitDlgProgress(hWnd, IDC_PROGBAR, &ProgStat);\r\n\r\n\tstime = GetTickCount();\r\n\tprev_elapsed = 0;\r\n\r\n\tfor (;;) {\r\n\t\t// Cancel\ufffd{\ufffd^\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ua0bd\ufffd\ufffdE\ufffdB\ufffd\ufffd\ufffdh\ufffdE\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\tif (is_canceled_window(hWnd))\r\n\t\t\tgoto cancel_abort;\r\n\r\n\t\tssh2_scp_get_packetlist(pvar, c, &data, &buflen);\r\n\t\tif (data && buflen) {\r\n\t\t\tmsg.message = WM_RECEIVING_FILE;\r\n\r\n\t\t\tswitch (msg.message) {\r\n\t\t\tcase WM_RECEIVING_FILE:\r\n\t\t\t\t//data = (unsigned char *)msg.wParam;\r\n\t\t\t\t//buflen = (unsigned int)msg.lParam;\r\n\t\t\t\teof = 0;\r\n\r\n\t\t\t\tif (c->scp.filercvsize >= c->scp.filetotalsize) { // EOF\r\n\t\t\t\t\tfree(data);  // free!\r\n\t\t\t\t\tgoto done;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (c->scp.filercvsize + buflen > c->scp.filetotalsize) { // overflow (include EOF)\r\n\t\t\t\t\tbuflen = (unsigned int)(c->scp.filetotalsize - c->scp.filercvsize);\r\n\t\t\t\t\teof = 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tc->scp.filercvsize += buflen;\r\n\r\n\t\t\t\tif (fwrite(data, 1, buflen, c->scp.localfp) < buflen) { // error\r\n\t\t\t\t\t// TODO:\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfree(data);  // free!\r\n\r\n\t\t\t\trate =(int)(100 * c->scp.filercvsize / c->scp.filetotalsize);\r\n\t\t\t\t_snprintf_s(s, sizeof(s), _TRUNCATE, \"%lld / %lld (%d%%)\", c->scp.filercvsize, c->scp.filetotalsize, rate);\r\n\t\t\t\tSendMessage(GetDlgItem(c->scp.progress_window, IDC_PROGRESS), WM_SETTEXT, 0, (LPARAM)s);\r\n\r\n\t\t\t\tif (ProgStat != rate) {\r\n\t\t\t\t\tProgStat = rate;\r\n\t\t\t\t\tSendDlgItemMessage(c->scp.progress_window, IDC_PROGBAR, PBM_SETPOS, (WPARAM)ProgStat, 0);\r\n\t\t\t\t}\r\n\r\n\t\t\t\telapsed = (GetTickCount() - stime) / 1000;\r\n\t\t\t\tif (elapsed > prev_elapsed) {\r\n\t\t\t\t\tif (elapsed > 2) {\r\n\t\t\t\t\t\trate = (int)(c->scp.filercvsize / elapsed);\r\n\t\t\t\t\t\tif (rate < 1200) {\r\n\t\t\t\t\t\t\t_snprintf_s(s, sizeof(s), _TRUNCATE, \"%d:%02d (%d %s)\", elapsed / 60, elapsed % 60, rate, \"Bytes/s\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (rate < 1200000) {\r\n\t\t\t\t\t\t\t_snprintf_s(s, sizeof(s), _TRUNCATE, \"%d:%02d (%d.%02d %s)\", elapsed / 60, elapsed % 60, rate / 1000, rate / 10 % 100, \"KBytes/s\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t_snprintf_s(s, sizeof(s), _TRUNCATE, \"%d:%02d (%d.%02d %s)\", elapsed / 60, elapsed % 60, rate / (1000 * 1000), rate / 10000 % 100, \"MBytes/s\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t_snprintf_s(s, sizeof(s), _TRUNCATE, \"%d:%02d\", elapsed / 60, elapsed % 60);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tSendDlgItemMessage(hWnd, IDC_PROGTIME, WM_SETTEXT, 0, (LPARAM)s);\r\n\t\t\t\t\tprev_elapsed = elapsed;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (eof)\r\n\t\t\t\t\tgoto done;\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tSleep(0);\r\n\t}\r\n\r\ndone:\r\n\tc->scp.state = SCP_CLOSING;\r\n\tShowWindow(c->scp.progress_window, SW_HIDE);\r\n\r\n\t// \ufffd`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\u0303N\ufffd\ufffd\ufffd[\ufffdY\ufffd\ufffd\ufffds\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffd\ufffd ssh2_channel_send_close() \ufffd\ufffd\ufffd\u0102\u044fo\ufffd\ufffd\ufffd\u0181A\r\n\t// \ufffd\ufffd\ufffdY\ufffd\u0590\ufffd\ufffd\ufffd\ufffdX\ufffd\ufffd\ufffdb\ufffdh\ufffdZ\ufffd[\ufffdt\ufffd\u0142\u0342\u0202\ufffd\ufffd\ufffd\ufffd\u07c1ASCP\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u024fI\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\ua347\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t// (2011.6.1 yutaka)\r\n\tparm.c = c;\r\n\tparm.pvar = pvar;\r\n\tSendMessage(hWnd, WM_CHANNEL_CLOSE, (WPARAM)&parm, 0);\r\n\treturn 0;\r\n\r\ncancel_abort:\r\n\tpvar->recv.close_request = TRUE;\r\n\treturn 0;\r\n}\r\n\r\n// do_SSH2_adjust_window_size() \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdx\ufffd\ufffd\ufffd\u0502\ufffd\ufffdo\ufffd\u07c2\ufffd\ufffd\u0102\ufffd\ufffd\ufffdR\ufffd[\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\r\n// \ufffdt\ufffd\ufffd\ufffd[\ufffd\ufffd\ufffd\ufffdA\ufffd\ufffdM\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u010aJ\r\nstatic void CALLBACK do_SSH2_adjust_window_size_timer(\r\n\tHWND hWnd, UINT uMsg, UINT_PTR nIDEvent, DWORD dwTime)\r\n{\r\n\tChannel_t *c = (Channel_t *)nIDEvent;\r\n\tPTInstVar pvar = c->scp.pvar;\r\n\r\n\t(void)hWnd;\r\n\t(void)uMsg;\r\n\t(void)dwTime;\r\n\r\n\tif (pvar->recv.data_finished) {\r\n\t\t// \ufffd\ufffd\ufffdM\ufffdI\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0243\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd\ufffd\ufffdc\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u038d\ufffd\r\n\t\treturn;\r\n\t}\r\n\tif (pvar->recv.timer_id != 0) {\r\n\t\t// SetTimer() \ufffd\u0343C\ufffd\ufffd\ufffd^\ufffd[\ufffdo\ufffd\ufffd\ufffd\u0254\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u014d\ud3dc\ufffd\ufffd\ufffd\ufffd\r\n\t\tKillTimer(pvar->cv->HWin, pvar->recv.timer_id);\r\n\t\tpvar->recv.timer_id = 0;\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_NOTICE, \"%s: SCP receive, send SSH_MSG_CHANNEL_WINDOW_ADJUST\", __FUNCTION__);\r\n\tpvar->recv.suspended = FALSE;\r\n\tdo_SSH2_adjust_window_size(pvar, c);\r\n}\r\n\r\n// SSH\ufffdT\ufffd[\ufffdo\ufffd\ufffd\ufffd\u7457\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffdt\ufffd@\ufffdC\ufffd\ufffd\ufffd\u0303f\ufffd[\ufffd^\ufffd\ufffd\ufffd\ufffd\ufffdX\ufffdg\ufffd\u0242\u0082\u0202\ufffd\ufffdB\r\n// \ufffd\ufffd\ufffdX\ufffdg\ufffd\u030e\ufffd\ufffdo\ufffd\ufffd\ufffd\ufffd ssh_scp_receive_thread \ufffdX\ufffd\ufffd\ufffdb\ufffdh\ufffd\u014ds\ufffd\ufffd\ufffdB\r\nstatic void ssh2_scp_add_packetlist(PTInstVar pvar, Channel_t *c, unsigned char *buf, unsigned int buflen)\r\n{\r\n\tPacketList_t *p, *old;\r\n\r\n\tEnterCriticalSection(&g_ssh_scp_lock);\r\n\r\n\t// allocate new buffer\r\n\tp = malloc(sizeof(PacketList_t));\r\n\tif (p == NULL)\r\n\t\tgoto error;\r\n\tp->buf = buf;\r\n\tp->buflen = buflen;\r\n\tp->next = NULL;\r\n\r\n\tif (c->scp.pktlist_head == NULL) {\r\n\t\tc->scp.pktlist_head = p;\r\n\t\tc->scp.pktlist_tail = p;\r\n\t}\r\n\telse {\r\n\t\told = c->scp.pktlist_tail;\r\n\t\told->next = p;\r\n\t\tc->scp.pktlist_tail = p;\r\n\t}\r\n\r\n\t// \ufffdL\ufffd\ufffd\ufffd[\ufffd\u024bl\ufffd\ud8cb\udf83f\ufffd[\ufffd^\ufffd\u0311\ufffd\ufffdT\ufffdC\ufffdY\ufffd\ufffd\ufffd\ufffd\ufffdZ\ufffd\ufffd\ufffd\ufffdB\r\n\tc->scp.pktlist_cursize += buflen;\r\n\r\n\t// \ufffdL\ufffd\ufffd\ufffd[\ufffd\u024bl\ufffd\ud8cb\udf83f\ufffd[\ufffd^\ufffd\u0311\ufffd\ufffdT\ufffdC\ufffdY\ufffd\ufffd\ufffd\ufffd\ufffd\u81d2l\ufffd\ud80b\udd02\ufffd\ufffd\ufffd\ufffd\ua347\ufffdA\r\n\t// SSH\ufffdT\ufffd[\ufffdo\ufffd\ufffdwindows size\ufffd\u030dX\ufffdV\ufffd\ufffd\ufffd~\ufffd\ufffd\ufffd\ufffd\r\n\t// \ufffd\ufffd\ufffd\ufffd\u0242\ufffd\u80ca\ufffdX\ufffdg\ufffdG\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffd\uf0c1\ufffd\ufffd\ufffd\ufffd\ufffd\u0314\ufffd\u527b\ufffd\ufffd\r\n\t// \ufffd\ufffd\ufffd\ufffd\u0142\ufffd\ufffd\ufffdB\r\n\tif (c->scp.pktlist_cursize >= SCPRCV_HIGH_WATER_MARK) {\r\n\t\tlogprintf(LOG_LEVEL_NOTICE,\r\n\t\t\t\"%s: enter suspend\", __FUNCTION__);\r\n\t\tpvar->recv.suspended = TRUE;\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_NOTICE,\r\n\t\t\"%s: channel=#%d SCP recv %u(bytes) and enqueued.%s\",\r\n\t\t__FUNCTION__, c->self_id, c->scp.pktlist_cursize,\r\n\t\tpvar->recv.suspended ? \"(suspended)\" : \"\"\r\n\t);\r\n\r\nerror:;\r\n\tLeaveCriticalSection(&g_ssh_scp_lock);\r\n}\r\n\r\nstatic void ssh2_scp_get_packetlist(PTInstVar pvar, Channel_t *c, unsigned char **buf, unsigned int *buflen)\r\n{\r\n\tPacketList_t *p;\r\n\r\n\tEnterCriticalSection(&g_ssh_scp_lock);\r\n\r\n\tif (c->scp.pktlist_head == NULL) {\r\n\t\t*buf = NULL;\r\n\t\t*buflen = 0;\r\n\t\tgoto end;\r\n\t}\r\n\r\n\tp = c->scp.pktlist_head;\r\n\t*buf = p->buf;\r\n\t*buflen = p->buflen;\r\n\r\n\tc->scp.pktlist_head = p->next;\r\n\r\n\tif (c->scp.pktlist_head == NULL)\r\n\t\tc->scp.pktlist_tail = NULL;\r\n\r\n\tfree(p);\r\n\r\n\t// \ufffdL\ufffd\ufffd\ufffd[\ufffd\u024bl\ufffd\ud8cb\udf83f\ufffd[\ufffd^\ufffd\u0311\ufffd\ufffdT\ufffdC\ufffdY\ufffd\ufffd\ufffd\ufffd\ufffdZ\ufffd\ufffd\ufffd\ufffdB\r\n\tc->scp.pktlist_cursize -= *buflen;\r\n\r\n\t// \ufffdL\ufffd\ufffd\ufffd[\ufffd\u024bl\ufffd\ud8cb\udf83f\ufffd[\ufffd^\ufffd\u0311\ufffd\ufffdT\ufffdC\ufffdY\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u81d2l\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ua347\ufffdA\r\n\t// SSH\ufffdT\ufffd[\ufffdo\ufffd\ufffdwindow size\ufffd\u030dX\ufffdV\ufffd\ufffd\ufffd\u010aJ\ufffd\ufffd\ufffd\ufffd\r\n\tif (c->scp.pktlist_cursize <= SCPRCV_LOW_WATER_MARK) {\r\n\t\tlogprintf(LOG_LEVEL_NOTICE, \"%s: SCP receive resumed\", __FUNCTION__);\r\n\t\t// \ufffdu\ufffd\ufffd\ufffdb\ufffdN\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ua347\r\n\t\tif (pvar->recv.suspended) {\r\n\t\t\t// SCP\ufffd\ufffdM\ufffd\u0303u\ufffd\ufffd\ufffdb\ufffdN\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\t\tpvar->recv.suspended = FALSE;\r\n\t\t\tif (c->scp.filercvsize < c->scp.filetotalsize) {\r\n\t\t\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdM\r\n\t\t\t\tpvar->recv.timer_id =\r\n\t\t\t\t\tSetTimer(pvar->cv->HWin, (UINT_PTR)c, USER_TIMER_MINIMUM, do_SSH2_adjust_window_size_timer);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_NOTICE,\r\n\t\t\"%s: channel=#%d SCP recv %u(bytes) and dequeued.%s\",\r\n\t\t__FUNCTION__, c->self_id, c->scp.pktlist_cursize,\r\n\t\tpvar->recv.suspended ? \"(suspended)\" : \"\"\r\n\t);\r\n\r\nend:;\r\n\tLeaveCriticalSection(&g_ssh_scp_lock);\r\n}\r\n\r\nstatic void ssh2_scp_alloc_packetlist(PTInstVar pvar, Channel_t *c)\r\n{\r\n\tc->scp.pktlist_head = NULL;\r\n\tc->scp.pktlist_tail = NULL;\r\n\tInitializeCriticalSection(&g_ssh_scp_lock);\r\n\tc->scp.pktlist_cursize = 0;\r\n\tpvar->recv.suspended = FALSE;\r\n\tpvar->recv.timer_id = 0;\r\n\tpvar->recv.close_request = FALSE;\r\n}\r\n\r\nstatic void ssh2_scp_free_packetlist(PTInstVar pvar, Channel_t *c)\r\n{\r\n\tPacketList_t *p, *old;\r\n\r\n\tp = c->scp.pktlist_head;\r\n\twhile (p) {\r\n\t\told = p;\r\n\t\tp = p->next;\r\n\r\n\t\tfree(old->buf);\r\n\t\tfree(old);\r\n\t}\r\n\r\n\tc->scp.pktlist_head = NULL;\r\n\tc->scp.pktlist_tail = NULL;\r\n\tDeleteCriticalSection(&g_ssh_scp_lock);\r\n}\r\n\r\nstatic BOOL SSH2_scp_fromremote(PTInstVar pvar, Channel_t *c, unsigned char *data, unsigned int buflen)\r\n{\r\n\tif (buflen == 0)\r\n\t\treturn FALSE;\r\n\r\n\tif (c->scp.state == SCP_INIT) {\r\n\t\tif (data[0] == '\\01' || data[1] == '\\02') {  // error\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\r\n\t\tif (data[0] == 'T') {  // Tmtime.sec mtime.usec atime.sec atime.usec\r\n\t\t\tDWORD mtime, atime;\r\n\r\n\t\t\tsscanf_s(data, \"T%ld 0 %ld 0\", &mtime, &atime);\r\n\r\n\t\t\t// \ufffd^\ufffdC\ufffd\ufffd\ufffdX\ufffd^\ufffd\ufffd\ufffdv\ufffd\ufffd\ufffdL\ufffd^\r\n\t\t\tc->scp.filemtime = mtime;\r\n\t\t\tc->scp.fileatime = atime;\r\n\r\n\t\t\t// \ufffd\ufffd\ufffdv\ufffd\ufffd\ufffdC\ufffd\ufffd\u0502\ufffd\r\n\t\t\tgoto reply;\r\n\r\n\t\t} else if (data[0] == 'C') {  // C0666 size file\r\n\t\t\tHWND hDlgWnd;\r\n\t\t\tHANDLE thread;\r\n\t\t\tunsigned int tid;\r\n\t\t\tint permission;\r\n\t\t\tlong long size;\r\n\t\t\tchar filename[MAX_PATH];\r\n\r\n\t\t\tsscanf_s(data, \"C%o %lld %s\", &permission, &size, filename, (unsigned int)sizeof(filename));\r\n\t\t\tlogprintf(LOG_LEVEL_NOTICE, \"%s: SCP '%s', size=%lld, perm=0x%08x\",\r\n\t\t\t\t\t  __FUNCTION__,\r\n\t\t\t\t\t  filename, size, permission);\r\n\r\n\t\t\t// Windows\ufffd\u0202\u0302\u0143p\ufffd[\ufffd~\ufffdb\ufffdV\ufffd\ufffd\ufffd\ufffd\ufffd\u0356\ufffd\ufffd\ufffd\ufffdB\ufffdT\ufffdC\ufffdY\ufffd\u0302\u074bL\ufffd^\ufffdB\r\n\t\t\tc->scp.filetotalsize = size;\r\n\t\t\tc->scp.filercvsize = 0;\r\n\t\t\tc->scp.recv.received_size = 0;\r\n\r\n\t\t\tc->scp.state = SCP_DATA;\r\n\r\n\t\t\t// \ufffdi\ufffd\ufffd\ufffdE\ufffdB\ufffd\ufffd\ufffdh\ufffdE\r\n\t\t\tc->scp.pvar = pvar;\r\n\t\t\thDlgWnd = TTCreateDialog(hInst, MAKEINTRESOURCE(IDD_SSHSCP_PROGRESS),\r\n\t\t\t\t\t\t\t\t\t pvar->cv->HWin, ssh_scp_dlg_proc);\r\n\t\t\tif (hDlgWnd != NULL) {\r\n\t\t\t\tstatic const DlgTextInfo text_info[] = {\r\n\t\t\t\t\t{ 0, \"DLG_SCP_PROGRESS_TITLE_RECEIVEFILE\" },\r\n\t\t\t\t\t{ IDC_SCP_PROGRESS_FILENAME_LABEL, \"DLG_SCP_SENDFILE_FROM\" },\r\n\t\t\t\t\t{ IDC_SCP_PROGRESS_BYTE_LABEL, \"DLG_SCP_PROGRESS_BYTES_LABEL\" },\r\n\t\t\t\t\t{ IDC_SCP_PROGRESS_TIME_LABEL, \"DLG_SCP_PROGRESS_TIME_LABEL\" },\r\n\t\t\t\t};\r\n\t\t\t\tSetI18nDlgStrsW(hDlgWnd, \"TTSSH\", text_info, _countof(text_info), pvar->ts->UILanguageFileW);\r\n\r\n\t\t\t\tc->scp.progress_window = hDlgWnd;\r\n\t\t\t\tSetDlgItemTextU8(hDlgWnd, IDC_FILENAME, c->scp.localfilefull);\r\n\t\t\t\tShowWindow(hDlgWnd, SW_SHOW);\r\n\t\t\t}\r\n\r\n\t\t\tssh2_scp_alloc_packetlist(pvar, c);\r\n\t\t\tthread = (HANDLE)_beginthreadex(NULL, 0, ssh_scp_receive_thread, c, 0, &tid);\r\n\t\t\tif (thread == 0) {\r\n\t\t\t\t// TODO:\r\n\t\t\t\tthread = INVALID_HANDLE_VALUE;\r\n\t\t\t}\r\n\t\t\tc->scp.thread = thread;\r\n\t\t\tc->scp.thread_id = tid;\r\n\r\n\t\t\tgoto reply;\r\n\r\n\t\t} else {\r\n\t\t\t// \ufffdT\ufffd[\ufffdo\ufffd\ufffd\ufffd\ufffd\u0303f\ufffd[\ufffd^\ufffd\ufffd\ufffds\ufffd\ufffd\u030f\ua347\ufffd\u0341A\ufffdG\ufffd\ufffd\ufffd[\ufffd\\\ufffd\ufffd\ufffd\ufffd\ufffds\ufffd\ufffd\ufffdB\r\n\t\t\t// (2014.7.13 yutaka)\r\n\t\t\tchar msg[256];\r\n\t\t\tint copylen;\r\n\r\n\t\t\tcopylen = min(buflen, sizeof(msg));\r\n\t\t\tmemcpy(msg, data, copylen);\r\n\t\t\tmsg[copylen - 1] = 0;\r\n\r\n\t\t\tUTIL_get_lang_msg(\"MSG_SSH_SCP_ERROR_INIT_TITLE\", pvar,\r\n\t\t\t                  \"TTSSH: SCP error (SCP_INIT)\");\r\n\t\t\tMessageBox(NULL, msg, pvar->UIMsg, MB_OK | MB_ICONEXCLAMATION);\r\n\t\t}\r\n\r\n\t} else if (c->scp.state == SCP_DATA) {  // payload\ufffd\u030e\ufffdM\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: SCP_DATA size=%u\",\r\n\t\t\t\t  __FUNCTION__,\r\n\t\t\t\t  buflen);\r\n\t\tif (pvar->recv.close_request) {\r\n\t\t\t// \ufffdL\ufffd\ufffd\ufffd\ufffd\ufffdZ\ufffd\ufffd\ufffd{\ufffd^\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ua0bd\r\n\t\t\tssh2_channel_send_close(pvar, c);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tunsigned char *newdata = malloc(buflen);\r\n\t\t\tif (newdata != NULL) {\r\n\t\t\t\tmemcpy(newdata, data, buflen);\r\n\r\n\t\t\t\t// \ufffd\ufffd\ufffd\u0312\ufffd\ufffd\ufffd suspended \ufffd\ufffd TRUE \ufffd\u0242\u0202\u90b1\ufffd\u0182\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\t\t\t\tssh2_scp_add_packetlist(pvar, c, newdata, buflen);\r\n\t\t\t}\r\n\r\n\t\t\tc->scp.recv.received_size += buflen;\r\n\r\n\t\t\tif (c->scp.recv.received_size >= c->scp.filetotalsize) {\r\n\t\t\t\t// \ufffd\ufffdM\ufffdI\ufffd\ufffd\r\n\t\t\t\tPTInstVar pvar = c->scp.pvar;\r\n\t\t\t\tpvar->recv.data_finished = TRUE;\r\n\t\t\t\tif (pvar->recv.timer_id != 0) {\r\n\t\t\t\t\tpvar->recv.timer_id = 0;\r\n\t\t\t\t\tKillTimer(pvar->cv->HWin, pvar->recv.timer_id);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (pvar->recv.suspended) {\r\n\t\t\t\t// \ufffdt\ufffd\ufffd\ufffd[\ufffd\ufffd\ufffd\u4486\r\n\t\t\t\tlogprintf(LOG_LEVEL_NOTICE, \"%s: scp receive suspended\", __FUNCTION__);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// \ufffd\ufffd\ufffd[\ufffdJ\ufffd\ufffd\ufffd\ufffdwindow size\ufffd\ufffd\ufffd`\ufffdF\ufffdb\ufffdN\r\n\t\t\t\t//\t\ufffd\ufffd\ufffd\u0702\u07c2\u0242\ufffd\u70b8\ufffd\u0241A\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdx\ufffd\u0702\u0182\u07c2\u0112\ufffd\ufffd\ufffd\ufffd\ufffd\ufffds\ufffd\ufffd\r\n\t\t\t\tif (c->local_window < c->local_window_max/2) {\r\n\t\t\t\t\t// window\ufffdT\ufffdC\ufffdY\ufffd\ud80b\udc90\ufffd\ufffd\ufffd\ufffd\ufffd\r\n#if 0\r\n\t\t\t\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd\u0252\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\t\t\t\t\t//\t\t\ufffd\ufffd\ufffd\ufffd\ufffd\u0243T\ufffd[\ufffdo\ufffd[\ufffd\ufffd\ufffd\ufffdf\ufffd[\ufffd^\ufffd\ufffd\ufffd\ufffdM\ufffd\u0142\ufffd\ufffd\ufffd\u008b\ufffd\ufffd\u030f\ua347\ufffdA\r\n\t\t\t\t\t// \t\tFD_READ\ufffd\ufffd\ufffdD\ufffd\u60b3\ufffd\ufffd\u0103\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffdL\ufffd\ufffd\ufffd[\ufffd\u0250\u03c2\u0702\ufffd\ufffd\r\n\t\t\t\t\t// \t\t\ufffd\ufffd\ufffd\ufffdwindows\ufffd\u0303\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd\ufffd\ufffd\ufffd(\ufffdL\ufffd\ufffd\ufffd\ufffd\ufffdZ\ufffd\ufffd\ufffd{\ufffd^\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd)\ufffd\ufffd\r\n\t\t\t\t\t//\t\t\ufffd\u0142\ufffd\ufffd\u0202\ufffd\ufffd\u0202\u90bd\ufffd\u07ceg\ufffdp\ufffd\ufffd\ufffd\u0202\ufffd\r\n\t\t\t\t\tdo_ssh2_adjust_window_size(pvar, c);\r\n#else\r\n\t\t\t\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0502\ufffdu\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u74b2\ufffd\ufffd\r\n\t\t\t\t\t//\t\t\ufffd^\ufffdC\ufffd}\ufffd[\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffd\ufffdGUI\ufffdX\ufffd\ufffd\ufffdb\ufffdh\ufffd\u014a\u0590\ufffd\ufffd\ufffd\ufffdR\ufffd[\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\t\t\t\t\tif (pvar->recv.timer_id == 0) {\r\n\t\t\t\t\t\tpvar->recv.timer_id =\r\n\t\t\t\t\t\t\tSetTimer(pvar->cv->HWin, (UINT_PTR)c, USER_TIMER_MINIMUM, do_SSH2_adjust_window_size_timer);\r\n\t\t\t\t\t}\r\n#endif\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t} else if (c->scp.state == SCP_CLOSING) {  // EOF\ufffd\u030e\ufffdM\r\n\t\tssh2_channel_send_close(pvar, c);\r\n\r\n\t}\r\n\r\n\treturn TRUE;\r\n\r\nreply:\r\n\t{\r\n\t\tchar ch;\r\n\t\tch = '\\0';\r\n\t\tSSH2_send_channel_data(pvar, c, &ch, 1, 0);\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\n// cf. response()#scp.c\r\nstatic void SSH2_scp_response(PTInstVar pvar, Channel_t *c, unsigned char *data, unsigned int buflen)\r\n{\r\n\tif (c->scp.dir == FROMREMOTE) {\r\n\t\tif (SSH2_scp_fromremote(pvar, c, data, buflen) == FALSE)\r\n\t\t\tgoto error;\r\n\r\n\t} else\tif (c->scp.dir == TOREMOTE) {\r\n\t\tif (buflen == 1 && data[0] == '\\0') {  // OK\r\n\t\t\tSSH2_scp_toremote(pvar, c, data, buflen);\r\n\t\t} else {\r\n\t\t\tgoto error;\r\n\t\t}\r\n\t}\r\n\treturn;\r\n\r\nerror:\r\n\t{  // error\r\n\t\tchar msg[2048];\r\n\t\tunsigned int max;\r\n\t\tint offset, resp;\r\n\r\n\t\tresp = data[0];\r\n\r\n\t\t// \ufffdG\ufffd\ufffd\ufffd[\ufffdR\ufffd[\ufffdh\ufffd\u0242\ufffd\u8576\ufffd\ufffd\ufffd\ufffd\u030ai\ufffd[\ufffd\ua3ca\ufffd\ufffd\ufffd\u12b1\ufffd\u0642\u0202\ufffdB\r\n\t\tif (resp == 1 || /* error, followed by error msg */\r\n\t\t\tresp == 2) {  /* fatal error, \"\" */\r\n\t\t\toffset = 1;\r\n\t\t} else {\r\n\t\t\toffset = 0;\r\n\t\t}\r\n\r\n\t\tif (buflen > sizeof(msg) - 1)\r\n\t\t\tmax = sizeof(msg) - 1;\r\n\t\telse\r\n\t\t\tmax = buflen - offset;\r\n\t\tmemcpy(msg, &data[offset], max);\r\n\t\tmsg[max] = '\\0';\r\n\r\n\t\t// \ufffd\u60ad\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffdG\ufffd\ufffd\ufffd[\ufffd\u030f\ua347\ufffd\u0341A\ufffd\ufffd\ufffdg\ufffd\u0143`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\ufffd\ufffdN\ufffd\ufffd\ufffd[\ufffdY\ufffd\ufffd\ufffd\ufffdB\r\n\t\t// .bashrc \ufffd\ufffd\"stty stop undef\"\ufffd\ufffd\ufffd\ufffd`\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\u0181ATTSSH\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0582\u030eb\ufffd\u83c8\ufffdu\ufffdB\r\n\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd\u9334\ufffd\ufffd\ufffd\u0355\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t\t// (2013.4.5 yutaka)\r\n\t\tif (resp == 1) {\r\n\t\t\tssh2_channel_send_close(pvar, c);\r\n\t\t} else {\r\n\t\t\t//ssh2_channel_delete(c);  // free channel\r\n\t\t\t//ssh2_channel_send_close(pvar, c);\r\n\t\t}\r\n\r\n\t\twchar_t uimsgW[MAX_UIMSG];\r\n\t\tUTIL_get_lang_msgW(\"MSG_SSH_SCP_ERROR_TITLE\", pvar,\r\n\t\t\t\t\t\t   L\"TTSSH: SCP error\", uimsgW);\r\n\t\twchar_t *msgW = ToWcharU8(msg);\r\n\t\tMessageBoxW(pvar->cv->HWin, msgW, uimsgW, MB_OK | MB_ICONEXCLAMATION);\r\n\t\tfree(msgW);\r\n\t}\r\n}\r\n\r\n\r\nstatic BOOL handle_SSH2_channel_data(PTInstVar pvar)\r\n{\r\n\tint len;\r\n\tchar *data;\r\n\tint id;\r\n\tunsigned int str_len;\r\n\tChannel_t *c;\r\n\r\n\t// 6byte\ufffdi\ufffdT\ufffdC\ufffdY\ufffd{\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd{\ufffd^\ufffdC\ufffdv\ufffdj\ufffd\ufffd\ufffd\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffd\u020d~\ufffd\u0303y\ufffdC\ufffd\ufffd\ufffd[\ufffdh\r\n\tdata = pvar->ssh_state.payload;\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY - (\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffdT\ufffdC\ufffdY+1)\ufffdG\ufffd^\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY\r\n\tlen = pvar->ssh_state.payloadlen;\r\n\r\n\t// channel number\r\n\tid = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\r\n\tc = ssh2_channel_lookup(id);\r\n\tif (c == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: channel not found. (%d)\", __FUNCTION__, id);\r\n\t\treturn FALSE;\r\n\t}\r\n\tif (c->remote_id == SSH_CHANNEL_INVALID) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: remote shell channel number is unknown.\", __FUNCTION__);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\t// string length\r\n\tstr_len = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\r\n\tif (LogLevel(pvar, LOG_LEVEL_SSHDUMP)) {\r\n\t\tlogprintf(LOG_LEVEL_SSHDUMP, \"SSH2_MSG_CHANNEL_DATA was received. local:%d remote:%d len:%d\", c->self_id, c->remote_id, str_len);\r\n\t\tinit_memdump();\r\n\t\tpush_memdump(\"SSH receiving packet\", \"PKT_recv\", (char *)data, str_len);\r\n\t}\r\n\r\n\t// \ufffdo\ufffdb\ufffdt\ufffd@\ufffdT\ufffdC\ufffdY\ufffd\u0303`\ufffdF\ufffdb\ufffdN\r\n\tif (str_len > c->local_maxpacket) {\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: Data length is larger than local_maxpacket. \"\r\n\t\t\t\"len:%d local_maxpacket:%d\", __FUNCTION__, str_len, c->local_maxpacket);\r\n\t}\r\n\tif (str_len > c->local_window) {\r\n\t\t// local window size\ufffd\ufffd\ufffd\u50ab\ufffd\u0203p\ufffdP\ufffdb\ufffdg\ufffd\u034e\u0302\u0102\ufffd\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: Data length is larger than local_window. \"\r\n\t\t\t\"len:%d local_window:%d\", __FUNCTION__, str_len, c->local_window);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\t// \ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\u0182\ufffd\ufffd\u0103N\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg(Tera Term)\ufffd\u0593n\ufffd\ufffd\r\n\tif (c->type == TYPE_SHELL || c->type == TYPE_SUBSYSTEM_GEN) {\r\n\t\tpvar->ssh_state.payload_datalen = str_len;\r\n\t\tpvar->ssh_state.payload_datastart = 8; // id + strlen\r\n\r\n\t} else if (c->type == TYPE_PORTFWD) {\r\n\t\t//debug_print(0, data, strlen);\r\n\t\tFWD_received_data(pvar, c->local_num, data, str_len);\r\n\r\n\t} else if (c->type == TYPE_SCP) {  // SCP\r\n\t\tSSH2_scp_response(pvar, c, data, str_len);\r\n\t\t// \ufffdE\ufffdB\ufffd\ufffd\ufffdh\ufffdE\ufffdT\ufffdC\ufffdY\ufffd\u0312\ufffd\ufffd\ufffd\r\n\t\tc->local_window -= str_len;\r\n\t\treturn TRUE;\r\n\r\n\t} else if (c->type == TYPE_SFTP) {  // SFTP\r\n\t\tsftp_response(pvar, c, data, str_len);\r\n\r\n\t} else if (c->type == TYPE_AGENT) {  // agent forward\r\n\t\tif (!SSH_agent_response(pvar, c, 0, data, str_len)) {\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t}\r\n\r\n\t// \ufffdE\ufffdB\ufffd\ufffd\ufffdh\ufffdE\ufffdT\ufffdC\ufffdY\ufffd\u0312\ufffd\ufffd\ufffd\r\n\tc->local_window -= str_len;\r\n\r\n\tdo_SSH2_adjust_window_size(pvar, c);\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n\r\n// Tectia Server \ufffd\ufffd Windows \ufffd\u0142\u0341ADOS\ufffdR\ufffd}\ufffd\ufffd\ufffdh\ufffd\ufffd\ufffd\ufffd\ufffds\ufffd\ufffd\ufffd\ufffd\ufffd\u0182\ufffd\ufffd\ufffdstderr\ufffd\u024fo\ufffd\u0342\ufffd\ufffd\ufffd\ufffd\r\n// \ufffdG\ufffd\ufffd\ufffd[\ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd\ufffd SSH2_MSG_CHANNEL_EXTENDED_DATA \ufffd\u0151\ufffd\ufffdM\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffdB\r\n// SSH2_MSG_CHANNEL_EXTENDED_DATA \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u60a4\ufffd\u0242\ufffd\ufffd\ufffd\ufffdB(2006.10.30 maya)\r\nstatic BOOL handle_SSH2_channel_extended_data(PTInstVar pvar)\r\n{\r\n\tint len;\r\n\tchar *data;\r\n\tint id;\r\n\tunsigned int strlen;\r\n\tChannel_t *c;\r\n\tint data_type;\r\n\r\n\tlogputs(LOG_LEVEL_SSHDUMP, \"SSH2_MSG_CHANNEL_EXTENDED_DATA was received.\");\r\n\r\n\t// 6byte\ufffdi\ufffdT\ufffdC\ufffdY\ufffd{\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd{\ufffd^\ufffdC\ufffdv\ufffdj\ufffd\ufffd\ufffd\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffd\u020d~\ufffd\u0303y\ufffdC\ufffd\ufffd\ufffd[\ufffdh\r\n\tdata = pvar->ssh_state.payload;\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY - (\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffdT\ufffdC\ufffdY+1)\ufffdG\ufffd^\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY\r\n\tlen = pvar->ssh_state.payloadlen;\r\n\r\n\t//debug_print(80, data, len);\r\n\r\n\t// channel number\r\n\tid = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\r\n\tc = ssh2_channel_lookup(id);\r\n\tif (c == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: channel not found. (%d)\", __FUNCTION__, id);\r\n\t\treturn FALSE;\r\n\t}\r\n\tif (c->remote_id == SSH_CHANNEL_INVALID) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: remote shell channel number is unknown.\", __FUNCTION__);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\t// data_type_code\r\n\tdata_type = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\r\n\t// string length\r\n\tstrlen = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\r\n\t// \ufffdo\ufffdb\ufffdt\ufffd@\ufffdT\ufffdC\ufffdY\ufffd\u0303`\ufffdF\ufffdb\ufffdN\r\n\tif (strlen > c->local_maxpacket) {\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: Data length is larger than local_maxpacket. \"\r\n\t\t\t\"len:%d local_maxpacket:%d\", __FUNCTION__, strlen, c->local_maxpacket);\r\n\t}\r\n\tif (strlen > c->local_window) {\r\n\t\t// local window size\ufffd\ufffd\ufffd\u50ab\ufffd\u0203p\ufffdP\ufffdb\ufffdg\ufffd\u034e\u0302\u0102\ufffd\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: Data length is larger than local_window. \"\r\n\t\t\t\"len:%d local_window:%d\", __FUNCTION__, strlen, c->local_window);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\t// \ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\u0182\ufffd\ufffd\u0103N\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg(Tera Term)\ufffd\u0593n\ufffd\ufffd\r\n\tif (c->type == TYPE_SHELL || c->type == TYPE_SUBSYSTEM_GEN) {\r\n\t\tpvar->ssh_state.payload_datalen = strlen;\r\n\t\tpvar->ssh_state.payload_datastart = 12; // id + data_type + strlen\r\n\r\n\t} else if (c->type == TYPE_PORTFWD) {\r\n\t\t//debug_print(0, data, strlen);\r\n\t\tFWD_received_data(pvar, c->local_num, data, strlen);\r\n\r\n\t} else if (c->type == TYPE_SCP) {  // SCP\r\n\t\tchar *msg = (char *)malloc(strlen+1);\r\n\t\twchar_t *msgW;\r\n\t\tmemcpy(msg, data, strlen);\r\n\t\tmsg[strlen] = '\\0';\r\n\t\tmsgW = ToWcharU8(msg);\r\n\t\tif (msgW) {\r\n\t\t\tNotifySetIconID(pvar->cv, hInst, pvar->settings.IconID);\r\n\t\t\tNotifyWarnMessageW(pvar->cv, msgW, L\"SSH_MSG_CHANNEL_EXTENDED_DATA\");\r\n\t\t\tNotifySetIconID(pvar->cv, NULL, 0);\r\n\t\t\tfree(msgW);\r\n\t\t}\r\n\t\tfree(msg);\r\n\r\n\t} else if (c->type == TYPE_SFTP) {  // SFTP\r\n\r\n\t} else if (c->type == TYPE_AGENT) {  // agent forward\r\n\t\tif (!SSH_agent_response(pvar, c, 0, data, strlen)) {\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t}\r\n\r\n\t//debug_print(200, data, strlen);\r\n\r\n\t// \ufffdE\ufffdB\ufffd\ufffd\ufffdh\ufffdE\ufffdT\ufffdC\ufffdY\ufffd\u0312\ufffd\ufffd\ufffd\r\n\tc->local_window -= strlen;\r\n\r\n\tif (c->type == TYPE_SCP && pvar->recv.suspended) {\r\n\t\tlogprintf(LOG_LEVEL_NOTICE, \"%s: SCP suspended\", __FUNCTION__);\r\n\t}\r\n\telse {\r\n\t\tdo_SSH2_adjust_window_size(pvar, c);\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n\r\nstatic BOOL handle_SSH2_channel_eof(PTInstVar pvar)\r\n{\r\n\tint len;\r\n\tchar *data;\r\n\tint id;\r\n\tChannel_t *c;\r\n\r\n\t// \ufffd\u0612f\ufffd\ufffd\ufffd\u0243T\ufffd[\ufffdo\ufffd\ufffd SSH2_MSG_CHANNEL_EOF \ufffd\ud805\uddc2\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\u0302\u0141A\ufffd`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB(2005.6.19 yutaka)\r\n\r\n\t// 6byte\ufffdi\ufffdT\ufffdC\ufffdY\ufffd{\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd{\ufffd^\ufffdC\ufffdv\ufffdj\ufffd\ufffd\ufffd\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffd\u020d~\ufffd\u0303y\ufffdC\ufffd\ufffd\ufffd[\ufffdh\r\n\tdata = pvar->ssh_state.payload;\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY - (\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffdT\ufffdC\ufffdY+1)\ufffdG\ufffd^\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY\r\n\tlen = pvar->ssh_state.payloadlen;\r\n\r\n\t// channel number\r\n\tid = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\r\n\tc = ssh2_channel_lookup(id);\r\n\tif (c == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: channel not found. (%d)\", __FUNCTION__, id);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"SSH2_MSG_CHANNEL_EOF was received. local:%d remote:%d\", c->self_id, c->remote_id);\r\n\r\n\tif (c->type == TYPE_PORTFWD) {\r\n\t\tFWD_channel_input_eof(pvar, c->local_num);\r\n\t}\r\n\telse if (c->type == TYPE_AGENT) {\r\n\t\tssh2_channel_send_close(pvar, c);\r\n\t}\r\n\telse {\r\n\t\t// \ufffd\u01c2\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdH\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_SSH2_channel_open(PTInstVar pvar)\r\n{\r\n\tint len;\r\n\tchar *data;\r\n\tChannel_t *c = NULL;\r\n\tint buflen;\r\n\tchar *ctype;\r\n\tint remote_id;\r\n\tint remote_window;\r\n\tint remote_maxpacket;\r\n\tint chan_num = -1;\r\n\tbuffer_t *msg;\r\n\tunsigned char *outmsg;\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: SSH2_MSG_CHANNEL_OPEN was received.\", __FUNCTION__);\r\n\r\n\t// 6byte\ufffdi\ufffdT\ufffdC\ufffdY\ufffd{\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd{\ufffd^\ufffdC\ufffdv\ufffdj\ufffd\ufffd\ufffd\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffd\u020d~\ufffd\u0303y\ufffdC\ufffd\ufffd\ufffd[\ufffdh\r\n\tdata = pvar->ssh_state.payload;\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY - (\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffdT\ufffdC\ufffdY+1)\ufffdG\ufffd^\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY\r\n\tlen = pvar->ssh_state.payloadlen;\r\n\r\n\t// get string\r\n\tctype = buffer_get_string(&data, &buflen);\r\n\r\n\t// get value\r\n\tremote_id = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\tremote_window = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\tremote_maxpacket = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE,\r\n\t\t\"%s: type=%s, channel=%d, init_winsize=%d, max_packetsize:%d\", __FUNCTION__,\r\n\t\tNonNull(ctype), remote_id, remote_window, remote_maxpacket);\r\n\r\n\t// check Channel Type(string)\r\n\tif (ctype == NULL) {\r\n\t\t// ctype \ufffd\ufffd NULL \ufffd\u0156\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0315\u06cf\u0602\u0308\u05c1A\ufffd\ufffd\u0243`\ufffdF\ufffdb\ufffdN\ufffd\ufffd\ufffd\ufffd\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_get_string returns NULL. (ctype)\", __FUNCTION__);\r\n\t}\r\n\telse if (strcmp(ctype, \"forwarded-tcpip\") == 0) { // port-forwarding(remote to local)\r\n\t\tchar *listen_addr, *orig_addr;\r\n\t\tint listen_port, orig_port;\r\n\r\n\t\tlisten_addr = buffer_get_string(&data, &buflen);  // 0.0.0.0\r\n\t\tlisten_port = get_uint32_MSBfirst(data); // 5000\r\n\t\tdata += 4;\r\n\r\n\t\torig_addr = buffer_get_string(&data, &buflen);  // 127.0.0.1\r\n\t\torig_port = get_uint32_MSBfirst(data);  // 32776\r\n\t\tdata += 4;\r\n\r\n\t\tif (listen_addr && orig_addr) {\r\n\t\t\tlogprintf(LOG_LEVEL_VERBOSE,\r\n\t\t\t\t\"%s: %s: listen_addr=%s, listen_port=%d, orig_addr=%s, orig_port=%d\", __FUNCTION__,\r\n\t\t\t\tctype, listen_addr, listen_port, orig_addr, orig_port);\r\n\t\t\t// searching request entry by listen_port & create_local_channel\r\n\t\t\tFWD_open(pvar, remote_id, listen_addr, listen_port, orig_addr, orig_port, &chan_num);\r\n\r\n\t\t\t// channel\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffdP\ufffd[\ufffdg\ufffd\ufffd\ufffdA\ufffdK\ufffdv\ufffd\u020f\ufffd\ufffdiremote window size\ufffdj\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u014e\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffdB\r\n\t\t\t// changed window size from 128KB to 32KB. (2006.3.6 yutaka)\r\n\t\t\t// changed window size from 32KB to 128KB. (2007.10.29 maya)\r\n\t\t\tc = ssh2_channel_new(CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, TYPE_PORTFWD, chan_num);\r\n\t\t\tif (c == NULL) {\r\n\t\t\t\t// \ufffd]\ufffd\ufffd\ufffd`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\ufffd\\\ufffdP\ufffdb\ufffdg\ufffd\u0309\ufffd\ufffd\ufffdR\ufffd\ufffd\ufffd\ufffdC\ufffd\ufffd (2007.7.26 maya)\r\n\t\t\t\tFWD_free_channel(pvar, chan_num);\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_NO_FREE_CHANNEL\", pvar,\r\n\t\t\t\t                  \"Could not open new channel. TTSSH is already opening too many channels.\");\r\n\t\t\t\tnotify_nonfatal_error(pvar, pvar->UIMsg);\r\n\t\t\t\treturn FALSE;\r\n\t\t\t}\r\n\t\t\tc->remote_id = remote_id;\r\n\t\t\tc->remote_window = remote_window;\r\n\t\t\tc->remote_maxpacket = remote_maxpacket;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: %s: buffer_get_string returns NULL. \"\r\n\t\t\t\t\"linsten_addr=%s, orig_addr=%s\", __FUNCTION__,\r\n\t\t\t\tctype, NonNull(listen_addr), NonNull(orig_addr));\r\n\t\t}\r\n\t\tfree(listen_addr);\r\n\t\tfree(orig_addr);\r\n\r\n\t} else if (strcmp(ctype, \"x11\") == 0) { // port-forwarding(X11)\r\n\t\t// X application\ufffd\ufffd\ufffd^\ufffd[\ufffd~\ufffdi\ufffd\ufffd\ufffd\ufffd\u014e\ufffd\ufffds\ufffd\ufffd\ufffd\ufffd\u0181ASSH2_MSG_CHANNEL_OPEN \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffdB\r\n\t\tchar *orig_str;\r\n\t\tint orig_port;\r\n\r\n\t\torig_str = buffer_get_string(&data, NULL);  // \"127.0.0.1\"\r\n\t\torig_port = get_uint32_MSBfirst(data);\r\n\t\tdata += 4;\r\n\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: %s: orig_addr=%s, orig_port=%d\", __FUNCTION__,\r\n\t\t\tctype, orig_str, orig_port);\r\n\r\n\t\tfree(orig_str);\r\n\r\n\t\t// X server \ufffd\u0590\u0691\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\tFWD_X11_open(pvar, remote_id, NULL, 0, &chan_num);\r\n\r\n\t\t// channel\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffdP\ufffd[\ufffdg\ufffd\ufffd\ufffdA\ufffdK\ufffdv\ufffd\u020f\ufffd\ufffdiremote window size\ufffdj\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u014e\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffdB\r\n\t\t// changed window size from 128KB to 32KB. (2006.3.6 yutaka)\r\n\t\t// changed window size from 32KB to 128KB. (2007.10.29 maya)\r\n\t\tc = ssh2_channel_new(CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, TYPE_PORTFWD, chan_num);\r\n\t\tif (c == NULL) {\r\n\t\t\t// \ufffd]\ufffd\ufffd\ufffd`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\ufffd\\\ufffdP\ufffdb\ufffdg\ufffd\u0309\ufffd\ufffd\ufffdR\ufffd\ufffd\ufffd\ufffdC\ufffd\ufffd (2007.7.26 maya)\r\n\t\t\tFWD_free_channel(pvar, chan_num);\r\n\t\t\tUTIL_get_lang_msg(\"MSG_SSH_NO_FREE_CHANNEL\", pvar,\r\n\t\t\t                  \"Could not open new channel. TTSSH is already opening too many channels.\");\r\n\t\t\tnotify_nonfatal_error(pvar, pvar->UIMsg);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\tc->remote_id = remote_id;\r\n\t\tc->remote_window = remote_window;\r\n\t\tc->remote_maxpacket = remote_maxpacket;\r\n\r\n\t} else if (strcmp(ctype, \"auth-agent@openssh.com\") == 0) { // agent forwarding\r\n\t\tif (pvar->agentfwd_enable && FWD_agent_forward_confirm(pvar)) {\r\n\t\t\tc = ssh2_channel_new(CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, TYPE_AGENT, -1);\r\n\t\t\tif (c == NULL) {\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_NO_FREE_CHANNEL\", pvar,\r\n\t\t\t\t                  \"Could not open new channel. TTSSH is already opening too many channels.\");\r\n\t\t\t\tnotify_nonfatal_error(pvar, pvar->UIMsg);\r\n\t\t\t\treturn FALSE;\r\n\t\t\t}\r\n\t\t\tc->remote_id = remote_id;\r\n\t\t\tc->remote_window = remote_window;\r\n\t\t\tc->remote_maxpacket = remote_maxpacket;\r\n\r\n\t\t\tSSH2_confirm_channel_open(pvar, c);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tmsg = buffer_init();\r\n\t\t\tif (msg == NULL) {\r\n\t\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\t\treturn FALSE;\r\n\t\t\t}\r\n\t\t\tbuffer_put_int(msg, remote_id);\r\n\t\t\tbuffer_put_int(msg, SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED);\r\n\t\t\tbuffer_put_string(msg, \"\", 0); // description\r\n\t\t\tbuffer_put_string(msg, \"\", 0); // language tag\r\n\r\n\t\t\tlen = buffer_len(msg);\r\n\t\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_OPEN_FAILURE, len);\r\n\t\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\t\tfinish_send_packet(pvar);\r\n\t\t\tbuffer_free(msg);\r\n\r\n\t\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: SSH2_MSG_CHANNEL_OPEN_FAILURE was sent.\", __FUNCTION__ );\r\n\t\t}\r\n\r\n\t} else {\r\n\t\t// unknown type(unsupported)\r\n\t}\r\n\r\n\tfree(ctype);\r\n\r\n\treturn(TRUE);\r\n}\r\n\r\n\r\nstatic BOOL handle_SSH2_channel_close(PTInstVar pvar)\r\n{\r\n\tint len;\r\n\tchar *data;\r\n\tint id;\r\n\tChannel_t *c;\r\n\r\n\t// \ufffdR\ufffdl\ufffdN\ufffdV\ufffd\ufffd\ufffd\ufffd\ufffd\u0612f\ufffd\ufffd\ufffd\u0241A\ufffdp\ufffdP\ufffdb\ufffdg\ufffd_\ufffd\ufffd\ufffdv\ufffd\ufffd\ufffdt\ufffd@\ufffdC\ufffd\ufffd\ufffd\u0591|\ufffd\ufffd\ufffdo\ufffd\ufffd\ufffdB\r\n\tif (LOG_LEVEL_SSHDUMP <= pvar->session_settings.LogLevel) {\r\n\t\tsave_memdump(LOG_PACKET_DUMP);\r\n\t\tfinish_memdump();\r\n\t}\r\n\r\n\t// 6byte\ufffdi\ufffdT\ufffdC\ufffdY\ufffd{\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd{\ufffd^\ufffdC\ufffdv\ufffdj\ufffd\ufffd\ufffd\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffd\u020d~\ufffd\u0303y\ufffdC\ufffd\ufffd\ufffd[\ufffdh\r\n\tdata = pvar->ssh_state.payload;\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY - (\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffdT\ufffdC\ufffdY+1)\ufffdG\ufffd^\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY\r\n\tlen = pvar->ssh_state.payloadlen;\r\n\r\n\tid = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\tc = ssh2_channel_lookup(id);\r\n\tif (c == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: channel not found. (%d)\", __FUNCTION__, id);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"SSH2_MSG_CHANNEL_CLOSE was received. local:%d remote:%d\", c->self_id, c->remote_id);\r\n\r\n\tif (c->type == TYPE_SHELL || c->type == TYPE_SUBSYSTEM_GEN) {\r\n\t\tssh2_channel_send_close(pvar, c);\r\n\r\n\t\t// TCP connection closed\r\n\t\tnotify_closed_connection(pvar, \"disconnected by server request\");\r\n\r\n\t} else if (c->type == TYPE_PORTFWD) {\r\n\t\t// CHANNEL_CLOSE \ufffd\ud805\uddc2\ufffd\u0502\ufffd\ufffd\u0202\ufffd\ufffd\u0183\ufffd\ufffd\ufffd\ufffd[\ufffdg\ufffd\ufffdchannel\ufffd\ufffd\ufffdJ\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\r\n\t\t// c.f. RFC 4254 5.3. Closing a Channel\r\n\t\tssh2_channel_send_close(pvar, c);\r\n\r\n\t\t// \ufffd]\ufffd\ufffd\ufffd`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\ufffd\\\ufffdP\ufffdb\ufffdg\ufffd\u0309\ufffd\ufffd\ufffdR\ufffd\ufffd\ufffd\ufffdC\ufffd\ufffd (2007.7.26 maya)\r\n\t\tFWD_free_channel(pvar, c->local_num);\r\n\r\n\t\t// \ufffd`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\u0309\ufffd\ufffd\ufffdR\ufffd\ufffd\ufffd\ufffdC\ufffd\ufffd (2007.4.26 yutaka)\r\n\t\tssh2_channel_delete(c);\r\n\r\n\t} else if (c->type == TYPE_SCP) {\r\n\t\t// \ufffd\ufffdM\ufffdI\ufffd\ufffd\r\n\t\tPTInstVar pvar = c->scp.pvar;\r\n\t\tpvar->recv.data_finished = TRUE;\r\n\r\n\t\tssh2_channel_delete(c);\r\n\r\n\t} else if (c->type == TYPE_AGENT) {\r\n\t\tssh2_channel_delete(c);\r\n\r\n\t} else {\r\n\t\tssh2_channel_delete(c);\r\n\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_SSH2_channel_request(PTInstVar pvar)\r\n{\r\n\tint len;\r\n\tchar *data;\r\n\tint id;\r\n\tchar *request;\r\n\tint want_reply;\r\n\tint success = 0;\r\n\tChannel_t *c;\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_CHANNEL_REQUEST was received.\");\r\n\r\n\t// 6byte\ufffdi\ufffdT\ufffdC\ufffdY\ufffd{\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd{\ufffd^\ufffdC\ufffdv\ufffdj\ufffd\ufffd\ufffd\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffd\u020d~\ufffd\u0303y\ufffdC\ufffd\ufffd\ufffd[\ufffdh\r\n\tdata = pvar->ssh_state.payload;\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY - (\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffdT\ufffdC\ufffdY+1)\ufffdG\ufffd^\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY\r\n\tlen = pvar->ssh_state.payloadlen;\r\n\r\n\t// ID(4) + string(any) + want_reply(1) + exit status(4)\r\n\tid = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\tc = ssh2_channel_lookup(id);\r\n\tif (c == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: channel not found. (%d)\", __FUNCTION__, id);\r\n\t\treturn FALSE;\r\n\t}\r\n\tif (c->remote_id == SSH_CHANNEL_INVALID) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: remote shell channel number is unknown.\", __FUNCTION__);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\trequest = buffer_get_string(&data, NULL);\r\n\r\n\twant_reply = data[0];\r\n\tdata += 1;\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE,\r\n\t\t\"%s: local=%d, remote=%d, request=%s, want_reply=%d\",  __FUNCTION__,\r\n\t\tc->self_id, c->remote_id, NonNull(request), want_reply);\r\n\r\n\tif (request == NULL) {\r\n\t\t// request \ufffd\ufffd NULL \ufffd\u0156\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0315\u06cf\ufffd\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_get_string returns NULL. (request)\", __FUNCTION__);\r\n\t}\r\n\telse if (strcmp(request, \"exit-status\") == 0) {\r\n\t\t// \ufffdI\ufffd\ufffd\ufffdR\ufffd[\ufffdh\ufffd\ufffd\ufffd\u0702\u0702\ufffd\u0102\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\r\n\t\tint estat = get_uint32_MSBfirst(data);\r\n\t\tsuccess = 1;\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: exit-status=%d\", __FUNCTION__, estat);\r\n\t}\r\n\telse if (strcmp(request, \"keepalive@openssh.com\") == 0) {\r\n\t\t// \ufffd\u00c2\ufffd OpenSSH \ufffd\u0142\ufffd SUCCESS \ufffd\ufffd\u0502\ufffd\ufffd\u0102\ufffd keepalive \ufffd\ufffd\r\n\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u018a\u0158\udbcb\udcc2\ufffd\u0202\ufffd\ufffd\u0302\ufffd FAILURE \ufffd\ufffd\u0502\ufffd\ufffdB[teraterm:1278]\r\n\t\tsuccess = 0;\r\n\t}\r\n\r\n\tfree(request);\r\n\r\n\tif (want_reply) {\r\n\t\tbuffer_t *msg;\r\n\t\tunsigned char *outmsg;\r\n\t\tint len;\r\n\t\tint type;\r\n\r\n\t\tif (success) {\r\n\t\t\ttype = SSH2_MSG_CHANNEL_SUCCESS;\r\n\t\t} else {\r\n\t\t\ttype = SSH2_MSG_CHANNEL_FAILURE;\r\n\t\t}\r\n\r\n\t\tmsg = buffer_init();\r\n\t\tif (msg == NULL) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\tbuffer_put_int(msg, c->remote_id);\r\n\r\n\t\tlen = buffer_len(msg);\r\n\t\toutmsg = begin_send_packet(pvar, type, len);\r\n\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\tfinish_send_packet(pvar);\r\n\t\tbuffer_free(msg);\r\n\r\n\t\tif (success) {\r\n\t\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: SSH2_MSG_CHANNEL_SUCCESS was sent.\", __FUNCTION__);\r\n\t\t} else {\r\n\t\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: SSH2_MSG_CHANNEL_FAILURE was sent.\", __FUNCTION__);\r\n\t\t}\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n\r\nstatic BOOL handle_SSH2_window_adjust(PTInstVar pvar)\r\n{\r\n\tint len;\r\n\tchar *data;\r\n\tint id;\r\n\tunsigned int adjust;\r\n\tChannel_t *c;\r\n\r\n\tlogputs(LOG_LEVEL_SSHDUMP, \"SSH2_MSG_CHANNEL_WINDOW_ADJUST was received.\");\r\n\r\n\t// 6byte\ufffdi\ufffdT\ufffdC\ufffdY\ufffd{\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd{\ufffd^\ufffdC\ufffdv\ufffdj\ufffd\ufffd\ufffd\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffd\u020d~\ufffd\u0303y\ufffdC\ufffd\ufffd\ufffd[\ufffdh\r\n\tdata = pvar->ssh_state.payload;\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY - (\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffdT\ufffdC\ufffdY+1)\ufffdG\ufffd^\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY\r\n\tlen = pvar->ssh_state.payloadlen;\r\n\r\n\t//debug_print(80, data, len);\r\n\r\n\t// channel number\r\n\tid = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\r\n\tc = ssh2_channel_lookup(id);\r\n\tif (c == NULL) {\r\n\t\t// channel close\ufffd\ufffd\ufffdadjust message\ufffd\ufffd\ufffdx\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffdP\ufffd[\ufffdX\ufffd\ufffd\ufffd\ufffd\ufffd\u90bd\ufffd\u07c1A\r\n\t\t// FALSE\ufffd\u0142\u0355\u0502\ufffd\ufffd\u0202\ufffd\ufffd\u60a4\ufffd\u0242\ufffd\ufffd\ufffdB(2007.12.26 yutaka)\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: channel not found. (%d)\", __FUNCTION__, id);\r\n\t\treturn TRUE;\r\n\t}\r\n\tif (c->remote_id == SSH_CHANNEL_INVALID) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: remote shell channel number is unknown.\", __FUNCTION__);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tadjust = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\r\n\t// window size\ufffd\u0312\ufffd\ufffd\ufffd\r\n\tc->remote_window += adjust;\r\n\r\n\t// \ufffd\ufffd\ufffd\u70b8\ufffdo\ufffdb\ufffdt\ufffd@\ufffd\u0255\u06d1\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdf\ufffd[\ufffd^\ufffd\ud805\uddc2\ufffd\r\n\tssh2_channel_retry_send_bufchain(pvar, c);\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n// Channel_t ........... SSH2\ufffd\u0303`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\\\ufffd\ufffd\ufffd\ufffd\r\n// local_channel_num ... SSH1\ufffd\u0303\ufffd\ufffd[\ufffdJ\ufffd\ufffd\ufffd`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\u050d\ufffd\r\nstatic BOOL SSH_agent_response(PTInstVar pvar, Channel_t *c, int local_channel_num,\r\n                               unsigned char *data, unsigned int buflen)\r\n{\r\n\tunsigned int req_len;\r\n\tFWDChannel *fc;\r\n\tbuffer_t *agent_msg;\r\n\tunsigned int *agent_request_len;\r\n\tunsigned char *response = NULL;\r\n\tunsigned int resplen = 0;\r\n\r\n\r\n\t// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ua0bd CHANNEL_DATA \ufffd\u030e\ufffdM\ufffd\u0251\u0389\ufffd (2008.11.30 maya)\r\n\tif (SSHv2(pvar)) {\r\n\t\tagent_msg = c->agent_msg;\r\n\t\tagent_request_len = &c->agent_request_len;\r\n\t}\r\n\telse {\r\n\t\tfc = pvar->fwd_state.channels + local_channel_num;\r\n\t\tagent_msg = fc->agent_msg;\r\n\t\tagent_request_len = &fc->agent_request_len;\r\n\t}\r\n\r\n\tif (agent_msg->len == 0) {\r\n\t\treq_len = get_uint32_MSBfirst(data);\r\n\t\tif (req_len > AGENT_MAX_MSGLEN - 4) {\r\n\t\t\tlogprintf(LOG_LEVEL_NOTICE,\r\n\t\t\t\t\"%s: Agent Forwarding Error: server request is too large. size=%u, allowd max=%u.\",\r\n\t\t\t\t__FUNCTION__ , req_len, AGENT_MAX_MSGLEN-4);\r\n\t\t\tif (pvar->session_settings.ForwardAgentNotify) {\r\n\t\t\t\tchar title[MAX_UIMSG];\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_AGENTERROR_TITLE\", pvar, \"Bad agent request\");\r\n\t\t\t\tstrncpy_s(title, sizeof(title), pvar->UIMsg, _TRUNCATE);\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_AGENTERROR_TOOLARGE\", pvar,\r\n\t\t\t\t\t\"Agent request size is too large, ignore it.\");\r\n\r\n\t\t\t\tNotifySetIconID(pvar->cv, hInst, pvar->settings.IconID);\r\n\t\t\t\tNotifyInfoMessage(pvar->cv, pvar->UIMsg, title);\r\n\t\t\t\tNotifySetIconID(pvar->cv, NULL, 0);\r\n\t\t\t}\r\n\r\n\t\t\tgoto error;\r\n\t\t}\r\n\r\n\t\t*agent_request_len = req_len + 4;\r\n\r\n\t\tif (*agent_request_len > buflen) {\r\n\t\t\tbuffer_put_raw(agent_msg, data, buflen);\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\tbuffer_put_raw(agent_msg, data, buflen);\r\n\t\tif (*agent_request_len > agent_msg->len) {\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t\tdata = agent_msg->buf;\r\n\t}\r\n\r\n\tputty_agent_query_synchronous(data, *agent_request_len, &response, &resplen);\r\n\tif (response == NULL || resplen < 5) {\r\n\t\tlogprintf(LOG_LEVEL_NOTICE, \"%s Agent Forwarding Error: putty_agent_query_synchronous is failed.\", __FUNCTION__);\r\n\t\tgoto error;\r\n\t}\r\n\r\n\tif (SSHv2(pvar)) {\r\n\t\tSSH2_send_channel_data(pvar, c, response, resplen, 0);\r\n\t}\r\n\telse {\r\n\t\tSSH_channel_send(pvar, local_channel_num, fc->remote_num,\r\n\t\t                 response, resplen, 0);\r\n\t}\r\n\tsafefree(response);\r\n\r\n\t// \ufffdg\ufffd\ufffd\ufffdI\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdo\ufffdb\ufffdt\ufffd@\ufffd\ufffd\ufffdN\ufffd\ufffd\ufffdA\r\n\tbuffer_clear(agent_msg);\r\n\treturn TRUE;\r\n\r\nerror:\r\n\t// \ufffdG\ufffd\ufffd\ufffd[\ufffd\ufffd\ufffd\ufffd SSH_AGENT_FAILURE \ufffd\ufffd\u0502\ufffd\r\n\tif (SSHv2(pvar)) {\r\n\t\tSSH2_send_channel_data(pvar, c, SSH_AGENT_FAILURE_MSG, sizeof(SSH_AGENT_FAILURE_MSG), 0);\r\n\t}\r\n\telse {\r\n\t\tSSH_channel_send(pvar, local_channel_num, fc->remote_num,\r\n\t\t                 SSH_AGENT_FAILURE_MSG, sizeof(SSH_AGENT_FAILURE_MSG), 0);\r\n\t}\r\n\tif (response) {\r\n\t\tsafefree(response);\r\n\t}\r\n\r\n\t// \ufffdg\ufffd\ufffd\ufffdI\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdo\ufffdb\ufffdt\ufffd@\ufffd\ufffd\ufffdN\ufffd\ufffd\ufffdA\r\n\tbuffer_clear(agent_msg);\r\n\treturn TRUE;\r\n}\r\n", "/*\r\n * Copyright (c) 1998-2001, Robert O'Callahan\r\n * (C) 2004- TeraTerm Project\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions\r\n * are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright\r\n *    notice, this list of conditions and the following disclaimer.\r\n * 2. Redistributions in binary form must reproduce the above copyright\r\n *    notice, this list of conditions and the following disclaimer in the\r\n *    documentation and/or other materials provided with the distribution.\r\n * 3. The name of the author may not be used to endorse or promote products\r\n *    derived from this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\r\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,\r\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\r\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n/*\r\nThis code is copyright (C) 1998-1999 Robert O'Callahan.\r\nSee LICENSE.TXT for the license.\r\n*/\r\n\r\n#ifndef __TTXSSH_H\r\n#define __TTXSSH_H\r\n\r\n#pragma warning(3 : 4035)\r\n\r\n/* VS2015(VC14.0)\ufffd\ufffd\ufffd\u0181AWSASocketA(), inet_ntoa() \ufffd\u0202\u01c2\ufffdAPI\ufffd\ufffddeprecated\ufffd\u0142\ufffd\ufffd\ufffd\ufffd\r\n* \ufffdx\ufffd\ufffd\ufffd\ufffd\ufffd\u90bd\ufffd\u07c2\u0241A\ufffdx\ufffd\ufffd\ufffd\ufffd}\ufffd~\ufffd\ufffd\ufffd\ufffdB\ufffd\ufffd\u058a\u0590\ufffd\ufffd\u0252u\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0181AVS2005(VC8.0)\ufffd\u0143r\ufffd\ufffd\ufffdh\r\n* \ufffd\u0142\ufffd\ufffd\u0202\ufffd\ufffd\u0202\u90bd\ufffd\u07c1A\ufffdx\ufffd\ufffd\ufffd\ufffd}\ufffd~\ufffd\ufffd\ufffd\u90be\ufffd\ufffd\ufffd\u0182\ufffd\ufffd\ufffdB\r\n*/\r\n#if _MSC_VER >= 1800  // VSC2013(VC12.0) or later\r\n\t#ifndef _WINSOCK_DEPRECATED_NO_WARNINGS\r\n\t\t#define _WINSOCK_DEPRECATED_NO_WARNINGS\r\n\t#endif\r\n#endif\r\n\r\n#include <winsock2.h>\r\n#include <ws2tcpip.h>\r\n#include <wspiapi.h>\r\n/* actual body of in6addr_any and in6addr_loopback is disappeared?? */\r\n#undef IN6_IS_ADDR_LOOPBACK\r\n#define IN6_IS_ADDR_LOOPBACK(a)         \\\r\n        ((*(unsigned int *)(&(a)->s6_addr[0]) == 0) &&     \\\r\n         (*(unsigned int *)(&(a)->s6_addr[4]) == 0) &&     \\\r\n         (*(unsigned int *)(&(a)->s6_addr[8]) == 0) &&     \\\r\n         (*(unsigned int *)(&(a)->s6_addr[12]) == ntohl(1)))\r\n/* work around for MS Platform SDK Oct 2000 */\r\n#include <malloc.h> /* prevent of conflict stdlib.h */\r\n#include <stdlib.h>\r\n#include <stdarg.h>\r\n#include <crtdbg.h>\r\n\r\n#include \"i18n.h\"\r\n#include \"ttlib.h\"\r\n\r\ntypedef struct _TInstVar *PTInstVar;\r\n\r\n#include \"util.h\"\r\n#include \"pkt.h\"\r\n#include \"ssh.h\"\r\n#include \"auth.h\"\r\n#include \"crypt.h\"\r\n#include \"cipher.h\"\r\n#include \"comp.h\"\r\n#include \"kex.h\"\r\n#include \"hostkey.h\"\r\n#include \"key.h\"\r\n#include \"hosts.h\"\r\n#include \"fwd.h\"\r\n\r\n#include <openssl/dh.h>\r\n#include <openssl/ec.h>\r\n#include <openssl/evp.h>\r\n#include \"buffer.h\"\r\n\r\n/* tttypes.h \ufffd\u0152\ufffd`\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd EM \ufffd}\ufffdN\ufffd\ufffd\ufffd\ufffd openssl/rsa.h (OpenSSL 0.9.8)\ufffd\u030a\u0590\ufffd\ufffdv\ufffd\ufffd\ufffdg\ufffd^\ufffdC\ufffdv\ufffd\u933e\ufffd\ufffd\r\n * \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u018fd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0702\ufffd\ufffd\u0302\u0141A\ufffdr\ufffd\ufffd\ufffdh\ufffdG\ufffd\ufffd\ufffd[\ufffd\u0182\u0202\ufffdB\ufffd\ufffd\ufffdL3\ufffdw\ufffdb\ufffd_\ufffd\ufffdinclude\ufffd\u0292u\ufffd\ufffd\ufffd\ufffd\ufffdL\ufffd\u0248\u0693\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n * (2005.7.9 yutaka)\r\n */\r\n#include \"teraterm.h\"\r\n#include \"tttypes.h\"\r\n#include \"ttplugin.h\"\r\n\r\n#if defined(_MSC_VER) && !defined(_Printf_format_string_)\r\n// \ufffd\ufffd`\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0202\ufffd\ufffd\u0182\ufffd\ufffd\u0349\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\u60a4\ufffd\u0252\ufffd`\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\r\n#define _Printf_format_string_\r\n#endif\r\n\r\nextern HANDLE hInst; /* Instance handle of TTXSSH.DLL */\r\n\r\n#define ID_SSHSCPMENU       52110\r\n#define ID_SSHSETUPMENU     52310\r\n#define ID_SSHAUTHSETUPMENU 52320\r\n#define ID_SSHFWDSETUPMENU  52330\r\n#define ID_SSHKEYGENMENU    52340\r\n#define ID_ABOUTMENU        52910\r\n\r\n#define ID_SSHAUTH            62501\r\n#define ID_SSHUNKNOWNHOST     62502\r\n#define ID_SSHDIFFERENTKEY    62503\r\n#define ID_SSHASYNCMESSAGEBOX 62504\r\n#define ID_SSHDIFFERENT_TYPE_KEY 62505\r\n\r\n#define OPTION_NONE     0\r\n#define OPTION_CLEAR    1\r\n#define OPTION_REPLACE  2\r\n\r\n/*\r\n * DisablePopupMessage \ufffdp\ufffd\u0303r\ufffdb\ufffdg\ufffd\ufffd`\r\n */\r\n#define POPUP_MSG_default\t\t\t0\r\n#define POPUP_MSG_FWD_received_data\t(1 << 0)\r\n#define POPUP_MSG_FWD_channel_open\t(1 << 1)\r\n\r\n\r\n/*\r\n * Host key rotation\r\n */\r\n#define SSH_UPDATE_HOSTKEYS_NO\t0\r\n#define SSH_UPDATE_HOSTKEYS_YES\t1\r\n#define SSH_UPDATE_HOSTKEYS_ASK\t2\r\n#define SSH_UPDATE_HOSTKEYS_MAX\t3\r\n\r\n/*\r\n * Server compatibility flag\r\n */\r\n#define SSH_BUG_DHGEX_LARGE 0x00000001\r\n\r\n\r\n/*\r\nThese are the fields that WOULD go in Tera Term's 'ts' structure, if\r\nwe could put them there.\r\n*/\r\ntypedef struct _TS_SSH {\r\n\tBOOL Enabled;\r\n\tint CompressionLevel; /* 0 = NONE, else 1-9 */\r\n\r\n\tint DefaultUserType;\t/* 0/1/2 = no input/DefaultUserName/Windows logon user */\r\n\tchar DefaultUserName[256];\r\n\r\n\t/* this next option is a string of digits. Each digit represents a\r\n\t   cipher. The first digit is the most preferred cipher, and so on.\r\n\t   The digit SSH_CIPHER_NONE signifies that any ciphers after it are\r\n\t   disabled. */\r\n\tchar CipherOrder[SSH_CIPHER_MAX+2];\r\n\r\n\tchar KnownHostsFiles[2048];\r\n\tint DefaultAuthMethod;\r\n\tchar DefaultRhostsLocalUserName[256];\r\n\tchar DefaultRhostsHostPrivateKeyFile[1024];\r\n\tchar DefaultRSAPrivateKeyFile[1024];\r\n\r\n\tchar DefaultForwarding[4096];\r\n\tBOOL TryDefaultAuth;\r\n\r\n\tint LogLevel;      /* 0 = NONE, 100 = Verbose */\r\n\tint WriteBufferSize;\r\n\r\n\tint ssh_protocol_version; // SSH version (2004.10.11 yutaka)\r\n\tint ssh_heartbeat_overtime; // SSH heartbeat(keepalive) (2004.12.11 yutaka)\r\n\t// whether password will permanently store on heap memory (2006.8.5 yutaka)\r\n\tint remember_password;\r\n\r\n\t// try auth with \"none\" method for disable unsupported on dialog (2007.9.24 maya)\r\n\tBOOL CheckAuthListFirst;\r\n\r\n\t// Enable connection to the server that has RSA key length less than 768 bit (2008.9.11 maya)\r\n\tBOOL EnableRsaShortKeyServer;\r\n\r\n\t// Enable Agent forwarding\r\n\tBOOL ForwardAgent;\r\n\r\n\t// Confirm Agent forwarding\r\n\tBOOL ForwardAgentConfirm;\r\n\r\n\t// Confirm Agent forwarding\r\n\tBOOL ForwardAgentNotify;\r\n\r\n\t// KEX order(derived from teraterm.ini)\r\n\tchar KexOrder[KEX_DH_MAX+1];\r\n\tchar HostKeyOrder[KEY_ALGO_MAX+1];\r\n\tchar MacOrder[HMAC_MAX+1];\r\n\tchar CompOrder[COMP_MAX+1];\r\n\r\n\tBOOL VerifyHostKeyDNS;\r\n\r\n\tint IconID;\r\n\r\n\tint DisablePopupMessage;\r\n\r\n\tchar X11Display[128];\r\n\r\n\tint UpdateHostkeys;\r\n\r\n\tint GexMinimalGroupSize;\r\n\r\n\tint AuthBanner;\r\n\r\n\tBOOL KexKeyLogging;\r\n\twchar_t KexKeyLogFile[1024];\r\n\r\n\t// Sign algorithm order\r\n\t//   for publickey authentication (not for server hostkey)\r\n\t//   for RSA key only\r\n\tchar RSAPubkeySignAlgorithmOrder[RSA_PUBKEY_SIGN_ALGO_MAX+1];\r\n} TS_SSH;\r\n\r\ntypedef struct _TInstVar {\r\n\tPTTSet ts;\r\n\tPComVar cv;\r\n\r\n\t/* shared memory for settings across instances. Basically it's\r\n\t   a cache for the INI file.*/\r\n\tTS_SSH *ts_SSH;\r\n\r\n\tint fatal_error;\r\n\tint showing_err;\r\n\tchar *err_msg;\r\n\r\n\tTconnect Pconnect;\r\n\tTrecv Precv;\r\n\tTsend Psend;\r\n\tTWSAAsyncSelect PWSAAsyncSelect;\r\n\tTWSAGetLastError PWSAGetLastError;\r\n\r\n\tPReadIniFile ReadIniFile;\r\n\tPWriteIniFile WriteIniFile;\r\n\tPParseParam ParseParam;\r\n\r\n\tHMENU FileMenu;\r\n\r\n\tSOCKET socket;\r\n\tHWND NotificationWindow;\r\n\tunsigned int notification_msg;\r\n\tlong notification_events;\r\n\tHICON OldSmallIcon; // \ufffdg\ufffdp\ufffd\ufffd\ufffd\u0202\ufffd\r\n\tHICON OldLargeIcon; // \ufffdg\ufffdp\ufffd\ufffd\ufffd\u0202\ufffd\r\n\r\n\tBOOL hostdlg_activated;\r\n\tBOOL hostdlg_Enabled;\r\n\r\n\tint protocol_major;\r\n\tint protocol_minor;\r\n\r\n\tPKTState pkt_state;\r\n\tSSHState ssh_state;\r\n\tAUTHState auth_state;\r\n\tCRYPTState crypt_state;\r\n\tHOSTSState hosts_state;\r\n\tFWDState fwd_state;\r\n\r\n/* The settings applied to the current session. The user may change\r\n   the settings but usually we don't want that to affect the session\r\n   in progress (race conditions). So user setup changes usually\r\n   modify the 'settings' field below. */\r\n\tTS_SSH session_settings;\r\n\r\n/* our copy of the global settings. This is synced up with the shared\r\n   memory only when we do a ReadIniFile or WriteIniFile\r\n   (i.e. the user loads or saves setup) */\r\n\tTS_SSH settings;\r\n\r\n\t// SSH2\r\n\tDH *kexdh;\r\n\tchar server_version_string[128];\r\n\tchar client_version_string[128];\r\n\tbuffer_t *my_kex;\r\n\tbuffer_t *peer_kex;\r\n\tkex_algorithm kex_type; // KEX algorithm\r\n\tssh_keyalgo hostkey_type;\r\n\tconst struct ssh2cipher *ciphers[MODE_MAX];\r\n\tconst struct SSH2Mac *macs[MODE_MAX];\r\n\tcompression_type ctos_compression;\r\n\tcompression_type stoc_compression;\r\n\tint we_need;\r\n\tint kex_status;\r\n\tchar *session_id;\r\n\tint session_id_len;\r\n\tSSHKeys ssh2_keys[MODE_MAX];\r\n\tstruct sshcipher_ctx *cc[MODE_MAX];\r\n\tint userauth_success;\r\n\tint shell_id;\r\n\tint session_nego_status;\r\n\t/*\r\n\tunsigned int local_window;\r\n\tunsigned int local_window_max;\r\n\tunsigned int local_consumed;\r\n\tunsigned int local_maxpacket;\r\n\tunsigned int remote_window;\r\n\tunsigned int remote_maxpacket;\r\n\t*/\r\n\tint client_key_bits;\r\n\tint server_key_bits;\r\n\tint kexgex_min;\r\n\tint kexgex_bits;\r\n\tint kexgex_max;\r\n\tint ssh2_autologin;\r\n\tint ask4passwd;\r\n\tSSHAuthMethod ssh2_authmethod;\r\n\tchar ssh2_username[MAX_PATH];\r\n\tchar ssh2_password[MAX_PATH];\r\n\tchar ssh2_keyfile[MAX_PATH];\r\n\ttime_t ssh_heartbeat_tick;\r\n\tHANDLE ssh_heartbeat_thread;\r\n\tint keyboard_interactive_password_input;\r\n\tint userauth_retry_count;\r\n\tbuffer_t *decomp_buffer;\r\n\tbuffer_t *authbanner_buffer;\r\n\tchar *ssh2_authlist;\r\n\tBOOL tryed_ssh2_authlist;\r\n\tHWND ssh_hearbeat_dialog;\r\n\r\n\t/* Pageant \ufffd\u0182\u0312\u0290M\ufffdp */\r\n\tunsigned char *pageant_key;\r\n\tunsigned char *pageant_curkey;\r\n\tint pageant_keylistlen;\r\n\tint pageant_keycount;\r\n\tint pageant_keycurrent;\r\n\tBOOL pageant_keyfinal;// SSH2 PK_OK \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0182\ufffd\ufffd\ufffd TRUE \ufffd\u0242\ufffd\ufffd\ufffd\r\n\r\n\t// agent forward\r\n\tBOOL agentfwd_enable;\r\n\r\n\tBOOL origDisableTCPEchoCR;\r\n\r\n\tBOOL nocheck_known_hosts;\r\n\r\n\tEC_KEY *ecdh_client_key;\r\n\r\n\tint dns_key_check;\r\n\r\n\tunsigned int server_compat_flag;\r\n\r\n\tvoid *hostkey_ctx;\r\n\r\n\tBOOL use_subsystem;\r\n\tchar subsystem_name[256];\r\n\r\n\tBOOL nosession;\r\n\r\n\t// dialog resource\r\n\tHFONT hFontFixed;\t\t// hosts.c\ufffd\ufffd\ufffd\u0303_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffdp\r\n\r\n\tstruct {\r\n\t\tBOOL suspended;  // SCP\ufffd\ufffdM\ufffd\u0303t\ufffd\ufffd\ufffd[\ufffd\ufffd\ufffd\ufffdp,TRUE\ufffd\u0302\u0182\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0502\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffd\r\n\t\t//BOOL timer_triggerd;\r\n\t\tUINT_PTR timer_id;\r\n\t\tBOOL data_finished;\t// TRUE\ufffd\u0302\u0182\ufffd,\ufffdf\ufffd[\ufffd^\ufffd\u030e\ufffdM\ufffd\u034a\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\t\tBOOL close_request;\r\n\t} recv;\r\n\r\n\tchar *server_sig_algs;\r\n\r\n\tchar UIMsg[MAX_UIMSG];\r\n} TInstVar;\r\n\r\n// \ufffdo\ufffd[\ufffdW\ufffd\ufffd\ufffd\ufffd\ufffd\u024d\ufffd\ufffd\ud0b9\ufffd\u010e\ufffd\ufffd\ufffd\ufffd\u03cdX\ufffd\ufffd\ufffd\ufffd\ufffdB \ufffd\ufffd: TTSSH_2-81_TS_data\r\n#define TTSSH_FILEMAPNAME \"TTSSH_\" TTSSH_VERSION_STR(\"-\") \"_TS_data\"\r\n\r\n#define LOG_LEVEL_FATAL      5\r\n#define LOG_LEVEL_ERROR      10\r\n#define LOG_LEVEL_WARNING    30\r\n#define LOG_LEVEL_NOTICE     50\r\n#define LOG_LEVEL_INFO       80\r\n#define LOG_LEVEL_VERBOSE    100\r\n#define LOG_LEVEL_SSHDUMP    200\r\n\r\n#define SSHv1(pvar) ((pvar)->protocol_major == 1)\r\n#define SSHv2(pvar) ((pvar)->protocol_major == 2)\r\n\r\n#define LogLevel(pvar, level) ((pvar)->settings.LogLevel >= (level))\r\n\r\nvoid notify_established_secure_connection(PTInstVar pvar);\r\nvoid notify_closed_connection(PTInstVar pvar, char *send_msg);\r\nvoid notify_nonfatal_error(PTInstVar pvar, char *msg);\r\nvoid notify_fatal_error(PTInstVar pvar, char *msg, BOOL send_disconnect);\r\nvoid logputs(int level, char *msg);\r\n#if defined(_MSC_VER)\r\nvoid logprintf(int level, _Printf_format_string_ const char *fmt, ...);\r\nvoid logprintf_hexdump(int level, const char *data, int len, _Printf_format_string_ const char *fmt, ...);\r\n#elif defined(__GNUC__)\r\nvoid logprintf(int level, const char *fmt, ...) __attribute__ ((format (printf, 2, 3)));\r\nvoid logprintf_hexdump(int level, const char *data, int len, const char *fmt, ...) __attribute__ ((format (printf, 4, 5)));\r\n#else\r\nvoid logprintf(int level, const char *fmt, ...);\r\nvoid logprintf_hexdump(int level, const char *data, int len, const char *fmt, ...);\r\n#endif\r\n\r\nvoid get_teraterm_dir_relative_name(char *buf, int bufsize, char *basename);\r\nwchar_t *get_teraterm_dir_relative_nameW(const wchar_t *basename);\r\nint copy_teraterm_dir_relative_path(char *dest, int destsize, char *basename);\r\nwchar_t *get_home_dir_relative_nameW(const wchar_t *basename);\r\nwchar_t *get_log_dir_relative_nameW(const wchar_t *basename);\r\nint uuencode(unsigned char *src, int srclen, unsigned char *target, int targsize);\r\n\r\n#endif\r\n"], "fixing_code": ["/*\r\n * (C) 2011- TeraTerm Project\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions\r\n * are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright\r\n *    notice, this list of conditions and the following disclaimer.\r\n * 2. Redistributions in binary form must reproduce the above copyright\r\n *    notice, this list of conditions and the following disclaimer in the\r\n *    documentation and/or other materials provided with the distribution.\r\n * 3. The name of the author may not be used to endorse or promote products\r\n *    derived from this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\r\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,\r\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\r\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n#include \"ttxssh.h\"\r\n#include \"kex.h\"\r\n\r\n\r\nchar *myproposal[PROPOSAL_MAX] = {\r\n\tKEX_DEFAULT_KEX,\r\n\tKEX_DEFAULT_PK_ALG,\r\n\tKEX_DEFAULT_ENCRYPT,\r\n\tKEX_DEFAULT_ENCRYPT,\r\n\tKEX_DEFAULT_MAC,\r\n\tKEX_DEFAULT_MAC,\r\n\tKEX_DEFAULT_COMP,\r\n\tKEX_DEFAULT_COMP,\r\n\tKEX_DEFAULT_LANG,\r\n\tKEX_DEFAULT_LANG,\r\n};\r\n\r\nstruct ssh2_kex_algorithm_t {\r\n\tkex_algorithm kextype;\r\n\tchar *name;\r\n\tconst EVP_MD *(*evp_md)(void);\r\n};\r\n\r\nstatic const struct ssh2_kex_algorithm_t ssh2_kex_algorithms[] = {\r\n\t{KEX_DH_GRP1_SHA1,  \"diffie-hellman-group1-sha1\",           EVP_sha1},   // RFC4253\r\n\t{KEX_DH_GRP14_SHA1, \"diffie-hellman-group14-sha1\",          EVP_sha1},   // RFC4253\r\n\t{KEX_DH_GEX_SHA1,   \"diffie-hellman-group-exchange-sha1\",   EVP_sha1},   // RFC4419\r\n\t{KEX_DH_GEX_SHA256, \"diffie-hellman-group-exchange-sha256\", EVP_sha256}, // RFC4419\r\n\t{KEX_ECDH_SHA2_256, \"ecdh-sha2-nistp256\",                   EVP_sha256}, // RFC5656\r\n\t{KEX_ECDH_SHA2_384, \"ecdh-sha2-nistp384\",                   EVP_sha384}, // RFC5656\r\n\t{KEX_ECDH_SHA2_521, \"ecdh-sha2-nistp521\",                   EVP_sha512}, // RFC5656\r\n\t{KEX_DH_GRP14_SHA256, \"diffie-hellman-group14-sha256\",      EVP_sha256}, // RFC8268\r\n\t{KEX_DH_GRP16_SHA512, \"diffie-hellman-group16-sha512\",      EVP_sha512}, // RFC8268\r\n\t{KEX_DH_GRP18_SHA512, \"diffie-hellman-group18-sha512\",      EVP_sha512}, // RFC8268\r\n\t{KEX_DH_NONE      , NULL,                                   NULL},\r\n};\r\n\r\n\r\nchar* get_kex_algorithm_name(kex_algorithm kextype)\r\n{\r\n\tconst struct ssh2_kex_algorithm_t *ptr = ssh2_kex_algorithms;\r\n\r\n\twhile (ptr->name != NULL) {\r\n\t\tif (kextype == ptr->kextype) {\r\n\t\t\treturn ptr->name;\r\n\t\t}\r\n\t\tptr++;\r\n\t}\r\n\r\n\t// not found.\r\n\treturn \"unknown\";\r\n}\r\n\r\nconst EVP_MD* get_kex_algorithm_EVP_MD(kex_algorithm kextype)\r\n{\r\n\tconst struct ssh2_kex_algorithm_t *ptr = ssh2_kex_algorithms;\r\n\r\n\twhile (ptr->name != NULL) {\r\n\t\tif (kextype == ptr->kextype) {\r\n\t\t\treturn ptr->evp_md();\r\n\t\t}\r\n\t\tptr++;\r\n\t}\r\n\r\n\t// not found.\r\n\treturn EVP_md_null();\r\n}\r\n\r\nvoid normalize_kex_order(char *buf)\r\n{\r\n\tstatic char default_strings[] = {\r\n\t\tKEX_ECDH_SHA2_256,\r\n\t\tKEX_ECDH_SHA2_384,\r\n\t\tKEX_ECDH_SHA2_521,\r\n\t\tKEX_DH_GRP18_SHA512,\r\n\t\tKEX_DH_GRP16_SHA512,\r\n\t\tKEX_DH_GRP14_SHA256,\r\n\t\tKEX_DH_GEX_SHA256,\r\n\t\tKEX_DH_GRP14_SHA1,\r\n\t\tKEX_DH_NONE,\r\n\t\tKEX_DH_GEX_SHA1,\r\n\t\tKEX_DH_GRP1_SHA1,\r\n\t};\r\n\r\n\tnormalize_generic_order(buf, default_strings, NUM_ELEM(default_strings));\r\n}\r\n\r\nkex_algorithm choose_SSH2_kex_algorithm(char *server_proposal, char *my_proposal)\r\n{\r\n\tkex_algorithm type = KEX_DH_UNKNOWN;\r\n\tchar str_kextype[40];\r\n\tconst struct ssh2_kex_algorithm_t *ptr = ssh2_kex_algorithms;\r\n\r\n\tchoose_SSH2_proposal(server_proposal, my_proposal, str_kextype, sizeof(str_kextype));\r\n\r\n\twhile (ptr->name != NULL) {\r\n\t\tif (strcmp(ptr->name, str_kextype) == 0) {\r\n\t\t\ttype = ptr->kextype;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tptr++;\r\n\t}\r\n\r\n\treturn (type);\r\n}\r\n\r\n// KEX\ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd\ufffdD\ufffd\u63c7\ufffd\u0282\u0249\ufffd\ufffd\ufffd\ufffd\u0101Amyproposal[]\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n// (2011.2.28 yutaka)\r\nvoid SSH2_update_kex_myproposal(PTInstVar pvar)\r\n{\r\n\tstatic char buf[512]; // TODO: malloc()\ufffd\u0242\ufffd\ufffd\u05c2\ufffd\r\n\tint index;\r\n\tint i;\r\n\r\n\t// \ufffd\u0290M\ufffd\ufffd\ufffd\u024c\u0102\u0382\ufffd\ufffd\u0182\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0182\u0343L\ufffd[\ufffd\u010d\uc42c\r\n\tif (pvar->socket != INVALID_SOCKET) {\r\n\t\tif (pvar->kex_status & KEX_FLAG_REKEYING) {\r\n\t\t\t// \ufffdL\ufffd[\ufffd\u010d\uc42c\ufffd\u030f\ua347\ufffd\u0242\u0341A\ufffd\u0691\ufffd\ufffd\ufffd\ufffd\ufffd pvar->settings \ufffd\ufffd\ufffd\ufffdg\ufffd\u0757\ufffd\ufffd\u0102\ufffd\ua0bd myproposal \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\t\t//   pvar->settings \ufffd\ufffd \ufffd\u0691\ufffd\ufffd\ufffd\ufffd\ufffd myproposal \ufffd\ufffd\ufffd\uc42c\ufffd\ufffd\ufffd\ufffd\ufffd\u0182\ufffd\ufffd\u0312l\ufffd\ufffd\ufffd\ufffd\u03c2\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0202\ufffd\ufffd\u06cf\u0602\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t\t\t//   \ufffd\u0113x\ufffdg\ufffd\u0757\ufffd\ufffd\u0102\ufffd\u0302\u0142\u0342\u0202\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd myproposal \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u90b1\ufffd\u0182\u0242\ufffd\ufffd\ufffd\ufffdB\r\n\t\t\tint pos = strlen(myproposal[PROPOSAL_KEX_ALGS]) - strlen(\",ext-info-c,kex-strict-c-v00@openssh.com\");\r\n\t\t\tif (strcmp(myproposal[PROPOSAL_KEX_ALGS] + pos, \",ext-info-c,kex-strict-c-v00@openssh.com\") == 0) {\r\n\t\t\t\tmyproposal[PROPOSAL_KEX_ALGS][pos] = '\\0';\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\r\n\tbuf[0] = '\\0';\r\n\tfor (i = 0 ; pvar->settings.KexOrder[i] != 0 ; i++) {\r\n\t\tindex = pvar->settings.KexOrder[i] - '0';\r\n\t\tif (index == KEX_DH_NONE) // disabled line\r\n\t\t\tbreak;\r\n\t\tstrncat_s(buf, sizeof(buf), get_kex_algorithm_name(index), _TRUNCATE);\r\n\t\tstrncat_s(buf, sizeof(buf), \",\", _TRUNCATE);\r\n\t}\r\n\r\n\t// Enables RFC 8308 Extension Negotiation & Strict KEX mode (for CVE-2023-48795)\r\n\tstrncat_s(buf, sizeof(buf), \"ext-info-c,kex-strict-c-v00@openssh.com\", _TRUNCATE);\r\n\r\n\tmyproposal[PROPOSAL_KEX_ALGS] = buf; \r\n}\r\n\r\n\r\nstatic DH *dh_new_group_asc(const char *gen, const char *modulus)\r\n{\r\n\tDH *dh = NULL;\r\n\tBIGNUM *p = NULL, *g = NULL;\r\n\r\n\tif ((dh = DH_new()) == NULL) {\r\n\t\tprintf(\"dh_new_group_asc: DH_new\");\r\n\t\tgoto error;\r\n\t}\r\n\r\n\t// P\ufffd\ufffdG\ufffd\u034c\ufffd\ufffdJ\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u60a2\ufffdf\ufffd\ufffd\ufffd\u0311g\ufffd\u074d\ufffd\ufffd\ud0b9\r\n\tif (BN_hex2bn(&p, modulus) == 0) {\r\n\t\tprintf(\"BN_hex2bn p\");\r\n\t\tgoto error;\r\n\t}\r\n\r\n\tif (BN_hex2bn(&g, gen) == 0) {\r\n\t\tprintf(\"BN_hex2bn g\");\r\n\t\tgoto error;\r\n\t}\r\n\r\n\t// BN_hex2bn()\ufffd\u0155\u03ca\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd|\ufffdC\ufffd\ufffd\ufffd^\ufffd\ufffdDH\ufffd\\\ufffd\ufffd\ufffd\u0302\u0243Z\ufffdb\ufffdg\ufffd\ufffd\ufffd\ufffdB\r\n\tDH_set0_pqg(dh, p, NULL, g);\r\n\r\n\treturn (dh);\r\n\r\nerror:\r\n    BN_free(g);\r\n    BN_free(p);\r\n\tDH_free(dh);\r\n\treturn (NULL);\r\n}\r\n\r\n\r\nDH *dh_new_group1(void)\r\n{\r\n\tstatic char *gen = \"2\", *group1 =\r\n\t    \"FFFFFFFF\" \"FFFFFFFF\" \"C90FDAA2\" \"2168C234\" \"C4C6628B\" \"80DC1CD1\"\r\n\t    \"29024E08\" \"8A67CC74\" \"020BBEA6\" \"3B139B22\" \"514A0879\" \"8E3404DD\"\r\n\t    \"EF9519B3\" \"CD3A431B\" \"302B0A6D\" \"F25F1437\" \"4FE1356D\" \"6D51C245\"\r\n\t    \"E485B576\" \"625E7EC6\" \"F44C42E9\" \"A637ED6B\" \"0BFF5CB6\" \"F406B7ED\"\r\n\t    \"EE386BFB\" \"5A899FA5\" \"AE9F2411\" \"7C4B1FE6\" \"49286651\" \"ECE65381\"\r\n\t    \"FFFFFFFF\" \"FFFFFFFF\";\r\n\r\n\treturn (dh_new_group_asc(gen, group1));\r\n}\r\n\r\n\r\nDH *dh_new_group14(void)\r\n{\r\n    static char *gen = \"2\", *group14 =\r\n        \"FFFFFFFF\" \"FFFFFFFF\" \"C90FDAA2\" \"2168C234\" \"C4C6628B\" \"80DC1CD1\"\r\n        \"29024E08\" \"8A67CC74\" \"020BBEA6\" \"3B139B22\" \"514A0879\" \"8E3404DD\"\r\n        \"EF9519B3\" \"CD3A431B\" \"302B0A6D\" \"F25F1437\" \"4FE1356D\" \"6D51C245\"\r\n        \"E485B576\" \"625E7EC6\" \"F44C42E9\" \"A637ED6B\" \"0BFF5CB6\" \"F406B7ED\"\r\n        \"EE386BFB\" \"5A899FA5\" \"AE9F2411\" \"7C4B1FE6\" \"49286651\" \"ECE45B3D\"\r\n        \"C2007CB8\" \"A163BF05\" \"98DA4836\" \"1C55D39A\" \"69163FA8\" \"FD24CF5F\"\r\n        \"83655D23\" \"DCA3AD96\" \"1C62F356\" \"208552BB\" \"9ED52907\" \"7096966D\"\r\n        \"670C354E\" \"4ABC9804\" \"F1746C08\" \"CA18217C\" \"32905E46\" \"2E36CE3B\"\r\n        \"E39E772C\" \"180E8603\" \"9B2783A2\" \"EC07A28F\" \"B5C55DF0\" \"6F4C52C9\"\r\n        \"DE2BCBF6\" \"95581718\" \"3995497C\" \"EA956AE5\" \"15D22618\" \"98FA0510\"\r\n        \"15728E5A\" \"8AACAA68\" \"FFFFFFFF\" \"FFFFFFFF\";\r\n\r\n\treturn (dh_new_group_asc(gen, group14));\r\n}\r\n\r\n// \ufffd\ufffd\ufffdg\ufffdp\r\nDH *dh_new_group15(void)\r\n{\r\n    static char *gen = \"2\", *group15 =\r\n\t\"FFFFFFFF\" \"FFFFFFFF\" \"C90FDAA2\" \"2168C234\" \"C4C6628B\" \"80DC1CD1\"\r\n\t\"29024E08\" \"8A67CC74\" \"020BBEA6\" \"3B139B22\" \"514A0879\" \"8E3404DD\"\r\n\t\"EF9519B3\" \"CD3A431B\" \"302B0A6D\" \"F25F1437\" \"4FE1356D\" \"6D51C245\"\r\n\t\"E485B576\" \"625E7EC6\" \"F44C42E9\" \"A637ED6B\" \"0BFF5CB6\" \"F406B7ED\"\r\n\t\"EE386BFB\" \"5A899FA5\" \"AE9F2411\" \"7C4B1FE6\" \"49286651\" \"ECE45B3D\"\r\n\t\"C2007CB8\" \"A163BF05\" \"98DA4836\" \"1C55D39A\" \"69163FA8\" \"FD24CF5F\"\r\n\t\"83655D23\" \"DCA3AD96\" \"1C62F356\" \"208552BB\" \"9ED52907\" \"7096966D\"\r\n\t\"670C354E\" \"4ABC9804\" \"F1746C08\" \"CA18217C\" \"32905E46\" \"2E36CE3B\"\r\n\t\"E39E772C\" \"180E8603\" \"9B2783A2\" \"EC07A28F\" \"B5C55DF0\" \"6F4C52C9\"\r\n\t\"DE2BCBF6\" \"95581718\" \"3995497C\" \"EA956AE5\" \"15D22618\" \"98FA0510\"\r\n\t\"15728E5A\" \"8AAAC42D\" \"AD33170D\" \"04507A33\" \"A85521AB\" \"DF1CBA64\"\r\n\t\"ECFB8504\" \"58DBEF0A\" \"8AEA7157\" \"5D060C7D\" \"B3970F85\" \"A6E1E4C7\"\r\n\t\"ABF5AE8C\" \"DB0933D7\" \"1E8C94E0\" \"4A25619D\" \"CEE3D226\" \"1AD2EE6B\"\r\n\t\"F12FFA06\" \"D98A0864\" \"D8760273\" \"3EC86A64\" \"521F2B18\" \"177B200C\"\r\n\t\"BBE11757\" \"7A615D6C\" \"770988C0\" \"BAD946E2\" \"08E24FA0\" \"74E5AB31\"\r\n\t\"43DB5BFC\" \"E0FD108E\" \"4B82D120\" \"A93AD2CA\" \"FFFFFFFF\" \"FFFFFFFF\";\r\n\treturn (dh_new_group_asc(gen, group15));\r\n}\r\n\r\nDH *dh_new_group16(void)\r\n{\r\n    static char *gen = \"2\", *group16 =\r\n\t\"FFFFFFFF\" \"FFFFFFFF\" \"C90FDAA2\" \"2168C234\" \"C4C6628B\" \"80DC1CD1\"\r\n\t\"29024E08\" \"8A67CC74\" \"020BBEA6\" \"3B139B22\" \"514A0879\" \"8E3404DD\"\r\n\t\"EF9519B3\" \"CD3A431B\" \"302B0A6D\" \"F25F1437\" \"4FE1356D\" \"6D51C245\"\r\n\t\"E485B576\" \"625E7EC6\" \"F44C42E9\" \"A637ED6B\" \"0BFF5CB6\" \"F406B7ED\"\r\n\t\"EE386BFB\" \"5A899FA5\" \"AE9F2411\" \"7C4B1FE6\" \"49286651\" \"ECE45B3D\"\r\n\t\"C2007CB8\" \"A163BF05\" \"98DA4836\" \"1C55D39A\" \"69163FA8\" \"FD24CF5F\"\r\n\t\"83655D23\" \"DCA3AD96\" \"1C62F356\" \"208552BB\" \"9ED52907\" \"7096966D\"\r\n\t\"670C354E\" \"4ABC9804\" \"F1746C08\" \"CA18217C\" \"32905E46\" \"2E36CE3B\"\r\n\t\"E39E772C\" \"180E8603\" \"9B2783A2\" \"EC07A28F\" \"B5C55DF0\" \"6F4C52C9\"\r\n\t\"DE2BCBF6\" \"95581718\" \"3995497C\" \"EA956AE5\" \"15D22618\" \"98FA0510\"\r\n\t\"15728E5A\" \"8AAAC42D\" \"AD33170D\" \"04507A33\" \"A85521AB\" \"DF1CBA64\"\r\n\t\"ECFB8504\" \"58DBEF0A\" \"8AEA7157\" \"5D060C7D\" \"B3970F85\" \"A6E1E4C7\"\r\n\t\"ABF5AE8C\" \"DB0933D7\" \"1E8C94E0\" \"4A25619D\" \"CEE3D226\" \"1AD2EE6B\"\r\n\t\"F12FFA06\" \"D98A0864\" \"D8760273\" \"3EC86A64\" \"521F2B18\" \"177B200C\"\r\n\t\"BBE11757\" \"7A615D6C\" \"770988C0\" \"BAD946E2\" \"08E24FA0\" \"74E5AB31\"\r\n\t\"43DB5BFC\" \"E0FD108E\" \"4B82D120\" \"A9210801\" \"1A723C12\" \"A787E6D7\"\r\n\t\"88719A10\" \"BDBA5B26\" \"99C32718\" \"6AF4E23C\" \"1A946834\" \"B6150BDA\"\r\n\t\"2583E9CA\" \"2AD44CE8\" \"DBBBC2DB\" \"04DE8EF9\" \"2E8EFC14\" \"1FBECAA6\"\r\n\t\"287C5947\" \"4E6BC05D\" \"99B2964F\" \"A090C3A2\" \"233BA186\" \"515BE7ED\"\r\n\t\"1F612970\" \"CEE2D7AF\" \"B81BDD76\" \"2170481C\" \"D0069127\" \"D5B05AA9\"\r\n\t\"93B4EA98\" \"8D8FDDC1\" \"86FFB7DC\" \"90A6C08F\" \"4DF435C9\" \"34063199\"\r\n\t\"FFFFFFFF\" \"FFFFFFFF\";\r\n\treturn (dh_new_group_asc(gen, group16));\r\n}\r\n\r\n// \ufffd\ufffd\ufffdg\ufffdp\r\nDH *dh_new_group17(void)\r\n{\r\n    static char *gen = \"2\", *group17 =\r\n\t\"FFFFFFFF\" \"FFFFFFFF\" \"C90FDAA2\" \"2168C234\" \"C4C6628B\" \"80DC1CD1\" \"29024E08\"\r\n\t\"8A67CC74\" \"020BBEA6\" \"3B139B22\" \"514A0879\" \"8E3404DD\" \"EF9519B3\" \"CD3A431B\"\r\n\t\"302B0A6D\" \"F25F1437\" \"4FE1356D\" \"6D51C245\" \"E485B576\" \"625E7EC6\" \"F44C42E9\"\r\n\t\"A637ED6B\" \"0BFF5CB6\" \"F406B7ED\" \"EE386BFB\" \"5A899FA5\" \"AE9F2411\" \"7C4B1FE6\"\r\n\t\"49286651\" \"ECE45B3D\" \"C2007CB8\" \"A163BF05\" \"98DA4836\" \"1C55D39A\" \"69163FA8\"\r\n\t\"FD24CF5F\" \"83655D23\" \"DCA3AD96\" \"1C62F356\" \"208552BB\" \"9ED52907\" \"7096966D\"\r\n\t\"670C354E\" \"4ABC9804\" \"F1746C08\" \"CA18217C\" \"32905E46\" \"2E36CE3B\" \"E39E772C\"\r\n\t\"180E8603\" \"9B2783A2\" \"EC07A28F\" \"B5C55DF0\" \"6F4C52C9\" \"DE2BCBF6\" \"95581718\"\r\n\t\"3995497C\" \"EA956AE5\" \"15D22618\" \"98FA0510\" \"15728E5A\" \"8AAAC42D\" \"AD33170D\"\r\n\t\"04507A33\" \"A85521AB\" \"DF1CBA64\" \"ECFB8504\" \"58DBEF0A\" \"8AEA7157\" \"5D060C7D\"\r\n\t\"B3970F85\" \"A6E1E4C7\" \"ABF5AE8C\" \"DB0933D7\" \"1E8C94E0\" \"4A25619D\" \"CEE3D226\"\r\n\t\"1AD2EE6B\" \"F12FFA06\" \"D98A0864\" \"D8760273\" \"3EC86A64\" \"521F2B18\" \"177B200C\"\r\n\t\"BBE11757\" \"7A615D6C\" \"770988C0\" \"BAD946E2\" \"08E24FA0\" \"74E5AB31\" \"43DB5BFC\"\r\n\t\"E0FD108E\" \"4B82D120\" \"A9210801\" \"1A723C12\" \"A787E6D7\" \"88719A10\" \"BDBA5B26\"\r\n\t\"99C32718\" \"6AF4E23C\" \"1A946834\" \"B6150BDA\" \"2583E9CA\" \"2AD44CE8\" \"DBBBC2DB\"\r\n\t\"04DE8EF9\" \"2E8EFC14\" \"1FBECAA6\" \"287C5947\" \"4E6BC05D\" \"99B2964F\" \"A090C3A2\"\r\n\t\"233BA186\" \"515BE7ED\" \"1F612970\" \"CEE2D7AF\" \"B81BDD76\" \"2170481C\" \"D0069127\"\r\n\t\"D5B05AA9\" \"93B4EA98\" \"8D8FDDC1\" \"86FFB7DC\" \"90A6C08F\" \"4DF435C9\" \"34028492\"\r\n\t\"36C3FAB4\" \"D27C7026\" \"C1D4DCB2\" \"602646DE\" \"C9751E76\" \"3DBA37BD\" \"F8FF9406\"\r\n\t\"AD9E530E\" \"E5DB382F\" \"413001AE\" \"B06A53ED\" \"9027D831\" \"179727B0\" \"865A8918\"\r\n\t\"DA3EDBEB\" \"CF9B14ED\" \"44CE6CBA\" \"CED4BB1B\" \"DB7F1447\" \"E6CC254B\" \"33205151\"\r\n\t\"2BD7AF42\" \"6FB8F401\" \"378CD2BF\" \"5983CA01\" \"C64B92EC\" \"F032EA15\" \"D1721D03\"\r\n\t\"F482D7CE\" \"6E74FEF6\" \"D55E702F\" \"46980C82\" \"B5A84031\" \"900B1C9E\" \"59E7C97F\"\r\n\t\"BEC7E8F3\" \"23A97A7E\" \"36CC88BE\" \"0F1D45B7\" \"FF585AC5\" \"4BD407B2\" \"2B4154AA\"\r\n\t\"CC8F6D7E\" \"BF48E1D8\" \"14CC5ED2\" \"0F8037E0\" \"A79715EE\" \"F29BE328\" \"06A1D58B\"\r\n\t\"B7C5DA76\" \"F550AA3D\" \"8A1FBFF0\" \"EB19CCB1\" \"A313D55C\" \"DA56C9EC\" \"2EF29632\"\r\n\t\"387FE8D7\" \"6E3C0468\" \"043E8F66\" \"3F4860EE\" \"12BF2D5B\" \"0B7474D6\" \"E694F91E\"\r\n\t\"6DCC4024\" \"FFFFFFFF\" \"FFFFFFFF\";\r\n\treturn (dh_new_group_asc(gen, group17));\r\n}\r\n\r\nDH *dh_new_group18(void)\r\n{\r\n    static char *gen = \"2\", *group18 =\r\n\t\"FFFFFFFF\" \"FFFFFFFF\" \"C90FDAA2\" \"2168C234\" \"C4C6628B\" \"80DC1CD1\"\r\n\t\"29024E08\" \"8A67CC74\" \"020BBEA6\" \"3B139B22\" \"514A0879\" \"8E3404DD\"\r\n\t\"EF9519B3\" \"CD3A431B\" \"302B0A6D\" \"F25F1437\" \"4FE1356D\" \"6D51C245\"\r\n\t\"E485B576\" \"625E7EC6\" \"F44C42E9\" \"A637ED6B\" \"0BFF5CB6\" \"F406B7ED\"\r\n\t\"EE386BFB\" \"5A899FA5\" \"AE9F2411\" \"7C4B1FE6\" \"49286651\" \"ECE45B3D\"\r\n\t\"C2007CB8\" \"A163BF05\" \"98DA4836\" \"1C55D39A\" \"69163FA8\" \"FD24CF5F\"\r\n\t\"83655D23\" \"DCA3AD96\" \"1C62F356\" \"208552BB\" \"9ED52907\" \"7096966D\"\r\n\t\"670C354E\" \"4ABC9804\" \"F1746C08\" \"CA18217C\" \"32905E46\" \"2E36CE3B\"\r\n\t\"E39E772C\" \"180E8603\" \"9B2783A2\" \"EC07A28F\" \"B5C55DF0\" \"6F4C52C9\"\r\n\t\"DE2BCBF6\" \"95581718\" \"3995497C\" \"EA956AE5\" \"15D22618\" \"98FA0510\"\r\n\t\"15728E5A\" \"8AAAC42D\" \"AD33170D\" \"04507A33\" \"A85521AB\" \"DF1CBA64\"\r\n\t\"ECFB8504\" \"58DBEF0A\" \"8AEA7157\" \"5D060C7D\" \"B3970F85\" \"A6E1E4C7\"\r\n\t\"ABF5AE8C\" \"DB0933D7\" \"1E8C94E0\" \"4A25619D\" \"CEE3D226\" \"1AD2EE6B\"\r\n\t\"F12FFA06\" \"D98A0864\" \"D8760273\" \"3EC86A64\" \"521F2B18\" \"177B200C\"\r\n\t\"BBE11757\" \"7A615D6C\" \"770988C0\" \"BAD946E2\" \"08E24FA0\" \"74E5AB31\"\r\n\t\"43DB5BFC\" \"E0FD108E\" \"4B82D120\" \"A9210801\" \"1A723C12\" \"A787E6D7\"\r\n\t\"88719A10\" \"BDBA5B26\" \"99C32718\" \"6AF4E23C\" \"1A946834\" \"B6150BDA\"\r\n\t\"2583E9CA\" \"2AD44CE8\" \"DBBBC2DB\" \"04DE8EF9\" \"2E8EFC14\" \"1FBECAA6\"\r\n\t\"287C5947\" \"4E6BC05D\" \"99B2964F\" \"A090C3A2\" \"233BA186\" \"515BE7ED\"\r\n\t\"1F612970\" \"CEE2D7AF\" \"B81BDD76\" \"2170481C\" \"D0069127\" \"D5B05AA9\"\r\n\t\"93B4EA98\" \"8D8FDDC1\" \"86FFB7DC\" \"90A6C08F\" \"4DF435C9\" \"34028492\"\r\n\t\"36C3FAB4\" \"D27C7026\" \"C1D4DCB2\" \"602646DE\" \"C9751E76\" \"3DBA37BD\"\r\n\t\"F8FF9406\" \"AD9E530E\" \"E5DB382F\" \"413001AE\" \"B06A53ED\" \"9027D831\"\r\n\t\"179727B0\" \"865A8918\" \"DA3EDBEB\" \"CF9B14ED\" \"44CE6CBA\" \"CED4BB1B\"\r\n\t\"DB7F1447\" \"E6CC254B\" \"33205151\" \"2BD7AF42\" \"6FB8F401\" \"378CD2BF\"\r\n\t\"5983CA01\" \"C64B92EC\" \"F032EA15\" \"D1721D03\" \"F482D7CE\" \"6E74FEF6\"\r\n\t\"D55E702F\" \"46980C82\" \"B5A84031\" \"900B1C9E\" \"59E7C97F\" \"BEC7E8F3\"\r\n\t\"23A97A7E\" \"36CC88BE\" \"0F1D45B7\" \"FF585AC5\" \"4BD407B2\" \"2B4154AA\"\r\n\t\"CC8F6D7E\" \"BF48E1D8\" \"14CC5ED2\" \"0F8037E0\" \"A79715EE\" \"F29BE328\"\r\n\t\"06A1D58B\" \"B7C5DA76\" \"F550AA3D\" \"8A1FBFF0\" \"EB19CCB1\" \"A313D55C\"\r\n\t\"DA56C9EC\" \"2EF29632\" \"387FE8D7\" \"6E3C0468\" \"043E8F66\" \"3F4860EE\"\r\n\t\"12BF2D5B\" \"0B7474D6\" \"E694F91E\" \"6DBE1159\" \"74A3926F\" \"12FEE5E4\"\r\n\t\"38777CB6\" \"A932DF8C\" \"D8BEC4D0\" \"73B931BA\" \"3BC832B6\" \"8D9DD300\"\r\n\t\"741FA7BF\" \"8AFC47ED\" \"2576F693\" \"6BA42466\" \"3AAB639C\" \"5AE4F568\"\r\n\t\"3423B474\" \"2BF1C978\" \"238F16CB\" \"E39D652D\" \"E3FDB8BE\" \"FC848AD9\"\r\n\t\"22222E04\" \"A4037C07\" \"13EB57A8\" \"1A23F0C7\" \"3473FC64\" \"6CEA306B\"\r\n\t\"4BCBC886\" \"2F8385DD\" \"FA9D4B7F\" \"A2C087E8\" \"79683303\" \"ED5BDD3A\"\r\n\t\"062B3CF5\" \"B3A278A6\" \"6D2A13F8\" \"3F44F82D\" \"DF310EE0\" \"74AB6A36\"\r\n\t\"4597E899\" \"A0255DC1\" \"64F31CC5\" \"0846851D\" \"F9AB4819\" \"5DED7EA1\"\r\n\t\"B1D510BD\" \"7EE74D73\" \"FAF36BC3\" \"1ECFA268\" \"359046F4\" \"EB879F92\"\r\n\t\"4009438B\" \"481C6CD7\" \"889A002E\" \"D5EE382B\" \"C9190DA6\" \"FC026E47\"\r\n\t\"9558E447\" \"5677E9AA\" \"9E3050E2\" \"765694DF\" \"C81F56E8\" \"80B96E71\"\r\n\t\"60C980DD\" \"98EDD3DF\" \"FFFFFFFF\" \"FFFFFFFF\";\r\n\treturn (dh_new_group_asc(gen, group18));\r\n}\r\n\r\n\r\n// DH\ufffd\ufffd\ufffd\ud803\udd90\ufffd\ufffd\ufffd\ufffd\ufffd\r\nvoid dh_gen_key(PTInstVar pvar, DH *dh, int we_need /* bytes */ )\r\n{\r\n\tint i;\r\n\tBIGNUM *pub_key;\r\n\tBIGNUM *priv_key;\r\n\r\n\tpriv_key = NULL;\r\n\r\n\t// \ufffd\u95a7\ufffd\u0242\ufffd\ufffd\u05c2\ufffd\ufffd\ufffd\ufffd\ufffd(X)\ufffd\ud803\udd90\ufffd\r\n\tfor (i = 0 ; i < 10 ; i++) { // retry counter\r\n\t\tif (priv_key != NULL) {\r\n\t\t\tBN_clear_free(priv_key);\r\n\t\t}\r\n\t\tpriv_key = BN_new();\r\n\t\tDH_set0_key(dh, NULL, priv_key);\r\n\t\tif (priv_key == NULL)\r\n\t\t\tgoto error;\r\n\t\tif (BN_rand(priv_key, 2*(we_need*8), 0, 0) == 0)\r\n\t\t\tgoto error;\r\n\t\tif (DH_generate_key(dh) == 0)\r\n\t\t\tgoto error;\r\n\t\tDH_get0_key(dh, &pub_key, NULL);\r\n\t\tif (dh_pub_is_valid(dh, pub_key))\r\n\t\t\tbreak;\r\n\t}\r\n\tif (i >= 10) {\r\n\t\tgoto error;\r\n\t}\r\n\treturn;\r\n\r\nerror:;\r\n\tnotify_fatal_error(pvar, \"error occurred @ dh_gen_key()\", TRUE);\r\n\r\n}\r\n\r\n\r\nint dh_estimate(int bits)\r\n{\r\n\tif (bits <= 112)\r\n\t\treturn 2048;\r\n\tif (bits <= 128)\r\n\t\treturn 3072;\r\n\tif (bits <= 192)\r\n\t\treturn 7680;\r\n\treturn 8192;\r\n}\r\n\r\n\r\n// shared secret \ufffd\ufffd\ufffdv\ufffdZ\ufffd\ufffd\ufffd\ufffd (DH \ufffd\u0152\ufffdO\ufffd\ufffd\ufffd[\ufffdv\ufffdp)\r\nunsigned char *kex_dh_hash(const EVP_MD *evp_md,\r\n                           char *client_version_string,\r\n                           char *server_version_string,\r\n                           char *ckexinit, int ckexinitlen,\r\n                           char *skexinit, int skexinitlen,\r\n                           u_char *serverhostkeyblob, int sbloblen,\r\n                           BIGNUM *client_dh_pub,\r\n                           BIGNUM *server_dh_pub,\r\n                           BIGNUM *shared_secret,\r\n                           unsigned int *hashlen)\r\n{\r\n\tbuffer_t *b;\r\n\tstatic unsigned char digest[EVP_MAX_MD_SIZE];\r\n\tEVP_MD_CTX *md = NULL;\r\n\r\n\tmd = EVP_MD_CTX_new();\r\n\tif (md == NULL)\r\n\t\tgoto error;\r\n\r\n\tb = buffer_init();\r\n\tbuffer_put_string(b, client_version_string, strlen(client_version_string));\r\n\tbuffer_put_string(b, server_version_string, strlen(server_version_string));\r\n\r\n\t/* kexinit messages: fake header: len+SSH2_MSG_KEXINIT */\r\n\tbuffer_put_int(b, ckexinitlen+1);\r\n\tbuffer_put_char(b, SSH2_MSG_KEXINIT);\r\n\tbuffer_append(b, ckexinit, ckexinitlen);\r\n\tbuffer_put_int(b, skexinitlen+1);\r\n\tbuffer_put_char(b, SSH2_MSG_KEXINIT);\r\n\tbuffer_append(b, skexinit, skexinitlen);\r\n\r\n\tbuffer_put_string(b, serverhostkeyblob, sbloblen);\r\n\tbuffer_put_bignum2(b, client_dh_pub);\r\n\tbuffer_put_bignum2(b, server_dh_pub);\r\n\tbuffer_put_bignum2(b, shared_secret);\r\n\r\n\t// yutaka\r\n\t//debug_print(38, buffer_ptr(b), buffer_len(b));\r\n\r\n\tEVP_DigestInit(md, evp_md);\r\n\tEVP_DigestUpdate(md, buffer_ptr(b), buffer_len(b));\r\n\tEVP_DigestFinal(md, digest, NULL);\r\n\r\n\tbuffer_free(b);\r\n\r\n\t//write_buffer_file(digest, EVP_MD_size(evp_md));\r\n\r\n\t*hashlen = EVP_MD_size(evp_md);\r\n\r\nerror:\r\n\tif (md)\r\n\t\tEVP_MD_CTX_free(md);\r\n\r\n\treturn digest;\r\n}\r\n\r\n\r\n// shared secret \ufffd\ufffd\ufffdv\ufffdZ\ufffd\ufffd\ufffd\ufffd (DH GEX\ufffdp)\r\nunsigned char *kex_dh_gex_hash(const EVP_MD *evp_md,\r\n                               char *client_version_string,\r\n                               char *server_version_string,\r\n                               char *ckexinit, int ckexinitlen,\r\n                               char *skexinit, int skexinitlen,\r\n                               u_char *serverhostkeyblob, int sbloblen,\r\n                               int kexgex_min,\r\n                               int kexgex_bits,\r\n                               int kexgex_max,\r\n                               BIGNUM *kexgex_p,\r\n                               BIGNUM *kexgex_g,\r\n                               BIGNUM *client_dh_pub,\r\n                               BIGNUM *server_dh_pub,\r\n                               BIGNUM *shared_secret,\r\n                               unsigned int *hashlen)\r\n{\r\n\tbuffer_t *b;\r\n\tstatic unsigned char digest[EVP_MAX_MD_SIZE];\r\n\tEVP_MD_CTX *md = NULL;\r\n\r\n\tmd = EVP_MD_CTX_new();\r\n\tif (md == NULL)\r\n\t\tgoto error;\r\n\r\n\tb = buffer_init();\r\n\tbuffer_put_string(b, client_version_string, strlen(client_version_string));\r\n\tbuffer_put_string(b, server_version_string, strlen(server_version_string));\r\n\r\n\t/* kexinit messages: fake header: len+SSH2_MSG_KEXINIT */\r\n\tbuffer_put_int(b, ckexinitlen+1);\r\n\tbuffer_put_char(b, SSH2_MSG_KEXINIT);\r\n\tbuffer_append(b, ckexinit, ckexinitlen);\r\n\tbuffer_put_int(b, skexinitlen+1);\r\n\tbuffer_put_char(b, SSH2_MSG_KEXINIT);\r\n\tbuffer_append(b, skexinit, skexinitlen);\r\n\r\n\tbuffer_put_string(b, serverhostkeyblob, sbloblen);\r\n\r\n\t// DH group size\ufffd\u0303r\ufffdb\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdZ\ufffd\ufffd\ufffd\ufffd\r\n\tbuffer_put_int(b, kexgex_min);\r\n\tbuffer_put_int(b, kexgex_bits);\r\n\tbuffer_put_int(b, kexgex_max);\r\n\r\n\t// DH\ufffd\ufffd\ufffd\u0311f\ufffd\ufffd\ufffd\u0190\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdZ\ufffd\ufffd\ufffd\ufffd\r\n\tbuffer_put_bignum2(b, kexgex_p);\r\n\tbuffer_put_bignum2(b, kexgex_g);\r\n\r\n\tbuffer_put_bignum2(b, client_dh_pub);\r\n\tbuffer_put_bignum2(b, server_dh_pub);\r\n\tbuffer_put_bignum2(b, shared_secret);\r\n\r\n\t// yutaka\r\n\t//debug_print(38, buffer_ptr(b), buffer_len(b));\r\n\r\n\tEVP_DigestInit(md, evp_md);\r\n\tEVP_DigestUpdate(md, buffer_ptr(b), buffer_len(b));\r\n\tEVP_DigestFinal(md, digest, NULL);\r\n\r\n\tbuffer_free(b);\r\n\r\n\t//write_buffer_file(digest, EVP_MD_size(evp_md));\r\n\r\n\t*hashlen = EVP_MD_size(evp_md);\r\n\r\nerror:\r\n\tif (md)\r\n\t\tEVP_MD_CTX_free(md);\r\n\r\n\treturn digest;\r\n}\r\n\r\n\r\nunsigned char *kex_ecdh_hash(const EVP_MD *evp_md,\r\n                             const EC_GROUP *ec_group,\r\n                             char *client_version_string,\r\n                             char *server_version_string,\r\n                             char *ckexinit, int ckexinitlen,\r\n                             char *skexinit, int skexinitlen,\r\n                             u_char *serverhostkeyblob, int sbloblen,\r\n                             const EC_POINT *client_dh_pub,\r\n                             const EC_POINT *server_dh_pub,\r\n                             BIGNUM *shared_secret,\r\n                             unsigned int *hashlen)\r\n{\r\n\tbuffer_t *b;\r\n\tstatic unsigned char digest[EVP_MAX_MD_SIZE];\r\n\tEVP_MD_CTX *md = NULL;\r\n\r\n\tmd = EVP_MD_CTX_new();\r\n\tif (md == NULL)\r\n\t\tgoto error;\r\n\r\n\tb = buffer_init();\r\n\tbuffer_put_string(b, client_version_string, strlen(client_version_string));\r\n\tbuffer_put_string(b, server_version_string, strlen(server_version_string));\r\n\r\n\t/* kexinit messages: fake header: len+SSH2_MSG_KEXINIT */\r\n\tbuffer_put_int(b, ckexinitlen+1);\r\n\tbuffer_put_char(b, SSH2_MSG_KEXINIT);\r\n\tbuffer_append(b, ckexinit, ckexinitlen);\r\n\tbuffer_put_int(b, skexinitlen+1);\r\n\tbuffer_put_char(b, SSH2_MSG_KEXINIT);\r\n\tbuffer_append(b, skexinit, skexinitlen);\r\n\r\n\tbuffer_put_string(b, serverhostkeyblob, sbloblen);\r\n\r\n\tbuffer_put_ecpoint(b, ec_group, client_dh_pub);\r\n\tbuffer_put_ecpoint(b, ec_group, server_dh_pub);\r\n\tbuffer_put_bignum2(b, shared_secret);\r\n\r\n\t// yutaka\r\n\t//debug_print(38, buffer_ptr(b), buffer_len(b));\r\n\r\n\tEVP_DigestInit(md, evp_md);\r\n\tEVP_DigestUpdate(md, buffer_ptr(b), buffer_len(b));\r\n\tEVP_DigestFinal(md, digest, NULL);\r\n\r\n\tbuffer_free(b);\r\n\r\n\t//write_buffer_file(digest, EVP_MD_size(evp_md));\r\n\r\n\t*hashlen = EVP_MD_size(evp_md);\r\n\r\nerror:\r\n\tif (md)\r\n\t\tEVP_MD_CTX_free(md);\r\n\r\n\treturn digest;\r\n}\r\n\r\n\r\nint dh_pub_is_valid(DH *dh, BIGNUM *dh_pub)\r\n{\r\n\tint i;\r\n\tint n = BN_num_bits(dh_pub);\r\n\tint bits_set = 0;\r\n\tconst BIGNUM *p;\r\n\r\n\t// OpenSSL 1.1.0\ufffd\u0141ABIGNUM\ufffd\\\ufffd\ufffd\ufffd\u0302\ufffdneg\ufffd\ufffd\ufffd\ufffd\ufffdo\ufffd[\ufffd\u0252\ufffd\ufffd\u0683A\ufffdN\ufffdZ\ufffdX\ufffd\u0142\ufffd\ufffd\u0202\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u07c1A\r\n\t// BN_is_negative\ufffd\u0590\ufffd\ufffd\u0252u\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdBOpenSSL 1.0.2\ufffd\u0142\u0343}\ufffdN\ufffd\ufffd\ufffd\ufffd`\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\u0302\u0141A\r\n\t// OpenSSL 1.0.2\ufffd\u0142\ufffd\ufffdA\ufffd\ufffd\ufffd\u030f\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0142\u60a2\ufffdB\r\n\tif (BN_is_negative(dh_pub)) {\r\n\t\t//logit(\"invalid public DH value: negativ\");\r\n\t\treturn 0;\r\n\t}\r\n\tfor (i = 0; i <= n; i++)\r\n\t\tif (BN_is_bit_set(dh_pub, i))\r\n\t\t\tbits_set++;\r\n\t//debug2(\"bits set: %d/%d\", bits_set, BN_num_bits(dh->p));\r\n\r\n\t/* if g==2 and bits_set==1 then computing log_g(dh_pub) is trivial */\r\n\tDH_get0_pqg(dh, &p, NULL, NULL);\r\n\tif (bits_set > 1 && (BN_cmp(dh_pub, p) == -1))\r\n\t\treturn 1;\r\n\t//logit(\"invalid public DH value (%d/%d)\", bits_set, BN_num_bits(dh->p));\r\n\treturn 0;\r\n}\r\n\r\n\r\nstatic u_char *derive_key(int id, int need, u_char *hash, BIGNUM *shared_secret,\r\n                          char *session_id, int session_id_len,\r\n                          const EVP_MD *evp_md)\r\n{\r\n\tbuffer_t *b;\r\n\tEVP_MD_CTX *md = NULL;\r\n\tchar c = id;\r\n\tint have;\r\n\tint mdsz = EVP_MD_size(evp_md);\r\n\tu_char *digest = malloc(roundup(need, mdsz));\r\n\r\n\tmd = EVP_MD_CTX_new();\r\n\tif (md == NULL)\r\n\t\tgoto skip;\r\n\r\n\tif (digest == NULL)\r\n\t\tgoto skip;\r\n\r\n\tb = buffer_init();\r\n\tif (b == NULL)\r\n\t\tgoto skip;\r\n\r\n\tbuffer_put_bignum2(b, shared_secret);\r\n\r\n\t/* K1 = HASH(K || H || \"A\" || session_id) */\r\n\tEVP_DigestInit(md, evp_md);\r\n\tEVP_DigestUpdate(md, buffer_ptr(b), buffer_len(b));\r\n\tEVP_DigestUpdate(md, hash, mdsz);\r\n\tEVP_DigestUpdate(md, &c, 1);\r\n\tEVP_DigestUpdate(md, session_id, session_id_len);\r\n\tEVP_DigestFinal(md, digest, NULL);\r\n\r\n\t/*\r\n\t * expand key:\r\n\t * Kn = HASH(K || H || K1 || K2 || ... || Kn-1)\r\n\t * Key = K1 || K2 || ... || Kn\r\n\t */\r\n\tfor (have = mdsz; need > have; have += mdsz) {\r\n\t\tEVP_DigestInit(md, evp_md);\r\n\t\tEVP_DigestUpdate(md, buffer_ptr(b), buffer_len(b));\r\n\t\tEVP_DigestUpdate(md, hash, mdsz);\r\n\t\tEVP_DigestUpdate(md, digest, have);\r\n\t\tEVP_DigestFinal(md, digest + have, NULL);\r\n\t}\r\n\tbuffer_free(b);\r\n\r\nskip:;\r\n\tif (md)\r\n\t\tEVP_MD_CTX_free(md);\r\n\r\n\treturn digest;\r\n}\r\n\r\n/*\r\n * \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u030c\ufffd\ufffd\u0282\ufffd\ufffd\ufffde\ufffd\ufffd\ufffd\ud803\udd90\ufffd\ufffd\ufffd newkeys \ufffd\u0243Z\ufffdb\ufffdg\ufffd\ufffd\ufffd\u0116\u07c2\ufffd\ufffdB\r\n */\r\nvoid kex_derive_keys(PTInstVar pvar, SSHKeys *newkeys, int need, u_char *hash, BIGNUM *shared_secret,\r\n                     char *session_id, int session_id_len)\r\n{\r\n#define NKEYS\t6\r\n\tu_char *keys[NKEYS];\r\n\tint i, mode, ctos;\r\n\r\n\tfor (i = 0; i < NKEYS; i++) {\r\n\t\tkeys[i] = derive_key('A'+i, need, hash, shared_secret, session_id, session_id_len,\r\n\t\t                     get_kex_algorithm_EVP_MD(pvar->kex_type));\r\n\t\t//debug_print(i, keys[i], need);\r\n\t}\r\n\r\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\r\n\t\tif (mode == MODE_OUT)\r\n\t\t\tctos = 1;\r\n\t\telse\r\n\t\t\tctos = 0;\r\n\r\n\t\t// setting\r\n\t\tnewkeys[mode].enc.iv  = keys[ctos ? 0 : 1];\r\n\t\tnewkeys[mode].enc.key = keys[ctos ? 2 : 3];\r\n\t\tnewkeys[mode].mac.key = keys[ctos ? 4 : 5];\r\n\r\n\t\t//debug_print(20 + mode*3, newkeys[mode]->enc.iv, 8);\r\n\t\t//debug_print(21 + mode*3, newkeys[mode]->enc.key, 24);\r\n\t\t//debug_print(22 + mode*3, newkeys[mode]->mac.key, 24);\r\n\t}\r\n}\r\n", "/*\r\n * Copyright (c) 1998-2001, Robert O'Callahan\r\n * (C) 2004- TeraTerm Project\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions\r\n * are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright\r\n *    notice, this list of conditions and the following disclaimer.\r\n * 2. Redistributions in binary form must reproduce the above copyright\r\n *    notice, this list of conditions and the following disclaimer in the\r\n *    documentation and/or other materials provided with the distribution.\r\n * 3. The name of the author may not be used to endorse or promote products\r\n *    derived from this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\r\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,\r\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\r\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n#include \"ttxssh.h\"\r\n#include \"util.h\"\r\n#include \"resource.h\"\r\n#include \"libputty.h\"\r\n#include \"key.h\"\r\n#include \"ttcommon.h\"\r\n#include \"codeconv.h\"\r\n#include \"ttxssh-version.h\"\r\n\r\n#include <openssl/bn.h>\r\n#include <openssl/evp.h>\r\n#include <openssl/dh.h>\r\n#include <openssl/engine.h>\r\n#include <openssl/rsa.h>\r\n#include <openssl/dsa.h>\r\n#include <openssl/md5.h>\r\n\r\n#include <limits.h>\r\n#include <malloc.h>\r\n#include <string.h>\r\n#if !defined(_CRTDBG_MAP_ALLOC)\r\n#define _CRTDBG_MAP_ALLOC\r\n#endif\r\n#include <stdlib.h>\r\n#include <crtdbg.h>\r\n#include <process.h>\r\n#include <time.h>\r\n#include <commctrl.h>\r\n#include <sys/types.h>\r\n#include <sys/stat.h>\r\n#include <sys/utime.h>\r\n#include <assert.h>\r\n\r\n#include <direct.h>\r\n#include <io.h>\r\n#ifdef _DEBUG\t// KEX logging\r\n#include <fcntl.h>\r\n#endif\r\n\r\n\r\n#include \"buffer.h\"\r\n#include \"ssh.h\"\r\n#include \"crypt.h\"\r\n#include \"fwd.h\"\r\n#include \"sftp.h\"\r\n#include \"kex.h\"\r\n#include \"dlglib.h\"\r\n#include \"win32helper.h\"\r\n\r\n#ifndef MAX\r\n# define MAX(a,b) (((a)>(b))?(a):(b))\r\n# define MIN(a,b) (((a)<(b))?(a):(b))\r\n#endif\r\n\r\n// SSH2 macro\r\n#ifdef _DEBUG\r\n#define SSH2_DEBUG\r\n#endif\r\n\r\n//#define DONT_WANTCONFIRM 1  // (2005.3.28 yutaka)\r\n#undef DONT_WANTCONFIRM // (2008.11.25 maya)\r\n\r\n//\r\n// SSH2 data structure\r\n//\r\n\r\n// channel data structure\r\n#define CHANNEL_MAX 100\r\n\r\n//\r\n// msg \ufffd\ufffd NULL \ufffd\u0142\u0356\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0315\u06cf\u0601BNULL \ufffd\u030f\ua347\ufffd\ufffd \"(null)\" \ufffd\ufffd\u0502\ufffd\ufffdB\r\n//\r\n#define NonNull(msg) ((msg)?(msg):\"(null)\")\r\n\r\ntypedef enum {\r\n\tGetPayloadError = 0,\r\n\tGetPayloadOK = 1,\r\n\tGetPayloadTruncate = 2\r\n} PayloadStat;\r\n\r\nstatic struct global_confirm global_confirms;\r\n\r\nstatic Channel_t channels[CHANNEL_MAX];\r\n\r\nstatic char ssh_ttymodes[] = \"\\x01\\x03\\x02\\x1c\\x03\\x08\\x04\\x15\\x05\\x04\";\r\n\r\nstatic CRITICAL_SECTION g_ssh_scp_lock;   /* SCP\ufffd\ufffdM\ufffdp\ufffd\ufffd\ufffdb\ufffdN */\r\n\r\nstatic int g_scp_sending;  /* SCP\ufffd\ufffd\ufffdM\ufffd\ufffd\ufffd\ufffd? */\r\n\r\nstatic void try_send_credentials(PTInstVar pvar);\r\nstatic void prep_compression(PTInstVar pvar);\r\n\r\n// \ufffd\u0590\ufffd\ufffdv\ufffd\ufffd\ufffdg\ufffd^\ufffdC\ufffdv\ufffd\u933e\r\nvoid SSH2_send_kexinit(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_kexinit(PTInstVar pvar);\r\nstatic void SSH2_dh_kex_init(PTInstVar pvar);\r\nstatic void SSH2_dh_gex_kex_init(PTInstVar pvar);\r\nstatic void SSH2_ecdh_kex_init(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_dh_common_reply(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_dh_gex_reply(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_newkeys(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_service_accept(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_ext_info(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_userauth_success(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_userauth_failure(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_userauth_banner(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_open_confirm(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_open_failure(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_client_global_request(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_request_success(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_request_failure(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_channel_success(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_channel_failure(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_channel_data(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_channel_extended_data(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_channel_eof(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_channel_close(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_channel_open(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_window_adjust(PTInstVar pvar);\r\nstatic BOOL handle_SSH2_channel_request(PTInstVar pvar);\r\nvoid SSH2_dispatch_init(int stage);\r\nint SSH2_dispatch_enabled_check(unsigned char message);\r\nvoid SSH2_dispatch_add_message(unsigned char message);\r\nvoid SSH2_dispatch_add_range_message(unsigned char begin, unsigned char end);\r\nint dh_pub_is_valid(DH *dh, BIGNUM *dh_pub);\r\nstatic void start_ssh_heartbeat_thread(PTInstVar pvar);\r\nvoid ssh2_channel_send_close(PTInstVar pvar, Channel_t *c);\r\nstatic BOOL SSH_agent_response(PTInstVar pvar, Channel_t *c, int local_channel_num, unsigned char *data, unsigned int buflen);\r\nstatic void ssh2_scp_get_packetlist(PTInstVar pvar, Channel_t *c, unsigned char **buf, unsigned int *buflen);\r\nstatic void ssh2_scp_free_packetlist(PTInstVar pvar, Channel_t *c);\r\nstatic void get_window_pixel_size(PTInstVar pvar, int *x, int *y);\r\nstatic void do_SSH2_dispatch_setup_for_transfer(PTInstVar pvar);\r\nstatic void ssh2_prep_userauth(PTInstVar pvar);\r\nstatic void ssh2_send_newkeys(PTInstVar pvar);\r\n\r\n// \ufffd}\ufffdN\ufffd\ufffd\r\n#define remained_payload(pvar) ((pvar)->ssh_state.payload + payload_current_offset(pvar))\r\n#define remained_payloadlen(pvar) ((pvar)->ssh_state.payloadlen - (pvar)->ssh_state.payload_grabbed)\r\n#define payload_current_offset(pvar) ((pvar)->ssh_state.payload_grabbed - 1)\r\n\r\n//\r\n// Global request confirm\r\n//\r\nstatic void client_init_global_confirm(void)\r\n{\r\n\tmemset(&global_confirms, 0, sizeof(global_confirms));\r\n\tglobal_confirms.ref_count = 0;\r\n}\r\n\r\nvoid client_register_global_confirm(global_confirm_cb *cb, void *ctx)\r\n{\r\n\tstruct global_confirm *gc = &global_confirms;\r\n\r\n\tif (gc->ref_count == 0) {\r\n\t\tgc->cb = cb;\r\n\t\tgc->ctx = ctx;\r\n\t\tgc->ref_count = 1;\r\n\t}\r\n}\r\n\r\nstatic int client_global_request_reply(PTInstVar pvar, int type, unsigned int seq, void *ctxt)\r\n{\r\n\tstruct global_confirm *gc = &global_confirms;\r\n\r\n\tif (gc->ref_count >= 1) {\r\n\t\tif (gc->cb)\r\n\t\t\tgc->cb(pvar, type, seq, gc->ctx);\r\n\t\tgc->ref_count = 0;\r\n\t}\r\n\r\n\treturn 0;\r\n}\r\n\r\n//\r\n// channel function\r\n//\r\nstatic Channel_t *ssh2_channel_new(unsigned int window, unsigned int maxpack,\r\n                                   enum channel_type type, int local_num)\r\n{\r\n\tint i, found;\r\n\tChannel_t *c;\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: local_num %d\", __FUNCTION__, local_num);\r\n\r\n\tfound = -1;\r\n\tfor (i = 0 ; i < CHANNEL_MAX ; i++) {\r\n\t\tif (channels[i].used == 0) { // free channel\r\n\t\t\tfound = i;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tif (found == -1) { // not free channel\r\n\t\treturn (NULL);\r\n\t}\r\n\r\n\t// setup\r\n\tc = &channels[found];\r\n\tmemset(c, 0, sizeof(Channel_t));\r\n\tc->used = 1;\r\n\tc->self_id = i;\r\n\tc->remote_id = SSH_CHANNEL_INVALID;\r\n\tc->local_window = window;\r\n\tc->local_window_max = window;\r\n\tc->local_consumed = 0;\r\n\tc->local_maxpacket = maxpack;\r\n\tc->remote_window = 0;\r\n\tc->remote_maxpacket = 0;\r\n\tc->type = type;\r\n\tc->local_num = local_num;  // alloc_channel()\ufffd\u0315\u0512l\ufffd\ufffd\u06d1\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\r\n\tc->bufchain = NULL;\r\n\tc->bufchain_amount = 0;\r\n\tc->bufchain_recv_suspended = FALSE;\r\n\tif (type == TYPE_SCP) {\r\n\t\tc->scp.state = SCP_INIT;\r\n\t\tc->scp.progress_window = NULL;\r\n\t\tc->scp.thread = INVALID_HANDLE_VALUE;\r\n\t\tc->scp.localfp = NULL;\r\n\t\tc->scp.filemtime = 0;\r\n\t\tc->scp.fileatime = 0;\r\n\t\tc->scp.pktlist_cursize = 0;\r\n\t}\r\n\tif (type == TYPE_AGENT) {\r\n\t\tc->agent_msg = buffer_init();\r\n\t\tc->agent_request_len = 0;\r\n\t}\r\n\tc->state = 0;\r\n\r\n\treturn (c);\r\n}\r\n\r\n// remote_window\ufffd\u030b\udaca\udec2\ufffd\ufffd\u0202\ufffd\ufffd\ua347\ufffd\u0241A\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdo\ufffdb\ufffdt\ufffd@\ufffd\ufffd\ufffd\ufffd\ufffdX\ufffdg\ufffdi\ufffd\ufffd\ufffd\u034f\ufffd\ufffdj\ufffd\u0582\u0082\u0202\ufffd\ufffd\u0142\ufffd\ufffd\ufffd\ufffdB\r\n// \ufffd\ufffd\ufffd\ufffd\ufffd\u014am\ufffd\u06c2\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd ssh2_channel_retry_send_bufchain() \ufffd\u0149\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\nstatic void ssh2_channel_add_bufchain(PTInstVar pvar, Channel_t *c, unsigned char *buf, unsigned int buflen)\r\n{\r\n\tbufchain_t *p, *old;\r\n\r\n\t// allocate new buffer\r\n\tp = malloc(sizeof(bufchain_t));\r\n\tif (p == NULL)\r\n\t\treturn;\r\n\tp->msg = buffer_init();\r\n\tif (p == NULL) {\r\n\t\tfree(p);\r\n\t\treturn;\r\n\t}\r\n\tbuffer_put_raw(p->msg, buf, buflen);\r\n\tp->next = NULL;\r\n\r\n\tif (c->bufchain == NULL) {\r\n\t\tc->bufchain = p;\r\n\t} else {\r\n\t\told = c->bufchain;\r\n\t\twhile (old->next)\r\n\t\t\told = old->next;\r\n\t\told->next = p;\r\n\t}\r\n\r\n\t// \ufffdo\ufffdb\ufffdt\ufffd@\ufffdT\ufffdC\ufffdY\ufffd\u030d\ufffd\ufffdv\ufffd\ufffd\ufffdX\ufffdV\ufffd\ufffd\ufffd\ufffd(\ufffdL\ufffd^\ufffdp)\r\n\tc->bufchain_amount += buflen;\r\n\r\n\t// remote_window\ufffd\u030b\udaca\udec2\ufffd\ufffd\u0202\ufffd\ufffd\u0302\u0141Alocal connection\ufffd\ufffd\ufffd\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffd\ufffdM\ufffd\ufffd\r\n\t// \ufffd\ufffd~\ufffdw\ufffd\ufffd\ufffd\ufffd\ufffdo\ufffd\ufffd\ufffdB\ufffd\ufffd\ufffd\ufffd\ufffd\u0252\u0292m\ufffd\ufffd\ufffd~\ufffd\u0702\ufffd\ud0af\ufffd\u0142\u0342\u0202\ufffd\ufffdB\r\n\tFWD_suspend_resume_local_connection(pvar, c, FALSE);\r\n}\r\n\r\n// remote_window\ufffd\u030b\udaca\udec2\ufffd\ufffd\u0142\ufffd\ufffd\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffdX\ufffdg\ufffd\u024ec\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffdf\ufffd[\ufffd^\ufffd\ufffd\ufffd\ufffd\ufffd\u0502\u0251\ufffd\ufffd\ufffdB\r\n// \ufffd\ufffd\ufffdM\ufffd\ufffd\ufffd\u0142\ufffd\ufffd\ufffd\ufffd\u70c1\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\nstatic void ssh2_channel_retry_send_bufchain(PTInstVar pvar, Channel_t *c)\r\n{\r\n\tbufchain_t *ch;\r\n\tunsigned int size;\r\n\tbufchain_t* ch_origin = c->bufchain;\r\n\r\n\twhile (c->bufchain) {\r\n\t\t// \ufffd\u64ea\ufffd\ufffd\ufffd\ufffd\ufffd\u0251\ufffd\ufffd\ufffd\r\n\t\tch = c->bufchain;\r\n\t\tsize = buffer_len(ch->msg);\r\n\t\tif (size >= c->remote_window)\r\n\t\t\tbreak;\r\n\r\n\t\tif (c->local_num == -1) { // shell or SCP\r\n\t\t\tSSH2_send_channel_data(pvar, c, buffer_ptr(ch->msg), size, TRUE);\r\n\t\t} else { // port-forwarding\r\n\t\t\tSSH_channel_send(pvar, c->local_num, -1, buffer_ptr(ch->msg), size, TRUE);\r\n\t\t}\r\n\r\n\t\tc->bufchain = ch->next;\r\n\r\n\t\tbuffer_free(ch->msg);\r\n\t\tfree(ch);\r\n\r\n\t\t// \ufffdo\ufffdb\ufffdt\ufffd@\ufffdT\ufffdC\ufffdY\ufffd\u030d\ufffd\ufffdv\ufffd\ufffd\ufffdX\ufffdV\ufffd\ufffd\ufffd\ufffd(\ufffdL\ufffd^\ufffdp)\r\n\t\tc->bufchain_amount -= size;\r\n\t}\r\n\r\n\t// \ufffd\ufffd\ufffdX\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdX\ufffdg\ufffd\ufffd\ufffd\ufffd\u0242\u0202\ufffd\ufffd\ufffd\ufffd\ufffdA\r\n\t// local connection\ufffd\ufffd\ufffd\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffd\u0292m\ufffd\ufffd\ufffd\u010aJ\ufffd\ufffd\ufffd\ufffdB\r\n\tif (ch_origin && c->bufchain == NULL) {\r\n\t\tFWD_suspend_resume_local_connection(pvar, c, TRUE);\r\n\t}\r\n}\r\n\r\n// channel close\ufffd\ufffd\ufffd\u0243`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\\\ufffd\ufffd\ufffd\u0302\ufffd\ufffd\ufffd\ufffdX\ufffdg\ufffd\u0595\u050bp\ufffd\ufffd\ufffd\ufffd\r\n// (2007.4.26 yutaka)\r\nstatic void ssh2_channel_delete(Channel_t *c)\r\n{\r\n\tbufchain_t *ch, *ptr;\r\n\tenum scp_state prev_state;\r\n\r\n\tch = c->bufchain;\r\n\twhile (ch) {\r\n\t\tif (ch->msg)\r\n\t\t\tbuffer_free(ch->msg);\r\n\t\tptr = ch;\r\n\t\tch = ch->next;\r\n\t\tfree(ptr);\r\n\t}\r\n\r\n\tif (c->type == TYPE_SCP) {\r\n\t\t// SCP\ufffd\ufffd\ufffd\ufffd\ufffd\u030d\u014c\ufffd\u030f\ufffd\u0502\ufffd\u06d1\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\tprev_state = c->scp.state;\r\n\r\n\t\tc->scp.state = SCP_CLOSING;\r\n\t\tif (c->scp.localfp != NULL) {\r\n\t\t\tfclose(c->scp.localfp);\r\n\t\t\tif (c->scp.dir == FROMREMOTE) {\r\n\t\t\t\tif (c->scp.fileatime > 0 && c->scp.filemtime > 0) {\r\n\t\t\t\t\tstruct _utimbuf filetime;\r\n\t\t\t\t\tfiletime.actime = c->scp.fileatime;\r\n\t\t\t\t\tfiletime.modtime = c->scp.filemtime;\r\n\t\t\t\t\t_utime(c->scp.localfilefull, &filetime);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// SCP\ufffd\ufffdM\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\u0381A\ufffd\ufffd\ufffd[\ufffdJ\ufffd\ufffd\ufffd\u024d\ufffd\ufffd\ufffd\ufffd\ufffdt\ufffd@\ufffdC\ufffd\ufffd\ufffd\u030ec\ufffd[\ufffd\ufffd\ufffd\ud3dc\ufffd\ufffd\ufffd\ufffdB\r\n\t\t\t\t// (2017.2.12 yutaka)\r\n\t\t\t\tif (prev_state != SCP_CLOSING)\r\n\t\t\t\t\tremove(c->scp.localfilefull);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (c->scp.progress_window != NULL) {\r\n\t\t\tDestroyWindow(c->scp.progress_window);\r\n\t\t\tc->scp.progress_window = NULL;\r\n\t\t}\r\n\t\tif (c->scp.thread != INVALID_HANDLE_VALUE) {\r\n\t\t\tWaitForSingleObject(c->scp.thread, INFINITE);\r\n\t\t\tCloseHandle(c->scp.thread);\r\n\t\t\tc->scp.thread = INVALID_HANDLE_VALUE;\r\n\t\t}\r\n\r\n\t\t// SCP\ufffd\ufffdM\ufffd\u030f\ua347\ufffd\u0302\u0741ASCP\ufffdp\ufffd\ufffd\ufffdX\ufffdg\ufffd\u030aJ\ufffd\ufffd\ufffd\ufffd\ufffds\ufffd\ufffd\ufffdB\r\n\t\t// Windows9x\ufffd\u0157\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdC\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\tif (c->scp.dir == FROMREMOTE) {\r\n\t\t\tPTInstVar pvar = c->scp.pvar;\r\n\t\t\tssh2_scp_free_packetlist(pvar, c);\r\n\t\t}\r\n\r\n\t\tg_scp_sending = FALSE;\r\n\t}\r\n\tif (c->type == TYPE_AGENT) {\r\n\t\tbuffer_free(c->agent_msg);\r\n\t}\r\n\r\n\tmemset(c, 0, sizeof(Channel_t));\r\n\tc->used = 0;\r\n}\r\n\r\n// connection close\ufffd\ufffd\ufffd\u024c\u0102\u0382\ufffd\ufffd\r\nvoid ssh2_channel_free(void)\r\n{\r\n\tint i;\r\n\tChannel_t *c;\r\n\r\n\tfor (i = 0 ; i < CHANNEL_MAX ; i++) {\r\n\t\tc = &channels[i];\r\n\t\tssh2_channel_delete(c);\r\n\t}\r\n}\r\n\r\nstatic Channel_t *ssh2_channel_lookup(int id)\r\n{\r\n\tChannel_t *c;\r\n\r\n\tif (id < 0 || id >= CHANNEL_MAX) {\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: invalid channel id. (%d)\", __FUNCTION__, id);\r\n\t\treturn (NULL);\r\n\t}\r\n\tc = &channels[id];\r\n\tif (c->used == 0) { // already freed\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: channel was already freed. id:%d\", __FUNCTION__, id);\r\n\t\treturn (NULL);\r\n\t}\r\n\treturn (c);\r\n}\r\n\r\n// SSH1\ufffd\u014a\u01d7\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffdchannel\ufffd\\\ufffd\ufffd\ufffd\u0302\ufffd\ufffd\ufffdASSH2\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdChannel_t\ufffd\u0595\u03ca\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n// TODO: \ufffd\ufffd\ufffd\ufffd\ufffdI\ufffd\u0242\u0343`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\\\ufffd\ufffd\ufffd\u0302\ufffd1\ufffd\u0082\u0253\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n// (2005.6.12 yutaka)\r\nChannel_t *ssh2_local_channel_lookup(int local_num)\r\n{\r\n\tint i;\r\n\tChannel_t *c;\r\n\r\n\tfor (i = 0 ; i < CHANNEL_MAX ; i++) {\r\n\t\tc = &channels[i];\r\n\t\tif (c->type != TYPE_PORTFWD)\r\n\t\t\tcontinue;\r\n\t\tif (c->local_num == local_num)\r\n\t\t\treturn (c);\r\n\t}\r\n\treturn (NULL);\r\n}\r\n\r\n//\r\n// SSH heartbeat mutex\r\n//\r\n// TTSSH\ufffd\ufffd thread-safe \ufffd\u0142\u0342\u0202\ufffd\ufffd\ufffd\ufffd\u07c1A\ufffd}\ufffd\ufffd\ufffd`\ufffdX\ufffd\ufffd\ufffdb\ufffdh\ufffd\ufffd\ufffd\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffdM\ufffd\u0342\u0142\ufffd\ufffd\u0202\ufffd\ufffdB\r\n// \ufffdV\ufffd\ufffd\ufffdO\ufffd\ufffd\ufffdX\ufffd\ufffd\ufffdb\ufffdh\ufffd\u0142\u0343R\ufffd\ufffd\ufffde\ufffdL\ufffdX\ufffdg\ufffdX\ufffdC\ufffdb\ufffd`\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u90b1\ufffd\u0182\u0342\u0202\ufffd\ufffd\ufffd\ufffd\u07c1A\r\n// \ufffd\ufffd\ufffdb\ufffdN\ufffd\ufffd\ufffd\ufffd\ufffdK\ufffdv\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffd\u07c1A\ufffd\ud3dc\ufffd\ufffd\ufffd\ufffdB(2007.12.26 yutaka)\r\n//\r\nstatic CRITICAL_SECTION g_ssh_heartbeat_lock;   /* \ufffd\ufffd\ufffd\ufffdM\ufffdp\ufffd\ufffd\ufffdb\ufffdN */\r\n\r\nvoid ssh_heartbeat_lock_initialize(void)\r\n{\r\n\t//InitializeCriticalSection(&g_ssh_heartbeat_lock);\r\n}\r\n\r\nvoid ssh_heartbeat_lock_finalize(void)\r\n{\r\n\t//DeleteCriticalSection(&g_ssh_heartbeat_lock);\r\n}\r\n\r\nvoid ssh_heartbeat_lock(void)\r\n{\r\n\t//EnterCriticalSection(&g_ssh_heartbeat_lock);\r\n}\r\n\r\nvoid ssh_heartbeat_unlock(void)\r\n{\r\n\t//LeaveCriticalSection(&g_ssh_heartbeat_lock);\r\n}\r\n\r\n//\r\n// SSH memory dump (for debug)\r\n//\r\n// (2005.3.7 yutaka)\r\n//\r\n#define MEMTAG_MAX 300\r\n#define LOGDUMP L\"ssh2connect.log\"\r\n#define LOG_PACKET_DUMP L\"ssh2packet.log\"\r\n#define SENDTOME L\"Please send '\" LOGDUMP L\"' file to Tera Term developer team.\"\r\n\r\ntypedef struct memtag {\r\n\tchar *name;\r\n\tchar *desc;\r\n\ttime_t time;\r\n\tint len;\r\n\tchar *data;\r\n} memtag_t;\r\n\r\nstatic memtag_t memtags[MEMTAG_MAX];\r\nstatic int memtag_count = 0;\r\nstatic int memtag_use = 0;\r\n\r\n/* \ufffd_\ufffd\ufffd\ufffdv\ufffd\ufffd\ufffdC\ufffd\ufffd\ufffd\ufffd\ufffdt\ufffdH\ufffd[\ufffd}\ufffdb\ufffdg\ufffd\\\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd */\r\nstatic void displine_memdump(FILE *fp, int addr, int *bytes, int byte_cnt)\r\n{\r\n\tint i, c;\r\n\r\n\t/* \ufffd\u64ea\ufffd\u0303A\ufffdh\ufffd\ufffd\ufffdX\ufffd\\\ufffd\ufffd */\r\n\tfprintf(fp, \"%08X : \", addr);\r\n\r\n\t/* \ufffdo\ufffdC\ufffdi\ufffd\ufffd\ufffd\\\ufffd\ufffd\ufffdi4\ufffdo\ufffdC\ufffdg\ufffd\ufffd\ufffd\u0182\u024b\udb11\udc82\ufffd}\ufffd\ufffd\ufffdj*/\r\n\tfor (i = 0 ; i < byte_cnt ; i++) {\r\n\t\tif (i > 0 && i % 4 == 0)\r\n\t\t\tfprintf(fp, \" \");\r\n\r\n\t\tfprintf(fp, \"%02X\", bytes[i]);\r\n\t}\r\n\r\n\t/* ASCII\ufffd\\\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0702\u0142\u030b\udb11\udc82\ufffd\u20a4 */\r\n\tfprintf(fp, \"   %*s%*s\", (16-byte_cnt)*2+1, \" \", (16-byte_cnt+3)/4, \" \");\r\n\r\n\t/* ASCII\ufffd\\\ufffd\ufffd */\r\n\tfor (i = 0 ; i < byte_cnt ; i++) {\r\n\t\tc = bytes[i];\r\n\t\tif (isprint(c)) {\r\n\t\t\tfprintf(fp, \"%c\", c);\r\n\t\t} else {\r\n\t\t\tfprintf(fp, \".\");\r\n\t\t}\r\n\t}\r\n\r\n\tfprintf(fp, \"\\n\");\r\n}\r\n\r\n\r\n/* \ufffd_\ufffd\ufffd\ufffdv\ufffd\ufffd\ufffd[\ufffd`\ufffd\ufffd */\r\nstatic void dump_memdump(FILE *fp, char *data, int len)\r\n{\r\n\tint c, addr;\r\n\tint bytes[16], *ptr;\r\n\tint byte_cnt;\r\n\tint i;\r\n\r\n\taddr = 0;\r\n\tbyte_cnt = 0;\r\n\tptr = bytes;\r\n\tfor (i = 0 ; i < len ; i++) {\r\n\t\tc = data[i];\r\n\t\t*ptr++ = c & 0xff;\r\n\t\tbyte_cnt++;\r\n\r\n\t\tif (byte_cnt == 16) {\r\n\t\t\tdispline_memdump(fp, addr, bytes, byte_cnt);\r\n\r\n\t\t\taddr += 16;\r\n\t\t\tbyte_cnt = 0;\r\n\t\t\tptr = bytes;\r\n\t\t}\r\n\t}\r\n\r\n\tif (byte_cnt > 0) {\r\n\t\tdispline_memdump(fp, addr, bytes, byte_cnt);\r\n\t}\r\n}\r\n\r\nvoid init_memdump(void)\r\n{\r\n\tint i;\r\n\r\n\tif (memtag_use > 0)\r\n\t\treturn;\r\n\r\n\tfor (i = 0 ; i < MEMTAG_MAX ; i++) {\r\n\t\tmemtags[i].name = NULL;\r\n\t\tmemtags[i].desc = NULL;\r\n\t\tmemtags[i].data = NULL;\r\n\t\tmemtags[i].len = 0;\r\n\t}\r\n\tmemtag_use++;\r\n}\r\n\r\nvoid finish_memdump(void)\r\n{\r\n\tint i;\r\n\r\n\t// initialize\ufffd\ufffd\ufffd\ufffd\u0102\u0202\ufffd\ufffd\u0182\ufffd\ufffd\u0349\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0256\u07c2\ufffdB(2005.4.3 yutaka)\r\n\tif (memtag_use <= 0)\r\n\t\treturn;\r\n\tmemtag_use--;\r\n\r\n\tfor (i = 0 ; i < MEMTAG_MAX ; i++) {\r\n\t\tfree(memtags[i].name);\r\n\t\tfree(memtags[i].desc);\r\n\t\tfree(memtags[i].data);\r\n\t\tmemtags[i].len = 0;\r\n\t}\r\n\tmemtag_count = 0;\r\n}\r\n\r\nvoid save_memdump(wchar_t *filename)\r\n{\r\n\tFILE *fp;\r\n\tint i;\r\n\ttime_t t;\r\n\tstruct tm *tm;\r\n\twchar_t *dumpfile = NULL;\r\n\r\n\tdumpfile = get_log_dir_relative_nameW(filename);\r\n\t_wfopen_s(&fp, dumpfile, L\"w\");\r\n\tfree(dumpfile);\r\n\tif (fp == NULL)\r\n\t\treturn;\r\n\r\n\tt = time(NULL);\r\n\ttm = localtime(&t);\r\n\r\n\tfprintf(fp, \"<<< Tera Term SSH2 log dump >>>\\n\");\r\n\tfprintf(fp, \"saved time: %04d/%02d/%02d %02d:%02d:%02d\\n\",\r\n\t        tm->tm_year + 1900,\r\n\t        tm->tm_mon + 1,\r\n\t        tm->tm_mday,\r\n\t        tm->tm_hour,\r\n\t        tm->tm_min,\r\n\t        tm->tm_sec);\r\n\tfprintf(fp, \"\\n\");\r\n\r\n\tfor (i = 0 ; i < memtag_count ; i++) {\r\n\t\tfprintf(fp, \"============================================\\n\");\r\n\t\tfprintf(fp, \"name: %s\\n\", memtags[i].name);\r\n\t\tfprintf(fp, \"--------------------------------------------\\n\");\r\n\t\tfprintf(fp, \"description: %s\\n\", memtags[i].desc);\r\n\t\tfprintf(fp, \"--------------------------------------------\\n\");\r\n\t\tfprintf(fp, \"time: %s\", ctime(&memtags[i].time));\r\n\t\tfprintf(fp, \"============================================\\n\");\r\n\t\tdump_memdump(fp, memtags[i].data, memtags[i].len);\r\n\t\tfprintf(fp, \"\\n\\n\\n\");\r\n\t}\r\n\r\n\tfprintf(fp, \"[EOF]\\n\");\r\n\r\n\tfclose(fp);\r\n}\r\n\r\nvoid push_memdump(char *name, char *desc, char *data, int len)\r\n{\r\n\tmemtag_t *ptr;\r\n\tchar *dp;\r\n\r\n\tdp = malloc(len);\r\n\tif (dp == NULL)\r\n\t\treturn;\r\n\tmemcpy(dp, data, len);\r\n\r\n\tif (memtag_count >= MEMTAG_MAX)\r\n\t\treturn;\r\n\r\n\tptr = &memtags[memtag_count];\r\n\tmemtag_count++;\r\n\tptr->name = _strdup(name);\r\n\tptr->desc = _strdup(desc);\r\n\tptr->time = time(NULL);\r\n\tptr->data = dp;\r\n\tptr->len = len;\r\n}\r\n\r\nvoid push_bignum_memdump(char *name, char *desc, BIGNUM *bignum)\r\n{\r\n\tint len;\r\n\tchar *buf;\r\n\r\n\tlen = BN_num_bytes(bignum);\r\n\tbuf = malloc(len); // allocate\r\n\tif (buf == NULL)\r\n\t\treturn;\r\n\tBN_bn2bin(bignum, buf);\r\n\tpush_memdump(name, desc, buf, len); // at push_bignum_memdump()\r\n\tfree(buf); // free\r\n}\r\n\r\nvoid log_kex_key(PTInstVar pvar, const BIGNUM *secret)\r\n{\r\n#ifdef _DEBUG\t// KEX logging\r\n\tint fd, i;\r\n\tunsigned char buff[4], *cookie;\r\n\tchar *hexstr;\r\n\twchar_t *fname;\r\n\r\n\tif (pvar->settings.KexKeyLogging && pvar->settings.KexKeyLogFile[0] != 0) {\r\n\t\thexstr = BN_bn2hex(secret);\r\n\t\tif (hexstr == NULL) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfname = get_log_dir_relative_nameW(pvar->settings.KexKeyLogFile);\r\n\t\tif (fname == NULL) {\r\n\t\t\tOPENSSL_free(hexstr);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfd = _wopen(fname,\r\n\t\t\t_O_RDWR | _O_APPEND | _O_CREAT | _O_TEXT,\r\n\t\t\t_S_IREAD | _S_IWRITE);\r\n\t\tif (fd >= 0) {\r\n\t\t\tcookie = pvar->crypt_state.client_cookie;\r\n\t\t\tfor (i=0; i<16; i++) {\r\n\t\t\t\t_snprintf_s(buff, sizeof(buff), _TRUNCATE, \"%02x\", cookie[i]);\r\n\t\t\t\t_write(fd, buff, 2);\r\n\t\t\t}\r\n\t\t\t_write(fd, \" \", 1);\r\n\t\t\t_write(fd, hexstr, strlen(hexstr));\r\n\t\t\t_write(fd, \"\\n\", 1);\r\n\t\t\t_close(fd);\r\n\t\t}\r\n\t\tfree(fname);\r\n\t\tOPENSSL_free(hexstr);\r\n\t}\r\n#endif\r\n}\r\n\r\nstatic unsigned int get_predecryption_amount(PTInstVar pvar)\r\n{\r\n\tstatic int small_block_decryption_sizes[] = { 5, 5, 6, 6, 8 };\r\n\r\n\tif (SSHv1(pvar)) {\r\n\t\treturn 0;\r\n\t} else {\r\n\t\tunsigned int block_size = CRYPT_get_decryption_block_size(pvar);\r\n\r\n\t\tif (block_size < 5) {\r\n\t\t\treturn small_block_decryption_sizes[block_size];\r\n\t\t} else {\r\n\t\t\treturn block_size;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/* Get up to 'limit' bytes into the payload buffer.\r\n   'limit' is counted from the start of the payload data.\r\n   Returns the amount of data in the payload buffer, or\r\n   -1 if there is an error.\r\n   We can return more than limit in some cases. */\r\nstatic int buffer_packet_data(PTInstVar pvar, int limit)\r\n{\r\n\tif (pvar->ssh_state.payloadlen >= 0) {\r\n\t\treturn pvar->ssh_state.payloadlen;\r\n\t} else {\r\n\t\tint cur_decompressed_bytes =\r\n\t\t\tpvar->ssh_state.decompress_stream.next_out - pvar->ssh_state.postdecompress_inbuf;\r\n\r\n\t\twhile (limit > cur_decompressed_bytes) {\r\n\t\t\tint result;\r\n\r\n\t\t\tpvar->ssh_state.payload = pvar->ssh_state.postdecompress_inbuf + 1;\r\n\t\t\tif (pvar->ssh_state.postdecompress_inbuflen == cur_decompressed_bytes) {\r\n\t\t\t\tbuf_ensure_size(&pvar->ssh_state.postdecompress_inbuf,\r\n\t\t\t\t                &pvar->ssh_state.postdecompress_inbuflen,\r\n\t\t\t\t                min(limit, cur_decompressed_bytes * 2));\r\n\t\t\t}\r\n\r\n\t\t\tpvar->ssh_state.decompress_stream.next_out =\r\n\t\t\t\tpvar->ssh_state.postdecompress_inbuf + cur_decompressed_bytes;\r\n\t\t\tpvar->ssh_state.decompress_stream.avail_out =\r\n\t\t\t\tmin(limit, pvar->ssh_state.postdecompress_inbuflen) - cur_decompressed_bytes;\r\n\r\n\t\t\tresult = inflate(&pvar->ssh_state.decompress_stream, Z_SYNC_FLUSH);\r\n\t\t\tcur_decompressed_bytes =\r\n\t\t\t\tpvar->ssh_state.decompress_stream.next_out - pvar->ssh_state.postdecompress_inbuf;\r\n\r\n\t\t\tswitch (result) {\r\n\t\t\tcase Z_OK:\r\n\t\t\t\tbreak;\r\n\t\t\tcase Z_BUF_ERROR:\r\n\t\t\t\tpvar->ssh_state.payloadlen = cur_decompressed_bytes;\r\n\t\t\t\treturn cur_decompressed_bytes;\r\n\t\t\tdefault:\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_INVALID_COMPDATA_ERROR\", pvar,\r\n\t\t\t\t                  \"Invalid compressed data in received packet\");\r\n\t\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\t\treturn -1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn cur_decompressed_bytes;\r\n\t}\r\n}\r\n\r\n/* For use by the protocol processing code.\r\n   Gets N bytes of uncompressed payload. Returns FALSE if data not available\r\n   and a fatal error has been signaled.\r\n   The data is available in the payload buffer. This buffer address\r\n   can change during a call to grab_payload, so take care!\r\n   The payload pointer is set to point to the first byte of the actual data\r\n   (after the packet type byte).\r\n*/\r\nstatic BOOL grab_payload(PTInstVar pvar, int num_bytes)\r\n{\r\n\t/* Accept maximum of 4MB of payload data */\r\n\tint in_buffer = buffer_packet_data(pvar, PACKET_MAX_SIZE);\r\n\r\n\tif (in_buffer < 0) {\r\n\t\treturn FALSE;\r\n\t} else {\r\n\t\tpvar->ssh_state.payload_grabbed += num_bytes;\r\n\t\tif (pvar->ssh_state.payload_grabbed > in_buffer) {\r\n\t\t\tchar buf[128];\r\n\t\t\tUTIL_get_lang_msg(\"MSG_SSH_TRUNCATED_PKT_ERROR\", pvar,\r\n\t\t\t                  \"Received truncated packet (%ld > %d) @ grab_payload()\");\r\n\t\t\t_snprintf_s(buf, sizeof(buf), _TRUNCATE, pvar->UIMsg,\r\n\t\t\t            pvar->ssh_state.payload_grabbed, in_buffer);\r\n\t\t\tnotify_fatal_error(pvar, buf, TRUE);\r\n\t\t\treturn FALSE;\r\n\t\t} else {\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstatic BOOL grab_payload_limited(PTInstVar pvar, int num_bytes)\r\n{\r\n\tint in_buffer;\r\n\r\n\tpvar->ssh_state.payload_grabbed += num_bytes;\r\n\tin_buffer = buffer_packet_data(pvar, pvar->ssh_state.payload_grabbed);\r\n\r\n\tif (in_buffer < 0) {\r\n\t\treturn FALSE;\r\n\t} else {\r\n\t\tif (pvar->ssh_state.payload_grabbed > in_buffer) {\r\n\t\t\tchar buf[128];\r\n\t\t\tUTIL_get_lang_msg(\"MSG_SSH_TRUNCATED_PKT_LIM_ERROR\", pvar,\r\n\t\t\t                  \"Received truncated packet (%ld > %d) @ grab_payload_limited()\");\r\n\t\t\t_snprintf_s(buf, sizeof(buf), _TRUNCATE, pvar->UIMsg,\r\n\t\t\t            pvar->ssh_state.payload_grabbed, in_buffer);\r\n\t\t\tnotify_fatal_error(pvar, buf, TRUE);\r\n\t\t\treturn FALSE;\r\n\t\t} else {\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstatic PayloadStat get_byte_from_payload(PTInstVar pvar, unsigned char *val)\r\n{\r\n\tunsigned char *data;\r\n\r\n\tdata = remained_payload(pvar);\r\n\tif (!grab_payload(pvar, 1)) {\r\n\t\treturn GetPayloadError;\r\n\t}\r\n\r\n\t*val = *data;\r\n\treturn GetPayloadOK;\r\n}\r\n#define get_boolean_from_payload(pvar, val) get_byte_from_payload(pvar, val)\r\n\r\nstatic PayloadStat get_bytearray_from_payload(PTInstVar pvar, unsigned char *buff, unsigned int len)\r\n{\r\n\tunsigned char *data;\r\n\r\n\tdata = remained_payload(pvar);\r\n\tif (!grab_payload(pvar, len)) {\r\n\t\treturn GetPayloadError;\r\n\t}\r\n\r\n\tmemcpy_s(buff, len, data, len);\r\n\treturn GetPayloadOK;\r\n}\r\n\r\nstatic PayloadStat get_uint32_from_payload(PTInstVar pvar, unsigned int *val)\r\n{\r\n\tunsigned char *data;\r\n\r\n\tdata = remained_payload(pvar);\r\n\tif (!grab_payload(pvar, 4)) {\r\n\t\treturn  GetPayloadError;\r\n\t}\r\n\r\n\t*val = get_uint32(data);\r\n\treturn GetPayloadOK;\r\n}\r\n\r\nstatic PayloadStat get_string_from_payload(\r\n\tPTInstVar pvar, unsigned char *buff, unsigned int bufflen, unsigned int *len, BOOL null_terminate)\r\n{\r\n\tunsigned int size;\r\n\tunsigned char *data;\r\n\r\n\tif (!get_uint32_from_payload(pvar, &size)) {\r\n\t\treturn GetPayloadError;\r\n\t}\r\n\r\n\tdata = remained_payload(pvar);\r\n\tif (!grab_payload(pvar, size)) {\r\n\t\treturn GetPayloadError;\r\n\t}\r\n\r\n\t*len = size;\r\n\r\n\tif (size < bufflen) {\r\n\t\tmemcpy_s(buff, bufflen, data, size);\r\n\t\tif (null_terminate) {\r\n\t\t\tbuff[size] = 0;\r\n\t\t}\r\n\t\treturn GetPayloadOK;\r\n\t}\r\n\telse if (size == bufflen) {\r\n\t\tmemcpy_s(buff, bufflen, data, bufflen);\r\n\t\tif (null_terminate) {\r\n\t\t\tbuff[bufflen-1] = 0;\r\n\t\t\treturn GetPayloadTruncate;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn GetPayloadOK;\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\tmemcpy_s(buff, bufflen, data, bufflen);\r\n\t\tif (null_terminate) {\r\n\t\t\tbuff[bufflen-1] = 0;\r\n\t\t}\r\n\t\treturn GetPayloadTruncate;\r\n\t}\r\n}\r\n#define get_namelist_from_payload(pvar, buff, bufflen, size) get_string_from_payload(pvar, buff, bufflen, size, TRUE)\r\n\r\nstatic PayloadStat get_mpint_from_payload(PTInstVar pvar, BIGNUM *bn)\r\n{\r\n\tunsigned int len;\r\n\tunsigned char *data;\r\n\r\n\tif (!get_uint32_from_payload(pvar, &len)) {\r\n\t\treturn GetPayloadError;\r\n\t}\r\n\r\n\tdata = remained_payload(pvar);\r\n\tif (!grab_payload(pvar, len)) {\r\n\t\treturn GetPayloadError;\r\n\t}\r\n\r\n\tBN_bin2bn(data, len, bn);\r\n\r\n\treturn GetPayloadOK;\r\n}\r\n\r\n#define do_crc(buf, len) (~(uint32)crc32(0xFFFFFFFF, (buf), (len)))\r\n\r\n/*\r\n * Decrypt the payload, checksum it, eat the padding, get the packet type and return it.\r\n * 'data' points to the start of the packet --- its length field.\r\n * 'len' is the length of the * payload + padding (+ length of CRC for SSHv1).\r\n * 'padding' is the length of the padding alone.\r\n */\r\nstatic int prep_packet_ssh1(PTInstVar pvar, char *data, unsigned int len, unsigned int padding)\r\n{\r\n\tpvar->ssh_state.payload = data + 4;\r\n\tpvar->ssh_state.payloadlen = len;\r\n\r\n\tif (CRYPT_detect_attack(pvar, pvar->ssh_state.payload, len)) {\r\n\t\tUTIL_get_lang_msg(\"MSG_SSH_COREINS_ERROR\", pvar, \"'CORE insertion attack' detected.  Aborting connection.\");\r\n\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t}\r\n\r\n\tCRYPT_decrypt(pvar, pvar->ssh_state.payload, len);\r\n\t/* PKT guarantees that the data is always 4-byte aligned */\r\n\tif (do_crc(pvar->ssh_state.payload, len - 4) != get_uint32_MSBfirst(pvar->ssh_state.payload + len - 4)) {\r\n\t\tUTIL_get_lang_msg(\"MSG_SSH_CORRUPTDATA_ERROR\", pvar, \"Detected corrupted data; connection terminating.\");\r\n\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\treturn SSH_MSG_NONE;\r\n\t}\r\n\r\n\tpvar->ssh_state.payload += padding;\r\n\tpvar->ssh_state.payloadlen -= padding + 4;\r\n\r\n\tpvar->ssh_state.payload_grabbed = 0;\r\n\r\n\tif (pvar->ssh_state.decompressing) {\r\n\t\tif (pvar->ssh_state.decompress_stream.avail_in != 0) {\r\n\t\t\tUTIL_get_lang_msg(\"MSG_SSH_DECOMPRESS_ERROR\", pvar,\r\n\t\t\t                  \"Internal error: a packet was not fully decompressed.\\n\"\r\n\t\t\t                  \"This is a bug, please report it.\");\r\n\t\t\tnotify_nonfatal_error(pvar, pvar->UIMsg);\r\n\t\t}\r\n\r\n\t\tpvar->ssh_state.decompress_stream.next_in = pvar->ssh_state.payload;\r\n\t\tpvar->ssh_state.decompress_stream.avail_in = pvar->ssh_state.payloadlen;\r\n\t\tpvar->ssh_state.decompress_stream.next_out = pvar->ssh_state.postdecompress_inbuf;\r\n\t\tpvar->ssh_state.payloadlen = -1;\r\n\t} else {\r\n\t\tpvar->ssh_state.payload++;\r\n\t}\r\n\r\n\tif (!grab_payload_limited(pvar, 1)) {\r\n\t\treturn SSH_MSG_NONE;\r\n\t}\r\n\r\n\tpvar->ssh_state.receiver_sequence_number++;\r\n\r\n\treturn pvar->ssh_state.payload[-1];\r\n}\r\n\r\n/*\r\n * \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\u0308\u05c2\u0308\u0209\ufffd\ufffd\u030f\ufffd\ufffd\ufffd\ufffd\ufffd\ufffds\ufffd\ufffd\ufffdB(SSHv2\ufffdp)\r\n * \ufffdE\ufffdf\ufffd[\ufffd^\ufffd\ufffd\ufffd\ufffd\r\n * \ufffdEMAC \ufffd\u030c\ufffd\ufffd\ufffd\r\n * \ufffdEpadding \ufffd\ufffd\ufffd\ufffd\u83dc\ufffd\ufffd\r\n * \ufffdE\ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd^\ufffdC\ufffdv\ufffd\ud813\uded5\u0282\ufffd\ufffd\u0115\u0502\ufffd\r\n *\r\n * \ufffd\ufffd\ufffd\ufffd:\r\n *   data - ssh \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\u0310\u64ea\ufffd\ufffd\ufffdw\ufffd\ufffd\ufffd|\ufffdC\ufffd\ufffd\ufffd^\r\n *   len - \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd (\ufffd\u64ea\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffd\u0308\ufffd(4\ufffdo\ufffdC\ufffdg)\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdl)\r\n *   aadlen - \ufffd\u00cd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffdF\ufffd\u0602\u0311\u038f\u06c2\u0182\u0202\ufffd\ufffd\u0102\ufffd\ufffd\ufffdf\ufffd[\ufffd^\ufffd\u0312\ufffd\ufffd\ufffd\r\n *            chacha20-poly1305 \ufffd\u0142\u0348\u00cd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0312\ufffd\ufffd\ufffd\r\n *   authlen - \ufffdF\ufffd\u0603f\ufffd[\ufffd^(AEAD tag)\ufffd\ufffd\r\n */\r\n\r\nstatic int prep_packet_ssh2(PTInstVar pvar, char *data, unsigned int len, unsigned int aadlen, unsigned int authlen)\r\n{\r\n\tunsigned int padding;\r\n\r\n\tif (authlen > 0) {\r\n\t\tif (!CRYPT_decrypt_aead(pvar, data, len, aadlen, authlen)) {\r\n\t\t\tUTIL_get_lang_msg(\"MSG_SSH_CORRUPTDATA_ERROR\", pvar, \"Detected corrupted data; connection terminating.\");\r\n\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\treturn SSH_MSG_NONE;\r\n\t\t}\r\n\t}\r\n\telse if (aadlen > 0) {\r\n\t\t// EtM \ufffd\u030f\ua347\ufffd\u0350\ufffd\ufffd MAC \ufffd\u030c\ufffd\ufffd\u0602\ufffd\ufffds\ufffd\ufffd\r\n\t\tif (!CRYPT_verify_receiver_MAC(pvar, pvar->ssh_state.receiver_sequence_number, data, len + 4, data + len + 4)) {\r\n\t\t\tUTIL_get_lang_msg(\"MSG_SSH_CORRUPTDATA_ERROR\", pvar, \"Detected corrupted data; connection terminating.\");\r\n\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\treturn SSH_MSG_NONE;\r\n\t\t}\r\n\r\n\t\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd(\ufffd\u64ea4\ufffdo\ufffdC\ufffdg)\ufffd\u0348\u00cd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0202\ufffd\ufffd\u0302\u0141A\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdX\ufffdL\ufffdb\ufffdv\ufffd\ufffd\ufffd\u0115\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\tCRYPT_decrypt(pvar, data + 4, len);\r\n\t}\r\n\telse {\r\n\t\t// E&M \ufffd\u0142\u0350\u64ea\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdO\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffdB\r\n\t\t// \ufffd\ufffd\ufffdO\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ua0bd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u64fe\ufffd\ufffd\ufffd\ufffdB\r\n\t\tunsigned int already_decrypted = get_predecryption_amount(pvar);\r\n\r\n\t\t// \ufffd\ufffd\ufffdO\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ua0bd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdX\ufffdL\ufffdb\ufffdv\ufffd\ufffd\ufffd\u0101A\ufffdc\ufffd\ufffd\u0315\ufffd\ufffd\ufffd\ufffd\ud815\udf0d\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\tCRYPT_decrypt(pvar, data + already_decrypted, (4 + len) - already_decrypted);\r\n\r\n\t\t// E&M \ufffd\u0142\u0355\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd MAC \ufffd\u030c\ufffd\ufffd\u0602\ufffd\ufffds\ufffd\ufffd\ufffdB\r\n\t\tif (!CRYPT_verify_receiver_MAC(pvar, pvar->ssh_state.receiver_sequence_number, data, len + 4, data + len + 4)) {\r\n\t\t\tUTIL_get_lang_msg(\"MSG_SSH_CORRUPTDATA_ERROR\", pvar, \"Detected corrupted data; connection terminating.\");\r\n\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\treturn SSH_MSG_NONE;\r\n\t\t}\r\n\t}\r\n\r\n\t// \ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd\ufffd\ufffd\u030e\u64fe\r\n\tpadding = (unsigned int) data[4];\r\n\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd(4\ufffdo\ufffdC\ufffdg) \ufffd\ufffd\ufffd\ufffd\ufffd\u0183p\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd\ufffd(1\ufffdo\ufffdC\ufffdg)\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdX\ufffdL\ufffdb\ufffdv\ufffd\ufffd\ufffd\ufffd SSH \ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\u0310\u64ea\r\n\tpvar->ssh_state.payload = data + 4 + 1;\r\n\r\n\t// \ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd(1\ufffdo\ufffdC\ufffdg)\ufffd\u0183p\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u06c2\u0303y\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\ufffd\r\n\tpvar->ssh_state.payloadlen = len - 1 - padding;\r\n\r\n\tpvar->ssh_state.payload_grabbed = 0;\r\n\r\n\t// data compression\r\n\tif (pvar->ssh2_keys[MODE_IN].comp.enabled &&\r\n\t   (pvar->stoc_compression == COMP_ZLIB ||\r\n\t    pvar->stoc_compression == COMP_DELAYED && pvar->userauth_success)) {\r\n\r\n\t\tif (pvar->decomp_buffer == NULL) {\r\n\t\t\tpvar->decomp_buffer = buffer_init();\r\n\t\t\tif (pvar->decomp_buffer == NULL)\r\n\t\t\t\treturn SSH_MSG_NONE;\r\n\t\t}\r\n\t\t// \ufffd\ufffdx\ufffdm\ufffd\u06c2\ufffd\ufffd\ufffd\ufffdo\ufffdb\ufffdt\ufffd@\ufffd\u034eg\ufffd\ufffd\ufffd\ud8cb\uddc2\u0302\u014f\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdY\ufffd\ua0b8\ufffd\u0241B\r\n\t\tbuffer_clear(pvar->decomp_buffer);\r\n\r\n\t\t// packet size\ufffd\ufffdpadding\ufffd\ufffd\ufffd\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0742\ufffdW\ufffdJ\ufffd\ufffd\ufffd\ufffdB\r\n\t\tbuffer_decompress(&pvar->ssh_state.decompress_stream,\r\n\t\t                  pvar->ssh_state.payload,\r\n\t\t                  pvar->ssh_state.payloadlen,\r\n\t\t                  pvar->decomp_buffer);\r\n\r\n\t\t// \ufffd|\ufffdC\ufffd\ufffd\ufffd^\ufffd\u030dX\ufffdV\ufffdB\r\n\t\tpvar->ssh_state.payload = buffer_ptr(pvar->decomp_buffer);\r\n\t\tpvar->ssh_state.payload++;\r\n\t\tpvar->ssh_state.payloadlen = buffer_len(pvar->decomp_buffer);\r\n\t} else {\r\n\t\tpvar->ssh_state.payload++;\r\n\t}\r\n\r\n\tif (!grab_payload_limited(pvar, 1)) {\r\n\t\treturn SSH_MSG_NONE;\r\n\t}\r\n\r\n\tpvar->ssh_state.receiver_sequence_number++;\r\n\r\n\treturn pvar->ssh_state.payload[-1];\r\n}\r\n\r\n/* Create a packet to be sent. The SSH protocol packet type is in 'type';\r\n   'len' contains the length of the packet payload, in bytes (this\r\n   does not include the space for any of the packet headers or padding,\r\n   or for the packet type byte).\r\n   Returns a pointer to the payload data area, a region of length 'len',\r\n   to be filled by the caller. */\r\nunsigned char *begin_send_packet(PTInstVar pvar, int type, int len)\r\n{\r\n\tunsigned char *buf;\r\n\r\n\tpvar->ssh_state.outgoing_packet_len = len + 1;\r\n\r\n\tif (pvar->ssh_state.compressing) {\r\n\t\tbuf_ensure_size(&pvar->ssh_state.precompress_outbuf,\r\n\t\t                &pvar->ssh_state.precompress_outbuflen, 1 + len);\r\n\t\tbuf = pvar->ssh_state.precompress_outbuf;\r\n\t} else {\r\n\t\t/* For SSHv2,\r\n\t\t   Encrypted_length is 4(packetlength) + 1(paddinglength) + 1(packettype)\r\n\t\t   + len(payload) + 4(minpadding), rounded up to nearest block_size\r\n\t\t   We only need a reasonable upper bound for the buffer size */\r\n\t\tbuf_ensure_size(&pvar->ssh_state.outbuf,\r\n\t\t                &pvar->ssh_state.outbuflen,\r\n\t\t                (int)(len + 30 + CRYPT_get_sender_MAC_size(pvar) +\r\n\t\t                CRYPT_get_encryption_block_size(pvar)));\r\n\t\tbuf = pvar->ssh_state.outbuf + 12;\r\n\t}\r\n\r\n\tbuf[0] = (unsigned char) type;\r\n\treturn buf + 1;\r\n}\r\n\r\n\r\n// \ufffd\ufffd\ufffdM\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffdC\ufffd\u0590\ufffd\ufffd\u0312\u01c9\ufffd\r\n//\r\n// WinSock\ufffd\ufffd send() \ufffd\u0343o\ufffdb\ufffdt\ufffd@\ufffdT\ufffdC\ufffdY(len)\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffdl\ufffd\ud803\udccf\ud39e\ufffd\u0255\u0502\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\r\n// \ufffd\ufffd\ufffd\u0182\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\ufffd\ufffd\u030f\ua347\ufffd\u0343G\ufffd\ufffd\ufffd[\ufffd\u0182\ufffd\ufffd\u0202\ufffd\ufffdB\r\n// \ufffd\ufffd\ufffd\ufffd\u0242\ufffd\ufffdATCP\ufffdR\ufffdl\ufffdN\ufffdV\ufffd\ufffd\ufffd\ufffd\ufffd\u0612f\ufffd\u030c\ub31f\ufffdo\ufffd\ufffdh\ufffd\ufffd\ufffdB\r\n// (2006.12.9 yutaka)\r\nstatic int retry_send_packet(PTInstVar pvar, char *data, int len)\r\n{\r\n\tint n;\r\n\tint err;\r\n\r\n\twhile (len > 0) {\r\n\t\tn = (pvar->Psend)(pvar->socket, data, len, 0);\r\n\r\n\t\tif (n < 0) {\r\n\t\t\terr = WSAGetLastError();\r\n\t\t\tif (err < WSABASEERR || err == WSAEWOULDBLOCK) {\r\n\t\t\t\t// send()\ufffd\u0315\u0512l\ufffd\ufffd0\ufffd\ufffd\ufffd\ufffd\ufffd\u0141A\ufffd\ufffd\ufffd\u0083G\ufffd\ufffd\ufffd[\ufffd\u050d\ufffd\ufffd\ufffd 10000 \ufffd\ufffd\ufffd\ufffd\ufffd\u030f\ua347\ufffd\u0341A\r\n\t\t\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u018c\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t\t\t\t// PuTTY 0.58\ufffd\u030e\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdQ\ufffdl\ufffdB\r\n\t\t\t\t// (2007.2.4 yutak)\r\n\t\t\t\treturn 0; // success\r\n\t\t\t}\r\n\t\t\treturn 1; // error\r\n\t\t}\r\n\r\n\t\tlen -= n;\r\n\t\tdata += n;\r\n\t}\r\n\r\n\treturn 0; // success\r\n}\r\n\r\nstatic BOOL send_packet_blocking(PTInstVar pvar, char *data, int len)\r\n{\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffdM\ufffd\ufffd\u0243o\ufffdb\ufffdt\ufffd@\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffd\u0702\ud0b7\ufffd\ufffd\ufffd\u07c1A\ufffdu\ufffd\ufffd\ufffdb\ufffdL\ufffd\ufffd\ufffdO\ufffd\u0151\ufffd\ufffdM\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0702\ufffd\ufffdK\ufffdv\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t// \ufffdm\ufffd\ufffd\ufffdu\ufffd\ufffd\ufffdb\ufffdL\ufffd\ufffd\ufffdO\ufffd\u0151\ufffd\ufffdM\ufffd\ufffd\ufffd\ufffdWSAEWOULDBLOCK\ufffd\ufffd\ufffd\u0502\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffd\ua347\ufffdA\ufffd\ufffd\ufffd\u0303o\ufffdb\ufffdt\ufffd@\ufffd\u0351\ufffd\ufffdM\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\t// \ufffd\u0702\u0155\u06ce\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\u0102\u0342\u0202\ufffd\u0202\ufffd\ufffdB(2007.10.30 yutaka)\r\n\tu_long do_block = 0;\r\n\tint code = 0;\r\n\tchar *kind = NULL, buf[256];\r\n\r\n\tif ((pvar->PWSAAsyncSelect) (pvar->socket, pvar->NotificationWindow, 0, 0) == SOCKET_ERROR) {\r\n\t\tcode = WSAGetLastError();\r\n\t\tkind = \"WSAAsyncSelect1\";\r\n\t\tgoto error;\r\n\t}\r\n\tif (ioctlsocket(pvar->socket, FIONBIO, &do_block) == SOCKET_ERROR) {\r\n\t\tcode = WSAGetLastError();\r\n\t\tkind = \"ioctlsocket\";\r\n\t\tgoto error;\r\n\t}\r\n\tif (retry_send_packet(pvar, data, len) != 0) {\r\n\t\tcode = WSAGetLastError();\r\n\t\tkind = \"retry_send_packet\";\r\n\t\tgoto error;\r\n\t}\r\n\tif ((pvar->PWSAAsyncSelect) (pvar->socket, pvar->NotificationWindow,\r\n\t                             pvar->notification_msg,\r\n\t                             pvar->notification_events) == SOCKET_ERROR) {\r\n\t\tcode = WSAGetLastError();\r\n\t\tkind = \"WSAAsyncSelect2\";\r\n\t\tgoto error;\r\n\t}\r\n\treturn TRUE;\r\n\r\nerror:\r\n\tUTIL_get_lang_msg(\"MSG_SSH_SEND_PKT_ERROR\", pvar,\r\n\t                  \"A communications error occurred while sending an SSH packet.\\n\"\r\n\t                  \"The connection will close. (%s:%d)\");\r\n\t_snprintf_s(buf, sizeof(buf), _TRUNCATE, pvar->UIMsg,\r\n\t            kind, code);\r\n\tnotify_fatal_error(pvar, buf, TRUE);\r\n\treturn FALSE;\r\n}\r\n\r\n/* if skip_compress is true, then the data has already been compressed\r\n   into outbuf + 12 */\r\nvoid finish_send_packet_special(PTInstVar pvar, int skip_compress)\r\n{\r\n\tunsigned int len = pvar->ssh_state.outgoing_packet_len;\r\n\tunsigned char *data;\r\n\tunsigned int data_length;\r\n\tbuffer_t *msg = NULL; // for SSH2 packet compression\r\n\r\n\tif (pvar->ssh_state.compressing) {\r\n\t\tif (!skip_compress) {\r\n\t\t\tbuf_ensure_size(&pvar->ssh_state.outbuf,\r\n\t\t\t                &pvar->ssh_state.outbuflen,\r\n\t\t\t                (int)(len + (len >> 6) + 50 + CRYPT_get_sender_MAC_size(pvar)));\r\n\t\t\tpvar->ssh_state.compress_stream.next_in = pvar->ssh_state.precompress_outbuf;\r\n\t\t\tpvar->ssh_state.compress_stream.avail_in = len;\r\n\t\t\tpvar->ssh_state.compress_stream.next_out = pvar->ssh_state.outbuf + 12;\r\n\t\t\tpvar->ssh_state.compress_stream.avail_out = pvar->ssh_state.outbuflen - 12;\r\n\r\n\t\t\tif (deflate(&pvar->ssh_state.compress_stream, Z_SYNC_FLUSH) != Z_OK) {\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_COMP_ERROR\", pvar,\r\n\t\t\t\t                  \"An error occurred while compressing packet data.\\n\"\r\n\t\t\t\t                  \"The connection will close.\");\r\n\t\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlen = pvar->ssh_state.outbuflen - 12 - pvar->ssh_state.compress_stream.avail_out;\r\n\t}\r\n\r\n\tif (SSHv1(pvar)) {\r\n\t\tunsigned int padding = 8 - ((len + 4) % 8);\r\n\r\n\t\tdata = pvar->ssh_state.outbuf + 8 - padding;\r\n\t\tdata_length = padding + len + 8;\r\n\r\n\t\tset_uint32(data, len + 4);\r\n\t\tif (CRYPT_get_receiver_cipher(pvar) != SSH_CIPHER_NONE) {\r\n\t\t\tCRYPT_set_random_data(pvar, data + 4, padding);\r\n\t\t} else {\r\n\t\t\tmemset(data + 4, 0, padding);\r\n\t\t}\r\n\t\tset_uint32(data + data_length - 4, do_crc(data + 4, data_length - 8));\r\n\t\tCRYPT_encrypt(pvar, data + 4, data_length - 4);\r\n\t} else { //for SSH2(yutaka)\r\n\t\tunsigned int block_size = CRYPT_get_encryption_block_size(pvar);\r\n\t\tunsigned int packet_length;\r\n\t\tunsigned int encryption_size;\r\n\t\tunsigned int padding_size;\r\n\t\tBOOL ret;\r\n\t\tstruct Mac *mac = &pvar->ssh2_keys[MODE_OUT].mac;\r\n\t\tstruct Enc *enc = &pvar->ssh2_keys[MODE_OUT].enc;\r\n\t\tunsigned int aadlen = 0, maclen = 0, authlen = 0;\r\n\r\n\t\t/*\r\n\t\t \ufffdf\ufffd[\ufffd^\ufffd\\\ufffd\ufffd\r\n\t\t pvar->ssh_state.outbuf:\r\n\t\t offset: 0 1 2 3 4 5 6 7 8 9 10 11 12 ...         EOD\r\n\t\t         <--ignore---> ^^^^^^^^    <---- payload --->\r\n\t\t                       packet length\r\n\r\n\t\t                                ^^padding_size\r\n\r\n\t\t                       <---------------------------->\r\n\t\t                          SSH2 sending data on TCP\r\n\r\n\t\t NOTE:\r\n\t\t   payload = type(1) + raw-data\r\n\t\t   len = ssh_state.outgoing_packet_len = payload size\r\n\t\t */\r\n\t\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffdk\ufffd\ufffd\ufffdL\ufffd\ufffd\ufffd\u030f\ua347\ufffdA\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffdk\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u7457\ufffdM\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffd\\\ufffdz\ufffd\ufffd\ufffd\ufffdB(2005.7.9 yutaka)\r\n\t\t// support of \"Compression delayed\" (2006.6.23 maya)\r\n\t\tif ((pvar->ctos_compression == COMP_ZLIB ||\r\n\t\t     pvar->ctos_compression == COMP_DELAYED && pvar->userauth_success) &&\r\n\t\t    pvar->ssh2_keys[MODE_OUT].comp.enabled) {\r\n\t\t\t// \ufffd\ufffd\ufffd\u0303o\ufffdb\ufffdt\ufffd@\ufffd\ufffd packet-length(4) + padding(1) + payload(any) \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\t\tmsg = buffer_init();\r\n\t\t\tif (msg == NULL) {\r\n\t\t\t\t// TODO: error check\r\n\t\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// \ufffd\ufffd\ufffdk\ufffd\u038f\u06c2\u0343w\ufffdb\ufffd_\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\u0302\u0741B\r\n\t\t\tbuffer_append(msg, \"\\0\\0\\0\\0\\0\", 5);  // 5 = packet-length(4) + padding(1)\r\n\t\t\tif (buffer_compress(&pvar->ssh_state.compress_stream, pvar->ssh_state.outbuf + 12, len, msg) == -1) {\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_COMP_ERROR\", pvar,\r\n\t\t\t\t                  \"An error occurred while compressing packet data.\\n\"\r\n\t\t\t\t                  \"The connection will close.\");\r\n\t\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tdata = buffer_ptr(msg);\r\n\t\t\tlen = buffer_len(msg) - 5;  // 'len' is overwritten.\r\n\r\n\t\t} else {\r\n\t\t\t// \ufffd\ufffd\ufffd\ufffd\ufffdk\r\n\t\t\tdata = pvar->ssh_state.outbuf + 7;\r\n\t\t}\r\n\r\n\t\t// \ufffd\ufffd\ufffdM\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\\\ufffdz(input parameter: data, len)\r\n\t\tif (block_size < 8) {\r\n\t\t\tblock_size = 8;\r\n\t\t}\r\n\r\n\t\tif (enc) {\r\n\t\t\tauthlen = enc->auth_len;\r\n\t\t}\r\n\r\n\t\tif (mac && mac->etm || authlen > 0) {\r\n\t\t\t// \ufffd\u00cd\ufffd\ufffd\ufffd\ufffd\u038f\u06c2\u0142\u0342\u0202\ufffd\ufffd\ufffd\ufffdAMAC \ufffd\u0311\u038f\u06c2\u0182\u0202\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0312\ufffd\ufffd\ufffd\r\n\t\t\t// \ufffd\u0702\ufffd\ufffd\ufffd chacha20-poly1305 \ufffd\u0148\u00cd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0312\ufffd\ufffd\ufffd\r\n\t\t\t// cf. PKT_recv \ufffd\ufffd\ufffd\u0303R\ufffd\ufffd\ufffd\ufffd\ufffdg\r\n\t\t\taadlen = 4;\r\n\t\t}\r\n\r\n\t\tpacket_length = 1 + len; // \ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd\ufffd\ufffd\u0303T\ufffdC\ufffdY + \ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\ufffd\r\n\t\tencryption_size = 4 + packet_length - aadlen; // \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffd\u0303T\ufffdC\ufffdY + packet_length - addlen\r\n\t\tpadding_size = block_size - (encryption_size % block_size);\r\n\t\tif (padding_size < 4)\r\n\t\t\tpadding_size += block_size;\r\n\t\tpacket_length += padding_size;\r\n\t\tencryption_size += padding_size;\r\n\t\tset_uint32(data, packet_length);\r\n\t\tdata[4] = (unsigned char) padding_size;\r\n\t\tif (msg) {\r\n\t\t\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffdk\ufffd\u030f\ua347\ufffdA\ufffdo\ufffdb\ufffdt\ufffd@\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB(2011.6.10 yutaka)\r\n\t\t\tbuffer_append_space(msg, padding_size + EVP_MAX_MD_SIZE);\r\n\t\t\t// realloc()\ufffd\ufffd\ufffd\ufffd\ufffd\u0181A\ufffd|\ufffdC\ufffd\ufffd\ufffd^\ufffd\ufffd\ufffd\u03c2\ufffd\ufffd\u0094\\\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\u0113x\ufffd\ufffd\u84bc\ufffd\ufffd\ufffdB\r\n\t\t\tdata = buffer_ptr(msg);\r\n\t\t}\r\n\r\n\t\tCRYPT_set_random_data(pvar, data + 5 + len, padding_size);\r\n\r\n\t\tif (authlen > 0) {\r\n\t\t\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\u00cd\ufffd\ufffd\ufffd\ufffd\ufffd MAC \ufffd\u030cv\ufffdZ\r\n\t\t\tCRYPT_encrypt_aead(pvar, data, encryption_size, aadlen, authlen);\r\n\t\t\tmaclen = authlen;\r\n\t\t}\r\n\t\telse if (aadlen) {\r\n\t\t\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\u00cd\ufffd\ufffd\ufffd\ufffdiaadlen\ufffd\ufffd\ufffd\ufffd\ub0be\ufffd\ufffd\ufffdj\r\n\t\t\tCRYPT_encrypt(pvar, data + aadlen, encryption_size);\r\n\r\n\t\t\t// EtM \ufffd\u0142\u0348\u00cd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd MAC \ufffd\ufffd\ufffdv\ufffdZ\ufffd\ufffd\ufffd\ufffd\r\n\t\t\tret = CRYPT_build_sender_MAC(pvar, pvar->ssh_state.sender_sequence_number,\r\n\t\t\t                             data, aadlen + encryption_size, data + aadlen + encryption_size);\r\n\t\t\tif (ret) {\r\n\t\t\t\tmaclen = CRYPT_get_sender_MAC_size(pvar);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// E&M \ufffd\u0142\u0348\u00cd\ufffd\ufffd\ufffd\ufffdO\ufffd\ufffd MAC \ufffd\ufffd\ufffdv\ufffdZ\ufffd\ufffd\ufffd\ufffd\r\n\t\t\tret = CRYPT_build_sender_MAC(pvar, pvar->ssh_state.sender_sequence_number,\r\n\t\t\t                             data, encryption_size, data + encryption_size);\r\n\t\t\tif (ret) {\r\n\t\t\t\tmaclen = CRYPT_get_sender_MAC_size(pvar);\r\n\t\t\t}\r\n\r\n\t\t\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\u00cd\ufffd\ufffd\ufffd\r\n\t\t\tCRYPT_encrypt(pvar, data, encryption_size);\r\n\t\t}\r\n\r\n\t\tdata_length = encryption_size + aadlen + maclen;\r\n\r\n\t\tlogprintf(150,\r\n\t\t          \"%s: built packet info: \"\r\n\t\t          \"aadlen:%d, enclen:%d, padlen:%d, datalen:%d, maclen:%d, \"\r\n\t\t          \"Encrypt Mode:%s, MAC mode:%s\",\r\n\t\t          __FUNCTION__,\r\n\t\t          aadlen, encryption_size, padding_size, data_length, maclen,\r\n\t\t          authlen ? \"AEAD\" : \"not AEAD\", aadlen ? \"EtM\" : \"E&M\");\r\n\t}\r\n\r\n\tsend_packet_blocking(pvar, data, data_length);\r\n\r\n\tbuffer_free(msg);\r\n\r\n\tpvar->ssh_state.sender_sequence_number++;\r\n\r\n\t// \ufffd\ufffd\ufffdM\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdL\ufffd^\r\n\tpvar->ssh_heartbeat_tick = time(NULL);\r\n}\r\n\r\nstatic void destroy_packet_buf(PTInstVar pvar)\r\n{\r\n\tmemset(pvar->ssh_state.outbuf, 0, pvar->ssh_state.outbuflen);\r\n\tif (pvar->ssh_state.compressing) {\r\n\t\tmemset(pvar->ssh_state.precompress_outbuf, 0,\r\n\t\t       pvar->ssh_state.precompress_outbuflen);\r\n\t}\r\n}\r\n\r\n/* The handlers are added to the queue for each message. When one of the\r\n   handlers fires, if it returns FALSE, then all handlers in the set are\r\n   removed from their queues. */\r\nstatic void enque_handlers(PTInstVar pvar, int num_msgs,\r\n                           const int *messages,\r\n                           const SSHPacketHandler *handlers)\r\n{\r\n\tSSHPacketHandlerItem *first_item;\r\n\tSSHPacketHandlerItem *last_item = NULL;\r\n\tint i;\r\n\r\n\tfor (i = 0; i < num_msgs; i++) {\r\n\t\tSSHPacketHandlerItem *item =\r\n\t\t\t(SSHPacketHandlerItem *)\r\n\t\t\tmalloc(sizeof(SSHPacketHandlerItem));\r\n\t\tSSHPacketHandlerItem *cur_item =\r\n\t\t\tpvar->ssh_state.packet_handlers[messages[i]];\r\n\r\n\t\titem->handler = handlers[i];\r\n\r\n\t\tif (cur_item == NULL) {\r\n\t\t\tpvar->ssh_state.packet_handlers[messages[i]] = item;\r\n\t\t\titem->next_for_message = item;\r\n\t\t\titem->last_for_message = item;\r\n\t\t\titem->active_for_message = messages[i];\r\n\t\t} else {\r\n\t\t\titem->next_for_message = cur_item;\r\n\t\t\titem->last_for_message = cur_item->last_for_message;\r\n\t\t\tcur_item->last_for_message->next_for_message = item;\r\n\t\t\tcur_item->last_for_message = item;\r\n\t\t\titem->active_for_message = -1;\r\n\t\t}\r\n\r\n\t\tif (last_item != NULL) {\r\n\t\t\tlast_item->next_in_set = item;\r\n\t\t} else {\r\n\t\t\tfirst_item = item;\r\n\t\t}\r\n\t\tlast_item = item;\r\n\t}\r\n\r\n\tif (last_item != NULL) {\r\n\t\tlast_item->next_in_set = first_item;\r\n\t}\r\n}\r\n\r\nstatic SSHPacketHandler get_handler(PTInstVar pvar, int message)\r\n{\r\n\tSSHPacketHandlerItem *cur_item =\r\n\t\tpvar->ssh_state.packet_handlers[message];\r\n\r\n\tif (cur_item == NULL) {\r\n\t\treturn NULL;\r\n\t} else {\r\n\t\treturn cur_item->handler;\r\n\t}\r\n}\r\n\r\n/* Called only by SSH_handle_packet */\r\nstatic void deque_handlers(PTInstVar pvar, int message)\r\n{\r\n\tSSHPacketHandlerItem *cur_item =\r\n\t\tpvar->ssh_state.packet_handlers[message];\r\n\tSSHPacketHandlerItem *first_item_in_set = cur_item;\r\n\r\n\tif (cur_item == NULL)\r\n\t\treturn;\r\n\r\n\tdo {\r\n\t\tSSHPacketHandlerItem *next_in_set = cur_item->next_in_set;\r\n\r\n\t\tif (cur_item->active_for_message >= 0) {\r\n\t\t\tSSHPacketHandlerItem *replacement =\r\n\t\t\t\tcur_item->next_for_message;\r\n\r\n\t\t\tif (replacement == cur_item) {\r\n\t\t\t\treplacement = NULL;\r\n\t\t\t} else {\r\n\t\t\t\treplacement->active_for_message =\r\n\t\t\t\t\tcur_item->active_for_message;\r\n\t\t\t}\r\n\t\t\tpvar->ssh_state.packet_handlers[cur_item->active_for_message] =\r\n\t\t\t\treplacement;\r\n\t\t}\r\n\t\tcur_item->next_for_message->last_for_message =\r\n\t\t\tcur_item->last_for_message;\r\n\t\tcur_item->last_for_message->next_for_message =\r\n\t\t\tcur_item->next_for_message;\r\n\r\n\t\tfree(cur_item);\r\n\t\tcur_item = next_in_set;\r\n\t} while (cur_item != first_item_in_set);\r\n}\r\n\r\nstatic void enque_handler(PTInstVar pvar, int message,\r\n                          SSHPacketHandler handler)\r\n{\r\n\tenque_handlers(pvar, 1, &message, &handler);\r\n}\r\n\r\nstatic void chop_newlines(char *buf)\r\n{\r\n\tint len = strlen(buf);\r\n\r\n\twhile (len > 0 && (buf[len - 1] == '\\n' || buf[len - 1] == '\\r')) {\r\n\t\tbuf[len - 1] = 0;\r\n\t\tlen--;\r\n\t}\r\n}\r\n\r\n/********************/\r\n/* Message handlers */\r\n/********************/\r\n\r\nstatic BOOL handle_forwarding_success(PTInstVar pvar)\r\n{\r\n\treturn FALSE;\r\n}\r\n\r\nstatic BOOL handle_forwarding_failure(PTInstVar pvar)\r\n{\r\n\treturn FALSE;\r\n}\r\n\r\nstatic void enque_forwarding_request_handlers(PTInstVar pvar)\r\n{\r\n\tstatic const int msgs[] = { SSH_SMSG_SUCCESS, SSH_SMSG_FAILURE };\r\n\tstatic const SSHPacketHandler handlers[]\r\n\t= { handle_forwarding_success, handle_forwarding_failure };\r\n\r\n\tenque_handlers(pvar, 2, msgs, handlers);\r\n}\r\n\r\nstatic BOOL handle_auth_failure(PTInstVar pvar)\r\n{\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"Authentication failed\");\r\n\r\n\t// retry count\ufffd\u0312\u01c9\ufffd (2005.7.15 yutaka)\r\n\tpvar->userauth_retry_count++;\r\n\r\n\tAUTH_set_generic_mode(pvar);\r\n\tAUTH_advance_to_next_cred(pvar);\r\n\tpvar->ssh_state.status_flags &= ~STATUS_DONT_SEND_CREDENTIALS;\r\n\ttry_send_credentials(pvar);\r\n\treturn FALSE;\r\n}\r\n\r\nstatic BOOL handle_rsa_auth_refused(PTInstVar pvar)\r\n{\r\n\tif (pvar->auth_state.cur_cred.method == SSH_AUTH_PAGEANT) {\r\n\t\tif (pvar->pageant_keycount <= pvar->pageant_keycurrent) {\r\n\t\t\t// \ufffdS\ufffd\u0102\u030c\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdI\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\t\t\tsafefree(pvar->pageant_key);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// \ufffd\u0702\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\t\t\tpvar->ssh_state.status_flags &= ~STATUS_DONT_SEND_CREDENTIALS;\r\n\t\t\ttry_send_credentials(pvar);\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t}\r\n\tAUTH_destroy_cur_cred(pvar);\r\n\treturn handle_auth_failure(pvar);\r\n}\r\n\r\nstatic BOOL handle_TIS_challenge(PTInstVar pvar)\r\n{\r\n\tif (grab_payload(pvar, 4)) {\r\n\t\tint len = get_payload_uint32(pvar, 0);\r\n\r\n\t\tif (grab_payload(pvar, len)) {\r\n\t\t\tlogputs(LOG_LEVEL_VERBOSE, \"Received TIS challenge\");\r\n\r\n\t\t\tAUTH_set_TIS_mode(pvar, pvar->ssh_state.payload + 4, len, 0);\r\n\t\t\tAUTH_advance_to_next_cred(pvar);\r\n\t\t\tpvar->ssh_state.status_flags &= ~STATUS_DONT_SEND_CREDENTIALS;\r\n\t\t\ttry_send_credentials(pvar);\r\n\t\t}\r\n\t}\r\n\treturn FALSE;\r\n}\r\n\r\nstatic BOOL handle_auth_required(PTInstVar pvar)\r\n{\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"Server requires authentication\");\r\n\r\n\tpvar->ssh_state.status_flags &= ~STATUS_DONT_SEND_CREDENTIALS;\r\n\ttry_send_credentials(pvar);\r\n\t/* the first AUTH_advance_to_next_cred is issued early by ttxssh.c */\r\n\r\n\treturn FALSE;\r\n}\r\n\r\nstatic BOOL handle_ignore(PTInstVar pvar)\r\n{\r\n\tif (SSHv1(pvar)) {\r\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"SSH_MSG_IGNORE was received.\");\r\n\r\n\t\tif (grab_payload(pvar, 4)\r\n\t\t && grab_payload(pvar, get_payload_uint32(pvar, 0))) {\r\n\t\t\t/* ignore it! but it must be decompressed */\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_IGNORE was received.\");\r\n\r\n\t\t// \ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd\ufffd SSH2_MSG_IGNORE \ufffd\u030e\ufffd\ufffd\u0349\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\r\n\t\t// Cisco \ufffd\ufffd\ufffd[\ufffd^\ufffd\u038d\ufffd (2006.11.28 maya)\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_debug(PTInstVar pvar)\r\n{\r\n\tBOOL always_display;\r\n\tchar *description;\r\n\tint description_len;\r\n\tchar buf[2048];\r\n\r\n\tif (SSHv1(pvar)) {\r\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"SSH_MSG_DEBUG was received.\");\r\n\r\n\t\tif (grab_payload(pvar, 4)\r\n\t\t && grab_payload(pvar, description_len =\r\n\t\t                 get_payload_uint32(pvar, 0))) {\r\n\t\t\talways_display = FALSE;\r\n\t\t\tdescription = pvar->ssh_state.payload + 4;\r\n\t\t\tdescription[description_len] = 0;\r\n\t\t} else {\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t} else {\r\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_DEBUG was received.\");\r\n\r\n\t\tif (grab_payload(pvar, 5)\r\n\t\t && grab_payload(pvar,\r\n\t\t                 (description_len = get_payload_uint32(pvar, 1)) + 4)\r\n\t\t && grab_payload(pvar,\r\n\t\t                 get_payload_uint32(pvar, 5 + description_len))) {\r\n\t\t\talways_display = pvar->ssh_state.payload[0] != 0;\r\n\t\t\tdescription = pvar->ssh_state.payload + 5;\r\n\t\t\tdescription[description_len] = 0;\r\n\t\t} else {\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t}\r\n\r\n\tchop_newlines(description);\r\n\t_snprintf_s(buf, sizeof(buf), _TRUNCATE, \"DEBUG message from server: %s\",\r\n\t            description);\r\n\tif (always_display) {\r\n\t\tnotify_nonfatal_error(pvar, buf);\r\n\t} else {\r\n\t\tlogputs(LOG_LEVEL_VERBOSE, buf);\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_disconnect(PTInstVar pvar)\r\n{\r\n\tint reason_code;\r\n\tchar *description;\r\n\tint description_len;\r\n\tchar buf[2048];\r\n\tchar *explanation = \"\";\r\n\tchar uimsg[MAX_UIMSG];\r\n\r\n\tif (SSHv1(pvar)) {\r\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"SSH_MSG_DISCONNECT was received.\");\r\n\r\n\t\tif (grab_payload(pvar, 4)\r\n\t\t && grab_payload(pvar, description_len = get_payload_uint32(pvar, 0))) {\r\n\t\t\treason_code = -1;\r\n\t\t\tdescription = pvar->ssh_state.payload + 4;\r\n\t\t\tdescription[description_len] = 0;\r\n\t\t} else {\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t} else {\r\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_DISCONNECT was received.\");\r\n\r\n\t\tif (grab_payload(pvar, 8)\r\n\t\t && grab_payload(pvar,\r\n\t\t                 (description_len = get_payload_uint32(pvar, 4)) + 4)\r\n\t\t && grab_payload(pvar,\r\n\t\t                 get_payload_uint32(pvar, 8 + description_len))) {\r\n\t\t\treason_code = get_payload_uint32(pvar, 0);\r\n\t\t\tdescription = pvar->ssh_state.payload + 8;\r\n\t\t\tdescription[description_len] = 0;\r\n\t\t} else {\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t}\r\n\r\n\tchop_newlines(description);\r\n\tif (description[0] == 0) {\r\n\t\tdescription = NULL;\r\n\t}\r\n\r\n\tif (get_handler(pvar, SSH_SMSG_FAILURE) == handle_forwarding_failure) {\r\n\t\tUTIL_get_lang_msg(\"MSG_SSH_UNABLE_FWD_ERROR\", pvar,\r\n\t\t                  \"\\nIt may have disconnected because it was unable to forward a port you requested to be forwarded from the server.\\n\"\r\n\t\t                  \"This often happens when someone is already forwarding that port from the server.\");\r\n\t\tstrncpy_s(uimsg, sizeof(uimsg), pvar->UIMsg, _TRUNCATE);\r\n\t\texplanation = uimsg;\r\n\t}\r\n\r\n\tif (description != NULL) {\r\n\t\tUTIL_get_lang_msg(\"MSG_SSH_SERVER_DISCON_ERROR\", pvar,\r\n\t\t                  \"Server disconnected with message '%s'%s\");\r\n\t\t_snprintf_s(buf, sizeof(buf), _TRUNCATE,\r\n\t\t            pvar->UIMsg, description,\r\n\t\t            explanation);\r\n\t} else {\r\n\t\tUTIL_get_lang_msg(\"MSG_SSH_SERVER_DISCON_NORES_ERROR\", pvar,\r\n\t\t                  \"Server disconnected (no reason given).%s\");\r\n\t\t_snprintf_s(buf, sizeof(buf), _TRUNCATE,\r\n\t\t            pvar->UIMsg, explanation);\r\n\t}\r\n\r\n\tif (SSHv2(pvar)) {\r\n\t\t// SSH2_MSG_DISCONNECT \ufffd\ufffd\ufffd\udaca\udfce\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0182\u0349\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdM\ufffd\ufffd\ufffd\u0102\u0342\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\r\n\t\tnotify_fatal_error(pvar, buf, FALSE);\r\n\t}\r\n\telse {\r\n\t\t// SSH1 \ufffd\u030f\ua347\ufffd\u030ed\ufffdl\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\u0302\u0141A\ufffd\u0211O\ufffd\u0302\u0702\u0702\u0242\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\r\n\t\tnotify_fatal_error(pvar, buf, TRUE);\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_unimplemented(PTInstVar pvar)\r\n{\r\n\t/* Should never receive this since we only send base 2.0 protocol messages */\r\n\tgrab_payload(pvar, 4);\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_crypt_success(PTInstVar pvar)\r\n{\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"Secure mode successfully achieved\");\r\n\treturn FALSE;\r\n}\r\n\r\nstatic BOOL handle_noauth_success(PTInstVar pvar)\r\n{\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"Server does not require authentication\");\r\n\tprep_compression(pvar);\r\n\treturn FALSE;\r\n}\r\n\r\nstatic BOOL handle_auth_success(PTInstVar pvar)\r\n{\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"Authentication accepted\");\r\n\tprep_compression(pvar);\r\n\r\n\t// \ufffdn\ufffd[\ufffdg\ufffdr\ufffd[\ufffdg\ufffdE\ufffdX\ufffd\ufffd\ufffdb\ufffdh\ufffd\u030aJ\ufffdn (2004.12.11 yutaka)\r\n\tstart_ssh_heartbeat_thread(pvar);\r\n\r\n\treturn FALSE;\r\n}\r\n\r\n/*\r\n * SSH1\ufffdT\ufffd[\ufffdo\ufffd\ufffd\ufffd\u7457\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd`\ufffdF\ufffdb\ufffdN\ufffd\ufffd\ufffd\u0101A\ufffd\u014c\ufffd\ufffdknown_hosts\ufffd_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\ufffd\\\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n */\r\nstatic BOOL handle_server_public_key(PTInstVar pvar)\r\n{\r\n\tint server_key_public_exponent_len;\r\n\tint server_key_public_modulus_pos;\r\n\tint server_key_public_modulus_len;\r\n\tint host_key_bits_pos;\r\n\tint host_key_public_exponent_len;\r\n\tint host_key_public_modulus_pos;\r\n\tint host_key_public_modulus_len;\r\n\tint protocol_flags_pos;\r\n\tint supported_ciphers;\r\n\tchar *inmsg;\r\n\tKey hostkey;\r\n\tint supported_types;\r\n\tint ret;\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH_SMSG_PUBLIC_KEY was received.\");\r\n\r\n\tif (!grab_payload(pvar, 14))\r\n\t\treturn FALSE;\r\n\tserver_key_public_exponent_len = get_mpint_len(pvar, 12);\r\n\r\n\tif (!grab_payload(pvar, server_key_public_exponent_len + 2))\r\n\t\treturn FALSE;\r\n\tserver_key_public_modulus_pos = 14 + server_key_public_exponent_len;\r\n\tserver_key_public_modulus_len =\r\n\t\tget_mpint_len(pvar, server_key_public_modulus_pos);\r\n\r\n\tif (!grab_payload(pvar, server_key_public_modulus_len + 6))\r\n\t\treturn FALSE;\r\n\thost_key_bits_pos =\r\n\t\tserver_key_public_modulus_pos + 2 + server_key_public_modulus_len;\r\n\thost_key_public_exponent_len =\r\n\t\tget_mpint_len(pvar, host_key_bits_pos + 4);\r\n\r\n\tif (!grab_payload(pvar, host_key_public_exponent_len + 2))\r\n\t\treturn FALSE;\r\n\thost_key_public_modulus_pos =\r\n\t\thost_key_bits_pos + 6 + host_key_public_exponent_len;\r\n\thost_key_public_modulus_len =\r\n\t\tget_mpint_len(pvar, host_key_public_modulus_pos);\r\n\r\n\tif (!grab_payload(pvar, host_key_public_modulus_len + 12))\r\n\t\treturn FALSE;\r\n\tprotocol_flags_pos =\r\n\t\thost_key_public_modulus_pos + 2 + host_key_public_modulus_len;\r\n\r\n\tinmsg = pvar->ssh_state.payload;\r\n\r\n\tCRYPT_set_server_cookie(pvar, inmsg);\r\n\tif (!CRYPT_set_server_RSA_key(pvar,\r\n\t                              get_uint32(inmsg + 8),\r\n\t                              pvar->ssh_state.payload + 12,\r\n\t                              inmsg + server_key_public_modulus_pos))\r\n\t\treturn FALSE;\r\n\tif (!CRYPT_set_host_RSA_key(pvar,\r\n\t                            get_uint32(inmsg + host_key_bits_pos),\r\n\t                            inmsg + host_key_bits_pos + 4,\r\n\t                            inmsg + host_key_public_modulus_pos))\r\n\t\treturn FALSE;\r\n\tpvar->ssh_state.server_protocol_flags =\r\n\t\tget_uint32(inmsg + protocol_flags_pos);\r\n\r\n\tsupported_ciphers = get_uint32(inmsg + protocol_flags_pos + 4);\r\n\tif (!CRYPT_set_supported_ciphers(pvar,\r\n\t                                 supported_ciphers,\r\n\t                                 supported_ciphers))\r\n\t\treturn FALSE;\r\n\r\n\t// SSH1 \ufffdT\ufffd[\ufffdo\ufffd\u0341A\ufffdT\ufffd|\ufffd[\ufffdg\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffdF\ufffd\u0615\ufffd\ufffd\ufffd\ufffd\ud805\uddc2\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\r\n\t// RSA \ufffd\ufffd\ufffdL\ufffd\ufffd\ufffd\u0202\ufffd PAGEANT \ufffd\ufffdL\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\ufffd\r\n\tsupported_types = get_uint32(inmsg + protocol_flags_pos + 8);\r\n\tif ((supported_types & (1 << SSH_AUTH_RSA)) > 0) {\r\n\t\tsupported_types |= (1 << SSH_AUTH_PAGEANT);\r\n\t}\r\n\tif (!AUTH_set_supported_auth_types(pvar,\r\n\t                                   supported_types))\r\n\t\treturn FALSE;\r\n\r\n\t/* this must be the LAST THING in this function, since it can cause\r\n\t   host_is_OK to be called. */\r\n\thostkey.type = KEY_RSA1;\r\n\thostkey.bits = get_uint32(inmsg + host_key_bits_pos);\r\n\thostkey.exp = inmsg + host_key_bits_pos + 4;\r\n\thostkey.mod = inmsg + host_key_public_modulus_pos;\r\n\r\n\tret = HOSTS_check_host_key(pvar, pvar->ssh_state.hostname, pvar->ssh_state.tcpport, &hostkey);\r\n\tif (ret == TRUE) {\r\n\t\t// known_hosts\ufffd_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\u030c\u0102\u044fo\ufffd\ufffd\ufffd\u0355s\ufffdv\ufffd\u0202\u0302\u0141A\ufffd\ufffd\ufffd\ufffd\ufffd\u030f\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffds\ufffd\ufffd\ufffd\ufffdB\r\n\t\tSSH_notify_host_OK(pvar);\r\n\r\n\t} else {\r\n\t\t// known_hosts\ufffd_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\u030c\u0102\u044fo\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\u020d~\ufffdA\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\r\n\t}\r\n\r\n\treturn FALSE;\r\n}\r\n\r\n/*\r\nThe ID must have already been found to start with \"SSH-\". It must\r\nbe null-terminated.\r\n*/\r\nstatic BOOL parse_protocol_ID(PTInstVar pvar, char *ID)\r\n{\r\n\tchar *str;\r\n\r\n\tfor (str = ID + 4; *str >= '0' && *str <= '9'; str++) {\r\n\t}\r\n\r\n\tif (*str != '.') {\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tpvar->protocol_major = atoi(ID + 4);\r\n\tpvar->protocol_minor = atoi(str + 1);\r\n\r\n\tfor (str = str + 1; *str >= '0' && *str <= '9'; str++) {\r\n\t}\r\n\r\n\treturn *str == '-';\r\n}\r\n\r\n/*\r\nOn entry, the pvar->protocol_xxx fields hold the server's advertised\r\nprotocol number. We replace the fields with the protocol number we will\r\nactually use, or return FALSE if there is no usable protocol version.\r\n*/\r\nstatic int negotiate_protocol(PTInstVar pvar)\r\n{\r\n\tswitch (pvar->protocol_major) {\r\n\tcase 1:\r\n\t\tif (pvar->protocol_minor == 99 &&\r\n\t\t    pvar->settings.ssh_protocol_version == 2) {\r\n\t\t\t// \ufffdT\ufffd[\ufffdo\ufffd\ufffd 1.99 \ufffd\u0143\ufffd\ufffd[\ufffdU\ufffd\ufffd SSH2 \ufffd\ufffdI\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\u0302\u0202\ufffd\ufffd\r\n\t\t\t// 2.0 \ufffd\u0691\ufffd\ufffd\u0182\ufffd\ufffd\ufffd\r\n\t\t\tpvar->protocol_major = 2;\r\n\t\t\tpvar->protocol_minor = 0;\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tif (pvar->settings.ssh_protocol_version == 2) {\r\n\t\t\t// \ufffdo\ufffd[\ufffdW\ufffd\ufffd\ufffd\ufffd\ufffd\u10a2\r\n\t\t\treturn -1;\r\n\t\t}\r\n\r\n\t\tif (pvar->protocol_minor > 5) {\r\n\t\t\tpvar->protocol_minor = 5;\r\n\t\t}\r\n\r\n\t\treturn 0;\r\n\r\n\t// for SSH2(yutaka)\r\n\tcase 2:\r\n\t\tif (pvar->settings.ssh_protocol_version == 1) {\r\n\t\t\t// \ufffdo\ufffd[\ufffdW\ufffd\ufffd\ufffd\ufffd\ufffd\u10a2\r\n\t\t\treturn -1;\r\n\t\t}\r\n\r\n\t\treturn 0;\t\t\t// SSH2 support\r\n\r\n\tdefault:\r\n\t\treturn 1;\r\n\t}\r\n}\r\n\r\nstatic void init_protocol(PTInstVar pvar)\r\n{\r\n\tCRYPT_initialize_random_numbers(pvar);\r\n\r\n\t// known_hosts\ufffdt\ufffd@\ufffdC\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdz\ufffdX\ufffdg\ufffd\ufffd\ufffdJ\ufffd\ufffd\ufffd\ufffd\ufffd\u01c2\u0742\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\r\n\tHOSTS_prefetch_host_key(pvar, pvar->ssh_state.hostname, pvar->ssh_state.tcpport);\r\n\r\n\t/* while we wait for a response from the server... */\r\n\r\n\tif (SSHv1(pvar)) {\r\n\t\tenque_handler(pvar, SSH_MSG_DISCONNECT, handle_disconnect);\r\n\t\tenque_handler(pvar, SSH_MSG_IGNORE, handle_ignore);\r\n\t\tenque_handler(pvar, SSH_MSG_DEBUG, handle_debug);\r\n\t\tenque_handler(pvar, SSH_SMSG_PUBLIC_KEY, handle_server_public_key);\r\n\r\n\t} else {  // for SSH2(yutaka)\r\n\t\tenque_handler(pvar, SSH2_MSG_DISCONNECT, handle_disconnect);\r\n\t\tenque_handler(pvar, SSH2_MSG_IGNORE, handle_ignore);\r\n\t\tenque_handler(pvar, SSH2_MSG_DEBUG, handle_debug);\r\n\t\tenque_handler(pvar, SSH2_MSG_KEXINIT, handle_SSH2_kexinit);\r\n\t\tenque_handler(pvar, SSH2_MSG_KEXDH_INIT, handle_unimplemented);\r\n\t\tenque_handler(pvar, SSH2_MSG_KEXDH_REPLY, handle_SSH2_dh_common_reply);\r\n\t\tenque_handler(pvar, SSH2_MSG_KEX_DH_GEX_REPLY, handle_SSH2_dh_gex_reply);\r\n\t\tenque_handler(pvar, SSH2_MSG_NEWKEYS, handle_SSH2_newkeys);\r\n\t\tenque_handler(pvar, SSH2_MSG_SERVICE_ACCEPT, handle_SSH2_service_accept);\r\n\t\tenque_handler(pvar, SSH2_MSG_EXT_INFO, handle_SSH2_ext_info);\r\n\t\tenque_handler(pvar, SSH2_MSG_USERAUTH_SUCCESS, handle_SSH2_userauth_success);\r\n\t\tenque_handler(pvar, SSH2_MSG_USERAUTH_FAILURE, handle_SSH2_userauth_failure);\r\n\t\tenque_handler(pvar, SSH2_MSG_USERAUTH_BANNER, handle_SSH2_userauth_banner);\r\n\t\tenque_handler(pvar, SSH2_MSG_USERAUTH_INFO_REQUEST, handle_SSH2_userauth_msg60);\r\n\r\n\t\tenque_handler(pvar, SSH2_MSG_UNIMPLEMENTED, handle_unimplemented);\r\n\r\n\t\t// \ufffd\ufffd\ufffd[\ufffdU\ufffdF\ufffd\u060c\ufffd\u0303f\ufffdB\ufffdX\ufffdp\ufffdb\ufffd`\ufffd\ufffd\ufffd[\ufffd`\ufffd\ufffd\r\n\t\tenque_handler(pvar, SSH2_MSG_CHANNEL_CLOSE, handle_SSH2_channel_close);\r\n\t\tenque_handler(pvar, SSH2_MSG_CHANNEL_DATA, handle_SSH2_channel_data);\r\n\t\tenque_handler(pvar, SSH2_MSG_CHANNEL_EOF, handle_SSH2_channel_eof);\r\n\t\tenque_handler(pvar, SSH2_MSG_CHANNEL_EXTENDED_DATA, handle_SSH2_channel_extended_data);\r\n\t\tenque_handler(pvar, SSH2_MSG_CHANNEL_OPEN, handle_SSH2_channel_open);\r\n\t\tenque_handler(pvar, SSH2_MSG_CHANNEL_OPEN_CONFIRMATION, handle_SSH2_open_confirm);\r\n\t\tenque_handler(pvar, SSH2_MSG_CHANNEL_OPEN_FAILURE, handle_SSH2_open_failure);\r\n\t\tenque_handler(pvar, SSH2_MSG_CHANNEL_REQUEST, handle_SSH2_channel_request);\r\n\t\tenque_handler(pvar, SSH2_MSG_CHANNEL_WINDOW_ADJUST, handle_SSH2_window_adjust);\r\n\t\tenque_handler(pvar, SSH2_MSG_CHANNEL_SUCCESS, handle_SSH2_channel_success);\r\n\t\tenque_handler(pvar, SSH2_MSG_CHANNEL_FAILURE, handle_SSH2_channel_failure);\r\n\t\tenque_handler(pvar, SSH2_MSG_GLOBAL_REQUEST, handle_SSH2_client_global_request);\r\n\t\tenque_handler(pvar, SSH2_MSG_REQUEST_FAILURE, handle_SSH2_request_failure);\r\n\t\tenque_handler(pvar, SSH2_MSG_REQUEST_SUCCESS, handle_SSH2_request_success);\r\n\r\n\t\tclient_init_global_confirm();\r\n\r\n\t}\r\n}\r\n\r\nvoid server_version_check(PTInstVar pvar)\r\n{\r\n\tchar *server_swver;\r\n\r\n\tpvar->server_compat_flag = 0;\r\n\r\n\tif ((server_swver = strchr(pvar->server_version_string+4, '-')) == NULL) {\r\n\t\tlogputs(LOG_LEVEL_WARNING, \"Can't get server software version string.\");\r\n\t\treturn;\r\n\t}\r\n\tserver_swver++;\r\n\r\n\tif (strncmp(server_swver, \"Cisco-1\", 7) == 0) {\r\n\t\tpvar->server_compat_flag |= SSH_BUG_DHGEX_LARGE;\r\n\t\tlogputs(LOG_LEVEL_INFO, \"Server version string is matched to \\\"Cisco-1\\\", compatibility flag SSH_BUG_DHGEX_LARGE is enabled.\");\r\n\t}\r\n}\r\n\r\nBOOL SSH_handle_server_ID(PTInstVar pvar, char *ID, int ID_len)\r\n{\r\n\tstatic char prefix[64];\r\n\tint negotiate;\r\n\tchar uimsg[MAX_UIMSG];\r\n\r\n\t// initialize SSH2 memory dump (2005.3.7 yutaka)\r\n\tinit_memdump();\r\n\tpush_memdump(\"pure server ID\", \"start protocol version exchange\", ID, ID_len);\r\n\r\n\tif (ID_len <= 0) {\r\n\t\treturn FALSE;\r\n\t} else {\r\n\t\tint buf_len;\r\n\t\tchar *buf;\r\n\r\n\t\tstrncpy_s(prefix, sizeof(prefix), \"Received server identification string: \", _TRUNCATE);\r\n\t\tbuf_len = strlen(prefix) + ID_len + 1;\r\n\t\tbuf = (char *) malloc(buf_len);\r\n\t\tstrncpy_s(buf, buf_len, prefix, _TRUNCATE);\r\n\t\tstrncat_s(buf, buf_len, ID, _TRUNCATE);\r\n\t\tchop_newlines(buf);\r\n\t\tlogputs(LOG_LEVEL_VERBOSE, buf);\r\n\t\tfree(buf);\r\n\r\n\t\tif (ID[ID_len - 1] != '\\n') {\r\n\t\t\tpvar->ssh_state.status_flags |= STATUS_IN_PARTIAL_ID_STRING;\r\n\t\t\treturn FALSE;\r\n\t\t} else if ((pvar->ssh_state.status_flags & STATUS_IN_PARTIAL_ID_STRING) != 0) {\r\n\t\t\tpvar->ssh_state.status_flags &= ~STATUS_IN_PARTIAL_ID_STRING;\r\n\t\t\treturn FALSE;\r\n\t\t} else if (strncmp(ID, \"SSH-\", 4) != 0) {\r\n\t\t\treturn FALSE;\r\n\t\t} else {\r\n\t\t\tID[ID_len - 1] = 0;\r\n\r\n\t\t\tif (ID_len > 1 && ID[ID_len - 2] == '\\r') {\r\n\t\t\t\tID[ID_len - 2] = 0;\r\n\t\t\t}\r\n\r\n\t\t\tpvar->ssh_state.server_ID = _strdup(ID);\r\n\r\n\t\t\tif (!parse_protocol_ID(pvar, ID)) {\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_VERSION_ERROR\", pvar,\r\n\t\t\t\t                  \"This program does not understand the server's version of the protocol.\");\r\n\t\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\t}\r\n\t\t\telse if ((negotiate = negotiate_protocol(pvar)) == 1) {\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_VERSION_ERROR\", pvar,\r\n\t\t\t\t                  \"This program does not understand the server's version of the protocol.\");\r\n\t\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\t}\r\n\t\t\telse if (negotiate == -1) {\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_VERSION_MISMATCH\", pvar,\r\n\t\t\t\t                  \"Protocol version mismatch. server:%d.%d client:%d\");\r\n\t\t\t\t_snprintf_s(uimsg, sizeof(uimsg), _TRUNCATE, pvar->UIMsg,\r\n\t\t\t\t            pvar->protocol_major, pvar->protocol_minor, pvar->settings.ssh_protocol_version);\r\n\t\t\t\tnotify_fatal_error(pvar, uimsg, TRUE);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tchar TTSSH_ID[1024];\r\n\t\t\t\tint TTSSH_ID_len;\r\n\r\n\t\t\t\t// SSH \ufffdo\ufffd[\ufffdW\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd teraterm \ufffd\ufffd\ufffd\u0243Z\ufffdb\ufffdg\ufffd\ufffd\ufffd\ufffd\r\n\t\t\t\t// SCP \ufffdR\ufffd}\ufffd\ufffd\ufffdh\ufffd\u0302\ufffd\ufffd\ufffd (2008.2.3 maya)\r\n\t\t\t\tpvar->cv->isSSH = pvar->protocol_major;\r\n\r\n\t\t\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdg\ufffd\u0303o\ufffd[\ufffdW\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u64fe\ufffd\ufffd\ufffd\ufffd (2005.3.3 yutaka)\r\n\t\t\t\t_snprintf_s(TTSSH_ID, sizeof(TTSSH_ID), _TRUNCATE,\r\n\t\t\t\t            \"SSH-%d.%d-TTSSH/%d.%d Win32\\r\\n\",\r\n\t\t\t\t            pvar->protocol_major, pvar->protocol_minor,\r\n\t\t\t\t            TTSSH_VERSION_MAJOR, TTSSH_VERSION_MINOR);\r\n\t\t\t\tTTSSH_ID_len = strlen(TTSSH_ID);\r\n\r\n\t\t\t\t// for SSH2(yutaka)\r\n\t\t\t\t// \ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg\ufffdo\ufffd[\ufffdW\ufffd\ufffd\ufffd\ufffd\ufffd\u0315\u06d1\ufffd\ufffdi\ufffd\ufffd\ufffds\ufffd\u034e\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffd\u0181j\r\n\t\t\t\tstrncpy_s(pvar->client_version_string, sizeof(pvar->client_version_string),\r\n\t\t\t\t          TTSSH_ID, _TRUNCATE);\r\n\r\n\t\t\t\t// \ufffdT\ufffd[\ufffdo\ufffdo\ufffd[\ufffdW\ufffd\ufffd\ufffd\ufffd\ufffd\u0315\u06d1\ufffd\ufffdi\ufffd\ufffd\ufffds\ufffd\u034e\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffd\u0181j(2005.3.9 yutaka)\r\n\t\t\t\t_snprintf_s(pvar->server_version_string,\r\n\t\t\t\t            sizeof(pvar->server_version_string), _TRUNCATE,\r\n\t\t\t\t            \"%s\", pvar->ssh_state.server_ID);\r\n\r\n\t\t\t\t// \ufffdT\ufffd[\ufffdo\ufffdo\ufffd[\ufffdW\ufffd\ufffd\ufffd\ufffd\ufffd\u0303`\ufffdF\ufffdb\ufffdN\r\n\t\t\t\tserver_version_check(pvar);\r\n\r\n\t\t\t\tif ((pvar->Psend) (pvar->socket, TTSSH_ID, TTSSH_ID_len, 0) != TTSSH_ID_len) {\r\n\t\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_SEND_ID_ERROR\", pvar,\r\n\t\t\t\t\t                  \"An error occurred while sending the SSH ID string.\\n\"\r\n\t\t\t\t\t                  \"The connection will close.\");\r\n\t\t\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// \ufffd\ufffd\ufffds\ufffd\u030f\ufffd\ufffd\ufffd\r\n\t\t\t\t\tchop_newlines(pvar->client_version_string);\r\n\t\t\t\t\tlogprintf(LOG_LEVEL_VERBOSE, \"Sent client identification string: %s\", pvar->client_version_string);\r\n\r\n\t\t\t\t\tpush_memdump(\"server ID\", NULL, pvar->server_version_string, strlen(pvar->server_version_string));\r\n\t\t\t\t\tpush_memdump(\"client ID\", NULL, pvar->client_version_string, strlen(pvar->client_version_string));\r\n\r\n\t\t\t\t\t// SSH\ufffdn\ufffd\ufffd\ufffdh\ufffd\ufffd\ufffd\u0313o\ufffd^\ufffd\ufffd\ufffds\ufffd\ufffd\r\n\t\t\t\t\tinit_protocol(pvar);\r\n\r\n\t\t\t\t\tSSH2_dispatch_init(1);\r\n\t\t\t\t\tSSH2_dispatch_add_message(SSH2_MSG_KEXINIT);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstatic BOOL handle_exit(PTInstVar pvar)\r\n{\r\n\tif (grab_payload(pvar, 4)) {\r\n\t\tbegin_send_packet(pvar, SSH_CMSG_EXIT_CONFIRMATION, 0);\r\n\t\tfinish_send_packet(pvar);\r\n\t\tnotify_closed_connection(pvar, \"disconnected by server request\");\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_data(PTInstVar pvar)\r\n{\r\n\tif (grab_payload_limited(pvar, 4)) {\r\n\t\tpvar->ssh_state.payload_datalen = get_payload_uint32(pvar, 0);\r\n\t\tpvar->ssh_state.payload_datastart = 4;\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_channel_open(PTInstVar pvar)\r\n{\r\n\tint host_len;\r\n\tint originator_len;\r\n\r\n\tif ((pvar->ssh_state.\r\n\t\t server_protocol_flags & SSH_PROTOFLAG_HOST_IN_FWD_OPEN) != 0) {\r\n\t\tif (grab_payload(pvar, 8)\r\n\t\t && grab_payload(pvar,\r\n\t\t                 8 + (host_len = get_payload_uint32(pvar, 4)))\r\n\t\t && grab_payload(pvar, originator_len =\r\n\t\t                 get_payload_uint32(pvar, host_len + 12))) {\r\n\t\t\tint local_port = get_payload_uint32(pvar, 8 + host_len);\r\n\r\n\t\t\tpvar->ssh_state.payload[8 + host_len] = 0;\r\n\t\t\tFWD_open(pvar, get_payload_uint32(pvar, 0),\r\n\t\t\t         pvar->ssh_state.payload + 8, local_port,\r\n\t\t\t         pvar->ssh_state.payload + 16 + host_len,\r\n\t\t\t         originator_len,\r\n\t\t\t         NULL);\r\n\t\t}\r\n\t} else {\r\n\t\tif (grab_payload(pvar, 8)\r\n\t\t && grab_payload(pvar,\r\n\t\t                 4 + (host_len = get_payload_uint32(pvar, 4)))) {\r\n\t\t\tint local_port = get_payload_uint32(pvar, 8 + host_len);\r\n\r\n\t\t\tpvar->ssh_state.payload[8 + host_len] = 0;\r\n\t\t\tFWD_open(pvar, get_payload_uint32(pvar, 0),\r\n\t\t\t         pvar->ssh_state.payload + 8, local_port, NULL, 0,\r\n\t\t\t         NULL);\r\n\t\t}\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_X11_channel_open(PTInstVar pvar)\r\n{\r\n\tint originator_len;\r\n\r\n\tif ((pvar->ssh_state.server_protocol_flags & SSH_PROTOFLAG_HOST_IN_FWD_OPEN) != 0) {\r\n\t\tif (grab_payload(pvar, 8)\r\n\t\t && grab_payload(pvar, originator_len = get_payload_uint32(pvar, 4))) {\r\n\t\t\tFWD_X11_open(pvar, get_payload_uint32(pvar, 0),\r\n\t\t\t             pvar->ssh_state.payload + 8, originator_len, NULL);\r\n\t\t}\r\n\t} else {\r\n\t\tif (grab_payload(pvar, 4)) {\r\n\t\t\tFWD_X11_open(pvar, get_payload_uint32(pvar, 0), NULL, 0, NULL);\r\n\t\t}\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_channel_open_confirmation(PTInstVar pvar)\r\n{\r\n\tif (grab_payload(pvar, 8)) {\r\n\t\tFWD_confirmed_open(pvar, get_payload_uint32(pvar, 0),\r\n\t\t                   get_payload_uint32(pvar, 4));\r\n\t}\r\n\treturn FALSE;\r\n}\r\n\r\nstatic BOOL handle_channel_open_failure(PTInstVar pvar)\r\n{\r\n\tif (grab_payload(pvar, 4)) {\r\n\t\tFWD_failed_open(pvar, get_payload_uint32(pvar, 0), -1);\r\n\t}\r\n\treturn FALSE;\r\n}\r\n\r\nstatic BOOL handle_channel_data(PTInstVar pvar)\r\n{\r\n\tint len;\r\n\r\n\tif (grab_payload(pvar, 8)\r\n\t && grab_payload(pvar, len = get_payload_uint32(pvar, 4))) {\r\n\t\tFWDChannel *channel;\r\n\t\tint local_channel_num = get_payload_uint32(pvar, 0);\r\n\t\tif (!FWD_check_local_channel_num(pvar, local_channel_num)) {\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\tchannel = pvar->fwd_state.channels + local_channel_num;\r\n\t\tif (channel->type == TYPE_AGENT) {\r\n\t\t\tSSH_agent_response(pvar, NULL, local_channel_num,\r\n\t\t\t                   pvar->ssh_state.payload + 8, len);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tFWD_received_data(pvar, local_channel_num,\r\n\t\t\t                  pvar->ssh_state.payload + 8, len);\r\n\t\t}\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_channel_input_eof(PTInstVar pvar)\r\n{\r\n\tif (grab_payload(pvar, 4)) {\r\n\t\tint local_channel_num = get_payload_uint32(pvar, 0);\r\n\t\tFWDChannel *channel;\r\n\t\tif (!FWD_check_local_channel_num(pvar, local_channel_num)) {\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\tchannel = pvar->fwd_state.channels + local_channel_num;\r\n\t\tif (channel->type == TYPE_AGENT) {\r\n\t\t\tchannel->status |= FWD_CLOSED_REMOTE_IN;\r\n\t\t\tSSH_channel_input_eof(pvar, channel->remote_num, local_channel_num);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tFWD_channel_input_eof(pvar, local_channel_num);\r\n\t\t}\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_channel_output_eof(PTInstVar pvar)\r\n{\r\n\tif (grab_payload(pvar, 4)) {\r\n\t\tint local_channel_num = get_payload_uint32(pvar, 0);\r\n\t\tFWDChannel *channel;\r\n\t\tif (!FWD_check_local_channel_num(pvar, local_channel_num)) {\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\tchannel = pvar->fwd_state.channels + local_channel_num;\r\n\t\tif (channel->type == TYPE_AGENT) {\r\n\t\t\tchannel->status |= FWD_CLOSED_REMOTE_OUT;\r\n\t\t\tSSH_channel_output_eof(pvar, channel->remote_num);\r\n\t\t\tFWD_free_channel(pvar, local_channel_num);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tFWD_channel_output_eof(pvar, local_channel_num);\r\n\t\t}\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_agent_open(PTInstVar pvar)\r\n{\r\n\tif (grab_payload(pvar, 4)) {\r\n\t\tint remote_id = get_payload_uint32(pvar, 0);\r\n\t\tint local_id;\r\n\r\n\t\tif (pvar->agentfwd_enable && FWD_agent_forward_confirm(pvar)) {\r\n\t\t\tlocal_id = FWD_agent_open(pvar, remote_id);\r\n\t\t\tif (local_id == -1) {\r\n\t\t\t\tSSH_fail_channel_open(pvar, remote_id);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tSSH_confirm_channel_open(pvar, remote_id, local_id);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tSSH_fail_channel_open(pvar, remote_id);\r\n\t\t}\r\n\t}\r\n\t/*\r\n\telse {\r\n\t\t// \ufffd\u0292m\ufffd\ufffd\ufffd\u944a\ufffd\ufffdchannel\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\u0302\u0149\ufffd\ufffd\ufffd\ufffd\u0142\ufffd\ufffd\u0202\ufffd\r\n\t}\r\n\t*/\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n\r\n\r\n// \ufffdn\ufffd\ufffd\ufffdh\ufffd\ufffd\ufffd\ufffd\ufffdO\ufffd\ufffd\ufffd\u90c1\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd\ufffd\ufffd\ufffd\ufffd\u80b7\ufffd\ufffd\r\n\r\n#define HANDLE_MESSAGE_MAX 30\r\nstatic unsigned char handle_messages[HANDLE_MESSAGE_MAX];\r\nstatic int handle_message_count = 0;\r\nstatic int handle_message_stage = 0;\r\n\r\nvoid SSH2_dispatch_init(int stage)\r\n{\r\n\thandle_message_count = 0;\r\n\thandle_message_stage = stage;\r\n\r\n\tSSH2_dispatch_add_message(SSH2_MSG_IGNORE);\r\n\tSSH2_dispatch_add_message(SSH2_MSG_DEBUG);\r\n\tSSH2_dispatch_add_message(SSH2_MSG_DISCONNECT);\r\n\tSSH2_dispatch_add_message(SSH2_MSG_UNIMPLEMENTED);\r\n}\r\n\r\nint SSH2_dispatch_enabled_check(unsigned char message)\r\n{\r\n\tint i;\r\n\r\n\tfor (i = 0 ; i < handle_message_count ; i++) {\r\n\t\tif (handle_messages[i] == message)\r\n\t\t\treturn 1;\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\nvoid SSH2_dispatch_add_message(unsigned char message)\r\n{\r\n\tint i;\r\n\r\n\tif (handle_message_count >= HANDLE_MESSAGE_MAX) {\r\n\t\t// TODO: error check\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: too many handlers. handlers:%d, max:%d\", __FUNCTION__,\r\n\t\t\thandle_message_count, HANDLE_MESSAGE_MAX);\r\n\t\treturn;\r\n\t}\r\n\r\n\t// \ufffd\ufffd\ufffd\u0142\u0253o\ufffd^\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u90c1\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd\u0352\u01c9\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\r\n\tfor (i=0; i<handle_message_count; i++) {\r\n\t\tif (handle_messages[i] == message) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\r\n\thandle_messages[handle_message_count++] = message;\r\n}\r\n\r\nvoid SSH2_dispatch_add_range_message(unsigned char begin, unsigned char end)\r\n{\r\n\tunsigned char c;\r\n\r\n\tfor (c = begin ; c <= end ; c++) {\r\n\t\tSSH2_dispatch_add_message(c);\r\n\t}\r\n}\r\n\r\nvoid SSH1_handle_packet(PTInstVar pvar, char *data, unsigned int len, unsigned int padding)\r\n{\r\n\tunsigned char message = prep_packet_ssh1(pvar, data, len, padding);\r\n\r\n\t// SSH\ufffd\u0303\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd^\ufffdC\ufffdv\ufffd\ufffd\ufffd`\ufffdF\ufffdb\ufffdN\r\n\tif (message != SSH_MSG_NONE) {\r\n\t\t// \ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd^\ufffdC\ufffdv\ufffd\u0249\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdn\ufffd\ufffd\ufffdh\ufffd\ufffd\ufffd\ufffd\ufffdN\ufffd\ufffd\r\n\t\tSSHPacketHandler handler = get_handler(pvar, message);\r\n\r\n\t\tif (handler == NULL) {\r\n\t\t\tchar buf[1024];\r\n\r\n\t\t\tUTIL_get_lang_msg(\"MSG_SSH_UNEXP_MSG_ERROR\", pvar, \"Unexpected packet type received: %d\");\r\n\t\t\t_snprintf_s(buf, sizeof(buf), _TRUNCATE, pvar->UIMsg, message, handle_message_stage);\r\n\t\t\tnotify_fatal_error(pvar, buf, TRUE);\r\n\t\t} else {\r\n\t\t\tif (!handler(pvar)) {\r\n\t\t\t\tdeque_handlers(pvar, message);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid SSH2_handle_packet(PTInstVar pvar, char *data, unsigned int len, unsigned int aadlen, unsigned int authlen)\r\n{\r\n\tunsigned char message = prep_packet_ssh2(pvar, data, len, aadlen, authlen);\r\n\r\n\t// SSH\ufffd\u0303\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd^\ufffdC\ufffdv\ufffd\ufffd\ufffd`\ufffdF\ufffdb\ufffdN\r\n\tif (message != SSH_MSG_NONE) {\r\n\t\t// \ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd^\ufffdC\ufffdv\ufffd\u0249\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdn\ufffd\ufffd\ufffdh\ufffd\ufffd\ufffd\ufffd\ufffdN\ufffd\ufffd\r\n\t\tSSHPacketHandler handler = get_handler(pvar, message);\r\n\r\n\t\t// \ufffdz\ufffd\ufffdO\ufffd\u0303\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd^\ufffdC\ufffdv\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdA\ufffd{\ufffd[\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\tif (!SSH2_dispatch_enabled_check(message) || handler == NULL) {\r\n\t\t\tchar buf[1024];\r\n\r\n\t\t\tUTIL_get_lang_msg(\"MSG_SSH_UNEXP_MSG2_ERROR\", pvar, \"Unexpected SSH2 message(%d) on current stage(%d)\");\r\n\t\t\t_snprintf_s(buf, sizeof(buf), _TRUNCATE, pvar->UIMsg, message, handle_message_stage);\r\n\t\t\tnotify_fatal_error(pvar, buf, TRUE);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (handler == NULL) {\r\n\t\t\tunsigned char *outmsg = begin_send_packet(pvar, SSH2_MSG_UNIMPLEMENTED, 4);\r\n\r\n\t\t\tset_uint32(outmsg, pvar->ssh_state.receiver_sequence_number - 1);\r\n\t\t\tfinish_send_packet(pvar);\r\n\r\n\t\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: SSH2_MSG_UNIMPLEMENTED was sent.\", __FUNCTION__);\r\n\t\t\t/* XXX need to decompress incoming packet, but how? */\r\n\t\t} else {\r\n\t\t\tif (!handler(pvar)) {\r\n\t\t\t\tdeque_handlers(pvar, message);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstatic BOOL handle_pty_success(PTInstVar pvar)\r\n{\r\n\tFWD_enter_interactive_mode(pvar);\r\n\tenque_handler(pvar, SSH_SMSG_EXITSTATUS, handle_exit);\r\n\tenque_handler(pvar, SSH_SMSG_STDOUT_DATA, handle_data);\r\n\tenque_handler(pvar, SSH_SMSG_STDERR_DATA, handle_data);\r\n\tenque_handler(pvar, SSH_MSG_CHANNEL_DATA, handle_channel_data);\r\n\tenque_handler(pvar, SSH_MSG_CHANNEL_INPUT_EOF, handle_channel_input_eof);\r\n\tenque_handler(pvar, SSH_MSG_CHANNEL_OUTPUT_CLOSED, handle_channel_output_eof);\r\n\tenque_handler(pvar, SSH_MSG_PORT_OPEN, handle_channel_open);\r\n\tenque_handler(pvar, SSH_SMSG_X11_OPEN, handle_X11_channel_open);\r\n\tenque_handler(pvar, SSH_SMSG_AGENT_OPEN, handle_agent_open);\r\n\treturn FALSE;\r\n}\r\n\r\nstatic BOOL handle_pty_failure(PTInstVar pvar)\r\n{\r\n\tUTIL_get_lang_msg(\"MSG_SSH_ALLOC_TERMINAL_ERROR\", pvar,\r\n\t                  \"The server cannot allocate a pseudo-terminal. \"\r\n\t                  \"You may encounter some problems with the terminal.\");\r\n\tnotify_nonfatal_error(pvar, pvar->UIMsg);\r\n\treturn handle_pty_success(pvar);\r\n}\r\n\r\nstatic void prep_pty(PTInstVar pvar)\r\n{\r\n\tint len = strlen(pvar->ts->TermType);\r\n\tunsigned char *outmsg = begin_send_packet(pvar, SSH_CMSG_REQUEST_PTY, 4 + len + 16 + sizeof(ssh_ttymodes));\r\n\tstatic const int msgs[] = { SSH_SMSG_SUCCESS, SSH_SMSG_FAILURE };\r\n\tstatic const SSHPacketHandler handlers[]\r\n\t= { handle_pty_success, handle_pty_failure };\r\n\tint x, y;\r\n\r\n\tget_window_pixel_size(pvar, &x, &y);\r\n\r\n\tset_uint32(outmsg, len);\r\n\tmemcpy(outmsg + 4, pvar->ts->TermType, len);\r\n\tset_uint32(outmsg + 4 + len, pvar->ssh_state.win_rows);\r\n\tset_uint32(outmsg + 4 + len + 4, pvar->ssh_state.win_cols);\r\n\tset_uint32(outmsg + 4 + len + 8, x);\r\n\tset_uint32(outmsg + 4 + len + 12, y);\r\n\tmemcpy(outmsg + 4 + len + 16, ssh_ttymodes, sizeof(ssh_ttymodes));\r\n\tfinish_send_packet(pvar);\r\n\r\n\tenque_handlers(pvar, 2, msgs, handlers);\r\n\r\n\tbegin_send_packet(pvar, SSH_CMSG_EXEC_SHELL, 0);\r\n\tfinish_send_packet(pvar);\r\n}\r\n\r\nstatic BOOL handle_agent_request_success(PTInstVar pvar)\r\n{\r\n\tpvar->agentfwd_enable = TRUE;\r\n\tprep_pty(pvar);\r\n\treturn FALSE;\r\n}\r\n\r\nstatic BOOL handle_agent_request_failure(PTInstVar pvar)\r\n{\r\n\tprep_pty(pvar);\r\n\treturn FALSE;\r\n}\r\n\r\nstatic void prep_agent_request(PTInstVar pvar)\r\n{\r\n\tstatic const int msgs[] = { SSH_SMSG_SUCCESS, SSH_SMSG_FAILURE };\r\n\tstatic const SSHPacketHandler handlers[] = { handle_agent_request_success, handle_agent_request_failure };\r\n\r\n\tenque_handlers(pvar, 2, msgs, handlers);\r\n\r\n\tbegin_send_packet(pvar, SSH_CMSG_AGENT_REQUEST_FORWARDING, 0);\r\n\tfinish_send_packet(pvar);\r\n}\r\n\r\nstatic void prep_forwarding(PTInstVar pvar)\r\n{\r\n\tFWD_prep_forwarding(pvar);\r\n\r\n\tif (pvar->session_settings.ForwardAgent) {\r\n\t\tprep_agent_request(pvar);\r\n\t}\r\n\telse {\r\n\t\tprep_pty(pvar);\r\n\t}\r\n}\r\n\r\n//\r\n//\r\n// (2005.7.10 yutaka)\r\nstatic void enable_send_compression(PTInstVar pvar)\r\n{\r\n\tstatic int initialize = 0;\r\n\r\n\tif (initialize) {\r\n\t\tdeflateEnd(&pvar->ssh_state.compress_stream);\r\n\t}\r\n\tinitialize = 1;\r\n\r\n\tpvar->ssh_state.compress_stream.zalloc = NULL;\r\n\tpvar->ssh_state.compress_stream.zfree = NULL;\r\n\tpvar->ssh_state.compress_stream.opaque = NULL;\r\n\tif (deflateInit(&pvar->ssh_state.compress_stream, pvar->ssh_state.compression_level) != Z_OK) {\r\n\t\tUTIL_get_lang_msg(\"MSG_SSH_SETUP_COMP_ERROR\", pvar,\r\n\t\t                  \"An error occurred while setting up compression.\\n\"\r\n\t\t                  \"The connection will close.\");\r\n\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\treturn;\r\n\t} else {\r\n\t\t// SSH2\ufffd\u0142\u0348\ufffd\ufffdk\ufffdE\ufffdW\ufffdJ\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdSSH1\ufffd\u0182\u0355\u0282\u024ds\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\ufffd\ufffdL\ufffdt\ufffd\ufffd\ufffdO\ufffd\u0357\ufffd\ufffd\u0182\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffdB(2005.7.9 yutaka)\r\n\t\tif (SSHv2(pvar)) {\r\n\t\t\tpvar->ssh_state.compressing = FALSE;\r\n\t\t} else {\r\n\t\t\tpvar->ssh_state.compressing = TRUE;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstatic void enable_recv_compression(PTInstVar pvar)\r\n{\r\n\tstatic int initialize = 0;\r\n\r\n\tif (initialize) {\r\n\t\tdeflateEnd(&pvar->ssh_state.decompress_stream);\r\n\t}\r\n\tinitialize = 1;\r\n\r\n\tpvar->ssh_state.decompress_stream.zalloc = NULL;\r\n\tpvar->ssh_state.decompress_stream.zfree = NULL;\r\n\tpvar->ssh_state.decompress_stream.opaque = NULL;\r\n\tif (inflateInit(&pvar->ssh_state.decompress_stream) != Z_OK) {\r\n\t\tdeflateEnd(&pvar->ssh_state.compress_stream);\r\n\t\tUTIL_get_lang_msg(\"MSG_SSH_SETUP_COMP_ERROR\", pvar,\r\n\t\t                  \"An error occurred while setting up compression.\\n\"\r\n\t\t                  \"The connection will close.\");\r\n\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\treturn;\r\n\t} else {\r\n\t\t// SSH2\ufffd\u0142\u0348\ufffd\ufffdk\ufffdE\ufffdW\ufffdJ\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdSSH1\ufffd\u0182\u0355\u0282\u024ds\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\ufffd\ufffdL\ufffdt\ufffd\ufffd\ufffdO\ufffd\u0357\ufffd\ufffd\u0182\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffdB(2005.7.9 yutaka)\r\n\t\tif (SSHv2(pvar)) {\r\n\t\t\tpvar->ssh_state.decompressing = FALSE;\r\n\t\t} else {\r\n\t\t\tpvar->ssh_state.decompressing = TRUE;\r\n\t\t}\r\n\r\n\t\tbuf_ensure_size(&pvar->ssh_state.postdecompress_inbuf, &pvar->ssh_state.postdecompress_inbuflen, 1000);\r\n\t}\r\n}\r\n\r\nstatic void enable_compression(PTInstVar pvar)\r\n{\r\n\tenable_send_compression(pvar);\r\n\tenable_recv_compression(pvar);\r\n\r\n\t// SSH2\ufffd\u0142\u0348\ufffd\ufffdk\ufffdE\ufffdW\ufffdJ\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdSSH1\ufffd\u0182\u0355\u0282\u024ds\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\ufffd\ufffdL\ufffdt\ufffd\ufffd\ufffdO\ufffd\u0357\ufffd\ufffd\u0182\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffdB(2005.7.9 yutaka)\r\n\tif (SSHv2(pvar)) {\r\n\t\tpvar->ssh_state.compressing = FALSE;\r\n\t\tpvar->ssh_state.decompressing = FALSE;\r\n\t}\r\n}\r\n\r\nstatic BOOL handle_enable_compression(PTInstVar pvar)\r\n{\r\n\tenable_compression(pvar);\r\n\tprep_forwarding(pvar);\r\n\treturn FALSE;\r\n}\r\n\r\nstatic BOOL handle_disable_compression(PTInstVar pvar)\r\n{\r\n\tprep_forwarding(pvar);\r\n\treturn FALSE;\r\n}\r\n\r\nstatic void prep_compression(PTInstVar pvar)\r\n{\r\n\tif (pvar->session_settings.CompressionLevel > 0) {\r\n\t\t// added if statement (2005.7.10 yutaka)\r\n\t\tif (SSHv1(pvar)) {\r\n\t\t\tstatic const int msgs[] = { SSH_SMSG_SUCCESS, SSH_SMSG_FAILURE };\r\n\t\t\tstatic const SSHPacketHandler handlers[] = { handle_enable_compression, handle_disable_compression };\r\n\r\n\t\t\tunsigned char *outmsg = begin_send_packet(pvar, SSH_CMSG_REQUEST_COMPRESSION, 4);\r\n\r\n\t\t\tset_uint32(outmsg, pvar->session_settings.CompressionLevel);\r\n\t\t\tfinish_send_packet(pvar);\r\n\r\n\t\t\tenque_handlers(pvar, 2, msgs, handlers);\r\n\t\t}\r\n\r\n\t\tpvar->ssh_state.compression_level = pvar->session_settings.CompressionLevel;\r\n\r\n\t} else {\r\n\t\t// added if statement (2005.7.10 yutaka)\r\n\t\tif (SSHv1(pvar)) {\r\n\t\t\tprep_forwarding(pvar);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstatic void enque_simple_auth_handlers(PTInstVar pvar)\r\n{\r\n\tstatic const int msgs[] = { SSH_SMSG_SUCCESS, SSH_SMSG_FAILURE };\r\n\tstatic const SSHPacketHandler handlers[] = { handle_auth_success, handle_auth_failure };\r\n\r\n\tenque_handlers(pvar, 2, msgs, handlers);\r\n}\r\n\r\nstatic BOOL handle_rsa_challenge(PTInstVar pvar)\r\n{\r\n\tint challenge_bytes;\r\n\r\n\tif (!grab_payload(pvar, 2)) {\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tchallenge_bytes = get_mpint_len(pvar, 0);\r\n\r\n\tif (grab_payload(pvar, challenge_bytes)) {\r\n\t\tunsigned char *outmsg = begin_send_packet(pvar, SSH_CMSG_AUTH_RSA_RESPONSE, 16);\r\n\r\n\t\t// rhosts\ufffdF\ufffd\ufffd(SSH1)\ufffd\ufffd\ufffd\u0142\ufffd\ufffd\ufffd\u60a4\ufffd\ufffd SSH_AUTH_RHOSTS_RSA \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0252\u01c9\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\tif (pvar->auth_state.cur_cred.method == SSH_AUTH_RSA ||\r\n\t\t\tpvar->auth_state.cur_cred.method == SSH_AUTH_RHOSTS_RSA\r\n\t\t\t) {\r\n\t\t\tif (CRYPT_generate_RSA_challenge_response\r\n\t\t\t\t(pvar, pvar->ssh_state.payload + 2, challenge_bytes, outmsg)) {\r\n\r\n\t\t\t\t// \ufffdZ\ufffdb\ufffdV\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0243p\ufffdX\ufffd\ufffd\ufffd[\ufffdh\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffd\ud8cb\udd42\ufffd\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\ufffd\ufffd\ufffd\ufffd\u0142\u0303\ufffd\ufffd\\\ufffd[\ufffdX\ufffd\ufffd\ufffd\ufffd\u0342\ufffd\u07c2\ufffdB\r\n\t\t\t\t// socket close\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\ufffd\ufffd\u030a\u0590\ufffd\ufffd\u034c\u0102\u0382\ufffd\u0102\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\ufffd\ufffd\u0502\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB(2005.4.8 yutaka)\r\n\t\t\t\t//AUTH_destroy_cur_cred(pvar);\r\n\r\n\t\t\t\tfinish_send_packet(pvar);\r\n\r\n\t\t\t\tenque_simple_auth_handlers(pvar);\r\n\t\t\t} else {\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_DECRYPT_RSA_ERROR\", pvar,\r\n\t\t\t\t\t\t\t\t  \"An error occurred while decrypting the RSA challenge.\\n\"\r\n\t\t\t\t\t\t\t\t  \"Perhaps the key file is corrupted.\");\r\n\t\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (pvar->auth_state.cur_cred.method == SSH_AUTH_PAGEANT) {\r\n\t\t\tint server_key_bits;\r\n\t\t\tint host_key_bits;\r\n\t\t\tint server_key_bytes;\r\n\t\t\tint host_key_bytes;\r\n\t\t\tint session_buf_len;\r\n\t\t\tchar *session_buf;\r\n\t\t\tunsigned char session_id[16];\r\n\r\n\t\t\tunsigned char *hash;\r\n\t\t\tint pubkeylen, hashlen;\r\n\t\t\tBIGNUM *server_n, *host_n;\r\n\r\n\t\t\tRSA_get0_key(pvar->crypt_state.server_key.RSA_key, &server_n, NULL, NULL);\r\n\t\t\tRSA_get0_key(pvar->crypt_state.host_key.RSA_key, &host_n, NULL, NULL);\r\n\t\t\tserver_key_bits = BN_num_bits(server_n);\r\n\t\t\thost_key_bits = BN_num_bits(host_n);\r\n\t\t\tserver_key_bytes = (server_key_bits + 7) / 8;\r\n\t\t\thost_key_bytes = (host_key_bits + 7) / 8;\r\n\t\t\tsession_buf_len = server_key_bytes + host_key_bytes + 8;\r\n\t\t\tsession_buf = (char *) malloc(session_buf_len);\r\n\r\n\t\t\t/* Pageant \ufffd\u0243n\ufffdb\ufffdV\ufffd\ufffd\ufffd\ufffd\ufffdv\ufffdZ\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u70a4 */\r\n\t\t\t// \ufffd\ufffd\ufffdJ\ufffd\ufffd\ufffd\u0312\ufffd\ufffd\ufffd\r\n\t\t\tpubkeylen = putty_get_ssh1_keylen(pvar->pageant_curkey, pvar->pageant_keylistlen);\r\n\t\t\t// \ufffdZ\ufffdb\ufffdV\ufffd\ufffd\ufffd\ufffdID\ufffd\ufffd\ufffd\uc42c\r\n\t\t\tBN_bn2bin(host_n, session_buf);\r\n\t\t\tBN_bn2bin(server_n, session_buf + host_key_bytes);\r\n\t\t\tmemcpy(session_buf + server_key_bytes + host_key_bytes, pvar->crypt_state.server_cookie, 8);\r\n\t\t\tMD5(session_buf, session_buf_len, session_id);\r\n\t\t\t// \ufffdn\ufffdb\ufffdV\ufffd\ufffd\ufffd\ufffd\ufffd\udaca\udfce\ufffd\ufffd\r\n\t\t\thash = putty_hash_ssh1_challenge(pvar->pageant_curkey,\r\n\t\t\t                                 pubkeylen,\r\n\t\t\t                                 pvar->ssh_state.payload,\r\n\t\t\t                                 challenge_bytes + 2,\r\n\t\t\t                                 session_id,\r\n\t\t\t                                 &hashlen);\r\n\r\n\t\t\t// \ufffdn\ufffdb\ufffdV\ufffd\ufffd\ufffd\ud805\uddd0M\r\n\t\t\tmemcpy(outmsg, hash, 16);\r\n\t\t\tfree(hash);\r\n\r\n\t\t\tfinish_send_packet(pvar);\r\n\r\n\t\t\tenque_simple_auth_handlers(pvar);\r\n\t\t}\r\n\t}\r\n\r\n\treturn FALSE;\r\n}\r\n\r\nstatic void try_send_credentials(PTInstVar pvar)\r\n{\r\n\tBIGNUM *e, *n;\r\n\r\n\tif ((pvar->ssh_state.status_flags & STATUS_DONT_SEND_CREDENTIALS) == 0) {\r\n\t\tAUTHCred *cred = AUTH_get_cur_cred(pvar);\r\n\t\tstatic const int RSA_msgs[] =\r\n\t\t\t{ SSH_SMSG_AUTH_RSA_CHALLENGE, SSH_SMSG_FAILURE };\r\n\t\tstatic const SSHPacketHandler RSA_handlers[]\r\n\t\t= { handle_rsa_challenge, handle_rsa_auth_refused };\r\n\t\tstatic const int TIS_msgs[] =\r\n\t\t\t{ SSH_SMSG_AUTH_TIS_CHALLENGE, SSH_SMSG_FAILURE };\r\n\t\tstatic const SSHPacketHandler TIS_handlers[]\r\n\t\t= { handle_TIS_challenge, handle_auth_failure };\r\n\r\n\t\t// SSH2\ufffd\u030f\ua347\ufffd\u0348\u0209\ufffd\ufffd\u030f\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdX\ufffdL\ufffdb\ufffdv\r\n\t\tif (SSHv2(pvar))\r\n\t\t\tgoto skip_ssh2;\r\n\r\n\t\tswitch (cred->method) {\r\n\t\tcase SSH_AUTH_NONE:\r\n\t\t\treturn;\r\n\t\tcase SSH_AUTH_PASSWORD:{\r\n\t\t\t\tint len = strlen(cred->password);\r\n\t\t\t\tunsigned char *outmsg =\r\n\t\t\t\t\tbegin_send_packet(pvar, SSH_CMSG_AUTH_PASSWORD,\r\n\t\t\t\t\t                  4 + len);\r\n\r\n\t\t\t\tlogputs(LOG_LEVEL_VERBOSE, \"Trying PASSWORD authentication...\");\r\n\r\n\t\t\t\tset_uint32(outmsg, len);\r\n\t\t\t\tmemcpy(outmsg + 4, cred->password, len);\r\n\r\n\t\t\t\t// \ufffdZ\ufffdb\ufffdV\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0243p\ufffdX\ufffd\ufffd\ufffd[\ufffdh\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffd\ud8cb\udd42\ufffd\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\ufffd\ufffd\ufffd\ufffd\u0142\u0303\ufffd\ufffd\\\ufffd[\ufffdX\ufffd\ufffd\ufffd\ufffd\u0342\ufffd\u07c2\ufffdB\r\n\t\t\t\t// socket close\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\ufffd\ufffd\u030a\u0590\ufffd\ufffd\u034c\u0102\u0382\ufffd\u0102\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\ufffd\ufffd\u0502\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB(2005.4.8 yutaka)\r\n\t\t\t\t//AUTH_destroy_cur_cred(pvar);\r\n\r\n\t\t\t\tenque_simple_auth_handlers(pvar);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\tcase SSH_AUTH_RHOSTS:{\r\n\t\t\t\tint len = strlen(cred->rhosts_client_user);\r\n\t\t\t\tunsigned char *outmsg =\r\n\t\t\t\t\tbegin_send_packet(pvar, SSH_CMSG_AUTH_RHOSTS, 4 + len);\r\n\r\n\t\t\t\tlogputs(LOG_LEVEL_VERBOSE, \"Trying RHOSTS authentication...\");\r\n\r\n\t\t\t\tset_uint32(outmsg, len);\r\n\t\t\t\tmemcpy(outmsg + 4, cred->rhosts_client_user, len);\r\n\t\t\t\tAUTH_destroy_cur_cred(pvar);\r\n\t\t\t\tenque_simple_auth_handlers(pvar);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\tcase SSH_AUTH_RSA:{\r\n\t\t\t\tint len;\r\n\t\t\t\tunsigned char *outmsg;\r\n\r\n\t\t\t\tRSA_get0_key(cred->key_pair->rsa, &n, NULL, NULL);\r\n\t\t\t\tlen = BN_num_bytes(n);\r\n\t\t\t\toutmsg = begin_send_packet(pvar, SSH_CMSG_AUTH_RSA, 2 + len);\r\n\r\n\t\t\t\tlogputs(LOG_LEVEL_VERBOSE, \"Trying RSA authentication...\");\r\n\r\n\t\t\t\tset_ushort16_MSBfirst(outmsg, len * 8);\r\n\t\t\t\tBN_bn2bin(n, outmsg + 2);\r\n\t\t\t\t/* don't destroy the current credentials yet */\r\n\t\t\t\tenque_handlers(pvar, 2, RSA_msgs, RSA_handlers);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\tcase SSH_AUTH_RHOSTS_RSA:{\r\n\t\t\t\tint mod_len;\r\n\t\t\t\tint name_len;\r\n\t\t\t\tint exp_len;\r\n\t\t\t\tint index;\r\n\t\t\t\tunsigned char *outmsg;\r\n\r\n\t\t\t\tRSA_get0_key(cred->key_pair->rsa, &n, &e, NULL);\r\n\t\t\t\tmod_len = BN_num_bytes(n);\r\n\t\t\t\tname_len = strlen(cred->rhosts_client_user);\r\n\t\t\t\texp_len = BN_num_bytes(e);\r\n\t\t\t\toutmsg = begin_send_packet(pvar, SSH_CMSG_AUTH_RHOSTS_RSA,\r\n\t\t\t\t\t                       12 + mod_len + name_len + exp_len);\r\n\r\n\t\t\t\tlogputs(LOG_LEVEL_VERBOSE, \"Trying RHOSTS+RSA authentication...\");\r\n\r\n\t\t\t\tset_uint32(outmsg, name_len);\r\n\t\t\t\tmemcpy(outmsg + 4, cred->rhosts_client_user, name_len);\r\n\t\t\t\tindex = 4 + name_len;\r\n\r\n\t\t\t\tset_uint32(outmsg + index, 8 * mod_len);\r\n\t\t\t\tset_ushort16_MSBfirst(outmsg + index + 4, 8 * exp_len);\r\n\t\t\t\tBN_bn2bin(e, outmsg + index + 6);\r\n\t\t\t\tindex += 6 + exp_len;\r\n\r\n\t\t\t\tset_ushort16_MSBfirst(outmsg + index, 8 * mod_len);\r\n\t\t\t\tBN_bn2bin(n, outmsg + index + 2);\r\n\t\t\t\t/* don't destroy the current credentials yet */\r\n\t\t\t\tenque_handlers(pvar, 2, RSA_msgs, RSA_handlers);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\tcase SSH_AUTH_PAGEANT:{\r\n\t\t\t\tunsigned char *outmsg;\r\n\t\t\t\tunsigned char *pubkey;\r\n\t\t\t\tint len, bn_bytes;\r\n\r\n\t\t\t\tif (pvar->pageant_keycurrent != 0) {\r\n\t\t\t\t\t// \ufffd\ufffd\ufffdO\ufffd\u030c\ufffd\ufffd\ufffd\ufffdX\ufffdL\ufffdb\ufffdv\r\n\t\t\t\t\tpvar->pageant_curkey += 4;\r\n\t\t\t\t\tlen = get_ushort16_MSBfirst(pvar->pageant_curkey);\r\n\t\t\t\t\tbn_bytes = (len + 7) / 8;\r\n\t\t\t\t\tpvar->pageant_curkey += 2 + bn_bytes;\r\n\t\t\t\t\tlen = get_ushort16_MSBfirst(pvar->pageant_curkey);\r\n\t\t\t\t\tbn_bytes = (len + 7) / 8;\r\n\t\t\t\t\tpvar->pageant_curkey += 2 + bn_bytes;\r\n\t\t\t\t\t// \ufffd\ufffd\ufffdO\ufffd\u030c\ufffd\ufffd\u0303R\ufffd\ufffd\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffdX\ufffdL\ufffdb\ufffdv\r\n\t\t\t\t\tlen = get_uint32_MSBfirst(pvar->pageant_curkey);\r\n\t\t\t\t\tpvar->pageant_curkey += 4 + len;\r\n\t\t\t\t\t// \ufffd\ufffd\ufffd\u030c\ufffd\ufffd\u0308\u0292u\ufffd\u0597\ufffd\ufffd\ufffd\r\n\t\t\t\t}\r\n\t\t\t\tpubkey = pvar->pageant_curkey + 4;\r\n\t\t\t\tlen = get_ushort16_MSBfirst(pubkey);\r\n\t\t\t\tbn_bytes = (len + 7) / 8;\r\n\t\t\t\tpubkey += 2 + bn_bytes;\r\n\t\t\t\tlen = get_ushort16_MSBfirst(pubkey);\r\n\t\t\t\tbn_bytes = (len + 7) / 8;\r\n\t\t\t\tpubkey += 2;\r\n\t\t\t\toutmsg = begin_send_packet(pvar, SSH_CMSG_AUTH_RSA, 2 + bn_bytes);\r\n\r\n\t\t\t\tlogputs(LOG_LEVEL_VERBOSE, \"Trying RSA authentication...\");\r\n\r\n\t\t\t\tset_ushort16_MSBfirst(outmsg, bn_bytes * 8);\r\n\t\t\t\tmemcpy(outmsg + 2, pubkey, bn_bytes);\r\n\t\t\t\t/* don't destroy the current credentials yet */\r\n\r\n\t\t\t\tpvar->pageant_keycurrent++;\r\n\r\n\t\t\t\tenque_handlers(pvar, 2, RSA_msgs, RSA_handlers);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\tcase SSH_AUTH_TIS:{\r\n\t\t\t\tif (cred->password == NULL) {\r\n\t\t\t\t\tunsigned char *outmsg =\r\n\t\t\t\t\t\tbegin_send_packet(pvar, SSH_CMSG_AUTH_TIS, 0);\r\n\r\n\t\t\t\t\tlogputs(LOG_LEVEL_VERBOSE, \"Trying TIS authentication...\");\r\n\t\t\t\t\tenque_handlers(pvar, 2, TIS_msgs, TIS_handlers);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tint len = strlen(cred->password);\r\n\t\t\t\t\tunsigned char *outmsg =\r\n\t\t\t\t\t\tbegin_send_packet(pvar, SSH_CMSG_AUTH_TIS_RESPONSE,\r\n\t\t\t\t\t\t                  4 + len);\r\n\r\n\t\t\t\t\tlogputs(LOG_LEVEL_VERBOSE, \"Sending TIS response\");\r\n\r\n\t\t\t\t\tset_uint32(outmsg, len);\r\n\t\t\t\t\tmemcpy(outmsg + 4, cred->password, len);\r\n\t\t\t\t\tenque_simple_auth_handlers(pvar);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tAUTH_destroy_cur_cred(pvar);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\tdefault:\r\n\t\t\tUTIL_get_lang_msg(\"MSG_SSH_UNSUPPORT_AUTH_METHOD_ERROR\", pvar,\r\n\t\t\t                  \"Internal error: unsupported authentication method\");\r\n\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfinish_send_packet(pvar);\r\n\r\nskip_ssh2:;\r\n\t\tdestroy_packet_buf(pvar);\r\n\r\n\t\tpvar->ssh_state.status_flags |= STATUS_DONT_SEND_CREDENTIALS;\r\n\t}\r\n}\r\n\r\nstatic void try_send_user_name(PTInstVar pvar)\r\n{\r\n\tif ((pvar->ssh_state.status_flags & STATUS_DONT_SEND_USER_NAME) == 0) {\r\n\t\tchar *username = AUTH_get_user_name(pvar);\r\n\r\n\t\tif (username != NULL) {\r\n\t\t\tint len = strlen(username);\r\n\t\t\tunsigned char *outmsg =\r\n\t\t\t\tbegin_send_packet(pvar, SSH_CMSG_USER, 4 + len);\r\n\t\t\tstatic const int msgs[] =\r\n\t\t\t\t{ SSH_SMSG_SUCCESS, SSH_SMSG_FAILURE };\r\n\t\t\tstatic const SSHPacketHandler handlers[]\r\n\t\t\t= { handle_noauth_success, handle_auth_required };\r\n\r\n\t\t\tset_uint32(outmsg, len);\r\n\t\t\tmemcpy(outmsg + 4, username, len);\r\n\t\t\tfinish_send_packet(pvar);\r\n\r\n\t\t\tpvar->ssh_state.status_flags |= STATUS_DONT_SEND_USER_NAME;\r\n\r\n\t\t\tlogprintf(LOG_LEVEL_VERBOSE, \"Sending user name: %s\", username);\r\n\r\n\t\t\tenque_handlers(pvar, 2, msgs, handlers);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstatic void send_session_key(PTInstVar pvar)\r\n{\r\n\tint encrypted_session_key_len;\r\n\tunsigned char *outmsg;\r\n\r\n\tif (SSHv1(pvar)) {\r\n\t\tencrypted_session_key_len =\r\n\t\t\tCRYPT_get_encrypted_session_key_len(pvar);\r\n\t}\r\n\r\n\tif (!CRYPT_choose_ciphers(pvar))\r\n\t\treturn;\r\n\r\n\tif (SSHv1(pvar)) {\r\n\t\toutmsg =\r\n\t\t\tbegin_send_packet(pvar, SSH_CMSG_SESSION_KEY,\r\n\t\t\t                  15 + encrypted_session_key_len);\r\n\t\toutmsg[0] = (unsigned char) CRYPT_get_sender_cipher(pvar);\r\n\t\tmemcpy(outmsg + 1, CRYPT_get_server_cookie(pvar), 8);\t/* antispoofing cookie */\r\n\t\toutmsg[9] = (unsigned char) (encrypted_session_key_len >> 5);\r\n\t\toutmsg[10] = (unsigned char) (encrypted_session_key_len << 3);\r\n\t\tif (!CRYPT_choose_session_key(pvar, outmsg + 11))\r\n\t\t\treturn;\r\n\t\tset_uint32(outmsg + 11 + encrypted_session_key_len,\r\n\t\t           SSH_PROTOFLAG_SCREEN_NUMBER |\r\n\t\t           SSH_PROTOFLAG_HOST_IN_FWD_OPEN);\r\n\t\tfinish_send_packet(pvar);\r\n\t}\r\n\r\n\tif (!CRYPT_start_encryption(pvar, 1, 1))\r\n\t\treturn;\r\n\tnotify_established_secure_connection(pvar);\r\n\r\n\tif (SSHv1(pvar)) {\r\n\t\tenque_handler(pvar, SSH_SMSG_SUCCESS, handle_crypt_success);\r\n\t}\r\n\r\n\tpvar->ssh_state.status_flags &= ~STATUS_DONT_SEND_USER_NAME;\r\n\r\n\tif (SSHv1(pvar)) {\r\n\t\ttry_send_user_name(pvar);\r\n\t}\r\n}\r\n\r\n/*************************\r\n   END of message handlers\r\n   ************************/\r\n\r\nvoid SSH_init(PTInstVar pvar)\r\n{\r\n\tint i;\r\n\r\n\tbuf_create(&pvar->ssh_state.outbuf, &pvar->ssh_state.outbuflen);\r\n\tbuf_create(&pvar->ssh_state.precompress_outbuf,\r\n\t           &pvar->ssh_state.precompress_outbuflen);\r\n\tbuf_create(&pvar->ssh_state.postdecompress_inbuf,\r\n\t           &pvar->ssh_state.postdecompress_inbuflen);\r\n\tpvar->ssh_state.payload = NULL;\r\n\tpvar->ssh_state.compressing = FALSE;\r\n\tpvar->ssh_state.decompressing = FALSE;\r\n\tpvar->ssh_state.status_flags =\r\n\t\tSTATUS_DONT_SEND_USER_NAME | STATUS_DONT_SEND_CREDENTIALS;\r\n\tpvar->ssh_state.payload_datalen = 0;\r\n\tpvar->ssh_state.hostname = NULL;\r\n\tpvar->ssh_state.server_ID = NULL;\r\n\tpvar->ssh_state.receiver_sequence_number = 0;\r\n\tpvar->ssh_state.sender_sequence_number = 0;\r\n\tfor (i = 0; i < NUM_ELEM(pvar->ssh_state.packet_handlers); i++) {\r\n\t\tpvar->ssh_state.packet_handlers[i] = NULL;\r\n\t}\r\n\r\n\t// for SSH2(yutaka)\r\n\tmemset(pvar->ssh2_keys, 0, sizeof(pvar->ssh2_keys));\r\n\tpvar->userauth_success = 0;\r\n\tpvar->shell_id = SSH_CHANNEL_INVALID;\r\n\tpvar->session_nego_status = 0;\r\n\tpvar->settings.ssh_protocol_version = 2;  // SSH2(default)\r\n\tpvar->kex_status = 0;\r\n\tpvar->ssh2_autologin = 0;  // autologin disabled(default)\r\n\tpvar->ask4passwd = 0; // disabled(default) (2006.9.18 maya)\r\n\tpvar->userauth_retry_count = 0;\r\n\tpvar->decomp_buffer = NULL;\r\n\tpvar->authbanner_buffer = NULL;\r\n\tpvar->ssh2_authlist = NULL; // (2007.4.27 yutaka)\r\n\tpvar->tryed_ssh2_authlist = FALSE;\r\n\tpvar->agentfwd_enable = FALSE;\r\n\tpvar->use_subsystem = FALSE;\r\n\tpvar->nosession = FALSE;\r\n\tpvar->server_sig_algs = NULL;\r\n\tpvar->server_strict_kex = FALSE;\r\n\r\n}\r\n\r\nvoid SSH_open(PTInstVar pvar)\r\n{\r\n\tpvar->ssh_state.hostname = _strdup(pvar->ts->HostName);\r\n\tpvar->ssh_state.tcpport  = pvar->ts->TCPPort;\r\n\tpvar->ssh_state.win_cols = pvar->ts->TerminalWidth;\r\n\tpvar->ssh_state.win_rows = pvar->ts->TerminalHeight;\r\n}\r\n\r\nvoid SSH_notify_disconnecting(PTInstVar pvar, char *reason)\r\n{\r\n\tif (SSHv1(pvar)) {\r\n\t\tint len = reason == NULL ? 0 : strlen(reason);\r\n\t\tunsigned char *outmsg =\r\n\t\t\tbegin_send_packet(pvar, SSH_MSG_DISCONNECT, len + 4);\r\n\r\n\t\tset_uint32(outmsg, len);\r\n\t\tif (reason != NULL) {\r\n\t\t\tmemcpy(outmsg + 4, reason, len);\r\n\t\t}\r\n\t\tfinish_send_packet(pvar);\r\n\r\n\t} else { // for SSH2(yutaka)\r\n\t\tbuffer_t *msg;\r\n\t\tunsigned char *outmsg;\r\n\t\tchar *s;\r\n\t\tint len;\r\n\r\n\t\t// SSH2 server\ufffd\ufffddisconnect\ufffd\ufffd`\ufffd\ufffd\ufffd\ufffd\r\n\t\tmsg = buffer_init();\r\n\t\tif (msg == NULL) {\r\n\t\t\t// TODO: error check\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbuffer_put_int(msg, SSH2_DISCONNECT_BY_APPLICATION);\r\n\t\tbuffer_put_string(msg, reason, strlen(reason));\r\n\t\ts = \"\";\r\n\t\tbuffer_put_string(msg, s, strlen(s));\r\n\r\n\t\tlen = buffer_len(msg);\r\n\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_DISCONNECT, len);\r\n\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\tfinish_send_packet(pvar);\r\n\t\tbuffer_free(msg);\r\n\r\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_DISCONNECT was sent at SSH_notify_disconnecting().\");\r\n\t}\r\n}\r\n\r\nvoid ssh2_finish_encryption_setup(PTInstVar pvar)\r\n{\r\n\tnotify_established_secure_connection(pvar);\r\n\tpvar->ssh_state.status_flags &= ~STATUS_DONT_SEND_USER_NAME;\r\n}\r\n\r\nvoid SSH_notify_host_OK(PTInstVar pvar)\r\n{\r\n\tif ((pvar->ssh_state.status_flags & STATUS_HOST_OK) == 0) {\r\n\t\tpvar->ssh_state.status_flags |= STATUS_HOST_OK;\r\n\r\n\t\tif (SSHv1(pvar)) {\r\n\t\t\tsend_session_key(pvar);\r\n\t\t\t// \ufffd\ufffd\ufffd[\ufffdU\ufffdF\ufffd\u0602\ufffd\ufffds\ufffd\ufffd\ufffd\u0102\u60a2\ufffd^\ufffdC\ufffd~\ufffd\ufffd\ufffdO\ufffd\u0242\u0202\ufffd\ufffd\u0102\ufffd\ufffd\ufffdA\ufffdF\ufffd\u0603_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\ufffd\ufffdo\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\t\t// STATUS_HOST_OK\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdASTATUS_DONT_SEND_USER_NAME\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0202\ufffd\ufffd\u0181A\r\n\t\t\t// \ufffdF\ufffd\u0603_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\u034e\ufffd\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\u0302\u0141A\ufffd\ufffd\ufffd\u0303^\ufffdC\ufffd~\ufffd\ufffd\ufffdO\ufffd\u0156\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t\t\tAUTH_advance_to_next_cred(pvar);\r\n\t\t}\r\n\t}\r\n\r\n\tif (SSHv2(pvar)) {\r\n\t\t// SSH2_MSG_NEWKEYS \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdM\ufffd\u0202\ufffd\u0391\ufffd\ufffd\ufffd\r\n\t\tif ((pvar->kex_status & KEX_FLAG_NEWKEYS_SENT) == 0) {\r\n\t\t\tssh2_send_newkeys(pvar);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstatic void get_window_pixel_size(PTInstVar pvar, int *x, int *y)\r\n{\r\n\tRECT r;\r\n\r\n\tif (pvar->cv->HWin && GetWindowRect(pvar->cv->HWin, &r)) {\r\n\t\t*x = r.right - r.left;\r\n\t\t*y = r.bottom - r.top;\r\n\t}\r\n\telse {\r\n\t\t*x = 0;\r\n\t\t*y = 0;\r\n\t}\r\n\r\n\treturn;\r\n}\r\n\r\nvoid SSH_notify_win_size(PTInstVar pvar, int cols, int rows)\r\n{\r\n\tint x, y;\r\n\r\n\tpvar->ssh_state.win_cols = cols;\r\n\tpvar->ssh_state.win_rows = rows;\r\n\r\n\tget_window_pixel_size(pvar, &x, &y);\r\n\r\n\tif (SSHv1(pvar)) {\r\n\t\tif (get_handler(pvar, SSH_SMSG_STDOUT_DATA) == handle_data) {\r\n\t\t\tunsigned char *outmsg =\r\n\t\t\t\tbegin_send_packet(pvar, SSH_CMSG_WINDOW_SIZE, 16);\r\n\r\n\t\t\tset_uint32(outmsg, rows);     // window height (characters)\r\n\t\t\tset_uint32(outmsg + 4, cols); // window width  (characters)\r\n\t\t\tset_uint32(outmsg + 8, x);    // window width  (pixels)\r\n\t\t\tset_uint32(outmsg + 12, y);   // window height (pixels)\r\n\t\t\tfinish_send_packet(pvar);\r\n\t\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: sending SSH_CMSG_WINDOW_SIZE. \"\r\n\t\t\t          \"cols: %d, rows: %d, x: %d, y: %d\", __FUNCTION__, cols, rows, x, y);\r\n\t\t}\r\n\r\n\t} else if (SSHv2(pvar)) {\r\n\t\t// \ufffd^\ufffd[\ufffd~\ufffdi\ufffd\ufffd\ufffdT\ufffdC\ufffdY\ufffd\u03cdX\ufffd\u0292m\ufffd\u0312\u01c9\ufffd (2005.1.4 yutaka)\r\n\t\t// SSH2\ufffd\ufffd\ufffd\u01c2\ufffd\ufffd\ufffd\ufffd\u0303`\ufffdF\ufffdb\ufffdN\ufffd\ufffd\ufffds\ufffd\ufffd\ufffdB(2005.1.5 yutaka)\r\n\t\tbuffer_t *msg;\r\n\t\tchar *req_type = \"window-change\";\r\n\t\tunsigned char *outmsg;\r\n\t\tint len;\r\n\t\tChannel_t *c;\r\n\r\n\t\tc = ssh2_channel_lookup(pvar->shell_id);\r\n\t\tif (c == NULL) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: shell channel not found.\", __FUNCTION__);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (c->remote_id == SSH_CHANNEL_INVALID) {\r\n\t\t\t// \ufffd\ufffd\ufffd\u030f\udaef\udd42\u0354F\ufffd\u060a\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0243E\ufffdB\ufffd\ufffd\ufffdh\ufffdE\ufffdT\ufffdC\ufffdY\ufffd\ufffd\u03cdX\ufffd\ufffd\ufffd\ufffd\u0194\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\t\t// \ufffd\u0702\ufffd\ufffdV\ufffdF\ufffd\ufffd\ufffd\u0303`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\u0251\u0382\ufffd\ufffd\ufffd SSH_MSG_OPEN_CONFIRMATION \ufffd\ufffd\ufffd\udaca\udfc2\u0102\ufffd\ufffd\u0202\ufffd\ufffd\u0302\u0141A\r\n\t\t\t// \ufffd\ufffd\ufffd\u8464\ufffd\u0303`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\u050d\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\u0302\ufffd window-change \ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd\u0351\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: remote shell channel number is unknown.\", __FUNCTION__);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tmsg = buffer_init();\r\n\t\tif (msg == NULL) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbuffer_put_int(msg, c->remote_id);\r\n\t\tbuffer_put_string(msg, req_type, strlen(req_type));\r\n\t\tbuffer_put_char(msg, 0);    // want_reply\r\n\t\tbuffer_put_int(msg, cols);  // columns\r\n\t\tbuffer_put_int(msg, rows);  // lines\r\n\t\tbuffer_put_int(msg, x);     // window width (pixel):\r\n\t\tbuffer_put_int(msg, y);     // window height (pixel):\r\n\t\tlen = buffer_len(msg);\r\n\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_REQUEST, len);\r\n\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\tfinish_send_packet(pvar);\r\n\t\tbuffer_free(msg);\r\n\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: sending SSH2_MSG_CHANNEL_REQUEST. \"\r\n\t\t          \"local: %d, remote: %d, request-type: %s, cols: %d, rows: %d, x: %d, y: %d\", __FUNCTION__,\r\n\t\t          c->self_id, c->remote_id, req_type, cols, rows, x, y);\r\n\r\n\t} else {\r\n\t\t// SSH\ufffd\u0142\u0202\ufffd\ufffd\ua347\ufffd\u0349\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t}\r\n}\r\n\r\n// \ufffdu\ufffd\ufffd\ufffd[\ufffdN\ufffdM\ufffd\ufffd\ufffd\ud805\uddc2\ufffd -- RFC 4335\r\n// OpenSSH \ufffd\ufffd\"~B\"\ufffd\u0251\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n// (2010.9.27 yutaka)\r\nint SSH_notify_break_signal(PTInstVar pvar)\r\n{\r\n\tint ret = 0;\r\n\r\n\tif (SSHv2(pvar)) { // SSH2 \ufffd\u0302\u0751\u0389\ufffd\r\n\t\tbuffer_t *msg;\r\n\t\tchar *req_type = \"break\";\r\n\t\tunsigned char *outmsg;\r\n\t\tint len;\r\n\t\tChannel_t *c;\r\n\r\n\t\tc = ssh2_channel_lookup(pvar->shell_id);\r\n\t\tif (c == NULL) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: shell channel not found.\", __FUNCTION__);\r\n\t\t\tgoto error;\r\n\t\t}\r\n\t\tif (c->remote_id == SSH_CHANNEL_INVALID) {\r\n\t\t\t// \ufffdF\ufffd\u0612\ufffd\ufffd\ufffd\ufffd send break \ufffd\ufffd\ufffds\ufffd\ufffd\ufffd\u0194\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\t\t\t// \ufffd\u0702\ufffd\ufffdV\ufffdF\ufffd\ufffd\ufffd\u0303`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\u0251\u0382\ufffd\ufffd\ufffd SSH_MSG_OPEN_CONFIRMATION \ufffd\ufffd\ufffd\udaca\udfc2\u0102\ufffd\ufffd\u0202\ufffd\ufffd\u0302\u0141A\r\n\t\t\t// \ufffd\ufffd\ufffd\u8464\ufffd\u0303`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\u050d\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\u0302\ufffd break \ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd\u0351\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: remote shell channel number is unknown.\", __FUNCTION__);\r\n\t\t\tgoto error;\r\n\t\t}\r\n\r\n\t\tmsg = buffer_init();\r\n\t\tif (msg == NULL) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\tgoto error;\r\n\t\t}\r\n\t\tbuffer_put_int(msg, c->remote_id);\r\n\t\tbuffer_put_string(msg, req_type, strlen(req_type));\r\n\t\tbuffer_put_char(msg, 0);  // want_reply\r\n\t\tbuffer_put_int(msg, 1000);  // break-length (msec)\r\n\t\tlen = buffer_len(msg);\r\n\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_REQUEST, len);\r\n\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\tfinish_send_packet(pvar);\r\n\t\tbuffer_free(msg);\r\n\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: sending SSH2_MSG_CHANNEL_REQUEST. \"\r\n\t\t          \"local: %d, remote: %d, request-type: %s, break-length: %d\", __FUNCTION__,\r\n\t\t          c->self_id, c->remote_id, req_type, 1000);\r\n\r\n\t\tret = 1;\r\n\t}\r\n\r\nerror:\r\n\treturn (ret);\r\n}\r\n\r\nunsigned int SSH_get_min_packet_size(PTInstVar pvar)\r\n{\r\n\tif (SSHv1(pvar)) {\r\n\t\treturn 12;\r\n\t} else {\r\n\t\treturn max(16, CRYPT_get_decryption_block_size(pvar));\r\n\t}\r\n}\r\n\r\n/* data is guaranteed to be at least SSH_get_min_packet_size bytes long\r\n   at least 5 bytes must be decrypted */\r\nvoid SSH_predecrypt_packet(PTInstVar pvar, char *data)\r\n{\r\n\tif (SSHv2(pvar)) {\r\n\t\tCRYPT_decrypt(pvar, data, get_predecryption_amount(pvar));\r\n\t}\r\n}\r\n\r\nunsigned int SSH_get_clear_MAC_size(PTInstVar pvar)\r\n{\r\n\tif (SSHv1(pvar)) {\r\n\t\treturn 0;\r\n\t} else {\r\n\t\treturn CRYPT_get_receiver_MAC_size(pvar);\r\n\t}\r\n}\r\n\r\nunsigned int SSH_get_authdata_size(PTInstVar pvar, int direction)\r\n{\r\n\tif (SSHv1(pvar)) {\r\n\t\treturn 0;\r\n\t}\r\n\telse {\r\n\t\tstruct Mac *mac = &pvar->ssh2_keys[direction].mac;\r\n\t\tstruct Enc *enc = &pvar->ssh2_keys[direction].enc;\r\n\r\n\t\tif (enc && enc->auth_len > 0) {\r\n\t\t\t// AEAD\r\n\t\t\treturn enc->auth_len;\r\n\t\t}\r\n\t\telse if (mac && mac->enabled) {\r\n\t\t\treturn mac->mac_len;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid SSH_notify_user_name(PTInstVar pvar)\r\n{\r\n\ttry_send_user_name(pvar);\r\n}\r\n\r\nvoid SSH_notify_cred(PTInstVar pvar)\r\n{\r\n\ttry_send_credentials(pvar);\r\n}\r\n\r\nvoid SSH_send(PTInstVar pvar, unsigned char const *buf, unsigned int buflen)\r\n{\r\n\t// RAW\ufffdp\ufffdP\ufffdb\ufffdg\ufffd_\ufffd\ufffd\ufffdv\ufffd\ufffd\u01c9\ufffd (2008.8.15 yutaka)\r\n\tif (LogLevel(pvar, LOG_LEVEL_SSHDUMP)) {\r\n\t\tinit_memdump();\r\n\t\tpush_memdump(\"SSH sending packet\", \"SSH_send\", (char *)buf, buflen);\r\n\t}\r\n\r\n\tif (SSHv1(pvar)) {\r\n\t\tif (get_handler(pvar, SSH_SMSG_STDOUT_DATA) != handle_data) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\twhile (buflen > 0) {\r\n\t\t\tint len =\r\n\t\t\t\tbuflen >\r\n\t\t\t\tSSH_MAX_SEND_PACKET_SIZE ? SSH_MAX_SEND_PACKET_SIZE : buflen;\r\n\t\t\tunsigned char *outmsg =\r\n\t\t\t\tbegin_send_packet(pvar, SSH_CMSG_STDIN_DATA, 4 + len);\r\n\r\n\t\t\tset_uint32(outmsg, len);\r\n\r\n\t\t\tif (pvar->ssh_state.compressing) {\r\n\t\t\t\tbuf_ensure_size(&pvar->ssh_state.outbuf,\r\n\t\t\t\t                &pvar->ssh_state.outbuflen,\r\n\t\t\t\t                len + (len >> 6) + 50);\r\n\t\t\t\tpvar->ssh_state.compress_stream.next_in =\r\n\t\t\t\t\tpvar->ssh_state.precompress_outbuf;\r\n\t\t\t\tpvar->ssh_state.compress_stream.avail_in = 5;\r\n\t\t\t\tpvar->ssh_state.compress_stream.next_out =\r\n\t\t\t\t\tpvar->ssh_state.outbuf + 12;\r\n\t\t\t\tpvar->ssh_state.compress_stream.avail_out =\r\n\t\t\t\t\tpvar->ssh_state.outbuflen - 12;\r\n\r\n\t\t\t\tif (deflate(&pvar->ssh_state.compress_stream, Z_NO_FLUSH) != Z_OK) {\r\n\t\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_COMP_ERROR\", pvar,\r\n\t\t\t\t\t\t\t\t\t  \"Error compressing packet data\");\r\n\t\t\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tpvar->ssh_state.compress_stream.next_in =\r\n\t\t\t\t\t(unsigned char *) buf;\r\n\t\t\t\tpvar->ssh_state.compress_stream.avail_in = len;\r\n\r\n\t\t\t\tif (deflate(&pvar->ssh_state.compress_stream, Z_SYNC_FLUSH) != Z_OK) {\r\n\t\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_COMP_ERROR\", pvar,\r\n\t\t\t\t\t                  \"Error compressing packet data\");\r\n\t\t\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tmemcpy(outmsg + 4, buf, len);\r\n\t\t\t}\r\n\r\n\t\t\tfinish_send_packet_special(pvar, 1);\r\n\r\n\t\t\tbuflen -= len;\r\n\t\t\tbuf += len;\r\n\t\t}\r\n\r\n\t} else { // for SSH2(yutaka)\r\n\t\tChannel_t *c = ssh2_channel_lookup(pvar->shell_id);\r\n\t\tif (c == NULL || c->remote_id == SSH_CHANNEL_INVALID) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: shell channel not found.\", __FUNCTION__);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tSSH2_send_channel_data(pvar, c, (unsigned char *)buf, buflen, 0);\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\nint SSH_extract_payload(PTInstVar pvar, unsigned char *dest, int len)\r\n{\r\n\tint num_bytes = pvar->ssh_state.payload_datalen;\r\n\r\n\tif (num_bytes > len) {\r\n\t\tnum_bytes = len;\r\n\t}\r\n\r\n\tif (!pvar->ssh_state.decompressing) {\r\n\t\tmemcpy(dest,\r\n\t\t       pvar->ssh_state.payload + pvar->ssh_state.payload_datastart,\r\n\t\t       num_bytes);\r\n\t\tpvar->ssh_state.payload_datastart += num_bytes;\r\n\t} else if (num_bytes > 0) {\r\n\t\tpvar->ssh_state.decompress_stream.next_out = dest;\r\n\t\tpvar->ssh_state.decompress_stream.avail_out = num_bytes;\r\n\r\n\t\tif (inflate(&pvar->ssh_state.decompress_stream, Z_SYNC_FLUSH) != Z_OK) {\r\n\t\t\tUTIL_get_lang_msg(\"MSG_SSH_INVALID_COMPDATA_ERROR\", pvar,\r\n\t\t\t                  \"Invalid compressed data in received packet\");\r\n\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\r\n\tpvar->ssh_state.payload_datalen -= num_bytes;\r\n\r\n\treturn num_bytes;\r\n}\r\n\r\nvoid SSH_get_compression_info(PTInstVar pvar, char *dest, int len)\r\n{\r\n\tchar buf[1024];\r\n\tchar buf2[1024];\r\n\r\n\t// added support of SSH2 packet compression (2005.7.10 yutaka)\r\n\t// support of \"Compression delayed\" (2006.6.23 maya)\r\n\tif (pvar->ssh_state.compressing ||\r\n\t\tpvar->ctos_compression == COMP_ZLIB ||\r\n\t\tpvar->ctos_compression == COMP_DELAYED && pvar->userauth_success) {\r\n\t\tunsigned long total_in = pvar->ssh_state.compress_stream.total_in;\r\n\t\tunsigned long total_out =\r\n\t\t\tpvar->ssh_state.compress_stream.total_out;\r\n\r\n\t\tif (total_out > 0) {\r\n\t\t\tUTIL_get_lang_msgU8(\"DLG_ABOUT_COMP_INFO\", pvar,\r\n\t\t\t\t\t\t\t\t\"level %d; ratio %.1f (%ld:%ld)\");\r\n\t\t\t_snprintf_s(buf, sizeof(buf), _TRUNCATE, pvar->UIMsg,\r\n\t\t\t            pvar->ssh_state.compression_level,\r\n\t\t\t            ((double) total_in) / total_out, total_in,\r\n\t\t\t            total_out);\r\n\t\t} else {\r\n\t\t\tUTIL_get_lang_msgU8(\"DLG_ABOUT_COMP_INFO2\", pvar, \"level %d\");\r\n\t\t\t_snprintf_s(buf, sizeof(buf), _TRUNCATE, pvar->UIMsg,\r\n\t\t\t            pvar->ssh_state.compression_level);\r\n\t\t}\r\n\t} else {\r\n\t\tUTIL_get_lang_msgU8(\"DLG_ABOUT_COMP_NONE\", pvar, \"none\");\r\n\t\tstrncpy_s(buf, sizeof(buf), pvar->UIMsg, _TRUNCATE);\r\n\t}\r\n\r\n\t// support of \"Compression delayed\" (2006.6.23 maya)\r\n\tif (pvar->ssh_state.decompressing ||\r\n\t\tpvar->stoc_compression == COMP_ZLIB ||\r\n\t\tpvar->stoc_compression == COMP_DELAYED && pvar->userauth_success) {\r\n\t\tunsigned long total_in =\r\n\t\t\tpvar->ssh_state.decompress_stream.total_in;\r\n\t\tunsigned long total_out =\r\n\t\t\tpvar->ssh_state.decompress_stream.total_out;\r\n\r\n\t\tif (total_in > 0) {\r\n\t\t\tUTIL_get_lang_msgU8(\"DLG_ABOUT_COMP_INFO\", pvar,\r\n\t\t\t\t\t\t\t\t\"level %d; ratio %.1f (%ld:%ld)\");\r\n\t\t\t_snprintf_s(buf2, sizeof(buf2), _TRUNCATE, pvar->UIMsg,\r\n\t\t\t            pvar->ssh_state.compression_level,\r\n\t\t\t            ((double) total_out) / total_in, total_out,\r\n\t\t\t            total_in);\r\n\t\t} else {\r\n\t\t\tUTIL_get_lang_msgU8(\"DLG_ABOUT_COMP_INFO2\", pvar, \"level %d\");\r\n\t\t\t_snprintf_s(buf2, sizeof(buf2), _TRUNCATE, pvar->UIMsg,\r\n\t\t\t            pvar->ssh_state.compression_level);\r\n\t\t}\r\n\t} else {\r\n\t\tUTIL_get_lang_msgU8(\"DLG_ABOUT_COMP_NONE\", pvar, \"none\");\r\n\t\tstrncpy_s(buf2, sizeof(buf2), pvar->UIMsg, _TRUNCATE);\r\n\t}\r\n\r\n\tUTIL_get_lang_msgU8(\"DLG_ABOUT_COMP_UPDOWN\", pvar,\r\n\t\t\t\t\t\t\"Upstream %s; Downstream %s\");\r\n\t_snprintf_s(dest, len, _TRUNCATE, pvar->UIMsg, buf, buf2);\r\n}\r\n\r\nvoid SSH_get_server_ID_info(PTInstVar pvar, char *dest, int len)\r\n{\r\n\tstrncpy_s(dest, len,\r\n\t          pvar->ssh_state.server_ID == NULL ? \"Unknown\"\r\n\t                                            : pvar->ssh_state.server_ID,\r\n\t          _TRUNCATE);\r\n}\r\n\r\nvoid SSH_get_protocol_version_info(PTInstVar pvar, char *dest,\r\n                                   int len)\r\n{\r\n\tif (pvar->protocol_major == 0) {\r\n\t\tstrncpy_s(dest, len, \"Unknown\", _TRUNCATE);\r\n\t} else {\r\n\t\t_snprintf_s(dest, len, _TRUNCATE, \"%d.%d\", pvar->protocol_major,\r\n\t\t            pvar->protocol_minor);\r\n\t}\r\n}\r\n\r\nvoid SSH_get_mac_info(PTInstVar pvar, char *dest, int len)\r\n{\r\n\tUTIL_get_lang_msgU8(\"DLG_ABOUT_MAC_INFO\", pvar,\r\n\t\t\t\t\t\t\"%s to server, %s from server\");\r\n\t_snprintf_s(dest, len, _TRUNCATE, pvar->UIMsg,\r\n\t            get_ssh2_mac_name(pvar->macs[MODE_OUT]),\r\n\t            get_ssh2_mac_name(pvar->macs[MODE_IN]));\r\n}\r\n\r\nvoid SSH_end(PTInstVar pvar)\r\n{\r\n\tint i;\r\n\tint mode;\r\n\r\n\tfor (i = 0; i < 256; i++) {\r\n\t\tSSHPacketHandlerItem *first_item =\r\n\t\t\tpvar->ssh_state.packet_handlers[i];\r\n\r\n\t\tif (first_item != NULL) {\r\n\t\t\tSSHPacketHandlerItem *item = first_item;\r\n\r\n\t\t\tdo {\r\n\t\t\t\tSSHPacketHandlerItem *cur_item = item;\r\n\r\n\t\t\t\titem = item->next_for_message;\r\n\t\t\t\tfree(cur_item);\r\n\t\t\t} while (item != first_item);\r\n\t\t}\r\n\t\tpvar->ssh_state.packet_handlers[i] = NULL;\r\n\t}\r\n\r\n\tfree(pvar->ssh_state.hostname);\r\n\tpvar->ssh_state.hostname = NULL;\r\n\tfree(pvar->ssh_state.server_ID);\r\n\tpvar->ssh_state.server_ID = NULL;\r\n\tbuf_destroy(&pvar->ssh_state.outbuf, &pvar->ssh_state.outbuflen);\r\n\tbuf_destroy(&pvar->ssh_state.precompress_outbuf,\r\n\t            &pvar->ssh_state.precompress_outbuflen);\r\n\tbuf_destroy(&pvar->ssh_state.postdecompress_inbuf,\r\n\t            &pvar->ssh_state.postdecompress_inbuflen);\r\n\tpvar->agentfwd_enable = FALSE;\r\n\tpvar->use_subsystem = FALSE;\r\n\tpvar->nosession = FALSE;\r\n\r\n\t// support of \"Compression delayed\" (2006.6.23 maya)\r\n\tif (pvar->ssh_state.compressing ||\r\n\t\tpvar->ctos_compression == COMP_ZLIB || // add SSH2 flag (2005.7.10 yutaka)\r\n\t\tpvar->ctos_compression == COMP_DELAYED && pvar->userauth_success) {\r\n\t\tdeflateEnd(&pvar->ssh_state.compress_stream);\r\n\t\tpvar->ssh_state.compressing = FALSE;\r\n\t}\r\n\t// support of \"Compression delayed\" (2006.6.23 maya)\r\n\tif (pvar->ssh_state.decompressing ||\r\n\t\tpvar->stoc_compression == COMP_ZLIB || // add SSH2 flag (2005.7.10 yutaka)\r\n\t\tpvar->stoc_compression == COMP_DELAYED && pvar->userauth_success) {\r\n\t\tinflateEnd(&pvar->ssh_state.decompress_stream);\r\n\t\tpvar->ssh_state.decompressing = FALSE;\r\n\t}\r\n\r\n\t// SSH2\ufffd\u0303f\ufffd[\ufffd^\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd (2004.12.27 yutaka)\r\n\tif (SSHv2(pvar)) {\r\n\t\tif (pvar->kexdh) {\r\n\t\t\tDH_free(pvar->kexdh);\r\n\t\t\tpvar->kexdh = NULL;\r\n\t\t}\r\n\t\tif (pvar->ecdh_client_key) {\r\n\t\t\tEC_KEY_free(pvar->ecdh_client_key);\r\n\t\t\tpvar->ecdh_client_key = NULL;\r\n\t\t}\r\n\t\tmemset(pvar->server_version_string, 0, sizeof(pvar->server_version_string));\r\n\t\tmemset(pvar->client_version_string, 0, sizeof(pvar->client_version_string));\r\n\r\n\t\tif (pvar->my_kex != NULL) {\r\n\t\t\tbuffer_free(pvar->my_kex);\r\n\t\t\tpvar->my_kex = NULL;\r\n\t\t}\r\n\t\tif (pvar->peer_kex != NULL) {\r\n\t\t\tbuffer_free(pvar->peer_kex);\r\n\t\t\tpvar->peer_kex = NULL;\r\n\t\t}\r\n\r\n\t\tpvar->we_need = 0;\r\n\t\tpvar->kex_status = 0;\r\n\r\n\t\tif (pvar->session_id != NULL) {\r\n\t\t\tfree(pvar->session_id);\r\n\t\t\tpvar->session_id = NULL;\r\n\t\t}\r\n\t\tpvar->session_id_len = 0;\r\n\r\n\t\tpvar->userauth_success = 0;\r\n\t\tpvar->shell_id = SSH_CHANNEL_INVALID;\r\n\t\tpvar->session_nego_status = 0;\r\n\r\n\t\tpvar->ssh_heartbeat_tick = 0;\r\n\r\n\t\tif (pvar->decomp_buffer != NULL) {\r\n\t\t\tbuffer_free(pvar->decomp_buffer);\r\n\t\t\tpvar->decomp_buffer = NULL;\r\n\t\t}\r\n\r\n\t\tif (pvar->authbanner_buffer != NULL) {\r\n\t\t\tbuffer_free(pvar->authbanner_buffer);\r\n\t\t\tpvar->authbanner_buffer = NULL;\r\n\t\t}\r\n\r\n\t\tif (pvar->ssh2_authlist != NULL) { // (2007.4.27 yutaka)\r\n\t\t\tfree(pvar->ssh2_authlist);\r\n\t\t\tpvar->ssh2_authlist = NULL;\r\n\t\t}\r\n\r\n\t\tpvar->tryed_ssh2_authlist = FALSE;\r\n\r\n\t\tfree(pvar->server_sig_algs);\r\n\t\tpvar->server_sig_algs = NULL;\r\n\r\n\t\t// add (2008.3.2 yutaka)\r\n\t\tfor (mode = 0 ; mode < MODE_MAX ; mode++) {\r\n\t\t\tif (pvar->ssh2_keys[mode].enc.iv != NULL) {\r\n\t\t\t\tfree(pvar->ssh2_keys[mode].enc.iv);\r\n\t\t\t\tpvar->ssh2_keys[mode].enc.iv = NULL;\r\n\t\t\t}\r\n\t\t\tif (pvar->ssh2_keys[mode].enc.key != NULL) {\r\n\t\t\t\tfree(pvar->ssh2_keys[mode].enc.key);\r\n\t\t\t\tpvar->ssh2_keys[mode].enc.key = NULL;\r\n\t\t\t}\r\n\t\t\tif (pvar->ssh2_keys[mode].mac.key != NULL) {\r\n\t\t\t\tfree(pvar->ssh2_keys[mode].mac.key);\r\n\t\t\t\tpvar->ssh2_keys[mode].mac.key = NULL;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid SSH2_send_channel_data(PTInstVar pvar, Channel_t *c, unsigned char *buf, unsigned int buflen, int retry)\r\n{\r\n\tbuffer_t *msg;\r\n\tunsigned char *outmsg;\r\n\tunsigned int len;\r\n\r\n\t// SSH2\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u030f\ua347\ufffd\u0341A\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ud805\uddc2\ufffd\u0202\ufffd\ufffd\u0302\u0142\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u06d1\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\r\n\tif (pvar->kex_status & KEX_FLAG_REKEYING) {\r\n\t\tssh2_channel_add_bufchain(pvar, c, buf, buflen);\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (c == NULL)\r\n\t\treturn;\r\n\r\n\t// \ufffd\ufffd\ufffdg\ufffd\ufffd\ufffdC\ufffd\u0142\u0342\u0202\ufffd\ufffdA\ufffd\u028f\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffdM\ufffd\u030d\u06c1A\ufffd\u0211O\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdf\ufffd[\ufffd^\ufffd\ufffd\r\n\t// \ufffd\ufffd\ufffd\ufffd\ufffdN\ufffdh\ufffd\ufffd\ufffdX\ufffdg\ufffd\u024ec\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\u60a4\ufffd\u0142\ufffd\ufffd\ufffd\u0381A\ufffd\ufffd\ufffdX\ufffdg\ufffd\u0316\ufffd\ufffd\ufffd\ufffd\u024cq\ufffd\ufffd\ufffdB\r\n\t// \ufffd\ufffd\ufffd\ufffd\u0242\ufffd\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffd\ufffd\ua0bd\ufffd\u60a4\ufffd\u024c\ufffd\ufffd\ufffd\ufffd\u933b\ufffd\u06c2\ufffd\ufffd\ufffd\ufffdP\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t// (2012.10.14 yutaka)\r\n\tif (retry == 0 && c->bufchain) {\r\n\t\tssh2_channel_add_bufchain(pvar, c, buf, buflen);\r\n\t\treturn;\r\n\t}\r\n\r\n\tif ((unsigned int)buflen > c->remote_window) {\r\n\t\tunsigned int offset = 0;\r\n\t\t// \ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffdf\ufffd[\ufffd^\ufffd\u0342\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u06d1\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\r\n\t\tssh2_channel_add_bufchain(pvar, c, buf + offset, buflen - offset);\r\n\t\tbuflen = offset;\r\n\t\treturn;\r\n\t}\r\n\tif (buflen > 0) {\r\n\t\tmsg = buffer_init();\r\n\t\tif (msg == NULL) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbuffer_put_int(msg, c->remote_id);\r\n\t\tbuffer_put_string(msg, (char *)buf, buflen);\r\n\r\n\t\tlen = buffer_len(msg);\r\n\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_DATA, len);\r\n\t\t//if (len + 12 >= pvar->ssh_state.outbuflen) *(int *)0 = 0;\r\n\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\tfinish_send_packet(pvar);\r\n\t\tbuffer_free(msg);\r\n\r\n\t\tlogprintf(LOG_LEVEL_SSHDUMP, \"%s: sending SSH2_MSG_CHANNEL_DATA. \"\r\n\t\t\t\t  \"local:%d remote:%d len:%d\", __FUNCTION__, c->self_id, c->remote_id, buflen);\r\n\r\n\t\t// remote window size\ufffd\u0312\ufffd\ufffd\ufffd\r\n\t\tif (buflen <= c->remote_window) {\r\n\t\t\tc->remote_window -= buflen;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tc->remote_window = 0;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/* support for port forwarding */\r\nvoid SSH_channel_send(PTInstVar pvar, int channel_num,\r\n                      uint32 remote_channel_num,\r\n                      unsigned char *buf, int len, int retry)\r\n{\r\n\tif (SSHv1(pvar)) {\r\n\t\tunsigned char *outmsg =\r\n\t\t\tbegin_send_packet(pvar, SSH_MSG_CHANNEL_DATA, 8 + len);\r\n\r\n\t\tset_uint32(outmsg, remote_channel_num);\r\n\t\tset_uint32(outmsg + 4, len);\r\n\r\n\t\tif (pvar->ssh_state.compressing) {\r\n\t\t\tbuf_ensure_size(&pvar->ssh_state.outbuf,\r\n\t\t\t                &pvar->ssh_state.outbuflen, len + (len >> 6) + 50);\r\n\t\t\tpvar->ssh_state.compress_stream.next_in =\r\n\t\t\t\tpvar->ssh_state.precompress_outbuf;\r\n\t\t\tpvar->ssh_state.compress_stream.avail_in = 9;\r\n\t\t\tpvar->ssh_state.compress_stream.next_out =\r\n\t\t\t\tpvar->ssh_state.outbuf + 12;\r\n\t\t\tpvar->ssh_state.compress_stream.avail_out =\r\n\t\t\t\tpvar->ssh_state.outbuflen - 12;\r\n\r\n\t\t\tif (deflate(&pvar->ssh_state.compress_stream, Z_NO_FLUSH) != Z_OK) {\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_COMP_ERROR\", pvar,\r\n\t\t\t\t                  \"Error compressing packet data\");\r\n\t\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tpvar->ssh_state.compress_stream.next_in =\r\n\t\t\t\t(unsigned char *) buf;\r\n\t\t\tpvar->ssh_state.compress_stream.avail_in = len;\r\n\r\n\t\t\tif (deflate(&pvar->ssh_state.compress_stream, Z_SYNC_FLUSH) !=\r\n\t\t\t\tZ_OK) {\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_COMP_ERROR\", pvar,\r\n\t\t\t\t                  \"Error compressing packet data\");\r\n\t\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tmemcpy(outmsg + 8, buf, len);\r\n\t\t}\r\n\r\n\t\tfinish_send_packet_special(pvar, 1);\r\n\r\n\t} else {\r\n\t\t// \ufffd|\ufffd[\ufffdg\ufffdt\ufffdH\ufffd\ufffd\ufffd[\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd\u0242\ufffd\ufffd\ufffd\ufffd\u0103N\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffd\ufffd\u0311\ufffd\ufffdM\ufffdv\ufffd\ufffd\ufffd\ufffd\ufffdASSH\ufffd\u0290M\ufffd\u024f\u60b9\ufffd\u0103T\ufffd[\ufffdo\ufffd\u0702\u0151\ufffd\ufffd\ufffd\u0342\ufffd\ufffd\ufffdB\r\n\t\tChannel_t *c = ssh2_local_channel_lookup(channel_num);\r\n\t\tSSH2_send_channel_data(pvar, c, buf, len, retry);\r\n\t}\r\n\r\n}\r\n\r\nvoid SSH_fail_channel_open(PTInstVar pvar, uint32 remote_channel_num)\r\n{\r\n\tif (SSHv1(pvar)) {\r\n\t\tunsigned char *outmsg =\r\n\t\t\tbegin_send_packet(pvar, SSH_MSG_CHANNEL_OPEN_FAILURE, 4);\r\n\r\n\t\tset_uint32(outmsg, remote_channel_num);\r\n\t\tfinish_send_packet(pvar);\r\n\r\n\t} else { // SSH2 (2005.6.26 yutaka)\r\n\t\tint len;\r\n\t\tChannel_t *c = NULL;\r\n\t\tbuffer_t *msg;\r\n\t\tunsigned char *outmsg;\r\n\r\n\t\tmsg = buffer_init();\r\n\t\tif (msg == NULL) {\r\n\t\t\t// TODO: error check\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbuffer_put_int(msg, remote_channel_num);\r\n\t\tbuffer_put_int(msg, SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED);\r\n\t\tbuffer_put_string(msg, \"\", 0); // description\r\n\t\tbuffer_put_string(msg, \"\", 0); // language tag\r\n\r\n\t\tlen = buffer_len(msg);\r\n\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_OPEN_FAILURE, len);\r\n\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\tfinish_send_packet(pvar);\r\n\t\tbuffer_free(msg);\r\n\r\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_CHANNEL_OPEN_FAILURE was sent at SSH_fail_channel_open().\");\r\n\t}\r\n}\r\n\r\nvoid SSH2_confirm_channel_open(PTInstVar pvar, Channel_t *c)\r\n{\r\n\tbuffer_t *msg;\r\n\tunsigned char *outmsg;\r\n\tint len;\r\n\r\n\tif (c == NULL)\r\n\t\treturn;\r\n\r\n\tmsg = buffer_init();\r\n\tif (msg == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\treturn;\r\n\t}\r\n\tbuffer_put_int(msg, c->remote_id);\r\n\tbuffer_put_int(msg, c->self_id);\r\n\tbuffer_put_int(msg, c->local_window);\r\n\tbuffer_put_int(msg, c->local_maxpacket);\r\n\r\n\tlen = buffer_len(msg);\r\n\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_OPEN_CONFIRMATION, len);\r\n\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\tfinish_send_packet(pvar);\r\n\tbuffer_free(msg);\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"SSH2_MSG_CHANNEL_OPEN_CONFIRMATION was sent at SSH_confirm_channel_open(). local:%d remote:%d\", c->self_id, c->remote_id);\r\n}\r\n\r\nvoid SSH_confirm_channel_open(PTInstVar pvar, uint32 remote_channel_num,\r\n\t\t\t\t\t\t\t  uint32 local_channel_num)\r\n{\r\n\tif (SSHv1(pvar)) {\r\n\t\tunsigned char *outmsg =\r\n\t\t\tbegin_send_packet(pvar, SSH_MSG_CHANNEL_OPEN_CONFIRMATION, 8);\r\n\r\n\t\tset_uint32(outmsg, remote_channel_num);\r\n\t\tset_uint32(outmsg + 4, local_channel_num);\r\n\t\tfinish_send_packet(pvar);\r\n\r\n\t} else {\r\n\t\tChannel_t *c;\r\n\r\n\t\t// port-forwarding(remote to local)\ufffd\u0303\ufffd\ufffd[\ufffdJ\ufffd\ufffd\ufffd\u0691\ufffd\ufffd\u0582\u0310\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdT\ufffd[\ufffdo\ufffd\u0595\u0502\ufffd\ufffdB(2005.7.2 yutaka)\r\n\t\tc = ssh2_local_channel_lookup(local_channel_num);\r\n\t\tif (c == NULL) {\r\n\t\t\t// It is sure to be successful as long as it's not a program bug either.\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tSSH2_confirm_channel_open(pvar, c);\r\n\t}\r\n}\r\n\r\nvoid SSH_channel_output_eof(PTInstVar pvar, uint32 remote_channel_num)\r\n{\r\n\tif (SSHv1(pvar)){\r\n\t\tunsigned char *outmsg =\r\n\t\t\tbegin_send_packet(pvar, SSH_MSG_CHANNEL_OUTPUT_CLOSED, 4);\r\n\r\n\t\tset_uint32(outmsg, remote_channel_num);\r\n\t\tfinish_send_packet(pvar);\r\n\r\n\t} else {\r\n\t\t// SSH2: \ufffd\ufffd\ufffd\u0242\u0202\ufffd\ufffdB\r\n\r\n\t}\r\n}\r\n\r\nvoid SSH2_channel_input_eof(PTInstVar pvar, Channel_t *c)\r\n{\r\n\tbuffer_t *msg;\r\n\tunsigned char *outmsg;\r\n\tint len;\r\n\r\n\tif (c == NULL)\r\n\t\treturn;\r\n\r\n\t// SSH2\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u030f\ua347\ufffdA\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffd\u0302\u0102\ufffdB(2005.6.21 yutaka)\r\n\tif (pvar->kex_status & KEX_FLAG_REKEYING) {\r\n\t\t// TODO: \ufffd\ufffd\ufffdz\ufffd\u0182\ufffd\ufffd\u0102\u0343p\ufffdP\ufffdb\ufffdg\ufffdj\ufffd\ufffd\ufffd\u0142\u0342\u0202\ufffd\ufffdA\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\u01c2\u074e\ufffd\ufffdx\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0182\ufffd\ufffd\ub0be\ufffd\ufffd\ufffdA\r\n\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0182\u0242\ufffd\ufffd\ufffdB\r\n\t\tlogprintf(LOG_LEVEL_INFO, \"%s: now rekeying. data is not sent.\", __FUNCTION__);\r\n\r\n\t\tc = NULL;\r\n\r\n\t\treturn;\r\n\t}\r\n\r\n\tmsg = buffer_init();\r\n\tif (msg == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\treturn;\r\n\t}\r\n\tbuffer_put_int(msg, c->remote_id);  // remote ID\r\n\r\n\tlen = buffer_len(msg);\r\n\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_EOF, len);\r\n\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\tfinish_send_packet(pvar);\r\n\tbuffer_free(msg);\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"SSH2_MSG_CHANNEL_EOF was sent at SSH2_channel_input_eof(). local:%d remote:%d\", c->self_id, c->remote_id);\r\n}\r\n\r\nvoid SSH_channel_input_eof(PTInstVar pvar, uint32 remote_channel_num, uint32 local_channel_num)\r\n{\r\n\tif (SSHv1(pvar)){\r\n\t\tunsigned char *outmsg =\r\n\t\t\tbegin_send_packet(pvar, SSH_MSG_CHANNEL_INPUT_EOF, 4);\r\n\r\n\t\tset_uint32(outmsg, remote_channel_num);\r\n\t\tfinish_send_packet(pvar);\r\n\r\n\t} else {\r\n\t\t// SSH2: \ufffd`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffdN\ufffd\ufffd\ufffd[\ufffdY\ufffd\ufffd\ufffdT\ufffd[\ufffdo\ufffd\u0592\u0292m\r\n\t\tChannel_t *c;\r\n\r\n\t\tc = ssh2_local_channel_lookup(local_channel_num);\r\n\t\tif (c == NULL)\r\n\t\t\treturn;\r\n\r\n\t\tSSH2_channel_input_eof(pvar, c);\r\n\t}\r\n}\r\n\r\nvoid SSH_request_forwarding(PTInstVar pvar, char *bind_address, int from_server_port,\r\n                            char *to_local_host, int to_local_port)\r\n{\r\n\tif (SSHv1(pvar)) {\r\n\t\tint host_len = strlen(to_local_host);\r\n\t\tunsigned char *outmsg =\r\n\t\t\tbegin_send_packet(pvar, SSH_CMSG_PORT_FORWARD_REQUEST, 12 + host_len);\r\n\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: Forwarding request (SSH1 RtoL): \"\r\n\t\t\t\t  \"remote_port=%d, to_host=%s, to_port=%d\", __FUNCTION__,\r\n\t\t\tfrom_server_port, to_local_host, to_local_port);\r\n\r\n\t\tset_uint32(outmsg, from_server_port);\r\n\t\tset_uint32(outmsg + 4, host_len);\r\n\t\tmemcpy(outmsg + 8, to_local_host, host_len);\r\n\t\tset_uint32(outmsg + 8 + host_len, to_local_port);\r\n\t\tfinish_send_packet(pvar);\r\n\r\n\t\tenque_forwarding_request_handlers(pvar);\r\n\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: sending SSH_CMSG_PORT_FORWARD_REQUEST.\"\r\n\t\t\t\t  \"remote_port=%d, to_host=%s, to_port=%d\", __FUNCTION__,\r\n\t\t\tfrom_server_port, to_local_host, to_local_port);\r\n\r\n\t} else {\r\n\t\t// SSH2 port-forwading remote to local (2005.6.21 yutaka)\r\n\t\tbuffer_t *msg;\r\n\t\tchar *req;\r\n\t\tunsigned char *outmsg;\r\n\t\tint len;\r\n\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: Forwarding request (SSH2 RtoL): \"\r\n\t\t\t\t  \"bind_addr=%s, remote_port=%d, to_host=%s, to_port=%d\", __FUNCTION__,\r\n\t\t\tbind_address, from_server_port, to_local_host, to_local_port);\r\n\r\n\t\tmsg = buffer_init();\r\n\t\tif (msg == NULL) {\r\n\t\t\t// TODO: error check\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\treq = \"tcpip-forward\";\r\n\t\tbuffer_put_string(msg, req, strlen(req)); // ctype\r\n\t\tbuffer_put_char(msg, 1);  // want reply\r\n\t\tbuffer_put_string(msg, bind_address, strlen(bind_address));\r\n\r\n\t\tbuffer_put_int(msg, from_server_port);  // listening port\r\n\r\n\t\tlen = buffer_len(msg);\r\n\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_GLOBAL_REQUEST, len);\r\n\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\tfinish_send_packet(pvar);\r\n\t\tbuffer_free(msg);\r\n\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: sending SSH2_MSG_GLOBAL_REQUEST. \"\r\n\t\t\t\t  \"request=%s, want_reply=%d, bind_address=%s, remote_port=%d\", __FUNCTION__,\r\n\t\t\treq, 1, bind_address, from_server_port);\r\n\t}\r\n}\r\n\r\nvoid SSH_cancel_request_forwarding(PTInstVar pvar, char *bind_address, int from_server_port, int reply)\r\n{\r\n\tif (SSHv2(pvar)) {\r\n\t\tbuffer_t *msg;\r\n\t\tchar *s;\r\n\t\tunsigned char *outmsg;\r\n\t\tint len;\r\n\r\n\t\tmsg = buffer_init();\r\n\t\tif (msg == NULL) {\r\n\t\t\t// TODO: error check\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\ts = \"cancel-tcpip-forward\";\r\n\t\tbuffer_put_string(msg, s, strlen(s)); // ctype\r\n\t\tbuffer_put_char(msg, reply);  // want reply\r\n\t\tbuffer_put_string(msg, bind_address, strlen(bind_address));\r\n\r\n\t\tbuffer_put_int(msg, from_server_port);  // listening port\r\n\r\n\t\tlen = buffer_len(msg);\r\n\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_GLOBAL_REQUEST, len);\r\n\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\tfinish_send_packet(pvar);\r\n\t\tbuffer_free(msg);\r\n\r\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_GLOBAL_REQUEST was sent at SSH_cancel_request_forwarding().\");\r\n\t}\r\n}\r\n\r\nvoid SSH_request_X11_forwarding(PTInstVar pvar,\r\n                                char *auth_protocol,\r\n                                unsigned char *auth_data,\r\n                                int auth_data_len, int screen_num)\r\n{\r\n\tif (SSHv1(pvar)) {\r\n\t\tint protocol_len = strlen(auth_protocol);\r\n\t\tint data_len = auth_data_len * 2;\r\n\t\tint outmsg_len = 12 + protocol_len + data_len;\r\n\t\tunsigned char *outmsg =\r\n\t\t\tbegin_send_packet(pvar, SSH_CMSG_X11_REQUEST_FORWARDING, outmsg_len);\r\n\t\tint i;\r\n\t\tchar *auth_data_ptr;\r\n\r\n\t\tset_uint32(outmsg, protocol_len);\r\n\t\tmemcpy(outmsg + 4, auth_protocol, protocol_len);\r\n\t\tset_uint32(outmsg + 4 + protocol_len, data_len);\r\n\t\tauth_data_ptr = outmsg + 8 + protocol_len;\r\n\t\tfor (i = 0; i < auth_data_len; i++) {\r\n\t\t\t_snprintf_s(auth_data_ptr + i * 2,\r\n\t\t\t            outmsg_len - ((UINT_PTR)auth_data_ptr - (UINT_PTR)outmsg) - i * 2,\r\n\t\t\t            _TRUNCATE, \"%.2x\", auth_data[i]);\r\n\t\t}\r\n\t\tset_uint32(outmsg + 8 + protocol_len + data_len, screen_num);\r\n\r\n\t\tfinish_send_packet(pvar);\r\n\r\n\t\tenque_forwarding_request_handlers(pvar);\r\n\r\n\t} else {\r\n\t\t// SSH2: X11 port-forwarding (2005.7.2 yutaka)\r\n\t\tbuffer_t *msg;\r\n\t\tchar *req_type = \"x11-req\";\r\n\t\tunsigned char *outmsg;\r\n\t\tint len;\r\n\t\tChannel_t *c;\r\n\t\tint newlen;\r\n\t\tchar *newdata;\r\n\t\tint i;\r\n\r\n\t\tmsg = buffer_init();\r\n\t\tif (msg == NULL) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tc = ssh2_channel_lookup(pvar->shell_id);\r\n\t\tif (c == NULL) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: shell channel not found.\", __FUNCTION__);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (c->remote_id == SSH_CHANNEL_INVALID) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: remote shell channel number is unknown.\", __FUNCTION__);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// making the fake data\r\n\t\tnewlen = 2 * auth_data_len + 1;\r\n\t\tnewdata = malloc(newlen);\r\n\t\tif (newdata == NULL)\r\n\t\t\treturn;\r\n\t\tfor (i = 0 ; i < auth_data_len ; i++) {\r\n\t\t\t_snprintf_s(newdata + i*2, newlen - i*2, _TRUNCATE, \"%02x\", auth_data[i]);\r\n\t\t}\r\n\t\tnewdata[newlen - 1] = '\\0';\r\n\r\n\t\tbuffer_put_int(msg, c->remote_id);\r\n\t\tbuffer_put_string(msg, req_type, strlen(req_type)); // service name\r\n\t\tbuffer_put_char(msg, 0);  // want_reply (false)\r\n\t\tbuffer_put_char(msg, 0);  // single connection\r\n\r\n\t\tbuffer_put_string(msg, auth_protocol, strlen(auth_protocol)); // protocol (\"MIT-MAGIC-COOKIE-1\")\r\n\t\tbuffer_put_string(msg, newdata, strlen(newdata)); // cookie\r\n\r\n\t\tbuffer_put_int(msg, screen_num);\r\n\r\n\t\tlen = buffer_len(msg);\r\n\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_REQUEST, len);\r\n\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\tfinish_send_packet(pvar);\r\n\t\tbuffer_free(msg);\r\n\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: sending SSH2_MSG_CHANNEL_REQUEST. \"\r\n\t\t          \"local: %d, remote: %d, request-type: %s, proto: %s, cookie: %s, screen: %d\", __FUNCTION__,\r\n\t\t          c->self_id, c->remote_id, req_type, auth_protocol, newdata, screen_num);\r\n\r\n\t\tfree(newdata);\r\n\t}\r\n\r\n}\r\n\r\nvoid SSH_open_channel(PTInstVar pvar, uint32 local_channel_num,\r\n                      char *to_remote_host, int to_remote_port,\r\n                      char *originator, unsigned short originator_port)\r\n{\r\n\tstatic const int msgs[]\r\n\t= { SSH_MSG_CHANNEL_OPEN_CONFIRMATION, SSH_MSG_CHANNEL_OPEN_FAILURE };\r\n\tstatic const SSHPacketHandler handlers[]\r\n\t= { handle_channel_open_confirmation, handle_channel_open_failure };\r\n\r\n\tint host_len = strlen(to_remote_host);\r\n\r\n\tif ((pvar->ssh_state.\r\n\t\t server_protocol_flags & SSH_PROTOFLAG_HOST_IN_FWD_OPEN) != 0) {\r\n\t\tint originator_len = strlen(originator);\r\n\t\tunsigned char *outmsg =\r\n\t\t\tbegin_send_packet(pvar, SSH_MSG_PORT_OPEN,\r\n\t\t\t                  16 + host_len + originator_len);\r\n\r\n\t\tset_uint32(outmsg, local_channel_num);\r\n\t\tset_uint32(outmsg + 4, host_len);\r\n\t\tmemcpy(outmsg + 8, to_remote_host, host_len);\r\n\t\tset_uint32(outmsg + 8 + host_len, to_remote_port);\r\n\t\tset_uint32(outmsg + 12 + host_len, originator_len);\r\n\t\tmemcpy(outmsg + 16 + host_len, originator, originator_len);\r\n\t} else {\r\n\r\n\t\tif (SSHv1(pvar)) {\r\n\t\t\tunsigned char *outmsg =\r\n\t\t\t\tbegin_send_packet(pvar, SSH_MSG_PORT_OPEN,\r\n\t\t\t\t                  12 + host_len);\r\n\r\n\t\t\tset_uint32(outmsg, local_channel_num);\r\n\t\t\tset_uint32(outmsg + 4, host_len);\r\n\t\t\tmemcpy(outmsg + 8, to_remote_host, host_len);\r\n\t\t\tset_uint32(outmsg + 8 + host_len, to_remote_port);\r\n\r\n\t\t} else {\r\n\t\t\t// SSH2 port-fowarding (2005.2.26 yutaka)\r\n\t\t\tbuffer_t *msg;\r\n\t\t\tchar *s;\r\n\t\t\tunsigned char *outmsg;\r\n\t\t\tint len;\r\n\t\t\tChannel_t *c;\r\n\r\n\t\t\t// SSH2\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u030f\ua347\ufffdA\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffd\u0302\u0102\ufffdB(2005.6.21 yutaka)\r\n\t\t\tif (pvar->kex_status & KEX_FLAG_REKEYING) {\r\n\t\t\t\t// TODO: \ufffd\ufffd\ufffdz\ufffd\u0182\ufffd\ufffd\u0102\u0343p\ufffdP\ufffdb\ufffdg\ufffdj\ufffd\ufffd\ufffd\u0142\u0342\u0202\ufffd\ufffdA\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\u01c2\u074e\ufffd\ufffdx\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0182\ufffd\ufffd\ub0be\ufffd\ufffd\ufffdA\r\n\t\t\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0182\u0242\ufffd\ufffd\ufffdB\r\n\t\t\t\tlogprintf(LOG_LEVEL_INFO, \"%s: now rekeying. channel open request is not sent.\", __FUNCTION__);\r\n\r\n\t\t\t\tc = NULL;\r\n\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// changed window size from 128KB to 32KB. (2006.3.6 yutaka)\r\n\t\t\t// changed window size from 32KB to 128KB. (2007.10.29 maya)\r\n\t\t\tc = ssh2_channel_new(CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, TYPE_PORTFWD, local_channel_num);\r\n\t\t\tif (c == NULL) {\r\n\t\t\t\t// \ufffd]\ufffd\ufffd\ufffd`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\ufffd\\\ufffdP\ufffdb\ufffdg\ufffd\u0309\ufffd\ufffd\ufffdR\ufffd\ufffd\ufffd\ufffdC\ufffd\ufffd (2007.7.26 maya)\r\n\t\t\t\tFWD_free_channel(pvar, local_channel_num);\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_NO_FREE_CHANNEL\", pvar,\r\n\t\t\t\t                  \"Could not open new channel. TTSSH is already opening too many channels.\");\r\n\t\t\t\tnotify_nonfatal_error(pvar, pvar->UIMsg);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tmsg = buffer_init();\r\n\t\t\tif (msg == NULL) {\r\n\t\t\t\t// TODO: error check\r\n\t\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\ts = \"direct-tcpip\";\r\n\t\t\tbuffer_put_string(msg, s, strlen(s)); // ctype\r\n\t\t\tbuffer_put_int(msg, c->self_id);  // self\r\n\t\t\tbuffer_put_int(msg, c->local_window);  // local_window\r\n\t\t\tbuffer_put_int(msg, c->local_maxpacket);  // local_maxpacket\r\n\r\n\t\t\ts = to_remote_host;\r\n\t\t\tbuffer_put_string(msg, s, strlen(s)); // target host\r\n\t\t\tbuffer_put_int(msg, to_remote_port);  // target port\r\n\r\n\t\t\ts = originator;\r\n\t\t\tbuffer_put_string(msg, s, strlen(s)); // originator host\r\n\t\t\tbuffer_put_int(msg, originator_port);  // originator port\r\n\r\n\t\t\tlen = buffer_len(msg);\r\n\t\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_OPEN, len);\r\n\t\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\t\tfinish_send_packet(pvar);\r\n\t\t\tbuffer_free(msg);\r\n\r\n\t\t\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_CHANNEL_OPEN was sent at SSH_open_channel().\");\r\n\r\n\t\t\treturn;\r\n\r\n\t\t\t/* NOT REACHED */\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif (SSHv1(pvar)) { // SSH1\ufffd\u0302\ufffd\r\n\t\tfinish_send_packet(pvar);\r\n\t\tenque_handlers(pvar, 2, msgs, handlers);\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n *\tfopen utf-8 wrapper\r\n */\r\nstatic FILE *fopenU8(const char *filenameU8, const char *mode)\r\n{\r\n\twchar_t *filenameW = ToWcharU8(filenameU8);\r\n\twchar_t *modeW = ToWcharU8(mode);\r\n\tFILE *fp;\r\n\t_wfopen_s(&fp, filenameW, modeW);\r\n\tfree(modeW);\r\n\tfree(filenameW);\r\n\treturn fp;\r\n}\r\n\r\n/**\r\n * stat UTF-8 wrapper\r\n */\r\nstatic int statU8(const char *filenameU8, struct __stat64 *st)\r\n{\r\n\twchar_t *filenameW = ToWcharU8(filenameU8);\r\n\tint r = _wstat64(filenameW, st);\r\n\tfree(filenameW);\r\n\treturn r;\r\n}\r\n\r\n/**\r\n *\tExtractFileName() UTF-8\ufffd\ufffd\r\n */\r\nstatic void ExtractFileNameU8(const char *PathName, char *FileName, size_t destlen)\r\n{\r\n\tconst char *sep = strrchr(PathName, '/');\r\n\tif (sep == NULL) {\r\n\t\tsep = strrchr(PathName, '\\\\');\r\n\t}\r\n\tif (sep != NULL) {\r\n\t\tstrncpy_s(FileName, destlen, sep + 1, _TRUNCATE);\r\n\t}\r\n\telse {\r\n\t\tstrncpy_s(FileName, destlen, PathName, _TRUNCATE);\r\n\t}\r\n}\r\n\r\nstatic int accessU8(const char *pathU8, int mode)\r\n{\r\n\twchar_t *pathW = ToWcharU8(pathU8);\r\n\tint r = _waccess(pathW, mode);\r\n\tfree(pathW);\r\n\treturn r;\r\n}\r\n\r\n/**\r\n *\tSCP support\r\n *\r\n *\t@param sendfile\t\t\ufffdt\ufffd@\ufffdC\ufffd\ufffd\ufffd\ufffd,UTF-8\r\n *\t@param dstfile\t\t\ufffdt\ufffd@\ufffdC\ufffd\ufffd\ufffd\ufffd,UTF-8\r\n *\t\t\t\t\t\tTOREMOTE \ufffd\u0302\u0182\ufffd\ufffdA\r\n *\t\t\t\t\t\t\tNULL \ufffd\u0302\u0182\ufffd\ufffdA\ufffdz\ufffd[\ufffd\ufffd\ufffdt\ufffdH\ufffd\ufffd\ufffd_\r\n *\t\t\t\t\t\t\t\ufffd\ufffd\ufffd\u0383p\ufffdX\ufffdA\ufffdz\ufffd[\ufffd\ufffd\ufffdt\ufffdH\ufffd\ufffd\ufffd_\ufffd\ufffd\ufffd\ufffd\u0311\ufffd\ufffd\ufffd?\r\n *\t\t\t\t\t\t\t\ufffd\ufffd\u0383p\ufffdX\r\n *\t\t\t\t\t\tTOLOCAL \ufffd\u0302\u0182\ufffd\r\n *\t\t\t\t\t\t\tNULL \ufffd\u0302\u0182\ufffd\ufffdA\ufffd_\ufffdE\ufffd\ufffd\ufffd\ufffd\ufffd[\ufffdh\ufffdt\ufffdH\ufffd\ufffd\ufffd_\r\n *\t\t\t\t\t\t\t\ufffd\ufffd\ufffd\u0383p\ufffdX\ufffdA\ufffdJ\ufffd\ufffd\ufffd\ufffd\ufffdg\ufffdt\ufffdH\ufffd\ufffd\ufffd_\ufffd\ufffd\ufffd\ufffd\u0311\ufffd\ufffd\ufffd?\r\n *\t\t\t\t\t\t\t\ufffd\ufffd\u0383p\ufffdX\r\n *\t@param direction\tTOREMOTE\tcopy local to remote\r\n *\t\t\t\t\t\tFROMREMOTE\tcopy remote to local\r\n *\r\n */\r\nint SSH_scp_transaction(PTInstVar pvar, const char *sendfile, const char *dstfile, enum scp_dir direction)\r\n{\r\n\tChannel_t *c = NULL;\r\n\tFILE *fp = NULL;\r\n\r\n\t// \ufffd\\\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffdN\ufffd\ufffd\ufffd[\ufffdY\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ua347\ufffd\u0349\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\tif (pvar->socket == INVALID_SOCKET)\r\n\t\tgoto error;\r\n\r\n\tif (SSHv1(pvar))      // SSH1\ufffdT\ufffd|\ufffd[\ufffdg\ufffd\ufffdTBD\r\n\t\tgoto error;\r\n\r\n\t// \ufffd`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\u0752\ufffd\r\n\tc = ssh2_channel_new(CHAN_SES_WINDOW_DEFAULT, CHAN_SES_PACKET_DEFAULT, TYPE_SCP, -1);\r\n\tif (c == NULL) {\r\n\t\tUTIL_get_lang_msg(\"MSG_SSH_NO_FREE_CHANNEL\", pvar,\r\n\t\t                  \"Could not open new channel. TTSSH is already opening too many channels.\");\r\n\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\tgoto error;\r\n\t}\r\n\tif (c->type == TYPE_SCP) {\r\n\t\tc->scp.pvar = pvar;\r\n\t\tpvar->recv.suspended = FALSE;\r\n\t\tpvar->recv.data_finished = FALSE;\r\n\t}\r\n\r\n\tif (direction == TOREMOTE) {  // copy local to remote\r\n\t\tstruct __stat64 st;\r\n\t\tfp = fopenU8(sendfile, \"rb\");\r\n\t\tif (fp == NULL) {\r\n\t\t\tstatic const TTMessageBoxInfoW info = {\r\n\t\t\t\t\"TTSSH\",\r\n\t\t\t\t\"MSG_SSH_SCP_FILEOPEN_ERROR_TITLE\", L\"TTSSH: file open error\",\r\n\t\t\t\t\"MSG_SSH_SCP_FILEOPEN_READ_ERROR\", L\"Can't open file for reading: %s %s\",\r\n\t\t\t\tMB_OK | MB_ICONERROR\r\n\t\t\t};\r\n\t\t\tDWORD error = GetLastError();\r\n\t\t\twchar_t *err_str;\r\n\t\t\thFormatMessageW(error, &err_str);\r\n\t\t\twchar_t *fname = ToWcharU8(sendfile);\r\n\t\t\tTTMessageBoxW(NULL, &info, pvar->ts->UILanguageFileW, err_str, fname);\r\n\t\t\tfree(fname);\r\n\t\t\tfree(err_str);\r\n\t\t\tgoto error;\r\n\t\t}\r\n\r\n\t\tstrncpy_s(c->scp.localfilefull, sizeof(c->scp.localfilefull), sendfile, _TRUNCATE);  // full path\r\n\t\tExtractFileNameU8(sendfile, c->scp.localfile, sizeof(c->scp.localfile));   // file name only\r\n\t\tif (dstfile == NULL || dstfile[0] == '\\0') { // remote file path\r\n\t\t\tstrncpy_s(c->scp.remotefile, sizeof(c->scp.remotefile), \".\", _TRUNCATE);  // full path\r\n\t\t} else {\r\n\t\t\tstrncpy_s(c->scp.remotefile, sizeof(c->scp.remotefile), dstfile, _TRUNCATE);  // full path\r\n\t\t}\r\n\t\tc->scp.localfp = fp;     // file pointer\r\n\r\n\t\tif (statU8(c->scp.localfilefull, &st) == 0) {\r\n\t\t\tc->scp.filestat = st;\r\n\t\t} else {\r\n\t\t\tgoto error;\r\n\t\t}\r\n\t} else { // copy remote to local\r\n\t\tstrncpy_s(c->scp.remotefile, sizeof(c->scp.remotefile), sendfile, _TRUNCATE);\r\n\r\n\t\tif (dstfile == NULL || dstfile[0] == '\\0') { // local file path is empty.\r\n\t\t\tchar *fn;\r\n\t\t\twchar_t *FileDirExpanded;\r\n\t\t\tchar *FileDirExpandedU8;\r\n\r\n\t\t\tfn = strrchr(sendfile, '/');\r\n\t\t\tif (fn && fn[1] == '\\0')\r\n\t\t\t\tgoto error;\r\n\r\n\t\t\thExpandEnvironmentStringsW(pvar->ts->FileDirW, &FileDirExpanded);\r\n\t\t\tFileDirExpandedU8 = ToU8W(FileDirExpanded);\r\n\t\t\t_snprintf_s(c->scp.localfilefull, sizeof(c->scp.localfilefull), _TRUNCATE, \"%s\\\\%s\", FileDirExpandedU8, fn ? fn : sendfile);\r\n\t\t\tfree(FileDirExpanded);\r\n\t\t\tfree(FileDirExpandedU8);\r\n\t\t\tExtractFileName(c->scp.localfilefull, c->scp.localfile, sizeof(c->scp.localfile));   // file name only\r\n\t\t} else {\r\n\t\t\t_snprintf_s(c->scp.localfilefull, sizeof(c->scp.localfilefull), _TRUNCATE, \"%s\", dstfile);\r\n\t\t\tExtractFileName(dstfile, c->scp.localfile, sizeof(c->scp.localfile));   // file name only\r\n\t\t}\r\n\r\n\t\tif (accessU8(c->scp.localfilefull, 0x00) == 0) {\r\n\t\t\tint dlgresult;\r\n\t\t\tif (accessU8(c->scp.localfilefull, 0x02) == -1) { // 0x02 == writable\r\n\t\t\t\tstatic const TTMessageBoxInfoW info = {\r\n\t\t\t\t\t\"TTSSH\",\r\n\t\t\t\t\t\"MSG_SSH_SCP_FILEOPEN_ERROR_TITLE\", L\"TTSSH: file open error\",\r\n\t\t\t\t\t\"MSG_SSH_SCP_FILEOPEN_READONLY_ERROR\", L\"`%s' file is read only.\",\r\n\t\t\t\t\tMB_OK | MB_ICONERROR\r\n\t\t\t\t};\r\n\t\t\t\twchar_t *fname = ToWcharU8(c->scp.localfilefull);\r\n\t\t\t\tTTMessageBoxW(NULL, &info, pvar->ts->UILanguageFileW, fname);\r\n\t\t\t\tfree(fname);\r\n\t\t\t\tgoto error;\r\n\t\t\t}\r\n\t\t\tstatic const TTMessageBoxInfoW info = {\r\n\t\t\t\t\"TTSSH\",\r\n\t\t\t\t\"MSG_SSH_SCP_CONFIRM_TITLE\", L\"TTSSH: confirm\",\r\n\t\t\t\t\"MSG_SSH_SCP_FILEOPEN_OVERWRITE_CONFIRM\", L\"`%s' file exists.\\noverwrite it?\",\r\n\t\t\t\tMB_YESNO | MB_ICONQUESTION\r\n\t\t\t};\r\n\t\t\twchar_t *fname = ToWcharU8(c->scp.localfilefull);\r\n\t\t\tdlgresult = TTMessageBoxW(NULL, &info, pvar->ts->UILanguageFileW, fname);\r\n\t\t\tfree(fname);\r\n\t\t\tif (dlgresult == IDNO) {\r\n\t\t\t\tgoto error;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfp = fopenU8(c->scp.localfilefull, \"wb\");\r\n\t\tif (fp == NULL) {\r\n\t\t\tstatic const TTMessageBoxInfoW info = {\r\n\t\t\t\t\"TTSSH\",\r\n\t\t\t\t\"MSG_SSH_SCP_FILEOPEN_ERROR_TITLE\", L\"TTSSH: file open error\",\r\n\t\t\t\t\"MSG_SSH_SCP_FILEOPEN_WRITE_ERROR\", L\"Can't open file for writing: %s %s\",\r\n\t\t\t\tMB_OK | MB_ICONERROR\r\n\t\t\t};\r\n\t\t\tDWORD error = GetLastError();\r\n\t\t\twchar_t *err_str;\r\n\t\t\thFormatMessageW(error, &err_str);\r\n\t\t\twchar_t *fname = ToWcharU8(c->scp.localfilefull);\r\n\t\t\tTTMessageBoxW(NULL, &info, pvar->ts->UILanguageFileW, err_str, fname);\r\n\t\t\tfree(fname);\r\n\t\t\tfree(err_str);\r\n\t\t\tgoto error;\r\n\t\t}\r\n\r\n\t\tc->scp.localfp = fp;     // file pointer\r\n\t}\r\n\r\n\t// setup SCP data\r\n\tc->scp.dir = direction;\r\n\tc->scp.state = SCP_INIT;\r\n\r\n\t{\r\n\t\tbuffer_t *msg;\r\n\t\tchar *s;\r\n\t\tunsigned char *outmsg;\r\n\t\tint len;\r\n\r\n\t\t// session open\r\n\t\tmsg = buffer_init();\r\n\t\tif (msg == NULL) {\r\n\t\t\tgoto error;\r\n\t\t}\r\n\t\ts = \"session\";\r\n\t\tbuffer_put_string(msg, s, strlen(s));  // ctype\r\n\t\tbuffer_put_int(msg, c->self_id);  // self(channel number)\r\n\t\tbuffer_put_int(msg, c->local_window);  // local_window\r\n\t\tbuffer_put_int(msg, c->local_maxpacket);  // local_maxpacket\r\n\t\tlen = buffer_len(msg);\r\n\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_OPEN, len);\r\n\t\tmemcpy(outmsg, buffer_ptr (msg), len);\r\n\t\tfinish_send_packet(pvar);\r\n\t\tbuffer_free(msg);\r\n\t}\r\n\r\n\tg_scp_sending = TRUE;\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_CHANNEL_OPEN was sent at SSH_scp_transaction().\");\r\n\r\n\treturn TRUE;\r\n\r\nerror:\r\n\tif (c != NULL)\r\n\t\tssh2_channel_delete(c);\r\n\tif (fp != NULL)\r\n\t\tfclose(fp);\r\n\r\n\treturn FALSE;\r\n}\r\n\r\nint SSH_start_scp(PTInstVar pvar, char *sendfile, char *dstfile)\r\n{\r\n\treturn SSH_scp_transaction(pvar, sendfile, dstfile, TOREMOTE);\r\n}\r\n\r\nint SSH_scp_sending_status(void)\r\n{\r\n\treturn g_scp_sending;\r\n}\r\n\r\nint SSH_start_scp_receive(PTInstVar pvar, char *filename)\r\n{\r\n\treturn SSH_scp_transaction(pvar, filename, NULL, FROMREMOTE);\r\n}\r\n\r\n\r\nint SSH_sftp_transaction(PTInstVar pvar)\r\n{\r\n\tbuffer_t *msg;\r\n\tchar *s;\r\n\tunsigned char *outmsg;\r\n\tint len;\r\n\tChannel_t *c = NULL;\r\n//\tFILE *fp = NULL;\r\n//\tstruct __stat64 st;\r\n\r\n\t// \ufffd\\\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffdN\ufffd\ufffd\ufffd[\ufffdY\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ua347\ufffd\u0349\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\tif (pvar->socket == INVALID_SOCKET)\r\n\t\tgoto error;\r\n\r\n\tif (SSHv1(pvar))      // SSH1\ufffdT\ufffd|\ufffd[\ufffdg\ufffd\ufffdTBD\r\n\t\tgoto error;\r\n\r\n\t// \ufffd`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\u0752\ufffd\r\n\tc = ssh2_channel_new(CHAN_SES_WINDOW_DEFAULT, CHAN_SES_PACKET_DEFAULT, TYPE_SFTP, -1);\r\n\tif (c == NULL) {\r\n\t\tUTIL_get_lang_msg(\"MSG_SSH_NO_FREE_CHANNEL\", pvar,\r\n\t\t                  \"Could not open new channel. TTSSH is already opening too many channels.\");\r\n\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\tgoto error;\r\n\t}\r\n\r\n\t// session open\r\n\tmsg = buffer_init();\r\n\tif (msg == NULL) {\r\n\t\tgoto error;\r\n\t}\r\n\ts = \"session\";\r\n\tbuffer_put_string(msg, s, strlen(s));  // ctype\r\n\tbuffer_put_int(msg, c->self_id);  // self(channel number)\r\n\tbuffer_put_int(msg, c->local_window);  // local_window\r\n\tbuffer_put_int(msg, c->local_maxpacket);  // local_maxpacket\r\n\tlen = buffer_len(msg);\r\n\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_OPEN, len);\r\n\tmemcpy(outmsg, buffer_ptr (msg), len);\r\n\tfinish_send_packet(pvar);\r\n\tbuffer_free(msg);\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_CHANNEL_OPEN was sent at SSH_sftp_transaction().\");\r\n\r\n\treturn TRUE;\r\n\r\nerror:\r\n\tif (c != NULL)\r\n\t\tssh2_channel_delete(c);\r\n\r\n\treturn FALSE;\r\n}\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// SSH2 protocol procedure in the following code:\r\n//\r\n/////////////////////////////////////////////////////////////////////////////\r\n\r\nvoid debug_print(int no, char *msg, int len)\r\n{\r\n#ifdef _DEBUG\r\n\tFILE *fp;\r\n\tchar file[128];\r\n\r\n\t_snprintf_s(file, sizeof(file), _TRUNCATE, \"dump%d.bin\", no);\r\n\r\n\tfp = fopen(file, \"wb\");\r\n\tif (fp == NULL)\r\n\t\treturn;\r\n\r\n\tfwrite(msg, 1, len, fp);\r\n\r\n\tfclose(fp);\r\n#endif\r\n}\r\n\r\n\r\n/*\r\n * \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0150\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0312u\ufffd\ufffd\ufffd\ufffdB\ufffd\ufffd\ufffd\u06c2\u0312\u0290M\ufffd\u024eg\ufffd\ufffd\ufffd\ufffd\u0302\ufffdpvar->ssh2_keys[]\ufffd\u0142\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffd\ufffd\ufffd\u0252u\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0142\u034eg\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB\r\n * \ufffdL\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\ufffd^\ufffdC\ufffd~\ufffd\ufffd\ufffdO\ufffd\u0141Apvar->ssh2_keys \ufffd\u0243R\ufffds\ufffd[\ufffd\ufffd\ufffd\ufffdB\r\n */\r\nstatic SSHKeys current_keys[MODE_MAX];\r\n\r\n\r\n#define write_buffer_file(buf,len) do_write_buffer_file(buf,len,__FILE__,__LINE__)\r\n\r\n\r\nstatic void do_write_buffer_file(void *buf, int len, char *file, int lineno)\r\n{\r\n\tFILE *fp;\r\n\tchar filename[256];\r\n\r\n\t_snprintf_s(filename, sizeof(filename), _TRUNCATE, \"data%d.bin\", lineno);\r\n\r\n\tfp = fopen(filename, \"wb\");\r\n\tif (fp == NULL)\r\n\t\treturn;\r\n\r\n\tfwrite(buf, 1, len, fp);\r\n\r\n\tfclose(fp);\r\n}\r\n\r\nvoid SSH2_packet_start(buffer_t *msg, unsigned char type)\r\n{\r\n\tunsigned char buf[9];\r\n\tint len = 6;\r\n\r\n\tmemset(buf, 0, sizeof(buf));\r\n\tbuf[len - 1] = type;\r\n\tbuffer_clear(msg);\r\n\tbuffer_append(msg, buf, len);\r\n}\r\n\r\n// \ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffd\ufffdT\ufffd[\ufffdo\ufffd\u0582\u0303L\ufffd[\ufffd\ufffd\ufffd\ufffd\ufffdJ\ufffdn\ufffdv\ufffd\ufffd\r\nvoid SSH2_send_kexinit(PTInstVar pvar)\r\n{\r\n\tchar cookie[SSH2_COOKIE_LENGTH];\r\n\tbuffer_t *msg;\r\n\tunsigned char *outmsg;\r\n\tint len, i;\r\n\r\n\tmsg = buffer_init();\r\n\tif (msg == NULL) {\r\n\t\t// TODO: error check\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\treturn;\r\n\t}\r\n\tif (pvar->my_kex != NULL)\r\n\t\tbuffer_free(pvar->my_kex);\r\n\tpvar->my_kex = msg;\r\n\r\n\t// \ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd^\ufffdC\ufffdv\r\n\t//SSH2_packet_start(msg, SSH2_MSG_KEXINIT);\r\n\r\n\t// cookie\ufffd\u0303Z\ufffdb\ufffdg\r\n\tCRYPT_set_random_data(pvar, cookie, sizeof(cookie));\r\n\tCRYPT_set_client_cookie(pvar, cookie);\r\n\tbuffer_append(msg, cookie, sizeof(cookie));\r\n\r\n\t// \ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg\ufffd\u0303L\ufffd[\ufffd\ufffd\ufffd\r\n\tfor (i = 0 ; i < PROPOSAL_MAX ; i++) {\r\n\t\tbuffer_put_string(msg, myproposal[i], strlen(myproposal[i]));\r\n\t}\r\n\tbuffer_put_char(msg, 0);\r\n\tbuffer_put_int(msg, 0);\r\n\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE,\r\n\t\t\"client proposal: KEX algorithm: %s\",\r\n\t\tmyproposal[0]);\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE,\r\n\t\t\"client proposal: server host key algorithm: %s\",\r\n\t\tmyproposal[1]);\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE,\r\n\t\t\"client proposal: encryption algorithm client to server: %s\",\r\n\t\tmyproposal[2]);\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE,\r\n\t\t\"client proposal: encryption algorithm server to client: %s\",\r\n\t\tmyproposal[3]);\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE,\r\n\t\t\"client proposal: MAC algorithm client to server: %s\",\r\n\t\tmyproposal[4]);\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE,\r\n\t\t\"client proposal: MAC algorithm server to client: %s\",\r\n\t\tmyproposal[5]);\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE,\r\n\t\t\"client proposal: compression algorithm client to server: %s\",\r\n\t\tmyproposal[6]);\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE,\r\n\t\t\"client proposal: compression algorithm server to client: %s\",\r\n\t\tmyproposal[7]);\r\n\r\n\r\n\tlen = buffer_len(msg);\r\n\toutmsg = begin_send_packet(pvar, SSH2_MSG_KEXINIT, len);\r\n\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\tfinish_send_packet(pvar);\r\n\r\n\t// my_kex\ufffd\u024e\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u07c1A\ufffdt\ufffd\ufffd\ufffd[\ufffd\ufffd\ufffd\u0102\u0342\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t//buffer_free(msg);\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_KEXINIT was sent at SSH2_send_kexinit().\");\r\n}\r\n\r\n\r\nvoid normalize_generic_order(char *buf, char default_strings[], int default_strings_len)\r\n{\r\n\tchar listed[max(KEX_DH_MAX,max(SSH_CIPHER_MAX,max(KEY_ALGO_MAX,max(HMAC_MAX,COMP_MAX)))) + 1];\r\n\tchar allowed[max(KEX_DH_MAX,max(SSH_CIPHER_MAX,max(KEY_ALGO_MAX,max(HMAC_MAX,COMP_MAX)))) + 1];\r\n\tint i, j, k=-1;\r\n\r\n\tmemset(listed, 0, sizeof(listed));\r\n\tmemset(allowed, 0, sizeof(allowed));\r\n\r\n\t// \ufffd\ufffd\ufffd\u0082\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u9576\ufffd\ufffd\ufffd\u0303\ufffd\ufffdX\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\tfor (i = 0; i < default_strings_len ; i++) {\r\n\t\tallowed[default_strings[i]] = 1;\r\n\t}\r\n\r\n\t// \ufffdw\ufffd\u80b3\ufffd\ua0bd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ud805\udd8d\ufffd\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffd\u0082\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdA\ufffdd\ufffd\ufffd\ufffd\ufffd\ufffd\u9576\ufffd\ufffd\ufffd\u034d\ud3dc\ufffd\ufffd\ufffd\ufffdB\r\n\t//\r\n\t// ex. (i=5 \ufffd\u0315\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ud3dc\ufffd\ufffd\ufffd\ufffd)\r\n\t// i=012345\r\n\t//   >:=9<87;A@?B3026(\\0)\r\n\t//         i+1\r\n\t//         <------------>\r\n\t//       \ufffd\ufffd\r\n\t//   >:=9<7;A@?B3026(\\0)\r\n\t//\r\n\tfor (i = 0; buf[i] != 0; i++) {\r\n\t\tint num = buf[i] - '0';\r\n\r\n\t\tif (num < 0 || num > default_strings_len\r\n\t\t\t|| !allowed[num]\r\n\t\t\t|| listed[num]) {\r\n\t\t\tmemmove(buf + i, buf + i + 1, strlen(buf + i + 1) + 1);\r\n\t\t\ti--;\r\n\t\t} else {\r\n\t\t\tlisted[num] = 1;\r\n\t\t}\r\n\r\n\t\t// disabled line\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0381A\ufffd\u0292u\ufffd\ufffd\ufffdo\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffdB\r\n\t\tif (num == 0) {\r\n\t\t\tk = i;\r\n\t\t}\r\n\t}\r\n\r\n\t// \ufffdw\ufffd\u80b3\ufffd\ufffd\u0102\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0381Adisabled line\ufffd\u0312\ufffd\ufffdO\ufffd\u0251}\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t//\r\n\t// ex. (Z\ufffd\ufffd}\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd)\r\n\t//                k\r\n\t//   >:=9<87;A@?B3026(\\0)\r\n\t//                 k+1\r\n\t//                 <---->\r\n\t//       \ufffd\ufffd       k\r\n\t//   >:=9<87;A@?B30026(\\0)\r\n\t//       \ufffd\ufffd        k\r\n\t//   >:=9<87;A@?B3Z026(\\0)\r\n\t//\r\n\tfor (j = 0; j < default_strings_len && default_strings[j] != 0; j++) {\r\n\t\tint num = default_strings[j];\r\n\r\n\t\tif (!listed[num] && k >= 0) {\r\n\t\t\tint copylen = strlen(buf + k + 1) + 1;\r\n\r\n\t\t\tmemmove(buf + k + 1, buf + k, copylen);\r\n\t\t\tbuf[k + 1 + copylen] = '\\0';   // \ufffdI\ufffd[\ufffd\ufffdY\ufffd\ua0b8\ufffd\u0255t\ufffd\ufffd\ufffd\ufffdB\r\n\t\t\tbuf[k] = num + '0';\r\n\t\t\tk++;\r\n\t\t\ti++;\r\n\t\t}\r\n\t}\r\n\tif (k < 0) {\r\n\t\tj = 0;\r\n\t}\r\n\telse {\r\n\t\tj++;\r\n\t}\r\n\r\n\t// disabled line\ufffd\ufffd\ufffd\ufffd\ufffd\u0742\ufffd\ufffd\u0202\ufffd\ufffd\ua347\ufffd\u0341A\ufffd\ufffd\ufffd\u0302\u0702\u0716\ufffd\ufffd\ufffd\ufffd\u0252\u01c9\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\tfor (; j < default_strings_len ; j++) {\r\n\t\tint num = default_strings[j];\r\n\r\n\t\tif (!listed[num]) {\r\n\t\t\tbuf[i] = num + '0';\r\n\t\t\tlisted[num] = 1;\r\n\t\t\ti++;\r\n\t\t}\r\n\t}\r\n\r\n\tbuf[i] = 0;\r\n}\r\n\r\nvoid choose_SSH2_proposal(char *server_proposal,\r\n                          char *my_proposal,\r\n                          char *dest,\r\n                          int dest_len)\r\n{\r\n\tchar tmp_cli[1024], *ptr_cli, *ctc_cli;\r\n\tchar tmp_svr[1024], *ptr_svr, *ctc_svr;\r\n\r\n\tstrncpy_s(tmp_cli, sizeof(tmp_cli), my_proposal, _TRUNCATE);\r\n\tptr_cli = strtok_s(tmp_cli, \",\", &ctc_cli);\r\n\twhile (ptr_cli != NULL) {\r\n\t\t// server_proposal\ufffd\u0242\u0343T\ufffd[\ufffdo\ufffd\ufffdproposal\ufffd\ufffd\ufffdJ\ufffd\ufffd\ufffd}\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u014ai\ufffd[\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\r\n\t\tstrncpy_s(tmp_svr, sizeof(tmp_svr), server_proposal, _TRUNCATE);\r\n\t\tptr_svr = strtok_s(tmp_svr, \",\", &ctc_svr);\r\n\t\twhile (ptr_svr != NULL) {\r\n\t\t\tif (strcmp(ptr_svr, ptr_cli) == 0) { // match\r\n\t\t\t\tgoto found;\r\n\t\t\t}\r\n\t\t\tptr_svr = strtok_s(NULL, \",\", &ctc_svr);\r\n\t\t}\r\n\t\tptr_cli = strtok_s(NULL, \",\", &ctc_cli);\r\n\t}\r\n\r\nfound:\r\n\tif (ptr_cli != NULL) {\r\n\t\tstrncpy_s(dest, dest_len, ptr_cli, _TRUNCATE);\r\n\t}\r\n\telse {\r\n\t\tstrncpy_s(dest, dest_len, \"\", _TRUNCATE);\r\n\t}\r\n}\r\n\r\n// \ufffd\u00cd\ufffd\ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd\ufffd\u0303L\ufffd[\ufffdT\ufffdC\ufffdY\ufffdA\ufffdu\ufffd\ufffd\ufffdb\ufffdN\ufffdT\ufffdC\ufffdY\ufffdAMAC\ufffdT\ufffdC\ufffdY\ufffd\u0302\ufffd\ufffd\ufffd\ufffd\u0151\ufffdl(we_need)\ufffd\ufffd\ufffd\ufffd\ufffd\u80b7\ufffd\ufffdB\r\nstatic void choose_SSH2_key_maxlength(PTInstVar pvar)\r\n{\r\n\tint mode, val;\r\n\tunsigned int need = 0;\r\n\tconst EVP_MD *md;\r\n\tconst struct ssh2cipher *cipher;\r\n\tconst struct SSH2Mac *mac;\r\n\r\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\r\n\t\tcipher = pvar->ciphers[mode];\r\n\t\tmac = pvar->macs[mode];\r\n\r\n\t\t// current_keys[]\ufffd\u0250\u0752\u80b5\ufffd\u0102\ufffd\ufffd\ufffd\ufffd\u0101A\ufffd\ufffd\ufffd\u0182\ufffd pvar->ssh2_keys[] \ufffd\u0583R\ufffds\ufffd[\ufffd\ufffd\ufffd\ufffdB\r\n\t\tmd = get_ssh2_mac_EVP_MD(mac);\r\n\t\tcurrent_keys[mode].mac.md = md;\r\n\t\tcurrent_keys[mode].mac.key_len = current_keys[mode].mac.mac_len = EVP_MD_size(md);\r\n\t\tval = get_ssh2_mac_truncatebits(mac);\r\n\t\tif (val != 0) {\r\n\t\t\tcurrent_keys[mode].mac.mac_len = val / 8;\r\n\t\t}\r\n\t\tcurrent_keys[mode].mac.etm = get_ssh2_mac_etm(mac);\r\n\r\n\t\t// \ufffdL\ufffd[\ufffdT\ufffdC\ufffdY\ufffd\u0183u\ufffd\ufffd\ufffdb\ufffdN\ufffdT\ufffdC\ufffdY\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0150\u0752\u80b5\ufffd\u0102\ufffd\ufffd\ufffd (2004.11.7 yutaka)\r\n\t\tcurrent_keys[mode].enc.key_len = get_cipher_key_len(cipher);\r\n\t\tcurrent_keys[mode].enc.block_size = get_cipher_block_size(cipher);\r\n\t\tcurrent_keys[mode].enc.iv_len = get_cipher_iv_len(cipher);\r\n\t\tcurrent_keys[mode].enc.auth_len = get_cipher_auth_len(cipher);\r\n\r\n\t\tcurrent_keys[mode].mac.enabled = 0;\r\n\t\tcurrent_keys[mode].comp.enabled = 0; // (2005.7.9 yutaka)\r\n\r\n\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd_\ufffd\u0142\ufffdMAC\ufffd\ufffddisable\r\n\t\tpvar->ssh2_keys[mode].mac.enabled = 0;\r\n\t\tpvar->ssh2_keys[mode].comp.enabled = 0; // (2005.7.9 yutaka)\r\n\r\n\t\tneed = max(need, current_keys[mode].enc.key_len);\r\n\t\tneed = max(need, current_keys[mode].enc.block_size);\r\n\t\tneed = max(need, current_keys[mode].enc.iv_len);\r\n\t\tneed = max(need, current_keys[mode].mac.key_len);\r\n\t}\r\n\tpvar->we_need = need;\r\n}\r\n\r\n\r\n/*\r\n * \ufffdL\ufffd[\ufffd\ufffd\ufffd\ufffd\ufffdJ\ufffdn\ufffdO\ufffd\u0303`\ufffdF\ufffdb\ufffdN (SSH2_MSG_KEXINIT)\r\n * \ufffd\ufffd\ufffd\ufffd\ufffdY\ufffd\u0590\ufffd\ufffd\u0343f\ufffd[\ufffd^\ufffd\u0290M\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\u0102\u0382\ufffd\u0102\ufffd\ufffd\ufffd\u0094\\\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\r\n *\r\n * SSH2_MSG_KEXINIT:\r\n *   byte         SSH_MSG_KEXINIT\r\n *   byte[16]     cookie (random bytes)\r\n *   name-list    kex_algorithms\r\n *   name-list    server_host_key_algorithms\r\n *   name-list    encryption_algorithms (c2s)\r\n *   name-list    encryption_algorithms (s2c)\r\n *   name-list    mac_algorithms (c2s)\r\n *   name-list    mac_algorithms (s2c)\r\n *   name-list    compression_algorithms (c2s)\r\n *   name-list    compression_algorithms (s2c)\r\n *   name-list    languages (c2s)\r\n *   name-list    languages (s2c)\r\n *   boolean      first_kex_packet_follows\r\n *   uint32       0 (reserved for future extension)\r\n */\r\nstatic BOOL handle_SSH2_kexinit(PTInstVar pvar)\r\n{\r\n\tchar buf[1024];\r\n\tchar *data;\r\n\tint len, size;\r\n\tchar *msg = NULL;\r\n\tchar tmp[1024+512];\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_KEXINIT was received.\");\r\n\r\n\t// \ufffd\ufffd\ufffd\u0142\u0243L\ufffd[\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdI\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\u0582\ufffd\u70b8\ufffdA\ufffdT\ufffd[\ufffdo\ufffd\ufffd\ufffd\ufffd SSH2_MSG_KEXINIT \ufffd\ufffd\r\n\t// \ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ua347\ufffd\u0341A\ufffdL\ufffd[\ufffd\u010d\uc42c\ufffd\ufffd\ufffds\ufffd\ufffd\ufffdB(2004.10.24 yutaka)\r\n\tif (pvar->kex_status == KEX_FLAG_KEXDONE) {\r\n\t\tpvar->kex_status = KEX_FLAG_REKEYING;\r\n\r\n\t\t// \ufffdL\ufffd[\ufffd\u010d\uc42c\ufffd\ufffd\ufffd\ufffd myproposal \ufffd\ufffd\ufffd\ufffd \",ext-info-c,kex-strict-c-v00@openssh.com\" \ufffd\ufffd\ufffd\ud3dc\ufffd\ufffd\ufffd\ufffd\r\n\t\t// \ufffdX\ufffdV\ufffd\ufffd\ufffd\ufffd\u0302\ufffd KEX \ufffd\u0302\u0742\u0142\u60a2\r\n\t\tSSH2_update_kex_myproposal(pvar);\r\n\r\n\t\t// \ufffdT\ufffd[\ufffdo\ufffd\ufffdSSH2_MSG_KEXINIT \ufffd\ud805\uddc2\ufffd\r\n\t\tSSH2_send_kexinit(pvar);\r\n\t}\r\n\r\n\tdata = remained_payload(pvar);\r\n\tlen = remained_payloadlen(pvar);\r\n\r\n\t// KEX \ufffd\u030d\u014c\ufffd\ufffd exchange-hash (session-id) \ufffd\ufffd\ufffdv\ufffdZ\ufffd\ufffd\ufffd\ufffd\u0302\u024eg\ufffd\ufffd\ufffd\u0302\u0155\u06d1\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\r\n\tif (pvar->peer_kex != NULL) {\r\n\t\t// already allocated\r\n\t\tbuffer_clear(pvar->peer_kex);\r\n\t}\r\n\telse {\r\n\t\tpvar->peer_kex = buffer_init();\r\n\t\tif (pvar->peer_kex == NULL) {\r\n\t\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\r\n\t\t\t\t\t\t\"%s: Out of memory\", __FUNCTION__);\r\n\t\t\tmsg = tmp;\r\n\t\t\tgoto error;\r\n\t\t}\r\n\t}\r\n\tbuffer_append(pvar->peer_kex, data, len);\r\n\r\n\tpush_memdump(\"KEXINIT\", \"exchange algorithm list: receiving\", data, len);\r\n\r\n\t// cookie\r\n\tif (! get_bytearray_from_payload(pvar, buf, SSH2_COOKIE_LENGTH)) {\r\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: truncated packet (cookie)\", __FUNCTION__);\r\n\t\tmsg = tmp;\r\n\t\tgoto error;\r\n\t}\r\n\tCRYPT_set_server_cookie(pvar, buf);\r\n\r\n\t// \ufffde\ufffdv\ufffdf(\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd,\ufffd\u00cd\ufffd\ufffd\ufffd\ufffd\ufffd)\ufffd\u014eg\ufffdp\ufffd\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd\ufffd\u030c\ufffd\ufffd\ufffdB\r\n\t// \ufffdT\ufffd[\ufffdo\ufffd\ufffd\ufffd\ufffd\u0343J\ufffd\ufffd\ufffd}\ufffd\ufffd\u0602\ufffd\u0142\u0303\ufffd\ufffdX\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0117\ufffd\ufffd\ufffdB\r\n\t// \ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg\ufffd\u0183T\ufffd[\ufffdo\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdT\ufffd|\ufffd[\ufffdg\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u9568\ufffd\u0302\ufffd\ufffd\ufffd\ufffdA\r\n\t// \ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffd\u014d\u0142\ufffd\ufffdO\ufffd\u024ew\ufffd\u80b5\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffd\ufffdB\r\n\r\n\t// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd\r\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\r\n\tcase GetPayloadError:\r\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: truncated packet (kex algorithms)\", __FUNCTION__);\r\n\t\tmsg = tmp;\r\n\t\tgoto error;\r\n\tcase GetPayloadTruncate:\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed kex algorithms is too long.\", __FUNCTION__);\r\n\t\tbreak;\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: KEX algorithm: %s\", buf);\r\n\r\n\tpvar->kex_type = choose_SSH2_kex_algorithm(buf, myproposal[PROPOSAL_KEX_ALGS]);\r\n\tif (pvar->kex_type == KEX_DH_UNKNOWN) { // not match\r\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown KEX algorithm: \", _TRUNCATE);\r\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\r\n\t\tmsg = tmp;\r\n\t\tgoto error;\r\n\t}\r\n\r\n\t// \ufffdT\ufffd[\ufffdo\ufffd[\ufffd\ufffd\ufffd\ufffdStrict KEX\ufffd\u0251\u0389\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u90a9\ufffd\u030am\ufffdF\r\n\tchoose_SSH2_proposal(buf, \"kex-strict-s-v00@openssh.com\", tmp, sizeof(tmp));\r\n\tif (tmp[0] != '\\0') {\r\n\t\tpvar->server_strict_kex = TRUE;\r\n\t\tlogprintf(LOG_LEVEL_INFO, \"Server supports strict kex. Strict kex will be enabled.\");\r\n\t}\r\n\r\n\t// \ufffdz\ufffdX\ufffdg\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd\r\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\r\n\tcase GetPayloadError:\r\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: truncated packet (hostkey algorithms)\", __FUNCTION__);\r\n\t\tmsg = tmp;\r\n\t\tgoto error;\r\n\tcase GetPayloadTruncate:\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed hostkey algorithms is too long.\", __FUNCTION__);\r\n\t\tbreak;\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: server host key algorithm: %s\", buf);\r\n\r\n\tpvar->hostkey_type = choose_SSH2_host_key_algorithm(buf, myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS]);\r\n\tif (pvar->hostkey_type == KEY_ALGO_UNSPEC) {\r\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown host KEY algorithm: \", _TRUNCATE);\r\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\r\n\t\tmsg = tmp;\r\n\t\tgoto error;\r\n\t}\r\n\r\n\t// \ufffd\u00cd\ufffd\ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd(\ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg -> \ufffdT\ufffd[\ufffdo)\r\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\r\n\tcase GetPayloadError:\r\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: truncated packet (encryption algorithms client to server)\", __FUNCTION__);\r\n\t\tmsg = tmp;\r\n\t\tgoto error;\r\n\tcase GetPayloadTruncate:\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed encryption algorithms (client to server) is too long.\", __FUNCTION__);\r\n\t\tbreak;\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: encryption algorithm client to server: %s\", buf);\r\n\r\n\tpvar->ciphers[MODE_OUT] = choose_SSH2_cipher_algorithm(buf, myproposal[PROPOSAL_ENC_ALGS_CTOS]);\r\n\tif (pvar->ciphers[MODE_OUT] == NULL) {\r\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown Encrypt algorithm(client to server): \", _TRUNCATE);\r\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\r\n\t\tmsg = tmp;\r\n\t\tgoto error;\r\n\t}\r\n\r\n\t// \ufffd\u00cd\ufffd\ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd(\ufffdT\ufffd[\ufffdo -> \ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg)\r\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\r\n\tcase GetPayloadError:\r\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: truncated packet (encryption algorithms server to client)\", __FUNCTION__);\r\n\t\tmsg = tmp;\r\n\t\tgoto error;\r\n\tcase GetPayloadTruncate:\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed encryption algorithms (server to client) is too long.\", __FUNCTION__);\r\n\t\tbreak;\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: encryption algorithm server to client: %s\", buf);\r\n\r\n\tpvar->ciphers[MODE_IN] = choose_SSH2_cipher_algorithm(buf, myproposal[PROPOSAL_ENC_ALGS_STOC]);\r\n\tif (pvar->ciphers[MODE_IN] == NULL) {\r\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown Encrypt algorithm(server to client): \", _TRUNCATE);\r\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\r\n\t\tmsg = tmp;\r\n\t\tgoto error;\r\n\t}\r\n\r\n\t// MAC\ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd(\ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg -> \ufffdT\ufffd[\ufffdo)\r\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\r\n\tcase GetPayloadError:\r\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: truncated packet (MAC algorithms client to server)\", __FUNCTION__);\r\n\t\tmsg = tmp;\r\n\t\tgoto error;\r\n\tcase GetPayloadTruncate:\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed MAC algorithms (client to server) is too long.\", __FUNCTION__);\r\n\t\tbreak;\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: MAC algorithm client to server: %s\", buf);\r\n\r\n\tif (get_cipher_auth_len(pvar->ciphers[MODE_OUT]) > 0) {\r\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"AEAD cipher is selected, ignoring MAC algorithms. (client to server)\");\r\n\t\tpvar->macs[MODE_OUT] = get_ssh2_mac(HMAC_IMPLICIT);\r\n\t}\r\n\telse {\r\n\t\tpvar->macs[MODE_OUT] = choose_SSH2_mac_algorithm(buf, myproposal[PROPOSAL_MAC_ALGS_CTOS]);\r\n\t\tif (pvar->macs[MODE_OUT] == NULL) { // not match\r\n\t\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown MAC algorithm: \", _TRUNCATE);\r\n\t\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\r\n\t\t\tmsg = tmp;\r\n\t\t\tgoto error;\r\n\t\t}\r\n\t}\r\n\r\n\t// MAC\ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd(\ufffdT\ufffd[\ufffdo -> \ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg)\r\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\r\n\tcase GetPayloadError:\r\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: truncated packet (MAC algorithms server to client)\", __FUNCTION__);\r\n\t\tmsg = tmp;\r\n\t\tgoto error;\r\n\tcase GetPayloadTruncate:\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed MAC algorithms (server to client) is too long.\", __FUNCTION__);\r\n\t\tbreak;\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: MAC algorithm server to client: %s\", buf);\r\n\r\n\tif (get_cipher_auth_len(pvar->ciphers[MODE_IN]) > 0) {\r\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"AEAD cipher is selected, ignoring MAC algorithms. (server to client)\");\r\n\t\tpvar->macs[MODE_IN] = get_ssh2_mac(HMAC_IMPLICIT);\r\n\t}\r\n\telse {\r\n\t\tpvar->macs[MODE_IN] = choose_SSH2_mac_algorithm(buf, myproposal[PROPOSAL_MAC_ALGS_STOC]);\r\n\t\tif (pvar->macs[MODE_IN] == NULL) { // not match\r\n\t\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown MAC algorithm: \", _TRUNCATE);\r\n\t\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\r\n\t\t\tmsg = tmp;\r\n\t\t\tgoto error;\r\n\t\t}\r\n\t}\r\n\r\n\t// \ufffd\ufffd\ufffdk\ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd(\ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg -> \ufffdT\ufffd[\ufffdo)\r\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\r\n\tcase GetPayloadError:\r\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: truncated packet (compression algorithms client to server)\", __FUNCTION__);\r\n\t\tmsg = tmp;\r\n\t\tgoto error;\r\n\tcase GetPayloadTruncate:\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed compression algorithms (client to server) is too long.\", __FUNCTION__);\r\n\t\tbreak;\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: compression algorithm client to server: %s\", buf);\r\n\r\n\tpvar->ctos_compression = choose_SSH2_compression_algorithm(buf, myproposal[PROPOSAL_COMP_ALGS_CTOS]);\r\n\tif (pvar->ctos_compression == COMP_UNKNOWN) { // not match\r\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown Packet Compression algorithm: \", _TRUNCATE);\r\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\r\n\t\tmsg = tmp;\r\n\t\tgoto error;\r\n\t}\r\n\r\n\t// \ufffd\ufffd\ufffdk\ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd(\ufffdT\ufffd[\ufffdo -> \ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg)\r\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\r\n\tcase GetPayloadError:\r\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: truncated packet (compression algorithms server to client)\", __FUNCTION__);\r\n\t\tmsg = tmp;\r\n\t\tgoto error;\r\n\tcase GetPayloadTruncate:\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed compression algorithms (server to client) is too long.\", __FUNCTION__);\r\n\t\tbreak;\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: compression algorithm server to client: %s\", buf);\r\n\r\n\tpvar->stoc_compression = choose_SSH2_compression_algorithm(buf, myproposal[PROPOSAL_COMP_ALGS_STOC]);\r\n\tif (pvar->stoc_compression == COMP_UNKNOWN) { // not match\r\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown Packet Compression algorithm: \", _TRUNCATE);\r\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\r\n\t\tmsg = tmp;\r\n\t\tgoto error;\r\n\t}\r\n\r\n\t// \ufffd\ufffd\ufffd\ufffd(\ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg -> \ufffdT\ufffd[\ufffdo)\r\n\t// \ufffd\ufffd\ufffd\ufffd\u0142\u0356\ufffd\ufffdg\ufffdp\ufffdB\ufffd\ufffd\ufffdO\ufffd\u024bL\ufffd^\ufffd\ufffd\ufffd\u90be\ufffd\ufffd\ufffdB\r\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\r\n\tcase GetPayloadError:\r\n\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd name-list \ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\u0182\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd KEXINIT \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\u0303t\ufffdH\ufffd[\ufffd}\ufffdb\ufffdg\ufffd\ufffd\ufffd\u0302\ufffd\ufffdz\ufffd\ufffdO\ufffd\u0142\ufffd\ufffd\ufffd\r\n\t\t// \ufffd\u064f\ufffd\u020f\ufffd\u0502\u0142\ufffd\ufffd\u90aa\ufffdA\ufffd\u0290M\ufffd\u0255K\ufffdv\ufffd\u0203A\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd\ufffd\u0342\ufffd\ufffd\u0142\u0243l\ufffdS\ufffd\u03c2\u0742\u0152\u0290M\ufffd\ufffd\ufffd\u0302\u034ds\ufffd\ufffd\ufffd\ufffdB\r\n\t\t// \ufffd\ufffd\ufffd\u0702\u0142\u0342\ufffd\ufffd\u0315\ufffd\ufffd\ufffd\ufffd\u0303`\ufffdF\ufffdb\ufffdN\ufffd\ufffd\ufffds\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0141A\ufffdx\ufffd\ufffd\ufffd\ufffd\ufffdL\ufffd^\ufffd\ufffd\ufffd\ufffd\u0302\u0742\u014f\ufffd\ufffd\ufffd\ufffd\ud807\udc4ds\ufffd\ufffd\ufffd\ufffdB\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: truncated packet (language client to server)\", __FUNCTION__);\r\n\t\tgoto skip;\r\n\tcase GetPayloadTruncate:\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed language (client to server) is too long.\", __FUNCTION__);\r\n\t\tbreak;\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: language client to server: %s\", buf);\r\n\r\n\t// \ufffd\ufffd\ufffd\ufffd(\ufffdT\ufffd[\ufffdo -> \ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg)\r\n\t// \ufffd\ufffd\ufffd\ufffd\u0142\u0356\ufffd\ufffdg\ufffdp\ufffdB\ufffd\ufffd\ufffdO\ufffd\u024bL\ufffd^\ufffd\ufffd\ufffd\u90be\ufffd\ufffd\ufffdB\r\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\r\n\tcase GetPayloadError:\r\n\t\t// \ufffd\ufffd\ufffd\ufffd(\ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg -> \ufffdT\ufffd[\ufffdo) \ufffd\u0193\ufffd\ufffdl\ufffd\u0241A\ufffd\ufffd\u80aa\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffdx\ufffd\ufffd\ufffd\u0302\u0742\u0182\ufffd\ufffd\ufffdB\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: truncated packet (language server to client)\", __FUNCTION__);\r\n\t\tgoto error;\r\n\tcase GetPayloadTruncate:\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed language (server to client) is too long.\", __FUNCTION__);\r\n\t\tbreak;\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: language server to client: %s\", buf);\r\n\r\n\t// first_kex_packet_follows:\r\n\t// KEXINIT \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\u030c\ufffd\u0241A\ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd\ufffd\u0303l\ufffdS\ufffd\ufffd\ufffd\u0282\ud800\udd11\ufffd\ufffd\ufffd\ufffd\u010c\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ud805\uddc2\ufffd\ufffd\u0102\ufffd\ufffd\u90a9\ufffdB\r\n\t// SSH_MSG_KEXINIT \ufffd\u030c\ufffd\u030c\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0343N\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\u7457\ufffd\ufffd\u0302\u0143T\ufffd[\ufffdo\ufffd\ufffd\ufffd\ufffd 1 \ufffd\u0242\ufffd\ufffd\u9396\ufffd\u0342\u0202\ufffd\ufffd\u0342\ufffd\ufffdB\r\n\tif (!get_boolean_from_payload(pvar, buf)) {\r\n\t\t// \ufffd\ufffd\ufffd\ufffd(\ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg -> \ufffdT\ufffd[\ufffdo) \ufffd\u0193\ufffd\ufffdl\ufffd\u0241A\ufffd\ufffd\u80aa\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffdx\ufffd\ufffd\ufffd\u0302\u0742\u0182\ufffd\ufffd\ufffdB\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: truncated packet (first_kex_packet_follows)\", __FUNCTION__);\r\n\t\tgoto skip;\r\n\t}\r\n\tif (buf[0] != 0) {\r\n\t\t// \ufffdO\ufffdq\ufffd\u0302\u60a4\ufffd\u0243T\ufffd[\ufffdo\ufffd\ufffd\ufffd\ufffd 0 \ufffd\u020aO\ufffd\u0242\ufffd\ufffd\u9396\ufffd\u0342\u0202\ufffd\ufffd\u0342\ufffd\ufffd\u0202\u0302\u0141A\ufffdx\ufffd\ufffd\ufffd\ufffd\ufffdL\ufffd^\ufffd\ufffd\ufffd\ufffdB\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: first_kex_packet_follows is not 0. (%d)\", __FUNCTION__, buf[0]);\r\n\t}\r\n\r\n\t// reserved: \ufffd\ufffd\ufffd\ufffd\u034f\ufffd\ufffd 0 \ufffd\u0182\u0202\ufffdB\r\n\tif (!get_uint32_from_payload(pvar, &size)) {\r\n\t\t// \ufffd\ufffd\ufffd\ufffd(\ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg -> \ufffdT\ufffd[\ufffdo) \ufffd\u0193\ufffd\ufffdl\ufffd\u0241A\ufffd\ufffd\u80aa\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffdx\ufffd\ufffd\ufffd\u0302\u0742\u0182\ufffd\ufffd\ufffdB\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: truncated packet (reserved)\", __FUNCTION__ );\r\n\t\tgoto skip;\r\n\t}\r\n\tif (size != 0) {\r\n\t\tlogprintf(LOG_LEVEL_INFO, \"%s: reserved data is not 0. (%d)\", __FUNCTION__, size);\r\n\t}\r\n\r\nskip:\r\n\t// \ufffd\ufffd\ufffd\u80b5\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdO\ufffd\u024fo\ufffd\ufffd\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"KEX algorithm: %s\",\r\n\t\tget_kex_algorithm_name(pvar->kex_type));\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server host key algorithm: %s\",\r\n\t\tget_ssh2_hostkey_algorithm_name(pvar->hostkey_type));\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"encryption algorithm client to server: %s\",\r\n\t\tget_cipher_string(pvar->ciphers[MODE_OUT]));\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"encryption algorithm server to client: %s\",\r\n\t\tget_cipher_string(pvar->ciphers[MODE_IN]));\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"MAC algorithm client to server: %s\",\r\n\t\tget_ssh2_mac_name(pvar->macs[MODE_OUT]));\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"MAC algorithm server to client: %s\",\r\n\t\tget_ssh2_mac_name(pvar->macs[MODE_IN]));\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"compression algorithm client to server: %s\",\r\n\t\tget_ssh2_comp_name(pvar->ctos_compression));\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"compression algorithm server to client: %s\",\r\n\t\tget_ssh2_comp_name(pvar->stoc_compression));\r\n\r\n\t// we_need\ufffd\u030c\ufffd\ufffd\ufffd (2004.11.6 yutaka)\r\n\t// \ufffdL\ufffd[\ufffd\u010d\uc42c\ufffd\u030f\ua347\ufffd\u0343X\ufffdL\ufffdb\ufffdv\ufffd\ufffd\ufffd\ufffdB\r\n\tif ((pvar->kex_status & KEX_FLAG_REKEYING) == 0) {\r\n\t\tchoose_SSH2_key_maxlength(pvar);\r\n\t}\r\n\r\n\t// send DH kex init\r\n\tswitch (pvar->kex_type) {\r\n\t\tcase KEX_DH_GRP1_SHA1:\r\n\t\tcase KEX_DH_GRP14_SHA1:\r\n\t\tcase KEX_DH_GRP14_SHA256:\r\n\t\tcase KEX_DH_GRP16_SHA512:\r\n\t\tcase KEX_DH_GRP18_SHA512:\r\n\t\t\tSSH2_dh_kex_init(pvar);\r\n\t\t\tbreak;\r\n\t\tcase KEX_DH_GEX_SHA1:\r\n\t\tcase KEX_DH_GEX_SHA256:\r\n\t\t\tSSH2_dh_gex_kex_init(pvar);\r\n\t\t\tbreak;\r\n\t\tcase KEX_ECDH_SHA2_256:\r\n\t\tcase KEX_ECDH_SHA2_384:\r\n\t\tcase KEX_ECDH_SHA2_521:\r\n\t\t\tSSH2_ecdh_kex_init(pvar);\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\t// TODO\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\treturn TRUE;\r\n\r\nerror:;\r\n\tbuffer_free(pvar->peer_kex);\r\n\tpvar->peer_kex = NULL;\r\n\r\n\tnotify_fatal_error(pvar, msg, TRUE);\r\n\r\n\treturn FALSE;\r\n}\r\n\r\n\r\n//\r\n// \ufffd\u0152\ufffd DH Groups (RFC 4253, draft-baushke-ssh-dh-group-sha2-04)\r\n//\r\nstatic void SSH2_dh_kex_init(PTInstVar pvar)\r\n{\r\n\tDH *dh = NULL;\r\n\tbuffer_t *msg = NULL;\r\n\tunsigned char *outmsg;\r\n\tint len;\r\n\tBIGNUM *pub_key, *priv_key;\r\n\r\n\t// Diffie-Hellman key agreement\r\n\tswitch (pvar->kex_type) {\r\n\tcase KEX_DH_GRP1_SHA1:\r\n\t\tdh = dh_new_group1();\r\n\t\tbreak;\r\n\tcase KEX_DH_GRP14_SHA1:\r\n\tcase KEX_DH_GRP14_SHA256:\r\n\t\tdh = dh_new_group14();\r\n\t\tbreak;\r\n\tcase KEX_DH_GRP16_SHA512:\r\n\t\tdh = dh_new_group16();\r\n\t\tbreak;\r\n\tcase KEX_DH_GRP18_SHA512:\r\n\t\tdh = dh_new_group18();\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tgoto error;\r\n\t}\r\n\r\n\t// \ufffd\u95a7\ufffd\u0242\ufffd\ufffd\u05c2\ufffd\ufffd\ufffd\ufffd\ufffd(X)\ufffd\ud803\udd90\ufffd\r\n\tdh_gen_key(pvar, dh, pvar->we_need);\r\n\tDH_get0_key(dh, NULL, &priv_key);\r\n\tlog_kex_key(pvar, priv_key);\r\n\r\n\tmsg = buffer_init();\r\n\tif (msg == NULL) {\r\n\t\t// TODO: error check\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\treturn;\r\n\t}\r\n\r\n\tDH_get0_key(dh, &pub_key, NULL);\r\n\tbuffer_put_bignum2(msg, pub_key);\r\n\r\n\tlen = buffer_len(msg);\r\n\toutmsg = begin_send_packet(pvar, SSH2_MSG_KEXDH_INIT, len);\r\n\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\tfinish_send_packet(pvar);\r\n\r\n\tif (pvar->kexdh != NULL) {\r\n\t\tDH_free(pvar->kexdh);\r\n\t}\r\n\tpvar->kexdh = dh;\r\n\r\n\tSSH2_dispatch_init(2);\r\n\tSSH2_dispatch_add_message(SSH2_MSG_KEXDH_REPLY);\r\n\r\n\tbuffer_free(msg);\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_KEXDH_INIT was sent at SSH2_dh_kex_init().\");\r\n\r\n\treturn;\r\n\r\nerror:;\r\n\tDH_free(dh);\r\n\tbuffer_free(msg);\r\n\r\n\tnotify_fatal_error(pvar, \"error occurred @ SSH2_dh_kex_init()\", TRUE);\r\n}\r\n\r\n\r\n\r\n/*\r\n * DH-GEX (RFC 4419)\r\n *\r\n * SSH_MSG_KEY_DH_GEX_REQUEST:\r\n *   byte    SSH_MSG_KEY_DH_GEX_REQUEST (34)\r\n *   uint32  min, minimal size in bits of an acceptable group\r\n *   uint32  n, preferred size in bits of the group the server will send\r\n *   uint32  max, maximal size in bits of an acceptable group\r\n */\r\n\r\nstatic void SSH2_dh_gex_kex_init(PTInstVar pvar)\r\n{\r\n\tbuffer_t *msg = NULL;\r\n\tunsigned char *outmsg;\r\n\tint len;\r\n\tint bits, min, max;\r\n\r\n\tmsg = buffer_init();\r\n\tif (msg == NULL) {\r\n\t\tgoto error;\r\n\t}\r\n\r\n\t// \ufffdT\ufffd[\ufffdo\ufffd\u0257v\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd group size \ufffd\ufffd min, n(preferred), max \ufffd\ufffd\ufffd\ufffd\ufffd\u80b7\ufffd\ufffdB\r\n\tif (pvar->settings.GexMinimalGroupSize == 0) {\r\n\t\t// 0 (\ufffd\ufffd\ufffd\u0752\ufffd) \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u034d\u0150V\ufffd\u0310\ufffd\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffdg\ufffd\ufffd\r\n\t\tmin = GEX_GRP_DEFAULT_MIN;\r\n\t}\r\n\telse if (pvar->settings.GexMinimalGroupSize < GEX_GRP_LIMIT_MIN) {\r\n\t\tmin = GEX_GRP_LIMIT_MIN;\r\n\t\tlogprintf(LOG_LEVEL_NOTICE,\r\n\t\t\t\"%s: small GexMinimalGroupSize is too small (%d), use minimum limit (%d)\", __FUNCTION__,\r\n\t\t\tpvar->settings.GexMinimalGroupSize, GEX_GRP_LIMIT_MIN);\r\n\t}\r\n\telse if (pvar->settings.GexMinimalGroupSize > GEX_GRP_LIMIT_MAX) {\r\n\t\tmin = GEX_GRP_LIMIT_MAX;\r\n\t\tlogprintf(LOG_LEVEL_NOTICE,\r\n\t\t\t\"%s: small GexMinimalGroupSize is too large (%d), use maximum limit (%d)\", __FUNCTION__,\r\n\t\t\tpvar->settings.GexMinimalGroupSize, GEX_GRP_LIMIT_MAX);\r\n\t}\r\n\telse {\r\n\t\tmin = pvar->settings.GexMinimalGroupSize;\r\n\t}\r\n\r\n\t// max \ufffd\u034f\ufffd\u024f\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u03c2\ufffd\r\n\tmax = GEX_GRP_LIMIT_MAX;\r\n\r\n\t// preferred \ufffd\u034eg\ufffdp\ufffd\ufffd\ufffd\ufffde\ufffd\u00cd\ufffd\ufffdv\ufffdf\ufffd\u030c\ufffd\ufffd\ufffd/\ufffdu\ufffd\ufffd\ufffdb\ufffdN\ufffd\ufffd\ufffd\u0302\ufffd\ufffd\ufffd\ufffdA\ufffd\u0151\ufffd\u0302\ufffd\ufffd\u0302\ufffd\ufffdg\ufffd\ufffd\r\n\tbits = dh_estimate(pvar->we_need * 8);\r\n\tif (bits < min) {\r\n\t\tbits = min;\r\n\t}\r\n\telse if (bits > max) {\r\n\t\tbits = max;\r\n\t}\r\n\tif (pvar->server_compat_flag & SSH_BUG_DHGEX_LARGE && bits > 4096) {\r\n\t\tlogprintf(LOG_LEVEL_NOTICE,\r\n\t\t\t\"SSH_BUG_DHGEX_LARGE is enabled. DH-GEX group size is limited to 4096. \"\r\n\t\t\t\"(Original size is %d)\", bits);\r\n\t\tbits = 4096;\r\n\t}\r\n\r\n\t// \ufffdT\ufffd[\ufffdo\ufffd\ufffdgroup size\ufffd\ud805\uddc2\ufffd\ufffd\u0101Ap \ufffd\ufffd g \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u70a4\ufffdB\r\n\tbuffer_put_int(msg, min);\r\n\tbuffer_put_int(msg, bits);\r\n\tbuffer_put_int(msg, max);\r\n\tlen = buffer_len(msg);\r\n\toutmsg = begin_send_packet(pvar, SSH2_MSG_KEX_DH_GEX_REQUEST, len);\r\n\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\tfinish_send_packet(pvar);\r\n\r\n\t// \ufffd\ufffd\ufffd\u0182\u0143n\ufffdb\ufffdV\ufffd\ufffd\ufffdv\ufffdZ\ufffd\u024eg\ufffd\ufffd\ufffd\u0302\u014e\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffdB\r\n\tpvar->kexgex_min = min;\r\n\tpvar->kexgex_bits = bits;\r\n\tpvar->kexgex_max = max;\r\n\r\n\t{\r\n\t\tchar tmp[128];\r\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\r\n\t\t            \"we_need %d min %d bits %d max %d\",\r\n\t\t            pvar->we_need, min, bits, max);\r\n\t\tpush_memdump(\"DH_GEX_REQUEST\", \"requested key bits\", tmp, strlen(tmp));\r\n\t}\r\n\r\n\tSSH2_dispatch_init(2);\r\n\tSSH2_dispatch_add_message(SSH2_MSG_KEX_DH_GEX_GROUP);\r\n\r\n\tbuffer_free(msg);\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_KEX_DH_GEX_REQUEST was sent at SSH2_dh_gex_kex_init().\");\r\n\r\n\treturn;\r\n\r\nerror:;\r\n\tbuffer_free(msg);\r\n\r\n\tnotify_fatal_error(pvar, \"error occurred @ SSH2_dh_gex_kex_init()\", TRUE);\r\n}\r\n\r\n/*\r\n * SSH2_MSG_KEX_DH_GEX_GROUP:\r\n *   byte    SSH_MSG_KEX_DH_GEX_GROUP\r\n *   mpint   p, safe prime\r\n *   mpint   g, generator for subgroup in GF(p)\r\n */\r\nstatic BOOL handle_SSH2_dh_gex_group(PTInstVar pvar)\r\n{\r\n\tint len, grp_bits;\r\n\tBIGNUM *p = NULL, *g = NULL;\r\n\tDH *dh = NULL;\r\n\tbuffer_t *msg = NULL;\r\n\tunsigned char *outmsg;\r\n\tchar tmpbuf[256];\r\n\tBIGNUM *pub_key, *priv_key;\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_KEX_DH_GEX_GROUP was received.\");\r\n\r\n\tp = BN_new();\r\n\tg = BN_new();\r\n\tif (p == NULL || g == NULL)\r\n\t\tgoto error;\r\n\r\n\tif (!get_mpint_from_payload(pvar, p) || !get_mpint_from_payload(pvar, g)) {\r\n\t\t_snprintf_s(tmpbuf, sizeof(tmpbuf), _TRUNCATE,\r\n\t\t\t\t\t\"%s:truncated packet (mpint)\", __FUNCTION__);\r\n\t\tnotify_fatal_error(pvar, tmpbuf, FALSE);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tgrp_bits = BN_num_bits(p);\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"DH-GEX: Request: %d / %d / %d, Received: %d\",\r\n\t            pvar->kexgex_min, pvar->kexgex_bits, pvar->kexgex_max, BN_num_bits(p));\r\n\r\n\t//\r\n\t// (1) < GEX_GRP_LIMIT_MIN <= (2) < kexgex_min <= (3) < kexgex_bits <= (4) <= kexgex_max < (5) <= GEX_GRP_LIMIT_MAX < (6)\r\n\t//\r\n\tif (grp_bits < GEX_GRP_LIMIT_MIN || grp_bits > GEX_GRP_LIMIT_MAX) {\r\n\t// (1), (6) \ufffdv\ufffd\ufffd\ufffdg\ufffdR\ufffd\ufffd\ufffd\u0154F\ufffd\u07c2\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\u0348\ufffd(1024 <= grp_bits <= 8192)\ufffd\u030aO\ufffdB\ufffd\ufffd\ufffd\ufffd\ufffd\u0612f\ufffdB\r\n\t\tUTIL_get_lang_msg(\"MSG_SSH_GEX_SIZE_OUTOFRANGE\", pvar,\r\n\t\t                  \"Received group size is out of range: %d\");\r\n\t\t_snprintf_s(tmpbuf, sizeof(tmpbuf), _TRUNCATE, pvar->UIMsg, grp_bits);\r\n\t\tnotify_fatal_error(pvar, tmpbuf, FALSE);\r\n\t\tgoto error;\r\n\t}\r\n\telse if (grp_bits < pvar->kexgex_min) {\r\n\t// (2) \ufffdv\ufffd\ufffd\ufffdg\ufffdR\ufffd\ufffd\ufffd\u0154F\ufffd\u07c2\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\u0348\u0353\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0310\u0752\u80b5\ufffd\ufffd\ufffd\u014f\ufffd\ufffdl\ufffd\ufffd\u83ec\ufffd\ufffd\ufffd\ufffd\ufffdB\ufffdm\ufffdF\ufffd_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\ufffd\ufffdo\ufffd\ufffd\ufffdB\r\n\t\tlogprintf(LOG_LEVEL_WARNING,\r\n\t\t    \"DH-GEX: grp_bits(%d) < kexgex_min(%d)\", grp_bits, pvar->kexgex_min);\r\n\t\tUTIL_get_lang_msg(\"MSG_SSH_GEX_SIZE_SMALLER\", pvar,\r\n\t\t                  \"Received group size is smaller than the requested minimal size.\\nrequested: %d, received: %d\\nAre you sure that you want to accecpt received group?\");\r\n\t\t_snprintf_s(tmpbuf, sizeof(tmpbuf), _TRUNCATE,\r\n\t\t\tpvar->UIMsg, pvar->kexgex_min, grp_bits);\r\n\t}\r\n\telse if (grp_bits < pvar->kexgex_bits) {\r\n\t// (3) \ufffdv\ufffd\ufffd\ufffd\u030d\u014f\ufffd\ufffdl\ufffd\u0356\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdA\ufffdv\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\u034f\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\ufffdm\ufffdF\ufffd_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\u034fo\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t\tlogprintf(LOG_LEVEL_NOTICE,\r\n\t\t\t\"DH-GEX: grp_bits(%d) < kexgex_bits(%d)\", grp_bits, pvar->kexgex_bits);\r\n\t\ttmpbuf[0] = 0; // no message\r\n\t}\r\n\telse if (grp_bits <= pvar->kexgex_max) {\r\n\t// (4) \ufffdv\ufffd\ufffd\ufffdl\ufffd\u020f\ufffdA\ufffd\ufffd\ufffd\u0097v\ufffd\ufffd\ufffd\u030d\u0151\ufffdl\ufffd\u0209\ufffd\ufffdB\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t\ttmpbuf[0] = 0; // no message\r\n\t}\r\n\telse {\r\n\t// (5) \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0310\u0752\u80b5\ufffd\ufffd\ufffd\u0151\ufffdl\ufffd\ufffd\ufffd\u50ab\ufffd\ufffd\ufffdB\ufffdm\ufffdF\ufffd_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\ufffd\ufffdo\ufffd\ufffd\ufffdB\r\n\t//     \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0142\ufffd kexgex_max == GEX_GRP_LIMIT_MAX(8192) \ufffd\u0142\ufffd\ufffd\ufffd\u05c2\ufffd\ufffd\u030f\udaef\udd42\u0242\u0202\u9396\ufffd\u0356\ufffd\ufffd\ufffd\ufffdB\r\n\t\tlogprintf(LOG_LEVEL_WARNING,\r\n\t\t\t\"DH-GEX: grp_bits(%d) > kexgex_max(%d)\", grp_bits, pvar->kexgex_max);\r\n\t\tUTIL_get_lang_msg(\"MSG_SSH_GEX_SIZE_LARGER\", pvar,\r\n\t\t                  \"Received group size is larger than the requested maximal size.\\nrequested: %d, received: %d\\nAre you sure that you want to accecpt received group?\");\r\n\t\t_snprintf_s(tmpbuf, sizeof(tmpbuf), _TRUNCATE,\r\n\t\t\tpvar->UIMsg, pvar->kexgex_max, grp_bits);\r\n\t}\r\n\r\n\tif (tmpbuf[0] != 0) {\r\n\t\tUTIL_get_lang_msg(\"MSG_SSH_GEX_SIZE_TITLE\", pvar,\r\n\t\t                  \"TTSSH: Confirm GEX group size\");\r\n\t\tif (MessageBox(NULL, tmpbuf, pvar->UIMsg, MB_YESNO | MB_ICONERROR) == IDNO) {\r\n\t\t\tUTIL_get_lang_msg(\"MSG_SSH_GEX_SIZE_CANCEL\", pvar,\r\n\t\t\t                  \"New connection is cancelled.\");\r\n\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, FALSE);\r\n\t\t\tgoto error;\r\n\t\t}\r\n\t}\r\n\r\n\tdh = DH_new();\r\n\tif (dh == NULL)\r\n\t\tgoto error;\r\n\tDH_set0_pqg(dh, p, NULL, g);\r\n\r\n\t// \ufffd\u95a7\ufffd\u0242\ufffd\ufffd\u05c2\ufffd\ufffd\ufffd\ufffd\ufffd(X)\ufffd\ud803\udd90\ufffd\r\n\tdh_gen_key(pvar, dh, pvar->we_need);\r\n\tDH_get0_key(dh, NULL, &priv_key);\r\n\tlog_kex_key(pvar, priv_key);\r\n\r\n\t// \ufffd\ufffd\ufffdJ\ufffd\ufffd\ufffd\ufffd\ufffdT\ufffd[\ufffdo\ufffd\u0591\ufffd\ufffdM\r\n\tmsg = buffer_init();\r\n\tif (msg == NULL) {\r\n\t\tgoto error;\r\n\t}\r\n\tDH_get0_key(dh, &pub_key, NULL);\r\n\tbuffer_put_bignum2(msg, pub_key);\r\n\tlen = buffer_len(msg);\r\n\toutmsg = begin_send_packet(pvar, SSH2_MSG_KEX_DH_GEX_INIT, len);\r\n\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\tfinish_send_packet(pvar);\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_KEX_DH_GEX_INIT was sent at handle_SSH2_dh_gex_group().\");\r\n\r\n\t// \ufffd\ufffd\ufffd\ufffd\ufffd\u014d\uc42c\ufffd\ufffd\ufffd\ufffdDH\ufffd\ufffd\ufffd\u0341A\ufffd\ufffd\ufffd\u0182\u0143n\ufffdb\ufffdV\ufffd\ufffd\ufffdv\ufffdZ\ufffd\u024eg\ufffd\ufffd\ufffd\ufffd\ufffd\u07ce\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffdB(2004.10.31 yutaka)\r\n\tif (pvar->kexdh != NULL) {\r\n\t\tDH_free(pvar->kexdh);\r\n\t}\r\n\tpvar->kexdh = dh;\r\n\r\n\t{\r\n\t\tBIGNUM *p, *q, *pub_key;\r\n\r\n\t\tDH_get0_pqg(dh, &p, &q, NULL);\r\n\t\tDH_get0_key(dh, &pub_key, NULL);\r\n\r\n\t\tpush_bignum_memdump(\"DH_GEX_GROUP\", \"p\", p);\r\n\t\tpush_bignum_memdump(\"DH_GEX_GROUP\", \"g\", g);\r\n\t\tpush_bignum_memdump(\"DH_GEX_GROUP\", \"pub_key\", pub_key);\r\n\t}\r\n\r\n\tSSH2_dispatch_init(2);\r\n\tSSH2_dispatch_add_message(SSH2_MSG_KEX_DH_GEX_REPLY);\r\n\r\n\tbuffer_free(msg);\r\n\r\n\treturn TRUE;\r\n\r\nerror:;\r\n\tBN_free(p);\r\n\tBN_free(g);\r\n\tDH_free(dh);\r\n\r\n\treturn FALSE;\r\n}\r\n\r\n\r\n//\r\n// KEX_ECDH_SHA2_256 or KEX_ECDH_SHA2_384 or KEX_ECDH_SHA2_521\r\n//\r\n\r\nstatic void SSH2_ecdh_kex_init(PTInstVar pvar)\r\n{\r\n\tEC_KEY *client_key = NULL;\r\n\tconst EC_GROUP *group;\r\n\tbuffer_t *msg = NULL;\r\n\tunsigned char *outmsg;\r\n\tint len, ret;\r\n\tchar buf[128];\r\n\r\n\tclient_key = EC_KEY_new();\r\n\tif (client_key == NULL) {\r\n\t\t_snprintf_s(buf, sizeof(buf), _TRUNCATE, \"%s: EC_KEY_new was failed\", __FUNCTION__);\r\n\t\tgoto error;\r\n\t}\r\n\tclient_key = EC_KEY_new_by_curve_name(kextype_to_cipher_nid(pvar->kex_type));\r\n\tif (client_key == NULL) {\r\n\t\t_snprintf_s(buf, sizeof(buf), _TRUNCATE, \"%s: EC_KEY_new_by_curve_name was failed\", __FUNCTION__);\r\n\t\tgoto error;\r\n\t}\r\n\tret = EC_KEY_generate_key(client_key);\r\n\tif (ret != 1) {\r\n\t\t_snprintf_s(buf, sizeof(buf), _TRUNCATE, \"%s: EC_KEY_generate_key was failed(ret %d)\", __FUNCTION__, ret);\r\n\t\tgoto error;\r\n\t}\r\n\tgroup = EC_KEY_get0_group(client_key);\r\n\tlog_kex_key(pvar, EC_KEY_get0_private_key(client_key));\r\n\r\n\tmsg = buffer_init();\r\n\tif (msg == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t_snprintf_s(buf, sizeof(buf), _TRUNCATE, \"%s: buffer_init was failed\", __FUNCTION__);\r\n\t\tgoto error;\r\n\t}\r\n\r\n\tbuffer_put_ecpoint(msg, group, EC_KEY_get0_public_key(client_key));\r\n\r\n\tlen = buffer_len(msg);\r\n\toutmsg = begin_send_packet(pvar, SSH2_MSG_KEX_ECDH_INIT, len);\r\n\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\tfinish_send_packet(pvar);\r\n\r\n\t// \ufffd\ufffd\ufffd\ufffd\ufffd\u014d\uc42c\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0341A\ufffd\ufffd\ufffd\u0182\u0143n\ufffdb\ufffdV\ufffd\ufffd\ufffdv\ufffdZ\ufffd\u024eg\ufffd\ufffd\ufffd\ufffd\ufffd\u07ce\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffdB\r\n\tif (pvar->ecdh_client_key) {\r\n\t\tEC_KEY_free(pvar->ecdh_client_key);\r\n\t}\r\n\tpvar->ecdh_client_key = client_key;\r\n\r\n\tSSH2_dispatch_init(2);\r\n\tSSH2_dispatch_add_message(SSH2_MSG_KEX_ECDH_REPLY);\r\n\r\n\tbuffer_free(msg);\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_KEX_ECDH_INIT was sent at SSH2_ecdh_kex_init().\");\r\n\r\n\treturn;\r\n\r\nerror:;\r\n\tEC_KEY_free(client_key);\r\n\tbuffer_free(msg);\r\n\r\n\tnotify_fatal_error(pvar, buf, TRUE);\r\n}\r\n\r\n\r\nstatic void ssh2_set_newkeys(PTInstVar pvar, int mode)\r\n{\r\n\t// free already allocated buffer\r\n\tif (pvar->ssh2_keys[mode].enc.iv != NULL) {\r\n\t\tfree(pvar->ssh2_keys[mode].enc.iv);\r\n\t}\r\n\tif (pvar->ssh2_keys[mode].enc.key != NULL) {\r\n\t\tfree(pvar->ssh2_keys[mode].enc.key);\r\n\t}\r\n\tif (pvar->ssh2_keys[mode].mac.key != NULL) {\r\n\t\tfree(pvar->ssh2_keys[mode].mac.key);\r\n\t}\r\n\r\n\tpvar->ssh2_keys[mode] = current_keys[mode];\r\n}\r\n\r\nstatic BOOL ssh2_kex_finish(PTInstVar pvar, char *hash, int hashlen, BIGNUM *share_key, Key *hostkey, char *signature, int siglen)\r\n{\r\n\tint ret;\r\n\tchar emsg[1024];  // error message\r\n\r\n\t//debug_print(30, hash, hashlen);\r\n\t//debug_print(31, pvar->client_version_string, strlen(pvar->client_version_string));\r\n\t//debug_print(32, pvar->server_version_string, strlen(pvar->server_version_string));\r\n\t//debug_print(33, buffer_ptr(pvar->my_kex), buffer_len(pvar->my_kex));\r\n\t//debug_print(34, buffer_ptr(pvar->peer_kex), buffer_len(pvar->peer_kex));\r\n\t//debug_print(35, server_host_key_blob, bloblen);\r\n\r\n\t// session id\ufffd\u0315\u06d1\ufffd\ufffdi\ufffd\ufffd\ufffd\ufffd\u0691\ufffd\ufffd\ufffd\ufffd\u0302\u0741j\r\n\tif (pvar->session_id == NULL) {\r\n\t\tpvar->session_id_len = hashlen;\r\n\t\tpvar->session_id = malloc(pvar->session_id_len);\r\n\t\tif (pvar->session_id != NULL) {\r\n\t\t\tmemcpy(pvar->session_id, hash, pvar->session_id_len);\r\n\t\t} else {\r\n\t\t\t// TODO:\r\n\t\t}\r\n\t}\r\n\r\n\tif ((ret = key_verify(hostkey, signature, siglen, hash, hashlen, pvar->hostkey_type)) != 1) {\r\n\t\tif (ret == -3 && hostkey->type == KEY_RSA) {\r\n\t\t\tif (!pvar->settings.EnableRsaShortKeyServer) {\r\n\t\t\t\tBIGNUM *n;\r\n\t\t\t\tRSA_get0_key(hostkey->rsa, &n, NULL, NULL);\r\n\t\t\t\t_snprintf_s(emsg, sizeof(emsg), _TRUNCATE,\r\n\t\t\t\t\t\"%s: key verify error. remote rsa key length is too short (%d-bit)\", __FUNCTION__,\r\n\t\t\t\t\tBN_num_bits(n));\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tgoto cont;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tchar *buf = NULL;\r\n\t\t\tbuf = ToCharW(SENDTOME);\r\n\t\t\t_snprintf_s(emsg, sizeof(emsg), _TRUNCATE, \"%s: key verify error (%d)\\r\\n%s\", __FUNCTION__, ret, buf);\r\n\t\t\tfree(buf);\r\n\t\t}\r\n\r\n\t\tsave_memdump(LOGDUMP);\r\n\t\tnotify_fatal_error(pvar, emsg, TRUE);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\ncont:\r\n\tkex_derive_keys(pvar, current_keys, pvar->we_need, hash, share_key, pvar->session_id, pvar->session_id_len);\r\n\r\n\tprep_compression(pvar);\r\n\r\n\tSSH2_dispatch_init(3);\r\n\tSSH2_dispatch_add_message(SSH2_MSG_NEWKEYS);\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nstatic void ssh2_send_newkeys(PTInstVar pvar)\r\n{\r\n\t// send SSH2_MSG_NEWKEYS\r\n\tbegin_send_packet(pvar, SSH2_MSG_NEWKEYS, 0);\r\n\tfinish_send_packet(pvar);\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: SSH2_MSG_NEWKEYS was sent.\", __FUNCTION__);\r\n\r\n\t// SSH2_MSG_NEWKEYS \ufffd\ud805\uddc2\ufffdI\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u020d~\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffd\u0348\u00cd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdK\ufffdv\ufffd\ufffd\ufffdL\ufffd\ufffd\u05c1A\r\n\t// \ufffd\ufffd\ufffd\u030e\ufffd\ufffd_\ufffd\u0151\ufffd\ufffdM\ufffd\ufffd\ufffd\ufffd\ufffd\u0308\u00cd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdJ\ufffdn\ufffd\ufffd\ufffd\ufffdB\r\n\tssh2_set_newkeys(pvar, MODE_OUT);\r\n\tif (!CRYPT_start_encryption(pvar, 1, 0)) {\r\n\t\t// TODO: error\r\n\t}\r\n\r\n\r\n\t// \ufffd\ufffd\ufffdl\ufffd\u0241AMAC\ufffd\u0183p\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffdk\ufffd\ufffd\ufffd\ufffd\ufffd\u030e\ufffd\ufffd_\ufffd\u0157L\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\ufffdB\r\n\tpvar->ssh2_keys[MODE_OUT].mac.enabled = 1;\r\n\tpvar->ssh2_keys[MODE_OUT].comp.enabled = 1;\r\n\tenable_send_compression(pvar);\r\n\r\n\tpvar->kex_status |= KEX_FLAG_NEWKEYS_SENT;\r\n\r\n\tif (pvar->server_strict_kex) {\r\n\t\tpvar->ssh_state.sender_sequence_number = 0;\r\n\t}\r\n\r\n\t// SSH2_MSG_NEWKEYS \ufffd\ufffd\ufffd\ufffd\ufffd\u024e\udaca\udfce\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffd\ufffdKEX\ufffd\u034a\ufffd\ufffd\ufffd\ufffdB\ufffd\ufffd\ufffd\u030f\ufffd\ufffd\ufffd\ufffd\u0248\u0682\ufffdB\r\n\tif (pvar->kex_status & KEX_FLAG_NEWKEYS_RECEIVED) {\r\n\t\tif ((pvar->kex_status & KEX_FLAG_REKEYING)) {\r\n\t\t\tdo_SSH2_dispatch_setup_for_transfer(pvar);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd SSH2_MSG_NEWKEYS \ufffd\u0311\ufffd\ufffd\ufffdM\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdA\ufffd\u020d~\ufffd\u0312\u0290M\ufffd\u0348\u00cd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ua0bd\ufffd\ufffd\u0502\u0242\u0202\ufffd\r\n\t\t\tssh2_finish_encryption_setup(pvar);\r\n\r\n\t\t\t// \ufffd\ufffd\ufffd\ufffd\u030c\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0343\ufffd\ufffd[\ufffdU\ufffdF\ufffd\u0602\ufffd\ufffdJ\ufffdn\ufffd\ufffd\ufffd\ufffd\r\n\t\t\tssh2_prep_userauth(pvar);\r\n\t\t}\r\n\t\tpvar->kex_status = KEX_FLAG_KEXDONE;\r\n\t}\r\n\r\n\treturn;\r\n}\r\n\r\n/*\r\n * Diffie-Hellman Key Exchange Reply (SSH2_MSG_KEXDH_REPLY:31)\r\n *\r\n * return TRUE: \ufffd\ufffd\ufffd\ufffd\r\n *        FALSE: \ufffd\ufffd\ufffds\r\n */\r\nstatic BOOL handle_SSH2_dh_kex_reply(PTInstVar pvar)\r\n{\r\n\tchar *data;\r\n\tint len;\r\n\tchar *server_host_key_blob;\r\n\tint bloblen, siglen;\r\n\tBIGNUM *server_public = NULL;\r\n\tchar *signature;\r\n\tint dh_len, share_len;\r\n\tchar *dh_buf = NULL;\r\n\tBIGNUM *share_key = NULL;\r\n\tchar *hash;\r\n\tchar *emsg = NULL, emsg_tmp[1024];  // error message\r\n\tint hashlen;\r\n\tKey *hostkey = NULL;  // hostkey\r\n\tBOOL result = FALSE;\r\n\tBIGNUM *pub_key;\r\n\tint ret;\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_KEXDH_REPLY was received.\");\r\n\r\n\tmemset(&hostkey, 0, sizeof(hostkey));\r\n\r\n\t// \ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd^\ufffdC\ufffdv\ufffd\u030c\ufffd\u0251\ufffd\ufffd\ufffd\ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\u0310\u64ea\r\n\tdata = pvar->ssh_state.payload;\r\n\t// \ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\u0312\ufffd\ufffd\ufffd; \ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd^\ufffdC\ufffdv\ufffd\ufffd\ufffd\ufffd 1 \ufffdo\ufffdC\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\u70b7\r\n\tlen = pvar->ssh_state.payloadlen - 1;\r\n\r\n\t// for debug\r\n\tpush_memdump(\"KEXDH_REPLY\", \"key exchange: receiving\", data, len);\r\n\r\n\tbloblen = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\tserver_host_key_blob = data; // for hash\r\n\r\n\tpush_memdump(\"KEXDH_REPLY\", \"server_host_key_blob\", server_host_key_blob, bloblen);\r\n\r\n\thostkey = key_from_blob(data, bloblen);\r\n\tif (hostkey == NULL) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: key_from_blob error\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\tdata += bloblen;\r\n\r\n\t// known_hosts\ufffd\u0389\ufffd (2006.3.20 yutaka)\r\n\tif (hostkey->type != get_ssh2_hostkey_type_from_algorithm(pvar->hostkey_type)) {  // \ufffdz\ufffdX\ufffdg\ufffdL\ufffd[\ufffd\u030e\ufffd\u0294\ufffdr\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t            \"%s: type mismatch for decoded server_host_key_blob (kex:%s(%s) blob:%s)\",\r\n\t\t            /*__FUNCTION__*/\"handle_SSH2_dh_kex_reply\",\r\n\t\t            get_ssh2_hostkey_type_name_from_algorithm(pvar->hostkey_type),\r\n\t\t            get_ssh2_hostkey_algorithm_name(pvar->hostkey_type),\r\n\t\t            get_ssh2_hostkey_type_name(hostkey->type));\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\r\n\tserver_public = BN_new();\r\n\tif (server_public == NULL) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: Out of memory (1)\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\r\n\tbuffer_get_bignum2(&data, server_public);\r\n\r\n\tsiglen = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\tsignature = data;\r\n\tdata += siglen;\r\n\r\n\tpush_memdump(\"KEXDH_REPLY\", \"signature\", signature, siglen);\r\n\r\n\t// check public key\r\n\tif (!dh_pub_is_valid(pvar->kexdh, server_public)) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: invalid server public key\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\t// \ufffd\ufffd\ufffd\u028c\ufffd\ufffd\u0310\ufffd\ufffd\ufffd\r\n\tdh_len = DH_size(pvar->kexdh);\r\n\tdh_buf = malloc(dh_len);\r\n\tif (dh_buf == NULL) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: Out of memory (2)\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\tshare_len = DH_compute_key(dh_buf, server_public, pvar->kexdh);\r\n\tshare_key = BN_new();\r\n\tif (share_key == NULL) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: Out of memory (3)\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\t// 'share_key'\ufffd\ufffd\ufffdT\ufffd[\ufffdo\ufffd\u0183N\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg\ufffd\u014b\ufffd\ufffdL\ufffd\ufffd\ufffd\u932e\ufffdiG^A\ufffd~B mod P\ufffdj\ufffd\u0182\u0202\ufffdB\r\n\tBN_bin2bn(dh_buf, share_len, share_key);\r\n\t//debug_print(40, dh_buf, share_len);\r\n\r\n\t// \ufffdn\ufffdb\ufffdV\ufffd\ufffd\ufffd\u030cv\ufffdZ\r\n\t/* calc and verify H */\r\n\tDH_get0_key(pvar->kexdh, &pub_key, NULL);\r\n\thash = kex_dh_hash(\r\n\t\tget_kex_algorithm_EVP_MD(pvar->kex_type),\r\n\t\tpvar->client_version_string,\r\n\t\tpvar->server_version_string,\r\n\t\tbuffer_ptr(pvar->my_kex), buffer_len(pvar->my_kex),\r\n\t\tbuffer_ptr(pvar->peer_kex), buffer_len(pvar->peer_kex),\r\n\t\tserver_host_key_blob, bloblen,\r\n\t\tpub_key,\r\n\t\tserver_public,\r\n\t\tshare_key,\r\n\t\t&hashlen);\r\n\r\n\t{\r\n\t\tpush_memdump(\"KEXDH_REPLY kex_dh_kex_hash\", \"my_kex\", buffer_ptr(pvar->my_kex), buffer_len(pvar->my_kex));\r\n\t\tpush_memdump(\"KEXDH_REPLY kex_dh_kex_hash\", \"peer_kex\", buffer_ptr(pvar->peer_kex), buffer_len(pvar->peer_kex));\r\n\r\n\t\tpush_bignum_memdump(\"KEXDH_REPLY kex_dh_kex_hash\", \"server_public\", server_public);\r\n\t\tpush_bignum_memdump(\"KEXDH_REPLY kex_dh_kex_hash\", \"share_key\", share_key);\r\n\r\n\t\tpush_memdump(\"KEXDH_REPLY kex_dh_kex_hash\", \"hash\", hash, hashlen);\r\n\t}\r\n\r\n\t// TTSSH\ufffdo\ufffd[\ufffdW\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0255\\\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdL\ufffd[\ufffdr\ufffdb\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u07c2\u0102\ufffd\ufffd\ufffd\r\n\tDH_get0_key(pvar->kexdh, &pub_key, NULL);\r\n\tpvar->client_key_bits = BN_num_bits(pub_key);\r\n\tpvar->server_key_bits = BN_num_bits(server_public);\r\n\r\n\tresult = ssh2_kex_finish(pvar, hash, hashlen, share_key, hostkey, signature, siglen);\r\n\r\n\tret = HOSTS_check_host_key(pvar, pvar->ssh_state.hostname, pvar->ssh_state.tcpport, hostkey);\r\n\tif (ret == TRUE) {\r\n\t\t// \ufffdz\ufffdX\ufffdg\ufffd\ufffd\ufffd\u030am\ufffdF\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\u3471\ufffd\u030f\ufffd\ufffd\ufffd\ufffd\ufffd\ufffds\ufffd\ufffd\r\n\t\tSSH_notify_host_OK(pvar);\r\n\t\t// known_hosts\ufffd_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\u030c\u0102\u044fo\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\u020d~\ufffdA\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t}\r\n\r\nerror:\r\n\tBN_free(server_public);\r\n\tDH_free(pvar->kexdh); pvar->kexdh = NULL;\r\n\tkey_free(hostkey);\r\n\tfree(dh_buf);\r\n\tBN_free(share_key);\r\n\r\n\tif (emsg)\r\n\t\tnotify_fatal_error(pvar, emsg, TRUE);\r\n\r\n\treturn result;\r\n}\r\n\r\n/*\r\n * Diffie-Hellman Group and Key Exchange Reply (SSH2_MSG_KEX_DH_GEX_REPLY:33)\r\n *\r\n * return TRUE: \ufffd\ufffd\ufffd\ufffd\r\n *        FALSE: \ufffd\ufffd\ufffds\r\n */\r\nstatic BOOL handle_SSH2_dh_gex_reply(PTInstVar pvar)\r\n{\r\n\tchar *data;\r\n\tint len;\r\n\tchar *server_host_key_blob;\r\n\tint bloblen, siglen;\r\n\tBIGNUM *server_public = NULL;\r\n\tchar *signature;\r\n\tint dh_len, share_len;\r\n\tchar *dh_buf = NULL;\r\n\tBIGNUM *share_key = NULL;\r\n\tchar *hash;\r\n\tchar *emsg = NULL, emsg_tmp[1024];  // error message\r\n\tint hashlen;\r\n\tKey *hostkey = NULL;  // hostkey\r\n\tBOOL result = FALSE;\r\n\tint ret;\r\n\tBIGNUM *p, *g;\r\n\tBIGNUM *pub_key;\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_KEX_DH_GEX_REPLY was received.\");\r\n\r\n\tmemset(&hostkey, 0, sizeof(hostkey));\r\n\r\n\t// \ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd^\ufffdC\ufffdv\ufffd\u030c\ufffd\u0251\ufffd\ufffd\ufffd\ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\u0310\u64ea\r\n\tdata = pvar->ssh_state.payload;\r\n\t// \ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\u0312\ufffd\ufffd\ufffd; \ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd^\ufffdC\ufffdv\ufffd\ufffd\ufffd\ufffd 1 \ufffdo\ufffdC\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\u70b7\r\n\tlen = pvar->ssh_state.payloadlen - 1;\r\n\r\n\t// for debug\r\n\tpush_memdump(\"DH_GEX_REPLY\", \"key exchange: receiving\", data, len);\r\n\r\n\tbloblen = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\tserver_host_key_blob = data; // for hash\r\n\r\n\tpush_memdump(\"DH_GEX_REPLY\", \"server_host_key_blob\", server_host_key_blob, bloblen);\r\n\r\n\thostkey = key_from_blob(data, bloblen);\r\n\tif (hostkey == NULL) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: key_from_blob error\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\tdata += bloblen;\r\n\r\n\t// known_hosts\ufffd\u0389\ufffd (2006.3.20 yutaka)\r\n\tif (hostkey->type != get_ssh2_hostkey_type_from_algorithm(pvar->hostkey_type)) {  // \ufffdz\ufffdX\ufffdg\ufffdL\ufffd[\ufffd\u030e\ufffd\u0294\ufffdr\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t            \"%s: type mismatch for decoded server_host_key_blob (kex:%s(%s) blob:%s)\",\r\n\t\t            /*__FUNCTION__*/\"handle_SSH2_dh_gex_reply\",\r\n\t\t            get_ssh2_hostkey_type_name_from_algorithm(pvar->hostkey_type),\r\n\t\t            get_ssh2_hostkey_algorithm_name(pvar->hostkey_type),\r\n\t\t            get_ssh2_hostkey_type_name(hostkey->type));\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\r\n\tserver_public = BN_new();\r\n\tif (server_public == NULL) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: Out of memory (1)\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\r\n\tbuffer_get_bignum2(&data, server_public);\r\n\r\n\tsiglen = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\tsignature = data;\r\n\tdata += siglen;\r\n\r\n\tpush_memdump(\"DH_GEX_REPLY\", \"signature\", signature, siglen);\r\n\r\n\t// check public key\r\n\tif (!dh_pub_is_valid(pvar->kexdh, server_public)) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: invalid server public key\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\t// \ufffd\ufffd\ufffd\u028c\ufffd\ufffd\u0310\ufffd\ufffd\ufffd\r\n\tdh_len = DH_size(pvar->kexdh);\r\n\tdh_buf = malloc(dh_len);\r\n\tif (dh_buf == NULL) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: Out of memory (2)\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\tshare_len = DH_compute_key(dh_buf, server_public, pvar->kexdh);\r\n\tshare_key = BN_new();\r\n\tif (share_key == NULL) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: Out of memory (3)\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\t// 'share_key'\ufffd\ufffd\ufffdT\ufffd[\ufffdo\ufffd\u0183N\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg\ufffd\u014b\ufffd\ufffdL\ufffd\ufffd\ufffd\u932e\ufffdiG^A\ufffd~B mod P\ufffdj\ufffd\u0182\u0202\ufffdB\r\n\tBN_bin2bn(dh_buf, share_len, share_key);\r\n\t//debug_print(40, dh_buf, share_len);\r\n\r\n\t// \ufffdn\ufffdb\ufffdV\ufffd\ufffd\ufffd\u030cv\ufffdZ\r\n\t/* calc and verify H */\r\n\tDH_get0_pqg(pvar->kexdh, &p, NULL, &g);\r\n\tDH_get0_key(pvar->kexdh, &pub_key, NULL);\r\n\thash = kex_dh_gex_hash(\r\n\t\tget_kex_algorithm_EVP_MD(pvar->kex_type),\r\n\t\tpvar->client_version_string,\r\n\t\tpvar->server_version_string,\r\n\t\tbuffer_ptr(pvar->my_kex), buffer_len(pvar->my_kex),\r\n\t\tbuffer_ptr(pvar->peer_kex), buffer_len(pvar->peer_kex),\r\n\t\tserver_host_key_blob, bloblen,\r\n\t\tpvar->kexgex_min,\r\n\t\tpvar->kexgex_bits,\r\n\t\tpvar->kexgex_max,\r\n\t\tp,\r\n\t\tg,\r\n\t\tpub_key,\r\n\t\tserver_public,\r\n\t\tshare_key,\r\n\t\t&hashlen);\r\n\r\n\t{\r\n\t\tpush_memdump(\"DH_GEX_REPLY kex_dh_gex_hash\", \"my_kex\", buffer_ptr(pvar->my_kex), buffer_len(pvar->my_kex));\r\n\t\tpush_memdump(\"DH_GEX_REPLY kex_dh_gex_hash\", \"peer_kex\", buffer_ptr(pvar->peer_kex), buffer_len(pvar->peer_kex));\r\n\r\n\t\tpush_bignum_memdump(\"DH_GEX_REPLY kex_dh_gex_hash\", \"server_public\", server_public);\r\n\t\tpush_bignum_memdump(\"DH_GEX_REPLY kex_dh_gex_hash\", \"share_key\", share_key);\r\n\r\n\t\tpush_memdump(\"DH_GEX_REPLY kex_dh_gex_hash\", \"hash\", hash, hashlen);\r\n\t}\r\n\r\n\t// TTSSH\ufffdo\ufffd[\ufffdW\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0255\\\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdL\ufffd[\ufffdr\ufffdb\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u07c2\u0102\ufffd\ufffd\ufffd\r\n\tDH_get0_key(pvar->kexdh, &pub_key, NULL);\r\n\tpvar->client_key_bits = BN_num_bits(pub_key);\r\n\tpvar->server_key_bits = BN_num_bits(server_public);\r\n\r\n\tresult = ssh2_kex_finish(pvar, hash, hashlen, share_key, hostkey, signature, siglen);\r\n\r\n\tret = HOSTS_check_host_key(pvar, pvar->ssh_state.hostname, pvar->ssh_state.tcpport, hostkey);\r\n\tif (ret == TRUE) {\r\n\t\t// \ufffdz\ufffdX\ufffdg\ufffd\ufffd\ufffd\u030am\ufffdF\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\u3471\ufffd\u030f\ufffd\ufffd\ufffd\ufffd\ufffd\ufffds\ufffd\ufffd\r\n\t\tSSH_notify_host_OK(pvar);\r\n\t\t// known_hosts\ufffd_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\u030c\u0102\u044fo\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\u020d~\ufffdA\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t}\r\n\r\nerror:\r\n\tBN_free(server_public);\r\n\tDH_free(pvar->kexdh); pvar->kexdh = NULL;\r\n\tkey_free(hostkey);\r\n\tfree(dh_buf);\r\n\tBN_free(share_key);\r\n\r\n\tif (emsg)\r\n\t\tnotify_fatal_error(pvar, emsg, TRUE);\r\n\r\n\treturn result;\r\n}\r\n\r\n\r\n/*\r\n * Elliptic Curve Diffie-Hellman Key Exchange Reply (SSH2_MSG_KEX_ECDH_REPLY:31)\r\n *\r\n * return TRUE: \ufffd\ufffd\ufffd\ufffd\r\n *        FALSE: \ufffd\ufffd\ufffds\r\n */\r\nstatic BOOL handle_SSH2_ecdh_kex_reply(PTInstVar pvar)\r\n{\r\n\tchar *data;\r\n\tint len;\r\n\tchar *server_host_key_blob;\r\n\tint bloblen, siglen;\r\n\tEC_POINT *server_public = NULL;\r\n\tconst EC_GROUP *group;\r\n\tchar *signature;\r\n\tint ecdh_len;\r\n\tchar *ecdh_buf = NULL;\r\n\tBIGNUM *share_key = NULL;\r\n\tchar *hash;\r\n\tchar *emsg = NULL, emsg_tmp[1024];  // error message\r\n\tint hashlen;\r\n\tKey *hostkey = NULL;  // hostkey\r\n\tBOOL result = FALSE;\r\n\tint ret;\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_KEX_ECDH_REPLY was received.\");\r\n\r\n\tmemset(&hostkey, 0, sizeof(hostkey));\r\n\r\n\t// \ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd^\ufffdC\ufffdv\ufffd\u030c\ufffd\u0251\ufffd\ufffd\ufffd\ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\u0310\u64ea\r\n\tdata = pvar->ssh_state.payload;\r\n\t// \ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\u0312\ufffd\ufffd\ufffd; \ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd^\ufffdC\ufffdv\ufffd\ufffd\ufffd\ufffd 1 \ufffdo\ufffdC\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\u70b7\r\n\tlen = pvar->ssh_state.payloadlen - 1;\r\n\r\n\t// for debug\r\n\tpush_memdump(\"KEX_ECDH_REPLY\", \"key exchange: receiving\", data, len);\r\n\r\n\tbloblen = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\tserver_host_key_blob = data; // for hash\r\n\r\n\tpush_memdump(\"KEX_ECDH_REPLY\", \"server_host_key_blob\", server_host_key_blob, bloblen);\r\n\r\n\thostkey = key_from_blob(data, bloblen);\r\n\tif (hostkey == NULL) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: key_from_blob error\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\tdata += bloblen;\r\n\r\n\t// known_hosts\ufffd\u0389\ufffd (2006.3.20 yutaka)\r\n\tif (hostkey->type != get_ssh2_hostkey_type_from_algorithm(pvar->hostkey_type)) {  // \ufffdz\ufffdX\ufffdg\ufffdL\ufffd[\ufffd\u030e\ufffd\u0294\ufffdr\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t            \"%s: type mismatch for decoded server_host_key_blob (kex:%s(%s) blob:%s)\",\r\n\t\t            /*__FUNCTION__*/\"handle_SSH2_ecdh_kex_reply\",\r\n\t\t            get_ssh2_hostkey_type_name_from_algorithm(pvar->hostkey_type),\r\n\t\t            get_ssh2_hostkey_algorithm_name(pvar->hostkey_type),\r\n\t\t            get_ssh2_hostkey_type_name(hostkey->type));\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\r\n\t/* Q_S, server public key */\r\n\tgroup = EC_KEY_get0_group(pvar->ecdh_client_key);\r\n\tserver_public = EC_POINT_new(group);\r\n\tif (server_public == NULL) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: Out of memory (1)\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\r\n\tbuffer_get_ecpoint(&data, group, server_public);\r\n\r\n\tsiglen = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\tsignature = data;\r\n\tdata += siglen;\r\n\r\n\tpush_memdump(\"KEX_ECDH_REPLY\", \"signature\", signature, siglen);\r\n\r\n\t// check public key\r\n\tif (key_ec_validate_public(group, server_public) != 0) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: invalid server public key\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\t// \ufffd\ufffd\ufffd\u028c\ufffd\ufffd\u0310\ufffd\ufffd\ufffd\r\n\tecdh_len = (EC_GROUP_get_degree(group) + 7) / 8;\r\n\tecdh_buf = malloc(ecdh_len);\r\n\tif (ecdh_buf == NULL) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: Out of memory (2)\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\tif (ECDH_compute_key(ecdh_buf, ecdh_len, server_public,\r\n\t                     pvar->ecdh_client_key, NULL) != (int)ecdh_len) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: Out of memory (3)\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\tshare_key = BN_new();\r\n\tif (share_key == NULL) {\r\n\t\t_snprintf_s(emsg_tmp, sizeof(emsg_tmp), _TRUNCATE,\r\n\t\t\t\t\t\"%s: Out of memory (4)\", __FUNCTION__);\r\n\t\temsg = emsg_tmp;\r\n\t\tgoto error;\r\n\t}\r\n\t// 'share_key'\ufffd\ufffd\ufffdT\ufffd[\ufffdo\ufffd\u0183N\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg\ufffd\u014b\ufffd\ufffdL\ufffd\ufffd\ufffd\u932e\ufffdiG^A\ufffd~B mod P\ufffdj\ufffd\u0182\u0202\ufffdB\r\n\tBN_bin2bn(ecdh_buf, ecdh_len, share_key);\r\n\t//debug_print(40, ecdh_buf, ecdh_len);\r\n\r\n\t// \ufffdn\ufffdb\ufffdV\ufffd\ufffd\ufffd\u030cv\ufffdZ\r\n\t/* calc and verify H */\r\n\thash = kex_ecdh_hash(\r\n\t\tget_kex_algorithm_EVP_MD(pvar->kex_type),\r\n\t\tgroup,\r\n\t\tpvar->client_version_string,\r\n\t\tpvar->server_version_string,\r\n\t\tbuffer_ptr(pvar->my_kex), buffer_len(pvar->my_kex),\r\n\t\tbuffer_ptr(pvar->peer_kex), buffer_len(pvar->peer_kex),\r\n\t\tserver_host_key_blob, bloblen,\r\n\t\tEC_KEY_get0_public_key(pvar->ecdh_client_key),\r\n\t\tserver_public,\r\n\t\tshare_key,\r\n\t\t&hashlen);\r\n\r\n\t{\r\n\t\tpush_memdump(\"KEX_ECDH_REPLY ecdh_kex_reply\", \"my_kex\", buffer_ptr(pvar->my_kex), buffer_len(pvar->my_kex));\r\n\t\tpush_memdump(\"KEX_ECDH_REPLY ecdh_kex_reply\", \"peer_kex\", buffer_ptr(pvar->peer_kex), buffer_len(pvar->peer_kex));\r\n\r\n\t\tpush_bignum_memdump(\"KEX_ECDH_REPLY ecdh_kex_reply\", \"share_key\", share_key);\r\n\r\n\t\tpush_memdump(\"KEX_ECDH_REPLY ecdh_kex_reply\", \"hash\", hash, hashlen);\r\n\t}\r\n\r\n\t// TTSSH\ufffdo\ufffd[\ufffdW\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0255\\\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdL\ufffd[\ufffdr\ufffdb\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u07c2\u0102\ufffd\ufffd\ufffd\r\n\tswitch (pvar->kex_type) {\r\n\t\tcase KEX_ECDH_SHA2_256:\r\n\t\t\tpvar->client_key_bits = 256;\r\n\t\t\tpvar->server_key_bits = 256;\r\n\t\t\tbreak;\r\n\t\tcase KEX_ECDH_SHA2_384:\r\n\t\t\tpvar->client_key_bits = 384;\r\n\t\t\tpvar->server_key_bits = 384;\r\n\t\t\tbreak;\r\n\t\tcase KEX_ECDH_SHA2_521:\r\n\t\t\tpvar->client_key_bits = 521;\r\n\t\t\tpvar->server_key_bits = 521;\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\t// TODO\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\tresult = ssh2_kex_finish(pvar, hash, hashlen, share_key, hostkey, signature, siglen);\r\n\r\n\tret = HOSTS_check_host_key(pvar, pvar->ssh_state.hostname, pvar->ssh_state.tcpport, hostkey);\r\n\tif (ret == TRUE) {\r\n\t\t// \ufffdz\ufffdX\ufffdg\ufffd\ufffd\ufffd\u030am\ufffdF\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\u3471\ufffd\u030f\ufffd\ufffd\ufffd\ufffd\ufffd\ufffds\ufffd\ufffd\r\n\t\tSSH_notify_host_OK(pvar);\r\n\t\t// known_hosts\ufffd_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\u030c\u0102\u044fo\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\u020d~\ufffdA\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t}\r\n\r\nerror:\r\n\tEC_POINT_clear_free(server_public);\r\n\tEC_KEY_free(pvar->ecdh_client_key); pvar->ecdh_client_key = NULL;\r\n\tkey_free(hostkey);\r\n\tfree(ecdh_buf);\r\n\tBN_free(share_key);\r\n\r\n\tif (emsg)\r\n\t\tnotify_fatal_error(pvar, emsg, TRUE);\r\n\r\n\treturn result;\r\n}\r\n\r\n\r\n// KEX\ufffd\u0242\ufffd\ufffd\ufffd\ufffd\u0103T\ufffd[\ufffdo\ufffd\ufffd\ufffd\ufffd\u0502\ufffd\ufffd\u0102\ufffd\ufffd\ufffd 31 \ufffd\u0503\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd\u0251\u0382\ufffd\ufffd\ufffdn\ufffd\ufffd\ufffdh\ufffd\ufffd\r\nstatic BOOL handle_SSH2_dh_common_reply(PTInstVar pvar)\r\n{\r\n\tswitch (pvar->kex_type) {\r\n\t\tcase KEX_DH_GRP1_SHA1:\r\n\t\tcase KEX_DH_GRP14_SHA1:\r\n\t\tcase KEX_DH_GRP14_SHA256:\r\n\t\tcase KEX_DH_GRP16_SHA512:\r\n\t\tcase KEX_DH_GRP18_SHA512:\r\n\t\t\thandle_SSH2_dh_kex_reply(pvar);\r\n\t\t\tbreak;\r\n\t\tcase KEX_DH_GEX_SHA1:\r\n\t\tcase KEX_DH_GEX_SHA256:\r\n\t\t\thandle_SSH2_dh_gex_group(pvar);\r\n\t\t\tbreak;\r\n\t\tcase KEX_ECDH_SHA2_256:\r\n\t\tcase KEX_ECDH_SHA2_384:\r\n\t\tcase KEX_ECDH_SHA2_521:\r\n\t\t\thandle_SSH2_ecdh_kex_reply(pvar);\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\t// TODO\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n\r\nstatic void do_SSH2_dispatch_setup_for_transfer(PTInstVar pvar)\r\n{\r\n\tpvar->kex_status = KEX_FLAG_KEXDONE;\r\n\r\n\tSSH2_dispatch_init(6);\r\n\tSSH2_dispatch_add_range_message(SSH2_MSG_GLOBAL_REQUEST, SSH2_MSG_CHANNEL_FAILURE);\r\n\tSSH2_dispatch_add_message(SSH2_MSG_KEXINIT);\r\n}\r\n\r\n\r\nstatic BOOL handle_SSH2_newkeys(PTInstVar pvar)\r\n{\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_NEWKEYS was received(DH key generation is completed).\");\r\n\r\n\t// \ufffd\ufffd\ufffdO\ufffd\u030e\ufffd\u030fI\ufffd\ufffd (2005.3.7 yutaka)\r\n\tif (LogLevel(pvar, LOG_LEVEL_SSHDUMP)) {\r\n\t\tsave_memdump(LOGDUMP);\r\n\t}\r\n\tfinish_memdump();\r\n\r\n\tpvar->kex_status |= KEX_FLAG_NEWKEYS_RECEIVED;\r\n\r\n\t// SSH2_MSG_NEWKEYS \ufffd\ufffdM\ufffd\ufffd\u0351\ufffd\ufffd\u80a9\ufffd\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffd\u0348\u00cd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\u0302\u0141A\r\n\t// \ufffd\ufffdM\ufffd\ufffd\ufffd\ufffd\ufffd\u0308\u00cd\ufffd\ufffd\ufffd(\ufffd\ufffd\ufffd\ufffd)\ufffd\ufffdL\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\ufffdB\r\n\tssh2_set_newkeys(pvar, MODE_IN);\r\n\tif (!CRYPT_start_encryption(pvar, 0, 1)) {\r\n\t\t// TODO: error\r\n\t}\r\n\r\n\t// \ufffd\ufffd\ufffdl\ufffd\u0241AMAC\ufffd\ufffd\ufffd\ufffd\u0448\ufffd\ufffdk\ufffd\ufffdL\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\ufffdB\r\n\tpvar->ssh2_keys[MODE_IN].mac.enabled = 1;\r\n\tpvar->ssh2_keys[MODE_IN].comp.enabled = 1;\r\n\tenable_recv_compression(pvar);\r\n\r\n\tif (pvar->server_strict_kex) {\r\n\t\tpvar->ssh_state.receiver_sequence_number = 0;\r\n\t}\r\n\r\n\tSSH2_dispatch_add_message(SSH2_MSG_EXT_INFO);\r\n\r\n\t// SSH2_MSG_NEWKEYS \ufffd\ufffd\ufffd\ufffd\ufffd\u0251\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffd\ufffdKEX\ufffd\u034a\ufffd\ufffd\ufffd\ufffdB\ufffd\ufffd\ufffd\u030f\ufffd\ufffd\ufffd\ufffd\u0248\u0682\ufffdB\r\n\tif (pvar->kex_status & KEX_FLAG_NEWKEYS_SENT) {\r\n\t\tif (pvar->kex_status & KEX_FLAG_REKEYING) {\r\n\t\t\tint i;\r\n\t\t\tChannel_t *c;\r\n\r\n\t\t\tdo_SSH2_dispatch_setup_for_transfer(pvar);\r\n\r\n\t\t\t// \ufffd\ufffd\ufffd\u70b8\ufffdo\ufffdb\ufffdt\ufffd@\ufffd\u0255\u06d1\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdf\ufffd[\ufffd^\ufffd\ud805\uddc2\ufffd\r\n\t\t\tfor (i = 0 ; i < CHANNEL_MAX ; i++) {\r\n\t\t\t\tc = &channels[i];\r\n\t\t\t\tif (c->used) {\r\n\t\t\t\t\tssh2_channel_retry_send_bufchain(pvar, c);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd SSH2_MSG_NEWKEYS \ufffd\u0311\ufffd\ufffd\ufffdM\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdA\ufffd\u020d~\ufffd\u0312\u0290M\ufffd\u0348\u00cd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ua0bd\ufffd\ufffd\u0502\u0242\u0202\ufffd\r\n\t\t\tssh2_finish_encryption_setup(pvar);\r\n\r\n\t\t\t// \ufffd\ufffd\ufffd\ufffd\u030c\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0343\ufffd\ufffd[\ufffdU\ufffdF\ufffd\u0602\ufffd\ufffdJ\ufffdn\ufffd\ufffd\ufffd\ufffd\r\n\t\t\tssh2_prep_userauth(pvar);\r\n\t\t}\r\n\t\tpvar->kex_status = KEX_FLAG_KEXDONE;\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nstatic void ssh2_prep_userauth(PTInstVar pvar)\r\n{\r\n\tint type = (1 << SSH_AUTH_PASSWORD) | (1 << SSH_AUTH_RSA) |\r\n\t           (1 << SSH_AUTH_TIS) | (1 << SSH_AUTH_PAGEANT);\r\n\r\n\t// \ufffdF\ufffd\u0615\ufffd\ufffd\ufffd\ufffd\u0310\u0752\ufffd\r\n\tAUTH_set_supported_auth_types(pvar, type);\r\n\r\n\t// \ufffdF\ufffd\u0603_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\ufffd\\\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\tAUTH_advance_to_next_cred(pvar);\r\n}\r\n\r\n// \ufffd\ufffd\ufffd[\ufffdU\ufffdF\ufffd\u0602\u030aJ\ufffdn\r\nBOOL do_SSH2_userauth(PTInstVar pvar)\r\n{\r\n\tbuffer_t *msg;\r\n\tchar *s;\r\n\tunsigned char *outmsg;\r\n\tint len;\r\n\r\n\t// \ufffdp\ufffdX\ufffd\ufffd\ufffd[\ufffdh\ufffd\ufffd\ufffd\ufffd\ufffd\u0342\ufffd\ufffd\ua0bd\ufffd\ufffd 1 \ufffd\ud81e\uddc2\u0102\ufffd (2005.3.12 yutaka)\r\n\tpvar->keyboard_interactive_password_input = 0;\r\n\r\n\t// \ufffd\ufffd\ufffd\u0142\u0243\ufffd\ufffdO\ufffdC\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffds\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ua347\ufffd\u0341ASSH2_MSG_SERVICE_REQUEST\ufffd\u0311\ufffd\ufffdM\ufffd\ufffd\r\n\t// \ufffd\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffd\u0182\u0242\ufffd\ufffd\ufffdBOpenSSH\ufffd\u0142\u034ex\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffdATru64 UNIX\ufffd\u0142\u0343T\ufffd[\ufffdo\ufffdG\ufffd\ufffd\ufffd[\ufffd\u0182\u0202\ufffd\ufffd\u0102\ufffd\ufffd\u0702\ufffd\ufffd\ufffd\ufffd\u07c1B\r\n\t// (2005.3.10 yutaka)\r\n\t// Cisco 12.4.11T \ufffd\u0142\ufffd\ufffd\ufffd\ufffd\u030c\ufffd\ufffd\u06c2\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0357l\ufffdB\r\n\t// \ufffdF\ufffd\u0603\ufffd\ufffd\\\ufffdb\ufffdh none \ufffd\u030e\ufffd\ufffd_\ufffd\ufffd SSH2_MSG_SERVICE_REQUEST \ufffd\ud805\uddd0M\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffdB\r\n\t// (2007.10.26 maya)\r\n\tif (pvar->userauth_retry_count > 0\r\n\t || pvar->tryed_ssh2_authlist == TRUE) {\r\n\t\treturn do_SSH2_authrequest(pvar);\r\n\t\t/* NOT REACHED */\r\n\t}\r\n\r\n\t// start user authentication\r\n\tmsg = buffer_init();\r\n\tif (msg == NULL) {\r\n\t\t// TODO: error check\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\treturn FALSE;\r\n\t}\r\n\ts = \"ssh-userauth\";\r\n\tbuffer_put_string(msg, s, strlen(s));\r\n\t//buffer_put_padding(msg, 32); // XXX:\r\n\tlen = buffer_len(msg);\r\n\toutmsg = begin_send_packet(pvar, SSH2_MSG_SERVICE_REQUEST, len);\r\n\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\tfinish_send_packet(pvar);\r\n\tbuffer_free(msg);\r\n\r\n\tSSH2_dispatch_init(4);\r\n\tSSH2_dispatch_add_message(SSH2_MSG_SERVICE_ACCEPT);\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_SERVICE_REQUEST was sent at do_SSH2_userauth().\");\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n\r\nstatic BOOL handle_SSH2_service_accept(PTInstVar pvar)\r\n{\r\n\tchar *data, *svc;\r\n\r\n\t// 6byte\ufffdi\ufffdT\ufffdC\ufffdY\ufffd{\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd{\ufffd^\ufffdC\ufffdv\ufffdj\ufffd\ufffd\ufffd\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffd\u020d~\ufffd\u0303y\ufffdC\ufffd\ufffd\ufffd[\ufffdh\r\n\tdata = pvar->ssh_state.payload;\r\n\r\n\tif ((svc = buffer_get_string(&data, NULL)) == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_get_string returns NULL.\", __FUNCTION__);\r\n\t}\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"SSH2_MSG_SERVICE_ACCEPT was received. service-name=%s\", NonNull(svc));\r\n\tfree(svc);\r\n\r\n\tSSH2_dispatch_init(5);\r\n\tif (pvar->auth_state.cur_cred.method == SSH_AUTH_TIS) {\r\n\t\t// keyboard-interactive method\r\n\t\tSSH2_dispatch_add_message(SSH2_MSG_USERAUTH_INFO_REQUEST);\r\n\t}\r\n\telse if (pvar->auth_state.cur_cred.method == SSH_AUTH_PAGEANT) {\r\n\t\t// Pageant\r\n\t\tSSH2_dispatch_add_message(SSH2_MSG_USERAUTH_PK_OK);\r\n\t}\r\n\telse if (pvar->auth_state.cur_cred.method == SSH_AUTH_PASSWORD) {\r\n\t\tSSH2_dispatch_add_message(SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ);\r\n\t}\r\n\tSSH2_dispatch_add_message(SSH2_MSG_USERAUTH_SUCCESS);\r\n\tSSH2_dispatch_add_message(SSH2_MSG_USERAUTH_FAILURE);\r\n\tSSH2_dispatch_add_message(SSH2_MSG_USERAUTH_BANNER);\r\n\tSSH2_dispatch_add_message(SSH2_MSG_EXT_INFO);\r\n\r\n\treturn do_SSH2_authrequest(pvar);\r\n}\r\n\r\n\r\n/*\r\n * SSH_MSG_EXT_INFO:\r\n *     byte       SSH_MSG_EXT_INFO (value 7)\r\n *     uint32     nr-extensions\r\n *     repeat the following 2 fields \"nr-extensions\" times:\r\n *       string   extension-name\r\n *       string   extension-value (binary)\r\n */\r\n\r\nstatic BOOL handle_SSH2_ext_info(PTInstVar pvar)\r\n{\r\n\tunsigned int num_of_exts, i, len;\r\n\tunsigned char ext_name[256], ext_val[2048];\r\n\tchar *new_payload_buffer = NULL;\r\n\r\n\tlogputs(LOG_LEVEL_INFO, \"SSH2_EXT_INFO was received.\");\r\n\r\n\tif (!get_uint32_from_payload(pvar, &num_of_exts)) {\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: ext info payload was corrupted\", __FUNCTION__);\r\n\t\treturn FALSE;\r\n\t}\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: %d extensions\", __FUNCTION__, num_of_exts);\r\n\r\n\tfor (i=0; i<num_of_exts; i++) {\r\n\t\tif (!get_string_from_payload(pvar, ext_name, sizeof(ext_name), &len, TRUE)) {\r\n\t\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: can't get extension name\", __FUNCTION__);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\tif (strcmp(ext_name, \"server-sig-algs\") == 0) {\r\n\t\t\tif (!get_namelist_from_payload(pvar, ext_val, sizeof(ext_val), &len)) {\r\n\t\t\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: can't get extension value\", __FUNCTION__);\r\n\t\t\t\treturn FALSE;\r\n\t\t\t}\r\n\t\t\tif (pvar->server_sig_algs) {\r\n\t\t\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: update server-sig-algs, old=%s, new=%s\",\r\n\t\t\t\t          __FUNCTION__, pvar->server_sig_algs, ext_val);\r\n\t\t\t\tfree(pvar->server_sig_algs);\r\n\t\t\t}\r\n\t\t\tpvar->server_sig_algs = _strdup(ext_val);\r\n\t\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: extension: server-sig-algs, value: %s\", __FUNCTION__, ext_val);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (!get_string_from_payload(pvar, ext_val, sizeof(ext_val), &len, TRUE)) {\r\n\t\t\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: can't get extension value\", __FUNCTION__);\r\n\t\t\t\treturn FALSE;\r\n\t\t\t}\r\n\t\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: extension: ext_name\", __FUNCTION__, ext_name);\r\n\t\t}\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n// \ufffd\ufffd\ufffd[\ufffdU\ufffdF\ufffd\u0603p\ufffdP\ufffdb\ufffdg\ufffd\u030d\\\ufffdz\r\nBOOL do_SSH2_authrequest(PTInstVar pvar)\r\n{\r\n\tbuffer_t *msg = NULL;\r\n\tchar *s, *username;\r\n\tunsigned char *outmsg;\r\n\tint len;\r\n\tchar *connect_id = \"ssh-connection\";\r\n\r\n\tmsg = buffer_init();\r\n\tif (msg == NULL) {\r\n\t\t// TODO: error check\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\t// \ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\u030d\\\ufffdz\r\n\tusername = pvar->auth_state.user;  // \ufffd\ufffd\ufffd[\ufffdU\ufffd\ufffd\r\n\tbuffer_put_string(msg, username, strlen(username));\r\n\tbuffer_put_string(msg, connect_id, strlen(connect_id));\r\n\r\n\tif (!pvar->tryed_ssh2_authlist) { // \"none\"\ufffd\ufffd\ufffd\\\ufffdb\ufffdh\ufffd\u0311\ufffd\ufffdM\r\n\t\t// \ufffdF\ufffd\u0603\ufffd\ufffdX\ufffdg\ufffd\ufffd\ufffdT\ufffd[\ufffdo\ufffd\ufffd\ufffd\ufffd\u64fe\ufffd\ufffd\ufffd\ufffdB\r\n\t\t// SSH2_MSG_USERAUTH_FAILURE\ufffd\ufffd\ufffd\u0502\u90aa\ufffdA\ufffdT\ufffd[\ufffdo\ufffd\u0242\u0343\ufffd\ufffdO\ufffd\u034ec\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t\t// (2007.4.27 yutaka)\r\n\t\ts = \"none\";  // method name\r\n\t\tbuffer_put_string(msg, s, strlen(s));\r\n\r\n\t} else if (pvar->auth_state.cur_cred.method == SSH_AUTH_PASSWORD) { // \ufffdp\ufffdX\ufffd\ufffd\ufffd[\ufffdh\ufffdF\ufffd\ufffd\r\n\t\t// password authentication method\r\n\t\ts = \"password\";\r\n\t\tbuffer_put_string(msg, s, strlen(s));\r\n\t\tbuffer_put_char(msg, 0); // 0\r\n\r\n\t\tif (pvar->ssh2_autologin == 1) { // SSH2\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdO\ufffdC\ufffd\ufffd\r\n\t\t\ts = pvar->ssh2_password;\r\n\t\t} else {\r\n\t\t\ts = pvar->auth_state.cur_cred.password;  // \ufffdp\ufffdX\ufffd\ufffd\ufffd[\ufffdh\r\n\t\t}\r\n\t\tbuffer_put_string(msg, s, strlen(s));\r\n\r\n\t} else if (pvar->auth_state.cur_cred.method == SSH_AUTH_TIS) { // keyboard-interactive (2005.3.12 yutaka)\r\n\t\ts = \"keyboard-interactive\";  // method name\r\n\t\tbuffer_put_string(msg, s, strlen(s));\r\n\t\ts = \"\";  // language tag\r\n\t\tbuffer_put_string(msg, s, strlen(s));\r\n\t\ts = \"\";  // submethods\r\n\t\tbuffer_put_string(msg, s, strlen(s));\r\n\r\n\t\tSSH2_dispatch_add_message(SSH2_MSG_USERAUTH_INFO_REQUEST);\r\n\r\n\t} else if (pvar->auth_state.cur_cred.method == SSH_AUTH_RSA) { // \ufffd\ufffd\ufffdJ\ufffd\ufffd\ufffdF\ufffd\ufffd\r\n\t\tbuffer_t *signbuf = NULL;\r\n\t\tbuffer_t *blob = NULL;\r\n\t\tint bloblen;\r\n\t\tchar *signature = NULL;\r\n\t\tint siglen;\r\n\t\tKey *keypair = pvar->auth_state.cur_cred.key_pair;\r\n\t\tssh_keyalgo keyalgo;\r\n\t\tchar *keyalgo_name;\r\n\r\n\t\tif (get_SSH2_publickey_blob(pvar, &blob, &bloblen) == FALSE) {\r\n\t\t\tgoto error;\r\n\t\t}\r\n\r\n\t\tkeyalgo = choose_SSH2_keysign_algorithm(pvar, keypair->type);\r\n\t\tkeyalgo_name = get_ssh2_hostkey_algorithm_name(keyalgo);\r\n\r\n\t\t// step1\r\n\t\tsignbuf = buffer_init();\r\n\t\tif (signbuf == NULL) {\r\n\t\t\tbuffer_free(blob);\r\n\t\t\tgoto error;\r\n\t\t}\r\n\t\t// \ufffdZ\ufffdb\ufffdV\ufffd\ufffd\ufffd\ufffdID\r\n\t\tbuffer_append_length(signbuf, pvar->session_id, pvar->session_id_len);\r\n\t\tbuffer_put_char(signbuf, SSH2_MSG_USERAUTH_REQUEST);\r\n\t\ts = username;  // \ufffd\ufffd\ufffd[\ufffdU\ufffd\ufffd\r\n\t\tbuffer_put_string(signbuf, s, strlen(s));\r\n\t\ts = connect_id;\r\n\t\tbuffer_put_string(signbuf, s, strlen(s));\r\n\t\ts = \"publickey\";\r\n\t\tbuffer_put_string(signbuf, s, strlen(s));\r\n\t\tbuffer_put_char(signbuf, 1); // true\r\n\r\n\t\ts = keyalgo_name;\r\n\t\tbuffer_put_string(signbuf, s, strlen(s));\r\n\r\n\t\ts = buffer_ptr(blob);\r\n\t\tbuffer_append_length(signbuf, s, bloblen);\r\n\r\n\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd\u030d\uc42c\r\n\t\tif (generate_SSH2_keysign(keypair, &signature, &siglen, buffer_ptr(signbuf), buffer_len(signbuf), keyalgo) == FALSE) {\r\n\t\t\tbuffer_free(blob);\r\n\t\t\tbuffer_free(signbuf);\r\n\t\t\tgoto error;\r\n\t\t}\r\n\r\n\t\t// step3\r\n\t\ts = \"publickey\";\r\n\t\tbuffer_put_string(msg, s, strlen(s));\r\n\t\tbuffer_put_char(msg, 1); // true\r\n\r\n\t\ts = keyalgo_name;\r\n\t\tbuffer_put_string(msg, s, strlen(s));\r\n\r\n\t\ts = buffer_ptr(blob);\r\n\t\tbuffer_append_length(msg, s, bloblen);\r\n\t\tbuffer_append_length(msg, signature, siglen);\r\n\r\n\t\tbuffer_free(blob);\r\n\t\tbuffer_free(signbuf);\r\n\t\tfree(signature);\r\n\r\n\t} else if (pvar->auth_state.cur_cred.method == SSH_AUTH_PAGEANT) { // Pageant\r\n\t\tunsigned char *puttykey;\r\n\t\tunsigned char *keytype_name, *keyalgo_name;\r\n\t\tssh_keytype keytype;\r\n\t\tssh_keyalgo keyalgo;\r\n\r\n\t\ts = \"publickey\";\r\n\t\tbuffer_put_string(msg, s, strlen(s));\r\n\t\tbuffer_put_char(msg, 0); // false\r\n\r\n\t\tif (pvar->pageant_keycurrent != 0) {\r\n\t\t\t// \ufffd\ufffd\ufffdO\ufffd\u030c\ufffd\ufffd\ufffd\ufffdX\ufffdL\ufffdb\ufffdv\r\n\t\t\tlen = get_uint32_MSBfirst(pvar->pageant_curkey);\r\n\t\t\tpvar->pageant_curkey += 4 + len;\r\n\t\t\t// \ufffd\ufffd\ufffdO\ufffd\u030c\ufffd\ufffd\u0303R\ufffd\ufffd\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffdX\ufffdL\ufffdb\ufffdv\r\n\t\t\tlen = get_uint32_MSBfirst(pvar->pageant_curkey);\r\n\t\t\tpvar->pageant_curkey += 4 + len;\r\n\t\t\t// \ufffd\ufffd\ufffd\u030c\ufffd\ufffd\u0308\u0292u\ufffd\u0597\ufffd\ufffd\ufffd\r\n\t\t}\r\n\t\tputtykey = pvar->pageant_curkey;\r\n\r\n\t\t// \ufffd\ufffd\ufffd\ufffd\u0282\ufffd\ufffd\u75d8\ufffdp\ufffd\ufffd\ufffd\u93d0\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u80b7\ufffd\ufffd\r\n\t\tlen = get_uint32_MSBfirst(puttykey+4);\r\n\t\tkeytype_name = puttykey + 8;\r\n\t\tkeytype = get_hostkey_type_from_name(keytype_name);\r\n\t\tkeyalgo = choose_SSH2_keysign_algorithm(pvar, keytype);\r\n\t\tkeyalgo_name = get_ssh2_hostkey_algorithm_name(keyalgo);\r\n\r\n\t\t// \ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd\ufffd\ufffd\ufffdR\ufffds\ufffd[\ufffd\ufffd\ufffd\ufffd\r\n\t\tlen = strlen(keyalgo_name);\r\n\t\tbuffer_put_string(msg, keyalgo_name, len);\r\n\r\n\t\t// \ufffd\ufffd\ufffd\ufffd\ufffdR\ufffds\ufffd[\ufffd\ufffd\ufffd\ufffd\r\n\t\tlen = get_uint32_MSBfirst(puttykey);\r\n\t\tputtykey += 4;\r\n\t\tbuffer_put_string(msg, puttykey, len);\r\n\t\tputtykey += len;\r\n\r\n\t\tpvar->pageant_keycurrent++;\r\n\r\n\t\tSSH2_dispatch_add_message(SSH2_MSG_USERAUTH_PK_OK);\r\n\r\n\t} else {\r\n\t\tgoto error;\r\n\r\n\t}\r\n\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffdM\r\n\tlen = buffer_len(msg);\r\n\toutmsg = begin_send_packet(pvar, SSH2_MSG_USERAUTH_REQUEST, len);\r\n\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\tfinish_send_packet(pvar);\r\n\tbuffer_free(msg);\r\n\r\n\t{\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE,\r\n\t\t\t\"SSH2_MSG_USERAUTH_REQUEST was sent do_SSH2_authrequest(). (method %d)\",\r\n\t\t\tpvar->auth_state.cur_cred.method);\r\n\t}\r\n\r\n\treturn TRUE;\r\n\r\nerror:\r\n\tbuffer_free(msg);\r\n\r\n\treturn FALSE;\r\n}\r\n\r\n\r\n//\r\n// SSH2 heartbeat procedure\r\n//\r\n// NAT\ufffd\u008b\ufffd\ufffd\u0242\ufffd\ufffd\ufffd\ufffd\u0101ASSH\ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg\ufffd\u0183T\ufffd[\ufffdo\ufffd\u0502\u0152\u0290M\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ua347\ufffdA\r\n// \ufffd\ufffd\ufffd[\ufffd^\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdNAT\ufffde\ufffd[\ufffdu\ufffd\ufffd\ufffd\ufffd\ufffdN\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffd\u90b1\ufffd\u0182\ufffd\ufffd\ufffd\ufffd\ufffdASSH\ufffdR\ufffdl\ufffdN\ufffdV\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\r\n// \ufffd\u0602\ufffd\u0102\ufffd\ufffd\u0702\ufffd\ufffd\ufffd\ufffd\u0182\ufffd\ufffd\ufffd\ufffd\ufffdB\ufffd\ufffd\ufffd\ufffdI\ufffd\u0241A\ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffd\ufffd_\ufffd~\ufffd[\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\r\n// \ufffd\ufffd\ufffdM\ufffd\ufffd\ufffd\u90b1\ufffd\u0182\u0151\u038f\ufffd\ufffd\ufffd\ufffd\ufffdB(2004.12.10 yutaka)\r\n//\r\n// \ufffd\ufffd\ufffd[\ufffdh\ufffd\ufffd\ufffdX\ufffd_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\ufffd\ufffd\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffdM\ufffd\ufffd\ufffd\ufffd\u60a4\ufffd\u0255\u03cdX\ufffdB(2007.12.26 yutaka)\r\n//\r\n#define WM_SEND_HEARTBEAT (WM_USER + 1)\r\n\r\nstatic LRESULT CALLBACK ssh_heartbeat_dlg_proc(HWND hWnd, UINT msg, WPARAM wp, LPARAM lp)\r\n{\r\n\r\n\tswitch (msg) {\r\n\t\tcase WM_INITDIALOG:\r\n\t\t\treturn FALSE;\r\n\r\n\t\tcase WM_SEND_HEARTBEAT:\r\n\t\t\t{\r\n\t\t\tPTInstVar pvar = (PTInstVar)wp;\r\n\t\t\tbuffer_t *msg;\r\n\t\t\tchar *s;\r\n\t\t\tunsigned char *outmsg;\r\n\t\t\tint len;\r\n\r\n\t\t\tmsg = buffer_init();\r\n\t\t\tif (msg == NULL) {\r\n\t\t\t\t// TODO: error check\r\n\t\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\t\treturn FALSE;\r\n\t\t\t}\r\n\t\t\ts = \"ssh-heartbeat\";\r\n\t\t\tbuffer_put_string(msg, s, strlen(s));\r\n\t\t\tlen = buffer_len(msg);\r\n\t\t\tif (SSHv1(pvar)) {\r\n\t\t\t\toutmsg = begin_send_packet(pvar, SSH_MSG_IGNORE, len);\r\n\t\t\t} else {\r\n\t\t\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_IGNORE, len);\r\n\t\t\t}\r\n\t\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\t\tfinish_send_packet(pvar);\r\n\t\t\tbuffer_free(msg);\r\n\t\t\tif (SSHv1(pvar)) {\r\n\t\t\t\tlogputs(LOG_LEVEL_SSHDUMP, \"SSH_MSG_IGNORE was sent at ssh_heartbeat_dlg_proc().\");\r\n\t\t\t} else {\r\n\t\t\t\tlogputs(LOG_LEVEL_SSHDUMP, \"SSH2_MSG_IGNORE was sent at ssh_heartbeat_dlg_proc().\");\r\n\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn TRUE;\r\n\t\t\tbreak;\r\n\r\n\t\tcase WM_COMMAND:\r\n\t\t\tswitch (wp) {\r\n\t\t\t}\r\n\r\n\t\t\tswitch (LOWORD(wp)) {\r\n\t\t\t\tcase IDOK:\r\n\t\t\t\t\t{\r\n\t\t\t\t\treturn TRUE;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\tcase IDCANCEL:\r\n\t\t\t\t\tEndDialog(hWnd, 0);\r\n\t\t\t\t\treturn TRUE;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\treturn FALSE;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\t\tcase WM_CLOSE:\r\n\t\t\t// close\ufffd{\ufffd^\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd window \ufffd\ufffd\ufffd\u0082\ufffd\ufffd\u0202\ufffd\ufffd\u60a4\ufffd\u0242\ufffd\ufffd\ufffdB\r\n\t\t\treturn TRUE;\r\n\r\n\t\tcase WM_DESTROY:\r\n\t\t\treturn TRUE;\r\n\r\n\t\tdefault:\r\n\t\t\treturn FALSE;\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\n\r\nstatic unsigned __stdcall ssh_heartbeat_thread(void *p)\r\n{\r\n\tstatic int instance = 0;\r\n\tPTInstVar pvar = (PTInstVar)p;\r\n\ttime_t tick;\r\n\r\n\t// \ufffd\ufffd\ufffd\u0142\u024e\ufffd\ufffds\ufffd\ufffd\ufffd\u0202\u727d\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0255\u0502\ufffdB\r\n\tif (instance > 0)\r\n\t\treturn 0;\r\n\tinstance++;\r\n\r\n\tfor (;;) {\r\n\t\t// \ufffd\\\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffdN\ufffd\ufffd\ufffd[\ufffdY\ufffd\ufffd\ufffd\ua0bd\ufffd\ufffdX\ufffd\ufffd\ufffdb\ufffdh\ufffd\ufffd\ufffdI\ufffd\ufffd\ufffd\r\n\t\tif (pvar->socket == INVALID_SOCKET)\r\n\t\t\tbreak;\r\n\r\n\t\t// \ufffd\ufffd\u839e\ufffd\u0516\ufffd\ufffd\u0290M\ufffd\u0142\ufffd\ufffd\ufffd\u0381A\ufffdT\ufffd[\ufffdo\ufffd\u0583_\ufffd~\ufffd[\ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ud805\uddc2\ufffd\r\n\t\t// \u81d2l\ufffd\ufffd0\ufffd\u0142\ufffd\ufffd\ufffd\u0389\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t\ttick = time(NULL) - pvar->ssh_heartbeat_tick;\r\n\t\tif (pvar->session_settings.ssh_heartbeat_overtime > 0 &&\r\n\t\t\ttick > pvar->session_settings.ssh_heartbeat_overtime) {\r\n\r\n\t\t\tSendMessage(pvar->ssh_hearbeat_dialog, WM_SEND_HEARTBEAT, (WPARAM)pvar, 0);\r\n\t\t}\r\n\r\n\t\tSleep(100); // yield\r\n\t}\r\n\r\n\tinstance = 0;\r\n\r\n\treturn 0;\r\n}\r\n\r\nstatic void start_ssh_heartbeat_thread(PTInstVar pvar)\r\n{\r\n\tHANDLE thread = INVALID_HANDLE_VALUE;\r\n\tunsigned tid;\r\n\tHWND hDlgWnd;\r\n\r\n\t// \ufffd\ufffd\ufffd[\ufffdh\ufffd\ufffd\ufffdX\ufffd_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\ufffd\ufffd\uc42c\ufffdB\ufffdn\ufffd[\ufffdg\ufffdr\ufffd[\ufffdg\ufffdp\ufffd\u0202\u0302\u0143_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\u0354\ufffd\\\ufffd\ufffd\ufffd\u0302\u0702\u0702\ufffd\r\n\t// \ufffd\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\ufffd\ufffd\\\ufffd[\ufffdXID\ufffd\u0342\u0202\ufffd\u0142\ufffd\ufffd\u60a2\ufffdB\r\n\thDlgWnd = CreateDialog(hInst, MAKEINTRESOURCE(IDD_SSHSCP_PROGRESS),\r\n               pvar->cv->HWin, (DLGPROC)ssh_heartbeat_dlg_proc);\r\n\tpvar->ssh_hearbeat_dialog = hDlgWnd;\r\n\r\n\t// TTSSH\ufffd\ufffd thread-safe \ufffd\u0142\u0342\u0202\ufffd\ufffd\u0302\u0143X\ufffd\ufffd\ufffdb\ufffdh\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffdM\ufffd\u0355s\ufffd\u0081B(2007.12.26 yutaka)\r\n\tthread = (HANDLE)_beginthreadex(NULL, 0, ssh_heartbeat_thread, pvar, 0, &tid);\r\n\tif (thread == 0) {\r\n\t\t// TODO:\r\n\t\tthread = INVALID_HANDLE_VALUE;\r\n\t}\r\n\tpvar->ssh_heartbeat_thread = thread;\r\n}\r\n\r\n// \ufffdX\ufffd\ufffd\ufffdb\ufffdh\ufffd\u0312\ufffd~ (2004.12.27 yutaka)\r\nvoid halt_ssh_heartbeat_thread(PTInstVar pvar)\r\n{\r\n\tif (pvar->ssh_heartbeat_thread != INVALID_HANDLE_VALUE) {\r\n\t\tWaitForSingleObject(pvar->ssh_heartbeat_thread, INFINITE);\r\n\t\tCloseHandle(pvar->ssh_heartbeat_thread);\r\n\t\tpvar->ssh_heartbeat_thread = INVALID_HANDLE_VALUE;\r\n\r\n\t\tDestroyWindow(pvar->ssh_hearbeat_dialog);\r\n\t}\r\n}\r\n\r\n\r\nstatic BOOL handle_SSH2_userauth_success(PTInstVar pvar)\r\n{\r\n\tbuffer_t *msg;\r\n\tchar *s;\r\n\tunsigned char *outmsg;\r\n\tint len;\r\n\tChannel_t *c;\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_USERAUTH_SUCCESS was received.\");\r\n\r\n\t// \ufffdp\ufffdX\ufffd\ufffd\ufffd[\ufffdh\ufffd\u0314j\ufffd\ufffd (2006.8.22 yutaka)\r\n\tif (pvar->settings.remember_password == 0) {\r\n\t\tdestroy_malloced_string(&pvar->auth_state.cur_cred.password);\r\n\t}\r\n\r\n\t// \ufffdF\ufffd\ufffdOK\r\n\tpvar->userauth_success = 1;\r\n\r\n\t// \ufffdf\ufffdB\ufffdX\ufffdp\ufffdb\ufffd`\ufffd\ufffd\ufffd[\ufffd`\ufffd\ufffd\ufffd\u030d\u0110\u0752\ufffd\r\n\tdo_SSH2_dispatch_setup_for_transfer(pvar);\r\n\r\n\tif (pvar->nosession) {\r\n\t\t// start forwarding\r\n\t\tFWD_prep_forwarding(pvar);\r\n\t\tFWD_enter_interactive_mode(pvar);\r\n\t}\r\n\telse {\r\n\t\t// \ufffd`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\u0752\ufffd\r\n\t\t// FWD_prep_forwarding()\ufffd\ufffdshell ID\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\ufffd\u0250\u0752\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffdB(2005.7.3 yutaka)\r\n\t\t// changed window size from 64KB to 32KB. (2006.3.6 yutaka)\r\n\t\t// changed window size from 32KB to 128KB. (2007.10.29 maya)\r\n\t\tif (pvar->use_subsystem) {\r\n\t\t\tc = ssh2_channel_new(CHAN_SES_WINDOW_DEFAULT, CHAN_SES_PACKET_DEFAULT, TYPE_SUBSYSTEM_GEN, -1);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tc = ssh2_channel_new(CHAN_SES_WINDOW_DEFAULT, CHAN_SES_PACKET_DEFAULT, TYPE_SHELL, -1);\r\n\t\t}\r\n\r\n\t\tif (c == NULL) {\r\n\t\t\tUTIL_get_lang_msg(\"MSG_SSH_NO_FREE_CHANNEL\", pvar,\r\n\t\t\t\t\t  \"Could not open new channel. TTSSH is already opening too many channels.\");\r\n\t\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\t// \ufffdV\ufffdF\ufffd\ufffd\ufffd\ufffdID\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\r\n\t\tpvar->shell_id = c->self_id;\r\n\r\n\t\t// \ufffdV\ufffdF\ufffd\ufffd\ufffdI\ufffd[\ufffdv\ufffd\ufffd\r\n\t\tmsg = buffer_init();\r\n\t\tif (msg == NULL) {\r\n\t\t\t// TODO: error check\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\ts = \"session\";\r\n\t\tbuffer_put_string(msg, s, strlen(s));  // ctype\r\n\t\tbuffer_put_int(msg, c->self_id);  // self(channel number)\r\n\t\tbuffer_put_int(msg, c->local_window);  // local_window\r\n\t\tbuffer_put_int(msg, c->local_maxpacket);  // local_maxpacket\r\n\t\tlen = buffer_len(msg);\r\n\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_OPEN, len);\r\n\t\tmemcpy(outmsg, buffer_ptr (msg), len);\r\n\t\tfinish_send_packet(pvar);\r\n\t\tbuffer_free(msg);\r\n\r\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_CHANNEL_OPEN was sent at handle_SSH2_userauth_success().\");\r\n\t}\r\n\r\n\t// \ufffdn\ufffd[\ufffdg\ufffdr\ufffd[\ufffdg\ufffdE\ufffdX\ufffd\ufffd\ufffdb\ufffdh\ufffd\u030aJ\ufffdn (2004.12.11 yutaka)\r\n\tstart_ssh_heartbeat_thread(pvar);\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"User authentication is successful and SSH heartbeat thread is starting.\");\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n\r\nstatic BOOL handle_SSH2_userauth_failure(PTInstVar pvar)\r\n{\r\n\tint len;\r\n\tchar *data;\r\n\tchar *cstring;\r\n\tint partial;\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_USERAUTH_FAILURE was received.\");\r\n\r\n\t// 6byte\ufffdi\ufffdT\ufffdC\ufffdY\ufffd{\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd{\ufffd^\ufffdC\ufffdv\ufffdj\ufffd\ufffd\ufffd\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffd\u020d~\ufffd\u0303y\ufffdC\ufffd\ufffd\ufffd[\ufffdh\r\n\tdata = pvar->ssh_state.payload;\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY - (\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffdT\ufffdC\ufffdY+1)\ufffdG\ufffd^\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY\r\n\tlen = pvar->ssh_state.payloadlen;\r\n\r\n\tcstring = buffer_get_string(&data, NULL); // \ufffdF\ufffd\u0603\ufffd\ufffdX\ufffdg\ufffd\u030e\u64fe\r\n\tpartial = data[0];\r\n\tdata += 1;\r\n\r\n\t// \ufffdL\ufffd\ufffd\ufffd\u0214F\ufffd\u0615\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\ua347\r\n\tif (cstring == NULL) {\r\n\t\tUTIL_get_lang_msg(\"MSG_SSH_SERVER_NO_AUTH_METHOD_ERROR\", pvar,\r\n\t\t                  \"The server doesn't have valid authentication method.\");\r\n\t\tnotify_fatal_error(pvar, pvar->UIMsg, TRUE);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\t// tryed_ssh2_authlist \ufffd\ufffd FALSE \ufffd\u030f\ua347\ufffd\u0341A\ufffd\u0702\ufffd\ufffdF\ufffd\u0602\ufffd\ufffd\ufffd\ufffds\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\tif (!pvar->tryed_ssh2_authlist) {\r\n\t\tint type = 0;\r\n\r\n\t\tpvar->tryed_ssh2_authlist = TRUE;\r\n\r\n\t\t// \ufffdF\ufffd\u0603_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\u0303\ufffd\ufffdW\ufffdI\ufffd{\ufffd^\ufffd\ufffd\ufffd\ufffd\ufffdX\ufffdV\r\n\t\tif (strstr(cstring, \"password\")) {\r\n\t\t\ttype |= (1 << SSH_AUTH_PASSWORD);\r\n\t\t}\r\n\t\tif (strstr(cstring, \"publickey\")) {\r\n\t\t\ttype |= (1 << SSH_AUTH_RSA);\r\n\t\t\ttype |= (1 << SSH_AUTH_PAGEANT);\r\n\t\t}\r\n\t\tif (strstr(cstring, \"keyboard-interactive\")) {\r\n\t\t\ttype |= (1 << SSH_AUTH_TIS);\r\n\t\t}\r\n\t\tif (!AUTH_set_supported_auth_types(pvar, type))\r\n\t\t\treturn FALSE;\r\n\r\n\t\tpvar->ssh2_authlist = cstring; // \ufffds\ufffdv\ufffd\u0242\u0202\ufffd\ufffd\ufffd\ufffd\ufffdt\ufffd\ufffd\ufffd[\ufffd\ufffd\ufffd\u90b1\ufffd\ufffd\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"method list from server: %s\", cstring);\r\n\r\n\t\tif (pvar->ssh2_authmethod == SSH_AUTH_TIS &&\r\n\t\t    pvar->ask4passwd &&\r\n\t\t    pvar->session_settings.CheckAuthListFirst &&\r\n\t\t    pvar->auth_state.auth_dialog != NULL) {\r\n\t\t\t// challenge \ufffd\ufffd ask4passwd \ufffd\u0302\u0182\ufffd\ufffdA\ufffdF\ufffd\u0603\ufffd\ufffd\\\ufffdb\ufffdh\ufffd\ua5d7\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u64fe\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\t\t\t// \ufffd\ufffd\ufffd\ufffd\ufffdI\ufffd\ufffd TIS \ufffd_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\ufffd\ufffdo\ufffd\ufffd\ufffd\ufffd\ufffd\u07c2\ufffd OK \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\t\t\tSendMessage(pvar->auth_state.auth_dialog, WM_COMMAND, IDOK, 0);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// \ufffd\u0402\u0182\u0702\ufffd none \ufffd\u014e\ufffd\ufffds\ufffd\ufffd\ufffd\u0115\u0502\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffd\u0182\ufffd\ufffd\ufffd\u0202\u0302\u0141A\ufffd\ufffd\ufffd\u06c2\u0303\ufffd\ufffdO\ufffdC\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\t\t\tdo_SSH2_authrequest(pvar);\r\n\t\t}\r\n\r\n\t\treturn TRUE;\r\n\t}\r\n\r\n\t// TCP connection closed\r\n\t//notify_closed_connection(pvar);\r\n\r\n\t// retry count\ufffd\u0312\u01c9\ufffd (2005.3.10 yutaka)\r\n\tif (pvar->auth_state.cur_cred.method != SSH_AUTH_PAGEANT) {\r\n\t\tpvar->userauth_retry_count++;\r\n\t}\r\n\telse {\r\n\t\tif (pvar->pageant_keycount <= pvar->pageant_keycurrent ||\r\n\t\t    pvar->pageant_keyfinal) {\r\n\t\t\t// \ufffdS\ufffd\u0102\u030c\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdI\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\t\t\t// \ufffd\u0702\ufffd\ufffd\u0341ATRUE \ufffd\u0142\u0303\ufffd\ufffdO\ufffdC\ufffd\ufffd\ufffd\u024e\ufffd\ufffds\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffd\u0257\ufffd\ufffd\ufffd\r\n\t\t\tsafefree(pvar->pageant_key);\r\n\t\t\tpvar->userauth_retry_count++;\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// \ufffd\u0702\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\t\t\tdo_SSH2_authrequest(pvar);\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t}\r\n\r\n\tif (pvar->ssh2_autologin == 1) {\r\n\t\tchar uimsg[MAX_UIMSG];\r\n\t\t// SSH2\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdO\ufffdC\ufffd\ufffd\ufffd\ufffd\ufffdL\ufffd\ufffd\ufffd\u030f\ua347\ufffd\u0341A\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffdC\ufffd\u034ds\ufffd\ufffd\u0202\ufffd\ufffdB(2004.12.4 yutaka)\r\n\t\tUTIL_get_lang_msg(\"MSG_SSH_AUTH_FAILURE_ERROR\", pvar,\r\n\t\t                  \"SSH2 auto-login error: user authentication failed.\");\r\n\t\tstrncpy_s(uimsg, sizeof(uimsg), pvar->UIMsg, _TRUNCATE);\r\n\r\n\t\tif (pvar->ssh2_authlist != NULL || strlen(pvar->ssh2_authlist) != 0) {\r\n\t\t\tif ((pvar->auth_state.supported_types & (1 << pvar->ssh2_authmethod)) == 0) {\r\n\t\t\t\t// \ufffdg\ufffdp\ufffd\ufffd\ufffd\ufffd\ufffdF\ufffd\u0603\ufffd\ufffd\\\ufffdb\ufffdh\ufffd\u0343T\ufffd|\ufffd[\ufffdg\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_SERVER_UNSUPPORT_AUTH_METHOD_ERROR\", pvar,\r\n\t\t\t\t                  \"\\nAuthentication method is not supported by server.\");\r\n\t\t\t\tstrncat_s(uimsg, sizeof(uimsg), pvar->UIMsg, _TRUNCATE);\r\n\t\t\t}\r\n\t\t}\r\n\t\tnotify_fatal_error(pvar, uimsg, TRUE);\r\n\t\treturn TRUE;\r\n\t}\r\n\r\n\t// \ufffd\ufffd\ufffd[\ufffdU\ufffdF\ufffd\u0602\u024e\ufffd\ufffds\ufffd\ufffd\ufffd\ufffd\ufffd\u0182\ufffd\ufffd\u0341A\ufffd\ufffd\ufffd[\ufffdU\ufffd\ufffd\ufffd\u034c\u0152\u80b5\ufffd\u0101A\ufffdp\ufffdX\ufffd\ufffd\ufffd[\ufffdh\ufffd\u030d\u0113\ufffd\ufffd\u0342\ufffd\r\n\t// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\ufffd\ufffd\ufffd\ufffd\ufffd\u030f\ufffd\ufffd\ufffd\ufffd\ufffd SSH1 \ufffd\u0193\ufffd\ufffd\ufffd\ufffdB(2004.10.3 yutaka)\r\n\tAUTH_set_generic_mode(pvar);\r\n\tAUTH_advance_to_next_cred(pvar);\r\n\tpvar->ssh_state.status_flags &= ~STATUS_DONT_SEND_CREDENTIALS;\r\n\ttry_send_credentials(pvar);\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nvoid sanitize_str(buffer_t *buff, unsigned char *src, size_t srclen)\r\n{\r\n\tunsigned char *start = src;\r\n\tint cplen = 0;\r\n\tunsigned int i;\r\n\r\n\tif (srclen == 0)\r\n\t\treturn;\r\n\r\n\tfor (i=0; i<srclen; i++) {\r\n\t\tif (src[i] < 0x20 && src[i] != '\\t') {\r\n\t\t\tif (cplen > 0) {\r\n\t\t\t\tbuffer_append(buff, start, cplen);\r\n\t\t\t}\r\n\r\n\t\t\tif (src[i] == '\\r') {\r\n\t\t\t\tbuffer_append(buff, \"\\r\\n\", 2);\r\n\r\n\t\t\t\tif (i < srclen - 1 && src[i+1] == '\\n') {\r\n\t\t\t\t\ti++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (src[i] == '\\n') {\r\n\t\t\t\tbuffer_append(buff, \"\\r\\n\", 2);\r\n\t\t\t}\r\n\r\n\t\t\tstart = src + i + 1;\r\n\t\t\tcplen = 0;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcplen++;\r\n\t\t}\r\n\t}\r\n\r\n\tif (cplen > 0) {\r\n\t\tbuffer_append(buff, start, cplen);\r\n\t}\r\n\r\n\tbuffer_append(buff, \"\\0\", 1);\r\n}\r\n\r\n/*\r\n * SSH_MSG_USERAUTH_BANNER:\r\n *    byte      SSH_MSG_USERAUTH_BANNER\r\n *    string    message in ISO-10646 UTF-8 encoding\r\n *    string    language tag\r\n */\r\nstatic BOOL handle_SSH2_userauth_banner(PTInstVar pvar)\r\n{\r\n\tint msglen, ltaglen;\r\n\tchar buff[2048];\r\n\tchar *new_payload_buffer = NULL;\r\n\r\n\tlogputs(LOG_LEVEL_INFO, \"SSH2_MSG_USERAUTH_BANNER was received.\");\r\n\r\n\tif (!get_string_from_payload(pvar, buff, sizeof(buff), &msglen, TRUE)) {\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: banner payload corrupted.\", __FUNCTION__);\r\n\t\treturn TRUE;\r\n\t}\r\n\r\n\tif (msglen > 0) {\r\n\t\tchar *msg, *msgA;\r\n\t\twchar_t *msgW;\r\n\r\n\t\tif (pvar->authbanner_buffer == NULL) {\r\n\t\t\tpvar->authbanner_buffer = buffer_init();\r\n\t\t}\r\n\t\telse {\r\n\t\t\tbuffer_clear(pvar->authbanner_buffer);\r\n\t\t}\r\n\r\n\t\tif (pvar->authbanner_buffer != NULL) {\r\n\t\t\tsanitize_str(pvar->authbanner_buffer, buff, MIN(msglen, sizeof(buff)));\r\n\t\t\tmsg = buffer_ptr(pvar->authbanner_buffer);\r\n\t\t\tmsglen = buffer_len(pvar->authbanner_buffer) - 1; // NUL Terminate \ufffd\ufffd\ufffd\u0350\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdm\ufffd\u06ce\ufffd\ufffds\ufffd\ufffd\ufffd\u0355\u03ca\ufffd\ufffdO\ufffd\u0315\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\\\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\t\t// \ufffd\ufffd\ufffd\ufffd\ufffdAC0 \ufffd\ufffd\ufffd\u4576\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0702\u0715\\\ufffd\ufffd\ufffd\ufffd\ufffd\u60a4\ufffd\u0182\ufffd\ufffd\ufffd\u0302\u0156]\ufffd\u0702\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\t\tmsg = buff;\r\n\t\t}\r\n\r\n\t\tswitch (pvar->settings.AuthBanner) {\r\n\t\tcase 0:\r\n\t\t\tbreak;\r\n\t\tcase 1:\r\n\t\t\tif (pvar->authbanner_buffer != NULL) {\r\n\t\t\t\tif (pvar->ts->Language == IdJapanese) { // \ufffd\u0182\u80a0\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd{\ufffd\ua0c2\ufffd[\ufffdh\ufffd\u0302\u0751\u0389\ufffd\r\n\t\t\t\t\tswitch (pvar->ts->KanjiCode) {\r\n\t\t\t\t\tcase IdSJIS:\r\n\t\t\t\t\t\tmsgA = ToCharU8(msg);\r\n\t\t\t\t\t\tif (msgA) {\r\n\t\t\t\t\t\t\tmsg = msgA;\r\n\t\t\t\t\t\t\tmsglen = strlen(msg);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase IdEUC:\r\n\t\t\t\t\t\t// CP51932 \ufffd\u0582\u0315\u03ca\ufffd\ufffd\u014e\u8532\ufffd\ufffd\ufffd\ufffd\ufffd\u60a4\ufffd\u0182\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\t\t\t\t\t\t// \ufffdg\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0142\u0182\u80a0\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0389\ufffd\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase IdJIS:\r\n\t\t\t\t\t\t// \ufffdg\ufffd\ufffd\ufffd\u9396\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\u0302\u0196\u0293|\ufffd\u0202\u0302\u0142\u0182\u80a0\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0389\ufffd\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t// nothing to do\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tnew_payload_buffer = msg;\r\n\t\t\t\tpvar->ssh_state.payload_datastart = 0;\r\n\t\t\t\tpvar->ssh_state.payload_datalen = msglen;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tpvar->ssh_state.payload_datastart = 4;\r\n\t\t\t\tpvar->ssh_state.payload_datalen = msglen;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\tmsgW = ToWcharU8(msg);\r\n\t\t\tif (msgW) {\r\n\t\t\t\tMessageBoxW(pvar->cv->HWin, msgW, L\"Authentication Banner\", MB_OK | MB_ICONINFORMATION);\r\n\t\t\t\tfree(msgW);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 3:\r\n\t\t\tmsgW = ToWcharU8(msg);\r\n\t\t\tif (msgW) {\r\n\t\t\t\tNotifySetIconID(pvar->cv, hInst, pvar->settings.IconID);\r\n\t\t\t\tNotifyInfoMessageW(pvar->cv, msgW, L\"Authentication Banner\");\r\n\t\t\t\tNotifySetIconID(pvar->cv, NULL, 0);\r\n\t\t\t\tfree(msgW);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tlogprintf(LOG_LEVEL_NOTICE, \"Banner len: %d, Banner message: %s.\", msglen, msg);\r\n\t}\r\n\telse {\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"Empty banner\");\r\n\t}\r\n\r\n\tif (!get_string_from_payload(pvar, buff, sizeof(buff), &ltaglen, TRUE)) {\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: langtag payload corrupted.\", __FUNCTION__);\r\n\t\treturn TRUE;\r\n\t}\r\n\r\n\tif (ltaglen > 0) {\r\n\t\tlogprintf(LOG_LEVEL_NOTICE, \"Banner ltag len: %d, Banner Language Tag: %s\", ltaglen, buff);\r\n\t}\r\n\telse {\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"Empty Language Tag\");\r\n\t}\r\n\r\n\tif (new_payload_buffer) {\r\n\t\tpvar->ssh_state.payload = new_payload_buffer;\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n\r\n// SSH2 \ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW 60 \ufffd\u0502\u030f\ufffd\ufffd\ufffd\ufffd\u0590\ufffd\r\n//\r\n// SSH2 \ufffd\u0142\u0348\u0209\ufffd\ufffd\u0303\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd\ufffd 60 \ufffd\u0502\u058fd\ufffd\ufffd\ufffd\ufffd\ufffd\u010a\ufffd\ufffd\u84d6\ufffd\u0102\ufffd\ufffd\u0102\ufffd\ufffd\ufffdB\r\n//\r\n// * SSH2_MSG_USERAUTH_INFO_REQUEST (keyboard-interactive)\r\n// * SSH2_MSG_USERAUTH_PK_OK (publickey / Tera Term \ufffd\u0142\ufffd Pageant \ufffdF\ufffd\u0602\u0302\ufffd)\r\n// * SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ (password)\r\n//\r\n// \ufffd\ufffd\ufffd\ufffd\u030e\ufffd\ufffd\ufffd\ufffd\u0142\u0353\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd\u050d\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0742\u0142\ufffd\ufffd\u0202\ufffd\ufffd\u0302\u0141A\r\n// 60 \ufffd\u0502\u0342\ufffd\ufffd\u030a\u0590\ufffd\ufffd\u014e\udaca\udfc1Amethod \ufffd\u0242\ufffd\ufffd\ufffd\u0111\u0389\ufffd\ufffd\ufffd\ufffd\ufffdn\ufffd\ufffd\ufffdh\ufffd\ufffd\ufffd\u0590\ufffd\ufffd\u0250U\ufffd\u856a\ufffd\ufffd\ufffd\ufffdB\r\n//\r\nBOOL handle_SSH2_userauth_msg60(PTInstVar pvar)\r\n{\r\n\tif (pvar->auth_state.cur_cred.method == SSH_AUTH_TIS) {\r\n\t\treturn handle_SSH2_userauth_inforeq(pvar);\r\n\t}\r\n\telse if (pvar->auth_state.cur_cred.method == SSH_AUTH_PAGEANT) {\r\n\t\treturn handle_SSH2_userauth_pkok(pvar);\r\n\t}\r\n\telse if (pvar->auth_state.cur_cred.method == SSH_AUTH_PASSWORD) {\r\n\t\treturn handle_SSH2_userauth_passwd_changereq(pvar);\r\n\t}\r\n\telse {\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\treturn TRUE; // not reached\r\n}\r\n\r\nBOOL handle_SSH2_userauth_inforeq(PTInstVar pvar)\r\n{\r\n\t// SSH2_MSG_USERAUTH_INFO_REQUEST\r\n\tint len;\r\n\tchar *data;\r\n\tint slen = 0, num, echo;\r\n\tchar *s, *prompt = NULL;\r\n\tbuffer_t *msg;\r\n\tunsigned char *outmsg;\r\n\tint i;\r\n\tchar *name, *inst, *lang;\r\n\tchar lprompt[512];\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_USERAUTH_INFO_REQUEST was received.\");\r\n\r\n\t// 6byte\ufffdi\ufffdT\ufffdC\ufffdY\ufffd{\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd{\ufffd^\ufffdC\ufffdv\ufffdj\ufffd\ufffd\ufffd\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffd\u020d~\ufffd\u0303y\ufffdC\ufffd\ufffd\ufffd[\ufffdh\r\n\tdata = pvar->ssh_state.payload;\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY - (\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffdT\ufffdC\ufffdY+1)\ufffdG\ufffd^\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY\r\n\tlen = pvar->ssh_state.payloadlen;\r\n\r\n\t//debug_print(10, data, len);\r\n\r\n\t///////// step1\r\n\t// get string\r\n\tname = buffer_get_string(&data, NULL);\r\n\tinst = buffer_get_string(&data, NULL);\r\n\tlang = buffer_get_string(&data, NULL);\r\n\tlprompt[0] = 0;\r\n\tif (inst == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_get_string returns NULL. (inst)\", __FUNCTION__);\r\n\t}\r\n\telse if (strlen(inst) > 0) {\r\n\t\tstrncat_s(lprompt, sizeof(lprompt), inst, _TRUNCATE);\r\n\t\tstrncat_s(lprompt, sizeof(lprompt), \"\\r\\n\", _TRUNCATE);\r\n\t}\r\n\tif (lang == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_get_string returns NULL. (lang)\", __FUNCTION__);\r\n\t}\r\n\telse if (strlen(lang) > 0) {\r\n\t\tstrncat_s(lprompt, sizeof(lprompt), lang, _TRUNCATE);\r\n\t\tstrncat_s(lprompt, sizeof(lprompt), \"\\r\\n\", _TRUNCATE);\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: user=%s, inst=%s, lang=%s\", __FUNCTION__,\r\n\t\tNonNull(name), NonNull(inst), NonNull(lang));\r\n\r\n\tfree(name);\r\n\tfree(inst);\r\n\tfree(lang);\r\n\r\n\t// num-prompts\r\n\tnum = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: prompts=%d\", __FUNCTION__, num);\r\n\r\n\t///////// step2\r\n\t// \ufffdT\ufffd[\ufffdo\ufffd\u0583p\ufffdX\ufffdt\ufffd\ufffd\ufffd[\ufffdY\ufffd\ud805\uddc2\ufffd\r\n\tmsg = buffer_init();\r\n\tif (msg == NULL) {\r\n\t\t// TODO: error check\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\treturn FALSE;\r\n\t}\r\n\tbuffer_put_int(msg, num);\r\n\r\n\t// \ufffdp\ufffdX\ufffd\ufffd\ufffd[\ufffdh\ufffd\u03cdX\ufffd\u030f\ua347\ufffdA\ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0381A\ufffd\\\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB(2010.11.11 yutaka)\r\n\tif (num == 0) {\r\n\t\tif (strlen(lprompt) > 0)\r\n\t\t\tMessageBox(pvar->cv->HWin, lprompt, \"USERAUTH INFO_REQUEST\", MB_OK | MB_ICONINFORMATION);\r\n\t}\r\n\r\n\t// \ufffdv\ufffd\ufffd\ufffd\ufffd\ufffdv\ufffdg\ufffd\u0310\ufffd\ufffd\ufffd\ufffd\ufffd prompt & echo \ufffd\ufffd\ufffdJ\ufffd\ufffd\u0502\ufffd\ufffd\ufffd\ufffdB\r\n\tfor (i = 0 ; i < num ; i++) {\r\n\t\t// get string\r\n\t\tslen = get_uint32_MSBfirst(data);\r\n\t\tdata += 4;\r\n\t\tprompt = data;  // prompt\r\n\t\tdata += slen;\r\n\r\n\t\t// get boolean\r\n\t\techo = data[0];\r\n\t\tdata[0] = '\\0'; // \ufffd\ufffd\ufffdO\ufffdo\ufffd\u0342\u0308\u05c1A\ufffd\ua39e\ufffdI\ufffd\ufffd NUL Terminate \ufffd\ufffd\ufffd\ufffd\r\n\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s:   prompt[%d]=\\\"%s\\\", echo=%d, pass-state=%d\", __FUNCTION__,\r\n\t\t\ti, prompt, slen, pvar->keyboard_interactive_password_input);\r\n\r\n\t\tdata[0] = echo; // \ufffd\ufffd\ufffdO\ufffdo\ufffd\u0342\ufffd\ufffds\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0141A\ufffd\ufffd\ufffd\u0312l\ufffd\u024f\ufffd\ufffd\ufffd\ufffd\u07c2\ufffd\r\n\t\tdata += 1;\r\n\r\n\t\t// keyboard-interactive method (2005.3.12 yutaka)\r\n\t\tif (pvar->keyboard_interactive_password_input == 0 &&\r\n\t\t\tpvar->auth_state.cur_cred.method == SSH_AUTH_TIS) {\r\n\t\t\tAUTH_set_TIS_mode(pvar, prompt, slen, echo);\r\n\t\t\tAUTH_advance_to_next_cred(pvar);\r\n\t\t\tpvar->ssh_state.status_flags &= ~STATUS_DONT_SEND_CREDENTIALS;\r\n\t\t\t//try_send_credentials(pvar);\r\n\t\t\tbuffer_free(msg);\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\r\n\t\t// TODO: \ufffd\ufffd\ufffd\ufffd\ufffd\u0143v\ufffd\ufffd\ufffd\ufffd\ufffdv\ufffdg\ufffd\ufffd\\\ufffd\ufffd\ufffd\ufffd\ufffd\u0103\ufffd\ufffd[\ufffdU\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0342\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\ts = pvar->auth_state.cur_cred.password;\r\n\t\tbuffer_put_string(msg, s, strlen(s));\r\n\r\n\t\t// \ufffd\ufffd\ufffdg\ufffd\ufffd\ufffdC\ufffd\u0251\u0389\ufffd\ufffd\u0142\ufffd\ufffd\ufffd\u60a4\ufffdA\ufffdt\ufffd\ufffd\ufffdO\ufffd\ufffd\ufffdN\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffd\ufffdB(2010.11.11 yutaka)\r\n\t\tpvar->keyboard_interactive_password_input = 0;\r\n\t}\r\n\r\n\tlen = buffer_len(msg);\r\n\toutmsg = begin_send_packet(pvar, SSH2_MSG_USERAUTH_INFO_RESPONSE, len);\r\n\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\tfinish_send_packet(pvar);\r\n\tbuffer_free(msg);\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: sending SSH2_MSG_USERAUTH_INFO_RESPONSE.\", __FUNCTION__);\r\n\treturn TRUE;\r\n}\r\n\r\nBOOL handle_SSH2_userauth_pkok(PTInstVar pvar)\r\n{\r\n\t\t// SSH2_MSG_USERAUTH_PK_OK\r\n\t\tbuffer_t *msg = NULL;\r\n\t\tchar *s, *username;\r\n\t\tunsigned char *outmsg;\r\n\t\tint len;\r\n\t\tchar *connect_id = \"ssh-connection\";\r\n\r\n\t\tunsigned char *puttykey;\r\n\t\tbuffer_t *signbuf;\r\n\t\tunsigned char *signedmsg;\r\n\t\tint signedlen;\r\n\r\n\t\tunsigned char *keytype_name, *keyalgo_name;\r\n\t\tssh_keytype keytype;\r\n\t\tssh_keyalgo keyalgo;\r\n\t\tssh_agentflag signflag;\r\n\r\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_USERAUTH_PK_OK was received.\");\r\n\r\n\t\tusername = pvar->auth_state.user;  // \ufffd\ufffd\ufffd[\ufffdU\ufffd\ufffd\r\n\r\n\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdf\ufffd[\ufffd^\ufffd\ufffd\ufffd\uc42c\r\n\t\tsignbuf = buffer_init();\r\n\t\tif (signbuf == NULL) {\r\n\t\t\tsafefree(pvar->pageant_key);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\tbuffer_append_length(signbuf, pvar->session_id, pvar->session_id_len);\r\n\t\tbuffer_put_char(signbuf, SSH2_MSG_USERAUTH_REQUEST);\r\n\t\ts = username;  // \ufffd\ufffd\ufffd[\ufffdU\ufffd\ufffd\r\n\t\tbuffer_put_string(signbuf, s, strlen(s));\r\n\t\ts = connect_id;\r\n\t\tbuffer_put_string(signbuf, s, strlen(s));\r\n\t\ts = \"publickey\";\r\n\t\tbuffer_put_string(signbuf, s, strlen(s));\r\n\t\tbuffer_put_char(signbuf, 1); // true\r\n\r\n\t\tputtykey = pvar->pageant_curkey;\r\n\r\n\t\t// \ufffd\ufffd\ufffd\ufffd\u0282\ufffd\ufffd\u75d8\ufffdp\ufffd\ufffd\ufffd\u93d0\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u80b7\ufffd\ufffd\r\n\t\tlen = get_uint32_MSBfirst(puttykey+4);\r\n\t\tkeytype_name = puttykey + 8;\r\n\t\tkeytype = get_hostkey_type_from_name(keytype_name);\r\n\t\tkeyalgo = choose_SSH2_keysign_algorithm(pvar, keytype);\r\n\t\tkeyalgo_name = get_ssh2_hostkey_algorithm_name(keyalgo);\r\n\t\tsignflag = get_ssh2_agent_flag(keyalgo);\r\n\r\n\t\t// \ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd\ufffd\ufffd\ufffdR\ufffds\ufffd[\ufffd\ufffd\ufffd\ufffd\r\n\t\tlen = strlen(keyalgo_name);\r\n\t\tbuffer_put_string(signbuf, keyalgo_name, len);\r\n\r\n\t\t// \ufffd\ufffd\ufffd\ufffd\ufffdR\ufffds\ufffd[\ufffd\ufffd\ufffd\ufffd\r\n\t\tlen = get_uint32_MSBfirst(puttykey);\r\n\t\tputtykey += 4;\r\n\t\tbuffer_put_string(signbuf, puttykey, len);\r\n\t\tputtykey += len;\r\n\r\n\t\t// Pageant \ufffd\u024f\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u70a4\r\n\t\tsignedmsg = putty_sign_ssh2_key(pvar->pageant_curkey,\r\n\t\t                                signbuf->buf, signbuf->len,\r\n\t\t                                &signedlen, signflag);\r\n\t\tbuffer_free(signbuf);\r\n\t\tif (signedmsg == NULL) {\r\n\t\t\tsafefree(pvar->pageant_key);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\r\n\r\n\t\t// \ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\u030d\\\ufffdz\r\n\t\tmsg = buffer_init();\r\n\t\tif (msg == NULL) {\r\n\t\t\tsafefree(pvar->pageant_key);\r\n\t\t\tsafefree(signedmsg);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\ts = username;  // \ufffd\ufffd\ufffd[\ufffdU\ufffd\ufffd\r\n\t\tbuffer_put_string(msg, s, strlen(s));\r\n\t\ts = connect_id;\r\n\t\tbuffer_put_string(msg, s, strlen(s));\r\n\t\ts = \"publickey\";\r\n\t\tbuffer_put_string(msg, s, strlen(s));\r\n\t\tbuffer_put_char(msg, 1); // true\r\n\r\n\t\tputtykey = pvar->pageant_curkey;\r\n\r\n\t\t// \ufffdA\ufffd\ufffd\ufffdS\ufffd\ufffd\ufffdY\ufffd\ufffd\ufffd\ufffd\ufffdR\ufffds\ufffd[\ufffd\ufffd\ufffd\ufffd\r\n\t\tlen = strlen(keyalgo_name);\r\n\t\tbuffer_put_string(msg, keyalgo_name, len);\r\n\r\n\t\t// \ufffd\ufffd\ufffd\ufffd\ufffdR\ufffds\ufffd[\ufffd\ufffd\ufffd\ufffd\r\n\t\tlen = get_uint32_MSBfirst(puttykey);\r\n\t\tputtykey += 4;\r\n\t\tbuffer_put_string(msg, puttykey, len);\r\n\t\tputtykey += len;\r\n\r\n\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ua0bd\ufffdf\ufffd[\ufffd^\r\n\t\tlen  = get_uint32_MSBfirst(signedmsg);\r\n\t\tbuffer_put_string(msg, signedmsg + 4, len);\r\n\t\tfree(signedmsg);\r\n\r\n\t\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffdM\r\n\t\tlen = buffer_len(msg);\r\n\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_USERAUTH_REQUEST, len);\r\n\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\tfinish_send_packet(pvar);\r\n\t\tbuffer_free(msg);\r\n\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: sending SSH2_MSG_USERAUTH_REQUEST method=publickey\", __FUNCTION__);\r\n\r\n\t\tpvar->pageant_keyfinal = TRUE;\r\n\r\n\t\treturn TRUE;\r\n\t}\r\n\r\n#define PASSWD_MAXLEN 150\r\n\r\nstruct change_password {\r\n\tPTInstVar pvar;\r\n\tchar passwd[PASSWD_MAXLEN];\r\n\tchar new_passwd[PASSWD_MAXLEN];\r\n};\r\n\r\nstatic INT_PTR CALLBACK passwd_change_dialog(HWND dlg, UINT msg, WPARAM wParam, LPARAM lParam)\r\n{\r\n\tchar old_passwd[PASSWD_MAXLEN];\r\n\tchar new_passwd[PASSWD_MAXLEN];\r\n\tchar retype_passwd[PASSWD_MAXLEN];\r\n\tstatic struct change_password *cp;\r\n\tchar uimsg[MAX_UIMSG];\r\n\tstatic PTInstVar pvar;\r\n\r\n\tswitch (msg) {\r\n\tcase WM_INITDIALOG:\r\n\t\tcp = (struct change_password *)lParam;\r\n\t\tpvar = cp->pvar;\r\n\r\n\t\tGetWindowText(dlg, uimsg, sizeof(uimsg));\r\n\t\tUTIL_get_lang_msg(\"DLG_PASSCHG_TITLE\", pvar, uimsg);\r\n\t\tSetWindowText(dlg, pvar->UIMsg);\r\n\r\n\t\tGetDlgItemText(dlg, IDC_PASSWD_CHANGEREQ_MSG, uimsg, sizeof(uimsg));\r\n\t\tUTIL_get_lang_msg(\"DLG_PASSCHG_MESSAGE\", pvar, uimsg);\r\n\t\tSetDlgItemText(dlg, IDC_PASSWD_CHANGEREQ_MSG, pvar->UIMsg);\r\n\r\n\t\tGetDlgItemText(dlg, IDC_OLD_PASSWD_LABEL, uimsg, sizeof(uimsg));\r\n\t\tUTIL_get_lang_msg(\"DLG_PASSCHG_OLDPASSWD\", pvar, uimsg);\r\n\t\tSetDlgItemText(dlg, IDC_OLD_PASSWD_LABEL, pvar->UIMsg);\r\n\r\n\t\tGetDlgItemText(dlg, IDC_NEW_PASSWD_LABEL, uimsg, sizeof(uimsg));\r\n\t\tUTIL_get_lang_msg(\"DLG_PASSCHG_NEWPASSWD\", pvar, uimsg);\r\n\t\tSetDlgItemText(dlg, IDC_NEW_PASSWD_LABEL, pvar->UIMsg);\r\n\r\n\t\tGetDlgItemText(dlg, IDC_CONFIRM_PASSWD_LABEL, uimsg, sizeof(uimsg));\r\n\t\tUTIL_get_lang_msg(\"DLG_PASSCHG_CONFIRMPASSWD\", pvar, uimsg);\r\n\t\tSetDlgItemText(dlg, IDC_CONFIRM_PASSWD_LABEL, pvar->UIMsg);\r\n\r\n\t\tSetFocus(GetDlgItem(dlg, IDC_OLD_PASSWD));\r\n\r\n\t\tCenterWindow(dlg, GetParent(dlg));\r\n\r\n\t\treturn FALSE;\r\n\r\n\tcase WM_COMMAND:\r\n\t\tswitch (LOWORD(wParam)) {\r\n\t\tcase IDOK:\r\n\t\t\tSendMessage(GetDlgItem(dlg, IDC_OLD_PASSWD), WM_GETTEXT , sizeof(old_passwd), (LPARAM)old_passwd);\r\n\t\t\tSendMessage(GetDlgItem(dlg, IDC_NEW_PASSWD), WM_GETTEXT , sizeof(new_passwd), (LPARAM)new_passwd);\r\n\t\t\tSendMessage(GetDlgItem(dlg, IDC_CONFIRM_PASSWD), WM_GETTEXT , sizeof(retype_passwd), (LPARAM)retype_passwd);\r\n\r\n\t\t\tif (strcmp(new_passwd, retype_passwd) == 1) {\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_PASSCHG_MISMATCH\", pvar, \"Mismatch; try again.\");\r\n\t\t\t\tMessageBox(NULL, pvar->UIMsg, \"ERROR\", MB_OK | MB_ICONEXCLAMATION);\r\n\t\t\t\treturn FALSE;\r\n\t\t\t}\r\n\r\n\t\t\tif (new_passwd[0] == 0) {\r\n\t\t\t\t// \ufffd_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffd\ufffd\ufffdJ\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffd\ufffd Return \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0702\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0311\u038d\ufffd\u0308\u05c1A\r\n\t\t\t\t// \ufffd\u0182\u80a0\ufffd\ufffd\ufffd\ufffd\ufffdV\ufffdp\ufffdX\ufffd\ufffd\ufffd[\ufffdh\ufffd\ufffd\ufffd\ufffd\u030f\ua347\ufffd\ufffd\ufffd\u0342\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffdB\r\n\t\t\t\t// c.f. Ticket: #38970\r\n\t\t\t\treturn FALSE;\r\n\t\t\t}\r\n\r\n\t\t\tstrncpy_s(cp->passwd, sizeof(cp->passwd), old_passwd, _TRUNCATE);\r\n\t\t\tstrncpy_s(cp->new_passwd, sizeof(cp->new_passwd), new_passwd, _TRUNCATE);\r\n\r\n\t\t\tEndDialog(dlg, 1); // dialog close\r\n\t\t\treturn TRUE;\r\n\r\n\t\tcase IDCANCEL:\r\n\t\t\t// \ufffd\u0691\ufffd\ufffd\ufffd\u0602\ufffd\r\n\t\t\tnotify_closed_connection(pvar, \"authentication cancelled\");\r\n\t\t\tEndDialog(dlg, 0); // dialog close\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t}\r\n\r\n\treturn FALSE;\r\n}\r\n\r\nBOOL handle_SSH2_userauth_passwd_changereq(PTInstVar pvar)\r\n{\r\n\tint len;\r\n\tINT_PTR ret;\r\n\tchar *data;\r\n\tbuffer_t *msg = NULL;\r\n\tchar *s, *username;\r\n\tunsigned char *outmsg;\r\n\tchar *connect_id = \"ssh-connection\";\r\n\tchar *info, *lang;\r\n\tstruct change_password cp;\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ was received.\");\r\n\r\n\tmemset(&cp, 0, sizeof(cp));\r\n\tcp.pvar = pvar;\r\n\tret = DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_SSHPASSWD_INPUT), pvar->cv->HWin, passwd_change_dialog, (LPARAM)&cp);\r\n\r\n\tif (ret == -1) {\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: DialogBoxParam failed.\", __FUNCTION__);\r\n\t\treturn FALSE;\r\n\t}\r\n\telse if (ret == 0) {\r\n\t\tlogprintf(LOG_LEVEL_NOTICE, \"%s: dialog cancelled.\", __FUNCTION__);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\t// 6byte\ufffdi\ufffdT\ufffdC\ufffdY\ufffd{\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd{\ufffd^\ufffdC\ufffdv\ufffdj\ufffd\ufffd\ufffd\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffd\u020d~\ufffd\u0303y\ufffdC\ufffd\ufffd\ufffd[\ufffdh\r\n\tdata = pvar->ssh_state.payload;\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY - (\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffdT\ufffdC\ufffdY+1)\ufffdG\ufffd^\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY\r\n\tlen = pvar->ssh_state.payloadlen;\r\n\r\n\tinfo = buffer_get_string(&data, NULL);\r\n\tlang = buffer_get_string(&data, NULL);\r\n\tif (info == NULL || lang == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR,\r\n\t\t\t\"%s: buffer_get_string returns NULL. info=%s, lang=%s\", __FUNCTION__,\r\n\t\t\tNonNull(info), NonNull(lang));\r\n\t}\r\n\telse {\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: info=%s, lang=%s\\n\", __FUNCTION__, info, lang);\r\n\t}\r\n\tfree(info);\r\n\tfree(lang);\r\n\r\n\tmsg = buffer_init();\r\n\tif (msg == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\t// \ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\u030d\\\ufffdz\r\n\tusername = pvar->auth_state.user;  // \ufffd\ufffd\ufffd[\ufffdU\ufffd\ufffd\r\n\tbuffer_put_string(msg, username, strlen(username));\r\n\r\n\t// password authentication method\r\n\ts = connect_id;\r\n\tbuffer_put_string(msg, s, strlen(s));\r\n\ts = \"password\";\r\n\tbuffer_put_string(msg, s, strlen(s));\r\n\r\n\tbuffer_put_char(msg, 1); // additional info\r\n\r\n\ts = cp.passwd;\r\n\tbuffer_put_string(msg, s, strlen(s));\r\n\r\n\ts = cp.new_passwd;\r\n\tbuffer_put_string(msg, s, strlen(s));\r\n\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffd\ufffd\ufffdM\r\n\tlen = buffer_len(msg);\r\n\toutmsg = begin_send_packet(pvar, SSH2_MSG_USERAUTH_REQUEST, len);\r\n\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\tfinish_send_packet(pvar);\r\n\tbuffer_free(msg);\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n/*\r\n * SSH_MSG_CHANNEL_REQUEST \ufffd\ufffd\ufffdM\ufffd\u0590\ufffd\r\n * type-specific data \ufffd\ufffd string \ufffd\ufffd 0 \ufffd` 2 \ufffd\u0315\ufffd\ufffd\u0251\u0389\ufffd\ufffdB\r\n * \ufffdg\ufffdp\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd\ufffd NULL \ufffd\u0242\ufffd\ufffd\ufffdB\r\n * type-specific data \ufffd\ufffd\ufffd\ufffd\ufffd\u030c`\ufffd\ufffd\ufffd\u0242\u0351\u0389\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0202\ufffd\ufffd\u0302\u0141A\ufffd\ufffd\ufffdO\ufffd\u0151\ufffd\ufffd\u9396\ufffdB\r\n */\r\nstatic BOOL send_channel_request_gen(PTInstVar pvar, Channel_t *c, unsigned char *req, int want_reply, unsigned char *msg1, unsigned char *msg2)\r\n{\r\n\tbuffer_t *msg;\r\n\tunsigned char *outmsg;\r\n\tint len;\r\n\r\n\tmsg = buffer_init();\r\n\tif (msg == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\treturn FALSE;\r\n\t}\r\n\tif (c->remote_id == SSH_CHANNEL_INVALID) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: invalid remote channel number (%d).\", __FUNCTION__, c->remote_id);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tbuffer_put_int(msg, c->remote_id);\r\n\tbuffer_put_string(msg, req, strlen(req));\r\n\r\n\tbuffer_put_char(msg, want_reply);\r\n\r\n\tif (msg1) {\r\n\t\tbuffer_put_string(msg, msg1, strlen(msg1));\r\n\t}\r\n\tif (msg2) {\r\n\t\tbuffer_put_string(msg, msg1, strlen(msg1));\r\n\t}\r\n\r\n\tlen = buffer_len(msg);\r\n\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_REQUEST, len);\r\n\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\tfinish_send_packet(pvar);\r\n\tbuffer_free(msg);\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: sending SSH2_MSG_CHANNEL_REQUEST. \"\r\n\t          \"local: %d, remote: %d, request-type: %s, msg1=%s, msg2=%s\", __FUNCTION__,\r\n\t          c->self_id, c->remote_id, req, msg1 ? msg1 : \"none\", msg2 ? msg2 : \"none\");\r\n\treturn TRUE;\r\n}\r\n\r\nBOOL send_pty_request(PTInstVar pvar, Channel_t *c)\r\n{\r\n\tbuffer_t *msg, *ttymsg;\r\n\tchar *req_type = \"pty-req\";  // pseudo terminal\ufffd\u0303\ufffd\ufffdN\ufffdG\ufffdX\ufffdg\r\n\tunsigned char *outmsg;\r\n\tint len, x, y;\r\n#ifdef DONT_WANTCONFIRM\r\n\tint want_reply = 0; // false\r\n#else\r\n\tint want_reply = 1; // true\r\n#endif\r\n\r\n\t// pty open\r\n\tmsg = buffer_init();\r\n\tif (msg == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL. (msg)\", __FUNCTION__);\r\n\t\treturn FALSE;\r\n\t}\r\n\tttymsg = buffer_init();\r\n\tif (ttymsg == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL. (ttymsg)\", __FUNCTION__);\r\n\t\tbuffer_free(msg);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tbuffer_put_int(msg, c->remote_id);\r\n\tbuffer_put_string(msg, req_type, strlen(req_type));\r\n\tbuffer_put_char(msg, want_reply);  // want_reply (disable\ufffd\u0255\u03cdX 2005/3/28 yutaka)\r\n\r\n\tbuffer_put_string(msg, pvar->ts->TermType, strlen(pvar->ts->TermType));\r\n\tbuffer_put_int(msg, pvar->ssh_state.win_cols);  // columns\r\n\tbuffer_put_int(msg, pvar->ssh_state.win_rows);  // lines\r\n\tget_window_pixel_size(pvar, &x, &y);\r\n\tbuffer_put_int(msg, x);  // window width (pixel):\r\n\tbuffer_put_int(msg, y);  // window height (pixel):\r\n\r\n\t// TTY mode\ufffd\u0342\ufffd\ufffd\ufffd\ufffd\u0153n\ufffd\ufffd (2005.7.17 yutaka)\r\n\tbuffer_put_char(ttymsg, SSH2_TTY_OP_OSPEED);\r\n\tbuffer_put_int(ttymsg, pvar->ts->TerminalOutputSpeed);  // baud rate\r\n\tbuffer_put_char(ttymsg, SSH2_TTY_OP_ISPEED);\r\n\tbuffer_put_int(ttymsg, pvar->ts->TerminalInputSpeed);  // baud rate\r\n\r\n\t// VERASE\r\n\tbuffer_put_char(ttymsg, SSH2_TTY_KEY_VERASE);\r\n\tif (pvar->ts->BSKey == IdBS) {\r\n\t\tbuffer_put_int(ttymsg, 0x08); // BS key\r\n\t} else {\r\n\t\tbuffer_put_int(ttymsg, 0x7F); // DEL key\r\n\t}\r\n\r\n\tswitch (pvar->ts->CRReceive) {\r\n\t  case IdLF:\r\n\t\tbuffer_put_char(ttymsg, SSH2_TTY_OP_ONLCR);\r\n\t\tbuffer_put_int(ttymsg, 0);\r\n\t\tbreak;\r\n\t  case IdCR:\r\n\t\tbuffer_put_char(ttymsg, SSH2_TTY_OP_ONLCR);\r\n\t\tbuffer_put_int(ttymsg, 1);\r\n\t\tbreak;\r\n\t  default:\r\n\t\tbreak;\r\n\t}\r\n\r\n\tbuffer_put_char(ttymsg, SSH2_TTY_OP_END); // End of terminal modes\r\n\r\n\t// SSH2\ufffd\u0142\u0355\ufffd\ufffd\ufffd\ufffd\ufffd\u0182\ufffd\ufffd\u010f\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0781B\r\n\tbuffer_put_string(msg, buffer_ptr(ttymsg), buffer_len(ttymsg));\r\n\r\n\tlen = buffer_len(msg);\r\n\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_REQUEST, len);\r\n\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\tfinish_send_packet(pvar);\r\n\tbuffer_free(msg);\r\n\tbuffer_free(ttymsg);\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: sending SSH2_MSG_CHANNEL_REQUEST. \"\r\n\t          \"local: %d, remote: %d, request-type: %s, \"\r\n\t          \"term: %s, cols: %d, rows: %d, x: %d, y: %d, \"\r\n\t          \"out-speed: %d, in-speed: %d, verase: %s, onlcr: %s\", __FUNCTION__,\r\n\t          c->self_id, c->remote_id, req_type, pvar->ts->TermType,\r\n\t          pvar->ssh_state.win_cols, pvar->ssh_state.win_rows, x, y,\r\n\t          pvar->ts->TerminalOutputSpeed, pvar->ts->TerminalInputSpeed,\r\n\t          (pvar->ts->BSKey==IdBS)?\"^h\":\"^?\", (pvar->ts->CRReceive==IdBS)?\"on\":\"off\");\r\n\r\n\tpvar->session_nego_status = 2;\r\n\r\n\tif (want_reply == 0) {\r\n\t\thandle_SSH2_channel_success(pvar);\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_SSH2_open_confirm(PTInstVar pvar)\r\n{\r\n\tint len;\r\n\tchar *data;\r\n\tint id, remote_id;\r\n\tChannel_t *c;\r\n\tchar buff[MAX_PATH + 30];\r\n\r\n#ifdef DONT_WANTCONFIRM\r\n\tint want_reply = 0; // false\r\n#else\r\n\tint want_reply = 1; // true\r\n#endif\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_CHANNEL_OPEN_CONFIRMATION was received.\");\r\n\r\n\t// 6byte\ufffdi\ufffdT\ufffdC\ufffdY\ufffd{\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd{\ufffd^\ufffdC\ufffdv\ufffdj\ufffd\ufffd\ufffd\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffd\u020d~\ufffd\u0303y\ufffdC\ufffd\ufffd\ufffd[\ufffdh\r\n\tdata = pvar->ssh_state.payload;\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY - (\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffdT\ufffdC\ufffdY+1)\ufffdG\ufffd^\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY\r\n\tlen = pvar->ssh_state.payloadlen;\r\n\r\n\tid = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\r\n\tc = ssh2_channel_lookup(id);\r\n\tif (c == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: channel not found. (%d)\", __FUNCTION__, id);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tremote_id = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\r\n\tc->remote_id = remote_id;\r\n\tif (c->self_id == pvar->shell_id) {\r\n\t\t// \ufffd\u014f\ufffd\ufffd\u0303`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\u020aO\ufffd\u0143\ufffd\ufffdZ\ufffdb\ufffdg\ufffd\ufffd\ufffd\u0102\u0342\ufffd\ufffd\ufffd\ufffd\u0202\ufffd (2008.12.19 maya)\r\n\t\tpvar->session_nego_status = 1;\r\n\t}\r\n\r\n\t// remote window size\r\n\tc->remote_window = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\tc->remote_maxpacket = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\r\n\tswitch (c->type) {\r\n\tcase TYPE_PORTFWD:\r\n\t\t// port-forwading\ufffd\ufffd\"direct-tcpip\"\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\tFWD_confirmed_open(pvar, c->local_num, -1);\r\n\t\tbreak;\r\n\r\n\tcase TYPE_SHELL:\r\n\t\t// \ufffd|\ufffd[\ufffdg\ufffdt\ufffdH\ufffd\ufffd\ufffd[\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd\u030f\ufffd\ufffd\ufffd (2005.2.26, 2005.6.21 yutaka)\r\n\t\t// \ufffdV\ufffdF\ufffd\ufffd\ufffdI\ufffd[\ufffdv\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0182\ufffd X11 \ufffd\u0317v\ufffd\ufffd\ufffd\ufffd\ufffdo\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\u0102\u0342\u0202\ufffd\u0202\ufffd\ufffdB(2005.7.3 yutaka)\r\n\t\tFWD_prep_forwarding(pvar);\r\n\t\tFWD_enter_interactive_mode(pvar);\r\n\r\n\t\t// \ufffdG\ufffd[\ufffdW\ufffdF\ufffd\ufffd\ufffdg\ufffd]\ufffd\ufffd (2008.11.25 maya)\r\n\t\tif (pvar->session_settings.ForwardAgent) {\r\n\t\t\t// pty-req \ufffd\ufffd\ufffdO\ufffd\u0243\ufffd\ufffdN\ufffdG\ufffdX\ufffdg\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\u0183G\ufffd\ufffd\ufffd[\ufffd\u0242\u0202\ufffd\u0357l\r\n\t\t\treturn send_channel_request_gen(pvar, c, \"auth-agent-req@openssh.com\", 1, NULL, NULL);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn send_pty_request(pvar, c);\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase TYPE_SCP:\r\n\t\tif (c->scp.dir == TOREMOTE) {\r\n\t\t\t_snprintf_s(buff, sizeof(buff), _TRUNCATE, \"scp -t %s\", c->scp.remotefile);\r\n\r\n\t\t} else {\r\n\t\t\t// \ufffdt\ufffd@\ufffdC\ufffd\ufffd\ufffd\ufffd\ufffd\u024b\udb11\udc82\ufffd\ufffd\u0702\u0702\ufffd\u0102\ufffd\ufffd\u0102\ufffd\ufffd\u60a2\ufffd\u60a4\ufffd\u0241A\ufffdt\ufffd@\ufffdC\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdd\ufffd\ufffd\ufffdp\ufffd\ufffd\ufffd\u0148\u0342\u0781B\r\n\t\t\t// (2014.7.13 yutaka)\r\n\t\t\t_snprintf_s(buff, sizeof(buff), _TRUNCATE, \"scp -p -f \\\"%s\\\"\", c->scp.remotefile);\r\n\t\t}\r\n\r\n\t\tif (!send_channel_request_gen(pvar, c, \"exec\", want_reply, buff, NULL)) {\r\n\t\t\treturn FALSE;;\r\n\t\t}\r\n\r\n\t\t// SCP\ufffd\ufffd remote-to-local \ufffd\u030f\ua347\ufffd\u0341A\ufffdT\ufffd[\ufffdo\ufffd\ufffd\ufffd\ufffd\u0303t\ufffd@\ufffdC\ufffd\ufffd\ufffd\ufffd\ufffdM\ufffdv\ufffd\ufffd\ufffd\ufffd\ufffdo\ufffd\ufffd\ufffdB\r\n\t\t// \ufffd\ufffd\ufffd\u030e\ufffd\ufffd_\ufffd\u0142\ufffd remote window size \ufffd\ufffd\"0\"\ufffd\u0202\u0302\u0141A\ufffd\ufffd\ufffd\ufffd\ufffd\u0242\u0351\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffdA\ufffdx\ufffd\ufffd\ufffd\ufffd\ufffdM\ufffd\ufffd\ufffd\ufffd\ufffd\u0151\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\t// (2007.12.27 yutaka)\r\n\t\tif (c->scp.dir == FROMREMOTE) {\r\n\t\t\tchar ch = '\\0';\r\n\t\t\tSSH2_send_channel_data(pvar, c, &ch, 1, 0);\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase TYPE_SFTP:\r\n\t\tif (!send_channel_request_gen(pvar, c, \"subsystem\", want_reply, \"sftp\", NULL)) {\r\n\t\t\treturn FALSE;;\r\n\t\t}\r\n\r\n\t\t// SFTP\ufffdZ\ufffdb\ufffdV\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdJ\ufffdn\ufffd\ufffd\ufffd\u90bd\ufffd\u07c2\u0303l\ufffdS\ufffdV\ufffdG\ufffd[\ufffdV\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffds\ufffd\ufffd\ufffdB\r\n\t\t// (2012.5.3 yutaka)\r\n\t\tsftp_do_init(pvar, c);\r\n\t\tbreak;\r\n\r\n\tcase TYPE_SUBSYSTEM_GEN:\r\n\t\tif (!send_channel_request_gen(pvar, c, \"subsystem\", want_reply, pvar->subsystem_name, NULL)) {\r\n\t\t\treturn FALSE;;\r\n\t\t}\r\n\t\tpvar->session_nego_status = 0;\r\n\t\tbreak;\r\n\r\n\tdefault: // NOT REACHED\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: Invalid channel-type. (%d)\", __FUNCTION__, c->type);\r\n\t\treturn FALSE;\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\n// SSH2 port-forwarding \ufffd\u0242\ufffd\ufffd\ufffd\ufffd\u0103Z\ufffdb\ufffdV\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdI\ufffd[\ufffdv\ufffd\ufffd\ufffd\u0142\ufffd\ufffd\u0202\ufffd\ufffd\ua347\ufffd\u0303T\ufffd[\ufffdo\ufffd\ufffd\ufffd\ufffd\u0303\ufffd\ufffdv\ufffd\ufffd\ufffdC\ufffdi\ufffd\ufffd\ufffds\ufffdj\r\nstatic BOOL handle_SSH2_open_failure(PTInstVar pvar)\r\n{\r\n\tint len;\r\n\tchar *data;\r\n\tint id;\r\n\tChannel_t *c;\r\n\tint reason;\r\n\tchar *cstring;\r\n\tchar tmpbuf[256];\r\n\tchar *rmsg;\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_CHANNEL_OPEN_FAILURE was received.\");\r\n\r\n\t// 6byte\ufffdi\ufffdT\ufffdC\ufffdY\ufffd{\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd{\ufffd^\ufffdC\ufffdv\ufffdj\ufffd\ufffd\ufffd\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffd\u020d~\ufffd\u0303y\ufffdC\ufffd\ufffd\ufffd[\ufffdh\r\n\tdata = pvar->ssh_state.payload;\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY - (\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffdT\ufffdC\ufffdY+1)\ufffdG\ufffd^\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY\r\n\tlen = pvar->ssh_state.payloadlen;\r\n\r\n\tid = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\r\n\tc = ssh2_channel_lookup(id);\r\n\tif (c == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: channel not found. (%d)\", __FUNCTION__, id);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\treason = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\r\n\tif (reason == SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED) {\r\n\t\trmsg = \"administratively prohibited\";\r\n\t} else if (reason == SSH2_OPEN_CONNECT_FAILED) {\r\n\t\trmsg = \"connect failed\";\r\n\t} else if (reason == SSH2_OPEN_UNKNOWN_CHANNEL_TYPE) {\r\n\t\trmsg = \"unknown channel type\";\r\n\t} else if (reason == SSH2_OPEN_RESOURCE_SHORTAGE) {\r\n\t\trmsg = \"resource shortage\";\r\n\t} else {\r\n\t\trmsg = \"unknown reason\";\r\n\t}\r\n\r\n\tcstring = buffer_get_string(&data, NULL);\r\n\r\n\tif (cstring == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_get_string returns NULL\", __FUNCTION__);\r\n\t}\r\n\tUTIL_get_lang_msg(\"MSG_SSH_CHANNEL_OPEN_ERROR\", pvar,\r\n\t                  \"SSH2_MSG_CHANNEL_OPEN_FAILURE was received.\\r\\nchannel [%d]: reason: %s(%d) message: %s\");\r\n\t_snprintf_s(tmpbuf, sizeof(tmpbuf), _TRUNCATE, pvar->UIMsg,\r\n\t            id, rmsg, reason, NonNull(cstring));\r\n\tif ((pvar->settings.DisablePopupMessage & POPUP_MSG_FWD_channel_open) == 0) {\r\n\t\tnotify_nonfatal_error(pvar, tmpbuf);\r\n\t}\r\n\telse {\r\n\t\tlogputs(LOG_LEVEL_ERROR, tmpbuf);\r\n\t}\r\n\r\n\tfree(cstring);\r\n\r\n\tif (c->type == TYPE_PORTFWD) {\r\n\t\tFWD_failed_open(pvar, c->local_num, reason);\r\n\t}\r\n\r\n\t// \ufffd`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\u0309\ufffd\ufffd\ufffdR\ufffd\ufffd\ufffd\ufffdC\ufffd\ufffd (2007.5.1 maya)\r\n\tssh2_channel_delete(c);\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n// SSH2_MSG_GLOBAL_REQUEST for OpenSSH 6.8\r\nstatic BOOL handle_SSH2_client_global_request(PTInstVar pvar)\r\n{\r\n\tint len, n;\r\n\tchar *data;\r\n\tchar *rtype;\r\n\tint want_reply;\r\n\tint success = 0;\r\n\tbuffer_t *msg;\r\n\tunsigned char *outmsg;\r\n\tint type;\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_GLOBAL_REQUEST was received.\");\r\n\r\n\t// SSH2 packet format:\r\n\t// size(4) + padding size(1) + type(1) + payload(N) + padding(X)\r\n\t//                                       ^data\r\n\t//           <-----------------size---------------------------->\r\n\t//                             <--------len------->\r\n\t//\r\n\t// data: \ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd^\ufffdC\ufffdv\ufffd\u0251\ufffd\ufffd\ufffd\ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\u0310\u64ea\ufffd\ufffd\ufffdw\ufffd\ufffd\ufffd|\ufffdC\ufffd\ufffd\ufffd^\r\n\tdata = pvar->ssh_state.payload;\r\n\t// len = size - (padding size + sizeof(padding size)) = sizeof(type) + sizeof(payload):\r\n\t// \ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\ufffd\ufffd\ufffd\ufffd\u0312\ufffd\ufffd\ufffd\ufffdBtype \ufffd\ufffd\ufffd\ufffd\ufffd\u0702\ufffd\r\n\tlen = pvar->ssh_state.payloadlen;\r\n\r\n\tlen--;   // type \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\r\n\trtype = buffer_get_string(&data, &n);\r\n\tlen -= (n + 4);\r\n\r\n\twant_reply = data[0];\r\n\tdata++;\r\n\tlen--;\r\n\r\n\tif (rtype == NULL) {\r\n\t\t// rtype \ufffd\ufffd NULL \ufffd\u0156\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0315\u06cf\ufffd\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_get_string returns NULL.\", __FUNCTION__);\r\n\t}\r\n\telse if (strcmp(rtype, \"hostkeys-00@openssh.com\") == 0) {\r\n\t\t// OpenSSH 6.8\ufffd\u0142\u0341A\ufffdT\ufffd[\ufffdo\ufffd\u0303z\ufffdX\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffdX\ufffdV\ufffd\ufffd\ufffd\ufffd\ufffd\u0181A\ufffd\ufffd\ufffd\u0312\u0292m\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\t// OpenSSH 6.8\ufffd\u030e\ufffd\ufffd\ufffd\ufffd\u0142\u0341A\ufffd\ufffd\u0250\ufffd\ufffd\ufffd\ufffd\u0155\u0502\ufffd\ufffd\u60a4\ufffd\u0242\u0202\ufffd\ufffd\u0102\ufffd\ufffd\u90bd\ufffd\u07c1A\r\n\t\t// \ufffd\ufffd\ufffd\ufffd\u024d\ufffd\ufffd\ud0b9\ufffd\ufffd Tera Term \ufffd\u0142\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0195\u0502\ufffd\ufffd\ufffd\ufffd\u0182\u0242\ufffd\ufffd\ufffdB\r\n\t\tsuccess = update_client_input_hostkeys(pvar, data, len);\r\n\r\n\t}\r\n\tfree(rtype);\r\n\r\n\tif (want_reply) {\r\n\t\tmsg = buffer_init();\r\n\t\tif (msg) {\r\n\t\t\tlen = buffer_len(msg);\r\n\t\t\ttype = success ? SSH2_MSG_REQUEST_SUCCESS : SSH2_MSG_REQUEST_FAILURE;\r\n\t\t\toutmsg = begin_send_packet(pvar, type, len);\r\n\t\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\t\tfinish_send_packet(pvar);\r\n\t\t\tbuffer_free(msg);\r\n\t\t}\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n\r\n// SSH2 port-forwarding (remote -> local)\ufffd\u0251\u0382\ufffd\ufffd\u90ca\ufffdv\ufffd\ufffd\ufffdC\ufffdi\ufffd\ufffd\ufffd\ufffd\ufffdj\r\nstatic BOOL handle_SSH2_request_success(PTInstVar pvar)\r\n{\r\n\t// \ufffdK\ufffdv\ufffd\u0142\ufffd\ufffd\ufffd\u0383\ufffd\ufffdO\ufffd\ufffd\ufffd\ufffd\ufffdB\ufffd\ufffd\ufffd\u0249\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\u0102\ufffd\ufffd\u60a2\ufffdB\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_REQUEST_SUCCESS was received.\");\r\n\r\n\tclient_global_request_reply(pvar, SSH2_MSG_REQUEST_SUCCESS, 0, NULL);\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n// SSH2 port-forwarding (remote -> local)\ufffd\u0251\u0382\ufffd\ufffd\u90ca\ufffdv\ufffd\ufffd\ufffdC\ufffdi\ufffd\ufffd\ufffds\ufffdj\r\nstatic BOOL handle_SSH2_request_failure(PTInstVar pvar)\r\n{\r\n\t// \ufffdK\ufffdv\ufffd\u0142\ufffd\ufffd\ufffd\u0383\ufffd\ufffdO\ufffd\ufffd\ufffd\ufffd\ufffdB\ufffd\ufffd\ufffd\u0249\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\u0102\ufffd\ufffd\u60a2\ufffdB\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_REQUEST_FAILURE was received.\");\r\n\r\n\tclient_global_request_reply(pvar, SSH2_MSG_REQUEST_FAILURE, 0, NULL);\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_SSH2_channel_success(PTInstVar pvar)\r\n{\r\n\tChannel_t *c;\r\n#ifdef DONT_WANTCONFIRM\r\n\tint want_reply = 0; // false\r\n#else\r\n\tint want_reply = 1; // true\r\n#endif\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE,\r\n\t\t\"SSH2_MSG_CHANNEL_SUCCESS was received(nego_status %d).\",\r\n\t\tpvar->session_nego_status);\r\n\r\n\tif (pvar->session_nego_status == 1) {\r\n\t\tc = ssh2_channel_lookup(pvar->shell_id);\r\n\t\tif (c == NULL) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: shell channel not found.\", __FUNCTION__);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\tif (c->remote_id == SSH_CHANNEL_INVALID) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: remote shell channel number is unknown.\", __FUNCTION__);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\tpvar->agentfwd_enable = TRUE;\r\n\t\treturn send_pty_request(pvar, c);\r\n\r\n\t} else if (pvar->session_nego_status == 2) {\r\n\t\tpvar->session_nego_status = 3;\r\n\r\n\t\tc = ssh2_channel_lookup(pvar->shell_id);\r\n\t\tif (c == NULL) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: shell channel not found.\", __FUNCTION__);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\tif (c->remote_id == SSH_CHANNEL_INVALID) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: remote shell channel number is unknown.\", __FUNCTION__);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\r\n\t\tif (!send_channel_request_gen(pvar, c, \"shell\", want_reply, NULL, NULL)) {\r\n\t\t\treturn FALSE;;\r\n\t\t}\r\n\r\n\t\tif (want_reply == 0) {\r\n\t\t\thandle_SSH2_channel_success(pvar);\r\n\t\t}\r\n\r\n\t} else if (pvar->session_nego_status == 3) {\r\n\t\tpvar->session_nego_status = 4;\r\n\r\n\t} else {\r\n\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_SSH2_channel_failure(PTInstVar pvar)\r\n{\r\n\tChannel_t *c;\r\n\tchar *data;\r\n\tint channel_id;\r\n\r\n\tdata = pvar->ssh_state.payload;\r\n\tchannel_id = get_uint32_MSBfirst(data);\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_CHANNEL_FAILURE was received.\");\r\n\r\n\tc = ssh2_channel_lookup(channel_id);\r\n\tif (c == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: channel not found. (%d)\", __FUNCTION__, channel_id);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tif (pvar->shell_id == channel_id) {\r\n\t\tif (c->type == TYPE_SUBSYSTEM_GEN) {\r\n\t\t\t// \ufffdT\ufffdu\ufffdV\ufffdX\ufffde\ufffd\ufffd\ufffd\u030bN\ufffd\ufffd\ufffd\u024e\ufffd\ufffds\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0150\u0602\ufffdB\r\n\t\t\tchar errmsg[MAX_UIMSG];\r\n\t\t\tUTIL_get_lang_msg(\"MSG_SSH_SUBSYSTEM_REQUEST_ERROR\", pvar, \"subsystem request failed. (%s)\");\r\n\t\t\t_snprintf_s(errmsg, sizeof(errmsg), _TRUNCATE, pvar->UIMsg, pvar->subsystem_name);\r\n\t\t\tnotify_fatal_error(pvar, errmsg, TRUE);\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t\telse { // TYPE_SHELL\r\n\t\t\tif (pvar->session_nego_status == 1) {\r\n\t\t\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd[\ufffdg\ufffd\ufffd auth-agent-req@openssh.com \ufffd\ufffd\ufffdT\ufffd|\ufffd[\ufffdg\ufffd\ufffd\ufffd\ufffd\u0102\u0202\ufffd\ufffd\u0302\ufffd\r\n\t\t\t\t// \ufffdG\ufffd\ufffd\ufffd[\ufffd\u034bC\ufffd\u0242\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0590i\ufffd\ufffd\r\n\t\t\t\tlogputs(LOG_LEVEL_VERBOSE, \"auth-agent-req@openssh.com is not supported by remote host.\");\r\n\r\n\t\t\t\treturn send_pty_request(pvar, c);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tssh2_channel_delete(c);\r\n\treturn TRUE;\r\n}\r\n\r\n\r\n\r\n// \ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg\ufffd\ufffdwindow size\ufffd\ufffd\ufffdT\ufffd[\ufffdo\ufffd\u0592m\ufffd\u70b9\ufffd\ufffd\r\nstatic void do_SSH2_adjust_window_size(PTInstVar pvar, Channel_t *c)\r\n{\r\n\t// window size\ufffd\ufffd32KB\ufffd\u0595\u03cdX\ufffd\ufffd\ufffdAlocal window\ufffd\u0314\ufffd\ufffd\u0282\ufffd\ufffdC\ufffd\ufffd\ufffdB\r\n\t// \ufffd\ufffd\ufffd\ufffd\u0242\ufffd\ufffdSSH2\ufffd\u0303X\ufffd\ufffd\ufffd[\ufffdv\ufffdb\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\u30b7\ufffd\ufffdB(2006.3.6 yutaka)\r\n\tbuffer_t *msg;\r\n\tunsigned char *outmsg;\r\n\tint len;\r\n\r\n\t// \ufffd\ufffd\ufffd[\ufffdJ\ufffd\ufffd\ufffd\ufffdwindow size\ufffd\u0242\u0702\ufffd\ufffd]\ufffdT\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffdA\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t// added /2 (2006.3.6 yutaka)\r\n\tif (c->local_window > c->local_window_max/2)\r\n\t\treturn;\r\n\r\n\t{\r\n\t\t// pty open\r\n\t\tmsg = buffer_init();\r\n\t\tif (msg == NULL) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbuffer_put_int(msg, c->remote_id);\r\n\t\tbuffer_put_int(msg, c->local_window_max - c->local_window);\r\n\r\n\t\tlen = buffer_len(msg);\r\n\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_WINDOW_ADJUST, len);\r\n\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\tfinish_send_packet(pvar);\r\n\t\tbuffer_free(msg);\r\n\r\n\t\tlogputs(LOG_LEVEL_SSHDUMP, \"SSH2_MSG_CHANNEL_WINDOW_ADJUST was sent at do_SSH2_adjust_window_size().\");\r\n\t\t// \ufffdN\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg\ufffd\ufffdwindow size\ufffd\ud805\udf42\u20b7\r\n\t\tc->local_window = c->local_window_max;\r\n\t}\r\n\r\n}\r\n\r\n\r\nvoid ssh2_channel_send_close(PTInstVar pvar, Channel_t *c)\r\n{\r\n\tif (SSHv2(pvar)) {\r\n\t\tbuffer_t *msg;\r\n\t\tunsigned char *outmsg;\r\n\t\tint len;\r\n\r\n\t\t// \ufffd\ufffd\ufffd\ufffdchannel\ufffd\u0242\u0082\ufffd\ufffd\ufffdclose\ufffd\ud805\uddd0M\ufffd\u03c2\u0742\u0202\u7457\ufffd\ufffd\u0202\ufffd\r\n\t\tif (c->state & SSH_CHANNEL_STATE_CLOSE_SENT) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// SSH2 server\ufffd\ufffdchannel close\ufffd\ufffd`\ufffd\ufffd\ufffd\ufffd\r\n\t\tmsg = buffer_init();\r\n\t\tif (msg == NULL) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbuffer_put_int(msg, c->remote_id);\r\n\r\n\t\tlen = buffer_len(msg);\r\n\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_CLOSE, len);\r\n\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\tfinish_send_packet(pvar);\r\n\t\tbuffer_free(msg);\r\n\r\n\t\tc->state |= SSH_CHANNEL_STATE_CLOSE_SENT;\r\n\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"SSH2_MSG_CHANNEL_CLOSE was sent at ssh2_channel_send_close(). local:%d remote:%d\", c->self_id, c->remote_id);\r\n\t}\r\n}\r\n\r\n\r\n#define WM_SENDING_FILE (WM_USER + 1)\r\n#define WM_CHANNEL_CLOSE (WM_USER + 2)\r\n#define WM_GET_CLOSED_STATUS (WM_USER + 3)\r\n\r\ntypedef struct scp_dlg_parm {\r\n\tChannel_t *c;\r\n\tPTInstVar pvar;\r\n\tchar *buf;\r\n\tsize_t buflen;\r\n} scp_dlg_parm_t;\r\n\r\nstatic INT_PTR CALLBACK ssh_scp_dlg_proc(HWND hWnd, UINT msg, WPARAM wp, LPARAM lp)\r\n{\r\n\tstatic int closed = 0;\r\n\r\n\tswitch (msg) {\r\n\t\tcase WM_INITDIALOG:\r\n\t\t\tclosed = 0;\r\n\t\t\tCenterWindow(hWnd, GetParent(hWnd));\r\n\t\t\treturn FALSE;\r\n\r\n\t\t// SCP\ufffdt\ufffd@\ufffdC\ufffd\ufffd\ufffd\ufffdM(remote-to-local)\ufffd\ufffd\ufffdA\ufffdg\ufffdp\ufffd\ufffd\ufffd\ufffdB\r\n\t\tcase WM_CHANNEL_CLOSE:\r\n\t\t\t{\r\n\t\t\tscp_dlg_parm_t *parm = (scp_dlg_parm_t *)wp;\r\n\r\n\t\t\tssh2_channel_send_close(parm->pvar, parm->c);\r\n\t\t\t}\r\n\t\t\treturn TRUE;\r\n\t\t\tbreak;\r\n\r\n\t\tcase WM_SENDING_FILE:\r\n\t\t\t{\r\n\t\t\tscp_dlg_parm_t *parm = (scp_dlg_parm_t *)wp;\r\n\r\n\t\t\tSSH2_send_channel_data(parm->pvar, parm->c, parm->buf, parm->buflen, 0);\r\n\t\t\t}\r\n\t\t\treturn TRUE;\r\n\t\t\tbreak;\r\n\r\n\t\tcase WM_COMMAND:\r\n\t\t\tswitch (wp) {\r\n\t\t\t}\r\n\r\n\t\t\tswitch (LOWORD(wp)) {\r\n\t\t\t\tcase IDOK:\r\n\t\t\t\t\t{\r\n\t\t\t\t\treturn TRUE;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\tcase IDCANCEL:\r\n\t\t\t\t\t// \ufffdE\ufffdB\ufffd\ufffd\ufffdh\ufffdE\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffdj\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0142\u0342\u0202\ufffd\ufffdA\ufffd\ufffd\\\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\ufffd\u0302\u0742\u0182\ufffd\ufffd\u0101A\r\n\t\t\t\t\t// \ufffdX\ufffd\ufffd\ufffdb\ufffdh\ufffd\ufffd\ufffd\ufffd\u0303\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0142\ufffd\ufffd\ufffd\u60a4\ufffd\u0242\ufffd\ufffd\ufffdB\r\n\t\t\t\t\t// (2011.6.8 yutaka)\r\n\t\t\t\t\t//EndDialog(hWnd, 0);\r\n\t\t\t\t\t//DestroyWindow(hWnd);\r\n\t\t\t\t\tShowWindow(hWnd, SW_HIDE);\r\n\t\t\t\t\tclosed = 1;\r\n\t\t\t\t\treturn TRUE;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\treturn FALSE;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\t\tcase WM_CLOSE:\r\n\t\t\t// close\ufffd{\ufffd^\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd window \ufffd\ufffd\ufffd\u0082\ufffd\ufffd\u0202\ufffd\ufffd\u60a4\ufffd\u0242\ufffd\ufffd\ufffdB\r\n\t\t\treturn TRUE;\r\n\r\n\t\tcase WM_DESTROY:\r\n\t\t\treturn TRUE;\r\n\r\n\t\tcase WM_GET_CLOSED_STATUS:\r\n\t\t\t{\r\n\t\t\tint *flag = (int *)wp;\r\n\r\n\r\n\r\n\t\t\t*flag = closed;\r\n\t\t\t}\r\n\t\t\treturn TRUE;\r\n\r\n\t\tdefault:\r\n\t\t\treturn FALSE;\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\nstatic int is_canceled_window(HWND hd)\r\n{\r\n\tint closed = 0;\r\n\r\n\tSendMessage(hd, WM_GET_CLOSED_STATUS, (WPARAM)&closed, 0);\r\n\tif (closed)\r\n\t\treturn 1;\r\n\telse\r\n\t\treturn 0;\r\n}\r\n\r\nstatic BOOL SetDlgItemTextU8(HWND hDlg, int nIDDlgItem, const char *strU8)\r\n{\r\n\twchar_t *strW = ToWcharU8(strU8);\r\n\tBOOL retval = SetDlgItemTextW(hDlg, nIDDlgItem, strW);\r\n\tfree(strW);\r\n\treturn retval;\r\n}\r\n\r\nstatic unsigned __stdcall ssh_scp_thread(void *p)\r\n{\r\n\tChannel_t *c = (Channel_t *)p;\r\n\tPTInstVar pvar = c->scp.pvar;\r\n\tlong long total_size = 0;\r\n\tchar *buf = NULL;\r\n\tsize_t buflen;\r\n\tchar s[80];\r\n\tsize_t ret;\r\n\tHWND hWnd = c->scp.progress_window;\r\n\tscp_dlg_parm_t parm;\r\n\tint rate, ProgStat;\r\n\tDWORD stime;\r\n\tint elapsed, prev_elapsed;\r\n\r\n\tbuflen = min(c->remote_window, 8192*4); // max 32KB\r\n\tbuf = malloc(buflen);\r\n\r\n\tSetDlgItemTextU8(hWnd, IDC_FILENAME, c->scp.localfilefull);\r\n\r\n\tInitDlgProgress(hWnd, IDC_PROGBAR, &ProgStat);\r\n\r\n\tstime = GetTickCount();\r\n\tprev_elapsed = 0;\r\n\r\n\tdo {\r\n\t\tint readlen, count=0;\r\n\r\n\t\t// Cancel\ufffd{\ufffd^\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ua0bd\ufffd\ufffdE\ufffdB\ufffd\ufffd\ufffdh\ufffdE\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\tif (is_canceled_window(hWnd))\r\n\t\t\tgoto cancel_abort;\r\n\r\n\t\t// \ufffdt\ufffd@\ufffdC\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u01c2\u074d\ufffd\ufffd\ud8cb\udf83f\ufffd[\ufffd^\ufffd\u0342\ufffd\ufffd\u0202\u70b8\ufffdT\ufffd[\ufffdo\ufffd\u0591\ufffd\ufffdM\ufffd\ufffd\ufffd\ufffdB\r\n\t\treadlen = max(4096, min(buflen, c->remote_window)); // min 4KB\r\n\t\tret = fread(buf, 1, readlen, c->scp.localfp);\r\n\t\tif (ret == 0)\r\n\t\t\tbreak;\r\n\r\n\t\t// remote_window \ufffd\ufffd\ufffd\ud915\udf02\ufffd\ufffd\ufffd\u0702\u0151\u0482\ufffd\r\n\t\tdo {\r\n\t\t\t// socket or channel\ufffd\ufffd\ufffdN\ufffd\ufffd\ufffd[\ufffdY\ufffd\ufffd\ufffd\ua0bd\ufffd\ufffdX\ufffd\ufffd\ufffdb\ufffdh\ufffd\ufffd\ufffdI\ufffd\ufffd\ufffd\r\n\t\t\tif (pvar->socket == INVALID_SOCKET || c->scp.state == SCP_CLOSING || c->used == 0)\r\n\t\t\t\tgoto abort;\r\n\r\n\t\t\tif (ret > c->remote_window) {\r\n\t\t\t\tSleep(100);\r\n\t\t\t}\r\n\r\n\t\t\t// 100\ufffd\ud913\udc82\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u7532\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0702\ufffd\r\n\t\t\tcount++;\r\n\t\t\tif (count > 100) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t} while (ret > c->remote_window);\r\n\r\n\t\t// sending data\r\n\t\tparm.buf = buf;\r\n\t\tparm.buflen = ret;\r\n\t\tparm.c = c;\r\n\t\tparm.pvar = pvar;\r\n\t\tSendMessage(hWnd, WM_SENDING_FILE, (WPARAM)&parm, 0);\r\n\r\n\t\ttotal_size += ret;\r\n\r\n\t\trate = (int)(100 * total_size / c->scp.filestat.st_size);\r\n\t\t_snprintf_s(s, sizeof(s), _TRUNCATE, \"%lld / %lld (%d%%)\", total_size, c->scp.filestat.st_size, rate);\r\n\t\tSendMessage(GetDlgItem(hWnd, IDC_PROGRESS), WM_SETTEXT, 0, (LPARAM)s);\r\n\t\tif (ProgStat != rate) {\r\n\t\t\tProgStat = rate;\r\n\t\t\tSendDlgItemMessage(hWnd, IDC_PROGBAR, PBM_SETPOS, (WPARAM)ProgStat, 0);\r\n\t\t}\r\n\r\n\t\telapsed = (GetTickCount() - stime) / 1000;\r\n\t\tif (elapsed > prev_elapsed) {\r\n\t\t\tif (elapsed > 2) {\r\n\t\t\t\trate = (int)(total_size / elapsed);\r\n\t\t\t\tif (rate < 1200) {\r\n\t\t\t\t\t_snprintf_s(s, sizeof(s), _TRUNCATE, \"%d:%02d (%d %s)\", elapsed / 60, elapsed % 60, rate, \"Bytes/s\");\r\n\t\t\t\t}\r\n\t\t\t\telse if (rate < 1200000) {\r\n\t\t\t\t\t_snprintf_s(s, sizeof(s), _TRUNCATE, \"%d:%02d (%d.%02d %s)\", elapsed / 60, elapsed % 60, rate / 1000, rate / 10 % 100, \"KBytes/s\");\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t_snprintf_s(s, sizeof(s), _TRUNCATE, \"%d:%02d (%d.%02d %s)\", elapsed / 60, elapsed % 60, rate / (1000 * 1000), rate / 10000 % 100, \"MBytes/s\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t_snprintf_s(s, sizeof(s), _TRUNCATE, \"%d:%02d\", elapsed / 60, elapsed % 60);\r\n\t\t\t}\r\n\t\t\tSendDlgItemMessage(hWnd, IDC_PROGTIME, WM_SETTEXT, 0, (LPARAM)s);\r\n\t\t\tprev_elapsed = elapsed;\r\n\t\t}\r\n\r\n\t} while (ret <= buflen);\r\n\r\n\t// eof\r\n\tc->scp.state = SCP_DATA;\r\n\r\n\tbuf[0] = '\\0';\r\n\tparm.buf = buf;\r\n\tparm.buflen = 1;\r\n\tparm.c = c;\r\n\tparm.pvar = pvar;\r\n\tSendMessage(hWnd, WM_SENDING_FILE, (WPARAM)&parm, 0);\r\n\r\n\tShowWindow(hWnd, SW_HIDE);\r\n\r\n\tfree(buf);\r\n\r\n\treturn 0;\r\n\r\ncancel_abort:\r\n\t// \ufffd`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\u0303N\ufffd\ufffd\ufffd[\ufffdY\ufffd\ufffd\ufffds\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffd\ufffd ssh2_channel_send_close() \ufffd\ufffd\ufffd\u0102\u044fo\ufffd\ufffd\ufffd\u0181A\r\n\t// \ufffd\ufffd\ufffdY\ufffd\u0590\ufffd\ufffd\ufffd\ufffdX\ufffd\ufffd\ufffdb\ufffdh\ufffdZ\ufffd[\ufffdt\ufffd\u0142\u0342\u0202\ufffd\ufffd\ufffd\ufffd\u07c1ASCP\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u024fI\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\ua347\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t// (2011.6.8 yutaka)\r\n\tparm.c = c;\r\n\tparm.pvar = pvar;\r\n\tSendMessage(hWnd, WM_CHANNEL_CLOSE, (WPARAM)&parm, 0);\r\n\r\nabort:\r\n\r\n\tfree(buf);\r\n\r\n\treturn 0;\r\n}\r\n\r\n\r\nstatic void SSH2_scp_toremote(PTInstVar pvar, Channel_t *c, unsigned char *data, unsigned int buflen)\r\n{\r\n\tif (c->scp.state == SCP_INIT) {\r\n\t\tchar buf[128];\r\n\r\n\t\t_snprintf_s(buf, sizeof(buf), _TRUNCATE, \"T%lu 0 %lu 0\\n\",\r\n\t\t\t(unsigned long)c->scp.filestat.st_mtime,  (unsigned long)c->scp.filestat.st_atime);\r\n\r\n\t\tc->scp.state = SCP_TIMESTAMP;\r\n\t\tSSH2_send_channel_data(pvar, c, buf, strlen(buf), 0);\r\n\r\n\t} else if (c->scp.state == SCP_TIMESTAMP) {\r\n\t\tchar buf[128];\r\n\r\n\t\t_snprintf_s(buf, sizeof(buf), _TRUNCATE, \"C0644 %lld %s\\n\",\r\n\t\t\tc->scp.filestat.st_size, c->scp.localfile);\r\n\r\n\t\tc->scp.state = SCP_FILEINFO;\r\n\t\tSSH2_send_channel_data(pvar, c, buf, strlen(buf), 0);\r\n\r\n\t} else if (c->scp.state == SCP_FILEINFO) {\r\n\t\tHWND hDlgWnd;\r\n\t\tHANDLE thread;\r\n\t\tunsigned int tid;\r\n\r\n\t\thDlgWnd = TTCreateDialog(hInst, MAKEINTRESOURCE(IDD_SSHSCP_PROGRESS),\r\n\t\t\t\t\t\t\t\t pvar->cv->HWin, ssh_scp_dlg_proc);\r\n\t\tif (hDlgWnd != NULL) {\r\n\t\t\tstatic const DlgTextInfo text_info[] = {\r\n\t\t\t\t{ 0, \"DLG_SCP_PROGRESS_TITLE_SENDFILE\" },\r\n\t\t\t\t{ IDC_SCP_PROGRESS_FILENAME_LABEL, \"DLG_SCP_PROGRESS_FILENAME_LABEL\" },\r\n\t\t\t\t{ IDC_SCP_PROGRESS_BYTE_LABEL, \"DLG_SCP_PROGRESS_BYTES_LABEL\" },\r\n\t\t\t\t{ IDC_SCP_PROGRESS_TIME_LABEL, \"DLG_SCP_PROGRESS_TIME_LABEL\" },\r\n\t\t\t};\r\n\t\t\tSetI18nDlgStrsW(hDlgWnd, \"TTSSH\", text_info, _countof(text_info), pvar->ts->UILanguageFileW);\r\n\r\n\t\t\tc->scp.progress_window = hDlgWnd;\r\n\t\t\tShowWindow(hDlgWnd, SW_SHOW);\r\n\t\t}\r\n\r\n\t\tthread = (HANDLE)_beginthreadex(NULL, 0, ssh_scp_thread, c, 0, &tid);\r\n\t\tif (thread == 0) {\r\n\t\t\t// TODO:\r\n\t\t\tthread = INVALID_HANDLE_VALUE;\r\n\t\t}\r\n\t\tc->scp.thread = thread;\r\n\r\n\r\n\t} else if (c->scp.state == SCP_DATA) {\r\n\t\t// \ufffd\ufffd\ufffdM\ufffd\ufffd\ufffd\ufffd\r\n\t\tssh2_channel_send_close(pvar, c);\r\n\t\t//ssh2_channel_delete(c);  // free channel\r\n\r\n\t\t//MessageBox(NULL, \"SCP sending done.\", \"TTSSH\", MB_OK);\r\n\t}\r\n}\r\n\r\n\r\n#define WM_RECEIVING_FILE (WM_USER + 2)\r\n\r\nstatic unsigned __stdcall ssh_scp_receive_thread(void *p)\r\n{\r\n\tChannel_t *c = (Channel_t *)p;\r\n\tPTInstVar pvar = c->scp.pvar;\r\n\tlong long total_size = 0;\r\n\tchar s[80];\r\n\tHWND hWnd = c->scp.progress_window;\r\n\tMSG msg;\r\n\tunsigned char *data;\r\n\tunsigned int buflen;\r\n\tint eof;\r\n\tint rate, ProgStat;\r\n\tDWORD stime;\r\n\tint elapsed, prev_elapsed;\r\n\tscp_dlg_parm_t parm;\r\n\r\n\tInitDlgProgress(hWnd, IDC_PROGBAR, &ProgStat);\r\n\r\n\tstime = GetTickCount();\r\n\tprev_elapsed = 0;\r\n\r\n\tfor (;;) {\r\n\t\t// Cancel\ufffd{\ufffd^\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ua0bd\ufffd\ufffdE\ufffdB\ufffd\ufffd\ufffdh\ufffdE\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\tif (is_canceled_window(hWnd))\r\n\t\t\tgoto cancel_abort;\r\n\r\n\t\tssh2_scp_get_packetlist(pvar, c, &data, &buflen);\r\n\t\tif (data && buflen) {\r\n\t\t\tmsg.message = WM_RECEIVING_FILE;\r\n\r\n\t\t\tswitch (msg.message) {\r\n\t\t\tcase WM_RECEIVING_FILE:\r\n\t\t\t\t//data = (unsigned char *)msg.wParam;\r\n\t\t\t\t//buflen = (unsigned int)msg.lParam;\r\n\t\t\t\teof = 0;\r\n\r\n\t\t\t\tif (c->scp.filercvsize >= c->scp.filetotalsize) { // EOF\r\n\t\t\t\t\tfree(data);  // free!\r\n\t\t\t\t\tgoto done;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (c->scp.filercvsize + buflen > c->scp.filetotalsize) { // overflow (include EOF)\r\n\t\t\t\t\tbuflen = (unsigned int)(c->scp.filetotalsize - c->scp.filercvsize);\r\n\t\t\t\t\teof = 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tc->scp.filercvsize += buflen;\r\n\r\n\t\t\t\tif (fwrite(data, 1, buflen, c->scp.localfp) < buflen) { // error\r\n\t\t\t\t\t// TODO:\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfree(data);  // free!\r\n\r\n\t\t\t\trate =(int)(100 * c->scp.filercvsize / c->scp.filetotalsize);\r\n\t\t\t\t_snprintf_s(s, sizeof(s), _TRUNCATE, \"%lld / %lld (%d%%)\", c->scp.filercvsize, c->scp.filetotalsize, rate);\r\n\t\t\t\tSendMessage(GetDlgItem(c->scp.progress_window, IDC_PROGRESS), WM_SETTEXT, 0, (LPARAM)s);\r\n\r\n\t\t\t\tif (ProgStat != rate) {\r\n\t\t\t\t\tProgStat = rate;\r\n\t\t\t\t\tSendDlgItemMessage(c->scp.progress_window, IDC_PROGBAR, PBM_SETPOS, (WPARAM)ProgStat, 0);\r\n\t\t\t\t}\r\n\r\n\t\t\t\telapsed = (GetTickCount() - stime) / 1000;\r\n\t\t\t\tif (elapsed > prev_elapsed) {\r\n\t\t\t\t\tif (elapsed > 2) {\r\n\t\t\t\t\t\trate = (int)(c->scp.filercvsize / elapsed);\r\n\t\t\t\t\t\tif (rate < 1200) {\r\n\t\t\t\t\t\t\t_snprintf_s(s, sizeof(s), _TRUNCATE, \"%d:%02d (%d %s)\", elapsed / 60, elapsed % 60, rate, \"Bytes/s\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (rate < 1200000) {\r\n\t\t\t\t\t\t\t_snprintf_s(s, sizeof(s), _TRUNCATE, \"%d:%02d (%d.%02d %s)\", elapsed / 60, elapsed % 60, rate / 1000, rate / 10 % 100, \"KBytes/s\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t_snprintf_s(s, sizeof(s), _TRUNCATE, \"%d:%02d (%d.%02d %s)\", elapsed / 60, elapsed % 60, rate / (1000 * 1000), rate / 10000 % 100, \"MBytes/s\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t_snprintf_s(s, sizeof(s), _TRUNCATE, \"%d:%02d\", elapsed / 60, elapsed % 60);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tSendDlgItemMessage(hWnd, IDC_PROGTIME, WM_SETTEXT, 0, (LPARAM)s);\r\n\t\t\t\t\tprev_elapsed = elapsed;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (eof)\r\n\t\t\t\t\tgoto done;\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tSleep(0);\r\n\t}\r\n\r\ndone:\r\n\tc->scp.state = SCP_CLOSING;\r\n\tShowWindow(c->scp.progress_window, SW_HIDE);\r\n\r\n\t// \ufffd`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\u0303N\ufffd\ufffd\ufffd[\ufffdY\ufffd\ufffd\ufffds\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffd\ufffd ssh2_channel_send_close() \ufffd\ufffd\ufffd\u0102\u044fo\ufffd\ufffd\ufffd\u0181A\r\n\t// \ufffd\ufffd\ufffdY\ufffd\u0590\ufffd\ufffd\ufffd\ufffdX\ufffd\ufffd\ufffdb\ufffdh\ufffdZ\ufffd[\ufffdt\ufffd\u0142\u0342\u0202\ufffd\ufffd\ufffd\ufffd\u07c1ASCP\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u024fI\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\ua347\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t// (2011.6.1 yutaka)\r\n\tparm.c = c;\r\n\tparm.pvar = pvar;\r\n\tSendMessage(hWnd, WM_CHANNEL_CLOSE, (WPARAM)&parm, 0);\r\n\treturn 0;\r\n\r\ncancel_abort:\r\n\tpvar->recv.close_request = TRUE;\r\n\treturn 0;\r\n}\r\n\r\n// do_SSH2_adjust_window_size() \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdx\ufffd\ufffd\ufffd\u0502\ufffd\ufffdo\ufffd\u07c2\ufffd\ufffd\u0102\ufffd\ufffd\ufffdR\ufffd[\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\r\n// \ufffdt\ufffd\ufffd\ufffd[\ufffd\ufffd\ufffd\ufffdA\ufffd\ufffdM\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u010aJ\r\nstatic void CALLBACK do_SSH2_adjust_window_size_timer(\r\n\tHWND hWnd, UINT uMsg, UINT_PTR nIDEvent, DWORD dwTime)\r\n{\r\n\tChannel_t *c = (Channel_t *)nIDEvent;\r\n\tPTInstVar pvar = c->scp.pvar;\r\n\r\n\t(void)hWnd;\r\n\t(void)uMsg;\r\n\t(void)dwTime;\r\n\r\n\tif (pvar->recv.data_finished) {\r\n\t\t// \ufffd\ufffd\ufffdM\ufffdI\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u0243\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd\ufffd\ufffdc\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u038d\ufffd\r\n\t\treturn;\r\n\t}\r\n\tif (pvar->recv.timer_id != 0) {\r\n\t\t// SetTimer() \ufffd\u0343C\ufffd\ufffd\ufffd^\ufffd[\ufffdo\ufffd\ufffd\ufffd\u0254\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\u014d\ud3dc\ufffd\ufffd\ufffd\ufffd\r\n\t\tKillTimer(pvar->cv->HWin, pvar->recv.timer_id);\r\n\t\tpvar->recv.timer_id = 0;\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_NOTICE, \"%s: SCP receive, send SSH_MSG_CHANNEL_WINDOW_ADJUST\", __FUNCTION__);\r\n\tpvar->recv.suspended = FALSE;\r\n\tdo_SSH2_adjust_window_size(pvar, c);\r\n}\r\n\r\n// SSH\ufffdT\ufffd[\ufffdo\ufffd\ufffd\ufffd\u7457\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffdt\ufffd@\ufffdC\ufffd\ufffd\ufffd\u0303f\ufffd[\ufffd^\ufffd\ufffd\ufffd\ufffd\ufffdX\ufffdg\ufffd\u0242\u0082\u0202\ufffd\ufffdB\r\n// \ufffd\ufffd\ufffdX\ufffdg\ufffd\u030e\ufffd\ufffdo\ufffd\ufffd\ufffd\ufffd ssh_scp_receive_thread \ufffdX\ufffd\ufffd\ufffdb\ufffdh\ufffd\u014ds\ufffd\ufffd\ufffdB\r\nstatic void ssh2_scp_add_packetlist(PTInstVar pvar, Channel_t *c, unsigned char *buf, unsigned int buflen)\r\n{\r\n\tPacketList_t *p, *old;\r\n\r\n\tEnterCriticalSection(&g_ssh_scp_lock);\r\n\r\n\t// allocate new buffer\r\n\tp = malloc(sizeof(PacketList_t));\r\n\tif (p == NULL)\r\n\t\tgoto error;\r\n\tp->buf = buf;\r\n\tp->buflen = buflen;\r\n\tp->next = NULL;\r\n\r\n\tif (c->scp.pktlist_head == NULL) {\r\n\t\tc->scp.pktlist_head = p;\r\n\t\tc->scp.pktlist_tail = p;\r\n\t}\r\n\telse {\r\n\t\told = c->scp.pktlist_tail;\r\n\t\told->next = p;\r\n\t\tc->scp.pktlist_tail = p;\r\n\t}\r\n\r\n\t// \ufffdL\ufffd\ufffd\ufffd[\ufffd\u024bl\ufffd\ud8cb\udf83f\ufffd[\ufffd^\ufffd\u0311\ufffd\ufffdT\ufffdC\ufffdY\ufffd\ufffd\ufffd\ufffd\ufffdZ\ufffd\ufffd\ufffd\ufffdB\r\n\tc->scp.pktlist_cursize += buflen;\r\n\r\n\t// \ufffdL\ufffd\ufffd\ufffd[\ufffd\u024bl\ufffd\ud8cb\udf83f\ufffd[\ufffd^\ufffd\u0311\ufffd\ufffdT\ufffdC\ufffdY\ufffd\ufffd\ufffd\ufffd\ufffd\u81d2l\ufffd\ud80b\udd02\ufffd\ufffd\ufffd\ufffd\ua347\ufffdA\r\n\t// SSH\ufffdT\ufffd[\ufffdo\ufffd\ufffdwindows size\ufffd\u030dX\ufffdV\ufffd\ufffd\ufffd~\ufffd\ufffd\ufffd\ufffd\r\n\t// \ufffd\ufffd\ufffd\ufffd\u0242\ufffd\u80ca\ufffdX\ufffdg\ufffdG\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffd\uf0c1\ufffd\ufffd\ufffd\ufffd\ufffd\u0314\ufffd\u527b\ufffd\ufffd\r\n\t// \ufffd\ufffd\ufffd\ufffd\u0142\ufffd\ufffd\ufffdB\r\n\tif (c->scp.pktlist_cursize >= SCPRCV_HIGH_WATER_MARK) {\r\n\t\tlogprintf(LOG_LEVEL_NOTICE,\r\n\t\t\t\"%s: enter suspend\", __FUNCTION__);\r\n\t\tpvar->recv.suspended = TRUE;\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_NOTICE,\r\n\t\t\"%s: channel=#%d SCP recv %u(bytes) and enqueued.%s\",\r\n\t\t__FUNCTION__, c->self_id, c->scp.pktlist_cursize,\r\n\t\tpvar->recv.suspended ? \"(suspended)\" : \"\"\r\n\t);\r\n\r\nerror:;\r\n\tLeaveCriticalSection(&g_ssh_scp_lock);\r\n}\r\n\r\nstatic void ssh2_scp_get_packetlist(PTInstVar pvar, Channel_t *c, unsigned char **buf, unsigned int *buflen)\r\n{\r\n\tPacketList_t *p;\r\n\r\n\tEnterCriticalSection(&g_ssh_scp_lock);\r\n\r\n\tif (c->scp.pktlist_head == NULL) {\r\n\t\t*buf = NULL;\r\n\t\t*buflen = 0;\r\n\t\tgoto end;\r\n\t}\r\n\r\n\tp = c->scp.pktlist_head;\r\n\t*buf = p->buf;\r\n\t*buflen = p->buflen;\r\n\r\n\tc->scp.pktlist_head = p->next;\r\n\r\n\tif (c->scp.pktlist_head == NULL)\r\n\t\tc->scp.pktlist_tail = NULL;\r\n\r\n\tfree(p);\r\n\r\n\t// \ufffdL\ufffd\ufffd\ufffd[\ufffd\u024bl\ufffd\ud8cb\udf83f\ufffd[\ufffd^\ufffd\u0311\ufffd\ufffdT\ufffdC\ufffdY\ufffd\ufffd\ufffd\ufffd\ufffdZ\ufffd\ufffd\ufffd\ufffdB\r\n\tc->scp.pktlist_cursize -= *buflen;\r\n\r\n\t// \ufffdL\ufffd\ufffd\ufffd[\ufffd\u024bl\ufffd\ud8cb\udf83f\ufffd[\ufffd^\ufffd\u0311\ufffd\ufffdT\ufffdC\ufffdY\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u81d2l\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ua347\ufffdA\r\n\t// SSH\ufffdT\ufffd[\ufffdo\ufffd\ufffdwindow size\ufffd\u030dX\ufffdV\ufffd\ufffd\ufffd\u010aJ\ufffd\ufffd\ufffd\ufffd\r\n\tif (c->scp.pktlist_cursize <= SCPRCV_LOW_WATER_MARK) {\r\n\t\tlogprintf(LOG_LEVEL_NOTICE, \"%s: SCP receive resumed\", __FUNCTION__);\r\n\t\t// \ufffdu\ufffd\ufffd\ufffdb\ufffdN\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ua347\r\n\t\tif (pvar->recv.suspended) {\r\n\t\t\t// SCP\ufffd\ufffdM\ufffd\u0303u\ufffd\ufffd\ufffdb\ufffdN\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\t\tpvar->recv.suspended = FALSE;\r\n\t\t\tif (c->scp.filercvsize < c->scp.filetotalsize) {\r\n\t\t\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdM\r\n\t\t\t\tpvar->recv.timer_id =\r\n\t\t\t\t\tSetTimer(pvar->cv->HWin, (UINT_PTR)c, USER_TIMER_MINIMUM, do_SSH2_adjust_window_size_timer);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_NOTICE,\r\n\t\t\"%s: channel=#%d SCP recv %u(bytes) and dequeued.%s\",\r\n\t\t__FUNCTION__, c->self_id, c->scp.pktlist_cursize,\r\n\t\tpvar->recv.suspended ? \"(suspended)\" : \"\"\r\n\t);\r\n\r\nend:;\r\n\tLeaveCriticalSection(&g_ssh_scp_lock);\r\n}\r\n\r\nstatic void ssh2_scp_alloc_packetlist(PTInstVar pvar, Channel_t *c)\r\n{\r\n\tc->scp.pktlist_head = NULL;\r\n\tc->scp.pktlist_tail = NULL;\r\n\tInitializeCriticalSection(&g_ssh_scp_lock);\r\n\tc->scp.pktlist_cursize = 0;\r\n\tpvar->recv.suspended = FALSE;\r\n\tpvar->recv.timer_id = 0;\r\n\tpvar->recv.close_request = FALSE;\r\n}\r\n\r\nstatic void ssh2_scp_free_packetlist(PTInstVar pvar, Channel_t *c)\r\n{\r\n\tPacketList_t *p, *old;\r\n\r\n\tp = c->scp.pktlist_head;\r\n\twhile (p) {\r\n\t\told = p;\r\n\t\tp = p->next;\r\n\r\n\t\tfree(old->buf);\r\n\t\tfree(old);\r\n\t}\r\n\r\n\tc->scp.pktlist_head = NULL;\r\n\tc->scp.pktlist_tail = NULL;\r\n\tDeleteCriticalSection(&g_ssh_scp_lock);\r\n}\r\n\r\nstatic BOOL SSH2_scp_fromremote(PTInstVar pvar, Channel_t *c, unsigned char *data, unsigned int buflen)\r\n{\r\n\tif (buflen == 0)\r\n\t\treturn FALSE;\r\n\r\n\tif (c->scp.state == SCP_INIT) {\r\n\t\tif (data[0] == '\\01' || data[1] == '\\02') {  // error\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\r\n\t\tif (data[0] == 'T') {  // Tmtime.sec mtime.usec atime.sec atime.usec\r\n\t\t\tDWORD mtime, atime;\r\n\r\n\t\t\tsscanf_s(data, \"T%ld 0 %ld 0\", &mtime, &atime);\r\n\r\n\t\t\t// \ufffd^\ufffdC\ufffd\ufffd\ufffdX\ufffd^\ufffd\ufffd\ufffdv\ufffd\ufffd\ufffdL\ufffd^\r\n\t\t\tc->scp.filemtime = mtime;\r\n\t\t\tc->scp.fileatime = atime;\r\n\r\n\t\t\t// \ufffd\ufffd\ufffdv\ufffd\ufffd\ufffdC\ufffd\ufffd\u0502\ufffd\r\n\t\t\tgoto reply;\r\n\r\n\t\t} else if (data[0] == 'C') {  // C0666 size file\r\n\t\t\tHWND hDlgWnd;\r\n\t\t\tHANDLE thread;\r\n\t\t\tunsigned int tid;\r\n\t\t\tint permission;\r\n\t\t\tlong long size;\r\n\t\t\tchar filename[MAX_PATH];\r\n\r\n\t\t\tsscanf_s(data, \"C%o %lld %s\", &permission, &size, filename, (unsigned int)sizeof(filename));\r\n\t\t\tlogprintf(LOG_LEVEL_NOTICE, \"%s: SCP '%s', size=%lld, perm=0x%08x\",\r\n\t\t\t\t\t  __FUNCTION__,\r\n\t\t\t\t\t  filename, size, permission);\r\n\r\n\t\t\t// Windows\ufffd\u0202\u0302\u0143p\ufffd[\ufffd~\ufffdb\ufffdV\ufffd\ufffd\ufffd\ufffd\ufffd\u0356\ufffd\ufffd\ufffd\ufffdB\ufffdT\ufffdC\ufffdY\ufffd\u0302\u074bL\ufffd^\ufffdB\r\n\t\t\tc->scp.filetotalsize = size;\r\n\t\t\tc->scp.filercvsize = 0;\r\n\t\t\tc->scp.recv.received_size = 0;\r\n\r\n\t\t\tc->scp.state = SCP_DATA;\r\n\r\n\t\t\t// \ufffdi\ufffd\ufffd\ufffdE\ufffdB\ufffd\ufffd\ufffdh\ufffdE\r\n\t\t\tc->scp.pvar = pvar;\r\n\t\t\thDlgWnd = TTCreateDialog(hInst, MAKEINTRESOURCE(IDD_SSHSCP_PROGRESS),\r\n\t\t\t\t\t\t\t\t\t pvar->cv->HWin, ssh_scp_dlg_proc);\r\n\t\t\tif (hDlgWnd != NULL) {\r\n\t\t\t\tstatic const DlgTextInfo text_info[] = {\r\n\t\t\t\t\t{ 0, \"DLG_SCP_PROGRESS_TITLE_RECEIVEFILE\" },\r\n\t\t\t\t\t{ IDC_SCP_PROGRESS_FILENAME_LABEL, \"DLG_SCP_SENDFILE_FROM\" },\r\n\t\t\t\t\t{ IDC_SCP_PROGRESS_BYTE_LABEL, \"DLG_SCP_PROGRESS_BYTES_LABEL\" },\r\n\t\t\t\t\t{ IDC_SCP_PROGRESS_TIME_LABEL, \"DLG_SCP_PROGRESS_TIME_LABEL\" },\r\n\t\t\t\t};\r\n\t\t\t\tSetI18nDlgStrsW(hDlgWnd, \"TTSSH\", text_info, _countof(text_info), pvar->ts->UILanguageFileW);\r\n\r\n\t\t\t\tc->scp.progress_window = hDlgWnd;\r\n\t\t\t\tSetDlgItemTextU8(hDlgWnd, IDC_FILENAME, c->scp.localfilefull);\r\n\t\t\t\tShowWindow(hDlgWnd, SW_SHOW);\r\n\t\t\t}\r\n\r\n\t\t\tssh2_scp_alloc_packetlist(pvar, c);\r\n\t\t\tthread = (HANDLE)_beginthreadex(NULL, 0, ssh_scp_receive_thread, c, 0, &tid);\r\n\t\t\tif (thread == 0) {\r\n\t\t\t\t// TODO:\r\n\t\t\t\tthread = INVALID_HANDLE_VALUE;\r\n\t\t\t}\r\n\t\t\tc->scp.thread = thread;\r\n\t\t\tc->scp.thread_id = tid;\r\n\r\n\t\t\tgoto reply;\r\n\r\n\t\t} else {\r\n\t\t\t// \ufffdT\ufffd[\ufffdo\ufffd\ufffd\ufffd\ufffd\u0303f\ufffd[\ufffd^\ufffd\ufffd\ufffds\ufffd\ufffd\u030f\ua347\ufffd\u0341A\ufffdG\ufffd\ufffd\ufffd[\ufffd\\\ufffd\ufffd\ufffd\ufffd\ufffds\ufffd\ufffd\ufffdB\r\n\t\t\t// (2014.7.13 yutaka)\r\n\t\t\tchar msg[256];\r\n\t\t\tint copylen;\r\n\r\n\t\t\tcopylen = min(buflen, sizeof(msg));\r\n\t\t\tmemcpy(msg, data, copylen);\r\n\t\t\tmsg[copylen - 1] = 0;\r\n\r\n\t\t\tUTIL_get_lang_msg(\"MSG_SSH_SCP_ERROR_INIT_TITLE\", pvar,\r\n\t\t\t                  \"TTSSH: SCP error (SCP_INIT)\");\r\n\t\t\tMessageBox(NULL, msg, pvar->UIMsg, MB_OK | MB_ICONEXCLAMATION);\r\n\t\t}\r\n\r\n\t} else if (c->scp.state == SCP_DATA) {  // payload\ufffd\u030e\ufffdM\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: SCP_DATA size=%u\",\r\n\t\t\t\t  __FUNCTION__,\r\n\t\t\t\t  buflen);\r\n\t\tif (pvar->recv.close_request) {\r\n\t\t\t// \ufffdL\ufffd\ufffd\ufffd\ufffd\ufffdZ\ufffd\ufffd\ufffd{\ufffd^\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ua0bd\r\n\t\t\tssh2_channel_send_close(pvar, c);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tunsigned char *newdata = malloc(buflen);\r\n\t\t\tif (newdata != NULL) {\r\n\t\t\t\tmemcpy(newdata, data, buflen);\r\n\r\n\t\t\t\t// \ufffd\ufffd\ufffd\u0312\ufffd\ufffd\ufffd suspended \ufffd\ufffd TRUE \ufffd\u0242\u0202\u90b1\ufffd\u0182\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\t\t\t\tssh2_scp_add_packetlist(pvar, c, newdata, buflen);\r\n\t\t\t}\r\n\r\n\t\t\tc->scp.recv.received_size += buflen;\r\n\r\n\t\t\tif (c->scp.recv.received_size >= c->scp.filetotalsize) {\r\n\t\t\t\t// \ufffd\ufffdM\ufffdI\ufffd\ufffd\r\n\t\t\t\tPTInstVar pvar = c->scp.pvar;\r\n\t\t\t\tpvar->recv.data_finished = TRUE;\r\n\t\t\t\tif (pvar->recv.timer_id != 0) {\r\n\t\t\t\t\tpvar->recv.timer_id = 0;\r\n\t\t\t\t\tKillTimer(pvar->cv->HWin, pvar->recv.timer_id);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (pvar->recv.suspended) {\r\n\t\t\t\t// \ufffdt\ufffd\ufffd\ufffd[\ufffd\ufffd\ufffd\u4486\r\n\t\t\t\tlogprintf(LOG_LEVEL_NOTICE, \"%s: scp receive suspended\", __FUNCTION__);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// \ufffd\ufffd\ufffd[\ufffdJ\ufffd\ufffd\ufffd\ufffdwindow size\ufffd\ufffd\ufffd`\ufffdF\ufffdb\ufffdN\r\n\t\t\t\t//\t\ufffd\ufffd\ufffd\u0702\u07c2\u0242\ufffd\u70b8\ufffd\u0241A\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdx\ufffd\u0702\u0182\u07c2\u0112\ufffd\ufffd\ufffd\ufffd\ufffd\ufffds\ufffd\ufffd\r\n\t\t\t\tif (c->local_window < c->local_window_max/2) {\r\n\t\t\t\t\t// window\ufffdT\ufffdC\ufffdY\ufffd\ud80b\udc90\ufffd\ufffd\ufffd\ufffd\ufffd\r\n#if 0\r\n\t\t\t\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd\u0252\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\t\t\t\t\t//\t\t\ufffd\ufffd\ufffd\ufffd\ufffd\u0243T\ufffd[\ufffdo\ufffd[\ufffd\ufffd\ufffd\ufffdf\ufffd[\ufffd^\ufffd\ufffd\ufffd\ufffdM\ufffd\u0142\ufffd\ufffd\ufffd\u008b\ufffd\ufffd\u030f\ua347\ufffdA\r\n\t\t\t\t\t// \t\tFD_READ\ufffd\ufffd\ufffdD\ufffd\u60b3\ufffd\ufffd\u0103\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffdL\ufffd\ufffd\ufffd[\ufffd\u0250\u03c2\u0702\ufffd\ufffd\r\n\t\t\t\t\t// \t\t\ufffd\ufffd\ufffd\ufffdwindows\ufffd\u0303\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd\ufffd\ufffd\ufffd(\ufffdL\ufffd\ufffd\ufffd\ufffd\ufffdZ\ufffd\ufffd\ufffd{\ufffd^\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd)\ufffd\ufffd\r\n\t\t\t\t\t//\t\t\ufffd\u0142\ufffd\ufffd\u0202\ufffd\ufffd\u0202\u90bd\ufffd\u07ceg\ufffdp\ufffd\ufffd\ufffd\u0202\ufffd\r\n\t\t\t\t\tdo_ssh2_adjust_window_size(pvar, c);\r\n#else\r\n\t\t\t\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0502\ufffdu\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u74b2\ufffd\ufffd\r\n\t\t\t\t\t//\t\t\ufffd^\ufffdC\ufffd}\ufffd[\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffd\ufffdGUI\ufffdX\ufffd\ufffd\ufffdb\ufffdh\ufffd\u014a\u0590\ufffd\ufffd\ufffd\ufffdR\ufffd[\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\t\t\t\t\tif (pvar->recv.timer_id == 0) {\r\n\t\t\t\t\t\tpvar->recv.timer_id =\r\n\t\t\t\t\t\t\tSetTimer(pvar->cv->HWin, (UINT_PTR)c, USER_TIMER_MINIMUM, do_SSH2_adjust_window_size_timer);\r\n\t\t\t\t\t}\r\n#endif\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t} else if (c->scp.state == SCP_CLOSING) {  // EOF\ufffd\u030e\ufffdM\r\n\t\tssh2_channel_send_close(pvar, c);\r\n\r\n\t}\r\n\r\n\treturn TRUE;\r\n\r\nreply:\r\n\t{\r\n\t\tchar ch;\r\n\t\tch = '\\0';\r\n\t\tSSH2_send_channel_data(pvar, c, &ch, 1, 0);\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\n// cf. response()#scp.c\r\nstatic void SSH2_scp_response(PTInstVar pvar, Channel_t *c, unsigned char *data, unsigned int buflen)\r\n{\r\n\tif (c->scp.dir == FROMREMOTE) {\r\n\t\tif (SSH2_scp_fromremote(pvar, c, data, buflen) == FALSE)\r\n\t\t\tgoto error;\r\n\r\n\t} else\tif (c->scp.dir == TOREMOTE) {\r\n\t\tif (buflen == 1 && data[0] == '\\0') {  // OK\r\n\t\t\tSSH2_scp_toremote(pvar, c, data, buflen);\r\n\t\t} else {\r\n\t\t\tgoto error;\r\n\t\t}\r\n\t}\r\n\treturn;\r\n\r\nerror:\r\n\t{  // error\r\n\t\tchar msg[2048];\r\n\t\tunsigned int max;\r\n\t\tint offset, resp;\r\n\r\n\t\tresp = data[0];\r\n\r\n\t\t// \ufffdG\ufffd\ufffd\ufffd[\ufffdR\ufffd[\ufffdh\ufffd\u0242\ufffd\u8576\ufffd\ufffd\ufffd\ufffd\u030ai\ufffd[\ufffd\ua3ca\ufffd\ufffd\ufffd\u12b1\ufffd\u0642\u0202\ufffdB\r\n\t\tif (resp == 1 || /* error, followed by error msg */\r\n\t\t\tresp == 2) {  /* fatal error, \"\" */\r\n\t\t\toffset = 1;\r\n\t\t} else {\r\n\t\t\toffset = 0;\r\n\t\t}\r\n\r\n\t\tif (buflen > sizeof(msg) - 1)\r\n\t\t\tmax = sizeof(msg) - 1;\r\n\t\telse\r\n\t\t\tmax = buflen - offset;\r\n\t\tmemcpy(msg, &data[offset], max);\r\n\t\tmsg[max] = '\\0';\r\n\r\n\t\t// \ufffd\u60ad\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffdG\ufffd\ufffd\ufffd[\ufffd\u030f\ua347\ufffd\u0341A\ufffd\ufffd\ufffdg\ufffd\u0143`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\ufffd\ufffdN\ufffd\ufffd\ufffd[\ufffdY\ufffd\ufffd\ufffd\ufffdB\r\n\t\t// .bashrc \ufffd\ufffd\"stty stop undef\"\ufffd\ufffd\ufffd\ufffd`\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\u0181ATTSSH\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0582\u030eb\ufffd\u83c8\ufffdu\ufffdB\r\n\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd\u9334\ufffd\ufffd\ufffd\u0355\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0202\ufffd\ufffdB\r\n\t\t// (2013.4.5 yutaka)\r\n\t\tif (resp == 1) {\r\n\t\t\tssh2_channel_send_close(pvar, c);\r\n\t\t} else {\r\n\t\t\t//ssh2_channel_delete(c);  // free channel\r\n\t\t\t//ssh2_channel_send_close(pvar, c);\r\n\t\t}\r\n\r\n\t\twchar_t uimsgW[MAX_UIMSG];\r\n\t\tUTIL_get_lang_msgW(\"MSG_SSH_SCP_ERROR_TITLE\", pvar,\r\n\t\t\t\t\t\t   L\"TTSSH: SCP error\", uimsgW);\r\n\t\twchar_t *msgW = ToWcharU8(msg);\r\n\t\tMessageBoxW(pvar->cv->HWin, msgW, uimsgW, MB_OK | MB_ICONEXCLAMATION);\r\n\t\tfree(msgW);\r\n\t}\r\n}\r\n\r\n\r\nstatic BOOL handle_SSH2_channel_data(PTInstVar pvar)\r\n{\r\n\tint len;\r\n\tchar *data;\r\n\tint id;\r\n\tunsigned int str_len;\r\n\tChannel_t *c;\r\n\r\n\t// 6byte\ufffdi\ufffdT\ufffdC\ufffdY\ufffd{\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd{\ufffd^\ufffdC\ufffdv\ufffdj\ufffd\ufffd\ufffd\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffd\u020d~\ufffd\u0303y\ufffdC\ufffd\ufffd\ufffd[\ufffdh\r\n\tdata = pvar->ssh_state.payload;\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY - (\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffdT\ufffdC\ufffdY+1)\ufffdG\ufffd^\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY\r\n\tlen = pvar->ssh_state.payloadlen;\r\n\r\n\t// channel number\r\n\tid = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\r\n\tc = ssh2_channel_lookup(id);\r\n\tif (c == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: channel not found. (%d)\", __FUNCTION__, id);\r\n\t\treturn FALSE;\r\n\t}\r\n\tif (c->remote_id == SSH_CHANNEL_INVALID) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: remote shell channel number is unknown.\", __FUNCTION__);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\t// string length\r\n\tstr_len = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\r\n\tif (LogLevel(pvar, LOG_LEVEL_SSHDUMP)) {\r\n\t\tlogprintf(LOG_LEVEL_SSHDUMP, \"SSH2_MSG_CHANNEL_DATA was received. local:%d remote:%d len:%d\", c->self_id, c->remote_id, str_len);\r\n\t\tinit_memdump();\r\n\t\tpush_memdump(\"SSH receiving packet\", \"PKT_recv\", (char *)data, str_len);\r\n\t}\r\n\r\n\t// \ufffdo\ufffdb\ufffdt\ufffd@\ufffdT\ufffdC\ufffdY\ufffd\u0303`\ufffdF\ufffdb\ufffdN\r\n\tif (str_len > c->local_maxpacket) {\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: Data length is larger than local_maxpacket. \"\r\n\t\t\t\"len:%d local_maxpacket:%d\", __FUNCTION__, str_len, c->local_maxpacket);\r\n\t}\r\n\tif (str_len > c->local_window) {\r\n\t\t// local window size\ufffd\ufffd\ufffd\u50ab\ufffd\u0203p\ufffdP\ufffdb\ufffdg\ufffd\u034e\u0302\u0102\ufffd\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: Data length is larger than local_window. \"\r\n\t\t\t\"len:%d local_window:%d\", __FUNCTION__, str_len, c->local_window);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\t// \ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\u0182\ufffd\ufffd\u0103N\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg(Tera Term)\ufffd\u0593n\ufffd\ufffd\r\n\tif (c->type == TYPE_SHELL || c->type == TYPE_SUBSYSTEM_GEN) {\r\n\t\tpvar->ssh_state.payload_datalen = str_len;\r\n\t\tpvar->ssh_state.payload_datastart = 8; // id + strlen\r\n\r\n\t} else if (c->type == TYPE_PORTFWD) {\r\n\t\t//debug_print(0, data, strlen);\r\n\t\tFWD_received_data(pvar, c->local_num, data, str_len);\r\n\r\n\t} else if (c->type == TYPE_SCP) {  // SCP\r\n\t\tSSH2_scp_response(pvar, c, data, str_len);\r\n\t\t// \ufffdE\ufffdB\ufffd\ufffd\ufffdh\ufffdE\ufffdT\ufffdC\ufffdY\ufffd\u0312\ufffd\ufffd\ufffd\r\n\t\tc->local_window -= str_len;\r\n\t\treturn TRUE;\r\n\r\n\t} else if (c->type == TYPE_SFTP) {  // SFTP\r\n\t\tsftp_response(pvar, c, data, str_len);\r\n\r\n\t} else if (c->type == TYPE_AGENT) {  // agent forward\r\n\t\tif (!SSH_agent_response(pvar, c, 0, data, str_len)) {\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t}\r\n\r\n\t// \ufffdE\ufffdB\ufffd\ufffd\ufffdh\ufffdE\ufffdT\ufffdC\ufffdY\ufffd\u0312\ufffd\ufffd\ufffd\r\n\tc->local_window -= str_len;\r\n\r\n\tdo_SSH2_adjust_window_size(pvar, c);\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n\r\n// Tectia Server \ufffd\ufffd Windows \ufffd\u0142\u0341ADOS\ufffdR\ufffd}\ufffd\ufffd\ufffdh\ufffd\ufffd\ufffd\ufffd\ufffds\ufffd\ufffd\ufffd\ufffd\ufffd\u0182\ufffd\ufffd\ufffdstderr\ufffd\u024fo\ufffd\u0342\ufffd\ufffd\ufffd\ufffd\r\n// \ufffdG\ufffd\ufffd\ufffd[\ufffd\ufffd\ufffdb\ufffdZ\ufffd[\ufffdW\ufffd\ufffd SSH2_MSG_CHANNEL_EXTENDED_DATA \ufffd\u0151\ufffd\ufffdM\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffdB\r\n// SSH2_MSG_CHANNEL_EXTENDED_DATA \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u60a4\ufffd\u0242\ufffd\ufffd\ufffd\ufffdB(2006.10.30 maya)\r\nstatic BOOL handle_SSH2_channel_extended_data(PTInstVar pvar)\r\n{\r\n\tint len;\r\n\tchar *data;\r\n\tint id;\r\n\tunsigned int strlen;\r\n\tChannel_t *c;\r\n\tint data_type;\r\n\r\n\tlogputs(LOG_LEVEL_SSHDUMP, \"SSH2_MSG_CHANNEL_EXTENDED_DATA was received.\");\r\n\r\n\t// 6byte\ufffdi\ufffdT\ufffdC\ufffdY\ufffd{\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd{\ufffd^\ufffdC\ufffdv\ufffdj\ufffd\ufffd\ufffd\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffd\u020d~\ufffd\u0303y\ufffdC\ufffd\ufffd\ufffd[\ufffdh\r\n\tdata = pvar->ssh_state.payload;\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY - (\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffdT\ufffdC\ufffdY+1)\ufffdG\ufffd^\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY\r\n\tlen = pvar->ssh_state.payloadlen;\r\n\r\n\t//debug_print(80, data, len);\r\n\r\n\t// channel number\r\n\tid = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\r\n\tc = ssh2_channel_lookup(id);\r\n\tif (c == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: channel not found. (%d)\", __FUNCTION__, id);\r\n\t\treturn FALSE;\r\n\t}\r\n\tif (c->remote_id == SSH_CHANNEL_INVALID) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: remote shell channel number is unknown.\", __FUNCTION__);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\t// data_type_code\r\n\tdata_type = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\r\n\t// string length\r\n\tstrlen = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\r\n\t// \ufffdo\ufffdb\ufffdt\ufffd@\ufffdT\ufffdC\ufffdY\ufffd\u0303`\ufffdF\ufffdb\ufffdN\r\n\tif (strlen > c->local_maxpacket) {\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: Data length is larger than local_maxpacket. \"\r\n\t\t\t\"len:%d local_maxpacket:%d\", __FUNCTION__, strlen, c->local_maxpacket);\r\n\t}\r\n\tif (strlen > c->local_window) {\r\n\t\t// local window size\ufffd\ufffd\ufffd\u50ab\ufffd\u0203p\ufffdP\ufffdb\ufffdg\ufffd\u034e\u0302\u0102\ufffd\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: Data length is larger than local_window. \"\r\n\t\t\t\"len:%d local_window:%d\", __FUNCTION__, strlen, c->local_window);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\t// \ufffdy\ufffdC\ufffd\ufffd\ufffd[\ufffdh\ufffd\u0182\ufffd\ufffd\u0103N\ufffd\ufffd\ufffdC\ufffdA\ufffd\ufffd\ufffdg(Tera Term)\ufffd\u0593n\ufffd\ufffd\r\n\tif (c->type == TYPE_SHELL || c->type == TYPE_SUBSYSTEM_GEN) {\r\n\t\tpvar->ssh_state.payload_datalen = strlen;\r\n\t\tpvar->ssh_state.payload_datastart = 12; // id + data_type + strlen\r\n\r\n\t} else if (c->type == TYPE_PORTFWD) {\r\n\t\t//debug_print(0, data, strlen);\r\n\t\tFWD_received_data(pvar, c->local_num, data, strlen);\r\n\r\n\t} else if (c->type == TYPE_SCP) {  // SCP\r\n\t\tchar *msg = (char *)malloc(strlen+1);\r\n\t\twchar_t *msgW;\r\n\t\tmemcpy(msg, data, strlen);\r\n\t\tmsg[strlen] = '\\0';\r\n\t\tmsgW = ToWcharU8(msg);\r\n\t\tif (msgW) {\r\n\t\t\tNotifySetIconID(pvar->cv, hInst, pvar->settings.IconID);\r\n\t\t\tNotifyWarnMessageW(pvar->cv, msgW, L\"SSH_MSG_CHANNEL_EXTENDED_DATA\");\r\n\t\t\tNotifySetIconID(pvar->cv, NULL, 0);\r\n\t\t\tfree(msgW);\r\n\t\t}\r\n\t\tfree(msg);\r\n\r\n\t} else if (c->type == TYPE_SFTP) {  // SFTP\r\n\r\n\t} else if (c->type == TYPE_AGENT) {  // agent forward\r\n\t\tif (!SSH_agent_response(pvar, c, 0, data, strlen)) {\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t}\r\n\r\n\t//debug_print(200, data, strlen);\r\n\r\n\t// \ufffdE\ufffdB\ufffd\ufffd\ufffdh\ufffdE\ufffdT\ufffdC\ufffdY\ufffd\u0312\ufffd\ufffd\ufffd\r\n\tc->local_window -= strlen;\r\n\r\n\tif (c->type == TYPE_SCP && pvar->recv.suspended) {\r\n\t\tlogprintf(LOG_LEVEL_NOTICE, \"%s: SCP suspended\", __FUNCTION__);\r\n\t}\r\n\telse {\r\n\t\tdo_SSH2_adjust_window_size(pvar, c);\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n\r\nstatic BOOL handle_SSH2_channel_eof(PTInstVar pvar)\r\n{\r\n\tint len;\r\n\tchar *data;\r\n\tint id;\r\n\tChannel_t *c;\r\n\r\n\t// \ufffd\u0612f\ufffd\ufffd\ufffd\u0243T\ufffd[\ufffdo\ufffd\ufffd SSH2_MSG_CHANNEL_EOF \ufffd\ud805\uddc2\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\u0302\u0141A\ufffd`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB(2005.6.19 yutaka)\r\n\r\n\t// 6byte\ufffdi\ufffdT\ufffdC\ufffdY\ufffd{\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd{\ufffd^\ufffdC\ufffdv\ufffdj\ufffd\ufffd\ufffd\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffd\u020d~\ufffd\u0303y\ufffdC\ufffd\ufffd\ufffd[\ufffdh\r\n\tdata = pvar->ssh_state.payload;\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY - (\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffdT\ufffdC\ufffdY+1)\ufffdG\ufffd^\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY\r\n\tlen = pvar->ssh_state.payloadlen;\r\n\r\n\t// channel number\r\n\tid = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\r\n\tc = ssh2_channel_lookup(id);\r\n\tif (c == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: channel not found. (%d)\", __FUNCTION__, id);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"SSH2_MSG_CHANNEL_EOF was received. local:%d remote:%d\", c->self_id, c->remote_id);\r\n\r\n\tif (c->type == TYPE_PORTFWD) {\r\n\t\tFWD_channel_input_eof(pvar, c->local_num);\r\n\t}\r\n\telse if (c->type == TYPE_AGENT) {\r\n\t\tssh2_channel_send_close(pvar, c);\r\n\t}\r\n\telse {\r\n\t\t// \ufffd\u01c2\ufffd\ufffd\ufffd\ufffd\ufffd\u0302\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdH\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_SSH2_channel_open(PTInstVar pvar)\r\n{\r\n\tint len;\r\n\tchar *data;\r\n\tChannel_t *c = NULL;\r\n\tint buflen;\r\n\tchar *ctype;\r\n\tint remote_id;\r\n\tint remote_window;\r\n\tint remote_maxpacket;\r\n\tint chan_num = -1;\r\n\tbuffer_t *msg;\r\n\tunsigned char *outmsg;\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: SSH2_MSG_CHANNEL_OPEN was received.\", __FUNCTION__);\r\n\r\n\t// 6byte\ufffdi\ufffdT\ufffdC\ufffdY\ufffd{\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd{\ufffd^\ufffdC\ufffdv\ufffdj\ufffd\ufffd\ufffd\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffd\u020d~\ufffd\u0303y\ufffdC\ufffd\ufffd\ufffd[\ufffdh\r\n\tdata = pvar->ssh_state.payload;\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY - (\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffdT\ufffdC\ufffdY+1)\ufffdG\ufffd^\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY\r\n\tlen = pvar->ssh_state.payloadlen;\r\n\r\n\t// get string\r\n\tctype = buffer_get_string(&data, &buflen);\r\n\r\n\t// get value\r\n\tremote_id = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\tremote_window = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\tremote_maxpacket = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE,\r\n\t\t\"%s: type=%s, channel=%d, init_winsize=%d, max_packetsize:%d\", __FUNCTION__,\r\n\t\tNonNull(ctype), remote_id, remote_window, remote_maxpacket);\r\n\r\n\t// check Channel Type(string)\r\n\tif (ctype == NULL) {\r\n\t\t// ctype \ufffd\ufffd NULL \ufffd\u0156\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0315\u06cf\u0602\u0308\u05c1A\ufffd\ufffd\u0243`\ufffdF\ufffdb\ufffdN\ufffd\ufffd\ufffd\ufffd\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_get_string returns NULL. (ctype)\", __FUNCTION__);\r\n\t}\r\n\telse if (strcmp(ctype, \"forwarded-tcpip\") == 0) { // port-forwarding(remote to local)\r\n\t\tchar *listen_addr, *orig_addr;\r\n\t\tint listen_port, orig_port;\r\n\r\n\t\tlisten_addr = buffer_get_string(&data, &buflen);  // 0.0.0.0\r\n\t\tlisten_port = get_uint32_MSBfirst(data); // 5000\r\n\t\tdata += 4;\r\n\r\n\t\torig_addr = buffer_get_string(&data, &buflen);  // 127.0.0.1\r\n\t\torig_port = get_uint32_MSBfirst(data);  // 32776\r\n\t\tdata += 4;\r\n\r\n\t\tif (listen_addr && orig_addr) {\r\n\t\t\tlogprintf(LOG_LEVEL_VERBOSE,\r\n\t\t\t\t\"%s: %s: listen_addr=%s, listen_port=%d, orig_addr=%s, orig_port=%d\", __FUNCTION__,\r\n\t\t\t\tctype, listen_addr, listen_port, orig_addr, orig_port);\r\n\t\t\t// searching request entry by listen_port & create_local_channel\r\n\t\t\tFWD_open(pvar, remote_id, listen_addr, listen_port, orig_addr, orig_port, &chan_num);\r\n\r\n\t\t\t// channel\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffdP\ufffd[\ufffdg\ufffd\ufffd\ufffdA\ufffdK\ufffdv\ufffd\u020f\ufffd\ufffdiremote window size\ufffdj\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u014e\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffdB\r\n\t\t\t// changed window size from 128KB to 32KB. (2006.3.6 yutaka)\r\n\t\t\t// changed window size from 32KB to 128KB. (2007.10.29 maya)\r\n\t\t\tc = ssh2_channel_new(CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, TYPE_PORTFWD, chan_num);\r\n\t\t\tif (c == NULL) {\r\n\t\t\t\t// \ufffd]\ufffd\ufffd\ufffd`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\ufffd\\\ufffdP\ufffdb\ufffdg\ufffd\u0309\ufffd\ufffd\ufffdR\ufffd\ufffd\ufffd\ufffdC\ufffd\ufffd (2007.7.26 maya)\r\n\t\t\t\tFWD_free_channel(pvar, chan_num);\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_NO_FREE_CHANNEL\", pvar,\r\n\t\t\t\t                  \"Could not open new channel. TTSSH is already opening too many channels.\");\r\n\t\t\t\tnotify_nonfatal_error(pvar, pvar->UIMsg);\r\n\t\t\t\treturn FALSE;\r\n\t\t\t}\r\n\t\t\tc->remote_id = remote_id;\r\n\t\t\tc->remote_window = remote_window;\r\n\t\t\tc->remote_maxpacket = remote_maxpacket;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: %s: buffer_get_string returns NULL. \"\r\n\t\t\t\t\"linsten_addr=%s, orig_addr=%s\", __FUNCTION__,\r\n\t\t\t\tctype, NonNull(listen_addr), NonNull(orig_addr));\r\n\t\t}\r\n\t\tfree(listen_addr);\r\n\t\tfree(orig_addr);\r\n\r\n\t} else if (strcmp(ctype, \"x11\") == 0) { // port-forwarding(X11)\r\n\t\t// X application\ufffd\ufffd\ufffd^\ufffd[\ufffd~\ufffdi\ufffd\ufffd\ufffd\ufffd\u014e\ufffd\ufffds\ufffd\ufffd\ufffd\ufffd\u0181ASSH2_MSG_CHANNEL_OPEN \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffdB\r\n\t\tchar *orig_str;\r\n\t\tint orig_port;\r\n\r\n\t\torig_str = buffer_get_string(&data, NULL);  // \"127.0.0.1\"\r\n\t\torig_port = get_uint32_MSBfirst(data);\r\n\t\tdata += 4;\r\n\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: %s: orig_addr=%s, orig_port=%d\", __FUNCTION__,\r\n\t\t\tctype, orig_str, orig_port);\r\n\r\n\t\tfree(orig_str);\r\n\r\n\t\t// X server \ufffd\u0590\u0691\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n\t\tFWD_X11_open(pvar, remote_id, NULL, 0, &chan_num);\r\n\r\n\t\t// channel\ufffd\ufffd\ufffdA\ufffd\ufffd\ufffdP\ufffd[\ufffdg\ufffd\ufffd\ufffdA\ufffdK\ufffdv\ufffd\u020f\ufffd\ufffdiremote window size\ufffdj\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u014e\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffdB\r\n\t\t// changed window size from 128KB to 32KB. (2006.3.6 yutaka)\r\n\t\t// changed window size from 32KB to 128KB. (2007.10.29 maya)\r\n\t\tc = ssh2_channel_new(CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, TYPE_PORTFWD, chan_num);\r\n\t\tif (c == NULL) {\r\n\t\t\t// \ufffd]\ufffd\ufffd\ufffd`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\ufffd\\\ufffdP\ufffdb\ufffdg\ufffd\u0309\ufffd\ufffd\ufffdR\ufffd\ufffd\ufffd\ufffdC\ufffd\ufffd (2007.7.26 maya)\r\n\t\t\tFWD_free_channel(pvar, chan_num);\r\n\t\t\tUTIL_get_lang_msg(\"MSG_SSH_NO_FREE_CHANNEL\", pvar,\r\n\t\t\t                  \"Could not open new channel. TTSSH is already opening too many channels.\");\r\n\t\t\tnotify_nonfatal_error(pvar, pvar->UIMsg);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\tc->remote_id = remote_id;\r\n\t\tc->remote_window = remote_window;\r\n\t\tc->remote_maxpacket = remote_maxpacket;\r\n\r\n\t} else if (strcmp(ctype, \"auth-agent@openssh.com\") == 0) { // agent forwarding\r\n\t\tif (pvar->agentfwd_enable && FWD_agent_forward_confirm(pvar)) {\r\n\t\t\tc = ssh2_channel_new(CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, TYPE_AGENT, -1);\r\n\t\t\tif (c == NULL) {\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_NO_FREE_CHANNEL\", pvar,\r\n\t\t\t\t                  \"Could not open new channel. TTSSH is already opening too many channels.\");\r\n\t\t\t\tnotify_nonfatal_error(pvar, pvar->UIMsg);\r\n\t\t\t\treturn FALSE;\r\n\t\t\t}\r\n\t\t\tc->remote_id = remote_id;\r\n\t\t\tc->remote_window = remote_window;\r\n\t\t\tc->remote_maxpacket = remote_maxpacket;\r\n\r\n\t\t\tSSH2_confirm_channel_open(pvar, c);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tmsg = buffer_init();\r\n\t\t\tif (msg == NULL) {\r\n\t\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\t\treturn FALSE;\r\n\t\t\t}\r\n\t\t\tbuffer_put_int(msg, remote_id);\r\n\t\t\tbuffer_put_int(msg, SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED);\r\n\t\t\tbuffer_put_string(msg, \"\", 0); // description\r\n\t\t\tbuffer_put_string(msg, \"\", 0); // language tag\r\n\r\n\t\t\tlen = buffer_len(msg);\r\n\t\t\toutmsg = begin_send_packet(pvar, SSH2_MSG_CHANNEL_OPEN_FAILURE, len);\r\n\t\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\t\tfinish_send_packet(pvar);\r\n\t\t\tbuffer_free(msg);\r\n\r\n\t\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: SSH2_MSG_CHANNEL_OPEN_FAILURE was sent.\", __FUNCTION__ );\r\n\t\t}\r\n\r\n\t} else {\r\n\t\t// unknown type(unsupported)\r\n\t}\r\n\r\n\tfree(ctype);\r\n\r\n\treturn(TRUE);\r\n}\r\n\r\n\r\nstatic BOOL handle_SSH2_channel_close(PTInstVar pvar)\r\n{\r\n\tint len;\r\n\tchar *data;\r\n\tint id;\r\n\tChannel_t *c;\r\n\r\n\t// \ufffdR\ufffdl\ufffdN\ufffdV\ufffd\ufffd\ufffd\ufffd\ufffd\u0612f\ufffd\ufffd\ufffd\u0241A\ufffdp\ufffdP\ufffdb\ufffdg\ufffd_\ufffd\ufffd\ufffdv\ufffd\ufffd\ufffdt\ufffd@\ufffdC\ufffd\ufffd\ufffd\u0591|\ufffd\ufffd\ufffdo\ufffd\ufffd\ufffdB\r\n\tif (LOG_LEVEL_SSHDUMP <= pvar->session_settings.LogLevel) {\r\n\t\tsave_memdump(LOG_PACKET_DUMP);\r\n\t\tfinish_memdump();\r\n\t}\r\n\r\n\t// 6byte\ufffdi\ufffdT\ufffdC\ufffdY\ufffd{\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd{\ufffd^\ufffdC\ufffdv\ufffdj\ufffd\ufffd\ufffd\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffd\u020d~\ufffd\u0303y\ufffdC\ufffd\ufffd\ufffd[\ufffdh\r\n\tdata = pvar->ssh_state.payload;\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY - (\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffdT\ufffdC\ufffdY+1)\ufffdG\ufffd^\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY\r\n\tlen = pvar->ssh_state.payloadlen;\r\n\r\n\tid = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\tc = ssh2_channel_lookup(id);\r\n\tif (c == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: channel not found. (%d)\", __FUNCTION__, id);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE, \"SSH2_MSG_CHANNEL_CLOSE was received. local:%d remote:%d\", c->self_id, c->remote_id);\r\n\r\n\tif (c->type == TYPE_SHELL || c->type == TYPE_SUBSYSTEM_GEN) {\r\n\t\tssh2_channel_send_close(pvar, c);\r\n\r\n\t\t// TCP connection closed\r\n\t\tnotify_closed_connection(pvar, \"disconnected by server request\");\r\n\r\n\t} else if (c->type == TYPE_PORTFWD) {\r\n\t\t// CHANNEL_CLOSE \ufffd\ud805\uddc2\ufffd\u0502\ufffd\ufffd\u0202\ufffd\ufffd\u0183\ufffd\ufffd\ufffd\ufffd[\ufffdg\ufffd\ufffdchannel\ufffd\ufffd\ufffdJ\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\r\n\t\t// c.f. RFC 4254 5.3. Closing a Channel\r\n\t\tssh2_channel_send_close(pvar, c);\r\n\r\n\t\t// \ufffd]\ufffd\ufffd\ufffd`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\ufffd\ufffd\u0242\ufffd\ufffd\ufffd\\\ufffdP\ufffdb\ufffdg\ufffd\u0309\ufffd\ufffd\ufffdR\ufffd\ufffd\ufffd\ufffdC\ufffd\ufffd (2007.7.26 maya)\r\n\t\tFWD_free_channel(pvar, c->local_num);\r\n\r\n\t\t// \ufffd`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\u0309\ufffd\ufffd\ufffdR\ufffd\ufffd\ufffd\ufffdC\ufffd\ufffd (2007.4.26 yutaka)\r\n\t\tssh2_channel_delete(c);\r\n\r\n\t} else if (c->type == TYPE_SCP) {\r\n\t\t// \ufffd\ufffdM\ufffdI\ufffd\ufffd\r\n\t\tPTInstVar pvar = c->scp.pvar;\r\n\t\tpvar->recv.data_finished = TRUE;\r\n\r\n\t\tssh2_channel_delete(c);\r\n\r\n\t} else if (c->type == TYPE_AGENT) {\r\n\t\tssh2_channel_delete(c);\r\n\r\n\t} else {\r\n\t\tssh2_channel_delete(c);\r\n\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nstatic BOOL handle_SSH2_channel_request(PTInstVar pvar)\r\n{\r\n\tint len;\r\n\tchar *data;\r\n\tint id;\r\n\tchar *request;\r\n\tint want_reply;\r\n\tint success = 0;\r\n\tChannel_t *c;\r\n\r\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_CHANNEL_REQUEST was received.\");\r\n\r\n\t// 6byte\ufffdi\ufffdT\ufffdC\ufffdY\ufffd{\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd{\ufffd^\ufffdC\ufffdv\ufffdj\ufffd\ufffd\ufffd\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffd\u020d~\ufffd\u0303y\ufffdC\ufffd\ufffd\ufffd[\ufffdh\r\n\tdata = pvar->ssh_state.payload;\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY - (\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffdT\ufffdC\ufffdY+1)\ufffdG\ufffd^\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY\r\n\tlen = pvar->ssh_state.payloadlen;\r\n\r\n\t// ID(4) + string(any) + want_reply(1) + exit status(4)\r\n\tid = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\tc = ssh2_channel_lookup(id);\r\n\tif (c == NULL) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: channel not found. (%d)\", __FUNCTION__, id);\r\n\t\treturn FALSE;\r\n\t}\r\n\tif (c->remote_id == SSH_CHANNEL_INVALID) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: remote shell channel number is unknown.\", __FUNCTION__);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\trequest = buffer_get_string(&data, NULL);\r\n\r\n\twant_reply = data[0];\r\n\tdata += 1;\r\n\r\n\tlogprintf(LOG_LEVEL_VERBOSE,\r\n\t\t\"%s: local=%d, remote=%d, request=%s, want_reply=%d\",  __FUNCTION__,\r\n\t\tc->self_id, c->remote_id, NonNull(request), want_reply);\r\n\r\n\tif (request == NULL) {\r\n\t\t// request \ufffd\ufffd NULL \ufffd\u0156\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0315\u06cf\ufffd\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_get_string returns NULL. (request)\", __FUNCTION__);\r\n\t}\r\n\telse if (strcmp(request, \"exit-status\") == 0) {\r\n\t\t// \ufffdI\ufffd\ufffd\ufffdR\ufffd[\ufffdh\ufffd\ufffd\ufffd\u0702\u0702\ufffd\u0102\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\r\n\t\tint estat = get_uint32_MSBfirst(data);\r\n\t\tsuccess = 1;\r\n\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: exit-status=%d\", __FUNCTION__, estat);\r\n\t}\r\n\telse if (strcmp(request, \"keepalive@openssh.com\") == 0) {\r\n\t\t// \ufffd\u00c2\ufffd OpenSSH \ufffd\u0142\ufffd SUCCESS \ufffd\ufffd\u0502\ufffd\ufffd\u0102\ufffd keepalive \ufffd\ufffd\r\n\t\t// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u018a\u0158\udbcb\udcc2\ufffd\u0202\ufffd\ufffd\u0302\ufffd FAILURE \ufffd\ufffd\u0502\ufffd\ufffdB[teraterm:1278]\r\n\t\tsuccess = 0;\r\n\t}\r\n\r\n\tfree(request);\r\n\r\n\tif (want_reply) {\r\n\t\tbuffer_t *msg;\r\n\t\tunsigned char *outmsg;\r\n\t\tint len;\r\n\t\tint type;\r\n\r\n\t\tif (success) {\r\n\t\t\ttype = SSH2_MSG_CHANNEL_SUCCESS;\r\n\t\t} else {\r\n\t\t\ttype = SSH2_MSG_CHANNEL_FAILURE;\r\n\t\t}\r\n\r\n\t\tmsg = buffer_init();\r\n\t\tif (msg == NULL) {\r\n\t\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: buffer_init returns NULL.\", __FUNCTION__);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\tbuffer_put_int(msg, c->remote_id);\r\n\r\n\t\tlen = buffer_len(msg);\r\n\t\toutmsg = begin_send_packet(pvar, type, len);\r\n\t\tmemcpy(outmsg, buffer_ptr(msg), len);\r\n\t\tfinish_send_packet(pvar);\r\n\t\tbuffer_free(msg);\r\n\r\n\t\tif (success) {\r\n\t\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: SSH2_MSG_CHANNEL_SUCCESS was sent.\", __FUNCTION__);\r\n\t\t} else {\r\n\t\t\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: SSH2_MSG_CHANNEL_FAILURE was sent.\", __FUNCTION__);\r\n\t\t}\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n\r\nstatic BOOL handle_SSH2_window_adjust(PTInstVar pvar)\r\n{\r\n\tint len;\r\n\tchar *data;\r\n\tint id;\r\n\tunsigned int adjust;\r\n\tChannel_t *c;\r\n\r\n\tlogputs(LOG_LEVEL_SSHDUMP, \"SSH2_MSG_CHANNEL_WINDOW_ADJUST was received.\");\r\n\r\n\t// 6byte\ufffdi\ufffdT\ufffdC\ufffdY\ufffd{\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffd{\ufffd^\ufffdC\ufffdv\ufffdj\ufffd\ufffd\ufffd\ufffd\u83dc\ufffd\ufffd\ufffd\ufffd\ufffd\u020d~\ufffd\u0303y\ufffdC\ufffd\ufffd\ufffd[\ufffdh\r\n\tdata = pvar->ssh_state.payload;\r\n\t// \ufffdp\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY - (\ufffdp\ufffdf\ufffdB\ufffd\ufffd\ufffdO\ufffdT\ufffdC\ufffdY+1)\ufffdG\ufffd^\ufffd\u0303p\ufffdP\ufffdb\ufffdg\ufffdT\ufffdC\ufffdY\r\n\tlen = pvar->ssh_state.payloadlen;\r\n\r\n\t//debug_print(80, data, len);\r\n\r\n\t// channel number\r\n\tid = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\r\n\tc = ssh2_channel_lookup(id);\r\n\tif (c == NULL) {\r\n\t\t// channel close\ufffd\ufffd\ufffdadjust message\ufffd\ufffd\ufffdx\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffdP\ufffd[\ufffdX\ufffd\ufffd\ufffd\ufffd\ufffd\u90bd\ufffd\u07c1A\r\n\t\t// FALSE\ufffd\u0142\u0355\u0502\ufffd\ufffd\u0202\ufffd\ufffd\u60a4\ufffd\u0242\ufffd\ufffd\ufffdB(2007.12.26 yutaka)\r\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: channel not found. (%d)\", __FUNCTION__, id);\r\n\t\treturn TRUE;\r\n\t}\r\n\tif (c->remote_id == SSH_CHANNEL_INVALID) {\r\n\t\tlogprintf(LOG_LEVEL_ERROR, \"%s: remote shell channel number is unknown.\", __FUNCTION__);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tadjust = get_uint32_MSBfirst(data);\r\n\tdata += 4;\r\n\r\n\t// window size\ufffd\u0312\ufffd\ufffd\ufffd\r\n\tc->remote_window += adjust;\r\n\r\n\t// \ufffd\ufffd\ufffd\u70b8\ufffdo\ufffdb\ufffdt\ufffd@\ufffd\u0255\u06d1\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdf\ufffd[\ufffd^\ufffd\ud805\uddc2\ufffd\r\n\tssh2_channel_retry_send_bufchain(pvar, c);\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n// Channel_t ........... SSH2\ufffd\u0303`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\\\ufffd\ufffd\ufffd\ufffd\r\n// local_channel_num ... SSH1\ufffd\u0303\ufffd\ufffd[\ufffdJ\ufffd\ufffd\ufffd`\ufffd\ufffd\ufffdl\ufffd\ufffd\ufffd\u050d\ufffd\r\nstatic BOOL SSH_agent_response(PTInstVar pvar, Channel_t *c, int local_channel_num,\r\n                               unsigned char *data, unsigned int buflen)\r\n{\r\n\tunsigned int req_len;\r\n\tFWDChannel *fc;\r\n\tbuffer_t *agent_msg;\r\n\tunsigned int *agent_request_len;\r\n\tunsigned char *response = NULL;\r\n\tunsigned int resplen = 0;\r\n\r\n\r\n\t// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ua0bd CHANNEL_DATA \ufffd\u030e\ufffdM\ufffd\u0251\u0389\ufffd (2008.11.30 maya)\r\n\tif (SSHv2(pvar)) {\r\n\t\tagent_msg = c->agent_msg;\r\n\t\tagent_request_len = &c->agent_request_len;\r\n\t}\r\n\telse {\r\n\t\tfc = pvar->fwd_state.channels + local_channel_num;\r\n\t\tagent_msg = fc->agent_msg;\r\n\t\tagent_request_len = &fc->agent_request_len;\r\n\t}\r\n\r\n\tif (agent_msg->len == 0) {\r\n\t\treq_len = get_uint32_MSBfirst(data);\r\n\t\tif (req_len > AGENT_MAX_MSGLEN - 4) {\r\n\t\t\tlogprintf(LOG_LEVEL_NOTICE,\r\n\t\t\t\t\"%s: Agent Forwarding Error: server request is too large. size=%u, allowd max=%u.\",\r\n\t\t\t\t__FUNCTION__ , req_len, AGENT_MAX_MSGLEN-4);\r\n\t\t\tif (pvar->session_settings.ForwardAgentNotify) {\r\n\t\t\t\tchar title[MAX_UIMSG];\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_AGENTERROR_TITLE\", pvar, \"Bad agent request\");\r\n\t\t\t\tstrncpy_s(title, sizeof(title), pvar->UIMsg, _TRUNCATE);\r\n\t\t\t\tUTIL_get_lang_msg(\"MSG_SSH_AGENTERROR_TOOLARGE\", pvar,\r\n\t\t\t\t\t\"Agent request size is too large, ignore it.\");\r\n\r\n\t\t\t\tNotifySetIconID(pvar->cv, hInst, pvar->settings.IconID);\r\n\t\t\t\tNotifyInfoMessage(pvar->cv, pvar->UIMsg, title);\r\n\t\t\t\tNotifySetIconID(pvar->cv, NULL, 0);\r\n\t\t\t}\r\n\r\n\t\t\tgoto error;\r\n\t\t}\r\n\r\n\t\t*agent_request_len = req_len + 4;\r\n\r\n\t\tif (*agent_request_len > buflen) {\r\n\t\t\tbuffer_put_raw(agent_msg, data, buflen);\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\tbuffer_put_raw(agent_msg, data, buflen);\r\n\t\tif (*agent_request_len > agent_msg->len) {\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t\tdata = agent_msg->buf;\r\n\t}\r\n\r\n\tputty_agent_query_synchronous(data, *agent_request_len, &response, &resplen);\r\n\tif (response == NULL || resplen < 5) {\r\n\t\tlogprintf(LOG_LEVEL_NOTICE, \"%s Agent Forwarding Error: putty_agent_query_synchronous is failed.\", __FUNCTION__);\r\n\t\tgoto error;\r\n\t}\r\n\r\n\tif (SSHv2(pvar)) {\r\n\t\tSSH2_send_channel_data(pvar, c, response, resplen, 0);\r\n\t}\r\n\telse {\r\n\t\tSSH_channel_send(pvar, local_channel_num, fc->remote_num,\r\n\t\t                 response, resplen, 0);\r\n\t}\r\n\tsafefree(response);\r\n\r\n\t// \ufffdg\ufffd\ufffd\ufffdI\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdo\ufffdb\ufffdt\ufffd@\ufffd\ufffd\ufffdN\ufffd\ufffd\ufffdA\r\n\tbuffer_clear(agent_msg);\r\n\treturn TRUE;\r\n\r\nerror:\r\n\t// \ufffdG\ufffd\ufffd\ufffd[\ufffd\ufffd\ufffd\ufffd SSH_AGENT_FAILURE \ufffd\ufffd\u0502\ufffd\r\n\tif (SSHv2(pvar)) {\r\n\t\tSSH2_send_channel_data(pvar, c, SSH_AGENT_FAILURE_MSG, sizeof(SSH_AGENT_FAILURE_MSG), 0);\r\n\t}\r\n\telse {\r\n\t\tSSH_channel_send(pvar, local_channel_num, fc->remote_num,\r\n\t\t                 SSH_AGENT_FAILURE_MSG, sizeof(SSH_AGENT_FAILURE_MSG), 0);\r\n\t}\r\n\tif (response) {\r\n\t\tsafefree(response);\r\n\t}\r\n\r\n\t// \ufffdg\ufffd\ufffd\ufffdI\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdo\ufffdb\ufffdt\ufffd@\ufffd\ufffd\ufffdN\ufffd\ufffd\ufffdA\r\n\tbuffer_clear(agent_msg);\r\n\treturn TRUE;\r\n}\r\n", "/*\r\n * Copyright (c) 1998-2001, Robert O'Callahan\r\n * (C) 2004- TeraTerm Project\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions\r\n * are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright\r\n *    notice, this list of conditions and the following disclaimer.\r\n * 2. Redistributions in binary form must reproduce the above copyright\r\n *    notice, this list of conditions and the following disclaimer in the\r\n *    documentation and/or other materials provided with the distribution.\r\n * 3. The name of the author may not be used to endorse or promote products\r\n *    derived from this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\r\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,\r\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\r\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n/*\r\nThis code is copyright (C) 1998-1999 Robert O'Callahan.\r\nSee LICENSE.TXT for the license.\r\n*/\r\n\r\n#ifndef __TTXSSH_H\r\n#define __TTXSSH_H\r\n\r\n#pragma warning(3 : 4035)\r\n\r\n/* VS2015(VC14.0)\ufffd\ufffd\ufffd\u0181AWSASocketA(), inet_ntoa() \ufffd\u0202\u01c2\ufffdAPI\ufffd\ufffddeprecated\ufffd\u0142\ufffd\ufffd\ufffd\ufffd\r\n* \ufffdx\ufffd\ufffd\ufffd\ufffd\ufffd\u90bd\ufffd\u07c2\u0241A\ufffdx\ufffd\ufffd\ufffd\ufffd}\ufffd~\ufffd\ufffd\ufffd\ufffdB\ufffd\ufffd\u058a\u0590\ufffd\ufffd\u0252u\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0181AVS2005(VC8.0)\ufffd\u0143r\ufffd\ufffd\ufffdh\r\n* \ufffd\u0142\ufffd\ufffd\u0202\ufffd\ufffd\u0202\u90bd\ufffd\u07c1A\ufffdx\ufffd\ufffd\ufffd\ufffd}\ufffd~\ufffd\ufffd\ufffd\u90be\ufffd\ufffd\ufffd\u0182\ufffd\ufffd\ufffdB\r\n*/\r\n#if _MSC_VER >= 1800  // VSC2013(VC12.0) or later\r\n\t#ifndef _WINSOCK_DEPRECATED_NO_WARNINGS\r\n\t\t#define _WINSOCK_DEPRECATED_NO_WARNINGS\r\n\t#endif\r\n#endif\r\n\r\n#include <winsock2.h>\r\n#include <ws2tcpip.h>\r\n#include <wspiapi.h>\r\n/* actual body of in6addr_any and in6addr_loopback is disappeared?? */\r\n#undef IN6_IS_ADDR_LOOPBACK\r\n#define IN6_IS_ADDR_LOOPBACK(a)         \\\r\n        ((*(unsigned int *)(&(a)->s6_addr[0]) == 0) &&     \\\r\n         (*(unsigned int *)(&(a)->s6_addr[4]) == 0) &&     \\\r\n         (*(unsigned int *)(&(a)->s6_addr[8]) == 0) &&     \\\r\n         (*(unsigned int *)(&(a)->s6_addr[12]) == ntohl(1)))\r\n/* work around for MS Platform SDK Oct 2000 */\r\n#include <malloc.h> /* prevent of conflict stdlib.h */\r\n#include <stdlib.h>\r\n#include <stdarg.h>\r\n#include <crtdbg.h>\r\n\r\n#include \"i18n.h\"\r\n#include \"ttlib.h\"\r\n\r\ntypedef struct _TInstVar *PTInstVar;\r\n\r\n#include \"util.h\"\r\n#include \"pkt.h\"\r\n#include \"ssh.h\"\r\n#include \"auth.h\"\r\n#include \"crypt.h\"\r\n#include \"cipher.h\"\r\n#include \"comp.h\"\r\n#include \"kex.h\"\r\n#include \"hostkey.h\"\r\n#include \"key.h\"\r\n#include \"hosts.h\"\r\n#include \"fwd.h\"\r\n\r\n#include <openssl/dh.h>\r\n#include <openssl/ec.h>\r\n#include <openssl/evp.h>\r\n#include \"buffer.h\"\r\n\r\n/* tttypes.h \ufffd\u0152\ufffd`\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd EM \ufffd}\ufffdN\ufffd\ufffd\ufffd\ufffd openssl/rsa.h (OpenSSL 0.9.8)\ufffd\u030a\u0590\ufffd\ufffdv\ufffd\ufffd\ufffdg\ufffd^\ufffdC\ufffdv\ufffd\u933e\ufffd\ufffd\r\n * \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u018fd\ufffd\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0702\ufffd\ufffd\u0302\u0141A\ufffdr\ufffd\ufffd\ufffdh\ufffdG\ufffd\ufffd\ufffd[\ufffd\u0182\u0202\ufffdB\ufffd\ufffd\ufffdL3\ufffdw\ufffdb\ufffd_\ufffd\ufffdinclude\ufffd\u0292u\ufffd\ufffd\ufffd\ufffd\ufffdL\ufffd\u0248\u0693\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\r\n * (2005.7.9 yutaka)\r\n */\r\n#include \"teraterm.h\"\r\n#include \"tttypes.h\"\r\n#include \"ttplugin.h\"\r\n\r\n#if defined(_MSC_VER) && !defined(_Printf_format_string_)\r\n// \ufffd\ufffd`\ufffd\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\u0202\ufffd\ufffd\u0182\ufffd\ufffd\u0349\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0202\ufffd\ufffd\u60a4\ufffd\u0252\ufffd`\ufffd\ufffd\ufffd\u0102\ufffd\ufffd\ufffd\r\n#define _Printf_format_string_\r\n#endif\r\n\r\nextern HANDLE hInst; /* Instance handle of TTXSSH.DLL */\r\n\r\n#define ID_SSHSCPMENU       52110\r\n#define ID_SSHSETUPMENU     52310\r\n#define ID_SSHAUTHSETUPMENU 52320\r\n#define ID_SSHFWDSETUPMENU  52330\r\n#define ID_SSHKEYGENMENU    52340\r\n#define ID_ABOUTMENU        52910\r\n\r\n#define ID_SSHAUTH            62501\r\n#define ID_SSHUNKNOWNHOST     62502\r\n#define ID_SSHDIFFERENTKEY    62503\r\n#define ID_SSHASYNCMESSAGEBOX 62504\r\n#define ID_SSHDIFFERENT_TYPE_KEY 62505\r\n\r\n#define OPTION_NONE     0\r\n#define OPTION_CLEAR    1\r\n#define OPTION_REPLACE  2\r\n\r\n/*\r\n * DisablePopupMessage \ufffdp\ufffd\u0303r\ufffdb\ufffdg\ufffd\ufffd`\r\n */\r\n#define POPUP_MSG_default\t\t\t0\r\n#define POPUP_MSG_FWD_received_data\t(1 << 0)\r\n#define POPUP_MSG_FWD_channel_open\t(1 << 1)\r\n\r\n\r\n/*\r\n * Host key rotation\r\n */\r\n#define SSH_UPDATE_HOSTKEYS_NO\t0\r\n#define SSH_UPDATE_HOSTKEYS_YES\t1\r\n#define SSH_UPDATE_HOSTKEYS_ASK\t2\r\n#define SSH_UPDATE_HOSTKEYS_MAX\t3\r\n\r\n/*\r\n * Server compatibility flag\r\n */\r\n#define SSH_BUG_DHGEX_LARGE 0x00000001\r\n\r\n\r\n/*\r\nThese are the fields that WOULD go in Tera Term's 'ts' structure, if\r\nwe could put them there.\r\n*/\r\ntypedef struct _TS_SSH {\r\n\tBOOL Enabled;\r\n\tint CompressionLevel; /* 0 = NONE, else 1-9 */\r\n\r\n\tint DefaultUserType;\t/* 0/1/2 = no input/DefaultUserName/Windows logon user */\r\n\tchar DefaultUserName[256];\r\n\r\n\t/* this next option is a string of digits. Each digit represents a\r\n\t   cipher. The first digit is the most preferred cipher, and so on.\r\n\t   The digit SSH_CIPHER_NONE signifies that any ciphers after it are\r\n\t   disabled. */\r\n\tchar CipherOrder[SSH_CIPHER_MAX+2];\r\n\r\n\tchar KnownHostsFiles[2048];\r\n\tint DefaultAuthMethod;\r\n\tchar DefaultRhostsLocalUserName[256];\r\n\tchar DefaultRhostsHostPrivateKeyFile[1024];\r\n\tchar DefaultRSAPrivateKeyFile[1024];\r\n\r\n\tchar DefaultForwarding[4096];\r\n\tBOOL TryDefaultAuth;\r\n\r\n\tint LogLevel;      /* 0 = NONE, 100 = Verbose */\r\n\tint WriteBufferSize;\r\n\r\n\tint ssh_protocol_version; // SSH version (2004.10.11 yutaka)\r\n\tint ssh_heartbeat_overtime; // SSH heartbeat(keepalive) (2004.12.11 yutaka)\r\n\t// whether password will permanently store on heap memory (2006.8.5 yutaka)\r\n\tint remember_password;\r\n\r\n\t// try auth with \"none\" method for disable unsupported on dialog (2007.9.24 maya)\r\n\tBOOL CheckAuthListFirst;\r\n\r\n\t// Enable connection to the server that has RSA key length less than 768 bit (2008.9.11 maya)\r\n\tBOOL EnableRsaShortKeyServer;\r\n\r\n\t// Enable Agent forwarding\r\n\tBOOL ForwardAgent;\r\n\r\n\t// Confirm Agent forwarding\r\n\tBOOL ForwardAgentConfirm;\r\n\r\n\t// Confirm Agent forwarding\r\n\tBOOL ForwardAgentNotify;\r\n\r\n\t// KEX order(derived from teraterm.ini)\r\n\tchar KexOrder[KEX_DH_MAX+1];\r\n\tchar HostKeyOrder[KEY_ALGO_MAX+1];\r\n\tchar MacOrder[HMAC_MAX+1];\r\n\tchar CompOrder[COMP_MAX+1];\r\n\r\n\tBOOL VerifyHostKeyDNS;\r\n\r\n\tint IconID;\r\n\r\n\tint DisablePopupMessage;\r\n\r\n\tchar X11Display[128];\r\n\r\n\tint UpdateHostkeys;\r\n\r\n\tint GexMinimalGroupSize;\r\n\r\n\tint AuthBanner;\r\n\r\n\tBOOL KexKeyLogging;\r\n\twchar_t KexKeyLogFile[1024];\r\n\r\n\t// Sign algorithm order\r\n\t//   for publickey authentication (not for server hostkey)\r\n\t//   for RSA key only\r\n\tchar RSAPubkeySignAlgorithmOrder[RSA_PUBKEY_SIGN_ALGO_MAX+1];\r\n} TS_SSH;\r\n\r\ntypedef struct _TInstVar {\r\n\tPTTSet ts;\r\n\tPComVar cv;\r\n\r\n\t/* shared memory for settings across instances. Basically it's\r\n\t   a cache for the INI file.*/\r\n\tTS_SSH *ts_SSH;\r\n\r\n\tint fatal_error;\r\n\tint showing_err;\r\n\tchar *err_msg;\r\n\r\n\tTconnect Pconnect;\r\n\tTrecv Precv;\r\n\tTsend Psend;\r\n\tTWSAAsyncSelect PWSAAsyncSelect;\r\n\tTWSAGetLastError PWSAGetLastError;\r\n\r\n\tPReadIniFile ReadIniFile;\r\n\tPWriteIniFile WriteIniFile;\r\n\tPParseParam ParseParam;\r\n\r\n\tHMENU FileMenu;\r\n\r\n\tSOCKET socket;\r\n\tHWND NotificationWindow;\r\n\tunsigned int notification_msg;\r\n\tlong notification_events;\r\n\tHICON OldSmallIcon; // \ufffdg\ufffdp\ufffd\ufffd\ufffd\u0202\ufffd\r\n\tHICON OldLargeIcon; // \ufffdg\ufffdp\ufffd\ufffd\ufffd\u0202\ufffd\r\n\r\n\tBOOL hostdlg_activated;\r\n\tBOOL hostdlg_Enabled;\r\n\r\n\tint protocol_major;\r\n\tint protocol_minor;\r\n\r\n\tPKTState pkt_state;\r\n\tSSHState ssh_state;\r\n\tAUTHState auth_state;\r\n\tCRYPTState crypt_state;\r\n\tHOSTSState hosts_state;\r\n\tFWDState fwd_state;\r\n\r\n/* The settings applied to the current session. The user may change\r\n   the settings but usually we don't want that to affect the session\r\n   in progress (race conditions). So user setup changes usually\r\n   modify the 'settings' field below. */\r\n\tTS_SSH session_settings;\r\n\r\n/* our copy of the global settings. This is synced up with the shared\r\n   memory only when we do a ReadIniFile or WriteIniFile\r\n   (i.e. the user loads or saves setup) */\r\n\tTS_SSH settings;\r\n\r\n\t// SSH2\r\n\tDH *kexdh;\r\n\tchar server_version_string[128];\r\n\tchar client_version_string[128];\r\n\tbuffer_t *my_kex;\r\n\tbuffer_t *peer_kex;\r\n\tkex_algorithm kex_type; // KEX algorithm\r\n\tssh_keyalgo hostkey_type;\r\n\tconst struct ssh2cipher *ciphers[MODE_MAX];\r\n\tconst struct SSH2Mac *macs[MODE_MAX];\r\n\tcompression_type ctos_compression;\r\n\tcompression_type stoc_compression;\r\n\tint we_need;\r\n\tint kex_status;\r\n\tchar *session_id;\r\n\tint session_id_len;\r\n\tSSHKeys ssh2_keys[MODE_MAX];\r\n\tstruct sshcipher_ctx *cc[MODE_MAX];\r\n\tint userauth_success;\r\n\tint shell_id;\r\n\tint session_nego_status;\r\n\t/*\r\n\tunsigned int local_window;\r\n\tunsigned int local_window_max;\r\n\tunsigned int local_consumed;\r\n\tunsigned int local_maxpacket;\r\n\tunsigned int remote_window;\r\n\tunsigned int remote_maxpacket;\r\n\t*/\r\n\tint client_key_bits;\r\n\tint server_key_bits;\r\n\tint kexgex_min;\r\n\tint kexgex_bits;\r\n\tint kexgex_max;\r\n\tint ssh2_autologin;\r\n\tint ask4passwd;\r\n\tSSHAuthMethod ssh2_authmethod;\r\n\tchar ssh2_username[MAX_PATH];\r\n\tchar ssh2_password[MAX_PATH];\r\n\tchar ssh2_keyfile[MAX_PATH];\r\n\ttime_t ssh_heartbeat_tick;\r\n\tHANDLE ssh_heartbeat_thread;\r\n\tint keyboard_interactive_password_input;\r\n\tint userauth_retry_count;\r\n\tbuffer_t *decomp_buffer;\r\n\tbuffer_t *authbanner_buffer;\r\n\tchar *ssh2_authlist;\r\n\tBOOL tryed_ssh2_authlist;\r\n\tHWND ssh_hearbeat_dialog;\r\n\r\n\t/* Pageant \ufffd\u0182\u0312\u0290M\ufffdp */\r\n\tunsigned char *pageant_key;\r\n\tunsigned char *pageant_curkey;\r\n\tint pageant_keylistlen;\r\n\tint pageant_keycount;\r\n\tint pageant_keycurrent;\r\n\tBOOL pageant_keyfinal;// SSH2 PK_OK \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0182\ufffd\ufffd\ufffd TRUE \ufffd\u0242\ufffd\ufffd\ufffd\r\n\r\n\t// agent forward\r\n\tBOOL agentfwd_enable;\r\n\r\n\tBOOL origDisableTCPEchoCR;\r\n\r\n\tBOOL nocheck_known_hosts;\r\n\r\n\tEC_KEY *ecdh_client_key;\r\n\r\n\tint dns_key_check;\r\n\r\n\tunsigned int server_compat_flag;\r\n\r\n\tvoid *hostkey_ctx;\r\n\r\n\tBOOL use_subsystem;\r\n\tchar subsystem_name[256];\r\n\r\n\tBOOL nosession;\r\n\r\n\t// dialog resource\r\n\tHFONT hFontFixed;\t\t// hosts.c\ufffd\ufffd\ufffd\u0303_\ufffdC\ufffdA\ufffd\ufffd\ufffdO\ufffdp\r\n\r\n\tstruct {\r\n\t\tBOOL suspended;  // SCP\ufffd\ufffdM\ufffd\u0303t\ufffd\ufffd\ufffd[\ufffd\ufffd\ufffd\ufffdp,TRUE\ufffd\u0302\u0182\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0502\ufffd\ufffd\u0202\ufffd\ufffd\ufffd\ufffd\r\n\t\t//BOOL timer_triggerd;\r\n\t\tUINT_PTR timer_id;\r\n\t\tBOOL data_finished;\t// TRUE\ufffd\u0302\u0182\ufffd,\ufffdf\ufffd[\ufffd^\ufffd\u030e\ufffdM\ufffd\u034a\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\r\n\t\tBOOL close_request;\r\n\t} recv;\r\n\r\n\tchar *server_sig_algs;\r\n\tBOOL server_strict_kex;\r\n\r\n\tchar UIMsg[MAX_UIMSG];\r\n} TInstVar;\r\n\r\n// \ufffdo\ufffd[\ufffdW\ufffd\ufffd\ufffd\ufffd\ufffd\u024d\ufffd\ufffd\ud0b9\ufffd\u010e\ufffd\ufffd\ufffd\ufffd\u03cdX\ufffd\ufffd\ufffd\ufffd\ufffdB \ufffd\ufffd: TTSSH_2-81_TS_data\r\n#define TTSSH_FILEMAPNAME \"TTSSH_\" TTSSH_VERSION_STR(\"-\") \"_TS_data\"\r\n\r\n#define LOG_LEVEL_FATAL      5\r\n#define LOG_LEVEL_ERROR      10\r\n#define LOG_LEVEL_WARNING    30\r\n#define LOG_LEVEL_NOTICE     50\r\n#define LOG_LEVEL_INFO       80\r\n#define LOG_LEVEL_VERBOSE    100\r\n#define LOG_LEVEL_SSHDUMP    200\r\n\r\n#define SSHv1(pvar) ((pvar)->protocol_major == 1)\r\n#define SSHv2(pvar) ((pvar)->protocol_major == 2)\r\n\r\n#define LogLevel(pvar, level) ((pvar)->settings.LogLevel >= (level))\r\n\r\nvoid notify_established_secure_connection(PTInstVar pvar);\r\nvoid notify_closed_connection(PTInstVar pvar, char *send_msg);\r\nvoid notify_nonfatal_error(PTInstVar pvar, char *msg);\r\nvoid notify_fatal_error(PTInstVar pvar, char *msg, BOOL send_disconnect);\r\nvoid logputs(int level, char *msg);\r\n#if defined(_MSC_VER)\r\nvoid logprintf(int level, _Printf_format_string_ const char *fmt, ...);\r\nvoid logprintf_hexdump(int level, const char *data, int len, _Printf_format_string_ const char *fmt, ...);\r\n#elif defined(__GNUC__)\r\nvoid logprintf(int level, const char *fmt, ...) __attribute__ ((format (printf, 2, 3)));\r\nvoid logprintf_hexdump(int level, const char *data, int len, const char *fmt, ...) __attribute__ ((format (printf, 4, 5)));\r\n#else\r\nvoid logprintf(int level, const char *fmt, ...);\r\nvoid logprintf_hexdump(int level, const char *data, int len, const char *fmt, ...);\r\n#endif\r\n\r\nvoid get_teraterm_dir_relative_name(char *buf, int bufsize, char *basename);\r\nwchar_t *get_teraterm_dir_relative_nameW(const wchar_t *basename);\r\nint copy_teraterm_dir_relative_path(char *dest, int destsize, char *basename);\r\nwchar_t *get_home_dir_relative_nameW(const wchar_t *basename);\r\nwchar_t *get_log_dir_relative_nameW(const wchar_t *basename);\r\nint uuencode(unsigned char *src, int srclen, unsigned char *target, int targsize);\r\n\r\n#endif\r\n"], "filenames": ["ttssh2/ttxssh/kex.c", "ttssh2/ttxssh/ssh.c", "ttssh2/ttxssh/ttxssh.h"], "buggy_code_start_loc": [149, 2999, 365], "buggy_code_end_loc": [168, 6239, 365], "fixing_code_start_loc": [149, 3000, 366], "fixing_code_end_loc": [168, 6256, 367], "type": "CWE-354", "message": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.", "other": {"cve": {"id": "CVE-2023-48795", "sourceIdentifier": "cve@mitre.org", "published": "2023-12-18T16:15:10.897", "lastModified": "2024-03-07T19:15:10.263", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust."}, {"lang": "es", "value": "El protocolo de transporte SSH con ciertas extensiones OpenSSH, que se encuentra en OpenSSH anterior a 9.6 y otros productos, permite a atacantes remotos eludir las comprobaciones de integridad de modo que algunos paquetes se omiten (del mensaje de negociaci\u00f3n de extensi\u00f3n) y, en consecuencia, un cliente y un servidor pueden terminar con una conexi\u00f3n para la cual algunas caracter\u00edsticas de seguridad han sido degradadas o deshabilitadas, tambi\u00e9n conocido como un ataque Terrapin. Esto ocurre porque SSH Binary Packet Protocol (BPP), implementado por estas extensiones, maneja mal la fase de protocolo de enlace y el uso de n\u00fameros de secuencia. Por ejemplo, existe un ataque eficaz contra ChaCha20-Poly1305 (y CBC con Encrypt-then-MAC). La omisi\u00f3n se produce en chacha20-poly1305@openssh.com y (si se utiliza CBC) en los algoritmos MAC -etm@openssh.com. Esto tambi\u00e9n afecta a Maverick Synergy Java SSH API anterior a 3.1.0-SNAPSHOT, Dropbear hasta 2022.83, Ssh anterior a 5.1.1 en Erlang/OTP, PuTTY anterior a 0.80 y AsyncSSH anterior a 2.14.2; y podr\u00eda haber efectos en Bitvise SSH hasta la versi\u00f3n 9.31, libssh hasta la 0.10.5 y golang.org/x/crypto hasta el 17 de diciembre de 2023."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-354"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openbsd:openssh:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.6", "matchCriteriaId": "5308FBBB-F738-41C5-97A4-E40118E957CD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:putty:putty:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.80", "matchCriteriaId": "A9D807DB-9E20-4792-8A9F-4BFFC841BAB7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:filezilla-project:filezilla_client:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.66.4", "matchCriteriaId": "42915485-A4DA-48DD-9C15-415D2D39DC52"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:microsoft:powershell:*:*:*:*:*:*:*:*", "versionEndIncluding": "11.1.0", "matchCriteriaId": "9F37C9AC-185F-403A-A79B-2D5C8E11AFC4"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:panic:transmit_5:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.10.4", "matchCriteriaId": "31FFE0AA-FC25-40DE-8EE9-7F4C80ABDE4F"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:apple:macos:-:*:*:*:*:*:*:*", "matchCriteriaId": "387021A0-AF36-463C-A605-32EA7DAC172E"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:panic:nova:*:*:*:*:*:*:*:*", "versionEndExcluding": "11.8", "matchCriteriaId": "F2FCF7EF-97D7-44CF-AC74-72D856901755"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:apple:macos:-:*:*:*:*:*:*:*", "matchCriteriaId": "387021A0-AF36-463C-A605-32EA7DAC172E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:roumenpetrov:pkixssh:*:*:*:*:*:*:*:*", "versionEndExcluding": "14.4", "matchCriteriaId": "53CAD263-1C60-43BD-86A2-C8DB15FFB4C6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:winscp:winscp:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.2.2", "matchCriteriaId": "8FA57F20-C9C1-40A7-B2CD-F3440CCF1D66"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bitvise:ssh_client:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.33", "matchCriteriaId": "6209E375-10C7-4E65-A2E7-455A686717AC"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bitvise:ssh_server:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.32", "matchCriteriaId": "1A05CC3C-19C5-4BAA-ABA2-EE1795E0BE81"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:lancom-systems:lcos:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.66.4", "matchCriteriaId": "3A71B523-0778-46C6-A38B-64452E0BB6E7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:lancom-systems:lcos_fx:-:*:*:*:*:*:*:*", "matchCriteriaId": "F1C91308-15E5-40AF-B4D5-3CAD7BC65DDF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:lancom-systems:lcos_lx:-:*:*:*:*:*:*:*", "matchCriteriaId": "418940E3-6DD1-4AA6-846A-03E059D0C681"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:lancom-systems:lcos_sx:4.20:*:*:*:*:*:*:*", "matchCriteriaId": "411BA58A-33B6-44CA-B9D6-7F9042D46961"}, {"vulnerable": true, "criteria": "cpe:2.3:o:lancom-systems:lcos_sx:5.20:*:*:*:*:*:*:*", "matchCriteriaId": "FA17A153-30E4-4731-8706-8F74FCA50993"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:lancom-systems:lanconfig:-:*:*:*:*:*:*:*", "matchCriteriaId": "FB736F57-9BE3-4457-A10E-FA88D0932154"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vandyke:securecrt:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.4.3", "matchCriteriaId": "6EB8D02D-87F3-414D-A3EA-43F594DAAC1B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libssh:libssh:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.10.6", "matchCriteriaId": "AAB481DA-FBFE-4CC2-9AE7-22025FA07494"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:net-ssh:net-ssh:7.2.0:*:*:*:*:ruby:*:*", "matchCriteriaId": "3D6FD459-F8E8-4126-8097-D30B4639404A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ssh2_project:ssh2:*:*:*:*:*:node.js:*:*", "versionEndIncluding": "1.11.0", "matchCriteriaId": "69510F52-C699-4E7D-87EF-7000682888F0"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:proftpd:proftpd:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.3.8b", "matchCriteriaId": "9461430B-3709-45B6-8858-2101F5AE4481"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:freebsd:freebsd:*:*:*:*:*:*:*:*", "versionEndIncluding": "12.4", "matchCriteriaId": "B9A01DF3-E20E-4F29-B5CF-DDF717D01E74"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:crates:thrussh:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.35.1", "matchCriteriaId": "D25EB73D-6145-4B7D-8F14-80FD0B458E99"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tera_term_project:tera_term:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.1", "matchCriteriaId": "77594DEC-B5F7-4911-A13D-FFE91C74BAFA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oryx-embedded:cyclone_ssh:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.3.4", "matchCriteriaId": "F8FF7E74-2351-4CD9-B717-FA28893293A1"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:crushftp:crushftp:*:*:*:*:*:*:*:*", "versionEndIncluding": "10.6.0", "matchCriteriaId": "82A93C12-FEB6-4E82-B283-0ED7820D807E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netsarang:xshell_7:*:*:*:*:*:*:*:*", "versionEndExcluding": "build__0144", "matchCriteriaId": "B480AE79-2FA1-4281-9F0D-0DE812B9354D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:paramiko:paramiko:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.4.0", "matchCriteriaId": "826B6323-06F8-4B96-8771-3FA15A727B08"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_container_platform:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "932D137F-528B-4526-9A89-CD59FA1AB0FE"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openstack_platform:16.1:*:*:*:*:*:*:*", "matchCriteriaId": "DCC81071-B46D-4F5D-AC25-B4A4CCC20C73"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openstack_platform:16.2:*:*:*:*:*:*:*", "matchCriteriaId": "4B3000D2-35DF-4A93-9FC0-1AD3AB8349B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openstack_platform:17.1:*:*:*:*:*:*:*", "matchCriteriaId": "E315FC5C-FF19-43C9-A58A-CF2A5FF13824"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ceph_storage:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA7EAD12-E398-44AF-9859-F3CA6C63BA6B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "7F6FB57C-2BC7-487C-96DD-132683AEB35D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_serverless:-:*:*:*:*:*:*:*", "matchCriteriaId": "77675CB7-67D7-44E9-B7FF-D224B3341AA5"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_gitops:-:*:*:*:*:*:*:*", "matchCriteriaId": "C0AAA300-691A-4957-8B69-F6888CC971B1"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_pipelines:-:*:*:*:*:*:*:*", "matchCriteriaId": "45937289-2D64-47CB-A750-5B4F0D4664A0"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_developer_tools_and_services:-:*:*:*:*:*:*:*", "matchCriteriaId": "97321212-0E07-4CC2-A917-7B5F61AB9A5A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_data_foundation:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "0E2C021C-A9F0-4EB4-ADED-81D8B57B4563"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_api_for_data_protection:-:*:*:*:*:*:*:*", "matchCriteriaId": "7BF8EFFB-5686-4F28-A68F-1A8854E098CE"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_virtualization:4:*:*:*:*:*:*:*", "matchCriteriaId": "9C877879-B84B-471C-80CF-0656521CA8AB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:storage:3.0:*:*:*:*:*:*:*", "matchCriteriaId": "379A5883-F6DF-41F5-9403-8D17F6605737"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:discovery:-:*:*:*:*:*:*:*", "matchCriteriaId": "B5B1D946-5978-4818-BF21-A43D9C1365E1"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_dev_spaces:-:*:*:*:*:*:*:*", "matchCriteriaId": "99B8A88B-0B31-4CFF-AFD7-C9D3DDD5790D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:cert-manager_operator_for_red_hat_openshift:-:*:*:*:*:*:*:*", "matchCriteriaId": "6D5A7736-A403-4617-8790-18E46CB74DA6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:keycloak:-:*:*:*:*:*:*:*", "matchCriteriaId": "6E0DE4E1-5D8D-40F3-8AC8-C7F736966158"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:jboss_enterprise_application_platform:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "88BF3B2C-B121-483A-AEF2-8082F6DA5310"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:single_sign-on:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "9EFEC7CA-8DDA-48A6-A7B6-1F1D14792890"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:advanced_cluster_security:3.0:*:*:*:*:*:*:*", "matchCriteriaId": "F0FD736A-8730-446A-BA3A-7B608DB62B0E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:advanced_cluster_security:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4C504B6-3902-46E2-82B7-48AEC9CDD48D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:golang:crypto:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.17.0", "matchCriteriaId": "F92E56DF-98DF-4328-B37E-4D5744E4103D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:russh_project:russh:*:*:*:*:*:rust:*:*", "versionEndExcluding": "0.40.2", "matchCriteriaId": "AC12508E-3C31-44EA-B4F3-29316BE9B189"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sftpgo_project:sftpgo:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.5.6", "matchCriteriaId": "1750028C-698D-4E84-B727-8A155A46ADEB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:erlang:erlang\\/otp:*:*:*:*:*:*:*:*", "versionEndExcluding": "26.2.1", "matchCriteriaId": "3A9A8E99-7F4A-4B74-B86B-8B3E8B2A8776"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:matez:jsch:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.2.15", "matchCriteriaId": "61119DB3-4336-4D3B-863A-0CCF4146E5C1"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libssh2:libssh2:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.11.10", "matchCriteriaId": "F9DCCF91-FA48-406D-B620-D3C8F066FACB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:asyncssh_project:asyncssh:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.14.2", "matchCriteriaId": "FAE46983-0ABC-49F7-AC18-A78FAC7E73AA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dropbear_ssh_project:dropbear_ssh:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022.83", "matchCriteriaId": "06BF3368-F232-4E6B-883E-A591EED5C827"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jadaptive:maverick_synergy_java_ssh_api:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.1.0-snapshot", "matchCriteriaId": "36531FB6-5682-4BF1-9785-E9D6D1C4207B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ssh:ssh:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.11", "matchCriteriaId": "514ED687-0D7B-479B-82C5-7EB1A5EEC94C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:thorntech:sftp_gateway_firmware:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.4.6", "matchCriteriaId": "83B1AF39-C0B9-4031-B19A-BDDD4F337273"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netgate:pfsense_plus:*:*:*:*:*:*:*:*", "versionEndIncluding": "23.09.1", "matchCriteriaId": "2B71B0EF-888E-45E2-A055-F59CDCC1AFC7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netgate:pfsense_ce:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.7.2", "matchCriteriaId": "8F23CDF7-2881-4B4E-B84F-4E04F4ED8CCF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:crushftp:crushftp:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.6.0", "matchCriteriaId": "C1795F7A-203F-400E-B09C-0FAF16D01CFC"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:connectbot:sshlib:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.2.22", "matchCriteriaId": "0D79DDDD-02F0-4C12-BE7F-1B9DF1722C7A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:apache:sshd:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.11.0", "matchCriteriaId": "E2D7B0CA-C01F-4296-9425-48299E3889C5"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:apache:sshj:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.37.0", "matchCriteriaId": "1C3EB0B8-9E76-4146-AB02-02E20B91D55C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tinyssh:tinyssh:*:*:*:*:*:*:*:*", "versionEndIncluding": "20230101", "matchCriteriaId": "0582468A-149B-429F-978A-2AEDF4BE2606"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:trilead:ssh2:6401:*:*:*:*:*:*:*", "matchCriteriaId": "7E4BAF06-5A79-46D7-8C4F-E670BD6B7C2D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:kitty_project:kitty:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.76.1.13", "matchCriteriaId": "4C19DD32-7922-4DBD-BC4A-AFB5E6B7A5C2"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gentoo:security:-:*:*:*:*:*:*:*", "matchCriteriaId": "76BDAFDE-4515-42E6-820F-38AF4A786CF2"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:debian:debian_linux:-:*:*:*:*:*:*:*", "matchCriteriaId": "5920923E-0D52-44E5-801D-10B82846ED58"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/176280/Terrapin-SSH-Connection-Weakening.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.openwall.com/lists/oss-security/2023/12/18/3", "source": "cve@mitre.org", "tags": ["Mailing List"]}, {"url": "http://www.openwall.com/lists/oss-security/2023/12/19/5", "source": "cve@mitre.org", "tags": ["Mailing List"]}, {"url": "http://www.openwall.com/lists/oss-security/2023/12/20/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Mitigation"]}, {"url": "https://access.redhat.com/security/cve/cve-2023-48795", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://arstechnica.com/security/2023/12/hackers-can-break-ssh-channel-integrity-using-novel-data-corruption-attack/", "source": "cve@mitre.org", "tags": ["Press/Media Coverage"]}, {"url": "https://bugs.gentoo.org/920280", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2254210", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://bugzilla.suse.com/show_bug.cgi?id=1217950", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://crates.io/crates/thrussh/versions", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://filezilla-project.org/versions.php", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://forum.netgate.com/topic/184941/terrapin-ssh-attack", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://git.libssh.org/projects/libssh.git/commit/?h=stable-0.10&id=10e09e273f69e149389b3e0e5d44b8c221c2e7f6", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/NixOS/nixpkgs/pull/275249", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/PowerShell/Win32-OpenSSH/issues/2189", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/PowerShell/Win32-OpenSSH/releases/tag/v9.5.0.0p1-Beta", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/TeraTermProject/teraterm/commit/7279fbd6ef4d0c8bdd6a90af4ada2899d786eec0", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/TeraTermProject/teraterm/releases/tag/v5.1", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/advisories/GHSA-45x7-px36-x8w8", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/apache/mina-sshd/issues/445", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/connectbot/sshlib/commit/5c8b534f6e97db7ac0e0e579331213aa25c173ab", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/connectbot/sshlib/compare/2.2.21...2.2.22", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/cyd01/KiTTY/issues/520", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/drakkan/sftpgo/releases/tag/v2.5.6", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/erlang/otp/blob/d1b43dc0f1361d2ad67601169e90a7fc50bb0369/lib/ssh/doc/src/notes.xml#L39-L42", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/erlang/otp/releases/tag/OTP-26.2.1", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/golang/crypto/commit/9d2ee975ef9fe627bf0a6f01c1f69e8ef1d4f05d", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/hierynomus/sshj/issues/916", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/janmojzis/tinyssh/issues/81", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/jtesta/ssh-audit/commit/8e972c5e94b460379fe0c7d20209c16df81538a5", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/libssh2/libssh2/pull/1291", "source": "cve@mitre.org", "tags": ["Mitigation"]}, {"url": "https://github.com/mkj/dropbear/blob/17657c36cce6df7716d5ff151ec09a665382d5dd/CHANGES#L25", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/mscdex/ssh2/commit/97b223f8891b96d6fc054df5ab1d5a1a545da2a3", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/mwiede/jsch/compare/jsch-0.2.14...jsch-0.2.15", "source": "cve@mitre.org", "tags": ["Product"]}, {"url": "https://github.com/mwiede/jsch/issues/457", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/mwiede/jsch/pull/461", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/net-ssh/net-ssh/blob/2e65064a52d73396bfc3806c9196fc8108f33cd8/CHANGES.txt#L14-L16", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/openssh/openssh-portable/commits/master", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/paramiko/paramiko/issues/2337", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/proftpd/proftpd/blob/0a7ea9b0ba9fcdf368374a226370d08f10397d99/RELEASE_NOTES", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/proftpd/proftpd/blob/d21e7a2e47e9b38f709bec58e3fa711f759ad0e1/RELEASE_NOTES", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/proftpd/proftpd/blob/master/RELEASE_NOTES", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/proftpd/proftpd/issues/456", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/rapier1/hpn-ssh/releases", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/ronf/asyncssh/blob/develop/docs/changes.rst", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/ronf/asyncssh/tags", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/ssh-mitm/ssh-mitm/issues/165", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/warp-tech/russh/releases/tag/v0.40.2", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://gitlab.com/libssh/libssh-mirror/-/tags", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://groups.google.com/g/golang-announce/c/-n5WqVC18LQ", "source": "cve@mitre.org", "tags": ["Mailing List"]}, {"url": "https://groups.google.com/g/golang-announce/c/qA3XtxvMUyg", "source": "cve@mitre.org", "tags": ["Mailing List"]}, {"url": "https://help.panic.com/releasenotes/transmit5/", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://jadaptive.com/important-java-ssh-security-update-new-ssh-vulnerability-discovered-cve-2023-48795/", "source": "cve@mitre.org", "tags": ["Press/Media Coverage"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/12/msg00017.html", "source": "cve@mitre.org", "tags": ["Mailing List"]}, {"url": "https://lists.debian.org/debian-lts-announce/2024/01/msg00013.html", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2024/01/msg00014.html", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/33XHJUB6ROFUOH2OQNENFROTVH6MHSHA/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/3CAYYW35MUTNO65RVAELICTNZZFMT2XS/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/3JIMLVBDWOP4FUPXPTB4PGHHIOMGFLQE/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/3YQLUQWLIHDB5QCXQEX7HXHAWMOKPP5O/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/6Y74KVCPEPT4MVU3LHDWCNNOXOE5ZLUR/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/APYIXIQOVDCRWLHTGB4VYMAUIAQLKYJ3/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/BL5KTLOSLH2KHRN4HCXJPK3JUVLDGEL6/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/C3AFMZ6MH2UHHOPIWT5YLSFV3D2VB3AC/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/CHHITS4PUOZAKFIUBQAQZC7JWXMOYE4B/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/F7EYCFQCTSGJXWO3ZZ44MGKFC5HA7G3Y/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/HYEDEXIKFKTUJIN43RG4B7T5ZS6MHUSP/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/I724O3LSRCPO4WNVIXTZCT4VVRMXMMSG/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/KEOTKBUPZXHE3F352JBYNTSNRXYLWD6P/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/KMZCVGUGJZZVDPCVDA7TEB22VUCNEXDD/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/L5Y6MNNVAPIJSXJERQ6PKZVCIUXSNJK7/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LZQVUHWVWRH73YBXUQJOD6CKHDQBU3DM/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/MKQRBF3DWMWPH36LBCOBUTSIZRTPEZXB/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/QI3EHAHABFQK7OABNCSF5GMYP6TONTI7/", "source": "cve@mitre.org"}, {"url": "https://matt.ucc.asn.au/dropbear/CHANGES", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://nest.pijul.com/pijul/thrussh/changes/D6H7OWTTMHHX6BTB3B6MNBOBX2L66CBL4LGSEUSAI2MCRCJDQFRQC", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://news.ycombinator.com/item?id=38684904", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://news.ycombinator.com/item?id=38685286", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://news.ycombinator.com/item?id=38732005", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://nova.app/releases/#v11.8", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://oryx-embedded.com/download/#changelog", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://psirt.global.sonicwall.com/vuln-detail/SNWLID-2024-0002", "source": "cve@mitre.org"}, {"url": "https://roumenpetrov.info/secsh/#news20231220", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://security-tracker.debian.org/tracker/CVE-2023-48795", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://security-tracker.debian.org/tracker/source-package/libssh2", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://security-tracker.debian.org/tracker/source-package/proftpd-dfsg", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://security-tracker.debian.org/tracker/source-package/trilead-ssh2", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://security.gentoo.org/glsa/202312-16", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202312-17", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20240105-0004/", "source": "cve@mitre.org"}, {"url": "https://support.apple.com/kb/HT214084", "source": "cve@mitre.org"}, {"url": "https://thorntech.com/cve-2023-48795-and-sftp-gateway/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://twitter.com/TrueSkrillor/status/1736774389725565005", "source": "cve@mitre.org", "tags": ["Press/Media Coverage"]}, {"url": "https://ubuntu.com/security/CVE-2023-48795", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://winscp.net/eng/docs/history#6.2.2", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://www.bitvise.com/ssh-client-version-history#933", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://www.bitvise.com/ssh-server-version-history", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://www.chiark.greenend.org.uk/~sgtatham/putty/changes.html", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://www.crushftp.com/crush10wiki/Wiki.jsp?page=Update", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://www.debian.org/security/2023/dsa-5586", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://www.debian.org/security/2023/dsa-5588", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://www.freebsd.org/security/advisories/FreeBSD-SA-23:19.openssh.asc", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://www.lancom-systems.de/service-support/allgemeine-sicherheitshinweise#c243508", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://www.netsarang.com/en/xshell-update-history/", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://www.openssh.com/openbsd.html", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://www.openssh.com/txt/release-9.6", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://www.openwall.com/lists/oss-security/2023/12/18/2", "source": "cve@mitre.org", "tags": ["Mailing List"]}, {"url": "https://www.openwall.com/lists/oss-security/2023/12/20/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Mitigation"]}, {"url": "https://www.paramiko.org/changelog.html", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://www.reddit.com/r/sysadmin/comments/18idv52/cve202348795_why_is_this_cve_still_undisclosed/", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://www.suse.com/c/suse-addresses-the-ssh-v2-protocol-terrapin-attack-aka-cve-2023-48795/", "source": "cve@mitre.org", "tags": ["Press/Media Coverage"]}, {"url": "https://www.terrapin-attack.com", "source": "cve@mitre.org", "tags": ["Exploit"]}, {"url": "https://www.theregister.com/2023/12/20/terrapin_attack_ssh", "source": "cve@mitre.org", "tags": ["Press/Media Coverage"]}, {"url": "https://www.vandyke.com/products/securecrt/history.txt", "source": "cve@mitre.org", "tags": ["Release Notes"]}]}, "github_commit_url": "https://github.com/TeraTermProject/teraterm/commit/7279fbd6ef4d0c8bdd6a90af4ada2899d786eec0"}}