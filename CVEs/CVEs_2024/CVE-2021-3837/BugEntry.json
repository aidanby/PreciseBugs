{"buggy_code": ["/**\n * login controller, to authenticate users\n */\nvar emailModel = require('../../models/email.js');\nvar userModel = require('../../models/user.js');\nvar notifEmails = require('../../models/notifEmails.js');\nvar userApi = require('../../controllers/api/user.js');\n\nvar md5 = userModel.md5;\nvar loggingTemplate = require('../../templates/logging.js');\n\nexports.handleRequest = function (request, form, response, ignorePassword) {\n  form = form || {};\n  if (form.password && !form.md5) form.md5 = md5(form.password);\n\n  request.logToConsole('login.handleRequest', {\n    action: form.action,\n    email: form.email,\n    md5: form.md5,\n  });\n\n  function renderJSON(json) {\n    response[form.ajax == 'iframe' ? 'renderWrappedJSON' : 'renderJSON'](json);\n  }\n\n  // in case of successful login\n  function renderRedirect(url, user) {\n    request.session.whydUid = (user || {}).id;\n    if (!form.ajax) response.renderHTML(loggingTemplate.htmlRedirect(url));\n    else {\n      var json = { redirect: url };\n      if (form.includeUser) {\n        userApi.fetchUserData(user, function (user) {\n          json.user = user;\n          renderJSON(json);\n        });\n      } else renderJSON(json);\n    }\n  }\n\n  function renderForm(form) {\n    delete request.session;\n    if (form.ajax) renderJSON(form);\n    else response.renderHTML(loggingTemplate.renderLoginPage(form));\n  }\n\n  if (form.action === 'logout') {\n    request.session.destroy(function (err) {\n      if (err) {\n        console.error('error from request.session.destroy()', err);\n        form.error = err;\n      }\n      console.log('logout result', form.error);\n      renderForm(form);\n    });\n    return;\n  } else if (form.email) {\n    form.email = emailModel.normalize(form.email);\n\n    userModel[form.email.indexOf('@') > -1 ? 'fetchByEmail' : 'fetchByHandle'](\n      form.email,\n      function (dbUser) {\n        if (!dbUser) {\n          form.error = \"Are you sure? We don't recognize your email address!\";\n        } else if (form.action == 'forgot') {\n          notifEmails.sendPasswordReset(dbUser._id, dbUser.pwd, form.redirect);\n          /*form.error*/ form.ok =\n            'We just sent you an email to reset your password, wait for it!';\n        } else if (\n          !ignorePassword &&\n          !form.md5 /*(!form.password || form.password == \"password\")*/\n        ) {\n          form.error = 'Please enter your password below:';\n        } else if (\n          form.action == 'login' &&\n          (ignorePassword || dbUser.pwd == form.md5)\n        ) {\n          // console.log('ok, user logged in as: ' + dbUser.name);\n          // console.log('form.fbUid', form.fbUid);\n          if (form.fbUid)\n            userModel.update(dbUser._id, {\n              $set: {\n                fbId: form.fbUid,\n                fbTok: form.fbTok, // access token provided on last facebook login\n              },\n            });\n          renderRedirect(form.redirect || '/', dbUser);\n          return; // prevent default response (renderForm)\n        } else if (form.action != 'logout') {\n          form.wrongPassword = 1;\n          form.error = 'Your password seems wrong... Try again!';\n        }\n\n        console.log('login result', form.error);\n        renderForm(form);\n      }\n    );\n  } else renderForm(form);\n};\n\nexports.controller = function (request, getParams, response) {\n  if (request.method.toLowerCase() === 'post')\n    exports.handleRequest(request, request.body, response);\n  else exports.handleRequest(request, getParams, response);\n};\n", "var http = require('http');\nvar querystring = require('querystring');\nvar errorTemplate = require('../templates/error.js');\nconst snip = require('../snip.js');\n\nconst genReqLogLine = ({ head, method, path, params, suffix }) =>\n  !process.appParams.color\n    ? [\n        head,\n        method,\n        path[0] + (path.length > 1 ? '?' + path.slice(1).join('?') : ''),\n        suffix,\n        params,\n      ]\n    : [\n        head.grey,\n        method.cyan,\n        path[0].green +\n          (path.length > 1 ? '?' + path.slice(1).join('?') : '').yellow,\n        suffix.white,\n        params.grey,\n      ];\n\nhttp.IncomingMessage.prototype.logToConsole = function (suffix, params) {\n  console.log(\n    ...genReqLogLine({\n      head: '\u25b6 ' + new Date().toISOString(),\n      method: this.method,\n      path: this.url.split('?'),\n      params:\n        typeof params === 'object'\n          ? JSON.stringify(snip.formatPrivateFields(params))\n          : '',\n      suffix: suffix ? '(' + suffix + ')' : '',\n    })\n  );\n};\n\nvar config = require('./config.js');\nvar mongodb = require('./mongodb.js');\nvar loggingTemplate = require('../templates/logging.js');\nvar renderUnauthorizedPage = loggingTemplate.renderUnauthorizedPage;\n\n// ========= USER AGENT STUFF\n\n/**\n * Gets the http referer of a request\n */\nhttp.IncomingMessage.prototype.getReferer = function () {\n  return this.headers['referrer'] || this.headers['referer'];\n};\n\n// ========= COOKIE STUFF\n\n/**\n * Generates a user session cookie string\n * that can be supplied to a Set-Cookie HTTP header.\n */\n/*\nexports.makeCookie = function(user) {\n\tvar date = new Date((new Date()).getTime() + 1000 * 60 * 60 * 24 * 365);\n\treturn 'whydUid=\"'+(user.id || '')+'\"; Expires=' + date.toGMTString();\n};\n*/\n\n/**\n * Transforms cookies found in the request into an object\n */\nhttp.IncomingMessage.prototype.getCookies = (function () {\n  //var cookieReg = /([^=\\s]+)=\"([^\"]*)\"/;\n  return function () {\n    //console.log(\"cookies raw:\", this.headers.cookie);\n    if (!this.headers.cookie) return null;\n    var cookiesArray = this.headers.cookie.split(';');\n    //console.log(\"cookies array:\", cookiesArray);\n    var cookies = {};\n    for (let i = 0; i < cookiesArray.length; i++) {\n      //var match = cookiesArray[i].trim().match(cookieReg);\n      //if (match)\n      cookiesArray[i] = cookiesArray[i].trim();\n      var separ = cookiesArray[i].indexOf('=');\n      if (separ > 0)\n        cookies[cookiesArray[i].substr(0, separ)] = cookiesArray[i].substring(\n          separ + 1\n        );\n    }\n    //console.log(\"cookies object:\", cookies);\n    return cookies;\n  };\n})();\n\n/**\n * Return facebook's \"fbs_\" cookie object from the request\n */\nhttp.IncomingMessage.prototype.getFacebookCookie = function () {\n  var cookies = this.getCookies();\n  //console.log(\"cookies:\", cookies);\n  for (let i in cookies)\n    if (i.startsWith('fbs_')) {\n      const cookie = {},\n        cookieArray = cookies[i].split('&');\n      for (let j in cookieArray) {\n        var cookieItem = cookieArray[j].split('=');\n        cookie[cookieItem[0]] = cookieItem[1];\n      }\n      console.log('found facebook cookie'); //, cookie);\n      return cookie;\n    } else if (i.startsWith('fbsr_')) {\n      // https://developers.facebook.com/docs/authentication/signed_request/\n      try {\n        let cookie = cookies[i].split('.')[1];\n        cookie = Buffer.from(cookie /*|| \"\"*/, 'base64').toString('ascii');\n        cookie = JSON.parse(cookie);\n        console.log('found secure facebook cookie'); //, cookie);\n        return cookie;\n      } catch (e) {\n        console.log('secure facebook connect error: ', e);\n      }\n    }\n  return null;\n};\n\n// ========= USER ACCESSORS\n\n/**\n * Returns the logged in user's facebook uid, from its cookie\n */\nhttp.IncomingMessage.prototype.getFbUid = function () {\n  var fbCookie = this.getFacebookCookie();\n  if (fbCookie && fbCookie.uid)\n    this.getFbUid = function () {\n      return fbCookie.uid;\n    };\n  else if (fbCookie && fbCookie.user_id)\n    this.getFbUid = function () {\n      return fbCookie.user_id;\n    };\n  else return null;\n  return this.getFbUid();\n};\n\n/**\n * Returns the logged in user's uid, from its openwhyd session cookie\n */\nhttp.IncomingMessage.prototype.getUid = function () {\n  /*\n\tvar uid = (this.getCookies() || {})[\"whydUid\"];\n\tif (uid) uid = uid.replace(/\\\"/g, \"\");\n\t//if (uid) console.log(\"found openwhyd session cookie\", uid);\n\treturn uid;\n\t*/\n  return (this.session || {}).whydUid;\n};\n\n/**\n * Returns the logged in user as an object {_id, id, fbId, name, img}\n */\nhttp.IncomingMessage.prototype.getUser = function () {\n  var uid = this.getUid();\n  if (uid) {\n    var user = mongodb.usernames[uid];\n    if (user) user.id = '' + user._id;\n    return user;\n  } else return null;\n};\n\n//http.IncomingMessage.prototype.getUserFromFbUid = mongodb.getUserFromFbUid;\n\nhttp.IncomingMessage.prototype.getUserFromId = mongodb.getUserFromId;\n\nhttp.IncomingMessage.prototype.getUserNameFromId = mongodb.getUserNameFromId;\n\n// ========= LOGIN/SESSION/PRIVILEGES STUFF\n\n/**\n * Checks that a registered user is logged in, and return that user, or show an error page\n */\nhttp.IncomingMessage.prototype.checkLogin = function (response, format) {\n  var user = this.getUser();\n  //console.log(\"checkLogin, cached record for logged in user: \", user);\n  if (!user /*|| !user.name*/) {\n    if (response) {\n      if (format && format.toLowerCase() == 'json')\n        errorTemplate.renderErrorResponse(\n          { errorCode: 'REQ_LOGIN' },\n          response,\n          'json'\n        );\n      else response.renderHTML(renderUnauthorizedPage());\n    }\n    return false;\n  }\n  return user;\n};\n\nhttp.IncomingMessage.prototype.isUserAdmin = exports.isUserAdmin = function (\n  user\n) {\n  return user.email && config.adminEmails[user.email];\n};\n\nhttp.IncomingMessage.prototype.isAdmin = function () {\n  return this.isUserAdmin(this.getUser());\n};\n\nhttp.IncomingMessage.prototype.checkAdmin = function (response, format) {\n  var user = this.checkLogin(response, format);\n  if (!user) return false;\n  else if (!exports.isUserAdmin(user)) {\n    console.log(\n      'access restricted, user is not an admin: ',\n      user._id || user.id\n    );\n    response && response.legacyRender('nice try! ;-)');\n    return false;\n  }\n  return user;\n};\n\n// ========= HTTP RESPONSE SNIPPETS\n\nhttp.ServerResponse.prototype.renderHTML = function (html, statusCode) {\n  return this.legacyRender(\n    html,\n    null,\n    { 'content-type': 'text/html; charset=utf-8' },\n    statusCode\n  );\n};\n\nhttp.ServerResponse.prototype.renderJSON = function (json, statusCode) {\n  return this.legacyRender(\n    json,\n    null,\n    { 'content-type': 'application/json; charset=utf-8' },\n    statusCode\n  );\n};\n\nhttp.ServerResponse.prototype.renderWrappedJSON = function (json, statusCode) {\n  this.renderHTML(\n    '<!DOCTYPE html><html><body><textarea>' +\n      JSON.stringify(json) +\n      '</textarea></body></html>',\n    statusCode\n  );\n};\n\nhttp.ServerResponse.prototype.renderText = function (json, statusCode) {\n  return this.legacyRender(\n    json,\n    null,\n    { 'content-type': 'text/text; charset=utf-8' },\n    statusCode\n  );\n};\n\n// TODO: this function is overrided by Express => delete it to prevent ambiguity\nhttp.ServerResponse.prototype.redirect = function (url) {\n  return this.renderHTML(loggingTemplate.htmlRedirect(url));\n};\n\nhttp.ServerResponse.prototype.safeRedirect = function (url) {\n  const fullURL = new URL(url, config.urlPrefix);\n  if (`${fullURL.protocol}//${fullURL.host}` !== config.urlPrefix)\n    return this.forbidden();\n  this.redirect(url);\n};\n\nhttp.ServerResponse.prototype.redirectWithTracking = function (url, title) {\n  return this.renderHTML(\n    loggingTemplate.renderRedirectPageWithTracking(url, title)\n  );\n};\n\nhttp.ServerResponse.prototype.renderIframe = function (url, metaOverrides) {\n  return this.renderHTML(loggingTemplate.renderIframe(url, metaOverrides));\n};\n\nhttp.ServerResponse.prototype.temporaryRedirect = function (_url, _reqParams) {\n  let url = '' + _url;\n  if (_reqParams /*request.method.toLowerCase() == \"get\"*/) {\n    const reqParams = querystring.stringify(_reqParams);\n    if (reqParams.length) url += '?' + reqParams;\n  }\n  this.redirect(307, url); // see https://expressjs.com/fr/4x/api.html#res.redirect\n};\n\nhttp.ServerResponse.prototype.badRequest = function (error) {\n  this.status(400).send(error ? '' + error : 'BAD REQUEST');\n};\n\nhttp.ServerResponse.prototype.forbidden = function (error) {\n  this.status(403).send(error ? '' + error : 'FORBIDDEN');\n};\n\nhttp.ServerResponse.prototype.notFound = function () {\n  this.status(404).send();\n};\n", "// various tools by Adrien Joly\n// tests: tests/tess-snips.js\n\nvar fs = require('fs');\nvar urlModule = require('url');\nvar http = require('http');\nvar https = require('https');\nvar querystring = require('querystring');\n\nvar firstWeek = new Date('Monday January 3, 2011 08:00'); // week #1 = 1st of january 2010\n\n// privacy helper: anonymise email address\nexports.formatEmail = function (emailAddr) {\n  if (typeof emailAddr !== 'string' || emailAddr.length < 1)\n    return '<invalid_email>';\n  const [name, domain] = emailAddr.split('@');\n  return name.substring(0, 1).concat('*********@').concat(domain);\n};\n\nexports.formatPrivateFields = (obj) => {\n  if (typeof obj !== 'object') return obj;\n  const res = { ...obj };\n  if (typeof obj.email === 'string') res.email = exports.formatEmail(obj.email);\n  if (typeof obj.md5 === 'string') res.md5 = '<MD5_HASH>';\n  return res;\n};\n\n// privacy-enforcing console.log helper\nexports.console = {\n  log(...args) {\n    const filteredArgs = args.map(exports.formatPrivateFields);\n    console.log(...filteredArgs);\n  },\n};\n\nexports.getWeekNumber = function (date) {\n  return date && Math.floor(1 + (date - firstWeek) / 1000 / 60 / 60 / 24 / 7);\n};\n\nexports.weekNumberToDate = function (weekNumber) {\n  return new Date(firstWeek.getTime() + 7 * 24 * 60 * 60 * 1000 * weekNumber);\n};\n\nexports.forEachFileLine = function (fileName, lineHandler) {\n  var buffer = '';\n  function processBuffer(flush) {\n    var parts = buffer.replace('\\r', '').split('\\n');\n    buffer = !flush && parts.pop();\n    parts.forEach(lineHandler);\n  }\n  fs.createReadStream(fileName)\n    .addListener('data', function (data) {\n      buffer += data.toString();\n      processBuffer();\n    })\n    .addListener('end', function () {\n      processBuffer(true);\n      lineHandler();\n    });\n};\n\n// =========================================================================\n// string manipulation / regular expressions\n\nexports.removeAccents = function (str) {\n  return !str\n    ? ''\n    : str\n        .replace(/[\u00e0\u00e2\u00e4]/gi, 'a')\n        .replace(/[\u00e9\u00e8\u00ea\u00eb]/gi, 'e')\n        .replace(/[\u00ee\u00ef]/gi, 'i')\n        .replace(/[\u00f4\u00f6]/gi, 'o')\n        .replace(/[\u00f9\u00fb\u00fc]/gi, 'u');\n};\n\n//var regexUrl = /(\\b(https?|ftp|file):\\/\\/[-A-Z0-9+&@#\\/%?=~_|!:,.;]*[-A-Z0-9+&@#\\/%=~_|])/ig;\nvar regexUrl =\n  /(\\b(https?|ftp|file):\\/\\/([-A-Z0-9+&@#$*'()%?=~_|!:,.;]*)[-A-Z0-9+&@#/%?=~_|!:,.;]*[-A-Z0-9+&@#/%=~_|])/gi;\nvar regexUrl2 = /(\\b(https?|ftp|file):\\/\\/([^/\\s]*)[^\\s]*)/gi;\n\nexports.replaceURLWithHTMLLinks = function (text) {\n  return String(text || '').replace(regexUrl2, \"<a href='$1'>$3...</a>\");\n};\n\nexports.replaceURLWithFullHTMLLinks = function (text) {\n  return String(text || '').replace(regexUrl, \"<a href='$1'>$1</a>\");\n};\n\nexports.shortenURLs = function (text) {\n  return String(text || '').replace(regexUrl, '$3...');\n};\n\n// source: http://css-tricks.com/snippets/javascript/htmlentities-for-javascript/\nexports.htmlEntities = function (str) {\n  return String(str || '')\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;');\n};\n\nexports.addSlashes = function (str) {\n  return typeof str == 'string'\n    ? str.replace(/\\\\/g, '\\\\\\\\').replace(/'/g, \"\\\\'\").replace(/\"/g, '\\\\\"')\n    : str;\n};\n\nexports.sanitizeJsStringInHtml = function (str) {\n  return exports.htmlEntities(exports.addSlashes(str || ''));\n};\n\nvar timeScales = [\n  { 'minute(s)': 60 },\n  { 'hour(s)': 60 },\n  { 'day(s)': 24 },\n  { 'month(s)': 30 },\n  { 'year(s)': 12 },\n];\n\nexports.renderTimestamp = function (timestamp) {\n  var t = timestamp / 1000,\n    lastScale = 'second(s)';\n  for (let i in timeScales) {\n    var scaleTitle;\n    for (scaleTitle in timeScales[i]);\n    var scaleVal = timeScales[i][scaleTitle];\n\n    if (t / scaleVal < 1) break;\n    t = t / scaleVal;\n    lastScale = scaleTitle;\n  }\n  var rounded = Math.round(t);\n  return rounded + ' ' + lastScale.replace(/\\(s\\)/g, rounded > 1 ? 's' : '');\n};\n\nexports.MONTHS_SHORT = [\n  'Jan',\n  'Feb',\n  'Mar',\n  'Apr',\n  'May',\n  'Jun',\n  'Jul',\n  'Aug',\n  'Sep',\n  'Oct',\n  'Nov',\n  'Dec',\n];\n\nexports.renderShortMonthYear = function (date) {\n  var t = new Date(date);\n  var sameYear = false; //(new Date()).getFullYear() == t.getFullYear();\n  return (\n    exports.MONTHS_SHORT[t.getMonth()] + (sameYear ? '' : ' ' + t.getFullYear())\n  );\n};\n\nexports.padNumber = function (str, n) {\n  var ret = '' + str;\n  while (\n    ret.length < n // pad with leading zeroes\n  )\n    ret = '0' + ret;\n  return ret;\n};\n\nexports.renderTime = function (date) {\n  var t = new Date(date);\n  return t.getHours() + ':' + exports.padNumber(t.getMinutes(), 2);\n};\n\n// minimal sanitization of function name: remove javascript's special / control characters\nexports.sanitizeJsIdentifier = function (id) {\n  return ('' + id).replace(/\\/\\\\\\n\\(\\)\\[\\];\\./g, ' ');\n};\n\nexports.renderJsCallback = function (fctName, obj) {\n  return (\n    exports.sanitizeJsIdentifier(fctName) +\n    '(' +\n    (typeof obj == 'object' ? JSON.stringify(obj) : '\"' + obj + '\"') +\n    ');'\n  );\n};\n\n// =========================================================================\n// music track related functions\n\nexports.cleanTrackName = function (str) {\n  return !str\n    ? ''\n    : str\n        .trim()\n        .replace(/^\\d+([-./\\\\]\\d+)+\\s+/, '') // remove prefixing date\n        .replace(/^\\d+[.]+\\s+/, '') // remove prefixing track number\n        .replace(/^#\\d+\\s+/, '') // remove prefixing rank\n        .replace(/\\([^)]*\\)/g, '') // remove parentheses\n        .replace(/\\[[^]]*\\]/g, '') // remove brackets\n        .replace(/\\s+/, ' ') // remove extra/duplicate whitespace\n        .trim();\n};\n\n// to run on cleaned track names, for better performance\nexports.normalizeArtistName = function (artistName) {\n  return exports\n    .removeAccents(artistName.trim().toLowerCase())\n    .replace(/[^a-z0-9]/g, ''); // remove non alpha characters\n};\n\nvar reQuotes = /\"[^\")]*\"/g;\nvar reSeparator = /-+\\s+/g;\nvar reOnlyDigits = /^\\d+$/;\n\n// to run on cleaned track names, for better performance\nexports.detectArtistName = function (trackName) {\n  var quoted = trackName.match(reQuotes) || [];\n  var splitted = (trackName || '').replace(reQuotes, ' - ').split(reSeparator);\n  // remove track title (last item of the string, or quoted items)\n  splitted.length = splitted.length - (quoted.length || 1);\n  for (let i in splitted) {\n    var normalized = exports.normalizeArtistName(splitted[i]);\n    if (normalized && !reOnlyDigits.test(normalized)) return splitted[i].trim();\n  }\n  return null;\n};\n\n// to run on cleaned track names, for better performance\nexports.detectTrackFields = function (trackName) {\n  var quoted = trackName.match(reQuotes) || [];\n  if (quoted.length == 1) return JSON.stringify(quoted);\n  else return null;\n};\n\n// =========================================================================\n// data structures\n\nexports.arrayHas = function (array, value) {\n  if (array) for (let i in array) if (value == array[i]) return true;\n  return false;\n};\n\nexports.values = function (set) {\n  var list = [];\n  for (let i in set)\n    if (set[i])\n      // TODO: remove this line\n      list.push(set[i]);\n  return list;\n};\n\nexports.mapToObjArray = function (map, keyFieldName, valueFieldName) {\n  var array = [];\n  for (let k in map) {\n    var obj = {};\n    if (keyFieldName) obj[keyFieldName] = k;\n    if (valueFieldName) obj[valueFieldName] = map[k];\n    else if (typeof map[k] == 'object')\n      for (let f in map[k]) obj[f] = map[k][f];\n    array.push(obj);\n  }\n  return array;\n};\n\nexports.arrayToSet = function (array, value) {\n  var set = {};\n  for (let i in array)\n    if (array[i])\n      // TODO: remove this line\n      set[array[i]] = value !== undefined ? value : true;\n  return set;\n};\n\nexports.objArrayToSet = function (array, attr, val) {\n  var set = {};\n  for (let i in array)\n    if (array[i] && attr in array[i]) set[array[i][attr]] = val || array[i];\n  return set;\n};\n\nexports.groupObjectsBy = function (array, attr) {\n  var r = {};\n  var path = ('' + attr).split('.');\n  if (path.length > 1) {\n    for (let i in array) {\n      const obj = array[i] || {};\n      let key = obj;\n      for (let j in path) {\n        key = (key || {})[path[j]];\n      }\n      if (key) (r[key] = r[key] || []).push(obj);\n    }\n  } else {\n    for (let i in array) {\n      const obj = array[i] || {};\n      let key = obj[attr];\n      if (key)\n        // TODO: fix this line\n        (r[key] = r[key] || []).push(obj);\n    }\n  }\n  return r;\n};\n\nexports.removeDuplicates = function (array, keyFieldName) {\n  if (keyFieldName)\n    return exports.mapToObjArray(\n      exports.objArrayToSet(array, keyFieldName),\n      keyFieldName\n    );\n  else return Object.keys(exports.arrayToSet(array));\n};\n\nexports.objArrayToValueArray = function (array, attr) {\n  var list = [];\n  for (let i in array)\n    if (array[i] && array[i][attr])\n      // TODO: fix this line, cf line 217\n      list.push(array[i][attr]);\n  return list;\n};\n\nexports.forEachArrayItem = function (array, handler, cb) {\n  var i = 0;\n  var length = array.length;\n  (function next() {\n    setTimeout(function () {\n      if (i < length) handler(array[i++], next);\n      else if (cb) cb(array);\n    }, 0);\n  })();\n};\n\nexports.getMapFieldNames = function (map /*, firstField*/) {\n  var fieldNames = [],\n    fieldSet = {};\n  for (let i in map) {\n    for (let f in map[i])\n      if (!fieldSet[f]) {\n        // TODO: check this line\n        fieldNames.push(f);\n        fieldSet[f] = true;\n      }\n  }\n  /*if (firstField)\n\t\tfieldNames.unshift(firstField);*/\n  return fieldNames;\n};\n\nexports.excludeKeys = function (map = [], keySet = {}) {\n  const res = [];\n  for (let k in map)\n    if (!keySet[k])\n      // TODO: check this line\n      res[k] = map[k];\n  return res;\n};\n\nexports.checkMissingFields = function (obj, fieldSet) {\n  if (!obj || typeof obj !== 'object') return { error: 'object is null' };\n  for (let f in fieldSet)\n    if (fieldSet[f] && !(f in obj))\n      return { field: f, expected: true, error: 'missing field: ' + f };\n    else if (!fieldSet[f] && f in obj)\n      return { field: f, expected: false, error: 'forbidden field: ' + f };\n};\n\nexports.checkMistypedFields = function (obj, fieldTypeSet) {\n  if (!obj || typeof obj !== 'object') return { error: 'object is null' };\n  function Error(error, f) {\n    return {\n      field: f,\n      type: typeof obj[f],\n      expected: fieldTypeSet[f],\n      error: error + ': ' + f,\n    };\n  }\n  for (let f in fieldTypeSet)\n    if (fieldTypeSet[f]) {\n      if (!(f in obj)) return Error('missing field', f);\n      else if (\n        typeof obj[f] !== fieldTypeSet[f] &&\n        (fieldTypeSet[f] !== 'array' || !obj[f].splice)\n      )\n        return Error('mistyped field', f);\n    } else if (f in obj) return Error('forbidden field', f);\n};\n\n// translateFields({a,b,c}, {b:\"bb\"}) => {a,bb,c}\nexports.translateFields = function (obj, mapping) {\n  if (obj && typeof obj === 'object')\n    for (let f in mapping)\n      if (f in obj) {\n        obj[mapping[f]] = obj[f];\n        delete obj[f];\n      }\n  return obj;\n};\n\n// filterFields({a,b,c}, {b:\"bb\"}) => {bb}\nexports.filterFields = function (obj, mapping) {\n  var finalObj = {};\n  for (let field in mapping)\n    if (field in obj)\n      finalObj[mapping[field] === true ? field : mapping[field]] = obj[field];\n  return finalObj;\n};\n\n// =========================================================================\n// sorting comparators\n\nexports.descSort = function (a, b) {\n  return parseInt(b) - parseInt(a);\n};\n\nexports.ascSort = function (a, b) {\n  if (a < b) return -1;\n  if (a > b) return 1;\n  return 0;\n};\n\nexports.makeFieldSort = function (field, sortFct) {\n  return function (a, b) {\n    return sortFct(a[field], b[field]);\n  };\n};\n\n// by http://andrew.hedges.name\nexports.getLevenshteinDistance = (function () {\n  function minimator(x, y, z) {\n    if (x < y && x < z) return x;\n    if (y < x && y < z) return y;\n    return z;\n  }\n  return function (a, b) {\n    var cost,\n      m = a.length,\n      n = b.length;\n    if (m < n) {\n      var c = a;\n      a = b;\n      b = c;\n      var o = m;\n      m = n;\n      n = o;\n    }\n    var r = [];\n    r[0] = [];\n    for (let c = 0; c < n + 1; c++) r[0][c] = c;\n    for (let i = 1; i < m + 1; i++) {\n      r[i] = [];\n      r[i][0] = i;\n      for (let j = 1; j < n + 1; j++) {\n        cost = a.charAt(i - 1) == b.charAt(j - 1) ? 0 : 1;\n        r[i][j] = minimator(\n          r[i - 1][j] + 1,\n          r[i][j - 1] + 1,\n          r[i - 1][j - 1] + cost\n        );\n      }\n    }\n    return r[m][n];\n  };\n})();\n\n// =========================================================================\n// table structures\n\nexports.DataTable = function () {\n  this.table = [];\n  this.header = null; //[]; // fields\n\n  this.fromArray = (array, header) => {\n    if (header) this.header = header;\n    this.table = array;\n    return this;\n  };\n\n  this.fromMap = (map, header) => {\n    this.header = header || exports.getMapFieldNames(map);\n    //table = /*mapToTable(map, header);*/ [];\n    for (let i in map) {\n      var line = [\n        /*i*/\n      ];\n      //for (let f in map[i]) line.push(map[i][f]);\n      for (let f in this.header) line.push(map[i][this.header[f]]);\n      this.table.push(line);\n    }\n    return this;\n  };\n\n  this.sort = (fct) => {\n    this.table.sort(fct);\n    return this;\n  };\n\n  const getFullTableCopy = () => {\n    return [].concat(this.header ? [this.header] : []).concat(this.table);\n  };\n\n  const toCharSeparatedValues = (charSepar, replacement, lineSepar) => {\n    var table = getFullTableCopy();\n    var regExp = new RegExp('[' + charSepar + '\\n\"]', 'g');\n    for (let i in table) {\n      for (let j in table[i])\n        table[i][j] = ('' + table[i][j]).replace(regExp, replacement || ' ');\n      //console.log(i, table[i]);\n      table[i] = table[i].join(charSepar);\n    }\n    return table.join(lineSepar || '\\n');\n  };\n\n  this.toTsv = () => {\n    return toCharSeparatedValues('\\t');\n  };\n\n  this.toCsv = () => {\n    return toCharSeparatedValues(',');\n  };\n\n  const valToHtmlCell = (val) => {\n    return '<td>' + exports.htmlEntities(val) + '</td>';\n  };\n\n  this.toHtml = () => {\n    var table = getFullTableCopy().map((line) => {\n      return '<tr>' + line.map(valToHtmlCell).join('') + '</tr>';\n    });\n    return [\n      '<!DOCTYPE html>',\n      '<html>',\n      '<head>',\n      '<meta charset=\"utf-8\"/>',\n      '</head>',\n      '<body>',\n      '<p>' + this.table.length + ' items</p>',\n      '<table>',\n      \"<thead style='background:#ccc;'>\",\n      table.shift(),\n      '</thead>',\n      '<tbody>',\n    ]\n      .concat(table)\n      .concat(['</tbody', '</table>', '</body>', '</html>'])\n      .join('\\n');\n  };\n\n  return this;\n};\n\n// =========================================================================\n// HTTP requests\n\nvar httpDomains = {};\n\nexports.httpSetDomain = function (regex, options) {\n  if (!options) delete httpDomains[regex];\n  else httpDomains[regex] = [regex, options];\n};\n\nexports.httpDomains = httpDomains;\n\nexports.httpGetDomain = function (domain) {\n  for (let i in httpDomains)\n    if (httpDomains[i][0].test(domain)) return httpDomains[i][1];\n};\n\nfunction _httpRequest(options, callback) {\n  var data = '',\n    body = options.body;\n  if (body)\n    // => don't forget to add Content-Type and Content-Length headers in that case\n    delete options.body;\n  //console.log(\"httpRequest\", options.host + options.path);\n  var req = (options.protocol === 'http:' ? http : https)\n    .request(options, function (res) {\n      if (options.responseEncoding)\n        res.setEncoding(options.responseEncoding /*'utf-8'*/);\n      res.addListener('data', function (chunk) {\n        data += chunk.toString();\n      });\n      res.addListener('end', function () {\n        callback(null, data, res);\n      });\n    })\n    .on('error', function (err) {\n      //console.log(\"[ERR] snip.httpRequest \", url, err);\n      //console.error(\"[ERR] snip.httpRequest \", url, err);\n      callback(err);\n    });\n  req.end(body);\n  return req;\n}\n\nexports.httpRequest = function (url, options = {}, callback) {\n  var urlObj = urlModule.parse(url);\n  options.method = options.method || 'GET';\n  options.protocol = urlObj.protocol;\n  options.host = urlObj.hostname;\n  options.port = urlObj.port || (urlObj.protocol === 'https:' ? 443 : 80);\n  options.path = urlObj.path; //url; //urlObj.pathname\n  //options.headers = {'Accept':'application/json'};\n  var domainOpts = exports.httpGetDomain(options.host) || {};\n  if (domainOpts.queue) {\n    const runNext = () => {\n      //console.log(\"5-next?\", options.host, domainOpts.queue.length);\n      return domainOpts.queue.length && domainOpts.queue[0](); // run next request in line\n    };\n    //console.log(\"1-REQ\", options.host, domainOpts.queue.length);\n    domainOpts.queue.push(\n      _httpRequest.bind(null, options, function () {\n        //console.log(\"2-RES\", options.host, domainOpts.queue.length);\n        callback.apply(null, arguments);\n        //console.log(\"3-END\", options.host, domainOpts.queue.length);\n        domainOpts.queue.shift(); // request id done => dequeue\n        //console.log(\"4 =>\", options.host, domainOpts.queue.length);\n        runNext();\n      })\n    );\n    return domainOpts.queue.length == 1 ? runNext() : undefined;\n  }\n  return _httpRequest(options, callback);\n};\n\nexports.httpRequestWithParams = function (url, options, cb) {\n  if (options.params) {\n    url += '?' + querystring.stringify(options.params);\n    delete options.params;\n  }\n  if (options.body) {\n    options.body =\n      typeof options.body == 'object'\n        ? querystring.stringify(options.body)\n        : options.body;\n    options.headers = options.headers || {};\n    options.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n    options.headers['Content-Length'] = options.body.length;\n  }\n  return exports.httpRequest(url, options, cb);\n};\n\nexports.httpRequestJSON = function (url, options, callback) {\n  return exports.httpRequest(url, options, function (err, data, res) {\n    if (err) callback(err, null, res);\n    else {\n      try {\n        if (typeof data == 'string') data = JSON.parse(data);\n        callback(null, data, res);\n      } catch (e) {\n        //console.error(e);\n        callback(e, data, res);\n      }\n    }\n  });\n};\n\nfunction BasicCache() {\n  var cache = {};\n  this.get = function (url) {\n    return cache[url];\n  };\n  this.set = function (url, data) {\n    return (cache[url] = data);\n  };\n  this.dump = function () {\n    return cache;\n  };\n  this.restore = function (cacheDump) {\n    return (cache = cacheDump);\n  };\n  return this;\n}\n\nexports.HttpRequestCache = function (cache) {\n  var realRequest = exports.httpRequest;\n  this.cache = cache = cache || new BasicCache();\n  this.httpRequest = function (url, options, callback) {\n    // TODO: options are ignored for now\n    var cached = cache.get(url);\n    if (cached) {\n      //console.warn(\"used cached request for\", url, \"...\");\n      callback(null, cached);\n    } else {\n      //console.warn(\"making a real request to\", url, \"...\");\n      realRequest(url, options, function (err, data, res) {\n        cache.set(url, data);\n        callback(err, data, res);\n      });\n    }\n  };\n};\n\n// =========================================================================\n/**\n * simple implementation of an async event emitter\n * listeners are called in sequence, based on callbacks\n * inspired by: https://github.com/joyent/node/blob/master/lib/events.js\n **/\n\nfunction AsyncEventEmitter() {\n  this._eventListeners = {};\n}\n\nAsyncEventEmitter.prototype.on = function (evtName, listener) {\n  this._eventListeners[evtName] = this._eventListeners[evtName] || [];\n  this._eventListeners[evtName].push(listener);\n  return this;\n};\n\nAsyncEventEmitter.prototype.emit = function (evtName, param, callback) {\n  var listeners = this._eventListeners[evtName];\n  if (!listeners) return false;\n  listeners = listeners.slice(); // duplicate array\n  const nextListener = () => {\n    process.nextTick(() => {\n      if (listeners.length) {\n        //var args = Array.prototype.slice.call(arguments, 1);\n        listeners.pop().call(this, param, nextListener);\n      } else if (callback) callback();\n    });\n  };\n  nextListener();\n  return true;\n};\n\nexports.AsyncEventEmitter = AsyncEventEmitter;\n\n// =========================================================================\n/**\n * callWhenDone: a simple synchronized callback closure\n * @author adrienjoly, whyd\n */\nexports.callWhenDone = function (callback) {\n  var counter = 0;\n  return function (incr) {\n    if (0 == (counter += incr)) callback();\n  };\n};\n\n// =========================================================================\n/**\n * checkParams: validate an object against two sets of types properties: mandatory and optional\n * returns validated object, or throws an error.\n * @author adrienjoly, whyd\n */\nexports.checkParams = function (obj, mandatorySet, optionalSet) {\n  var finalObj = {};\n  function storeIfValid(fieldName, typeSet) {\n    if (typeof obj[fieldName] != typeSet[fieldName])\n      throw Error('invalid field value: ' + fieldName);\n    else finalObj[fieldName] = obj[fieldName];\n  }\n  obj = obj || {};\n  for (let fieldName in mandatorySet) storeIfValid(fieldName, mandatorySet);\n  for (let fieldName in optionalSet)\n    if (fieldName in obj && obj[fieldName] != null)\n      storeIfValid(fieldName, optionalSet);\n  return finalObj;\n};\n\n// =========================================================================\n\nvar MAX_NB_MENTIONS = 6;\nvar RE_MENTION = /@\\[([^\\]]*)\\]\\(user:([^)]*)\\)/gi;\n\nexports.RE_MENTION = RE_MENTION;\n\nexports.extractMentions = function (commentText) {\n  var mentions = [];\n  for (;;) {\n    // extract user id (last matched group) of each mention\n    var mentionedUid = (RE_MENTION.exec(commentText) || []).pop();\n    if (mentionedUid) mentions.push(mentionedUid);\n    else break;\n  }\n  return mentions.slice(0, MAX_NB_MENTIONS);\n};\n\n// =========================================================================\n// class to track the execution of long jobs, with callback timeout capability\n\nexports.Worker = function (options) {\n  options = options || {};\n  var jobs = 0,\n    interval = null;\n  function addJob(job) {\n    console.log('added job: ' + job);\n    ++jobs;\n    if (!interval)\n      interval = setInterval(function () {\n        console.log('(' + jobs + ' jobs)');\n      }, options.statusDisplayInterval || 5000);\n  }\n  function removeJob(job) {\n    clearTimeout(job.timeout);\n    job.done = null;\n    --jobs;\n    if (!jobs) interval = clearInterval(interval);\n    console.log('removed job: ' + job);\n  }\n  function Job(id) {\n    this.toString = function () {\n      return id;\n    };\n    this.done = () => {\n      removeJob(this);\n      delete this;\n    };\n    this.wrapCallback = (callback) => {\n      return function () {\n        if (this && this.done) {\n          callback && callback.apply(null, arguments);\n          this.done();\n        } else\n          console.log(\n            'warning: intercepted callback from terminated job ' + this\n          );\n      };\n    };\n    this.timeout = setTimeout(() => {\n      console.log(\n        'job ' + this + ' was still running 1 minute after launch => destroying'\n      );\n      console.warn(\n        'destroyed a job that was still running 1 minute after launch'\n      );\n      removeJob(this);\n      delete this;\n    }, options.expiry || 60000);\n    addJob(this);\n    return this;\n  }\n  this.newJob = function (id) {\n    return new Job(id);\n  };\n  this.countPendingJobs = function () {\n    return jobs;\n  };\n  return this;\n};\n\n/*\n// tested with expiry duration of 6000 milliseconds\nvar worker = new exports.Worker({expiry:6000})\nvar cb = worker.newJob(\"test1\").wrapCallback(function(){\n\tconsole.log(\"callback1\");\n});\nvar cb2 = worker.newJob(\"test2\").wrapCallback(function(){\n\tconsole.log(\"callback2\");\n});\nsetTimeout(cb, 2000); // -> callback1 displayed, then job removed\n// -> test1 job expiry error message, then job removed\nsetTimeout(cb, 7000); // -> error: intercepted callback tentative for test1 (already terminated)\nsetTimeout(cb2, 8000); // -> error: intercepted callback tentative for test2 (already terminated)\n*/\n", "/* global describe, it, before */\n\nconst { promisify } = require('util');\nconst assert = require('assert');\n\nconst { ADMIN_USER, cleanup, URL_PREFIX } = require('../fixtures.js');\nconst apiClient = require('../api-client.js');\n\nconst postRaw = promisify(apiClient.postRaw);\nconst loginAs = promisify(apiClient.loginAs);\n\nbefore(cleanup);\n\ndescribe('security', () => {\n  describe('Open Redirect', () => {\n    it('should allow redirect to /stream', async () => {\n      const target = `/stream`;\n      const { jar } = await loginAs(ADMIN_USER);\n      const { response } = await postRaw(jar, `/consent`, {\n        lang: 'en',\n        redirect: target,\n      });\n      assert.equal(response.statusCode, 302);\n      assert.equal(response.headers.location, target);\n    });\n\n    it(`should allow redirect to ${URL_PREFIX}/stream`, async () => {\n      const target = `${URL_PREFIX}/stream`;\n      const { jar } = await loginAs(ADMIN_USER);\n      const { response } = await postRaw(jar, `/consent`, {\n        lang: 'en',\n        redirect: target,\n      });\n      assert.equal(response.statusCode, 302);\n      assert.equal(response.headers.location, target);\n    });\n\n    it('should NOT allow redirect to other domain', async () => {\n      const { jar } = await loginAs(ADMIN_USER);\n      const { response } = await postRaw(jar, `/consent`, {\n        lang: 'en',\n        redirect: `http://google.com`,\n      });\n      assert.equal(response.statusCode, 403); // forbidden\n    });\n\n    it('should NOT allow redirect to a disguised domain', async () => {\n      const { jar } = await loginAs(ADMIN_USER);\n      const { response } = await postRaw(jar, `/consent`, {\n        lang: 'en',\n        redirect: `${URL_PREFIX}@google.com`,\n      });\n      assert.equal(response.statusCode, 403); // forbidden\n    });\n  });\n});\n"], "fixing_code": ["/**\n * login controller, to authenticate users\n */\nconst snip = require('../../snip.js');\nconst config = require('../../models/config.js');\nvar emailModel = require('../../models/email.js');\nvar userModel = require('../../models/user.js');\nvar notifEmails = require('../../models/notifEmails.js');\nvar userApi = require('../../controllers/api/user.js');\n\nvar md5 = userModel.md5;\nvar loggingTemplate = require('../../templates/logging.js');\n\nexports.handleRequest = function (request, form, response, ignorePassword) {\n  form = form || {};\n  if (form.password && !form.md5) form.md5 = md5(form.password);\n\n  request.logToConsole('login.handleRequest', {\n    action: form.action,\n    email: form.email,\n    md5: form.md5,\n  });\n\n  function renderJSON(json) {\n    response[form.ajax == 'iframe' ? 'renderWrappedJSON' : 'renderJSON'](json);\n  }\n\n  // in case of successful login\n  function renderRedirect(url, user) {\n    request.session.whydUid = (user || {}).id;\n    if (!form.ajax) response.renderHTML(loggingTemplate.htmlRedirect(url));\n    else {\n      var json = { redirect: url };\n      if (form.includeUser) {\n        userApi.fetchUserData(user, function (user) {\n          json.user = user;\n          renderJSON(json);\n        });\n      } else renderJSON(json);\n    }\n  }\n\n  function renderForm(form) {\n    delete request.session;\n    if (form.ajax) renderJSON(form);\n    else response.renderHTML(loggingTemplate.renderLoginPage(form));\n  }\n\n  if (form.action === 'logout') {\n    request.session.destroy(function (err) {\n      if (err) {\n        console.error('error from request.session.destroy()', err);\n        form.error = err;\n      }\n      console.log('logout result', form.error);\n      renderForm(form);\n    });\n    return;\n  } else if (form.email) {\n    form.email = emailModel.normalize(form.email);\n\n    userModel[form.email.indexOf('@') > -1 ? 'fetchByEmail' : 'fetchByHandle'](\n      form.email,\n      function (dbUser) {\n        if (\n          form.redirect &&\n          snip.getSafeOpenwhydURL(form.redirect, config.urlPrefix) === false\n        ) {\n          form.error = 'Unsafe redirect target';\n        } else if (!dbUser) {\n          form.error = \"Are you sure? We don't recognize your email address!\";\n        } else if (form.action == 'forgot') {\n          notifEmails.sendPasswordReset(dbUser._id, dbUser.pwd, form.redirect);\n          /*form.error*/ form.ok =\n            'We just sent you an email to reset your password, wait for it!';\n        } else if (\n          !ignorePassword &&\n          !form.md5 /*(!form.password || form.password == \"password\")*/\n        ) {\n          form.error = 'Please enter your password below:';\n        } else if (\n          form.action == 'login' &&\n          (ignorePassword || dbUser.pwd == form.md5)\n        ) {\n          // console.log('ok, user logged in as: ' + dbUser.name);\n          // console.log('form.fbUid', form.fbUid);\n          if (form.fbUid)\n            userModel.update(dbUser._id, {\n              $set: {\n                fbId: form.fbUid,\n                fbTok: form.fbTok, // access token provided on last facebook login\n              },\n            });\n          renderRedirect(form.redirect || '/', dbUser);\n          return; // prevent default response (renderForm)\n        } else if (form.action != 'logout') {\n          form.wrongPassword = 1;\n          form.error = 'Your password seems wrong... Try again!';\n        }\n\n        console.log('login result', form.error);\n        renderForm(form);\n      }\n    );\n  } else renderForm(form);\n};\n\nexports.controller = function (request, getParams, response) {\n  if (request.method.toLowerCase() === 'post')\n    exports.handleRequest(request, request.body, response);\n  else exports.handleRequest(request, getParams, response);\n};\n", "var http = require('http');\nvar querystring = require('querystring');\nvar errorTemplate = require('../templates/error.js');\nconst snip = require('../snip.js');\n\nconst genReqLogLine = ({ head, method, path, params, suffix }) =>\n  !process.appParams.color\n    ? [\n        head,\n        method,\n        path[0] + (path.length > 1 ? '?' + path.slice(1).join('?') : ''),\n        suffix,\n        params,\n      ]\n    : [\n        head.grey,\n        method.cyan,\n        path[0].green +\n          (path.length > 1 ? '?' + path.slice(1).join('?') : '').yellow,\n        suffix.white,\n        params.grey,\n      ];\n\nhttp.IncomingMessage.prototype.logToConsole = function (suffix, params) {\n  console.log(\n    ...genReqLogLine({\n      head: '\u25b6 ' + new Date().toISOString(),\n      method: this.method,\n      path: this.url.split('?'),\n      params:\n        typeof params === 'object'\n          ? JSON.stringify(snip.formatPrivateFields(params))\n          : '',\n      suffix: suffix ? '(' + suffix + ')' : '',\n    })\n  );\n};\n\nvar config = require('./config.js');\nvar mongodb = require('./mongodb.js');\nvar loggingTemplate = require('../templates/logging.js');\nvar renderUnauthorizedPage = loggingTemplate.renderUnauthorizedPage;\n\n// ========= USER AGENT STUFF\n\n/**\n * Gets the http referer of a request\n */\nhttp.IncomingMessage.prototype.getReferer = function () {\n  return this.headers['referrer'] || this.headers['referer'];\n};\n\n// ========= COOKIE STUFF\n\n/**\n * Generates a user session cookie string\n * that can be supplied to a Set-Cookie HTTP header.\n */\n/*\nexports.makeCookie = function(user) {\n\tvar date = new Date((new Date()).getTime() + 1000 * 60 * 60 * 24 * 365);\n\treturn 'whydUid=\"'+(user.id || '')+'\"; Expires=' + date.toGMTString();\n};\n*/\n\n/**\n * Transforms cookies found in the request into an object\n */\nhttp.IncomingMessage.prototype.getCookies = (function () {\n  //var cookieReg = /([^=\\s]+)=\"([^\"]*)\"/;\n  return function () {\n    //console.log(\"cookies raw:\", this.headers.cookie);\n    if (!this.headers.cookie) return null;\n    var cookiesArray = this.headers.cookie.split(';');\n    //console.log(\"cookies array:\", cookiesArray);\n    var cookies = {};\n    for (let i = 0; i < cookiesArray.length; i++) {\n      //var match = cookiesArray[i].trim().match(cookieReg);\n      //if (match)\n      cookiesArray[i] = cookiesArray[i].trim();\n      var separ = cookiesArray[i].indexOf('=');\n      if (separ > 0)\n        cookies[cookiesArray[i].substr(0, separ)] = cookiesArray[i].substring(\n          separ + 1\n        );\n    }\n    //console.log(\"cookies object:\", cookies);\n    return cookies;\n  };\n})();\n\n/**\n * Return facebook's \"fbs_\" cookie object from the request\n */\nhttp.IncomingMessage.prototype.getFacebookCookie = function () {\n  var cookies = this.getCookies();\n  //console.log(\"cookies:\", cookies);\n  for (let i in cookies)\n    if (i.startsWith('fbs_')) {\n      const cookie = {},\n        cookieArray = cookies[i].split('&');\n      for (let j in cookieArray) {\n        var cookieItem = cookieArray[j].split('=');\n        cookie[cookieItem[0]] = cookieItem[1];\n      }\n      console.log('found facebook cookie'); //, cookie);\n      return cookie;\n    } else if (i.startsWith('fbsr_')) {\n      // https://developers.facebook.com/docs/authentication/signed_request/\n      try {\n        let cookie = cookies[i].split('.')[1];\n        cookie = Buffer.from(cookie /*|| \"\"*/, 'base64').toString('ascii');\n        cookie = JSON.parse(cookie);\n        console.log('found secure facebook cookie'); //, cookie);\n        return cookie;\n      } catch (e) {\n        console.log('secure facebook connect error: ', e);\n      }\n    }\n  return null;\n};\n\n// ========= USER ACCESSORS\n\n/**\n * Returns the logged in user's facebook uid, from its cookie\n */\nhttp.IncomingMessage.prototype.getFbUid = function () {\n  var fbCookie = this.getFacebookCookie();\n  if (fbCookie && fbCookie.uid)\n    this.getFbUid = function () {\n      return fbCookie.uid;\n    };\n  else if (fbCookie && fbCookie.user_id)\n    this.getFbUid = function () {\n      return fbCookie.user_id;\n    };\n  else return null;\n  return this.getFbUid();\n};\n\n/**\n * Returns the logged in user's uid, from its openwhyd session cookie\n */\nhttp.IncomingMessage.prototype.getUid = function () {\n  /*\n\tvar uid = (this.getCookies() || {})[\"whydUid\"];\n\tif (uid) uid = uid.replace(/\\\"/g, \"\");\n\t//if (uid) console.log(\"found openwhyd session cookie\", uid);\n\treturn uid;\n\t*/\n  return (this.session || {}).whydUid;\n};\n\n/**\n * Returns the logged in user as an object {_id, id, fbId, name, img}\n */\nhttp.IncomingMessage.prototype.getUser = function () {\n  var uid = this.getUid();\n  if (uid) {\n    var user = mongodb.usernames[uid];\n    if (user) user.id = '' + user._id;\n    return user;\n  } else return null;\n};\n\n//http.IncomingMessage.prototype.getUserFromFbUid = mongodb.getUserFromFbUid;\n\nhttp.IncomingMessage.prototype.getUserFromId = mongodb.getUserFromId;\n\nhttp.IncomingMessage.prototype.getUserNameFromId = mongodb.getUserNameFromId;\n\n// ========= LOGIN/SESSION/PRIVILEGES STUFF\n\n/**\n * Checks that a registered user is logged in, and return that user, or show an error page\n */\nhttp.IncomingMessage.prototype.checkLogin = function (response, format) {\n  var user = this.getUser();\n  //console.log(\"checkLogin, cached record for logged in user: \", user);\n  if (!user /*|| !user.name*/) {\n    if (response) {\n      if (format && format.toLowerCase() == 'json')\n        errorTemplate.renderErrorResponse(\n          { errorCode: 'REQ_LOGIN' },\n          response,\n          'json'\n        );\n      else response.renderHTML(renderUnauthorizedPage());\n    }\n    return false;\n  }\n  return user;\n};\n\nhttp.IncomingMessage.prototype.isUserAdmin = exports.isUserAdmin = function (\n  user\n) {\n  return user.email && config.adminEmails[user.email];\n};\n\nhttp.IncomingMessage.prototype.isAdmin = function () {\n  return this.isUserAdmin(this.getUser());\n};\n\nhttp.IncomingMessage.prototype.checkAdmin = function (response, format) {\n  var user = this.checkLogin(response, format);\n  if (!user) return false;\n  else if (!exports.isUserAdmin(user)) {\n    console.log(\n      'access restricted, user is not an admin: ',\n      user._id || user.id\n    );\n    response && response.legacyRender('nice try! ;-)');\n    return false;\n  }\n  return user;\n};\n\n// ========= HTTP RESPONSE SNIPPETS\n\nhttp.ServerResponse.prototype.renderHTML = function (html, statusCode) {\n  return this.legacyRender(\n    html,\n    null,\n    { 'content-type': 'text/html; charset=utf-8' },\n    statusCode\n  );\n};\n\nhttp.ServerResponse.prototype.renderJSON = function (json, statusCode) {\n  return this.legacyRender(\n    json,\n    null,\n    { 'content-type': 'application/json; charset=utf-8' },\n    statusCode\n  );\n};\n\nhttp.ServerResponse.prototype.renderWrappedJSON = function (json, statusCode) {\n  this.renderHTML(\n    '<!DOCTYPE html><html><body><textarea>' +\n      JSON.stringify(json) +\n      '</textarea></body></html>',\n    statusCode\n  );\n};\n\nhttp.ServerResponse.prototype.renderText = function (json, statusCode) {\n  return this.legacyRender(\n    json,\n    null,\n    { 'content-type': 'text/text; charset=utf-8' },\n    statusCode\n  );\n};\n\n// TODO: this function is overrided by Express => delete it to prevent ambiguity\nhttp.ServerResponse.prototype.redirect = function (url) {\n  return this.renderHTML(loggingTemplate.htmlRedirect(url));\n};\n\nhttp.ServerResponse.prototype.safeRedirect = function (url) {\n  const safeURL = snip.getSafeOpenwhydURL(url, config.urlPrefix);\n  if (safeURL === false) return this.forbidden();\n  this.redirect(url);\n};\n\nhttp.ServerResponse.prototype.redirectWithTracking = function (url, title) {\n  return this.renderHTML(\n    loggingTemplate.renderRedirectPageWithTracking(url, title)\n  );\n};\n\nhttp.ServerResponse.prototype.renderIframe = function (url, metaOverrides) {\n  return this.renderHTML(loggingTemplate.renderIframe(url, metaOverrides));\n};\n\nhttp.ServerResponse.prototype.temporaryRedirect = function (_url, _reqParams) {\n  let url = '' + _url;\n  if (_reqParams /*request.method.toLowerCase() == \"get\"*/) {\n    const reqParams = querystring.stringify(_reqParams);\n    if (reqParams.length) url += '?' + reqParams;\n  }\n  this.redirect(307, url); // see https://expressjs.com/fr/4x/api.html#res.redirect\n};\n\nhttp.ServerResponse.prototype.badRequest = function (error) {\n  this.status(400).send(error ? '' + error : 'BAD REQUEST');\n};\n\nhttp.ServerResponse.prototype.forbidden = function (error) {\n  this.status(403).send(error ? '' + error : 'FORBIDDEN');\n};\n\nhttp.ServerResponse.prototype.notFound = function () {\n  this.status(404).send();\n};\n", "// various tools by Adrien Joly\n// tests: tests/tess-snips.js\n\nvar fs = require('fs');\nvar urlModule = require('url');\nvar http = require('http');\nvar https = require('https');\nvar querystring = require('querystring');\n\nvar firstWeek = new Date('Monday January 3, 2011 08:00'); // week #1 = 1st of january 2010\n\n// privacy helper: anonymise email address\nexports.formatEmail = function (emailAddr) {\n  if (typeof emailAddr !== 'string' || emailAddr.length < 1)\n    return '<invalid_email>';\n  const [name, domain] = emailAddr.split('@');\n  return name.substring(0, 1).concat('*********@').concat(domain);\n};\n\nexports.formatPrivateFields = (obj) => {\n  if (typeof obj !== 'object') return obj;\n  const res = { ...obj };\n  if (typeof obj.email === 'string') res.email = exports.formatEmail(obj.email);\n  if (typeof obj.md5 === 'string') res.md5 = '<MD5_HASH>';\n  return res;\n};\n\n// privacy-enforcing console.log helper\nexports.console = {\n  log(...args) {\n    const filteredArgs = args.map(exports.formatPrivateFields);\n    console.log(...filteredArgs);\n  },\n};\n\nexports.getWeekNumber = function (date) {\n  return date && Math.floor(1 + (date - firstWeek) / 1000 / 60 / 60 / 24 / 7);\n};\n\nexports.weekNumberToDate = function (weekNumber) {\n  return new Date(firstWeek.getTime() + 7 * 24 * 60 * 60 * 1000 * weekNumber);\n};\n\nexports.forEachFileLine = function (fileName, lineHandler) {\n  var buffer = '';\n  function processBuffer(flush) {\n    var parts = buffer.replace('\\r', '').split('\\n');\n    buffer = !flush && parts.pop();\n    parts.forEach(lineHandler);\n  }\n  fs.createReadStream(fileName)\n    .addListener('data', function (data) {\n      buffer += data.toString();\n      processBuffer();\n    })\n    .addListener('end', function () {\n      processBuffer(true);\n      lineHandler();\n    });\n};\n\n// =========================================================================\n// string manipulation / regular expressions\n\nexports.removeAccents = function (str) {\n  return !str\n    ? ''\n    : str\n        .replace(/[\u00e0\u00e2\u00e4]/gi, 'a')\n        .replace(/[\u00e9\u00e8\u00ea\u00eb]/gi, 'e')\n        .replace(/[\u00ee\u00ef]/gi, 'i')\n        .replace(/[\u00f4\u00f6]/gi, 'o')\n        .replace(/[\u00f9\u00fb\u00fc]/gi, 'u');\n};\n\n//var regexUrl = /(\\b(https?|ftp|file):\\/\\/[-A-Z0-9+&@#\\/%?=~_|!:,.;]*[-A-Z0-9+&@#\\/%=~_|])/ig;\nvar regexUrl =\n  /(\\b(https?|ftp|file):\\/\\/([-A-Z0-9+&@#$*'()%?=~_|!:,.;]*)[-A-Z0-9+&@#/%?=~_|!:,.;]*[-A-Z0-9+&@#/%=~_|])/gi;\nvar regexUrl2 = /(\\b(https?|ftp|file):\\/\\/([^/\\s]*)[^\\s]*)/gi;\n\nexports.replaceURLWithHTMLLinks = function (text) {\n  return String(text || '').replace(regexUrl2, \"<a href='$1'>$3...</a>\");\n};\n\nexports.replaceURLWithFullHTMLLinks = function (text) {\n  return String(text || '').replace(regexUrl, \"<a href='$1'>$1</a>\");\n};\n\nexports.shortenURLs = function (text) {\n  return String(text || '').replace(regexUrl, '$3...');\n};\n\n// source: http://css-tricks.com/snippets/javascript/htmlentities-for-javascript/\nexports.htmlEntities = function (str) {\n  return String(str || '')\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;');\n};\n\nexports.addSlashes = function (str) {\n  return typeof str == 'string'\n    ? str.replace(/\\\\/g, '\\\\\\\\').replace(/'/g, \"\\\\'\").replace(/\"/g, '\\\\\"')\n    : str;\n};\n\nexports.sanitizeJsStringInHtml = function (str) {\n  return exports.htmlEntities(exports.addSlashes(str || ''));\n};\n\nexports.getSafeOpenwhydURL = function (url, safeUrlPrefix) {\n  if (typeof url !== 'string' || url.includes('<script')) return false;\n  const fullURL = new URL(url, safeUrlPrefix);\n  if (`${fullURL.protocol}//${fullURL.host}` !== safeUrlPrefix) return false;\n  else return fullURL;\n};\n\nvar timeScales = [\n  { 'minute(s)': 60 },\n  { 'hour(s)': 60 },\n  { 'day(s)': 24 },\n  { 'month(s)': 30 },\n  { 'year(s)': 12 },\n];\n\nexports.renderTimestamp = function (timestamp) {\n  var t = timestamp / 1000,\n    lastScale = 'second(s)';\n  for (let i in timeScales) {\n    var scaleTitle;\n    for (scaleTitle in timeScales[i]);\n    var scaleVal = timeScales[i][scaleTitle];\n\n    if (t / scaleVal < 1) break;\n    t = t / scaleVal;\n    lastScale = scaleTitle;\n  }\n  var rounded = Math.round(t);\n  return rounded + ' ' + lastScale.replace(/\\(s\\)/g, rounded > 1 ? 's' : '');\n};\n\nexports.MONTHS_SHORT = [\n  'Jan',\n  'Feb',\n  'Mar',\n  'Apr',\n  'May',\n  'Jun',\n  'Jul',\n  'Aug',\n  'Sep',\n  'Oct',\n  'Nov',\n  'Dec',\n];\n\nexports.renderShortMonthYear = function (date) {\n  var t = new Date(date);\n  var sameYear = false; //(new Date()).getFullYear() == t.getFullYear();\n  return (\n    exports.MONTHS_SHORT[t.getMonth()] + (sameYear ? '' : ' ' + t.getFullYear())\n  );\n};\n\nexports.padNumber = function (str, n) {\n  var ret = '' + str;\n  while (\n    ret.length < n // pad with leading zeroes\n  )\n    ret = '0' + ret;\n  return ret;\n};\n\nexports.renderTime = function (date) {\n  var t = new Date(date);\n  return t.getHours() + ':' + exports.padNumber(t.getMinutes(), 2);\n};\n\n// minimal sanitization of function name: remove javascript's special / control characters\nexports.sanitizeJsIdentifier = function (id) {\n  return ('' + id).replace(/\\/\\\\\\n\\(\\)\\[\\];\\./g, ' ');\n};\n\nexports.renderJsCallback = function (fctName, obj) {\n  return (\n    exports.sanitizeJsIdentifier(fctName) +\n    '(' +\n    (typeof obj == 'object' ? JSON.stringify(obj) : '\"' + obj + '\"') +\n    ');'\n  );\n};\n\n// =========================================================================\n// music track related functions\n\nexports.cleanTrackName = function (str) {\n  return !str\n    ? ''\n    : str\n        .trim()\n        .replace(/^\\d+([-./\\\\]\\d+)+\\s+/, '') // remove prefixing date\n        .replace(/^\\d+[.]+\\s+/, '') // remove prefixing track number\n        .replace(/^#\\d+\\s+/, '') // remove prefixing rank\n        .replace(/\\([^)]*\\)/g, '') // remove parentheses\n        .replace(/\\[[^]]*\\]/g, '') // remove brackets\n        .replace(/\\s+/, ' ') // remove extra/duplicate whitespace\n        .trim();\n};\n\n// to run on cleaned track names, for better performance\nexports.normalizeArtistName = function (artistName) {\n  return exports\n    .removeAccents(artistName.trim().toLowerCase())\n    .replace(/[^a-z0-9]/g, ''); // remove non alpha characters\n};\n\nvar reQuotes = /\"[^\")]*\"/g;\nvar reSeparator = /-+\\s+/g;\nvar reOnlyDigits = /^\\d+$/;\n\n// to run on cleaned track names, for better performance\nexports.detectArtistName = function (trackName) {\n  var quoted = trackName.match(reQuotes) || [];\n  var splitted = (trackName || '').replace(reQuotes, ' - ').split(reSeparator);\n  // remove track title (last item of the string, or quoted items)\n  splitted.length = splitted.length - (quoted.length || 1);\n  for (let i in splitted) {\n    var normalized = exports.normalizeArtistName(splitted[i]);\n    if (normalized && !reOnlyDigits.test(normalized)) return splitted[i].trim();\n  }\n  return null;\n};\n\n// to run on cleaned track names, for better performance\nexports.detectTrackFields = function (trackName) {\n  var quoted = trackName.match(reQuotes) || [];\n  if (quoted.length == 1) return JSON.stringify(quoted);\n  else return null;\n};\n\n// =========================================================================\n// data structures\n\nexports.arrayHas = function (array, value) {\n  if (array) for (let i in array) if (value == array[i]) return true;\n  return false;\n};\n\nexports.values = function (set) {\n  var list = [];\n  for (let i in set)\n    if (set[i])\n      // TODO: remove this line\n      list.push(set[i]);\n  return list;\n};\n\nexports.mapToObjArray = function (map, keyFieldName, valueFieldName) {\n  var array = [];\n  for (let k in map) {\n    var obj = {};\n    if (keyFieldName) obj[keyFieldName] = k;\n    if (valueFieldName) obj[valueFieldName] = map[k];\n    else if (typeof map[k] == 'object')\n      for (let f in map[k]) obj[f] = map[k][f];\n    array.push(obj);\n  }\n  return array;\n};\n\nexports.arrayToSet = function (array, value) {\n  var set = {};\n  for (let i in array)\n    if (array[i])\n      // TODO: remove this line\n      set[array[i]] = value !== undefined ? value : true;\n  return set;\n};\n\nexports.objArrayToSet = function (array, attr, val) {\n  var set = {};\n  for (let i in array)\n    if (array[i] && attr in array[i]) set[array[i][attr]] = val || array[i];\n  return set;\n};\n\nexports.groupObjectsBy = function (array, attr) {\n  var r = {};\n  var path = ('' + attr).split('.');\n  if (path.length > 1) {\n    for (let i in array) {\n      const obj = array[i] || {};\n      let key = obj;\n      for (let j in path) {\n        key = (key || {})[path[j]];\n      }\n      if (key) (r[key] = r[key] || []).push(obj);\n    }\n  } else {\n    for (let i in array) {\n      const obj = array[i] || {};\n      let key = obj[attr];\n      if (key)\n        // TODO: fix this line\n        (r[key] = r[key] || []).push(obj);\n    }\n  }\n  return r;\n};\n\nexports.removeDuplicates = function (array, keyFieldName) {\n  if (keyFieldName)\n    return exports.mapToObjArray(\n      exports.objArrayToSet(array, keyFieldName),\n      keyFieldName\n    );\n  else return Object.keys(exports.arrayToSet(array));\n};\n\nexports.objArrayToValueArray = function (array, attr) {\n  var list = [];\n  for (let i in array)\n    if (array[i] && array[i][attr])\n      // TODO: fix this line, cf line 217\n      list.push(array[i][attr]);\n  return list;\n};\n\nexports.forEachArrayItem = function (array, handler, cb) {\n  var i = 0;\n  var length = array.length;\n  (function next() {\n    setTimeout(function () {\n      if (i < length) handler(array[i++], next);\n      else if (cb) cb(array);\n    }, 0);\n  })();\n};\n\nexports.getMapFieldNames = function (map /*, firstField*/) {\n  var fieldNames = [],\n    fieldSet = {};\n  for (let i in map) {\n    for (let f in map[i])\n      if (!fieldSet[f]) {\n        // TODO: check this line\n        fieldNames.push(f);\n        fieldSet[f] = true;\n      }\n  }\n  /*if (firstField)\n\t\tfieldNames.unshift(firstField);*/\n  return fieldNames;\n};\n\nexports.excludeKeys = function (map = [], keySet = {}) {\n  const res = [];\n  for (let k in map)\n    if (!keySet[k])\n      // TODO: check this line\n      res[k] = map[k];\n  return res;\n};\n\nexports.checkMissingFields = function (obj, fieldSet) {\n  if (!obj || typeof obj !== 'object') return { error: 'object is null' };\n  for (let f in fieldSet)\n    if (fieldSet[f] && !(f in obj))\n      return { field: f, expected: true, error: 'missing field: ' + f };\n    else if (!fieldSet[f] && f in obj)\n      return { field: f, expected: false, error: 'forbidden field: ' + f };\n};\n\nexports.checkMistypedFields = function (obj, fieldTypeSet) {\n  if (!obj || typeof obj !== 'object') return { error: 'object is null' };\n  function Error(error, f) {\n    return {\n      field: f,\n      type: typeof obj[f],\n      expected: fieldTypeSet[f],\n      error: error + ': ' + f,\n    };\n  }\n  for (let f in fieldTypeSet)\n    if (fieldTypeSet[f]) {\n      if (!(f in obj)) return Error('missing field', f);\n      else if (\n        typeof obj[f] !== fieldTypeSet[f] &&\n        (fieldTypeSet[f] !== 'array' || !obj[f].splice)\n      )\n        return Error('mistyped field', f);\n    } else if (f in obj) return Error('forbidden field', f);\n};\n\n// translateFields({a,b,c}, {b:\"bb\"}) => {a,bb,c}\nexports.translateFields = function (obj, mapping) {\n  if (obj && typeof obj === 'object')\n    for (let f in mapping)\n      if (f in obj) {\n        obj[mapping[f]] = obj[f];\n        delete obj[f];\n      }\n  return obj;\n};\n\n// filterFields({a,b,c}, {b:\"bb\"}) => {bb}\nexports.filterFields = function (obj, mapping) {\n  var finalObj = {};\n  for (let field in mapping)\n    if (field in obj)\n      finalObj[mapping[field] === true ? field : mapping[field]] = obj[field];\n  return finalObj;\n};\n\n// =========================================================================\n// sorting comparators\n\nexports.descSort = function (a, b) {\n  return parseInt(b) - parseInt(a);\n};\n\nexports.ascSort = function (a, b) {\n  if (a < b) return -1;\n  if (a > b) return 1;\n  return 0;\n};\n\nexports.makeFieldSort = function (field, sortFct) {\n  return function (a, b) {\n    return sortFct(a[field], b[field]);\n  };\n};\n\n// by http://andrew.hedges.name\nexports.getLevenshteinDistance = (function () {\n  function minimator(x, y, z) {\n    if (x < y && x < z) return x;\n    if (y < x && y < z) return y;\n    return z;\n  }\n  return function (a, b) {\n    var cost,\n      m = a.length,\n      n = b.length;\n    if (m < n) {\n      var c = a;\n      a = b;\n      b = c;\n      var o = m;\n      m = n;\n      n = o;\n    }\n    var r = [];\n    r[0] = [];\n    for (let c = 0; c < n + 1; c++) r[0][c] = c;\n    for (let i = 1; i < m + 1; i++) {\n      r[i] = [];\n      r[i][0] = i;\n      for (let j = 1; j < n + 1; j++) {\n        cost = a.charAt(i - 1) == b.charAt(j - 1) ? 0 : 1;\n        r[i][j] = minimator(\n          r[i - 1][j] + 1,\n          r[i][j - 1] + 1,\n          r[i - 1][j - 1] + cost\n        );\n      }\n    }\n    return r[m][n];\n  };\n})();\n\n// =========================================================================\n// table structures\n\nexports.DataTable = function () {\n  this.table = [];\n  this.header = null; //[]; // fields\n\n  this.fromArray = (array, header) => {\n    if (header) this.header = header;\n    this.table = array;\n    return this;\n  };\n\n  this.fromMap = (map, header) => {\n    this.header = header || exports.getMapFieldNames(map);\n    //table = /*mapToTable(map, header);*/ [];\n    for (let i in map) {\n      var line = [\n        /*i*/\n      ];\n      //for (let f in map[i]) line.push(map[i][f]);\n      for (let f in this.header) line.push(map[i][this.header[f]]);\n      this.table.push(line);\n    }\n    return this;\n  };\n\n  this.sort = (fct) => {\n    this.table.sort(fct);\n    return this;\n  };\n\n  const getFullTableCopy = () => {\n    return [].concat(this.header ? [this.header] : []).concat(this.table);\n  };\n\n  const toCharSeparatedValues = (charSepar, replacement, lineSepar) => {\n    var table = getFullTableCopy();\n    var regExp = new RegExp('[' + charSepar + '\\n\"]', 'g');\n    for (let i in table) {\n      for (let j in table[i])\n        table[i][j] = ('' + table[i][j]).replace(regExp, replacement || ' ');\n      //console.log(i, table[i]);\n      table[i] = table[i].join(charSepar);\n    }\n    return table.join(lineSepar || '\\n');\n  };\n\n  this.toTsv = () => {\n    return toCharSeparatedValues('\\t');\n  };\n\n  this.toCsv = () => {\n    return toCharSeparatedValues(',');\n  };\n\n  const valToHtmlCell = (val) => {\n    return '<td>' + exports.htmlEntities(val) + '</td>';\n  };\n\n  this.toHtml = () => {\n    var table = getFullTableCopy().map((line) => {\n      return '<tr>' + line.map(valToHtmlCell).join('') + '</tr>';\n    });\n    return [\n      '<!DOCTYPE html>',\n      '<html>',\n      '<head>',\n      '<meta charset=\"utf-8\"/>',\n      '</head>',\n      '<body>',\n      '<p>' + this.table.length + ' items</p>',\n      '<table>',\n      \"<thead style='background:#ccc;'>\",\n      table.shift(),\n      '</thead>',\n      '<tbody>',\n    ]\n      .concat(table)\n      .concat(['</tbody', '</table>', '</body>', '</html>'])\n      .join('\\n');\n  };\n\n  return this;\n};\n\n// =========================================================================\n// HTTP requests\n\nvar httpDomains = {};\n\nexports.httpSetDomain = function (regex, options) {\n  if (!options) delete httpDomains[regex];\n  else httpDomains[regex] = [regex, options];\n};\n\nexports.httpDomains = httpDomains;\n\nexports.httpGetDomain = function (domain) {\n  for (let i in httpDomains)\n    if (httpDomains[i][0].test(domain)) return httpDomains[i][1];\n};\n\nfunction _httpRequest(options, callback) {\n  var data = '',\n    body = options.body;\n  if (body)\n    // => don't forget to add Content-Type and Content-Length headers in that case\n    delete options.body;\n  //console.log(\"httpRequest\", options.host + options.path);\n  var req = (options.protocol === 'http:' ? http : https)\n    .request(options, function (res) {\n      if (options.responseEncoding)\n        res.setEncoding(options.responseEncoding /*'utf-8'*/);\n      res.addListener('data', function (chunk) {\n        data += chunk.toString();\n      });\n      res.addListener('end', function () {\n        callback(null, data, res);\n      });\n    })\n    .on('error', function (err) {\n      //console.log(\"[ERR] snip.httpRequest \", url, err);\n      //console.error(\"[ERR] snip.httpRequest \", url, err);\n      callback(err);\n    });\n  req.end(body);\n  return req;\n}\n\nexports.httpRequest = function (url, options = {}, callback) {\n  var urlObj = urlModule.parse(url);\n  options.method = options.method || 'GET';\n  options.protocol = urlObj.protocol;\n  options.host = urlObj.hostname;\n  options.port = urlObj.port || (urlObj.protocol === 'https:' ? 443 : 80);\n  options.path = urlObj.path; //url; //urlObj.pathname\n  //options.headers = {'Accept':'application/json'};\n  var domainOpts = exports.httpGetDomain(options.host) || {};\n  if (domainOpts.queue) {\n    const runNext = () => {\n      //console.log(\"5-next?\", options.host, domainOpts.queue.length);\n      return domainOpts.queue.length && domainOpts.queue[0](); // run next request in line\n    };\n    //console.log(\"1-REQ\", options.host, domainOpts.queue.length);\n    domainOpts.queue.push(\n      _httpRequest.bind(null, options, function () {\n        //console.log(\"2-RES\", options.host, domainOpts.queue.length);\n        callback.apply(null, arguments);\n        //console.log(\"3-END\", options.host, domainOpts.queue.length);\n        domainOpts.queue.shift(); // request id done => dequeue\n        //console.log(\"4 =>\", options.host, domainOpts.queue.length);\n        runNext();\n      })\n    );\n    return domainOpts.queue.length == 1 ? runNext() : undefined;\n  }\n  return _httpRequest(options, callback);\n};\n\nexports.httpRequestWithParams = function (url, options, cb) {\n  if (options.params) {\n    url += '?' + querystring.stringify(options.params);\n    delete options.params;\n  }\n  if (options.body) {\n    options.body =\n      typeof options.body == 'object'\n        ? querystring.stringify(options.body)\n        : options.body;\n    options.headers = options.headers || {};\n    options.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n    options.headers['Content-Length'] = options.body.length;\n  }\n  return exports.httpRequest(url, options, cb);\n};\n\nexports.httpRequestJSON = function (url, options, callback) {\n  return exports.httpRequest(url, options, function (err, data, res) {\n    if (err) callback(err, null, res);\n    else {\n      try {\n        if (typeof data == 'string') data = JSON.parse(data);\n        callback(null, data, res);\n      } catch (e) {\n        //console.error(e);\n        callback(e, data, res);\n      }\n    }\n  });\n};\n\nfunction BasicCache() {\n  var cache = {};\n  this.get = function (url) {\n    return cache[url];\n  };\n  this.set = function (url, data) {\n    return (cache[url] = data);\n  };\n  this.dump = function () {\n    return cache;\n  };\n  this.restore = function (cacheDump) {\n    return (cache = cacheDump);\n  };\n  return this;\n}\n\nexports.HttpRequestCache = function (cache) {\n  var realRequest = exports.httpRequest;\n  this.cache = cache = cache || new BasicCache();\n  this.httpRequest = function (url, options, callback) {\n    // TODO: options are ignored for now\n    var cached = cache.get(url);\n    if (cached) {\n      //console.warn(\"used cached request for\", url, \"...\");\n      callback(null, cached);\n    } else {\n      //console.warn(\"making a real request to\", url, \"...\");\n      realRequest(url, options, function (err, data, res) {\n        cache.set(url, data);\n        callback(err, data, res);\n      });\n    }\n  };\n};\n\n// =========================================================================\n/**\n * simple implementation of an async event emitter\n * listeners are called in sequence, based on callbacks\n * inspired by: https://github.com/joyent/node/blob/master/lib/events.js\n **/\n\nfunction AsyncEventEmitter() {\n  this._eventListeners = {};\n}\n\nAsyncEventEmitter.prototype.on = function (evtName, listener) {\n  this._eventListeners[evtName] = this._eventListeners[evtName] || [];\n  this._eventListeners[evtName].push(listener);\n  return this;\n};\n\nAsyncEventEmitter.prototype.emit = function (evtName, param, callback) {\n  var listeners = this._eventListeners[evtName];\n  if (!listeners) return false;\n  listeners = listeners.slice(); // duplicate array\n  const nextListener = () => {\n    process.nextTick(() => {\n      if (listeners.length) {\n        //var args = Array.prototype.slice.call(arguments, 1);\n        listeners.pop().call(this, param, nextListener);\n      } else if (callback) callback();\n    });\n  };\n  nextListener();\n  return true;\n};\n\nexports.AsyncEventEmitter = AsyncEventEmitter;\n\n// =========================================================================\n/**\n * callWhenDone: a simple synchronized callback closure\n * @author adrienjoly, whyd\n */\nexports.callWhenDone = function (callback) {\n  var counter = 0;\n  return function (incr) {\n    if (0 == (counter += incr)) callback();\n  };\n};\n\n// =========================================================================\n/**\n * checkParams: validate an object against two sets of types properties: mandatory and optional\n * returns validated object, or throws an error.\n * @author adrienjoly, whyd\n */\nexports.checkParams = function (obj, mandatorySet, optionalSet) {\n  var finalObj = {};\n  function storeIfValid(fieldName, typeSet) {\n    if (typeof obj[fieldName] != typeSet[fieldName])\n      throw Error('invalid field value: ' + fieldName);\n    else finalObj[fieldName] = obj[fieldName];\n  }\n  obj = obj || {};\n  for (let fieldName in mandatorySet) storeIfValid(fieldName, mandatorySet);\n  for (let fieldName in optionalSet)\n    if (fieldName in obj && obj[fieldName] != null)\n      storeIfValid(fieldName, optionalSet);\n  return finalObj;\n};\n\n// =========================================================================\n\nvar MAX_NB_MENTIONS = 6;\nvar RE_MENTION = /@\\[([^\\]]*)\\]\\(user:([^)]*)\\)/gi;\n\nexports.RE_MENTION = RE_MENTION;\n\nexports.extractMentions = function (commentText) {\n  var mentions = [];\n  for (;;) {\n    // extract user id (last matched group) of each mention\n    var mentionedUid = (RE_MENTION.exec(commentText) || []).pop();\n    if (mentionedUid) mentions.push(mentionedUid);\n    else break;\n  }\n  return mentions.slice(0, MAX_NB_MENTIONS);\n};\n\n// =========================================================================\n// class to track the execution of long jobs, with callback timeout capability\n\nexports.Worker = function (options) {\n  options = options || {};\n  var jobs = 0,\n    interval = null;\n  function addJob(job) {\n    console.log('added job: ' + job);\n    ++jobs;\n    if (!interval)\n      interval = setInterval(function () {\n        console.log('(' + jobs + ' jobs)');\n      }, options.statusDisplayInterval || 5000);\n  }\n  function removeJob(job) {\n    clearTimeout(job.timeout);\n    job.done = null;\n    --jobs;\n    if (!jobs) interval = clearInterval(interval);\n    console.log('removed job: ' + job);\n  }\n  function Job(id) {\n    this.toString = function () {\n      return id;\n    };\n    this.done = () => {\n      removeJob(this);\n      delete this;\n    };\n    this.wrapCallback = (callback) => {\n      return function () {\n        if (this && this.done) {\n          callback && callback.apply(null, arguments);\n          this.done();\n        } else\n          console.log(\n            'warning: intercepted callback from terminated job ' + this\n          );\n      };\n    };\n    this.timeout = setTimeout(() => {\n      console.log(\n        'job ' + this + ' was still running 1 minute after launch => destroying'\n      );\n      console.warn(\n        'destroyed a job that was still running 1 minute after launch'\n      );\n      removeJob(this);\n      delete this;\n    }, options.expiry || 60000);\n    addJob(this);\n    return this;\n  }\n  this.newJob = function (id) {\n    return new Job(id);\n  };\n  this.countPendingJobs = function () {\n    return jobs;\n  };\n  return this;\n};\n\n/*\n// tested with expiry duration of 6000 milliseconds\nvar worker = new exports.Worker({expiry:6000})\nvar cb = worker.newJob(\"test1\").wrapCallback(function(){\n\tconsole.log(\"callback1\");\n});\nvar cb2 = worker.newJob(\"test2\").wrapCallback(function(){\n\tconsole.log(\"callback2\");\n});\nsetTimeout(cb, 2000); // -> callback1 displayed, then job removed\n// -> test1 job expiry error message, then job removed\nsetTimeout(cb, 7000); // -> error: intercepted callback tentative for test1 (already terminated)\nsetTimeout(cb2, 8000); // -> error: intercepted callback tentative for test2 (already terminated)\n*/\n", "/* global describe, it, before */\n\nconst { promisify } = require('util');\nconst assert = require('assert');\n\nconst { ADMIN_USER, cleanup, URL_PREFIX } = require('../fixtures.js');\nconst apiClient = require('../api-client.js');\n\nconst postRaw = promisify(apiClient.postRaw);\nconst loginAs = promisify(apiClient.loginAs);\n\nbefore(cleanup);\n\ndescribe('security', () => {\n  describe('Open Redirect from /login', () => {\n    it('should allow redirect to /stream', async () => {\n      const target = `/stream`;\n      const { response } = await postRaw(null, `/login`, {\n        action: 'login',\n        email: ADMIN_USER.email,\n        md5: ADMIN_USER.md5,\n        redirect: target,\n      });\n      assert(\n        response.body.includes(`window.location.href=\"${target}\"`) === true,\n        `page body should include redirect to ${target}`\n      );\n    });\n\n    it('should NOT allow redirect to other domain', async () => {\n      const target = `https://google.com`;\n      const { response } = await postRaw(null, `/login`, {\n        action: 'login',\n        email: ADMIN_USER.email,\n        md5: ADMIN_USER.md5,\n        redirect: target,\n      });\n      assert(\n        response.body.includes(`window.location.href=\"${target}\"`) === false,\n        `page body should NOT include redirect to ${target}`\n      );\n    });\n\n    it('should NOT allow javascript in redirect URL', async () => {\n      const target = `javascript:alert()`;\n      const { response } = await postRaw(null, `/login`, {\n        action: 'login',\n        email: ADMIN_USER.email,\n        md5: ADMIN_USER.md5,\n        redirect: target,\n      });\n      assert(\n        response.body.includes(`window.location.href=\"${target}\"`) === false,\n        `page body should NOT include redirect to ${target}`\n      );\n    });\n\n    it('should NOT allow script element in redirect URL', async () => {\n      const target = `<script>alert(document.cookie)</script>`;\n      const { response } = await postRaw(null, `/login`, {\n        action: 'login',\n        email: ADMIN_USER.email,\n        md5: ADMIN_USER.md5,\n        redirect: target,\n      });\n      assert(\n        response.body.includes(`window.location.href=\"${target}\"`) === false,\n        `page body should NOT include redirect to ${target}`\n      );\n    });\n  });\n\n  describe('Open Redirect from /consent', () => {\n    it('should allow redirect to /stream', async () => {\n      const target = `/stream`;\n      const { jar } = await loginAs(ADMIN_USER);\n      const { response } = await postRaw(jar, `/consent`, {\n        lang: 'en',\n        redirect: target,\n      });\n      assert.equal(response.statusCode, 302);\n      assert.equal(response.headers.location, target);\n    });\n\n    it(`should allow redirect to ${URL_PREFIX}/stream`, async () => {\n      const target = `${URL_PREFIX}/stream`;\n      const { jar } = await loginAs(ADMIN_USER);\n      const { response } = await postRaw(jar, `/consent`, {\n        lang: 'en',\n        redirect: target,\n      });\n      assert.equal(response.statusCode, 302);\n      assert.equal(response.headers.location, target);\n    });\n\n    it('should NOT allow redirect to other domain', async () => {\n      const { jar } = await loginAs(ADMIN_USER);\n      const { response } = await postRaw(jar, `/consent`, {\n        lang: 'en',\n        redirect: `http://google.com`,\n      });\n      assert.equal(response.statusCode, 403); // forbidden\n    });\n\n    it('should NOT allow redirect to a disguised domain', async () => {\n      const { jar } = await loginAs(ADMIN_USER);\n      const { response } = await postRaw(jar, `/consent`, {\n        lang: 'en',\n        redirect: `${URL_PREFIX}@google.com`,\n      });\n      assert.equal(response.statusCode, 403); // forbidden\n    });\n  });\n});\n"], "filenames": ["app/controllers/api/login.js", "app/models/logging.js", "app/snip.js", "test/api/security.api.tests.js"], "buggy_code_start_loc": [3, 264, 109, 15], "buggy_code_end_loc": [64, 267, 109, 16], "fixing_code_start_loc": [4, 264, 110, 15], "fixing_code_end_loc": [71, 266, 117, 74], "type": "NVD-CWE-Other", "message": "openwhyd is vulnerable to Improper Authorization", "other": {"cve": {"id": "CVE-2021-3837", "sourceIdentifier": "security@huntr.dev", "published": "2022-01-03T15:15:08.480", "lastModified": "2022-10-27T11:38:46.010", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "openwhyd is vulnerable to Improper Authorization"}, {"lang": "es", "value": "openwhyd es vulnerable a una Autorizaci\u00f3n Inapropiada"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-285"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openwhyd:openwhyd:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.45.12", "matchCriteriaId": "EEFB6BEF-868E-4DBB-B08D-04C2DEE74E98"}]}]}], "references": [{"url": "https://github.com/openwhyd/openwhyd/commit/102a97bb082edc831cf35d27f9e5c4f55f10ae85", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/d66f90d6-1b5f-440d-8be6-cdffc9d4587e", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openwhyd/openwhyd/commit/102a97bb082edc831cf35d27f9e5c4f55f10ae85"}}