{"buggy_code": ["/*\n * Copyright (C) 2006,2008 by the Massachusetts Institute of Technology.\n * All rights reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n/*\n * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.\n * Use is subject to license terms.\n *\n * A module that implements the spnego security mechanism.\n * It is used to negotiate the security mechanism between\n * peers using the GSS-API.  SPNEGO is specified in RFC 4178.\n *\n */\n/*\n * Copyright (c) 2006-2008, Novell, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *   * The copyright holder's name is not used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n/* #pragma ident\t\"@(#)spnego_mech.c\t1.7\t04/09/28 SMI\" */\n\n#include\t<k5-int.h>\n#include\t<krb5.h>\n#include\t<mglueP.h>\n#include\t\"gssapiP_spnego.h\"\n#include\t<gssapi_err_generic.h>\n\n\n#undef g_token_size\n#undef g_verify_token_header\n#undef g_make_token_header\n\n#define HARD_ERROR(v) ((v) != GSS_S_COMPLETE && (v) != GSS_S_CONTINUE_NEEDED)\ntypedef const gss_OID_desc *gss_OID_const;\n\n/* der routines defined in libgss */\nextern unsigned int gssint_der_length_size(unsigned int);\nextern int gssint_get_der_length(unsigned char **, unsigned int,\n\t\t\t\t unsigned int*);\nextern int gssint_put_der_length(unsigned int, unsigned char **, unsigned int);\n\n\n/* private routines for spnego_mechanism */\nstatic spnego_token_t make_spnego_token(const char *);\nstatic gss_buffer_desc make_err_msg(const char *);\nstatic int g_token_size(gss_OID_const, unsigned int);\nstatic int g_make_token_header(gss_OID_const, unsigned int,\n\t\t\t       unsigned char **, unsigned int);\nstatic int g_verify_token_header(gss_OID_const, unsigned int *,\n\t\t\t\t unsigned char **,\n\t\t\t\t int, unsigned int);\nstatic int g_verify_neg_token_init(unsigned char **, unsigned int);\nstatic gss_OID get_mech_oid(OM_uint32 *, unsigned char **, size_t);\nstatic gss_buffer_t get_input_token(unsigned char **, unsigned int);\nstatic gss_OID_set get_mech_set(OM_uint32 *, unsigned char **, unsigned int);\nstatic OM_uint32 get_req_flags(unsigned char **, OM_uint32, OM_uint32 *);\nstatic OM_uint32 get_available_mechs(OM_uint32 *, gss_name_t, gss_cred_usage_t,\n\t\t\t\t     gss_const_key_value_set_t,\n\t\t\t\t     gss_cred_id_t *, gss_OID_set *);\nstatic OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,\n\t\t\t\t      gss_cred_usage_t, gss_OID_set *);\nstatic void release_spnego_ctx(spnego_gss_ctx_id_t *);\nstatic void check_spnego_options(spnego_gss_ctx_id_t);\nstatic spnego_gss_ctx_id_t create_spnego_ctx(void);\nstatic int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);\nstatic int put_input_token(unsigned char **, gss_buffer_t, unsigned int);\nstatic int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);\nstatic int put_negResult(unsigned char **, OM_uint32, unsigned int);\n\nstatic OM_uint32\nprocess_mic(OM_uint32 *, gss_buffer_t, spnego_gss_ctx_id_t,\n\t    gss_buffer_t *, OM_uint32 *, send_token_flag *);\nstatic OM_uint32\nhandle_mic(OM_uint32 *, gss_buffer_t, int, spnego_gss_ctx_id_t,\n\t   gss_buffer_t *, OM_uint32 *, send_token_flag *);\n\nstatic OM_uint32\ninit_ctx_new(OM_uint32 *, spnego_gss_cred_id_t, gss_ctx_id_t *,\n\t     send_token_flag *);\nstatic OM_uint32\ninit_ctx_nego(OM_uint32 *, spnego_gss_ctx_id_t, OM_uint32, gss_OID,\n\t      gss_buffer_t *, gss_buffer_t *,\n\t      OM_uint32 *, send_token_flag *);\nstatic OM_uint32\ninit_ctx_cont(OM_uint32 *, gss_ctx_id_t *, gss_buffer_t,\n\t      gss_buffer_t *, gss_buffer_t *,\n\t      OM_uint32 *, send_token_flag *);\nstatic OM_uint32\ninit_ctx_reselect(OM_uint32 *, spnego_gss_ctx_id_t, OM_uint32,\n\t\t  gss_OID, gss_buffer_t *, gss_buffer_t *,\n\t\t  OM_uint32 *, send_token_flag *);\nstatic OM_uint32\ninit_ctx_call_init(OM_uint32 *, spnego_gss_ctx_id_t, spnego_gss_cred_id_t,\n\t\t   gss_name_t, OM_uint32, OM_uint32, gss_buffer_t,\n\t\t   gss_OID *, gss_buffer_t, OM_uint32 *, OM_uint32 *,\n\t\t   OM_uint32 *, send_token_flag *);\n\nstatic OM_uint32\nacc_ctx_new(OM_uint32 *, gss_buffer_t, gss_ctx_id_t *,\n\t    spnego_gss_cred_id_t, gss_buffer_t *,\n\t    gss_buffer_t *, OM_uint32 *, send_token_flag *);\nstatic OM_uint32\nacc_ctx_cont(OM_uint32 *, gss_buffer_t, gss_ctx_id_t *,\n\t     gss_buffer_t *, gss_buffer_t *,\n\t     OM_uint32 *, send_token_flag *);\nstatic OM_uint32\nacc_ctx_vfy_oid(OM_uint32 *, spnego_gss_ctx_id_t, gss_OID,\n\t\tOM_uint32 *, send_token_flag *);\nstatic OM_uint32\nacc_ctx_call_acc(OM_uint32 *, spnego_gss_ctx_id_t, spnego_gss_cred_id_t,\n\t\t gss_buffer_t, gss_OID *, gss_buffer_t,\n\t\t OM_uint32 *, OM_uint32 *, gss_cred_id_t *,\n\t\t OM_uint32 *, send_token_flag *);\n\nstatic gss_OID\nnegotiate_mech(gss_OID_set, gss_OID_set, OM_uint32 *);\nstatic int\ng_get_tag_and_length(unsigned char **, int, unsigned int, unsigned int *);\n\nstatic int\nmake_spnego_tokenInit_msg(spnego_gss_ctx_id_t,\n\t\t\tint,\n\t\t\tgss_buffer_t,\n\t\t\tOM_uint32, gss_buffer_t, send_token_flag,\n\t\t\tgss_buffer_t);\nstatic int\nmake_spnego_tokenTarg_msg(OM_uint32, gss_OID, gss_buffer_t,\n\t\t\tgss_buffer_t, send_token_flag,\n\t\t\tgss_buffer_t);\n\nstatic OM_uint32\nget_negTokenInit(OM_uint32 *, gss_buffer_t, gss_buffer_t,\n\t\t gss_OID_set *, OM_uint32 *, gss_buffer_t *,\n\t\t gss_buffer_t *);\nstatic OM_uint32\nget_negTokenResp(OM_uint32 *, unsigned char *, unsigned int,\n\t\t OM_uint32 *, gss_OID *, gss_buffer_t *, gss_buffer_t *);\n\nstatic int\nis_kerb_mech(gss_OID oid);\n\n/* SPNEGO oid structure */\nstatic const gss_OID_desc spnego_oids[] = {\n\t{SPNEGO_OID_LENGTH, SPNEGO_OID},\n};\n\nconst gss_OID_desc * const gss_mech_spnego = spnego_oids+0;\nstatic const gss_OID_set_desc spnego_oidsets[] = {\n\t{1, (gss_OID) spnego_oids+0},\n};\nconst gss_OID_set_desc * const gss_mech_set_spnego = spnego_oidsets+0;\n\nstatic int make_NegHints(OM_uint32 *, spnego_gss_cred_id_t, gss_buffer_t *);\nstatic int put_neg_hints(unsigned char **, gss_buffer_t, unsigned int);\nstatic OM_uint32\nacc_ctx_hints(OM_uint32 *, gss_ctx_id_t *, spnego_gss_cred_id_t,\n\t      gss_buffer_t *, OM_uint32 *, send_token_flag *);\n\n/*\n * The Mech OID for SPNEGO:\n * { iso(1) org(3) dod(6) internet(1) security(5)\n *  mechanism(5) spnego(2) }\n */\nstatic struct gss_config spnego_mechanism =\n{\n\t{SPNEGO_OID_LENGTH, SPNEGO_OID},\n\tNULL,\n\tspnego_gss_acquire_cred,\n\tspnego_gss_release_cred,\n\tspnego_gss_init_sec_context,\n#ifndef LEAN_CLIENT\n\tspnego_gss_accept_sec_context,\n#else\n\tNULL,\n#endif  /* LEAN_CLIENT */\n\tNULL,\t\t\t\t/* gss_process_context_token */\n\tspnego_gss_delete_sec_context,\t/* gss_delete_sec_context */\n\tspnego_gss_context_time,\t/* gss_context_time */\n\tspnego_gss_get_mic,\t\t/* gss_get_mic */\n\tspnego_gss_verify_mic,\t\t/* gss_verify_mic */\n\tspnego_gss_wrap,\t\t/* gss_wrap */\n\tspnego_gss_unwrap,\t\t/* gss_unwrap */\n\tspnego_gss_display_status,\n\tNULL,\t\t\t\t/* gss_indicate_mechs */\n\tspnego_gss_compare_name,\n\tspnego_gss_display_name,\n\tspnego_gss_import_name,\n\tspnego_gss_release_name,\n\tspnego_gss_inquire_cred,\t/* gss_inquire_cred */\n\tNULL,\t\t\t\t/* gss_add_cred */\n#ifndef LEAN_CLIENT\n\tspnego_gss_export_sec_context,\t\t/* gss_export_sec_context */\n\tspnego_gss_import_sec_context,\t\t/* gss_import_sec_context */\n#else\n\tNULL,\t\t\t\t/* gss_export_sec_context */\n\tNULL,\t\t\t\t/* gss_import_sec_context */\n#endif /* LEAN_CLIENT */\n\tNULL, \t\t\t\t/* gss_inquire_cred_by_mech */\n\tspnego_gss_inquire_names_for_mech,\n\tspnego_gss_inquire_context,\t/* gss_inquire_context */\n\tNULL,\t\t\t\t/* gss_internal_release_oid */\n\tspnego_gss_wrap_size_limit,\t/* gss_wrap_size_limit */\n\tNULL,\t\t\t\t/* gssd_pname_to_uid */\n\tNULL,\t\t\t\t/* gss_userok */\n\tNULL,\t\t\t\t/* gss_export_name */\n\tspnego_gss_duplicate_name,\t/* gss_duplicate_name */\n\tNULL,\t\t\t\t/* gss_store_cred */\n \tspnego_gss_inquire_sec_context_by_oid, /* gss_inquire_sec_context_by_oid */\n \tspnego_gss_inquire_cred_by_oid,\t/* gss_inquire_cred_by_oid */\n \tspnego_gss_set_sec_context_option, /* gss_set_sec_context_option */\n\tspnego_gss_set_cred_option,\t/* gssspi_set_cred_option */\n \tNULL,\t\t\t\t/* gssspi_mech_invoke */\n\tspnego_gss_wrap_aead,\n\tspnego_gss_unwrap_aead,\n\tspnego_gss_wrap_iov,\n\tspnego_gss_unwrap_iov,\n\tspnego_gss_wrap_iov_length,\n\tspnego_gss_complete_auth_token,\n\tspnego_gss_acquire_cred_impersonate_name,\n\tNULL,\t\t\t\t/* gss_add_cred_impersonate_name */\n\tspnego_gss_display_name_ext,\n\tspnego_gss_inquire_name,\n\tspnego_gss_get_name_attribute,\n\tspnego_gss_set_name_attribute,\n\tspnego_gss_delete_name_attribute,\n\tspnego_gss_export_name_composite,\n\tspnego_gss_map_name_to_any,\n\tspnego_gss_release_any_name_mapping,\n\tspnego_gss_pseudo_random,\n\tspnego_gss_set_neg_mechs,\n\tspnego_gss_inquire_saslname_for_mech,\n\tspnego_gss_inquire_mech_for_saslname,\n\tspnego_gss_inquire_attrs_for_mech,\n\tspnego_gss_acquire_cred_from,\n\tNULL,\t\t\t\t/* gss_store_cred_into */\n\tspnego_gss_acquire_cred_with_password,\n\tspnego_gss_export_cred,\n\tspnego_gss_import_cred,\n\tNULL,\t\t\t\t/* gssspi_import_sec_context_by_mech */\n\tNULL,\t\t\t\t/* gssspi_import_name_by_mech */\n\tNULL,\t\t\t\t/* gssspi_import_cred_by_mech */\n\tspnego_gss_get_mic_iov,\n\tspnego_gss_verify_mic_iov,\n\tspnego_gss_get_mic_iov_length\n};\n\n#ifdef _GSS_STATIC_LINK\n#include \"mglueP.h\"\n\nstatic int gss_spnegomechglue_init(void)\n{\n\tstruct gss_mech_config mech_spnego;\n\n\tmemset(&mech_spnego, 0, sizeof(mech_spnego));\n\tmech_spnego.mech = &spnego_mechanism;\n\tmech_spnego.mechNameStr = \"spnego\";\n\tmech_spnego.mech_type = GSS_C_NO_OID;\n\n\treturn gssint_register_mechinfo(&mech_spnego);\n}\n#else\ngss_mechanism KRB5_CALLCONV\ngss_mech_initialize(void)\n{\n\treturn (&spnego_mechanism);\n}\n\nMAKE_INIT_FUNCTION(gss_krb5int_lib_init);\nMAKE_FINI_FUNCTION(gss_krb5int_lib_fini);\nint gss_krb5int_lib_init(void);\n#endif /* _GSS_STATIC_LINK */\n\nint gss_spnegoint_lib_init(void)\n{\n\tint err;\n\n\terr = k5_key_register(K5_KEY_GSS_SPNEGO_STATUS, NULL);\n\tif (err)\n\t\treturn err;\n\n#ifdef _GSS_STATIC_LINK\n\treturn gss_spnegomechglue_init();\n#else\n\treturn 0;\n#endif\n}\n\nvoid gss_spnegoint_lib_fini(void)\n{\n}\n\n/*ARGSUSED*/\nOM_uint32 KRB5_CALLCONV\nspnego_gss_acquire_cred(OM_uint32 *minor_status,\n\t\t\tgss_name_t desired_name,\n\t\t\tOM_uint32 time_req,\n\t\t\tgss_OID_set desired_mechs,\n\t\t\tgss_cred_usage_t cred_usage,\n\t\t\tgss_cred_id_t *output_cred_handle,\n\t\t\tgss_OID_set *actual_mechs,\n\t\t\tOM_uint32 *time_rec)\n{\n    return spnego_gss_acquire_cred_from(minor_status, desired_name, time_req,\n\t\t\t\t\tdesired_mechs, cred_usage, NULL,\n\t\t\t\t\toutput_cred_handle, actual_mechs,\n\t\t\t\t\ttime_rec);\n}\n\n/*ARGSUSED*/\nOM_uint32 KRB5_CALLCONV\nspnego_gss_acquire_cred_from(OM_uint32 *minor_status,\n\t\t\t     const gss_name_t desired_name,\n\t\t\t     OM_uint32 time_req,\n\t\t\t     const gss_OID_set desired_mechs,\n\t\t\t     gss_cred_usage_t cred_usage,\n\t\t\t     gss_const_key_value_set_t cred_store,\n\t\t\t     gss_cred_id_t *output_cred_handle,\n\t\t\t     gss_OID_set *actual_mechs,\n\t\t\t     OM_uint32 *time_rec)\n{\n\tOM_uint32 status, tmpmin;\n\tgss_OID_set amechs;\n\tgss_cred_id_t mcred = NULL;\n\tspnego_gss_cred_id_t spcred = NULL;\n\tdsyslog(\"Entering spnego_gss_acquire_cred\\n\");\n\n\tif (actual_mechs)\n\t\t*actual_mechs = NULL;\n\n\tif (time_rec)\n\t\t*time_rec = 0;\n\n\t/* We will obtain a mechglue credential and wrap it in a\n\t * spnego_gss_cred_id_rec structure.  Allocate the wrapper. */\n\tspcred = malloc(sizeof(spnego_gss_cred_id_rec));\n\tif (spcred == NULL) {\n\t\t*minor_status = ENOMEM;\n\t\treturn (GSS_S_FAILURE);\n\t}\n\tspcred->neg_mechs = GSS_C_NULL_OID_SET;\n\n\t/*\n\t * Always use get_available_mechs to collect a list of\n\t * mechs for which creds are available.\n\t */\n\tstatus = get_available_mechs(minor_status, desired_name,\n\t\t\t\t     cred_usage, cred_store, &mcred,\n\t\t\t\t     &amechs);\n\n\tif (actual_mechs && amechs != GSS_C_NULL_OID_SET) {\n\t\t(void) gssint_copy_oid_set(&tmpmin, amechs, actual_mechs);\n\t}\n\t(void) gss_release_oid_set(&tmpmin, &amechs);\n\n\tif (status == GSS_S_COMPLETE) {\n\t\tspcred->mcred = mcred;\n\t\t*output_cred_handle = (gss_cred_id_t)spcred;\n\t} else {\n\t\tfree(spcred);\n\t\t*output_cred_handle = GSS_C_NO_CREDENTIAL;\n\t}\n\n\tdsyslog(\"Leaving spnego_gss_acquire_cred\\n\");\n\treturn (status);\n}\n\n/*ARGSUSED*/\nOM_uint32 KRB5_CALLCONV\nspnego_gss_release_cred(OM_uint32 *minor_status,\n\t\t\tgss_cred_id_t *cred_handle)\n{\n\tspnego_gss_cred_id_t spcred = NULL;\n\n\tdsyslog(\"Entering spnego_gss_release_cred\\n\");\n\n\tif (minor_status == NULL || cred_handle == NULL)\n\t\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n\t*minor_status = 0;\n\n\tif (*cred_handle == GSS_C_NO_CREDENTIAL)\n\t\treturn (GSS_S_COMPLETE);\n\n\tspcred = (spnego_gss_cred_id_t)*cred_handle;\n\t*cred_handle = GSS_C_NO_CREDENTIAL;\n\tgss_release_oid_set(minor_status, &spcred->neg_mechs);\n\tgss_release_cred(minor_status, &spcred->mcred);\n\tfree(spcred);\n\n\tdsyslog(\"Leaving spnego_gss_release_cred\\n\");\n\treturn (GSS_S_COMPLETE);\n}\n\nstatic void\ncheck_spnego_options(spnego_gss_ctx_id_t spnego_ctx)\n{\n\tspnego_ctx->optionStr = gssint_get_modOptions(\n\t\t(const gss_OID)&spnego_oids[0]);\n}\n\nstatic spnego_gss_ctx_id_t\ncreate_spnego_ctx(void)\n{\n\tspnego_gss_ctx_id_t spnego_ctx = NULL;\n\tspnego_ctx = (spnego_gss_ctx_id_t)\n\t\tmalloc(sizeof (spnego_gss_ctx_id_rec));\n\n\tif (spnego_ctx == NULL) {\n\t\treturn (NULL);\n\t}\n\n\tspnego_ctx->magic_num = SPNEGO_MAGIC_ID;\n\tspnego_ctx->ctx_handle = GSS_C_NO_CONTEXT;\n\tspnego_ctx->mech_set = NULL;\n\tspnego_ctx->internal_mech = NULL;\n\tspnego_ctx->optionStr = NULL;\n\tspnego_ctx->DER_mechTypes.length = 0;\n\tspnego_ctx->DER_mechTypes.value = NULL;\n\tspnego_ctx->default_cred = GSS_C_NO_CREDENTIAL;\n\tspnego_ctx->mic_reqd = 0;\n\tspnego_ctx->mic_sent = 0;\n\tspnego_ctx->mic_rcvd = 0;\n\tspnego_ctx->mech_complete = 0;\n\tspnego_ctx->nego_done = 0;\n\tspnego_ctx->internal_name = GSS_C_NO_NAME;\n\tspnego_ctx->actual_mech = GSS_C_NO_OID;\n\n\tcheck_spnego_options(spnego_ctx);\n\n\treturn (spnego_ctx);\n}\n\n/* iso(1) org(3) dod(6) internet(1) private(4) enterprises(1) samba(7165)\n * gssntlmssp(655) controls(1) spnego_req_mechlistMIC(2) */\nstatic const gss_OID_desc spnego_req_mechlistMIC_oid =\n\t{ 11, \"\\x2B\\x06\\x01\\x04\\x01\\xB7\\x7D\\x85\\x0F\\x01\\x02\" };\n\n/*\n * Return nonzero if the mechanism has reason to believe that a mechlistMIC\n * exchange will be required.  Microsoft servers erroneously require SPNEGO\n * mechlistMIC if they see an internal MIC within an NTLMSSP Authenticate\n * message, even if NTLMSSP was the preferred mechanism.\n */\nstatic int\nmech_requires_mechlistMIC(spnego_gss_ctx_id_t sc)\n{\n\tOM_uint32 major, minor;\n\tgss_ctx_id_t ctx = sc->ctx_handle;\n\tgss_OID oid = (gss_OID)&spnego_req_mechlistMIC_oid;\n\tgss_buffer_set_t bufs;\n\tint result;\n\n\tmajor = gss_inquire_sec_context_by_oid(&minor, ctx, oid, &bufs);\n\tif (major != GSS_S_COMPLETE)\n\t\treturn 0;\n\n\t/* Report true if the mech returns a single buffer containing a single\n\t * byte with value 1. */\n\tresult = (bufs != NULL && bufs->count == 1 &&\n\t\t  bufs->elements[0].length == 1 &&\n\t\t  memcmp(bufs->elements[0].value, \"\\1\", 1) == 0);\n\t(void) gss_release_buffer_set(&minor, &bufs);\n\treturn result;\n}\n\n/*\n * Both initiator and acceptor call here to verify and/or create mechListMIC,\n * and to consistency-check the MIC state.  handle_mic is invoked only if the\n * negotiated mech has completed and supports MICs.\n */\nstatic OM_uint32\nhandle_mic(OM_uint32 *minor_status, gss_buffer_t mic_in,\n\t   int send_mechtok, spnego_gss_ctx_id_t sc,\n\t   gss_buffer_t *mic_out,\n\t   OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\n\tret = GSS_S_FAILURE;\n\t*mic_out = GSS_C_NO_BUFFER;\n\tif (mic_in != GSS_C_NO_BUFFER) {\n\t\tif (sc->mic_rcvd) {\n\t\t\t/* Reject MIC if we've already received a MIC. */\n\t\t\t*negState = REJECT;\n\t\t\t*tokflag = ERROR_TOKEN_SEND;\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t\t}\n\t} else if (sc->mic_reqd && !send_mechtok) {\n\t\t/*\n\t\t * If the peer sends the final mechanism token, it\n\t\t * must send the MIC with that token if the\n\t\t * negotiation requires MICs.\n\t\t */\n\t\t*negState = REJECT;\n\t\t*tokflag = ERROR_TOKEN_SEND;\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tret = process_mic(minor_status, mic_in, sc, mic_out,\n\t\t\t  negState, tokflag);\n\tif (ret != GSS_S_COMPLETE) {\n\t\treturn ret;\n\t}\n\tif (sc->mic_reqd) {\n\t\tassert(sc->mic_sent || sc->mic_rcvd);\n\t}\n\tif (sc->mic_sent && sc->mic_rcvd) {\n\t\tret = GSS_S_COMPLETE;\n\t\t*negState = ACCEPT_COMPLETE;\n\t\tif (*mic_out == GSS_C_NO_BUFFER) {\n\t\t\t/*\n\t\t\t * We sent a MIC on the previous pass; we\n\t\t\t * shouldn't be sending a mechanism token.\n\t\t\t */\n\t\t\tassert(!send_mechtok);\n\t\t\t*tokflag = NO_TOKEN_SEND;\n\t\t} else {\n\t\t\t*tokflag = CONT_TOKEN_SEND;\n\t\t}\n\t} else if (sc->mic_reqd) {\n\t\t*negState = ACCEPT_INCOMPLETE;\n\t\tret = GSS_S_CONTINUE_NEEDED;\n\t} else if (*negState == ACCEPT_COMPLETE) {\n\t\tret = GSS_S_COMPLETE;\n\t} else {\n\t\tret = GSS_S_CONTINUE_NEEDED;\n\t}\n\treturn ret;\n}\n\n/*\n * Perform the actual verification and/or generation of mechListMIC.\n */\nstatic OM_uint32\nprocess_mic(OM_uint32 *minor_status, gss_buffer_t mic_in,\n\t    spnego_gss_ctx_id_t sc, gss_buffer_t *mic_out,\n\t    OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 ret, tmpmin;\n\tgss_qop_t qop_state;\n\tgss_buffer_desc tmpmic = GSS_C_EMPTY_BUFFER;\n\n\tret = GSS_S_FAILURE;\n\tif (mic_in != GSS_C_NO_BUFFER) {\n\t\tret = gss_verify_mic(minor_status, sc->ctx_handle,\n\t\t\t\t     &sc->DER_mechTypes,\n\t\t\t\t     mic_in, &qop_state);\n\t\tif (ret != GSS_S_COMPLETE) {\n\t\t\t*negState = REJECT;\n\t\t\t*tokflag = ERROR_TOKEN_SEND;\n\t\t\treturn ret;\n\t\t}\n\t\t/* If we got a MIC, we must send a MIC. */\n\t\tsc->mic_reqd = 1;\n\t\tsc->mic_rcvd = 1;\n\t}\n\tif (sc->mic_reqd && !sc->mic_sent) {\n\t\tret = gss_get_mic(minor_status, sc->ctx_handle,\n\t\t\t\t  GSS_C_QOP_DEFAULT,\n\t\t\t\t  &sc->DER_mechTypes,\n\t\t\t\t  &tmpmic);\n\t\tif (ret != GSS_S_COMPLETE) {\n\t\t\tgss_release_buffer(&tmpmin, &tmpmic);\n\t\t\t*tokflag = NO_TOKEN_SEND;\n\t\t\treturn ret;\n\t\t}\n\t\t*mic_out = malloc(sizeof(gss_buffer_desc));\n\t\tif (*mic_out == GSS_C_NO_BUFFER) {\n\t\t\tgss_release_buffer(&tmpmin, &tmpmic);\n\t\t\t*tokflag = NO_TOKEN_SEND;\n\t\t\treturn GSS_S_FAILURE;\n\t\t}\n\t\t**mic_out = tmpmic;\n\t\tsc->mic_sent = 1;\n\t}\n\treturn GSS_S_COMPLETE;\n}\n\n/*\n * Initial call to spnego_gss_init_sec_context().\n */\nstatic OM_uint32\ninit_ctx_new(OM_uint32 *minor_status,\n\t     spnego_gss_cred_id_t spcred,\n\t     gss_ctx_id_t *ctx,\n\t     send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = NULL;\n\n\tsc = create_spnego_ctx();\n\tif (sc == NULL)\n\t\treturn GSS_S_FAILURE;\n\n\t/* determine negotiation mech set */\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_INITIATE,\n\t\t\t\t   &sc->mech_set);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\t/* Set an initial internal mech to make the first context token. */\n\tsc->internal_mech = &sc->mech_set->elements[0];\n\n\tif (put_mech_set(sc->mech_set, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\t/*\n\t * The actual context is not yet determined, set the output\n\t * context handle to refer to the spnego context itself.\n\t */\n\tsc->ctx_handle = GSS_C_NO_CONTEXT;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\t*tokflag = INIT_TOKEN_SEND;\n\tret = GSS_S_CONTINUE_NEEDED;\n\ncleanup:\n\trelease_spnego_ctx(&sc);\n\treturn ret;\n}\n\n/*\n * Called by second and later calls to spnego_gss_init_sec_context()\n * to decode reply and update state.\n */\nstatic OM_uint32\ninit_ctx_cont(OM_uint32 *minor_status, gss_ctx_id_t *ctx, gss_buffer_t buf,\n\t      gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t      OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 ret, tmpmin, acc_negState;\n\tunsigned char *ptr;\n\tspnego_gss_ctx_id_t sc;\n\tgss_OID supportedMech = GSS_C_NO_OID;\n\n\tsc = (spnego_gss_ctx_id_t)*ctx;\n\t*negState = REJECT;\n\t*tokflag = ERROR_TOKEN_SEND;\n\n\tptr = buf->value;\n\tret = get_negTokenResp(minor_status, ptr, buf->length,\n\t\t\t       &acc_negState, &supportedMech,\n\t\t\t       responseToken, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tif (acc_negState == REJECT) {\n\t\t*minor_status = ERR_SPNEGO_NEGOTIATION_FAILED;\n\t\tmap_errcode(minor_status);\n\t\t*tokflag = NO_TOKEN_SEND;\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\t/*\n\t * nego_done is false for the first call to init_ctx_cont()\n\t */\n\tif (!sc->nego_done) {\n\t\tret = init_ctx_nego(minor_status, sc,\n\t\t\t\t    acc_negState,\n\t\t\t\t    supportedMech, responseToken,\n\t\t\t\t    mechListMIC,\n\t\t\t\t    negState, tokflag);\n\t} else if ((!sc->mech_complete && *responseToken == GSS_C_NO_BUFFER) ||\n\t\t   (sc->mech_complete && *responseToken != GSS_C_NO_BUFFER)) {\n\t\t/* Missing or spurious token from acceptor. */\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t} else if (!sc->mech_complete ||\n\t\t   (sc->mic_reqd &&\n\t\t    (sc->ctx_flags & GSS_C_INTEG_FLAG))) {\n\t\t/* Not obviously done; we may decide we're done later in\n\t\t * init_ctx_call_init or handle_mic. */\n\t\t*negState = ACCEPT_INCOMPLETE;\n\t\t*tokflag = CONT_TOKEN_SEND;\n\t\tret = GSS_S_CONTINUE_NEEDED;\n\t} else {\n\t\t/* mech finished on last pass and no MIC required, so done. */\n\t\t*negState = ACCEPT_COMPLETE;\n\t\t*tokflag = NO_TOKEN_SEND;\n\t\tret = GSS_S_COMPLETE;\n\t}\ncleanup:\n\tif (supportedMech != GSS_C_NO_OID)\n\t\tgeneric_gss_release_oid(&tmpmin, &supportedMech);\n\treturn ret;\n}\n\n/*\n * Consistency checking and mechanism negotiation handling for second\n * call of spnego_gss_init_sec_context().  Call init_ctx_reselect() to\n * update internal state if acceptor has counter-proposed.\n */\nstatic OM_uint32\ninit_ctx_nego(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n\t      OM_uint32 acc_negState, gss_OID supportedMech,\n\t      gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t      OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\n\t*negState = REJECT;\n\t*tokflag = ERROR_TOKEN_SEND;\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\t/*\n\t * Both supportedMech and negState must be present in first\n\t * acceptor token.\n\t */\n\tif (supportedMech == GSS_C_NO_OID) {\n\t\t*minor_status = ERR_SPNEGO_NO_MECH_FROM_ACCEPTOR;\n\t\tmap_errcode(minor_status);\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tif (acc_negState == ACCEPT_DEFECTIVE_TOKEN) {\n\t\t*minor_status = ERR_SPNEGO_NEGOTIATION_FAILED;\n\t\tmap_errcode(minor_status);\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\n\t/*\n\t * If the mechanism we sent is not the mechanism returned from\n\t * the server, we need to handle the server's counter\n\t * proposal.  There is a bug in SAMBA servers that always send\n\t * the old Kerberos mech OID, even though we sent the new one.\n\t * So we will treat all the Kerberos mech OIDS as the same.\n         */\n\tif (!(is_kerb_mech(supportedMech) &&\n\t      is_kerb_mech(sc->internal_mech)) &&\n\t    !g_OID_equal(supportedMech, sc->internal_mech)) {\n\t\tret = init_ctx_reselect(minor_status, sc,\n\t\t\t\t\tacc_negState, supportedMech,\n\t\t\t\t\tresponseToken, mechListMIC,\n\t\t\t\t\tnegState, tokflag);\n\n\t} else if (*responseToken == GSS_C_NO_BUFFER) {\n\t\tif (sc->mech_complete) {\n\t\t\t/*\n\t\t\t * Mech completed on first call to its\n\t\t\t * init_sec_context().  Acceptor sends no mech\n\t\t\t * token.\n\t\t\t */\n\t\t\t*negState = ACCEPT_COMPLETE;\n\t\t\t*tokflag = NO_TOKEN_SEND;\n\t\t\tret = GSS_S_COMPLETE;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Reject missing mech token when optimistic\n\t\t\t * mech selected.\n\t\t\t */\n\t\t\t*minor_status = ERR_SPNEGO_NO_TOKEN_FROM_ACCEPTOR;\n\t\t\tmap_errcode(minor_status);\n\t\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\t}\n\t} else if ((*responseToken)->length == 0 && sc->mech_complete) {\n\t\t/* Handle old IIS servers returning empty token instead of\n\t\t * null tokens in the non-mutual auth case. */\n\t\t*negState = ACCEPT_COMPLETE;\n\t\t*tokflag = NO_TOKEN_SEND;\n\t\tret = GSS_S_COMPLETE;\n\t} else if (sc->mech_complete) {\n\t\t/* Reject spurious mech token. */\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t} else {\n\t\t*negState = ACCEPT_INCOMPLETE;\n\t\t*tokflag = CONT_TOKEN_SEND;\n\t\tret = GSS_S_CONTINUE_NEEDED;\n\t}\n\tsc->nego_done = 1;\n\treturn ret;\n}\n\n/*\n * Handle acceptor's counter-proposal of an alternative mechanism.\n */\nstatic OM_uint32\ninit_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n\t\t  OM_uint32 acc_negState, gss_OID supportedMech,\n\t\t  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t\t  OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 tmpmin;\n\tsize_t i;\n\n\tgeneric_gss_release_oid(&tmpmin, &sc->internal_mech);\n\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n\t\t\t       GSS_C_NO_BUFFER);\n\n\t/* Find supportedMech in sc->mech_set. */\n\tfor (i = 0; i < sc->mech_set->count; i++) {\n\t\tif (g_OID_equal(supportedMech, &sc->mech_set->elements[i]))\n\t\t\tbreak;\n\t}\n\tif (i == sc->mech_set->count)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->internal_mech = &sc->mech_set->elements[i];\n\n\t/*\n\t * Windows 2003 and earlier don't correctly send a\n\t * negState of request-mic when counter-proposing a\n\t * mechanism.  They probably don't handle mechListMICs\n\t * properly either.\n\t */\n\tif (acc_negState != REQUEST_MIC)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\tsc->mech_complete = 0;\n\tsc->mic_reqd = 1;\n\t*negState = REQUEST_MIC;\n\t*tokflag = CONT_TOKEN_SEND;\n\treturn GSS_S_CONTINUE_NEEDED;\n}\n\n/*\n * Wrap call to mechanism gss_init_sec_context() and update state\n * accordingly.\n */\nstatic OM_uint32\ninit_ctx_call_init(OM_uint32 *minor_status,\n\t\t   spnego_gss_ctx_id_t sc,\n\t\t   spnego_gss_cred_id_t spcred,\n\t\t   gss_name_t target_name,\n\t\t   OM_uint32 req_flags,\n\t\t   OM_uint32 time_req,\n\t\t   gss_buffer_t mechtok_in,\n\t\t   gss_OID *actual_mech,\n\t\t   gss_buffer_t mechtok_out,\n\t\t   OM_uint32 *ret_flags,\n\t\t   OM_uint32 *time_rec,\n\t\t   OM_uint32 *negState,\n\t\t   send_token_flag *send_token)\n{\n\tOM_uint32 ret, tmpret, tmpmin;\n\tgss_cred_id_t mcred;\n\n\tmcred = (spcred == NULL) ? GSS_C_NO_CREDENTIAL : spcred->mcred;\n\tret = gss_init_sec_context(minor_status,\n\t\t\t\t   mcred,\n\t\t\t\t   &sc->ctx_handle,\n\t\t\t\t   target_name,\n\t\t\t\t   sc->internal_mech,\n\t\t\t\t   (req_flags | GSS_C_INTEG_FLAG),\n\t\t\t\t   time_req,\n\t\t\t\t   GSS_C_NO_CHANNEL_BINDINGS,\n\t\t\t\t   mechtok_in,\n\t\t\t\t   &sc->actual_mech,\n\t\t\t\t   mechtok_out,\n\t\t\t\t   &sc->ctx_flags,\n\t\t\t\t   time_rec);\n\tif (ret == GSS_S_COMPLETE) {\n\t\tsc->mech_complete = 1;\n\t\tif (ret_flags != NULL)\n\t\t\t*ret_flags = sc->ctx_flags;\n\t\t/*\n\t\t * Microsoft SPNEGO implementations expect an even number of\n\t\t * token exchanges.  So if we're sending a final token, ask for\n\t\t * a zero-length token back from the server.  Also ask for a\n\t\t * token back if this is the first token or if a MIC exchange\n\t\t * is required.\n\t\t */\n\t\tif (*send_token == CONT_TOKEN_SEND &&\n\t\t    mechtok_out->length == 0 &&\n\t\t    (!sc->mic_reqd ||\n\t\t     !(sc->ctx_flags & GSS_C_INTEG_FLAG))) {\n\t\t\t/* The exchange is complete. */\n\t\t\t*negState = ACCEPT_COMPLETE;\n\t\t\tret = GSS_S_COMPLETE;\n\t\t\t*send_token = NO_TOKEN_SEND;\n\t\t} else {\n\t\t\t/* Ask for one more hop. */\n\t\t\t*negState = ACCEPT_INCOMPLETE;\n\t\t\tret = GSS_S_CONTINUE_NEEDED;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tif (ret == GSS_S_CONTINUE_NEEDED)\n\t\treturn ret;\n\n\tif (*send_token != INIT_TOKEN_SEND) {\n\t\t*send_token = ERROR_TOKEN_SEND;\n\t\t*negState = REJECT;\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Since this is the first token, we can fall back to later mechanisms\n\t * in the list.  Since the mechanism list is expected to be short, we\n\t * can do this with recursion.  If all mechanisms produce errors, the\n\t * caller should get the error from the first mech in the list.\n\t */\n\tgssalloc_free(sc->mech_set->elements->elements);\n\tmemmove(sc->mech_set->elements, sc->mech_set->elements + 1,\n\t\t--sc->mech_set->count * sizeof(*sc->mech_set->elements));\n\tif (sc->mech_set->count == 0)\n\t\tgoto fail;\n\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n\tif (put_mech_set(sc->mech_set, &sc->DER_mechTypes) < 0)\n\t\tgoto fail;\n\ttmpret = init_ctx_call_init(&tmpmin, sc, spcred, target_name,\n\t\t\t\t    req_flags, time_req, mechtok_in,\n\t\t\t\t    actual_mech, mechtok_out, ret_flags,\n\t\t\t\t    time_rec, negState, send_token);\n\tif (HARD_ERROR(tmpret))\n\t\tgoto fail;\n\t*minor_status = tmpmin;\n\treturn tmpret;\n\nfail:\n\t/* Don't output token on error from first call. */\n\t*send_token = NO_TOKEN_SEND;\n\t*negState = REJECT;\n\treturn ret;\n}\n\n/*ARGSUSED*/\nOM_uint32 KRB5_CALLCONV\nspnego_gss_init_sec_context(\n\t\t\tOM_uint32 *minor_status,\n\t\t\tgss_cred_id_t claimant_cred_handle,\n\t\t\tgss_ctx_id_t *context_handle,\n\t\t\tgss_name_t target_name,\n\t\t\tgss_OID mech_type,\n\t\t\tOM_uint32 req_flags,\n\t\t\tOM_uint32 time_req,\n\t\t\tgss_channel_bindings_t input_chan_bindings,\n\t\t\tgss_buffer_t input_token,\n\t\t\tgss_OID *actual_mech,\n\t\t\tgss_buffer_t output_token,\n\t\t\tOM_uint32 *ret_flags,\n\t\t\tOM_uint32 *time_rec)\n{\n\tsend_token_flag send_token = NO_TOKEN_SEND;\n\tOM_uint32 tmpmin, ret, negState;\n\tgss_buffer_t mechtok_in, mechListMIC_in, mechListMIC_out;\n\tgss_buffer_desc mechtok_out = GSS_C_EMPTY_BUFFER;\n\tspnego_gss_cred_id_t spcred = NULL;\n\tspnego_gss_ctx_id_t spnego_ctx = NULL;\n\n\tdsyslog(\"Entering init_sec_context\\n\");\n\n\tmechtok_in = mechListMIC_out = mechListMIC_in = GSS_C_NO_BUFFER;\n\tnegState = REJECT;\n\n\t/*\n\t * This function works in three steps:\n\t *\n\t *   1. Perform mechanism negotiation.\n\t *   2. Invoke the negotiated or optimistic mech's gss_init_sec_context\n\t *      function and examine the results.\n\t *   3. Process or generate MICs if necessary.\n\t *\n\t * The three steps share responsibility for determining when the\n\t * exchange is complete.  If the selected mech completed in a previous\n\t * call and no MIC exchange is expected, then step 1 will decide.  If\n\t * the selected mech completes in this call and no MIC exchange is\n\t * expected, then step 2 will decide.  If a MIC exchange is expected,\n\t * then step 3 will decide.  If an error occurs in any step, the\n\t * exchange will be aborted, possibly with an error token.\n\t *\n\t * negState determines the state of the negotiation, and is\n\t * communicated to the acceptor if a continuing token is sent.\n\t * send_token is used to indicate what type of token, if any, should be\n\t * generated.\n\t */\n\n\t/* Validate arguments. */\n\tif (minor_status != NULL)\n\t\t*minor_status = 0;\n\tif (output_token != GSS_C_NO_BUFFER) {\n\t\toutput_token->length = 0;\n\t\toutput_token->value = NULL;\n\t}\n\tif (minor_status == NULL ||\n\t    output_token == GSS_C_NO_BUFFER ||\n\t    context_handle == NULL)\n\t\treturn GSS_S_CALL_INACCESSIBLE_WRITE;\n\n\tif (actual_mech != NULL)\n\t\t*actual_mech = GSS_C_NO_OID;\n\n\t/* Step 1: perform mechanism negotiation. */\n\tspcred = (spnego_gss_cred_id_t)claimant_cred_handle;\n\tif (*context_handle == GSS_C_NO_CONTEXT) {\n\t\tret = init_ctx_new(minor_status, spcred,\n\t\t\t\t   context_handle, &send_token);\n\t\tif (ret != GSS_S_CONTINUE_NEEDED) {\n\t\t\tgoto cleanup;\n\t\t}\n\t} else {\n\t\tret = init_ctx_cont(minor_status, context_handle,\n\t\t\t\t    input_token, &mechtok_in,\n\t\t\t\t    &mechListMIC_in, &negState, &send_token);\n\t\tif (HARD_ERROR(ret)) {\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/* Step 2: invoke the selected or optimistic mechanism's\n\t * gss_init_sec_context function, if it didn't complete previously. */\n\tspnego_ctx = (spnego_gss_ctx_id_t)*context_handle;\n\tif (!spnego_ctx->mech_complete) {\n\t\tret = init_ctx_call_init(\n\t\t\tminor_status, spnego_ctx, spcred,\n\t\t\ttarget_name, req_flags,\n\t\t\ttime_req, mechtok_in,\n\t\t\tactual_mech, &mechtok_out,\n\t\t\tret_flags, time_rec,\n\t\t\t&negState, &send_token);\n\n\t\t/* Give the mechanism a chance to force a mechlistMIC. */\n\t\tif (!HARD_ERROR(ret) && mech_requires_mechlistMIC(spnego_ctx))\n\t\t\tspnego_ctx->mic_reqd = 1;\n\t}\n\n\t/* Step 3: process or generate the MIC, if the negotiated mech is\n\t * complete and supports MICs. */\n\tif (!HARD_ERROR(ret) && spnego_ctx->mech_complete &&\n\t    (spnego_ctx->ctx_flags & GSS_C_INTEG_FLAG)) {\n\n\t\tret = handle_mic(minor_status,\n\t\t\t\t mechListMIC_in,\n\t\t\t\t (mechtok_out.length != 0),\n\t\t\t\t spnego_ctx, &mechListMIC_out,\n\t\t\t\t &negState, &send_token);\n\t}\ncleanup:\n\tif (send_token == INIT_TOKEN_SEND) {\n\t\tif (make_spnego_tokenInit_msg(spnego_ctx,\n\t\t\t\t\t      0,\n\t\t\t\t\t      mechListMIC_out,\n\t\t\t\t\t      req_flags,\n\t\t\t\t\t      &mechtok_out, send_token,\n\t\t\t\t\t      output_token) < 0) {\n\t\t\tret = GSS_S_FAILURE;\n\t\t}\n\t} else if (send_token != NO_TOKEN_SEND) {\n\t\tif (make_spnego_tokenTarg_msg(negState, GSS_C_NO_OID,\n\t\t\t\t\t      &mechtok_out, mechListMIC_out,\n\t\t\t\t\t      send_token,\n\t\t\t\t\t      output_token) < 0) {\n\t\t\tret = GSS_S_FAILURE;\n\t\t}\n\t}\n\tgss_release_buffer(&tmpmin, &mechtok_out);\n\tif (ret == GSS_S_COMPLETE) {\n\t\t/*\n\t\t * Now, switch the output context to refer to the\n\t\t * negotiated mechanism's context.\n\t\t */\n\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n\t\tif (actual_mech != NULL)\n\t\t\t*actual_mech = spnego_ctx->actual_mech;\n\t\tif (ret_flags != NULL)\n\t\t\t*ret_flags = spnego_ctx->ctx_flags;\n\t\trelease_spnego_ctx(&spnego_ctx);\n\t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n\t\tif (spnego_ctx != NULL) {\n\t\t\tgss_delete_sec_context(&tmpmin,\n\t\t\t\t\t       &spnego_ctx->ctx_handle,\n\t\t\t\t\t       GSS_C_NO_BUFFER);\n\t\t\trelease_spnego_ctx(&spnego_ctx);\n\t\t}\n\t\t*context_handle = GSS_C_NO_CONTEXT;\n\t}\n\tif (mechtok_in != GSS_C_NO_BUFFER) {\n\t\tgss_release_buffer(&tmpmin, mechtok_in);\n\t\tfree(mechtok_in);\n\t}\n\tif (mechListMIC_in != GSS_C_NO_BUFFER) {\n\t\tgss_release_buffer(&tmpmin, mechListMIC_in);\n\t\tfree(mechListMIC_in);\n\t}\n\tif (mechListMIC_out != GSS_C_NO_BUFFER) {\n\t\tgss_release_buffer(&tmpmin, mechListMIC_out);\n\t\tfree(mechListMIC_out);\n\t}\n\treturn ret;\n} /* init_sec_context */\n\n/* We don't want to import KRB5 headers here */\nstatic const gss_OID_desc gss_mech_krb5_oid =\n\t{ 9, \"\\052\\206\\110\\206\\367\\022\\001\\002\\002\" };\nstatic const gss_OID_desc gss_mech_krb5_wrong_oid =\n\t{ 9, \"\\052\\206\\110\\202\\367\\022\\001\\002\\002\" };\n\n/*\n * verify that the input token length is not 0. If it is, just return.\n * If the token length is greater than 0, der encode as a sequence\n * and place in buf_out, advancing buf_out.\n */\n\nstatic int\nput_neg_hints(unsigned char **buf_out, gss_buffer_t input_token,\n\t      unsigned int buflen)\n{\n\tint ret;\n\n\t/* if token length is 0, we do not want to send */\n\tif (input_token->length == 0)\n\t\treturn (0);\n\n\tif (input_token->length > buflen)\n\t\treturn (-1);\n\n\t*(*buf_out)++ = SEQUENCE;\n\tif ((ret = gssint_put_der_length(input_token->length, buf_out,\n\t\t\t    input_token->length)))\n\t\treturn (ret);\n\tTWRITE_STR(*buf_out, input_token->value, input_token->length);\n\treturn (0);\n}\n\n/*\n * NegHints ::= SEQUENCE {\n *    hintName       [0]  GeneralString      OPTIONAL,\n *    hintAddress    [1]  OCTET STRING       OPTIONAL\n * }\n */\n\n#define HOST_PREFIX\t\"host@\"\n#define HOST_PREFIX_LEN\t(sizeof(HOST_PREFIX) - 1)\n\nstatic int\nmake_NegHints(OM_uint32 *minor_status,\n\t      spnego_gss_cred_id_t spcred, gss_buffer_t *outbuf)\n{\n\tgss_buffer_desc hintNameBuf;\n\tgss_name_t hintName = GSS_C_NO_NAME;\n\tgss_name_t hintKerberosName;\n\tgss_OID hintNameType;\n\tOM_uint32 major_status;\n\tOM_uint32 minor;\n\tunsigned int tlen = 0;\n\tunsigned int hintNameSize = 0;\n\tunsigned char *ptr;\n\tunsigned char *t;\n\n\t*outbuf = GSS_C_NO_BUFFER;\n\n\tif (spcred != NULL) {\n\t\tmajor_status = gss_inquire_cred(minor_status,\n\t\t\t\t\t\tspcred->mcred,\n\t\t\t\t\t\t&hintName,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tNULL);\n\t\tif (major_status != GSS_S_COMPLETE)\n\t\t\treturn (major_status);\n\t}\n\n\tif (hintName == GSS_C_NO_NAME) {\n\t\tkrb5_error_code code;\n\t\tkrb5int_access kaccess;\n\t\tchar hostname[HOST_PREFIX_LEN + MAXHOSTNAMELEN + 1] = HOST_PREFIX;\n\n\t\tcode = krb5int_accessor(&kaccess, KRB5INT_ACCESS_VERSION);\n\t\tif (code != 0) {\n\t\t\t*minor_status = code;\n\t\t\treturn (GSS_S_FAILURE);\n\t\t}\n\n\t\t/* this breaks mutual authentication but Samba relies on it */\n\t\tcode = (*kaccess.clean_hostname)(NULL, NULL,\n\t\t\t\t\t\t &hostname[HOST_PREFIX_LEN],\n\t\t\t\t\t\t MAXHOSTNAMELEN);\n\t\tif (code != 0) {\n\t\t\t*minor_status = code;\n\t\t\treturn (GSS_S_FAILURE);\n\t\t}\n\n\t\thintNameBuf.value = hostname;\n\t\thintNameBuf.length = strlen(hostname);\n\n\t\tmajor_status = gss_import_name(minor_status,\n\t\t\t\t\t       &hintNameBuf,\n\t\t\t\t\t       GSS_C_NT_HOSTBASED_SERVICE,\n\t\t\t\t\t       &hintName);\n\t\tif (major_status != GSS_S_COMPLETE) {\n\t\t\treturn (major_status);\n\t\t}\n\t}\n\n\thintNameBuf.value = NULL;\n\thintNameBuf.length = 0;\n\n\tmajor_status = gss_canonicalize_name(minor_status,\n\t\t\t\t\t     hintName,\n\t\t\t\t\t     (gss_OID)&gss_mech_krb5_oid,\n\t\t\t\t\t     &hintKerberosName);\n\tif (major_status != GSS_S_COMPLETE) {\n\t\tgss_release_name(&minor, &hintName);\n\t\treturn (major_status);\n\t}\n\tgss_release_name(&minor, &hintName);\n\n\tmajor_status = gss_display_name(minor_status,\n\t\t\t\t\thintKerberosName,\n\t\t\t\t\t&hintNameBuf,\n\t\t\t\t\t&hintNameType);\n\tif (major_status != GSS_S_COMPLETE) {\n\t\tgss_release_name(&minor, &hintName);\n\t\treturn (major_status);\n\t}\n\tgss_release_name(&minor, &hintKerberosName);\n\n\t/*\n\t * Now encode the name hint into a NegHints ASN.1 type\n\t */\n\tmajor_status = GSS_S_FAILURE;\n\n\t/* Length of DER encoded GeneralString */\n\ttlen = 1 + gssint_der_length_size(hintNameBuf.length) +\n\t\thintNameBuf.length;\n\thintNameSize = tlen;\n\n\t/* Length of DER encoded hintName */\n\ttlen += 1 + gssint_der_length_size(hintNameSize);\n\n\tt = gssalloc_malloc(tlen);\n\tif (t == NULL) {\n\t\t*minor_status = ENOMEM;\n\t\tgoto errout;\n\t}\n\n\tptr = t;\n\n\t*ptr++ = CONTEXT | 0x00; /* hintName identifier */\n\tif (gssint_put_der_length(hintNameSize,\n\t\t\t\t  &ptr, tlen - (int)(ptr-t)))\n\t\tgoto errout;\n\n\t*ptr++ = GENERAL_STRING;\n\tif (gssint_put_der_length(hintNameBuf.length,\n\t\t\t\t  &ptr, tlen - (int)(ptr-t)))\n\t\tgoto errout;\n\n\tmemcpy(ptr, hintNameBuf.value, hintNameBuf.length);\n\tptr += hintNameBuf.length;\n\n\t*outbuf = (gss_buffer_t)malloc(sizeof(gss_buffer_desc));\n\tif (*outbuf == NULL) {\n\t\t*minor_status = ENOMEM;\n\t\tgoto errout;\n\t}\n\t(*outbuf)->value = (void *)t;\n\t(*outbuf)->length = ptr - t;\n\n\tt = NULL; /* don't free */\n\n\t*minor_status = 0;\n\tmajor_status = GSS_S_COMPLETE;\n\nerrout:\n\tif (t != NULL) {\n\t\tfree(t);\n\t}\n\n\tgss_release_buffer(&minor, &hintNameBuf);\n\n\treturn (major_status);\n}\n\n/*\n * Support the Microsoft NegHints extension to SPNEGO for compatibility with\n * some versions of Samba.  See:\n *   http://msdn.microsoft.com/en-us/library/cc247039(PROT.10).aspx\n */\nstatic OM_uint32\nacc_ctx_hints(OM_uint32 *minor_status,\n\t      gss_ctx_id_t *ctx,\n\t      spnego_gss_cred_id_t spcred,\n\t      gss_buffer_t *mechListMIC,\n\t      OM_uint32 *negState,\n\t      send_token_flag *return_token)\n{\n\tOM_uint32 tmpmin, ret;\n\tgss_OID_set supported_mechSet;\n\tspnego_gss_ctx_id_t sc = NULL;\n\n\t*mechListMIC = GSS_C_NO_BUFFER;\n\tsupported_mechSet = GSS_C_NO_OID_SET;\n\t*return_token = NO_TOKEN_SEND;\n\t*negState = REJECT;\n\t*minor_status = 0;\n\n\t/* A hint request must be the first token received. */\n\tif (*ctx != GSS_C_NO_CONTEXT)\n\t    return GSS_S_DEFECTIVE_TOKEN;\n\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_ACCEPT,\n\t\t\t\t   &supported_mechSet);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tret = make_NegHints(minor_status, spcred, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tsc = create_spnego_ctx();\n\tif (sc == NULL) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tif (put_mech_set(supported_mechSet, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tsc->internal_mech = GSS_C_NO_OID;\n\n\t*negState = ACCEPT_INCOMPLETE;\n\t*return_token = INIT_TOKEN_SEND;\n\tsc->firstpass = 1;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\tret = GSS_S_COMPLETE;\n\ncleanup:\n\trelease_spnego_ctx(&sc);\n\tgss_release_oid_set(&tmpmin, &supported_mechSet);\n\n\treturn ret;\n}\n\n/*\n * Set negState to REJECT if the token is defective, else\n * ACCEPT_INCOMPLETE or REQUEST_MIC, depending on whether initiator's\n * preferred mechanism is supported.\n */\nstatic OM_uint32\nacc_ctx_new(OM_uint32 *minor_status,\n\t    gss_buffer_t buf,\n\t    gss_ctx_id_t *ctx,\n\t    spnego_gss_cred_id_t spcred,\n\t    gss_buffer_t *mechToken,\n\t    gss_buffer_t *mechListMIC,\n\t    OM_uint32 *negState,\n\t    send_token_flag *return_token)\n{\n\tOM_uint32 tmpmin, ret, req_flags;\n\tgss_OID_set supported_mechSet, mechTypes;\n\tgss_buffer_desc der_mechTypes;\n\tgss_OID mech_wanted;\n\tspnego_gss_ctx_id_t sc = NULL;\n\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\tder_mechTypes.length = 0;\n\tder_mechTypes.value = NULL;\n\t*mechToken = *mechListMIC = GSS_C_NO_BUFFER;\n\tsupported_mechSet = mechTypes = GSS_C_NO_OID_SET;\n\t*return_token = ERROR_TOKEN_SEND;\n\t*negState = REJECT;\n\t*minor_status = 0;\n\n\tret = get_negTokenInit(minor_status, buf, &der_mechTypes,\n\t\t\t       &mechTypes, &req_flags,\n\t\t\t       mechToken, mechListMIC);\n\tif (ret != GSS_S_COMPLETE) {\n\t\tgoto cleanup;\n\t}\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_ACCEPT,\n\t\t\t\t   &supported_mechSet);\n\tif (ret != GSS_S_COMPLETE) {\n\t\t*return_token = NO_TOKEN_SEND;\n\t\tgoto cleanup;\n\t}\n\t/*\n\t * Select the best match between the list of mechs\n\t * that the initiator requested and the list that\n\t * the acceptor will support.\n\t */\n\tmech_wanted = negotiate_mech(supported_mechSet, mechTypes, negState);\n\tif (*negState == REJECT) {\n\t\tret = GSS_S_BAD_MECH;\n\t\tgoto cleanup;\n\t}\n\tsc = (spnego_gss_ctx_id_t)*ctx;\n\tif (sc != NULL) {\n\t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n\t\tassert(mech_wanted != GSS_C_NO_OID);\n\t} else\n\t\tsc = create_spnego_ctx();\n\tif (sc == NULL) {\n\t\tret = GSS_S_FAILURE;\n\t\t*return_token = NO_TOKEN_SEND;\n\t\tgoto cleanup;\n\t}\n\tsc->mech_set = mechTypes;\n\tmechTypes = GSS_C_NO_OID_SET;\n\tsc->internal_mech = mech_wanted;\n\tsc->DER_mechTypes = der_mechTypes;\n\tder_mechTypes.length = 0;\n\tder_mechTypes.value = NULL;\n\n\tif (*negState == REQUEST_MIC)\n\t\tsc->mic_reqd = 1;\n\n\t*return_token = INIT_TOKEN_SEND;\n\tsc->firstpass = 1;\n\t*ctx = (gss_ctx_id_t)sc;\n\tret = GSS_S_COMPLETE;\ncleanup:\n\tgss_release_oid_set(&tmpmin, &mechTypes);\n\tgss_release_oid_set(&tmpmin, &supported_mechSet);\n\tif (der_mechTypes.length != 0)\n\t\tgss_release_buffer(&tmpmin, &der_mechTypes);\n\n\treturn ret;\n}\n\nstatic OM_uint32\nacc_ctx_cont(OM_uint32 *minstat,\n\t     gss_buffer_t buf,\n\t     gss_ctx_id_t *ctx,\n\t     gss_buffer_t *responseToken,\n\t     gss_buffer_t *mechListMIC,\n\t     OM_uint32 *negState,\n\t     send_token_flag *return_token)\n{\n\tOM_uint32 ret, tmpmin;\n\tgss_OID supportedMech;\n\tspnego_gss_ctx_id_t sc;\n\tunsigned int len;\n\tunsigned char *ptr, *bufstart;\n\n\tsc = (spnego_gss_ctx_id_t)*ctx;\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\t*negState = REJECT;\n\t*minstat = 0;\n\tsupportedMech = GSS_C_NO_OID;\n\t*return_token = ERROR_TOKEN_SEND;\n\t*responseToken = *mechListMIC = GSS_C_NO_BUFFER;\n\n\tptr = bufstart = buf->value;\n#define REMAIN (buf->length - (ptr - bufstart))\n\tif (REMAIN > INT_MAX)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\t/*\n\t * Attempt to work with old Sun SPNEGO.\n\t */\n\tif (*ptr == HEADER_ID) {\n\t\tret = g_verify_token_header(gss_mech_spnego,\n\t\t\t\t\t    &len, &ptr, 0, REMAIN);\n\t\tif (ret) {\n\t\t\t*minstat = ret;\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t\t}\n\t}\n\tif (*ptr != (CONTEXT | 0x01)) {\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tret = get_negTokenResp(minstat, ptr, REMAIN,\n\t\t\t       negState, &supportedMech,\n\t\t\t       responseToken, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tif (*responseToken == GSS_C_NO_BUFFER &&\n\t    *mechListMIC == GSS_C_NO_BUFFER) {\n\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tsc->firstpass = 0;\n\t*negState = ACCEPT_INCOMPLETE;\n\t*return_token = CONT_TOKEN_SEND;\ncleanup:\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tgeneric_gss_release_oid(&tmpmin, &supportedMech);\n\t}\n\treturn ret;\n#undef REMAIN\n}\n\n/*\n * Verify that mech OID is either exactly the same as the negotiated\n * mech OID, or is a mech OID supported by the negotiated mech.  MS\n * implementations can list a most preferred mech using an incorrect\n * krb5 OID while emitting a krb5 initiator mech token having the\n * correct krb5 mech OID.\n */\nstatic OM_uint32\nacc_ctx_vfy_oid(OM_uint32 *minor_status,\n\t\tspnego_gss_ctx_id_t sc, gss_OID mechoid,\n\t\tOM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 ret, tmpmin;\n\tgss_mechanism mech = NULL;\n\tgss_OID_set mech_set = GSS_C_NO_OID_SET;\n\tint present = 0;\n\n\tif (g_OID_equal(sc->internal_mech, mechoid))\n\t\treturn GSS_S_COMPLETE;\n\n\tmech = gssint_get_mechanism(sc->internal_mech);\n\tif (mech == NULL || mech->gss_indicate_mechs == NULL) {\n\t\t*minor_status = ERR_SPNEGO_NEGOTIATION_FAILED;\n\t\tmap_errcode(minor_status);\n\t\t*negState = REJECT;\n\t\t*tokflag = ERROR_TOKEN_SEND;\n\t\treturn GSS_S_BAD_MECH;\n\t}\n\tret = mech->gss_indicate_mechs(minor_status, &mech_set);\n\tif (ret != GSS_S_COMPLETE) {\n\t\t*tokflag = NO_TOKEN_SEND;\n\t\tmap_error(minor_status, mech);\n\t\tgoto cleanup;\n\t}\n\tret = gss_test_oid_set_member(minor_status, mechoid,\n\t\t\t\t      mech_set, &present);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tif (!present) {\n\t\t*minor_status = ERR_SPNEGO_NEGOTIATION_FAILED;\n\t\tmap_errcode(minor_status);\n\t\t*negState = REJECT;\n\t\t*tokflag = ERROR_TOKEN_SEND;\n\t\tret = GSS_S_BAD_MECH;\n\t}\ncleanup:\n\tgss_release_oid_set(&tmpmin, &mech_set);\n\treturn ret;\n}\n#ifndef LEAN_CLIENT\n/*\n * Wrap call to gss_accept_sec_context() and update state\n * accordingly.\n */\nstatic OM_uint32\nacc_ctx_call_acc(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n\t\t spnego_gss_cred_id_t spcred, gss_buffer_t mechtok_in,\n\t\t gss_OID *mech_type, gss_buffer_t mechtok_out,\n\t\t OM_uint32 *ret_flags, OM_uint32 *time_rec,\n\t\t gss_cred_id_t *delegated_cred_handle,\n\t\t OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\tgss_OID_desc mechoid;\n\tgss_cred_id_t mcred;\n\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n\t\t/*\n\t\t * mechoid is an alias; don't free it.\n\t\t */\n\t\tret = gssint_get_mech_type(&mechoid, mechtok_in);\n\t\tif (ret != GSS_S_COMPLETE) {\n\t\t\t*tokflag = NO_TOKEN_SEND;\n\t\t\treturn ret;\n\t\t}\n\t\tret = acc_ctx_vfy_oid(minor_status, sc, &mechoid,\n\t\t\t\t      negState, tokflag);\n\t\tif (ret != GSS_S_COMPLETE)\n\t\t\treturn ret;\n\t}\n\n\tmcred = (spcred == NULL) ? GSS_C_NO_CREDENTIAL : spcred->mcred;\n\tret = gss_accept_sec_context(minor_status,\n\t\t\t\t     &sc->ctx_handle,\n\t\t\t\t     mcred,\n\t\t\t\t     mechtok_in,\n\t\t\t\t     GSS_C_NO_CHANNEL_BINDINGS,\n\t\t\t\t     &sc->internal_name,\n\t\t\t\t     mech_type,\n\t\t\t\t     mechtok_out,\n\t\t\t\t     &sc->ctx_flags,\n\t\t\t\t     time_rec,\n\t\t\t\t     delegated_cred_handle);\n\tif (ret == GSS_S_COMPLETE) {\n#ifdef MS_BUG_TEST\n\t\t/*\n\t\t * Force MIC to be not required even if we previously\n\t\t * requested a MIC.\n\t\t */\n\t\tchar *envstr = getenv(\"MS_FORCE_NO_MIC\");\n\n\t\tif (envstr != NULL && strcmp(envstr, \"1\") == 0 &&\n\t\t    !(sc->ctx_flags & GSS_C_MUTUAL_FLAG) &&\n\t\t    sc->mic_reqd) {\n\n\t\t\tsc->mic_reqd = 0;\n\t\t}\n#endif\n\t\tsc->mech_complete = 1;\n\t\tif (ret_flags != NULL)\n\t\t\t*ret_flags = sc->ctx_flags;\n\n\t\tif (!sc->mic_reqd ||\n\t\t    !(sc->ctx_flags & GSS_C_INTEG_FLAG)) {\n\t\t\t/* No MIC exchange required, so we're done. */\n\t\t\t*negState = ACCEPT_COMPLETE;\n\t\t\tret = GSS_S_COMPLETE;\n\t\t} else {\n\t\t\t/* handle_mic will decide if we're done. */\n\t\t\tret = GSS_S_CONTINUE_NEEDED;\n\t\t}\n\t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n\t\t*negState = REJECT;\n\t\t*tokflag = ERROR_TOKEN_SEND;\n\t}\n\treturn ret;\n}\n\n/*ARGSUSED*/\nOM_uint32 KRB5_CALLCONV\nspnego_gss_accept_sec_context(\n\t\t\t    OM_uint32 *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_cred_id_t verifier_cred_handle,\n\t\t\t    gss_buffer_t input_token,\n\t\t\t    gss_channel_bindings_t input_chan_bindings,\n\t\t\t    gss_name_t *src_name,\n\t\t\t    gss_OID *mech_type,\n\t\t\t    gss_buffer_t output_token,\n\t\t\t    OM_uint32 *ret_flags,\n\t\t\t    OM_uint32 *time_rec,\n\t\t\t    gss_cred_id_t *delegated_cred_handle)\n{\n\tOM_uint32 ret, tmpmin, negState;\n\tsend_token_flag return_token;\n\tgss_buffer_t mechtok_in, mic_in, mic_out;\n\tgss_buffer_desc mechtok_out = GSS_C_EMPTY_BUFFER;\n\tspnego_gss_ctx_id_t sc = NULL;\n\tspnego_gss_cred_id_t spcred = NULL;\n\tint sendTokenInit = 0, tmpret;\n\n\tmechtok_in = mic_in = mic_out = GSS_C_NO_BUFFER;\n\n\t/*\n\t * This function works in three steps:\n\t *\n\t *   1. Perform mechanism negotiation.\n\t *   2. Invoke the negotiated mech's gss_accept_sec_context function\n\t *      and examine the results.\n\t *   3. Process or generate MICs if necessary.\n\t *\n\t * Step one determines whether the negotiation requires a MIC exchange,\n\t * while steps two and three share responsibility for determining when\n\t * the exchange is complete.  If the selected mech completes in this\n\t * call and no MIC exchange is expected, then step 2 will decide.  If a\n\t * MIC exchange is expected, then step 3 will decide.  If an error\n\t * occurs in any step, the exchange will be aborted, possibly with an\n\t * error token.\n\t *\n\t * negState determines the state of the negotiation, and is\n\t * communicated to the acceptor if a continuing token is sent.\n\t * return_token is used to indicate what type of token, if any, should\n\t * be generated.\n\t */\n\n\t/* Validate arguments. */\n\tif (minor_status != NULL)\n\t\t*minor_status = 0;\n\tif (output_token != GSS_C_NO_BUFFER) {\n\t\toutput_token->length = 0;\n\t\toutput_token->value = NULL;\n\t}\n\n\tif (minor_status == NULL ||\n\t    output_token == GSS_C_NO_BUFFER ||\n\t    context_handle == NULL)\n\t\treturn GSS_S_CALL_INACCESSIBLE_WRITE;\n\n\tif (input_token == GSS_C_NO_BUFFER)\n\t\treturn GSS_S_CALL_INACCESSIBLE_READ;\n\n\t/* Step 1: Perform mechanism negotiation. */\n\tsc = (spnego_gss_ctx_id_t)*context_handle;\n\tspcred = (spnego_gss_cred_id_t)verifier_cred_handle;\n\tif (sc == NULL || sc->internal_mech == GSS_C_NO_OID) {\n\t\t/* Process an initial token or request for NegHints. */\n\t\tif (src_name != NULL)\n\t\t\t*src_name = GSS_C_NO_NAME;\n\t\tif (mech_type != NULL)\n\t\t\t*mech_type = GSS_C_NO_OID;\n\t\tif (time_rec != NULL)\n\t\t\t*time_rec = 0;\n\t\tif (ret_flags != NULL)\n\t\t\t*ret_flags = 0;\n\t\tif (delegated_cred_handle != NULL)\n\t\t\t*delegated_cred_handle = GSS_C_NO_CREDENTIAL;\n\t\tif (input_token->length == 0) {\n\t\t\tret = acc_ctx_hints(minor_status,\n\t\t\t\t\t    context_handle, spcred,\n\t\t\t\t\t    &mic_out,\n\t\t\t\t\t    &negState,\n\t\t\t\t\t    &return_token);\n\t\t\tif (ret != GSS_S_COMPLETE)\n\t\t\t\tgoto cleanup;\n\t\t\tsendTokenInit = 1;\n\t\t\tret = GSS_S_CONTINUE_NEEDED;\n\t\t} else {\n\t\t\t/* Can set negState to REQUEST_MIC */\n\t\t\tret = acc_ctx_new(minor_status, input_token,\n\t\t\t\t\t  context_handle, spcred,\n\t\t\t\t\t  &mechtok_in, &mic_in,\n\t\t\t\t\t  &negState, &return_token);\n\t\t\tif (ret != GSS_S_COMPLETE)\n\t\t\t\tgoto cleanup;\n\t\t\tret = GSS_S_CONTINUE_NEEDED;\n\t\t}\n\t} else {\n\t\t/* Process a response token.  Can set negState to\n\t\t * ACCEPT_INCOMPLETE. */\n\t\tret = acc_ctx_cont(minor_status, input_token,\n\t\t\t\t   context_handle, &mechtok_in,\n\t\t\t\t   &mic_in, &negState, &return_token);\n\t\tif (ret != GSS_S_COMPLETE)\n\t\t\tgoto cleanup;\n\t\tret = GSS_S_CONTINUE_NEEDED;\n\t}\n\n\t/* Step 2: invoke the negotiated mechanism's gss_accept_sec_context\n\t * function. */\n\tsc = (spnego_gss_ctx_id_t)*context_handle;\n\t/*\n\t * Handle mechtok_in and mic_in only if they are\n\t * present in input_token.  If neither is present, whether\n\t * this is an error depends on whether this is the first\n\t * round-trip.  RET is set to a default value according to\n\t * whether it is the first round-trip.\n\t */\n\tif (negState != REQUEST_MIC && mechtok_in != GSS_C_NO_BUFFER) {\n\t\tret = acc_ctx_call_acc(minor_status, sc, spcred,\n\t\t\t\t       mechtok_in, mech_type, &mechtok_out,\n\t\t\t\t       ret_flags, time_rec,\n\t\t\t\t       delegated_cred_handle,\n\t\t\t\t       &negState, &return_token);\n\t}\n\n\t/* Step 3: process or generate the MIC, if the negotiated mech is\n\t * complete and supports MICs. */\n\tif (!HARD_ERROR(ret) && sc->mech_complete &&\n\t    (sc->ctx_flags & GSS_C_INTEG_FLAG)) {\n\n\t\tret = handle_mic(minor_status, mic_in,\n\t\t\t\t (mechtok_out.length != 0),\n\t\t\t\t sc, &mic_out,\n\t\t\t\t &negState, &return_token);\n\t}\ncleanup:\n\tif (return_token == INIT_TOKEN_SEND && sendTokenInit) {\n\t\tassert(sc != NULL);\n\t\ttmpret = make_spnego_tokenInit_msg(sc, 1, mic_out, 0,\n\t\t\t\t\t\t   GSS_C_NO_BUFFER,\n\t\t\t\t\t\t   return_token, output_token);\n\t\tif (tmpret < 0)\n\t\t\tret = GSS_S_FAILURE;\n\t} else if (return_token != NO_TOKEN_SEND &&\n\t\t   return_token != CHECK_MIC) {\n\t\ttmpret = make_spnego_tokenTarg_msg(negState,\n\t\t\t\t\t\t   sc ? sc->internal_mech :\n\t\t\t\t\t\t   GSS_C_NO_OID,\n\t\t\t\t\t\t   &mechtok_out, mic_out,\n\t\t\t\t\t\t   return_token,\n\t\t\t\t\t\t   output_token);\n\t\tif (tmpret < 0)\n\t\t\tret = GSS_S_FAILURE;\n\t}\n\tif (ret == GSS_S_COMPLETE) {\n\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n\t\tif (sc->internal_name != GSS_C_NO_NAME &&\n\t\t    src_name != NULL) {\n\t\t\t*src_name = sc->internal_name;\n\t\t\tsc->internal_name = GSS_C_NO_NAME;\n\t\t}\n\t\trelease_spnego_ctx(&sc);\n\t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n\t\tif (sc != NULL) {\n\t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n\t\t\t\t\t       GSS_C_NO_BUFFER);\n\t\t\trelease_spnego_ctx(&sc);\n\t\t}\n\t\t*context_handle = GSS_C_NO_CONTEXT;\n\t}\n\tgss_release_buffer(&tmpmin, &mechtok_out);\n\tif (mechtok_in != GSS_C_NO_BUFFER) {\n\t\tgss_release_buffer(&tmpmin, mechtok_in);\n\t\tfree(mechtok_in);\n\t}\n\tif (mic_in != GSS_C_NO_BUFFER) {\n\t\tgss_release_buffer(&tmpmin, mic_in);\n\t\tfree(mic_in);\n\t}\n\tif (mic_out != GSS_C_NO_BUFFER) {\n\t\tgss_release_buffer(&tmpmin, mic_out);\n\t\tfree(mic_out);\n\t}\n\treturn ret;\n}\n#endif /*  LEAN_CLIENT */\n\n/*ARGSUSED*/\nOM_uint32 KRB5_CALLCONV\nspnego_gss_display_status(\n\t\tOM_uint32 *minor_status,\n\t\tOM_uint32 status_value,\n\t\tint status_type,\n\t\tgss_OID mech_type,\n\t\tOM_uint32 *message_context,\n\t\tgss_buffer_t status_string)\n{\n\tOM_uint32 maj = GSS_S_COMPLETE;\n\tint ret;\n\n\tdsyslog(\"Entering display_status\\n\");\n\n\t*message_context = 0;\n\tswitch (status_value) {\n\t    case ERR_SPNEGO_NO_MECHS_AVAILABLE:\n\t\t/* CSTYLED */\n\t\t*status_string = make_err_msg(_(\"SPNEGO cannot find \"\n\t\t\t\t\t\t\"mechanisms to negotiate\"));\n\t\tbreak;\n\t    case ERR_SPNEGO_NO_CREDS_ACQUIRED:\n\t\t/* CSTYLED */\n\t\t*status_string = make_err_msg(_(\"SPNEGO failed to acquire \"\n\t\t\t\t\t\t\"creds\"));\n\t\tbreak;\n\t    case ERR_SPNEGO_NO_MECH_FROM_ACCEPTOR:\n\t\t/* CSTYLED */\n\t\t*status_string = make_err_msg(_(\"SPNEGO acceptor did not \"\n\t\t\t\t\t\t\"select a mechanism\"));\n\t\tbreak;\n\t    case ERR_SPNEGO_NEGOTIATION_FAILED:\n\t\t/* CSTYLED */\n\t\t*status_string = make_err_msg(_(\"SPNEGO failed to negotiate a \"\n\t\t\t\t\t\t\"mechanism\"));\n\t\tbreak;\n\t    case ERR_SPNEGO_NO_TOKEN_FROM_ACCEPTOR:\n\t\t/* CSTYLED */\n\t\t*status_string = make_err_msg(_(\"SPNEGO acceptor did not \"\n\t\t\t\t\t\t\"return a valid token\"));\n\t\tbreak;\n\t    default:\n\t\t/* Not one of our minor codes; might be from a mech.  Call back\n\t\t * to gss_display_status, but first check for recursion. */\n\t\tif (k5_getspecific(K5_KEY_GSS_SPNEGO_STATUS) != NULL) {\n\t\t\t/* Perhaps we returned a com_err code like ENOMEM. */\n\t\t\tconst char *err = error_message(status_value);\n\t\t\t*status_string = make_err_msg(err);\n\t\t\tbreak;\n\t\t}\n\t\t/* Set a non-null pointer value; doesn't matter which one. */\n\t\tret = k5_setspecific(K5_KEY_GSS_SPNEGO_STATUS, &ret);\n\t\tif (ret != 0) {\n\t\t\t*minor_status = ret;\n\t\t\tmaj = GSS_S_FAILURE;\n\t\t\tbreak;\n\t\t}\n\t\tmaj = gss_display_status(minor_status, status_value,\n\t\t\t\t\t status_type, mech_type,\n\t\t\t\t\t message_context, status_string);\n\t\t/* This is unlikely to fail; not much we can do if it does. */\n\t\t(void)k5_setspecific(K5_KEY_GSS_SPNEGO_STATUS, NULL);\n\t\tbreak;\n\t}\n\n\tdsyslog(\"Leaving display_status\\n\");\n\treturn maj;\n}\n\n\n/*ARGSUSED*/\nOM_uint32 KRB5_CALLCONV\nspnego_gss_import_name(\n\t\t    OM_uint32 *minor_status,\n\t\t    gss_buffer_t input_name_buffer,\n\t\t    gss_OID input_name_type,\n\t\t    gss_name_t *output_name)\n{\n\tOM_uint32 status;\n\n\tdsyslog(\"Entering import_name\\n\");\n\n\tstatus = gss_import_name(minor_status, input_name_buffer,\n\t\t\tinput_name_type, output_name);\n\n\tdsyslog(\"Leaving import_name\\n\");\n\treturn (status);\n}\n\n/*ARGSUSED*/\nOM_uint32 KRB5_CALLCONV\nspnego_gss_release_name(\n\t\t\tOM_uint32 *minor_status,\n\t\t\tgss_name_t *input_name)\n{\n\tOM_uint32 status;\n\n\tdsyslog(\"Entering release_name\\n\");\n\n\tstatus = gss_release_name(minor_status, input_name);\n\n\tdsyslog(\"Leaving release_name\\n\");\n\treturn (status);\n}\n\n/*ARGSUSED*/\nOM_uint32 KRB5_CALLCONV\nspnego_gss_duplicate_name(\n\t\t\tOM_uint32 *minor_status,\n\t\t\tconst gss_name_t input_name,\n\t\t\tgss_name_t *output_name)\n{\n\tOM_uint32 status;\n\n\tdsyslog(\"Entering duplicate_name\\n\");\n\n\tstatus = gss_duplicate_name(minor_status, input_name, output_name);\n\n\tdsyslog(\"Leaving duplicate_name\\n\");\n\treturn (status);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_inquire_cred(\n\t\t\tOM_uint32 *minor_status,\n\t\t\tgss_cred_id_t cred_handle,\n\t\t\tgss_name_t *name,\n\t\t\tOM_uint32 *lifetime,\n\t\t\tint *cred_usage,\n\t\t\tgss_OID_set *mechanisms)\n{\n\tOM_uint32 status;\n\tspnego_gss_cred_id_t spcred = NULL;\n\tgss_cred_id_t creds = GSS_C_NO_CREDENTIAL;\n\tOM_uint32 tmp_minor_status;\n\tOM_uint32 initiator_lifetime, acceptor_lifetime;\n\n\tdsyslog(\"Entering inquire_cred\\n\");\n\n\t/*\n\t * To avoid infinite recursion, if GSS_C_NO_CREDENTIAL is\n\t * supplied we call gss_inquire_cred_by_mech() on the\n\t * first non-SPNEGO mechanism.\n\t */\n\tspcred = (spnego_gss_cred_id_t)cred_handle;\n\tif (spcred == NULL) {\n\t\tstatus = get_available_mechs(minor_status,\n\t\t\tGSS_C_NO_NAME,\n\t\t\tGSS_C_BOTH,\n\t\t\tGSS_C_NO_CRED_STORE,\n\t\t\t&creds,\n\t\t\tmechanisms);\n\t\tif (status != GSS_S_COMPLETE) {\n\t\t\tdsyslog(\"Leaving inquire_cred\\n\");\n\t\t\treturn (status);\n\t\t}\n\n\t\tif ((*mechanisms)->count == 0) {\n\t\t\tgss_release_cred(&tmp_minor_status, &creds);\n\t\t\tgss_release_oid_set(&tmp_minor_status, mechanisms);\n\t\t\tdsyslog(\"Leaving inquire_cred\\n\");\n\t\t\treturn (GSS_S_DEFECTIVE_CREDENTIAL);\n\t\t}\n\n\t\tassert((*mechanisms)->elements != NULL);\n\n\t\tstatus = gss_inquire_cred_by_mech(minor_status,\n\t\t\tcreds,\n\t\t\t&(*mechanisms)->elements[0],\n\t\t\tname,\n\t\t\t&initiator_lifetime,\n\t\t\t&acceptor_lifetime,\n\t\t\tcred_usage);\n\t\tif (status != GSS_S_COMPLETE) {\n\t\t\tgss_release_cred(&tmp_minor_status, &creds);\n\t\t\tdsyslog(\"Leaving inquire_cred\\n\");\n\t\t\treturn (status);\n\t\t}\n\n\t\tif (lifetime != NULL)\n\t\t\t*lifetime = (*cred_usage == GSS_C_ACCEPT) ?\n\t\t\t\tacceptor_lifetime : initiator_lifetime;\n\n\t\tgss_release_cred(&tmp_minor_status, &creds);\n\t} else {\n\t\tstatus = gss_inquire_cred(minor_status, spcred->mcred,\n\t\t\t\t\t  name, lifetime,\n\t\t\t\t\t  cred_usage, mechanisms);\n\t}\n\n\tdsyslog(\"Leaving inquire_cred\\n\");\n\n\treturn (status);\n}\n\n/*ARGSUSED*/\nOM_uint32 KRB5_CALLCONV\nspnego_gss_compare_name(\n\t\t\tOM_uint32 *minor_status,\n\t\t\tconst gss_name_t name1,\n\t\t\tconst gss_name_t name2,\n\t\t\tint *name_equal)\n{\n\tOM_uint32 status = GSS_S_COMPLETE;\n\tdsyslog(\"Entering compare_name\\n\");\n\n\tstatus = gss_compare_name(minor_status, name1, name2, name_equal);\n\n\tdsyslog(\"Leaving compare_name\\n\");\n\treturn (status);\n}\n\n/*ARGSUSED*/\n/*ARGSUSED*/\nOM_uint32 KRB5_CALLCONV\nspnego_gss_display_name(\n\t\t\tOM_uint32 *minor_status,\n\t\t\tgss_name_t input_name,\n\t\t\tgss_buffer_t output_name_buffer,\n\t\t\tgss_OID *output_name_type)\n{\n\tOM_uint32 status = GSS_S_COMPLETE;\n\tdsyslog(\"Entering display_name\\n\");\n\n\tstatus = gss_display_name(minor_status, input_name,\n\t\t\toutput_name_buffer, output_name_type);\n\n\tdsyslog(\"Leaving display_name\\n\");\n\treturn (status);\n}\n\n\n/*ARGSUSED*/\nOM_uint32 KRB5_CALLCONV\nspnego_gss_inquire_names_for_mech(\n\t\t\t\tOM_uint32\t*minor_status,\n\t\t\t\tgss_OID\t\tmechanism,\n\t\t\t\tgss_OID_set\t*name_types)\n{\n\tOM_uint32   major, minor;\n\n\tdsyslog(\"Entering inquire_names_for_mech\\n\");\n\t/*\n\t * We only know how to handle our own mechanism.\n\t */\n\tif ((mechanism != GSS_C_NULL_OID) &&\n\t    !g_OID_equal(gss_mech_spnego, mechanism)) {\n\t\t*minor_status = 0;\n\t\treturn (GSS_S_FAILURE);\n\t}\n\n\tmajor = gss_create_empty_oid_set(minor_status, name_types);\n\tif (major == GSS_S_COMPLETE) {\n\t\t/* Now add our members. */\n\t\tif (((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_USER_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE) &&\n\t\t    ((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_MACHINE_UID_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE) &&\n\t\t    ((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_STRING_UID_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE)) {\n\t\t\tmajor = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_HOSTBASED_SERVICE,\n\t\t\t\tname_types);\n\t\t}\n\n\t\tif (major != GSS_S_COMPLETE)\n\t\t\t(void) gss_release_oid_set(&minor, name_types);\n\t}\n\n\tdsyslog(\"Leaving inquire_names_for_mech\\n\");\n\treturn (major);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_unwrap(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t context_handle,\n\t\tgss_buffer_t input_message_buffer,\n\t\tgss_buffer_t output_message_buffer,\n\t\tint *conf_state,\n\t\tgss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap(minor_status,\n\t\t\tcontext_handle,\n\t\t\tinput_message_buffer,\n\t\t\toutput_message_buffer,\n\t\t\tconf_state,\n\t\t\tqop_state);\n\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_wrap(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t context_handle,\n\t\tint conf_req_flag,\n\t\tgss_qop_t qop_req,\n\t\tgss_buffer_t input_message_buffer,\n\t\tint *conf_state,\n\t\tgss_buffer_t output_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap(minor_status,\n\t\t    context_handle,\n\t\t    conf_req_flag,\n\t\t    qop_req,\n\t\t    input_message_buffer,\n\t\t    conf_state,\n\t\t    output_message_buffer);\n\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_process_context_token(\n\t\t\t\tOM_uint32\t*minor_status,\n\t\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\t\tconst gss_buffer_t token_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_process_context_token(minor_status,\n\t\t\t\t\tcontext_handle,\n\t\t\t\t\ttoken_buffer);\n\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_delete_sec_context(\n\t\t\t    OM_uint32 *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_buffer_t output_token)\n{\n\tOM_uint32 ret = GSS_S_COMPLETE;\n\tspnego_gss_ctx_id_t *ctx =\n\t\t    (spnego_gss_ctx_id_t *)context_handle;\n\n\t*minor_status = 0;\n\n\tif (context_handle == NULL)\n\t\treturn (GSS_S_FAILURE);\n\n\tif (*ctx == NULL)\n\t\treturn (GSS_S_COMPLETE);\n\n\t/*\n\t * If this is still an SPNEGO mech, release it locally.\n\t */\n\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n\t\t(void) gss_delete_sec_context(minor_status,\n\t\t\t\t    &(*ctx)->ctx_handle,\n\t\t\t\t    output_token);\n\t\t(void) release_spnego_ctx(ctx);\n\t} else {\n\t\tret = gss_delete_sec_context(minor_status,\n\t\t\t\t    context_handle,\n\t\t\t\t    output_token);\n\t}\n\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_context_time(\n\t\t\tOM_uint32\t*minor_status,\n\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\tOM_uint32\t*time_rec)\n{\n\tOM_uint32 ret;\n\tret = gss_context_time(minor_status,\n\t\t\t    context_handle,\n\t\t\t    time_rec);\n\treturn (ret);\n}\n#ifndef LEAN_CLIENT\nOM_uint32 KRB5_CALLCONV\nspnego_gss_export_sec_context(\n\t\t\t    OM_uint32\t  *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_buffer_t interprocess_token)\n{\n\tOM_uint32 ret;\n\tret = gss_export_sec_context(minor_status,\n\t\t\t\t    context_handle,\n\t\t\t\t    interprocess_token);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_import_sec_context(\n\tOM_uint32\t\t*minor_status,\n\tconst gss_buffer_t\tinterprocess_token,\n\tgss_ctx_id_t\t\t*context_handle)\n{\n\tOM_uint32 ret;\n\tret = gss_import_sec_context(minor_status,\n\t\t\t\t    interprocess_token,\n\t\t\t\t    context_handle);\n\treturn (ret);\n}\n#endif /* LEAN_CLIENT */\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_inquire_context(\n\t\t\tOM_uint32\t*minor_status,\n\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\tgss_name_t\t*src_name,\n\t\t\tgss_name_t\t*targ_name,\n\t\t\tOM_uint32\t*lifetime_rec,\n\t\t\tgss_OID\t\t*mech_type,\n\t\t\tOM_uint32\t*ctx_flags,\n\t\t\tint\t\t*locally_initiated,\n\t\t\tint\t\t*opened)\n{\n\tOM_uint32 ret = GSS_S_COMPLETE;\n\n\tret = gss_inquire_context(minor_status,\n\t\t\t\tcontext_handle,\n\t\t\t\tsrc_name,\n\t\t\t\ttarg_name,\n\t\t\t\tlifetime_rec,\n\t\t\t\tmech_type,\n\t\t\t\tctx_flags,\n\t\t\t\tlocally_initiated,\n\t\t\t\topened);\n\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_wrap_size_limit(\n\tOM_uint32\t*minor_status,\n\tconst gss_ctx_id_t context_handle,\n\tint\t\tconf_req_flag,\n\tgss_qop_t\tqop_req,\n\tOM_uint32\treq_output_size,\n\tOM_uint32\t*max_input_size)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_size_limit(minor_status,\n\t\t\t\tcontext_handle,\n\t\t\t\tconf_req_flag,\n\t\t\t\tqop_req,\n\t\t\t\treq_output_size,\n\t\t\t\tmax_input_size);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_get_mic(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tgss_qop_t  qop_req,\n\t\tconst gss_buffer_t message_buffer,\n\t\tgss_buffer_t message_token)\n{\n\tOM_uint32 ret;\n\tret = gss_get_mic(minor_status,\n\t\t    context_handle,\n\t\t    qop_req,\n\t\t    message_buffer,\n\t\t    message_token);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_verify_mic(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_buffer_t msg_buffer,\n\t\tconst gss_buffer_t token_buffer,\n\t\tgss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_verify_mic(minor_status,\n\t\t\t    context_handle,\n\t\t\t    msg_buffer,\n\t\t\t    token_buffer,\n\t\t\t    qop_state);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_inquire_sec_context_by_oid(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_OID desired_object,\n\t\tgss_buffer_set_t *data_set)\n{\n\tOM_uint32 ret;\n\tret = gss_inquire_sec_context_by_oid(minor_status,\n\t\t\t    context_handle,\n\t\t\t    desired_object,\n\t\t\t    data_set);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_inquire_cred_by_oid(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_cred_id_t cred_handle,\n\t\tconst gss_OID desired_object,\n\t\tgss_buffer_set_t *data_set)\n{\n\tOM_uint32 ret;\n\tspnego_gss_cred_id_t spcred = (spnego_gss_cred_id_t)cred_handle;\n\tgss_cred_id_t mcred;\n\tmcred = (spcred == NULL) ? GSS_C_NO_CREDENTIAL : spcred->mcred;\n\tret = gss_inquire_cred_by_oid(minor_status,\n\t\t\t\tmcred,\n\t\t\t\tdesired_object,\n\t\t\t\tdata_set);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_set_cred_option(\n\t\tOM_uint32 *minor_status,\n\t\tgss_cred_id_t *cred_handle,\n\t\tconst gss_OID desired_object,\n\t\tconst gss_buffer_t value)\n{\n\tOM_uint32 ret;\n\tOM_uint32 tmp_minor_status;\n\tspnego_gss_cred_id_t spcred = (spnego_gss_cred_id_t)*cred_handle;\n\tgss_cred_id_t mcred;\n\n\tmcred = (spcred == NULL) ? GSS_C_NO_CREDENTIAL : spcred->mcred;\n\tret = gss_set_cred_option(minor_status,\n\t\t\t\t  &mcred,\n\t\t\t\t  desired_object,\n\t\t\t\t  value);\n\tif (ret == GSS_S_COMPLETE && spcred == NULL) {\n\t\t/*\n\t\t * If the mechanism allocated a new credential handle, then\n\t\t * we need to wrap it up in an SPNEGO credential handle.\n\t\t */\n\n\t\tspcred = malloc(sizeof(spnego_gss_cred_id_rec));\n\t\tif (spcred == NULL) {\n\t\t\tgss_release_cred(&tmp_minor_status, &mcred);\n\t\t\t*minor_status = ENOMEM;\n\t\t\treturn (GSS_S_FAILURE);\n\t\t}\n\t\tspcred->mcred = mcred;\n\t\tspcred->neg_mechs = GSS_C_NULL_OID_SET;\n\t\t*cred_handle = (gss_cred_id_t)spcred;\n\t}\n\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_set_sec_context_option(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t *context_handle,\n\t\tconst gss_OID desired_object,\n\t\tconst gss_buffer_t value)\n{\n\tOM_uint32 ret;\n\tret = gss_set_sec_context_option(minor_status,\n\t\t\t    context_handle,\n\t\t\t    desired_object,\n\t\t\t    value);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_wrap_aead(OM_uint32 *minor_status,\n\t\t     gss_ctx_id_t context_handle,\n\t\t     int conf_req_flag,\n\t\t     gss_qop_t qop_req,\n\t\t     gss_buffer_t input_assoc_buffer,\n\t\t     gss_buffer_t input_payload_buffer,\n\t\t     int *conf_state,\n\t\t     gss_buffer_t output_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_aead(minor_status,\n\t\t\t    context_handle,\n\t\t\t    conf_req_flag,\n\t\t\t    qop_req,\n\t\t\t    input_assoc_buffer,\n\t\t\t    input_payload_buffer,\n\t\t\t    conf_state,\n\t\t\t    output_message_buffer);\n\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_unwrap_aead(OM_uint32 *minor_status,\n\t\t       gss_ctx_id_t context_handle,\n\t\t       gss_buffer_t input_message_buffer,\n\t\t       gss_buffer_t input_assoc_buffer,\n\t\t       gss_buffer_t output_payload_buffer,\n\t\t       int *conf_state,\n\t\t       gss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap_aead(minor_status,\n\t\t\t      context_handle,\n\t\t\t      input_message_buffer,\n\t\t\t      input_assoc_buffer,\n\t\t\t      output_payload_buffer,\n\t\t\t      conf_state,\n\t\t\t      qop_state);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_wrap_iov(OM_uint32 *minor_status,\n\t\t    gss_ctx_id_t context_handle,\n\t\t    int conf_req_flag,\n\t\t    gss_qop_t qop_req,\n\t\t    int *conf_state,\n\t\t    gss_iov_buffer_desc *iov,\n\t\t    int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_iov(minor_status,\n\t\t\t   context_handle,\n\t\t\t   conf_req_flag,\n\t\t\t   qop_req,\n\t\t\t   conf_state,\n\t\t\t   iov,\n\t\t\t   iov_count);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_unwrap_iov(OM_uint32 *minor_status,\n\t\t      gss_ctx_id_t context_handle,\n\t\t      int *conf_state,\n\t\t      gss_qop_t *qop_state,\n\t\t      gss_iov_buffer_desc *iov,\n\t\t      int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap_iov(minor_status,\n\t\t\t     context_handle,\n\t\t\t     conf_state,\n\t\t\t     qop_state,\n\t\t\t     iov,\n\t\t\t     iov_count);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n\t\t\t   gss_ctx_id_t context_handle,\n\t\t\t   int conf_req_flag,\n\t\t\t   gss_qop_t qop_req,\n\t\t\t   int *conf_state,\n\t\t\t   gss_iov_buffer_desc *iov,\n\t\t\t   int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_iov_length(minor_status,\n\t\t\t\t  context_handle,\n\t\t\t\t  conf_req_flag,\n\t\t\t\t  qop_req,\n\t\t\t\t  conf_state,\n\t\t\t\t  iov,\n\t\t\t\t  iov_count);\n\treturn (ret);\n}\n\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_complete_auth_token(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tgss_buffer_t input_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_complete_auth_token(minor_status,\n\t\t\t\t      context_handle,\n\t\t\t\t      input_message_buffer);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_acquire_cred_impersonate_name(OM_uint32 *minor_status,\n\t\t\t\t\t const gss_cred_id_t impersonator_cred_handle,\n\t\t\t\t\t const gss_name_t desired_name,\n\t\t\t\t\t OM_uint32 time_req,\n\t\t\t\t\t gss_OID_set desired_mechs,\n\t\t\t\t\t gss_cred_usage_t cred_usage,\n\t\t\t\t\t gss_cred_id_t *output_cred_handle,\n\t\t\t\t\t gss_OID_set *actual_mechs,\n\t\t\t\t\t OM_uint32 *time_rec)\n{\n\tOM_uint32 status;\n\tgss_OID_set amechs = GSS_C_NULL_OID_SET;\n\tspnego_gss_cred_id_t imp_spcred = NULL, out_spcred = NULL;\n\tgss_cred_id_t imp_mcred, out_mcred;\n\n\tdsyslog(\"Entering spnego_gss_acquire_cred_impersonate_name\\n\");\n\n\tif (actual_mechs)\n\t\t*actual_mechs = NULL;\n\n\tif (time_rec)\n\t\t*time_rec = 0;\n\n\timp_spcred = (spnego_gss_cred_id_t)impersonator_cred_handle;\n\timp_mcred = imp_spcred ? imp_spcred->mcred : GSS_C_NO_CREDENTIAL;\n\tif (desired_mechs == GSS_C_NO_OID_SET) {\n\t\tstatus = gss_inquire_cred(minor_status, imp_mcred, NULL, NULL,\n\t\t\t\t\t  NULL, &amechs);\n\t\tif (status != GSS_S_COMPLETE)\n\t\t\treturn status;\n\n\t\tdesired_mechs = amechs;\n\t}\n\n\tstatus = gss_acquire_cred_impersonate_name(minor_status, imp_mcred,\n\t\t\t\t\t\t   desired_name, time_req,\n\t\t\t\t\t\t   desired_mechs, cred_usage,\n\t\t\t\t\t\t   &out_mcred, actual_mechs,\n\t\t\t\t\t\t   time_rec);\n\n\tif (amechs != GSS_C_NULL_OID_SET)\n\t\t(void) gss_release_oid_set(minor_status, &amechs);\n\n\tout_spcred = malloc(sizeof(spnego_gss_cred_id_rec));\n\tif (out_spcred == NULL) {\n\t\tgss_release_cred(minor_status, &out_mcred);\n\t\t*minor_status = ENOMEM;\n\t\treturn (GSS_S_FAILURE);\n\t}\n\tout_spcred->mcred = out_mcred;\n\tout_spcred->neg_mechs = GSS_C_NULL_OID_SET;\n\t*output_cred_handle = (gss_cred_id_t)out_spcred;\n\n\tdsyslog(\"Leaving spnego_gss_acquire_cred_impersonate_name\\n\");\n\treturn (status);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_acquire_cred_with_password(OM_uint32 *minor_status,\n\t\t\t\t      const gss_name_t desired_name,\n\t\t\t\t      const gss_buffer_t password,\n\t\t\t\t      OM_uint32 time_req,\n\t\t\t\t      const gss_OID_set desired_mechs,\n\t\t\t\t      gss_cred_usage_t cred_usage,\n\t\t\t\t      gss_cred_id_t *output_cred_handle,\n\t\t\t\t      gss_OID_set *actual_mechs,\n\t\t\t\t      OM_uint32 *time_rec)\n{\n\tOM_uint32 status, tmpmin;\n\tgss_OID_set amechs = GSS_C_NULL_OID_SET;\n\tgss_cred_id_t mcred = NULL;\n\tspnego_gss_cred_id_t spcred = NULL;\n\n\tdsyslog(\"Entering spnego_gss_acquire_cred_with_password\\n\");\n\n\tif (actual_mechs)\n\t\t*actual_mechs = NULL;\n\n\tif (time_rec)\n\t\t*time_rec = 0;\n\n\tstatus = get_available_mechs(minor_status, desired_name,\n\t\t\t\t     cred_usage, GSS_C_NO_CRED_STORE,\n\t\t\t\t     NULL, &amechs);\n\tif (status != GSS_S_COMPLETE)\n\t    goto cleanup;\n\n\tstatus = gss_acquire_cred_with_password(minor_status, desired_name,\n\t\t\t\t\t\tpassword, time_req, amechs,\n\t\t\t\t\t\tcred_usage, &mcred,\n\t\t\t\t\t\tactual_mechs, time_rec);\n\tif (status != GSS_S_COMPLETE)\n\t    goto cleanup;\n\n\tspcred = malloc(sizeof(spnego_gss_cred_id_rec));\n\tif (spcred == NULL) {\n\t\t*minor_status = ENOMEM;\n\t\tstatus = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tspcred->neg_mechs = GSS_C_NULL_OID_SET;\n\tspcred->mcred = mcred;\n\tmcred = GSS_C_NO_CREDENTIAL;\n\t*output_cred_handle = (gss_cred_id_t)spcred;\n\ncleanup:\n\n\t(void) gss_release_oid_set(&tmpmin, &amechs);\n\t(void) gss_release_cred(&tmpmin, &mcred);\n\n\tdsyslog(\"Leaving spnego_gss_acquire_cred_with_password\\n\");\n\treturn (status);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_display_name_ext(OM_uint32 *minor_status,\n\t\t\t    gss_name_t name,\n\t\t\t    gss_OID display_as_name_type,\n\t\t\t    gss_buffer_t display_name)\n{\n\tOM_uint32 ret;\n\tret = gss_display_name_ext(minor_status,\n\t\t\t\t   name,\n\t\t\t\t   display_as_name_type,\n\t\t\t\t   display_name);\n\treturn (ret);\n}\n\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_inquire_name(OM_uint32 *minor_status,\n\t\t\tgss_name_t name,\n\t\t\tint *name_is_MN,\n\t\t\tgss_OID *MN_mech,\n\t\t\tgss_buffer_set_t *attrs)\n{\n\tOM_uint32 ret;\n\tret = gss_inquire_name(minor_status,\n\t\t\t       name,\n\t\t\t       name_is_MN,\n\t\t\t       MN_mech,\n\t\t\t       attrs);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_get_name_attribute(OM_uint32 *minor_status,\n\t\t\t      gss_name_t name,\n\t\t\t      gss_buffer_t attr,\n\t\t\t      int *authenticated,\n\t\t\t      int *complete,\n\t\t\t      gss_buffer_t value,\n\t\t\t      gss_buffer_t display_value,\n\t\t\t      int *more)\n{\n\tOM_uint32 ret;\n\tret = gss_get_name_attribute(minor_status,\n\t\t\t\t     name,\n\t\t\t\t     attr,\n\t\t\t\t     authenticated,\n\t\t\t\t     complete,\n\t\t\t\t     value,\n\t\t\t\t     display_value,\n\t\t\t\t     more);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_set_name_attribute(OM_uint32 *minor_status,\n\t\t\t      gss_name_t name,\n\t\t\t      int complete,\n\t\t\t      gss_buffer_t attr,\n\t\t\t      gss_buffer_t value)\n{\n\tOM_uint32 ret;\n\tret = gss_set_name_attribute(minor_status,\n\t\t\t\t     name,\n\t\t\t\t     complete,\n\t\t\t\t     attr,\n\t\t\t\t     value);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_delete_name_attribute(OM_uint32 *minor_status,\n\t\t\t\t gss_name_t name,\n\t\t\t\t gss_buffer_t attr)\n{\n\tOM_uint32 ret;\n\tret = gss_delete_name_attribute(minor_status,\n\t\t\t\t\tname,\n\t\t\t\t\tattr);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_export_name_composite(OM_uint32 *minor_status,\n\t\t\t\t gss_name_t name,\n\t\t\t\t gss_buffer_t exp_composite_name)\n{\n\tOM_uint32 ret;\n\tret = gss_export_name_composite(minor_status,\n\t\t\t\t\tname,\n\t\t\t\t\texp_composite_name);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_map_name_to_any(OM_uint32 *minor_status,\n\t\t\t   gss_name_t name,\n\t\t\t   int authenticated,\n\t\t\t   gss_buffer_t type_id,\n\t\t\t   gss_any_t *output)\n{\n\tOM_uint32 ret;\n\tret = gss_map_name_to_any(minor_status,\n\t\t\t\t  name,\n\t\t\t\t  authenticated,\n\t\t\t\t  type_id,\n\t\t\t\t  output);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_release_any_name_mapping(OM_uint32 *minor_status,\n\t\t\t\t    gss_name_t name,\n\t\t\t\t    gss_buffer_t type_id,\n\t\t\t\t    gss_any_t *input)\n{\n\tOM_uint32 ret;\n\tret = gss_release_any_name_mapping(minor_status,\n\t\t\t\t\t   name,\n\t\t\t\t\t   type_id,\n\t\t\t\t\t   input);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_pseudo_random(OM_uint32 *minor_status,\n\t\t\t gss_ctx_id_t context,\n\t\t\t int prf_key,\n\t\t\t const gss_buffer_t prf_in,\n\t\t\t ssize_t desired_output_len,\n\t\t\t gss_buffer_t prf_out)\n{\n\tOM_uint32 ret;\n\tret = gss_pseudo_random(minor_status,\n\t\t\t\tcontext,\n\t\t\t\tprf_key,\n\t\t\t\tprf_in,\n\t\t\t\tdesired_output_len,\n\t\t\t\tprf_out);\n        return (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_set_neg_mechs(OM_uint32 *minor_status,\n\t\t\t gss_cred_id_t cred_handle,\n\t\t\t const gss_OID_set mech_list)\n{\n\tOM_uint32 ret;\n\tspnego_gss_cred_id_t spcred = (spnego_gss_cred_id_t)cred_handle;\n\n\t/* Store mech_list in spcred for use in negotiation logic. */\n\tgss_release_oid_set(minor_status, &spcred->neg_mechs);\n\tret = generic_gss_copy_oid_set(minor_status, mech_list,\n\t\t\t\t       &spcred->neg_mechs);\n\treturn (ret);\n}\n\n#define SPNEGO_SASL_NAME\t\"SPNEGO\"\n#define SPNEGO_SASL_NAME_LEN\t(sizeof(SPNEGO_SASL_NAME) - 1)\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_inquire_mech_for_saslname(OM_uint32 *minor_status,\n                                     const gss_buffer_t sasl_mech_name,\n                                     gss_OID *mech_type)\n{\n\tif (sasl_mech_name->length == SPNEGO_SASL_NAME_LEN &&\n\t    memcmp(sasl_mech_name->value, SPNEGO_SASL_NAME,\n\t\t   SPNEGO_SASL_NAME_LEN) == 0) {\n\t\tif (mech_type != NULL)\n\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n\t\treturn (GSS_S_COMPLETE);\n\t}\n\n\treturn (GSS_S_BAD_MECH);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_inquire_saslname_for_mech(OM_uint32 *minor_status,\n                                     const gss_OID desired_mech,\n                                     gss_buffer_t sasl_mech_name,\n                                     gss_buffer_t mech_name,\n                                     gss_buffer_t mech_description)\n{\n\t*minor_status = 0;\n\n\tif (!g_OID_equal(desired_mech, gss_mech_spnego))\n\t\treturn (GSS_S_BAD_MECH);\n\n\tif (!g_make_string_buffer(SPNEGO_SASL_NAME, sasl_mech_name) ||\n\t    !g_make_string_buffer(\"spnego\", mech_name) ||\n\t    !g_make_string_buffer(\"Simple and Protected GSS-API \"\n\t\t\t\t  \"Negotiation Mechanism\", mech_description))\n\t\tgoto fail;\n\n\treturn (GSS_S_COMPLETE);\n\nfail:\n\t*minor_status = ENOMEM;\n\treturn (GSS_S_FAILURE);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_inquire_attrs_for_mech(OM_uint32 *minor_status,\n\t\t\t\t  gss_const_OID mech,\n\t\t\t\t  gss_OID_set *mech_attrs,\n\t\t\t\t  gss_OID_set *known_mech_attrs)\n{\n\tOM_uint32 major, tmpMinor;\n\n\t/* known_mech_attrs is handled by mechglue */\n\t*minor_status = 0;\n\n\tif (mech_attrs == NULL)\n\t    return (GSS_S_COMPLETE);\n\n\tmajor = gss_create_empty_oid_set(minor_status, mech_attrs);\n\tif (GSS_ERROR(major))\n\t\tgoto cleanup;\n\n#define MA_SUPPORTED(ma)    do {\t\t\t\t\t\\\n\t\tmajor = gss_add_oid_set_member(minor_status,\t\t\\\n\t\t\t\t\t       (gss_OID)ma, mech_attrs); \\\n\t\tif (GSS_ERROR(major))\t\t\t\t\t\\\n\t\t\tgoto cleanup;\t\t\t\t\t\\\n\t} while (0)\n\n\tMA_SUPPORTED(GSS_C_MA_MECH_NEGO);\n\tMA_SUPPORTED(GSS_C_MA_ITOK_FRAMED);\n\ncleanup:\n\tif (GSS_ERROR(major))\n\t\tgss_release_oid_set(&tmpMinor, mech_attrs);\n\n\treturn (major);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_export_cred(OM_uint32 *minor_status,\n\t\t       gss_cred_id_t cred_handle,\n\t\t       gss_buffer_t token)\n{\n\tspnego_gss_cred_id_t spcred = (spnego_gss_cred_id_t)cred_handle;\n\n\treturn (gss_export_cred(minor_status, spcred->mcred, token));\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_import_cred(OM_uint32 *minor_status,\n\t\t       gss_buffer_t token,\n\t\t       gss_cred_id_t *cred_handle)\n{\n\tOM_uint32 ret;\n\tspnego_gss_cred_id_t spcred;\n\tgss_cred_id_t mcred;\n\n\tret = gss_import_cred(minor_status, token, &mcred);\n\tif (GSS_ERROR(ret))\n\t\treturn (ret);\n\tspcred = malloc(sizeof(*spcred));\n\tif (spcred == NULL) {\n\t\tgss_release_cred(minor_status, &mcred);\n\t\t*minor_status = ENOMEM;\n\t\treturn (GSS_S_FAILURE);\n\t}\n\tspcred->mcred = mcred;\n\tspcred->neg_mechs = GSS_C_NULL_OID_SET;\n\t*cred_handle = (gss_cred_id_t)spcred;\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n\t\t       int iov_count)\n{\n    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n\t\t\t   iov_count);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n\t\t\t  int iov_count)\n{\n    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n\t\t\t      iov_count);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n\t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n\t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n{\n    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n\t\t\t\t  iov_count);\n}\n\n/*\n * We will release everything but the ctx_handle so that it\n * can be passed back to init/accept context. This routine should\n * not be called until after the ctx_handle memory is assigned to\n * the supplied context handle from init/accept context.\n */\nstatic void\nrelease_spnego_ctx(spnego_gss_ctx_id_t *ctx)\n{\n\tspnego_gss_ctx_id_t context;\n\tOM_uint32 minor_stat;\n\tcontext = *ctx;\n\n\tif (context != NULL) {\n\t\t(void) gss_release_buffer(&minor_stat,\n\t\t\t\t\t&context->DER_mechTypes);\n\n\t\t(void) gss_release_oid_set(&minor_stat, &context->mech_set);\n\n\t\t(void) gss_release_name(&minor_stat, &context->internal_name);\n\n\t\tif (context->optionStr != NULL) {\n\t\t\tfree(context->optionStr);\n\t\t\tcontext->optionStr = NULL;\n\t\t}\n\t\tfree(context);\n\t\t*ctx = NULL;\n\t}\n}\n\n/*\n * Can't use gss_indicate_mechs by itself to get available mechs for\n * SPNEGO because it will also return the SPNEGO mech and we do not\n * want to consider SPNEGO as an available security mech for\n * negotiation. For this reason, get_available_mechs will return\n * all available mechs except SPNEGO.\n *\n * If a ptr to a creds list is given, this function will attempt\n * to acquire creds for the creds given and trim the list of\n * returned mechanisms to only those for which creds are valid.\n *\n */\nstatic OM_uint32\nget_available_mechs(OM_uint32 *minor_status,\n\tgss_name_t name, gss_cred_usage_t usage,\n\tgss_const_key_value_set_t cred_store,\n\tgss_cred_id_t *creds, gss_OID_set *rmechs)\n{\n\tunsigned int\ti;\n\tint\t\tfound = 0;\n\tOM_uint32 major_status = GSS_S_COMPLETE, tmpmin;\n\tgss_OID_set mechs, goodmechs;\n\n\tmajor_status = gss_indicate_mechs(minor_status, &mechs);\n\n\tif (major_status != GSS_S_COMPLETE) {\n\t\treturn (major_status);\n\t}\n\n\tmajor_status = gss_create_empty_oid_set(minor_status, rmechs);\n\n\tif (major_status != GSS_S_COMPLETE) {\n\t\t(void) gss_release_oid_set(minor_status, &mechs);\n\t\treturn (major_status);\n\t}\n\n\tfor (i = 0; i < mechs->count && major_status == GSS_S_COMPLETE; i++) {\n\t\tif ((mechs->elements[i].length\n\t\t    != spnego_mechanism.mech_type.length) ||\n\t\t    memcmp(mechs->elements[i].elements,\n\t\t\tspnego_mechanism.mech_type.elements,\n\t\t\tspnego_mechanism.mech_type.length)) {\n\n\t\t\tmajor_status = gss_add_oid_set_member(minor_status,\n\t\t\t\t\t\t\t      &mechs->elements[i],\n\t\t\t\t\t\t\t      rmechs);\n\t\t\tif (major_status == GSS_S_COMPLETE)\n\t\t\t\tfound++;\n\t\t}\n\t}\n\n\t/*\n\t * If the caller wanted a list of creds returned,\n\t * trim the list of mechanisms down to only those\n\t * for which the creds are valid.\n\t */\n\tif (found > 0 && major_status == GSS_S_COMPLETE && creds != NULL) {\n\t\tmajor_status = gss_acquire_cred_from(minor_status, name,\n\t\t\t\t\t\t     GSS_C_INDEFINITE,\n\t\t\t\t\t\t     *rmechs, usage,\n\t\t\t\t\t\t     cred_store, creds,\n\t\t\t\t\t\t     &goodmechs, NULL);\n\n\t\t/*\n\t\t * Drop the old list in favor of the new\n\t\t * \"trimmed\" list.\n\t\t */\n\t\t(void) gss_release_oid_set(&tmpmin, rmechs);\n\t\tif (major_status == GSS_S_COMPLETE) {\n\t\t\t(void) gssint_copy_oid_set(&tmpmin,\n\t\t\t\t\tgoodmechs, rmechs);\n\t\t\t(void) gss_release_oid_set(&tmpmin, &goodmechs);\n\t\t}\n\t}\n\n\t(void) gss_release_oid_set(&tmpmin, &mechs);\n\tif (found == 0 || major_status != GSS_S_COMPLETE) {\n\t\t*minor_status = ERR_SPNEGO_NO_MECHS_AVAILABLE;\n\t\tmap_errcode(minor_status);\n\t\tif (major_status == GSS_S_COMPLETE)\n\t\t\tmajor_status = GSS_S_FAILURE;\n\t}\n\n\treturn (major_status);\n}\n\n/*\n * Return a list of mechanisms we are willing to negotiate for a credential,\n * taking into account the mech set provided with gss_set_neg_mechs if it\n * exists.\n */\nstatic OM_uint32\nget_negotiable_mechs(OM_uint32 *minor_status, spnego_gss_cred_id_t spcred,\n\t\t     gss_cred_usage_t usage, gss_OID_set *rmechs)\n{\n\tOM_uint32 ret, tmpmin;\n\tgss_cred_id_t creds = GSS_C_NO_CREDENTIAL, *credptr;\n\tgss_OID_set cred_mechs = GSS_C_NULL_OID_SET;\n\tgss_OID_set intersect_mechs = GSS_C_NULL_OID_SET;\n\tunsigned int i;\n\tint present;\n\n\tif (spcred == NULL) {\n\t\t/*\n\t\t * The default credentials were supplied.  Return a list of all\n\t\t * available mechs except SPNEGO.  When initiating, trim this\n\t\t * list to mechs we can acquire credentials for.\n\t\t */\n\t\tcredptr = (usage == GSS_C_INITIATE) ? &creds : NULL;\n\t\tret = get_available_mechs(minor_status, GSS_C_NO_NAME, usage,\n\t\t\t\t\t  GSS_C_NO_CRED_STORE, credptr,\n\t\t\t\t\t  rmechs);\n\t\tgss_release_cred(&tmpmin, &creds);\n\t\treturn (ret);\n\t}\n\n\t/* Get the list of mechs in the mechglue cred. */\n\tret = gss_inquire_cred(minor_status, spcred->mcred, NULL, NULL, NULL,\n\t\t\t       &cred_mechs);\n\tif (ret != GSS_S_COMPLETE)\n\t\treturn (ret);\n\n\tif (spcred->neg_mechs == GSS_C_NULL_OID_SET) {\n\t\t/* gss_set_neg_mechs was never called; return cred_mechs. */\n\t\t*rmechs = cred_mechs;\n\t\t*minor_status = 0;\n\t\treturn (GSS_S_COMPLETE);\n\t}\n\n\t/* Compute the intersection of cred_mechs and spcred->neg_mechs,\n\t * preserving the order in spcred->neg_mechs. */\n\tret = gss_create_empty_oid_set(minor_status, &intersect_mechs);\n\tif (ret != GSS_S_COMPLETE) {\n\t\tgss_release_oid_set(&tmpmin, &cred_mechs);\n\t\treturn (ret);\n\t}\n\n\tfor (i = 0; i < spcred->neg_mechs->count; i++) {\n\t\tgss_test_oid_set_member(&tmpmin,\n\t\t\t\t\t&spcred->neg_mechs->elements[i],\n\t\t\t\t\tcred_mechs, &present);\n\t\tif (!present)\n\t\t\tcontinue;\n\t\tret = gss_add_oid_set_member(minor_status,\n\t\t\t\t\t     &spcred->neg_mechs->elements[i],\n\t\t\t\t\t     &intersect_mechs);\n\t\tif (ret != GSS_S_COMPLETE)\n\t\t\tbreak;\n\t}\n\n\tgss_release_oid_set(&tmpmin, &cred_mechs);\n\tif (intersect_mechs->count == 0 || ret != GSS_S_COMPLETE) {\n\t\tgss_release_oid_set(&tmpmin, &intersect_mechs);\n\t\t*minor_status = ERR_SPNEGO_NO_MECHS_AVAILABLE;\n\t\tmap_errcode(minor_status);\n\t\treturn (GSS_S_FAILURE);\n\t}\n\n\t*rmechs = intersect_mechs;\n\t*minor_status = 0;\n\treturn (GSS_S_COMPLETE);\n}\n\n/* following are token creation and reading routines */\n\n/*\n * If buff_in is not pointing to a MECH_OID, then return NULL and do not\n * advance the buffer, otherwise, decode the mech_oid from the buffer and\n * place in gss_OID.\n */\nstatic gss_OID\nget_mech_oid(OM_uint32 *minor_status, unsigned char **buff_in, size_t length)\n{\n\tOM_uint32\tstatus;\n\tgss_OID_desc \ttoid;\n\tgss_OID\t\tmech_out = NULL;\n\tunsigned char\t\t*start, *end;\n\n\tif (length < 1 || **buff_in != MECH_OID)\n\t\treturn (NULL);\n\n\tstart = *buff_in;\n\tend = start + length;\n\n\t(*buff_in)++;\n\ttoid.length = *(*buff_in)++;\n\n\tif ((*buff_in + toid.length) > end)\n\t\treturn (NULL);\n\n\ttoid.elements = *buff_in;\n\t*buff_in += toid.length;\n\n\tstatus = generic_gss_copy_oid(minor_status, &toid, &mech_out);\n\n\tif (status != GSS_S_COMPLETE) {\n\t\tmap_errcode(minor_status);\n\t\tmech_out = NULL;\n\t}\n\n\treturn (mech_out);\n}\n\n/*\n * der encode the given mechanism oid into buf_out, advancing the\n * buffer pointer.\n */\n\nstatic int\nput_mech_oid(unsigned char **buf_out, gss_OID_const mech, unsigned int buflen)\n{\n\tif (buflen < mech->length + 2)\n\t\treturn (-1);\n\t*(*buf_out)++ = MECH_OID;\n\t*(*buf_out)++ = (unsigned char) mech->length;\n\tmemcpy(*buf_out, mech->elements, mech->length);\n\t*buf_out += mech->length;\n\treturn (0);\n}\n\n/*\n * verify that buff_in points to an octet string, if it does not,\n * return NULL and don't advance the pointer. If it is an octet string\n * decode buff_in into a gss_buffer_t and return it, advancing the\n * buffer pointer.\n */\nstatic gss_buffer_t\nget_input_token(unsigned char **buff_in, unsigned int buff_length)\n{\n\tgss_buffer_t input_token;\n\tunsigned int len;\n\n\tif (g_get_tag_and_length(buff_in, OCTET_STRING, buff_length, &len) < 0)\n\t\treturn (NULL);\n\n\tinput_token = (gss_buffer_t)malloc(sizeof (gss_buffer_desc));\n\tif (input_token == NULL)\n\t\treturn (NULL);\n\n\tinput_token->length = len;\n\tif (input_token->length > 0) {\n\t\tinput_token->value = gssalloc_malloc(input_token->length);\n\t\tif (input_token->value == NULL) {\n\t\t\tfree(input_token);\n\t\t\treturn (NULL);\n\t\t}\n\n\t\tmemcpy(input_token->value, *buff_in, input_token->length);\n\t} else {\n\t\tinput_token->value = NULL;\n\t}\n\t*buff_in += input_token->length;\n\treturn (input_token);\n}\n\n/*\n * verify that the input token length is not 0. If it is, just return.\n * If the token length is greater than 0, der encode as an octet string\n * and place in buf_out, advancing buf_out.\n */\n\nstatic int\nput_input_token(unsigned char **buf_out, gss_buffer_t input_token,\n\t\tunsigned int buflen)\n{\n\tint ret;\n\n\t/* if token length is 0, we do not want to send */\n\tif (input_token->length == 0)\n\t\treturn (0);\n\n\tif (input_token->length > buflen)\n\t\treturn (-1);\n\n\t*(*buf_out)++ = OCTET_STRING;\n\tif ((ret = gssint_put_der_length(input_token->length, buf_out,\n\t\t\t    input_token->length)))\n\t\treturn (ret);\n\tTWRITE_STR(*buf_out, input_token->value, input_token->length);\n\treturn (0);\n}\n\n/*\n * verify that buff_in points to a sequence of der encoding. The mech\n * set is the only sequence of encoded object in the token, so if it is\n * a sequence of encoding, decode the mechset into a gss_OID_set and\n * return it, advancing the buffer pointer.\n */\nstatic gss_OID_set\nget_mech_set(OM_uint32 *minor_status, unsigned char **buff_in,\n\t     unsigned int buff_length)\n{\n\tgss_OID_set returned_mechSet;\n\tOM_uint32 major_status;\n\tint length;\n\tunsigned int bytes;\n\tOM_uint32 set_length;\n\tunsigned char\t\t*start;\n\tint i;\n\n\tif (**buff_in != SEQUENCE_OF)\n\t\treturn (NULL);\n\n\tstart = *buff_in;\n\t(*buff_in)++;\n\n\tlength = gssint_get_der_length(buff_in, buff_length, &bytes);\n\tif (length < 0 || buff_length - bytes < (unsigned int)length)\n\t\treturn NULL;\n\n\tmajor_status = gss_create_empty_oid_set(minor_status,\n\t\t\t\t\t\t&returned_mechSet);\n\tif (major_status != GSS_S_COMPLETE)\n\t\treturn (NULL);\n\n\tfor (set_length = 0, i = 0; set_length < (unsigned int)length; i++) {\n\t\tgss_OID_desc *temp = get_mech_oid(minor_status, buff_in,\n\t\t\tbuff_length - (*buff_in - start));\n\t\tif (temp == NULL)\n\t\t\tbreak;\n\n\t\tmajor_status = gss_add_oid_set_member(minor_status,\n\t\t\t\t\t\t      temp, &returned_mechSet);\n\t\tif (major_status == GSS_S_COMPLETE) {\n\t\t\tset_length += returned_mechSet->elements[i].length +2;\n\t\t\tif (generic_gss_release_oid(minor_status, &temp))\n\t\t\t\tmap_errcode(minor_status);\n\t\t}\n\t}\n\n\treturn (returned_mechSet);\n}\n\n/*\n * Encode mechSet into buf.\n */\nstatic int\nput_mech_set(gss_OID_set mechSet, gss_buffer_t buf)\n{\n\tunsigned char *ptr;\n\tunsigned int i;\n\tunsigned int tlen, ilen;\n\n\ttlen = ilen = 0;\n\tfor (i = 0; i < mechSet->count; i++) {\n\t\t/*\n\t\t * 0x06 [DER LEN] [OID]\n\t\t */\n\t\tilen += 1 +\n\t\t\tgssint_der_length_size(mechSet->elements[i].length) +\n\t\t\tmechSet->elements[i].length;\n\t}\n\t/*\n\t * 0x30 [DER LEN]\n\t */\n\ttlen = 1 + gssint_der_length_size(ilen) + ilen;\n\tptr = gssalloc_malloc(tlen);\n\tif (ptr == NULL)\n\t\treturn -1;\n\n\tbuf->value = ptr;\n\tbuf->length = tlen;\n#define REMAIN (buf->length - ((unsigned char *)buf->value - ptr))\n\n\t*ptr++ = SEQUENCE_OF;\n\tif (gssint_put_der_length(ilen, &ptr, REMAIN) < 0)\n\t\treturn -1;\n\tfor (i = 0; i < mechSet->count; i++) {\n\t\tif (put_mech_oid(&ptr, &mechSet->elements[i], REMAIN) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n#undef REMAIN\n}\n\n/*\n * Verify that buff_in is pointing to a BIT_STRING with the correct\n * length and padding for the req_flags. If it is, decode req_flags\n * and return them, otherwise, return NULL.\n */\nstatic OM_uint32\nget_req_flags(unsigned char **buff_in, OM_uint32 bodysize,\n\t      OM_uint32 *req_flags)\n{\n\tunsigned int len;\n\n\tif (**buff_in != (CONTEXT | 0x01))\n\t\treturn (0);\n\n\tif (g_get_tag_and_length(buff_in, (CONTEXT | 0x01),\n\t\t\t\tbodysize, &len) < 0)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\tif (*(*buff_in)++ != BIT_STRING)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\tif (*(*buff_in)++ != BIT_STRING_LENGTH)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\tif (*(*buff_in)++ != BIT_STRING_PADDING)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\t*req_flags = (OM_uint32) (*(*buff_in)++ >> 1);\n\treturn (0);\n}\n\nstatic OM_uint32\nget_negTokenInit(OM_uint32 *minor_status,\n\t\t gss_buffer_t buf,\n\t\t gss_buffer_t der_mechSet,\n\t\t gss_OID_set *mechSet,\n\t\t OM_uint32 *req_flags,\n\t\t gss_buffer_t *mechtok,\n\t\t gss_buffer_t *mechListMIC)\n{\n\tOM_uint32 err;\n\tunsigned char *ptr, *bufstart;\n\tunsigned int len;\n\tgss_buffer_desc tmpbuf;\n\n\t*minor_status = 0;\n\tder_mechSet->length = 0;\n\tder_mechSet->value = NULL;\n\t*mechSet = GSS_C_NO_OID_SET;\n\t*req_flags = 0;\n\t*mechtok = *mechListMIC = GSS_C_NO_BUFFER;\n\n\tptr = bufstart = buf->value;\n\tif ((buf->length - (ptr - bufstart)) > INT_MAX)\n\t\treturn GSS_S_FAILURE;\n#define REMAIN (buf->length - (ptr - bufstart))\n\n\terr = g_verify_token_header(gss_mech_spnego,\n\t\t\t\t    &len, &ptr, 0, REMAIN);\n\tif (err) {\n\t\t*minor_status = err;\n\t\tmap_errcode(minor_status);\n\t\treturn GSS_S_FAILURE;\n\t}\n\t*minor_status = g_verify_neg_token_init(&ptr, REMAIN);\n\tif (*minor_status) {\n\t\tmap_errcode(minor_status);\n\t\treturn GSS_S_FAILURE;\n\t}\n\n\t/* alias into input_token */\n\ttmpbuf.value = ptr;\n\ttmpbuf.length = REMAIN;\n\t*mechSet = get_mech_set(minor_status, &ptr, REMAIN);\n\tif (*mechSet == NULL)\n\t\treturn GSS_S_FAILURE;\n\n\ttmpbuf.length = ptr - (unsigned char *)tmpbuf.value;\n\tder_mechSet->value = gssalloc_malloc(tmpbuf.length);\n\tif (der_mechSet->value == NULL)\n\t\treturn GSS_S_FAILURE;\n\tmemcpy(der_mechSet->value, tmpbuf.value, tmpbuf.length);\n\tder_mechSet->length = tmpbuf.length;\n\n\terr = get_req_flags(&ptr, REMAIN, req_flags);\n\tif (err != GSS_S_COMPLETE) {\n\t\treturn err;\n\t}\n\tif (g_get_tag_and_length(&ptr, (CONTEXT | 0x02),\n\t\t\t\t REMAIN, &len) >= 0) {\n\t\t*mechtok = get_input_token(&ptr, len);\n\t\tif (*mechtok == GSS_C_NO_BUFFER) {\n\t\t\treturn GSS_S_FAILURE;\n\t\t}\n\t}\n\tif (g_get_tag_and_length(&ptr, (CONTEXT | 0x03),\n\t\t\t\t REMAIN, &len) >= 0) {\n\t\t*mechListMIC = get_input_token(&ptr, len);\n\t\tif (*mechListMIC == GSS_C_NO_BUFFER) {\n\t\t\treturn GSS_S_FAILURE;\n\t\t}\n\t}\n\treturn GSS_S_COMPLETE;\n#undef REMAIN\n}\n\nstatic OM_uint32\nget_negTokenResp(OM_uint32 *minor_status,\n\t\t unsigned char *buf, unsigned int buflen,\n\t\t OM_uint32 *negState,\n\t\t gss_OID *supportedMech,\n\t\t gss_buffer_t *responseToken,\n\t\t gss_buffer_t *mechListMIC)\n{\n\tunsigned char *ptr, *bufstart;\n\tunsigned int len;\n\tint tmplen;\n\tunsigned int tag, bytes;\n\n\t*negState = ACCEPT_DEFECTIVE_TOKEN;\n\t*supportedMech = GSS_C_NO_OID;\n\t*responseToken = *mechListMIC = GSS_C_NO_BUFFER;\n\tptr = bufstart = buf;\n#define REMAIN (buflen - (ptr - bufstart))\n\n\tif (g_get_tag_and_length(&ptr, (CONTEXT | 0x01), REMAIN, &len) < 0)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tif (*ptr++ == SEQUENCE) {\n\t\ttmplen = gssint_get_der_length(&ptr, REMAIN, &bytes);\n\t\tif (tmplen < 0 || REMAIN < (unsigned int)tmplen)\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tif (REMAIN < 1)\n\t\ttag = 0;\n\telse\n\t\ttag = *ptr++;\n\n\tif (tag == CONTEXT) {\n\t\ttmplen = gssint_get_der_length(&ptr, REMAIN, &bytes);\n\t\tif (tmplen < 0 || REMAIN < (unsigned int)tmplen)\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\t\tif (g_get_tag_and_length(&ptr, ENUMERATED,\n\t\t\t\t\t REMAIN, &len) < 0)\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\t\tif (len != ENUMERATION_LENGTH)\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\t\tif (REMAIN < 1)\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t\t*negState = *ptr++;\n\n\t\tif (REMAIN < 1)\n\t\t\ttag = 0;\n\t\telse\n\t\t\ttag = *ptr++;\n\t}\n\tif (tag == (CONTEXT | 0x01)) {\n\t\ttmplen = gssint_get_der_length(&ptr, REMAIN, &bytes);\n\t\tif (tmplen < 0 || REMAIN < (unsigned int)tmplen)\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\t\t*supportedMech = get_mech_oid(minor_status, &ptr, REMAIN);\n\t\tif (*supportedMech == GSS_C_NO_OID)\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\t\tif (REMAIN < 1)\n\t\t\ttag = 0;\n\t\telse\n\t\t\ttag = *ptr++;\n\t}\n\tif (tag == (CONTEXT | 0x02)) {\n\t\ttmplen = gssint_get_der_length(&ptr, REMAIN, &bytes);\n\t\tif (tmplen < 0 || REMAIN < (unsigned int)tmplen)\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\t\t*responseToken = get_input_token(&ptr, REMAIN);\n\t\tif (*responseToken == GSS_C_NO_BUFFER)\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\t\tif (REMAIN < 1)\n\t\t\ttag = 0;\n\t\telse\n\t\t\ttag = *ptr++;\n\t}\n\tif (tag == (CONTEXT | 0x03)) {\n\t\ttmplen = gssint_get_der_length(&ptr, REMAIN, &bytes);\n\t\tif (tmplen < 0 || REMAIN < (unsigned int)tmplen)\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\t\t*mechListMIC = get_input_token(&ptr, REMAIN);\n\t\tif (*mechListMIC == GSS_C_NO_BUFFER)\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n                /* Handle Windows 2000 duplicate response token */\n                if (*responseToken &&\n                    ((*responseToken)->length == (*mechListMIC)->length) &&\n                    !memcmp((*responseToken)->value, (*mechListMIC)->value,\n                            (*responseToken)->length)) {\n\t\t\tOM_uint32 tmpmin;\n\n\t\t\tgss_release_buffer(&tmpmin, *mechListMIC);\n\t\t\tfree(*mechListMIC);\n\t\t\t*mechListMIC = NULL;\n\t\t}\n\t}\n\treturn GSS_S_COMPLETE;\n#undef REMAIN\n}\n\n/*\n * der encode the passed negResults as an ENUMERATED type and\n * place it in buf_out, advancing the buffer.\n */\n\nstatic int\nput_negResult(unsigned char **buf_out, OM_uint32 negResult,\n\t      unsigned int buflen)\n{\n\tif (buflen < 3)\n\t\treturn (-1);\n\t*(*buf_out)++ = ENUMERATED;\n\t*(*buf_out)++ = ENUMERATION_LENGTH;\n\t*(*buf_out)++ = (unsigned char) negResult;\n\treturn (0);\n}\n\n/*\n * This routine compares the recieved mechset to the mechset that\n * this server can support. It looks sequentially through the mechset\n * and the first one that matches what the server can support is\n * chosen as the negotiated mechanism. If one is found, negResult\n * is set to ACCEPT_INCOMPLETE if it's the first mech, REQUEST_MIC if\n * it's not the first mech, otherwise we return NULL and negResult\n * is set to REJECT. The returned pointer is an alias into\n * received->elements and should not be freed.\n *\n * NOTE: There is currently no way to specify a preference order of\n * mechanisms supported by the acceptor.\n */\nstatic gss_OID\nnegotiate_mech(gss_OID_set supported, gss_OID_set received,\n\t       OM_uint32 *negResult)\n{\n\tsize_t i, j;\n\n\tfor (i = 0; i < received->count; i++) {\n\t\tgss_OID mech_oid = &received->elements[i];\n\n\t\t/* Accept wrong mechanism OID from MS clients */\n\t\tif (g_OID_equal(mech_oid, &gss_mech_krb5_wrong_oid))\n\t\t\tmech_oid = (gss_OID)&gss_mech_krb5_oid;\n\n\t\tfor (j = 0; j < supported->count; j++) {\n\t\t\tif (g_OID_equal(mech_oid, &supported->elements[j])) {\n\t\t\t\t*negResult = (i == 0) ? ACCEPT_INCOMPLETE :\n\t\t\t\t\tREQUEST_MIC;\n\t\t\t\treturn &received->elements[i];\n\t\t\t}\n\t\t}\n\t}\n\t*negResult = REJECT;\n\treturn (NULL);\n}\n\n/*\n * the next two routines make a token buffer suitable for\n * spnego_gss_display_status. These currently take the string\n * in name and place it in the token. Eventually, if\n * spnego_gss_display_status returns valid error messages,\n * these routines will be changes to return the error string.\n */\nstatic spnego_token_t\nmake_spnego_token(const char *name)\n{\n\treturn (spnego_token_t)strdup(name);\n}\n\nstatic gss_buffer_desc\nmake_err_msg(const char *name)\n{\n\tgss_buffer_desc buffer;\n\n\tif (name == NULL) {\n\t\tbuffer.length = 0;\n\t\tbuffer.value = NULL;\n\t} else {\n\t\tbuffer.length = strlen(name)+1;\n\t\tbuffer.value = make_spnego_token(name);\n\t}\n\n\treturn (buffer);\n}\n\n/*\n * Create the client side spnego token passed back to gss_init_sec_context\n * and eventually up to the application program and over to the server.\n *\n * Use DER rules, definite length method per RFC 2478\n */\nstatic int\nmake_spnego_tokenInit_msg(spnego_gss_ctx_id_t spnego_ctx,\n\t\t\t  int negHintsCompat,\n\t\t\t  gss_buffer_t mechListMIC, OM_uint32 req_flags,\n\t\t\t  gss_buffer_t data, send_token_flag sendtoken,\n\t\t\t  gss_buffer_t outbuf)\n{\n\tint ret = 0;\n\tunsigned int tlen, dataLen = 0;\n\tunsigned int negTokenInitSize = 0;\n\tunsigned int negTokenInitSeqSize = 0;\n\tunsigned int negTokenInitContSize = 0;\n\tunsigned int rspTokenSize = 0;\n\tunsigned int mechListTokenSize = 0;\n\tunsigned int micTokenSize = 0;\n\tunsigned char *t;\n\tunsigned char *ptr;\n\n\tif (outbuf == GSS_C_NO_BUFFER)\n\t\treturn (-1);\n\n\toutbuf->length = 0;\n\toutbuf->value = NULL;\n\n\t/* calculate the data length */\n\n\t/*\n\t * 0xa0 [DER LEN] [mechTypes]\n\t */\n\tmechListTokenSize = 1 +\n\t\tgssint_der_length_size(spnego_ctx->DER_mechTypes.length) +\n\t\tspnego_ctx->DER_mechTypes.length;\n\tdataLen += mechListTokenSize;\n\n\t/*\n\t * If a token from gss_init_sec_context exists,\n\t * add the length of the token + the ASN.1 overhead\n\t */\n\tif (data != NULL) {\n\t\t/*\n\t\t * Encoded in final output as:\n\t\t * 0xa2 [DER LEN] 0x04 [DER LEN] [DATA]\n\t\t * -----s--------|--------s2----------\n\t\t */\n\t\trspTokenSize = 1 +\n\t\t\tgssint_der_length_size(data->length) +\n\t\t\tdata->length;\n\t\tdataLen += 1 + gssint_der_length_size(rspTokenSize) +\n\t\t\trspTokenSize;\n\t}\n\n\tif (mechListMIC) {\n\t\t/*\n\t\t * Encoded in final output as:\n\t\t * 0xa3 [DER LEN] 0x04 [DER LEN] [DATA]\n\t\t *\t--s--     -----tlen------------\n\t\t */\n\t\tmicTokenSize = 1 +\n\t\t\tgssint_der_length_size(mechListMIC->length) +\n\t\t\tmechListMIC->length;\n\t\tdataLen += 1 +\n\t\t\tgssint_der_length_size(micTokenSize) +\n\t\t\tmicTokenSize;\n\t}\n\n\t/*\n\t * Add size of DER encoding\n\t * [ SEQUENCE { MechTypeList | ReqFLags | Token | mechListMIC } ]\n\t *   0x30 [DER_LEN] [data]\n\t *\n\t */\n\tnegTokenInitContSize = dataLen;\n\tnegTokenInitSeqSize = 1 + gssint_der_length_size(dataLen) + dataLen;\n\tdataLen = negTokenInitSeqSize;\n\n\t/*\n\t * negTokenInitSize indicates the bytes needed to\n\t * hold the ASN.1 encoding of the entire NegTokenInit\n\t * SEQUENCE.\n\t * 0xa0 [DER_LEN] + data\n\t *\n\t */\n\tnegTokenInitSize = 1 +\n\t\tgssint_der_length_size(negTokenInitSeqSize) +\n\t\tnegTokenInitSeqSize;\n\n\ttlen = g_token_size(gss_mech_spnego, negTokenInitSize);\n\n\tt = (unsigned char *) gssalloc_malloc(tlen);\n\n\tif (t == NULL) {\n\t\treturn (-1);\n\t}\n\n\tptr = t;\n\n\t/* create the message */\n\tif ((ret = g_make_token_header(gss_mech_spnego, negTokenInitSize,\n\t\t\t    &ptr, tlen)))\n\t\tgoto errout;\n\n\t*ptr++ = CONTEXT; /* NegotiationToken identifier */\n\tif ((ret = gssint_put_der_length(negTokenInitSeqSize, &ptr, tlen)))\n\t\tgoto errout;\n\n\t*ptr++ = SEQUENCE;\n\tif ((ret = gssint_put_der_length(negTokenInitContSize, &ptr,\n\t\t\t\t\t tlen - (int)(ptr-t))))\n\t\tgoto errout;\n\n\t*ptr++ = CONTEXT | 0x00; /* MechTypeList identifier */\n\tif ((ret = gssint_put_der_length(spnego_ctx->DER_mechTypes.length,\n\t\t\t\t\t &ptr, tlen - (int)(ptr-t))))\n\t\tgoto errout;\n\n\t/* We already encoded the MechSetList */\n\t(void) memcpy(ptr, spnego_ctx->DER_mechTypes.value,\n\t\t      spnego_ctx->DER_mechTypes.length);\n\n\tptr += spnego_ctx->DER_mechTypes.length;\n\n\tif (data != NULL) {\n\t\t*ptr++ = CONTEXT | 0x02;\n\t\tif ((ret = gssint_put_der_length(rspTokenSize,\n\t\t\t\t&ptr, tlen - (int)(ptr - t))))\n\t\t\tgoto errout;\n\n\t\tif ((ret = put_input_token(&ptr, data,\n\t\t\ttlen - (int)(ptr - t))))\n\t\t\tgoto errout;\n\t}\n\n\tif (mechListMIC != GSS_C_NO_BUFFER) {\n\t\t*ptr++ = CONTEXT | 0x03;\n\t\tif ((ret = gssint_put_der_length(micTokenSize,\n\t\t\t\t&ptr, tlen - (int)(ptr - t))))\n\t\t\tgoto errout;\n\n\t\tif (negHintsCompat) {\n\t\t\tret = put_neg_hints(&ptr, mechListMIC,\n\t\t\t\t\t    tlen - (int)(ptr - t));\n\t\t\tif (ret)\n\t\t\t\tgoto errout;\n\t\t} else if ((ret = put_input_token(&ptr, mechListMIC,\n\t\t\t\ttlen - (int)(ptr - t))))\n\t\t\tgoto errout;\n\t}\n\nerrout:\n\tif (ret != 0) {\n\t\tif (t)\n\t\t\tfree(t);\n\t\tt = NULL;\n\t\ttlen = 0;\n\t}\n\toutbuf->length = tlen;\n\toutbuf->value = (void *) t;\n\n\treturn (ret);\n}\n\n/*\n * create the server side spnego token passed back to\n * gss_accept_sec_context and eventually up to the application program\n * and over to the client.\n */\nstatic int\nmake_spnego_tokenTarg_msg(OM_uint32 status, gss_OID mech_wanted,\n\t\t\t  gss_buffer_t data, gss_buffer_t mechListMIC,\n\t\t\t  send_token_flag sendtoken,\n\t\t\t  gss_buffer_t outbuf)\n{\n\tunsigned int tlen = 0;\n\tunsigned int ret = 0;\n\tunsigned int NegTokenTargSize = 0;\n\tunsigned int NegTokenSize = 0;\n\tunsigned int rspTokenSize = 0;\n\tunsigned int micTokenSize = 0;\n\tunsigned int dataLen = 0;\n\tunsigned char *t;\n\tunsigned char *ptr;\n\n\tif (outbuf == GSS_C_NO_BUFFER)\n\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n\tif (sendtoken == INIT_TOKEN_SEND && mech_wanted == GSS_C_NO_OID)\n\t    return (GSS_S_DEFECTIVE_TOKEN);\n\n\toutbuf->length = 0;\n\toutbuf->value = NULL;\n\n\t/*\n\t * ASN.1 encoding of the negResult\n\t * ENUMERATED type is 3 bytes\n\t *  ENUMERATED TAG, Length, Value,\n\t * Plus 2 bytes for the CONTEXT id and length.\n\t */\n\tdataLen = 5;\n\n\t/*\n\t * calculate data length\n\t *\n\t * If this is the initial token, include length of\n\t * mech_type and the negotiation result fields.\n\t */\n\tif (sendtoken == INIT_TOKEN_SEND) {\n\t\tint mechlistTokenSize;\n\t\t/*\n\t\t * 1 byte for the CONTEXT ID(0xa0),\n\t\t * 1 byte for the OID ID(0x06)\n\t\t * 1 byte for OID Length field\n\t\t * Plus the rest... (OID Length, OID value)\n\t\t */\n\t\tmechlistTokenSize = 3 + mech_wanted->length +\n\t\t\tgssint_der_length_size(mech_wanted->length);\n\n\t\tdataLen += mechlistTokenSize;\n\t}\n\tif (data != NULL && data->length > 0) {\n\t\t/* Length of the inner token */\n\t\trspTokenSize = 1 + gssint_der_length_size(data->length) +\n\t\t\tdata->length;\n\n\t\tdataLen += rspTokenSize;\n\n\t\t/* Length of the outer token */\n\t\tdataLen += 1 + gssint_der_length_size(rspTokenSize);\n\t}\n\tif (mechListMIC != NULL) {\n\n\t\t/* Length of the inner token */\n\t\tmicTokenSize = 1 + gssint_der_length_size(mechListMIC->length) +\n\t\t\tmechListMIC->length;\n\n\t\tdataLen += micTokenSize;\n\n\t\t/* Length of the outer token */\n\t\tdataLen += 1 + gssint_der_length_size(micTokenSize);\n\t}\n\t/*\n\t * Add size of DER encoded:\n\t * NegTokenTarg [ SEQUENCE ] of\n\t *    NegResult[0] ENUMERATED {\n\t *\taccept_completed(0),\n\t *\taccept_incomplete(1),\n\t *\treject(2) }\n\t *    supportedMech [1] MechType OPTIONAL,\n\t *    responseToken [2] OCTET STRING OPTIONAL,\n\t *    mechListMIC   [3] OCTET STRING OPTIONAL\n\t *\n\t * size = data->length + MechListMic + SupportedMech len +\n\t *\tResult Length + ASN.1 overhead\n\t */\n\tNegTokenTargSize = dataLen;\n\tdataLen += 1 + gssint_der_length_size(NegTokenTargSize);\n\n\t/*\n\t * NegotiationToken [ CHOICE ]{\n\t *    negTokenInit  [0]\t NegTokenInit,\n\t *    negTokenTarg  [1]\t NegTokenTarg }\n\t */\n\tNegTokenSize = dataLen;\n\tdataLen += 1 + gssint_der_length_size(NegTokenSize);\n\n\ttlen = dataLen;\n\tt = (unsigned char *) gssalloc_malloc(tlen);\n\n\tif (t == NULL) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto errout;\n\t}\n\n\tptr = t;\n\n\t/*\n\t * Indicate that we are sending CHOICE 1\n\t * (NegTokenTarg)\n\t */\n\t*ptr++ = CONTEXT | 0x01;\n\tif (gssint_put_der_length(NegTokenSize, &ptr, dataLen) < 0) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto errout;\n\t}\n\t*ptr++ = SEQUENCE;\n\tif (gssint_put_der_length(NegTokenTargSize, &ptr,\n\t\t\t\t  tlen - (int)(ptr-t)) < 0) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto errout;\n\t}\n\n\t/*\n\t * First field of the NegTokenTarg SEQUENCE\n\t * is the ENUMERATED NegResult.\n\t */\n\t*ptr++ = CONTEXT;\n\tif (gssint_put_der_length(3, &ptr,\n\t\t\t\t  tlen - (int)(ptr-t)) < 0) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto errout;\n\t}\n\tif (put_negResult(&ptr, status, tlen - (int)(ptr - t)) < 0) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto errout;\n\t}\n\tif (sendtoken == INIT_TOKEN_SEND) {\n\t\t/*\n\t\t * Next, is the Supported MechType\n\t\t */\n\t\t*ptr++ = CONTEXT | 0x01;\n\t\tif (gssint_put_der_length(mech_wanted->length + 2,\n\t\t\t\t\t  &ptr,\n\t\t\t\t\t  tlen - (int)(ptr - t)) < 0) {\n\t\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\t\tgoto errout;\n\t\t}\n\t\tif (put_mech_oid(&ptr, mech_wanted,\n\t\t\t\t tlen - (int)(ptr - t)) < 0) {\n\t\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\tif (data != NULL && data->length > 0) {\n\t\t*ptr++ = CONTEXT | 0x02;\n\t\tif (gssint_put_der_length(rspTokenSize, &ptr,\n\t\t\t\t\t  tlen - (int)(ptr - t)) < 0) {\n\t\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\t\tgoto errout;\n\t\t}\n\t\tif (put_input_token(&ptr, data,\n\t\t\t\t    tlen - (int)(ptr - t)) < 0) {\n\t\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\tif (mechListMIC != NULL) {\n\t\t*ptr++ = CONTEXT | 0x03;\n\t\tif (gssint_put_der_length(micTokenSize, &ptr,\n\t\t\t\t\t  tlen - (int)(ptr - t)) < 0) {\n\t\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\t\tgoto errout;\n\t\t}\n\t\tif (put_input_token(&ptr, mechListMIC,\n\t\t\t\t    tlen - (int)(ptr - t)) < 0) {\n\t\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\tret = GSS_S_COMPLETE;\nerrout:\n\tif (ret != GSS_S_COMPLETE) {\n\t\tif (t)\n\t\t\tfree(t);\n\t} else {\n\t\toutbuf->length = ptr - t;\n\t\toutbuf->value = (void *) t;\n\t}\n\n\treturn (ret);\n}\n\n/* determine size of token */\nstatic int\ng_token_size(gss_OID_const mech, unsigned int body_size)\n{\n\tint hdrsize;\n\n\t/*\n\t * Initialize the header size to the\n\t * MECH_OID byte + the bytes needed to indicate the\n\t * length of the OID + the OID itself.\n\t *\n\t * 0x06 [MECHLENFIELD] MECHDATA\n\t */\n\thdrsize = 1 + gssint_der_length_size(mech->length) + mech->length;\n\n\t/*\n\t * Now add the bytes needed for the initial header\n\t * token bytes:\n\t * 0x60 + [DER_LEN] + HDRSIZE\n\t */\n\thdrsize += 1 + gssint_der_length_size(body_size + hdrsize);\n\n\treturn (hdrsize + body_size);\n}\n\n/*\n * generate token header.\n *\n * Use DER Definite Length method per RFC2478\n * Use of indefinite length encoding will not be compatible\n * with Microsoft or others that actually follow the spec.\n */\nstatic int\ng_make_token_header(gss_OID_const mech,\n\t\t    unsigned int body_size,\n\t\t    unsigned char **buf,\n\t\t    unsigned int totallen)\n{\n\tint ret = 0;\n\tunsigned int hdrsize;\n\tunsigned char *p = *buf;\n\n\thdrsize = 1 + gssint_der_length_size(mech->length) + mech->length;\n\n\t*(*buf)++ = HEADER_ID;\n\tif ((ret = gssint_put_der_length(hdrsize + body_size, buf, totallen)))\n\t\treturn (ret);\n\n\t*(*buf)++ = MECH_OID;\n\tif ((ret = gssint_put_der_length(mech->length, buf,\n\t\t\t    totallen - (int)(p - *buf))))\n\t\treturn (ret);\n\tTWRITE_STR(*buf, mech->elements, mech->length);\n\treturn (0);\n}\n\n/*\n * NOTE: This checks that the length returned by\n * gssint_get_der_length() is not greater than the number of octets\n * remaining, even though gssint_get_der_length() already checks, in\n * theory.\n */\nstatic int\ng_get_tag_and_length(unsigned char **buf, int tag,\n\t\t     unsigned int buflen, unsigned int *outlen)\n{\n\tunsigned char *ptr = *buf;\n\tint ret = -1; /* pessimists, assume failure ! */\n\tunsigned int encoded_len;\n\tint tmplen = 0;\n\n\t*outlen = 0;\n\tif (buflen > 1 && *ptr == tag) {\n\t\tptr++;\n\t\ttmplen = gssint_get_der_length(&ptr, buflen - 1,\n\t\t\t\t\t\t&encoded_len);\n\t\tif (tmplen < 0) {\n\t\t\tret = -1;\n\t\t} else if ((unsigned int)tmplen > buflen - (ptr - *buf)) {\n\t\t\tret = -1;\n\t\t} else\n\t\t\tret = 0;\n\t}\n\t*outlen = tmplen;\n\t*buf = ptr;\n\treturn (ret);\n}\n\nstatic int\ng_verify_neg_token_init(unsigned char **buf_in, unsigned int cur_size)\n{\n\tunsigned char *buf = *buf_in;\n\tunsigned char *endptr = buf + cur_size;\n\tint seqsize;\n\tint ret = 0;\n\tunsigned int bytes;\n\n\t/*\n\t * Verify this is a NegotiationToken type token\n\t * - check for a0(context specific identifier)\n\t * - get length and verify that enoughd ata exists\n\t */\n\tif (g_get_tag_and_length(&buf, CONTEXT, cur_size, &bytes) < 0)\n\t\treturn (G_BAD_TOK_HEADER);\n\n\tcur_size = bytes; /* should indicate bytes remaining */\n\n\t/*\n\t * Verify the next piece, it should identify this as\n\t * a strucure of type NegTokenInit.\n\t */\n\tif (*buf++ == SEQUENCE) {\n\t\tif ((seqsize = gssint_get_der_length(&buf, cur_size, &bytes)) < 0)\n\t\t\treturn (G_BAD_TOK_HEADER);\n\t\t/*\n\t\t * Make sure we have the entire buffer as described\n\t\t */\n\t\tif (seqsize > endptr - buf)\n\t\t\treturn (G_BAD_TOK_HEADER);\n\t} else {\n\t\treturn (G_BAD_TOK_HEADER);\n\t}\n\n\tcur_size = seqsize; /* should indicate bytes remaining */\n\n\t/*\n\t * Verify that the first blob is a sequence of mechTypes\n\t */\n\tif (*buf++ == CONTEXT) {\n\t\tif ((seqsize = gssint_get_der_length(&buf, cur_size, &bytes)) < 0)\n\t\t\treturn (G_BAD_TOK_HEADER);\n\t\t/*\n\t\t * Make sure we have the entire buffer as described\n\t\t */\n\t\tif (seqsize > endptr - buf)\n\t\t\treturn (G_BAD_TOK_HEADER);\n\t} else {\n\t\treturn (G_BAD_TOK_HEADER);\n\t}\n\n\t/*\n\t * At this point, *buf should be at the beginning of the\n\t * DER encoded list of mech types that are to be negotiated.\n\t */\n\t*buf_in = buf;\n\n\treturn (ret);\n\n}\n\n/* verify token header. */\nstatic int\ng_verify_token_header(gss_OID_const mech,\n\t\t    unsigned int *body_size,\n\t\t    unsigned char **buf_in,\n\t\t    int tok_type,\n\t\t    unsigned int toksize)\n{\n\tunsigned char *buf = *buf_in;\n\tint seqsize;\n\tgss_OID_desc toid;\n\tint ret = 0;\n\tunsigned int bytes;\n\n\tif (toksize-- < 1)\n\t\treturn (G_BAD_TOK_HEADER);\n\n\tif (*buf++ != HEADER_ID)\n\t\treturn (G_BAD_TOK_HEADER);\n\n\tif ((seqsize = gssint_get_der_length(&buf, toksize, &bytes)) < 0)\n\t\treturn (G_BAD_TOK_HEADER);\n\n\tif ((seqsize + bytes) != toksize)\n\t\treturn (G_BAD_TOK_HEADER);\n\n\tif (toksize-- < 1)\n\t\treturn (G_BAD_TOK_HEADER);\n\n\n\tif (*buf++ != MECH_OID)\n\t\treturn (G_BAD_TOK_HEADER);\n\n\tif (toksize-- < 1)\n\t\treturn (G_BAD_TOK_HEADER);\n\n\ttoid.length = *buf++;\n\n\tif (toksize < toid.length)\n\t\treturn (G_BAD_TOK_HEADER);\n\telse\n\t\ttoksize -= toid.length;\n\n\ttoid.elements = buf;\n\tbuf += toid.length;\n\n\tif (!g_OID_equal(&toid, mech))\n\t\tret = G_WRONG_MECH;\n\n\t/*\n\t * G_WRONG_MECH is not returned immediately because it's more important\n\t * to return G_BAD_TOK_HEADER if the token header is in fact bad\n\t */\n\tif (toksize < 2)\n\t\treturn (G_BAD_TOK_HEADER);\n\telse\n\t\ttoksize -= 2;\n\n\tif (!ret) {\n\t\t*buf_in = buf;\n\t\t*body_size = toksize;\n\t}\n\n\treturn (ret);\n}\n\n/*\n * Return non-zero if the oid is one of the kerberos mech oids,\n * otherwise return zero.\n *\n * N.B. There are 3 oids that represent the kerberos mech:\n * RFC-specified GSS_MECH_KRB5_OID,\n * Old pre-RFC   GSS_MECH_KRB5_OLD_OID,\n * Incorrect MS  GSS_MECH_KRB5_WRONG_OID\n */\n\nstatic int\nis_kerb_mech(gss_OID oid)\n{\n\tint answer = 0;\n\tOM_uint32 minor;\n\textern const gss_OID_set_desc * const gss_mech_set_krb5_both;\n\n\t(void) gss_test_oid_set_member(&minor,\n\t\toid, (gss_OID_set)gss_mech_set_krb5_both, &answer);\n\n\treturn (answer);\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2006,2008 by the Massachusetts Institute of Technology.\n * All rights reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n/*\n * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.\n * Use is subject to license terms.\n *\n * A module that implements the spnego security mechanism.\n * It is used to negotiate the security mechanism between\n * peers using the GSS-API.  SPNEGO is specified in RFC 4178.\n *\n */\n/*\n * Copyright (c) 2006-2008, Novell, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *   * The copyright holder's name is not used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n/* #pragma ident\t\"@(#)spnego_mech.c\t1.7\t04/09/28 SMI\" */\n\n#include\t<k5-int.h>\n#include\t<krb5.h>\n#include\t<mglueP.h>\n#include\t\"gssapiP_spnego.h\"\n#include\t<gssapi_err_generic.h>\n\n\n#undef g_token_size\n#undef g_verify_token_header\n#undef g_make_token_header\n\n#define HARD_ERROR(v) ((v) != GSS_S_COMPLETE && (v) != GSS_S_CONTINUE_NEEDED)\ntypedef const gss_OID_desc *gss_OID_const;\n\n/* der routines defined in libgss */\nextern unsigned int gssint_der_length_size(unsigned int);\nextern int gssint_get_der_length(unsigned char **, unsigned int,\n\t\t\t\t unsigned int*);\nextern int gssint_put_der_length(unsigned int, unsigned char **, unsigned int);\n\n\n/* private routines for spnego_mechanism */\nstatic spnego_token_t make_spnego_token(const char *);\nstatic gss_buffer_desc make_err_msg(const char *);\nstatic int g_token_size(gss_OID_const, unsigned int);\nstatic int g_make_token_header(gss_OID_const, unsigned int,\n\t\t\t       unsigned char **, unsigned int);\nstatic int g_verify_token_header(gss_OID_const, unsigned int *,\n\t\t\t\t unsigned char **,\n\t\t\t\t int, unsigned int);\nstatic int g_verify_neg_token_init(unsigned char **, unsigned int);\nstatic gss_OID get_mech_oid(OM_uint32 *, unsigned char **, size_t);\nstatic gss_buffer_t get_input_token(unsigned char **, unsigned int);\nstatic gss_OID_set get_mech_set(OM_uint32 *, unsigned char **, unsigned int);\nstatic OM_uint32 get_req_flags(unsigned char **, OM_uint32, OM_uint32 *);\nstatic OM_uint32 get_available_mechs(OM_uint32 *, gss_name_t, gss_cred_usage_t,\n\t\t\t\t     gss_const_key_value_set_t,\n\t\t\t\t     gss_cred_id_t *, gss_OID_set *);\nstatic OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,\n\t\t\t\t      gss_cred_usage_t, gss_OID_set *);\nstatic void release_spnego_ctx(spnego_gss_ctx_id_t *);\nstatic void check_spnego_options(spnego_gss_ctx_id_t);\nstatic spnego_gss_ctx_id_t create_spnego_ctx(void);\nstatic int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);\nstatic int put_input_token(unsigned char **, gss_buffer_t, unsigned int);\nstatic int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);\nstatic int put_negResult(unsigned char **, OM_uint32, unsigned int);\n\nstatic OM_uint32\nprocess_mic(OM_uint32 *, gss_buffer_t, spnego_gss_ctx_id_t,\n\t    gss_buffer_t *, OM_uint32 *, send_token_flag *);\nstatic OM_uint32\nhandle_mic(OM_uint32 *, gss_buffer_t, int, spnego_gss_ctx_id_t,\n\t   gss_buffer_t *, OM_uint32 *, send_token_flag *);\n\nstatic OM_uint32\ninit_ctx_new(OM_uint32 *, spnego_gss_cred_id_t, gss_ctx_id_t *,\n\t     send_token_flag *);\nstatic OM_uint32\ninit_ctx_nego(OM_uint32 *, spnego_gss_ctx_id_t, OM_uint32, gss_OID,\n\t      gss_buffer_t *, gss_buffer_t *,\n\t      OM_uint32 *, send_token_flag *);\nstatic OM_uint32\ninit_ctx_cont(OM_uint32 *, gss_ctx_id_t *, gss_buffer_t,\n\t      gss_buffer_t *, gss_buffer_t *,\n\t      OM_uint32 *, send_token_flag *);\nstatic OM_uint32\ninit_ctx_reselect(OM_uint32 *, spnego_gss_ctx_id_t, OM_uint32,\n\t\t  gss_OID, gss_buffer_t *, gss_buffer_t *,\n\t\t  OM_uint32 *, send_token_flag *);\nstatic OM_uint32\ninit_ctx_call_init(OM_uint32 *, spnego_gss_ctx_id_t, spnego_gss_cred_id_t,\n\t\t   gss_name_t, OM_uint32, OM_uint32, gss_buffer_t,\n\t\t   gss_OID *, gss_buffer_t, OM_uint32 *, OM_uint32 *,\n\t\t   OM_uint32 *, send_token_flag *);\n\nstatic OM_uint32\nacc_ctx_new(OM_uint32 *, gss_buffer_t, gss_ctx_id_t *,\n\t    spnego_gss_cred_id_t, gss_buffer_t *,\n\t    gss_buffer_t *, OM_uint32 *, send_token_flag *);\nstatic OM_uint32\nacc_ctx_cont(OM_uint32 *, gss_buffer_t, gss_ctx_id_t *,\n\t     gss_buffer_t *, gss_buffer_t *,\n\t     OM_uint32 *, send_token_flag *);\nstatic OM_uint32\nacc_ctx_vfy_oid(OM_uint32 *, spnego_gss_ctx_id_t, gss_OID,\n\t\tOM_uint32 *, send_token_flag *);\nstatic OM_uint32\nacc_ctx_call_acc(OM_uint32 *, spnego_gss_ctx_id_t, spnego_gss_cred_id_t,\n\t\t gss_buffer_t, gss_OID *, gss_buffer_t,\n\t\t OM_uint32 *, OM_uint32 *, gss_cred_id_t *,\n\t\t OM_uint32 *, send_token_flag *);\n\nstatic gss_OID\nnegotiate_mech(gss_OID_set, gss_OID_set, OM_uint32 *);\nstatic int\ng_get_tag_and_length(unsigned char **, int, unsigned int, unsigned int *);\n\nstatic int\nmake_spnego_tokenInit_msg(spnego_gss_ctx_id_t,\n\t\t\tint,\n\t\t\tgss_buffer_t,\n\t\t\tOM_uint32, gss_buffer_t, send_token_flag,\n\t\t\tgss_buffer_t);\nstatic int\nmake_spnego_tokenTarg_msg(OM_uint32, gss_OID, gss_buffer_t,\n\t\t\tgss_buffer_t, send_token_flag,\n\t\t\tgss_buffer_t);\n\nstatic OM_uint32\nget_negTokenInit(OM_uint32 *, gss_buffer_t, gss_buffer_t,\n\t\t gss_OID_set *, OM_uint32 *, gss_buffer_t *,\n\t\t gss_buffer_t *);\nstatic OM_uint32\nget_negTokenResp(OM_uint32 *, unsigned char *, unsigned int,\n\t\t OM_uint32 *, gss_OID *, gss_buffer_t *, gss_buffer_t *);\n\nstatic int\nis_kerb_mech(gss_OID oid);\n\n/* SPNEGO oid structure */\nstatic const gss_OID_desc spnego_oids[] = {\n\t{SPNEGO_OID_LENGTH, SPNEGO_OID},\n};\n\nconst gss_OID_desc * const gss_mech_spnego = spnego_oids+0;\nstatic const gss_OID_set_desc spnego_oidsets[] = {\n\t{1, (gss_OID) spnego_oids+0},\n};\nconst gss_OID_set_desc * const gss_mech_set_spnego = spnego_oidsets+0;\n\nstatic int make_NegHints(OM_uint32 *, spnego_gss_cred_id_t, gss_buffer_t *);\nstatic int put_neg_hints(unsigned char **, gss_buffer_t, unsigned int);\nstatic OM_uint32\nacc_ctx_hints(OM_uint32 *, gss_ctx_id_t *, spnego_gss_cred_id_t,\n\t      gss_buffer_t *, OM_uint32 *, send_token_flag *);\n\n/*\n * The Mech OID for SPNEGO:\n * { iso(1) org(3) dod(6) internet(1) security(5)\n *  mechanism(5) spnego(2) }\n */\nstatic struct gss_config spnego_mechanism =\n{\n\t{SPNEGO_OID_LENGTH, SPNEGO_OID},\n\tNULL,\n\tspnego_gss_acquire_cred,\n\tspnego_gss_release_cred,\n\tspnego_gss_init_sec_context,\n#ifndef LEAN_CLIENT\n\tspnego_gss_accept_sec_context,\n#else\n\tNULL,\n#endif  /* LEAN_CLIENT */\n\tNULL,\t\t\t\t/* gss_process_context_token */\n\tspnego_gss_delete_sec_context,\t/* gss_delete_sec_context */\n\tspnego_gss_context_time,\t/* gss_context_time */\n\tspnego_gss_get_mic,\t\t/* gss_get_mic */\n\tspnego_gss_verify_mic,\t\t/* gss_verify_mic */\n\tspnego_gss_wrap,\t\t/* gss_wrap */\n\tspnego_gss_unwrap,\t\t/* gss_unwrap */\n\tspnego_gss_display_status,\n\tNULL,\t\t\t\t/* gss_indicate_mechs */\n\tspnego_gss_compare_name,\n\tspnego_gss_display_name,\n\tspnego_gss_import_name,\n\tspnego_gss_release_name,\n\tspnego_gss_inquire_cred,\t/* gss_inquire_cred */\n\tNULL,\t\t\t\t/* gss_add_cred */\n#ifndef LEAN_CLIENT\n\tspnego_gss_export_sec_context,\t\t/* gss_export_sec_context */\n\tspnego_gss_import_sec_context,\t\t/* gss_import_sec_context */\n#else\n\tNULL,\t\t\t\t/* gss_export_sec_context */\n\tNULL,\t\t\t\t/* gss_import_sec_context */\n#endif /* LEAN_CLIENT */\n\tNULL, \t\t\t\t/* gss_inquire_cred_by_mech */\n\tspnego_gss_inquire_names_for_mech,\n\tspnego_gss_inquire_context,\t/* gss_inquire_context */\n\tNULL,\t\t\t\t/* gss_internal_release_oid */\n\tspnego_gss_wrap_size_limit,\t/* gss_wrap_size_limit */\n\tNULL,\t\t\t\t/* gssd_pname_to_uid */\n\tNULL,\t\t\t\t/* gss_userok */\n\tNULL,\t\t\t\t/* gss_export_name */\n\tspnego_gss_duplicate_name,\t/* gss_duplicate_name */\n\tNULL,\t\t\t\t/* gss_store_cred */\n \tspnego_gss_inquire_sec_context_by_oid, /* gss_inquire_sec_context_by_oid */\n \tspnego_gss_inquire_cred_by_oid,\t/* gss_inquire_cred_by_oid */\n \tspnego_gss_set_sec_context_option, /* gss_set_sec_context_option */\n\tspnego_gss_set_cred_option,\t/* gssspi_set_cred_option */\n \tNULL,\t\t\t\t/* gssspi_mech_invoke */\n\tspnego_gss_wrap_aead,\n\tspnego_gss_unwrap_aead,\n\tspnego_gss_wrap_iov,\n\tspnego_gss_unwrap_iov,\n\tspnego_gss_wrap_iov_length,\n\tspnego_gss_complete_auth_token,\n\tspnego_gss_acquire_cred_impersonate_name,\n\tNULL,\t\t\t\t/* gss_add_cred_impersonate_name */\n\tspnego_gss_display_name_ext,\n\tspnego_gss_inquire_name,\n\tspnego_gss_get_name_attribute,\n\tspnego_gss_set_name_attribute,\n\tspnego_gss_delete_name_attribute,\n\tspnego_gss_export_name_composite,\n\tspnego_gss_map_name_to_any,\n\tspnego_gss_release_any_name_mapping,\n\tspnego_gss_pseudo_random,\n\tspnego_gss_set_neg_mechs,\n\tspnego_gss_inquire_saslname_for_mech,\n\tspnego_gss_inquire_mech_for_saslname,\n\tspnego_gss_inquire_attrs_for_mech,\n\tspnego_gss_acquire_cred_from,\n\tNULL,\t\t\t\t/* gss_store_cred_into */\n\tspnego_gss_acquire_cred_with_password,\n\tspnego_gss_export_cred,\n\tspnego_gss_import_cred,\n\tNULL,\t\t\t\t/* gssspi_import_sec_context_by_mech */\n\tNULL,\t\t\t\t/* gssspi_import_name_by_mech */\n\tNULL,\t\t\t\t/* gssspi_import_cred_by_mech */\n\tspnego_gss_get_mic_iov,\n\tspnego_gss_verify_mic_iov,\n\tspnego_gss_get_mic_iov_length\n};\n\n#ifdef _GSS_STATIC_LINK\n#include \"mglueP.h\"\n\nstatic int gss_spnegomechglue_init(void)\n{\n\tstruct gss_mech_config mech_spnego;\n\n\tmemset(&mech_spnego, 0, sizeof(mech_spnego));\n\tmech_spnego.mech = &spnego_mechanism;\n\tmech_spnego.mechNameStr = \"spnego\";\n\tmech_spnego.mech_type = GSS_C_NO_OID;\n\n\treturn gssint_register_mechinfo(&mech_spnego);\n}\n#else\ngss_mechanism KRB5_CALLCONV\ngss_mech_initialize(void)\n{\n\treturn (&spnego_mechanism);\n}\n\nMAKE_INIT_FUNCTION(gss_krb5int_lib_init);\nMAKE_FINI_FUNCTION(gss_krb5int_lib_fini);\nint gss_krb5int_lib_init(void);\n#endif /* _GSS_STATIC_LINK */\n\nint gss_spnegoint_lib_init(void)\n{\n\tint err;\n\n\terr = k5_key_register(K5_KEY_GSS_SPNEGO_STATUS, NULL);\n\tif (err)\n\t\treturn err;\n\n#ifdef _GSS_STATIC_LINK\n\treturn gss_spnegomechglue_init();\n#else\n\treturn 0;\n#endif\n}\n\nvoid gss_spnegoint_lib_fini(void)\n{\n}\n\n/*ARGSUSED*/\nOM_uint32 KRB5_CALLCONV\nspnego_gss_acquire_cred(OM_uint32 *minor_status,\n\t\t\tgss_name_t desired_name,\n\t\t\tOM_uint32 time_req,\n\t\t\tgss_OID_set desired_mechs,\n\t\t\tgss_cred_usage_t cred_usage,\n\t\t\tgss_cred_id_t *output_cred_handle,\n\t\t\tgss_OID_set *actual_mechs,\n\t\t\tOM_uint32 *time_rec)\n{\n    return spnego_gss_acquire_cred_from(minor_status, desired_name, time_req,\n\t\t\t\t\tdesired_mechs, cred_usage, NULL,\n\t\t\t\t\toutput_cred_handle, actual_mechs,\n\t\t\t\t\ttime_rec);\n}\n\n/*ARGSUSED*/\nOM_uint32 KRB5_CALLCONV\nspnego_gss_acquire_cred_from(OM_uint32 *minor_status,\n\t\t\t     const gss_name_t desired_name,\n\t\t\t     OM_uint32 time_req,\n\t\t\t     const gss_OID_set desired_mechs,\n\t\t\t     gss_cred_usage_t cred_usage,\n\t\t\t     gss_const_key_value_set_t cred_store,\n\t\t\t     gss_cred_id_t *output_cred_handle,\n\t\t\t     gss_OID_set *actual_mechs,\n\t\t\t     OM_uint32 *time_rec)\n{\n\tOM_uint32 status, tmpmin;\n\tgss_OID_set amechs;\n\tgss_cred_id_t mcred = NULL;\n\tspnego_gss_cred_id_t spcred = NULL;\n\tdsyslog(\"Entering spnego_gss_acquire_cred\\n\");\n\n\tif (actual_mechs)\n\t\t*actual_mechs = NULL;\n\n\tif (time_rec)\n\t\t*time_rec = 0;\n\n\t/* We will obtain a mechglue credential and wrap it in a\n\t * spnego_gss_cred_id_rec structure.  Allocate the wrapper. */\n\tspcred = malloc(sizeof(spnego_gss_cred_id_rec));\n\tif (spcred == NULL) {\n\t\t*minor_status = ENOMEM;\n\t\treturn (GSS_S_FAILURE);\n\t}\n\tspcred->neg_mechs = GSS_C_NULL_OID_SET;\n\n\t/*\n\t * Always use get_available_mechs to collect a list of\n\t * mechs for which creds are available.\n\t */\n\tstatus = get_available_mechs(minor_status, desired_name,\n\t\t\t\t     cred_usage, cred_store, &mcred,\n\t\t\t\t     &amechs);\n\n\tif (actual_mechs && amechs != GSS_C_NULL_OID_SET) {\n\t\t(void) gssint_copy_oid_set(&tmpmin, amechs, actual_mechs);\n\t}\n\t(void) gss_release_oid_set(&tmpmin, &amechs);\n\n\tif (status == GSS_S_COMPLETE) {\n\t\tspcred->mcred = mcred;\n\t\t*output_cred_handle = (gss_cred_id_t)spcred;\n\t} else {\n\t\tfree(spcred);\n\t\t*output_cred_handle = GSS_C_NO_CREDENTIAL;\n\t}\n\n\tdsyslog(\"Leaving spnego_gss_acquire_cred\\n\");\n\treturn (status);\n}\n\n/*ARGSUSED*/\nOM_uint32 KRB5_CALLCONV\nspnego_gss_release_cred(OM_uint32 *minor_status,\n\t\t\tgss_cred_id_t *cred_handle)\n{\n\tspnego_gss_cred_id_t spcred = NULL;\n\n\tdsyslog(\"Entering spnego_gss_release_cred\\n\");\n\n\tif (minor_status == NULL || cred_handle == NULL)\n\t\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n\t*minor_status = 0;\n\n\tif (*cred_handle == GSS_C_NO_CREDENTIAL)\n\t\treturn (GSS_S_COMPLETE);\n\n\tspcred = (spnego_gss_cred_id_t)*cred_handle;\n\t*cred_handle = GSS_C_NO_CREDENTIAL;\n\tgss_release_oid_set(minor_status, &spcred->neg_mechs);\n\tgss_release_cred(minor_status, &spcred->mcred);\n\tfree(spcred);\n\n\tdsyslog(\"Leaving spnego_gss_release_cred\\n\");\n\treturn (GSS_S_COMPLETE);\n}\n\nstatic void\ncheck_spnego_options(spnego_gss_ctx_id_t spnego_ctx)\n{\n\tspnego_ctx->optionStr = gssint_get_modOptions(\n\t\t(const gss_OID)&spnego_oids[0]);\n}\n\nstatic spnego_gss_ctx_id_t\ncreate_spnego_ctx(void)\n{\n\tspnego_gss_ctx_id_t spnego_ctx = NULL;\n\tspnego_ctx = (spnego_gss_ctx_id_t)\n\t\tmalloc(sizeof (spnego_gss_ctx_id_rec));\n\n\tif (spnego_ctx == NULL) {\n\t\treturn (NULL);\n\t}\n\n\tspnego_ctx->magic_num = SPNEGO_MAGIC_ID;\n\tspnego_ctx->ctx_handle = GSS_C_NO_CONTEXT;\n\tspnego_ctx->mech_set = NULL;\n\tspnego_ctx->internal_mech = NULL;\n\tspnego_ctx->optionStr = NULL;\n\tspnego_ctx->DER_mechTypes.length = 0;\n\tspnego_ctx->DER_mechTypes.value = NULL;\n\tspnego_ctx->default_cred = GSS_C_NO_CREDENTIAL;\n\tspnego_ctx->mic_reqd = 0;\n\tspnego_ctx->mic_sent = 0;\n\tspnego_ctx->mic_rcvd = 0;\n\tspnego_ctx->mech_complete = 0;\n\tspnego_ctx->nego_done = 0;\n\tspnego_ctx->internal_name = GSS_C_NO_NAME;\n\tspnego_ctx->actual_mech = GSS_C_NO_OID;\n\n\tcheck_spnego_options(spnego_ctx);\n\n\treturn (spnego_ctx);\n}\n\n/* iso(1) org(3) dod(6) internet(1) private(4) enterprises(1) samba(7165)\n * gssntlmssp(655) controls(1) spnego_req_mechlistMIC(2) */\nstatic const gss_OID_desc spnego_req_mechlistMIC_oid =\n\t{ 11, \"\\x2B\\x06\\x01\\x04\\x01\\xB7\\x7D\\x85\\x0F\\x01\\x02\" };\n\n/*\n * Return nonzero if the mechanism has reason to believe that a mechlistMIC\n * exchange will be required.  Microsoft servers erroneously require SPNEGO\n * mechlistMIC if they see an internal MIC within an NTLMSSP Authenticate\n * message, even if NTLMSSP was the preferred mechanism.\n */\nstatic int\nmech_requires_mechlistMIC(spnego_gss_ctx_id_t sc)\n{\n\tOM_uint32 major, minor;\n\tgss_ctx_id_t ctx = sc->ctx_handle;\n\tgss_OID oid = (gss_OID)&spnego_req_mechlistMIC_oid;\n\tgss_buffer_set_t bufs;\n\tint result;\n\n\tmajor = gss_inquire_sec_context_by_oid(&minor, ctx, oid, &bufs);\n\tif (major != GSS_S_COMPLETE)\n\t\treturn 0;\n\n\t/* Report true if the mech returns a single buffer containing a single\n\t * byte with value 1. */\n\tresult = (bufs != NULL && bufs->count == 1 &&\n\t\t  bufs->elements[0].length == 1 &&\n\t\t  memcmp(bufs->elements[0].value, \"\\1\", 1) == 0);\n\t(void) gss_release_buffer_set(&minor, &bufs);\n\treturn result;\n}\n\n/*\n * Both initiator and acceptor call here to verify and/or create mechListMIC,\n * and to consistency-check the MIC state.  handle_mic is invoked only if the\n * negotiated mech has completed and supports MICs.\n */\nstatic OM_uint32\nhandle_mic(OM_uint32 *minor_status, gss_buffer_t mic_in,\n\t   int send_mechtok, spnego_gss_ctx_id_t sc,\n\t   gss_buffer_t *mic_out,\n\t   OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\n\tret = GSS_S_FAILURE;\n\t*mic_out = GSS_C_NO_BUFFER;\n\tif (mic_in != GSS_C_NO_BUFFER) {\n\t\tif (sc->mic_rcvd) {\n\t\t\t/* Reject MIC if we've already received a MIC. */\n\t\t\t*negState = REJECT;\n\t\t\t*tokflag = ERROR_TOKEN_SEND;\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t\t}\n\t} else if (sc->mic_reqd && !send_mechtok) {\n\t\t/*\n\t\t * If the peer sends the final mechanism token, it\n\t\t * must send the MIC with that token if the\n\t\t * negotiation requires MICs.\n\t\t */\n\t\t*negState = REJECT;\n\t\t*tokflag = ERROR_TOKEN_SEND;\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tret = process_mic(minor_status, mic_in, sc, mic_out,\n\t\t\t  negState, tokflag);\n\tif (ret != GSS_S_COMPLETE) {\n\t\treturn ret;\n\t}\n\tif (sc->mic_reqd) {\n\t\tassert(sc->mic_sent || sc->mic_rcvd);\n\t}\n\tif (sc->mic_sent && sc->mic_rcvd) {\n\t\tret = GSS_S_COMPLETE;\n\t\t*negState = ACCEPT_COMPLETE;\n\t\tif (*mic_out == GSS_C_NO_BUFFER) {\n\t\t\t/*\n\t\t\t * We sent a MIC on the previous pass; we\n\t\t\t * shouldn't be sending a mechanism token.\n\t\t\t */\n\t\t\tassert(!send_mechtok);\n\t\t\t*tokflag = NO_TOKEN_SEND;\n\t\t} else {\n\t\t\t*tokflag = CONT_TOKEN_SEND;\n\t\t}\n\t} else if (sc->mic_reqd) {\n\t\t*negState = ACCEPT_INCOMPLETE;\n\t\tret = GSS_S_CONTINUE_NEEDED;\n\t} else if (*negState == ACCEPT_COMPLETE) {\n\t\tret = GSS_S_COMPLETE;\n\t} else {\n\t\tret = GSS_S_CONTINUE_NEEDED;\n\t}\n\treturn ret;\n}\n\n/*\n * Perform the actual verification and/or generation of mechListMIC.\n */\nstatic OM_uint32\nprocess_mic(OM_uint32 *minor_status, gss_buffer_t mic_in,\n\t    spnego_gss_ctx_id_t sc, gss_buffer_t *mic_out,\n\t    OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 ret, tmpmin;\n\tgss_qop_t qop_state;\n\tgss_buffer_desc tmpmic = GSS_C_EMPTY_BUFFER;\n\n\tret = GSS_S_FAILURE;\n\tif (mic_in != GSS_C_NO_BUFFER) {\n\t\tret = gss_verify_mic(minor_status, sc->ctx_handle,\n\t\t\t\t     &sc->DER_mechTypes,\n\t\t\t\t     mic_in, &qop_state);\n\t\tif (ret != GSS_S_COMPLETE) {\n\t\t\t*negState = REJECT;\n\t\t\t*tokflag = ERROR_TOKEN_SEND;\n\t\t\treturn ret;\n\t\t}\n\t\t/* If we got a MIC, we must send a MIC. */\n\t\tsc->mic_reqd = 1;\n\t\tsc->mic_rcvd = 1;\n\t}\n\tif (sc->mic_reqd && !sc->mic_sent) {\n\t\tret = gss_get_mic(minor_status, sc->ctx_handle,\n\t\t\t\t  GSS_C_QOP_DEFAULT,\n\t\t\t\t  &sc->DER_mechTypes,\n\t\t\t\t  &tmpmic);\n\t\tif (ret != GSS_S_COMPLETE) {\n\t\t\tgss_release_buffer(&tmpmin, &tmpmic);\n\t\t\t*tokflag = NO_TOKEN_SEND;\n\t\t\treturn ret;\n\t\t}\n\t\t*mic_out = malloc(sizeof(gss_buffer_desc));\n\t\tif (*mic_out == GSS_C_NO_BUFFER) {\n\t\t\tgss_release_buffer(&tmpmin, &tmpmic);\n\t\t\t*tokflag = NO_TOKEN_SEND;\n\t\t\treturn GSS_S_FAILURE;\n\t\t}\n\t\t**mic_out = tmpmic;\n\t\tsc->mic_sent = 1;\n\t}\n\treturn GSS_S_COMPLETE;\n}\n\n/*\n * Initial call to spnego_gss_init_sec_context().\n */\nstatic OM_uint32\ninit_ctx_new(OM_uint32 *minor_status,\n\t     spnego_gss_cred_id_t spcred,\n\t     gss_ctx_id_t *ctx,\n\t     send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = NULL;\n\n\tsc = create_spnego_ctx();\n\tif (sc == NULL)\n\t\treturn GSS_S_FAILURE;\n\n\t/* determine negotiation mech set */\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_INITIATE,\n\t\t\t\t   &sc->mech_set);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\t/* Set an initial internal mech to make the first context token. */\n\tsc->internal_mech = &sc->mech_set->elements[0];\n\n\tif (put_mech_set(sc->mech_set, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\t/*\n\t * The actual context is not yet determined, set the output\n\t * context handle to refer to the spnego context itself.\n\t */\n\tsc->ctx_handle = GSS_C_NO_CONTEXT;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\t*tokflag = INIT_TOKEN_SEND;\n\tret = GSS_S_CONTINUE_NEEDED;\n\ncleanup:\n\trelease_spnego_ctx(&sc);\n\treturn ret;\n}\n\n/*\n * Called by second and later calls to spnego_gss_init_sec_context()\n * to decode reply and update state.\n */\nstatic OM_uint32\ninit_ctx_cont(OM_uint32 *minor_status, gss_ctx_id_t *ctx, gss_buffer_t buf,\n\t      gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t      OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 ret, tmpmin, acc_negState;\n\tunsigned char *ptr;\n\tspnego_gss_ctx_id_t sc;\n\tgss_OID supportedMech = GSS_C_NO_OID;\n\n\tsc = (spnego_gss_ctx_id_t)*ctx;\n\t*negState = REJECT;\n\t*tokflag = ERROR_TOKEN_SEND;\n\n\tptr = buf->value;\n\tret = get_negTokenResp(minor_status, ptr, buf->length,\n\t\t\t       &acc_negState, &supportedMech,\n\t\t\t       responseToken, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tif (acc_negState == REJECT) {\n\t\t*minor_status = ERR_SPNEGO_NEGOTIATION_FAILED;\n\t\tmap_errcode(minor_status);\n\t\t*tokflag = NO_TOKEN_SEND;\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\t/*\n\t * nego_done is false for the first call to init_ctx_cont()\n\t */\n\tif (!sc->nego_done) {\n\t\tret = init_ctx_nego(minor_status, sc,\n\t\t\t\t    acc_negState,\n\t\t\t\t    supportedMech, responseToken,\n\t\t\t\t    mechListMIC,\n\t\t\t\t    negState, tokflag);\n\t} else if ((!sc->mech_complete && *responseToken == GSS_C_NO_BUFFER) ||\n\t\t   (sc->mech_complete && *responseToken != GSS_C_NO_BUFFER)) {\n\t\t/* Missing or spurious token from acceptor. */\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t} else if (!sc->mech_complete ||\n\t\t   (sc->mic_reqd &&\n\t\t    (sc->ctx_flags & GSS_C_INTEG_FLAG))) {\n\t\t/* Not obviously done; we may decide we're done later in\n\t\t * init_ctx_call_init or handle_mic. */\n\t\t*negState = ACCEPT_INCOMPLETE;\n\t\t*tokflag = CONT_TOKEN_SEND;\n\t\tret = GSS_S_CONTINUE_NEEDED;\n\t} else {\n\t\t/* mech finished on last pass and no MIC required, so done. */\n\t\t*negState = ACCEPT_COMPLETE;\n\t\t*tokflag = NO_TOKEN_SEND;\n\t\tret = GSS_S_COMPLETE;\n\t}\ncleanup:\n\tif (supportedMech != GSS_C_NO_OID)\n\t\tgeneric_gss_release_oid(&tmpmin, &supportedMech);\n\treturn ret;\n}\n\n/*\n * Consistency checking and mechanism negotiation handling for second\n * call of spnego_gss_init_sec_context().  Call init_ctx_reselect() to\n * update internal state if acceptor has counter-proposed.\n */\nstatic OM_uint32\ninit_ctx_nego(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n\t      OM_uint32 acc_negState, gss_OID supportedMech,\n\t      gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t      OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\n\t*negState = REJECT;\n\t*tokflag = ERROR_TOKEN_SEND;\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\t/*\n\t * Both supportedMech and negState must be present in first\n\t * acceptor token.\n\t */\n\tif (supportedMech == GSS_C_NO_OID) {\n\t\t*minor_status = ERR_SPNEGO_NO_MECH_FROM_ACCEPTOR;\n\t\tmap_errcode(minor_status);\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tif (acc_negState == ACCEPT_DEFECTIVE_TOKEN) {\n\t\t*minor_status = ERR_SPNEGO_NEGOTIATION_FAILED;\n\t\tmap_errcode(minor_status);\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\n\t/*\n\t * If the mechanism we sent is not the mechanism returned from\n\t * the server, we need to handle the server's counter\n\t * proposal.  There is a bug in SAMBA servers that always send\n\t * the old Kerberos mech OID, even though we sent the new one.\n\t * So we will treat all the Kerberos mech OIDS as the same.\n         */\n\tif (!(is_kerb_mech(supportedMech) &&\n\t      is_kerb_mech(sc->internal_mech)) &&\n\t    !g_OID_equal(supportedMech, sc->internal_mech)) {\n\t\tret = init_ctx_reselect(minor_status, sc,\n\t\t\t\t\tacc_negState, supportedMech,\n\t\t\t\t\tresponseToken, mechListMIC,\n\t\t\t\t\tnegState, tokflag);\n\n\t} else if (*responseToken == GSS_C_NO_BUFFER) {\n\t\tif (sc->mech_complete) {\n\t\t\t/*\n\t\t\t * Mech completed on first call to its\n\t\t\t * init_sec_context().  Acceptor sends no mech\n\t\t\t * token.\n\t\t\t */\n\t\t\t*negState = ACCEPT_COMPLETE;\n\t\t\t*tokflag = NO_TOKEN_SEND;\n\t\t\tret = GSS_S_COMPLETE;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Reject missing mech token when optimistic\n\t\t\t * mech selected.\n\t\t\t */\n\t\t\t*minor_status = ERR_SPNEGO_NO_TOKEN_FROM_ACCEPTOR;\n\t\t\tmap_errcode(minor_status);\n\t\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\t}\n\t} else if ((*responseToken)->length == 0 && sc->mech_complete) {\n\t\t/* Handle old IIS servers returning empty token instead of\n\t\t * null tokens in the non-mutual auth case. */\n\t\t*negState = ACCEPT_COMPLETE;\n\t\t*tokflag = NO_TOKEN_SEND;\n\t\tret = GSS_S_COMPLETE;\n\t} else if (sc->mech_complete) {\n\t\t/* Reject spurious mech token. */\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t} else {\n\t\t*negState = ACCEPT_INCOMPLETE;\n\t\t*tokflag = CONT_TOKEN_SEND;\n\t\tret = GSS_S_CONTINUE_NEEDED;\n\t}\n\tsc->nego_done = 1;\n\treturn ret;\n}\n\n/*\n * Handle acceptor's counter-proposal of an alternative mechanism.\n */\nstatic OM_uint32\ninit_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n\t\t  OM_uint32 acc_negState, gss_OID supportedMech,\n\t\t  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t\t  OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 tmpmin;\n\tsize_t i;\n\n\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n\t\t\t       GSS_C_NO_BUFFER);\n\n\t/* Find supportedMech in sc->mech_set. */\n\tfor (i = 0; i < sc->mech_set->count; i++) {\n\t\tif (g_OID_equal(supportedMech, &sc->mech_set->elements[i]))\n\t\t\tbreak;\n\t}\n\tif (i == sc->mech_set->count)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->internal_mech = &sc->mech_set->elements[i];\n\n\t/*\n\t * Windows 2003 and earlier don't correctly send a\n\t * negState of request-mic when counter-proposing a\n\t * mechanism.  They probably don't handle mechListMICs\n\t * properly either.\n\t */\n\tif (acc_negState != REQUEST_MIC)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\tsc->mech_complete = 0;\n\tsc->mic_reqd = 1;\n\t*negState = REQUEST_MIC;\n\t*tokflag = CONT_TOKEN_SEND;\n\treturn GSS_S_CONTINUE_NEEDED;\n}\n\n/*\n * Wrap call to mechanism gss_init_sec_context() and update state\n * accordingly.\n */\nstatic OM_uint32\ninit_ctx_call_init(OM_uint32 *minor_status,\n\t\t   spnego_gss_ctx_id_t sc,\n\t\t   spnego_gss_cred_id_t spcred,\n\t\t   gss_name_t target_name,\n\t\t   OM_uint32 req_flags,\n\t\t   OM_uint32 time_req,\n\t\t   gss_buffer_t mechtok_in,\n\t\t   gss_OID *actual_mech,\n\t\t   gss_buffer_t mechtok_out,\n\t\t   OM_uint32 *ret_flags,\n\t\t   OM_uint32 *time_rec,\n\t\t   OM_uint32 *negState,\n\t\t   send_token_flag *send_token)\n{\n\tOM_uint32 ret, tmpret, tmpmin;\n\tgss_cred_id_t mcred;\n\n\tmcred = (spcred == NULL) ? GSS_C_NO_CREDENTIAL : spcred->mcred;\n\tret = gss_init_sec_context(minor_status,\n\t\t\t\t   mcred,\n\t\t\t\t   &sc->ctx_handle,\n\t\t\t\t   target_name,\n\t\t\t\t   sc->internal_mech,\n\t\t\t\t   (req_flags | GSS_C_INTEG_FLAG),\n\t\t\t\t   time_req,\n\t\t\t\t   GSS_C_NO_CHANNEL_BINDINGS,\n\t\t\t\t   mechtok_in,\n\t\t\t\t   &sc->actual_mech,\n\t\t\t\t   mechtok_out,\n\t\t\t\t   &sc->ctx_flags,\n\t\t\t\t   time_rec);\n\tif (ret == GSS_S_COMPLETE) {\n\t\tsc->mech_complete = 1;\n\t\tif (ret_flags != NULL)\n\t\t\t*ret_flags = sc->ctx_flags;\n\t\t/*\n\t\t * Microsoft SPNEGO implementations expect an even number of\n\t\t * token exchanges.  So if we're sending a final token, ask for\n\t\t * a zero-length token back from the server.  Also ask for a\n\t\t * token back if this is the first token or if a MIC exchange\n\t\t * is required.\n\t\t */\n\t\tif (*send_token == CONT_TOKEN_SEND &&\n\t\t    mechtok_out->length == 0 &&\n\t\t    (!sc->mic_reqd ||\n\t\t     !(sc->ctx_flags & GSS_C_INTEG_FLAG))) {\n\t\t\t/* The exchange is complete. */\n\t\t\t*negState = ACCEPT_COMPLETE;\n\t\t\tret = GSS_S_COMPLETE;\n\t\t\t*send_token = NO_TOKEN_SEND;\n\t\t} else {\n\t\t\t/* Ask for one more hop. */\n\t\t\t*negState = ACCEPT_INCOMPLETE;\n\t\t\tret = GSS_S_CONTINUE_NEEDED;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tif (ret == GSS_S_CONTINUE_NEEDED)\n\t\treturn ret;\n\n\tif (*send_token != INIT_TOKEN_SEND) {\n\t\t*send_token = ERROR_TOKEN_SEND;\n\t\t*negState = REJECT;\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Since this is the first token, we can fall back to later mechanisms\n\t * in the list.  Since the mechanism list is expected to be short, we\n\t * can do this with recursion.  If all mechanisms produce errors, the\n\t * caller should get the error from the first mech in the list.\n\t */\n\tgssalloc_free(sc->mech_set->elements->elements);\n\tmemmove(sc->mech_set->elements, sc->mech_set->elements + 1,\n\t\t--sc->mech_set->count * sizeof(*sc->mech_set->elements));\n\tif (sc->mech_set->count == 0)\n\t\tgoto fail;\n\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n\tif (put_mech_set(sc->mech_set, &sc->DER_mechTypes) < 0)\n\t\tgoto fail;\n\ttmpret = init_ctx_call_init(&tmpmin, sc, spcred, target_name,\n\t\t\t\t    req_flags, time_req, mechtok_in,\n\t\t\t\t    actual_mech, mechtok_out, ret_flags,\n\t\t\t\t    time_rec, negState, send_token);\n\tif (HARD_ERROR(tmpret))\n\t\tgoto fail;\n\t*minor_status = tmpmin;\n\treturn tmpret;\n\nfail:\n\t/* Don't output token on error from first call. */\n\t*send_token = NO_TOKEN_SEND;\n\t*negState = REJECT;\n\treturn ret;\n}\n\n/*ARGSUSED*/\nOM_uint32 KRB5_CALLCONV\nspnego_gss_init_sec_context(\n\t\t\tOM_uint32 *minor_status,\n\t\t\tgss_cred_id_t claimant_cred_handle,\n\t\t\tgss_ctx_id_t *context_handle,\n\t\t\tgss_name_t target_name,\n\t\t\tgss_OID mech_type,\n\t\t\tOM_uint32 req_flags,\n\t\t\tOM_uint32 time_req,\n\t\t\tgss_channel_bindings_t input_chan_bindings,\n\t\t\tgss_buffer_t input_token,\n\t\t\tgss_OID *actual_mech,\n\t\t\tgss_buffer_t output_token,\n\t\t\tOM_uint32 *ret_flags,\n\t\t\tOM_uint32 *time_rec)\n{\n\tsend_token_flag send_token = NO_TOKEN_SEND;\n\tOM_uint32 tmpmin, ret, negState;\n\tgss_buffer_t mechtok_in, mechListMIC_in, mechListMIC_out;\n\tgss_buffer_desc mechtok_out = GSS_C_EMPTY_BUFFER;\n\tspnego_gss_cred_id_t spcred = NULL;\n\tspnego_gss_ctx_id_t spnego_ctx = NULL;\n\n\tdsyslog(\"Entering init_sec_context\\n\");\n\n\tmechtok_in = mechListMIC_out = mechListMIC_in = GSS_C_NO_BUFFER;\n\tnegState = REJECT;\n\n\t/*\n\t * This function works in three steps:\n\t *\n\t *   1. Perform mechanism negotiation.\n\t *   2. Invoke the negotiated or optimistic mech's gss_init_sec_context\n\t *      function and examine the results.\n\t *   3. Process or generate MICs if necessary.\n\t *\n\t * The three steps share responsibility for determining when the\n\t * exchange is complete.  If the selected mech completed in a previous\n\t * call and no MIC exchange is expected, then step 1 will decide.  If\n\t * the selected mech completes in this call and no MIC exchange is\n\t * expected, then step 2 will decide.  If a MIC exchange is expected,\n\t * then step 3 will decide.  If an error occurs in any step, the\n\t * exchange will be aborted, possibly with an error token.\n\t *\n\t * negState determines the state of the negotiation, and is\n\t * communicated to the acceptor if a continuing token is sent.\n\t * send_token is used to indicate what type of token, if any, should be\n\t * generated.\n\t */\n\n\t/* Validate arguments. */\n\tif (minor_status != NULL)\n\t\t*minor_status = 0;\n\tif (output_token != GSS_C_NO_BUFFER) {\n\t\toutput_token->length = 0;\n\t\toutput_token->value = NULL;\n\t}\n\tif (minor_status == NULL ||\n\t    output_token == GSS_C_NO_BUFFER ||\n\t    context_handle == NULL)\n\t\treturn GSS_S_CALL_INACCESSIBLE_WRITE;\n\n\tif (actual_mech != NULL)\n\t\t*actual_mech = GSS_C_NO_OID;\n\n\t/* Step 1: perform mechanism negotiation. */\n\tspcred = (spnego_gss_cred_id_t)claimant_cred_handle;\n\tif (*context_handle == GSS_C_NO_CONTEXT) {\n\t\tret = init_ctx_new(minor_status, spcred,\n\t\t\t\t   context_handle, &send_token);\n\t\tif (ret != GSS_S_CONTINUE_NEEDED) {\n\t\t\tgoto cleanup;\n\t\t}\n\t} else {\n\t\tret = init_ctx_cont(minor_status, context_handle,\n\t\t\t\t    input_token, &mechtok_in,\n\t\t\t\t    &mechListMIC_in, &negState, &send_token);\n\t\tif (HARD_ERROR(ret)) {\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/* Step 2: invoke the selected or optimistic mechanism's\n\t * gss_init_sec_context function, if it didn't complete previously. */\n\tspnego_ctx = (spnego_gss_ctx_id_t)*context_handle;\n\tif (!spnego_ctx->mech_complete) {\n\t\tret = init_ctx_call_init(\n\t\t\tminor_status, spnego_ctx, spcred,\n\t\t\ttarget_name, req_flags,\n\t\t\ttime_req, mechtok_in,\n\t\t\tactual_mech, &mechtok_out,\n\t\t\tret_flags, time_rec,\n\t\t\t&negState, &send_token);\n\n\t\t/* Give the mechanism a chance to force a mechlistMIC. */\n\t\tif (!HARD_ERROR(ret) && mech_requires_mechlistMIC(spnego_ctx))\n\t\t\tspnego_ctx->mic_reqd = 1;\n\t}\n\n\t/* Step 3: process or generate the MIC, if the negotiated mech is\n\t * complete and supports MICs. */\n\tif (!HARD_ERROR(ret) && spnego_ctx->mech_complete &&\n\t    (spnego_ctx->ctx_flags & GSS_C_INTEG_FLAG)) {\n\n\t\tret = handle_mic(minor_status,\n\t\t\t\t mechListMIC_in,\n\t\t\t\t (mechtok_out.length != 0),\n\t\t\t\t spnego_ctx, &mechListMIC_out,\n\t\t\t\t &negState, &send_token);\n\t}\ncleanup:\n\tif (send_token == INIT_TOKEN_SEND) {\n\t\tif (make_spnego_tokenInit_msg(spnego_ctx,\n\t\t\t\t\t      0,\n\t\t\t\t\t      mechListMIC_out,\n\t\t\t\t\t      req_flags,\n\t\t\t\t\t      &mechtok_out, send_token,\n\t\t\t\t\t      output_token) < 0) {\n\t\t\tret = GSS_S_FAILURE;\n\t\t}\n\t} else if (send_token != NO_TOKEN_SEND) {\n\t\tif (make_spnego_tokenTarg_msg(negState, GSS_C_NO_OID,\n\t\t\t\t\t      &mechtok_out, mechListMIC_out,\n\t\t\t\t\t      send_token,\n\t\t\t\t\t      output_token) < 0) {\n\t\t\tret = GSS_S_FAILURE;\n\t\t}\n\t}\n\tgss_release_buffer(&tmpmin, &mechtok_out);\n\tif (ret == GSS_S_COMPLETE) {\n\t\t/*\n\t\t * Now, switch the output context to refer to the\n\t\t * negotiated mechanism's context.\n\t\t */\n\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n\t\tif (actual_mech != NULL)\n\t\t\t*actual_mech = spnego_ctx->actual_mech;\n\t\tif (ret_flags != NULL)\n\t\t\t*ret_flags = spnego_ctx->ctx_flags;\n\t\trelease_spnego_ctx(&spnego_ctx);\n\t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n\t\tif (spnego_ctx != NULL) {\n\t\t\tgss_delete_sec_context(&tmpmin,\n\t\t\t\t\t       &spnego_ctx->ctx_handle,\n\t\t\t\t\t       GSS_C_NO_BUFFER);\n\t\t\trelease_spnego_ctx(&spnego_ctx);\n\t\t}\n\t\t*context_handle = GSS_C_NO_CONTEXT;\n\t}\n\tif (mechtok_in != GSS_C_NO_BUFFER) {\n\t\tgss_release_buffer(&tmpmin, mechtok_in);\n\t\tfree(mechtok_in);\n\t}\n\tif (mechListMIC_in != GSS_C_NO_BUFFER) {\n\t\tgss_release_buffer(&tmpmin, mechListMIC_in);\n\t\tfree(mechListMIC_in);\n\t}\n\tif (mechListMIC_out != GSS_C_NO_BUFFER) {\n\t\tgss_release_buffer(&tmpmin, mechListMIC_out);\n\t\tfree(mechListMIC_out);\n\t}\n\treturn ret;\n} /* init_sec_context */\n\n/* We don't want to import KRB5 headers here */\nstatic const gss_OID_desc gss_mech_krb5_oid =\n\t{ 9, \"\\052\\206\\110\\206\\367\\022\\001\\002\\002\" };\nstatic const gss_OID_desc gss_mech_krb5_wrong_oid =\n\t{ 9, \"\\052\\206\\110\\202\\367\\022\\001\\002\\002\" };\n\n/*\n * verify that the input token length is not 0. If it is, just return.\n * If the token length is greater than 0, der encode as a sequence\n * and place in buf_out, advancing buf_out.\n */\n\nstatic int\nput_neg_hints(unsigned char **buf_out, gss_buffer_t input_token,\n\t      unsigned int buflen)\n{\n\tint ret;\n\n\t/* if token length is 0, we do not want to send */\n\tif (input_token->length == 0)\n\t\treturn (0);\n\n\tif (input_token->length > buflen)\n\t\treturn (-1);\n\n\t*(*buf_out)++ = SEQUENCE;\n\tif ((ret = gssint_put_der_length(input_token->length, buf_out,\n\t\t\t    input_token->length)))\n\t\treturn (ret);\n\tTWRITE_STR(*buf_out, input_token->value, input_token->length);\n\treturn (0);\n}\n\n/*\n * NegHints ::= SEQUENCE {\n *    hintName       [0]  GeneralString      OPTIONAL,\n *    hintAddress    [1]  OCTET STRING       OPTIONAL\n * }\n */\n\n#define HOST_PREFIX\t\"host@\"\n#define HOST_PREFIX_LEN\t(sizeof(HOST_PREFIX) - 1)\n\nstatic int\nmake_NegHints(OM_uint32 *minor_status,\n\t      spnego_gss_cred_id_t spcred, gss_buffer_t *outbuf)\n{\n\tgss_buffer_desc hintNameBuf;\n\tgss_name_t hintName = GSS_C_NO_NAME;\n\tgss_name_t hintKerberosName;\n\tgss_OID hintNameType;\n\tOM_uint32 major_status;\n\tOM_uint32 minor;\n\tunsigned int tlen = 0;\n\tunsigned int hintNameSize = 0;\n\tunsigned char *ptr;\n\tunsigned char *t;\n\n\t*outbuf = GSS_C_NO_BUFFER;\n\n\tif (spcred != NULL) {\n\t\tmajor_status = gss_inquire_cred(minor_status,\n\t\t\t\t\t\tspcred->mcred,\n\t\t\t\t\t\t&hintName,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tNULL);\n\t\tif (major_status != GSS_S_COMPLETE)\n\t\t\treturn (major_status);\n\t}\n\n\tif (hintName == GSS_C_NO_NAME) {\n\t\tkrb5_error_code code;\n\t\tkrb5int_access kaccess;\n\t\tchar hostname[HOST_PREFIX_LEN + MAXHOSTNAMELEN + 1] = HOST_PREFIX;\n\n\t\tcode = krb5int_accessor(&kaccess, KRB5INT_ACCESS_VERSION);\n\t\tif (code != 0) {\n\t\t\t*minor_status = code;\n\t\t\treturn (GSS_S_FAILURE);\n\t\t}\n\n\t\t/* this breaks mutual authentication but Samba relies on it */\n\t\tcode = (*kaccess.clean_hostname)(NULL, NULL,\n\t\t\t\t\t\t &hostname[HOST_PREFIX_LEN],\n\t\t\t\t\t\t MAXHOSTNAMELEN);\n\t\tif (code != 0) {\n\t\t\t*minor_status = code;\n\t\t\treturn (GSS_S_FAILURE);\n\t\t}\n\n\t\thintNameBuf.value = hostname;\n\t\thintNameBuf.length = strlen(hostname);\n\n\t\tmajor_status = gss_import_name(minor_status,\n\t\t\t\t\t       &hintNameBuf,\n\t\t\t\t\t       GSS_C_NT_HOSTBASED_SERVICE,\n\t\t\t\t\t       &hintName);\n\t\tif (major_status != GSS_S_COMPLETE) {\n\t\t\treturn (major_status);\n\t\t}\n\t}\n\n\thintNameBuf.value = NULL;\n\thintNameBuf.length = 0;\n\n\tmajor_status = gss_canonicalize_name(minor_status,\n\t\t\t\t\t     hintName,\n\t\t\t\t\t     (gss_OID)&gss_mech_krb5_oid,\n\t\t\t\t\t     &hintKerberosName);\n\tif (major_status != GSS_S_COMPLETE) {\n\t\tgss_release_name(&minor, &hintName);\n\t\treturn (major_status);\n\t}\n\tgss_release_name(&minor, &hintName);\n\n\tmajor_status = gss_display_name(minor_status,\n\t\t\t\t\thintKerberosName,\n\t\t\t\t\t&hintNameBuf,\n\t\t\t\t\t&hintNameType);\n\tif (major_status != GSS_S_COMPLETE) {\n\t\tgss_release_name(&minor, &hintName);\n\t\treturn (major_status);\n\t}\n\tgss_release_name(&minor, &hintKerberosName);\n\n\t/*\n\t * Now encode the name hint into a NegHints ASN.1 type\n\t */\n\tmajor_status = GSS_S_FAILURE;\n\n\t/* Length of DER encoded GeneralString */\n\ttlen = 1 + gssint_der_length_size(hintNameBuf.length) +\n\t\thintNameBuf.length;\n\thintNameSize = tlen;\n\n\t/* Length of DER encoded hintName */\n\ttlen += 1 + gssint_der_length_size(hintNameSize);\n\n\tt = gssalloc_malloc(tlen);\n\tif (t == NULL) {\n\t\t*minor_status = ENOMEM;\n\t\tgoto errout;\n\t}\n\n\tptr = t;\n\n\t*ptr++ = CONTEXT | 0x00; /* hintName identifier */\n\tif (gssint_put_der_length(hintNameSize,\n\t\t\t\t  &ptr, tlen - (int)(ptr-t)))\n\t\tgoto errout;\n\n\t*ptr++ = GENERAL_STRING;\n\tif (gssint_put_der_length(hintNameBuf.length,\n\t\t\t\t  &ptr, tlen - (int)(ptr-t)))\n\t\tgoto errout;\n\n\tmemcpy(ptr, hintNameBuf.value, hintNameBuf.length);\n\tptr += hintNameBuf.length;\n\n\t*outbuf = (gss_buffer_t)malloc(sizeof(gss_buffer_desc));\n\tif (*outbuf == NULL) {\n\t\t*minor_status = ENOMEM;\n\t\tgoto errout;\n\t}\n\t(*outbuf)->value = (void *)t;\n\t(*outbuf)->length = ptr - t;\n\n\tt = NULL; /* don't free */\n\n\t*minor_status = 0;\n\tmajor_status = GSS_S_COMPLETE;\n\nerrout:\n\tif (t != NULL) {\n\t\tfree(t);\n\t}\n\n\tgss_release_buffer(&minor, &hintNameBuf);\n\n\treturn (major_status);\n}\n\n/*\n * Support the Microsoft NegHints extension to SPNEGO for compatibility with\n * some versions of Samba.  See:\n *   http://msdn.microsoft.com/en-us/library/cc247039(PROT.10).aspx\n */\nstatic OM_uint32\nacc_ctx_hints(OM_uint32 *minor_status,\n\t      gss_ctx_id_t *ctx,\n\t      spnego_gss_cred_id_t spcred,\n\t      gss_buffer_t *mechListMIC,\n\t      OM_uint32 *negState,\n\t      send_token_flag *return_token)\n{\n\tOM_uint32 tmpmin, ret;\n\tgss_OID_set supported_mechSet;\n\tspnego_gss_ctx_id_t sc = NULL;\n\n\t*mechListMIC = GSS_C_NO_BUFFER;\n\tsupported_mechSet = GSS_C_NO_OID_SET;\n\t*return_token = NO_TOKEN_SEND;\n\t*negState = REJECT;\n\t*minor_status = 0;\n\n\t/* A hint request must be the first token received. */\n\tif (*ctx != GSS_C_NO_CONTEXT)\n\t    return GSS_S_DEFECTIVE_TOKEN;\n\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_ACCEPT,\n\t\t\t\t   &supported_mechSet);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tret = make_NegHints(minor_status, spcred, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tsc = create_spnego_ctx();\n\tif (sc == NULL) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tif (put_mech_set(supported_mechSet, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tsc->internal_mech = GSS_C_NO_OID;\n\n\t*negState = ACCEPT_INCOMPLETE;\n\t*return_token = INIT_TOKEN_SEND;\n\tsc->firstpass = 1;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\tret = GSS_S_COMPLETE;\n\ncleanup:\n\trelease_spnego_ctx(&sc);\n\tgss_release_oid_set(&tmpmin, &supported_mechSet);\n\n\treturn ret;\n}\n\n/*\n * Set negState to REJECT if the token is defective, else\n * ACCEPT_INCOMPLETE or REQUEST_MIC, depending on whether initiator's\n * preferred mechanism is supported.\n */\nstatic OM_uint32\nacc_ctx_new(OM_uint32 *minor_status,\n\t    gss_buffer_t buf,\n\t    gss_ctx_id_t *ctx,\n\t    spnego_gss_cred_id_t spcred,\n\t    gss_buffer_t *mechToken,\n\t    gss_buffer_t *mechListMIC,\n\t    OM_uint32 *negState,\n\t    send_token_flag *return_token)\n{\n\tOM_uint32 tmpmin, ret, req_flags;\n\tgss_OID_set supported_mechSet, mechTypes;\n\tgss_buffer_desc der_mechTypes;\n\tgss_OID mech_wanted;\n\tspnego_gss_ctx_id_t sc = NULL;\n\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\tder_mechTypes.length = 0;\n\tder_mechTypes.value = NULL;\n\t*mechToken = *mechListMIC = GSS_C_NO_BUFFER;\n\tsupported_mechSet = mechTypes = GSS_C_NO_OID_SET;\n\t*return_token = ERROR_TOKEN_SEND;\n\t*negState = REJECT;\n\t*minor_status = 0;\n\n\tret = get_negTokenInit(minor_status, buf, &der_mechTypes,\n\t\t\t       &mechTypes, &req_flags,\n\t\t\t       mechToken, mechListMIC);\n\tif (ret != GSS_S_COMPLETE) {\n\t\tgoto cleanup;\n\t}\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_ACCEPT,\n\t\t\t\t   &supported_mechSet);\n\tif (ret != GSS_S_COMPLETE) {\n\t\t*return_token = NO_TOKEN_SEND;\n\t\tgoto cleanup;\n\t}\n\t/*\n\t * Select the best match between the list of mechs\n\t * that the initiator requested and the list that\n\t * the acceptor will support.\n\t */\n\tmech_wanted = negotiate_mech(supported_mechSet, mechTypes, negState);\n\tif (*negState == REJECT) {\n\t\tret = GSS_S_BAD_MECH;\n\t\tgoto cleanup;\n\t}\n\tsc = (spnego_gss_ctx_id_t)*ctx;\n\tif (sc != NULL) {\n\t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n\t\tassert(mech_wanted != GSS_C_NO_OID);\n\t} else\n\t\tsc = create_spnego_ctx();\n\tif (sc == NULL) {\n\t\tret = GSS_S_FAILURE;\n\t\t*return_token = NO_TOKEN_SEND;\n\t\tgoto cleanup;\n\t}\n\tsc->mech_set = mechTypes;\n\tmechTypes = GSS_C_NO_OID_SET;\n\tsc->internal_mech = mech_wanted;\n\tsc->DER_mechTypes = der_mechTypes;\n\tder_mechTypes.length = 0;\n\tder_mechTypes.value = NULL;\n\n\tif (*negState == REQUEST_MIC)\n\t\tsc->mic_reqd = 1;\n\n\t*return_token = INIT_TOKEN_SEND;\n\tsc->firstpass = 1;\n\t*ctx = (gss_ctx_id_t)sc;\n\tret = GSS_S_COMPLETE;\ncleanup:\n\tgss_release_oid_set(&tmpmin, &mechTypes);\n\tgss_release_oid_set(&tmpmin, &supported_mechSet);\n\tif (der_mechTypes.length != 0)\n\t\tgss_release_buffer(&tmpmin, &der_mechTypes);\n\n\treturn ret;\n}\n\nstatic OM_uint32\nacc_ctx_cont(OM_uint32 *minstat,\n\t     gss_buffer_t buf,\n\t     gss_ctx_id_t *ctx,\n\t     gss_buffer_t *responseToken,\n\t     gss_buffer_t *mechListMIC,\n\t     OM_uint32 *negState,\n\t     send_token_flag *return_token)\n{\n\tOM_uint32 ret, tmpmin;\n\tgss_OID supportedMech;\n\tspnego_gss_ctx_id_t sc;\n\tunsigned int len;\n\tunsigned char *ptr, *bufstart;\n\n\tsc = (spnego_gss_ctx_id_t)*ctx;\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\t*negState = REJECT;\n\t*minstat = 0;\n\tsupportedMech = GSS_C_NO_OID;\n\t*return_token = ERROR_TOKEN_SEND;\n\t*responseToken = *mechListMIC = GSS_C_NO_BUFFER;\n\n\tptr = bufstart = buf->value;\n#define REMAIN (buf->length - (ptr - bufstart))\n\tif (REMAIN > INT_MAX)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\t/*\n\t * Attempt to work with old Sun SPNEGO.\n\t */\n\tif (*ptr == HEADER_ID) {\n\t\tret = g_verify_token_header(gss_mech_spnego,\n\t\t\t\t\t    &len, &ptr, 0, REMAIN);\n\t\tif (ret) {\n\t\t\t*minstat = ret;\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t\t}\n\t}\n\tif (*ptr != (CONTEXT | 0x01)) {\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tret = get_negTokenResp(minstat, ptr, REMAIN,\n\t\t\t       negState, &supportedMech,\n\t\t\t       responseToken, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tif (*responseToken == GSS_C_NO_BUFFER &&\n\t    *mechListMIC == GSS_C_NO_BUFFER) {\n\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tsc->firstpass = 0;\n\t*negState = ACCEPT_INCOMPLETE;\n\t*return_token = CONT_TOKEN_SEND;\ncleanup:\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tgeneric_gss_release_oid(&tmpmin, &supportedMech);\n\t}\n\treturn ret;\n#undef REMAIN\n}\n\n/*\n * Verify that mech OID is either exactly the same as the negotiated\n * mech OID, or is a mech OID supported by the negotiated mech.  MS\n * implementations can list a most preferred mech using an incorrect\n * krb5 OID while emitting a krb5 initiator mech token having the\n * correct krb5 mech OID.\n */\nstatic OM_uint32\nacc_ctx_vfy_oid(OM_uint32 *minor_status,\n\t\tspnego_gss_ctx_id_t sc, gss_OID mechoid,\n\t\tOM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 ret, tmpmin;\n\tgss_mechanism mech = NULL;\n\tgss_OID_set mech_set = GSS_C_NO_OID_SET;\n\tint present = 0;\n\n\tif (g_OID_equal(sc->internal_mech, mechoid))\n\t\treturn GSS_S_COMPLETE;\n\n\tmech = gssint_get_mechanism(sc->internal_mech);\n\tif (mech == NULL || mech->gss_indicate_mechs == NULL) {\n\t\t*minor_status = ERR_SPNEGO_NEGOTIATION_FAILED;\n\t\tmap_errcode(minor_status);\n\t\t*negState = REJECT;\n\t\t*tokflag = ERROR_TOKEN_SEND;\n\t\treturn GSS_S_BAD_MECH;\n\t}\n\tret = mech->gss_indicate_mechs(minor_status, &mech_set);\n\tif (ret != GSS_S_COMPLETE) {\n\t\t*tokflag = NO_TOKEN_SEND;\n\t\tmap_error(minor_status, mech);\n\t\tgoto cleanup;\n\t}\n\tret = gss_test_oid_set_member(minor_status, mechoid,\n\t\t\t\t      mech_set, &present);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tif (!present) {\n\t\t*minor_status = ERR_SPNEGO_NEGOTIATION_FAILED;\n\t\tmap_errcode(minor_status);\n\t\t*negState = REJECT;\n\t\t*tokflag = ERROR_TOKEN_SEND;\n\t\tret = GSS_S_BAD_MECH;\n\t}\ncleanup:\n\tgss_release_oid_set(&tmpmin, &mech_set);\n\treturn ret;\n}\n#ifndef LEAN_CLIENT\n/*\n * Wrap call to gss_accept_sec_context() and update state\n * accordingly.\n */\nstatic OM_uint32\nacc_ctx_call_acc(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n\t\t spnego_gss_cred_id_t spcred, gss_buffer_t mechtok_in,\n\t\t gss_OID *mech_type, gss_buffer_t mechtok_out,\n\t\t OM_uint32 *ret_flags, OM_uint32 *time_rec,\n\t\t gss_cred_id_t *delegated_cred_handle,\n\t\t OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\tgss_OID_desc mechoid;\n\tgss_cred_id_t mcred;\n\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n\t\t/*\n\t\t * mechoid is an alias; don't free it.\n\t\t */\n\t\tret = gssint_get_mech_type(&mechoid, mechtok_in);\n\t\tif (ret != GSS_S_COMPLETE) {\n\t\t\t*tokflag = NO_TOKEN_SEND;\n\t\t\treturn ret;\n\t\t}\n\t\tret = acc_ctx_vfy_oid(minor_status, sc, &mechoid,\n\t\t\t\t      negState, tokflag);\n\t\tif (ret != GSS_S_COMPLETE)\n\t\t\treturn ret;\n\t}\n\n\tmcred = (spcred == NULL) ? GSS_C_NO_CREDENTIAL : spcred->mcred;\n\tret = gss_accept_sec_context(minor_status,\n\t\t\t\t     &sc->ctx_handle,\n\t\t\t\t     mcred,\n\t\t\t\t     mechtok_in,\n\t\t\t\t     GSS_C_NO_CHANNEL_BINDINGS,\n\t\t\t\t     &sc->internal_name,\n\t\t\t\t     mech_type,\n\t\t\t\t     mechtok_out,\n\t\t\t\t     &sc->ctx_flags,\n\t\t\t\t     time_rec,\n\t\t\t\t     delegated_cred_handle);\n\tif (ret == GSS_S_COMPLETE) {\n#ifdef MS_BUG_TEST\n\t\t/*\n\t\t * Force MIC to be not required even if we previously\n\t\t * requested a MIC.\n\t\t */\n\t\tchar *envstr = getenv(\"MS_FORCE_NO_MIC\");\n\n\t\tif (envstr != NULL && strcmp(envstr, \"1\") == 0 &&\n\t\t    !(sc->ctx_flags & GSS_C_MUTUAL_FLAG) &&\n\t\t    sc->mic_reqd) {\n\n\t\t\tsc->mic_reqd = 0;\n\t\t}\n#endif\n\t\tsc->mech_complete = 1;\n\t\tif (ret_flags != NULL)\n\t\t\t*ret_flags = sc->ctx_flags;\n\n\t\tif (!sc->mic_reqd ||\n\t\t    !(sc->ctx_flags & GSS_C_INTEG_FLAG)) {\n\t\t\t/* No MIC exchange required, so we're done. */\n\t\t\t*negState = ACCEPT_COMPLETE;\n\t\t\tret = GSS_S_COMPLETE;\n\t\t} else {\n\t\t\t/* handle_mic will decide if we're done. */\n\t\t\tret = GSS_S_CONTINUE_NEEDED;\n\t\t}\n\t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n\t\t*negState = REJECT;\n\t\t*tokflag = ERROR_TOKEN_SEND;\n\t}\n\treturn ret;\n}\n\n/*ARGSUSED*/\nOM_uint32 KRB5_CALLCONV\nspnego_gss_accept_sec_context(\n\t\t\t    OM_uint32 *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_cred_id_t verifier_cred_handle,\n\t\t\t    gss_buffer_t input_token,\n\t\t\t    gss_channel_bindings_t input_chan_bindings,\n\t\t\t    gss_name_t *src_name,\n\t\t\t    gss_OID *mech_type,\n\t\t\t    gss_buffer_t output_token,\n\t\t\t    OM_uint32 *ret_flags,\n\t\t\t    OM_uint32 *time_rec,\n\t\t\t    gss_cred_id_t *delegated_cred_handle)\n{\n\tOM_uint32 ret, tmpmin, negState;\n\tsend_token_flag return_token;\n\tgss_buffer_t mechtok_in, mic_in, mic_out;\n\tgss_buffer_desc mechtok_out = GSS_C_EMPTY_BUFFER;\n\tspnego_gss_ctx_id_t sc = NULL;\n\tspnego_gss_cred_id_t spcred = NULL;\n\tint sendTokenInit = 0, tmpret;\n\n\tmechtok_in = mic_in = mic_out = GSS_C_NO_BUFFER;\n\n\t/*\n\t * This function works in three steps:\n\t *\n\t *   1. Perform mechanism negotiation.\n\t *   2. Invoke the negotiated mech's gss_accept_sec_context function\n\t *      and examine the results.\n\t *   3. Process or generate MICs if necessary.\n\t *\n\t * Step one determines whether the negotiation requires a MIC exchange,\n\t * while steps two and three share responsibility for determining when\n\t * the exchange is complete.  If the selected mech completes in this\n\t * call and no MIC exchange is expected, then step 2 will decide.  If a\n\t * MIC exchange is expected, then step 3 will decide.  If an error\n\t * occurs in any step, the exchange will be aborted, possibly with an\n\t * error token.\n\t *\n\t * negState determines the state of the negotiation, and is\n\t * communicated to the acceptor if a continuing token is sent.\n\t * return_token is used to indicate what type of token, if any, should\n\t * be generated.\n\t */\n\n\t/* Validate arguments. */\n\tif (minor_status != NULL)\n\t\t*minor_status = 0;\n\tif (output_token != GSS_C_NO_BUFFER) {\n\t\toutput_token->length = 0;\n\t\toutput_token->value = NULL;\n\t}\n\n\tif (minor_status == NULL ||\n\t    output_token == GSS_C_NO_BUFFER ||\n\t    context_handle == NULL)\n\t\treturn GSS_S_CALL_INACCESSIBLE_WRITE;\n\n\tif (input_token == GSS_C_NO_BUFFER)\n\t\treturn GSS_S_CALL_INACCESSIBLE_READ;\n\n\t/* Step 1: Perform mechanism negotiation. */\n\tsc = (spnego_gss_ctx_id_t)*context_handle;\n\tspcred = (spnego_gss_cred_id_t)verifier_cred_handle;\n\tif (sc == NULL || sc->internal_mech == GSS_C_NO_OID) {\n\t\t/* Process an initial token or request for NegHints. */\n\t\tif (src_name != NULL)\n\t\t\t*src_name = GSS_C_NO_NAME;\n\t\tif (mech_type != NULL)\n\t\t\t*mech_type = GSS_C_NO_OID;\n\t\tif (time_rec != NULL)\n\t\t\t*time_rec = 0;\n\t\tif (ret_flags != NULL)\n\t\t\t*ret_flags = 0;\n\t\tif (delegated_cred_handle != NULL)\n\t\t\t*delegated_cred_handle = GSS_C_NO_CREDENTIAL;\n\t\tif (input_token->length == 0) {\n\t\t\tret = acc_ctx_hints(minor_status,\n\t\t\t\t\t    context_handle, spcred,\n\t\t\t\t\t    &mic_out,\n\t\t\t\t\t    &negState,\n\t\t\t\t\t    &return_token);\n\t\t\tif (ret != GSS_S_COMPLETE)\n\t\t\t\tgoto cleanup;\n\t\t\tsendTokenInit = 1;\n\t\t\tret = GSS_S_CONTINUE_NEEDED;\n\t\t} else {\n\t\t\t/* Can set negState to REQUEST_MIC */\n\t\t\tret = acc_ctx_new(minor_status, input_token,\n\t\t\t\t\t  context_handle, spcred,\n\t\t\t\t\t  &mechtok_in, &mic_in,\n\t\t\t\t\t  &negState, &return_token);\n\t\t\tif (ret != GSS_S_COMPLETE)\n\t\t\t\tgoto cleanup;\n\t\t\tret = GSS_S_CONTINUE_NEEDED;\n\t\t}\n\t} else {\n\t\t/* Process a response token.  Can set negState to\n\t\t * ACCEPT_INCOMPLETE. */\n\t\tret = acc_ctx_cont(minor_status, input_token,\n\t\t\t\t   context_handle, &mechtok_in,\n\t\t\t\t   &mic_in, &negState, &return_token);\n\t\tif (ret != GSS_S_COMPLETE)\n\t\t\tgoto cleanup;\n\t\tret = GSS_S_CONTINUE_NEEDED;\n\t}\n\n\t/* Step 2: invoke the negotiated mechanism's gss_accept_sec_context\n\t * function. */\n\tsc = (spnego_gss_ctx_id_t)*context_handle;\n\t/*\n\t * Handle mechtok_in and mic_in only if they are\n\t * present in input_token.  If neither is present, whether\n\t * this is an error depends on whether this is the first\n\t * round-trip.  RET is set to a default value according to\n\t * whether it is the first round-trip.\n\t */\n\tif (negState != REQUEST_MIC && mechtok_in != GSS_C_NO_BUFFER) {\n\t\tret = acc_ctx_call_acc(minor_status, sc, spcred,\n\t\t\t\t       mechtok_in, mech_type, &mechtok_out,\n\t\t\t\t       ret_flags, time_rec,\n\t\t\t\t       delegated_cred_handle,\n\t\t\t\t       &negState, &return_token);\n\t}\n\n\t/* Step 3: process or generate the MIC, if the negotiated mech is\n\t * complete and supports MICs. */\n\tif (!HARD_ERROR(ret) && sc->mech_complete &&\n\t    (sc->ctx_flags & GSS_C_INTEG_FLAG)) {\n\n\t\tret = handle_mic(minor_status, mic_in,\n\t\t\t\t (mechtok_out.length != 0),\n\t\t\t\t sc, &mic_out,\n\t\t\t\t &negState, &return_token);\n\t}\ncleanup:\n\tif (return_token == INIT_TOKEN_SEND && sendTokenInit) {\n\t\tassert(sc != NULL);\n\t\ttmpret = make_spnego_tokenInit_msg(sc, 1, mic_out, 0,\n\t\t\t\t\t\t   GSS_C_NO_BUFFER,\n\t\t\t\t\t\t   return_token, output_token);\n\t\tif (tmpret < 0)\n\t\t\tret = GSS_S_FAILURE;\n\t} else if (return_token != NO_TOKEN_SEND &&\n\t\t   return_token != CHECK_MIC) {\n\t\ttmpret = make_spnego_tokenTarg_msg(negState,\n\t\t\t\t\t\t   sc ? sc->internal_mech :\n\t\t\t\t\t\t   GSS_C_NO_OID,\n\t\t\t\t\t\t   &mechtok_out, mic_out,\n\t\t\t\t\t\t   return_token,\n\t\t\t\t\t\t   output_token);\n\t\tif (tmpret < 0)\n\t\t\tret = GSS_S_FAILURE;\n\t}\n\tif (ret == GSS_S_COMPLETE) {\n\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n\t\tif (sc->internal_name != GSS_C_NO_NAME &&\n\t\t    src_name != NULL) {\n\t\t\t*src_name = sc->internal_name;\n\t\t\tsc->internal_name = GSS_C_NO_NAME;\n\t\t}\n\t\trelease_spnego_ctx(&sc);\n\t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n\t\tif (sc != NULL) {\n\t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n\t\t\t\t\t       GSS_C_NO_BUFFER);\n\t\t\trelease_spnego_ctx(&sc);\n\t\t}\n\t\t*context_handle = GSS_C_NO_CONTEXT;\n\t}\n\tgss_release_buffer(&tmpmin, &mechtok_out);\n\tif (mechtok_in != GSS_C_NO_BUFFER) {\n\t\tgss_release_buffer(&tmpmin, mechtok_in);\n\t\tfree(mechtok_in);\n\t}\n\tif (mic_in != GSS_C_NO_BUFFER) {\n\t\tgss_release_buffer(&tmpmin, mic_in);\n\t\tfree(mic_in);\n\t}\n\tif (mic_out != GSS_C_NO_BUFFER) {\n\t\tgss_release_buffer(&tmpmin, mic_out);\n\t\tfree(mic_out);\n\t}\n\treturn ret;\n}\n#endif /*  LEAN_CLIENT */\n\n/*ARGSUSED*/\nOM_uint32 KRB5_CALLCONV\nspnego_gss_display_status(\n\t\tOM_uint32 *minor_status,\n\t\tOM_uint32 status_value,\n\t\tint status_type,\n\t\tgss_OID mech_type,\n\t\tOM_uint32 *message_context,\n\t\tgss_buffer_t status_string)\n{\n\tOM_uint32 maj = GSS_S_COMPLETE;\n\tint ret;\n\n\tdsyslog(\"Entering display_status\\n\");\n\n\t*message_context = 0;\n\tswitch (status_value) {\n\t    case ERR_SPNEGO_NO_MECHS_AVAILABLE:\n\t\t/* CSTYLED */\n\t\t*status_string = make_err_msg(_(\"SPNEGO cannot find \"\n\t\t\t\t\t\t\"mechanisms to negotiate\"));\n\t\tbreak;\n\t    case ERR_SPNEGO_NO_CREDS_ACQUIRED:\n\t\t/* CSTYLED */\n\t\t*status_string = make_err_msg(_(\"SPNEGO failed to acquire \"\n\t\t\t\t\t\t\"creds\"));\n\t\tbreak;\n\t    case ERR_SPNEGO_NO_MECH_FROM_ACCEPTOR:\n\t\t/* CSTYLED */\n\t\t*status_string = make_err_msg(_(\"SPNEGO acceptor did not \"\n\t\t\t\t\t\t\"select a mechanism\"));\n\t\tbreak;\n\t    case ERR_SPNEGO_NEGOTIATION_FAILED:\n\t\t/* CSTYLED */\n\t\t*status_string = make_err_msg(_(\"SPNEGO failed to negotiate a \"\n\t\t\t\t\t\t\"mechanism\"));\n\t\tbreak;\n\t    case ERR_SPNEGO_NO_TOKEN_FROM_ACCEPTOR:\n\t\t/* CSTYLED */\n\t\t*status_string = make_err_msg(_(\"SPNEGO acceptor did not \"\n\t\t\t\t\t\t\"return a valid token\"));\n\t\tbreak;\n\t    default:\n\t\t/* Not one of our minor codes; might be from a mech.  Call back\n\t\t * to gss_display_status, but first check for recursion. */\n\t\tif (k5_getspecific(K5_KEY_GSS_SPNEGO_STATUS) != NULL) {\n\t\t\t/* Perhaps we returned a com_err code like ENOMEM. */\n\t\t\tconst char *err = error_message(status_value);\n\t\t\t*status_string = make_err_msg(err);\n\t\t\tbreak;\n\t\t}\n\t\t/* Set a non-null pointer value; doesn't matter which one. */\n\t\tret = k5_setspecific(K5_KEY_GSS_SPNEGO_STATUS, &ret);\n\t\tif (ret != 0) {\n\t\t\t*minor_status = ret;\n\t\t\tmaj = GSS_S_FAILURE;\n\t\t\tbreak;\n\t\t}\n\t\tmaj = gss_display_status(minor_status, status_value,\n\t\t\t\t\t status_type, mech_type,\n\t\t\t\t\t message_context, status_string);\n\t\t/* This is unlikely to fail; not much we can do if it does. */\n\t\t(void)k5_setspecific(K5_KEY_GSS_SPNEGO_STATUS, NULL);\n\t\tbreak;\n\t}\n\n\tdsyslog(\"Leaving display_status\\n\");\n\treturn maj;\n}\n\n\n/*ARGSUSED*/\nOM_uint32 KRB5_CALLCONV\nspnego_gss_import_name(\n\t\t    OM_uint32 *minor_status,\n\t\t    gss_buffer_t input_name_buffer,\n\t\t    gss_OID input_name_type,\n\t\t    gss_name_t *output_name)\n{\n\tOM_uint32 status;\n\n\tdsyslog(\"Entering import_name\\n\");\n\n\tstatus = gss_import_name(minor_status, input_name_buffer,\n\t\t\tinput_name_type, output_name);\n\n\tdsyslog(\"Leaving import_name\\n\");\n\treturn (status);\n}\n\n/*ARGSUSED*/\nOM_uint32 KRB5_CALLCONV\nspnego_gss_release_name(\n\t\t\tOM_uint32 *minor_status,\n\t\t\tgss_name_t *input_name)\n{\n\tOM_uint32 status;\n\n\tdsyslog(\"Entering release_name\\n\");\n\n\tstatus = gss_release_name(minor_status, input_name);\n\n\tdsyslog(\"Leaving release_name\\n\");\n\treturn (status);\n}\n\n/*ARGSUSED*/\nOM_uint32 KRB5_CALLCONV\nspnego_gss_duplicate_name(\n\t\t\tOM_uint32 *minor_status,\n\t\t\tconst gss_name_t input_name,\n\t\t\tgss_name_t *output_name)\n{\n\tOM_uint32 status;\n\n\tdsyslog(\"Entering duplicate_name\\n\");\n\n\tstatus = gss_duplicate_name(minor_status, input_name, output_name);\n\n\tdsyslog(\"Leaving duplicate_name\\n\");\n\treturn (status);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_inquire_cred(\n\t\t\tOM_uint32 *minor_status,\n\t\t\tgss_cred_id_t cred_handle,\n\t\t\tgss_name_t *name,\n\t\t\tOM_uint32 *lifetime,\n\t\t\tint *cred_usage,\n\t\t\tgss_OID_set *mechanisms)\n{\n\tOM_uint32 status;\n\tspnego_gss_cred_id_t spcred = NULL;\n\tgss_cred_id_t creds = GSS_C_NO_CREDENTIAL;\n\tOM_uint32 tmp_minor_status;\n\tOM_uint32 initiator_lifetime, acceptor_lifetime;\n\n\tdsyslog(\"Entering inquire_cred\\n\");\n\n\t/*\n\t * To avoid infinite recursion, if GSS_C_NO_CREDENTIAL is\n\t * supplied we call gss_inquire_cred_by_mech() on the\n\t * first non-SPNEGO mechanism.\n\t */\n\tspcred = (spnego_gss_cred_id_t)cred_handle;\n\tif (spcred == NULL) {\n\t\tstatus = get_available_mechs(minor_status,\n\t\t\tGSS_C_NO_NAME,\n\t\t\tGSS_C_BOTH,\n\t\t\tGSS_C_NO_CRED_STORE,\n\t\t\t&creds,\n\t\t\tmechanisms);\n\t\tif (status != GSS_S_COMPLETE) {\n\t\t\tdsyslog(\"Leaving inquire_cred\\n\");\n\t\t\treturn (status);\n\t\t}\n\n\t\tif ((*mechanisms)->count == 0) {\n\t\t\tgss_release_cred(&tmp_minor_status, &creds);\n\t\t\tgss_release_oid_set(&tmp_minor_status, mechanisms);\n\t\t\tdsyslog(\"Leaving inquire_cred\\n\");\n\t\t\treturn (GSS_S_DEFECTIVE_CREDENTIAL);\n\t\t}\n\n\t\tassert((*mechanisms)->elements != NULL);\n\n\t\tstatus = gss_inquire_cred_by_mech(minor_status,\n\t\t\tcreds,\n\t\t\t&(*mechanisms)->elements[0],\n\t\t\tname,\n\t\t\t&initiator_lifetime,\n\t\t\t&acceptor_lifetime,\n\t\t\tcred_usage);\n\t\tif (status != GSS_S_COMPLETE) {\n\t\t\tgss_release_cred(&tmp_minor_status, &creds);\n\t\t\tdsyslog(\"Leaving inquire_cred\\n\");\n\t\t\treturn (status);\n\t\t}\n\n\t\tif (lifetime != NULL)\n\t\t\t*lifetime = (*cred_usage == GSS_C_ACCEPT) ?\n\t\t\t\tacceptor_lifetime : initiator_lifetime;\n\n\t\tgss_release_cred(&tmp_minor_status, &creds);\n\t} else {\n\t\tstatus = gss_inquire_cred(minor_status, spcred->mcred,\n\t\t\t\t\t  name, lifetime,\n\t\t\t\t\t  cred_usage, mechanisms);\n\t}\n\n\tdsyslog(\"Leaving inquire_cred\\n\");\n\n\treturn (status);\n}\n\n/*ARGSUSED*/\nOM_uint32 KRB5_CALLCONV\nspnego_gss_compare_name(\n\t\t\tOM_uint32 *minor_status,\n\t\t\tconst gss_name_t name1,\n\t\t\tconst gss_name_t name2,\n\t\t\tint *name_equal)\n{\n\tOM_uint32 status = GSS_S_COMPLETE;\n\tdsyslog(\"Entering compare_name\\n\");\n\n\tstatus = gss_compare_name(minor_status, name1, name2, name_equal);\n\n\tdsyslog(\"Leaving compare_name\\n\");\n\treturn (status);\n}\n\n/*ARGSUSED*/\n/*ARGSUSED*/\nOM_uint32 KRB5_CALLCONV\nspnego_gss_display_name(\n\t\t\tOM_uint32 *minor_status,\n\t\t\tgss_name_t input_name,\n\t\t\tgss_buffer_t output_name_buffer,\n\t\t\tgss_OID *output_name_type)\n{\n\tOM_uint32 status = GSS_S_COMPLETE;\n\tdsyslog(\"Entering display_name\\n\");\n\n\tstatus = gss_display_name(minor_status, input_name,\n\t\t\toutput_name_buffer, output_name_type);\n\n\tdsyslog(\"Leaving display_name\\n\");\n\treturn (status);\n}\n\n\n/*ARGSUSED*/\nOM_uint32 KRB5_CALLCONV\nspnego_gss_inquire_names_for_mech(\n\t\t\t\tOM_uint32\t*minor_status,\n\t\t\t\tgss_OID\t\tmechanism,\n\t\t\t\tgss_OID_set\t*name_types)\n{\n\tOM_uint32   major, minor;\n\n\tdsyslog(\"Entering inquire_names_for_mech\\n\");\n\t/*\n\t * We only know how to handle our own mechanism.\n\t */\n\tif ((mechanism != GSS_C_NULL_OID) &&\n\t    !g_OID_equal(gss_mech_spnego, mechanism)) {\n\t\t*minor_status = 0;\n\t\treturn (GSS_S_FAILURE);\n\t}\n\n\tmajor = gss_create_empty_oid_set(minor_status, name_types);\n\tif (major == GSS_S_COMPLETE) {\n\t\t/* Now add our members. */\n\t\tif (((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_USER_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE) &&\n\t\t    ((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_MACHINE_UID_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE) &&\n\t\t    ((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_STRING_UID_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE)) {\n\t\t\tmajor = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_HOSTBASED_SERVICE,\n\t\t\t\tname_types);\n\t\t}\n\n\t\tif (major != GSS_S_COMPLETE)\n\t\t\t(void) gss_release_oid_set(&minor, name_types);\n\t}\n\n\tdsyslog(\"Leaving inquire_names_for_mech\\n\");\n\treturn (major);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_unwrap(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t context_handle,\n\t\tgss_buffer_t input_message_buffer,\n\t\tgss_buffer_t output_message_buffer,\n\t\tint *conf_state,\n\t\tgss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap(minor_status,\n\t\t\tcontext_handle,\n\t\t\tinput_message_buffer,\n\t\t\toutput_message_buffer,\n\t\t\tconf_state,\n\t\t\tqop_state);\n\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_wrap(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t context_handle,\n\t\tint conf_req_flag,\n\t\tgss_qop_t qop_req,\n\t\tgss_buffer_t input_message_buffer,\n\t\tint *conf_state,\n\t\tgss_buffer_t output_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap(minor_status,\n\t\t    context_handle,\n\t\t    conf_req_flag,\n\t\t    qop_req,\n\t\t    input_message_buffer,\n\t\t    conf_state,\n\t\t    output_message_buffer);\n\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_process_context_token(\n\t\t\t\tOM_uint32\t*minor_status,\n\t\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\t\tconst gss_buffer_t token_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_process_context_token(minor_status,\n\t\t\t\t\tcontext_handle,\n\t\t\t\t\ttoken_buffer);\n\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_delete_sec_context(\n\t\t\t    OM_uint32 *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_buffer_t output_token)\n{\n\tOM_uint32 ret = GSS_S_COMPLETE;\n\tspnego_gss_ctx_id_t *ctx =\n\t\t    (spnego_gss_ctx_id_t *)context_handle;\n\n\t*minor_status = 0;\n\n\tif (context_handle == NULL)\n\t\treturn (GSS_S_FAILURE);\n\n\tif (*ctx == NULL)\n\t\treturn (GSS_S_COMPLETE);\n\n\t/*\n\t * If this is still an SPNEGO mech, release it locally.\n\t */\n\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n\t\t(void) gss_delete_sec_context(minor_status,\n\t\t\t\t    &(*ctx)->ctx_handle,\n\t\t\t\t    output_token);\n\t\t(void) release_spnego_ctx(ctx);\n\t} else {\n\t\tret = gss_delete_sec_context(minor_status,\n\t\t\t\t    context_handle,\n\t\t\t\t    output_token);\n\t}\n\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_context_time(\n\t\t\tOM_uint32\t*minor_status,\n\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\tOM_uint32\t*time_rec)\n{\n\tOM_uint32 ret;\n\tret = gss_context_time(minor_status,\n\t\t\t    context_handle,\n\t\t\t    time_rec);\n\treturn (ret);\n}\n#ifndef LEAN_CLIENT\nOM_uint32 KRB5_CALLCONV\nspnego_gss_export_sec_context(\n\t\t\t    OM_uint32\t  *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_buffer_t interprocess_token)\n{\n\tOM_uint32 ret;\n\tret = gss_export_sec_context(minor_status,\n\t\t\t\t    context_handle,\n\t\t\t\t    interprocess_token);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_import_sec_context(\n\tOM_uint32\t\t*minor_status,\n\tconst gss_buffer_t\tinterprocess_token,\n\tgss_ctx_id_t\t\t*context_handle)\n{\n\tOM_uint32 ret;\n\tret = gss_import_sec_context(minor_status,\n\t\t\t\t    interprocess_token,\n\t\t\t\t    context_handle);\n\treturn (ret);\n}\n#endif /* LEAN_CLIENT */\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_inquire_context(\n\t\t\tOM_uint32\t*minor_status,\n\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\tgss_name_t\t*src_name,\n\t\t\tgss_name_t\t*targ_name,\n\t\t\tOM_uint32\t*lifetime_rec,\n\t\t\tgss_OID\t\t*mech_type,\n\t\t\tOM_uint32\t*ctx_flags,\n\t\t\tint\t\t*locally_initiated,\n\t\t\tint\t\t*opened)\n{\n\tOM_uint32 ret = GSS_S_COMPLETE;\n\n\tret = gss_inquire_context(minor_status,\n\t\t\t\tcontext_handle,\n\t\t\t\tsrc_name,\n\t\t\t\ttarg_name,\n\t\t\t\tlifetime_rec,\n\t\t\t\tmech_type,\n\t\t\t\tctx_flags,\n\t\t\t\tlocally_initiated,\n\t\t\t\topened);\n\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_wrap_size_limit(\n\tOM_uint32\t*minor_status,\n\tconst gss_ctx_id_t context_handle,\n\tint\t\tconf_req_flag,\n\tgss_qop_t\tqop_req,\n\tOM_uint32\treq_output_size,\n\tOM_uint32\t*max_input_size)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_size_limit(minor_status,\n\t\t\t\tcontext_handle,\n\t\t\t\tconf_req_flag,\n\t\t\t\tqop_req,\n\t\t\t\treq_output_size,\n\t\t\t\tmax_input_size);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_get_mic(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tgss_qop_t  qop_req,\n\t\tconst gss_buffer_t message_buffer,\n\t\tgss_buffer_t message_token)\n{\n\tOM_uint32 ret;\n\tret = gss_get_mic(minor_status,\n\t\t    context_handle,\n\t\t    qop_req,\n\t\t    message_buffer,\n\t\t    message_token);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_verify_mic(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_buffer_t msg_buffer,\n\t\tconst gss_buffer_t token_buffer,\n\t\tgss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_verify_mic(minor_status,\n\t\t\t    context_handle,\n\t\t\t    msg_buffer,\n\t\t\t    token_buffer,\n\t\t\t    qop_state);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_inquire_sec_context_by_oid(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_OID desired_object,\n\t\tgss_buffer_set_t *data_set)\n{\n\tOM_uint32 ret;\n\tret = gss_inquire_sec_context_by_oid(minor_status,\n\t\t\t    context_handle,\n\t\t\t    desired_object,\n\t\t\t    data_set);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_inquire_cred_by_oid(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_cred_id_t cred_handle,\n\t\tconst gss_OID desired_object,\n\t\tgss_buffer_set_t *data_set)\n{\n\tOM_uint32 ret;\n\tspnego_gss_cred_id_t spcred = (spnego_gss_cred_id_t)cred_handle;\n\tgss_cred_id_t mcred;\n\tmcred = (spcred == NULL) ? GSS_C_NO_CREDENTIAL : spcred->mcred;\n\tret = gss_inquire_cred_by_oid(minor_status,\n\t\t\t\tmcred,\n\t\t\t\tdesired_object,\n\t\t\t\tdata_set);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_set_cred_option(\n\t\tOM_uint32 *minor_status,\n\t\tgss_cred_id_t *cred_handle,\n\t\tconst gss_OID desired_object,\n\t\tconst gss_buffer_t value)\n{\n\tOM_uint32 ret;\n\tOM_uint32 tmp_minor_status;\n\tspnego_gss_cred_id_t spcred = (spnego_gss_cred_id_t)*cred_handle;\n\tgss_cred_id_t mcred;\n\n\tmcred = (spcred == NULL) ? GSS_C_NO_CREDENTIAL : spcred->mcred;\n\tret = gss_set_cred_option(minor_status,\n\t\t\t\t  &mcred,\n\t\t\t\t  desired_object,\n\t\t\t\t  value);\n\tif (ret == GSS_S_COMPLETE && spcred == NULL) {\n\t\t/*\n\t\t * If the mechanism allocated a new credential handle, then\n\t\t * we need to wrap it up in an SPNEGO credential handle.\n\t\t */\n\n\t\tspcred = malloc(sizeof(spnego_gss_cred_id_rec));\n\t\tif (spcred == NULL) {\n\t\t\tgss_release_cred(&tmp_minor_status, &mcred);\n\t\t\t*minor_status = ENOMEM;\n\t\t\treturn (GSS_S_FAILURE);\n\t\t}\n\t\tspcred->mcred = mcred;\n\t\tspcred->neg_mechs = GSS_C_NULL_OID_SET;\n\t\t*cred_handle = (gss_cred_id_t)spcred;\n\t}\n\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_set_sec_context_option(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t *context_handle,\n\t\tconst gss_OID desired_object,\n\t\tconst gss_buffer_t value)\n{\n\tOM_uint32 ret;\n\tret = gss_set_sec_context_option(minor_status,\n\t\t\t    context_handle,\n\t\t\t    desired_object,\n\t\t\t    value);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_wrap_aead(OM_uint32 *minor_status,\n\t\t     gss_ctx_id_t context_handle,\n\t\t     int conf_req_flag,\n\t\t     gss_qop_t qop_req,\n\t\t     gss_buffer_t input_assoc_buffer,\n\t\t     gss_buffer_t input_payload_buffer,\n\t\t     int *conf_state,\n\t\t     gss_buffer_t output_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_aead(minor_status,\n\t\t\t    context_handle,\n\t\t\t    conf_req_flag,\n\t\t\t    qop_req,\n\t\t\t    input_assoc_buffer,\n\t\t\t    input_payload_buffer,\n\t\t\t    conf_state,\n\t\t\t    output_message_buffer);\n\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_unwrap_aead(OM_uint32 *minor_status,\n\t\t       gss_ctx_id_t context_handle,\n\t\t       gss_buffer_t input_message_buffer,\n\t\t       gss_buffer_t input_assoc_buffer,\n\t\t       gss_buffer_t output_payload_buffer,\n\t\t       int *conf_state,\n\t\t       gss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap_aead(minor_status,\n\t\t\t      context_handle,\n\t\t\t      input_message_buffer,\n\t\t\t      input_assoc_buffer,\n\t\t\t      output_payload_buffer,\n\t\t\t      conf_state,\n\t\t\t      qop_state);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_wrap_iov(OM_uint32 *minor_status,\n\t\t    gss_ctx_id_t context_handle,\n\t\t    int conf_req_flag,\n\t\t    gss_qop_t qop_req,\n\t\t    int *conf_state,\n\t\t    gss_iov_buffer_desc *iov,\n\t\t    int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_iov(minor_status,\n\t\t\t   context_handle,\n\t\t\t   conf_req_flag,\n\t\t\t   qop_req,\n\t\t\t   conf_state,\n\t\t\t   iov,\n\t\t\t   iov_count);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_unwrap_iov(OM_uint32 *minor_status,\n\t\t      gss_ctx_id_t context_handle,\n\t\t      int *conf_state,\n\t\t      gss_qop_t *qop_state,\n\t\t      gss_iov_buffer_desc *iov,\n\t\t      int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap_iov(minor_status,\n\t\t\t     context_handle,\n\t\t\t     conf_state,\n\t\t\t     qop_state,\n\t\t\t     iov,\n\t\t\t     iov_count);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n\t\t\t   gss_ctx_id_t context_handle,\n\t\t\t   int conf_req_flag,\n\t\t\t   gss_qop_t qop_req,\n\t\t\t   int *conf_state,\n\t\t\t   gss_iov_buffer_desc *iov,\n\t\t\t   int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_iov_length(minor_status,\n\t\t\t\t  context_handle,\n\t\t\t\t  conf_req_flag,\n\t\t\t\t  qop_req,\n\t\t\t\t  conf_state,\n\t\t\t\t  iov,\n\t\t\t\t  iov_count);\n\treturn (ret);\n}\n\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_complete_auth_token(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tgss_buffer_t input_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_complete_auth_token(minor_status,\n\t\t\t\t      context_handle,\n\t\t\t\t      input_message_buffer);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_acquire_cred_impersonate_name(OM_uint32 *minor_status,\n\t\t\t\t\t const gss_cred_id_t impersonator_cred_handle,\n\t\t\t\t\t const gss_name_t desired_name,\n\t\t\t\t\t OM_uint32 time_req,\n\t\t\t\t\t gss_OID_set desired_mechs,\n\t\t\t\t\t gss_cred_usage_t cred_usage,\n\t\t\t\t\t gss_cred_id_t *output_cred_handle,\n\t\t\t\t\t gss_OID_set *actual_mechs,\n\t\t\t\t\t OM_uint32 *time_rec)\n{\n\tOM_uint32 status;\n\tgss_OID_set amechs = GSS_C_NULL_OID_SET;\n\tspnego_gss_cred_id_t imp_spcred = NULL, out_spcred = NULL;\n\tgss_cred_id_t imp_mcred, out_mcred;\n\n\tdsyslog(\"Entering spnego_gss_acquire_cred_impersonate_name\\n\");\n\n\tif (actual_mechs)\n\t\t*actual_mechs = NULL;\n\n\tif (time_rec)\n\t\t*time_rec = 0;\n\n\timp_spcred = (spnego_gss_cred_id_t)impersonator_cred_handle;\n\timp_mcred = imp_spcred ? imp_spcred->mcred : GSS_C_NO_CREDENTIAL;\n\tif (desired_mechs == GSS_C_NO_OID_SET) {\n\t\tstatus = gss_inquire_cred(minor_status, imp_mcred, NULL, NULL,\n\t\t\t\t\t  NULL, &amechs);\n\t\tif (status != GSS_S_COMPLETE)\n\t\t\treturn status;\n\n\t\tdesired_mechs = amechs;\n\t}\n\n\tstatus = gss_acquire_cred_impersonate_name(minor_status, imp_mcred,\n\t\t\t\t\t\t   desired_name, time_req,\n\t\t\t\t\t\t   desired_mechs, cred_usage,\n\t\t\t\t\t\t   &out_mcred, actual_mechs,\n\t\t\t\t\t\t   time_rec);\n\n\tif (amechs != GSS_C_NULL_OID_SET)\n\t\t(void) gss_release_oid_set(minor_status, &amechs);\n\n\tout_spcred = malloc(sizeof(spnego_gss_cred_id_rec));\n\tif (out_spcred == NULL) {\n\t\tgss_release_cred(minor_status, &out_mcred);\n\t\t*minor_status = ENOMEM;\n\t\treturn (GSS_S_FAILURE);\n\t}\n\tout_spcred->mcred = out_mcred;\n\tout_spcred->neg_mechs = GSS_C_NULL_OID_SET;\n\t*output_cred_handle = (gss_cred_id_t)out_spcred;\n\n\tdsyslog(\"Leaving spnego_gss_acquire_cred_impersonate_name\\n\");\n\treturn (status);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_acquire_cred_with_password(OM_uint32 *minor_status,\n\t\t\t\t      const gss_name_t desired_name,\n\t\t\t\t      const gss_buffer_t password,\n\t\t\t\t      OM_uint32 time_req,\n\t\t\t\t      const gss_OID_set desired_mechs,\n\t\t\t\t      gss_cred_usage_t cred_usage,\n\t\t\t\t      gss_cred_id_t *output_cred_handle,\n\t\t\t\t      gss_OID_set *actual_mechs,\n\t\t\t\t      OM_uint32 *time_rec)\n{\n\tOM_uint32 status, tmpmin;\n\tgss_OID_set amechs = GSS_C_NULL_OID_SET;\n\tgss_cred_id_t mcred = NULL;\n\tspnego_gss_cred_id_t spcred = NULL;\n\n\tdsyslog(\"Entering spnego_gss_acquire_cred_with_password\\n\");\n\n\tif (actual_mechs)\n\t\t*actual_mechs = NULL;\n\n\tif (time_rec)\n\t\t*time_rec = 0;\n\n\tstatus = get_available_mechs(minor_status, desired_name,\n\t\t\t\t     cred_usage, GSS_C_NO_CRED_STORE,\n\t\t\t\t     NULL, &amechs);\n\tif (status != GSS_S_COMPLETE)\n\t    goto cleanup;\n\n\tstatus = gss_acquire_cred_with_password(minor_status, desired_name,\n\t\t\t\t\t\tpassword, time_req, amechs,\n\t\t\t\t\t\tcred_usage, &mcred,\n\t\t\t\t\t\tactual_mechs, time_rec);\n\tif (status != GSS_S_COMPLETE)\n\t    goto cleanup;\n\n\tspcred = malloc(sizeof(spnego_gss_cred_id_rec));\n\tif (spcred == NULL) {\n\t\t*minor_status = ENOMEM;\n\t\tstatus = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tspcred->neg_mechs = GSS_C_NULL_OID_SET;\n\tspcred->mcred = mcred;\n\tmcred = GSS_C_NO_CREDENTIAL;\n\t*output_cred_handle = (gss_cred_id_t)spcred;\n\ncleanup:\n\n\t(void) gss_release_oid_set(&tmpmin, &amechs);\n\t(void) gss_release_cred(&tmpmin, &mcred);\n\n\tdsyslog(\"Leaving spnego_gss_acquire_cred_with_password\\n\");\n\treturn (status);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_display_name_ext(OM_uint32 *minor_status,\n\t\t\t    gss_name_t name,\n\t\t\t    gss_OID display_as_name_type,\n\t\t\t    gss_buffer_t display_name)\n{\n\tOM_uint32 ret;\n\tret = gss_display_name_ext(minor_status,\n\t\t\t\t   name,\n\t\t\t\t   display_as_name_type,\n\t\t\t\t   display_name);\n\treturn (ret);\n}\n\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_inquire_name(OM_uint32 *minor_status,\n\t\t\tgss_name_t name,\n\t\t\tint *name_is_MN,\n\t\t\tgss_OID *MN_mech,\n\t\t\tgss_buffer_set_t *attrs)\n{\n\tOM_uint32 ret;\n\tret = gss_inquire_name(minor_status,\n\t\t\t       name,\n\t\t\t       name_is_MN,\n\t\t\t       MN_mech,\n\t\t\t       attrs);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_get_name_attribute(OM_uint32 *minor_status,\n\t\t\t      gss_name_t name,\n\t\t\t      gss_buffer_t attr,\n\t\t\t      int *authenticated,\n\t\t\t      int *complete,\n\t\t\t      gss_buffer_t value,\n\t\t\t      gss_buffer_t display_value,\n\t\t\t      int *more)\n{\n\tOM_uint32 ret;\n\tret = gss_get_name_attribute(minor_status,\n\t\t\t\t     name,\n\t\t\t\t     attr,\n\t\t\t\t     authenticated,\n\t\t\t\t     complete,\n\t\t\t\t     value,\n\t\t\t\t     display_value,\n\t\t\t\t     more);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_set_name_attribute(OM_uint32 *minor_status,\n\t\t\t      gss_name_t name,\n\t\t\t      int complete,\n\t\t\t      gss_buffer_t attr,\n\t\t\t      gss_buffer_t value)\n{\n\tOM_uint32 ret;\n\tret = gss_set_name_attribute(minor_status,\n\t\t\t\t     name,\n\t\t\t\t     complete,\n\t\t\t\t     attr,\n\t\t\t\t     value);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_delete_name_attribute(OM_uint32 *minor_status,\n\t\t\t\t gss_name_t name,\n\t\t\t\t gss_buffer_t attr)\n{\n\tOM_uint32 ret;\n\tret = gss_delete_name_attribute(minor_status,\n\t\t\t\t\tname,\n\t\t\t\t\tattr);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_export_name_composite(OM_uint32 *minor_status,\n\t\t\t\t gss_name_t name,\n\t\t\t\t gss_buffer_t exp_composite_name)\n{\n\tOM_uint32 ret;\n\tret = gss_export_name_composite(minor_status,\n\t\t\t\t\tname,\n\t\t\t\t\texp_composite_name);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_map_name_to_any(OM_uint32 *minor_status,\n\t\t\t   gss_name_t name,\n\t\t\t   int authenticated,\n\t\t\t   gss_buffer_t type_id,\n\t\t\t   gss_any_t *output)\n{\n\tOM_uint32 ret;\n\tret = gss_map_name_to_any(minor_status,\n\t\t\t\t  name,\n\t\t\t\t  authenticated,\n\t\t\t\t  type_id,\n\t\t\t\t  output);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_release_any_name_mapping(OM_uint32 *minor_status,\n\t\t\t\t    gss_name_t name,\n\t\t\t\t    gss_buffer_t type_id,\n\t\t\t\t    gss_any_t *input)\n{\n\tOM_uint32 ret;\n\tret = gss_release_any_name_mapping(minor_status,\n\t\t\t\t\t   name,\n\t\t\t\t\t   type_id,\n\t\t\t\t\t   input);\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_pseudo_random(OM_uint32 *minor_status,\n\t\t\t gss_ctx_id_t context,\n\t\t\t int prf_key,\n\t\t\t const gss_buffer_t prf_in,\n\t\t\t ssize_t desired_output_len,\n\t\t\t gss_buffer_t prf_out)\n{\n\tOM_uint32 ret;\n\tret = gss_pseudo_random(minor_status,\n\t\t\t\tcontext,\n\t\t\t\tprf_key,\n\t\t\t\tprf_in,\n\t\t\t\tdesired_output_len,\n\t\t\t\tprf_out);\n        return (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_set_neg_mechs(OM_uint32 *minor_status,\n\t\t\t gss_cred_id_t cred_handle,\n\t\t\t const gss_OID_set mech_list)\n{\n\tOM_uint32 ret;\n\tspnego_gss_cred_id_t spcred = (spnego_gss_cred_id_t)cred_handle;\n\n\t/* Store mech_list in spcred for use in negotiation logic. */\n\tgss_release_oid_set(minor_status, &spcred->neg_mechs);\n\tret = generic_gss_copy_oid_set(minor_status, mech_list,\n\t\t\t\t       &spcred->neg_mechs);\n\treturn (ret);\n}\n\n#define SPNEGO_SASL_NAME\t\"SPNEGO\"\n#define SPNEGO_SASL_NAME_LEN\t(sizeof(SPNEGO_SASL_NAME) - 1)\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_inquire_mech_for_saslname(OM_uint32 *minor_status,\n                                     const gss_buffer_t sasl_mech_name,\n                                     gss_OID *mech_type)\n{\n\tif (sasl_mech_name->length == SPNEGO_SASL_NAME_LEN &&\n\t    memcmp(sasl_mech_name->value, SPNEGO_SASL_NAME,\n\t\t   SPNEGO_SASL_NAME_LEN) == 0) {\n\t\tif (mech_type != NULL)\n\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n\t\treturn (GSS_S_COMPLETE);\n\t}\n\n\treturn (GSS_S_BAD_MECH);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_inquire_saslname_for_mech(OM_uint32 *minor_status,\n                                     const gss_OID desired_mech,\n                                     gss_buffer_t sasl_mech_name,\n                                     gss_buffer_t mech_name,\n                                     gss_buffer_t mech_description)\n{\n\t*minor_status = 0;\n\n\tif (!g_OID_equal(desired_mech, gss_mech_spnego))\n\t\treturn (GSS_S_BAD_MECH);\n\n\tif (!g_make_string_buffer(SPNEGO_SASL_NAME, sasl_mech_name) ||\n\t    !g_make_string_buffer(\"spnego\", mech_name) ||\n\t    !g_make_string_buffer(\"Simple and Protected GSS-API \"\n\t\t\t\t  \"Negotiation Mechanism\", mech_description))\n\t\tgoto fail;\n\n\treturn (GSS_S_COMPLETE);\n\nfail:\n\t*minor_status = ENOMEM;\n\treturn (GSS_S_FAILURE);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_inquire_attrs_for_mech(OM_uint32 *minor_status,\n\t\t\t\t  gss_const_OID mech,\n\t\t\t\t  gss_OID_set *mech_attrs,\n\t\t\t\t  gss_OID_set *known_mech_attrs)\n{\n\tOM_uint32 major, tmpMinor;\n\n\t/* known_mech_attrs is handled by mechglue */\n\t*minor_status = 0;\n\n\tif (mech_attrs == NULL)\n\t    return (GSS_S_COMPLETE);\n\n\tmajor = gss_create_empty_oid_set(minor_status, mech_attrs);\n\tif (GSS_ERROR(major))\n\t\tgoto cleanup;\n\n#define MA_SUPPORTED(ma)    do {\t\t\t\t\t\\\n\t\tmajor = gss_add_oid_set_member(minor_status,\t\t\\\n\t\t\t\t\t       (gss_OID)ma, mech_attrs); \\\n\t\tif (GSS_ERROR(major))\t\t\t\t\t\\\n\t\t\tgoto cleanup;\t\t\t\t\t\\\n\t} while (0)\n\n\tMA_SUPPORTED(GSS_C_MA_MECH_NEGO);\n\tMA_SUPPORTED(GSS_C_MA_ITOK_FRAMED);\n\ncleanup:\n\tif (GSS_ERROR(major))\n\t\tgss_release_oid_set(&tmpMinor, mech_attrs);\n\n\treturn (major);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_export_cred(OM_uint32 *minor_status,\n\t\t       gss_cred_id_t cred_handle,\n\t\t       gss_buffer_t token)\n{\n\tspnego_gss_cred_id_t spcred = (spnego_gss_cred_id_t)cred_handle;\n\n\treturn (gss_export_cred(minor_status, spcred->mcred, token));\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_import_cred(OM_uint32 *minor_status,\n\t\t       gss_buffer_t token,\n\t\t       gss_cred_id_t *cred_handle)\n{\n\tOM_uint32 ret;\n\tspnego_gss_cred_id_t spcred;\n\tgss_cred_id_t mcred;\n\n\tret = gss_import_cred(minor_status, token, &mcred);\n\tif (GSS_ERROR(ret))\n\t\treturn (ret);\n\tspcred = malloc(sizeof(*spcred));\n\tif (spcred == NULL) {\n\t\tgss_release_cred(minor_status, &mcred);\n\t\t*minor_status = ENOMEM;\n\t\treturn (GSS_S_FAILURE);\n\t}\n\tspcred->mcred = mcred;\n\tspcred->neg_mechs = GSS_C_NULL_OID_SET;\n\t*cred_handle = (gss_cred_id_t)spcred;\n\treturn (ret);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n\t\t       int iov_count)\n{\n    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n\t\t\t   iov_count);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n\t\t\t  int iov_count)\n{\n    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n\t\t\t      iov_count);\n}\n\nOM_uint32 KRB5_CALLCONV\nspnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n\t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n\t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n{\n    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n\t\t\t\t  iov_count);\n}\n\n/*\n * We will release everything but the ctx_handle so that it\n * can be passed back to init/accept context. This routine should\n * not be called until after the ctx_handle memory is assigned to\n * the supplied context handle from init/accept context.\n */\nstatic void\nrelease_spnego_ctx(spnego_gss_ctx_id_t *ctx)\n{\n\tspnego_gss_ctx_id_t context;\n\tOM_uint32 minor_stat;\n\tcontext = *ctx;\n\n\tif (context != NULL) {\n\t\t(void) gss_release_buffer(&minor_stat,\n\t\t\t\t\t&context->DER_mechTypes);\n\n\t\t(void) gss_release_oid_set(&minor_stat, &context->mech_set);\n\n\t\t(void) gss_release_name(&minor_stat, &context->internal_name);\n\n\t\tif (context->optionStr != NULL) {\n\t\t\tfree(context->optionStr);\n\t\t\tcontext->optionStr = NULL;\n\t\t}\n\t\tfree(context);\n\t\t*ctx = NULL;\n\t}\n}\n\n/*\n * Can't use gss_indicate_mechs by itself to get available mechs for\n * SPNEGO because it will also return the SPNEGO mech and we do not\n * want to consider SPNEGO as an available security mech for\n * negotiation. For this reason, get_available_mechs will return\n * all available mechs except SPNEGO.\n *\n * If a ptr to a creds list is given, this function will attempt\n * to acquire creds for the creds given and trim the list of\n * returned mechanisms to only those for which creds are valid.\n *\n */\nstatic OM_uint32\nget_available_mechs(OM_uint32 *minor_status,\n\tgss_name_t name, gss_cred_usage_t usage,\n\tgss_const_key_value_set_t cred_store,\n\tgss_cred_id_t *creds, gss_OID_set *rmechs)\n{\n\tunsigned int\ti;\n\tint\t\tfound = 0;\n\tOM_uint32 major_status = GSS_S_COMPLETE, tmpmin;\n\tgss_OID_set mechs, goodmechs;\n\n\tmajor_status = gss_indicate_mechs(minor_status, &mechs);\n\n\tif (major_status != GSS_S_COMPLETE) {\n\t\treturn (major_status);\n\t}\n\n\tmajor_status = gss_create_empty_oid_set(minor_status, rmechs);\n\n\tif (major_status != GSS_S_COMPLETE) {\n\t\t(void) gss_release_oid_set(minor_status, &mechs);\n\t\treturn (major_status);\n\t}\n\n\tfor (i = 0; i < mechs->count && major_status == GSS_S_COMPLETE; i++) {\n\t\tif ((mechs->elements[i].length\n\t\t    != spnego_mechanism.mech_type.length) ||\n\t\t    memcmp(mechs->elements[i].elements,\n\t\t\tspnego_mechanism.mech_type.elements,\n\t\t\tspnego_mechanism.mech_type.length)) {\n\n\t\t\tmajor_status = gss_add_oid_set_member(minor_status,\n\t\t\t\t\t\t\t      &mechs->elements[i],\n\t\t\t\t\t\t\t      rmechs);\n\t\t\tif (major_status == GSS_S_COMPLETE)\n\t\t\t\tfound++;\n\t\t}\n\t}\n\n\t/*\n\t * If the caller wanted a list of creds returned,\n\t * trim the list of mechanisms down to only those\n\t * for which the creds are valid.\n\t */\n\tif (found > 0 && major_status == GSS_S_COMPLETE && creds != NULL) {\n\t\tmajor_status = gss_acquire_cred_from(minor_status, name,\n\t\t\t\t\t\t     GSS_C_INDEFINITE,\n\t\t\t\t\t\t     *rmechs, usage,\n\t\t\t\t\t\t     cred_store, creds,\n\t\t\t\t\t\t     &goodmechs, NULL);\n\n\t\t/*\n\t\t * Drop the old list in favor of the new\n\t\t * \"trimmed\" list.\n\t\t */\n\t\t(void) gss_release_oid_set(&tmpmin, rmechs);\n\t\tif (major_status == GSS_S_COMPLETE) {\n\t\t\t(void) gssint_copy_oid_set(&tmpmin,\n\t\t\t\t\tgoodmechs, rmechs);\n\t\t\t(void) gss_release_oid_set(&tmpmin, &goodmechs);\n\t\t}\n\t}\n\n\t(void) gss_release_oid_set(&tmpmin, &mechs);\n\tif (found == 0 || major_status != GSS_S_COMPLETE) {\n\t\t*minor_status = ERR_SPNEGO_NO_MECHS_AVAILABLE;\n\t\tmap_errcode(minor_status);\n\t\tif (major_status == GSS_S_COMPLETE)\n\t\t\tmajor_status = GSS_S_FAILURE;\n\t}\n\n\treturn (major_status);\n}\n\n/*\n * Return a list of mechanisms we are willing to negotiate for a credential,\n * taking into account the mech set provided with gss_set_neg_mechs if it\n * exists.\n */\nstatic OM_uint32\nget_negotiable_mechs(OM_uint32 *minor_status, spnego_gss_cred_id_t spcred,\n\t\t     gss_cred_usage_t usage, gss_OID_set *rmechs)\n{\n\tOM_uint32 ret, tmpmin;\n\tgss_cred_id_t creds = GSS_C_NO_CREDENTIAL, *credptr;\n\tgss_OID_set cred_mechs = GSS_C_NULL_OID_SET;\n\tgss_OID_set intersect_mechs = GSS_C_NULL_OID_SET;\n\tunsigned int i;\n\tint present;\n\n\tif (spcred == NULL) {\n\t\t/*\n\t\t * The default credentials were supplied.  Return a list of all\n\t\t * available mechs except SPNEGO.  When initiating, trim this\n\t\t * list to mechs we can acquire credentials for.\n\t\t */\n\t\tcredptr = (usage == GSS_C_INITIATE) ? &creds : NULL;\n\t\tret = get_available_mechs(minor_status, GSS_C_NO_NAME, usage,\n\t\t\t\t\t  GSS_C_NO_CRED_STORE, credptr,\n\t\t\t\t\t  rmechs);\n\t\tgss_release_cred(&tmpmin, &creds);\n\t\treturn (ret);\n\t}\n\n\t/* Get the list of mechs in the mechglue cred. */\n\tret = gss_inquire_cred(minor_status, spcred->mcred, NULL, NULL, NULL,\n\t\t\t       &cred_mechs);\n\tif (ret != GSS_S_COMPLETE)\n\t\treturn (ret);\n\n\tif (spcred->neg_mechs == GSS_C_NULL_OID_SET) {\n\t\t/* gss_set_neg_mechs was never called; return cred_mechs. */\n\t\t*rmechs = cred_mechs;\n\t\t*minor_status = 0;\n\t\treturn (GSS_S_COMPLETE);\n\t}\n\n\t/* Compute the intersection of cred_mechs and spcred->neg_mechs,\n\t * preserving the order in spcred->neg_mechs. */\n\tret = gss_create_empty_oid_set(minor_status, &intersect_mechs);\n\tif (ret != GSS_S_COMPLETE) {\n\t\tgss_release_oid_set(&tmpmin, &cred_mechs);\n\t\treturn (ret);\n\t}\n\n\tfor (i = 0; i < spcred->neg_mechs->count; i++) {\n\t\tgss_test_oid_set_member(&tmpmin,\n\t\t\t\t\t&spcred->neg_mechs->elements[i],\n\t\t\t\t\tcred_mechs, &present);\n\t\tif (!present)\n\t\t\tcontinue;\n\t\tret = gss_add_oid_set_member(minor_status,\n\t\t\t\t\t     &spcred->neg_mechs->elements[i],\n\t\t\t\t\t     &intersect_mechs);\n\t\tif (ret != GSS_S_COMPLETE)\n\t\t\tbreak;\n\t}\n\n\tgss_release_oid_set(&tmpmin, &cred_mechs);\n\tif (intersect_mechs->count == 0 || ret != GSS_S_COMPLETE) {\n\t\tgss_release_oid_set(&tmpmin, &intersect_mechs);\n\t\t*minor_status = ERR_SPNEGO_NO_MECHS_AVAILABLE;\n\t\tmap_errcode(minor_status);\n\t\treturn (GSS_S_FAILURE);\n\t}\n\n\t*rmechs = intersect_mechs;\n\t*minor_status = 0;\n\treturn (GSS_S_COMPLETE);\n}\n\n/* following are token creation and reading routines */\n\n/*\n * If buff_in is not pointing to a MECH_OID, then return NULL and do not\n * advance the buffer, otherwise, decode the mech_oid from the buffer and\n * place in gss_OID.\n */\nstatic gss_OID\nget_mech_oid(OM_uint32 *minor_status, unsigned char **buff_in, size_t length)\n{\n\tOM_uint32\tstatus;\n\tgss_OID_desc \ttoid;\n\tgss_OID\t\tmech_out = NULL;\n\tunsigned char\t\t*start, *end;\n\n\tif (length < 1 || **buff_in != MECH_OID)\n\t\treturn (NULL);\n\n\tstart = *buff_in;\n\tend = start + length;\n\n\t(*buff_in)++;\n\ttoid.length = *(*buff_in)++;\n\n\tif ((*buff_in + toid.length) > end)\n\t\treturn (NULL);\n\n\ttoid.elements = *buff_in;\n\t*buff_in += toid.length;\n\n\tstatus = generic_gss_copy_oid(minor_status, &toid, &mech_out);\n\n\tif (status != GSS_S_COMPLETE) {\n\t\tmap_errcode(minor_status);\n\t\tmech_out = NULL;\n\t}\n\n\treturn (mech_out);\n}\n\n/*\n * der encode the given mechanism oid into buf_out, advancing the\n * buffer pointer.\n */\n\nstatic int\nput_mech_oid(unsigned char **buf_out, gss_OID_const mech, unsigned int buflen)\n{\n\tif (buflen < mech->length + 2)\n\t\treturn (-1);\n\t*(*buf_out)++ = MECH_OID;\n\t*(*buf_out)++ = (unsigned char) mech->length;\n\tmemcpy(*buf_out, mech->elements, mech->length);\n\t*buf_out += mech->length;\n\treturn (0);\n}\n\n/*\n * verify that buff_in points to an octet string, if it does not,\n * return NULL and don't advance the pointer. If it is an octet string\n * decode buff_in into a gss_buffer_t and return it, advancing the\n * buffer pointer.\n */\nstatic gss_buffer_t\nget_input_token(unsigned char **buff_in, unsigned int buff_length)\n{\n\tgss_buffer_t input_token;\n\tunsigned int len;\n\n\tif (g_get_tag_and_length(buff_in, OCTET_STRING, buff_length, &len) < 0)\n\t\treturn (NULL);\n\n\tinput_token = (gss_buffer_t)malloc(sizeof (gss_buffer_desc));\n\tif (input_token == NULL)\n\t\treturn (NULL);\n\n\tinput_token->length = len;\n\tif (input_token->length > 0) {\n\t\tinput_token->value = gssalloc_malloc(input_token->length);\n\t\tif (input_token->value == NULL) {\n\t\t\tfree(input_token);\n\t\t\treturn (NULL);\n\t\t}\n\n\t\tmemcpy(input_token->value, *buff_in, input_token->length);\n\t} else {\n\t\tinput_token->value = NULL;\n\t}\n\t*buff_in += input_token->length;\n\treturn (input_token);\n}\n\n/*\n * verify that the input token length is not 0. If it is, just return.\n * If the token length is greater than 0, der encode as an octet string\n * and place in buf_out, advancing buf_out.\n */\n\nstatic int\nput_input_token(unsigned char **buf_out, gss_buffer_t input_token,\n\t\tunsigned int buflen)\n{\n\tint ret;\n\n\t/* if token length is 0, we do not want to send */\n\tif (input_token->length == 0)\n\t\treturn (0);\n\n\tif (input_token->length > buflen)\n\t\treturn (-1);\n\n\t*(*buf_out)++ = OCTET_STRING;\n\tif ((ret = gssint_put_der_length(input_token->length, buf_out,\n\t\t\t    input_token->length)))\n\t\treturn (ret);\n\tTWRITE_STR(*buf_out, input_token->value, input_token->length);\n\treturn (0);\n}\n\n/*\n * verify that buff_in points to a sequence of der encoding. The mech\n * set is the only sequence of encoded object in the token, so if it is\n * a sequence of encoding, decode the mechset into a gss_OID_set and\n * return it, advancing the buffer pointer.\n */\nstatic gss_OID_set\nget_mech_set(OM_uint32 *minor_status, unsigned char **buff_in,\n\t     unsigned int buff_length)\n{\n\tgss_OID_set returned_mechSet;\n\tOM_uint32 major_status;\n\tint length;\n\tunsigned int bytes;\n\tOM_uint32 set_length;\n\tunsigned char\t\t*start;\n\tint i;\n\n\tif (**buff_in != SEQUENCE_OF)\n\t\treturn (NULL);\n\n\tstart = *buff_in;\n\t(*buff_in)++;\n\n\tlength = gssint_get_der_length(buff_in, buff_length, &bytes);\n\tif (length < 0 || buff_length - bytes < (unsigned int)length)\n\t\treturn NULL;\n\n\tmajor_status = gss_create_empty_oid_set(minor_status,\n\t\t\t\t\t\t&returned_mechSet);\n\tif (major_status != GSS_S_COMPLETE)\n\t\treturn (NULL);\n\n\tfor (set_length = 0, i = 0; set_length < (unsigned int)length; i++) {\n\t\tgss_OID_desc *temp = get_mech_oid(minor_status, buff_in,\n\t\t\tbuff_length - (*buff_in - start));\n\t\tif (temp == NULL)\n\t\t\tbreak;\n\n\t\tmajor_status = gss_add_oid_set_member(minor_status,\n\t\t\t\t\t\t      temp, &returned_mechSet);\n\t\tif (major_status == GSS_S_COMPLETE) {\n\t\t\tset_length += returned_mechSet->elements[i].length +2;\n\t\t\tif (generic_gss_release_oid(minor_status, &temp))\n\t\t\t\tmap_errcode(minor_status);\n\t\t}\n\t}\n\n\treturn (returned_mechSet);\n}\n\n/*\n * Encode mechSet into buf.\n */\nstatic int\nput_mech_set(gss_OID_set mechSet, gss_buffer_t buf)\n{\n\tunsigned char *ptr;\n\tunsigned int i;\n\tunsigned int tlen, ilen;\n\n\ttlen = ilen = 0;\n\tfor (i = 0; i < mechSet->count; i++) {\n\t\t/*\n\t\t * 0x06 [DER LEN] [OID]\n\t\t */\n\t\tilen += 1 +\n\t\t\tgssint_der_length_size(mechSet->elements[i].length) +\n\t\t\tmechSet->elements[i].length;\n\t}\n\t/*\n\t * 0x30 [DER LEN]\n\t */\n\ttlen = 1 + gssint_der_length_size(ilen) + ilen;\n\tptr = gssalloc_malloc(tlen);\n\tif (ptr == NULL)\n\t\treturn -1;\n\n\tbuf->value = ptr;\n\tbuf->length = tlen;\n#define REMAIN (buf->length - ((unsigned char *)buf->value - ptr))\n\n\t*ptr++ = SEQUENCE_OF;\n\tif (gssint_put_der_length(ilen, &ptr, REMAIN) < 0)\n\t\treturn -1;\n\tfor (i = 0; i < mechSet->count; i++) {\n\t\tif (put_mech_oid(&ptr, &mechSet->elements[i], REMAIN) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n#undef REMAIN\n}\n\n/*\n * Verify that buff_in is pointing to a BIT_STRING with the correct\n * length and padding for the req_flags. If it is, decode req_flags\n * and return them, otherwise, return NULL.\n */\nstatic OM_uint32\nget_req_flags(unsigned char **buff_in, OM_uint32 bodysize,\n\t      OM_uint32 *req_flags)\n{\n\tunsigned int len;\n\n\tif (**buff_in != (CONTEXT | 0x01))\n\t\treturn (0);\n\n\tif (g_get_tag_and_length(buff_in, (CONTEXT | 0x01),\n\t\t\t\tbodysize, &len) < 0)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\tif (*(*buff_in)++ != BIT_STRING)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\tif (*(*buff_in)++ != BIT_STRING_LENGTH)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\tif (*(*buff_in)++ != BIT_STRING_PADDING)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\t*req_flags = (OM_uint32) (*(*buff_in)++ >> 1);\n\treturn (0);\n}\n\nstatic OM_uint32\nget_negTokenInit(OM_uint32 *minor_status,\n\t\t gss_buffer_t buf,\n\t\t gss_buffer_t der_mechSet,\n\t\t gss_OID_set *mechSet,\n\t\t OM_uint32 *req_flags,\n\t\t gss_buffer_t *mechtok,\n\t\t gss_buffer_t *mechListMIC)\n{\n\tOM_uint32 err;\n\tunsigned char *ptr, *bufstart;\n\tunsigned int len;\n\tgss_buffer_desc tmpbuf;\n\n\t*minor_status = 0;\n\tder_mechSet->length = 0;\n\tder_mechSet->value = NULL;\n\t*mechSet = GSS_C_NO_OID_SET;\n\t*req_flags = 0;\n\t*mechtok = *mechListMIC = GSS_C_NO_BUFFER;\n\n\tptr = bufstart = buf->value;\n\tif ((buf->length - (ptr - bufstart)) > INT_MAX)\n\t\treturn GSS_S_FAILURE;\n#define REMAIN (buf->length - (ptr - bufstart))\n\n\terr = g_verify_token_header(gss_mech_spnego,\n\t\t\t\t    &len, &ptr, 0, REMAIN);\n\tif (err) {\n\t\t*minor_status = err;\n\t\tmap_errcode(minor_status);\n\t\treturn GSS_S_FAILURE;\n\t}\n\t*minor_status = g_verify_neg_token_init(&ptr, REMAIN);\n\tif (*minor_status) {\n\t\tmap_errcode(minor_status);\n\t\treturn GSS_S_FAILURE;\n\t}\n\n\t/* alias into input_token */\n\ttmpbuf.value = ptr;\n\ttmpbuf.length = REMAIN;\n\t*mechSet = get_mech_set(minor_status, &ptr, REMAIN);\n\tif (*mechSet == NULL)\n\t\treturn GSS_S_FAILURE;\n\n\ttmpbuf.length = ptr - (unsigned char *)tmpbuf.value;\n\tder_mechSet->value = gssalloc_malloc(tmpbuf.length);\n\tif (der_mechSet->value == NULL)\n\t\treturn GSS_S_FAILURE;\n\tmemcpy(der_mechSet->value, tmpbuf.value, tmpbuf.length);\n\tder_mechSet->length = tmpbuf.length;\n\n\terr = get_req_flags(&ptr, REMAIN, req_flags);\n\tif (err != GSS_S_COMPLETE) {\n\t\treturn err;\n\t}\n\tif (g_get_tag_and_length(&ptr, (CONTEXT | 0x02),\n\t\t\t\t REMAIN, &len) >= 0) {\n\t\t*mechtok = get_input_token(&ptr, len);\n\t\tif (*mechtok == GSS_C_NO_BUFFER) {\n\t\t\treturn GSS_S_FAILURE;\n\t\t}\n\t}\n\tif (g_get_tag_and_length(&ptr, (CONTEXT | 0x03),\n\t\t\t\t REMAIN, &len) >= 0) {\n\t\t*mechListMIC = get_input_token(&ptr, len);\n\t\tif (*mechListMIC == GSS_C_NO_BUFFER) {\n\t\t\treturn GSS_S_FAILURE;\n\t\t}\n\t}\n\treturn GSS_S_COMPLETE;\n#undef REMAIN\n}\n\nstatic OM_uint32\nget_negTokenResp(OM_uint32 *minor_status,\n\t\t unsigned char *buf, unsigned int buflen,\n\t\t OM_uint32 *negState,\n\t\t gss_OID *supportedMech,\n\t\t gss_buffer_t *responseToken,\n\t\t gss_buffer_t *mechListMIC)\n{\n\tunsigned char *ptr, *bufstart;\n\tunsigned int len;\n\tint tmplen;\n\tunsigned int tag, bytes;\n\n\t*negState = ACCEPT_DEFECTIVE_TOKEN;\n\t*supportedMech = GSS_C_NO_OID;\n\t*responseToken = *mechListMIC = GSS_C_NO_BUFFER;\n\tptr = bufstart = buf;\n#define REMAIN (buflen - (ptr - bufstart))\n\n\tif (g_get_tag_and_length(&ptr, (CONTEXT | 0x01), REMAIN, &len) < 0)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tif (*ptr++ == SEQUENCE) {\n\t\ttmplen = gssint_get_der_length(&ptr, REMAIN, &bytes);\n\t\tif (tmplen < 0 || REMAIN < (unsigned int)tmplen)\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tif (REMAIN < 1)\n\t\ttag = 0;\n\telse\n\t\ttag = *ptr++;\n\n\tif (tag == CONTEXT) {\n\t\ttmplen = gssint_get_der_length(&ptr, REMAIN, &bytes);\n\t\tif (tmplen < 0 || REMAIN < (unsigned int)tmplen)\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\t\tif (g_get_tag_and_length(&ptr, ENUMERATED,\n\t\t\t\t\t REMAIN, &len) < 0)\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\t\tif (len != ENUMERATION_LENGTH)\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\t\tif (REMAIN < 1)\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t\t*negState = *ptr++;\n\n\t\tif (REMAIN < 1)\n\t\t\ttag = 0;\n\t\telse\n\t\t\ttag = *ptr++;\n\t}\n\tif (tag == (CONTEXT | 0x01)) {\n\t\ttmplen = gssint_get_der_length(&ptr, REMAIN, &bytes);\n\t\tif (tmplen < 0 || REMAIN < (unsigned int)tmplen)\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\t\t*supportedMech = get_mech_oid(minor_status, &ptr, REMAIN);\n\t\tif (*supportedMech == GSS_C_NO_OID)\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\t\tif (REMAIN < 1)\n\t\t\ttag = 0;\n\t\telse\n\t\t\ttag = *ptr++;\n\t}\n\tif (tag == (CONTEXT | 0x02)) {\n\t\ttmplen = gssint_get_der_length(&ptr, REMAIN, &bytes);\n\t\tif (tmplen < 0 || REMAIN < (unsigned int)tmplen)\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\t\t*responseToken = get_input_token(&ptr, REMAIN);\n\t\tif (*responseToken == GSS_C_NO_BUFFER)\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\t\tif (REMAIN < 1)\n\t\t\ttag = 0;\n\t\telse\n\t\t\ttag = *ptr++;\n\t}\n\tif (tag == (CONTEXT | 0x03)) {\n\t\ttmplen = gssint_get_der_length(&ptr, REMAIN, &bytes);\n\t\tif (tmplen < 0 || REMAIN < (unsigned int)tmplen)\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\t\t*mechListMIC = get_input_token(&ptr, REMAIN);\n\t\tif (*mechListMIC == GSS_C_NO_BUFFER)\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n                /* Handle Windows 2000 duplicate response token */\n                if (*responseToken &&\n                    ((*responseToken)->length == (*mechListMIC)->length) &&\n                    !memcmp((*responseToken)->value, (*mechListMIC)->value,\n                            (*responseToken)->length)) {\n\t\t\tOM_uint32 tmpmin;\n\n\t\t\tgss_release_buffer(&tmpmin, *mechListMIC);\n\t\t\tfree(*mechListMIC);\n\t\t\t*mechListMIC = NULL;\n\t\t}\n\t}\n\treturn GSS_S_COMPLETE;\n#undef REMAIN\n}\n\n/*\n * der encode the passed negResults as an ENUMERATED type and\n * place it in buf_out, advancing the buffer.\n */\n\nstatic int\nput_negResult(unsigned char **buf_out, OM_uint32 negResult,\n\t      unsigned int buflen)\n{\n\tif (buflen < 3)\n\t\treturn (-1);\n\t*(*buf_out)++ = ENUMERATED;\n\t*(*buf_out)++ = ENUMERATION_LENGTH;\n\t*(*buf_out)++ = (unsigned char) negResult;\n\treturn (0);\n}\n\n/*\n * This routine compares the recieved mechset to the mechset that\n * this server can support. It looks sequentially through the mechset\n * and the first one that matches what the server can support is\n * chosen as the negotiated mechanism. If one is found, negResult\n * is set to ACCEPT_INCOMPLETE if it's the first mech, REQUEST_MIC if\n * it's not the first mech, otherwise we return NULL and negResult\n * is set to REJECT. The returned pointer is an alias into\n * received->elements and should not be freed.\n *\n * NOTE: There is currently no way to specify a preference order of\n * mechanisms supported by the acceptor.\n */\nstatic gss_OID\nnegotiate_mech(gss_OID_set supported, gss_OID_set received,\n\t       OM_uint32 *negResult)\n{\n\tsize_t i, j;\n\n\tfor (i = 0; i < received->count; i++) {\n\t\tgss_OID mech_oid = &received->elements[i];\n\n\t\t/* Accept wrong mechanism OID from MS clients */\n\t\tif (g_OID_equal(mech_oid, &gss_mech_krb5_wrong_oid))\n\t\t\tmech_oid = (gss_OID)&gss_mech_krb5_oid;\n\n\t\tfor (j = 0; j < supported->count; j++) {\n\t\t\tif (g_OID_equal(mech_oid, &supported->elements[j])) {\n\t\t\t\t*negResult = (i == 0) ? ACCEPT_INCOMPLETE :\n\t\t\t\t\tREQUEST_MIC;\n\t\t\t\treturn &received->elements[i];\n\t\t\t}\n\t\t}\n\t}\n\t*negResult = REJECT;\n\treturn (NULL);\n}\n\n/*\n * the next two routines make a token buffer suitable for\n * spnego_gss_display_status. These currently take the string\n * in name and place it in the token. Eventually, if\n * spnego_gss_display_status returns valid error messages,\n * these routines will be changes to return the error string.\n */\nstatic spnego_token_t\nmake_spnego_token(const char *name)\n{\n\treturn (spnego_token_t)strdup(name);\n}\n\nstatic gss_buffer_desc\nmake_err_msg(const char *name)\n{\n\tgss_buffer_desc buffer;\n\n\tif (name == NULL) {\n\t\tbuffer.length = 0;\n\t\tbuffer.value = NULL;\n\t} else {\n\t\tbuffer.length = strlen(name)+1;\n\t\tbuffer.value = make_spnego_token(name);\n\t}\n\n\treturn (buffer);\n}\n\n/*\n * Create the client side spnego token passed back to gss_init_sec_context\n * and eventually up to the application program and over to the server.\n *\n * Use DER rules, definite length method per RFC 2478\n */\nstatic int\nmake_spnego_tokenInit_msg(spnego_gss_ctx_id_t spnego_ctx,\n\t\t\t  int negHintsCompat,\n\t\t\t  gss_buffer_t mechListMIC, OM_uint32 req_flags,\n\t\t\t  gss_buffer_t data, send_token_flag sendtoken,\n\t\t\t  gss_buffer_t outbuf)\n{\n\tint ret = 0;\n\tunsigned int tlen, dataLen = 0;\n\tunsigned int negTokenInitSize = 0;\n\tunsigned int negTokenInitSeqSize = 0;\n\tunsigned int negTokenInitContSize = 0;\n\tunsigned int rspTokenSize = 0;\n\tunsigned int mechListTokenSize = 0;\n\tunsigned int micTokenSize = 0;\n\tunsigned char *t;\n\tunsigned char *ptr;\n\n\tif (outbuf == GSS_C_NO_BUFFER)\n\t\treturn (-1);\n\n\toutbuf->length = 0;\n\toutbuf->value = NULL;\n\n\t/* calculate the data length */\n\n\t/*\n\t * 0xa0 [DER LEN] [mechTypes]\n\t */\n\tmechListTokenSize = 1 +\n\t\tgssint_der_length_size(spnego_ctx->DER_mechTypes.length) +\n\t\tspnego_ctx->DER_mechTypes.length;\n\tdataLen += mechListTokenSize;\n\n\t/*\n\t * If a token from gss_init_sec_context exists,\n\t * add the length of the token + the ASN.1 overhead\n\t */\n\tif (data != NULL) {\n\t\t/*\n\t\t * Encoded in final output as:\n\t\t * 0xa2 [DER LEN] 0x04 [DER LEN] [DATA]\n\t\t * -----s--------|--------s2----------\n\t\t */\n\t\trspTokenSize = 1 +\n\t\t\tgssint_der_length_size(data->length) +\n\t\t\tdata->length;\n\t\tdataLen += 1 + gssint_der_length_size(rspTokenSize) +\n\t\t\trspTokenSize;\n\t}\n\n\tif (mechListMIC) {\n\t\t/*\n\t\t * Encoded in final output as:\n\t\t * 0xa3 [DER LEN] 0x04 [DER LEN] [DATA]\n\t\t *\t--s--     -----tlen------------\n\t\t */\n\t\tmicTokenSize = 1 +\n\t\t\tgssint_der_length_size(mechListMIC->length) +\n\t\t\tmechListMIC->length;\n\t\tdataLen += 1 +\n\t\t\tgssint_der_length_size(micTokenSize) +\n\t\t\tmicTokenSize;\n\t}\n\n\t/*\n\t * Add size of DER encoding\n\t * [ SEQUENCE { MechTypeList | ReqFLags | Token | mechListMIC } ]\n\t *   0x30 [DER_LEN] [data]\n\t *\n\t */\n\tnegTokenInitContSize = dataLen;\n\tnegTokenInitSeqSize = 1 + gssint_der_length_size(dataLen) + dataLen;\n\tdataLen = negTokenInitSeqSize;\n\n\t/*\n\t * negTokenInitSize indicates the bytes needed to\n\t * hold the ASN.1 encoding of the entire NegTokenInit\n\t * SEQUENCE.\n\t * 0xa0 [DER_LEN] + data\n\t *\n\t */\n\tnegTokenInitSize = 1 +\n\t\tgssint_der_length_size(negTokenInitSeqSize) +\n\t\tnegTokenInitSeqSize;\n\n\ttlen = g_token_size(gss_mech_spnego, negTokenInitSize);\n\n\tt = (unsigned char *) gssalloc_malloc(tlen);\n\n\tif (t == NULL) {\n\t\treturn (-1);\n\t}\n\n\tptr = t;\n\n\t/* create the message */\n\tif ((ret = g_make_token_header(gss_mech_spnego, negTokenInitSize,\n\t\t\t    &ptr, tlen)))\n\t\tgoto errout;\n\n\t*ptr++ = CONTEXT; /* NegotiationToken identifier */\n\tif ((ret = gssint_put_der_length(negTokenInitSeqSize, &ptr, tlen)))\n\t\tgoto errout;\n\n\t*ptr++ = SEQUENCE;\n\tif ((ret = gssint_put_der_length(negTokenInitContSize, &ptr,\n\t\t\t\t\t tlen - (int)(ptr-t))))\n\t\tgoto errout;\n\n\t*ptr++ = CONTEXT | 0x00; /* MechTypeList identifier */\n\tif ((ret = gssint_put_der_length(spnego_ctx->DER_mechTypes.length,\n\t\t\t\t\t &ptr, tlen - (int)(ptr-t))))\n\t\tgoto errout;\n\n\t/* We already encoded the MechSetList */\n\t(void) memcpy(ptr, spnego_ctx->DER_mechTypes.value,\n\t\t      spnego_ctx->DER_mechTypes.length);\n\n\tptr += spnego_ctx->DER_mechTypes.length;\n\n\tif (data != NULL) {\n\t\t*ptr++ = CONTEXT | 0x02;\n\t\tif ((ret = gssint_put_der_length(rspTokenSize,\n\t\t\t\t&ptr, tlen - (int)(ptr - t))))\n\t\t\tgoto errout;\n\n\t\tif ((ret = put_input_token(&ptr, data,\n\t\t\ttlen - (int)(ptr - t))))\n\t\t\tgoto errout;\n\t}\n\n\tif (mechListMIC != GSS_C_NO_BUFFER) {\n\t\t*ptr++ = CONTEXT | 0x03;\n\t\tif ((ret = gssint_put_der_length(micTokenSize,\n\t\t\t\t&ptr, tlen - (int)(ptr - t))))\n\t\t\tgoto errout;\n\n\t\tif (negHintsCompat) {\n\t\t\tret = put_neg_hints(&ptr, mechListMIC,\n\t\t\t\t\t    tlen - (int)(ptr - t));\n\t\t\tif (ret)\n\t\t\t\tgoto errout;\n\t\t} else if ((ret = put_input_token(&ptr, mechListMIC,\n\t\t\t\ttlen - (int)(ptr - t))))\n\t\t\tgoto errout;\n\t}\n\nerrout:\n\tif (ret != 0) {\n\t\tif (t)\n\t\t\tfree(t);\n\t\tt = NULL;\n\t\ttlen = 0;\n\t}\n\toutbuf->length = tlen;\n\toutbuf->value = (void *) t;\n\n\treturn (ret);\n}\n\n/*\n * create the server side spnego token passed back to\n * gss_accept_sec_context and eventually up to the application program\n * and over to the client.\n */\nstatic int\nmake_spnego_tokenTarg_msg(OM_uint32 status, gss_OID mech_wanted,\n\t\t\t  gss_buffer_t data, gss_buffer_t mechListMIC,\n\t\t\t  send_token_flag sendtoken,\n\t\t\t  gss_buffer_t outbuf)\n{\n\tunsigned int tlen = 0;\n\tunsigned int ret = 0;\n\tunsigned int NegTokenTargSize = 0;\n\tunsigned int NegTokenSize = 0;\n\tunsigned int rspTokenSize = 0;\n\tunsigned int micTokenSize = 0;\n\tunsigned int dataLen = 0;\n\tunsigned char *t;\n\tunsigned char *ptr;\n\n\tif (outbuf == GSS_C_NO_BUFFER)\n\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n\tif (sendtoken == INIT_TOKEN_SEND && mech_wanted == GSS_C_NO_OID)\n\t    return (GSS_S_DEFECTIVE_TOKEN);\n\n\toutbuf->length = 0;\n\toutbuf->value = NULL;\n\n\t/*\n\t * ASN.1 encoding of the negResult\n\t * ENUMERATED type is 3 bytes\n\t *  ENUMERATED TAG, Length, Value,\n\t * Plus 2 bytes for the CONTEXT id and length.\n\t */\n\tdataLen = 5;\n\n\t/*\n\t * calculate data length\n\t *\n\t * If this is the initial token, include length of\n\t * mech_type and the negotiation result fields.\n\t */\n\tif (sendtoken == INIT_TOKEN_SEND) {\n\t\tint mechlistTokenSize;\n\t\t/*\n\t\t * 1 byte for the CONTEXT ID(0xa0),\n\t\t * 1 byte for the OID ID(0x06)\n\t\t * 1 byte for OID Length field\n\t\t * Plus the rest... (OID Length, OID value)\n\t\t */\n\t\tmechlistTokenSize = 3 + mech_wanted->length +\n\t\t\tgssint_der_length_size(mech_wanted->length);\n\n\t\tdataLen += mechlistTokenSize;\n\t}\n\tif (data != NULL && data->length > 0) {\n\t\t/* Length of the inner token */\n\t\trspTokenSize = 1 + gssint_der_length_size(data->length) +\n\t\t\tdata->length;\n\n\t\tdataLen += rspTokenSize;\n\n\t\t/* Length of the outer token */\n\t\tdataLen += 1 + gssint_der_length_size(rspTokenSize);\n\t}\n\tif (mechListMIC != NULL) {\n\n\t\t/* Length of the inner token */\n\t\tmicTokenSize = 1 + gssint_der_length_size(mechListMIC->length) +\n\t\t\tmechListMIC->length;\n\n\t\tdataLen += micTokenSize;\n\n\t\t/* Length of the outer token */\n\t\tdataLen += 1 + gssint_der_length_size(micTokenSize);\n\t}\n\t/*\n\t * Add size of DER encoded:\n\t * NegTokenTarg [ SEQUENCE ] of\n\t *    NegResult[0] ENUMERATED {\n\t *\taccept_completed(0),\n\t *\taccept_incomplete(1),\n\t *\treject(2) }\n\t *    supportedMech [1] MechType OPTIONAL,\n\t *    responseToken [2] OCTET STRING OPTIONAL,\n\t *    mechListMIC   [3] OCTET STRING OPTIONAL\n\t *\n\t * size = data->length + MechListMic + SupportedMech len +\n\t *\tResult Length + ASN.1 overhead\n\t */\n\tNegTokenTargSize = dataLen;\n\tdataLen += 1 + gssint_der_length_size(NegTokenTargSize);\n\n\t/*\n\t * NegotiationToken [ CHOICE ]{\n\t *    negTokenInit  [0]\t NegTokenInit,\n\t *    negTokenTarg  [1]\t NegTokenTarg }\n\t */\n\tNegTokenSize = dataLen;\n\tdataLen += 1 + gssint_der_length_size(NegTokenSize);\n\n\ttlen = dataLen;\n\tt = (unsigned char *) gssalloc_malloc(tlen);\n\n\tif (t == NULL) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto errout;\n\t}\n\n\tptr = t;\n\n\t/*\n\t * Indicate that we are sending CHOICE 1\n\t * (NegTokenTarg)\n\t */\n\t*ptr++ = CONTEXT | 0x01;\n\tif (gssint_put_der_length(NegTokenSize, &ptr, dataLen) < 0) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto errout;\n\t}\n\t*ptr++ = SEQUENCE;\n\tif (gssint_put_der_length(NegTokenTargSize, &ptr,\n\t\t\t\t  tlen - (int)(ptr-t)) < 0) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto errout;\n\t}\n\n\t/*\n\t * First field of the NegTokenTarg SEQUENCE\n\t * is the ENUMERATED NegResult.\n\t */\n\t*ptr++ = CONTEXT;\n\tif (gssint_put_der_length(3, &ptr,\n\t\t\t\t  tlen - (int)(ptr-t)) < 0) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto errout;\n\t}\n\tif (put_negResult(&ptr, status, tlen - (int)(ptr - t)) < 0) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto errout;\n\t}\n\tif (sendtoken == INIT_TOKEN_SEND) {\n\t\t/*\n\t\t * Next, is the Supported MechType\n\t\t */\n\t\t*ptr++ = CONTEXT | 0x01;\n\t\tif (gssint_put_der_length(mech_wanted->length + 2,\n\t\t\t\t\t  &ptr,\n\t\t\t\t\t  tlen - (int)(ptr - t)) < 0) {\n\t\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\t\tgoto errout;\n\t\t}\n\t\tif (put_mech_oid(&ptr, mech_wanted,\n\t\t\t\t tlen - (int)(ptr - t)) < 0) {\n\t\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\tif (data != NULL && data->length > 0) {\n\t\t*ptr++ = CONTEXT | 0x02;\n\t\tif (gssint_put_der_length(rspTokenSize, &ptr,\n\t\t\t\t\t  tlen - (int)(ptr - t)) < 0) {\n\t\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\t\tgoto errout;\n\t\t}\n\t\tif (put_input_token(&ptr, data,\n\t\t\t\t    tlen - (int)(ptr - t)) < 0) {\n\t\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\tif (mechListMIC != NULL) {\n\t\t*ptr++ = CONTEXT | 0x03;\n\t\tif (gssint_put_der_length(micTokenSize, &ptr,\n\t\t\t\t\t  tlen - (int)(ptr - t)) < 0) {\n\t\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\t\tgoto errout;\n\t\t}\n\t\tif (put_input_token(&ptr, mechListMIC,\n\t\t\t\t    tlen - (int)(ptr - t)) < 0) {\n\t\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\tret = GSS_S_COMPLETE;\nerrout:\n\tif (ret != GSS_S_COMPLETE) {\n\t\tif (t)\n\t\t\tfree(t);\n\t} else {\n\t\toutbuf->length = ptr - t;\n\t\toutbuf->value = (void *) t;\n\t}\n\n\treturn (ret);\n}\n\n/* determine size of token */\nstatic int\ng_token_size(gss_OID_const mech, unsigned int body_size)\n{\n\tint hdrsize;\n\n\t/*\n\t * Initialize the header size to the\n\t * MECH_OID byte + the bytes needed to indicate the\n\t * length of the OID + the OID itself.\n\t *\n\t * 0x06 [MECHLENFIELD] MECHDATA\n\t */\n\thdrsize = 1 + gssint_der_length_size(mech->length) + mech->length;\n\n\t/*\n\t * Now add the bytes needed for the initial header\n\t * token bytes:\n\t * 0x60 + [DER_LEN] + HDRSIZE\n\t */\n\thdrsize += 1 + gssint_der_length_size(body_size + hdrsize);\n\n\treturn (hdrsize + body_size);\n}\n\n/*\n * generate token header.\n *\n * Use DER Definite Length method per RFC2478\n * Use of indefinite length encoding will not be compatible\n * with Microsoft or others that actually follow the spec.\n */\nstatic int\ng_make_token_header(gss_OID_const mech,\n\t\t    unsigned int body_size,\n\t\t    unsigned char **buf,\n\t\t    unsigned int totallen)\n{\n\tint ret = 0;\n\tunsigned int hdrsize;\n\tunsigned char *p = *buf;\n\n\thdrsize = 1 + gssint_der_length_size(mech->length) + mech->length;\n\n\t*(*buf)++ = HEADER_ID;\n\tif ((ret = gssint_put_der_length(hdrsize + body_size, buf, totallen)))\n\t\treturn (ret);\n\n\t*(*buf)++ = MECH_OID;\n\tif ((ret = gssint_put_der_length(mech->length, buf,\n\t\t\t    totallen - (int)(p - *buf))))\n\t\treturn (ret);\n\tTWRITE_STR(*buf, mech->elements, mech->length);\n\treturn (0);\n}\n\n/*\n * NOTE: This checks that the length returned by\n * gssint_get_der_length() is not greater than the number of octets\n * remaining, even though gssint_get_der_length() already checks, in\n * theory.\n */\nstatic int\ng_get_tag_and_length(unsigned char **buf, int tag,\n\t\t     unsigned int buflen, unsigned int *outlen)\n{\n\tunsigned char *ptr = *buf;\n\tint ret = -1; /* pessimists, assume failure ! */\n\tunsigned int encoded_len;\n\tint tmplen = 0;\n\n\t*outlen = 0;\n\tif (buflen > 1 && *ptr == tag) {\n\t\tptr++;\n\t\ttmplen = gssint_get_der_length(&ptr, buflen - 1,\n\t\t\t\t\t\t&encoded_len);\n\t\tif (tmplen < 0) {\n\t\t\tret = -1;\n\t\t} else if ((unsigned int)tmplen > buflen - (ptr - *buf)) {\n\t\t\tret = -1;\n\t\t} else\n\t\t\tret = 0;\n\t}\n\t*outlen = tmplen;\n\t*buf = ptr;\n\treturn (ret);\n}\n\nstatic int\ng_verify_neg_token_init(unsigned char **buf_in, unsigned int cur_size)\n{\n\tunsigned char *buf = *buf_in;\n\tunsigned char *endptr = buf + cur_size;\n\tint seqsize;\n\tint ret = 0;\n\tunsigned int bytes;\n\n\t/*\n\t * Verify this is a NegotiationToken type token\n\t * - check for a0(context specific identifier)\n\t * - get length and verify that enoughd ata exists\n\t */\n\tif (g_get_tag_and_length(&buf, CONTEXT, cur_size, &bytes) < 0)\n\t\treturn (G_BAD_TOK_HEADER);\n\n\tcur_size = bytes; /* should indicate bytes remaining */\n\n\t/*\n\t * Verify the next piece, it should identify this as\n\t * a strucure of type NegTokenInit.\n\t */\n\tif (*buf++ == SEQUENCE) {\n\t\tif ((seqsize = gssint_get_der_length(&buf, cur_size, &bytes)) < 0)\n\t\t\treturn (G_BAD_TOK_HEADER);\n\t\t/*\n\t\t * Make sure we have the entire buffer as described\n\t\t */\n\t\tif (seqsize > endptr - buf)\n\t\t\treturn (G_BAD_TOK_HEADER);\n\t} else {\n\t\treturn (G_BAD_TOK_HEADER);\n\t}\n\n\tcur_size = seqsize; /* should indicate bytes remaining */\n\n\t/*\n\t * Verify that the first blob is a sequence of mechTypes\n\t */\n\tif (*buf++ == CONTEXT) {\n\t\tif ((seqsize = gssint_get_der_length(&buf, cur_size, &bytes)) < 0)\n\t\t\treturn (G_BAD_TOK_HEADER);\n\t\t/*\n\t\t * Make sure we have the entire buffer as described\n\t\t */\n\t\tif (seqsize > endptr - buf)\n\t\t\treturn (G_BAD_TOK_HEADER);\n\t} else {\n\t\treturn (G_BAD_TOK_HEADER);\n\t}\n\n\t/*\n\t * At this point, *buf should be at the beginning of the\n\t * DER encoded list of mech types that are to be negotiated.\n\t */\n\t*buf_in = buf;\n\n\treturn (ret);\n\n}\n\n/* verify token header. */\nstatic int\ng_verify_token_header(gss_OID_const mech,\n\t\t    unsigned int *body_size,\n\t\t    unsigned char **buf_in,\n\t\t    int tok_type,\n\t\t    unsigned int toksize)\n{\n\tunsigned char *buf = *buf_in;\n\tint seqsize;\n\tgss_OID_desc toid;\n\tint ret = 0;\n\tunsigned int bytes;\n\n\tif (toksize-- < 1)\n\t\treturn (G_BAD_TOK_HEADER);\n\n\tif (*buf++ != HEADER_ID)\n\t\treturn (G_BAD_TOK_HEADER);\n\n\tif ((seqsize = gssint_get_der_length(&buf, toksize, &bytes)) < 0)\n\t\treturn (G_BAD_TOK_HEADER);\n\n\tif ((seqsize + bytes) != toksize)\n\t\treturn (G_BAD_TOK_HEADER);\n\n\tif (toksize-- < 1)\n\t\treturn (G_BAD_TOK_HEADER);\n\n\n\tif (*buf++ != MECH_OID)\n\t\treturn (G_BAD_TOK_HEADER);\n\n\tif (toksize-- < 1)\n\t\treturn (G_BAD_TOK_HEADER);\n\n\ttoid.length = *buf++;\n\n\tif (toksize < toid.length)\n\t\treturn (G_BAD_TOK_HEADER);\n\telse\n\t\ttoksize -= toid.length;\n\n\ttoid.elements = buf;\n\tbuf += toid.length;\n\n\tif (!g_OID_equal(&toid, mech))\n\t\tret = G_WRONG_MECH;\n\n\t/*\n\t * G_WRONG_MECH is not returned immediately because it's more important\n\t * to return G_BAD_TOK_HEADER if the token header is in fact bad\n\t */\n\tif (toksize < 2)\n\t\treturn (G_BAD_TOK_HEADER);\n\telse\n\t\ttoksize -= 2;\n\n\tif (!ret) {\n\t\t*buf_in = buf;\n\t\t*body_size = toksize;\n\t}\n\n\treturn (ret);\n}\n\n/*\n * Return non-zero if the oid is one of the kerberos mech oids,\n * otherwise return zero.\n *\n * N.B. There are 3 oids that represent the kerberos mech:\n * RFC-specified GSS_MECH_KRB5_OID,\n * Old pre-RFC   GSS_MECH_KRB5_OLD_OID,\n * Incorrect MS  GSS_MECH_KRB5_WRONG_OID\n */\n\nstatic int\nis_kerb_mech(gss_OID oid)\n{\n\tint answer = 0;\n\tOM_uint32 minor;\n\textern const gss_OID_set_desc * const gss_mech_set_krb5_both;\n\n\t(void) gss_test_oid_set_member(&minor,\n\t\toid, (gss_OID_set)gss_mech_set_krb5_both, &answer);\n\n\treturn (answer);\n}\n"], "filenames": ["src/lib/gssapi/spnego/spnego_mech.c"], "buggy_code_start_loc": [821], "buggy_code_end_loc": [822], "fixing_code_start_loc": [820], "fixing_code_end_loc": [820], "type": "CWE-415", "message": "Double free vulnerability in the init_ctx_reselect function in the SPNEGO initiator in lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) 1.10.x through 1.12.x before 1.12.2 allows remote attackers to cause a denial of service (memory corruption) or possibly execute arbitrary code via network traffic that appears to come from an intended acceptor, but specifies a security mechanism different from the one proposed by the initiator.", "other": {"cve": {"id": "CVE-2014-4343", "sourceIdentifier": "cve@mitre.org", "published": "2014-08-14T05:01:49.897", "lastModified": "2020-01-21T15:46:47.197", "vulnStatus": "Modified", "evaluatorComment": "<a href=\"http://cwe.mitre.org/data/definitions/415.html\" target=\"_blank\">CWE-415: Double Free</a>", "descriptions": [{"lang": "en", "value": "Double free vulnerability in the init_ctx_reselect function in the SPNEGO initiator in lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) 1.10.x through 1.12.x before 1.12.2 allows remote attackers to cause a denial of service (memory corruption) or possibly execute arbitrary code via network traffic that appears to come from an intended acceptor, but specifies a security mechanism different from the one proposed by the initiator."}, {"lang": "es", "value": "Vulnerabilidad de doble liberaci\u00f3n en la funci\u00f3n init_ctx_reselect en el iniciador SPNEGO en lib/gssapi/spnego/spnego_mech.c en MIT Kerberos 5 (tambi\u00e9n conocido como krb5) 1.10.x hasta 1.12.x anterior a 1.12.2 permite a atacantes remotos causar una denegaci\u00f3n de servicio (corrupci\u00f3n de memoria) o posiblemente ejecutar c\u00f3digo arbitrario a trav\u00e9s de trafico de la red que parece venir de un aceptador intencionado, pero especifica un mecanismo de seguridad diferente al propuesto por el iniciador."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.6}, "baseSeverity": "HIGH", "exploitabilityScore": 4.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.10:*:*:*:*:*:*:*", "matchCriteriaId": "FC504264-A9E9-4433-B7AA-6D5015A93FF3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "77FA352F-520C-4C05-AD52-FC8586DB16B1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.10.2:*:*:*:*:*:*:*", "matchCriteriaId": "9FFB18F7-CB08-4AE4-9DEC-55D047819A0A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.10.3:*:*:*:*:*:*:*", "matchCriteriaId": "637E858A-7C16-490C-99A8-F46440E5F504"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.10.4:*:*:*:*:*:*:*", "matchCriteriaId": "22840B84-2EA4-4E96-A8D8-154AAEADB806"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.11:*:*:*:*:*:*:*", "matchCriteriaId": "2D554BDC-CD7D-4572-B1E8-5F627F2C5916"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.11.1:*:*:*:*:*:*:*", "matchCriteriaId": "65BCD38A-33AD-4FD7-AF5B-8470B24C4139"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.11.2:*:*:*:*:*:*:*", "matchCriteriaId": "E11F9209-799A-428B-9513-DBD0F19C7BF4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.11.3:*:*:*:*:*:*:*", "matchCriteriaId": "1DA40FAA-B858-4282-8438-247E99FBB002"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.11.4:*:*:*:*:*:*:*", "matchCriteriaId": "65795542-D886-46C4-8ECB-4630078DF66A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.11.5:*:*:*:*:*:*:*", "matchCriteriaId": "D0A4C436-C3D7-469E-8895-8EEC9569EE86"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.12:*:*:*:*:*:*:*", "matchCriteriaId": "79A9FAE9-7219-4D6A-9E94-FFE20223537D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.12.1:*:*:*:*:*:*:*", "matchCriteriaId": "EA68BC90-FCFC-4C9B-8574-9029DB2358E9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_hpc_node:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "3C84489B-B08C-4854-8A12-D01B6E45CF79"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}], "references": [{"url": "http://advisories.mageia.org/MGASA-2014-0345.html", "source": "cve@mitre.org"}, {"url": "http://aix.software.ibm.com/aix/efixes/security/nas_advisory1.asc", "source": "cve@mitre.org"}, {"url": "http://krbdev.mit.edu/rt/Ticket/Display.html?id=7969", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2014-August/136360.html", "source": "cve@mitre.org"}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-0439.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://secunia.com/advisories/59102", "source": "cve@mitre.org"}, {"url": "http://secunia.com/advisories/60082", "source": "cve@mitre.org"}, {"url": "http://secunia.com/advisories/60448", "source": "cve@mitre.org"}, {"url": "http://secunia.com/advisories/61052", "source": "cve@mitre.org"}, {"url": "http://security.gentoo.org/glsa/glsa-201412-53.xml", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://support.f5.com/kb/en-us/solutions/public/15000/500/sol15553.html", "source": "cve@mitre.org"}, {"url": "http://www.debian.org/security/2014/dsa-3000", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.osvdb.org/109390", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/69159", "source": "cve@mitre.org"}, {"url": "http://www.securitytracker.com/id/1030706", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1121876", "source": "cve@mitre.org"}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/95211", "source": "cve@mitre.org"}, {"url": "https://github.com/krb5/krb5/commit/f18ddf5d82de0ab7591a36e465bc24225776940f", "source": "cve@mitre.org", "tags": ["Patch", "Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/krb5/krb5/commit/f18ddf5d82de0ab7591a36e465bc24225776940f"}}