{"buggy_code": ["// Copyright (C) 2012 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage com.google.json;\n\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Random;\n\nimport javax.annotation.Nullable;\n\nimport junit.framework.TestCase;\nimport org.junit.Test;\n\n\n/**\n * Tries a series of pseudo-random variants of a string of JSON to suss out\n * boundary conditions in the JSON parser.\n */\n@SuppressWarnings(\"javadoc\")\npublic final class FuzzyTest extends TestCase {\n  @Test\n  public static final void testSanitizerLikesFuzzyWuzzyInputs()\n  throws Throwable {\n    int nRuns = 10000;\n    long seed;\n    {\n      // Try to fetch a seed from a system property so that we can replay failed\n      // tests.\n      String seedString = System.getProperty(\"fuzz.seed\", null);\n      if (seedString != null) {\n        seed = Long.parseLong(seedString, 16);\n      } else {\n        // Use java.util.Random's default constructor to generate a seed since\n        // it does a pretty good job of making a good non-crypto-strong seed.\n        seed = new Random().nextLong();\n      }\n    }\n\n    // Dump the seed so that failures can be reproduced with only this line\n    // from the test log.\n    System.err.println(\"Fuzzing with -Dfuzz.seed=\" + Long.toHexString(seed));\n    System.err.flush();\n\n    Random rnd = new Random(seed);\n    for (String fuzzyWuzzyString : new FuzzyStringGenerator(rnd)) {\n      try {\n        String sanitized0 = JsonSanitizer.sanitize(fuzzyWuzzyString);\n        String sanitized1 = JsonSanitizer.sanitize(sanitized0);\n        // Test idempotence.\n        assertEquals(fuzzyWuzzyString + \"  =>  \" + sanitized0, sanitized0,\n                     sanitized1);\n      } catch (Throwable th) {\n        System.err.println(\"Failed on `\" + fuzzyWuzzyString + \"`\");\n        hexDump(fuzzyWuzzyString.getBytes(\"UTF16\"), System.err);\n        System.err.println(\"\");\n        throw th;\n      }\n      if (--nRuns <= 0) { break; }\n    }\n  }\n\n\n  private static void hexDump(byte[] bytes, Appendable app)\n    throws IOException {\n    for (int i = 0; i < bytes.length; ++i) {\n      if ((i % 16) == 0) {\n        if (i != 0) {\n          app.append('\\n');\n        }\n      } else {\n        app.append(' ');\n      }\n      byte b = bytes[i];\n      app.append(\"0123456789ABCDEF\".charAt((b >>> 4) & 0xf));\n      app.append(\"0123456789ABCDEF\".charAt((b >>> 0) & 0xf));\n    }\n  }\n}\n\nfinal class FuzzyStringGenerator implements Iterable<String> {\n  final Random rnd;\n\n  FuzzyStringGenerator(Random rnd) {\n    this.rnd = rnd;\n  }\n\n  @Override\n  public Iterator<String> iterator() {\n    return new Iterator<String>() {\n      private @Nullable String basis;\n      private @Nullable String pending;\n      @Override\n      public boolean hasNext() {\n        return true;\n      }\n      @Override\n      public String next() {\n        if (pending == null) {\n          fuzz();\n        }\n        String s = pending;\n        pending = null;\n        if (0 == rnd.nextInt(16)) { basis = null; }\n        return s;\n      }\n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n      @SuppressWarnings(\"synthetic-access\")\n      private void fuzz() {\n        if (basis == null) {\n          pending = basis = makeRandomJson();\n          return;\n        }\n        pending = mutate(basis);\n      }\n    };\n  }\n\n  private String makeRandomJson() {\n    int maxDepth = 1 + rnd.nextInt(8);\n    int maxBreadth = 4 + rnd.nextInt(16);\n    StringBuilder sb = new StringBuilder();\n    appendWhitespace(sb);\n    appendRandomJson(maxDepth, maxBreadth, sb);\n    appendWhitespace(sb);\n    return sb.toString();\n  }\n\n  private static final String[] FLOAT_FORMAT_STRING = {\n    \"%g\", \"%G\", \"%e\", \"%E\", \"%f\"\n  };\n\n  private static final String[] INT_FORMAT_STRING = {\n    \"%x\", \"%X\", \"%d\"\n  };\n\n\n  private void appendRandomJson(\n      int maxDepth, int maxBreadth, StringBuilder sb) {\n    int r = rnd.nextInt(maxDepth > 0 ? 8 : 6);\n\n    switch (r) {\n      case 0: sb.append(\"null\"); break;\n      case 1: sb.append(\"true\"); break;\n      case 2: sb.append(\"false\"); break;\n      case 3: {\n        String fmt = FLOAT_FORMAT_STRING\n          [rnd.nextInt(FLOAT_FORMAT_STRING.length)];\n        sb.append(String.format(Locale.ROOT, fmt, 1.0 / rnd.nextGaussian()));\n        break;\n      }\n      case 4: {\n        switch (rnd.nextInt(3)) {\n          case 0: break;\n          case 1: sb.append('-'); break;\n          case 2: sb.append('+'); break;\n        }\n        String fmt = INT_FORMAT_STRING\n          [rnd.nextInt(INT_FORMAT_STRING.length)];\n        BigInteger num = new BigInteger(randomDecimalDigits(maxBreadth * 2));\n        sb.append(String.format(Locale.ROOT, fmt, num));\n        break;\n      }\n      case 5:\n        appendRandomString(maxBreadth, sb);\n        break;\n      case 6:\n        sb.append('[');\n        appendWhitespace(sb);\n        for (int i = rnd.nextInt(maxBreadth); --i >= 0;) {\n          appendWhitespace(sb);\n          appendRandomJson(maxDepth - 1, Math.max(1, maxBreadth - 1), sb);\n          if (i != 1) {\n            appendWhitespace(sb);\n            sb.append(',');\n          }\n        }\n        appendWhitespace(sb);\n        sb.append(']');\n        break;\n      case 7:\n        sb.append('{');\n        appendWhitespace(sb);\n        for (int i = rnd.nextInt(maxBreadth); --i >= 0;) {\n          appendWhitespace(sb);\n          appendRandomString(maxBreadth, sb);\n          appendWhitespace(sb);\n          sb.append(':');\n          appendWhitespace(sb);\n          appendRandomJson(maxDepth - 1, Math.max(1, maxBreadth - 1), sb);\n          if (i != 1) {\n            appendWhitespace(sb);\n            sb.append(',');\n          }\n        }\n        appendWhitespace(sb);\n        sb.append('}');\n        break;\n    }\n  }\n\n  private void appendRandomString(int maxBreadth, StringBuilder sb) {\n    sb.append('\"');\n    appendRandomChars(rnd.nextInt(maxBreadth * 4), sb);\n    sb.append('\"');\n  }\n\n  private void appendRandomChars(int nChars, StringBuilder sb) {\n    for (int i = nChars; --i >= 0;) {\n      appendRandomChar(sb);\n    }\n  }\n\n  private void appendRandomChar(StringBuilder sb) {\n    char delim = rnd.nextInt(8) == 0 ? '\\'' : '\"';\n    int cpMax;\n    switch (rnd.nextInt(7)) {\n      case 0: case 1: case 2: case 3: cpMax = 0x100; break;\n      case 4: case 5: cpMax = 0x10000; break;\n      default: cpMax = Character.MAX_CODE_POINT; break;\n    }\n    int cp = rnd.nextInt(cpMax);\n    boolean encode = false;\n    if (cp == delim || cp < 0x20 || cp == '\\\\') {\n      encode = true;\n    }\n    if (!encode && 0 == rnd.nextInt(8)) {\n      encode = true;\n    }\n    if (encode) {\n      if (rnd.nextBoolean()) {\n        for (char cu : Character.toChars(cp)) {\n          sb.append(\"\\\\u\").append(String.format(\"%04x\", (int) cu));\n        }\n      } else {\n        sb.append('\\\\');\n        switch (cp) {\n          case 0xa: sb.append('\\n'); break;\n          case 0xd: sb.append('\\r'); break;\n          default: sb.appendCodePoint(cp); break;\n        }\n      }\n    } else {\n      sb.appendCodePoint(cp);\n    }\n  }\n\n  private void appendWhitespace(StringBuilder sb) {\n    if (rnd.nextInt(4) == 0) {\n      for (int i = rnd.nextInt(4); --i >= 0;) {\n        sb.append(\" \\t\\r\\n\".charAt(rnd.nextInt(4)));\n      }\n    }\n  }\n\n  private String randomDecimalDigits(int maxDigits) {\n    int nDigits = Math.max(1, rnd.nextInt(maxDigits));\n    StringBuilder sb = new StringBuilder(nDigits);\n    for (int i = nDigits; --i >= 0;) {\n      sb.append((char) ('0' + rnd.nextInt(10)));\n    }\n    return sb.toString();\n  }\n\n  private String mutate(String s) {\n    int n = rnd.nextInt(16) + 1;  // Number of changes.\n    int len = s.length();\n    // Pick the places where we mutate, so we can sort, de-dupe, and then\n    // derive s' in a left-to-right pass.\n    int[] locations = new int[n];\n    for (int i = n; --i >= 0;) {\n      locations[i] = rnd.nextInt(len);\n    }\n    Arrays.sort(locations);\n\n    // Dedupe.\n    {\n      int k = 1;\n      for (int i = 1; i < n; ++i) {\n        if (locations[i] != locations[i - 1]) {\n          locations[k++] = locations[i];\n        }\n      }\n      n = k;  // Skip any duped ones.\n    }\n\n    // Walk left-to-right and perform modifications.\n    int left = 0;\n    StringBuilder delta = new StringBuilder(len);\n    for (int i = 0; i < n; ++i) {\n      int loc = locations[i];\n      int nextLoc = i + 1 == n ? len : locations[i + 1];\n      int size = nextLoc - loc;\n      int rndSliceLen = 1;\n      if (size > 1) {\n        rndSliceLen = rnd.nextInt(size);\n      }\n\n      delta.append(s, left, loc);\n      left = loc;\n\n      switch (rnd.nextInt(3)) {\n        case 0:  // insert\n          appendRandomChars(rndSliceLen, delta);\n          break;\n        case 1:  // replace\n          appendRandomChars(rndSliceLen, delta);\n          left += rndSliceLen;\n          break;\n        case 2:  // remove\n          left += rndSliceLen;\n          break;\n      }\n    }\n    delta.append(s, left, len);\n    return delta.toString();\n  }\n}\n", "// Copyright (C) 2012 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage com.google.json;\n\nimport static com.google.json.JsonSanitizer.DEFAULT_NESTING_DEPTH;\nimport static com.google.json.JsonSanitizer.sanitize;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport junit.framework.TestCase;\nimport org.junit.Test;\n\n@SuppressWarnings(\"javadoc\")\npublic final class JsonSanitizerTest extends TestCase {\n\n  private static void assertSanitized(String golden, String input) {\n    assertSanitized(golden, input, DEFAULT_NESTING_DEPTH);\n  }\n\n  private static void assertSanitized(String golden, String input, int maximumNestingDepth) {\n    String actual = sanitize(input, maximumNestingDepth);\n    assertEquals(input, golden, actual);\n    if (actual.equals(input)) {\n      assertSame(input, input, actual);\n    }\n  }\n\n  private static void assertSanitized(String sanitary) {\n    assertSanitized(sanitary, sanitary);\n  }\n\n  @Test\n  public static final void testSanitize() {\n    // On the left is the sanitized output, and on the right the input.\n    // If there is a single string, then the input is fine as-is.\n    assertSanitized(\"null\", null);\n    assertSanitized(\"null\", \"\");\n    assertSanitized(\"null\");\n    assertSanitized(\"false\");\n    assertSanitized(\"true\");\n    assertSanitized(\" false \");\n    assertSanitized(\"  false\");\n    assertSanitized(\"false\\n\");\n    assertSanitized(\"false\", \"false,true\");\n    assertSanitized(\"\\\"foo\\\"\");\n    assertSanitized(\"\\\"foo\\\"\", \"'foo'\");\n    assertSanitized(\n        \"\\\"\\\\u003cscript>foo()\\\\u003c/script>\\\"\", \"\\\"<script>foo()</script>\\\"\");\n    assertSanitized(\"\\\"\\\\u003c/SCRIPT\\\\n>\\\"\", \"\\\"</SCRIPT\\n>\\\"\");\n    assertSanitized(\"\\\"\\\\u003c/ScRIpT\\\"\", \"\\\"</ScRIpT\\\"\");\n    // \\u0130 is a Turkish dotted upper-case 'I' so the lower case version of\n    // the tag name is \"script\".\n    assertSanitized(\"\\\"\\\\u003c/ScR\\u0130pT\\\"\", \"\\\"</ScR\\u0130pT\\\"\");\n    assertSanitized(\"\\\"<b>Hello</b>\\\"\");\n    assertSanitized(\"\\\"<s>Hello</s>\\\"\");\n    assertSanitized(\"\\\"<[[\\\\u005d]>\\\"\", \"'<[[]]>'\");\n    assertSanitized(\"\\\"\\\\u005d]>\\\"\", \"']]>'\");\n    assertSanitized(\"[[0]]\", \"[[0]]>\");\n    assertSanitized(\"[1,-1,0.0,-0.5,1e2]\", \"[1,-1,0.0,-0.5,1e2,\");\n    assertSanitized(\"[1,2,3]\", \"[1,2,3,]\");\n    assertSanitized(\"[1,null,3]\", \"[1,,3,]\");\n    assertSanitized(\"[1 ,2 ,3]\", \"[1 2 3]\");\n    assertSanitized(\"{ \\\"foo\\\": \\\"bar\\\" }\");\n    assertSanitized(\"{ \\\"foo\\\": \\\"bar\\\" }\", \"{ \\\"foo\\\": \\\"bar\\\", }\");\n    assertSanitized(\"{\\\"foo\\\":\\\"bar\\\"}\", \"{\\\"foo\\\",\\\"bar\\\"}\");\n    assertSanitized(\"{ \\\"foo\\\": \\\"bar\\\" }\", \"{ foo: \\\"bar\\\" }\");\n    assertSanitized(\"{ \\\"foo\\\": \\\"bar\\\"}\", \"{ foo: 'bar\");\n    assertSanitized(\"{ \\\"foo\\\": [\\\"bar\\\"]}\", \"{ foo: ['bar\");\n    assertSanitized(\"false\", \"// comment\\nfalse\");\n    assertSanitized(\"false\", \"false// comment\");\n    assertSanitized(\"false\", \"false// comment\\n\");\n    assertSanitized(\"false\", \"false/* comment */\");\n    assertSanitized(\"false\", \"false/* comment *\");\n    assertSanitized(\"false\", \"false/* comment \");\n    assertSanitized(\"false\", \"/*/true**/false\");\n    assertSanitized(\"1\");\n    assertSanitized(\"-1\");\n    assertSanitized(\"1.0\");\n    assertSanitized(\"-1.0\");\n    assertSanitized(\"1.05\");\n    assertSanitized(\"427.0953333\");\n    assertSanitized(\"6.0221412927e+23\");\n    assertSanitized(\"6.0221412927e23\");\n    assertSanitized(\"6.0221412927e0\", \"6.0221412927e\");\n    assertSanitized(\"6.0221412927e-0\", \"6.0221412927e-\");\n    assertSanitized(\"6.0221412927e+0\", \"6.0221412927e+\");\n    assertSanitized(\"1.660538920287695E-24\");\n    assertSanitized(\"-6.02e-23\");\n    assertSanitized(\"1.0\", \"1.\");\n    assertSanitized(\"0.5\", \".5\");\n    assertSanitized(\"-0.5\", \"-.5\");\n    assertSanitized(\"0.5\", \"+.5\");\n    assertSanitized(\"0.5e2\", \"+.5e2\");\n    assertSanitized(\"1.5e+2\", \"+1.5e+2\");\n    assertSanitized(\"0.5e-2\", \"+.5e-2\");\n    assertSanitized(\"{\\\"0\\\":0}\", \"{0:0}\");\n    assertSanitized(\"{\\\"0\\\":0}\", \"{-0:0}\");\n    assertSanitized(\"{\\\"0\\\":0}\", \"{+0:0}\");\n    assertSanitized(\"{\\\"1\\\":0}\", \"{1.0:0}\");\n    assertSanitized(\"{\\\"1\\\":0}\", \"{1.:0}\");\n    assertSanitized(\"{\\\"0.5\\\":0}\", \"{.5:0}\");\n    assertSanitized(\"{\\\"-0.5\\\":0}\", \"{-.5:0}\");\n    assertSanitized(\"{\\\"0.5\\\":0}\", \"{+.5:0}\");\n    assertSanitized(\"{\\\"50\\\":0}\", \"{+.5e2:0}\");\n    assertSanitized(\"{\\\"150\\\":0}\", \"{+1.5e+2:0}\");\n    assertSanitized(\"{\\\"0.1\\\":0}\", \"{+.1:0}\");\n    assertSanitized(\"{\\\"0.01\\\":0}\", \"{+.01:0}\");\n    assertSanitized(\"{\\\"0.005\\\":0}\", \"{+.5e-2:0}\");\n    assertSanitized(\"{\\\"1e+101\\\":0}\", \"{10e100:0}\");\n    assertSanitized(\"{\\\"1e-99\\\":0}\", \"{10e-100:0}\");\n    assertSanitized(\"{\\\"1.05e-99\\\":0}\", \"{10.5e-100:0}\");\n    assertSanitized(\"{\\\"1.05e-99\\\":0}\", \"{10.500e-100:0}\");\n    assertSanitized(\"{\\\"1.234e+101\\\":0}\", \"{12.34e100:0}\");\n    assertSanitized(\"{\\\"1.234e-102\\\":0}\", \"{.01234e-100:0}\");\n    assertSanitized(\"{\\\"1.234e-102\\\":0}\", \"{.01234e-100:0}\");\n    assertSanitized(\"{}\");\n    // Remove grouping parentheses.\n    assertSanitized(\"{}\", \"({})\");\n    // Escape code-points and isolated surrogates which are not XML embeddable.\n    assertSanitized(\"\\\"\\\\u0000\\\\u0008\\\\u001f\\\"\", \"'\\u0000\\u0008\\u001f'\");\n    assertSanitized(\"\\\"\\ud800\\udc00\\\\udc00\\\\ud800\\\"\",\n                    \"'\\ud800\\udc00\\udc00\\ud800'\");\n    assertSanitized(\"\\\"\\ufffd\\\\ufffe\\\\uffff\\\"\", \"'\\ufffd\\ufffe\\uffff'\");\n    // These control characters should be elided if they appear outside a string\n    // literal.\n    assertSanitized(\"42\", \"\\uffef\\u000042\\u0008\\ud800\\uffff\\udc00\");\n    assertSanitized(\"null\", \"\\uffef\\u0000\\u0008\\ud800\\uffff\\udc00\");\n    assertSanitized(\"[null]\", \"[,]\");\n    assertSanitized(\"[null]\", \"[null,]\");\n    assertSanitized(\"{\\\"a\\\":0,\\\"false\\\":\\\"x\\\",\\\"\\\":{\\\"\\\":-1}}\",\n                    \"{\\\"a\\\":0,false\\\"x\\\":{\\\"\\\":-1}}\");\n    assertSanitized(\"[true ,false]\", \"[true false]\");\n    assertSanitized(\"[\\\"\\\\u00a0\\\\u1234\\\"]\");\n    assertSanitized(\"{\\\"a\\\\b\\\":\\\"c\\\"}\", \"{a\\\\b\\\"c\");\n    assertSanitized(\"{\\\"a\\\":\\\"b\\\",\\\"c\\\":null}\", \"{\\\"a\\\":\\\"b\\\",\\\"c\\\":\");\n    assertSanitized(\n        \"{\\\"1e0001234567890123456789123456789123456789\\\":0}\",\n        // Exponent way out of representable range in a JS double.\n        \"{1e0001234567890123456789123456789123456789:0}\"\n                    );\n    // Our octal recoder interprets an octal-like literal that includes a digit '8' or '9' as\n    // decimal.\n    assertSanitized(\"-16923547559\", \"-016923547559\");\n  }\n\n  @Test\n  public static final void testIssue3() {\n    // These triggered index out of bounds and assertion errors.\n    assertSanitized(\"[{\\\"\\\":{}}]\", \"[{{},\\u00E4\");\n    assertSanitized(\"[{\\\"\\\":{}}]\", \"[{{\\u00E4\\u00E4},\\u00E4\");\n  }\n\n  @Test\n  public static final void testIssue4() {\n    // Make sure that bare words are quoted.\n    assertSanitized(\"\\\"dev\\\"\", \"dev\");\n    assertSanitized(\"\\\"eval\\\"\", \"eval\");\n    assertSanitized(\"\\\"comment\\\"\", \"comment\");\n    assertSanitized(\"\\\"fasle\\\"\", \"fasle\");\n    assertSanitized(\"\\\"FALSE\\\"\", \"FALSE\");\n    assertSanitized(\"\\\"dev/comment\\\"\", \"dev/comment\");\n    assertSanitized(\"\\\"devcomment\\\"\", \"dev\\\\comment\");\n    assertSanitized(\"\\\"dev\\\\ncomment\\\"\", \"dev\\\\ncomment\");\n    assertSanitized(\"[\\\"dev\\\", \\\"comment\\\"]\", \"[dev\\\\, comment]\");\n  }\n\n  @Test\n  public static final void testMaximumNestingLevel() {\n    String nestedMaps = \"{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}\";\n    String sanitizedNestedMaps = \"{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}\";\n\n    boolean exceptionIfTooMuchNesting = false;\n    try {\n      assertSanitized(sanitizedNestedMaps, nestedMaps, DEFAULT_NESTING_DEPTH);\n    } catch (ArrayIndexOutOfBoundsException e) {\n      Logger.getAnonymousLogger().log(Level.FINEST, \"Expected exception in testing maximum nesting level\", e);\n      exceptionIfTooMuchNesting = true;\n    }\n    assertTrue(\"Expecting failure for too nested JSON\", exceptionIfTooMuchNesting);\n    assertSanitized(sanitizedNestedMaps, nestedMaps, DEFAULT_NESTING_DEPTH + 1);\n  }\n\n  @Test\n  public static final void testMaximumNestingLevelAssignment() {\n    assertEquals(1, new JsonSanitizer(\"\", Integer.MIN_VALUE).getMaximumNestingDepth());\n    assertEquals(JsonSanitizer.MAXIMUM_NESTING_DEPTH, new JsonSanitizer(\"\", Integer.MAX_VALUE).getMaximumNestingDepth());\n  }\n\n  @Test\n  public static final void testClosedArray() {\n    // Discovered by fuzzer with seed -Dfuzz.seed=df3b4778ce54d00a\n    assertSanitized(\"-1742461140214282\", \"\\ufeff-01742461140214282]\");\n  }\n\n  @Test\n  public static final void testIssue13() {\n    assertSanitized(\n        \"[ { \\\"description\\\": \\\"aa##############aa\\\" }, 1 ]\",\n        \"[ { \\\"description\\\": \\\"aa##############aa\\\" }, 1 ]\");\n  }\n\n  @Test\n  public static final void testHtmlParserStateChanges() {\n    assertSanitized(\"\\\"\\\\u003cscript\\\"\", \"\\\"<script\\\"\");\n    assertSanitized(\"\\\"\\\\u003cScript\\\"\", \"\\\"<Script\\\"\");\n    // \\u0130 is a Turkish dotted upper-case 'I' so the lower case version of\n    // the tag name is \"script\".\n    assertSanitized(\"\\\"\\\\u003cScR\\u0130pT\\\"\", \"\\\"<ScR\\u0130pT\\\"\");\n    assertSanitized(\"\\\"\\\\u003cSCRIPT\\\\n>\\\"\", \"\\\"<SCRIPT\\n>\\\"\");\n    assertSanitized(\"\\\"script\\\"\", \"<script\");\n\n    assertSanitized(\"\\\"\\\\u003c!--\\\"\", \"\\\"<!--\\\"\");\n    assertSanitized(\"-0\", \"<!--\");\n\n    assertSanitized(\"\\\"--\\\\u003e\\\"\", \"\\\"-->\\\"\");\n    assertSanitized(\"-0\", \"-->\");\n\n    assertSanitized(\"\\\"\\\\u003c!--\\\\u003cscript>\\\"\", \"\\\"<!--<script>\\\"\");\n  }\n}\n"], "fixing_code": ["// Copyright (C) 2012 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage com.google.json;\n\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Random;\n\nimport javax.annotation.Nullable;\n\nimport junit.framework.TestCase;\nimport org.junit.Test;\n\n\n/**\n * Tries a series of pseudo-random variants of a string of JSON to suss out\n * boundary conditions in the JSON parser.\n */\n@SuppressWarnings(\"javadoc\")\npublic final class FuzzyTest extends TestCase {\n  @Test\n  public static final void testSanitizerLikesFuzzyWuzzyInputs()\n  throws Throwable {\n    int nRuns = 10000;\n    long seed;\n    {\n      // Try to fetch a seed from a system property so that we can replay failed\n      // tests.\n      String seedString = System.getProperty(\"fuzz.seed\", null);\n      if (seedString != null) {\n        seed = Long.parseLong(seedString, 16);\n      } else {\n        // Use java.util.Random's default constructor to generate a seed since\n        // it does a pretty good job of making a good non-crypto-strong seed.\n        seed = new Random().nextLong();\n      }\n    }\n\n    // Dump the seed so that failures can be reproduced with only this line\n    // from the test log.\n    System.err.println(\"Fuzzing with -Dfuzz.seed=\" + Long.toHexString(seed));\n    System.err.flush();\n\n    Random rnd = new Random(seed);\n    for (String fuzzyWuzzyString : new FuzzyStringGenerator(rnd)) {\n      try {\n        String sanitized0 = JsonSanitizer.sanitize(fuzzyWuzzyString);\n        String sanitized1 = JsonSanitizer.sanitize(sanitized0);\n        // Test idempotence.\n        if (!sanitized0.equals(sanitized1)) {\n          int commonPrefixLen = 0;\n          int minLength = Math.min(sanitized0.length(), sanitized1.length());\n          while (commonPrefixLen < minLength) {\n            if (sanitized0.charAt(commonPrefixLen) != sanitized1.charAt(commonPrefixLen)) {\n              break;\n            }\n            ++commonPrefixLen;\n          }\n\n          int right0 = sanitized0.length();\n          int right1 = sanitized1.length();\n          while (right0 > commonPrefixLen && right1 > commonPrefixLen) {\n            if (sanitized0.charAt(right0 - 1) != sanitized1.charAt(right1 - 1)) {\n              break;\n            }\n            --right0;\n            --right1;\n          }\n\n          int commonSuffixLen = sanitized0.length() - right0;\n\n          System.err.println(\"Difference at \" + commonPrefixLen + \" to -\" + commonSuffixLen);\n          System.err.println(\"Before: \" + excerpt(sanitized0, commonPrefixLen, right0));\n          System.err.println(\"After:  \" + excerpt(sanitized0, commonPrefixLen, right1));\n        }\n        assertEquals(fuzzyWuzzyString + \"  =>  \" + sanitized0, sanitized0,\n                     sanitized1);\n      } catch (Throwable th) {\n        System.err.println(\"Failed on `\" + fuzzyWuzzyString + \"`\");\n        hexDump(fuzzyWuzzyString.getBytes(\"UTF16\"), System.err);\n        System.err.println(\"\");\n        throw th;\n      }\n      if (--nRuns <= 0) { break; }\n    }\n  }\n\n\n  private static void hexDump(byte[] bytes, Appendable app)\n    throws IOException {\n    for (int i = 0; i < bytes.length; ++i) {\n      if ((i % 16) == 0) {\n        if (i != 0) {\n          app.append('\\n');\n        }\n      } else {\n        app.append(' ');\n      }\n      byte b = bytes[i];\n      app.append(\"0123456789ABCDEF\".charAt((b >>> 4) & 0xf));\n      app.append(\"0123456789ABCDEF\".charAt((b >>> 0) & 0xf));\n    }\n  }\n\n  private static String excerpt(String s, int left, int right) {\n    int leftIncl = left - 10;\n    boolean ellipseLeft = leftIncl > 0;\n    if (!ellipseLeft) { leftIncl = 0; }\n\n    int rightIncl = right + 10;\n    boolean ellipseRight = s.length() > rightIncl;\n    if (!ellipseRight) {\n      rightIncl = s.length();\n    }\n\n    return s.substring(leftIncl, rightIncl)\n            .replace(\"\\r\", \"\\\\r\")\n            .replace(\"\\n\", \"\\\\n\")\n            .replace(\"\\\\\", \"\\\\\\\\\");\n  }\n}\n\nfinal class FuzzyStringGenerator implements Iterable<String> {\n  final Random rnd;\n\n  FuzzyStringGenerator(Random rnd) {\n    this.rnd = rnd;\n  }\n\n  @Override\n  public Iterator<String> iterator() {\n    return new Iterator<String>() {\n      private @Nullable String basis;\n      private @Nullable String pending;\n      @Override\n      public boolean hasNext() {\n        return true;\n      }\n      @Override\n      public String next() {\n        if (pending == null) {\n          fuzz();\n        }\n        String s = pending;\n        pending = null;\n        if (0 == rnd.nextInt(16)) { basis = null; }\n        return s;\n      }\n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n      @SuppressWarnings(\"synthetic-access\")\n      private void fuzz() {\n        if (basis == null) {\n          pending = basis = makeRandomJson();\n          return;\n        }\n        pending = mutate(basis);\n      }\n    };\n  }\n\n  private String makeRandomJson() {\n    int maxDepth = 1 + rnd.nextInt(8);\n    int maxBreadth = 4 + rnd.nextInt(16);\n    StringBuilder sb = new StringBuilder();\n    appendWhitespace(sb);\n    appendRandomJson(maxDepth, maxBreadth, sb);\n    appendWhitespace(sb);\n    return sb.toString();\n  }\n\n  private static final String[] FLOAT_FORMAT_STRING = {\n    \"%g\", \"%G\", \"%e\", \"%E\", \"%f\"\n  };\n\n  private static final String[] INT_FORMAT_STRING = {\n    \"%x\", \"%X\", \"%d\"\n  };\n\n\n  private void appendRandomJson(\n      int maxDepth, int maxBreadth, StringBuilder sb) {\n    int r = rnd.nextInt(maxDepth > 0 ? 8 : 6);\n\n    switch (r) {\n      case 0: sb.append(\"null\"); break;\n      case 1: sb.append(\"true\"); break;\n      case 2: sb.append(\"false\"); break;\n      case 3: {\n        String fmt = FLOAT_FORMAT_STRING\n          [rnd.nextInt(FLOAT_FORMAT_STRING.length)];\n        sb.append(String.format(Locale.ROOT, fmt, 1.0 / rnd.nextGaussian()));\n        break;\n      }\n      case 4: {\n        switch (rnd.nextInt(3)) {\n          case 0: break;\n          case 1: sb.append('-'); break;\n          case 2: sb.append('+'); break;\n        }\n        String fmt = INT_FORMAT_STRING\n          [rnd.nextInt(INT_FORMAT_STRING.length)];\n        BigInteger num = new BigInteger(randomDecimalDigits(maxBreadth * 2));\n        sb.append(String.format(Locale.ROOT, fmt, num));\n        break;\n      }\n      case 5:\n        appendRandomString(maxBreadth, sb);\n        break;\n      case 6:\n        sb.append('[');\n        appendWhitespace(sb);\n        for (int i = rnd.nextInt(maxBreadth); --i >= 0;) {\n          appendWhitespace(sb);\n          appendRandomJson(maxDepth - 1, Math.max(1, maxBreadth - 1), sb);\n          if (i != 1) {\n            appendWhitespace(sb);\n            sb.append(',');\n          }\n        }\n        appendWhitespace(sb);\n        sb.append(']');\n        break;\n      case 7:\n        sb.append('{');\n        appendWhitespace(sb);\n        for (int i = rnd.nextInt(maxBreadth); --i >= 0;) {\n          appendWhitespace(sb);\n          appendRandomString(maxBreadth, sb);\n          appendWhitespace(sb);\n          sb.append(':');\n          appendWhitespace(sb);\n          appendRandomJson(maxDepth - 1, Math.max(1, maxBreadth - 1), sb);\n          if (i != 1) {\n            appendWhitespace(sb);\n            sb.append(',');\n          }\n        }\n        appendWhitespace(sb);\n        sb.append('}');\n        break;\n    }\n  }\n\n  private void appendRandomString(int maxBreadth, StringBuilder sb) {\n    sb.append('\"');\n    appendRandomChars(rnd.nextInt(maxBreadth * 4), sb);\n    sb.append('\"');\n  }\n\n  private void appendRandomChars(int nChars, StringBuilder sb) {\n    for (int i = nChars; --i >= 0;) {\n      appendRandomChar(sb);\n    }\n  }\n\n  private void appendRandomChar(StringBuilder sb) {\n    char delim = rnd.nextInt(8) == 0 ? '\\'' : '\"';\n    int cpMax;\n    switch (rnd.nextInt(7)) {\n      case 0: case 1: case 2: case 3: cpMax = 0x100; break;\n      case 4: case 5: cpMax = 0x10000; break;\n      default: cpMax = Character.MAX_CODE_POINT; break;\n    }\n    int cp = rnd.nextInt(cpMax);\n    boolean encode = false;\n    if (cp == delim || cp < 0x20 || cp == '\\\\') {\n      encode = true;\n    }\n    if (!encode && 0 == rnd.nextInt(8)) {\n      encode = true;\n    }\n    if (encode) {\n      if (rnd.nextBoolean()) {\n        for (char cu : Character.toChars(cp)) {\n          sb.append(\"\\\\u\").append(String.format(\"%04x\", (int) cu));\n        }\n      } else {\n        sb.append('\\\\');\n        switch (cp) {\n          case 0xa: sb.append('\\n'); break;\n          case 0xd: sb.append('\\r'); break;\n          default: sb.appendCodePoint(cp); break;\n        }\n      }\n    } else {\n      sb.appendCodePoint(cp);\n    }\n  }\n\n  private void appendWhitespace(StringBuilder sb) {\n    if (rnd.nextInt(4) == 0) {\n      for (int i = rnd.nextInt(4); --i >= 0;) {\n        sb.append(\" \\t\\r\\n\".charAt(rnd.nextInt(4)));\n      }\n    }\n  }\n\n  private String randomDecimalDigits(int maxDigits) {\n    int nDigits = Math.max(1, rnd.nextInt(maxDigits));\n    StringBuilder sb = new StringBuilder(nDigits);\n    for (int i = nDigits; --i >= 0;) {\n      sb.append((char) ('0' + rnd.nextInt(10)));\n    }\n    return sb.toString();\n  }\n\n  private String mutate(String s) {\n    int n = rnd.nextInt(16) + 1;  // Number of changes.\n    int len = s.length();\n    // Pick the places where we mutate, so we can sort, de-dupe, and then\n    // derive s' in a left-to-right pass.\n    int[] locations = new int[n];\n    for (int i = n; --i >= 0;) {\n      locations[i] = rnd.nextInt(len);\n    }\n    Arrays.sort(locations);\n\n    // Dedupe.\n    {\n      int k = 1;\n      for (int i = 1; i < n; ++i) {\n        if (locations[i] != locations[i - 1]) {\n          locations[k++] = locations[i];\n        }\n      }\n      n = k;  // Skip any duped ones.\n    }\n\n    // Walk left-to-right and perform modifications.\n    int left = 0;\n    StringBuilder delta = new StringBuilder(len);\n    for (int i = 0; i < n; ++i) {\n      int loc = locations[i];\n      int nextLoc = i + 1 == n ? len : locations[i + 1];\n      int size = nextLoc - loc;\n      int rndSliceLen = 1;\n      if (size > 1) {\n        rndSliceLen = rnd.nextInt(size);\n      }\n\n      delta.append(s, left, loc);\n      left = loc;\n\n      switch (rnd.nextInt(3)) {\n        case 0:  // insert\n          appendRandomChars(rndSliceLen, delta);\n          break;\n        case 1:  // replace\n          appendRandomChars(rndSliceLen, delta);\n          left += rndSliceLen;\n          break;\n        case 2:  // remove\n          left += rndSliceLen;\n          break;\n      }\n    }\n    delta.append(s, left, len);\n    return delta.toString();\n  }\n}\n", "// Copyright (C) 2012 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage com.google.json;\n\nimport static com.google.json.JsonSanitizer.DEFAULT_NESTING_DEPTH;\nimport static com.google.json.JsonSanitizer.sanitize;\n\nimport java.util.Locale;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport junit.framework.TestCase;\nimport org.junit.Test;\n\n@SuppressWarnings(\"javadoc\")\npublic final class JsonSanitizerTest extends TestCase {\n\n  private static void assertSanitized(String golden, String input) {\n    assertSanitized(golden, input, DEFAULT_NESTING_DEPTH);\n  }\n\n  private static void assertSanitized(String golden, String input, int maximumNestingDepth) {\n    String actual = sanitize(input, maximumNestingDepth);\n    assertEquals(input, golden, actual);\n    if (actual.equals(input)) {\n      assertSame(input, input, actual);\n    }\n  }\n\n  private static void assertSanitized(String sanitary) {\n    assertSanitized(sanitary, sanitary);\n  }\n\n  @Test\n  public static final void testSanitize() {\n    // On the left is the sanitized output, and on the right the input.\n    // If there is a single string, then the input is fine as-is.\n    assertSanitized(\"null\", null);\n    assertSanitized(\"null\", \"\");\n    assertSanitized(\"null\");\n    assertSanitized(\"false\");\n    assertSanitized(\"true\");\n    assertSanitized(\" false \");\n    assertSanitized(\"  false\");\n    assertSanitized(\"false\\n\");\n    assertSanitized(\"false\", \"false,true\");\n    assertSanitized(\"\\\"foo\\\"\");\n    assertSanitized(\"\\\"foo\\\"\", \"'foo'\");\n    assertSanitized(\n        \"\\\"\\\\u003cscript>foo()\\\\u003c/script>\\\"\", \"\\\"<script>foo()</script>\\\"\");\n    assertSanitized(\"\\\"\\\\u003c/SCRIPT\\\\n>\\\"\", \"\\\"</SCRIPT\\n>\\\"\");\n    assertSanitized(\"\\\"\\\\u003c/ScRIpT\\\"\", \"\\\"</ScRIpT\\\"\");\n    // \\u0130 is a Turkish dotted upper-case 'I' so the lower case version of\n    // the tag name is \"script\".\n    assertSanitized(\"\\\"\\\\u003c/ScR\\u0130pT\\\"\", \"\\\"</ScR\\u0130pT\\\"\");\n    assertSanitized(\"\\\"<b>Hello</b>\\\"\");\n    assertSanitized(\"\\\"<s>Hello</s>\\\"\");\n    assertSanitized(\"\\\"<[[\\\\u005d]>\\\"\", \"'<[[]]>'\");\n    assertSanitized(\"\\\"\\\\u005d]>\\\"\", \"']]>'\");\n    assertSanitized(\"[[0]]\", \"[[0]]>\");\n    assertSanitized(\"[1,-1,0.0,-0.5,1e2]\", \"[1,-1,0.0,-0.5,1e2,\");\n    assertSanitized(\"[1,2,3]\", \"[1,2,3,]\");\n    assertSanitized(\"[1,null,3]\", \"[1,,3,]\");\n    assertSanitized(\"[1 ,2 ,3]\", \"[1 2 3]\");\n    assertSanitized(\"{ \\\"foo\\\": \\\"bar\\\" }\");\n    assertSanitized(\"{ \\\"foo\\\": \\\"bar\\\" }\", \"{ \\\"foo\\\": \\\"bar\\\", }\");\n    assertSanitized(\"{\\\"foo\\\":\\\"bar\\\"}\", \"{\\\"foo\\\",\\\"bar\\\"}\");\n    assertSanitized(\"{ \\\"foo\\\": \\\"bar\\\" }\", \"{ foo: \\\"bar\\\" }\");\n    assertSanitized(\"{ \\\"foo\\\": \\\"bar\\\"}\", \"{ foo: 'bar\");\n    assertSanitized(\"{ \\\"foo\\\": [\\\"bar\\\"]}\", \"{ foo: ['bar\");\n    assertSanitized(\"false\", \"// comment\\nfalse\");\n    assertSanitized(\"false\", \"false// comment\");\n    assertSanitized(\"false\", \"false// comment\\n\");\n    assertSanitized(\"false\", \"false/* comment */\");\n    assertSanitized(\"false\", \"false/* comment *\");\n    assertSanitized(\"false\", \"false/* comment \");\n    assertSanitized(\"false\", \"/*/true**/false\");\n    assertSanitized(\"1\");\n    assertSanitized(\"-1\");\n    assertSanitized(\"1.0\");\n    assertSanitized(\"-1.0\");\n    assertSanitized(\"1.05\");\n    assertSanitized(\"427.0953333\");\n    assertSanitized(\"6.0221412927e+23\");\n    assertSanitized(\"6.0221412927e23\");\n    assertSanitized(\"6.0221412927e0\", \"6.0221412927e\");\n    assertSanitized(\"6.0221412927e-0\", \"6.0221412927e-\");\n    assertSanitized(\"6.0221412927e+0\", \"6.0221412927e+\");\n    assertSanitized(\"1.660538920287695E-24\");\n    assertSanitized(\"-6.02e-23\");\n    assertSanitized(\"1.0\", \"1.\");\n    assertSanitized(\"0.5\", \".5\");\n    assertSanitized(\"-0.5\", \"-.5\");\n    assertSanitized(\"0.5\", \"+.5\");\n    assertSanitized(\"0.5e2\", \"+.5e2\");\n    assertSanitized(\"1.5e+2\", \"+1.5e+2\");\n    assertSanitized(\"0.5e-2\", \"+.5e-2\");\n    assertSanitized(\"{\\\"0\\\":0}\", \"{0:0}\");\n    assertSanitized(\"{\\\"0\\\":0}\", \"{-0:0}\");\n    assertSanitized(\"{\\\"0\\\":0}\", \"{+0:0}\");\n    assertSanitized(\"{\\\"1\\\":0}\", \"{1.0:0}\");\n    assertSanitized(\"{\\\"1\\\":0}\", \"{1.:0}\");\n    assertSanitized(\"{\\\"0.5\\\":0}\", \"{.5:0}\");\n    assertSanitized(\"{\\\"-0.5\\\":0}\", \"{-.5:0}\");\n    assertSanitized(\"{\\\"0.5\\\":0}\", \"{+.5:0}\");\n    assertSanitized(\"{\\\"50\\\":0}\", \"{+.5e2:0}\");\n    assertSanitized(\"{\\\"150\\\":0}\", \"{+1.5e+2:0}\");\n    assertSanitized(\"{\\\"0.1\\\":0}\", \"{+.1:0}\");\n    assertSanitized(\"{\\\"0.01\\\":0}\", \"{+.01:0}\");\n    assertSanitized(\"{\\\"0.005\\\":0}\", \"{+.5e-2:0}\");\n    assertSanitized(\"{\\\"1e+101\\\":0}\", \"{10e100:0}\");\n    assertSanitized(\"{\\\"1e-99\\\":0}\", \"{10e-100:0}\");\n    assertSanitized(\"{\\\"1.05e-99\\\":0}\", \"{10.5e-100:0}\");\n    assertSanitized(\"{\\\"1.05e-99\\\":0}\", \"{10.500e-100:0}\");\n    assertSanitized(\"{\\\"1.234e+101\\\":0}\", \"{12.34e100:0}\");\n    assertSanitized(\"{\\\"1.234e-102\\\":0}\", \"{.01234e-100:0}\");\n    assertSanitized(\"{\\\"1.234e-102\\\":0}\", \"{.01234e-100:0}\");\n    assertSanitized(\"{}\");\n    // Remove grouping parentheses.\n    assertSanitized(\"{}\", \"({})\");\n    // Escape code-points and isolated surrogates which are not XML embeddable.\n    assertSanitized(\"\\\"\\\\u0000\\\\u0008\\\\u001f\\\"\", \"'\\u0000\\u0008\\u001f'\");\n    assertSanitized(\"\\\"\\ud800\\udc00\\\\udc00\\\\ud800\\\"\",\n                    \"'\\ud800\\udc00\\udc00\\ud800'\");\n    assertSanitized(\"\\\"\\ufffd\\\\ufffe\\\\uffff\\\"\", \"'\\ufffd\\ufffe\\uffff'\");\n    // These control characters should be elided if they appear outside a string\n    // literal.\n    assertSanitized(\"42\", \"\\uffef\\u000042\\u0008\\ud800\\uffff\\udc00\");\n    assertSanitized(\"null\", \"\\uffef\\u0000\\u0008\\ud800\\uffff\\udc00\");\n    assertSanitized(\"[null]\", \"[,]\");\n    assertSanitized(\"[null]\", \"[null,]\");\n    assertSanitized(\"{\\\"a\\\":0,\\\"false\\\":\\\"x\\\",\\\"\\\":{\\\"\\\":-1}}\",\n                    \"{\\\"a\\\":0,false\\\"x\\\":{\\\"\\\":-1}}\");\n    assertSanitized(\"[true ,false]\", \"[true false]\");\n    assertSanitized(\"[\\\"\\\\u00a0\\\\u1234\\\"]\");\n    assertSanitized(\"{\\\"a\\\\b\\\":\\\"c\\\"}\", \"{a\\\\b\\\"c\");\n    assertSanitized(\"{\\\"a\\\":\\\"b\\\",\\\"c\\\":null}\", \"{\\\"a\\\":\\\"b\\\",\\\"c\\\":\");\n    assertSanitized(\n        \"{\\\"1e0001234567890123456789123456789123456789\\\":0}\",\n        // Exponent way out of representable range in a JS double.\n        \"{1e0001234567890123456789123456789123456789:0}\"\n                    );\n    // Our octal recoder interprets an octal-like literal that includes a digit '8' or '9' as\n    // decimal.\n    assertSanitized(\"-16923547559\", \"-016923547559\");\n  }\n\n  @Test\n  public static final void testIssue3() {\n    // These triggered index out of bounds and assertion errors.\n    assertSanitized(\"[{\\\"\\\":{}}]\", \"[{{},\\u00E4\");\n    assertSanitized(\"[{\\\"\\\":{}}]\", \"[{{\\u00E4\\u00E4},\\u00E4\");\n  }\n\n  @Test\n  public static final void testIssue4() {\n    // Make sure that bare words are quoted.\n    assertSanitized(\"\\\"dev\\\"\", \"dev\");\n    assertSanitized(\"\\\"eval\\\"\", \"eval\");\n    assertSanitized(\"\\\"comment\\\"\", \"comment\");\n    assertSanitized(\"\\\"fasle\\\"\", \"fasle\");\n    assertSanitized(\"\\\"FALSE\\\"\", \"FALSE\");\n    assertSanitized(\"\\\"dev/comment\\\"\", \"dev/comment\");\n    assertSanitized(\"\\\"devcomment\\\"\", \"dev\\\\comment\");\n    assertSanitized(\"\\\"dev\\\\ncomment\\\"\", \"dev\\\\ncomment\");\n    assertSanitized(\"[\\\"dev\\\", \\\"comment\\\"]\", \"[dev\\\\, comment]\");\n  }\n\n  @Test\n  public static final void testMaximumNestingLevel() {\n    String nestedMaps = \"{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}\";\n    String sanitizedNestedMaps = \"{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}\";\n\n    boolean exceptionIfTooMuchNesting = false;\n    try {\n      assertSanitized(sanitizedNestedMaps, nestedMaps, DEFAULT_NESTING_DEPTH);\n    } catch (ArrayIndexOutOfBoundsException e) {\n      Logger.getAnonymousLogger().log(Level.FINEST, \"Expected exception in testing maximum nesting level\", e);\n      exceptionIfTooMuchNesting = true;\n    }\n    assertTrue(\"Expecting failure for too nested JSON\", exceptionIfTooMuchNesting);\n    assertSanitized(sanitizedNestedMaps, nestedMaps, DEFAULT_NESTING_DEPTH + 1);\n  }\n\n  @Test\n  public static final void testMaximumNestingLevelAssignment() {\n    assertEquals(1, new JsonSanitizer(\"\", Integer.MIN_VALUE).getMaximumNestingDepth());\n    assertEquals(JsonSanitizer.MAXIMUM_NESTING_DEPTH, new JsonSanitizer(\"\", Integer.MAX_VALUE).getMaximumNestingDepth());\n  }\n\n  @Test\n  public static final void testUnopenedArray() {\n    // Discovered by fuzzer with seed -Dfuzz.seed=df3b4778ce54d00a\n    assertSanitized(\"-1742461140214282\", \"\\ufeff-01742461140214282]\");\n  }\n\n  @Test\n  public static final void testIssue13() {\n    assertSanitized(\n        \"[ { \\\"description\\\": \\\"aa##############aa\\\" }, 1 ]\",\n        \"[ { \\\"description\\\": \\\"aa##############aa\\\" }, 1 ]\");\n  }\n\n  @Test\n  public static final void testHtmlParserStateChanges() {\n    assertSanitized(\"\\\"\\\\u003cscript\\\"\", \"\\\"<script\\\"\");\n    assertSanitized(\"\\\"\\\\u003cScript\\\"\", \"\\\"<Script\\\"\");\n    // \\u0130 is a Turkish dotted upper-case 'I' so the lower case version of\n    // the tag name is \"script\".\n    assertSanitized(\"\\\"\\\\u003cScR\\u0130pT\\\"\", \"\\\"<ScR\\u0130pT\\\"\");\n    assertSanitized(\"\\\"\\\\u003cSCRIPT\\\\n>\\\"\", \"\\\"<SCRIPT\\n>\\\"\");\n    assertSanitized(\"\\\"script\\\"\", \"<script\");\n\n    assertSanitized(\"\\\"\\\\u003c!--\\\"\", \"\\\"<!--\\\"\");\n    assertSanitized(\"-0\", \"<!--\");\n\n    assertSanitized(\"\\\"--\\\\u003e\\\"\", \"\\\"-->\\\"\");\n    assertSanitized(\"-0\", \"-->\");\n\n    assertSanitized(\"\\\"\\\\u003c!--\\\\u003cscript>\\\"\", \"\\\"<!--<script>\\\"\");\n  }\n\n  @Test\n  public static final void testLongOctalNumberWithBadDigits() {\n    // Found by Fabian Meumertzheim using CI Fuzz (https://www.code-intelligence.com)\n    assertEquals(\n            \"-888888888888888888888\",\n            JsonSanitizer.sanitize(\"-0888888888888888888888\")\n    );\n  }\n\n  @Test\n  public static final void testLongNumberInUnclosedInputWithU80() {\n    // Found by Fabian Meumertzheim using CI Fuzz (https://www.code-intelligence.com)\n    assertEquals(\n            \"{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"x80\\\":{\\\"\\\":{\\\"\\\":[-400557869725698078427]}}}}}}}}}\",\n            JsonSanitizer.sanitize(\"{{{{{{{\\\\x80{{([-053333333304233333333333\")\n    );\n  }\n\n  @Test\n  public static final void testSlashFour() {\n    // Found by Fabian Meumertzheim using CI Fuzz (https://www.code-intelligence.com)\n    assertEquals(\"\\\"y\\\\u0004\\\"\", JsonSanitizer.sanitize(\"y\\\\4\")); // \"y\\4\"\n  }\n\n  @Test\n  public static final void testUnterminatedObject() {\n    // Found by Fabian Meumertzheim using CI Fuzz (https://www.code-intelligence.com)\n    String input = \"?\\u0000\\u0000\\u0000{{\\u0000\\ufffd\\u0003]ve{R]\\u00000\\ufffd\\u0016&e{\\u0003]\\ufffda<!.b<!<!cc1x\\u0000\\u00005{281<\\u0000.{t\\u0001\\ufffd5\\ufffd{5\\ufffd\\ufffd0\\ufffd15\\r\\ufffd\\u0000\\u0000\\u0000~~-0081273222428822883223759,55\\ufffd\\u0000\\ufffd\\t\\u0000\\ufffd\";\n    String got = JsonSanitizer.sanitize(input);\n    String want = \"{\\\"\\\":{},\\\"ve\\\":{\\\"R\\\":null},\\\"0\\\":\\\"e\\\",\\\"\\\":{},\\\"a<!.b<!<!cc1x\\\":5,\\\"\\\":{\\\"281\\\":0.0,\\\"\\\":{\\\"t\\\":5,\\\"\\\":{\\\"5\\\":0,\\\"15\\\"\\r:-81273222428822883223759,\\\"55\\\"\\t:null}}}}\";\n    assertEquals(want, got);\n  }\n\n  @Test\n  public static final void testCrash1() {\n    // Found by Fabian Meumertzheim using CI Fuzz (https://www.code-intelligence.com)\n    String input = \"?\\u0000\\u0000\\u0000{{\\u0000\\ufffd\\u0003]ve{R]\\u00000\\ufffd\\ufffd\\u0016&e{\\u0003]\\ufffda<!.b<!<!c\\u00005{281<\\u0000.{t\\u0001\\ufffd5\\ufffd{515\\r[\\u0000\\u0000\\u0000~~-008127322242\\ufffd\\ufffd\\ufffd\\ufffd\\ufffd\\ufffd\\ufffd\\ufffd23759,551x\\u0000\\u00006{281<\\u0000.{t\\u0001\\ufffd5\\ufffd{5\\ufffd\\ufffd0\\ufffd15\\r[\\u0000\\u0000\\u0000~~-0081273222428822883223759,\\ufffd\";\n    String want = \"{\\\"\\\":{},\\\"ve\\\":{\\\"R\\\":null},\\\"0\\\":\\\"e\\\",\\\"\\\":{},\\\"a<!.b<!<!c\\\":5,\\\"\\\":{\\\"281\\\":0.0,\\\"\\\":{\\\"t\\\":5,\\\"\\\":{\\\"515\\\"\\r:[-8127322242,23759,551,6,{\\\"281\\\":0.0,\\\"\\\":{\\\"t\\\":5,\\\"\\\":{\\\"5\\\":0,\\\"15\\\"\\r:[-81273222428822883223759]}}}]}}}}\";\n    String got = JsonSanitizer.sanitize(input);\n    assertEquals(want, got);\n  }\n\n  @Test\n  public static final void testDisallowedSubstrings() {\n    // Found by Fabian Meumertzheim using CI Fuzz (https://www.code-intelligence.com)\n    String[] inputs = {\n            \"x<\\\\script>\",\n            \"x</\\\\script>\",\n            \"x</sc\\\\ript>\",\n            \"x<\\\\163cript>\",\n            \"x</\\\\163cript>\",\n            \"x<\\\\123cript>\",\n            \"x</\\\\123cript>\",\n            \"u\\\\u\\\\uu\\ufffd\\ufffd\\\\u7u\\\\u\\\\u\\\\u\\ufffdu<\\\\script>5\",\n            \"z\\\\<\\\\!--\",\n            \"z\\\\<!\\\\--\",\n            \"z\\\\<!-\\\\-\",\n            \"z\\\\<\\\\!--\",\n            \"\\\"\\\\]]\\\\>\",\n    };\n    for (String input : inputs) {\n      String out = JsonSanitizer.sanitize(input).toLowerCase(Locale.ROOT);\n      assertFalse(out, out.contains(\"<!--\"));\n      assertFalse(out, out.contains(\"-->\"));\n      assertFalse(out, out.contains(\"<script\"));\n      assertFalse(out, out.contains(\"</script\"));\n      assertFalse(out, out.contains(\"]]>\"));\n      assertFalse(out, out.contains(\"<![cdata[\"));\n    }\n  }\n\n  @Test\n  public static final void testXssPayload() {\n    // Found by Fabian Meumertzheim using CI Fuzz (https://www.code-intelligence.com)\n    String input = \"x</\\\\script>u\\\\u\\\\uu\\ufffd\\ufffd\\\\u7u\\\\u\\\\u\\\\u\\ufffdu<\\\\script>5+alert(1)//\";\n    assertEquals(\n            \"\\\"x\\\\u003c/script>uuuu\\uFFFD\\uFFFDu7uuuu\\uFFFDu\\\\u003cscript>5+alert(1)//\\\"\",\n            JsonSanitizer.sanitize(input)\n    );\n  }\n\n  @Test\n  public static final void testInvalidOutput() {\n    // Found by Fabian Meumertzheim using CI Fuzz (https://www.code-intelligence.com)\n    String input = \"\\u0010{'\\u0000\\u0000'\\\"\\u0000\\\"{.\\ufffd-0X29295909049550970,\\n\\n0\";\n    String want = \"{\\\"\\\\u0000\\\\u0000\\\":\\\"\\\\u0000\\\",\\\"\\\":{\\\"0\\\":-47455995597866469744,\\n\\n\\\"0\\\":null}}\";\n    String got = JsonSanitizer.sanitize(input);\n    assertEquals(want, got);\n  }\n\n  @Test\n  public static final void testBadNumber() {\n    String input = \"\u00b60x.\\\\\u8e434\\\\\u00c0906\";\n    String want = \"0.0\";\n    String got = JsonSanitizer.sanitize(input);\n    assertEquals(want, got);\n  }\n}\n"], "filenames": ["src/test/java/com/google/json/FuzzyTest.java", "src/test/java/com/google/json/JsonSanitizerTest.java"], "buggy_code_start_loc": [64, 18], "buggy_code_end_loc": [91, 230], "fixing_code_start_loc": [65, 19], "fixing_code_end_loc": [135, 331], "type": "NVD-CWE-noinfo", "message": "OWASP json-sanitizer before 1.2.2 can output invalid JSON or throw an undeclared exception for crafted input. This may lead to denial of service if the application is not prepared to handle these situations.", "other": {"cve": {"id": "CVE-2021-23900", "sourceIdentifier": "cve@mitre.org", "published": "2021-01-13T16:15:14.490", "lastModified": "2021-01-19T19:00:48.250", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OWASP json-sanitizer before 1.2.2 can output invalid JSON or throw an undeclared exception for crafted input. This may lead to denial of service if the application is not prepared to handle these situations."}, {"lang": "es", "value": "OWASP json-sanitizer versiones anteriores a  1.2.2, puede generar JSON no v\u00e1lido o lanzar una excepci\u00f3n no declarada para una entrada dise\u00f1ada.&#xa0;Esto puede conllevar a una denegaci\u00f3n del servicio si la aplicaci\u00f3n no est\u00e1 preparada para manejar estas situaciones."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:owasp:json-sanitizer:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.2", "matchCriteriaId": "C22C77CE-0FF1-474E-B921-438980F66C82"}]}]}], "references": [{"url": "https://github.com/OWASP/json-sanitizer/commit/a37f594f7378a1c76b3283e0dab9e1ab1dc0247e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/OWASP/json-sanitizer/compare/v1.2.1...v1.2.2", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://groups.google.com/g/json-sanitizer-support/c/dAW1AeNMoA0", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/OWASP/json-sanitizer/commit/a37f594f7378a1c76b3283e0dab9e1ab1dc0247e"}}