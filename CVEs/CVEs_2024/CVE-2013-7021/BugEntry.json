{"buggy_code": ["/*\n * Copyright 2007 Bobby Bingham\n * Copyright 2012 Robert Nagy <ronag89 gmail com>\n * Copyright 2012 Anton Khirnov <anton khirnov net>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * a filter enforcing given constant framerate\n */\n\n#include <float.h>\n\n#include \"libavutil/common.h\"\n#include \"libavutil/fifo.h\"\n#include \"libavutil/mathematics.h\"\n#include \"libavutil/opt.h\"\n#include \"libavutil/parseutils.h\"\n\n#include \"avfilter.h\"\n#include \"internal.h\"\n#include \"video.h\"\n\ntypedef struct FPSContext {\n    const AVClass *class;\n\n    AVFifoBuffer *fifo;     ///< store frames until we get two successive timestamps\n\n    /* timestamps in input timebase */\n    int64_t first_pts;      ///< pts of the first frame that arrived on this filter\n    int64_t pts;            ///< pts of the first frame currently in the fifo\n\n    double start_time;      ///< pts, in seconds, of the expected first frame\n\n    AVRational framerate;   ///< target framerate\n    int rounding;           ///< AVRounding method for timestamps\n\n    /* statistics */\n    int frames_in;             ///< number of frames on input\n    int frames_out;            ///< number of frames on output\n    int dup;                   ///< number of frames duplicated\n    int drop;                  ///< number of framed dropped\n} FPSContext;\n\n#define OFFSET(x) offsetof(FPSContext, x)\n#define V AV_OPT_FLAG_VIDEO_PARAM\n#define F AV_OPT_FLAG_FILTERING_PARAM\nstatic const AVOption fps_options[] = {\n    { \"fps\", \"A string describing desired output framerate\", OFFSET(framerate), AV_OPT_TYPE_VIDEO_RATE, { .str = \"25\" }, .flags = V|F },\n    { \"start_time\", \"Assume the first PTS should be this value.\", OFFSET(start_time), AV_OPT_TYPE_DOUBLE, { .dbl = DBL_MAX}, -DBL_MAX, DBL_MAX, V },\n    { \"round\", \"set rounding method for timestamps\", OFFSET(rounding), AV_OPT_TYPE_INT, { .i64 = AV_ROUND_NEAR_INF }, 0, 5, V|F, \"round\" },\n    { \"zero\", \"round towards 0\",      OFFSET(rounding), AV_OPT_TYPE_CONST, { .i64 = AV_ROUND_ZERO     }, 0, 5, V|F, \"round\" },\n    { \"inf\",  \"round away from 0\",    OFFSET(rounding), AV_OPT_TYPE_CONST, { .i64 = AV_ROUND_INF      }, 0, 5, V|F, \"round\" },\n    { \"down\", \"round towards -infty\", OFFSET(rounding), AV_OPT_TYPE_CONST, { .i64 = AV_ROUND_DOWN     }, 0, 5, V|F, \"round\" },\n    { \"up\",   \"round towards +infty\", OFFSET(rounding), AV_OPT_TYPE_CONST, { .i64 = AV_ROUND_UP       }, 0, 5, V|F, \"round\" },\n    { \"near\", \"round to nearest\",     OFFSET(rounding), AV_OPT_TYPE_CONST, { .i64 = AV_ROUND_NEAR_INF }, 0, 5, V|F, \"round\" },\n    { NULL },\n};\n\nAVFILTER_DEFINE_CLASS(fps);\n\nstatic av_cold int init(AVFilterContext *ctx)\n{\n    FPSContext *s = ctx->priv;\n\n    if (!(s->fifo = av_fifo_alloc(2*sizeof(AVFrame*))))\n        return AVERROR(ENOMEM);\n\n    s->pts          = AV_NOPTS_VALUE;\n    s->first_pts    = AV_NOPTS_VALUE;\n\n    av_log(ctx, AV_LOG_VERBOSE, \"fps=%d/%d\\n\", s->framerate.num, s->framerate.den);\n    return 0;\n}\n\nstatic void flush_fifo(AVFifoBuffer *fifo)\n{\n    while (av_fifo_size(fifo)) {\n        AVFrame *tmp;\n        av_fifo_generic_read(fifo, &tmp, sizeof(tmp), NULL);\n        av_frame_free(&tmp);\n    }\n}\n\nstatic av_cold void uninit(AVFilterContext *ctx)\n{\n    FPSContext *s = ctx->priv;\n    if (s->fifo) {\n        s->drop += av_fifo_size(s->fifo) / sizeof(AVFrame*);\n        flush_fifo(s->fifo);\n        av_fifo_free(s->fifo);\n    }\n\n    av_log(ctx, AV_LOG_VERBOSE, \"%d frames in, %d frames out; %d frames dropped, \"\n           \"%d frames duplicated.\\n\", s->frames_in, s->frames_out, s->drop, s->dup);\n}\n\nstatic int config_props(AVFilterLink* link)\n{\n    FPSContext   *s = link->src->priv;\n\n    link->time_base = av_inv_q(s->framerate);\n    link->frame_rate= s->framerate;\n    link->w         = link->src->inputs[0]->w;\n    link->h         = link->src->inputs[0]->h;\n\n    return 0;\n}\n\nstatic int request_frame(AVFilterLink *outlink)\n{\n    AVFilterContext *ctx = outlink->src;\n    FPSContext        *s = ctx->priv;\n    int frames_out = s->frames_out;\n    int ret = 0;\n\n    while (ret >= 0 && s->frames_out == frames_out)\n        ret = ff_request_frame(ctx->inputs[0]);\n\n    /* flush the fifo */\n    if (ret == AVERROR_EOF && av_fifo_size(s->fifo)) {\n        int i;\n        for (i = 0; av_fifo_size(s->fifo); i++) {\n            AVFrame *buf;\n\n            av_fifo_generic_read(s->fifo, &buf, sizeof(buf), NULL);\n            buf->pts = av_rescale_q(s->first_pts, ctx->inputs[0]->time_base,\n                                    outlink->time_base) + s->frames_out;\n\n            if ((ret = ff_filter_frame(outlink, buf)) < 0)\n                return ret;\n\n            s->frames_out++;\n        }\n        return 0;\n    }\n\n    return ret;\n}\n\nstatic int write_to_fifo(AVFifoBuffer *fifo, AVFrame *buf)\n{\n    int ret;\n\n    if (!av_fifo_space(fifo) &&\n        (ret = av_fifo_realloc2(fifo, 2*av_fifo_size(fifo)))) {\n        av_frame_free(&buf);\n        return ret;\n    }\n\n    av_fifo_generic_write(fifo, &buf, sizeof(buf), NULL);\n    return 0;\n}\n\nstatic int filter_frame(AVFilterLink *inlink, AVFrame *buf)\n{\n    AVFilterContext    *ctx = inlink->dst;\n    FPSContext           *s = ctx->priv;\n    AVFilterLink   *outlink = ctx->outputs[0];\n    int64_t delta;\n    int i, ret;\n\n    s->frames_in++;\n    /* discard frames until we get the first timestamp */\n    if (s->pts == AV_NOPTS_VALUE) {\n        if (buf->pts != AV_NOPTS_VALUE) {\n            ret = write_to_fifo(s->fifo, buf);\n            if (ret < 0)\n                return ret;\n\n            if (s->start_time != DBL_MAX && s->start_time != AV_NOPTS_VALUE) {\n                double first_pts = s->start_time * AV_TIME_BASE;\n                first_pts = FFMIN(FFMAX(first_pts, INT64_MIN), INT64_MAX);\n                s->first_pts = s->pts = av_rescale_q(first_pts, AV_TIME_BASE_Q,\n                                                     inlink->time_base);\n                av_log(ctx, AV_LOG_VERBOSE, \"Set first pts to (in:%\"PRId64\" out:%\"PRId64\")\\n\",\n                       s->first_pts, av_rescale_q(first_pts, AV_TIME_BASE_Q,\n                                                  outlink->time_base));\n            } else {\n                s->first_pts = s->pts = buf->pts;\n            }\n        } else {\n            av_log(ctx, AV_LOG_WARNING, \"Discarding initial frame(s) with no \"\n                   \"timestamp.\\n\");\n            av_frame_free(&buf);\n            s->drop++;\n        }\n        return 0;\n    }\n\n    /* now wait for the next timestamp */\n    if (buf->pts == AV_NOPTS_VALUE) {\n        return write_to_fifo(s->fifo, buf);\n    }\n\n    /* number of output frames */\n    delta = av_rescale_q_rnd(buf->pts - s->pts, inlink->time_base,\n                             outlink->time_base, s->rounding);\n\n    if (delta < 1) {\n        /* drop the frame and everything buffered except the first */\n        AVFrame *tmp;\n        int drop = av_fifo_size(s->fifo)/sizeof(AVFrame*);\n\n        av_log(ctx, AV_LOG_DEBUG, \"Dropping %d frame(s).\\n\", drop);\n        s->drop += drop;\n\n        av_fifo_generic_read(s->fifo, &tmp, sizeof(tmp), NULL);\n        flush_fifo(s->fifo);\n        ret = write_to_fifo(s->fifo, tmp);\n\n        av_frame_free(&buf);\n        return ret;\n    }\n\n    /* can output >= 1 frames */\n    for (i = 0; i < delta; i++) {\n        AVFrame *buf_out;\n        av_fifo_generic_read(s->fifo, &buf_out, sizeof(buf_out), NULL);\n\n        /* duplicate the frame if needed */\n        if (!av_fifo_size(s->fifo) && i < delta - 1) {\n            AVFrame *dup = av_frame_clone(buf_out);\n\n            av_log(ctx, AV_LOG_DEBUG, \"Duplicating frame.\\n\");\n            if (dup)\n                ret = write_to_fifo(s->fifo, dup);\n            else\n                ret = AVERROR(ENOMEM);\n\n            if (ret < 0) {\n                av_frame_free(&buf_out);\n                av_frame_free(&buf);\n                return ret;\n            }\n\n            s->dup++;\n        }\n\n        buf_out->pts = av_rescale_q(s->first_pts, inlink->time_base,\n                                    outlink->time_base) + s->frames_out;\n\n        if ((ret = ff_filter_frame(outlink, buf_out)) < 0) {\n            av_frame_free(&buf);\n            return ret;\n        }\n\n        s->frames_out++;\n    }\n    flush_fifo(s->fifo);\n\n    ret = write_to_fifo(s->fifo, buf);\n    s->pts = s->first_pts + av_rescale_q(s->frames_out, outlink->time_base, inlink->time_base);\n\n    return ret;\n}\n\nstatic const AVFilterPad avfilter_vf_fps_inputs[] = {\n    {\n        .name        = \"default\",\n        .type        = AVMEDIA_TYPE_VIDEO,\n        .filter_frame = filter_frame,\n    },\n    { NULL }\n};\n\nstatic const AVFilterPad avfilter_vf_fps_outputs[] = {\n    {\n        .name          = \"default\",\n        .type          = AVMEDIA_TYPE_VIDEO,\n        .request_frame = request_frame,\n        .config_props  = config_props\n    },\n    { NULL }\n};\n\nAVFilter avfilter_vf_fps = {\n    .name        = \"fps\",\n    .description = NULL_IF_CONFIG_SMALL(\"Force constant framerate.\"),\n\n    .init      = init,\n    .uninit    = uninit,\n\n    .priv_size = sizeof(FPSContext),\n    .priv_class = &fps_class,\n\n    .inputs    = avfilter_vf_fps_inputs,\n    .outputs   = avfilter_vf_fps_outputs,\n};\n"], "fixing_code": ["/*\n * Copyright 2007 Bobby Bingham\n * Copyright 2012 Robert Nagy <ronag89 gmail com>\n * Copyright 2012 Anton Khirnov <anton khirnov net>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * a filter enforcing given constant framerate\n */\n\n#include <float.h>\n\n#include \"libavutil/common.h\"\n#include \"libavutil/fifo.h\"\n#include \"libavutil/mathematics.h\"\n#include \"libavutil/opt.h\"\n#include \"libavutil/parseutils.h\"\n\n#include \"avfilter.h\"\n#include \"internal.h\"\n#include \"video.h\"\n\ntypedef struct FPSContext {\n    const AVClass *class;\n\n    AVFifoBuffer *fifo;     ///< store frames until we get two successive timestamps\n\n    /* timestamps in input timebase */\n    int64_t first_pts;      ///< pts of the first frame that arrived on this filter\n    int64_t pts;            ///< pts of the first frame currently in the fifo\n\n    double start_time;      ///< pts, in seconds, of the expected first frame\n\n    AVRational framerate;   ///< target framerate\n    int rounding;           ///< AVRounding method for timestamps\n\n    /* statistics */\n    int frames_in;             ///< number of frames on input\n    int frames_out;            ///< number of frames on output\n    int dup;                   ///< number of frames duplicated\n    int drop;                  ///< number of framed dropped\n} FPSContext;\n\n#define OFFSET(x) offsetof(FPSContext, x)\n#define V AV_OPT_FLAG_VIDEO_PARAM\n#define F AV_OPT_FLAG_FILTERING_PARAM\nstatic const AVOption fps_options[] = {\n    { \"fps\", \"A string describing desired output framerate\", OFFSET(framerate), AV_OPT_TYPE_VIDEO_RATE, { .str = \"25\" }, .flags = V|F },\n    { \"start_time\", \"Assume the first PTS should be this value.\", OFFSET(start_time), AV_OPT_TYPE_DOUBLE, { .dbl = DBL_MAX}, -DBL_MAX, DBL_MAX, V },\n    { \"round\", \"set rounding method for timestamps\", OFFSET(rounding), AV_OPT_TYPE_INT, { .i64 = AV_ROUND_NEAR_INF }, 0, 5, V|F, \"round\" },\n    { \"zero\", \"round towards 0\",      OFFSET(rounding), AV_OPT_TYPE_CONST, { .i64 = AV_ROUND_ZERO     }, 0, 5, V|F, \"round\" },\n    { \"inf\",  \"round away from 0\",    OFFSET(rounding), AV_OPT_TYPE_CONST, { .i64 = AV_ROUND_INF      }, 0, 5, V|F, \"round\" },\n    { \"down\", \"round towards -infty\", OFFSET(rounding), AV_OPT_TYPE_CONST, { .i64 = AV_ROUND_DOWN     }, 0, 5, V|F, \"round\" },\n    { \"up\",   \"round towards +infty\", OFFSET(rounding), AV_OPT_TYPE_CONST, { .i64 = AV_ROUND_UP       }, 0, 5, V|F, \"round\" },\n    { \"near\", \"round to nearest\",     OFFSET(rounding), AV_OPT_TYPE_CONST, { .i64 = AV_ROUND_NEAR_INF }, 0, 5, V|F, \"round\" },\n    { NULL },\n};\n\nAVFILTER_DEFINE_CLASS(fps);\n\nstatic av_cold int init(AVFilterContext *ctx)\n{\n    FPSContext *s = ctx->priv;\n\n    if (!(s->fifo = av_fifo_alloc(2*sizeof(AVFrame*))))\n        return AVERROR(ENOMEM);\n\n    s->pts          = AV_NOPTS_VALUE;\n    s->first_pts    = AV_NOPTS_VALUE;\n\n    av_log(ctx, AV_LOG_VERBOSE, \"fps=%d/%d\\n\", s->framerate.num, s->framerate.den);\n    return 0;\n}\n\nstatic void flush_fifo(AVFifoBuffer *fifo)\n{\n    while (av_fifo_size(fifo)) {\n        AVFrame *tmp;\n        av_fifo_generic_read(fifo, &tmp, sizeof(tmp), NULL);\n        av_frame_free(&tmp);\n    }\n}\n\nstatic av_cold void uninit(AVFilterContext *ctx)\n{\n    FPSContext *s = ctx->priv;\n    if (s->fifo) {\n        s->drop += av_fifo_size(s->fifo) / sizeof(AVFrame*);\n        flush_fifo(s->fifo);\n        av_fifo_free(s->fifo);\n    }\n\n    av_log(ctx, AV_LOG_VERBOSE, \"%d frames in, %d frames out; %d frames dropped, \"\n           \"%d frames duplicated.\\n\", s->frames_in, s->frames_out, s->drop, s->dup);\n}\n\nstatic int config_props(AVFilterLink* link)\n{\n    FPSContext   *s = link->src->priv;\n\n    link->time_base = av_inv_q(s->framerate);\n    link->frame_rate= s->framerate;\n    link->w         = link->src->inputs[0]->w;\n    link->h         = link->src->inputs[0]->h;\n\n    return 0;\n}\n\nstatic int request_frame(AVFilterLink *outlink)\n{\n    AVFilterContext *ctx = outlink->src;\n    FPSContext        *s = ctx->priv;\n    int frames_out = s->frames_out;\n    int ret = 0;\n\n    while (ret >= 0 && s->frames_out == frames_out)\n        ret = ff_request_frame(ctx->inputs[0]);\n\n    /* flush the fifo */\n    if (ret == AVERROR_EOF && av_fifo_size(s->fifo)) {\n        int i;\n        for (i = 0; av_fifo_size(s->fifo); i++) {\n            AVFrame *buf;\n\n            av_fifo_generic_read(s->fifo, &buf, sizeof(buf), NULL);\n            buf->pts = av_rescale_q(s->first_pts, ctx->inputs[0]->time_base,\n                                    outlink->time_base) + s->frames_out;\n\n            if ((ret = ff_filter_frame(outlink, buf)) < 0)\n                return ret;\n\n            s->frames_out++;\n        }\n        return 0;\n    }\n\n    return ret;\n}\n\nstatic int write_to_fifo(AVFifoBuffer *fifo, AVFrame *buf)\n{\n    int ret;\n\n    if (!av_fifo_space(fifo) &&\n        (ret = av_fifo_realloc2(fifo, 2*av_fifo_size(fifo)))) {\n        av_frame_free(&buf);\n        return ret;\n    }\n\n    av_fifo_generic_write(fifo, &buf, sizeof(buf), NULL);\n    return 0;\n}\n\nstatic int filter_frame(AVFilterLink *inlink, AVFrame *buf)\n{\n    AVFilterContext    *ctx = inlink->dst;\n    FPSContext           *s = ctx->priv;\n    AVFilterLink   *outlink = ctx->outputs[0];\n    int64_t delta;\n    int i, ret;\n\n    s->frames_in++;\n    /* discard frames until we get the first timestamp */\n    if (s->pts == AV_NOPTS_VALUE) {\n        if (buf->pts != AV_NOPTS_VALUE) {\n            ret = write_to_fifo(s->fifo, buf);\n            if (ret < 0)\n                return ret;\n\n            if (s->start_time != DBL_MAX && s->start_time != AV_NOPTS_VALUE) {\n                double first_pts = s->start_time * AV_TIME_BASE;\n                first_pts = FFMIN(FFMAX(first_pts, INT64_MIN), INT64_MAX);\n                s->first_pts = s->pts = av_rescale_q(first_pts, AV_TIME_BASE_Q,\n                                                     inlink->time_base);\n                av_log(ctx, AV_LOG_VERBOSE, \"Set first pts to (in:%\"PRId64\" out:%\"PRId64\")\\n\",\n                       s->first_pts, av_rescale_q(first_pts, AV_TIME_BASE_Q,\n                                                  outlink->time_base));\n            } else {\n                s->first_pts = s->pts = buf->pts;\n            }\n        } else {\n            av_log(ctx, AV_LOG_WARNING, \"Discarding initial frame(s) with no \"\n                   \"timestamp.\\n\");\n            av_frame_free(&buf);\n            s->drop++;\n        }\n        return 0;\n    }\n\n    /* now wait for the next timestamp */\n    if (buf->pts == AV_NOPTS_VALUE || av_fifo_size(s->fifo) <= 0) {\n        return write_to_fifo(s->fifo, buf);\n    }\n\n    /* number of output frames */\n    delta = av_rescale_q_rnd(buf->pts - s->pts, inlink->time_base,\n                             outlink->time_base, s->rounding);\n\n    if (delta < 1) {\n        /* drop the frame and everything buffered except the first */\n        AVFrame *tmp;\n        int drop = av_fifo_size(s->fifo)/sizeof(AVFrame*);\n\n        av_log(ctx, AV_LOG_DEBUG, \"Dropping %d frame(s).\\n\", drop);\n        s->drop += drop;\n\n        av_fifo_generic_read(s->fifo, &tmp, sizeof(tmp), NULL);\n        flush_fifo(s->fifo);\n        ret = write_to_fifo(s->fifo, tmp);\n\n        av_frame_free(&buf);\n        return ret;\n    }\n\n    /* can output >= 1 frames */\n    for (i = 0; i < delta; i++) {\n        AVFrame *buf_out;\n        av_fifo_generic_read(s->fifo, &buf_out, sizeof(buf_out), NULL);\n\n        /* duplicate the frame if needed */\n        if (!av_fifo_size(s->fifo) && i < delta - 1) {\n            AVFrame *dup = av_frame_clone(buf_out);\n\n            av_log(ctx, AV_LOG_DEBUG, \"Duplicating frame.\\n\");\n            if (dup)\n                ret = write_to_fifo(s->fifo, dup);\n            else\n                ret = AVERROR(ENOMEM);\n\n            if (ret < 0) {\n                av_frame_free(&buf_out);\n                av_frame_free(&buf);\n                return ret;\n            }\n\n            s->dup++;\n        }\n\n        buf_out->pts = av_rescale_q(s->first_pts, inlink->time_base,\n                                    outlink->time_base) + s->frames_out;\n\n        if ((ret = ff_filter_frame(outlink, buf_out)) < 0) {\n            av_frame_free(&buf);\n            return ret;\n        }\n\n        s->frames_out++;\n    }\n    flush_fifo(s->fifo);\n\n    ret = write_to_fifo(s->fifo, buf);\n    s->pts = s->first_pts + av_rescale_q(s->frames_out, outlink->time_base, inlink->time_base);\n\n    return ret;\n}\n\nstatic const AVFilterPad avfilter_vf_fps_inputs[] = {\n    {\n        .name        = \"default\",\n        .type        = AVMEDIA_TYPE_VIDEO,\n        .filter_frame = filter_frame,\n    },\n    { NULL }\n};\n\nstatic const AVFilterPad avfilter_vf_fps_outputs[] = {\n    {\n        .name          = \"default\",\n        .type          = AVMEDIA_TYPE_VIDEO,\n        .request_frame = request_frame,\n        .config_props  = config_props\n    },\n    { NULL }\n};\n\nAVFilter avfilter_vf_fps = {\n    .name        = \"fps\",\n    .description = NULL_IF_CONFIG_SMALL(\"Force constant framerate.\"),\n\n    .init      = init,\n    .uninit    = uninit,\n\n    .priv_size = sizeof(FPSContext),\n    .priv_class = &fps_class,\n\n    .inputs    = avfilter_vf_fps_inputs,\n    .outputs   = avfilter_vf_fps_outputs,\n};\n"], "filenames": ["libavfilter/vf_fps.c"], "buggy_code_start_loc": [208], "buggy_code_end_loc": [209], "fixing_code_start_loc": [208], "fixing_code_end_loc": [209], "type": "CWE-399", "message": "The filter_frame function in libavfilter/vf_fps.c in FFmpeg before 2.1 does not properly ensure the availability of FIFO content, which allows remote attackers to cause a denial of service (double free) or possibly have unspecified other impact via crafted data.", "other": {"cve": {"id": "CVE-2013-7021", "sourceIdentifier": "cve@mitre.org", "published": "2013-12-09T16:36:50.050", "lastModified": "2016-12-03T03:00:46.127", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The filter_frame function in libavfilter/vf_fps.c in FFmpeg before 2.1 does not properly ensure the availability of FIFO content, which allows remote attackers to cause a denial of service (double free) or possibly have unspecified other impact via crafted data."}, {"lang": "es", "value": "La funci\u00f3m filter_frame en libavfilter/vf_fps.c en FFmepg anteriores a 2.1 no asegura apropiadamente la disponibilidad de contenido FIFO, lo que permite a atacantes remotos causar una denegaci\u00f3n de servicio (doble liberaci\u00f3n) o posiblemente tener otro impacto a trav\u00e9s de datos manipulados."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.0.1", "matchCriteriaId": "C41A1983-BA74-4806-A227-EBBF7989112C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3:*:*:*:*:*:*:*", "matchCriteriaId": "B2649A80-4739-4BBB-AB0B-99AD435BE7CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "D4A2E77D-B826-4B49-ADC8-7F704E149A5A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "18157837-4550-45E3-A12E-AE06E047E253"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "E9F42611-C3E2-416B-9AE7-A5AE83E4DEF7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "3A20789F-26E3-4871-B24E-25E922BADDF0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "67C6C243-3ACC-49C3-80CA-D7CA8FEFF0D8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "6AE6D368-0BA6-4499-B7E1-EE16C03012E9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "26C0F6EF-0452-4AFE-AF3E-B88F963A0938"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "5B4DD372-4D3B-445C-8C38-E083A3C0D4A7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "733C03D7-2780-4D69-A98D-BCFB91D1119A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "0AEE1977-E9E0-4BFF-B33B-B083E49E51F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "E6979C17-0BC6-47D1-9B73-254D84306A96"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "204C7C05-3441-4DB0-8702-D99C8FCB381E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.9:pre1:*:*:*:*:*:*", "matchCriteriaId": "2E1A7011-B992-4E35-B306-45772DACB23C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5:*:*:*:*:*:*:*", "matchCriteriaId": "8D486C17-FC4A-4AEE-A430-1B1FBCC2C27C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "632BC7C2-FE59-47B0-885C-0EB8C74DF041"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "5D1AE0BF-A6FD-4EBA-BF61-07AC81EA560D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "5B8FA106-FE65-4BB0-92A7-E8A5AF978A9B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "514669DA-8D02-44CE-BE18-8783F69AE394"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "8041E6ED-472A-40DF-AA90-F3509D90D47A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "D2C64382-9259-4D61-B352-7F123527289C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "32A152D9-947E-4198-9C2D-2A582F09AB75"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6:*:*:*:*:*:*:*", "matchCriteriaId": "37FBB817-A186-4517-9DA7-B3638576AAE7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "157ABA40-6101-4E9C-A24C-84F8E23D374D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "C7EA46DD-2CC4-426F-8709-821B7572C94A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "3DE12C59-4409-4F7A-9759-7B26FA9DAC34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7:*:*:*:*:*:*:*", "matchCriteriaId": "30FE6578-F031-4F5B-B955-8F912CFCA1B0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "07669E0E-8C4B-430E-802F-F64EEA2B5A0B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "F3EB7F17-F25D-4E48-8A43-F799619CE71F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.3:*:*:*:*:*:*:*", "matchCriteriaId": "60705A3B-7136-45D1-8068-E2DC9E01EB04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.4:*:*:*:*:*:*:*", "matchCriteriaId": "C722B143-2648-4EB2-A090-7B788F41F300"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.5:*:*:*:*:*:*:*", "matchCriteriaId": "B31AFDBC-A782-4C18-8EAA-6D927397BEA3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.6:*:*:*:*:*:*:*", "matchCriteriaId": "73E9E8F4-A942-4F34-BCE2-82A180F1DD1F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.7:*:*:*:*:*:*:*", "matchCriteriaId": "AAA31D75-C3FB-4D89-8B2D-21372AAEB78B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.8:*:*:*:*:*:*:*", "matchCriteriaId": "B20E5358-826C-47A2-B39F-ED4E9213BA95"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.9:*:*:*:*:*:*:*", "matchCriteriaId": "26321888-E140-4F09-AAA0-7392AA7F6307"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.11:*:*:*:*:*:*:*", "matchCriteriaId": "7E46B9F3-A9C0-4B8A-A119-40CA4CBBD0EE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.12:*:*:*:*:*:*:*", "matchCriteriaId": "44800572-71C5-4AA1-9CB6-30AA902B0353"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "87090477-1D36-48B3-88AE-5CD5EE8F89D7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "2096FF8B-9B57-4C59-84DB-9CC0DEAB47AC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "34C99254-776C-4AAD-BDA2-3F544256AA67"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "CE9D7B73-9CDA-4BAE-8DD9-8E1E34C20648"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "4FDBF2C0-8E33-4575-8A19-4F1CABA3023F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "72040664-077A-48FB-9E6B-B69EA8D26CB4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "F428A2E4-A54F-4296-A00F-1A4E160253D7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.7:*:*:*:*:*:*:*", "matchCriteriaId": "5239E4FA-0359-49F1-93D4-24AB013FAC20"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.8:*:*:*:*:*:*:*", "matchCriteriaId": "F0C8230D-4E89-45F9-B0F7-E317119E0FA0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.10:*:*:*:*:*:*:*", "matchCriteriaId": "585CE7D2-1CE8-44AB-AE67-07D7D3721F68"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.11:*:*:*:*:*:*:*", "matchCriteriaId": "EE81C339-A794-4303-B829-BE743DF0B132"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.9:*:*:*:*:*:*:*", "matchCriteriaId": "5CE0A27B-66D7-4D1B-8E6A-F4722C070BD3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "864DC4A2-A378-4389-B62E-9E785879A744"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.10:*:*:*:*:*:*:*", "matchCriteriaId": "16304267-C808-4B6B-9903-2DEAB40AD899"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.10.3:*:*:*:*:*:*:*", "matchCriteriaId": "CEEBBA83-1BFC-45A8-B34A-AB3A9B8A9414"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.10.4:*:*:*:*:*:*:*", "matchCriteriaId": "F559B34E-23EE-4E09-A044-E7F54C55B05E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.11:*:*:*:*:*:*:*", "matchCriteriaId": "62BA2708-BE77-42B7-B51A-C1B58632462C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "23E57BB1-DF1E-4173-BE52-72E2B3E6BA23"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "A3E30DB1-0CFC-4EAA-BF07-CE7551ABDCB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "DBA7D745-DC16-43B9-8A2D-4D6944A6BFD0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "87A511A5-2040-433A-9B32-B89332214FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "0C01DD9C-98C9-4896-8D66-A8336582298B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.2:*:*:*:*:*:*:*", "matchCriteriaId": "BBE7723A-3D6B-4390-B82E-6A5A6992141A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "1ED8FF93-5AA7-443C-BBDB-845736BB337B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:2.0:*:*:*:*:*:*:*", "matchCriteriaId": "A1337F5B-E9D9-4335-9E05-50018E59E530"}]}]}], "references": [{"url": "http://ffmpeg.org/security.html", "source": "cve@mitre.org"}, {"url": "http://openwall.com/lists/oss-security/2013/11/26/7", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://openwall.com/lists/oss-security/2013/12/08/3", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/cdd5df8189ff1537f7abe8defe971f80602cc2d2", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}, {"url": "https://security.gentoo.org/glsa/201603-06", "source": "cve@mitre.org"}, {"url": "https://trac.ffmpeg.org/ticket/2905", "source": "cve@mitre.org", "tags": ["Exploit"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/cdd5df8189ff1537f7abe8defe971f80602cc2d2"}}