{"buggy_code": ["// Styles\nimport './calendar-with-events.sass'\n\n// Types\nimport { VNode, VNodeData } from 'vue'\n\n// Directives\nimport ripple from '../../../directives/ripple'\n\n// Mixins\nimport CalendarBase from './calendar-base'\n\n// Helpers\nimport { escapeHTML } from '../../../util/helpers'\n\n// Util\nimport props from '../util/props'\nimport {\n  CalendarEventOverlapModes,\n} from '../modes'\nimport {\n  getDayIdentifier, diffMinutes,\n} from '../util/timestamp'\nimport {\n  parseEvent,\n  isEventStart,\n  isEventOn,\n  isEventOverlapping,\n  isEventHiddenOn,\n} from '../util/events'\nimport {\n  CalendarTimestamp,\n  CalendarEventParsed,\n  CalendarEventVisual,\n  CalendarEventColorFunction,\n  CalendarEventNameFunction,\n  CalendarEventTimedFunction,\n  CalendarDaySlotScope,\n  CalendarDayBodySlotScope,\n  CalendarEventOverlapMode,\n  CalendarEvent,\n  CalendarEventCategoryFunction,\n  CalendarCategory,\n} from 'vuetify/types'\n\n// Types\ntype VEventGetter<D> = (day: D) => CalendarEventParsed[]\n\ntype VEventVisualToNode<D> = (visual: CalendarEventVisual, day: D) => VNode | false\n\ntype VEventsToNodes = <D extends CalendarDaySlotScope>(\n  day: D,\n  getter: VEventGetter<D>,\n  mapper: VEventVisualToNode<D>,\n  timed: boolean) => VNode[] | undefined\n\ntype VDailyEventsMap = {\n  [date: string]: {\n    parent: HTMLElement\n    more: HTMLElement | null\n    events: HTMLElement[]\n  }\n}\n\ninterface VEventScopeInput {\n  eventParsed: CalendarEventParsed\n  day: CalendarDaySlotScope\n  start: boolean\n  end: boolean\n  timed: boolean\n}\n\nconst WIDTH_FULL = 100\nconst WIDTH_START = 95\nconst MINUTES_IN_DAY = 1440\n\n/* @vue/component */\nexport default CalendarBase.extend({\n  name: 'calendar-with-events',\n\n  directives: {\n    ripple,\n  },\n\n  props: {\n    ...props.events,\n    ...props.calendar,\n    ...props.category,\n  },\n\n  computed: {\n    noEvents (): boolean {\n      return this.events.length === 0\n    },\n    parsedEvents (): CalendarEventParsed[] {\n      return this.events.map(this.parseEvent)\n    },\n    parsedEventOverlapThreshold (): number {\n      return parseInt(this.eventOverlapThreshold)\n    },\n    eventTimedFunction (): CalendarEventTimedFunction {\n      return typeof this.eventTimed === 'function'\n        ? this.eventTimed\n        : event => !!event[this.eventTimed as string]\n    },\n    eventCategoryFunction (): CalendarEventCategoryFunction {\n      return typeof this.eventCategory === 'function'\n        ? this.eventCategory\n        : event => event[this.eventCategory as string]\n    },\n    eventTextColorFunction (): CalendarEventColorFunction {\n      return typeof this.eventTextColor === 'function'\n        ? this.eventTextColor\n        : () => this.eventTextColor as string\n    },\n    eventNameFunction (): CalendarEventNameFunction {\n      return typeof this.eventName === 'function'\n        ? this.eventName\n        : (event, timedEvent) => escapeHTML(event.input[this.eventName as string] as string || '')\n    },\n    eventModeFunction (): CalendarEventOverlapMode {\n      return typeof this.eventOverlapMode === 'function'\n        ? this.eventOverlapMode\n        : CalendarEventOverlapModes[this.eventOverlapMode]\n    },\n    eventWeekdays (): number[] {\n      return this.parsedWeekdays\n    },\n    categoryMode (): boolean {\n      return this.type === 'category'\n    },\n  },\n\n  methods: {\n    eventColorFunction (e: CalendarEvent): string {\n      return typeof this.eventColor === 'function'\n        ? this.eventColor(e)\n        : e.color || this.eventColor\n    },\n    parseEvent (input: CalendarEvent, index = 0): CalendarEventParsed {\n      return parseEvent(\n        input,\n        index,\n        this.eventStart,\n        this.eventEnd,\n        this.eventTimedFunction(input),\n        this.categoryMode ? this.eventCategoryFunction(input) : false,\n      )\n    },\n    formatTime (withTime: CalendarTimestamp, ampm: boolean): string {\n      const formatter = this.getFormatter({\n        timeZone: 'UTC',\n        hour: 'numeric',\n        minute: withTime.minute > 0 ? 'numeric' : undefined,\n      })\n\n      return formatter(withTime, true)\n    },\n    updateEventVisibility () {\n      if (this.noEvents || !this.eventMore) {\n        return\n      }\n\n      const eventHeight = this.eventHeight\n      const eventsMap = this.getEventsMap()\n\n      for (const date in eventsMap) {\n        const { parent, events, more } = eventsMap[date]\n        if (!more) {\n          break\n        }\n\n        const parentBounds = parent.getBoundingClientRect()\n        const last = events.length - 1\n        const eventsSorted = events.map(event => ({\n          event,\n          bottom: event.getBoundingClientRect().bottom,\n        })).sort((a, b) => a.bottom - b.bottom)\n        let hidden = 0\n\n        for (let i = 0; i <= last; i++) {\n          const bottom = eventsSorted[i].bottom\n          const hide = i === last\n            ? (bottom > parentBounds.bottom)\n            : (bottom + eventHeight > parentBounds.bottom)\n\n          if (hide) {\n            eventsSorted[i].event.style.display = 'none'\n            hidden++\n          }\n        }\n\n        if (hidden) {\n          more.style.display = ''\n          more.innerHTML = this.$vuetify.lang.t(this.eventMoreText, hidden)\n        } else {\n          more.style.display = 'none'\n        }\n      }\n    },\n    getEventsMap (): VDailyEventsMap {\n      const eventsMap: VDailyEventsMap = {}\n      const elements = this.$refs.events as HTMLElement[]\n\n      if (!elements || !elements.forEach) {\n        return eventsMap\n      }\n\n      elements.forEach(el => {\n        const date = el.getAttribute('data-date')\n        if (el.parentElement && date) {\n          if (!(date in eventsMap)) {\n            eventsMap[date] = {\n              parent: el.parentElement,\n              more: null,\n              events: [],\n            }\n          }\n          if (el.getAttribute('data-more')) {\n            eventsMap[date].more = el\n          } else {\n            eventsMap[date].events.push(el)\n            el.style.display = ''\n          }\n        }\n      })\n\n      return eventsMap\n    },\n    genDayEvent ({ event }: CalendarEventVisual, day: CalendarDaySlotScope): VNode {\n      const eventHeight = this.eventHeight\n      const eventMarginBottom = this.eventMarginBottom\n      const dayIdentifier = getDayIdentifier(day)\n      const week = day.week\n      const start = dayIdentifier === event.startIdentifier\n      let end = dayIdentifier === event.endIdentifier\n      let width = WIDTH_START\n\n      if (!this.categoryMode) {\n        for (let i = day.index + 1; i < week.length; i++) {\n          const weekdayIdentifier = getDayIdentifier(week[i])\n          if (event.endIdentifier >= weekdayIdentifier) {\n            width += WIDTH_FULL\n            end = end || weekdayIdentifier === event.endIdentifier\n          } else {\n            end = true\n            break\n          }\n        }\n      }\n      const scope = { eventParsed: event, day, start, end, timed: false }\n\n      return this.genEvent(event, scope, false, {\n        staticClass: 'v-event',\n        class: {\n          'v-event-start': start,\n          'v-event-end': end,\n        },\n        style: {\n          height: `${eventHeight}px`,\n          width: `${width}%`,\n          'margin-bottom': `${eventMarginBottom}px`,\n        },\n        attrs: {\n          'data-date': day.date,\n        },\n        key: event.index,\n        ref: 'events',\n        refInFor: true,\n      })\n    },\n    genTimedEvent ({ event, left, width }: CalendarEventVisual, day: CalendarDayBodySlotScope): VNode | false {\n      if (day.timeDelta(event.end) < 0 || day.timeDelta(event.start) >= 1 || isEventHiddenOn(event, day)) {\n        return false\n      }\n\n      const dayIdentifier = getDayIdentifier(day)\n      const start = event.startIdentifier >= dayIdentifier\n      const end = event.endIdentifier > dayIdentifier\n      const top = start ? day.timeToY(event.start) : 0\n      const bottom = end ? day.timeToY(MINUTES_IN_DAY) : day.timeToY(event.end)\n      const height = Math.max(this.eventHeight, bottom - top)\n      const scope = { eventParsed: event, day, start, end, timed: true }\n\n      return this.genEvent(event, scope, true, {\n        staticClass: 'v-event-timed',\n        style: {\n          top: `${top}px`,\n          height: `${height}px`,\n          left: `${left}%`,\n          width: `${width}%`,\n        },\n      })\n    },\n    genEvent (event: CalendarEventParsed, scopeInput: VEventScopeInput, timedEvent: boolean, data: VNodeData): VNode {\n      const slot = this.$scopedSlots.event\n      const text = this.eventTextColorFunction(event.input)\n      const background = this.eventColorFunction(event.input)\n      const overlapsNoon = event.start.hour < 12 && event.end.hour >= 12\n      const singline = diffMinutes(event.start, event.end) <= this.parsedEventOverlapThreshold\n      const formatTime = this.formatTime\n      const timeSummary = () => formatTime(event.start, overlapsNoon) + ' - ' + formatTime(event.end, true)\n      const eventSummary = () => {\n        const name = this.eventNameFunction(event, timedEvent)\n        if (event.start.hasTime) {\n          const eventSummaryClass = 'v-event-summary'\n          if (timedEvent) {\n            const time = timeSummary()\n            const delimiter = singline ? ', ' : '<br>'\n\n            return `<span class=\"${eventSummaryClass}\"><strong>${name}</strong>${delimiter}${time}</span>`\n          } else {\n            const time = formatTime(event.start, true)\n\n            return `<span class=\"${eventSummaryClass}\"><strong>${time}</strong> ${name}</span>`\n          }\n        }\n\n        return name\n      }\n\n      const scope = {\n        ...scopeInput,\n        event: event.input,\n        outside: scopeInput.day.outside,\n        singline,\n        overlapsNoon,\n        formatTime,\n        timeSummary,\n        eventSummary,\n      }\n\n      return this.$createElement('div',\n        this.setTextColor(text,\n          this.setBackgroundColor(background, {\n            on: this.getDefaultMouseEventHandlers(':event', nativeEvent => ({ ...scope, nativeEvent })),\n            directives: [{\n              name: 'ripple',\n              value: this.eventRipple ?? true,\n            }],\n            ...data,\n          })\n        ), slot\n          ? slot(scope)\n          : [this.genName(eventSummary)]\n      )\n    },\n    genName (eventSummary: () => string): VNode {\n      return this.$createElement('div', {\n        staticClass: 'pl-1',\n        domProps: {\n          innerHTML: eventSummary(),\n        },\n      })\n    },\n    genPlaceholder (day: CalendarTimestamp): VNode {\n      const height = this.eventHeight + this.eventMarginBottom\n\n      return this.$createElement('div', {\n        style: {\n          height: `${height}px`,\n        },\n        attrs: {\n          'data-date': day.date,\n        },\n        ref: 'events',\n        refInFor: true,\n      })\n    },\n    genMore (day: CalendarDaySlotScope): VNode {\n      const eventHeight = this.eventHeight\n      const eventMarginBottom = this.eventMarginBottom\n\n      return this.$createElement('div', {\n        staticClass: 'v-event-more pl-1',\n        class: {\n          'v-outside': day.outside,\n        },\n        attrs: {\n          'data-date': day.date,\n          'data-more': 1,\n        },\n        directives: [{\n          name: 'ripple',\n          value: this.eventRipple ?? true,\n        }],\n        on: this.getDefaultMouseEventHandlers(':more', nativeEvent => {\n          return { nativeEvent, ...day }\n        }),\n\n        style: {\n          display: 'none',\n          height: `${eventHeight}px`,\n          'margin-bottom': `${eventMarginBottom}px`,\n        },\n        ref: 'events',\n        refInFor: true,\n      })\n    },\n    getVisibleEvents (): CalendarEventParsed[] {\n      const start = getDayIdentifier(this.days[0])\n      const end = getDayIdentifier(this.days[this.days.length - 1])\n\n      return this.parsedEvents.filter(\n        event => isEventOverlapping(event, start, end)\n      )\n    },\n    isEventForCategory (event: CalendarEventParsed, category: CalendarCategory): boolean {\n      return !this.categoryMode ||\n        (typeof category === 'object' && category.categoryName &&\n        category.categoryName === event.category) ||\n        (typeof event.category === 'string' && category === event.category) ||\n        (typeof event.category !== 'string' && category === null)\n    },\n    getEventsForDay (day: CalendarDaySlotScope): CalendarEventParsed[] {\n      const identifier = getDayIdentifier(day)\n      const firstWeekday = this.eventWeekdays[0]\n\n      return this.parsedEvents.filter(\n        event => isEventStart(event, day, identifier, firstWeekday)\n      )\n    },\n    getEventsForDayAll (day: CalendarDaySlotScope): CalendarEventParsed[] {\n      const identifier = getDayIdentifier(day)\n      const firstWeekday = this.eventWeekdays[0]\n\n      return this.parsedEvents.filter(\n        event => event.allDay &&\n          (this.categoryMode ? isEventOn(event, identifier) : isEventStart(event, day, identifier, firstWeekday)) &&\n          this.isEventForCategory(event, day.category)\n      )\n    },\n    getEventsForDayTimed (day: CalendarDaySlotScope): CalendarEventParsed[] {\n      const identifier = getDayIdentifier(day)\n      return this.parsedEvents.filter(\n        event => !event.allDay &&\n          isEventOn(event, identifier) &&\n          this.isEventForCategory(event, day.category)\n      )\n    },\n    getScopedSlots () {\n      if (this.noEvents) {\n        return { ...this.$scopedSlots }\n      }\n\n      const mode = this.eventModeFunction(\n        this.parsedEvents,\n        this.eventWeekdays[0],\n        this.parsedEventOverlapThreshold\n      )\n\n      const isNode = (input: VNode | false): input is VNode => !!input\n      const getSlotChildren: VEventsToNodes = (day, getter, mapper, timed) => {\n        const events = getter(day)\n        const visuals = mode(day, events, timed, this.categoryMode)\n\n        if (timed) {\n          return visuals.map(visual => mapper(visual, day)).filter(isNode)\n        }\n\n        const children: VNode[] = []\n\n        visuals.forEach((visual, index) => {\n          while (children.length < visual.column) {\n            children.push(this.genPlaceholder(day))\n          }\n\n          const mapped = mapper(visual, day)\n          if (mapped) {\n            children.push(mapped)\n          }\n        })\n\n        return children\n      }\n\n      const slots = this.$scopedSlots\n      const slotDay = slots.day\n      const slotDayHeader = slots['day-header']\n      const slotDayBody = slots['day-body']\n\n      return {\n        ...slots,\n        day: (day: CalendarDaySlotScope) => {\n          let children = getSlotChildren(day, this.getEventsForDay, this.genDayEvent, false)\n          if (children && children.length > 0 && this.eventMore) {\n            children.push(this.genMore(day))\n          }\n          if (slotDay) {\n            const slot = slotDay(day)\n            if (slot) {\n              children = children ? children.concat(slot) : slot\n            }\n          }\n          return children\n        },\n        'day-header': (day: CalendarDaySlotScope) => {\n          let children = getSlotChildren(day, this.getEventsForDayAll, this.genDayEvent, false)\n\n          if (slotDayHeader) {\n            const slot = slotDayHeader(day)\n            if (slot) {\n              children = children ? children.concat(slot) : slot\n            }\n          }\n          return children\n        },\n        'day-body': (day: CalendarDayBodySlotScope) => {\n          const events = getSlotChildren(day, this.getEventsForDayTimed, this.genTimedEvent, true)\n          let children: VNode[] = [\n            this.$createElement('div', {\n              staticClass: 'v-event-timed-container',\n            }, events),\n          ]\n\n          if (slotDayBody) {\n            const slot = slotDayBody(day)\n            if (slot) {\n              children = children.concat(slot)\n            }\n          }\n          return children\n        },\n      }\n    },\n  },\n})\n", "import Vue, { Component, PluginFunction, VueConstructor, DirectiveOptions } from 'vue'\nimport './lib'\nimport './alacarte'\nimport './colors'\n\n// Services\nimport { Application } from './services/application'\nimport { Breakpoint } from './services/breakpoint'\nimport { Icons } from './services/icons'\nimport { Lang } from './services/lang'\nimport { Theme } from './services/theme'\nimport {\n  Presets,\n  UserVuetifyPreset,\n  VuetifyPreset,\n} from './services/presets'\n\n// Service Options\nimport { GoToOptions, VuetifyGoToTarget } from './services/goto'\n\nexport default class Vuetify {\n  constructor (preset?: Partial<UserVuetifyPreset>)\n\n  static install: PluginFunction<VuetifyUseOptions>\n  static version: string\n  static config: Config\n\n  framework: Framework\n  preset: VuetifyPreset\n  userPreset: UserVuetifyPreset\n}\n\nexport interface Config {\n  silent: boolean\n}\n\nexport { Presets, VuetifyPreset, UserVuetifyPreset } from './services/presets'\n\nexport type ComponentOrPack = Component & {\n  $_vuetify_subcomponents?: Record<string, ComponentOrPack>\n}\n\nexport interface VuetifyUseOptions {\n  transitions?: Record<string, VueConstructor>\n  directives?: Record<string, DirectiveOptions>\n  components?: Record<string, ComponentOrPack>\n}\n\nexport interface Framework {\n  readonly breakpoint: Breakpoint\n  readonly goTo: (target: VuetifyGoToTarget, options?: GoToOptions) => Promise<number>\n  application: Application\n  theme: Theme\n  icons: Icons\n  lang: Lang\n  presets: Presets\n  rtl: boolean\n}\n\ndeclare module 'vue/types/vue' {\n  export interface Vue {\n    $vuetify: Framework\n  }\n}\n\ndeclare module 'vue/types/options' {\n  export interface ComponentOptions<\n    V extends Vue,\n    Data=DefaultData<V>,\n    Methods=DefaultMethods<V>,\n    Computed=DefaultComputed,\n    PropsDef=PropsDefinition<DefaultProps>,\n    Props=DefaultProps> {\n    vuetify?: Vuetify\n  }\n}\n\n// Public types\nexport type TreeviewItemFunction = (item: object, search: string, textKey: string) => boolean\n\nexport type SelectItemKey = string | (string | number)[] | ((item: object, fallback?: any) => any)\n\nexport interface ItemGroup<T> {\n  name: string\n  items: T[]\n}\n\nexport interface DataOptions {\n  page: number\n  itemsPerPage: number\n  sortBy: string[]\n  sortDesc: boolean[]\n  groupBy: string[]\n  groupDesc: boolean[]\n  multiSort: boolean\n  mustSort: boolean\n}\n\nexport interface DataPagination {\n  page: number\n  itemsPerPage: number\n  pageStart: number\n  pageStop: number\n  pageCount: number\n  itemsLength: number\n}\n\nexport interface DataItemProps {\n  index: number\n  item: any\n  select: (v: boolean) => void\n  isSelected: boolean\n  expand: (v: boolean) => void\n  isExpanded: boolean\n  isMobile: boolean\n}\n\nexport interface DataTableItemProps extends DataItemProps {\n  headers: DataTableHeader[]\n}\n\nexport interface DataScopeProps {\n  originalItemsLength: number\n  items: any[]\n  pagination: DataPagination\n  options: DataOptions\n  updateOptions: (obj: any) => void\n  sort: (value: string) => void\n  sortArray: (sortBy: string[]) => void\n  group: (value: string) => void\n  groupedItems: ItemGroup<any>[] | null\n}\n\nexport type DataTableCompareFunction<T = any> = (a: T, b: T) => number\n\nexport type DataSortFunction<T extends any = any> = (\n  items: T[],\n  sortBy: string[],\n  sortDesc: boolean[],\n  locale: string,\n  customSorters?: Record<string, DataTableCompareFunction<T>>\n) => T[];\n\nexport type DataGroupFunction<T extends any = any> = (\n  items: T[],\n  groupBy: string[],\n  groupDesc: boolean[],\n) => ItemGroup<T>[]\n\nexport type DataSearchFunction<T extends any = any> = (items: T[], search: string) => T[]\n\nexport type DatePickerFormatter = (date: string) => string\n\nexport type DatePickerAllowedDatesFunction = (date: string) => boolean\n\nexport type DatePickerEventColorValue = string | string[]\n\nexport type DatePickerEvents = string[] | ((date: string) => boolean | DatePickerEventColorValue) | Record<string, DatePickerEventColorValue>\n\nexport type DatePickerEventColors = DatePickerEventColorValue | Record<string, DatePickerEventColorValue> | ((date: string) => DatePickerEventColorValue)\n\nexport type DatePickerType = 'date' | 'month'\n\nexport type DatePickerMultipleFormatter = (date: string[]) => string\n\nexport interface TouchHandlers {\n  start?: (wrapperEvent: TouchEvent & TouchWrapper) => void\n  end?: (wrapperEvent: TouchEvent & TouchWrapper) => void\n  move?: (wrapperEvent: TouchEvent & TouchWrapper) => void\n  left?: (wrapper: TouchWrapper) => void\n  right?: (wrapper: TouchWrapper) => void\n  up?: (wrapper: TouchWrapper) => void\n  down?: (wrapper: TouchWrapper) => void\n}\n\nexport interface TouchWrapper extends TouchHandlers {\n  touchstartX: number\n  touchstartY: number\n  touchmoveX: number\n  touchmoveY: number\n  touchendX: number\n  touchendY: number\n  offsetX: number\n  offsetY: number\n}\n\nexport type TouchValue = TouchHandlers & {\n  parent?: boolean\n  options?: AddEventListenerOptions\n}\n\nexport type InputValidationRule = (value: any) => string | boolean\n\nexport type InputMessage = string | string[]\n\nexport type InputValidationRules = (InputValidationRule | string)[]\n\nexport type CalendarCategory =\n  | string\n  | {\n      name?: string\n      categoryName?: string\n      [key: string]: any\n    }\n\nexport type CalendarCategoryTextFunction = (\n  category: CalendarCategory\n) => string\n\nexport interface CalendarTimestamp {\n  date: string\n  time: string\n  year: number\n  month: number\n  day: number\n  weekday: number\n  hour: number\n  minute: number\n  hasDay: boolean\n  hasTime: boolean\n  past: boolean\n  present: boolean\n  future: boolean\n  category?: CalendarCategory\n}\n\nexport type CalendarFormatter = (timestamp: CalendarTimestamp, short: boolean) => string\n\nexport interface CalendarEvent {\n  [prop: string]: any\n}\n\nexport interface CalendarEventParsed {\n  input: CalendarEvent\n  start: CalendarTimestamp\n  startIdentifier: number\n  startTimestampIdentifier: number\n  end: CalendarTimestamp\n  endIdentifier: number\n  endTimestampIdentifier: number\n  allDay: boolean\n  index: number\n  category: string | false\n}\n\nexport interface CalendarEventVisual {\n  event: CalendarEventParsed\n  columnCount: number\n  column: number\n  left: number\n  width: number\n}\n\nexport interface CalendarDaySlotScope extends CalendarTimestamp {\n  outside: boolean\n  index: number\n  week: CalendarTimestamp[]\n  category: CalendarCategory\n}\n\nexport type CalendarTimeToY = (time: CalendarTimestamp | number | string, clamp?: boolean) => number\n\nexport type CalendarTimeDelta = (time: CalendarTimestamp | number | string) => number | false\n\nexport interface CalendarDayBodySlotScope extends CalendarDaySlotScope {\n  timeToY: CalendarTimeToY\n  timeDelta: CalendarTimeDelta\n}\n\nexport type CalendarEventOverlapMode = (events: CalendarEventParsed[], firstWeekday: number, overlapThreshold: number) => (day: CalendarDaySlotScope, dayEvents: CalendarEventParsed[], timed: boolean, reset: boolean) => CalendarEventVisual[]\n\nexport type CalendarEventColorFunction = (event: CalendarEvent) => string\n\nexport type CalendarEventTimedFunction = (event: CalendarEvent) => boolean\n\nexport type CalendarEventCategoryFunction = (event: CalendarEvent) => string\n\nexport type CalendarEventNameFunction = (event: CalendarEventParsed, timedEvent: boolean) => string\n\nexport type DataTableFilterFunction = (value: any, search: string | null, item: any) => boolean\n\nexport interface DataTableHeader<T extends any = any> {\n  text: string\n  value: string\n  align?: 'start' | 'center' | 'end'\n  sortable?: boolean\n  filterable?: boolean\n  groupable?: boolean\n  divider?: boolean\n  class?: string | string[]\n  cellClass?: string | string[]\n  width?: string | number\n  filter?: (value: any, search: string | null, item: any) => boolean\n  sort?: DataTableCompareFunction<T>\n}\n\nexport type DataItemsPerPageOption = (number | {\n  text: string\n  value: number\n});\n\nexport type RowClassFunction = (item: any) => null | undefined | string | string[] | Record<string, boolean>\n"], "fixing_code": ["// Styles\nimport './calendar-with-events.sass'\n\n// Types\nimport { VNode, VNodeData } from 'vue'\n\n// Directives\nimport ripple from '../../../directives/ripple'\n\n// Mixins\nimport CalendarBase from './calendar-base'\n\n// Util\nimport props from '../util/props'\nimport {\n  CalendarEventOverlapModes,\n} from '../modes'\nimport {\n  getDayIdentifier, diffMinutes,\n} from '../util/timestamp'\nimport {\n  parseEvent,\n  isEventStart,\n  isEventOn,\n  isEventOverlapping,\n  isEventHiddenOn,\n} from '../util/events'\nimport {\n  CalendarTimestamp,\n  CalendarEventParsed,\n  CalendarEventVisual,\n  CalendarEventColorFunction,\n  CalendarEventNameFunction,\n  CalendarEventTimedFunction,\n  CalendarDaySlotScope,\n  CalendarDayBodySlotScope,\n  CalendarEventOverlapMode,\n  CalendarEvent,\n  CalendarEventCategoryFunction,\n  CalendarCategory,\n} from 'vuetify/types'\n\n// Types\ntype VEventGetter<D> = (day: D) => CalendarEventParsed[]\n\ntype VEventVisualToNode<D> = (visual: CalendarEventVisual, day: D) => VNode | false\n\ntype VEventsToNodes = <D extends CalendarDaySlotScope>(\n  day: D,\n  getter: VEventGetter<D>,\n  mapper: VEventVisualToNode<D>,\n  timed: boolean) => VNode[] | undefined\n\ntype VDailyEventsMap = {\n  [date: string]: {\n    parent: HTMLElement\n    more: HTMLElement | null\n    events: HTMLElement[]\n  }\n}\n\ninterface VEventScopeInput {\n  eventParsed: CalendarEventParsed\n  day: CalendarDaySlotScope\n  start: boolean\n  end: boolean\n  timed: boolean\n}\n\nconst WIDTH_FULL = 100\nconst WIDTH_START = 95\nconst MINUTES_IN_DAY = 1440\n\n/* @vue/component */\nexport default CalendarBase.extend({\n  name: 'calendar-with-events',\n\n  directives: {\n    ripple,\n  },\n\n  props: {\n    ...props.events,\n    ...props.calendar,\n    ...props.category,\n  },\n\n  computed: {\n    noEvents (): boolean {\n      return this.events.length === 0\n    },\n    parsedEvents (): CalendarEventParsed[] {\n      return this.events.map(this.parseEvent)\n    },\n    parsedEventOverlapThreshold (): number {\n      return parseInt(this.eventOverlapThreshold)\n    },\n    eventTimedFunction (): CalendarEventTimedFunction {\n      return typeof this.eventTimed === 'function'\n        ? this.eventTimed\n        : event => !!event[this.eventTimed as string]\n    },\n    eventCategoryFunction (): CalendarEventCategoryFunction {\n      return typeof this.eventCategory === 'function'\n        ? this.eventCategory\n        : event => event[this.eventCategory as string]\n    },\n    eventTextColorFunction (): CalendarEventColorFunction {\n      return typeof this.eventTextColor === 'function'\n        ? this.eventTextColor\n        : () => this.eventTextColor as string\n    },\n    eventNameFunction (): CalendarEventNameFunction {\n      return typeof this.eventName === 'function'\n        ? this.eventName\n        : (event, timedEvent) => event.input[this.eventName as string] as string || ''\n    },\n    eventModeFunction (): CalendarEventOverlapMode {\n      return typeof this.eventOverlapMode === 'function'\n        ? this.eventOverlapMode\n        : CalendarEventOverlapModes[this.eventOverlapMode]\n    },\n    eventWeekdays (): number[] {\n      return this.parsedWeekdays\n    },\n    categoryMode (): boolean {\n      return this.type === 'category'\n    },\n  },\n\n  methods: {\n    eventColorFunction (e: CalendarEvent): string {\n      return typeof this.eventColor === 'function'\n        ? this.eventColor(e)\n        : e.color || this.eventColor\n    },\n    parseEvent (input: CalendarEvent, index = 0): CalendarEventParsed {\n      return parseEvent(\n        input,\n        index,\n        this.eventStart,\n        this.eventEnd,\n        this.eventTimedFunction(input),\n        this.categoryMode ? this.eventCategoryFunction(input) : false,\n      )\n    },\n    formatTime (withTime: CalendarTimestamp, ampm: boolean): string {\n      const formatter = this.getFormatter({\n        timeZone: 'UTC',\n        hour: 'numeric',\n        minute: withTime.minute > 0 ? 'numeric' : undefined,\n      })\n\n      return formatter(withTime, true)\n    },\n    updateEventVisibility () {\n      if (this.noEvents || !this.eventMore) {\n        return\n      }\n\n      const eventHeight = this.eventHeight\n      const eventsMap = this.getEventsMap()\n\n      for (const date in eventsMap) {\n        const { parent, events, more } = eventsMap[date]\n        if (!more) {\n          break\n        }\n\n        const parentBounds = parent.getBoundingClientRect()\n        const last = events.length - 1\n        const eventsSorted = events.map(event => ({\n          event,\n          bottom: event.getBoundingClientRect().bottom,\n        })).sort((a, b) => a.bottom - b.bottom)\n        let hidden = 0\n\n        for (let i = 0; i <= last; i++) {\n          const bottom = eventsSorted[i].bottom\n          const hide = i === last\n            ? (bottom > parentBounds.bottom)\n            : (bottom + eventHeight > parentBounds.bottom)\n\n          if (hide) {\n            eventsSorted[i].event.style.display = 'none'\n            hidden++\n          }\n        }\n\n        if (hidden) {\n          more.style.display = ''\n          more.innerHTML = this.$vuetify.lang.t(this.eventMoreText, hidden)\n        } else {\n          more.style.display = 'none'\n        }\n      }\n    },\n    getEventsMap (): VDailyEventsMap {\n      const eventsMap: VDailyEventsMap = {}\n      const elements = this.$refs.events as HTMLElement[]\n\n      if (!elements || !elements.forEach) {\n        return eventsMap\n      }\n\n      elements.forEach(el => {\n        const date = el.getAttribute('data-date')\n        if (el.parentElement && date) {\n          if (!(date in eventsMap)) {\n            eventsMap[date] = {\n              parent: el.parentElement,\n              more: null,\n              events: [],\n            }\n          }\n          if (el.getAttribute('data-more')) {\n            eventsMap[date].more = el\n          } else {\n            eventsMap[date].events.push(el)\n            el.style.display = ''\n          }\n        }\n      })\n\n      return eventsMap\n    },\n    genDayEvent ({ event }: CalendarEventVisual, day: CalendarDaySlotScope): VNode {\n      const eventHeight = this.eventHeight\n      const eventMarginBottom = this.eventMarginBottom\n      const dayIdentifier = getDayIdentifier(day)\n      const week = day.week\n      const start = dayIdentifier === event.startIdentifier\n      let end = dayIdentifier === event.endIdentifier\n      let width = WIDTH_START\n\n      if (!this.categoryMode) {\n        for (let i = day.index + 1; i < week.length; i++) {\n          const weekdayIdentifier = getDayIdentifier(week[i])\n          if (event.endIdentifier >= weekdayIdentifier) {\n            width += WIDTH_FULL\n            end = end || weekdayIdentifier === event.endIdentifier\n          } else {\n            end = true\n            break\n          }\n        }\n      }\n      const scope = { eventParsed: event, day, start, end, timed: false }\n\n      return this.genEvent(event, scope, false, {\n        staticClass: 'v-event',\n        class: {\n          'v-event-start': start,\n          'v-event-end': end,\n        },\n        style: {\n          height: `${eventHeight}px`,\n          width: `${width}%`,\n          'margin-bottom': `${eventMarginBottom}px`,\n        },\n        attrs: {\n          'data-date': day.date,\n        },\n        key: event.index,\n        ref: 'events',\n        refInFor: true,\n      })\n    },\n    genTimedEvent ({ event, left, width }: CalendarEventVisual, day: CalendarDayBodySlotScope): VNode | false {\n      if (day.timeDelta(event.end) < 0 || day.timeDelta(event.start) >= 1 || isEventHiddenOn(event, day)) {\n        return false\n      }\n\n      const dayIdentifier = getDayIdentifier(day)\n      const start = event.startIdentifier >= dayIdentifier\n      const end = event.endIdentifier > dayIdentifier\n      const top = start ? day.timeToY(event.start) : 0\n      const bottom = end ? day.timeToY(MINUTES_IN_DAY) : day.timeToY(event.end)\n      const height = Math.max(this.eventHeight, bottom - top)\n      const scope = { eventParsed: event, day, start, end, timed: true }\n\n      return this.genEvent(event, scope, true, {\n        staticClass: 'v-event-timed',\n        style: {\n          top: `${top}px`,\n          height: `${height}px`,\n          left: `${left}%`,\n          width: `${width}%`,\n        },\n      })\n    },\n    genEvent (event: CalendarEventParsed, scopeInput: VEventScopeInput, timedEvent: boolean, data: VNodeData): VNode {\n      const slot = this.$scopedSlots.event\n      const text = this.eventTextColorFunction(event.input)\n      const background = this.eventColorFunction(event.input)\n      const overlapsNoon = event.start.hour < 12 && event.end.hour >= 12\n      const singline = diffMinutes(event.start, event.end) <= this.parsedEventOverlapThreshold\n      const formatTime = this.formatTime\n      const timeSummary = () => formatTime(event.start, overlapsNoon) + ' - ' + formatTime(event.end, true)\n      const eventSummary = () => {\n        const name = this.eventNameFunction(event, timedEvent)\n        if (event.start.hasTime) {\n          if (timedEvent) {\n            const time = timeSummary()\n            const delimiter = singline ? ', ' : this.$createElement('br')\n\n            return this.$createElement('span', { staticClass: 'v-event-summary' }, [\n              this.$createElement('strong', [name]),\n              delimiter,\n              time,\n            ])\n          } else {\n            const time = formatTime(event.start, true)\n\n            return this.$createElement('span', { staticClass: 'v-event-summary' }, [\n              this.$createElement('strong', [time]),\n              ' ',\n              name,\n            ])\n          }\n        }\n\n        return name\n      }\n\n      const scope = {\n        ...scopeInput,\n        event: event.input,\n        outside: scopeInput.day.outside,\n        singline,\n        overlapsNoon,\n        formatTime,\n        timeSummary,\n        eventSummary,\n      }\n\n      return this.$createElement('div',\n        this.setTextColor(text,\n          this.setBackgroundColor(background, {\n            on: this.getDefaultMouseEventHandlers(':event', nativeEvent => ({ ...scope, nativeEvent })),\n            directives: [{\n              name: 'ripple',\n              value: this.eventRipple ?? true,\n            }],\n            ...data,\n          })\n        ), slot\n          ? slot(scope)\n          : [this.genName(eventSummary)]\n      )\n    },\n    genName (eventSummary: () => string | VNode): VNode {\n      return this.$createElement('div', {\n        staticClass: 'pl-1',\n      }, [eventSummary()])\n    },\n    genPlaceholder (day: CalendarTimestamp): VNode {\n      const height = this.eventHeight + this.eventMarginBottom\n\n      return this.$createElement('div', {\n        style: {\n          height: `${height}px`,\n        },\n        attrs: {\n          'data-date': day.date,\n        },\n        ref: 'events',\n        refInFor: true,\n      })\n    },\n    genMore (day: CalendarDaySlotScope): VNode {\n      const eventHeight = this.eventHeight\n      const eventMarginBottom = this.eventMarginBottom\n\n      return this.$createElement('div', {\n        staticClass: 'v-event-more pl-1',\n        class: {\n          'v-outside': day.outside,\n        },\n        attrs: {\n          'data-date': day.date,\n          'data-more': 1,\n        },\n        directives: [{\n          name: 'ripple',\n          value: this.eventRipple ?? true,\n        }],\n        on: this.getDefaultMouseEventHandlers(':more', nativeEvent => {\n          return { nativeEvent, ...day }\n        }),\n\n        style: {\n          display: 'none',\n          height: `${eventHeight}px`,\n          'margin-bottom': `${eventMarginBottom}px`,\n        },\n        ref: 'events',\n        refInFor: true,\n      })\n    },\n    getVisibleEvents (): CalendarEventParsed[] {\n      const start = getDayIdentifier(this.days[0])\n      const end = getDayIdentifier(this.days[this.days.length - 1])\n\n      return this.parsedEvents.filter(\n        event => isEventOverlapping(event, start, end)\n      )\n    },\n    isEventForCategory (event: CalendarEventParsed, category: CalendarCategory): boolean {\n      return !this.categoryMode ||\n        (typeof category === 'object' && category.categoryName &&\n        category.categoryName === event.category) ||\n        (typeof event.category === 'string' && category === event.category) ||\n        (typeof event.category !== 'string' && category === null)\n    },\n    getEventsForDay (day: CalendarDaySlotScope): CalendarEventParsed[] {\n      const identifier = getDayIdentifier(day)\n      const firstWeekday = this.eventWeekdays[0]\n\n      return this.parsedEvents.filter(\n        event => isEventStart(event, day, identifier, firstWeekday)\n      )\n    },\n    getEventsForDayAll (day: CalendarDaySlotScope): CalendarEventParsed[] {\n      const identifier = getDayIdentifier(day)\n      const firstWeekday = this.eventWeekdays[0]\n\n      return this.parsedEvents.filter(\n        event => event.allDay &&\n          (this.categoryMode ? isEventOn(event, identifier) : isEventStart(event, day, identifier, firstWeekday)) &&\n          this.isEventForCategory(event, day.category)\n      )\n    },\n    getEventsForDayTimed (day: CalendarDaySlotScope): CalendarEventParsed[] {\n      const identifier = getDayIdentifier(day)\n      return this.parsedEvents.filter(\n        event => !event.allDay &&\n          isEventOn(event, identifier) &&\n          this.isEventForCategory(event, day.category)\n      )\n    },\n    getScopedSlots () {\n      if (this.noEvents) {\n        return { ...this.$scopedSlots }\n      }\n\n      const mode = this.eventModeFunction(\n        this.parsedEvents,\n        this.eventWeekdays[0],\n        this.parsedEventOverlapThreshold\n      )\n\n      const isNode = (input: VNode | false): input is VNode => !!input\n      const getSlotChildren: VEventsToNodes = (day, getter, mapper, timed) => {\n        const events = getter(day)\n        const visuals = mode(day, events, timed, this.categoryMode)\n\n        if (timed) {\n          return visuals.map(visual => mapper(visual, day)).filter(isNode)\n        }\n\n        const children: VNode[] = []\n\n        visuals.forEach((visual, index) => {\n          while (children.length < visual.column) {\n            children.push(this.genPlaceholder(day))\n          }\n\n          const mapped = mapper(visual, day)\n          if (mapped) {\n            children.push(mapped)\n          }\n        })\n\n        return children\n      }\n\n      const slots = this.$scopedSlots\n      const slotDay = slots.day\n      const slotDayHeader = slots['day-header']\n      const slotDayBody = slots['day-body']\n\n      return {\n        ...slots,\n        day: (day: CalendarDaySlotScope) => {\n          let children = getSlotChildren(day, this.getEventsForDay, this.genDayEvent, false)\n          if (children && children.length > 0 && this.eventMore) {\n            children.push(this.genMore(day))\n          }\n          if (slotDay) {\n            const slot = slotDay(day)\n            if (slot) {\n              children = children ? children.concat(slot) : slot\n            }\n          }\n          return children\n        },\n        'day-header': (day: CalendarDaySlotScope) => {\n          let children = getSlotChildren(day, this.getEventsForDayAll, this.genDayEvent, false)\n\n          if (slotDayHeader) {\n            const slot = slotDayHeader(day)\n            if (slot) {\n              children = children ? children.concat(slot) : slot\n            }\n          }\n          return children\n        },\n        'day-body': (day: CalendarDayBodySlotScope) => {\n          const events = getSlotChildren(day, this.getEventsForDayTimed, this.genTimedEvent, true)\n          let children: VNode[] = [\n            this.$createElement('div', {\n              staticClass: 'v-event-timed-container',\n            }, events),\n          ]\n\n          if (slotDayBody) {\n            const slot = slotDayBody(day)\n            if (slot) {\n              children = children.concat(slot)\n            }\n          }\n          return children\n        },\n      }\n    },\n  },\n})\n", "import Vue, { Component, PluginFunction, VueConstructor, DirectiveOptions, VNode } from 'vue'\nimport './lib'\nimport './alacarte'\nimport './colors'\n\n// Services\nimport { Application } from './services/application'\nimport { Breakpoint } from './services/breakpoint'\nimport { Icons } from './services/icons'\nimport { Lang } from './services/lang'\nimport { Theme } from './services/theme'\nimport {\n  Presets,\n  UserVuetifyPreset,\n  VuetifyPreset,\n} from './services/presets'\n\n// Service Options\nimport { GoToOptions, VuetifyGoToTarget } from './services/goto'\n\nexport default class Vuetify {\n  constructor (preset?: Partial<UserVuetifyPreset>)\n\n  static install: PluginFunction<VuetifyUseOptions>\n  static version: string\n  static config: Config\n\n  framework: Framework\n  preset: VuetifyPreset\n  userPreset: UserVuetifyPreset\n}\n\nexport interface Config {\n  silent: boolean\n}\n\nexport { Presets, VuetifyPreset, UserVuetifyPreset } from './services/presets'\n\nexport type ComponentOrPack = Component & {\n  $_vuetify_subcomponents?: Record<string, ComponentOrPack>\n}\n\nexport interface VuetifyUseOptions {\n  transitions?: Record<string, VueConstructor>\n  directives?: Record<string, DirectiveOptions>\n  components?: Record<string, ComponentOrPack>\n}\n\nexport interface Framework {\n  readonly breakpoint: Breakpoint\n  readonly goTo: (target: VuetifyGoToTarget, options?: GoToOptions) => Promise<number>\n  application: Application\n  theme: Theme\n  icons: Icons\n  lang: Lang\n  presets: Presets\n  rtl: boolean\n}\n\ndeclare module 'vue/types/vue' {\n  export interface Vue {\n    $vuetify: Framework\n  }\n}\n\ndeclare module 'vue/types/options' {\n  export interface ComponentOptions<\n    V extends Vue,\n    Data=DefaultData<V>,\n    Methods=DefaultMethods<V>,\n    Computed=DefaultComputed,\n    PropsDef=PropsDefinition<DefaultProps>,\n    Props=DefaultProps> {\n    vuetify?: Vuetify\n  }\n}\n\n// Public types\nexport type TreeviewItemFunction = (item: object, search: string, textKey: string) => boolean\n\nexport type SelectItemKey = string | (string | number)[] | ((item: object, fallback?: any) => any)\n\nexport interface ItemGroup<T> {\n  name: string\n  items: T[]\n}\n\nexport interface DataOptions {\n  page: number\n  itemsPerPage: number\n  sortBy: string[]\n  sortDesc: boolean[]\n  groupBy: string[]\n  groupDesc: boolean[]\n  multiSort: boolean\n  mustSort: boolean\n}\n\nexport interface DataPagination {\n  page: number\n  itemsPerPage: number\n  pageStart: number\n  pageStop: number\n  pageCount: number\n  itemsLength: number\n}\n\nexport interface DataItemProps {\n  index: number\n  item: any\n  select: (v: boolean) => void\n  isSelected: boolean\n  expand: (v: boolean) => void\n  isExpanded: boolean\n  isMobile: boolean\n}\n\nexport interface DataTableItemProps extends DataItemProps {\n  headers: DataTableHeader[]\n}\n\nexport interface DataScopeProps {\n  originalItemsLength: number\n  items: any[]\n  pagination: DataPagination\n  options: DataOptions\n  updateOptions: (obj: any) => void\n  sort: (value: string) => void\n  sortArray: (sortBy: string[]) => void\n  group: (value: string) => void\n  groupedItems: ItemGroup<any>[] | null\n}\n\nexport type DataTableCompareFunction<T = any> = (a: T, b: T) => number\n\nexport type DataSortFunction<T extends any = any> = (\n  items: T[],\n  sortBy: string[],\n  sortDesc: boolean[],\n  locale: string,\n  customSorters?: Record<string, DataTableCompareFunction<T>>\n) => T[];\n\nexport type DataGroupFunction<T extends any = any> = (\n  items: T[],\n  groupBy: string[],\n  groupDesc: boolean[],\n) => ItemGroup<T>[]\n\nexport type DataSearchFunction<T extends any = any> = (items: T[], search: string) => T[]\n\nexport type DatePickerFormatter = (date: string) => string\n\nexport type DatePickerAllowedDatesFunction = (date: string) => boolean\n\nexport type DatePickerEventColorValue = string | string[]\n\nexport type DatePickerEvents = string[] | ((date: string) => boolean | DatePickerEventColorValue) | Record<string, DatePickerEventColorValue>\n\nexport type DatePickerEventColors = DatePickerEventColorValue | Record<string, DatePickerEventColorValue> | ((date: string) => DatePickerEventColorValue)\n\nexport type DatePickerType = 'date' | 'month'\n\nexport type DatePickerMultipleFormatter = (date: string[]) => string\n\nexport interface TouchHandlers {\n  start?: (wrapperEvent: TouchEvent & TouchWrapper) => void\n  end?: (wrapperEvent: TouchEvent & TouchWrapper) => void\n  move?: (wrapperEvent: TouchEvent & TouchWrapper) => void\n  left?: (wrapper: TouchWrapper) => void\n  right?: (wrapper: TouchWrapper) => void\n  up?: (wrapper: TouchWrapper) => void\n  down?: (wrapper: TouchWrapper) => void\n}\n\nexport interface TouchWrapper extends TouchHandlers {\n  touchstartX: number\n  touchstartY: number\n  touchmoveX: number\n  touchmoveY: number\n  touchendX: number\n  touchendY: number\n  offsetX: number\n  offsetY: number\n}\n\nexport type TouchValue = TouchHandlers & {\n  parent?: boolean\n  options?: AddEventListenerOptions\n}\n\nexport type InputValidationRule = (value: any) => string | boolean\n\nexport type InputMessage = string | string[]\n\nexport type InputValidationRules = (InputValidationRule | string)[]\n\nexport type CalendarCategory =\n  | string\n  | {\n      name?: string\n      categoryName?: string\n      [key: string]: any\n    }\n\nexport type CalendarCategoryTextFunction = (\n  category: CalendarCategory\n) => string\n\nexport interface CalendarTimestamp {\n  date: string\n  time: string\n  year: number\n  month: number\n  day: number\n  weekday: number\n  hour: number\n  minute: number\n  hasDay: boolean\n  hasTime: boolean\n  past: boolean\n  present: boolean\n  future: boolean\n  category?: CalendarCategory\n}\n\nexport type CalendarFormatter = (timestamp: CalendarTimestamp, short: boolean) => string\n\nexport interface CalendarEvent {\n  [prop: string]: any\n}\n\nexport interface CalendarEventParsed {\n  input: CalendarEvent\n  start: CalendarTimestamp\n  startIdentifier: number\n  startTimestampIdentifier: number\n  end: CalendarTimestamp\n  endIdentifier: number\n  endTimestampIdentifier: number\n  allDay: boolean\n  index: number\n  category: string | false\n}\n\nexport interface CalendarEventVisual {\n  event: CalendarEventParsed\n  columnCount: number\n  column: number\n  left: number\n  width: number\n}\n\nexport interface CalendarDaySlotScope extends CalendarTimestamp {\n  outside: boolean\n  index: number\n  week: CalendarTimestamp[]\n  category: CalendarCategory\n}\n\nexport type CalendarTimeToY = (time: CalendarTimestamp | number | string, clamp?: boolean) => number\n\nexport type CalendarTimeDelta = (time: CalendarTimestamp | number | string) => number | false\n\nexport interface CalendarDayBodySlotScope extends CalendarDaySlotScope {\n  timeToY: CalendarTimeToY\n  timeDelta: CalendarTimeDelta\n}\n\nexport type CalendarEventOverlapMode = (events: CalendarEventParsed[], firstWeekday: number, overlapThreshold: number) => (day: CalendarDaySlotScope, dayEvents: CalendarEventParsed[], timed: boolean, reset: boolean) => CalendarEventVisual[]\n\nexport type CalendarEventColorFunction = (event: CalendarEvent) => string\n\nexport type CalendarEventTimedFunction = (event: CalendarEvent) => boolean\n\nexport type CalendarEventCategoryFunction = (event: CalendarEvent) => string\n\nexport type CalendarEventNameFunction = (event: CalendarEventParsed, timedEvent: boolean) => string | VNode\n\nexport type DataTableFilterFunction = (value: any, search: string | null, item: any) => boolean\n\nexport interface DataTableHeader<T extends any = any> {\n  text: string\n  value: string\n  align?: 'start' | 'center' | 'end'\n  sortable?: boolean\n  filterable?: boolean\n  groupable?: boolean\n  divider?: boolean\n  class?: string | string[]\n  cellClass?: string | string[]\n  width?: string | number\n  filter?: (value: any, search: string | null, item: any) => boolean\n  sort?: DataTableCompareFunction<T>\n}\n\nexport type DataItemsPerPageOption = (number | {\n  text: string\n  value: number\n});\n\nexport type RowClassFunction = (item: any) => null | undefined | string | string[] | Record<string, boolean>\n"], "filenames": ["packages/vuetify/src/components/VCalendar/mixins/calendar-with-events.ts", "packages/vuetify/types/index.d.ts"], "buggy_code_start_loc": [12, 1], "buggy_code_end_loc": [355, 279], "fixing_code_start_loc": [11, 1], "fixing_code_end_loc": [356, 279], "type": "CWE-79", "message": "The package vuetify from 2.0.0-beta.4 and before 2.6.10 are vulnerable to Cross-site Scripting (XSS) due to improper input sanitization in the 'eventName' function within the VCalendar component.", "other": {"cve": {"id": "CVE-2022-25873", "sourceIdentifier": "report@snyk.io", "published": "2022-09-18T15:15:09.660", "lastModified": "2022-09-21T12:49:39.937", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package vuetify from 2.0.0-beta.4 and before 2.6.10 are vulnerable to Cross-site Scripting (XSS) due to improper input sanitization in the 'eventName' function within the VCalendar component."}, {"lang": "es", "value": "El paquete vuetify a partir de la versi\u00f3n 2.0.0-beta.4 anteriores a 2.6.10 es vulnerable a un ataque de tipo Cross-site Scripting (XSS) debido a una saneo inapropiado de la entrada en la funci\u00f3n \"eventName\" dentro del componente VCalendar"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 2.5}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vuetifyjs:vuetify:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.1", "versionEndExcluding": "2.6.10", "matchCriteriaId": "5717CAE6-B23D-4EE0-88A8-5A98FF6D68E2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vuetifyjs:vuetify:2.0.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "C8EA2D38-E38D-4913-82FF-949BD4358B6A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vuetifyjs:vuetify:2.0.0:beta5:*:*:*:*:*:*", "matchCriteriaId": "3B9DD644-5DC7-4297-B2B7-318242E112AD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vuetifyjs:vuetify:2.0.0:beta6:*:*:*:*:*:*", "matchCriteriaId": "2BF63ECA-F9A5-4269-ACF1-717401F5A6FB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vuetifyjs:vuetify:2.0.0:beta7:*:*:*:*:*:*", "matchCriteriaId": "6C2F172F-EB66-4864-8D7A-F15BDFCBD84D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vuetifyjs:vuetify:2.0.0:beta8:*:*:*:*:*:*", "matchCriteriaId": "ADE7EEE9-F3C0-46E7-87BD-1BEB43B73945"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vuetifyjs:vuetify:2.0.0:beta9:*:*:*:*:*:*", "matchCriteriaId": "2E21A173-87E5-4F49-A9A4-5018664D3576"}]}]}], "references": [{"url": "https://codepen.io/5v3n-08/pen/MWGKEjY", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/vuetifyjs/vuetify/commit/ade1434927f55a0eccf3d54f900f24c5fa85a176", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/vuetifyjs/vuetify/issues/15757", "source": "report@snyk.io", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://security.snyk.io/vuln/SNYK-JAVA-ORGWEBJARSBOWERGITHUBVUETIFYJS-3024407", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}, {"url": "https://security.snyk.io/vuln/SNYK-JAVA-ORGWEBJARSNPM-3024406", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}, {"url": "https://security.snyk.io/vuln/SNYK-JS-VUETIFY-3019858", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vuetifyjs/vuetify/commit/ade1434927f55a0eccf3d54f900f24c5fa85a176"}}