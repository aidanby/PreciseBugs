{"buggy_code": ["from django.contrib.auth import get_user_model\nfrom django.http import HttpRequest, HttpResponse\nfrom django.test import TestCase\nfrom django.urls import reverse\n\nfrom wagtail.test.utils import WagtailTestUtils\nfrom wagtail.users.views.bulk_actions.user_bulk_action import UserBulkAction\n\nUser = get_user_model()\n\n\nclass TestUserDeleteView(WagtailTestUtils, TestCase):\n    def setUp(self):\n        # create a set of test users\n        self.test_users = [\n            self.create_user(\n                username=f\"testuser-{i}\",\n                email=f\"testuser{i}@email.com\",\n                password=f\"password-{i}\",\n            )\n            for i in range(1, 6)\n        ]\n        # also create a superuser to delete\n        self.superuser = self.create_superuser(\n            username=\"testsuperuser\",\n            email=\"testsuperuser@email.com\",\n            password=\"password\",\n        )\n        self.current_user = self.login()\n        self.url = (\n            reverse(\n                \"wagtail_bulk_action\",\n                args=(\n                    User._meta.app_label,\n                    User._meta.model_name,\n                    \"delete\",\n                ),\n            )\n            + \"?\"\n        )\n        for user in self.test_users:\n            self.url += f\"id={user.pk}&\"\n\n        self.self_delete_url = self.url + f\"id={self.current_user.pk}\"\n        self.superuser_delete_url = self.url + f\"id={self.superuser.pk}\"\n\n    def test_simple(self):\n        response = self.client.get(self.url)\n        self.assertEqual(response.status_code, 200)\n        self.assertTemplateUsed(\n            response, \"wagtailusers/bulk_actions/confirm_bulk_delete.html\"\n        )\n\n    def test_bulk_delete(self):\n        response = self.client.post(self.url)\n\n        # Should redirect back to index\n        self.assertEqual(response.status_code, 302)\n\n        # Check that the users were deleted\n        for user in self.test_users:\n            self.assertFalse(User.objects.filter(email=user.email).exists())\n\n    def test_user_cannot_delete_self(self):\n        response = self.client.get(self.self_delete_url)\n\n        self.assertEqual(response.status_code, 200)\n        html = response.content.decode()\n        self.assertInHTML(\"<p>You don't have permission to delete this user</p>\", html)\n\n        needle = \"<ul>\"\n        needle += f\"<li>{self.current_user.email}</li>\"\n        needle += \"</ul>\"\n        self.assertInHTML(needle, html)\n\n        self.client.post(self.self_delete_url)\n\n        # Check user was not deleted\n        self.assertTrue(User.objects.filter(pk=self.current_user.pk).exists())\n\n    def test_user_can_delete_other_superuser(self):\n        response = self.client.get(self.superuser_delete_url)\n        self.assertEqual(response.status_code, 200)\n        self.assertTemplateUsed(\n            response, \"wagtailusers/bulk_actions/confirm_bulk_delete.html\"\n        )\n\n        response = self.client.post(self.superuser_delete_url)\n        # Should redirect back to index\n        self.assertEqual(response.status_code, 302)\n\n        # Check that the user was deleted\n        users = User.objects.filter(email=self.superuser.email)\n        self.assertEqual(users.count(), 0)\n\n    def test_before_delete_user_hook_post(self):\n        def hook_func(request, action_type, users, action_class_instance):\n            self.assertEqual(action_type, \"delete\")\n            self.assertIsInstance(request, HttpRequest)\n            self.assertIsInstance(action_class_instance, UserBulkAction)\n            self.assertCountEqual(\n                [user.pk for user in self.test_users], [user.pk for user in users]\n            )\n\n            return HttpResponse(\"Overridden!\")\n\n        with self.register_hook(\"before_bulk_action\", hook_func):\n            response = self.client.post(self.url)\n\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b\"Overridden!\")\n\n        for user in self.test_users:\n            self.assertTrue(User.objects.filter(email=user.email).exists())\n\n    def test_after_delete_user_hook(self):\n        def hook_func(request, action_type, users, action_class_instance):\n            self.assertEqual(action_type, \"delete\")\n            self.assertIsInstance(request, HttpRequest)\n            self.assertIsInstance(action_class_instance, UserBulkAction)\n\n            return HttpResponse(\"Overridden!\")\n\n        with self.register_hook(\"after_bulk_action\", hook_func):\n            response = self.client.post(self.url)\n\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b\"Overridden!\")\n\n        for user in self.test_users:\n            self.assertFalse(User.objects.filter(email=user.email).exists())\n", "from django.contrib.auth import get_user_model\n\nfrom wagtail.admin.views.bulk_action import BulkAction\nfrom wagtail.users.views.users import get_users_filter_query\n\n\nclass UserBulkAction(BulkAction):\n    models = [get_user_model()]\n\n    def get_all_objects_in_listing_query(self, parent_id):\n        listing_objects = self.model.objects.all().values_list(\"pk\", flat=True)\n        if \"q\" in self.request.GET:\n            q = self.request.GET.get(\"q\")\n            model_fields = {f.name for f in self.model._meta.get_fields()}\n            conditions = get_users_filter_query(q, model_fields)\n\n            listing_objects = listing_objects.filter(conditions)\n\n        return listing_objects\n"], "fixing_code": ["from django.contrib.auth import get_user_model\nfrom django.contrib.auth.models import Permission\nfrom django.http import HttpRequest, HttpResponse\nfrom django.test import TestCase\nfrom django.urls import reverse\n\nfrom wagtail.test.utils import WagtailTestUtils\nfrom wagtail.users.views.bulk_actions.user_bulk_action import UserBulkAction\n\nUser = get_user_model()\n\n\nclass TestUserDeleteView(WagtailTestUtils, TestCase):\n    def setUp(self):\n        # create a set of test users\n        self.test_users = [\n            self.create_user(\n                username=f\"testuser-{i}\",\n                email=f\"testuser{i}@email.com\",\n                password=f\"password-{i}\",\n            )\n            for i in range(1, 6)\n        ]\n        # also create a superuser to delete\n        self.superuser = self.create_superuser(\n            username=\"testsuperuser\",\n            email=\"testsuperuser@email.com\",\n            password=\"password\",\n        )\n        self.current_user = self.login()\n        self.url = (\n            reverse(\n                \"wagtail_bulk_action\",\n                args=(\n                    User._meta.app_label,\n                    User._meta.model_name,\n                    \"delete\",\n                ),\n            )\n            + \"?\"\n        )\n        for user in self.test_users:\n            self.url += f\"id={user.pk}&\"\n\n        self.self_delete_url = self.url + f\"id={self.current_user.pk}\"\n        self.superuser_delete_url = self.url + f\"id={self.superuser.pk}\"\n\n    def test_simple(self):\n        response = self.client.get(self.url)\n        self.assertEqual(response.status_code, 200)\n        self.assertTemplateUsed(\n            response, \"wagtailusers/bulk_actions/confirm_bulk_delete.html\"\n        )\n\n    def test_user_permissions_required(self):\n        # Log in with a user that doesn't have permission to delete users\n        user = self.create_user(username=\"editor\", password=\"password\")\n        admin_permission = Permission.objects.get(\n            content_type__app_label=\"wagtailadmin\", codename=\"access_admin\"\n        )\n        user.user_permissions.add(admin_permission)\n        self.login(username=\"editor\", password=\"password\")\n\n        response = self.client.get(self.url)\n        self.assertRedirects(response, \"/admin/\")\n\n    def test_bulk_delete(self):\n        response = self.client.post(self.url)\n\n        # Should redirect back to index\n        self.assertEqual(response.status_code, 302)\n\n        # Check that the users were deleted\n        for user in self.test_users:\n            self.assertFalse(User.objects.filter(email=user.email).exists())\n\n    def test_user_cannot_delete_self(self):\n        response = self.client.get(self.self_delete_url)\n\n        self.assertEqual(response.status_code, 200)\n        html = response.content.decode()\n        self.assertInHTML(\"<p>You don't have permission to delete this user</p>\", html)\n\n        needle = \"<ul>\"\n        needle += f\"<li>{self.current_user.email}</li>\"\n        needle += \"</ul>\"\n        self.assertInHTML(needle, html)\n\n        self.client.post(self.self_delete_url)\n\n        # Check user was not deleted\n        self.assertTrue(User.objects.filter(pk=self.current_user.pk).exists())\n\n    def test_user_can_delete_other_superuser(self):\n        response = self.client.get(self.superuser_delete_url)\n        self.assertEqual(response.status_code, 200)\n        self.assertTemplateUsed(\n            response, \"wagtailusers/bulk_actions/confirm_bulk_delete.html\"\n        )\n\n        response = self.client.post(self.superuser_delete_url)\n        # Should redirect back to index\n        self.assertEqual(response.status_code, 302)\n\n        # Check that the user was deleted\n        users = User.objects.filter(email=self.superuser.email)\n        self.assertEqual(users.count(), 0)\n\n    def test_before_delete_user_hook_post(self):\n        def hook_func(request, action_type, users, action_class_instance):\n            self.assertEqual(action_type, \"delete\")\n            self.assertIsInstance(request, HttpRequest)\n            self.assertIsInstance(action_class_instance, UserBulkAction)\n            self.assertCountEqual(\n                [user.pk for user in self.test_users], [user.pk for user in users]\n            )\n\n            return HttpResponse(\"Overridden!\")\n\n        with self.register_hook(\"before_bulk_action\", hook_func):\n            response = self.client.post(self.url)\n\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b\"Overridden!\")\n\n        for user in self.test_users:\n            self.assertTrue(User.objects.filter(email=user.email).exists())\n\n    def test_after_delete_user_hook(self):\n        def hook_func(request, action_type, users, action_class_instance):\n            self.assertEqual(action_type, \"delete\")\n            self.assertIsInstance(request, HttpRequest)\n            self.assertIsInstance(action_class_instance, UserBulkAction)\n\n            return HttpResponse(\"Overridden!\")\n\n        with self.register_hook(\"after_bulk_action\", hook_func):\n            response = self.client.post(self.url)\n\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b\"Overridden!\")\n\n        for user in self.test_users:\n            self.assertFalse(User.objects.filter(email=user.email).exists())\n", "from django.contrib.auth import get_user_model\n\nfrom wagtail.admin.views.bulk_action import BulkAction\nfrom wagtail.admin.views.generic.permissions import PermissionCheckedMixin\nfrom wagtail.permission_policies import ModelPermissionPolicy\nfrom wagtail.users.views.users import get_users_filter_query\n\nUser = get_user_model()\n\n\nclass UserBulkAction(PermissionCheckedMixin, BulkAction):\n    models = [User]\n    permission_policy = ModelPermissionPolicy(User)\n    any_permission_required = [\"add\", \"change\", \"delete\"]\n\n    def get_all_objects_in_listing_query(self, parent_id):\n        listing_objects = self.model.objects.all().values_list(\"pk\", flat=True)\n        if \"q\" in self.request.GET:\n            q = self.request.GET.get(\"q\")\n            model_fields = {f.name for f in self.model._meta.get_fields()}\n            conditions = get_users_filter_query(q, model_fields)\n\n            listing_objects = listing_objects.filter(conditions)\n\n        return listing_objects\n"], "filenames": ["wagtail/users/tests/test_bulk_actions/test_bulk_delete.py", "wagtail/users/views/bulk_actions/user_bulk_action.py"], "buggy_code_start_loc": [1, 3], "buggy_code_end_loc": [52, 9], "fixing_code_start_loc": [2, 4], "fixing_code_end_loc": [66, 15], "type": "CWE-532", "message": "Wagtail is an open source content management system built on Django. A user with a limited-permission editor account for the Wagtail admin can make a direct URL request to the admin view that handles bulk actions on user accounts. While authentication rules prevent the user from making any changes, the error message discloses the display names of user accounts, and by modifying URL parameters, the user can retrieve the display name for any user. The vulnerability is not exploitable by an ordinary site visitor without access to the Wagtail admin. Patched versions have been released as Wagtail 4.1.8 (LTS), 5.0.5 and 5.1.3. The fix is also included in Release Candidate 1 of the forthcoming Wagtail 5.2 release. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-45809", "sourceIdentifier": "security-advisories@github.com", "published": "2023-10-19T19:15:15.867", "lastModified": "2023-12-28T18:58:51.657", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Wagtail is an open source content management system built on Django. A user with a limited-permission editor account for the Wagtail admin can make a direct URL request to the admin view that handles bulk actions on user accounts. While authentication rules prevent the user from making any changes, the error message discloses the display names of user accounts, and by modifying URL parameters, the user can retrieve the display name for any user. The vulnerability is not exploitable by an ordinary site visitor without access to the Wagtail admin. Patched versions have been released as Wagtail 4.1.8 (LTS), 5.0.5 and 5.1.3. The fix is also included in Release Candidate 1 of the forthcoming Wagtail 5.2 release. Users are advised to upgrade. There are no known workarounds for this vulnerability."}, {"lang": "es", "value": "Wagtail es un sistema de gesti\u00f3n de contenidos de c\u00f3digo abierto construido sobre Django. Un usuario con una cuenta de editor con permisos limitados para el administrador de Wagtail puede realizar una solicitud de URL directa a la vista de administrador que maneja acciones masivas en cuentas de usuario. Si bien las reglas de autenticaci\u00f3n impiden que el usuario realice cambios, el mensaje de error revela los nombres para mostrar de las cuentas de usuario y, al modificar los par\u00e1metros de URL, el usuario puede recuperar el nombre para mostrar de cualquier usuario. La vulnerabilidad no es explotable por un visitante normal del sitio sin acceso al administrador de Wagtail. Se han lanzado versiones parcheadas como Wagtail 4.1.8 (LTS), 5.0.5 y 5.1.3. La soluci\u00f3n tambi\u00e9n se incluye en la versi\u00f3n candidata 1 de la pr\u00f3xima versi\u00f3n Wagtail 5.2. Se recomienda a los usuarios que actualicen. No se conocen workarounds para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.7, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.7, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-532"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}, {"lang": "en", "value": "CWE-425"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:torchbox:wagtail:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.1.9", "matchCriteriaId": "974BDF97-9C1D-44BB-AD65-7BF0C5BF2EA9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:torchbox:wagtail:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.2", "versionEndExcluding": "5.0.5", "matchCriteriaId": "7DAC1931-ECF9-47BA-9DFA-322E8DA9CCEB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:torchbox:wagtail:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.1", "versionEndExcluding": "5.1.3", "matchCriteriaId": "288CEC75-D1C5-4C43-9802-CF30E66DB5D2"}]}]}], "references": [{"url": "https://github.com/wagtail/wagtail/commit/bc96aed6ac53f998b2f4c4bf97e2d4f5fe337e5b", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/wagtail/wagtail/security/advisories/GHSA-fc75-58r8-rm3h", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/wagtail/wagtail/commit/bc96aed6ac53f998b2f4c4bf97e2d4f5fe337e5b"}}