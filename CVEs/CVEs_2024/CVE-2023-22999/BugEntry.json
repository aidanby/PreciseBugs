{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/* Copyright (c) 2018, The Linux Foundation. All rights reserved.\n *\n * Inspired by dwc3-of-simple.c\n */\n\n#include <linux/acpi.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/clk.h>\n#include <linux/irq.h>\n#include <linux/of_clk.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/extcon.h>\n#include <linux/interconnect.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/phy/phy.h>\n#include <linux/usb/of.h>\n#include <linux/reset.h>\n#include <linux/iopoll.h>\n\n#include \"core.h\"\n\n/* USB QSCRATCH Hardware registers */\n#define QSCRATCH_HS_PHY_CTRL\t\t\t0x10\n#define UTMI_OTG_VBUS_VALID\t\t\tBIT(20)\n#define SW_SESSVLD_SEL\t\t\t\tBIT(28)\n\n#define QSCRATCH_SS_PHY_CTRL\t\t\t0x30\n#define LANE0_PWR_PRESENT\t\t\tBIT(24)\n\n#define QSCRATCH_GENERAL_CFG\t\t\t0x08\n#define PIPE_UTMI_CLK_SEL\t\t\tBIT(0)\n#define PIPE3_PHYSTATUS_SW\t\t\tBIT(3)\n#define PIPE_UTMI_CLK_DIS\t\t\tBIT(8)\n\n#define PWR_EVNT_IRQ_STAT_REG\t\t\t0x58\n#define PWR_EVNT_LPM_IN_L2_MASK\t\t\tBIT(4)\n#define PWR_EVNT_LPM_OUT_L2_MASK\t\tBIT(5)\n\n#define SDM845_QSCRATCH_BASE_OFFSET\t\t0xf8800\n#define SDM845_QSCRATCH_SIZE\t\t\t0x400\n#define SDM845_DWC3_CORE_SIZE\t\t\t0xcd00\n\n/* Interconnect path bandwidths in MBps */\n#define USB_MEMORY_AVG_HS_BW MBps_to_icc(240)\n#define USB_MEMORY_PEAK_HS_BW MBps_to_icc(700)\n#define USB_MEMORY_AVG_SS_BW  MBps_to_icc(1000)\n#define USB_MEMORY_PEAK_SS_BW MBps_to_icc(2500)\n#define APPS_USB_AVG_BW 0\n#define APPS_USB_PEAK_BW MBps_to_icc(40)\n\nstruct dwc3_acpi_pdata {\n\tu32\t\t\tqscratch_base_offset;\n\tu32\t\t\tqscratch_base_size;\n\tu32\t\t\tdwc3_core_base_size;\n\tint\t\t\ths_phy_irq_index;\n\tint\t\t\tdp_hs_phy_irq_index;\n\tint\t\t\tdm_hs_phy_irq_index;\n\tint\t\t\tss_phy_irq_index;\n\tbool\t\t\tis_urs;\n};\n\nstruct dwc3_qcom {\n\tstruct device\t\t*dev;\n\tvoid __iomem\t\t*qscratch_base;\n\tstruct platform_device\t*dwc3;\n\tstruct platform_device\t*urs_usb;\n\tstruct clk\t\t**clks;\n\tint\t\t\tnum_clocks;\n\tstruct reset_control\t*resets;\n\n\tint\t\t\ths_phy_irq;\n\tint\t\t\tdp_hs_phy_irq;\n\tint\t\t\tdm_hs_phy_irq;\n\tint\t\t\tss_phy_irq;\n\n\tstruct extcon_dev\t*edev;\n\tstruct extcon_dev\t*host_edev;\n\tstruct notifier_block\tvbus_nb;\n\tstruct notifier_block\thost_nb;\n\n\tconst struct dwc3_acpi_pdata *acpi_pdata;\n\n\tenum usb_dr_mode\tmode;\n\tbool\t\t\tis_suspended;\n\tbool\t\t\tpm_suspended;\n\tstruct icc_path\t\t*icc_path_ddr;\n\tstruct icc_path\t\t*icc_path_apps;\n};\n\nstatic inline void dwc3_qcom_setbits(void __iomem *base, u32 offset, u32 val)\n{\n\tu32 reg;\n\n\treg = readl(base + offset);\n\treg |= val;\n\twritel(reg, base + offset);\n\n\t/* ensure that above write is through */\n\treadl(base + offset);\n}\n\nstatic inline void dwc3_qcom_clrbits(void __iomem *base, u32 offset, u32 val)\n{\n\tu32 reg;\n\n\treg = readl(base + offset);\n\treg &= ~val;\n\twritel(reg, base + offset);\n\n\t/* ensure that above write is through */\n\treadl(base + offset);\n}\n\nstatic void dwc3_qcom_vbus_override_enable(struct dwc3_qcom *qcom, bool enable)\n{\n\tif (enable) {\n\t\tdwc3_qcom_setbits(qcom->qscratch_base, QSCRATCH_SS_PHY_CTRL,\n\t\t\t\t  LANE0_PWR_PRESENT);\n\t\tdwc3_qcom_setbits(qcom->qscratch_base, QSCRATCH_HS_PHY_CTRL,\n\t\t\t\t  UTMI_OTG_VBUS_VALID | SW_SESSVLD_SEL);\n\t} else {\n\t\tdwc3_qcom_clrbits(qcom->qscratch_base, QSCRATCH_SS_PHY_CTRL,\n\t\t\t\t  LANE0_PWR_PRESENT);\n\t\tdwc3_qcom_clrbits(qcom->qscratch_base, QSCRATCH_HS_PHY_CTRL,\n\t\t\t\t  UTMI_OTG_VBUS_VALID | SW_SESSVLD_SEL);\n\t}\n}\n\nstatic int dwc3_qcom_vbus_notifier(struct notifier_block *nb,\n\t\t\t\t   unsigned long event, void *ptr)\n{\n\tstruct dwc3_qcom *qcom = container_of(nb, struct dwc3_qcom, vbus_nb);\n\n\t/* enable vbus override for device mode */\n\tdwc3_qcom_vbus_override_enable(qcom, event);\n\tqcom->mode = event ? USB_DR_MODE_PERIPHERAL : USB_DR_MODE_HOST;\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int dwc3_qcom_host_notifier(struct notifier_block *nb,\n\t\t\t\t   unsigned long event, void *ptr)\n{\n\tstruct dwc3_qcom *qcom = container_of(nb, struct dwc3_qcom, host_nb);\n\n\t/* disable vbus override in host mode */\n\tdwc3_qcom_vbus_override_enable(qcom, !event);\n\tqcom->mode = event ? USB_DR_MODE_HOST : USB_DR_MODE_PERIPHERAL;\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int dwc3_qcom_register_extcon(struct dwc3_qcom *qcom)\n{\n\tstruct device\t\t*dev = qcom->dev;\n\tstruct extcon_dev\t*host_edev;\n\tint\t\t\tret;\n\n\tif (!of_property_read_bool(dev->of_node, \"extcon\"))\n\t\treturn 0;\n\n\tqcom->edev = extcon_get_edev_by_phandle(dev, 0);\n\tif (IS_ERR(qcom->edev))\n\t\treturn PTR_ERR(qcom->edev);\n\n\tqcom->vbus_nb.notifier_call = dwc3_qcom_vbus_notifier;\n\n\tqcom->host_edev = extcon_get_edev_by_phandle(dev, 1);\n\tif (IS_ERR(qcom->host_edev))\n\t\tqcom->host_edev = NULL;\n\n\tret = devm_extcon_register_notifier(dev, qcom->edev, EXTCON_USB,\n\t\t\t\t\t    &qcom->vbus_nb);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"VBUS notifier register failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (qcom->host_edev)\n\t\thost_edev = qcom->host_edev;\n\telse\n\t\thost_edev = qcom->edev;\n\n\tqcom->host_nb.notifier_call = dwc3_qcom_host_notifier;\n\tret = devm_extcon_register_notifier(dev, host_edev, EXTCON_USB_HOST,\n\t\t\t\t\t    &qcom->host_nb);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Host notifier register failed\\n\");\n\t\treturn ret;\n\t}\n\n\t/* Update initial VBUS override based on extcon state */\n\tif (extcon_get_state(qcom->edev, EXTCON_USB) ||\n\t    !extcon_get_state(host_edev, EXTCON_USB_HOST))\n\t\tdwc3_qcom_vbus_notifier(&qcom->vbus_nb, true, qcom->edev);\n\telse\n\t\tdwc3_qcom_vbus_notifier(&qcom->vbus_nb, false, qcom->edev);\n\n\treturn 0;\n}\n\nstatic int dwc3_qcom_interconnect_enable(struct dwc3_qcom *qcom)\n{\n\tint ret;\n\n\tret = icc_enable(qcom->icc_path_ddr);\n\tif (ret)\n\t\treturn ret;\n\n\tret = icc_enable(qcom->icc_path_apps);\n\tif (ret)\n\t\ticc_disable(qcom->icc_path_ddr);\n\n\treturn ret;\n}\n\nstatic int dwc3_qcom_interconnect_disable(struct dwc3_qcom *qcom)\n{\n\tint ret;\n\n\tret = icc_disable(qcom->icc_path_ddr);\n\tif (ret)\n\t\treturn ret;\n\n\tret = icc_disable(qcom->icc_path_apps);\n\tif (ret)\n\t\ticc_enable(qcom->icc_path_ddr);\n\n\treturn ret;\n}\n\n/**\n * dwc3_qcom_interconnect_init() - Get interconnect path handles\n * and set bandwidth.\n * @qcom:\t\t\tPointer to the concerned usb core.\n *\n */\nstatic int dwc3_qcom_interconnect_init(struct dwc3_qcom *qcom)\n{\n\tstruct device *dev = qcom->dev;\n\tint ret;\n\n\tif (has_acpi_companion(dev))\n\t\treturn 0;\n\n\tqcom->icc_path_ddr = of_icc_get(dev, \"usb-ddr\");\n\tif (IS_ERR(qcom->icc_path_ddr)) {\n\t\tdev_err(dev, \"failed to get usb-ddr path: %ld\\n\",\n\t\t\tPTR_ERR(qcom->icc_path_ddr));\n\t\treturn PTR_ERR(qcom->icc_path_ddr);\n\t}\n\n\tqcom->icc_path_apps = of_icc_get(dev, \"apps-usb\");\n\tif (IS_ERR(qcom->icc_path_apps)) {\n\t\tdev_err(dev, \"failed to get apps-usb path: %ld\\n\",\n\t\t\t\tPTR_ERR(qcom->icc_path_apps));\n\t\treturn PTR_ERR(qcom->icc_path_apps);\n\t}\n\n\tif (usb_get_maximum_speed(&qcom->dwc3->dev) >= USB_SPEED_SUPER ||\n\t\t\tusb_get_maximum_speed(&qcom->dwc3->dev) == USB_SPEED_UNKNOWN)\n\t\tret = icc_set_bw(qcom->icc_path_ddr,\n\t\t\tUSB_MEMORY_AVG_SS_BW, USB_MEMORY_PEAK_SS_BW);\n\telse\n\t\tret = icc_set_bw(qcom->icc_path_ddr,\n\t\t\tUSB_MEMORY_AVG_HS_BW, USB_MEMORY_PEAK_HS_BW);\n\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set bandwidth for usb-ddr path: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = icc_set_bw(qcom->icc_path_apps,\n\t\tAPPS_USB_AVG_BW, APPS_USB_PEAK_BW);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set bandwidth for apps-usb path: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n/**\n * dwc3_qcom_interconnect_exit() - Release interconnect path handles\n * @qcom:\t\t\tPointer to the concerned usb core.\n *\n * This function is used to release interconnect path handle.\n */\nstatic void dwc3_qcom_interconnect_exit(struct dwc3_qcom *qcom)\n{\n\ticc_put(qcom->icc_path_ddr);\n\ticc_put(qcom->icc_path_apps);\n}\n\nstatic void dwc3_qcom_disable_interrupts(struct dwc3_qcom *qcom)\n{\n\tif (qcom->hs_phy_irq) {\n\t\tdisable_irq_wake(qcom->hs_phy_irq);\n\t\tdisable_irq_nosync(qcom->hs_phy_irq);\n\t}\n\n\tif (qcom->dp_hs_phy_irq) {\n\t\tdisable_irq_wake(qcom->dp_hs_phy_irq);\n\t\tdisable_irq_nosync(qcom->dp_hs_phy_irq);\n\t}\n\n\tif (qcom->dm_hs_phy_irq) {\n\t\tdisable_irq_wake(qcom->dm_hs_phy_irq);\n\t\tdisable_irq_nosync(qcom->dm_hs_phy_irq);\n\t}\n\n\tif (qcom->ss_phy_irq) {\n\t\tdisable_irq_wake(qcom->ss_phy_irq);\n\t\tdisable_irq_nosync(qcom->ss_phy_irq);\n\t}\n}\n\nstatic void dwc3_qcom_enable_interrupts(struct dwc3_qcom *qcom)\n{\n\tif (qcom->hs_phy_irq) {\n\t\tenable_irq(qcom->hs_phy_irq);\n\t\tenable_irq_wake(qcom->hs_phy_irq);\n\t}\n\n\tif (qcom->dp_hs_phy_irq) {\n\t\tenable_irq(qcom->dp_hs_phy_irq);\n\t\tenable_irq_wake(qcom->dp_hs_phy_irq);\n\t}\n\n\tif (qcom->dm_hs_phy_irq) {\n\t\tenable_irq(qcom->dm_hs_phy_irq);\n\t\tenable_irq_wake(qcom->dm_hs_phy_irq);\n\t}\n\n\tif (qcom->ss_phy_irq) {\n\t\tenable_irq(qcom->ss_phy_irq);\n\t\tenable_irq_wake(qcom->ss_phy_irq);\n\t}\n}\n\nstatic int dwc3_qcom_suspend(struct dwc3_qcom *qcom)\n{\n\tu32 val;\n\tint i, ret;\n\n\tif (qcom->is_suspended)\n\t\treturn 0;\n\n\tval = readl(qcom->qscratch_base + PWR_EVNT_IRQ_STAT_REG);\n\tif (!(val & PWR_EVNT_LPM_IN_L2_MASK))\n\t\tdev_err(qcom->dev, \"HS-PHY not in L2\\n\");\n\n\tfor (i = qcom->num_clocks - 1; i >= 0; i--)\n\t\tclk_disable_unprepare(qcom->clks[i]);\n\n\tret = dwc3_qcom_interconnect_disable(qcom);\n\tif (ret)\n\t\tdev_warn(qcom->dev, \"failed to disable interconnect: %d\\n\", ret);\n\n\tif (device_may_wakeup(qcom->dev))\n\t\tdwc3_qcom_enable_interrupts(qcom);\n\n\tqcom->is_suspended = true;\n\n\treturn 0;\n}\n\nstatic int dwc3_qcom_resume(struct dwc3_qcom *qcom)\n{\n\tint ret;\n\tint i;\n\n\tif (!qcom->is_suspended)\n\t\treturn 0;\n\n\tif (device_may_wakeup(qcom->dev))\n\t\tdwc3_qcom_disable_interrupts(qcom);\n\n\tfor (i = 0; i < qcom->num_clocks; i++) {\n\t\tret = clk_prepare_enable(qcom->clks[i]);\n\t\tif (ret < 0) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tclk_disable_unprepare(qcom->clks[i]);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = dwc3_qcom_interconnect_enable(qcom);\n\tif (ret)\n\t\tdev_warn(qcom->dev, \"failed to enable interconnect: %d\\n\", ret);\n\n\t/* Clear existing events from PHY related to L2 in/out */\n\tdwc3_qcom_setbits(qcom->qscratch_base, PWR_EVNT_IRQ_STAT_REG,\n\t\t\t  PWR_EVNT_LPM_IN_L2_MASK | PWR_EVNT_LPM_OUT_L2_MASK);\n\n\tqcom->is_suspended = false;\n\n\treturn 0;\n}\n\nstatic irqreturn_t qcom_dwc3_resume_irq(int irq, void *data)\n{\n\tstruct dwc3_qcom *qcom = data;\n\tstruct dwc3\t*dwc = platform_get_drvdata(qcom->dwc3);\n\n\t/* If pm_suspended then let pm_resume take care of resuming h/w */\n\tif (qcom->pm_suspended)\n\t\treturn IRQ_HANDLED;\n\n\tif (dwc->xhci)\n\t\tpm_runtime_resume(&dwc->xhci->dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void dwc3_qcom_select_utmi_clk(struct dwc3_qcom *qcom)\n{\n\t/* Configure dwc3 to use UTMI clock as PIPE clock not present */\n\tdwc3_qcom_setbits(qcom->qscratch_base, QSCRATCH_GENERAL_CFG,\n\t\t\t  PIPE_UTMI_CLK_DIS);\n\n\tusleep_range(100, 1000);\n\n\tdwc3_qcom_setbits(qcom->qscratch_base, QSCRATCH_GENERAL_CFG,\n\t\t\t  PIPE_UTMI_CLK_SEL | PIPE3_PHYSTATUS_SW);\n\n\tusleep_range(100, 1000);\n\n\tdwc3_qcom_clrbits(qcom->qscratch_base, QSCRATCH_GENERAL_CFG,\n\t\t\t  PIPE_UTMI_CLK_DIS);\n}\n\nstatic int dwc3_qcom_get_irq(struct platform_device *pdev,\n\t\t\t     const char *name, int num)\n{\n\tstruct dwc3_qcom *qcom = platform_get_drvdata(pdev);\n\tstruct platform_device *pdev_irq = qcom->urs_usb ? qcom->urs_usb : pdev;\n\tstruct device_node *np = pdev->dev.of_node;\n\tint ret;\n\n\tif (np)\n\t\tret = platform_get_irq_byname(pdev_irq, name);\n\telse\n\t\tret = platform_get_irq(pdev_irq, num);\n\n\treturn ret;\n}\n\nstatic int dwc3_qcom_setup_irq(struct platform_device *pdev)\n{\n\tstruct dwc3_qcom *qcom = platform_get_drvdata(pdev);\n\tconst struct dwc3_acpi_pdata *pdata = qcom->acpi_pdata;\n\tint irq;\n\tint ret;\n\n\tirq = dwc3_qcom_get_irq(pdev, \"hs_phy_irq\",\n\t\t\t\tpdata ? pdata->hs_phy_irq_index : -1);\n\tif (irq > 0) {\n\t\t/* Keep wakeup interrupts disabled until suspend */\n\t\tirq_set_status_flags(irq, IRQ_NOAUTOEN);\n\t\tret = devm_request_threaded_irq(qcom->dev, irq, NULL,\n\t\t\t\t\tqcom_dwc3_resume_irq,\n\t\t\t\t\tIRQF_TRIGGER_HIGH | IRQF_ONESHOT,\n\t\t\t\t\t\"qcom_dwc3 HS\", qcom);\n\t\tif (ret) {\n\t\t\tdev_err(qcom->dev, \"hs_phy_irq failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tqcom->hs_phy_irq = irq;\n\t}\n\n\tirq = dwc3_qcom_get_irq(pdev, \"dp_hs_phy_irq\",\n\t\t\t\tpdata ? pdata->dp_hs_phy_irq_index : -1);\n\tif (irq > 0) {\n\t\tirq_set_status_flags(irq, IRQ_NOAUTOEN);\n\t\tret = devm_request_threaded_irq(qcom->dev, irq, NULL,\n\t\t\t\t\tqcom_dwc3_resume_irq,\n\t\t\t\t\tIRQF_TRIGGER_HIGH | IRQF_ONESHOT,\n\t\t\t\t\t\"qcom_dwc3 DP_HS\", qcom);\n\t\tif (ret) {\n\t\t\tdev_err(qcom->dev, \"dp_hs_phy_irq failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tqcom->dp_hs_phy_irq = irq;\n\t}\n\n\tirq = dwc3_qcom_get_irq(pdev, \"dm_hs_phy_irq\",\n\t\t\t\tpdata ? pdata->dm_hs_phy_irq_index : -1);\n\tif (irq > 0) {\n\t\tirq_set_status_flags(irq, IRQ_NOAUTOEN);\n\t\tret = devm_request_threaded_irq(qcom->dev, irq, NULL,\n\t\t\t\t\tqcom_dwc3_resume_irq,\n\t\t\t\t\tIRQF_TRIGGER_HIGH | IRQF_ONESHOT,\n\t\t\t\t\t\"qcom_dwc3 DM_HS\", qcom);\n\t\tif (ret) {\n\t\t\tdev_err(qcom->dev, \"dm_hs_phy_irq failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tqcom->dm_hs_phy_irq = irq;\n\t}\n\n\tirq = dwc3_qcom_get_irq(pdev, \"ss_phy_irq\",\n\t\t\t\tpdata ? pdata->ss_phy_irq_index : -1);\n\tif (irq > 0) {\n\t\tirq_set_status_flags(irq, IRQ_NOAUTOEN);\n\t\tret = devm_request_threaded_irq(qcom->dev, irq, NULL,\n\t\t\t\t\tqcom_dwc3_resume_irq,\n\t\t\t\t\tIRQF_TRIGGER_HIGH | IRQF_ONESHOT,\n\t\t\t\t\t\"qcom_dwc3 SS\", qcom);\n\t\tif (ret) {\n\t\t\tdev_err(qcom->dev, \"ss_phy_irq failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tqcom->ss_phy_irq = irq;\n\t}\n\n\treturn 0;\n}\n\nstatic int dwc3_qcom_clk_init(struct dwc3_qcom *qcom, int count)\n{\n\tstruct device\t\t*dev = qcom->dev;\n\tstruct device_node\t*np = dev->of_node;\n\tint\t\t\ti;\n\n\tif (!np || !count)\n\t\treturn 0;\n\n\tif (count < 0)\n\t\treturn count;\n\n\tqcom->num_clocks = count;\n\n\tqcom->clks = devm_kcalloc(dev, qcom->num_clocks,\n\t\t\t\t  sizeof(struct clk *), GFP_KERNEL);\n\tif (!qcom->clks)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < qcom->num_clocks; i++) {\n\t\tstruct clk\t*clk;\n\t\tint\t\tret;\n\n\t\tclk = of_clk_get(np, i);\n\t\tif (IS_ERR(clk)) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tclk_put(qcom->clks[i]);\n\t\t\treturn PTR_ERR(clk);\n\t\t}\n\n\t\tret = clk_prepare_enable(clk);\n\t\tif (ret < 0) {\n\t\t\twhile (--i >= 0) {\n\t\t\t\tclk_disable_unprepare(qcom->clks[i]);\n\t\t\t\tclk_put(qcom->clks[i]);\n\t\t\t}\n\t\t\tclk_put(clk);\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tqcom->clks[i] = clk;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct property_entry dwc3_qcom_acpi_properties[] = {\n\tPROPERTY_ENTRY_STRING(\"dr_mode\", \"host\"),\n\t{}\n};\n\nstatic const struct software_node dwc3_qcom_swnode = {\n\t.properties = dwc3_qcom_acpi_properties,\n};\n\nstatic int dwc3_qcom_acpi_register_core(struct platform_device *pdev)\n{\n\tstruct dwc3_qcom\t*qcom = platform_get_drvdata(pdev);\n\tstruct device\t\t*dev = &pdev->dev;\n\tstruct resource\t\t*res, *child_res = NULL;\n\tstruct platform_device\t*pdev_irq = qcom->urs_usb ? qcom->urs_usb :\n\t\t\t\t\t\t\t    pdev;\n\tint\t\t\tirq;\n\tint\t\t\tret;\n\n\tqcom->dwc3 = platform_device_alloc(\"dwc3\", PLATFORM_DEVID_AUTO);\n\tif (!qcom->dwc3)\n\t\treturn -ENOMEM;\n\n\tqcom->dwc3->dev.parent = dev;\n\tqcom->dwc3->dev.type = dev->type;\n\tqcom->dwc3->dev.dma_mask = dev->dma_mask;\n\tqcom->dwc3->dev.dma_parms = dev->dma_parms;\n\tqcom->dwc3->dev.coherent_dma_mask = dev->coherent_dma_mask;\n\n\tchild_res = kcalloc(2, sizeof(*child_res), GFP_KERNEL);\n\tif (!child_res) {\n\t\tplatform_device_put(qcom->dwc3);\n\t\treturn -ENOMEM;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"failed to get memory resource\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tchild_res[0].flags = res->flags;\n\tchild_res[0].start = res->start;\n\tchild_res[0].end = child_res[0].start +\n\t\tqcom->acpi_pdata->dwc3_core_base_size;\n\n\tirq = platform_get_irq(pdev_irq, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto out;\n\t}\n\tchild_res[1].flags = IORESOURCE_IRQ;\n\tchild_res[1].start = child_res[1].end = irq;\n\n\tret = platform_device_add_resources(qcom->dwc3, child_res, 2);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to add resources\\n\");\n\t\tgoto out;\n\t}\n\n\tret = device_add_software_node(&qcom->dwc3->dev, &dwc3_qcom_swnode);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to add properties\\n\");\n\t\tgoto out;\n\t}\n\n\tret = platform_device_add(qcom->dwc3);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to add device\\n\");\n\t\tdevice_remove_software_node(&qcom->dwc3->dev);\n\t\tgoto out;\n\t}\n\tkfree(child_res);\n\treturn 0;\n\nout:\n\tplatform_device_put(qcom->dwc3);\n\tkfree(child_res);\n\treturn ret;\n}\n\nstatic int dwc3_qcom_of_register_core(struct platform_device *pdev)\n{\n\tstruct dwc3_qcom\t*qcom = platform_get_drvdata(pdev);\n\tstruct device_node\t*np = pdev->dev.of_node, *dwc3_np;\n\tstruct device\t\t*dev = &pdev->dev;\n\tint\t\t\tret;\n\n\tdwc3_np = of_get_compatible_child(np, \"snps,dwc3\");\n\tif (!dwc3_np) {\n\t\tdev_err(dev, \"failed to find dwc3 core child\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = of_platform_populate(np, NULL, NULL, dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register dwc3 core - %d\\n\", ret);\n\t\tgoto node_put;\n\t}\n\n\tqcom->dwc3 = of_find_device_by_node(dwc3_np);\n\tif (!qcom->dwc3) {\n\t\tret = -ENODEV;\n\t\tdev_err(dev, \"failed to get dwc3 platform device\\n\");\n\t}\n\nnode_put:\n\tof_node_put(dwc3_np);\n\n\treturn ret;\n}\n\nstatic struct platform_device *\ndwc3_qcom_create_urs_usb_platdev(struct device *dev)\n{\n\tstruct fwnode_handle *fwh;\n\tstruct acpi_device *adev;\n\tchar name[8];\n\tint ret;\n\tint id;\n\n\t/* Figure out device id */\n\tret = sscanf(fwnode_get_name(dev->fwnode), \"URS%d\", &id);\n\tif (!ret)\n\t\treturn NULL;\n\n\t/* Find the child using name */\n\tsnprintf(name, sizeof(name), \"USB%d\", id);\n\tfwh = fwnode_get_named_child_node(dev->fwnode, name);\n\tif (!fwh)\n\t\treturn NULL;\n\n\tadev = to_acpi_device_node(fwh);\n\tif (!adev)\n\t\treturn NULL;\n\n\treturn acpi_create_platform_device(adev, NULL);\n}\n\nstatic int dwc3_qcom_probe(struct platform_device *pdev)\n{\n\tstruct device_node\t*np = pdev->dev.of_node;\n\tstruct device\t\t*dev = &pdev->dev;\n\tstruct dwc3_qcom\t*qcom;\n\tstruct resource\t\t*res, *parent_res = NULL;\n\tint\t\t\tret, i;\n\tbool\t\t\tignore_pipe_clk;\n\n\tqcom = devm_kzalloc(&pdev->dev, sizeof(*qcom), GFP_KERNEL);\n\tif (!qcom)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, qcom);\n\tqcom->dev = &pdev->dev;\n\n\tif (has_acpi_companion(dev)) {\n\t\tqcom->acpi_pdata = acpi_device_get_match_data(dev);\n\t\tif (!qcom->acpi_pdata) {\n\t\t\tdev_err(&pdev->dev, \"no supporting ACPI device data\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tqcom->resets = devm_reset_control_array_get_optional_exclusive(dev);\n\tif (IS_ERR(qcom->resets)) {\n\t\tret = PTR_ERR(qcom->resets);\n\t\tdev_err(&pdev->dev, \"failed to get resets, err=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = reset_control_assert(qcom->resets);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to assert resets, err=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tusleep_range(10, 1000);\n\n\tret = reset_control_deassert(qcom->resets);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to deassert resets, err=%d\\n\", ret);\n\t\tgoto reset_assert;\n\t}\n\n\tret = dwc3_qcom_clk_init(qcom, of_clk_get_parent_count(np));\n\tif (ret) {\n\t\tdev_err(dev, \"failed to get clocks\\n\");\n\t\tgoto reset_assert;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\n\tif (np) {\n\t\tparent_res = res;\n\t} else {\n\t\tparent_res = kmemdup(res, sizeof(struct resource), GFP_KERNEL);\n\t\tif (!parent_res)\n\t\t\treturn -ENOMEM;\n\n\t\tparent_res->start = res->start +\n\t\t\tqcom->acpi_pdata->qscratch_base_offset;\n\t\tparent_res->end = parent_res->start +\n\t\t\tqcom->acpi_pdata->qscratch_base_size;\n\n\t\tif (qcom->acpi_pdata->is_urs) {\n\t\t\tqcom->urs_usb = dwc3_qcom_create_urs_usb_platdev(dev);\n\t\t\tif (!qcom->urs_usb) {\n\t\t\t\tdev_err(dev, \"failed to create URS USB platdev\\n\");\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t}\n\t}\n\n\tqcom->qscratch_base = devm_ioremap_resource(dev, parent_res);\n\tif (IS_ERR(qcom->qscratch_base)) {\n\t\tret = PTR_ERR(qcom->qscratch_base);\n\t\tgoto clk_disable;\n\t}\n\n\tret = dwc3_qcom_setup_irq(pdev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to setup IRQs, err=%d\\n\", ret);\n\t\tgoto clk_disable;\n\t}\n\n\t/*\n\t * Disable pipe_clk requirement if specified. Used when dwc3\n\t * operates without SSPHY and only HS/FS/LS modes are supported.\n\t */\n\tignore_pipe_clk = device_property_read_bool(dev,\n\t\t\t\t\"qcom,select-utmi-as-pipe-clk\");\n\tif (ignore_pipe_clk)\n\t\tdwc3_qcom_select_utmi_clk(qcom);\n\n\tif (np)\n\t\tret = dwc3_qcom_of_register_core(pdev);\n\telse\n\t\tret = dwc3_qcom_acpi_register_core(pdev);\n\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register DWC3 Core, err=%d\\n\", ret);\n\t\tgoto depopulate;\n\t}\n\n\tret = dwc3_qcom_interconnect_init(qcom);\n\tif (ret)\n\t\tgoto depopulate;\n\n\tqcom->mode = usb_get_dr_mode(&qcom->dwc3->dev);\n\n\t/* enable vbus override for device mode */\n\tif (qcom->mode == USB_DR_MODE_PERIPHERAL)\n\t\tdwc3_qcom_vbus_override_enable(qcom, true);\n\n\t/* register extcon to override sw_vbus on Vbus change later */\n\tret = dwc3_qcom_register_extcon(qcom);\n\tif (ret)\n\t\tgoto interconnect_exit;\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\tqcom->is_suspended = false;\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\tpm_runtime_forbid(dev);\n\n\treturn 0;\n\ninterconnect_exit:\n\tdwc3_qcom_interconnect_exit(qcom);\ndepopulate:\n\tif (np)\n\t\tof_platform_depopulate(&pdev->dev);\n\telse\n\t\tplatform_device_put(pdev);\nclk_disable:\n\tfor (i = qcom->num_clocks - 1; i >= 0; i--) {\n\t\tclk_disable_unprepare(qcom->clks[i]);\n\t\tclk_put(qcom->clks[i]);\n\t}\nreset_assert:\n\treset_control_assert(qcom->resets);\n\n\treturn ret;\n}\n\nstatic int dwc3_qcom_remove(struct platform_device *pdev)\n{\n\tstruct dwc3_qcom *qcom = platform_get_drvdata(pdev);\n\tstruct device *dev = &pdev->dev;\n\tint i;\n\n\tdevice_remove_software_node(&qcom->dwc3->dev);\n\tof_platform_depopulate(dev);\n\n\tfor (i = qcom->num_clocks - 1; i >= 0; i--) {\n\t\tclk_disable_unprepare(qcom->clks[i]);\n\t\tclk_put(qcom->clks[i]);\n\t}\n\tqcom->num_clocks = 0;\n\n\tdwc3_qcom_interconnect_exit(qcom);\n\treset_control_assert(qcom->resets);\n\n\tpm_runtime_allow(dev);\n\tpm_runtime_disable(dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused dwc3_qcom_pm_suspend(struct device *dev)\n{\n\tstruct dwc3_qcom *qcom = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tret = dwc3_qcom_suspend(qcom);\n\tif (!ret)\n\t\tqcom->pm_suspended = true;\n\n\treturn ret;\n}\n\nstatic int __maybe_unused dwc3_qcom_pm_resume(struct device *dev)\n{\n\tstruct dwc3_qcom *qcom = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = dwc3_qcom_resume(qcom);\n\tif (!ret)\n\t\tqcom->pm_suspended = false;\n\n\treturn ret;\n}\n\nstatic int __maybe_unused dwc3_qcom_runtime_suspend(struct device *dev)\n{\n\tstruct dwc3_qcom *qcom = dev_get_drvdata(dev);\n\n\treturn dwc3_qcom_suspend(qcom);\n}\n\nstatic int __maybe_unused dwc3_qcom_runtime_resume(struct device *dev)\n{\n\tstruct dwc3_qcom *qcom = dev_get_drvdata(dev);\n\n\treturn dwc3_qcom_resume(qcom);\n}\n\nstatic const struct dev_pm_ops dwc3_qcom_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(dwc3_qcom_pm_suspend, dwc3_qcom_pm_resume)\n\tSET_RUNTIME_PM_OPS(dwc3_qcom_runtime_suspend, dwc3_qcom_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic const struct of_device_id dwc3_qcom_of_match[] = {\n\t{ .compatible = \"qcom,dwc3\" },\n\t{ .compatible = \"qcom,msm8996-dwc3\" },\n\t{ .compatible = \"qcom,msm8998-dwc3\" },\n\t{ .compatible = \"qcom,sdm660-dwc3\" },\n\t{ .compatible = \"qcom,sdm845-dwc3\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, dwc3_qcom_of_match);\n\n#ifdef CONFIG_ACPI\nstatic const struct dwc3_acpi_pdata sdm845_acpi_pdata = {\n\t.qscratch_base_offset = SDM845_QSCRATCH_BASE_OFFSET,\n\t.qscratch_base_size = SDM845_QSCRATCH_SIZE,\n\t.dwc3_core_base_size = SDM845_DWC3_CORE_SIZE,\n\t.hs_phy_irq_index = 1,\n\t.dp_hs_phy_irq_index = 4,\n\t.dm_hs_phy_irq_index = 3,\n\t.ss_phy_irq_index = 2\n};\n\nstatic const struct dwc3_acpi_pdata sdm845_acpi_urs_pdata = {\n\t.qscratch_base_offset = SDM845_QSCRATCH_BASE_OFFSET,\n\t.qscratch_base_size = SDM845_QSCRATCH_SIZE,\n\t.dwc3_core_base_size = SDM845_DWC3_CORE_SIZE,\n\t.hs_phy_irq_index = 1,\n\t.dp_hs_phy_irq_index = 4,\n\t.dm_hs_phy_irq_index = 3,\n\t.ss_phy_irq_index = 2,\n\t.is_urs = true,\n};\n\nstatic const struct acpi_device_id dwc3_qcom_acpi_match[] = {\n\t{ \"QCOM2430\", (unsigned long)&sdm845_acpi_pdata },\n\t{ \"QCOM0304\", (unsigned long)&sdm845_acpi_urs_pdata },\n\t{ \"QCOM0497\", (unsigned long)&sdm845_acpi_urs_pdata },\n\t{ \"QCOM04A6\", (unsigned long)&sdm845_acpi_pdata },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, dwc3_qcom_acpi_match);\n#endif\n\nstatic struct platform_driver dwc3_qcom_driver = {\n\t.probe\t\t= dwc3_qcom_probe,\n\t.remove\t\t= dwc3_qcom_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"dwc3-qcom\",\n\t\t.pm\t= &dwc3_qcom_dev_pm_ops,\n\t\t.of_match_table\t= dwc3_qcom_of_match,\n\t\t.acpi_match_table = ACPI_PTR(dwc3_qcom_acpi_match),\n\t},\n};\n\nmodule_platform_driver(dwc3_qcom_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"DesignWare DWC3 QCOM Glue Driver\");\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/* Copyright (c) 2018, The Linux Foundation. All rights reserved.\n *\n * Inspired by dwc3-of-simple.c\n */\n\n#include <linux/acpi.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/clk.h>\n#include <linux/irq.h>\n#include <linux/of_clk.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/extcon.h>\n#include <linux/interconnect.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/phy/phy.h>\n#include <linux/usb/of.h>\n#include <linux/reset.h>\n#include <linux/iopoll.h>\n\n#include \"core.h\"\n\n/* USB QSCRATCH Hardware registers */\n#define QSCRATCH_HS_PHY_CTRL\t\t\t0x10\n#define UTMI_OTG_VBUS_VALID\t\t\tBIT(20)\n#define SW_SESSVLD_SEL\t\t\t\tBIT(28)\n\n#define QSCRATCH_SS_PHY_CTRL\t\t\t0x30\n#define LANE0_PWR_PRESENT\t\t\tBIT(24)\n\n#define QSCRATCH_GENERAL_CFG\t\t\t0x08\n#define PIPE_UTMI_CLK_SEL\t\t\tBIT(0)\n#define PIPE3_PHYSTATUS_SW\t\t\tBIT(3)\n#define PIPE_UTMI_CLK_DIS\t\t\tBIT(8)\n\n#define PWR_EVNT_IRQ_STAT_REG\t\t\t0x58\n#define PWR_EVNT_LPM_IN_L2_MASK\t\t\tBIT(4)\n#define PWR_EVNT_LPM_OUT_L2_MASK\t\tBIT(5)\n\n#define SDM845_QSCRATCH_BASE_OFFSET\t\t0xf8800\n#define SDM845_QSCRATCH_SIZE\t\t\t0x400\n#define SDM845_DWC3_CORE_SIZE\t\t\t0xcd00\n\n/* Interconnect path bandwidths in MBps */\n#define USB_MEMORY_AVG_HS_BW MBps_to_icc(240)\n#define USB_MEMORY_PEAK_HS_BW MBps_to_icc(700)\n#define USB_MEMORY_AVG_SS_BW  MBps_to_icc(1000)\n#define USB_MEMORY_PEAK_SS_BW MBps_to_icc(2500)\n#define APPS_USB_AVG_BW 0\n#define APPS_USB_PEAK_BW MBps_to_icc(40)\n\nstruct dwc3_acpi_pdata {\n\tu32\t\t\tqscratch_base_offset;\n\tu32\t\t\tqscratch_base_size;\n\tu32\t\t\tdwc3_core_base_size;\n\tint\t\t\ths_phy_irq_index;\n\tint\t\t\tdp_hs_phy_irq_index;\n\tint\t\t\tdm_hs_phy_irq_index;\n\tint\t\t\tss_phy_irq_index;\n\tbool\t\t\tis_urs;\n};\n\nstruct dwc3_qcom {\n\tstruct device\t\t*dev;\n\tvoid __iomem\t\t*qscratch_base;\n\tstruct platform_device\t*dwc3;\n\tstruct platform_device\t*urs_usb;\n\tstruct clk\t\t**clks;\n\tint\t\t\tnum_clocks;\n\tstruct reset_control\t*resets;\n\n\tint\t\t\ths_phy_irq;\n\tint\t\t\tdp_hs_phy_irq;\n\tint\t\t\tdm_hs_phy_irq;\n\tint\t\t\tss_phy_irq;\n\n\tstruct extcon_dev\t*edev;\n\tstruct extcon_dev\t*host_edev;\n\tstruct notifier_block\tvbus_nb;\n\tstruct notifier_block\thost_nb;\n\n\tconst struct dwc3_acpi_pdata *acpi_pdata;\n\n\tenum usb_dr_mode\tmode;\n\tbool\t\t\tis_suspended;\n\tbool\t\t\tpm_suspended;\n\tstruct icc_path\t\t*icc_path_ddr;\n\tstruct icc_path\t\t*icc_path_apps;\n};\n\nstatic inline void dwc3_qcom_setbits(void __iomem *base, u32 offset, u32 val)\n{\n\tu32 reg;\n\n\treg = readl(base + offset);\n\treg |= val;\n\twritel(reg, base + offset);\n\n\t/* ensure that above write is through */\n\treadl(base + offset);\n}\n\nstatic inline void dwc3_qcom_clrbits(void __iomem *base, u32 offset, u32 val)\n{\n\tu32 reg;\n\n\treg = readl(base + offset);\n\treg &= ~val;\n\twritel(reg, base + offset);\n\n\t/* ensure that above write is through */\n\treadl(base + offset);\n}\n\nstatic void dwc3_qcom_vbus_override_enable(struct dwc3_qcom *qcom, bool enable)\n{\n\tif (enable) {\n\t\tdwc3_qcom_setbits(qcom->qscratch_base, QSCRATCH_SS_PHY_CTRL,\n\t\t\t\t  LANE0_PWR_PRESENT);\n\t\tdwc3_qcom_setbits(qcom->qscratch_base, QSCRATCH_HS_PHY_CTRL,\n\t\t\t\t  UTMI_OTG_VBUS_VALID | SW_SESSVLD_SEL);\n\t} else {\n\t\tdwc3_qcom_clrbits(qcom->qscratch_base, QSCRATCH_SS_PHY_CTRL,\n\t\t\t\t  LANE0_PWR_PRESENT);\n\t\tdwc3_qcom_clrbits(qcom->qscratch_base, QSCRATCH_HS_PHY_CTRL,\n\t\t\t\t  UTMI_OTG_VBUS_VALID | SW_SESSVLD_SEL);\n\t}\n}\n\nstatic int dwc3_qcom_vbus_notifier(struct notifier_block *nb,\n\t\t\t\t   unsigned long event, void *ptr)\n{\n\tstruct dwc3_qcom *qcom = container_of(nb, struct dwc3_qcom, vbus_nb);\n\n\t/* enable vbus override for device mode */\n\tdwc3_qcom_vbus_override_enable(qcom, event);\n\tqcom->mode = event ? USB_DR_MODE_PERIPHERAL : USB_DR_MODE_HOST;\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int dwc3_qcom_host_notifier(struct notifier_block *nb,\n\t\t\t\t   unsigned long event, void *ptr)\n{\n\tstruct dwc3_qcom *qcom = container_of(nb, struct dwc3_qcom, host_nb);\n\n\t/* disable vbus override in host mode */\n\tdwc3_qcom_vbus_override_enable(qcom, !event);\n\tqcom->mode = event ? USB_DR_MODE_HOST : USB_DR_MODE_PERIPHERAL;\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int dwc3_qcom_register_extcon(struct dwc3_qcom *qcom)\n{\n\tstruct device\t\t*dev = qcom->dev;\n\tstruct extcon_dev\t*host_edev;\n\tint\t\t\tret;\n\n\tif (!of_property_read_bool(dev->of_node, \"extcon\"))\n\t\treturn 0;\n\n\tqcom->edev = extcon_get_edev_by_phandle(dev, 0);\n\tif (IS_ERR(qcom->edev))\n\t\treturn PTR_ERR(qcom->edev);\n\n\tqcom->vbus_nb.notifier_call = dwc3_qcom_vbus_notifier;\n\n\tqcom->host_edev = extcon_get_edev_by_phandle(dev, 1);\n\tif (IS_ERR(qcom->host_edev))\n\t\tqcom->host_edev = NULL;\n\n\tret = devm_extcon_register_notifier(dev, qcom->edev, EXTCON_USB,\n\t\t\t\t\t    &qcom->vbus_nb);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"VBUS notifier register failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (qcom->host_edev)\n\t\thost_edev = qcom->host_edev;\n\telse\n\t\thost_edev = qcom->edev;\n\n\tqcom->host_nb.notifier_call = dwc3_qcom_host_notifier;\n\tret = devm_extcon_register_notifier(dev, host_edev, EXTCON_USB_HOST,\n\t\t\t\t\t    &qcom->host_nb);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Host notifier register failed\\n\");\n\t\treturn ret;\n\t}\n\n\t/* Update initial VBUS override based on extcon state */\n\tif (extcon_get_state(qcom->edev, EXTCON_USB) ||\n\t    !extcon_get_state(host_edev, EXTCON_USB_HOST))\n\t\tdwc3_qcom_vbus_notifier(&qcom->vbus_nb, true, qcom->edev);\n\telse\n\t\tdwc3_qcom_vbus_notifier(&qcom->vbus_nb, false, qcom->edev);\n\n\treturn 0;\n}\n\nstatic int dwc3_qcom_interconnect_enable(struct dwc3_qcom *qcom)\n{\n\tint ret;\n\n\tret = icc_enable(qcom->icc_path_ddr);\n\tif (ret)\n\t\treturn ret;\n\n\tret = icc_enable(qcom->icc_path_apps);\n\tif (ret)\n\t\ticc_disable(qcom->icc_path_ddr);\n\n\treturn ret;\n}\n\nstatic int dwc3_qcom_interconnect_disable(struct dwc3_qcom *qcom)\n{\n\tint ret;\n\n\tret = icc_disable(qcom->icc_path_ddr);\n\tif (ret)\n\t\treturn ret;\n\n\tret = icc_disable(qcom->icc_path_apps);\n\tif (ret)\n\t\ticc_enable(qcom->icc_path_ddr);\n\n\treturn ret;\n}\n\n/**\n * dwc3_qcom_interconnect_init() - Get interconnect path handles\n * and set bandwidth.\n * @qcom:\t\t\tPointer to the concerned usb core.\n *\n */\nstatic int dwc3_qcom_interconnect_init(struct dwc3_qcom *qcom)\n{\n\tstruct device *dev = qcom->dev;\n\tint ret;\n\n\tif (has_acpi_companion(dev))\n\t\treturn 0;\n\n\tqcom->icc_path_ddr = of_icc_get(dev, \"usb-ddr\");\n\tif (IS_ERR(qcom->icc_path_ddr)) {\n\t\tdev_err(dev, \"failed to get usb-ddr path: %ld\\n\",\n\t\t\tPTR_ERR(qcom->icc_path_ddr));\n\t\treturn PTR_ERR(qcom->icc_path_ddr);\n\t}\n\n\tqcom->icc_path_apps = of_icc_get(dev, \"apps-usb\");\n\tif (IS_ERR(qcom->icc_path_apps)) {\n\t\tdev_err(dev, \"failed to get apps-usb path: %ld\\n\",\n\t\t\t\tPTR_ERR(qcom->icc_path_apps));\n\t\treturn PTR_ERR(qcom->icc_path_apps);\n\t}\n\n\tif (usb_get_maximum_speed(&qcom->dwc3->dev) >= USB_SPEED_SUPER ||\n\t\t\tusb_get_maximum_speed(&qcom->dwc3->dev) == USB_SPEED_UNKNOWN)\n\t\tret = icc_set_bw(qcom->icc_path_ddr,\n\t\t\tUSB_MEMORY_AVG_SS_BW, USB_MEMORY_PEAK_SS_BW);\n\telse\n\t\tret = icc_set_bw(qcom->icc_path_ddr,\n\t\t\tUSB_MEMORY_AVG_HS_BW, USB_MEMORY_PEAK_HS_BW);\n\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set bandwidth for usb-ddr path: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = icc_set_bw(qcom->icc_path_apps,\n\t\tAPPS_USB_AVG_BW, APPS_USB_PEAK_BW);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set bandwidth for apps-usb path: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n/**\n * dwc3_qcom_interconnect_exit() - Release interconnect path handles\n * @qcom:\t\t\tPointer to the concerned usb core.\n *\n * This function is used to release interconnect path handle.\n */\nstatic void dwc3_qcom_interconnect_exit(struct dwc3_qcom *qcom)\n{\n\ticc_put(qcom->icc_path_ddr);\n\ticc_put(qcom->icc_path_apps);\n}\n\nstatic void dwc3_qcom_disable_interrupts(struct dwc3_qcom *qcom)\n{\n\tif (qcom->hs_phy_irq) {\n\t\tdisable_irq_wake(qcom->hs_phy_irq);\n\t\tdisable_irq_nosync(qcom->hs_phy_irq);\n\t}\n\n\tif (qcom->dp_hs_phy_irq) {\n\t\tdisable_irq_wake(qcom->dp_hs_phy_irq);\n\t\tdisable_irq_nosync(qcom->dp_hs_phy_irq);\n\t}\n\n\tif (qcom->dm_hs_phy_irq) {\n\t\tdisable_irq_wake(qcom->dm_hs_phy_irq);\n\t\tdisable_irq_nosync(qcom->dm_hs_phy_irq);\n\t}\n\n\tif (qcom->ss_phy_irq) {\n\t\tdisable_irq_wake(qcom->ss_phy_irq);\n\t\tdisable_irq_nosync(qcom->ss_phy_irq);\n\t}\n}\n\nstatic void dwc3_qcom_enable_interrupts(struct dwc3_qcom *qcom)\n{\n\tif (qcom->hs_phy_irq) {\n\t\tenable_irq(qcom->hs_phy_irq);\n\t\tenable_irq_wake(qcom->hs_phy_irq);\n\t}\n\n\tif (qcom->dp_hs_phy_irq) {\n\t\tenable_irq(qcom->dp_hs_phy_irq);\n\t\tenable_irq_wake(qcom->dp_hs_phy_irq);\n\t}\n\n\tif (qcom->dm_hs_phy_irq) {\n\t\tenable_irq(qcom->dm_hs_phy_irq);\n\t\tenable_irq_wake(qcom->dm_hs_phy_irq);\n\t}\n\n\tif (qcom->ss_phy_irq) {\n\t\tenable_irq(qcom->ss_phy_irq);\n\t\tenable_irq_wake(qcom->ss_phy_irq);\n\t}\n}\n\nstatic int dwc3_qcom_suspend(struct dwc3_qcom *qcom)\n{\n\tu32 val;\n\tint i, ret;\n\n\tif (qcom->is_suspended)\n\t\treturn 0;\n\n\tval = readl(qcom->qscratch_base + PWR_EVNT_IRQ_STAT_REG);\n\tif (!(val & PWR_EVNT_LPM_IN_L2_MASK))\n\t\tdev_err(qcom->dev, \"HS-PHY not in L2\\n\");\n\n\tfor (i = qcom->num_clocks - 1; i >= 0; i--)\n\t\tclk_disable_unprepare(qcom->clks[i]);\n\n\tret = dwc3_qcom_interconnect_disable(qcom);\n\tif (ret)\n\t\tdev_warn(qcom->dev, \"failed to disable interconnect: %d\\n\", ret);\n\n\tif (device_may_wakeup(qcom->dev))\n\t\tdwc3_qcom_enable_interrupts(qcom);\n\n\tqcom->is_suspended = true;\n\n\treturn 0;\n}\n\nstatic int dwc3_qcom_resume(struct dwc3_qcom *qcom)\n{\n\tint ret;\n\tint i;\n\n\tif (!qcom->is_suspended)\n\t\treturn 0;\n\n\tif (device_may_wakeup(qcom->dev))\n\t\tdwc3_qcom_disable_interrupts(qcom);\n\n\tfor (i = 0; i < qcom->num_clocks; i++) {\n\t\tret = clk_prepare_enable(qcom->clks[i]);\n\t\tif (ret < 0) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tclk_disable_unprepare(qcom->clks[i]);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = dwc3_qcom_interconnect_enable(qcom);\n\tif (ret)\n\t\tdev_warn(qcom->dev, \"failed to enable interconnect: %d\\n\", ret);\n\n\t/* Clear existing events from PHY related to L2 in/out */\n\tdwc3_qcom_setbits(qcom->qscratch_base, PWR_EVNT_IRQ_STAT_REG,\n\t\t\t  PWR_EVNT_LPM_IN_L2_MASK | PWR_EVNT_LPM_OUT_L2_MASK);\n\n\tqcom->is_suspended = false;\n\n\treturn 0;\n}\n\nstatic irqreturn_t qcom_dwc3_resume_irq(int irq, void *data)\n{\n\tstruct dwc3_qcom *qcom = data;\n\tstruct dwc3\t*dwc = platform_get_drvdata(qcom->dwc3);\n\n\t/* If pm_suspended then let pm_resume take care of resuming h/w */\n\tif (qcom->pm_suspended)\n\t\treturn IRQ_HANDLED;\n\n\tif (dwc->xhci)\n\t\tpm_runtime_resume(&dwc->xhci->dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void dwc3_qcom_select_utmi_clk(struct dwc3_qcom *qcom)\n{\n\t/* Configure dwc3 to use UTMI clock as PIPE clock not present */\n\tdwc3_qcom_setbits(qcom->qscratch_base, QSCRATCH_GENERAL_CFG,\n\t\t\t  PIPE_UTMI_CLK_DIS);\n\n\tusleep_range(100, 1000);\n\n\tdwc3_qcom_setbits(qcom->qscratch_base, QSCRATCH_GENERAL_CFG,\n\t\t\t  PIPE_UTMI_CLK_SEL | PIPE3_PHYSTATUS_SW);\n\n\tusleep_range(100, 1000);\n\n\tdwc3_qcom_clrbits(qcom->qscratch_base, QSCRATCH_GENERAL_CFG,\n\t\t\t  PIPE_UTMI_CLK_DIS);\n}\n\nstatic int dwc3_qcom_get_irq(struct platform_device *pdev,\n\t\t\t     const char *name, int num)\n{\n\tstruct dwc3_qcom *qcom = platform_get_drvdata(pdev);\n\tstruct platform_device *pdev_irq = qcom->urs_usb ? qcom->urs_usb : pdev;\n\tstruct device_node *np = pdev->dev.of_node;\n\tint ret;\n\n\tif (np)\n\t\tret = platform_get_irq_byname(pdev_irq, name);\n\telse\n\t\tret = platform_get_irq(pdev_irq, num);\n\n\treturn ret;\n}\n\nstatic int dwc3_qcom_setup_irq(struct platform_device *pdev)\n{\n\tstruct dwc3_qcom *qcom = platform_get_drvdata(pdev);\n\tconst struct dwc3_acpi_pdata *pdata = qcom->acpi_pdata;\n\tint irq;\n\tint ret;\n\n\tirq = dwc3_qcom_get_irq(pdev, \"hs_phy_irq\",\n\t\t\t\tpdata ? pdata->hs_phy_irq_index : -1);\n\tif (irq > 0) {\n\t\t/* Keep wakeup interrupts disabled until suspend */\n\t\tirq_set_status_flags(irq, IRQ_NOAUTOEN);\n\t\tret = devm_request_threaded_irq(qcom->dev, irq, NULL,\n\t\t\t\t\tqcom_dwc3_resume_irq,\n\t\t\t\t\tIRQF_TRIGGER_HIGH | IRQF_ONESHOT,\n\t\t\t\t\t\"qcom_dwc3 HS\", qcom);\n\t\tif (ret) {\n\t\t\tdev_err(qcom->dev, \"hs_phy_irq failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tqcom->hs_phy_irq = irq;\n\t}\n\n\tirq = dwc3_qcom_get_irq(pdev, \"dp_hs_phy_irq\",\n\t\t\t\tpdata ? pdata->dp_hs_phy_irq_index : -1);\n\tif (irq > 0) {\n\t\tirq_set_status_flags(irq, IRQ_NOAUTOEN);\n\t\tret = devm_request_threaded_irq(qcom->dev, irq, NULL,\n\t\t\t\t\tqcom_dwc3_resume_irq,\n\t\t\t\t\tIRQF_TRIGGER_HIGH | IRQF_ONESHOT,\n\t\t\t\t\t\"qcom_dwc3 DP_HS\", qcom);\n\t\tif (ret) {\n\t\t\tdev_err(qcom->dev, \"dp_hs_phy_irq failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tqcom->dp_hs_phy_irq = irq;\n\t}\n\n\tirq = dwc3_qcom_get_irq(pdev, \"dm_hs_phy_irq\",\n\t\t\t\tpdata ? pdata->dm_hs_phy_irq_index : -1);\n\tif (irq > 0) {\n\t\tirq_set_status_flags(irq, IRQ_NOAUTOEN);\n\t\tret = devm_request_threaded_irq(qcom->dev, irq, NULL,\n\t\t\t\t\tqcom_dwc3_resume_irq,\n\t\t\t\t\tIRQF_TRIGGER_HIGH | IRQF_ONESHOT,\n\t\t\t\t\t\"qcom_dwc3 DM_HS\", qcom);\n\t\tif (ret) {\n\t\t\tdev_err(qcom->dev, \"dm_hs_phy_irq failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tqcom->dm_hs_phy_irq = irq;\n\t}\n\n\tirq = dwc3_qcom_get_irq(pdev, \"ss_phy_irq\",\n\t\t\t\tpdata ? pdata->ss_phy_irq_index : -1);\n\tif (irq > 0) {\n\t\tirq_set_status_flags(irq, IRQ_NOAUTOEN);\n\t\tret = devm_request_threaded_irq(qcom->dev, irq, NULL,\n\t\t\t\t\tqcom_dwc3_resume_irq,\n\t\t\t\t\tIRQF_TRIGGER_HIGH | IRQF_ONESHOT,\n\t\t\t\t\t\"qcom_dwc3 SS\", qcom);\n\t\tif (ret) {\n\t\t\tdev_err(qcom->dev, \"ss_phy_irq failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tqcom->ss_phy_irq = irq;\n\t}\n\n\treturn 0;\n}\n\nstatic int dwc3_qcom_clk_init(struct dwc3_qcom *qcom, int count)\n{\n\tstruct device\t\t*dev = qcom->dev;\n\tstruct device_node\t*np = dev->of_node;\n\tint\t\t\ti;\n\n\tif (!np || !count)\n\t\treturn 0;\n\n\tif (count < 0)\n\t\treturn count;\n\n\tqcom->num_clocks = count;\n\n\tqcom->clks = devm_kcalloc(dev, qcom->num_clocks,\n\t\t\t\t  sizeof(struct clk *), GFP_KERNEL);\n\tif (!qcom->clks)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < qcom->num_clocks; i++) {\n\t\tstruct clk\t*clk;\n\t\tint\t\tret;\n\n\t\tclk = of_clk_get(np, i);\n\t\tif (IS_ERR(clk)) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tclk_put(qcom->clks[i]);\n\t\t\treturn PTR_ERR(clk);\n\t\t}\n\n\t\tret = clk_prepare_enable(clk);\n\t\tif (ret < 0) {\n\t\t\twhile (--i >= 0) {\n\t\t\t\tclk_disable_unprepare(qcom->clks[i]);\n\t\t\t\tclk_put(qcom->clks[i]);\n\t\t\t}\n\t\t\tclk_put(clk);\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tqcom->clks[i] = clk;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct property_entry dwc3_qcom_acpi_properties[] = {\n\tPROPERTY_ENTRY_STRING(\"dr_mode\", \"host\"),\n\t{}\n};\n\nstatic const struct software_node dwc3_qcom_swnode = {\n\t.properties = dwc3_qcom_acpi_properties,\n};\n\nstatic int dwc3_qcom_acpi_register_core(struct platform_device *pdev)\n{\n\tstruct dwc3_qcom\t*qcom = platform_get_drvdata(pdev);\n\tstruct device\t\t*dev = &pdev->dev;\n\tstruct resource\t\t*res, *child_res = NULL;\n\tstruct platform_device\t*pdev_irq = qcom->urs_usb ? qcom->urs_usb :\n\t\t\t\t\t\t\t    pdev;\n\tint\t\t\tirq;\n\tint\t\t\tret;\n\n\tqcom->dwc3 = platform_device_alloc(\"dwc3\", PLATFORM_DEVID_AUTO);\n\tif (!qcom->dwc3)\n\t\treturn -ENOMEM;\n\n\tqcom->dwc3->dev.parent = dev;\n\tqcom->dwc3->dev.type = dev->type;\n\tqcom->dwc3->dev.dma_mask = dev->dma_mask;\n\tqcom->dwc3->dev.dma_parms = dev->dma_parms;\n\tqcom->dwc3->dev.coherent_dma_mask = dev->coherent_dma_mask;\n\n\tchild_res = kcalloc(2, sizeof(*child_res), GFP_KERNEL);\n\tif (!child_res) {\n\t\tplatform_device_put(qcom->dwc3);\n\t\treturn -ENOMEM;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"failed to get memory resource\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tchild_res[0].flags = res->flags;\n\tchild_res[0].start = res->start;\n\tchild_res[0].end = child_res[0].start +\n\t\tqcom->acpi_pdata->dwc3_core_base_size;\n\n\tirq = platform_get_irq(pdev_irq, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto out;\n\t}\n\tchild_res[1].flags = IORESOURCE_IRQ;\n\tchild_res[1].start = child_res[1].end = irq;\n\n\tret = platform_device_add_resources(qcom->dwc3, child_res, 2);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to add resources\\n\");\n\t\tgoto out;\n\t}\n\n\tret = device_add_software_node(&qcom->dwc3->dev, &dwc3_qcom_swnode);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to add properties\\n\");\n\t\tgoto out;\n\t}\n\n\tret = platform_device_add(qcom->dwc3);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to add device\\n\");\n\t\tdevice_remove_software_node(&qcom->dwc3->dev);\n\t\tgoto out;\n\t}\n\tkfree(child_res);\n\treturn 0;\n\nout:\n\tplatform_device_put(qcom->dwc3);\n\tkfree(child_res);\n\treturn ret;\n}\n\nstatic int dwc3_qcom_of_register_core(struct platform_device *pdev)\n{\n\tstruct dwc3_qcom\t*qcom = platform_get_drvdata(pdev);\n\tstruct device_node\t*np = pdev->dev.of_node, *dwc3_np;\n\tstruct device\t\t*dev = &pdev->dev;\n\tint\t\t\tret;\n\n\tdwc3_np = of_get_compatible_child(np, \"snps,dwc3\");\n\tif (!dwc3_np) {\n\t\tdev_err(dev, \"failed to find dwc3 core child\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = of_platform_populate(np, NULL, NULL, dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register dwc3 core - %d\\n\", ret);\n\t\tgoto node_put;\n\t}\n\n\tqcom->dwc3 = of_find_device_by_node(dwc3_np);\n\tif (!qcom->dwc3) {\n\t\tret = -ENODEV;\n\t\tdev_err(dev, \"failed to get dwc3 platform device\\n\");\n\t}\n\nnode_put:\n\tof_node_put(dwc3_np);\n\n\treturn ret;\n}\n\nstatic struct platform_device *\ndwc3_qcom_create_urs_usb_platdev(struct device *dev)\n{\n\tstruct fwnode_handle *fwh;\n\tstruct acpi_device *adev;\n\tchar name[8];\n\tint ret;\n\tint id;\n\n\t/* Figure out device id */\n\tret = sscanf(fwnode_get_name(dev->fwnode), \"URS%d\", &id);\n\tif (!ret)\n\t\treturn NULL;\n\n\t/* Find the child using name */\n\tsnprintf(name, sizeof(name), \"USB%d\", id);\n\tfwh = fwnode_get_named_child_node(dev->fwnode, name);\n\tif (!fwh)\n\t\treturn NULL;\n\n\tadev = to_acpi_device_node(fwh);\n\tif (!adev)\n\t\treturn NULL;\n\n\treturn acpi_create_platform_device(adev, NULL);\n}\n\nstatic int dwc3_qcom_probe(struct platform_device *pdev)\n{\n\tstruct device_node\t*np = pdev->dev.of_node;\n\tstruct device\t\t*dev = &pdev->dev;\n\tstruct dwc3_qcom\t*qcom;\n\tstruct resource\t\t*res, *parent_res = NULL;\n\tint\t\t\tret, i;\n\tbool\t\t\tignore_pipe_clk;\n\n\tqcom = devm_kzalloc(&pdev->dev, sizeof(*qcom), GFP_KERNEL);\n\tif (!qcom)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, qcom);\n\tqcom->dev = &pdev->dev;\n\n\tif (has_acpi_companion(dev)) {\n\t\tqcom->acpi_pdata = acpi_device_get_match_data(dev);\n\t\tif (!qcom->acpi_pdata) {\n\t\t\tdev_err(&pdev->dev, \"no supporting ACPI device data\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tqcom->resets = devm_reset_control_array_get_optional_exclusive(dev);\n\tif (IS_ERR(qcom->resets)) {\n\t\tret = PTR_ERR(qcom->resets);\n\t\tdev_err(&pdev->dev, \"failed to get resets, err=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = reset_control_assert(qcom->resets);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to assert resets, err=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tusleep_range(10, 1000);\n\n\tret = reset_control_deassert(qcom->resets);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to deassert resets, err=%d\\n\", ret);\n\t\tgoto reset_assert;\n\t}\n\n\tret = dwc3_qcom_clk_init(qcom, of_clk_get_parent_count(np));\n\tif (ret) {\n\t\tdev_err(dev, \"failed to get clocks\\n\");\n\t\tgoto reset_assert;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\n\tif (np) {\n\t\tparent_res = res;\n\t} else {\n\t\tparent_res = kmemdup(res, sizeof(struct resource), GFP_KERNEL);\n\t\tif (!parent_res)\n\t\t\treturn -ENOMEM;\n\n\t\tparent_res->start = res->start +\n\t\t\tqcom->acpi_pdata->qscratch_base_offset;\n\t\tparent_res->end = parent_res->start +\n\t\t\tqcom->acpi_pdata->qscratch_base_size;\n\n\t\tif (qcom->acpi_pdata->is_urs) {\n\t\t\tqcom->urs_usb = dwc3_qcom_create_urs_usb_platdev(dev);\n\t\t\tif (IS_ERR_OR_NULL(qcom->urs_usb)) {\n\t\t\t\tdev_err(dev, \"failed to create URS USB platdev\\n\");\n\t\t\t\tif (!qcom->urs_usb)\n\t\t\t\t\treturn -ENODEV;\n\t\t\t\telse\n\t\t\t\t\treturn PTR_ERR(qcom->urs_usb);\n\t\t\t}\n\t\t}\n\t}\n\n\tqcom->qscratch_base = devm_ioremap_resource(dev, parent_res);\n\tif (IS_ERR(qcom->qscratch_base)) {\n\t\tret = PTR_ERR(qcom->qscratch_base);\n\t\tgoto clk_disable;\n\t}\n\n\tret = dwc3_qcom_setup_irq(pdev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to setup IRQs, err=%d\\n\", ret);\n\t\tgoto clk_disable;\n\t}\n\n\t/*\n\t * Disable pipe_clk requirement if specified. Used when dwc3\n\t * operates without SSPHY and only HS/FS/LS modes are supported.\n\t */\n\tignore_pipe_clk = device_property_read_bool(dev,\n\t\t\t\t\"qcom,select-utmi-as-pipe-clk\");\n\tif (ignore_pipe_clk)\n\t\tdwc3_qcom_select_utmi_clk(qcom);\n\n\tif (np)\n\t\tret = dwc3_qcom_of_register_core(pdev);\n\telse\n\t\tret = dwc3_qcom_acpi_register_core(pdev);\n\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register DWC3 Core, err=%d\\n\", ret);\n\t\tgoto depopulate;\n\t}\n\n\tret = dwc3_qcom_interconnect_init(qcom);\n\tif (ret)\n\t\tgoto depopulate;\n\n\tqcom->mode = usb_get_dr_mode(&qcom->dwc3->dev);\n\n\t/* enable vbus override for device mode */\n\tif (qcom->mode == USB_DR_MODE_PERIPHERAL)\n\t\tdwc3_qcom_vbus_override_enable(qcom, true);\n\n\t/* register extcon to override sw_vbus on Vbus change later */\n\tret = dwc3_qcom_register_extcon(qcom);\n\tif (ret)\n\t\tgoto interconnect_exit;\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\tqcom->is_suspended = false;\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\tpm_runtime_forbid(dev);\n\n\treturn 0;\n\ninterconnect_exit:\n\tdwc3_qcom_interconnect_exit(qcom);\ndepopulate:\n\tif (np)\n\t\tof_platform_depopulate(&pdev->dev);\n\telse\n\t\tplatform_device_put(pdev);\nclk_disable:\n\tfor (i = qcom->num_clocks - 1; i >= 0; i--) {\n\t\tclk_disable_unprepare(qcom->clks[i]);\n\t\tclk_put(qcom->clks[i]);\n\t}\nreset_assert:\n\treset_control_assert(qcom->resets);\n\n\treturn ret;\n}\n\nstatic int dwc3_qcom_remove(struct platform_device *pdev)\n{\n\tstruct dwc3_qcom *qcom = platform_get_drvdata(pdev);\n\tstruct device *dev = &pdev->dev;\n\tint i;\n\n\tdevice_remove_software_node(&qcom->dwc3->dev);\n\tof_platform_depopulate(dev);\n\n\tfor (i = qcom->num_clocks - 1; i >= 0; i--) {\n\t\tclk_disable_unprepare(qcom->clks[i]);\n\t\tclk_put(qcom->clks[i]);\n\t}\n\tqcom->num_clocks = 0;\n\n\tdwc3_qcom_interconnect_exit(qcom);\n\treset_control_assert(qcom->resets);\n\n\tpm_runtime_allow(dev);\n\tpm_runtime_disable(dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused dwc3_qcom_pm_suspend(struct device *dev)\n{\n\tstruct dwc3_qcom *qcom = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tret = dwc3_qcom_suspend(qcom);\n\tif (!ret)\n\t\tqcom->pm_suspended = true;\n\n\treturn ret;\n}\n\nstatic int __maybe_unused dwc3_qcom_pm_resume(struct device *dev)\n{\n\tstruct dwc3_qcom *qcom = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = dwc3_qcom_resume(qcom);\n\tif (!ret)\n\t\tqcom->pm_suspended = false;\n\n\treturn ret;\n}\n\nstatic int __maybe_unused dwc3_qcom_runtime_suspend(struct device *dev)\n{\n\tstruct dwc3_qcom *qcom = dev_get_drvdata(dev);\n\n\treturn dwc3_qcom_suspend(qcom);\n}\n\nstatic int __maybe_unused dwc3_qcom_runtime_resume(struct device *dev)\n{\n\tstruct dwc3_qcom *qcom = dev_get_drvdata(dev);\n\n\treturn dwc3_qcom_resume(qcom);\n}\n\nstatic const struct dev_pm_ops dwc3_qcom_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(dwc3_qcom_pm_suspend, dwc3_qcom_pm_resume)\n\tSET_RUNTIME_PM_OPS(dwc3_qcom_runtime_suspend, dwc3_qcom_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic const struct of_device_id dwc3_qcom_of_match[] = {\n\t{ .compatible = \"qcom,dwc3\" },\n\t{ .compatible = \"qcom,msm8996-dwc3\" },\n\t{ .compatible = \"qcom,msm8998-dwc3\" },\n\t{ .compatible = \"qcom,sdm660-dwc3\" },\n\t{ .compatible = \"qcom,sdm845-dwc3\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, dwc3_qcom_of_match);\n\n#ifdef CONFIG_ACPI\nstatic const struct dwc3_acpi_pdata sdm845_acpi_pdata = {\n\t.qscratch_base_offset = SDM845_QSCRATCH_BASE_OFFSET,\n\t.qscratch_base_size = SDM845_QSCRATCH_SIZE,\n\t.dwc3_core_base_size = SDM845_DWC3_CORE_SIZE,\n\t.hs_phy_irq_index = 1,\n\t.dp_hs_phy_irq_index = 4,\n\t.dm_hs_phy_irq_index = 3,\n\t.ss_phy_irq_index = 2\n};\n\nstatic const struct dwc3_acpi_pdata sdm845_acpi_urs_pdata = {\n\t.qscratch_base_offset = SDM845_QSCRATCH_BASE_OFFSET,\n\t.qscratch_base_size = SDM845_QSCRATCH_SIZE,\n\t.dwc3_core_base_size = SDM845_DWC3_CORE_SIZE,\n\t.hs_phy_irq_index = 1,\n\t.dp_hs_phy_irq_index = 4,\n\t.dm_hs_phy_irq_index = 3,\n\t.ss_phy_irq_index = 2,\n\t.is_urs = true,\n};\n\nstatic const struct acpi_device_id dwc3_qcom_acpi_match[] = {\n\t{ \"QCOM2430\", (unsigned long)&sdm845_acpi_pdata },\n\t{ \"QCOM0304\", (unsigned long)&sdm845_acpi_urs_pdata },\n\t{ \"QCOM0497\", (unsigned long)&sdm845_acpi_urs_pdata },\n\t{ \"QCOM04A6\", (unsigned long)&sdm845_acpi_pdata },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, dwc3_qcom_acpi_match);\n#endif\n\nstatic struct platform_driver dwc3_qcom_driver = {\n\t.probe\t\t= dwc3_qcom_probe,\n\t.remove\t\t= dwc3_qcom_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"dwc3-qcom\",\n\t\t.pm\t= &dwc3_qcom_dev_pm_ops,\n\t\t.of_match_table\t= dwc3_qcom_of_match,\n\t\t.acpi_match_table = ACPI_PTR(dwc3_qcom_acpi_match),\n\t},\n};\n\nmodule_platform_driver(dwc3_qcom_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"DesignWare DWC3 QCOM Glue Driver\");\n"], "filenames": ["drivers/usb/dwc3/dwc3-qcom.c"], "buggy_code_start_loc": [778], "buggy_code_end_loc": [781], "fixing_code_start_loc": [778], "fixing_code_end_loc": [784], "type": "CWE-476", "message": "In the Linux kernel before 5.16.3, drivers/usb/dwc3/dwc3-qcom.c misinterprets the dwc3_qcom_create_urs_usb_platdev return value (expects it to be NULL in the error case, whereas it is actually an error pointer).", "other": {"cve": {"id": "CVE-2023-22999", "sourceIdentifier": "cve@mitre.org", "published": "2023-02-28T21:15:12.240", "lastModified": "2023-03-06T16:39:49.743", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 5.16.3, drivers/usb/dwc3/dwc3-qcom.c misinterprets the dwc3_qcom_create_urs_usb_platdev return value (expects it to be NULL in the error case, whereas it is actually an error pointer)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.16.3", "matchCriteriaId": "6FBCF385-C05A-44CC-AF30-EDA38785D4BD"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.16.3", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/torvalds/linux/commit/b52fe2dbb3e655eb1483000adfab68a219549e13", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/b52fe2dbb3e655eb1483000adfab68a219549e13"}}