{"buggy_code": ["/*\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"get_bits.h\"\n#include \"golomb.h\"\n#include \"evc.h\"\n#include \"evc_ps.h\"\n\n#define EXTENDED_SAR 255\n\n// @see ISO_IEC_23094-1 (7.3.7 Reference picture list structure syntax)\nstatic int ref_pic_list_struct(GetBitContext *gb, RefPicListStruct *rpl)\n{\n    uint32_t delta_poc_st, strp_entry_sign_flag = 0;\n    rpl->ref_pic_num = get_ue_golomb_long(gb);\n    if (rpl->ref_pic_num > 0) {\n        delta_poc_st = get_ue_golomb_long(gb);\n\n        rpl->ref_pics[0] = delta_poc_st;\n        if (rpl->ref_pics[0] != 0) {\n            strp_entry_sign_flag = get_bits(gb, 1);\n\n            rpl->ref_pics[0] *= 1 - (strp_entry_sign_flag << 1);\n        }\n    }\n\n    for (int i = 1; i < rpl->ref_pic_num; ++i) {\n        delta_poc_st = get_ue_golomb_long(gb);\n        if (delta_poc_st != 0)\n            strp_entry_sign_flag = get_bits(gb, 1);\n        rpl->ref_pics[i] = rpl->ref_pics[i - 1] + delta_poc_st * (1 - (strp_entry_sign_flag << 1));\n    }\n\n    return 0;\n}\n\n// @see  ISO_IEC_23094-1 (E.2.2 HRD parameters syntax)\nstatic int hrd_parameters(GetBitContext *gb, HRDParameters *hrd)\n{\n    hrd->cpb_cnt_minus1 = get_ue_golomb_31(gb);\n    hrd->bit_rate_scale = get_bits(gb, 4);\n    hrd->cpb_size_scale = get_bits(gb, 4);\n    for (int SchedSelIdx = 0; SchedSelIdx <= hrd->cpb_cnt_minus1; SchedSelIdx++) {\n        hrd->bit_rate_value_minus1[SchedSelIdx] = get_ue_golomb_long(gb);\n        hrd->cpb_size_value_minus1[SchedSelIdx] = get_ue_golomb_long(gb);\n        hrd->cbr_flag[SchedSelIdx] = get_bits(gb, 1);\n    }\n    hrd->initial_cpb_removal_delay_length_minus1 = get_bits(gb, 5);\n    hrd->cpb_removal_delay_length_minus1 = get_bits(gb, 5);\n    hrd->cpb_removal_delay_length_minus1 = get_bits(gb, 5);\n    hrd->time_offset_length = get_bits(gb, 5);\n\n    return 0;\n}\n\n// @see  ISO_IEC_23094-1 (E.2.1 VUI parameters syntax)\nstatic int vui_parameters(GetBitContext *gb, VUIParameters *vui)\n{\n    vui->aspect_ratio_info_present_flag = get_bits(gb, 1);\n    if (vui->aspect_ratio_info_present_flag) {\n        vui->aspect_ratio_idc = get_bits(gb, 8);\n        if (vui->aspect_ratio_idc == EXTENDED_SAR) {\n            vui->sar_width = get_bits(gb, 16);\n            vui->sar_height = get_bits(gb, 16);\n        }\n    }\n    vui->overscan_info_present_flag = get_bits(gb, 1);\n    if (vui->overscan_info_present_flag)\n        vui->overscan_appropriate_flag = get_bits(gb, 1);\n    vui->video_signal_type_present_flag = get_bits(gb, 1);\n    if (vui->video_signal_type_present_flag) {\n        vui->video_format = get_bits(gb, 3);\n        vui->video_full_range_flag = get_bits(gb, 1);\n        vui->colour_description_present_flag = get_bits(gb, 1);\n        if (vui->colour_description_present_flag) {\n            vui->colour_primaries = get_bits(gb, 8);\n            vui->transfer_characteristics = get_bits(gb, 8);\n            vui->matrix_coefficients = get_bits(gb, 8);\n        }\n    }\n    vui->chroma_loc_info_present_flag = get_bits(gb, 1);\n    if (vui->chroma_loc_info_present_flag) {\n        vui->chroma_sample_loc_type_top_field = get_ue_golomb_31(gb);\n        vui->chroma_sample_loc_type_bottom_field = get_ue_golomb_31(gb);\n    }\n    vui->neutral_chroma_indication_flag = get_bits(gb, 1);\n\n    vui->field_seq_flag = get_bits(gb, 1);\n\n    vui->timing_info_present_flag = get_bits(gb, 1);\n    if (vui->timing_info_present_flag) {\n        vui->num_units_in_tick = get_bits_long(gb, 32);\n        vui->time_scale = get_bits_long(gb, 32);\n        vui->fixed_pic_rate_flag = get_bits(gb, 1);\n    }\n    vui->nal_hrd_parameters_present_flag = get_bits(gb, 1);\n    if (vui->nal_hrd_parameters_present_flag)\n        hrd_parameters(gb, &vui->hrd_parameters);\n    vui->vcl_hrd_parameters_present_flag = get_bits(gb, 1);\n    if (vui->vcl_hrd_parameters_present_flag)\n        hrd_parameters(gb, &vui->hrd_parameters);\n    if (vui->nal_hrd_parameters_present_flag || vui->vcl_hrd_parameters_present_flag)\n        vui->low_delay_hrd_flag = get_bits(gb, 1);\n    vui->pic_struct_present_flag = get_bits(gb, 1);\n    vui->bitstream_restriction_flag = get_bits(gb, 1);\n    if (vui->bitstream_restriction_flag) {\n        vui->motion_vectors_over_pic_boundaries_flag = get_bits(gb, 1);\n        vui->max_bytes_per_pic_denom = get_ue_golomb_31(gb);\n        vui->max_bits_per_mb_denom = get_ue_golomb_31(gb);\n        vui->log2_max_mv_length_horizontal = get_ue_golomb_31(gb);\n        vui->log2_max_mv_length_vertical = get_ue_golomb_31(gb);\n        vui->num_reorder_pics = get_ue_golomb_long(gb);\n        vui->max_dec_pic_buffering = get_ue_golomb_long(gb);\n    }\n\n    return 0;\n}\n\n// @see ISO_IEC_23094-1 (7.3.2.1 SPS RBSP syntax)\nint ff_evc_parse_sps(GetBitContext *gb, EVCParamSets *ps)\n{\n    EVCParserSPS *sps;\n    unsigned sps_seq_parameter_set_id;\n    int ret;\n\n    sps_seq_parameter_set_id = get_ue_golomb(gb);\n\n    if (sps_seq_parameter_set_id >= EVC_MAX_SPS_COUNT)\n        return AVERROR_INVALIDDATA;\n\n    sps = av_mallocz(sizeof(*sps));\n    if (!sps)\n        return AVERROR(ENOMEM);\n\n    sps->sps_seq_parameter_set_id = sps_seq_parameter_set_id;\n\n    // the Baseline profile is indicated by profile_idc eqal to 0\n    // the Main profile is indicated by profile_idc eqal to 1\n    sps->profile_idc = get_bits(gb, 8);\n\n    sps->level_idc = get_bits(gb, 8);\n\n    skip_bits_long(gb, 32); /* skip toolset_idc_h */\n    skip_bits_long(gb, 32); /* skip toolset_idc_l */\n\n    // 0 - monochrome\n    // 1 - 4:2:0\n    // 2 - 4:2:2\n    // 3 - 4:4:4\n    sps->chroma_format_idc = get_ue_golomb_31(gb);\n\n    sps->pic_width_in_luma_samples = get_ue_golomb_long(gb);\n    sps->pic_height_in_luma_samples = get_ue_golomb_long(gb);\n\n    sps->bit_depth_luma_minus8 = get_ue_golomb_31(gb);\n    sps->bit_depth_chroma_minus8 = get_ue_golomb_31(gb);\n\n    sps->sps_btt_flag = get_bits1(gb);\n    if (sps->sps_btt_flag) {\n        sps->log2_ctu_size_minus2 = get_ue_golomb_long(gb);\n        sps->log2_min_cb_size_minus2 = get_ue_golomb_long(gb);\n        sps->log2_diff_ctu_max_14_cb_size = get_ue_golomb_long(gb);\n        sps->log2_diff_ctu_max_tt_cb_size = get_ue_golomb_long(gb);\n        sps->log2_diff_min_cb_min_tt_cb_size_minus2 = get_ue_golomb_long(gb);\n    }\n\n    sps->sps_suco_flag = get_bits1(gb);\n    if (sps->sps_suco_flag) {\n        sps->log2_diff_ctu_size_max_suco_cb_size = get_ue_golomb_long(gb);\n        sps->log2_diff_max_suco_min_suco_cb_size = get_ue_golomb_long(gb);\n    }\n\n    sps->sps_admvp_flag = get_bits1(gb);\n    if (sps->sps_admvp_flag) {\n        sps->sps_affine_flag = get_bits1(gb);\n        sps->sps_amvr_flag = get_bits1(gb);\n        sps->sps_dmvr_flag = get_bits1(gb);\n        sps->sps_mmvd_flag = get_bits1(gb);\n        sps->sps_hmvp_flag = get_bits1(gb);\n    }\n\n    sps->sps_eipd_flag =  get_bits1(gb);\n    if (sps->sps_eipd_flag) {\n        sps->sps_ibc_flag = get_bits1(gb);\n        if (sps->sps_ibc_flag)\n            sps->log2_max_ibc_cand_size_minus2 = get_ue_golomb(gb);\n    }\n\n    sps->sps_cm_init_flag = get_bits1(gb);\n    if (sps->sps_cm_init_flag)\n        sps->sps_adcc_flag = get_bits1(gb);\n\n    sps->sps_iqt_flag = get_bits1(gb);\n    if (sps->sps_iqt_flag)\n        sps->sps_ats_flag = get_bits1(gb);\n\n    sps->sps_addb_flag = get_bits1(gb);\n    sps->sps_alf_flag = get_bits1(gb);\n    sps->sps_htdf_flag = get_bits1(gb);\n    sps->sps_rpl_flag = get_bits1(gb);\n    sps->sps_pocs_flag = get_bits1(gb);\n    sps->sps_dquant_flag = get_bits1(gb);\n    sps->sps_dra_flag = get_bits1(gb);\n\n    if (sps->sps_pocs_flag) {\n        sps->log2_max_pic_order_cnt_lsb_minus4 = get_ue_golomb(gb);\n        if (sps->log2_max_pic_order_cnt_lsb_minus4 > 12U) {\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n    }\n\n    if (!sps->sps_pocs_flag || !sps->sps_rpl_flag) {\n        sps->log2_sub_gop_length = get_ue_golomb(gb);\n        if (sps->log2_sub_gop_length > 5U) {\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n        if (sps->log2_sub_gop_length == 0)\n            sps->log2_ref_pic_gap_length = get_ue_golomb(gb);\n    }\n\n    if (!sps->sps_rpl_flag)\n        sps->max_num_tid0_ref_pics = get_ue_golomb_31(gb);\n    else {\n        sps->sps_max_dec_pic_buffering_minus1 = get_ue_golomb_long(gb);\n        sps->long_term_ref_pic_flag = get_bits1(gb);\n        sps->rpl1_same_as_rpl0_flag = get_bits1(gb);\n        sps->num_ref_pic_list_in_sps[0] = get_ue_golomb(gb);\n\n        if ((unsigned)sps->num_ref_pic_list_in_sps[0] >= EVC_MAX_NUM_RPLS) {\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n        for (int i = 0; i < sps->num_ref_pic_list_in_sps[0]; ++i)\n            ref_pic_list_struct(gb, &sps->rpls[0][i]);\n\n        if (!sps->rpl1_same_as_rpl0_flag) {\n            sps->num_ref_pic_list_in_sps[1] = get_ue_golomb(gb);\n            if ((unsigned)sps->num_ref_pic_list_in_sps[1] >= EVC_MAX_NUM_RPLS) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            for (int i = 0; i < sps->num_ref_pic_list_in_sps[1]; ++i)\n                ref_pic_list_struct(gb, &sps->rpls[1][i]);\n        }\n    }\n\n    sps->picture_cropping_flag = get_bits1(gb);\n\n    if (sps->picture_cropping_flag) {\n        sps->picture_crop_left_offset = get_ue_golomb_long(gb);\n        sps->picture_crop_right_offset = get_ue_golomb_long(gb);\n        sps->picture_crop_top_offset = get_ue_golomb_long(gb);\n        sps->picture_crop_bottom_offset = get_ue_golomb_long(gb);\n    }\n\n    if (sps->chroma_format_idc != 0) {\n        sps->chroma_qp_table_struct.chroma_qp_table_present_flag = get_bits1(gb);\n\n        if (sps->chroma_qp_table_struct.chroma_qp_table_present_flag) {\n            sps->chroma_qp_table_struct.same_qp_table_for_chroma = get_bits1(gb);\n            sps->chroma_qp_table_struct.global_offset_flag = get_bits1(gb);\n            for (int i = 0; i < (sps->chroma_qp_table_struct.same_qp_table_for_chroma ? 1 : 2); i++) {\n                sps->chroma_qp_table_struct.num_points_in_qp_table_minus1[i] = get_ue_golomb(gb);\n                if (sps->chroma_qp_table_struct.num_points_in_qp_table_minus1[i] >= EVC_MAX_QP_TABLE_SIZE) {\n                    ret = AVERROR_INVALIDDATA;\n                    goto fail;\n                }\n                for (int j = 0; j <= sps->chroma_qp_table_struct.num_points_in_qp_table_minus1[i]; j++) {\n                    sps->chroma_qp_table_struct.delta_qp_in_val_minus1[i][j] = get_bits(gb, 6);\n                    sps->chroma_qp_table_struct.delta_qp_out_val[i][j] = get_se_golomb_long(gb);\n                }\n            }\n        }\n    }\n\n    sps->vui_parameters_present_flag = get_bits1(gb);\n    if (sps->vui_parameters_present_flag)\n        vui_parameters(gb, &(sps->vui_parameters));\n\n    // @note\n    // If necessary, add the missing fields to the EVCParserSPS structure\n    // and then extend parser implementation\n\n    av_freep(&ps->sps[sps_seq_parameter_set_id]);\n    ps->sps[sps_seq_parameter_set_id] = sps;\n\n    return 0;\nfail:\n    av_free(sps);\n    return ret;\n}\n\n// @see ISO_IEC_23094-1 (7.3.2.2 SPS RBSP syntax)\n//\n// @note\n// The current implementation of parse_sps function doesn't handle VUI parameters parsing.\n// If it will be needed, parse_sps function could be extended to handle VUI parameters parsing\n// to initialize fields of the AVCodecContex i.e. color_primaries, color_trc,color_range\n//\nint ff_evc_parse_pps(GetBitContext *gb, EVCParamSets *ps)\n{\n    EVCParserPPS *pps;\n    unsigned pps_pic_parameter_set_id;\n    int ret;\n\n    pps_pic_parameter_set_id = get_ue_golomb(gb);\n    if (pps_pic_parameter_set_id >= EVC_MAX_PPS_COUNT)\n        return AVERROR_INVALIDDATA;\n\n    pps = av_mallocz(sizeof(*pps));\n    if (!pps)\n        return AVERROR(ENOMEM);\n\n    pps->pps_pic_parameter_set_id = pps_pic_parameter_set_id;\n\n    pps->pps_seq_parameter_set_id = get_ue_golomb(gb);\n    if (pps->pps_seq_parameter_set_id >= EVC_MAX_SPS_COUNT) {\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    pps->num_ref_idx_default_active_minus1[0] = get_ue_golomb(gb);\n    pps->num_ref_idx_default_active_minus1[1] = get_ue_golomb(gb);\n    pps->additional_lt_poc_lsb_len = get_ue_golomb(gb);\n    pps->rpl1_idx_present_flag = get_bits1(gb);\n    pps->single_tile_in_pic_flag = get_bits1(gb);\n\n    if (!pps->single_tile_in_pic_flag) {\n        pps->num_tile_columns_minus1 = get_ue_golomb(gb);\n        pps->num_tile_rows_minus1 = get_ue_golomb(gb);\n        if (pps->num_tile_columns_minus1 >= EVC_MAX_TILE_COLUMNS ||\n            pps->num_tile_rows_minus1 >= EVC_MAX_TILE_ROWS) {\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n        pps->uniform_tile_spacing_flag = get_bits1(gb);\n\n        if (!pps->uniform_tile_spacing_flag) {\n            for (int i = 0; i < pps->num_tile_columns_minus1; i++)\n                pps->tile_column_width_minus1[i] = get_ue_golomb(gb);\n\n            for (int i = 0; i < pps->num_tile_rows_minus1; i++)\n                pps->tile_row_height_minus1[i] = get_ue_golomb(gb);\n        }\n        pps->loop_filter_across_tiles_enabled_flag = get_bits1(gb);\n        pps->tile_offset_len_minus1 = get_ue_golomb(gb);\n    }\n\n    pps->tile_id_len_minus1 = get_ue_golomb(gb);\n    if (pps->tile_id_len_minus1 > 15U) {\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n    pps->explicit_tile_id_flag = get_bits1(gb);\n\n    if (pps->explicit_tile_id_flag) {\n        for (int i = 0; i <= pps->num_tile_rows_minus1; i++) {\n            for (int j = 0; j <= pps->num_tile_columns_minus1; j++)\n                pps->tile_id_val[i][j] = get_bits(gb, pps->tile_id_len_minus1 + 1);\n        }\n    }\n\n    pps->pic_dra_enabled_flag = 0;\n    pps->pic_dra_enabled_flag = get_bits1(gb);\n\n    if (pps->pic_dra_enabled_flag)\n        pps->pic_dra_aps_id = get_bits(gb, 5);\n\n    pps->arbitrary_slice_present_flag = get_bits1(gb);\n    pps->constrained_intra_pred_flag = get_bits1(gb);\n    pps->cu_qp_delta_enabled_flag = get_bits1(gb);\n\n    if (pps->cu_qp_delta_enabled_flag)\n        pps->log2_cu_qp_delta_area_minus6 = get_ue_golomb(gb);\n\n    av_freep(&ps->pps[pps_pic_parameter_set_id]);\n    ps->pps[pps_pic_parameter_set_id] = pps;\n\n    return 0;\nfail:\n    av_free(pps);\n    return ret;\n}\n\nvoid ff_evc_ps_free(EVCParamSets *ps) {\n    for (int i = 0; i < EVC_MAX_SPS_COUNT; i++)\n        av_freep(&ps->sps[i]);\n\n    for (int i = 0; i < EVC_MAX_PPS_COUNT; i++)\n        av_freep(&ps->pps[i]);\n}\n"], "fixing_code": ["/*\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"get_bits.h\"\n#include \"golomb.h\"\n#include \"evc.h\"\n#include \"evc_ps.h\"\n\n#define EXTENDED_SAR 255\n\n// @see ISO_IEC_23094-1 (7.3.7 Reference picture list structure syntax)\nstatic int ref_pic_list_struct(EVCParserSPS *sps, GetBitContext *gb, RefPicListStruct *rpl)\n{\n    uint32_t delta_poc_st, strp_entry_sign_flag = 0;\n    rpl->ref_pic_num = get_ue_golomb_long(gb);\n\n    if ((unsigned)rpl->ref_pic_num  > sps->sps_max_dec_pic_buffering_minus1)\n        return AVERROR_INVALIDDATA;\n\n    if (rpl->ref_pic_num > 0) {\n        delta_poc_st = get_ue_golomb_long(gb);\n\n        rpl->ref_pics[0] = delta_poc_st;\n        if (rpl->ref_pics[0] != 0) {\n            strp_entry_sign_flag = get_bits(gb, 1);\n\n            rpl->ref_pics[0] *= 1 - (strp_entry_sign_flag << 1);\n        }\n    }\n\n    for (int i = 1; i < rpl->ref_pic_num; ++i) {\n        delta_poc_st = get_ue_golomb_long(gb);\n        if (delta_poc_st != 0)\n            strp_entry_sign_flag = get_bits(gb, 1);\n        rpl->ref_pics[i] = rpl->ref_pics[i - 1] + delta_poc_st * (1 - (strp_entry_sign_flag << 1));\n    }\n\n    return 0;\n}\n\n// @see  ISO_IEC_23094-1 (E.2.2 HRD parameters syntax)\nstatic int hrd_parameters(GetBitContext *gb, HRDParameters *hrd)\n{\n    hrd->cpb_cnt_minus1 = get_ue_golomb_31(gb);\n    hrd->bit_rate_scale = get_bits(gb, 4);\n    hrd->cpb_size_scale = get_bits(gb, 4);\n    for (int SchedSelIdx = 0; SchedSelIdx <= hrd->cpb_cnt_minus1; SchedSelIdx++) {\n        hrd->bit_rate_value_minus1[SchedSelIdx] = get_ue_golomb_long(gb);\n        hrd->cpb_size_value_minus1[SchedSelIdx] = get_ue_golomb_long(gb);\n        hrd->cbr_flag[SchedSelIdx] = get_bits(gb, 1);\n    }\n    hrd->initial_cpb_removal_delay_length_minus1 = get_bits(gb, 5);\n    hrd->cpb_removal_delay_length_minus1 = get_bits(gb, 5);\n    hrd->cpb_removal_delay_length_minus1 = get_bits(gb, 5);\n    hrd->time_offset_length = get_bits(gb, 5);\n\n    return 0;\n}\n\n// @see  ISO_IEC_23094-1 (E.2.1 VUI parameters syntax)\nstatic int vui_parameters(GetBitContext *gb, VUIParameters *vui)\n{\n    vui->aspect_ratio_info_present_flag = get_bits(gb, 1);\n    if (vui->aspect_ratio_info_present_flag) {\n        vui->aspect_ratio_idc = get_bits(gb, 8);\n        if (vui->aspect_ratio_idc == EXTENDED_SAR) {\n            vui->sar_width = get_bits(gb, 16);\n            vui->sar_height = get_bits(gb, 16);\n        }\n    }\n    vui->overscan_info_present_flag = get_bits(gb, 1);\n    if (vui->overscan_info_present_flag)\n        vui->overscan_appropriate_flag = get_bits(gb, 1);\n    vui->video_signal_type_present_flag = get_bits(gb, 1);\n    if (vui->video_signal_type_present_flag) {\n        vui->video_format = get_bits(gb, 3);\n        vui->video_full_range_flag = get_bits(gb, 1);\n        vui->colour_description_present_flag = get_bits(gb, 1);\n        if (vui->colour_description_present_flag) {\n            vui->colour_primaries = get_bits(gb, 8);\n            vui->transfer_characteristics = get_bits(gb, 8);\n            vui->matrix_coefficients = get_bits(gb, 8);\n        }\n    }\n    vui->chroma_loc_info_present_flag = get_bits(gb, 1);\n    if (vui->chroma_loc_info_present_flag) {\n        vui->chroma_sample_loc_type_top_field = get_ue_golomb_31(gb);\n        vui->chroma_sample_loc_type_bottom_field = get_ue_golomb_31(gb);\n    }\n    vui->neutral_chroma_indication_flag = get_bits(gb, 1);\n\n    vui->field_seq_flag = get_bits(gb, 1);\n\n    vui->timing_info_present_flag = get_bits(gb, 1);\n    if (vui->timing_info_present_flag) {\n        vui->num_units_in_tick = get_bits_long(gb, 32);\n        vui->time_scale = get_bits_long(gb, 32);\n        vui->fixed_pic_rate_flag = get_bits(gb, 1);\n    }\n    vui->nal_hrd_parameters_present_flag = get_bits(gb, 1);\n    if (vui->nal_hrd_parameters_present_flag)\n        hrd_parameters(gb, &vui->hrd_parameters);\n    vui->vcl_hrd_parameters_present_flag = get_bits(gb, 1);\n    if (vui->vcl_hrd_parameters_present_flag)\n        hrd_parameters(gb, &vui->hrd_parameters);\n    if (vui->nal_hrd_parameters_present_flag || vui->vcl_hrd_parameters_present_flag)\n        vui->low_delay_hrd_flag = get_bits(gb, 1);\n    vui->pic_struct_present_flag = get_bits(gb, 1);\n    vui->bitstream_restriction_flag = get_bits(gb, 1);\n    if (vui->bitstream_restriction_flag) {\n        vui->motion_vectors_over_pic_boundaries_flag = get_bits(gb, 1);\n        vui->max_bytes_per_pic_denom = get_ue_golomb_31(gb);\n        vui->max_bits_per_mb_denom = get_ue_golomb_31(gb);\n        vui->log2_max_mv_length_horizontal = get_ue_golomb_31(gb);\n        vui->log2_max_mv_length_vertical = get_ue_golomb_31(gb);\n        vui->num_reorder_pics = get_ue_golomb_long(gb);\n        vui->max_dec_pic_buffering = get_ue_golomb_long(gb);\n    }\n\n    return 0;\n}\n\n// @see ISO_IEC_23094-1 (7.3.2.1 SPS RBSP syntax)\nint ff_evc_parse_sps(GetBitContext *gb, EVCParamSets *ps)\n{\n    EVCParserSPS *sps;\n    unsigned sps_seq_parameter_set_id;\n    int ret;\n\n    sps_seq_parameter_set_id = get_ue_golomb(gb);\n\n    if (sps_seq_parameter_set_id >= EVC_MAX_SPS_COUNT)\n        return AVERROR_INVALIDDATA;\n\n    sps = av_mallocz(sizeof(*sps));\n    if (!sps)\n        return AVERROR(ENOMEM);\n\n    sps->sps_seq_parameter_set_id = sps_seq_parameter_set_id;\n\n    // the Baseline profile is indicated by profile_idc eqal to 0\n    // the Main profile is indicated by profile_idc eqal to 1\n    sps->profile_idc = get_bits(gb, 8);\n\n    sps->level_idc = get_bits(gb, 8);\n\n    skip_bits_long(gb, 32); /* skip toolset_idc_h */\n    skip_bits_long(gb, 32); /* skip toolset_idc_l */\n\n    // 0 - monochrome\n    // 1 - 4:2:0\n    // 2 - 4:2:2\n    // 3 - 4:4:4\n    sps->chroma_format_idc = get_ue_golomb_31(gb);\n\n    sps->pic_width_in_luma_samples = get_ue_golomb_long(gb);\n    sps->pic_height_in_luma_samples = get_ue_golomb_long(gb);\n\n    sps->bit_depth_luma_minus8 = get_ue_golomb_31(gb);\n    sps->bit_depth_chroma_minus8 = get_ue_golomb_31(gb);\n\n    sps->sps_btt_flag = get_bits1(gb);\n    if (sps->sps_btt_flag) {\n        sps->log2_ctu_size_minus2 = get_ue_golomb_long(gb);\n        sps->log2_min_cb_size_minus2 = get_ue_golomb_long(gb);\n        sps->log2_diff_ctu_max_14_cb_size = get_ue_golomb_long(gb);\n        sps->log2_diff_ctu_max_tt_cb_size = get_ue_golomb_long(gb);\n        sps->log2_diff_min_cb_min_tt_cb_size_minus2 = get_ue_golomb_long(gb);\n    }\n\n    sps->sps_suco_flag = get_bits1(gb);\n    if (sps->sps_suco_flag) {\n        sps->log2_diff_ctu_size_max_suco_cb_size = get_ue_golomb_long(gb);\n        sps->log2_diff_max_suco_min_suco_cb_size = get_ue_golomb_long(gb);\n    }\n\n    sps->sps_admvp_flag = get_bits1(gb);\n    if (sps->sps_admvp_flag) {\n        sps->sps_affine_flag = get_bits1(gb);\n        sps->sps_amvr_flag = get_bits1(gb);\n        sps->sps_dmvr_flag = get_bits1(gb);\n        sps->sps_mmvd_flag = get_bits1(gb);\n        sps->sps_hmvp_flag = get_bits1(gb);\n    }\n\n    sps->sps_eipd_flag =  get_bits1(gb);\n    if (sps->sps_eipd_flag) {\n        sps->sps_ibc_flag = get_bits1(gb);\n        if (sps->sps_ibc_flag)\n            sps->log2_max_ibc_cand_size_minus2 = get_ue_golomb(gb);\n    }\n\n    sps->sps_cm_init_flag = get_bits1(gb);\n    if (sps->sps_cm_init_flag)\n        sps->sps_adcc_flag = get_bits1(gb);\n\n    sps->sps_iqt_flag = get_bits1(gb);\n    if (sps->sps_iqt_flag)\n        sps->sps_ats_flag = get_bits1(gb);\n\n    sps->sps_addb_flag = get_bits1(gb);\n    sps->sps_alf_flag = get_bits1(gb);\n    sps->sps_htdf_flag = get_bits1(gb);\n    sps->sps_rpl_flag = get_bits1(gb);\n    sps->sps_pocs_flag = get_bits1(gb);\n    sps->sps_dquant_flag = get_bits1(gb);\n    sps->sps_dra_flag = get_bits1(gb);\n\n    if (sps->sps_pocs_flag) {\n        sps->log2_max_pic_order_cnt_lsb_minus4 = get_ue_golomb(gb);\n        if (sps->log2_max_pic_order_cnt_lsb_minus4 > 12U) {\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n    }\n\n    if (!sps->sps_pocs_flag || !sps->sps_rpl_flag) {\n        sps->log2_sub_gop_length = get_ue_golomb(gb);\n        if (sps->log2_sub_gop_length > 5U) {\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n        if (sps->log2_sub_gop_length == 0)\n            sps->log2_ref_pic_gap_length = get_ue_golomb(gb);\n    }\n\n    if (!sps->sps_rpl_flag)\n        sps->max_num_tid0_ref_pics = get_ue_golomb_31(gb);\n    else {\n        sps->sps_max_dec_pic_buffering_minus1 = get_ue_golomb_long(gb);\n        if ((unsigned)sps->sps_max_dec_pic_buffering_minus1 > 16 - 1)\n            return AVERROR_INVALIDDATA;\n        sps->long_term_ref_pic_flag = get_bits1(gb);\n        sps->rpl1_same_as_rpl0_flag = get_bits1(gb);\n        sps->num_ref_pic_list_in_sps[0] = get_ue_golomb(gb);\n\n        if ((unsigned)sps->num_ref_pic_list_in_sps[0] >= EVC_MAX_NUM_RPLS) {\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n        for (int i = 0; i < sps->num_ref_pic_list_in_sps[0]; ++i) {\n            ret = ref_pic_list_struct(sps, gb, &sps->rpls[0][i]);\n            if (ret < 0)\n                goto fail;\n        }\n\n        if (!sps->rpl1_same_as_rpl0_flag) {\n            sps->num_ref_pic_list_in_sps[1] = get_ue_golomb(gb);\n            if ((unsigned)sps->num_ref_pic_list_in_sps[1] >= EVC_MAX_NUM_RPLS) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            for (int i = 0; i < sps->num_ref_pic_list_in_sps[1]; ++i) {\n                ret = ref_pic_list_struct(sps, gb, &sps->rpls[1][i]);\n                if (ret < 0)\n                    goto fail;\n            }\n        }\n    }\n\n    sps->picture_cropping_flag = get_bits1(gb);\n\n    if (sps->picture_cropping_flag) {\n        sps->picture_crop_left_offset = get_ue_golomb_long(gb);\n        sps->picture_crop_right_offset = get_ue_golomb_long(gb);\n        sps->picture_crop_top_offset = get_ue_golomb_long(gb);\n        sps->picture_crop_bottom_offset = get_ue_golomb_long(gb);\n    }\n\n    if (sps->chroma_format_idc != 0) {\n        sps->chroma_qp_table_struct.chroma_qp_table_present_flag = get_bits1(gb);\n\n        if (sps->chroma_qp_table_struct.chroma_qp_table_present_flag) {\n            sps->chroma_qp_table_struct.same_qp_table_for_chroma = get_bits1(gb);\n            sps->chroma_qp_table_struct.global_offset_flag = get_bits1(gb);\n            for (int i = 0; i < (sps->chroma_qp_table_struct.same_qp_table_for_chroma ? 1 : 2); i++) {\n                sps->chroma_qp_table_struct.num_points_in_qp_table_minus1[i] = get_ue_golomb(gb);\n                if (sps->chroma_qp_table_struct.num_points_in_qp_table_minus1[i] >= EVC_MAX_QP_TABLE_SIZE) {\n                    ret = AVERROR_INVALIDDATA;\n                    goto fail;\n                }\n                for (int j = 0; j <= sps->chroma_qp_table_struct.num_points_in_qp_table_minus1[i]; j++) {\n                    sps->chroma_qp_table_struct.delta_qp_in_val_minus1[i][j] = get_bits(gb, 6);\n                    sps->chroma_qp_table_struct.delta_qp_out_val[i][j] = get_se_golomb_long(gb);\n                }\n            }\n        }\n    }\n\n    sps->vui_parameters_present_flag = get_bits1(gb);\n    if (sps->vui_parameters_present_flag)\n        vui_parameters(gb, &(sps->vui_parameters));\n\n    // @note\n    // If necessary, add the missing fields to the EVCParserSPS structure\n    // and then extend parser implementation\n\n    av_freep(&ps->sps[sps_seq_parameter_set_id]);\n    ps->sps[sps_seq_parameter_set_id] = sps;\n\n    return 0;\nfail:\n    av_free(sps);\n    return ret;\n}\n\n// @see ISO_IEC_23094-1 (7.3.2.2 SPS RBSP syntax)\n//\n// @note\n// The current implementation of parse_sps function doesn't handle VUI parameters parsing.\n// If it will be needed, parse_sps function could be extended to handle VUI parameters parsing\n// to initialize fields of the AVCodecContex i.e. color_primaries, color_trc,color_range\n//\nint ff_evc_parse_pps(GetBitContext *gb, EVCParamSets *ps)\n{\n    EVCParserPPS *pps;\n    unsigned pps_pic_parameter_set_id;\n    int ret;\n\n    pps_pic_parameter_set_id = get_ue_golomb(gb);\n    if (pps_pic_parameter_set_id >= EVC_MAX_PPS_COUNT)\n        return AVERROR_INVALIDDATA;\n\n    pps = av_mallocz(sizeof(*pps));\n    if (!pps)\n        return AVERROR(ENOMEM);\n\n    pps->pps_pic_parameter_set_id = pps_pic_parameter_set_id;\n\n    pps->pps_seq_parameter_set_id = get_ue_golomb(gb);\n    if (pps->pps_seq_parameter_set_id >= EVC_MAX_SPS_COUNT) {\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    pps->num_ref_idx_default_active_minus1[0] = get_ue_golomb(gb);\n    pps->num_ref_idx_default_active_minus1[1] = get_ue_golomb(gb);\n    pps->additional_lt_poc_lsb_len = get_ue_golomb(gb);\n    pps->rpl1_idx_present_flag = get_bits1(gb);\n    pps->single_tile_in_pic_flag = get_bits1(gb);\n\n    if (!pps->single_tile_in_pic_flag) {\n        pps->num_tile_columns_minus1 = get_ue_golomb(gb);\n        pps->num_tile_rows_minus1 = get_ue_golomb(gb);\n        if (pps->num_tile_columns_minus1 >= EVC_MAX_TILE_COLUMNS ||\n            pps->num_tile_rows_minus1 >= EVC_MAX_TILE_ROWS) {\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n        pps->uniform_tile_spacing_flag = get_bits1(gb);\n\n        if (!pps->uniform_tile_spacing_flag) {\n            for (int i = 0; i < pps->num_tile_columns_minus1; i++)\n                pps->tile_column_width_minus1[i] = get_ue_golomb(gb);\n\n            for (int i = 0; i < pps->num_tile_rows_minus1; i++)\n                pps->tile_row_height_minus1[i] = get_ue_golomb(gb);\n        }\n        pps->loop_filter_across_tiles_enabled_flag = get_bits1(gb);\n        pps->tile_offset_len_minus1 = get_ue_golomb(gb);\n    }\n\n    pps->tile_id_len_minus1 = get_ue_golomb(gb);\n    if (pps->tile_id_len_minus1 > 15U) {\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n    pps->explicit_tile_id_flag = get_bits1(gb);\n\n    if (pps->explicit_tile_id_flag) {\n        for (int i = 0; i <= pps->num_tile_rows_minus1; i++) {\n            for (int j = 0; j <= pps->num_tile_columns_minus1; j++)\n                pps->tile_id_val[i][j] = get_bits(gb, pps->tile_id_len_minus1 + 1);\n        }\n    }\n\n    pps->pic_dra_enabled_flag = 0;\n    pps->pic_dra_enabled_flag = get_bits1(gb);\n\n    if (pps->pic_dra_enabled_flag)\n        pps->pic_dra_aps_id = get_bits(gb, 5);\n\n    pps->arbitrary_slice_present_flag = get_bits1(gb);\n    pps->constrained_intra_pred_flag = get_bits1(gb);\n    pps->cu_qp_delta_enabled_flag = get_bits1(gb);\n\n    if (pps->cu_qp_delta_enabled_flag)\n        pps->log2_cu_qp_delta_area_minus6 = get_ue_golomb(gb);\n\n    av_freep(&ps->pps[pps_pic_parameter_set_id]);\n    ps->pps[pps_pic_parameter_set_id] = pps;\n\n    return 0;\nfail:\n    av_free(pps);\n    return ret;\n}\n\nvoid ff_evc_ps_free(EVCParamSets *ps) {\n    for (int i = 0; i < EVC_MAX_SPS_COUNT; i++)\n        av_freep(&ps->sps[i]);\n\n    for (int i = 0; i < EVC_MAX_PPS_COUNT; i++)\n        av_freep(&ps->pps[i]);\n}\n"], "filenames": ["libavcodec/evc_ps.c"], "buggy_code_start_loc": [27], "buggy_code_end_loc": [262], "fixing_code_start_loc": [27], "fixing_code_end_loc": [274], "type": "CWE-787", "message": "Buffer Overflow vulnerability in Ffmpeg before github commit 4565747056a11356210ed8edcecb920105e40b60 allows a remote attacker to achieve an out-of-array write, execute arbitrary code, and cause a denial of service (DoS) via the ref_pic_list_struct function in libavcodec/evc_ps.c", "other": {"cve": {"id": "CVE-2023-47470", "sourceIdentifier": "cve@mitre.org", "published": "2023-11-16T03:15:07.400", "lastModified": "2023-11-29T20:32:05.517", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Buffer Overflow vulnerability in Ffmpeg before github commit 4565747056a11356210ed8edcecb920105e40b60 allows a remote attacker to achieve an out-of-array write, execute arbitrary code, and cause a denial of service (DoS) via the ref_pic_list_struct function in libavcodec/evc_ps.c"}, {"lang": "es", "value": "Vulnerabilidad de desbordamiento del b\u00fafer en Ffmpeg anterior al commit de github 4565747056a11356210ed8edcecb920105e40b60 permite a un atacante remoto lograr una escritura fuera de matriz, ejecutar c\u00f3digo arbitrario y provocar una denegaci\u00f3n de servicio (DoS) a trav\u00e9s de la funci\u00f3n ref_pic_list_struct en libavcodec/evc_ps.c"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.1", "matchCriteriaId": "54E3D89D-E427-413B-A8E1-C9ED6D2409F3"}]}]}], "references": [{"url": "https://github.com/FFmpeg/FFmpeg/commit/4565747056a11356210ed8edcecb920105e40b60", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/goldds96/Report/tree/main/FFmpeg", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://patchwork.ffmpeg.org/project/ffmpeg/patch/20230915131147.5945-2-michael%40niedermayer.cc/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/4565747056a11356210ed8edcecb920105e40b60"}}