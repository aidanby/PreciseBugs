{"buggy_code": ["<?php\n# MantisBT - A PHP based bugtracking system\n\n# MantisBT is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 2 of the License, or\n# (at your option) any later version.\n#\n# MantisBT is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with MantisBT.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * This page allows actions to be performed an an array of bugs\n *\n * @package MantisBT\n * @copyright Copyright (C) 2000 - 2002  Kenzaburo Ito - kenito@300baud.org\n * @copyright Copyright (C) 2002 - 2012  MantisBT Team - mantisbt-dev@lists.sourceforge.net\n * @link http://www.mantisbt.org\n *\n * @uses core.php\n * @uses access_api.php\n * @uses authentication_api.php\n * @uses bug_api.php\n * @uses bugnote_api.php\n * @uses category_api.php\n * @uses config_api.php\n * @uses constant_inc.php\n * @uses custom_field_api.php\n * @uses event_api.php\n * @uses form_api.php\n * @uses gpc_api.php\n * @uses helper_api.php\n * @uses html_api.php\n * @uses lang_api.php\n * @uses print_api.php\n * @uses string_api.php\n * @uses utility_api.php\n * @uses version_api.php\n */\n\n/**\n * MantisBT Core API's\n */\nrequire_once( 'core.php' );\nrequire_api( 'access_api.php' );\nrequire_api( 'authentication_api.php' );\nrequire_api( 'bug_api.php' );\nrequire_api( 'bugnote_api.php' );\nrequire_api( 'category_api.php' );\nrequire_api( 'config_api.php' );\nrequire_api( 'constant_inc.php' );\nrequire_api( 'custom_field_api.php' );\nrequire_api( 'event_api.php' );\nrequire_api( 'form_api.php' );\nrequire_api( 'gpc_api.php' );\nrequire_api( 'helper_api.php' );\nrequire_api( 'html_api.php' );\nrequire_api( 'lang_api.php' );\nrequire_api( 'print_api.php' );\nrequire_api( 'string_api.php' );\nrequire_api( 'utility_api.php' );\nrequire_api( 'version_api.php' );\n\nauth_ensure_user_authenticated();\nhelper_begin_long_process();\n\n$f_action\t= gpc_get_string( 'action' );\n$f_custom_field_id = gpc_get_int( 'custom_field_id', 0 );\n$f_bug_arr\t= gpc_get_int_array( 'bug_arr', array() );\n$f_bug_notetext = gpc_get_string( 'bugnote_text', '' );\n$f_bug_noteprivate = gpc_get_bool( 'private' );\n$t_form_name = 'bug_actiongroup_' . $f_action;\nform_security_validate( $t_form_name );\n\n$t_custom_group_actions = config_get( 'custom_group_actions' );\n\nforeach( $t_custom_group_actions as $t_custom_group_action ) {\n\tif ( $f_action == $t_custom_group_action['action'] ) {\n\t\trequire_once( $t_custom_group_action['action_page'] );\n\t\texit;\n\t}\n}\n\n$t_failed_ids = array();\n\nif ( 0 != $f_custom_field_id ) {\n\t$t_custom_field_def = custom_field_get_definition( $f_custom_field_id );\n}\n\nforeach( $f_bug_arr as $t_bug_id ) {\n\tbug_ensure_exists( $t_bug_id );\n\t$t_bug = bug_get( $t_bug_id, true );\n\n\tif( $t_bug->project_id != helper_get_current_project() ) {\n\t\t# in case the current project is not the same project of the bug we are viewing...\n\t\t# ... override the current project. This to avoid problems with categories and handlers lists etc.\n\t\t$g_project_override = $t_bug->project_id;\n\t\t/** @todo (thraxisp) the next line goes away if the cache was smarter and used project */\n\t\tconfig_flush_cache(); # flush the config cache so that configs are refetched\n\t}\n\n\t$t_status = $t_bug->status;\n\n\tswitch ( $f_action ) {\n\n\tcase 'CLOSE':\n\t\t$t_closed = config_get( 'bug_closed_status_threshold' );\n\t\tif ( access_can_close_bug( $t_bug_id ) ) {\n\t\t\tif( ( $t_status < $t_closed ) &&\n\t\t\t\tbug_check_workflow( $t_status, $t_closed ) ) {\n\n\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $f_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\tbug_close( $t_bug_id, $f_bug_notetext, $f_bug_noteprivate );\n\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t} else {\n\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_status' );\n\t\t\t}\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'DELETE':\n\t\tif ( access_has_bug_level( config_get( 'delete_bug_threshold' ), $t_bug_id ) ) {\n\t\t\tevent_signal( 'EVENT_BUG_DELETED', array( $t_bug_id ) );\n\t\t\tbug_delete( $t_bug_id );\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'MOVE':\n\t\t$f_project_id = gpc_get_int( 'project_id' );\n\t\tif ( access_has_bug_level( config_get( 'move_bug_threshold' ), $t_bug_id ) &&\n\t\t     access_has_project_level( config_get( 'report_bug_threshold' ), $f_project_id ) ) {\n\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\tbug_move( $t_bug_id, $f_project_id );\n\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'COPY':\n\t\t$f_project_id = gpc_get_int( 'project_id' );\n\n\t\tif ( access_has_project_level( config_get( 'report_bug_threshold' ), $f_project_id ) ) {\n\t\t\tbug_copy( $t_bug_id, $f_project_id, true, true, true, true, true, true );\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'ASSIGN':\n\t\t$f_assign = gpc_get_int( 'assign' );\n\t\tif ( ON == config_get( 'auto_set_status_to_assigned' ) ) {\n\t\t\t$t_assign_status = config_get( 'bug_assigned_status' );\n\t\t} else {\n\t\t\t$t_assign_status = $t_status;\n\t\t}\n\t\t# check that new handler has rights to handle the issue, and\n\t\t#  that current user has rights to assign the issue\n\t\t$t_threshold = access_get_status_threshold( $t_assign_status, bug_get_field( $t_bug_id, 'project_id' ) );\n\t\tif ( access_has_bug_level( config_get( 'update_bug_assign_threshold', config_get( 'update_bug_threshold' ) ), $t_bug_id ) ) {\n\t\t\tif ( access_has_bug_level( config_get( 'handle_bug_threshold' ), $t_bug_id, $f_assign ) ) {\n\t\t\t\tif ( bug_check_workflow( $t_status, $t_assign_status ) ) {\n\t\t\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\t\t\tbug_assign( $t_bug_id, $f_assign, $f_bug_notetext, $f_bug_noteprivate );\n\t\t\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t\t\t} else {\n\t\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_status' );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_handler' );\n\t\t\t}\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'RESOLVE':\n\t\t$t_resolved_status = config_get( 'bug_resolved_status_threshold' );\n\t\t\tif ( access_has_bug_level( access_get_status_threshold( $t_resolved_status, bug_get_field( $t_bug_id, 'project_id' ) ), $t_bug_id ) ) {\n\t\t\t\tif ( ( $t_status < $t_resolved_status ) &&\n\t\t\t\t\tbug_check_workflow($t_status, $t_resolved_status ) ) {\n\t\t\t$f_resolution = gpc_get_int( 'resolution' );\n\t\t\t$f_fixed_in_version = gpc_get_string( 'fixed_in_version', '' );\n\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\tbug_resolve( $t_bug_id, $f_resolution, $f_fixed_in_version, $f_bug_notetext, null, null, $f_bug_noteprivate );\n\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t} else {\n\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_status' );\n\t\t\t}\n\t\t\t} else {\n\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'UP_PRIOR':\n\t\tif ( access_has_bug_level( config_get( 'update_bug_threshold' ), $t_bug_id ) ) {\n\t\t\t$f_priority = gpc_get_int( 'priority' );\n\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\tbug_set_field( $t_bug_id, 'priority', $f_priority );\n\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'UP_STATUS':\n\t\t$f_status = gpc_get_int( 'status' );\n\t\t$t_project = bug_get_field( $t_bug_id, 'project_id' );\n\t\tif ( access_has_bug_level( access_get_status_threshold( $f_status, $t_project ), $t_bug_id ) ) {\n\t\t\tif ( TRUE == bug_check_workflow($t_status, $f_status ) ) {\n\t\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\t\tbug_set_field( $t_bug_id, 'status', $f_status );\n\n\t\t\t\t# Add bugnote if supplied\n\t\t\t\tif ( !is_blank( $f_bug_notetext ) ) {\n\t\t\t\t\tbugnote_add( $t_bug_id, $f_bug_notetext, null, $f_bug_noteprivate );\n\t\t\t\t}\n\n\t\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t\t} else {\n\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_status' );\n\t\t\t}\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'UP_CATEGORY':\n\t\t$f_category_id = gpc_get_int( 'category' );\n\t\tif ( access_has_bug_level( config_get( 'update_bug_threshold' ), $t_bug_id ) ) {\n\t\t\tif ( category_exists( $f_category_id ) ) {\n\t\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\t\tbug_set_field( $t_bug_id, 'category_id', $f_category_id );\n\t\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t\t} else {\n\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_category' );\n\t\t\t}\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'UP_FIXED_IN_VERSION':\n\t\t$f_fixed_in_version = gpc_get_string( 'fixed_in_version' );\n\t\t$t_project_id = bug_get_field( $t_bug_id, 'project_id' );\n\n\t\tif ( access_has_bug_level( config_get( 'update_bug_threshold' ), $t_bug_id ) ) {\n\t\t\tif ( $f_fixed_in_version === '' || version_get_id( $f_fixed_in_version, $t_project_id ) !== false ) {\n\t\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\t\tbug_set_field( $t_bug_id, 'fixed_in_version', $f_fixed_in_version );\n\t\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t\t\t} else {\n\t\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_version' );\n\t\t\t}\n\t\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'UP_TARGET_VERSION':\n\t\t$f_target_version = gpc_get_string( 'target_version' );\n\t\t$t_project_id = bug_get_field( $t_bug_id, 'project_id' );\n\n\t\tif ( access_has_bug_level( config_get( 'roadmap_update_threshold' ), $t_bug_id ) ) {\n\t\t\tif ( $f_target_version === '' || version_get_id( $f_target_version, $t_project_id ) !== false ) {\n\t\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\t\tbug_set_field( $t_bug_id, 'target_version', $f_target_version );\n\t\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t\t\t} else {\n\t\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_version' );\n\t\t\t}\n\t\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'VIEW_STATUS':\n\t\tif ( access_has_bug_level( config_get( 'change_view_status_threshold' ), $t_bug_id ) ) {\n\t\t\t$f_view_status = gpc_get_int( 'view_status' );\n\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\tbug_set_field( $t_bug_id, 'view_state', $f_view_status );\n\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'SET_STICKY':\n\t\tif ( access_has_bug_level( config_get( 'set_bug_sticky_threshold' ), $t_bug_id ) ) {\n\t\t\t$f_sticky = bug_get_field( $t_bug_id, 'sticky' );\n\t\t\t// The new value is the inverted old value\n\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\tbug_set_field( $t_bug_id, 'sticky', intval( !$f_sticky ) );\n\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'CUSTOM':\n\t\tif ( 0 === $f_custom_field_id ) {\n\t\t\ttrigger_error( ERROR_GENERIC, ERROR );\n\t\t}\n\n\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t$t_form_var = \"custom_field_$f_custom_field_id\";\n\t\t$t_custom_field_value = gpc_get_custom_field( $t_form_var, $t_custom_field_def['type'], null );\n\t\tcustom_field_set_value( $f_custom_field_id, $t_bug_id, $t_custom_field_value );\n\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\tbreak;\n\n\tdefault:\n\t\ttrigger_error( ERROR_GENERIC, ERROR );\n\t}\n\n\t// Bug Action Event\n\tevent_signal( 'EVENT_BUG_ACTION', array( $f_action, $t_bug_id ) );\n}\n\nform_security_purge( $t_form_name );\n\n$t_redirect_url = 'view_all_bug_page.php';\n\nif ( count( $t_failed_ids ) > 0 ) {\n\thtml_page_top();\n\n\techo '<div><br />';\n\techo '<table class=\"width75\">';\n\t$separator = lang_get( 'word_separator' );\n\tforeach( $t_failed_ids as $t_id => $t_reason ) {\n\t\t$label = sprintf( lang_get( 'label' ), string_get_bug_view_link( $t_id ) ) . $separator;\n\t\tprintf( \"<tr><td width=\\\"50%%\\\">%s%s</td><td>%s</td></tr>\\n\", $label, bug_get_field( $t_id, 'summary' ), $t_reason );\n\t}\n\techo '</table><br />';\n\tprint_bracket_link( $t_redirect_url, lang_get( 'proceed' ) );\n\techo '</div>';\n\n\thtml_page_bottom();\n} else {\n\tprint_header_redirect( $t_redirect_url );\n}\n"], "fixing_code": ["<?php\n# MantisBT - A PHP based bugtracking system\n\n# MantisBT is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 2 of the License, or\n# (at your option) any later version.\n#\n# MantisBT is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with MantisBT.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * This page allows actions to be performed an an array of bugs\n *\n * @package MantisBT\n * @copyright Copyright (C) 2000 - 2002  Kenzaburo Ito - kenito@300baud.org\n * @copyright Copyright (C) 2002 - 2012  MantisBT Team - mantisbt-dev@lists.sourceforge.net\n * @link http://www.mantisbt.org\n *\n * @uses core.php\n * @uses access_api.php\n * @uses authentication_api.php\n * @uses bug_api.php\n * @uses bugnote_api.php\n * @uses category_api.php\n * @uses config_api.php\n * @uses constant_inc.php\n * @uses custom_field_api.php\n * @uses event_api.php\n * @uses form_api.php\n * @uses gpc_api.php\n * @uses helper_api.php\n * @uses html_api.php\n * @uses lang_api.php\n * @uses print_api.php\n * @uses string_api.php\n * @uses utility_api.php\n * @uses version_api.php\n */\n\n/**\n * MantisBT Core API's\n */\nrequire_once( 'core.php' );\nrequire_api( 'access_api.php' );\nrequire_api( 'authentication_api.php' );\nrequire_api( 'bug_api.php' );\nrequire_api( 'bugnote_api.php' );\nrequire_api( 'category_api.php' );\nrequire_api( 'config_api.php' );\nrequire_api( 'constant_inc.php' );\nrequire_api( 'custom_field_api.php' );\nrequire_api( 'event_api.php' );\nrequire_api( 'form_api.php' );\nrequire_api( 'gpc_api.php' );\nrequire_api( 'helper_api.php' );\nrequire_api( 'html_api.php' );\nrequire_api( 'lang_api.php' );\nrequire_api( 'print_api.php' );\nrequire_api( 'string_api.php' );\nrequire_api( 'utility_api.php' );\nrequire_api( 'version_api.php' );\n\nauth_ensure_user_authenticated();\nhelper_begin_long_process();\n\n$f_action\t= gpc_get_string( 'action' );\n$f_custom_field_id = gpc_get_int( 'custom_field_id', 0 );\n$f_bug_arr\t= gpc_get_int_array( 'bug_arr', array() );\n$f_bug_notetext = gpc_get_string( 'bugnote_text', '' );\n$f_bug_noteprivate = gpc_get_bool( 'private' );\n$t_form_name = 'bug_actiongroup_' . $f_action;\nform_security_validate( $t_form_name );\n\n$t_custom_group_actions = config_get( 'custom_group_actions' );\n\nforeach( $t_custom_group_actions as $t_custom_group_action ) {\n\tif ( $f_action == $t_custom_group_action['action'] ) {\n\t\trequire_once( $t_custom_group_action['action_page'] );\n\t\texit;\n\t}\n}\n\n$t_failed_ids = array();\n\nif ( 0 != $f_custom_field_id ) {\n\t$t_custom_field_def = custom_field_get_definition( $f_custom_field_id );\n}\n\nforeach( $f_bug_arr as $t_bug_id ) {\n\tbug_ensure_exists( $t_bug_id );\n\t$t_bug = bug_get( $t_bug_id, true );\n\n\tif( $t_bug->project_id != helper_get_current_project() ) {\n\t\t# in case the current project is not the same project of the bug we are viewing...\n\t\t# ... override the current project. This to avoid problems with categories and handlers lists etc.\n\t\t$g_project_override = $t_bug->project_id;\n\t\t/** @todo (thraxisp) the next line goes away if the cache was smarter and used project */\n\t\tconfig_flush_cache(); # flush the config cache so that configs are refetched\n\t}\n\n\t$t_status = $t_bug->status;\n\n\tswitch ( $f_action ) {\n\n\tcase 'CLOSE':\n\t\t$t_closed = config_get( 'bug_closed_status_threshold' );\n\t\tif ( access_can_close_bug( $t_bug_id ) ) {\n\t\t\tif( ( $t_status < $t_closed ) &&\n\t\t\t\tbug_check_workflow( $t_status, $t_closed ) ) {\n\n\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $f_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\tbug_close( $t_bug_id, $f_bug_notetext, $f_bug_noteprivate );\n\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t} else {\n\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_status' );\n\t\t\t}\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'DELETE':\n\t\tif ( access_has_bug_level( config_get( 'delete_bug_threshold' ), $t_bug_id ) ) {\n\t\t\tevent_signal( 'EVENT_BUG_DELETED', array( $t_bug_id ) );\n\t\t\tbug_delete( $t_bug_id );\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'MOVE':\n\t\t$f_project_id = gpc_get_int( 'project_id' );\n\t\tif( access_has_bug_level( config_get( 'move_bug_threshold' ), $t_bug_id ) &&\n\t\t    access_has_project_level( config_get( 'report_bug_threshold', null, null, $f_project_id ), $f_project_id ) ) {\n\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\tbug_move( $t_bug_id, $f_project_id );\n\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'COPY':\n\t\t$f_project_id = gpc_get_int( 'project_id' );\n\n\t\tif ( access_has_project_level( config_get( 'report_bug_threshold' ), $f_project_id ) ) {\n\t\t\tbug_copy( $t_bug_id, $f_project_id, true, true, true, true, true, true );\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'ASSIGN':\n\t\t$f_assign = gpc_get_int( 'assign' );\n\t\tif ( ON == config_get( 'auto_set_status_to_assigned' ) ) {\n\t\t\t$t_assign_status = config_get( 'bug_assigned_status' );\n\t\t} else {\n\t\t\t$t_assign_status = $t_status;\n\t\t}\n\t\t# check that new handler has rights to handle the issue, and\n\t\t#  that current user has rights to assign the issue\n\t\t$t_threshold = access_get_status_threshold( $t_assign_status, bug_get_field( $t_bug_id, 'project_id' ) );\n\t\tif ( access_has_bug_level( config_get( 'update_bug_assign_threshold', config_get( 'update_bug_threshold' ) ), $t_bug_id ) ) {\n\t\t\tif ( access_has_bug_level( config_get( 'handle_bug_threshold' ), $t_bug_id, $f_assign ) ) {\n\t\t\t\tif ( bug_check_workflow( $t_status, $t_assign_status ) ) {\n\t\t\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\t\t\tbug_assign( $t_bug_id, $f_assign, $f_bug_notetext, $f_bug_noteprivate );\n\t\t\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t\t\t} else {\n\t\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_status' );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_handler' );\n\t\t\t}\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'RESOLVE':\n\t\t$t_resolved_status = config_get( 'bug_resolved_status_threshold' );\n\t\t\tif ( access_has_bug_level( access_get_status_threshold( $t_resolved_status, bug_get_field( $t_bug_id, 'project_id' ) ), $t_bug_id ) ) {\n\t\t\t\tif ( ( $t_status < $t_resolved_status ) &&\n\t\t\t\t\tbug_check_workflow($t_status, $t_resolved_status ) ) {\n\t\t\t$f_resolution = gpc_get_int( 'resolution' );\n\t\t\t$f_fixed_in_version = gpc_get_string( 'fixed_in_version', '' );\n\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\tbug_resolve( $t_bug_id, $f_resolution, $f_fixed_in_version, $f_bug_notetext, null, null, $f_bug_noteprivate );\n\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t} else {\n\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_status' );\n\t\t\t}\n\t\t\t} else {\n\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'UP_PRIOR':\n\t\tif ( access_has_bug_level( config_get( 'update_bug_threshold' ), $t_bug_id ) ) {\n\t\t\t$f_priority = gpc_get_int( 'priority' );\n\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\tbug_set_field( $t_bug_id, 'priority', $f_priority );\n\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'UP_STATUS':\n\t\t$f_status = gpc_get_int( 'status' );\n\t\t$t_project = bug_get_field( $t_bug_id, 'project_id' );\n\t\tif ( access_has_bug_level( access_get_status_threshold( $f_status, $t_project ), $t_bug_id ) ) {\n\t\t\tif ( TRUE == bug_check_workflow($t_status, $f_status ) ) {\n\t\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\t\tbug_set_field( $t_bug_id, 'status', $f_status );\n\n\t\t\t\t# Add bugnote if supplied\n\t\t\t\tif ( !is_blank( $f_bug_notetext ) ) {\n\t\t\t\t\tbugnote_add( $t_bug_id, $f_bug_notetext, null, $f_bug_noteprivate );\n\t\t\t\t}\n\n\t\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t\t} else {\n\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_status' );\n\t\t\t}\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'UP_CATEGORY':\n\t\t$f_category_id = gpc_get_int( 'category' );\n\t\tif ( access_has_bug_level( config_get( 'update_bug_threshold' ), $t_bug_id ) ) {\n\t\t\tif ( category_exists( $f_category_id ) ) {\n\t\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\t\tbug_set_field( $t_bug_id, 'category_id', $f_category_id );\n\t\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t\t} else {\n\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_category' );\n\t\t\t}\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'UP_FIXED_IN_VERSION':\n\t\t$f_fixed_in_version = gpc_get_string( 'fixed_in_version' );\n\t\t$t_project_id = bug_get_field( $t_bug_id, 'project_id' );\n\n\t\tif ( access_has_bug_level( config_get( 'update_bug_threshold' ), $t_bug_id ) ) {\n\t\t\tif ( $f_fixed_in_version === '' || version_get_id( $f_fixed_in_version, $t_project_id ) !== false ) {\n\t\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\t\tbug_set_field( $t_bug_id, 'fixed_in_version', $f_fixed_in_version );\n\t\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t\t\t} else {\n\t\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_version' );\n\t\t\t}\n\t\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'UP_TARGET_VERSION':\n\t\t$f_target_version = gpc_get_string( 'target_version' );\n\t\t$t_project_id = bug_get_field( $t_bug_id, 'project_id' );\n\n\t\tif ( access_has_bug_level( config_get( 'roadmap_update_threshold' ), $t_bug_id ) ) {\n\t\t\tif ( $f_target_version === '' || version_get_id( $f_target_version, $t_project_id ) !== false ) {\n\t\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\t\tbug_set_field( $t_bug_id, 'target_version', $f_target_version );\n\t\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t\t\t} else {\n\t\t\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_version' );\n\t\t\t}\n\t\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'VIEW_STATUS':\n\t\tif ( access_has_bug_level( config_get( 'change_view_status_threshold' ), $t_bug_id ) ) {\n\t\t\t$f_view_status = gpc_get_int( 'view_status' );\n\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\tbug_set_field( $t_bug_id, 'view_state', $f_view_status );\n\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'SET_STICKY':\n\t\tif ( access_has_bug_level( config_get( 'set_bug_sticky_threshold' ), $t_bug_id ) ) {\n\t\t\t$f_sticky = bug_get_field( $t_bug_id, 'sticky' );\n\t\t\t// The new value is the inverted old value\n\t\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t\tbug_set_field( $t_bug_id, 'sticky', intval( !$f_sticky ) );\n\t\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\t} else {\n\t\t\t$t_failed_ids[$t_bug_id] = lang_get( 'bug_actiongroup_access' );\n\t\t}\n\t\tbreak;\n\n\tcase 'CUSTOM':\n\t\tif ( 0 === $f_custom_field_id ) {\n\t\t\ttrigger_error( ERROR_GENERIC, ERROR );\n\t\t}\n\n\t\t/** @todo we need to issue a helper_call_custom_function( 'issue_update_validate', array( $t_bug_id, $t_bug_data, $f_bugnote_text ) ); */\n\t\t$t_form_var = \"custom_field_$f_custom_field_id\";\n\t\t$t_custom_field_value = gpc_get_custom_field( $t_form_var, $t_custom_field_def['type'], null );\n\t\tcustom_field_set_value( $f_custom_field_id, $t_bug_id, $t_custom_field_value );\n\t\thelper_call_custom_function( 'issue_update_notify', array( $t_bug_id ) );\n\t\tbreak;\n\n\tdefault:\n\t\ttrigger_error( ERROR_GENERIC, ERROR );\n\t}\n\n\t// Bug Action Event\n\tevent_signal( 'EVENT_BUG_ACTION', array( $f_action, $t_bug_id ) );\n}\n\nform_security_purge( $t_form_name );\n\n$t_redirect_url = 'view_all_bug_page.php';\n\nif ( count( $t_failed_ids ) > 0 ) {\n\thtml_page_top();\n\n\techo '<div><br />';\n\techo '<table class=\"width75\">';\n\t$separator = lang_get( 'word_separator' );\n\tforeach( $t_failed_ids as $t_id => $t_reason ) {\n\t\t$label = sprintf( lang_get( 'label' ), string_get_bug_view_link( $t_id ) ) . $separator;\n\t\tprintf( \"<tr><td width=\\\"50%%\\\">%s%s</td><td>%s</td></tr>\\n\", $label, bug_get_field( $t_id, 'summary' ), $t_reason );\n\t}\n\techo '</table><br />';\n\tprint_bracket_link( $t_redirect_url, lang_get( 'proceed' ) );\n\techo '</div>';\n\n\thtml_page_bottom();\n} else {\n\tprint_header_redirect( $t_redirect_url );\n}\n"], "filenames": ["bug_actiongroup.php"], "buggy_code_start_loc": [139], "buggy_code_end_loc": [141], "fixing_code_start_loc": [139], "fixing_code_end_loc": [141], "type": "CWE-264", "message": "bug_actiongroup.php in MantisBT before 1.2.9 does not properly check the report_bug_threshold permission of the receiving project when moving a bug report, which allows remote authenticated users with the report_bug_threshold and move_bug_threshold privileges for a project to bypass intended access restrictions and move bug reports to a different project.", "other": {"cve": {"id": "CVE-2012-1122", "sourceIdentifier": "secalert@redhat.com", "published": "2012-06-29T19:55:03.093", "lastModified": "2013-08-27T03:21:46.477", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "bug_actiongroup.php in MantisBT before 1.2.9 does not properly check the report_bug_threshold permission of the receiving project when moving a bug report, which allows remote authenticated users with the report_bug_threshold and move_bug_threshold privileges for a project to bypass intended access restrictions and move bug reports to a different project."}, {"lang": "es", "value": "bug_actiongroup.php de MantisBT anteriores a 1.2.9 no comprueba apropiadamente el permiso report_bug_threshold del proyecto destino cuando se mueve un reporte de bug, lo que permite a usuarios autenticados remotos con los privilegios report_bug_threshold y move_bug_threshold para un proyecto evitar las restricciones de acceso previstas y mover reportes de bug a un proyecto distinto."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:S/C:N/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 3.6}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.2.8", "matchCriteriaId": "79367D94-9665-49D7-94E4-CC9EFC7439BB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.18.0:*:*:*:*:*:*:*", "matchCriteriaId": "AF83F757-4B62-441C-8421-15809E573A83"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.0:*:*:*:*:*:*:*", "matchCriteriaId": "A608AFEC-B265-4143-99DA-BB2AE9D522BC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "7FCB56AC-4C14-49B1-BEFE-8651BC70476E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.0a1:*:*:*:*:*:*:*", "matchCriteriaId": "64BCCC4D-D109-4116-A9C3-E5553686A986"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.0a2:*:*:*:*:*:*:*", "matchCriteriaId": "BAAF1C66-9DC7-4FD3-8651-C5561B2681A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.1:*:*:*:*:*:*:*", "matchCriteriaId": "F59BAE6B-C73D-4BE2-AEF9-93F2F4A4373F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.2:*:*:*:*:*:*:*", "matchCriteriaId": "C9DA5C2F-FB7C-4D95-81DE-24D8EADC5C30"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.3:*:*:*:*:*:*:*", "matchCriteriaId": "85A3FBD5-163C-4990-B809-A5C9C81A3C6C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.4:*:*:*:*:*:*:*", "matchCriteriaId": "D3FDF456-9648-4A7C-B15A-2828A32D4962"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.5:*:*:*:*:*:*:*", "matchCriteriaId": "9EE8BCBE-D864-4311-B73A-DF92162D8DF3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "6B2602F7-2D93-4E1E-9425-4EDD23752029"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "62F6B391-DDE3-4E8E-8582-85EA7287E591"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "80DBD667-1FB9-4354-9150-A190D4D817A2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "F27E40C0-263F-452B-8C91-E621A02EFC28"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "CB888B14-EA67-4EDB-A3AF-ACD3F0A6227E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0:rc5:*:*:*:*:*:*", "matchCriteriaId": "1DB45A02-2522-4E10-BC81-48750ACB42DD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0a1:*:*:*:*:*:*:*", "matchCriteriaId": "AC837ACF-EB55-4E9C-BFC5-83BB04B84BE3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0a2:*:*:*:*:*:*:*", "matchCriteriaId": "F8826523-FDEE-4C14-8EAC-97C564272CC8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0a3:*:*:*:*:*:*:*", "matchCriteriaId": "1780295B-215F-4EEE-8CF8-2E3531D7A196"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "86DE3BE3-D6C9-4905-9E61-B70776460604"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "F128A2E2-D509-4B50-95C2-1A31C5B3B31F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "140D5F68-1CAB-458C-BC8B-4F726D657FE8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "0D25F4F5-7678-41C1-93CB-305883A08527"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "D1A1316D-314B-4740-A836-D5E6319F4B28"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "DBD27CCE-28C4-43CC-8CBD-D7FFB46171AC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "97298C43-B881-4C11-ADB6-17A8E43EB84E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "7257ADD7-C9B7-4F85-AA13-615DD033FD5C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "02FE950B-5E29-4FAA-9BE5-79F38B4C38F7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "D6F2BA78-D054-4E49-ABCA-637922898BF7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "4595B1E3-25AB-489E-A847-FDBF2554DD6D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "C11A8F17-5253-475B-89FF-A26EA7531E13"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "4A88B09D-CDCF-45FD-B004-13B597DA4F48"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "49583BE8-B832-4E9F-B154-47A26C72489D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.7:*:*:*:*:*:*:*", "matchCriteriaId": "E2501F40-3630-4528-BE0A-61D4BB6EC7FE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "9223DAF7-D03E-4A4E-8AB5-5CEB87DFF2C3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "CFF77ABF-0A03-437A-B241-1EF2BBB83D24"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.0a1:*:*:*:*:*:*:*", "matchCriteriaId": "5875D457-28EF-4076-8E04-60CF9CF6D27A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.0a2:*:*:*:*:*:*:*", "matchCriteriaId": "301F44D1-21E7-4E00-BF45-2190D1FE21FF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "5F096CD6-534E-4ABF-B2DF-D4B55B8C5F6A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "A66AB537-6FBA-4A51-B10C-BF61F54BC01B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "A50835BF-D28B-47FF-81F0-C34D95D6F2E9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "BA0EB9A6-1DFD-4C17-A002-0899DA252A56"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "BBA33285-3EE7-43FD-8347-E7D9A18DC134"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "8827C2B4-EBEC-4D64-9AC8-07A048467F40"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "1F32DFF4-6448-46FD-9358-4FB1C310EC2E"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2012-November/092926.html", "source": "secalert@redhat.com"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2012-November/093063.html", "source": "secalert@redhat.com"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2012-November/093064.html", "source": "secalert@redhat.com"}, {"url": "http://security.gentoo.org/glsa/glsa-201211-01.xml", "source": "secalert@redhat.com"}, {"url": "http://www.debian.org/security/2012/dsa-2500", "source": "secalert@redhat.com"}, {"url": "http://www.mantisbt.org/bugs/changelog_page.php?version_id=140", "source": "secalert@redhat.com"}, {"url": "http://www.mantisbt.org/bugs/view.php?id=13748", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2012/03/06/9", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/52313", "source": "secalert@redhat.com"}, {"url": "https://github.com/mantisbt/mantisbt/commit/0da3f7ace233208eb3c8d628cc2fd6e56d83839f", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/mantisbt/mantisbt/commit/0da3f7ace233208eb3c8d628cc2fd6e56d83839f"}}