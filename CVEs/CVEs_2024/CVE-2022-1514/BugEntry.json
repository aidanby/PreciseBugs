{"buggy_code": ["<?php\n/**\n * This file is part of FacturaScripts\n * Copyright (C) 2017-2022 Carlos Garcia Gomez <carlos@facturascripts.com>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\nnamespace FacturaScripts\\Core\\Base;\n\nuse ZipArchive;\n\n/**\n * FacturaScripts plugins manager.\n *\n * @author Carlos Garc\u00eda G\u00f3mez <carlos@facturascripts.com>\n */\nfinal class PluginManager\n{\n\n    /**\n     * FacturaScripts core version.\n     */\n    const CORE_VERSION = 2022.06;\n\n    /**\n     * Path to list plugins on file.\n     */\n    const PLUGIN_LIST_FILE = FS_FOLDER . DIRECTORY_SEPARATOR . 'MyFiles' . DIRECTORY_SEPARATOR . 'plugins.json';\n\n    /**\n     * Plugin path folder.\n     */\n    const PLUGIN_PATH = FS_FOLDER . DIRECTORY_SEPARATOR . 'Plugins' . DIRECTORY_SEPARATOR;\n\n    /**\n     * Indicates if a deployment is necessary.\n     *\n     * @var bool\n     */\n    private static $deploymentRequired = false;\n\n    /**\n     * List of active plugins.\n     *\n     * @var array\n     */\n    private static $enabledPlugins;\n\n    /**\n     * Name of the last plugin installed or updated.\n     *\n     * @var string\n     */\n    private static $lastPlugin = '';\n\n    /**\n     * PluginManager constructor.\n     */\n    public function __construct()\n    {\n        if (self::$enabledPlugins === null) {\n            self::$enabledPlugins = $this->loadFromFile();\n        }\n\n        if (false === defined('FS_DISABLE_ADD_PLUGINS')) {\n            define('FS_DISABLE_ADD_PLUGINS', false);\n        }\n\n        if (false === defined('FS_DISABLE_RM_PLUGINS')) {\n            define('FS_DISABLE_RM_PLUGINS', false);\n        }\n    }\n\n    /**\n     * Deploy all the necessary files in the Dinamic folder to be able to use plugins\n     * with the autoloader, but following the priority system of FacturaScripts.\n     *\n     * @param bool $clean\n     * @param bool $initControllers\n     */\n    public function deploy(bool $clean = true, bool $initControllers = false)\n    {\n        $pluginDeploy = new PluginDeploy();\n        $pluginDeploy->deploy(self::PLUGIN_PATH, $this->enabledPlugins(), $clean);\n\n        if ($initControllers) {\n            $pluginDeploy->initControllers();\n        }\n    }\n\n    public function deploymentRequired(): bool\n    {\n        return self::$deploymentRequired;\n    }\n\n    /**\n     * Disable the indicated plugin.\n     *\n     * @param string $pluginName\n     *\n     * @return bool\n     */\n    public function disable(string $pluginName): bool\n    {\n        foreach (self::$enabledPlugins as $key => $value) {\n            if ($value['name'] !== $pluginName) {\n                continue;\n            }\n\n            unset(self::$enabledPlugins[$key]);\n            $this->disableByDependency($pluginName);\n            $this->save();\n            $this->deploy(true, true);\n\n            $pluginClass = \"FacturaScripts\\\\Plugins\\\\$pluginName\\\\Init\";\n            if (class_exists($pluginClass)) {\n                $initObject = new $pluginClass();\n                $initObject->uninstall();\n            }\n\n            ToolBox::i18nLog()->notice('plugin-disabled', ['%pluginName%' => $pluginName]);\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Activate the indicated plugin.\n     *\n     * @param string $pluginName\n     *\n     * @return bool\n     */\n    public function enable(string $pluginName): bool\n    {\n        // is pluginName enabled?\n        if (in_array($pluginName, $this->enabledPlugins())) {\n            return true;\n        }\n\n        foreach ($this->installedPlugins() as $plugin) {\n            if ($plugin['name'] !== $pluginName) {\n                continue;\n            }\n\n            if ($this->checkRequire($plugin['require'])) {\n                $plugin['enabled'] = true;\n                self::$enabledPlugins[] = $plugin;\n                $this->save();\n                $this->deploy(false, true);\n                $this->initPlugin($pluginName);\n                ToolBox::i18nLog()->notice('plugin-enabled', ['%pluginName%' => $pluginName]);\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns the list of active plugins.\n     *\n     * @return array\n     */\n    public function enabledPlugins(): array\n    {\n        $enabled = [];\n        foreach (self::$enabledPlugins as $value) {\n            $enabled[] = $value['name'];\n        }\n\n        return $enabled;\n    }\n\n    public function getLastPluginName(): string\n    {\n        return self::$lastPlugin;\n    }\n\n    /**\n     * @param string $pluginName\n     */\n    public function initPlugin(string $pluginName)\n    {\n        $pluginClass = \"FacturaScripts\\\\Plugins\\\\$pluginName\\\\Init\";\n        if (class_exists($pluginClass) && in_array($pluginName, $this->enabledPlugins())) {\n            $initObject = new $pluginClass();\n            $initObject->update();\n        }\n    }\n\n    /**\n     * Installs a new plugin.\n     *\n     * @param string $zipPath\n     * @param string $zipName\n     * @param bool $force\n     *\n     * @return bool\n     */\n    public function install(string $zipPath, string $zipName = 'plugin.zip', bool $force = false): bool\n    {\n        if (FS_DISABLE_ADD_PLUGINS && !$force) {\n            ToolBox::i18nLog()->warning('plugin-installation-disabled');\n            return false;\n        }\n\n        $zipFile = new ZipArchive();\n        if (false === $this->testZipFile($zipFile, $zipPath, $zipName)) {\n            return false;\n        }\n\n        // get the facturascripts.ini file inside the zip\n        $zipIndex = $zipFile->locateName('facturascripts.ini', ZipArchive::FL_NODIR);\n        $pathINI = $zipFile->getNameIndex($zipIndex);\n        $info = $this->getPluginInfo($zipName, $zipFile->getFromIndex($zipIndex));\n        if (false === $info['compatible']) {\n            $errorTag = empty($info['min_version']) ? 'plugin-unsupported-version' : 'plugin-needs-fs-version';\n            ToolBox::i18nLog()->error(\n                $errorTag, ['%pluginName%' => $zipName, '%minVersion%' => $info['min_version'], '%version%' => self::CORE_VERSION]\n            );\n            return false;\n        }\n\n        // Removing previous version\n        if (is_dir(self::PLUGIN_PATH . $info['name'])) {\n            ToolBox::files()->delTree(self::PLUGIN_PATH . $info['name']);\n        }\n\n        // Extract new version\n        if (false === $zipFile->extractTo(self::PLUGIN_PATH)) {\n            ToolBox::log()->error('ZIP EXTRACT ERROR: ' . $zipName);\n            $zipFile->close();\n            return false;\n        }\n\n        $zipFile->close();\n\n        // Rename folder Plugin\n        $folderPluginZip = explode('/', $pathINI);\n        if ($folderPluginZip[0] !== $info['name']) {\n            rename(self::PLUGIN_PATH . $folderPluginZip[0], self::PLUGIN_PATH . $info['name']);\n        }\n\n        // Deployment required?\n        if (in_array($info['name'], $this->enabledPlugins())) {\n            self::$deploymentRequired = true;\n        }\n\n        self::$lastPlugin = $info['name'];\n        ToolBox::i18nLog()->notice('plugin-installed', ['%pluginName%' => $info['name']]);\n        return true;\n    }\n\n    /**\n     * Returns the list of installed plugins.\n     *\n     * @return array\n     */\n    public function installedPlugins(): array\n    {\n        $plugins = [];\n\n        foreach (ToolBox::files()->scanFolder(self::PLUGIN_PATH, false) as $folder) {\n            $iniPath = self::PLUGIN_PATH . $folder . DIRECTORY_SEPARATOR . 'facturascripts.ini';\n            $iniContent = file_exists($iniPath) ? file_get_contents($iniPath) : '';\n            $plugins[] = $this->getPluginInfo($folder, $iniContent);\n        }\n\n        return $plugins;\n    }\n\n    /**\n     * Remove a plugin only if it's disabled.\n     *\n     * @param string $pluginName\n     *\n     * @return bool\n     */\n    public function remove(string $pluginName): bool\n    {\n        if (FS_DISABLE_RM_PLUGINS) {\n            ToolBox::i18nLog()->warning('plugin-removal-disabled');\n            return false;\n        }\n\n        // can't remove enabled plugins\n        if (in_array($pluginName, $this->enabledPlugins())) {\n            ToolBox::i18nLog()->warning('plugin-enabled', ['%pluginName%' => $pluginName]);\n            return false;\n        }\n\n        $pluginPath = self::PLUGIN_PATH . $pluginName;\n        if (is_dir($pluginPath) || is_file($pluginPath)) {\n            ToolBox::files()->delTree($pluginPath);\n            ToolBox::i18nLog()->notice('plugin-deleted', ['%pluginName%' => $pluginName]);\n            return true;\n        }\n\n        ToolBox::i18nLog()->error('plugin-delete-error', ['%pluginName%' => $pluginName]);\n        return false;\n    }\n\n    /**\n     * Check for plugins needed.\n     *\n     * @param array $require\n     *\n     * @return bool\n     */\n    private function checkRequire(array $require): bool\n    {\n        if (empty($require)) {\n            return true;\n        }\n\n        foreach ($require as $req) {\n            $found = false;\n            foreach ($this->enabledPlugins() as $pluginName) {\n                if ($pluginName === $req) {\n                    $found = true;\n                    break;\n                }\n            }\n\n            if (false === $found) {\n                ToolBox::i18nLog()->warning('plugin-needed', ['%pluginName%' => $req]);\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Disables plugins that depends on $pluginDisabled\n     *\n     * @param string $pluginDisabled\n     */\n    private function disableByDependency(string $pluginDisabled)\n    {\n        foreach (self::$enabledPlugins as $key => $value) {\n            if (in_array($pluginDisabled, $value['require'])) {\n                ToolBox::i18nLog()->warning('plugin-disabled', ['%pluginName%' => $value['name']]);\n                unset(self::$enabledPlugins[$key]);\n                $this->disableByDependency($value['name']);\n            }\n        }\n    }\n\n    /**\n     * Return plugin information.\n     *\n     * @param string $pluginName\n     * @param string $iniContent\n     *\n     * @return array\n     */\n    private function getPluginInfo(string $pluginName, string $iniContent): array\n    {\n        $info = [\n            'compatible' => false,\n            'description' => 'Incompatible',\n            'enabled' => false,\n            'min_version' => 0.0,\n            'name' => $pluginName,\n            'require' => [],\n            'version' => 1\n        ];\n\n        $ini = parse_ini_string($iniContent);\n        if ($ini !== false) {\n            foreach (['name', 'version', 'description', 'min_version'] as $key) {\n                $info[$key] = $ini[$key] ?? $info[$key];\n            }\n\n            if (isset($ini['require'])) {\n                $info['require'] = explode(',', $ini['require']);\n            }\n\n            if ($info['min_version'] >= 2018 && $info['min_version'] <= self::CORE_VERSION) {\n                $info['compatible'] = true;\n                $info['description'] = ('Incompatible' === $info['description']) ? ToolBox::i18n()->trans('compatible') : $info['description'];\n            } else {\n                $info['description'] = ToolBox::i18n()->trans('incompatible-with-facturascripts', ['%version%' => self::CORE_VERSION]);\n            }\n\n            $info['enabled'] = in_array($info['name'], $this->enabledPlugins());\n        }\n\n        return $info;\n    }\n\n    /**\n     * Returns an array with the list of plugins in the plugin.list file.\n     *\n     * @return array\n     */\n    private function loadFromFile(): array\n    {\n        if (file_exists(self::PLUGIN_LIST_FILE)) {\n            $content = file_get_contents(self::PLUGIN_LIST_FILE);\n            if ($content) {\n                return json_decode($content, true);\n            }\n        }\n\n        return [];\n    }\n\n    /**\n     * Save the list of plugins in a file.\n     *\n     * @return bool\n     */\n    private function save(): bool\n    {\n        $content = json_encode(self::$enabledPlugins);\n        return file_put_contents(self::PLUGIN_LIST_FILE, $content) !== false;\n    }\n\n    /**\n     * @param ZipArchive $zipFile\n     * @param string $zipPath\n     * @param string $zipName\n     *\n     * @return bool\n     */\n    private function testZipFile(ZipArchive &$zipFile, string $zipPath, string $zipName): bool\n    {\n        $result = $zipFile->open($zipPath, ZipArchive::CHECKCONS);\n        if (true !== $result) {\n            ToolBox::log()->error('ZIP error: ' . $result);\n            return false;\n        }\n\n        // get the facturascripts.ini file inside the zip\n        $zipIndex = $zipFile->locateName('facturascripts.ini', ZipArchive::FL_NODIR);\n        if (false === $zipIndex) {\n            ToolBox::i18nLog()->error('plugin-not-compatible', ['%pluginName%' => $zipName, '%version%' => self::CORE_VERSION]);\n            return false;\n        }\n\n        // the zip must contain the plugin folder\n        $pathINI = $zipFile->getNameIndex($zipIndex);\n        if (count(explode('/', $pathINI)) !== 2) {\n            ToolBox::i18nLog()->error('zip-error-wrong-structure');\n            return false;\n        }\n\n        // get folders inside the zip file\n        $folders = [];\n        for ($index = 0; $index < $zipFile->numFiles; $index++) {\n            $data = $zipFile->statIndex($index);\n            $path = explode('/', $data['name']);\n            if (count($path) > 1) {\n                $folders[$path[0]] = $path[0];\n            }\n        }\n\n        // the zip must contain a single plugin\n        if (count($folders) != 1) {\n            ToolBox::i18nLog()->error('zip-error-wrong-structure');\n            return false;\n        }\n\n        return true;\n    }\n}\n"], "fixing_code": ["<?php\n/**\n * This file is part of FacturaScripts\n * Copyright (C) 2017-2022 Carlos Garcia Gomez <carlos@facturascripts.com>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\nnamespace FacturaScripts\\Core\\Base;\n\nuse ZipArchive;\n\n/**\n * FacturaScripts plugins manager.\n *\n * @author Carlos Garc\u00eda G\u00f3mez <carlos@facturascripts.com>\n */\nfinal class PluginManager\n{\n\n    /**\n     * FacturaScripts core version.\n     */\n    const CORE_VERSION = 2022.06;\n\n    /**\n     * Path to list plugins on file.\n     */\n    const PLUGIN_LIST_FILE = FS_FOLDER . DIRECTORY_SEPARATOR . 'MyFiles' . DIRECTORY_SEPARATOR . 'plugins.json';\n\n    /**\n     * Plugin path folder.\n     */\n    const PLUGIN_PATH = FS_FOLDER . DIRECTORY_SEPARATOR . 'Plugins' . DIRECTORY_SEPARATOR;\n\n    /**\n     * Indicates if a deployment is necessary.\n     *\n     * @var bool\n     */\n    private static $deploymentRequired = false;\n\n    /**\n     * List of active plugins.\n     *\n     * @var array\n     */\n    private static $enabledPlugins;\n\n    /**\n     * Name of the last plugin installed or updated.\n     *\n     * @var string\n     */\n    private static $lastPlugin = '';\n\n    /**\n     * PluginManager constructor.\n     */\n    public function __construct()\n    {\n        if (self::$enabledPlugins === null) {\n            self::$enabledPlugins = $this->loadFromFile();\n        }\n\n        if (false === defined('FS_DISABLE_ADD_PLUGINS')) {\n            define('FS_DISABLE_ADD_PLUGINS', false);\n        }\n\n        if (false === defined('FS_DISABLE_RM_PLUGINS')) {\n            define('FS_DISABLE_RM_PLUGINS', false);\n        }\n    }\n\n    /**\n     * Deploy all the necessary files in the Dinamic folder to be able to use plugins\n     * with the autoloader, but following the priority system of FacturaScripts.\n     *\n     * @param bool $clean\n     * @param bool $initControllers\n     */\n    public function deploy(bool $clean = true, bool $initControllers = false)\n    {\n        $pluginDeploy = new PluginDeploy();\n        $pluginDeploy->deploy(self::PLUGIN_PATH, $this->enabledPlugins(), $clean);\n\n        if ($initControllers) {\n            $pluginDeploy->initControllers();\n        }\n    }\n\n    public function deploymentRequired(): bool\n    {\n        return self::$deploymentRequired;\n    }\n\n    /**\n     * Disable the indicated plugin.\n     *\n     * @param string $pluginName\n     *\n     * @return bool\n     */\n    public function disable(string $pluginName): bool\n    {\n        foreach (self::$enabledPlugins as $key => $value) {\n            if ($value['name'] !== $pluginName) {\n                continue;\n            }\n\n            unset(self::$enabledPlugins[$key]);\n            $this->disableByDependency($pluginName);\n            $this->save();\n            $this->deploy(true, true);\n\n            $pluginClass = \"FacturaScripts\\\\Plugins\\\\$pluginName\\\\Init\";\n            if (class_exists($pluginClass)) {\n                $initObject = new $pluginClass();\n                $initObject->uninstall();\n            }\n\n            ToolBox::i18nLog()->notice('plugin-disabled', ['%pluginName%' => $pluginName]);\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Activate the indicated plugin.\n     *\n     * @param string $pluginName\n     *\n     * @return bool\n     */\n    public function enable(string $pluginName): bool\n    {\n        // is pluginName enabled?\n        if (in_array($pluginName, $this->enabledPlugins())) {\n            return true;\n        }\n\n        foreach ($this->installedPlugins() as $plugin) {\n            if ($plugin['name'] !== $pluginName) {\n                continue;\n            }\n\n            if ($this->checkRequire($plugin['require'])) {\n                $plugin['enabled'] = true;\n                self::$enabledPlugins[] = $plugin;\n                $this->save();\n                $this->deploy(false, true);\n                $this->initPlugin($pluginName);\n                ToolBox::i18nLog()->notice('plugin-enabled', ['%pluginName%' => $pluginName]);\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns the list of active plugins.\n     *\n     * @return array\n     */\n    public function enabledPlugins(): array\n    {\n        $enabled = [];\n        foreach (self::$enabledPlugins as $value) {\n            $enabled[] = $value['name'];\n        }\n\n        return $enabled;\n    }\n\n    public function getLastPluginName(): string\n    {\n        return self::$lastPlugin;\n    }\n\n    /**\n     * @param string $pluginName\n     */\n    public function initPlugin(string $pluginName)\n    {\n        $pluginClass = \"FacturaScripts\\\\Plugins\\\\$pluginName\\\\Init\";\n        if (class_exists($pluginClass) && in_array($pluginName, $this->enabledPlugins())) {\n            $initObject = new $pluginClass();\n            $initObject->update();\n        }\n    }\n\n    /**\n     * Installs a new plugin.\n     *\n     * @param string $zipPath\n     * @param string $zipName\n     * @param bool $force\n     *\n     * @return bool\n     */\n    public function install(string $zipPath, string $zipName = 'plugin.zip', bool $force = false): bool\n    {\n        if (FS_DISABLE_ADD_PLUGINS && !$force) {\n            ToolBox::i18nLog()->warning('plugin-installation-disabled');\n            return false;\n        }\n\n        $zipFile = new ZipArchive();\n        if (false === $this->testZipFile($zipFile, $zipPath, $zipName)) {\n            return false;\n        }\n\n        // get the facturascripts.ini file inside the zip\n        $zipIndex = $zipFile->locateName('facturascripts.ini', ZipArchive::FL_NODIR);\n        $pathINI = $zipFile->getNameIndex($zipIndex);\n        $info = $this->getPluginInfo($zipName, $zipFile->getFromIndex($zipIndex));\n        if (false === $info['compatible']) {\n            $errorTag = empty($info['min_version']) ? 'plugin-unsupported-version' : 'plugin-needs-fs-version';\n            ToolBox::i18nLog()->error(\n                $errorTag, ['%pluginName%' => $zipName, '%minVersion%' => $info['min_version'], '%version%' => self::CORE_VERSION]\n            );\n            return false;\n        }\n\n        // Removing previous version\n        if (is_dir(self::PLUGIN_PATH . $info['name'])) {\n            ToolBox::files()->delTree(self::PLUGIN_PATH . $info['name']);\n        }\n\n        // Extract new version\n        if (false === $zipFile->extractTo(self::PLUGIN_PATH)) {\n            ToolBox::log()->error('ZIP EXTRACT ERROR: ' . $zipName);\n            $zipFile->close();\n            return false;\n        }\n\n        $zipFile->close();\n\n        // Rename folder Plugin\n        $folderPluginZip = explode('/', $pathINI);\n        if ($folderPluginZip[0] !== $info['name']) {\n            rename(self::PLUGIN_PATH . $folderPluginZip[0], self::PLUGIN_PATH . $info['name']);\n        }\n\n        // Deployment required?\n        if (in_array($info['name'], $this->enabledPlugins())) {\n            self::$deploymentRequired = true;\n        }\n\n        self::$lastPlugin = $info['name'];\n        ToolBox::i18nLog()->notice('plugin-installed', ['%pluginName%' => $info['name']]);\n        return true;\n    }\n\n    /**\n     * Returns the list of installed plugins.\n     *\n     * @return array\n     */\n    public function installedPlugins(): array\n    {\n        $plugins = [];\n\n        foreach (ToolBox::files()->scanFolder(self::PLUGIN_PATH, false) as $folder) {\n            $iniPath = self::PLUGIN_PATH . $folder . DIRECTORY_SEPARATOR . 'facturascripts.ini';\n            $iniContent = file_exists($iniPath) ? file_get_contents($iniPath) : '';\n            $plugins[] = $this->getPluginInfo($folder, $iniContent);\n        }\n\n        return $plugins;\n    }\n\n    /**\n     * Remove a plugin only if it's disabled.\n     *\n     * @param string $pluginName\n     *\n     * @return bool\n     */\n    public function remove(string $pluginName): bool\n    {\n        if (FS_DISABLE_RM_PLUGINS) {\n            ToolBox::i18nLog()->warning('plugin-removal-disabled');\n            return false;\n        }\n\n        // can't remove enabled plugins\n        if (in_array($pluginName, $this->enabledPlugins())) {\n            ToolBox::i18nLog()->warning('plugin-enabled', ['%pluginName%' => $pluginName]);\n            return false;\n        }\n\n        $pluginPath = self::PLUGIN_PATH . $pluginName;\n        if (is_dir($pluginPath) || is_file($pluginPath)) {\n            ToolBox::files()->delTree($pluginPath);\n            ToolBox::i18nLog()->notice('plugin-deleted', ['%pluginName%' => $pluginName]);\n            return true;\n        }\n\n        ToolBox::i18nLog()->error('plugin-delete-error', ['%pluginName%' => $pluginName]);\n        return false;\n    }\n\n    /**\n     * Check for plugins needed.\n     *\n     * @param array $require\n     *\n     * @return bool\n     */\n    private function checkRequire(array $require): bool\n    {\n        if (empty($require)) {\n            return true;\n        }\n\n        foreach ($require as $req) {\n            $found = false;\n            foreach ($this->enabledPlugins() as $pluginName) {\n                if ($pluginName === $req) {\n                    $found = true;\n                    break;\n                }\n            }\n\n            if (false === $found) {\n                ToolBox::i18nLog()->warning('plugin-needed', ['%pluginName%' => $req]);\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Disables plugins that depends on $pluginDisabled\n     *\n     * @param string $pluginDisabled\n     */\n    private function disableByDependency(string $pluginDisabled)\n    {\n        foreach (self::$enabledPlugins as $key => $value) {\n            if (in_array($pluginDisabled, $value['require'])) {\n                ToolBox::i18nLog()->warning('plugin-disabled', ['%pluginName%' => $value['name']]);\n                unset(self::$enabledPlugins[$key]);\n                $this->disableByDependency($value['name']);\n            }\n        }\n    }\n\n    /**\n     * Return plugin information.\n     *\n     * @param string $pluginName\n     * @param string $iniContent\n     *\n     * @return array\n     */\n    private function getPluginInfo(string $pluginName, string $iniContent): array\n    {\n        $info = [\n            'compatible' => false,\n            'description' => 'Incompatible',\n            'enabled' => false,\n            'min_version' => 0.0,\n            'name' => $pluginName,\n            'require' => [],\n            'version' => 1\n        ];\n        $ini = parse_ini_string($iniContent);\n        if ($ini === false) {\n            return $info;\n        }\n\n        $info['name'] = strip_tags($ini['name'] ?? $info['name']);\n        $info['version'] = floatval($ini['version'] ?? $info['version']);\n        $info['description'] = strip_tags($ini['description'] ?? $info['description']);\n        $info['min_version'] = floatval($ini['min_version'] ?? $info['min_version']);\n\n        if (isset($ini['require'])) {\n            foreach (explode(',', $ini['require']) as $req) {\n                $req = trim($req);\n                if (!empty($req)) {\n                    $info['require'][] = $req;\n                }\n            }\n        }\n\n        if ($info['min_version'] <= self::CORE_VERSION && $info['min_version'] >= 2020) {\n            $info['compatible'] = true;\n        } else {\n            $info['description'] = ToolBox::i18n()->trans('incompatible-with-facturascripts', ['%version%' => self::CORE_VERSION]);\n        }\n\n        $info['enabled'] = in_array($info['name'], $this->enabledPlugins());\n        return $info;\n    }\n\n    /**\n     * Returns an array with the list of plugins in the plugin.list file.\n     *\n     * @return array\n     */\n    private function loadFromFile(): array\n    {\n        if (file_exists(self::PLUGIN_LIST_FILE)) {\n            $content = file_get_contents(self::PLUGIN_LIST_FILE);\n            if ($content) {\n                return json_decode($content, true);\n            }\n        }\n\n        return [];\n    }\n\n    /**\n     * Save the list of plugins in a file.\n     *\n     * @return bool\n     */\n    private function save(): bool\n    {\n        $content = json_encode(self::$enabledPlugins);\n        return file_put_contents(self::PLUGIN_LIST_FILE, $content) !== false;\n    }\n\n    /**\n     * @param ZipArchive $zipFile\n     * @param string $zipPath\n     * @param string $zipName\n     *\n     * @return bool\n     */\n    private function testZipFile(ZipArchive &$zipFile, string $zipPath, string $zipName): bool\n    {\n        $result = $zipFile->open($zipPath, ZipArchive::CHECKCONS);\n        if (true !== $result) {\n            ToolBox::log()->error('ZIP error: ' . $result);\n            return false;\n        }\n\n        // get the facturascripts.ini file inside the zip\n        $zipIndex = $zipFile->locateName('facturascripts.ini', ZipArchive::FL_NODIR);\n        if (false === $zipIndex) {\n            ToolBox::i18nLog()->error('plugin-not-compatible', ['%pluginName%' => $zipName, '%version%' => self::CORE_VERSION]);\n            return false;\n        }\n\n        // the zip must contain the plugin folder\n        $pathINI = $zipFile->getNameIndex($zipIndex);\n        if (count(explode('/', $pathINI)) !== 2) {\n            ToolBox::i18nLog()->error('zip-error-wrong-structure');\n            return false;\n        }\n\n        // get folders inside the zip file\n        $folders = [];\n        for ($index = 0; $index < $zipFile->numFiles; $index++) {\n            $data = $zipFile->statIndex($index);\n            $path = explode('/', $data['name']);\n            if (count($path) > 1) {\n                $folders[$path[0]] = $path[0];\n            }\n        }\n\n        // the zip must contain a single plugin\n        if (count($folders) != 1) {\n            ToolBox::i18nLog()->error('zip-error-wrong-structure');\n            return false;\n        }\n\n        return true;\n    }\n}\n"], "filenames": ["Core/Base/PluginManager.php"], "buggy_code_start_loc": [383], "buggy_code_end_loc": [404], "fixing_code_start_loc": [382], "fixing_code_end_loc": [409], "type": "CWE-79", "message": "Stored XSS via upload plugin functionality in zip format in GitHub repository neorazorx/facturascripts prior to 2022.06. Cross-site scripting attacks can have devastating consequences. Code injected into a vulnerable application can exfiltrate data or install malware on the user's machine. Attackers can masquerade as authorized users via session cookies, allowing them to perform any action allowed by the user account.", "other": {"cve": {"id": "CVE-2022-1514", "sourceIdentifier": "security@huntr.dev", "published": "2022-04-28T16:15:08.060", "lastModified": "2022-05-06T18:16:49.473", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Stored XSS via upload plugin functionality in zip format in GitHub repository neorazorx/facturascripts prior to 2022.06. Cross-site scripting attacks can have devastating consequences. Code injected into a vulnerable application can exfiltrate data or install malware on the user's machine. Attackers can masquerade as authorized users via session cookies, allowing them to perform any action allowed by the user account."}, {"lang": "es", "value": "Una vulnerabilidad de tipo XSS almacenado por medio de la funcionalidad upload plugin en formato zip en el repositorio de GitHub neorazorx/facturascripts versiones anteriores a 2022.06. Los ataques de tipo cross-site scripting pueden tener consecuencias devastadoras. El c\u00f3digo inyectado en una aplicaci\u00f3n vulnerable puede exfiltrar datos o instalar malware en la m\u00e1quina del usuario. Los atacantes pueden hacerse pasar por usuarios autorizados por medio de cookies de sesi\u00f3n, permiti\u00e9ndoles llevar a cabo cualquier acci\u00f3n permitida por la cuenta de usuario"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.2, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facturascripts:facturascripts:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022.06", "matchCriteriaId": "4D19608D-8D38-4581-89F0-4C4318197848"}]}]}], "references": [{"url": "https://github.com/neorazorx/facturascripts/commit/aa9f28cb86467468f43486b77ddef7ff4d3c687e", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/4ae2a917-843a-4ae4-8197-8425a596761c", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/neorazorx/facturascripts/commit/aa9f28cb86467468f43486b77ddef7ff4d3c687e"}}