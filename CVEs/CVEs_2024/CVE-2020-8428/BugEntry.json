{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n *  linux/fs/namei.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n */\n\n/*\n * Some corrections by tytso.\n */\n\n/* [Feb 1997 T. Schoebel-Theuer] Complete rewrite of the pathname\n * lookup logic.\n */\n/* [Feb-Apr 2000, AV] Rewrite to the new namespace architecture.\n */\n\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/personality.h>\n#include <linux/security.h>\n#include <linux/ima.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/device_cgroup.h>\n#include <linux/fs_struct.h>\n#include <linux/posix_acl.h>\n#include <linux/hash.h>\n#include <linux/bitops.h>\n#include <linux/init_task.h>\n#include <linux/uaccess.h>\n\n#include \"internal.h\"\n#include \"mount.h\"\n\n/* [Feb-1997 T. Schoebel-Theuer]\n * Fundamental changes in the pathname lookup mechanisms (namei)\n * were necessary because of omirr.  The reason is that omirr needs\n * to know the _real_ pathname, not the user-supplied one, in case\n * of symlinks (and also when transname replacements occur).\n *\n * The new code replaces the old recursive symlink resolution with\n * an iterative one (in case of non-nested symlink chains).  It does\n * this with calls to <fs>_follow_link().\n * As a side effect, dir_namei(), _namei() and follow_link() are now \n * replaced with a single function lookup_dentry() that can handle all \n * the special cases of the former code.\n *\n * With the new dcache, the pathname is stored at each inode, at least as\n * long as the refcount of the inode is positive.  As a side effect, the\n * size of the dcache depends on the inode cache and thus is dynamic.\n *\n * [29-Apr-1998 C. Scott Ananian] Updated above description of symlink\n * resolution to correspond with current state of the code.\n *\n * Note that the symlink resolution is not *completely* iterative.\n * There is still a significant amount of tail- and mid- recursion in\n * the algorithm.  Also, note that <fs>_readlink() is not used in\n * lookup_dentry(): lookup_dentry() on the result of <fs>_readlink()\n * may return different results than <fs>_follow_link().  Many virtual\n * filesystems (including /proc) exhibit this behavior.\n */\n\n/* [24-Feb-97 T. Schoebel-Theuer] Side effects caused by new implementation:\n * New symlink semantics: when open() is called with flags O_CREAT | O_EXCL\n * and the name already exists in form of a symlink, try to create the new\n * name indicated by the symlink. The old code always complained that the\n * name already exists, due to not following the symlink even if its target\n * is nonexistent.  The new semantics affects also mknod() and link() when\n * the name is a symlink pointing to a non-existent name.\n *\n * I don't know which semantics is the right one, since I have no access\n * to standards. But I found by trial that HP-UX 9.0 has the full \"new\"\n * semantics implemented, while SunOS 4.1.1 and Solaris (SunOS 5.4) have the\n * \"old\" one. Personally, I think the new semantics is much more logical.\n * Note that \"ln old new\" where \"new\" is a symlink pointing to a non-existing\n * file does succeed in both HP-UX and SunOs, but not in Solaris\n * and in the old Linux semantics.\n */\n\n/* [16-Dec-97 Kevin Buhr] For security reasons, we change some symlink\n * semantics.  See the comments in \"open_namei\" and \"do_link\" below.\n *\n * [10-Sep-98 Alan Modra] Another symlink change.\n */\n\n/* [Feb-Apr 2000 AV] Complete rewrite. Rules for symlinks:\n *\tinside the path - always follow.\n *\tin the last component in creation/removal/renaming - never follow.\n *\tif LOOKUP_FOLLOW passed - follow.\n *\tif the pathname has trailing slashes - follow.\n *\totherwise - don't follow.\n * (applied in that order).\n *\n * [Jun 2000 AV] Inconsistent behaviour of open() in case if flags==O_CREAT\n * restored for 2.4. This is the last surviving part of old 4.2BSD bug.\n * During the 2.4 we need to fix the userland stuff depending on it -\n * hopefully we will be able to get rid of that wart in 2.5. So far only\n * XEmacs seems to be relying on it...\n */\n/*\n * [Sep 2001 AV] Single-semaphore locking scheme (kudos to David Holland)\n * implemented.  Let's see if raised priority of ->s_vfs_rename_mutex gives\n * any extra contention...\n */\n\n/* In order to reduce some races, while at the same time doing additional\n * checking and hopefully speeding things up, we copy filenames to the\n * kernel data space before using them..\n *\n * POSIX.1 2.4: an empty pathname is invalid (ENOENT).\n * PATH_MAX includes the nul terminator --RR.\n */\n\n#define EMBEDDED_NAME_MAX\t(PATH_MAX - offsetof(struct filename, iname))\n\nstruct filename *\ngetname_flags(const char __user *filename, int flags, int *empty)\n{\n\tstruct filename *result;\n\tchar *kname;\n\tint len;\n\n\tresult = audit_reusename(filename);\n\tif (result)\n\t\treturn result;\n\n\tresult = __getname();\n\tif (unlikely(!result))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/*\n\t * First, try to embed the struct filename inside the names_cache\n\t * allocation\n\t */\n\tkname = (char *)result->iname;\n\tresult->name = kname;\n\n\tlen = strncpy_from_user(kname, filename, EMBEDDED_NAME_MAX);\n\tif (unlikely(len < 0)) {\n\t\t__putname(result);\n\t\treturn ERR_PTR(len);\n\t}\n\n\t/*\n\t * Uh-oh. We have a name that's approaching PATH_MAX. Allocate a\n\t * separate struct filename so we can dedicate the entire\n\t * names_cache allocation for the pathname, and re-do the copy from\n\t * userland.\n\t */\n\tif (unlikely(len == EMBEDDED_NAME_MAX)) {\n\t\tconst size_t size = offsetof(struct filename, iname[1]);\n\t\tkname = (char *)result;\n\n\t\t/*\n\t\t * size is chosen that way we to guarantee that\n\t\t * result->iname[0] is within the same object and that\n\t\t * kname can't be equal to result->iname, no matter what.\n\t\t */\n\t\tresult = kzalloc(size, GFP_KERNEL);\n\t\tif (unlikely(!result)) {\n\t\t\t__putname(kname);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\tresult->name = kname;\n\t\tlen = strncpy_from_user(kname, filename, PATH_MAX);\n\t\tif (unlikely(len < 0)) {\n\t\t\t__putname(kname);\n\t\t\tkfree(result);\n\t\t\treturn ERR_PTR(len);\n\t\t}\n\t\tif (unlikely(len == PATH_MAX)) {\n\t\t\t__putname(kname);\n\t\t\tkfree(result);\n\t\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t\t}\n\t}\n\n\tresult->refcnt = 1;\n\t/* The empty path is special. */\n\tif (unlikely(!len)) {\n\t\tif (empty)\n\t\t\t*empty = 1;\n\t\tif (!(flags & LOOKUP_EMPTY)) {\n\t\t\tputname(result);\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\t}\n\t}\n\n\tresult->uptr = filename;\n\tresult->aname = NULL;\n\taudit_getname(result);\n\treturn result;\n}\n\nstruct filename *\ngetname(const char __user * filename)\n{\n\treturn getname_flags(filename, 0, NULL);\n}\n\nstruct filename *\ngetname_kernel(const char * filename)\n{\n\tstruct filename *result;\n\tint len = strlen(filename) + 1;\n\n\tresult = __getname();\n\tif (unlikely(!result))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (len <= EMBEDDED_NAME_MAX) {\n\t\tresult->name = (char *)result->iname;\n\t} else if (len <= PATH_MAX) {\n\t\tconst size_t size = offsetof(struct filename, iname[1]);\n\t\tstruct filename *tmp;\n\n\t\ttmp = kmalloc(size, GFP_KERNEL);\n\t\tif (unlikely(!tmp)) {\n\t\t\t__putname(result);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\ttmp->name = (char *)result;\n\t\tresult = tmp;\n\t} else {\n\t\t__putname(result);\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\tmemcpy((char *)result->name, filename, len);\n\tresult->uptr = NULL;\n\tresult->aname = NULL;\n\tresult->refcnt = 1;\n\taudit_getname(result);\n\n\treturn result;\n}\n\nvoid putname(struct filename *name)\n{\n\tBUG_ON(name->refcnt <= 0);\n\n\tif (--name->refcnt > 0)\n\t\treturn;\n\n\tif (name->name != name->iname) {\n\t\t__putname(name->name);\n\t\tkfree(name);\n\t} else\n\t\t__putname(name);\n}\n\nstatic int check_acl(struct inode *inode, int mask)\n{\n#ifdef CONFIG_FS_POSIX_ACL\n\tstruct posix_acl *acl;\n\n\tif (mask & MAY_NOT_BLOCK) {\n\t\tacl = get_cached_acl_rcu(inode, ACL_TYPE_ACCESS);\n\t        if (!acl)\n\t                return -EAGAIN;\n\t\t/* no ->get_acl() calls in RCU mode... */\n\t\tif (is_uncached_acl(acl))\n\t\t\treturn -ECHILD;\n\t        return posix_acl_permission(inode, acl, mask & ~MAY_NOT_BLOCK);\n\t}\n\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR(acl))\n\t\treturn PTR_ERR(acl);\n\tif (acl) {\n\t        int error = posix_acl_permission(inode, acl, mask);\n\t        posix_acl_release(acl);\n\t        return error;\n\t}\n#endif\n\n\treturn -EAGAIN;\n}\n\n/*\n * This does the basic permission checking\n */\nstatic int acl_permission_check(struct inode *inode, int mask)\n{\n\tunsigned int mode = inode->i_mode;\n\n\tif (likely(uid_eq(current_fsuid(), inode->i_uid)))\n\t\tmode >>= 6;\n\telse {\n\t\tif (IS_POSIXACL(inode) && (mode & S_IRWXG)) {\n\t\t\tint error = check_acl(inode, mask);\n\t\t\tif (error != -EAGAIN)\n\t\t\t\treturn error;\n\t\t}\n\n\t\tif (in_group_p(inode->i_gid))\n\t\t\tmode >>= 3;\n\t}\n\n\t/*\n\t * If the DACs are ok we don't need any capability check.\n\t */\n\tif ((mask & ~mode & (MAY_READ | MAY_WRITE | MAY_EXEC)) == 0)\n\t\treturn 0;\n\treturn -EACCES;\n}\n\n/**\n * generic_permission -  check for access rights on a Posix-like filesystem\n * @inode:\tinode to check access rights for\n * @mask:\tright to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC, ...)\n *\n * Used to check for read/write/execute permissions on a file.\n * We use \"fsuid\" for this, letting us set arbitrary permissions\n * for filesystem access without changing the \"normal\" uids which\n * are used for other things.\n *\n * generic_permission is rcu-walk aware. It returns -ECHILD in case an rcu-walk\n * request cannot be satisfied (eg. requires blocking or too much complexity).\n * It would then be called again in ref-walk mode.\n */\nint generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}\nEXPORT_SYMBOL(generic_permission);\n\n/*\n * We _really_ want to just do \"generic_permission()\" without\n * even looking at the inode->i_op values. So we keep a cache\n * flag in inode->i_opflags, that says \"this has not special\n * permission function, use the fast case\".\n */\nstatic inline int do_inode_permission(struct inode *inode, int mask)\n{\n\tif (unlikely(!(inode->i_opflags & IOP_FASTPERM))) {\n\t\tif (likely(inode->i_op->permission))\n\t\t\treturn inode->i_op->permission(inode, mask);\n\n\t\t/* This gets set once for the inode lifetime */\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_opflags |= IOP_FASTPERM;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn generic_permission(inode, mask);\n}\n\n/**\n * sb_permission - Check superblock-level permissions\n * @sb: Superblock of inode to check permission on\n * @inode: Inode to check permission on\n * @mask: Right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC)\n *\n * Separate out file-system wide checks from inode-specific permission checks.\n */\nstatic int sb_permission(struct super_block *sb, struct inode *inode, int mask)\n{\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\tumode_t mode = inode->i_mode;\n\n\t\t/* Nobody gets write access to a read-only fs. */\n\t\tif (sb_rdonly(sb) && (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))\n\t\t\treturn -EROFS;\n\t}\n\treturn 0;\n}\n\n/**\n * inode_permission - Check for access rights to a given inode\n * @inode: Inode to check permission on\n * @mask: Right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC)\n *\n * Check for read/write/execute permissions on an inode.  We use fs[ug]id for\n * this, letting us set arbitrary permissions for filesystem access without\n * changing the \"normal\" UIDs which are used for other things.\n *\n * When checking for MAY_APPEND, MAY_WRITE must also be set in @mask.\n */\nint inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\t/*\n\t\t * Nobody gets write access to an immutable file.\n\t\t */\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Updating mtime will likely cause i_uid and i_gid to be\n\t\t * written back improperly if their true value is unknown\n\t\t * to the vfs.\n\t\t */\n\t\tif (HAS_UNMAPPED_ID(inode))\n\t\t\treturn -EACCES;\n\t}\n\n\tretval = do_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = devcgroup_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\treturn security_inode_permission(inode, mask);\n}\nEXPORT_SYMBOL(inode_permission);\n\n/**\n * path_get - get a reference to a path\n * @path: path to get the reference to\n *\n * Given a path increment the reference count to the dentry and the vfsmount.\n */\nvoid path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}\nEXPORT_SYMBOL(path_get);\n\n/**\n * path_put - put a reference to a path\n * @path: path to put the reference to\n *\n * Given a path decrement the reference count to the dentry and the vfsmount.\n */\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}\nEXPORT_SYMBOL(path_put);\n\n#define EMBEDDED_LEVELS 2\nstruct nameidata {\n\tstruct path\tpath;\n\tstruct qstr\tlast;\n\tstruct path\troot;\n\tstruct inode\t*inode; /* path.dentry.d_inode */\n\tunsigned int\tflags;\n\tunsigned\tseq, m_seq;\n\tint\t\tlast_type;\n\tunsigned\tdepth;\n\tint\t\ttotal_link_count;\n\tstruct saved {\n\t\tstruct path link;\n\t\tstruct delayed_call done;\n\t\tconst char *name;\n\t\tunsigned seq;\n\t} *stack, internal[EMBEDDED_LEVELS];\n\tstruct filename\t*name;\n\tstruct nameidata *saved;\n\tstruct inode\t*link_inode;\n\tunsigned\troot_seq;\n\tint\t\tdfd;\n} __randomize_layout;\n\nstatic void set_nameidata(struct nameidata *p, int dfd, struct filename *name)\n{\n\tstruct nameidata *old = current->nameidata;\n\tp->stack = p->internal;\n\tp->dfd = dfd;\n\tp->name = name;\n\tp->total_link_count = old ? old->total_link_count : 0;\n\tp->saved = old;\n\tcurrent->nameidata = p;\n}\n\nstatic void restore_nameidata(void)\n{\n\tstruct nameidata *now = current->nameidata, *old = now->saved;\n\n\tcurrent->nameidata = old;\n\tif (old)\n\t\told->total_link_count = now->total_link_count;\n\tif (now->stack != now->internal)\n\t\tkfree(now->stack);\n}\n\nstatic int __nd_alloc_stack(struct nameidata *nd)\n{\n\tstruct saved *p;\n\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tp= kmalloc_array(MAXSYMLINKS, sizeof(struct saved),\n\t\t\t\t  GFP_ATOMIC);\n\t\tif (unlikely(!p))\n\t\t\treturn -ECHILD;\n\t} else {\n\t\tp= kmalloc_array(MAXSYMLINKS, sizeof(struct saved),\n\t\t\t\t  GFP_KERNEL);\n\t\tif (unlikely(!p))\n\t\t\treturn -ENOMEM;\n\t}\n\tmemcpy(p, nd->internal, sizeof(nd->internal));\n\tnd->stack = p;\n\treturn 0;\n}\n\n/**\n * path_connected - Verify that a path->dentry is below path->mnt.mnt_root\n * @path: nameidate to verify\n *\n * Rename can sometimes move a file or directory outside of a bind\n * mount, path_connected allows those cases to be detected.\n */\nstatic bool path_connected(const struct path *path)\n{\n\tstruct vfsmount *mnt = path->mnt;\n\tstruct super_block *sb = mnt->mnt_sb;\n\n\t/* Bind mounts and multi-root filesystems can have disconnected paths */\n\tif (!(sb->s_iflags & SB_I_MULTIROOT) && (mnt->mnt_root == sb->s_root))\n\t\treturn true;\n\n\treturn is_subdir(path->dentry, mnt->mnt_root);\n}\n\nstatic inline int nd_alloc_stack(struct nameidata *nd)\n{\n\tif (likely(nd->depth != EMBEDDED_LEVELS))\n\t\treturn 0;\n\tif (likely(nd->stack != nd->internal))\n\t\treturn 0;\n\treturn __nd_alloc_stack(nd);\n}\n\nstatic void drop_links(struct nameidata *nd)\n{\n\tint i = nd->depth;\n\twhile (i--) {\n\t\tstruct saved *last = nd->stack + i;\n\t\tdo_delayed_call(&last->done);\n\t\tclear_delayed_call(&last->done);\n\t}\n}\n\nstatic void terminate_walk(struct nameidata *nd)\n{\n\tdrop_links(nd);\n\tif (!(nd->flags & LOOKUP_RCU)) {\n\t\tint i;\n\t\tpath_put(&nd->path);\n\t\tfor (i = 0; i < nd->depth; i++)\n\t\t\tpath_put(&nd->stack[i].link);\n\t\tif (nd->flags & LOOKUP_ROOT_GRABBED) {\n\t\t\tpath_put(&nd->root);\n\t\t\tnd->flags &= ~LOOKUP_ROOT_GRABBED;\n\t\t}\n\t} else {\n\t\tnd->flags &= ~LOOKUP_RCU;\n\t\trcu_read_unlock();\n\t}\n\tnd->depth = 0;\n}\n\n/* path_put is needed afterwards regardless of success or failure */\nstatic bool legitimize_path(struct nameidata *nd,\n\t\t\t    struct path *path, unsigned seq)\n{\n\tint res = __legitimize_mnt(path->mnt, nd->m_seq);\n\tif (unlikely(res)) {\n\t\tif (res > 0)\n\t\t\tpath->mnt = NULL;\n\t\tpath->dentry = NULL;\n\t\treturn false;\n\t}\n\tif (unlikely(!lockref_get_not_dead(&path->dentry->d_lockref))) {\n\t\tpath->dentry = NULL;\n\t\treturn false;\n\t}\n\treturn !read_seqcount_retry(&path->dentry->d_seq, seq);\n}\n\nstatic bool legitimize_links(struct nameidata *nd)\n{\n\tint i;\n\tfor (i = 0; i < nd->depth; i++) {\n\t\tstruct saved *last = nd->stack + i;\n\t\tif (unlikely(!legitimize_path(nd, &last->link, last->seq))) {\n\t\t\tdrop_links(nd);\n\t\t\tnd->depth = i + 1;\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic bool legitimize_root(struct nameidata *nd)\n{\n\tif (!nd->root.mnt || (nd->flags & LOOKUP_ROOT))\n\t\treturn true;\n\tnd->flags |= LOOKUP_ROOT_GRABBED;\n\treturn legitimize_path(nd, &nd->root, nd->root_seq);\n}\n\n/*\n * Path walking has 2 modes, rcu-walk and ref-walk (see\n * Documentation/filesystems/path-lookup.txt).  In situations when we can't\n * continue in RCU mode, we attempt to drop out of rcu-walk mode and grab\n * normal reference counts on dentries and vfsmounts to transition to ref-walk\n * mode.  Refcounts are grabbed at the last known good point before rcu-walk\n * got stuck, so ref-walk may continue from there. If this is not successful\n * (eg. a seqcount has changed), then failure is returned and it's up to caller\n * to restart the path walk from the beginning in ref-walk mode.\n */\n\n/**\n * unlazy_walk - try to switch to ref-walk mode.\n * @nd: nameidata pathwalk data\n * Returns: 0 on success, -ECHILD on failure\n *\n * unlazy_walk attempts to legitimize the current nd->path and nd->root\n * for ref-walk mode.\n * Must be called from rcu-walk context.\n * Nothing should touch nameidata between unlazy_walk() failure and\n * terminate_walk().\n */\nstatic int unlazy_walk(struct nameidata *nd)\n{\n\tstruct dentry *parent = nd->path.dentry;\n\n\tBUG_ON(!(nd->flags & LOOKUP_RCU));\n\n\tnd->flags &= ~LOOKUP_RCU;\n\tif (unlikely(!legitimize_links(nd)))\n\t\tgoto out1;\n\tif (unlikely(!legitimize_path(nd, &nd->path, nd->seq)))\n\t\tgoto out;\n\tif (unlikely(!legitimize_root(nd)))\n\t\tgoto out;\n\trcu_read_unlock();\n\tBUG_ON(nd->inode != parent->d_inode);\n\treturn 0;\n\nout1:\n\tnd->path.mnt = NULL;\n\tnd->path.dentry = NULL;\nout:\n\trcu_read_unlock();\n\treturn -ECHILD;\n}\n\n/**\n * unlazy_child - try to switch to ref-walk mode.\n * @nd: nameidata pathwalk data\n * @dentry: child of nd->path.dentry\n * @seq: seq number to check dentry against\n * Returns: 0 on success, -ECHILD on failure\n *\n * unlazy_child attempts to legitimize the current nd->path, nd->root and dentry\n * for ref-walk mode.  @dentry must be a path found by a do_lookup call on\n * @nd.  Must be called from rcu-walk context.\n * Nothing should touch nameidata between unlazy_child() failure and\n * terminate_walk().\n */\nstatic int unlazy_child(struct nameidata *nd, struct dentry *dentry, unsigned seq)\n{\n\tBUG_ON(!(nd->flags & LOOKUP_RCU));\n\n\tnd->flags &= ~LOOKUP_RCU;\n\tif (unlikely(!legitimize_links(nd)))\n\t\tgoto out2;\n\tif (unlikely(!legitimize_mnt(nd->path.mnt, nd->m_seq)))\n\t\tgoto out2;\n\tif (unlikely(!lockref_get_not_dead(&nd->path.dentry->d_lockref)))\n\t\tgoto out1;\n\n\t/*\n\t * We need to move both the parent and the dentry from the RCU domain\n\t * to be properly refcounted. And the sequence number in the dentry\n\t * validates *both* dentry counters, since we checked the sequence\n\t * number of the parent after we got the child sequence number. So we\n\t * know the parent must still be valid if the child sequence number is\n\t */\n\tif (unlikely(!lockref_get_not_dead(&dentry->d_lockref)))\n\t\tgoto out;\n\tif (unlikely(read_seqcount_retry(&dentry->d_seq, seq)))\n\t\tgoto out_dput;\n\t/*\n\t * Sequence counts matched. Now make sure that the root is\n\t * still valid and get it if required.\n\t */\n\tif (unlikely(!legitimize_root(nd)))\n\t\tgoto out_dput;\n\trcu_read_unlock();\n\treturn 0;\n\nout2:\n\tnd->path.mnt = NULL;\nout1:\n\tnd->path.dentry = NULL;\nout:\n\trcu_read_unlock();\n\treturn -ECHILD;\nout_dput:\n\trcu_read_unlock();\n\tdput(dentry);\n\treturn -ECHILD;\n}\n\nstatic inline int d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tif (unlikely(dentry->d_flags & DCACHE_OP_REVALIDATE))\n\t\treturn dentry->d_op->d_revalidate(dentry, flags);\n\telse\n\t\treturn 1;\n}\n\n/**\n * complete_walk - successful completion of path walk\n * @nd:  pointer nameidata\n *\n * If we had been in RCU mode, drop out of it and legitimize nd->path.\n * Revalidate the final result, unless we'd already done that during\n * the path walk or the filesystem doesn't ask for it.  Return 0 on\n * success, -error on failure.  In case of failure caller does not\n * need to drop nd->path.\n */\nstatic int complete_walk(struct nameidata *nd)\n{\n\tstruct dentry *dentry = nd->path.dentry;\n\tint status;\n\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tif (!(nd->flags & LOOKUP_ROOT))\n\t\t\tnd->root.mnt = NULL;\n\t\tif (unlikely(unlazy_walk(nd)))\n\t\t\treturn -ECHILD;\n\t}\n\n\tif (likely(!(nd->flags & LOOKUP_JUMPED)))\n\t\treturn 0;\n\n\tif (likely(!(dentry->d_flags & DCACHE_OP_WEAK_REVALIDATE)))\n\t\treturn 0;\n\n\tstatus = dentry->d_op->d_weak_revalidate(dentry, nd->flags);\n\tif (status > 0)\n\t\treturn 0;\n\n\tif (!status)\n\t\tstatus = -ESTALE;\n\n\treturn status;\n}\n\nstatic void set_root(struct nameidata *nd)\n{\n\tstruct fs_struct *fs = current->fs;\n\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tunsigned seq;\n\n\t\tdo {\n\t\t\tseq = read_seqcount_begin(&fs->seq);\n\t\t\tnd->root = fs->root;\n\t\t\tnd->root_seq = __read_seqcount_begin(&nd->root.dentry->d_seq);\n\t\t} while (read_seqcount_retry(&fs->seq, seq));\n\t} else {\n\t\tget_fs_root(fs, &nd->root);\n\t\tnd->flags |= LOOKUP_ROOT_GRABBED;\n\t}\n}\n\nstatic void path_put_conditional(struct path *path, struct nameidata *nd)\n{\n\tdput(path->dentry);\n\tif (path->mnt != nd->path.mnt)\n\t\tmntput(path->mnt);\n}\n\nstatic inline void path_to_nameidata(const struct path *path,\n\t\t\t\t\tstruct nameidata *nd)\n{\n\tif (!(nd->flags & LOOKUP_RCU)) {\n\t\tdput(nd->path.dentry);\n\t\tif (nd->path.mnt != path->mnt)\n\t\t\tmntput(nd->path.mnt);\n\t}\n\tnd->path.mnt = path->mnt;\n\tnd->path.dentry = path->dentry;\n}\n\nstatic int nd_jump_root(struct nameidata *nd)\n{\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tstruct dentry *d;\n\t\tnd->path = nd->root;\n\t\td = nd->path.dentry;\n\t\tnd->inode = d->d_inode;\n\t\tnd->seq = nd->root_seq;\n\t\tif (unlikely(read_seqcount_retry(&d->d_seq, nd->seq)))\n\t\t\treturn -ECHILD;\n\t} else {\n\t\tpath_put(&nd->path);\n\t\tnd->path = nd->root;\n\t\tpath_get(&nd->path);\n\t\tnd->inode = nd->path.dentry->d_inode;\n\t}\n\tnd->flags |= LOOKUP_JUMPED;\n\treturn 0;\n}\n\n/*\n * Helper to directly jump to a known parsed path from ->get_link,\n * caller must have taken a reference to path beforehand.\n */\nvoid nd_jump_link(struct path *path)\n{\n\tstruct nameidata *nd = current->nameidata;\n\tpath_put(&nd->path);\n\n\tnd->path = *path;\n\tnd->inode = nd->path.dentry->d_inode;\n\tnd->flags |= LOOKUP_JUMPED;\n}\n\nstatic inline void put_link(struct nameidata *nd)\n{\n\tstruct saved *last = nd->stack + --nd->depth;\n\tdo_delayed_call(&last->done);\n\tif (!(nd->flags & LOOKUP_RCU))\n\t\tpath_put(&last->link);\n}\n\nint sysctl_protected_symlinks __read_mostly = 0;\nint sysctl_protected_hardlinks __read_mostly = 0;\nint sysctl_protected_fifos __read_mostly;\nint sysctl_protected_regular __read_mostly;\n\n/**\n * may_follow_link - Check symlink following for unsafe situations\n * @nd: nameidata pathwalk data\n *\n * In the case of the sysctl_protected_symlinks sysctl being enabled,\n * CAP_DAC_OVERRIDE needs to be specifically ignored if the symlink is\n * in a sticky world-writable directory. This is to protect privileged\n * processes from failing races against path names that may change out\n * from under them by way of other users creating malicious symlinks.\n * It will permit symlinks to be followed only when outside a sticky\n * world-writable directory, or when the uid of the symlink and follower\n * match, or when the directory owner matches the symlink's owner.\n *\n * Returns 0 if following the symlink is allowed, -ve on error.\n */\nstatic inline int may_follow_link(struct nameidata *nd)\n{\n\tconst struct inode *inode;\n\tconst struct inode *parent;\n\tkuid_t puid;\n\n\tif (!sysctl_protected_symlinks)\n\t\treturn 0;\n\n\t/* Allowed if owner and follower match. */\n\tinode = nd->link_inode;\n\tif (uid_eq(current_cred()->fsuid, inode->i_uid))\n\t\treturn 0;\n\n\t/* Allowed if parent directory not sticky and world-writable. */\n\tparent = nd->inode;\n\tif ((parent->i_mode & (S_ISVTX|S_IWOTH)) != (S_ISVTX|S_IWOTH))\n\t\treturn 0;\n\n\t/* Allowed if parent directory and link owner match. */\n\tpuid = parent->i_uid;\n\tif (uid_valid(puid) && uid_eq(puid, inode->i_uid))\n\t\treturn 0;\n\n\tif (nd->flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\taudit_inode(nd->name, nd->stack[0].link.dentry, 0);\n\taudit_log_path_denied(AUDIT_ANOM_LINK, \"follow_link\");\n\treturn -EACCES;\n}\n\n/**\n * safe_hardlink_source - Check for safe hardlink conditions\n * @inode: the source inode to hardlink from\n *\n * Return false if at least one of the following conditions:\n *    - inode is not a regular file\n *    - inode is setuid\n *    - inode is setgid and group-exec\n *    - access failure for read and write\n *\n * Otherwise returns true.\n */\nstatic bool safe_hardlink_source(struct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\n\t/* Special files should not get pinned to the filesystem. */\n\tif (!S_ISREG(mode))\n\t\treturn false;\n\n\t/* Setuid files should not get pinned to the filesystem. */\n\tif (mode & S_ISUID)\n\t\treturn false;\n\n\t/* Executable setgid files should not get pinned to the filesystem. */\n\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP))\n\t\treturn false;\n\n\t/* Hardlinking to unreadable or unwritable sources is dangerous. */\n\tif (inode_permission(inode, MAY_READ | MAY_WRITE))\n\t\treturn false;\n\n\treturn true;\n}\n\n/**\n * may_linkat - Check permissions for creating a hardlink\n * @link: the source to hardlink from\n *\n * Block hardlink when all of:\n *  - sysctl_protected_hardlinks enabled\n *  - fsuid does not match inode\n *  - hardlink source is unsafe (see safe_hardlink_source() above)\n *  - not CAP_FOWNER in a namespace with the inode owner uid mapped\n *\n * Returns 0 if successful, -ve on error.\n */\nstatic int may_linkat(struct path *link)\n{\n\tstruct inode *inode = link->dentry->d_inode;\n\n\t/* Inode writeback is not safe when the uid or gid are invalid. */\n\tif (!uid_valid(inode->i_uid) || !gid_valid(inode->i_gid))\n\t\treturn -EOVERFLOW;\n\n\tif (!sysctl_protected_hardlinks)\n\t\treturn 0;\n\n\t/* Source inode owner (or CAP_FOWNER) can hardlink all they like,\n\t * otherwise, it must be a safe source.\n\t */\n\tif (safe_hardlink_source(inode) || inode_owner_or_capable(inode))\n\t\treturn 0;\n\n\taudit_log_path_denied(AUDIT_ANOM_LINK, \"linkat\");\n\treturn -EPERM;\n}\n\n/**\n * may_create_in_sticky - Check whether an O_CREAT open in a sticky directory\n *\t\t\t  should be allowed, or not, on files that already\n *\t\t\t  exist.\n * @dir: the sticky parent directory\n * @inode: the inode of the file to open\n *\n * Block an O_CREAT open of a FIFO (or a regular file) when:\n *   - sysctl_protected_fifos (or sysctl_protected_regular) is enabled\n *   - the file already exists\n *   - we are in a sticky directory\n *   - we don't own the file\n *   - the owner of the directory doesn't own the file\n *   - the directory is world writable\n * If the sysctl_protected_fifos (or sysctl_protected_regular) is set to 2\n * the directory doesn't have to be world writable: being group writable will\n * be enough.\n *\n * Returns 0 if the open is allowed, -ve on error.\n */\nstatic int may_create_in_sticky(struct dentry * const dir,\n\t\t\t\tstruct inode * const inode)\n{\n\tif ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||\n\t    (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||\n\t    likely(!(dir->d_inode->i_mode & S_ISVTX)) ||\n\t    uid_eq(inode->i_uid, dir->d_inode->i_uid) ||\n\t    uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn 0;\n\n\tif (likely(dir->d_inode->i_mode & 0002) ||\n\t    (dir->d_inode->i_mode & 0020 &&\n\t     ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||\n\t      (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {\n\t\tconst char *operation = S_ISFIFO(inode->i_mode) ?\n\t\t\t\t\t\"sticky_create_fifo\" :\n\t\t\t\t\t\"sticky_create_regular\";\n\t\taudit_log_path_denied(AUDIT_ANOM_CREAT, operation);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}\n\nstatic __always_inline\nconst char *get_link(struct nameidata *nd)\n{\n\tstruct saved *last = nd->stack + nd->depth - 1;\n\tstruct dentry *dentry = last->link.dentry;\n\tstruct inode *inode = nd->link_inode;\n\tint error;\n\tconst char *res;\n\n\tif (!(nd->flags & LOOKUP_RCU)) {\n\t\ttouch_atime(&last->link);\n\t\tcond_resched();\n\t} else if (atime_needs_update(&last->link, inode)) {\n\t\tif (unlikely(unlazy_walk(nd)))\n\t\t\treturn ERR_PTR(-ECHILD);\n\t\ttouch_atime(&last->link);\n\t}\n\n\terror = security_inode_follow_link(dentry, inode,\n\t\t\t\t\t   nd->flags & LOOKUP_RCU);\n\tif (unlikely(error))\n\t\treturn ERR_PTR(error);\n\n\tnd->last_type = LAST_BIND;\n\tres = READ_ONCE(inode->i_link);\n\tif (!res) {\n\t\tconst char * (*get)(struct dentry *, struct inode *,\n\t\t\t\tstruct delayed_call *);\n\t\tget = inode->i_op->get_link;\n\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\tres = get(NULL, inode, &last->done);\n\t\t\tif (res == ERR_PTR(-ECHILD)) {\n\t\t\t\tif (unlikely(unlazy_walk(nd)))\n\t\t\t\t\treturn ERR_PTR(-ECHILD);\n\t\t\t\tres = get(dentry, inode, &last->done);\n\t\t\t}\n\t\t} else {\n\t\t\tres = get(dentry, inode, &last->done);\n\t\t}\n\t\tif (IS_ERR_OR_NULL(res))\n\t\t\treturn res;\n\t}\n\tif (*res == '/') {\n\t\tif (!nd->root.mnt)\n\t\t\tset_root(nd);\n\t\tif (unlikely(nd_jump_root(nd)))\n\t\t\treturn ERR_PTR(-ECHILD);\n\t\twhile (unlikely(*++res == '/'))\n\t\t\t;\n\t}\n\tif (!*res)\n\t\tres = NULL;\n\treturn res;\n}\n\n/*\n * follow_up - Find the mountpoint of path's vfsmount\n *\n * Given a path, find the mountpoint of its source file system.\n * Replace @path with the path of the mountpoint in the parent mount.\n * Up is towards /.\n *\n * Return 1 if we went up a level and 0 if we were already at the\n * root.\n */\nint follow_up(struct path *path)\n{\n\tstruct mount *mnt = real_mount(path->mnt);\n\tstruct mount *parent;\n\tstruct dentry *mountpoint;\n\n\tread_seqlock_excl(&mount_lock);\n\tparent = mnt->mnt_parent;\n\tif (parent == mnt) {\n\t\tread_sequnlock_excl(&mount_lock);\n\t\treturn 0;\n\t}\n\tmntget(&parent->mnt);\n\tmountpoint = dget(mnt->mnt_mountpoint);\n\tread_sequnlock_excl(&mount_lock);\n\tdput(path->dentry);\n\tpath->dentry = mountpoint;\n\tmntput(path->mnt);\n\tpath->mnt = &parent->mnt;\n\treturn 1;\n}\nEXPORT_SYMBOL(follow_up);\n\n/*\n * Perform an automount\n * - return -EISDIR to tell follow_managed() to stop and return the path we\n *   were called with.\n */\nstatic int follow_automount(struct path *path, struct nameidata *nd,\n\t\t\t    bool *need_mntput)\n{\n\tstruct vfsmount *mnt;\n\tint err;\n\n\tif (!path->dentry->d_op || !path->dentry->d_op->d_automount)\n\t\treturn -EREMOTE;\n\n\t/* We don't want to mount if someone's just doing a stat -\n\t * unless they're stat'ing a directory and appended a '/' to\n\t * the name.\n\t *\n\t * We do, however, want to mount if someone wants to open or\n\t * create a file of any type under the mountpoint, wants to\n\t * traverse through the mountpoint or wants to open the\n\t * mounted directory.  Also, autofs may mark negative dentries\n\t * as being automount points.  These will need the attentions\n\t * of the daemon to instantiate them before they can be used.\n\t */\n\tif (!(nd->flags & (LOOKUP_PARENT | LOOKUP_DIRECTORY |\n\t\t\t   LOOKUP_OPEN | LOOKUP_CREATE | LOOKUP_AUTOMOUNT)) &&\n\t    path->dentry->d_inode)\n\t\treturn -EISDIR;\n\n\tnd->total_link_count++;\n\tif (nd->total_link_count >= 40)\n\t\treturn -ELOOP;\n\n\tmnt = path->dentry->d_op->d_automount(path);\n\tif (IS_ERR(mnt)) {\n\t\t/*\n\t\t * The filesystem is allowed to return -EISDIR here to indicate\n\t\t * it doesn't want to automount.  For instance, autofs would do\n\t\t * this so that its userspace daemon can mount on this dentry.\n\t\t *\n\t\t * However, we can only permit this if it's a terminal point in\n\t\t * the path being looked up; if it wasn't then the remainder of\n\t\t * the path is inaccessible and we should say so.\n\t\t */\n\t\tif (PTR_ERR(mnt) == -EISDIR && (nd->flags & LOOKUP_PARENT))\n\t\t\treturn -EREMOTE;\n\t\treturn PTR_ERR(mnt);\n\t}\n\n\tif (!mnt) /* mount collision */\n\t\treturn 0;\n\n\tif (!*need_mntput) {\n\t\t/* lock_mount() may release path->mnt on error */\n\t\tmntget(path->mnt);\n\t\t*need_mntput = true;\n\t}\n\terr = finish_automount(mnt, path);\n\n\tswitch (err) {\n\tcase -EBUSY:\n\t\t/* Someone else made a mount here whilst we were busy */\n\t\treturn 0;\n\tcase 0:\n\t\tpath_put(path);\n\t\tpath->mnt = mnt;\n\t\tpath->dentry = dget(mnt->mnt_root);\n\t\treturn 0;\n\tdefault:\n\t\treturn err;\n\t}\n\n}\n\n/*\n * Handle a dentry that is managed in some way.\n * - Flagged for transit management (autofs)\n * - Flagged as mountpoint\n * - Flagged as automount point\n *\n * This may only be called in refwalk mode.\n * On success path->dentry is known positive.\n *\n * Serialization is taken care of in namespace.c\n */\nstatic int follow_managed(struct path *path, struct nameidata *nd)\n{\n\tstruct vfsmount *mnt = path->mnt; /* held by caller, must be left alone */\n\tunsigned flags;\n\tbool need_mntput = false;\n\tint ret = 0;\n\n\t/* Given that we're not holding a lock here, we retain the value in a\n\t * local variable for each dentry as we look at it so that we don't see\n\t * the components of that value change under us */\n\twhile (flags = smp_load_acquire(&path->dentry->d_flags),\n\t       unlikely(flags & DCACHE_MANAGED_DENTRY)) {\n\t\t/* Allow the filesystem to manage the transit without i_mutex\n\t\t * being held. */\n\t\tif (flags & DCACHE_MANAGE_TRANSIT) {\n\t\t\tBUG_ON(!path->dentry->d_op);\n\t\t\tBUG_ON(!path->dentry->d_op->d_manage);\n\t\t\tret = path->dentry->d_op->d_manage(path, false);\n\t\t\tflags = smp_load_acquire(&path->dentry->d_flags);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Transit to a mounted filesystem. */\n\t\tif (flags & DCACHE_MOUNTED) {\n\t\t\tstruct vfsmount *mounted = lookup_mnt(path);\n\t\t\tif (mounted) {\n\t\t\t\tdput(path->dentry);\n\t\t\t\tif (need_mntput)\n\t\t\t\t\tmntput(path->mnt);\n\t\t\t\tpath->mnt = mounted;\n\t\t\t\tpath->dentry = dget(mounted->mnt_root);\n\t\t\t\tneed_mntput = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Something is mounted on this dentry in another\n\t\t\t * namespace and/or whatever was mounted there in this\n\t\t\t * namespace got unmounted before lookup_mnt() could\n\t\t\t * get it */\n\t\t}\n\n\t\t/* Handle an automount point */\n\t\tif (flags & DCACHE_NEED_AUTOMOUNT) {\n\t\t\tret = follow_automount(path, nd, &need_mntput);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We didn't change the current path point */\n\t\tbreak;\n\t}\n\n\tif (need_mntput && path->mnt == mnt)\n\t\tmntput(path->mnt);\n\tif (need_mntput)\n\t\tnd->flags |= LOOKUP_JUMPED;\n\tif (ret == -EISDIR || !ret)\n\t\tret = 1;\n\tif (ret > 0 && unlikely(d_flags_negative(flags)))\n\t\tret = -ENOENT;\n\tif (unlikely(ret < 0))\n\t\tpath_put_conditional(path, nd);\n\treturn ret;\n}\n\nint follow_down_one(struct path *path)\n{\n\tstruct vfsmount *mounted;\n\n\tmounted = lookup_mnt(path);\n\tif (mounted) {\n\t\tdput(path->dentry);\n\t\tmntput(path->mnt);\n\t\tpath->mnt = mounted;\n\t\tpath->dentry = dget(mounted->mnt_root);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(follow_down_one);\n\nstatic inline int managed_dentry_rcu(const struct path *path)\n{\n\treturn (path->dentry->d_flags & DCACHE_MANAGE_TRANSIT) ?\n\t\tpath->dentry->d_op->d_manage(path, true) : 0;\n}\n\n/*\n * Try to skip to top of mountpoint pile in rcuwalk mode.  Fail if\n * we meet a managed dentry that would need blocking.\n */\nstatic bool __follow_mount_rcu(struct nameidata *nd, struct path *path,\n\t\t\t       struct inode **inode, unsigned *seqp)\n{\n\tfor (;;) {\n\t\tstruct mount *mounted;\n\t\t/*\n\t\t * Don't forget we might have a non-mountpoint managed dentry\n\t\t * that wants to block transit.\n\t\t */\n\t\tswitch (managed_dentry_rcu(path)) {\n\t\tcase -ECHILD:\n\t\tdefault:\n\t\t\treturn false;\n\t\tcase -EISDIR:\n\t\t\treturn true;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!d_mountpoint(path->dentry))\n\t\t\treturn !(path->dentry->d_flags & DCACHE_NEED_AUTOMOUNT);\n\n\t\tmounted = __lookup_mnt(path->mnt, path->dentry);\n\t\tif (!mounted)\n\t\t\tbreak;\n\t\tpath->mnt = &mounted->mnt;\n\t\tpath->dentry = mounted->mnt.mnt_root;\n\t\tnd->flags |= LOOKUP_JUMPED;\n\t\t*seqp = read_seqcount_begin(&path->dentry->d_seq);\n\t\t/*\n\t\t * Update the inode too. We don't need to re-check the\n\t\t * dentry sequence number here after this d_inode read,\n\t\t * because a mount-point is always pinned.\n\t\t */\n\t\t*inode = path->dentry->d_inode;\n\t}\n\treturn !read_seqretry(&mount_lock, nd->m_seq) &&\n\t\t!(path->dentry->d_flags & DCACHE_NEED_AUTOMOUNT);\n}\n\nstatic int follow_dotdot_rcu(struct nameidata *nd)\n{\n\tstruct inode *inode = nd->inode;\n\n\twhile (1) {\n\t\tif (path_equal(&nd->path, &nd->root))\n\t\t\tbreak;\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\tstruct dentry *old = nd->path.dentry;\n\t\t\tstruct dentry *parent = old->d_parent;\n\t\t\tunsigned seq;\n\n\t\t\tinode = parent->d_inode;\n\t\t\tseq = read_seqcount_begin(&parent->d_seq);\n\t\t\tif (unlikely(read_seqcount_retry(&old->d_seq, nd->seq)))\n\t\t\t\treturn -ECHILD;\n\t\t\tnd->path.dentry = parent;\n\t\t\tnd->seq = seq;\n\t\t\tif (unlikely(!path_connected(&nd->path)))\n\t\t\t\treturn -ENOENT;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tstruct mount *mnt = real_mount(nd->path.mnt);\n\t\t\tstruct mount *mparent = mnt->mnt_parent;\n\t\t\tstruct dentry *mountpoint = mnt->mnt_mountpoint;\n\t\t\tstruct inode *inode2 = mountpoint->d_inode;\n\t\t\tunsigned seq = read_seqcount_begin(&mountpoint->d_seq);\n\t\t\tif (unlikely(read_seqretry(&mount_lock, nd->m_seq)))\n\t\t\t\treturn -ECHILD;\n\t\t\tif (&mparent->mnt == nd->path.mnt)\n\t\t\t\tbreak;\n\t\t\t/* we know that mountpoint was pinned */\n\t\t\tnd->path.dentry = mountpoint;\n\t\t\tnd->path.mnt = &mparent->mnt;\n\t\t\tinode = inode2;\n\t\t\tnd->seq = seq;\n\t\t}\n\t}\n\twhile (unlikely(d_mountpoint(nd->path.dentry))) {\n\t\tstruct mount *mounted;\n\t\tmounted = __lookup_mnt(nd->path.mnt, nd->path.dentry);\n\t\tif (unlikely(read_seqretry(&mount_lock, nd->m_seq)))\n\t\t\treturn -ECHILD;\n\t\tif (!mounted)\n\t\t\tbreak;\n\t\tnd->path.mnt = &mounted->mnt;\n\t\tnd->path.dentry = mounted->mnt.mnt_root;\n\t\tinode = nd->path.dentry->d_inode;\n\t\tnd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);\n\t}\n\tnd->inode = inode;\n\treturn 0;\n}\n\n/*\n * Follow down to the covering mount currently visible to userspace.  At each\n * point, the filesystem owning that dentry may be queried as to whether the\n * caller is permitted to proceed or not.\n */\nint follow_down(struct path *path)\n{\n\tunsigned managed;\n\tint ret;\n\n\twhile (managed = READ_ONCE(path->dentry->d_flags),\n\t       unlikely(managed & DCACHE_MANAGED_DENTRY)) {\n\t\t/* Allow the filesystem to manage the transit without i_mutex\n\t\t * being held.\n\t\t *\n\t\t * We indicate to the filesystem if someone is trying to mount\n\t\t * something here.  This gives autofs the chance to deny anyone\n\t\t * other than its daemon the right to mount on its\n\t\t * superstructure.\n\t\t *\n\t\t * The filesystem may sleep at this point.\n\t\t */\n\t\tif (managed & DCACHE_MANAGE_TRANSIT) {\n\t\t\tBUG_ON(!path->dentry->d_op);\n\t\t\tBUG_ON(!path->dentry->d_op->d_manage);\n\t\t\tret = path->dentry->d_op->d_manage(path, false);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret == -EISDIR ? 0 : ret;\n\t\t}\n\n\t\t/* Transit to a mounted filesystem. */\n\t\tif (managed & DCACHE_MOUNTED) {\n\t\t\tstruct vfsmount *mounted = lookup_mnt(path);\n\t\t\tif (!mounted)\n\t\t\t\tbreak;\n\t\t\tdput(path->dentry);\n\t\t\tmntput(path->mnt);\n\t\t\tpath->mnt = mounted;\n\t\t\tpath->dentry = dget(mounted->mnt_root);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Don't handle automount points here */\n\t\tbreak;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(follow_down);\n\n/*\n * Skip to top of mountpoint pile in refwalk mode for follow_dotdot()\n */\nstatic void follow_mount(struct path *path)\n{\n\twhile (d_mountpoint(path->dentry)) {\n\t\tstruct vfsmount *mounted = lookup_mnt(path);\n\t\tif (!mounted)\n\t\t\tbreak;\n\t\tdput(path->dentry);\n\t\tmntput(path->mnt);\n\t\tpath->mnt = mounted;\n\t\tpath->dentry = dget(mounted->mnt_root);\n\t}\n}\n\nstatic int path_parent_directory(struct path *path)\n{\n\tstruct dentry *old = path->dentry;\n\t/* rare case of legitimate dget_parent()... */\n\tpath->dentry = dget_parent(path->dentry);\n\tdput(old);\n\tif (unlikely(!path_connected(path)))\n\t\treturn -ENOENT;\n\treturn 0;\n}\n\nstatic int follow_dotdot(struct nameidata *nd)\n{\n\twhile(1) {\n\t\tif (path_equal(&nd->path, &nd->root))\n\t\t\tbreak;\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\tint ret = path_parent_directory(&nd->path);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\t}\n\t\tif (!follow_up(&nd->path))\n\t\t\tbreak;\n\t}\n\tfollow_mount(&nd->path);\n\tnd->inode = nd->path.dentry->d_inode;\n\treturn 0;\n}\n\n/*\n * This looks up the name in dcache and possibly revalidates the found dentry.\n * NULL is returned if the dentry does not exist in the cache.\n */\nstatic struct dentry *lookup_dcache(const struct qstr *name,\n\t\t\t\t    struct dentry *dir,\n\t\t\t\t    unsigned int flags)\n{\n\tstruct dentry *dentry = d_lookup(dir, name);\n\tif (dentry) {\n\t\tint error = d_revalidate(dentry, flags);\n\t\tif (unlikely(error <= 0)) {\n\t\t\tif (!error)\n\t\t\t\td_invalidate(dentry);\n\t\t\tdput(dentry);\n\t\t\treturn ERR_PTR(error);\n\t\t}\n\t}\n\treturn dentry;\n}\n\n/*\n * Parent directory has inode locked exclusive.  This is one\n * and only case when ->lookup() gets called on non in-lookup\n * dentries - as the matter of fact, this only gets called\n * when directory is guaranteed to have no in-lookup children\n * at all.\n */\nstatic struct dentry *__lookup_hash(const struct qstr *name,\n\t\tstruct dentry *base, unsigned int flags)\n{\n\tstruct dentry *dentry = lookup_dcache(name, base, flags);\n\tstruct dentry *old;\n\tstruct inode *dir = base->d_inode;\n\n\tif (dentry)\n\t\treturn dentry;\n\n\t/* Don't create child dentry for a dead directory. */\n\tif (unlikely(IS_DEADDIR(dir)))\n\t\treturn ERR_PTR(-ENOENT);\n\n\tdentry = d_alloc(base, name);\n\tif (unlikely(!dentry))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\told = dir->i_op->lookup(dir, dentry, flags);\n\tif (unlikely(old)) {\n\t\tdput(dentry);\n\t\tdentry = old;\n\t}\n\treturn dentry;\n}\n\nstatic int lookup_fast(struct nameidata *nd,\n\t\t       struct path *path, struct inode **inode,\n\t\t       unsigned *seqp)\n{\n\tstruct vfsmount *mnt = nd->path.mnt;\n\tstruct dentry *dentry, *parent = nd->path.dentry;\n\tint status = 1;\n\tint err;\n\n\t/*\n\t * Rename seqlock is not required here because in the off chance\n\t * of a false negative due to a concurrent rename, the caller is\n\t * going to fall back to non-racy lookup.\n\t */\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tunsigned seq;\n\t\tbool negative;\n\t\tdentry = __d_lookup_rcu(parent, &nd->last, &seq);\n\t\tif (unlikely(!dentry)) {\n\t\t\tif (unlazy_walk(nd))\n\t\t\t\treturn -ECHILD;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * This sequence count validates that the inode matches\n\t\t * the dentry name information from lookup.\n\t\t */\n\t\t*inode = d_backing_inode(dentry);\n\t\tnegative = d_is_negative(dentry);\n\t\tif (unlikely(read_seqcount_retry(&dentry->d_seq, seq)))\n\t\t\treturn -ECHILD;\n\n\t\t/*\n\t\t * This sequence count validates that the parent had no\n\t\t * changes while we did the lookup of the dentry above.\n\t\t *\n\t\t * The memory barrier in read_seqcount_begin of child is\n\t\t *  enough, we can use __read_seqcount_retry here.\n\t\t */\n\t\tif (unlikely(__read_seqcount_retry(&parent->d_seq, nd->seq)))\n\t\t\treturn -ECHILD;\n\n\t\t*seqp = seq;\n\t\tstatus = d_revalidate(dentry, nd->flags);\n\t\tif (likely(status > 0)) {\n\t\t\t/*\n\t\t\t * Note: do negative dentry check after revalidation in\n\t\t\t * case that drops it.\n\t\t\t */\n\t\t\tif (unlikely(negative))\n\t\t\t\treturn -ENOENT;\n\t\t\tpath->mnt = mnt;\n\t\t\tpath->dentry = dentry;\n\t\t\tif (likely(__follow_mount_rcu(nd, path, inode, seqp)))\n\t\t\t\treturn 1;\n\t\t}\n\t\tif (unlazy_child(nd, dentry, seq))\n\t\t\treturn -ECHILD;\n\t\tif (unlikely(status == -ECHILD))\n\t\t\t/* we'd been told to redo it in non-rcu mode */\n\t\t\tstatus = d_revalidate(dentry, nd->flags);\n\t} else {\n\t\tdentry = __d_lookup(parent, &nd->last);\n\t\tif (unlikely(!dentry))\n\t\t\treturn 0;\n\t\tstatus = d_revalidate(dentry, nd->flags);\n\t}\n\tif (unlikely(status <= 0)) {\n\t\tif (!status)\n\t\t\td_invalidate(dentry);\n\t\tdput(dentry);\n\t\treturn status;\n\t}\n\n\tpath->mnt = mnt;\n\tpath->dentry = dentry;\n\terr = follow_managed(path, nd);\n\tif (likely(err > 0))\n\t\t*inode = d_backing_inode(path->dentry);\n\treturn err;\n}\n\n/* Fast lookup failed, do it the slow way */\nstatic struct dentry *__lookup_slow(const struct qstr *name,\n\t\t\t\t    struct dentry *dir,\n\t\t\t\t    unsigned int flags)\n{\n\tstruct dentry *dentry, *old;\n\tstruct inode *inode = dir->d_inode;\n\tDECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);\n\n\t/* Don't go there if it's already dead */\n\tif (unlikely(IS_DEADDIR(inode)))\n\t\treturn ERR_PTR(-ENOENT);\nagain:\n\tdentry = d_alloc_parallel(dir, name, &wq);\n\tif (IS_ERR(dentry))\n\t\treturn dentry;\n\tif (unlikely(!d_in_lookup(dentry))) {\n\t\tint error = d_revalidate(dentry, flags);\n\t\tif (unlikely(error <= 0)) {\n\t\t\tif (!error) {\n\t\t\t\td_invalidate(dentry);\n\t\t\t\tdput(dentry);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tdput(dentry);\n\t\t\tdentry = ERR_PTR(error);\n\t\t}\n\t} else {\n\t\told = inode->i_op->lookup(inode, dentry, flags);\n\t\td_lookup_done(dentry);\n\t\tif (unlikely(old)) {\n\t\t\tdput(dentry);\n\t\t\tdentry = old;\n\t\t}\n\t}\n\treturn dentry;\n}\n\nstatic struct dentry *lookup_slow(const struct qstr *name,\n\t\t\t\t  struct dentry *dir,\n\t\t\t\t  unsigned int flags)\n{\n\tstruct inode *inode = dir->d_inode;\n\tstruct dentry *res;\n\tinode_lock_shared(inode);\n\tres = __lookup_slow(name, dir, flags);\n\tinode_unlock_shared(inode);\n\treturn res;\n}\n\nstatic inline int may_lookup(struct nameidata *nd)\n{\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tint err = inode_permission(nd->inode, MAY_EXEC|MAY_NOT_BLOCK);\n\t\tif (err != -ECHILD)\n\t\t\treturn err;\n\t\tif (unlazy_walk(nd))\n\t\t\treturn -ECHILD;\n\t}\n\treturn inode_permission(nd->inode, MAY_EXEC);\n}\n\nstatic inline int handle_dots(struct nameidata *nd, int type)\n{\n\tif (type == LAST_DOTDOT) {\n\t\tif (!nd->root.mnt)\n\t\t\tset_root(nd);\n\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\treturn follow_dotdot_rcu(nd);\n\t\t} else\n\t\t\treturn follow_dotdot(nd);\n\t}\n\treturn 0;\n}\n\nstatic int pick_link(struct nameidata *nd, struct path *link,\n\t\t     struct inode *inode, unsigned seq)\n{\n\tint error;\n\tstruct saved *last;\n\tif (unlikely(nd->total_link_count++ >= MAXSYMLINKS)) {\n\t\tpath_to_nameidata(link, nd);\n\t\treturn -ELOOP;\n\t}\n\tif (!(nd->flags & LOOKUP_RCU)) {\n\t\tif (link->mnt == nd->path.mnt)\n\t\t\tmntget(link->mnt);\n\t}\n\terror = nd_alloc_stack(nd);\n\tif (unlikely(error)) {\n\t\tif (error == -ECHILD) {\n\t\t\tif (unlikely(!legitimize_path(nd, link, seq))) {\n\t\t\t\tdrop_links(nd);\n\t\t\t\tnd->depth = 0;\n\t\t\t\tnd->flags &= ~LOOKUP_RCU;\n\t\t\t\tnd->path.mnt = NULL;\n\t\t\t\tnd->path.dentry = NULL;\n\t\t\t\trcu_read_unlock();\n\t\t\t} else if (likely(unlazy_walk(nd)) == 0)\n\t\t\t\terror = nd_alloc_stack(nd);\n\t\t}\n\t\tif (error) {\n\t\t\tpath_put(link);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tlast = nd->stack + nd->depth++;\n\tlast->link = *link;\n\tclear_delayed_call(&last->done);\n\tnd->link_inode = inode;\n\tlast->seq = seq;\n\treturn 1;\n}\n\nenum {WALK_FOLLOW = 1, WALK_MORE = 2};\n\n/*\n * Do we need to follow links? We _really_ want to be able\n * to do this check without having to look at inode->i_op,\n * so we keep a cache of \"no, this doesn't need follow_link\"\n * for the common case.\n */\nstatic inline int step_into(struct nameidata *nd, struct path *path,\n\t\t\t    int flags, struct inode *inode, unsigned seq)\n{\n\tif (!(flags & WALK_MORE) && nd->depth)\n\t\tput_link(nd);\n\tif (likely(!d_is_symlink(path->dentry)) ||\n\t   !(flags & WALK_FOLLOW || nd->flags & LOOKUP_FOLLOW)) {\n\t\t/* not a symlink or should not follow */\n\t\tpath_to_nameidata(path, nd);\n\t\tnd->inode = inode;\n\t\tnd->seq = seq;\n\t\treturn 0;\n\t}\n\t/* make sure that d_is_symlink above matches inode */\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tif (read_seqcount_retry(&path->dentry->d_seq, seq))\n\t\t\treturn -ECHILD;\n\t}\n\treturn pick_link(nd, path, inode, seq);\n}\n\nstatic int walk_component(struct nameidata *nd, int flags)\n{\n\tstruct path path;\n\tstruct inode *inode;\n\tunsigned seq;\n\tint err;\n\t/*\n\t * \".\" and \"..\" are special - \"..\" especially so because it has\n\t * to be able to know about the current root directory and\n\t * parent relationships.\n\t */\n\tif (unlikely(nd->last_type != LAST_NORM)) {\n\t\terr = handle_dots(nd, nd->last_type);\n\t\tif (!(flags & WALK_MORE) && nd->depth)\n\t\t\tput_link(nd);\n\t\treturn err;\n\t}\n\terr = lookup_fast(nd, &path, &inode, &seq);\n\tif (unlikely(err <= 0)) {\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tpath.dentry = lookup_slow(&nd->last, nd->path.dentry,\n\t\t\t\t\t  nd->flags);\n\t\tif (IS_ERR(path.dentry))\n\t\t\treturn PTR_ERR(path.dentry);\n\n\t\tpath.mnt = nd->path.mnt;\n\t\terr = follow_managed(&path, nd);\n\t\tif (unlikely(err < 0))\n\t\t\treturn err;\n\n\t\tseq = 0;\t/* we are already out of RCU mode */\n\t\tinode = d_backing_inode(path.dentry);\n\t}\n\n\treturn step_into(nd, &path, flags, inode, seq);\n}\n\n/*\n * We can do the critical dentry name comparison and hashing\n * operations one word at a time, but we are limited to:\n *\n * - Architectures with fast unaligned word accesses. We could\n *   do a \"get_unaligned()\" if this helps and is sufficiently\n *   fast.\n *\n * - non-CONFIG_DEBUG_PAGEALLOC configurations (so that we\n *   do not trap on the (extremely unlikely) case of a page\n *   crossing operation.\n *\n * - Furthermore, we need an efficient 64-bit compile for the\n *   64-bit case in order to generate the \"number of bytes in\n *   the final mask\". Again, that could be replaced with a\n *   efficient population count instruction or similar.\n */\n#ifdef CONFIG_DCACHE_WORD_ACCESS\n\n#include <asm/word-at-a-time.h>\n\n#ifdef HASH_MIX\n\n/* Architecture provides HASH_MIX and fold_hash() in <asm/hash.h> */\n\n#elif defined(CONFIG_64BIT)\n/*\n * Register pressure in the mixing function is an issue, particularly\n * on 32-bit x86, but almost any function requires one state value and\n * one temporary.  Instead, use a function designed for two state values\n * and no temporaries.\n *\n * This function cannot create a collision in only two iterations, so\n * we have two iterations to achieve avalanche.  In those two iterations,\n * we have six layers of mixing, which is enough to spread one bit's\n * influence out to 2^6 = 64 state bits.\n *\n * Rotate constants are scored by considering either 64 one-bit input\n * deltas or 64*63/2 = 2016 two-bit input deltas, and finding the\n * probability of that delta causing a change to each of the 128 output\n * bits, using a sample of random initial states.\n *\n * The Shannon entropy of the computed probabilities is then summed\n * to produce a score.  Ideally, any input change has a 50% chance of\n * toggling any given output bit.\n *\n * Mixing scores (in bits) for (12,45):\n * Input delta: 1-bit      2-bit\n * 1 round:     713.3    42542.6\n * 2 rounds:   2753.7   140389.8\n * 3 rounds:   5954.1   233458.2\n * 4 rounds:   7862.6   256672.2\n * Perfect:    8192     258048\n *            (64*128) (64*63/2 * 128)\n */\n#define HASH_MIX(x, y, a)\t\\\n\t(\tx ^= (a),\t\\\n\ty ^= x,\tx = rol64(x,12),\\\n\tx += y,\ty = rol64(y,45),\\\n\ty *= 9\t\t\t)\n\n/*\n * Fold two longs into one 32-bit hash value.  This must be fast, but\n * latency isn't quite as critical, as there is a fair bit of additional\n * work done before the hash value is used.\n */\nstatic inline unsigned int fold_hash(unsigned long x, unsigned long y)\n{\n\ty ^= x * GOLDEN_RATIO_64;\n\ty *= GOLDEN_RATIO_64;\n\treturn y >> 32;\n}\n\n#else\t/* 32-bit case */\n\n/*\n * Mixing scores (in bits) for (7,20):\n * Input delta: 1-bit      2-bit\n * 1 round:     330.3     9201.6\n * 2 rounds:   1246.4    25475.4\n * 3 rounds:   1907.1    31295.1\n * 4 rounds:   2042.3    31718.6\n * Perfect:    2048      31744\n *            (32*64)   (32*31/2 * 64)\n */\n#define HASH_MIX(x, y, a)\t\\\n\t(\tx ^= (a),\t\\\n\ty ^= x,\tx = rol32(x, 7),\\\n\tx += y,\ty = rol32(y,20),\\\n\ty *= 9\t\t\t)\n\nstatic inline unsigned int fold_hash(unsigned long x, unsigned long y)\n{\n\t/* Use arch-optimized multiply if one exists */\n\treturn __hash_32(y ^ __hash_32(x));\n}\n\n#endif\n\n/*\n * Return the hash of a string of known length.  This is carfully\n * designed to match hash_name(), which is the more critical function.\n * In particular, we must end by hashing a final word containing 0..7\n * payload bytes, to match the way that hash_name() iterates until it\n * finds the delimiter after the name.\n */\nunsigned int full_name_hash(const void *salt, const char *name, unsigned int len)\n{\n\tunsigned long a, x = 0, y = (unsigned long)salt;\n\n\tfor (;;) {\n\t\tif (!len)\n\t\t\tgoto done;\n\t\ta = load_unaligned_zeropad(name);\n\t\tif (len < sizeof(unsigned long))\n\t\t\tbreak;\n\t\tHASH_MIX(x, y, a);\n\t\tname += sizeof(unsigned long);\n\t\tlen -= sizeof(unsigned long);\n\t}\n\tx ^= a & bytemask_from_count(len);\ndone:\n\treturn fold_hash(x, y);\n}\nEXPORT_SYMBOL(full_name_hash);\n\n/* Return the \"hash_len\" (hash and length) of a null-terminated string */\nu64 hashlen_string(const void *salt, const char *name)\n{\n\tunsigned long a = 0, x = 0, y = (unsigned long)salt;\n\tunsigned long adata, mask, len;\n\tconst struct word_at_a_time constants = WORD_AT_A_TIME_CONSTANTS;\n\n\tlen = 0;\n\tgoto inside;\n\n\tdo {\n\t\tHASH_MIX(x, y, a);\n\t\tlen += sizeof(unsigned long);\ninside:\n\t\ta = load_unaligned_zeropad(name+len);\n\t} while (!has_zero(a, &adata, &constants));\n\n\tadata = prep_zero_mask(a, adata, &constants);\n\tmask = create_zero_mask(adata);\n\tx ^= a & zero_bytemask(mask);\n\n\treturn hashlen_create(fold_hash(x, y), len + find_zero(mask));\n}\nEXPORT_SYMBOL(hashlen_string);\n\n/*\n * Calculate the length and hash of the path component, and\n * return the \"hash_len\" as the result.\n */\nstatic inline u64 hash_name(const void *salt, const char *name)\n{\n\tunsigned long a = 0, b, x = 0, y = (unsigned long)salt;\n\tunsigned long adata, bdata, mask, len;\n\tconst struct word_at_a_time constants = WORD_AT_A_TIME_CONSTANTS;\n\n\tlen = 0;\n\tgoto inside;\n\n\tdo {\n\t\tHASH_MIX(x, y, a);\n\t\tlen += sizeof(unsigned long);\ninside:\n\t\ta = load_unaligned_zeropad(name+len);\n\t\tb = a ^ REPEAT_BYTE('/');\n\t} while (!(has_zero(a, &adata, &constants) | has_zero(b, &bdata, &constants)));\n\n\tadata = prep_zero_mask(a, adata, &constants);\n\tbdata = prep_zero_mask(b, bdata, &constants);\n\tmask = create_zero_mask(adata | bdata);\n\tx ^= a & zero_bytemask(mask);\n\n\treturn hashlen_create(fold_hash(x, y), len + find_zero(mask));\n}\n\n#else\t/* !CONFIG_DCACHE_WORD_ACCESS: Slow, byte-at-a-time version */\n\n/* Return the hash of a string of known length */\nunsigned int full_name_hash(const void *salt, const char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash(salt);\n\twhile (len--)\n\t\thash = partial_name_hash((unsigned char)*name++, hash);\n\treturn end_name_hash(hash);\n}\nEXPORT_SYMBOL(full_name_hash);\n\n/* Return the \"hash_len\" (hash and length) of a null-terminated string */\nu64 hashlen_string(const void *salt, const char *name)\n{\n\tunsigned long hash = init_name_hash(salt);\n\tunsigned long len = 0, c;\n\n\tc = (unsigned char)*name;\n\twhile (c) {\n\t\tlen++;\n\t\thash = partial_name_hash(c, hash);\n\t\tc = (unsigned char)name[len];\n\t}\n\treturn hashlen_create(end_name_hash(hash), len);\n}\nEXPORT_SYMBOL(hashlen_string);\n\n/*\n * We know there's a real path component here of at least\n * one character.\n */\nstatic inline u64 hash_name(const void *salt, const char *name)\n{\n\tunsigned long hash = init_name_hash(salt);\n\tunsigned long len = 0, c;\n\n\tc = (unsigned char)*name;\n\tdo {\n\t\tlen++;\n\t\thash = partial_name_hash(c, hash);\n\t\tc = (unsigned char)name[len];\n\t} while (c && c != '/');\n\treturn hashlen_create(end_name_hash(hash), len);\n}\n\n#endif\n\n/*\n * Name resolution.\n * This is the basic name resolution function, turning a pathname into\n * the final dentry. We expect 'base' to be positive and a directory.\n *\n * Returns 0 and nd will have valid dentry and mnt on success.\n * Returns error and drops reference to input namei data on failure.\n */\nstatic int link_path_walk(const char *name, struct nameidata *nd)\n{\n\tint err;\n\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\twhile (*name=='/')\n\t\tname++;\n\tif (!*name)\n\t\treturn 0;\n\n\t/* At this point we know we have a real path component. */\n\tfor(;;) {\n\t\tu64 hash_len;\n\t\tint type;\n\n\t\terr = may_lookup(nd);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\thash_len = hash_name(nd->path.dentry, name);\n\n\t\ttype = LAST_NORM;\n\t\tif (name[0] == '.') switch (hashlen_len(hash_len)) {\n\t\t\tcase 2:\n\t\t\t\tif (name[1] == '.') {\n\t\t\t\t\ttype = LAST_DOTDOT;\n\t\t\t\t\tnd->flags |= LOOKUP_JUMPED;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\ttype = LAST_DOT;\n\t\t}\n\t\tif (likely(type == LAST_NORM)) {\n\t\t\tstruct dentry *parent = nd->path.dentry;\n\t\t\tnd->flags &= ~LOOKUP_JUMPED;\n\t\t\tif (unlikely(parent->d_flags & DCACHE_OP_HASH)) {\n\t\t\t\tstruct qstr this = { { .hash_len = hash_len }, .name = name };\n\t\t\t\terr = parent->d_op->d_hash(parent, &this);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t\thash_len = this.hash_len;\n\t\t\t\tname = this.name;\n\t\t\t}\n\t\t}\n\n\t\tnd->last.hash_len = hash_len;\n\t\tnd->last.name = name;\n\t\tnd->last_type = type;\n\n\t\tname += hashlen_len(hash_len);\n\t\tif (!*name)\n\t\t\tgoto OK;\n\t\t/*\n\t\t * If it wasn't NUL, we know it was '/'. Skip that\n\t\t * slash, and continue until no more slashes.\n\t\t */\n\t\tdo {\n\t\t\tname++;\n\t\t} while (unlikely(*name == '/'));\n\t\tif (unlikely(!*name)) {\nOK:\n\t\t\t/* pathname body, done */\n\t\t\tif (!nd->depth)\n\t\t\t\treturn 0;\n\t\t\tname = nd->stack[nd->depth - 1].name;\n\t\t\t/* trailing symlink, done */\n\t\t\tif (!name)\n\t\t\t\treturn 0;\n\t\t\t/* last component of nested symlink */\n\t\t\terr = walk_component(nd, WALK_FOLLOW);\n\t\t} else {\n\t\t\t/* not the last component */\n\t\t\terr = walk_component(nd, WALK_FOLLOW | WALK_MORE);\n\t\t}\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (err) {\n\t\t\tconst char *s = get_link(nd);\n\n\t\t\tif (IS_ERR(s))\n\t\t\t\treturn PTR_ERR(s);\n\t\t\terr = 0;\n\t\t\tif (unlikely(!s)) {\n\t\t\t\t/* jumped */\n\t\t\t\tput_link(nd);\n\t\t\t} else {\n\t\t\t\tnd->stack[nd->depth - 1].name = name;\n\t\t\t\tname = s;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (unlikely(!d_can_lookup(nd->path.dentry))) {\n\t\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\t\tif (unlazy_walk(nd))\n\t\t\t\t\treturn -ECHILD;\n\t\t\t}\n\t\t\treturn -ENOTDIR;\n\t\t}\n\t}\n}\n\n/* must be paired with terminate_walk() */\nstatic const char *path_init(struct nameidata *nd, unsigned flags)\n{\n\tconst char *s = nd->name->name;\n\n\tif (!*s)\n\t\tflags &= ~LOOKUP_RCU;\n\tif (flags & LOOKUP_RCU)\n\t\trcu_read_lock();\n\n\tnd->last_type = LAST_ROOT; /* if there are only slashes... */\n\tnd->flags = flags | LOOKUP_JUMPED | LOOKUP_PARENT;\n\tnd->depth = 0;\n\tif (flags & LOOKUP_ROOT) {\n\t\tstruct dentry *root = nd->root.dentry;\n\t\tstruct inode *inode = root->d_inode;\n\t\tif (*s && unlikely(!d_can_lookup(root)))\n\t\t\treturn ERR_PTR(-ENOTDIR);\n\t\tnd->path = nd->root;\n\t\tnd->inode = inode;\n\t\tif (flags & LOOKUP_RCU) {\n\t\t\tnd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);\n\t\t\tnd->root_seq = nd->seq;\n\t\t\tnd->m_seq = read_seqbegin(&mount_lock);\n\t\t} else {\n\t\t\tpath_get(&nd->path);\n\t\t}\n\t\treturn s;\n\t}\n\n\tnd->root.mnt = NULL;\n\tnd->path.mnt = NULL;\n\tnd->path.dentry = NULL;\n\n\tnd->m_seq = read_seqbegin(&mount_lock);\n\tif (*s == '/') {\n\t\tset_root(nd);\n\t\tif (likely(!nd_jump_root(nd)))\n\t\t\treturn s;\n\t\treturn ERR_PTR(-ECHILD);\n\t} else if (nd->dfd == AT_FDCWD) {\n\t\tif (flags & LOOKUP_RCU) {\n\t\t\tstruct fs_struct *fs = current->fs;\n\t\t\tunsigned seq;\n\n\t\t\tdo {\n\t\t\t\tseq = read_seqcount_begin(&fs->seq);\n\t\t\t\tnd->path = fs->pwd;\n\t\t\t\tnd->inode = nd->path.dentry->d_inode;\n\t\t\t\tnd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);\n\t\t\t} while (read_seqcount_retry(&fs->seq, seq));\n\t\t} else {\n\t\t\tget_fs_pwd(current->fs, &nd->path);\n\t\t\tnd->inode = nd->path.dentry->d_inode;\n\t\t}\n\t\treturn s;\n\t} else {\n\t\t/* Caller must check execute permissions on the starting path component */\n\t\tstruct fd f = fdget_raw(nd->dfd);\n\t\tstruct dentry *dentry;\n\n\t\tif (!f.file)\n\t\t\treturn ERR_PTR(-EBADF);\n\n\t\tdentry = f.file->f_path.dentry;\n\n\t\tif (*s && unlikely(!d_can_lookup(dentry))) {\n\t\t\tfdput(f);\n\t\t\treturn ERR_PTR(-ENOTDIR);\n\t\t}\n\n\t\tnd->path = f.file->f_path;\n\t\tif (flags & LOOKUP_RCU) {\n\t\t\tnd->inode = nd->path.dentry->d_inode;\n\t\t\tnd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);\n\t\t} else {\n\t\t\tpath_get(&nd->path);\n\t\t\tnd->inode = nd->path.dentry->d_inode;\n\t\t}\n\t\tfdput(f);\n\t\treturn s;\n\t}\n}\n\nstatic const char *trailing_symlink(struct nameidata *nd)\n{\n\tconst char *s;\n\tint error = may_follow_link(nd);\n\tif (unlikely(error))\n\t\treturn ERR_PTR(error);\n\tnd->flags |= LOOKUP_PARENT;\n\tnd->stack[0].name = NULL;\n\ts = get_link(nd);\n\treturn s ? s : \"\";\n}\n\nstatic inline int lookup_last(struct nameidata *nd)\n{\n\tif (nd->last_type == LAST_NORM && nd->last.name[nd->last.len])\n\t\tnd->flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY;\n\n\tnd->flags &= ~LOOKUP_PARENT;\n\treturn walk_component(nd, 0);\n}\n\nstatic int handle_lookup_down(struct nameidata *nd)\n{\n\tstruct path path = nd->path;\n\tstruct inode *inode = nd->inode;\n\tunsigned seq = nd->seq;\n\tint err;\n\n\tif (nd->flags & LOOKUP_RCU) {\n\t\t/*\n\t\t * don't bother with unlazy_walk on failure - we are\n\t\t * at the very beginning of walk, so we lose nothing\n\t\t * if we simply redo everything in non-RCU mode\n\t\t */\n\t\tif (unlikely(!__follow_mount_rcu(nd, &path, &inode, &seq)))\n\t\t\treturn -ECHILD;\n\t} else {\n\t\tdget(path.dentry);\n\t\terr = follow_managed(&path, nd);\n\t\tif (unlikely(err < 0))\n\t\t\treturn err;\n\t\tinode = d_backing_inode(path.dentry);\n\t\tseq = 0;\n\t}\n\tpath_to_nameidata(&path, nd);\n\tnd->inode = inode;\n\tnd->seq = seq;\n\treturn 0;\n}\n\n/* Returns 0 and nd will be valid on success; Retuns error, otherwise. */\nstatic int path_lookupat(struct nameidata *nd, unsigned flags, struct path *path)\n{\n\tconst char *s = path_init(nd, flags);\n\tint err;\n\n\tif (unlikely(flags & LOOKUP_DOWN) && !IS_ERR(s)) {\n\t\terr = handle_lookup_down(nd);\n\t\tif (unlikely(err < 0))\n\t\t\ts = ERR_PTR(err);\n\t}\n\n\twhile (!(err = link_path_walk(s, nd))\n\t\t&& ((err = lookup_last(nd)) > 0)) {\n\t\ts = trailing_symlink(nd);\n\t}\n\tif (!err)\n\t\terr = complete_walk(nd);\n\n\tif (!err && nd->flags & LOOKUP_DIRECTORY)\n\t\tif (!d_can_lookup(nd->path.dentry))\n\t\t\terr = -ENOTDIR;\n\tif (!err) {\n\t\t*path = nd->path;\n\t\tnd->path.mnt = NULL;\n\t\tnd->path.dentry = NULL;\n\t}\n\tterminate_walk(nd);\n\treturn err;\n}\n\nint filename_lookup(int dfd, struct filename *name, unsigned flags,\n\t\t    struct path *path, struct path *root)\n{\n\tint retval;\n\tstruct nameidata nd;\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\tif (unlikely(root)) {\n\t\tnd.root = *root;\n\t\tflags |= LOOKUP_ROOT;\n\t}\n\tset_nameidata(&nd, dfd, name);\n\tretval = path_lookupat(&nd, flags | LOOKUP_RCU, path);\n\tif (unlikely(retval == -ECHILD))\n\t\tretval = path_lookupat(&nd, flags, path);\n\tif (unlikely(retval == -ESTALE))\n\t\tretval = path_lookupat(&nd, flags | LOOKUP_REVAL, path);\n\n\tif (likely(!retval))\n\t\taudit_inode(name, path->dentry, 0);\n\trestore_nameidata();\n\tputname(name);\n\treturn retval;\n}\n\n/* Returns 0 and nd will be valid on success; Retuns error, otherwise. */\nstatic int path_parentat(struct nameidata *nd, unsigned flags,\n\t\t\t\tstruct path *parent)\n{\n\tconst char *s = path_init(nd, flags);\n\tint err = link_path_walk(s, nd);\n\tif (!err)\n\t\terr = complete_walk(nd);\n\tif (!err) {\n\t\t*parent = nd->path;\n\t\tnd->path.mnt = NULL;\n\t\tnd->path.dentry = NULL;\n\t}\n\tterminate_walk(nd);\n\treturn err;\n}\n\nstatic struct filename *filename_parentat(int dfd, struct filename *name,\n\t\t\t\tunsigned int flags, struct path *parent,\n\t\t\t\tstruct qstr *last, int *type)\n{\n\tint retval;\n\tstruct nameidata nd;\n\n\tif (IS_ERR(name))\n\t\treturn name;\n\tset_nameidata(&nd, dfd, name);\n\tretval = path_parentat(&nd, flags | LOOKUP_RCU, parent);\n\tif (unlikely(retval == -ECHILD))\n\t\tretval = path_parentat(&nd, flags, parent);\n\tif (unlikely(retval == -ESTALE))\n\t\tretval = path_parentat(&nd, flags | LOOKUP_REVAL, parent);\n\tif (likely(!retval)) {\n\t\t*last = nd.last;\n\t\t*type = nd.last_type;\n\t\taudit_inode(name, parent->dentry, AUDIT_INODE_PARENT);\n\t} else {\n\t\tputname(name);\n\t\tname = ERR_PTR(retval);\n\t}\n\trestore_nameidata();\n\treturn name;\n}\n\n/* does lookup, returns the object with parent locked */\nstruct dentry *kern_path_locked(const char *name, struct path *path)\n{\n\tstruct filename *filename;\n\tstruct dentry *d;\n\tstruct qstr last;\n\tint type;\n\n\tfilename = filename_parentat(AT_FDCWD, getname_kernel(name), 0, path,\n\t\t\t\t    &last, &type);\n\tif (IS_ERR(filename))\n\t\treturn ERR_CAST(filename);\n\tif (unlikely(type != LAST_NORM)) {\n\t\tpath_put(path);\n\t\tputname(filename);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tinode_lock_nested(path->dentry->d_inode, I_MUTEX_PARENT);\n\td = __lookup_hash(&last, path->dentry, 0);\n\tif (IS_ERR(d)) {\n\t\tinode_unlock(path->dentry->d_inode);\n\t\tpath_put(path);\n\t}\n\tputname(filename);\n\treturn d;\n}\n\nint kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\treturn filename_lookup(AT_FDCWD, getname_kernel(name),\n\t\t\t       flags, path, NULL);\n}\nEXPORT_SYMBOL(kern_path);\n\n/**\n * vfs_path_lookup - lookup a file path relative to a dentry-vfsmount pair\n * @dentry:  pointer to dentry of the base directory\n * @mnt: pointer to vfs mount of the base directory\n * @name: pointer to file name\n * @flags: lookup flags\n * @path: pointer to struct path to fill\n */\nint vfs_path_lookup(struct dentry *dentry, struct vfsmount *mnt,\n\t\t    const char *name, unsigned int flags,\n\t\t    struct path *path)\n{\n\tstruct path root = {.mnt = mnt, .dentry = dentry};\n\t/* the first argument of filename_lookup() is ignored with root */\n\treturn filename_lookup(AT_FDCWD, getname_kernel(name),\n\t\t\t       flags , path, &root);\n}\nEXPORT_SYMBOL(vfs_path_lookup);\n\nstatic int lookup_one_len_common(const char *name, struct dentry *base,\n\t\t\t\t int len, struct qstr *this)\n{\n\tthis->name = name;\n\tthis->len = len;\n\tthis->hash = full_name_hash(base, name, len);\n\tif (!len)\n\t\treturn -EACCES;\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn -EACCES;\n\t}\n\n\twhile (len--) {\n\t\tunsigned int c = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn -EACCES;\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, this);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn inode_permission(base->d_inode, MAY_EXEC);\n}\n\n/**\n * try_lookup_one_len - filesystem helper to lookup single pathname component\n * @name:\tpathname component to lookup\n * @base:\tbase directory to lookup from\n * @len:\tmaximum length @len should be interpreted to\n *\n * Look up a dentry by name in the dcache, returning NULL if it does not\n * currently exist.  The function does not try to create a dentry.\n *\n * Note that this routine is purely a helper for filesystem usage and should\n * not be called by generic code.\n *\n * The caller must hold base->i_mutex.\n */\nstruct dentry *try_lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tint err;\n\n\tWARN_ON_ONCE(!inode_is_locked(base->d_inode));\n\n\terr = lookup_one_len_common(name, base, len, &this);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn lookup_dcache(&this, base, 0);\n}\nEXPORT_SYMBOL(try_lookup_one_len);\n\n/**\n * lookup_one_len - filesystem helper to lookup single pathname component\n * @name:\tpathname component to lookup\n * @base:\tbase directory to lookup from\n * @len:\tmaximum length @len should be interpreted to\n *\n * Note that this routine is purely a helper for filesystem usage and should\n * not be called by generic code.\n *\n * The caller must hold base->i_mutex.\n */\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct dentry *dentry;\n\tstruct qstr this;\n\tint err;\n\n\tWARN_ON_ONCE(!inode_is_locked(base->d_inode));\n\n\terr = lookup_one_len_common(name, base, len, &this);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tdentry = lookup_dcache(&this, base, 0);\n\treturn dentry ? dentry : __lookup_slow(&this, base, 0);\n}\nEXPORT_SYMBOL(lookup_one_len);\n\n/**\n * lookup_one_len_unlocked - filesystem helper to lookup single pathname component\n * @name:\tpathname component to lookup\n * @base:\tbase directory to lookup from\n * @len:\tmaximum length @len should be interpreted to\n *\n * Note that this routine is purely a helper for filesystem usage and should\n * not be called by generic code.\n *\n * Unlike lookup_one_len, it should be called without the parent\n * i_mutex held, and will take the i_mutex itself if necessary.\n */\nstruct dentry *lookup_one_len_unlocked(const char *name,\n\t\t\t\t       struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tint err;\n\tstruct dentry *ret;\n\n\terr = lookup_one_len_common(name, base, len, &this);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tret = lookup_dcache(&this, base, 0);\n\tif (!ret)\n\t\tret = lookup_slow(&this, base, 0);\n\treturn ret;\n}\nEXPORT_SYMBOL(lookup_one_len_unlocked);\n\n/*\n * Like lookup_one_len_unlocked(), except that it yields ERR_PTR(-ENOENT)\n * on negatives.  Returns known positive or ERR_PTR(); that's what\n * most of the users want.  Note that pinned negative with unlocked parent\n * _can_ become positive at any time, so callers of lookup_one_len_unlocked()\n * need to be very careful; pinned positives have ->d_inode stable, so\n * this one avoids such problems.\n */\nstruct dentry *lookup_positive_unlocked(const char *name,\n\t\t\t\t       struct dentry *base, int len)\n{\n\tstruct dentry *ret = lookup_one_len_unlocked(name, base, len);\n\tif (!IS_ERR(ret) && d_flags_negative(smp_load_acquire(&ret->d_flags))) {\n\t\tdput(ret);\n\t\tret = ERR_PTR(-ENOENT);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(lookup_positive_unlocked);\n\n#ifdef CONFIG_UNIX98_PTYS\nint path_pts(struct path *path)\n{\n\t/* Find something mounted on \"pts\" in the same directory as\n\t * the input path.\n\t */\n\tstruct dentry *child, *parent;\n\tstruct qstr this;\n\tint ret;\n\n\tret = path_parent_directory(path);\n\tif (ret)\n\t\treturn ret;\n\n\tparent = path->dentry;\n\tthis.name = \"pts\";\n\tthis.len = 3;\n\tchild = d_hash_and_lookup(parent, &this);\n\tif (!child)\n\t\treturn -ENOENT;\n\n\tpath->dentry = child;\n\tdput(parent);\n\tfollow_mount(path);\n\treturn 0;\n}\n#endif\n\nint user_path_at_empty(int dfd, const char __user *name, unsigned flags,\n\t\t struct path *path, int *empty)\n{\n\treturn filename_lookup(dfd, getname_flags(name, flags, empty),\n\t\t\t       flags, path, NULL);\n}\nEXPORT_SYMBOL(user_path_at_empty);\n\n/**\n * path_mountpoint - look up a path to be umounted\n * @nd:\t\tlookup context\n * @flags:\tlookup flags\n * @path:\tpointer to container for result\n *\n * Look up the given name, but don't attempt to revalidate the last component.\n * Returns 0 and \"path\" will be valid on success; Returns error otherwise.\n */\nstatic int\npath_mountpoint(struct nameidata *nd, unsigned flags, struct path *path)\n{\n\tconst char *s = path_init(nd, flags);\n\tint err;\n\n\twhile (!(err = link_path_walk(s, nd)) &&\n\t\t(err = lookup_last(nd)) > 0) {\n\t\ts = trailing_symlink(nd);\n\t}\n\tif (!err && (nd->flags & LOOKUP_RCU))\n\t\terr = unlazy_walk(nd);\n\tif (!err)\n\t\terr = handle_lookup_down(nd);\n\tif (!err) {\n\t\t*path = nd->path;\n\t\tnd->path.mnt = NULL;\n\t\tnd->path.dentry = NULL;\n\t}\n\tterminate_walk(nd);\n\treturn err;\n}\n\nstatic int\nfilename_mountpoint(int dfd, struct filename *name, struct path *path,\n\t\t\tunsigned int flags)\n{\n\tstruct nameidata nd;\n\tint error;\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\tset_nameidata(&nd, dfd, name);\n\terror = path_mountpoint(&nd, flags | LOOKUP_RCU, path);\n\tif (unlikely(error == -ECHILD))\n\t\terror = path_mountpoint(&nd, flags, path);\n\tif (unlikely(error == -ESTALE))\n\t\terror = path_mountpoint(&nd, flags | LOOKUP_REVAL, path);\n\tif (likely(!error))\n\t\taudit_inode(name, path->dentry, AUDIT_INODE_NOEVAL);\n\trestore_nameidata();\n\tputname(name);\n\treturn error;\n}\n\n/**\n * user_path_mountpoint_at - lookup a path from userland in order to umount it\n * @dfd:\tdirectory file descriptor\n * @name:\tpathname from userland\n * @flags:\tlookup flags\n * @path:\tpointer to container to hold result\n *\n * A umount is a special case for path walking. We're not actually interested\n * in the inode in this situation, and ESTALE errors can be a problem. We\n * simply want track down the dentry and vfsmount attached at the mountpoint\n * and avoid revalidating the last component.\n *\n * Returns 0 and populates \"path\" on success.\n */\nint\nuser_path_mountpoint_at(int dfd, const char __user *name, unsigned int flags,\n\t\t\tstruct path *path)\n{\n\treturn filename_mountpoint(dfd, getname(name), path, flags);\n}\n\nint\nkern_path_mountpoint(int dfd, const char *name, struct path *path,\n\t\t\tunsigned int flags)\n{\n\treturn filename_mountpoint(dfd, getname_kernel(name), path, flags);\n}\nEXPORT_SYMBOL(kern_path_mountpoint);\n\nint __check_sticky(struct inode *dir, struct inode *inode)\n{\n\tkuid_t fsuid = current_fsuid();\n\n\tif (uid_eq(inode->i_uid, fsuid))\n\t\treturn 0;\n\tif (uid_eq(dir->i_uid, fsuid))\n\t\treturn 0;\n\treturn !capable_wrt_inode_uidgid(inode, CAP_FOWNER);\n}\nEXPORT_SYMBOL(__check_sticky);\n\n/*\n *\tCheck whether we can remove a link victim from directory dir, check\n *  whether the type of victim is right.\n *  1. We can't do it if dir is read-only (done in permission())\n *  2. We should have write and exec permissions on dir\n *  3. We can't remove anything from append-only dir\n *  4. We can't do anything with immutable dir (done in permission())\n *  5. If the sticky bit on dir is set we should either\n *\ta. be owner of dir, or\n *\tb. be owner of victim, or\n *\tc. have CAP_FOWNER capability\n *  6. If the victim is append-only or immutable we can't do antyhing with\n *     links pointing to it.\n *  7. If the victim has an unknown uid or gid we can't change the inode.\n *  8. If we were asked to remove a directory and victim isn't one - ENOTDIR.\n *  9. If we were asked to remove a non-directory and victim isn't one - EISDIR.\n * 10. We can't remove a root or mountpoint.\n * 11. We don't allow removal of NFS sillyrenamed files; it's handled by\n *     nfs_async_unlink().\n */\nstatic int may_delete(struct inode *dir, struct dentry *victim, bool isdir)\n{\n\tstruct inode *inode = d_backing_inode(victim);\n\tint error;\n\n\tif (d_is_negative(victim))\n\t\treturn -ENOENT;\n\tBUG_ON(!inode);\n\n\tBUG_ON(victim->d_parent->d_inode != dir);\n\n\t/* Inode writeback is not safe when the uid or gid are invalid. */\n\tif (!uid_valid(inode->i_uid) || !gid_valid(inode->i_gid))\n\t\treturn -EOVERFLOW;\n\n\taudit_inode_child(dir, victim, AUDIT_TYPE_CHILD_DELETE);\n\n\terror = inode_permission(dir, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\tif (IS_APPEND(dir))\n\t\treturn -EPERM;\n\n\tif (check_sticky(dir, inode) || IS_APPEND(inode) ||\n\t    IS_IMMUTABLE(inode) || IS_SWAPFILE(inode) || HAS_UNMAPPED_ID(inode))\n\t\treturn -EPERM;\n\tif (isdir) {\n\t\tif (!d_is_dir(victim))\n\t\t\treturn -ENOTDIR;\n\t\tif (IS_ROOT(victim))\n\t\t\treturn -EBUSY;\n\t} else if (d_is_dir(victim))\n\t\treturn -EISDIR;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\tif (victim->d_flags & DCACHE_NFSFS_RENAMED)\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\n/*\tCheck whether we can create an object with dentry child in directory\n *  dir.\n *  1. We can't do it if child already exists (open has special treatment for\n *     this case, but since we are inlined it's OK)\n *  2. We can't do it if dir is read-only (done in permission())\n *  3. We can't do it if the fs can't represent the fsuid or fsgid.\n *  4. We should have write and exec permissions on dir\n *  5. We can't do it if dir is immutable (done in permission())\n */\nstatic inline int may_create(struct inode *dir, struct dentry *child)\n{\n\tstruct user_namespace *s_user_ns;\n\taudit_inode_child(dir, child, AUDIT_TYPE_CHILD_CREATE);\n\tif (child->d_inode)\n\t\treturn -EEXIST;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\ts_user_ns = dir->i_sb->s_user_ns;\n\tif (!kuid_has_mapping(s_user_ns, current_fsuid()) ||\n\t    !kgid_has_mapping(s_user_ns, current_fsgid()))\n\t\treturn -EOVERFLOW;\n\treturn inode_permission(dir, MAY_WRITE | MAY_EXEC);\n}\n\n/*\n * p1 and p2 should be directories on the same fs.\n */\nstruct dentry *lock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tstruct dentry *p;\n\n\tif (p1 == p2) {\n\t\tinode_lock_nested(p1->d_inode, I_MUTEX_PARENT);\n\t\treturn NULL;\n\t}\n\n\tmutex_lock(&p1->d_sb->s_vfs_rename_mutex);\n\n\tp = d_ancestor(p2, p1);\n\tif (p) {\n\t\tinode_lock_nested(p2->d_inode, I_MUTEX_PARENT);\n\t\tinode_lock_nested(p1->d_inode, I_MUTEX_CHILD);\n\t\treturn p;\n\t}\n\n\tp = d_ancestor(p1, p2);\n\tif (p) {\n\t\tinode_lock_nested(p1->d_inode, I_MUTEX_PARENT);\n\t\tinode_lock_nested(p2->d_inode, I_MUTEX_CHILD);\n\t\treturn p;\n\t}\n\n\tinode_lock_nested(p1->d_inode, I_MUTEX_PARENT);\n\tinode_lock_nested(p2->d_inode, I_MUTEX_PARENT2);\n\treturn NULL;\n}\nEXPORT_SYMBOL(lock_rename);\n\nvoid unlock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tinode_unlock(p1->d_inode);\n\tif (p1 != p2) {\n\t\tinode_unlock(p2->d_inode);\n\t\tmutex_unlock(&p1->d_sb->s_vfs_rename_mutex);\n\t}\n}\nEXPORT_SYMBOL(unlock_rename);\n\nint vfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\tbool want_excl)\n{\n\tint error = may_create(dir, dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->create)\n\t\treturn -EACCES;\t/* shouldn't it be ENOSYS? */\n\tmode &= S_IALLUGO;\n\tmode |= S_IFREG;\n\terror = security_inode_create(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\terror = dir->i_op->create(dir, dentry, mode, want_excl);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_create);\n\nint vfs_mkobj(struct dentry *dentry, umode_t mode,\n\t\tint (*f)(struct dentry *, umode_t, void *),\n\t\tvoid *arg)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tint error = may_create(dir, dentry);\n\tif (error)\n\t\treturn error;\n\n\tmode &= S_IALLUGO;\n\tmode |= S_IFREG;\n\terror = security_inode_create(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\terror = f(dentry, mode, arg);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_mkobj);\n\nbool may_open_dev(const struct path *path)\n{\n\treturn !(path->mnt->mnt_flags & MNT_NODEV) &&\n\t\t!(path->mnt->mnt_sb->s_iflags & SB_I_NODEV);\n}\n\nstatic int may_open(const struct path *path, int acc_mode, int flag)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFLNK:\n\t\treturn -ELOOP;\n\tcase S_IFDIR:\n\t\tif (acc_mode & MAY_WRITE)\n\t\t\treturn -EISDIR;\n\t\tbreak;\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\tif (!may_open_dev(path))\n\t\t\treturn -EACCES;\n\t\t/*FALLTHRU*/\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tflag &= ~O_TRUNC;\n\t\tbreak;\n\t}\n\n\terror = inode_permission(inode, MAY_OPEN | acc_mode);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * An append-only file must be opened in append mode for writing.\n\t */\n\tif (IS_APPEND(inode)) {\n\t\tif  ((flag & O_ACCMODE) != O_RDONLY && !(flag & O_APPEND))\n\t\t\treturn -EPERM;\n\t\tif (flag & O_TRUNC)\n\t\t\treturn -EPERM;\n\t}\n\n\t/* O_NOATIME can only be set by the owner or superuser */\n\tif (flag & O_NOATIME && !inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\n\treturn 0;\n}\n\nstatic int handle_truncate(struct file *filp)\n{\n\tconst struct path *path = &filp->f_path;\n\tstruct inode *inode = path->dentry->d_inode;\n\tint error = get_write_access(inode);\n\tif (error)\n\t\treturn error;\n\t/*\n\t * Refuse to truncate files with mandatory locks held on them.\n\t */\n\terror = locks_verify_locked(filp);\n\tif (!error)\n\t\terror = security_path_truncate(path);\n\tif (!error) {\n\t\terror = do_truncate(path->dentry, 0,\n\t\t\t\t    ATTR_MTIME|ATTR_CTIME|ATTR_OPEN,\n\t\t\t\t    filp);\n\t}\n\tput_write_access(inode);\n\treturn error;\n}\n\nstatic inline int open_to_namei_flags(int flag)\n{\n\tif ((flag & O_ACCMODE) == 3)\n\t\tflag--;\n\treturn flag;\n}\n\nstatic int may_o_create(const struct path *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct user_namespace *s_user_ns;\n\tint error = security_path_mknod(dir, dentry, mode, 0);\n\tif (error)\n\t\treturn error;\n\n\ts_user_ns = dir->dentry->d_sb->s_user_ns;\n\tif (!kuid_has_mapping(s_user_ns, current_fsuid()) ||\n\t    !kgid_has_mapping(s_user_ns, current_fsgid()))\n\t\treturn -EOVERFLOW;\n\n\terror = inode_permission(dir->dentry->d_inode, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\n\treturn security_inode_create(dir->dentry->d_inode, dentry, mode);\n}\n\n/*\n * Attempt to atomically look up, create and open a file from a negative\n * dentry.\n *\n * Returns 0 if successful.  The file will have been created and attached to\n * @file by the filesystem calling finish_open().\n *\n * If the file was looked up only or didn't need creating, FMODE_OPENED won't\n * be set.  The caller will need to perform the open themselves.  @path will\n * have been updated to point to the new dentry.  This may be negative.\n *\n * Returns an error code otherwise.\n */\nstatic int atomic_open(struct nameidata *nd, struct dentry *dentry,\n\t\t\tstruct path *path, struct file *file,\n\t\t\tconst struct open_flags *op,\n\t\t\tint open_flag, umode_t mode)\n{\n\tstruct dentry *const DENTRY_NOT_SET = (void *) -1UL;\n\tstruct inode *dir =  nd->path.dentry->d_inode;\n\tint error;\n\n\tif (!(~open_flag & (O_EXCL | O_CREAT)))\t/* both O_EXCL and O_CREAT */\n\t\topen_flag &= ~O_TRUNC;\n\n\tif (nd->flags & LOOKUP_DIRECTORY)\n\t\topen_flag |= O_DIRECTORY;\n\n\tfile->f_path.dentry = DENTRY_NOT_SET;\n\tfile->f_path.mnt = nd->path.mnt;\n\terror = dir->i_op->atomic_open(dir, dentry, file,\n\t\t\t\t       open_to_namei_flags(open_flag), mode);\n\td_lookup_done(dentry);\n\tif (!error) {\n\t\tif (file->f_mode & FMODE_OPENED) {\n\t\t\t/*\n\t\t\t * We didn't have the inode before the open, so check open\n\t\t\t * permission here.\n\t\t\t */\n\t\t\tint acc_mode = op->acc_mode;\n\t\t\tif (file->f_mode & FMODE_CREATED) {\n\t\t\t\tWARN_ON(!(open_flag & O_CREAT));\n\t\t\t\tfsnotify_create(dir, dentry);\n\t\t\t\tacc_mode = 0;\n\t\t\t}\n\t\t\terror = may_open(&file->f_path, acc_mode, open_flag);\n\t\t\tif (WARN_ON(error > 0))\n\t\t\t\terror = -EINVAL;\n\t\t} else if (WARN_ON(file->f_path.dentry == DENTRY_NOT_SET)) {\n\t\t\terror = -EIO;\n\t\t} else {\n\t\t\tif (file->f_path.dentry) {\n\t\t\t\tdput(dentry);\n\t\t\t\tdentry = file->f_path.dentry;\n\t\t\t}\n\t\t\tif (file->f_mode & FMODE_CREATED)\n\t\t\t\tfsnotify_create(dir, dentry);\n\t\t\tif (unlikely(d_is_negative(dentry))) {\n\t\t\t\terror = -ENOENT;\n\t\t\t} else {\n\t\t\t\tpath->dentry = dentry;\n\t\t\t\tpath->mnt = nd->path.mnt;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tdput(dentry);\n\treturn error;\n}\n\n/*\n * Look up and maybe create and open the last component.\n *\n * Must be called with parent locked (exclusive in O_CREAT case).\n *\n * Returns 0 on success, that is, if\n *  the file was successfully atomically created (if necessary) and opened, or\n *  the file was not completely opened at this time, though lookups and\n *  creations were performed.\n * These case are distinguished by presence of FMODE_OPENED on file->f_mode.\n * In the latter case dentry returned in @path might be negative if O_CREAT\n * hadn't been specified.\n *\n * An error code is returned on failure.\n */\nstatic int lookup_open(struct nameidata *nd, struct path *path,\n\t\t\tstruct file *file,\n\t\t\tconst struct open_flags *op,\n\t\t\tbool got_write)\n{\n\tstruct dentry *dir = nd->path.dentry;\n\tstruct inode *dir_inode = dir->d_inode;\n\tint open_flag = op->open_flag;\n\tstruct dentry *dentry;\n\tint error, create_error = 0;\n\tumode_t mode = op->mode;\n\tDECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);\n\n\tif (unlikely(IS_DEADDIR(dir_inode)))\n\t\treturn -ENOENT;\n\n\tfile->f_mode &= ~FMODE_CREATED;\n\tdentry = d_lookup(dir, &nd->last);\n\tfor (;;) {\n\t\tif (!dentry) {\n\t\t\tdentry = d_alloc_parallel(dir, &nd->last, &wq);\n\t\t\tif (IS_ERR(dentry))\n\t\t\t\treturn PTR_ERR(dentry);\n\t\t}\n\t\tif (d_in_lookup(dentry))\n\t\t\tbreak;\n\n\t\terror = d_revalidate(dentry, nd->flags);\n\t\tif (likely(error > 0))\n\t\t\tbreak;\n\t\tif (error)\n\t\t\tgoto out_dput;\n\t\td_invalidate(dentry);\n\t\tdput(dentry);\n\t\tdentry = NULL;\n\t}\n\tif (dentry->d_inode) {\n\t\t/* Cached positive dentry: will open in f_op->open */\n\t\tgoto out_no_open;\n\t}\n\n\t/*\n\t * Checking write permission is tricky, bacuse we don't know if we are\n\t * going to actually need it: O_CREAT opens should work as long as the\n\t * file exists.  But checking existence breaks atomicity.  The trick is\n\t * to check access and if not granted clear O_CREAT from the flags.\n\t *\n\t * Another problem is returing the \"right\" error value (e.g. for an\n\t * O_EXCL open we want to return EEXIST not EROFS).\n\t */\n\tif (open_flag & O_CREAT) {\n\t\tif (!IS_POSIXACL(dir->d_inode))\n\t\t\tmode &= ~current_umask();\n\t\tif (unlikely(!got_write)) {\n\t\t\tcreate_error = -EROFS;\n\t\t\topen_flag &= ~O_CREAT;\n\t\t\tif (open_flag & (O_EXCL | O_TRUNC))\n\t\t\t\tgoto no_open;\n\t\t\t/* No side effects, safe to clear O_CREAT */\n\t\t} else {\n\t\t\tcreate_error = may_o_create(&nd->path, dentry, mode);\n\t\t\tif (create_error) {\n\t\t\t\topen_flag &= ~O_CREAT;\n\t\t\t\tif (open_flag & O_EXCL)\n\t\t\t\t\tgoto no_open;\n\t\t\t}\n\t\t}\n\t} else if ((open_flag & (O_TRUNC|O_WRONLY|O_RDWR)) &&\n\t\t   unlikely(!got_write)) {\n\t\t/*\n\t\t * No O_CREATE -> atomicity not a requirement -> fall\n\t\t * back to lookup + open\n\t\t */\n\t\tgoto no_open;\n\t}\n\n\tif (dir_inode->i_op->atomic_open) {\n\t\terror = atomic_open(nd, dentry, path, file, op, open_flag,\n\t\t\t\t    mode);\n\t\tif (unlikely(error == -ENOENT) && create_error)\n\t\t\terror = create_error;\n\t\treturn error;\n\t}\n\nno_open:\n\tif (d_in_lookup(dentry)) {\n\t\tstruct dentry *res = dir_inode->i_op->lookup(dir_inode, dentry,\n\t\t\t\t\t\t\t     nd->flags);\n\t\td_lookup_done(dentry);\n\t\tif (unlikely(res)) {\n\t\t\tif (IS_ERR(res)) {\n\t\t\t\terror = PTR_ERR(res);\n\t\t\t\tgoto out_dput;\n\t\t\t}\n\t\t\tdput(dentry);\n\t\t\tdentry = res;\n\t\t}\n\t}\n\n\t/* Negative dentry, just create the file */\n\tif (!dentry->d_inode && (open_flag & O_CREAT)) {\n\t\tfile->f_mode |= FMODE_CREATED;\n\t\taudit_inode_child(dir_inode, dentry, AUDIT_TYPE_CHILD_CREATE);\n\t\tif (!dir_inode->i_op->create) {\n\t\t\terror = -EACCES;\n\t\t\tgoto out_dput;\n\t\t}\n\t\terror = dir_inode->i_op->create(dir_inode, dentry, mode,\n\t\t\t\t\t\topen_flag & O_EXCL);\n\t\tif (error)\n\t\t\tgoto out_dput;\n\t\tfsnotify_create(dir_inode, dentry);\n\t}\n\tif (unlikely(create_error) && !dentry->d_inode) {\n\t\terror = create_error;\n\t\tgoto out_dput;\n\t}\nout_no_open:\n\tpath->dentry = dentry;\n\tpath->mnt = nd->path.mnt;\n\treturn 0;\n\nout_dput:\n\tdput(dentry);\n\treturn error;\n}\n\n/*\n * Handle the last step of open()\n */\nstatic int do_last(struct nameidata *nd,\n\t\t   struct file *file, const struct open_flags *op)\n{\n\tstruct dentry *dir = nd->path.dentry;\n\tint open_flag = op->open_flag;\n\tbool will_truncate = (open_flag & O_TRUNC) != 0;\n\tbool got_write = false;\n\tint acc_mode = op->acc_mode;\n\tunsigned seq;\n\tstruct inode *inode;\n\tstruct path path;\n\tint error;\n\n\tnd->flags &= ~LOOKUP_PARENT;\n\tnd->flags |= op->intent;\n\n\tif (nd->last_type != LAST_NORM) {\n\t\terror = handle_dots(nd, nd->last_type);\n\t\tif (unlikely(error))\n\t\t\treturn error;\n\t\tgoto finish_open;\n\t}\n\n\tif (!(open_flag & O_CREAT)) {\n\t\tif (nd->last.name[nd->last.len])\n\t\t\tnd->flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY;\n\t\t/* we _can_ be in RCU mode here */\n\t\terror = lookup_fast(nd, &path, &inode, &seq);\n\t\tif (likely(error > 0))\n\t\t\tgoto finish_lookup;\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tBUG_ON(nd->inode != dir->d_inode);\n\t\tBUG_ON(nd->flags & LOOKUP_RCU);\n\t} else {\n\t\t/* create side of things */\n\t\t/*\n\t\t * This will *only* deal with leaving RCU mode - LOOKUP_JUMPED\n\t\t * has been cleared when we got to the last component we are\n\t\t * about to look up\n\t\t */\n\t\terror = complete_walk(nd);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\taudit_inode(nd->name, dir, AUDIT_INODE_PARENT);\n\t\t/* trailing slashes? */\n\t\tif (unlikely(nd->last.name[nd->last.len]))\n\t\t\treturn -EISDIR;\n\t}\n\n\tif (open_flag & (O_CREAT | O_TRUNC | O_WRONLY | O_RDWR)) {\n\t\terror = mnt_want_write(nd->path.mnt);\n\t\tif (!error)\n\t\t\tgot_write = true;\n\t\t/*\n\t\t * do _not_ fail yet - we might not need that or fail with\n\t\t * a different error; let lookup_open() decide; we'll be\n\t\t * dropping this one anyway.\n\t\t */\n\t}\n\tif (open_flag & O_CREAT)\n\t\tinode_lock(dir->d_inode);\n\telse\n\t\tinode_lock_shared(dir->d_inode);\n\terror = lookup_open(nd, &path, file, op, got_write);\n\tif (open_flag & O_CREAT)\n\t\tinode_unlock(dir->d_inode);\n\telse\n\t\tinode_unlock_shared(dir->d_inode);\n\n\tif (error)\n\t\tgoto out;\n\n\tif (file->f_mode & FMODE_OPENED) {\n\t\tif ((file->f_mode & FMODE_CREATED) ||\n\t\t    !S_ISREG(file_inode(file)->i_mode))\n\t\t\twill_truncate = false;\n\n\t\taudit_inode(nd->name, file->f_path.dentry, 0);\n\t\tgoto opened;\n\t}\n\n\tif (file->f_mode & FMODE_CREATED) {\n\t\t/* Don't check for write permission, don't truncate */\n\t\topen_flag &= ~O_TRUNC;\n\t\twill_truncate = false;\n\t\tacc_mode = 0;\n\t\tpath_to_nameidata(&path, nd);\n\t\tgoto finish_open_created;\n\t}\n\n\t/*\n\t * If atomic_open() acquired write access it is dropped now due to\n\t * possible mount and symlink following (this might be optimized away if\n\t * necessary...)\n\t */\n\tif (got_write) {\n\t\tmnt_drop_write(nd->path.mnt);\n\t\tgot_write = false;\n\t}\n\n\terror = follow_managed(&path, nd);\n\tif (unlikely(error < 0))\n\t\treturn error;\n\n\t/*\n\t * create/update audit record if it already exists.\n\t */\n\taudit_inode(nd->name, path.dentry, 0);\n\n\tif (unlikely((open_flag & (O_EXCL | O_CREAT)) == (O_EXCL | O_CREAT))) {\n\t\tpath_to_nameidata(&path, nd);\n\t\treturn -EEXIST;\n\t}\n\n\tseq = 0;\t/* out of RCU mode, so the value doesn't matter */\n\tinode = d_backing_inode(path.dentry);\nfinish_lookup:\n\terror = step_into(nd, &path, 0, inode, seq);\n\tif (unlikely(error))\n\t\treturn error;\nfinish_open:\n\t/* Why this, you ask?  _Now_ we might have grown LOOKUP_JUMPED... */\n\terror = complete_walk(nd);\n\tif (error)\n\t\treturn error;\n\taudit_inode(nd->name, nd->path.dentry, 0);\n\tif (open_flag & O_CREAT) {\n\t\terror = -EISDIR;\n\t\tif (d_is_dir(nd->path.dentry))\n\t\t\tgoto out;\n\t\terror = may_create_in_sticky(dir,\n\t\t\t\t\t     d_backing_inode(nd->path.dentry));\n\t\tif (unlikely(error))\n\t\t\tgoto out;\n\t}\n\terror = -ENOTDIR;\n\tif ((nd->flags & LOOKUP_DIRECTORY) && !d_can_lookup(nd->path.dentry))\n\t\tgoto out;\n\tif (!d_is_reg(nd->path.dentry))\n\t\twill_truncate = false;\n\n\tif (will_truncate) {\n\t\terror = mnt_want_write(nd->path.mnt);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tgot_write = true;\n\t}\nfinish_open_created:\n\terror = may_open(&nd->path, acc_mode, open_flag);\n\tif (error)\n\t\tgoto out;\n\tBUG_ON(file->f_mode & FMODE_OPENED); /* once it's opened, it's opened */\n\terror = vfs_open(&nd->path, file);\n\tif (error)\n\t\tgoto out;\nopened:\n\terror = ima_file_check(file, op->acc_mode);\n\tif (!error && will_truncate)\n\t\terror = handle_truncate(file);\nout:\n\tif (unlikely(error > 0)) {\n\t\tWARN_ON(1);\n\t\terror = -EINVAL;\n\t}\n\tif (got_write)\n\t\tmnt_drop_write(nd->path.mnt);\n\treturn error;\n}\n\nstruct dentry *vfs_tmpfile(struct dentry *dentry, umode_t mode, int open_flag)\n{\n\tstruct dentry *child = NULL;\n\tstruct inode *dir = dentry->d_inode;\n\tstruct inode *inode;\n\tint error;\n\n\t/* we want directory to be writable */\n\terror = inode_permission(dir, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\tgoto out_err;\n\terror = -EOPNOTSUPP;\n\tif (!dir->i_op->tmpfile)\n\t\tgoto out_err;\n\terror = -ENOMEM;\n\tchild = d_alloc(dentry, &slash_name);\n\tif (unlikely(!child))\n\t\tgoto out_err;\n\terror = dir->i_op->tmpfile(dir, child, mode);\n\tif (error)\n\t\tgoto out_err;\n\terror = -ENOENT;\n\tinode = child->d_inode;\n\tif (unlikely(!inode))\n\t\tgoto out_err;\n\tif (!(open_flag & O_EXCL)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state |= I_LINKABLE;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tima_post_create_tmpfile(inode);\n\treturn child;\n\nout_err:\n\tdput(child);\n\treturn ERR_PTR(error);\n}\nEXPORT_SYMBOL(vfs_tmpfile);\n\nstatic int do_tmpfile(struct nameidata *nd, unsigned flags,\n\t\tconst struct open_flags *op,\n\t\tstruct file *file)\n{\n\tstruct dentry *child;\n\tstruct path path;\n\tint error = path_lookupat(nd, flags | LOOKUP_DIRECTORY, &path);\n\tif (unlikely(error))\n\t\treturn error;\n\terror = mnt_want_write(path.mnt);\n\tif (unlikely(error))\n\t\tgoto out;\n\tchild = vfs_tmpfile(path.dentry, op->mode, op->open_flag);\n\terror = PTR_ERR(child);\n\tif (IS_ERR(child))\n\t\tgoto out2;\n\tdput(path.dentry);\n\tpath.dentry = child;\n\taudit_inode(nd->name, child, 0);\n\t/* Don't check for other permissions, the inode was just created */\n\terror = may_open(&path, 0, op->open_flag);\n\tif (error)\n\t\tgoto out2;\n\tfile->f_path.mnt = path.mnt;\n\terror = finish_open(file, child, NULL);\nout2:\n\tmnt_drop_write(path.mnt);\nout:\n\tpath_put(&path);\n\treturn error;\n}\n\nstatic int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)\n{\n\tstruct path path;\n\tint error = path_lookupat(nd, flags, &path);\n\tif (!error) {\n\t\taudit_inode(nd->name, path.dentry, 0);\n\t\terror = vfs_open(&path, file);\n\t\tpath_put(&path);\n\t}\n\treturn error;\n}\n\nstatic struct file *path_openat(struct nameidata *nd,\n\t\t\tconst struct open_flags *op, unsigned flags)\n{\n\tstruct file *file;\n\tint error;\n\n\tfile = alloc_empty_file(op->open_flag, current_cred());\n\tif (IS_ERR(file))\n\t\treturn file;\n\n\tif (unlikely(file->f_flags & __O_TMPFILE)) {\n\t\terror = do_tmpfile(nd, flags, op, file);\n\t} else if (unlikely(file->f_flags & O_PATH)) {\n\t\terror = do_o_path(nd, flags, file);\n\t} else {\n\t\tconst char *s = path_init(nd, flags);\n\t\twhile (!(error = link_path_walk(s, nd)) &&\n\t\t\t(error = do_last(nd, file, op)) > 0) {\n\t\t\tnd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);\n\t\t\ts = trailing_symlink(nd);\n\t\t}\n\t\tterminate_walk(nd);\n\t}\n\tif (likely(!error)) {\n\t\tif (likely(file->f_mode & FMODE_OPENED))\n\t\t\treturn file;\n\t\tWARN_ON(1);\n\t\terror = -EINVAL;\n\t}\n\tfput(file);\n\tif (error == -EOPENSTALE) {\n\t\tif (flags & LOOKUP_RCU)\n\t\t\terror = -ECHILD;\n\t\telse\n\t\t\terror = -ESTALE;\n\t}\n\treturn ERR_PTR(error);\n}\n\nstruct file *do_filp_open(int dfd, struct filename *pathname,\n\t\tconst struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tint flags = op->lookup_flags;\n\tstruct file *filp;\n\n\tset_nameidata(&nd, dfd, pathname);\n\tfilp = path_openat(&nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(filp == ERR_PTR(-ECHILD)))\n\t\tfilp = path_openat(&nd, op, flags);\n\tif (unlikely(filp == ERR_PTR(-ESTALE)))\n\t\tfilp = path_openat(&nd, op, flags | LOOKUP_REVAL);\n\trestore_nameidata();\n\treturn filp;\n}\n\nstruct file *do_file_open_root(struct dentry *dentry, struct vfsmount *mnt,\n\t\tconst char *name, const struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tstruct file *file;\n\tstruct filename *filename;\n\tint flags = op->lookup_flags | LOOKUP_ROOT;\n\n\tnd.root.mnt = mnt;\n\tnd.root.dentry = dentry;\n\n\tif (d_is_symlink(dentry) && op->intent & LOOKUP_OPEN)\n\t\treturn ERR_PTR(-ELOOP);\n\n\tfilename = getname_kernel(name);\n\tif (IS_ERR(filename))\n\t\treturn ERR_CAST(filename);\n\n\tset_nameidata(&nd, -1, filename);\n\tfile = path_openat(&nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(file == ERR_PTR(-ECHILD)))\n\t\tfile = path_openat(&nd, op, flags);\n\tif (unlikely(file == ERR_PTR(-ESTALE)))\n\t\tfile = path_openat(&nd, op, flags | LOOKUP_REVAL);\n\trestore_nameidata();\n\tputname(filename);\n\treturn file;\n}\n\nstatic struct dentry *filename_create(int dfd, struct filename *name,\n\t\t\t\tstruct path *path, unsigned int lookup_flags)\n{\n\tstruct dentry *dentry = ERR_PTR(-EEXIST);\n\tstruct qstr last;\n\tint type;\n\tint err2;\n\tint error;\n\tbool is_dir = (lookup_flags & LOOKUP_DIRECTORY);\n\n\t/*\n\t * Note that only LOOKUP_REVAL and LOOKUP_DIRECTORY matter here. Any\n\t * other flags passed in are ignored!\n\t */\n\tlookup_flags &= LOOKUP_REVAL;\n\n\tname = filename_parentat(dfd, name, lookup_flags, path, &last, &type);\n\tif (IS_ERR(name))\n\t\treturn ERR_CAST(name);\n\n\t/*\n\t * Yucky last component or no last component at all?\n\t * (foo/., foo/.., /////)\n\t */\n\tif (unlikely(type != LAST_NORM))\n\t\tgoto out;\n\n\t/* don't fail immediately if it's r/o, at least try to report other errors */\n\terr2 = mnt_want_write(path->mnt);\n\t/*\n\t * Do the final lookup.\n\t */\n\tlookup_flags |= LOOKUP_CREATE | LOOKUP_EXCL;\n\tinode_lock_nested(path->dentry->d_inode, I_MUTEX_PARENT);\n\tdentry = __lookup_hash(&last, path->dentry, lookup_flags);\n\tif (IS_ERR(dentry))\n\t\tgoto unlock;\n\n\terror = -EEXIST;\n\tif (d_is_positive(dentry))\n\t\tgoto fail;\n\n\t/*\n\t * Special case - lookup gave negative, but... we had foo/bar/\n\t * From the vfs_mknod() POV we just have a negative dentry -\n\t * all is fine. Let's be bastards - you had / on the end, you've\n\t * been asking for (non-existent) directory. -ENOENT for you.\n\t */\n\tif (unlikely(!is_dir && last.name[last.len])) {\n\t\terror = -ENOENT;\n\t\tgoto fail;\n\t}\n\tif (unlikely(err2)) {\n\t\terror = err2;\n\t\tgoto fail;\n\t}\n\tputname(name);\n\treturn dentry;\nfail:\n\tdput(dentry);\n\tdentry = ERR_PTR(error);\nunlock:\n\tinode_unlock(path->dentry->d_inode);\n\tif (!err2)\n\t\tmnt_drop_write(path->mnt);\nout:\n\tpath_put(path);\n\tputname(name);\n\treturn dentry;\n}\n\nstruct dentry *kern_path_create(int dfd, const char *pathname,\n\t\t\t\tstruct path *path, unsigned int lookup_flags)\n{\n\treturn filename_create(dfd, getname_kernel(pathname),\n\t\t\t\tpath, lookup_flags);\n}\nEXPORT_SYMBOL(kern_path_create);\n\nvoid done_path_create(struct path *path, struct dentry *dentry)\n{\n\tdput(dentry);\n\tinode_unlock(path->dentry->d_inode);\n\tmnt_drop_write(path->mnt);\n\tpath_put(path);\n}\nEXPORT_SYMBOL(done_path_create);\n\ninline struct dentry *user_path_create(int dfd, const char __user *pathname,\n\t\t\t\tstruct path *path, unsigned int lookup_flags)\n{\n\treturn filename_create(dfd, getname(pathname), path, lookup_flags);\n}\nEXPORT_SYMBOL(user_path_create);\n\nint vfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)\n{\n\tint error = may_create(dir, dentry);\n\n\tif (error)\n\t\treturn error;\n\n\tif ((S_ISCHR(mode) || S_ISBLK(mode)) && !capable(CAP_MKNOD))\n\t\treturn -EPERM;\n\n\tif (!dir->i_op->mknod)\n\t\treturn -EPERM;\n\n\terror = devcgroup_inode_mknod(mode, dev);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_mknod(dir, dentry, mode, dev);\n\tif (error)\n\t\treturn error;\n\n\terror = dir->i_op->mknod(dir, dentry, mode, dev);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_mknod);\n\nstatic int may_mknod(umode_t mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFREG:\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\tcase 0: /* zero mode translates to S_IFREG */\n\t\treturn 0;\n\tcase S_IFDIR:\n\t\treturn -EPERM;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nlong do_mknodat(int dfd, const char __user *filename, umode_t mode,\n\t\tunsigned int dev)\n{\n\tstruct dentry *dentry;\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags = 0;\n\n\terror = may_mknod(mode);\n\tif (error)\n\t\treturn error;\nretry:\n\tdentry = user_path_create(dfd, filename, &path, lookup_flags);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tif (!IS_POSIXACL(path.dentry->d_inode))\n\t\tmode &= ~current_umask();\n\terror = security_path_mknod(&path, dentry, mode, dev);\n\tif (error)\n\t\tgoto out;\n\tswitch (mode & S_IFMT) {\n\t\tcase 0: case S_IFREG:\n\t\t\terror = vfs_create(path.dentry->d_inode,dentry,mode,true);\n\t\t\tif (!error)\n\t\t\t\tima_post_path_mknod(dentry);\n\t\t\tbreak;\n\t\tcase S_IFCHR: case S_IFBLK:\n\t\t\terror = vfs_mknod(path.dentry->d_inode,dentry,mode,\n\t\t\t\t\tnew_decode_dev(dev));\n\t\t\tbreak;\n\t\tcase S_IFIFO: case S_IFSOCK:\n\t\t\terror = vfs_mknod(path.dentry->d_inode,dentry,mode,0);\n\t\t\tbreak;\n\t}\nout:\n\tdone_path_create(&path, dentry);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE4(mknodat, int, dfd, const char __user *, filename, umode_t, mode,\n\t\tunsigned int, dev)\n{\n\treturn do_mknodat(dfd, filename, mode, dev);\n}\n\nSYSCALL_DEFINE3(mknod, const char __user *, filename, umode_t, mode, unsigned, dev)\n{\n\treturn do_mknodat(AT_FDCWD, filename, mode, dev);\n}\n\nint vfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint error = may_create(dir, dentry);\n\tunsigned max_links = dir->i_sb->s_max_links;\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->mkdir)\n\t\treturn -EPERM;\n\n\tmode &= (S_IRWXUGO|S_ISVTX);\n\terror = security_inode_mkdir(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\n\tif (max_links && dir->i_nlink >= max_links)\n\t\treturn -EMLINK;\n\n\terror = dir->i_op->mkdir(dir, dentry, mode);\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_mkdir);\n\nlong do_mkdirat(int dfd, const char __user *pathname, umode_t mode)\n{\n\tstruct dentry *dentry;\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags = LOOKUP_DIRECTORY;\n\nretry:\n\tdentry = user_path_create(dfd, pathname, &path, lookup_flags);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tif (!IS_POSIXACL(path.dentry->d_inode))\n\t\tmode &= ~current_umask();\n\terror = security_path_mkdir(&path, dentry, mode);\n\tif (!error)\n\t\terror = vfs_mkdir(path.dentry->d_inode, dentry, mode);\n\tdone_path_create(&path, dentry);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE3(mkdirat, int, dfd, const char __user *, pathname, umode_t, mode)\n{\n\treturn do_mkdirat(dfd, pathname, mode);\n}\n\nSYSCALL_DEFINE2(mkdir, const char __user *, pathname, umode_t, mode)\n{\n\treturn do_mkdirat(AT_FDCWD, pathname, mode);\n}\n\nint vfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint error = may_delete(dir, dentry, 1);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->rmdir)\n\t\treturn -EPERM;\n\n\tdget(dentry);\n\tinode_lock(dentry->d_inode);\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(dentry))\n\t\tgoto out;\n\n\terror = security_inode_rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\terror = dir->i_op->rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tshrink_dcache_parent(dentry);\n\tdentry->d_inode->i_flags |= S_DEAD;\n\tdont_mount(dentry);\n\tdetach_mounts(dentry);\n\tfsnotify_rmdir(dir, dentry);\n\nout:\n\tinode_unlock(dentry->d_inode);\n\tdput(dentry);\n\tif (!error)\n\t\td_delete(dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_rmdir);\n\nlong do_rmdir(int dfd, const char __user *pathname)\n{\n\tint error = 0;\n\tstruct filename *name;\n\tstruct dentry *dentry;\n\tstruct path path;\n\tstruct qstr last;\n\tint type;\n\tunsigned int lookup_flags = 0;\nretry:\n\tname = filename_parentat(dfd, getname(pathname), lookup_flags,\n\t\t\t\t&path, &last, &type);\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\n\tswitch (type) {\n\tcase LAST_DOTDOT:\n\t\terror = -ENOTEMPTY;\n\t\tgoto exit1;\n\tcase LAST_DOT:\n\t\terror = -EINVAL;\n\t\tgoto exit1;\n\tcase LAST_ROOT:\n\t\terror = -EBUSY;\n\t\tgoto exit1;\n\t}\n\n\terror = mnt_want_write(path.mnt);\n\tif (error)\n\t\tgoto exit1;\n\n\tinode_lock_nested(path.dentry->d_inode, I_MUTEX_PARENT);\n\tdentry = __lookup_hash(&last, path.dentry, lookup_flags);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto exit2;\n\tif (!dentry->d_inode) {\n\t\terror = -ENOENT;\n\t\tgoto exit3;\n\t}\n\terror = security_path_rmdir(&path, dentry);\n\tif (error)\n\t\tgoto exit3;\n\terror = vfs_rmdir(path.dentry->d_inode, dentry);\nexit3:\n\tdput(dentry);\nexit2:\n\tinode_unlock(path.dentry->d_inode);\n\tmnt_drop_write(path.mnt);\nexit1:\n\tpath_put(&path);\n\tputname(name);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE1(rmdir, const char __user *, pathname)\n{\n\treturn do_rmdir(AT_FDCWD, pathname);\n}\n\n/**\n * vfs_unlink - unlink a filesystem object\n * @dir:\tparent directory\n * @dentry:\tvictim\n * @delegated_inode: returns victim inode, if the inode is delegated.\n *\n * The caller must hold dir->i_mutex.\n *\n * If vfs_unlink discovers a delegation, it will return -EWOULDBLOCK and\n * return a reference to the inode in delegated_inode.  The caller\n * should then break the delegation on that inode and retry.  Because\n * breaking a delegation may take a long time, the caller should drop\n * dir->i_mutex before doing so.\n *\n * Alternatively, a caller may pass NULL for delegated_inode.  This may\n * be appropriate for callers that expect the underlying filesystem not\n * to be NFS exported.\n */\nint vfs_unlink(struct inode *dir, struct dentry *dentry, struct inode **delegated_inode)\n{\n\tstruct inode *target = dentry->d_inode;\n\tint error = may_delete(dir, dentry, 0);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->unlink)\n\t\treturn -EPERM;\n\n\tinode_lock(target);\n\tif (is_local_mountpoint(dentry))\n\t\terror = -EBUSY;\n\telse {\n\t\terror = security_inode_unlink(dir, dentry);\n\t\tif (!error) {\n\t\t\terror = try_break_deleg(target, delegated_inode);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\terror = dir->i_op->unlink(dir, dentry);\n\t\t\tif (!error) {\n\t\t\t\tdont_mount(dentry);\n\t\t\t\tdetach_mounts(dentry);\n\t\t\t\tfsnotify_unlink(dir, dentry);\n\t\t\t}\n\t\t}\n\t}\nout:\n\tinode_unlock(target);\n\n\t/* We don't d_delete() NFS sillyrenamed files--they still exist. */\n\tif (!error && !(dentry->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\tfsnotify_link_count(target);\n\t\td_delete(dentry);\n\t}\n\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_unlink);\n\n/*\n * Make sure that the actual truncation of the file will occur outside its\n * directory's i_mutex.  Truncate can take a long time if there is a lot of\n * writeout happening, and we don't want to prevent access to the directory\n * while waiting on the I/O.\n */\nlong do_unlinkat(int dfd, struct filename *name)\n{\n\tint error;\n\tstruct dentry *dentry;\n\tstruct path path;\n\tstruct qstr last;\n\tint type;\n\tstruct inode *inode = NULL;\n\tstruct inode *delegated_inode = NULL;\n\tunsigned int lookup_flags = 0;\nretry:\n\tname = filename_parentat(dfd, name, lookup_flags, &path, &last, &type);\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\n\terror = -EISDIR;\n\tif (type != LAST_NORM)\n\t\tgoto exit1;\n\n\terror = mnt_want_write(path.mnt);\n\tif (error)\n\t\tgoto exit1;\nretry_deleg:\n\tinode_lock_nested(path.dentry->d_inode, I_MUTEX_PARENT);\n\tdentry = __lookup_hash(&last, path.dentry, lookup_flags);\n\terror = PTR_ERR(dentry);\n\tif (!IS_ERR(dentry)) {\n\t\t/* Why not before? Because we want correct error value */\n\t\tif (last.name[last.len])\n\t\t\tgoto slashes;\n\t\tinode = dentry->d_inode;\n\t\tif (d_is_negative(dentry))\n\t\t\tgoto slashes;\n\t\tihold(inode);\n\t\terror = security_path_unlink(&path, dentry);\n\t\tif (error)\n\t\t\tgoto exit2;\n\t\terror = vfs_unlink(path.dentry->d_inode, dentry, &delegated_inode);\nexit2:\n\t\tdput(dentry);\n\t}\n\tinode_unlock(path.dentry->d_inode);\n\tif (inode)\n\t\tiput(inode);\t/* truncate the inode here */\n\tinode = NULL;\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\tmnt_drop_write(path.mnt);\nexit1:\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tinode = NULL;\n\t\tgoto retry;\n\t}\n\tputname(name);\n\treturn error;\n\nslashes:\n\tif (d_is_negative(dentry))\n\t\terror = -ENOENT;\n\telse if (d_is_dir(dentry))\n\t\terror = -EISDIR;\n\telse\n\t\terror = -ENOTDIR;\n\tgoto exit2;\n}\n\nSYSCALL_DEFINE3(unlinkat, int, dfd, const char __user *, pathname, int, flag)\n{\n\tif ((flag & ~AT_REMOVEDIR) != 0)\n\t\treturn -EINVAL;\n\n\tif (flag & AT_REMOVEDIR)\n\t\treturn do_rmdir(dfd, pathname);\n\n\treturn do_unlinkat(dfd, getname(pathname));\n}\n\nSYSCALL_DEFINE1(unlink, const char __user *, pathname)\n{\n\treturn do_unlinkat(AT_FDCWD, getname(pathname));\n}\n\nint vfs_symlink(struct inode *dir, struct dentry *dentry, const char *oldname)\n{\n\tint error = may_create(dir, dentry);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->symlink)\n\t\treturn -EPERM;\n\n\terror = security_inode_symlink(dir, dentry, oldname);\n\tif (error)\n\t\treturn error;\n\n\terror = dir->i_op->symlink(dir, dentry, oldname);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_symlink);\n\nlong do_symlinkat(const char __user *oldname, int newdfd,\n\t\t  const char __user *newname)\n{\n\tint error;\n\tstruct filename *from;\n\tstruct dentry *dentry;\n\tstruct path path;\n\tunsigned int lookup_flags = 0;\n\n\tfrom = getname(oldname);\n\tif (IS_ERR(from))\n\t\treturn PTR_ERR(from);\nretry:\n\tdentry = user_path_create(newdfd, newname, &path, lookup_flags);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto out_putname;\n\n\terror = security_path_symlink(&path, dentry, from->name);\n\tif (!error)\n\t\terror = vfs_symlink(path.dentry->d_inode, dentry, from->name);\n\tdone_path_create(&path, dentry);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout_putname:\n\tputname(from);\n\treturn error;\n}\n\nSYSCALL_DEFINE3(symlinkat, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname)\n{\n\treturn do_symlinkat(oldname, newdfd, newname);\n}\n\nSYSCALL_DEFINE2(symlink, const char __user *, oldname, const char __user *, newname)\n{\n\treturn do_symlinkat(oldname, AT_FDCWD, newname);\n}\n\n/**\n * vfs_link - create a new link\n * @old_dentry:\tobject to be linked\n * @dir:\tnew parent\n * @new_dentry:\twhere to create the new link\n * @delegated_inode: returns inode needing a delegation break\n *\n * The caller must hold dir->i_mutex\n *\n * If vfs_link discovers a delegation on the to-be-linked file in need\n * of breaking, it will return -EWOULDBLOCK and return a reference to the\n * inode in delegated_inode.  The caller should then break the delegation\n * and retry.  Because breaking a delegation may take a long time, the\n * caller should drop the i_mutex before doing so.\n *\n * Alternatively, a caller may pass NULL for delegated_inode.  This may\n * be appropriate for callers that expect the underlying filesystem not\n * to be NFS exported.\n */\nint vfs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry, struct inode **delegated_inode)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\tunsigned max_links = dir->i_sb->s_max_links;\n\tint error;\n\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\terror = may_create(dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (dir->i_sb != inode->i_sb)\n\t\treturn -EXDEV;\n\n\t/*\n\t * A link to an append-only or immutable file cannot be created.\n\t */\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\t/*\n\t * Updating the link count will likely cause i_uid and i_gid to\n\t * be writen back improperly if their true value is unknown to\n\t * the vfs.\n\t */\n\tif (HAS_UNMAPPED_ID(inode))\n\t\treturn -EPERM;\n\tif (!dir->i_op->link)\n\t\treturn -EPERM;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EPERM;\n\n\terror = security_inode_link(old_dentry, dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\tinode_lock(inode);\n\t/* Make sure we don't allow creating hardlink to an unlinked file */\n\tif (inode->i_nlink == 0 && !(inode->i_state & I_LINKABLE))\n\t\terror =  -ENOENT;\n\telse if (max_links && inode->i_nlink >= max_links)\n\t\terror = -EMLINK;\n\telse {\n\t\terror = try_break_deleg(inode, delegated_inode);\n\t\tif (!error)\n\t\t\terror = dir->i_op->link(old_dentry, dir, new_dentry);\n\t}\n\n\tif (!error && (inode->i_state & I_LINKABLE)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state &= ~I_LINKABLE;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tinode_unlock(inode);\n\tif (!error)\n\t\tfsnotify_link(dir, inode, new_dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_link);\n\n/*\n * Hardlinks are often used in delicate situations.  We avoid\n * security-related surprises by not following symlinks on the\n * newname.  --KAB\n *\n * We don't follow them on the oldname either to be compatible\n * with linux 2.0, and to avoid hard-linking to directories\n * and other special files.  --ADM\n */\nint do_linkat(int olddfd, const char __user *oldname, int newdfd,\n\t      const char __user *newname, int flags)\n{\n\tstruct dentry *new_dentry;\n\tstruct path old_path, new_path;\n\tstruct inode *delegated_inode = NULL;\n\tint how = 0;\n\tint error;\n\n\tif ((flags & ~(AT_SYMLINK_FOLLOW | AT_EMPTY_PATH)) != 0)\n\t\treturn -EINVAL;\n\t/*\n\t * To use null names we require CAP_DAC_READ_SEARCH\n\t * This ensures that not everyone will be able to create\n\t * handlink using the passed filedescriptor.\n\t */\n\tif (flags & AT_EMPTY_PATH) {\n\t\tif (!capable(CAP_DAC_READ_SEARCH))\n\t\t\treturn -ENOENT;\n\t\thow = LOOKUP_EMPTY;\n\t}\n\n\tif (flags & AT_SYMLINK_FOLLOW)\n\t\thow |= LOOKUP_FOLLOW;\nretry:\n\terror = user_path_at(olddfd, oldname, how, &old_path);\n\tif (error)\n\t\treturn error;\n\n\tnew_dentry = user_path_create(newdfd, newname, &new_path,\n\t\t\t\t\t(how & LOOKUP_REVAL));\n\terror = PTR_ERR(new_dentry);\n\tif (IS_ERR(new_dentry))\n\t\tgoto out;\n\n\terror = -EXDEV;\n\tif (old_path.mnt != new_path.mnt)\n\t\tgoto out_dput;\n\terror = may_linkat(&old_path);\n\tif (unlikely(error))\n\t\tgoto out_dput;\n\terror = security_path_link(old_path.dentry, &new_path, new_dentry);\n\tif (error)\n\t\tgoto out_dput;\n\terror = vfs_link(old_path.dentry, new_path.dentry->d_inode, new_dentry, &delegated_inode);\nout_dput:\n\tdone_path_create(&new_path, new_dentry);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error) {\n\t\t\tpath_put(&old_path);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (retry_estale(error, how)) {\n\t\tpath_put(&old_path);\n\t\thow |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout:\n\tpath_put(&old_path);\n\n\treturn error;\n}\n\nSYSCALL_DEFINE5(linkat, int, olddfd, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname, int, flags)\n{\n\treturn do_linkat(olddfd, oldname, newdfd, newname, flags);\n}\n\nSYSCALL_DEFINE2(link, const char __user *, oldname, const char __user *, newname)\n{\n\treturn do_linkat(AT_FDCWD, oldname, AT_FDCWD, newname, 0);\n}\n\n/**\n * vfs_rename - rename a filesystem object\n * @old_dir:\tparent of source\n * @old_dentry:\tsource\n * @new_dir:\tparent of destination\n * @new_dentry:\tdestination\n * @delegated_inode: returns an inode needing a delegation break\n * @flags:\trename flags\n *\n * The caller must hold multiple mutexes--see lock_rename()).\n *\n * If vfs_rename discovers a delegation in need of breaking at either\n * the source or destination, it will return -EWOULDBLOCK and return a\n * reference to the inode in delegated_inode.  The caller should then\n * break the delegation and retry.  Because breaking a delegation may\n * take a long time, the caller should drop all locks before doing\n * so.\n *\n * Alternatively, a caller may pass NULL for delegated_inode.  This may\n * be appropriate for callers that expect the underlying filesystem not\n * to be NFS exported.\n *\n * The worst of all namespace operations - renaming directory. \"Perverted\"\n * doesn't even start to describe it. Somebody in UCB had a heck of a trip...\n * Problems:\n *\n *\ta) we can get into loop creation.\n *\tb) race potential - two innocent renames can create a loop together.\n *\t   That's where 4.4 screws up. Current fix: serialization on\n *\t   sb->s_vfs_rename_mutex. We might be more accurate, but that's another\n *\t   story.\n *\tc) we have to lock _four_ objects - parents and victim (if it exists),\n *\t   and source (if it is not a directory).\n *\t   And that - after we got ->i_mutex on parents (until then we don't know\n *\t   whether the target exists).  Solution: try to be smart with locking\n *\t   order for inodes.  We rely on the fact that tree topology may change\n *\t   only under ->s_vfs_rename_mutex _and_ that parent of the object we\n *\t   move will be locked.  Thus we can rank directories by the tree\n *\t   (ancestors first) and rank all non-directories after them.\n *\t   That works since everybody except rename does \"lock parent, lookup,\n *\t   lock child\" and rename is under ->s_vfs_rename_mutex.\n *\t   HOWEVER, it relies on the assumption that any object with ->lookup()\n *\t   has no more than 1 dentry.  If \"hybrid\" objects will ever appear,\n *\t   we'd better make sure that there's no link(2) for them.\n *\td) conversion from fhandle to dentry may come in the wrong moment - when\n *\t   we are removing the target. Solution: we will have to grab ->i_mutex\n *\t   in the fhandle_to_dentry code. [FIXME - current nfsfh.c relies on\n *\t   ->i_mutex on parents, which works but leads to some truly excessive\n *\t   locking].\n */\nint vfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t       struct inode *new_dir, struct dentry *new_dentry,\n\t       struct inode **delegated_inode, unsigned int flags)\n{\n\tint error;\n\tbool is_dir = d_is_dir(old_dentry);\n\tstruct inode *source = old_dentry->d_inode;\n\tstruct inode *target = new_dentry->d_inode;\n\tbool new_is_dir = false;\n\tunsigned max_links = new_dir->i_sb->s_max_links;\n\tstruct name_snapshot old_name;\n\n\tif (source == target)\n\t\treturn 0;\n\n\terror = may_delete(old_dir, old_dentry, is_dir);\n\tif (error)\n\t\treturn error;\n\n\tif (!target) {\n\t\terror = may_create(new_dir, new_dentry);\n\t} else {\n\t\tnew_is_dir = d_is_dir(new_dentry);\n\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\terror = may_delete(new_dir, new_dentry, is_dir);\n\t\telse\n\t\t\terror = may_delete(new_dir, new_dentry, new_is_dir);\n\t}\n\tif (error)\n\t\treturn error;\n\n\tif (!old_dir->i_op->rename)\n\t\treturn -EPERM;\n\n\t/*\n\t * If we are going to change the parent - check write permissions,\n\t * we'll need to flip '..'.\n\t */\n\tif (new_dir != old_dir) {\n\t\tif (is_dir) {\n\t\t\terror = inode_permission(source, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif ((flags & RENAME_EXCHANGE) && new_is_dir) {\n\t\t\terror = inode_permission(target, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry,\n\t\t\t\t      flags);\n\tif (error)\n\t\treturn error;\n\n\ttake_dentry_name_snapshot(&old_name, old_dentry);\n\tdget(new_dentry);\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tinode_lock(target);\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry))\n\t\tgoto out;\n\n\tif (max_links && new_dir != old_dir) {\n\t\terror = -EMLINK;\n\t\tif (is_dir && !new_is_dir && new_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t\tif ((flags & RENAME_EXCHANGE) && !is_dir && new_is_dir &&\n\t\t    old_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t}\n\tif (!is_dir) {\n\t\terror = try_break_deleg(source, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (target && !new_is_dir) {\n\t\terror = try_break_deleg(target, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\terror = old_dir->i_op->rename(old_dir, old_dentry,\n\t\t\t\t       new_dir, new_dentry, flags);\n\tif (error)\n\t\tgoto out;\n\n\tif (!(flags & RENAME_EXCHANGE) && target) {\n\t\tif (is_dir) {\n\t\t\tshrink_dcache_parent(new_dentry);\n\t\t\ttarget->i_flags |= S_DEAD;\n\t\t}\n\t\tdont_mount(new_dentry);\n\t\tdetach_mounts(new_dentry);\n\t}\n\tif (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE)) {\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\td_move(old_dentry, new_dentry);\n\t\telse\n\t\t\td_exchange(old_dentry, new_dentry);\n\t}\nout:\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tunlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tinode_unlock(target);\n\tdput(new_dentry);\n\tif (!error) {\n\t\tfsnotify_move(old_dir, new_dir, &old_name.name, is_dir,\n\t\t\t      !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry);\n\t\tif (flags & RENAME_EXCHANGE) {\n\t\t\tfsnotify_move(new_dir, old_dir, &old_dentry->d_name,\n\t\t\t\t      new_is_dir, NULL, new_dentry);\n\t\t}\n\t}\n\trelease_dentry_name_snapshot(&old_name);\n\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_rename);\n\nstatic int do_renameat2(int olddfd, const char __user *oldname, int newdfd,\n\t\t\tconst char __user *newname, unsigned int flags)\n{\n\tstruct dentry *old_dentry, *new_dentry;\n\tstruct dentry *trap;\n\tstruct path old_path, new_path;\n\tstruct qstr old_last, new_last;\n\tint old_type, new_type;\n\tstruct inode *delegated_inode = NULL;\n\tstruct filename *from;\n\tstruct filename *to;\n\tunsigned int lookup_flags = 0, target_flags = LOOKUP_RENAME_TARGET;\n\tbool should_retry = false;\n\tint error;\n\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))\n\t\treturn -EINVAL;\n\n\tif ((flags & (RENAME_NOREPLACE | RENAME_WHITEOUT)) &&\n\t    (flags & RENAME_EXCHANGE))\n\t\treturn -EINVAL;\n\n\tif ((flags & RENAME_WHITEOUT) && !capable(CAP_MKNOD))\n\t\treturn -EPERM;\n\n\tif (flags & RENAME_EXCHANGE)\n\t\ttarget_flags = 0;\n\nretry:\n\tfrom = filename_parentat(olddfd, getname(oldname), lookup_flags,\n\t\t\t\t&old_path, &old_last, &old_type);\n\tif (IS_ERR(from)) {\n\t\terror = PTR_ERR(from);\n\t\tgoto exit;\n\t}\n\n\tto = filename_parentat(newdfd, getname(newname), lookup_flags,\n\t\t\t\t&new_path, &new_last, &new_type);\n\tif (IS_ERR(to)) {\n\t\terror = PTR_ERR(to);\n\t\tgoto exit1;\n\t}\n\n\terror = -EXDEV;\n\tif (old_path.mnt != new_path.mnt)\n\t\tgoto exit2;\n\n\terror = -EBUSY;\n\tif (old_type != LAST_NORM)\n\t\tgoto exit2;\n\n\tif (flags & RENAME_NOREPLACE)\n\t\terror = -EEXIST;\n\tif (new_type != LAST_NORM)\n\t\tgoto exit2;\n\n\terror = mnt_want_write(old_path.mnt);\n\tif (error)\n\t\tgoto exit2;\n\nretry_deleg:\n\ttrap = lock_rename(new_path.dentry, old_path.dentry);\n\n\told_dentry = __lookup_hash(&old_last, old_path.dentry, lookup_flags);\n\terror = PTR_ERR(old_dentry);\n\tif (IS_ERR(old_dentry))\n\t\tgoto exit3;\n\t/* source must exist */\n\terror = -ENOENT;\n\tif (d_is_negative(old_dentry))\n\t\tgoto exit4;\n\tnew_dentry = __lookup_hash(&new_last, new_path.dentry, lookup_flags | target_flags);\n\terror = PTR_ERR(new_dentry);\n\tif (IS_ERR(new_dentry))\n\t\tgoto exit4;\n\terror = -EEXIST;\n\tif ((flags & RENAME_NOREPLACE) && d_is_positive(new_dentry))\n\t\tgoto exit5;\n\tif (flags & RENAME_EXCHANGE) {\n\t\terror = -ENOENT;\n\t\tif (d_is_negative(new_dentry))\n\t\t\tgoto exit5;\n\n\t\tif (!d_is_dir(new_dentry)) {\n\t\t\terror = -ENOTDIR;\n\t\t\tif (new_last.name[new_last.len])\n\t\t\t\tgoto exit5;\n\t\t}\n\t}\n\t/* unless the source is a directory trailing slashes give -ENOTDIR */\n\tif (!d_is_dir(old_dentry)) {\n\t\terror = -ENOTDIR;\n\t\tif (old_last.name[old_last.len])\n\t\t\tgoto exit5;\n\t\tif (!(flags & RENAME_EXCHANGE) && new_last.name[new_last.len])\n\t\t\tgoto exit5;\n\t}\n\t/* source should not be ancestor of target */\n\terror = -EINVAL;\n\tif (old_dentry == trap)\n\t\tgoto exit5;\n\t/* target should not be an ancestor of source */\n\tif (!(flags & RENAME_EXCHANGE))\n\t\terror = -ENOTEMPTY;\n\tif (new_dentry == trap)\n\t\tgoto exit5;\n\n\terror = security_path_rename(&old_path, old_dentry,\n\t\t\t\t     &new_path, new_dentry, flags);\n\tif (error)\n\t\tgoto exit5;\n\terror = vfs_rename(old_path.dentry->d_inode, old_dentry,\n\t\t\t   new_path.dentry->d_inode, new_dentry,\n\t\t\t   &delegated_inode, flags);\nexit5:\n\tdput(new_dentry);\nexit4:\n\tdput(old_dentry);\nexit3:\n\tunlock_rename(new_path.dentry, old_path.dentry);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\tmnt_drop_write(old_path.mnt);\nexit2:\n\tif (retry_estale(error, lookup_flags))\n\t\tshould_retry = true;\n\tpath_put(&new_path);\n\tputname(to);\nexit1:\n\tpath_put(&old_path);\n\tputname(from);\n\tif (should_retry) {\n\t\tshould_retry = false;\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nexit:\n\treturn error;\n}\n\nSYSCALL_DEFINE5(renameat2, int, olddfd, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname, unsigned int, flags)\n{\n\treturn do_renameat2(olddfd, oldname, newdfd, newname, flags);\n}\n\nSYSCALL_DEFINE4(renameat, int, olddfd, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname)\n{\n\treturn do_renameat2(olddfd, oldname, newdfd, newname, 0);\n}\n\nSYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)\n{\n\treturn do_renameat2(AT_FDCWD, oldname, AT_FDCWD, newname, 0);\n}\n\nint vfs_whiteout(struct inode *dir, struct dentry *dentry)\n{\n\tint error = may_create(dir, dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->mknod)\n\t\treturn -EPERM;\n\n\treturn dir->i_op->mknod(dir, dentry,\n\t\t\t\tS_IFCHR | WHITEOUT_MODE, WHITEOUT_DEV);\n}\nEXPORT_SYMBOL(vfs_whiteout);\n\nint readlink_copy(char __user *buffer, int buflen, const char *link)\n{\n\tint len = PTR_ERR(link);\n\tif (IS_ERR(link))\n\t\tgoto out;\n\n\tlen = strlen(link);\n\tif (len > (unsigned) buflen)\n\t\tlen = buflen;\n\tif (copy_to_user(buffer, link, len))\n\t\tlen = -EFAULT;\nout:\n\treturn len;\n}\n\n/**\n * vfs_readlink - copy symlink body into userspace buffer\n * @dentry: dentry on which to get symbolic link\n * @buffer: user memory pointer\n * @buflen: size of buffer\n *\n * Does not touch atime.  That's up to the caller if necessary\n *\n * Does not call security hook.\n */\nint vfs_readlink(struct dentry *dentry, char __user *buffer, int buflen)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tDEFINE_DELAYED_CALL(done);\n\tconst char *link;\n\tint res;\n\n\tif (unlikely(!(inode->i_opflags & IOP_DEFAULT_READLINK))) {\n\t\tif (unlikely(inode->i_op->readlink))\n\t\t\treturn inode->i_op->readlink(dentry, buffer, buflen);\n\n\t\tif (!d_is_symlink(dentry))\n\t\t\treturn -EINVAL;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_opflags |= IOP_DEFAULT_READLINK;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\n\tlink = READ_ONCE(inode->i_link);\n\tif (!link) {\n\t\tlink = inode->i_op->get_link(dentry, inode, &done);\n\t\tif (IS_ERR(link))\n\t\t\treturn PTR_ERR(link);\n\t}\n\tres = readlink_copy(buffer, buflen, link);\n\tdo_delayed_call(&done);\n\treturn res;\n}\nEXPORT_SYMBOL(vfs_readlink);\n\n/**\n * vfs_get_link - get symlink body\n * @dentry: dentry on which to get symbolic link\n * @done: caller needs to free returned data with this\n *\n * Calls security hook and i_op->get_link() on the supplied inode.\n *\n * It does not touch atime.  That's up to the caller if necessary.\n *\n * Does not work on \"special\" symlinks like /proc/$$/fd/N\n */\nconst char *vfs_get_link(struct dentry *dentry, struct delayed_call *done)\n{\n\tconst char *res = ERR_PTR(-EINVAL);\n\tstruct inode *inode = d_inode(dentry);\n\n\tif (d_is_symlink(dentry)) {\n\t\tres = ERR_PTR(security_inode_readlink(dentry));\n\t\tif (!res)\n\t\t\tres = inode->i_op->get_link(dentry, inode, done);\n\t}\n\treturn res;\n}\nEXPORT_SYMBOL(vfs_get_link);\n\n/* get the link contents into pagecache */\nconst char *page_get_link(struct dentry *dentry, struct inode *inode,\n\t\t\t  struct delayed_call *callback)\n{\n\tchar *kaddr;\n\tstruct page *page;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\tif (!dentry) {\n\t\tpage = find_get_page(mapping, 0);\n\t\tif (!page)\n\t\t\treturn ERR_PTR(-ECHILD);\n\t\tif (!PageUptodate(page)) {\n\t\t\tput_page(page);\n\t\t\treturn ERR_PTR(-ECHILD);\n\t\t}\n\t} else {\n\t\tpage = read_mapping_page(mapping, 0, NULL);\n\t\tif (IS_ERR(page))\n\t\t\treturn (char*)page;\n\t}\n\tset_delayed_call(callback, page_put_link, page);\n\tBUG_ON(mapping_gfp_mask(mapping) & __GFP_HIGHMEM);\n\tkaddr = page_address(page);\n\tnd_terminate_link(kaddr, inode->i_size, PAGE_SIZE - 1);\n\treturn kaddr;\n}\n\nEXPORT_SYMBOL(page_get_link);\n\nvoid page_put_link(void *arg)\n{\n\tput_page(arg);\n}\nEXPORT_SYMBOL(page_put_link);\n\nint page_readlink(struct dentry *dentry, char __user *buffer, int buflen)\n{\n\tDEFINE_DELAYED_CALL(done);\n\tint res = readlink_copy(buffer, buflen,\n\t\t\t\tpage_get_link(dentry, d_inode(dentry),\n\t\t\t\t\t      &done));\n\tdo_delayed_call(&done);\n\treturn res;\n}\nEXPORT_SYMBOL(page_readlink);\n\n/*\n * The nofs argument instructs pagecache_write_begin to pass AOP_FLAG_NOFS\n */\nint __page_symlink(struct inode *inode, const char *symname, int len, int nofs)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tvoid *fsdata;\n\tint err;\n\tunsigned int flags = 0;\n\tif (nofs)\n\t\tflags |= AOP_FLAG_NOFS;\n\nretry:\n\terr = pagecache_write_begin(NULL, mapping, 0, len-1,\n\t\t\t\tflags, &page, &fsdata);\n\tif (err)\n\t\tgoto fail;\n\n\tmemcpy(page_address(page), symname, len-1);\n\n\terr = pagecache_write_end(NULL, mapping, 0, len-1, len-1,\n\t\t\t\t\t\t\tpage, fsdata);\n\tif (err < 0)\n\t\tgoto fail;\n\tif (err < len-1)\n\t\tgoto retry;\n\n\tmark_inode_dirty(inode);\n\treturn 0;\nfail:\n\treturn err;\n}\nEXPORT_SYMBOL(__page_symlink);\n\nint page_symlink(struct inode *inode, const char *symname, int len)\n{\n\treturn __page_symlink(inode, symname, len,\n\t\t\t!mapping_gfp_constraint(inode->i_mapping, __GFP_FS));\n}\nEXPORT_SYMBOL(page_symlink);\n\nconst struct inode_operations page_symlink_inode_operations = {\n\t.get_link\t= page_get_link,\n};\nEXPORT_SYMBOL(page_symlink_inode_operations);\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n *  linux/fs/namei.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n */\n\n/*\n * Some corrections by tytso.\n */\n\n/* [Feb 1997 T. Schoebel-Theuer] Complete rewrite of the pathname\n * lookup logic.\n */\n/* [Feb-Apr 2000, AV] Rewrite to the new namespace architecture.\n */\n\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/personality.h>\n#include <linux/security.h>\n#include <linux/ima.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/device_cgroup.h>\n#include <linux/fs_struct.h>\n#include <linux/posix_acl.h>\n#include <linux/hash.h>\n#include <linux/bitops.h>\n#include <linux/init_task.h>\n#include <linux/uaccess.h>\n\n#include \"internal.h\"\n#include \"mount.h\"\n\n/* [Feb-1997 T. Schoebel-Theuer]\n * Fundamental changes in the pathname lookup mechanisms (namei)\n * were necessary because of omirr.  The reason is that omirr needs\n * to know the _real_ pathname, not the user-supplied one, in case\n * of symlinks (and also when transname replacements occur).\n *\n * The new code replaces the old recursive symlink resolution with\n * an iterative one (in case of non-nested symlink chains).  It does\n * this with calls to <fs>_follow_link().\n * As a side effect, dir_namei(), _namei() and follow_link() are now \n * replaced with a single function lookup_dentry() that can handle all \n * the special cases of the former code.\n *\n * With the new dcache, the pathname is stored at each inode, at least as\n * long as the refcount of the inode is positive.  As a side effect, the\n * size of the dcache depends on the inode cache and thus is dynamic.\n *\n * [29-Apr-1998 C. Scott Ananian] Updated above description of symlink\n * resolution to correspond with current state of the code.\n *\n * Note that the symlink resolution is not *completely* iterative.\n * There is still a significant amount of tail- and mid- recursion in\n * the algorithm.  Also, note that <fs>_readlink() is not used in\n * lookup_dentry(): lookup_dentry() on the result of <fs>_readlink()\n * may return different results than <fs>_follow_link().  Many virtual\n * filesystems (including /proc) exhibit this behavior.\n */\n\n/* [24-Feb-97 T. Schoebel-Theuer] Side effects caused by new implementation:\n * New symlink semantics: when open() is called with flags O_CREAT | O_EXCL\n * and the name already exists in form of a symlink, try to create the new\n * name indicated by the symlink. The old code always complained that the\n * name already exists, due to not following the symlink even if its target\n * is nonexistent.  The new semantics affects also mknod() and link() when\n * the name is a symlink pointing to a non-existent name.\n *\n * I don't know which semantics is the right one, since I have no access\n * to standards. But I found by trial that HP-UX 9.0 has the full \"new\"\n * semantics implemented, while SunOS 4.1.1 and Solaris (SunOS 5.4) have the\n * \"old\" one. Personally, I think the new semantics is much more logical.\n * Note that \"ln old new\" where \"new\" is a symlink pointing to a non-existing\n * file does succeed in both HP-UX and SunOs, but not in Solaris\n * and in the old Linux semantics.\n */\n\n/* [16-Dec-97 Kevin Buhr] For security reasons, we change some symlink\n * semantics.  See the comments in \"open_namei\" and \"do_link\" below.\n *\n * [10-Sep-98 Alan Modra] Another symlink change.\n */\n\n/* [Feb-Apr 2000 AV] Complete rewrite. Rules for symlinks:\n *\tinside the path - always follow.\n *\tin the last component in creation/removal/renaming - never follow.\n *\tif LOOKUP_FOLLOW passed - follow.\n *\tif the pathname has trailing slashes - follow.\n *\totherwise - don't follow.\n * (applied in that order).\n *\n * [Jun 2000 AV] Inconsistent behaviour of open() in case if flags==O_CREAT\n * restored for 2.4. This is the last surviving part of old 4.2BSD bug.\n * During the 2.4 we need to fix the userland stuff depending on it -\n * hopefully we will be able to get rid of that wart in 2.5. So far only\n * XEmacs seems to be relying on it...\n */\n/*\n * [Sep 2001 AV] Single-semaphore locking scheme (kudos to David Holland)\n * implemented.  Let's see if raised priority of ->s_vfs_rename_mutex gives\n * any extra contention...\n */\n\n/* In order to reduce some races, while at the same time doing additional\n * checking and hopefully speeding things up, we copy filenames to the\n * kernel data space before using them..\n *\n * POSIX.1 2.4: an empty pathname is invalid (ENOENT).\n * PATH_MAX includes the nul terminator --RR.\n */\n\n#define EMBEDDED_NAME_MAX\t(PATH_MAX - offsetof(struct filename, iname))\n\nstruct filename *\ngetname_flags(const char __user *filename, int flags, int *empty)\n{\n\tstruct filename *result;\n\tchar *kname;\n\tint len;\n\n\tresult = audit_reusename(filename);\n\tif (result)\n\t\treturn result;\n\n\tresult = __getname();\n\tif (unlikely(!result))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/*\n\t * First, try to embed the struct filename inside the names_cache\n\t * allocation\n\t */\n\tkname = (char *)result->iname;\n\tresult->name = kname;\n\n\tlen = strncpy_from_user(kname, filename, EMBEDDED_NAME_MAX);\n\tif (unlikely(len < 0)) {\n\t\t__putname(result);\n\t\treturn ERR_PTR(len);\n\t}\n\n\t/*\n\t * Uh-oh. We have a name that's approaching PATH_MAX. Allocate a\n\t * separate struct filename so we can dedicate the entire\n\t * names_cache allocation for the pathname, and re-do the copy from\n\t * userland.\n\t */\n\tif (unlikely(len == EMBEDDED_NAME_MAX)) {\n\t\tconst size_t size = offsetof(struct filename, iname[1]);\n\t\tkname = (char *)result;\n\n\t\t/*\n\t\t * size is chosen that way we to guarantee that\n\t\t * result->iname[0] is within the same object and that\n\t\t * kname can't be equal to result->iname, no matter what.\n\t\t */\n\t\tresult = kzalloc(size, GFP_KERNEL);\n\t\tif (unlikely(!result)) {\n\t\t\t__putname(kname);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\tresult->name = kname;\n\t\tlen = strncpy_from_user(kname, filename, PATH_MAX);\n\t\tif (unlikely(len < 0)) {\n\t\t\t__putname(kname);\n\t\t\tkfree(result);\n\t\t\treturn ERR_PTR(len);\n\t\t}\n\t\tif (unlikely(len == PATH_MAX)) {\n\t\t\t__putname(kname);\n\t\t\tkfree(result);\n\t\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t\t}\n\t}\n\n\tresult->refcnt = 1;\n\t/* The empty path is special. */\n\tif (unlikely(!len)) {\n\t\tif (empty)\n\t\t\t*empty = 1;\n\t\tif (!(flags & LOOKUP_EMPTY)) {\n\t\t\tputname(result);\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\t}\n\t}\n\n\tresult->uptr = filename;\n\tresult->aname = NULL;\n\taudit_getname(result);\n\treturn result;\n}\n\nstruct filename *\ngetname(const char __user * filename)\n{\n\treturn getname_flags(filename, 0, NULL);\n}\n\nstruct filename *\ngetname_kernel(const char * filename)\n{\n\tstruct filename *result;\n\tint len = strlen(filename) + 1;\n\n\tresult = __getname();\n\tif (unlikely(!result))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (len <= EMBEDDED_NAME_MAX) {\n\t\tresult->name = (char *)result->iname;\n\t} else if (len <= PATH_MAX) {\n\t\tconst size_t size = offsetof(struct filename, iname[1]);\n\t\tstruct filename *tmp;\n\n\t\ttmp = kmalloc(size, GFP_KERNEL);\n\t\tif (unlikely(!tmp)) {\n\t\t\t__putname(result);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\ttmp->name = (char *)result;\n\t\tresult = tmp;\n\t} else {\n\t\t__putname(result);\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\tmemcpy((char *)result->name, filename, len);\n\tresult->uptr = NULL;\n\tresult->aname = NULL;\n\tresult->refcnt = 1;\n\taudit_getname(result);\n\n\treturn result;\n}\n\nvoid putname(struct filename *name)\n{\n\tBUG_ON(name->refcnt <= 0);\n\n\tif (--name->refcnt > 0)\n\t\treturn;\n\n\tif (name->name != name->iname) {\n\t\t__putname(name->name);\n\t\tkfree(name);\n\t} else\n\t\t__putname(name);\n}\n\nstatic int check_acl(struct inode *inode, int mask)\n{\n#ifdef CONFIG_FS_POSIX_ACL\n\tstruct posix_acl *acl;\n\n\tif (mask & MAY_NOT_BLOCK) {\n\t\tacl = get_cached_acl_rcu(inode, ACL_TYPE_ACCESS);\n\t        if (!acl)\n\t                return -EAGAIN;\n\t\t/* no ->get_acl() calls in RCU mode... */\n\t\tif (is_uncached_acl(acl))\n\t\t\treturn -ECHILD;\n\t        return posix_acl_permission(inode, acl, mask & ~MAY_NOT_BLOCK);\n\t}\n\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR(acl))\n\t\treturn PTR_ERR(acl);\n\tif (acl) {\n\t        int error = posix_acl_permission(inode, acl, mask);\n\t        posix_acl_release(acl);\n\t        return error;\n\t}\n#endif\n\n\treturn -EAGAIN;\n}\n\n/*\n * This does the basic permission checking\n */\nstatic int acl_permission_check(struct inode *inode, int mask)\n{\n\tunsigned int mode = inode->i_mode;\n\n\tif (likely(uid_eq(current_fsuid(), inode->i_uid)))\n\t\tmode >>= 6;\n\telse {\n\t\tif (IS_POSIXACL(inode) && (mode & S_IRWXG)) {\n\t\t\tint error = check_acl(inode, mask);\n\t\t\tif (error != -EAGAIN)\n\t\t\t\treturn error;\n\t\t}\n\n\t\tif (in_group_p(inode->i_gid))\n\t\t\tmode >>= 3;\n\t}\n\n\t/*\n\t * If the DACs are ok we don't need any capability check.\n\t */\n\tif ((mask & ~mode & (MAY_READ | MAY_WRITE | MAY_EXEC)) == 0)\n\t\treturn 0;\n\treturn -EACCES;\n}\n\n/**\n * generic_permission -  check for access rights on a Posix-like filesystem\n * @inode:\tinode to check access rights for\n * @mask:\tright to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC, ...)\n *\n * Used to check for read/write/execute permissions on a file.\n * We use \"fsuid\" for this, letting us set arbitrary permissions\n * for filesystem access without changing the \"normal\" uids which\n * are used for other things.\n *\n * generic_permission is rcu-walk aware. It returns -ECHILD in case an rcu-walk\n * request cannot be satisfied (eg. requires blocking or too much complexity).\n * It would then be called again in ref-walk mode.\n */\nint generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}\nEXPORT_SYMBOL(generic_permission);\n\n/*\n * We _really_ want to just do \"generic_permission()\" without\n * even looking at the inode->i_op values. So we keep a cache\n * flag in inode->i_opflags, that says \"this has not special\n * permission function, use the fast case\".\n */\nstatic inline int do_inode_permission(struct inode *inode, int mask)\n{\n\tif (unlikely(!(inode->i_opflags & IOP_FASTPERM))) {\n\t\tif (likely(inode->i_op->permission))\n\t\t\treturn inode->i_op->permission(inode, mask);\n\n\t\t/* This gets set once for the inode lifetime */\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_opflags |= IOP_FASTPERM;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn generic_permission(inode, mask);\n}\n\n/**\n * sb_permission - Check superblock-level permissions\n * @sb: Superblock of inode to check permission on\n * @inode: Inode to check permission on\n * @mask: Right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC)\n *\n * Separate out file-system wide checks from inode-specific permission checks.\n */\nstatic int sb_permission(struct super_block *sb, struct inode *inode, int mask)\n{\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\tumode_t mode = inode->i_mode;\n\n\t\t/* Nobody gets write access to a read-only fs. */\n\t\tif (sb_rdonly(sb) && (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))\n\t\t\treturn -EROFS;\n\t}\n\treturn 0;\n}\n\n/**\n * inode_permission - Check for access rights to a given inode\n * @inode: Inode to check permission on\n * @mask: Right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC)\n *\n * Check for read/write/execute permissions on an inode.  We use fs[ug]id for\n * this, letting us set arbitrary permissions for filesystem access without\n * changing the \"normal\" UIDs which are used for other things.\n *\n * When checking for MAY_APPEND, MAY_WRITE must also be set in @mask.\n */\nint inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\t/*\n\t\t * Nobody gets write access to an immutable file.\n\t\t */\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Updating mtime will likely cause i_uid and i_gid to be\n\t\t * written back improperly if their true value is unknown\n\t\t * to the vfs.\n\t\t */\n\t\tif (HAS_UNMAPPED_ID(inode))\n\t\t\treturn -EACCES;\n\t}\n\n\tretval = do_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = devcgroup_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\treturn security_inode_permission(inode, mask);\n}\nEXPORT_SYMBOL(inode_permission);\n\n/**\n * path_get - get a reference to a path\n * @path: path to get the reference to\n *\n * Given a path increment the reference count to the dentry and the vfsmount.\n */\nvoid path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}\nEXPORT_SYMBOL(path_get);\n\n/**\n * path_put - put a reference to a path\n * @path: path to put the reference to\n *\n * Given a path decrement the reference count to the dentry and the vfsmount.\n */\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}\nEXPORT_SYMBOL(path_put);\n\n#define EMBEDDED_LEVELS 2\nstruct nameidata {\n\tstruct path\tpath;\n\tstruct qstr\tlast;\n\tstruct path\troot;\n\tstruct inode\t*inode; /* path.dentry.d_inode */\n\tunsigned int\tflags;\n\tunsigned\tseq, m_seq;\n\tint\t\tlast_type;\n\tunsigned\tdepth;\n\tint\t\ttotal_link_count;\n\tstruct saved {\n\t\tstruct path link;\n\t\tstruct delayed_call done;\n\t\tconst char *name;\n\t\tunsigned seq;\n\t} *stack, internal[EMBEDDED_LEVELS];\n\tstruct filename\t*name;\n\tstruct nameidata *saved;\n\tstruct inode\t*link_inode;\n\tunsigned\troot_seq;\n\tint\t\tdfd;\n} __randomize_layout;\n\nstatic void set_nameidata(struct nameidata *p, int dfd, struct filename *name)\n{\n\tstruct nameidata *old = current->nameidata;\n\tp->stack = p->internal;\n\tp->dfd = dfd;\n\tp->name = name;\n\tp->total_link_count = old ? old->total_link_count : 0;\n\tp->saved = old;\n\tcurrent->nameidata = p;\n}\n\nstatic void restore_nameidata(void)\n{\n\tstruct nameidata *now = current->nameidata, *old = now->saved;\n\n\tcurrent->nameidata = old;\n\tif (old)\n\t\told->total_link_count = now->total_link_count;\n\tif (now->stack != now->internal)\n\t\tkfree(now->stack);\n}\n\nstatic int __nd_alloc_stack(struct nameidata *nd)\n{\n\tstruct saved *p;\n\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tp= kmalloc_array(MAXSYMLINKS, sizeof(struct saved),\n\t\t\t\t  GFP_ATOMIC);\n\t\tif (unlikely(!p))\n\t\t\treturn -ECHILD;\n\t} else {\n\t\tp= kmalloc_array(MAXSYMLINKS, sizeof(struct saved),\n\t\t\t\t  GFP_KERNEL);\n\t\tif (unlikely(!p))\n\t\t\treturn -ENOMEM;\n\t}\n\tmemcpy(p, nd->internal, sizeof(nd->internal));\n\tnd->stack = p;\n\treturn 0;\n}\n\n/**\n * path_connected - Verify that a path->dentry is below path->mnt.mnt_root\n * @path: nameidate to verify\n *\n * Rename can sometimes move a file or directory outside of a bind\n * mount, path_connected allows those cases to be detected.\n */\nstatic bool path_connected(const struct path *path)\n{\n\tstruct vfsmount *mnt = path->mnt;\n\tstruct super_block *sb = mnt->mnt_sb;\n\n\t/* Bind mounts and multi-root filesystems can have disconnected paths */\n\tif (!(sb->s_iflags & SB_I_MULTIROOT) && (mnt->mnt_root == sb->s_root))\n\t\treturn true;\n\n\treturn is_subdir(path->dentry, mnt->mnt_root);\n}\n\nstatic inline int nd_alloc_stack(struct nameidata *nd)\n{\n\tif (likely(nd->depth != EMBEDDED_LEVELS))\n\t\treturn 0;\n\tif (likely(nd->stack != nd->internal))\n\t\treturn 0;\n\treturn __nd_alloc_stack(nd);\n}\n\nstatic void drop_links(struct nameidata *nd)\n{\n\tint i = nd->depth;\n\twhile (i--) {\n\t\tstruct saved *last = nd->stack + i;\n\t\tdo_delayed_call(&last->done);\n\t\tclear_delayed_call(&last->done);\n\t}\n}\n\nstatic void terminate_walk(struct nameidata *nd)\n{\n\tdrop_links(nd);\n\tif (!(nd->flags & LOOKUP_RCU)) {\n\t\tint i;\n\t\tpath_put(&nd->path);\n\t\tfor (i = 0; i < nd->depth; i++)\n\t\t\tpath_put(&nd->stack[i].link);\n\t\tif (nd->flags & LOOKUP_ROOT_GRABBED) {\n\t\t\tpath_put(&nd->root);\n\t\t\tnd->flags &= ~LOOKUP_ROOT_GRABBED;\n\t\t}\n\t} else {\n\t\tnd->flags &= ~LOOKUP_RCU;\n\t\trcu_read_unlock();\n\t}\n\tnd->depth = 0;\n}\n\n/* path_put is needed afterwards regardless of success or failure */\nstatic bool legitimize_path(struct nameidata *nd,\n\t\t\t    struct path *path, unsigned seq)\n{\n\tint res = __legitimize_mnt(path->mnt, nd->m_seq);\n\tif (unlikely(res)) {\n\t\tif (res > 0)\n\t\t\tpath->mnt = NULL;\n\t\tpath->dentry = NULL;\n\t\treturn false;\n\t}\n\tif (unlikely(!lockref_get_not_dead(&path->dentry->d_lockref))) {\n\t\tpath->dentry = NULL;\n\t\treturn false;\n\t}\n\treturn !read_seqcount_retry(&path->dentry->d_seq, seq);\n}\n\nstatic bool legitimize_links(struct nameidata *nd)\n{\n\tint i;\n\tfor (i = 0; i < nd->depth; i++) {\n\t\tstruct saved *last = nd->stack + i;\n\t\tif (unlikely(!legitimize_path(nd, &last->link, last->seq))) {\n\t\t\tdrop_links(nd);\n\t\t\tnd->depth = i + 1;\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic bool legitimize_root(struct nameidata *nd)\n{\n\tif (!nd->root.mnt || (nd->flags & LOOKUP_ROOT))\n\t\treturn true;\n\tnd->flags |= LOOKUP_ROOT_GRABBED;\n\treturn legitimize_path(nd, &nd->root, nd->root_seq);\n}\n\n/*\n * Path walking has 2 modes, rcu-walk and ref-walk (see\n * Documentation/filesystems/path-lookup.txt).  In situations when we can't\n * continue in RCU mode, we attempt to drop out of rcu-walk mode and grab\n * normal reference counts on dentries and vfsmounts to transition to ref-walk\n * mode.  Refcounts are grabbed at the last known good point before rcu-walk\n * got stuck, so ref-walk may continue from there. If this is not successful\n * (eg. a seqcount has changed), then failure is returned and it's up to caller\n * to restart the path walk from the beginning in ref-walk mode.\n */\n\n/**\n * unlazy_walk - try to switch to ref-walk mode.\n * @nd: nameidata pathwalk data\n * Returns: 0 on success, -ECHILD on failure\n *\n * unlazy_walk attempts to legitimize the current nd->path and nd->root\n * for ref-walk mode.\n * Must be called from rcu-walk context.\n * Nothing should touch nameidata between unlazy_walk() failure and\n * terminate_walk().\n */\nstatic int unlazy_walk(struct nameidata *nd)\n{\n\tstruct dentry *parent = nd->path.dentry;\n\n\tBUG_ON(!(nd->flags & LOOKUP_RCU));\n\n\tnd->flags &= ~LOOKUP_RCU;\n\tif (unlikely(!legitimize_links(nd)))\n\t\tgoto out1;\n\tif (unlikely(!legitimize_path(nd, &nd->path, nd->seq)))\n\t\tgoto out;\n\tif (unlikely(!legitimize_root(nd)))\n\t\tgoto out;\n\trcu_read_unlock();\n\tBUG_ON(nd->inode != parent->d_inode);\n\treturn 0;\n\nout1:\n\tnd->path.mnt = NULL;\n\tnd->path.dentry = NULL;\nout:\n\trcu_read_unlock();\n\treturn -ECHILD;\n}\n\n/**\n * unlazy_child - try to switch to ref-walk mode.\n * @nd: nameidata pathwalk data\n * @dentry: child of nd->path.dentry\n * @seq: seq number to check dentry against\n * Returns: 0 on success, -ECHILD on failure\n *\n * unlazy_child attempts to legitimize the current nd->path, nd->root and dentry\n * for ref-walk mode.  @dentry must be a path found by a do_lookup call on\n * @nd.  Must be called from rcu-walk context.\n * Nothing should touch nameidata between unlazy_child() failure and\n * terminate_walk().\n */\nstatic int unlazy_child(struct nameidata *nd, struct dentry *dentry, unsigned seq)\n{\n\tBUG_ON(!(nd->flags & LOOKUP_RCU));\n\n\tnd->flags &= ~LOOKUP_RCU;\n\tif (unlikely(!legitimize_links(nd)))\n\t\tgoto out2;\n\tif (unlikely(!legitimize_mnt(nd->path.mnt, nd->m_seq)))\n\t\tgoto out2;\n\tif (unlikely(!lockref_get_not_dead(&nd->path.dentry->d_lockref)))\n\t\tgoto out1;\n\n\t/*\n\t * We need to move both the parent and the dentry from the RCU domain\n\t * to be properly refcounted. And the sequence number in the dentry\n\t * validates *both* dentry counters, since we checked the sequence\n\t * number of the parent after we got the child sequence number. So we\n\t * know the parent must still be valid if the child sequence number is\n\t */\n\tif (unlikely(!lockref_get_not_dead(&dentry->d_lockref)))\n\t\tgoto out;\n\tif (unlikely(read_seqcount_retry(&dentry->d_seq, seq)))\n\t\tgoto out_dput;\n\t/*\n\t * Sequence counts matched. Now make sure that the root is\n\t * still valid and get it if required.\n\t */\n\tif (unlikely(!legitimize_root(nd)))\n\t\tgoto out_dput;\n\trcu_read_unlock();\n\treturn 0;\n\nout2:\n\tnd->path.mnt = NULL;\nout1:\n\tnd->path.dentry = NULL;\nout:\n\trcu_read_unlock();\n\treturn -ECHILD;\nout_dput:\n\trcu_read_unlock();\n\tdput(dentry);\n\treturn -ECHILD;\n}\n\nstatic inline int d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tif (unlikely(dentry->d_flags & DCACHE_OP_REVALIDATE))\n\t\treturn dentry->d_op->d_revalidate(dentry, flags);\n\telse\n\t\treturn 1;\n}\n\n/**\n * complete_walk - successful completion of path walk\n * @nd:  pointer nameidata\n *\n * If we had been in RCU mode, drop out of it and legitimize nd->path.\n * Revalidate the final result, unless we'd already done that during\n * the path walk or the filesystem doesn't ask for it.  Return 0 on\n * success, -error on failure.  In case of failure caller does not\n * need to drop nd->path.\n */\nstatic int complete_walk(struct nameidata *nd)\n{\n\tstruct dentry *dentry = nd->path.dentry;\n\tint status;\n\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tif (!(nd->flags & LOOKUP_ROOT))\n\t\t\tnd->root.mnt = NULL;\n\t\tif (unlikely(unlazy_walk(nd)))\n\t\t\treturn -ECHILD;\n\t}\n\n\tif (likely(!(nd->flags & LOOKUP_JUMPED)))\n\t\treturn 0;\n\n\tif (likely(!(dentry->d_flags & DCACHE_OP_WEAK_REVALIDATE)))\n\t\treturn 0;\n\n\tstatus = dentry->d_op->d_weak_revalidate(dentry, nd->flags);\n\tif (status > 0)\n\t\treturn 0;\n\n\tif (!status)\n\t\tstatus = -ESTALE;\n\n\treturn status;\n}\n\nstatic void set_root(struct nameidata *nd)\n{\n\tstruct fs_struct *fs = current->fs;\n\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tunsigned seq;\n\n\t\tdo {\n\t\t\tseq = read_seqcount_begin(&fs->seq);\n\t\t\tnd->root = fs->root;\n\t\t\tnd->root_seq = __read_seqcount_begin(&nd->root.dentry->d_seq);\n\t\t} while (read_seqcount_retry(&fs->seq, seq));\n\t} else {\n\t\tget_fs_root(fs, &nd->root);\n\t\tnd->flags |= LOOKUP_ROOT_GRABBED;\n\t}\n}\n\nstatic void path_put_conditional(struct path *path, struct nameidata *nd)\n{\n\tdput(path->dentry);\n\tif (path->mnt != nd->path.mnt)\n\t\tmntput(path->mnt);\n}\n\nstatic inline void path_to_nameidata(const struct path *path,\n\t\t\t\t\tstruct nameidata *nd)\n{\n\tif (!(nd->flags & LOOKUP_RCU)) {\n\t\tdput(nd->path.dentry);\n\t\tif (nd->path.mnt != path->mnt)\n\t\t\tmntput(nd->path.mnt);\n\t}\n\tnd->path.mnt = path->mnt;\n\tnd->path.dentry = path->dentry;\n}\n\nstatic int nd_jump_root(struct nameidata *nd)\n{\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tstruct dentry *d;\n\t\tnd->path = nd->root;\n\t\td = nd->path.dentry;\n\t\tnd->inode = d->d_inode;\n\t\tnd->seq = nd->root_seq;\n\t\tif (unlikely(read_seqcount_retry(&d->d_seq, nd->seq)))\n\t\t\treturn -ECHILD;\n\t} else {\n\t\tpath_put(&nd->path);\n\t\tnd->path = nd->root;\n\t\tpath_get(&nd->path);\n\t\tnd->inode = nd->path.dentry->d_inode;\n\t}\n\tnd->flags |= LOOKUP_JUMPED;\n\treturn 0;\n}\n\n/*\n * Helper to directly jump to a known parsed path from ->get_link,\n * caller must have taken a reference to path beforehand.\n */\nvoid nd_jump_link(struct path *path)\n{\n\tstruct nameidata *nd = current->nameidata;\n\tpath_put(&nd->path);\n\n\tnd->path = *path;\n\tnd->inode = nd->path.dentry->d_inode;\n\tnd->flags |= LOOKUP_JUMPED;\n}\n\nstatic inline void put_link(struct nameidata *nd)\n{\n\tstruct saved *last = nd->stack + --nd->depth;\n\tdo_delayed_call(&last->done);\n\tif (!(nd->flags & LOOKUP_RCU))\n\t\tpath_put(&last->link);\n}\n\nint sysctl_protected_symlinks __read_mostly = 0;\nint sysctl_protected_hardlinks __read_mostly = 0;\nint sysctl_protected_fifos __read_mostly;\nint sysctl_protected_regular __read_mostly;\n\n/**\n * may_follow_link - Check symlink following for unsafe situations\n * @nd: nameidata pathwalk data\n *\n * In the case of the sysctl_protected_symlinks sysctl being enabled,\n * CAP_DAC_OVERRIDE needs to be specifically ignored if the symlink is\n * in a sticky world-writable directory. This is to protect privileged\n * processes from failing races against path names that may change out\n * from under them by way of other users creating malicious symlinks.\n * It will permit symlinks to be followed only when outside a sticky\n * world-writable directory, or when the uid of the symlink and follower\n * match, or when the directory owner matches the symlink's owner.\n *\n * Returns 0 if following the symlink is allowed, -ve on error.\n */\nstatic inline int may_follow_link(struct nameidata *nd)\n{\n\tconst struct inode *inode;\n\tconst struct inode *parent;\n\tkuid_t puid;\n\n\tif (!sysctl_protected_symlinks)\n\t\treturn 0;\n\n\t/* Allowed if owner and follower match. */\n\tinode = nd->link_inode;\n\tif (uid_eq(current_cred()->fsuid, inode->i_uid))\n\t\treturn 0;\n\n\t/* Allowed if parent directory not sticky and world-writable. */\n\tparent = nd->inode;\n\tif ((parent->i_mode & (S_ISVTX|S_IWOTH)) != (S_ISVTX|S_IWOTH))\n\t\treturn 0;\n\n\t/* Allowed if parent directory and link owner match. */\n\tpuid = parent->i_uid;\n\tif (uid_valid(puid) && uid_eq(puid, inode->i_uid))\n\t\treturn 0;\n\n\tif (nd->flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\taudit_inode(nd->name, nd->stack[0].link.dentry, 0);\n\taudit_log_path_denied(AUDIT_ANOM_LINK, \"follow_link\");\n\treturn -EACCES;\n}\n\n/**\n * safe_hardlink_source - Check for safe hardlink conditions\n * @inode: the source inode to hardlink from\n *\n * Return false if at least one of the following conditions:\n *    - inode is not a regular file\n *    - inode is setuid\n *    - inode is setgid and group-exec\n *    - access failure for read and write\n *\n * Otherwise returns true.\n */\nstatic bool safe_hardlink_source(struct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\n\t/* Special files should not get pinned to the filesystem. */\n\tif (!S_ISREG(mode))\n\t\treturn false;\n\n\t/* Setuid files should not get pinned to the filesystem. */\n\tif (mode & S_ISUID)\n\t\treturn false;\n\n\t/* Executable setgid files should not get pinned to the filesystem. */\n\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP))\n\t\treturn false;\n\n\t/* Hardlinking to unreadable or unwritable sources is dangerous. */\n\tif (inode_permission(inode, MAY_READ | MAY_WRITE))\n\t\treturn false;\n\n\treturn true;\n}\n\n/**\n * may_linkat - Check permissions for creating a hardlink\n * @link: the source to hardlink from\n *\n * Block hardlink when all of:\n *  - sysctl_protected_hardlinks enabled\n *  - fsuid does not match inode\n *  - hardlink source is unsafe (see safe_hardlink_source() above)\n *  - not CAP_FOWNER in a namespace with the inode owner uid mapped\n *\n * Returns 0 if successful, -ve on error.\n */\nstatic int may_linkat(struct path *link)\n{\n\tstruct inode *inode = link->dentry->d_inode;\n\n\t/* Inode writeback is not safe when the uid or gid are invalid. */\n\tif (!uid_valid(inode->i_uid) || !gid_valid(inode->i_gid))\n\t\treturn -EOVERFLOW;\n\n\tif (!sysctl_protected_hardlinks)\n\t\treturn 0;\n\n\t/* Source inode owner (or CAP_FOWNER) can hardlink all they like,\n\t * otherwise, it must be a safe source.\n\t */\n\tif (safe_hardlink_source(inode) || inode_owner_or_capable(inode))\n\t\treturn 0;\n\n\taudit_log_path_denied(AUDIT_ANOM_LINK, \"linkat\");\n\treturn -EPERM;\n}\n\n/**\n * may_create_in_sticky - Check whether an O_CREAT open in a sticky directory\n *\t\t\t  should be allowed, or not, on files that already\n *\t\t\t  exist.\n * @dir_mode: mode bits of directory\n * @dir_uid: owner of directory\n * @inode: the inode of the file to open\n *\n * Block an O_CREAT open of a FIFO (or a regular file) when:\n *   - sysctl_protected_fifos (or sysctl_protected_regular) is enabled\n *   - the file already exists\n *   - we are in a sticky directory\n *   - we don't own the file\n *   - the owner of the directory doesn't own the file\n *   - the directory is world writable\n * If the sysctl_protected_fifos (or sysctl_protected_regular) is set to 2\n * the directory doesn't have to be world writable: being group writable will\n * be enough.\n *\n * Returns 0 if the open is allowed, -ve on error.\n */\nstatic int may_create_in_sticky(umode_t dir_mode, kuid_t dir_uid,\n\t\t\t\tstruct inode * const inode)\n{\n\tif ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||\n\t    (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||\n\t    likely(!(dir_mode & S_ISVTX)) ||\n\t    uid_eq(inode->i_uid, dir_uid) ||\n\t    uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn 0;\n\n\tif (likely(dir_mode & 0002) ||\n\t    (dir_mode & 0020 &&\n\t     ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||\n\t      (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {\n\t\tconst char *operation = S_ISFIFO(inode->i_mode) ?\n\t\t\t\t\t\"sticky_create_fifo\" :\n\t\t\t\t\t\"sticky_create_regular\";\n\t\taudit_log_path_denied(AUDIT_ANOM_CREAT, operation);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}\n\nstatic __always_inline\nconst char *get_link(struct nameidata *nd)\n{\n\tstruct saved *last = nd->stack + nd->depth - 1;\n\tstruct dentry *dentry = last->link.dentry;\n\tstruct inode *inode = nd->link_inode;\n\tint error;\n\tconst char *res;\n\n\tif (!(nd->flags & LOOKUP_RCU)) {\n\t\ttouch_atime(&last->link);\n\t\tcond_resched();\n\t} else if (atime_needs_update(&last->link, inode)) {\n\t\tif (unlikely(unlazy_walk(nd)))\n\t\t\treturn ERR_PTR(-ECHILD);\n\t\ttouch_atime(&last->link);\n\t}\n\n\terror = security_inode_follow_link(dentry, inode,\n\t\t\t\t\t   nd->flags & LOOKUP_RCU);\n\tif (unlikely(error))\n\t\treturn ERR_PTR(error);\n\n\tnd->last_type = LAST_BIND;\n\tres = READ_ONCE(inode->i_link);\n\tif (!res) {\n\t\tconst char * (*get)(struct dentry *, struct inode *,\n\t\t\t\tstruct delayed_call *);\n\t\tget = inode->i_op->get_link;\n\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\tres = get(NULL, inode, &last->done);\n\t\t\tif (res == ERR_PTR(-ECHILD)) {\n\t\t\t\tif (unlikely(unlazy_walk(nd)))\n\t\t\t\t\treturn ERR_PTR(-ECHILD);\n\t\t\t\tres = get(dentry, inode, &last->done);\n\t\t\t}\n\t\t} else {\n\t\t\tres = get(dentry, inode, &last->done);\n\t\t}\n\t\tif (IS_ERR_OR_NULL(res))\n\t\t\treturn res;\n\t}\n\tif (*res == '/') {\n\t\tif (!nd->root.mnt)\n\t\t\tset_root(nd);\n\t\tif (unlikely(nd_jump_root(nd)))\n\t\t\treturn ERR_PTR(-ECHILD);\n\t\twhile (unlikely(*++res == '/'))\n\t\t\t;\n\t}\n\tif (!*res)\n\t\tres = NULL;\n\treturn res;\n}\n\n/*\n * follow_up - Find the mountpoint of path's vfsmount\n *\n * Given a path, find the mountpoint of its source file system.\n * Replace @path with the path of the mountpoint in the parent mount.\n * Up is towards /.\n *\n * Return 1 if we went up a level and 0 if we were already at the\n * root.\n */\nint follow_up(struct path *path)\n{\n\tstruct mount *mnt = real_mount(path->mnt);\n\tstruct mount *parent;\n\tstruct dentry *mountpoint;\n\n\tread_seqlock_excl(&mount_lock);\n\tparent = mnt->mnt_parent;\n\tif (parent == mnt) {\n\t\tread_sequnlock_excl(&mount_lock);\n\t\treturn 0;\n\t}\n\tmntget(&parent->mnt);\n\tmountpoint = dget(mnt->mnt_mountpoint);\n\tread_sequnlock_excl(&mount_lock);\n\tdput(path->dentry);\n\tpath->dentry = mountpoint;\n\tmntput(path->mnt);\n\tpath->mnt = &parent->mnt;\n\treturn 1;\n}\nEXPORT_SYMBOL(follow_up);\n\n/*\n * Perform an automount\n * - return -EISDIR to tell follow_managed() to stop and return the path we\n *   were called with.\n */\nstatic int follow_automount(struct path *path, struct nameidata *nd,\n\t\t\t    bool *need_mntput)\n{\n\tstruct vfsmount *mnt;\n\tint err;\n\n\tif (!path->dentry->d_op || !path->dentry->d_op->d_automount)\n\t\treturn -EREMOTE;\n\n\t/* We don't want to mount if someone's just doing a stat -\n\t * unless they're stat'ing a directory and appended a '/' to\n\t * the name.\n\t *\n\t * We do, however, want to mount if someone wants to open or\n\t * create a file of any type under the mountpoint, wants to\n\t * traverse through the mountpoint or wants to open the\n\t * mounted directory.  Also, autofs may mark negative dentries\n\t * as being automount points.  These will need the attentions\n\t * of the daemon to instantiate them before they can be used.\n\t */\n\tif (!(nd->flags & (LOOKUP_PARENT | LOOKUP_DIRECTORY |\n\t\t\t   LOOKUP_OPEN | LOOKUP_CREATE | LOOKUP_AUTOMOUNT)) &&\n\t    path->dentry->d_inode)\n\t\treturn -EISDIR;\n\n\tnd->total_link_count++;\n\tif (nd->total_link_count >= 40)\n\t\treturn -ELOOP;\n\n\tmnt = path->dentry->d_op->d_automount(path);\n\tif (IS_ERR(mnt)) {\n\t\t/*\n\t\t * The filesystem is allowed to return -EISDIR here to indicate\n\t\t * it doesn't want to automount.  For instance, autofs would do\n\t\t * this so that its userspace daemon can mount on this dentry.\n\t\t *\n\t\t * However, we can only permit this if it's a terminal point in\n\t\t * the path being looked up; if it wasn't then the remainder of\n\t\t * the path is inaccessible and we should say so.\n\t\t */\n\t\tif (PTR_ERR(mnt) == -EISDIR && (nd->flags & LOOKUP_PARENT))\n\t\t\treturn -EREMOTE;\n\t\treturn PTR_ERR(mnt);\n\t}\n\n\tif (!mnt) /* mount collision */\n\t\treturn 0;\n\n\tif (!*need_mntput) {\n\t\t/* lock_mount() may release path->mnt on error */\n\t\tmntget(path->mnt);\n\t\t*need_mntput = true;\n\t}\n\terr = finish_automount(mnt, path);\n\n\tswitch (err) {\n\tcase -EBUSY:\n\t\t/* Someone else made a mount here whilst we were busy */\n\t\treturn 0;\n\tcase 0:\n\t\tpath_put(path);\n\t\tpath->mnt = mnt;\n\t\tpath->dentry = dget(mnt->mnt_root);\n\t\treturn 0;\n\tdefault:\n\t\treturn err;\n\t}\n\n}\n\n/*\n * Handle a dentry that is managed in some way.\n * - Flagged for transit management (autofs)\n * - Flagged as mountpoint\n * - Flagged as automount point\n *\n * This may only be called in refwalk mode.\n * On success path->dentry is known positive.\n *\n * Serialization is taken care of in namespace.c\n */\nstatic int follow_managed(struct path *path, struct nameidata *nd)\n{\n\tstruct vfsmount *mnt = path->mnt; /* held by caller, must be left alone */\n\tunsigned flags;\n\tbool need_mntput = false;\n\tint ret = 0;\n\n\t/* Given that we're not holding a lock here, we retain the value in a\n\t * local variable for each dentry as we look at it so that we don't see\n\t * the components of that value change under us */\n\twhile (flags = smp_load_acquire(&path->dentry->d_flags),\n\t       unlikely(flags & DCACHE_MANAGED_DENTRY)) {\n\t\t/* Allow the filesystem to manage the transit without i_mutex\n\t\t * being held. */\n\t\tif (flags & DCACHE_MANAGE_TRANSIT) {\n\t\t\tBUG_ON(!path->dentry->d_op);\n\t\t\tBUG_ON(!path->dentry->d_op->d_manage);\n\t\t\tret = path->dentry->d_op->d_manage(path, false);\n\t\t\tflags = smp_load_acquire(&path->dentry->d_flags);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Transit to a mounted filesystem. */\n\t\tif (flags & DCACHE_MOUNTED) {\n\t\t\tstruct vfsmount *mounted = lookup_mnt(path);\n\t\t\tif (mounted) {\n\t\t\t\tdput(path->dentry);\n\t\t\t\tif (need_mntput)\n\t\t\t\t\tmntput(path->mnt);\n\t\t\t\tpath->mnt = mounted;\n\t\t\t\tpath->dentry = dget(mounted->mnt_root);\n\t\t\t\tneed_mntput = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Something is mounted on this dentry in another\n\t\t\t * namespace and/or whatever was mounted there in this\n\t\t\t * namespace got unmounted before lookup_mnt() could\n\t\t\t * get it */\n\t\t}\n\n\t\t/* Handle an automount point */\n\t\tif (flags & DCACHE_NEED_AUTOMOUNT) {\n\t\t\tret = follow_automount(path, nd, &need_mntput);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We didn't change the current path point */\n\t\tbreak;\n\t}\n\n\tif (need_mntput && path->mnt == mnt)\n\t\tmntput(path->mnt);\n\tif (need_mntput)\n\t\tnd->flags |= LOOKUP_JUMPED;\n\tif (ret == -EISDIR || !ret)\n\t\tret = 1;\n\tif (ret > 0 && unlikely(d_flags_negative(flags)))\n\t\tret = -ENOENT;\n\tif (unlikely(ret < 0))\n\t\tpath_put_conditional(path, nd);\n\treturn ret;\n}\n\nint follow_down_one(struct path *path)\n{\n\tstruct vfsmount *mounted;\n\n\tmounted = lookup_mnt(path);\n\tif (mounted) {\n\t\tdput(path->dentry);\n\t\tmntput(path->mnt);\n\t\tpath->mnt = mounted;\n\t\tpath->dentry = dget(mounted->mnt_root);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(follow_down_one);\n\nstatic inline int managed_dentry_rcu(const struct path *path)\n{\n\treturn (path->dentry->d_flags & DCACHE_MANAGE_TRANSIT) ?\n\t\tpath->dentry->d_op->d_manage(path, true) : 0;\n}\n\n/*\n * Try to skip to top of mountpoint pile in rcuwalk mode.  Fail if\n * we meet a managed dentry that would need blocking.\n */\nstatic bool __follow_mount_rcu(struct nameidata *nd, struct path *path,\n\t\t\t       struct inode **inode, unsigned *seqp)\n{\n\tfor (;;) {\n\t\tstruct mount *mounted;\n\t\t/*\n\t\t * Don't forget we might have a non-mountpoint managed dentry\n\t\t * that wants to block transit.\n\t\t */\n\t\tswitch (managed_dentry_rcu(path)) {\n\t\tcase -ECHILD:\n\t\tdefault:\n\t\t\treturn false;\n\t\tcase -EISDIR:\n\t\t\treturn true;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!d_mountpoint(path->dentry))\n\t\t\treturn !(path->dentry->d_flags & DCACHE_NEED_AUTOMOUNT);\n\n\t\tmounted = __lookup_mnt(path->mnt, path->dentry);\n\t\tif (!mounted)\n\t\t\tbreak;\n\t\tpath->mnt = &mounted->mnt;\n\t\tpath->dentry = mounted->mnt.mnt_root;\n\t\tnd->flags |= LOOKUP_JUMPED;\n\t\t*seqp = read_seqcount_begin(&path->dentry->d_seq);\n\t\t/*\n\t\t * Update the inode too. We don't need to re-check the\n\t\t * dentry sequence number here after this d_inode read,\n\t\t * because a mount-point is always pinned.\n\t\t */\n\t\t*inode = path->dentry->d_inode;\n\t}\n\treturn !read_seqretry(&mount_lock, nd->m_seq) &&\n\t\t!(path->dentry->d_flags & DCACHE_NEED_AUTOMOUNT);\n}\n\nstatic int follow_dotdot_rcu(struct nameidata *nd)\n{\n\tstruct inode *inode = nd->inode;\n\n\twhile (1) {\n\t\tif (path_equal(&nd->path, &nd->root))\n\t\t\tbreak;\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\tstruct dentry *old = nd->path.dentry;\n\t\t\tstruct dentry *parent = old->d_parent;\n\t\t\tunsigned seq;\n\n\t\t\tinode = parent->d_inode;\n\t\t\tseq = read_seqcount_begin(&parent->d_seq);\n\t\t\tif (unlikely(read_seqcount_retry(&old->d_seq, nd->seq)))\n\t\t\t\treturn -ECHILD;\n\t\t\tnd->path.dentry = parent;\n\t\t\tnd->seq = seq;\n\t\t\tif (unlikely(!path_connected(&nd->path)))\n\t\t\t\treturn -ENOENT;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tstruct mount *mnt = real_mount(nd->path.mnt);\n\t\t\tstruct mount *mparent = mnt->mnt_parent;\n\t\t\tstruct dentry *mountpoint = mnt->mnt_mountpoint;\n\t\t\tstruct inode *inode2 = mountpoint->d_inode;\n\t\t\tunsigned seq = read_seqcount_begin(&mountpoint->d_seq);\n\t\t\tif (unlikely(read_seqretry(&mount_lock, nd->m_seq)))\n\t\t\t\treturn -ECHILD;\n\t\t\tif (&mparent->mnt == nd->path.mnt)\n\t\t\t\tbreak;\n\t\t\t/* we know that mountpoint was pinned */\n\t\t\tnd->path.dentry = mountpoint;\n\t\t\tnd->path.mnt = &mparent->mnt;\n\t\t\tinode = inode2;\n\t\t\tnd->seq = seq;\n\t\t}\n\t}\n\twhile (unlikely(d_mountpoint(nd->path.dentry))) {\n\t\tstruct mount *mounted;\n\t\tmounted = __lookup_mnt(nd->path.mnt, nd->path.dentry);\n\t\tif (unlikely(read_seqretry(&mount_lock, nd->m_seq)))\n\t\t\treturn -ECHILD;\n\t\tif (!mounted)\n\t\t\tbreak;\n\t\tnd->path.mnt = &mounted->mnt;\n\t\tnd->path.dentry = mounted->mnt.mnt_root;\n\t\tinode = nd->path.dentry->d_inode;\n\t\tnd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);\n\t}\n\tnd->inode = inode;\n\treturn 0;\n}\n\n/*\n * Follow down to the covering mount currently visible to userspace.  At each\n * point, the filesystem owning that dentry may be queried as to whether the\n * caller is permitted to proceed or not.\n */\nint follow_down(struct path *path)\n{\n\tunsigned managed;\n\tint ret;\n\n\twhile (managed = READ_ONCE(path->dentry->d_flags),\n\t       unlikely(managed & DCACHE_MANAGED_DENTRY)) {\n\t\t/* Allow the filesystem to manage the transit without i_mutex\n\t\t * being held.\n\t\t *\n\t\t * We indicate to the filesystem if someone is trying to mount\n\t\t * something here.  This gives autofs the chance to deny anyone\n\t\t * other than its daemon the right to mount on its\n\t\t * superstructure.\n\t\t *\n\t\t * The filesystem may sleep at this point.\n\t\t */\n\t\tif (managed & DCACHE_MANAGE_TRANSIT) {\n\t\t\tBUG_ON(!path->dentry->d_op);\n\t\t\tBUG_ON(!path->dentry->d_op->d_manage);\n\t\t\tret = path->dentry->d_op->d_manage(path, false);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret == -EISDIR ? 0 : ret;\n\t\t}\n\n\t\t/* Transit to a mounted filesystem. */\n\t\tif (managed & DCACHE_MOUNTED) {\n\t\t\tstruct vfsmount *mounted = lookup_mnt(path);\n\t\t\tif (!mounted)\n\t\t\t\tbreak;\n\t\t\tdput(path->dentry);\n\t\t\tmntput(path->mnt);\n\t\t\tpath->mnt = mounted;\n\t\t\tpath->dentry = dget(mounted->mnt_root);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Don't handle automount points here */\n\t\tbreak;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(follow_down);\n\n/*\n * Skip to top of mountpoint pile in refwalk mode for follow_dotdot()\n */\nstatic void follow_mount(struct path *path)\n{\n\twhile (d_mountpoint(path->dentry)) {\n\t\tstruct vfsmount *mounted = lookup_mnt(path);\n\t\tif (!mounted)\n\t\t\tbreak;\n\t\tdput(path->dentry);\n\t\tmntput(path->mnt);\n\t\tpath->mnt = mounted;\n\t\tpath->dentry = dget(mounted->mnt_root);\n\t}\n}\n\nstatic int path_parent_directory(struct path *path)\n{\n\tstruct dentry *old = path->dentry;\n\t/* rare case of legitimate dget_parent()... */\n\tpath->dentry = dget_parent(path->dentry);\n\tdput(old);\n\tif (unlikely(!path_connected(path)))\n\t\treturn -ENOENT;\n\treturn 0;\n}\n\nstatic int follow_dotdot(struct nameidata *nd)\n{\n\twhile(1) {\n\t\tif (path_equal(&nd->path, &nd->root))\n\t\t\tbreak;\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\tint ret = path_parent_directory(&nd->path);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\t}\n\t\tif (!follow_up(&nd->path))\n\t\t\tbreak;\n\t}\n\tfollow_mount(&nd->path);\n\tnd->inode = nd->path.dentry->d_inode;\n\treturn 0;\n}\n\n/*\n * This looks up the name in dcache and possibly revalidates the found dentry.\n * NULL is returned if the dentry does not exist in the cache.\n */\nstatic struct dentry *lookup_dcache(const struct qstr *name,\n\t\t\t\t    struct dentry *dir,\n\t\t\t\t    unsigned int flags)\n{\n\tstruct dentry *dentry = d_lookup(dir, name);\n\tif (dentry) {\n\t\tint error = d_revalidate(dentry, flags);\n\t\tif (unlikely(error <= 0)) {\n\t\t\tif (!error)\n\t\t\t\td_invalidate(dentry);\n\t\t\tdput(dentry);\n\t\t\treturn ERR_PTR(error);\n\t\t}\n\t}\n\treturn dentry;\n}\n\n/*\n * Parent directory has inode locked exclusive.  This is one\n * and only case when ->lookup() gets called on non in-lookup\n * dentries - as the matter of fact, this only gets called\n * when directory is guaranteed to have no in-lookup children\n * at all.\n */\nstatic struct dentry *__lookup_hash(const struct qstr *name,\n\t\tstruct dentry *base, unsigned int flags)\n{\n\tstruct dentry *dentry = lookup_dcache(name, base, flags);\n\tstruct dentry *old;\n\tstruct inode *dir = base->d_inode;\n\n\tif (dentry)\n\t\treturn dentry;\n\n\t/* Don't create child dentry for a dead directory. */\n\tif (unlikely(IS_DEADDIR(dir)))\n\t\treturn ERR_PTR(-ENOENT);\n\n\tdentry = d_alloc(base, name);\n\tif (unlikely(!dentry))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\told = dir->i_op->lookup(dir, dentry, flags);\n\tif (unlikely(old)) {\n\t\tdput(dentry);\n\t\tdentry = old;\n\t}\n\treturn dentry;\n}\n\nstatic int lookup_fast(struct nameidata *nd,\n\t\t       struct path *path, struct inode **inode,\n\t\t       unsigned *seqp)\n{\n\tstruct vfsmount *mnt = nd->path.mnt;\n\tstruct dentry *dentry, *parent = nd->path.dentry;\n\tint status = 1;\n\tint err;\n\n\t/*\n\t * Rename seqlock is not required here because in the off chance\n\t * of a false negative due to a concurrent rename, the caller is\n\t * going to fall back to non-racy lookup.\n\t */\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tunsigned seq;\n\t\tbool negative;\n\t\tdentry = __d_lookup_rcu(parent, &nd->last, &seq);\n\t\tif (unlikely(!dentry)) {\n\t\t\tif (unlazy_walk(nd))\n\t\t\t\treturn -ECHILD;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * This sequence count validates that the inode matches\n\t\t * the dentry name information from lookup.\n\t\t */\n\t\t*inode = d_backing_inode(dentry);\n\t\tnegative = d_is_negative(dentry);\n\t\tif (unlikely(read_seqcount_retry(&dentry->d_seq, seq)))\n\t\t\treturn -ECHILD;\n\n\t\t/*\n\t\t * This sequence count validates that the parent had no\n\t\t * changes while we did the lookup of the dentry above.\n\t\t *\n\t\t * The memory barrier in read_seqcount_begin of child is\n\t\t *  enough, we can use __read_seqcount_retry here.\n\t\t */\n\t\tif (unlikely(__read_seqcount_retry(&parent->d_seq, nd->seq)))\n\t\t\treturn -ECHILD;\n\n\t\t*seqp = seq;\n\t\tstatus = d_revalidate(dentry, nd->flags);\n\t\tif (likely(status > 0)) {\n\t\t\t/*\n\t\t\t * Note: do negative dentry check after revalidation in\n\t\t\t * case that drops it.\n\t\t\t */\n\t\t\tif (unlikely(negative))\n\t\t\t\treturn -ENOENT;\n\t\t\tpath->mnt = mnt;\n\t\t\tpath->dentry = dentry;\n\t\t\tif (likely(__follow_mount_rcu(nd, path, inode, seqp)))\n\t\t\t\treturn 1;\n\t\t}\n\t\tif (unlazy_child(nd, dentry, seq))\n\t\t\treturn -ECHILD;\n\t\tif (unlikely(status == -ECHILD))\n\t\t\t/* we'd been told to redo it in non-rcu mode */\n\t\t\tstatus = d_revalidate(dentry, nd->flags);\n\t} else {\n\t\tdentry = __d_lookup(parent, &nd->last);\n\t\tif (unlikely(!dentry))\n\t\t\treturn 0;\n\t\tstatus = d_revalidate(dentry, nd->flags);\n\t}\n\tif (unlikely(status <= 0)) {\n\t\tif (!status)\n\t\t\td_invalidate(dentry);\n\t\tdput(dentry);\n\t\treturn status;\n\t}\n\n\tpath->mnt = mnt;\n\tpath->dentry = dentry;\n\terr = follow_managed(path, nd);\n\tif (likely(err > 0))\n\t\t*inode = d_backing_inode(path->dentry);\n\treturn err;\n}\n\n/* Fast lookup failed, do it the slow way */\nstatic struct dentry *__lookup_slow(const struct qstr *name,\n\t\t\t\t    struct dentry *dir,\n\t\t\t\t    unsigned int flags)\n{\n\tstruct dentry *dentry, *old;\n\tstruct inode *inode = dir->d_inode;\n\tDECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);\n\n\t/* Don't go there if it's already dead */\n\tif (unlikely(IS_DEADDIR(inode)))\n\t\treturn ERR_PTR(-ENOENT);\nagain:\n\tdentry = d_alloc_parallel(dir, name, &wq);\n\tif (IS_ERR(dentry))\n\t\treturn dentry;\n\tif (unlikely(!d_in_lookup(dentry))) {\n\t\tint error = d_revalidate(dentry, flags);\n\t\tif (unlikely(error <= 0)) {\n\t\t\tif (!error) {\n\t\t\t\td_invalidate(dentry);\n\t\t\t\tdput(dentry);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tdput(dentry);\n\t\t\tdentry = ERR_PTR(error);\n\t\t}\n\t} else {\n\t\told = inode->i_op->lookup(inode, dentry, flags);\n\t\td_lookup_done(dentry);\n\t\tif (unlikely(old)) {\n\t\t\tdput(dentry);\n\t\t\tdentry = old;\n\t\t}\n\t}\n\treturn dentry;\n}\n\nstatic struct dentry *lookup_slow(const struct qstr *name,\n\t\t\t\t  struct dentry *dir,\n\t\t\t\t  unsigned int flags)\n{\n\tstruct inode *inode = dir->d_inode;\n\tstruct dentry *res;\n\tinode_lock_shared(inode);\n\tres = __lookup_slow(name, dir, flags);\n\tinode_unlock_shared(inode);\n\treturn res;\n}\n\nstatic inline int may_lookup(struct nameidata *nd)\n{\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tint err = inode_permission(nd->inode, MAY_EXEC|MAY_NOT_BLOCK);\n\t\tif (err != -ECHILD)\n\t\t\treturn err;\n\t\tif (unlazy_walk(nd))\n\t\t\treturn -ECHILD;\n\t}\n\treturn inode_permission(nd->inode, MAY_EXEC);\n}\n\nstatic inline int handle_dots(struct nameidata *nd, int type)\n{\n\tif (type == LAST_DOTDOT) {\n\t\tif (!nd->root.mnt)\n\t\t\tset_root(nd);\n\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\treturn follow_dotdot_rcu(nd);\n\t\t} else\n\t\t\treturn follow_dotdot(nd);\n\t}\n\treturn 0;\n}\n\nstatic int pick_link(struct nameidata *nd, struct path *link,\n\t\t     struct inode *inode, unsigned seq)\n{\n\tint error;\n\tstruct saved *last;\n\tif (unlikely(nd->total_link_count++ >= MAXSYMLINKS)) {\n\t\tpath_to_nameidata(link, nd);\n\t\treturn -ELOOP;\n\t}\n\tif (!(nd->flags & LOOKUP_RCU)) {\n\t\tif (link->mnt == nd->path.mnt)\n\t\t\tmntget(link->mnt);\n\t}\n\terror = nd_alloc_stack(nd);\n\tif (unlikely(error)) {\n\t\tif (error == -ECHILD) {\n\t\t\tif (unlikely(!legitimize_path(nd, link, seq))) {\n\t\t\t\tdrop_links(nd);\n\t\t\t\tnd->depth = 0;\n\t\t\t\tnd->flags &= ~LOOKUP_RCU;\n\t\t\t\tnd->path.mnt = NULL;\n\t\t\t\tnd->path.dentry = NULL;\n\t\t\t\trcu_read_unlock();\n\t\t\t} else if (likely(unlazy_walk(nd)) == 0)\n\t\t\t\terror = nd_alloc_stack(nd);\n\t\t}\n\t\tif (error) {\n\t\t\tpath_put(link);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tlast = nd->stack + nd->depth++;\n\tlast->link = *link;\n\tclear_delayed_call(&last->done);\n\tnd->link_inode = inode;\n\tlast->seq = seq;\n\treturn 1;\n}\n\nenum {WALK_FOLLOW = 1, WALK_MORE = 2};\n\n/*\n * Do we need to follow links? We _really_ want to be able\n * to do this check without having to look at inode->i_op,\n * so we keep a cache of \"no, this doesn't need follow_link\"\n * for the common case.\n */\nstatic inline int step_into(struct nameidata *nd, struct path *path,\n\t\t\t    int flags, struct inode *inode, unsigned seq)\n{\n\tif (!(flags & WALK_MORE) && nd->depth)\n\t\tput_link(nd);\n\tif (likely(!d_is_symlink(path->dentry)) ||\n\t   !(flags & WALK_FOLLOW || nd->flags & LOOKUP_FOLLOW)) {\n\t\t/* not a symlink or should not follow */\n\t\tpath_to_nameidata(path, nd);\n\t\tnd->inode = inode;\n\t\tnd->seq = seq;\n\t\treturn 0;\n\t}\n\t/* make sure that d_is_symlink above matches inode */\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tif (read_seqcount_retry(&path->dentry->d_seq, seq))\n\t\t\treturn -ECHILD;\n\t}\n\treturn pick_link(nd, path, inode, seq);\n}\n\nstatic int walk_component(struct nameidata *nd, int flags)\n{\n\tstruct path path;\n\tstruct inode *inode;\n\tunsigned seq;\n\tint err;\n\t/*\n\t * \".\" and \"..\" are special - \"..\" especially so because it has\n\t * to be able to know about the current root directory and\n\t * parent relationships.\n\t */\n\tif (unlikely(nd->last_type != LAST_NORM)) {\n\t\terr = handle_dots(nd, nd->last_type);\n\t\tif (!(flags & WALK_MORE) && nd->depth)\n\t\t\tput_link(nd);\n\t\treturn err;\n\t}\n\terr = lookup_fast(nd, &path, &inode, &seq);\n\tif (unlikely(err <= 0)) {\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tpath.dentry = lookup_slow(&nd->last, nd->path.dentry,\n\t\t\t\t\t  nd->flags);\n\t\tif (IS_ERR(path.dentry))\n\t\t\treturn PTR_ERR(path.dentry);\n\n\t\tpath.mnt = nd->path.mnt;\n\t\terr = follow_managed(&path, nd);\n\t\tif (unlikely(err < 0))\n\t\t\treturn err;\n\n\t\tseq = 0;\t/* we are already out of RCU mode */\n\t\tinode = d_backing_inode(path.dentry);\n\t}\n\n\treturn step_into(nd, &path, flags, inode, seq);\n}\n\n/*\n * We can do the critical dentry name comparison and hashing\n * operations one word at a time, but we are limited to:\n *\n * - Architectures with fast unaligned word accesses. We could\n *   do a \"get_unaligned()\" if this helps and is sufficiently\n *   fast.\n *\n * - non-CONFIG_DEBUG_PAGEALLOC configurations (so that we\n *   do not trap on the (extremely unlikely) case of a page\n *   crossing operation.\n *\n * - Furthermore, we need an efficient 64-bit compile for the\n *   64-bit case in order to generate the \"number of bytes in\n *   the final mask\". Again, that could be replaced with a\n *   efficient population count instruction or similar.\n */\n#ifdef CONFIG_DCACHE_WORD_ACCESS\n\n#include <asm/word-at-a-time.h>\n\n#ifdef HASH_MIX\n\n/* Architecture provides HASH_MIX and fold_hash() in <asm/hash.h> */\n\n#elif defined(CONFIG_64BIT)\n/*\n * Register pressure in the mixing function is an issue, particularly\n * on 32-bit x86, but almost any function requires one state value and\n * one temporary.  Instead, use a function designed for two state values\n * and no temporaries.\n *\n * This function cannot create a collision in only two iterations, so\n * we have two iterations to achieve avalanche.  In those two iterations,\n * we have six layers of mixing, which is enough to spread one bit's\n * influence out to 2^6 = 64 state bits.\n *\n * Rotate constants are scored by considering either 64 one-bit input\n * deltas or 64*63/2 = 2016 two-bit input deltas, and finding the\n * probability of that delta causing a change to each of the 128 output\n * bits, using a sample of random initial states.\n *\n * The Shannon entropy of the computed probabilities is then summed\n * to produce a score.  Ideally, any input change has a 50% chance of\n * toggling any given output bit.\n *\n * Mixing scores (in bits) for (12,45):\n * Input delta: 1-bit      2-bit\n * 1 round:     713.3    42542.6\n * 2 rounds:   2753.7   140389.8\n * 3 rounds:   5954.1   233458.2\n * 4 rounds:   7862.6   256672.2\n * Perfect:    8192     258048\n *            (64*128) (64*63/2 * 128)\n */\n#define HASH_MIX(x, y, a)\t\\\n\t(\tx ^= (a),\t\\\n\ty ^= x,\tx = rol64(x,12),\\\n\tx += y,\ty = rol64(y,45),\\\n\ty *= 9\t\t\t)\n\n/*\n * Fold two longs into one 32-bit hash value.  This must be fast, but\n * latency isn't quite as critical, as there is a fair bit of additional\n * work done before the hash value is used.\n */\nstatic inline unsigned int fold_hash(unsigned long x, unsigned long y)\n{\n\ty ^= x * GOLDEN_RATIO_64;\n\ty *= GOLDEN_RATIO_64;\n\treturn y >> 32;\n}\n\n#else\t/* 32-bit case */\n\n/*\n * Mixing scores (in bits) for (7,20):\n * Input delta: 1-bit      2-bit\n * 1 round:     330.3     9201.6\n * 2 rounds:   1246.4    25475.4\n * 3 rounds:   1907.1    31295.1\n * 4 rounds:   2042.3    31718.6\n * Perfect:    2048      31744\n *            (32*64)   (32*31/2 * 64)\n */\n#define HASH_MIX(x, y, a)\t\\\n\t(\tx ^= (a),\t\\\n\ty ^= x,\tx = rol32(x, 7),\\\n\tx += y,\ty = rol32(y,20),\\\n\ty *= 9\t\t\t)\n\nstatic inline unsigned int fold_hash(unsigned long x, unsigned long y)\n{\n\t/* Use arch-optimized multiply if one exists */\n\treturn __hash_32(y ^ __hash_32(x));\n}\n\n#endif\n\n/*\n * Return the hash of a string of known length.  This is carfully\n * designed to match hash_name(), which is the more critical function.\n * In particular, we must end by hashing a final word containing 0..7\n * payload bytes, to match the way that hash_name() iterates until it\n * finds the delimiter after the name.\n */\nunsigned int full_name_hash(const void *salt, const char *name, unsigned int len)\n{\n\tunsigned long a, x = 0, y = (unsigned long)salt;\n\n\tfor (;;) {\n\t\tif (!len)\n\t\t\tgoto done;\n\t\ta = load_unaligned_zeropad(name);\n\t\tif (len < sizeof(unsigned long))\n\t\t\tbreak;\n\t\tHASH_MIX(x, y, a);\n\t\tname += sizeof(unsigned long);\n\t\tlen -= sizeof(unsigned long);\n\t}\n\tx ^= a & bytemask_from_count(len);\ndone:\n\treturn fold_hash(x, y);\n}\nEXPORT_SYMBOL(full_name_hash);\n\n/* Return the \"hash_len\" (hash and length) of a null-terminated string */\nu64 hashlen_string(const void *salt, const char *name)\n{\n\tunsigned long a = 0, x = 0, y = (unsigned long)salt;\n\tunsigned long adata, mask, len;\n\tconst struct word_at_a_time constants = WORD_AT_A_TIME_CONSTANTS;\n\n\tlen = 0;\n\tgoto inside;\n\n\tdo {\n\t\tHASH_MIX(x, y, a);\n\t\tlen += sizeof(unsigned long);\ninside:\n\t\ta = load_unaligned_zeropad(name+len);\n\t} while (!has_zero(a, &adata, &constants));\n\n\tadata = prep_zero_mask(a, adata, &constants);\n\tmask = create_zero_mask(adata);\n\tx ^= a & zero_bytemask(mask);\n\n\treturn hashlen_create(fold_hash(x, y), len + find_zero(mask));\n}\nEXPORT_SYMBOL(hashlen_string);\n\n/*\n * Calculate the length and hash of the path component, and\n * return the \"hash_len\" as the result.\n */\nstatic inline u64 hash_name(const void *salt, const char *name)\n{\n\tunsigned long a = 0, b, x = 0, y = (unsigned long)salt;\n\tunsigned long adata, bdata, mask, len;\n\tconst struct word_at_a_time constants = WORD_AT_A_TIME_CONSTANTS;\n\n\tlen = 0;\n\tgoto inside;\n\n\tdo {\n\t\tHASH_MIX(x, y, a);\n\t\tlen += sizeof(unsigned long);\ninside:\n\t\ta = load_unaligned_zeropad(name+len);\n\t\tb = a ^ REPEAT_BYTE('/');\n\t} while (!(has_zero(a, &adata, &constants) | has_zero(b, &bdata, &constants)));\n\n\tadata = prep_zero_mask(a, adata, &constants);\n\tbdata = prep_zero_mask(b, bdata, &constants);\n\tmask = create_zero_mask(adata | bdata);\n\tx ^= a & zero_bytemask(mask);\n\n\treturn hashlen_create(fold_hash(x, y), len + find_zero(mask));\n}\n\n#else\t/* !CONFIG_DCACHE_WORD_ACCESS: Slow, byte-at-a-time version */\n\n/* Return the hash of a string of known length */\nunsigned int full_name_hash(const void *salt, const char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash(salt);\n\twhile (len--)\n\t\thash = partial_name_hash((unsigned char)*name++, hash);\n\treturn end_name_hash(hash);\n}\nEXPORT_SYMBOL(full_name_hash);\n\n/* Return the \"hash_len\" (hash and length) of a null-terminated string */\nu64 hashlen_string(const void *salt, const char *name)\n{\n\tunsigned long hash = init_name_hash(salt);\n\tunsigned long len = 0, c;\n\n\tc = (unsigned char)*name;\n\twhile (c) {\n\t\tlen++;\n\t\thash = partial_name_hash(c, hash);\n\t\tc = (unsigned char)name[len];\n\t}\n\treturn hashlen_create(end_name_hash(hash), len);\n}\nEXPORT_SYMBOL(hashlen_string);\n\n/*\n * We know there's a real path component here of at least\n * one character.\n */\nstatic inline u64 hash_name(const void *salt, const char *name)\n{\n\tunsigned long hash = init_name_hash(salt);\n\tunsigned long len = 0, c;\n\n\tc = (unsigned char)*name;\n\tdo {\n\t\tlen++;\n\t\thash = partial_name_hash(c, hash);\n\t\tc = (unsigned char)name[len];\n\t} while (c && c != '/');\n\treturn hashlen_create(end_name_hash(hash), len);\n}\n\n#endif\n\n/*\n * Name resolution.\n * This is the basic name resolution function, turning a pathname into\n * the final dentry. We expect 'base' to be positive and a directory.\n *\n * Returns 0 and nd will have valid dentry and mnt on success.\n * Returns error and drops reference to input namei data on failure.\n */\nstatic int link_path_walk(const char *name, struct nameidata *nd)\n{\n\tint err;\n\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\twhile (*name=='/')\n\t\tname++;\n\tif (!*name)\n\t\treturn 0;\n\n\t/* At this point we know we have a real path component. */\n\tfor(;;) {\n\t\tu64 hash_len;\n\t\tint type;\n\n\t\terr = may_lookup(nd);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\thash_len = hash_name(nd->path.dentry, name);\n\n\t\ttype = LAST_NORM;\n\t\tif (name[0] == '.') switch (hashlen_len(hash_len)) {\n\t\t\tcase 2:\n\t\t\t\tif (name[1] == '.') {\n\t\t\t\t\ttype = LAST_DOTDOT;\n\t\t\t\t\tnd->flags |= LOOKUP_JUMPED;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\ttype = LAST_DOT;\n\t\t}\n\t\tif (likely(type == LAST_NORM)) {\n\t\t\tstruct dentry *parent = nd->path.dentry;\n\t\t\tnd->flags &= ~LOOKUP_JUMPED;\n\t\t\tif (unlikely(parent->d_flags & DCACHE_OP_HASH)) {\n\t\t\t\tstruct qstr this = { { .hash_len = hash_len }, .name = name };\n\t\t\t\terr = parent->d_op->d_hash(parent, &this);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t\thash_len = this.hash_len;\n\t\t\t\tname = this.name;\n\t\t\t}\n\t\t}\n\n\t\tnd->last.hash_len = hash_len;\n\t\tnd->last.name = name;\n\t\tnd->last_type = type;\n\n\t\tname += hashlen_len(hash_len);\n\t\tif (!*name)\n\t\t\tgoto OK;\n\t\t/*\n\t\t * If it wasn't NUL, we know it was '/'. Skip that\n\t\t * slash, and continue until no more slashes.\n\t\t */\n\t\tdo {\n\t\t\tname++;\n\t\t} while (unlikely(*name == '/'));\n\t\tif (unlikely(!*name)) {\nOK:\n\t\t\t/* pathname body, done */\n\t\t\tif (!nd->depth)\n\t\t\t\treturn 0;\n\t\t\tname = nd->stack[nd->depth - 1].name;\n\t\t\t/* trailing symlink, done */\n\t\t\tif (!name)\n\t\t\t\treturn 0;\n\t\t\t/* last component of nested symlink */\n\t\t\terr = walk_component(nd, WALK_FOLLOW);\n\t\t} else {\n\t\t\t/* not the last component */\n\t\t\terr = walk_component(nd, WALK_FOLLOW | WALK_MORE);\n\t\t}\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (err) {\n\t\t\tconst char *s = get_link(nd);\n\n\t\t\tif (IS_ERR(s))\n\t\t\t\treturn PTR_ERR(s);\n\t\t\terr = 0;\n\t\t\tif (unlikely(!s)) {\n\t\t\t\t/* jumped */\n\t\t\t\tput_link(nd);\n\t\t\t} else {\n\t\t\t\tnd->stack[nd->depth - 1].name = name;\n\t\t\t\tname = s;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (unlikely(!d_can_lookup(nd->path.dentry))) {\n\t\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\t\tif (unlazy_walk(nd))\n\t\t\t\t\treturn -ECHILD;\n\t\t\t}\n\t\t\treturn -ENOTDIR;\n\t\t}\n\t}\n}\n\n/* must be paired with terminate_walk() */\nstatic const char *path_init(struct nameidata *nd, unsigned flags)\n{\n\tconst char *s = nd->name->name;\n\n\tif (!*s)\n\t\tflags &= ~LOOKUP_RCU;\n\tif (flags & LOOKUP_RCU)\n\t\trcu_read_lock();\n\n\tnd->last_type = LAST_ROOT; /* if there are only slashes... */\n\tnd->flags = flags | LOOKUP_JUMPED | LOOKUP_PARENT;\n\tnd->depth = 0;\n\tif (flags & LOOKUP_ROOT) {\n\t\tstruct dentry *root = nd->root.dentry;\n\t\tstruct inode *inode = root->d_inode;\n\t\tif (*s && unlikely(!d_can_lookup(root)))\n\t\t\treturn ERR_PTR(-ENOTDIR);\n\t\tnd->path = nd->root;\n\t\tnd->inode = inode;\n\t\tif (flags & LOOKUP_RCU) {\n\t\t\tnd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);\n\t\t\tnd->root_seq = nd->seq;\n\t\t\tnd->m_seq = read_seqbegin(&mount_lock);\n\t\t} else {\n\t\t\tpath_get(&nd->path);\n\t\t}\n\t\treturn s;\n\t}\n\n\tnd->root.mnt = NULL;\n\tnd->path.mnt = NULL;\n\tnd->path.dentry = NULL;\n\n\tnd->m_seq = read_seqbegin(&mount_lock);\n\tif (*s == '/') {\n\t\tset_root(nd);\n\t\tif (likely(!nd_jump_root(nd)))\n\t\t\treturn s;\n\t\treturn ERR_PTR(-ECHILD);\n\t} else if (nd->dfd == AT_FDCWD) {\n\t\tif (flags & LOOKUP_RCU) {\n\t\t\tstruct fs_struct *fs = current->fs;\n\t\t\tunsigned seq;\n\n\t\t\tdo {\n\t\t\t\tseq = read_seqcount_begin(&fs->seq);\n\t\t\t\tnd->path = fs->pwd;\n\t\t\t\tnd->inode = nd->path.dentry->d_inode;\n\t\t\t\tnd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);\n\t\t\t} while (read_seqcount_retry(&fs->seq, seq));\n\t\t} else {\n\t\t\tget_fs_pwd(current->fs, &nd->path);\n\t\t\tnd->inode = nd->path.dentry->d_inode;\n\t\t}\n\t\treturn s;\n\t} else {\n\t\t/* Caller must check execute permissions on the starting path component */\n\t\tstruct fd f = fdget_raw(nd->dfd);\n\t\tstruct dentry *dentry;\n\n\t\tif (!f.file)\n\t\t\treturn ERR_PTR(-EBADF);\n\n\t\tdentry = f.file->f_path.dentry;\n\n\t\tif (*s && unlikely(!d_can_lookup(dentry))) {\n\t\t\tfdput(f);\n\t\t\treturn ERR_PTR(-ENOTDIR);\n\t\t}\n\n\t\tnd->path = f.file->f_path;\n\t\tif (flags & LOOKUP_RCU) {\n\t\t\tnd->inode = nd->path.dentry->d_inode;\n\t\t\tnd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);\n\t\t} else {\n\t\t\tpath_get(&nd->path);\n\t\t\tnd->inode = nd->path.dentry->d_inode;\n\t\t}\n\t\tfdput(f);\n\t\treturn s;\n\t}\n}\n\nstatic const char *trailing_symlink(struct nameidata *nd)\n{\n\tconst char *s;\n\tint error = may_follow_link(nd);\n\tif (unlikely(error))\n\t\treturn ERR_PTR(error);\n\tnd->flags |= LOOKUP_PARENT;\n\tnd->stack[0].name = NULL;\n\ts = get_link(nd);\n\treturn s ? s : \"\";\n}\n\nstatic inline int lookup_last(struct nameidata *nd)\n{\n\tif (nd->last_type == LAST_NORM && nd->last.name[nd->last.len])\n\t\tnd->flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY;\n\n\tnd->flags &= ~LOOKUP_PARENT;\n\treturn walk_component(nd, 0);\n}\n\nstatic int handle_lookup_down(struct nameidata *nd)\n{\n\tstruct path path = nd->path;\n\tstruct inode *inode = nd->inode;\n\tunsigned seq = nd->seq;\n\tint err;\n\n\tif (nd->flags & LOOKUP_RCU) {\n\t\t/*\n\t\t * don't bother with unlazy_walk on failure - we are\n\t\t * at the very beginning of walk, so we lose nothing\n\t\t * if we simply redo everything in non-RCU mode\n\t\t */\n\t\tif (unlikely(!__follow_mount_rcu(nd, &path, &inode, &seq)))\n\t\t\treturn -ECHILD;\n\t} else {\n\t\tdget(path.dentry);\n\t\terr = follow_managed(&path, nd);\n\t\tif (unlikely(err < 0))\n\t\t\treturn err;\n\t\tinode = d_backing_inode(path.dentry);\n\t\tseq = 0;\n\t}\n\tpath_to_nameidata(&path, nd);\n\tnd->inode = inode;\n\tnd->seq = seq;\n\treturn 0;\n}\n\n/* Returns 0 and nd will be valid on success; Retuns error, otherwise. */\nstatic int path_lookupat(struct nameidata *nd, unsigned flags, struct path *path)\n{\n\tconst char *s = path_init(nd, flags);\n\tint err;\n\n\tif (unlikely(flags & LOOKUP_DOWN) && !IS_ERR(s)) {\n\t\terr = handle_lookup_down(nd);\n\t\tif (unlikely(err < 0))\n\t\t\ts = ERR_PTR(err);\n\t}\n\n\twhile (!(err = link_path_walk(s, nd))\n\t\t&& ((err = lookup_last(nd)) > 0)) {\n\t\ts = trailing_symlink(nd);\n\t}\n\tif (!err)\n\t\terr = complete_walk(nd);\n\n\tif (!err && nd->flags & LOOKUP_DIRECTORY)\n\t\tif (!d_can_lookup(nd->path.dentry))\n\t\t\terr = -ENOTDIR;\n\tif (!err) {\n\t\t*path = nd->path;\n\t\tnd->path.mnt = NULL;\n\t\tnd->path.dentry = NULL;\n\t}\n\tterminate_walk(nd);\n\treturn err;\n}\n\nint filename_lookup(int dfd, struct filename *name, unsigned flags,\n\t\t    struct path *path, struct path *root)\n{\n\tint retval;\n\tstruct nameidata nd;\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\tif (unlikely(root)) {\n\t\tnd.root = *root;\n\t\tflags |= LOOKUP_ROOT;\n\t}\n\tset_nameidata(&nd, dfd, name);\n\tretval = path_lookupat(&nd, flags | LOOKUP_RCU, path);\n\tif (unlikely(retval == -ECHILD))\n\t\tretval = path_lookupat(&nd, flags, path);\n\tif (unlikely(retval == -ESTALE))\n\t\tretval = path_lookupat(&nd, flags | LOOKUP_REVAL, path);\n\n\tif (likely(!retval))\n\t\taudit_inode(name, path->dentry, 0);\n\trestore_nameidata();\n\tputname(name);\n\treturn retval;\n}\n\n/* Returns 0 and nd will be valid on success; Retuns error, otherwise. */\nstatic int path_parentat(struct nameidata *nd, unsigned flags,\n\t\t\t\tstruct path *parent)\n{\n\tconst char *s = path_init(nd, flags);\n\tint err = link_path_walk(s, nd);\n\tif (!err)\n\t\terr = complete_walk(nd);\n\tif (!err) {\n\t\t*parent = nd->path;\n\t\tnd->path.mnt = NULL;\n\t\tnd->path.dentry = NULL;\n\t}\n\tterminate_walk(nd);\n\treturn err;\n}\n\nstatic struct filename *filename_parentat(int dfd, struct filename *name,\n\t\t\t\tunsigned int flags, struct path *parent,\n\t\t\t\tstruct qstr *last, int *type)\n{\n\tint retval;\n\tstruct nameidata nd;\n\n\tif (IS_ERR(name))\n\t\treturn name;\n\tset_nameidata(&nd, dfd, name);\n\tretval = path_parentat(&nd, flags | LOOKUP_RCU, parent);\n\tif (unlikely(retval == -ECHILD))\n\t\tretval = path_parentat(&nd, flags, parent);\n\tif (unlikely(retval == -ESTALE))\n\t\tretval = path_parentat(&nd, flags | LOOKUP_REVAL, parent);\n\tif (likely(!retval)) {\n\t\t*last = nd.last;\n\t\t*type = nd.last_type;\n\t\taudit_inode(name, parent->dentry, AUDIT_INODE_PARENT);\n\t} else {\n\t\tputname(name);\n\t\tname = ERR_PTR(retval);\n\t}\n\trestore_nameidata();\n\treturn name;\n}\n\n/* does lookup, returns the object with parent locked */\nstruct dentry *kern_path_locked(const char *name, struct path *path)\n{\n\tstruct filename *filename;\n\tstruct dentry *d;\n\tstruct qstr last;\n\tint type;\n\n\tfilename = filename_parentat(AT_FDCWD, getname_kernel(name), 0, path,\n\t\t\t\t    &last, &type);\n\tif (IS_ERR(filename))\n\t\treturn ERR_CAST(filename);\n\tif (unlikely(type != LAST_NORM)) {\n\t\tpath_put(path);\n\t\tputname(filename);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tinode_lock_nested(path->dentry->d_inode, I_MUTEX_PARENT);\n\td = __lookup_hash(&last, path->dentry, 0);\n\tif (IS_ERR(d)) {\n\t\tinode_unlock(path->dentry->d_inode);\n\t\tpath_put(path);\n\t}\n\tputname(filename);\n\treturn d;\n}\n\nint kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\treturn filename_lookup(AT_FDCWD, getname_kernel(name),\n\t\t\t       flags, path, NULL);\n}\nEXPORT_SYMBOL(kern_path);\n\n/**\n * vfs_path_lookup - lookup a file path relative to a dentry-vfsmount pair\n * @dentry:  pointer to dentry of the base directory\n * @mnt: pointer to vfs mount of the base directory\n * @name: pointer to file name\n * @flags: lookup flags\n * @path: pointer to struct path to fill\n */\nint vfs_path_lookup(struct dentry *dentry, struct vfsmount *mnt,\n\t\t    const char *name, unsigned int flags,\n\t\t    struct path *path)\n{\n\tstruct path root = {.mnt = mnt, .dentry = dentry};\n\t/* the first argument of filename_lookup() is ignored with root */\n\treturn filename_lookup(AT_FDCWD, getname_kernel(name),\n\t\t\t       flags , path, &root);\n}\nEXPORT_SYMBOL(vfs_path_lookup);\n\nstatic int lookup_one_len_common(const char *name, struct dentry *base,\n\t\t\t\t int len, struct qstr *this)\n{\n\tthis->name = name;\n\tthis->len = len;\n\tthis->hash = full_name_hash(base, name, len);\n\tif (!len)\n\t\treturn -EACCES;\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn -EACCES;\n\t}\n\n\twhile (len--) {\n\t\tunsigned int c = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn -EACCES;\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, this);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn inode_permission(base->d_inode, MAY_EXEC);\n}\n\n/**\n * try_lookup_one_len - filesystem helper to lookup single pathname component\n * @name:\tpathname component to lookup\n * @base:\tbase directory to lookup from\n * @len:\tmaximum length @len should be interpreted to\n *\n * Look up a dentry by name in the dcache, returning NULL if it does not\n * currently exist.  The function does not try to create a dentry.\n *\n * Note that this routine is purely a helper for filesystem usage and should\n * not be called by generic code.\n *\n * The caller must hold base->i_mutex.\n */\nstruct dentry *try_lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tint err;\n\n\tWARN_ON_ONCE(!inode_is_locked(base->d_inode));\n\n\terr = lookup_one_len_common(name, base, len, &this);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn lookup_dcache(&this, base, 0);\n}\nEXPORT_SYMBOL(try_lookup_one_len);\n\n/**\n * lookup_one_len - filesystem helper to lookup single pathname component\n * @name:\tpathname component to lookup\n * @base:\tbase directory to lookup from\n * @len:\tmaximum length @len should be interpreted to\n *\n * Note that this routine is purely a helper for filesystem usage and should\n * not be called by generic code.\n *\n * The caller must hold base->i_mutex.\n */\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct dentry *dentry;\n\tstruct qstr this;\n\tint err;\n\n\tWARN_ON_ONCE(!inode_is_locked(base->d_inode));\n\n\terr = lookup_one_len_common(name, base, len, &this);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tdentry = lookup_dcache(&this, base, 0);\n\treturn dentry ? dentry : __lookup_slow(&this, base, 0);\n}\nEXPORT_SYMBOL(lookup_one_len);\n\n/**\n * lookup_one_len_unlocked - filesystem helper to lookup single pathname component\n * @name:\tpathname component to lookup\n * @base:\tbase directory to lookup from\n * @len:\tmaximum length @len should be interpreted to\n *\n * Note that this routine is purely a helper for filesystem usage and should\n * not be called by generic code.\n *\n * Unlike lookup_one_len, it should be called without the parent\n * i_mutex held, and will take the i_mutex itself if necessary.\n */\nstruct dentry *lookup_one_len_unlocked(const char *name,\n\t\t\t\t       struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tint err;\n\tstruct dentry *ret;\n\n\terr = lookup_one_len_common(name, base, len, &this);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tret = lookup_dcache(&this, base, 0);\n\tif (!ret)\n\t\tret = lookup_slow(&this, base, 0);\n\treturn ret;\n}\nEXPORT_SYMBOL(lookup_one_len_unlocked);\n\n/*\n * Like lookup_one_len_unlocked(), except that it yields ERR_PTR(-ENOENT)\n * on negatives.  Returns known positive or ERR_PTR(); that's what\n * most of the users want.  Note that pinned negative with unlocked parent\n * _can_ become positive at any time, so callers of lookup_one_len_unlocked()\n * need to be very careful; pinned positives have ->d_inode stable, so\n * this one avoids such problems.\n */\nstruct dentry *lookup_positive_unlocked(const char *name,\n\t\t\t\t       struct dentry *base, int len)\n{\n\tstruct dentry *ret = lookup_one_len_unlocked(name, base, len);\n\tif (!IS_ERR(ret) && d_flags_negative(smp_load_acquire(&ret->d_flags))) {\n\t\tdput(ret);\n\t\tret = ERR_PTR(-ENOENT);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(lookup_positive_unlocked);\n\n#ifdef CONFIG_UNIX98_PTYS\nint path_pts(struct path *path)\n{\n\t/* Find something mounted on \"pts\" in the same directory as\n\t * the input path.\n\t */\n\tstruct dentry *child, *parent;\n\tstruct qstr this;\n\tint ret;\n\n\tret = path_parent_directory(path);\n\tif (ret)\n\t\treturn ret;\n\n\tparent = path->dentry;\n\tthis.name = \"pts\";\n\tthis.len = 3;\n\tchild = d_hash_and_lookup(parent, &this);\n\tif (!child)\n\t\treturn -ENOENT;\n\n\tpath->dentry = child;\n\tdput(parent);\n\tfollow_mount(path);\n\treturn 0;\n}\n#endif\n\nint user_path_at_empty(int dfd, const char __user *name, unsigned flags,\n\t\t struct path *path, int *empty)\n{\n\treturn filename_lookup(dfd, getname_flags(name, flags, empty),\n\t\t\t       flags, path, NULL);\n}\nEXPORT_SYMBOL(user_path_at_empty);\n\n/**\n * path_mountpoint - look up a path to be umounted\n * @nd:\t\tlookup context\n * @flags:\tlookup flags\n * @path:\tpointer to container for result\n *\n * Look up the given name, but don't attempt to revalidate the last component.\n * Returns 0 and \"path\" will be valid on success; Returns error otherwise.\n */\nstatic int\npath_mountpoint(struct nameidata *nd, unsigned flags, struct path *path)\n{\n\tconst char *s = path_init(nd, flags);\n\tint err;\n\n\twhile (!(err = link_path_walk(s, nd)) &&\n\t\t(err = lookup_last(nd)) > 0) {\n\t\ts = trailing_symlink(nd);\n\t}\n\tif (!err && (nd->flags & LOOKUP_RCU))\n\t\terr = unlazy_walk(nd);\n\tif (!err)\n\t\terr = handle_lookup_down(nd);\n\tif (!err) {\n\t\t*path = nd->path;\n\t\tnd->path.mnt = NULL;\n\t\tnd->path.dentry = NULL;\n\t}\n\tterminate_walk(nd);\n\treturn err;\n}\n\nstatic int\nfilename_mountpoint(int dfd, struct filename *name, struct path *path,\n\t\t\tunsigned int flags)\n{\n\tstruct nameidata nd;\n\tint error;\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\tset_nameidata(&nd, dfd, name);\n\terror = path_mountpoint(&nd, flags | LOOKUP_RCU, path);\n\tif (unlikely(error == -ECHILD))\n\t\terror = path_mountpoint(&nd, flags, path);\n\tif (unlikely(error == -ESTALE))\n\t\terror = path_mountpoint(&nd, flags | LOOKUP_REVAL, path);\n\tif (likely(!error))\n\t\taudit_inode(name, path->dentry, AUDIT_INODE_NOEVAL);\n\trestore_nameidata();\n\tputname(name);\n\treturn error;\n}\n\n/**\n * user_path_mountpoint_at - lookup a path from userland in order to umount it\n * @dfd:\tdirectory file descriptor\n * @name:\tpathname from userland\n * @flags:\tlookup flags\n * @path:\tpointer to container to hold result\n *\n * A umount is a special case for path walking. We're not actually interested\n * in the inode in this situation, and ESTALE errors can be a problem. We\n * simply want track down the dentry and vfsmount attached at the mountpoint\n * and avoid revalidating the last component.\n *\n * Returns 0 and populates \"path\" on success.\n */\nint\nuser_path_mountpoint_at(int dfd, const char __user *name, unsigned int flags,\n\t\t\tstruct path *path)\n{\n\treturn filename_mountpoint(dfd, getname(name), path, flags);\n}\n\nint\nkern_path_mountpoint(int dfd, const char *name, struct path *path,\n\t\t\tunsigned int flags)\n{\n\treturn filename_mountpoint(dfd, getname_kernel(name), path, flags);\n}\nEXPORT_SYMBOL(kern_path_mountpoint);\n\nint __check_sticky(struct inode *dir, struct inode *inode)\n{\n\tkuid_t fsuid = current_fsuid();\n\n\tif (uid_eq(inode->i_uid, fsuid))\n\t\treturn 0;\n\tif (uid_eq(dir->i_uid, fsuid))\n\t\treturn 0;\n\treturn !capable_wrt_inode_uidgid(inode, CAP_FOWNER);\n}\nEXPORT_SYMBOL(__check_sticky);\n\n/*\n *\tCheck whether we can remove a link victim from directory dir, check\n *  whether the type of victim is right.\n *  1. We can't do it if dir is read-only (done in permission())\n *  2. We should have write and exec permissions on dir\n *  3. We can't remove anything from append-only dir\n *  4. We can't do anything with immutable dir (done in permission())\n *  5. If the sticky bit on dir is set we should either\n *\ta. be owner of dir, or\n *\tb. be owner of victim, or\n *\tc. have CAP_FOWNER capability\n *  6. If the victim is append-only or immutable we can't do antyhing with\n *     links pointing to it.\n *  7. If the victim has an unknown uid or gid we can't change the inode.\n *  8. If we were asked to remove a directory and victim isn't one - ENOTDIR.\n *  9. If we were asked to remove a non-directory and victim isn't one - EISDIR.\n * 10. We can't remove a root or mountpoint.\n * 11. We don't allow removal of NFS sillyrenamed files; it's handled by\n *     nfs_async_unlink().\n */\nstatic int may_delete(struct inode *dir, struct dentry *victim, bool isdir)\n{\n\tstruct inode *inode = d_backing_inode(victim);\n\tint error;\n\n\tif (d_is_negative(victim))\n\t\treturn -ENOENT;\n\tBUG_ON(!inode);\n\n\tBUG_ON(victim->d_parent->d_inode != dir);\n\n\t/* Inode writeback is not safe when the uid or gid are invalid. */\n\tif (!uid_valid(inode->i_uid) || !gid_valid(inode->i_gid))\n\t\treturn -EOVERFLOW;\n\n\taudit_inode_child(dir, victim, AUDIT_TYPE_CHILD_DELETE);\n\n\terror = inode_permission(dir, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\tif (IS_APPEND(dir))\n\t\treturn -EPERM;\n\n\tif (check_sticky(dir, inode) || IS_APPEND(inode) ||\n\t    IS_IMMUTABLE(inode) || IS_SWAPFILE(inode) || HAS_UNMAPPED_ID(inode))\n\t\treturn -EPERM;\n\tif (isdir) {\n\t\tif (!d_is_dir(victim))\n\t\t\treturn -ENOTDIR;\n\t\tif (IS_ROOT(victim))\n\t\t\treturn -EBUSY;\n\t} else if (d_is_dir(victim))\n\t\treturn -EISDIR;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\tif (victim->d_flags & DCACHE_NFSFS_RENAMED)\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\n/*\tCheck whether we can create an object with dentry child in directory\n *  dir.\n *  1. We can't do it if child already exists (open has special treatment for\n *     this case, but since we are inlined it's OK)\n *  2. We can't do it if dir is read-only (done in permission())\n *  3. We can't do it if the fs can't represent the fsuid or fsgid.\n *  4. We should have write and exec permissions on dir\n *  5. We can't do it if dir is immutable (done in permission())\n */\nstatic inline int may_create(struct inode *dir, struct dentry *child)\n{\n\tstruct user_namespace *s_user_ns;\n\taudit_inode_child(dir, child, AUDIT_TYPE_CHILD_CREATE);\n\tif (child->d_inode)\n\t\treturn -EEXIST;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\ts_user_ns = dir->i_sb->s_user_ns;\n\tif (!kuid_has_mapping(s_user_ns, current_fsuid()) ||\n\t    !kgid_has_mapping(s_user_ns, current_fsgid()))\n\t\treturn -EOVERFLOW;\n\treturn inode_permission(dir, MAY_WRITE | MAY_EXEC);\n}\n\n/*\n * p1 and p2 should be directories on the same fs.\n */\nstruct dentry *lock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tstruct dentry *p;\n\n\tif (p1 == p2) {\n\t\tinode_lock_nested(p1->d_inode, I_MUTEX_PARENT);\n\t\treturn NULL;\n\t}\n\n\tmutex_lock(&p1->d_sb->s_vfs_rename_mutex);\n\n\tp = d_ancestor(p2, p1);\n\tif (p) {\n\t\tinode_lock_nested(p2->d_inode, I_MUTEX_PARENT);\n\t\tinode_lock_nested(p1->d_inode, I_MUTEX_CHILD);\n\t\treturn p;\n\t}\n\n\tp = d_ancestor(p1, p2);\n\tif (p) {\n\t\tinode_lock_nested(p1->d_inode, I_MUTEX_PARENT);\n\t\tinode_lock_nested(p2->d_inode, I_MUTEX_CHILD);\n\t\treturn p;\n\t}\n\n\tinode_lock_nested(p1->d_inode, I_MUTEX_PARENT);\n\tinode_lock_nested(p2->d_inode, I_MUTEX_PARENT2);\n\treturn NULL;\n}\nEXPORT_SYMBOL(lock_rename);\n\nvoid unlock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tinode_unlock(p1->d_inode);\n\tif (p1 != p2) {\n\t\tinode_unlock(p2->d_inode);\n\t\tmutex_unlock(&p1->d_sb->s_vfs_rename_mutex);\n\t}\n}\nEXPORT_SYMBOL(unlock_rename);\n\nint vfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\tbool want_excl)\n{\n\tint error = may_create(dir, dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->create)\n\t\treturn -EACCES;\t/* shouldn't it be ENOSYS? */\n\tmode &= S_IALLUGO;\n\tmode |= S_IFREG;\n\terror = security_inode_create(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\terror = dir->i_op->create(dir, dentry, mode, want_excl);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_create);\n\nint vfs_mkobj(struct dentry *dentry, umode_t mode,\n\t\tint (*f)(struct dentry *, umode_t, void *),\n\t\tvoid *arg)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tint error = may_create(dir, dentry);\n\tif (error)\n\t\treturn error;\n\n\tmode &= S_IALLUGO;\n\tmode |= S_IFREG;\n\terror = security_inode_create(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\terror = f(dentry, mode, arg);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_mkobj);\n\nbool may_open_dev(const struct path *path)\n{\n\treturn !(path->mnt->mnt_flags & MNT_NODEV) &&\n\t\t!(path->mnt->mnt_sb->s_iflags & SB_I_NODEV);\n}\n\nstatic int may_open(const struct path *path, int acc_mode, int flag)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFLNK:\n\t\treturn -ELOOP;\n\tcase S_IFDIR:\n\t\tif (acc_mode & MAY_WRITE)\n\t\t\treturn -EISDIR;\n\t\tbreak;\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\tif (!may_open_dev(path))\n\t\t\treturn -EACCES;\n\t\t/*FALLTHRU*/\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tflag &= ~O_TRUNC;\n\t\tbreak;\n\t}\n\n\terror = inode_permission(inode, MAY_OPEN | acc_mode);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * An append-only file must be opened in append mode for writing.\n\t */\n\tif (IS_APPEND(inode)) {\n\t\tif  ((flag & O_ACCMODE) != O_RDONLY && !(flag & O_APPEND))\n\t\t\treturn -EPERM;\n\t\tif (flag & O_TRUNC)\n\t\t\treturn -EPERM;\n\t}\n\n\t/* O_NOATIME can only be set by the owner or superuser */\n\tif (flag & O_NOATIME && !inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\n\treturn 0;\n}\n\nstatic int handle_truncate(struct file *filp)\n{\n\tconst struct path *path = &filp->f_path;\n\tstruct inode *inode = path->dentry->d_inode;\n\tint error = get_write_access(inode);\n\tif (error)\n\t\treturn error;\n\t/*\n\t * Refuse to truncate files with mandatory locks held on them.\n\t */\n\terror = locks_verify_locked(filp);\n\tif (!error)\n\t\terror = security_path_truncate(path);\n\tif (!error) {\n\t\terror = do_truncate(path->dentry, 0,\n\t\t\t\t    ATTR_MTIME|ATTR_CTIME|ATTR_OPEN,\n\t\t\t\t    filp);\n\t}\n\tput_write_access(inode);\n\treturn error;\n}\n\nstatic inline int open_to_namei_flags(int flag)\n{\n\tif ((flag & O_ACCMODE) == 3)\n\t\tflag--;\n\treturn flag;\n}\n\nstatic int may_o_create(const struct path *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct user_namespace *s_user_ns;\n\tint error = security_path_mknod(dir, dentry, mode, 0);\n\tif (error)\n\t\treturn error;\n\n\ts_user_ns = dir->dentry->d_sb->s_user_ns;\n\tif (!kuid_has_mapping(s_user_ns, current_fsuid()) ||\n\t    !kgid_has_mapping(s_user_ns, current_fsgid()))\n\t\treturn -EOVERFLOW;\n\n\terror = inode_permission(dir->dentry->d_inode, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\n\treturn security_inode_create(dir->dentry->d_inode, dentry, mode);\n}\n\n/*\n * Attempt to atomically look up, create and open a file from a negative\n * dentry.\n *\n * Returns 0 if successful.  The file will have been created and attached to\n * @file by the filesystem calling finish_open().\n *\n * If the file was looked up only or didn't need creating, FMODE_OPENED won't\n * be set.  The caller will need to perform the open themselves.  @path will\n * have been updated to point to the new dentry.  This may be negative.\n *\n * Returns an error code otherwise.\n */\nstatic int atomic_open(struct nameidata *nd, struct dentry *dentry,\n\t\t\tstruct path *path, struct file *file,\n\t\t\tconst struct open_flags *op,\n\t\t\tint open_flag, umode_t mode)\n{\n\tstruct dentry *const DENTRY_NOT_SET = (void *) -1UL;\n\tstruct inode *dir =  nd->path.dentry->d_inode;\n\tint error;\n\n\tif (!(~open_flag & (O_EXCL | O_CREAT)))\t/* both O_EXCL and O_CREAT */\n\t\topen_flag &= ~O_TRUNC;\n\n\tif (nd->flags & LOOKUP_DIRECTORY)\n\t\topen_flag |= O_DIRECTORY;\n\n\tfile->f_path.dentry = DENTRY_NOT_SET;\n\tfile->f_path.mnt = nd->path.mnt;\n\terror = dir->i_op->atomic_open(dir, dentry, file,\n\t\t\t\t       open_to_namei_flags(open_flag), mode);\n\td_lookup_done(dentry);\n\tif (!error) {\n\t\tif (file->f_mode & FMODE_OPENED) {\n\t\t\t/*\n\t\t\t * We didn't have the inode before the open, so check open\n\t\t\t * permission here.\n\t\t\t */\n\t\t\tint acc_mode = op->acc_mode;\n\t\t\tif (file->f_mode & FMODE_CREATED) {\n\t\t\t\tWARN_ON(!(open_flag & O_CREAT));\n\t\t\t\tfsnotify_create(dir, dentry);\n\t\t\t\tacc_mode = 0;\n\t\t\t}\n\t\t\terror = may_open(&file->f_path, acc_mode, open_flag);\n\t\t\tif (WARN_ON(error > 0))\n\t\t\t\terror = -EINVAL;\n\t\t} else if (WARN_ON(file->f_path.dentry == DENTRY_NOT_SET)) {\n\t\t\terror = -EIO;\n\t\t} else {\n\t\t\tif (file->f_path.dentry) {\n\t\t\t\tdput(dentry);\n\t\t\t\tdentry = file->f_path.dentry;\n\t\t\t}\n\t\t\tif (file->f_mode & FMODE_CREATED)\n\t\t\t\tfsnotify_create(dir, dentry);\n\t\t\tif (unlikely(d_is_negative(dentry))) {\n\t\t\t\terror = -ENOENT;\n\t\t\t} else {\n\t\t\t\tpath->dentry = dentry;\n\t\t\t\tpath->mnt = nd->path.mnt;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tdput(dentry);\n\treturn error;\n}\n\n/*\n * Look up and maybe create and open the last component.\n *\n * Must be called with parent locked (exclusive in O_CREAT case).\n *\n * Returns 0 on success, that is, if\n *  the file was successfully atomically created (if necessary) and opened, or\n *  the file was not completely opened at this time, though lookups and\n *  creations were performed.\n * These case are distinguished by presence of FMODE_OPENED on file->f_mode.\n * In the latter case dentry returned in @path might be negative if O_CREAT\n * hadn't been specified.\n *\n * An error code is returned on failure.\n */\nstatic int lookup_open(struct nameidata *nd, struct path *path,\n\t\t\tstruct file *file,\n\t\t\tconst struct open_flags *op,\n\t\t\tbool got_write)\n{\n\tstruct dentry *dir = nd->path.dentry;\n\tstruct inode *dir_inode = dir->d_inode;\n\tint open_flag = op->open_flag;\n\tstruct dentry *dentry;\n\tint error, create_error = 0;\n\tumode_t mode = op->mode;\n\tDECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);\n\n\tif (unlikely(IS_DEADDIR(dir_inode)))\n\t\treturn -ENOENT;\n\n\tfile->f_mode &= ~FMODE_CREATED;\n\tdentry = d_lookup(dir, &nd->last);\n\tfor (;;) {\n\t\tif (!dentry) {\n\t\t\tdentry = d_alloc_parallel(dir, &nd->last, &wq);\n\t\t\tif (IS_ERR(dentry))\n\t\t\t\treturn PTR_ERR(dentry);\n\t\t}\n\t\tif (d_in_lookup(dentry))\n\t\t\tbreak;\n\n\t\terror = d_revalidate(dentry, nd->flags);\n\t\tif (likely(error > 0))\n\t\t\tbreak;\n\t\tif (error)\n\t\t\tgoto out_dput;\n\t\td_invalidate(dentry);\n\t\tdput(dentry);\n\t\tdentry = NULL;\n\t}\n\tif (dentry->d_inode) {\n\t\t/* Cached positive dentry: will open in f_op->open */\n\t\tgoto out_no_open;\n\t}\n\n\t/*\n\t * Checking write permission is tricky, bacuse we don't know if we are\n\t * going to actually need it: O_CREAT opens should work as long as the\n\t * file exists.  But checking existence breaks atomicity.  The trick is\n\t * to check access and if not granted clear O_CREAT from the flags.\n\t *\n\t * Another problem is returing the \"right\" error value (e.g. for an\n\t * O_EXCL open we want to return EEXIST not EROFS).\n\t */\n\tif (open_flag & O_CREAT) {\n\t\tif (!IS_POSIXACL(dir->d_inode))\n\t\t\tmode &= ~current_umask();\n\t\tif (unlikely(!got_write)) {\n\t\t\tcreate_error = -EROFS;\n\t\t\topen_flag &= ~O_CREAT;\n\t\t\tif (open_flag & (O_EXCL | O_TRUNC))\n\t\t\t\tgoto no_open;\n\t\t\t/* No side effects, safe to clear O_CREAT */\n\t\t} else {\n\t\t\tcreate_error = may_o_create(&nd->path, dentry, mode);\n\t\t\tif (create_error) {\n\t\t\t\topen_flag &= ~O_CREAT;\n\t\t\t\tif (open_flag & O_EXCL)\n\t\t\t\t\tgoto no_open;\n\t\t\t}\n\t\t}\n\t} else if ((open_flag & (O_TRUNC|O_WRONLY|O_RDWR)) &&\n\t\t   unlikely(!got_write)) {\n\t\t/*\n\t\t * No O_CREATE -> atomicity not a requirement -> fall\n\t\t * back to lookup + open\n\t\t */\n\t\tgoto no_open;\n\t}\n\n\tif (dir_inode->i_op->atomic_open) {\n\t\terror = atomic_open(nd, dentry, path, file, op, open_flag,\n\t\t\t\t    mode);\n\t\tif (unlikely(error == -ENOENT) && create_error)\n\t\t\terror = create_error;\n\t\treturn error;\n\t}\n\nno_open:\n\tif (d_in_lookup(dentry)) {\n\t\tstruct dentry *res = dir_inode->i_op->lookup(dir_inode, dentry,\n\t\t\t\t\t\t\t     nd->flags);\n\t\td_lookup_done(dentry);\n\t\tif (unlikely(res)) {\n\t\t\tif (IS_ERR(res)) {\n\t\t\t\terror = PTR_ERR(res);\n\t\t\t\tgoto out_dput;\n\t\t\t}\n\t\t\tdput(dentry);\n\t\t\tdentry = res;\n\t\t}\n\t}\n\n\t/* Negative dentry, just create the file */\n\tif (!dentry->d_inode && (open_flag & O_CREAT)) {\n\t\tfile->f_mode |= FMODE_CREATED;\n\t\taudit_inode_child(dir_inode, dentry, AUDIT_TYPE_CHILD_CREATE);\n\t\tif (!dir_inode->i_op->create) {\n\t\t\terror = -EACCES;\n\t\t\tgoto out_dput;\n\t\t}\n\t\terror = dir_inode->i_op->create(dir_inode, dentry, mode,\n\t\t\t\t\t\topen_flag & O_EXCL);\n\t\tif (error)\n\t\t\tgoto out_dput;\n\t\tfsnotify_create(dir_inode, dentry);\n\t}\n\tif (unlikely(create_error) && !dentry->d_inode) {\n\t\terror = create_error;\n\t\tgoto out_dput;\n\t}\nout_no_open:\n\tpath->dentry = dentry;\n\tpath->mnt = nd->path.mnt;\n\treturn 0;\n\nout_dput:\n\tdput(dentry);\n\treturn error;\n}\n\n/*\n * Handle the last step of open()\n */\nstatic int do_last(struct nameidata *nd,\n\t\t   struct file *file, const struct open_flags *op)\n{\n\tstruct dentry *dir = nd->path.dentry;\n\tkuid_t dir_uid = dir->d_inode->i_uid;\n\tumode_t dir_mode = dir->d_inode->i_mode;\n\tint open_flag = op->open_flag;\n\tbool will_truncate = (open_flag & O_TRUNC) != 0;\n\tbool got_write = false;\n\tint acc_mode = op->acc_mode;\n\tunsigned seq;\n\tstruct inode *inode;\n\tstruct path path;\n\tint error;\n\n\tnd->flags &= ~LOOKUP_PARENT;\n\tnd->flags |= op->intent;\n\n\tif (nd->last_type != LAST_NORM) {\n\t\terror = handle_dots(nd, nd->last_type);\n\t\tif (unlikely(error))\n\t\t\treturn error;\n\t\tgoto finish_open;\n\t}\n\n\tif (!(open_flag & O_CREAT)) {\n\t\tif (nd->last.name[nd->last.len])\n\t\t\tnd->flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY;\n\t\t/* we _can_ be in RCU mode here */\n\t\terror = lookup_fast(nd, &path, &inode, &seq);\n\t\tif (likely(error > 0))\n\t\t\tgoto finish_lookup;\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tBUG_ON(nd->inode != dir->d_inode);\n\t\tBUG_ON(nd->flags & LOOKUP_RCU);\n\t} else {\n\t\t/* create side of things */\n\t\t/*\n\t\t * This will *only* deal with leaving RCU mode - LOOKUP_JUMPED\n\t\t * has been cleared when we got to the last component we are\n\t\t * about to look up\n\t\t */\n\t\terror = complete_walk(nd);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\taudit_inode(nd->name, dir, AUDIT_INODE_PARENT);\n\t\t/* trailing slashes? */\n\t\tif (unlikely(nd->last.name[nd->last.len]))\n\t\t\treturn -EISDIR;\n\t}\n\n\tif (open_flag & (O_CREAT | O_TRUNC | O_WRONLY | O_RDWR)) {\n\t\terror = mnt_want_write(nd->path.mnt);\n\t\tif (!error)\n\t\t\tgot_write = true;\n\t\t/*\n\t\t * do _not_ fail yet - we might not need that or fail with\n\t\t * a different error; let lookup_open() decide; we'll be\n\t\t * dropping this one anyway.\n\t\t */\n\t}\n\tif (open_flag & O_CREAT)\n\t\tinode_lock(dir->d_inode);\n\telse\n\t\tinode_lock_shared(dir->d_inode);\n\terror = lookup_open(nd, &path, file, op, got_write);\n\tif (open_flag & O_CREAT)\n\t\tinode_unlock(dir->d_inode);\n\telse\n\t\tinode_unlock_shared(dir->d_inode);\n\n\tif (error)\n\t\tgoto out;\n\n\tif (file->f_mode & FMODE_OPENED) {\n\t\tif ((file->f_mode & FMODE_CREATED) ||\n\t\t    !S_ISREG(file_inode(file)->i_mode))\n\t\t\twill_truncate = false;\n\n\t\taudit_inode(nd->name, file->f_path.dentry, 0);\n\t\tgoto opened;\n\t}\n\n\tif (file->f_mode & FMODE_CREATED) {\n\t\t/* Don't check for write permission, don't truncate */\n\t\topen_flag &= ~O_TRUNC;\n\t\twill_truncate = false;\n\t\tacc_mode = 0;\n\t\tpath_to_nameidata(&path, nd);\n\t\tgoto finish_open_created;\n\t}\n\n\t/*\n\t * If atomic_open() acquired write access it is dropped now due to\n\t * possible mount and symlink following (this might be optimized away if\n\t * necessary...)\n\t */\n\tif (got_write) {\n\t\tmnt_drop_write(nd->path.mnt);\n\t\tgot_write = false;\n\t}\n\n\terror = follow_managed(&path, nd);\n\tif (unlikely(error < 0))\n\t\treturn error;\n\n\t/*\n\t * create/update audit record if it already exists.\n\t */\n\taudit_inode(nd->name, path.dentry, 0);\n\n\tif (unlikely((open_flag & (O_EXCL | O_CREAT)) == (O_EXCL | O_CREAT))) {\n\t\tpath_to_nameidata(&path, nd);\n\t\treturn -EEXIST;\n\t}\n\n\tseq = 0;\t/* out of RCU mode, so the value doesn't matter */\n\tinode = d_backing_inode(path.dentry);\nfinish_lookup:\n\terror = step_into(nd, &path, 0, inode, seq);\n\tif (unlikely(error))\n\t\treturn error;\nfinish_open:\n\t/* Why this, you ask?  _Now_ we might have grown LOOKUP_JUMPED... */\n\terror = complete_walk(nd);\n\tif (error)\n\t\treturn error;\n\taudit_inode(nd->name, nd->path.dentry, 0);\n\tif (open_flag & O_CREAT) {\n\t\terror = -EISDIR;\n\t\tif (d_is_dir(nd->path.dentry))\n\t\t\tgoto out;\n\t\terror = may_create_in_sticky(dir_mode, dir_uid,\n\t\t\t\t\t     d_backing_inode(nd->path.dentry));\n\t\tif (unlikely(error))\n\t\t\tgoto out;\n\t}\n\terror = -ENOTDIR;\n\tif ((nd->flags & LOOKUP_DIRECTORY) && !d_can_lookup(nd->path.dentry))\n\t\tgoto out;\n\tif (!d_is_reg(nd->path.dentry))\n\t\twill_truncate = false;\n\n\tif (will_truncate) {\n\t\terror = mnt_want_write(nd->path.mnt);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tgot_write = true;\n\t}\nfinish_open_created:\n\terror = may_open(&nd->path, acc_mode, open_flag);\n\tif (error)\n\t\tgoto out;\n\tBUG_ON(file->f_mode & FMODE_OPENED); /* once it's opened, it's opened */\n\terror = vfs_open(&nd->path, file);\n\tif (error)\n\t\tgoto out;\nopened:\n\terror = ima_file_check(file, op->acc_mode);\n\tif (!error && will_truncate)\n\t\terror = handle_truncate(file);\nout:\n\tif (unlikely(error > 0)) {\n\t\tWARN_ON(1);\n\t\terror = -EINVAL;\n\t}\n\tif (got_write)\n\t\tmnt_drop_write(nd->path.mnt);\n\treturn error;\n}\n\nstruct dentry *vfs_tmpfile(struct dentry *dentry, umode_t mode, int open_flag)\n{\n\tstruct dentry *child = NULL;\n\tstruct inode *dir = dentry->d_inode;\n\tstruct inode *inode;\n\tint error;\n\n\t/* we want directory to be writable */\n\terror = inode_permission(dir, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\tgoto out_err;\n\terror = -EOPNOTSUPP;\n\tif (!dir->i_op->tmpfile)\n\t\tgoto out_err;\n\terror = -ENOMEM;\n\tchild = d_alloc(dentry, &slash_name);\n\tif (unlikely(!child))\n\t\tgoto out_err;\n\terror = dir->i_op->tmpfile(dir, child, mode);\n\tif (error)\n\t\tgoto out_err;\n\terror = -ENOENT;\n\tinode = child->d_inode;\n\tif (unlikely(!inode))\n\t\tgoto out_err;\n\tif (!(open_flag & O_EXCL)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state |= I_LINKABLE;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tima_post_create_tmpfile(inode);\n\treturn child;\n\nout_err:\n\tdput(child);\n\treturn ERR_PTR(error);\n}\nEXPORT_SYMBOL(vfs_tmpfile);\n\nstatic int do_tmpfile(struct nameidata *nd, unsigned flags,\n\t\tconst struct open_flags *op,\n\t\tstruct file *file)\n{\n\tstruct dentry *child;\n\tstruct path path;\n\tint error = path_lookupat(nd, flags | LOOKUP_DIRECTORY, &path);\n\tif (unlikely(error))\n\t\treturn error;\n\terror = mnt_want_write(path.mnt);\n\tif (unlikely(error))\n\t\tgoto out;\n\tchild = vfs_tmpfile(path.dentry, op->mode, op->open_flag);\n\terror = PTR_ERR(child);\n\tif (IS_ERR(child))\n\t\tgoto out2;\n\tdput(path.dentry);\n\tpath.dentry = child;\n\taudit_inode(nd->name, child, 0);\n\t/* Don't check for other permissions, the inode was just created */\n\terror = may_open(&path, 0, op->open_flag);\n\tif (error)\n\t\tgoto out2;\n\tfile->f_path.mnt = path.mnt;\n\terror = finish_open(file, child, NULL);\nout2:\n\tmnt_drop_write(path.mnt);\nout:\n\tpath_put(&path);\n\treturn error;\n}\n\nstatic int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)\n{\n\tstruct path path;\n\tint error = path_lookupat(nd, flags, &path);\n\tif (!error) {\n\t\taudit_inode(nd->name, path.dentry, 0);\n\t\terror = vfs_open(&path, file);\n\t\tpath_put(&path);\n\t}\n\treturn error;\n}\n\nstatic struct file *path_openat(struct nameidata *nd,\n\t\t\tconst struct open_flags *op, unsigned flags)\n{\n\tstruct file *file;\n\tint error;\n\n\tfile = alloc_empty_file(op->open_flag, current_cred());\n\tif (IS_ERR(file))\n\t\treturn file;\n\n\tif (unlikely(file->f_flags & __O_TMPFILE)) {\n\t\terror = do_tmpfile(nd, flags, op, file);\n\t} else if (unlikely(file->f_flags & O_PATH)) {\n\t\terror = do_o_path(nd, flags, file);\n\t} else {\n\t\tconst char *s = path_init(nd, flags);\n\t\twhile (!(error = link_path_walk(s, nd)) &&\n\t\t\t(error = do_last(nd, file, op)) > 0) {\n\t\t\tnd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);\n\t\t\ts = trailing_symlink(nd);\n\t\t}\n\t\tterminate_walk(nd);\n\t}\n\tif (likely(!error)) {\n\t\tif (likely(file->f_mode & FMODE_OPENED))\n\t\t\treturn file;\n\t\tWARN_ON(1);\n\t\terror = -EINVAL;\n\t}\n\tfput(file);\n\tif (error == -EOPENSTALE) {\n\t\tif (flags & LOOKUP_RCU)\n\t\t\terror = -ECHILD;\n\t\telse\n\t\t\terror = -ESTALE;\n\t}\n\treturn ERR_PTR(error);\n}\n\nstruct file *do_filp_open(int dfd, struct filename *pathname,\n\t\tconst struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tint flags = op->lookup_flags;\n\tstruct file *filp;\n\n\tset_nameidata(&nd, dfd, pathname);\n\tfilp = path_openat(&nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(filp == ERR_PTR(-ECHILD)))\n\t\tfilp = path_openat(&nd, op, flags);\n\tif (unlikely(filp == ERR_PTR(-ESTALE)))\n\t\tfilp = path_openat(&nd, op, flags | LOOKUP_REVAL);\n\trestore_nameidata();\n\treturn filp;\n}\n\nstruct file *do_file_open_root(struct dentry *dentry, struct vfsmount *mnt,\n\t\tconst char *name, const struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tstruct file *file;\n\tstruct filename *filename;\n\tint flags = op->lookup_flags | LOOKUP_ROOT;\n\n\tnd.root.mnt = mnt;\n\tnd.root.dentry = dentry;\n\n\tif (d_is_symlink(dentry) && op->intent & LOOKUP_OPEN)\n\t\treturn ERR_PTR(-ELOOP);\n\n\tfilename = getname_kernel(name);\n\tif (IS_ERR(filename))\n\t\treturn ERR_CAST(filename);\n\n\tset_nameidata(&nd, -1, filename);\n\tfile = path_openat(&nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(file == ERR_PTR(-ECHILD)))\n\t\tfile = path_openat(&nd, op, flags);\n\tif (unlikely(file == ERR_PTR(-ESTALE)))\n\t\tfile = path_openat(&nd, op, flags | LOOKUP_REVAL);\n\trestore_nameidata();\n\tputname(filename);\n\treturn file;\n}\n\nstatic struct dentry *filename_create(int dfd, struct filename *name,\n\t\t\t\tstruct path *path, unsigned int lookup_flags)\n{\n\tstruct dentry *dentry = ERR_PTR(-EEXIST);\n\tstruct qstr last;\n\tint type;\n\tint err2;\n\tint error;\n\tbool is_dir = (lookup_flags & LOOKUP_DIRECTORY);\n\n\t/*\n\t * Note that only LOOKUP_REVAL and LOOKUP_DIRECTORY matter here. Any\n\t * other flags passed in are ignored!\n\t */\n\tlookup_flags &= LOOKUP_REVAL;\n\n\tname = filename_parentat(dfd, name, lookup_flags, path, &last, &type);\n\tif (IS_ERR(name))\n\t\treturn ERR_CAST(name);\n\n\t/*\n\t * Yucky last component or no last component at all?\n\t * (foo/., foo/.., /////)\n\t */\n\tif (unlikely(type != LAST_NORM))\n\t\tgoto out;\n\n\t/* don't fail immediately if it's r/o, at least try to report other errors */\n\terr2 = mnt_want_write(path->mnt);\n\t/*\n\t * Do the final lookup.\n\t */\n\tlookup_flags |= LOOKUP_CREATE | LOOKUP_EXCL;\n\tinode_lock_nested(path->dentry->d_inode, I_MUTEX_PARENT);\n\tdentry = __lookup_hash(&last, path->dentry, lookup_flags);\n\tif (IS_ERR(dentry))\n\t\tgoto unlock;\n\n\terror = -EEXIST;\n\tif (d_is_positive(dentry))\n\t\tgoto fail;\n\n\t/*\n\t * Special case - lookup gave negative, but... we had foo/bar/\n\t * From the vfs_mknod() POV we just have a negative dentry -\n\t * all is fine. Let's be bastards - you had / on the end, you've\n\t * been asking for (non-existent) directory. -ENOENT for you.\n\t */\n\tif (unlikely(!is_dir && last.name[last.len])) {\n\t\terror = -ENOENT;\n\t\tgoto fail;\n\t}\n\tif (unlikely(err2)) {\n\t\terror = err2;\n\t\tgoto fail;\n\t}\n\tputname(name);\n\treturn dentry;\nfail:\n\tdput(dentry);\n\tdentry = ERR_PTR(error);\nunlock:\n\tinode_unlock(path->dentry->d_inode);\n\tif (!err2)\n\t\tmnt_drop_write(path->mnt);\nout:\n\tpath_put(path);\n\tputname(name);\n\treturn dentry;\n}\n\nstruct dentry *kern_path_create(int dfd, const char *pathname,\n\t\t\t\tstruct path *path, unsigned int lookup_flags)\n{\n\treturn filename_create(dfd, getname_kernel(pathname),\n\t\t\t\tpath, lookup_flags);\n}\nEXPORT_SYMBOL(kern_path_create);\n\nvoid done_path_create(struct path *path, struct dentry *dentry)\n{\n\tdput(dentry);\n\tinode_unlock(path->dentry->d_inode);\n\tmnt_drop_write(path->mnt);\n\tpath_put(path);\n}\nEXPORT_SYMBOL(done_path_create);\n\ninline struct dentry *user_path_create(int dfd, const char __user *pathname,\n\t\t\t\tstruct path *path, unsigned int lookup_flags)\n{\n\treturn filename_create(dfd, getname(pathname), path, lookup_flags);\n}\nEXPORT_SYMBOL(user_path_create);\n\nint vfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)\n{\n\tint error = may_create(dir, dentry);\n\n\tif (error)\n\t\treturn error;\n\n\tif ((S_ISCHR(mode) || S_ISBLK(mode)) && !capable(CAP_MKNOD))\n\t\treturn -EPERM;\n\n\tif (!dir->i_op->mknod)\n\t\treturn -EPERM;\n\n\terror = devcgroup_inode_mknod(mode, dev);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_mknod(dir, dentry, mode, dev);\n\tif (error)\n\t\treturn error;\n\n\terror = dir->i_op->mknod(dir, dentry, mode, dev);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_mknod);\n\nstatic int may_mknod(umode_t mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFREG:\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\tcase 0: /* zero mode translates to S_IFREG */\n\t\treturn 0;\n\tcase S_IFDIR:\n\t\treturn -EPERM;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nlong do_mknodat(int dfd, const char __user *filename, umode_t mode,\n\t\tunsigned int dev)\n{\n\tstruct dentry *dentry;\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags = 0;\n\n\terror = may_mknod(mode);\n\tif (error)\n\t\treturn error;\nretry:\n\tdentry = user_path_create(dfd, filename, &path, lookup_flags);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tif (!IS_POSIXACL(path.dentry->d_inode))\n\t\tmode &= ~current_umask();\n\terror = security_path_mknod(&path, dentry, mode, dev);\n\tif (error)\n\t\tgoto out;\n\tswitch (mode & S_IFMT) {\n\t\tcase 0: case S_IFREG:\n\t\t\terror = vfs_create(path.dentry->d_inode,dentry,mode,true);\n\t\t\tif (!error)\n\t\t\t\tima_post_path_mknod(dentry);\n\t\t\tbreak;\n\t\tcase S_IFCHR: case S_IFBLK:\n\t\t\terror = vfs_mknod(path.dentry->d_inode,dentry,mode,\n\t\t\t\t\tnew_decode_dev(dev));\n\t\t\tbreak;\n\t\tcase S_IFIFO: case S_IFSOCK:\n\t\t\terror = vfs_mknod(path.dentry->d_inode,dentry,mode,0);\n\t\t\tbreak;\n\t}\nout:\n\tdone_path_create(&path, dentry);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE4(mknodat, int, dfd, const char __user *, filename, umode_t, mode,\n\t\tunsigned int, dev)\n{\n\treturn do_mknodat(dfd, filename, mode, dev);\n}\n\nSYSCALL_DEFINE3(mknod, const char __user *, filename, umode_t, mode, unsigned, dev)\n{\n\treturn do_mknodat(AT_FDCWD, filename, mode, dev);\n}\n\nint vfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint error = may_create(dir, dentry);\n\tunsigned max_links = dir->i_sb->s_max_links;\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->mkdir)\n\t\treturn -EPERM;\n\n\tmode &= (S_IRWXUGO|S_ISVTX);\n\terror = security_inode_mkdir(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\n\tif (max_links && dir->i_nlink >= max_links)\n\t\treturn -EMLINK;\n\n\terror = dir->i_op->mkdir(dir, dentry, mode);\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_mkdir);\n\nlong do_mkdirat(int dfd, const char __user *pathname, umode_t mode)\n{\n\tstruct dentry *dentry;\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags = LOOKUP_DIRECTORY;\n\nretry:\n\tdentry = user_path_create(dfd, pathname, &path, lookup_flags);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tif (!IS_POSIXACL(path.dentry->d_inode))\n\t\tmode &= ~current_umask();\n\terror = security_path_mkdir(&path, dentry, mode);\n\tif (!error)\n\t\terror = vfs_mkdir(path.dentry->d_inode, dentry, mode);\n\tdone_path_create(&path, dentry);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE3(mkdirat, int, dfd, const char __user *, pathname, umode_t, mode)\n{\n\treturn do_mkdirat(dfd, pathname, mode);\n}\n\nSYSCALL_DEFINE2(mkdir, const char __user *, pathname, umode_t, mode)\n{\n\treturn do_mkdirat(AT_FDCWD, pathname, mode);\n}\n\nint vfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint error = may_delete(dir, dentry, 1);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->rmdir)\n\t\treturn -EPERM;\n\n\tdget(dentry);\n\tinode_lock(dentry->d_inode);\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(dentry))\n\t\tgoto out;\n\n\terror = security_inode_rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\terror = dir->i_op->rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tshrink_dcache_parent(dentry);\n\tdentry->d_inode->i_flags |= S_DEAD;\n\tdont_mount(dentry);\n\tdetach_mounts(dentry);\n\tfsnotify_rmdir(dir, dentry);\n\nout:\n\tinode_unlock(dentry->d_inode);\n\tdput(dentry);\n\tif (!error)\n\t\td_delete(dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_rmdir);\n\nlong do_rmdir(int dfd, const char __user *pathname)\n{\n\tint error = 0;\n\tstruct filename *name;\n\tstruct dentry *dentry;\n\tstruct path path;\n\tstruct qstr last;\n\tint type;\n\tunsigned int lookup_flags = 0;\nretry:\n\tname = filename_parentat(dfd, getname(pathname), lookup_flags,\n\t\t\t\t&path, &last, &type);\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\n\tswitch (type) {\n\tcase LAST_DOTDOT:\n\t\terror = -ENOTEMPTY;\n\t\tgoto exit1;\n\tcase LAST_DOT:\n\t\terror = -EINVAL;\n\t\tgoto exit1;\n\tcase LAST_ROOT:\n\t\terror = -EBUSY;\n\t\tgoto exit1;\n\t}\n\n\terror = mnt_want_write(path.mnt);\n\tif (error)\n\t\tgoto exit1;\n\n\tinode_lock_nested(path.dentry->d_inode, I_MUTEX_PARENT);\n\tdentry = __lookup_hash(&last, path.dentry, lookup_flags);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto exit2;\n\tif (!dentry->d_inode) {\n\t\terror = -ENOENT;\n\t\tgoto exit3;\n\t}\n\terror = security_path_rmdir(&path, dentry);\n\tif (error)\n\t\tgoto exit3;\n\terror = vfs_rmdir(path.dentry->d_inode, dentry);\nexit3:\n\tdput(dentry);\nexit2:\n\tinode_unlock(path.dentry->d_inode);\n\tmnt_drop_write(path.mnt);\nexit1:\n\tpath_put(&path);\n\tputname(name);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE1(rmdir, const char __user *, pathname)\n{\n\treturn do_rmdir(AT_FDCWD, pathname);\n}\n\n/**\n * vfs_unlink - unlink a filesystem object\n * @dir:\tparent directory\n * @dentry:\tvictim\n * @delegated_inode: returns victim inode, if the inode is delegated.\n *\n * The caller must hold dir->i_mutex.\n *\n * If vfs_unlink discovers a delegation, it will return -EWOULDBLOCK and\n * return a reference to the inode in delegated_inode.  The caller\n * should then break the delegation on that inode and retry.  Because\n * breaking a delegation may take a long time, the caller should drop\n * dir->i_mutex before doing so.\n *\n * Alternatively, a caller may pass NULL for delegated_inode.  This may\n * be appropriate for callers that expect the underlying filesystem not\n * to be NFS exported.\n */\nint vfs_unlink(struct inode *dir, struct dentry *dentry, struct inode **delegated_inode)\n{\n\tstruct inode *target = dentry->d_inode;\n\tint error = may_delete(dir, dentry, 0);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->unlink)\n\t\treturn -EPERM;\n\n\tinode_lock(target);\n\tif (is_local_mountpoint(dentry))\n\t\terror = -EBUSY;\n\telse {\n\t\terror = security_inode_unlink(dir, dentry);\n\t\tif (!error) {\n\t\t\terror = try_break_deleg(target, delegated_inode);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\terror = dir->i_op->unlink(dir, dentry);\n\t\t\tif (!error) {\n\t\t\t\tdont_mount(dentry);\n\t\t\t\tdetach_mounts(dentry);\n\t\t\t\tfsnotify_unlink(dir, dentry);\n\t\t\t}\n\t\t}\n\t}\nout:\n\tinode_unlock(target);\n\n\t/* We don't d_delete() NFS sillyrenamed files--they still exist. */\n\tif (!error && !(dentry->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\tfsnotify_link_count(target);\n\t\td_delete(dentry);\n\t}\n\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_unlink);\n\n/*\n * Make sure that the actual truncation of the file will occur outside its\n * directory's i_mutex.  Truncate can take a long time if there is a lot of\n * writeout happening, and we don't want to prevent access to the directory\n * while waiting on the I/O.\n */\nlong do_unlinkat(int dfd, struct filename *name)\n{\n\tint error;\n\tstruct dentry *dentry;\n\tstruct path path;\n\tstruct qstr last;\n\tint type;\n\tstruct inode *inode = NULL;\n\tstruct inode *delegated_inode = NULL;\n\tunsigned int lookup_flags = 0;\nretry:\n\tname = filename_parentat(dfd, name, lookup_flags, &path, &last, &type);\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\n\terror = -EISDIR;\n\tif (type != LAST_NORM)\n\t\tgoto exit1;\n\n\terror = mnt_want_write(path.mnt);\n\tif (error)\n\t\tgoto exit1;\nretry_deleg:\n\tinode_lock_nested(path.dentry->d_inode, I_MUTEX_PARENT);\n\tdentry = __lookup_hash(&last, path.dentry, lookup_flags);\n\terror = PTR_ERR(dentry);\n\tif (!IS_ERR(dentry)) {\n\t\t/* Why not before? Because we want correct error value */\n\t\tif (last.name[last.len])\n\t\t\tgoto slashes;\n\t\tinode = dentry->d_inode;\n\t\tif (d_is_negative(dentry))\n\t\t\tgoto slashes;\n\t\tihold(inode);\n\t\terror = security_path_unlink(&path, dentry);\n\t\tif (error)\n\t\t\tgoto exit2;\n\t\terror = vfs_unlink(path.dentry->d_inode, dentry, &delegated_inode);\nexit2:\n\t\tdput(dentry);\n\t}\n\tinode_unlock(path.dentry->d_inode);\n\tif (inode)\n\t\tiput(inode);\t/* truncate the inode here */\n\tinode = NULL;\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\tmnt_drop_write(path.mnt);\nexit1:\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tinode = NULL;\n\t\tgoto retry;\n\t}\n\tputname(name);\n\treturn error;\n\nslashes:\n\tif (d_is_negative(dentry))\n\t\terror = -ENOENT;\n\telse if (d_is_dir(dentry))\n\t\terror = -EISDIR;\n\telse\n\t\terror = -ENOTDIR;\n\tgoto exit2;\n}\n\nSYSCALL_DEFINE3(unlinkat, int, dfd, const char __user *, pathname, int, flag)\n{\n\tif ((flag & ~AT_REMOVEDIR) != 0)\n\t\treturn -EINVAL;\n\n\tif (flag & AT_REMOVEDIR)\n\t\treturn do_rmdir(dfd, pathname);\n\n\treturn do_unlinkat(dfd, getname(pathname));\n}\n\nSYSCALL_DEFINE1(unlink, const char __user *, pathname)\n{\n\treturn do_unlinkat(AT_FDCWD, getname(pathname));\n}\n\nint vfs_symlink(struct inode *dir, struct dentry *dentry, const char *oldname)\n{\n\tint error = may_create(dir, dentry);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->symlink)\n\t\treturn -EPERM;\n\n\terror = security_inode_symlink(dir, dentry, oldname);\n\tif (error)\n\t\treturn error;\n\n\terror = dir->i_op->symlink(dir, dentry, oldname);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_symlink);\n\nlong do_symlinkat(const char __user *oldname, int newdfd,\n\t\t  const char __user *newname)\n{\n\tint error;\n\tstruct filename *from;\n\tstruct dentry *dentry;\n\tstruct path path;\n\tunsigned int lookup_flags = 0;\n\n\tfrom = getname(oldname);\n\tif (IS_ERR(from))\n\t\treturn PTR_ERR(from);\nretry:\n\tdentry = user_path_create(newdfd, newname, &path, lookup_flags);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto out_putname;\n\n\terror = security_path_symlink(&path, dentry, from->name);\n\tif (!error)\n\t\terror = vfs_symlink(path.dentry->d_inode, dentry, from->name);\n\tdone_path_create(&path, dentry);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout_putname:\n\tputname(from);\n\treturn error;\n}\n\nSYSCALL_DEFINE3(symlinkat, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname)\n{\n\treturn do_symlinkat(oldname, newdfd, newname);\n}\n\nSYSCALL_DEFINE2(symlink, const char __user *, oldname, const char __user *, newname)\n{\n\treturn do_symlinkat(oldname, AT_FDCWD, newname);\n}\n\n/**\n * vfs_link - create a new link\n * @old_dentry:\tobject to be linked\n * @dir:\tnew parent\n * @new_dentry:\twhere to create the new link\n * @delegated_inode: returns inode needing a delegation break\n *\n * The caller must hold dir->i_mutex\n *\n * If vfs_link discovers a delegation on the to-be-linked file in need\n * of breaking, it will return -EWOULDBLOCK and return a reference to the\n * inode in delegated_inode.  The caller should then break the delegation\n * and retry.  Because breaking a delegation may take a long time, the\n * caller should drop the i_mutex before doing so.\n *\n * Alternatively, a caller may pass NULL for delegated_inode.  This may\n * be appropriate for callers that expect the underlying filesystem not\n * to be NFS exported.\n */\nint vfs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry, struct inode **delegated_inode)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\tunsigned max_links = dir->i_sb->s_max_links;\n\tint error;\n\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\terror = may_create(dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (dir->i_sb != inode->i_sb)\n\t\treturn -EXDEV;\n\n\t/*\n\t * A link to an append-only or immutable file cannot be created.\n\t */\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\t/*\n\t * Updating the link count will likely cause i_uid and i_gid to\n\t * be writen back improperly if their true value is unknown to\n\t * the vfs.\n\t */\n\tif (HAS_UNMAPPED_ID(inode))\n\t\treturn -EPERM;\n\tif (!dir->i_op->link)\n\t\treturn -EPERM;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EPERM;\n\n\terror = security_inode_link(old_dentry, dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\tinode_lock(inode);\n\t/* Make sure we don't allow creating hardlink to an unlinked file */\n\tif (inode->i_nlink == 0 && !(inode->i_state & I_LINKABLE))\n\t\terror =  -ENOENT;\n\telse if (max_links && inode->i_nlink >= max_links)\n\t\terror = -EMLINK;\n\telse {\n\t\terror = try_break_deleg(inode, delegated_inode);\n\t\tif (!error)\n\t\t\terror = dir->i_op->link(old_dentry, dir, new_dentry);\n\t}\n\n\tif (!error && (inode->i_state & I_LINKABLE)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state &= ~I_LINKABLE;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tinode_unlock(inode);\n\tif (!error)\n\t\tfsnotify_link(dir, inode, new_dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_link);\n\n/*\n * Hardlinks are often used in delicate situations.  We avoid\n * security-related surprises by not following symlinks on the\n * newname.  --KAB\n *\n * We don't follow them on the oldname either to be compatible\n * with linux 2.0, and to avoid hard-linking to directories\n * and other special files.  --ADM\n */\nint do_linkat(int olddfd, const char __user *oldname, int newdfd,\n\t      const char __user *newname, int flags)\n{\n\tstruct dentry *new_dentry;\n\tstruct path old_path, new_path;\n\tstruct inode *delegated_inode = NULL;\n\tint how = 0;\n\tint error;\n\n\tif ((flags & ~(AT_SYMLINK_FOLLOW | AT_EMPTY_PATH)) != 0)\n\t\treturn -EINVAL;\n\t/*\n\t * To use null names we require CAP_DAC_READ_SEARCH\n\t * This ensures that not everyone will be able to create\n\t * handlink using the passed filedescriptor.\n\t */\n\tif (flags & AT_EMPTY_PATH) {\n\t\tif (!capable(CAP_DAC_READ_SEARCH))\n\t\t\treturn -ENOENT;\n\t\thow = LOOKUP_EMPTY;\n\t}\n\n\tif (flags & AT_SYMLINK_FOLLOW)\n\t\thow |= LOOKUP_FOLLOW;\nretry:\n\terror = user_path_at(olddfd, oldname, how, &old_path);\n\tif (error)\n\t\treturn error;\n\n\tnew_dentry = user_path_create(newdfd, newname, &new_path,\n\t\t\t\t\t(how & LOOKUP_REVAL));\n\terror = PTR_ERR(new_dentry);\n\tif (IS_ERR(new_dentry))\n\t\tgoto out;\n\n\terror = -EXDEV;\n\tif (old_path.mnt != new_path.mnt)\n\t\tgoto out_dput;\n\terror = may_linkat(&old_path);\n\tif (unlikely(error))\n\t\tgoto out_dput;\n\terror = security_path_link(old_path.dentry, &new_path, new_dentry);\n\tif (error)\n\t\tgoto out_dput;\n\terror = vfs_link(old_path.dentry, new_path.dentry->d_inode, new_dentry, &delegated_inode);\nout_dput:\n\tdone_path_create(&new_path, new_dentry);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error) {\n\t\t\tpath_put(&old_path);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (retry_estale(error, how)) {\n\t\tpath_put(&old_path);\n\t\thow |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout:\n\tpath_put(&old_path);\n\n\treturn error;\n}\n\nSYSCALL_DEFINE5(linkat, int, olddfd, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname, int, flags)\n{\n\treturn do_linkat(olddfd, oldname, newdfd, newname, flags);\n}\n\nSYSCALL_DEFINE2(link, const char __user *, oldname, const char __user *, newname)\n{\n\treturn do_linkat(AT_FDCWD, oldname, AT_FDCWD, newname, 0);\n}\n\n/**\n * vfs_rename - rename a filesystem object\n * @old_dir:\tparent of source\n * @old_dentry:\tsource\n * @new_dir:\tparent of destination\n * @new_dentry:\tdestination\n * @delegated_inode: returns an inode needing a delegation break\n * @flags:\trename flags\n *\n * The caller must hold multiple mutexes--see lock_rename()).\n *\n * If vfs_rename discovers a delegation in need of breaking at either\n * the source or destination, it will return -EWOULDBLOCK and return a\n * reference to the inode in delegated_inode.  The caller should then\n * break the delegation and retry.  Because breaking a delegation may\n * take a long time, the caller should drop all locks before doing\n * so.\n *\n * Alternatively, a caller may pass NULL for delegated_inode.  This may\n * be appropriate for callers that expect the underlying filesystem not\n * to be NFS exported.\n *\n * The worst of all namespace operations - renaming directory. \"Perverted\"\n * doesn't even start to describe it. Somebody in UCB had a heck of a trip...\n * Problems:\n *\n *\ta) we can get into loop creation.\n *\tb) race potential - two innocent renames can create a loop together.\n *\t   That's where 4.4 screws up. Current fix: serialization on\n *\t   sb->s_vfs_rename_mutex. We might be more accurate, but that's another\n *\t   story.\n *\tc) we have to lock _four_ objects - parents and victim (if it exists),\n *\t   and source (if it is not a directory).\n *\t   And that - after we got ->i_mutex on parents (until then we don't know\n *\t   whether the target exists).  Solution: try to be smart with locking\n *\t   order for inodes.  We rely on the fact that tree topology may change\n *\t   only under ->s_vfs_rename_mutex _and_ that parent of the object we\n *\t   move will be locked.  Thus we can rank directories by the tree\n *\t   (ancestors first) and rank all non-directories after them.\n *\t   That works since everybody except rename does \"lock parent, lookup,\n *\t   lock child\" and rename is under ->s_vfs_rename_mutex.\n *\t   HOWEVER, it relies on the assumption that any object with ->lookup()\n *\t   has no more than 1 dentry.  If \"hybrid\" objects will ever appear,\n *\t   we'd better make sure that there's no link(2) for them.\n *\td) conversion from fhandle to dentry may come in the wrong moment - when\n *\t   we are removing the target. Solution: we will have to grab ->i_mutex\n *\t   in the fhandle_to_dentry code. [FIXME - current nfsfh.c relies on\n *\t   ->i_mutex on parents, which works but leads to some truly excessive\n *\t   locking].\n */\nint vfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t       struct inode *new_dir, struct dentry *new_dentry,\n\t       struct inode **delegated_inode, unsigned int flags)\n{\n\tint error;\n\tbool is_dir = d_is_dir(old_dentry);\n\tstruct inode *source = old_dentry->d_inode;\n\tstruct inode *target = new_dentry->d_inode;\n\tbool new_is_dir = false;\n\tunsigned max_links = new_dir->i_sb->s_max_links;\n\tstruct name_snapshot old_name;\n\n\tif (source == target)\n\t\treturn 0;\n\n\terror = may_delete(old_dir, old_dentry, is_dir);\n\tif (error)\n\t\treturn error;\n\n\tif (!target) {\n\t\terror = may_create(new_dir, new_dentry);\n\t} else {\n\t\tnew_is_dir = d_is_dir(new_dentry);\n\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\terror = may_delete(new_dir, new_dentry, is_dir);\n\t\telse\n\t\t\terror = may_delete(new_dir, new_dentry, new_is_dir);\n\t}\n\tif (error)\n\t\treturn error;\n\n\tif (!old_dir->i_op->rename)\n\t\treturn -EPERM;\n\n\t/*\n\t * If we are going to change the parent - check write permissions,\n\t * we'll need to flip '..'.\n\t */\n\tif (new_dir != old_dir) {\n\t\tif (is_dir) {\n\t\t\terror = inode_permission(source, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif ((flags & RENAME_EXCHANGE) && new_is_dir) {\n\t\t\terror = inode_permission(target, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry,\n\t\t\t\t      flags);\n\tif (error)\n\t\treturn error;\n\n\ttake_dentry_name_snapshot(&old_name, old_dentry);\n\tdget(new_dentry);\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tinode_lock(target);\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry))\n\t\tgoto out;\n\n\tif (max_links && new_dir != old_dir) {\n\t\terror = -EMLINK;\n\t\tif (is_dir && !new_is_dir && new_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t\tif ((flags & RENAME_EXCHANGE) && !is_dir && new_is_dir &&\n\t\t    old_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t}\n\tif (!is_dir) {\n\t\terror = try_break_deleg(source, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (target && !new_is_dir) {\n\t\terror = try_break_deleg(target, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\terror = old_dir->i_op->rename(old_dir, old_dentry,\n\t\t\t\t       new_dir, new_dentry, flags);\n\tif (error)\n\t\tgoto out;\n\n\tif (!(flags & RENAME_EXCHANGE) && target) {\n\t\tif (is_dir) {\n\t\t\tshrink_dcache_parent(new_dentry);\n\t\t\ttarget->i_flags |= S_DEAD;\n\t\t}\n\t\tdont_mount(new_dentry);\n\t\tdetach_mounts(new_dentry);\n\t}\n\tif (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE)) {\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\td_move(old_dentry, new_dentry);\n\t\telse\n\t\t\td_exchange(old_dentry, new_dentry);\n\t}\nout:\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tunlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tinode_unlock(target);\n\tdput(new_dentry);\n\tif (!error) {\n\t\tfsnotify_move(old_dir, new_dir, &old_name.name, is_dir,\n\t\t\t      !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry);\n\t\tif (flags & RENAME_EXCHANGE) {\n\t\t\tfsnotify_move(new_dir, old_dir, &old_dentry->d_name,\n\t\t\t\t      new_is_dir, NULL, new_dentry);\n\t\t}\n\t}\n\trelease_dentry_name_snapshot(&old_name);\n\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_rename);\n\nstatic int do_renameat2(int olddfd, const char __user *oldname, int newdfd,\n\t\t\tconst char __user *newname, unsigned int flags)\n{\n\tstruct dentry *old_dentry, *new_dentry;\n\tstruct dentry *trap;\n\tstruct path old_path, new_path;\n\tstruct qstr old_last, new_last;\n\tint old_type, new_type;\n\tstruct inode *delegated_inode = NULL;\n\tstruct filename *from;\n\tstruct filename *to;\n\tunsigned int lookup_flags = 0, target_flags = LOOKUP_RENAME_TARGET;\n\tbool should_retry = false;\n\tint error;\n\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))\n\t\treturn -EINVAL;\n\n\tif ((flags & (RENAME_NOREPLACE | RENAME_WHITEOUT)) &&\n\t    (flags & RENAME_EXCHANGE))\n\t\treturn -EINVAL;\n\n\tif ((flags & RENAME_WHITEOUT) && !capable(CAP_MKNOD))\n\t\treturn -EPERM;\n\n\tif (flags & RENAME_EXCHANGE)\n\t\ttarget_flags = 0;\n\nretry:\n\tfrom = filename_parentat(olddfd, getname(oldname), lookup_flags,\n\t\t\t\t&old_path, &old_last, &old_type);\n\tif (IS_ERR(from)) {\n\t\terror = PTR_ERR(from);\n\t\tgoto exit;\n\t}\n\n\tto = filename_parentat(newdfd, getname(newname), lookup_flags,\n\t\t\t\t&new_path, &new_last, &new_type);\n\tif (IS_ERR(to)) {\n\t\terror = PTR_ERR(to);\n\t\tgoto exit1;\n\t}\n\n\terror = -EXDEV;\n\tif (old_path.mnt != new_path.mnt)\n\t\tgoto exit2;\n\n\terror = -EBUSY;\n\tif (old_type != LAST_NORM)\n\t\tgoto exit2;\n\n\tif (flags & RENAME_NOREPLACE)\n\t\terror = -EEXIST;\n\tif (new_type != LAST_NORM)\n\t\tgoto exit2;\n\n\terror = mnt_want_write(old_path.mnt);\n\tif (error)\n\t\tgoto exit2;\n\nretry_deleg:\n\ttrap = lock_rename(new_path.dentry, old_path.dentry);\n\n\told_dentry = __lookup_hash(&old_last, old_path.dentry, lookup_flags);\n\terror = PTR_ERR(old_dentry);\n\tif (IS_ERR(old_dentry))\n\t\tgoto exit3;\n\t/* source must exist */\n\terror = -ENOENT;\n\tif (d_is_negative(old_dentry))\n\t\tgoto exit4;\n\tnew_dentry = __lookup_hash(&new_last, new_path.dentry, lookup_flags | target_flags);\n\terror = PTR_ERR(new_dentry);\n\tif (IS_ERR(new_dentry))\n\t\tgoto exit4;\n\terror = -EEXIST;\n\tif ((flags & RENAME_NOREPLACE) && d_is_positive(new_dentry))\n\t\tgoto exit5;\n\tif (flags & RENAME_EXCHANGE) {\n\t\terror = -ENOENT;\n\t\tif (d_is_negative(new_dentry))\n\t\t\tgoto exit5;\n\n\t\tif (!d_is_dir(new_dentry)) {\n\t\t\terror = -ENOTDIR;\n\t\t\tif (new_last.name[new_last.len])\n\t\t\t\tgoto exit5;\n\t\t}\n\t}\n\t/* unless the source is a directory trailing slashes give -ENOTDIR */\n\tif (!d_is_dir(old_dentry)) {\n\t\terror = -ENOTDIR;\n\t\tif (old_last.name[old_last.len])\n\t\t\tgoto exit5;\n\t\tif (!(flags & RENAME_EXCHANGE) && new_last.name[new_last.len])\n\t\t\tgoto exit5;\n\t}\n\t/* source should not be ancestor of target */\n\terror = -EINVAL;\n\tif (old_dentry == trap)\n\t\tgoto exit5;\n\t/* target should not be an ancestor of source */\n\tif (!(flags & RENAME_EXCHANGE))\n\t\terror = -ENOTEMPTY;\n\tif (new_dentry == trap)\n\t\tgoto exit5;\n\n\terror = security_path_rename(&old_path, old_dentry,\n\t\t\t\t     &new_path, new_dentry, flags);\n\tif (error)\n\t\tgoto exit5;\n\terror = vfs_rename(old_path.dentry->d_inode, old_dentry,\n\t\t\t   new_path.dentry->d_inode, new_dentry,\n\t\t\t   &delegated_inode, flags);\nexit5:\n\tdput(new_dentry);\nexit4:\n\tdput(old_dentry);\nexit3:\n\tunlock_rename(new_path.dentry, old_path.dentry);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\tmnt_drop_write(old_path.mnt);\nexit2:\n\tif (retry_estale(error, lookup_flags))\n\t\tshould_retry = true;\n\tpath_put(&new_path);\n\tputname(to);\nexit1:\n\tpath_put(&old_path);\n\tputname(from);\n\tif (should_retry) {\n\t\tshould_retry = false;\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nexit:\n\treturn error;\n}\n\nSYSCALL_DEFINE5(renameat2, int, olddfd, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname, unsigned int, flags)\n{\n\treturn do_renameat2(olddfd, oldname, newdfd, newname, flags);\n}\n\nSYSCALL_DEFINE4(renameat, int, olddfd, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname)\n{\n\treturn do_renameat2(olddfd, oldname, newdfd, newname, 0);\n}\n\nSYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)\n{\n\treturn do_renameat2(AT_FDCWD, oldname, AT_FDCWD, newname, 0);\n}\n\nint vfs_whiteout(struct inode *dir, struct dentry *dentry)\n{\n\tint error = may_create(dir, dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->mknod)\n\t\treturn -EPERM;\n\n\treturn dir->i_op->mknod(dir, dentry,\n\t\t\t\tS_IFCHR | WHITEOUT_MODE, WHITEOUT_DEV);\n}\nEXPORT_SYMBOL(vfs_whiteout);\n\nint readlink_copy(char __user *buffer, int buflen, const char *link)\n{\n\tint len = PTR_ERR(link);\n\tif (IS_ERR(link))\n\t\tgoto out;\n\n\tlen = strlen(link);\n\tif (len > (unsigned) buflen)\n\t\tlen = buflen;\n\tif (copy_to_user(buffer, link, len))\n\t\tlen = -EFAULT;\nout:\n\treturn len;\n}\n\n/**\n * vfs_readlink - copy symlink body into userspace buffer\n * @dentry: dentry on which to get symbolic link\n * @buffer: user memory pointer\n * @buflen: size of buffer\n *\n * Does not touch atime.  That's up to the caller if necessary\n *\n * Does not call security hook.\n */\nint vfs_readlink(struct dentry *dentry, char __user *buffer, int buflen)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tDEFINE_DELAYED_CALL(done);\n\tconst char *link;\n\tint res;\n\n\tif (unlikely(!(inode->i_opflags & IOP_DEFAULT_READLINK))) {\n\t\tif (unlikely(inode->i_op->readlink))\n\t\t\treturn inode->i_op->readlink(dentry, buffer, buflen);\n\n\t\tif (!d_is_symlink(dentry))\n\t\t\treturn -EINVAL;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_opflags |= IOP_DEFAULT_READLINK;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\n\tlink = READ_ONCE(inode->i_link);\n\tif (!link) {\n\t\tlink = inode->i_op->get_link(dentry, inode, &done);\n\t\tif (IS_ERR(link))\n\t\t\treturn PTR_ERR(link);\n\t}\n\tres = readlink_copy(buffer, buflen, link);\n\tdo_delayed_call(&done);\n\treturn res;\n}\nEXPORT_SYMBOL(vfs_readlink);\n\n/**\n * vfs_get_link - get symlink body\n * @dentry: dentry on which to get symbolic link\n * @done: caller needs to free returned data with this\n *\n * Calls security hook and i_op->get_link() on the supplied inode.\n *\n * It does not touch atime.  That's up to the caller if necessary.\n *\n * Does not work on \"special\" symlinks like /proc/$$/fd/N\n */\nconst char *vfs_get_link(struct dentry *dentry, struct delayed_call *done)\n{\n\tconst char *res = ERR_PTR(-EINVAL);\n\tstruct inode *inode = d_inode(dentry);\n\n\tif (d_is_symlink(dentry)) {\n\t\tres = ERR_PTR(security_inode_readlink(dentry));\n\t\tif (!res)\n\t\t\tres = inode->i_op->get_link(dentry, inode, done);\n\t}\n\treturn res;\n}\nEXPORT_SYMBOL(vfs_get_link);\n\n/* get the link contents into pagecache */\nconst char *page_get_link(struct dentry *dentry, struct inode *inode,\n\t\t\t  struct delayed_call *callback)\n{\n\tchar *kaddr;\n\tstruct page *page;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\tif (!dentry) {\n\t\tpage = find_get_page(mapping, 0);\n\t\tif (!page)\n\t\t\treturn ERR_PTR(-ECHILD);\n\t\tif (!PageUptodate(page)) {\n\t\t\tput_page(page);\n\t\t\treturn ERR_PTR(-ECHILD);\n\t\t}\n\t} else {\n\t\tpage = read_mapping_page(mapping, 0, NULL);\n\t\tif (IS_ERR(page))\n\t\t\treturn (char*)page;\n\t}\n\tset_delayed_call(callback, page_put_link, page);\n\tBUG_ON(mapping_gfp_mask(mapping) & __GFP_HIGHMEM);\n\tkaddr = page_address(page);\n\tnd_terminate_link(kaddr, inode->i_size, PAGE_SIZE - 1);\n\treturn kaddr;\n}\n\nEXPORT_SYMBOL(page_get_link);\n\nvoid page_put_link(void *arg)\n{\n\tput_page(arg);\n}\nEXPORT_SYMBOL(page_put_link);\n\nint page_readlink(struct dentry *dentry, char __user *buffer, int buflen)\n{\n\tDEFINE_DELAYED_CALL(done);\n\tint res = readlink_copy(buffer, buflen,\n\t\t\t\tpage_get_link(dentry, d_inode(dentry),\n\t\t\t\t\t      &done));\n\tdo_delayed_call(&done);\n\treturn res;\n}\nEXPORT_SYMBOL(page_readlink);\n\n/*\n * The nofs argument instructs pagecache_write_begin to pass AOP_FLAG_NOFS\n */\nint __page_symlink(struct inode *inode, const char *symname, int len, int nofs)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tvoid *fsdata;\n\tint err;\n\tunsigned int flags = 0;\n\tif (nofs)\n\t\tflags |= AOP_FLAG_NOFS;\n\nretry:\n\terr = pagecache_write_begin(NULL, mapping, 0, len-1,\n\t\t\t\tflags, &page, &fsdata);\n\tif (err)\n\t\tgoto fail;\n\n\tmemcpy(page_address(page), symname, len-1);\n\n\terr = pagecache_write_end(NULL, mapping, 0, len-1, len-1,\n\t\t\t\t\t\t\tpage, fsdata);\n\tif (err < 0)\n\t\tgoto fail;\n\tif (err < len-1)\n\t\tgoto retry;\n\n\tmark_inode_dirty(inode);\n\treturn 0;\nfail:\n\treturn err;\n}\nEXPORT_SYMBOL(__page_symlink);\n\nint page_symlink(struct inode *inode, const char *symname, int len)\n{\n\treturn __page_symlink(inode, symname, len,\n\t\t\t!mapping_gfp_constraint(inode->i_mapping, __GFP_FS));\n}\nEXPORT_SYMBOL(page_symlink);\n\nconst struct inode_operations page_symlink_inode_operations = {\n\t.get_link\t= page_get_link,\n};\nEXPORT_SYMBOL(page_symlink_inode_operations);\n"], "filenames": ["fs/namei.c"], "buggy_code_start_loc": [1004], "buggy_code_end_loc": [3335], "fixing_code_start_loc": [1004], "fixing_code_end_loc": [3338], "type": "CWE-416", "message": "fs/namei.c in the Linux kernel before 5.5 has a may_create_in_sticky use-after-free, which allows local users to cause a denial of service (OOPS) or possibly obtain sensitive information from kernel memory, aka CID-d0cb50185ae9. One attack vector may be an open system call for a UNIX domain socket, if the socket is being moved to a new parent directory and its old parent directory is being removed.", "other": {"cve": {"id": "CVE-2020-8428", "sourceIdentifier": "cve@mitre.org", "published": "2020-01-29T00:15:10.953", "lastModified": "2020-06-10T20:15:14.563", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "fs/namei.c in the Linux kernel before 5.5 has a may_create_in_sticky use-after-free, which allows local users to cause a denial of service (OOPS) or possibly obtain sensitive information from kernel memory, aka CID-d0cb50185ae9. One attack vector may be an open system call for a UNIX domain socket, if the socket is being moved to a new parent directory and its old parent directory is being removed."}, {"lang": "es", "value": "El archivo fs/namei.c en el kernel de Linux versiones anteriores a 5.5, presenta una vulnerabilidad de uso de la memoria previamente liberada en la funci\u00f3n may_create_in_sticky, que permite a usuarios locales causar una denegaci\u00f3n de servicio (OOPS) u obtener informaci\u00f3n confidencial de la memoria del kernel, tambi\u00e9n se conoce como CID-d0cb50185ae9. Un vector de ataque puede ser una llamada de sistema abierta para un socket del dominio UNIX, si el socket est\u00e1 siendo movido hacia un nuevo directorio padre y su antiguo directorio padre est\u00e1 siendo eliminado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 3.6}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.19", "versionEndExcluding": "5.5", "matchCriteriaId": "904A2E19-D6CD-4C97-B8F4-1F179CC6956C"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-03/msg00021.html", "source": "cve@mitre.org"}, {"url": "http://packetstormsecurity.com/files/157233/Kernel-Live-Patch-Security-Notice-LSN-0065-1.html", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2020/01/28/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2020/02/02/1", "source": "cve@mitre.org"}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=d0cb50185ae942b03c4327be322055d622dc79f6", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/d0cb50185ae942b03c4327be322055d622dc79f6", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00012.html", "source": "cve@mitre.org"}, {"url": "https://security.netapp.com/advisory/ntap-20200313-0003/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4318-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4319-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4320-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4324-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4325-1/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2020/dsa-4667", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2020/dsa-4698", "source": "cve@mitre.org"}, {"url": "https://www.openwall.com/lists/oss-security/2020/01/28/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/d0cb50185ae942b03c4327be322055d622dc79f6"}}