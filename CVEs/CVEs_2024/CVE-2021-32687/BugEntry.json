{"buggy_code": ["/*\n * Copyright (c) 2009-2012, Pieter Noordhuis <pcnoordhuis at gmail dot com>\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"intset.h\"\n#include \"zmalloc.h\"\n#include \"endianconv.h\"\n\n/* Note that these encodings are ordered, so:\n * INTSET_ENC_INT16 < INTSET_ENC_INT32 < INTSET_ENC_INT64. */\n#define INTSET_ENC_INT16 (sizeof(int16_t))\n#define INTSET_ENC_INT32 (sizeof(int32_t))\n#define INTSET_ENC_INT64 (sizeof(int64_t))\n\n/* Return the required encoding for the provided value. */\nstatic uint8_t _intsetValueEncoding(int64_t v) {\n    if (v < INT32_MIN || v > INT32_MAX)\n        return INTSET_ENC_INT64;\n    else if (v < INT16_MIN || v > INT16_MAX)\n        return INTSET_ENC_INT32;\n    else\n        return INTSET_ENC_INT16;\n}\n\n/* Return the value at pos, given an encoding. */\nstatic int64_t _intsetGetEncoded(intset *is, int pos, uint8_t enc) {\n    int64_t v64;\n    int32_t v32;\n    int16_t v16;\n\n    if (enc == INTSET_ENC_INT64) {\n        memcpy(&v64,((int64_t*)is->contents)+pos,sizeof(v64));\n        memrev64ifbe(&v64);\n        return v64;\n    } else if (enc == INTSET_ENC_INT32) {\n        memcpy(&v32,((int32_t*)is->contents)+pos,sizeof(v32));\n        memrev32ifbe(&v32);\n        return v32;\n    } else {\n        memcpy(&v16,((int16_t*)is->contents)+pos,sizeof(v16));\n        memrev16ifbe(&v16);\n        return v16;\n    }\n}\n\n/* Return the value at pos, using the configured encoding. */\nstatic int64_t _intsetGet(intset *is, int pos) {\n    return _intsetGetEncoded(is,pos,intrev32ifbe(is->encoding));\n}\n\n/* Set the value at pos, using the configured encoding. */\nstatic void _intsetSet(intset *is, int pos, int64_t value) {\n    uint32_t encoding = intrev32ifbe(is->encoding);\n\n    if (encoding == INTSET_ENC_INT64) {\n        ((int64_t*)is->contents)[pos] = value;\n        memrev64ifbe(((int64_t*)is->contents)+pos);\n    } else if (encoding == INTSET_ENC_INT32) {\n        ((int32_t*)is->contents)[pos] = value;\n        memrev32ifbe(((int32_t*)is->contents)+pos);\n    } else {\n        ((int16_t*)is->contents)[pos] = value;\n        memrev16ifbe(((int16_t*)is->contents)+pos);\n    }\n}\n\n/* Create an empty intset. */\nintset *intsetNew(void) {\n    intset *is = zmalloc(sizeof(intset));\n    is->encoding = intrev32ifbe(INTSET_ENC_INT16);\n    is->length = 0;\n    return is;\n}\n\n/* Resize the intset */\nstatic intset *intsetResize(intset *is, uint32_t len) {\n    uint32_t size = len*intrev32ifbe(is->encoding);\n    is = zrealloc(is,sizeof(intset)+size);\n    return is;\n}\n\n/* Search for the position of \"value\". Return 1 when the value was found and\n * sets \"pos\" to the position of the value within the intset. Return 0 when\n * the value is not present in the intset and sets \"pos\" to the position\n * where \"value\" can be inserted. */\nstatic uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos) {\n    int min = 0, max = intrev32ifbe(is->length)-1, mid = -1;\n    int64_t cur = -1;\n\n    /* The value can never be found when the set is empty */\n    if (intrev32ifbe(is->length) == 0) {\n        if (pos) *pos = 0;\n        return 0;\n    } else {\n        /* Check for the case where we know we cannot find the value,\n         * but do know the insert position. */\n        if (value > _intsetGet(is,max)) {\n            if (pos) *pos = intrev32ifbe(is->length);\n            return 0;\n        } else if (value < _intsetGet(is,0)) {\n            if (pos) *pos = 0;\n            return 0;\n        }\n    }\n\n    while(max >= min) {\n        mid = ((unsigned int)min + (unsigned int)max) >> 1;\n        cur = _intsetGet(is,mid);\n        if (value > cur) {\n            min = mid+1;\n        } else if (value < cur) {\n            max = mid-1;\n        } else {\n            break;\n        }\n    }\n\n    if (value == cur) {\n        if (pos) *pos = mid;\n        return 1;\n    } else {\n        if (pos) *pos = min;\n        return 0;\n    }\n}\n\n/* Upgrades the intset to a larger encoding and inserts the given integer. */\nstatic intset *intsetUpgradeAndAdd(intset *is, int64_t value) {\n    uint8_t curenc = intrev32ifbe(is->encoding);\n    uint8_t newenc = _intsetValueEncoding(value);\n    int length = intrev32ifbe(is->length);\n    int prepend = value < 0 ? 1 : 0;\n\n    /* First set new encoding and resize */\n    is->encoding = intrev32ifbe(newenc);\n    is = intsetResize(is,intrev32ifbe(is->length)+1);\n\n    /* Upgrade back-to-front so we don't overwrite values.\n     * Note that the \"prepend\" variable is used to make sure we have an empty\n     * space at either the beginning or the end of the intset. */\n    while(length--)\n        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));\n\n    /* Set the value at the beginning or the end. */\n    if (prepend)\n        _intsetSet(is,0,value);\n    else\n        _intsetSet(is,intrev32ifbe(is->length),value);\n    is->length = intrev32ifbe(intrev32ifbe(is->length)+1);\n    return is;\n}\n\nstatic void intsetMoveTail(intset *is, uint32_t from, uint32_t to) {\n    void *src, *dst;\n    uint32_t bytes = intrev32ifbe(is->length)-from;\n    uint32_t encoding = intrev32ifbe(is->encoding);\n\n    if (encoding == INTSET_ENC_INT64) {\n        src = (int64_t*)is->contents+from;\n        dst = (int64_t*)is->contents+to;\n        bytes *= sizeof(int64_t);\n    } else if (encoding == INTSET_ENC_INT32) {\n        src = (int32_t*)is->contents+from;\n        dst = (int32_t*)is->contents+to;\n        bytes *= sizeof(int32_t);\n    } else {\n        src = (int16_t*)is->contents+from;\n        dst = (int16_t*)is->contents+to;\n        bytes *= sizeof(int16_t);\n    }\n    memmove(dst,src,bytes);\n}\n\n/* Insert an integer in the intset */\nintset *intsetAdd(intset *is, int64_t value, uint8_t *success) {\n    uint8_t valenc = _intsetValueEncoding(value);\n    uint32_t pos;\n    if (success) *success = 1;\n\n    /* Upgrade encoding if necessary. If we need to upgrade, we know that\n     * this value should be either appended (if > 0) or prepended (if < 0),\n     * because it lies outside the range of existing values. */\n    if (valenc > intrev32ifbe(is->encoding)) {\n        /* This always succeeds, so we don't need to curry *success. */\n        return intsetUpgradeAndAdd(is,value);\n    } else {\n        /* Abort if the value is already present in the set.\n         * This call will populate \"pos\" with the right position to insert\n         * the value when it cannot be found. */\n        if (intsetSearch(is,value,&pos)) {\n            if (success) *success = 0;\n            return is;\n        }\n\n        is = intsetResize(is,intrev32ifbe(is->length)+1);\n        if (pos < intrev32ifbe(is->length)) intsetMoveTail(is,pos,pos+1);\n    }\n\n    _intsetSet(is,pos,value);\n    is->length = intrev32ifbe(intrev32ifbe(is->length)+1);\n    return is;\n}\n\n/* Delete integer from intset */\nintset *intsetRemove(intset *is, int64_t value, int *success) {\n    uint8_t valenc = _intsetValueEncoding(value);\n    uint32_t pos;\n    if (success) *success = 0;\n\n    if (valenc <= intrev32ifbe(is->encoding) && intsetSearch(is,value,&pos)) {\n        uint32_t len = intrev32ifbe(is->length);\n\n        /* We know we can delete */\n        if (success) *success = 1;\n\n        /* Overwrite value with tail and update length */\n        if (pos < (len-1)) intsetMoveTail(is,pos+1,pos);\n        is = intsetResize(is,len-1);\n        is->length = intrev32ifbe(len-1);\n    }\n    return is;\n}\n\n/* Determine whether a value belongs to this set */\nuint8_t intsetFind(intset *is, int64_t value) {\n    uint8_t valenc = _intsetValueEncoding(value);\n    return valenc <= intrev32ifbe(is->encoding) && intsetSearch(is,value,NULL);\n}\n\n/* Return random member */\nint64_t intsetRandom(intset *is) {\n    return _intsetGet(is,rand()%intrev32ifbe(is->length));\n}\n\n/* Get the value at the given position. When this position is\n * out of range the function returns 0, when in range it returns 1. */\nuint8_t intsetGet(intset *is, uint32_t pos, int64_t *value) {\n    if (pos < intrev32ifbe(is->length)) {\n        *value = _intsetGet(is,pos);\n        return 1;\n    }\n    return 0;\n}\n\n/* Return intset length */\nuint32_t intsetLen(const intset *is) {\n    return intrev32ifbe(is->length);\n}\n\n/* Return intset blob size in bytes. */\nsize_t intsetBlobLen(intset *is) {\n    return sizeof(intset)+(size_t)intrev32ifbe(is->length)*intrev32ifbe(is->encoding);\n}\n\n#ifdef REDIS_TEST\n#include <sys/time.h>\n#include <time.h>\n\n#if 0\nstatic void intsetRepr(intset *is) {\n    for (uint32_t i = 0; i < intrev32ifbe(is->length); i++) {\n        printf(\"%lld\\n\", (uint64_t)_intsetGet(is,i));\n    }\n    printf(\"\\n\");\n}\n\nstatic void error(char *err) {\n    printf(\"%s\\n\", err);\n    exit(1);\n}\n#endif\n\nstatic void ok(void) {\n    printf(\"OK\\n\");\n}\n\nstatic long long usec(void) {\n    struct timeval tv;\n    gettimeofday(&tv,NULL);\n    return (((long long)tv.tv_sec)*1000000)+tv.tv_usec;\n}\n\n#define assert(_e) ((_e)?(void)0:(_assert(#_e,__FILE__,__LINE__),exit(1)))\nstatic void _assert(char *estr, char *file, int line) {\n    printf(\"\\n\\n=== ASSERTION FAILED ===\\n\");\n    printf(\"==> %s:%d '%s' is not true\\n\",file,line,estr);\n}\n\nstatic intset *createSet(int bits, int size) {\n    uint64_t mask = (1<<bits)-1;\n    uint64_t value;\n    intset *is = intsetNew();\n\n    for (int i = 0; i < size; i++) {\n        if (bits > 32) {\n            value = (rand()*rand()) & mask;\n        } else {\n            value = rand() & mask;\n        }\n        is = intsetAdd(is,value,NULL);\n    }\n    return is;\n}\n\nstatic void checkConsistency(intset *is) {\n    for (uint32_t i = 0; i < (intrev32ifbe(is->length)-1); i++) {\n        uint32_t encoding = intrev32ifbe(is->encoding);\n\n        if (encoding == INTSET_ENC_INT16) {\n            int16_t *i16 = (int16_t*)is->contents;\n            assert(i16[i] < i16[i+1]);\n        } else if (encoding == INTSET_ENC_INT32) {\n            int32_t *i32 = (int32_t*)is->contents;\n            assert(i32[i] < i32[i+1]);\n        } else {\n            int64_t *i64 = (int64_t*)is->contents;\n            assert(i64[i] < i64[i+1]);\n        }\n    }\n}\n\n#define UNUSED(x) (void)(x)\nint intsetTest(int argc, char **argv) {\n    uint8_t success;\n    int i;\n    intset *is;\n    srand(time(NULL));\n\n    UNUSED(argc);\n    UNUSED(argv);\n\n    printf(\"Value encodings: \"); {\n        assert(_intsetValueEncoding(-32768) == INTSET_ENC_INT16);\n        assert(_intsetValueEncoding(+32767) == INTSET_ENC_INT16);\n        assert(_intsetValueEncoding(-32769) == INTSET_ENC_INT32);\n        assert(_intsetValueEncoding(+32768) == INTSET_ENC_INT32);\n        assert(_intsetValueEncoding(-2147483648) == INTSET_ENC_INT32);\n        assert(_intsetValueEncoding(+2147483647) == INTSET_ENC_INT32);\n        assert(_intsetValueEncoding(-2147483649) == INTSET_ENC_INT64);\n        assert(_intsetValueEncoding(+2147483648) == INTSET_ENC_INT64);\n        assert(_intsetValueEncoding(-9223372036854775808ull) ==\n                    INTSET_ENC_INT64);\n        assert(_intsetValueEncoding(+9223372036854775807ull) ==\n                    INTSET_ENC_INT64);\n        ok();\n    }\n\n    printf(\"Basic adding: \"); {\n        is = intsetNew();\n        is = intsetAdd(is,5,&success); assert(success);\n        is = intsetAdd(is,6,&success); assert(success);\n        is = intsetAdd(is,4,&success); assert(success);\n        is = intsetAdd(is,4,&success); assert(!success);\n        ok();\n    }\n\n    printf(\"Large number of random adds: \"); {\n        uint32_t inserts = 0;\n        is = intsetNew();\n        for (i = 0; i < 1024; i++) {\n            is = intsetAdd(is,rand()%0x800,&success);\n            if (success) inserts++;\n        }\n        assert(intrev32ifbe(is->length) == inserts);\n        checkConsistency(is);\n        ok();\n    }\n\n    printf(\"Upgrade from int16 to int32: \"); {\n        is = intsetNew();\n        is = intsetAdd(is,32,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT16);\n        is = intsetAdd(is,65535,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT32);\n        assert(intsetFind(is,32));\n        assert(intsetFind(is,65535));\n        checkConsistency(is);\n\n        is = intsetNew();\n        is = intsetAdd(is,32,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT16);\n        is = intsetAdd(is,-65535,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT32);\n        assert(intsetFind(is,32));\n        assert(intsetFind(is,-65535));\n        checkConsistency(is);\n        ok();\n    }\n\n    printf(\"Upgrade from int16 to int64: \"); {\n        is = intsetNew();\n        is = intsetAdd(is,32,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT16);\n        is = intsetAdd(is,4294967295,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT64);\n        assert(intsetFind(is,32));\n        assert(intsetFind(is,4294967295));\n        checkConsistency(is);\n\n        is = intsetNew();\n        is = intsetAdd(is,32,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT16);\n        is = intsetAdd(is,-4294967295,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT64);\n        assert(intsetFind(is,32));\n        assert(intsetFind(is,-4294967295));\n        checkConsistency(is);\n        ok();\n    }\n\n    printf(\"Upgrade from int32 to int64: \"); {\n        is = intsetNew();\n        is = intsetAdd(is,65535,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT32);\n        is = intsetAdd(is,4294967295,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT64);\n        assert(intsetFind(is,65535));\n        assert(intsetFind(is,4294967295));\n        checkConsistency(is);\n\n        is = intsetNew();\n        is = intsetAdd(is,65535,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT32);\n        is = intsetAdd(is,-4294967295,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT64);\n        assert(intsetFind(is,65535));\n        assert(intsetFind(is,-4294967295));\n        checkConsistency(is);\n        ok();\n    }\n\n    printf(\"Stress lookups: \"); {\n        long num = 100000, size = 10000;\n        int i, bits = 20;\n        long long start;\n        is = createSet(bits,size);\n        checkConsistency(is);\n\n        start = usec();\n        for (i = 0; i < num; i++) intsetSearch(is,rand() % ((1<<bits)-1),NULL);\n        printf(\"%ld lookups, %ld element set, %lldusec\\n\",\n               num,size,usec()-start);\n    }\n\n    printf(\"Stress add+delete: \"); {\n        int i, v1, v2;\n        is = intsetNew();\n        for (i = 0; i < 0xffff; i++) {\n            v1 = rand() % 0xfff;\n            is = intsetAdd(is,v1,NULL);\n            assert(intsetFind(is,v1));\n\n            v2 = rand() % 0xfff;\n            is = intsetRemove(is,v2,NULL);\n            assert(!intsetFind(is,v2));\n        }\n        checkConsistency(is);\n        ok();\n    }\n\n    return 0;\n}\n#endif\n", "/*\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n#include \"lzf.h\"    /* LZF compression library */\n#include \"zipmap.h\"\n#include \"endianconv.h\"\n#include \"stream.h\"\n\n#include <math.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/wait.h>\n#include <arpa/inet.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n\n/* This macro is called when the internal RDB stracture is corrupt */\n#define rdbExitReportCorruptRDB(...) rdbReportError(1, __LINE__,__VA_ARGS__)\n/* This macro is called when RDB read failed (possibly a short read) */\n#define rdbReportReadError(...) rdbReportError(0, __LINE__,__VA_ARGS__)\n\nchar* rdbFileBeingLoaded = NULL; /* used for rdb checking on read error */\nextern int rdbCheckMode;\nvoid rdbCheckError(const char *fmt, ...);\nvoid rdbCheckSetError(const char *fmt, ...);\n\n#ifdef __GNUC__\nvoid rdbReportError(int corruption_error, int linenum, char *reason, ...) __attribute__ ((format (printf, 3, 4)));\n#endif\nvoid rdbReportError(int corruption_error, int linenum, char *reason, ...) {\n    va_list ap;\n    char msg[1024];\n    int len;\n\n    len = snprintf(msg,sizeof(msg),\n        \"Internal error in RDB reading offset %llu, function at rdb.c:%d -> \",\n        (unsigned long long)server.loading_loaded_bytes, linenum);\n    va_start(ap,reason);\n    vsnprintf(msg+len,sizeof(msg)-len,reason,ap);\n    va_end(ap);\n\n    if (!rdbCheckMode) {\n        if (rdbFileBeingLoaded || corruption_error) {\n            serverLog(LL_WARNING, \"%s\", msg);\n            char *argv[2] = {\"\",rdbFileBeingLoaded};\n            redis_check_rdb_main(2,argv,NULL);\n        } else {\n            serverLog(LL_WARNING, \"%s. Failure loading rdb format from socket, assuming connection error, resuming operation.\", msg);\n            return;\n        }\n    } else {\n        rdbCheckError(\"%s\",msg);\n    }\n    serverLog(LL_WARNING, \"Terminating server after rdb file reading failure.\");\n    exit(1);\n}\n\nstatic ssize_t rdbWriteRaw(rio *rdb, void *p, size_t len) {\n    if (rdb && rioWrite(rdb,p,len) == 0)\n        return -1;\n    return len;\n}\n\nint rdbSaveType(rio *rdb, unsigned char type) {\n    return rdbWriteRaw(rdb,&type,1);\n}\n\n/* Load a \"type\" in RDB format, that is a one byte unsigned integer.\n * This function is not only used to load object types, but also special\n * \"types\" like the end-of-file type, the EXPIRE type, and so forth. */\nint rdbLoadType(rio *rdb) {\n    unsigned char type;\n    if (rioRead(rdb,&type,1) == 0) return -1;\n    return type;\n}\n\n/* This is only used to load old databases stored with the RDB_OPCODE_EXPIRETIME\n * opcode. New versions of Redis store using the RDB_OPCODE_EXPIRETIME_MS\n * opcode. On error -1 is returned, however this could be a valid time, so\n * to check for loading errors the caller should call rioGetReadError() after\n * calling this function. */\ntime_t rdbLoadTime(rio *rdb) {\n    int32_t t32;\n    if (rioRead(rdb,&t32,4) == 0) return -1;\n    return (time_t)t32;\n}\n\nint rdbSaveMillisecondTime(rio *rdb, long long t) {\n    int64_t t64 = (int64_t) t;\n    memrev64ifbe(&t64); /* Store in little endian. */\n    return rdbWriteRaw(rdb,&t64,8);\n}\n\n/* This function loads a time from the RDB file. It gets the version of the\n * RDB because, unfortunately, before Redis 5 (RDB version 9), the function\n * failed to convert data to/from little endian, so RDB files with keys having\n * expires could not be shared between big endian and little endian systems\n * (because the expire time will be totally wrong). The fix for this is just\n * to call memrev64ifbe(), however if we fix this for all the RDB versions,\n * this call will introduce an incompatibility for big endian systems:\n * after upgrading to Redis version 5 they will no longer be able to load their\n * own old RDB files. Because of that, we instead fix the function only for new\n * RDB versions, and load older RDB versions as we used to do in the past,\n * allowing big endian systems to load their own old RDB files.\n *\n * On I/O error the function returns LLONG_MAX, however if this is also a\n * valid stored value, the caller should use rioGetReadError() to check for\n * errors after calling this function. */\nlong long rdbLoadMillisecondTime(rio *rdb, int rdbver) {\n    int64_t t64;\n    if (rioRead(rdb,&t64,8) == 0) return LLONG_MAX;\n    if (rdbver >= 9) /* Check the top comment of this function. */\n        memrev64ifbe(&t64); /* Convert in big endian if the system is BE. */\n    return (long long)t64;\n}\n\n/* Saves an encoded length. The first two bits in the first byte are used to\n * hold the encoding type. See the RDB_* definitions for more information\n * on the types of encoding. */\nint rdbSaveLen(rio *rdb, uint64_t len) {\n    unsigned char buf[2];\n    size_t nwritten;\n\n    if (len < (1<<6)) {\n        /* Save a 6 bit len */\n        buf[0] = (len&0xFF)|(RDB_6BITLEN<<6);\n        if (rdbWriteRaw(rdb,buf,1) == -1) return -1;\n        nwritten = 1;\n    } else if (len < (1<<14)) {\n        /* Save a 14 bit len */\n        buf[0] = ((len>>8)&0xFF)|(RDB_14BITLEN<<6);\n        buf[1] = len&0xFF;\n        if (rdbWriteRaw(rdb,buf,2) == -1) return -1;\n        nwritten = 2;\n    } else if (len <= UINT32_MAX) {\n        /* Save a 32 bit len */\n        buf[0] = RDB_32BITLEN;\n        if (rdbWriteRaw(rdb,buf,1) == -1) return -1;\n        uint32_t len32 = htonl(len);\n        if (rdbWriteRaw(rdb,&len32,4) == -1) return -1;\n        nwritten = 1+4;\n    } else {\n        /* Save a 64 bit len */\n        buf[0] = RDB_64BITLEN;\n        if (rdbWriteRaw(rdb,buf,1) == -1) return -1;\n        len = htonu64(len);\n        if (rdbWriteRaw(rdb,&len,8) == -1) return -1;\n        nwritten = 1+8;\n    }\n    return nwritten;\n}\n\n\n/* Load an encoded length. If the loaded length is a normal length as stored\n * with rdbSaveLen(), the read length is set to '*lenptr'. If instead the\n * loaded length describes a special encoding that follows, then '*isencoded'\n * is set to 1 and the encoding format is stored at '*lenptr'.\n *\n * See the RDB_ENC_* definitions in rdb.h for more information on special\n * encodings.\n *\n * The function returns -1 on error, 0 on success. */\nint rdbLoadLenByRef(rio *rdb, int *isencoded, uint64_t *lenptr) {\n    unsigned char buf[2];\n    int type;\n\n    if (isencoded) *isencoded = 0;\n    if (rioRead(rdb,buf,1) == 0) return -1;\n    type = (buf[0]&0xC0)>>6;\n    if (type == RDB_ENCVAL) {\n        /* Read a 6 bit encoding type. */\n        if (isencoded) *isencoded = 1;\n        *lenptr = buf[0]&0x3F;\n    } else if (type == RDB_6BITLEN) {\n        /* Read a 6 bit len. */\n        *lenptr = buf[0]&0x3F;\n    } else if (type == RDB_14BITLEN) {\n        /* Read a 14 bit len. */\n        if (rioRead(rdb,buf+1,1) == 0) return -1;\n        *lenptr = ((buf[0]&0x3F)<<8)|buf[1];\n    } else if (buf[0] == RDB_32BITLEN) {\n        /* Read a 32 bit len. */\n        uint32_t len;\n        if (rioRead(rdb,&len,4) == 0) return -1;\n        *lenptr = ntohl(len);\n    } else if (buf[0] == RDB_64BITLEN) {\n        /* Read a 64 bit len. */\n        uint64_t len;\n        if (rioRead(rdb,&len,8) == 0) return -1;\n        *lenptr = ntohu64(len);\n    } else {\n        rdbExitReportCorruptRDB(\n            \"Unknown length encoding %d in rdbLoadLen()\",type);\n        return -1; /* Never reached. */\n    }\n    return 0;\n}\n\n/* This is like rdbLoadLenByRef() but directly returns the value read\n * from the RDB stream, signaling an error by returning RDB_LENERR\n * (since it is a too large count to be applicable in any Redis data\n * structure). */\nuint64_t rdbLoadLen(rio *rdb, int *isencoded) {\n    uint64_t len;\n\n    if (rdbLoadLenByRef(rdb,isencoded,&len) == -1) return RDB_LENERR;\n    return len;\n}\n\n/* Encodes the \"value\" argument as integer when it fits in the supported ranges\n * for encoded types. If the function successfully encodes the integer, the\n * representation is stored in the buffer pointer to by \"enc\" and the string\n * length is returned. Otherwise 0 is returned. */\nint rdbEncodeInteger(long long value, unsigned char *enc) {\n    if (value >= -(1<<7) && value <= (1<<7)-1) {\n        enc[0] = (RDB_ENCVAL<<6)|RDB_ENC_INT8;\n        enc[1] = value&0xFF;\n        return 2;\n    } else if (value >= -(1<<15) && value <= (1<<15)-1) {\n        enc[0] = (RDB_ENCVAL<<6)|RDB_ENC_INT16;\n        enc[1] = value&0xFF;\n        enc[2] = (value>>8)&0xFF;\n        return 3;\n    } else if (value >= -((long long)1<<31) && value <= ((long long)1<<31)-1) {\n        enc[0] = (RDB_ENCVAL<<6)|RDB_ENC_INT32;\n        enc[1] = value&0xFF;\n        enc[2] = (value>>8)&0xFF;\n        enc[3] = (value>>16)&0xFF;\n        enc[4] = (value>>24)&0xFF;\n        return 5;\n    } else {\n        return 0;\n    }\n}\n\n/* Loads an integer-encoded object with the specified encoding type \"enctype\".\n * The returned value changes according to the flags, see\n * rdbGenericLoadStringObject() for more info. */\nvoid *rdbLoadIntegerObject(rio *rdb, int enctype, int flags, size_t *lenptr) {\n    int plain = flags & RDB_LOAD_PLAIN;\n    int sds = flags & RDB_LOAD_SDS;\n    int encode = flags & RDB_LOAD_ENC;\n    unsigned char enc[4];\n    long long val;\n\n    if (enctype == RDB_ENC_INT8) {\n        if (rioRead(rdb,enc,1) == 0) return NULL;\n        val = (signed char)enc[0];\n    } else if (enctype == RDB_ENC_INT16) {\n        uint16_t v;\n        if (rioRead(rdb,enc,2) == 0) return NULL;\n        v = enc[0]|(enc[1]<<8);\n        val = (int16_t)v;\n    } else if (enctype == RDB_ENC_INT32) {\n        uint32_t v;\n        if (rioRead(rdb,enc,4) == 0) return NULL;\n        v = enc[0]|(enc[1]<<8)|(enc[2]<<16)|(enc[3]<<24);\n        val = (int32_t)v;\n    } else {\n        rdbExitReportCorruptRDB(\"Unknown RDB integer encoding type %d\",enctype);\n        return NULL; /* Never reached. */\n    }\n    if (plain || sds) {\n        char buf[LONG_STR_SIZE], *p;\n        int len = ll2string(buf,sizeof(buf),val);\n        if (lenptr) *lenptr = len;\n        p = plain ? zmalloc(len) : sdsnewlen(SDS_NOINIT,len);\n        memcpy(p,buf,len);\n        return p;\n    } else if (encode) {\n        return createStringObjectFromLongLongForValue(val);\n    } else {\n        return createObject(OBJ_STRING,sdsfromlonglong(val));\n    }\n}\n\n/* String objects in the form \"2391\" \"-100\" without any space and with a\n * range of values that can fit in an 8, 16 or 32 bit signed value can be\n * encoded as integers to save space */\nint rdbTryIntegerEncoding(char *s, size_t len, unsigned char *enc) {\n    long long value;\n    char *endptr, buf[32];\n\n    /* Check if it's possible to encode this value as a number */\n    value = strtoll(s, &endptr, 10);\n    if (endptr[0] != '\\0') return 0;\n    ll2string(buf,32,value);\n\n    /* If the number converted back into a string is not identical\n     * then it's not possible to encode the string as integer */\n    if (strlen(buf) != len || memcmp(buf,s,len)) return 0;\n\n    return rdbEncodeInteger(value,enc);\n}\n\nssize_t rdbSaveLzfBlob(rio *rdb, void *data, size_t compress_len,\n                       size_t original_len) {\n    unsigned char byte;\n    ssize_t n, nwritten = 0;\n\n    /* Data compressed! Let's save it on disk */\n    byte = (RDB_ENCVAL<<6)|RDB_ENC_LZF;\n    if ((n = rdbWriteRaw(rdb,&byte,1)) == -1) goto writeerr;\n    nwritten += n;\n\n    if ((n = rdbSaveLen(rdb,compress_len)) == -1) goto writeerr;\n    nwritten += n;\n\n    if ((n = rdbSaveLen(rdb,original_len)) == -1) goto writeerr;\n    nwritten += n;\n\n    if ((n = rdbWriteRaw(rdb,data,compress_len)) == -1) goto writeerr;\n    nwritten += n;\n\n    return nwritten;\n\nwriteerr:\n    return -1;\n}\n\nssize_t rdbSaveLzfStringObject(rio *rdb, unsigned char *s, size_t len) {\n    size_t comprlen, outlen;\n    void *out;\n\n    /* We require at least four bytes compression for this to be worth it */\n    if (len <= 4) return 0;\n    outlen = len-4;\n    if ((out = zmalloc(outlen+1)) == NULL) return 0;\n    comprlen = lzf_compress(s, len, out, outlen);\n    if (comprlen == 0) {\n        zfree(out);\n        return 0;\n    }\n    ssize_t nwritten = rdbSaveLzfBlob(rdb, out, comprlen, len);\n    zfree(out);\n    return nwritten;\n}\n\n/* Load an LZF compressed string in RDB format. The returned value\n * changes according to 'flags'. For more info check the\n * rdbGenericLoadStringObject() function. */\nvoid *rdbLoadLzfStringObject(rio *rdb, int flags, size_t *lenptr) {\n    int plain = flags & RDB_LOAD_PLAIN;\n    int sds = flags & RDB_LOAD_SDS;\n    uint64_t len, clen;\n    unsigned char *c = NULL;\n    char *val = NULL;\n\n    if ((clen = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;\n    if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;\n    if ((c = zmalloc(clen)) == NULL) goto err;\n\n    /* Allocate our target according to the uncompressed size. */\n    if (plain) {\n        val = zmalloc(len);\n    } else {\n        val = sdsnewlen(SDS_NOINIT,len);\n    }\n    if (lenptr) *lenptr = len;\n\n    /* Load the compressed representation and uncompress it to target. */\n    if (rioRead(rdb,c,clen) == 0) goto err;\n    if (lzf_decompress(c,clen,val,len) == 0) {\n        rdbExitReportCorruptRDB(\"Invalid LZF compressed string\");\n    }\n    zfree(c);\n\n    if (plain || sds) {\n        return val;\n    } else {\n        return createObject(OBJ_STRING,val);\n    }\nerr:\n    zfree(c);\n    if (plain)\n        zfree(val);\n    else\n        sdsfree(val);\n    return NULL;\n}\n\n/* Save a string object as [len][data] on disk. If the object is a string\n * representation of an integer value we try to save it in a special form */\nssize_t rdbSaveRawString(rio *rdb, unsigned char *s, size_t len) {\n    int enclen;\n    ssize_t n, nwritten = 0;\n\n    /* Try integer encoding */\n    if (len <= 11) {\n        unsigned char buf[5];\n        if ((enclen = rdbTryIntegerEncoding((char*)s,len,buf)) > 0) {\n            if (rdbWriteRaw(rdb,buf,enclen) == -1) return -1;\n            return enclen;\n        }\n    }\n\n    /* Try LZF compression - under 20 bytes it's unable to compress even\n     * aaaaaaaaaaaaaaaaaa so skip it */\n    if (server.rdb_compression && len > 20) {\n        n = rdbSaveLzfStringObject(rdb,s,len);\n        if (n == -1) return -1;\n        if (n > 0) return n;\n        /* Return value of 0 means data can't be compressed, save the old way */\n    }\n\n    /* Store verbatim */\n    if ((n = rdbSaveLen(rdb,len)) == -1) return -1;\n    nwritten += n;\n    if (len > 0) {\n        if (rdbWriteRaw(rdb,s,len) == -1) return -1;\n        nwritten += len;\n    }\n    return nwritten;\n}\n\n/* Save a long long value as either an encoded string or a string. */\nssize_t rdbSaveLongLongAsStringObject(rio *rdb, long long value) {\n    unsigned char buf[32];\n    ssize_t n, nwritten = 0;\n    int enclen = rdbEncodeInteger(value,buf);\n    if (enclen > 0) {\n        return rdbWriteRaw(rdb,buf,enclen);\n    } else {\n        /* Encode as string */\n        enclen = ll2string((char*)buf,32,value);\n        serverAssert(enclen < 32);\n        if ((n = rdbSaveLen(rdb,enclen)) == -1) return -1;\n        nwritten += n;\n        if ((n = rdbWriteRaw(rdb,buf,enclen)) == -1) return -1;\n        nwritten += n;\n    }\n    return nwritten;\n}\n\n/* Like rdbSaveRawString() gets a Redis object instead. */\nssize_t rdbSaveStringObject(rio *rdb, robj *obj) {\n    /* Avoid to decode the object, then encode it again, if the\n     * object is already integer encoded. */\n    if (obj->encoding == OBJ_ENCODING_INT) {\n        return rdbSaveLongLongAsStringObject(rdb,(long)obj->ptr);\n    } else {\n        serverAssertWithInfo(NULL,obj,sdsEncodedObject(obj));\n        return rdbSaveRawString(rdb,obj->ptr,sdslen(obj->ptr));\n    }\n}\n\n/* Load a string object from an RDB file according to flags:\n *\n * RDB_LOAD_NONE (no flags): load an RDB object, unencoded.\n * RDB_LOAD_ENC: If the returned type is a Redis object, try to\n *               encode it in a special way to be more memory\n *               efficient. When this flag is passed the function\n *               no longer guarantees that obj->ptr is an SDS string.\n * RDB_LOAD_PLAIN: Return a plain string allocated with zmalloc()\n *                 instead of a Redis object with an sds in it.\n * RDB_LOAD_SDS: Return an SDS string instead of a Redis object.\n *\n * On I/O error NULL is returned.\n */\nvoid *rdbGenericLoadStringObject(rio *rdb, int flags, size_t *lenptr) {\n    int encode = flags & RDB_LOAD_ENC;\n    int plain = flags & RDB_LOAD_PLAIN;\n    int sds = flags & RDB_LOAD_SDS;\n    int isencoded;\n    unsigned long long len;\n\n    len = rdbLoadLen(rdb,&isencoded);\n    if (isencoded) {\n        switch(len) {\n        case RDB_ENC_INT8:\n        case RDB_ENC_INT16:\n        case RDB_ENC_INT32:\n            return rdbLoadIntegerObject(rdb,len,flags,lenptr);\n        case RDB_ENC_LZF:\n            return rdbLoadLzfStringObject(rdb,flags,lenptr);\n        default:\n            rdbExitReportCorruptRDB(\"Unknown RDB string encoding type %llu\",len);\n            return NULL;\n        }\n    }\n\n    if (len == RDB_LENERR) return NULL;\n    if (plain || sds) {\n        void *buf = plain ? zmalloc(len) : sdsnewlen(SDS_NOINIT,len);\n        if (lenptr) *lenptr = len;\n        if (len && rioRead(rdb,buf,len) == 0) {\n            if (plain)\n                zfree(buf);\n            else\n                sdsfree(buf);\n            return NULL;\n        }\n        return buf;\n    } else {\n        robj *o = encode ? createStringObject(SDS_NOINIT,len) :\n                           createRawStringObject(SDS_NOINIT,len);\n        if (len && rioRead(rdb,o->ptr,len) == 0) {\n            decrRefCount(o);\n            return NULL;\n        }\n        return o;\n    }\n}\n\nrobj *rdbLoadStringObject(rio *rdb) {\n    return rdbGenericLoadStringObject(rdb,RDB_LOAD_NONE,NULL);\n}\n\nrobj *rdbLoadEncodedStringObject(rio *rdb) {\n    return rdbGenericLoadStringObject(rdb,RDB_LOAD_ENC,NULL);\n}\n\n/* Save a double value. Doubles are saved as strings prefixed by an unsigned\n * 8 bit integer specifying the length of the representation.\n * This 8 bit integer has special values in order to specify the following\n * conditions:\n * 253: not a number\n * 254: + inf\n * 255: - inf\n */\nint rdbSaveDoubleValue(rio *rdb, double val) {\n    unsigned char buf[128];\n    int len;\n\n    if (isnan(val)) {\n        buf[0] = 253;\n        len = 1;\n    } else if (!isfinite(val)) {\n        len = 1;\n        buf[0] = (val < 0) ? 255 : 254;\n    } else {\n#if (DBL_MANT_DIG >= 52) && (LLONG_MAX == 0x7fffffffffffffffLL)\n        /* Check if the float is in a safe range to be casted into a\n         * long long. We are assuming that long long is 64 bit here.\n         * Also we are assuming that there are no implementations around where\n         * double has precision < 52 bit.\n         *\n         * Under this assumptions we test if a double is inside an interval\n         * where casting to long long is safe. Then using two castings we\n         * make sure the decimal part is zero. If all this is true we use\n         * integer printing function that is much faster. */\n        double min = -4503599627370495; /* (2^52)-1 */\n        double max = 4503599627370496; /* -(2^52) */\n        if (val > min && val < max && val == ((double)((long long)val)))\n            ll2string((char*)buf+1,sizeof(buf)-1,(long long)val);\n        else\n#endif\n            snprintf((char*)buf+1,sizeof(buf)-1,\"%.17g\",val);\n        buf[0] = strlen((char*)buf+1);\n        len = buf[0]+1;\n    }\n    return rdbWriteRaw(rdb,buf,len);\n}\n\n/* For information about double serialization check rdbSaveDoubleValue() */\nint rdbLoadDoubleValue(rio *rdb, double *val) {\n    char buf[256];\n    unsigned char len;\n\n    if (rioRead(rdb,&len,1) == 0) return -1;\n    switch(len) {\n    case 255: *val = R_NegInf; return 0;\n    case 254: *val = R_PosInf; return 0;\n    case 253: *val = R_Nan; return 0;\n    default:\n        if (rioRead(rdb,buf,len) == 0) return -1;\n        buf[len] = '\\0';\n        sscanf(buf, \"%lg\", val);\n        return 0;\n    }\n}\n\n/* Saves a double for RDB 8 or greater, where IE754 binary64 format is assumed.\n * We just make sure the integer is always stored in little endian, otherwise\n * the value is copied verbatim from memory to disk.\n *\n * Return -1 on error, the size of the serialized value on success. */\nint rdbSaveBinaryDoubleValue(rio *rdb, double val) {\n    memrev64ifbe(&val);\n    return rdbWriteRaw(rdb,&val,sizeof(val));\n}\n\n/* Loads a double from RDB 8 or greater. See rdbSaveBinaryDoubleValue() for\n * more info. On error -1 is returned, otherwise 0. */\nint rdbLoadBinaryDoubleValue(rio *rdb, double *val) {\n    if (rioRead(rdb,val,sizeof(*val)) == 0) return -1;\n    memrev64ifbe(val);\n    return 0;\n}\n\n/* Like rdbSaveBinaryDoubleValue() but single precision. */\nint rdbSaveBinaryFloatValue(rio *rdb, float val) {\n    memrev32ifbe(&val);\n    return rdbWriteRaw(rdb,&val,sizeof(val));\n}\n\n/* Like rdbLoadBinaryDoubleValue() but single precision. */\nint rdbLoadBinaryFloatValue(rio *rdb, float *val) {\n    if (rioRead(rdb,val,sizeof(*val)) == 0) return -1;\n    memrev32ifbe(val);\n    return 0;\n}\n\n/* Save the object type of object \"o\". */\nint rdbSaveObjectType(rio *rdb, robj *o) {\n    switch (o->type) {\n    case OBJ_STRING:\n        return rdbSaveType(rdb,RDB_TYPE_STRING);\n    case OBJ_LIST:\n        if (o->encoding == OBJ_ENCODING_QUICKLIST)\n            return rdbSaveType(rdb,RDB_TYPE_LIST_QUICKLIST);\n        else\n            serverPanic(\"Unknown list encoding\");\n    case OBJ_SET:\n        if (o->encoding == OBJ_ENCODING_INTSET)\n            return rdbSaveType(rdb,RDB_TYPE_SET_INTSET);\n        else if (o->encoding == OBJ_ENCODING_HT)\n            return rdbSaveType(rdb,RDB_TYPE_SET);\n        else\n            serverPanic(\"Unknown set encoding\");\n    case OBJ_ZSET:\n        if (o->encoding == OBJ_ENCODING_ZIPLIST)\n            return rdbSaveType(rdb,RDB_TYPE_ZSET_ZIPLIST);\n        else if (o->encoding == OBJ_ENCODING_SKIPLIST)\n            return rdbSaveType(rdb,RDB_TYPE_ZSET_2);\n        else\n            serverPanic(\"Unknown sorted set encoding\");\n    case OBJ_HASH:\n        if (o->encoding == OBJ_ENCODING_ZIPLIST)\n            return rdbSaveType(rdb,RDB_TYPE_HASH_ZIPLIST);\n        else if (o->encoding == OBJ_ENCODING_HT)\n            return rdbSaveType(rdb,RDB_TYPE_HASH);\n        else\n            serverPanic(\"Unknown hash encoding\");\n    case OBJ_STREAM:\n        return rdbSaveType(rdb,RDB_TYPE_STREAM_LISTPACKS);\n    case OBJ_MODULE:\n        return rdbSaveType(rdb,RDB_TYPE_MODULE_2);\n    default:\n        serverPanic(\"Unknown object type\");\n    }\n    return -1; /* avoid warning */\n}\n\n/* Use rdbLoadType() to load a TYPE in RDB format, but returns -1 if the\n * type is not specifically a valid Object Type. */\nint rdbLoadObjectType(rio *rdb) {\n    int type;\n    if ((type = rdbLoadType(rdb)) == -1) return -1;\n    if (!rdbIsObjectType(type)) return -1;\n    return type;\n}\n\n/* This helper function serializes a consumer group Pending Entries List (PEL)\n * into the RDB file. The 'nacks' argument tells the function if also persist\n * the informations about the not acknowledged message, or if to persist\n * just the IDs: this is useful because for the global consumer group PEL\n * we serialized the NACKs as well, but when serializing the local consumer\n * PELs we just add the ID, that will be resolved inside the global PEL to\n * put a reference to the same structure. */\nssize_t rdbSaveStreamPEL(rio *rdb, rax *pel, int nacks) {\n    ssize_t n, nwritten = 0;\n\n    /* Number of entries in the PEL. */\n    if ((n = rdbSaveLen(rdb,raxSize(pel))) == -1) return -1;\n    nwritten += n;\n\n    /* Save each entry. */\n    raxIterator ri;\n    raxStart(&ri,pel);\n    raxSeek(&ri,\"^\",NULL,0);\n    while(raxNext(&ri)) {\n        /* We store IDs in raw form as 128 big big endian numbers, like\n         * they are inside the radix tree key. */\n        if ((n = rdbWriteRaw(rdb,ri.key,sizeof(streamID))) == -1) {\n            raxStop(&ri);\n            return -1;\n        }\n        nwritten += n;\n\n        if (nacks) {\n            streamNACK *nack = ri.data;\n            if ((n = rdbSaveMillisecondTime(rdb,nack->delivery_time)) == -1) {\n                raxStop(&ri);\n                return -1;\n            }\n            nwritten += n;\n            if ((n = rdbSaveLen(rdb,nack->delivery_count)) == -1) {\n                raxStop(&ri);\n                return -1;\n            }\n            nwritten += n;\n            /* We don't save the consumer name: we'll save the pending IDs\n             * for each consumer in the consumer PEL, and resolve the consumer\n             * at loading time. */\n        }\n    }\n    raxStop(&ri);\n    return nwritten;\n}\n\n/* Serialize the consumers of a stream consumer group into the RDB. Helper\n * function for the stream data type serialization. What we do here is to\n * persist the consumer metadata, and it's PEL, for each consumer. */\nsize_t rdbSaveStreamConsumers(rio *rdb, streamCG *cg) {\n    ssize_t n, nwritten = 0;\n\n    /* Number of consumers in this consumer group. */\n    if ((n = rdbSaveLen(rdb,raxSize(cg->consumers))) == -1) return -1;\n    nwritten += n;\n\n    /* Save each consumer. */\n    raxIterator ri;\n    raxStart(&ri,cg->consumers);\n    raxSeek(&ri,\"^\",NULL,0);\n    while(raxNext(&ri)) {\n        streamConsumer *consumer = ri.data;\n\n        /* Consumer name. */\n        if ((n = rdbSaveRawString(rdb,ri.key,ri.key_len)) == -1) {\n            raxStop(&ri);\n            return -1;\n        }\n        nwritten += n;\n\n        /* Last seen time. */\n        if ((n = rdbSaveMillisecondTime(rdb,consumer->seen_time)) == -1) {\n            raxStop(&ri);\n            return -1;\n        }\n        nwritten += n;\n\n        /* Consumer PEL, without the ACKs (see last parameter of the function\n         * passed with value of 0), at loading time we'll lookup the ID\n         * in the consumer group global PEL and will put a reference in the\n         * consumer local PEL. */\n        if ((n = rdbSaveStreamPEL(rdb,consumer->pel,0)) == -1) {\n            raxStop(&ri);\n            return -1;\n        }\n        nwritten += n;\n    }\n    raxStop(&ri);\n    return nwritten;\n}\n\n/* Save a Redis object.\n * Returns -1 on error, number of bytes written on success. */\nssize_t rdbSaveObject(rio *rdb, robj *o, robj *key) {\n    ssize_t n = 0, nwritten = 0;\n\n    if (o->type == OBJ_STRING) {\n        /* Save a string value */\n        if ((n = rdbSaveStringObject(rdb,o)) == -1) return -1;\n        nwritten += n;\n    } else if (o->type == OBJ_LIST) {\n        /* Save a list value */\n        if (o->encoding == OBJ_ENCODING_QUICKLIST) {\n            quicklist *ql = o->ptr;\n            quicklistNode *node = ql->head;\n\n            if ((n = rdbSaveLen(rdb,ql->len)) == -1) return -1;\n            nwritten += n;\n\n            while(node) {\n                if (quicklistNodeIsCompressed(node)) {\n                    void *data;\n                    size_t compress_len = quicklistGetLzf(node, &data);\n                    if ((n = rdbSaveLzfBlob(rdb,data,compress_len,node->sz)) == -1) return -1;\n                    nwritten += n;\n                } else {\n                    if ((n = rdbSaveRawString(rdb,node->zl,node->sz)) == -1) return -1;\n                    nwritten += n;\n                }\n                node = node->next;\n            }\n        } else {\n            serverPanic(\"Unknown list encoding\");\n        }\n    } else if (o->type == OBJ_SET) {\n        /* Save a set value */\n        if (o->encoding == OBJ_ENCODING_HT) {\n            dict *set = o->ptr;\n            dictIterator *di = dictGetIterator(set);\n            dictEntry *de;\n\n            if ((n = rdbSaveLen(rdb,dictSize(set))) == -1) {\n                dictReleaseIterator(di);\n                return -1;\n            }\n            nwritten += n;\n\n            while((de = dictNext(di)) != NULL) {\n                sds ele = dictGetKey(de);\n                if ((n = rdbSaveRawString(rdb,(unsigned char*)ele,sdslen(ele)))\n                    == -1)\n                {\n                    dictReleaseIterator(di);\n                    return -1;\n                }\n                nwritten += n;\n            }\n            dictReleaseIterator(di);\n        } else if (o->encoding == OBJ_ENCODING_INTSET) {\n            size_t l = intsetBlobLen((intset*)o->ptr);\n\n            if ((n = rdbSaveRawString(rdb,o->ptr,l)) == -1) return -1;\n            nwritten += n;\n        } else {\n            serverPanic(\"Unknown set encoding\");\n        }\n    } else if (o->type == OBJ_ZSET) {\n        /* Save a sorted set value */\n        if (o->encoding == OBJ_ENCODING_ZIPLIST) {\n            size_t l = ziplistBlobLen((unsigned char*)o->ptr);\n\n            if ((n = rdbSaveRawString(rdb,o->ptr,l)) == -1) return -1;\n            nwritten += n;\n        } else if (o->encoding == OBJ_ENCODING_SKIPLIST) {\n            zset *zs = o->ptr;\n            zskiplist *zsl = zs->zsl;\n\n            if ((n = rdbSaveLen(rdb,zsl->length)) == -1) return -1;\n            nwritten += n;\n\n            /* We save the skiplist elements from the greatest to the smallest\n             * (that's trivial since the elements are already ordered in the\n             * skiplist): this improves the load process, since the next loaded\n             * element will always be the smaller, so adding to the skiplist\n             * will always immediately stop at the head, making the insertion\n             * O(1) instead of O(log(N)). */\n            zskiplistNode *zn = zsl->tail;\n            while (zn != NULL) {\n                if ((n = rdbSaveRawString(rdb,\n                    (unsigned char*)zn->ele,sdslen(zn->ele))) == -1)\n                {\n                    return -1;\n                }\n                nwritten += n;\n                if ((n = rdbSaveBinaryDoubleValue(rdb,zn->score)) == -1)\n                    return -1;\n                nwritten += n;\n                zn = zn->backward;\n            }\n        } else {\n            serverPanic(\"Unknown sorted set encoding\");\n        }\n    } else if (o->type == OBJ_HASH) {\n        /* Save a hash value */\n        if (o->encoding == OBJ_ENCODING_ZIPLIST) {\n            size_t l = ziplistBlobLen((unsigned char*)o->ptr);\n\n            if ((n = rdbSaveRawString(rdb,o->ptr,l)) == -1) return -1;\n            nwritten += n;\n\n        } else if (o->encoding == OBJ_ENCODING_HT) {\n            dictIterator *di = dictGetIterator(o->ptr);\n            dictEntry *de;\n\n            if ((n = rdbSaveLen(rdb,dictSize((dict*)o->ptr))) == -1) {\n                dictReleaseIterator(di);\n                return -1;\n            }\n            nwritten += n;\n\n            while((de = dictNext(di)) != NULL) {\n                sds field = dictGetKey(de);\n                sds value = dictGetVal(de);\n\n                if ((n = rdbSaveRawString(rdb,(unsigned char*)field,\n                        sdslen(field))) == -1)\n                {\n                    dictReleaseIterator(di);\n                    return -1;\n                }\n                nwritten += n;\n                if ((n = rdbSaveRawString(rdb,(unsigned char*)value,\n                        sdslen(value))) == -1)\n                {\n                    dictReleaseIterator(di);\n                    return -1;\n                }\n                nwritten += n;\n            }\n            dictReleaseIterator(di);\n        } else {\n            serverPanic(\"Unknown hash encoding\");\n        }\n    } else if (o->type == OBJ_STREAM) {\n        /* Store how many listpacks we have inside the radix tree. */\n        stream *s = o->ptr;\n        rax *rax = s->rax;\n        if ((n = rdbSaveLen(rdb,raxSize(rax))) == -1) return -1;\n        nwritten += n;\n\n        /* Serialize all the listpacks inside the radix tree as they are,\n         * when loading back, we'll use the first entry of each listpack\n         * to insert it back into the radix tree. */\n        raxIterator ri;\n        raxStart(&ri,rax);\n        raxSeek(&ri,\"^\",NULL,0);\n        while (raxNext(&ri)) {\n            unsigned char *lp = ri.data;\n            size_t lp_bytes = lpBytes(lp);\n            if ((n = rdbSaveRawString(rdb,ri.key,ri.key_len)) == -1) {\n                raxStop(&ri);\n                return -1;\n            }\n            nwritten += n;\n            if ((n = rdbSaveRawString(rdb,lp,lp_bytes)) == -1) {\n                raxStop(&ri);\n                return -1;\n            }\n            nwritten += n;\n        }\n        raxStop(&ri);\n\n        /* Save the number of elements inside the stream. We cannot obtain\n         * this easily later, since our macro nodes should be checked for\n         * number of items: not a great CPU / space tradeoff. */\n        if ((n = rdbSaveLen(rdb,s->length)) == -1) return -1;\n        nwritten += n;\n        /* Save the last entry ID. */\n        if ((n = rdbSaveLen(rdb,s->last_id.ms)) == -1) return -1;\n        nwritten += n;\n        if ((n = rdbSaveLen(rdb,s->last_id.seq)) == -1) return -1;\n        nwritten += n;\n\n        /* The consumer groups and their clients are part of the stream\n         * type, so serialize every consumer group. */\n\n        /* Save the number of groups. */\n        size_t num_cgroups = s->cgroups ? raxSize(s->cgroups) : 0;\n        if ((n = rdbSaveLen(rdb,num_cgroups)) == -1) return -1;\n        nwritten += n;\n\n        if (num_cgroups) {\n            /* Serialize each consumer group. */\n            raxStart(&ri,s->cgroups);\n            raxSeek(&ri,\"^\",NULL,0);\n            while(raxNext(&ri)) {\n                streamCG *cg = ri.data;\n\n                /* Save the group name. */\n                if ((n = rdbSaveRawString(rdb,ri.key,ri.key_len)) == -1) {\n                    raxStop(&ri);\n                    return -1;\n                }\n                nwritten += n;\n\n                /* Last ID. */\n                if ((n = rdbSaveLen(rdb,cg->last_id.ms)) == -1) {\n                    raxStop(&ri);\n                    return -1;\n                }\n                nwritten += n;\n                if ((n = rdbSaveLen(rdb,cg->last_id.seq)) == -1) {\n                    raxStop(&ri);\n                    return -1;\n                }\n                nwritten += n;\n\n                /* Save the global PEL. */\n                if ((n = rdbSaveStreamPEL(rdb,cg->pel,1)) == -1) {\n                    raxStop(&ri);\n                    return -1;\n                }\n                nwritten += n;\n\n                /* Save the consumers of this group. */\n                if ((n = rdbSaveStreamConsumers(rdb,cg)) == -1) {\n                    raxStop(&ri);\n                    return -1;\n                }\n                nwritten += n;\n            }\n            raxStop(&ri);\n        }\n    } else if (o->type == OBJ_MODULE) {\n        /* Save a module-specific value. */\n        RedisModuleIO io;\n        moduleValue *mv = o->ptr;\n        moduleType *mt = mv->type;\n\n        /* Write the \"module\" identifier as prefix, so that we'll be able\n         * to call the right module during loading. */\n        int retval = rdbSaveLen(rdb,mt->id);\n        if (retval == -1) return -1;\n        io.bytes += retval;\n\n        /* Then write the module-specific representation + EOF marker. */\n        moduleInitIOContext(io,mt,rdb,key);\n        mt->rdb_save(&io,mv->value);\n        retval = rdbSaveLen(rdb,RDB_MODULE_OPCODE_EOF);\n        if (retval == -1)\n            io.error = 1;\n        else\n            io.bytes += retval;\n\n        if (io.ctx) {\n            moduleFreeContext(io.ctx);\n            zfree(io.ctx);\n        }\n        return io.error ? -1 : (ssize_t)io.bytes;\n    } else {\n        serverPanic(\"Unknown object type\");\n    }\n    return nwritten;\n}\n\n/* Return the length the object will have on disk if saved with\n * the rdbSaveObject() function. Currently we use a trick to get\n * this length with very little changes to the code. In the future\n * we could switch to a faster solution. */\nsize_t rdbSavedObjectLen(robj *o, robj *key) {\n    ssize_t len = rdbSaveObject(NULL,o,key);\n    serverAssertWithInfo(NULL,o,len != -1);\n    return len;\n}\n\n/* Save a key-value pair, with expire time, type, key, value.\n * On error -1 is returned.\n * On success if the key was actually saved 1 is returned, otherwise 0\n * is returned (the key was already expired). */\nint rdbSaveKeyValuePair(rio *rdb, robj *key, robj *val, long long expiretime) {\n    int savelru = server.maxmemory_policy & MAXMEMORY_FLAG_LRU;\n    int savelfu = server.maxmemory_policy & MAXMEMORY_FLAG_LFU;\n\n    /* Save the expire time */\n    if (expiretime != -1) {\n        if (rdbSaveType(rdb,RDB_OPCODE_EXPIRETIME_MS) == -1) return -1;\n        if (rdbSaveMillisecondTime(rdb,expiretime) == -1) return -1;\n    }\n\n    /* Save the LRU info. */\n    if (savelru) {\n        uint64_t idletime = estimateObjectIdleTime(val);\n        idletime /= 1000; /* Using seconds is enough and requires less space.*/\n        if (rdbSaveType(rdb,RDB_OPCODE_IDLE) == -1) return -1;\n        if (rdbSaveLen(rdb,idletime) == -1) return -1;\n    }\n\n    /* Save the LFU info. */\n    if (savelfu) {\n        uint8_t buf[1];\n        buf[0] = LFUDecrAndReturn(val);\n        /* We can encode this in exactly two bytes: the opcode and an 8\n         * bit counter, since the frequency is logarithmic with a 0-255 range.\n         * Note that we do not store the halving time because to reset it\n         * a single time when loading does not affect the frequency much. */\n        if (rdbSaveType(rdb,RDB_OPCODE_FREQ) == -1) return -1;\n        if (rdbWriteRaw(rdb,buf,1) == -1) return -1;\n    }\n\n    /* Save type, key, value */\n    if (rdbSaveObjectType(rdb,val) == -1) return -1;\n    if (rdbSaveStringObject(rdb,key) == -1) return -1;\n    if (rdbSaveObject(rdb,val,key) == -1) return -1;\n\n    /* Delay return if required (for testing) */\n    if (server.rdb_key_save_delay)\n        usleep(server.rdb_key_save_delay);\n\n    return 1;\n}\n\n/* Save an AUX field. */\nssize_t rdbSaveAuxField(rio *rdb, void *key, size_t keylen, void *val, size_t vallen) {\n    ssize_t ret, len = 0;\n    if ((ret = rdbSaveType(rdb,RDB_OPCODE_AUX)) == -1) return -1;\n    len += ret;\n    if ((ret = rdbSaveRawString(rdb,key,keylen)) == -1) return -1;\n    len += ret;\n    if ((ret = rdbSaveRawString(rdb,val,vallen)) == -1) return -1;\n    len += ret;\n    return len;\n}\n\n/* Wrapper for rdbSaveAuxField() used when key/val length can be obtained\n * with strlen(). */\nssize_t rdbSaveAuxFieldStrStr(rio *rdb, char *key, char *val) {\n    return rdbSaveAuxField(rdb,key,strlen(key),val,strlen(val));\n}\n\n/* Wrapper for strlen(key) + integer type (up to long long range). */\nssize_t rdbSaveAuxFieldStrInt(rio *rdb, char *key, long long val) {\n    char buf[LONG_STR_SIZE];\n    int vlen = ll2string(buf,sizeof(buf),val);\n    return rdbSaveAuxField(rdb,key,strlen(key),buf,vlen);\n}\n\n/* Save a few default AUX fields with information about the RDB generated. */\nint rdbSaveInfoAuxFields(rio *rdb, int rdbflags, rdbSaveInfo *rsi) {\n    int redis_bits = (sizeof(void*) == 8) ? 64 : 32;\n    int aof_preamble = (rdbflags & RDBFLAGS_AOF_PREAMBLE) != 0;\n\n    /* Add a few fields about the state when the RDB was created. */\n    if (rdbSaveAuxFieldStrStr(rdb,\"redis-ver\",REDIS_VERSION) == -1) return -1;\n    if (rdbSaveAuxFieldStrInt(rdb,\"redis-bits\",redis_bits) == -1) return -1;\n    if (rdbSaveAuxFieldStrInt(rdb,\"ctime\",time(NULL)) == -1) return -1;\n    if (rdbSaveAuxFieldStrInt(rdb,\"used-mem\",zmalloc_used_memory()) == -1) return -1;\n\n    /* Handle saving options that generate aux fields. */\n    if (rsi) {\n        if (rdbSaveAuxFieldStrInt(rdb,\"repl-stream-db\",rsi->repl_stream_db)\n            == -1) return -1;\n        if (rdbSaveAuxFieldStrStr(rdb,\"repl-id\",server.replid)\n            == -1) return -1;\n        if (rdbSaveAuxFieldStrInt(rdb,\"repl-offset\",server.master_repl_offset)\n            == -1) return -1;\n    }\n    if (rdbSaveAuxFieldStrInt(rdb,\"aof-preamble\",aof_preamble) == -1) return -1;\n    return 1;\n}\n\nssize_t rdbSaveSingleModuleAux(rio *rdb, int when, moduleType *mt) {\n    /* Save a module-specific aux value. */\n    RedisModuleIO io;\n    int retval = rdbSaveType(rdb, RDB_OPCODE_MODULE_AUX);\n    if (retval == -1) return -1;\n    io.bytes += retval;\n\n    /* Write the \"module\" identifier as prefix, so that we'll be able\n     * to call the right module during loading. */\n    retval = rdbSaveLen(rdb,mt->id);\n    if (retval == -1) return -1;\n    io.bytes += retval;\n\n    /* write the 'when' so that we can provide it on loading. add a UINT opcode\n     * for backwards compatibility, everything after the MT needs to be prefixed\n     * by an opcode. */\n    retval = rdbSaveLen(rdb,RDB_MODULE_OPCODE_UINT);\n    if (retval == -1) return -1;\n    io.bytes += retval;\n    retval = rdbSaveLen(rdb,when);\n    if (retval == -1) return -1;\n    io.bytes += retval;\n\n    /* Then write the module-specific representation + EOF marker. */\n    moduleInitIOContext(io,mt,rdb,NULL);\n    mt->aux_save(&io,when);\n    retval = rdbSaveLen(rdb,RDB_MODULE_OPCODE_EOF);\n    if (retval == -1)\n        io.error = 1;\n    else\n        io.bytes += retval;\n\n    if (io.ctx) {\n        moduleFreeContext(io.ctx);\n        zfree(io.ctx);\n    }\n    if (io.error)\n        return -1;\n    return io.bytes;\n}\n\n/* Produces a dump of the database in RDB format sending it to the specified\n * Redis I/O channel. On success C_OK is returned, otherwise C_ERR\n * is returned and part of the output, or all the output, can be\n * missing because of I/O errors.\n *\n * When the function returns C_ERR and if 'error' is not NULL, the\n * integer pointed by 'error' is set to the value of errno just after the I/O\n * error. */\nint rdbSaveRio(rio *rdb, int *error, int rdbflags, rdbSaveInfo *rsi) {\n    dictIterator *di = NULL;\n    dictEntry *de;\n    char magic[10];\n    int j;\n    uint64_t cksum;\n    size_t processed = 0;\n\n    if (server.rdb_checksum)\n        rdb->update_cksum = rioGenericUpdateChecksum;\n    snprintf(magic,sizeof(magic),\"REDIS%04d\",RDB_VERSION);\n    if (rdbWriteRaw(rdb,magic,9) == -1) goto werr;\n    if (rdbSaveInfoAuxFields(rdb,rdbflags,rsi) == -1) goto werr;\n    if (rdbSaveModulesAux(rdb, REDISMODULE_AUX_BEFORE_RDB) == -1) goto werr;\n\n    for (j = 0; j < server.dbnum; j++) {\n        redisDb *db = server.db+j;\n        dict *d = db->dict;\n        if (dictSize(d) == 0) continue;\n        di = dictGetSafeIterator(d);\n\n        /* Write the SELECT DB opcode */\n        if (rdbSaveType(rdb,RDB_OPCODE_SELECTDB) == -1) goto werr;\n        if (rdbSaveLen(rdb,j) == -1) goto werr;\n\n        /* Write the RESIZE DB opcode. */\n        uint64_t db_size, expires_size;\n        db_size = dictSize(db->dict);\n        expires_size = dictSize(db->expires);\n        if (rdbSaveType(rdb,RDB_OPCODE_RESIZEDB) == -1) goto werr;\n        if (rdbSaveLen(rdb,db_size) == -1) goto werr;\n        if (rdbSaveLen(rdb,expires_size) == -1) goto werr;\n\n        /* Iterate this DB writing every entry */\n        while((de = dictNext(di)) != NULL) {\n            sds keystr = dictGetKey(de);\n            robj key, *o = dictGetVal(de);\n            long long expire;\n\n            initStaticStringObject(key,keystr);\n            expire = getExpire(db,&key);\n            if (rdbSaveKeyValuePair(rdb,&key,o,expire) == -1) goto werr;\n\n            /* When this RDB is produced as part of an AOF rewrite, move\n             * accumulated diff from parent to child while rewriting in\n             * order to have a smaller final write. */\n            if (rdbflags & RDBFLAGS_AOF_PREAMBLE &&\n                rdb->processed_bytes > processed+AOF_READ_DIFF_INTERVAL_BYTES)\n            {\n                processed = rdb->processed_bytes;\n                aofReadDiffFromParent();\n            }\n        }\n        dictReleaseIterator(di);\n        di = NULL; /* So that we don't release it again on error. */\n    }\n\n    /* If we are storing the replication information on disk, persist\n     * the script cache as well: on successful PSYNC after a restart, we need\n     * to be able to process any EVALSHA inside the replication backlog the\n     * master will send us. */\n    if (rsi && dictSize(server.lua_scripts)) {\n        di = dictGetIterator(server.lua_scripts);\n        while((de = dictNext(di)) != NULL) {\n            robj *body = dictGetVal(de);\n            if (rdbSaveAuxField(rdb,\"lua\",3,body->ptr,sdslen(body->ptr)) == -1)\n                goto werr;\n        }\n        dictReleaseIterator(di);\n        di = NULL; /* So that we don't release it again on error. */\n    }\n\n    if (rdbSaveModulesAux(rdb, REDISMODULE_AUX_AFTER_RDB) == -1) goto werr;\n\n    /* EOF opcode */\n    if (rdbSaveType(rdb,RDB_OPCODE_EOF) == -1) goto werr;\n\n    /* CRC64 checksum. It will be zero if checksum computation is disabled, the\n     * loading code skips the check in this case. */\n    cksum = rdb->cksum;\n    memrev64ifbe(&cksum);\n    if (rioWrite(rdb,&cksum,8) == 0) goto werr;\n    return C_OK;\n\nwerr:\n    if (error) *error = errno;\n    if (di) dictReleaseIterator(di);\n    return C_ERR;\n}\n\n/* This is just a wrapper to rdbSaveRio() that additionally adds a prefix\n * and a suffix to the generated RDB dump. The prefix is:\n *\n * $EOF:<40 bytes unguessable hex string>\\r\\n\n *\n * While the suffix is the 40 bytes hex string we announced in the prefix.\n * This way processes receiving the payload can understand when it ends\n * without doing any processing of the content. */\nint rdbSaveRioWithEOFMark(rio *rdb, int *error, rdbSaveInfo *rsi) {\n    char eofmark[RDB_EOF_MARK_SIZE];\n\n    startSaving(RDBFLAGS_REPLICATION);\n    getRandomHexChars(eofmark,RDB_EOF_MARK_SIZE);\n    if (error) *error = 0;\n    if (rioWrite(rdb,\"$EOF:\",5) == 0) goto werr;\n    if (rioWrite(rdb,eofmark,RDB_EOF_MARK_SIZE) == 0) goto werr;\n    if (rioWrite(rdb,\"\\r\\n\",2) == 0) goto werr;\n    if (rdbSaveRio(rdb,error,RDBFLAGS_NONE,rsi) == C_ERR) goto werr;\n    if (rioWrite(rdb,eofmark,RDB_EOF_MARK_SIZE) == 0) goto werr;\n    stopSaving(1);\n    return C_OK;\n\nwerr: /* Write error. */\n    /* Set 'error' only if not already set by rdbSaveRio() call. */\n    if (error && *error == 0) *error = errno;\n    stopSaving(0);\n    return C_ERR;\n}\n\n/* Save the DB on disk. Return C_ERR on error, C_OK on success. */\nint rdbSave(char *filename, rdbSaveInfo *rsi) {\n    char tmpfile[256];\n    char cwd[MAXPATHLEN]; /* Current working dir path for error messages. */\n    FILE *fp = NULL;\n    rio rdb;\n    int error = 0;\n\n    snprintf(tmpfile,256,\"temp-%d.rdb\", (int) getpid());\n    fp = fopen(tmpfile,\"w\");\n    if (!fp) {\n        char *cwdp = getcwd(cwd,MAXPATHLEN);\n        serverLog(LL_WARNING,\n            \"Failed opening the RDB file %s (in server root dir %s) \"\n            \"for saving: %s\",\n            filename,\n            cwdp ? cwdp : \"unknown\",\n            strerror(errno));\n        return C_ERR;\n    }\n\n    rioInitWithFile(&rdb,fp);\n    startSaving(RDBFLAGS_NONE);\n\n    if (server.rdb_save_incremental_fsync)\n        rioSetAutoSync(&rdb,REDIS_AUTOSYNC_BYTES);\n\n    if (rdbSaveRio(&rdb,&error,RDBFLAGS_NONE,rsi) == C_ERR) {\n        errno = error;\n        goto werr;\n    }\n\n    /* Make sure data will not remain on the OS's output buffers */\n    if (fflush(fp)) goto werr;\n    if (fsync(fileno(fp))) goto werr;\n    if (fclose(fp)) { fp = NULL; goto werr; }\n    fp = NULL;\n    \n    /* Use RENAME to make sure the DB file is changed atomically only\n     * if the generate DB file is ok. */\n    if (rename(tmpfile,filename) == -1) {\n        char *cwdp = getcwd(cwd,MAXPATHLEN);\n        serverLog(LL_WARNING,\n            \"Error moving temp DB file %s on the final \"\n            \"destination %s (in server root dir %s): %s\",\n            tmpfile,\n            filename,\n            cwdp ? cwdp : \"unknown\",\n            strerror(errno));\n        unlink(tmpfile);\n        stopSaving(0);\n        return C_ERR;\n    }\n\n    serverLog(LL_NOTICE,\"DB saved on disk\");\n    server.dirty = 0;\n    server.lastsave = time(NULL);\n    server.lastbgsave_status = C_OK;\n    stopSaving(1);\n    return C_OK;\n\nwerr:\n    serverLog(LL_WARNING,\"Write error saving DB on disk: %s\", strerror(errno));\n    if (fp) fclose(fp);\n    unlink(tmpfile);\n    stopSaving(0);\n    return C_ERR;\n}\n\nint rdbSaveBackground(char *filename, rdbSaveInfo *rsi) {\n    pid_t childpid;\n\n    if (hasActiveChildProcess()) return C_ERR;\n\n    server.dirty_before_bgsave = server.dirty;\n    server.lastbgsave_try = time(NULL);\n    openChildInfoPipe();\n\n    if ((childpid = redisFork(CHILD_TYPE_RDB)) == 0) {\n        int retval;\n\n        /* Child */\n        redisSetProcTitle(\"redis-rdb-bgsave\");\n        redisSetCpuAffinity(server.bgsave_cpulist);\n        retval = rdbSave(filename,rsi);\n        if (retval == C_OK) {\n            sendChildCOWInfo(CHILD_TYPE_RDB, \"RDB\");\n        }\n        exitFromChild((retval == C_OK) ? 0 : 1);\n    } else {\n        /* Parent */\n        if (childpid == -1) {\n            closeChildInfoPipe();\n            server.lastbgsave_status = C_ERR;\n            serverLog(LL_WARNING,\"Can't save in background: fork: %s\",\n                strerror(errno));\n            return C_ERR;\n        }\n        serverLog(LL_NOTICE,\"Background saving started by pid %d\",childpid);\n        server.rdb_save_time_start = time(NULL);\n        server.rdb_child_pid = childpid;\n        server.rdb_child_type = RDB_CHILD_TYPE_DISK;\n        updateDictResizePolicy();\n        return C_OK;\n    }\n    return C_OK; /* unreached */\n}\n\n/* Note that we may call this function in signal handle 'sigShutdownHandler',\n * so we need guarantee all functions we call are async-signal-safe.\n * If  we call this function from signal handle, we won't call bg_unlik that\n * is not async-signal-safe. */\nvoid rdbRemoveTempFile(pid_t childpid, int from_signal) {\n    char tmpfile[256];\n    char pid[32];\n\n    /* Generate temp rdb file name using aync-signal safe functions. */\n    int pid_len = ll2string(pid, sizeof(pid), childpid);\n    strcpy(tmpfile, \"temp-\");\n    strncpy(tmpfile+5, pid, pid_len);\n    strcpy(tmpfile+5+pid_len, \".rdb\");\n\n    if (from_signal) {\n        /* bg_unlink is not async-signal-safe, but in this case we don't really\n         * need to close the fd, it'll be released when the process exists. */\n        int fd = open(tmpfile, O_RDONLY|O_NONBLOCK);\n        UNUSED(fd);\n        unlink(tmpfile);\n    } else {\n        bg_unlink(tmpfile);\n    }\n}\n\n/* This function is called by rdbLoadObject() when the code is in RDB-check\n * mode and we find a module value of type 2 that can be parsed without\n * the need of the actual module. The value is parsed for errors, finally\n * a dummy redis object is returned just to conform to the API. */\nrobj *rdbLoadCheckModuleValue(rio *rdb, char *modulename) {\n    uint64_t opcode;\n    while((opcode = rdbLoadLen(rdb,NULL)) != RDB_MODULE_OPCODE_EOF) {\n        if (opcode == RDB_MODULE_OPCODE_SINT ||\n            opcode == RDB_MODULE_OPCODE_UINT)\n        {\n            uint64_t len;\n            if (rdbLoadLenByRef(rdb,NULL,&len) == -1) {\n                rdbExitReportCorruptRDB(\n                    \"Error reading integer from module %s value\", modulename);\n            }\n        } else if (opcode == RDB_MODULE_OPCODE_STRING) {\n            robj *o = rdbGenericLoadStringObject(rdb,RDB_LOAD_NONE,NULL);\n            if (o == NULL) {\n                rdbExitReportCorruptRDB(\n                    \"Error reading string from module %s value\", modulename);\n            }\n            decrRefCount(o);\n        } else if (opcode == RDB_MODULE_OPCODE_FLOAT) {\n            float val;\n            if (rdbLoadBinaryFloatValue(rdb,&val) == -1) {\n                rdbExitReportCorruptRDB(\n                    \"Error reading float from module %s value\", modulename);\n            }\n        } else if (opcode == RDB_MODULE_OPCODE_DOUBLE) {\n            double val;\n            if (rdbLoadBinaryDoubleValue(rdb,&val) == -1) {\n                rdbExitReportCorruptRDB(\n                    \"Error reading double from module %s value\", modulename);\n            }\n        }\n    }\n    return createStringObject(\"module-dummy-value\",18);\n}\n\n/* Load a Redis object of the specified type from the specified file.\n * On success a newly allocated object is returned, otherwise NULL. */\nrobj *rdbLoadObject(int rdbtype, rio *rdb, sds key) {\n    robj *o = NULL, *ele, *dec;\n    uint64_t len;\n    unsigned int i;\n\n    if (rdbtype == RDB_TYPE_STRING) {\n        /* Read string value */\n        if ((o = rdbLoadEncodedStringObject(rdb)) == NULL) return NULL;\n        o = tryObjectEncoding(o);\n    } else if (rdbtype == RDB_TYPE_LIST) {\n        /* Read list value */\n        if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;\n\n        o = createQuicklistObject();\n        quicklistSetOptions(o->ptr, server.list_max_ziplist_size,\n                            server.list_compress_depth);\n\n        /* Load every single element of the list */\n        while(len--) {\n            if ((ele = rdbLoadEncodedStringObject(rdb)) == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n            dec = getDecodedObject(ele);\n            size_t len = sdslen(dec->ptr);\n            quicklistPushTail(o->ptr, dec->ptr, len);\n            decrRefCount(dec);\n            decrRefCount(ele);\n        }\n    } else if (rdbtype == RDB_TYPE_SET) {\n        /* Read Set value */\n        if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;\n\n        /* Use a regular set when there are too many entries. */\n        if (len > server.set_max_intset_entries) {\n            o = createSetObject();\n            /* It's faster to expand the dict to the right size asap in order\n             * to avoid rehashing */\n            if (len > DICT_HT_INITIAL_SIZE)\n                dictExpand(o->ptr,len);\n        } else {\n            o = createIntsetObject();\n        }\n\n        /* Load every single element of the set */\n        for (i = 0; i < len; i++) {\n            long long llval;\n            sds sdsele;\n\n            if ((sdsele = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n\n            if (o->encoding == OBJ_ENCODING_INTSET) {\n                /* Fetch integer value from element. */\n                if (isSdsRepresentableAsLongLong(sdsele,&llval) == C_OK) {\n                    o->ptr = intsetAdd(o->ptr,llval,NULL);\n                } else {\n                    setTypeConvert(o,OBJ_ENCODING_HT);\n                    dictExpand(o->ptr,len);\n                }\n            }\n\n            /* This will also be called when the set was just converted\n             * to a regular hash table encoded set. */\n            if (o->encoding == OBJ_ENCODING_HT) {\n                dictAdd((dict*)o->ptr,sdsele,NULL);\n            } else {\n                sdsfree(sdsele);\n            }\n        }\n    } else if (rdbtype == RDB_TYPE_ZSET_2 || rdbtype == RDB_TYPE_ZSET) {\n        /* Read list/set value. */\n        uint64_t zsetlen;\n        size_t maxelelen = 0;\n        zset *zs;\n\n        if ((zsetlen = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;\n        o = createZsetObject();\n        zs = o->ptr;\n\n        if (zsetlen > DICT_HT_INITIAL_SIZE)\n            dictExpand(zs->dict,zsetlen);\n\n        /* Load every single element of the sorted set. */\n        while(zsetlen--) {\n            sds sdsele;\n            double score;\n            zskiplistNode *znode;\n\n            if ((sdsele = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n\n            if (rdbtype == RDB_TYPE_ZSET_2) {\n                if (rdbLoadBinaryDoubleValue(rdb,&score) == -1) {\n                    decrRefCount(o);\n                    sdsfree(sdsele);\n                    return NULL;\n                }\n            } else {\n                if (rdbLoadDoubleValue(rdb,&score) == -1) {\n                    decrRefCount(o);\n                    sdsfree(sdsele);\n                    return NULL;\n                }\n            }\n\n            /* Don't care about integer-encoded strings. */\n            if (sdslen(sdsele) > maxelelen) maxelelen = sdslen(sdsele);\n\n            znode = zslInsert(zs->zsl,score,sdsele);\n            dictAdd(zs->dict,sdsele,&znode->score);\n        }\n\n        /* Convert *after* loading, since sorted sets are not stored ordered. */\n        if (zsetLength(o) <= server.zset_max_ziplist_entries &&\n            maxelelen <= server.zset_max_ziplist_value)\n                zsetConvert(o,OBJ_ENCODING_ZIPLIST);\n    } else if (rdbtype == RDB_TYPE_HASH) {\n        uint64_t len;\n        int ret;\n        sds field, value;\n\n        len = rdbLoadLen(rdb, NULL);\n        if (len == RDB_LENERR) return NULL;\n\n        o = createHashObject();\n\n        /* Too many entries? Use a hash table. */\n        if (len > server.hash_max_ziplist_entries)\n            hashTypeConvert(o, OBJ_ENCODING_HT);\n\n        /* Load every field and value into the ziplist */\n        while (o->encoding == OBJ_ENCODING_ZIPLIST && len > 0) {\n            len--;\n            /* Load raw strings */\n            if ((field = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n            if ((value = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                sdsfree(field);\n                decrRefCount(o);\n                return NULL;\n            }\n\n            /* Add pair to ziplist */\n            o->ptr = ziplistPush(o->ptr, (unsigned char*)field,\n                    sdslen(field), ZIPLIST_TAIL);\n            o->ptr = ziplistPush(o->ptr, (unsigned char*)value,\n                    sdslen(value), ZIPLIST_TAIL);\n\n            /* Convert to hash table if size threshold is exceeded */\n            if (sdslen(field) > server.hash_max_ziplist_value ||\n                sdslen(value) > server.hash_max_ziplist_value)\n            {\n                sdsfree(field);\n                sdsfree(value);\n                hashTypeConvert(o, OBJ_ENCODING_HT);\n                break;\n            }\n            sdsfree(field);\n            sdsfree(value);\n        }\n\n        if (o->encoding == OBJ_ENCODING_HT && len > DICT_HT_INITIAL_SIZE)\n            dictExpand(o->ptr,len);\n\n        /* Load remaining fields and values into the hash table */\n        while (o->encoding == OBJ_ENCODING_HT && len > 0) {\n            len--;\n            /* Load encoded strings */\n            if ((field = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n            if ((value = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                sdsfree(field);\n                decrRefCount(o);\n                return NULL;\n            }\n\n            /* Add pair to hash table */\n            ret = dictAdd((dict*)o->ptr, field, value);\n            if (ret == DICT_ERR) {\n                rdbExitReportCorruptRDB(\"Duplicate keys detected\");\n            }\n        }\n\n        /* All pairs should be read by now */\n        serverAssert(len == 0);\n    } else if (rdbtype == RDB_TYPE_LIST_QUICKLIST) {\n        if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;\n        o = createQuicklistObject();\n        quicklistSetOptions(o->ptr, server.list_max_ziplist_size,\n                            server.list_compress_depth);\n\n        while (len--) {\n            unsigned char *zl =\n                rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN,NULL);\n            if (zl == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n            quicklistAppendZiplist(o->ptr, zl);\n        }\n    } else if (rdbtype == RDB_TYPE_HASH_ZIPMAP  ||\n               rdbtype == RDB_TYPE_LIST_ZIPLIST ||\n               rdbtype == RDB_TYPE_SET_INTSET   ||\n               rdbtype == RDB_TYPE_ZSET_ZIPLIST ||\n               rdbtype == RDB_TYPE_HASH_ZIPLIST)\n    {\n        unsigned char *encoded =\n            rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN,NULL);\n        if (encoded == NULL) return NULL;\n        o = createObject(OBJ_STRING,encoded); /* Obj type fixed below. */\n\n        /* Fix the object encoding, and make sure to convert the encoded\n         * data type into the base type if accordingly to the current\n         * configuration there are too many elements in the encoded data\n         * type. Note that we only check the length and not max element\n         * size as this is an O(N) scan. Eventually everything will get\n         * converted. */\n        switch(rdbtype) {\n            case RDB_TYPE_HASH_ZIPMAP:\n                /* Convert to ziplist encoded hash. This must be deprecated\n                 * when loading dumps created by Redis 2.4 gets deprecated. */\n                {\n                    unsigned char *zl = ziplistNew();\n                    unsigned char *zi = zipmapRewind(o->ptr);\n                    unsigned char *fstr, *vstr;\n                    unsigned int flen, vlen;\n                    unsigned int maxlen = 0;\n\n                    while ((zi = zipmapNext(zi, &fstr, &flen, &vstr, &vlen)) != NULL) {\n                        if (flen > maxlen) maxlen = flen;\n                        if (vlen > maxlen) maxlen = vlen;\n                        zl = ziplistPush(zl, fstr, flen, ZIPLIST_TAIL);\n                        zl = ziplistPush(zl, vstr, vlen, ZIPLIST_TAIL);\n                    }\n\n                    zfree(o->ptr);\n                    o->ptr = zl;\n                    o->type = OBJ_HASH;\n                    o->encoding = OBJ_ENCODING_ZIPLIST;\n\n                    if (hashTypeLength(o) > server.hash_max_ziplist_entries ||\n                        maxlen > server.hash_max_ziplist_value)\n                    {\n                        hashTypeConvert(o, OBJ_ENCODING_HT);\n                    }\n                }\n                break;\n            case RDB_TYPE_LIST_ZIPLIST:\n                o->type = OBJ_LIST;\n                o->encoding = OBJ_ENCODING_ZIPLIST;\n                listTypeConvert(o,OBJ_ENCODING_QUICKLIST);\n                break;\n            case RDB_TYPE_SET_INTSET:\n                o->type = OBJ_SET;\n                o->encoding = OBJ_ENCODING_INTSET;\n                if (intsetLen(o->ptr) > server.set_max_intset_entries)\n                    setTypeConvert(o,OBJ_ENCODING_HT);\n                break;\n            case RDB_TYPE_ZSET_ZIPLIST:\n                o->type = OBJ_ZSET;\n                o->encoding = OBJ_ENCODING_ZIPLIST;\n                if (zsetLength(o) > server.zset_max_ziplist_entries)\n                    zsetConvert(o,OBJ_ENCODING_SKIPLIST);\n                break;\n            case RDB_TYPE_HASH_ZIPLIST:\n                o->type = OBJ_HASH;\n                o->encoding = OBJ_ENCODING_ZIPLIST;\n                if (hashTypeLength(o) > server.hash_max_ziplist_entries)\n                    hashTypeConvert(o, OBJ_ENCODING_HT);\n                break;\n            default:\n                /* totally unreachable */\n                rdbExitReportCorruptRDB(\"Unknown RDB encoding type %d\",rdbtype);\n                break;\n        }\n    } else if (rdbtype == RDB_TYPE_STREAM_LISTPACKS) {\n        o = createStreamObject();\n        stream *s = o->ptr;\n        uint64_t listpacks = rdbLoadLen(rdb,NULL);\n        if (listpacks == RDB_LENERR) {\n            rdbReportReadError(\"Stream listpacks len loading failed.\");\n            decrRefCount(o);\n            return NULL;\n        }\n\n        while(listpacks--) {\n            /* Get the master ID, the one we'll use as key of the radix tree\n             * node: the entries inside the listpack itself are delta-encoded\n             * relatively to this ID. */\n            sds nodekey = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL);\n            if (nodekey == NULL) {\n                rdbReportReadError(\"Stream master ID loading failed: invalid encoding or I/O error.\");\n                decrRefCount(o);\n                return NULL;\n            }\n            if (sdslen(nodekey) != sizeof(streamID)) {\n                rdbExitReportCorruptRDB(\"Stream node key entry is not the \"\n                                        \"size of a stream ID\");\n            }\n\n            /* Load the listpack. */\n            unsigned char *lp =\n                rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN,NULL);\n            if (lp == NULL) {\n                rdbReportReadError(\"Stream listpacks loading failed.\");\n                sdsfree(nodekey);\n                decrRefCount(o);\n                return NULL;\n            }\n            unsigned char *first = lpFirst(lp);\n            if (first == NULL) {\n                /* Serialized listpacks should never be empty, since on\n                 * deletion we should remove the radix tree key if the\n                 * resulting listpack is empty. */\n                rdbExitReportCorruptRDB(\"Empty listpack inside stream\");\n            }\n\n            /* Insert the key in the radix tree. */\n            int retval = raxInsert(s->rax,\n                (unsigned char*)nodekey,sizeof(streamID),lp,NULL);\n            sdsfree(nodekey);\n            if (!retval)\n                rdbExitReportCorruptRDB(\"Listpack re-added with existing key\");\n        }\n        /* Load total number of items inside the stream. */\n        s->length = rdbLoadLen(rdb,NULL);\n\n        /* Load the last entry ID. */\n        s->last_id.ms = rdbLoadLen(rdb,NULL);\n        s->last_id.seq = rdbLoadLen(rdb,NULL);\n\n        if (rioGetReadError(rdb)) {\n            rdbReportReadError(\"Stream object metadata loading failed.\");\n            decrRefCount(o);\n            return NULL;\n        }\n\n        /* Consumer groups loading */\n        uint64_t cgroups_count = rdbLoadLen(rdb,NULL);\n        if (cgroups_count == RDB_LENERR) {\n            rdbReportReadError(\"Stream cgroup count loading failed.\");\n            decrRefCount(o);\n            return NULL;\n        }\n        while(cgroups_count--) {\n            /* Get the consumer group name and ID. We can then create the\n             * consumer group ASAP and populate its structure as\n             * we read more data. */\n            streamID cg_id;\n            sds cgname = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL);\n            if (cgname == NULL) {\n                rdbReportReadError(\n                    \"Error reading the consumer group name from Stream\");\n                decrRefCount(o);\n                return NULL;\n            }\n\n            cg_id.ms = rdbLoadLen(rdb,NULL);\n            cg_id.seq = rdbLoadLen(rdb,NULL);\n            if (rioGetReadError(rdb)) {\n                rdbReportReadError(\"Stream cgroup ID loading failed.\");\n                sdsfree(cgname);\n                decrRefCount(o);\n                return NULL;\n            }\n\n            streamCG *cgroup = streamCreateCG(s,cgname,sdslen(cgname),&cg_id);\n            if (cgroup == NULL)\n                rdbExitReportCorruptRDB(\"Duplicated consumer group name %s\",\n                                         cgname);\n            sdsfree(cgname);\n\n            /* Load the global PEL for this consumer group, however we'll\n             * not yet populate the NACK structures with the message\n             * owner, since consumers for this group and their messages will\n             * be read as a next step. So for now leave them not resolved\n             * and later populate it. */\n            uint64_t pel_size = rdbLoadLen(rdb,NULL);\n            if (pel_size == RDB_LENERR) {\n                rdbReportReadError(\"Stream PEL size loading failed.\");\n                decrRefCount(o);\n                return NULL;\n            }\n            while(pel_size--) {\n                unsigned char rawid[sizeof(streamID)];\n                if (rioRead(rdb,rawid,sizeof(rawid)) == 0) {\n                    rdbReportReadError(\"Stream PEL ID loading failed.\");\n                    decrRefCount(o);\n                    return NULL;\n                }\n                streamNACK *nack = streamCreateNACK(NULL);\n                nack->delivery_time = rdbLoadMillisecondTime(rdb,RDB_VERSION);\n                nack->delivery_count = rdbLoadLen(rdb,NULL);\n                if (rioGetReadError(rdb)) {\n                    rdbReportReadError(\"Stream PEL NACK loading failed.\");\n                    decrRefCount(o);\n                    streamFreeNACK(nack);\n                    return NULL;\n                }\n                if (!raxInsert(cgroup->pel,rawid,sizeof(rawid),nack,NULL))\n                    rdbExitReportCorruptRDB(\"Duplicated gobal PEL entry \"\n                                            \"loading stream consumer group\");\n            }\n\n            /* Now that we loaded our global PEL, we need to load the\n             * consumers and their local PELs. */\n            uint64_t consumers_num = rdbLoadLen(rdb,NULL);\n            if (consumers_num == RDB_LENERR) {\n                rdbReportReadError(\"Stream consumers num loading failed.\");\n                decrRefCount(o);\n                return NULL;\n            }\n            while(consumers_num--) {\n                sds cname = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL);\n                if (cname == NULL) {\n                    rdbReportReadError(\n                        \"Error reading the consumer name from Stream group.\");\n                    decrRefCount(o);\n                    return NULL;\n                }\n                streamConsumer *consumer =\n                    streamLookupConsumer(cgroup,cname,SLC_NONE);\n                sdsfree(cname);\n                consumer->seen_time = rdbLoadMillisecondTime(rdb,RDB_VERSION);\n                if (rioGetReadError(rdb)) {\n                    rdbReportReadError(\"Stream short read reading seen time.\");\n                    decrRefCount(o);\n                    return NULL;\n                }\n\n                /* Load the PEL about entries owned by this specific\n                 * consumer. */\n                pel_size = rdbLoadLen(rdb,NULL);\n                if (pel_size == RDB_LENERR) {\n                    rdbReportReadError(\n                        \"Stream consumer PEL num loading failed.\");\n                    decrRefCount(o);\n                    return NULL;\n                }\n                while(pel_size--) {\n                    unsigned char rawid[sizeof(streamID)];\n                    if (rioRead(rdb,rawid,sizeof(rawid)) == 0) {\n                        rdbReportReadError(\n                            \"Stream short read reading PEL streamID.\");\n                        decrRefCount(o);\n                        return NULL;\n                    }\n                    streamNACK *nack = raxFind(cgroup->pel,rawid,sizeof(rawid));\n                    if (nack == raxNotFound)\n                        rdbExitReportCorruptRDB(\"Consumer entry not found in \"\n                                                \"group global PEL\");\n\n                    /* Set the NACK consumer, that was left to NULL when\n                     * loading the global PEL. Then set the same shared\n                     * NACK structure also in the consumer-specific PEL. */\n                    nack->consumer = consumer;\n                    if (!raxInsert(consumer->pel,rawid,sizeof(rawid),nack,NULL))\n                        rdbExitReportCorruptRDB(\"Duplicated consumer PEL entry \"\n                                                \" loading a stream consumer \"\n                                                \"group\");\n                }\n            }\n        }\n    } else if (rdbtype == RDB_TYPE_MODULE || rdbtype == RDB_TYPE_MODULE_2) {\n        uint64_t moduleid = rdbLoadLen(rdb,NULL);\n        if (rioGetReadError(rdb)) {\n            rdbReportReadError(\"Short read module id\");\n            return NULL;\n        }\n        moduleType *mt = moduleTypeLookupModuleByID(moduleid);\n        char name[10];\n\n        if (rdbCheckMode && rdbtype == RDB_TYPE_MODULE_2) {\n            moduleTypeNameByID(name,moduleid);\n            return rdbLoadCheckModuleValue(rdb,name);\n        }\n\n        if (mt == NULL) {\n            moduleTypeNameByID(name,moduleid);\n            serverLog(LL_WARNING,\"The RDB file contains module data I can't load: no matching module '%s'\", name);\n            exit(1);\n        }\n        RedisModuleIO io;\n        robj keyobj;\n        initStaticStringObject(keyobj,key);\n        moduleInitIOContext(io,mt,rdb,&keyobj);\n        io.ver = (rdbtype == RDB_TYPE_MODULE) ? 1 : 2;\n        /* Call the rdb_load method of the module providing the 10 bit\n         * encoding version in the lower 10 bits of the module ID. */\n        void *ptr = mt->rdb_load(&io,moduleid&1023);\n        if (io.ctx) {\n            moduleFreeContext(io.ctx);\n            zfree(io.ctx);\n        }\n\n        /* Module v2 serialization has an EOF mark at the end. */\n        if (io.ver == 2) {\n            uint64_t eof = rdbLoadLen(rdb,NULL);\n            if (eof == RDB_LENERR) {\n                o = createModuleObject(mt,ptr); /* creating just in order to easily destroy */\n                decrRefCount(o);\n                return NULL;\n            }\n            if (eof != RDB_MODULE_OPCODE_EOF) {\n                serverLog(LL_WARNING,\"The RDB file contains module data for the module '%s' that is not terminated by the proper module value EOF marker\", name);\n                exit(1);\n            }\n        }\n\n        if (ptr == NULL) {\n            moduleTypeNameByID(name,moduleid);\n            serverLog(LL_WARNING,\"The RDB file contains module data for the module type '%s', that the responsible module is not able to load. Check for modules log above for additional clues.\", name);\n            exit(1);\n        }\n        o = createModuleObject(mt,ptr);\n    } else {\n        rdbReportReadError(\"Unknown RDB encoding type %d\",rdbtype);\n        return NULL;\n    }\n    return o;\n}\n\n/* Mark that we are loading in the global state and setup the fields\n * needed to provide loading stats. */\nvoid startLoading(size_t size, int rdbflags) {\n    /* Load the DB */\n    server.loading = 1;\n    server.loading_start_time = time(NULL);\n    server.loading_loaded_bytes = 0;\n    server.loading_total_bytes = size;\n\n    /* Fire the loading modules start event. */\n    int subevent;\n    if (rdbflags & RDBFLAGS_AOF_PREAMBLE)\n        subevent = REDISMODULE_SUBEVENT_LOADING_AOF_START;\n    else if(rdbflags & RDBFLAGS_REPLICATION)\n        subevent = REDISMODULE_SUBEVENT_LOADING_REPL_START;\n    else\n        subevent = REDISMODULE_SUBEVENT_LOADING_RDB_START;\n    moduleFireServerEvent(REDISMODULE_EVENT_LOADING,subevent,NULL);\n}\n\n/* Mark that we are loading in the global state and setup the fields\n * needed to provide loading stats.\n * 'filename' is optional and used for rdb-check on error */\nvoid startLoadingFile(FILE *fp, char* filename, int rdbflags) {\n    struct stat sb;\n    if (fstat(fileno(fp), &sb) == -1)\n        sb.st_size = 0;\n    rdbFileBeingLoaded = filename;\n    startLoading(sb.st_size, rdbflags);\n}\n\n/* Refresh the loading progress info */\nvoid loadingProgress(off_t pos) {\n    server.loading_loaded_bytes = pos;\n    if (server.stat_peak_memory < zmalloc_used_memory())\n        server.stat_peak_memory = zmalloc_used_memory();\n}\n\n/* Loading finished */\nvoid stopLoading(int success) {\n    server.loading = 0;\n    rdbFileBeingLoaded = NULL;\n\n    /* Fire the loading modules end event. */\n    moduleFireServerEvent(REDISMODULE_EVENT_LOADING,\n                          success?\n                            REDISMODULE_SUBEVENT_LOADING_ENDED:\n                            REDISMODULE_SUBEVENT_LOADING_FAILED,\n                          NULL);\n}\n\nvoid startSaving(int rdbflags) {\n    /* Fire the persistence modules end event. */\n    int subevent;\n    if (rdbflags & RDBFLAGS_AOF_PREAMBLE)\n        subevent = REDISMODULE_SUBEVENT_PERSISTENCE_AOF_START;\n    else if (getpid()!=server.pid)\n        subevent = REDISMODULE_SUBEVENT_PERSISTENCE_RDB_START;\n    else\n        subevent = REDISMODULE_SUBEVENT_PERSISTENCE_SYNC_RDB_START;\n    moduleFireServerEvent(REDISMODULE_EVENT_PERSISTENCE,subevent,NULL);\n}\n\nvoid stopSaving(int success) {\n    /* Fire the persistence modules end event. */\n    moduleFireServerEvent(REDISMODULE_EVENT_PERSISTENCE,\n                          success?\n                            REDISMODULE_SUBEVENT_PERSISTENCE_ENDED:\n                            REDISMODULE_SUBEVENT_PERSISTENCE_FAILED,\n                          NULL);\n}\n\n/* Track loading progress in order to serve client's from time to time\n   and if needed calculate rdb checksum  */\nvoid rdbLoadProgressCallback(rio *r, const void *buf, size_t len) {\n    if (server.rdb_checksum)\n        rioGenericUpdateChecksum(r, buf, len);\n    if (server.loading_process_events_interval_bytes &&\n        (r->processed_bytes + len)/server.loading_process_events_interval_bytes > r->processed_bytes/server.loading_process_events_interval_bytes)\n    {\n        /* The DB can take some non trivial amount of time to load. Update\n         * our cached time since it is used to create and update the last\n         * interaction time with clients and for other important things. */\n        updateCachedTime(0);\n        if (server.masterhost && server.repl_state == REPL_STATE_TRANSFER)\n            replicationSendNewlineToMaster();\n        loadingProgress(r->processed_bytes);\n        processEventsWhileBlocked();\n        processModuleLoadingProgressEvent(0);\n    }\n}\n\n/* Load an RDB file from the rio stream 'rdb'. On success C_OK is returned,\n * otherwise C_ERR is returned and 'errno' is set accordingly. */\nint rdbLoadRio(rio *rdb, int rdbflags, rdbSaveInfo *rsi) {\n    uint64_t dbid;\n    int type, rdbver;\n    redisDb *db = server.db+0;\n    char buf[1024];\n\n    rdb->update_cksum = rdbLoadProgressCallback;\n    rdb->max_processing_chunk = server.loading_process_events_interval_bytes;\n    if (rioRead(rdb,buf,9) == 0) goto eoferr;\n    buf[9] = '\\0';\n    if (memcmp(buf,\"REDIS\",5) != 0) {\n        serverLog(LL_WARNING,\"Wrong signature trying to load DB from file\");\n        errno = EINVAL;\n        return C_ERR;\n    }\n    rdbver = atoi(buf+5);\n    if (rdbver < 1 || rdbver > RDB_VERSION) {\n        serverLog(LL_WARNING,\"Can't handle RDB format version %d\",rdbver);\n        errno = EINVAL;\n        return C_ERR;\n    }\n\n    /* Key-specific attributes, set by opcodes before the key type. */\n    long long lru_idle = -1, lfu_freq = -1, expiretime = -1, now = mstime();\n    long long lru_clock = LRU_CLOCK();\n\n    while(1) {\n        sds key;\n        robj *val;\n\n        /* Read type. */\n        if ((type = rdbLoadType(rdb)) == -1) goto eoferr;\n\n        /* Handle special types. */\n        if (type == RDB_OPCODE_EXPIRETIME) {\n            /* EXPIRETIME: load an expire associated with the next key\n             * to load. Note that after loading an expire we need to\n             * load the actual type, and continue. */\n            expiretime = rdbLoadTime(rdb);\n            expiretime *= 1000;\n            if (rioGetReadError(rdb)) goto eoferr;\n            continue; /* Read next opcode. */\n        } else if (type == RDB_OPCODE_EXPIRETIME_MS) {\n            /* EXPIRETIME_MS: milliseconds precision expire times introduced\n             * with RDB v3. Like EXPIRETIME but no with more precision. */\n            expiretime = rdbLoadMillisecondTime(rdb,rdbver);\n            if (rioGetReadError(rdb)) goto eoferr;\n            continue; /* Read next opcode. */\n        } else if (type == RDB_OPCODE_FREQ) {\n            /* FREQ: LFU frequency. */\n            uint8_t byte;\n            if (rioRead(rdb,&byte,1) == 0) goto eoferr;\n            lfu_freq = byte;\n            continue; /* Read next opcode. */\n        } else if (type == RDB_OPCODE_IDLE) {\n            /* IDLE: LRU idle time. */\n            uint64_t qword;\n            if ((qword = rdbLoadLen(rdb,NULL)) == RDB_LENERR) goto eoferr;\n            lru_idle = qword;\n            continue; /* Read next opcode. */\n        } else if (type == RDB_OPCODE_EOF) {\n            /* EOF: End of file, exit the main loop. */\n            break;\n        } else if (type == RDB_OPCODE_SELECTDB) {\n            /* SELECTDB: Select the specified database. */\n            if ((dbid = rdbLoadLen(rdb,NULL)) == RDB_LENERR) goto eoferr;\n            if (dbid >= (unsigned)server.dbnum) {\n                serverLog(LL_WARNING,\n                    \"FATAL: Data file was created with a Redis \"\n                    \"server configured to handle more than %d \"\n                    \"databases. Exiting\\n\", server.dbnum);\n                exit(1);\n            }\n            db = server.db+dbid;\n            continue; /* Read next opcode. */\n        } else if (type == RDB_OPCODE_RESIZEDB) {\n            /* RESIZEDB: Hint about the size of the keys in the currently\n             * selected data base, in order to avoid useless rehashing. */\n            uint64_t db_size, expires_size;\n            if ((db_size = rdbLoadLen(rdb,NULL)) == RDB_LENERR)\n                goto eoferr;\n            if ((expires_size = rdbLoadLen(rdb,NULL)) == RDB_LENERR)\n                goto eoferr;\n            dictExpand(db->dict,db_size);\n            dictExpand(db->expires,expires_size);\n            continue; /* Read next opcode. */\n        } else if (type == RDB_OPCODE_AUX) {\n            /* AUX: generic string-string fields. Use to add state to RDB\n             * which is backward compatible. Implementations of RDB loading\n             * are required to skip AUX fields they don't understand.\n             *\n             * An AUX field is composed of two strings: key and value. */\n            robj *auxkey, *auxval;\n            if ((auxkey = rdbLoadStringObject(rdb)) == NULL) goto eoferr;\n            if ((auxval = rdbLoadStringObject(rdb)) == NULL) goto eoferr;\n\n            if (((char*)auxkey->ptr)[0] == '%') {\n                /* All the fields with a name staring with '%' are considered\n                 * information fields and are logged at startup with a log\n                 * level of NOTICE. */\n                serverLog(LL_NOTICE,\"RDB '%s': %s\",\n                    (char*)auxkey->ptr,\n                    (char*)auxval->ptr);\n            } else if (!strcasecmp(auxkey->ptr,\"repl-stream-db\")) {\n                if (rsi) rsi->repl_stream_db = atoi(auxval->ptr);\n            } else if (!strcasecmp(auxkey->ptr,\"repl-id\")) {\n                if (rsi && sdslen(auxval->ptr) == CONFIG_RUN_ID_SIZE) {\n                    memcpy(rsi->repl_id,auxval->ptr,CONFIG_RUN_ID_SIZE+1);\n                    rsi->repl_id_is_set = 1;\n                }\n            } else if (!strcasecmp(auxkey->ptr,\"repl-offset\")) {\n                if (rsi) rsi->repl_offset = strtoll(auxval->ptr,NULL,10);\n            } else if (!strcasecmp(auxkey->ptr,\"lua\")) {\n                /* Load the script back in memory. */\n                if (luaCreateFunction(NULL,server.lua,auxval) == NULL) {\n                    rdbExitReportCorruptRDB(\n                        \"Can't load Lua script from RDB file! \"\n                        \"BODY: %s\", (char*)auxval->ptr);\n                }\n            } else if (!strcasecmp(auxkey->ptr,\"redis-ver\")) {\n                serverLog(LL_NOTICE,\"Loading RDB produced by version %s\",\n                    (char*)auxval->ptr);\n            } else if (!strcasecmp(auxkey->ptr,\"ctime\")) {\n                time_t age = time(NULL)-strtol(auxval->ptr,NULL,10);\n                if (age < 0) age = 0;\n                serverLog(LL_NOTICE,\"RDB age %ld seconds\",\n                    (unsigned long) age);\n            } else if (!strcasecmp(auxkey->ptr,\"used-mem\")) {\n                long long usedmem = strtoll(auxval->ptr,NULL,10);\n                serverLog(LL_NOTICE,\"RDB memory usage when created %.2f Mb\",\n                    (double) usedmem / (1024*1024));\n            } else if (!strcasecmp(auxkey->ptr,\"aof-preamble\")) {\n                long long haspreamble = strtoll(auxval->ptr,NULL,10);\n                if (haspreamble) serverLog(LL_NOTICE,\"RDB has an AOF tail\");\n            } else if (!strcasecmp(auxkey->ptr,\"redis-bits\")) {\n                /* Just ignored. */\n            } else {\n                /* We ignore fields we don't understand, as by AUX field\n                 * contract. */\n                serverLog(LL_DEBUG,\"Unrecognized RDB AUX field: '%s'\",\n                    (char*)auxkey->ptr);\n            }\n\n            decrRefCount(auxkey);\n            decrRefCount(auxval);\n            continue; /* Read type again. */\n        } else if (type == RDB_OPCODE_MODULE_AUX) {\n            /* Load module data that is not related to the Redis key space.\n             * Such data can be potentially be stored both before and after the\n             * RDB keys-values section. */\n            uint64_t moduleid = rdbLoadLen(rdb,NULL);\n            int when_opcode = rdbLoadLen(rdb,NULL);\n            int when = rdbLoadLen(rdb,NULL);\n            if (rioGetReadError(rdb)) goto eoferr;\n            if (when_opcode != RDB_MODULE_OPCODE_UINT) {\n                rdbReportReadError(\"bad when_opcode\");\n                goto eoferr;\n            }\n            moduleType *mt = moduleTypeLookupModuleByID(moduleid);\n            char name[10];\n            moduleTypeNameByID(name,moduleid);\n\n            if (!rdbCheckMode && mt == NULL) {\n                /* Unknown module. */\n                serverLog(LL_WARNING,\"The RDB file contains AUX module data I can't load: no matching module '%s'\", name);\n                exit(1);\n            } else if (!rdbCheckMode && mt != NULL) {\n                if (!mt->aux_load) {\n                    /* Module doesn't support AUX. */\n                    serverLog(LL_WARNING,\"The RDB file contains module AUX data, but the module '%s' doesn't seem to support it.\", name);\n                    exit(1);\n                }\n\n                RedisModuleIO io;\n                moduleInitIOContext(io,mt,rdb,NULL);\n                io.ver = 2;\n                /* Call the rdb_load method of the module providing the 10 bit\n                 * encoding version in the lower 10 bits of the module ID. */\n                if (mt->aux_load(&io,moduleid&1023, when) != REDISMODULE_OK || io.error) {\n                    moduleTypeNameByID(name,moduleid);\n                    serverLog(LL_WARNING,\"The RDB file contains module AUX data for the module type '%s', that the responsible module is not able to load. Check for modules log above for additional clues.\", name);\n                    goto eoferr;\n                }\n                if (io.ctx) {\n                    moduleFreeContext(io.ctx);\n                    zfree(io.ctx);\n                }\n                uint64_t eof = rdbLoadLen(rdb,NULL);\n                if (eof != RDB_MODULE_OPCODE_EOF) {\n                    serverLog(LL_WARNING,\"The RDB file contains module AUX data for the module '%s' that is not terminated by the proper module value EOF marker\", name);\n                    goto eoferr;\n                }\n                continue;\n            } else {\n                /* RDB check mode. */\n                robj *aux = rdbLoadCheckModuleValue(rdb,name);\n                decrRefCount(aux);\n                continue; /* Read next opcode. */\n            }\n        }\n\n        /* Read key */\n        if ((key = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL)\n            goto eoferr;\n        /* Read value */\n        if ((val = rdbLoadObject(type,rdb,key)) == NULL) {\n            sdsfree(key);\n            goto eoferr;\n        }\n\n        /* Check if the key already expired. This function is used when loading\n         * an RDB file from disk, either at startup, or when an RDB was\n         * received from the master. In the latter case, the master is\n         * responsible for key expiry. If we would expire keys here, the\n         * snapshot taken by the master may not be reflected on the slave.\n         * Similarly if the RDB is the preamble of an AOF file, we want to\n         * load all the keys as they are, since the log of operations later\n         * assume to work in an exact keyspace state. */\n        if (iAmMaster() &&\n            !(rdbflags&RDBFLAGS_AOF_PREAMBLE) &&\n            expiretime != -1 && expiretime < now)\n        {\n            sdsfree(key);\n            decrRefCount(val);\n        } else {\n            robj keyobj;\n            initStaticStringObject(keyobj,key);\n\n            /* Add the new object in the hash table */\n            int added = dbAddRDBLoad(db,key,val);\n            if (!added) {\n                if (rdbflags & RDBFLAGS_ALLOW_DUP) {\n                    /* This flag is useful for DEBUG RELOAD special modes.\n                     * When it's set we allow new keys to replace the current\n                     * keys with the same name. */\n                    dbSyncDelete(db,&keyobj);\n                    dbAddRDBLoad(db,key,val);\n                } else {\n                    serverLog(LL_WARNING,\n                        \"RDB has duplicated key '%s' in DB %d\",key,db->id);\n                    serverPanic(\"Duplicated key found in RDB file\");\n                }\n            }\n\n            /* Set the expire time if needed */\n            if (expiretime != -1) {\n                setExpire(NULL,db,&keyobj,expiretime);\n            }\n\n            /* Set usage information (for eviction). */\n            objectSetLRUOrLFU(val,lfu_freq,lru_idle,lru_clock,1000);\n\n            /* call key space notification on key loaded for modules only */\n            moduleNotifyKeyspaceEvent(NOTIFY_LOADED, \"loaded\", &keyobj, db->id);\n        }\n\n        /* Loading the database more slowly is useful in order to test\n         * certain edge cases. */\n        if (server.key_load_delay) usleep(server.key_load_delay);\n\n        /* Reset the state that is key-specified and is populated by\n         * opcodes before the key, so that we start from scratch again. */\n        expiretime = -1;\n        lfu_freq = -1;\n        lru_idle = -1;\n    }\n    /* Verify the checksum if RDB version is >= 5 */\n    if (rdbver >= 5) {\n        uint64_t cksum, expected = rdb->cksum;\n\n        if (rioRead(rdb,&cksum,8) == 0) goto eoferr;\n        if (server.rdb_checksum) {\n            memrev64ifbe(&cksum);\n            if (cksum == 0) {\n                serverLog(LL_WARNING,\"RDB file was saved with checksum disabled: no check performed.\");\n            } else if (cksum != expected) {\n                serverLog(LL_WARNING,\"Wrong RDB checksum expected: (%llx) but \"\n                    \"got (%llx). Aborting now.\",\n                        (unsigned long long)expected,\n                        (unsigned long long)cksum);\n                rdbExitReportCorruptRDB(\"RDB CRC error\");\n            }\n        }\n    }\n    return C_OK;\n\n    /* Unexpected end of file is handled here calling rdbReportReadError():\n     * this will in turn either abort Redis in most cases, or if we are loading\n     * the RDB file from a socket during initial SYNC (diskless replica mode),\n     * we'll report the error to the caller, so that we can retry. */\neoferr:\n    serverLog(LL_WARNING,\n        \"Short read or OOM loading DB. Unrecoverable error, aborting now.\");\n    rdbReportReadError(\"Unexpected EOF reading RDB file\");\n    return C_ERR;\n}\n\n/* Like rdbLoadRio() but takes a filename instead of a rio stream. The\n * filename is open for reading and a rio stream object created in order\n * to do the actual loading. Moreover the ETA displayed in the INFO\n * output is initialized and finalized.\n *\n * If you pass an 'rsi' structure initialied with RDB_SAVE_OPTION_INIT, the\n * loading code will fiil the information fields in the structure. */\nint rdbLoad(char *filename, rdbSaveInfo *rsi, int rdbflags) {\n    FILE *fp;\n    rio rdb;\n    int retval;\n\n    if ((fp = fopen(filename,\"r\")) == NULL) return C_ERR;\n    startLoadingFile(fp, filename,rdbflags);\n    rioInitWithFile(&rdb,fp);\n    retval = rdbLoadRio(&rdb,rdbflags,rsi);\n    fclose(fp);\n    stopLoading(retval==C_OK);\n    return retval;\n}\n\n/* A background saving child (BGSAVE) terminated its work. Handle this.\n * This function covers the case of actual BGSAVEs. */\nstatic void backgroundSaveDoneHandlerDisk(int exitcode, int bysignal) {\n    if (!bysignal && exitcode == 0) {\n        serverLog(LL_NOTICE,\n            \"Background saving terminated with success\");\n        server.dirty = server.dirty - server.dirty_before_bgsave;\n        server.lastsave = time(NULL);\n        server.lastbgsave_status = C_OK;\n    } else if (!bysignal && exitcode != 0) {\n        serverLog(LL_WARNING, \"Background saving error\");\n        server.lastbgsave_status = C_ERR;\n    } else {\n        mstime_t latency;\n\n        serverLog(LL_WARNING,\n            \"Background saving terminated by signal %d\", bysignal);\n        latencyStartMonitor(latency);\n        rdbRemoveTempFile(server.rdb_child_pid, 0);\n        latencyEndMonitor(latency);\n        latencyAddSampleIfNeeded(\"rdb-unlink-temp-file\",latency);\n        /* SIGUSR1 is whitelisted, so we have a way to kill a child without\n         * triggering an error condition. */\n        if (bysignal != SIGUSR1)\n            server.lastbgsave_status = C_ERR;\n    }\n}\n\n/* A background saving child (BGSAVE) terminated its work. Handle this.\n * This function covers the case of RDB -> Slaves socket transfers for\n * diskless replication. */\nstatic void backgroundSaveDoneHandlerSocket(int exitcode, int bysignal) {\n    if (!bysignal && exitcode == 0) {\n        serverLog(LL_NOTICE,\n            \"Background RDB transfer terminated with success\");\n    } else if (!bysignal && exitcode != 0) {\n        serverLog(LL_WARNING, \"Background transfer error\");\n    } else {\n        serverLog(LL_WARNING,\n            \"Background transfer terminated by signal %d\", bysignal);\n    }\n    if (server.rdb_child_exit_pipe!=-1)\n        close(server.rdb_child_exit_pipe);\n    aeDeleteFileEvent(server.el, server.rdb_pipe_read, AE_READABLE);\n    close(server.rdb_pipe_read);\n    server.rdb_child_exit_pipe = -1;\n    server.rdb_pipe_read = -1;\n    zfree(server.rdb_pipe_conns);\n    server.rdb_pipe_conns = NULL;\n    server.rdb_pipe_numconns = 0;\n    server.rdb_pipe_numconns_writing = 0;\n    zfree(server.rdb_pipe_buff);\n    server.rdb_pipe_buff = NULL;\n    server.rdb_pipe_bufflen = 0;\n}\n\n/* When a background RDB saving/transfer terminates, call the right handler. */\nvoid backgroundSaveDoneHandler(int exitcode, int bysignal) {\n    int type = server.rdb_child_type;\n    switch(server.rdb_child_type) {\n    case RDB_CHILD_TYPE_DISK:\n        backgroundSaveDoneHandlerDisk(exitcode,bysignal);\n        break;\n    case RDB_CHILD_TYPE_SOCKET:\n        backgroundSaveDoneHandlerSocket(exitcode,bysignal);\n        break;\n    default:\n        serverPanic(\"Unknown RDB child type.\");\n        break;\n    }\n\n    server.rdb_child_pid = -1;\n    server.rdb_child_type = RDB_CHILD_TYPE_NONE;\n    server.rdb_save_time_last = time(NULL)-server.rdb_save_time_start;\n    server.rdb_save_time_start = -1;\n    /* Possibly there are slaves waiting for a BGSAVE in order to be served\n     * (the first stage of SYNC is a bulk transfer of dump.rdb) */\n    updateSlavesWaitingBgsave((!bysignal && exitcode == 0) ? C_OK : C_ERR, type);\n}\n\n/* Kill the RDB saving child using SIGUSR1 (so that the parent will know\n * the child did not exit for an error, but because we wanted), and performs\n * the cleanup needed. */\nvoid killRDBChild(void) {\n    kill(server.rdb_child_pid,SIGUSR1);\n    rdbRemoveTempFile(server.rdb_child_pid, 0);\n    closeChildInfoPipe();\n    updateDictResizePolicy();\n}\n\n/* Spawn an RDB child that writes the RDB to the sockets of the slaves\n * that are currently in SLAVE_STATE_WAIT_BGSAVE_START state. */\nint rdbSaveToSlavesSockets(rdbSaveInfo *rsi) {\n    listNode *ln;\n    listIter li;\n    pid_t childpid;\n    int pipefds[2], rdb_pipe_write, safe_to_exit_pipe;\n\n    if (hasActiveChildProcess()) return C_ERR;\n\n    /* Even if the previous fork child exited, don't start a new one until we\n     * drained the pipe. */\n    if (server.rdb_pipe_conns) return C_ERR;\n\n    /* Before to fork, create a pipe that is used to transfer the rdb bytes to\n     * the parent, we can't let it write directly to the sockets, since in case\n     * of TLS we must let the parent handle a continuous TLS state when the\n     * child terminates and parent takes over. */\n    if (pipe(pipefds) == -1) return C_ERR;\n    server.rdb_pipe_read = pipefds[0]; /* read end */\n    rdb_pipe_write = pipefds[1]; /* write end */\n    anetNonBlock(NULL, server.rdb_pipe_read);\n\n    /* create another pipe that is used by the parent to signal to the child\n     * that it can exit. */\n    if (pipe(pipefds) == -1) {\n        close(rdb_pipe_write);\n        close(server.rdb_pipe_read);\n        return C_ERR;\n    }\n    safe_to_exit_pipe = pipefds[0]; /* read end */\n    server.rdb_child_exit_pipe = pipefds[1]; /* write end */\n\n    /* Collect the connections of the replicas we want to transfer\n     * the RDB to, which are i WAIT_BGSAVE_START state. */\n    server.rdb_pipe_conns = zmalloc(sizeof(connection *)*listLength(server.slaves));\n    server.rdb_pipe_numconns = 0;\n    server.rdb_pipe_numconns_writing = 0;\n    listRewind(server.slaves,&li);\n    while((ln = listNext(&li))) {\n        client *slave = ln->value;\n        if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START) {\n            server.rdb_pipe_conns[server.rdb_pipe_numconns++] = slave->conn;\n            replicationSetupSlaveForFullResync(slave,getPsyncInitialOffset());\n        }\n    }\n\n    /* Create the child process. */\n    openChildInfoPipe();\n    if ((childpid = redisFork(CHILD_TYPE_RDB)) == 0) {\n        /* Child */\n        int retval, dummy;\n        rio rdb;\n\n        rioInitWithFd(&rdb,rdb_pipe_write);\n\n        redisSetProcTitle(\"redis-rdb-to-slaves\");\n        redisSetCpuAffinity(server.bgsave_cpulist);\n\n        retval = rdbSaveRioWithEOFMark(&rdb,NULL,rsi);\n        if (retval == C_OK && rioFlush(&rdb) == 0)\n            retval = C_ERR;\n\n        if (retval == C_OK) {\n            sendChildCOWInfo(CHILD_TYPE_RDB, \"RDB\");\n        }\n\n        rioFreeFd(&rdb);\n        /* wake up the reader, tell it we're done. */\n        close(rdb_pipe_write);\n        close(server.rdb_child_exit_pipe); /* close write end so that we can detect the close on the parent. */\n        /* hold exit until the parent tells us it's safe. we're not expecting\n         * to read anything, just get the error when the pipe is closed. */\n        dummy = read(safe_to_exit_pipe, pipefds, 1);\n        UNUSED(dummy);\n        exitFromChild((retval == C_OK) ? 0 : 1);\n    } else {\n        /* Parent */\n        close(safe_to_exit_pipe);\n        if (childpid == -1) {\n            serverLog(LL_WARNING,\"Can't save in background: fork: %s\",\n                strerror(errno));\n\n            /* Undo the state change. The caller will perform cleanup on\n             * all the slaves in BGSAVE_START state, but an early call to\n             * replicationSetupSlaveForFullResync() turned it into BGSAVE_END */\n            listRewind(server.slaves,&li);\n            while((ln = listNext(&li))) {\n                client *slave = ln->value;\n                if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_END) {\n                    slave->replstate = SLAVE_STATE_WAIT_BGSAVE_START;\n                }\n            }\n            close(rdb_pipe_write);\n            close(server.rdb_pipe_read);\n            zfree(server.rdb_pipe_conns);\n            server.rdb_pipe_conns = NULL;\n            server.rdb_pipe_numconns = 0;\n            server.rdb_pipe_numconns_writing = 0;\n            closeChildInfoPipe();\n        } else {\n            serverLog(LL_NOTICE,\"Background RDB transfer started by pid %d\",\n                childpid);\n            server.rdb_save_time_start = time(NULL);\n            server.rdb_child_pid = childpid;\n            server.rdb_child_type = RDB_CHILD_TYPE_SOCKET;\n            updateDictResizePolicy();\n            close(rdb_pipe_write); /* close write in parent so that it can detect the close on the child. */\n            if (aeCreateFileEvent(server.el, server.rdb_pipe_read, AE_READABLE, rdbPipeReadHandler,NULL) == AE_ERR) {\n                serverPanic(\"Unrecoverable error creating server.rdb_pipe_read file event.\");\n            }\n        }\n        return (childpid == -1) ? C_ERR : C_OK;\n    }\n    return C_OK; /* Unreached. */\n}\n\nvoid saveCommand(client *c) {\n    if (server.rdb_child_pid != -1) {\n        addReplyError(c,\"Background save already in progress\");\n        return;\n    }\n    rdbSaveInfo rsi, *rsiptr;\n    rsiptr = rdbPopulateSaveInfo(&rsi);\n    if (rdbSave(server.rdb_filename,rsiptr) == C_OK) {\n        addReply(c,shared.ok);\n    } else {\n        addReply(c,shared.err);\n    }\n}\n\n/* BGSAVE [SCHEDULE] */\nvoid bgsaveCommand(client *c) {\n    int schedule = 0;\n\n    /* The SCHEDULE option changes the behavior of BGSAVE when an AOF rewrite\n     * is in progress. Instead of returning an error a BGSAVE gets scheduled. */\n    if (c->argc > 1) {\n        if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,\"schedule\")) {\n            schedule = 1;\n        } else {\n            addReply(c,shared.syntaxerr);\n            return;\n        }\n    }\n\n    rdbSaveInfo rsi, *rsiptr;\n    rsiptr = rdbPopulateSaveInfo(&rsi);\n\n    if (server.rdb_child_pid != -1) {\n        addReplyError(c,\"Background save already in progress\");\n    } else if (hasActiveChildProcess()) {\n        if (schedule) {\n            server.rdb_bgsave_scheduled = 1;\n            addReplyStatus(c,\"Background saving scheduled\");\n        } else {\n            addReplyError(c,\n            \"Another child process is active (AOF?): can't BGSAVE right now. \"\n            \"Use BGSAVE SCHEDULE in order to schedule a BGSAVE whenever \"\n            \"possible.\");\n        }\n    } else if (rdbSaveBackground(server.rdb_filename,rsiptr) == C_OK) {\n        addReplyStatus(c,\"Background saving started\");\n    } else {\n        addReply(c,shared.err);\n    }\n}\n\n/* Populate the rdbSaveInfo structure used to persist the replication\n * information inside the RDB file. Currently the structure explicitly\n * contains just the currently selected DB from the master stream, however\n * if the rdbSave*() family functions receive a NULL rsi structure also\n * the Replication ID/offset is not saved. The function popultes 'rsi'\n * that is normally stack-allocated in the caller, returns the populated\n * pointer if the instance has a valid master client, otherwise NULL\n * is returned, and the RDB saving will not persist any replication related\n * information. */\nrdbSaveInfo *rdbPopulateSaveInfo(rdbSaveInfo *rsi) {\n    rdbSaveInfo rsi_init = RDB_SAVE_INFO_INIT;\n    *rsi = rsi_init;\n\n    /* If the instance is a master, we can populate the replication info\n     * only when repl_backlog is not NULL. If the repl_backlog is NULL,\n     * it means that the instance isn't in any replication chains. In this\n     * scenario the replication info is useless, because when a slave\n     * connects to us, the NULL repl_backlog will trigger a full\n     * synchronization, at the same time we will use a new replid and clear\n     * replid2. */\n    if (!server.masterhost && server.repl_backlog) {\n        /* Note that when server.slaveseldb is -1, it means that this master\n         * didn't apply any write commands after a full synchronization.\n         * So we can let repl_stream_db be 0, this allows a restarted slave\n         * to reload replication ID/offset, it's safe because the next write\n         * command must generate a SELECT statement. */\n        rsi->repl_stream_db = server.slaveseldb == -1 ? 0 : server.slaveseldb;\n        return rsi;\n    }\n\n    /* If the instance is a slave we need a connected master\n     * in order to fetch the currently selected DB. */\n    if (server.master) {\n        rsi->repl_stream_db = server.master->db->id;\n        return rsi;\n    }\n\n    /* If we have a cached master we can use it in order to populate the\n     * replication selected DB info inside the RDB file: the slave can\n     * increment the master_repl_offset only from data arriving from the\n     * master, so if we are disconnected the offset in the cached master\n     * is valid. */\n    if (server.cached_master) {\n        rsi->repl_stream_db = server.cached_master->db->id;\n        return rsi;\n    }\n    return NULL;\n}\n", "/*\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n\n/*-----------------------------------------------------------------------------\n * Set Commands\n *----------------------------------------------------------------------------*/\n\nvoid sunionDiffGenericCommand(client *c, robj **setkeys, int setnum,\n                              robj *dstkey, int op);\n\n/* Factory method to return a set that *can* hold \"value\". When the object has\n * an integer-encodable value, an intset will be returned. Otherwise a regular\n * hash table. */\nrobj *setTypeCreate(sds value) {\n    if (isSdsRepresentableAsLongLong(value,NULL) == C_OK)\n        return createIntsetObject();\n    return createSetObject();\n}\n\n/* Add the specified value into a set.\n *\n * If the value was already member of the set, nothing is done and 0 is\n * returned, otherwise the new element is added and 1 is returned. */\nint setTypeAdd(robj *subject, sds value) {\n    long long llval;\n    if (subject->encoding == OBJ_ENCODING_HT) {\n        dict *ht = subject->ptr;\n        dictEntry *de = dictAddRaw(ht,value,NULL);\n        if (de) {\n            dictSetKey(ht,de,sdsdup(value));\n            dictSetVal(ht,de,NULL);\n            return 1;\n        }\n    } else if (subject->encoding == OBJ_ENCODING_INTSET) {\n        if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {\n            uint8_t success = 0;\n            subject->ptr = intsetAdd(subject->ptr,llval,&success);\n            if (success) {\n                /* Convert to regular set when the intset contains\n                 * too many entries. */\n                if (intsetLen(subject->ptr) > server.set_max_intset_entries)\n                    setTypeConvert(subject,OBJ_ENCODING_HT);\n                return 1;\n            }\n        } else {\n            /* Failed to get integer from object, convert to regular set. */\n            setTypeConvert(subject,OBJ_ENCODING_HT);\n\n            /* The set *was* an intset and this value is not integer\n             * encodable, so dictAdd should always work. */\n            serverAssert(dictAdd(subject->ptr,sdsdup(value),NULL) == DICT_OK);\n            return 1;\n        }\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return 0;\n}\n\nint setTypeRemove(robj *setobj, sds value) {\n    long long llval;\n    if (setobj->encoding == OBJ_ENCODING_HT) {\n        if (dictDelete(setobj->ptr,value) == DICT_OK) {\n            if (htNeedsResize(setobj->ptr)) dictResize(setobj->ptr);\n            return 1;\n        }\n    } else if (setobj->encoding == OBJ_ENCODING_INTSET) {\n        if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {\n            int success;\n            setobj->ptr = intsetRemove(setobj->ptr,llval,&success);\n            if (success) return 1;\n        }\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return 0;\n}\n\nint setTypeIsMember(robj *subject, sds value) {\n    long long llval;\n    if (subject->encoding == OBJ_ENCODING_HT) {\n        return dictFind((dict*)subject->ptr,value) != NULL;\n    } else if (subject->encoding == OBJ_ENCODING_INTSET) {\n        if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {\n            return intsetFind((intset*)subject->ptr,llval);\n        }\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return 0;\n}\n\nsetTypeIterator *setTypeInitIterator(robj *subject) {\n    setTypeIterator *si = zmalloc(sizeof(setTypeIterator));\n    si->subject = subject;\n    si->encoding = subject->encoding;\n    if (si->encoding == OBJ_ENCODING_HT) {\n        si->di = dictGetIterator(subject->ptr);\n    } else if (si->encoding == OBJ_ENCODING_INTSET) {\n        si->ii = 0;\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return si;\n}\n\nvoid setTypeReleaseIterator(setTypeIterator *si) {\n    if (si->encoding == OBJ_ENCODING_HT)\n        dictReleaseIterator(si->di);\n    zfree(si);\n}\n\n/* Move to the next entry in the set. Returns the object at the current\n * position.\n *\n * Since set elements can be internally be stored as SDS strings or\n * simple arrays of integers, setTypeNext returns the encoding of the\n * set object you are iterating, and will populate the appropriate pointer\n * (sdsele) or (llele) accordingly.\n *\n * Note that both the sdsele and llele pointers should be passed and cannot\n * be NULL since the function will try to defensively populate the non\n * used field with values which are easy to trap if misused.\n *\n * When there are no longer elements -1 is returned. */\nint setTypeNext(setTypeIterator *si, sds *sdsele, int64_t *llele) {\n    if (si->encoding == OBJ_ENCODING_HT) {\n        dictEntry *de = dictNext(si->di);\n        if (de == NULL) return -1;\n        *sdsele = dictGetKey(de);\n        *llele = -123456789; /* Not needed. Defensive. */\n    } else if (si->encoding == OBJ_ENCODING_INTSET) {\n        if (!intsetGet(si->subject->ptr,si->ii++,llele))\n            return -1;\n        *sdsele = NULL; /* Not needed. Defensive. */\n    } else {\n        serverPanic(\"Wrong set encoding in setTypeNext\");\n    }\n    return si->encoding;\n}\n\n/* The not copy on write friendly version but easy to use version\n * of setTypeNext() is setTypeNextObject(), returning new SDS\n * strings. So if you don't retain a pointer to this object you should call\n * sdsfree() against it.\n *\n * This function is the way to go for write operations where COW is not\n * an issue. */\nsds setTypeNextObject(setTypeIterator *si) {\n    int64_t intele;\n    sds sdsele;\n    int encoding;\n\n    encoding = setTypeNext(si,&sdsele,&intele);\n    switch(encoding) {\n        case -1:    return NULL;\n        case OBJ_ENCODING_INTSET:\n            return sdsfromlonglong(intele);\n        case OBJ_ENCODING_HT:\n            return sdsdup(sdsele);\n        default:\n            serverPanic(\"Unsupported encoding\");\n    }\n    return NULL; /* just to suppress warnings */\n}\n\n/* Return random element from a non empty set.\n * The returned element can be an int64_t value if the set is encoded\n * as an \"intset\" blob of integers, or an SDS string if the set\n * is a regular set.\n *\n * The caller provides both pointers to be populated with the right\n * object. The return value of the function is the object->encoding\n * field of the object and is used by the caller to check if the\n * int64_t pointer or the redis object pointer was populated.\n *\n * Note that both the sdsele and llele pointers should be passed and cannot\n * be NULL since the function will try to defensively populate the non\n * used field with values which are easy to trap if misused. */\nint setTypeRandomElement(robj *setobj, sds *sdsele, int64_t *llele) {\n    if (setobj->encoding == OBJ_ENCODING_HT) {\n        dictEntry *de = dictGetFairRandomKey(setobj->ptr);\n        *sdsele = dictGetKey(de);\n        *llele = -123456789; /* Not needed. Defensive. */\n    } else if (setobj->encoding == OBJ_ENCODING_INTSET) {\n        *llele = intsetRandom(setobj->ptr);\n        *sdsele = NULL; /* Not needed. Defensive. */\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return setobj->encoding;\n}\n\nunsigned long setTypeSize(const robj *subject) {\n    if (subject->encoding == OBJ_ENCODING_HT) {\n        return dictSize((const dict*)subject->ptr);\n    } else if (subject->encoding == OBJ_ENCODING_INTSET) {\n        return intsetLen((const intset*)subject->ptr);\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n}\n\n/* Convert the set to specified encoding. The resulting dict (when converting\n * to a hash table) is presized to hold the number of elements in the original\n * set. */\nvoid setTypeConvert(robj *setobj, int enc) {\n    setTypeIterator *si;\n    serverAssertWithInfo(NULL,setobj,setobj->type == OBJ_SET &&\n                             setobj->encoding == OBJ_ENCODING_INTSET);\n\n    if (enc == OBJ_ENCODING_HT) {\n        int64_t intele;\n        dict *d = dictCreate(&setDictType,NULL);\n        sds element;\n\n        /* Presize the dict to avoid rehashing */\n        dictExpand(d,intsetLen(setobj->ptr));\n\n        /* To add the elements we extract integers and create redis objects */\n        si = setTypeInitIterator(setobj);\n        while (setTypeNext(si,&element,&intele) != -1) {\n            element = sdsfromlonglong(intele);\n            serverAssert(dictAdd(d,element,NULL) == DICT_OK);\n        }\n        setTypeReleaseIterator(si);\n\n        setobj->encoding = OBJ_ENCODING_HT;\n        zfree(setobj->ptr);\n        setobj->ptr = d;\n    } else {\n        serverPanic(\"Unsupported set conversion\");\n    }\n}\n\nvoid saddCommand(client *c) {\n    robj *set;\n    int j, added = 0;\n\n    set = lookupKeyWrite(c->db,c->argv[1]);\n    if (set == NULL) {\n        set = setTypeCreate(c->argv[2]->ptr);\n        dbAdd(c->db,c->argv[1],set);\n    } else {\n        if (set->type != OBJ_SET) {\n            addReply(c,shared.wrongtypeerr);\n            return;\n        }\n    }\n\n    for (j = 2; j < c->argc; j++) {\n        if (setTypeAdd(set,c->argv[j]->ptr)) added++;\n    }\n    if (added) {\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_SET,\"sadd\",c->argv[1],c->db->id);\n    }\n    server.dirty += added;\n    addReplyLongLong(c,added);\n}\n\nvoid sremCommand(client *c) {\n    robj *set;\n    int j, deleted = 0, keyremoved = 0;\n\n    if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,set,OBJ_SET)) return;\n\n    for (j = 2; j < c->argc; j++) {\n        if (setTypeRemove(set,c->argv[j]->ptr)) {\n            deleted++;\n            if (setTypeSize(set) == 0) {\n                dbDelete(c->db,c->argv[1]);\n                keyremoved = 1;\n                break;\n            }\n        }\n    }\n    if (deleted) {\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_SET,\"srem\",c->argv[1],c->db->id);\n        if (keyremoved)\n            notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",c->argv[1],\n                                c->db->id);\n        server.dirty += deleted;\n    }\n    addReplyLongLong(c,deleted);\n}\n\nvoid smoveCommand(client *c) {\n    robj *srcset, *dstset, *ele;\n    srcset = lookupKeyWrite(c->db,c->argv[1]);\n    dstset = lookupKeyWrite(c->db,c->argv[2]);\n    ele = c->argv[3];\n\n    /* If the source key does not exist return 0 */\n    if (srcset == NULL) {\n        addReply(c,shared.czero);\n        return;\n    }\n\n    /* If the source key has the wrong type, or the destination key\n     * is set and has the wrong type, return with an error. */\n    if (checkType(c,srcset,OBJ_SET) ||\n        (dstset && checkType(c,dstset,OBJ_SET))) return;\n\n    /* If srcset and dstset are equal, SMOVE is a no-op */\n    if (srcset == dstset) {\n        addReply(c,setTypeIsMember(srcset,ele->ptr) ?\n            shared.cone : shared.czero);\n        return;\n    }\n\n    /* If the element cannot be removed from the src set, return 0. */\n    if (!setTypeRemove(srcset,ele->ptr)) {\n        addReply(c,shared.czero);\n        return;\n    }\n    notifyKeyspaceEvent(NOTIFY_SET,\"srem\",c->argv[1],c->db->id);\n\n    /* Remove the src set from the database when empty */\n    if (setTypeSize(srcset) == 0) {\n        dbDelete(c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",c->argv[1],c->db->id);\n    }\n\n    /* Create the destination set when it doesn't exist */\n    if (!dstset) {\n        dstset = setTypeCreate(ele->ptr);\n        dbAdd(c->db,c->argv[2],dstset);\n    }\n\n    signalModifiedKey(c,c->db,c->argv[1]);\n    server.dirty++;\n\n    /* An extra key has changed when ele was successfully added to dstset */\n    if (setTypeAdd(dstset,ele->ptr)) {\n        server.dirty++;\n        signalModifiedKey(c,c->db,c->argv[2]);\n        notifyKeyspaceEvent(NOTIFY_SET,\"sadd\",c->argv[2],c->db->id);\n    }\n    addReply(c,shared.cone);\n}\n\nvoid sismemberCommand(client *c) {\n    robj *set;\n\n    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,set,OBJ_SET)) return;\n\n    if (setTypeIsMember(set,c->argv[2]->ptr))\n        addReply(c,shared.cone);\n    else\n        addReply(c,shared.czero);\n}\n\nvoid scardCommand(client *c) {\n    robj *o;\n\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,o,OBJ_SET)) return;\n\n    addReplyLongLong(c,setTypeSize(o));\n}\n\n/* Handle the \"SPOP key <count>\" variant. The normal version of the\n * command is handled by the spopCommand() function itself. */\n\n/* How many times bigger should be the set compared to the remaining size\n * for us to use the \"create new set\" strategy? Read later in the\n * implementation for more info. */\n#define SPOP_MOVE_STRATEGY_MUL 5\n\nvoid spopWithCountCommand(client *c) {\n    long l;\n    unsigned long count, size;\n    robj *set;\n\n    /* Get the count argument */\n    if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n    if (l >= 0) {\n        count = (unsigned long) l;\n    } else {\n        addReply(c,shared.outofrangeerr);\n        return;\n    }\n\n    /* Make sure a key with the name inputted exists, and that it's type is\n     * indeed a set. Otherwise, return nil */\n    if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.emptyset[c->resp]))\n        == NULL || checkType(c,set,OBJ_SET)) return;\n\n    /* If count is zero, serve an empty set ASAP to avoid special\n     * cases later. */\n    if (count == 0) {\n        addReply(c,shared.emptyset[c->resp]);\n        return;\n    }\n\n    size = setTypeSize(set);\n\n    /* Generate an SPOP keyspace notification */\n    notifyKeyspaceEvent(NOTIFY_SET,\"spop\",c->argv[1],c->db->id);\n    server.dirty += count;\n\n    /* CASE 1:\n     * The number of requested elements is greater than or equal to\n     * the number of elements inside the set: simply return the whole set. */\n    if (count >= size) {\n        /* We just return the entire set */\n        sunionDiffGenericCommand(c,c->argv+1,1,NULL,SET_OP_UNION);\n\n        /* Delete the set as it is now empty */\n        dbDelete(c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",c->argv[1],c->db->id);\n\n        /* Propagate this command as a DEL operation */\n        rewriteClientCommandVector(c,2,shared.del,c->argv[1]);\n        signalModifiedKey(c,c->db,c->argv[1]);\n        server.dirty++;\n        return;\n    }\n\n    /* Case 2 and 3 require to replicate SPOP as a set of SREM commands.\n     * Prepare our replication argument vector. Also send the array length\n     * which is common to both the code paths. */\n    robj *propargv[3];\n    propargv[0] = createStringObject(\"SREM\",4);\n    propargv[1] = c->argv[1];\n    addReplySetLen(c,count);\n\n    /* Common iteration vars. */\n    sds sdsele;\n    robj *objele;\n    int encoding;\n    int64_t llele;\n    unsigned long remaining = size-count; /* Elements left after SPOP. */\n\n    /* If we are here, the number of requested elements is less than the\n     * number of elements inside the set. Also we are sure that count < size.\n     * Use two different strategies.\n     *\n     * CASE 2: The number of elements to return is small compared to the\n     * set size. We can just extract random elements and return them to\n     * the set. */\n    if (remaining*SPOP_MOVE_STRATEGY_MUL > count) {\n        while(count--) {\n            /* Emit and remove. */\n            encoding = setTypeRandomElement(set,&sdsele,&llele);\n            if (encoding == OBJ_ENCODING_INTSET) {\n                addReplyBulkLongLong(c,llele);\n                objele = createStringObjectFromLongLong(llele);\n                set->ptr = intsetRemove(set->ptr,llele,NULL);\n            } else {\n                addReplyBulkCBuffer(c,sdsele,sdslen(sdsele));\n                objele = createStringObject(sdsele,sdslen(sdsele));\n                setTypeRemove(set,sdsele);\n            }\n\n            /* Replicate/AOF this command as an SREM operation */\n            propargv[2] = objele;\n            alsoPropagate(server.sremCommand,c->db->id,propargv,3,\n                PROPAGATE_AOF|PROPAGATE_REPL);\n            decrRefCount(objele);\n        }\n    } else {\n    /* CASE 3: The number of elements to return is very big, approaching\n     * the size of the set itself. After some time extracting random elements\n     * from such a set becomes computationally expensive, so we use\n     * a different strategy, we extract random elements that we don't\n     * want to return (the elements that will remain part of the set),\n     * creating a new set as we do this (that will be stored as the original\n     * set). Then we return the elements left in the original set and\n     * release it. */\n        robj *newset = NULL;\n\n        /* Create a new set with just the remaining elements. */\n        while(remaining--) {\n            encoding = setTypeRandomElement(set,&sdsele,&llele);\n            if (encoding == OBJ_ENCODING_INTSET) {\n                sdsele = sdsfromlonglong(llele);\n            } else {\n                sdsele = sdsdup(sdsele);\n            }\n            if (!newset) newset = setTypeCreate(sdsele);\n            setTypeAdd(newset,sdsele);\n            setTypeRemove(set,sdsele);\n            sdsfree(sdsele);\n        }\n\n        /* Transfer the old set to the client. */\n        setTypeIterator *si;\n        si = setTypeInitIterator(set);\n        while((encoding = setTypeNext(si,&sdsele,&llele)) != -1) {\n            if (encoding == OBJ_ENCODING_INTSET) {\n                addReplyBulkLongLong(c,llele);\n                objele = createStringObjectFromLongLong(llele);\n            } else {\n                addReplyBulkCBuffer(c,sdsele,sdslen(sdsele));\n                objele = createStringObject(sdsele,sdslen(sdsele));\n            }\n\n            /* Replicate/AOF this command as an SREM operation */\n            propargv[2] = objele;\n            alsoPropagate(server.sremCommand,c->db->id,propargv,3,\n                PROPAGATE_AOF|PROPAGATE_REPL);\n            decrRefCount(objele);\n        }\n        setTypeReleaseIterator(si);\n\n        /* Assign the new set as the key value. */\n        dbOverwrite(c->db,c->argv[1],newset);\n    }\n\n    /* Don't propagate the command itself even if we incremented the\n     * dirty counter. We don't want to propagate an SPOP command since\n     * we propagated the command as a set of SREMs operations using\n     * the alsoPropagate() API. */\n    decrRefCount(propargv[0]);\n    preventCommandPropagation(c);\n    signalModifiedKey(c,c->db,c->argv[1]);\n    server.dirty++;\n}\n\nvoid spopCommand(client *c) {\n    robj *set, *ele, *aux;\n    sds sdsele;\n    int64_t llele;\n    int encoding;\n\n    if (c->argc == 3) {\n        spopWithCountCommand(c);\n        return;\n    } else if (c->argc > 3) {\n        addReply(c,shared.syntaxerr);\n        return;\n    }\n\n    /* Make sure a key with the name inputted exists, and that it's type is\n     * indeed a set */\n    if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.null[c->resp]))\n         == NULL || checkType(c,set,OBJ_SET)) return;\n\n    /* Get a random element from the set */\n    encoding = setTypeRandomElement(set,&sdsele,&llele);\n\n    /* Remove the element from the set */\n    if (encoding == OBJ_ENCODING_INTSET) {\n        ele = createStringObjectFromLongLong(llele);\n        set->ptr = intsetRemove(set->ptr,llele,NULL);\n    } else {\n        ele = createStringObject(sdsele,sdslen(sdsele));\n        setTypeRemove(set,ele->ptr);\n    }\n\n    notifyKeyspaceEvent(NOTIFY_SET,\"spop\",c->argv[1],c->db->id);\n\n    /* Replicate/AOF this command as an SREM operation */\n    aux = createStringObject(\"SREM\",4);\n    rewriteClientCommandVector(c,3,aux,c->argv[1],ele);\n    decrRefCount(aux);\n\n    /* Add the element to the reply */\n    addReplyBulk(c,ele);\n    decrRefCount(ele);\n\n    /* Delete the set if it's empty */\n    if (setTypeSize(set) == 0) {\n        dbDelete(c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",c->argv[1],c->db->id);\n    }\n\n    /* Set has been modified */\n    signalModifiedKey(c,c->db,c->argv[1]);\n    server.dirty++;\n}\n\n/* handle the \"SRANDMEMBER key <count>\" variant. The normal version of the\n * command is handled by the srandmemberCommand() function itself. */\n\n/* How many times bigger should be the set compared to the requested size\n * for us to don't use the \"remove elements\" strategy? Read later in the\n * implementation for more info. */\n#define SRANDMEMBER_SUB_STRATEGY_MUL 3\n\nvoid srandmemberWithCountCommand(client *c) {\n    long l;\n    unsigned long count, size;\n    int uniq = 1;\n    robj *set;\n    sds ele;\n    int64_t llele;\n    int encoding;\n\n    dict *d;\n\n    if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n    if (l >= 0) {\n        count = (unsigned long) l;\n    } else {\n        /* A negative count means: return the same elements multiple times\n         * (i.e. don't remove the extracted element after every extraction). */\n        count = -l;\n        uniq = 0;\n    }\n\n    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptyset[c->resp]))\n        == NULL || checkType(c,set,OBJ_SET)) return;\n    size = setTypeSize(set);\n\n    /* If count is zero, serve it ASAP to avoid special cases later. */\n    if (count == 0) {\n        addReply(c,shared.emptyset[c->resp]);\n        return;\n    }\n\n    /* CASE 1: The count was negative, so the extraction method is just:\n     * \"return N random elements\" sampling the whole set every time.\n     * This case is trivial and can be served without auxiliary data\n     * structures. */\n    if (!uniq) {\n        addReplySetLen(c,count);\n        while(count--) {\n            encoding = setTypeRandomElement(set,&ele,&llele);\n            if (encoding == OBJ_ENCODING_INTSET) {\n                addReplyBulkLongLong(c,llele);\n            } else {\n                addReplyBulkCBuffer(c,ele,sdslen(ele));\n            }\n        }\n        return;\n    }\n\n    /* CASE 2:\n     * The number of requested elements is greater than the number of\n     * elements inside the set: simply return the whole set. */\n    if (count >= size) {\n        sunionDiffGenericCommand(c,c->argv+1,1,NULL,SET_OP_UNION);\n        return;\n    }\n\n    /* For CASE 3 and CASE 4 we need an auxiliary dictionary. */\n    d = dictCreate(&objectKeyPointerValueDictType,NULL);\n\n    /* CASE 3:\n     * The number of elements inside the set is not greater than\n     * SRANDMEMBER_SUB_STRATEGY_MUL times the number of requested elements.\n     * In this case we create a set from scratch with all the elements, and\n     * subtract random elements to reach the requested number of elements.\n     *\n     * This is done because if the number of requested elements is just\n     * a bit less than the number of elements in the set, the natural approach\n     * used into CASE 3 is highly inefficient. */\n    if (count*SRANDMEMBER_SUB_STRATEGY_MUL > size) {\n        setTypeIterator *si;\n\n        /* Add all the elements into the temporary dictionary. */\n        si = setTypeInitIterator(set);\n        while((encoding = setTypeNext(si,&ele,&llele)) != -1) {\n            int retval = DICT_ERR;\n\n            if (encoding == OBJ_ENCODING_INTSET) {\n                retval = dictAdd(d,createStringObjectFromLongLong(llele),NULL);\n            } else {\n                retval = dictAdd(d,createStringObject(ele,sdslen(ele)),NULL);\n            }\n            serverAssert(retval == DICT_OK);\n        }\n        setTypeReleaseIterator(si);\n        serverAssert(dictSize(d) == size);\n\n        /* Remove random elements to reach the right count. */\n        while(size > count) {\n            dictEntry *de;\n\n            de = dictGetRandomKey(d);\n            dictDelete(d,dictGetKey(de));\n            size--;\n        }\n    }\n\n    /* CASE 4: We have a big set compared to the requested number of elements.\n     * In this case we can simply get random elements from the set and add\n     * to the temporary set, trying to eventually get enough unique elements\n     * to reach the specified count. */\n    else {\n        unsigned long added = 0;\n        robj *objele;\n\n        while(added < count) {\n            encoding = setTypeRandomElement(set,&ele,&llele);\n            if (encoding == OBJ_ENCODING_INTSET) {\n                objele = createStringObjectFromLongLong(llele);\n            } else {\n                objele = createStringObject(ele,sdslen(ele));\n            }\n            /* Try to add the object to the dictionary. If it already exists\n             * free it, otherwise increment the number of objects we have\n             * in the result dictionary. */\n            if (dictAdd(d,objele,NULL) == DICT_OK)\n                added++;\n            else\n                decrRefCount(objele);\n        }\n    }\n\n    /* CASE 3 & 4: send the result to the user. */\n    {\n        dictIterator *di;\n        dictEntry *de;\n\n        addReplySetLen(c,count);\n        di = dictGetIterator(d);\n        while((de = dictNext(di)) != NULL)\n            addReplyBulk(c,dictGetKey(de));\n        dictReleaseIterator(di);\n        dictRelease(d);\n    }\n}\n\nvoid srandmemberCommand(client *c) {\n    robj *set;\n    sds ele;\n    int64_t llele;\n    int encoding;\n\n    if (c->argc == 3) {\n        srandmemberWithCountCommand(c);\n        return;\n    } else if (c->argc > 3) {\n        addReply(c,shared.syntaxerr);\n        return;\n    }\n\n    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))\n        == NULL || checkType(c,set,OBJ_SET)) return;\n\n    encoding = setTypeRandomElement(set,&ele,&llele);\n    if (encoding == OBJ_ENCODING_INTSET) {\n        addReplyBulkLongLong(c,llele);\n    } else {\n        addReplyBulkCBuffer(c,ele,sdslen(ele));\n    }\n}\n\nint qsortCompareSetsByCardinality(const void *s1, const void *s2) {\n    if (setTypeSize(*(robj**)s1) > setTypeSize(*(robj**)s2)) return 1;\n    if (setTypeSize(*(robj**)s1) < setTypeSize(*(robj**)s2)) return -1;\n    return 0;\n}\n\n/* This is used by SDIFF and in this case we can receive NULL that should\n * be handled as empty sets. */\nint qsortCompareSetsByRevCardinality(const void *s1, const void *s2) {\n    robj *o1 = *(robj**)s1, *o2 = *(robj**)s2;\n    unsigned long first = o1 ? setTypeSize(o1) : 0;\n    unsigned long second = o2 ? setTypeSize(o2) : 0;\n\n    if (first < second) return 1;\n    if (first > second) return -1;\n    return 0;\n}\n\nvoid sinterGenericCommand(client *c, robj **setkeys,\n                          unsigned long setnum, robj *dstkey) {\n    robj **sets = zmalloc(sizeof(robj*)*setnum);\n    setTypeIterator *si;\n    robj *dstset = NULL;\n    sds elesds;\n    int64_t intobj;\n    void *replylen = NULL;\n    unsigned long j, cardinality = 0;\n    int encoding, empty = 0;\n\n    for (j = 0; j < setnum; j++) {\n        robj *setobj = dstkey ?\n            lookupKeyWrite(c->db,setkeys[j]) :\n            lookupKeyRead(c->db,setkeys[j]);\n        if (!setobj) {\n            /* A NULL is considered an empty set */\n            empty += 1;\n            sets[j] = NULL;\n            continue;\n        }\n        if (checkType(c,setobj,OBJ_SET)) {\n            zfree(sets);\n            return;\n        }\n        sets[j] = setobj;\n    }\n\n    /* Set intersection with an empty set always results in an empty set.\n     * Return ASAP if there is an empty set. */\n    if (empty > 0) {\n        zfree(sets);\n        if (dstkey) {\n            if (dbDelete(c->db,dstkey)) {\n                signalModifiedKey(c,c->db,dstkey);\n                notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",dstkey,c->db->id);\n                server.dirty++;\n            }\n            addReply(c,shared.czero);\n        } else {\n            addReply(c,shared.emptyset[c->resp]);\n        }\n        return;\n    }\n\n    /* Sort sets from the smallest to largest, this will improve our\n     * algorithm's performance */\n    qsort(sets,setnum,sizeof(robj*),qsortCompareSetsByCardinality);\n\n    /* The first thing we should output is the total number of elements...\n     * since this is a multi-bulk write, but at this stage we don't know\n     * the intersection set size, so we use a trick, append an empty object\n     * to the output list and save the pointer to later modify it with the\n     * right length */\n    if (!dstkey) {\n        replylen = addReplyDeferredLen(c);\n    } else {\n        /* If we have a target key where to store the resulting set\n         * create this key with an empty set inside */\n        dstset = createIntsetObject();\n    }\n\n    /* Iterate all the elements of the first (smallest) set, and test\n     * the element against all the other sets, if at least one set does\n     * not include the element it is discarded */\n    si = setTypeInitIterator(sets[0]);\n    while((encoding = setTypeNext(si,&elesds,&intobj)) != -1) {\n        for (j = 1; j < setnum; j++) {\n            if (sets[j] == sets[0]) continue;\n            if (encoding == OBJ_ENCODING_INTSET) {\n                /* intset with intset is simple... and fast */\n                if (sets[j]->encoding == OBJ_ENCODING_INTSET &&\n                    !intsetFind((intset*)sets[j]->ptr,intobj))\n                {\n                    break;\n                /* in order to compare an integer with an object we\n                 * have to use the generic function, creating an object\n                 * for this */\n                } else if (sets[j]->encoding == OBJ_ENCODING_HT) {\n                    elesds = sdsfromlonglong(intobj);\n                    if (!setTypeIsMember(sets[j],elesds)) {\n                        sdsfree(elesds);\n                        break;\n                    }\n                    sdsfree(elesds);\n                }\n            } else if (encoding == OBJ_ENCODING_HT) {\n                if (!setTypeIsMember(sets[j],elesds)) {\n                    break;\n                }\n            }\n        }\n\n        /* Only take action when all sets contain the member */\n        if (j == setnum) {\n            if (!dstkey) {\n                if (encoding == OBJ_ENCODING_HT)\n                    addReplyBulkCBuffer(c,elesds,sdslen(elesds));\n                else\n                    addReplyBulkLongLong(c,intobj);\n                cardinality++;\n            } else {\n                if (encoding == OBJ_ENCODING_INTSET) {\n                    elesds = sdsfromlonglong(intobj);\n                    setTypeAdd(dstset,elesds);\n                    sdsfree(elesds);\n                } else {\n                    setTypeAdd(dstset,elesds);\n                }\n            }\n        }\n    }\n    setTypeReleaseIterator(si);\n\n    if (dstkey) {\n        /* Store the resulting set into the target, if the intersection\n         * is not an empty set. */\n        int deleted = dbDelete(c->db,dstkey);\n        if (setTypeSize(dstset) > 0) {\n            dbAdd(c->db,dstkey,dstset);\n            addReplyLongLong(c,setTypeSize(dstset));\n            notifyKeyspaceEvent(NOTIFY_SET,\"sinterstore\",\n                dstkey,c->db->id);\n        } else {\n            decrRefCount(dstset);\n            addReply(c,shared.czero);\n            if (deleted)\n                notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",\n                    dstkey,c->db->id);\n        }\n        signalModifiedKey(c,c->db,dstkey);\n        server.dirty++;\n    } else {\n        setDeferredSetLen(c,replylen,cardinality);\n    }\n    zfree(sets);\n}\n\n/* SINTER key [key ...] */\nvoid sinterCommand(client *c) {\n    sinterGenericCommand(c,c->argv+1,c->argc-1,NULL);\n}\n\n/* SINTERSTORE destination key [key ...] */\nvoid sinterstoreCommand(client *c) {\n    sinterGenericCommand(c,c->argv+2,c->argc-2,c->argv[1]);\n}\n\n#define SET_OP_UNION 0\n#define SET_OP_DIFF 1\n#define SET_OP_INTER 2\n\nvoid sunionDiffGenericCommand(client *c, robj **setkeys, int setnum,\n                              robj *dstkey, int op) {\n    robj **sets = zmalloc(sizeof(robj*)*setnum);\n    setTypeIterator *si;\n    robj *dstset = NULL;\n    sds ele;\n    int j, cardinality = 0;\n    int diff_algo = 1;\n\n    for (j = 0; j < setnum; j++) {\n        robj *setobj = dstkey ?\n            lookupKeyWrite(c->db,setkeys[j]) :\n            lookupKeyRead(c->db,setkeys[j]);\n        if (!setobj) {\n            sets[j] = NULL;\n            continue;\n        }\n        if (checkType(c,setobj,OBJ_SET)) {\n            zfree(sets);\n            return;\n        }\n        sets[j] = setobj;\n    }\n\n    /* Select what DIFF algorithm to use.\n     *\n     * Algorithm 1 is O(N*M) where N is the size of the element first set\n     * and M the total number of sets.\n     *\n     * Algorithm 2 is O(N) where N is the total number of elements in all\n     * the sets.\n     *\n     * We compute what is the best bet with the current input here. */\n    if (op == SET_OP_DIFF && sets[0]) {\n        long long algo_one_work = 0, algo_two_work = 0;\n\n        for (j = 0; j < setnum; j++) {\n            if (sets[j] == NULL) continue;\n\n            algo_one_work += setTypeSize(sets[0]);\n            algo_two_work += setTypeSize(sets[j]);\n        }\n\n        /* Algorithm 1 has better constant times and performs less operations\n         * if there are elements in common. Give it some advantage. */\n        algo_one_work /= 2;\n        diff_algo = (algo_one_work <= algo_two_work) ? 1 : 2;\n\n        if (diff_algo == 1 && setnum > 1) {\n            /* With algorithm 1 it is better to order the sets to subtract\n             * by decreasing size, so that we are more likely to find\n             * duplicated elements ASAP. */\n            qsort(sets+1,setnum-1,sizeof(robj*),\n                qsortCompareSetsByRevCardinality);\n        }\n    }\n\n    /* We need a temp set object to store our union. If the dstkey\n     * is not NULL (that is, we are inside an SUNIONSTORE operation) then\n     * this set object will be the resulting object to set into the target key*/\n    dstset = createIntsetObject();\n\n    if (op == SET_OP_UNION) {\n        /* Union is trivial, just add every element of every set to the\n         * temporary set. */\n        for (j = 0; j < setnum; j++) {\n            if (!sets[j]) continue; /* non existing keys are like empty sets */\n\n            si = setTypeInitIterator(sets[j]);\n            while((ele = setTypeNextObject(si)) != NULL) {\n                if (setTypeAdd(dstset,ele)) cardinality++;\n                sdsfree(ele);\n            }\n            setTypeReleaseIterator(si);\n        }\n    } else if (op == SET_OP_DIFF && sets[0] && diff_algo == 1) {\n        /* DIFF Algorithm 1:\n         *\n         * We perform the diff by iterating all the elements of the first set,\n         * and only adding it to the target set if the element does not exist\n         * into all the other sets.\n         *\n         * This way we perform at max N*M operations, where N is the size of\n         * the first set, and M the number of sets. */\n        si = setTypeInitIterator(sets[0]);\n        while((ele = setTypeNextObject(si)) != NULL) {\n            for (j = 1; j < setnum; j++) {\n                if (!sets[j]) continue; /* no key is an empty set. */\n                if (sets[j] == sets[0]) break; /* same set! */\n                if (setTypeIsMember(sets[j],ele)) break;\n            }\n            if (j == setnum) {\n                /* There is no other set with this element. Add it. */\n                setTypeAdd(dstset,ele);\n                cardinality++;\n            }\n            sdsfree(ele);\n        }\n        setTypeReleaseIterator(si);\n    } else if (op == SET_OP_DIFF && sets[0] && diff_algo == 2) {\n        /* DIFF Algorithm 2:\n         *\n         * Add all the elements of the first set to the auxiliary set.\n         * Then remove all the elements of all the next sets from it.\n         *\n         * This is O(N) where N is the sum of all the elements in every\n         * set. */\n        for (j = 0; j < setnum; j++) {\n            if (!sets[j]) continue; /* non existing keys are like empty sets */\n\n            si = setTypeInitIterator(sets[j]);\n            while((ele = setTypeNextObject(si)) != NULL) {\n                if (j == 0) {\n                    if (setTypeAdd(dstset,ele)) cardinality++;\n                } else {\n                    if (setTypeRemove(dstset,ele)) cardinality--;\n                }\n                sdsfree(ele);\n            }\n            setTypeReleaseIterator(si);\n\n            /* Exit if result set is empty as any additional removal\n             * of elements will have no effect. */\n            if (cardinality == 0) break;\n        }\n    }\n\n    /* Output the content of the resulting set, if not in STORE mode */\n    if (!dstkey) {\n        addReplySetLen(c,cardinality);\n        si = setTypeInitIterator(dstset);\n        while((ele = setTypeNextObject(si)) != NULL) {\n            addReplyBulkCBuffer(c,ele,sdslen(ele));\n            sdsfree(ele);\n        }\n        setTypeReleaseIterator(si);\n        server.lazyfree_lazy_server_del ? freeObjAsync(dstset) :\n                                          decrRefCount(dstset);\n    } else {\n        /* If we have a target key where to store the resulting set\n         * create this key with the result set inside */\n        int deleted = dbDelete(c->db,dstkey);\n        if (setTypeSize(dstset) > 0) {\n            dbAdd(c->db,dstkey,dstset);\n            addReplyLongLong(c,setTypeSize(dstset));\n            notifyKeyspaceEvent(NOTIFY_SET,\n                op == SET_OP_UNION ? \"sunionstore\" : \"sdiffstore\",\n                dstkey,c->db->id);\n        } else {\n            decrRefCount(dstset);\n            addReply(c,shared.czero);\n            if (deleted)\n                notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",\n                    dstkey,c->db->id);\n        }\n        signalModifiedKey(c,c->db,dstkey);\n        server.dirty++;\n    }\n    zfree(sets);\n}\n\n/* SUNION key [key ...] */\nvoid sunionCommand(client *c) {\n    sunionDiffGenericCommand(c,c->argv+1,c->argc-1,NULL,SET_OP_UNION);\n}\n\n/* SUNIONSTORE destination key [key ...] */\nvoid sunionstoreCommand(client *c) {\n    sunionDiffGenericCommand(c,c->argv+2,c->argc-2,c->argv[1],SET_OP_UNION);\n}\n\n/* SDIFF key [key ...] */\nvoid sdiffCommand(client *c) {\n    sunionDiffGenericCommand(c,c->argv+1,c->argc-1,NULL,SET_OP_DIFF);\n}\n\n/* SDIFFSTORE destination key [key ...] */\nvoid sdiffstoreCommand(client *c) {\n    sunionDiffGenericCommand(c,c->argv+2,c->argc-2,c->argv[1],SET_OP_DIFF);\n}\n\nvoid sscanCommand(client *c) {\n    robj *set;\n    unsigned long cursor;\n\n    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) return;\n    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||\n        checkType(c,set,OBJ_SET)) return;\n    scanGenericCommand(c,set,cursor);\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2009-2012, Pieter Noordhuis <pcnoordhuis at gmail dot com>\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"intset.h\"\n#include \"zmalloc.h\"\n#include \"endianconv.h\"\n#include \"redisassert.h\"\n\n/* Note that these encodings are ordered, so:\n * INTSET_ENC_INT16 < INTSET_ENC_INT32 < INTSET_ENC_INT64. */\n#define INTSET_ENC_INT16 (sizeof(int16_t))\n#define INTSET_ENC_INT32 (sizeof(int32_t))\n#define INTSET_ENC_INT64 (sizeof(int64_t))\n\n/* Return the required encoding for the provided value. */\nstatic uint8_t _intsetValueEncoding(int64_t v) {\n    if (v < INT32_MIN || v > INT32_MAX)\n        return INTSET_ENC_INT64;\n    else if (v < INT16_MIN || v > INT16_MAX)\n        return INTSET_ENC_INT32;\n    else\n        return INTSET_ENC_INT16;\n}\n\n/* Return the value at pos, given an encoding. */\nstatic int64_t _intsetGetEncoded(intset *is, int pos, uint8_t enc) {\n    int64_t v64;\n    int32_t v32;\n    int16_t v16;\n\n    if (enc == INTSET_ENC_INT64) {\n        memcpy(&v64,((int64_t*)is->contents)+pos,sizeof(v64));\n        memrev64ifbe(&v64);\n        return v64;\n    } else if (enc == INTSET_ENC_INT32) {\n        memcpy(&v32,((int32_t*)is->contents)+pos,sizeof(v32));\n        memrev32ifbe(&v32);\n        return v32;\n    } else {\n        memcpy(&v16,((int16_t*)is->contents)+pos,sizeof(v16));\n        memrev16ifbe(&v16);\n        return v16;\n    }\n}\n\n/* Return the value at pos, using the configured encoding. */\nstatic int64_t _intsetGet(intset *is, int pos) {\n    return _intsetGetEncoded(is,pos,intrev32ifbe(is->encoding));\n}\n\n/* Set the value at pos, using the configured encoding. */\nstatic void _intsetSet(intset *is, int pos, int64_t value) {\n    uint32_t encoding = intrev32ifbe(is->encoding);\n\n    if (encoding == INTSET_ENC_INT64) {\n        ((int64_t*)is->contents)[pos] = value;\n        memrev64ifbe(((int64_t*)is->contents)+pos);\n    } else if (encoding == INTSET_ENC_INT32) {\n        ((int32_t*)is->contents)[pos] = value;\n        memrev32ifbe(((int32_t*)is->contents)+pos);\n    } else {\n        ((int16_t*)is->contents)[pos] = value;\n        memrev16ifbe(((int16_t*)is->contents)+pos);\n    }\n}\n\n/* Create an empty intset. */\nintset *intsetNew(void) {\n    intset *is = zmalloc(sizeof(intset));\n    is->encoding = intrev32ifbe(INTSET_ENC_INT16);\n    is->length = 0;\n    return is;\n}\n\n/* Resize the intset */\nstatic intset *intsetResize(intset *is, uint32_t len) {\n    uint64_t size = (uint64_t)len*intrev32ifbe(is->encoding);\n    assert(size <= SIZE_MAX - sizeof(intset));\n    is = zrealloc(is,sizeof(intset)+size);\n    return is;\n}\n\n/* Search for the position of \"value\". Return 1 when the value was found and\n * sets \"pos\" to the position of the value within the intset. Return 0 when\n * the value is not present in the intset and sets \"pos\" to the position\n * where \"value\" can be inserted. */\nstatic uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos) {\n    int min = 0, max = intrev32ifbe(is->length)-1, mid = -1;\n    int64_t cur = -1;\n\n    /* The value can never be found when the set is empty */\n    if (intrev32ifbe(is->length) == 0) {\n        if (pos) *pos = 0;\n        return 0;\n    } else {\n        /* Check for the case where we know we cannot find the value,\n         * but do know the insert position. */\n        if (value > _intsetGet(is,max)) {\n            if (pos) *pos = intrev32ifbe(is->length);\n            return 0;\n        } else if (value < _intsetGet(is,0)) {\n            if (pos) *pos = 0;\n            return 0;\n        }\n    }\n\n    while(max >= min) {\n        mid = ((unsigned int)min + (unsigned int)max) >> 1;\n        cur = _intsetGet(is,mid);\n        if (value > cur) {\n            min = mid+1;\n        } else if (value < cur) {\n            max = mid-1;\n        } else {\n            break;\n        }\n    }\n\n    if (value == cur) {\n        if (pos) *pos = mid;\n        return 1;\n    } else {\n        if (pos) *pos = min;\n        return 0;\n    }\n}\n\n/* Upgrades the intset to a larger encoding and inserts the given integer. */\nstatic intset *intsetUpgradeAndAdd(intset *is, int64_t value) {\n    uint8_t curenc = intrev32ifbe(is->encoding);\n    uint8_t newenc = _intsetValueEncoding(value);\n    int length = intrev32ifbe(is->length);\n    int prepend = value < 0 ? 1 : 0;\n\n    /* First set new encoding and resize */\n    is->encoding = intrev32ifbe(newenc);\n    is = intsetResize(is,intrev32ifbe(is->length)+1);\n\n    /* Upgrade back-to-front so we don't overwrite values.\n     * Note that the \"prepend\" variable is used to make sure we have an empty\n     * space at either the beginning or the end of the intset. */\n    while(length--)\n        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));\n\n    /* Set the value at the beginning or the end. */\n    if (prepend)\n        _intsetSet(is,0,value);\n    else\n        _intsetSet(is,intrev32ifbe(is->length),value);\n    is->length = intrev32ifbe(intrev32ifbe(is->length)+1);\n    return is;\n}\n\nstatic void intsetMoveTail(intset *is, uint32_t from, uint32_t to) {\n    void *src, *dst;\n    uint32_t bytes = intrev32ifbe(is->length)-from;\n    uint32_t encoding = intrev32ifbe(is->encoding);\n\n    if (encoding == INTSET_ENC_INT64) {\n        src = (int64_t*)is->contents+from;\n        dst = (int64_t*)is->contents+to;\n        bytes *= sizeof(int64_t);\n    } else if (encoding == INTSET_ENC_INT32) {\n        src = (int32_t*)is->contents+from;\n        dst = (int32_t*)is->contents+to;\n        bytes *= sizeof(int32_t);\n    } else {\n        src = (int16_t*)is->contents+from;\n        dst = (int16_t*)is->contents+to;\n        bytes *= sizeof(int16_t);\n    }\n    memmove(dst,src,bytes);\n}\n\n/* Insert an integer in the intset */\nintset *intsetAdd(intset *is, int64_t value, uint8_t *success) {\n    uint8_t valenc = _intsetValueEncoding(value);\n    uint32_t pos;\n    if (success) *success = 1;\n\n    /* Upgrade encoding if necessary. If we need to upgrade, we know that\n     * this value should be either appended (if > 0) or prepended (if < 0),\n     * because it lies outside the range of existing values. */\n    if (valenc > intrev32ifbe(is->encoding)) {\n        /* This always succeeds, so we don't need to curry *success. */\n        return intsetUpgradeAndAdd(is,value);\n    } else {\n        /* Abort if the value is already present in the set.\n         * This call will populate \"pos\" with the right position to insert\n         * the value when it cannot be found. */\n        if (intsetSearch(is,value,&pos)) {\n            if (success) *success = 0;\n            return is;\n        }\n\n        is = intsetResize(is,intrev32ifbe(is->length)+1);\n        if (pos < intrev32ifbe(is->length)) intsetMoveTail(is,pos,pos+1);\n    }\n\n    _intsetSet(is,pos,value);\n    is->length = intrev32ifbe(intrev32ifbe(is->length)+1);\n    return is;\n}\n\n/* Delete integer from intset */\nintset *intsetRemove(intset *is, int64_t value, int *success) {\n    uint8_t valenc = _intsetValueEncoding(value);\n    uint32_t pos;\n    if (success) *success = 0;\n\n    if (valenc <= intrev32ifbe(is->encoding) && intsetSearch(is,value,&pos)) {\n        uint32_t len = intrev32ifbe(is->length);\n\n        /* We know we can delete */\n        if (success) *success = 1;\n\n        /* Overwrite value with tail and update length */\n        if (pos < (len-1)) intsetMoveTail(is,pos+1,pos);\n        is = intsetResize(is,len-1);\n        is->length = intrev32ifbe(len-1);\n    }\n    return is;\n}\n\n/* Determine whether a value belongs to this set */\nuint8_t intsetFind(intset *is, int64_t value) {\n    uint8_t valenc = _intsetValueEncoding(value);\n    return valenc <= intrev32ifbe(is->encoding) && intsetSearch(is,value,NULL);\n}\n\n/* Return random member */\nint64_t intsetRandom(intset *is) {\n    return _intsetGet(is,rand()%intrev32ifbe(is->length));\n}\n\n/* Get the value at the given position. When this position is\n * out of range the function returns 0, when in range it returns 1. */\nuint8_t intsetGet(intset *is, uint32_t pos, int64_t *value) {\n    if (pos < intrev32ifbe(is->length)) {\n        *value = _intsetGet(is,pos);\n        return 1;\n    }\n    return 0;\n}\n\n/* Return intset length */\nuint32_t intsetLen(const intset *is) {\n    return intrev32ifbe(is->length);\n}\n\n/* Return intset blob size in bytes. */\nsize_t intsetBlobLen(intset *is) {\n    return sizeof(intset)+(size_t)intrev32ifbe(is->length)*intrev32ifbe(is->encoding);\n}\n\n#ifdef REDIS_TEST\n#include <sys/time.h>\n#include <time.h>\n\n#if 0\nstatic void intsetRepr(intset *is) {\n    for (uint32_t i = 0; i < intrev32ifbe(is->length); i++) {\n        printf(\"%lld\\n\", (uint64_t)_intsetGet(is,i));\n    }\n    printf(\"\\n\");\n}\n\nstatic void error(char *err) {\n    printf(\"%s\\n\", err);\n    exit(1);\n}\n#endif\n\nstatic void ok(void) {\n    printf(\"OK\\n\");\n}\n\nstatic long long usec(void) {\n    struct timeval tv;\n    gettimeofday(&tv,NULL);\n    return (((long long)tv.tv_sec)*1000000)+tv.tv_usec;\n}\n\n#define assert(_e) ((_e)?(void)0:(_assert(#_e,__FILE__,__LINE__),exit(1)))\nstatic void _assert(char *estr, char *file, int line) {\n    printf(\"\\n\\n=== ASSERTION FAILED ===\\n\");\n    printf(\"==> %s:%d '%s' is not true\\n\",file,line,estr);\n}\n\nstatic intset *createSet(int bits, int size) {\n    uint64_t mask = (1<<bits)-1;\n    uint64_t value;\n    intset *is = intsetNew();\n\n    for (int i = 0; i < size; i++) {\n        if (bits > 32) {\n            value = (rand()*rand()) & mask;\n        } else {\n            value = rand() & mask;\n        }\n        is = intsetAdd(is,value,NULL);\n    }\n    return is;\n}\n\nstatic void checkConsistency(intset *is) {\n    for (uint32_t i = 0; i < (intrev32ifbe(is->length)-1); i++) {\n        uint32_t encoding = intrev32ifbe(is->encoding);\n\n        if (encoding == INTSET_ENC_INT16) {\n            int16_t *i16 = (int16_t*)is->contents;\n            assert(i16[i] < i16[i+1]);\n        } else if (encoding == INTSET_ENC_INT32) {\n            int32_t *i32 = (int32_t*)is->contents;\n            assert(i32[i] < i32[i+1]);\n        } else {\n            int64_t *i64 = (int64_t*)is->contents;\n            assert(i64[i] < i64[i+1]);\n        }\n    }\n}\n\n#define UNUSED(x) (void)(x)\nint intsetTest(int argc, char **argv) {\n    uint8_t success;\n    int i;\n    intset *is;\n    srand(time(NULL));\n\n    UNUSED(argc);\n    UNUSED(argv);\n\n    printf(\"Value encodings: \"); {\n        assert(_intsetValueEncoding(-32768) == INTSET_ENC_INT16);\n        assert(_intsetValueEncoding(+32767) == INTSET_ENC_INT16);\n        assert(_intsetValueEncoding(-32769) == INTSET_ENC_INT32);\n        assert(_intsetValueEncoding(+32768) == INTSET_ENC_INT32);\n        assert(_intsetValueEncoding(-2147483648) == INTSET_ENC_INT32);\n        assert(_intsetValueEncoding(+2147483647) == INTSET_ENC_INT32);\n        assert(_intsetValueEncoding(-2147483649) == INTSET_ENC_INT64);\n        assert(_intsetValueEncoding(+2147483648) == INTSET_ENC_INT64);\n        assert(_intsetValueEncoding(-9223372036854775808ull) ==\n                    INTSET_ENC_INT64);\n        assert(_intsetValueEncoding(+9223372036854775807ull) ==\n                    INTSET_ENC_INT64);\n        ok();\n    }\n\n    printf(\"Basic adding: \"); {\n        is = intsetNew();\n        is = intsetAdd(is,5,&success); assert(success);\n        is = intsetAdd(is,6,&success); assert(success);\n        is = intsetAdd(is,4,&success); assert(success);\n        is = intsetAdd(is,4,&success); assert(!success);\n        ok();\n    }\n\n    printf(\"Large number of random adds: \"); {\n        uint32_t inserts = 0;\n        is = intsetNew();\n        for (i = 0; i < 1024; i++) {\n            is = intsetAdd(is,rand()%0x800,&success);\n            if (success) inserts++;\n        }\n        assert(intrev32ifbe(is->length) == inserts);\n        checkConsistency(is);\n        ok();\n    }\n\n    printf(\"Upgrade from int16 to int32: \"); {\n        is = intsetNew();\n        is = intsetAdd(is,32,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT16);\n        is = intsetAdd(is,65535,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT32);\n        assert(intsetFind(is,32));\n        assert(intsetFind(is,65535));\n        checkConsistency(is);\n\n        is = intsetNew();\n        is = intsetAdd(is,32,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT16);\n        is = intsetAdd(is,-65535,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT32);\n        assert(intsetFind(is,32));\n        assert(intsetFind(is,-65535));\n        checkConsistency(is);\n        ok();\n    }\n\n    printf(\"Upgrade from int16 to int64: \"); {\n        is = intsetNew();\n        is = intsetAdd(is,32,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT16);\n        is = intsetAdd(is,4294967295,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT64);\n        assert(intsetFind(is,32));\n        assert(intsetFind(is,4294967295));\n        checkConsistency(is);\n\n        is = intsetNew();\n        is = intsetAdd(is,32,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT16);\n        is = intsetAdd(is,-4294967295,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT64);\n        assert(intsetFind(is,32));\n        assert(intsetFind(is,-4294967295));\n        checkConsistency(is);\n        ok();\n    }\n\n    printf(\"Upgrade from int32 to int64: \"); {\n        is = intsetNew();\n        is = intsetAdd(is,65535,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT32);\n        is = intsetAdd(is,4294967295,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT64);\n        assert(intsetFind(is,65535));\n        assert(intsetFind(is,4294967295));\n        checkConsistency(is);\n\n        is = intsetNew();\n        is = intsetAdd(is,65535,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT32);\n        is = intsetAdd(is,-4294967295,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT64);\n        assert(intsetFind(is,65535));\n        assert(intsetFind(is,-4294967295));\n        checkConsistency(is);\n        ok();\n    }\n\n    printf(\"Stress lookups: \"); {\n        long num = 100000, size = 10000;\n        int i, bits = 20;\n        long long start;\n        is = createSet(bits,size);\n        checkConsistency(is);\n\n        start = usec();\n        for (i = 0; i < num; i++) intsetSearch(is,rand() % ((1<<bits)-1),NULL);\n        printf(\"%ld lookups, %ld element set, %lldusec\\n\",\n               num,size,usec()-start);\n    }\n\n    printf(\"Stress add+delete: \"); {\n        int i, v1, v2;\n        is = intsetNew();\n        for (i = 0; i < 0xffff; i++) {\n            v1 = rand() % 0xfff;\n            is = intsetAdd(is,v1,NULL);\n            assert(intsetFind(is,v1));\n\n            v2 = rand() % 0xfff;\n            is = intsetRemove(is,v2,NULL);\n            assert(!intsetFind(is,v2));\n        }\n        checkConsistency(is);\n        ok();\n    }\n\n    return 0;\n}\n#endif\n", "/*\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n#include \"lzf.h\"    /* LZF compression library */\n#include \"zipmap.h\"\n#include \"endianconv.h\"\n#include \"stream.h\"\n\n#include <math.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/wait.h>\n#include <arpa/inet.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n\n/* This macro is called when the internal RDB stracture is corrupt */\n#define rdbExitReportCorruptRDB(...) rdbReportError(1, __LINE__,__VA_ARGS__)\n/* This macro is called when RDB read failed (possibly a short read) */\n#define rdbReportReadError(...) rdbReportError(0, __LINE__,__VA_ARGS__)\n\nchar* rdbFileBeingLoaded = NULL; /* used for rdb checking on read error */\nextern int rdbCheckMode;\nvoid rdbCheckError(const char *fmt, ...);\nvoid rdbCheckSetError(const char *fmt, ...);\n\n#ifdef __GNUC__\nvoid rdbReportError(int corruption_error, int linenum, char *reason, ...) __attribute__ ((format (printf, 3, 4)));\n#endif\nvoid rdbReportError(int corruption_error, int linenum, char *reason, ...) {\n    va_list ap;\n    char msg[1024];\n    int len;\n\n    len = snprintf(msg,sizeof(msg),\n        \"Internal error in RDB reading offset %llu, function at rdb.c:%d -> \",\n        (unsigned long long)server.loading_loaded_bytes, linenum);\n    va_start(ap,reason);\n    vsnprintf(msg+len,sizeof(msg)-len,reason,ap);\n    va_end(ap);\n\n    if (!rdbCheckMode) {\n        if (rdbFileBeingLoaded || corruption_error) {\n            serverLog(LL_WARNING, \"%s\", msg);\n            char *argv[2] = {\"\",rdbFileBeingLoaded};\n            redis_check_rdb_main(2,argv,NULL);\n        } else {\n            serverLog(LL_WARNING, \"%s. Failure loading rdb format from socket, assuming connection error, resuming operation.\", msg);\n            return;\n        }\n    } else {\n        rdbCheckError(\"%s\",msg);\n    }\n    serverLog(LL_WARNING, \"Terminating server after rdb file reading failure.\");\n    exit(1);\n}\n\nstatic ssize_t rdbWriteRaw(rio *rdb, void *p, size_t len) {\n    if (rdb && rioWrite(rdb,p,len) == 0)\n        return -1;\n    return len;\n}\n\nint rdbSaveType(rio *rdb, unsigned char type) {\n    return rdbWriteRaw(rdb,&type,1);\n}\n\n/* Load a \"type\" in RDB format, that is a one byte unsigned integer.\n * This function is not only used to load object types, but also special\n * \"types\" like the end-of-file type, the EXPIRE type, and so forth. */\nint rdbLoadType(rio *rdb) {\n    unsigned char type;\n    if (rioRead(rdb,&type,1) == 0) return -1;\n    return type;\n}\n\n/* This is only used to load old databases stored with the RDB_OPCODE_EXPIRETIME\n * opcode. New versions of Redis store using the RDB_OPCODE_EXPIRETIME_MS\n * opcode. On error -1 is returned, however this could be a valid time, so\n * to check for loading errors the caller should call rioGetReadError() after\n * calling this function. */\ntime_t rdbLoadTime(rio *rdb) {\n    int32_t t32;\n    if (rioRead(rdb,&t32,4) == 0) return -1;\n    return (time_t)t32;\n}\n\nint rdbSaveMillisecondTime(rio *rdb, long long t) {\n    int64_t t64 = (int64_t) t;\n    memrev64ifbe(&t64); /* Store in little endian. */\n    return rdbWriteRaw(rdb,&t64,8);\n}\n\n/* This function loads a time from the RDB file. It gets the version of the\n * RDB because, unfortunately, before Redis 5 (RDB version 9), the function\n * failed to convert data to/from little endian, so RDB files with keys having\n * expires could not be shared between big endian and little endian systems\n * (because the expire time will be totally wrong). The fix for this is just\n * to call memrev64ifbe(), however if we fix this for all the RDB versions,\n * this call will introduce an incompatibility for big endian systems:\n * after upgrading to Redis version 5 they will no longer be able to load their\n * own old RDB files. Because of that, we instead fix the function only for new\n * RDB versions, and load older RDB versions as we used to do in the past,\n * allowing big endian systems to load their own old RDB files.\n *\n * On I/O error the function returns LLONG_MAX, however if this is also a\n * valid stored value, the caller should use rioGetReadError() to check for\n * errors after calling this function. */\nlong long rdbLoadMillisecondTime(rio *rdb, int rdbver) {\n    int64_t t64;\n    if (rioRead(rdb,&t64,8) == 0) return LLONG_MAX;\n    if (rdbver >= 9) /* Check the top comment of this function. */\n        memrev64ifbe(&t64); /* Convert in big endian if the system is BE. */\n    return (long long)t64;\n}\n\n/* Saves an encoded length. The first two bits in the first byte are used to\n * hold the encoding type. See the RDB_* definitions for more information\n * on the types of encoding. */\nint rdbSaveLen(rio *rdb, uint64_t len) {\n    unsigned char buf[2];\n    size_t nwritten;\n\n    if (len < (1<<6)) {\n        /* Save a 6 bit len */\n        buf[0] = (len&0xFF)|(RDB_6BITLEN<<6);\n        if (rdbWriteRaw(rdb,buf,1) == -1) return -1;\n        nwritten = 1;\n    } else if (len < (1<<14)) {\n        /* Save a 14 bit len */\n        buf[0] = ((len>>8)&0xFF)|(RDB_14BITLEN<<6);\n        buf[1] = len&0xFF;\n        if (rdbWriteRaw(rdb,buf,2) == -1) return -1;\n        nwritten = 2;\n    } else if (len <= UINT32_MAX) {\n        /* Save a 32 bit len */\n        buf[0] = RDB_32BITLEN;\n        if (rdbWriteRaw(rdb,buf,1) == -1) return -1;\n        uint32_t len32 = htonl(len);\n        if (rdbWriteRaw(rdb,&len32,4) == -1) return -1;\n        nwritten = 1+4;\n    } else {\n        /* Save a 64 bit len */\n        buf[0] = RDB_64BITLEN;\n        if (rdbWriteRaw(rdb,buf,1) == -1) return -1;\n        len = htonu64(len);\n        if (rdbWriteRaw(rdb,&len,8) == -1) return -1;\n        nwritten = 1+8;\n    }\n    return nwritten;\n}\n\n\n/* Load an encoded length. If the loaded length is a normal length as stored\n * with rdbSaveLen(), the read length is set to '*lenptr'. If instead the\n * loaded length describes a special encoding that follows, then '*isencoded'\n * is set to 1 and the encoding format is stored at '*lenptr'.\n *\n * See the RDB_ENC_* definitions in rdb.h for more information on special\n * encodings.\n *\n * The function returns -1 on error, 0 on success. */\nint rdbLoadLenByRef(rio *rdb, int *isencoded, uint64_t *lenptr) {\n    unsigned char buf[2];\n    int type;\n\n    if (isencoded) *isencoded = 0;\n    if (rioRead(rdb,buf,1) == 0) return -1;\n    type = (buf[0]&0xC0)>>6;\n    if (type == RDB_ENCVAL) {\n        /* Read a 6 bit encoding type. */\n        if (isencoded) *isencoded = 1;\n        *lenptr = buf[0]&0x3F;\n    } else if (type == RDB_6BITLEN) {\n        /* Read a 6 bit len. */\n        *lenptr = buf[0]&0x3F;\n    } else if (type == RDB_14BITLEN) {\n        /* Read a 14 bit len. */\n        if (rioRead(rdb,buf+1,1) == 0) return -1;\n        *lenptr = ((buf[0]&0x3F)<<8)|buf[1];\n    } else if (buf[0] == RDB_32BITLEN) {\n        /* Read a 32 bit len. */\n        uint32_t len;\n        if (rioRead(rdb,&len,4) == 0) return -1;\n        *lenptr = ntohl(len);\n    } else if (buf[0] == RDB_64BITLEN) {\n        /* Read a 64 bit len. */\n        uint64_t len;\n        if (rioRead(rdb,&len,8) == 0) return -1;\n        *lenptr = ntohu64(len);\n    } else {\n        rdbExitReportCorruptRDB(\n            \"Unknown length encoding %d in rdbLoadLen()\",type);\n        return -1; /* Never reached. */\n    }\n    return 0;\n}\n\n/* This is like rdbLoadLenByRef() but directly returns the value read\n * from the RDB stream, signaling an error by returning RDB_LENERR\n * (since it is a too large count to be applicable in any Redis data\n * structure). */\nuint64_t rdbLoadLen(rio *rdb, int *isencoded) {\n    uint64_t len;\n\n    if (rdbLoadLenByRef(rdb,isencoded,&len) == -1) return RDB_LENERR;\n    return len;\n}\n\n/* Encodes the \"value\" argument as integer when it fits in the supported ranges\n * for encoded types. If the function successfully encodes the integer, the\n * representation is stored in the buffer pointer to by \"enc\" and the string\n * length is returned. Otherwise 0 is returned. */\nint rdbEncodeInteger(long long value, unsigned char *enc) {\n    if (value >= -(1<<7) && value <= (1<<7)-1) {\n        enc[0] = (RDB_ENCVAL<<6)|RDB_ENC_INT8;\n        enc[1] = value&0xFF;\n        return 2;\n    } else if (value >= -(1<<15) && value <= (1<<15)-1) {\n        enc[0] = (RDB_ENCVAL<<6)|RDB_ENC_INT16;\n        enc[1] = value&0xFF;\n        enc[2] = (value>>8)&0xFF;\n        return 3;\n    } else if (value >= -((long long)1<<31) && value <= ((long long)1<<31)-1) {\n        enc[0] = (RDB_ENCVAL<<6)|RDB_ENC_INT32;\n        enc[1] = value&0xFF;\n        enc[2] = (value>>8)&0xFF;\n        enc[3] = (value>>16)&0xFF;\n        enc[4] = (value>>24)&0xFF;\n        return 5;\n    } else {\n        return 0;\n    }\n}\n\n/* Loads an integer-encoded object with the specified encoding type \"enctype\".\n * The returned value changes according to the flags, see\n * rdbGenericLoadStringObject() for more info. */\nvoid *rdbLoadIntegerObject(rio *rdb, int enctype, int flags, size_t *lenptr) {\n    int plain = flags & RDB_LOAD_PLAIN;\n    int sds = flags & RDB_LOAD_SDS;\n    int encode = flags & RDB_LOAD_ENC;\n    unsigned char enc[4];\n    long long val;\n\n    if (enctype == RDB_ENC_INT8) {\n        if (rioRead(rdb,enc,1) == 0) return NULL;\n        val = (signed char)enc[0];\n    } else if (enctype == RDB_ENC_INT16) {\n        uint16_t v;\n        if (rioRead(rdb,enc,2) == 0) return NULL;\n        v = enc[0]|(enc[1]<<8);\n        val = (int16_t)v;\n    } else if (enctype == RDB_ENC_INT32) {\n        uint32_t v;\n        if (rioRead(rdb,enc,4) == 0) return NULL;\n        v = enc[0]|(enc[1]<<8)|(enc[2]<<16)|(enc[3]<<24);\n        val = (int32_t)v;\n    } else {\n        rdbExitReportCorruptRDB(\"Unknown RDB integer encoding type %d\",enctype);\n        return NULL; /* Never reached. */\n    }\n    if (plain || sds) {\n        char buf[LONG_STR_SIZE], *p;\n        int len = ll2string(buf,sizeof(buf),val);\n        if (lenptr) *lenptr = len;\n        p = plain ? zmalloc(len) : sdsnewlen(SDS_NOINIT,len);\n        memcpy(p,buf,len);\n        return p;\n    } else if (encode) {\n        return createStringObjectFromLongLongForValue(val);\n    } else {\n        return createObject(OBJ_STRING,sdsfromlonglong(val));\n    }\n}\n\n/* String objects in the form \"2391\" \"-100\" without any space and with a\n * range of values that can fit in an 8, 16 or 32 bit signed value can be\n * encoded as integers to save space */\nint rdbTryIntegerEncoding(char *s, size_t len, unsigned char *enc) {\n    long long value;\n    char *endptr, buf[32];\n\n    /* Check if it's possible to encode this value as a number */\n    value = strtoll(s, &endptr, 10);\n    if (endptr[0] != '\\0') return 0;\n    ll2string(buf,32,value);\n\n    /* If the number converted back into a string is not identical\n     * then it's not possible to encode the string as integer */\n    if (strlen(buf) != len || memcmp(buf,s,len)) return 0;\n\n    return rdbEncodeInteger(value,enc);\n}\n\nssize_t rdbSaveLzfBlob(rio *rdb, void *data, size_t compress_len,\n                       size_t original_len) {\n    unsigned char byte;\n    ssize_t n, nwritten = 0;\n\n    /* Data compressed! Let's save it on disk */\n    byte = (RDB_ENCVAL<<6)|RDB_ENC_LZF;\n    if ((n = rdbWriteRaw(rdb,&byte,1)) == -1) goto writeerr;\n    nwritten += n;\n\n    if ((n = rdbSaveLen(rdb,compress_len)) == -1) goto writeerr;\n    nwritten += n;\n\n    if ((n = rdbSaveLen(rdb,original_len)) == -1) goto writeerr;\n    nwritten += n;\n\n    if ((n = rdbWriteRaw(rdb,data,compress_len)) == -1) goto writeerr;\n    nwritten += n;\n\n    return nwritten;\n\nwriteerr:\n    return -1;\n}\n\nssize_t rdbSaveLzfStringObject(rio *rdb, unsigned char *s, size_t len) {\n    size_t comprlen, outlen;\n    void *out;\n\n    /* We require at least four bytes compression for this to be worth it */\n    if (len <= 4) return 0;\n    outlen = len-4;\n    if ((out = zmalloc(outlen+1)) == NULL) return 0;\n    comprlen = lzf_compress(s, len, out, outlen);\n    if (comprlen == 0) {\n        zfree(out);\n        return 0;\n    }\n    ssize_t nwritten = rdbSaveLzfBlob(rdb, out, comprlen, len);\n    zfree(out);\n    return nwritten;\n}\n\n/* Load an LZF compressed string in RDB format. The returned value\n * changes according to 'flags'. For more info check the\n * rdbGenericLoadStringObject() function. */\nvoid *rdbLoadLzfStringObject(rio *rdb, int flags, size_t *lenptr) {\n    int plain = flags & RDB_LOAD_PLAIN;\n    int sds = flags & RDB_LOAD_SDS;\n    uint64_t len, clen;\n    unsigned char *c = NULL;\n    char *val = NULL;\n\n    if ((clen = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;\n    if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;\n    if ((c = zmalloc(clen)) == NULL) goto err;\n\n    /* Allocate our target according to the uncompressed size. */\n    if (plain) {\n        val = zmalloc(len);\n    } else {\n        val = sdsnewlen(SDS_NOINIT,len);\n    }\n    if (lenptr) *lenptr = len;\n\n    /* Load the compressed representation and uncompress it to target. */\n    if (rioRead(rdb,c,clen) == 0) goto err;\n    if (lzf_decompress(c,clen,val,len) == 0) {\n        rdbExitReportCorruptRDB(\"Invalid LZF compressed string\");\n    }\n    zfree(c);\n\n    if (plain || sds) {\n        return val;\n    } else {\n        return createObject(OBJ_STRING,val);\n    }\nerr:\n    zfree(c);\n    if (plain)\n        zfree(val);\n    else\n        sdsfree(val);\n    return NULL;\n}\n\n/* Save a string object as [len][data] on disk. If the object is a string\n * representation of an integer value we try to save it in a special form */\nssize_t rdbSaveRawString(rio *rdb, unsigned char *s, size_t len) {\n    int enclen;\n    ssize_t n, nwritten = 0;\n\n    /* Try integer encoding */\n    if (len <= 11) {\n        unsigned char buf[5];\n        if ((enclen = rdbTryIntegerEncoding((char*)s,len,buf)) > 0) {\n            if (rdbWriteRaw(rdb,buf,enclen) == -1) return -1;\n            return enclen;\n        }\n    }\n\n    /* Try LZF compression - under 20 bytes it's unable to compress even\n     * aaaaaaaaaaaaaaaaaa so skip it */\n    if (server.rdb_compression && len > 20) {\n        n = rdbSaveLzfStringObject(rdb,s,len);\n        if (n == -1) return -1;\n        if (n > 0) return n;\n        /* Return value of 0 means data can't be compressed, save the old way */\n    }\n\n    /* Store verbatim */\n    if ((n = rdbSaveLen(rdb,len)) == -1) return -1;\n    nwritten += n;\n    if (len > 0) {\n        if (rdbWriteRaw(rdb,s,len) == -1) return -1;\n        nwritten += len;\n    }\n    return nwritten;\n}\n\n/* Save a long long value as either an encoded string or a string. */\nssize_t rdbSaveLongLongAsStringObject(rio *rdb, long long value) {\n    unsigned char buf[32];\n    ssize_t n, nwritten = 0;\n    int enclen = rdbEncodeInteger(value,buf);\n    if (enclen > 0) {\n        return rdbWriteRaw(rdb,buf,enclen);\n    } else {\n        /* Encode as string */\n        enclen = ll2string((char*)buf,32,value);\n        serverAssert(enclen < 32);\n        if ((n = rdbSaveLen(rdb,enclen)) == -1) return -1;\n        nwritten += n;\n        if ((n = rdbWriteRaw(rdb,buf,enclen)) == -1) return -1;\n        nwritten += n;\n    }\n    return nwritten;\n}\n\n/* Like rdbSaveRawString() gets a Redis object instead. */\nssize_t rdbSaveStringObject(rio *rdb, robj *obj) {\n    /* Avoid to decode the object, then encode it again, if the\n     * object is already integer encoded. */\n    if (obj->encoding == OBJ_ENCODING_INT) {\n        return rdbSaveLongLongAsStringObject(rdb,(long)obj->ptr);\n    } else {\n        serverAssertWithInfo(NULL,obj,sdsEncodedObject(obj));\n        return rdbSaveRawString(rdb,obj->ptr,sdslen(obj->ptr));\n    }\n}\n\n/* Load a string object from an RDB file according to flags:\n *\n * RDB_LOAD_NONE (no flags): load an RDB object, unencoded.\n * RDB_LOAD_ENC: If the returned type is a Redis object, try to\n *               encode it in a special way to be more memory\n *               efficient. When this flag is passed the function\n *               no longer guarantees that obj->ptr is an SDS string.\n * RDB_LOAD_PLAIN: Return a plain string allocated with zmalloc()\n *                 instead of a Redis object with an sds in it.\n * RDB_LOAD_SDS: Return an SDS string instead of a Redis object.\n *\n * On I/O error NULL is returned.\n */\nvoid *rdbGenericLoadStringObject(rio *rdb, int flags, size_t *lenptr) {\n    int encode = flags & RDB_LOAD_ENC;\n    int plain = flags & RDB_LOAD_PLAIN;\n    int sds = flags & RDB_LOAD_SDS;\n    int isencoded;\n    unsigned long long len;\n\n    len = rdbLoadLen(rdb,&isencoded);\n    if (isencoded) {\n        switch(len) {\n        case RDB_ENC_INT8:\n        case RDB_ENC_INT16:\n        case RDB_ENC_INT32:\n            return rdbLoadIntegerObject(rdb,len,flags,lenptr);\n        case RDB_ENC_LZF:\n            return rdbLoadLzfStringObject(rdb,flags,lenptr);\n        default:\n            rdbExitReportCorruptRDB(\"Unknown RDB string encoding type %llu\",len);\n            return NULL;\n        }\n    }\n\n    if (len == RDB_LENERR) return NULL;\n    if (plain || sds) {\n        void *buf = plain ? zmalloc(len) : sdsnewlen(SDS_NOINIT,len);\n        if (lenptr) *lenptr = len;\n        if (len && rioRead(rdb,buf,len) == 0) {\n            if (plain)\n                zfree(buf);\n            else\n                sdsfree(buf);\n            return NULL;\n        }\n        return buf;\n    } else {\n        robj *o = encode ? createStringObject(SDS_NOINIT,len) :\n                           createRawStringObject(SDS_NOINIT,len);\n        if (len && rioRead(rdb,o->ptr,len) == 0) {\n            decrRefCount(o);\n            return NULL;\n        }\n        return o;\n    }\n}\n\nrobj *rdbLoadStringObject(rio *rdb) {\n    return rdbGenericLoadStringObject(rdb,RDB_LOAD_NONE,NULL);\n}\n\nrobj *rdbLoadEncodedStringObject(rio *rdb) {\n    return rdbGenericLoadStringObject(rdb,RDB_LOAD_ENC,NULL);\n}\n\n/* Save a double value. Doubles are saved as strings prefixed by an unsigned\n * 8 bit integer specifying the length of the representation.\n * This 8 bit integer has special values in order to specify the following\n * conditions:\n * 253: not a number\n * 254: + inf\n * 255: - inf\n */\nint rdbSaveDoubleValue(rio *rdb, double val) {\n    unsigned char buf[128];\n    int len;\n\n    if (isnan(val)) {\n        buf[0] = 253;\n        len = 1;\n    } else if (!isfinite(val)) {\n        len = 1;\n        buf[0] = (val < 0) ? 255 : 254;\n    } else {\n#if (DBL_MANT_DIG >= 52) && (LLONG_MAX == 0x7fffffffffffffffLL)\n        /* Check if the float is in a safe range to be casted into a\n         * long long. We are assuming that long long is 64 bit here.\n         * Also we are assuming that there are no implementations around where\n         * double has precision < 52 bit.\n         *\n         * Under this assumptions we test if a double is inside an interval\n         * where casting to long long is safe. Then using two castings we\n         * make sure the decimal part is zero. If all this is true we use\n         * integer printing function that is much faster. */\n        double min = -4503599627370495; /* (2^52)-1 */\n        double max = 4503599627370496; /* -(2^52) */\n        if (val > min && val < max && val == ((double)((long long)val)))\n            ll2string((char*)buf+1,sizeof(buf)-1,(long long)val);\n        else\n#endif\n            snprintf((char*)buf+1,sizeof(buf)-1,\"%.17g\",val);\n        buf[0] = strlen((char*)buf+1);\n        len = buf[0]+1;\n    }\n    return rdbWriteRaw(rdb,buf,len);\n}\n\n/* For information about double serialization check rdbSaveDoubleValue() */\nint rdbLoadDoubleValue(rio *rdb, double *val) {\n    char buf[256];\n    unsigned char len;\n\n    if (rioRead(rdb,&len,1) == 0) return -1;\n    switch(len) {\n    case 255: *val = R_NegInf; return 0;\n    case 254: *val = R_PosInf; return 0;\n    case 253: *val = R_Nan; return 0;\n    default:\n        if (rioRead(rdb,buf,len) == 0) return -1;\n        buf[len] = '\\0';\n        sscanf(buf, \"%lg\", val);\n        return 0;\n    }\n}\n\n/* Saves a double for RDB 8 or greater, where IE754 binary64 format is assumed.\n * We just make sure the integer is always stored in little endian, otherwise\n * the value is copied verbatim from memory to disk.\n *\n * Return -1 on error, the size of the serialized value on success. */\nint rdbSaveBinaryDoubleValue(rio *rdb, double val) {\n    memrev64ifbe(&val);\n    return rdbWriteRaw(rdb,&val,sizeof(val));\n}\n\n/* Loads a double from RDB 8 or greater. See rdbSaveBinaryDoubleValue() for\n * more info. On error -1 is returned, otherwise 0. */\nint rdbLoadBinaryDoubleValue(rio *rdb, double *val) {\n    if (rioRead(rdb,val,sizeof(*val)) == 0) return -1;\n    memrev64ifbe(val);\n    return 0;\n}\n\n/* Like rdbSaveBinaryDoubleValue() but single precision. */\nint rdbSaveBinaryFloatValue(rio *rdb, float val) {\n    memrev32ifbe(&val);\n    return rdbWriteRaw(rdb,&val,sizeof(val));\n}\n\n/* Like rdbLoadBinaryDoubleValue() but single precision. */\nint rdbLoadBinaryFloatValue(rio *rdb, float *val) {\n    if (rioRead(rdb,val,sizeof(*val)) == 0) return -1;\n    memrev32ifbe(val);\n    return 0;\n}\n\n/* Save the object type of object \"o\". */\nint rdbSaveObjectType(rio *rdb, robj *o) {\n    switch (o->type) {\n    case OBJ_STRING:\n        return rdbSaveType(rdb,RDB_TYPE_STRING);\n    case OBJ_LIST:\n        if (o->encoding == OBJ_ENCODING_QUICKLIST)\n            return rdbSaveType(rdb,RDB_TYPE_LIST_QUICKLIST);\n        else\n            serverPanic(\"Unknown list encoding\");\n    case OBJ_SET:\n        if (o->encoding == OBJ_ENCODING_INTSET)\n            return rdbSaveType(rdb,RDB_TYPE_SET_INTSET);\n        else if (o->encoding == OBJ_ENCODING_HT)\n            return rdbSaveType(rdb,RDB_TYPE_SET);\n        else\n            serverPanic(\"Unknown set encoding\");\n    case OBJ_ZSET:\n        if (o->encoding == OBJ_ENCODING_ZIPLIST)\n            return rdbSaveType(rdb,RDB_TYPE_ZSET_ZIPLIST);\n        else if (o->encoding == OBJ_ENCODING_SKIPLIST)\n            return rdbSaveType(rdb,RDB_TYPE_ZSET_2);\n        else\n            serverPanic(\"Unknown sorted set encoding\");\n    case OBJ_HASH:\n        if (o->encoding == OBJ_ENCODING_ZIPLIST)\n            return rdbSaveType(rdb,RDB_TYPE_HASH_ZIPLIST);\n        else if (o->encoding == OBJ_ENCODING_HT)\n            return rdbSaveType(rdb,RDB_TYPE_HASH);\n        else\n            serverPanic(\"Unknown hash encoding\");\n    case OBJ_STREAM:\n        return rdbSaveType(rdb,RDB_TYPE_STREAM_LISTPACKS);\n    case OBJ_MODULE:\n        return rdbSaveType(rdb,RDB_TYPE_MODULE_2);\n    default:\n        serverPanic(\"Unknown object type\");\n    }\n    return -1; /* avoid warning */\n}\n\n/* Use rdbLoadType() to load a TYPE in RDB format, but returns -1 if the\n * type is not specifically a valid Object Type. */\nint rdbLoadObjectType(rio *rdb) {\n    int type;\n    if ((type = rdbLoadType(rdb)) == -1) return -1;\n    if (!rdbIsObjectType(type)) return -1;\n    return type;\n}\n\n/* This helper function serializes a consumer group Pending Entries List (PEL)\n * into the RDB file. The 'nacks' argument tells the function if also persist\n * the informations about the not acknowledged message, or if to persist\n * just the IDs: this is useful because for the global consumer group PEL\n * we serialized the NACKs as well, but when serializing the local consumer\n * PELs we just add the ID, that will be resolved inside the global PEL to\n * put a reference to the same structure. */\nssize_t rdbSaveStreamPEL(rio *rdb, rax *pel, int nacks) {\n    ssize_t n, nwritten = 0;\n\n    /* Number of entries in the PEL. */\n    if ((n = rdbSaveLen(rdb,raxSize(pel))) == -1) return -1;\n    nwritten += n;\n\n    /* Save each entry. */\n    raxIterator ri;\n    raxStart(&ri,pel);\n    raxSeek(&ri,\"^\",NULL,0);\n    while(raxNext(&ri)) {\n        /* We store IDs in raw form as 128 big big endian numbers, like\n         * they are inside the radix tree key. */\n        if ((n = rdbWriteRaw(rdb,ri.key,sizeof(streamID))) == -1) {\n            raxStop(&ri);\n            return -1;\n        }\n        nwritten += n;\n\n        if (nacks) {\n            streamNACK *nack = ri.data;\n            if ((n = rdbSaveMillisecondTime(rdb,nack->delivery_time)) == -1) {\n                raxStop(&ri);\n                return -1;\n            }\n            nwritten += n;\n            if ((n = rdbSaveLen(rdb,nack->delivery_count)) == -1) {\n                raxStop(&ri);\n                return -1;\n            }\n            nwritten += n;\n            /* We don't save the consumer name: we'll save the pending IDs\n             * for each consumer in the consumer PEL, and resolve the consumer\n             * at loading time. */\n        }\n    }\n    raxStop(&ri);\n    return nwritten;\n}\n\n/* Serialize the consumers of a stream consumer group into the RDB. Helper\n * function for the stream data type serialization. What we do here is to\n * persist the consumer metadata, and it's PEL, for each consumer. */\nsize_t rdbSaveStreamConsumers(rio *rdb, streamCG *cg) {\n    ssize_t n, nwritten = 0;\n\n    /* Number of consumers in this consumer group. */\n    if ((n = rdbSaveLen(rdb,raxSize(cg->consumers))) == -1) return -1;\n    nwritten += n;\n\n    /* Save each consumer. */\n    raxIterator ri;\n    raxStart(&ri,cg->consumers);\n    raxSeek(&ri,\"^\",NULL,0);\n    while(raxNext(&ri)) {\n        streamConsumer *consumer = ri.data;\n\n        /* Consumer name. */\n        if ((n = rdbSaveRawString(rdb,ri.key,ri.key_len)) == -1) {\n            raxStop(&ri);\n            return -1;\n        }\n        nwritten += n;\n\n        /* Last seen time. */\n        if ((n = rdbSaveMillisecondTime(rdb,consumer->seen_time)) == -1) {\n            raxStop(&ri);\n            return -1;\n        }\n        nwritten += n;\n\n        /* Consumer PEL, without the ACKs (see last parameter of the function\n         * passed with value of 0), at loading time we'll lookup the ID\n         * in the consumer group global PEL and will put a reference in the\n         * consumer local PEL. */\n        if ((n = rdbSaveStreamPEL(rdb,consumer->pel,0)) == -1) {\n            raxStop(&ri);\n            return -1;\n        }\n        nwritten += n;\n    }\n    raxStop(&ri);\n    return nwritten;\n}\n\n/* Save a Redis object.\n * Returns -1 on error, number of bytes written on success. */\nssize_t rdbSaveObject(rio *rdb, robj *o, robj *key) {\n    ssize_t n = 0, nwritten = 0;\n\n    if (o->type == OBJ_STRING) {\n        /* Save a string value */\n        if ((n = rdbSaveStringObject(rdb,o)) == -1) return -1;\n        nwritten += n;\n    } else if (o->type == OBJ_LIST) {\n        /* Save a list value */\n        if (o->encoding == OBJ_ENCODING_QUICKLIST) {\n            quicklist *ql = o->ptr;\n            quicklistNode *node = ql->head;\n\n            if ((n = rdbSaveLen(rdb,ql->len)) == -1) return -1;\n            nwritten += n;\n\n            while(node) {\n                if (quicklistNodeIsCompressed(node)) {\n                    void *data;\n                    size_t compress_len = quicklistGetLzf(node, &data);\n                    if ((n = rdbSaveLzfBlob(rdb,data,compress_len,node->sz)) == -1) return -1;\n                    nwritten += n;\n                } else {\n                    if ((n = rdbSaveRawString(rdb,node->zl,node->sz)) == -1) return -1;\n                    nwritten += n;\n                }\n                node = node->next;\n            }\n        } else {\n            serverPanic(\"Unknown list encoding\");\n        }\n    } else if (o->type == OBJ_SET) {\n        /* Save a set value */\n        if (o->encoding == OBJ_ENCODING_HT) {\n            dict *set = o->ptr;\n            dictIterator *di = dictGetIterator(set);\n            dictEntry *de;\n\n            if ((n = rdbSaveLen(rdb,dictSize(set))) == -1) {\n                dictReleaseIterator(di);\n                return -1;\n            }\n            nwritten += n;\n\n            while((de = dictNext(di)) != NULL) {\n                sds ele = dictGetKey(de);\n                if ((n = rdbSaveRawString(rdb,(unsigned char*)ele,sdslen(ele)))\n                    == -1)\n                {\n                    dictReleaseIterator(di);\n                    return -1;\n                }\n                nwritten += n;\n            }\n            dictReleaseIterator(di);\n        } else if (o->encoding == OBJ_ENCODING_INTSET) {\n            size_t l = intsetBlobLen((intset*)o->ptr);\n\n            if ((n = rdbSaveRawString(rdb,o->ptr,l)) == -1) return -1;\n            nwritten += n;\n        } else {\n            serverPanic(\"Unknown set encoding\");\n        }\n    } else if (o->type == OBJ_ZSET) {\n        /* Save a sorted set value */\n        if (o->encoding == OBJ_ENCODING_ZIPLIST) {\n            size_t l = ziplistBlobLen((unsigned char*)o->ptr);\n\n            if ((n = rdbSaveRawString(rdb,o->ptr,l)) == -1) return -1;\n            nwritten += n;\n        } else if (o->encoding == OBJ_ENCODING_SKIPLIST) {\n            zset *zs = o->ptr;\n            zskiplist *zsl = zs->zsl;\n\n            if ((n = rdbSaveLen(rdb,zsl->length)) == -1) return -1;\n            nwritten += n;\n\n            /* We save the skiplist elements from the greatest to the smallest\n             * (that's trivial since the elements are already ordered in the\n             * skiplist): this improves the load process, since the next loaded\n             * element will always be the smaller, so adding to the skiplist\n             * will always immediately stop at the head, making the insertion\n             * O(1) instead of O(log(N)). */\n            zskiplistNode *zn = zsl->tail;\n            while (zn != NULL) {\n                if ((n = rdbSaveRawString(rdb,\n                    (unsigned char*)zn->ele,sdslen(zn->ele))) == -1)\n                {\n                    return -1;\n                }\n                nwritten += n;\n                if ((n = rdbSaveBinaryDoubleValue(rdb,zn->score)) == -1)\n                    return -1;\n                nwritten += n;\n                zn = zn->backward;\n            }\n        } else {\n            serverPanic(\"Unknown sorted set encoding\");\n        }\n    } else if (o->type == OBJ_HASH) {\n        /* Save a hash value */\n        if (o->encoding == OBJ_ENCODING_ZIPLIST) {\n            size_t l = ziplistBlobLen((unsigned char*)o->ptr);\n\n            if ((n = rdbSaveRawString(rdb,o->ptr,l)) == -1) return -1;\n            nwritten += n;\n\n        } else if (o->encoding == OBJ_ENCODING_HT) {\n            dictIterator *di = dictGetIterator(o->ptr);\n            dictEntry *de;\n\n            if ((n = rdbSaveLen(rdb,dictSize((dict*)o->ptr))) == -1) {\n                dictReleaseIterator(di);\n                return -1;\n            }\n            nwritten += n;\n\n            while((de = dictNext(di)) != NULL) {\n                sds field = dictGetKey(de);\n                sds value = dictGetVal(de);\n\n                if ((n = rdbSaveRawString(rdb,(unsigned char*)field,\n                        sdslen(field))) == -1)\n                {\n                    dictReleaseIterator(di);\n                    return -1;\n                }\n                nwritten += n;\n                if ((n = rdbSaveRawString(rdb,(unsigned char*)value,\n                        sdslen(value))) == -1)\n                {\n                    dictReleaseIterator(di);\n                    return -1;\n                }\n                nwritten += n;\n            }\n            dictReleaseIterator(di);\n        } else {\n            serverPanic(\"Unknown hash encoding\");\n        }\n    } else if (o->type == OBJ_STREAM) {\n        /* Store how many listpacks we have inside the radix tree. */\n        stream *s = o->ptr;\n        rax *rax = s->rax;\n        if ((n = rdbSaveLen(rdb,raxSize(rax))) == -1) return -1;\n        nwritten += n;\n\n        /* Serialize all the listpacks inside the radix tree as they are,\n         * when loading back, we'll use the first entry of each listpack\n         * to insert it back into the radix tree. */\n        raxIterator ri;\n        raxStart(&ri,rax);\n        raxSeek(&ri,\"^\",NULL,0);\n        while (raxNext(&ri)) {\n            unsigned char *lp = ri.data;\n            size_t lp_bytes = lpBytes(lp);\n            if ((n = rdbSaveRawString(rdb,ri.key,ri.key_len)) == -1) {\n                raxStop(&ri);\n                return -1;\n            }\n            nwritten += n;\n            if ((n = rdbSaveRawString(rdb,lp,lp_bytes)) == -1) {\n                raxStop(&ri);\n                return -1;\n            }\n            nwritten += n;\n        }\n        raxStop(&ri);\n\n        /* Save the number of elements inside the stream. We cannot obtain\n         * this easily later, since our macro nodes should be checked for\n         * number of items: not a great CPU / space tradeoff. */\n        if ((n = rdbSaveLen(rdb,s->length)) == -1) return -1;\n        nwritten += n;\n        /* Save the last entry ID. */\n        if ((n = rdbSaveLen(rdb,s->last_id.ms)) == -1) return -1;\n        nwritten += n;\n        if ((n = rdbSaveLen(rdb,s->last_id.seq)) == -1) return -1;\n        nwritten += n;\n\n        /* The consumer groups and their clients are part of the stream\n         * type, so serialize every consumer group. */\n\n        /* Save the number of groups. */\n        size_t num_cgroups = s->cgroups ? raxSize(s->cgroups) : 0;\n        if ((n = rdbSaveLen(rdb,num_cgroups)) == -1) return -1;\n        nwritten += n;\n\n        if (num_cgroups) {\n            /* Serialize each consumer group. */\n            raxStart(&ri,s->cgroups);\n            raxSeek(&ri,\"^\",NULL,0);\n            while(raxNext(&ri)) {\n                streamCG *cg = ri.data;\n\n                /* Save the group name. */\n                if ((n = rdbSaveRawString(rdb,ri.key,ri.key_len)) == -1) {\n                    raxStop(&ri);\n                    return -1;\n                }\n                nwritten += n;\n\n                /* Last ID. */\n                if ((n = rdbSaveLen(rdb,cg->last_id.ms)) == -1) {\n                    raxStop(&ri);\n                    return -1;\n                }\n                nwritten += n;\n                if ((n = rdbSaveLen(rdb,cg->last_id.seq)) == -1) {\n                    raxStop(&ri);\n                    return -1;\n                }\n                nwritten += n;\n\n                /* Save the global PEL. */\n                if ((n = rdbSaveStreamPEL(rdb,cg->pel,1)) == -1) {\n                    raxStop(&ri);\n                    return -1;\n                }\n                nwritten += n;\n\n                /* Save the consumers of this group. */\n                if ((n = rdbSaveStreamConsumers(rdb,cg)) == -1) {\n                    raxStop(&ri);\n                    return -1;\n                }\n                nwritten += n;\n            }\n            raxStop(&ri);\n        }\n    } else if (o->type == OBJ_MODULE) {\n        /* Save a module-specific value. */\n        RedisModuleIO io;\n        moduleValue *mv = o->ptr;\n        moduleType *mt = mv->type;\n\n        /* Write the \"module\" identifier as prefix, so that we'll be able\n         * to call the right module during loading. */\n        int retval = rdbSaveLen(rdb,mt->id);\n        if (retval == -1) return -1;\n        io.bytes += retval;\n\n        /* Then write the module-specific representation + EOF marker. */\n        moduleInitIOContext(io,mt,rdb,key);\n        mt->rdb_save(&io,mv->value);\n        retval = rdbSaveLen(rdb,RDB_MODULE_OPCODE_EOF);\n        if (retval == -1)\n            io.error = 1;\n        else\n            io.bytes += retval;\n\n        if (io.ctx) {\n            moduleFreeContext(io.ctx);\n            zfree(io.ctx);\n        }\n        return io.error ? -1 : (ssize_t)io.bytes;\n    } else {\n        serverPanic(\"Unknown object type\");\n    }\n    return nwritten;\n}\n\n/* Return the length the object will have on disk if saved with\n * the rdbSaveObject() function. Currently we use a trick to get\n * this length with very little changes to the code. In the future\n * we could switch to a faster solution. */\nsize_t rdbSavedObjectLen(robj *o, robj *key) {\n    ssize_t len = rdbSaveObject(NULL,o,key);\n    serverAssertWithInfo(NULL,o,len != -1);\n    return len;\n}\n\n/* Save a key-value pair, with expire time, type, key, value.\n * On error -1 is returned.\n * On success if the key was actually saved 1 is returned, otherwise 0\n * is returned (the key was already expired). */\nint rdbSaveKeyValuePair(rio *rdb, robj *key, robj *val, long long expiretime) {\n    int savelru = server.maxmemory_policy & MAXMEMORY_FLAG_LRU;\n    int savelfu = server.maxmemory_policy & MAXMEMORY_FLAG_LFU;\n\n    /* Save the expire time */\n    if (expiretime != -1) {\n        if (rdbSaveType(rdb,RDB_OPCODE_EXPIRETIME_MS) == -1) return -1;\n        if (rdbSaveMillisecondTime(rdb,expiretime) == -1) return -1;\n    }\n\n    /* Save the LRU info. */\n    if (savelru) {\n        uint64_t idletime = estimateObjectIdleTime(val);\n        idletime /= 1000; /* Using seconds is enough and requires less space.*/\n        if (rdbSaveType(rdb,RDB_OPCODE_IDLE) == -1) return -1;\n        if (rdbSaveLen(rdb,idletime) == -1) return -1;\n    }\n\n    /* Save the LFU info. */\n    if (savelfu) {\n        uint8_t buf[1];\n        buf[0] = LFUDecrAndReturn(val);\n        /* We can encode this in exactly two bytes: the opcode and an 8\n         * bit counter, since the frequency is logarithmic with a 0-255 range.\n         * Note that we do not store the halving time because to reset it\n         * a single time when loading does not affect the frequency much. */\n        if (rdbSaveType(rdb,RDB_OPCODE_FREQ) == -1) return -1;\n        if (rdbWriteRaw(rdb,buf,1) == -1) return -1;\n    }\n\n    /* Save type, key, value */\n    if (rdbSaveObjectType(rdb,val) == -1) return -1;\n    if (rdbSaveStringObject(rdb,key) == -1) return -1;\n    if (rdbSaveObject(rdb,val,key) == -1) return -1;\n\n    /* Delay return if required (for testing) */\n    if (server.rdb_key_save_delay)\n        usleep(server.rdb_key_save_delay);\n\n    return 1;\n}\n\n/* Save an AUX field. */\nssize_t rdbSaveAuxField(rio *rdb, void *key, size_t keylen, void *val, size_t vallen) {\n    ssize_t ret, len = 0;\n    if ((ret = rdbSaveType(rdb,RDB_OPCODE_AUX)) == -1) return -1;\n    len += ret;\n    if ((ret = rdbSaveRawString(rdb,key,keylen)) == -1) return -1;\n    len += ret;\n    if ((ret = rdbSaveRawString(rdb,val,vallen)) == -1) return -1;\n    len += ret;\n    return len;\n}\n\n/* Wrapper for rdbSaveAuxField() used when key/val length can be obtained\n * with strlen(). */\nssize_t rdbSaveAuxFieldStrStr(rio *rdb, char *key, char *val) {\n    return rdbSaveAuxField(rdb,key,strlen(key),val,strlen(val));\n}\n\n/* Wrapper for strlen(key) + integer type (up to long long range). */\nssize_t rdbSaveAuxFieldStrInt(rio *rdb, char *key, long long val) {\n    char buf[LONG_STR_SIZE];\n    int vlen = ll2string(buf,sizeof(buf),val);\n    return rdbSaveAuxField(rdb,key,strlen(key),buf,vlen);\n}\n\n/* Save a few default AUX fields with information about the RDB generated. */\nint rdbSaveInfoAuxFields(rio *rdb, int rdbflags, rdbSaveInfo *rsi) {\n    int redis_bits = (sizeof(void*) == 8) ? 64 : 32;\n    int aof_preamble = (rdbflags & RDBFLAGS_AOF_PREAMBLE) != 0;\n\n    /* Add a few fields about the state when the RDB was created. */\n    if (rdbSaveAuxFieldStrStr(rdb,\"redis-ver\",REDIS_VERSION) == -1) return -1;\n    if (rdbSaveAuxFieldStrInt(rdb,\"redis-bits\",redis_bits) == -1) return -1;\n    if (rdbSaveAuxFieldStrInt(rdb,\"ctime\",time(NULL)) == -1) return -1;\n    if (rdbSaveAuxFieldStrInt(rdb,\"used-mem\",zmalloc_used_memory()) == -1) return -1;\n\n    /* Handle saving options that generate aux fields. */\n    if (rsi) {\n        if (rdbSaveAuxFieldStrInt(rdb,\"repl-stream-db\",rsi->repl_stream_db)\n            == -1) return -1;\n        if (rdbSaveAuxFieldStrStr(rdb,\"repl-id\",server.replid)\n            == -1) return -1;\n        if (rdbSaveAuxFieldStrInt(rdb,\"repl-offset\",server.master_repl_offset)\n            == -1) return -1;\n    }\n    if (rdbSaveAuxFieldStrInt(rdb,\"aof-preamble\",aof_preamble) == -1) return -1;\n    return 1;\n}\n\nssize_t rdbSaveSingleModuleAux(rio *rdb, int when, moduleType *mt) {\n    /* Save a module-specific aux value. */\n    RedisModuleIO io;\n    int retval = rdbSaveType(rdb, RDB_OPCODE_MODULE_AUX);\n    if (retval == -1) return -1;\n    io.bytes += retval;\n\n    /* Write the \"module\" identifier as prefix, so that we'll be able\n     * to call the right module during loading. */\n    retval = rdbSaveLen(rdb,mt->id);\n    if (retval == -1) return -1;\n    io.bytes += retval;\n\n    /* write the 'when' so that we can provide it on loading. add a UINT opcode\n     * for backwards compatibility, everything after the MT needs to be prefixed\n     * by an opcode. */\n    retval = rdbSaveLen(rdb,RDB_MODULE_OPCODE_UINT);\n    if (retval == -1) return -1;\n    io.bytes += retval;\n    retval = rdbSaveLen(rdb,when);\n    if (retval == -1) return -1;\n    io.bytes += retval;\n\n    /* Then write the module-specific representation + EOF marker. */\n    moduleInitIOContext(io,mt,rdb,NULL);\n    mt->aux_save(&io,when);\n    retval = rdbSaveLen(rdb,RDB_MODULE_OPCODE_EOF);\n    if (retval == -1)\n        io.error = 1;\n    else\n        io.bytes += retval;\n\n    if (io.ctx) {\n        moduleFreeContext(io.ctx);\n        zfree(io.ctx);\n    }\n    if (io.error)\n        return -1;\n    return io.bytes;\n}\n\n/* Produces a dump of the database in RDB format sending it to the specified\n * Redis I/O channel. On success C_OK is returned, otherwise C_ERR\n * is returned and part of the output, or all the output, can be\n * missing because of I/O errors.\n *\n * When the function returns C_ERR and if 'error' is not NULL, the\n * integer pointed by 'error' is set to the value of errno just after the I/O\n * error. */\nint rdbSaveRio(rio *rdb, int *error, int rdbflags, rdbSaveInfo *rsi) {\n    dictIterator *di = NULL;\n    dictEntry *de;\n    char magic[10];\n    int j;\n    uint64_t cksum;\n    size_t processed = 0;\n\n    if (server.rdb_checksum)\n        rdb->update_cksum = rioGenericUpdateChecksum;\n    snprintf(magic,sizeof(magic),\"REDIS%04d\",RDB_VERSION);\n    if (rdbWriteRaw(rdb,magic,9) == -1) goto werr;\n    if (rdbSaveInfoAuxFields(rdb,rdbflags,rsi) == -1) goto werr;\n    if (rdbSaveModulesAux(rdb, REDISMODULE_AUX_BEFORE_RDB) == -1) goto werr;\n\n    for (j = 0; j < server.dbnum; j++) {\n        redisDb *db = server.db+j;\n        dict *d = db->dict;\n        if (dictSize(d) == 0) continue;\n        di = dictGetSafeIterator(d);\n\n        /* Write the SELECT DB opcode */\n        if (rdbSaveType(rdb,RDB_OPCODE_SELECTDB) == -1) goto werr;\n        if (rdbSaveLen(rdb,j) == -1) goto werr;\n\n        /* Write the RESIZE DB opcode. */\n        uint64_t db_size, expires_size;\n        db_size = dictSize(db->dict);\n        expires_size = dictSize(db->expires);\n        if (rdbSaveType(rdb,RDB_OPCODE_RESIZEDB) == -1) goto werr;\n        if (rdbSaveLen(rdb,db_size) == -1) goto werr;\n        if (rdbSaveLen(rdb,expires_size) == -1) goto werr;\n\n        /* Iterate this DB writing every entry */\n        while((de = dictNext(di)) != NULL) {\n            sds keystr = dictGetKey(de);\n            robj key, *o = dictGetVal(de);\n            long long expire;\n\n            initStaticStringObject(key,keystr);\n            expire = getExpire(db,&key);\n            if (rdbSaveKeyValuePair(rdb,&key,o,expire) == -1) goto werr;\n\n            /* When this RDB is produced as part of an AOF rewrite, move\n             * accumulated diff from parent to child while rewriting in\n             * order to have a smaller final write. */\n            if (rdbflags & RDBFLAGS_AOF_PREAMBLE &&\n                rdb->processed_bytes > processed+AOF_READ_DIFF_INTERVAL_BYTES)\n            {\n                processed = rdb->processed_bytes;\n                aofReadDiffFromParent();\n            }\n        }\n        dictReleaseIterator(di);\n        di = NULL; /* So that we don't release it again on error. */\n    }\n\n    /* If we are storing the replication information on disk, persist\n     * the script cache as well: on successful PSYNC after a restart, we need\n     * to be able to process any EVALSHA inside the replication backlog the\n     * master will send us. */\n    if (rsi && dictSize(server.lua_scripts)) {\n        di = dictGetIterator(server.lua_scripts);\n        while((de = dictNext(di)) != NULL) {\n            robj *body = dictGetVal(de);\n            if (rdbSaveAuxField(rdb,\"lua\",3,body->ptr,sdslen(body->ptr)) == -1)\n                goto werr;\n        }\n        dictReleaseIterator(di);\n        di = NULL; /* So that we don't release it again on error. */\n    }\n\n    if (rdbSaveModulesAux(rdb, REDISMODULE_AUX_AFTER_RDB) == -1) goto werr;\n\n    /* EOF opcode */\n    if (rdbSaveType(rdb,RDB_OPCODE_EOF) == -1) goto werr;\n\n    /* CRC64 checksum. It will be zero if checksum computation is disabled, the\n     * loading code skips the check in this case. */\n    cksum = rdb->cksum;\n    memrev64ifbe(&cksum);\n    if (rioWrite(rdb,&cksum,8) == 0) goto werr;\n    return C_OK;\n\nwerr:\n    if (error) *error = errno;\n    if (di) dictReleaseIterator(di);\n    return C_ERR;\n}\n\n/* This is just a wrapper to rdbSaveRio() that additionally adds a prefix\n * and a suffix to the generated RDB dump. The prefix is:\n *\n * $EOF:<40 bytes unguessable hex string>\\r\\n\n *\n * While the suffix is the 40 bytes hex string we announced in the prefix.\n * This way processes receiving the payload can understand when it ends\n * without doing any processing of the content. */\nint rdbSaveRioWithEOFMark(rio *rdb, int *error, rdbSaveInfo *rsi) {\n    char eofmark[RDB_EOF_MARK_SIZE];\n\n    startSaving(RDBFLAGS_REPLICATION);\n    getRandomHexChars(eofmark,RDB_EOF_MARK_SIZE);\n    if (error) *error = 0;\n    if (rioWrite(rdb,\"$EOF:\",5) == 0) goto werr;\n    if (rioWrite(rdb,eofmark,RDB_EOF_MARK_SIZE) == 0) goto werr;\n    if (rioWrite(rdb,\"\\r\\n\",2) == 0) goto werr;\n    if (rdbSaveRio(rdb,error,RDBFLAGS_NONE,rsi) == C_ERR) goto werr;\n    if (rioWrite(rdb,eofmark,RDB_EOF_MARK_SIZE) == 0) goto werr;\n    stopSaving(1);\n    return C_OK;\n\nwerr: /* Write error. */\n    /* Set 'error' only if not already set by rdbSaveRio() call. */\n    if (error && *error == 0) *error = errno;\n    stopSaving(0);\n    return C_ERR;\n}\n\n/* Save the DB on disk. Return C_ERR on error, C_OK on success. */\nint rdbSave(char *filename, rdbSaveInfo *rsi) {\n    char tmpfile[256];\n    char cwd[MAXPATHLEN]; /* Current working dir path for error messages. */\n    FILE *fp = NULL;\n    rio rdb;\n    int error = 0;\n\n    snprintf(tmpfile,256,\"temp-%d.rdb\", (int) getpid());\n    fp = fopen(tmpfile,\"w\");\n    if (!fp) {\n        char *cwdp = getcwd(cwd,MAXPATHLEN);\n        serverLog(LL_WARNING,\n            \"Failed opening the RDB file %s (in server root dir %s) \"\n            \"for saving: %s\",\n            filename,\n            cwdp ? cwdp : \"unknown\",\n            strerror(errno));\n        return C_ERR;\n    }\n\n    rioInitWithFile(&rdb,fp);\n    startSaving(RDBFLAGS_NONE);\n\n    if (server.rdb_save_incremental_fsync)\n        rioSetAutoSync(&rdb,REDIS_AUTOSYNC_BYTES);\n\n    if (rdbSaveRio(&rdb,&error,RDBFLAGS_NONE,rsi) == C_ERR) {\n        errno = error;\n        goto werr;\n    }\n\n    /* Make sure data will not remain on the OS's output buffers */\n    if (fflush(fp)) goto werr;\n    if (fsync(fileno(fp))) goto werr;\n    if (fclose(fp)) { fp = NULL; goto werr; }\n    fp = NULL;\n    \n    /* Use RENAME to make sure the DB file is changed atomically only\n     * if the generate DB file is ok. */\n    if (rename(tmpfile,filename) == -1) {\n        char *cwdp = getcwd(cwd,MAXPATHLEN);\n        serverLog(LL_WARNING,\n            \"Error moving temp DB file %s on the final \"\n            \"destination %s (in server root dir %s): %s\",\n            tmpfile,\n            filename,\n            cwdp ? cwdp : \"unknown\",\n            strerror(errno));\n        unlink(tmpfile);\n        stopSaving(0);\n        return C_ERR;\n    }\n\n    serverLog(LL_NOTICE,\"DB saved on disk\");\n    server.dirty = 0;\n    server.lastsave = time(NULL);\n    server.lastbgsave_status = C_OK;\n    stopSaving(1);\n    return C_OK;\n\nwerr:\n    serverLog(LL_WARNING,\"Write error saving DB on disk: %s\", strerror(errno));\n    if (fp) fclose(fp);\n    unlink(tmpfile);\n    stopSaving(0);\n    return C_ERR;\n}\n\nint rdbSaveBackground(char *filename, rdbSaveInfo *rsi) {\n    pid_t childpid;\n\n    if (hasActiveChildProcess()) return C_ERR;\n\n    server.dirty_before_bgsave = server.dirty;\n    server.lastbgsave_try = time(NULL);\n    openChildInfoPipe();\n\n    if ((childpid = redisFork(CHILD_TYPE_RDB)) == 0) {\n        int retval;\n\n        /* Child */\n        redisSetProcTitle(\"redis-rdb-bgsave\");\n        redisSetCpuAffinity(server.bgsave_cpulist);\n        retval = rdbSave(filename,rsi);\n        if (retval == C_OK) {\n            sendChildCOWInfo(CHILD_TYPE_RDB, \"RDB\");\n        }\n        exitFromChild((retval == C_OK) ? 0 : 1);\n    } else {\n        /* Parent */\n        if (childpid == -1) {\n            closeChildInfoPipe();\n            server.lastbgsave_status = C_ERR;\n            serverLog(LL_WARNING,\"Can't save in background: fork: %s\",\n                strerror(errno));\n            return C_ERR;\n        }\n        serverLog(LL_NOTICE,\"Background saving started by pid %d\",childpid);\n        server.rdb_save_time_start = time(NULL);\n        server.rdb_child_pid = childpid;\n        server.rdb_child_type = RDB_CHILD_TYPE_DISK;\n        updateDictResizePolicy();\n        return C_OK;\n    }\n    return C_OK; /* unreached */\n}\n\n/* Note that we may call this function in signal handle 'sigShutdownHandler',\n * so we need guarantee all functions we call are async-signal-safe.\n * If  we call this function from signal handle, we won't call bg_unlik that\n * is not async-signal-safe. */\nvoid rdbRemoveTempFile(pid_t childpid, int from_signal) {\n    char tmpfile[256];\n    char pid[32];\n\n    /* Generate temp rdb file name using aync-signal safe functions. */\n    int pid_len = ll2string(pid, sizeof(pid), childpid);\n    strcpy(tmpfile, \"temp-\");\n    strncpy(tmpfile+5, pid, pid_len);\n    strcpy(tmpfile+5+pid_len, \".rdb\");\n\n    if (from_signal) {\n        /* bg_unlink is not async-signal-safe, but in this case we don't really\n         * need to close the fd, it'll be released when the process exists. */\n        int fd = open(tmpfile, O_RDONLY|O_NONBLOCK);\n        UNUSED(fd);\n        unlink(tmpfile);\n    } else {\n        bg_unlink(tmpfile);\n    }\n}\n\n/* This function is called by rdbLoadObject() when the code is in RDB-check\n * mode and we find a module value of type 2 that can be parsed without\n * the need of the actual module. The value is parsed for errors, finally\n * a dummy redis object is returned just to conform to the API. */\nrobj *rdbLoadCheckModuleValue(rio *rdb, char *modulename) {\n    uint64_t opcode;\n    while((opcode = rdbLoadLen(rdb,NULL)) != RDB_MODULE_OPCODE_EOF) {\n        if (opcode == RDB_MODULE_OPCODE_SINT ||\n            opcode == RDB_MODULE_OPCODE_UINT)\n        {\n            uint64_t len;\n            if (rdbLoadLenByRef(rdb,NULL,&len) == -1) {\n                rdbExitReportCorruptRDB(\n                    \"Error reading integer from module %s value\", modulename);\n            }\n        } else if (opcode == RDB_MODULE_OPCODE_STRING) {\n            robj *o = rdbGenericLoadStringObject(rdb,RDB_LOAD_NONE,NULL);\n            if (o == NULL) {\n                rdbExitReportCorruptRDB(\n                    \"Error reading string from module %s value\", modulename);\n            }\n            decrRefCount(o);\n        } else if (opcode == RDB_MODULE_OPCODE_FLOAT) {\n            float val;\n            if (rdbLoadBinaryFloatValue(rdb,&val) == -1) {\n                rdbExitReportCorruptRDB(\n                    \"Error reading float from module %s value\", modulename);\n            }\n        } else if (opcode == RDB_MODULE_OPCODE_DOUBLE) {\n            double val;\n            if (rdbLoadBinaryDoubleValue(rdb,&val) == -1) {\n                rdbExitReportCorruptRDB(\n                    \"Error reading double from module %s value\", modulename);\n            }\n        }\n    }\n    return createStringObject(\"module-dummy-value\",18);\n}\n\n/* Load a Redis object of the specified type from the specified file.\n * On success a newly allocated object is returned, otherwise NULL. */\nrobj *rdbLoadObject(int rdbtype, rio *rdb, sds key) {\n    robj *o = NULL, *ele, *dec;\n    uint64_t len;\n    unsigned int i;\n\n    if (rdbtype == RDB_TYPE_STRING) {\n        /* Read string value */\n        if ((o = rdbLoadEncodedStringObject(rdb)) == NULL) return NULL;\n        o = tryObjectEncoding(o);\n    } else if (rdbtype == RDB_TYPE_LIST) {\n        /* Read list value */\n        if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;\n\n        o = createQuicklistObject();\n        quicklistSetOptions(o->ptr, server.list_max_ziplist_size,\n                            server.list_compress_depth);\n\n        /* Load every single element of the list */\n        while(len--) {\n            if ((ele = rdbLoadEncodedStringObject(rdb)) == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n            dec = getDecodedObject(ele);\n            size_t len = sdslen(dec->ptr);\n            quicklistPushTail(o->ptr, dec->ptr, len);\n            decrRefCount(dec);\n            decrRefCount(ele);\n        }\n    } else if (rdbtype == RDB_TYPE_SET) {\n        /* Read Set value */\n        if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;\n\n        /* Use a regular set when there are too many entries. */\n        size_t max_entries = server.set_max_intset_entries;\n        if (max_entries >= 1<<30) max_entries = 1<<30;\n        if (len > max_entries) {\n            o = createSetObject();\n            /* It's faster to expand the dict to the right size asap in order\n             * to avoid rehashing */\n            if (len > DICT_HT_INITIAL_SIZE)\n                dictExpand(o->ptr,len);\n        } else {\n            o = createIntsetObject();\n        }\n\n        /* Load every single element of the set */\n        for (i = 0; i < len; i++) {\n            long long llval;\n            sds sdsele;\n\n            if ((sdsele = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n\n            if (o->encoding == OBJ_ENCODING_INTSET) {\n                /* Fetch integer value from element. */\n                if (isSdsRepresentableAsLongLong(sdsele,&llval) == C_OK) {\n                    o->ptr = intsetAdd(o->ptr,llval,NULL);\n                } else {\n                    setTypeConvert(o,OBJ_ENCODING_HT);\n                    dictExpand(o->ptr,len);\n                }\n            }\n\n            /* This will also be called when the set was just converted\n             * to a regular hash table encoded set. */\n            if (o->encoding == OBJ_ENCODING_HT) {\n                dictAdd((dict*)o->ptr,sdsele,NULL);\n            } else {\n                sdsfree(sdsele);\n            }\n        }\n    } else if (rdbtype == RDB_TYPE_ZSET_2 || rdbtype == RDB_TYPE_ZSET) {\n        /* Read list/set value. */\n        uint64_t zsetlen;\n        size_t maxelelen = 0;\n        zset *zs;\n\n        if ((zsetlen = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;\n        o = createZsetObject();\n        zs = o->ptr;\n\n        if (zsetlen > DICT_HT_INITIAL_SIZE)\n            dictExpand(zs->dict,zsetlen);\n\n        /* Load every single element of the sorted set. */\n        while(zsetlen--) {\n            sds sdsele;\n            double score;\n            zskiplistNode *znode;\n\n            if ((sdsele = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n\n            if (rdbtype == RDB_TYPE_ZSET_2) {\n                if (rdbLoadBinaryDoubleValue(rdb,&score) == -1) {\n                    decrRefCount(o);\n                    sdsfree(sdsele);\n                    return NULL;\n                }\n            } else {\n                if (rdbLoadDoubleValue(rdb,&score) == -1) {\n                    decrRefCount(o);\n                    sdsfree(sdsele);\n                    return NULL;\n                }\n            }\n\n            /* Don't care about integer-encoded strings. */\n            if (sdslen(sdsele) > maxelelen) maxelelen = sdslen(sdsele);\n\n            znode = zslInsert(zs->zsl,score,sdsele);\n            dictAdd(zs->dict,sdsele,&znode->score);\n        }\n\n        /* Convert *after* loading, since sorted sets are not stored ordered. */\n        if (zsetLength(o) <= server.zset_max_ziplist_entries &&\n            maxelelen <= server.zset_max_ziplist_value)\n                zsetConvert(o,OBJ_ENCODING_ZIPLIST);\n    } else if (rdbtype == RDB_TYPE_HASH) {\n        uint64_t len;\n        int ret;\n        sds field, value;\n\n        len = rdbLoadLen(rdb, NULL);\n        if (len == RDB_LENERR) return NULL;\n\n        o = createHashObject();\n\n        /* Too many entries? Use a hash table. */\n        if (len > server.hash_max_ziplist_entries)\n            hashTypeConvert(o, OBJ_ENCODING_HT);\n\n        /* Load every field and value into the ziplist */\n        while (o->encoding == OBJ_ENCODING_ZIPLIST && len > 0) {\n            len--;\n            /* Load raw strings */\n            if ((field = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n            if ((value = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                sdsfree(field);\n                decrRefCount(o);\n                return NULL;\n            }\n\n            /* Add pair to ziplist */\n            o->ptr = ziplistPush(o->ptr, (unsigned char*)field,\n                    sdslen(field), ZIPLIST_TAIL);\n            o->ptr = ziplistPush(o->ptr, (unsigned char*)value,\n                    sdslen(value), ZIPLIST_TAIL);\n\n            /* Convert to hash table if size threshold is exceeded */\n            if (sdslen(field) > server.hash_max_ziplist_value ||\n                sdslen(value) > server.hash_max_ziplist_value)\n            {\n                sdsfree(field);\n                sdsfree(value);\n                hashTypeConvert(o, OBJ_ENCODING_HT);\n                break;\n            }\n            sdsfree(field);\n            sdsfree(value);\n        }\n\n        if (o->encoding == OBJ_ENCODING_HT && len > DICT_HT_INITIAL_SIZE)\n            dictExpand(o->ptr,len);\n\n        /* Load remaining fields and values into the hash table */\n        while (o->encoding == OBJ_ENCODING_HT && len > 0) {\n            len--;\n            /* Load encoded strings */\n            if ((field = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n            if ((value = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                sdsfree(field);\n                decrRefCount(o);\n                return NULL;\n            }\n\n            /* Add pair to hash table */\n            ret = dictAdd((dict*)o->ptr, field, value);\n            if (ret == DICT_ERR) {\n                rdbExitReportCorruptRDB(\"Duplicate keys detected\");\n            }\n        }\n\n        /* All pairs should be read by now */\n        serverAssert(len == 0);\n    } else if (rdbtype == RDB_TYPE_LIST_QUICKLIST) {\n        if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;\n        o = createQuicklistObject();\n        quicklistSetOptions(o->ptr, server.list_max_ziplist_size,\n                            server.list_compress_depth);\n\n        while (len--) {\n            unsigned char *zl =\n                rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN,NULL);\n            if (zl == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n            quicklistAppendZiplist(o->ptr, zl);\n        }\n    } else if (rdbtype == RDB_TYPE_HASH_ZIPMAP  ||\n               rdbtype == RDB_TYPE_LIST_ZIPLIST ||\n               rdbtype == RDB_TYPE_SET_INTSET   ||\n               rdbtype == RDB_TYPE_ZSET_ZIPLIST ||\n               rdbtype == RDB_TYPE_HASH_ZIPLIST)\n    {\n        unsigned char *encoded =\n            rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN,NULL);\n        if (encoded == NULL) return NULL;\n        o = createObject(OBJ_STRING,encoded); /* Obj type fixed below. */\n\n        /* Fix the object encoding, and make sure to convert the encoded\n         * data type into the base type if accordingly to the current\n         * configuration there are too many elements in the encoded data\n         * type. Note that we only check the length and not max element\n         * size as this is an O(N) scan. Eventually everything will get\n         * converted. */\n        switch(rdbtype) {\n            case RDB_TYPE_HASH_ZIPMAP:\n                /* Convert to ziplist encoded hash. This must be deprecated\n                 * when loading dumps created by Redis 2.4 gets deprecated. */\n                {\n                    unsigned char *zl = ziplistNew();\n                    unsigned char *zi = zipmapRewind(o->ptr);\n                    unsigned char *fstr, *vstr;\n                    unsigned int flen, vlen;\n                    unsigned int maxlen = 0;\n\n                    while ((zi = zipmapNext(zi, &fstr, &flen, &vstr, &vlen)) != NULL) {\n                        if (flen > maxlen) maxlen = flen;\n                        if (vlen > maxlen) maxlen = vlen;\n                        zl = ziplistPush(zl, fstr, flen, ZIPLIST_TAIL);\n                        zl = ziplistPush(zl, vstr, vlen, ZIPLIST_TAIL);\n                    }\n\n                    zfree(o->ptr);\n                    o->ptr = zl;\n                    o->type = OBJ_HASH;\n                    o->encoding = OBJ_ENCODING_ZIPLIST;\n\n                    if (hashTypeLength(o) > server.hash_max_ziplist_entries ||\n                        maxlen > server.hash_max_ziplist_value)\n                    {\n                        hashTypeConvert(o, OBJ_ENCODING_HT);\n                    }\n                }\n                break;\n            case RDB_TYPE_LIST_ZIPLIST:\n                o->type = OBJ_LIST;\n                o->encoding = OBJ_ENCODING_ZIPLIST;\n                listTypeConvert(o,OBJ_ENCODING_QUICKLIST);\n                break;\n            case RDB_TYPE_SET_INTSET:\n                o->type = OBJ_SET;\n                o->encoding = OBJ_ENCODING_INTSET;\n                if (intsetLen(o->ptr) > server.set_max_intset_entries)\n                    setTypeConvert(o,OBJ_ENCODING_HT);\n                break;\n            case RDB_TYPE_ZSET_ZIPLIST:\n                o->type = OBJ_ZSET;\n                o->encoding = OBJ_ENCODING_ZIPLIST;\n                if (zsetLength(o) > server.zset_max_ziplist_entries)\n                    zsetConvert(o,OBJ_ENCODING_SKIPLIST);\n                break;\n            case RDB_TYPE_HASH_ZIPLIST:\n                o->type = OBJ_HASH;\n                o->encoding = OBJ_ENCODING_ZIPLIST;\n                if (hashTypeLength(o) > server.hash_max_ziplist_entries)\n                    hashTypeConvert(o, OBJ_ENCODING_HT);\n                break;\n            default:\n                /* totally unreachable */\n                rdbExitReportCorruptRDB(\"Unknown RDB encoding type %d\",rdbtype);\n                break;\n        }\n    } else if (rdbtype == RDB_TYPE_STREAM_LISTPACKS) {\n        o = createStreamObject();\n        stream *s = o->ptr;\n        uint64_t listpacks = rdbLoadLen(rdb,NULL);\n        if (listpacks == RDB_LENERR) {\n            rdbReportReadError(\"Stream listpacks len loading failed.\");\n            decrRefCount(o);\n            return NULL;\n        }\n\n        while(listpacks--) {\n            /* Get the master ID, the one we'll use as key of the radix tree\n             * node: the entries inside the listpack itself are delta-encoded\n             * relatively to this ID. */\n            sds nodekey = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL);\n            if (nodekey == NULL) {\n                rdbReportReadError(\"Stream master ID loading failed: invalid encoding or I/O error.\");\n                decrRefCount(o);\n                return NULL;\n            }\n            if (sdslen(nodekey) != sizeof(streamID)) {\n                rdbExitReportCorruptRDB(\"Stream node key entry is not the \"\n                                        \"size of a stream ID\");\n            }\n\n            /* Load the listpack. */\n            unsigned char *lp =\n                rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN,NULL);\n            if (lp == NULL) {\n                rdbReportReadError(\"Stream listpacks loading failed.\");\n                sdsfree(nodekey);\n                decrRefCount(o);\n                return NULL;\n            }\n            unsigned char *first = lpFirst(lp);\n            if (first == NULL) {\n                /* Serialized listpacks should never be empty, since on\n                 * deletion we should remove the radix tree key if the\n                 * resulting listpack is empty. */\n                rdbExitReportCorruptRDB(\"Empty listpack inside stream\");\n            }\n\n            /* Insert the key in the radix tree. */\n            int retval = raxInsert(s->rax,\n                (unsigned char*)nodekey,sizeof(streamID),lp,NULL);\n            sdsfree(nodekey);\n            if (!retval)\n                rdbExitReportCorruptRDB(\"Listpack re-added with existing key\");\n        }\n        /* Load total number of items inside the stream. */\n        s->length = rdbLoadLen(rdb,NULL);\n\n        /* Load the last entry ID. */\n        s->last_id.ms = rdbLoadLen(rdb,NULL);\n        s->last_id.seq = rdbLoadLen(rdb,NULL);\n\n        if (rioGetReadError(rdb)) {\n            rdbReportReadError(\"Stream object metadata loading failed.\");\n            decrRefCount(o);\n            return NULL;\n        }\n\n        /* Consumer groups loading */\n        uint64_t cgroups_count = rdbLoadLen(rdb,NULL);\n        if (cgroups_count == RDB_LENERR) {\n            rdbReportReadError(\"Stream cgroup count loading failed.\");\n            decrRefCount(o);\n            return NULL;\n        }\n        while(cgroups_count--) {\n            /* Get the consumer group name and ID. We can then create the\n             * consumer group ASAP and populate its structure as\n             * we read more data. */\n            streamID cg_id;\n            sds cgname = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL);\n            if (cgname == NULL) {\n                rdbReportReadError(\n                    \"Error reading the consumer group name from Stream\");\n                decrRefCount(o);\n                return NULL;\n            }\n\n            cg_id.ms = rdbLoadLen(rdb,NULL);\n            cg_id.seq = rdbLoadLen(rdb,NULL);\n            if (rioGetReadError(rdb)) {\n                rdbReportReadError(\"Stream cgroup ID loading failed.\");\n                sdsfree(cgname);\n                decrRefCount(o);\n                return NULL;\n            }\n\n            streamCG *cgroup = streamCreateCG(s,cgname,sdslen(cgname),&cg_id);\n            if (cgroup == NULL)\n                rdbExitReportCorruptRDB(\"Duplicated consumer group name %s\",\n                                         cgname);\n            sdsfree(cgname);\n\n            /* Load the global PEL for this consumer group, however we'll\n             * not yet populate the NACK structures with the message\n             * owner, since consumers for this group and their messages will\n             * be read as a next step. So for now leave them not resolved\n             * and later populate it. */\n            uint64_t pel_size = rdbLoadLen(rdb,NULL);\n            if (pel_size == RDB_LENERR) {\n                rdbReportReadError(\"Stream PEL size loading failed.\");\n                decrRefCount(o);\n                return NULL;\n            }\n            while(pel_size--) {\n                unsigned char rawid[sizeof(streamID)];\n                if (rioRead(rdb,rawid,sizeof(rawid)) == 0) {\n                    rdbReportReadError(\"Stream PEL ID loading failed.\");\n                    decrRefCount(o);\n                    return NULL;\n                }\n                streamNACK *nack = streamCreateNACK(NULL);\n                nack->delivery_time = rdbLoadMillisecondTime(rdb,RDB_VERSION);\n                nack->delivery_count = rdbLoadLen(rdb,NULL);\n                if (rioGetReadError(rdb)) {\n                    rdbReportReadError(\"Stream PEL NACK loading failed.\");\n                    decrRefCount(o);\n                    streamFreeNACK(nack);\n                    return NULL;\n                }\n                if (!raxInsert(cgroup->pel,rawid,sizeof(rawid),nack,NULL))\n                    rdbExitReportCorruptRDB(\"Duplicated gobal PEL entry \"\n                                            \"loading stream consumer group\");\n            }\n\n            /* Now that we loaded our global PEL, we need to load the\n             * consumers and their local PELs. */\n            uint64_t consumers_num = rdbLoadLen(rdb,NULL);\n            if (consumers_num == RDB_LENERR) {\n                rdbReportReadError(\"Stream consumers num loading failed.\");\n                decrRefCount(o);\n                return NULL;\n            }\n            while(consumers_num--) {\n                sds cname = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL);\n                if (cname == NULL) {\n                    rdbReportReadError(\n                        \"Error reading the consumer name from Stream group.\");\n                    decrRefCount(o);\n                    return NULL;\n                }\n                streamConsumer *consumer =\n                    streamLookupConsumer(cgroup,cname,SLC_NONE);\n                sdsfree(cname);\n                consumer->seen_time = rdbLoadMillisecondTime(rdb,RDB_VERSION);\n                if (rioGetReadError(rdb)) {\n                    rdbReportReadError(\"Stream short read reading seen time.\");\n                    decrRefCount(o);\n                    return NULL;\n                }\n\n                /* Load the PEL about entries owned by this specific\n                 * consumer. */\n                pel_size = rdbLoadLen(rdb,NULL);\n                if (pel_size == RDB_LENERR) {\n                    rdbReportReadError(\n                        \"Stream consumer PEL num loading failed.\");\n                    decrRefCount(o);\n                    return NULL;\n                }\n                while(pel_size--) {\n                    unsigned char rawid[sizeof(streamID)];\n                    if (rioRead(rdb,rawid,sizeof(rawid)) == 0) {\n                        rdbReportReadError(\n                            \"Stream short read reading PEL streamID.\");\n                        decrRefCount(o);\n                        return NULL;\n                    }\n                    streamNACK *nack = raxFind(cgroup->pel,rawid,sizeof(rawid));\n                    if (nack == raxNotFound)\n                        rdbExitReportCorruptRDB(\"Consumer entry not found in \"\n                                                \"group global PEL\");\n\n                    /* Set the NACK consumer, that was left to NULL when\n                     * loading the global PEL. Then set the same shared\n                     * NACK structure also in the consumer-specific PEL. */\n                    nack->consumer = consumer;\n                    if (!raxInsert(consumer->pel,rawid,sizeof(rawid),nack,NULL))\n                        rdbExitReportCorruptRDB(\"Duplicated consumer PEL entry \"\n                                                \" loading a stream consumer \"\n                                                \"group\");\n                }\n            }\n        }\n    } else if (rdbtype == RDB_TYPE_MODULE || rdbtype == RDB_TYPE_MODULE_2) {\n        uint64_t moduleid = rdbLoadLen(rdb,NULL);\n        if (rioGetReadError(rdb)) {\n            rdbReportReadError(\"Short read module id\");\n            return NULL;\n        }\n        moduleType *mt = moduleTypeLookupModuleByID(moduleid);\n        char name[10];\n\n        if (rdbCheckMode && rdbtype == RDB_TYPE_MODULE_2) {\n            moduleTypeNameByID(name,moduleid);\n            return rdbLoadCheckModuleValue(rdb,name);\n        }\n\n        if (mt == NULL) {\n            moduleTypeNameByID(name,moduleid);\n            serverLog(LL_WARNING,\"The RDB file contains module data I can't load: no matching module '%s'\", name);\n            exit(1);\n        }\n        RedisModuleIO io;\n        robj keyobj;\n        initStaticStringObject(keyobj,key);\n        moduleInitIOContext(io,mt,rdb,&keyobj);\n        io.ver = (rdbtype == RDB_TYPE_MODULE) ? 1 : 2;\n        /* Call the rdb_load method of the module providing the 10 bit\n         * encoding version in the lower 10 bits of the module ID. */\n        void *ptr = mt->rdb_load(&io,moduleid&1023);\n        if (io.ctx) {\n            moduleFreeContext(io.ctx);\n            zfree(io.ctx);\n        }\n\n        /* Module v2 serialization has an EOF mark at the end. */\n        if (io.ver == 2) {\n            uint64_t eof = rdbLoadLen(rdb,NULL);\n            if (eof == RDB_LENERR) {\n                o = createModuleObject(mt,ptr); /* creating just in order to easily destroy */\n                decrRefCount(o);\n                return NULL;\n            }\n            if (eof != RDB_MODULE_OPCODE_EOF) {\n                serverLog(LL_WARNING,\"The RDB file contains module data for the module '%s' that is not terminated by the proper module value EOF marker\", name);\n                exit(1);\n            }\n        }\n\n        if (ptr == NULL) {\n            moduleTypeNameByID(name,moduleid);\n            serverLog(LL_WARNING,\"The RDB file contains module data for the module type '%s', that the responsible module is not able to load. Check for modules log above for additional clues.\", name);\n            exit(1);\n        }\n        o = createModuleObject(mt,ptr);\n    } else {\n        rdbReportReadError(\"Unknown RDB encoding type %d\",rdbtype);\n        return NULL;\n    }\n    return o;\n}\n\n/* Mark that we are loading in the global state and setup the fields\n * needed to provide loading stats. */\nvoid startLoading(size_t size, int rdbflags) {\n    /* Load the DB */\n    server.loading = 1;\n    server.loading_start_time = time(NULL);\n    server.loading_loaded_bytes = 0;\n    server.loading_total_bytes = size;\n\n    /* Fire the loading modules start event. */\n    int subevent;\n    if (rdbflags & RDBFLAGS_AOF_PREAMBLE)\n        subevent = REDISMODULE_SUBEVENT_LOADING_AOF_START;\n    else if(rdbflags & RDBFLAGS_REPLICATION)\n        subevent = REDISMODULE_SUBEVENT_LOADING_REPL_START;\n    else\n        subevent = REDISMODULE_SUBEVENT_LOADING_RDB_START;\n    moduleFireServerEvent(REDISMODULE_EVENT_LOADING,subevent,NULL);\n}\n\n/* Mark that we are loading in the global state and setup the fields\n * needed to provide loading stats.\n * 'filename' is optional and used for rdb-check on error */\nvoid startLoadingFile(FILE *fp, char* filename, int rdbflags) {\n    struct stat sb;\n    if (fstat(fileno(fp), &sb) == -1)\n        sb.st_size = 0;\n    rdbFileBeingLoaded = filename;\n    startLoading(sb.st_size, rdbflags);\n}\n\n/* Refresh the loading progress info */\nvoid loadingProgress(off_t pos) {\n    server.loading_loaded_bytes = pos;\n    if (server.stat_peak_memory < zmalloc_used_memory())\n        server.stat_peak_memory = zmalloc_used_memory();\n}\n\n/* Loading finished */\nvoid stopLoading(int success) {\n    server.loading = 0;\n    rdbFileBeingLoaded = NULL;\n\n    /* Fire the loading modules end event. */\n    moduleFireServerEvent(REDISMODULE_EVENT_LOADING,\n                          success?\n                            REDISMODULE_SUBEVENT_LOADING_ENDED:\n                            REDISMODULE_SUBEVENT_LOADING_FAILED,\n                          NULL);\n}\n\nvoid startSaving(int rdbflags) {\n    /* Fire the persistence modules end event. */\n    int subevent;\n    if (rdbflags & RDBFLAGS_AOF_PREAMBLE)\n        subevent = REDISMODULE_SUBEVENT_PERSISTENCE_AOF_START;\n    else if (getpid()!=server.pid)\n        subevent = REDISMODULE_SUBEVENT_PERSISTENCE_RDB_START;\n    else\n        subevent = REDISMODULE_SUBEVENT_PERSISTENCE_SYNC_RDB_START;\n    moduleFireServerEvent(REDISMODULE_EVENT_PERSISTENCE,subevent,NULL);\n}\n\nvoid stopSaving(int success) {\n    /* Fire the persistence modules end event. */\n    moduleFireServerEvent(REDISMODULE_EVENT_PERSISTENCE,\n                          success?\n                            REDISMODULE_SUBEVENT_PERSISTENCE_ENDED:\n                            REDISMODULE_SUBEVENT_PERSISTENCE_FAILED,\n                          NULL);\n}\n\n/* Track loading progress in order to serve client's from time to time\n   and if needed calculate rdb checksum  */\nvoid rdbLoadProgressCallback(rio *r, const void *buf, size_t len) {\n    if (server.rdb_checksum)\n        rioGenericUpdateChecksum(r, buf, len);\n    if (server.loading_process_events_interval_bytes &&\n        (r->processed_bytes + len)/server.loading_process_events_interval_bytes > r->processed_bytes/server.loading_process_events_interval_bytes)\n    {\n        /* The DB can take some non trivial amount of time to load. Update\n         * our cached time since it is used to create and update the last\n         * interaction time with clients and for other important things. */\n        updateCachedTime(0);\n        if (server.masterhost && server.repl_state == REPL_STATE_TRANSFER)\n            replicationSendNewlineToMaster();\n        loadingProgress(r->processed_bytes);\n        processEventsWhileBlocked();\n        processModuleLoadingProgressEvent(0);\n    }\n}\n\n/* Load an RDB file from the rio stream 'rdb'. On success C_OK is returned,\n * otherwise C_ERR is returned and 'errno' is set accordingly. */\nint rdbLoadRio(rio *rdb, int rdbflags, rdbSaveInfo *rsi) {\n    uint64_t dbid;\n    int type, rdbver;\n    redisDb *db = server.db+0;\n    char buf[1024];\n\n    rdb->update_cksum = rdbLoadProgressCallback;\n    rdb->max_processing_chunk = server.loading_process_events_interval_bytes;\n    if (rioRead(rdb,buf,9) == 0) goto eoferr;\n    buf[9] = '\\0';\n    if (memcmp(buf,\"REDIS\",5) != 0) {\n        serverLog(LL_WARNING,\"Wrong signature trying to load DB from file\");\n        errno = EINVAL;\n        return C_ERR;\n    }\n    rdbver = atoi(buf+5);\n    if (rdbver < 1 || rdbver > RDB_VERSION) {\n        serverLog(LL_WARNING,\"Can't handle RDB format version %d\",rdbver);\n        errno = EINVAL;\n        return C_ERR;\n    }\n\n    /* Key-specific attributes, set by opcodes before the key type. */\n    long long lru_idle = -1, lfu_freq = -1, expiretime = -1, now = mstime();\n    long long lru_clock = LRU_CLOCK();\n\n    while(1) {\n        sds key;\n        robj *val;\n\n        /* Read type. */\n        if ((type = rdbLoadType(rdb)) == -1) goto eoferr;\n\n        /* Handle special types. */\n        if (type == RDB_OPCODE_EXPIRETIME) {\n            /* EXPIRETIME: load an expire associated with the next key\n             * to load. Note that after loading an expire we need to\n             * load the actual type, and continue. */\n            expiretime = rdbLoadTime(rdb);\n            expiretime *= 1000;\n            if (rioGetReadError(rdb)) goto eoferr;\n            continue; /* Read next opcode. */\n        } else if (type == RDB_OPCODE_EXPIRETIME_MS) {\n            /* EXPIRETIME_MS: milliseconds precision expire times introduced\n             * with RDB v3. Like EXPIRETIME but no with more precision. */\n            expiretime = rdbLoadMillisecondTime(rdb,rdbver);\n            if (rioGetReadError(rdb)) goto eoferr;\n            continue; /* Read next opcode. */\n        } else if (type == RDB_OPCODE_FREQ) {\n            /* FREQ: LFU frequency. */\n            uint8_t byte;\n            if (rioRead(rdb,&byte,1) == 0) goto eoferr;\n            lfu_freq = byte;\n            continue; /* Read next opcode. */\n        } else if (type == RDB_OPCODE_IDLE) {\n            /* IDLE: LRU idle time. */\n            uint64_t qword;\n            if ((qword = rdbLoadLen(rdb,NULL)) == RDB_LENERR) goto eoferr;\n            lru_idle = qword;\n            continue; /* Read next opcode. */\n        } else if (type == RDB_OPCODE_EOF) {\n            /* EOF: End of file, exit the main loop. */\n            break;\n        } else if (type == RDB_OPCODE_SELECTDB) {\n            /* SELECTDB: Select the specified database. */\n            if ((dbid = rdbLoadLen(rdb,NULL)) == RDB_LENERR) goto eoferr;\n            if (dbid >= (unsigned)server.dbnum) {\n                serverLog(LL_WARNING,\n                    \"FATAL: Data file was created with a Redis \"\n                    \"server configured to handle more than %d \"\n                    \"databases. Exiting\\n\", server.dbnum);\n                exit(1);\n            }\n            db = server.db+dbid;\n            continue; /* Read next opcode. */\n        } else if (type == RDB_OPCODE_RESIZEDB) {\n            /* RESIZEDB: Hint about the size of the keys in the currently\n             * selected data base, in order to avoid useless rehashing. */\n            uint64_t db_size, expires_size;\n            if ((db_size = rdbLoadLen(rdb,NULL)) == RDB_LENERR)\n                goto eoferr;\n            if ((expires_size = rdbLoadLen(rdb,NULL)) == RDB_LENERR)\n                goto eoferr;\n            dictExpand(db->dict,db_size);\n            dictExpand(db->expires,expires_size);\n            continue; /* Read next opcode. */\n        } else if (type == RDB_OPCODE_AUX) {\n            /* AUX: generic string-string fields. Use to add state to RDB\n             * which is backward compatible. Implementations of RDB loading\n             * are required to skip AUX fields they don't understand.\n             *\n             * An AUX field is composed of two strings: key and value. */\n            robj *auxkey, *auxval;\n            if ((auxkey = rdbLoadStringObject(rdb)) == NULL) goto eoferr;\n            if ((auxval = rdbLoadStringObject(rdb)) == NULL) goto eoferr;\n\n            if (((char*)auxkey->ptr)[0] == '%') {\n                /* All the fields with a name staring with '%' are considered\n                 * information fields and are logged at startup with a log\n                 * level of NOTICE. */\n                serverLog(LL_NOTICE,\"RDB '%s': %s\",\n                    (char*)auxkey->ptr,\n                    (char*)auxval->ptr);\n            } else if (!strcasecmp(auxkey->ptr,\"repl-stream-db\")) {\n                if (rsi) rsi->repl_stream_db = atoi(auxval->ptr);\n            } else if (!strcasecmp(auxkey->ptr,\"repl-id\")) {\n                if (rsi && sdslen(auxval->ptr) == CONFIG_RUN_ID_SIZE) {\n                    memcpy(rsi->repl_id,auxval->ptr,CONFIG_RUN_ID_SIZE+1);\n                    rsi->repl_id_is_set = 1;\n                }\n            } else if (!strcasecmp(auxkey->ptr,\"repl-offset\")) {\n                if (rsi) rsi->repl_offset = strtoll(auxval->ptr,NULL,10);\n            } else if (!strcasecmp(auxkey->ptr,\"lua\")) {\n                /* Load the script back in memory. */\n                if (luaCreateFunction(NULL,server.lua,auxval) == NULL) {\n                    rdbExitReportCorruptRDB(\n                        \"Can't load Lua script from RDB file! \"\n                        \"BODY: %s\", (char*)auxval->ptr);\n                }\n            } else if (!strcasecmp(auxkey->ptr,\"redis-ver\")) {\n                serverLog(LL_NOTICE,\"Loading RDB produced by version %s\",\n                    (char*)auxval->ptr);\n            } else if (!strcasecmp(auxkey->ptr,\"ctime\")) {\n                time_t age = time(NULL)-strtol(auxval->ptr,NULL,10);\n                if (age < 0) age = 0;\n                serverLog(LL_NOTICE,\"RDB age %ld seconds\",\n                    (unsigned long) age);\n            } else if (!strcasecmp(auxkey->ptr,\"used-mem\")) {\n                long long usedmem = strtoll(auxval->ptr,NULL,10);\n                serverLog(LL_NOTICE,\"RDB memory usage when created %.2f Mb\",\n                    (double) usedmem / (1024*1024));\n            } else if (!strcasecmp(auxkey->ptr,\"aof-preamble\")) {\n                long long haspreamble = strtoll(auxval->ptr,NULL,10);\n                if (haspreamble) serverLog(LL_NOTICE,\"RDB has an AOF tail\");\n            } else if (!strcasecmp(auxkey->ptr,\"redis-bits\")) {\n                /* Just ignored. */\n            } else {\n                /* We ignore fields we don't understand, as by AUX field\n                 * contract. */\n                serverLog(LL_DEBUG,\"Unrecognized RDB AUX field: '%s'\",\n                    (char*)auxkey->ptr);\n            }\n\n            decrRefCount(auxkey);\n            decrRefCount(auxval);\n            continue; /* Read type again. */\n        } else if (type == RDB_OPCODE_MODULE_AUX) {\n            /* Load module data that is not related to the Redis key space.\n             * Such data can be potentially be stored both before and after the\n             * RDB keys-values section. */\n            uint64_t moduleid = rdbLoadLen(rdb,NULL);\n            int when_opcode = rdbLoadLen(rdb,NULL);\n            int when = rdbLoadLen(rdb,NULL);\n            if (rioGetReadError(rdb)) goto eoferr;\n            if (when_opcode != RDB_MODULE_OPCODE_UINT) {\n                rdbReportReadError(\"bad when_opcode\");\n                goto eoferr;\n            }\n            moduleType *mt = moduleTypeLookupModuleByID(moduleid);\n            char name[10];\n            moduleTypeNameByID(name,moduleid);\n\n            if (!rdbCheckMode && mt == NULL) {\n                /* Unknown module. */\n                serverLog(LL_WARNING,\"The RDB file contains AUX module data I can't load: no matching module '%s'\", name);\n                exit(1);\n            } else if (!rdbCheckMode && mt != NULL) {\n                if (!mt->aux_load) {\n                    /* Module doesn't support AUX. */\n                    serverLog(LL_WARNING,\"The RDB file contains module AUX data, but the module '%s' doesn't seem to support it.\", name);\n                    exit(1);\n                }\n\n                RedisModuleIO io;\n                moduleInitIOContext(io,mt,rdb,NULL);\n                io.ver = 2;\n                /* Call the rdb_load method of the module providing the 10 bit\n                 * encoding version in the lower 10 bits of the module ID. */\n                if (mt->aux_load(&io,moduleid&1023, when) != REDISMODULE_OK || io.error) {\n                    moduleTypeNameByID(name,moduleid);\n                    serverLog(LL_WARNING,\"The RDB file contains module AUX data for the module type '%s', that the responsible module is not able to load. Check for modules log above for additional clues.\", name);\n                    goto eoferr;\n                }\n                if (io.ctx) {\n                    moduleFreeContext(io.ctx);\n                    zfree(io.ctx);\n                }\n                uint64_t eof = rdbLoadLen(rdb,NULL);\n                if (eof != RDB_MODULE_OPCODE_EOF) {\n                    serverLog(LL_WARNING,\"The RDB file contains module AUX data for the module '%s' that is not terminated by the proper module value EOF marker\", name);\n                    goto eoferr;\n                }\n                continue;\n            } else {\n                /* RDB check mode. */\n                robj *aux = rdbLoadCheckModuleValue(rdb,name);\n                decrRefCount(aux);\n                continue; /* Read next opcode. */\n            }\n        }\n\n        /* Read key */\n        if ((key = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL)\n            goto eoferr;\n        /* Read value */\n        if ((val = rdbLoadObject(type,rdb,key)) == NULL) {\n            sdsfree(key);\n            goto eoferr;\n        }\n\n        /* Check if the key already expired. This function is used when loading\n         * an RDB file from disk, either at startup, or when an RDB was\n         * received from the master. In the latter case, the master is\n         * responsible for key expiry. If we would expire keys here, the\n         * snapshot taken by the master may not be reflected on the slave.\n         * Similarly if the RDB is the preamble of an AOF file, we want to\n         * load all the keys as they are, since the log of operations later\n         * assume to work in an exact keyspace state. */\n        if (iAmMaster() &&\n            !(rdbflags&RDBFLAGS_AOF_PREAMBLE) &&\n            expiretime != -1 && expiretime < now)\n        {\n            sdsfree(key);\n            decrRefCount(val);\n        } else {\n            robj keyobj;\n            initStaticStringObject(keyobj,key);\n\n            /* Add the new object in the hash table */\n            int added = dbAddRDBLoad(db,key,val);\n            if (!added) {\n                if (rdbflags & RDBFLAGS_ALLOW_DUP) {\n                    /* This flag is useful for DEBUG RELOAD special modes.\n                     * When it's set we allow new keys to replace the current\n                     * keys with the same name. */\n                    dbSyncDelete(db,&keyobj);\n                    dbAddRDBLoad(db,key,val);\n                } else {\n                    serverLog(LL_WARNING,\n                        \"RDB has duplicated key '%s' in DB %d\",key,db->id);\n                    serverPanic(\"Duplicated key found in RDB file\");\n                }\n            }\n\n            /* Set the expire time if needed */\n            if (expiretime != -1) {\n                setExpire(NULL,db,&keyobj,expiretime);\n            }\n\n            /* Set usage information (for eviction). */\n            objectSetLRUOrLFU(val,lfu_freq,lru_idle,lru_clock,1000);\n\n            /* call key space notification on key loaded for modules only */\n            moduleNotifyKeyspaceEvent(NOTIFY_LOADED, \"loaded\", &keyobj, db->id);\n        }\n\n        /* Loading the database more slowly is useful in order to test\n         * certain edge cases. */\n        if (server.key_load_delay) usleep(server.key_load_delay);\n\n        /* Reset the state that is key-specified and is populated by\n         * opcodes before the key, so that we start from scratch again. */\n        expiretime = -1;\n        lfu_freq = -1;\n        lru_idle = -1;\n    }\n    /* Verify the checksum if RDB version is >= 5 */\n    if (rdbver >= 5) {\n        uint64_t cksum, expected = rdb->cksum;\n\n        if (rioRead(rdb,&cksum,8) == 0) goto eoferr;\n        if (server.rdb_checksum) {\n            memrev64ifbe(&cksum);\n            if (cksum == 0) {\n                serverLog(LL_WARNING,\"RDB file was saved with checksum disabled: no check performed.\");\n            } else if (cksum != expected) {\n                serverLog(LL_WARNING,\"Wrong RDB checksum expected: (%llx) but \"\n                    \"got (%llx). Aborting now.\",\n                        (unsigned long long)expected,\n                        (unsigned long long)cksum);\n                rdbExitReportCorruptRDB(\"RDB CRC error\");\n            }\n        }\n    }\n    return C_OK;\n\n    /* Unexpected end of file is handled here calling rdbReportReadError():\n     * this will in turn either abort Redis in most cases, or if we are loading\n     * the RDB file from a socket during initial SYNC (diskless replica mode),\n     * we'll report the error to the caller, so that we can retry. */\neoferr:\n    serverLog(LL_WARNING,\n        \"Short read or OOM loading DB. Unrecoverable error, aborting now.\");\n    rdbReportReadError(\"Unexpected EOF reading RDB file\");\n    return C_ERR;\n}\n\n/* Like rdbLoadRio() but takes a filename instead of a rio stream. The\n * filename is open for reading and a rio stream object created in order\n * to do the actual loading. Moreover the ETA displayed in the INFO\n * output is initialized and finalized.\n *\n * If you pass an 'rsi' structure initialied with RDB_SAVE_OPTION_INIT, the\n * loading code will fiil the information fields in the structure. */\nint rdbLoad(char *filename, rdbSaveInfo *rsi, int rdbflags) {\n    FILE *fp;\n    rio rdb;\n    int retval;\n\n    if ((fp = fopen(filename,\"r\")) == NULL) return C_ERR;\n    startLoadingFile(fp, filename,rdbflags);\n    rioInitWithFile(&rdb,fp);\n    retval = rdbLoadRio(&rdb,rdbflags,rsi);\n    fclose(fp);\n    stopLoading(retval==C_OK);\n    return retval;\n}\n\n/* A background saving child (BGSAVE) terminated its work. Handle this.\n * This function covers the case of actual BGSAVEs. */\nstatic void backgroundSaveDoneHandlerDisk(int exitcode, int bysignal) {\n    if (!bysignal && exitcode == 0) {\n        serverLog(LL_NOTICE,\n            \"Background saving terminated with success\");\n        server.dirty = server.dirty - server.dirty_before_bgsave;\n        server.lastsave = time(NULL);\n        server.lastbgsave_status = C_OK;\n    } else if (!bysignal && exitcode != 0) {\n        serverLog(LL_WARNING, \"Background saving error\");\n        server.lastbgsave_status = C_ERR;\n    } else {\n        mstime_t latency;\n\n        serverLog(LL_WARNING,\n            \"Background saving terminated by signal %d\", bysignal);\n        latencyStartMonitor(latency);\n        rdbRemoveTempFile(server.rdb_child_pid, 0);\n        latencyEndMonitor(latency);\n        latencyAddSampleIfNeeded(\"rdb-unlink-temp-file\",latency);\n        /* SIGUSR1 is whitelisted, so we have a way to kill a child without\n         * triggering an error condition. */\n        if (bysignal != SIGUSR1)\n            server.lastbgsave_status = C_ERR;\n    }\n}\n\n/* A background saving child (BGSAVE) terminated its work. Handle this.\n * This function covers the case of RDB -> Slaves socket transfers for\n * diskless replication. */\nstatic void backgroundSaveDoneHandlerSocket(int exitcode, int bysignal) {\n    if (!bysignal && exitcode == 0) {\n        serverLog(LL_NOTICE,\n            \"Background RDB transfer terminated with success\");\n    } else if (!bysignal && exitcode != 0) {\n        serverLog(LL_WARNING, \"Background transfer error\");\n    } else {\n        serverLog(LL_WARNING,\n            \"Background transfer terminated by signal %d\", bysignal);\n    }\n    if (server.rdb_child_exit_pipe!=-1)\n        close(server.rdb_child_exit_pipe);\n    aeDeleteFileEvent(server.el, server.rdb_pipe_read, AE_READABLE);\n    close(server.rdb_pipe_read);\n    server.rdb_child_exit_pipe = -1;\n    server.rdb_pipe_read = -1;\n    zfree(server.rdb_pipe_conns);\n    server.rdb_pipe_conns = NULL;\n    server.rdb_pipe_numconns = 0;\n    server.rdb_pipe_numconns_writing = 0;\n    zfree(server.rdb_pipe_buff);\n    server.rdb_pipe_buff = NULL;\n    server.rdb_pipe_bufflen = 0;\n}\n\n/* When a background RDB saving/transfer terminates, call the right handler. */\nvoid backgroundSaveDoneHandler(int exitcode, int bysignal) {\n    int type = server.rdb_child_type;\n    switch(server.rdb_child_type) {\n    case RDB_CHILD_TYPE_DISK:\n        backgroundSaveDoneHandlerDisk(exitcode,bysignal);\n        break;\n    case RDB_CHILD_TYPE_SOCKET:\n        backgroundSaveDoneHandlerSocket(exitcode,bysignal);\n        break;\n    default:\n        serverPanic(\"Unknown RDB child type.\");\n        break;\n    }\n\n    server.rdb_child_pid = -1;\n    server.rdb_child_type = RDB_CHILD_TYPE_NONE;\n    server.rdb_save_time_last = time(NULL)-server.rdb_save_time_start;\n    server.rdb_save_time_start = -1;\n    /* Possibly there are slaves waiting for a BGSAVE in order to be served\n     * (the first stage of SYNC is a bulk transfer of dump.rdb) */\n    updateSlavesWaitingBgsave((!bysignal && exitcode == 0) ? C_OK : C_ERR, type);\n}\n\n/* Kill the RDB saving child using SIGUSR1 (so that the parent will know\n * the child did not exit for an error, but because we wanted), and performs\n * the cleanup needed. */\nvoid killRDBChild(void) {\n    kill(server.rdb_child_pid,SIGUSR1);\n    rdbRemoveTempFile(server.rdb_child_pid, 0);\n    closeChildInfoPipe();\n    updateDictResizePolicy();\n}\n\n/* Spawn an RDB child that writes the RDB to the sockets of the slaves\n * that are currently in SLAVE_STATE_WAIT_BGSAVE_START state. */\nint rdbSaveToSlavesSockets(rdbSaveInfo *rsi) {\n    listNode *ln;\n    listIter li;\n    pid_t childpid;\n    int pipefds[2], rdb_pipe_write, safe_to_exit_pipe;\n\n    if (hasActiveChildProcess()) return C_ERR;\n\n    /* Even if the previous fork child exited, don't start a new one until we\n     * drained the pipe. */\n    if (server.rdb_pipe_conns) return C_ERR;\n\n    /* Before to fork, create a pipe that is used to transfer the rdb bytes to\n     * the parent, we can't let it write directly to the sockets, since in case\n     * of TLS we must let the parent handle a continuous TLS state when the\n     * child terminates and parent takes over. */\n    if (pipe(pipefds) == -1) return C_ERR;\n    server.rdb_pipe_read = pipefds[0]; /* read end */\n    rdb_pipe_write = pipefds[1]; /* write end */\n    anetNonBlock(NULL, server.rdb_pipe_read);\n\n    /* create another pipe that is used by the parent to signal to the child\n     * that it can exit. */\n    if (pipe(pipefds) == -1) {\n        close(rdb_pipe_write);\n        close(server.rdb_pipe_read);\n        return C_ERR;\n    }\n    safe_to_exit_pipe = pipefds[0]; /* read end */\n    server.rdb_child_exit_pipe = pipefds[1]; /* write end */\n\n    /* Collect the connections of the replicas we want to transfer\n     * the RDB to, which are i WAIT_BGSAVE_START state. */\n    server.rdb_pipe_conns = zmalloc(sizeof(connection *)*listLength(server.slaves));\n    server.rdb_pipe_numconns = 0;\n    server.rdb_pipe_numconns_writing = 0;\n    listRewind(server.slaves,&li);\n    while((ln = listNext(&li))) {\n        client *slave = ln->value;\n        if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START) {\n            server.rdb_pipe_conns[server.rdb_pipe_numconns++] = slave->conn;\n            replicationSetupSlaveForFullResync(slave,getPsyncInitialOffset());\n        }\n    }\n\n    /* Create the child process. */\n    openChildInfoPipe();\n    if ((childpid = redisFork(CHILD_TYPE_RDB)) == 0) {\n        /* Child */\n        int retval, dummy;\n        rio rdb;\n\n        rioInitWithFd(&rdb,rdb_pipe_write);\n\n        redisSetProcTitle(\"redis-rdb-to-slaves\");\n        redisSetCpuAffinity(server.bgsave_cpulist);\n\n        retval = rdbSaveRioWithEOFMark(&rdb,NULL,rsi);\n        if (retval == C_OK && rioFlush(&rdb) == 0)\n            retval = C_ERR;\n\n        if (retval == C_OK) {\n            sendChildCOWInfo(CHILD_TYPE_RDB, \"RDB\");\n        }\n\n        rioFreeFd(&rdb);\n        /* wake up the reader, tell it we're done. */\n        close(rdb_pipe_write);\n        close(server.rdb_child_exit_pipe); /* close write end so that we can detect the close on the parent. */\n        /* hold exit until the parent tells us it's safe. we're not expecting\n         * to read anything, just get the error when the pipe is closed. */\n        dummy = read(safe_to_exit_pipe, pipefds, 1);\n        UNUSED(dummy);\n        exitFromChild((retval == C_OK) ? 0 : 1);\n    } else {\n        /* Parent */\n        close(safe_to_exit_pipe);\n        if (childpid == -1) {\n            serverLog(LL_WARNING,\"Can't save in background: fork: %s\",\n                strerror(errno));\n\n            /* Undo the state change. The caller will perform cleanup on\n             * all the slaves in BGSAVE_START state, but an early call to\n             * replicationSetupSlaveForFullResync() turned it into BGSAVE_END */\n            listRewind(server.slaves,&li);\n            while((ln = listNext(&li))) {\n                client *slave = ln->value;\n                if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_END) {\n                    slave->replstate = SLAVE_STATE_WAIT_BGSAVE_START;\n                }\n            }\n            close(rdb_pipe_write);\n            close(server.rdb_pipe_read);\n            zfree(server.rdb_pipe_conns);\n            server.rdb_pipe_conns = NULL;\n            server.rdb_pipe_numconns = 0;\n            server.rdb_pipe_numconns_writing = 0;\n            closeChildInfoPipe();\n        } else {\n            serverLog(LL_NOTICE,\"Background RDB transfer started by pid %d\",\n                childpid);\n            server.rdb_save_time_start = time(NULL);\n            server.rdb_child_pid = childpid;\n            server.rdb_child_type = RDB_CHILD_TYPE_SOCKET;\n            updateDictResizePolicy();\n            close(rdb_pipe_write); /* close write in parent so that it can detect the close on the child. */\n            if (aeCreateFileEvent(server.el, server.rdb_pipe_read, AE_READABLE, rdbPipeReadHandler,NULL) == AE_ERR) {\n                serverPanic(\"Unrecoverable error creating server.rdb_pipe_read file event.\");\n            }\n        }\n        return (childpid == -1) ? C_ERR : C_OK;\n    }\n    return C_OK; /* Unreached. */\n}\n\nvoid saveCommand(client *c) {\n    if (server.rdb_child_pid != -1) {\n        addReplyError(c,\"Background save already in progress\");\n        return;\n    }\n    rdbSaveInfo rsi, *rsiptr;\n    rsiptr = rdbPopulateSaveInfo(&rsi);\n    if (rdbSave(server.rdb_filename,rsiptr) == C_OK) {\n        addReply(c,shared.ok);\n    } else {\n        addReply(c,shared.err);\n    }\n}\n\n/* BGSAVE [SCHEDULE] */\nvoid bgsaveCommand(client *c) {\n    int schedule = 0;\n\n    /* The SCHEDULE option changes the behavior of BGSAVE when an AOF rewrite\n     * is in progress. Instead of returning an error a BGSAVE gets scheduled. */\n    if (c->argc > 1) {\n        if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,\"schedule\")) {\n            schedule = 1;\n        } else {\n            addReply(c,shared.syntaxerr);\n            return;\n        }\n    }\n\n    rdbSaveInfo rsi, *rsiptr;\n    rsiptr = rdbPopulateSaveInfo(&rsi);\n\n    if (server.rdb_child_pid != -1) {\n        addReplyError(c,\"Background save already in progress\");\n    } else if (hasActiveChildProcess()) {\n        if (schedule) {\n            server.rdb_bgsave_scheduled = 1;\n            addReplyStatus(c,\"Background saving scheduled\");\n        } else {\n            addReplyError(c,\n            \"Another child process is active (AOF?): can't BGSAVE right now. \"\n            \"Use BGSAVE SCHEDULE in order to schedule a BGSAVE whenever \"\n            \"possible.\");\n        }\n    } else if (rdbSaveBackground(server.rdb_filename,rsiptr) == C_OK) {\n        addReplyStatus(c,\"Background saving started\");\n    } else {\n        addReply(c,shared.err);\n    }\n}\n\n/* Populate the rdbSaveInfo structure used to persist the replication\n * information inside the RDB file. Currently the structure explicitly\n * contains just the currently selected DB from the master stream, however\n * if the rdbSave*() family functions receive a NULL rsi structure also\n * the Replication ID/offset is not saved. The function popultes 'rsi'\n * that is normally stack-allocated in the caller, returns the populated\n * pointer if the instance has a valid master client, otherwise NULL\n * is returned, and the RDB saving will not persist any replication related\n * information. */\nrdbSaveInfo *rdbPopulateSaveInfo(rdbSaveInfo *rsi) {\n    rdbSaveInfo rsi_init = RDB_SAVE_INFO_INIT;\n    *rsi = rsi_init;\n\n    /* If the instance is a master, we can populate the replication info\n     * only when repl_backlog is not NULL. If the repl_backlog is NULL,\n     * it means that the instance isn't in any replication chains. In this\n     * scenario the replication info is useless, because when a slave\n     * connects to us, the NULL repl_backlog will trigger a full\n     * synchronization, at the same time we will use a new replid and clear\n     * replid2. */\n    if (!server.masterhost && server.repl_backlog) {\n        /* Note that when server.slaveseldb is -1, it means that this master\n         * didn't apply any write commands after a full synchronization.\n         * So we can let repl_stream_db be 0, this allows a restarted slave\n         * to reload replication ID/offset, it's safe because the next write\n         * command must generate a SELECT statement. */\n        rsi->repl_stream_db = server.slaveseldb == -1 ? 0 : server.slaveseldb;\n        return rsi;\n    }\n\n    /* If the instance is a slave we need a connected master\n     * in order to fetch the currently selected DB. */\n    if (server.master) {\n        rsi->repl_stream_db = server.master->db->id;\n        return rsi;\n    }\n\n    /* If we have a cached master we can use it in order to populate the\n     * replication selected DB info inside the RDB file: the slave can\n     * increment the master_repl_offset only from data arriving from the\n     * master, so if we are disconnected the offset in the cached master\n     * is valid. */\n    if (server.cached_master) {\n        rsi->repl_stream_db = server.cached_master->db->id;\n        return rsi;\n    }\n    return NULL;\n}\n", "/*\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n\n/*-----------------------------------------------------------------------------\n * Set Commands\n *----------------------------------------------------------------------------*/\n\nvoid sunionDiffGenericCommand(client *c, robj **setkeys, int setnum,\n                              robj *dstkey, int op);\n\n/* Factory method to return a set that *can* hold \"value\". When the object has\n * an integer-encodable value, an intset will be returned. Otherwise a regular\n * hash table. */\nrobj *setTypeCreate(sds value) {\n    if (isSdsRepresentableAsLongLong(value,NULL) == C_OK)\n        return createIntsetObject();\n    return createSetObject();\n}\n\n/* Add the specified value into a set.\n *\n * If the value was already member of the set, nothing is done and 0 is\n * returned, otherwise the new element is added and 1 is returned. */\nint setTypeAdd(robj *subject, sds value) {\n    long long llval;\n    if (subject->encoding == OBJ_ENCODING_HT) {\n        dict *ht = subject->ptr;\n        dictEntry *de = dictAddRaw(ht,value,NULL);\n        if (de) {\n            dictSetKey(ht,de,sdsdup(value));\n            dictSetVal(ht,de,NULL);\n            return 1;\n        }\n    } else if (subject->encoding == OBJ_ENCODING_INTSET) {\n        if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {\n            uint8_t success = 0;\n            subject->ptr = intsetAdd(subject->ptr,llval,&success);\n            if (success) {\n                /* Convert to regular set when the intset contains\n                 * too many entries. */\n                size_t max_entries = server.set_max_intset_entries;\n                /* limit to 1G entries due to intset internals. */\n                if (max_entries >= 1<<30) max_entries = 1<<30;\n                if (intsetLen(subject->ptr) > max_entries)\n                    setTypeConvert(subject,OBJ_ENCODING_HT);\n                return 1;\n            }\n        } else {\n            /* Failed to get integer from object, convert to regular set. */\n            setTypeConvert(subject,OBJ_ENCODING_HT);\n\n            /* The set *was* an intset and this value is not integer\n             * encodable, so dictAdd should always work. */\n            serverAssert(dictAdd(subject->ptr,sdsdup(value),NULL) == DICT_OK);\n            return 1;\n        }\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return 0;\n}\n\nint setTypeRemove(robj *setobj, sds value) {\n    long long llval;\n    if (setobj->encoding == OBJ_ENCODING_HT) {\n        if (dictDelete(setobj->ptr,value) == DICT_OK) {\n            if (htNeedsResize(setobj->ptr)) dictResize(setobj->ptr);\n            return 1;\n        }\n    } else if (setobj->encoding == OBJ_ENCODING_INTSET) {\n        if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {\n            int success;\n            setobj->ptr = intsetRemove(setobj->ptr,llval,&success);\n            if (success) return 1;\n        }\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return 0;\n}\n\nint setTypeIsMember(robj *subject, sds value) {\n    long long llval;\n    if (subject->encoding == OBJ_ENCODING_HT) {\n        return dictFind((dict*)subject->ptr,value) != NULL;\n    } else if (subject->encoding == OBJ_ENCODING_INTSET) {\n        if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {\n            return intsetFind((intset*)subject->ptr,llval);\n        }\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return 0;\n}\n\nsetTypeIterator *setTypeInitIterator(robj *subject) {\n    setTypeIterator *si = zmalloc(sizeof(setTypeIterator));\n    si->subject = subject;\n    si->encoding = subject->encoding;\n    if (si->encoding == OBJ_ENCODING_HT) {\n        si->di = dictGetIterator(subject->ptr);\n    } else if (si->encoding == OBJ_ENCODING_INTSET) {\n        si->ii = 0;\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return si;\n}\n\nvoid setTypeReleaseIterator(setTypeIterator *si) {\n    if (si->encoding == OBJ_ENCODING_HT)\n        dictReleaseIterator(si->di);\n    zfree(si);\n}\n\n/* Move to the next entry in the set. Returns the object at the current\n * position.\n *\n * Since set elements can be internally be stored as SDS strings or\n * simple arrays of integers, setTypeNext returns the encoding of the\n * set object you are iterating, and will populate the appropriate pointer\n * (sdsele) or (llele) accordingly.\n *\n * Note that both the sdsele and llele pointers should be passed and cannot\n * be NULL since the function will try to defensively populate the non\n * used field with values which are easy to trap if misused.\n *\n * When there are no longer elements -1 is returned. */\nint setTypeNext(setTypeIterator *si, sds *sdsele, int64_t *llele) {\n    if (si->encoding == OBJ_ENCODING_HT) {\n        dictEntry *de = dictNext(si->di);\n        if (de == NULL) return -1;\n        *sdsele = dictGetKey(de);\n        *llele = -123456789; /* Not needed. Defensive. */\n    } else if (si->encoding == OBJ_ENCODING_INTSET) {\n        if (!intsetGet(si->subject->ptr,si->ii++,llele))\n            return -1;\n        *sdsele = NULL; /* Not needed. Defensive. */\n    } else {\n        serverPanic(\"Wrong set encoding in setTypeNext\");\n    }\n    return si->encoding;\n}\n\n/* The not copy on write friendly version but easy to use version\n * of setTypeNext() is setTypeNextObject(), returning new SDS\n * strings. So if you don't retain a pointer to this object you should call\n * sdsfree() against it.\n *\n * This function is the way to go for write operations where COW is not\n * an issue. */\nsds setTypeNextObject(setTypeIterator *si) {\n    int64_t intele;\n    sds sdsele;\n    int encoding;\n\n    encoding = setTypeNext(si,&sdsele,&intele);\n    switch(encoding) {\n        case -1:    return NULL;\n        case OBJ_ENCODING_INTSET:\n            return sdsfromlonglong(intele);\n        case OBJ_ENCODING_HT:\n            return sdsdup(sdsele);\n        default:\n            serverPanic(\"Unsupported encoding\");\n    }\n    return NULL; /* just to suppress warnings */\n}\n\n/* Return random element from a non empty set.\n * The returned element can be an int64_t value if the set is encoded\n * as an \"intset\" blob of integers, or an SDS string if the set\n * is a regular set.\n *\n * The caller provides both pointers to be populated with the right\n * object. The return value of the function is the object->encoding\n * field of the object and is used by the caller to check if the\n * int64_t pointer or the redis object pointer was populated.\n *\n * Note that both the sdsele and llele pointers should be passed and cannot\n * be NULL since the function will try to defensively populate the non\n * used field with values which are easy to trap if misused. */\nint setTypeRandomElement(robj *setobj, sds *sdsele, int64_t *llele) {\n    if (setobj->encoding == OBJ_ENCODING_HT) {\n        dictEntry *de = dictGetFairRandomKey(setobj->ptr);\n        *sdsele = dictGetKey(de);\n        *llele = -123456789; /* Not needed. Defensive. */\n    } else if (setobj->encoding == OBJ_ENCODING_INTSET) {\n        *llele = intsetRandom(setobj->ptr);\n        *sdsele = NULL; /* Not needed. Defensive. */\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return setobj->encoding;\n}\n\nunsigned long setTypeSize(const robj *subject) {\n    if (subject->encoding == OBJ_ENCODING_HT) {\n        return dictSize((const dict*)subject->ptr);\n    } else if (subject->encoding == OBJ_ENCODING_INTSET) {\n        return intsetLen((const intset*)subject->ptr);\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n}\n\n/* Convert the set to specified encoding. The resulting dict (when converting\n * to a hash table) is presized to hold the number of elements in the original\n * set. */\nvoid setTypeConvert(robj *setobj, int enc) {\n    setTypeIterator *si;\n    serverAssertWithInfo(NULL,setobj,setobj->type == OBJ_SET &&\n                             setobj->encoding == OBJ_ENCODING_INTSET);\n\n    if (enc == OBJ_ENCODING_HT) {\n        int64_t intele;\n        dict *d = dictCreate(&setDictType,NULL);\n        sds element;\n\n        /* Presize the dict to avoid rehashing */\n        dictExpand(d,intsetLen(setobj->ptr));\n\n        /* To add the elements we extract integers and create redis objects */\n        si = setTypeInitIterator(setobj);\n        while (setTypeNext(si,&element,&intele) != -1) {\n            element = sdsfromlonglong(intele);\n            serverAssert(dictAdd(d,element,NULL) == DICT_OK);\n        }\n        setTypeReleaseIterator(si);\n\n        setobj->encoding = OBJ_ENCODING_HT;\n        zfree(setobj->ptr);\n        setobj->ptr = d;\n    } else {\n        serverPanic(\"Unsupported set conversion\");\n    }\n}\n\nvoid saddCommand(client *c) {\n    robj *set;\n    int j, added = 0;\n\n    set = lookupKeyWrite(c->db,c->argv[1]);\n    if (set == NULL) {\n        set = setTypeCreate(c->argv[2]->ptr);\n        dbAdd(c->db,c->argv[1],set);\n    } else {\n        if (set->type != OBJ_SET) {\n            addReply(c,shared.wrongtypeerr);\n            return;\n        }\n    }\n\n    for (j = 2; j < c->argc; j++) {\n        if (setTypeAdd(set,c->argv[j]->ptr)) added++;\n    }\n    if (added) {\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_SET,\"sadd\",c->argv[1],c->db->id);\n    }\n    server.dirty += added;\n    addReplyLongLong(c,added);\n}\n\nvoid sremCommand(client *c) {\n    robj *set;\n    int j, deleted = 0, keyremoved = 0;\n\n    if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,set,OBJ_SET)) return;\n\n    for (j = 2; j < c->argc; j++) {\n        if (setTypeRemove(set,c->argv[j]->ptr)) {\n            deleted++;\n            if (setTypeSize(set) == 0) {\n                dbDelete(c->db,c->argv[1]);\n                keyremoved = 1;\n                break;\n            }\n        }\n    }\n    if (deleted) {\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_SET,\"srem\",c->argv[1],c->db->id);\n        if (keyremoved)\n            notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",c->argv[1],\n                                c->db->id);\n        server.dirty += deleted;\n    }\n    addReplyLongLong(c,deleted);\n}\n\nvoid smoveCommand(client *c) {\n    robj *srcset, *dstset, *ele;\n    srcset = lookupKeyWrite(c->db,c->argv[1]);\n    dstset = lookupKeyWrite(c->db,c->argv[2]);\n    ele = c->argv[3];\n\n    /* If the source key does not exist return 0 */\n    if (srcset == NULL) {\n        addReply(c,shared.czero);\n        return;\n    }\n\n    /* If the source key has the wrong type, or the destination key\n     * is set and has the wrong type, return with an error. */\n    if (checkType(c,srcset,OBJ_SET) ||\n        (dstset && checkType(c,dstset,OBJ_SET))) return;\n\n    /* If srcset and dstset are equal, SMOVE is a no-op */\n    if (srcset == dstset) {\n        addReply(c,setTypeIsMember(srcset,ele->ptr) ?\n            shared.cone : shared.czero);\n        return;\n    }\n\n    /* If the element cannot be removed from the src set, return 0. */\n    if (!setTypeRemove(srcset,ele->ptr)) {\n        addReply(c,shared.czero);\n        return;\n    }\n    notifyKeyspaceEvent(NOTIFY_SET,\"srem\",c->argv[1],c->db->id);\n\n    /* Remove the src set from the database when empty */\n    if (setTypeSize(srcset) == 0) {\n        dbDelete(c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",c->argv[1],c->db->id);\n    }\n\n    /* Create the destination set when it doesn't exist */\n    if (!dstset) {\n        dstset = setTypeCreate(ele->ptr);\n        dbAdd(c->db,c->argv[2],dstset);\n    }\n\n    signalModifiedKey(c,c->db,c->argv[1]);\n    server.dirty++;\n\n    /* An extra key has changed when ele was successfully added to dstset */\n    if (setTypeAdd(dstset,ele->ptr)) {\n        server.dirty++;\n        signalModifiedKey(c,c->db,c->argv[2]);\n        notifyKeyspaceEvent(NOTIFY_SET,\"sadd\",c->argv[2],c->db->id);\n    }\n    addReply(c,shared.cone);\n}\n\nvoid sismemberCommand(client *c) {\n    robj *set;\n\n    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,set,OBJ_SET)) return;\n\n    if (setTypeIsMember(set,c->argv[2]->ptr))\n        addReply(c,shared.cone);\n    else\n        addReply(c,shared.czero);\n}\n\nvoid scardCommand(client *c) {\n    robj *o;\n\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,o,OBJ_SET)) return;\n\n    addReplyLongLong(c,setTypeSize(o));\n}\n\n/* Handle the \"SPOP key <count>\" variant. The normal version of the\n * command is handled by the spopCommand() function itself. */\n\n/* How many times bigger should be the set compared to the remaining size\n * for us to use the \"create new set\" strategy? Read later in the\n * implementation for more info. */\n#define SPOP_MOVE_STRATEGY_MUL 5\n\nvoid spopWithCountCommand(client *c) {\n    long l;\n    unsigned long count, size;\n    robj *set;\n\n    /* Get the count argument */\n    if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n    if (l >= 0) {\n        count = (unsigned long) l;\n    } else {\n        addReply(c,shared.outofrangeerr);\n        return;\n    }\n\n    /* Make sure a key with the name inputted exists, and that it's type is\n     * indeed a set. Otherwise, return nil */\n    if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.emptyset[c->resp]))\n        == NULL || checkType(c,set,OBJ_SET)) return;\n\n    /* If count is zero, serve an empty set ASAP to avoid special\n     * cases later. */\n    if (count == 0) {\n        addReply(c,shared.emptyset[c->resp]);\n        return;\n    }\n\n    size = setTypeSize(set);\n\n    /* Generate an SPOP keyspace notification */\n    notifyKeyspaceEvent(NOTIFY_SET,\"spop\",c->argv[1],c->db->id);\n    server.dirty += count;\n\n    /* CASE 1:\n     * The number of requested elements is greater than or equal to\n     * the number of elements inside the set: simply return the whole set. */\n    if (count >= size) {\n        /* We just return the entire set */\n        sunionDiffGenericCommand(c,c->argv+1,1,NULL,SET_OP_UNION);\n\n        /* Delete the set as it is now empty */\n        dbDelete(c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",c->argv[1],c->db->id);\n\n        /* Propagate this command as a DEL operation */\n        rewriteClientCommandVector(c,2,shared.del,c->argv[1]);\n        signalModifiedKey(c,c->db,c->argv[1]);\n        server.dirty++;\n        return;\n    }\n\n    /* Case 2 and 3 require to replicate SPOP as a set of SREM commands.\n     * Prepare our replication argument vector. Also send the array length\n     * which is common to both the code paths. */\n    robj *propargv[3];\n    propargv[0] = createStringObject(\"SREM\",4);\n    propargv[1] = c->argv[1];\n    addReplySetLen(c,count);\n\n    /* Common iteration vars. */\n    sds sdsele;\n    robj *objele;\n    int encoding;\n    int64_t llele;\n    unsigned long remaining = size-count; /* Elements left after SPOP. */\n\n    /* If we are here, the number of requested elements is less than the\n     * number of elements inside the set. Also we are sure that count < size.\n     * Use two different strategies.\n     *\n     * CASE 2: The number of elements to return is small compared to the\n     * set size. We can just extract random elements and return them to\n     * the set. */\n    if (remaining*SPOP_MOVE_STRATEGY_MUL > count) {\n        while(count--) {\n            /* Emit and remove. */\n            encoding = setTypeRandomElement(set,&sdsele,&llele);\n            if (encoding == OBJ_ENCODING_INTSET) {\n                addReplyBulkLongLong(c,llele);\n                objele = createStringObjectFromLongLong(llele);\n                set->ptr = intsetRemove(set->ptr,llele,NULL);\n            } else {\n                addReplyBulkCBuffer(c,sdsele,sdslen(sdsele));\n                objele = createStringObject(sdsele,sdslen(sdsele));\n                setTypeRemove(set,sdsele);\n            }\n\n            /* Replicate/AOF this command as an SREM operation */\n            propargv[2] = objele;\n            alsoPropagate(server.sremCommand,c->db->id,propargv,3,\n                PROPAGATE_AOF|PROPAGATE_REPL);\n            decrRefCount(objele);\n        }\n    } else {\n    /* CASE 3: The number of elements to return is very big, approaching\n     * the size of the set itself. After some time extracting random elements\n     * from such a set becomes computationally expensive, so we use\n     * a different strategy, we extract random elements that we don't\n     * want to return (the elements that will remain part of the set),\n     * creating a new set as we do this (that will be stored as the original\n     * set). Then we return the elements left in the original set and\n     * release it. */\n        robj *newset = NULL;\n\n        /* Create a new set with just the remaining elements. */\n        while(remaining--) {\n            encoding = setTypeRandomElement(set,&sdsele,&llele);\n            if (encoding == OBJ_ENCODING_INTSET) {\n                sdsele = sdsfromlonglong(llele);\n            } else {\n                sdsele = sdsdup(sdsele);\n            }\n            if (!newset) newset = setTypeCreate(sdsele);\n            setTypeAdd(newset,sdsele);\n            setTypeRemove(set,sdsele);\n            sdsfree(sdsele);\n        }\n\n        /* Transfer the old set to the client. */\n        setTypeIterator *si;\n        si = setTypeInitIterator(set);\n        while((encoding = setTypeNext(si,&sdsele,&llele)) != -1) {\n            if (encoding == OBJ_ENCODING_INTSET) {\n                addReplyBulkLongLong(c,llele);\n                objele = createStringObjectFromLongLong(llele);\n            } else {\n                addReplyBulkCBuffer(c,sdsele,sdslen(sdsele));\n                objele = createStringObject(sdsele,sdslen(sdsele));\n            }\n\n            /* Replicate/AOF this command as an SREM operation */\n            propargv[2] = objele;\n            alsoPropagate(server.sremCommand,c->db->id,propargv,3,\n                PROPAGATE_AOF|PROPAGATE_REPL);\n            decrRefCount(objele);\n        }\n        setTypeReleaseIterator(si);\n\n        /* Assign the new set as the key value. */\n        dbOverwrite(c->db,c->argv[1],newset);\n    }\n\n    /* Don't propagate the command itself even if we incremented the\n     * dirty counter. We don't want to propagate an SPOP command since\n     * we propagated the command as a set of SREMs operations using\n     * the alsoPropagate() API. */\n    decrRefCount(propargv[0]);\n    preventCommandPropagation(c);\n    signalModifiedKey(c,c->db,c->argv[1]);\n    server.dirty++;\n}\n\nvoid spopCommand(client *c) {\n    robj *set, *ele, *aux;\n    sds sdsele;\n    int64_t llele;\n    int encoding;\n\n    if (c->argc == 3) {\n        spopWithCountCommand(c);\n        return;\n    } else if (c->argc > 3) {\n        addReply(c,shared.syntaxerr);\n        return;\n    }\n\n    /* Make sure a key with the name inputted exists, and that it's type is\n     * indeed a set */\n    if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.null[c->resp]))\n         == NULL || checkType(c,set,OBJ_SET)) return;\n\n    /* Get a random element from the set */\n    encoding = setTypeRandomElement(set,&sdsele,&llele);\n\n    /* Remove the element from the set */\n    if (encoding == OBJ_ENCODING_INTSET) {\n        ele = createStringObjectFromLongLong(llele);\n        set->ptr = intsetRemove(set->ptr,llele,NULL);\n    } else {\n        ele = createStringObject(sdsele,sdslen(sdsele));\n        setTypeRemove(set,ele->ptr);\n    }\n\n    notifyKeyspaceEvent(NOTIFY_SET,\"spop\",c->argv[1],c->db->id);\n\n    /* Replicate/AOF this command as an SREM operation */\n    aux = createStringObject(\"SREM\",4);\n    rewriteClientCommandVector(c,3,aux,c->argv[1],ele);\n    decrRefCount(aux);\n\n    /* Add the element to the reply */\n    addReplyBulk(c,ele);\n    decrRefCount(ele);\n\n    /* Delete the set if it's empty */\n    if (setTypeSize(set) == 0) {\n        dbDelete(c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",c->argv[1],c->db->id);\n    }\n\n    /* Set has been modified */\n    signalModifiedKey(c,c->db,c->argv[1]);\n    server.dirty++;\n}\n\n/* handle the \"SRANDMEMBER key <count>\" variant. The normal version of the\n * command is handled by the srandmemberCommand() function itself. */\n\n/* How many times bigger should be the set compared to the requested size\n * for us to don't use the \"remove elements\" strategy? Read later in the\n * implementation for more info. */\n#define SRANDMEMBER_SUB_STRATEGY_MUL 3\n\nvoid srandmemberWithCountCommand(client *c) {\n    long l;\n    unsigned long count, size;\n    int uniq = 1;\n    robj *set;\n    sds ele;\n    int64_t llele;\n    int encoding;\n\n    dict *d;\n\n    if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n    if (l >= 0) {\n        count = (unsigned long) l;\n    } else {\n        /* A negative count means: return the same elements multiple times\n         * (i.e. don't remove the extracted element after every extraction). */\n        count = -l;\n        uniq = 0;\n    }\n\n    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptyset[c->resp]))\n        == NULL || checkType(c,set,OBJ_SET)) return;\n    size = setTypeSize(set);\n\n    /* If count is zero, serve it ASAP to avoid special cases later. */\n    if (count == 0) {\n        addReply(c,shared.emptyset[c->resp]);\n        return;\n    }\n\n    /* CASE 1: The count was negative, so the extraction method is just:\n     * \"return N random elements\" sampling the whole set every time.\n     * This case is trivial and can be served without auxiliary data\n     * structures. */\n    if (!uniq) {\n        addReplySetLen(c,count);\n        while(count--) {\n            encoding = setTypeRandomElement(set,&ele,&llele);\n            if (encoding == OBJ_ENCODING_INTSET) {\n                addReplyBulkLongLong(c,llele);\n            } else {\n                addReplyBulkCBuffer(c,ele,sdslen(ele));\n            }\n        }\n        return;\n    }\n\n    /* CASE 2:\n     * The number of requested elements is greater than the number of\n     * elements inside the set: simply return the whole set. */\n    if (count >= size) {\n        sunionDiffGenericCommand(c,c->argv+1,1,NULL,SET_OP_UNION);\n        return;\n    }\n\n    /* For CASE 3 and CASE 4 we need an auxiliary dictionary. */\n    d = dictCreate(&objectKeyPointerValueDictType,NULL);\n\n    /* CASE 3:\n     * The number of elements inside the set is not greater than\n     * SRANDMEMBER_SUB_STRATEGY_MUL times the number of requested elements.\n     * In this case we create a set from scratch with all the elements, and\n     * subtract random elements to reach the requested number of elements.\n     *\n     * This is done because if the number of requested elements is just\n     * a bit less than the number of elements in the set, the natural approach\n     * used into CASE 3 is highly inefficient. */\n    if (count*SRANDMEMBER_SUB_STRATEGY_MUL > size) {\n        setTypeIterator *si;\n\n        /* Add all the elements into the temporary dictionary. */\n        si = setTypeInitIterator(set);\n        while((encoding = setTypeNext(si,&ele,&llele)) != -1) {\n            int retval = DICT_ERR;\n\n            if (encoding == OBJ_ENCODING_INTSET) {\n                retval = dictAdd(d,createStringObjectFromLongLong(llele),NULL);\n            } else {\n                retval = dictAdd(d,createStringObject(ele,sdslen(ele)),NULL);\n            }\n            serverAssert(retval == DICT_OK);\n        }\n        setTypeReleaseIterator(si);\n        serverAssert(dictSize(d) == size);\n\n        /* Remove random elements to reach the right count. */\n        while(size > count) {\n            dictEntry *de;\n\n            de = dictGetRandomKey(d);\n            dictDelete(d,dictGetKey(de));\n            size--;\n        }\n    }\n\n    /* CASE 4: We have a big set compared to the requested number of elements.\n     * In this case we can simply get random elements from the set and add\n     * to the temporary set, trying to eventually get enough unique elements\n     * to reach the specified count. */\n    else {\n        unsigned long added = 0;\n        robj *objele;\n\n        while(added < count) {\n            encoding = setTypeRandomElement(set,&ele,&llele);\n            if (encoding == OBJ_ENCODING_INTSET) {\n                objele = createStringObjectFromLongLong(llele);\n            } else {\n                objele = createStringObject(ele,sdslen(ele));\n            }\n            /* Try to add the object to the dictionary. If it already exists\n             * free it, otherwise increment the number of objects we have\n             * in the result dictionary. */\n            if (dictAdd(d,objele,NULL) == DICT_OK)\n                added++;\n            else\n                decrRefCount(objele);\n        }\n    }\n\n    /* CASE 3 & 4: send the result to the user. */\n    {\n        dictIterator *di;\n        dictEntry *de;\n\n        addReplySetLen(c,count);\n        di = dictGetIterator(d);\n        while((de = dictNext(di)) != NULL)\n            addReplyBulk(c,dictGetKey(de));\n        dictReleaseIterator(di);\n        dictRelease(d);\n    }\n}\n\nvoid srandmemberCommand(client *c) {\n    robj *set;\n    sds ele;\n    int64_t llele;\n    int encoding;\n\n    if (c->argc == 3) {\n        srandmemberWithCountCommand(c);\n        return;\n    } else if (c->argc > 3) {\n        addReply(c,shared.syntaxerr);\n        return;\n    }\n\n    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))\n        == NULL || checkType(c,set,OBJ_SET)) return;\n\n    encoding = setTypeRandomElement(set,&ele,&llele);\n    if (encoding == OBJ_ENCODING_INTSET) {\n        addReplyBulkLongLong(c,llele);\n    } else {\n        addReplyBulkCBuffer(c,ele,sdslen(ele));\n    }\n}\n\nint qsortCompareSetsByCardinality(const void *s1, const void *s2) {\n    if (setTypeSize(*(robj**)s1) > setTypeSize(*(robj**)s2)) return 1;\n    if (setTypeSize(*(robj**)s1) < setTypeSize(*(robj**)s2)) return -1;\n    return 0;\n}\n\n/* This is used by SDIFF and in this case we can receive NULL that should\n * be handled as empty sets. */\nint qsortCompareSetsByRevCardinality(const void *s1, const void *s2) {\n    robj *o1 = *(robj**)s1, *o2 = *(robj**)s2;\n    unsigned long first = o1 ? setTypeSize(o1) : 0;\n    unsigned long second = o2 ? setTypeSize(o2) : 0;\n\n    if (first < second) return 1;\n    if (first > second) return -1;\n    return 0;\n}\n\nvoid sinterGenericCommand(client *c, robj **setkeys,\n                          unsigned long setnum, robj *dstkey) {\n    robj **sets = zmalloc(sizeof(robj*)*setnum);\n    setTypeIterator *si;\n    robj *dstset = NULL;\n    sds elesds;\n    int64_t intobj;\n    void *replylen = NULL;\n    unsigned long j, cardinality = 0;\n    int encoding, empty = 0;\n\n    for (j = 0; j < setnum; j++) {\n        robj *setobj = dstkey ?\n            lookupKeyWrite(c->db,setkeys[j]) :\n            lookupKeyRead(c->db,setkeys[j]);\n        if (!setobj) {\n            /* A NULL is considered an empty set */\n            empty += 1;\n            sets[j] = NULL;\n            continue;\n        }\n        if (checkType(c,setobj,OBJ_SET)) {\n            zfree(sets);\n            return;\n        }\n        sets[j] = setobj;\n    }\n\n    /* Set intersection with an empty set always results in an empty set.\n     * Return ASAP if there is an empty set. */\n    if (empty > 0) {\n        zfree(sets);\n        if (dstkey) {\n            if (dbDelete(c->db,dstkey)) {\n                signalModifiedKey(c,c->db,dstkey);\n                notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",dstkey,c->db->id);\n                server.dirty++;\n            }\n            addReply(c,shared.czero);\n        } else {\n            addReply(c,shared.emptyset[c->resp]);\n        }\n        return;\n    }\n\n    /* Sort sets from the smallest to largest, this will improve our\n     * algorithm's performance */\n    qsort(sets,setnum,sizeof(robj*),qsortCompareSetsByCardinality);\n\n    /* The first thing we should output is the total number of elements...\n     * since this is a multi-bulk write, but at this stage we don't know\n     * the intersection set size, so we use a trick, append an empty object\n     * to the output list and save the pointer to later modify it with the\n     * right length */\n    if (!dstkey) {\n        replylen = addReplyDeferredLen(c);\n    } else {\n        /* If we have a target key where to store the resulting set\n         * create this key with an empty set inside */\n        dstset = createIntsetObject();\n    }\n\n    /* Iterate all the elements of the first (smallest) set, and test\n     * the element against all the other sets, if at least one set does\n     * not include the element it is discarded */\n    si = setTypeInitIterator(sets[0]);\n    while((encoding = setTypeNext(si,&elesds,&intobj)) != -1) {\n        for (j = 1; j < setnum; j++) {\n            if (sets[j] == sets[0]) continue;\n            if (encoding == OBJ_ENCODING_INTSET) {\n                /* intset with intset is simple... and fast */\n                if (sets[j]->encoding == OBJ_ENCODING_INTSET &&\n                    !intsetFind((intset*)sets[j]->ptr,intobj))\n                {\n                    break;\n                /* in order to compare an integer with an object we\n                 * have to use the generic function, creating an object\n                 * for this */\n                } else if (sets[j]->encoding == OBJ_ENCODING_HT) {\n                    elesds = sdsfromlonglong(intobj);\n                    if (!setTypeIsMember(sets[j],elesds)) {\n                        sdsfree(elesds);\n                        break;\n                    }\n                    sdsfree(elesds);\n                }\n            } else if (encoding == OBJ_ENCODING_HT) {\n                if (!setTypeIsMember(sets[j],elesds)) {\n                    break;\n                }\n            }\n        }\n\n        /* Only take action when all sets contain the member */\n        if (j == setnum) {\n            if (!dstkey) {\n                if (encoding == OBJ_ENCODING_HT)\n                    addReplyBulkCBuffer(c,elesds,sdslen(elesds));\n                else\n                    addReplyBulkLongLong(c,intobj);\n                cardinality++;\n            } else {\n                if (encoding == OBJ_ENCODING_INTSET) {\n                    elesds = sdsfromlonglong(intobj);\n                    setTypeAdd(dstset,elesds);\n                    sdsfree(elesds);\n                } else {\n                    setTypeAdd(dstset,elesds);\n                }\n            }\n        }\n    }\n    setTypeReleaseIterator(si);\n\n    if (dstkey) {\n        /* Store the resulting set into the target, if the intersection\n         * is not an empty set. */\n        int deleted = dbDelete(c->db,dstkey);\n        if (setTypeSize(dstset) > 0) {\n            dbAdd(c->db,dstkey,dstset);\n            addReplyLongLong(c,setTypeSize(dstset));\n            notifyKeyspaceEvent(NOTIFY_SET,\"sinterstore\",\n                dstkey,c->db->id);\n        } else {\n            decrRefCount(dstset);\n            addReply(c,shared.czero);\n            if (deleted)\n                notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",\n                    dstkey,c->db->id);\n        }\n        signalModifiedKey(c,c->db,dstkey);\n        server.dirty++;\n    } else {\n        setDeferredSetLen(c,replylen,cardinality);\n    }\n    zfree(sets);\n}\n\n/* SINTER key [key ...] */\nvoid sinterCommand(client *c) {\n    sinterGenericCommand(c,c->argv+1,c->argc-1,NULL);\n}\n\n/* SINTERSTORE destination key [key ...] */\nvoid sinterstoreCommand(client *c) {\n    sinterGenericCommand(c,c->argv+2,c->argc-2,c->argv[1]);\n}\n\n#define SET_OP_UNION 0\n#define SET_OP_DIFF 1\n#define SET_OP_INTER 2\n\nvoid sunionDiffGenericCommand(client *c, robj **setkeys, int setnum,\n                              robj *dstkey, int op) {\n    robj **sets = zmalloc(sizeof(robj*)*setnum);\n    setTypeIterator *si;\n    robj *dstset = NULL;\n    sds ele;\n    int j, cardinality = 0;\n    int diff_algo = 1;\n\n    for (j = 0; j < setnum; j++) {\n        robj *setobj = dstkey ?\n            lookupKeyWrite(c->db,setkeys[j]) :\n            lookupKeyRead(c->db,setkeys[j]);\n        if (!setobj) {\n            sets[j] = NULL;\n            continue;\n        }\n        if (checkType(c,setobj,OBJ_SET)) {\n            zfree(sets);\n            return;\n        }\n        sets[j] = setobj;\n    }\n\n    /* Select what DIFF algorithm to use.\n     *\n     * Algorithm 1 is O(N*M) where N is the size of the element first set\n     * and M the total number of sets.\n     *\n     * Algorithm 2 is O(N) where N is the total number of elements in all\n     * the sets.\n     *\n     * We compute what is the best bet with the current input here. */\n    if (op == SET_OP_DIFF && sets[0]) {\n        long long algo_one_work = 0, algo_two_work = 0;\n\n        for (j = 0; j < setnum; j++) {\n            if (sets[j] == NULL) continue;\n\n            algo_one_work += setTypeSize(sets[0]);\n            algo_two_work += setTypeSize(sets[j]);\n        }\n\n        /* Algorithm 1 has better constant times and performs less operations\n         * if there are elements in common. Give it some advantage. */\n        algo_one_work /= 2;\n        diff_algo = (algo_one_work <= algo_two_work) ? 1 : 2;\n\n        if (diff_algo == 1 && setnum > 1) {\n            /* With algorithm 1 it is better to order the sets to subtract\n             * by decreasing size, so that we are more likely to find\n             * duplicated elements ASAP. */\n            qsort(sets+1,setnum-1,sizeof(robj*),\n                qsortCompareSetsByRevCardinality);\n        }\n    }\n\n    /* We need a temp set object to store our union. If the dstkey\n     * is not NULL (that is, we are inside an SUNIONSTORE operation) then\n     * this set object will be the resulting object to set into the target key*/\n    dstset = createIntsetObject();\n\n    if (op == SET_OP_UNION) {\n        /* Union is trivial, just add every element of every set to the\n         * temporary set. */\n        for (j = 0; j < setnum; j++) {\n            if (!sets[j]) continue; /* non existing keys are like empty sets */\n\n            si = setTypeInitIterator(sets[j]);\n            while((ele = setTypeNextObject(si)) != NULL) {\n                if (setTypeAdd(dstset,ele)) cardinality++;\n                sdsfree(ele);\n            }\n            setTypeReleaseIterator(si);\n        }\n    } else if (op == SET_OP_DIFF && sets[0] && diff_algo == 1) {\n        /* DIFF Algorithm 1:\n         *\n         * We perform the diff by iterating all the elements of the first set,\n         * and only adding it to the target set if the element does not exist\n         * into all the other sets.\n         *\n         * This way we perform at max N*M operations, where N is the size of\n         * the first set, and M the number of sets. */\n        si = setTypeInitIterator(sets[0]);\n        while((ele = setTypeNextObject(si)) != NULL) {\n            for (j = 1; j < setnum; j++) {\n                if (!sets[j]) continue; /* no key is an empty set. */\n                if (sets[j] == sets[0]) break; /* same set! */\n                if (setTypeIsMember(sets[j],ele)) break;\n            }\n            if (j == setnum) {\n                /* There is no other set with this element. Add it. */\n                setTypeAdd(dstset,ele);\n                cardinality++;\n            }\n            sdsfree(ele);\n        }\n        setTypeReleaseIterator(si);\n    } else if (op == SET_OP_DIFF && sets[0] && diff_algo == 2) {\n        /* DIFF Algorithm 2:\n         *\n         * Add all the elements of the first set to the auxiliary set.\n         * Then remove all the elements of all the next sets from it.\n         *\n         * This is O(N) where N is the sum of all the elements in every\n         * set. */\n        for (j = 0; j < setnum; j++) {\n            if (!sets[j]) continue; /* non existing keys are like empty sets */\n\n            si = setTypeInitIterator(sets[j]);\n            while((ele = setTypeNextObject(si)) != NULL) {\n                if (j == 0) {\n                    if (setTypeAdd(dstset,ele)) cardinality++;\n                } else {\n                    if (setTypeRemove(dstset,ele)) cardinality--;\n                }\n                sdsfree(ele);\n            }\n            setTypeReleaseIterator(si);\n\n            /* Exit if result set is empty as any additional removal\n             * of elements will have no effect. */\n            if (cardinality == 0) break;\n        }\n    }\n\n    /* Output the content of the resulting set, if not in STORE mode */\n    if (!dstkey) {\n        addReplySetLen(c,cardinality);\n        si = setTypeInitIterator(dstset);\n        while((ele = setTypeNextObject(si)) != NULL) {\n            addReplyBulkCBuffer(c,ele,sdslen(ele));\n            sdsfree(ele);\n        }\n        setTypeReleaseIterator(si);\n        server.lazyfree_lazy_server_del ? freeObjAsync(dstset) :\n                                          decrRefCount(dstset);\n    } else {\n        /* If we have a target key where to store the resulting set\n         * create this key with the result set inside */\n        int deleted = dbDelete(c->db,dstkey);\n        if (setTypeSize(dstset) > 0) {\n            dbAdd(c->db,dstkey,dstset);\n            addReplyLongLong(c,setTypeSize(dstset));\n            notifyKeyspaceEvent(NOTIFY_SET,\n                op == SET_OP_UNION ? \"sunionstore\" : \"sdiffstore\",\n                dstkey,c->db->id);\n        } else {\n            decrRefCount(dstset);\n            addReply(c,shared.czero);\n            if (deleted)\n                notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",\n                    dstkey,c->db->id);\n        }\n        signalModifiedKey(c,c->db,dstkey);\n        server.dirty++;\n    }\n    zfree(sets);\n}\n\n/* SUNION key [key ...] */\nvoid sunionCommand(client *c) {\n    sunionDiffGenericCommand(c,c->argv+1,c->argc-1,NULL,SET_OP_UNION);\n}\n\n/* SUNIONSTORE destination key [key ...] */\nvoid sunionstoreCommand(client *c) {\n    sunionDiffGenericCommand(c,c->argv+2,c->argc-2,c->argv[1],SET_OP_UNION);\n}\n\n/* SDIFF key [key ...] */\nvoid sdiffCommand(client *c) {\n    sunionDiffGenericCommand(c,c->argv+1,c->argc-1,NULL,SET_OP_DIFF);\n}\n\n/* SDIFFSTORE destination key [key ...] */\nvoid sdiffstoreCommand(client *c) {\n    sunionDiffGenericCommand(c,c->argv+2,c->argc-2,c->argv[1],SET_OP_DIFF);\n}\n\nvoid sscanCommand(client *c) {\n    robj *set;\n    unsigned long cursor;\n\n    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) return;\n    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||\n        checkType(c,set,OBJ_SET)) return;\n    scanGenericCommand(c,set,cursor);\n}\n"], "filenames": ["src/intset.c", "src/rdb.c", "src/t_set.c"], "buggy_code_start_loc": [36, 1521, 69], "buggy_code_end_loc": [107, 1522, 70], "fixing_code_start_loc": [37, 1521, 69], "fixing_code_end_loc": [109, 1524, 73], "type": "CWE-190", "message": "Redis is an open source, in-memory database that persists on disk. An integer overflow bug affecting all versions of Redis can be exploited to corrupt the heap and potentially be used to leak arbitrary contents of the heap or trigger remote code execution. The vulnerability involves changing the default set-max-intset-entries configuration parameter to a very large value and constructing specially crafted commands to manipulate sets. The problem is fixed in Redis versions 6.2.6, 6.0.16 and 5.0.14. An additional workaround to mitigate the problem without patching the redis-server executable is to prevent users from modifying the set-max-intset-entries configuration parameter. This can be done using ACL to restrict unprivileged users from using the CONFIG SET command.", "other": {"cve": {"id": "CVE-2021-32687", "sourceIdentifier": "security-advisories@github.com", "published": "2021-10-04T18:15:08.980", "lastModified": "2022-10-06T16:58:42.073", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Redis is an open source, in-memory database that persists on disk. An integer overflow bug affecting all versions of Redis can be exploited to corrupt the heap and potentially be used to leak arbitrary contents of the heap or trigger remote code execution. The vulnerability involves changing the default set-max-intset-entries configuration parameter to a very large value and constructing specially crafted commands to manipulate sets. The problem is fixed in Redis versions 6.2.6, 6.0.16 and 5.0.14. An additional workaround to mitigate the problem without patching the redis-server executable is to prevent users from modifying the set-max-intset-entries configuration parameter. This can be done using ACL to restrict unprivileged users from using the CONFIG SET command."}, {"lang": "es", "value": "Redis es una base de datos en memoria de c\u00f3digo abierto que persiste en el disco. Un error de desbordamiento de enteros que afecta a todas las versiones de Redis puede ser explotado para corromper la pila y potencialmente ser usado para filtrar contenidos arbitrarios de la pila o desencadenar una ejecuci\u00f3n de c\u00f3digo remota . La vulnerabilidad implica cambiar el par\u00e1metro de configuraci\u00f3n por defecto set-max-intset-entries a un valor muy grande y construir comandos especialmente dise\u00f1ados para manipular conjuntos. El problema se ha corregido en las versiones de Redis 6.2.6, 6.0.16 y 5.0.14. Una soluci\u00f3n adicional para mitigar el problema sin parchear el ejecutable de redis-server es evitar que los usuarios modifiquen el par\u00e1metro de configuraci\u00f3n set-max-intset-entries. Esto puede hacerse usando ACL para restringir a usuarios sin privilegios el uso del comando CONFIG SET"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.8, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}, {"lang": "en", "value": "CWE-680"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.0.14", "matchCriteriaId": "D5D64A76-B253-4A64-8AA2-DD8815CB3CF8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0.0", "versionEndExcluding": "6.0.16", "matchCriteriaId": "02DF8086-645E-4D42-93D3-A4B11D289C7C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.2.0", "versionEndExcluding": "6.2.6", "matchCriteriaId": "4686800E-16BA-42CE-B691-011D1D5D0CC2"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:management_services_for_element_software:-:*:*:*:*:*:*:*", "matchCriteriaId": "86B51137-28D9-41F2-AFA2-3CC22B4954D1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:management_services_for_netapp_hci:-:*:*:*:*:*:*:*", "matchCriteriaId": "4455CF3A-CC91-4BE4-A7AB-929AC82E34F5"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_operations_monitor:4.3:*:*:*:*:*:*:*", "matchCriteriaId": "CBE1A019-7BB6-4226-8AC4-9D6927ADAEFA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_operations_monitor:4.4:*:*:*:*:*:*:*", "matchCriteriaId": "B98BAEB2-A540-4E8A-A946-C4331B913AFD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_operations_monitor:5.0:*:*:*:*:*:*:*", "matchCriteriaId": "B8FBE260-E306-4215-80C0-D2D27CA43E0F"}]}]}], "references": [{"url": "https://github.com/redis/redis/commit/a30d367a71b7017581cf1ca104242a3c644dec0f", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/redis/redis/security/advisories/GHSA-m3mf-8x9w-r27q", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HTYQ5ZF37HNGTZWVNJD3VXP7I6MEEF42/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VL5KXFN3ATM7IIM7Q4O4PWTSRGZ5744Z/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WR5WKJWXD4D6S3DJCZ56V74ESLTDQRAB/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202209-17", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20211104-0003/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2021/dsa-5001", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2022.html", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/redis/redis/commit/a30d367a71b7017581cf1ca104242a3c644dec0f"}}