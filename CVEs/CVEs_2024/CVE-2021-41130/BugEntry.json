{"buggy_code": ["/* Copyright (C) Extensible Service Proxy Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef API_MANAGER_REQUEST_H_\n#define API_MANAGER_REQUEST_H_\n\n#include <map>\n#include <string>\n\n#include \"include/api_manager/protocol.h\"\n#include \"include/api_manager/utils/status.h\"\n\nnamespace google {\nnamespace api_manager {\n\n// Request provides an interface for CallHandler::Check to use to\n// query information about a request.\nclass Request {\n public:\n  virtual ~Request() {}\n\n  // Returns the HTTP method used for this call.\n  virtual std::string GetRequestHTTPMethod() = 0;\n\n  // Returns the query parameters\n  virtual std::string GetQueryParameters() = 0;\n\n  // Returns the REST path or RPC path for this call.\n  // It is the \"Unparsed\" path without the query parameters.\n  virtual std::string GetRequestPath() = 0;\n\n  // Returns the REST path or RPC path for this call.\n  // It should be \"Unparsed\" original URL path.\n  virtual std::string GetUnparsedRequestPath() = 0;\n\n  // Gets Client IP\n  // This will be used by service control Check() call.\n  virtual std::string GetClientIP() = 0;\n  // Gets Client Host.\n  virtual std::string GetClientHost() { return \"\"; }\n\n  // Get GRPC stats.\n  virtual int64_t GetGrpcRequestBytes() = 0;\n  virtual int64_t GetGrpcResponseBytes() = 0;\n  virtual int64_t GetGrpcRequestMessageCounts() = 0;\n  virtual int64_t GetGrpcResponseMessageCounts() = 0;\n\n  // Finds a HTTP query parameter with a name. Returns true if found.\n  virtual bool FindQuery(const std::string &name, std::string *query) = 0;\n\n  // Finds a HTTP header with a name. Returns true if found.\n  // Don't support multiple headers with same name for now. In that case,\n  // the first header will be returned.\n  virtual bool FindHeader(const std::string &name, std::string *header) = 0;\n\n  // Returns the protocol used for this call.\n  virtual ::google::api_manager::protocol::Protocol GetFrontendProtocol() = 0;\n  virtual ::google::api_manager::protocol::Protocol GetBackendProtocol() = 0;\n\n  // Sets auth token to the request object. Caller of RequestHandler::Check\n  // need to use it compose error message if authentication fails.\n  virtual void SetAuthToken(const std::string &auth_token) = 0;\n\n  // Adds a header to backend. If the header exists, overwrite its value\n  virtual utils::Status AddHeaderToBackend(const std::string &key,\n                                           const std::string &value) = 0;\n};\n\n}  // namespace api_manager\n}  // namespace google\n\n#endif  // API_MANAGER_REQUEST_H_\n", "// Copyright (C) Extensible Service Proxy Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////////\n#include \"src/api_manager/check_auth.h\"\n\n#include <chrono>\n#include <string>\n\n#include \"include/api_manager/api_manager.h\"\n#include \"include/api_manager/request.h\"\n#include \"src/api_manager/auth.h\"\n#include \"src/api_manager/auth/lib/auth_jwt_validator.h\"\n#include \"src/api_manager/auth/lib/auth_token.h\"\n#include \"src/api_manager/auth/lib/base64.h\"\n#include \"src/api_manager/auth/lib/json.h\"\n#include \"src/api_manager/auth/lib/json_util.h\"\n#include \"src/api_manager/cloud_trace/cloud_trace.h\"\n#include \"src/api_manager/utils/url_util.h\"\n\nusing ::google::api_manager::auth::Certs;\nusing ::google::api_manager::auth::GetStringValue;\nusing ::google::api_manager::auth::JwtCache;\nusing ::google::api_manager::auth::JwtValidator;\nusing ::google::api_manager::auth::JwtValue;\nusing ::google::api_manager::utils::Status;\nusing ::google::protobuf::util::error::Code;\nusing std::chrono::system_clock;\n\nnamespace google {\nnamespace api_manager {\n\nnamespace {\nconst char kAccessTokenName[] = \"access_token\";\nconst char kAuthHeader[] = \"authorization\";\nconst char kAuthHeaderIAP[] = \"x-goog-iap-jwt-assertion\";\nconst char kBearer[] = \"Bearer \";\n\n// An AuthChecker object is created for every incoming request. It authenticates\n// the request, extracts user info from the auth token and sets it to the\n// request context.\nclass AuthChecker : public std::enable_shared_from_this<AuthChecker> {\n public:\n  AuthChecker(std::shared_ptr<context::RequestContext> context,\n              std::function<void(Status status)> continuation);\n\n  // Check auth for a given request. This is the starting point to enter\n  // the auth state machine.\n  void Check();\n\n private:\n  /*** Steps in auth state machine, ordered in execution sequence. ***/\n\n  // Not all the steps are executed for every request.\n  // For example, in case of a JWT cache hit, only four steps are executed:\n  // GetAuthToken() --> LookupJwtCache() --> CheckAudience() --> PassUserInfo()\n  // In the case of a JWT cache miss, but a key cache hit, the steps are:\n  // GetAuthToken() --> LookupJwtCache() --> ParseJwt() --> CheckAudience() -->\n  // InitKey() --> VerifySignature() --> PassUserInfo()\n  void GetAuthToken();\n\n  void LookupJwtCache();\n\n  void ParseJwt();\n\n  void CheckAudience(bool cache_hit);\n\n  void InitKey();\n\n  void DiscoverJwksUri(const std::string &url);\n\n  // Callback function for open ID discovery http fetch.\n  void PostFetchJwksUri(Status status, std::string &&body);\n\n  void FetchPubKey(const std::string &url);\n\n  // Callback function for public key http fetch.\n  void PostFetchPubKey(Status status, std::string &&body);\n\n  void VerifySignature();\n\n  void PassUserInfoOnSuccess();\n\n  /*** Helper functions ***/\n\n  // Returns a shared pointer of this AuthChecker object.\n  std::shared_ptr<AuthChecker> GetPtr() { return shared_from_this(); }\n\n  // Helper function to send a http GET request.\n  void HttpFetch(const std::string &url,\n                 std::function<void(Status, std::string &&)> continuation);\n\n  // Authentication error\n  void Unauthenticated(const std::string &error);\n\n  // Authorization error\n  void Unauthorized(const std::string &error);\n\n  // Fetch error, takes upstream error\n  void FetchFailure(const std::string &error, Status status);\n\n  /*** Member Variables. ***/\n\n  // Request context.\n  std::shared_ptr<context::RequestContext> context_;\n\n  // JWT validator.\n  std::unique_ptr<auth::JwtValidator> validator_;\n\n  // User info extracted from auth token.\n  UserInfo user_info_;\n\n  // Pointer to access ESP running environment.\n  ApiManagerEnvInterface *env_;\n\n  // auth token.\n  std::string auth_token_;\n\n  // The final continuation function.\n  std::function<void(Status status)> on_done_;\n\n  // Trace span for check auth.\n  std::shared_ptr<cloud_trace::CloudTraceSpan> trace_span_;\n};\n\nAuthChecker::AuthChecker(std::shared_ptr<context::RequestContext> context,\n                         std::function<void(Status status)> continuation)\n    : context_(context),\n      env_(context_->service_context()->env()),\n      on_done_(continuation) {}\n\nvoid AuthChecker::Check() {\n  if (!context_->service_context()->RequireAuth() ||\n      context_->method() == nullptr || !context_->method()->auth()) {\n    env_->LogDebug(\"Auth not required.\");\n    on_done_(Status::OK);\n    return;\n  }\n\n  // CreateSpan returns nullptr if trace is disabled.\n  trace_span_.reset(CreateSpan(context_->cloud_trace(), \"CheckAuth\"));\n\n  GetAuthToken();\n  if (auth_token_.empty()) {\n    Unauthenticated(\"Missing or invalid credentials\");\n    return;\n  }\n  context_->request()->SetAuthToken(auth_token_);\n  context_->SetAuthToken(auth_token_);\n  env_->LogDebug(std::string(\"auth token: \") + auth_token_);\n  LookupJwtCache();\n}\n\nvoid AuthChecker::GetAuthToken() {\n  Request *r = context_->request();\n  // IAP header is of format \"X-Goog-Iap-Jwt-Assertion\": \"eyJhbG...\". No\n  // \"Bearer\" prefix is needed.\n  if (r->FindHeader(kAuthHeaderIAP, &auth_token_)) {\n    return;\n  }\n\n  std::string auth_header;\n  if (!r->FindHeader(kAuthHeader, &auth_header)) {\n    // When authorization header is missing, check query parameter.\n    r->FindQuery(kAccessTokenName, &auth_token_);\n    return;\n  }\n\n  static const size_t bearer_len = sizeof(kBearer) - 1;\n  if (auth_header.size() <= bearer_len ||\n      auth_header.compare(0, bearer_len, kBearer) != 0) {\n    // Authorization header is not long enough, or authorization header does\n    // not begin with \"Bearer \", set auth_token_ to the whole string.\n    auth_token_ = auth_header;\n    return;\n  }\n\n  auth_token_ = auth_header.substr(bearer_len);\n}\n\nvoid AuthChecker::LookupJwtCache() {\n  bool remove = false;  // whether or not need to remove an expired entry.\n  bool cache_hit = false;\n  JwtCache &jwt_cache = context_->service_context()->jwt_cache();\n  {\n    JwtCache::ScopedLookup lookup(&jwt_cache, auth_token_);\n    if (lookup.Found()) {\n      JwtValue *val = lookup.value();\n      if (system_clock::now() <= val->exp) {\n        // Cache hit and cache entry is not expired.\n        user_info_ = val->user_info;\n        cache_hit = true;\n      } else {\n        // Need to removes the expired cache entry.\n        remove = true;\n      }\n    }\n  }\n  if (remove) {\n    jwt_cache.Remove(auth_token_);\n  }\n\n  if (cache_hit) {\n    CheckAudience(true);\n  } else {\n    ParseJwt();\n  }\n}\n\nvoid AuthChecker::ParseJwt() {\n  if (validator_ == nullptr) {\n    validator_ = JwtValidator::Create(auth_token_.c_str(), auth_token_.size());\n    if (validator_ == nullptr) {\n      Unauthenticated(\"Internal error\");\n      return;\n    }\n  }\n\n  Status status = validator_->Parse(&user_info_);\n  if (!status.ok()) {\n    Unauthenticated(status.message());\n    return;\n  }\n  CheckAudience(false);\n}\n\nvoid AuthChecker::CheckAudience(bool cache_hit) {\n  std::string audience = user_info_.audiences.empty()\n                             ? std::string()\n                             : user_info_.AudiencesAsString();\n  context_->set_auth_issuer(user_info_.issuer);\n  context_->set_auth_audience(audience);\n  context_->set_auth_authorized_party(user_info_.authorized_party);\n\n  context_->set_auth_claims(user_info_.claims);\n\n  // Remove http/s header and trailing '/' for issuer.\n  std::string issuer = utils::GetUrlContent(user_info_.issuer);\n  if (!context_->method()->isIssuerAllowed(issuer)) {\n    Unauthenticated(\"Issuer not allowed\");\n    return;\n  }\n\n  // The audience from the JWT must\n  //   - Equals to service_name or\n  //   - Explicitly allowed by the issuer in the method configuration.\n  // Otherwise the JWT is rejected.\n  const std::string &service_name = context_->service_context()->service_name();\n  // Remove http/s header and trailing '/' for audiences.\n  std::set<std::string> aud;\n  for (auto &it : user_info_.audiences) {\n    aud.insert(utils::GetUrlContent(it));\n  }\n  if (aud.find(service_name) == aud.end() &&\n      !context_->method()->isAudienceAllowed(issuer, aud)) {\n    Unauthorized(\"Audience not allowed\");\n    return;\n  }\n  if (cache_hit) {\n    PassUserInfoOnSuccess();\n  } else {\n    InitKey();\n  }\n}\n\nvoid AuthChecker::InitKey() {\n  Certs &key_cache = context_->service_context()->certs();\n  auto cert = key_cache.GetCert(user_info_.issuer);\n\n  if (cert == nullptr || system_clock::now() > cert->second) {\n    // Key has not been fetched or has expired.\n    std::string url;\n    bool tryOpenId =\n        context_->service_context()->GetJwksUri(user_info_.issuer, &url);\n    if (url.empty()) {\n      Unauthenticated(\"Cannot determine the URI of the key\");\n      return;\n    }\n\n    if (tryOpenId) {\n      DiscoverJwksUri(url);\n    } else {\n      // JwksUri is available. No need to try openID discovery.\n      FetchPubKey(url);\n    }\n  } else {\n    // Key is in the cache, next step is to verify signature.\n    VerifySignature();\n  }\n}\n\nvoid AuthChecker::DiscoverJwksUri(const std::string &url) {\n  auto pChecker = GetPtr();\n  HttpFetch(url, [pChecker](Status status, std::string &&body) {\n    pChecker->PostFetchJwksUri(status, std::move(body));\n  });\n}\n\nvoid AuthChecker::PostFetchJwksUri(Status status, std::string &&body) {\n  if (!status.ok()) {\n    context_->service_context()->SetJwksUri(user_info_.issuer, std::string(),\n                                            false);\n    FetchFailure(\"Unable to fetch URI of the key via OpenID discovery\", status);\n    return;\n  }\n\n  // Parse discovery doc and extract jwks_uri\n  grpc_json *discovery_json = grpc_json_parse_string_with_len(\n      const_cast<char *>(body.c_str()), body.size());\n  const char *jwks_uri;\n  if (discovery_json != nullptr) {\n    jwks_uri = GetStringValue(discovery_json, \"jwks_uri\");\n    grpc_json_destroy(discovery_json);\n  } else {\n    jwks_uri = nullptr;\n  }\n\n  if (jwks_uri == nullptr) {\n    env_->LogError(\"OpenID discovery failed due to invalid doc format\");\n    context_->service_context()->SetJwksUri(user_info_.issuer, std::string(),\n                                            false);\n    Unauthenticated(\"Unable to parse URI of the key via OpenID discovery\");\n    return;\n  }\n\n  // OpenID discovery completed. Set jwks_uri for the issuer in cache.\n  context_->service_context()->SetJwksUri(user_info_.issuer, jwks_uri, false);\n\n  FetchPubKey(jwks_uri);\n}\n\nvoid AuthChecker::FetchPubKey(const std::string &url) {\n  auto pChecker = GetPtr();\n  HttpFetch(url, [pChecker](Status status, std::string &&body) {\n    pChecker->PostFetchPubKey(status, std::move(body));\n  });\n}\n\nvoid AuthChecker::PostFetchPubKey(Status status, std::string &&body) {\n  if (!status.ok() || body.empty()) {\n    FetchFailure(\"Unable to fetch verification key\", status);\n    return;\n  }\n\n  Certs &key_cache = context_->service_context()->certs();\n  int cache_duration_in_s =\n      context_->service_context()->global_context()->jwks_cache_duration_in_s();\n  key_cache.Update(\n      user_info_.issuer, std::move(body),\n      system_clock::now() + std::chrono::seconds(cache_duration_in_s));\n  VerifySignature();\n}\n\nvoid AuthChecker::VerifySignature() {\n  Certs &key_cache = context_->service_context()->certs();\n  auto cert = key_cache.GetCert(user_info_.issuer);\n  if (cert == nullptr) {\n    Unauthenticated(\"Missing verification key\");\n    return;\n  }\n\n  Status status =\n      validator_->VerifySignature(cert->first.c_str(), cert->first.size());\n  if (!status.ok()) {\n    Unauthenticated(status.message());\n    return;\n  }\n\n  // Inserts the entry to JwtCache.\n  JwtCache &cache = context_->service_context()->jwt_cache();\n  cache.Insert(auth_token_, user_info_, validator_->GetExpirationTime(),\n               system_clock::now());\n\n  PassUserInfoOnSuccess();\n}\n\nvoid AuthChecker::PassUserInfoOnSuccess() {\n  char *json_buf = auth::WriteUserInfoToJson(user_info_);\n  if (json_buf == nullptr) {\n    return;\n  }\n  char *base64_json_buf = auth::esp_base64_encode(\n      json_buf, strlen(json_buf), true, false, true /*padding*/);\n  context_->request()->AddHeaderToBackend(auth::kEndpointApiUserInfo,\n                                          base64_json_buf);\n  auth::esp_grpc_free(json_buf);\n  auth::esp_grpc_free(base64_json_buf);\n\n  TRACE(trace_span_) << \"Authenticated.\";\n  trace_span_.reset();\n  on_done_(Status::OK);\n}\n\nvoid AuthChecker::Unauthenticated(const std::string &error) {\n  TRACE(trace_span_) << \"Authentication failed: \" << error;\n  trace_span_.reset();\n  on_done_(Status(Code::UNAUTHENTICATED,\n                  std::string(\"JWT validation failed: \") + error,\n                  Status::AUTH));\n}\n\nvoid AuthChecker::Unauthorized(const std::string &error) {\n  TRACE(trace_span_) << \"Authorization failed: \" << error;\n  trace_span_.reset();\n  on_done_(Status(Code::PERMISSION_DENIED,\n                  std::string(\"JWT validation failed: \") + error,\n                  Status::AUTH));\n}\n\nvoid AuthChecker::FetchFailure(const std::string &error, Status status) {\n  // Append HTTP response code for the upstream statuses\n  trace_span_.reset();\n  on_done_(Status(Code::UNAUTHENTICATED,\n                  std::string(\"JWT validation failed: \") + error +\n                      (status.code() >= 300 ? \". HTTP response code: \" +\n                                                  std::to_string(status.code())\n                                            : \"\"),\n                  Status::AUTH));\n}\n\nvoid AuthChecker::HttpFetch(\n    const std::string &url,\n    std::function<void(Status, std::string &&)> continuation) {\n  std::shared_ptr<cloud_trace::CloudTraceSpan> fetch_span(\n      CreateChildSpan(trace_span_.get(), \"HttpFetch\"));\n  env_->LogDebug(std::string(\"http fetch: \") + url);\n  TRACE(fetch_span) << \"Http request URL: \" << url;\n\n  std::unique_ptr<HTTPRequest> request(\n      new HTTPRequest([continuation, fetch_span](\n                          Status status, std::map<std::string, std::string> &&,\n                          std::string &&body) {\n        TRACE(fetch_span) << \"Http response status: \" << status.ToString();\n        continuation(status, std::move(body));\n      }));\n  if (!request) {\n    continuation(Status(Code::INTERNAL, \"Out of memory\"), \"\");\n    return;\n  }\n\n  request->set_method(\"GET\").set_url(url);\n  env_->RunHTTPRequest(std::move(request));\n}\n\n}  // namespace\n\nvoid CheckAuth(std::shared_ptr<context::RequestContext> context,\n               std::function<void(Status status)> continuation) {\n  std::shared_ptr<AuthChecker> authChecker =\n      std::make_shared<AuthChecker>(context, continuation);\n  authChecker->Check();\n}\n\n}  // namespace api_manager\n}  // namespace google\n", "// Copyright (C) Extensible Service Proxy Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n#include \"src/api_manager/check_auth.h\"\n\n#include \"src/api_manager/check_workflow.h\"\n#include \"src/api_manager/context/service_context.h\"\n#include \"src/api_manager/mock_api_manager_environment.h\"\n#include \"src/api_manager/mock_request.h\"\n\nusing ::testing::_;\nusing ::testing::AllOf;\nusing ::testing::DoAll;\nusing ::testing::Field;\nusing ::testing::Invoke;\nusing ::testing::Mock;\nusing ::testing::Return;\n\nusing ::google::api_manager::utils::Status;\nusing ::google::protobuf::util::error::Code;\n\nnamespace google {\nnamespace api_manager {\n\nnamespace {\n\nconst char kAccessTokenName[] = \"access_token\";\nconst char kAuthHeader[] = \"authorization\";\nconst char kBearer[] = \"Bearer \";\n\nconst char kServiceConfig[] =\n    \"name: \\\"endpoints-test.cloudendpointsapis.com\\\"\\n\"\n    \"authentication {\\n\"\n    \"    providers: [\\n\"\n    \"    {\\n\"\n    \"      id: \\\"issuer1\\\"\\n\"\n    \"      issuer: \\\"https://issuer1.com\\\"\\n\"\n    \"    },\\n\"\n    \"    {\\n\"\n    \"      id: \\\"openid_fail\\\"\\n\"\n    \"      issuer: \\\"http://openid_fail\\\"\\n\"\n    \"    },\\n\"\n    \"    {\\n\"\n    \"      id: \\\"issuer2\\\"\\n\"\n    \"      issuer: \\\"https://issuer2.com\\\"\\n\"\n    \"      jwks_uri: \\\"https://issuer2.com/pubkey\\\"\\n\"\n    \"    }\\n\"\n    \"    ],\\n\"\n    \"    rules: {\\n\"\n    \"      selector: \\\"ListShelves\\\"\\n\"\n    \"      requirements: [\\n\"\n    \"      {\\n\"\n    \"        provider_id: \\\"issuer1\\\"\\n\"\n    \"      },\\n\"\n    \"      {\\n\"\n    \"        provider_id: \\\"openid_fail\\\"\\n\"\n    \"      },\\n\"\n    \"      {\\n\"\n    \"        provider_id: \\\"issuer2\\\"\\n\"\n    \"      }\\n\"\n    \"      ]\\n\"\n    \"    }\\n\"\n    \"}\\n\"\n    \"http {\\n\"\n    \"  rules {\\n\"\n    \"    selector: \\\"ListShelves\\\"\\n\"\n    \"    get: \\\"/ListShelves\\\"\\n\"\n    \"  }\\n\"\n    \"}\\n\"\n    \"control {\\n\"\n    \"  environment : \\\"http://127.0.0.1:8081\\\"\\n\"\n    \"}\\n\";\n\n// Auth token generated with the following header and payload.\n//{\n// \"alg\": \"RS256\",\n// \"typ\": \"JWT\",\n// \"kid\": \"b3319a147514df7ee5e4bcdee51350cc890cc89e\"\n//}\n//{\n// \"iss\": \"https://issuer1.com\",\n// \"sub\": \"end-user-id\",\n// \"aud\": \"endpoints-test.cloudendpointsapis.com\",\n// \"iat\": 1461779321,\n// \"exp\": 2461782921\n//}\nconst char kToken[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImIzMzE5YTE0NzUxNGRmN2VlNWU0Ym\"\n    \"NkZWU1MTM1MGNjODkwY2M4OWUifQ.\"\n    \"eyJpc3MiOiJodHRwczovL2lzc3VlcjEuY29tIiwic3ViIjoiZW5kLXVzZXItaWQiLCJhdWQiOi\"\n    \"JlbmRwb2ludHMtdGVzdC5jbG91ZGVuZHBvaW50c2FwaXMuY29tIiwiaWF0IjoxNDYxNzc5MzIx\"\n    \"LCJleHAiOjI0NjE3ODI5MjF9.iiJj93x_KNSIh14nthz_N_\"\n    \"JsA6ZAZfQQxECrmhalrcw5jnlKKIwI_QFnv8y9EFyIHLfEt56-\"\n    \"GUXH7uLhed1sTJUNTd8sXyuFdSK1Cd3jAozvvZaYazhNIYC9ljh7hhm-\"\n    \"rHkirWTu1GxdRaJD3Az-B-VX3C_OWY9oHR2mhw0zxkEcMAgjf7GuGWr-AYtDmAMD_\"\n    \"fE8o7oXvD9eg506E5mcDa208m0N8Ysc3Ibdmfnux5B1pPB-5M-O2u2lVLjhne7SMCG9wv-\"\n    \"nnXCy9iAcTgCt6VmBtehZOBDQ0q8_08aWGoWBXntLwdXinVIs-zR-\"\n    \"4YUumdkEIIPF3IYE6ZAlloWG7Q\";\n\n// kToken2 is the same as kToken except that \"sub\" is \"another-user-id\".\nconst char kToken2[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImIzMzE5YTE0NzUxNGRmN2VlNWU0Ym\"\n    \"NkZWU1MTM1MGNjODkwY2M4OWUifQ.eyJpc3MiOiJodHRwczovL2lzc3VlcjEuY29tIiwic3ViI\"\n    \"joiYW5vdGhlci11c2VyLWlkIiwiYXVkIjoiZW5kcG9pbnRzLXRlc3QuY2xvdWRlbmRwb2ludHN\"\n    \"hcGlzLmNvbSIsImlhdCI6MTQ2MTc3OTMyMSwiZXhwIjoyNDYxNzgyOTIxfQ.ASIXY1N3fmGuDY\"\n    \"8-Xg6lCxiXM51wtTiGRmcYMk6_q_91D3D9cswVMfNp7YLf6sA4KQFxoTFAiWRqxT-kPzF5o2O8\"\n    \"ga4CY0VZAsiXRm-YTe7O8T2kFrVJOkABQIyNZgln8Sm15bO1MSyClj8Ti2qRAYPeoDM57X0f-u\"\n    \"0nQsWv0X8BsLvlJfu1J-4n08l_eEUFZlYGwpWCKfwvklmWXYfXdcJMeQ_poVqOti8dvSnqVi_Z\"\n    \"0Yu1r5Xuq45q4WNqQ9PRk1HFsWB7uV25m8fU2VpbRLFka6F9MZu4dU9gZoGCGDTtauCHiMqBTv\"\n    \"6vON8GbcB7w8pEhS1hK6FOehe4qZKnSA\";\n\n// kTokenOpenIdFail is the same as kToken except that \"iss\" is\n// \"http://openid_fail\".\nconst char kTokenOpenIdFail[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImIzMzE5YTE0NzUxNGRmN2VlNWU0Ym\"\n    \"NkZWU1MTM1MGNjODkwY2M4OWUifQ.\"\n    \"eyJpc3MiOiJodHRwOi8vb3BlbmlkX2ZhaWwiLCJzdWIiOiJlbmQtdXNlci1pZCIsImF1ZCI6Im\"\n    \"VuZHBvaW50cy10ZXN0LmNsb3VkZW5kcG9pbnRzYXBpcy5jb20iLCJpYXQiOjE0NjE3NzkzMjEs\"\n    \"ImV4cCI6MjQ2MTc4MjkyMX0.kauli_A55XB3AI-ZHrzlZs87VlMF_\"\n    \"iRyxAJs0BOCIZ0pYrsH4gKpheepafoJfYJcP5HYeC4JZuivKmfZn8hVjHZ-crXhxvnQf0AM-\"\n    \"nI4S80tuWewcvKQq3tpyoyjw0DAu4sI61ejCINvc2qEpiyp4jBcww1xxOFXbCOvSTbfJzISGSe\"\n    \"Kmqs5ryGHFyW-\"\n    \"rsGau030xa4ZnJo4qjzEaFqf9UwbWoEGhmJLHx6AWJUPnMtHN1YGZkCO7OXBk7gOOlVd5iNR-\"\n    \"OHDbpUEEYI2KM5N2MNdjN5QaAIwyvDnWTA3ivetbiiNP2sjt9Ar3fTkfO_\"\n    \"bjHTvoHiUKvPLTJfWeLVSzQ\";\n\n// kTokenOpenIdFail2 is the same as kTokenOpenIdFail except that \"sub\" is\n// \"another-user-id\".\nconst char kTokenOpenIdFail2[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImIzMzE5YTE0NzUxNGRmN2VlNWU0Ym\"\n    \"NkZWU1MTM1MGNjODkwY2M4OWUifQ.\"\n    \"eyJpc3MiOiJodHRwOi8vb3BlbmlkX2ZhaWwiLCJzdWIiOiJhbm90aGVyLXVzZXItaWQiLCJhdW\"\n    \"QiOiJlbmRwb2ludHMtdGVzdC5jbG91ZGVuZHBvaW50c2FwaXMuY29tIiwiaWF0IjoxNDYxNzc5\"\n    \"MzIxLCJleHAiOjI0NjE3ODI5MjF9.DYsI1A0CDZUbIniGAQy0JXyE9KjhmbSMxNzIrm_\"\n    \"5ogvwAXgpx4vStYtGU6w_Lv1vAtQHONY6zK4qzNBi3h-\"\n    \"wSXQtaFxycRphopohA56vyT6dP0BMWJQuDvWBUyxYWApP49XuVkZCFy3BFbJ8ZniuhzkgrRhTN\"\n    \"-L8jUiopUd6mtdPPc7ZLoWcKXrtsTjlNSOH7r2VmJTCeWgVsDCBRceFdLyNy1tfz5ibaTgP-\"\n    \"oL7tUQ1VnRkRoedLm17LoPKtu4-dbGchIaUnYfP1__gbHW48_oj_\"\n    \"QSbutSQYsxtx2ESZ78JFd1kFX0Qs5YL7u2k93Za49S3SuWH9CV7bca0leIzEw\";\n\n// kTokenIssuer2 is the same as kToken except that \"iss\" is\n// \"https://issuer2.com\".\nconst char kTokenIssuer2[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImIzMzE5YTE0NzUxNGRmN2VlNWU0Ym\"\n    \"NkZWU1MTM1MGNjODkwY2M4OWUifQ.\"\n    \"eyJpc3MiOiJodHRwczovL2lzc3VlcjIuY29tIiwic3ViIjoiZW5kLXVzZXItaWQiLCJhdWQiOi\"\n    \"JlbmRwb2ludHMtdGVzdC5jbG91ZGVuZHBvaW50c2FwaXMuY29tIiwiaWF0IjoxNDYxNzc5MzIx\"\n    \"LCJleHAiOjI0NjE3ODI5MjF9.iFPb5TSZXGBxzFKJ5FOZDr1sH_-5KEBRvJy5vtanbjX2H-\"\n    \"VU0aloWUeKCUGbtd9HdnHP4I7n-nivI1wltYK-E19aG3xswDZr3I5kg3JyNp-\"\n    \"T9a4EuQ7cue7ofxJi57l7vRDGQ-\"\n    \"9548QoenJP9vkJc4nb70xPF0CriwujaBr91jOaJmvc4W1ivXoIc1QgG9wHdRg8AgeIAaQhvnyj\"\n    \"F_Y9ut23lhAL8miYEs2ggwUSrImQzjed0t0205nz_\"\n    \"3rFZuei5DNEGbDoj6ja5jLvf11W2bCTkitEjYXUbomKm-RegWX6MjT-\"\n    \"zdhuVgY0vUaLFI1OFlKT7ArQQ5HZpw9lt4sKzg\";\n\n// kTokenExpired is the same as kToken except that \"exp\" is \"1461782921\".\nconst char kTokenExpired[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImIzMzE5YTE0NzUxNGRmN2VlNWU0Ym\"\n    \"NkZWU1MTM1MGNjODkwY2M4OWUifQ.\"\n    \"eyJpc3MiOiJodHRwczovL2lzc3VlcjEuY29tIiwic3ViIjoiZW5kLXVzZXItaWQiLCJhdWQiOi\"\n    \"JlbmRwb2ludHMtdGVzdC5jbG91ZGVuZHBvaW50c2FwaXMuY29tIiwiaWF0IjoxNDYxNzc5MzIx\"\n    \"LCJleHAiOjE0NjE3ODI5MjF9.Zlk_QD3FM5u-E7r2Vo4xrPfNUNtewfTmJPZUL_\"\n    \"MaLkWK3Do6ov0B8mj5nzf8fFyw3YTxhN7VjabDfwr2pTfVl0PA8Kx8XLz3R_\"\n    \"apAbP0UhKEBgYhv5GCLhiTTuq01QCDnhvcTVXRorWfe6ocC2GPTIHVA_M5U1v5nPopP-\"\n    \"Kp68fMQ3sro7mNIs-NtWQsjPEyk1cHu1wH0_pUjcVjex8SQb6vRxAEsF4sZq17cCRI-\"\n    \"6miwxYNzYyVCv-csNsxgTH8_kZbfXgk9WbJKE4k7XhIsU4K_cLmz8OysRw9IpsWQpmhHGHMXu-\"\n    \"-QBSDC3_5Lp5RU5oaEjHRd9AvXVsz1K1iaQ\";\n\n// kTokenBadAud is the same as kToken except that \"aud\" is \"some-audience\".\nconst char kTokenBadAud[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImIzMzE5YTE0NzUxNGRmN2VlNWU0Ym\"\n    \"NkZWU1MTM1MGNjODkwY2M4OWUifQ.\"\n    \"eyJpc3MiOiJodHRwczovL2lzc3VlcjEuY29tIiwic3ViIjoiZW5kLXVzZXItaWQiLCJhdWQiOi\"\n    \"Jzb21lLWF1ZGllbmNlIiwiaWF0IjoxNDYxNzc5MzIxLCJleHAiOjI0NjE3ODI5MjF9.\"\n    \"KFNI2R5r9IdjvAWFEvrM6q7dHNkrbLfPZNK7u8XQmn4vbMChHVW0gYYbO-\"\n    \"eaLPl0xnGX9q40xiMkM3blZ4oRPTj5YF_GcG9S-2fTPXdbmOtbHbpfMG1W26n2ESH2UKpEAL-\"\n    \"wRWbC7ea2dsdHE2zEbQfbLAwRjX3m3JiJlLHFJkQcrxsj8PwEScNBRJLRrIA1c4EPwQRsiNR7w\"\n    \"VooZYt_8v2ClgdKx8I-iDa4zhOheIVgvOduKARW5p2yyptM__9Pr544ox-R1IO2YYh-\"\n    \"70mLN05YowDM268OOjkdR1wC5vtsXGns5ZmT-h1vdQXluMuz-S2ppR3EqTUip4rBMOSAEQ\";\n\n// kTokenHttpsAud is the same as kToken except that \"aud\" is\n// \"https://endpoints-test.cloudendpointsapis.com\".\nconst char kTokenHttpsAud[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImIzMzE5YTE0NzUxNGRmN2VlNWU0Ym\"\n    \"NkZWU1MTM1MGNjODkwY2M4OWUifQ.\"\n    \"eyJpc3MiOiJodHRwczovL2lzc3VlcjEuY29tIiwic3ViIjoiZW5kLXVzZXItaWQiLCJhdWQiOi\"\n    \"JodHRwczovL2VuZHBvaW50cy10ZXN0LmNsb3VkZW5kcG9pbnRzYXBpcy5jb20iLCJpYXQiOjE0\"\n    \"NjE3NzkzMjEsImV4cCI6MjQ2MTc4MjkyMX0.\"\n    \"YVL4imxp7jS0RdvQhz7zflaqQzX7Q7TxVGZF9iHy9cxZKnB0wxGgXSb7jl_\"\n    \"KZ2tVCXvQLvErQAxrADDHUOLpXGbgdImF1UJz0YPQGffiyYPvXch2207czH9erKRNdMSxDCHrc\"\n    \"976Rvb9VTO9JFCTTbRwcGgBWz4H-gO55oCbErJCchyXdjLiMPiww-otw8n4tKqcNZhp_\"\n    \"xNDxkRExbk0oQH04epoIvmgmh6snAF06bi652Ag6Z4E842017DIZdaoy3VySbBsDMpZU2YLMil\"\n    \"fLJYUe5b64D6YvAfVAGgB01s7UJJb1b9KXoash5_nvM6xG0syr9URGF-kbqbWVccclA\";\n\n// kTokenHttpsSlashAud is the same as kToken except that \"aud\" is\n// \"\"https://endpoints-test.cloudendpointsapis.com/\".\nconst char kTokenHttpsSlashAud[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImIzMzE5YTE0NzUxNGRmN2VlNWU0Ym\"\n    \"NkZWU1MTM1MGNjODkwY2M4OWUifQ.\"\n    \"eyJpc3MiOiJodHRwczovL2lzc3VlcjEuY29tIiwic3ViIjoiZW5kLXVzZXItaWQiLCJhdWQiOi\"\n    \"JodHRwczovL2VuZHBvaW50cy10ZXN0LmNsb3VkZW5kcG9pbnRzYXBpcy5jb20vIiwiaWF0Ijox\"\n    \"NDYxNzc5MzIxLCJleHAiOjI0NjE3ODI5MjF9.OPN_7kPW2XR2qDNOB-\"\n    \"RNL1YLBTqJagbK7O2aieEr8VRWpUDR-BcY4LgbrVTY9kRvV1pb_T_\"\n    \"lCxX6tLIkKqC4QOZ1NuOVFhL1yAAjCI8oZB30m43JE8I0m6aEqjzelYcMBJFKp2Wfk16Hj-\"\n    \"Ain797f0u1F1tYJiat67bCfaPFJwWBsHHvyPbJ7NnxFvRYN6F1b8ddT9qAbELxj4fsj1F9rE0O\"\n    \"dmcp0lLhUa2OYrpyyipD5hv0eZIj4Yxlt962Qb6ZhewJULKULueIsWFXq3QZ-FPHXO8-B-\"\n    \"ZBDv5_INzDpTaUK0htgVMMvcbqCcr2DdAlloaZXUnnEINy-d57SBsw1w\";\n\n// kTokenHttpAud is the same as kToken except that \"aud\" is\n// \"http://endpoints-test.cloudendpointsapis.com\".\nconst char kTokenHttpAud[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImIzMzE5YTE0NzUxNGRmN2VlNWU0Ym\"\n    \"NkZWU1MTM1MGNjODkwY2M4OWUifQ.\"\n    \"eyJpc3MiOiJodHRwczovL2lzc3VlcjEuY29tIiwic3ViIjoiZW5kLXVzZXItaWQiLCJhdWQiOi\"\n    \"JodHRwczovL2VuZHBvaW50cy10ZXN0LmNsb3VkZW5kcG9pbnRzYXBpcy5jb20iLCJpYXQiOjE0\"\n    \"NjE3NzkzMjEsImV4cCI6MjQ2MTc4MjkyMX0.\"\n    \"YVL4imxp7jS0RdvQhz7zflaqQzX7Q7TxVGZF9iHy9cxZKnB0wxGgXSb7jl_\"\n    \"KZ2tVCXvQLvErQAxrADDHUOLpXGbgdImF1UJz0YPQGffiyYPvXch2207czH9erKRNdMSxDCHrc\"\n    \"976Rvb9VTO9JFCTTbRwcGgBWz4H-gO55oCbErJCchyXdjLiMPiww-otw8n4tKqcNZhp_\"\n    \"xNDxkRExbk0oQH04epoIvmgmh6snAF06bi652Ag6Z4E842017DIZdaoy3VySbBsDMpZU2YLMil\"\n    \"fLJYUe5b64D6YvAfVAGgB01s7UJJb1b9KXoash5_nvM6xG0syr9URGF-kbqbWVccclA\";\n\n// kTokenHttpSlashAud is the same as kToken except that \"aud\" is\n// \"\"http://endpoints-test.cloudendpointsapis.com/\".\nconst char kTokenHttpSlashAud[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImIzMzE5YTE0NzUxNGRmN2VlNWU0Ym\"\n    \"NkZWU1MTM1MGNjODkwY2M4OWUifQ.\"\n    \"eyJpc3MiOiJodHRwczovL2lzc3VlcjEuY29tIiwic3ViIjoiZW5kLXVzZXItaWQiLCJhdWQiOi\"\n    \"JodHRwczovL2VuZHBvaW50cy10ZXN0LmNsb3VkZW5kcG9pbnRzYXBpcy5jb20vIiwiaWF0Ijox\"\n    \"NDYxNzc5MzIxLCJleHAiOjI0NjE3ODI5MjF9.OPN_7kPW2XR2qDNOB-\"\n    \"RNL1YLBTqJagbK7O2aieEr8VRWpUDR-BcY4LgbrVTY9kRvV1pb_T_\"\n    \"lCxX6tLIkKqC4QOZ1NuOVFhL1yAAjCI8oZB30m43JE8I0m6aEqjzelYcMBJFKp2Wfk16Hj-\"\n    \"Ain797f0u1F1tYJiat67bCfaPFJwWBsHHvyPbJ7NnxFvRYN6F1b8ddT9qAbELxj4fsj1F9rE0O\"\n    \"dmcp0lLhUa2OYrpyyipD5hv0eZIj4Yxlt962Qb6ZhewJULKULueIsWFXq3QZ-FPHXO8-B-\"\n    \"ZBDv5_INzDpTaUK0htgVMMvcbqCcr2DdAlloaZXUnnEINy-d57SBsw1w\";\n\n// kTokenWithNbf is the same as kToken but has an additional \"nbf\" claim set to\n// 2461782921.\nconst char kTokenWithNbf[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImIzMzE5YTE0NzUxNGRmN2VlNWU0Ym\"\n    \"NkZWU1MTM1MGNjODkwY2M4OWUifQ.eyJpc3MiOiJodHRwczovL2lzc3VlcjEuY29tIiwic3ViI\"\n    \"joiZW5kLXVzZXItaWQiLCJhdWQiOiJlbmRwb2ludHMtdGVzdHMuY2xvdWRlbmRwb2ludHNhcGl\"\n    \"zLmNvbSIsImlhdCI6MTQ2MTc3OTMyMSwiZXhwIjoyNDYxNzgyOTIxLCJuYmYiOjI0NjE3ODI5M\"\n    \"jF9.eG8k_YeXPrmzkpu88PvvL_sP2FiG_VVsqG6zMxYleBKytGS1cUELVQzzlYNWeUh_w3q6EV\"\n    \"r_VeyrhbeUtQEsiDbeqWrz8fSaeUvgg0q1ndMo30YZxGx7gnFq5PKsDyyd_gi20J0P40y5ig5K\"\n    \"g4hXKlxpdJkUxwljmzkVvvy5N69EGvfIap474hHGKa1rpMZC2hfxAP0damJBShyGkr9qCnmBKn\"\n    \"5X-tA-XrqQjByzcdwu8D9jZSAdXsue285glUwPCpAYlRbrtrlhxHPS2pR2malTcR1PNXYEQD2G\"\n    \"x7n57Rg31-DuEoZAqWT5Tsr-cY8rn0cALm0AkFPyyC4OwI0O7w\";\n\nconst char kOpenIdContent[] = \"{\\\"jwks_uri\\\": \\\"https://issuer1.com/pubkey\\\"}\";\n\nconst char kPubkey[] =\n    \"{\\\"keys\\\": [{\\\"kty\\\": \\\"RSA\\\",\\\"alg\\\": \\\"RS256\\\",\\\"use\\\": \"\n    \"\\\"sig\\\",\\\"kid\\\": \\\"62a93512c9ee4c7f8067b5a216dade2763d32a47\\\",\\\"n\\\": \"\n    \"\\\"0YWnm_eplO9BFtXszMRQNL5UtZ8HJdTH2jK7vjs4XdLkPW7YBkkm_\"\n    \"2xNgcaVpkW0VT2l4mU3KftR-6s3Oa5Rnz5BrWEUkCTVVolR7VYksfqIB2I_\"\n    \"x5yZHdOiomMTcm3DheUUCgbJRv5OKRnNqszA4xHn3tA3Ry8VO3X7BgKZYAUh9fyZTFLlkeAh0-\"\n    \"bLK5zvqCmKW5QgDIXSxUTJxPjZCgfx1vmAfGqaJb-\"\n    \"nvmrORXQ6L284c73DUL7mnt6wj3H6tVqPKA27j56N0TB1Hfx4ja6Slr8S4EB3F1luYhATa1PKU\"\n    \"SH8mYDW11HolzZmTQpRoLV8ZoHbHEaTfqX_aYahIw\\\",\\\"e\\\": \\\"AQAB\\\"},{\\\"kty\\\": \"\n    \"\\\"RSA\\\",\\\"alg\\\": \\\"RS256\\\",\\\"use\\\": \\\"sig\\\",\\\"kid\\\": \"\n    \"\\\"b3319a147514df7ee5e4bcdee51350cc890cc89e\\\",\\\"n\\\": \"\n    \"\\\"qDi7Tx4DhNvPQsl1ofxxc2ePQFcs-L0mXYo6TGS64CY_\"\n    \"2WmOtvYlcLNZjhuddZVV2X88m0MfwaSA16wE-\"\n    \"RiKM9hqo5EY8BPXj57CMiYAyiHuQPp1yayjMgoE1P2jvp4eqF-\"\n    \"BTillGJt5W5RuXti9uqfMtCQdagB8EC3MNRuU_KdeLgBy3lS3oo4LOYd-\"\n    \"74kRBVZbk2wnmmb7IhP9OoLc1-7-9qU1uhpDxmE6JwBau0mDSwMnYDS4G_ML17dC-\"\n    \"ZDtLd1i24STUw39KH0pcSdfFbL2NtEZdNeam1DDdk0iUtJSPZliUHJBI_pj8M-2Mn_\"\n    \"oA8jBuI8YKwBqYkZCN1I95Q\\\",\\\"e\\\": \\\"AQAB\\\"}]}\";\n\nconst char kIssuer1OpenIdUrl[] =\n    \"https://issuer1.com/.well-known/openid-configuration\";\n\nconst char kIssuer1PubkeyUrl[] = \"https://issuer1.com/pubkey\";\nconst char kIssuer2PubkeyUrl[] = \"https://issuer2.com/pubkey\";\n\nconst char kOpenIdFailUrl[] =\n    \"http://openid_fail/.well-known/openid-configuration\";\n\n// The header key to send endpoint api user info.\nconst char kEndpointApiUserInfo[] = \"X-Endpoint-API-UserInfo\";\n\n// Base64 encoded string of\n// {\n//    \"issuer\": \"https://issuer1.com\",\n//    \"id\": \"end-user-id\"\n// }\nconst char kUserInfo_kSub_kIss[] =\n    \"eyJjbGFpbXMiOiJ7XCJpc3NcIjpcImh0dHBzOi8vaXNzdWVyMS5jb21cIixcInN1YlwiOlwiZW\"\n    \"5kLXVzZXItaWRcIixcImF1ZFwiOlwiZW5kcG9pbnRzLXRlc3QuY2xvdWRlbmRwb2ludHNhcGlz\"\n    \"LmNvbVwiLFwiaWF0XCI6MTQ2MTc3OTMyMSxcImV4cFwiOjI0NjE3ODI5MjF9IiwiaXNzdWVyIj\"\n    \"oiaHR0cHM6Ly9pc3N1ZXIxLmNvbSIsImlkIjoiZW5kLXVzZXItaWQiLCJhdWRpZW5jZXMiOlsi\"\n    \"ZW5kcG9pbnRzLXRlc3QuY2xvdWRlbmRwb2ludHNhcGlzLmNvbSJdfQ==\";\n\n// Base64 encoded string of\n// {\n//    \"issuer\": \"https://issuer1.com\",\n//    \"id\": \"another-user-id\"\n// }\nconst char kUserInfo_kSub2_kIss[] =\n    \"eyJjbGFpbXMiOiJ7XCJpc3NcIjpcImh0dHBzOi8vaXNzdWVyMS5jb21cIixcInN1YlwiOlwiZW\"\n    \"5kLXVzZXItaWRcIixcImF1ZFwiOlwiZW5kcG9pbnRzLXRlc3QuY2xvdWRlbmRwb2ludHNhcGlz\"\n    \"LmNvbVwiLFwiaWF0XCI6MTQ2MTc3OTMyMSxcImV4cFwiOjI0NjE3ODI5MjF9IiwiaXNzdWVyIj\"\n    \"oiaHR0cHM6Ly9pc3N1ZXIxLmNvbSIsImlkIjoiZW5kLXVzZXItaWQiLCJhdWRpZW5jZXMiOlsi\"\n    \"ZW5kcG9pbnRzLXRlc3QuY2xvdWRlbmRwb2ludHNhcGlzLmNvbSJdfQ==\";\n\nconst char kUserInfo_kSub2_kIss2[] =\n    \"eyJjbGFpbXMiOiJ7XCJpc3NcIjpcImh0dHBzOi8vaXNzdWVyMS5jb21cIixcInN1YlwiOlwiYW\"\n    \"5vdGhlci11c2VyLWlkXCIsXCJhdWRcIjpcImVuZHBvaW50cy10ZXN0LmNsb3VkZW5kcG9pbnRz\"\n    \"YXBpcy5jb21cIixcImlhdFwiOjE0NjE3NzkzMjEsXCJleHBcIjoyNDYxNzgyOTIxfSIsImlzc3\"\n    \"VlciI6Imh0dHBzOi8vaXNzdWVyMS5jb20iLCJpZCI6ImFub3RoZXItdXNlci1pZCIsImF1ZGll\"\n    \"bmNlcyI6WyJlbmRwb2ludHMtdGVzdC5jbG91ZGVuZHBvaW50c2FwaXMuY29tIl19\";\n\n// Base64 encoded string of\n// {\n//    \"issuer\": \"https://issuer2.com\",\n//    \"id\": \"end-user-id\"\n// }\nconst char kUserInfo_kSub_kIss2[] =\n    \"eyJjbGFpbXMiOiJ7XCJpc3NcIjpcImh0dHBzOi8vaXNzdWVyMi5jb21cIixcInN1YlwiOlwiZW\"\n    \"5kLXVzZXItaWRcIixcImF1ZFwiOlwiZW5kcG9pbnRzLXRlc3QuY2xvdWRlbmRwb2ludHNhcGlz\"\n    \"LmNvbVwiLFwiaWF0XCI6MTQ2MTc3OTMyMSxcImV4cFwiOjI0NjE3ODI5MjF9IiwiaXNzdWVyIj\"\n    \"oiaHR0cHM6Ly9pc3N1ZXIyLmNvbSIsImlkIjoiZW5kLXVzZXItaWQiLCJhdWRpZW5jZXMiOlsi\"\n    \"ZW5kcG9pbnRzLXRlc3QuY2xvdWRlbmRwb2ludHNhcGlzLmNvbSJdfQ==\";\n\nconst char kUserInfo_kSub2_kIss3[] =\n    \"eyJjbGFpbXMiOiJ7XCJpc3NcIjpcImh0dHBzOi8vaXNzdWVyMS5jb21cIixcInN1YlwiOlwiZW\"\n    \"5kLXVzZXItaWRcIixcImF1ZFwiOlwiaHR0cHM6Ly9lbmRwb2ludHMtdGVzdC5jbG91ZGVuZHBv\"\n    \"aW50c2FwaXMuY29tXCIsXCJpYXRcIjoxNDYxNzc5MzIxLFwiZXhwXCI6MjQ2MTc4MjkyMX0iLC\"\n    \"Jpc3N1ZXIiOiJodHRwczovL2lzc3VlcjEuY29tIiwiaWQiOiJlbmQtdXNlci1pZCIsImF1ZGll\"\n    \"bmNlcyI6WyJodHRwczovL2VuZHBvaW50cy10ZXN0LmNsb3VkZW5kcG9pbnRzYXBpcy5jb20iXX\"\n    \"0=\";\n\nconst char kUserInfo_kSub2_kIss4[] =\n    \"eyJjbGFpbXMiOiJ7XCJpc3NcIjpcImh0dHBzOi8vaXNzdWVyMS5jb21cIixcInN1YlwiOlwiZW\"\n    \"5kLXVzZXItaWRcIixcImF1ZFwiOlwiaHR0cHM6Ly9lbmRwb2ludHMtdGVzdC5jbG91ZGVuZHBv\"\n    \"aW50c2FwaXMuY29tL1wiLFwiaWF0XCI6MTQ2MTc3OTMyMSxcImV4cFwiOjI0NjE3ODI5MjF9Ii\"\n    \"wiaXNzdWVyIjoiaHR0cHM6Ly9pc3N1ZXIxLmNvbSIsImlkIjoiZW5kLXVzZXItaWQiLCJhdWRp\"\n    \"ZW5jZXMiOlsiaHR0cHM6Ly9lbmRwb2ludHMtdGVzdC5jbG91ZGVuZHBvaW50c2FwaXMuY29tLy\"\n    \"JdfQ==\";\n\nconst char kUserInfo_kSub2_kIss5[] =\n    \"eyJjbGFpbXMiOiJ7XCJpc3NcIjpcImh0dHBzOi8vaXNzdWVyMS5jb21cIixcInN1YlwiOlwiZW\"\n    \"5kLXVzZXItaWRcIixcImF1ZFwiOlwiaHR0cHM6Ly9lbmRwb2ludHMtdGVzdC5jbG91ZGVuZHBv\"\n    \"aW50c2FwaXMuY29tXCIsXCJpYXRcIjoxNDYxNzc5MzIxLFwiZXhwXCI6MjQ2MTc4MjkyMX0iLC\"\n    \"Jpc3N1ZXIiOiJodHRwczovL2lzc3VlcjEuY29tIiwiaWQiOiJlbmQtdXNlci1pZCIsImF1ZGll\"\n    \"bmNlcyI6WyJodHRwczovL2VuZHBvaW50cy10ZXN0LmNsb3VkZW5kcG9pbnRzYXBpcy5jb20iXX\"\n    \"0=\";\n\nconst char kUserInfo_kSub2_kIss6[] =\n    \"eyJjbGFpbXMiOiJ7XCJpc3NcIjpcImh0dHBzOi8vaXNzdWVyMS5jb21cIixcInN1YlwiOlwiZW\"\n    \"5kLXVzZXItaWRcIixcImF1ZFwiOlwiaHR0cHM6Ly9lbmRwb2ludHMtdGVzdC5jbG91ZGVuZHBv\"\n    \"aW50c2FwaXMuY29tL1wiLFwiaWF0XCI6MTQ2MTc3OTMyMSxcImV4cFwiOjI0NjE3ODI5MjF9Ii\"\n    \"wiaXNzdWVyIjoiaHR0cHM6Ly9pc3N1ZXIxLmNvbSIsImlkIjoiZW5kLXVzZXItaWQiLCJhdWRp\"\n    \"ZW5jZXMiOlsiaHR0cHM6Ly9lbmRwb2ludHMtdGVzdC5jbG91ZGVuZHBvaW50c2FwaXMuY29tLy\"\n    \"JdfQ==\";\n\nclass CheckAuthTest : public ::testing::Test {\n public:\n  void SetUp() {\n    std::unique_ptr<MockApiManagerEnvironment> env(\n        new ::testing::NiceMock<MockApiManagerEnvironment>());\n    // save the raw pointer of env before calling std::move(env).\n    raw_env_ = env.get();\n\n    std::unique_ptr<Config> config = Config::Create(raw_env_, kServiceConfig);\n    ASSERT_NE(config.get(), nullptr);\n\n    service_context_ = std::make_shared<context::ServiceContext>(\n        std::move(env), \"\", std::move(config));\n    ASSERT_NE(service_context_.get(), nullptr);\n\n    std::unique_ptr<MockRequest> request(\n        new ::testing::NiceMock<MockRequest>());\n    // save the raw pointer of request before calling std::move(request).\n    raw_request_ = request.get();\n\n    EXPECT_CALL(*raw_request_, GetRequestHTTPMethod())\n        .WillOnce(Return(std::string(\"GET\")));\n    EXPECT_CALL(*raw_request_, GetUnparsedRequestPath())\n        .WillOnce(Return(std::string(\"/ListShelves\")));\n    EXPECT_CALL(*raw_request_, FindQuery(_, _))\n        .WillOnce(Invoke([](const std::string &, std::string *apikey) {\n          *apikey = \"apikey\";\n          return true;\n        }));\n    EXPECT_CALL(*raw_request_, FindHeader(\"X-HTTP-Method-Override\", _))\n        .Times(1);\n    EXPECT_CALL(*raw_request_, FindHeader(\"referer\", _))\n        .WillOnce(Invoke([](const std::string &, std::string *http_referer) {\n          *http_referer = \"\";\n          return true;\n        }));\n    EXPECT_CALL(*raw_request_, FindHeader(\"grpc-trace-bin\", _))\n        .WillOnce(Invoke([](const std::string &, std::string *trace_context) {\n          *trace_context = \"\";\n          return false;\n        }));\n    EXPECT_CALL(*raw_request_, FindHeader(\"X-Cloud-Trace-Context\", _))\n        .WillOnce(Invoke([](const std::string &, std::string *trace_context) {\n          *trace_context = \"\";\n          return true;\n        }));\n\n    context_ = std::make_shared<context::RequestContext>(service_context_,\n                                                         std::move(request));\n    EXPECT_TRUE(Mock::VerifyAndClearExpectations(raw_request_));\n  }\n\n  void TestValidToken(const std::string &auth_token,\n                      const std::string &user_info);\n\n  MockApiManagerEnvironment *raw_env_;\n  std::shared_ptr<context::ServiceContext> service_context_;\n  MockRequest *raw_request_;\n  std::shared_ptr<context::RequestContext> context_;\n};\n\nvoid CheckAuthTest::TestValidToken(const std::string &auth_token,\n                                   const std::string &user_info) {\n  EXPECT_CALL(*raw_request_, FindHeader(\"x-goog-iap-jwt-assertion\", _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = \"\";\n        return false;\n      }));\n  EXPECT_CALL(*raw_request_, FindHeader(kAuthHeader, _))\n      .WillOnce(Invoke([auth_token](const std::string &, std::string *token) {\n        *token = std::string(kBearer) + auth_token;\n        return true;\n      }));\n  EXPECT_CALL(*raw_request_, SetAuthToken(auth_token)).Times(1);\n  EXPECT_CALL(*raw_env_, DoRunHTTPRequest(_))\n      .Times(2)\n      .WillOnce(Invoke([](HTTPRequest *req) {\n        EXPECT_EQ(req->url(), kIssuer1OpenIdUrl);\n        std::string body(kOpenIdContent);\n        std::map<std::string, std::string> empty;\n        req->OnComplete(Status::OK, std::move(empty), std::move(body));\n      }))\n      .WillOnce(Invoke([](HTTPRequest *req) {\n        EXPECT_EQ(req->url(), kIssuer1PubkeyUrl);\n        std::string body(kPubkey);\n        std::map<std::string, std::string> empty;\n        req->OnComplete(Status::OK, std::move(empty), std::move(body));\n      }));\n  std::cout << \"need be replaced: \" << user_info << std::endl;\n  EXPECT_CALL(*raw_request_,\n              AddHeaderToBackend(kEndpointApiUserInfo, user_info))\n      .WillOnce(Return(utils::Status::OK));\n\n  CheckAuth(context_, [](Status status) { ASSERT_TRUE(status.ok()); });\n}\n\n// Positive test.\n// Step 1: Check auth workflow that involves openID discovery and fetching\n//         public key.\n// Step 2. Use the same auth token, which should be cached in JWT cache.\n// Step 3. Use a different auth token signed by the same issuer. This time,\n//         token is not cached, but key is cached.\nTEST_F(CheckAuthTest, TestOKAuth) {\n  // Step 1. Check auth requires open ID discovery and fetching public key.\n  TestValidToken(kToken, kUserInfo_kSub2_kIss);\n\n  EXPECT_TRUE(Mock::VerifyAndClearExpectations(raw_request_));\n  EXPECT_TRUE(Mock::VerifyAndClearExpectations(raw_env_));\n\n  // Step 2. Check auth with the same auth token. This time the token is cached.\n  EXPECT_CALL(*raw_request_, FindHeader(\"x-goog-iap-jwt-assertion\", _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = \"\";\n        return false;\n      }));\n  EXPECT_CALL(*raw_request_, FindHeader(kAuthHeader, _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = std::string(kBearer) + std::string(kToken);\n        return true;\n      }));\n  EXPECT_CALL(*raw_request_, SetAuthToken(kToken)).Times(1);\n  EXPECT_CALL(*raw_env_, DoRunHTTPRequest(_)).Times(0);\n  EXPECT_CALL(*raw_request_,\n              AddHeaderToBackend(kEndpointApiUserInfo, kUserInfo_kSub_kIss))\n      .WillOnce(Return(utils::Status::OK));\n\n  CheckAuth(context_, [](Status status) { ASSERT_TRUE(status.ok()); });\n\n  EXPECT_TRUE(Mock::VerifyAndClearExpectations(raw_request_));\n  EXPECT_TRUE(Mock::VerifyAndClearExpectations(raw_env_));\n\n  // Step 3. Check auth with a different token signed by the same issuer.\n  // In this case, the token is not in the cache, but key is cached.\n  EXPECT_CALL(*raw_request_, FindHeader(\"x-goog-iap-jwt-assertion\", _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = \"\";\n        return false;\n      }));\n  EXPECT_CALL(*raw_request_, FindHeader(kAuthHeader, _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = std::string(kToken2);\n        return true;\n      }));\n  EXPECT_CALL(*raw_request_, SetAuthToken(kToken2)).Times(1);\n  EXPECT_CALL(*raw_env_, DoRunHTTPRequest(_)).Times(0);\n  EXPECT_CALL(*raw_request_,\n              AddHeaderToBackend(kEndpointApiUserInfo, kUserInfo_kSub2_kIss2))\n      .WillOnce(Return(utils::Status::OK));\n\n  CheckAuth(context_, [](Status status) { ASSERT_TRUE(status.ok()); });\n}\n\n// Negative test: Test the case that openID discovery failed.\n// Step 1. Try to fetch key URI via OpenID discovery but failed.\n// Step 2. Use a different token signed by the same issuer, no HTTP request\n//         is sent this time because the failure result was cached.\nTEST_F(CheckAuthTest, TestOpenIdFailed) {\n  // Step 1. Try to fetch key URI via OpenID discovery but failed.\n  // Use FindQuery to get auth token.\n  EXPECT_CALL(*raw_request_, FindHeader(\"x-goog-iap-jwt-assertion\", _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = \"\";\n        return false;\n      }));\n  EXPECT_CALL(*raw_request_, FindHeader(kAuthHeader, _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = std::string();\n        return false;\n      }));\n  EXPECT_CALL(*raw_request_, FindQuery(kAccessTokenName, _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = std::string(kTokenOpenIdFail);\n        return true;\n      }));\n  EXPECT_CALL(*raw_request_, SetAuthToken(kTokenOpenIdFail)).Times(1);\n  EXPECT_CALL(*raw_env_, DoRunHTTPRequest(_))\n      .WillOnce(Invoke([](HTTPRequest *req) {\n        EXPECT_EQ(req->url(), kOpenIdFailUrl);\n        std::string body(\"\");\n        std::map<std::string, std::string> empty;\n        req->OnComplete(Status::OK, std::move(empty), std::move(body));\n      }));\n\n  CheckAuth(context_, [](Status status) {\n    ASSERT_EQ(status.code(), Code::UNAUTHENTICATED);\n    ASSERT_EQ(status.message(),\n              \"JWT validation failed: Unable to parse \"\n              \"URI of the key via OpenID discovery\");\n  });\n\n  EXPECT_TRUE(Mock::VerifyAndClearExpectations(raw_request_));\n  EXPECT_TRUE(Mock::VerifyAndClearExpectations(raw_env_));\n\n  // Step 2. Use a different token signed by the same issuer, no HTTP request\n  //         is sent this time because the failure result was cached.\n  EXPECT_CALL(*raw_request_, FindHeader(\"x-goog-iap-jwt-assertion\", _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = \"\";\n        return false;\n      }));\n  EXPECT_CALL(*raw_request_, FindHeader(kAuthHeader, _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = std::string(kBearer) + std::string(kTokenOpenIdFail2);\n        return true;\n      }));\n  EXPECT_CALL(*raw_request_, SetAuthToken(kTokenOpenIdFail2)).Times(1);\n  EXPECT_CALL(*raw_env_, DoRunHTTPRequest(_)).Times(0);\n\n  CheckAuth(context_, [](Status status) {\n    ASSERT_EQ(status.code(), Code::UNAUTHENTICATED);\n    ASSERT_EQ(status.message(),\n              \"JWT validation failed: \"\n              \"Cannot determine the URI of the key\");\n  });\n}\n\n// jwks_uri is already specified in service config. Hence, no need to\n// do openID discovery.\nTEST_F(CheckAuthTest, TestNoOpenId) {\n  EXPECT_CALL(*raw_request_, FindHeader(\"x-goog-iap-jwt-assertion\", _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = \"\";\n        return false;\n      }));\n  EXPECT_CALL(*raw_request_, FindHeader(kAuthHeader, _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = std::string(kBearer) + std::string(kTokenIssuer2);\n        return true;\n      }));\n  EXPECT_CALL(*raw_request_, SetAuthToken(kTokenIssuer2)).Times(1);\n  EXPECT_CALL(*raw_env_, DoRunHTTPRequest(_))\n      .WillOnce(Invoke([](HTTPRequest *req) {\n        EXPECT_EQ(req->url(), kIssuer2PubkeyUrl);\n        std::string body(kPubkey);\n        std::map<std::string, std::string> empty;\n        req->OnComplete(Status::OK, std::move(empty), std::move(body));\n      }));\n  EXPECT_CALL(*raw_request_,\n              AddHeaderToBackend(kEndpointApiUserInfo, kUserInfo_kSub_kIss2))\n      .WillOnce(Return(utils::Status::OK));\n\n  CheckAuth(context_, [](Status status) { ASSERT_TRUE(status.ok()); });\n}\n\n// Negative test: invalid token and expired token.\nTEST_F(CheckAuthTest, TestInvalidToken) {\n  EXPECT_CALL(*raw_request_, FindHeader(\"x-goog-iap-jwt-assertion\", _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = \"\";\n        return false;\n      }));\n  // Invalid token.\n  EXPECT_CALL(*raw_request_, FindHeader(kAuthHeader, _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = \"bad_token\";\n        return true;\n      }));\n\n  CheckAuth(context_, [](Status status) {\n    ASSERT_EQ(status.code(), Code::UNAUTHENTICATED);\n    ASSERT_EQ(status.message(),\n              \"JWT validation failed: \"\n              \"Bad JWT format: should have 2 dots\");\n  });\n\n  EXPECT_TRUE(Mock::VerifyAndClearExpectations(raw_request_));\n\n  EXPECT_CALL(*raw_request_, FindHeader(\"x-goog-iap-jwt-assertion\", _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = \"\";\n        return false;\n      }));\n  // Expired token.\n  EXPECT_CALL(*raw_request_, FindHeader(kAuthHeader, _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = std::string(kBearer) + std::string(kTokenExpired);\n        return true;\n      }));\n  EXPECT_CALL(*raw_request_, SetAuthToken(kTokenExpired)).Times(1);\n  EXPECT_CALL(*raw_env_, DoRunHTTPRequest(_)).Times(0);\n\n  CheckAuth(context_, [](Status status) {\n    ASSERT_EQ(status.code(), Code::UNAUTHENTICATED);\n    ASSERT_EQ(status.message(),\n              \"JWT validation failed: TIME_CONSTRAINT_FAILURE\");\n  });\n\n  EXPECT_TRUE(Mock::VerifyAndClearExpectations(raw_request_));\n  EXPECT_TRUE(Mock::VerifyAndClearExpectations(raw_env_));\n\n  EXPECT_CALL(*raw_request_, FindHeader(\"x-goog-iap-jwt-assertion\", _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = \"\";\n        return false;\n      }));\n  // Token that is not ready to be used (i.e., current time is less than the\n  // \"nbf\" claim).\n  EXPECT_CALL(*raw_request_, FindHeader(kAuthHeader, _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = std::string(kBearer) + std::string(kTokenWithNbf);\n        return true;\n      }));\n  EXPECT_CALL(*raw_request_, SetAuthToken(kTokenWithNbf)).Times(1);\n  EXPECT_CALL(*raw_env_, DoRunHTTPRequest(_)).Times(0);\n\n  CheckAuth(context_, [](Status status) {\n    ASSERT_EQ(status.code(), Code::UNAUTHENTICATED);\n    ASSERT_EQ(status.message(),\n              \"JWT validation failed: TIME_CONSTRAINT_FAILURE\");\n  });\n}\n\n// Negative test: bad audience\nTEST_F(CheckAuthTest, TestBadAudience) {\n  EXPECT_CALL(*raw_request_, FindHeader(\"x-goog-iap-jwt-assertion\", _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = \"\";\n        return false;\n      }));\n  EXPECT_CALL(*raw_request_, FindHeader(kAuthHeader, _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = std::string(kBearer) + std::string(kTokenBadAud);\n        return true;\n      }));\n  EXPECT_CALL(*raw_request_, SetAuthToken(kTokenBadAud)).Times(1);\n  EXPECT_CALL(*raw_env_, DoRunHTTPRequest(_)).Times(0);\n\n  CheckAuth(context_, [](Status status) {\n    ASSERT_EQ(status.code(), Code::PERMISSION_DENIED);\n    ASSERT_EQ(status.message(), \"JWT validation failed: Audience not allowed\");\n  });\n}\n\n// Positive test: audience is service name with https prefix.\nTEST_F(CheckAuthTest, TestHttpsAudience) {\n  TestValidToken(kTokenHttpsAud, kUserInfo_kSub2_kIss3);\n}\n\n// Positive test: audience is service name with https prefix and a trailing\n// slash.\nTEST_F(CheckAuthTest, TestHttpsSlashAudience) {\n  TestValidToken(kTokenHttpsSlashAud, kUserInfo_kSub2_kIss4);\n}\n\n// Positive test: audience is service name with http prefix.\nTEST_F(CheckAuthTest, TestHttpAudience) {\n  TestValidToken(kTokenHttpAud, kUserInfo_kSub2_kIss5);\n}\n\n// Positive test: audience is service name with http prefix and a trailing\n// slash.\nTEST_F(CheckAuthTest, TestHttpSlashAudience) {\n  TestValidToken(kTokenHttpSlashAud, kUserInfo_kSub2_kIss6);\n}\n\n}  // namespace\n\n}  // namespace api_manager\n}  // namespace google\n", "// Copyright (C) Extensible Service Proxy Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////////\n// includes should be ordered. This seems like a bug in clang-format?\n#include \"src/api_manager/check_service_control.h\"\n#include \"google/protobuf/stubs/status.h\"\n#include \"src/api_manager/cloud_trace/cloud_trace.h\"\n\nusing ::google::api_manager::utils::Status;\nusing ::google::protobuf::util::error::Code;\n\nnamespace google {\nnamespace api_manager {\n\nnamespace {\n\nconst std::string kConsumerProjecId = \"X-Endpoint-API-Project-ID\";\n}\n\nvoid CheckServiceControl(std::shared_ptr<context::RequestContext> context,\n                         std::function<void(Status status)> continuation) {\n  std::shared_ptr<cloud_trace::CloudTraceSpan> trace_span(\n      CreateSpan(context->cloud_trace(), \"CheckServiceControl\"));\n  // If the method is not configured from the service config.\n  // or if not need to check service control, skip it.\n  if (!context->method()) {\n    if (context->GetRequestHTTPMethodWithOverride() == \"OPTIONS\") {\n      TRACE(trace_span) << \"OPTIONS request is rejected\";\n      continuation(Status(Code::PERMISSION_DENIED,\n                          \"The service does not allow CORS traffic.\",\n                          Status::SERVICE_CONTROL));\n    } else {\n      TRACE(trace_span) << \"Method is not configured in the service config\";\n      continuation(Status(Code::NOT_FOUND, \"Method does not exist.\",\n                          Status::SERVICE_CONTROL));\n    }\n    return;\n  } else if (!context->service_context()->service_control() ||\n             context->method()->skip_service_control()) {\n    TRACE(trace_span) << \"Service control check is not needed\";\n    continuation(Status::OK);\n    return;\n  }\n\n  if (context->api_key().empty()) {\n    if (context->method()->allow_unregistered_calls()) {\n      // Not need to call Check.\n      TRACE(trace_span) << \"Service control check is not needed\";\n      continuation(Status::OK);\n      return;\n    }\n\n    TRACE(trace_span) << \"Failed at checking caller identity.\";\n    continuation(\n        Status(Code::UNAUTHENTICATED,\n               \"Method doesn't allow unregistered callers (callers without \"\n               \"established identity). Please use API Key or other form of \"\n               \"API consumer identity to call this API.\",\n               Status::SERVICE_CONTROL));\n    return;\n  }\n\n  service_control::CheckRequestInfo info;\n  context->FillCheckRequestInfo(&info);\n  context->service_context()->service_control()->Check(\n      info, trace_span.get(),\n      [context, continuation, trace_span](\n          Status status, const service_control::CheckResponseInfo &info) {\n        TRACE(trace_span) << \"Check service control request returned with \"\n                          << \"status \" << status.ToString();\n        // info is valid regardless status.\n        context->set_check_response_info(info);\n\n        // update consumer_project_id to service context\n        if (!info.consumer_project_id.empty()) {\n          context->request()->AddHeaderToBackend(kConsumerProjecId,\n                                                 info.consumer_project_id);\n        }\n\n        continuation(status);\n      });\n}\n\n}  // namespace api_manager\n}  // namespace google\n", "// Copyright (C) Extensible Service Proxy Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n#include <iostream>\n#include <map>\n#include <memory>\n#include <string>\n\n#include \"gmock/gmock.h\"\n#include \"gtest/gtest.h\"\n\n#include \"src/api_manager/context/request_context.h\"\n#include \"src/api_manager/context/service_context.h\"\n#include \"src/api_manager/mock_api_manager_environment.h\"\n//#include \"src/api_manager/mock_request.h\"\n//#include \"src/api_manager/api_manager_impl.h\"\n#include \"include/api_manager/request.h\"\n\nusing ::testing::_;\nusing ::testing::Invoke;\nusing ::testing::Mock;\nusing ::testing::Return;\n\nusing ::google::api_manager::utils::Status;\n\nnamespace google {\nnamespace api_manager {\nnamespace context {\n\nnamespace {\n\nconst char kServiceConfig1[] =\n    R\"(\n{\n  \"name\": \"bookstore.test.appspot.com\",\n  \"title\": \"Bookstore\",\n  \"http\": {\n    \"rules\": [\n      {\n        \"selector\": \"EchoGetMessage\",\n        \"get\": \"/echo\"\n      }\n    ]\n  },\n  \"usage\": {\n    \"rules\": [\n      {\n        \"selector\": \"EchoGetMessage\",\n        \"allowUnregisteredCalls\": true\n      }\n    ]\n  },\n  \"control\": {\n    \"environment\": \"servicecontrol.googleapis.com\"\n  },\n  \"id\": \"2017-05-01r0\"\n}\n)\";\n\nclass MockApiManagerEnvironment : public ApiManagerEnvInterface {\n public:\n  virtual ~MockApiManagerEnvironment() {}\n\n  void Log(LogLevel level, const char *message) override {\n    // std::cout << __FILE__ << \":\" << __LINE__ << \" \" << message << std::endl;\n  }\n  std::unique_ptr<PeriodicTimer> StartPeriodicTimer(\n      std::chrono::milliseconds interval, std::function<void()> continuation) {\n    return std::unique_ptr<PeriodicTimer>(new MockPeriodicTimer(continuation));\n  }\n\n  void RunHTTPRequest(std::unique_ptr<HTTPRequest> request) override {}\n\n  virtual void RunGRPCRequest(std::unique_ptr<GRPCRequest> request) override {}\n};\n\nclass MockRequest : public Request {\n public:\n  MockRequest(const std::string &client_ip,\n              const std::map<std::string, std::string> &header)\n      : client_ip_(client_ip), header_(header) {}\n\n  virtual ~MockRequest() {}\n\n  bool FindHeader(const std::string &name, std::string *header) override {\n    auto it = header_.find(name);\n    if (it != header_.end()) {\n      header->assign(it->second);\n      return true;\n    }\n\n    return false;\n  }\n\n  std::string GetClientIP() { return client_ip_; }\n\n  std::string GetRequestHTTPMethod() override { return \"GET\"; }\n\n  std::string GetQueryParameters() override { return \"\"; }\n\n  std::string GetUnparsedRequestPath() override { return \"/echo\"; }\n\n  bool FindQuery(const std::string &name, std::string *query) override {\n    return false;\n  }\n\n  MOCK_METHOD2(AddHeaderToBackend,\n               utils::Status(const std::string &, const std::string &));\n  MOCK_METHOD1(SetAuthToken, void(const std::string &));\n  MOCK_METHOD0(GetFrontendProtocol,\n               ::google::api_manager::protocol::Protocol());\n  MOCK_METHOD0(GetBackendProtocol, ::google::api_manager::protocol::Protocol());\n  MOCK_METHOD0(GetRequestPath, std::string());\n  MOCK_METHOD0(GetInsecureCallerID, std::string());\n  MOCK_METHOD0(GetRequestHeaders, std::multimap<std::string, std::string> *());\n  MOCK_METHOD0(GetGrpcRequestBytes, int64_t());\n  MOCK_METHOD0(GetGrpcResponseBytes, int64_t());\n  MOCK_METHOD0(GetGrpcRequestMessageCounts, int64_t());\n  MOCK_METHOD0(GetGrpcResponseMessageCounts, int64_t());\n\n private:\n  const std::string client_ip_;\n  const std::map<std::string, std::string> header_;\n};\n}  // namespace\n\nclass ClientIPExtractionTest : public ::testing::Test {\n protected:\n  ClientIPExtractionTest() : callback_run_count_(0) {}\n\n  void SetUp() {\n    callback_run_count_ = 0;\n    call_history_.clear();\n  }\n\n protected:\n  std::vector<std::string> call_history_;\n  int callback_run_count_;\n};\n\n// Extracts client IP address from the request based on the server configuration\nstd::string ExtractClientIP(std::string serverConfig, std::string remote_ip,\n                            std::map<std::string, std::string> headers) {\n  std::unique_ptr<ApiManagerEnvInterface> env(new MockApiManagerEnvironment());\n\n  std::shared_ptr<context::GlobalContext> global_context(\n      new context::GlobalContext(std::move(env), serverConfig));\n\n  std::unique_ptr<Config> config =\n      Config::Create(global_context->env(), std::string(kServiceConfig1));\n\n  std::shared_ptr<context::ServiceContext> service_context(\n      new context::ServiceContext(global_context, std::move(config)));\n\n  std::unique_ptr<MockRequest> request(new MockRequest(remote_ip, headers));\n\n  RequestContext context(service_context, std::move(request));\n\n  service_control::CheckRequestInfo info;\n\n  context.FillCheckRequestInfo(&info);\n\n  return info.client_ip;\n}\n\nTEST_F(ClientIPExtractionTest, ClientIPAddressNoOverrideTest) {\n  const char kServerConfigWithoutClientIPExperiment[] =\n      R\"(\n  {\n    \"experimental\": {\n      \"disable_log_status\": false\n    }\n  }\n  )\";\n\n  EXPECT_EQ(\"4.4.4.4\",\n            ExtractClientIP(kServerConfigWithoutClientIPExperiment, \"4.4.4.4\",\n                            {{\"X-Forwarded-For\", \"1.1.1.1, 2.2.2.2, 3.3.3.3\"},\n                             {\"apiKey\", \"test-api-key\"}}));\n}\n\nTEST_F(ClientIPExtractionTest, ClientIPAddressOverrideTest) {\n  const char kServerConfigWithClientIPExperimentSecondFromLast[] =\n      R\"(\n  {\n    \"client_ip_extraction_config\": {\n      \"client_ip_header\": \"X-Forwarded-For\",\n      \"client_ip_position\": -2\n    }\n  }\n  )\";\n\n  EXPECT_EQ(\"2.2.2.2\",\n            ExtractClientIP(kServerConfigWithClientIPExperimentSecondFromLast,\n                            \"4.4.4.4\",\n                            {{\"X-Forwarded-For\", \"1.1.1.1, 2.2.2.2, 3.3.3.3\"},\n                             {\"apiKey\", \"test-api-key\"}}));\n}\n\nTEST_F(ClientIPExtractionTest, ClientIPAddressOverrideLastTest) {\n  const char kServerConfigWithClientIPExperimentLast[] =\n      R\"(\n  {\n    \"client_ip_extraction_config\": {\n      \"client_ip_header\": \"X-Forwarded-For\",\n      \"client_ip_position\": -1\n    }\n  }\n  )\";\n\n  EXPECT_EQ(\"3.3.3.3\",\n            ExtractClientIP(kServerConfigWithClientIPExperimentLast, \"4.4.4.4\",\n                            {{\"X-Forwarded-For\", \"1.1.1.1, 2.2.2.2, 3.3.3.3\"},\n                             {\"apiKey\", \"test-api-key\"}}));\n}\n\nTEST_F(ClientIPExtractionTest, ClientIPAddressOverrideOutOfIndexTest) {\n  const char kServerConfigWithClientIPExperimentOutOfIndex[] =\n      R\"(\n  {\n    \"client_ip_extraction_config\": {\n      \"client_ip_header\": \"X-Forwarded-For\",\n      \"client_ip_position\": -5\n    }\n  }\n  )\";\n\n  EXPECT_EQ(\n      \"4.4.4.4\",\n      ExtractClientIP(kServerConfigWithClientIPExperimentOutOfIndex, \"4.4.4.4\",\n                      {{\"X-Forwarded-For\", \"1.1.1.1, 2.2.2.2, 3.3.3.3\"},\n                       {\"apiKey\", \"test-api-key\"}}));\n}\n\nTEST_F(ClientIPExtractionTest, ClientIPAddressOverrideFirstIndexTest) {\n  const char kServerConfigWithClientIPExperimentFirst[] =\n      R\"(\n  {\n    \"client_ip_extraction_config\": {\n      \"client_ip_header\": \"X-Forwarded-For\",\n      \"client_ip_position\": 0\n    }\n  }\n  )\";\n\n  EXPECT_EQ(\"1.1.1.1\",\n            ExtractClientIP(kServerConfigWithClientIPExperimentFirst, \"4.4.4.4\",\n                            {{\"X-Forwarded-For\", \"1.1.1.1, 2.2.2.2, 3.3.3.3\"},\n                             {\"apiKey\", \"test-api-key\"}}));\n}\n\nTEST_F(ClientIPExtractionTest, ClientIPAddressOverrideSecondIndexTest) {\n  const char kServerConfigWithClientIPExperimentSecond[] =\n      R\"(\n  {\n    \"client_ip_extraction_config\": {\n      \"client_ip_header\": \"X-Forwarded-For\",\n      \"client_ip_position\": 1\n    }\n  }\n  )\";\n\n  EXPECT_EQ(\"2.2.2.2\", ExtractClientIP(\n                           kServerConfigWithClientIPExperimentSecond, \"4.4.4.4\",\n                           {{\"X-Forwarded-For\", \"1.1.1.1, 2.2.2.2, 3.3.3.3\"},\n                            {\"apiKey\", \"test-api-key\"}}));\n}\n\n}  // namespace context\n}  // namespace api_manager\n}  // namespace google\n", "// Copyright (C) Extensible Service Proxy Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n\n#include \"src/api_manager/context/request_context.h\"\n#include \"google/api/backend.pb.h\"\n#include \"src/api_manager/auth/lib/json_util.h\"\n#include \"src/api_manager/utils/str_util.h\"\n\n#include <uuid/uuid.h>\n#include <numeric>\n#include <sstream>\n#include <vector>\n\nusing ::google::api_manager::auth::GetPrimitiveFieldValue;\nusing ::google::api_manager::cloud_trace::HeaderType;\nusing ::google::api_manager::utils::Status;\n\nnamespace google {\nnamespace api_manager {\nnamespace context {\n\nnamespace {\n\n// Cloud Trace Context Header\nconst char kCloudTraceContextHeader[] = \"X-Cloud-Trace-Context\";\n// gRPC Trace Context Header\nconst char kGRpcTraceContextHeader[] = \"grpc-trace-bin\";\n\n// Authorization Header\nconst char kAuthorizationHeader[] = \"Authorization\";\nconst char kXForwardedAuthorizationHeader[] = \"X-Forwarded-Authorization\";\n\nconst char kBearerPrefix[] = \"Bearer \";\n\n// HTTP Method Override Header\nconst char kHttpMethodOverrideHeader[] = \"X-HTTP-Method-Override\";\n\n// Log message prefix for a success method.\nconst char kMessage[] = \"Method: \";\n// Log message prefix for an ignored method.\nconst char kIgnoredMessage[] =\n    \"Endpoints management skipped for an unrecognized HTTP call: \";\n// Unknown HTTP verb.\nconst char kUnknownHttpVerb[] = \"<Unknown HTTP Verb>\";\n\n// Service control does not currently support logging with an empty\n// operation name so we use this value until fix is available.\nconst char kUnrecognizedOperation[] = \"<Unknown Operation Name>\";\n\n// Maximum 36 byte string for UUID\nconst int kMaxUUIDBufSize = 40;\n\n// Default api key names\nconst char kDefaultApiKeyQueryName1[] = \"key\";\nconst char kDefaultApiKeyQueryName2[] = \"api_key\";\nconst char kDefaultApiKeyHeaderName[] = \"x-api-key\";\n\n// Delimiter of the IP addresses in the XFF header\nconst char kClientIPHeaderDelimeter = ',';\n\n// Header for android package name, used for api key restriction check.\nconst char kXAndroidPackage[] = \"x-android-package\";\n\n// Header for android certificate fingerprint, used for api key restriction\n// check.\nconst char kXAndroidCert[] = \"x-android-cert\";\n\n// Header for IOS bundle identifier, used for api key restriction check.\nconst char kXIosBundleId[] = \"x-ios-bundle-identifier\";\n\n// Genereates a UUID string\nstd::string GenerateUUID() {\n  char uuid_buf[kMaxUUIDBufSize];\n  uuid_t uuid;\n  uuid_generate(uuid);\n  uuid_unparse(uuid, uuid_buf);\n  return uuid_buf;\n}\n\n}  // namespace\n\nusing context::ServiceContext;\n\nRequestContext::RequestContext(std::shared_ptr<ServiceContext> service_context,\n                               std::unique_ptr<Request> request)\n    : service_context_(service_context),\n      request_(std::move(request)),\n      is_first_report_(true),\n      last_request_bytes_(0),\n      last_response_bytes_(0),\n      api_key_from_query_(false) {\n  start_time_ = std::chrono::system_clock::now();\n  last_report_time_ = std::chrono::steady_clock::now();\n  operation_id_ = GenerateUUID();\n  const std::string &method = GetRequestHTTPMethodWithOverride();\n  const std::string &path = request_->GetUnparsedRequestPath();\n  std::string query_params = request_->GetQueryParameters();\n\n  // In addition to matching the method, service_context_->GetMethodCallInfo()\n  // will extract the variable bindings from the url. We need variable bindings\n  // only when we need to do transcoding. If this turns out to be a performance\n  // problem for non-transcoded calls, we have a couple of options:\n  // 1) Do not extract variable bindings here, and do the method matching again\n  //    with extracting variable bindings when transcoding is needed.\n  // 2) Store all the pieces needed for extracting variable bindings (such as\n  //    http template variables, url path parts) in MethodCallInfo and extract\n  //    variables lazily when needed.\n\n  method_call_ =\n      service_context_->GetMethodCallInfo(method, path, query_params);\n\n  if (method_call_.method_info &&\n      !method_call_.method_info->allow_unregistered_calls()) {\n    ExtractApiKey();\n  }\n  request_->FindHeader(\"referer\", &http_referer_);\n\n  // Enable trace if tracing is not force disabled and the triggering header is\n  // set.\n  if (service_context_->cloud_trace_aggregator()) {\n    std::string trace_context_header;\n    // Default to CLOUD_TRACE_CONTEXT to not change the default behavior.\n    HeaderType header_type = HeaderType::CLOUD_TRACE_CONTEXT;\n    if (request_->FindHeader(kGRpcTraceContextHeader, &trace_context_header)) {\n      // gRPC trace header found, the type of the header should be\n      // GRPC_TRACE_CONTEXT\n      header_type = HeaderType::GRPC_TRACE_CONTEXT;\n    } else {\n      request_->FindHeader(kCloudTraceContextHeader, &trace_context_header);\n    }\n\n    std::string method_name = kUnrecognizedOperation;\n    if (method_call_.method_info) {\n      method_name = method_call_.method_info->selector();\n    }\n    // qualify with the service name\n    method_name = service_context_->service_name() + \"/\" + method_name;\n    cloud_trace_.reset(cloud_trace::CreateCloudTrace(\n        trace_context_header, method_name, header_type,\n        &service_context_->cloud_trace_aggregator()->sampler()));\n  }\n}\n\nstd::string RequestContext::GetRequestHTTPMethodWithOverride() {\n  std::string method;\n\n  if (!request_->FindHeader(kHttpMethodOverrideHeader, &method)) {\n    method = request()->GetRequestHTTPMethod();\n  }\n\n  service_context()->env()->LogDebug(std::string(\"Request method SET TO: \") +\n                                     method);\n\n  return method;\n}\n\nvoid RequestContext::ExtractApiKey() {\n  bool api_key_defined = false;\n  auto url_queries = method()->api_key_url_query_parameters();\n  if (url_queries) {\n    api_key_defined = true;\n    for (const auto &url_query : *url_queries) {\n      if (request_->FindQuery(url_query, &api_key_)) {\n        api_key_from_query_ = true;\n        return;\n      }\n    }\n  }\n\n  auto headers = method()->api_key_http_headers();\n  if (headers) {\n    api_key_defined = true;\n    for (const auto &header : *headers) {\n      if (request_->FindHeader(header, &api_key_)) {\n        return;\n      }\n    }\n  }\n\n  if (!api_key_defined) {\n    // If api_key is not specified for a method,\n    // check \"key\" first, if not, check \"api_key\" in query parameter.\n    if (request_->FindQuery(kDefaultApiKeyQueryName1, &api_key_)) {\n      api_key_from_query_ = true;\n      return;\n    }\n\n    if (request_->FindQuery(kDefaultApiKeyQueryName2, &api_key_)) {\n      api_key_from_query_ = true;\n      return;\n    }\n    request_->FindHeader(kDefaultApiKeyHeaderName, &api_key_);\n  }\n}\n\nvoid RequestContext::SetApiKeyHeader() {\n  request_->AddHeaderToBackend(kDefaultApiKeyHeaderName, api_key_);\n}\n\nvoid RequestContext::CompleteCheck(Status status) {\n  // Makes sure set_check_continuation() is called.\n  // Only making sure CompleteCheck() is NOT called twice.\n  GOOGLE_CHECK(check_continuation_);\n\n  auto temp_continuation = check_continuation_;\n  check_continuation_ = nullptr;\n\n  temp_continuation(status);\n}\n\nvoid RequestContext::FillOperationInfo(service_control::OperationInfo *info) {\n  if (method()) {\n    info->operation_name = method()->selector();\n  } else {\n    info->operation_name = kUnrecognizedOperation;\n  }\n  info->operation_id = operation_id_;\n  if (check_response_info_.is_api_key_valid &&\n      check_response_info_.service_is_activated) {\n    info->api_key = api_key_;\n  }\n  info->producer_project_id = service_context()->project_id();\n  info->referer = http_referer_;\n  info->request_start_time = start_time_;\n  info->client_ip = FindClientIPAddress();\n  info->client_host = request_->GetClientHost();\n}\n\nvoid RequestContext::FillLocation(service_control::ReportRequestInfo *info) {\n  info->location = service_context()->global_context()->location();\n}\n\nvoid RequestContext::FillComputePlatform(\n    service_control::ReportRequestInfo *info) {\n  info->compute_platform = service_context()->global_context()->platform();\n}\n\nvoid RequestContext::FillLogMessage(service_control::ReportRequestInfo *info) {\n  if (method()) {\n    info->api_method = method()->selector();\n    info->api_name = method()->api_name();\n    info->api_version = method()->api_version();\n    info->log_message = std::string(kMessage) + method()->selector();\n    if (info->response_code >= 400) {\n      info->log_message += std::string(\" failed: \") + info->status.ToString();\n    }\n  } else {\n    std::string http_verb = info->method;\n    if (http_verb.empty()) {\n      http_verb = kUnknownHttpVerb;\n    }\n    info->log_message = std::string(kIgnoredMessage) + http_verb + \" \" +\n                        request_->GetUnparsedRequestPath();\n  }\n}\n\nvoid RequestContext::FillHttpHeaders(const Response *response,\n                                     service_control::ReportRequestInfo *info) {\n  auto serverConfig = service_context_->config()->server_config();\n  if (serverConfig->has_service_control_config()) {\n    const auto &request_headers =\n        serverConfig->service_control_config().log_request_header();\n    for (const auto &header : request_headers) {\n      std::string header_value;\n      if (request_->FindHeader(header, &header_value)) {\n        info->request_headers =\n            info->request_headers + header + \"=\" + header_value + \";\";\n      }\n    }\n\n    const auto &response_headers =\n        serverConfig->service_control_config().log_response_header();\n    for (const auto &header : response_headers) {\n      std::string header_value;\n      if (response->FindHeader(header, &header_value)) {\n        info->response_headers =\n            info->response_headers + header + \"=\" + header_value + \";\";\n      }\n    }\n  }\n}\n\nvoid RequestContext::FillJwtPayloads(service_control::ReportRequestInfo *info) {\n  auto serverConfig = service_context_->config()->server_config();\n  if (serverConfig->has_service_control_config() &&\n      serverConfig->service_control_config().log_jwt_payload().size() != 0) {\n    for (const auto &payload_path :\n         serverConfig->service_control_config().log_jwt_payload()) {\n      std::string payload_value;\n      if (GetPrimitiveFieldValue(auth_claims_, payload_path, &payload_value)) {\n        info->jwt_payloads =\n            info->jwt_payloads + payload_path + \"=\" + payload_value + \";\";\n      }\n    }\n  }\n}\n\nvoid RequestContext::FillCheckRequestInfo(\n    service_control::CheckRequestInfo *info) {\n  FillOperationInfo(info);\n\n  request_->FindHeader(kXAndroidPackage, &info->android_package_name);\n  request_->FindHeader(kXAndroidCert, &info->android_cert_fingerprint);\n  request_->FindHeader(kXIosBundleId, &info->ios_bundle_id);\n}\n\nvoid RequestContext::FillAllocateQuotaRequestInfo(\n    service_control::QuotaRequestInfo *info) {\n  FillOperationInfo(info);\n\n  info->method_name = this->method_call_.method_info->name();\n  info->metric_cost_vector =\n      &this->method_call_.method_info->metric_cost_vector();\n}\n\nvoid RequestContext::FillReportRequestInfo(\n    Response *response, service_control::ReportRequestInfo *info) {\n  FillOperationInfo(info);\n  FillLocation(info);\n  FillComputePlatform(info);\n\n  info->url = request_->GetUnparsedRequestPath();\n  info->method = GetRequestHTTPMethodWithOverride();\n\n  info->frontend_protocol = request_->GetFrontendProtocol();\n  info->backend_protocol = request_->GetBackendProtocol();\n  info->check_response_info = check_response_info_;\n\n  info->auth_issuer = auth_issuer_;\n  info->auth_audience = auth_audience_;\n\n  if (!info->is_final_report) {\n    // Make sure we send delta metrics for intermediate reports.\n    info->request_bytes = request_->GetGrpcRequestBytes() - last_request_bytes_;\n    info->response_bytes =\n        request_->GetGrpcResponseBytes() - last_response_bytes_;\n    last_request_bytes_ += info->request_bytes;\n    last_response_bytes_ += info->response_bytes;\n  } else {\n    info->request_size = response->GetRequestSize();\n    info->response_size = response->GetResponseSize();\n    info->request_bytes = info->request_size - last_request_bytes_;\n    if (info->request_bytes < 0) {\n      info->request_bytes = 0;\n    }\n    info->response_bytes = info->response_size - last_response_bytes_;\n    if (info->response_bytes < 0) {\n      info->response_bytes = 0;\n    }\n\n    info->streaming_request_message_counts =\n        request_->GetGrpcRequestMessageCounts();\n    info->streaming_response_message_counts =\n        request_->GetGrpcResponseMessageCounts();\n\n    info->streaming_durations =\n        std::chrono::duration_cast<std::chrono::microseconds>(\n            std::chrono::system_clock::now() - start_time_)\n            .count();\n\n    info->status = response->GetResponseStatus();\n    info->response_code = info->status.HttpCode();\n\n    // Must be after response_code and method are assigned.\n    FillLogMessage(info);\n\n    FillHttpHeaders(response, info);\n    FillJwtPayloads(info);\n    bool is_streaming = false;\n    if (method() &&\n        (method()->request_streaming() || method()->response_streaming())) {\n      is_streaming = true;\n    }\n    if (!is_streaming) {\n      response->GetLatencyInfo(&info->latency);\n    }\n  }\n}\n\nconst std::string RequestContext::FindClientIPAddress() {\n  auto serverConfig = service_context_->config()->server_config();\n  std::string client_ip_header;\n\n  if (serverConfig->has_client_ip_extraction_config() &&\n      serverConfig->client_ip_extraction_config().client_ip_header().length() >\n          0 &&\n      request_->FindHeader(\n          serverConfig->client_ip_extraction_config().client_ip_header(),\n          &client_ip_header)) {\n    // split headers\n    std::vector<std::string> secments;\n    utils::Split(client_ip_header, kClientIPHeaderDelimeter, &secments);\n    int client_ip_header_position =\n        serverConfig->client_ip_extraction_config().client_ip_position();\n\n    if (client_ip_header_position < 0) {\n      client_ip_header_position = secments.size() + client_ip_header_position;\n    }\n\n    if (client_ip_header_position >= 0 &&\n        client_ip_header_position < (int)secments.size()) {\n      return utils::Trim(secments[client_ip_header_position]);\n    }\n  }\n\n  return request_->GetClientIP();\n}\n\nvoid RequestContext::StartBackendSpanAndSetTraceContext() {\n  backend_span_.reset(CreateSpan(cloud_trace_.get(), \"Backend\"));\n\n  // TODO: A better logic would be to send for GRPC backends the grpc-trace-bin\n  // header, and for http/https backends the X-Cloud-Trace-Context header.\n\n  std::string trace_context_header = cloud_trace()->ToTraceContextHeader(\n      backend_span_->trace_span()->span_id());\n\n  // Set trace context header to backend.\n  Status status = request()->AddHeaderToBackend(\n      cloud_trace()->header_type() == HeaderType::CLOUD_TRACE_CONTEXT\n          ? kCloudTraceContextHeader\n          : kGRpcTraceContextHeader,\n      trace_context_header);\n  if (!status.ok()) {\n    service_context()->env()->LogError(\n        \"Failed to set trace context header to backend.\");\n  }\n}\n\nstd::string RequestContext::GetAuthorizationUrl() const {\n  if (method_call_.method_info == nullptr) {\n    return \"\";\n  }\n  // This feature has to be enabled from the flag\n  if (!service_context()->global_context()->redirect_authorization_url()) {\n    return \"\";\n  }\n  if (auth_issuer_.empty()) {\n    return method_call_.method_info->first_authorization_url();\n  } else {\n    return method_call_.method_info->authorization_url_by_issuer(auth_issuer_);\n  }\n}\n\nstd::string RequestContext::GetBackendPath() const {\n  if (method_call_.method_info == nullptr) {\n    return \"\";\n  }\n\n  if (method_call_.method_info->backend_path_translation() ==\n      ::google::api::BackendRule_PathTranslation_APPEND_PATH_TO_ADDRESS) {\n    if (!method_call_.method_info->backend_path().empty()) {\n      return method_call_.method_info->backend_path() +\n             request_->GetUnparsedRequestPath();\n    } else {\n      // Not change to the request path.\n      return \"\";\n    }\n  } else if (method_call_.method_info->backend_path_translation() ==\n             ::google::api::BackendRule_PathTranslation_CONSTANT_ADDRESS) {\n    std::string parameters;\n    for (std::size_t i = 0; i != method_call_.variable_bindings.size(); i++) {\n      auto &variable_binding = method_call_.variable_bindings[i];\n      for (std::size_t j = 0; j < variable_binding.field_path.size(); ++j) {\n        // If field_path is snake case, need to use corresponding jsonName.\n        std::string::size_type found = variable_binding.field_path[j].find(\"_\");\n        std::string field_path;\n        if (found != std::string::npos &&\n            service_context_->config()->GetJsonName(\n                variable_binding.field_path[j], &field_path)) {\n          parameters.append(field_path);\n        } else {\n          parameters.append(variable_binding.field_path[j]);\n        }\n\n        if (j != variable_binding.field_path.size() - 1) {\n          parameters.append(\".\");\n        }\n      }\n\n      parameters.append(\"=\");\n      parameters.append(variable_binding.value);\n      if (i != method_call_.variable_bindings.size() - 1) {\n        parameters.append(\"&\");\n      }\n    }\n\n    if (parameters != \"\") {\n      return method_call_.method_info->backend_path() + \"?\" + parameters;\n    }\n    return method_call_.method_info->backend_path();\n  } else {\n    return \"\";\n  }\n}\n\nbool RequestContext::ShouldOverrideBackend() const {\n  if (method_call_.method_info == nullptr) {\n    return false;\n  }\n\n  if (method_call_.method_info->backend_path_translation() ==\n      ::google::api::BackendRule_PathTranslation_PATH_TRANSLATION_UNSPECIFIED) {\n    return false;\n  }\n  return true;\n}\n\nvoid RequestContext::AddInstanceIdentityToken() {\n  if (!method()) {\n    return;\n  }\n\n  const auto &audience = method()->backend_jwt_audience();\n  if (!audience.empty()) {\n    auto &token = service_context()\n                      ->global_context()\n                      ->GetInstanceIdentityToken(audience)\n                      ->GetAuthToken();\n    if (!token.empty()) {\n      std::string origin_auth_header;\n      if (request()->FindHeader(kAuthorizationHeader, &origin_auth_header)) {\n        Status status = request()->AddHeaderToBackend(\n            kXForwardedAuthorizationHeader, origin_auth_header);\n        if (!status.ok()) {\n          service_context()->env()->LogError(\n              \"Failed to set X-Forwarded-Authorization header to backend.\");\n        }\n      }\n      Status status = request()->AddHeaderToBackend(kAuthorizationHeader,\n                                                    kBearerPrefix + token);\n      if (!status.ok()) {\n        service_context()->env()->LogError(\n            \"Failed to set authorization header to backend.\");\n      }\n    }\n  }\n}\n\n}  // namespace context\n}  // namespace api_manager\n}  // namespace google\n", "/* Copyright (C) Extensible Service Proxy Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef API_MANAGER_MOCK_REQUEST_H_\n#define API_MANAGER_MOCK_REQUEST_H_\n\n#include \"gmock/gmock.h\"\n#include \"include/api_manager/request.h\"\n\nnamespace google {\nnamespace api_manager {\n\nclass MockRequest : public Request {\n public:\n  MOCK_METHOD2(FindQuery, bool(const std::string &, std::string *));\n  MOCK_METHOD2(FindHeader, bool(const std::string &, std::string *));\n  MOCK_METHOD2(AddHeaderToBackend,\n               utils::Status(const std::string &, const std::string &));\n  MOCK_METHOD1(SetAuthToken, void(const std::string &));\n  MOCK_METHOD0(GetRequestHTTPMethod, std::string());\n  MOCK_METHOD0(GetQueryParameters, std::string());\n  MOCK_METHOD0(GetFrontendProtocol,\n               ::google::api_manager::protocol::Protocol());\n  MOCK_METHOD0(GetBackendProtocol, ::google::api_manager::protocol::Protocol());\n  MOCK_METHOD0(GetRequestPath, std::string());\n  MOCK_METHOD0(GetUnparsedRequestPath, std::string());\n  MOCK_METHOD0(GetInsecureCallerID, std::string());\n  MOCK_METHOD0(GetClientIP, std::string());\n  MOCK_METHOD0(GetRequestHeaders, std::multimap<std::string, std::string> *());\n  MOCK_METHOD0(GetGrpcRequestBytes, int64_t());\n  MOCK_METHOD0(GetGrpcResponseBytes, int64_t());\n  MOCK_METHOD0(GetGrpcRequestMessageCounts, int64_t());\n  MOCK_METHOD0(GetGrpcResponseMessageCounts, int64_t());\n};\n\n}  // namespace api_manager\n}  // namespace google\n\n#endif  // API_MANAGER_MOCK_REQUEST_H_\n", "// Copyright (C) Extensible Service Proxy Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n#include \"src/api_manager/request_handler.h\"\n\n#include \"google/devtools/cloudtrace/v1/trace.pb.h\"\n#include \"google/protobuf/stubs/logging.h\"\n#include \"src/api_manager/auth/service_account_token.h\"\n#include \"src/api_manager/check_auth.h\"\n#include \"src/api_manager/check_workflow.h\"\n#include \"src/api_manager/cloud_trace/cloud_trace.h\"\n#include \"src/api_manager/utils/marshalling.h\"\n\nusing ::google::api_manager::utils::Status;\nusing google::devtools::cloudtrace::v1::Traces;\n\nnamespace google {\nnamespace api_manager {\n\nRequestHandler::RequestHandler(\n    std::shared_ptr<CheckWorkflow> check_workflow,\n    std::shared_ptr<context::ServiceContext> service_context,\n    std::unique_ptr<Request> request_data)\n    : context_(new context::RequestContext(service_context,\n                                           std::move(request_data))),\n      check_workflow_(check_workflow) {\n  // Remove x-endponts-api-userinfo from downstream client.\n  // It should be set by the last Endpoint proxy to prevent users spoofing.\n  std::string buffer;\n  if (context_->request()->FindHeader(\n          google::api_manager::auth::kEndpointApiUserInfo, &buffer)) {\n    context_->request()->AddHeaderToBackend(\n        google::api_manager::auth::kEndpointApiUserInfo, \"\");\n  }\n}\n\nvoid RequestHandler::Check(std::function<void(Status status)> continuation) {\n  auto interception = [continuation, this](Status status) {\n    if (status.ok()) {\n      if (context_->cloud_trace()) {\n        context_->StartBackendSpanAndSetTraceContext();\n      }\n      // Add InstanceIdentityToken to request header if needed, which is\n      // required for backend routing.\n      context_->AddInstanceIdentityToken();\n    }\n\n    continuation(status);\n  };\n\n  context_->set_check_continuation(interception);\n\n  // Run the check flow.\n  check_workflow_->Run(context_);\n}\n\nvoid RequestHandler::AttemptIntermediateReport() {\n  // For grpc streaming calls, we send intermediate reports to represent\n  // streaming stats. Specifically:\n  // 1) We send request_count in the first report to indicate the start of a\n  // stream.\n  // 2) We send request_bytes, response_bytes in intermediate reports, which\n  // triggered by timer.\n  // 3) In the final report, we send all metrics except request_count if it\n  // already sent.\n  // We only send intermediate streaming report if the time_interval >\n  // intermediate_report_interval().\n  if (std::chrono::duration_cast<std::chrono::seconds>(\n          std::chrono::steady_clock::now() - context_->last_report_time())\n          .count() <\n      context_->service_context()->intermediate_report_interval()) {\n    return;\n  }\n  service_control::ReportRequestInfo info;\n  info.is_first_report = context_->is_first_report();\n  info.is_final_report = false;\n  context_->FillReportRequestInfo(NULL, &info);\n\n  // Calling service_control Report.\n  Status status = context_->service_context()->service_control()->Report(info);\n  if (!status.ok()) {\n    context_->service_context()->env()->LogError(\n        \"Failed to send intermediate report to service control.\");\n  } else {\n    context_->set_first_report(false);\n  }\n  context_->set_last_report_time(std::chrono::steady_clock::now());\n}\n\n// Sends a report.\nvoid RequestHandler::Report(std::unique_ptr<Response> response,\n                            std::function<void(void)> continuation) {\n  if (context_->method() && context_->method()->skip_service_control()) {\n    continuation();\n    return;\n  }\n  // Close backend trace span.\n  context_->EndBackendSpan();\n\n  if (context_->service_context()->service_control()) {\n    service_control::ReportRequestInfo info;\n    info.is_first_report = context_->is_first_report();\n    info.is_final_report = true;\n    context_->FillReportRequestInfo(response.get(), &info);\n    // Calling service_control Report.\n    Status status =\n        context_->service_context()->service_control()->Report(info);\n    if (!status.ok()) {\n      context_->service_context()->env()->LogError(\n          \"Failed to send report to service control.\");\n    }\n  }\n\n  if (context_->cloud_trace()) {\n    context_->cloud_trace()->EndRootSpan();\n    // Always set the project_id to the latest one.\n    //\n    // this is how project_id is calculated: if gce metadata is fetched, use\n    // its project_id. Otherwise, use the project_id from service_config if it\n    // is configured.\n    // gce metadata fetching is started by the first request. While fetching is\n    // in progress, subsequent requests will fail.  These failed requests may\n    // have wrong project_id until gce metadata is fetched successfully.\n    context_->service_context()->cloud_trace_aggregator()->SetProjectId(\n        context_->service_context()->project_id());\n    context_->service_context()->cloud_trace_aggregator()->AppendTrace(\n        context_->cloud_trace()->ReleaseTrace());\n  }\n\n  continuation();\n}\n\nstd::string RequestHandler::GetServiceConfigId() const {\n  return context_->service_context()->service().id();\n}\n\nstd::string RequestHandler::GetBackendAddress() const {\n  if (context_->method()) {\n    return context_->method()->backend_address();\n  } else {\n    return std::string();\n  }\n}\n\nstd::string RequestHandler::GetRpcMethodFullName() const {\n  if (context_ && context_->method() &&\n      !context_->method()->rpc_method_full_name().empty()) {\n    return context_->method()->rpc_method_full_name();\n  } else {\n    return std::string();\n  }\n}\n\nvoid RequestHandler::TryAddApiKeyHeaderFromQuery() {\n  if (context_->api_key_from_query()) {\n    context_->SetApiKeyHeader();\n  }\n}\n\nstd::string RequestHandler::GetAuthorizationUrl() const {\n  return context_->GetAuthorizationUrl();\n}\n\n}  // namespace api_manager\n}  // namespace google\n", "// Copyright (C) Extensible Service Proxy Authors\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n// SUCH DAMAGE.\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n#include \"src/nginx/request.h\"\n\n#include \"src/api_manager/check_auth.h\"\n#include \"src/nginx/module.h\"\n#include \"src/nginx/util.h\"\n\nnamespace google {\nnamespace api_manager {\nnamespace nginx {\n\nNgxEspRequest::NgxEspRequest(ngx_http_request_t *r) : r_(r) {}\n\nNgxEspRequest::~NgxEspRequest() {\n  // TODO: Propagate any changes to the headers back to the request.\n}\n\nstd::string NgxEspRequest::GetRequestHTTPMethod() {\n  return ngx_str_to_std(r_->method_name);\n}\n\nstd::string NgxEspRequest::GetQueryParameters() {\n  return ngx_str_to_std(r_->args);\n}\n\nstd::string NgxEspRequest::GetRequestPath() {\n  std::string unparsed_str = ngx_str_to_std(r_->unparsed_uri);\n  return unparsed_str.substr(0, unparsed_str.find_first_of('?'));\n}\n\nstd::string NgxEspRequest::GetUnparsedRequestPath() {\n  return ngx_str_to_std(r_->unparsed_uri);\n}\n\n::google::api_manager::protocol::Protocol NgxEspRequest::GetFrontendProtocol() {\n  ngx_esp_request_ctx_t *ctx = ngx_http_esp_get_module_ctx(r_);\n  if (ctx->grpc_pass_through) {\n    return ::google::api_manager::protocol::GRPC;\n  }\n  if (r_ && r_->connection) {\n#if (NGX_SSL)\n    if (r_->connection->ssl) {\n      return ::google::api_manager::protocol::HTTPS;\n    }\n#endif\n    return ::google::api_manager::protocol::HTTP;\n  } else {\n    return ::google::api_manager::protocol::UNKNOWN;\n  }\n}\n\n::google::api_manager::protocol::Protocol NgxEspRequest::GetBackendProtocol() {\n  ngx_esp_request_ctx_t *ctx = ngx_http_esp_get_module_ctx(r_);\n  if (ctx->grpc_backend) {\n    return ::google::api_manager::protocol::GRPC;\n  } else {\n    // TODO: determine HTTP or HTTPS for backend.\n    return ::google::api_manager::protocol::UNKNOWN;\n  }\n}\n\nstd::string NgxEspRequest::GetClientIP() {\n  // use remote_addr variable to get client_ip.\n  ngx_esp_main_conf_t *mc = reinterpret_cast<ngx_esp_main_conf_t *>(\n      ngx_http_get_module_main_conf(r_, ngx_esp_module));\n  if (mc->remote_addr_variable_index != NGX_ERROR) {\n    ngx_http_variable_value_t *vv =\n        ngx_http_get_indexed_variable(r_, mc->remote_addr_variable_index);\n    if (vv != nullptr && !vv->not_found) {\n      return ngx_str_to_std(ngx_str_t({vv->len, vv->data}));\n    }\n  }\n  return \"\";\n}\n\nint64_t NgxEspRequest::GetGrpcRequestMessageCounts() {\n  ngx_esp_request_ctx_t *ctx = ngx_http_esp_get_module_ctx(r_);\n  return ctx->grpc_request_message_counts;\n}\n\nint64_t NgxEspRequest::GetGrpcResponseMessageCounts() {\n  ngx_esp_request_ctx_t *ctx = ngx_http_esp_get_module_ctx(r_);\n  return ctx->grpc_response_message_counts;\n}\n\nint64_t NgxEspRequest::GetGrpcRequestBytes() {\n  ngx_esp_request_ctx_t *ctx = ngx_http_esp_get_module_ctx(r_);\n  return ctx->grpc_request_bytes;\n}\n\nint64_t NgxEspRequest::GetGrpcResponseBytes() {\n  ngx_esp_request_ctx_t *ctx = ngx_http_esp_get_module_ctx(r_);\n  return ctx->grpc_response_bytes;\n}\n\nbool NgxEspRequest::FindQuery(const std::string &name, std::string *query) {\n  ngx_str_t out = ngx_null_string;\n  ngx_http_arg(r_, reinterpret_cast<u_char *>(const_cast<char *>(name.data())),\n               name.size(), &out);\n  if (out.len > 0) {\n    *query = ngx_str_to_std(out);\n    return true;\n  }\n  return false;\n}\n\nbool NgxEspRequest::FindHeader(const std::string &name, std::string *header) {\n  auto h = ngx_esp_find_headers_in(\n      r_, reinterpret_cast<u_char *>(const_cast<char *>(name.data())),\n      name.size());\n  if (h && h->value.len > 0) {\n    *header = ngx_str_to_std(h->value);\n    return true;\n  }\n  return false;\n}\n\nvoid NgxEspRequest::SetAuthToken(const std::string &auth_token) {\n  ngx_esp_request_ctx_t *ctx = ngx_http_esp_get_module_ctx(r_);\n  ngx_str_copy_from_std(r_->pool, auth_token, &ctx->auth_token);\n}\n\nutils::Status NgxEspRequest::AddHeaderToBackend(const std::string &key,\n                                                const std::string &value) {\n  ngx_table_elt_t *h = nullptr;\n  for (auto &h_in : r_->headers_in) {\n    if (key.size() == h_in.key.len &&\n        strncasecmp(key.c_str(), reinterpret_cast<const char *>(h_in.key.data),\n                    h_in.key.len) == 0) {\n      h = &h_in;\n      break;\n    }\n  }\n  if (h == nullptr) {\n    h = reinterpret_cast<ngx_table_elt_t *>(\n        ngx_list_push(&r_->headers_in.headers));\n    if (h == nullptr) {\n      return utils::Status(Code::INTERNAL, \"Out of memory\");\n    }\n\n    h->lowcase_key =\n        reinterpret_cast<u_char *>(ngx_pcalloc(r_->pool, key.size()));\n    if (h->lowcase_key == nullptr) {\n      return utils::Status(Code::INTERNAL, \"Out of memory\");\n    }\n    h->hash = ngx_hash_strlow(\n        h->lowcase_key,\n        reinterpret_cast<u_char *>(const_cast<char *>(key.c_str())),\n        key.size());\n  }\n\n  if (ngx_str_copy_from_std(r_->pool, key, &h->key) != NGX_OK ||\n      ngx_str_copy_from_std(r_->pool, value, &h->value) != NGX_OK) {\n    return utils::Status(Code::INTERNAL, \"Out of memory\");\n  }\n  ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r_->connection->log, 0,\n                 \"updates header to backend: \\\"%V: %V\\\"\", &h->key, &h->value);\n  return utils::Status::OK;\n}\n\n}  // namespace nginx\n}  // namespace api_manager\n\n}  // namespace google\n", "/*\n * Copyright (C) Extensible Service Proxy Authors\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n#ifndef NGINX_NGX_ESP_REQUEST_H_\n#define NGINX_NGX_ESP_REQUEST_H_\n\nextern \"C\" {\n#include \"src/http/ngx_http.h\"\n}\n\n#include \"include/api_manager/request.h\"\n\nnamespace google {\nnamespace api_manager {\nnamespace nginx {\n\n// Wraps ngx_http_request_t as a ::google::api_manager::Request.\nclass NgxEspRequest : public Request {\n public:\n  NgxEspRequest(ngx_http_request_t *r);\n  ~NgxEspRequest();\n\n  virtual std::string GetRequestHTTPMethod();\n  virtual std::string GetQueryParameters();\n  virtual protocol::Protocol GetFrontendProtocol();\n  virtual protocol::Protocol GetBackendProtocol();\n  virtual std::string GetRequestPath();\n  virtual std::string GetUnparsedRequestPath();\n  virtual std::string GetClientIP();\n\n  virtual int64_t GetGrpcRequestBytes();\n  virtual int64_t GetGrpcResponseBytes();\n  virtual int64_t GetGrpcRequestMessageCounts();\n  virtual int64_t GetGrpcResponseMessageCounts();\n\n  virtual void SetAuthToken(const std::string &auth_token);\n  virtual utils::Status AddHeaderToBackend(const std::string &key,\n                                           const std::string &value);\n  virtual bool FindQuery(const std::string &name, std::string *query);\n  virtual bool FindHeader(const std::string &name, std::string *header);\n\n private:\n  ngx_http_request_t *r_;\n};\n\n}  // namespace nginx\n}  // namespace api_manager\n}  // namespace google\n\n#endif  // NGINX_NGX_ESP_REQUEST_H_\n", "# Copyright (C) Extensible Service Proxy Authors\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n#\n################################################################################\n#\n# A shared module for ESP end-to-end tests.\n# Sets up a TEST_NGINX_BINARY environment variable for Nginx test framework\n# to find ESP build of Nginx.\n# Adds Nginx test library (nginx-tests/lib) to the module search path.\n\nuse strict;\nuse warnings;\n\npackage ApiManager;\n\nuse Config;\nuse FindBin;\nuse IO::Socket;\nuse JSON::PP;\nuse Data::Dumper;\nuse MIME::Base64;\nuse Test::More;\n\nsub repo_root {\n  my $testdir = $FindBin::Bin;\n  my @path = split('/', $testdir);\n  return (join('/', @path[0 .. $#path - 3]), $testdir);\n}\n\nBEGIN {\n  our ($Root, $TestDir) = repo_root();\n  our $TestLib = $Root . \"/third_party/nginx-tests/lib\";\n\n  if (!defined $ENV{TEST_SRCDIR}) {\n    $ENV{TEST_SRCDIR} = $Root;\n  }\n}\n\nuse lib $ApiManager::TestLib;\n\nselect STDERR; $| = 1;   # flush stderr immediately\nselect STDOUT; $| = 1;   # flush stdout immediately\n\nsub write_binary_file {\n  my ($name, $content) = @_;\n  open F, '>>', $name or die \"Can't create $name: $!\";\n  binmode F;\n  print F $content;\n  close F;\n}\n\nsub compare {\n  my ($x, $y, $path, $ignore_keys) = @_;\n\n  my $refx = ref $x;\n  my $refy = ref $y;\n  if(!$refx && !$refy) { # both are scalars\n    unless ($x eq $y) {\n      print \"$path value doesn't match $x != $y.\\n\";\n      return 0;\n    }\n  }\n  elsif ($refx ne $refy) { # not the same type\n    print \"$path type doesn't match $refx != $refy.\\n\";\n    return 0;\n  }\n  elsif ($refx eq 'SCALAR' || $refx eq 'REF') {\n    return compare(${$x}, ${$y}, $path, $ignore_keys);\n  }\n  elsif ($refx eq 'ARRAY') {\n    if ($#{$x} == $#{$y}) { # same length\n      my $i = -1;\n      for (@$x) {\n        $i++;\n        return 0 unless compare(\n          $x->[$i], $y->[$i], \"$path:[$i]\", $ignore_keys);\n      }\n    }\n    else {\n      print \"$path array size doesn't match: $#{$x} != $#{$y}.\\n\";\n      return 0;\n    }\n  }\n  elsif ($refx eq 'HASH') {\n    my @diff = grep { !exists $ignore_keys->{$_} && !exists $y->{$_} } keys %$x;\n    if (@diff) {\n      print \"$path has following extra keys:\\n\";\n      for (@diff) {\n        print \"$_: $x->{$_}\\n\";\n      }\n      return 0;\n    }\n    for (keys %$y) {\n      unless(exists($x->{$_})) {\n        print \"$path key $_ doesn't exist.\\n\";\n        return 0;\n      }\n      return 0 unless compare($x->{$_}, $y->{$_}, \"$path:$_\", $ignore_keys);\n    }\n  } else {\n    print \"$path: Not supported type: $refx\\n\";\n    return 0;\n  }\n  return 1;\n}\n\nsub compare_json {\n  my ($json, $expected, $random_metrics) = @_;\n  my $json_obj = decode_json($json);\n\n  print Dumper $json_obj if $ENV{TEST_NGINX_VERBOSE};\n  return compare($json_obj, $expected, \"\", {});\n}\n\nsub compare_json_with_random_metrics {\n  my ($json, $expected, @random_metrics) = @_;\n  my $json_obj = decode_json($json);\n\n  # A list of metrics with non-deterministic values.\n  my %random_metric_map = map { $_ => 1 } @random_metrics;\n\n  # Check and remove the above random metrics before making the comparison.\n  my $matched_random_metric_count = 0;\n  if (not exists $json_obj->{operations}) {\n    return 0;\n  }\n\n  my $operation = $json_obj->{operations}->[0];\n  if (not exists $operation->{metricValueSets}) {\n    return 0;\n  }\n\n  my @metric_value_sets;\n  foreach my $metric (@{$operation->{metricValueSets}}) {\n    if (exists($random_metric_map{$metric->{metricName}})) {\n      $matched_random_metric_count += 1;\n    } else {\n      push @metric_value_sets, $metric;\n    }\n  }\n\n  if ($matched_random_metric_count != scalar @random_metrics) {\n    return 0;\n  }\n  $operation->{metricValueSets} = \\@metric_value_sets;\n\n  print Dumper $json_obj if $ENV{TEST_NGINX_VERBOSE};\n  my %ignore_keys = map { $_ => \"1\" } qw(\n    startTime endTime timestamp operationId);\n  return compare($json_obj, $expected, \"\", \\%ignore_keys);\n}\n\nsub compare_user_info {\n  my ($user_info, $expected) = @_;\n  my $json_obj = decode_json(decode_base64($user_info));\n  print Dumper $json_obj if $ENV{TEST_NGINX_VERBOSE};\n  return compare($json_obj, $expected, \"\", {});\n}\n\nsub read_file_using_full_path {\n  my ($full_path) = @_;\n  local $/;\n  open F, '<', $full_path or die \"Can't open $full_path $!\";\n  my $content = <F>;\n  close F;\n  return $content;\n}\n\nsub read_test_file {\n  my ($name) = @_;\n  return read_file_using_full_path($ApiManager::TestDir . '/' . $name);\n}\n\nsub write_file_expand {\n  if (!defined $ENV{TEST_CONFIG}) {\n    $ENV{TEST_CONFIG} = \"\";\n  }\n  my ($t, $name, $content) = @_;\n  $content =~ s/%%TEST_CONFIG%%/$ENV{TEST_CONFIG}/gmse;\n  $t->write_file_expand($name,  $content);\n}\n\nsub get_bookstore_service_config {\n  return read_test_file(\"testdata/bookstore.pb.txt\");\n}\n\nsub get_bookstore_service_config_allow_all_http_requests {\n    return read_test_file('testdata/bookstore_allow_all_http_requests.pb.txt');\n}\n\nsub get_bookstore_service_config_allow_unregistered {\n  return get_bookstore_service_config .\n         read_test_file(\"testdata/usage_fragment.pb.txt\");\n}\n\nsub get_bookstore_service_config_allow_some_unregistered {\n  return get_bookstore_service_config .\n      read_test_file(\"testdata/usage_frag.pb.txt\");\n}\n\nsub get_echo_service_config {\n  return read_test_file(\"testdata/echo_service.pb.txt\");\n}\n\nsub get_grpc_test_service_config {\n  my ($GrpcBackendPort) = @_;\n  return read_test_file(\"testdata/grpc_echo_service.pb.txt\") . <<EOF\nbackend {\n  rules {\n    selector: \"test.grpc.Test.Echo\"\n    address: \"127.0.0.1:$GrpcBackendPort\"\n  }\n  rules {\n    selector: \"test.grpc.Test.EchoStream\"\n    address: \"127.0.0.1:$GrpcBackendPort\"\n  }\n}\nEOF\n}\n\nsub get_grpc_interop_service_config {\n  return read_test_file(\"testdata/grpc_interop_service.pb.txt\");\n}\n\nsub get_transcoding_test_service_config {\n  my ($host_name, $service_control_address) = @_;\n  my $path = './test/transcoding/service.pb.txt';\n  my $service_config = read_file_using_full_path($path);\n  # Replace the host name\n  $service_config =~ s/<YOUR_PROJECT_ID>.appspot.com/$host_name/;\n  # Replace the project id\n  $service_config =~ s/<YOUR_PROJECT_ID>/endpoints-transcoding-test/;\n  # Replace the service control address\n  $service_config =~ s/servicecontrol.googleapis.com/$service_control_address/;\n  return $service_config;\n}\n\nsub get_grpc_echo_test_service_config {\n  my ($host_name, $service_control_address) = @_;\n  my $path = './test/grpc/local/service.json';\n  my $service_config = read_file_using_full_path($path);\n  # Replace the host name\n  $service_config =~ s/echo-dot-esp-grpc-load-test.appspot.com/$host_name/;\n  # Replace the service control address\n  $service_config =~ s/servicecontrol.googleapis.com/$service_control_address/;\n  return $service_config;\n}\n\nsub get_large_report_request {\n  my ($t, $size) = @_;\n  my $testdir = $t->testdir();\n  my $cmd = './src/tools/service_control_json_gen';\n  system \"$cmd --report_request_size=$size --json > $testdir/large_data.json\";\n  return $t->read_file('large_data.json');\n}\n\nsub get_metadata_response_body {\n  return <<EOF;\n{\n  \"instance\": {\n    \"attributes\": {\n      \"gae_app_container\": \"app\",\n      \"gae_app_fullname\": \"esp-test-app_20150921t180445-387321214075436208\",\n      \"gae_backend_instance\": \"0\",\n      \"gae_backend_minor_version\": \"387321214075436208\",\n      \"gae_backend_name\": \"default\",\n      \"gae_backend_version\": \"20150921t180445\",\n      \"gae_project\": \"esp-test-app\",\n      \"gae_vm_runtime\": \"custom\",\n      \"gcm-pool\": \"gae-default-20150921t180445\",\n      \"gcm-replica\": \"gae-default-20150921t180445-inqp\"\n    },\n    \"cpuPlatform\": \"Intel Ivy Bridge\",\n    \"description\": \"GAE managed VM for module: default, version: 20150921t180445\",\n    \"hostname\": \"gae-default-20150921t180445-inqp.c.esp-test-app.internal\",\n    \"id\": 3296474103533342935,\n    \"image\": \"\",\n    \"machineType\": \"projects/345623948572/machineTypes/g1-small\",\n    \"maintenanceEvent\": \"NONE\",\n    \"zone\": \"projects/345623948572/zones/us-west1-d\"\n  },\n  \"project\": {\n    \"numericProjectId\": 345623948572,\n    \"projectId\": \"esp-test-app\"\n  }\n}\nEOF\n}\n\nsub disable_service_control_cache {\n  return <<EOF;\nservice_control_config {\n  check_aggregator_config {\n  cache_entries: 0\n  }\n  report_aggregator_config {\n  cache_entries: 0\n  }\n}\nEOF\n}\n\nsub grpc_test_server {\n  my ($t, @args) = @_;\n  my $server = './test/grpc/grpc-test-server';\n  exec $server, @args;\n}\n\nsub grpc_interop_server {\n  my ($t, $port, @args) = @_;\n  my $server = \"./external/com_github_grpc_grpc/test/cpp/interop/interop_server\";\n  exec $server, \"--port\", $port, @args;\n}\n\nsub transcoding_test_server {\n  my ($t, @args) = @_;\n  my $server = './test/transcoding/bookstore-server';\n  exec $server, @args;\n}\n\n# Runs the gRPC server for testing transcoding and redirects the output to a\n# file.\nsub run_transcoding_test_server {\n  my ($t, $output_file, @args) = @_;\n  my $redirect_file = $t->{_testdir}.'/'.$output_file;\n\n  # redirect, fork & run, restore\n  open ORIGINAL, \">&\", \\*STDOUT;\n  open STDOUT, \">\", $redirect_file;\n  $t->run_daemon(\\&transcoding_test_server, $t, @args);\n  open STDOUT, \">&\", \\*ORIGINAL;\n}\n\nsub call_bookstore_client {\n  my ($t, @args) = @_;\n  my $client = './test/transcoding/bookstore-client';\n  my $output_file = $t->{_testdir} . '/bookstore-client.log';\n\n  my $rc = system \"$client \" . join(' ', @args) . \" > $output_file\";\n\n  return ($rc, read_file_using_full_path($output_file))\n}\n\nsub run_grpc_test {\n  my ($t, $plans) = @_;\n  $t->write_file('test_plans.txt', $plans);\n  my $testdir = $t->testdir();\n  my $client = './test/grpc/grpc-test-client';\n  system \"$client < $testdir/test_plans.txt > $testdir/test_results.txt\";\n  return $t->read_file('test_results.txt');\n}\n\nsub run_grpc_interop_test {\n  my ($t, $port, $test_case, @args) = @_;\n  my $testdir = $t->testdir();\n  my $client = \"./external/com_github_grpc_grpc/test/cpp/interop/interop_client\";\n  return system \"$client --server_port $port --test_case $test_case \" . join(' ', @args)\n}\n\nsub run_grpc_interop_stress_test {\n  my ($t, $port, $metrics_port, $test_cases, $duration, @args) = @_;\n  my $testdir = $t->testdir();\n  my $client = './external/com_github_grpc_grpc/test/cpp/interop/stress_test';\n  return system \"$client --server_addresses localhost:$port \" .\n      \"--test_cases $test_cases --test_duration_secs $duration \" .\n      \"--num_channels_per_server 200 --num_stubs_per_channel 1 \" . \n      join(' ', @args)\n}\n\n\nsub run_nginx_with_stderr_redirect {\n  my $t = shift;\n  my $redirect_file = $t->{_testdir}.'/stderr.log';\n\n  # redirect, fork & run, restore\n  open ORIGINAL, \">&\", \\*STDERR;\n  open STDERR, \">\", $redirect_file;\n  $t->run();\n  open STDERR, \">&\", \\*ORIGINAL;\n}\n\n# Runs an HTTP server that returns \"404 Not Found\" for every request.\nsub not_found_server {\n  my ($t, $port) = @_;\n\n  my $server = HttpServer->new($port, $t->testdir() . '/nop.log')\n    or die \"Can't create test server socket: $!\\n\";\n\n  $server->run();\n}\n\n# Reads a file which contains a stream of HTTP requests,\n# parses out individual requests and returns them in an array.\nsub read_http_stream {\n  my ($t, $file) = @_;\n\n  my $http = $t->read_file($file);\n\n  # Parse out individual HTTP requests.\n\n  my @requests;\n\n  while ($http ne '') {\n    my ($request_headers, $rest) = split /\\r\\n\\r\\n/, $http, 2;\n    my @header_lines = split /\\r\\n/, $request_headers;\n\n    my %headers;\n    my $verb = '';\n    my $uri = '';\n    my $path = '';\n    my $body = '';\n\n    # Process request line.\n    my $request_line = $header_lines[0];\n    if ($request_line =~ /^(\\S+)\\s+(([^? ]+)(\\?[^ ]+)?)\\s+HTTP/i) {\n      $verb = $1;\n      $uri = $2;\n      $path = $3;\n    }\n\n    # Process headers\n    foreach my $header (@header_lines[1 .. $#header_lines]) {\n      my ($key, $value) = split /\\s*:\\s*/, $header, 2;\n      $headers{lc $key} = $value;\n    }\n\n    my $content_length = $headers{'content-length'} || 0;\n    if ($content_length > 0) {\n      $body = substr $rest, 0, $content_length;\n      $rest = substr $rest, $content_length;\n    }\n\n    push @requests, {\n      'verb' => $verb,\n      'path' => $path,\n      'uri' => $uri,\n      'headers' => \\%headers,\n      'body' => $body\n    };\n\n    $http = $rest;\n  }\n\n  return @requests;\n}\n\n# Checks that response Content-Type header is application/json and matches the\n# response body with the expected JSON.\nsub verify_http_json_response {\n  my ($response, $expected_body) = @_;\n\n  # Parse out the body\n  my ($headers, $actual_body) = split /\\r\\n\\r\\n/, $response, 2;\n\n  if ($headers !~ qr/HTTP\\/1.1 200 OK/i) {\n    Test::More::diag(\"Status code doesn't match\\n\");\n    Test::More::diag(\"Expected: 200 OK\\n\");\n    Test::More::diag(\"Actual headers: ${headers}\\n\");\n    return 0;\n  }\n\n  if ($headers !~ qr/content-type:(\\s)*application\\/json/i) {\n    Test::More::diag(\"Content-Type doesn't match\\n\");\n    Test::More::diag(\"Expected: application/json\\n\");\n    Test::More::diag(\"Actual headers: ${headers}\\n\");\n    return 0;\n  }\n\n  if (!compare_json($actual_body, $expected_body)) {\n    Test::More::diag(\"Response body doesn't match\\n\");\n    Test::More::diag(\"Expected: \" . encode_json(${expected_body}) . \"\\n\");\n    Test::More::diag(\"Actual: ${actual_body}\\n\");\n    return 0;\n  }\n\n  return 1;\n}\n\nsub http_response_body {\n  my ($response, $expected_body) = @_;\n  my ($headers, $actual_body) = split /\\r\\n\\r\\n/, $response, 2;\n  return $actual_body;\n}\n\n# Initial port is 8080 or $TEST_PORT env variable. A test is allowed to use 10\n# subsequent ports.\nsub available_port_range {\n  my %port_range;\n  if (!defined $ENV{TEST_PORT}) {\n    %port_range = (8080, 8090);\n  } else {\n    %port_range = ($ENV{TEST_PORT}, $ENV{TEST_PORT} + 10);\n  }\n\n  printf(\"Available port range: [%d, %d)\\n\", %port_range);\n  return %port_range;\n}\n\nmy ($next_port, $max_port) = available_port_range();\n\n# Select an open port\nsub pick_port {\n  for (my $port = $next_port; $port < $max_port; $port++) {\n    my $server = IO::Socket::INET->new(\n        Proto => 'tcp',\n        LocalHost => '127.0.0.1',\n        LocalPort => $port,\n    )\n    or next;\n    close $server;\n    $next_port = $port + 1;\n    print \"Pick port: $port\\n\";\n    return $port;\n  }\n  die \"Could not find an available port for testing\\n\"\n}\n\n#\n# These routines are copied from Nginx.pm to support custom ports\n#\n\nsub log_core {\n  my ($prefix, $msg) = @_;\n  ($prefix, $msg) = ('', $prefix) unless defined $msg;\n  $prefix .= ' ' if length($prefix) > 0;\n\n  if (length($msg) > 2048) {\n    $msg = substr($msg, 0, 2048)\n      . \"(...logged only 2048 of \" . length($msg)\n      . \" bytes)\";\n  }\n\n  $msg =~ s/^/# $prefix/gm;\n  $msg =~ s/([^\\x20-\\x7e])/sprintf('\\\\x%02x', ord($1)) . (($1 eq \"\\n\") ? \"\\n\" : '')/gmxe;\n  $msg .= \"\\n\" unless $msg =~ /\\n\\Z/;\n  print $msg;\n}\n\nsub log_out {\n  log_core('>>', @_);\n}\n\nsub log_in {\n  log_core('<<', @_);\n}\n\nsub http_get($;$;%) {\n  my ($port, $url, %extra) = @_;\n  return http($port, <<EOF, %extra);\nGET $url HTTP/1.0\nHost: localhost\n\nEOF\n}\n\nsub http($;$;%) {\n  my ($port, $request, %extra) = @_;\n\n  my $s = http_start($port, $request, %extra);\n\n  return $s if $extra{start} or !defined $s;\n  return http_end($s, %extra);\n}\n\nsub http_start($;$;%) {\n  my ($port, $request, %extra) = @_;\n  my $s;\n\n  eval {\n    local $SIG{ALRM} = sub { die \"timeout\\n\" };\n    local $SIG{PIPE} = sub { die \"sigpipe\\n\" };\n    my $timeout = 8;\n    $timeout = $extra{timeout} if $extra{timeout};\n    alarm($timeout);\n\n    $s = $extra{socket} || IO::Socket::INET->new(\n      Proto => 'tcp',\n      PeerAddr => \"127.0.0.1:$port\"\n    )\n      or die \"Can't connect to nginx: $!\\n\";\n\n    log_out($request);\n    $s->print($request);\n\n    select undef, undef, undef, $extra{sleep} if $extra{sleep};\n    return '' if $extra{aborted};\n\n    if ($extra{body}) {\n      log_out($extra{body});\n      $s->print($extra{body});\n    }\n\n    alarm(0);\n  };\n  alarm(0);\n  if ($@) {\n    log_in(\"died: $@\");\n    return undef;\n  }\n\n  return $s;\n}\n\nsub http_end($;%) {\n  my ($s, %extra) = @_;\n  my $reply;\n\n  eval {\n    local $SIG{ALRM} = sub { die \"timeout\\n\" };\n    local $SIG{PIPE} = sub { die \"sigpipe\\n\" };\n    my $timeout = 8;\n    $timeout = $extra{timeout} if $extra{timeout};\n    alarm($timeout);\n\n    local $/;\n    $reply = $s->getline();\n\n    alarm(0);\n  };\n  alarm(0);\n  if ($@) {\n    log_in(\"died: $@\");\n    return undef;\n  }\n\n  log_in($reply);\n  return $reply;\n}\n\n# Waits for a UDS socket to be ready.\nsub wait_for_uds($) {\n  my ($sockpath) = @_;\n\n  # wait for socket to accept connections\n  for (1 .. 50) {\n    my $s = IO::Socket::UNIX->new(\n\t    Type => SOCK_STREAM(),\n\t    PeerAddr => $sockpath,\n    );\n\n    return 1 if defined $s;\n    select undef, undef, undef, 0.1;\n  }\n\n  return undef;\n}\n\n1;\n", "# Copyright (C) Extensible Service Proxy Authors\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n#\n################################################################################\n#\nuse strict;\nuse warnings;\n\n################################################################################\n\nuse src::nginx::t::ApiManager;   # Must be first (sets up import path to the Nginx test module)\nuse src::nginx::t::HttpServer;\nuse Test::Nginx;  # Imports Nginx's test module\nuse Test::More;   # And the test framework\nuse Data::Dumper;\n\n################################################################################\n\n# Port assignments\nmy $NginxPort = ApiManager::pick_port();\nmy $BackendPort = ApiManager::pick_port();\nmy $ServiceControlPort = ApiManager::pick_port();\n\nmy $t = Test::Nginx->new()->has(qw/http proxy/)->plan(14);\n\n# Save service name in the service configuration protocol buffer file.\n\n$t->write_file('service.pb.txt', ApiManager::get_bookstore_service_config . <<\"EOF\");\ncontrol {\n  environment: \"http://127.0.0.1:${ServiceControlPort}\"\n}\nEOF\n\nApiManager::write_file_expand($t, 'nginx.conf', <<\"EOF\");\n%%TEST_GLOBALS%%\ndaemon off;\nevents {\n  worker_connections 32;\n}\nhttp {\n  %%TEST_GLOBALS_HTTP%%\n  server_tokens off;\n  server {\n    listen 127.0.0.1:${NginxPort};\n    server_name localhost;\n    location / {\n      endpoints {\n        api service.pb.txt;\n        %%TEST_CONFIG%%\n        on;\n      }\n      proxy_pass http://127.0.0.1:${BackendPort};\n    }\n  }\n}\nEOF\n\n$t->run_daemon(\\&bookstore, $t, $BackendPort, 'bookstore.log');\n$t->run_daemon(\\&servicecontrol, $t, $ServiceControlPort, 'servicecontrol.log');\nis($t->waitforsocket(\"127.0.0.1:${BackendPort}\"), 1, 'Bookstore socket ready.');\nis($t->waitforsocket(\"127.0.0.1:${ServiceControlPort}\"), 1, 'Service control socket ready.');\n$t->run();\n\n################################################################################\n\nmy $response = ApiManager::http($NginxPort,<<'EOF');\nGET /shelves?key=this-is-an-api-key HTTP/1.0\nHost: localhost\nx-endpoint-api-userinfo: Should be removed\n\nEOF\n\n$t->stop_daemons();\n\nmy ($response_headers, $response_body) = split /\\r\\n\\r\\n/, $response, 2;\n\nlike($response_headers, qr/HTTP\\/1\\.1 200 OK/, 'Returned HTTP 200.');\nis($response_body, <<'EOF', 'Shelves returned in the response body.');\n{ \"shelves\": [\n    { \"name\": \"shelves/1\", \"theme\": \"Fiction\" },\n    { \"name\": \"shelves/2\", \"theme\": \"Fantasy\" }\n  ]\n}\nEOF\n\nmy @requests = ApiManager::read_http_stream($t, 'bookstore.log');\nis(scalar @requests, 1, 'Backend received one request');\n\nmy $r = shift @requests;\n\nis($r->{verb}, 'GET', 'Backend request was a get');\nis($r->{uri}, '/shelves?key=this-is-an-api-key', 'Backend uri was /shelves');\nis($r->{headers}->{host}, \"127.0.0.1:${BackendPort}\", 'Host header was set');\nis($r->{headers}->{'x-endpoint-api-userinfo'}, '',\n    'X-Endpoint-API-UserInfo should be removed from the request headers');\n\n@requests = ApiManager::read_http_stream($t, 'servicecontrol.log');\nis(scalar @requests, 1, 'Service control received one request');\n\n$r = shift @requests;\nis($r->{verb}, 'POST', ':check verb was post');\nis($r->{uri}, '/v1/services/endpoints-test.cloudendpointsapis.com:check', ':check was called');\nis($r->{headers}->{host}, \"127.0.0.1:${ServiceControlPort}\", 'Host header was set');\nis($r->{headers}->{'content-type'}, 'application/x-protobuf', ':check Content-Type was protocol buffer');\n\n################################################################################\n\nsub bookstore {\n  my ($t, $port, $file) = @_;\n  my $server = HttpServer->new($port, $t->testdir() . '/' . $file)\n    or die \"Can't create test server socket: $!\\n\";\n  local $SIG{PIPE} = 'IGNORE';\n\n  $server->on('GET', '/shelves?key=this-is-an-api-key', <<'EOF');\nHTTP/1.1 200 OK\nConnection: close\n\n{ \"shelves\": [\n    { \"name\": \"shelves/1\", \"theme\": \"Fiction\" },\n    { \"name\": \"shelves/2\", \"theme\": \"Fantasy\" }\n  ]\n}\nEOF\n  $server->run();\n}\n\nsub servicecontrol {\n  my ($t, $port, $file) = @_;\n  my $server = HttpServer->new($port, $t->testdir() . '/' . $file)\n    or die \"Can't create test server socket: $!\\n\";\n  local $SIG{PIPE} = 'IGNORE';\n  $server->on('POST', '/v1/services/endpoints-test.cloudendpointsapis.com:check', <<'EOF');\nHTTP/1.1 200 OK\nConnection: close\n\nEOF\n  $server->run();\n}\n\n################################################################################\n"], "fixing_code": ["/* Copyright (C) Extensible Service Proxy Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef API_MANAGER_REQUEST_H_\n#define API_MANAGER_REQUEST_H_\n\n#include <map>\n#include <string>\n\n#include \"include/api_manager/protocol.h\"\n#include \"include/api_manager/utils/status.h\"\n\nnamespace google {\nnamespace api_manager {\n\n// Request provides an interface for CallHandler::Check to use to\n// query information about a request.\nclass Request {\n public:\n  virtual ~Request() {}\n\n  // Returns the HTTP method used for this call.\n  virtual std::string GetRequestHTTPMethod() = 0;\n\n  // Returns the query parameters\n  virtual std::string GetQueryParameters() = 0;\n\n  // Returns the REST path or RPC path for this call.\n  // It is the \"Unparsed\" path without the query parameters.\n  virtual std::string GetRequestPath() = 0;\n\n  // Returns the REST path or RPC path for this call.\n  // It should be \"Unparsed\" original URL path.\n  virtual std::string GetUnparsedRequestPath() = 0;\n\n  // Gets Client IP\n  // This will be used by service control Check() call.\n  virtual std::string GetClientIP() = 0;\n  // Gets Client Host.\n  virtual std::string GetClientHost() { return \"\"; }\n\n  // Get GRPC stats.\n  virtual int64_t GetGrpcRequestBytes() = 0;\n  virtual int64_t GetGrpcResponseBytes() = 0;\n  virtual int64_t GetGrpcRequestMessageCounts() = 0;\n  virtual int64_t GetGrpcResponseMessageCounts() = 0;\n\n  // Finds a HTTP query parameter with a name. Returns true if found.\n  virtual bool FindQuery(const std::string &name, std::string *query) = 0;\n\n  // Finds a HTTP header with a name. Returns true if found.\n  // Don't support multiple headers with same name for now. In that case,\n  // the first header will be returned.\n  virtual bool FindHeader(const std::string &name, std::string *header) = 0;\n\n  // Returns the protocol used for this call.\n  virtual ::google::api_manager::protocol::Protocol GetFrontendProtocol() = 0;\n  virtual ::google::api_manager::protocol::Protocol GetBackendProtocol() = 0;\n\n  // Sets auth token to the request object. Caller of RequestHandler::Check\n  // need to use it compose error message if authentication fails.\n  virtual void SetAuthToken(const std::string &auth_token) = 0;\n\n  // Adds a header to backend. If the header exists, overwrite its value\n  virtual utils::Status AddHeaderToBackend(const std::string &key,\n                                           const std::string &value,\n                                           bool changeAllOccurrence) = 0;\n};\n\n}  // namespace api_manager\n}  // namespace google\n\n#endif  // API_MANAGER_REQUEST_H_\n", "// Copyright (C) Extensible Service Proxy Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////////\n#include \"src/api_manager/check_auth.h\"\n\n#include <chrono>\n#include <string>\n\n#include \"include/api_manager/api_manager.h\"\n#include \"include/api_manager/request.h\"\n#include \"src/api_manager/auth.h\"\n#include \"src/api_manager/auth/lib/auth_jwt_validator.h\"\n#include \"src/api_manager/auth/lib/auth_token.h\"\n#include \"src/api_manager/auth/lib/base64.h\"\n#include \"src/api_manager/auth/lib/json.h\"\n#include \"src/api_manager/auth/lib/json_util.h\"\n#include \"src/api_manager/cloud_trace/cloud_trace.h\"\n#include \"src/api_manager/utils/url_util.h\"\n\nusing ::google::api_manager::auth::Certs;\nusing ::google::api_manager::auth::GetStringValue;\nusing ::google::api_manager::auth::JwtCache;\nusing ::google::api_manager::auth::JwtValidator;\nusing ::google::api_manager::auth::JwtValue;\nusing ::google::api_manager::utils::Status;\nusing ::google::protobuf::util::error::Code;\nusing std::chrono::system_clock;\n\nnamespace google {\nnamespace api_manager {\n\nnamespace {\nconst char kAccessTokenName[] = \"access_token\";\nconst char kAuthHeader[] = \"authorization\";\nconst char kAuthHeaderIAP[] = \"x-goog-iap-jwt-assertion\";\nconst char kBearer[] = \"Bearer \";\n\n// An AuthChecker object is created for every incoming request. It authenticates\n// the request, extracts user info from the auth token and sets it to the\n// request context.\nclass AuthChecker : public std::enable_shared_from_this<AuthChecker> {\n public:\n  AuthChecker(std::shared_ptr<context::RequestContext> context,\n              std::function<void(Status status)> continuation);\n\n  // Check auth for a given request. This is the starting point to enter\n  // the auth state machine.\n  void Check();\n\n private:\n  /*** Steps in auth state machine, ordered in execution sequence. ***/\n\n  // Not all the steps are executed for every request.\n  // For example, in case of a JWT cache hit, only four steps are executed:\n  // GetAuthToken() --> LookupJwtCache() --> CheckAudience() --> PassUserInfo()\n  // In the case of a JWT cache miss, but a key cache hit, the steps are:\n  // GetAuthToken() --> LookupJwtCache() --> ParseJwt() --> CheckAudience() -->\n  // InitKey() --> VerifySignature() --> PassUserInfo()\n  void GetAuthToken();\n\n  void LookupJwtCache();\n\n  void ParseJwt();\n\n  void CheckAudience(bool cache_hit);\n\n  void InitKey();\n\n  void DiscoverJwksUri(const std::string &url);\n\n  // Callback function for open ID discovery http fetch.\n  void PostFetchJwksUri(Status status, std::string &&body);\n\n  void FetchPubKey(const std::string &url);\n\n  // Callback function for public key http fetch.\n  void PostFetchPubKey(Status status, std::string &&body);\n\n  void VerifySignature();\n\n  void PassUserInfoOnSuccess();\n\n  /*** Helper functions ***/\n\n  // Returns a shared pointer of this AuthChecker object.\n  std::shared_ptr<AuthChecker> GetPtr() { return shared_from_this(); }\n\n  // Helper function to send a http GET request.\n  void HttpFetch(const std::string &url,\n                 std::function<void(Status, std::string &&)> continuation);\n\n  // Authentication error\n  void Unauthenticated(const std::string &error);\n\n  // Authorization error\n  void Unauthorized(const std::string &error);\n\n  // Fetch error, takes upstream error\n  void FetchFailure(const std::string &error, Status status);\n\n  /*** Member Variables. ***/\n\n  // Request context.\n  std::shared_ptr<context::RequestContext> context_;\n\n  // JWT validator.\n  std::unique_ptr<auth::JwtValidator> validator_;\n\n  // User info extracted from auth token.\n  UserInfo user_info_;\n\n  // Pointer to access ESP running environment.\n  ApiManagerEnvInterface *env_;\n\n  // auth token.\n  std::string auth_token_;\n\n  // The final continuation function.\n  std::function<void(Status status)> on_done_;\n\n  // Trace span for check auth.\n  std::shared_ptr<cloud_trace::CloudTraceSpan> trace_span_;\n};\n\nAuthChecker::AuthChecker(std::shared_ptr<context::RequestContext> context,\n                         std::function<void(Status status)> continuation)\n    : context_(context),\n      env_(context_->service_context()->env()),\n      on_done_(continuation) {}\n\nvoid AuthChecker::Check() {\n  if (!context_->service_context()->RequireAuth() ||\n      context_->method() == nullptr || !context_->method()->auth()) {\n    env_->LogDebug(\"Auth not required.\");\n    on_done_(Status::OK);\n    return;\n  }\n\n  // CreateSpan returns nullptr if trace is disabled.\n  trace_span_.reset(CreateSpan(context_->cloud_trace(), \"CheckAuth\"));\n\n  GetAuthToken();\n  if (auth_token_.empty()) {\n    Unauthenticated(\"Missing or invalid credentials\");\n    return;\n  }\n  context_->request()->SetAuthToken(auth_token_);\n  context_->SetAuthToken(auth_token_);\n  env_->LogDebug(std::string(\"auth token: \") + auth_token_);\n  LookupJwtCache();\n}\n\nvoid AuthChecker::GetAuthToken() {\n  Request *r = context_->request();\n  // IAP header is of format \"X-Goog-Iap-Jwt-Assertion\": \"eyJhbG...\". No\n  // \"Bearer\" prefix is needed.\n  if (r->FindHeader(kAuthHeaderIAP, &auth_token_)) {\n    return;\n  }\n\n  std::string auth_header;\n  if (!r->FindHeader(kAuthHeader, &auth_header)) {\n    // When authorization header is missing, check query parameter.\n    r->FindQuery(kAccessTokenName, &auth_token_);\n    return;\n  }\n\n  static const size_t bearer_len = sizeof(kBearer) - 1;\n  if (auth_header.size() <= bearer_len ||\n      auth_header.compare(0, bearer_len, kBearer) != 0) {\n    // Authorization header is not long enough, or authorization header does\n    // not begin with \"Bearer \", set auth_token_ to the whole string.\n    auth_token_ = auth_header;\n    return;\n  }\n\n  auth_token_ = auth_header.substr(bearer_len);\n}\n\nvoid AuthChecker::LookupJwtCache() {\n  bool remove = false;  // whether or not need to remove an expired entry.\n  bool cache_hit = false;\n  JwtCache &jwt_cache = context_->service_context()->jwt_cache();\n  {\n    JwtCache::ScopedLookup lookup(&jwt_cache, auth_token_);\n    if (lookup.Found()) {\n      JwtValue *val = lookup.value();\n      if (system_clock::now() <= val->exp) {\n        // Cache hit and cache entry is not expired.\n        user_info_ = val->user_info;\n        cache_hit = true;\n      } else {\n        // Need to removes the expired cache entry.\n        remove = true;\n      }\n    }\n  }\n  if (remove) {\n    jwt_cache.Remove(auth_token_);\n  }\n\n  if (cache_hit) {\n    CheckAudience(true);\n  } else {\n    ParseJwt();\n  }\n}\n\nvoid AuthChecker::ParseJwt() {\n  if (validator_ == nullptr) {\n    validator_ = JwtValidator::Create(auth_token_.c_str(), auth_token_.size());\n    if (validator_ == nullptr) {\n      Unauthenticated(\"Internal error\");\n      return;\n    }\n  }\n\n  Status status = validator_->Parse(&user_info_);\n  if (!status.ok()) {\n    Unauthenticated(status.message());\n    return;\n  }\n  CheckAudience(false);\n}\n\nvoid AuthChecker::CheckAudience(bool cache_hit) {\n  std::string audience = user_info_.audiences.empty()\n                             ? std::string()\n                             : user_info_.AudiencesAsString();\n  context_->set_auth_issuer(user_info_.issuer);\n  context_->set_auth_audience(audience);\n  context_->set_auth_authorized_party(user_info_.authorized_party);\n\n  context_->set_auth_claims(user_info_.claims);\n\n  // Remove http/s header and trailing '/' for issuer.\n  std::string issuer = utils::GetUrlContent(user_info_.issuer);\n  if (!context_->method()->isIssuerAllowed(issuer)) {\n    Unauthenticated(\"Issuer not allowed\");\n    return;\n  }\n\n  // The audience from the JWT must\n  //   - Equals to service_name or\n  //   - Explicitly allowed by the issuer in the method configuration.\n  // Otherwise the JWT is rejected.\n  const std::string &service_name = context_->service_context()->service_name();\n  // Remove http/s header and trailing '/' for audiences.\n  std::set<std::string> aud;\n  for (auto &it : user_info_.audiences) {\n    aud.insert(utils::GetUrlContent(it));\n  }\n  if (aud.find(service_name) == aud.end() &&\n      !context_->method()->isAudienceAllowed(issuer, aud)) {\n    Unauthorized(\"Audience not allowed\");\n    return;\n  }\n  if (cache_hit) {\n    PassUserInfoOnSuccess();\n  } else {\n    InitKey();\n  }\n}\n\nvoid AuthChecker::InitKey() {\n  Certs &key_cache = context_->service_context()->certs();\n  auto cert = key_cache.GetCert(user_info_.issuer);\n\n  if (cert == nullptr || system_clock::now() > cert->second) {\n    // Key has not been fetched or has expired.\n    std::string url;\n    bool tryOpenId =\n        context_->service_context()->GetJwksUri(user_info_.issuer, &url);\n    if (url.empty()) {\n      Unauthenticated(\"Cannot determine the URI of the key\");\n      return;\n    }\n\n    if (tryOpenId) {\n      DiscoverJwksUri(url);\n    } else {\n      // JwksUri is available. No need to try openID discovery.\n      FetchPubKey(url);\n    }\n  } else {\n    // Key is in the cache, next step is to verify signature.\n    VerifySignature();\n  }\n}\n\nvoid AuthChecker::DiscoverJwksUri(const std::string &url) {\n  auto pChecker = GetPtr();\n  HttpFetch(url, [pChecker](Status status, std::string &&body) {\n    pChecker->PostFetchJwksUri(status, std::move(body));\n  });\n}\n\nvoid AuthChecker::PostFetchJwksUri(Status status, std::string &&body) {\n  if (!status.ok()) {\n    context_->service_context()->SetJwksUri(user_info_.issuer, std::string(),\n                                            false);\n    FetchFailure(\"Unable to fetch URI of the key via OpenID discovery\", status);\n    return;\n  }\n\n  // Parse discovery doc and extract jwks_uri\n  grpc_json *discovery_json = grpc_json_parse_string_with_len(\n      const_cast<char *>(body.c_str()), body.size());\n  const char *jwks_uri;\n  if (discovery_json != nullptr) {\n    jwks_uri = GetStringValue(discovery_json, \"jwks_uri\");\n    grpc_json_destroy(discovery_json);\n  } else {\n    jwks_uri = nullptr;\n  }\n\n  if (jwks_uri == nullptr) {\n    env_->LogError(\"OpenID discovery failed due to invalid doc format\");\n    context_->service_context()->SetJwksUri(user_info_.issuer, std::string(),\n                                            false);\n    Unauthenticated(\"Unable to parse URI of the key via OpenID discovery\");\n    return;\n  }\n\n  // OpenID discovery completed. Set jwks_uri for the issuer in cache.\n  context_->service_context()->SetJwksUri(user_info_.issuer, jwks_uri, false);\n\n  FetchPubKey(jwks_uri);\n}\n\nvoid AuthChecker::FetchPubKey(const std::string &url) {\n  auto pChecker = GetPtr();\n  HttpFetch(url, [pChecker](Status status, std::string &&body) {\n    pChecker->PostFetchPubKey(status, std::move(body));\n  });\n}\n\nvoid AuthChecker::PostFetchPubKey(Status status, std::string &&body) {\n  if (!status.ok() || body.empty()) {\n    FetchFailure(\"Unable to fetch verification key\", status);\n    return;\n  }\n\n  Certs &key_cache = context_->service_context()->certs();\n  int cache_duration_in_s =\n      context_->service_context()->global_context()->jwks_cache_duration_in_s();\n  key_cache.Update(\n      user_info_.issuer, std::move(body),\n      system_clock::now() + std::chrono::seconds(cache_duration_in_s));\n  VerifySignature();\n}\n\nvoid AuthChecker::VerifySignature() {\n  Certs &key_cache = context_->service_context()->certs();\n  auto cert = key_cache.GetCert(user_info_.issuer);\n  if (cert == nullptr) {\n    Unauthenticated(\"Missing verification key\");\n    return;\n  }\n\n  Status status =\n      validator_->VerifySignature(cert->first.c_str(), cert->first.size());\n  if (!status.ok()) {\n    Unauthenticated(status.message());\n    return;\n  }\n\n  // Inserts the entry to JwtCache.\n  JwtCache &cache = context_->service_context()->jwt_cache();\n  cache.Insert(auth_token_, user_info_, validator_->GetExpirationTime(),\n               system_clock::now());\n\n  PassUserInfoOnSuccess();\n}\n\nvoid AuthChecker::PassUserInfoOnSuccess() {\n  char *json_buf = auth::WriteUserInfoToJson(user_info_);\n  if (json_buf == nullptr) {\n    return;\n  }\n  char *base64_json_buf = auth::esp_base64_encode(\n      json_buf, strlen(json_buf), true, false, true /*padding*/);\n  context_->request()->AddHeaderToBackend(auth::kEndpointApiUserInfo,\n                                          base64_json_buf, false);\n  auth::esp_grpc_free(json_buf);\n  auth::esp_grpc_free(base64_json_buf);\n\n  TRACE(trace_span_) << \"Authenticated.\";\n  trace_span_.reset();\n  on_done_(Status::OK);\n}\n\nvoid AuthChecker::Unauthenticated(const std::string &error) {\n  TRACE(trace_span_) << \"Authentication failed: \" << error;\n  trace_span_.reset();\n  on_done_(Status(Code::UNAUTHENTICATED,\n                  std::string(\"JWT validation failed: \") + error,\n                  Status::AUTH));\n}\n\nvoid AuthChecker::Unauthorized(const std::string &error) {\n  TRACE(trace_span_) << \"Authorization failed: \" << error;\n  trace_span_.reset();\n  on_done_(Status(Code::PERMISSION_DENIED,\n                  std::string(\"JWT validation failed: \") + error,\n                  Status::AUTH));\n}\n\nvoid AuthChecker::FetchFailure(const std::string &error, Status status) {\n  // Append HTTP response code for the upstream statuses\n  trace_span_.reset();\n  on_done_(Status(Code::UNAUTHENTICATED,\n                  std::string(\"JWT validation failed: \") + error +\n                      (status.code() >= 300 ? \". HTTP response code: \" +\n                                                  std::to_string(status.code())\n                                            : \"\"),\n                  Status::AUTH));\n}\n\nvoid AuthChecker::HttpFetch(\n    const std::string &url,\n    std::function<void(Status, std::string &&)> continuation) {\n  std::shared_ptr<cloud_trace::CloudTraceSpan> fetch_span(\n      CreateChildSpan(trace_span_.get(), \"HttpFetch\"));\n  env_->LogDebug(std::string(\"http fetch: \") + url);\n  TRACE(fetch_span) << \"Http request URL: \" << url;\n\n  std::unique_ptr<HTTPRequest> request(\n      new HTTPRequest([continuation, fetch_span](\n                          Status status, std::map<std::string, std::string> &&,\n                          std::string &&body) {\n        TRACE(fetch_span) << \"Http response status: \" << status.ToString();\n        continuation(status, std::move(body));\n      }));\n  if (!request) {\n    continuation(Status(Code::INTERNAL, \"Out of memory\"), \"\");\n    return;\n  }\n\n  request->set_method(\"GET\").set_url(url);\n  env_->RunHTTPRequest(std::move(request));\n}\n\n}  // namespace\n\nvoid CheckAuth(std::shared_ptr<context::RequestContext> context,\n               std::function<void(Status status)> continuation) {\n  std::shared_ptr<AuthChecker> authChecker =\n      std::make_shared<AuthChecker>(context, continuation);\n  authChecker->Check();\n}\n\n}  // namespace api_manager\n}  // namespace google\n", "// Copyright (C) Extensible Service Proxy Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n#include \"src/api_manager/check_auth.h\"\n\n#include \"src/api_manager/check_workflow.h\"\n#include \"src/api_manager/context/service_context.h\"\n#include \"src/api_manager/mock_api_manager_environment.h\"\n#include \"src/api_manager/mock_request.h\"\n\nusing ::testing::_;\nusing ::testing::AllOf;\nusing ::testing::DoAll;\nusing ::testing::Field;\nusing ::testing::Invoke;\nusing ::testing::Mock;\nusing ::testing::Return;\n\nusing ::google::api_manager::utils::Status;\nusing ::google::protobuf::util::error::Code;\n\nnamespace google {\nnamespace api_manager {\n\nnamespace {\n\nconst char kAccessTokenName[] = \"access_token\";\nconst char kAuthHeader[] = \"authorization\";\nconst char kBearer[] = \"Bearer \";\n\nconst char kServiceConfig[] =\n    \"name: \\\"endpoints-test.cloudendpointsapis.com\\\"\\n\"\n    \"authentication {\\n\"\n    \"    providers: [\\n\"\n    \"    {\\n\"\n    \"      id: \\\"issuer1\\\"\\n\"\n    \"      issuer: \\\"https://issuer1.com\\\"\\n\"\n    \"    },\\n\"\n    \"    {\\n\"\n    \"      id: \\\"openid_fail\\\"\\n\"\n    \"      issuer: \\\"http://openid_fail\\\"\\n\"\n    \"    },\\n\"\n    \"    {\\n\"\n    \"      id: \\\"issuer2\\\"\\n\"\n    \"      issuer: \\\"https://issuer2.com\\\"\\n\"\n    \"      jwks_uri: \\\"https://issuer2.com/pubkey\\\"\\n\"\n    \"    }\\n\"\n    \"    ],\\n\"\n    \"    rules: {\\n\"\n    \"      selector: \\\"ListShelves\\\"\\n\"\n    \"      requirements: [\\n\"\n    \"      {\\n\"\n    \"        provider_id: \\\"issuer1\\\"\\n\"\n    \"      },\\n\"\n    \"      {\\n\"\n    \"        provider_id: \\\"openid_fail\\\"\\n\"\n    \"      },\\n\"\n    \"      {\\n\"\n    \"        provider_id: \\\"issuer2\\\"\\n\"\n    \"      }\\n\"\n    \"      ]\\n\"\n    \"    }\\n\"\n    \"}\\n\"\n    \"http {\\n\"\n    \"  rules {\\n\"\n    \"    selector: \\\"ListShelves\\\"\\n\"\n    \"    get: \\\"/ListShelves\\\"\\n\"\n    \"  }\\n\"\n    \"}\\n\"\n    \"control {\\n\"\n    \"  environment : \\\"http://127.0.0.1:8081\\\"\\n\"\n    \"}\\n\";\n\n// Auth token generated with the following header and payload.\n//{\n// \"alg\": \"RS256\",\n// \"typ\": \"JWT\",\n// \"kid\": \"b3319a147514df7ee5e4bcdee51350cc890cc89e\"\n//}\n//{\n// \"iss\": \"https://issuer1.com\",\n// \"sub\": \"end-user-id\",\n// \"aud\": \"endpoints-test.cloudendpointsapis.com\",\n// \"iat\": 1461779321,\n// \"exp\": 2461782921\n//}\nconst char kToken[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImIzMzE5YTE0NzUxNGRmN2VlNWU0Ym\"\n    \"NkZWU1MTM1MGNjODkwY2M4OWUifQ.\"\n    \"eyJpc3MiOiJodHRwczovL2lzc3VlcjEuY29tIiwic3ViIjoiZW5kLXVzZXItaWQiLCJhdWQiOi\"\n    \"JlbmRwb2ludHMtdGVzdC5jbG91ZGVuZHBvaW50c2FwaXMuY29tIiwiaWF0IjoxNDYxNzc5MzIx\"\n    \"LCJleHAiOjI0NjE3ODI5MjF9.iiJj93x_KNSIh14nthz_N_\"\n    \"JsA6ZAZfQQxECrmhalrcw5jnlKKIwI_QFnv8y9EFyIHLfEt56-\"\n    \"GUXH7uLhed1sTJUNTd8sXyuFdSK1Cd3jAozvvZaYazhNIYC9ljh7hhm-\"\n    \"rHkirWTu1GxdRaJD3Az-B-VX3C_OWY9oHR2mhw0zxkEcMAgjf7GuGWr-AYtDmAMD_\"\n    \"fE8o7oXvD9eg506E5mcDa208m0N8Ysc3Ibdmfnux5B1pPB-5M-O2u2lVLjhne7SMCG9wv-\"\n    \"nnXCy9iAcTgCt6VmBtehZOBDQ0q8_08aWGoWBXntLwdXinVIs-zR-\"\n    \"4YUumdkEIIPF3IYE6ZAlloWG7Q\";\n\n// kToken2 is the same as kToken except that \"sub\" is \"another-user-id\".\nconst char kToken2[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImIzMzE5YTE0NzUxNGRmN2VlNWU0Ym\"\n    \"NkZWU1MTM1MGNjODkwY2M4OWUifQ.eyJpc3MiOiJodHRwczovL2lzc3VlcjEuY29tIiwic3ViI\"\n    \"joiYW5vdGhlci11c2VyLWlkIiwiYXVkIjoiZW5kcG9pbnRzLXRlc3QuY2xvdWRlbmRwb2ludHN\"\n    \"hcGlzLmNvbSIsImlhdCI6MTQ2MTc3OTMyMSwiZXhwIjoyNDYxNzgyOTIxfQ.ASIXY1N3fmGuDY\"\n    \"8-Xg6lCxiXM51wtTiGRmcYMk6_q_91D3D9cswVMfNp7YLf6sA4KQFxoTFAiWRqxT-kPzF5o2O8\"\n    \"ga4CY0VZAsiXRm-YTe7O8T2kFrVJOkABQIyNZgln8Sm15bO1MSyClj8Ti2qRAYPeoDM57X0f-u\"\n    \"0nQsWv0X8BsLvlJfu1J-4n08l_eEUFZlYGwpWCKfwvklmWXYfXdcJMeQ_poVqOti8dvSnqVi_Z\"\n    \"0Yu1r5Xuq45q4WNqQ9PRk1HFsWB7uV25m8fU2VpbRLFka6F9MZu4dU9gZoGCGDTtauCHiMqBTv\"\n    \"6vON8GbcB7w8pEhS1hK6FOehe4qZKnSA\";\n\n// kTokenOpenIdFail is the same as kToken except that \"iss\" is\n// \"http://openid_fail\".\nconst char kTokenOpenIdFail[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImIzMzE5YTE0NzUxNGRmN2VlNWU0Ym\"\n    \"NkZWU1MTM1MGNjODkwY2M4OWUifQ.\"\n    \"eyJpc3MiOiJodHRwOi8vb3BlbmlkX2ZhaWwiLCJzdWIiOiJlbmQtdXNlci1pZCIsImF1ZCI6Im\"\n    \"VuZHBvaW50cy10ZXN0LmNsb3VkZW5kcG9pbnRzYXBpcy5jb20iLCJpYXQiOjE0NjE3NzkzMjEs\"\n    \"ImV4cCI6MjQ2MTc4MjkyMX0.kauli_A55XB3AI-ZHrzlZs87VlMF_\"\n    \"iRyxAJs0BOCIZ0pYrsH4gKpheepafoJfYJcP5HYeC4JZuivKmfZn8hVjHZ-crXhxvnQf0AM-\"\n    \"nI4S80tuWewcvKQq3tpyoyjw0DAu4sI61ejCINvc2qEpiyp4jBcww1xxOFXbCOvSTbfJzISGSe\"\n    \"Kmqs5ryGHFyW-\"\n    \"rsGau030xa4ZnJo4qjzEaFqf9UwbWoEGhmJLHx6AWJUPnMtHN1YGZkCO7OXBk7gOOlVd5iNR-\"\n    \"OHDbpUEEYI2KM5N2MNdjN5QaAIwyvDnWTA3ivetbiiNP2sjt9Ar3fTkfO_\"\n    \"bjHTvoHiUKvPLTJfWeLVSzQ\";\n\n// kTokenOpenIdFail2 is the same as kTokenOpenIdFail except that \"sub\" is\n// \"another-user-id\".\nconst char kTokenOpenIdFail2[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImIzMzE5YTE0NzUxNGRmN2VlNWU0Ym\"\n    \"NkZWU1MTM1MGNjODkwY2M4OWUifQ.\"\n    \"eyJpc3MiOiJodHRwOi8vb3BlbmlkX2ZhaWwiLCJzdWIiOiJhbm90aGVyLXVzZXItaWQiLCJhdW\"\n    \"QiOiJlbmRwb2ludHMtdGVzdC5jbG91ZGVuZHBvaW50c2FwaXMuY29tIiwiaWF0IjoxNDYxNzc5\"\n    \"MzIxLCJleHAiOjI0NjE3ODI5MjF9.DYsI1A0CDZUbIniGAQy0JXyE9KjhmbSMxNzIrm_\"\n    \"5ogvwAXgpx4vStYtGU6w_Lv1vAtQHONY6zK4qzNBi3h-\"\n    \"wSXQtaFxycRphopohA56vyT6dP0BMWJQuDvWBUyxYWApP49XuVkZCFy3BFbJ8ZniuhzkgrRhTN\"\n    \"-L8jUiopUd6mtdPPc7ZLoWcKXrtsTjlNSOH7r2VmJTCeWgVsDCBRceFdLyNy1tfz5ibaTgP-\"\n    \"oL7tUQ1VnRkRoedLm17LoPKtu4-dbGchIaUnYfP1__gbHW48_oj_\"\n    \"QSbutSQYsxtx2ESZ78JFd1kFX0Qs5YL7u2k93Za49S3SuWH9CV7bca0leIzEw\";\n\n// kTokenIssuer2 is the same as kToken except that \"iss\" is\n// \"https://issuer2.com\".\nconst char kTokenIssuer2[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImIzMzE5YTE0NzUxNGRmN2VlNWU0Ym\"\n    \"NkZWU1MTM1MGNjODkwY2M4OWUifQ.\"\n    \"eyJpc3MiOiJodHRwczovL2lzc3VlcjIuY29tIiwic3ViIjoiZW5kLXVzZXItaWQiLCJhdWQiOi\"\n    \"JlbmRwb2ludHMtdGVzdC5jbG91ZGVuZHBvaW50c2FwaXMuY29tIiwiaWF0IjoxNDYxNzc5MzIx\"\n    \"LCJleHAiOjI0NjE3ODI5MjF9.iFPb5TSZXGBxzFKJ5FOZDr1sH_-5KEBRvJy5vtanbjX2H-\"\n    \"VU0aloWUeKCUGbtd9HdnHP4I7n-nivI1wltYK-E19aG3xswDZr3I5kg3JyNp-\"\n    \"T9a4EuQ7cue7ofxJi57l7vRDGQ-\"\n    \"9548QoenJP9vkJc4nb70xPF0CriwujaBr91jOaJmvc4W1ivXoIc1QgG9wHdRg8AgeIAaQhvnyj\"\n    \"F_Y9ut23lhAL8miYEs2ggwUSrImQzjed0t0205nz_\"\n    \"3rFZuei5DNEGbDoj6ja5jLvf11W2bCTkitEjYXUbomKm-RegWX6MjT-\"\n    \"zdhuVgY0vUaLFI1OFlKT7ArQQ5HZpw9lt4sKzg\";\n\n// kTokenExpired is the same as kToken except that \"exp\" is \"1461782921\".\nconst char kTokenExpired[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImIzMzE5YTE0NzUxNGRmN2VlNWU0Ym\"\n    \"NkZWU1MTM1MGNjODkwY2M4OWUifQ.\"\n    \"eyJpc3MiOiJodHRwczovL2lzc3VlcjEuY29tIiwic3ViIjoiZW5kLXVzZXItaWQiLCJhdWQiOi\"\n    \"JlbmRwb2ludHMtdGVzdC5jbG91ZGVuZHBvaW50c2FwaXMuY29tIiwiaWF0IjoxNDYxNzc5MzIx\"\n    \"LCJleHAiOjE0NjE3ODI5MjF9.Zlk_QD3FM5u-E7r2Vo4xrPfNUNtewfTmJPZUL_\"\n    \"MaLkWK3Do6ov0B8mj5nzf8fFyw3YTxhN7VjabDfwr2pTfVl0PA8Kx8XLz3R_\"\n    \"apAbP0UhKEBgYhv5GCLhiTTuq01QCDnhvcTVXRorWfe6ocC2GPTIHVA_M5U1v5nPopP-\"\n    \"Kp68fMQ3sro7mNIs-NtWQsjPEyk1cHu1wH0_pUjcVjex8SQb6vRxAEsF4sZq17cCRI-\"\n    \"6miwxYNzYyVCv-csNsxgTH8_kZbfXgk9WbJKE4k7XhIsU4K_cLmz8OysRw9IpsWQpmhHGHMXu-\"\n    \"-QBSDC3_5Lp5RU5oaEjHRd9AvXVsz1K1iaQ\";\n\n// kTokenBadAud is the same as kToken except that \"aud\" is \"some-audience\".\nconst char kTokenBadAud[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImIzMzE5YTE0NzUxNGRmN2VlNWU0Ym\"\n    \"NkZWU1MTM1MGNjODkwY2M4OWUifQ.\"\n    \"eyJpc3MiOiJodHRwczovL2lzc3VlcjEuY29tIiwic3ViIjoiZW5kLXVzZXItaWQiLCJhdWQiOi\"\n    \"Jzb21lLWF1ZGllbmNlIiwiaWF0IjoxNDYxNzc5MzIxLCJleHAiOjI0NjE3ODI5MjF9.\"\n    \"KFNI2R5r9IdjvAWFEvrM6q7dHNkrbLfPZNK7u8XQmn4vbMChHVW0gYYbO-\"\n    \"eaLPl0xnGX9q40xiMkM3blZ4oRPTj5YF_GcG9S-2fTPXdbmOtbHbpfMG1W26n2ESH2UKpEAL-\"\n    \"wRWbC7ea2dsdHE2zEbQfbLAwRjX3m3JiJlLHFJkQcrxsj8PwEScNBRJLRrIA1c4EPwQRsiNR7w\"\n    \"VooZYt_8v2ClgdKx8I-iDa4zhOheIVgvOduKARW5p2yyptM__9Pr544ox-R1IO2YYh-\"\n    \"70mLN05YowDM268OOjkdR1wC5vtsXGns5ZmT-h1vdQXluMuz-S2ppR3EqTUip4rBMOSAEQ\";\n\n// kTokenHttpsAud is the same as kToken except that \"aud\" is\n// \"https://endpoints-test.cloudendpointsapis.com\".\nconst char kTokenHttpsAud[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImIzMzE5YTE0NzUxNGRmN2VlNWU0Ym\"\n    \"NkZWU1MTM1MGNjODkwY2M4OWUifQ.\"\n    \"eyJpc3MiOiJodHRwczovL2lzc3VlcjEuY29tIiwic3ViIjoiZW5kLXVzZXItaWQiLCJhdWQiOi\"\n    \"JodHRwczovL2VuZHBvaW50cy10ZXN0LmNsb3VkZW5kcG9pbnRzYXBpcy5jb20iLCJpYXQiOjE0\"\n    \"NjE3NzkzMjEsImV4cCI6MjQ2MTc4MjkyMX0.\"\n    \"YVL4imxp7jS0RdvQhz7zflaqQzX7Q7TxVGZF9iHy9cxZKnB0wxGgXSb7jl_\"\n    \"KZ2tVCXvQLvErQAxrADDHUOLpXGbgdImF1UJz0YPQGffiyYPvXch2207czH9erKRNdMSxDCHrc\"\n    \"976Rvb9VTO9JFCTTbRwcGgBWz4H-gO55oCbErJCchyXdjLiMPiww-otw8n4tKqcNZhp_\"\n    \"xNDxkRExbk0oQH04epoIvmgmh6snAF06bi652Ag6Z4E842017DIZdaoy3VySbBsDMpZU2YLMil\"\n    \"fLJYUe5b64D6YvAfVAGgB01s7UJJb1b9KXoash5_nvM6xG0syr9URGF-kbqbWVccclA\";\n\n// kTokenHttpsSlashAud is the same as kToken except that \"aud\" is\n// \"\"https://endpoints-test.cloudendpointsapis.com/\".\nconst char kTokenHttpsSlashAud[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImIzMzE5YTE0NzUxNGRmN2VlNWU0Ym\"\n    \"NkZWU1MTM1MGNjODkwY2M4OWUifQ.\"\n    \"eyJpc3MiOiJodHRwczovL2lzc3VlcjEuY29tIiwic3ViIjoiZW5kLXVzZXItaWQiLCJhdWQiOi\"\n    \"JodHRwczovL2VuZHBvaW50cy10ZXN0LmNsb3VkZW5kcG9pbnRzYXBpcy5jb20vIiwiaWF0Ijox\"\n    \"NDYxNzc5MzIxLCJleHAiOjI0NjE3ODI5MjF9.OPN_7kPW2XR2qDNOB-\"\n    \"RNL1YLBTqJagbK7O2aieEr8VRWpUDR-BcY4LgbrVTY9kRvV1pb_T_\"\n    \"lCxX6tLIkKqC4QOZ1NuOVFhL1yAAjCI8oZB30m43JE8I0m6aEqjzelYcMBJFKp2Wfk16Hj-\"\n    \"Ain797f0u1F1tYJiat67bCfaPFJwWBsHHvyPbJ7NnxFvRYN6F1b8ddT9qAbELxj4fsj1F9rE0O\"\n    \"dmcp0lLhUa2OYrpyyipD5hv0eZIj4Yxlt962Qb6ZhewJULKULueIsWFXq3QZ-FPHXO8-B-\"\n    \"ZBDv5_INzDpTaUK0htgVMMvcbqCcr2DdAlloaZXUnnEINy-d57SBsw1w\";\n\n// kTokenHttpAud is the same as kToken except that \"aud\" is\n// \"http://endpoints-test.cloudendpointsapis.com\".\nconst char kTokenHttpAud[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImIzMzE5YTE0NzUxNGRmN2VlNWU0Ym\"\n    \"NkZWU1MTM1MGNjODkwY2M4OWUifQ.\"\n    \"eyJpc3MiOiJodHRwczovL2lzc3VlcjEuY29tIiwic3ViIjoiZW5kLXVzZXItaWQiLCJhdWQiOi\"\n    \"JodHRwczovL2VuZHBvaW50cy10ZXN0LmNsb3VkZW5kcG9pbnRzYXBpcy5jb20iLCJpYXQiOjE0\"\n    \"NjE3NzkzMjEsImV4cCI6MjQ2MTc4MjkyMX0.\"\n    \"YVL4imxp7jS0RdvQhz7zflaqQzX7Q7TxVGZF9iHy9cxZKnB0wxGgXSb7jl_\"\n    \"KZ2tVCXvQLvErQAxrADDHUOLpXGbgdImF1UJz0YPQGffiyYPvXch2207czH9erKRNdMSxDCHrc\"\n    \"976Rvb9VTO9JFCTTbRwcGgBWz4H-gO55oCbErJCchyXdjLiMPiww-otw8n4tKqcNZhp_\"\n    \"xNDxkRExbk0oQH04epoIvmgmh6snAF06bi652Ag6Z4E842017DIZdaoy3VySbBsDMpZU2YLMil\"\n    \"fLJYUe5b64D6YvAfVAGgB01s7UJJb1b9KXoash5_nvM6xG0syr9URGF-kbqbWVccclA\";\n\n// kTokenHttpSlashAud is the same as kToken except that \"aud\" is\n// \"\"http://endpoints-test.cloudendpointsapis.com/\".\nconst char kTokenHttpSlashAud[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImIzMzE5YTE0NzUxNGRmN2VlNWU0Ym\"\n    \"NkZWU1MTM1MGNjODkwY2M4OWUifQ.\"\n    \"eyJpc3MiOiJodHRwczovL2lzc3VlcjEuY29tIiwic3ViIjoiZW5kLXVzZXItaWQiLCJhdWQiOi\"\n    \"JodHRwczovL2VuZHBvaW50cy10ZXN0LmNsb3VkZW5kcG9pbnRzYXBpcy5jb20vIiwiaWF0Ijox\"\n    \"NDYxNzc5MzIxLCJleHAiOjI0NjE3ODI5MjF9.OPN_7kPW2XR2qDNOB-\"\n    \"RNL1YLBTqJagbK7O2aieEr8VRWpUDR-BcY4LgbrVTY9kRvV1pb_T_\"\n    \"lCxX6tLIkKqC4QOZ1NuOVFhL1yAAjCI8oZB30m43JE8I0m6aEqjzelYcMBJFKp2Wfk16Hj-\"\n    \"Ain797f0u1F1tYJiat67bCfaPFJwWBsHHvyPbJ7NnxFvRYN6F1b8ddT9qAbELxj4fsj1F9rE0O\"\n    \"dmcp0lLhUa2OYrpyyipD5hv0eZIj4Yxlt962Qb6ZhewJULKULueIsWFXq3QZ-FPHXO8-B-\"\n    \"ZBDv5_INzDpTaUK0htgVMMvcbqCcr2DdAlloaZXUnnEINy-d57SBsw1w\";\n\n// kTokenWithNbf is the same as kToken but has an additional \"nbf\" claim set to\n// 2461782921.\nconst char kTokenWithNbf[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImIzMzE5YTE0NzUxNGRmN2VlNWU0Ym\"\n    \"NkZWU1MTM1MGNjODkwY2M4OWUifQ.eyJpc3MiOiJodHRwczovL2lzc3VlcjEuY29tIiwic3ViI\"\n    \"joiZW5kLXVzZXItaWQiLCJhdWQiOiJlbmRwb2ludHMtdGVzdHMuY2xvdWRlbmRwb2ludHNhcGl\"\n    \"zLmNvbSIsImlhdCI6MTQ2MTc3OTMyMSwiZXhwIjoyNDYxNzgyOTIxLCJuYmYiOjI0NjE3ODI5M\"\n    \"jF9.eG8k_YeXPrmzkpu88PvvL_sP2FiG_VVsqG6zMxYleBKytGS1cUELVQzzlYNWeUh_w3q6EV\"\n    \"r_VeyrhbeUtQEsiDbeqWrz8fSaeUvgg0q1ndMo30YZxGx7gnFq5PKsDyyd_gi20J0P40y5ig5K\"\n    \"g4hXKlxpdJkUxwljmzkVvvy5N69EGvfIap474hHGKa1rpMZC2hfxAP0damJBShyGkr9qCnmBKn\"\n    \"5X-tA-XrqQjByzcdwu8D9jZSAdXsue285glUwPCpAYlRbrtrlhxHPS2pR2malTcR1PNXYEQD2G\"\n    \"x7n57Rg31-DuEoZAqWT5Tsr-cY8rn0cALm0AkFPyyC4OwI0O7w\";\n\nconst char kOpenIdContent[] = \"{\\\"jwks_uri\\\": \\\"https://issuer1.com/pubkey\\\"}\";\n\nconst char kPubkey[] =\n    \"{\\\"keys\\\": [{\\\"kty\\\": \\\"RSA\\\",\\\"alg\\\": \\\"RS256\\\",\\\"use\\\": \"\n    \"\\\"sig\\\",\\\"kid\\\": \\\"62a93512c9ee4c7f8067b5a216dade2763d32a47\\\",\\\"n\\\": \"\n    \"\\\"0YWnm_eplO9BFtXszMRQNL5UtZ8HJdTH2jK7vjs4XdLkPW7YBkkm_\"\n    \"2xNgcaVpkW0VT2l4mU3KftR-6s3Oa5Rnz5BrWEUkCTVVolR7VYksfqIB2I_\"\n    \"x5yZHdOiomMTcm3DheUUCgbJRv5OKRnNqszA4xHn3tA3Ry8VO3X7BgKZYAUh9fyZTFLlkeAh0-\"\n    \"bLK5zvqCmKW5QgDIXSxUTJxPjZCgfx1vmAfGqaJb-\"\n    \"nvmrORXQ6L284c73DUL7mnt6wj3H6tVqPKA27j56N0TB1Hfx4ja6Slr8S4EB3F1luYhATa1PKU\"\n    \"SH8mYDW11HolzZmTQpRoLV8ZoHbHEaTfqX_aYahIw\\\",\\\"e\\\": \\\"AQAB\\\"},{\\\"kty\\\": \"\n    \"\\\"RSA\\\",\\\"alg\\\": \\\"RS256\\\",\\\"use\\\": \\\"sig\\\",\\\"kid\\\": \"\n    \"\\\"b3319a147514df7ee5e4bcdee51350cc890cc89e\\\",\\\"n\\\": \"\n    \"\\\"qDi7Tx4DhNvPQsl1ofxxc2ePQFcs-L0mXYo6TGS64CY_\"\n    \"2WmOtvYlcLNZjhuddZVV2X88m0MfwaSA16wE-\"\n    \"RiKM9hqo5EY8BPXj57CMiYAyiHuQPp1yayjMgoE1P2jvp4eqF-\"\n    \"BTillGJt5W5RuXti9uqfMtCQdagB8EC3MNRuU_KdeLgBy3lS3oo4LOYd-\"\n    \"74kRBVZbk2wnmmb7IhP9OoLc1-7-9qU1uhpDxmE6JwBau0mDSwMnYDS4G_ML17dC-\"\n    \"ZDtLd1i24STUw39KH0pcSdfFbL2NtEZdNeam1DDdk0iUtJSPZliUHJBI_pj8M-2Mn_\"\n    \"oA8jBuI8YKwBqYkZCN1I95Q\\\",\\\"e\\\": \\\"AQAB\\\"}]}\";\n\nconst char kIssuer1OpenIdUrl[] =\n    \"https://issuer1.com/.well-known/openid-configuration\";\n\nconst char kIssuer1PubkeyUrl[] = \"https://issuer1.com/pubkey\";\nconst char kIssuer2PubkeyUrl[] = \"https://issuer2.com/pubkey\";\n\nconst char kOpenIdFailUrl[] =\n    \"http://openid_fail/.well-known/openid-configuration\";\n\n// The header key to send endpoint api user info.\nconst char kEndpointApiUserInfo[] = \"X-Endpoint-API-UserInfo\";\n\n// Base64 encoded string of\n// {\n//    \"issuer\": \"https://issuer1.com\",\n//    \"id\": \"end-user-id\"\n// }\nconst char kUserInfo_kSub_kIss[] =\n    \"eyJjbGFpbXMiOiJ7XCJpc3NcIjpcImh0dHBzOi8vaXNzdWVyMS5jb21cIixcInN1YlwiOlwiZW\"\n    \"5kLXVzZXItaWRcIixcImF1ZFwiOlwiZW5kcG9pbnRzLXRlc3QuY2xvdWRlbmRwb2ludHNhcGlz\"\n    \"LmNvbVwiLFwiaWF0XCI6MTQ2MTc3OTMyMSxcImV4cFwiOjI0NjE3ODI5MjF9IiwiaXNzdWVyIj\"\n    \"oiaHR0cHM6Ly9pc3N1ZXIxLmNvbSIsImlkIjoiZW5kLXVzZXItaWQiLCJhdWRpZW5jZXMiOlsi\"\n    \"ZW5kcG9pbnRzLXRlc3QuY2xvdWRlbmRwb2ludHNhcGlzLmNvbSJdfQ==\";\n\n// Base64 encoded string of\n// {\n//    \"issuer\": \"https://issuer1.com\",\n//    \"id\": \"another-user-id\"\n// }\nconst char kUserInfo_kSub2_kIss[] =\n    \"eyJjbGFpbXMiOiJ7XCJpc3NcIjpcImh0dHBzOi8vaXNzdWVyMS5jb21cIixcInN1YlwiOlwiZW\"\n    \"5kLXVzZXItaWRcIixcImF1ZFwiOlwiZW5kcG9pbnRzLXRlc3QuY2xvdWRlbmRwb2ludHNhcGlz\"\n    \"LmNvbVwiLFwiaWF0XCI6MTQ2MTc3OTMyMSxcImV4cFwiOjI0NjE3ODI5MjF9IiwiaXNzdWVyIj\"\n    \"oiaHR0cHM6Ly9pc3N1ZXIxLmNvbSIsImlkIjoiZW5kLXVzZXItaWQiLCJhdWRpZW5jZXMiOlsi\"\n    \"ZW5kcG9pbnRzLXRlc3QuY2xvdWRlbmRwb2ludHNhcGlzLmNvbSJdfQ==\";\n\nconst char kUserInfo_kSub2_kIss2[] =\n    \"eyJjbGFpbXMiOiJ7XCJpc3NcIjpcImh0dHBzOi8vaXNzdWVyMS5jb21cIixcInN1YlwiOlwiYW\"\n    \"5vdGhlci11c2VyLWlkXCIsXCJhdWRcIjpcImVuZHBvaW50cy10ZXN0LmNsb3VkZW5kcG9pbnRz\"\n    \"YXBpcy5jb21cIixcImlhdFwiOjE0NjE3NzkzMjEsXCJleHBcIjoyNDYxNzgyOTIxfSIsImlzc3\"\n    \"VlciI6Imh0dHBzOi8vaXNzdWVyMS5jb20iLCJpZCI6ImFub3RoZXItdXNlci1pZCIsImF1ZGll\"\n    \"bmNlcyI6WyJlbmRwb2ludHMtdGVzdC5jbG91ZGVuZHBvaW50c2FwaXMuY29tIl19\";\n\n// Base64 encoded string of\n// {\n//    \"issuer\": \"https://issuer2.com\",\n//    \"id\": \"end-user-id\"\n// }\nconst char kUserInfo_kSub_kIss2[] =\n    \"eyJjbGFpbXMiOiJ7XCJpc3NcIjpcImh0dHBzOi8vaXNzdWVyMi5jb21cIixcInN1YlwiOlwiZW\"\n    \"5kLXVzZXItaWRcIixcImF1ZFwiOlwiZW5kcG9pbnRzLXRlc3QuY2xvdWRlbmRwb2ludHNhcGlz\"\n    \"LmNvbVwiLFwiaWF0XCI6MTQ2MTc3OTMyMSxcImV4cFwiOjI0NjE3ODI5MjF9IiwiaXNzdWVyIj\"\n    \"oiaHR0cHM6Ly9pc3N1ZXIyLmNvbSIsImlkIjoiZW5kLXVzZXItaWQiLCJhdWRpZW5jZXMiOlsi\"\n    \"ZW5kcG9pbnRzLXRlc3QuY2xvdWRlbmRwb2ludHNhcGlzLmNvbSJdfQ==\";\n\nconst char kUserInfo_kSub2_kIss3[] =\n    \"eyJjbGFpbXMiOiJ7XCJpc3NcIjpcImh0dHBzOi8vaXNzdWVyMS5jb21cIixcInN1YlwiOlwiZW\"\n    \"5kLXVzZXItaWRcIixcImF1ZFwiOlwiaHR0cHM6Ly9lbmRwb2ludHMtdGVzdC5jbG91ZGVuZHBv\"\n    \"aW50c2FwaXMuY29tXCIsXCJpYXRcIjoxNDYxNzc5MzIxLFwiZXhwXCI6MjQ2MTc4MjkyMX0iLC\"\n    \"Jpc3N1ZXIiOiJodHRwczovL2lzc3VlcjEuY29tIiwiaWQiOiJlbmQtdXNlci1pZCIsImF1ZGll\"\n    \"bmNlcyI6WyJodHRwczovL2VuZHBvaW50cy10ZXN0LmNsb3VkZW5kcG9pbnRzYXBpcy5jb20iXX\"\n    \"0=\";\n\nconst char kUserInfo_kSub2_kIss4[] =\n    \"eyJjbGFpbXMiOiJ7XCJpc3NcIjpcImh0dHBzOi8vaXNzdWVyMS5jb21cIixcInN1YlwiOlwiZW\"\n    \"5kLXVzZXItaWRcIixcImF1ZFwiOlwiaHR0cHM6Ly9lbmRwb2ludHMtdGVzdC5jbG91ZGVuZHBv\"\n    \"aW50c2FwaXMuY29tL1wiLFwiaWF0XCI6MTQ2MTc3OTMyMSxcImV4cFwiOjI0NjE3ODI5MjF9Ii\"\n    \"wiaXNzdWVyIjoiaHR0cHM6Ly9pc3N1ZXIxLmNvbSIsImlkIjoiZW5kLXVzZXItaWQiLCJhdWRp\"\n    \"ZW5jZXMiOlsiaHR0cHM6Ly9lbmRwb2ludHMtdGVzdC5jbG91ZGVuZHBvaW50c2FwaXMuY29tLy\"\n    \"JdfQ==\";\n\nconst char kUserInfo_kSub2_kIss5[] =\n    \"eyJjbGFpbXMiOiJ7XCJpc3NcIjpcImh0dHBzOi8vaXNzdWVyMS5jb21cIixcInN1YlwiOlwiZW\"\n    \"5kLXVzZXItaWRcIixcImF1ZFwiOlwiaHR0cHM6Ly9lbmRwb2ludHMtdGVzdC5jbG91ZGVuZHBv\"\n    \"aW50c2FwaXMuY29tXCIsXCJpYXRcIjoxNDYxNzc5MzIxLFwiZXhwXCI6MjQ2MTc4MjkyMX0iLC\"\n    \"Jpc3N1ZXIiOiJodHRwczovL2lzc3VlcjEuY29tIiwiaWQiOiJlbmQtdXNlci1pZCIsImF1ZGll\"\n    \"bmNlcyI6WyJodHRwczovL2VuZHBvaW50cy10ZXN0LmNsb3VkZW5kcG9pbnRzYXBpcy5jb20iXX\"\n    \"0=\";\n\nconst char kUserInfo_kSub2_kIss6[] =\n    \"eyJjbGFpbXMiOiJ7XCJpc3NcIjpcImh0dHBzOi8vaXNzdWVyMS5jb21cIixcInN1YlwiOlwiZW\"\n    \"5kLXVzZXItaWRcIixcImF1ZFwiOlwiaHR0cHM6Ly9lbmRwb2ludHMtdGVzdC5jbG91ZGVuZHBv\"\n    \"aW50c2FwaXMuY29tL1wiLFwiaWF0XCI6MTQ2MTc3OTMyMSxcImV4cFwiOjI0NjE3ODI5MjF9Ii\"\n    \"wiaXNzdWVyIjoiaHR0cHM6Ly9pc3N1ZXIxLmNvbSIsImlkIjoiZW5kLXVzZXItaWQiLCJhdWRp\"\n    \"ZW5jZXMiOlsiaHR0cHM6Ly9lbmRwb2ludHMtdGVzdC5jbG91ZGVuZHBvaW50c2FwaXMuY29tLy\"\n    \"JdfQ==\";\n\nclass CheckAuthTest : public ::testing::Test {\n public:\n  void SetUp() {\n    std::unique_ptr<MockApiManagerEnvironment> env(\n        new ::testing::NiceMock<MockApiManagerEnvironment>());\n    // save the raw pointer of env before calling std::move(env).\n    raw_env_ = env.get();\n\n    std::unique_ptr<Config> config = Config::Create(raw_env_, kServiceConfig);\n    ASSERT_NE(config.get(), nullptr);\n\n    service_context_ = std::make_shared<context::ServiceContext>(\n        std::move(env), \"\", std::move(config));\n    ASSERT_NE(service_context_.get(), nullptr);\n\n    std::unique_ptr<MockRequest> request(\n        new ::testing::NiceMock<MockRequest>());\n    // save the raw pointer of request before calling std::move(request).\n    raw_request_ = request.get();\n\n    EXPECT_CALL(*raw_request_, GetRequestHTTPMethod())\n        .WillOnce(Return(std::string(\"GET\")));\n    EXPECT_CALL(*raw_request_, GetUnparsedRequestPath())\n        .WillOnce(Return(std::string(\"/ListShelves\")));\n    EXPECT_CALL(*raw_request_, FindQuery(_, _))\n        .WillOnce(Invoke([](const std::string &, std::string *apikey) {\n          *apikey = \"apikey\";\n          return true;\n        }));\n    EXPECT_CALL(*raw_request_, FindHeader(\"X-HTTP-Method-Override\", _))\n        .Times(1);\n    EXPECT_CALL(*raw_request_, FindHeader(\"referer\", _))\n        .WillOnce(Invoke([](const std::string &, std::string *http_referer) {\n          *http_referer = \"\";\n          return true;\n        }));\n    EXPECT_CALL(*raw_request_, FindHeader(\"grpc-trace-bin\", _))\n        .WillOnce(Invoke([](const std::string &, std::string *trace_context) {\n          *trace_context = \"\";\n          return false;\n        }));\n    EXPECT_CALL(*raw_request_, FindHeader(\"X-Cloud-Trace-Context\", _))\n        .WillOnce(Invoke([](const std::string &, std::string *trace_context) {\n          *trace_context = \"\";\n          return true;\n        }));\n\n    context_ = std::make_shared<context::RequestContext>(service_context_,\n                                                         std::move(request));\n    EXPECT_TRUE(Mock::VerifyAndClearExpectations(raw_request_));\n  }\n\n  void TestValidToken(const std::string &auth_token,\n                      const std::string &user_info);\n\n  MockApiManagerEnvironment *raw_env_;\n  std::shared_ptr<context::ServiceContext> service_context_;\n  MockRequest *raw_request_;\n  std::shared_ptr<context::RequestContext> context_;\n};\n\nvoid CheckAuthTest::TestValidToken(const std::string &auth_token,\n                                   const std::string &user_info) {\n  EXPECT_CALL(*raw_request_, FindHeader(\"x-goog-iap-jwt-assertion\", _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = \"\";\n        return false;\n      }));\n  EXPECT_CALL(*raw_request_, FindHeader(kAuthHeader, _))\n      .WillOnce(Invoke([auth_token](const std::string &, std::string *token) {\n        *token = std::string(kBearer) + auth_token;\n        return true;\n      }));\n  EXPECT_CALL(*raw_request_, SetAuthToken(auth_token)).Times(1);\n  EXPECT_CALL(*raw_env_, DoRunHTTPRequest(_))\n      .Times(2)\n      .WillOnce(Invoke([](HTTPRequest *req) {\n        EXPECT_EQ(req->url(), kIssuer1OpenIdUrl);\n        std::string body(kOpenIdContent);\n        std::map<std::string, std::string> empty;\n        req->OnComplete(Status::OK, std::move(empty), std::move(body));\n      }))\n      .WillOnce(Invoke([](HTTPRequest *req) {\n        EXPECT_EQ(req->url(), kIssuer1PubkeyUrl);\n        std::string body(kPubkey);\n        std::map<std::string, std::string> empty;\n        req->OnComplete(Status::OK, std::move(empty), std::move(body));\n      }));\n  std::cout << \"need be replaced: \" << user_info << std::endl;\n  EXPECT_CALL(*raw_request_,\n              AddHeaderToBackend(kEndpointApiUserInfo, user_info, false))\n      .WillOnce(Return(utils::Status::OK));\n\n  CheckAuth(context_, [](Status status) { ASSERT_TRUE(status.ok()); });\n}\n\n// Positive test.\n// Step 1: Check auth workflow that involves openID discovery and fetching\n//         public key.\n// Step 2. Use the same auth token, which should be cached in JWT cache.\n// Step 3. Use a different auth token signed by the same issuer. This time,\n//         token is not cached, but key is cached.\nTEST_F(CheckAuthTest, TestOKAuth) {\n  // Step 1. Check auth requires open ID discovery and fetching public key.\n  TestValidToken(kToken, kUserInfo_kSub2_kIss);\n\n  EXPECT_TRUE(Mock::VerifyAndClearExpectations(raw_request_));\n  EXPECT_TRUE(Mock::VerifyAndClearExpectations(raw_env_));\n\n  // Step 2. Check auth with the same auth token. This time the token is cached.\n  EXPECT_CALL(*raw_request_, FindHeader(\"x-goog-iap-jwt-assertion\", _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = \"\";\n        return false;\n      }));\n  EXPECT_CALL(*raw_request_, FindHeader(kAuthHeader, _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = std::string(kBearer) + std::string(kToken);\n        return true;\n      }));\n  EXPECT_CALL(*raw_request_, SetAuthToken(kToken)).Times(1);\n  EXPECT_CALL(*raw_env_, DoRunHTTPRequest(_)).Times(0);\n  EXPECT_CALL(*raw_request_, AddHeaderToBackend(kEndpointApiUserInfo,\n                                                kUserInfo_kSub_kIss, false))\n      .WillOnce(Return(utils::Status::OK));\n\n  CheckAuth(context_, [](Status status) { ASSERT_TRUE(status.ok()); });\n\n  EXPECT_TRUE(Mock::VerifyAndClearExpectations(raw_request_));\n  EXPECT_TRUE(Mock::VerifyAndClearExpectations(raw_env_));\n\n  // Step 3. Check auth with a different token signed by the same issuer.\n  // In this case, the token is not in the cache, but key is cached.\n  EXPECT_CALL(*raw_request_, FindHeader(\"x-goog-iap-jwt-assertion\", _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = \"\";\n        return false;\n      }));\n  EXPECT_CALL(*raw_request_, FindHeader(kAuthHeader, _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = std::string(kToken2);\n        return true;\n      }));\n  EXPECT_CALL(*raw_request_, SetAuthToken(kToken2)).Times(1);\n  EXPECT_CALL(*raw_env_, DoRunHTTPRequest(_)).Times(0);\n  EXPECT_CALL(*raw_request_, AddHeaderToBackend(kEndpointApiUserInfo,\n                                                kUserInfo_kSub2_kIss2, false))\n      .WillOnce(Return(utils::Status::OK));\n\n  CheckAuth(context_, [](Status status) { ASSERT_TRUE(status.ok()); });\n}\n\n// Negative test: Test the case that openID discovery failed.\n// Step 1. Try to fetch key URI via OpenID discovery but failed.\n// Step 2. Use a different token signed by the same issuer, no HTTP request\n//         is sent this time because the failure result was cached.\nTEST_F(CheckAuthTest, TestOpenIdFailed) {\n  // Step 1. Try to fetch key URI via OpenID discovery but failed.\n  // Use FindQuery to get auth token.\n  EXPECT_CALL(*raw_request_, FindHeader(\"x-goog-iap-jwt-assertion\", _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = \"\";\n        return false;\n      }));\n  EXPECT_CALL(*raw_request_, FindHeader(kAuthHeader, _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = std::string();\n        return false;\n      }));\n  EXPECT_CALL(*raw_request_, FindQuery(kAccessTokenName, _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = std::string(kTokenOpenIdFail);\n        return true;\n      }));\n  EXPECT_CALL(*raw_request_, SetAuthToken(kTokenOpenIdFail)).Times(1);\n  EXPECT_CALL(*raw_env_, DoRunHTTPRequest(_))\n      .WillOnce(Invoke([](HTTPRequest *req) {\n        EXPECT_EQ(req->url(), kOpenIdFailUrl);\n        std::string body(\"\");\n        std::map<std::string, std::string> empty;\n        req->OnComplete(Status::OK, std::move(empty), std::move(body));\n      }));\n\n  CheckAuth(context_, [](Status status) {\n    ASSERT_EQ(status.code(), Code::UNAUTHENTICATED);\n    ASSERT_EQ(status.message(),\n              \"JWT validation failed: Unable to parse \"\n              \"URI of the key via OpenID discovery\");\n  });\n\n  EXPECT_TRUE(Mock::VerifyAndClearExpectations(raw_request_));\n  EXPECT_TRUE(Mock::VerifyAndClearExpectations(raw_env_));\n\n  // Step 2. Use a different token signed by the same issuer, no HTTP request\n  //         is sent this time because the failure result was cached.\n  EXPECT_CALL(*raw_request_, FindHeader(\"x-goog-iap-jwt-assertion\", _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = \"\";\n        return false;\n      }));\n  EXPECT_CALL(*raw_request_, FindHeader(kAuthHeader, _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = std::string(kBearer) + std::string(kTokenOpenIdFail2);\n        return true;\n      }));\n  EXPECT_CALL(*raw_request_, SetAuthToken(kTokenOpenIdFail2)).Times(1);\n  EXPECT_CALL(*raw_env_, DoRunHTTPRequest(_)).Times(0);\n\n  CheckAuth(context_, [](Status status) {\n    ASSERT_EQ(status.code(), Code::UNAUTHENTICATED);\n    ASSERT_EQ(status.message(),\n              \"JWT validation failed: \"\n              \"Cannot determine the URI of the key\");\n  });\n}\n\n// jwks_uri is already specified in service config. Hence, no need to\n// do openID discovery.\nTEST_F(CheckAuthTest, TestNoOpenId) {\n  EXPECT_CALL(*raw_request_, FindHeader(\"x-goog-iap-jwt-assertion\", _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = \"\";\n        return false;\n      }));\n  EXPECT_CALL(*raw_request_, FindHeader(kAuthHeader, _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = std::string(kBearer) + std::string(kTokenIssuer2);\n        return true;\n      }));\n  EXPECT_CALL(*raw_request_, SetAuthToken(kTokenIssuer2)).Times(1);\n  EXPECT_CALL(*raw_env_, DoRunHTTPRequest(_))\n      .WillOnce(Invoke([](HTTPRequest *req) {\n        EXPECT_EQ(req->url(), kIssuer2PubkeyUrl);\n        std::string body(kPubkey);\n        std::map<std::string, std::string> empty;\n        req->OnComplete(Status::OK, std::move(empty), std::move(body));\n      }));\n  EXPECT_CALL(*raw_request_, AddHeaderToBackend(kEndpointApiUserInfo,\n                                                kUserInfo_kSub_kIss2, false))\n      .WillOnce(Return(utils::Status::OK));\n\n  CheckAuth(context_, [](Status status) { ASSERT_TRUE(status.ok()); });\n}\n\n// Negative test: invalid token and expired token.\nTEST_F(CheckAuthTest, TestInvalidToken) {\n  EXPECT_CALL(*raw_request_, FindHeader(\"x-goog-iap-jwt-assertion\", _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = \"\";\n        return false;\n      }));\n  // Invalid token.\n  EXPECT_CALL(*raw_request_, FindHeader(kAuthHeader, _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = \"bad_token\";\n        return true;\n      }));\n\n  CheckAuth(context_, [](Status status) {\n    ASSERT_EQ(status.code(), Code::UNAUTHENTICATED);\n    ASSERT_EQ(status.message(),\n              \"JWT validation failed: \"\n              \"Bad JWT format: should have 2 dots\");\n  });\n\n  EXPECT_TRUE(Mock::VerifyAndClearExpectations(raw_request_));\n\n  EXPECT_CALL(*raw_request_, FindHeader(\"x-goog-iap-jwt-assertion\", _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = \"\";\n        return false;\n      }));\n  // Expired token.\n  EXPECT_CALL(*raw_request_, FindHeader(kAuthHeader, _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = std::string(kBearer) + std::string(kTokenExpired);\n        return true;\n      }));\n  EXPECT_CALL(*raw_request_, SetAuthToken(kTokenExpired)).Times(1);\n  EXPECT_CALL(*raw_env_, DoRunHTTPRequest(_)).Times(0);\n\n  CheckAuth(context_, [](Status status) {\n    ASSERT_EQ(status.code(), Code::UNAUTHENTICATED);\n    ASSERT_EQ(status.message(),\n              \"JWT validation failed: TIME_CONSTRAINT_FAILURE\");\n  });\n\n  EXPECT_TRUE(Mock::VerifyAndClearExpectations(raw_request_));\n  EXPECT_TRUE(Mock::VerifyAndClearExpectations(raw_env_));\n\n  EXPECT_CALL(*raw_request_, FindHeader(\"x-goog-iap-jwt-assertion\", _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = \"\";\n        return false;\n      }));\n  // Token that is not ready to be used (i.e., current time is less than the\n  // \"nbf\" claim).\n  EXPECT_CALL(*raw_request_, FindHeader(kAuthHeader, _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = std::string(kBearer) + std::string(kTokenWithNbf);\n        return true;\n      }));\n  EXPECT_CALL(*raw_request_, SetAuthToken(kTokenWithNbf)).Times(1);\n  EXPECT_CALL(*raw_env_, DoRunHTTPRequest(_)).Times(0);\n\n  CheckAuth(context_, [](Status status) {\n    ASSERT_EQ(status.code(), Code::UNAUTHENTICATED);\n    ASSERT_EQ(status.message(),\n              \"JWT validation failed: TIME_CONSTRAINT_FAILURE\");\n  });\n}\n\n// Negative test: bad audience\nTEST_F(CheckAuthTest, TestBadAudience) {\n  EXPECT_CALL(*raw_request_, FindHeader(\"x-goog-iap-jwt-assertion\", _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = \"\";\n        return false;\n      }));\n  EXPECT_CALL(*raw_request_, FindHeader(kAuthHeader, _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = std::string(kBearer) + std::string(kTokenBadAud);\n        return true;\n      }));\n  EXPECT_CALL(*raw_request_, SetAuthToken(kTokenBadAud)).Times(1);\n  EXPECT_CALL(*raw_env_, DoRunHTTPRequest(_)).Times(0);\n\n  CheckAuth(context_, [](Status status) {\n    ASSERT_EQ(status.code(), Code::PERMISSION_DENIED);\n    ASSERT_EQ(status.message(), \"JWT validation failed: Audience not allowed\");\n  });\n}\n\n// Positive test: audience is service name with https prefix.\nTEST_F(CheckAuthTest, TestHttpsAudience) {\n  TestValidToken(kTokenHttpsAud, kUserInfo_kSub2_kIss3);\n}\n\n// Positive test: audience is service name with https prefix and a trailing\n// slash.\nTEST_F(CheckAuthTest, TestHttpsSlashAudience) {\n  TestValidToken(kTokenHttpsSlashAud, kUserInfo_kSub2_kIss4);\n}\n\n// Positive test: audience is service name with http prefix.\nTEST_F(CheckAuthTest, TestHttpAudience) {\n  TestValidToken(kTokenHttpAud, kUserInfo_kSub2_kIss5);\n}\n\n// Positive test: audience is service name with http prefix and a trailing\n// slash.\nTEST_F(CheckAuthTest, TestHttpSlashAudience) {\n  TestValidToken(kTokenHttpSlashAud, kUserInfo_kSub2_kIss6);\n}\n\n}  // namespace\n\n}  // namespace api_manager\n}  // namespace google\n", "// Copyright (C) Extensible Service Proxy Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////////\n// includes should be ordered. This seems like a bug in clang-format?\n#include \"src/api_manager/check_service_control.h\"\n\n#include \"google/protobuf/stubs/status.h\"\n#include \"src/api_manager/cloud_trace/cloud_trace.h\"\n\nusing ::google::api_manager::utils::Status;\nusing ::google::protobuf::util::error::Code;\n\nnamespace google {\nnamespace api_manager {\n\nnamespace {\n\nconst std::string kConsumerProjecId = \"X-Endpoint-API-Project-ID\";\n}\n\nvoid CheckServiceControl(std::shared_ptr<context::RequestContext> context,\n                         std::function<void(Status status)> continuation) {\n  std::shared_ptr<cloud_trace::CloudTraceSpan> trace_span(\n      CreateSpan(context->cloud_trace(), \"CheckServiceControl\"));\n  // If the method is not configured from the service config.\n  // or if not need to check service control, skip it.\n  if (!context->method()) {\n    if (context->GetRequestHTTPMethodWithOverride() == \"OPTIONS\") {\n      TRACE(trace_span) << \"OPTIONS request is rejected\";\n      continuation(Status(Code::PERMISSION_DENIED,\n                          \"The service does not allow CORS traffic.\",\n                          Status::SERVICE_CONTROL));\n    } else {\n      TRACE(trace_span) << \"Method is not configured in the service config\";\n      continuation(Status(Code::NOT_FOUND, \"Method does not exist.\",\n                          Status::SERVICE_CONTROL));\n    }\n    return;\n  } else if (!context->service_context()->service_control() ||\n             context->method()->skip_service_control()) {\n    TRACE(trace_span) << \"Service control check is not needed\";\n    continuation(Status::OK);\n    return;\n  }\n\n  if (context->api_key().empty()) {\n    if (context->method()->allow_unregistered_calls()) {\n      // Not need to call Check.\n      TRACE(trace_span) << \"Service control check is not needed\";\n      continuation(Status::OK);\n      return;\n    }\n\n    TRACE(trace_span) << \"Failed at checking caller identity.\";\n    continuation(\n        Status(Code::UNAUTHENTICATED,\n               \"Method doesn't allow unregistered callers (callers without \"\n               \"established identity). Please use API Key or other form of \"\n               \"API consumer identity to call this API.\",\n               Status::SERVICE_CONTROL));\n    return;\n  }\n\n  service_control::CheckRequestInfo info;\n  context->FillCheckRequestInfo(&info);\n  context->service_context()->service_control()->Check(\n      info, trace_span.get(),\n      [context, continuation, trace_span](\n          Status status, const service_control::CheckResponseInfo &info) {\n        TRACE(trace_span) << \"Check service control request returned with \"\n                          << \"status \" << status.ToString();\n        // info is valid regardless status.\n        context->set_check_response_info(info);\n\n        // update consumer_project_id to service context\n        if (!info.consumer_project_id.empty()) {\n          context->request()->AddHeaderToBackend(\n              kConsumerProjecId, info.consumer_project_id, false);\n        }\n\n        continuation(status);\n      });\n}\n\n}  // namespace api_manager\n}  // namespace google\n", "// Copyright (C) Extensible Service Proxy Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n#include <iostream>\n#include <map>\n#include <memory>\n#include <string>\n\n#include \"gmock/gmock.h\"\n#include \"gtest/gtest.h\"\n\n#include \"src/api_manager/context/request_context.h\"\n#include \"src/api_manager/context/service_context.h\"\n#include \"src/api_manager/mock_api_manager_environment.h\"\n//#include \"src/api_manager/mock_request.h\"\n//#include \"src/api_manager/api_manager_impl.h\"\n#include \"include/api_manager/request.h\"\n\nusing ::testing::_;\nusing ::testing::Invoke;\nusing ::testing::Mock;\nusing ::testing::Return;\n\nusing ::google::api_manager::utils::Status;\n\nnamespace google {\nnamespace api_manager {\nnamespace context {\n\nnamespace {\n\nconst char kServiceConfig1[] =\n    R\"(\n{\n  \"name\": \"bookstore.test.appspot.com\",\n  \"title\": \"Bookstore\",\n  \"http\": {\n    \"rules\": [\n      {\n        \"selector\": \"EchoGetMessage\",\n        \"get\": \"/echo\"\n      }\n    ]\n  },\n  \"usage\": {\n    \"rules\": [\n      {\n        \"selector\": \"EchoGetMessage\",\n        \"allowUnregisteredCalls\": true\n      }\n    ]\n  },\n  \"control\": {\n    \"environment\": \"servicecontrol.googleapis.com\"\n  },\n  \"id\": \"2017-05-01r0\"\n}\n)\";\n\nclass MockApiManagerEnvironment : public ApiManagerEnvInterface {\n public:\n  virtual ~MockApiManagerEnvironment() {}\n\n  void Log(LogLevel level, const char *message) override {\n    // std::cout << __FILE__ << \":\" << __LINE__ << \" \" << message << std::endl;\n  }\n  std::unique_ptr<PeriodicTimer> StartPeriodicTimer(\n      std::chrono::milliseconds interval, std::function<void()> continuation) {\n    return std::unique_ptr<PeriodicTimer>(new MockPeriodicTimer(continuation));\n  }\n\n  void RunHTTPRequest(std::unique_ptr<HTTPRequest> request) override {}\n\n  virtual void RunGRPCRequest(std::unique_ptr<GRPCRequest> request) override {}\n};\n\nclass MockRequest : public Request {\n public:\n  MockRequest(const std::string &client_ip,\n              const std::map<std::string, std::string> &header)\n      : client_ip_(client_ip), header_(header) {}\n\n  virtual ~MockRequest() {}\n\n  bool FindHeader(const std::string &name, std::string *header) override {\n    auto it = header_.find(name);\n    if (it != header_.end()) {\n      header->assign(it->second);\n      return true;\n    }\n\n    return false;\n  }\n\n  std::string GetClientIP() { return client_ip_; }\n\n  std::string GetRequestHTTPMethod() override { return \"GET\"; }\n\n  std::string GetQueryParameters() override { return \"\"; }\n\n  std::string GetUnparsedRequestPath() override { return \"/echo\"; }\n\n  bool FindQuery(const std::string &name, std::string *query) override {\n    return false;\n  }\n\n  MOCK_METHOD3(AddHeaderToBackend,\n               utils::Status(const std::string &, const std::string &, bool));\n  MOCK_METHOD1(SetAuthToken, void(const std::string &));\n  MOCK_METHOD0(GetFrontendProtocol,\n               ::google::api_manager::protocol::Protocol());\n  MOCK_METHOD0(GetBackendProtocol, ::google::api_manager::protocol::Protocol());\n  MOCK_METHOD0(GetRequestPath, std::string());\n  MOCK_METHOD0(GetInsecureCallerID, std::string());\n  MOCK_METHOD0(GetRequestHeaders, std::multimap<std::string, std::string> *());\n  MOCK_METHOD0(GetGrpcRequestBytes, int64_t());\n  MOCK_METHOD0(GetGrpcResponseBytes, int64_t());\n  MOCK_METHOD0(GetGrpcRequestMessageCounts, int64_t());\n  MOCK_METHOD0(GetGrpcResponseMessageCounts, int64_t());\n\n private:\n  const std::string client_ip_;\n  const std::map<std::string, std::string> header_;\n};\n}  // namespace\n\nclass ClientIPExtractionTest : public ::testing::Test {\n protected:\n  ClientIPExtractionTest() : callback_run_count_(0) {}\n\n  void SetUp() {\n    callback_run_count_ = 0;\n    call_history_.clear();\n  }\n\n protected:\n  std::vector<std::string> call_history_;\n  int callback_run_count_;\n};\n\n// Extracts client IP address from the request based on the server configuration\nstd::string ExtractClientIP(std::string serverConfig, std::string remote_ip,\n                            std::map<std::string, std::string> headers) {\n  std::unique_ptr<ApiManagerEnvInterface> env(new MockApiManagerEnvironment());\n\n  std::shared_ptr<context::GlobalContext> global_context(\n      new context::GlobalContext(std::move(env), serverConfig));\n\n  std::unique_ptr<Config> config =\n      Config::Create(global_context->env(), std::string(kServiceConfig1));\n\n  std::shared_ptr<context::ServiceContext> service_context(\n      new context::ServiceContext(global_context, std::move(config)));\n\n  std::unique_ptr<MockRequest> request(new MockRequest(remote_ip, headers));\n\n  RequestContext context(service_context, std::move(request));\n\n  service_control::CheckRequestInfo info;\n\n  context.FillCheckRequestInfo(&info);\n\n  return info.client_ip;\n}\n\nTEST_F(ClientIPExtractionTest, ClientIPAddressNoOverrideTest) {\n  const char kServerConfigWithoutClientIPExperiment[] =\n      R\"(\n  {\n    \"experimental\": {\n      \"disable_log_status\": false\n    }\n  }\n  )\";\n\n  EXPECT_EQ(\"4.4.4.4\",\n            ExtractClientIP(kServerConfigWithoutClientIPExperiment, \"4.4.4.4\",\n                            {{\"X-Forwarded-For\", \"1.1.1.1, 2.2.2.2, 3.3.3.3\"},\n                             {\"apiKey\", \"test-api-key\"}}));\n}\n\nTEST_F(ClientIPExtractionTest, ClientIPAddressOverrideTest) {\n  const char kServerConfigWithClientIPExperimentSecondFromLast[] =\n      R\"(\n  {\n    \"client_ip_extraction_config\": {\n      \"client_ip_header\": \"X-Forwarded-For\",\n      \"client_ip_position\": -2\n    }\n  }\n  )\";\n\n  EXPECT_EQ(\"2.2.2.2\",\n            ExtractClientIP(kServerConfigWithClientIPExperimentSecondFromLast,\n                            \"4.4.4.4\",\n                            {{\"X-Forwarded-For\", \"1.1.1.1, 2.2.2.2, 3.3.3.3\"},\n                             {\"apiKey\", \"test-api-key\"}}));\n}\n\nTEST_F(ClientIPExtractionTest, ClientIPAddressOverrideLastTest) {\n  const char kServerConfigWithClientIPExperimentLast[] =\n      R\"(\n  {\n    \"client_ip_extraction_config\": {\n      \"client_ip_header\": \"X-Forwarded-For\",\n      \"client_ip_position\": -1\n    }\n  }\n  )\";\n\n  EXPECT_EQ(\"3.3.3.3\",\n            ExtractClientIP(kServerConfigWithClientIPExperimentLast, \"4.4.4.4\",\n                            {{\"X-Forwarded-For\", \"1.1.1.1, 2.2.2.2, 3.3.3.3\"},\n                             {\"apiKey\", \"test-api-key\"}}));\n}\n\nTEST_F(ClientIPExtractionTest, ClientIPAddressOverrideOutOfIndexTest) {\n  const char kServerConfigWithClientIPExperimentOutOfIndex[] =\n      R\"(\n  {\n    \"client_ip_extraction_config\": {\n      \"client_ip_header\": \"X-Forwarded-For\",\n      \"client_ip_position\": -5\n    }\n  }\n  )\";\n\n  EXPECT_EQ(\n      \"4.4.4.4\",\n      ExtractClientIP(kServerConfigWithClientIPExperimentOutOfIndex, \"4.4.4.4\",\n                      {{\"X-Forwarded-For\", \"1.1.1.1, 2.2.2.2, 3.3.3.3\"},\n                       {\"apiKey\", \"test-api-key\"}}));\n}\n\nTEST_F(ClientIPExtractionTest, ClientIPAddressOverrideFirstIndexTest) {\n  const char kServerConfigWithClientIPExperimentFirst[] =\n      R\"(\n  {\n    \"client_ip_extraction_config\": {\n      \"client_ip_header\": \"X-Forwarded-For\",\n      \"client_ip_position\": 0\n    }\n  }\n  )\";\n\n  EXPECT_EQ(\"1.1.1.1\",\n            ExtractClientIP(kServerConfigWithClientIPExperimentFirst, \"4.4.4.4\",\n                            {{\"X-Forwarded-For\", \"1.1.1.1, 2.2.2.2, 3.3.3.3\"},\n                             {\"apiKey\", \"test-api-key\"}}));\n}\n\nTEST_F(ClientIPExtractionTest, ClientIPAddressOverrideSecondIndexTest) {\n  const char kServerConfigWithClientIPExperimentSecond[] =\n      R\"(\n  {\n    \"client_ip_extraction_config\": {\n      \"client_ip_header\": \"X-Forwarded-For\",\n      \"client_ip_position\": 1\n    }\n  }\n  )\";\n\n  EXPECT_EQ(\"2.2.2.2\", ExtractClientIP(\n                           kServerConfigWithClientIPExperimentSecond, \"4.4.4.4\",\n                           {{\"X-Forwarded-For\", \"1.1.1.1, 2.2.2.2, 3.3.3.3\"},\n                            {\"apiKey\", \"test-api-key\"}}));\n}\n\n}  // namespace context\n}  // namespace api_manager\n}  // namespace google\n", "// Copyright (C) Extensible Service Proxy Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n\n#include \"src/api_manager/context/request_context.h\"\n\n#include <uuid/uuid.h>\n\n#include <numeric>\n#include <sstream>\n#include <vector>\n\n#include \"google/api/backend.pb.h\"\n#include \"src/api_manager/auth/lib/json_util.h\"\n#include \"src/api_manager/utils/str_util.h\"\n\nusing ::google::api_manager::auth::GetPrimitiveFieldValue;\nusing ::google::api_manager::cloud_trace::HeaderType;\nusing ::google::api_manager::utils::Status;\n\nnamespace google {\nnamespace api_manager {\nnamespace context {\n\nnamespace {\n\n// Cloud Trace Context Header\nconst char kCloudTraceContextHeader[] = \"X-Cloud-Trace-Context\";\n// gRPC Trace Context Header\nconst char kGRpcTraceContextHeader[] = \"grpc-trace-bin\";\n\n// Authorization Header\nconst char kAuthorizationHeader[] = \"Authorization\";\nconst char kXForwardedAuthorizationHeader[] = \"X-Forwarded-Authorization\";\n\nconst char kBearerPrefix[] = \"Bearer \";\n\n// HTTP Method Override Header\nconst char kHttpMethodOverrideHeader[] = \"X-HTTP-Method-Override\";\n\n// Log message prefix for a success method.\nconst char kMessage[] = \"Method: \";\n// Log message prefix for an ignored method.\nconst char kIgnoredMessage[] =\n    \"Endpoints management skipped for an unrecognized HTTP call: \";\n// Unknown HTTP verb.\nconst char kUnknownHttpVerb[] = \"<Unknown HTTP Verb>\";\n\n// Service control does not currently support logging with an empty\n// operation name so we use this value until fix is available.\nconst char kUnrecognizedOperation[] = \"<Unknown Operation Name>\";\n\n// Maximum 36 byte string for UUID\nconst int kMaxUUIDBufSize = 40;\n\n// Default api key names\nconst char kDefaultApiKeyQueryName1[] = \"key\";\nconst char kDefaultApiKeyQueryName2[] = \"api_key\";\nconst char kDefaultApiKeyHeaderName[] = \"x-api-key\";\n\n// Delimiter of the IP addresses in the XFF header\nconst char kClientIPHeaderDelimeter = ',';\n\n// Header for android package name, used for api key restriction check.\nconst char kXAndroidPackage[] = \"x-android-package\";\n\n// Header for android certificate fingerprint, used for api key restriction\n// check.\nconst char kXAndroidCert[] = \"x-android-cert\";\n\n// Header for IOS bundle identifier, used for api key restriction check.\nconst char kXIosBundleId[] = \"x-ios-bundle-identifier\";\n\n// Genereates a UUID string\nstd::string GenerateUUID() {\n  char uuid_buf[kMaxUUIDBufSize];\n  uuid_t uuid;\n  uuid_generate(uuid);\n  uuid_unparse(uuid, uuid_buf);\n  return uuid_buf;\n}\n\n}  // namespace\n\nusing context::ServiceContext;\n\nRequestContext::RequestContext(std::shared_ptr<ServiceContext> service_context,\n                               std::unique_ptr<Request> request)\n    : service_context_(service_context),\n      request_(std::move(request)),\n      is_first_report_(true),\n      last_request_bytes_(0),\n      last_response_bytes_(0),\n      api_key_from_query_(false) {\n  start_time_ = std::chrono::system_clock::now();\n  last_report_time_ = std::chrono::steady_clock::now();\n  operation_id_ = GenerateUUID();\n  const std::string &method = GetRequestHTTPMethodWithOverride();\n  const std::string &path = request_->GetUnparsedRequestPath();\n  std::string query_params = request_->GetQueryParameters();\n\n  // In addition to matching the method, service_context_->GetMethodCallInfo()\n  // will extract the variable bindings from the url. We need variable bindings\n  // only when we need to do transcoding. If this turns out to be a performance\n  // problem for non-transcoded calls, we have a couple of options:\n  // 1) Do not extract variable bindings here, and do the method matching again\n  //    with extracting variable bindings when transcoding is needed.\n  // 2) Store all the pieces needed for extracting variable bindings (such as\n  //    http template variables, url path parts) in MethodCallInfo and extract\n  //    variables lazily when needed.\n\n  method_call_ =\n      service_context_->GetMethodCallInfo(method, path, query_params);\n\n  if (method_call_.method_info &&\n      !method_call_.method_info->allow_unregistered_calls()) {\n    ExtractApiKey();\n  }\n  request_->FindHeader(\"referer\", &http_referer_);\n\n  // Enable trace if tracing is not force disabled and the triggering header is\n  // set.\n  if (service_context_->cloud_trace_aggregator()) {\n    std::string trace_context_header;\n    // Default to CLOUD_TRACE_CONTEXT to not change the default behavior.\n    HeaderType header_type = HeaderType::CLOUD_TRACE_CONTEXT;\n    if (request_->FindHeader(kGRpcTraceContextHeader, &trace_context_header)) {\n      // gRPC trace header found, the type of the header should be\n      // GRPC_TRACE_CONTEXT\n      header_type = HeaderType::GRPC_TRACE_CONTEXT;\n    } else {\n      request_->FindHeader(kCloudTraceContextHeader, &trace_context_header);\n    }\n\n    std::string method_name = kUnrecognizedOperation;\n    if (method_call_.method_info) {\n      method_name = method_call_.method_info->selector();\n    }\n    // qualify with the service name\n    method_name = service_context_->service_name() + \"/\" + method_name;\n    cloud_trace_.reset(cloud_trace::CreateCloudTrace(\n        trace_context_header, method_name, header_type,\n        &service_context_->cloud_trace_aggregator()->sampler()));\n  }\n}\n\nstd::string RequestContext::GetRequestHTTPMethodWithOverride() {\n  std::string method;\n\n  if (!request_->FindHeader(kHttpMethodOverrideHeader, &method)) {\n    method = request()->GetRequestHTTPMethod();\n  }\n\n  service_context()->env()->LogDebug(std::string(\"Request method SET TO: \") +\n                                     method);\n\n  return method;\n}\n\nvoid RequestContext::ExtractApiKey() {\n  bool api_key_defined = false;\n  auto url_queries = method()->api_key_url_query_parameters();\n  if (url_queries) {\n    api_key_defined = true;\n    for (const auto &url_query : *url_queries) {\n      if (request_->FindQuery(url_query, &api_key_)) {\n        api_key_from_query_ = true;\n        return;\n      }\n    }\n  }\n\n  auto headers = method()->api_key_http_headers();\n  if (headers) {\n    api_key_defined = true;\n    for (const auto &header : *headers) {\n      if (request_->FindHeader(header, &api_key_)) {\n        return;\n      }\n    }\n  }\n\n  if (!api_key_defined) {\n    // If api_key is not specified for a method,\n    // check \"key\" first, if not, check \"api_key\" in query parameter.\n    if (request_->FindQuery(kDefaultApiKeyQueryName1, &api_key_)) {\n      api_key_from_query_ = true;\n      return;\n    }\n\n    if (request_->FindQuery(kDefaultApiKeyQueryName2, &api_key_)) {\n      api_key_from_query_ = true;\n      return;\n    }\n    request_->FindHeader(kDefaultApiKeyHeaderName, &api_key_);\n  }\n}\n\nvoid RequestContext::SetApiKeyHeader() {\n  request_->AddHeaderToBackend(kDefaultApiKeyHeaderName, api_key_, false);\n}\n\nvoid RequestContext::CompleteCheck(Status status) {\n  // Makes sure set_check_continuation() is called.\n  // Only making sure CompleteCheck() is NOT called twice.\n  GOOGLE_CHECK(check_continuation_);\n\n  auto temp_continuation = check_continuation_;\n  check_continuation_ = nullptr;\n\n  temp_continuation(status);\n}\n\nvoid RequestContext::FillOperationInfo(service_control::OperationInfo *info) {\n  if (method()) {\n    info->operation_name = method()->selector();\n  } else {\n    info->operation_name = kUnrecognizedOperation;\n  }\n  info->operation_id = operation_id_;\n  if (check_response_info_.is_api_key_valid &&\n      check_response_info_.service_is_activated) {\n    info->api_key = api_key_;\n  }\n  info->producer_project_id = service_context()->project_id();\n  info->referer = http_referer_;\n  info->request_start_time = start_time_;\n  info->client_ip = FindClientIPAddress();\n  info->client_host = request_->GetClientHost();\n}\n\nvoid RequestContext::FillLocation(service_control::ReportRequestInfo *info) {\n  info->location = service_context()->global_context()->location();\n}\n\nvoid RequestContext::FillComputePlatform(\n    service_control::ReportRequestInfo *info) {\n  info->compute_platform = service_context()->global_context()->platform();\n}\n\nvoid RequestContext::FillLogMessage(service_control::ReportRequestInfo *info) {\n  if (method()) {\n    info->api_method = method()->selector();\n    info->api_name = method()->api_name();\n    info->api_version = method()->api_version();\n    info->log_message = std::string(kMessage) + method()->selector();\n    if (info->response_code >= 400) {\n      info->log_message += std::string(\" failed: \") + info->status.ToString();\n    }\n  } else {\n    std::string http_verb = info->method;\n    if (http_verb.empty()) {\n      http_verb = kUnknownHttpVerb;\n    }\n    info->log_message = std::string(kIgnoredMessage) + http_verb + \" \" +\n                        request_->GetUnparsedRequestPath();\n  }\n}\n\nvoid RequestContext::FillHttpHeaders(const Response *response,\n                                     service_control::ReportRequestInfo *info) {\n  auto serverConfig = service_context_->config()->server_config();\n  if (serverConfig->has_service_control_config()) {\n    const auto &request_headers =\n        serverConfig->service_control_config().log_request_header();\n    for (const auto &header : request_headers) {\n      std::string header_value;\n      if (request_->FindHeader(header, &header_value)) {\n        info->request_headers =\n            info->request_headers + header + \"=\" + header_value + \";\";\n      }\n    }\n\n    const auto &response_headers =\n        serverConfig->service_control_config().log_response_header();\n    for (const auto &header : response_headers) {\n      std::string header_value;\n      if (response->FindHeader(header, &header_value)) {\n        info->response_headers =\n            info->response_headers + header + \"=\" + header_value + \";\";\n      }\n    }\n  }\n}\n\nvoid RequestContext::FillJwtPayloads(service_control::ReportRequestInfo *info) {\n  auto serverConfig = service_context_->config()->server_config();\n  if (serverConfig->has_service_control_config() &&\n      serverConfig->service_control_config().log_jwt_payload().size() != 0) {\n    for (const auto &payload_path :\n         serverConfig->service_control_config().log_jwt_payload()) {\n      std::string payload_value;\n      if (GetPrimitiveFieldValue(auth_claims_, payload_path, &payload_value)) {\n        info->jwt_payloads =\n            info->jwt_payloads + payload_path + \"=\" + payload_value + \";\";\n      }\n    }\n  }\n}\n\nvoid RequestContext::FillCheckRequestInfo(\n    service_control::CheckRequestInfo *info) {\n  FillOperationInfo(info);\n\n  request_->FindHeader(kXAndroidPackage, &info->android_package_name);\n  request_->FindHeader(kXAndroidCert, &info->android_cert_fingerprint);\n  request_->FindHeader(kXIosBundleId, &info->ios_bundle_id);\n}\n\nvoid RequestContext::FillAllocateQuotaRequestInfo(\n    service_control::QuotaRequestInfo *info) {\n  FillOperationInfo(info);\n\n  info->method_name = this->method_call_.method_info->name();\n  info->metric_cost_vector =\n      &this->method_call_.method_info->metric_cost_vector();\n}\n\nvoid RequestContext::FillReportRequestInfo(\n    Response *response, service_control::ReportRequestInfo *info) {\n  FillOperationInfo(info);\n  FillLocation(info);\n  FillComputePlatform(info);\n\n  info->url = request_->GetUnparsedRequestPath();\n  info->method = GetRequestHTTPMethodWithOverride();\n\n  info->frontend_protocol = request_->GetFrontendProtocol();\n  info->backend_protocol = request_->GetBackendProtocol();\n  info->check_response_info = check_response_info_;\n\n  info->auth_issuer = auth_issuer_;\n  info->auth_audience = auth_audience_;\n\n  if (!info->is_final_report) {\n    // Make sure we send delta metrics for intermediate reports.\n    info->request_bytes = request_->GetGrpcRequestBytes() - last_request_bytes_;\n    info->response_bytes =\n        request_->GetGrpcResponseBytes() - last_response_bytes_;\n    last_request_bytes_ += info->request_bytes;\n    last_response_bytes_ += info->response_bytes;\n  } else {\n    info->request_size = response->GetRequestSize();\n    info->response_size = response->GetResponseSize();\n    info->request_bytes = info->request_size - last_request_bytes_;\n    if (info->request_bytes < 0) {\n      info->request_bytes = 0;\n    }\n    info->response_bytes = info->response_size - last_response_bytes_;\n    if (info->response_bytes < 0) {\n      info->response_bytes = 0;\n    }\n\n    info->streaming_request_message_counts =\n        request_->GetGrpcRequestMessageCounts();\n    info->streaming_response_message_counts =\n        request_->GetGrpcResponseMessageCounts();\n\n    info->streaming_durations =\n        std::chrono::duration_cast<std::chrono::microseconds>(\n            std::chrono::system_clock::now() - start_time_)\n            .count();\n\n    info->status = response->GetResponseStatus();\n    info->response_code = info->status.HttpCode();\n\n    // Must be after response_code and method are assigned.\n    FillLogMessage(info);\n\n    FillHttpHeaders(response, info);\n    FillJwtPayloads(info);\n    bool is_streaming = false;\n    if (method() &&\n        (method()->request_streaming() || method()->response_streaming())) {\n      is_streaming = true;\n    }\n    if (!is_streaming) {\n      response->GetLatencyInfo(&info->latency);\n    }\n  }\n}\n\nconst std::string RequestContext::FindClientIPAddress() {\n  auto serverConfig = service_context_->config()->server_config();\n  std::string client_ip_header;\n\n  if (serverConfig->has_client_ip_extraction_config() &&\n      serverConfig->client_ip_extraction_config().client_ip_header().length() >\n          0 &&\n      request_->FindHeader(\n          serverConfig->client_ip_extraction_config().client_ip_header(),\n          &client_ip_header)) {\n    // split headers\n    std::vector<std::string> secments;\n    utils::Split(client_ip_header, kClientIPHeaderDelimeter, &secments);\n    int client_ip_header_position =\n        serverConfig->client_ip_extraction_config().client_ip_position();\n\n    if (client_ip_header_position < 0) {\n      client_ip_header_position = secments.size() + client_ip_header_position;\n    }\n\n    if (client_ip_header_position >= 0 &&\n        client_ip_header_position < (int)secments.size()) {\n      return utils::Trim(secments[client_ip_header_position]);\n    }\n  }\n\n  return request_->GetClientIP();\n}\n\nvoid RequestContext::StartBackendSpanAndSetTraceContext() {\n  backend_span_.reset(CreateSpan(cloud_trace_.get(), \"Backend\"));\n\n  // TODO: A better logic would be to send for GRPC backends the grpc-trace-bin\n  // header, and for http/https backends the X-Cloud-Trace-Context header.\n\n  std::string trace_context_header = cloud_trace()->ToTraceContextHeader(\n      backend_span_->trace_span()->span_id());\n\n  // Set trace context header to backend.\n  Status status = request()->AddHeaderToBackend(\n      cloud_trace()->header_type() == HeaderType::CLOUD_TRACE_CONTEXT\n          ? kCloudTraceContextHeader\n          : kGRpcTraceContextHeader,\n      trace_context_header, false);\n  if (!status.ok()) {\n    service_context()->env()->LogError(\n        \"Failed to set trace context header to backend.\");\n  }\n}\n\nstd::string RequestContext::GetAuthorizationUrl() const {\n  if (method_call_.method_info == nullptr) {\n    return \"\";\n  }\n  // This feature has to be enabled from the flag\n  if (!service_context()->global_context()->redirect_authorization_url()) {\n    return \"\";\n  }\n  if (auth_issuer_.empty()) {\n    return method_call_.method_info->first_authorization_url();\n  } else {\n    return method_call_.method_info->authorization_url_by_issuer(auth_issuer_);\n  }\n}\n\nstd::string RequestContext::GetBackendPath() const {\n  if (method_call_.method_info == nullptr) {\n    return \"\";\n  }\n\n  if (method_call_.method_info->backend_path_translation() ==\n      ::google::api::BackendRule_PathTranslation_APPEND_PATH_TO_ADDRESS) {\n    if (!method_call_.method_info->backend_path().empty()) {\n      return method_call_.method_info->backend_path() +\n             request_->GetUnparsedRequestPath();\n    } else {\n      // Not change to the request path.\n      return \"\";\n    }\n  } else if (method_call_.method_info->backend_path_translation() ==\n             ::google::api::BackendRule_PathTranslation_CONSTANT_ADDRESS) {\n    std::string parameters;\n    for (std::size_t i = 0; i != method_call_.variable_bindings.size(); i++) {\n      auto &variable_binding = method_call_.variable_bindings[i];\n      for (std::size_t j = 0; j < variable_binding.field_path.size(); ++j) {\n        // If field_path is snake case, need to use corresponding jsonName.\n        std::string::size_type found = variable_binding.field_path[j].find(\"_\");\n        std::string field_path;\n        if (found != std::string::npos &&\n            service_context_->config()->GetJsonName(\n                variable_binding.field_path[j], &field_path)) {\n          parameters.append(field_path);\n        } else {\n          parameters.append(variable_binding.field_path[j]);\n        }\n\n        if (j != variable_binding.field_path.size() - 1) {\n          parameters.append(\".\");\n        }\n      }\n\n      parameters.append(\"=\");\n      parameters.append(variable_binding.value);\n      if (i != method_call_.variable_bindings.size() - 1) {\n        parameters.append(\"&\");\n      }\n    }\n\n    if (parameters != \"\") {\n      return method_call_.method_info->backend_path() + \"?\" + parameters;\n    }\n    return method_call_.method_info->backend_path();\n  } else {\n    return \"\";\n  }\n}\n\nbool RequestContext::ShouldOverrideBackend() const {\n  if (method_call_.method_info == nullptr) {\n    return false;\n  }\n\n  if (method_call_.method_info->backend_path_translation() ==\n      ::google::api::BackendRule_PathTranslation_PATH_TRANSLATION_UNSPECIFIED) {\n    return false;\n  }\n  return true;\n}\n\nvoid RequestContext::AddInstanceIdentityToken() {\n  if (!method()) {\n    return;\n  }\n\n  const auto &audience = method()->backend_jwt_audience();\n  if (!audience.empty()) {\n    auto &token = service_context()\n                      ->global_context()\n                      ->GetInstanceIdentityToken(audience)\n                      ->GetAuthToken();\n    if (!token.empty()) {\n      std::string origin_auth_header;\n      if (request()->FindHeader(kAuthorizationHeader, &origin_auth_header)) {\n        Status status = request()->AddHeaderToBackend(\n            kXForwardedAuthorizationHeader, origin_auth_header, false);\n        if (!status.ok()) {\n          service_context()->env()->LogError(\n              \"Failed to set X-Forwarded-Authorization header to backend.\");\n        }\n      }\n      Status status = request()->AddHeaderToBackend(\n          kAuthorizationHeader, kBearerPrefix + token, false);\n      if (!status.ok()) {\n        service_context()->env()->LogError(\n            \"Failed to set authorization header to backend.\");\n      }\n    }\n  }\n}\n\n}  // namespace context\n}  // namespace api_manager\n}  // namespace google\n", "/* Copyright (C) Extensible Service Proxy Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef API_MANAGER_MOCK_REQUEST_H_\n#define API_MANAGER_MOCK_REQUEST_H_\n\n#include \"gmock/gmock.h\"\n#include \"include/api_manager/request.h\"\n\nnamespace google {\nnamespace api_manager {\n\nclass MockRequest : public Request {\n public:\n  MOCK_METHOD2(FindQuery, bool(const std::string &, std::string *));\n  MOCK_METHOD2(FindHeader, bool(const std::string &, std::string *));\n  MOCK_METHOD3(AddHeaderToBackend,\n               utils::Status(const std::string &, const std::string &, bool));\n  MOCK_METHOD1(SetAuthToken, void(const std::string &));\n  MOCK_METHOD0(GetRequestHTTPMethod, std::string());\n  MOCK_METHOD0(GetQueryParameters, std::string());\n  MOCK_METHOD0(GetFrontendProtocol,\n               ::google::api_manager::protocol::Protocol());\n  MOCK_METHOD0(GetBackendProtocol, ::google::api_manager::protocol::Protocol());\n  MOCK_METHOD0(GetRequestPath, std::string());\n  MOCK_METHOD0(GetUnparsedRequestPath, std::string());\n  MOCK_METHOD0(GetInsecureCallerID, std::string());\n  MOCK_METHOD0(GetClientIP, std::string());\n  MOCK_METHOD0(GetRequestHeaders, std::multimap<std::string, std::string> *());\n  MOCK_METHOD0(GetGrpcRequestBytes, int64_t());\n  MOCK_METHOD0(GetGrpcResponseBytes, int64_t());\n  MOCK_METHOD0(GetGrpcRequestMessageCounts, int64_t());\n  MOCK_METHOD0(GetGrpcResponseMessageCounts, int64_t());\n};\n\n}  // namespace api_manager\n}  // namespace google\n\n#endif  // API_MANAGER_MOCK_REQUEST_H_\n", "// Copyright (C) Extensible Service Proxy Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n#include \"src/api_manager/request_handler.h\"\n\n#include \"google/devtools/cloudtrace/v1/trace.pb.h\"\n#include \"google/protobuf/stubs/logging.h\"\n#include \"src/api_manager/auth/service_account_token.h\"\n#include \"src/api_manager/check_auth.h\"\n#include \"src/api_manager/check_workflow.h\"\n#include \"src/api_manager/cloud_trace/cloud_trace.h\"\n#include \"src/api_manager/utils/marshalling.h\"\n\nusing ::google::api_manager::utils::Status;\nusing google::devtools::cloudtrace::v1::Traces;\n\nnamespace google {\nnamespace api_manager {\n\nRequestHandler::RequestHandler(\n    std::shared_ptr<CheckWorkflow> check_workflow,\n    std::shared_ptr<context::ServiceContext> service_context,\n    std::unique_ptr<Request> request_data)\n    : context_(new context::RequestContext(service_context,\n                                           std::move(request_data))),\n      check_workflow_(check_workflow) {\n  // Remove x-endponts-api-userinfo from downstream client.\n  // It should be set by the last Endpoint proxy to prevent users spoofing.\n  std::string buffer;\n  if (context_->request()->FindHeader(\n          google::api_manager::auth::kEndpointApiUserInfo, &buffer)) {\n    context_->request()->AddHeaderToBackend(\n        google::api_manager::auth::kEndpointApiUserInfo, \"\", true);\n  }\n}\n\nvoid RequestHandler::Check(std::function<void(Status status)> continuation) {\n  auto interception = [continuation, this](Status status) {\n    if (status.ok()) {\n      if (context_->cloud_trace()) {\n        context_->StartBackendSpanAndSetTraceContext();\n      }\n      // Add InstanceIdentityToken to request header if needed, which is\n      // required for backend routing.\n      context_->AddInstanceIdentityToken();\n    }\n\n    continuation(status);\n  };\n\n  context_->set_check_continuation(interception);\n\n  // Run the check flow.\n  check_workflow_->Run(context_);\n}\n\nvoid RequestHandler::AttemptIntermediateReport() {\n  // For grpc streaming calls, we send intermediate reports to represent\n  // streaming stats. Specifically:\n  // 1) We send request_count in the first report to indicate the start of a\n  // stream.\n  // 2) We send request_bytes, response_bytes in intermediate reports, which\n  // triggered by timer.\n  // 3) In the final report, we send all metrics except request_count if it\n  // already sent.\n  // We only send intermediate streaming report if the time_interval >\n  // intermediate_report_interval().\n  if (std::chrono::duration_cast<std::chrono::seconds>(\n          std::chrono::steady_clock::now() - context_->last_report_time())\n          .count() <\n      context_->service_context()->intermediate_report_interval()) {\n    return;\n  }\n  service_control::ReportRequestInfo info;\n  info.is_first_report = context_->is_first_report();\n  info.is_final_report = false;\n  context_->FillReportRequestInfo(NULL, &info);\n\n  // Calling service_control Report.\n  Status status = context_->service_context()->service_control()->Report(info);\n  if (!status.ok()) {\n    context_->service_context()->env()->LogError(\n        \"Failed to send intermediate report to service control.\");\n  } else {\n    context_->set_first_report(false);\n  }\n  context_->set_last_report_time(std::chrono::steady_clock::now());\n}\n\n// Sends a report.\nvoid RequestHandler::Report(std::unique_ptr<Response> response,\n                            std::function<void(void)> continuation) {\n  if (context_->method() && context_->method()->skip_service_control()) {\n    continuation();\n    return;\n  }\n  // Close backend trace span.\n  context_->EndBackendSpan();\n\n  if (context_->service_context()->service_control()) {\n    service_control::ReportRequestInfo info;\n    info.is_first_report = context_->is_first_report();\n    info.is_final_report = true;\n    context_->FillReportRequestInfo(response.get(), &info);\n    // Calling service_control Report.\n    Status status =\n        context_->service_context()->service_control()->Report(info);\n    if (!status.ok()) {\n      context_->service_context()->env()->LogError(\n          \"Failed to send report to service control.\");\n    }\n  }\n\n  if (context_->cloud_trace()) {\n    context_->cloud_trace()->EndRootSpan();\n    // Always set the project_id to the latest one.\n    //\n    // this is how project_id is calculated: if gce metadata is fetched, use\n    // its project_id. Otherwise, use the project_id from service_config if it\n    // is configured.\n    // gce metadata fetching is started by the first request. While fetching is\n    // in progress, subsequent requests will fail.  These failed requests may\n    // have wrong project_id until gce metadata is fetched successfully.\n    context_->service_context()->cloud_trace_aggregator()->SetProjectId(\n        context_->service_context()->project_id());\n    context_->service_context()->cloud_trace_aggregator()->AppendTrace(\n        context_->cloud_trace()->ReleaseTrace());\n  }\n\n  continuation();\n}\n\nstd::string RequestHandler::GetServiceConfigId() const {\n  return context_->service_context()->service().id();\n}\n\nstd::string RequestHandler::GetBackendAddress() const {\n  if (context_->method()) {\n    return context_->method()->backend_address();\n  } else {\n    return std::string();\n  }\n}\n\nstd::string RequestHandler::GetRpcMethodFullName() const {\n  if (context_ && context_->method() &&\n      !context_->method()->rpc_method_full_name().empty()) {\n    return context_->method()->rpc_method_full_name();\n  } else {\n    return std::string();\n  }\n}\n\nvoid RequestHandler::TryAddApiKeyHeaderFromQuery() {\n  if (context_->api_key_from_query()) {\n    context_->SetApiKeyHeader();\n  }\n}\n\nstd::string RequestHandler::GetAuthorizationUrl() const {\n  return context_->GetAuthorizationUrl();\n}\n\n}  // namespace api_manager\n}  // namespace google\n", "// Copyright (C) Extensible Service Proxy Authors\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n// SUCH DAMAGE.\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n#include \"src/nginx/request.h\"\n\n#include \"src/api_manager/check_auth.h\"\n#include \"src/nginx/module.h\"\n#include \"src/nginx/util.h\"\n\nnamespace google {\nnamespace api_manager {\nnamespace nginx {\n\nNgxEspRequest::NgxEspRequest(ngx_http_request_t *r) : r_(r) {}\n\nNgxEspRequest::~NgxEspRequest() {\n  // TODO: Propagate any changes to the headers back to the request.\n}\n\nstd::string NgxEspRequest::GetRequestHTTPMethod() {\n  return ngx_str_to_std(r_->method_name);\n}\n\nstd::string NgxEspRequest::GetQueryParameters() {\n  return ngx_str_to_std(r_->args);\n}\n\nstd::string NgxEspRequest::GetRequestPath() {\n  std::string unparsed_str = ngx_str_to_std(r_->unparsed_uri);\n  return unparsed_str.substr(0, unparsed_str.find_first_of('?'));\n}\n\nstd::string NgxEspRequest::GetUnparsedRequestPath() {\n  return ngx_str_to_std(r_->unparsed_uri);\n}\n\n::google::api_manager::protocol::Protocol NgxEspRequest::GetFrontendProtocol() {\n  ngx_esp_request_ctx_t *ctx = ngx_http_esp_get_module_ctx(r_);\n  if (ctx->grpc_pass_through) {\n    return ::google::api_manager::protocol::GRPC;\n  }\n  if (r_ && r_->connection) {\n#if (NGX_SSL)\n    if (r_->connection->ssl) {\n      return ::google::api_manager::protocol::HTTPS;\n    }\n#endif\n    return ::google::api_manager::protocol::HTTP;\n  } else {\n    return ::google::api_manager::protocol::UNKNOWN;\n  }\n}\n\n::google::api_manager::protocol::Protocol NgxEspRequest::GetBackendProtocol() {\n  ngx_esp_request_ctx_t *ctx = ngx_http_esp_get_module_ctx(r_);\n  if (ctx->grpc_backend) {\n    return ::google::api_manager::protocol::GRPC;\n  } else {\n    // TODO: determine HTTP or HTTPS for backend.\n    return ::google::api_manager::protocol::UNKNOWN;\n  }\n}\n\nstd::string NgxEspRequest::GetClientIP() {\n  // use remote_addr variable to get client_ip.\n  ngx_esp_main_conf_t *mc = reinterpret_cast<ngx_esp_main_conf_t *>(\n      ngx_http_get_module_main_conf(r_, ngx_esp_module));\n  if (mc->remote_addr_variable_index != NGX_ERROR) {\n    ngx_http_variable_value_t *vv =\n        ngx_http_get_indexed_variable(r_, mc->remote_addr_variable_index);\n    if (vv != nullptr && !vv->not_found) {\n      return ngx_str_to_std(ngx_str_t({vv->len, vv->data}));\n    }\n  }\n  return \"\";\n}\n\nint64_t NgxEspRequest::GetGrpcRequestMessageCounts() {\n  ngx_esp_request_ctx_t *ctx = ngx_http_esp_get_module_ctx(r_);\n  return ctx->grpc_request_message_counts;\n}\n\nint64_t NgxEspRequest::GetGrpcResponseMessageCounts() {\n  ngx_esp_request_ctx_t *ctx = ngx_http_esp_get_module_ctx(r_);\n  return ctx->grpc_response_message_counts;\n}\n\nint64_t NgxEspRequest::GetGrpcRequestBytes() {\n  ngx_esp_request_ctx_t *ctx = ngx_http_esp_get_module_ctx(r_);\n  return ctx->grpc_request_bytes;\n}\n\nint64_t NgxEspRequest::GetGrpcResponseBytes() {\n  ngx_esp_request_ctx_t *ctx = ngx_http_esp_get_module_ctx(r_);\n  return ctx->grpc_response_bytes;\n}\n\nbool NgxEspRequest::FindQuery(const std::string &name, std::string *query) {\n  ngx_str_t out = ngx_null_string;\n  ngx_http_arg(r_, reinterpret_cast<u_char *>(const_cast<char *>(name.data())),\n               name.size(), &out);\n  if (out.len > 0) {\n    *query = ngx_str_to_std(out);\n    return true;\n  }\n  return false;\n}\n\nbool NgxEspRequest::FindHeader(const std::string &name, std::string *header) {\n  auto h = ngx_esp_find_headers_in(\n      r_, reinterpret_cast<u_char *>(const_cast<char *>(name.data())),\n      name.size());\n  if (h && h->value.len > 0) {\n    *header = ngx_str_to_std(h->value);\n    return true;\n  }\n  return false;\n}\n\nvoid NgxEspRequest::SetAuthToken(const std::string &auth_token) {\n  ngx_esp_request_ctx_t *ctx = ngx_http_esp_get_module_ctx(r_);\n  ngx_str_copy_from_std(r_->pool, auth_token, &ctx->auth_token);\n}\n\nutils::Status NgxEspRequest::AddHeaderToBackend(const std::string &key,\n                                                const std::string &value,\n                                                bool changeAllOccurrence) {\n  std::vector<ngx_table_elt_t *> headers;\n  for (auto &h_in : r_->headers_in) {\n    if (key.size() == h_in.key.len &&\n        strncasecmp(key.c_str(), reinterpret_cast<const char *>(h_in.key.data),\n                    h_in.key.len) == 0) {\n      headers.push_back(&h_in);\n      if (!changeAllOccurrence) {\n        break;\n      }\n    }\n  }\n  if (headers.empty()) {\n    ngx_table_elt_t *h = reinterpret_cast<ngx_table_elt_t *>(\n        ngx_list_push(&r_->headers_in.headers));\n    if (h == nullptr) {\n      return utils::Status(Code::INTERNAL, \"Out of memory\");\n    }\n\n    h->lowcase_key =\n        reinterpret_cast<u_char *>(ngx_pcalloc(r_->pool, key.size()));\n    if (h->lowcase_key == nullptr) {\n      return utils::Status(Code::INTERNAL, \"Out of memory\");\n    }\n    h->hash = ngx_hash_strlow(\n        h->lowcase_key,\n        reinterpret_cast<u_char *>(const_cast<char *>(key.c_str())),\n        key.size());\n    headers.push_back(h);\n  }\n\n  for (size_t i = 0; i < headers.size(); ++i) {\n    ngx_table_elt_t *it = headers[i];\n    if (ngx_str_copy_from_std(r_->pool, key, &it->key) != NGX_OK ||\n        ngx_str_copy_from_std(r_->pool, value, &it->value) != NGX_OK) {\n      return utils::Status(Code::INTERNAL, \"Out of memory\");\n    }\n  }\n\n  ngx_log_debug3(\n      NGX_LOG_DEBUG_HTTP, r_->connection->log, 0,\n      \"updates header to backend, changeAllOccurrence: '%t', \\\"%V: %V\\\"\",\n      changeAllOccurrence, &h->key, &h->value);\n  return utils::Status::OK;\n}\n\n}  // namespace nginx\n}  // namespace api_manager\n\n}  // namespace google\n", "/*\n * Copyright (C) Extensible Service Proxy Authors\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n#ifndef NGINX_NGX_ESP_REQUEST_H_\n#define NGINX_NGX_ESP_REQUEST_H_\n\nextern \"C\" {\n#include \"src/http/ngx_http.h\"\n}\n\n#include \"include/api_manager/request.h\"\n\nnamespace google {\nnamespace api_manager {\nnamespace nginx {\n\n// Wraps ngx_http_request_t as a ::google::api_manager::Request.\nclass NgxEspRequest : public Request {\n public:\n  NgxEspRequest(ngx_http_request_t *r);\n  ~NgxEspRequest();\n\n  virtual std::string GetRequestHTTPMethod();\n  virtual std::string GetQueryParameters();\n  virtual protocol::Protocol GetFrontendProtocol();\n  virtual protocol::Protocol GetBackendProtocol();\n  virtual std::string GetRequestPath();\n  virtual std::string GetUnparsedRequestPath();\n  virtual std::string GetClientIP();\n\n  virtual int64_t GetGrpcRequestBytes();\n  virtual int64_t GetGrpcResponseBytes();\n  virtual int64_t GetGrpcRequestMessageCounts();\n  virtual int64_t GetGrpcResponseMessageCounts();\n\n  virtual void SetAuthToken(const std::string &auth_token);\n  virtual utils::Status AddHeaderToBackend(const std::string &key,\n                                           const std::string &value,\n                                           bool changeAllOccurrence);\n  virtual bool FindQuery(const std::string &name, std::string *query);\n  virtual bool FindHeader(const std::string &name, std::string *header);\n\n private:\n  ngx_http_request_t *r_;\n};\n\n}  // namespace nginx\n}  // namespace api_manager\n}  // namespace google\n\n#endif  // NGINX_NGX_ESP_REQUEST_H_\n", "# Copyright (C) Extensible Service Proxy Authors\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n#\n################################################################################\n#\n# A shared module for ESP end-to-end tests.\n# Sets up a TEST_NGINX_BINARY environment variable for Nginx test framework\n# to find ESP build of Nginx.\n# Adds Nginx test library (nginx-tests/lib) to the module search path.\n\nuse strict;\nuse warnings;\n\npackage ApiManager;\n\nuse Config;\nuse FindBin;\nuse IO::Socket;\nuse JSON::PP;\nuse Data::Dumper;\nuse MIME::Base64;\nuse Test::More;\n\nsub repo_root {\n  my $testdir = $FindBin::Bin;\n  my @path = split('/', $testdir);\n  return (join('/', @path[0 .. $#path - 3]), $testdir);\n}\n\nBEGIN {\n  our ($Root, $TestDir) = repo_root();\n  our $TestLib = $Root . \"/third_party/nginx-tests/lib\";\n\n  if (!defined $ENV{TEST_SRCDIR}) {\n    $ENV{TEST_SRCDIR} = $Root;\n  }\n}\n\nuse lib $ApiManager::TestLib;\n\nselect STDERR; $| = 1;   # flush stderr immediately\nselect STDOUT; $| = 1;   # flush stdout immediately\n\nsub write_binary_file {\n  my ($name, $content) = @_;\n  open F, '>>', $name or die \"Can't create $name: $!\";\n  binmode F;\n  print F $content;\n  close F;\n}\n\nsub compare {\n  my ($x, $y, $path, $ignore_keys) = @_;\n\n  my $refx = ref $x;\n  my $refy = ref $y;\n  if(!$refx && !$refy) { # both are scalars\n    unless ($x eq $y) {\n      print \"$path value doesn't match $x != $y.\\n\";\n      return 0;\n    }\n  }\n  elsif ($refx ne $refy) { # not the same type\n    print \"$path type doesn't match $refx != $refy.\\n\";\n    return 0;\n  }\n  elsif ($refx eq 'SCALAR' || $refx eq 'REF') {\n    return compare(${$x}, ${$y}, $path, $ignore_keys);\n  }\n  elsif ($refx eq 'ARRAY') {\n    if ($#{$x} == $#{$y}) { # same length\n      my $i = -1;\n      for (@$x) {\n        $i++;\n        return 0 unless compare(\n          $x->[$i], $y->[$i], \"$path:[$i]\", $ignore_keys);\n      }\n    }\n    else {\n      print \"$path array size doesn't match: $#{$x} != $#{$y}.\\n\";\n      return 0;\n    }\n  }\n  elsif ($refx eq 'HASH') {\n    my @diff = grep { !exists $ignore_keys->{$_} && !exists $y->{$_} } keys %$x;\n    if (@diff) {\n      print \"$path has following extra keys:\\n\";\n      for (@diff) {\n        print \"$_: $x->{$_}\\n\";\n      }\n      return 0;\n    }\n    for (keys %$y) {\n      unless(exists($x->{$_})) {\n        print \"$path key $_ doesn't exist.\\n\";\n        return 0;\n      }\n      return 0 unless compare($x->{$_}, $y->{$_}, \"$path:$_\", $ignore_keys);\n    }\n  } else {\n    print \"$path: Not supported type: $refx\\n\";\n    return 0;\n  }\n  return 1;\n}\n\nsub compare_json {\n  my ($json, $expected, $random_metrics) = @_;\n  my $json_obj = decode_json($json);\n\n  print Dumper $json_obj if $ENV{TEST_NGINX_VERBOSE};\n  return compare($json_obj, $expected, \"\", {});\n}\n\nsub compare_json_with_random_metrics {\n  my ($json, $expected, @random_metrics) = @_;\n  my $json_obj = decode_json($json);\n\n  # A list of metrics with non-deterministic values.\n  my %random_metric_map = map { $_ => 1 } @random_metrics;\n\n  # Check and remove the above random metrics before making the comparison.\n  my $matched_random_metric_count = 0;\n  if (not exists $json_obj->{operations}) {\n    return 0;\n  }\n\n  my $operation = $json_obj->{operations}->[0];\n  if (not exists $operation->{metricValueSets}) {\n    return 0;\n  }\n\n  my @metric_value_sets;\n  foreach my $metric (@{$operation->{metricValueSets}}) {\n    if (exists($random_metric_map{$metric->{metricName}})) {\n      $matched_random_metric_count += 1;\n    } else {\n      push @metric_value_sets, $metric;\n    }\n  }\n\n  if ($matched_random_metric_count != scalar @random_metrics) {\n    return 0;\n  }\n  $operation->{metricValueSets} = \\@metric_value_sets;\n\n  print Dumper $json_obj if $ENV{TEST_NGINX_VERBOSE};\n  my %ignore_keys = map { $_ => \"1\" } qw(\n    startTime endTime timestamp operationId);\n  return compare($json_obj, $expected, \"\", \\%ignore_keys);\n}\n\nsub compare_user_info {\n  my ($user_info, $expected) = @_;\n  my $json_obj = decode_json(decode_base64($user_info));\n  print Dumper $json_obj if $ENV{TEST_NGINX_VERBOSE};\n  return compare($json_obj, $expected, \"\", {});\n}\n\nsub read_file_using_full_path {\n  my ($full_path) = @_;\n  local $/;\n  open F, '<', $full_path or die \"Can't open $full_path $!\";\n  my $content = <F>;\n  close F;\n  return $content;\n}\n\nsub read_test_file {\n  my ($name) = @_;\n  return read_file_using_full_path($ApiManager::TestDir . '/' . $name);\n}\n\nsub write_file_expand {\n  if (!defined $ENV{TEST_CONFIG}) {\n    $ENV{TEST_CONFIG} = \"\";\n  }\n  my ($t, $name, $content) = @_;\n  $content =~ s/%%TEST_CONFIG%%/$ENV{TEST_CONFIG}/gmse;\n  $t->write_file_expand($name,  $content);\n}\n\nsub get_bookstore_service_config {\n  return read_test_file(\"testdata/bookstore.pb.txt\");\n}\n\nsub get_bookstore_service_config_allow_all_http_requests {\n    return read_test_file('testdata/bookstore_allow_all_http_requests.pb.txt');\n}\n\nsub get_bookstore_service_config_allow_unregistered {\n  return get_bookstore_service_config .\n         read_test_file(\"testdata/usage_fragment.pb.txt\");\n}\n\nsub get_bookstore_service_config_allow_some_unregistered {\n  return get_bookstore_service_config .\n      read_test_file(\"testdata/usage_frag.pb.txt\");\n}\n\nsub get_echo_service_config {\n  return read_test_file(\"testdata/echo_service.pb.txt\");\n}\n\nsub get_grpc_test_service_config {\n  my ($GrpcBackendPort) = @_;\n  return read_test_file(\"testdata/grpc_echo_service.pb.txt\") . <<EOF\nbackend {\n  rules {\n    selector: \"test.grpc.Test.Echo\"\n    address: \"127.0.0.1:$GrpcBackendPort\"\n  }\n  rules {\n    selector: \"test.grpc.Test.EchoStream\"\n    address: \"127.0.0.1:$GrpcBackendPort\"\n  }\n}\nEOF\n}\n\nsub get_grpc_interop_service_config {\n  return read_test_file(\"testdata/grpc_interop_service.pb.txt\");\n}\n\nsub get_transcoding_test_service_config {\n  my ($host_name, $service_control_address) = @_;\n  my $path = './test/transcoding/service.pb.txt';\n  my $service_config = read_file_using_full_path($path);\n  # Replace the host name\n  $service_config =~ s/<YOUR_PROJECT_ID>.appspot.com/$host_name/;\n  # Replace the project id\n  $service_config =~ s/<YOUR_PROJECT_ID>/endpoints-transcoding-test/;\n  # Replace the service control address\n  $service_config =~ s/servicecontrol.googleapis.com/$service_control_address/;\n  return $service_config;\n}\n\nsub get_grpc_echo_test_service_config {\n  my ($host_name, $service_control_address) = @_;\n  my $path = './test/grpc/local/service.json';\n  my $service_config = read_file_using_full_path($path);\n  # Replace the host name\n  $service_config =~ s/echo-dot-esp-grpc-load-test.appspot.com/$host_name/;\n  # Replace the service control address\n  $service_config =~ s/servicecontrol.googleapis.com/$service_control_address/;\n  return $service_config;\n}\n\nsub get_large_report_request {\n  my ($t, $size) = @_;\n  my $testdir = $t->testdir();\n  my $cmd = './src/tools/service_control_json_gen';\n  system \"$cmd --report_request_size=$size --json > $testdir/large_data.json\";\n  return $t->read_file('large_data.json');\n}\n\nsub get_metadata_response_body {\n  return <<EOF;\n{\n  \"instance\": {\n    \"attributes\": {\n      \"gae_app_container\": \"app\",\n      \"gae_app_fullname\": \"esp-test-app_20150921t180445-387321214075436208\",\n      \"gae_backend_instance\": \"0\",\n      \"gae_backend_minor_version\": \"387321214075436208\",\n      \"gae_backend_name\": \"default\",\n      \"gae_backend_version\": \"20150921t180445\",\n      \"gae_project\": \"esp-test-app\",\n      \"gae_vm_runtime\": \"custom\",\n      \"gcm-pool\": \"gae-default-20150921t180445\",\n      \"gcm-replica\": \"gae-default-20150921t180445-inqp\"\n    },\n    \"cpuPlatform\": \"Intel Ivy Bridge\",\n    \"description\": \"GAE managed VM for module: default, version: 20150921t180445\",\n    \"hostname\": \"gae-default-20150921t180445-inqp.c.esp-test-app.internal\",\n    \"id\": 3296474103533342935,\n    \"image\": \"\",\n    \"machineType\": \"projects/345623948572/machineTypes/g1-small\",\n    \"maintenanceEvent\": \"NONE\",\n    \"zone\": \"projects/345623948572/zones/us-west1-d\"\n  },\n  \"project\": {\n    \"numericProjectId\": 345623948572,\n    \"projectId\": \"esp-test-app\"\n  }\n}\nEOF\n}\n\nsub disable_service_control_cache {\n  return <<EOF;\nservice_control_config {\n  check_aggregator_config {\n  cache_entries: 0\n  }\n  report_aggregator_config {\n  cache_entries: 0\n  }\n}\nEOF\n}\n\nsub grpc_test_server {\n  my ($t, @args) = @_;\n  my $server = './test/grpc/grpc-test-server';\n  exec $server, @args;\n}\n\nsub grpc_interop_server {\n  my ($t, $port, @args) = @_;\n  my $server = \"./external/com_github_grpc_grpc/test/cpp/interop/interop_server\";\n  exec $server, \"--port\", $port, @args;\n}\n\nsub transcoding_test_server {\n  my ($t, @args) = @_;\n  my $server = './test/transcoding/bookstore-server';\n  exec $server, @args;\n}\n\n# Runs the gRPC server for testing transcoding and redirects the output to a\n# file.\nsub run_transcoding_test_server {\n  my ($t, $output_file, @args) = @_;\n  my $redirect_file = $t->{_testdir}.'/'.$output_file;\n\n  # redirect, fork & run, restore\n  open ORIGINAL, \">&\", \\*STDOUT;\n  open STDOUT, \">\", $redirect_file;\n  $t->run_daemon(\\&transcoding_test_server, $t, @args);\n  open STDOUT, \">&\", \\*ORIGINAL;\n}\n\nsub call_bookstore_client {\n  my ($t, @args) = @_;\n  my $client = './test/transcoding/bookstore-client';\n  my $output_file = $t->{_testdir} . '/bookstore-client.log';\n\n  my $rc = system \"$client \" . join(' ', @args) . \" > $output_file\";\n\n  return ($rc, read_file_using_full_path($output_file))\n}\n\nsub run_grpc_test {\n  my ($t, $plans) = @_;\n  $t->write_file('test_plans.txt', $plans);\n  my $testdir = $t->testdir();\n  my $client = './test/grpc/grpc-test-client';\n  system \"$client < $testdir/test_plans.txt > $testdir/test_results.txt\";\n  return $t->read_file('test_results.txt');\n}\n\nsub run_grpc_interop_test {\n  my ($t, $port, $test_case, @args) = @_;\n  my $testdir = $t->testdir();\n  my $client = \"./external/com_github_grpc_grpc/test/cpp/interop/interop_client\";\n  return system \"$client --server_port $port --test_case $test_case \" . join(' ', @args)\n}\n\nsub run_grpc_interop_stress_test {\n  my ($t, $port, $metrics_port, $test_cases, $duration, @args) = @_;\n  my $testdir = $t->testdir();\n  my $client = './external/com_github_grpc_grpc/test/cpp/interop/stress_test';\n  return system \"$client --server_addresses localhost:$port \" .\n      \"--test_cases $test_cases --test_duration_secs $duration \" .\n      \"--num_channels_per_server 200 --num_stubs_per_channel 1 \" . \n      join(' ', @args)\n}\n\n\nsub run_nginx_with_stderr_redirect {\n  my $t = shift;\n  my $redirect_file = $t->{_testdir}.'/stderr.log';\n\n  # redirect, fork & run, restore\n  open ORIGINAL, \">&\", \\*STDERR;\n  open STDERR, \">\", $redirect_file;\n  $t->run();\n  open STDERR, \">&\", \\*ORIGINAL;\n}\n\n# Runs an HTTP server that returns \"404 Not Found\" for every request.\nsub not_found_server {\n  my ($t, $port) = @_;\n\n  my $server = HttpServer->new($port, $t->testdir() . '/nop.log')\n    or die \"Can't create test server socket: $!\\n\";\n\n  $server->run();\n}\n\n# Reads a file which contains a stream of HTTP requests,\n# parses out individual requests and returns them in an array.\nsub read_http_stream {\n  my ($t, $file) = @_;\n\n  my $http = $t->read_file($file);\n\n  # Parse out individual HTTP requests.\n\n  my @requests;\n\n  while ($http ne '') {\n    my ($request_headers, $rest) = split /\\r\\n\\r\\n/, $http, 2;\n    my @header_lines = split /\\r\\n/, $request_headers;\n\n    my %headers;\n    my $verb = '';\n    my $uri = '';\n    my $path = '';\n    my $body = '';\n\n    # Process request line.\n    my $request_line = $header_lines[0];\n    if ($request_line =~ /^(\\S+)\\s+(([^? ]+)(\\?[^ ]+)?)\\s+HTTP/i) {\n      $verb = $1;\n      $uri = $2;\n      $path = $3;\n    }\n\n    # Process headers\n    foreach my $header (@header_lines[1 .. $#header_lines]) {\n      my ($key, $value) = split /\\s*:\\s*/, $header, 2;\n      $headers{lc $key} = $value;\n    }\n\n    my $content_length = $headers{'content-length'} || 0;\n    if ($content_length > 0) {\n      $body = substr $rest, 0, $content_length;\n      $rest = substr $rest, $content_length;\n    }\n\n    push @requests, {\n      'verb' => $verb,\n      'path' => $path,\n      'uri' => $uri,\n      'headers' => \\%headers,\n      'header_lines' => \\@header_lines,\n      'body' => $body\n    };\n\n    $http = $rest;\n  }\n\n  return @requests;\n}\n\n# Checks that response Content-Type header is application/json and matches the\n# response body with the expected JSON.\nsub verify_http_json_response {\n  my ($response, $expected_body) = @_;\n\n  # Parse out the body\n  my ($headers, $actual_body) = split /\\r\\n\\r\\n/, $response, 2;\n\n  if ($headers !~ qr/HTTP\\/1.1 200 OK/i) {\n    Test::More::diag(\"Status code doesn't match\\n\");\n    Test::More::diag(\"Expected: 200 OK\\n\");\n    Test::More::diag(\"Actual headers: ${headers}\\n\");\n    return 0;\n  }\n\n  if ($headers !~ qr/content-type:(\\s)*application\\/json/i) {\n    Test::More::diag(\"Content-Type doesn't match\\n\");\n    Test::More::diag(\"Expected: application/json\\n\");\n    Test::More::diag(\"Actual headers: ${headers}\\n\");\n    return 0;\n  }\n\n  if (!compare_json($actual_body, $expected_body)) {\n    Test::More::diag(\"Response body doesn't match\\n\");\n    Test::More::diag(\"Expected: \" . encode_json(${expected_body}) . \"\\n\");\n    Test::More::diag(\"Actual: ${actual_body}\\n\");\n    return 0;\n  }\n\n  return 1;\n}\n\nsub http_response_body {\n  my ($response, $expected_body) = @_;\n  my ($headers, $actual_body) = split /\\r\\n\\r\\n/, $response, 2;\n  return $actual_body;\n}\n\n# Initial port is 8080 or $TEST_PORT env variable. A test is allowed to use 10\n# subsequent ports.\nsub available_port_range {\n  my %port_range;\n  if (!defined $ENV{TEST_PORT}) {\n    %port_range = (8080, 8090);\n  } else {\n    %port_range = ($ENV{TEST_PORT}, $ENV{TEST_PORT} + 10);\n  }\n\n  printf(\"Available port range: [%d, %d)\\n\", %port_range);\n  return %port_range;\n}\n\nmy ($next_port, $max_port) = available_port_range();\n\n# Select an open port\nsub pick_port {\n  for (my $port = $next_port; $port < $max_port; $port++) {\n    my $server = IO::Socket::INET->new(\n        Proto => 'tcp',\n        LocalHost => '127.0.0.1',\n        LocalPort => $port,\n    )\n    or next;\n    close $server;\n    $next_port = $port + 1;\n    print \"Pick port: $port\\n\";\n    return $port;\n  }\n  die \"Could not find an available port for testing\\n\"\n}\n\n#\n# These routines are copied from Nginx.pm to support custom ports\n#\n\nsub log_core {\n  my ($prefix, $msg) = @_;\n  ($prefix, $msg) = ('', $prefix) unless defined $msg;\n  $prefix .= ' ' if length($prefix) > 0;\n\n  if (length($msg) > 2048) {\n    $msg = substr($msg, 0, 2048)\n      . \"(...logged only 2048 of \" . length($msg)\n      . \" bytes)\";\n  }\n\n  $msg =~ s/^/# $prefix/gm;\n  $msg =~ s/([^\\x20-\\x7e])/sprintf('\\\\x%02x', ord($1)) . (($1 eq \"\\n\") ? \"\\n\" : '')/gmxe;\n  $msg .= \"\\n\" unless $msg =~ /\\n\\Z/;\n  print $msg;\n}\n\nsub log_out {\n  log_core('>>', @_);\n}\n\nsub log_in {\n  log_core('<<', @_);\n}\n\nsub http_get($;$;%) {\n  my ($port, $url, %extra) = @_;\n  return http($port, <<EOF, %extra);\nGET $url HTTP/1.0\nHost: localhost\n\nEOF\n}\n\nsub http($;$;%) {\n  my ($port, $request, %extra) = @_;\n\n  my $s = http_start($port, $request, %extra);\n\n  return $s if $extra{start} or !defined $s;\n  return http_end($s, %extra);\n}\n\nsub http_start($;$;%) {\n  my ($port, $request, %extra) = @_;\n  my $s;\n\n  eval {\n    local $SIG{ALRM} = sub { die \"timeout\\n\" };\n    local $SIG{PIPE} = sub { die \"sigpipe\\n\" };\n    my $timeout = 8;\n    $timeout = $extra{timeout} if $extra{timeout};\n    alarm($timeout);\n\n    $s = $extra{socket} || IO::Socket::INET->new(\n      Proto => 'tcp',\n      PeerAddr => \"127.0.0.1:$port\"\n    )\n      or die \"Can't connect to nginx: $!\\n\";\n\n    log_out($request);\n    $s->print($request);\n\n    select undef, undef, undef, $extra{sleep} if $extra{sleep};\n    return '' if $extra{aborted};\n\n    if ($extra{body}) {\n      log_out($extra{body});\n      $s->print($extra{body});\n    }\n\n    alarm(0);\n  };\n  alarm(0);\n  if ($@) {\n    log_in(\"died: $@\");\n    return undef;\n  }\n\n  return $s;\n}\n\nsub http_end($;%) {\n  my ($s, %extra) = @_;\n  my $reply;\n\n  eval {\n    local $SIG{ALRM} = sub { die \"timeout\\n\" };\n    local $SIG{PIPE} = sub { die \"sigpipe\\n\" };\n    my $timeout = 8;\n    $timeout = $extra{timeout} if $extra{timeout};\n    alarm($timeout);\n\n    local $/;\n    $reply = $s->getline();\n\n    alarm(0);\n  };\n  alarm(0);\n  if ($@) {\n    log_in(\"died: $@\");\n    return undef;\n  }\n\n  log_in($reply);\n  return $reply;\n}\n\n# Waits for a UDS socket to be ready.\nsub wait_for_uds($) {\n  my ($sockpath) = @_;\n\n  # wait for socket to accept connections\n  for (1 .. 50) {\n    my $s = IO::Socket::UNIX->new(\n\t    Type => SOCK_STREAM(),\n\t    PeerAddr => $sockpath,\n    );\n\n    return 1 if defined $s;\n    select undef, undef, undef, 0.1;\n  }\n\n  return undef;\n}\n\n1;\n", "# Copyright (C) Extensible Service Proxy Authors\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n#\n################################################################################\n#\nuse strict;\nuse warnings;\n\n################################################################################\n\nuse src::nginx::t::ApiManager;   # Must be first (sets up import path to the Nginx test module)\nuse src::nginx::t::HttpServer;\nuse Test::Nginx;  # Imports Nginx's test module\nuse Test::More;   # And the test framework\nuse Data::Dumper;\n\n################################################################################\n\n# Port assignments\nmy $NginxPort = ApiManager::pick_port();\nmy $BackendPort = ApiManager::pick_port();\nmy $ServiceControlPort = ApiManager::pick_port();\n\nmy $t = Test::Nginx->new()->has(qw/http proxy/)->plan(15);\n\n# Save service name in the service configuration protocol buffer file.\n\n$t->write_file('service.pb.txt', ApiManager::get_bookstore_service_config . <<\"EOF\");\ncontrol {\n  environment: \"http://127.0.0.1:${ServiceControlPort}\"\n}\nEOF\n\nApiManager::write_file_expand($t, 'nginx.conf', <<\"EOF\");\n%%TEST_GLOBALS%%\ndaemon off;\nevents {\n  worker_connections 32;\n}\nhttp {\n  %%TEST_GLOBALS_HTTP%%\n  server_tokens off;\n  server {\n    listen 127.0.0.1:${NginxPort};\n    server_name localhost;\n    location / {\n      endpoints {\n        api service.pb.txt;\n        %%TEST_CONFIG%%\n        on;\n      }\n      proxy_pass http://127.0.0.1:${BackendPort};\n    }\n  }\n}\nEOF\n\n$t->run_daemon(\\&bookstore, $t, $BackendPort, 'bookstore.log');\n$t->run_daemon(\\&servicecontrol, $t, $ServiceControlPort, 'servicecontrol.log');\nis($t->waitforsocket(\"127.0.0.1:${BackendPort}\"), 1, 'Bookstore socket ready.');\nis($t->waitforsocket(\"127.0.0.1:${ServiceControlPort}\"), 1, 'Service control socket ready.');\n$t->run();\n\n################################################################################\n\nmy $response = ApiManager::http($NginxPort,<<'EOF');\nGET /shelves?key=this-is-an-api-key HTTP/1.0\nHost: localhost\nx-endpoint-api-userinfo: Should be removed\nx-endpoint-api-userinfo: Multiple userinfo should all be removed\n\nEOF\n\n$t->stop_daemons();\n\nmy ($response_headers, $response_body) = split /\\r\\n\\r\\n/, $response, 2;\n\nlike($response_headers, qr/HTTP\\/1\\.1 200 OK/, 'Returned HTTP 200.');\nis($response_body, <<'EOF', 'Shelves returned in the response body.');\n{ \"shelves\": [\n    { \"name\": \"shelves/1\", \"theme\": \"Fiction\" },\n    { \"name\": \"shelves/2\", \"theme\": \"Fantasy\" }\n  ]\n}\nEOF\n\nmy @requests = ApiManager::read_http_stream($t, 'bookstore.log');\nis(scalar @requests, 1, 'Backend received one request');\n\nmy $r = shift @requests;\n\nis($r->{verb}, 'GET', 'Backend request was a get');\nis($r->{uri}, '/shelves?key=this-is-an-api-key', 'Backend uri was /shelves');\nis($r->{headers}->{host}, \"127.0.0.1:${BackendPort}\", 'Host header was set');\nis($r->{headers}->{'x-endpoint-api-userinfo'}, '',\n    'X-Endpoint-API-UserInfo should be removed from the request headers');\nmy $arr = $r->{header_lines};\nmy @userinfo_list = ();\n\nforeach (@$arr) {\n  push(@userinfo_list, $_) if index($_, 'X-Endpoint-API-UserInfo') != -1;\n}\nis(join(\",\", @userinfo_list), 'X-Endpoint-API-UserInfo: ,X-Endpoint-API-UserInfo: ',\n   \"Multiple userinfo should all be removed\");\n\n@requests = ApiManager::read_http_stream($t, 'servicecontrol.log');\nis(scalar @requests, 1, 'Service control received one request');\n\n$r = shift @requests;\nis($r->{verb}, 'POST', ':check verb was post');\nis($r->{uri}, '/v1/services/endpoints-test.cloudendpointsapis.com:check', ':check was called');\nis($r->{headers}->{host}, \"127.0.0.1:${ServiceControlPort}\", 'Host header was set');\nis($r->{headers}->{'content-type'}, 'application/x-protobuf', ':check Content-Type was protocol buffer');\n\n################################################################################\n\nsub bookstore {\n  my ($t, $port, $file) = @_;\n  my $server = HttpServer->new($port, $t->testdir() . '/' . $file)\n    or die \"Can't create test server socket: $!\\n\";\n  local $SIG{PIPE} = 'IGNORE';\n\n  $server->on('GET', '/shelves?key=this-is-an-api-key', <<'EOF');\nHTTP/1.1 200 OK\nConnection: close\n\n{ \"shelves\": [\n    { \"name\": \"shelves/1\", \"theme\": \"Fiction\" },\n    { \"name\": \"shelves/2\", \"theme\": \"Fantasy\" }\n  ]\n}\nEOF\n  $server->run();\n}\n\nsub servicecontrol {\n  my ($t, $port, $file) = @_;\n  my $server = HttpServer->new($port, $t->testdir() . '/' . $file)\n    or die \"Can't create test server socket: $!\\n\";\n  local $SIG{PIPE} = 'IGNORE';\n  $server->on('POST', '/v1/services/endpoints-test.cloudendpointsapis.com:check', <<'EOF');\nHTTP/1.1 200 OK\nConnection: close\n\nEOF\n  $server->run();\n}\n\n################################################################################\n"], "filenames": ["include/api_manager/request.h", "src/api_manager/check_auth.cc", "src/api_manager/check_auth_test.cc", "src/api_manager/check_service_control.cc", "src/api_manager/context/client_ip_extraction_test.cc", "src/api_manager/context/request_context.cc", "src/api_manager/mock_request.h", "src/api_manager/request_handler.cc", "src/nginx/request.cc", "src/nginx/request.h", "src/nginx/t/ApiManager.pm", "src/nginx/t/auth_remove_user_info.t"], "buggy_code_start_loc": [77, 396, 461, 17, 120, 18, 28, 46, 149, 60, 458, 45], "buggy_code_end_loc": [78, 397, 610, 90, 122, 546, 30, 47, 183, 61, 458, 116], "fixing_code_start_loc": [77, 396, 461, 18, 120, 19, 28, 46, 149, 60, 459, 45], "fixing_code_end_loc": [79, 397, 610, 91, 122, 548, 30, 47, 193, 62, 460, 126], "type": "CWE-290", "message": "Extensible Service Proxy, a.k.a. ESP is a proxy which enables API management capabilities for JSON/REST or gRPC API services. ESPv1 can be configured to authenticate a JWT token. Its verified JWT claim is passed to the application by HTTP header \"X-Endpoint-API-UserInfo\", the application can use it to do authorization. But if there are two \"X-Endpoint-API-UserInfo\" headers from the client, ESPv1 only replaces the first one, the 2nd one will be passed to the application. An attacker can send two \"X-Endpoint-API-UserInfo\" headers, the second one with a fake JWT claim. Application may use the fake JWT claim to do the authorization. This impacts following ESPv1 usages: 1) Users have configured ESPv1 to do JWT authentication with Google ID Token as described in the referenced google endpoint document. 2) Users backend application is using the info in the \"X-Endpoint-API-UserInfo\" header to do the authorization. It has been fixed by v1.58.0. You need to patch it in the following ways: * If your docker image is using tag \":1\", needs to re-start the container to pick up the new version. The tag \":1\" will automatically point to the latest version. * If your docker image tag pings to a specific minor version, e.g. \":1.57\". You need to update it to \":1.58\" and re-start the container. There are no workaround for this issue.", "other": {"cve": {"id": "CVE-2021-41130", "sourceIdentifier": "security-advisories@github.com", "published": "2021-10-07T19:15:08.843", "lastModified": "2021-10-18T19:17:00.347", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Extensible Service Proxy, a.k.a. ESP is a proxy which enables API management capabilities for JSON/REST or gRPC API services. ESPv1 can be configured to authenticate a JWT token. Its verified JWT claim is passed to the application by HTTP header \"X-Endpoint-API-UserInfo\", the application can use it to do authorization. But if there are two \"X-Endpoint-API-UserInfo\" headers from the client, ESPv1 only replaces the first one, the 2nd one will be passed to the application. An attacker can send two \"X-Endpoint-API-UserInfo\" headers, the second one with a fake JWT claim. Application may use the fake JWT claim to do the authorization. This impacts following ESPv1 usages: 1) Users have configured ESPv1 to do JWT authentication with Google ID Token as described in the referenced google endpoint document. 2) Users backend application is using the info in the \"X-Endpoint-API-UserInfo\" header to do the authorization. It has been fixed by v1.58.0. You need to patch it in the following ways: * If your docker image is using tag \":1\", needs to re-start the container to pick up the new version. The tag \":1\" will automatically point to the latest version. * If your docker image tag pings to a specific minor version, e.g. \":1.57\". You need to update it to \":1.58\" and re-start the container. There are no workaround for this issue."}, {"lang": "es", "value": "Extensible Service Proxy, tambi\u00e9n se conoce como ESP, es un proxy que permite la administraci\u00f3n de la API para los servicios JSON/REST o gRPC. ESPv1 puede ser configurado para autenticar un token JWT. Su reclamaci\u00f3n JWT verificada se pasa a la aplicaci\u00f3n mediante el encabezado HTTP \"X-Endpoint-API-UserInfo\", la aplicaci\u00f3n puede usarla para hacer la autorizaci\u00f3n. Pero si presenta dos encabezados \"X-Endpoint-API-UserInfo\" del cliente, ESPv1 s\u00f3lo reemplaza la primera, la segunda ser\u00e1 pasada a la aplicaci\u00f3n. Un atacante puede enviar dos encabezados \"X-Endpoint-API-UserInfo\", la segunda con una reclamaci\u00f3n JWT falsa. La aplicaci\u00f3n puede usar la reclamaci\u00f3n JWT falsa para hacer la autorizaci\u00f3n. Esto afecta a los siguientes usos de ESPv1: 1) Los usuarios han configurado ESPv1 para hacer la autenticaci\u00f3n JWT con Google ID Token como se describe en el documento de Google Endpoint referenciado. 2) La aplicaci\u00f3n backend de los usuarios usa la informaci\u00f3n del encabezado \"X-Endpoint-API-UserInfo\" para realizar la autorizaci\u00f3n. Se ha corregido en la versi\u00f3n 1.58.0. Es necesario parchearlo de las siguientes maneras: * Si su imagen docker est\u00e1 usando la etiqueta \":1\", necesita reiniciar el contenedor para recoger la nueva versi\u00f3n. La etiqueta \":1\" apuntar\u00e1 autom\u00e1ticamente a la \u00faltima versi\u00f3n. * Si la etiqueta de su imagen docker apunta a una versi\u00f3n menor espec\u00edfica, por ejemplo \":1.57\". Debe actualizarla a \":1.58\" y reiniciar el contenedor. No se presenta ninguna soluci\u00f3n para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.1, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.8, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-290"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-290"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:extensible_service_proxy:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.58.0", "matchCriteriaId": "DB5147A5-A760-4866-AA59-9D0463B68A64"}]}]}], "references": [{"url": "https://cloud.google.com/endpoints/docs/openapi/authenticating-users-google-id", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/cloudendpoints/esp/commit/e310c4f91d229a072507f80c73811489b4cdff27", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/cloudendpoints/esp/releases/tag/v1.58.0", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/cloudendpoints/esp/security/advisories/GHSA-43wx-8qmj-9r9q", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/cloudendpoints/esp/commit/e310c4f91d229a072507f80c73811489b4cdff27"}}