{"buggy_code": ["/*\n *  USB HID support for Linux\n *\n *  Copyright (c) 1999 Andreas Gal\n *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>\n *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc\n *  Copyright (c) 2007-2008 Oliver Neukum\n *  Copyright (c) 2006-2010 Jiri Kosina\n */\n\n/*\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n */\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <linux/input.h>\n#include <linux/wait.h>\n#include <linux/workqueue.h>\n#include <linux/string.h>\n\n#include <linux/usb.h>\n\n#include <linux/hid.h>\n#include <linux/hiddev.h>\n#include <linux/hid-debug.h>\n#include <linux/hidraw.h>\n#include \"usbhid.h\"\n\n/*\n * Version Information\n */\n\n#define DRIVER_DESC \"USB HID core driver\"\n\n/*\n * Module parameters.\n */\n\nstatic unsigned int hid_mousepoll_interval;\nmodule_param_named(mousepoll, hid_mousepoll_interval, uint, 0644);\nMODULE_PARM_DESC(mousepoll, \"Polling interval of mice\");\n\nstatic unsigned int hid_jspoll_interval;\nmodule_param_named(jspoll, hid_jspoll_interval, uint, 0644);\nMODULE_PARM_DESC(jspoll, \"Polling interval of joysticks\");\n\nstatic unsigned int ignoreled;\nmodule_param_named(ignoreled, ignoreled, uint, 0644);\nMODULE_PARM_DESC(ignoreled, \"Autosuspend with active leds\");\n\n/* Quirks specified at module load time */\nstatic char *quirks_param[MAX_USBHID_BOOT_QUIRKS];\nmodule_param_array_named(quirks, quirks_param, charp, NULL, 0444);\nMODULE_PARM_DESC(quirks, \"Add/modify USB HID quirks by specifying \"\n\t\t\" quirks=vendorID:productID:quirks\"\n\t\t\" where vendorID, productID, and quirks are all in\"\n\t\t\" 0x-prefixed hex\");\n/*\n * Input submission and I/O error handler.\n */\nstatic void hid_io_error(struct hid_device *hid);\nstatic int hid_submit_out(struct hid_device *hid);\nstatic int hid_submit_ctrl(struct hid_device *hid);\nstatic void hid_cancel_delayed_stuff(struct usbhid_device *usbhid);\n\n/* Start up the input URB */\nstatic int hid_start_in(struct hid_device *hid)\n{\n\tunsigned long flags;\n\tint rc = 0;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\tspin_lock_irqsave(&usbhid->lock, flags);\n\tif (test_bit(HID_IN_POLLING, &usbhid->iofl) &&\n\t    !test_bit(HID_DISCONNECTED, &usbhid->iofl) &&\n\t    !test_bit(HID_SUSPENDED, &usbhid->iofl) &&\n\t    !test_and_set_bit(HID_IN_RUNNING, &usbhid->iofl)) {\n\t\trc = usb_submit_urb(usbhid->urbin, GFP_ATOMIC);\n\t\tif (rc != 0) {\n\t\t\tclear_bit(HID_IN_RUNNING, &usbhid->iofl);\n\t\t\tif (rc == -ENOSPC)\n\t\t\t\tset_bit(HID_NO_BANDWIDTH, &usbhid->iofl);\n\t\t} else {\n\t\t\tclear_bit(HID_NO_BANDWIDTH, &usbhid->iofl);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&usbhid->lock, flags);\n\treturn rc;\n}\n\n/* I/O retry timer routine */\nstatic void hid_retry_timeout(unsigned long _hid)\n{\n\tstruct hid_device *hid = (struct hid_device *) _hid;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\tdev_dbg(&usbhid->intf->dev, \"retrying intr urb\\n\");\n\tif (hid_start_in(hid))\n\t\thid_io_error(hid);\n}\n\n/* Workqueue routine to reset the device or clear a halt */\nstatic void hid_reset(struct work_struct *work)\n{\n\tstruct usbhid_device *usbhid =\n\t\tcontainer_of(work, struct usbhid_device, reset_work);\n\tstruct hid_device *hid = usbhid->hid;\n\tint rc;\n\n\tif (test_bit(HID_CLEAR_HALT, &usbhid->iofl)) {\n\t\tdev_dbg(&usbhid->intf->dev, \"clear halt\\n\");\n\t\trc = usb_clear_halt(hid_to_usb_dev(hid), usbhid->urbin->pipe);\n\t\tclear_bit(HID_CLEAR_HALT, &usbhid->iofl);\n\t\tif (rc == 0) {\n\t\t\thid_start_in(hid);\n\t\t} else {\n\t\t\tdev_dbg(&usbhid->intf->dev,\n\t\t\t\t\t\"clear-halt failed: %d\\n\", rc);\n\t\t\tset_bit(HID_RESET_PENDING, &usbhid->iofl);\n\t\t}\n\t}\n\n\tif (test_bit(HID_RESET_PENDING, &usbhid->iofl)) {\n\t\tdev_dbg(&usbhid->intf->dev, \"resetting device\\n\");\n\t\tusb_queue_reset_device(usbhid->intf);\n\t}\n}\n\n/* Main I/O error handler */\nstatic void hid_io_error(struct hid_device *hid)\n{\n\tunsigned long flags;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\tspin_lock_irqsave(&usbhid->lock, flags);\n\n\t/* Stop when disconnected */\n\tif (test_bit(HID_DISCONNECTED, &usbhid->iofl))\n\t\tgoto done;\n\n\t/* If it has been a while since the last error, we'll assume\n\t * this a brand new error and reset the retry timeout. */\n\tif (time_after(jiffies, usbhid->stop_retry + HZ/2))\n\t\tusbhid->retry_delay = 0;\n\n\t/* When an error occurs, retry at increasing intervals */\n\tif (usbhid->retry_delay == 0) {\n\t\tusbhid->retry_delay = 13;\t/* Then 26, 52, 104, 104, ... */\n\t\tusbhid->stop_retry = jiffies + msecs_to_jiffies(1000);\n\t} else if (usbhid->retry_delay < 100)\n\t\tusbhid->retry_delay *= 2;\n\n\tif (time_after(jiffies, usbhid->stop_retry)) {\n\n\t\t/* Retries failed, so do a port reset unless we lack bandwidth*/\n\t\tif (!test_bit(HID_NO_BANDWIDTH, &usbhid->iofl)\n\t\t     && !test_and_set_bit(HID_RESET_PENDING, &usbhid->iofl)) {\n\n\t\t\tschedule_work(&usbhid->reset_work);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tmod_timer(&usbhid->io_retry,\n\t\t\tjiffies + msecs_to_jiffies(usbhid->retry_delay));\ndone:\n\tspin_unlock_irqrestore(&usbhid->lock, flags);\n}\n\nstatic void usbhid_mark_busy(struct usbhid_device *usbhid)\n{\n\tstruct usb_interface *intf = usbhid->intf;\n\n\tusb_mark_last_busy(interface_to_usbdev(intf));\n}\n\nstatic int usbhid_restart_out_queue(struct usbhid_device *usbhid)\n{\n\tstruct hid_device *hid = usb_get_intfdata(usbhid->intf);\n\tint kicked;\n\tint r;\n\n\tif (!hid || test_bit(HID_RESET_PENDING, &usbhid->iofl) ||\n\t\t\ttest_bit(HID_SUSPENDED, &usbhid->iofl))\n\t\treturn 0;\n\n\tif ((kicked = (usbhid->outhead != usbhid->outtail))) {\n\t\thid_dbg(hid, \"Kicking head %d tail %d\", usbhid->outhead, usbhid->outtail);\n\n\t\t/* Try to wake up from autosuspend... */\n\t\tr = usb_autopm_get_interface_async(usbhid->intf);\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\t/*\n\t\t * If still suspended, don't submit.  Submission will\n\t\t * occur if/when resume drains the queue.\n\t\t */\n\t\tif (test_bit(HID_SUSPENDED, &usbhid->iofl)) {\n\t\t\tusb_autopm_put_interface_no_suspend(usbhid->intf);\n\t\t\treturn r;\n\t\t}\n\n\t\t/* Asynchronously flush queue. */\n\t\tset_bit(HID_OUT_RUNNING, &usbhid->iofl);\n\t\tif (hid_submit_out(hid)) {\n\t\t\tclear_bit(HID_OUT_RUNNING, &usbhid->iofl);\n\t\t\tusb_autopm_put_interface_async(usbhid->intf);\n\t\t}\n\t\twake_up(&usbhid->wait);\n\t}\n\treturn kicked;\n}\n\nstatic int usbhid_restart_ctrl_queue(struct usbhid_device *usbhid)\n{\n\tstruct hid_device *hid = usb_get_intfdata(usbhid->intf);\n\tint kicked;\n\tint r;\n\n\tWARN_ON(hid == NULL);\n\tif (!hid || test_bit(HID_RESET_PENDING, &usbhid->iofl) ||\n\t\t\ttest_bit(HID_SUSPENDED, &usbhid->iofl))\n\t\treturn 0;\n\n\tif ((kicked = (usbhid->ctrlhead != usbhid->ctrltail))) {\n\t\thid_dbg(hid, \"Kicking head %d tail %d\", usbhid->ctrlhead, usbhid->ctrltail);\n\n\t\t/* Try to wake up from autosuspend... */\n\t\tr = usb_autopm_get_interface_async(usbhid->intf);\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\t/*\n\t\t * If still suspended, don't submit.  Submission will\n\t\t * occur if/when resume drains the queue.\n\t\t */\n\t\tif (test_bit(HID_SUSPENDED, &usbhid->iofl)) {\n\t\t\tusb_autopm_put_interface_no_suspend(usbhid->intf);\n\t\t\treturn r;\n\t\t}\n\n\t\t/* Asynchronously flush queue. */\n\t\tset_bit(HID_CTRL_RUNNING, &usbhid->iofl);\n\t\tif (hid_submit_ctrl(hid)) {\n\t\t\tclear_bit(HID_CTRL_RUNNING, &usbhid->iofl);\n\t\t\tusb_autopm_put_interface_async(usbhid->intf);\n\t\t}\n\t\twake_up(&usbhid->wait);\n\t}\n\treturn kicked;\n}\n\n/*\n * Input interrupt completion handler.\n */\n\nstatic void hid_irq_in(struct urb *urb)\n{\n\tstruct hid_device\t*hid = urb->context;\n\tstruct usbhid_device\t*usbhid = hid->driver_data;\n\tint\t\t\tstatus;\n\n\tswitch (urb->status) {\n\tcase 0:\t\t\t/* success */\n\t\tusbhid->retry_delay = 0;\n\t\tif (!test_bit(HID_OPENED, &usbhid->iofl))\n\t\t\tbreak;\n\t\tusbhid_mark_busy(usbhid);\n\t\tif (!test_bit(HID_RESUME_RUNNING, &usbhid->iofl)) {\n\t\t\thid_input_report(urb->context, HID_INPUT_REPORT,\n\t\t\t\t\t urb->transfer_buffer,\n\t\t\t\t\t urb->actual_length, 1);\n\t\t\t/*\n\t\t\t * autosuspend refused while keys are pressed\n\t\t\t * because most keyboards don't wake up when\n\t\t\t * a key is released\n\t\t\t */\n\t\t\tif (hid_check_keys_pressed(hid))\n\t\t\t\tset_bit(HID_KEYS_PRESSED, &usbhid->iofl);\n\t\t\telse\n\t\t\t\tclear_bit(HID_KEYS_PRESSED, &usbhid->iofl);\n\t\t}\n\t\tbreak;\n\tcase -EPIPE:\t\t/* stall */\n\t\tusbhid_mark_busy(usbhid);\n\t\tclear_bit(HID_IN_RUNNING, &usbhid->iofl);\n\t\tset_bit(HID_CLEAR_HALT, &usbhid->iofl);\n\t\tschedule_work(&usbhid->reset_work);\n\t\treturn;\n\tcase -ECONNRESET:\t/* unlink */\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\t/* unplug */\n\t\tclear_bit(HID_IN_RUNNING, &usbhid->iofl);\n\t\treturn;\n\tcase -EILSEQ:\t\t/* protocol error or unplug */\n\tcase -EPROTO:\t\t/* protocol error or unplug */\n\tcase -ETIME:\t\t/* protocol error or unplug */\n\tcase -ETIMEDOUT:\t/* Should never happen, but... */\n\t\tusbhid_mark_busy(usbhid);\n\t\tclear_bit(HID_IN_RUNNING, &usbhid->iofl);\n\t\thid_io_error(hid);\n\t\treturn;\n\tdefault:\t\t/* error */\n\t\thid_warn(urb->dev, \"input irq status %d received\\n\",\n\t\t\t urb->status);\n\t}\n\n\tstatus = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (status) {\n\t\tclear_bit(HID_IN_RUNNING, &usbhid->iofl);\n\t\tif (status != -EPERM) {\n\t\t\thid_err(hid, \"can't resubmit intr, %s-%s/input%d, status %d\\n\",\n\t\t\t\thid_to_usb_dev(hid)->bus->bus_name,\n\t\t\t\thid_to_usb_dev(hid)->devpath,\n\t\t\t\tusbhid->ifnum, status);\n\t\t\thid_io_error(hid);\n\t\t}\n\t}\n}\n\nstatic int hid_submit_out(struct hid_device *hid)\n{\n\tstruct hid_report *report;\n\tchar *raw_report;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tint r;\n\n\treport = usbhid->out[usbhid->outtail].report;\n\traw_report = usbhid->out[usbhid->outtail].raw_report;\n\n\tusbhid->urbout->transfer_buffer_length = hid_report_len(report);\n\tusbhid->urbout->dev = hid_to_usb_dev(hid);\n\tif (raw_report) {\n\t\tmemcpy(usbhid->outbuf, raw_report,\n\t\t\t\tusbhid->urbout->transfer_buffer_length);\n\t\tkfree(raw_report);\n\t\tusbhid->out[usbhid->outtail].raw_report = NULL;\n\t}\n\n\tdbg_hid(\"submitting out urb\\n\");\n\n\tr = usb_submit_urb(usbhid->urbout, GFP_ATOMIC);\n\tif (r < 0) {\n\t\thid_err(hid, \"usb_submit_urb(out) failed: %d\\n\", r);\n\t\treturn r;\n\t}\n\tusbhid->last_out = jiffies;\n\treturn 0;\n}\n\nstatic int hid_submit_ctrl(struct hid_device *hid)\n{\n\tstruct hid_report *report;\n\tunsigned char dir;\n\tchar *raw_report;\n\tint len, r;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\treport = usbhid->ctrl[usbhid->ctrltail].report;\n\traw_report = usbhid->ctrl[usbhid->ctrltail].raw_report;\n\tdir = usbhid->ctrl[usbhid->ctrltail].dir;\n\n\tlen = ((report->size - 1) >> 3) + 1 + (report->id > 0);\n\tif (dir == USB_DIR_OUT) {\n\t\tusbhid->urbctrl->pipe = usb_sndctrlpipe(hid_to_usb_dev(hid), 0);\n\t\tusbhid->urbctrl->transfer_buffer_length = len;\n\t\tif (raw_report) {\n\t\t\tmemcpy(usbhid->ctrlbuf, raw_report, len);\n\t\t\tkfree(raw_report);\n\t\t\tusbhid->ctrl[usbhid->ctrltail].raw_report = NULL;\n\t\t}\n\t} else {\n\t\tint maxpacket, padlen;\n\n\t\tusbhid->urbctrl->pipe = usb_rcvctrlpipe(hid_to_usb_dev(hid), 0);\n\t\tmaxpacket = usb_maxpacket(hid_to_usb_dev(hid),\n\t\t\t\t\t  usbhid->urbctrl->pipe, 0);\n\t\tif (maxpacket > 0) {\n\t\t\tpadlen = DIV_ROUND_UP(len, maxpacket);\n\t\t\tpadlen *= maxpacket;\n\t\t\tif (padlen > usbhid->bufsize)\n\t\t\t\tpadlen = usbhid->bufsize;\n\t\t} else\n\t\t\tpadlen = 0;\n\t\tusbhid->urbctrl->transfer_buffer_length = padlen;\n\t}\n\tusbhid->urbctrl->dev = hid_to_usb_dev(hid);\n\n\tusbhid->cr->bRequestType = USB_TYPE_CLASS | USB_RECIP_INTERFACE | dir;\n\tusbhid->cr->bRequest = (dir == USB_DIR_OUT) ? HID_REQ_SET_REPORT :\n\t\t\t\t\t\t      HID_REQ_GET_REPORT;\n\tusbhid->cr->wValue = cpu_to_le16(((report->type + 1) << 8) |\n\t\t\t\t\t report->id);\n\tusbhid->cr->wIndex = cpu_to_le16(usbhid->ifnum);\n\tusbhid->cr->wLength = cpu_to_le16(len);\n\n\tdbg_hid(\"submitting ctrl urb: %s wValue=0x%04x wIndex=0x%04x wLength=%u\\n\",\n\t\tusbhid->cr->bRequest == HID_REQ_SET_REPORT ? \"Set_Report\" :\n\t\t\t\t\t\t\t     \"Get_Report\",\n\t\tusbhid->cr->wValue, usbhid->cr->wIndex, usbhid->cr->wLength);\n\n\tr = usb_submit_urb(usbhid->urbctrl, GFP_ATOMIC);\n\tif (r < 0) {\n\t\thid_err(hid, \"usb_submit_urb(ctrl) failed: %d\\n\", r);\n\t\treturn r;\n\t}\n\tusbhid->last_ctrl = jiffies;\n\treturn 0;\n}\n\n/*\n * Output interrupt completion handler.\n */\n\nstatic void hid_irq_out(struct urb *urb)\n{\n\tstruct hid_device *hid = urb->context;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tunsigned long flags;\n\tint unplug = 0;\n\n\tswitch (urb->status) {\n\tcase 0:\t\t\t/* success */\n\t\tbreak;\n\tcase -ESHUTDOWN:\t/* unplug */\n\t\tunplug = 1;\n\tcase -EILSEQ:\t\t/* protocol error or unplug */\n\tcase -EPROTO:\t\t/* protocol error or unplug */\n\tcase -ECONNRESET:\t/* unlink */\n\tcase -ENOENT:\n\t\tbreak;\n\tdefault:\t\t/* error */\n\t\thid_warn(urb->dev, \"output irq status %d received\\n\",\n\t\t\t urb->status);\n\t}\n\n\tspin_lock_irqsave(&usbhid->lock, flags);\n\n\tif (unplug) {\n\t\tusbhid->outtail = usbhid->outhead;\n\t} else {\n\t\tusbhid->outtail = (usbhid->outtail + 1) & (HID_OUTPUT_FIFO_SIZE - 1);\n\n\t\tif (usbhid->outhead != usbhid->outtail &&\n\t\t\t\thid_submit_out(hid) == 0) {\n\t\t\t/* Successfully submitted next urb in queue */\n\t\t\tspin_unlock_irqrestore(&usbhid->lock, flags);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tclear_bit(HID_OUT_RUNNING, &usbhid->iofl);\n\tspin_unlock_irqrestore(&usbhid->lock, flags);\n\tusb_autopm_put_interface_async(usbhid->intf);\n\twake_up(&usbhid->wait);\n}\n\n/*\n * Control pipe completion handler.\n */\n\nstatic void hid_ctrl(struct urb *urb)\n{\n\tstruct hid_device *hid = urb->context;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tint unplug = 0, status = urb->status;\n\n\tswitch (status) {\n\tcase 0:\t\t\t/* success */\n\t\tif (usbhid->ctrl[usbhid->ctrltail].dir == USB_DIR_IN)\n\t\t\thid_input_report(urb->context,\n\t\t\t\tusbhid->ctrl[usbhid->ctrltail].report->type,\n\t\t\t\turb->transfer_buffer, urb->actual_length, 0);\n\t\tbreak;\n\tcase -ESHUTDOWN:\t/* unplug */\n\t\tunplug = 1;\n\tcase -EILSEQ:\t\t/* protocol error or unplug */\n\tcase -EPROTO:\t\t/* protocol error or unplug */\n\tcase -ECONNRESET:\t/* unlink */\n\tcase -ENOENT:\n\tcase -EPIPE:\t\t/* report not available */\n\t\tbreak;\n\tdefault:\t\t/* error */\n\t\thid_warn(urb->dev, \"ctrl urb status %d received\\n\", status);\n\t}\n\n\tspin_lock(&usbhid->lock);\n\n\tif (unplug) {\n\t\tusbhid->ctrltail = usbhid->ctrlhead;\n\t} else {\n\t\tusbhid->ctrltail = (usbhid->ctrltail + 1) & (HID_CONTROL_FIFO_SIZE - 1);\n\n\t\tif (usbhid->ctrlhead != usbhid->ctrltail &&\n\t\t\t\thid_submit_ctrl(hid) == 0) {\n\t\t\t/* Successfully submitted next urb in queue */\n\t\t\tspin_unlock(&usbhid->lock);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tclear_bit(HID_CTRL_RUNNING, &usbhid->iofl);\n\tspin_unlock(&usbhid->lock);\n\tusb_autopm_put_interface_async(usbhid->intf);\n\twake_up(&usbhid->wait);\n}\n\nstatic void __usbhid_submit_report(struct hid_device *hid, struct hid_report *report,\n\t\t\t\t   unsigned char dir)\n{\n\tint head;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\tif (((hid->quirks & HID_QUIRK_NOGET) && dir == USB_DIR_IN) ||\n\t\ttest_bit(HID_DISCONNECTED, &usbhid->iofl))\n\t\treturn;\n\n\tif (usbhid->urbout && dir == USB_DIR_OUT && report->type == HID_OUTPUT_REPORT) {\n\t\tif ((head = (usbhid->outhead + 1) & (HID_OUTPUT_FIFO_SIZE - 1)) == usbhid->outtail) {\n\t\t\thid_warn(hid, \"output queue full\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tusbhid->out[usbhid->outhead].raw_report = hid_alloc_report_buf(report, GFP_ATOMIC);\n\t\tif (!usbhid->out[usbhid->outhead].raw_report) {\n\t\t\thid_warn(hid, \"output queueing failed\\n\");\n\t\t\treturn;\n\t\t}\n\t\thid_output_report(report, usbhid->out[usbhid->outhead].raw_report);\n\t\tusbhid->out[usbhid->outhead].report = report;\n\t\tusbhid->outhead = head;\n\n\t\t/* If the queue isn't running, restart it */\n\t\tif (!test_bit(HID_OUT_RUNNING, &usbhid->iofl)) {\n\t\t\tusbhid_restart_out_queue(usbhid);\n\n\t\t/* Otherwise see if an earlier request has timed out */\n\t\t} else if (time_after(jiffies, usbhid->last_out + HZ * 5)) {\n\n\t\t\t/* Prevent autosuspend following the unlink */\n\t\t\tusb_autopm_get_interface_no_resume(usbhid->intf);\n\n\t\t\t/*\n\t\t\t * Prevent resubmission in case the URB completes\n\t\t\t * before we can unlink it.  We don't want to cancel\n\t\t\t * the wrong transfer!\n\t\t\t */\n\t\t\tusb_block_urb(usbhid->urbout);\n\n\t\t\t/* Drop lock to avoid deadlock if the callback runs */\n\t\t\tspin_unlock(&usbhid->lock);\n\n\t\t\tusb_unlink_urb(usbhid->urbout);\n\t\t\tspin_lock(&usbhid->lock);\n\t\t\tusb_unblock_urb(usbhid->urbout);\n\n\t\t\t/* Unlink might have stopped the queue */\n\t\t\tif (!test_bit(HID_OUT_RUNNING, &usbhid->iofl))\n\t\t\t\tusbhid_restart_out_queue(usbhid);\n\n\t\t\t/* Now we can allow autosuspend again */\n\t\t\tusb_autopm_put_interface_async(usbhid->intf);\n\t\t}\n\t\treturn;\n\t}\n\n\tif ((head = (usbhid->ctrlhead + 1) & (HID_CONTROL_FIFO_SIZE - 1)) == usbhid->ctrltail) {\n\t\thid_warn(hid, \"control queue full\\n\");\n\t\treturn;\n\t}\n\n\tif (dir == USB_DIR_OUT) {\n\t\tusbhid->ctrl[usbhid->ctrlhead].raw_report = hid_alloc_report_buf(report, GFP_ATOMIC);\n\t\tif (!usbhid->ctrl[usbhid->ctrlhead].raw_report) {\n\t\t\thid_warn(hid, \"control queueing failed\\n\");\n\t\t\treturn;\n\t\t}\n\t\thid_output_report(report, usbhid->ctrl[usbhid->ctrlhead].raw_report);\n\t}\n\tusbhid->ctrl[usbhid->ctrlhead].report = report;\n\tusbhid->ctrl[usbhid->ctrlhead].dir = dir;\n\tusbhid->ctrlhead = head;\n\n\t/* If the queue isn't running, restart it */\n\tif (!test_bit(HID_CTRL_RUNNING, &usbhid->iofl)) {\n\t\tusbhid_restart_ctrl_queue(usbhid);\n\n\t/* Otherwise see if an earlier request has timed out */\n\t} else if (time_after(jiffies, usbhid->last_ctrl + HZ * 5)) {\n\n\t\t/* Prevent autosuspend following the unlink */\n\t\tusb_autopm_get_interface_no_resume(usbhid->intf);\n\n\t\t/*\n\t\t * Prevent resubmission in case the URB completes\n\t\t * before we can unlink it.  We don't want to cancel\n\t\t * the wrong transfer!\n\t\t */\n\t\tusb_block_urb(usbhid->urbctrl);\n\n\t\t/* Drop lock to avoid deadlock if the callback runs */\n\t\tspin_unlock(&usbhid->lock);\n\n\t\tusb_unlink_urb(usbhid->urbctrl);\n\t\tspin_lock(&usbhid->lock);\n\t\tusb_unblock_urb(usbhid->urbctrl);\n\n\t\t/* Unlink might have stopped the queue */\n\t\tif (!test_bit(HID_CTRL_RUNNING, &usbhid->iofl))\n\t\t\tusbhid_restart_ctrl_queue(usbhid);\n\n\t\t/* Now we can allow autosuspend again */\n\t\tusb_autopm_put_interface_async(usbhid->intf);\n\t}\n}\n\nstatic void usbhid_submit_report(struct hid_device *hid, struct hid_report *report, unsigned char dir)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&usbhid->lock, flags);\n\t__usbhid_submit_report(hid, report, dir);\n\tspin_unlock_irqrestore(&usbhid->lock, flags);\n}\n\nstatic int usbhid_wait_io(struct hid_device *hid)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\tif (!wait_event_timeout(usbhid->wait,\n\t\t\t\t(!test_bit(HID_CTRL_RUNNING, &usbhid->iofl) &&\n\t\t\t\t!test_bit(HID_OUT_RUNNING, &usbhid->iofl)),\n\t\t\t\t\t10*HZ)) {\n\t\tdbg_hid(\"timeout waiting for ctrl or out queue to clear\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int hid_set_idle(struct usb_device *dev, int ifnum, int report, int idle)\n{\n\treturn usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\tHID_REQ_SET_IDLE, USB_TYPE_CLASS | USB_RECIP_INTERFACE, (idle << 8) | report,\n\t\tifnum, NULL, 0, USB_CTRL_SET_TIMEOUT);\n}\n\nstatic int hid_get_class_descriptor(struct usb_device *dev, int ifnum,\n\t\tunsigned char type, void *buf, int size)\n{\n\tint result, retries = 4;\n\n\tmemset(buf, 0, size);\n\n\tdo {\n\t\tresult = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t\tUSB_REQ_GET_DESCRIPTOR, USB_RECIP_INTERFACE | USB_DIR_IN,\n\t\t\t\t(type << 8), ifnum, buf, size, USB_CTRL_GET_TIMEOUT);\n\t\tretries--;\n\t} while (result < size && retries);\n\treturn result;\n}\n\nstatic int usbhid_open(struct hid_device *hid)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tint res;\n\n\tset_bit(HID_OPENED, &usbhid->iofl);\n\n\tif (hid->quirks & HID_QUIRK_ALWAYS_POLL)\n\t\treturn 0;\n\n\tres = usb_autopm_get_interface(usbhid->intf);\n\t/* the device must be awake to reliably request remote wakeup */\n\tif (res < 0) {\n\t\tclear_bit(HID_OPENED, &usbhid->iofl);\n\t\treturn -EIO;\n\t}\n\n\tusbhid->intf->needs_remote_wakeup = 1;\n\n\tset_bit(HID_RESUME_RUNNING, &usbhid->iofl);\n\tset_bit(HID_IN_POLLING, &usbhid->iofl);\n\n\tres = hid_start_in(hid);\n\tif (res) {\n\t\tif (res != -ENOSPC) {\n\t\t\thid_io_error(hid);\n\t\t\tres = 0;\n\t\t} else {\n\t\t\t/* no use opening if resources are insufficient */\n\t\t\tres = -EBUSY;\n\t\t\tclear_bit(HID_OPENED, &usbhid->iofl);\n\t\t\tclear_bit(HID_IN_POLLING, &usbhid->iofl);\n\t\t\tusbhid->intf->needs_remote_wakeup = 0;\n\t\t}\n\t}\n\n\tusb_autopm_put_interface(usbhid->intf);\n\n\t/*\n\t * In case events are generated while nobody was listening,\n\t * some are released when the device is re-opened.\n\t * Wait 50 msec for the queue to empty before allowing events\n\t * to go through hid.\n\t */\n\tif (res == 0)\n\t\tmsleep(50);\n\n\tclear_bit(HID_RESUME_RUNNING, &usbhid->iofl);\n\treturn res;\n}\n\nstatic void usbhid_close(struct hid_device *hid)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\t/*\n\t * Make sure we don't restart data acquisition due to\n\t * a resumption we no longer care about by avoiding racing\n\t * with hid_start_in().\n\t */\n\tspin_lock_irq(&usbhid->lock);\n\tclear_bit(HID_OPENED, &usbhid->iofl);\n\tif (!(hid->quirks & HID_QUIRK_ALWAYS_POLL))\n\t\tclear_bit(HID_IN_POLLING, &usbhid->iofl);\n\tspin_unlock_irq(&usbhid->lock);\n\n\tif (hid->quirks & HID_QUIRK_ALWAYS_POLL)\n\t\treturn;\n\n\thid_cancel_delayed_stuff(usbhid);\n\tusb_kill_urb(usbhid->urbin);\n\tusbhid->intf->needs_remote_wakeup = 0;\n}\n\n/*\n * Initialize all reports\n */\n\nvoid usbhid_init_reports(struct hid_device *hid)\n{\n\tstruct hid_report *report;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tstruct hid_report_enum *report_enum;\n\tint err, ret;\n\n\treport_enum = &hid->report_enum[HID_INPUT_REPORT];\n\tlist_for_each_entry(report, &report_enum->report_list, list)\n\t\tusbhid_submit_report(hid, report, USB_DIR_IN);\n\n\treport_enum = &hid->report_enum[HID_FEATURE_REPORT];\n\tlist_for_each_entry(report, &report_enum->report_list, list)\n\t\tusbhid_submit_report(hid, report, USB_DIR_IN);\n\n\terr = 0;\n\tret = usbhid_wait_io(hid);\n\twhile (ret) {\n\t\terr |= ret;\n\t\tif (test_bit(HID_CTRL_RUNNING, &usbhid->iofl))\n\t\t\tusb_kill_urb(usbhid->urbctrl);\n\t\tif (test_bit(HID_OUT_RUNNING, &usbhid->iofl))\n\t\t\tusb_kill_urb(usbhid->urbout);\n\t\tret = usbhid_wait_io(hid);\n\t}\n\n\tif (err)\n\t\thid_warn(hid, \"timeout initializing reports\\n\");\n}\n\n/*\n * Reset LEDs which BIOS might have left on. For now, just NumLock (0x01).\n */\nstatic int hid_find_field_early(struct hid_device *hid, unsigned int page,\n    unsigned int hid_code, struct hid_field **pfield)\n{\n\tstruct hid_report *report;\n\tstruct hid_field *field;\n\tstruct hid_usage *usage;\n\tint i, j;\n\n\tlist_for_each_entry(report, &hid->report_enum[HID_OUTPUT_REPORT].report_list, list) {\n\t\tfor (i = 0; i < report->maxfield; i++) {\n\t\t\tfield = report->field[i];\n\t\t\tfor (j = 0; j < field->maxusage; j++) {\n\t\t\t\tusage = &field->usage[j];\n\t\t\t\tif ((usage->hid & HID_USAGE_PAGE) == page &&\n\t\t\t\t    (usage->hid & 0xFFFF) == hid_code) {\n\t\t\t\t\t*pfield = field;\n\t\t\t\t\treturn j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic void usbhid_set_leds(struct hid_device *hid)\n{\n\tstruct hid_field *field;\n\tint offset;\n\n\tif ((offset = hid_find_field_early(hid, HID_UP_LED, 0x01, &field)) != -1) {\n\t\thid_set_field(field, offset, 0);\n\t\tusbhid_submit_report(hid, field->report, USB_DIR_OUT);\n\t}\n}\n\n/*\n * Traverse the supplied list of reports and find the longest\n */\nstatic void hid_find_max_report(struct hid_device *hid, unsigned int type,\n\t\tunsigned int *max)\n{\n\tstruct hid_report *report;\n\tunsigned int size;\n\n\tlist_for_each_entry(report, &hid->report_enum[type].report_list, list) {\n\t\tsize = ((report->size - 1) >> 3) + 1 + hid->report_enum[type].numbered;\n\t\tif (*max < size)\n\t\t\t*max = size;\n\t}\n}\n\nstatic int hid_alloc_buffers(struct usb_device *dev, struct hid_device *hid)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\tusbhid->inbuf = usb_alloc_coherent(dev, usbhid->bufsize, GFP_KERNEL,\n\t\t\t&usbhid->inbuf_dma);\n\tusbhid->outbuf = usb_alloc_coherent(dev, usbhid->bufsize, GFP_KERNEL,\n\t\t\t&usbhid->outbuf_dma);\n\tusbhid->cr = kmalloc(sizeof(*usbhid->cr), GFP_KERNEL);\n\tusbhid->ctrlbuf = usb_alloc_coherent(dev, usbhid->bufsize, GFP_KERNEL,\n\t\t\t&usbhid->ctrlbuf_dma);\n\tif (!usbhid->inbuf || !usbhid->outbuf || !usbhid->cr ||\n\t\t\t!usbhid->ctrlbuf)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int usbhid_get_raw_report(struct hid_device *hid,\n\t\tunsigned char report_number, __u8 *buf, size_t count,\n\t\tunsigned char report_type)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tstruct usb_device *dev = hid_to_usb_dev(hid);\n\tstruct usb_interface *intf = usbhid->intf;\n\tstruct usb_host_interface *interface = intf->cur_altsetting;\n\tint skipped_report_id = 0;\n\tint ret;\n\n\t/* Byte 0 is the report number. Report data starts at byte 1.*/\n\tbuf[0] = report_number;\n\tif (report_number == 0x0) {\n\t\t/* Offset the return buffer by 1, so that the report ID\n\t\t   will remain in byte 0. */\n\t\tbuf++;\n\t\tcount--;\n\t\tskipped_report_id = 1;\n\t}\n\tret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\tHID_REQ_GET_REPORT,\n\t\tUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t((report_type + 1) << 8) | report_number,\n\t\tinterface->desc.bInterfaceNumber, buf, count,\n\t\tUSB_CTRL_SET_TIMEOUT);\n\n\t/* count also the report id */\n\tif (ret > 0 && skipped_report_id)\n\t\tret++;\n\n\treturn ret;\n}\n\nstatic int usbhid_set_raw_report(struct hid_device *hid, unsigned int reportnum,\n\t\t\t\t __u8 *buf, size_t count, unsigned char rtype)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tstruct usb_device *dev = hid_to_usb_dev(hid);\n\tstruct usb_interface *intf = usbhid->intf;\n\tstruct usb_host_interface *interface = intf->cur_altsetting;\n\tint ret, skipped_report_id = 0;\n\n\t/* Byte 0 is the report number. Report data starts at byte 1.*/\n\tif ((rtype == HID_OUTPUT_REPORT) &&\n\t    (hid->quirks & HID_QUIRK_SKIP_OUTPUT_REPORT_ID))\n\t\tbuf[0] = 0;\n\telse\n\t\tbuf[0] = reportnum;\n\n\tif (buf[0] == 0x0) {\n\t\t/* Don't send the Report ID */\n\t\tbuf++;\n\t\tcount--;\n\t\tskipped_report_id = 1;\n\t}\n\n\tret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\tHID_REQ_SET_REPORT,\n\t\t\tUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\t((rtype + 1) << 8) | reportnum,\n\t\t\tinterface->desc.bInterfaceNumber, buf, count,\n\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t/* count also the report id, if this was a numbered report. */\n\tif (ret > 0 && skipped_report_id)\n\t\tret++;\n\n\treturn ret;\n}\n\nstatic int usbhid_output_report(struct hid_device *hid, __u8 *buf, size_t count)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tstruct usb_device *dev = hid_to_usb_dev(hid);\n\tint actual_length, skipped_report_id = 0, ret;\n\n\tif (!usbhid->urbout)\n\t\treturn -ENOSYS;\n\n\tif (buf[0] == 0x0) {\n\t\t/* Don't send the Report ID */\n\t\tbuf++;\n\t\tcount--;\n\t\tskipped_report_id = 1;\n\t}\n\n\tret = usb_interrupt_msg(dev, usbhid->urbout->pipe,\n\t\t\t\tbuf, count, &actual_length,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t/* return the number of bytes transferred */\n\tif (ret == 0) {\n\t\tret = actual_length;\n\t\t/* count also the report id */\n\t\tif (skipped_report_id)\n\t\t\tret++;\n\t}\n\n\treturn ret;\n}\n\nstatic void hid_free_buffers(struct usb_device *dev, struct hid_device *hid)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\tusb_free_coherent(dev, usbhid->bufsize, usbhid->inbuf, usbhid->inbuf_dma);\n\tusb_free_coherent(dev, usbhid->bufsize, usbhid->outbuf, usbhid->outbuf_dma);\n\tkfree(usbhid->cr);\n\tusb_free_coherent(dev, usbhid->bufsize, usbhid->ctrlbuf, usbhid->ctrlbuf_dma);\n}\n\nstatic int usbhid_parse(struct hid_device *hid)\n{\n\tstruct usb_interface *intf = to_usb_interface(hid->dev.parent);\n\tstruct usb_host_interface *interface = intf->cur_altsetting;\n\tstruct usb_device *dev = interface_to_usbdev (intf);\n\tstruct hid_descriptor *hdesc;\n\tu32 quirks = 0;\n\tunsigned int rsize = 0;\n\tchar *rdesc;\n\tint ret, n;\n\n\tquirks = usbhid_lookup_quirk(le16_to_cpu(dev->descriptor.idVendor),\n\t\t\tle16_to_cpu(dev->descriptor.idProduct));\n\n\tif (quirks & HID_QUIRK_IGNORE)\n\t\treturn -ENODEV;\n\n\t/* Many keyboards and mice don't like to be polled for reports,\n\t * so we will always set the HID_QUIRK_NOGET flag for them. */\n\tif (interface->desc.bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT) {\n\t\tif (interface->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD ||\n\t\t\tinterface->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE)\n\t\t\t\tquirks |= HID_QUIRK_NOGET;\n\t}\n\n\tif (usb_get_extra_descriptor(interface, HID_DT_HID, &hdesc) &&\n\t    (!interface->desc.bNumEndpoints ||\n\t     usb_get_extra_descriptor(&interface->endpoint[0], HID_DT_HID, &hdesc))) {\n\t\tdbg_hid(\"class descriptor not present\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\thid->version = le16_to_cpu(hdesc->bcdHID);\n\thid->country = hdesc->bCountryCode;\n\n\tfor (n = 0; n < hdesc->bNumDescriptors; n++)\n\t\tif (hdesc->desc[n].bDescriptorType == HID_DT_REPORT)\n\t\t\trsize = le16_to_cpu(hdesc->desc[n].wDescriptorLength);\n\n\tif (!rsize || rsize > HID_MAX_DESCRIPTOR_SIZE) {\n\t\tdbg_hid(\"weird size of report descriptor (%u)\\n\", rsize);\n\t\treturn -EINVAL;\n\t}\n\n\trdesc = kmalloc(rsize, GFP_KERNEL);\n\tif (!rdesc)\n\t\treturn -ENOMEM;\n\n\thid_set_idle(dev, interface->desc.bInterfaceNumber, 0, 0);\n\n\tret = hid_get_class_descriptor(dev, interface->desc.bInterfaceNumber,\n\t\t\tHID_DT_REPORT, rdesc, rsize);\n\tif (ret < 0) {\n\t\tdbg_hid(\"reading report descriptor failed\\n\");\n\t\tkfree(rdesc);\n\t\tgoto err;\n\t}\n\n\tret = hid_parse_report(hid, rdesc, rsize);\n\tkfree(rdesc);\n\tif (ret) {\n\t\tdbg_hid(\"parsing report descriptor failed\\n\");\n\t\tgoto err;\n\t}\n\n\thid->quirks |= quirks;\n\n\treturn 0;\nerr:\n\treturn ret;\n}\n\nstatic int usbhid_start(struct hid_device *hid)\n{\n\tstruct usb_interface *intf = to_usb_interface(hid->dev.parent);\n\tstruct usb_host_interface *interface = intf->cur_altsetting;\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tunsigned int n, insize = 0;\n\tint ret;\n\n\tclear_bit(HID_DISCONNECTED, &usbhid->iofl);\n\n\tusbhid->bufsize = HID_MIN_BUFFER_SIZE;\n\thid_find_max_report(hid, HID_INPUT_REPORT, &usbhid->bufsize);\n\thid_find_max_report(hid, HID_OUTPUT_REPORT, &usbhid->bufsize);\n\thid_find_max_report(hid, HID_FEATURE_REPORT, &usbhid->bufsize);\n\n\tif (usbhid->bufsize > HID_MAX_BUFFER_SIZE)\n\t\tusbhid->bufsize = HID_MAX_BUFFER_SIZE;\n\n\thid_find_max_report(hid, HID_INPUT_REPORT, &insize);\n\n\tif (insize > HID_MAX_BUFFER_SIZE)\n\t\tinsize = HID_MAX_BUFFER_SIZE;\n\n\tif (hid_alloc_buffers(dev, hid)) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tfor (n = 0; n < interface->desc.bNumEndpoints; n++) {\n\t\tstruct usb_endpoint_descriptor *endpoint;\n\t\tint pipe;\n\t\tint interval;\n\n\t\tendpoint = &interface->endpoint[n].desc;\n\t\tif (!usb_endpoint_xfer_int(endpoint))\n\t\t\tcontinue;\n\n\t\tinterval = endpoint->bInterval;\n\n\t\t/* Some vendors give fullspeed interval on highspeed devides */\n\t\tif (hid->quirks & HID_QUIRK_FULLSPEED_INTERVAL &&\n\t\t    dev->speed == USB_SPEED_HIGH) {\n\t\t\tinterval = fls(endpoint->bInterval*8);\n\t\t\tpr_info(\"%s: Fixing fullspeed to highspeed interval: %d -> %d\\n\",\n\t\t\t\thid->name, endpoint->bInterval, interval);\n\t\t}\n\n\t\t/* Change the polling interval of mice and joysticks. */\n\t\tswitch (hid->collection->usage) {\n\t\tcase HID_GD_MOUSE:\n\t\t\tif (hid_mousepoll_interval > 0)\n\t\t\t\tinterval = hid_mousepoll_interval;\n\t\t\tbreak;\n\t\tcase HID_GD_JOYSTICK:\n\t\t\tif (hid_jspoll_interval > 0)\n\t\t\t\tinterval = hid_jspoll_interval;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = -ENOMEM;\n\t\tif (usb_endpoint_dir_in(endpoint)) {\n\t\t\tif (usbhid->urbin)\n\t\t\t\tcontinue;\n\t\t\tif (!(usbhid->urbin = usb_alloc_urb(0, GFP_KERNEL)))\n\t\t\t\tgoto fail;\n\t\t\tpipe = usb_rcvintpipe(dev, endpoint->bEndpointAddress);\n\t\t\tusb_fill_int_urb(usbhid->urbin, dev, pipe, usbhid->inbuf, insize,\n\t\t\t\t\t hid_irq_in, hid, interval);\n\t\t\tusbhid->urbin->transfer_dma = usbhid->inbuf_dma;\n\t\t\tusbhid->urbin->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\t\t} else {\n\t\t\tif (usbhid->urbout)\n\t\t\t\tcontinue;\n\t\t\tif (!(usbhid->urbout = usb_alloc_urb(0, GFP_KERNEL)))\n\t\t\t\tgoto fail;\n\t\t\tpipe = usb_sndintpipe(dev, endpoint->bEndpointAddress);\n\t\t\tusb_fill_int_urb(usbhid->urbout, dev, pipe, usbhid->outbuf, 0,\n\t\t\t\t\t hid_irq_out, hid, interval);\n\t\t\tusbhid->urbout->transfer_dma = usbhid->outbuf_dma;\n\t\t\tusbhid->urbout->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\t\t}\n\t}\n\n\tusbhid->urbctrl = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!usbhid->urbctrl) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tusb_fill_control_urb(usbhid->urbctrl, dev, 0, (void *) usbhid->cr,\n\t\t\t     usbhid->ctrlbuf, 1, hid_ctrl, hid);\n\tusbhid->urbctrl->transfer_dma = usbhid->ctrlbuf_dma;\n\tusbhid->urbctrl->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\tset_bit(HID_STARTED, &usbhid->iofl);\n\n\tif (hid->quirks & HID_QUIRK_ALWAYS_POLL) {\n\t\tret = usb_autopm_get_interface(usbhid->intf);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t\tset_bit(HID_IN_POLLING, &usbhid->iofl);\n\t\tusbhid->intf->needs_remote_wakeup = 1;\n\t\tret = hid_start_in(hid);\n\t\tif (ret) {\n\t\t\tdev_err(&hid->dev,\n\t\t\t\t\"failed to start in urb: %d\\n\", ret);\n\t\t}\n\t\tusb_autopm_put_interface(usbhid->intf);\n\t}\n\n\t/* Some keyboards don't work until their LEDs have been set.\n\t * Since BIOSes do set the LEDs, it must be safe for any device\n\t * that supports the keyboard boot protocol.\n\t * In addition, enable remote wakeup by default for all keyboard\n\t * devices supporting the boot protocol.\n\t */\n\tif (interface->desc.bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT &&\n\t\t\tinterface->desc.bInterfaceProtocol ==\n\t\t\t\tUSB_INTERFACE_PROTOCOL_KEYBOARD) {\n\t\tusbhid_set_leds(hid);\n\t\tdevice_set_wakeup_enable(&dev->dev, 1);\n\t}\n\treturn 0;\n\nfail:\n\tusb_free_urb(usbhid->urbin);\n\tusb_free_urb(usbhid->urbout);\n\tusb_free_urb(usbhid->urbctrl);\n\tusbhid->urbin = NULL;\n\tusbhid->urbout = NULL;\n\tusbhid->urbctrl = NULL;\n\thid_free_buffers(dev, hid);\n\treturn ret;\n}\n\nstatic void usbhid_stop(struct hid_device *hid)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\tif (WARN_ON(!usbhid))\n\t\treturn;\n\n\tif (hid->quirks & HID_QUIRK_ALWAYS_POLL) {\n\t\tclear_bit(HID_IN_POLLING, &usbhid->iofl);\n\t\tusbhid->intf->needs_remote_wakeup = 0;\n\t}\n\n\tclear_bit(HID_STARTED, &usbhid->iofl);\n\tspin_lock_irq(&usbhid->lock);\t/* Sync with error and led handlers */\n\tset_bit(HID_DISCONNECTED, &usbhid->iofl);\n\tspin_unlock_irq(&usbhid->lock);\n\tusb_kill_urb(usbhid->urbin);\n\tusb_kill_urb(usbhid->urbout);\n\tusb_kill_urb(usbhid->urbctrl);\n\n\thid_cancel_delayed_stuff(usbhid);\n\n\thid->claimed = 0;\n\n\tusb_free_urb(usbhid->urbin);\n\tusb_free_urb(usbhid->urbctrl);\n\tusb_free_urb(usbhid->urbout);\n\tusbhid->urbin = NULL; /* don't mess up next start */\n\tusbhid->urbctrl = NULL;\n\tusbhid->urbout = NULL;\n\n\thid_free_buffers(hid_to_usb_dev(hid), hid);\n}\n\nstatic int usbhid_power(struct hid_device *hid, int lvl)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tint r = 0;\n\n\tswitch (lvl) {\n\tcase PM_HINT_FULLON:\n\t\tr = usb_autopm_get_interface(usbhid->intf);\n\t\tbreak;\n\n\tcase PM_HINT_NORMAL:\n\t\tusb_autopm_put_interface(usbhid->intf);\n\t\tbreak;\n\t}\n\n\treturn r;\n}\n\nstatic void usbhid_request(struct hid_device *hid, struct hid_report *rep, int reqtype)\n{\n\tswitch (reqtype) {\n\tcase HID_REQ_GET_REPORT:\n\t\tusbhid_submit_report(hid, rep, USB_DIR_IN);\n\t\tbreak;\n\tcase HID_REQ_SET_REPORT:\n\t\tusbhid_submit_report(hid, rep, USB_DIR_OUT);\n\t\tbreak;\n\t}\n}\n\nstatic int usbhid_raw_request(struct hid_device *hid, unsigned char reportnum,\n\t\t\t      __u8 *buf, size_t len, unsigned char rtype,\n\t\t\t      int reqtype)\n{\n\tswitch (reqtype) {\n\tcase HID_REQ_GET_REPORT:\n\t\treturn usbhid_get_raw_report(hid, reportnum, buf, len, rtype);\n\tcase HID_REQ_SET_REPORT:\n\t\treturn usbhid_set_raw_report(hid, reportnum, buf, len, rtype);\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\nstatic int usbhid_idle(struct hid_device *hid, int report, int idle,\n\t\tint reqtype)\n{\n\tstruct usb_device *dev = hid_to_usb_dev(hid);\n\tstruct usb_interface *intf = to_usb_interface(hid->dev.parent);\n\tstruct usb_host_interface *interface = intf->cur_altsetting;\n\tint ifnum = interface->desc.bInterfaceNumber;\n\n\tif (reqtype != HID_REQ_SET_IDLE)\n\t\treturn -EINVAL;\n\n\treturn hid_set_idle(dev, ifnum, report, idle);\n}\n\nstruct hid_ll_driver usb_hid_driver = {\n\t.parse = usbhid_parse,\n\t.start = usbhid_start,\n\t.stop = usbhid_stop,\n\t.open = usbhid_open,\n\t.close = usbhid_close,\n\t.power = usbhid_power,\n\t.request = usbhid_request,\n\t.wait = usbhid_wait_io,\n\t.raw_request = usbhid_raw_request,\n\t.output_report = usbhid_output_report,\n\t.idle = usbhid_idle,\n};\nEXPORT_SYMBOL_GPL(usb_hid_driver);\n\nstatic int usbhid_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_host_interface *interface = intf->cur_altsetting;\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct usbhid_device *usbhid;\n\tstruct hid_device *hid;\n\tunsigned int n, has_in = 0;\n\tsize_t len;\n\tint ret;\n\n\tdbg_hid(\"HID probe called for ifnum %d\\n\",\n\t\t\tintf->altsetting->desc.bInterfaceNumber);\n\n\tfor (n = 0; n < interface->desc.bNumEndpoints; n++)\n\t\tif (usb_endpoint_is_int_in(&interface->endpoint[n].desc))\n\t\t\thas_in++;\n\tif (!has_in) {\n\t\thid_err(intf, \"couldn't find an input interrupt endpoint\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\thid = hid_allocate_device();\n\tif (IS_ERR(hid))\n\t\treturn PTR_ERR(hid);\n\n\tusb_set_intfdata(intf, hid);\n\thid->ll_driver = &usb_hid_driver;\n\thid->ff_init = hid_pidff_init;\n#ifdef CONFIG_USB_HIDDEV\n\thid->hiddev_connect = hiddev_connect;\n\thid->hiddev_disconnect = hiddev_disconnect;\n\thid->hiddev_hid_event = hiddev_hid_event;\n\thid->hiddev_report_event = hiddev_report_event;\n#endif\n\thid->dev.parent = &intf->dev;\n\thid->bus = BUS_USB;\n\thid->vendor = le16_to_cpu(dev->descriptor.idVendor);\n\thid->product = le16_to_cpu(dev->descriptor.idProduct);\n\thid->name[0] = 0;\n\thid->quirks = usbhid_lookup_quirk(hid->vendor, hid->product);\n\tif (intf->cur_altsetting->desc.bInterfaceProtocol ==\n\t\t\tUSB_INTERFACE_PROTOCOL_MOUSE)\n\t\thid->type = HID_TYPE_USBMOUSE;\n\telse if (intf->cur_altsetting->desc.bInterfaceProtocol == 0)\n\t\thid->type = HID_TYPE_USBNONE;\n\n\tif (dev->manufacturer)\n\t\tstrlcpy(hid->name, dev->manufacturer, sizeof(hid->name));\n\n\tif (dev->product) {\n\t\tif (dev->manufacturer)\n\t\t\tstrlcat(hid->name, \" \", sizeof(hid->name));\n\t\tstrlcat(hid->name, dev->product, sizeof(hid->name));\n\t}\n\n\tif (!strlen(hid->name))\n\t\tsnprintf(hid->name, sizeof(hid->name), \"HID %04x:%04x\",\n\t\t\t le16_to_cpu(dev->descriptor.idVendor),\n\t\t\t le16_to_cpu(dev->descriptor.idProduct));\n\n\tusb_make_path(dev, hid->phys, sizeof(hid->phys));\n\tstrlcat(hid->phys, \"/input\", sizeof(hid->phys));\n\tlen = strlen(hid->phys);\n\tif (len < sizeof(hid->phys) - 1)\n\t\tsnprintf(hid->phys + len, sizeof(hid->phys) - len,\n\t\t\t \"%d\", intf->altsetting[0].desc.bInterfaceNumber);\n\n\tif (usb_string(dev, dev->descriptor.iSerialNumber, hid->uniq, 64) <= 0)\n\t\thid->uniq[0] = 0;\n\n\tusbhid = kzalloc(sizeof(*usbhid), GFP_KERNEL);\n\tif (usbhid == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\thid->driver_data = usbhid;\n\tusbhid->hid = hid;\n\tusbhid->intf = intf;\n\tusbhid->ifnum = interface->desc.bInterfaceNumber;\n\n\tinit_waitqueue_head(&usbhid->wait);\n\tINIT_WORK(&usbhid->reset_work, hid_reset);\n\tsetup_timer(&usbhid->io_retry, hid_retry_timeout, (unsigned long) hid);\n\tspin_lock_init(&usbhid->lock);\n\n\tret = hid_add_device(hid);\n\tif (ret) {\n\t\tif (ret != -ENODEV)\n\t\t\thid_err(intf, \"can't add hid device: %d\\n\", ret);\n\t\tgoto err_free;\n\t}\n\n\treturn 0;\nerr_free:\n\tkfree(usbhid);\nerr:\n\thid_destroy_device(hid);\n\treturn ret;\n}\n\nstatic void usbhid_disconnect(struct usb_interface *intf)\n{\n\tstruct hid_device *hid = usb_get_intfdata(intf);\n\tstruct usbhid_device *usbhid;\n\n\tif (WARN_ON(!hid))\n\t\treturn;\n\n\tusbhid = hid->driver_data;\n\tspin_lock_irq(&usbhid->lock);\t/* Sync with error and led handlers */\n\tset_bit(HID_DISCONNECTED, &usbhid->iofl);\n\tspin_unlock_irq(&usbhid->lock);\n\thid_destroy_device(hid);\n\tkfree(usbhid);\n}\n\nstatic void hid_cancel_delayed_stuff(struct usbhid_device *usbhid)\n{\n\tdel_timer_sync(&usbhid->io_retry);\n\tcancel_work_sync(&usbhid->reset_work);\n}\n\nstatic void hid_cease_io(struct usbhid_device *usbhid)\n{\n\tdel_timer_sync(&usbhid->io_retry);\n\tusb_kill_urb(usbhid->urbin);\n\tusb_kill_urb(usbhid->urbctrl);\n\tusb_kill_urb(usbhid->urbout);\n}\n\nstatic void hid_restart_io(struct hid_device *hid)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tint clear_halt = test_bit(HID_CLEAR_HALT, &usbhid->iofl);\n\tint reset_pending = test_bit(HID_RESET_PENDING, &usbhid->iofl);\n\n\tspin_lock_irq(&usbhid->lock);\n\tclear_bit(HID_SUSPENDED, &usbhid->iofl);\n\tusbhid_mark_busy(usbhid);\n\n\tif (clear_halt || reset_pending)\n\t\tschedule_work(&usbhid->reset_work);\n\tusbhid->retry_delay = 0;\n\tspin_unlock_irq(&usbhid->lock);\n\n\tif (reset_pending || !test_bit(HID_STARTED, &usbhid->iofl))\n\t\treturn;\n\n\tif (!clear_halt) {\n\t\tif (hid_start_in(hid) < 0)\n\t\t\thid_io_error(hid);\n\t}\n\n\tspin_lock_irq(&usbhid->lock);\n\tif (usbhid->urbout && !test_bit(HID_OUT_RUNNING, &usbhid->iofl))\n\t\tusbhid_restart_out_queue(usbhid);\n\tif (!test_bit(HID_CTRL_RUNNING, &usbhid->iofl))\n\t\tusbhid_restart_ctrl_queue(usbhid);\n\tspin_unlock_irq(&usbhid->lock);\n}\n\n/* Treat USB reset pretty much the same as suspend/resume */\nstatic int hid_pre_reset(struct usb_interface *intf)\n{\n\tstruct hid_device *hid = usb_get_intfdata(intf);\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\tspin_lock_irq(&usbhid->lock);\n\tset_bit(HID_RESET_PENDING, &usbhid->iofl);\n\tspin_unlock_irq(&usbhid->lock);\n\thid_cease_io(usbhid);\n\n\treturn 0;\n}\n\n/* Same routine used for post_reset and reset_resume */\nstatic int hid_post_reset(struct usb_interface *intf)\n{\n\tstruct usb_device *dev = interface_to_usbdev (intf);\n\tstruct hid_device *hid = usb_get_intfdata(intf);\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tstruct usb_host_interface *interface = intf->cur_altsetting;\n\tint status;\n\tchar *rdesc;\n\n\t/* Fetch and examine the HID report descriptor. If this\n\t * has changed, then rebind. Since usbcore's check of the\n\t * configuration descriptors passed, we already know that\n\t * the size of the HID report descriptor has not changed.\n\t */\n\trdesc = kmalloc(hid->dev_rsize, GFP_KERNEL);\n\tif (!rdesc)\n\t\treturn -ENOMEM;\n\n\tstatus = hid_get_class_descriptor(dev,\n\t\t\t\tinterface->desc.bInterfaceNumber,\n\t\t\t\tHID_DT_REPORT, rdesc, hid->dev_rsize);\n\tif (status < 0) {\n\t\tdbg_hid(\"reading report descriptor failed (post_reset)\\n\");\n\t\tkfree(rdesc);\n\t\treturn status;\n\t}\n\tstatus = memcmp(rdesc, hid->dev_rdesc, hid->dev_rsize);\n\tkfree(rdesc);\n\tif (status != 0) {\n\t\tdbg_hid(\"report descriptor changed\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* No need to do another reset or clear a halted endpoint */\n\tspin_lock_irq(&usbhid->lock);\n\tclear_bit(HID_RESET_PENDING, &usbhid->iofl);\n\tclear_bit(HID_CLEAR_HALT, &usbhid->iofl);\n\tspin_unlock_irq(&usbhid->lock);\n\thid_set_idle(dev, intf->cur_altsetting->desc.bInterfaceNumber, 0, 0);\n\n\thid_restart_io(hid);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int hid_resume_common(struct hid_device *hid, bool driver_suspended)\n{\n\tint status = 0;\n\n\thid_restart_io(hid);\n\tif (driver_suspended && hid->driver && hid->driver->resume)\n\t\tstatus = hid->driver->resume(hid);\n\treturn status;\n}\n\nstatic int hid_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct hid_device *hid = usb_get_intfdata(intf);\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tint status = 0;\n\tbool driver_suspended = false;\n\tunsigned int ledcount;\n\n\tif (PMSG_IS_AUTO(message)) {\n\t\tledcount = hidinput_count_leds(hid);\n\t\tspin_lock_irq(&usbhid->lock);\t/* Sync with error handler */\n\t\tif (!test_bit(HID_RESET_PENDING, &usbhid->iofl)\n\t\t    && !test_bit(HID_CLEAR_HALT, &usbhid->iofl)\n\t\t    && !test_bit(HID_OUT_RUNNING, &usbhid->iofl)\n\t\t    && !test_bit(HID_CTRL_RUNNING, &usbhid->iofl)\n\t\t    && !test_bit(HID_KEYS_PRESSED, &usbhid->iofl)\n\t\t    && (!ledcount || ignoreled))\n\t\t{\n\t\t\tset_bit(HID_SUSPENDED, &usbhid->iofl);\n\t\t\tspin_unlock_irq(&usbhid->lock);\n\t\t\tif (hid->driver && hid->driver->suspend) {\n\t\t\t\tstatus = hid->driver->suspend(hid, message);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tdriver_suspended = true;\n\t\t} else {\n\t\t\tusbhid_mark_busy(usbhid);\n\t\t\tspin_unlock_irq(&usbhid->lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t} else {\n\t\t/* TODO: resume() might need to handle suspend failure */\n\t\tif (hid->driver && hid->driver->suspend)\n\t\t\tstatus = hid->driver->suspend(hid, message);\n\t\tdriver_suspended = true;\n\t\tspin_lock_irq(&usbhid->lock);\n\t\tset_bit(HID_SUSPENDED, &usbhid->iofl);\n\t\tspin_unlock_irq(&usbhid->lock);\n\t\tif (usbhid_wait_io(hid) < 0)\n\t\t\tstatus = -EIO;\n\t}\n\n\thid_cancel_delayed_stuff(usbhid);\n\thid_cease_io(usbhid);\n\n\tif (PMSG_IS_AUTO(message) && test_bit(HID_KEYS_PRESSED, &usbhid->iofl)) {\n\t\t/* lost race against keypresses */\n\t\tstatus = -EBUSY;\n\t\tgoto failed;\n\t}\n\tdev_dbg(&intf->dev, \"suspend\\n\");\n\treturn status;\n\n failed:\n\thid_resume_common(hid, driver_suspended);\n\treturn status;\n}\n\nstatic int hid_resume(struct usb_interface *intf)\n{\n\tstruct hid_device *hid = usb_get_intfdata (intf);\n\tint status;\n\n\tstatus = hid_resume_common(hid, true);\n\tdev_dbg(&intf->dev, \"resume status %d\\n\", status);\n\treturn 0;\n}\n\nstatic int hid_reset_resume(struct usb_interface *intf)\n{\n\tstruct hid_device *hid = usb_get_intfdata(intf);\n\tint status;\n\n\tstatus = hid_post_reset(intf);\n\tif (status >= 0 && hid->driver && hid->driver->reset_resume) {\n\t\tint ret = hid->driver->reset_resume(hid);\n\t\tif (ret < 0)\n\t\t\tstatus = ret;\n\t}\n\treturn status;\n}\n\n#endif /* CONFIG_PM */\n\nstatic const struct usb_device_id hid_usb_ids[] = {\n\t{ .match_flags = USB_DEVICE_ID_MATCH_INT_CLASS,\n\t\t.bInterfaceClass = USB_INTERFACE_CLASS_HID },\n\t{ }\t\t\t\t\t\t/* Terminating entry */\n};\n\nMODULE_DEVICE_TABLE (usb, hid_usb_ids);\n\nstatic struct usb_driver hid_driver = {\n\t.name =\t\t\"usbhid\",\n\t.probe =\tusbhid_probe,\n\t.disconnect =\tusbhid_disconnect,\n#ifdef CONFIG_PM\n\t.suspend =\thid_suspend,\n\t.resume =\thid_resume,\n\t.reset_resume =\thid_reset_resume,\n#endif\n\t.pre_reset =\thid_pre_reset,\n\t.post_reset =\thid_post_reset,\n\t.id_table =\thid_usb_ids,\n\t.supports_autosuspend = 1,\n};\n\nstruct usb_interface *usbhid_find_interface(int minor)\n{\n\treturn usb_find_interface(&hid_driver, minor);\n}\n\nstatic int __init hid_init(void)\n{\n\tint retval = -ENOMEM;\n\n\tretval = usbhid_quirks_init(quirks_param);\n\tif (retval)\n\t\tgoto usbhid_quirks_init_fail;\n\tretval = usb_register(&hid_driver);\n\tif (retval)\n\t\tgoto usb_register_fail;\n\tpr_info(KBUILD_MODNAME \": \" DRIVER_DESC \"\\n\");\n\n\treturn 0;\nusb_register_fail:\n\tusbhid_quirks_exit();\nusbhid_quirks_init_fail:\n\treturn retval;\n}\n\nstatic void __exit hid_exit(void)\n{\n\tusb_deregister(&hid_driver);\n\tusbhid_quirks_exit();\n}\n\nmodule_init(hid_init);\nmodule_exit(hid_exit);\n\nMODULE_AUTHOR(\"Andreas Gal\");\nMODULE_AUTHOR(\"Vojtech Pavlik\");\nMODULE_AUTHOR(\"Jiri Kosina\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["/*\n *  USB HID support for Linux\n *\n *  Copyright (c) 1999 Andreas Gal\n *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>\n *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc\n *  Copyright (c) 2007-2008 Oliver Neukum\n *  Copyright (c) 2006-2010 Jiri Kosina\n */\n\n/*\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n */\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <linux/input.h>\n#include <linux/wait.h>\n#include <linux/workqueue.h>\n#include <linux/string.h>\n\n#include <linux/usb.h>\n\n#include <linux/hid.h>\n#include <linux/hiddev.h>\n#include <linux/hid-debug.h>\n#include <linux/hidraw.h>\n#include \"usbhid.h\"\n\n/*\n * Version Information\n */\n\n#define DRIVER_DESC \"USB HID core driver\"\n\n/*\n * Module parameters.\n */\n\nstatic unsigned int hid_mousepoll_interval;\nmodule_param_named(mousepoll, hid_mousepoll_interval, uint, 0644);\nMODULE_PARM_DESC(mousepoll, \"Polling interval of mice\");\n\nstatic unsigned int hid_jspoll_interval;\nmodule_param_named(jspoll, hid_jspoll_interval, uint, 0644);\nMODULE_PARM_DESC(jspoll, \"Polling interval of joysticks\");\n\nstatic unsigned int ignoreled;\nmodule_param_named(ignoreled, ignoreled, uint, 0644);\nMODULE_PARM_DESC(ignoreled, \"Autosuspend with active leds\");\n\n/* Quirks specified at module load time */\nstatic char *quirks_param[MAX_USBHID_BOOT_QUIRKS];\nmodule_param_array_named(quirks, quirks_param, charp, NULL, 0444);\nMODULE_PARM_DESC(quirks, \"Add/modify USB HID quirks by specifying \"\n\t\t\" quirks=vendorID:productID:quirks\"\n\t\t\" where vendorID, productID, and quirks are all in\"\n\t\t\" 0x-prefixed hex\");\n/*\n * Input submission and I/O error handler.\n */\nstatic void hid_io_error(struct hid_device *hid);\nstatic int hid_submit_out(struct hid_device *hid);\nstatic int hid_submit_ctrl(struct hid_device *hid);\nstatic void hid_cancel_delayed_stuff(struct usbhid_device *usbhid);\n\n/* Start up the input URB */\nstatic int hid_start_in(struct hid_device *hid)\n{\n\tunsigned long flags;\n\tint rc = 0;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\tspin_lock_irqsave(&usbhid->lock, flags);\n\tif (test_bit(HID_IN_POLLING, &usbhid->iofl) &&\n\t    !test_bit(HID_DISCONNECTED, &usbhid->iofl) &&\n\t    !test_bit(HID_SUSPENDED, &usbhid->iofl) &&\n\t    !test_and_set_bit(HID_IN_RUNNING, &usbhid->iofl)) {\n\t\trc = usb_submit_urb(usbhid->urbin, GFP_ATOMIC);\n\t\tif (rc != 0) {\n\t\t\tclear_bit(HID_IN_RUNNING, &usbhid->iofl);\n\t\t\tif (rc == -ENOSPC)\n\t\t\t\tset_bit(HID_NO_BANDWIDTH, &usbhid->iofl);\n\t\t} else {\n\t\t\tclear_bit(HID_NO_BANDWIDTH, &usbhid->iofl);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&usbhid->lock, flags);\n\treturn rc;\n}\n\n/* I/O retry timer routine */\nstatic void hid_retry_timeout(unsigned long _hid)\n{\n\tstruct hid_device *hid = (struct hid_device *) _hid;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\tdev_dbg(&usbhid->intf->dev, \"retrying intr urb\\n\");\n\tif (hid_start_in(hid))\n\t\thid_io_error(hid);\n}\n\n/* Workqueue routine to reset the device or clear a halt */\nstatic void hid_reset(struct work_struct *work)\n{\n\tstruct usbhid_device *usbhid =\n\t\tcontainer_of(work, struct usbhid_device, reset_work);\n\tstruct hid_device *hid = usbhid->hid;\n\tint rc;\n\n\tif (test_bit(HID_CLEAR_HALT, &usbhid->iofl)) {\n\t\tdev_dbg(&usbhid->intf->dev, \"clear halt\\n\");\n\t\trc = usb_clear_halt(hid_to_usb_dev(hid), usbhid->urbin->pipe);\n\t\tclear_bit(HID_CLEAR_HALT, &usbhid->iofl);\n\t\tif (rc == 0) {\n\t\t\thid_start_in(hid);\n\t\t} else {\n\t\t\tdev_dbg(&usbhid->intf->dev,\n\t\t\t\t\t\"clear-halt failed: %d\\n\", rc);\n\t\t\tset_bit(HID_RESET_PENDING, &usbhid->iofl);\n\t\t}\n\t}\n\n\tif (test_bit(HID_RESET_PENDING, &usbhid->iofl)) {\n\t\tdev_dbg(&usbhid->intf->dev, \"resetting device\\n\");\n\t\tusb_queue_reset_device(usbhid->intf);\n\t}\n}\n\n/* Main I/O error handler */\nstatic void hid_io_error(struct hid_device *hid)\n{\n\tunsigned long flags;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\tspin_lock_irqsave(&usbhid->lock, flags);\n\n\t/* Stop when disconnected */\n\tif (test_bit(HID_DISCONNECTED, &usbhid->iofl))\n\t\tgoto done;\n\n\t/* If it has been a while since the last error, we'll assume\n\t * this a brand new error and reset the retry timeout. */\n\tif (time_after(jiffies, usbhid->stop_retry + HZ/2))\n\t\tusbhid->retry_delay = 0;\n\n\t/* When an error occurs, retry at increasing intervals */\n\tif (usbhid->retry_delay == 0) {\n\t\tusbhid->retry_delay = 13;\t/* Then 26, 52, 104, 104, ... */\n\t\tusbhid->stop_retry = jiffies + msecs_to_jiffies(1000);\n\t} else if (usbhid->retry_delay < 100)\n\t\tusbhid->retry_delay *= 2;\n\n\tif (time_after(jiffies, usbhid->stop_retry)) {\n\n\t\t/* Retries failed, so do a port reset unless we lack bandwidth*/\n\t\tif (!test_bit(HID_NO_BANDWIDTH, &usbhid->iofl)\n\t\t     && !test_and_set_bit(HID_RESET_PENDING, &usbhid->iofl)) {\n\n\t\t\tschedule_work(&usbhid->reset_work);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tmod_timer(&usbhid->io_retry,\n\t\t\tjiffies + msecs_to_jiffies(usbhid->retry_delay));\ndone:\n\tspin_unlock_irqrestore(&usbhid->lock, flags);\n}\n\nstatic void usbhid_mark_busy(struct usbhid_device *usbhid)\n{\n\tstruct usb_interface *intf = usbhid->intf;\n\n\tusb_mark_last_busy(interface_to_usbdev(intf));\n}\n\nstatic int usbhid_restart_out_queue(struct usbhid_device *usbhid)\n{\n\tstruct hid_device *hid = usb_get_intfdata(usbhid->intf);\n\tint kicked;\n\tint r;\n\n\tif (!hid || test_bit(HID_RESET_PENDING, &usbhid->iofl) ||\n\t\t\ttest_bit(HID_SUSPENDED, &usbhid->iofl))\n\t\treturn 0;\n\n\tif ((kicked = (usbhid->outhead != usbhid->outtail))) {\n\t\thid_dbg(hid, \"Kicking head %d tail %d\", usbhid->outhead, usbhid->outtail);\n\n\t\t/* Try to wake up from autosuspend... */\n\t\tr = usb_autopm_get_interface_async(usbhid->intf);\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\t/*\n\t\t * If still suspended, don't submit.  Submission will\n\t\t * occur if/when resume drains the queue.\n\t\t */\n\t\tif (test_bit(HID_SUSPENDED, &usbhid->iofl)) {\n\t\t\tusb_autopm_put_interface_no_suspend(usbhid->intf);\n\t\t\treturn r;\n\t\t}\n\n\t\t/* Asynchronously flush queue. */\n\t\tset_bit(HID_OUT_RUNNING, &usbhid->iofl);\n\t\tif (hid_submit_out(hid)) {\n\t\t\tclear_bit(HID_OUT_RUNNING, &usbhid->iofl);\n\t\t\tusb_autopm_put_interface_async(usbhid->intf);\n\t\t}\n\t\twake_up(&usbhid->wait);\n\t}\n\treturn kicked;\n}\n\nstatic int usbhid_restart_ctrl_queue(struct usbhid_device *usbhid)\n{\n\tstruct hid_device *hid = usb_get_intfdata(usbhid->intf);\n\tint kicked;\n\tint r;\n\n\tWARN_ON(hid == NULL);\n\tif (!hid || test_bit(HID_RESET_PENDING, &usbhid->iofl) ||\n\t\t\ttest_bit(HID_SUSPENDED, &usbhid->iofl))\n\t\treturn 0;\n\n\tif ((kicked = (usbhid->ctrlhead != usbhid->ctrltail))) {\n\t\thid_dbg(hid, \"Kicking head %d tail %d\", usbhid->ctrlhead, usbhid->ctrltail);\n\n\t\t/* Try to wake up from autosuspend... */\n\t\tr = usb_autopm_get_interface_async(usbhid->intf);\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\t/*\n\t\t * If still suspended, don't submit.  Submission will\n\t\t * occur if/when resume drains the queue.\n\t\t */\n\t\tif (test_bit(HID_SUSPENDED, &usbhid->iofl)) {\n\t\t\tusb_autopm_put_interface_no_suspend(usbhid->intf);\n\t\t\treturn r;\n\t\t}\n\n\t\t/* Asynchronously flush queue. */\n\t\tset_bit(HID_CTRL_RUNNING, &usbhid->iofl);\n\t\tif (hid_submit_ctrl(hid)) {\n\t\t\tclear_bit(HID_CTRL_RUNNING, &usbhid->iofl);\n\t\t\tusb_autopm_put_interface_async(usbhid->intf);\n\t\t}\n\t\twake_up(&usbhid->wait);\n\t}\n\treturn kicked;\n}\n\n/*\n * Input interrupt completion handler.\n */\n\nstatic void hid_irq_in(struct urb *urb)\n{\n\tstruct hid_device\t*hid = urb->context;\n\tstruct usbhid_device\t*usbhid = hid->driver_data;\n\tint\t\t\tstatus;\n\n\tswitch (urb->status) {\n\tcase 0:\t\t\t/* success */\n\t\tusbhid->retry_delay = 0;\n\t\tif (!test_bit(HID_OPENED, &usbhid->iofl))\n\t\t\tbreak;\n\t\tusbhid_mark_busy(usbhid);\n\t\tif (!test_bit(HID_RESUME_RUNNING, &usbhid->iofl)) {\n\t\t\thid_input_report(urb->context, HID_INPUT_REPORT,\n\t\t\t\t\t urb->transfer_buffer,\n\t\t\t\t\t urb->actual_length, 1);\n\t\t\t/*\n\t\t\t * autosuspend refused while keys are pressed\n\t\t\t * because most keyboards don't wake up when\n\t\t\t * a key is released\n\t\t\t */\n\t\t\tif (hid_check_keys_pressed(hid))\n\t\t\t\tset_bit(HID_KEYS_PRESSED, &usbhid->iofl);\n\t\t\telse\n\t\t\t\tclear_bit(HID_KEYS_PRESSED, &usbhid->iofl);\n\t\t}\n\t\tbreak;\n\tcase -EPIPE:\t\t/* stall */\n\t\tusbhid_mark_busy(usbhid);\n\t\tclear_bit(HID_IN_RUNNING, &usbhid->iofl);\n\t\tset_bit(HID_CLEAR_HALT, &usbhid->iofl);\n\t\tschedule_work(&usbhid->reset_work);\n\t\treturn;\n\tcase -ECONNRESET:\t/* unlink */\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\t/* unplug */\n\t\tclear_bit(HID_IN_RUNNING, &usbhid->iofl);\n\t\treturn;\n\tcase -EILSEQ:\t\t/* protocol error or unplug */\n\tcase -EPROTO:\t\t/* protocol error or unplug */\n\tcase -ETIME:\t\t/* protocol error or unplug */\n\tcase -ETIMEDOUT:\t/* Should never happen, but... */\n\t\tusbhid_mark_busy(usbhid);\n\t\tclear_bit(HID_IN_RUNNING, &usbhid->iofl);\n\t\thid_io_error(hid);\n\t\treturn;\n\tdefault:\t\t/* error */\n\t\thid_warn(urb->dev, \"input irq status %d received\\n\",\n\t\t\t urb->status);\n\t}\n\n\tstatus = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (status) {\n\t\tclear_bit(HID_IN_RUNNING, &usbhid->iofl);\n\t\tif (status != -EPERM) {\n\t\t\thid_err(hid, \"can't resubmit intr, %s-%s/input%d, status %d\\n\",\n\t\t\t\thid_to_usb_dev(hid)->bus->bus_name,\n\t\t\t\thid_to_usb_dev(hid)->devpath,\n\t\t\t\tusbhid->ifnum, status);\n\t\t\thid_io_error(hid);\n\t\t}\n\t}\n}\n\nstatic int hid_submit_out(struct hid_device *hid)\n{\n\tstruct hid_report *report;\n\tchar *raw_report;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tint r;\n\n\treport = usbhid->out[usbhid->outtail].report;\n\traw_report = usbhid->out[usbhid->outtail].raw_report;\n\n\tusbhid->urbout->transfer_buffer_length = hid_report_len(report);\n\tusbhid->urbout->dev = hid_to_usb_dev(hid);\n\tif (raw_report) {\n\t\tmemcpy(usbhid->outbuf, raw_report,\n\t\t\t\tusbhid->urbout->transfer_buffer_length);\n\t\tkfree(raw_report);\n\t\tusbhid->out[usbhid->outtail].raw_report = NULL;\n\t}\n\n\tdbg_hid(\"submitting out urb\\n\");\n\n\tr = usb_submit_urb(usbhid->urbout, GFP_ATOMIC);\n\tif (r < 0) {\n\t\thid_err(hid, \"usb_submit_urb(out) failed: %d\\n\", r);\n\t\treturn r;\n\t}\n\tusbhid->last_out = jiffies;\n\treturn 0;\n}\n\nstatic int hid_submit_ctrl(struct hid_device *hid)\n{\n\tstruct hid_report *report;\n\tunsigned char dir;\n\tchar *raw_report;\n\tint len, r;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\treport = usbhid->ctrl[usbhid->ctrltail].report;\n\traw_report = usbhid->ctrl[usbhid->ctrltail].raw_report;\n\tdir = usbhid->ctrl[usbhid->ctrltail].dir;\n\n\tlen = ((report->size - 1) >> 3) + 1 + (report->id > 0);\n\tif (dir == USB_DIR_OUT) {\n\t\tusbhid->urbctrl->pipe = usb_sndctrlpipe(hid_to_usb_dev(hid), 0);\n\t\tusbhid->urbctrl->transfer_buffer_length = len;\n\t\tif (raw_report) {\n\t\t\tmemcpy(usbhid->ctrlbuf, raw_report, len);\n\t\t\tkfree(raw_report);\n\t\t\tusbhid->ctrl[usbhid->ctrltail].raw_report = NULL;\n\t\t}\n\t} else {\n\t\tint maxpacket, padlen;\n\n\t\tusbhid->urbctrl->pipe = usb_rcvctrlpipe(hid_to_usb_dev(hid), 0);\n\t\tmaxpacket = usb_maxpacket(hid_to_usb_dev(hid),\n\t\t\t\t\t  usbhid->urbctrl->pipe, 0);\n\t\tif (maxpacket > 0) {\n\t\t\tpadlen = DIV_ROUND_UP(len, maxpacket);\n\t\t\tpadlen *= maxpacket;\n\t\t\tif (padlen > usbhid->bufsize)\n\t\t\t\tpadlen = usbhid->bufsize;\n\t\t} else\n\t\t\tpadlen = 0;\n\t\tusbhid->urbctrl->transfer_buffer_length = padlen;\n\t}\n\tusbhid->urbctrl->dev = hid_to_usb_dev(hid);\n\n\tusbhid->cr->bRequestType = USB_TYPE_CLASS | USB_RECIP_INTERFACE | dir;\n\tusbhid->cr->bRequest = (dir == USB_DIR_OUT) ? HID_REQ_SET_REPORT :\n\t\t\t\t\t\t      HID_REQ_GET_REPORT;\n\tusbhid->cr->wValue = cpu_to_le16(((report->type + 1) << 8) |\n\t\t\t\t\t report->id);\n\tusbhid->cr->wIndex = cpu_to_le16(usbhid->ifnum);\n\tusbhid->cr->wLength = cpu_to_le16(len);\n\n\tdbg_hid(\"submitting ctrl urb: %s wValue=0x%04x wIndex=0x%04x wLength=%u\\n\",\n\t\tusbhid->cr->bRequest == HID_REQ_SET_REPORT ? \"Set_Report\" :\n\t\t\t\t\t\t\t     \"Get_Report\",\n\t\tusbhid->cr->wValue, usbhid->cr->wIndex, usbhid->cr->wLength);\n\n\tr = usb_submit_urb(usbhid->urbctrl, GFP_ATOMIC);\n\tif (r < 0) {\n\t\thid_err(hid, \"usb_submit_urb(ctrl) failed: %d\\n\", r);\n\t\treturn r;\n\t}\n\tusbhid->last_ctrl = jiffies;\n\treturn 0;\n}\n\n/*\n * Output interrupt completion handler.\n */\n\nstatic void hid_irq_out(struct urb *urb)\n{\n\tstruct hid_device *hid = urb->context;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tunsigned long flags;\n\tint unplug = 0;\n\n\tswitch (urb->status) {\n\tcase 0:\t\t\t/* success */\n\t\tbreak;\n\tcase -ESHUTDOWN:\t/* unplug */\n\t\tunplug = 1;\n\tcase -EILSEQ:\t\t/* protocol error or unplug */\n\tcase -EPROTO:\t\t/* protocol error or unplug */\n\tcase -ECONNRESET:\t/* unlink */\n\tcase -ENOENT:\n\t\tbreak;\n\tdefault:\t\t/* error */\n\t\thid_warn(urb->dev, \"output irq status %d received\\n\",\n\t\t\t urb->status);\n\t}\n\n\tspin_lock_irqsave(&usbhid->lock, flags);\n\n\tif (unplug) {\n\t\tusbhid->outtail = usbhid->outhead;\n\t} else {\n\t\tusbhid->outtail = (usbhid->outtail + 1) & (HID_OUTPUT_FIFO_SIZE - 1);\n\n\t\tif (usbhid->outhead != usbhid->outtail &&\n\t\t\t\thid_submit_out(hid) == 0) {\n\t\t\t/* Successfully submitted next urb in queue */\n\t\t\tspin_unlock_irqrestore(&usbhid->lock, flags);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tclear_bit(HID_OUT_RUNNING, &usbhid->iofl);\n\tspin_unlock_irqrestore(&usbhid->lock, flags);\n\tusb_autopm_put_interface_async(usbhid->intf);\n\twake_up(&usbhid->wait);\n}\n\n/*\n * Control pipe completion handler.\n */\n\nstatic void hid_ctrl(struct urb *urb)\n{\n\tstruct hid_device *hid = urb->context;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tint unplug = 0, status = urb->status;\n\n\tswitch (status) {\n\tcase 0:\t\t\t/* success */\n\t\tif (usbhid->ctrl[usbhid->ctrltail].dir == USB_DIR_IN)\n\t\t\thid_input_report(urb->context,\n\t\t\t\tusbhid->ctrl[usbhid->ctrltail].report->type,\n\t\t\t\turb->transfer_buffer, urb->actual_length, 0);\n\t\tbreak;\n\tcase -ESHUTDOWN:\t/* unplug */\n\t\tunplug = 1;\n\tcase -EILSEQ:\t\t/* protocol error or unplug */\n\tcase -EPROTO:\t\t/* protocol error or unplug */\n\tcase -ECONNRESET:\t/* unlink */\n\tcase -ENOENT:\n\tcase -EPIPE:\t\t/* report not available */\n\t\tbreak;\n\tdefault:\t\t/* error */\n\t\thid_warn(urb->dev, \"ctrl urb status %d received\\n\", status);\n\t}\n\n\tspin_lock(&usbhid->lock);\n\n\tif (unplug) {\n\t\tusbhid->ctrltail = usbhid->ctrlhead;\n\t} else {\n\t\tusbhid->ctrltail = (usbhid->ctrltail + 1) & (HID_CONTROL_FIFO_SIZE - 1);\n\n\t\tif (usbhid->ctrlhead != usbhid->ctrltail &&\n\t\t\t\thid_submit_ctrl(hid) == 0) {\n\t\t\t/* Successfully submitted next urb in queue */\n\t\t\tspin_unlock(&usbhid->lock);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tclear_bit(HID_CTRL_RUNNING, &usbhid->iofl);\n\tspin_unlock(&usbhid->lock);\n\tusb_autopm_put_interface_async(usbhid->intf);\n\twake_up(&usbhid->wait);\n}\n\nstatic void __usbhid_submit_report(struct hid_device *hid, struct hid_report *report,\n\t\t\t\t   unsigned char dir)\n{\n\tint head;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\tif (((hid->quirks & HID_QUIRK_NOGET) && dir == USB_DIR_IN) ||\n\t\ttest_bit(HID_DISCONNECTED, &usbhid->iofl))\n\t\treturn;\n\n\tif (usbhid->urbout && dir == USB_DIR_OUT && report->type == HID_OUTPUT_REPORT) {\n\t\tif ((head = (usbhid->outhead + 1) & (HID_OUTPUT_FIFO_SIZE - 1)) == usbhid->outtail) {\n\t\t\thid_warn(hid, \"output queue full\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tusbhid->out[usbhid->outhead].raw_report = hid_alloc_report_buf(report, GFP_ATOMIC);\n\t\tif (!usbhid->out[usbhid->outhead].raw_report) {\n\t\t\thid_warn(hid, \"output queueing failed\\n\");\n\t\t\treturn;\n\t\t}\n\t\thid_output_report(report, usbhid->out[usbhid->outhead].raw_report);\n\t\tusbhid->out[usbhid->outhead].report = report;\n\t\tusbhid->outhead = head;\n\n\t\t/* If the queue isn't running, restart it */\n\t\tif (!test_bit(HID_OUT_RUNNING, &usbhid->iofl)) {\n\t\t\tusbhid_restart_out_queue(usbhid);\n\n\t\t/* Otherwise see if an earlier request has timed out */\n\t\t} else if (time_after(jiffies, usbhid->last_out + HZ * 5)) {\n\n\t\t\t/* Prevent autosuspend following the unlink */\n\t\t\tusb_autopm_get_interface_no_resume(usbhid->intf);\n\n\t\t\t/*\n\t\t\t * Prevent resubmission in case the URB completes\n\t\t\t * before we can unlink it.  We don't want to cancel\n\t\t\t * the wrong transfer!\n\t\t\t */\n\t\t\tusb_block_urb(usbhid->urbout);\n\n\t\t\t/* Drop lock to avoid deadlock if the callback runs */\n\t\t\tspin_unlock(&usbhid->lock);\n\n\t\t\tusb_unlink_urb(usbhid->urbout);\n\t\t\tspin_lock(&usbhid->lock);\n\t\t\tusb_unblock_urb(usbhid->urbout);\n\n\t\t\t/* Unlink might have stopped the queue */\n\t\t\tif (!test_bit(HID_OUT_RUNNING, &usbhid->iofl))\n\t\t\t\tusbhid_restart_out_queue(usbhid);\n\n\t\t\t/* Now we can allow autosuspend again */\n\t\t\tusb_autopm_put_interface_async(usbhid->intf);\n\t\t}\n\t\treturn;\n\t}\n\n\tif ((head = (usbhid->ctrlhead + 1) & (HID_CONTROL_FIFO_SIZE - 1)) == usbhid->ctrltail) {\n\t\thid_warn(hid, \"control queue full\\n\");\n\t\treturn;\n\t}\n\n\tif (dir == USB_DIR_OUT) {\n\t\tusbhid->ctrl[usbhid->ctrlhead].raw_report = hid_alloc_report_buf(report, GFP_ATOMIC);\n\t\tif (!usbhid->ctrl[usbhid->ctrlhead].raw_report) {\n\t\t\thid_warn(hid, \"control queueing failed\\n\");\n\t\t\treturn;\n\t\t}\n\t\thid_output_report(report, usbhid->ctrl[usbhid->ctrlhead].raw_report);\n\t}\n\tusbhid->ctrl[usbhid->ctrlhead].report = report;\n\tusbhid->ctrl[usbhid->ctrlhead].dir = dir;\n\tusbhid->ctrlhead = head;\n\n\t/* If the queue isn't running, restart it */\n\tif (!test_bit(HID_CTRL_RUNNING, &usbhid->iofl)) {\n\t\tusbhid_restart_ctrl_queue(usbhid);\n\n\t/* Otherwise see if an earlier request has timed out */\n\t} else if (time_after(jiffies, usbhid->last_ctrl + HZ * 5)) {\n\n\t\t/* Prevent autosuspend following the unlink */\n\t\tusb_autopm_get_interface_no_resume(usbhid->intf);\n\n\t\t/*\n\t\t * Prevent resubmission in case the URB completes\n\t\t * before we can unlink it.  We don't want to cancel\n\t\t * the wrong transfer!\n\t\t */\n\t\tusb_block_urb(usbhid->urbctrl);\n\n\t\t/* Drop lock to avoid deadlock if the callback runs */\n\t\tspin_unlock(&usbhid->lock);\n\n\t\tusb_unlink_urb(usbhid->urbctrl);\n\t\tspin_lock(&usbhid->lock);\n\t\tusb_unblock_urb(usbhid->urbctrl);\n\n\t\t/* Unlink might have stopped the queue */\n\t\tif (!test_bit(HID_CTRL_RUNNING, &usbhid->iofl))\n\t\t\tusbhid_restart_ctrl_queue(usbhid);\n\n\t\t/* Now we can allow autosuspend again */\n\t\tusb_autopm_put_interface_async(usbhid->intf);\n\t}\n}\n\nstatic void usbhid_submit_report(struct hid_device *hid, struct hid_report *report, unsigned char dir)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&usbhid->lock, flags);\n\t__usbhid_submit_report(hid, report, dir);\n\tspin_unlock_irqrestore(&usbhid->lock, flags);\n}\n\nstatic int usbhid_wait_io(struct hid_device *hid)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\tif (!wait_event_timeout(usbhid->wait,\n\t\t\t\t(!test_bit(HID_CTRL_RUNNING, &usbhid->iofl) &&\n\t\t\t\t!test_bit(HID_OUT_RUNNING, &usbhid->iofl)),\n\t\t\t\t\t10*HZ)) {\n\t\tdbg_hid(\"timeout waiting for ctrl or out queue to clear\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int hid_set_idle(struct usb_device *dev, int ifnum, int report, int idle)\n{\n\treturn usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\tHID_REQ_SET_IDLE, USB_TYPE_CLASS | USB_RECIP_INTERFACE, (idle << 8) | report,\n\t\tifnum, NULL, 0, USB_CTRL_SET_TIMEOUT);\n}\n\nstatic int hid_get_class_descriptor(struct usb_device *dev, int ifnum,\n\t\tunsigned char type, void *buf, int size)\n{\n\tint result, retries = 4;\n\n\tmemset(buf, 0, size);\n\n\tdo {\n\t\tresult = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t\tUSB_REQ_GET_DESCRIPTOR, USB_RECIP_INTERFACE | USB_DIR_IN,\n\t\t\t\t(type << 8), ifnum, buf, size, USB_CTRL_GET_TIMEOUT);\n\t\tretries--;\n\t} while (result < size && retries);\n\treturn result;\n}\n\nstatic int usbhid_open(struct hid_device *hid)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tint res;\n\n\tset_bit(HID_OPENED, &usbhid->iofl);\n\n\tif (hid->quirks & HID_QUIRK_ALWAYS_POLL)\n\t\treturn 0;\n\n\tres = usb_autopm_get_interface(usbhid->intf);\n\t/* the device must be awake to reliably request remote wakeup */\n\tif (res < 0) {\n\t\tclear_bit(HID_OPENED, &usbhid->iofl);\n\t\treturn -EIO;\n\t}\n\n\tusbhid->intf->needs_remote_wakeup = 1;\n\n\tset_bit(HID_RESUME_RUNNING, &usbhid->iofl);\n\tset_bit(HID_IN_POLLING, &usbhid->iofl);\n\n\tres = hid_start_in(hid);\n\tif (res) {\n\t\tif (res != -ENOSPC) {\n\t\t\thid_io_error(hid);\n\t\t\tres = 0;\n\t\t} else {\n\t\t\t/* no use opening if resources are insufficient */\n\t\t\tres = -EBUSY;\n\t\t\tclear_bit(HID_OPENED, &usbhid->iofl);\n\t\t\tclear_bit(HID_IN_POLLING, &usbhid->iofl);\n\t\t\tusbhid->intf->needs_remote_wakeup = 0;\n\t\t}\n\t}\n\n\tusb_autopm_put_interface(usbhid->intf);\n\n\t/*\n\t * In case events are generated while nobody was listening,\n\t * some are released when the device is re-opened.\n\t * Wait 50 msec for the queue to empty before allowing events\n\t * to go through hid.\n\t */\n\tif (res == 0)\n\t\tmsleep(50);\n\n\tclear_bit(HID_RESUME_RUNNING, &usbhid->iofl);\n\treturn res;\n}\n\nstatic void usbhid_close(struct hid_device *hid)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\t/*\n\t * Make sure we don't restart data acquisition due to\n\t * a resumption we no longer care about by avoiding racing\n\t * with hid_start_in().\n\t */\n\tspin_lock_irq(&usbhid->lock);\n\tclear_bit(HID_OPENED, &usbhid->iofl);\n\tif (!(hid->quirks & HID_QUIRK_ALWAYS_POLL))\n\t\tclear_bit(HID_IN_POLLING, &usbhid->iofl);\n\tspin_unlock_irq(&usbhid->lock);\n\n\tif (hid->quirks & HID_QUIRK_ALWAYS_POLL)\n\t\treturn;\n\n\thid_cancel_delayed_stuff(usbhid);\n\tusb_kill_urb(usbhid->urbin);\n\tusbhid->intf->needs_remote_wakeup = 0;\n}\n\n/*\n * Initialize all reports\n */\n\nvoid usbhid_init_reports(struct hid_device *hid)\n{\n\tstruct hid_report *report;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tstruct hid_report_enum *report_enum;\n\tint err, ret;\n\n\treport_enum = &hid->report_enum[HID_INPUT_REPORT];\n\tlist_for_each_entry(report, &report_enum->report_list, list)\n\t\tusbhid_submit_report(hid, report, USB_DIR_IN);\n\n\treport_enum = &hid->report_enum[HID_FEATURE_REPORT];\n\tlist_for_each_entry(report, &report_enum->report_list, list)\n\t\tusbhid_submit_report(hid, report, USB_DIR_IN);\n\n\terr = 0;\n\tret = usbhid_wait_io(hid);\n\twhile (ret) {\n\t\terr |= ret;\n\t\tif (test_bit(HID_CTRL_RUNNING, &usbhid->iofl))\n\t\t\tusb_kill_urb(usbhid->urbctrl);\n\t\tif (test_bit(HID_OUT_RUNNING, &usbhid->iofl))\n\t\t\tusb_kill_urb(usbhid->urbout);\n\t\tret = usbhid_wait_io(hid);\n\t}\n\n\tif (err)\n\t\thid_warn(hid, \"timeout initializing reports\\n\");\n}\n\n/*\n * Reset LEDs which BIOS might have left on. For now, just NumLock (0x01).\n */\nstatic int hid_find_field_early(struct hid_device *hid, unsigned int page,\n    unsigned int hid_code, struct hid_field **pfield)\n{\n\tstruct hid_report *report;\n\tstruct hid_field *field;\n\tstruct hid_usage *usage;\n\tint i, j;\n\n\tlist_for_each_entry(report, &hid->report_enum[HID_OUTPUT_REPORT].report_list, list) {\n\t\tfor (i = 0; i < report->maxfield; i++) {\n\t\t\tfield = report->field[i];\n\t\t\tfor (j = 0; j < field->maxusage; j++) {\n\t\t\t\tusage = &field->usage[j];\n\t\t\t\tif ((usage->hid & HID_USAGE_PAGE) == page &&\n\t\t\t\t    (usage->hid & 0xFFFF) == hid_code) {\n\t\t\t\t\t*pfield = field;\n\t\t\t\t\treturn j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic void usbhid_set_leds(struct hid_device *hid)\n{\n\tstruct hid_field *field;\n\tint offset;\n\n\tif ((offset = hid_find_field_early(hid, HID_UP_LED, 0x01, &field)) != -1) {\n\t\thid_set_field(field, offset, 0);\n\t\tusbhid_submit_report(hid, field->report, USB_DIR_OUT);\n\t}\n}\n\n/*\n * Traverse the supplied list of reports and find the longest\n */\nstatic void hid_find_max_report(struct hid_device *hid, unsigned int type,\n\t\tunsigned int *max)\n{\n\tstruct hid_report *report;\n\tunsigned int size;\n\n\tlist_for_each_entry(report, &hid->report_enum[type].report_list, list) {\n\t\tsize = ((report->size - 1) >> 3) + 1 + hid->report_enum[type].numbered;\n\t\tif (*max < size)\n\t\t\t*max = size;\n\t}\n}\n\nstatic int hid_alloc_buffers(struct usb_device *dev, struct hid_device *hid)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\tusbhid->inbuf = usb_alloc_coherent(dev, usbhid->bufsize, GFP_KERNEL,\n\t\t\t&usbhid->inbuf_dma);\n\tusbhid->outbuf = usb_alloc_coherent(dev, usbhid->bufsize, GFP_KERNEL,\n\t\t\t&usbhid->outbuf_dma);\n\tusbhid->cr = kmalloc(sizeof(*usbhid->cr), GFP_KERNEL);\n\tusbhid->ctrlbuf = usb_alloc_coherent(dev, usbhid->bufsize, GFP_KERNEL,\n\t\t\t&usbhid->ctrlbuf_dma);\n\tif (!usbhid->inbuf || !usbhid->outbuf || !usbhid->cr ||\n\t\t\t!usbhid->ctrlbuf)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int usbhid_get_raw_report(struct hid_device *hid,\n\t\tunsigned char report_number, __u8 *buf, size_t count,\n\t\tunsigned char report_type)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tstruct usb_device *dev = hid_to_usb_dev(hid);\n\tstruct usb_interface *intf = usbhid->intf;\n\tstruct usb_host_interface *interface = intf->cur_altsetting;\n\tint skipped_report_id = 0;\n\tint ret;\n\n\t/* Byte 0 is the report number. Report data starts at byte 1.*/\n\tbuf[0] = report_number;\n\tif (report_number == 0x0) {\n\t\t/* Offset the return buffer by 1, so that the report ID\n\t\t   will remain in byte 0. */\n\t\tbuf++;\n\t\tcount--;\n\t\tskipped_report_id = 1;\n\t}\n\tret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\tHID_REQ_GET_REPORT,\n\t\tUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t((report_type + 1) << 8) | report_number,\n\t\tinterface->desc.bInterfaceNumber, buf, count,\n\t\tUSB_CTRL_SET_TIMEOUT);\n\n\t/* count also the report id */\n\tif (ret > 0 && skipped_report_id)\n\t\tret++;\n\n\treturn ret;\n}\n\nstatic int usbhid_set_raw_report(struct hid_device *hid, unsigned int reportnum,\n\t\t\t\t __u8 *buf, size_t count, unsigned char rtype)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tstruct usb_device *dev = hid_to_usb_dev(hid);\n\tstruct usb_interface *intf = usbhid->intf;\n\tstruct usb_host_interface *interface = intf->cur_altsetting;\n\tint ret, skipped_report_id = 0;\n\n\t/* Byte 0 is the report number. Report data starts at byte 1.*/\n\tif ((rtype == HID_OUTPUT_REPORT) &&\n\t    (hid->quirks & HID_QUIRK_SKIP_OUTPUT_REPORT_ID))\n\t\tbuf[0] = 0;\n\telse\n\t\tbuf[0] = reportnum;\n\n\tif (buf[0] == 0x0) {\n\t\t/* Don't send the Report ID */\n\t\tbuf++;\n\t\tcount--;\n\t\tskipped_report_id = 1;\n\t}\n\n\tret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\tHID_REQ_SET_REPORT,\n\t\t\tUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\t((rtype + 1) << 8) | reportnum,\n\t\t\tinterface->desc.bInterfaceNumber, buf, count,\n\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t/* count also the report id, if this was a numbered report. */\n\tif (ret > 0 && skipped_report_id)\n\t\tret++;\n\n\treturn ret;\n}\n\nstatic int usbhid_output_report(struct hid_device *hid, __u8 *buf, size_t count)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tstruct usb_device *dev = hid_to_usb_dev(hid);\n\tint actual_length, skipped_report_id = 0, ret;\n\n\tif (!usbhid->urbout)\n\t\treturn -ENOSYS;\n\n\tif (buf[0] == 0x0) {\n\t\t/* Don't send the Report ID */\n\t\tbuf++;\n\t\tcount--;\n\t\tskipped_report_id = 1;\n\t}\n\n\tret = usb_interrupt_msg(dev, usbhid->urbout->pipe,\n\t\t\t\tbuf, count, &actual_length,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t/* return the number of bytes transferred */\n\tif (ret == 0) {\n\t\tret = actual_length;\n\t\t/* count also the report id */\n\t\tif (skipped_report_id)\n\t\t\tret++;\n\t}\n\n\treturn ret;\n}\n\nstatic void hid_free_buffers(struct usb_device *dev, struct hid_device *hid)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\tusb_free_coherent(dev, usbhid->bufsize, usbhid->inbuf, usbhid->inbuf_dma);\n\tusb_free_coherent(dev, usbhid->bufsize, usbhid->outbuf, usbhid->outbuf_dma);\n\tkfree(usbhid->cr);\n\tusb_free_coherent(dev, usbhid->bufsize, usbhid->ctrlbuf, usbhid->ctrlbuf_dma);\n}\n\nstatic int usbhid_parse(struct hid_device *hid)\n{\n\tstruct usb_interface *intf = to_usb_interface(hid->dev.parent);\n\tstruct usb_host_interface *interface = intf->cur_altsetting;\n\tstruct usb_device *dev = interface_to_usbdev (intf);\n\tstruct hid_descriptor *hdesc;\n\tu32 quirks = 0;\n\tunsigned int rsize = 0;\n\tchar *rdesc;\n\tint ret, n;\n\tint num_descriptors;\n\tsize_t offset = offsetof(struct hid_descriptor, desc);\n\n\tquirks = usbhid_lookup_quirk(le16_to_cpu(dev->descriptor.idVendor),\n\t\t\tle16_to_cpu(dev->descriptor.idProduct));\n\n\tif (quirks & HID_QUIRK_IGNORE)\n\t\treturn -ENODEV;\n\n\t/* Many keyboards and mice don't like to be polled for reports,\n\t * so we will always set the HID_QUIRK_NOGET flag for them. */\n\tif (interface->desc.bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT) {\n\t\tif (interface->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD ||\n\t\t\tinterface->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE)\n\t\t\t\tquirks |= HID_QUIRK_NOGET;\n\t}\n\n\tif (usb_get_extra_descriptor(interface, HID_DT_HID, &hdesc) &&\n\t    (!interface->desc.bNumEndpoints ||\n\t     usb_get_extra_descriptor(&interface->endpoint[0], HID_DT_HID, &hdesc))) {\n\t\tdbg_hid(\"class descriptor not present\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (hdesc->bLength < sizeof(struct hid_descriptor)) {\n\t\tdbg_hid(\"hid descriptor is too short\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\thid->version = le16_to_cpu(hdesc->bcdHID);\n\thid->country = hdesc->bCountryCode;\n\n\tnum_descriptors = min_t(int, hdesc->bNumDescriptors,\n\t       (hdesc->bLength - offset) / sizeof(struct hid_class_descriptor));\n\n\tfor (n = 0; n < num_descriptors; n++)\n\t\tif (hdesc->desc[n].bDescriptorType == HID_DT_REPORT)\n\t\t\trsize = le16_to_cpu(hdesc->desc[n].wDescriptorLength);\n\n\tif (!rsize || rsize > HID_MAX_DESCRIPTOR_SIZE) {\n\t\tdbg_hid(\"weird size of report descriptor (%u)\\n\", rsize);\n\t\treturn -EINVAL;\n\t}\n\n\trdesc = kmalloc(rsize, GFP_KERNEL);\n\tif (!rdesc)\n\t\treturn -ENOMEM;\n\n\thid_set_idle(dev, interface->desc.bInterfaceNumber, 0, 0);\n\n\tret = hid_get_class_descriptor(dev, interface->desc.bInterfaceNumber,\n\t\t\tHID_DT_REPORT, rdesc, rsize);\n\tif (ret < 0) {\n\t\tdbg_hid(\"reading report descriptor failed\\n\");\n\t\tkfree(rdesc);\n\t\tgoto err;\n\t}\n\n\tret = hid_parse_report(hid, rdesc, rsize);\n\tkfree(rdesc);\n\tif (ret) {\n\t\tdbg_hid(\"parsing report descriptor failed\\n\");\n\t\tgoto err;\n\t}\n\n\thid->quirks |= quirks;\n\n\treturn 0;\nerr:\n\treturn ret;\n}\n\nstatic int usbhid_start(struct hid_device *hid)\n{\n\tstruct usb_interface *intf = to_usb_interface(hid->dev.parent);\n\tstruct usb_host_interface *interface = intf->cur_altsetting;\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tunsigned int n, insize = 0;\n\tint ret;\n\n\tclear_bit(HID_DISCONNECTED, &usbhid->iofl);\n\n\tusbhid->bufsize = HID_MIN_BUFFER_SIZE;\n\thid_find_max_report(hid, HID_INPUT_REPORT, &usbhid->bufsize);\n\thid_find_max_report(hid, HID_OUTPUT_REPORT, &usbhid->bufsize);\n\thid_find_max_report(hid, HID_FEATURE_REPORT, &usbhid->bufsize);\n\n\tif (usbhid->bufsize > HID_MAX_BUFFER_SIZE)\n\t\tusbhid->bufsize = HID_MAX_BUFFER_SIZE;\n\n\thid_find_max_report(hid, HID_INPUT_REPORT, &insize);\n\n\tif (insize > HID_MAX_BUFFER_SIZE)\n\t\tinsize = HID_MAX_BUFFER_SIZE;\n\n\tif (hid_alloc_buffers(dev, hid)) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tfor (n = 0; n < interface->desc.bNumEndpoints; n++) {\n\t\tstruct usb_endpoint_descriptor *endpoint;\n\t\tint pipe;\n\t\tint interval;\n\n\t\tendpoint = &interface->endpoint[n].desc;\n\t\tif (!usb_endpoint_xfer_int(endpoint))\n\t\t\tcontinue;\n\n\t\tinterval = endpoint->bInterval;\n\n\t\t/* Some vendors give fullspeed interval on highspeed devides */\n\t\tif (hid->quirks & HID_QUIRK_FULLSPEED_INTERVAL &&\n\t\t    dev->speed == USB_SPEED_HIGH) {\n\t\t\tinterval = fls(endpoint->bInterval*8);\n\t\t\tpr_info(\"%s: Fixing fullspeed to highspeed interval: %d -> %d\\n\",\n\t\t\t\thid->name, endpoint->bInterval, interval);\n\t\t}\n\n\t\t/* Change the polling interval of mice and joysticks. */\n\t\tswitch (hid->collection->usage) {\n\t\tcase HID_GD_MOUSE:\n\t\t\tif (hid_mousepoll_interval > 0)\n\t\t\t\tinterval = hid_mousepoll_interval;\n\t\t\tbreak;\n\t\tcase HID_GD_JOYSTICK:\n\t\t\tif (hid_jspoll_interval > 0)\n\t\t\t\tinterval = hid_jspoll_interval;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = -ENOMEM;\n\t\tif (usb_endpoint_dir_in(endpoint)) {\n\t\t\tif (usbhid->urbin)\n\t\t\t\tcontinue;\n\t\t\tif (!(usbhid->urbin = usb_alloc_urb(0, GFP_KERNEL)))\n\t\t\t\tgoto fail;\n\t\t\tpipe = usb_rcvintpipe(dev, endpoint->bEndpointAddress);\n\t\t\tusb_fill_int_urb(usbhid->urbin, dev, pipe, usbhid->inbuf, insize,\n\t\t\t\t\t hid_irq_in, hid, interval);\n\t\t\tusbhid->urbin->transfer_dma = usbhid->inbuf_dma;\n\t\t\tusbhid->urbin->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\t\t} else {\n\t\t\tif (usbhid->urbout)\n\t\t\t\tcontinue;\n\t\t\tif (!(usbhid->urbout = usb_alloc_urb(0, GFP_KERNEL)))\n\t\t\t\tgoto fail;\n\t\t\tpipe = usb_sndintpipe(dev, endpoint->bEndpointAddress);\n\t\t\tusb_fill_int_urb(usbhid->urbout, dev, pipe, usbhid->outbuf, 0,\n\t\t\t\t\t hid_irq_out, hid, interval);\n\t\t\tusbhid->urbout->transfer_dma = usbhid->outbuf_dma;\n\t\t\tusbhid->urbout->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\t\t}\n\t}\n\n\tusbhid->urbctrl = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!usbhid->urbctrl) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tusb_fill_control_urb(usbhid->urbctrl, dev, 0, (void *) usbhid->cr,\n\t\t\t     usbhid->ctrlbuf, 1, hid_ctrl, hid);\n\tusbhid->urbctrl->transfer_dma = usbhid->ctrlbuf_dma;\n\tusbhid->urbctrl->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\tset_bit(HID_STARTED, &usbhid->iofl);\n\n\tif (hid->quirks & HID_QUIRK_ALWAYS_POLL) {\n\t\tret = usb_autopm_get_interface(usbhid->intf);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t\tset_bit(HID_IN_POLLING, &usbhid->iofl);\n\t\tusbhid->intf->needs_remote_wakeup = 1;\n\t\tret = hid_start_in(hid);\n\t\tif (ret) {\n\t\t\tdev_err(&hid->dev,\n\t\t\t\t\"failed to start in urb: %d\\n\", ret);\n\t\t}\n\t\tusb_autopm_put_interface(usbhid->intf);\n\t}\n\n\t/* Some keyboards don't work until their LEDs have been set.\n\t * Since BIOSes do set the LEDs, it must be safe for any device\n\t * that supports the keyboard boot protocol.\n\t * In addition, enable remote wakeup by default for all keyboard\n\t * devices supporting the boot protocol.\n\t */\n\tif (interface->desc.bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT &&\n\t\t\tinterface->desc.bInterfaceProtocol ==\n\t\t\t\tUSB_INTERFACE_PROTOCOL_KEYBOARD) {\n\t\tusbhid_set_leds(hid);\n\t\tdevice_set_wakeup_enable(&dev->dev, 1);\n\t}\n\treturn 0;\n\nfail:\n\tusb_free_urb(usbhid->urbin);\n\tusb_free_urb(usbhid->urbout);\n\tusb_free_urb(usbhid->urbctrl);\n\tusbhid->urbin = NULL;\n\tusbhid->urbout = NULL;\n\tusbhid->urbctrl = NULL;\n\thid_free_buffers(dev, hid);\n\treturn ret;\n}\n\nstatic void usbhid_stop(struct hid_device *hid)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\tif (WARN_ON(!usbhid))\n\t\treturn;\n\n\tif (hid->quirks & HID_QUIRK_ALWAYS_POLL) {\n\t\tclear_bit(HID_IN_POLLING, &usbhid->iofl);\n\t\tusbhid->intf->needs_remote_wakeup = 0;\n\t}\n\n\tclear_bit(HID_STARTED, &usbhid->iofl);\n\tspin_lock_irq(&usbhid->lock);\t/* Sync with error and led handlers */\n\tset_bit(HID_DISCONNECTED, &usbhid->iofl);\n\tspin_unlock_irq(&usbhid->lock);\n\tusb_kill_urb(usbhid->urbin);\n\tusb_kill_urb(usbhid->urbout);\n\tusb_kill_urb(usbhid->urbctrl);\n\n\thid_cancel_delayed_stuff(usbhid);\n\n\thid->claimed = 0;\n\n\tusb_free_urb(usbhid->urbin);\n\tusb_free_urb(usbhid->urbctrl);\n\tusb_free_urb(usbhid->urbout);\n\tusbhid->urbin = NULL; /* don't mess up next start */\n\tusbhid->urbctrl = NULL;\n\tusbhid->urbout = NULL;\n\n\thid_free_buffers(hid_to_usb_dev(hid), hid);\n}\n\nstatic int usbhid_power(struct hid_device *hid, int lvl)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tint r = 0;\n\n\tswitch (lvl) {\n\tcase PM_HINT_FULLON:\n\t\tr = usb_autopm_get_interface(usbhid->intf);\n\t\tbreak;\n\n\tcase PM_HINT_NORMAL:\n\t\tusb_autopm_put_interface(usbhid->intf);\n\t\tbreak;\n\t}\n\n\treturn r;\n}\n\nstatic void usbhid_request(struct hid_device *hid, struct hid_report *rep, int reqtype)\n{\n\tswitch (reqtype) {\n\tcase HID_REQ_GET_REPORT:\n\t\tusbhid_submit_report(hid, rep, USB_DIR_IN);\n\t\tbreak;\n\tcase HID_REQ_SET_REPORT:\n\t\tusbhid_submit_report(hid, rep, USB_DIR_OUT);\n\t\tbreak;\n\t}\n}\n\nstatic int usbhid_raw_request(struct hid_device *hid, unsigned char reportnum,\n\t\t\t      __u8 *buf, size_t len, unsigned char rtype,\n\t\t\t      int reqtype)\n{\n\tswitch (reqtype) {\n\tcase HID_REQ_GET_REPORT:\n\t\treturn usbhid_get_raw_report(hid, reportnum, buf, len, rtype);\n\tcase HID_REQ_SET_REPORT:\n\t\treturn usbhid_set_raw_report(hid, reportnum, buf, len, rtype);\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\nstatic int usbhid_idle(struct hid_device *hid, int report, int idle,\n\t\tint reqtype)\n{\n\tstruct usb_device *dev = hid_to_usb_dev(hid);\n\tstruct usb_interface *intf = to_usb_interface(hid->dev.parent);\n\tstruct usb_host_interface *interface = intf->cur_altsetting;\n\tint ifnum = interface->desc.bInterfaceNumber;\n\n\tif (reqtype != HID_REQ_SET_IDLE)\n\t\treturn -EINVAL;\n\n\treturn hid_set_idle(dev, ifnum, report, idle);\n}\n\nstruct hid_ll_driver usb_hid_driver = {\n\t.parse = usbhid_parse,\n\t.start = usbhid_start,\n\t.stop = usbhid_stop,\n\t.open = usbhid_open,\n\t.close = usbhid_close,\n\t.power = usbhid_power,\n\t.request = usbhid_request,\n\t.wait = usbhid_wait_io,\n\t.raw_request = usbhid_raw_request,\n\t.output_report = usbhid_output_report,\n\t.idle = usbhid_idle,\n};\nEXPORT_SYMBOL_GPL(usb_hid_driver);\n\nstatic int usbhid_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_host_interface *interface = intf->cur_altsetting;\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct usbhid_device *usbhid;\n\tstruct hid_device *hid;\n\tunsigned int n, has_in = 0;\n\tsize_t len;\n\tint ret;\n\n\tdbg_hid(\"HID probe called for ifnum %d\\n\",\n\t\t\tintf->altsetting->desc.bInterfaceNumber);\n\n\tfor (n = 0; n < interface->desc.bNumEndpoints; n++)\n\t\tif (usb_endpoint_is_int_in(&interface->endpoint[n].desc))\n\t\t\thas_in++;\n\tif (!has_in) {\n\t\thid_err(intf, \"couldn't find an input interrupt endpoint\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\thid = hid_allocate_device();\n\tif (IS_ERR(hid))\n\t\treturn PTR_ERR(hid);\n\n\tusb_set_intfdata(intf, hid);\n\thid->ll_driver = &usb_hid_driver;\n\thid->ff_init = hid_pidff_init;\n#ifdef CONFIG_USB_HIDDEV\n\thid->hiddev_connect = hiddev_connect;\n\thid->hiddev_disconnect = hiddev_disconnect;\n\thid->hiddev_hid_event = hiddev_hid_event;\n\thid->hiddev_report_event = hiddev_report_event;\n#endif\n\thid->dev.parent = &intf->dev;\n\thid->bus = BUS_USB;\n\thid->vendor = le16_to_cpu(dev->descriptor.idVendor);\n\thid->product = le16_to_cpu(dev->descriptor.idProduct);\n\thid->name[0] = 0;\n\thid->quirks = usbhid_lookup_quirk(hid->vendor, hid->product);\n\tif (intf->cur_altsetting->desc.bInterfaceProtocol ==\n\t\t\tUSB_INTERFACE_PROTOCOL_MOUSE)\n\t\thid->type = HID_TYPE_USBMOUSE;\n\telse if (intf->cur_altsetting->desc.bInterfaceProtocol == 0)\n\t\thid->type = HID_TYPE_USBNONE;\n\n\tif (dev->manufacturer)\n\t\tstrlcpy(hid->name, dev->manufacturer, sizeof(hid->name));\n\n\tif (dev->product) {\n\t\tif (dev->manufacturer)\n\t\t\tstrlcat(hid->name, \" \", sizeof(hid->name));\n\t\tstrlcat(hid->name, dev->product, sizeof(hid->name));\n\t}\n\n\tif (!strlen(hid->name))\n\t\tsnprintf(hid->name, sizeof(hid->name), \"HID %04x:%04x\",\n\t\t\t le16_to_cpu(dev->descriptor.idVendor),\n\t\t\t le16_to_cpu(dev->descriptor.idProduct));\n\n\tusb_make_path(dev, hid->phys, sizeof(hid->phys));\n\tstrlcat(hid->phys, \"/input\", sizeof(hid->phys));\n\tlen = strlen(hid->phys);\n\tif (len < sizeof(hid->phys) - 1)\n\t\tsnprintf(hid->phys + len, sizeof(hid->phys) - len,\n\t\t\t \"%d\", intf->altsetting[0].desc.bInterfaceNumber);\n\n\tif (usb_string(dev, dev->descriptor.iSerialNumber, hid->uniq, 64) <= 0)\n\t\thid->uniq[0] = 0;\n\n\tusbhid = kzalloc(sizeof(*usbhid), GFP_KERNEL);\n\tif (usbhid == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\thid->driver_data = usbhid;\n\tusbhid->hid = hid;\n\tusbhid->intf = intf;\n\tusbhid->ifnum = interface->desc.bInterfaceNumber;\n\n\tinit_waitqueue_head(&usbhid->wait);\n\tINIT_WORK(&usbhid->reset_work, hid_reset);\n\tsetup_timer(&usbhid->io_retry, hid_retry_timeout, (unsigned long) hid);\n\tspin_lock_init(&usbhid->lock);\n\n\tret = hid_add_device(hid);\n\tif (ret) {\n\t\tif (ret != -ENODEV)\n\t\t\thid_err(intf, \"can't add hid device: %d\\n\", ret);\n\t\tgoto err_free;\n\t}\n\n\treturn 0;\nerr_free:\n\tkfree(usbhid);\nerr:\n\thid_destroy_device(hid);\n\treturn ret;\n}\n\nstatic void usbhid_disconnect(struct usb_interface *intf)\n{\n\tstruct hid_device *hid = usb_get_intfdata(intf);\n\tstruct usbhid_device *usbhid;\n\n\tif (WARN_ON(!hid))\n\t\treturn;\n\n\tusbhid = hid->driver_data;\n\tspin_lock_irq(&usbhid->lock);\t/* Sync with error and led handlers */\n\tset_bit(HID_DISCONNECTED, &usbhid->iofl);\n\tspin_unlock_irq(&usbhid->lock);\n\thid_destroy_device(hid);\n\tkfree(usbhid);\n}\n\nstatic void hid_cancel_delayed_stuff(struct usbhid_device *usbhid)\n{\n\tdel_timer_sync(&usbhid->io_retry);\n\tcancel_work_sync(&usbhid->reset_work);\n}\n\nstatic void hid_cease_io(struct usbhid_device *usbhid)\n{\n\tdel_timer_sync(&usbhid->io_retry);\n\tusb_kill_urb(usbhid->urbin);\n\tusb_kill_urb(usbhid->urbctrl);\n\tusb_kill_urb(usbhid->urbout);\n}\n\nstatic void hid_restart_io(struct hid_device *hid)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tint clear_halt = test_bit(HID_CLEAR_HALT, &usbhid->iofl);\n\tint reset_pending = test_bit(HID_RESET_PENDING, &usbhid->iofl);\n\n\tspin_lock_irq(&usbhid->lock);\n\tclear_bit(HID_SUSPENDED, &usbhid->iofl);\n\tusbhid_mark_busy(usbhid);\n\n\tif (clear_halt || reset_pending)\n\t\tschedule_work(&usbhid->reset_work);\n\tusbhid->retry_delay = 0;\n\tspin_unlock_irq(&usbhid->lock);\n\n\tif (reset_pending || !test_bit(HID_STARTED, &usbhid->iofl))\n\t\treturn;\n\n\tif (!clear_halt) {\n\t\tif (hid_start_in(hid) < 0)\n\t\t\thid_io_error(hid);\n\t}\n\n\tspin_lock_irq(&usbhid->lock);\n\tif (usbhid->urbout && !test_bit(HID_OUT_RUNNING, &usbhid->iofl))\n\t\tusbhid_restart_out_queue(usbhid);\n\tif (!test_bit(HID_CTRL_RUNNING, &usbhid->iofl))\n\t\tusbhid_restart_ctrl_queue(usbhid);\n\tspin_unlock_irq(&usbhid->lock);\n}\n\n/* Treat USB reset pretty much the same as suspend/resume */\nstatic int hid_pre_reset(struct usb_interface *intf)\n{\n\tstruct hid_device *hid = usb_get_intfdata(intf);\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\tspin_lock_irq(&usbhid->lock);\n\tset_bit(HID_RESET_PENDING, &usbhid->iofl);\n\tspin_unlock_irq(&usbhid->lock);\n\thid_cease_io(usbhid);\n\n\treturn 0;\n}\n\n/* Same routine used for post_reset and reset_resume */\nstatic int hid_post_reset(struct usb_interface *intf)\n{\n\tstruct usb_device *dev = interface_to_usbdev (intf);\n\tstruct hid_device *hid = usb_get_intfdata(intf);\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tstruct usb_host_interface *interface = intf->cur_altsetting;\n\tint status;\n\tchar *rdesc;\n\n\t/* Fetch and examine the HID report descriptor. If this\n\t * has changed, then rebind. Since usbcore's check of the\n\t * configuration descriptors passed, we already know that\n\t * the size of the HID report descriptor has not changed.\n\t */\n\trdesc = kmalloc(hid->dev_rsize, GFP_KERNEL);\n\tif (!rdesc)\n\t\treturn -ENOMEM;\n\n\tstatus = hid_get_class_descriptor(dev,\n\t\t\t\tinterface->desc.bInterfaceNumber,\n\t\t\t\tHID_DT_REPORT, rdesc, hid->dev_rsize);\n\tif (status < 0) {\n\t\tdbg_hid(\"reading report descriptor failed (post_reset)\\n\");\n\t\tkfree(rdesc);\n\t\treturn status;\n\t}\n\tstatus = memcmp(rdesc, hid->dev_rdesc, hid->dev_rsize);\n\tkfree(rdesc);\n\tif (status != 0) {\n\t\tdbg_hid(\"report descriptor changed\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* No need to do another reset or clear a halted endpoint */\n\tspin_lock_irq(&usbhid->lock);\n\tclear_bit(HID_RESET_PENDING, &usbhid->iofl);\n\tclear_bit(HID_CLEAR_HALT, &usbhid->iofl);\n\tspin_unlock_irq(&usbhid->lock);\n\thid_set_idle(dev, intf->cur_altsetting->desc.bInterfaceNumber, 0, 0);\n\n\thid_restart_io(hid);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int hid_resume_common(struct hid_device *hid, bool driver_suspended)\n{\n\tint status = 0;\n\n\thid_restart_io(hid);\n\tif (driver_suspended && hid->driver && hid->driver->resume)\n\t\tstatus = hid->driver->resume(hid);\n\treturn status;\n}\n\nstatic int hid_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct hid_device *hid = usb_get_intfdata(intf);\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tint status = 0;\n\tbool driver_suspended = false;\n\tunsigned int ledcount;\n\n\tif (PMSG_IS_AUTO(message)) {\n\t\tledcount = hidinput_count_leds(hid);\n\t\tspin_lock_irq(&usbhid->lock);\t/* Sync with error handler */\n\t\tif (!test_bit(HID_RESET_PENDING, &usbhid->iofl)\n\t\t    && !test_bit(HID_CLEAR_HALT, &usbhid->iofl)\n\t\t    && !test_bit(HID_OUT_RUNNING, &usbhid->iofl)\n\t\t    && !test_bit(HID_CTRL_RUNNING, &usbhid->iofl)\n\t\t    && !test_bit(HID_KEYS_PRESSED, &usbhid->iofl)\n\t\t    && (!ledcount || ignoreled))\n\t\t{\n\t\t\tset_bit(HID_SUSPENDED, &usbhid->iofl);\n\t\t\tspin_unlock_irq(&usbhid->lock);\n\t\t\tif (hid->driver && hid->driver->suspend) {\n\t\t\t\tstatus = hid->driver->suspend(hid, message);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tdriver_suspended = true;\n\t\t} else {\n\t\t\tusbhid_mark_busy(usbhid);\n\t\t\tspin_unlock_irq(&usbhid->lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t} else {\n\t\t/* TODO: resume() might need to handle suspend failure */\n\t\tif (hid->driver && hid->driver->suspend)\n\t\t\tstatus = hid->driver->suspend(hid, message);\n\t\tdriver_suspended = true;\n\t\tspin_lock_irq(&usbhid->lock);\n\t\tset_bit(HID_SUSPENDED, &usbhid->iofl);\n\t\tspin_unlock_irq(&usbhid->lock);\n\t\tif (usbhid_wait_io(hid) < 0)\n\t\t\tstatus = -EIO;\n\t}\n\n\thid_cancel_delayed_stuff(usbhid);\n\thid_cease_io(usbhid);\n\n\tif (PMSG_IS_AUTO(message) && test_bit(HID_KEYS_PRESSED, &usbhid->iofl)) {\n\t\t/* lost race against keypresses */\n\t\tstatus = -EBUSY;\n\t\tgoto failed;\n\t}\n\tdev_dbg(&intf->dev, \"suspend\\n\");\n\treturn status;\n\n failed:\n\thid_resume_common(hid, driver_suspended);\n\treturn status;\n}\n\nstatic int hid_resume(struct usb_interface *intf)\n{\n\tstruct hid_device *hid = usb_get_intfdata (intf);\n\tint status;\n\n\tstatus = hid_resume_common(hid, true);\n\tdev_dbg(&intf->dev, \"resume status %d\\n\", status);\n\treturn 0;\n}\n\nstatic int hid_reset_resume(struct usb_interface *intf)\n{\n\tstruct hid_device *hid = usb_get_intfdata(intf);\n\tint status;\n\n\tstatus = hid_post_reset(intf);\n\tif (status >= 0 && hid->driver && hid->driver->reset_resume) {\n\t\tint ret = hid->driver->reset_resume(hid);\n\t\tif (ret < 0)\n\t\t\tstatus = ret;\n\t}\n\treturn status;\n}\n\n#endif /* CONFIG_PM */\n\nstatic const struct usb_device_id hid_usb_ids[] = {\n\t{ .match_flags = USB_DEVICE_ID_MATCH_INT_CLASS,\n\t\t.bInterfaceClass = USB_INTERFACE_CLASS_HID },\n\t{ }\t\t\t\t\t\t/* Terminating entry */\n};\n\nMODULE_DEVICE_TABLE (usb, hid_usb_ids);\n\nstatic struct usb_driver hid_driver = {\n\t.name =\t\t\"usbhid\",\n\t.probe =\tusbhid_probe,\n\t.disconnect =\tusbhid_disconnect,\n#ifdef CONFIG_PM\n\t.suspend =\thid_suspend,\n\t.resume =\thid_resume,\n\t.reset_resume =\thid_reset_resume,\n#endif\n\t.pre_reset =\thid_pre_reset,\n\t.post_reset =\thid_post_reset,\n\t.id_table =\thid_usb_ids,\n\t.supports_autosuspend = 1,\n};\n\nstruct usb_interface *usbhid_find_interface(int minor)\n{\n\treturn usb_find_interface(&hid_driver, minor);\n}\n\nstatic int __init hid_init(void)\n{\n\tint retval = -ENOMEM;\n\n\tretval = usbhid_quirks_init(quirks_param);\n\tif (retval)\n\t\tgoto usbhid_quirks_init_fail;\n\tretval = usb_register(&hid_driver);\n\tif (retval)\n\t\tgoto usb_register_fail;\n\tpr_info(KBUILD_MODNAME \": \" DRIVER_DESC \"\\n\");\n\n\treturn 0;\nusb_register_fail:\n\tusbhid_quirks_exit();\nusbhid_quirks_init_fail:\n\treturn retval;\n}\n\nstatic void __exit hid_exit(void)\n{\n\tusb_deregister(&hid_driver);\n\tusbhid_quirks_exit();\n}\n\nmodule_init(hid_init);\nmodule_exit(hid_exit);\n\nMODULE_AUTHOR(\"Andreas Gal\");\nMODULE_AUTHOR(\"Vojtech Pavlik\");\nMODULE_AUTHOR(\"Jiri Kosina\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["drivers/hid/usbhid/hid-core.c"], "buggy_code_start_loc": [977], "buggy_code_end_loc": [1004], "fixing_code_start_loc": [978], "fixing_code_end_loc": [1014], "type": "CWE-125", "message": "The usbhid_parse function in drivers/hid/usbhid/hid-core.c in the Linux kernel before 4.13.8 allows local users to cause a denial of service (out-of-bounds read and system crash) or possibly have unspecified other impact via a crafted USB device.", "other": {"cve": {"id": "CVE-2017-16533", "sourceIdentifier": "cve@mitre.org", "published": "2017-11-04T01:29:37.070", "lastModified": "2018-08-24T10:29:01.100", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The usbhid_parse function in drivers/hid/usbhid/hid-core.c in the Linux kernel before 4.13.8 allows local users to cause a denial of service (out-of-bounds read and system crash) or possibly have unspecified other impact via a crafted USB device."}, {"lang": "es", "value": "La funci\u00f3n usbhid_parse en drivers/hid/usbhid/hid-core.c en el kernel de Linux, en versiones anteriores a la 4.13.8, permite que los usuarios locales provoquen una denegaci\u00f3n de servicio (lectura fuera de l\u00edmites y cierre inesperado del sistema) o, posiblemente, causen otros impactos no especificados mediante llamadas del sistema manipuladas."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:P/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.7, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.13.7", "matchCriteriaId": "11C6B206-8716-4A16-81BD-F3B8C8ACBE19"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/102026", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/f043bfc98c193c284e2cd768fefabe18ac2fed9b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://groups.google.com/d/msg/syzkaller/CxkJ9QZgwlM/O3IOvAaGAwAJ", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2017/12/msg00004.html", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3754-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/f043bfc98c193c284e2cd768fefabe18ac2fed9b"}}