{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2005-2022\n *\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / common tools sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/xml.h>\n#include <gpac/utf.h>\n#include <gpac/network.h>\n\n#ifndef GPAC_DISABLE_ZLIB\n/*since 0.2.2, we use zlib for xmt/x3d reading to handle gz files*/\n#include <zlib.h>\n\n#if (defined(WIN32) || defined(_WIN32_WCE)) && !defined(__GNUC__)\n#pragma comment(lib, \"zlib\")\n#endif\n#else\n#define NO_GZIP\n#endif\n\n\n#define XML_INPUT_SIZE\t4096\n\n\nstatic GF_Err gf_xml_sax_parse_intern(GF_SAXParser *parser, char *current);\n\nstatic char *xml_translate_xml_string(char *str)\n{\n\tchar *value;\n\tu32 size, i, j;\n\tif (!str || !strlen(str)) return NULL;\n\tvalue = (char *)gf_malloc(sizeof(char) * 500);\n\tsize = 500;\n\ti = j = 0;\n\twhile (str[i]) {\n\t\tif (j+20 >= size) {\n\t\t\tsize += 500;\n\t\t\tvalue = (char *)gf_realloc(value, sizeof(char)*size);\n\t\t}\n\t\tif (str[i] == '&') {\n\t\t\tif (str[i+1]=='#') {\n\t\t\t\tchar szChar[20], *end;\n\t\t\t\tu16 wchar[2];\n\t\t\t\tu32 val, _len;\n\t\t\t\tconst unsigned short *srcp;\n\t\t\t\tstrncpy(szChar, str+i, 10);\n\t\t\t\tszChar[10] = 0;\n\t\t\t\tend = strchr(szChar, ';');\n\t\t\t\tif (!end) break;\n\t\t\t\tend[1] = 0;\n\t\t\t\ti += (u32) strlen(szChar);\n\t\t\t\twchar[1] = 0;\n\t\t\t\tif (szChar[2]=='x')\n\t\t\t\t\tsscanf(szChar, \"&#x%x;\", &val);\n\t\t\t\telse\n\t\t\t\t\tsscanf(szChar, \"&#%u;\", &val);\n\t\t\t\twchar[0] = val;\n\t\t\t\tsrcp = wchar;\n\t\t\t\t_len = gf_utf8_wcstombs(&value[j], 20, &srcp);\n\t\t\t\tif (_len == GF_UTF8_FAIL) _len = 0;\n\t\t\t\tj += _len;\n\t\t\t}\n\t\t\telse if (!strnicmp(&str[i], \"&amp;\", sizeof(char)*5)) {\n\t\t\t\tvalue[j] = '&';\n\t\t\t\tj++;\n\t\t\t\ti+= 5;\n\t\t\t}\n\t\t\telse if (!strnicmp(&str[i], \"&lt;\", sizeof(char)*4)) {\n\t\t\t\tvalue[j] = '<';\n\t\t\t\tj++;\n\t\t\t\ti+= 4;\n\t\t\t}\n\t\t\telse if (!strnicmp(&str[i], \"&gt;\", sizeof(char)*4)) {\n\t\t\t\tvalue[j] = '>';\n\t\t\t\tj++;\n\t\t\t\ti+= 4;\n\t\t\t}\n\t\t\telse if (!strnicmp(&str[i], \"&apos;\", sizeof(char)*6)) {\n\t\t\t\tvalue[j] = '\\'';\n\t\t\t\tj++;\n\t\t\t\ti+= 6;\n\t\t\t}\n\t\t\telse if (!strnicmp(&str[i], \"&quot;\", sizeof(char)*6)) {\n\t\t\t\tvalue[j] = '\\\"';\n\t\t\t\tj++;\n\t\t\t\ti+= 6;\n\t\t\t} else {\n\t\t\t\tvalue[j] = str[i];\n\t\t\t\tj++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t} else {\n\t\t\tvalue[j] = str[i];\n\t\t\tj++;\n\t\t\ti++;\n\t\t}\n\t}\n\tvalue[j] = 0;\n\treturn value;\n}\n\n\nenum\n{\n\tSAX_STATE_ATT_NAME,\n\tSAX_STATE_ATT_VALUE,\n\tSAX_STATE_ELEMENT,\n\tSAX_STATE_COMMENT,\n\tSAX_STATE_TEXT_CONTENT,\n\tSAX_STATE_ENTITY,\n\tSAX_STATE_SKIP_DOCTYPE,\n\tSAX_STATE_CDATA,\n\tSAX_STATE_DONE,\n\tSAX_STATE_XML_PROC,\n\tSAX_STATE_SYNTAX_ERROR,\n\tSAX_STATE_ALLOC_ERROR,\n};\n\ntypedef struct\n{\n\tu32 name_start, name_end;\n\tu32 val_start, val_end;\n\tBool has_entities;\n} GF_XMLSaxAttribute;\n\n\n/* #define NO_GZIP */\n\n\nstruct _tag_sax_parser\n{\n\t/*0: UTF-8, 1: UTF-16 BE, 2: UTF-16 LE. String input is always converted back to utf8*/\n\ts32 unicode_type;\n\tchar *buffer;\n\t/*alloc size, line size and current position*/\n\tu32 alloc_size, line_size, current_pos;\n\t/*current node depth*/\n\tu32 node_depth;\n\n\t/*gz input file*/\n#ifdef NO_GZIP\n\tFILE *f_in;\n#else\n\tgzFile gz_in;\n#endif\n\t/*current line , file size and pos for user notif*/\n\tu32 line, file_size, file_pos;\n\n\t/*SAX callbacks*/\n\tgf_xml_sax_node_start sax_node_start;\n\tgf_xml_sax_node_end sax_node_end;\n\tgf_xml_sax_text_content sax_text_content;\n\tvoid *sax_cbck;\n\tgf_xml_sax_progress on_progress;\n\n\tu32 sax_state;\n\tu32 init_state;\n\tGF_List *entities;\n\tchar att_sep;\n\tBool in_entity, suspended;\n\tu32 in_quote;\n\n\tu32 elt_start_pos, elt_end_pos;\n\n\t/*last error found*/\n\tchar err_msg[1000];\n\n\tu32 att_name_start, elt_name_start, elt_name_end, text_start, text_end;\n\tu32 text_check_escapes;\n\n\tGF_XMLAttribute *attrs;\n\tGF_XMLSaxAttribute *sax_attrs;\n\tu32 nb_attrs, nb_alloc_attrs;\n};\n\nstatic GF_XMLSaxAttribute *xml_get_sax_attribute(GF_SAXParser *parser)\n{\n\tif (parser->nb_attrs==parser->nb_alloc_attrs) {\n\t\tparser->nb_alloc_attrs++;\n\t\tparser->sax_attrs = (GF_XMLSaxAttribute *)gf_realloc(parser->sax_attrs, sizeof(GF_XMLSaxAttribute)*parser->nb_alloc_attrs);\n\t\tparser->attrs = (GF_XMLAttribute *)gf_realloc(parser->attrs, sizeof(GF_XMLAttribute)*parser->nb_alloc_attrs);\n\t}\n\treturn &parser->sax_attrs[parser->nb_attrs++];\n}\n\nstatic void xml_sax_swap(GF_SAXParser *parser)\n{\n\tif (parser->current_pos && ((parser->sax_state==SAX_STATE_TEXT_CONTENT) || (parser->sax_state==SAX_STATE_COMMENT) ) ) {\n\t\tif (parser->line_size >= parser->current_pos) {\n\t\t\tparser->line_size -= parser->current_pos;\n\t\t\tparser->file_pos += parser->current_pos;\n\t\t\tif (parser->line_size) memmove(parser->buffer, parser->buffer + parser->current_pos, sizeof(char)*parser->line_size);\n\t\t\tparser->buffer[parser->line_size] = 0;\n\t\t\tparser->current_pos = 0;\n\t\t}\n\t}\n}\n\nstatic void format_sax_error(GF_SAXParser *parser, u32 linepos, const char* fmt, ...)\n{\n\tva_list args;\n\tu32 len;\n\n\tif (!parser) return;\n\n\tva_start(args, fmt);\n\tvsnprintf(parser->err_msg, GF_ARRAY_LENGTH(parser->err_msg), fmt, args);\n\tva_end(args);\n\n\tif (strlen(parser->err_msg)+30 < GF_ARRAY_LENGTH(parser->err_msg)) {\n\t\tchar szM[20];\n\t\tsnprintf(szM, 20, \" - Line %d: \", parser->line + 1);\n\t\tstrcat(parser->err_msg, szM);\n\t\tlen = (u32) strlen(parser->err_msg);\n\t\tstrncpy(parser->err_msg + len, parser->buffer+ (linepos ? linepos : parser->current_pos), 10);\n\t\tparser->err_msg[len + 10] = 0;\n\t}\n\tparser->sax_state = SAX_STATE_SYNTAX_ERROR;\n}\n\nstatic void xml_sax_node_end(GF_SAXParser *parser, Bool had_children)\n{\n\tchar *name, c;\n\n\tassert(parser->elt_name_start);\n\tassert(parser->elt_name_end);\n\tif (!parser->node_depth) {\n\t\tformat_sax_error(parser, 0, \"Markup error\");\n\t\treturn;\n\t}\n\tc = parser->buffer[parser->elt_name_end - 1];\n\tparser->buffer[parser->elt_name_end - 1] = 0;\n\tname = parser->buffer + parser->elt_name_start - 1;\n\n\tif (parser->sax_node_end) {\n\t\tchar *sep = strchr(name, ':');\n\t\tif (sep) {\n\t\t\tsep[0] = 0;\n\t\t\tparser->sax_node_end(parser->sax_cbck, sep+1, name);\n\t\t\tsep[0] = ':';\n\t\t} else {\n\t\t\tparser->sax_node_end(parser->sax_cbck, name, NULL);\n\t\t}\n\t}\n\tparser->buffer[parser->elt_name_end - 1] = c;\n\tparser->node_depth--;\n\tif (!parser->init_state && !parser->node_depth) parser->sax_state = SAX_STATE_DONE;\n\txml_sax_swap(parser);\n\tparser->text_start = parser->text_end = 0;\n}\n\nstatic void xml_sax_node_start(GF_SAXParser *parser)\n{\n\tBool has_entities = GF_FALSE;\n\tu32 i;\n\tchar c, *name;\n\n\tassert(parser->elt_name_start && parser->elt_name_end);\n\tc = parser->buffer[parser->elt_name_end - 1];\n\tparser->buffer[parser->elt_name_end - 1] = 0;\n\tname = parser->buffer + parser->elt_name_start - 1;\n\n\tfor (i=0; i<parser->nb_attrs; i++) {\n\t\tparser->attrs[i].name = parser->buffer + parser->sax_attrs[i].name_start - 1;\n\t\tparser->buffer[parser->sax_attrs[i].name_end-1] = 0;\n\t\tparser->attrs[i].value = parser->buffer + parser->sax_attrs[i].val_start - 1;\n\t\tparser->buffer[parser->sax_attrs[i].val_end-1] = 0;\n\n\t\tif (strchr(parser->attrs[i].value, '&')) {\n\t\t\tparser->sax_attrs[i].has_entities = GF_TRUE;\n\t\t\thas_entities = GF_TRUE;\n\t\t\tparser->attrs[i].value = xml_translate_xml_string(parser->attrs[i].value);\n\t\t}\n\t\t/*store first char pos after current attrib for node peeking*/\n\t\tparser->att_name_start = parser->sax_attrs[i].val_end;\n\t}\n\n\tif (parser->sax_node_start) {\n\t\tchar *sep = strchr(name, ':');\n\t\tif (sep) {\n\t\t\tsep[0] = 0;\n\t\t\tparser->sax_node_start(parser->sax_cbck, sep+1, name, parser->attrs, parser->nb_attrs);\n\t\t\tsep[0] = ':';\n\t\t} else {\n\t\t\tparser->sax_node_start(parser->sax_cbck, name, NULL, parser->attrs, parser->nb_attrs);\n\t\t}\n\t}\n\tparser->att_name_start = 0;\n\tparser->buffer[parser->elt_name_end - 1] = c;\n\tparser->node_depth++;\n\tif (has_entities) {\n\t\tfor (i=0; i<parser->nb_attrs; i++) {\n\t\t\tif (parser->sax_attrs[i].has_entities) {\n\t\t\t\tparser->sax_attrs[i].has_entities = GF_FALSE;\n\t\t\t\tgf_free(parser->attrs[i].value);\n\t\t\t}\n\t\t}\n\t}\n\tparser->nb_attrs = 0;\n\txml_sax_swap(parser);\n\tparser->text_start = parser->text_end = 0;\n}\n\nstatic Bool xml_sax_parse_attribute(GF_SAXParser *parser)\n{\n\tchar *sep;\n\tGF_XMLSaxAttribute *att = NULL;\n\n\t/*looking for attribute name*/\n\tif (parser->sax_state==SAX_STATE_ATT_NAME) {\n\t\t/*looking for start*/\n\t\tif (!parser->att_name_start) {\n\t\t\twhile (parser->current_pos < parser->line_size) {\n\t\t\t\tu8 c = parser->buffer[parser->current_pos];\n\t\t\t\tswitch (c) {\n\t\t\t\tcase '\\n':\n\t\t\t\t\tparser->line++;\n\t\t\t\tcase ' ':\n\t\t\t\tcase '\\r':\n\t\t\t\tcase '\\t':\n\t\t\t\t\tparser->current_pos++;\n\t\t\t\t\tcontinue;\n\t\t\t\t/*end of element*/\n\t\t\t\tcase '?':\n\t\t\t\t\tif (parser->init_state!=1) break;\n\t\t\t\tcase '/':\n\t\t\t\t\t/*not enough data*/\n\t\t\t\t\tif (parser->current_pos+1 == parser->line_size) return GF_TRUE;\n\t\t\t\t\tif (parser->buffer[parser->current_pos+1]=='>') {\n\t\t\t\t\t\tparser->current_pos+=2;\n\t\t\t\t\t\tparser->elt_end_pos = parser->file_pos + parser->current_pos - 1;\n\t\t\t\t\t\t/*done parsing attr AND elements*/\n\t\t\t\t\t\tif (!parser->init_state) {\n\t\t\t\t\t\t\txml_sax_node_start(parser);\n\t\t\t\t\t\t\t/*move to SAX_STATE_TEXT_CONTENT to force text flush*/\n\t\t\t\t\t\t\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\t\t\t\t\t\t\txml_sax_node_end(parser, GF_FALSE);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparser->nb_attrs = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser->sax_state = (parser->init_state) ? SAX_STATE_ELEMENT : SAX_STATE_TEXT_CONTENT;\n\t\t\t\t\t\tparser->text_start = parser->text_end = 0;\n\t\t\t\t\t\treturn GF_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\tif (!parser->in_quote && (c=='/')) {\n\t\t\t\t\t\tif (!parser->init_state) {\n\t\t\t\t\t\t\tformat_sax_error(parser, 0, \"Markup error\");\n\t\t\t\t\t\t\treturn GF_TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\"':\n\t\t\t\t\tif (parser->sax_state==SAX_STATE_ATT_VALUE) break;\n\t\t\t\t\tif (parser->in_quote && (parser->in_quote!=c) ) {\n\t\t\t\t\t\tformat_sax_error(parser, 0, \"Markup error\");\n\t\t\t\t\t\treturn GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t\tif (parser->in_quote) parser->in_quote = 0;\n\t\t\t\t\telse parser->in_quote = c;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tparser->current_pos+=1;\n\t\t\t\t\t/*end of <!DOCTYPE>*/\n\t\t\t\t\tif (parser->init_state) {\n\t\t\t\t\t\tif (parser->init_state==1) {\n\t\t\t\t\t\t\tformat_sax_error(parser, 0, \"Invalid <!DOCTYPE...> or <?xml...?>\");\n\t\t\t\t\t\t\treturn GF_TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\t\t\t\treturn GF_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\t/*done parsing attr*/\n\t\t\t\t\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\t\t\t\t\txml_sax_node_start(parser);\n\t\t\t\t\treturn GF_FALSE;\n\t\t\t\tcase '[':\n\t\t\t\t\tif (parser->init_state) {\n\t\t\t\t\t\tparser->current_pos+=1;\n\t\t\t\t\t\tif (parser->init_state==1) {\n\t\t\t\t\t\t\tformat_sax_error(parser, 0, \"Invalid <!DOCTYPE...> or <?xml...?>\");\n\t\t\t\t\t\t\treturn GF_TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\t\t\t\treturn GF_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\tformat_sax_error(parser, 0, \"Invalid character '<'\");\n\t\t\t\t\treturn GF_FALSE;\n\t\t\t\t/*first char of attr name*/\n\t\t\t\tdefault:\n\t\t\t\t\tparser->att_name_start = parser->current_pos + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tparser->current_pos++;\n\t\t\t\tif (parser->att_name_start) break;\n\t\t\t}\n\t\t\tif (parser->current_pos == parser->line_size) return GF_TRUE;\n\t\t}\n\n\t\tif (parser->init_state==2) {\n\t\t\tsep = strchr(parser->buffer + parser->att_name_start - 1, parser->in_quote ?  parser->in_quote : ' ');\n\t\t\t/*not enough data*/\n\t\t\tif (!sep) return GF_TRUE;\n\t\t\tparser->current_pos = (u32) (sep - parser->buffer);\n\t\t\tparser->att_name_start = 0;\n\t\t\tif (parser->in_quote) {\n\t\t\t\tparser->current_pos++;\n\t\t\t\tparser->in_quote = 0;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\n\t\t/*looking for '\"'*/\n\t\tif (parser->att_name_start) {\n\t\t\tu32 i, first=1;\n\t\t\tsep = strchr(parser->buffer + parser->att_name_start - 1, '=');\n\t\t\t/*not enough data*/\n\t\t\tif (!sep) return GF_TRUE;\n\n\t\t\tparser->current_pos = (u32) (sep - parser->buffer);\n\t\t\tatt = xml_get_sax_attribute(parser);\n\t\t\tatt->name_start = parser->att_name_start;\n\t\t\tatt->name_end = parser->current_pos + 1;\n\t\t\twhile (strchr(\" \\n\\t\", parser->buffer[att->name_end - 2])) {\n\t\t\t\tassert(att->name_end);\n\t\t\t\tatt->name_end --;\n\t\t\t}\n\t\t\tatt->has_entities = GF_FALSE;\n\n\t\t\tfor (i=att->name_start; i<att->name_end; i++) {\n\t\t\t\tchar c = parser->buffer[i-1];\n\t\t\t\tif ((c>='a') && (c<='z')) {}\n\t\t\t\telse if ((c>='A') && (c<='Z')) {}\n\t\t\t\telse if ((c==':') || (c=='_')) {}\n\n\t\t\t\telse if (!first && ((c=='-') || (c=='.') || ((c>='0') && (c<='9')) )) {}\n\n\t\t\t\telse {\n\t\t\t\t\tformat_sax_error(parser, att->name_start-1, \"Invalid character \\'%c\\' for attribute name\", c);\n\t\t\t\t\treturn GF_TRUE;\n\t\t\t\t}\n\n\t\t\t\tfirst=0;\n\t\t\t}\n\n\t\t\tparser->att_name_start = 0;\n\t\t\tparser->current_pos++;\n\t\t\tparser->sax_state = SAX_STATE_ATT_VALUE;\n\n\t\t}\n\t}\n\n\tif (parser->sax_state == SAX_STATE_ATT_VALUE) {\n\t\tatt = &parser->sax_attrs[parser->nb_attrs-1];\n\t\t/*looking for first delimiter*/\n\t\tif (!parser->att_sep) {\n\t\t\twhile (parser->current_pos < parser->line_size) {\n\t\t\t\tu8 c = parser->buffer[parser->current_pos];\n\t\t\t\tswitch (c) {\n\t\t\t\tcase '\\n':\n\t\t\t\t\tparser->line++;\n\t\t\t\tcase ' ':\n\t\t\t\tcase '\\r':\n\t\t\t\tcase '\\t':\n\t\t\t\t\tparser->current_pos++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase '\\'':\n\t\t\t\tcase '\"':\n\t\t\t\t\tparser->att_sep = c;\n\t\t\t\t\tatt->val_start = parser->current_pos + 2;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tparser->current_pos++;\n\t\t\t\tif (parser->att_sep) break;\n\t\t\t}\n\t\t\tif (parser->current_pos == parser->line_size) return GF_TRUE;\n\t\t}\n\natt_retry:\n\n\t\tassert(parser->att_sep);\n\t\tsep = strchr(parser->buffer + parser->current_pos, parser->att_sep);\n\t\tif (!sep || !sep[1]) return GF_TRUE;\n\n\t\tif (sep[1]==parser->att_sep) {\n\t\t\tformat_sax_error(parser, (u32) (sep - parser->buffer), \"Invalid character %c after attribute value separator %c \", sep[1], parser->att_sep);\n\t\t\treturn GF_TRUE;\n\t\t}\n\n\t\tif (!parser->init_state && (strchr(\" />\\n\\t\\r\", sep[1])==NULL)) {\n\t\t\tparser->current_pos = (u32) (sep - parser->buffer + 1);\n\t\t\tgoto att_retry;\n\t\t}\n\n\t\tparser->current_pos = (u32) (sep - parser->buffer);\n\t\tatt->val_end = parser->current_pos + 1;\n\t\tparser->current_pos++;\n\n\t\t/*\"style\" always at the beginning of the attributes for ease of parsing*/\n\t\tif (!strncmp(parser->buffer + att->name_start-1, \"style\", 5)) {\n\t\t\tGF_XMLSaxAttribute prev = parser->sax_attrs[0];\n\t\t\tparser->sax_attrs[0] = *att;\n\t\t\t*att = prev;\n\t\t}\n\t\tparser->att_sep = 0;\n\t\tparser->sax_state = SAX_STATE_ATT_NAME;\n\t\tparser->att_name_start = 0;\n\t\treturn GF_FALSE;\n\t}\n\treturn GF_TRUE;\n}\n\n\ntypedef struct\n{\n\tchar *name;\n\tchar *value;\n\tu32 namelen;\n\tu8 sep;\n} XML_Entity;\n\nstatic void xml_sax_flush_text(GF_SAXParser *parser)\n{\n\tchar *text, c;\n\tif (!parser->text_start || parser->init_state || !parser->sax_text_content) return;\n\n\tassert(parser->text_start < parser->text_end);\n\n\tc = parser->buffer[parser->text_end-1];\n\tparser->buffer[parser->text_end-1] = 0;\n\ttext = parser->buffer + parser->text_start-1;\n\n\t/*solve XML built-in entities*/\n//old code commented for ref, we now track escape chars\n//\tif (strchr(text, '&') && strchr(text, ';')) {\n\tif (parser->text_check_escapes==0x3) {\n\t\tchar *xml_text = xml_translate_xml_string(text);\n\t\tif (xml_text) {\n\t\t\tparser->sax_text_content(parser->sax_cbck, xml_text, (parser->sax_state==SAX_STATE_CDATA) ? GF_TRUE : GF_FALSE);\n\t\t\tgf_free(xml_text);\n\t\t}\n\t} else {\n\t\tparser->sax_text_content(parser->sax_cbck, text, (parser->sax_state==SAX_STATE_CDATA) ? GF_TRUE : GF_FALSE);\n\t}\n\tparser->buffer[parser->text_end-1] = c;\n\tparser->text_start = parser->text_end = 0;\n\tparser->text_check_escapes = 0;\n}\n\nstatic void xml_sax_store_text(GF_SAXParser *parser, u32 txt_len)\n{\n\tif (!txt_len) return;\n\n\tif (!parser->text_start) {\n\t\tparser->text_check_escapes = 0;\n\t\tparser->text_start = parser->current_pos + 1;\n\t\tparser->text_end = parser->text_start + txt_len;\n\t\tparser->current_pos += txt_len;\n\t\tassert(parser->current_pos <= parser->line_size);\n\t\treturn;\n\t}\n\t/*contiguous text*/\n\tif (parser->text_end && (parser->text_end-1 == parser->current_pos)) {\n\t\tparser->text_end += txt_len;\n\t\tparser->current_pos += txt_len;\n\t\tassert(parser->current_pos <= parser->line_size);\n\t\treturn;\n\t}\n\t/*need to flush*/\n\txml_sax_flush_text(parser);\n\n\tparser->text_start = parser->current_pos + 1;\n\tparser->text_end = parser->text_start + txt_len;\n\tparser->current_pos += txt_len;\n\tassert(parser->current_pos <= parser->line_size);\n}\n\nstatic char *xml_get_current_text(GF_SAXParser *parser)\n{\n\tchar *text, c;\n\tif (!parser->text_start) return NULL;\n\n\tc = parser->buffer[parser->text_end-1];\n\tparser->buffer[parser->text_end-1] = 0;\n\ttext = gf_strdup(parser->buffer + parser->text_start-1);\n\tparser->buffer[parser->text_end-1] = c;\n\tparser->text_start = parser->text_end = 0;\n\treturn text;\n}\n\nstatic void xml_sax_skip_doctype(GF_SAXParser *parser)\n{\n\twhile (parser->current_pos < parser->line_size) {\n\t\tif (parser->buffer[parser->current_pos]=='>') {\n\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\tparser->current_pos++;\n\t\t\txml_sax_swap(parser);\n\t\t\treturn;\n\t\t}\n\t\tparser->current_pos++;\n\t}\n}\n\nstatic void xml_sax_skip_xml_proc(GF_SAXParser *parser)\n{\n\twhile (parser->current_pos + 1 < parser->line_size) {\n\t\tif ((parser->buffer[parser->current_pos]=='?') && (parser->buffer[parser->current_pos+1]=='>')) {\n\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\tparser->current_pos++;\n\t\t\txml_sax_swap(parser);\n\t\t\treturn;\n\t\t}\n\t\tparser->current_pos++;\n\t}\n}\n\n\nstatic void xml_sax_parse_entity(GF_SAXParser *parser)\n{\n\tchar szC[2];\n\tchar *ent_name=NULL;\n\tu32 i = 0;\n\tXML_Entity *ent = (XML_Entity *)gf_list_last(parser->entities);\n\tchar *skip_chars = \" \\t\\n\\r\";\n\ti=0;\n\tif (ent && ent->value) ent = NULL;\n\tif (ent) skip_chars = NULL;\n\tszC[1]=0;\n\n\twhile (parser->current_pos+i < parser->line_size) {\n\t\tu8 c = parser->buffer[parser->current_pos+i];\n\t\tif (skip_chars && strchr(skip_chars, c)) {\n\t\t\tif (c=='\\n') parser->line++;\n\t\t\tparser->current_pos++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!ent && (c=='%')) {\n\t\t\tparser->current_pos+=i+1;\n\t\t\tparser->sax_state = SAX_STATE_SKIP_DOCTYPE;\n\t\t\tif (ent_name) gf_free(ent_name);\n\t\t\treturn;\n\t\t}\n\t\telse if (!ent && ((c=='\\\"') || (c=='\\'')) ) {\n\t\t\tGF_SAFEALLOC(ent, XML_Entity);\n\t\t\tif (!ent) {\n\t\t\t\tparser->sax_state = SAX_STATE_ALLOC_ERROR;\n\t\t\t\tif (ent_name) gf_free(ent_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!ent_name) gf_dynstrcat(&ent_name, \"\", NULL);\n\n\t\t\tent->name = ent_name;\n\t\t\tent_name=NULL;\n\t\t\tent->namelen = (u32) strlen(ent->name);\n\t\t\tent->sep = c;\n\t\t\tparser->current_pos += 1+i;\n\t\t\tassert(parser->current_pos < parser->line_size);\n\t\t\txml_sax_swap(parser);\n\t\t\ti=0;\n\t\t\tgf_list_add(parser->entities, ent);\n\t\t\tskip_chars = NULL;\n\t\t} else if (ent && c==ent->sep) {\n\t\t\tif (ent_name) gf_free(ent_name);\n\t\t\txml_sax_store_text(parser, i);\n\n\t\t\tent->value = xml_get_current_text(parser);\n\t\t\tif (!ent->value) ent->value = gf_strdup(\"\");\n\n\t\t\tparser->current_pos += 1;\n\t\t\tassert(parser->current_pos < parser->line_size);\n\t\t\txml_sax_swap(parser);\n\t\t\tparser->sax_state = SAX_STATE_SKIP_DOCTYPE;\n\t\t\treturn;\n\t\t} else if (!ent) {\n\t\t\tszC[0] = c;\n\t\t\tgf_dynstrcat(&ent_name, szC, NULL);\n\t\t\ti++;\n\t\t} else {\n\t\t\ti++;\n\t\t}\n\t}\n\tif (ent_name) gf_free(ent_name);\n\txml_sax_store_text(parser, i);\n}\n\nstatic void xml_sax_cdata(GF_SAXParser *parser)\n{\n\tchar *cd_end = strstr(parser->buffer + parser->current_pos, \"]]>\");\n\tif (!cd_end) {\n\t\txml_sax_store_text(parser, parser->line_size - parser->current_pos);\n\t} else {\n\t\tu32 size = (u32) (cd_end - (parser->buffer + parser->current_pos));\n\t\txml_sax_store_text(parser, size);\n\t\txml_sax_flush_text(parser);\n\t\tparser->current_pos += 3;\n\t\tassert(parser->current_pos <= parser->line_size);\n\t\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\t}\n}\n\nstatic Bool xml_sax_parse_comments(GF_SAXParser *parser)\n{\n\tchar *end = strstr(parser->buffer + parser->current_pos, \"-->\");\n\tif (!end) {\n\t\tif (parser->line_size>3)\n\t\t\tparser->current_pos = parser->line_size-3;\n\t\txml_sax_swap(parser);\n\t\treturn GF_FALSE;\n\t}\n\n\tparser->current_pos += 3 + (u32) (end - (parser->buffer + parser->current_pos) );\n\tassert(parser->current_pos <= parser->line_size);\n\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\tparser->text_start = parser->text_end = 0;\n\txml_sax_swap(parser);\n\treturn GF_TRUE;\n}\n\n\n\nstatic GF_Err xml_sax_parse(GF_SAXParser *parser, Bool force_parse)\n{\n\tu32 i = 0;\n\tBool is_text;\n\tu32 is_end;\n\tu8 c;\n\tchar *elt, sep;\n\tu32 cdata_sep;\n\n\twhile (parser->current_pos<parser->line_size) {\n\t\tif (!force_parse && parser->suspended) goto exit;\n\nrestart:\n\t\tis_text = GF_FALSE;\n\t\tswitch (parser->sax_state) {\n\t\t/*load an XML element*/\n\t\tcase SAX_STATE_TEXT_CONTENT:\n\t\t\tis_text = GF_TRUE;\n\t\tcase SAX_STATE_ELEMENT:\n\t\t\telt = NULL;\n\t\t\ti=0;\n\t\t\twhile ((c = parser->buffer[parser->current_pos+i]) !='<') {\n\t\t\t\tif ((parser->init_state==2) && (c ==']')) {\n\t\t\t\t\tparser->sax_state = SAX_STATE_ATT_NAME;\n\t\t\t\t\tparser->current_pos+=i+1;\n\t\t\t\t\tgoto restart;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t\tif (c=='\\n') parser->line++;\n\t\t\t\tif (is_text) {\n\t\t\t\t\tif (c=='&') parser->text_check_escapes |= 1;\n\t\t\t\t\telse if (c==';') parser->text_check_escapes |= 2;\n\t\t\t\t}\n\n\t\t\t\tif (parser->current_pos+i==parser->line_size) {\n\t\t\t\t\tif ((parser->line_size>=2*XML_INPUT_SIZE) && !parser->init_state)\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_SYNTAX_ERROR;\n\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_text && i) {\n\t\t\t\tu32 has_esc = parser->text_check_escapes;\n\t\t\t\txml_sax_store_text(parser, i);\n\t\t\t\tparser->text_check_escapes = has_esc;\n\t\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\t} else if (i) {\n\t\t\t\tparser->current_pos += i;\n\t\t\t\tassert(parser->current_pos < parser->line_size);\n\t\t\t}\n\t\t\tis_end = 0;\n\t\t\ti = 0;\n\t\t\tcdata_sep = 0;\n\t\t\twhile (1) {\n\t\t\t\tc = parser->buffer[parser->current_pos+1+i];\n\t\t\t\tif (!strncmp(parser->buffer+parser->current_pos+1+i, \"!--\", 3)) {\n\t\t\t\t\tparser->sax_state = SAX_STATE_COMMENT;\n\t\t\t\t\ti += 3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!c) {\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tif ((c=='\\t') || (c=='\\r') || (c==' ') ) {\n\t\t\t\t\tif (i) break;\n\t\t\t\t\telse parser->current_pos++;\n\t\t\t\t}\n\t\t\t\telse if (c=='\\n') {\n\t\t\t\t\tparser->line++;\n\t\t\t\t\tif (i) break;\n\t\t\t\t\telse parser->current_pos++;\n\t\t\t\t}\n\t\t\t\telse if (c=='>') break;\n\t\t\t\telse if (c=='=') break;\n\t\t\t\telse if (c=='[') {\n\t\t\t\t\ti++;\n\t\t\t\t\tif (!cdata_sep) cdata_sep = 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (c=='/') {\n\t\t\t\t\tis_end = !i ? 1 : 2;\n\t\t\t\t\ti++;\n\t\t\t\t} else if (c=='<') {\n\t\t\t\t\tif (parser->sax_state != SAX_STATE_COMMENT) {\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_SYNTAX_ERROR;\n\t\t\t\t\t\treturn GF_CORRUPTED_DATA;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\t/*\t\t\t\tif ((c=='[') && (parser->buffer[parser->elt_name_start-1 + i-2]=='A') ) break; */\n\t\t\t\tif (parser->current_pos+1+i==parser->line_size) {\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i) {\n\t\t\t\tparser->elt_name_start = parser->current_pos+1 + 1;\n\t\t\t\tif (is_end==1) parser->elt_name_start ++;\n\t\t\t\tif (is_end==2) parser->elt_name_end = parser->current_pos+1+i;\n\t\t\t\telse parser->elt_name_end = parser->current_pos+1+i + 1;\n\t\t\t}\n\t\t\tif (is_end) {\n\t\t\t\txml_sax_flush_text(parser);\n\t\t\t\tparser->elt_end_pos = parser->file_pos + parser->current_pos + i;\n\t\t\t\tif (is_end==2) {\n\t\t\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\t\t\txml_sax_node_start(parser);\n\t\t\t\t\txml_sax_node_end(parser, GF_FALSE);\n\t\t\t\t} else {\n\t\t\t\t\tparser->elt_end_pos += parser->elt_name_end - parser->elt_name_start;\n\t\t\t\t\txml_sax_node_end(parser, GF_TRUE);\n\t\t\t\t}\n\t\t\t\tif (parser->sax_state == SAX_STATE_SYNTAX_ERROR) break;\n\t\t\t\tparser->current_pos+=2+i;\n\t\t\t\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!parser->elt_name_end) {\n\t\t\t\treturn GF_CORRUPTED_DATA;\n\t\t\t}\n\t\t\tsep = parser->buffer[parser->elt_name_end-1];\n\t\t\tparser->buffer[parser->elt_name_end-1] = 0;\n\t\t\telt = parser->buffer + parser->elt_name_start-1;\n\n\t\t\tparser->sax_state = SAX_STATE_ATT_NAME;\n\t\t\tassert(parser->elt_start_pos <= parser->file_pos + parser->current_pos);\n\t\t\tparser->elt_start_pos = parser->file_pos + parser->current_pos;\n\n\t\t\tif (!strncmp(elt, \"!--\", 3)) {\n\t\t\t\txml_sax_flush_text(parser);\n\t\t\t\tparser->sax_state = SAX_STATE_COMMENT;\n\t\t\t\tif (i>3) parser->current_pos -= (i-3);\n\t\t\t}\n\t\t\telse if (!strcmp(elt, \"?xml\")) parser->init_state = 1;\n\t\t\telse if (!strcmp(elt, \"!DOCTYPE\")) parser->init_state = 2;\n\t\t\telse if (!strcmp(elt, \"!ENTITY\")) parser->sax_state = SAX_STATE_ENTITY;\n\t\t\telse if (!strcmp(elt, \"!ATTLIST\") || !strcmp(elt, \"!ELEMENT\")) parser->sax_state = SAX_STATE_SKIP_DOCTYPE;\n\t\t\telse if (!strcmp(elt, \"![CDATA[\"))\n\t\t\t\tparser->sax_state = SAX_STATE_CDATA;\n\t\t\telse if (elt[0]=='?') {\n\t\t\t\ti--;\n\t\t\t\tparser->sax_state = SAX_STATE_XML_PROC;\n\t\t\t}\n\t\t\t/*node found*/\n\t\t\telse {\n\t\t\t\txml_sax_flush_text(parser);\n\t\t\t\tif (parser->init_state) {\n\t\t\t\t\tparser->init_state = 0;\n\t\t\t\t\t/*that's a bit ugly: since we solve entities when appending text, we need to\n\t\t\t\t\treparse the current buffer*/\n\t\t\t\t\tif (gf_list_count(parser->entities)) {\n\t\t\t\t\t\tchar *orig_buf;\n\t\t\t\t\t\tGF_Err e;\n\t\t\t\t\t\tparser->buffer[parser->elt_name_end-1] = sep;\n\t\t\t\t\t\torig_buf = gf_strdup(parser->buffer + parser->current_pos);\n\t\t\t\t\t\tparser->current_pos = 0;\n\t\t\t\t\t\tparser->line_size = 0;\n\t\t\t\t\t\tparser->elt_start_pos = 0;\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\t\t\t\t\t\te = gf_xml_sax_parse_intern(parser, orig_buf);\n\t\t\t\t\t\tgf_free(orig_buf);\n\t\t\t\t\t\treturn e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tparser->current_pos+=1+i;\n\t\t\tparser->buffer[parser->elt_name_end-1] = sep;\n\t\t\tbreak;\n\t\tcase SAX_STATE_COMMENT:\n\t\t\tif (!xml_sax_parse_comments(parser)) {\n\t\t\t\txml_sax_swap(parser);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SAX_STATE_ATT_NAME:\n\t\tcase SAX_STATE_ATT_VALUE:\n\t\t\tif (xml_sax_parse_attribute(parser))\n\t\t\t\tgoto exit;\n\t\t\tbreak;\n\t\tcase SAX_STATE_ENTITY:\n\t\t\txml_sax_parse_entity(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_SKIP_DOCTYPE:\n\t\t\txml_sax_skip_doctype(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_XML_PROC:\n\t\t\txml_sax_skip_xml_proc(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_CDATA:\n\t\t\txml_sax_cdata(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_SYNTAX_ERROR:\n\t\t\treturn GF_CORRUPTED_DATA;\n\t\tcase SAX_STATE_ALLOC_ERROR:\n\t\t\treturn GF_OUT_OF_MEM;\n\t\tcase SAX_STATE_DONE:\n\t\t\treturn GF_EOS;\n\t\t}\n\t}\nexit:\n#if 0\n\tif (is_text) {\n\t\tif (i) xml_sax_store_text(parser, i);\n\t\t/*DON'T FLUSH TEXT YET, wait for next '<' to do so otherwise we may corrupt xml base entities (&apos;, ...)*/\n\t}\n#endif\n\txml_sax_swap(parser);\n\n\tif (parser->sax_state==SAX_STATE_SYNTAX_ERROR)\n\t\treturn GF_CORRUPTED_DATA;\n\telse\n\t\treturn GF_OK;\n}\n\nstatic GF_Err xml_sax_append_string(GF_SAXParser *parser, char *string)\n{\n\tu32 size = parser->line_size;\n\tu32 nl_size = (u32) strlen(string);\n\n\tif (!nl_size) return GF_OK;\n\n\tif ( (parser->alloc_size < size+nl_size+1)\n\t        /*\t\t|| (parser->alloc_size / 2 ) > size+nl_size+1 */\n\t   )\n\t{\n\t\tparser->alloc_size = size+nl_size+1;\n\t\tparser->alloc_size = 3 * parser->alloc_size / 2;\n\t\tparser->buffer = (char*)gf_realloc(parser->buffer, sizeof(char) * parser->alloc_size);\n\t\tif (!parser->buffer ) return GF_OUT_OF_MEM;\n\t}\n\tmemcpy(parser->buffer+size, string, sizeof(char)*nl_size);\n\tparser->buffer[size+nl_size] = 0;\n\tparser->line_size = size+nl_size;\n\treturn GF_OK;\n}\n\nstatic XML_Entity *gf_xml_locate_entity(GF_SAXParser *parser, char *ent_start, Bool *needs_text)\n{\n\tu32 i, count;\n\tu32 len = (u32) strlen(ent_start);\n\n\t*needs_text = GF_FALSE;\n\tcount = gf_list_count(parser->entities);\n\n\tfor (i=0; i<count; i++) {\n\t\tXML_Entity *ent = (XML_Entity *)gf_list_get(parser->entities, i);\n\t\tif (len < ent->namelen + 1) {\n\t\t\tif (strncmp(ent->name, ent_start, len))\n\t\t\t \treturn NULL;\n\n\t\t\t*needs_text = GF_TRUE;\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!strncmp(ent->name, ent_start, ent->namelen) && (ent_start[ent->namelen]==';')) {\n\t\t\treturn ent;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n\nstatic GF_Err gf_xml_sax_parse_intern(GF_SAXParser *parser, char *current)\n{\n\tu32 count;\n\t/*solve entities*/\n\tcount = gf_list_count(parser->entities);\n\twhile (count) {\n\t\tchar *entityEnd;\n\t\tXML_Entity *ent;\n\t\tchar *entityStart = strstr(current, \"&\");\n\t\tBool needs_text;\n\t\tu32 line_num;\n\n\t\t/*if in entity, the start of the entity is in the buffer !!*/\n\t\tif (parser->in_entity) {\n\t\t\tu32 len;\n\t\t\tchar *name;\n\t\t\tentityEnd = strstr(current, \";\");\n\t\t\tif (!entityEnd) return xml_sax_append_string(parser, current);\n\t\t\tentityStart = strrchr(parser->buffer, '&');\n\n\t\t\tentityEnd[0] = 0;\n\t\t\tlen = (u32) strlen(entityStart) + (u32) strlen(current) + 1;\n\t\t\tname = (char*)gf_malloc(sizeof(char)*len);\n\t\t\tsprintf(name, \"%s%s;\", entityStart+1, current);\n\n\t\t\tent = gf_xml_locate_entity(parser, name, &needs_text);\n\t\t\tgf_free(name);\n\n\t\t\tif (!ent && !needs_text) {\n\t\t\t\txml_sax_append_string(parser, current);\n\t\t\t\txml_sax_parse(parser, GF_TRUE);\n\t\t\t\tentityEnd[0] = ';';\n\t\t\t\tcurrent = entityEnd;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tassert(ent);\n\t\t\t/*truncate input buffer*/\n\t\t\tparser->line_size -= (u32) strlen(entityStart);\n\t\t\tentityStart[0] = 0;\n\n\t\t\tparser->in_entity = GF_FALSE;\n\t\t\tentityEnd[0] = ';';\n\t\t\tcurrent = entityEnd+1;\n\t\t} else {\n\t\t\tif (!entityStart) break;\n\n\t\t\tent = gf_xml_locate_entity(parser, entityStart+1, &needs_text);\n\n\t\t\t/*store current string before entity start*/\n\t\t\tentityStart[0] = 0;\n\t\t\txml_sax_append_string(parser, current);\n\t\t\txml_sax_parse(parser, GF_TRUE);\n\t\t\tentityStart[0] = '&';\n\n\t\t\t/*this is not an entitiy*/\n\t\t\tif (!ent && !needs_text) {\n\t\t\t\txml_sax_append_string(parser, \"&\");\n\t\t\t\tcurrent = entityStart+1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!ent) {\n\t\t\t\tparser->in_entity = GF_TRUE;\n\t\t\t\t/*store entity start*/\n\t\t\t\treturn xml_sax_append_string(parser, entityStart);\n\t\t\t}\n\t\t\tcurrent = entityStart + ent->namelen + 2;\n\t\t}\n\t\t/*append entity*/\n\t\tline_num = parser->line;\n\t\txml_sax_append_string(parser, ent->value);\n\t\txml_sax_parse(parser, GF_TRUE);\n\t\tparser->line = line_num;\n\n\t}\n\txml_sax_append_string(parser, current);\n\treturn xml_sax_parse(parser, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_xml_sax_parse(GF_SAXParser *parser, const void *string)\n{\n\tGF_Err e;\n\tchar *current;\n\tchar *utf_conv = NULL;\n\n\tif (parser->unicode_type < 0) return GF_BAD_PARAM;\n\n\tif (parser->unicode_type>1) {\n\t\tconst u16 *sptr = (const u16 *)string;\n\t\tu32 len = 2 * gf_utf8_wcslen(sptr);\n\t\tutf_conv = (char *)gf_malloc(sizeof(char)*(len+1));\n\t\tlen = gf_utf8_wcstombs(utf_conv, len, &sptr);\n\t\tif (len == GF_UTF8_FAIL) {\n\t\t\tparser->sax_state = SAX_STATE_SYNTAX_ERROR;\n\t\t\tgf_free(utf_conv);\n\t\t\treturn GF_CORRUPTED_DATA;\n\t\t}\n\t\tutf_conv[len] = 0;\n\t\tcurrent = utf_conv;\n\t} else {\n\t\tcurrent = (char *)string;\n\t}\n\n\te = gf_xml_sax_parse_intern(parser, current);\n\tif (utf_conv) gf_free(utf_conv);\n\treturn e;\n}\n\n\nGF_EXPORT\nGF_Err gf_xml_sax_init(GF_SAXParser *parser, unsigned char *BOM)\n{\n\tu32 offset;\n\tif (!BOM) {\n\t\tparser->unicode_type = 0;\n\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\treturn GF_OK;\n\t}\n\n\tif (parser->unicode_type >= 0) return gf_xml_sax_parse(parser, BOM);\n\n\tif ((BOM[0]==0xFF) && (BOM[1]==0xFE)) {\n\t\tif (!BOM[2] && !BOM[3]) return GF_NOT_SUPPORTED;\n\t\tparser->unicode_type = 2;\n\t\toffset = 2;\n\t} else if ((BOM[0]==0xFE) && (BOM[1]==0xFF)) {\n\t\tif (!BOM[2] && !BOM[3]) return GF_NOT_SUPPORTED;\n\t\tparser->unicode_type = 1;\n\t\toffset = 2;\n\t} else if ((BOM[0]==0xEF) && (BOM[1]==0xBB) && (BOM[2]==0xBF)) {\n\t\t/*we handle UTF8 as asci*/\n\t\tparser->unicode_type = 0;\n\t\toffset = 3;\n\t} else {\n\t\tparser->unicode_type = 0;\n\t\toffset = 0;\n\t}\n\n#ifdef GPAC_ENABLE_COVERAGE\n\tif (gf_sys_is_cov_mode()) {\n\t\tformat_sax_error(NULL, 0, \"\");\n\t}\n#endif\n\n\tparser->sax_state = SAX_STATE_ELEMENT;\n\treturn gf_xml_sax_parse(parser, BOM + offset);\n}\n\nstatic void xml_sax_reset(GF_SAXParser *parser)\n{\n\twhile (1) {\n\t\tXML_Entity *ent = (XML_Entity *)gf_list_last(parser->entities);\n\t\tif (!ent) break;\n\t\tgf_list_rem_last(parser->entities);\n\t\tif (ent->name) gf_free(ent->name);\n\t\tif (ent->value) gf_free(ent->value);\n\t\tgf_free(ent);\n\t}\n\tif (parser->buffer) gf_free(parser->buffer);\n\tparser->buffer = NULL;\n\tparser->current_pos = 0;\n\tgf_free(parser->attrs);\n\tparser->attrs = NULL;\n\tgf_free(parser->sax_attrs);\n\tparser->sax_attrs = NULL;\n\tparser->nb_alloc_attrs = parser->nb_attrs = 0;\n}\n\n\nstatic GF_Err xml_sax_read_file(GF_SAXParser *parser)\n{\n\tGF_Err e = GF_EOS;\n\tunsigned char szLine[XML_INPUT_SIZE+2];\n\n#ifdef NO_GZIP\n\tif (!parser->f_in) return GF_BAD_PARAM;\n#else\n\tif (!parser->gz_in) return GF_BAD_PARAM;\n#endif\n\n\n\twhile (!parser->suspended) {\n#ifdef NO_GZIP\n\t\ts32 read = (s32)gf_fread(szLine, XML_INPUT_SIZE, parser->f_in);\n#else\n\t\ts32 read = gf_gzread(parser->gz_in, szLine, XML_INPUT_SIZE);\n#endif\n\t\tif ((read<=0) /*&& !parser->node_depth*/) break;\n\t\tszLine[read] = 0;\n\t\tszLine[read+1] = 0;\n\t\te = gf_xml_sax_parse(parser, szLine);\n\t\tif (e) break;\n\t\tif (parser->file_pos > parser->file_size) parser->file_size = parser->file_pos + 1;\n\t\tif (parser->on_progress) parser->on_progress(parser->sax_cbck, parser->file_pos, parser->file_size);\n\t}\n\n#ifdef NO_GZIP\n\tif (gf_feof(parser->f_in)) {\n#else\n\tif (gf_gzeof(parser->gz_in)) {\n#endif\n\t\tif (!e) e = GF_EOS;\n\t\tif (parser->on_progress) parser->on_progress(parser->sax_cbck, parser->file_size, parser->file_size);\n\n#ifdef NO_GZIP\n\t\tgf_fclose(parser->f_in);\n\t\tparser->f_in = NULL;\n#else\n\t\tgf_gzclose(parser->gz_in);\n\t\tparser->gz_in = 0;\n#endif\n\n\t\tparser->elt_start_pos = parser->elt_end_pos = 0;\n\t\tparser->elt_name_start = parser->elt_name_end = 0;\n\t\tparser->att_name_start = 0;\n\t\tparser->current_pos = 0;\n\t\tparser->line_size = 0;\n\t\tparser->att_sep = 0;\n\t\tparser->file_pos = 0;\n\t\tparser->file_size = 0;\n\t\tparser->line_size = 0;\n\t}\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_xml_sax_parse_file(GF_SAXParser *parser, const char *fileName, gf_xml_sax_progress OnProgress)\n{\n\tFILE *test;\n\tGF_Err e;\n\tu64 filesize;\n#ifndef NO_GZIP\n\tgzFile gzInput;\n#endif\n\tunsigned char szLine[6];\n\n\tparser->on_progress = OnProgress;\n\n\tif (!strncmp(fileName, \"gmem://\", 7)) {\n\t\tu32 size;\n\t\tu8 *xml_mem_address;\n\t\te = gf_blob_get(fileName, &xml_mem_address, &size, NULL);\n\t\tif (e) return e;\n\n\t\tparser->file_size = size;\n\t\t//copy possible BOM\n\t\tmemcpy(szLine, xml_mem_address, 4);\n\t\tszLine[4] = szLine[5] = 0;\n\n\t\tparser->file_pos = 0;\n\t\tparser->elt_start_pos = 0;\n\t\tparser->current_pos = 0;\n\n\t\te = gf_xml_sax_init(parser, szLine);\n        if (!e) {\n            e = gf_xml_sax_parse(parser, xml_mem_address+4);\n            if (parser->on_progress) parser->on_progress(parser->sax_cbck, parser->file_pos, parser->file_size);\n        }\n        gf_blob_release(fileName);\n        \n\t\tparser->elt_start_pos = parser->elt_end_pos = 0;\n\t\tparser->elt_name_start = parser->elt_name_end = 0;\n\t\tparser->att_name_start = 0;\n\t\tparser->current_pos = 0;\n\t\tparser->line_size = 0;\n\t\tparser->att_sep = 0;\n\t\tparser->file_pos = 0;\n\t\tparser->file_size = 0;\n\t\tparser->line_size = 0;\n\t\treturn e;\n\t}\n\n\t/*check file exists and gets its size (zlib doesn't support SEEK_END)*/\n\ttest = gf_fopen(fileName, \"rb\");\n\tif (!test) return GF_URL_ERROR;\n\n\tfilesize = gf_fsize(test);\n\tassert(filesize < 0x80000000);\n\tparser->file_size = (u32) filesize;\n\tgf_fclose(test);\n\n\tparser->file_pos = 0;\n\tparser->elt_start_pos = 0;\n\tparser->current_pos = 0;\n\t//open file and copy possible BOM\n#ifdef NO_GZIP\n\tparser->f_in = gf_fopen(fileName, \"rt\");\n\tif (gf_fread(szLine, 4, parser->f_in) != 4) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"[XML] Error loading BOM\\n\"));\n\t}\n#else\n\tgzInput = gf_gzopen(fileName, \"rb\");\n\tif (!gzInput) return GF_IO_ERR;\n\tparser->gz_in = gzInput;\n\t/*init SAX parser (unicode setup)*/\n\tgf_gzread(gzInput, szLine, 4);\n#endif\n\n\tszLine[4] = szLine[5] = 0;\n\te = gf_xml_sax_init(parser, szLine);\n\tif (e) return e;\n\n\treturn xml_sax_read_file(parser);\n}\n\nGF_EXPORT\nBool gf_xml_sax_binary_file(GF_SAXParser *parser)\n{\n\tif (!parser) return GF_FALSE;\n#ifdef NO_GZIP\n\treturn GF_FALSE;\n#else\n\tif (!parser->gz_in) return GF_FALSE;\n\treturn (((z_stream*)parser->gz_in)->data_type==Z_BINARY) ? GF_TRUE : GF_FALSE;\n#endif\n}\n\nGF_EXPORT\nGF_SAXParser *gf_xml_sax_new(gf_xml_sax_node_start on_node_start,\n                             gf_xml_sax_node_end on_node_end,\n                             gf_xml_sax_text_content on_text_content,\n                             void *cbck)\n{\n\tGF_SAXParser *parser;\n\tGF_SAFEALLOC(parser, GF_SAXParser);\n\tif (!parser) return NULL;\n\tparser->entities = gf_list_new();\n\tparser->unicode_type = -1;\n\tparser->sax_node_start = on_node_start;\n\tparser->sax_node_end = on_node_end;\n\tparser->sax_text_content = on_text_content;\n\tparser->sax_cbck = cbck;\n\treturn parser;\n}\n\nGF_EXPORT\nvoid gf_xml_sax_del(GF_SAXParser *parser)\n{\n\txml_sax_reset(parser);\n\tgf_list_del(parser->entities);\n#ifdef NO_GZIP\n\tif (parser->f_in) gf_fclose(parser->f_in);\n#else\n\tif (parser->gz_in) gf_gzclose(parser->gz_in);\n#endif\n\tgf_free(parser);\n}\n\nGF_EXPORT\nGF_Err gf_xml_sax_suspend(GF_SAXParser *parser, Bool do_suspend)\n{\n\tparser->suspended = do_suspend;\n\tif (!do_suspend) {\n#ifdef NO_GZIP\n\t\tif (parser->f_in) return xml_sax_read_file(parser);\n#else\n\t\tif (parser->gz_in) return xml_sax_read_file(parser);\n#endif\n\t\treturn xml_sax_parse(parser, GF_FALSE);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nu32 gf_xml_sax_get_line(GF_SAXParser *parser) {\n\treturn parser->line + 1 ;\n}\n\n#if 0 //unused\nu32 gf_xml_sax_get_file_size(GF_SAXParser *parser)\n{\n#ifdef NO_GZIP\n\treturn parser->f_in ? parser->file_size : 0;\n#else\n\treturn parser->gz_in ? parser->file_size : 0;\n#endif\n}\n\nu32 gf_xml_sax_get_file_pos(GF_SAXParser *parser)\n{\n#ifdef NO_GZIP\n\treturn parser->f_in ? parser->file_pos : 0;\n#else\n\treturn parser->gz_in ? parser->file_pos : 0;\n#endif\n}\n#endif\n\n\n\nGF_EXPORT\nchar *gf_xml_sax_peek_node(GF_SAXParser *parser, char *att_name, char *att_value, char *substitute, char *get_attr, char *end_pattern, Bool *is_substitute)\n{\n\tu32 state, att_len, alloc_size, _len;\n#ifdef NO_GZIP\n\tu64 pos;\n#else\n\tz_off_t pos;\n#endif\n\tBool from_buffer;\n\tBool dobreak=GF_FALSE;\n\tchar szLine1[XML_INPUT_SIZE+2], szLine2[XML_INPUT_SIZE+2], *szLine, *cur_line, *sep, *start, first_c, *result;\n\n\n#define CPYCAT_ALLOC(__str, __is_copy) _len = (u32) strlen(__str);\\\n\t\t\t\t\t\t\tif ( _len + (__is_copy ? 0 : strlen(szLine))>=alloc_size) {\\\n\t\t\t\t\t\t\t\talloc_size = 1 + (u32) strlen(__str);\t\\\n\t\t\t\t\t\t\t\tif (!__is_copy) alloc_size += (u32) strlen(szLine); \\\n\t\t\t\t\t\t\t\tszLine = gf_realloc(szLine, alloc_size);\t\\\n\t\t\t\t\t\t\t}\\\n\t\t\t\t\t\t\tif (__is_copy) { memmove(szLine, __str, sizeof(char)*_len); szLine[_len] = 0; }\\\n\t\t\t\t\t\t\telse strcat(szLine, __str); \\\n\n\tfrom_buffer=GF_FALSE;\n#ifdef NO_GZIP\n\tif (!parser->f_in) from_buffer=GF_TRUE;\n#else\n\tif (!parser->gz_in) from_buffer=GF_TRUE;\n#endif\n\n\tresult = NULL;\n\n\tszLine1[0] = szLine2[0] = 0;\n\tpos=0;\n\tif (!from_buffer) {\n#ifdef NO_GZIP\n\t\tpos = gf_ftell(parser->f_in);\n#else\n\t\tpos = (u32) gf_gztell(parser->gz_in);\n#endif\n\t}\n\tatt_len = (u32) strlen(parser->buffer + parser->att_name_start);\n\tif (att_len<2*XML_INPUT_SIZE) att_len = 2*XML_INPUT_SIZE;\n\talloc_size = att_len;\n\tszLine = (char *) gf_malloc(sizeof(char)*alloc_size);\n\tstrcpy(szLine, parser->buffer + parser->att_name_start);\n\tcur_line = szLine;\n\tatt_len = (u32) strlen(att_value);\n\tstate = 0;\n\tgoto retry;\n\n\twhile (1) {\n\t\tu32 read;\n\t\tu8 sep_char;\n\t\tif (!from_buffer) {\n#ifdef NO_GZIP\n\t\t\tif (gf_feof(parser->f_in)) break;\n#else\n\t\t\tif (gf_gzeof(parser->gz_in)) break;\n#endif\n\t\t}\n\n\t\tif (dobreak) break;\n\n\t\tif (cur_line == szLine2) {\n\t\t\tcur_line = szLine1;\n\t\t} else {\n\t\t\tcur_line = szLine2;\n\t\t}\n\t\tif (from_buffer) {\n\t\t\tdobreak=GF_TRUE;\n\t\t} else {\n#ifdef NO_GZIP\n\t\t\tread = (u32)gf_fread(cur_line, XML_INPUT_SIZE, parser->f_in);\n#else\n\t\t\tread = gf_gzread(parser->gz_in, cur_line, XML_INPUT_SIZE);\n#endif\n\t\t\tcur_line[read] = cur_line[read+1] = 0;\n\n\t\t\tCPYCAT_ALLOC(cur_line, 0);\n\t\t}\n\n\t\tif (end_pattern) {\n\t\t\tstart  = strstr(szLine, end_pattern);\n\t\t\tif (start) {\n\t\t\t\tstart[0] = 0;\n\t\t\t\tdobreak = GF_TRUE;\n\t\t\t}\n\t\t}\n\nretry:\n\t\tif (state == 2) goto fetch_attr;\n\t\tsep = strstr(szLine, att_name);\n\t\tif (!sep && !state) {\n\t\t\tstate = 0;\n\t\t\tstart = strrchr(szLine, '<');\n\t\t\tif (start) {\n\t\t\t\tCPYCAT_ALLOC(start, 1);\n\t\t\t} else {\n\t\t\t\tCPYCAT_ALLOC(cur_line, 1);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!state) {\n\t\t\tstate = 1;\n\t\t\t/*load next line*/\n\t\t\tfirst_c = sep[0];\n\t\t\tsep[0] = 0;\n\t\t\tstart = strrchr(szLine, '<');\n\t\t\tif (!start)\n\t\t\t\tgoto exit;\n\t\t\tsep[0] = first_c;\n\t\t\tCPYCAT_ALLOC(start, 1);\n\t\t\tsep = strstr(szLine, att_name);\n\t\t}\n\t\tsep = sep ? strchr(sep, '=') : NULL;\n\t\tif (!sep) {\n\t\t\tstate = 0;\n\t\t\tCPYCAT_ALLOC(cur_line, 1);\n\t\t\tcontinue;\n\t\t}\n\t\twhile (sep[0] && (sep[0] != '\\\"') && (sep[0] != '\\'') ) sep++;\n\t\tif (!sep[0]) continue;\n\t\tsep_char = sep[0];\n\t\tsep++;\n\t\twhile (sep[0] && strchr(\" \\n\\r\\t\", sep[0]) ) sep++;\n\t\tif (!sep[0]) continue;\n\t\tif (!strchr(sep, sep_char))\n\t\t\tcontinue;\n\n\t\t/*found*/\n\t\tif (!strncmp(sep, att_value, att_len)) {\n\t\t\tu32 sub_pos;\n\t\t\tsep = szLine + 1;\n\t\t\twhile (strchr(\" \\t\\r\\n\", sep[0])) sep++;\n\t\t\tsub_pos = 0;\n\t\t\twhile (!strchr(\" \\t\\r\\n\", sep[sub_pos])) sub_pos++;\n\t\t\tfirst_c = sep[sub_pos];\n\t\t\tsep[sub_pos] = 0;\n\t\t\tstate = 2;\n\t\t\tif (!substitute || !get_attr || strcmp(sep, substitute) ) {\n\t\t\t\tif (is_substitute) *is_substitute = GF_FALSE;\n\t\t\t\tresult = gf_strdup(sep);\n\t\t\t\tsep[sub_pos] = first_c;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tsep[sub_pos] = first_c;\nfetch_attr:\n\t\t\tsep = strstr(szLine + 1, get_attr);\n\t\t\tif (!sep) {\n\t\t\t\tCPYCAT_ALLOC(cur_line, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsep += strlen(get_attr);\n\t\t\twhile (strchr(\"= \\t\\r\\n\", sep[0])) sep++;\n\t\t\tsep++;\n\t\t\tsub_pos = 0;\n\t\t\twhile (!strchr(\" \\t\\r\\n/>\", sep[sub_pos])) sub_pos++;\n\t\t\tsep[sub_pos-1] = 0;\n\t\t\tresult = gf_strdup(sep);\n\t\t\tif (is_substitute) *is_substitute = GF_TRUE;\n\t\t\tgoto exit;\n\t\t}\n\t\tstate = 0;\n\t\tCPYCAT_ALLOC(sep, 1);\n\t\tgoto retry;\n\t}\nexit:\n\tgf_free(szLine);\n\n\tif (!from_buffer) {\n#ifdef NO_GZIP\n\t\tgf_fseek(parser->f_in, pos, SEEK_SET);\n#else\n\t\tgf_gzrewind(parser->gz_in);\n\t\tgf_gzseek(parser->gz_in, pos, SEEK_SET);\n#endif\n\t}\n\treturn result;\n}\n\nGF_EXPORT\nconst char *gf_xml_sax_get_error(GF_SAXParser *parser)\n{\n\treturn parser->err_msg;\n}\n\n\nstruct _peek_type\n{\n\tGF_SAXParser *parser;\n\tchar *res;\n};\n\nstatic void on_peek_node_start(void *cbk, const char *name, const char *ns, const GF_XMLAttribute *attributes, u32 nb_attributes)\n{\n\tstruct _peek_type *pt = (struct _peek_type*)cbk;\n\tpt->res = gf_strdup(name);\n\tpt->parser->suspended = GF_TRUE;\n}\n\nGF_EXPORT\nchar *gf_xml_get_root_type(const char *file, GF_Err *ret)\n{\n\tGF_Err e;\n\tstruct _peek_type pt;\n\tpt.res = NULL;\n\tpt.parser = gf_xml_sax_new(on_peek_node_start, NULL, NULL, &pt);\n\te = gf_xml_sax_parse_file(pt.parser, file, NULL);\n\tif (ret) *ret = e;\n\tgf_xml_sax_del(pt.parser);\n\treturn pt.res;\n}\n\n\nGF_EXPORT\nu32 gf_xml_sax_get_node_start_pos(GF_SAXParser *parser)\n{\n\treturn parser->elt_start_pos;\n}\n\nGF_EXPORT\nu32 gf_xml_sax_get_node_end_pos(GF_SAXParser *parser)\n{\n\treturn parser->elt_end_pos;\n}\n\nstruct _tag_dom_parser\n{\n\tGF_SAXParser *parser;\n\tGF_List *stack;\n\t//root node being parsed\n\tGF_XMLNode *root;\n\t//usually only one :)\n\tGF_List *root_nodes;\n\tu32 depth;\n\n\tvoid (*OnProgress)(void *cbck, u64 done, u64 tot);\n\tvoid *cbk;\n};\n\n\nGF_EXPORT\nvoid gf_xml_dom_node_reset(GF_XMLNode *node, Bool reset_attribs, Bool reset_children)\n{\n\tif (!node) return;\n\tif (node->attributes && reset_attribs) {\n\t\twhile (gf_list_count(node->attributes)) {\n\t\t\tGF_XMLAttribute *att = (GF_XMLAttribute *)gf_list_last(node->attributes);\n\t\t\tgf_list_rem_last(node->attributes);\n\t\t\tif (att->name) gf_free(att->name);\n\t\t\tif (att->value) gf_free(att->value);\n\t\t\tgf_free(att);\n\t\t}\n\t}\n\n\tif (reset_children && node->content) {\n\t\twhile (gf_list_count(node->content)) {\n\t\t\tGF_XMLNode *child = (GF_XMLNode *)gf_list_last(node->content);\n\t\t\tgf_list_rem_last(node->content);\n\t\t\tgf_xml_dom_node_del(child);\n\t\t}\n\t}\n}\n\nGF_EXPORT\nvoid gf_xml_dom_node_del(GF_XMLNode *node)\n{\n\tif (!node) return;\n\tgf_xml_dom_node_reset(node, GF_TRUE, GF_TRUE);\n\tif (node->attributes) gf_list_del(node->attributes);\n\tif (node->content) gf_list_del(node->content);\n\tif (node->ns) gf_free(node->ns);\n\tif (node->name) gf_free(node->name);\n\tgf_free(node);\n}\n\nGF_List * gf_list_new_prealloc(u32 nb_prealloc);\n\nstatic void on_dom_node_start(void *cbk, const char *name, const char *ns, const GF_XMLAttribute *attributes, u32 nb_attributes)\n{\n\tu32 i;\n\tGF_DOMParser *par = (GF_DOMParser *) cbk;\n\tGF_XMLNode *node;\n\n\tif (par->root && !gf_list_count(par->stack)) {\n\t\tpar->parser->suspended = GF_TRUE;\n\t\treturn;\n\t}\n\n\tGF_SAFEALLOC(node, GF_XMLNode);\n\tif (!node) {\n\t\tpar->parser->sax_state = SAX_STATE_ALLOC_ERROR;\n\t\treturn;\n\t}\n\tnode->attributes = gf_list_new_prealloc(nb_attributes);\n\t//don't allocate content yet\n\tnode->name = gf_strdup(name);\n\tif (ns) node->ns = gf_strdup(ns);\n\tgf_list_add(par->stack, node);\n\tif (!par->root) {\n\t\tpar->root = node;\n\t\tgf_list_add(par->root_nodes, node);\n\t}\n\n\tfor (i=0; i<nb_attributes; i++) {\n\t\tGF_XMLAttribute *att;\n\t\tconst GF_XMLAttribute *in_att = & attributes[i];\n\t\tGF_SAFEALLOC(att, GF_XMLAttribute);\n\t\tif (! att) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[SAX] Failed to allocate attribute\"));\n\t\t\tpar->parser->sax_state = SAX_STATE_ALLOC_ERROR;\n\t\t\treturn;\n\t\t}\n\t\tatt->name = gf_strdup(in_att->name);\n\t\tatt->value = gf_strdup(in_att->value);\n\t\tgf_list_add(node->attributes, att);\n\t}\n}\n\nstatic void on_dom_node_end(void *cbk, const char *name, const char *ns)\n{\n\tGF_DOMParser *par = (GF_DOMParser *)cbk;\n\tGF_XMLNode *last = (GF_XMLNode *)gf_list_last(par->stack);\n\tgf_list_rem_last(par->stack);\n\n\tif (!last || (strlen(last->name)!=strlen(name)) || strcmp(last->name, name) || (!ns && last->ns) || (ns && !last->ns) || (ns && strcmp(last->ns, ns) ) ) {\n\t\ts32 idx;\n\t\tformat_sax_error(par->parser, 0, \"Invalid node stack: closing node is %s but %s was expected\", name, last ? last->name : \"unknown\");\n\t\tpar->parser->suspended = GF_TRUE;\n\t\tgf_xml_dom_node_del(last);\n\t\tif (last == par->root)\n\t\t\tpar->root=NULL;\n\t\tidx = gf_list_find(par->root_nodes, last);\n\t\tif (idx != -1)\n\t\t\tgf_list_rem(par->root_nodes, idx);\n\t\treturn;\n\t}\n\tif (last != par->root) {\n\t\tGF_XMLNode *node = (GF_XMLNode *)gf_list_last(par->stack);\n\t\tif (!node->content)\n\t\t\tnode->content = gf_list_new();\n\n\t\tgf_list_add(node->content, last);\n\t}\n}\n\nstatic void on_dom_text_content(void *cbk, const char *content, Bool is_cdata)\n{\n\tGF_DOMParser *par = (GF_DOMParser *)cbk;\n\tGF_XMLNode *node;\n\tGF_XMLNode *last = (GF_XMLNode *)gf_list_last(par->stack);\n\tif (!last) return;\n\tif (!last->content)\n\t\tlast->content = gf_list_new();\n\n\tGF_SAFEALLOC(node, GF_XMLNode);\n\tif (!node) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[SAX] Failed to allocate XML node\"));\n\t\tpar->parser->sax_state = SAX_STATE_ALLOC_ERROR;\n\t\treturn;\n\t}\n\tnode->type = is_cdata ? GF_XML_CDATA_TYPE : GF_XML_TEXT_TYPE;\n\tnode->name = gf_strdup(content);\n\tgf_list_add(last->content, node);\n}\n\nGF_EXPORT\nGF_DOMParser *gf_xml_dom_new()\n{\n\tGF_DOMParser *dom;\n\tGF_SAFEALLOC(dom, GF_DOMParser);\n\tif (!dom) return NULL;\n\n\tdom->root_nodes = gf_list_new();\n\treturn dom;\n}\n\nstatic void gf_xml_dom_reset(GF_DOMParser *dom, Bool full_reset)\n{\n\tif (full_reset && dom->parser) {\n\t\tgf_xml_sax_del(dom->parser);\n\t\tdom->parser = NULL;\n\t}\n\n\tif (dom->stack) {\n\t\twhile (gf_list_count(dom->stack)) {\n\t\t\tGF_XMLNode *n = (GF_XMLNode *)gf_list_last(dom->stack);\n\t\t\tgf_list_rem_last(dom->stack);\n\t\t\tif (dom->root==n) {\n\t\t\t\tgf_list_del_item(dom->root_nodes, n);\n\t\t\t\tdom->root = NULL;\n\t\t\t}\n\t\t\tgf_xml_dom_node_del(n);\n\t\t}\n\t\tgf_list_del(dom->stack);\n\t\tdom->stack = NULL;\n\t}\n\tif (full_reset && gf_list_count(dom->root_nodes) ) {\n\t\twhile (gf_list_count(dom->root_nodes)) {\n\t\t\tGF_XMLNode *n = (GF_XMLNode *)gf_list_last(dom->root_nodes);\n\t\t\tgf_list_rem_last(dom->root_nodes);\n\t\t\tgf_xml_dom_node_del(n);\n\t\t}\n\t\tdom->root = NULL;\n\t}\n}\n\nGF_EXPORT\nvoid gf_xml_dom_del(GF_DOMParser *parser)\n{\n\tif (!parser)\n\t\treturn;\n\n\tgf_xml_dom_reset(parser, GF_TRUE);\n\tgf_list_del(parser->root_nodes);\n\tgf_free(parser);\n}\n\nGF_EXPORT\nGF_XMLNode *gf_xml_dom_detach_root(GF_DOMParser *parser)\n{\n\tGF_XMLNode *root;\n\tif (!parser)\n\t\treturn NULL;\n\troot = parser->root;\n\tgf_list_del_item(parser->root_nodes, root);\n\tparser->root = gf_list_get(parser->root_nodes, 0);\n\treturn root;\n}\n\nstatic void dom_on_progress(void *cbck, u64 done, u64 tot)\n{\n\tGF_DOMParser *dom = (GF_DOMParser *)cbck;\n\tdom->OnProgress(dom->cbk, done, tot);\n}\n\nGF_EXPORT\nGF_Err gf_xml_dom_parse(GF_DOMParser *dom, const char *file, gf_xml_sax_progress OnProgress, void *cbk)\n{\n\tGF_Err e;\n\tgf_xml_dom_reset(dom, GF_TRUE);\n\tdom->stack = gf_list_new();\n\tdom->parser = gf_xml_sax_new(on_dom_node_start, on_dom_node_end, on_dom_text_content, dom);\n\tdom->OnProgress = OnProgress;\n\tdom->cbk = cbk;\n\te = gf_xml_sax_parse_file(dom->parser, file, OnProgress ? dom_on_progress : NULL);\n\tgf_xml_dom_reset(dom, GF_FALSE);\n\treturn e<0 ? e : GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_xml_dom_parse_string(GF_DOMParser *dom, char *string)\n{\n\tGF_Err e;\n\tgf_xml_dom_reset(dom, GF_TRUE);\n\tdom->stack = gf_list_new();\n\tdom->parser = gf_xml_sax_new(on_dom_node_start, on_dom_node_end, on_dom_text_content, dom);\n\te = gf_xml_sax_init(dom->parser, (unsigned char *) string);\n\tgf_xml_dom_reset(dom, GF_FALSE);\n\treturn e<0 ? e : GF_OK;\n}\n\n#if 0 //unused\nGF_XMLNode *gf_xml_dom_create_root(GF_DOMParser *parser, const char* name) {\n\tGF_XMLNode * root;\n\tif (!parser) return NULL;\n\n\tGF_SAFEALLOC(root, GF_XMLNode);\n\tif (!root) return NULL;\n\troot->name = gf_strdup(name);\n\n\treturn root;\n}\n#endif\n\nGF_EXPORT\nGF_XMLNode *gf_xml_dom_get_root(GF_DOMParser *parser)\n{\n\treturn parser ? parser->root : NULL;\n}\nGF_EXPORT\nconst char *gf_xml_dom_get_error(GF_DOMParser *parser)\n{\n\treturn gf_xml_sax_get_error(parser->parser);\n}\nGF_EXPORT\nu32 gf_xml_dom_get_line(GF_DOMParser *parser)\n{\n\treturn gf_xml_sax_get_line(parser->parser);\n}\n\nGF_EXPORT\nu32 gf_xml_dom_get_root_nodes_count(GF_DOMParser *parser)\n{\n\treturn parser? gf_list_count(parser->root_nodes) : 0;\n}\n\nGF_EXPORT\nGF_XMLNode *gf_xml_dom_get_root_idx(GF_DOMParser *parser, u32 idx)\n{\n\treturn parser ? (GF_XMLNode*)gf_list_get(parser->root_nodes, idx) : NULL;\n}\n\n\nstatic void gf_xml_dom_node_serialize(GF_XMLNode *node, Bool content_only, Bool no_escape, char **str, u32 *alloc_size, u32 *size)\n{\n\tu32 i, count, vlen;\n\tchar *name;\n\n#define SET_STRING(v)\t\\\n\tvlen = (u32) strlen(v);\t\\\n\tif (vlen + (*size) >= (*alloc_size)) {\t\\\n\t\t(*alloc_size) += 1024;\t\\\n\t\tif (vlen + (*size) >= (*alloc_size)) (*alloc_size) = vlen + (*size) + 1;\\\n\t\t(*str) = gf_realloc((*str), (*alloc_size));\t\\\n\t\t(*str)[(*size)] = 0;\t\\\n\t}\t\\\n\tstrcat((*str), v);\t\\\n\t*size += vlen;\t\\\n\n\tswitch (node->type) {\n\tcase GF_XML_CDATA_TYPE:\n\t\tSET_STRING(\"![CDATA[\");\n\t\tSET_STRING(node->name);\n\t\tSET_STRING(\"]]>\");\n\t\treturn;\n\tcase GF_XML_TEXT_TYPE:\n\t\tname = node->name;\n\t\tif ((name[0]=='\\r') && (name[1]=='\\n'))\n\t\t\tname++;\n\n\t\tif (no_escape) {\n\t\t\tSET_STRING(name);\n\t\t} else {\n\t\t\tu32 tlen;\n\t\t\tchar szChar[2];\n\t\t\tszChar[1] = 0;\n\t\t\ttlen = (u32) strlen(name);\n\t\t\tfor (i= 0; i<tlen; i++) {\n\t\t\t\tswitch (name[i]) {\n\t\t\t\tcase '&':\n\t\t\t\t\tSET_STRING(\"&amp;\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\tSET_STRING(\"&lt;\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tSET_STRING(\"&gt;\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\'':\n\t\t\t\t\tSET_STRING(\"&apos;\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\"':\n\t\t\t\t\tSET_STRING(\"&quot;\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tszChar[0] = name[i];\n\t\t\t\t\tSET_STRING(szChar);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!content_only) {\n\t\tSET_STRING(\"<\");\n\t\tif (node->ns) {\n\t\t\tSET_STRING(node->ns);\n\t\t\tSET_STRING(\":\");\n\t\t}\n\t\tSET_STRING(node->name);\n\t\tcount = gf_list_count(node->attributes);\n\t\tif (count > 0) {\n\t\t\tSET_STRING(\" \");\n\t\t}\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_XMLAttribute *att = (GF_XMLAttribute*)gf_list_get(node->attributes, i);\n\t\t\tSET_STRING(att->name);\n\t\t\tSET_STRING(\"=\\\"\");\n\t\t\tSET_STRING(att->value);\n\t\t\tSET_STRING(\"\\\" \");\n\t\t}\n\n\t\tif (!gf_list_count(node->content)) {\n\t\t\tSET_STRING(\"/>\");\n\t\t\treturn;\n\t\t}\n\t\tSET_STRING(\">\");\n\t}\n\n\tcount = gf_list_count(node->content);\n\tfor (i=0; i<count; i++) {\n\t\tGF_XMLNode *child = (GF_XMLNode*)gf_list_get(node->content, i);\n\t\tgf_xml_dom_node_serialize(child, GF_FALSE, GF_FALSE, str, alloc_size, size);\n\t}\n\tif (!content_only) {\n\t\tSET_STRING(\"</\");\n\t\tif (node->ns) {\n\t\t\tSET_STRING(node->ns);\n\t\t\tSET_STRING(\":\");\n\t\t}\n\t\tSET_STRING(node->name);\n\t\tSET_STRING(\">\");\n\t}\n}\n\nGF_EXPORT\nchar *gf_xml_dom_serialize(GF_XMLNode *node, Bool content_only, Bool no_escape)\n{\n\tu32 alloc_size = 0;\n\tu32 size = 0;\n\tchar *str = NULL;\n\tgf_xml_dom_node_serialize(node, content_only, no_escape, &str, &alloc_size, &size);\n\treturn str;\n}\n\nGF_EXPORT\nchar *gf_xml_dom_serialize_root(GF_XMLNode *node, Bool content_only, Bool no_escape)\n{\n\tu32 alloc_size, size;\n\tchar *str = NULL;\n\tgf_dynstrcat(&str, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\", NULL);\n\tif (!str) return NULL;\n\n\talloc_size = size = (u32) strlen(str) + 1;\n\tgf_xml_dom_node_serialize(node, content_only, no_escape, &str, &alloc_size, &size);\n\treturn str;\n}\n\n#if 0 //unused\nGF_XMLAttribute *gf_xml_dom_set_attribute(GF_XMLNode *node, const char* name, const char* value) {\n\tGF_XMLAttribute *att;\n\tif (!name || !value) return NULL;\n\tif (!node->attributes) {\n\t\tnode->attributes = gf_list_new();\n\t\tif (!node->attributes) return NULL;\n\t}\n\n\tatt = gf_xml_dom_create_attribute(name, value);\n\tif (!att) return NULL;\n\tgf_list_add(node->attributes, att);\n\treturn att;\n}\n\nGF_XMLAttribute *gf_xml_dom_get_attribute(GF_XMLNode *node, const char* name) {\n\tu32 i = 0;\n\tGF_XMLAttribute *att;\n\tif (!node || !name) return NULL;\n\n\twhile ( (att = (GF_XMLAttribute*)gf_list_enum(node->attributes, &i))) {\n\t\tif (!strcmp(att->name, name)) {\n\t\t\treturn att;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n#endif\n\nGF_EXPORT\nGF_XMLAttribute *gf_xml_dom_create_attribute(const char* name, const char* value) {\n\tGF_XMLAttribute *att;\n\tGF_SAFEALLOC(att, GF_XMLAttribute);\n\tif (!att) return NULL;\n\n\tatt->name = gf_strdup(name);\n\tatt->value = gf_strdup(value);\n\treturn att;\n}\n\n\nGF_EXPORT\nGF_Err gf_xml_dom_append_child(GF_XMLNode *node, GF_XMLNode *child) {\n\tif (!node || !child) return GF_BAD_PARAM;\n\tif (!node->content) {\n\t\tnode->content = gf_list_new();\n\t\tif (!node->content) return GF_OUT_OF_MEM;\n\t}\n\treturn gf_list_add(node->content, child);\n}\n\n#if 0\n/*!\n\\brief Removes the node to the list of children of this node.\n\nRemoves the node to the list of children of this node.\n\\warning Doesn't free the memory of the removed children.\n\n\\param node the GF_XMLNode node\n\\param child the GF_XMLNode child to remove\n\\return Error code if any, otherwise GF_OK\n */\nGF_EXPORT\nGF_Err gf_xml_dom_rem_child(GF_XMLNode *node, GF_XMLNode *child) {\n\ts32 idx;\n\tif (!node || !child || !node->content) return GF_BAD_PARAM;\n\tidx = gf_list_find(node->content, child);\n\tif (idx == -1) return GF_BAD_PARAM;\n\treturn gf_list_rem(node->content, idx);\n}\n#endif //unused\n\n\nGF_XMLNode *gf_xml_dom_node_new(const char* ns, const char* name)\n{\n\tGF_XMLNode* node;\n\tGF_SAFEALLOC(node, GF_XMLNode);\n\tif (!node) return NULL;\n\tif (ns) {\n\t\tnode->ns = gf_strdup(ns);\n\t\tif (!node->ns) {\n\t\t\tgf_free(node);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (name) {\n\t\tnode->name = gf_strdup(name);\n\t\tif (!node->name) {\n\t\t\tgf_free(node->ns);\n\t\t\tgf_free(node);\n\t\t\treturn NULL;\n\t\t}\n\t\tnode->type = GF_XML_NODE_TYPE;\n\t} else {\n\t\tnode->type = GF_XML_TEXT_TYPE;\n\t}\n\treturn node;\n}\n\n#include <gpac/base_coding.h>\n\n#define XML_SCAN_INT(_fmt, _value)\t\\\n\t{\\\n\tif (strstr(att->value, \"0x\")) { u32 __i; sscanf(att->value+2, \"%x\", &__i); _value = __i; }\\\n\telse if (strstr(att->value, \"0X\")) { u32 __i; sscanf(att->value+2, \"%X\", &__i); _value = __i; }\\\n\telse sscanf(att->value, _fmt, &_value); \\\n\t}\\\n\n\nGF_Err gf_xml_parse_bit_sequence_bs(GF_XMLNode *bsroot, const char *parent_url, const char *base_media_file, GF_BitStream *bs_orig)\n{\n\tu32 i, j;\n\tGF_Err e = GF_OK;\n\tGF_XMLNode *node;\n\tGF_XMLAttribute *att;\n\tGF_BitStream *bs = bs_orig;\n\tu32 enc_base64 = 0;\n\n\ti=0;\n\twhile ((node = (GF_XMLNode *) gf_list_enum(bsroot->content, &i))) {\n\t\tu32 nb_bits = 0;\n\t\tu32 size = 0;\n\t\tu64 offset = 0;\n\t\ts64 value = 0;\n\t\tBool use_file = GF_FALSE;\n\t\tbin128 word128;\n\t\tFloat val_float = 0;\n\t\tDouble val_double = 0;\n\t\tBool use_word128 = GF_FALSE;\n\t\tBool use_text = GF_FALSE;\n\t\tBool base64_prefix_bits = 0;\n\t\tBool big_endian = GF_TRUE;\n\t\tBool has_float = GF_FALSE;\n\t\tBool has_double = GF_FALSE;\n\t\tconst char *szFile = NULL;\n\t\tconst char *szString = NULL;\n\t\tconst char *szBase64 = NULL;\n\t\tconst char *szData = NULL;\n\t\tif (node->type) continue;\n\n\t\tif (stricmp(node->name, \"BS\") ) {\n\t\t\te = gf_xml_parse_bit_sequence_bs(node, parent_url, base_media_file, bs);\n\t\t\tif (e) goto exit;\n\t\t\tcontinue;\n\t\t}\n\n\t\tj=0;\n\t\twhile ( (att = (GF_XMLAttribute *)gf_list_enum(node->attributes, &j))) {\n\t\t\tif (!stricmp(att->name, \"bits\")) {\n\t\t\t\tXML_SCAN_INT(\"%d\", nb_bits);\n\t\t\t} else if (!stricmp(att->name, \"value\")) {\n\t\t\t\tXML_SCAN_INT(LLD, value);\n\t\t\t} else if (!stricmp(att->name, \"float\")) {\n\t\t\t\tsscanf(att->value, \"%f\", &val_float);\n\t\t\t\thas_float = GF_TRUE;\n\t\t\t} else if (!stricmp(att->name, \"double\")) {\n\t\t\t\tsscanf(att->value, \"%lf\", &val_double);\n\t\t\t\thas_double = GF_TRUE;\n\t\t\t} else if (!stricmp(att->name, \"mediaOffset\") || !stricmp(att->name, \"dataOffset\")) {\n\t\t\t\tXML_SCAN_INT(LLU, offset);\n\t\t\t\tuse_file = GF_TRUE;\n\t\t\t} else if (!stricmp(att->name, \"dataLength\")) {\n\t\t\t\tXML_SCAN_INT(\"%u\", size);\n\t\t\t\tuse_file = GF_TRUE;\n\t\t\t} else if (!stricmp(att->name, \"mediaFile\") || !stricmp(att->name, \"dataFile\")) {\n\t\t\t\tszFile = att->value;\n\t\t\t\tuse_file = GF_TRUE;\n\t\t\t} else if (!stricmp(att->name, \"text\") || !stricmp(att->name, \"string\")) {\n\t\t\t\tszString = att->value;\n\t\t\t} else if (!stricmp(att->name, \"fcc\")) {\n\t\t\t\tvalue = GF_4CC(att->value[0], att->value[1], att->value[2], att->value[3]);\n\t\t\t\tnb_bits = 32;\n\t\t\t} else if (!stricmp(att->name, \"ID128\")) {\n\t\t\t\te = gf_bin128_parse(att->value, word128);\n                if (e != GF_OK) {\n                    GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[XML/NHML] Cannot parse ID128\\n\"));\n                    goto exit;\n                }\n\t\t\t\tuse_word128 = GF_TRUE;\n\t\t\t} else if (!stricmp(att->name, \"textmode\")) {\n\t\t\t\tif (!strcmp(att->value, \"yes\")) use_text = GF_TRUE;\n\t\t\t} else if (!stricmp(att->name, \"data64\")) {\n\t\t\t\tszBase64 = att->value;\n\t\t\t} else if (!stricmp(att->name, \"data\")) {\n\t\t\t\tszData = att->value;\n\t\t\t\tif (!strnicmp(szData, \"0x\", 2)) szData += 2;\n\t\t\t} else if (!stricmp(att->name, \"endian\") && !stricmp(att->value, \"little\")) {\n\t\t\t\tbig_endian = GF_FALSE;\n\t\t\t} else if (!stricmp(att->name, \"base64\")) {\n\t\t\t\tif (!stricmp(att->value, \"yes\") || !stricmp(att->value, \"true\") ) {\n\t\t\t\t\tif (!enc_base64) enc_base64 = 1;\n\t\t\t\t} else if (!stricmp(att->value, \"start\")) {\n\t\t\t\t\tif (!enc_base64) enc_base64 = 2;\n\t\t\t\t} else if (!stricmp(att->value, \"end\")) {\n\t\t\t\t\tif (enc_base64==2) enc_base64 = 3;\n\t\t\t\t} else {\n                    GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[XML/NHML] Invalid base64 attribute %s, expecting yes/no, start or end\\n\", att->value));\n                    e = GF_NON_COMPLIANT_BITSTREAM;\n                    goto exit;\n\t\t\t\t}\n\t\t\t} else if (!stricmp(att->name, \"base64Prefix\")) {\n\t\t\t\tbase64_prefix_bits = atoi(att->value);\n\t\t\t} else if (!stricmp(att->name, \"id\")) {\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[XML/NHML] Unkown attribute %s, ignoring\\n\", att->name));\n\t\t\t}\n\t\t}\n\n\t\tif (enc_base64 && (enc_base64<3)) {\n\t\t\tif (bs == bs_orig) {\n\t\t\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t\tif (!bs) {\n\t\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (use_file && !szFile)\n\t\t\tszFile = base_media_file;\n\n\t\tif (szString) {\n\t\t\tu32 len = (u32) strlen(szString);\n\t\t\tif (nb_bits)\n\t\t\t\tgf_bs_write_int(bs, len, nb_bits);\n\n\t\t\tgf_bs_write_data(bs, szString, len);\n\t\t} else if (szBase64) {\n\t\t\tu32 len = (u32) strlen(szBase64);\n\t\t\tchar *data = (char *) gf_malloc(sizeof(char)*len);\n\t\t\tu32 ret;\n\t\t\tif (!data) {\n\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tret = (u32) gf_base64_decode((char *)szBase64, len, data, len);\n\t\t\tif ((s32) ret >=0) {\n\t\t\t\tgf_bs_write_int(bs, ret, nb_bits);\n\t\t\t\tgf_bs_write_data(bs, data, ret);\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[XML/NHML] Error decoding base64 %s\\n\", att->value));\n\t\t\t\tgf_free(data);\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tgf_free(data);\n\t\t} else if (szData) {\n\t\t\tu32 len = (u32) strlen(szData);\n\t\t\tchar *data = (char *) gf_malloc(sizeof(char)*len/2);\n\t\t\tif (!data) {\n\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tfor (j=0; j<len; j+=2) {\n\t\t\t\tu32 v;\n\t\t\t\tchar szV[5];\n\t\t\t\tsprintf(szV, \"%c%c\", szData[j], szData[j+1]);\n\t\t\t\tsscanf(szV, \"%x\", &v);\n\t\t\t\tdata[j/2] = v;\n\t\t\t}\n\t\t\tgf_bs_write_int(bs, len/2, nb_bits);\n\t\t\tgf_bs_write_data(bs, data, len/2);\n\t\t\tgf_free(data);\n\t\t} else if (has_float) {\n\t\t\tgf_bs_write_float(bs, val_float);\n\t\t} else if (has_double) {\n\t\t\tgf_bs_write_double(bs, val_double);\n\t\t} else if (nb_bits) {\n\t\t\tif (!big_endian) {\n\t\t\t\tif (nb_bits == 16)\n\t\t\t\t\tgf_bs_write_u16_le(bs, (u32)value);\n\t\t\t\telse if (nb_bits == 32)\n\t\t\t\t\tgf_bs_write_u32_le(bs, (u32)value);\n\t\t\t\telse {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[XML/NHML] Little-endian values can only be 16 or 32-bit\\n\"));\n\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (nb_bits<33) gf_bs_write_int(bs, (s32) value, nb_bits);\n\t\t\t\telse gf_bs_write_long_int(bs, value, nb_bits);\n\t\t\t}\n\t\t} else if (szFile) {\n\t\t\tu32 read, remain;\n\t\t\tchar block[1024];\n\t\t\tFILE *_tmp = NULL;\n\t\t\tif (parent_url) {\n\t\t\t\tchar *f_url = gf_url_concatenate(parent_url, szFile);\n\t\t\t\t_tmp = gf_fopen(f_url, use_text ? \"rt\" : \"rb\");\n\t\t\t\tgf_free(f_url);\n\t\t\t} else {\n\t\t\t\t_tmp = gf_fopen(szFile, use_text ? \"rt\" : \"rb\");\n\t\t\t}\n\n\t\t\tif (!_tmp) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[XML/NHML] Error opening file %s\\n\", szFile));\n\t\t\t\te = GF_URL_ERROR;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tif (!size) {\n\t\t\t\tsize = (u32) gf_fsize(_tmp);\n\t\t\t\t//if offset only copy from offset until end\n\t\t\t\tif ((u64) size > offset)\n\t\t\t\t\tsize -= (u32) offset;\n\t\t\t}\n\t\t\tremain = size;\n\t\t\tgf_fseek(_tmp, offset, SEEK_SET);\n\t\t\twhile (remain) {\n\t\t\t\tu32 bsize = remain;\n\t\t\t\tif (bsize>1024) bsize=1024;\n\t\t\t\tread = (u32) gf_fread(block, bsize, _tmp);\n\t\t\t\tif ((s32) read < 0) {\n\t\t\t\t\tgf_fclose(_tmp);\n\t\t\t\t\te = GF_IO_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\n\t\t\t\tgf_bs_write_data(bs, block, read);\n\t\t\t\tremain -= bsize;\n\t\t\t}\n\t\t\tgf_fclose(_tmp);\n\t\t} else if (use_word128) {\n\t\t\tgf_bs_write_data(bs, (char *)word128, 16);\n\t\t}\n\n\t\tif ((enc_base64==1) || (enc_base64==3)) {\n\t\t\tu8 *bs_data;\n\t\t\tu32 bs_data_size;\n\t\t\tassert (bs != bs_orig);\n\t\t\tgf_bs_get_content(bs, &bs_data, &bs_data_size);\n\t\t\tgf_bs_del(bs);\n\t\t\tenc_base64 = 0;\n\t\t\tbs = bs_orig;\n\t\t\tif (bs_data) {\n\t\t\t\tu8 *bs_data_out;\n\t\t\t\tu32 res = 2*bs_data_size + 3;\n\t\t\t\tbs_data_out = gf_malloc(sizeof(char) * res);\n\t\t\t\tif (!bs_data_out) {\n\t\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tres = gf_base64_encode(bs_data, bs_data_size, bs_data_out, res);\n\t\t\t\tbs_data_out[res] = 0;\n\t\t\t\tif (base64_prefix_bits) {\n\t\t\t\t\tif (base64_prefix_bits % 8) {\n\t\t\t\t\t\tgf_bs_write_int(bs, res, base64_prefix_bits);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu32 nb_bytes = base64_prefix_bits/8;\n\t\t\t\t\t\tif (!big_endian && (nb_bytes==8)) gf_bs_write_u64_le(bs, res);\n\t\t\t\t\t\telse if (!big_endian && (nb_bytes==4)) gf_bs_write_u32_le(bs, res);\n\t\t\t\t\t\telse if (!big_endian && (nb_bytes==2)) gf_bs_write_u16_le(bs, res);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tgf_bs_write_int(bs, res, base64_prefix_bits);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_bs_write_data(bs, bs_data_out, res);\n\t\t\t\tgf_free(bs_data);\n\t\t\t\tgf_free(bs_data_out);\n\t\t\t}\n\t\t}\n\t}\n\nexit:\n\tif (bs != bs_orig) {\n\t\tif (!e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[XML/NHML] base64 encoding context not closed\\n\"));\n\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tgf_bs_del(bs);\n\t}\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_xml_parse_bit_sequence(GF_XMLNode *bsroot, const char *parent_url, u8 **data, u32 *data_size)\n{\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (!bs) return GF_OUT_OF_MEM;\n\n\tgf_xml_parse_bit_sequence_bs(bsroot, parent_url, NULL, bs);\n\n\tgf_bs_align(bs);\n\tgf_bs_get_content(bs, data, data_size);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\nGF_Err gf_xml_get_element_check_namespace(const GF_XMLNode *n, const char *expected_node_name, const char *expected_ns_prefix) {\n\tu32 i;\n\tGF_XMLAttribute *att;\n\n\t/*check we are processing the expected node*/\n\tif (expected_node_name && strcmp(expected_node_name, n->name)) {\n\t\treturn GF_SG_UNKNOWN_NODE;\n\t}\n\n\t/*check for previously declared prefix (to be manually provided)*/\n\tif (!n->ns) {\n\t\treturn GF_OK;\n\t}\n\tif (expected_ns_prefix && !strcmp(expected_ns_prefix, n->ns)) {\n\t\treturn GF_OK;\n\t}\n\n\t/*look for new namespace in attributes*/\n\ti = 0;\n\twhile ( (att = (GF_XMLAttribute*)gf_list_enum(n->attributes, &i)) ) {\n\t\tconst char *ns;\n\t\tns = strstr(att->name, \":\");\n\t\tif (!ns) continue;\n\t\t\n\t\tif (!strncmp(att->name, \"xmlns\", 5)) {\n\t\t\tif (!strcmp(ns+1, n->ns)) {\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CORE, (\"[XML] Unsupported attribute namespace \\\"%s\\\": ignoring\\n\", att->name));\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"[XML] Unresolved namespace \\\"%s\\\" for node \\\"%s\\\"\\n\", n->ns, n->name));\n\treturn GF_BAD_PARAM;\n}\n\nvoid gf_xml_dump_string(FILE* file, const char *before, const char *str, const char *after)\n{\n\tsize_t i;\n\tsize_t len=str?strlen(str):0;\n\n\tif (before) {\n\t\tgf_fprintf(file, \"%s\", before);\n\t}\n\n\tfor (i = 0; i < len; i++) {\n\t\tswitch (str[i]) {\n\t\tcase '&':\n\t\t\tgf_fprintf(file, \"%s\", \"&amp;\");\n\t\t\tbreak;\n\t\tcase '<':\n\t\t\tgf_fprintf(file, \"%s\", \"&lt;\");\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\tgf_fprintf(file, \"%s\", \"&gt;\");\n\t\t\tbreak;\n\t\tcase '\\'':\n\t\t\tgf_fprintf(file, \"&apos;\");\n\t\t\tbreak;\n\t\tcase '\\\"':\n\t\t\tgf_fprintf(file, \"&quot;\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgf_fprintf(file, \"%c\", str[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (after) {\n\t\tgf_fprintf(file, \"%s\", after);\n\t}\n}\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2005-2022\n *\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / common tools sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/xml.h>\n#include <gpac/utf.h>\n#include <gpac/network.h>\n\n#ifndef GPAC_DISABLE_ZLIB\n/*since 0.2.2, we use zlib for xmt/x3d reading to handle gz files*/\n#include <zlib.h>\n\n#if (defined(WIN32) || defined(_WIN32_WCE)) && !defined(__GNUC__)\n#pragma comment(lib, \"zlib\")\n#endif\n#else\n#define NO_GZIP\n#endif\n\n\n#define XML_INPUT_SIZE\t4096\n\n\nstatic GF_Err gf_xml_sax_parse_intern(GF_SAXParser *parser, char *current);\n\nstatic char *xml_translate_xml_string(char *str)\n{\n\tchar *value;\n\tu32 size, i, j;\n\tif (!str || !strlen(str)) return NULL;\n\tvalue = (char *)gf_malloc(sizeof(char) * 500);\n\tsize = 500;\n\ti = j = 0;\n\twhile (str[i]) {\n\t\tif (j+20 >= size) {\n\t\t\tsize += 500;\n\t\t\tvalue = (char *)gf_realloc(value, sizeof(char)*size);\n\t\t}\n\t\tif (str[i] == '&') {\n\t\t\tif (str[i+1]=='#') {\n\t\t\t\tchar szChar[20], *end;\n\t\t\t\tu16 wchar[2];\n\t\t\t\tu32 val, _len;\n\t\t\t\tconst unsigned short *srcp;\n\t\t\t\tstrncpy(szChar, str+i, 10);\n\t\t\t\tszChar[10] = 0;\n\t\t\t\tend = strchr(szChar, ';');\n\t\t\t\tif (!end) break;\n\t\t\t\tend[1] = 0;\n\t\t\t\ti += (u32) strlen(szChar);\n\t\t\t\twchar[1] = 0;\n\t\t\t\tif (szChar[2]=='x')\n\t\t\t\t\tsscanf(szChar, \"&#x%x;\", &val);\n\t\t\t\telse\n\t\t\t\t\tsscanf(szChar, \"&#%u;\", &val);\n\t\t\t\twchar[0] = val;\n\t\t\t\tsrcp = wchar;\n\t\t\t\t_len = gf_utf8_wcstombs(&value[j], 20, &srcp);\n\t\t\t\tif (_len == GF_UTF8_FAIL) _len = 0;\n\t\t\t\tj += _len;\n\t\t\t}\n\t\t\telse if (!strnicmp(&str[i], \"&amp;\", sizeof(char)*5)) {\n\t\t\t\tvalue[j] = '&';\n\t\t\t\tj++;\n\t\t\t\ti+= 5;\n\t\t\t}\n\t\t\telse if (!strnicmp(&str[i], \"&lt;\", sizeof(char)*4)) {\n\t\t\t\tvalue[j] = '<';\n\t\t\t\tj++;\n\t\t\t\ti+= 4;\n\t\t\t}\n\t\t\telse if (!strnicmp(&str[i], \"&gt;\", sizeof(char)*4)) {\n\t\t\t\tvalue[j] = '>';\n\t\t\t\tj++;\n\t\t\t\ti+= 4;\n\t\t\t}\n\t\t\telse if (!strnicmp(&str[i], \"&apos;\", sizeof(char)*6)) {\n\t\t\t\tvalue[j] = '\\'';\n\t\t\t\tj++;\n\t\t\t\ti+= 6;\n\t\t\t}\n\t\t\telse if (!strnicmp(&str[i], \"&quot;\", sizeof(char)*6)) {\n\t\t\t\tvalue[j] = '\\\"';\n\t\t\t\tj++;\n\t\t\t\ti+= 6;\n\t\t\t} else {\n\t\t\t\tvalue[j] = str[i];\n\t\t\t\tj++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t} else {\n\t\t\tvalue[j] = str[i];\n\t\t\tj++;\n\t\t\ti++;\n\t\t}\n\t}\n\tvalue[j] = 0;\n\treturn value;\n}\n\n\nenum\n{\n\tSAX_STATE_ATT_NAME,\n\tSAX_STATE_ATT_VALUE,\n\tSAX_STATE_ELEMENT,\n\tSAX_STATE_COMMENT,\n\tSAX_STATE_TEXT_CONTENT,\n\tSAX_STATE_ENTITY,\n\tSAX_STATE_SKIP_DOCTYPE,\n\tSAX_STATE_CDATA,\n\tSAX_STATE_DONE,\n\tSAX_STATE_XML_PROC,\n\tSAX_STATE_SYNTAX_ERROR,\n\tSAX_STATE_ALLOC_ERROR,\n};\n\ntypedef struct\n{\n\tu32 name_start, name_end;\n\tu32 val_start, val_end;\n\tBool has_entities;\n} GF_XMLSaxAttribute;\n\n\n/* #define NO_GZIP */\n\n\nstruct _tag_sax_parser\n{\n\t/*0: UTF-8, 1: UTF-16 BE, 2: UTF-16 LE. String input is always converted back to utf8*/\n\ts32 unicode_type;\n\tchar *buffer;\n\t/*alloc size, line size and current position*/\n\tu32 alloc_size, line_size, current_pos;\n\t/*current node depth*/\n\tu32 node_depth;\n\n\t/*gz input file*/\n#ifdef NO_GZIP\n\tFILE *f_in;\n#else\n\tgzFile gz_in;\n#endif\n\t/*current line , file size and pos for user notif*/\n\tu32 line, file_size, file_pos;\n\n\t/*SAX callbacks*/\n\tgf_xml_sax_node_start sax_node_start;\n\tgf_xml_sax_node_end sax_node_end;\n\tgf_xml_sax_text_content sax_text_content;\n\tvoid *sax_cbck;\n\tgf_xml_sax_progress on_progress;\n\n\tu32 sax_state;\n\tu32 init_state;\n\tGF_List *entities;\n\tchar att_sep;\n\tBool in_entity, suspended;\n\tu32 in_quote;\n\n\tu32 elt_start_pos, elt_end_pos;\n\n\t/*last error found*/\n\tchar err_msg[1000];\n\n\tu32 att_name_start, elt_name_start, elt_name_end, text_start, text_end;\n\tu32 text_check_escapes;\n\n\tGF_XMLAttribute *attrs;\n\tGF_XMLSaxAttribute *sax_attrs;\n\tu32 nb_attrs, nb_alloc_attrs;\n\tu32 ent_rec_level;\n};\n\nstatic GF_XMLSaxAttribute *xml_get_sax_attribute(GF_SAXParser *parser)\n{\n\tif (parser->nb_attrs==parser->nb_alloc_attrs) {\n\t\tparser->nb_alloc_attrs++;\n\t\tparser->sax_attrs = (GF_XMLSaxAttribute *)gf_realloc(parser->sax_attrs, sizeof(GF_XMLSaxAttribute)*parser->nb_alloc_attrs);\n\t\tparser->attrs = (GF_XMLAttribute *)gf_realloc(parser->attrs, sizeof(GF_XMLAttribute)*parser->nb_alloc_attrs);\n\t}\n\treturn &parser->sax_attrs[parser->nb_attrs++];\n}\n\nstatic void xml_sax_swap(GF_SAXParser *parser)\n{\n\tif (parser->current_pos && ((parser->sax_state==SAX_STATE_TEXT_CONTENT) || (parser->sax_state==SAX_STATE_COMMENT) ) ) {\n\t\tif (parser->line_size >= parser->current_pos) {\n\t\t\tparser->line_size -= parser->current_pos;\n\t\t\tparser->file_pos += parser->current_pos;\n\t\t\tif (parser->line_size) memmove(parser->buffer, parser->buffer + parser->current_pos, sizeof(char)*parser->line_size);\n\t\t\tparser->buffer[parser->line_size] = 0;\n\t\t\tparser->current_pos = 0;\n\t\t}\n\t}\n}\n\nstatic void format_sax_error(GF_SAXParser *parser, u32 linepos, const char* fmt, ...)\n{\n\tva_list args;\n\tu32 len;\n\n\tif (!parser) return;\n\n\tva_start(args, fmt);\n\tvsnprintf(parser->err_msg, GF_ARRAY_LENGTH(parser->err_msg), fmt, args);\n\tva_end(args);\n\n\tif (strlen(parser->err_msg)+30 < GF_ARRAY_LENGTH(parser->err_msg)) {\n\t\tchar szM[20];\n\t\tsnprintf(szM, 20, \" - Line %d: \", parser->line + 1);\n\t\tstrcat(parser->err_msg, szM);\n\t\tlen = (u32) strlen(parser->err_msg);\n\t\tstrncpy(parser->err_msg + len, parser->buffer+ (linepos ? linepos : parser->current_pos), 10);\n\t\tparser->err_msg[len + 10] = 0;\n\t}\n\tparser->sax_state = SAX_STATE_SYNTAX_ERROR;\n}\n\nstatic void xml_sax_node_end(GF_SAXParser *parser, Bool had_children)\n{\n\tchar *name, c;\n\n\tassert(parser->elt_name_start);\n\tassert(parser->elt_name_end);\n\tif (!parser->node_depth) {\n\t\tformat_sax_error(parser, 0, \"Markup error\");\n\t\treturn;\n\t}\n\tc = parser->buffer[parser->elt_name_end - 1];\n\tparser->buffer[parser->elt_name_end - 1] = 0;\n\tname = parser->buffer + parser->elt_name_start - 1;\n\n\tif (parser->sax_node_end) {\n\t\tchar *sep = strchr(name, ':');\n\t\tif (sep) {\n\t\t\tsep[0] = 0;\n\t\t\tparser->sax_node_end(parser->sax_cbck, sep+1, name);\n\t\t\tsep[0] = ':';\n\t\t} else {\n\t\t\tparser->sax_node_end(parser->sax_cbck, name, NULL);\n\t\t}\n\t}\n\tparser->buffer[parser->elt_name_end - 1] = c;\n\tparser->node_depth--;\n\tif (!parser->init_state && !parser->node_depth) parser->sax_state = SAX_STATE_DONE;\n\txml_sax_swap(parser);\n\tparser->text_start = parser->text_end = 0;\n}\n\nstatic void xml_sax_node_start(GF_SAXParser *parser)\n{\n\tBool has_entities = GF_FALSE;\n\tu32 i;\n\tchar c, *name;\n\n\tassert(parser->elt_name_start && parser->elt_name_end);\n\tc = parser->buffer[parser->elt_name_end - 1];\n\tparser->buffer[parser->elt_name_end - 1] = 0;\n\tname = parser->buffer + parser->elt_name_start - 1;\n\n\tfor (i=0; i<parser->nb_attrs; i++) {\n\t\tparser->attrs[i].name = parser->buffer + parser->sax_attrs[i].name_start - 1;\n\t\tparser->buffer[parser->sax_attrs[i].name_end-1] = 0;\n\t\tparser->attrs[i].value = parser->buffer + parser->sax_attrs[i].val_start - 1;\n\t\tparser->buffer[parser->sax_attrs[i].val_end-1] = 0;\n\n\t\tif (strchr(parser->attrs[i].value, '&')) {\n\t\t\tparser->sax_attrs[i].has_entities = GF_TRUE;\n\t\t\thas_entities = GF_TRUE;\n\t\t\tparser->attrs[i].value = xml_translate_xml_string(parser->attrs[i].value);\n\t\t}\n\t\t/*store first char pos after current attrib for node peeking*/\n\t\tparser->att_name_start = parser->sax_attrs[i].val_end;\n\t}\n\n\tif (parser->sax_node_start) {\n\t\tchar *sep = strchr(name, ':');\n\t\tif (sep) {\n\t\t\tsep[0] = 0;\n\t\t\tparser->sax_node_start(parser->sax_cbck, sep+1, name, parser->attrs, parser->nb_attrs);\n\t\t\tsep[0] = ':';\n\t\t} else {\n\t\t\tparser->sax_node_start(parser->sax_cbck, name, NULL, parser->attrs, parser->nb_attrs);\n\t\t}\n\t}\n\tparser->att_name_start = 0;\n\tparser->buffer[parser->elt_name_end - 1] = c;\n\tparser->node_depth++;\n\tif (has_entities) {\n\t\tfor (i=0; i<parser->nb_attrs; i++) {\n\t\t\tif (parser->sax_attrs[i].has_entities) {\n\t\t\t\tparser->sax_attrs[i].has_entities = GF_FALSE;\n\t\t\t\tgf_free(parser->attrs[i].value);\n\t\t\t}\n\t\t}\n\t}\n\tparser->nb_attrs = 0;\n\txml_sax_swap(parser);\n\tparser->text_start = parser->text_end = 0;\n}\n\nstatic Bool xml_sax_parse_attribute(GF_SAXParser *parser)\n{\n\tchar *sep;\n\tGF_XMLSaxAttribute *att = NULL;\n\n\t/*looking for attribute name*/\n\tif (parser->sax_state==SAX_STATE_ATT_NAME) {\n\t\t/*looking for start*/\n\t\tif (!parser->att_name_start) {\n\t\t\twhile (parser->current_pos < parser->line_size) {\n\t\t\t\tu8 c = parser->buffer[parser->current_pos];\n\t\t\t\tswitch (c) {\n\t\t\t\tcase '\\n':\n\t\t\t\t\tparser->line++;\n\t\t\t\tcase ' ':\n\t\t\t\tcase '\\r':\n\t\t\t\tcase '\\t':\n\t\t\t\t\tparser->current_pos++;\n\t\t\t\t\tcontinue;\n\t\t\t\t/*end of element*/\n\t\t\t\tcase '?':\n\t\t\t\t\tif (parser->init_state!=1) break;\n\t\t\t\tcase '/':\n\t\t\t\t\t/*not enough data*/\n\t\t\t\t\tif (parser->current_pos+1 == parser->line_size) return GF_TRUE;\n\t\t\t\t\tif (parser->buffer[parser->current_pos+1]=='>') {\n\t\t\t\t\t\tparser->current_pos+=2;\n\t\t\t\t\t\tparser->elt_end_pos = parser->file_pos + parser->current_pos - 1;\n\t\t\t\t\t\t/*done parsing attr AND elements*/\n\t\t\t\t\t\tif (!parser->init_state) {\n\t\t\t\t\t\t\txml_sax_node_start(parser);\n\t\t\t\t\t\t\t/*move to SAX_STATE_TEXT_CONTENT to force text flush*/\n\t\t\t\t\t\t\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\t\t\t\t\t\t\txml_sax_node_end(parser, GF_FALSE);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparser->nb_attrs = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser->sax_state = (parser->init_state) ? SAX_STATE_ELEMENT : SAX_STATE_TEXT_CONTENT;\n\t\t\t\t\t\tparser->text_start = parser->text_end = 0;\n\t\t\t\t\t\treturn GF_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\tif (!parser->in_quote && (c=='/')) {\n\t\t\t\t\t\tif (!parser->init_state) {\n\t\t\t\t\t\t\tformat_sax_error(parser, 0, \"Markup error\");\n\t\t\t\t\t\t\treturn GF_TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\"':\n\t\t\t\t\tif (parser->sax_state==SAX_STATE_ATT_VALUE) break;\n\t\t\t\t\tif (parser->in_quote && (parser->in_quote!=c) ) {\n\t\t\t\t\t\tformat_sax_error(parser, 0, \"Markup error\");\n\t\t\t\t\t\treturn GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t\tif (parser->in_quote) parser->in_quote = 0;\n\t\t\t\t\telse parser->in_quote = c;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tparser->current_pos+=1;\n\t\t\t\t\t/*end of <!DOCTYPE>*/\n\t\t\t\t\tif (parser->init_state) {\n\t\t\t\t\t\tif (parser->init_state==1) {\n\t\t\t\t\t\t\tformat_sax_error(parser, 0, \"Invalid <!DOCTYPE...> or <?xml...?>\");\n\t\t\t\t\t\t\treturn GF_TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\t\t\t\treturn GF_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\t/*done parsing attr*/\n\t\t\t\t\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\t\t\t\t\txml_sax_node_start(parser);\n\t\t\t\t\treturn GF_FALSE;\n\t\t\t\tcase '[':\n\t\t\t\t\tif (parser->init_state) {\n\t\t\t\t\t\tparser->current_pos+=1;\n\t\t\t\t\t\tif (parser->init_state==1) {\n\t\t\t\t\t\t\tformat_sax_error(parser, 0, \"Invalid <!DOCTYPE...> or <?xml...?>\");\n\t\t\t\t\t\t\treturn GF_TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\t\t\t\treturn GF_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\tformat_sax_error(parser, 0, \"Invalid character '<'\");\n\t\t\t\t\treturn GF_FALSE;\n\t\t\t\t/*first char of attr name*/\n\t\t\t\tdefault:\n\t\t\t\t\tparser->att_name_start = parser->current_pos + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tparser->current_pos++;\n\t\t\t\tif (parser->att_name_start) break;\n\t\t\t}\n\t\t\tif (parser->current_pos == parser->line_size) return GF_TRUE;\n\t\t}\n\n\t\tif (parser->init_state==2) {\n\t\t\tsep = strchr(parser->buffer + parser->att_name_start - 1, parser->in_quote ?  parser->in_quote : ' ');\n\t\t\t/*not enough data*/\n\t\t\tif (!sep) return GF_TRUE;\n\t\t\tparser->current_pos = (u32) (sep - parser->buffer);\n\t\t\tparser->att_name_start = 0;\n\t\t\tif (parser->in_quote) {\n\t\t\t\tparser->current_pos++;\n\t\t\t\tparser->in_quote = 0;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\n\t\t/*looking for '\"'*/\n\t\tif (parser->att_name_start) {\n\t\t\tu32 i, first=1;\n\t\t\tsep = strchr(parser->buffer + parser->att_name_start - 1, '=');\n\t\t\t/*not enough data*/\n\t\t\tif (!sep) return GF_TRUE;\n\n\t\t\tparser->current_pos = (u32) (sep - parser->buffer);\n\t\t\tatt = xml_get_sax_attribute(parser);\n\t\t\tatt->name_start = parser->att_name_start;\n\t\t\tatt->name_end = parser->current_pos + 1;\n\t\t\twhile (strchr(\" \\n\\t\", parser->buffer[att->name_end - 2])) {\n\t\t\t\tassert(att->name_end);\n\t\t\t\tatt->name_end --;\n\t\t\t}\n\t\t\tatt->has_entities = GF_FALSE;\n\n\t\t\tfor (i=att->name_start; i<att->name_end; i++) {\n\t\t\t\tchar c = parser->buffer[i-1];\n\t\t\t\tif ((c>='a') && (c<='z')) {}\n\t\t\t\telse if ((c>='A') && (c<='Z')) {}\n\t\t\t\telse if ((c==':') || (c=='_')) {}\n\n\t\t\t\telse if (!first && ((c=='-') || (c=='.') || ((c>='0') && (c<='9')) )) {}\n\n\t\t\t\telse {\n\t\t\t\t\tformat_sax_error(parser, att->name_start-1, \"Invalid character \\'%c\\' for attribute name\", c);\n\t\t\t\t\treturn GF_TRUE;\n\t\t\t\t}\n\n\t\t\t\tfirst=0;\n\t\t\t}\n\n\t\t\tparser->att_name_start = 0;\n\t\t\tparser->current_pos++;\n\t\t\tparser->sax_state = SAX_STATE_ATT_VALUE;\n\n\t\t}\n\t}\n\n\tif (parser->sax_state == SAX_STATE_ATT_VALUE) {\n\t\tatt = &parser->sax_attrs[parser->nb_attrs-1];\n\t\t/*looking for first delimiter*/\n\t\tif (!parser->att_sep) {\n\t\t\twhile (parser->current_pos < parser->line_size) {\n\t\t\t\tu8 c = parser->buffer[parser->current_pos];\n\t\t\t\tswitch (c) {\n\t\t\t\tcase '\\n':\n\t\t\t\t\tparser->line++;\n\t\t\t\tcase ' ':\n\t\t\t\tcase '\\r':\n\t\t\t\tcase '\\t':\n\t\t\t\t\tparser->current_pos++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase '\\'':\n\t\t\t\tcase '\"':\n\t\t\t\t\tparser->att_sep = c;\n\t\t\t\t\tatt->val_start = parser->current_pos + 2;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tparser->current_pos++;\n\t\t\t\tif (parser->att_sep) break;\n\t\t\t}\n\t\t\tif (parser->current_pos == parser->line_size) return GF_TRUE;\n\t\t}\n\natt_retry:\n\n\t\tassert(parser->att_sep);\n\t\tsep = strchr(parser->buffer + parser->current_pos, parser->att_sep);\n\t\tif (!sep || !sep[1]) return GF_TRUE;\n\n\t\tif (sep[1]==parser->att_sep) {\n\t\t\tformat_sax_error(parser, (u32) (sep - parser->buffer), \"Invalid character %c after attribute value separator %c \", sep[1], parser->att_sep);\n\t\t\treturn GF_TRUE;\n\t\t}\n\n\t\tif (!parser->init_state && (strchr(\" />\\n\\t\\r\", sep[1])==NULL)) {\n\t\t\tparser->current_pos = (u32) (sep - parser->buffer + 1);\n\t\t\tgoto att_retry;\n\t\t}\n\n\t\tparser->current_pos = (u32) (sep - parser->buffer);\n\t\tatt->val_end = parser->current_pos + 1;\n\t\tparser->current_pos++;\n\n\t\t/*\"style\" always at the beginning of the attributes for ease of parsing*/\n\t\tif (!strncmp(parser->buffer + att->name_start-1, \"style\", 5)) {\n\t\t\tGF_XMLSaxAttribute prev = parser->sax_attrs[0];\n\t\t\tparser->sax_attrs[0] = *att;\n\t\t\t*att = prev;\n\t\t}\n\t\tparser->att_sep = 0;\n\t\tparser->sax_state = SAX_STATE_ATT_NAME;\n\t\tparser->att_name_start = 0;\n\t\treturn GF_FALSE;\n\t}\n\treturn GF_TRUE;\n}\n\n\ntypedef struct\n{\n\tchar *name;\n\tchar *value;\n\tu32 namelen;\n\tu8 sep;\n} XML_Entity;\n\nstatic void xml_sax_flush_text(GF_SAXParser *parser)\n{\n\tchar *text, c;\n\tif (!parser->text_start || parser->init_state || !parser->sax_text_content) return;\n\n\tassert(parser->text_start < parser->text_end);\n\n\tc = parser->buffer[parser->text_end-1];\n\tparser->buffer[parser->text_end-1] = 0;\n\ttext = parser->buffer + parser->text_start-1;\n\n\t/*solve XML built-in entities*/\n//old code commented for ref, we now track escape chars\n//\tif (strchr(text, '&') && strchr(text, ';')) {\n\tif (parser->text_check_escapes==0x3) {\n\t\tchar *xml_text = xml_translate_xml_string(text);\n\t\tif (xml_text) {\n\t\t\tparser->sax_text_content(parser->sax_cbck, xml_text, (parser->sax_state==SAX_STATE_CDATA) ? GF_TRUE : GF_FALSE);\n\t\t\tgf_free(xml_text);\n\t\t}\n\t} else {\n\t\tparser->sax_text_content(parser->sax_cbck, text, (parser->sax_state==SAX_STATE_CDATA) ? GF_TRUE : GF_FALSE);\n\t}\n\tparser->buffer[parser->text_end-1] = c;\n\tparser->text_start = parser->text_end = 0;\n\tparser->text_check_escapes = 0;\n}\n\nstatic void xml_sax_store_text(GF_SAXParser *parser, u32 txt_len)\n{\n\tif (!txt_len) return;\n\n\tif (!parser->text_start) {\n\t\tparser->text_check_escapes = 0;\n\t\tparser->text_start = parser->current_pos + 1;\n\t\tparser->text_end = parser->text_start + txt_len;\n\t\tparser->current_pos += txt_len;\n\t\tassert(parser->current_pos <= parser->line_size);\n\t\treturn;\n\t}\n\t/*contiguous text*/\n\tif (parser->text_end && (parser->text_end-1 == parser->current_pos)) {\n\t\tparser->text_end += txt_len;\n\t\tparser->current_pos += txt_len;\n\t\tassert(parser->current_pos <= parser->line_size);\n\t\treturn;\n\t}\n\t/*need to flush*/\n\txml_sax_flush_text(parser);\n\n\tparser->text_start = parser->current_pos + 1;\n\tparser->text_end = parser->text_start + txt_len;\n\tparser->current_pos += txt_len;\n\tassert(parser->current_pos <= parser->line_size);\n}\n\nstatic char *xml_get_current_text(GF_SAXParser *parser)\n{\n\tchar *text, c;\n\tif (!parser->text_start) return NULL;\n\n\tc = parser->buffer[parser->text_end-1];\n\tparser->buffer[parser->text_end-1] = 0;\n\ttext = gf_strdup(parser->buffer + parser->text_start-1);\n\tparser->buffer[parser->text_end-1] = c;\n\tparser->text_start = parser->text_end = 0;\n\treturn text;\n}\n\nstatic void xml_sax_skip_doctype(GF_SAXParser *parser)\n{\n\twhile (parser->current_pos < parser->line_size) {\n\t\tif (parser->buffer[parser->current_pos]=='>') {\n\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\tparser->current_pos++;\n\t\t\txml_sax_swap(parser);\n\t\t\treturn;\n\t\t}\n\t\tparser->current_pos++;\n\t}\n}\n\nstatic void xml_sax_skip_xml_proc(GF_SAXParser *parser)\n{\n\twhile (parser->current_pos + 1 < parser->line_size) {\n\t\tif ((parser->buffer[parser->current_pos]=='?') && (parser->buffer[parser->current_pos+1]=='>')) {\n\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\tparser->current_pos++;\n\t\t\txml_sax_swap(parser);\n\t\t\treturn;\n\t\t}\n\t\tparser->current_pos++;\n\t}\n}\n\n\nstatic void xml_sax_parse_entity(GF_SAXParser *parser)\n{\n\tchar szC[2];\n\tchar *ent_name=NULL;\n\tu32 i = 0;\n\tXML_Entity *ent = (XML_Entity *)gf_list_last(parser->entities);\n\tchar *skip_chars = \" \\t\\n\\r\";\n\ti=0;\n\tif (ent && ent->value) ent = NULL;\n\tif (ent) skip_chars = NULL;\n\tszC[1]=0;\n\n\twhile (parser->current_pos+i < parser->line_size) {\n\t\tu8 c = parser->buffer[parser->current_pos+i];\n\t\tif (skip_chars && strchr(skip_chars, c)) {\n\t\t\tif (c=='\\n') parser->line++;\n\t\t\tparser->current_pos++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!ent && (c=='%')) {\n\t\t\tparser->current_pos+=i+1;\n\t\t\tparser->sax_state = SAX_STATE_SKIP_DOCTYPE;\n\t\t\tif (ent_name) gf_free(ent_name);\n\t\t\treturn;\n\t\t}\n\t\telse if (!ent && ((c=='\\\"') || (c=='\\'')) ) {\n\t\t\tGF_SAFEALLOC(ent, XML_Entity);\n\t\t\tif (!ent) {\n\t\t\t\tparser->sax_state = SAX_STATE_ALLOC_ERROR;\n\t\t\t\tif (ent_name) gf_free(ent_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!ent_name) gf_dynstrcat(&ent_name, \"\", NULL);\n\n\t\t\tent->name = ent_name;\n\t\t\tent_name=NULL;\n\t\t\tent->namelen = (u32) strlen(ent->name);\n\t\t\tent->sep = c;\n\t\t\tparser->current_pos += 1+i;\n\t\t\tassert(parser->current_pos < parser->line_size);\n\t\t\txml_sax_swap(parser);\n\t\t\ti=0;\n\t\t\tgf_list_add(parser->entities, ent);\n\t\t\tskip_chars = NULL;\n\t\t} else if (ent && c==ent->sep) {\n\t\t\tif (ent_name) gf_free(ent_name);\n\t\t\txml_sax_store_text(parser, i);\n\n\t\t\tent->value = xml_get_current_text(parser);\n\t\t\tif (!ent->value) ent->value = gf_strdup(\"\");\n\n\t\t\tparser->current_pos += 1;\n\t\t\tassert(parser->current_pos < parser->line_size);\n\t\t\txml_sax_swap(parser);\n\t\t\tparser->sax_state = SAX_STATE_SKIP_DOCTYPE;\n\t\t\treturn;\n\t\t} else if (!ent) {\n\t\t\tszC[0] = c;\n\t\t\tgf_dynstrcat(&ent_name, szC, NULL);\n\t\t\ti++;\n\t\t} else {\n\t\t\ti++;\n\t\t}\n\t}\n\tif (ent_name) gf_free(ent_name);\n\txml_sax_store_text(parser, i);\n}\n\nstatic void xml_sax_cdata(GF_SAXParser *parser)\n{\n\tchar *cd_end = strstr(parser->buffer + parser->current_pos, \"]]>\");\n\tif (!cd_end) {\n\t\txml_sax_store_text(parser, parser->line_size - parser->current_pos);\n\t} else {\n\t\tu32 size = (u32) (cd_end - (parser->buffer + parser->current_pos));\n\t\txml_sax_store_text(parser, size);\n\t\txml_sax_flush_text(parser);\n\t\tparser->current_pos += 3;\n\t\tassert(parser->current_pos <= parser->line_size);\n\t\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\t}\n}\n\nstatic Bool xml_sax_parse_comments(GF_SAXParser *parser)\n{\n\tchar *end = strstr(parser->buffer + parser->current_pos, \"-->\");\n\tif (!end) {\n\t\tif (parser->line_size>3)\n\t\t\tparser->current_pos = parser->line_size-3;\n\t\txml_sax_swap(parser);\n\t\treturn GF_FALSE;\n\t}\n\n\tparser->current_pos += 3 + (u32) (end - (parser->buffer + parser->current_pos) );\n\tassert(parser->current_pos <= parser->line_size);\n\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\tparser->text_start = parser->text_end = 0;\n\txml_sax_swap(parser);\n\treturn GF_TRUE;\n}\n\n\n\nstatic GF_Err xml_sax_parse(GF_SAXParser *parser, Bool force_parse)\n{\n\tu32 i = 0;\n\tBool is_text;\n\tu32 is_end;\n\tu8 c;\n\tchar *elt, sep;\n\tu32 cdata_sep;\n\n\twhile (parser->current_pos<parser->line_size) {\n\t\tif (!force_parse && parser->suspended) goto exit;\n\nrestart:\n\t\tis_text = GF_FALSE;\n\t\tswitch (parser->sax_state) {\n\t\t/*load an XML element*/\n\t\tcase SAX_STATE_TEXT_CONTENT:\n\t\t\tis_text = GF_TRUE;\n\t\tcase SAX_STATE_ELEMENT:\n\t\t\telt = NULL;\n\t\t\ti=0;\n\t\t\twhile ((c = parser->buffer[parser->current_pos+i]) !='<') {\n\t\t\t\tif ((parser->init_state==2) && (c ==']')) {\n\t\t\t\t\tparser->sax_state = SAX_STATE_ATT_NAME;\n\t\t\t\t\tparser->current_pos+=i+1;\n\t\t\t\t\tgoto restart;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t\tif (c=='\\n') parser->line++;\n\t\t\t\tif (is_text) {\n\t\t\t\t\tif (c=='&') parser->text_check_escapes |= 1;\n\t\t\t\t\telse if (c==';') parser->text_check_escapes |= 2;\n\t\t\t\t}\n\n\t\t\t\tif (parser->current_pos+i==parser->line_size) {\n\t\t\t\t\tif ((parser->line_size>=2*XML_INPUT_SIZE) && !parser->init_state)\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_SYNTAX_ERROR;\n\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_text && i) {\n\t\t\t\tu32 has_esc = parser->text_check_escapes;\n\t\t\t\txml_sax_store_text(parser, i);\n\t\t\t\tparser->text_check_escapes = has_esc;\n\t\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\t} else if (i) {\n\t\t\t\tparser->current_pos += i;\n\t\t\t\tassert(parser->current_pos < parser->line_size);\n\t\t\t}\n\t\t\tis_end = 0;\n\t\t\ti = 0;\n\t\t\tcdata_sep = 0;\n\t\t\twhile (1) {\n\t\t\t\tc = parser->buffer[parser->current_pos+1+i];\n\t\t\t\tif (!strncmp(parser->buffer+parser->current_pos+1+i, \"!--\", 3)) {\n\t\t\t\t\tparser->sax_state = SAX_STATE_COMMENT;\n\t\t\t\t\ti += 3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!c) {\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tif ((c=='\\t') || (c=='\\r') || (c==' ') ) {\n\t\t\t\t\tif (i) break;\n\t\t\t\t\telse parser->current_pos++;\n\t\t\t\t}\n\t\t\t\telse if (c=='\\n') {\n\t\t\t\t\tparser->line++;\n\t\t\t\t\tif (i) break;\n\t\t\t\t\telse parser->current_pos++;\n\t\t\t\t}\n\t\t\t\telse if (c=='>') break;\n\t\t\t\telse if (c=='=') break;\n\t\t\t\telse if (c=='[') {\n\t\t\t\t\ti++;\n\t\t\t\t\tif (!cdata_sep) cdata_sep = 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (c=='/') {\n\t\t\t\t\tis_end = !i ? 1 : 2;\n\t\t\t\t\ti++;\n\t\t\t\t} else if (c=='<') {\n\t\t\t\t\tif (parser->sax_state != SAX_STATE_COMMENT) {\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_SYNTAX_ERROR;\n\t\t\t\t\t\treturn GF_CORRUPTED_DATA;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\t/*\t\t\t\tif ((c=='[') && (parser->buffer[parser->elt_name_start-1 + i-2]=='A') ) break; */\n\t\t\t\tif (parser->current_pos+1+i==parser->line_size) {\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i) {\n\t\t\t\tparser->elt_name_start = parser->current_pos+1 + 1;\n\t\t\t\tif (is_end==1) parser->elt_name_start ++;\n\t\t\t\tif (is_end==2) parser->elt_name_end = parser->current_pos+1+i;\n\t\t\t\telse parser->elt_name_end = parser->current_pos+1+i + 1;\n\t\t\t}\n\t\t\tif (is_end) {\n\t\t\t\txml_sax_flush_text(parser);\n\t\t\t\tparser->elt_end_pos = parser->file_pos + parser->current_pos + i;\n\t\t\t\tif (is_end==2) {\n\t\t\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\t\t\txml_sax_node_start(parser);\n\t\t\t\t\txml_sax_node_end(parser, GF_FALSE);\n\t\t\t\t} else {\n\t\t\t\t\tparser->elt_end_pos += parser->elt_name_end - parser->elt_name_start;\n\t\t\t\t\txml_sax_node_end(parser, GF_TRUE);\n\t\t\t\t}\n\t\t\t\tif (parser->sax_state == SAX_STATE_SYNTAX_ERROR) break;\n\t\t\t\tparser->current_pos+=2+i;\n\t\t\t\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!parser->elt_name_end) {\n\t\t\t\treturn GF_CORRUPTED_DATA;\n\t\t\t}\n\t\t\tsep = parser->buffer[parser->elt_name_end-1];\n\t\t\tparser->buffer[parser->elt_name_end-1] = 0;\n\t\t\telt = parser->buffer + parser->elt_name_start-1;\n\n\t\t\tparser->sax_state = SAX_STATE_ATT_NAME;\n\t\t\tassert(parser->elt_start_pos <= parser->file_pos + parser->current_pos);\n\t\t\tparser->elt_start_pos = parser->file_pos + parser->current_pos;\n\n\t\t\tif (!strncmp(elt, \"!--\", 3)) {\n\t\t\t\txml_sax_flush_text(parser);\n\t\t\t\tparser->sax_state = SAX_STATE_COMMENT;\n\t\t\t\tif (i>3) parser->current_pos -= (i-3);\n\t\t\t}\n\t\t\telse if (!strcmp(elt, \"?xml\")) parser->init_state = 1;\n\t\t\telse if (!strcmp(elt, \"!DOCTYPE\")) parser->init_state = 2;\n\t\t\telse if (!strcmp(elt, \"!ENTITY\")) parser->sax_state = SAX_STATE_ENTITY;\n\t\t\telse if (!strcmp(elt, \"!ATTLIST\") || !strcmp(elt, \"!ELEMENT\")) parser->sax_state = SAX_STATE_SKIP_DOCTYPE;\n\t\t\telse if (!strcmp(elt, \"![CDATA[\"))\n\t\t\t\tparser->sax_state = SAX_STATE_CDATA;\n\t\t\telse if (elt[0]=='?') {\n\t\t\t\ti--;\n\t\t\t\tparser->sax_state = SAX_STATE_XML_PROC;\n\t\t\t}\n\t\t\t/*node found*/\n\t\t\telse {\n\t\t\t\txml_sax_flush_text(parser);\n\t\t\t\tif (parser->init_state) {\n\t\t\t\t\tparser->init_state = 0;\n\t\t\t\t\t/*that's a bit ugly: since we solve entities when appending text, we need to\n\t\t\t\t\treparse the current buffer*/\n\t\t\t\t\tif (gf_list_count(parser->entities)) {\n\t\t\t\t\t\tchar *orig_buf;\n\t\t\t\t\t\tGF_Err e;\n\t\t\t\t\t\tparser->buffer[parser->elt_name_end-1] = sep;\n\t\t\t\t\t\torig_buf = gf_strdup(parser->buffer + parser->current_pos);\n\t\t\t\t\t\tparser->current_pos = 0;\n\t\t\t\t\t\tparser->line_size = 0;\n\t\t\t\t\t\tparser->elt_start_pos = 0;\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\t\t\t\t\t\tparser->ent_rec_level++;\n\t\t\t\t\t\tif (parser->ent_rec_level>100) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"[XML] Too many recursions in entity solving, max 100 allowed\\n\"));\n\t\t\t\t\t\t\te = GF_NOT_SUPPORTED;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\te = gf_xml_sax_parse_intern(parser, orig_buf);\n\t\t\t\t\t\t\tparser->ent_rec_level--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_free(orig_buf);\n\t\t\t\t\t\treturn e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tparser->current_pos+=1+i;\n\t\t\tparser->buffer[parser->elt_name_end-1] = sep;\n\t\t\tbreak;\n\t\tcase SAX_STATE_COMMENT:\n\t\t\tif (!xml_sax_parse_comments(parser)) {\n\t\t\t\txml_sax_swap(parser);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SAX_STATE_ATT_NAME:\n\t\tcase SAX_STATE_ATT_VALUE:\n\t\t\tif (xml_sax_parse_attribute(parser))\n\t\t\t\tgoto exit;\n\t\t\tbreak;\n\t\tcase SAX_STATE_ENTITY:\n\t\t\txml_sax_parse_entity(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_SKIP_DOCTYPE:\n\t\t\txml_sax_skip_doctype(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_XML_PROC:\n\t\t\txml_sax_skip_xml_proc(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_CDATA:\n\t\t\txml_sax_cdata(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_SYNTAX_ERROR:\n\t\t\treturn GF_CORRUPTED_DATA;\n\t\tcase SAX_STATE_ALLOC_ERROR:\n\t\t\treturn GF_OUT_OF_MEM;\n\t\tcase SAX_STATE_DONE:\n\t\t\treturn GF_EOS;\n\t\t}\n\t}\nexit:\n#if 0\n\tif (is_text) {\n\t\tif (i) xml_sax_store_text(parser, i);\n\t\t/*DON'T FLUSH TEXT YET, wait for next '<' to do so otherwise we may corrupt xml base entities (&apos;, ...)*/\n\t}\n#endif\n\txml_sax_swap(parser);\n\n\tif (parser->sax_state==SAX_STATE_SYNTAX_ERROR)\n\t\treturn GF_CORRUPTED_DATA;\n\telse\n\t\treturn GF_OK;\n}\n\nstatic GF_Err xml_sax_append_string(GF_SAXParser *parser, char *string)\n{\n\tu32 size = parser->line_size;\n\tu32 nl_size = (u32) strlen(string);\n\n\tif (!nl_size) return GF_OK;\n\n\tif ( (parser->alloc_size < size+nl_size+1)\n\t        /*\t\t|| (parser->alloc_size / 2 ) > size+nl_size+1 */\n\t   )\n\t{\n\t\tparser->alloc_size = size+nl_size+1;\n\t\tparser->alloc_size = 3 * parser->alloc_size / 2;\n\t\tparser->buffer = (char*)gf_realloc(parser->buffer, sizeof(char) * parser->alloc_size);\n\t\tif (!parser->buffer ) return GF_OUT_OF_MEM;\n\t}\n\tmemcpy(parser->buffer+size, string, sizeof(char)*nl_size);\n\tparser->buffer[size+nl_size] = 0;\n\tparser->line_size = size+nl_size;\n\treturn GF_OK;\n}\n\nstatic XML_Entity *gf_xml_locate_entity(GF_SAXParser *parser, char *ent_start, Bool *needs_text)\n{\n\tu32 i, count;\n\tu32 len = (u32) strlen(ent_start);\n\n\t*needs_text = GF_FALSE;\n\tcount = gf_list_count(parser->entities);\n\n\tfor (i=0; i<count; i++) {\n\t\tXML_Entity *ent = (XML_Entity *)gf_list_get(parser->entities, i);\n\t\tif (len < ent->namelen + 1) {\n\t\t\tif (strncmp(ent->name, ent_start, len))\n\t\t\t \treturn NULL;\n\n\t\t\t*needs_text = GF_TRUE;\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!strncmp(ent->name, ent_start, ent->namelen) && (ent_start[ent->namelen]==';')) {\n\t\t\treturn ent;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n\nstatic GF_Err gf_xml_sax_parse_intern(GF_SAXParser *parser, char *current)\n{\n\tu32 count;\n\t/*solve entities*/\n\tcount = gf_list_count(parser->entities);\n\twhile (count) {\n\t\tchar *entityEnd;\n\t\tXML_Entity *ent;\n\t\tchar *entityStart = strstr(current, \"&\");\n\t\tBool needs_text;\n\t\tu32 line_num;\n\n\t\t/*if in entity, the start of the entity is in the buffer !!*/\n\t\tif (parser->in_entity) {\n\t\t\tu32 len;\n\t\t\tchar *name;\n\t\t\tentityEnd = strstr(current, \";\");\n\t\t\tif (!entityEnd) return xml_sax_append_string(parser, current);\n\t\t\tentityStart = strrchr(parser->buffer, '&');\n\n\t\t\tentityEnd[0] = 0;\n\t\t\tlen = (u32) strlen(entityStart) + (u32) strlen(current) + 1;\n\t\t\tname = (char*)gf_malloc(sizeof(char)*len);\n\t\t\tsprintf(name, \"%s%s;\", entityStart+1, current);\n\n\t\t\tent = gf_xml_locate_entity(parser, name, &needs_text);\n\t\t\tgf_free(name);\n\n\t\t\tif (!ent && !needs_text) {\n\t\t\t\txml_sax_append_string(parser, current);\n\t\t\t\txml_sax_parse(parser, GF_TRUE);\n\t\t\t\tentityEnd[0] = ';';\n\t\t\t\tcurrent = entityEnd;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tassert(ent);\n\t\t\t/*truncate input buffer*/\n\t\t\tparser->line_size -= (u32) strlen(entityStart);\n\t\t\tentityStart[0] = 0;\n\n\t\t\tparser->in_entity = GF_FALSE;\n\t\t\tentityEnd[0] = ';';\n\t\t\tcurrent = entityEnd+1;\n\t\t} else {\n\t\t\tif (!entityStart) break;\n\n\t\t\tent = gf_xml_locate_entity(parser, entityStart+1, &needs_text);\n\n\t\t\t/*store current string before entity start*/\n\t\t\tentityStart[0] = 0;\n\t\t\txml_sax_append_string(parser, current);\n\t\t\txml_sax_parse(parser, GF_TRUE);\n\t\t\tentityStart[0] = '&';\n\n\t\t\t/*this is not an entitiy*/\n\t\t\tif (!ent && !needs_text) {\n\t\t\t\txml_sax_append_string(parser, \"&\");\n\t\t\t\tcurrent = entityStart+1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!ent) {\n\t\t\t\tparser->in_entity = GF_TRUE;\n\t\t\t\t/*store entity start*/\n\t\t\t\treturn xml_sax_append_string(parser, entityStart);\n\t\t\t}\n\t\t\tcurrent = entityStart + ent->namelen + 2;\n\t\t}\n\t\t/*append entity*/\n\t\tline_num = parser->line;\n\t\txml_sax_append_string(parser, ent->value);\n\t\tGF_Err e = xml_sax_parse(parser, GF_TRUE);\n\t\tparser->line = line_num;\n\t\tif (e) return e;\n\n\t}\n\txml_sax_append_string(parser, current);\n\treturn xml_sax_parse(parser, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_xml_sax_parse(GF_SAXParser *parser, const void *string)\n{\n\tGF_Err e;\n\tchar *current;\n\tchar *utf_conv = NULL;\n\n\tif (parser->unicode_type < 0) return GF_BAD_PARAM;\n\n\tif (parser->unicode_type>1) {\n\t\tconst u16 *sptr = (const u16 *)string;\n\t\tu32 len = 2 * gf_utf8_wcslen(sptr);\n\t\tutf_conv = (char *)gf_malloc(sizeof(char)*(len+1));\n\t\tlen = gf_utf8_wcstombs(utf_conv, len, &sptr);\n\t\tif (len == GF_UTF8_FAIL) {\n\t\t\tparser->sax_state = SAX_STATE_SYNTAX_ERROR;\n\t\t\tgf_free(utf_conv);\n\t\t\treturn GF_CORRUPTED_DATA;\n\t\t}\n\t\tutf_conv[len] = 0;\n\t\tcurrent = utf_conv;\n\t} else {\n\t\tcurrent = (char *)string;\n\t}\n\n\te = gf_xml_sax_parse_intern(parser, current);\n\tif (utf_conv) gf_free(utf_conv);\n\treturn e;\n}\n\n\nGF_EXPORT\nGF_Err gf_xml_sax_init(GF_SAXParser *parser, unsigned char *BOM)\n{\n\tu32 offset;\n\tif (!BOM) {\n\t\tparser->unicode_type = 0;\n\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\treturn GF_OK;\n\t}\n\n\tif (parser->unicode_type >= 0) return gf_xml_sax_parse(parser, BOM);\n\n\tif ((BOM[0]==0xFF) && (BOM[1]==0xFE)) {\n\t\tif (!BOM[2] && !BOM[3]) return GF_NOT_SUPPORTED;\n\t\tparser->unicode_type = 2;\n\t\toffset = 2;\n\t} else if ((BOM[0]==0xFE) && (BOM[1]==0xFF)) {\n\t\tif (!BOM[2] && !BOM[3]) return GF_NOT_SUPPORTED;\n\t\tparser->unicode_type = 1;\n\t\toffset = 2;\n\t} else if ((BOM[0]==0xEF) && (BOM[1]==0xBB) && (BOM[2]==0xBF)) {\n\t\t/*we handle UTF8 as asci*/\n\t\tparser->unicode_type = 0;\n\t\toffset = 3;\n\t} else {\n\t\tparser->unicode_type = 0;\n\t\toffset = 0;\n\t}\n\n#ifdef GPAC_ENABLE_COVERAGE\n\tif (gf_sys_is_cov_mode()) {\n\t\tformat_sax_error(NULL, 0, \"\");\n\t}\n#endif\n\n\tparser->sax_state = SAX_STATE_ELEMENT;\n\treturn gf_xml_sax_parse(parser, BOM + offset);\n}\n\nstatic void xml_sax_reset(GF_SAXParser *parser)\n{\n\twhile (1) {\n\t\tXML_Entity *ent = (XML_Entity *)gf_list_last(parser->entities);\n\t\tif (!ent) break;\n\t\tgf_list_rem_last(parser->entities);\n\t\tif (ent->name) gf_free(ent->name);\n\t\tif (ent->value) gf_free(ent->value);\n\t\tgf_free(ent);\n\t}\n\tif (parser->buffer) gf_free(parser->buffer);\n\tparser->buffer = NULL;\n\tparser->current_pos = 0;\n\tgf_free(parser->attrs);\n\tparser->attrs = NULL;\n\tgf_free(parser->sax_attrs);\n\tparser->sax_attrs = NULL;\n\tparser->nb_alloc_attrs = parser->nb_attrs = 0;\n}\n\n\nstatic GF_Err xml_sax_read_file(GF_SAXParser *parser)\n{\n\tGF_Err e = GF_EOS;\n\tunsigned char szLine[XML_INPUT_SIZE+2];\n\n#ifdef NO_GZIP\n\tif (!parser->f_in) return GF_BAD_PARAM;\n#else\n\tif (!parser->gz_in) return GF_BAD_PARAM;\n#endif\n\n\n\twhile (!parser->suspended) {\n#ifdef NO_GZIP\n\t\ts32 read = (s32)gf_fread(szLine, XML_INPUT_SIZE, parser->f_in);\n#else\n\t\ts32 read = gf_gzread(parser->gz_in, szLine, XML_INPUT_SIZE);\n#endif\n\t\tif ((read<=0) /*&& !parser->node_depth*/) break;\n\t\tszLine[read] = 0;\n\t\tszLine[read+1] = 0;\n\t\te = gf_xml_sax_parse(parser, szLine);\n\t\tif (e) break;\n\t\tif (parser->file_pos > parser->file_size) parser->file_size = parser->file_pos + 1;\n\t\tif (parser->on_progress) parser->on_progress(parser->sax_cbck, parser->file_pos, parser->file_size);\n\t}\n\n#ifdef NO_GZIP\n\tif (gf_feof(parser->f_in)) {\n#else\n\tif (gf_gzeof(parser->gz_in)) {\n#endif\n\t\tif (!e) e = GF_EOS;\n\t\tif (parser->on_progress) parser->on_progress(parser->sax_cbck, parser->file_size, parser->file_size);\n\n#ifdef NO_GZIP\n\t\tgf_fclose(parser->f_in);\n\t\tparser->f_in = NULL;\n#else\n\t\tgf_gzclose(parser->gz_in);\n\t\tparser->gz_in = 0;\n#endif\n\n\t\tparser->elt_start_pos = parser->elt_end_pos = 0;\n\t\tparser->elt_name_start = parser->elt_name_end = 0;\n\t\tparser->att_name_start = 0;\n\t\tparser->current_pos = 0;\n\t\tparser->line_size = 0;\n\t\tparser->att_sep = 0;\n\t\tparser->file_pos = 0;\n\t\tparser->file_size = 0;\n\t\tparser->line_size = 0;\n\t}\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_xml_sax_parse_file(GF_SAXParser *parser, const char *fileName, gf_xml_sax_progress OnProgress)\n{\n\tFILE *test;\n\tGF_Err e;\n\tu64 filesize;\n#ifndef NO_GZIP\n\tgzFile gzInput;\n#endif\n\tunsigned char szLine[6];\n\n\tparser->on_progress = OnProgress;\n\n\tif (!strncmp(fileName, \"gmem://\", 7)) {\n\t\tu32 size;\n\t\tu8 *xml_mem_address;\n\t\te = gf_blob_get(fileName, &xml_mem_address, &size, NULL);\n\t\tif (e) return e;\n\n\t\tparser->file_size = size;\n\t\t//copy possible BOM\n\t\tmemcpy(szLine, xml_mem_address, 4);\n\t\tszLine[4] = szLine[5] = 0;\n\n\t\tparser->file_pos = 0;\n\t\tparser->elt_start_pos = 0;\n\t\tparser->current_pos = 0;\n\n\t\te = gf_xml_sax_init(parser, szLine);\n        if (!e) {\n            e = gf_xml_sax_parse(parser, xml_mem_address+4);\n            if (parser->on_progress) parser->on_progress(parser->sax_cbck, parser->file_pos, parser->file_size);\n        }\n        gf_blob_release(fileName);\n        \n\t\tparser->elt_start_pos = parser->elt_end_pos = 0;\n\t\tparser->elt_name_start = parser->elt_name_end = 0;\n\t\tparser->att_name_start = 0;\n\t\tparser->current_pos = 0;\n\t\tparser->line_size = 0;\n\t\tparser->att_sep = 0;\n\t\tparser->file_pos = 0;\n\t\tparser->file_size = 0;\n\t\tparser->line_size = 0;\n\t\treturn e;\n\t}\n\n\t/*check file exists and gets its size (zlib doesn't support SEEK_END)*/\n\ttest = gf_fopen(fileName, \"rb\");\n\tif (!test) return GF_URL_ERROR;\n\n\tfilesize = gf_fsize(test);\n\tassert(filesize < 0x80000000);\n\tparser->file_size = (u32) filesize;\n\tgf_fclose(test);\n\n\tparser->file_pos = 0;\n\tparser->elt_start_pos = 0;\n\tparser->current_pos = 0;\n\t//open file and copy possible BOM\n#ifdef NO_GZIP\n\tparser->f_in = gf_fopen(fileName, \"rt\");\n\tif (gf_fread(szLine, 4, parser->f_in) != 4) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"[XML] Error loading BOM\\n\"));\n\t}\n#else\n\tgzInput = gf_gzopen(fileName, \"rb\");\n\tif (!gzInput) return GF_IO_ERR;\n\tparser->gz_in = gzInput;\n\t/*init SAX parser (unicode setup)*/\n\tgf_gzread(gzInput, szLine, 4);\n#endif\n\n\tszLine[4] = szLine[5] = 0;\n\te = gf_xml_sax_init(parser, szLine);\n\tif (e) return e;\n\n\treturn xml_sax_read_file(parser);\n}\n\nGF_EXPORT\nBool gf_xml_sax_binary_file(GF_SAXParser *parser)\n{\n\tif (!parser) return GF_FALSE;\n#ifdef NO_GZIP\n\treturn GF_FALSE;\n#else\n\tif (!parser->gz_in) return GF_FALSE;\n\treturn (((z_stream*)parser->gz_in)->data_type==Z_BINARY) ? GF_TRUE : GF_FALSE;\n#endif\n}\n\nGF_EXPORT\nGF_SAXParser *gf_xml_sax_new(gf_xml_sax_node_start on_node_start,\n                             gf_xml_sax_node_end on_node_end,\n                             gf_xml_sax_text_content on_text_content,\n                             void *cbck)\n{\n\tGF_SAXParser *parser;\n\tGF_SAFEALLOC(parser, GF_SAXParser);\n\tif (!parser) return NULL;\n\tparser->entities = gf_list_new();\n\tparser->unicode_type = -1;\n\tparser->sax_node_start = on_node_start;\n\tparser->sax_node_end = on_node_end;\n\tparser->sax_text_content = on_text_content;\n\tparser->sax_cbck = cbck;\n\treturn parser;\n}\n\nGF_EXPORT\nvoid gf_xml_sax_del(GF_SAXParser *parser)\n{\n\txml_sax_reset(parser);\n\tgf_list_del(parser->entities);\n#ifdef NO_GZIP\n\tif (parser->f_in) gf_fclose(parser->f_in);\n#else\n\tif (parser->gz_in) gf_gzclose(parser->gz_in);\n#endif\n\tgf_free(parser);\n}\n\nGF_EXPORT\nGF_Err gf_xml_sax_suspend(GF_SAXParser *parser, Bool do_suspend)\n{\n\tparser->suspended = do_suspend;\n\tif (!do_suspend) {\n#ifdef NO_GZIP\n\t\tif (parser->f_in) return xml_sax_read_file(parser);\n#else\n\t\tif (parser->gz_in) return xml_sax_read_file(parser);\n#endif\n\t\treturn xml_sax_parse(parser, GF_FALSE);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nu32 gf_xml_sax_get_line(GF_SAXParser *parser) {\n\treturn parser->line + 1 ;\n}\n\n#if 0 //unused\nu32 gf_xml_sax_get_file_size(GF_SAXParser *parser)\n{\n#ifdef NO_GZIP\n\treturn parser->f_in ? parser->file_size : 0;\n#else\n\treturn parser->gz_in ? parser->file_size : 0;\n#endif\n}\n\nu32 gf_xml_sax_get_file_pos(GF_SAXParser *parser)\n{\n#ifdef NO_GZIP\n\treturn parser->f_in ? parser->file_pos : 0;\n#else\n\treturn parser->gz_in ? parser->file_pos : 0;\n#endif\n}\n#endif\n\n\n\nGF_EXPORT\nchar *gf_xml_sax_peek_node(GF_SAXParser *parser, char *att_name, char *att_value, char *substitute, char *get_attr, char *end_pattern, Bool *is_substitute)\n{\n\tu32 state, att_len, alloc_size, _len;\n#ifdef NO_GZIP\n\tu64 pos;\n#else\n\tz_off_t pos;\n#endif\n\tBool from_buffer;\n\tBool dobreak=GF_FALSE;\n\tchar szLine1[XML_INPUT_SIZE+2], szLine2[XML_INPUT_SIZE+2], *szLine, *cur_line, *sep, *start, first_c, *result;\n\n\n#define CPYCAT_ALLOC(__str, __is_copy) _len = (u32) strlen(__str);\\\n\t\t\t\t\t\t\tif ( _len + (__is_copy ? 0 : strlen(szLine))>=alloc_size) {\\\n\t\t\t\t\t\t\t\talloc_size = 1 + (u32) strlen(__str);\t\\\n\t\t\t\t\t\t\t\tif (!__is_copy) alloc_size += (u32) strlen(szLine); \\\n\t\t\t\t\t\t\t\tszLine = gf_realloc(szLine, alloc_size);\t\\\n\t\t\t\t\t\t\t}\\\n\t\t\t\t\t\t\tif (__is_copy) { memmove(szLine, __str, sizeof(char)*_len); szLine[_len] = 0; }\\\n\t\t\t\t\t\t\telse strcat(szLine, __str); \\\n\n\tfrom_buffer=GF_FALSE;\n#ifdef NO_GZIP\n\tif (!parser->f_in) from_buffer=GF_TRUE;\n#else\n\tif (!parser->gz_in) from_buffer=GF_TRUE;\n#endif\n\n\tresult = NULL;\n\n\tszLine1[0] = szLine2[0] = 0;\n\tpos=0;\n\tif (!from_buffer) {\n#ifdef NO_GZIP\n\t\tpos = gf_ftell(parser->f_in);\n#else\n\t\tpos = (u32) gf_gztell(parser->gz_in);\n#endif\n\t}\n\tatt_len = (u32) strlen(parser->buffer + parser->att_name_start);\n\tif (att_len<2*XML_INPUT_SIZE) att_len = 2*XML_INPUT_SIZE;\n\talloc_size = att_len;\n\tszLine = (char *) gf_malloc(sizeof(char)*alloc_size);\n\tstrcpy(szLine, parser->buffer + parser->att_name_start);\n\tcur_line = szLine;\n\tatt_len = (u32) strlen(att_value);\n\tstate = 0;\n\tgoto retry;\n\n\twhile (1) {\n\t\tu32 read;\n\t\tu8 sep_char;\n\t\tif (!from_buffer) {\n#ifdef NO_GZIP\n\t\t\tif (gf_feof(parser->f_in)) break;\n#else\n\t\t\tif (gf_gzeof(parser->gz_in)) break;\n#endif\n\t\t}\n\n\t\tif (dobreak) break;\n\n\t\tif (cur_line == szLine2) {\n\t\t\tcur_line = szLine1;\n\t\t} else {\n\t\t\tcur_line = szLine2;\n\t\t}\n\t\tif (from_buffer) {\n\t\t\tdobreak=GF_TRUE;\n\t\t} else {\n#ifdef NO_GZIP\n\t\t\tread = (u32)gf_fread(cur_line, XML_INPUT_SIZE, parser->f_in);\n#else\n\t\t\tread = gf_gzread(parser->gz_in, cur_line, XML_INPUT_SIZE);\n#endif\n\t\t\tcur_line[read] = cur_line[read+1] = 0;\n\n\t\t\tCPYCAT_ALLOC(cur_line, 0);\n\t\t}\n\n\t\tif (end_pattern) {\n\t\t\tstart  = strstr(szLine, end_pattern);\n\t\t\tif (start) {\n\t\t\t\tstart[0] = 0;\n\t\t\t\tdobreak = GF_TRUE;\n\t\t\t}\n\t\t}\n\nretry:\n\t\tif (state == 2) goto fetch_attr;\n\t\tsep = strstr(szLine, att_name);\n\t\tif (!sep && !state) {\n\t\t\tstate = 0;\n\t\t\tstart = strrchr(szLine, '<');\n\t\t\tif (start) {\n\t\t\t\tCPYCAT_ALLOC(start, 1);\n\t\t\t} else {\n\t\t\t\tCPYCAT_ALLOC(cur_line, 1);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!state) {\n\t\t\tstate = 1;\n\t\t\t/*load next line*/\n\t\t\tfirst_c = sep[0];\n\t\t\tsep[0] = 0;\n\t\t\tstart = strrchr(szLine, '<');\n\t\t\tif (!start)\n\t\t\t\tgoto exit;\n\t\t\tsep[0] = first_c;\n\t\t\tCPYCAT_ALLOC(start, 1);\n\t\t\tsep = strstr(szLine, att_name);\n\t\t}\n\t\tsep = sep ? strchr(sep, '=') : NULL;\n\t\tif (!sep) {\n\t\t\tstate = 0;\n\t\t\tCPYCAT_ALLOC(cur_line, 1);\n\t\t\tcontinue;\n\t\t}\n\t\twhile (sep[0] && (sep[0] != '\\\"') && (sep[0] != '\\'') ) sep++;\n\t\tif (!sep[0]) continue;\n\t\tsep_char = sep[0];\n\t\tsep++;\n\t\twhile (sep[0] && strchr(\" \\n\\r\\t\", sep[0]) ) sep++;\n\t\tif (!sep[0]) continue;\n\t\tif (!strchr(sep, sep_char))\n\t\t\tcontinue;\n\n\t\t/*found*/\n\t\tif (!strncmp(sep, att_value, att_len)) {\n\t\t\tu32 sub_pos;\n\t\t\tsep = szLine + 1;\n\t\t\twhile (strchr(\" \\t\\r\\n\", sep[0])) sep++;\n\t\t\tsub_pos = 0;\n\t\t\twhile (!strchr(\" \\t\\r\\n\", sep[sub_pos])) sub_pos++;\n\t\t\tfirst_c = sep[sub_pos];\n\t\t\tsep[sub_pos] = 0;\n\t\t\tstate = 2;\n\t\t\tif (!substitute || !get_attr || strcmp(sep, substitute) ) {\n\t\t\t\tif (is_substitute) *is_substitute = GF_FALSE;\n\t\t\t\tresult = gf_strdup(sep);\n\t\t\t\tsep[sub_pos] = first_c;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tsep[sub_pos] = first_c;\nfetch_attr:\n\t\t\tsep = strstr(szLine + 1, get_attr);\n\t\t\tif (!sep) {\n\t\t\t\tCPYCAT_ALLOC(cur_line, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsep += strlen(get_attr);\n\t\t\twhile (strchr(\"= \\t\\r\\n\", sep[0])) sep++;\n\t\t\tsep++;\n\t\t\tsub_pos = 0;\n\t\t\twhile (!strchr(\" \\t\\r\\n/>\", sep[sub_pos])) sub_pos++;\n\t\t\tsep[sub_pos-1] = 0;\n\t\t\tresult = gf_strdup(sep);\n\t\t\tif (is_substitute) *is_substitute = GF_TRUE;\n\t\t\tgoto exit;\n\t\t}\n\t\tstate = 0;\n\t\tCPYCAT_ALLOC(sep, 1);\n\t\tgoto retry;\n\t}\nexit:\n\tgf_free(szLine);\n\n\tif (!from_buffer) {\n#ifdef NO_GZIP\n\t\tgf_fseek(parser->f_in, pos, SEEK_SET);\n#else\n\t\tgf_gzrewind(parser->gz_in);\n\t\tgf_gzseek(parser->gz_in, pos, SEEK_SET);\n#endif\n\t}\n\treturn result;\n}\n\nGF_EXPORT\nconst char *gf_xml_sax_get_error(GF_SAXParser *parser)\n{\n\treturn parser->err_msg;\n}\n\n\nstruct _peek_type\n{\n\tGF_SAXParser *parser;\n\tchar *res;\n};\n\nstatic void on_peek_node_start(void *cbk, const char *name, const char *ns, const GF_XMLAttribute *attributes, u32 nb_attributes)\n{\n\tstruct _peek_type *pt = (struct _peek_type*)cbk;\n\tpt->res = gf_strdup(name);\n\tpt->parser->suspended = GF_TRUE;\n}\n\nGF_EXPORT\nchar *gf_xml_get_root_type(const char *file, GF_Err *ret)\n{\n\tGF_Err e;\n\tstruct _peek_type pt;\n\tpt.res = NULL;\n\tpt.parser = gf_xml_sax_new(on_peek_node_start, NULL, NULL, &pt);\n\te = gf_xml_sax_parse_file(pt.parser, file, NULL);\n\tif (ret) *ret = e;\n\tgf_xml_sax_del(pt.parser);\n\treturn pt.res;\n}\n\n\nGF_EXPORT\nu32 gf_xml_sax_get_node_start_pos(GF_SAXParser *parser)\n{\n\treturn parser->elt_start_pos;\n}\n\nGF_EXPORT\nu32 gf_xml_sax_get_node_end_pos(GF_SAXParser *parser)\n{\n\treturn parser->elt_end_pos;\n}\n\nstruct _tag_dom_parser\n{\n\tGF_SAXParser *parser;\n\tGF_List *stack;\n\t//root node being parsed\n\tGF_XMLNode *root;\n\t//usually only one :)\n\tGF_List *root_nodes;\n\tu32 depth;\n\n\tvoid (*OnProgress)(void *cbck, u64 done, u64 tot);\n\tvoid *cbk;\n};\n\n\nGF_EXPORT\nvoid gf_xml_dom_node_reset(GF_XMLNode *node, Bool reset_attribs, Bool reset_children)\n{\n\tif (!node) return;\n\tif (node->attributes && reset_attribs) {\n\t\twhile (gf_list_count(node->attributes)) {\n\t\t\tGF_XMLAttribute *att = (GF_XMLAttribute *)gf_list_last(node->attributes);\n\t\t\tgf_list_rem_last(node->attributes);\n\t\t\tif (att->name) gf_free(att->name);\n\t\t\tif (att->value) gf_free(att->value);\n\t\t\tgf_free(att);\n\t\t}\n\t}\n\n\tif (reset_children && node->content) {\n\t\twhile (gf_list_count(node->content)) {\n\t\t\tGF_XMLNode *child = (GF_XMLNode *)gf_list_last(node->content);\n\t\t\tgf_list_rem_last(node->content);\n\t\t\tgf_xml_dom_node_del(child);\n\t\t}\n\t}\n}\n\nGF_EXPORT\nvoid gf_xml_dom_node_del(GF_XMLNode *node)\n{\n\tif (!node) return;\n\tgf_xml_dom_node_reset(node, GF_TRUE, GF_TRUE);\n\tif (node->attributes) gf_list_del(node->attributes);\n\tif (node->content) gf_list_del(node->content);\n\tif (node->ns) gf_free(node->ns);\n\tif (node->name) gf_free(node->name);\n\tgf_free(node);\n}\n\nGF_List * gf_list_new_prealloc(u32 nb_prealloc);\n\nstatic void on_dom_node_start(void *cbk, const char *name, const char *ns, const GF_XMLAttribute *attributes, u32 nb_attributes)\n{\n\tu32 i;\n\tGF_DOMParser *par = (GF_DOMParser *) cbk;\n\tGF_XMLNode *node;\n\n\tif (par->root && !gf_list_count(par->stack)) {\n\t\tpar->parser->suspended = GF_TRUE;\n\t\treturn;\n\t}\n\n\tGF_SAFEALLOC(node, GF_XMLNode);\n\tif (!node) {\n\t\tpar->parser->sax_state = SAX_STATE_ALLOC_ERROR;\n\t\treturn;\n\t}\n\tnode->attributes = gf_list_new_prealloc(nb_attributes);\n\t//don't allocate content yet\n\tnode->name = gf_strdup(name);\n\tif (ns) node->ns = gf_strdup(ns);\n\tgf_list_add(par->stack, node);\n\tif (!par->root) {\n\t\tpar->root = node;\n\t\tgf_list_add(par->root_nodes, node);\n\t}\n\n\tfor (i=0; i<nb_attributes; i++) {\n\t\tGF_XMLAttribute *att;\n\t\tconst GF_XMLAttribute *in_att = & attributes[i];\n\t\tGF_SAFEALLOC(att, GF_XMLAttribute);\n\t\tif (! att) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[SAX] Failed to allocate attribute\"));\n\t\t\tpar->parser->sax_state = SAX_STATE_ALLOC_ERROR;\n\t\t\treturn;\n\t\t}\n\t\tatt->name = gf_strdup(in_att->name);\n\t\tatt->value = gf_strdup(in_att->value);\n\t\tgf_list_add(node->attributes, att);\n\t}\n}\n\nstatic void on_dom_node_end(void *cbk, const char *name, const char *ns)\n{\n\tGF_DOMParser *par = (GF_DOMParser *)cbk;\n\tGF_XMLNode *last = (GF_XMLNode *)gf_list_last(par->stack);\n\tgf_list_rem_last(par->stack);\n\n\tif (!last || (strlen(last->name)!=strlen(name)) || strcmp(last->name, name) || (!ns && last->ns) || (ns && !last->ns) || (ns && strcmp(last->ns, ns) ) ) {\n\t\ts32 idx;\n\t\tformat_sax_error(par->parser, 0, \"Invalid node stack: closing node is %s but %s was expected\", name, last ? last->name : \"unknown\");\n\t\tpar->parser->suspended = GF_TRUE;\n\t\tgf_xml_dom_node_del(last);\n\t\tif (last == par->root)\n\t\t\tpar->root=NULL;\n\t\tidx = gf_list_find(par->root_nodes, last);\n\t\tif (idx != -1)\n\t\t\tgf_list_rem(par->root_nodes, idx);\n\t\treturn;\n\t}\n\tif (last != par->root) {\n\t\tGF_XMLNode *node = (GF_XMLNode *)gf_list_last(par->stack);\n\t\tif (!node->content)\n\t\t\tnode->content = gf_list_new();\n\n\t\tgf_list_add(node->content, last);\n\t}\n}\n\nstatic void on_dom_text_content(void *cbk, const char *content, Bool is_cdata)\n{\n\tGF_DOMParser *par = (GF_DOMParser *)cbk;\n\tGF_XMLNode *node;\n\tGF_XMLNode *last = (GF_XMLNode *)gf_list_last(par->stack);\n\tif (!last) return;\n\tif (!last->content)\n\t\tlast->content = gf_list_new();\n\n\tGF_SAFEALLOC(node, GF_XMLNode);\n\tif (!node) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[SAX] Failed to allocate XML node\"));\n\t\tpar->parser->sax_state = SAX_STATE_ALLOC_ERROR;\n\t\treturn;\n\t}\n\tnode->type = is_cdata ? GF_XML_CDATA_TYPE : GF_XML_TEXT_TYPE;\n\tnode->name = gf_strdup(content);\n\tgf_list_add(last->content, node);\n}\n\nGF_EXPORT\nGF_DOMParser *gf_xml_dom_new()\n{\n\tGF_DOMParser *dom;\n\tGF_SAFEALLOC(dom, GF_DOMParser);\n\tif (!dom) return NULL;\n\n\tdom->root_nodes = gf_list_new();\n\treturn dom;\n}\n\nstatic void gf_xml_dom_reset(GF_DOMParser *dom, Bool full_reset)\n{\n\tif (full_reset && dom->parser) {\n\t\tgf_xml_sax_del(dom->parser);\n\t\tdom->parser = NULL;\n\t}\n\n\tif (dom->stack) {\n\t\twhile (gf_list_count(dom->stack)) {\n\t\t\tGF_XMLNode *n = (GF_XMLNode *)gf_list_last(dom->stack);\n\t\t\tgf_list_rem_last(dom->stack);\n\t\t\tif (dom->root==n) {\n\t\t\t\tgf_list_del_item(dom->root_nodes, n);\n\t\t\t\tdom->root = NULL;\n\t\t\t}\n\t\t\tgf_xml_dom_node_del(n);\n\t\t}\n\t\tgf_list_del(dom->stack);\n\t\tdom->stack = NULL;\n\t}\n\tif (full_reset && gf_list_count(dom->root_nodes) ) {\n\t\twhile (gf_list_count(dom->root_nodes)) {\n\t\t\tGF_XMLNode *n = (GF_XMLNode *)gf_list_last(dom->root_nodes);\n\t\t\tgf_list_rem_last(dom->root_nodes);\n\t\t\tgf_xml_dom_node_del(n);\n\t\t}\n\t\tdom->root = NULL;\n\t}\n}\n\nGF_EXPORT\nvoid gf_xml_dom_del(GF_DOMParser *parser)\n{\n\tif (!parser)\n\t\treturn;\n\n\tgf_xml_dom_reset(parser, GF_TRUE);\n\tgf_list_del(parser->root_nodes);\n\tgf_free(parser);\n}\n\nGF_EXPORT\nGF_XMLNode *gf_xml_dom_detach_root(GF_DOMParser *parser)\n{\n\tGF_XMLNode *root;\n\tif (!parser)\n\t\treturn NULL;\n\troot = parser->root;\n\tgf_list_del_item(parser->root_nodes, root);\n\tparser->root = gf_list_get(parser->root_nodes, 0);\n\treturn root;\n}\n\nstatic void dom_on_progress(void *cbck, u64 done, u64 tot)\n{\n\tGF_DOMParser *dom = (GF_DOMParser *)cbck;\n\tdom->OnProgress(dom->cbk, done, tot);\n}\n\nGF_EXPORT\nGF_Err gf_xml_dom_parse(GF_DOMParser *dom, const char *file, gf_xml_sax_progress OnProgress, void *cbk)\n{\n\tGF_Err e;\n\tgf_xml_dom_reset(dom, GF_TRUE);\n\tdom->stack = gf_list_new();\n\tdom->parser = gf_xml_sax_new(on_dom_node_start, on_dom_node_end, on_dom_text_content, dom);\n\tdom->OnProgress = OnProgress;\n\tdom->cbk = cbk;\n\te = gf_xml_sax_parse_file(dom->parser, file, OnProgress ? dom_on_progress : NULL);\n\tgf_xml_dom_reset(dom, GF_FALSE);\n\treturn e<0 ? e : GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_xml_dom_parse_string(GF_DOMParser *dom, char *string)\n{\n\tGF_Err e;\n\tgf_xml_dom_reset(dom, GF_TRUE);\n\tdom->stack = gf_list_new();\n\tdom->parser = gf_xml_sax_new(on_dom_node_start, on_dom_node_end, on_dom_text_content, dom);\n\te = gf_xml_sax_init(dom->parser, (unsigned char *) string);\n\tgf_xml_dom_reset(dom, GF_FALSE);\n\treturn e<0 ? e : GF_OK;\n}\n\n#if 0 //unused\nGF_XMLNode *gf_xml_dom_create_root(GF_DOMParser *parser, const char* name) {\n\tGF_XMLNode * root;\n\tif (!parser) return NULL;\n\n\tGF_SAFEALLOC(root, GF_XMLNode);\n\tif (!root) return NULL;\n\troot->name = gf_strdup(name);\n\n\treturn root;\n}\n#endif\n\nGF_EXPORT\nGF_XMLNode *gf_xml_dom_get_root(GF_DOMParser *parser)\n{\n\treturn parser ? parser->root : NULL;\n}\nGF_EXPORT\nconst char *gf_xml_dom_get_error(GF_DOMParser *parser)\n{\n\treturn gf_xml_sax_get_error(parser->parser);\n}\nGF_EXPORT\nu32 gf_xml_dom_get_line(GF_DOMParser *parser)\n{\n\treturn gf_xml_sax_get_line(parser->parser);\n}\n\nGF_EXPORT\nu32 gf_xml_dom_get_root_nodes_count(GF_DOMParser *parser)\n{\n\treturn parser? gf_list_count(parser->root_nodes) : 0;\n}\n\nGF_EXPORT\nGF_XMLNode *gf_xml_dom_get_root_idx(GF_DOMParser *parser, u32 idx)\n{\n\treturn parser ? (GF_XMLNode*)gf_list_get(parser->root_nodes, idx) : NULL;\n}\n\n\nstatic void gf_xml_dom_node_serialize(GF_XMLNode *node, Bool content_only, Bool no_escape, char **str, u32 *alloc_size, u32 *size)\n{\n\tu32 i, count, vlen;\n\tchar *name;\n\n#define SET_STRING(v)\t\\\n\tvlen = (u32) strlen(v);\t\\\n\tif (vlen + (*size) >= (*alloc_size)) {\t\\\n\t\t(*alloc_size) += 1024;\t\\\n\t\tif (vlen + (*size) >= (*alloc_size)) (*alloc_size) = vlen + (*size) + 1;\\\n\t\t(*str) = gf_realloc((*str), (*alloc_size));\t\\\n\t\t(*str)[(*size)] = 0;\t\\\n\t}\t\\\n\tstrcat((*str), v);\t\\\n\t*size += vlen;\t\\\n\n\tswitch (node->type) {\n\tcase GF_XML_CDATA_TYPE:\n\t\tSET_STRING(\"![CDATA[\");\n\t\tSET_STRING(node->name);\n\t\tSET_STRING(\"]]>\");\n\t\treturn;\n\tcase GF_XML_TEXT_TYPE:\n\t\tname = node->name;\n\t\tif ((name[0]=='\\r') && (name[1]=='\\n'))\n\t\t\tname++;\n\n\t\tif (no_escape) {\n\t\t\tSET_STRING(name);\n\t\t} else {\n\t\t\tu32 tlen;\n\t\t\tchar szChar[2];\n\t\t\tszChar[1] = 0;\n\t\t\ttlen = (u32) strlen(name);\n\t\t\tfor (i= 0; i<tlen; i++) {\n\t\t\t\tswitch (name[i]) {\n\t\t\t\tcase '&':\n\t\t\t\t\tSET_STRING(\"&amp;\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\tSET_STRING(\"&lt;\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tSET_STRING(\"&gt;\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\'':\n\t\t\t\t\tSET_STRING(\"&apos;\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\"':\n\t\t\t\t\tSET_STRING(\"&quot;\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tszChar[0] = name[i];\n\t\t\t\t\tSET_STRING(szChar);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!content_only) {\n\t\tSET_STRING(\"<\");\n\t\tif (node->ns) {\n\t\t\tSET_STRING(node->ns);\n\t\t\tSET_STRING(\":\");\n\t\t}\n\t\tSET_STRING(node->name);\n\t\tcount = gf_list_count(node->attributes);\n\t\tif (count > 0) {\n\t\t\tSET_STRING(\" \");\n\t\t}\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_XMLAttribute *att = (GF_XMLAttribute*)gf_list_get(node->attributes, i);\n\t\t\tSET_STRING(att->name);\n\t\t\tSET_STRING(\"=\\\"\");\n\t\t\tSET_STRING(att->value);\n\t\t\tSET_STRING(\"\\\" \");\n\t\t}\n\n\t\tif (!gf_list_count(node->content)) {\n\t\t\tSET_STRING(\"/>\");\n\t\t\treturn;\n\t\t}\n\t\tSET_STRING(\">\");\n\t}\n\n\tcount = gf_list_count(node->content);\n\tfor (i=0; i<count; i++) {\n\t\tGF_XMLNode *child = (GF_XMLNode*)gf_list_get(node->content, i);\n\t\tgf_xml_dom_node_serialize(child, GF_FALSE, GF_FALSE, str, alloc_size, size);\n\t}\n\tif (!content_only) {\n\t\tSET_STRING(\"</\");\n\t\tif (node->ns) {\n\t\t\tSET_STRING(node->ns);\n\t\t\tSET_STRING(\":\");\n\t\t}\n\t\tSET_STRING(node->name);\n\t\tSET_STRING(\">\");\n\t}\n}\n\nGF_EXPORT\nchar *gf_xml_dom_serialize(GF_XMLNode *node, Bool content_only, Bool no_escape)\n{\n\tu32 alloc_size = 0;\n\tu32 size = 0;\n\tchar *str = NULL;\n\tgf_xml_dom_node_serialize(node, content_only, no_escape, &str, &alloc_size, &size);\n\treturn str;\n}\n\nGF_EXPORT\nchar *gf_xml_dom_serialize_root(GF_XMLNode *node, Bool content_only, Bool no_escape)\n{\n\tu32 alloc_size, size;\n\tchar *str = NULL;\n\tgf_dynstrcat(&str, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\", NULL);\n\tif (!str) return NULL;\n\n\talloc_size = size = (u32) strlen(str) + 1;\n\tgf_xml_dom_node_serialize(node, content_only, no_escape, &str, &alloc_size, &size);\n\treturn str;\n}\n\n#if 0 //unused\nGF_XMLAttribute *gf_xml_dom_set_attribute(GF_XMLNode *node, const char* name, const char* value) {\n\tGF_XMLAttribute *att;\n\tif (!name || !value) return NULL;\n\tif (!node->attributes) {\n\t\tnode->attributes = gf_list_new();\n\t\tif (!node->attributes) return NULL;\n\t}\n\n\tatt = gf_xml_dom_create_attribute(name, value);\n\tif (!att) return NULL;\n\tgf_list_add(node->attributes, att);\n\treturn att;\n}\n\nGF_XMLAttribute *gf_xml_dom_get_attribute(GF_XMLNode *node, const char* name) {\n\tu32 i = 0;\n\tGF_XMLAttribute *att;\n\tif (!node || !name) return NULL;\n\n\twhile ( (att = (GF_XMLAttribute*)gf_list_enum(node->attributes, &i))) {\n\t\tif (!strcmp(att->name, name)) {\n\t\t\treturn att;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n#endif\n\nGF_EXPORT\nGF_XMLAttribute *gf_xml_dom_create_attribute(const char* name, const char* value) {\n\tGF_XMLAttribute *att;\n\tGF_SAFEALLOC(att, GF_XMLAttribute);\n\tif (!att) return NULL;\n\n\tatt->name = gf_strdup(name);\n\tatt->value = gf_strdup(value);\n\treturn att;\n}\n\n\nGF_EXPORT\nGF_Err gf_xml_dom_append_child(GF_XMLNode *node, GF_XMLNode *child) {\n\tif (!node || !child) return GF_BAD_PARAM;\n\tif (!node->content) {\n\t\tnode->content = gf_list_new();\n\t\tif (!node->content) return GF_OUT_OF_MEM;\n\t}\n\treturn gf_list_add(node->content, child);\n}\n\n#if 0\n/*!\n\\brief Removes the node to the list of children of this node.\n\nRemoves the node to the list of children of this node.\n\\warning Doesn't free the memory of the removed children.\n\n\\param node the GF_XMLNode node\n\\param child the GF_XMLNode child to remove\n\\return Error code if any, otherwise GF_OK\n */\nGF_EXPORT\nGF_Err gf_xml_dom_rem_child(GF_XMLNode *node, GF_XMLNode *child) {\n\ts32 idx;\n\tif (!node || !child || !node->content) return GF_BAD_PARAM;\n\tidx = gf_list_find(node->content, child);\n\tif (idx == -1) return GF_BAD_PARAM;\n\treturn gf_list_rem(node->content, idx);\n}\n#endif //unused\n\n\nGF_XMLNode *gf_xml_dom_node_new(const char* ns, const char* name)\n{\n\tGF_XMLNode* node;\n\tGF_SAFEALLOC(node, GF_XMLNode);\n\tif (!node) return NULL;\n\tif (ns) {\n\t\tnode->ns = gf_strdup(ns);\n\t\tif (!node->ns) {\n\t\t\tgf_free(node);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (name) {\n\t\tnode->name = gf_strdup(name);\n\t\tif (!node->name) {\n\t\t\tgf_free(node->ns);\n\t\t\tgf_free(node);\n\t\t\treturn NULL;\n\t\t}\n\t\tnode->type = GF_XML_NODE_TYPE;\n\t} else {\n\t\tnode->type = GF_XML_TEXT_TYPE;\n\t}\n\treturn node;\n}\n\n#include <gpac/base_coding.h>\n\n#define XML_SCAN_INT(_fmt, _value)\t\\\n\t{\\\n\tif (strstr(att->value, \"0x\")) { u32 __i; sscanf(att->value+2, \"%x\", &__i); _value = __i; }\\\n\telse if (strstr(att->value, \"0X\")) { u32 __i; sscanf(att->value+2, \"%X\", &__i); _value = __i; }\\\n\telse sscanf(att->value, _fmt, &_value); \\\n\t}\\\n\n\nGF_Err gf_xml_parse_bit_sequence_bs(GF_XMLNode *bsroot, const char *parent_url, const char *base_media_file, GF_BitStream *bs_orig)\n{\n\tu32 i, j;\n\tGF_Err e = GF_OK;\n\tGF_XMLNode *node;\n\tGF_XMLAttribute *att;\n\tGF_BitStream *bs = bs_orig;\n\tu32 enc_base64 = 0;\n\n\ti=0;\n\twhile ((node = (GF_XMLNode *) gf_list_enum(bsroot->content, &i))) {\n\t\tu32 nb_bits = 0;\n\t\tu32 size = 0;\n\t\tu64 offset = 0;\n\t\ts64 value = 0;\n\t\tBool use_file = GF_FALSE;\n\t\tbin128 word128;\n\t\tFloat val_float = 0;\n\t\tDouble val_double = 0;\n\t\tBool use_word128 = GF_FALSE;\n\t\tBool use_text = GF_FALSE;\n\t\tBool base64_prefix_bits = 0;\n\t\tBool big_endian = GF_TRUE;\n\t\tBool has_float = GF_FALSE;\n\t\tBool has_double = GF_FALSE;\n\t\tconst char *szFile = NULL;\n\t\tconst char *szString = NULL;\n\t\tconst char *szBase64 = NULL;\n\t\tconst char *szData = NULL;\n\t\tif (node->type) continue;\n\n\t\tif (stricmp(node->name, \"BS\") ) {\n\t\t\te = gf_xml_parse_bit_sequence_bs(node, parent_url, base_media_file, bs);\n\t\t\tif (e) goto exit;\n\t\t\tcontinue;\n\t\t}\n\n\t\tj=0;\n\t\twhile ( (att = (GF_XMLAttribute *)gf_list_enum(node->attributes, &j))) {\n\t\t\tif (!stricmp(att->name, \"bits\")) {\n\t\t\t\tXML_SCAN_INT(\"%d\", nb_bits);\n\t\t\t} else if (!stricmp(att->name, \"value\")) {\n\t\t\t\tXML_SCAN_INT(LLD, value);\n\t\t\t} else if (!stricmp(att->name, \"float\")) {\n\t\t\t\tsscanf(att->value, \"%f\", &val_float);\n\t\t\t\thas_float = GF_TRUE;\n\t\t\t} else if (!stricmp(att->name, \"double\")) {\n\t\t\t\tsscanf(att->value, \"%lf\", &val_double);\n\t\t\t\thas_double = GF_TRUE;\n\t\t\t} else if (!stricmp(att->name, \"mediaOffset\") || !stricmp(att->name, \"dataOffset\")) {\n\t\t\t\tXML_SCAN_INT(LLU, offset);\n\t\t\t\tuse_file = GF_TRUE;\n\t\t\t} else if (!stricmp(att->name, \"dataLength\")) {\n\t\t\t\tXML_SCAN_INT(\"%u\", size);\n\t\t\t\tuse_file = GF_TRUE;\n\t\t\t} else if (!stricmp(att->name, \"mediaFile\") || !stricmp(att->name, \"dataFile\")) {\n\t\t\t\tszFile = att->value;\n\t\t\t\tuse_file = GF_TRUE;\n\t\t\t} else if (!stricmp(att->name, \"text\") || !stricmp(att->name, \"string\")) {\n\t\t\t\tszString = att->value;\n\t\t\t} else if (!stricmp(att->name, \"fcc\")) {\n\t\t\t\tvalue = GF_4CC(att->value[0], att->value[1], att->value[2], att->value[3]);\n\t\t\t\tnb_bits = 32;\n\t\t\t} else if (!stricmp(att->name, \"ID128\")) {\n\t\t\t\te = gf_bin128_parse(att->value, word128);\n                if (e != GF_OK) {\n                    GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[XML/NHML] Cannot parse ID128\\n\"));\n                    goto exit;\n                }\n\t\t\t\tuse_word128 = GF_TRUE;\n\t\t\t} else if (!stricmp(att->name, \"textmode\")) {\n\t\t\t\tif (!strcmp(att->value, \"yes\")) use_text = GF_TRUE;\n\t\t\t} else if (!stricmp(att->name, \"data64\")) {\n\t\t\t\tszBase64 = att->value;\n\t\t\t} else if (!stricmp(att->name, \"data\")) {\n\t\t\t\tszData = att->value;\n\t\t\t\tif (!strnicmp(szData, \"0x\", 2)) szData += 2;\n\t\t\t} else if (!stricmp(att->name, \"endian\") && !stricmp(att->value, \"little\")) {\n\t\t\t\tbig_endian = GF_FALSE;\n\t\t\t} else if (!stricmp(att->name, \"base64\")) {\n\t\t\t\tif (!stricmp(att->value, \"yes\") || !stricmp(att->value, \"true\") ) {\n\t\t\t\t\tif (!enc_base64) enc_base64 = 1;\n\t\t\t\t} else if (!stricmp(att->value, \"start\")) {\n\t\t\t\t\tif (!enc_base64) enc_base64 = 2;\n\t\t\t\t} else if (!stricmp(att->value, \"end\")) {\n\t\t\t\t\tif (enc_base64==2) enc_base64 = 3;\n\t\t\t\t} else {\n                    GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[XML/NHML] Invalid base64 attribute %s, expecting yes/no, start or end\\n\", att->value));\n                    e = GF_NON_COMPLIANT_BITSTREAM;\n                    goto exit;\n\t\t\t\t}\n\t\t\t} else if (!stricmp(att->name, \"base64Prefix\")) {\n\t\t\t\tbase64_prefix_bits = atoi(att->value);\n\t\t\t} else if (!stricmp(att->name, \"id\")) {\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[XML/NHML] Unkown attribute %s, ignoring\\n\", att->name));\n\t\t\t}\n\t\t}\n\n\t\tif (enc_base64 && (enc_base64<3)) {\n\t\t\tif (bs == bs_orig) {\n\t\t\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t\tif (!bs) {\n\t\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (use_file && !szFile)\n\t\t\tszFile = base_media_file;\n\n\t\tif (szString) {\n\t\t\tu32 len = (u32) strlen(szString);\n\t\t\tif (nb_bits)\n\t\t\t\tgf_bs_write_int(bs, len, nb_bits);\n\n\t\t\tgf_bs_write_data(bs, szString, len);\n\t\t} else if (szBase64) {\n\t\t\tu32 len = (u32) strlen(szBase64);\n\t\t\tchar *data = (char *) gf_malloc(sizeof(char)*len);\n\t\t\tu32 ret;\n\t\t\tif (!data) {\n\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tret = (u32) gf_base64_decode((char *)szBase64, len, data, len);\n\t\t\tif ((s32) ret >=0) {\n\t\t\t\tgf_bs_write_int(bs, ret, nb_bits);\n\t\t\t\tgf_bs_write_data(bs, data, ret);\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[XML/NHML] Error decoding base64 %s\\n\", att->value));\n\t\t\t\tgf_free(data);\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tgf_free(data);\n\t\t} else if (szData) {\n\t\t\tu32 len = (u32) strlen(szData);\n\t\t\tchar *data = (char *) gf_malloc(sizeof(char)*len/2);\n\t\t\tif (!data) {\n\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tfor (j=0; j<len; j+=2) {\n\t\t\t\tu32 v;\n\t\t\t\tchar szV[5];\n\t\t\t\tsprintf(szV, \"%c%c\", szData[j], szData[j+1]);\n\t\t\t\tsscanf(szV, \"%x\", &v);\n\t\t\t\tdata[j/2] = v;\n\t\t\t}\n\t\t\tgf_bs_write_int(bs, len/2, nb_bits);\n\t\t\tgf_bs_write_data(bs, data, len/2);\n\t\t\tgf_free(data);\n\t\t} else if (has_float) {\n\t\t\tgf_bs_write_float(bs, val_float);\n\t\t} else if (has_double) {\n\t\t\tgf_bs_write_double(bs, val_double);\n\t\t} else if (nb_bits) {\n\t\t\tif (!big_endian) {\n\t\t\t\tif (nb_bits == 16)\n\t\t\t\t\tgf_bs_write_u16_le(bs, (u32)value);\n\t\t\t\telse if (nb_bits == 32)\n\t\t\t\t\tgf_bs_write_u32_le(bs, (u32)value);\n\t\t\t\telse {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[XML/NHML] Little-endian values can only be 16 or 32-bit\\n\"));\n\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (nb_bits<33) gf_bs_write_int(bs, (s32) value, nb_bits);\n\t\t\t\telse gf_bs_write_long_int(bs, value, nb_bits);\n\t\t\t}\n\t\t} else if (szFile) {\n\t\t\tu32 read, remain;\n\t\t\tchar block[1024];\n\t\t\tFILE *_tmp = NULL;\n\t\t\tif (parent_url) {\n\t\t\t\tchar *f_url = gf_url_concatenate(parent_url, szFile);\n\t\t\t\t_tmp = gf_fopen(f_url, use_text ? \"rt\" : \"rb\");\n\t\t\t\tgf_free(f_url);\n\t\t\t} else {\n\t\t\t\t_tmp = gf_fopen(szFile, use_text ? \"rt\" : \"rb\");\n\t\t\t}\n\n\t\t\tif (!_tmp) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[XML/NHML] Error opening file %s\\n\", szFile));\n\t\t\t\te = GF_URL_ERROR;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tif (!size) {\n\t\t\t\tsize = (u32) gf_fsize(_tmp);\n\t\t\t\t//if offset only copy from offset until end\n\t\t\t\tif ((u64) size > offset)\n\t\t\t\t\tsize -= (u32) offset;\n\t\t\t}\n\t\t\tremain = size;\n\t\t\tgf_fseek(_tmp, offset, SEEK_SET);\n\t\t\twhile (remain) {\n\t\t\t\tu32 bsize = remain;\n\t\t\t\tif (bsize>1024) bsize=1024;\n\t\t\t\tread = (u32) gf_fread(block, bsize, _tmp);\n\t\t\t\tif ((s32) read < 0) {\n\t\t\t\t\tgf_fclose(_tmp);\n\t\t\t\t\te = GF_IO_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\n\t\t\t\tgf_bs_write_data(bs, block, read);\n\t\t\t\tremain -= bsize;\n\t\t\t}\n\t\t\tgf_fclose(_tmp);\n\t\t} else if (use_word128) {\n\t\t\tgf_bs_write_data(bs, (char *)word128, 16);\n\t\t}\n\n\t\tif ((enc_base64==1) || (enc_base64==3)) {\n\t\t\tu8 *bs_data;\n\t\t\tu32 bs_data_size;\n\t\t\tassert (bs != bs_orig);\n\t\t\tgf_bs_get_content(bs, &bs_data, &bs_data_size);\n\t\t\tgf_bs_del(bs);\n\t\t\tenc_base64 = 0;\n\t\t\tbs = bs_orig;\n\t\t\tif (bs_data) {\n\t\t\t\tu8 *bs_data_out;\n\t\t\t\tu32 res = 2*bs_data_size + 3;\n\t\t\t\tbs_data_out = gf_malloc(sizeof(char) * res);\n\t\t\t\tif (!bs_data_out) {\n\t\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tres = gf_base64_encode(bs_data, bs_data_size, bs_data_out, res);\n\t\t\t\tbs_data_out[res] = 0;\n\t\t\t\tif (base64_prefix_bits) {\n\t\t\t\t\tif (base64_prefix_bits % 8) {\n\t\t\t\t\t\tgf_bs_write_int(bs, res, base64_prefix_bits);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu32 nb_bytes = base64_prefix_bits/8;\n\t\t\t\t\t\tif (!big_endian && (nb_bytes==8)) gf_bs_write_u64_le(bs, res);\n\t\t\t\t\t\telse if (!big_endian && (nb_bytes==4)) gf_bs_write_u32_le(bs, res);\n\t\t\t\t\t\telse if (!big_endian && (nb_bytes==2)) gf_bs_write_u16_le(bs, res);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tgf_bs_write_int(bs, res, base64_prefix_bits);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_bs_write_data(bs, bs_data_out, res);\n\t\t\t\tgf_free(bs_data);\n\t\t\t\tgf_free(bs_data_out);\n\t\t\t}\n\t\t}\n\t}\n\nexit:\n\tif (bs != bs_orig) {\n\t\tif (!e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[XML/NHML] base64 encoding context not closed\\n\"));\n\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tgf_bs_del(bs);\n\t}\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_xml_parse_bit_sequence(GF_XMLNode *bsroot, const char *parent_url, u8 **data, u32 *data_size)\n{\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (!bs) return GF_OUT_OF_MEM;\n\n\tgf_xml_parse_bit_sequence_bs(bsroot, parent_url, NULL, bs);\n\n\tgf_bs_align(bs);\n\tgf_bs_get_content(bs, data, data_size);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\nGF_Err gf_xml_get_element_check_namespace(const GF_XMLNode *n, const char *expected_node_name, const char *expected_ns_prefix) {\n\tu32 i;\n\tGF_XMLAttribute *att;\n\n\t/*check we are processing the expected node*/\n\tif (expected_node_name && strcmp(expected_node_name, n->name)) {\n\t\treturn GF_SG_UNKNOWN_NODE;\n\t}\n\n\t/*check for previously declared prefix (to be manually provided)*/\n\tif (!n->ns) {\n\t\treturn GF_OK;\n\t}\n\tif (expected_ns_prefix && !strcmp(expected_ns_prefix, n->ns)) {\n\t\treturn GF_OK;\n\t}\n\n\t/*look for new namespace in attributes*/\n\ti = 0;\n\twhile ( (att = (GF_XMLAttribute*)gf_list_enum(n->attributes, &i)) ) {\n\t\tconst char *ns;\n\t\tns = strstr(att->name, \":\");\n\t\tif (!ns) continue;\n\t\t\n\t\tif (!strncmp(att->name, \"xmlns\", 5)) {\n\t\t\tif (!strcmp(ns+1, n->ns)) {\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CORE, (\"[XML] Unsupported attribute namespace \\\"%s\\\": ignoring\\n\", att->name));\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"[XML] Unresolved namespace \\\"%s\\\" for node \\\"%s\\\"\\n\", n->ns, n->name));\n\treturn GF_BAD_PARAM;\n}\n\nvoid gf_xml_dump_string(FILE* file, const char *before, const char *str, const char *after)\n{\n\tsize_t i;\n\tsize_t len=str?strlen(str):0;\n\n\tif (before) {\n\t\tgf_fprintf(file, \"%s\", before);\n\t}\n\n\tfor (i = 0; i < len; i++) {\n\t\tswitch (str[i]) {\n\t\tcase '&':\n\t\t\tgf_fprintf(file, \"%s\", \"&amp;\");\n\t\t\tbreak;\n\t\tcase '<':\n\t\t\tgf_fprintf(file, \"%s\", \"&lt;\");\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\tgf_fprintf(file, \"%s\", \"&gt;\");\n\t\t\tbreak;\n\t\tcase '\\'':\n\t\t\tgf_fprintf(file, \"&apos;\");\n\t\t\tbreak;\n\t\tcase '\\\"':\n\t\t\tgf_fprintf(file, \"&quot;\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgf_fprintf(file, \"%c\", str[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (after) {\n\t\tgf_fprintf(file, \"%s\", after);\n\t}\n}\n"], "filenames": ["src/utils/xml_parser.c"], "buggy_code_start_loc": [193], "buggy_code_end_loc": [1079], "fixing_code_start_loc": [194], "fixing_code_end_loc": [1089], "type": "CWE-121", "message": "Stack-based Buffer Overflow in GitHub repository gpac/gpac prior to 2.2.2.", "other": {"cve": {"id": "CVE-2023-2837", "sourceIdentifier": "security@huntr.dev", "published": "2023-05-22T18:15:09.163", "lastModified": "2023-05-27T04:15:24.960", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Stack-based Buffer Overflow in GitHub repository gpac/gpac prior to 2.2.2."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-121"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.2.2", "matchCriteriaId": "DBF31B7B-F4C7-40C0-9245-09FECA1A8164"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/6f28c4cd607d83ce381f9b4a9f8101ca1e79c611", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/a6bfd1b2-aba8-4c6f-90c4-e95b1831cb17", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5411", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/6f28c4cd607d83ce381f9b4a9f8101ca1e79c611"}}