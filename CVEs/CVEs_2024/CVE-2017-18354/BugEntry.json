{"buggy_code": ["'use strict';\n\nconst request = require('request');\n\n/**\n * A default set of user agent patterns for bots/crawlers that do not perform\n * well with pages that require JavaScript.\n */\nconst botUserAgents = module.exports.botUserAgents = [\n  'W3C_Validator',\n  'baiduspider',\n  'bingbot',\n  'embedly',\n  'facebookexternalhit',\n  'linkedinbo',\n  'outbrain',\n  'pinterest',\n  'quora link preview',\n  'rogerbo',\n  'showyoubot',\n  'slackbot',\n  'twitterbot',\n  'vkShare',\n];\n\n/* eslint-disable no-multi-spaces */\n\n/**\n * A default set of file extensions for static assets that do not need to be\n * proxied.\n */\nconst staticFileExtensions = [\n  'ai',  'avi',  'css', 'dat',  'dmg', 'doc',     'doc',  'exe', 'flv',\n  'gif', 'ico',  'iso', 'jpeg', 'jpg', 'js',      'less', 'm4a', 'm4v',\n  'mov', 'mp3',  'mp4', 'mpeg', 'mpg', 'pdf',     'png',  'ppt', 'psd',\n  'rar', 'rss',  'svg', 'swf',  'tif', 'torrent', 'ttf',  'txt', 'wav',\n  'wmv', 'woff', 'xls', 'xml',  'zip',\n];\n\n/* eslint-enable no-multi-spaces */\n\n/**\n * @return {!Object} A new Express middleware function that proxies requests to\n * a Rendertron bot rendering service. Options:\n *\n * @param {!Object} options Configuration object with the following properties:\n * - proxyUrl: Base URL of the Rendertron proxy service. Required.\n * - userAgentPattern: Regular expression to match user agent to proxy.\n *   Defaults to a set of bots that do not perform well with pages that require\n *   JavaScript.\n * - excludeUrlPattern: Regular expression used to exclude request URL paths.\n *   Defaults to a set of typical static asset file extensions.\n * - injectShadyDom: Force web components polyfills to be loaded and enabled.\n * - timeout: Millisecond timeout for proxy requests.\n */\nmodule.exports.makeMiddleware = function(options) {\n  if (!options || !options.proxyUrl) {\n    throw new Error('Must set options.proxyUrl.');\n  }\n  let proxyUrl = options.proxyUrl;\n  if (!proxyUrl.endsWith('/')) {\n    proxyUrl += '/';\n  }\n  const userAgentPattern =\n      options.userAgentPattern || new RegExp(botUserAgents.join('|'), 'i');\n  const excludeUrlPattern = options.excludeUrlPattern ||\n      new RegExp(`\\\\.(${staticFileExtensions.join('|')})$`, 'i');\n  const injectShadyDom = !!options.injectShadyDom;\n  // The Rendertron service itself has a hard limit of 10 seconds to render, so\n  // let's give a little more time than that by default.\n  const timeout = options.timeout || 11000; // Milliseconds.\n\n  return function rendertronMiddleware(req, res, next) {\n    if (!userAgentPattern.test(req.headers['user-agent']) ||\n        excludeUrlPattern.test(req.path)) {\n      next();\n      return;\n    }\n    const incomingUrl =\n        req.protocol + '://' + req.get('host') + req.originalUrl;\n    let renderUrl = proxyUrl + encodeURIComponent(incomingUrl);\n    if (injectShadyDom) {\n      renderUrl += '?wc-inject-shadydom';\n    }\n    request({url: renderUrl, timeout}, (e) => {\n      if (e) {\n        console.error(\n            `[rendertron middleware] ${e.code} error fetching ${renderUrl}`);\n        next();\n      }\n    }).pipe(res);\n  };\n};\n", "'use strict';\n\nconst express = require('express');\nconst supertest = require('supertest');\nconst test = require('ava');\n\nconst rendertron = require('../src/middleware');\n\n/**\n * Start the given Express app on localhost with a random port.\n * @param {!Object} app The app.\n * @return {Promise<string>}Promise of the URL.\n */\nasync function listen(app) {\n  return new Promise((resolve) => {\n    const server = app.listen(/* random */ 0, 'localhost', () => {\n      resolve(`http://localhost:${server.address().port}`);\n    });\n  });\n}\n\n/**\n * Make an Express app that uses the Rendertron middleware and returns\n * \"fallthrough\" if the middleware skipped the request (i.e. called `next`).\n * @param {Object} options Rendertron middleware options.\n * @return {!Object} The app.\n */\nfunction makeApp(options) {\n  return express()\n      .use(rendertron.makeMiddleware(options))\n      .use((req, res) => res.end('fallthrough'));\n}\n\n/**\n * Make an Express app that takes the place of a Rendertron server instance and\n * always responds with \"proxy <decoded url>\".\n * @return {!Object} The app.\n */\nfunction makeProxy() {\n  return express().use((req, res) => {\n    res.end('proxy ' + decodeURIComponent(req.url.substring(1)));\n  });\n}\n\nconst bot = 'slackbot';\nconst human = 'Chrome';\n\n/**\n * GET a URL with the given user agent.\n * @param {string} userAgent The user agent string.\n * @param {string} host The host part of the URL.\n * @param {string} path The path part of the URL.\n * @return {Promise<!Object>} Promise of the GET response.\n */\nasync function get(userAgent, host, path) {\n  return await supertest(host).get(path).set('User-Agent', userAgent);\n}\n\ntest('makes a middleware function', async (t) => {\n  const m = rendertron.makeMiddleware({proxyUrl: 'http://example.com'});\n  t.truthy(m);\n});\n\ntest('throws if no proxyUrl given', async (t) => {\n  t.throws(() => rendertron.makeMiddleware());\n  t.throws(() => rendertron.makeMiddleware({}));\n  t.throws(() => rendertron.makeMiddleware({proxyUrl: ''}));\n});\n\ntest('proxies through given url', async (t) => {\n  const proxyUrl = await listen(makeProxy());\n  const appUrl = await listen(makeApp({proxyUrl}));\n\n  const res = await get(bot, appUrl, '/foo');\n  t.is(res.status, 200);\n  t.is(res.text, 'proxy ' + appUrl + '/foo');\n});\n\ntest('proxyUrl can have trailing slash', async (t) => {\n  const proxyUrl = await listen(makeProxy());\n  // Make sure our other tests are testing the no-trailing-slash case.\n  t.false(proxyUrl.endsWith('/'));\n  const appUrl = await listen(makeApp({proxyUrl: proxyUrl + '/'}));\n\n  const res = await get(bot, appUrl, '/foo');\n  t.is(res.status, 200);\n  t.is(res.text, 'proxy ' + appUrl + '/foo');\n});\n\ntest('adds shady dom parameter', async (t) => {\n  const proxyUrl = await listen(makeProxy());\n  const appUrl = await listen(makeApp({proxyUrl, injectShadyDom: true}));\n\n  const res = await get(bot, appUrl, '/foo');\n  t.is(res.status, 200);\n  t.is(res.text, 'proxy ' + appUrl + '/foo?wc-inject-shadydom');\n});\n\ntest('excludes static file paths by default', async (t) => {\n  const proxyUrl = await listen(makeProxy());\n  const appUrl = await listen(makeApp({proxyUrl}));\n\n  const res = await get(bot, appUrl, '/foo.png');\n  t.is(res.text, 'fallthrough');\n});\n\ntest('url exclusion only matches url path component', async (t) => {\n  const proxyUrl = await listen(makeProxy());\n  const appUrl = await listen(makeApp({proxyUrl}));\n\n  const res = await get(bot, appUrl, '/foo.png?params');\n  t.is(res.text, 'fallthrough');\n});\n\ntest('excludes non-bot user agents by default', async (t) => {\n  const proxyUrl = await listen(makeProxy());\n  const appUrl = await listen(makeApp({proxyUrl}));\n\n  const res = await get(human, appUrl, '/foo');\n  t.is(res.text, 'fallthrough');\n});\n\ntest('respects custom user agent pattern', async (t) => {\n  const proxyUrl = await listen(makeProxy());\n  const appUrl = await listen(makeApp({proxyUrl, userAgentPattern: /borg/}));\n\n  let res;\n\n  res = await get('humon', appUrl, '/foo');\n  t.is(res.text, 'fallthrough');\n\n  res = await get('borg', appUrl, '/foo');\n  t.is(res.text, 'proxy ' + appUrl + '/foo');\n});\n\ntest('respects custom exclude url pattern', async (t) => {\n  const proxyUrl = await listen(makeProxy());\n  const appUrl = await listen(makeApp({proxyUrl, excludeUrlPattern: /foo/}));\n\n  let res;\n\n  res = await get(bot, appUrl, '/foo');\n  t.is(res.text, 'fallthrough');\n\n  res = await get(bot, appUrl, '/bar');\n  t.is(res.text, 'proxy ' + appUrl + '/bar');\n});\n\ntest('forwards proxy error status and body', async (t) => {\n  // This proxy always returns an error.\n  const proxyUrl = await listen(\n      express().use((req, res) => res.status(500).end('proxy error')));\n  const appUrl = await listen(makeApp({proxyUrl}));\n\n  const res = await get(bot, appUrl, '/bar');\n  t.is(res.status, 500);\n  t.is(res.text, 'proxy error');\n});\n\ntest('falls through after timeout', async (t) => {\n  // This proxy returns after 20ms, but our timeout is 10ms.\n  const proxyUrl = await listen(express().use((req, res) => {\n    setTimeout(() => res.end('too slow'), 20);\n  }));\n  const appUrl = await listen(makeApp({proxyUrl, timeout: 10}));\n\n  const res = await get(bot, appUrl, '/foo');\n  t.is(res.text, 'fallthrough');\n});\n", "'use strict';\n\nconst datastore = require('@google-cloud/datastore')();\n\nclass Cache {\n  async clearCache() {\n    const query = datastore.createQuery('Page');\n    const data = await datastore.runQuery(query);\n    const entities = data[0];\n    const entityKeys = entities.map((entity) => entity[datastore.KEY]);\n    console.log(`Removing ${entities.length} items from the cache`);\n    await datastore.delete(entityKeys);\n    // TODO(samli): check info (data[1]) and loop through pages of entities to delete.\n  }\n\n  async cacheContent(key, headers, payload) {\n    // Set cache length to 1 day.\n    const cacheDurationMinutes = 60*24;\n    const now = new Date();\n    const entity = {\n      key: key,\n      data: [\n        {name: 'saved', value: now},\n        {name: 'expires', value: new Date(now.getTime() + cacheDurationMinutes*60*1000)},\n        {name: 'headers', value: JSON.stringify(headers), excludeFromIndexes: true},\n        {name: 'payload', value: JSON.stringify(payload), excludeFromIndexes: true},\n      ]\n    };\n    await datastore.save(entity);\n  }\n\n  /**\n   * Returns middleware function.\n   * @return {function}\n   */\n  middleware() {\n    return async function(request, response, next) {\n      function accumulateContent(content) {\n        if (typeof(content) === 'string') {\n          body = body || '' + content;\n        } else if (Buffer.isBuffer(content)) {\n          if (!body)\n            body = new Buffer(0);\n          body = Buffer.concat([body, content], body.length + content.length);\n        }\n      }\n\n      // Cache based on full URL. This means requests with different params are\n      // cached separately.\n      const key = datastore.key(['Page', request.url]);\n      const results = await datastore.get(key);\n\n      if (results.length && results[0] != undefined) {\n        // Serve cached content if its not expired.\n        if (results[0].expires.getTime() >= new Date().getTime()) {\n          const headers = JSON.parse(results[0].headers);\n          response.set(headers);\n          let payload = JSON.parse(results[0].payload);\n          if (typeof(payload) == 'object' && payload.type == 'Buffer')\n            payload = new Buffer(payload);\n          response.send(payload);\n          return;\n        }\n      }\n\n      // Capture output to cache.\n      const methods = {\n        write: response.write,\n        end: response.end,\n      };\n      let body = null;\n\n      response.write = function(content, ...args) {\n        accumulateContent(content);\n        return methods.write.apply(response, [content].concat(args));\n      };\n\n      response.end = async function(content, ...args) {\n        if (response.statusCode == 200) {\n          accumulateContent(content);\n          await this.cacheContent(key, response.getHeaders(), body);\n        }\n        return methods.end.apply(response, [content].concat(args));\n      }.bind(this);\n\n      next();\n    }.bind(this);\n  }\n}\n\n// TODO(samli): Allow for caching options, like freshness options.\nmodule.exports = new Cache();\n", "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes\">\n\n    <title>Rendertron</title>\n    <meta name=\"description\" content=\"Rendertron - headless rendering service\">\n\n    <link href=\"https://fonts.googleapis.com/css?family=Orbitron\" rel=\"stylesheet\">\n    <link href=\"https://fonts.googleapis.com/icon?family=Material+Icons\" rel=\"stylesheet\">\n\n    <script>\n      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\n      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\n      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\n\n      ga('create', 'UA-104508854-1', 'auto');\n      ga('send', 'pageview');\n    </script>\n\n    <style>\n      body {\n        background: black;\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        justify-content: center;\n        font-family: 'Orbitron', sans-serif;\n        margin: 0;\n        min-height: calc(100vh - 40px);\n        padding: 20px 0;\n      }\n\n      h1 {\n        font-size: 60px;\n        color: white;\n        border-bottom: 1px solid #99f3ff;\n        margin: 64px 32px;\n      }\n\n      #search-bar {\n        min-width: 300px;\n        width: calc(100% - 40px);\n        max-width: 664px;\n        position: relative;\n        box-sizing: border-box;\n      }\n\n      input[type=url] {\n        width: 100%;\n        padding: 30px;\n        box-sizing: border-box;\n        border: none;\n        font-size: 24px;\n        background: black;\n        border-radius: 10px;\n        border: 2px solid #99f3ff;\n        color: white;\n        font-family: 'Orbitron', sans-serif;\n        text-align: center;\n      }\n\n      progress-bar {\n        --progress-bar-color: #99f3ff;\n        height: 10px;\n        position: absolute;\n        margin-top: -10px;\n        border-radius: 0 0 10px 10px;\n      }\n\n      #options {\n        margin-top: 32px;\n        display: flex;\n        flex-wrap: wrap;\n        max-width: 800px;\n        justify-content: center;\n      }\n\n      #options > * {\n        margin: 32px;\n      }\n\n      #options button {\n        display: block;\n        width: 300px;\n        height: 300px;\n        border: 1px solid #99f3ff;\n        color: white;\n        background: none;\n        display: flex;\n        flex-direction: column;\n        font-size: 18px;\n        font-family: 'Orbitron', sans-serif;\n        align-items: center;\n        justify-content: center;\n        cursor: pointer;\n      }\n\n      .loading {\n        box-shadow: #99f3ff 0px 0px 7px 4px;\n        animation: pulse 1s infinite alternate cubic-bezier(0.4, 0, 0.2, 1)\n      }\n\n      @keyframes pulse {\n        from {\n          filter: blur(0px);\n          transform: none;\n        }\n        to {\n          filter: blur(1px);\n          transform: scale(1.05);\n        }\n      }\n\n      #options button i {\n        font-size: 96px;\n      }\n\n      #options button span {\n        margin-top: 24px;\n        max-width: 200px;\n        line-height: 24px;\n      }\n\n      a {\n        text-decoration: none;\n        color: inherit;\n      }\n\n      :focus, #url:focus, #options button:hover {\n        transition: 100ms box-shadow cubic-bezier(0, 0, 0.2, 1);\n        box-shadow: #99f3ff 0px 0px 7px 4px;\n      }\n\n      @media (max-width: 500px) {\n        h1 {\n          font-size: 40px;\n        }\n      }\n    </style>\n  </head>\n  <body>\n    <h1>Rendertron</h1>\n\n    <div id=\"search-bar\">\n      <input id=\"url\" type=\"url\" placeholder=\"Enter a URL\" autocapitalize=\"off\" spellcheck=\"false\">\n      <progress-bar hidden></progress-bar>\n    </div>\n\n    <div id=\"options\">\n      <button onclick=\"takeScreenshot(this)\">\n        <i class=\"material-icons\">photo_camera</i>\n        <span>Take screenshot</span>\n      </button>\n      <button onclick=\"render(this, false)\">\n        <i class=\"material-icons\">cloud_upload</i>\n        <span>Render &amp; serialize</span>\n      </button>\n      <button onclick=\"render(this, true)\">\n        <i class=\"material-icons\">code</i>\n        <span>Render &amp; serialize with web components v1</span>\n      </button>\n      <a href=\"https://github.com/samuelli/bot-render\" target=\"_blank\">\n        <button tabindex=\"-1\">\n          <i class=\"material-icons\">insert_drive_file</i>\n          <span>View documentation</span>\n        </button>\n      </a>\n    </div>\n\n\n\n    <script>\n    function render(element, webcomponents) {\n      if (!url.value)\n        return;\n      element.classList.add('loading');\n      document.querySelector('progress-bar').removeAttribute('hidden');\n      var queryParams = webcomponents ? '?wc-inject-shadydom=true' : '';\n      window.location.href += `render/${url.value.replace('?', '%3F')}${queryParams}`;\n    }\n\n    function takeScreenshot(element) {\n      if (!url.value)\n        return;\n      element.classList.add('loading');\n      document.querySelector('progress-bar').removeAttribute('hidden');\n      window.location.href += `screenshot/${url.value.replace('?', '%3F')}?width=${window.innerWidth}&height=${window.innerHeight}`;\n    }\n    </script>\n\n    <link rel=\"import\" href=\"node_modules/progress-bar-element/progress-bar.html\">\n  </body>\n</html>\n", "'use strict';\n\nconst assert = require('assert');\nconst renderer = require('./renderer');\nconst chromeLauncher = require('chrome-launcher');\nconst express = require('express');\nconst fs = require('fs');\nconst compression = require('compression');\nconst path = require('path');\nconst https = require('https');\nconst app = express();\nconst cache = require('./cache');\nconst now = require('performance-now');\nconst uuidv4 = require('uuid/v4');\n\n// Load config from config.json if it exists.\nlet config = {};\nconst configPath = path.resolve(__dirname, '../config.json');\n\nif (fs.existsSync(configPath)) {\n  config = JSON.parse(fs.readFileSync(configPath));\n  assert(config instanceof Object);\n}\n\n// Only start a cache if configured and not in testing.\nif (!module.parent && !!config['cache']) {\n  app.get('/render/:url(*)', cache.middleware());\n  app.get('/screenshot/:url(*)', cache.middleware());\n  // Always clear the cache for now, while things are changing.\n  cache.clearCache();\n}\n\n// Allows the config to be overriden\napp.setConfig = (newConfig) => {\n  const oldConfig = config;\n  config = newConfig;\n  config.chrome = oldConfig.chrome;\n  config.port = oldConfig.port;\n};\n\napp.use(compression());\n\napp.use('/node_modules', express.static(path.resolve(__dirname, '../node_modules')));\n\napp.get('/', (request, response) => {\n  response.sendFile(path.resolve(__dirname, 'index.html'));\n});\n\nfunction isRestricted(url) {\n  if (!config['renderOnly'])\n    return false;\n  for (let i = 0; i < config['renderOnly'].length; i++) {\n    if (url.startsWith(config['renderOnly'][i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// If configured, report action & time to Google Analytics.\nfunction track(action, time) {\n  if (config['analyticsTrackingId']) {\n    const postOptions = {\n      host: 'www.google-analytics.com',\n      path: '/collect',\n      method: 'POST'\n    };\n\n    const post = https.request(postOptions);\n    post.write(`v=1&t=event&ec=render&ea=${action}&ev=${Math.round(time)}&tid=${config['analyticsTrackingId']}&cid=${uuidv4()}`);\n    post.end();\n  }\n}\n\napp.get('/render/:url(*)', async(request, response) => {\n  if (isRestricted(request.params.url)) {\n    response.status(403).send('Render request forbidden, domain excluded');\n    return;\n  }\n\n  try {\n    const start = now();\n    const result = await renderer.serialize(request.params.url, request.query, config);\n    response.status(result.status).send(result.body);\n    track('render', now() - start);\n  } catch (err) {\n    let message = `Cannot render ${request.params.url}`;\n    if (err && err.message)\n      message += ` - \"${err.message}\"`;\n    response.status(400).send(message);\n  }\n});\n\napp.get('/screenshot/:url(*)', async(request, response) => {\n  if (isRestricted(request.params.url)) {\n    response.status(403).send('Render request forbidden, domain excluded');\n    return;\n  }\n\n  try {\n    const start = now();\n    const result = await renderer.captureScreenshot(request.params.url, request.query, config).catch((err) => console.error(err));\n    const img = new Buffer(result, 'base64');\n    response.set({\n      'Content-Type': 'image/jpeg',\n      'Content-Length': img.length\n    });\n    response.end(img);\n    track('screenshot', now() - start);\n  } catch (err) {\n    let message = `Cannot render ${request.params.url}`;\n    if (err && err.message)\n      message += ` - \"${err.message}\"`;\n    response.status(400).send(message);\n  }\n});\n\napp.get('/_ah/health', (request, response) => response.send('OK'));\n\napp.get('/_ah/stop', async(request, response) => {\n  await config.chrome.kill();\n  response.send('OK');\n});\n\nconst appPromise = chromeLauncher.launch({\n  chromeFlags: ['--headless', '--disable-gpu', '--remote-debugging-address=0.0.0.0'],\n  port: 0\n}).then((chrome) => {\n  console.log('Chrome launched with debugging on port', chrome.port);\n  config.chrome = chrome;\n  config.port = chrome.port;\n  // Don't open a port when running from inside a module (eg. tests). Importing\n  // module can control this.\n  const port = process.env.PORT || '3000';\n  if (!module.parent) {\n    app.listen(port, function() {\n      console.log('Listening on port', port);\n    });\n  }\n  return app;\n}).catch((error) => {\n  console.error(error);\n  // Critical failure, exit with error code.\n  process.exit(1);\n});\n\n\nlet exceptionCount = 0;\nasync function logUncaughtError(error) {\n  console.error('Uncaught exception');\n  console.error(error);\n  exceptionCount++;\n  // Restart instance due to several failures.\n  if (exceptionCount > 5) {\n    console.log(`Detected ${exceptionCount} errors, shutting instance down`);\n    if (config && config.chrome)\n      await config.chrome.kill();\n    process.exit(1);\n  }\n}\n\nif (!module.parent) {\n  process.on('uncaughtException', logUncaughtError);\n  process.on('unhandledRejection', logUncaughtError);\n}\n\nmodule.exports = appPromise;\n", "'use strict';\n\nconst CDP = require('chrome-remote-interface');\n\nclass Renderer {\n  _loadPage(client, url, options, config) {\n    /**\n     * Finds any meta tags setting the status code.\n     * @return {?number} status code\n     */\n    function getStatusCode() {\n      const metaElement = document.querySelector('meta[name=\"render:status_code\"]');\n      if (!metaElement)\n        return undefined;\n      return parseInt(metaElement.getAttribute('content')) || undefined;\n    }\n\n    /**\n     * Listens for the 'render-complete' event.\n     */\n    function listenForCompletionEvent() {\n      document.addEventListener('render-complete', () => {\n        console.log('Rendering complete');\n      });\n    }\n\n    return new Promise(async(resolve, reject) => {\n      const {Page, Runtime, Network, Emulation, Console} = client;\n\n      await Promise.all([\n        Page.enable(),\n        Runtime.enable(),\n        Console.enable(),\n        Network.enable(),\n        Network.setBypassServiceWorker({bypass: true}),\n      ]);\n\n      // Inject the Shady DOM polyfill if web components v1 is used, so we can\n      // serialize the page.\n      // TODO(samli): This needs to change to use the non-deprecated API after Chrome 61\n      //   addScriptToEvaluateOnNewDocument({source: `ShadyDOM = {force: true}`})\n      if (!!options['wc-inject-shadydom']) {\n        // Deprecated in Chrome 61.\n        Page.addScriptToEvaluateOnLoad({scriptSource: `customElements.forcePolyfill = true`});\n        Page.addScriptToEvaluateOnLoad({scriptSource: `ShadyDOM = {force: true}`});\n        Page.addScriptToEvaluateOnLoad({scriptSource: `ShadyCSS = {shimcssproperties: true}`});\n      }\n\n      // Add hook for completion event.\n      Page.addScriptToEvaluateOnLoad({scriptSource: `(${listenForCompletionEvent.toString()})()`});\n\n      if (!!config['debug']) {\n        Console.messageAdded((event) => {\n          console.log(`[${event.message.level}] ${event.message.text}`);\n        });\n      }\n\n      Page.navigate({url: url}).catch(reject);\n\n      // Check that all outstanding network requests have finished loading.\n      const outstandingRequests = new Map();\n      let initialRequestId = undefined;\n      Network.requestWillBeSent((event) => {\n        if (!initialRequestId)\n          initialRequestId = event.requestId;\n        outstandingRequests.set(event.requestId, event);\n      });\n\n      let statusCode = 200;\n      Network.responseReceived((event) => {\n        if (event.requestId == initialRequestId && event.response.status != 0)\n          statusCode = event.response.status;\n      });\n\n      Network.loadingFinished((event) => {\n        outstandingRequests.delete(event.requestId);\n      });\n\n      Network.loadingFailed((event) => {\n        if (event.requestId == initialRequestId) {\n          reject({message: event.errorText});\n        }\n        outstandingRequests.delete(event.requestId);\n      });\n\n      // Ensure the page load event has fired.\n      let pageLoadEventFired = false;\n      Page.loadEventFired(() => {\n        pageLoadEventFired = true;\n      });\n\n      // Set a virtual time budget of 10 seconds. This 10 second timer is paused while there are\n      // any active network requests. This allows for a maximum of 10 seconds in script/rendering\n      // time. Once the page is idle, the virtual time budget expires immediately.\n      let currentTimeBudget = 10000;\n      Emulation.setVirtualTimePolicy({policy: 'pauseIfNetworkFetchesPending', budget: currentTimeBudget});\n\n      let budgetExpired = async() => {\n        let result = await Runtime.evaluate({expression: `(${getStatusCode.toString()})()`});\n        // Original status codes which aren't either 200 or 304 always return with that\n        // status code, regardless of meta tags.\n        if ((statusCode == 200 || statusCode == 304) && result.result.value)\n          statusCode = result.result.value;\n\n        resolve({status: statusCode || 200});\n        budgetExpired = () => {};\n        clearTimeout(timeoutId);\n      };\n\n      Emulation.virtualTimeBudgetExpired((event) => {\n        // Reset the virtual time budget if there is still outstanding work. Converge the virtual time\n        // budget just in case network requests are firing on a regular timer.\n        if (outstandingRequests.size || !pageLoadEventFired) {\n          // Budget must be an integer.\n          currentTimeBudget = Math.ceil(currentTimeBudget / 2);\n          Emulation.setVirtualTimePolicy({policy: 'pauseIfNetworkFetchesPending', budget: currentTimeBudget});\n          return;\n        }\n        budgetExpired();\n      });\n\n      // Set a hard limit of 10 seconds.\n      let timeoutId = setTimeout(() => {\n        console.log(`10 second time budget limit reached.\n          Attempted rendering: ${url}\n          Page load event fired: ${pageLoadEventFired}\n          Outstanding network requests: ${outstandingRequests.size}`);\n        budgetExpired();\n      }, 10000);\n\n      // Listen for the message that signals that rendering event was fired.\n      Console.messageAdded((event) => {\n        if (event.message.text === 'Rendering complete') {\n          budgetExpired();\n        }\n      });\n    });\n  }\n\n  serialize(url, options, config) {\n    /**\n     * Executed on the page after the page has loaded. Strips script and\n     * import tags to prevent further loading of resources.\n     */\n    function stripPage() {\n      const elements = document.querySelectorAll('script, link[rel=import]');\n      elements.forEach((e) => e.remove());\n    }\n\n    /**\n     * Injects a <base> tag which allows other resources to load. This\n     * has no effect on serialised output, but allows it to verify render quality.\n     * @param {string} url - Requested URL to set as the base.\n     */\n    function injectBaseHref(url) {\n      const base = document.createElement('base');\n      base.setAttribute('href', url);\n      document.head.appendChild(base);\n    }\n\n    return new Promise(async(resolve, reject) => {\n      const tab = await CDP.New({port: config.port});\n      const client = await CDP({tab: tab, port: config.port});\n\n      const {Runtime} = client;\n\n      try {\n        let renderResult = await this._loadPage(client, url, options, config);\n\n        await Runtime.evaluate({expression: `(${stripPage.toString()})()`});\n        await Runtime.evaluate({expression: `(${injectBaseHref.toString()})('${url}')`});\n\n        let result = await Runtime.evaluate({expression: 'document.firstElementChild.outerHTML'});\n        CDP.Close({id: client.target.id, port: config.port});\n        resolve({\n          status: renderResult.status,\n          body: result.result.value});\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  captureScreenshot(url, options, config) {\n    return new Promise(async(resolve, reject) => {\n      const tab = await CDP.New({port: config.port});\n      const client = await CDP({tab: tab, port: config.port});\n\n      const {Animation, Page, Emulation} = client;\n\n      // Accelerate global animation timeline so that loading animations\n      // are hopefully complete by the time we take the screenshot.\n      Animation.setPlaybackRate({playbackRate: 1000});\n\n      const width = Math.min(2000, parseInt(options['width']) || 1000);\n      const height = Math.min(2000, parseInt(options['height']) || 1000);\n      await Emulation.setDeviceMetricsOverride({width: width, height: height, mobile: true, deviceScaleFactor: 3.5, fitWindow: false, screenWidth: width, screenHeight: height});\n      await Emulation.setVisibleSize({width: width, height: height});\n\n      try {\n        await this._loadPage(client, url, options, config);\n        let {data} = await Page.captureScreenshot({format: 'jpeg', quality: 60});\n\n        CDP.Close({id: client.target.id, port: config.port});\n        resolve(data);\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n}\n\nmodule.exports = new Renderer();\n", "'use strict';\n\nconst request = require('supertest');\nconst path = require('path');\nconst test = require('ava');\nconst express = require('express');\n\nconst app = express();\napp.use(express.static(path.resolve(__dirname, 'resources')));\nconst testBase = 'http://localhost:1234/';\n\ntest.before(async(t) => {\n  await app.listen(1234);\n});\n\n\n/**\n * This deletes server from the require cache and reloads\n * the server, allowing for a clean state between each test.\n * @param {?Object} config\n * @return {!Object} app server\n */\nasync function createServer(config) {\n  delete require.cache[require.resolve('../src/main.js')];\n  const app = await require('../src/main.js');\n  if (config)\n    app.setConfig(config);\n  return request(app);\n}\n\ntest('health check responds correctly', async(t) => {\n  const server = await createServer();\n  const res = await server.get('/_ah/health');\n  t.is(res.status, 200);\n});\n\ntest('renders basic script', async(t) => {\n  const server = await createServer();\n  const res = await server.get(`/render/${testBase}basic-script.html`);\n  t.is(res.status, 200);\n  t.true(res.text.indexOf('document-title') != -1);\n});\n\ntest('renders script after page load event', async(t) => {\n  const server = await createServer();\n  const res = await server.get(`/render/${testBase}script-after-load.html`);\n  t.is(res.status, 200);\n  t.true(res.text.indexOf('injectedElement') != -1);\n});\n\n// This test is failing as the polyfills (shady polyfill & scoping shim) are not\n// yet injected properly.\ntest.failing('renders shadow DOM - no polyfill', async(t) => {\n  const server = await createServer();\n  const res = await server.get(`/render/${testBase}shadow-dom-no-polyfill.html?wc-inject-shadydom=true`);\n  t.is(res.status, 200);\n  t.true(res.text.indexOf('shadow-root-text') != -1);\n});\n\ntest('renders shadow DOM - polyfill loader', async(t) => {\n  const server = await createServer();\n  const res = await server.get(`/render/${testBase}shadow-dom-polyfill-loader.html?wc-inject-shadydom=true`);\n  t.is(res.status, 200);\n  t.true(res.text.indexOf('shadow-root-text') != -1);\n});\n\ntest('renders shadow DOM - webcomponents-lite.js polyfill', async(t) => {\n  const server = await createServer();\n  const res = await server.get(`/render/${testBase}shadow-dom-polyfill-all.html?wc-inject-shadydom=true`);\n  t.is(res.status, 200);\n  t.true(res.text.indexOf('shadow-root-text') != -1);\n});\n\ntest('script tags and link[rel=import] tags are stripped', async(t) => {\n  const server = await createServer();\n  const res = await server.get(`/render/${testBase}include-script.html`);\n  t.is(res.status, 200);\n  t.false(res.text.indexOf('script src') != -1);\n  t.true(res.text.indexOf('injectedElement') != -1);\n  t.false(res.text.indexOf('link rel') != -1);\n  t.true(res.text.indexOf('element-text') != -1);\n});\n\ntest('server status code should be forwarded', async(t) => {\n  const server = await createServer();\n  const res = await server.get('/render/http://httpstat.us/404');\n  t.is(res.status, 404);\n  t.true(res.text.indexOf('404 Not Found') != -1);\n});\n\ntest('http status code should be able to be set via a meta tag', async(t) => {\n  const server = await createServer();\n  const testFile = path.resolve(__dirname, 'resources/http-meta-status-code.html');\n  const res = await server.get('/render/file://' + testFile + '?wc-inject-shadydom=true');\n  t.is(res.status, 400);\n});\n\ntest('http status codes need to be respected from top to bottom', async(t) => {\n  const server = await createServer();\n  const testFile = path.resolve(__dirname, 'resources/http-meta-status-code-multiple.html');\n  const res = await server.get('/render/file://' + testFile + '?wc-inject-shadydom=true');\n  t.is(res.status, 401);\n});\n\ntest('screenshot is an image', async(t) => {\n  const server = await createServer();\n  const res = await server.get(`/screenshot/${testBase}basic-script.html`);\n  t.is(res.status, 200);\n  t.is(res.header['content-type'], 'image/jpeg');\n  t.is(res.body.length, parseInt(res.header['content-length']));\n});\n\ntest('invalid url fails', async(t) => {\n  const server = await createServer();\n  const res = await server.get(`/render/abc`);\n  t.is(res.status, 400);\n});\n\ntest('unknown url fails', async(t) => {\n  const server = await createServer();\n  const res = await server.get(`/render/http://unknown.blah.com`);\n  t.is(res.status, 400);\n});\n\ntest('explicit render event ends early', async(t) => {\n  const server = await createServer();\n  const res = await server.get(`/render/${testBase}explicit-render-event.html`);\n  t.is(res.status, 200);\n  t.true(res.text.indexOf('async loaded') != -1);\n});\n\ntest('whitelist ensures other urls do not get rendered', async(t) => {\n  const server = await createServer({\n    renderOnly: [testBase]\n  });\n  let res = await server.get(`/render/${testBase}basic-script.html`);\n  t.is(res.status, 200);\n\n  res = await server.get(`/render/http://anotherDomain.com`);\n  t.is(res.status, 403);\n});\n", "'use strict';\n\nconst test = require('ava');\nconst request = require('supertest');\nconst express = require('express');\nconst compression = require('compression');\nconst cache = require('../src/cache.js');\n\nconst app = express();\nconst server = request(app);\n\napp.use(cache.middleware());\n\nlet handlerCalledCount = 0;\n\ntest.before(async(t) => {\n  await cache.clearCache();\n});\n\napp.get('/', (request, response) => {\n  handlerCalledCount++;\n  response.end('Called ' + handlerCalledCount + ' times');\n});\n\ntest('caches content and serves same content on cache hit', async(t) => {\n  let res = await server.get('/?basictest');\n  const previousCount = handlerCalledCount;\n  t.is(res.status, 200);\n  t.is(res.text, 'Called ' + previousCount + ' times');\n\n  res = await server.get('/?basictest');\n  t.is(res.status, 200);\n  t.is(res.text, 'Called ' + previousCount + ' times');\n\n  res = await server.get('/?basictest');\n  t.is(res.status, 200);\n  t.is(res.text, 'Called ' + previousCount + ' times');\n\n  res = await server.get('/?basictest2');\n  t.is(res.status, 200);\n  t.is(res.text, 'Called ' + (previousCount + 1) + ' times');\n});\n\napp.get('/set-header', (request, response) => {\n  response.set('my-header', 'header-value');\n  response.end('set-header-payload');\n});\n\ntest('caches headers', async(t) => {\n  let res = await server.get('/set-header');\n  t.is(res.status, 200);\n  t.is(res.header['my-header'], 'header-value');\n  t.is(res.text, 'set-header-payload');\n\n  res = await server.get('/set-header');\n  t.is(res.status, 200);\n  t.is(res.header['my-header'], 'header-value');\n  t.is(res.text, 'set-header-payload');\n});\n\napp.use('/compressed', compression());\napp.get('/compressed', (request, response) => {\n  response.set('Content-Type', 'text/html');\n  response.send(new Array(1025).join('x'));\n});\n\ntest('compression preserved', async(t) => {\n  const expectedBody = new Array(1025).join('x');\n  let res = await server.get('/compressed').set('Accept-Encoding', 'gzip, deflate, br');\n  t.is(res.status, 200);\n  t.is(res.header['content-encoding'], 'gzip');\n  t.is(res.text, expectedBody);\n\n  res = await server.get('/compressed').set('Accept-Encoding', 'gzip, deflate, br');\n  t.is(res.status, 200);\n  t.is(res.header['content-encoding'], 'gzip');\n  t.is(res.text, expectedBody);\n});\n\nlet statusCallCount = 0;\napp.get('/status/:status', (request, response) => {\n  // Every second call sends a different status.\n  if (statusCallCount % 2 == 0) {\n    response.sendStatus(request.params.status);\n  } else {\n    response.sendStatus(456);\n  }\n  statusCallCount++;\n});\n\ntest('original status is preserved', async(t) => {\n  let res = await server.get('/status/123');\n  t.is(res.status, 123);\n\n  // Non 200 status code should not be cached.\n  res = await server.get('/status/123');\n  t.is(res.status, 456);\n});\n", "<script>\n  var element = document.createElement('title');\n  element.textContent = 'document' + '-title';\n  document.head.appendChild(element);\n</script>\n", "<script>\n  class MyElement extends HTMLElement {\n    constructor() {\n      super();\n\n      this.innerHTML = '<div>element-' + 'text</div>';\n    }\n  }\n  customElements.define('custom-element', MyElement);\n</script>\n", "<script>\n  setTimeout(() => {\n    document.body.textContent = 'async loaded';\n    document.body.dispatchEvent(new Event('render-complete', { bubbles: true, composed: true}));\n  }, 5000);\n  setTimeout(() => {\n    document.body.textContent = 'should not be reached';\n  }, 10000);\n</script>\n", "<meta name=\"render:status_code\" content=\"401\">\n<meta name=\"render:status_code\" content=\"402\">", "<meta name=\"render:status_code\" content=\"400\">", "<script src=\"inject-element-after-load.js\"></script>\n<link rel=\"import\" href=\"custom-element.html\">\n<custom-element></custom-element>\n", "window.onload = function() {\n  var element = document.createElement('div');\n  element.textContent = 'injected' + 'Element';\n  document.body.appendChild(element);\n}\n", "var element = document.createElement('div');\nelement.textContent = 'injectedElement';\ndocument.body.appendChild(element);", "<script>\nwindow.onload = function() {\n  var script = document.createElement('script');\n  script.src = 'inject-element.js';\n  document.body.appendChild(script);\n}\n</script>\n", "<my-element></my-element>\n<script>\n  class MyElement extends HTMLElement {\n    constructor() {\n      super();\n\n      const shadowRoot = this.attachShadow({mode: 'open'});\n      shadowRoot.innerHTML = 'shadow-root' + '-text';\n    }\n  }\n  customElements.define('my-element', MyElement);\n</script>\n", "<script src=\"node_modules/@webcomponents/webcomponentsjs/webcomponents-lite.js\"></script>\n<my-element></my-element>\n<script>\n  class MyElement extends HTMLElement {\n    constructor() {\n      super();\n\n      const shadowRoot = this.attachShadow({mode: 'open'});\n      shadowRoot.innerHTML = 'shadow-root' + '-text';\n    }\n  }\n  customElements.define('my-element', MyElement);\n</script>\n", "<script src=\"node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js\"></script>\n<my-element></my-element>\n<script>\n  class MyElement extends HTMLElement {\n    constructor() {\n      super();\n\n      const shadowRoot = this.attachShadow({mode: 'open'});\n      shadowRoot.innerHTML = 'shadow-root' + '-text';\n    }\n  }\n  customElements.define('my-element', MyElement);\n</script>\n"], "fixing_code": ["/*\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\n'use strict';\n\nconst request = require('request');\n\n/**\n * A default set of user agent patterns for bots/crawlers that do not perform\n * well with pages that require JavaScript.\n */\nconst botUserAgents = module.exports.botUserAgents = [\n  'W3C_Validator',\n  'baiduspider',\n  'bingbot',\n  'embedly',\n  'facebookexternalhit',\n  'linkedinbo',\n  'outbrain',\n  'pinterest',\n  'quora link preview',\n  'rogerbo',\n  'showyoubot',\n  'slackbot',\n  'twitterbot',\n  'vkShare',\n];\n\n/* eslint-disable no-multi-spaces */\n\n/**\n * A default set of file extensions for static assets that do not need to be\n * proxied.\n */\nconst staticFileExtensions = [\n  'ai',  'avi',  'css', 'dat',  'dmg', 'doc',     'doc',  'exe', 'flv',\n  'gif', 'ico',  'iso', 'jpeg', 'jpg', 'js',      'less', 'm4a', 'm4v',\n  'mov', 'mp3',  'mp4', 'mpeg', 'mpg', 'pdf',     'png',  'ppt', 'psd',\n  'rar', 'rss',  'svg', 'swf',  'tif', 'torrent', 'ttf',  'txt', 'wav',\n  'wmv', 'woff', 'xls', 'xml',  'zip',\n];\n\n/* eslint-enable no-multi-spaces */\n\n/**\n * @return {!Object} A new Express middleware function that proxies requests to\n * a Rendertron bot rendering service. Options:\n *\n * @param {!Object} options Configuration object with the following properties:\n * - proxyUrl: Base URL of the Rendertron proxy service. Required.\n * - userAgentPattern: Regular expression to match user agent to proxy.\n *   Defaults to a set of bots that do not perform well with pages that require\n *   JavaScript.\n * - excludeUrlPattern: Regular expression used to exclude request URL paths.\n *   Defaults to a set of typical static asset file extensions.\n * - injectShadyDom: Force web components polyfills to be loaded and enabled.\n * - timeout: Millisecond timeout for proxy requests.\n */\nmodule.exports.makeMiddleware = function(options) {\n  if (!options || !options.proxyUrl) {\n    throw new Error('Must set options.proxyUrl.');\n  }\n  let proxyUrl = options.proxyUrl;\n  if (!proxyUrl.endsWith('/')) {\n    proxyUrl += '/';\n  }\n  const userAgentPattern =\n      options.userAgentPattern || new RegExp(botUserAgents.join('|'), 'i');\n  const excludeUrlPattern = options.excludeUrlPattern ||\n      new RegExp(`\\\\.(${staticFileExtensions.join('|')})$`, 'i');\n  const injectShadyDom = !!options.injectShadyDom;\n  // The Rendertron service itself has a hard limit of 10 seconds to render, so\n  // let's give a little more time than that by default.\n  const timeout = options.timeout || 11000; // Milliseconds.\n\n  return function rendertronMiddleware(req, res, next) {\n    if (!userAgentPattern.test(req.headers['user-agent']) ||\n        excludeUrlPattern.test(req.path)) {\n      next();\n      return;\n    }\n    const incomingUrl =\n        req.protocol + '://' + req.get('host') + req.originalUrl;\n    let renderUrl = proxyUrl + encodeURIComponent(incomingUrl);\n    if (injectShadyDom) {\n      renderUrl += '?wc-inject-shadydom';\n    }\n    request({url: renderUrl, timeout}, (e) => {\n      if (e) {\n        console.error(\n            `[rendertron middleware] ${e.code} error fetching ${renderUrl}`);\n        next();\n      }\n    }).pipe(res);\n  };\n};\n", "/*\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\n'use strict';\n\nconst express = require('express');\nconst supertest = require('supertest');\nconst test = require('ava');\n\nconst rendertron = require('../src/middleware');\n\n/**\n * Start the given Express app on localhost with a random port.\n * @param {!Object} app The app.\n * @return {Promise<string>}Promise of the URL.\n */\nasync function listen(app) {\n  return new Promise((resolve) => {\n    const server = app.listen(/* random */ 0, 'localhost', () => {\n      resolve(`http://localhost:${server.address().port}`);\n    });\n  });\n}\n\n/**\n * Make an Express app that uses the Rendertron middleware and returns\n * \"fallthrough\" if the middleware skipped the request (i.e. called `next`).\n * @param {Object} options Rendertron middleware options.\n * @return {!Object} The app.\n */\nfunction makeApp(options) {\n  return express()\n      .use(rendertron.makeMiddleware(options))\n      .use((req, res) => res.end('fallthrough'));\n}\n\n/**\n * Make an Express app that takes the place of a Rendertron server instance and\n * always responds with \"proxy <decoded url>\".\n * @return {!Object} The app.\n */\nfunction makeProxy() {\n  return express().use((req, res) => {\n    res.end('proxy ' + decodeURIComponent(req.url.substring(1)));\n  });\n}\n\nconst bot = 'slackbot';\nconst human = 'Chrome';\n\n/**\n * GET a URL with the given user agent.\n * @param {string} userAgent The user agent string.\n * @param {string} host The host part of the URL.\n * @param {string} path The path part of the URL.\n * @return {Promise<!Object>} Promise of the GET response.\n */\nasync function get(userAgent, host, path) {\n  return await supertest(host).get(path).set('User-Agent', userAgent);\n}\n\ntest('makes a middleware function', async (t) => {\n  const m = rendertron.makeMiddleware({proxyUrl: 'http://example.com'});\n  t.truthy(m);\n});\n\ntest('throws if no proxyUrl given', async (t) => {\n  t.throws(() => rendertron.makeMiddleware());\n  t.throws(() => rendertron.makeMiddleware({}));\n  t.throws(() => rendertron.makeMiddleware({proxyUrl: ''}));\n});\n\ntest('proxies through given url', async (t) => {\n  const proxyUrl = await listen(makeProxy());\n  const appUrl = await listen(makeApp({proxyUrl}));\n\n  const res = await get(bot, appUrl, '/foo');\n  t.is(res.status, 200);\n  t.is(res.text, 'proxy ' + appUrl + '/foo');\n});\n\ntest('proxyUrl can have trailing slash', async (t) => {\n  const proxyUrl = await listen(makeProxy());\n  // Make sure our other tests are testing the no-trailing-slash case.\n  t.false(proxyUrl.endsWith('/'));\n  const appUrl = await listen(makeApp({proxyUrl: proxyUrl + '/'}));\n\n  const res = await get(bot, appUrl, '/foo');\n  t.is(res.status, 200);\n  t.is(res.text, 'proxy ' + appUrl + '/foo');\n});\n\ntest('adds shady dom parameter', async (t) => {\n  const proxyUrl = await listen(makeProxy());\n  const appUrl = await listen(makeApp({proxyUrl, injectShadyDom: true}));\n\n  const res = await get(bot, appUrl, '/foo');\n  t.is(res.status, 200);\n  t.is(res.text, 'proxy ' + appUrl + '/foo?wc-inject-shadydom');\n});\n\ntest('excludes static file paths by default', async (t) => {\n  const proxyUrl = await listen(makeProxy());\n  const appUrl = await listen(makeApp({proxyUrl}));\n\n  const res = await get(bot, appUrl, '/foo.png');\n  t.is(res.text, 'fallthrough');\n});\n\ntest('url exclusion only matches url path component', async (t) => {\n  const proxyUrl = await listen(makeProxy());\n  const appUrl = await listen(makeApp({proxyUrl}));\n\n  const res = await get(bot, appUrl, '/foo.png?params');\n  t.is(res.text, 'fallthrough');\n});\n\ntest('excludes non-bot user agents by default', async (t) => {\n  const proxyUrl = await listen(makeProxy());\n  const appUrl = await listen(makeApp({proxyUrl}));\n\n  const res = await get(human, appUrl, '/foo');\n  t.is(res.text, 'fallthrough');\n});\n\ntest('respects custom user agent pattern', async (t) => {\n  const proxyUrl = await listen(makeProxy());\n  const appUrl = await listen(makeApp({proxyUrl, userAgentPattern: /borg/}));\n\n  let res;\n\n  res = await get('humon', appUrl, '/foo');\n  t.is(res.text, 'fallthrough');\n\n  res = await get('borg', appUrl, '/foo');\n  t.is(res.text, 'proxy ' + appUrl + '/foo');\n});\n\ntest('respects custom exclude url pattern', async (t) => {\n  const proxyUrl = await listen(makeProxy());\n  const appUrl = await listen(makeApp({proxyUrl, excludeUrlPattern: /foo/}));\n\n  let res;\n\n  res = await get(bot, appUrl, '/foo');\n  t.is(res.text, 'fallthrough');\n\n  res = await get(bot, appUrl, '/bar');\n  t.is(res.text, 'proxy ' + appUrl + '/bar');\n});\n\ntest('forwards proxy error status and body', async (t) => {\n  // This proxy always returns an error.\n  const proxyUrl = await listen(\n      express().use((req, res) => res.status(500).end('proxy error')));\n  const appUrl = await listen(makeApp({proxyUrl}));\n\n  const res = await get(bot, appUrl, '/bar');\n  t.is(res.status, 500);\n  t.is(res.text, 'proxy error');\n});\n\ntest('falls through after timeout', async (t) => {\n  // This proxy returns after 20ms, but our timeout is 10ms.\n  const proxyUrl = await listen(express().use((req, res) => {\n    setTimeout(() => res.end('too slow'), 20);\n  }));\n  const appUrl = await listen(makeApp({proxyUrl, timeout: 10}));\n\n  const res = await get(bot, appUrl, '/foo');\n  t.is(res.text, 'fallthrough');\n});\n", "/*\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\n'use strict';\n\nconst datastore = require('@google-cloud/datastore')();\n\nclass Cache {\n  async clearCache() {\n    const query = datastore.createQuery('Page');\n    const data = await datastore.runQuery(query);\n    const entities = data[0];\n    const entityKeys = entities.map((entity) => entity[datastore.KEY]);\n    console.log(`Removing ${entities.length} items from the cache`);\n    await datastore.delete(entityKeys);\n    // TODO(samli): check info (data[1]) and loop through pages of entities to delete.\n  }\n\n  async cacheContent(key, headers, payload) {\n    // Set cache length to 1 day.\n    const cacheDurationMinutes = 60*24;\n    const now = new Date();\n    const entity = {\n      key: key,\n      data: [\n        {name: 'saved', value: now},\n        {name: 'expires', value: new Date(now.getTime() + cacheDurationMinutes*60*1000)},\n        {name: 'headers', value: JSON.stringify(headers), excludeFromIndexes: true},\n        {name: 'payload', value: JSON.stringify(payload), excludeFromIndexes: true},\n      ]\n    };\n    await datastore.save(entity);\n  }\n\n  /**\n   * Returns middleware function.\n   * @return {function}\n   */\n  middleware() {\n    return async function(request, response, next) {\n      function accumulateContent(content) {\n        if (typeof(content) === 'string') {\n          body = body || '' + content;\n        } else if (Buffer.isBuffer(content)) {\n          if (!body)\n            body = new Buffer(0);\n          body = Buffer.concat([body, content], body.length + content.length);\n        }\n      }\n\n      // Cache based on full URL. This means requests with different params are\n      // cached separately.\n      const key = datastore.key(['Page', request.url]);\n      const results = await datastore.get(key);\n\n      if (results.length && results[0] != undefined) {\n        // Serve cached content if its not expired.\n        if (results[0].expires.getTime() >= new Date().getTime()) {\n          const headers = JSON.parse(results[0].headers);\n          response.set(headers);\n          let payload = JSON.parse(results[0].payload);\n          if (typeof(payload) == 'object' && payload.type == 'Buffer')\n            payload = new Buffer(payload);\n          response.send(payload);\n          return;\n        }\n      }\n\n      // Capture output to cache.\n      const methods = {\n        write: response.write,\n        end: response.end,\n      };\n      let body = null;\n\n      response.write = function(content, ...args) {\n        accumulateContent(content);\n        return methods.write.apply(response, [content].concat(args));\n      };\n\n      response.end = async function(content, ...args) {\n        if (response.statusCode == 200) {\n          accumulateContent(content);\n          await this.cacheContent(key, response.getHeaders(), body);\n        }\n        return methods.end.apply(response, [content].concat(args));\n      }.bind(this);\n\n      next();\n    }.bind(this);\n  }\n}\n\n// TODO(samli): Allow for caching options, like freshness options.\nmodule.exports = new Cache();\n", "<!--\nCopyright 2017 Google Inc. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not\nuse this file except in compliance with the License. You may obtain a copy of\nthe License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\nWARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\nLicense for the specific language governing permissions and limitations under\nthe License.\n-->\n<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes\">\n\n    <title>Rendertron</title>\n    <meta name=\"description\" content=\"Rendertron - headless rendering service\">\n\n    <link href=\"https://fonts.googleapis.com/css?family=Orbitron\" rel=\"stylesheet\">\n    <link href=\"https://fonts.googleapis.com/icon?family=Material+Icons\" rel=\"stylesheet\">\n\n    <script>\n      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\n      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\n      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\n\n      ga('create', 'UA-104508854-1', 'auto');\n      ga('send', 'pageview');\n    </script>\n\n    <style>\n      body {\n        background: black;\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        justify-content: center;\n        font-family: 'Orbitron', sans-serif;\n        margin: 0;\n        min-height: calc(100vh - 40px);\n        padding: 20px 0;\n      }\n\n      h1 {\n        font-size: 60px;\n        color: white;\n        border-bottom: 1px solid #99f3ff;\n        margin: 64px 32px;\n      }\n\n      #search-bar {\n        min-width: 300px;\n        width: calc(100% - 40px);\n        max-width: 664px;\n        position: relative;\n        box-sizing: border-box;\n      }\n\n      input[type=url] {\n        width: 100%;\n        padding: 30px;\n        box-sizing: border-box;\n        border: none;\n        font-size: 24px;\n        background: black;\n        border-radius: 10px;\n        border: 2px solid #99f3ff;\n        color: white;\n        font-family: 'Orbitron', sans-serif;\n        text-align: center;\n      }\n\n      progress-bar {\n        --progress-bar-color: #99f3ff;\n        height: 10px;\n        position: absolute;\n        margin-top: -10px;\n        border-radius: 0 0 10px 10px;\n      }\n\n      #options {\n        margin-top: 32px;\n        display: flex;\n        flex-wrap: wrap;\n        max-width: 800px;\n        justify-content: center;\n      }\n\n      #options > * {\n        margin: 32px;\n      }\n\n      #options button {\n        display: block;\n        width: 300px;\n        height: 300px;\n        border: 1px solid #99f3ff;\n        color: white;\n        background: none;\n        display: flex;\n        flex-direction: column;\n        font-size: 18px;\n        font-family: 'Orbitron', sans-serif;\n        align-items: center;\n        justify-content: center;\n        cursor: pointer;\n      }\n\n      .loading {\n        box-shadow: #99f3ff 0px 0px 7px 4px;\n        animation: pulse 1s infinite alternate cubic-bezier(0.4, 0, 0.2, 1)\n      }\n\n      @keyframes pulse {\n        from {\n          filter: blur(0px);\n          transform: none;\n        }\n        to {\n          filter: blur(1px);\n          transform: scale(1.05);\n        }\n      }\n\n      #options button i {\n        font-size: 96px;\n      }\n\n      #options button span {\n        margin-top: 24px;\n        max-width: 200px;\n        line-height: 24px;\n      }\n\n      a {\n        text-decoration: none;\n        color: inherit;\n      }\n\n      :focus, #url:focus, #options button:hover {\n        transition: 100ms box-shadow cubic-bezier(0, 0, 0.2, 1);\n        box-shadow: #99f3ff 0px 0px 7px 4px;\n      }\n\n      @media (max-width: 500px) {\n        h1 {\n          font-size: 40px;\n        }\n      }\n    </style>\n  </head>\n  <body>\n    <h1>Rendertron</h1>\n\n    <div id=\"search-bar\">\n      <input id=\"url\" type=\"url\" placeholder=\"Enter a URL\" autocapitalize=\"off\" spellcheck=\"false\">\n      <progress-bar hidden></progress-bar>\n    </div>\n\n    <div id=\"options\">\n      <button onclick=\"takeScreenshot(this)\">\n        <i class=\"material-icons\">photo_camera</i>\n        <span>Take screenshot</span>\n      </button>\n      <button onclick=\"render(this, false)\">\n        <i class=\"material-icons\">cloud_upload</i>\n        <span>Render &amp; serialize</span>\n      </button>\n      <button onclick=\"render(this, true)\">\n        <i class=\"material-icons\">code</i>\n        <span>Render &amp; serialize with web components v1</span>\n      </button>\n      <a href=\"https://github.com/samuelli/bot-render\" target=\"_blank\">\n        <button tabindex=\"-1\">\n          <i class=\"material-icons\">insert_drive_file</i>\n          <span>View documentation</span>\n        </button>\n      </a>\n    </div>\n\n\n\n    <script>\n    function render(element, webcomponents) {\n      if (!url.value)\n        return;\n      element.classList.add('loading');\n      document.querySelector('progress-bar').removeAttribute('hidden');\n      var queryParams = webcomponents ? '?wc-inject-shadydom=true' : '';\n      window.location.href += `render/${url.value.replace('?', '%3F')}${queryParams}`;\n    }\n\n    function takeScreenshot(element) {\n      if (!url.value)\n        return;\n      element.classList.add('loading');\n      document.querySelector('progress-bar').removeAttribute('hidden');\n      window.location.href += `screenshot/${url.value.replace('?', '%3F')}?width=${window.innerWidth}&height=${window.innerHeight}`;\n    }\n    </script>\n\n    <link rel=\"import\" href=\"node_modules/progress-bar-element/progress-bar.html\">\n  </body>\n</html>\n", "/*\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst renderer = require('./renderer');\nconst chromeLauncher = require('chrome-launcher');\nconst express = require('express');\nconst fs = require('fs');\nconst compression = require('compression');\nconst path = require('path');\nconst https = require('https');\nconst app = express();\nconst cache = require('./cache');\nconst now = require('performance-now');\nconst uuidv4 = require('uuid/v4');\n\n// Load config from config.json if it exists.\nlet config = {};\nconst configPath = path.resolve(__dirname, '../config.json');\n\nif (fs.existsSync(configPath)) {\n  config = JSON.parse(fs.readFileSync(configPath));\n  assert(config instanceof Object);\n}\n\n// Only start a cache if configured and not in testing.\nif (!module.parent && !!config['cache']) {\n  app.get('/render/:url(*)', cache.middleware());\n  app.get('/screenshot/:url(*)', cache.middleware());\n  // Always clear the cache for now, while things are changing.\n  cache.clearCache();\n}\n\n// Allows the config to be overriden\napp.setConfig = (newConfig) => {\n  const oldConfig = config;\n  config = newConfig;\n  config.chrome = oldConfig.chrome;\n  config.port = oldConfig.port;\n};\n\napp.use(compression());\n\napp.use('/node_modules', express.static(path.resolve(__dirname, '../node_modules')));\n\napp.get('/', (request, response) => {\n  response.sendFile(path.resolve(__dirname, 'index.html'));\n});\n\nfunction isRestricted(url) {\n  if (!config['renderOnly'])\n    return false;\n  for (let i = 0; i < config['renderOnly'].length; i++) {\n    if (url.startsWith(config['renderOnly'][i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// If configured, report action & time to Google Analytics.\nfunction track(action, time) {\n  if (config['analyticsTrackingId']) {\n    const postOptions = {\n      host: 'www.google-analytics.com',\n      path: '/collect',\n      method: 'POST'\n    };\n\n    const post = https.request(postOptions);\n    post.write(`v=1&t=event&ec=render&ea=${action}&ev=${Math.round(time)}&tid=${config['analyticsTrackingId']}&cid=${uuidv4()}`);\n    post.end();\n  }\n}\n\napp.get('/render/:url(*)', async(request, response) => {\n  if (isRestricted(request.params.url)) {\n    response.status(403).send('Render request forbidden, domain excluded');\n    return;\n  }\n\n  try {\n    const start = now();\n    const result = await renderer.serialize(request.params.url, request.query, config);\n    response.status(result.status).send(result.body);\n    track('render', now() - start);\n  } catch (err) {\n    let message = `Cannot render ${request.params.url}`;\n    if (err && err.message)\n      message += ` - \"${err.message}\"`;\n    response.status(400).send(message);\n  }\n});\n\napp.get('/screenshot/:url(*)', async(request, response) => {\n  if (isRestricted(request.params.url)) {\n    response.status(403).send('Render request forbidden, domain excluded');\n    return;\n  }\n\n  try {\n    const start = now();\n    const result = await renderer.captureScreenshot(request.params.url, request.query, config).catch((err) => console.error(err));\n    const img = new Buffer(result, 'base64');\n    response.set({\n      'Content-Type': 'image/jpeg',\n      'Content-Length': img.length\n    });\n    response.end(img);\n    track('screenshot', now() - start);\n  } catch (err) {\n    let message = `Cannot render ${request.params.url}`;\n    if (err && err.message)\n      message += ` - \"${err.message}\"`;\n    response.status(400).send(message);\n  }\n});\n\napp.get('/_ah/health', (request, response) => response.send('OK'));\n\napp.get('/_ah/stop', async(request, response) => {\n  await config.chrome.kill();\n  response.send('OK');\n});\n\nconst appPromise = chromeLauncher.launch({\n  chromeFlags: ['--headless', '--disable-gpu', '--remote-debugging-address=0.0.0.0'],\n  port: 0\n}).then((chrome) => {\n  console.log('Chrome launched with debugging on port', chrome.port);\n  config.chrome = chrome;\n  config.port = chrome.port;\n  // Don't open a port when running from inside a module (eg. tests). Importing\n  // module can control this.\n  const port = process.env.PORT || '3000';\n  if (!module.parent) {\n    app.listen(port, function() {\n      console.log('Listening on port', port);\n    });\n  }\n  return app;\n}).catch((error) => {\n  console.error(error);\n  // Critical failure, exit with error code.\n  process.exit(1);\n});\n\n\nlet exceptionCount = 0;\nasync function logUncaughtError(error) {\n  console.error('Uncaught exception');\n  console.error(error);\n  exceptionCount++;\n  // Restart instance due to several failures.\n  if (exceptionCount > 5) {\n    console.log(`Detected ${exceptionCount} errors, shutting instance down`);\n    if (config && config.chrome)\n      await config.chrome.kill();\n    process.exit(1);\n  }\n}\n\nif (!module.parent) {\n  process.on('uncaughtException', logUncaughtError);\n  process.on('unhandledRejection', logUncaughtError);\n}\n\nmodule.exports = appPromise;\n", "/*\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\n'use strict';\n\nconst CDP = require('chrome-remote-interface');\n\nclass Renderer {\n  _loadPage(client, url, options, config) {\n    /**\n     * Finds any meta tags setting the status code.\n     * @return {?number} status code\n     */\n    function getStatusCode() {\n      const metaElement = document.querySelector('meta[name=\"render:status_code\"]');\n      if (!metaElement)\n        return undefined;\n      return parseInt(metaElement.getAttribute('content')) || undefined;\n    }\n\n    /**\n     * Listens for the 'render-complete' event.\n     */\n    function listenForCompletionEvent() {\n      document.addEventListener('render-complete', () => {\n        console.log('Rendering complete');\n      });\n    }\n\n    return new Promise(async(resolve, reject) => {\n      const {Page, Runtime, Network, Emulation, Console} = client;\n\n      await Promise.all([\n        Page.enable(),\n        Runtime.enable(),\n        Console.enable(),\n        Network.enable(),\n        Network.setBypassServiceWorker({bypass: true}),\n      ]);\n\n      // Inject the Shady DOM polyfill if web components v1 is used, so we can\n      // serialize the page.\n      // TODO(samli): This needs to change to use the non-deprecated API after Chrome 61\n      //   addScriptToEvaluateOnNewDocument({source: `ShadyDOM = {force: true}`})\n      if (!!options['wc-inject-shadydom']) {\n        // Deprecated in Chrome 61.\n        Page.addScriptToEvaluateOnLoad({scriptSource: `customElements.forcePolyfill = true`});\n        Page.addScriptToEvaluateOnLoad({scriptSource: `ShadyDOM = {force: true}`});\n        Page.addScriptToEvaluateOnLoad({scriptSource: `ShadyCSS = {shimcssproperties: true}`});\n      }\n\n      // Add hook for completion event.\n      Page.addScriptToEvaluateOnLoad({scriptSource: `(${listenForCompletionEvent.toString()})()`});\n\n      if (!!config['debug']) {\n        Console.messageAdded((event) => {\n          console.log(`[${event.message.level}] ${event.message.text}`);\n        });\n      }\n\n      Page.navigate({url: url}).catch(reject);\n\n      // Check that all outstanding network requests have finished loading.\n      const outstandingRequests = new Map();\n      let initialRequestId = undefined;\n      Network.requestWillBeSent((event) => {\n        if (!initialRequestId)\n          initialRequestId = event.requestId;\n        outstandingRequests.set(event.requestId, event);\n      });\n\n      let statusCode = 200;\n      Network.responseReceived((event) => {\n        if (event.requestId == initialRequestId && event.response.status != 0)\n          statusCode = event.response.status;\n      });\n\n      Network.loadingFinished((event) => {\n        outstandingRequests.delete(event.requestId);\n      });\n\n      Network.loadingFailed((event) => {\n        if (event.requestId == initialRequestId) {\n          reject({message: event.errorText});\n        }\n        outstandingRequests.delete(event.requestId);\n      });\n\n      // Ensure the page load event has fired.\n      let pageLoadEventFired = false;\n      Page.loadEventFired(() => {\n        pageLoadEventFired = true;\n      });\n\n      // Set a virtual time budget of 10 seconds. This 10 second timer is paused while there are\n      // any active network requests. This allows for a maximum of 10 seconds in script/rendering\n      // time. Once the page is idle, the virtual time budget expires immediately.\n      let currentTimeBudget = 10000;\n      Emulation.setVirtualTimePolicy({policy: 'pauseIfNetworkFetchesPending', budget: currentTimeBudget});\n\n      let budgetExpired = async() => {\n        let result = await Runtime.evaluate({expression: `(${getStatusCode.toString()})()`});\n        // Original status codes which aren't either 200 or 304 always return with that\n        // status code, regardless of meta tags.\n        if ((statusCode == 200 || statusCode == 304) && result.result.value)\n          statusCode = result.result.value;\n\n        resolve({status: statusCode || 200});\n        budgetExpired = () => {};\n        clearTimeout(timeoutId);\n      };\n\n      Emulation.virtualTimeBudgetExpired((event) => {\n        // Reset the virtual time budget if there is still outstanding work. Converge the virtual time\n        // budget just in case network requests are firing on a regular timer.\n        if (outstandingRequests.size || !pageLoadEventFired) {\n          // Budget must be an integer.\n          currentTimeBudget = Math.ceil(currentTimeBudget / 2);\n          Emulation.setVirtualTimePolicy({policy: 'pauseIfNetworkFetchesPending', budget: currentTimeBudget});\n          return;\n        }\n        budgetExpired();\n      });\n\n      // Set a hard limit of 10 seconds.\n      let timeoutId = setTimeout(() => {\n        console.log(`10 second time budget limit reached.\n          Attempted rendering: ${url}\n          Page load event fired: ${pageLoadEventFired}\n          Outstanding network requests: ${outstandingRequests.size}`);\n        budgetExpired();\n      }, 10000);\n\n      // Listen for the message that signals that rendering event was fired.\n      Console.messageAdded((event) => {\n        if (event.message.text === 'Rendering complete') {\n          budgetExpired();\n        }\n      });\n    });\n  }\n\n  serialize(url, options, config) {\n    /**\n     * Executed on the page after the page has loaded. Strips script and\n     * import tags to prevent further loading of resources.\n     */\n    function stripPage() {\n      const elements = document.querySelectorAll('script, link[rel=import]');\n      elements.forEach((e) => e.remove());\n    }\n\n    /**\n     * Injects a <base> tag which allows other resources to load. This\n     * has no effect on serialised output, but allows it to verify render quality.\n     * @param {string} url - Requested URL to set as the base.\n     */\n    function injectBaseHref(url) {\n      const base = document.createElement('base');\n      base.setAttribute('href', url);\n      document.head.appendChild(base);\n    }\n\n    return new Promise(async(resolve, reject) => {\n      const tab = await CDP.New({port: config.port});\n      const client = await CDP({tab: tab, port: config.port});\n\n      const {Runtime} = client;\n\n      try {\n        let renderResult = await this._loadPage(client, url, options, config);\n\n        await Runtime.evaluate({expression: `(${stripPage.toString()})()`});\n        await Runtime.evaluate({expression: `(${injectBaseHref.toString()})('${url}')`});\n\n        let result = await Runtime.evaluate({expression: 'document.firstElementChild.outerHTML'});\n        CDP.Close({id: client.target.id, port: config.port});\n        resolve({\n          status: renderResult.status,\n          body: result.result.value});\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  captureScreenshot(url, options, config) {\n    return new Promise(async(resolve, reject) => {\n      const tab = await CDP.New({port: config.port});\n      const client = await CDP({tab: tab, port: config.port});\n\n      const {Animation, Page, Emulation} = client;\n\n      // Accelerate global animation timeline so that loading animations\n      // are hopefully complete by the time we take the screenshot.\n      Animation.setPlaybackRate({playbackRate: 1000});\n\n      const width = Math.min(2000, parseInt(options['width']) || 1000);\n      const height = Math.min(2000, parseInt(options['height']) || 1000);\n      await Emulation.setDeviceMetricsOverride({width: width, height: height, mobile: true, deviceScaleFactor: 3.5, fitWindow: false, screenWidth: width, screenHeight: height});\n      await Emulation.setVisibleSize({width: width, height: height});\n\n      try {\n        await this._loadPage(client, url, options, config);\n        let {data} = await Page.captureScreenshot({format: 'jpeg', quality: 60});\n\n        CDP.Close({id: client.target.id, port: config.port});\n        resolve(data);\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n}\n\nmodule.exports = new Renderer();\n", "/*\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\n'use strict';\n\nconst request = require('supertest');\nconst path = require('path');\nconst test = require('ava');\nconst express = require('express');\n\nconst app = express();\napp.use(express.static(path.resolve(__dirname, 'resources')));\nconst testBase = 'http://localhost:1234/';\n\ntest.before(async(t) => {\n  await app.listen(1234);\n});\n\n\n/**\n * This deletes server from the require cache and reloads\n * the server, allowing for a clean state between each test.\n * @param {?Object} config\n * @return {!Object} app server\n */\nasync function createServer(config) {\n  delete require.cache[require.resolve('../src/main.js')];\n  const app = await require('../src/main.js');\n  if (config)\n    app.setConfig(config);\n  return request(app);\n}\n\ntest('health check responds correctly', async(t) => {\n  const server = await createServer();\n  const res = await server.get('/_ah/health');\n  t.is(res.status, 200);\n});\n\ntest('renders basic script', async(t) => {\n  const server = await createServer();\n  const res = await server.get(`/render/${testBase}basic-script.html`);\n  t.is(res.status, 200);\n  t.true(res.text.indexOf('document-title') != -1);\n});\n\ntest('renders script after page load event', async(t) => {\n  const server = await createServer();\n  const res = await server.get(`/render/${testBase}script-after-load.html`);\n  t.is(res.status, 200);\n  t.true(res.text.indexOf('injectedElement') != -1);\n});\n\n// This test is failing as the polyfills (shady polyfill & scoping shim) are not\n// yet injected properly.\ntest.failing('renders shadow DOM - no polyfill', async(t) => {\n  const server = await createServer();\n  const res = await server.get(`/render/${testBase}shadow-dom-no-polyfill.html?wc-inject-shadydom=true`);\n  t.is(res.status, 200);\n  t.true(res.text.indexOf('shadow-root-text') != -1);\n});\n\ntest('renders shadow DOM - polyfill loader', async(t) => {\n  const server = await createServer();\n  const res = await server.get(`/render/${testBase}shadow-dom-polyfill-loader.html?wc-inject-shadydom=true`);\n  t.is(res.status, 200);\n  t.true(res.text.indexOf('shadow-root-text') != -1);\n});\n\ntest('renders shadow DOM - webcomponents-lite.js polyfill', async(t) => {\n  const server = await createServer();\n  const res = await server.get(`/render/${testBase}shadow-dom-polyfill-all.html?wc-inject-shadydom=true`);\n  t.is(res.status, 200);\n  t.true(res.text.indexOf('shadow-root-text') != -1);\n});\n\ntest('script tags and link[rel=import] tags are stripped', async(t) => {\n  const server = await createServer();\n  const res = await server.get(`/render/${testBase}include-script.html`);\n  t.is(res.status, 200);\n  t.false(res.text.indexOf('script src') != -1);\n  t.true(res.text.indexOf('injectedElement') != -1);\n  t.false(res.text.indexOf('link rel') != -1);\n  t.true(res.text.indexOf('element-text') != -1);\n});\n\ntest('server status code should be forwarded', async(t) => {\n  const server = await createServer();\n  const res = await server.get('/render/http://httpstat.us/404');\n  t.is(res.status, 404);\n  t.true(res.text.indexOf('404 Not Found') != -1);\n});\n\ntest('http status code should be able to be set via a meta tag', async(t) => {\n  const server = await createServer();\n  const testFile = path.resolve(__dirname, 'resources/http-meta-status-code.html');\n  const res = await server.get('/render/file://' + testFile + '?wc-inject-shadydom=true');\n  t.is(res.status, 400);\n});\n\ntest('http status codes need to be respected from top to bottom', async(t) => {\n  const server = await createServer();\n  const testFile = path.resolve(__dirname, 'resources/http-meta-status-code-multiple.html');\n  const res = await server.get('/render/file://' + testFile + '?wc-inject-shadydom=true');\n  t.is(res.status, 401);\n});\n\ntest('screenshot is an image', async(t) => {\n  const server = await createServer();\n  const res = await server.get(`/screenshot/${testBase}basic-script.html`);\n  t.is(res.status, 200);\n  t.is(res.header['content-type'], 'image/jpeg');\n  t.is(res.body.length, parseInt(res.header['content-length']));\n});\n\ntest('invalid url fails', async(t) => {\n  const server = await createServer();\n  const res = await server.get(`/render/abc`);\n  t.is(res.status, 400);\n});\n\ntest('unknown url fails', async(t) => {\n  const server = await createServer();\n  const res = await server.get(`/render/http://unknown.blah.com`);\n  t.is(res.status, 400);\n});\n\ntest('explicit render event ends early', async(t) => {\n  const server = await createServer();\n  const res = await server.get(`/render/${testBase}explicit-render-event.html`);\n  t.is(res.status, 200);\n  t.true(res.text.indexOf('async loaded') != -1);\n});\n\ntest('whitelist ensures other urls do not get rendered', async(t) => {\n  const server = await createServer({\n    renderOnly: [testBase]\n  });\n  let res = await server.get(`/render/${testBase}basic-script.html`);\n  t.is(res.status, 200);\n\n  res = await server.get(`/render/http://anotherDomain.com`);\n  t.is(res.status, 403);\n});\n", "/*\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\n'use strict';\n\nconst test = require('ava');\nconst request = require('supertest');\nconst express = require('express');\nconst compression = require('compression');\nconst cache = require('../src/cache.js');\n\nconst app = express();\nconst server = request(app);\n\napp.use(cache.middleware());\n\nlet handlerCalledCount = 0;\n\ntest.before(async(t) => {\n  await cache.clearCache();\n});\n\napp.get('/', (request, response) => {\n  handlerCalledCount++;\n  response.end('Called ' + handlerCalledCount + ' times');\n});\n\ntest('caches content and serves same content on cache hit', async(t) => {\n  let res = await server.get('/?basictest');\n  const previousCount = handlerCalledCount;\n  t.is(res.status, 200);\n  t.is(res.text, 'Called ' + previousCount + ' times');\n\n  res = await server.get('/?basictest');\n  t.is(res.status, 200);\n  t.is(res.text, 'Called ' + previousCount + ' times');\n\n  res = await server.get('/?basictest');\n  t.is(res.status, 200);\n  t.is(res.text, 'Called ' + previousCount + ' times');\n\n  res = await server.get('/?basictest2');\n  t.is(res.status, 200);\n  t.is(res.text, 'Called ' + (previousCount + 1) + ' times');\n});\n\napp.get('/set-header', (request, response) => {\n  response.set('my-header', 'header-value');\n  response.end('set-header-payload');\n});\n\ntest('caches headers', async(t) => {\n  let res = await server.get('/set-header');\n  t.is(res.status, 200);\n  t.is(res.header['my-header'], 'header-value');\n  t.is(res.text, 'set-header-payload');\n\n  res = await server.get('/set-header');\n  t.is(res.status, 200);\n  t.is(res.header['my-header'], 'header-value');\n  t.is(res.text, 'set-header-payload');\n});\n\napp.use('/compressed', compression());\napp.get('/compressed', (request, response) => {\n  response.set('Content-Type', 'text/html');\n  response.send(new Array(1025).join('x'));\n});\n\ntest('compression preserved', async(t) => {\n  const expectedBody = new Array(1025).join('x');\n  let res = await server.get('/compressed').set('Accept-Encoding', 'gzip, deflate, br');\n  t.is(res.status, 200);\n  t.is(res.header['content-encoding'], 'gzip');\n  t.is(res.text, expectedBody);\n\n  res = await server.get('/compressed').set('Accept-Encoding', 'gzip, deflate, br');\n  t.is(res.status, 200);\n  t.is(res.header['content-encoding'], 'gzip');\n  t.is(res.text, expectedBody);\n});\n\nlet statusCallCount = 0;\napp.get('/status/:status', (request, response) => {\n  // Every second call sends a different status.\n  if (statusCallCount % 2 == 0) {\n    response.sendStatus(request.params.status);\n  } else {\n    response.sendStatus(456);\n  }\n  statusCallCount++;\n});\n\ntest('original status is preserved', async(t) => {\n  let res = await server.get('/status/123');\n  t.is(res.status, 123);\n\n  // Non 200 status code should not be cached.\n  res = await server.get('/status/123');\n  t.is(res.status, 456);\n});\n", "<!--\nCopyright 2017 Google Inc. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not\nuse this file except in compliance with the License. You may obtain a copy of\nthe License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\nWARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\nLicense for the specific language governing permissions and limitations under\nthe License.\n-->\n<script>\n  var element = document.createElement('title');\n  element.textContent = 'document' + '-title';\n  document.head.appendChild(element);\n</script>\n", "<!--\nCopyright 2017 Google Inc. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not\nuse this file except in compliance with the License. You may obtain a copy of\nthe License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\nWARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\nLicense for the specific language governing permissions and limitations under\nthe License.\n-->\n<script>\n  class MyElement extends HTMLElement {\n    constructor() {\n      super();\n\n      this.innerHTML = '<div>element-' + 'text</div>';\n    }\n  }\n  customElements.define('custom-element', MyElement);\n</script>\n", "<!--\nCopyright 2017 Google Inc. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not\nuse this file except in compliance with the License. You may obtain a copy of\nthe License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\nWARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\nLicense for the specific language governing permissions and limitations under\nthe License.\n-->\n<script>\n  setTimeout(() => {\n    document.body.textContent = 'async loaded';\n    document.body.dispatchEvent(new Event('render-complete', { bubbles: true, composed: true}));\n  }, 5000);\n  setTimeout(() => {\n    document.body.textContent = 'should not be reached';\n  }, 10000);\n</script>\n", "<!--\nCopyright 2017 Google Inc. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not\nuse this file except in compliance with the License. You may obtain a copy of\nthe License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\nWARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\nLicense for the specific language governing permissions and limitations under\nthe License.\n-->\n<meta name=\"render:status_code\" content=\"401\">\n<meta name=\"render:status_code\" content=\"402\">", "<!--\nCopyright 2017 Google Inc. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not\nuse this file except in compliance with the License. You may obtain a copy of\nthe License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\nWARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\nLicense for the specific language governing permissions and limitations under\nthe License.\n-->\n<meta name=\"render:status_code\" content=\"400\">", "<!--\nCopyright 2017 Google Inc. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not\nuse this file except in compliance with the License. You may obtain a copy of\nthe License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\nWARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\nLicense for the specific language governing permissions and limitations under\nthe License.\n-->\n<script src=\"inject-element-after-load.js\"></script>\n<link rel=\"import\" href=\"custom-element.html\">\n<custom-element></custom-element>\n", "/*\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\nwindow.onload = function() {\n  var element = document.createElement('div');\n  element.textContent = 'injected' + 'Element';\n  document.body.appendChild(element);\n}\n", "/*\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\nvar element = document.createElement('div');\nelement.textContent = 'injectedElement';\ndocument.body.appendChild(element);", "<!--\nCopyright 2017 Google Inc. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not\nuse this file except in compliance with the License. You may obtain a copy of\nthe License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\nWARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\nLicense for the specific language governing permissions and limitations under\nthe License.\n-->\n<script>\nwindow.onload = function() {\n  var script = document.createElement('script');\n  script.src = 'inject-element.js';\n  document.body.appendChild(script);\n}\n</script>\n", "<!--\nCopyright 2017 Google Inc. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not\nuse this file except in compliance with the License. You may obtain a copy of\nthe License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\nWARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\nLicense for the specific language governing permissions and limitations under\nthe License.\n-->\n<my-element></my-element>\n<script>\n  class MyElement extends HTMLElement {\n    constructor() {\n      super();\n\n      const shadowRoot = this.attachShadow({mode: 'open'});\n      shadowRoot.innerHTML = 'shadow-root' + '-text';\n    }\n  }\n  customElements.define('my-element', MyElement);\n</script>\n", "<!--\nCopyright 2017 Google Inc. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not\nuse this file except in compliance with the License. You may obtain a copy of\nthe License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\nWARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\nLicense for the specific language governing permissions and limitations under\nthe License.\n-->\n<script src=\"node_modules/@webcomponents/webcomponentsjs/webcomponents-lite.js\"></script>\n<my-element></my-element>\n<script>\n  class MyElement extends HTMLElement {\n    constructor() {\n      super();\n\n      const shadowRoot = this.attachShadow({mode: 'open'});\n      shadowRoot.innerHTML = 'shadow-root' + '-text';\n    }\n  }\n  customElements.define('my-element', MyElement);\n</script>\n", "<!--\nCopyright 2017 Google Inc. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not\nuse this file except in compliance with the License. You may obtain a copy of\nthe License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\nWARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\nLicense for the specific language governing permissions and limitations under\nthe License.\n-->\n<script src=\"node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js\"></script>\n<my-element></my-element>\n<script>\n  class MyElement extends HTMLElement {\n    constructor() {\n      super();\n\n      const shadowRoot = this.attachShadow({mode: 'open'});\n      shadowRoot.innerHTML = 'shadow-root' + '-text';\n    }\n  }\n  customElements.define('my-element', MyElement);\n</script>\n"], "filenames": ["middleware/src/middleware.js", "middleware/test/middleware-test.js", "src/cache.js", "src/index.html", "src/main.js", "src/renderer.js", "test/app-test.js", "test/cache-test.js", "test/resources/basic-script.html", "test/resources/custom-element.html", "test/resources/explicit-render-event.html", "test/resources/http-meta-status-code-multiple.html", "test/resources/http-meta-status-code.html", "test/resources/include-script.html", "test/resources/inject-element-after-load.js", "test/resources/inject-element.js", "test/resources/script-after-load.html", "test/resources/shadow-dom-no-polyfill.html", "test/resources/shadow-dom-polyfill-all.html", "test/resources/shadow-dom-polyfill-loader.html"], "buggy_code_start_loc": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], "buggy_code_end_loc": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], "fixing_code_start_loc": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "fixing_code_end_loc": [17, 17, 17, 16, 17, 17, 17, 17, 16, 16, 16, 16, 16, 16, 17, 17, 16, 16, 16, 16], "type": "CWE-22", "message": "Rendertron 1.0.0 allows for alternative protocols such as 'file://' introducing a Local File Inclusion (LFI) bug where arbitrary files can be read by a remote attacker.", "other": {"cve": {"id": "CVE-2017-18354", "sourceIdentifier": "cve@mitre.org", "published": "2018-12-17T07:29:00.437", "lastModified": "2019-01-04T14:57:14.303", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Rendertron 1.0.0 allows for alternative protocols such as 'file://' introducing a Local File Inclusion (LFI) bug where arbitrary files can be read by a remote attacker."}, {"lang": "es", "value": "Rendertron 1.0.0 permite que protocolos alternativos como \"file://\" que introducen un error LFI (Local File Inclusion) por el que los archivos arbitrarios pueden ser le\u00eddos por un atacante remoto."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:rendertron:1.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "6D70E656-EEC7-43B2-8B6B-EB20B7025AFE"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/chromium/issues/detail?id=759111", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Vendor Advisory"]}, {"url": "https://github.com/GoogleChrome/rendertron/commit/8d70628c96ae72eff6eebb451d26fc9ed6b58b0e", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/GoogleChrome/rendertron/pull/88", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/GoogleChrome/rendertron/commit/8d70628c96ae72eff6eebb451d26fc9ed6b58b0e"}}