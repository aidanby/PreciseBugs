{"buggy_code": ["/* SPDX-License-Identifier: GPL-2.0 */\n/*\n * vboxguest linux pci driver, char-dev and input-device code,\n *\n * Copyright (C) 2006-2016 Oracle Corporation\n */\n\n#include <linux/input.h>\n#include <linux/kernel.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/poll.h>\n#include <linux/vbox_utils.h>\n#include \"vboxguest_core.h\"\n\n/** The device name. */\n#define DEVICE_NAME\t\t\"vboxguest\"\n/** The device name for the device node open to everyone. */\n#define DEVICE_NAME_USER\t\"vboxuser\"\n/** VirtualBox PCI vendor ID. */\n#define VBOX_VENDORID\t\t0x80ee\n/** VMMDev PCI card product ID. */\n#define VMMDEV_DEVICEID\t\t0xcafe\n\n/** Mutex protecting the global vbg_gdev pointer used by vbg_get/put_gdev. */\nstatic DEFINE_MUTEX(vbg_gdev_mutex);\n/** Global vbg_gdev pointer used by vbg_get/put_gdev. */\nstatic struct vbg_dev *vbg_gdev;\n\nstatic int vbg_misc_device_open(struct inode *inode, struct file *filp)\n{\n\tstruct vbg_session *session;\n\tstruct vbg_dev *gdev;\n\n\t/* misc_open sets filp->private_data to our misc device */\n\tgdev = container_of(filp->private_data, struct vbg_dev, misc_device);\n\n\tsession = vbg_core_open_session(gdev, false);\n\tif (IS_ERR(session))\n\t\treturn PTR_ERR(session);\n\n\tfilp->private_data = session;\n\treturn 0;\n}\n\nstatic int vbg_misc_device_user_open(struct inode *inode, struct file *filp)\n{\n\tstruct vbg_session *session;\n\tstruct vbg_dev *gdev;\n\n\t/* misc_open sets filp->private_data to our misc device */\n\tgdev = container_of(filp->private_data, struct vbg_dev,\n\t\t\t    misc_device_user);\n\n\tsession = vbg_core_open_session(gdev, false);\n\tif (IS_ERR(session))\n\t\treturn PTR_ERR(session);\n\n\tfilp->private_data = session;\n\treturn 0;\n}\n\n/**\n * Close device.\n * Return: 0 on success, negated errno on failure.\n * @inode:\t\tPointer to inode info structure.\n * @filp:\t\tAssociated file pointer.\n */\nstatic int vbg_misc_device_close(struct inode *inode, struct file *filp)\n{\n\tvbg_core_close_session(filp->private_data);\n\tfilp->private_data = NULL;\n\treturn 0;\n}\n\n/**\n * Device I/O Control entry point.\n * Return: 0 on success, negated errno on failure.\n * @filp:\t\tAssociated file pointer.\n * @req:\t\tThe request specified to ioctl().\n * @arg:\t\tThe argument specified to ioctl().\n */\nstatic long vbg_misc_device_ioctl(struct file *filp, unsigned int req,\n\t\t\t\t  unsigned long arg)\n{\n\tstruct vbg_session *session = filp->private_data;\n\tsize_t returned_size, size;\n\tstruct vbg_ioctl_hdr hdr;\n\tbool is_vmmdev_req;\n\tint ret = 0;\n\tvoid *buf;\n\n\tif (copy_from_user(&hdr, (void *)arg, sizeof(hdr)))\n\t\treturn -EFAULT;\n\n\tif (hdr.version != VBG_IOCTL_HDR_VERSION)\n\t\treturn -EINVAL;\n\n\tif (hdr.size_in < sizeof(hdr) ||\n\t    (hdr.size_out && hdr.size_out < sizeof(hdr)))\n\t\treturn -EINVAL;\n\n\tsize = max(hdr.size_in, hdr.size_out);\n\tif (_IOC_SIZE(req) && _IOC_SIZE(req) != size)\n\t\treturn -EINVAL;\n\tif (size > SZ_16M)\n\t\treturn -E2BIG;\n\n\t/*\n\t * IOCTL_VMMDEV_REQUEST needs the buffer to be below 4G to avoid\n\t * the need for a bounce-buffer and another copy later on.\n\t */\n\tis_vmmdev_req = (req & ~IOCSIZE_MASK) == VBG_IOCTL_VMMDEV_REQUEST(0) ||\n\t\t\t req == VBG_IOCTL_VMMDEV_REQUEST_BIG;\n\n\tif (is_vmmdev_req)\n\t\tbuf = vbg_req_alloc(size, VBG_IOCTL_HDR_TYPE_DEFAULT);\n\telse\n\t\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(buf, (void *)arg, hdr.size_in)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (hdr.size_in < size)\n\t\tmemset(buf + hdr.size_in, 0, size -  hdr.size_in);\n\n\tret = vbg_core_ioctl(session, req, buf);\n\tif (ret)\n\t\tgoto out;\n\n\treturned_size = ((struct vbg_ioctl_hdr *)buf)->size_out;\n\tif (returned_size > size) {\n\t\tvbg_debug(\"%s: too much output data %zu > %zu\\n\",\n\t\t\t  __func__, returned_size, size);\n\t\treturned_size = size;\n\t}\n\tif (copy_to_user((void *)arg, buf, returned_size) != 0)\n\t\tret = -EFAULT;\n\nout:\n\tif (is_vmmdev_req)\n\t\tvbg_req_free(buf, size);\n\telse\n\t\tkfree(buf);\n\n\treturn ret;\n}\n\n/** The file_operations structures. */\nstatic const struct file_operations vbg_misc_device_fops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.open\t\t\t= vbg_misc_device_open,\n\t.release\t\t= vbg_misc_device_close,\n\t.unlocked_ioctl\t\t= vbg_misc_device_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t\t= vbg_misc_device_ioctl,\n#endif\n};\nstatic const struct file_operations vbg_misc_device_user_fops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.open\t\t\t= vbg_misc_device_user_open,\n\t.release\t\t= vbg_misc_device_close,\n\t.unlocked_ioctl\t\t= vbg_misc_device_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t\t= vbg_misc_device_ioctl,\n#endif\n};\n\n/**\n * Called when the input device is first opened.\n *\n * Sets up absolute mouse reporting.\n */\nstatic int vbg_input_open(struct input_dev *input)\n{\n\tstruct vbg_dev *gdev = input_get_drvdata(input);\n\tu32 feat = VMMDEV_MOUSE_GUEST_CAN_ABSOLUTE | VMMDEV_MOUSE_NEW_PROTOCOL;\n\tint ret;\n\n\tret = vbg_core_set_mouse_status(gdev, feat);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n/**\n * Called if all open handles to the input device are closed.\n *\n * Disables absolute reporting.\n */\nstatic void vbg_input_close(struct input_dev *input)\n{\n\tstruct vbg_dev *gdev = input_get_drvdata(input);\n\n\tvbg_core_set_mouse_status(gdev, 0);\n}\n\n/**\n * Creates the kernel input device.\n *\n * Return: 0 on success, negated errno on failure.\n */\nstatic int vbg_create_input_device(struct vbg_dev *gdev)\n{\n\tstruct input_dev *input;\n\n\tinput = devm_input_allocate_device(gdev->dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinput->id.bustype = BUS_PCI;\n\tinput->id.vendor = VBOX_VENDORID;\n\tinput->id.product = VMMDEV_DEVICEID;\n\tinput->open = vbg_input_open;\n\tinput->close = vbg_input_close;\n\tinput->dev.parent = gdev->dev;\n\tinput->name = \"VirtualBox mouse integration\";\n\n\tinput_set_abs_params(input, ABS_X, VMMDEV_MOUSE_RANGE_MIN,\n\t\t\t     VMMDEV_MOUSE_RANGE_MAX, 0, 0);\n\tinput_set_abs_params(input, ABS_Y, VMMDEV_MOUSE_RANGE_MIN,\n\t\t\t     VMMDEV_MOUSE_RANGE_MAX, 0, 0);\n\tinput_set_capability(input, EV_KEY, BTN_MOUSE);\n\tinput_set_drvdata(input, gdev);\n\n\tgdev->input = input;\n\n\treturn input_register_device(gdev->input);\n}\n\nstatic ssize_t host_version_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct vbg_dev *gdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\\n\", gdev->host_version);\n}\n\nstatic ssize_t host_features_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct vbg_dev *gdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%#x\\n\", gdev->host_features);\n}\n\nstatic DEVICE_ATTR_RO(host_version);\nstatic DEVICE_ATTR_RO(host_features);\n\n/**\n * Does the PCI detection and init of the device.\n *\n * Return: 0 on success, negated errno on failure.\n */\nstatic int vbg_pci_probe(struct pci_dev *pci, const struct pci_device_id *id)\n{\n\tstruct device *dev = &pci->dev;\n\tresource_size_t io, io_len, mmio, mmio_len;\n\tstruct vmmdev_memory *vmmdev;\n\tstruct vbg_dev *gdev;\n\tint ret;\n\n\tgdev = devm_kzalloc(dev, sizeof(*gdev), GFP_KERNEL);\n\tif (!gdev)\n\t\treturn -ENOMEM;\n\n\tret = pci_enable_device(pci);\n\tif (ret != 0) {\n\t\tvbg_err(\"vboxguest: Error enabling device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = -ENODEV;\n\n\tio = pci_resource_start(pci, 0);\n\tio_len = pci_resource_len(pci, 0);\n\tif (!io || !io_len) {\n\t\tvbg_err(\"vboxguest: Error IO-port resource (0) is missing\\n\");\n\t\tgoto err_disable_pcidev;\n\t}\n\tif (devm_request_region(dev, io, io_len, DEVICE_NAME) == NULL) {\n\t\tvbg_err(\"vboxguest: Error could not claim IO resource\\n\");\n\t\tret = -EBUSY;\n\t\tgoto err_disable_pcidev;\n\t}\n\n\tmmio = pci_resource_start(pci, 1);\n\tmmio_len = pci_resource_len(pci, 1);\n\tif (!mmio || !mmio_len) {\n\t\tvbg_err(\"vboxguest: Error MMIO resource (1) is missing\\n\");\n\t\tgoto err_disable_pcidev;\n\t}\n\n\tif (devm_request_mem_region(dev, mmio, mmio_len, DEVICE_NAME) == NULL) {\n\t\tvbg_err(\"vboxguest: Error could not claim MMIO resource\\n\");\n\t\tret = -EBUSY;\n\t\tgoto err_disable_pcidev;\n\t}\n\n\tvmmdev = devm_ioremap(dev, mmio, mmio_len);\n\tif (!vmmdev) {\n\t\tvbg_err(\"vboxguest: Error ioremap failed; MMIO addr=%pap size=%pap\\n\",\n\t\t\t&mmio, &mmio_len);\n\t\tgoto err_disable_pcidev;\n\t}\n\n\t/* Validate MMIO region version and size. */\n\tif (vmmdev->version != VMMDEV_MEMORY_VERSION ||\n\t    vmmdev->size < 32 || vmmdev->size > mmio_len) {\n\t\tvbg_err(\"vboxguest: Bogus VMMDev memory; version=%08x (expected %08x) size=%d (expected <= %d)\\n\",\n\t\t\tvmmdev->version, VMMDEV_MEMORY_VERSION,\n\t\t\tvmmdev->size, (int)mmio_len);\n\t\tgoto err_disable_pcidev;\n\t}\n\n\tgdev->io_port = io;\n\tgdev->mmio = vmmdev;\n\tgdev->dev = dev;\n\tgdev->misc_device.minor = MISC_DYNAMIC_MINOR;\n\tgdev->misc_device.name = DEVICE_NAME;\n\tgdev->misc_device.fops = &vbg_misc_device_fops;\n\tgdev->misc_device_user.minor = MISC_DYNAMIC_MINOR;\n\tgdev->misc_device_user.name = DEVICE_NAME_USER;\n\tgdev->misc_device_user.fops = &vbg_misc_device_user_fops;\n\n\tret = vbg_core_init(gdev, VMMDEV_EVENT_MOUSE_POSITION_CHANGED);\n\tif (ret)\n\t\tgoto err_disable_pcidev;\n\n\tret = vbg_create_input_device(gdev);\n\tif (ret) {\n\t\tvbg_err(\"vboxguest: Error creating input device: %d\\n\", ret);\n\t\tgoto err_vbg_core_exit;\n\t}\n\n\tret = devm_request_irq(dev, pci->irq, vbg_core_isr, IRQF_SHARED,\n\t\t\t       DEVICE_NAME, gdev);\n\tif (ret) {\n\t\tvbg_err(\"vboxguest: Error requesting irq: %d\\n\", ret);\n\t\tgoto err_vbg_core_exit;\n\t}\n\n\tret = misc_register(&gdev->misc_device);\n\tif (ret) {\n\t\tvbg_err(\"vboxguest: Error misc_register %s failed: %d\\n\",\n\t\t\tDEVICE_NAME, ret);\n\t\tgoto err_vbg_core_exit;\n\t}\n\n\tret = misc_register(&gdev->misc_device_user);\n\tif (ret) {\n\t\tvbg_err(\"vboxguest: Error misc_register %s failed: %d\\n\",\n\t\t\tDEVICE_NAME_USER, ret);\n\t\tgoto err_unregister_misc_device;\n\t}\n\n\tmutex_lock(&vbg_gdev_mutex);\n\tif (!vbg_gdev)\n\t\tvbg_gdev = gdev;\n\telse\n\t\tret = -EBUSY;\n\tmutex_unlock(&vbg_gdev_mutex);\n\n\tif (ret) {\n\t\tvbg_err(\"vboxguest: Error more then 1 vbox guest pci device\\n\");\n\t\tgoto err_unregister_misc_device_user;\n\t}\n\n\tpci_set_drvdata(pci, gdev);\n\tdevice_create_file(dev, &dev_attr_host_version);\n\tdevice_create_file(dev, &dev_attr_host_features);\n\n\tvbg_info(\"vboxguest: misc device minor %d, IRQ %d, I/O port %x, MMIO at %pap (size %pap)\\n\",\n\t\t gdev->misc_device.minor, pci->irq, gdev->io_port,\n\t\t &mmio, &mmio_len);\n\n\treturn 0;\n\nerr_unregister_misc_device_user:\n\tmisc_deregister(&gdev->misc_device_user);\nerr_unregister_misc_device:\n\tmisc_deregister(&gdev->misc_device);\nerr_vbg_core_exit:\n\tvbg_core_exit(gdev);\nerr_disable_pcidev:\n\tpci_disable_device(pci);\n\n\treturn ret;\n}\n\nstatic void vbg_pci_remove(struct pci_dev *pci)\n{\n\tstruct vbg_dev *gdev = pci_get_drvdata(pci);\n\n\tmutex_lock(&vbg_gdev_mutex);\n\tvbg_gdev = NULL;\n\tmutex_unlock(&vbg_gdev_mutex);\n\n\tdevice_remove_file(gdev->dev, &dev_attr_host_features);\n\tdevice_remove_file(gdev->dev, &dev_attr_host_version);\n\tmisc_deregister(&gdev->misc_device_user);\n\tmisc_deregister(&gdev->misc_device);\n\tvbg_core_exit(gdev);\n\tpci_disable_device(pci);\n}\n\nstruct vbg_dev *vbg_get_gdev(void)\n{\n\tmutex_lock(&vbg_gdev_mutex);\n\n\t/*\n\t * Note on success we keep the mutex locked until vbg_put_gdev(),\n\t * this stops vbg_pci_remove from removing the device from underneath\n\t * vboxsf. vboxsf will only hold a reference for a short while.\n\t */\n\tif (vbg_gdev)\n\t\treturn vbg_gdev;\n\n\tmutex_unlock(&vbg_gdev_mutex);\n\treturn ERR_PTR(-ENODEV);\n}\nEXPORT_SYMBOL(vbg_get_gdev);\n\nvoid vbg_put_gdev(struct vbg_dev *gdev)\n{\n\tWARN_ON(gdev != vbg_gdev);\n\tmutex_unlock(&vbg_gdev_mutex);\n}\nEXPORT_SYMBOL(vbg_put_gdev);\n\n/**\n * Callback for mouse events.\n *\n * This is called at the end of the ISR, after leaving the event spinlock, if\n * VMMDEV_EVENT_MOUSE_POSITION_CHANGED was raised by the host.\n *\n * @gdev:\t\tThe device extension.\n */\nvoid vbg_linux_mouse_event(struct vbg_dev *gdev)\n{\n\tint rc;\n\n\t/* Report events to the kernel input device */\n\tgdev->mouse_status_req->mouse_features = 0;\n\tgdev->mouse_status_req->pointer_pos_x = 0;\n\tgdev->mouse_status_req->pointer_pos_y = 0;\n\trc = vbg_req_perform(gdev, gdev->mouse_status_req);\n\tif (rc >= 0) {\n\t\tinput_report_abs(gdev->input, ABS_X,\n\t\t\t\t gdev->mouse_status_req->pointer_pos_x);\n\t\tinput_report_abs(gdev->input, ABS_Y,\n\t\t\t\t gdev->mouse_status_req->pointer_pos_y);\n\t\tinput_sync(gdev->input);\n\t}\n}\n\nstatic const struct pci_device_id vbg_pci_ids[] = {\n\t{ .vendor = VBOX_VENDORID, .device = VMMDEV_DEVICEID },\n\t{}\n};\nMODULE_DEVICE_TABLE(pci,  vbg_pci_ids);\n\nstatic struct pci_driver vbg_pci_driver = {\n\t.name\t\t= DEVICE_NAME,\n\t.id_table\t= vbg_pci_ids,\n\t.probe\t\t= vbg_pci_probe,\n\t.remove\t\t= vbg_pci_remove,\n};\n\nmodule_pci_driver(vbg_pci_driver);\n\nMODULE_AUTHOR(\"Oracle Corporation\");\nMODULE_DESCRIPTION(\"Oracle VM VirtualBox Guest Additions for Linux Module\");\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["/* SPDX-License-Identifier: GPL-2.0 */\n/*\n * vboxguest linux pci driver, char-dev and input-device code,\n *\n * Copyright (C) 2006-2016 Oracle Corporation\n */\n\n#include <linux/input.h>\n#include <linux/kernel.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/poll.h>\n#include <linux/vbox_utils.h>\n#include \"vboxguest_core.h\"\n\n/** The device name. */\n#define DEVICE_NAME\t\t\"vboxguest\"\n/** The device name for the device node open to everyone. */\n#define DEVICE_NAME_USER\t\"vboxuser\"\n/** VirtualBox PCI vendor ID. */\n#define VBOX_VENDORID\t\t0x80ee\n/** VMMDev PCI card product ID. */\n#define VMMDEV_DEVICEID\t\t0xcafe\n\n/** Mutex protecting the global vbg_gdev pointer used by vbg_get/put_gdev. */\nstatic DEFINE_MUTEX(vbg_gdev_mutex);\n/** Global vbg_gdev pointer used by vbg_get/put_gdev. */\nstatic struct vbg_dev *vbg_gdev;\n\nstatic int vbg_misc_device_open(struct inode *inode, struct file *filp)\n{\n\tstruct vbg_session *session;\n\tstruct vbg_dev *gdev;\n\n\t/* misc_open sets filp->private_data to our misc device */\n\tgdev = container_of(filp->private_data, struct vbg_dev, misc_device);\n\n\tsession = vbg_core_open_session(gdev, false);\n\tif (IS_ERR(session))\n\t\treturn PTR_ERR(session);\n\n\tfilp->private_data = session;\n\treturn 0;\n}\n\nstatic int vbg_misc_device_user_open(struct inode *inode, struct file *filp)\n{\n\tstruct vbg_session *session;\n\tstruct vbg_dev *gdev;\n\n\t/* misc_open sets filp->private_data to our misc device */\n\tgdev = container_of(filp->private_data, struct vbg_dev,\n\t\t\t    misc_device_user);\n\n\tsession = vbg_core_open_session(gdev, false);\n\tif (IS_ERR(session))\n\t\treturn PTR_ERR(session);\n\n\tfilp->private_data = session;\n\treturn 0;\n}\n\n/**\n * Close device.\n * Return: 0 on success, negated errno on failure.\n * @inode:\t\tPointer to inode info structure.\n * @filp:\t\tAssociated file pointer.\n */\nstatic int vbg_misc_device_close(struct inode *inode, struct file *filp)\n{\n\tvbg_core_close_session(filp->private_data);\n\tfilp->private_data = NULL;\n\treturn 0;\n}\n\n/**\n * Device I/O Control entry point.\n * Return: 0 on success, negated errno on failure.\n * @filp:\t\tAssociated file pointer.\n * @req:\t\tThe request specified to ioctl().\n * @arg:\t\tThe argument specified to ioctl().\n */\nstatic long vbg_misc_device_ioctl(struct file *filp, unsigned int req,\n\t\t\t\t  unsigned long arg)\n{\n\tstruct vbg_session *session = filp->private_data;\n\tsize_t returned_size, size;\n\tstruct vbg_ioctl_hdr hdr;\n\tbool is_vmmdev_req;\n\tint ret = 0;\n\tvoid *buf;\n\n\tif (copy_from_user(&hdr, (void *)arg, sizeof(hdr)))\n\t\treturn -EFAULT;\n\n\tif (hdr.version != VBG_IOCTL_HDR_VERSION)\n\t\treturn -EINVAL;\n\n\tif (hdr.size_in < sizeof(hdr) ||\n\t    (hdr.size_out && hdr.size_out < sizeof(hdr)))\n\t\treturn -EINVAL;\n\n\tsize = max(hdr.size_in, hdr.size_out);\n\tif (_IOC_SIZE(req) && _IOC_SIZE(req) != size)\n\t\treturn -EINVAL;\n\tif (size > SZ_16M)\n\t\treturn -E2BIG;\n\n\t/*\n\t * IOCTL_VMMDEV_REQUEST needs the buffer to be below 4G to avoid\n\t * the need for a bounce-buffer and another copy later on.\n\t */\n\tis_vmmdev_req = (req & ~IOCSIZE_MASK) == VBG_IOCTL_VMMDEV_REQUEST(0) ||\n\t\t\t req == VBG_IOCTL_VMMDEV_REQUEST_BIG;\n\n\tif (is_vmmdev_req)\n\t\tbuf = vbg_req_alloc(size, VBG_IOCTL_HDR_TYPE_DEFAULT);\n\telse\n\t\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t*((struct vbg_ioctl_hdr *)buf) = hdr;\n\tif (copy_from_user(buf + sizeof(hdr), (void *)arg + sizeof(hdr),\n\t\t\t   hdr.size_in - sizeof(hdr))) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (hdr.size_in < size)\n\t\tmemset(buf + hdr.size_in, 0, size -  hdr.size_in);\n\n\tret = vbg_core_ioctl(session, req, buf);\n\tif (ret)\n\t\tgoto out;\n\n\treturned_size = ((struct vbg_ioctl_hdr *)buf)->size_out;\n\tif (returned_size > size) {\n\t\tvbg_debug(\"%s: too much output data %zu > %zu\\n\",\n\t\t\t  __func__, returned_size, size);\n\t\treturned_size = size;\n\t}\n\tif (copy_to_user((void *)arg, buf, returned_size) != 0)\n\t\tret = -EFAULT;\n\nout:\n\tif (is_vmmdev_req)\n\t\tvbg_req_free(buf, size);\n\telse\n\t\tkfree(buf);\n\n\treturn ret;\n}\n\n/** The file_operations structures. */\nstatic const struct file_operations vbg_misc_device_fops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.open\t\t\t= vbg_misc_device_open,\n\t.release\t\t= vbg_misc_device_close,\n\t.unlocked_ioctl\t\t= vbg_misc_device_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t\t= vbg_misc_device_ioctl,\n#endif\n};\nstatic const struct file_operations vbg_misc_device_user_fops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.open\t\t\t= vbg_misc_device_user_open,\n\t.release\t\t= vbg_misc_device_close,\n\t.unlocked_ioctl\t\t= vbg_misc_device_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t\t= vbg_misc_device_ioctl,\n#endif\n};\n\n/**\n * Called when the input device is first opened.\n *\n * Sets up absolute mouse reporting.\n */\nstatic int vbg_input_open(struct input_dev *input)\n{\n\tstruct vbg_dev *gdev = input_get_drvdata(input);\n\tu32 feat = VMMDEV_MOUSE_GUEST_CAN_ABSOLUTE | VMMDEV_MOUSE_NEW_PROTOCOL;\n\tint ret;\n\n\tret = vbg_core_set_mouse_status(gdev, feat);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n/**\n * Called if all open handles to the input device are closed.\n *\n * Disables absolute reporting.\n */\nstatic void vbg_input_close(struct input_dev *input)\n{\n\tstruct vbg_dev *gdev = input_get_drvdata(input);\n\n\tvbg_core_set_mouse_status(gdev, 0);\n}\n\n/**\n * Creates the kernel input device.\n *\n * Return: 0 on success, negated errno on failure.\n */\nstatic int vbg_create_input_device(struct vbg_dev *gdev)\n{\n\tstruct input_dev *input;\n\n\tinput = devm_input_allocate_device(gdev->dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinput->id.bustype = BUS_PCI;\n\tinput->id.vendor = VBOX_VENDORID;\n\tinput->id.product = VMMDEV_DEVICEID;\n\tinput->open = vbg_input_open;\n\tinput->close = vbg_input_close;\n\tinput->dev.parent = gdev->dev;\n\tinput->name = \"VirtualBox mouse integration\";\n\n\tinput_set_abs_params(input, ABS_X, VMMDEV_MOUSE_RANGE_MIN,\n\t\t\t     VMMDEV_MOUSE_RANGE_MAX, 0, 0);\n\tinput_set_abs_params(input, ABS_Y, VMMDEV_MOUSE_RANGE_MIN,\n\t\t\t     VMMDEV_MOUSE_RANGE_MAX, 0, 0);\n\tinput_set_capability(input, EV_KEY, BTN_MOUSE);\n\tinput_set_drvdata(input, gdev);\n\n\tgdev->input = input;\n\n\treturn input_register_device(gdev->input);\n}\n\nstatic ssize_t host_version_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct vbg_dev *gdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\\n\", gdev->host_version);\n}\n\nstatic ssize_t host_features_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct vbg_dev *gdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%#x\\n\", gdev->host_features);\n}\n\nstatic DEVICE_ATTR_RO(host_version);\nstatic DEVICE_ATTR_RO(host_features);\n\n/**\n * Does the PCI detection and init of the device.\n *\n * Return: 0 on success, negated errno on failure.\n */\nstatic int vbg_pci_probe(struct pci_dev *pci, const struct pci_device_id *id)\n{\n\tstruct device *dev = &pci->dev;\n\tresource_size_t io, io_len, mmio, mmio_len;\n\tstruct vmmdev_memory *vmmdev;\n\tstruct vbg_dev *gdev;\n\tint ret;\n\n\tgdev = devm_kzalloc(dev, sizeof(*gdev), GFP_KERNEL);\n\tif (!gdev)\n\t\treturn -ENOMEM;\n\n\tret = pci_enable_device(pci);\n\tif (ret != 0) {\n\t\tvbg_err(\"vboxguest: Error enabling device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = -ENODEV;\n\n\tio = pci_resource_start(pci, 0);\n\tio_len = pci_resource_len(pci, 0);\n\tif (!io || !io_len) {\n\t\tvbg_err(\"vboxguest: Error IO-port resource (0) is missing\\n\");\n\t\tgoto err_disable_pcidev;\n\t}\n\tif (devm_request_region(dev, io, io_len, DEVICE_NAME) == NULL) {\n\t\tvbg_err(\"vboxguest: Error could not claim IO resource\\n\");\n\t\tret = -EBUSY;\n\t\tgoto err_disable_pcidev;\n\t}\n\n\tmmio = pci_resource_start(pci, 1);\n\tmmio_len = pci_resource_len(pci, 1);\n\tif (!mmio || !mmio_len) {\n\t\tvbg_err(\"vboxguest: Error MMIO resource (1) is missing\\n\");\n\t\tgoto err_disable_pcidev;\n\t}\n\n\tif (devm_request_mem_region(dev, mmio, mmio_len, DEVICE_NAME) == NULL) {\n\t\tvbg_err(\"vboxguest: Error could not claim MMIO resource\\n\");\n\t\tret = -EBUSY;\n\t\tgoto err_disable_pcidev;\n\t}\n\n\tvmmdev = devm_ioremap(dev, mmio, mmio_len);\n\tif (!vmmdev) {\n\t\tvbg_err(\"vboxguest: Error ioremap failed; MMIO addr=%pap size=%pap\\n\",\n\t\t\t&mmio, &mmio_len);\n\t\tgoto err_disable_pcidev;\n\t}\n\n\t/* Validate MMIO region version and size. */\n\tif (vmmdev->version != VMMDEV_MEMORY_VERSION ||\n\t    vmmdev->size < 32 || vmmdev->size > mmio_len) {\n\t\tvbg_err(\"vboxguest: Bogus VMMDev memory; version=%08x (expected %08x) size=%d (expected <= %d)\\n\",\n\t\t\tvmmdev->version, VMMDEV_MEMORY_VERSION,\n\t\t\tvmmdev->size, (int)mmio_len);\n\t\tgoto err_disable_pcidev;\n\t}\n\n\tgdev->io_port = io;\n\tgdev->mmio = vmmdev;\n\tgdev->dev = dev;\n\tgdev->misc_device.minor = MISC_DYNAMIC_MINOR;\n\tgdev->misc_device.name = DEVICE_NAME;\n\tgdev->misc_device.fops = &vbg_misc_device_fops;\n\tgdev->misc_device_user.minor = MISC_DYNAMIC_MINOR;\n\tgdev->misc_device_user.name = DEVICE_NAME_USER;\n\tgdev->misc_device_user.fops = &vbg_misc_device_user_fops;\n\n\tret = vbg_core_init(gdev, VMMDEV_EVENT_MOUSE_POSITION_CHANGED);\n\tif (ret)\n\t\tgoto err_disable_pcidev;\n\n\tret = vbg_create_input_device(gdev);\n\tif (ret) {\n\t\tvbg_err(\"vboxguest: Error creating input device: %d\\n\", ret);\n\t\tgoto err_vbg_core_exit;\n\t}\n\n\tret = devm_request_irq(dev, pci->irq, vbg_core_isr, IRQF_SHARED,\n\t\t\t       DEVICE_NAME, gdev);\n\tif (ret) {\n\t\tvbg_err(\"vboxguest: Error requesting irq: %d\\n\", ret);\n\t\tgoto err_vbg_core_exit;\n\t}\n\n\tret = misc_register(&gdev->misc_device);\n\tif (ret) {\n\t\tvbg_err(\"vboxguest: Error misc_register %s failed: %d\\n\",\n\t\t\tDEVICE_NAME, ret);\n\t\tgoto err_vbg_core_exit;\n\t}\n\n\tret = misc_register(&gdev->misc_device_user);\n\tif (ret) {\n\t\tvbg_err(\"vboxguest: Error misc_register %s failed: %d\\n\",\n\t\t\tDEVICE_NAME_USER, ret);\n\t\tgoto err_unregister_misc_device;\n\t}\n\n\tmutex_lock(&vbg_gdev_mutex);\n\tif (!vbg_gdev)\n\t\tvbg_gdev = gdev;\n\telse\n\t\tret = -EBUSY;\n\tmutex_unlock(&vbg_gdev_mutex);\n\n\tif (ret) {\n\t\tvbg_err(\"vboxguest: Error more then 1 vbox guest pci device\\n\");\n\t\tgoto err_unregister_misc_device_user;\n\t}\n\n\tpci_set_drvdata(pci, gdev);\n\tdevice_create_file(dev, &dev_attr_host_version);\n\tdevice_create_file(dev, &dev_attr_host_features);\n\n\tvbg_info(\"vboxguest: misc device minor %d, IRQ %d, I/O port %x, MMIO at %pap (size %pap)\\n\",\n\t\t gdev->misc_device.minor, pci->irq, gdev->io_port,\n\t\t &mmio, &mmio_len);\n\n\treturn 0;\n\nerr_unregister_misc_device_user:\n\tmisc_deregister(&gdev->misc_device_user);\nerr_unregister_misc_device:\n\tmisc_deregister(&gdev->misc_device);\nerr_vbg_core_exit:\n\tvbg_core_exit(gdev);\nerr_disable_pcidev:\n\tpci_disable_device(pci);\n\n\treturn ret;\n}\n\nstatic void vbg_pci_remove(struct pci_dev *pci)\n{\n\tstruct vbg_dev *gdev = pci_get_drvdata(pci);\n\n\tmutex_lock(&vbg_gdev_mutex);\n\tvbg_gdev = NULL;\n\tmutex_unlock(&vbg_gdev_mutex);\n\n\tdevice_remove_file(gdev->dev, &dev_attr_host_features);\n\tdevice_remove_file(gdev->dev, &dev_attr_host_version);\n\tmisc_deregister(&gdev->misc_device_user);\n\tmisc_deregister(&gdev->misc_device);\n\tvbg_core_exit(gdev);\n\tpci_disable_device(pci);\n}\n\nstruct vbg_dev *vbg_get_gdev(void)\n{\n\tmutex_lock(&vbg_gdev_mutex);\n\n\t/*\n\t * Note on success we keep the mutex locked until vbg_put_gdev(),\n\t * this stops vbg_pci_remove from removing the device from underneath\n\t * vboxsf. vboxsf will only hold a reference for a short while.\n\t */\n\tif (vbg_gdev)\n\t\treturn vbg_gdev;\n\n\tmutex_unlock(&vbg_gdev_mutex);\n\treturn ERR_PTR(-ENODEV);\n}\nEXPORT_SYMBOL(vbg_get_gdev);\n\nvoid vbg_put_gdev(struct vbg_dev *gdev)\n{\n\tWARN_ON(gdev != vbg_gdev);\n\tmutex_unlock(&vbg_gdev_mutex);\n}\nEXPORT_SYMBOL(vbg_put_gdev);\n\n/**\n * Callback for mouse events.\n *\n * This is called at the end of the ISR, after leaving the event spinlock, if\n * VMMDEV_EVENT_MOUSE_POSITION_CHANGED was raised by the host.\n *\n * @gdev:\t\tThe device extension.\n */\nvoid vbg_linux_mouse_event(struct vbg_dev *gdev)\n{\n\tint rc;\n\n\t/* Report events to the kernel input device */\n\tgdev->mouse_status_req->mouse_features = 0;\n\tgdev->mouse_status_req->pointer_pos_x = 0;\n\tgdev->mouse_status_req->pointer_pos_y = 0;\n\trc = vbg_req_perform(gdev, gdev->mouse_status_req);\n\tif (rc >= 0) {\n\t\tinput_report_abs(gdev->input, ABS_X,\n\t\t\t\t gdev->mouse_status_req->pointer_pos_x);\n\t\tinput_report_abs(gdev->input, ABS_Y,\n\t\t\t\t gdev->mouse_status_req->pointer_pos_y);\n\t\tinput_sync(gdev->input);\n\t}\n}\n\nstatic const struct pci_device_id vbg_pci_ids[] = {\n\t{ .vendor = VBOX_VENDORID, .device = VMMDEV_DEVICEID },\n\t{}\n};\nMODULE_DEVICE_TABLE(pci,  vbg_pci_ids);\n\nstatic struct pci_driver vbg_pci_driver = {\n\t.name\t\t= DEVICE_NAME,\n\t.id_table\t= vbg_pci_ids,\n\t.probe\t\t= vbg_pci_probe,\n\t.remove\t\t= vbg_pci_remove,\n};\n\nmodule_pci_driver(vbg_pci_driver);\n\nMODULE_AUTHOR(\"Oracle Corporation\");\nMODULE_DESCRIPTION(\"Oracle VM VirtualBox Guest Additions for Linux Module\");\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["drivers/virt/vboxguest/vboxguest_linux.c"], "buggy_code_start_loc": [124], "buggy_code_end_loc": [125], "fixing_code_start_loc": [124], "fixing_code_end_loc": [127], "type": "CWE-362", "message": "An issue was discovered in the Linux kernel through 4.17.2. vbg_misc_device_ioctl() in drivers/virt/vboxguest/vboxguest_linux.c reads the same user data twice with copy_from_user. The header part of the user data is double-fetched, and a malicious user thread can tamper with the critical variables (hdr.size_in and hdr.size_out) in the header between the two fetches because of a race condition, leading to severe kernel errors, such as buffer over-accesses. This bug can cause a local denial of service and information leakage.", "other": {"cve": {"id": "CVE-2018-12633", "sourceIdentifier": "cve@mitre.org", "published": "2018-06-22T00:29:00.270", "lastModified": "2018-08-21T15:42:37.667", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in the Linux kernel through 4.17.2. vbg_misc_device_ioctl() in drivers/virt/vboxguest/vboxguest_linux.c reads the same user data twice with copy_from_user. The header part of the user data is double-fetched, and a malicious user thread can tamper with the critical variables (hdr.size_in and hdr.size_out) in the header between the two fetches because of a race condition, leading to severe kernel errors, such as buffer over-accesses. This bug can cause a local denial of service and information leakage."}, {"lang": "es", "value": "Se ha descubierto un problema en el kernel de Linux hasta la versi\u00f3n 4.17.2. vbg_misc_device_ioctl() en drivers/virt/vboxguest/vboxguest_linux.c lee los mismos datos de usuario dos veces con copy_from_user. La cabecera de los datos de usuario es de tipo double-fetch y un hilo de usuario malicioso puede falsificar las variables cr\u00edticas (hdr.size_in y hdr.size_out) en la cabecera entre los dos fetch debido a una condici\u00f3n de carrera. Esto desemboca en varios errores del kernel, como accesos espec\u00edficos al b\u00fafer. Este error puede provocar una denegaci\u00f3n de servicio (DoS) local y una fuga de informaci\u00f3n."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 6.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 9.2, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.17.2", "matchCriteriaId": "A7B1384E-833A-4422-A6B1-F80FB3EA20B6"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=bd23a7269834dc7c1f93e83535d16ebc44b75eba", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://bugzilla.kernel.org/show_bug.cgi?id=200131", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/bd23a7269834dc7c1f93e83535d16ebc44b75eba", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/bd23a7269834dc7c1f93e83535d16ebc44b75eba"}}