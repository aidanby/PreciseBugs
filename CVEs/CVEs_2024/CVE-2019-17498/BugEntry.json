{"buggy_code": ["/* Copyright (c) 2004-2007, Sara Golemon <sarag@libssh2.org>\n * Copyright (c) 2005,2006 Mikhail Gusarov\n * Copyright (c) 2009-2014 by Daniel Stenberg\n * Copyright (c) 2010 Simon Josefsson\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms,\n * with or without modification, are permitted provided\n * that the following conditions are met:\n *\n *   Redistributions of source code must retain the above\n *   copyright notice, this list of conditions and the\n *   following disclaimer.\n *\n *   Redistributions in binary form must reproduce the above\n *   copyright notice, this list of conditions and the following\n *   disclaimer in the documentation and/or other materials\n *   provided with the distribution.\n *\n *   Neither the name of the copyright holder nor the names\n *   of any other contributors may be used to endorse or\n *   promote products derived from this software without\n *   specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\n * CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\n * OF SUCH DAMAGE.\n */\n\n#include \"libssh2_priv.h\"\n#include <errno.h>\n#include <fcntl.h>\n\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n\n#ifdef HAVE_INTTYPES_H\n#include <inttypes.h>\n#endif\n\n/* Needed for struct iovec on some platforms */\n#ifdef HAVE_SYS_UIO_H\n#include <sys/uio.h>\n#endif\n\n#include <sys/types.h>\n\n#include \"transport.h\"\n#include \"channel.h\"\n#include \"packet.h\"\n\n/*\n * libssh2_packet_queue_listener\n *\n * Queue a connection request for a listener\n */\nstatic inline int\npacket_queue_listener(LIBSSH2_SESSION * session, unsigned char *data,\n                      unsigned long datalen,\n                      packet_queue_listener_state_t *listen_state)\n{\n    /*\n     * Look for a matching listener\n     */\n    /* 17 = packet_type(1) + channel(4) + reason(4) + descr(4) + lang(4) */\n    unsigned long packet_len = 17 + (sizeof(FwdNotReq) - 1);\n    unsigned char *p;\n    LIBSSH2_LISTENER *listn = _libssh2_list_first(&session->listeners);\n    char failure_code = SSH_OPEN_ADMINISTRATIVELY_PROHIBITED;\n    int rc;\n\n    (void) datalen;\n\n    if(listen_state->state == libssh2_NB_state_idle) {\n        unsigned char *s = data + (sizeof(\"forwarded-tcpip\") - 1) + 5;\n        listen_state->sender_channel = _libssh2_ntohu32(s);\n        s += 4;\n\n        listen_state->initial_window_size = _libssh2_ntohu32(s);\n        s += 4;\n        listen_state->packet_size = _libssh2_ntohu32(s);\n        s += 4;\n\n        listen_state->host_len = _libssh2_ntohu32(s);\n        s += 4;\n        listen_state->host = s;\n        s += listen_state->host_len;\n        listen_state->port = _libssh2_ntohu32(s);\n        s += 4;\n\n        listen_state->shost_len = _libssh2_ntohu32(s);\n        s += 4;\n        listen_state->shost = s;\n        s += listen_state->shost_len;\n        listen_state->sport = _libssh2_ntohu32(s);\n\n        _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                       \"Remote received connection from %s:%ld to %s:%ld\",\n                       listen_state->shost, listen_state->sport,\n                       listen_state->host, listen_state->port);\n\n        listen_state->state = libssh2_NB_state_allocated;\n    }\n\n    if(listen_state->state != libssh2_NB_state_sent) {\n        while(listn) {\n            if((listn->port == (int) listen_state->port) &&\n                (strlen(listn->host) == listen_state->host_len) &&\n                (memcmp (listn->host, listen_state->host,\n                         listen_state->host_len) == 0)) {\n                /* This is our listener */\n                LIBSSH2_CHANNEL *channel = NULL;\n                listen_state->channel = NULL;\n\n                if(listen_state->state == libssh2_NB_state_allocated) {\n                    if(listn->queue_maxsize &&\n                        (listn->queue_maxsize <= listn->queue_size)) {\n                        /* Queue is full */\n                        failure_code = SSH_OPEN_RESOURCE_SHORTAGE;\n                        _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                                       \"Listener queue full, ignoring\");\n                        listen_state->state = libssh2_NB_state_sent;\n                        break;\n                    }\n\n                    channel = LIBSSH2_CALLOC(session, sizeof(LIBSSH2_CHANNEL));\n                    if(!channel) {\n                        _libssh2_error(session, LIBSSH2_ERROR_ALLOC,\n                                       \"Unable to allocate a channel for \"\n                                       \"new connection\");\n                        failure_code = SSH_OPEN_RESOURCE_SHORTAGE;\n                        listen_state->state = libssh2_NB_state_sent;\n                        break;\n                    }\n                    listen_state->channel = channel;\n\n                    channel->session = session;\n                    channel->channel_type_len = sizeof(\"forwarded-tcpip\") - 1;\n                    channel->channel_type = LIBSSH2_ALLOC(session,\n                                                          channel->\n                                                          channel_type_len +\n                                                          1);\n                    if(!channel->channel_type) {\n                        _libssh2_error(session, LIBSSH2_ERROR_ALLOC,\n                                       \"Unable to allocate a channel for new\"\n                                       \" connection\");\n                        LIBSSH2_FREE(session, channel);\n                        failure_code = SSH_OPEN_RESOURCE_SHORTAGE;\n                        listen_state->state = libssh2_NB_state_sent;\n                        break;\n                    }\n                    memcpy(channel->channel_type, \"forwarded-tcpip\",\n                           channel->channel_type_len + 1);\n\n                    channel->remote.id = listen_state->sender_channel;\n                    channel->remote.window_size_initial =\n                        LIBSSH2_CHANNEL_WINDOW_DEFAULT;\n                    channel->remote.window_size =\n                        LIBSSH2_CHANNEL_WINDOW_DEFAULT;\n                    channel->remote.packet_size =\n                        LIBSSH2_CHANNEL_PACKET_DEFAULT;\n\n                    channel->local.id = _libssh2_channel_nextid(session);\n                    channel->local.window_size_initial =\n                        listen_state->initial_window_size;\n                    channel->local.window_size =\n                        listen_state->initial_window_size;\n                    channel->local.packet_size = listen_state->packet_size;\n\n                    _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                                   \"Connection queued: channel %lu/%lu \"\n                                   \"win %lu/%lu packet %lu/%lu\",\n                                   channel->local.id, channel->remote.id,\n                                   channel->local.window_size,\n                                   channel->remote.window_size,\n                                   channel->local.packet_size,\n                                   channel->remote.packet_size);\n\n                    p = listen_state->packet;\n                    *(p++) = SSH_MSG_CHANNEL_OPEN_CONFIRMATION;\n                    _libssh2_store_u32(&p, channel->remote.id);\n                    _libssh2_store_u32(&p, channel->local.id);\n                    _libssh2_store_u32(&p,\n                                       channel->remote.window_size_initial);\n                    _libssh2_store_u32(&p, channel->remote.packet_size);\n\n                    listen_state->state = libssh2_NB_state_created;\n                }\n\n                if(listen_state->state == libssh2_NB_state_created) {\n                    rc = _libssh2_transport_send(session, listen_state->packet,\n                                                 17, NULL, 0);\n                    if(rc == LIBSSH2_ERROR_EAGAIN)\n                        return rc;\n                    else if(rc) {\n                        listen_state->state = libssh2_NB_state_idle;\n                        return _libssh2_error(session, rc,\n                                              \"Unable to send channel \"\n                                              \"open confirmation\");\n                    }\n\n                    /* Link the channel into the end of the queue list */\n                    if(listen_state->channel) {\n                        _libssh2_list_add(&listn->queue,\n                                          &listen_state->channel->node);\n                        listn->queue_size++;\n                    }\n\n                    listen_state->state = libssh2_NB_state_idle;\n                    return 0;\n                }\n            }\n\n            listn = _libssh2_list_next(&listn->node);\n        }\n\n        listen_state->state = libssh2_NB_state_sent;\n    }\n\n    /* We're not listening to you */\n    p = listen_state->packet;\n    *(p++) = SSH_MSG_CHANNEL_OPEN_FAILURE;\n    _libssh2_store_u32(&p, listen_state->sender_channel);\n    _libssh2_store_u32(&p, failure_code);\n    _libssh2_store_str(&p, FwdNotReq, sizeof(FwdNotReq) - 1);\n    _libssh2_htonu32(p, 0);\n\n    rc = _libssh2_transport_send(session, listen_state->packet,\n                                 packet_len, NULL, 0);\n    if(rc == LIBSSH2_ERROR_EAGAIN) {\n        return rc;\n    }\n    else if(rc) {\n        listen_state->state = libssh2_NB_state_idle;\n        return _libssh2_error(session, rc, \"Unable to send open failure\");\n\n    }\n    listen_state->state = libssh2_NB_state_idle;\n    return 0;\n}\n\n/*\n * packet_x11_open\n *\n * Accept a forwarded X11 connection\n */\nstatic inline int\npacket_x11_open(LIBSSH2_SESSION * session, unsigned char *data,\n                unsigned long datalen,\n                packet_x11_open_state_t *x11open_state)\n{\n    int failure_code = SSH_OPEN_CONNECT_FAILED;\n    /* 17 = packet_type(1) + channel(4) + reason(4) + descr(4) + lang(4) */\n    unsigned long packet_len = 17 + (sizeof(X11FwdUnAvil) - 1);\n    unsigned char *p;\n    LIBSSH2_CHANNEL *channel = x11open_state->channel;\n    int rc;\n\n    (void) datalen;\n\n    if(x11open_state->state == libssh2_NB_state_idle) {\n        unsigned char *s = data + (sizeof(\"x11\") - 1) + 5;\n        x11open_state->sender_channel = _libssh2_ntohu32(s);\n        s += 4;\n        x11open_state->initial_window_size = _libssh2_ntohu32(s);\n        s += 4;\n        x11open_state->packet_size = _libssh2_ntohu32(s);\n        s += 4;\n        x11open_state->shost_len = _libssh2_ntohu32(s);\n        s += 4;\n        x11open_state->shost = s;\n        s += x11open_state->shost_len;\n        x11open_state->sport = _libssh2_ntohu32(s);\n\n        _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                       \"X11 Connection Received from %s:%ld on channel %lu\",\n                       x11open_state->shost, x11open_state->sport,\n                       x11open_state->sender_channel);\n\n        x11open_state->state = libssh2_NB_state_allocated;\n    }\n\n    if(session->x11) {\n        if(x11open_state->state == libssh2_NB_state_allocated) {\n            channel = LIBSSH2_CALLOC(session, sizeof(LIBSSH2_CHANNEL));\n            if(!channel) {\n                _libssh2_error(session, LIBSSH2_ERROR_ALLOC,\n                               \"allocate a channel for new connection\");\n                failure_code = SSH_OPEN_RESOURCE_SHORTAGE;\n                goto x11_exit;\n            }\n\n            channel->session = session;\n            channel->channel_type_len = sizeof(\"x11\") - 1;\n            channel->channel_type = LIBSSH2_ALLOC(session,\n                                                  channel->channel_type_len +\n                                                  1);\n            if(!channel->channel_type) {\n                _libssh2_error(session, LIBSSH2_ERROR_ALLOC,\n                               \"allocate a channel for new connection\");\n                LIBSSH2_FREE(session, channel);\n                failure_code = SSH_OPEN_RESOURCE_SHORTAGE;\n                goto x11_exit;\n            }\n            memcpy(channel->channel_type, \"x11\",\n                   channel->channel_type_len + 1);\n\n            channel->remote.id = x11open_state->sender_channel;\n            channel->remote.window_size_initial =\n                LIBSSH2_CHANNEL_WINDOW_DEFAULT;\n            channel->remote.window_size = LIBSSH2_CHANNEL_WINDOW_DEFAULT;\n            channel->remote.packet_size = LIBSSH2_CHANNEL_PACKET_DEFAULT;\n\n            channel->local.id = _libssh2_channel_nextid(session);\n            channel->local.window_size_initial =\n                x11open_state->initial_window_size;\n            channel->local.window_size = x11open_state->initial_window_size;\n            channel->local.packet_size = x11open_state->packet_size;\n\n            _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                           \"X11 Connection established: channel %lu/%lu \"\n                           \"win %lu/%lu packet %lu/%lu\",\n                           channel->local.id, channel->remote.id,\n                           channel->local.window_size,\n                           channel->remote.window_size,\n                           channel->local.packet_size,\n                           channel->remote.packet_size);\n            p = x11open_state->packet;\n            *(p++) = SSH_MSG_CHANNEL_OPEN_CONFIRMATION;\n            _libssh2_store_u32(&p, channel->remote.id);\n            _libssh2_store_u32(&p, channel->local.id);\n            _libssh2_store_u32(&p, channel->remote.window_size_initial);\n            _libssh2_store_u32(&p, channel->remote.packet_size);\n\n            x11open_state->state = libssh2_NB_state_created;\n        }\n\n        if(x11open_state->state == libssh2_NB_state_created) {\n            rc = _libssh2_transport_send(session, x11open_state->packet, 17,\n                                         NULL, 0);\n            if(rc == LIBSSH2_ERROR_EAGAIN) {\n                return rc;\n            }\n            else if(rc) {\n                x11open_state->state = libssh2_NB_state_idle;\n                return _libssh2_error(session, LIBSSH2_ERROR_SOCKET_SEND,\n                                      \"Unable to send channel open \"\n                                      \"confirmation\");\n            }\n\n            /* Link the channel into the session */\n            _libssh2_list_add(&session->channels, &channel->node);\n\n            /*\n             * Pass control to the callback, they may turn right around and\n             * free the channel, or actually use it\n             */\n            LIBSSH2_X11_OPEN(channel, (char *)x11open_state->shost,\n                             x11open_state->sport);\n\n            x11open_state->state = libssh2_NB_state_idle;\n            return 0;\n        }\n    }\n    else\n        failure_code = SSH_OPEN_RESOURCE_SHORTAGE;\n    /* fall-trough */\n  x11_exit:\n    p = x11open_state->packet;\n    *(p++) = SSH_MSG_CHANNEL_OPEN_FAILURE;\n    _libssh2_store_u32(&p, x11open_state->sender_channel);\n    _libssh2_store_u32(&p, failure_code);\n    _libssh2_store_str(&p, X11FwdUnAvil, sizeof(X11FwdUnAvil) - 1);\n    _libssh2_htonu32(p, 0);\n\n    rc = _libssh2_transport_send(session, x11open_state->packet, packet_len,\n                                 NULL, 0);\n    if(rc == LIBSSH2_ERROR_EAGAIN) {\n        return rc;\n    }\n    else if(rc) {\n        x11open_state->state = libssh2_NB_state_idle;\n        return _libssh2_error(session, rc, \"Unable to send open failure\");\n    }\n    x11open_state->state = libssh2_NB_state_idle;\n    return 0;\n}\n\n/*\n * _libssh2_packet_add\n *\n * Create a new packet and attach it to the brigade. Called from the transport\n * layer when it has received a packet.\n *\n * The input pointer 'data' is pointing to allocated data that this function\n * is asked to deal with so on failure OR success, it must be freed fine.\n * The only exception is when the return code is LIBSSH2_ERROR_EAGAIN.\n *\n * This function will always be called with 'datalen' greater than zero.\n */\nint\n_libssh2_packet_add(LIBSSH2_SESSION * session, unsigned char *data,\n                    size_t datalen, int macstate)\n{\n    int rc = 0;\n    char *message = NULL;\n    char *language = NULL;\n    size_t message_len = 0;\n    size_t language_len = 0;\n    LIBSSH2_CHANNEL *channelp = NULL;\n    size_t data_head = 0;\n    unsigned char msg = data[0];\n\n    switch(session->packAdd_state) {\n    case libssh2_NB_state_idle:\n        _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                       \"Packet type %d received, length=%d\",\n                       (int) msg, (int) datalen);\n\n        if((macstate == LIBSSH2_MAC_INVALID) &&\n            (!session->macerror ||\n             LIBSSH2_MACERROR(session, (char *) data, datalen))) {\n            /* Bad MAC input, but no callback set or non-zero return from the\n               callback */\n\n            LIBSSH2_FREE(session, data);\n            return _libssh2_error(session, LIBSSH2_ERROR_INVALID_MAC,\n                                  \"Invalid MAC received\");\n        }\n        session->packAdd_state = libssh2_NB_state_allocated;\n        break;\n    case libssh2_NB_state_jump1:\n        goto libssh2_packet_add_jump_point1;\n    case libssh2_NB_state_jump2:\n        goto libssh2_packet_add_jump_point2;\n    case libssh2_NB_state_jump3:\n        goto libssh2_packet_add_jump_point3;\n    case libssh2_NB_state_jump4:\n        goto libssh2_packet_add_jump_point4;\n    case libssh2_NB_state_jump5:\n        goto libssh2_packet_add_jump_point5;\n    default: /* nothing to do */\n        break;\n    }\n\n    if(session->packAdd_state == libssh2_NB_state_allocated) {\n        /* A couple exceptions to the packet adding rule: */\n        switch(msg) {\n\n            /*\n              byte      SSH_MSG_DISCONNECT\n              uint32    reason code\n              string    description in ISO-10646 UTF-8 encoding [RFC3629]\n              string    language tag [RFC3066]\n            */\n\n        case SSH_MSG_DISCONNECT:\n            if(datalen >= 5) {\n                size_t reason = _libssh2_ntohu32(data + 1);\n\n                if(datalen >= 9) {\n                    message_len = _libssh2_ntohu32(data + 5);\n\n                    if(message_len < datalen-13) {\n                        /* 9 = packet_type(1) + reason(4) + message_len(4) */\n                        message = (char *) data + 9;\n\n                        language_len =\n                            _libssh2_ntohu32(data + 9 + message_len);\n                        language = (char *) data + 9 + message_len + 4;\n\n                        if(language_len > (datalen-13-message_len)) {\n                            /* bad input, clear info */\n                            language = message = NULL;\n                            language_len = message_len = 0;\n                        }\n                    }\n                    else\n                        /* bad size, clear it */\n                        message_len = 0;\n                }\n                if(session->ssh_msg_disconnect) {\n                    LIBSSH2_DISCONNECT(session, reason, message,\n                                       message_len, language, language_len);\n                }\n                _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                               \"Disconnect(%d): %s(%s)\", reason,\n                               message, language);\n            }\n\n            LIBSSH2_FREE(session, data);\n            session->socket_state = LIBSSH2_SOCKET_DISCONNECTED;\n            session->packAdd_state = libssh2_NB_state_idle;\n            return _libssh2_error(session, LIBSSH2_ERROR_SOCKET_DISCONNECT,\n                                  \"socket disconnect\");\n            /*\n              byte      SSH_MSG_IGNORE\n              string    data\n            */\n\n        case SSH_MSG_IGNORE:\n            if(datalen >= 2) {\n                if(session->ssh_msg_ignore) {\n                    LIBSSH2_IGNORE(session, (char *) data + 1, datalen - 1);\n                }\n            }\n            else if(session->ssh_msg_ignore) {\n                LIBSSH2_IGNORE(session, \"\", 0);\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_DEBUG\n              boolean   always_display\n              string    message in ISO-10646 UTF-8 encoding [RFC3629]\n              string    language tag [RFC3066]\n            */\n\n        case SSH_MSG_DEBUG:\n            if(datalen >= 2) {\n                int always_display = data[1];\n\n                if(datalen >= 6) {\n                    message_len = _libssh2_ntohu32(data + 2);\n\n                    if(message_len <= (datalen - 10)) {\n                        /* 6 = packet_type(1) + display(1) + message_len(4) */\n                        message = (char *) data + 6;\n                        language_len = _libssh2_ntohu32(data + 6 +\n                                                        message_len);\n\n                        if(language_len <= (datalen - 10 - message_len))\n                            language = (char *) data + 10 + message_len;\n                    }\n                }\n\n                if(session->ssh_msg_debug) {\n                    LIBSSH2_DEBUG(session, always_display, message,\n                                  message_len, language, language_len);\n                }\n            }\n            /*\n             * _libssh2_debug will actually truncate this for us so\n             * that it's not an inordinate about of data\n             */\n            _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                           \"Debug Packet: %s\", message);\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_GLOBAL_REQUEST\n              string    request name in US-ASCII only\n              boolean   want reply\n              ....      request-specific data follows\n            */\n\n        case SSH_MSG_GLOBAL_REQUEST:\n            if(datalen >= 5) {\n                uint32_t len = 0;\n                unsigned char want_reply = 0;\n                len = _libssh2_ntohu32(data + 1);\n                if(datalen >= (6 + len)) {\n                    want_reply = data[5 + len];\n                    _libssh2_debug(session,\n                                   LIBSSH2_TRACE_CONN,\n                                   \"Received global request type %.*s (wr %X)\",\n                                   len, data + 5, want_reply);\n                }\n\n\n                if(want_reply) {\n                    static const unsigned char packet =\n                        SSH_MSG_REQUEST_FAILURE;\n                  libssh2_packet_add_jump_point5:\n                    session->packAdd_state = libssh2_NB_state_jump5;\n                    rc = _libssh2_transport_send(session, &packet, 1, NULL, 0);\n                    if(rc == LIBSSH2_ERROR_EAGAIN)\n                        return rc;\n                }\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_CHANNEL_EXTENDED_DATA\n              uint32    recipient channel\n              uint32    data_type_code\n              string    data\n            */\n\n        case SSH_MSG_CHANNEL_EXTENDED_DATA:\n            /* streamid(4) */\n            data_head += 4;\n\n            /* fall-through */\n\n            /*\n              byte      SSH_MSG_CHANNEL_DATA\n              uint32    recipient channel\n              string    data\n            */\n\n        case SSH_MSG_CHANNEL_DATA:\n            /* packet_type(1) + channelno(4) + datalen(4) */\n            data_head += 9;\n\n            if(datalen >= data_head)\n                channelp =\n                    _libssh2_channel_locate(session,\n                                            _libssh2_ntohu32(data + 1));\n\n            if(!channelp) {\n                _libssh2_error(session, LIBSSH2_ERROR_CHANNEL_UNKNOWN,\n                               \"Packet received for unknown channel\");\n                LIBSSH2_FREE(session, data);\n                session->packAdd_state = libssh2_NB_state_idle;\n                return 0;\n            }\n#ifdef LIBSSH2DEBUG\n            {\n                uint32_t stream_id = 0;\n                if(msg == SSH_MSG_CHANNEL_EXTENDED_DATA)\n                    stream_id = _libssh2_ntohu32(data + 5);\n\n                _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                               \"%d bytes packet_add() for %lu/%lu/%lu\",\n                               (int) (datalen - data_head),\n                               channelp->local.id,\n                               channelp->remote.id,\n                               stream_id);\n            }\n#endif\n            if((channelp->remote.extended_data_ignore_mode ==\n                 LIBSSH2_CHANNEL_EXTENDED_DATA_IGNORE) &&\n                (msg == SSH_MSG_CHANNEL_EXTENDED_DATA)) {\n                /* Pretend we didn't receive this */\n                LIBSSH2_FREE(session, data);\n\n                _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                               \"Ignoring extended data and refunding %d bytes\",\n                               (int) (datalen - 13));\n                if(channelp->read_avail + datalen - data_head >=\n                    channelp->remote.window_size)\n                    datalen = channelp->remote.window_size -\n                        channelp->read_avail + data_head;\n\n                channelp->remote.window_size -= datalen - data_head;\n                _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                               \"shrinking window size by %lu bytes to %lu, \"\n                               \"read_avail %lu\",\n                               datalen - data_head,\n                               channelp->remote.window_size,\n                               channelp->read_avail);\n\n                session->packAdd_channelp = channelp;\n\n                /* Adjust the window based on the block we just freed */\n              libssh2_packet_add_jump_point1:\n                session->packAdd_state = libssh2_NB_state_jump1;\n                rc = _libssh2_channel_receive_window_adjust(session->\n                                                            packAdd_channelp,\n                                                            datalen - 13,\n                                                            1, NULL);\n                if(rc == LIBSSH2_ERROR_EAGAIN)\n                    return rc;\n\n                session->packAdd_state = libssh2_NB_state_idle;\n                return 0;\n            }\n\n            /*\n             * REMEMBER! remote means remote as source of data,\n             * NOT remote window!\n             */\n            if(channelp->remote.packet_size < (datalen - data_head)) {\n                /*\n                 * Spec says we MAY ignore bytes sent beyond\n                 * packet_size\n                 */\n                _libssh2_error(session,\n                               LIBSSH2_ERROR_CHANNEL_PACKET_EXCEEDED,\n                               \"Packet contains more data than we offered\"\n                               \" to receive, truncating\");\n                datalen = channelp->remote.packet_size + data_head;\n            }\n            if(channelp->remote.window_size <= channelp->read_avail) {\n                /*\n                 * Spec says we MAY ignore bytes sent beyond\n                 * window_size\n                 */\n                _libssh2_error(session,\n                               LIBSSH2_ERROR_CHANNEL_WINDOW_EXCEEDED,\n                               \"The current receive window is full,\"\n                               \" data ignored\");\n                LIBSSH2_FREE(session, data);\n                session->packAdd_state = libssh2_NB_state_idle;\n                return 0;\n            }\n            /* Reset EOF status */\n            channelp->remote.eof = 0;\n\n            if(channelp->read_avail + datalen - data_head >\n                channelp->remote.window_size) {\n                _libssh2_error(session,\n                               LIBSSH2_ERROR_CHANNEL_WINDOW_EXCEEDED,\n                               \"Remote sent more data than current \"\n                               \"window allows, truncating\");\n                datalen = channelp->remote.window_size -\n                    channelp->read_avail + data_head;\n            }\n\n            /* Update the read_avail counter. The window size will be\n             * updated once the data is actually read from the queue\n             * from an upper layer */\n            channelp->read_avail += datalen - data_head;\n\n            _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                           \"increasing read_avail by %lu bytes to %lu/%lu\",\n                           (long)(datalen - data_head),\n                           (long)channelp->read_avail,\n                           (long)channelp->remote.window_size);\n\n            break;\n\n            /*\n              byte      SSH_MSG_CHANNEL_EOF\n              uint32    recipient channel\n            */\n\n        case SSH_MSG_CHANNEL_EOF:\n            if(datalen >= 5)\n                channelp =\n                    _libssh2_channel_locate(session,\n                                            _libssh2_ntohu32(data + 1));\n            if(!channelp)\n                /* We may have freed already, just quietly ignore this... */\n                ;\n            else {\n                _libssh2_debug(session,\n                               LIBSSH2_TRACE_CONN,\n                               \"EOF received for channel %lu/%lu\",\n                               channelp->local.id,\n                               channelp->remote.id);\n                channelp->remote.eof = 1;\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_CHANNEL_REQUEST\n              uint32    recipient channel\n              string    request type in US-ASCII characters only\n              boolean   want reply\n              ....      type-specific data follows\n            */\n\n        case SSH_MSG_CHANNEL_REQUEST:\n            if(datalen >= 9) {\n                uint32_t channel = _libssh2_ntohu32(data + 1);\n                uint32_t len = _libssh2_ntohu32(data + 5);\n                unsigned char want_reply = 1;\n\n                if((len + 9) < datalen)\n                    want_reply = data[len + 9];\n\n                _libssh2_debug(session,\n                               LIBSSH2_TRACE_CONN,\n                               \"Channel %d received request type %.*s (wr %X)\",\n                               channel, len, data + 9, want_reply);\n\n                if(len == sizeof(\"exit-status\") - 1\n                    && (sizeof(\"exit-status\") - 1 + 9) <= datalen\n                    && !memcmp(\"exit-status\", data + 9,\n                               sizeof(\"exit-status\") - 1)) {\n\n                    /* we've got \"exit-status\" packet. Set the session value */\n                    if(datalen >= 20)\n                        channelp =\n                            _libssh2_channel_locate(session, channel);\n\n                    if(channelp && (sizeof(\"exit-status\") + 13) <= datalen) {\n                        channelp->exit_status =\n                            _libssh2_ntohu32(data + 9 + sizeof(\"exit-status\"));\n                        _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                                       \"Exit status %lu received for \"\n                                       \"channel %lu/%lu\",\n                                       channelp->exit_status,\n                                       channelp->local.id,\n                                       channelp->remote.id);\n                    }\n\n                }\n                else if(len == sizeof(\"exit-signal\") - 1\n                         && (sizeof(\"exit-signal\") - 1 + 9) <= datalen\n                         && !memcmp(\"exit-signal\", data + 9,\n                                    sizeof(\"exit-signal\") - 1)) {\n                    /* command terminated due to signal */\n                    if(datalen >= 20)\n                        channelp = _libssh2_channel_locate(session, channel);\n\n                    if(channelp && (sizeof(\"exit-signal\") + 13) <= datalen) {\n                        /* set signal name (without SIG prefix) */\n                        uint32_t namelen =\n                            _libssh2_ntohu32(data + 9 + sizeof(\"exit-signal\"));\n\n                        if(namelen <= UINT_MAX - 1) {\n                            channelp->exit_signal =\n                                LIBSSH2_ALLOC(session, namelen + 1);\n                        }\n                        else {\n                            channelp->exit_signal = NULL;\n                        }\n\n                        if(!channelp->exit_signal)\n                            rc = _libssh2_error(session, LIBSSH2_ERROR_ALLOC,\n                                                \"memory for signal name\");\n                        else if((sizeof(\"exit-signal\") + 13 + namelen <=\n                                 datalen)) {\n                            memcpy(channelp->exit_signal,\n                                   data + 13 + sizeof(\"exit-signal\"), namelen);\n                            channelp->exit_signal[namelen] = '\\0';\n                            /* TODO: save error message and language tag */\n                            _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                                           \"Exit signal %s received for \"\n                                           \"channel %lu/%lu\",\n                                           channelp->exit_signal,\n                                           channelp->local.id,\n                                           channelp->remote.id);\n                        }\n                    }\n                }\n\n\n                if(want_reply) {\n                    unsigned char packet[5];\n                  libssh2_packet_add_jump_point4:\n                    session->packAdd_state = libssh2_NB_state_jump4;\n                    packet[0] = SSH_MSG_CHANNEL_FAILURE;\n                    memcpy(&packet[1], data + 1, 4);\n                    rc = _libssh2_transport_send(session, packet, 5, NULL, 0);\n                    if(rc == LIBSSH2_ERROR_EAGAIN)\n                        return rc;\n                }\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return rc;\n\n            /*\n              byte      SSH_MSG_CHANNEL_CLOSE\n              uint32    recipient channel\n            */\n\n        case SSH_MSG_CHANNEL_CLOSE:\n            if(datalen >= 5)\n                channelp =\n                    _libssh2_channel_locate(session,\n                                            _libssh2_ntohu32(data + 1));\n            if(!channelp) {\n                /* We may have freed already, just quietly ignore this... */\n                LIBSSH2_FREE(session, data);\n                session->packAdd_state = libssh2_NB_state_idle;\n                return 0;\n            }\n            _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                           \"Close received for channel %lu/%lu\",\n                           channelp->local.id,\n                           channelp->remote.id);\n\n            channelp->remote.close = 1;\n            channelp->remote.eof = 1;\n\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_CHANNEL_OPEN\n              string    \"session\"\n              uint32    sender channel\n              uint32    initial window size\n              uint32    maximum packet size\n            */\n\n        case SSH_MSG_CHANNEL_OPEN:\n            if(datalen < 17)\n                ;\n            else if((datalen >= (sizeof(\"forwarded-tcpip\") + 4)) &&\n                     ((sizeof(\"forwarded-tcpip\") - 1) ==\n                      _libssh2_ntohu32(data + 1))\n                     &&\n                     (memcmp(data + 5, \"forwarded-tcpip\",\n                             sizeof(\"forwarded-tcpip\") - 1) == 0)) {\n\n                /* init the state struct */\n                memset(&session->packAdd_Qlstn_state, 0,\n                       sizeof(session->packAdd_Qlstn_state));\n\n              libssh2_packet_add_jump_point2:\n                session->packAdd_state = libssh2_NB_state_jump2;\n                rc = packet_queue_listener(session, data, datalen,\n                                           &session->packAdd_Qlstn_state);\n            }\n            else if((datalen >= (sizeof(\"x11\") + 4)) &&\n                     ((sizeof(\"x11\") - 1) == _libssh2_ntohu32(data + 1)) &&\n                     (memcmp(data + 5, \"x11\", sizeof(\"x11\") - 1) == 0)) {\n\n                /* init the state struct */\n                memset(&session->packAdd_x11open_state, 0,\n                       sizeof(session->packAdd_x11open_state));\n\n              libssh2_packet_add_jump_point3:\n                session->packAdd_state = libssh2_NB_state_jump3;\n                rc = packet_x11_open(session, data, datalen,\n                                     &session->packAdd_x11open_state);\n            }\n            if(rc == LIBSSH2_ERROR_EAGAIN)\n                return rc;\n\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return rc;\n\n            /*\n              byte      SSH_MSG_CHANNEL_WINDOW_ADJUST\n              uint32    recipient channel\n              uint32    bytes to add\n            */\n        case SSH_MSG_CHANNEL_WINDOW_ADJUST:\n            if(datalen < 9)\n                ;\n            else {\n                uint32_t bytestoadd = _libssh2_ntohu32(data + 5);\n                channelp =\n                    _libssh2_channel_locate(session,\n                                            _libssh2_ntohu32(data + 1));\n                if(channelp) {\n                    channelp->local.window_size += bytestoadd;\n\n                    _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                                   \"Window adjust for channel %lu/%lu, \"\n                                   \"adding %lu bytes, new window_size=%lu\",\n                                   channelp->local.id,\n                                   channelp->remote.id,\n                                   bytestoadd,\n                                   channelp->local.window_size);\n                }\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n        default:\n            break;\n        }\n\n        session->packAdd_state = libssh2_NB_state_sent;\n    }\n\n    if(session->packAdd_state == libssh2_NB_state_sent) {\n        LIBSSH2_PACKET *packetp =\n            LIBSSH2_ALLOC(session, sizeof(LIBSSH2_PACKET));\n        if(!packetp) {\n            _libssh2_debug(session, LIBSSH2_ERROR_ALLOC,\n                           \"memory for packet\");\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return LIBSSH2_ERROR_ALLOC;\n        }\n        packetp->data = data;\n        packetp->data_len = datalen;\n        packetp->data_head = data_head;\n\n        _libssh2_list_add(&session->packets, &packetp->node);\n\n        session->packAdd_state = libssh2_NB_state_sent1;\n    }\n\n    if((msg == SSH_MSG_KEXINIT &&\n         !(session->state & LIBSSH2_STATE_EXCHANGING_KEYS)) ||\n        (session->packAdd_state == libssh2_NB_state_sent2)) {\n        if(session->packAdd_state == libssh2_NB_state_sent1) {\n            /*\n             * Remote wants new keys\n             * Well, it's already in the brigade,\n             * let's just call back into ourselves\n             */\n            _libssh2_debug(session, LIBSSH2_TRACE_TRANS, \"Renegotiating Keys\");\n\n            session->packAdd_state = libssh2_NB_state_sent2;\n        }\n\n        /*\n         * The KEXINIT message has been added to the queue.  The packAdd and\n         * readPack states need to be reset because _libssh2_kex_exchange\n         * (eventually) calls upon _libssh2_transport_read to read the rest of\n         * the key exchange conversation.\n         */\n        session->readPack_state = libssh2_NB_state_idle;\n        session->packet.total_num = 0;\n        session->packAdd_state = libssh2_NB_state_idle;\n        session->fullpacket_state = libssh2_NB_state_idle;\n\n        memset(&session->startup_key_state, 0, sizeof(key_exchange_state_t));\n\n        /*\n         * If there was a key reexchange failure, let's just hope we didn't\n         * send NEWKEYS yet, otherwise remote will drop us like a rock\n         */\n        rc = _libssh2_kex_exchange(session, 1, &session->startup_key_state);\n        if(rc == LIBSSH2_ERROR_EAGAIN)\n            return rc;\n    }\n\n    session->packAdd_state = libssh2_NB_state_idle;\n    return 0;\n}\n\n/*\n * _libssh2_packet_ask\n *\n * Scan the brigade for a matching packet type, optionally poll the socket for\n * a packet first\n */\nint\n_libssh2_packet_ask(LIBSSH2_SESSION * session, unsigned char packet_type,\n                    unsigned char **data, size_t *data_len,\n                    int match_ofs, const unsigned char *match_buf,\n                    size_t match_len)\n{\n    LIBSSH2_PACKET *packet = _libssh2_list_first(&session->packets);\n\n    _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                   \"Looking for packet of type: %d\", (int) packet_type);\n\n    while(packet) {\n        if(packet->data[0] == packet_type\n            && (packet->data_len >= (match_ofs + match_len))\n            && (!match_buf ||\n                (memcmp(packet->data + match_ofs, match_buf,\n                        match_len) == 0))) {\n            *data = packet->data;\n            *data_len = packet->data_len;\n\n            /* unlink struct from session->packets */\n            _libssh2_list_remove(&packet->node);\n\n            LIBSSH2_FREE(session, packet);\n\n            return 0;\n        }\n        packet = _libssh2_list_next(&packet->node);\n    }\n    return -1;\n}\n\n/*\n * libssh2_packet_askv\n *\n * Scan for any of a list of packet types in the brigade, optionally poll the\n * socket for a packet first\n */\nint\n_libssh2_packet_askv(LIBSSH2_SESSION * session,\n                     const unsigned char *packet_types,\n                     unsigned char **data, size_t *data_len,\n                     int match_ofs,\n                     const unsigned char *match_buf,\n                     size_t match_len)\n{\n    int i, packet_types_len = strlen((char *) packet_types);\n\n    for(i = 0; i < packet_types_len; i++) {\n        if(0 == _libssh2_packet_ask(session, packet_types[i], data,\n                                     data_len, match_ofs,\n                                     match_buf, match_len)) {\n            return 0;\n        }\n    }\n\n    return -1;\n}\n\n/*\n * _libssh2_packet_require\n *\n * Loops _libssh2_transport_read() until the packet requested is available\n * SSH_DISCONNECT or a SOCKET_DISCONNECTED will cause a bailout\n *\n * Returns negative on error\n * Returns 0 when it has taken care of the requested packet.\n */\nint\n_libssh2_packet_require(LIBSSH2_SESSION * session, unsigned char packet_type,\n                        unsigned char **data, size_t *data_len,\n                        int match_ofs,\n                        const unsigned char *match_buf,\n                        size_t match_len,\n                        packet_require_state_t *state)\n{\n    if(state->start == 0) {\n        if(_libssh2_packet_ask(session, packet_type, data, data_len,\n                                match_ofs, match_buf,\n                                match_len) == 0) {\n            /* A packet was available in the packet brigade */\n            return 0;\n        }\n\n        state->start = time(NULL);\n    }\n\n    while(session->socket_state == LIBSSH2_SOCKET_CONNECTED) {\n        int ret = _libssh2_transport_read(session);\n        if(ret == LIBSSH2_ERROR_EAGAIN)\n            return ret;\n        else if(ret < 0) {\n            state->start = 0;\n            /* an error which is not just because of blocking */\n            return ret;\n        }\n        else if(ret == packet_type) {\n            /* Be lazy, let packet_ask pull it out of the brigade */\n            ret = _libssh2_packet_ask(session, packet_type, data, data_len,\n                                      match_ofs, match_buf, match_len);\n            state->start = 0;\n            return ret;\n        }\n        else if(ret == 0) {\n            /* nothing available, wait until data arrives or we time out */\n            long left = LIBSSH2_READ_TIMEOUT - (long)(time(NULL) -\n                                                      state->start);\n\n            if(left <= 0) {\n                state->start = 0;\n                return LIBSSH2_ERROR_TIMEOUT;\n            }\n            return -1; /* no packet available yet */\n        }\n    }\n\n    /* Only reached if the socket died */\n    return LIBSSH2_ERROR_SOCKET_DISCONNECT;\n}\n\n/*\n * _libssh2_packet_burn\n *\n * Loops _libssh2_transport_read() until any packet is available and promptly\n * discards it.\n * Used during KEX exchange to discard badly guessed KEX_INIT packets\n */\nint\n_libssh2_packet_burn(LIBSSH2_SESSION * session,\n                     libssh2_nonblocking_states * state)\n{\n    unsigned char *data;\n    size_t data_len;\n    unsigned char i, all_packets[255];\n    int ret;\n\n    if(*state == libssh2_NB_state_idle) {\n        for(i = 1; i < 255; i++) {\n            all_packets[i - 1] = i;\n        }\n        all_packets[254] = 0;\n\n        if(_libssh2_packet_askv(session, all_packets, &data, &data_len, 0,\n                                 NULL, 0) == 0) {\n            i = data[0];\n            /* A packet was available in the packet brigade, burn it */\n            LIBSSH2_FREE(session, data);\n            return i;\n        }\n\n        _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                       \"Blocking until packet becomes available to burn\");\n        *state = libssh2_NB_state_created;\n    }\n\n    while(session->socket_state == LIBSSH2_SOCKET_CONNECTED) {\n        ret = _libssh2_transport_read(session);\n        if(ret == LIBSSH2_ERROR_EAGAIN) {\n            return ret;\n        }\n        else if(ret < 0) {\n            *state = libssh2_NB_state_idle;\n            return ret;\n        }\n        else if(ret == 0) {\n            /* FIXME: this might busyloop */\n            continue;\n        }\n\n        /* Be lazy, let packet_ask pull it out of the brigade */\n        if(0 ==\n            _libssh2_packet_ask(session, (unsigned char)ret,\n                                         &data, &data_len, 0, NULL, 0)) {\n            /* Smoke 'em if you got 'em */\n            LIBSSH2_FREE(session, data);\n            *state = libssh2_NB_state_idle;\n            return ret;\n        }\n    }\n\n    /* Only reached if the socket died */\n    return LIBSSH2_ERROR_SOCKET_DISCONNECT;\n}\n\n/*\n * _libssh2_packet_requirev\n *\n * Loops _libssh2_transport_read() until one of a list of packet types\n * requested is available. SSH_DISCONNECT or a SOCKET_DISCONNECTED will cause\n * a bailout. packet_types is a null terminated list of packet_type numbers\n */\n\nint\n_libssh2_packet_requirev(LIBSSH2_SESSION *session,\n                         const unsigned char *packet_types,\n                         unsigned char **data, size_t *data_len,\n                         int match_ofs,\n                         const unsigned char *match_buf, size_t match_len,\n                         packet_requirev_state_t * state)\n{\n    if(_libssh2_packet_askv(session, packet_types, data, data_len, match_ofs,\n                             match_buf, match_len) == 0) {\n        /* One of the packets listed was available in the packet brigade */\n        state->start = 0;\n        return 0;\n    }\n\n    if(state->start == 0) {\n        state->start = time(NULL);\n    }\n\n    while(session->socket_state != LIBSSH2_SOCKET_DISCONNECTED) {\n        int ret = _libssh2_transport_read(session);\n        if((ret < 0) && (ret != LIBSSH2_ERROR_EAGAIN)) {\n            state->start = 0;\n            return ret;\n        }\n        if(ret <= 0) {\n            long left = LIBSSH2_READ_TIMEOUT -\n                (long)(time(NULL) - state->start);\n\n            if(left <= 0) {\n                state->start = 0;\n                return LIBSSH2_ERROR_TIMEOUT;\n            }\n            else if(ret == LIBSSH2_ERROR_EAGAIN) {\n                return ret;\n            }\n        }\n\n        if(strchr((char *) packet_types, ret)) {\n            /* Be lazy, let packet_ask pull it out of the brigade */\n            return _libssh2_packet_askv(session, packet_types, data,\n                                        data_len, match_ofs, match_buf,\n                                        match_len);\n        }\n    }\n\n    /* Only reached if the socket died */\n    state->start = 0;\n    return LIBSSH2_ERROR_SOCKET_DISCONNECT;\n}\n\n"], "fixing_code": ["/* Copyright (c) 2004-2007, Sara Golemon <sarag@libssh2.org>\n * Copyright (c) 2005,2006 Mikhail Gusarov\n * Copyright (c) 2009-2014 by Daniel Stenberg\n * Copyright (c) 2010 Simon Josefsson\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms,\n * with or without modification, are permitted provided\n * that the following conditions are met:\n *\n *   Redistributions of source code must retain the above\n *   copyright notice, this list of conditions and the\n *   following disclaimer.\n *\n *   Redistributions in binary form must reproduce the above\n *   copyright notice, this list of conditions and the following\n *   disclaimer in the documentation and/or other materials\n *   provided with the distribution.\n *\n *   Neither the name of the copyright holder nor the names\n *   of any other contributors may be used to endorse or\n *   promote products derived from this software without\n *   specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\n * CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\n * OF SUCH DAMAGE.\n */\n\n#include \"libssh2_priv.h\"\n#include <errno.h>\n#include <fcntl.h>\n\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n\n#ifdef HAVE_INTTYPES_H\n#include <inttypes.h>\n#endif\n\n/* Needed for struct iovec on some platforms */\n#ifdef HAVE_SYS_UIO_H\n#include <sys/uio.h>\n#endif\n\n#include <sys/types.h>\n\n#include \"transport.h\"\n#include \"channel.h\"\n#include \"packet.h\"\n\n/*\n * libssh2_packet_queue_listener\n *\n * Queue a connection request for a listener\n */\nstatic inline int\npacket_queue_listener(LIBSSH2_SESSION * session, unsigned char *data,\n                      unsigned long datalen,\n                      packet_queue_listener_state_t *listen_state)\n{\n    /*\n     * Look for a matching listener\n     */\n    /* 17 = packet_type(1) + channel(4) + reason(4) + descr(4) + lang(4) */\n    unsigned long packet_len = 17 + (sizeof(FwdNotReq) - 1);\n    unsigned char *p;\n    LIBSSH2_LISTENER *listn = _libssh2_list_first(&session->listeners);\n    char failure_code = SSH_OPEN_ADMINISTRATIVELY_PROHIBITED;\n    int rc;\n\n    (void) datalen;\n\n    if(listen_state->state == libssh2_NB_state_idle) {\n        unsigned char *s = data + (sizeof(\"forwarded-tcpip\") - 1) + 5;\n        listen_state->sender_channel = _libssh2_ntohu32(s);\n        s += 4;\n\n        listen_state->initial_window_size = _libssh2_ntohu32(s);\n        s += 4;\n        listen_state->packet_size = _libssh2_ntohu32(s);\n        s += 4;\n\n        listen_state->host_len = _libssh2_ntohu32(s);\n        s += 4;\n        listen_state->host = s;\n        s += listen_state->host_len;\n        listen_state->port = _libssh2_ntohu32(s);\n        s += 4;\n\n        listen_state->shost_len = _libssh2_ntohu32(s);\n        s += 4;\n        listen_state->shost = s;\n        s += listen_state->shost_len;\n        listen_state->sport = _libssh2_ntohu32(s);\n\n        _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                       \"Remote received connection from %s:%ld to %s:%ld\",\n                       listen_state->shost, listen_state->sport,\n                       listen_state->host, listen_state->port);\n\n        listen_state->state = libssh2_NB_state_allocated;\n    }\n\n    if(listen_state->state != libssh2_NB_state_sent) {\n        while(listn) {\n            if((listn->port == (int) listen_state->port) &&\n                (strlen(listn->host) == listen_state->host_len) &&\n                (memcmp (listn->host, listen_state->host,\n                         listen_state->host_len) == 0)) {\n                /* This is our listener */\n                LIBSSH2_CHANNEL *channel = NULL;\n                listen_state->channel = NULL;\n\n                if(listen_state->state == libssh2_NB_state_allocated) {\n                    if(listn->queue_maxsize &&\n                        (listn->queue_maxsize <= listn->queue_size)) {\n                        /* Queue is full */\n                        failure_code = SSH_OPEN_RESOURCE_SHORTAGE;\n                        _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                                       \"Listener queue full, ignoring\");\n                        listen_state->state = libssh2_NB_state_sent;\n                        break;\n                    }\n\n                    channel = LIBSSH2_CALLOC(session, sizeof(LIBSSH2_CHANNEL));\n                    if(!channel) {\n                        _libssh2_error(session, LIBSSH2_ERROR_ALLOC,\n                                       \"Unable to allocate a channel for \"\n                                       \"new connection\");\n                        failure_code = SSH_OPEN_RESOURCE_SHORTAGE;\n                        listen_state->state = libssh2_NB_state_sent;\n                        break;\n                    }\n                    listen_state->channel = channel;\n\n                    channel->session = session;\n                    channel->channel_type_len = sizeof(\"forwarded-tcpip\") - 1;\n                    channel->channel_type = LIBSSH2_ALLOC(session,\n                                                          channel->\n                                                          channel_type_len +\n                                                          1);\n                    if(!channel->channel_type) {\n                        _libssh2_error(session, LIBSSH2_ERROR_ALLOC,\n                                       \"Unable to allocate a channel for new\"\n                                       \" connection\");\n                        LIBSSH2_FREE(session, channel);\n                        failure_code = SSH_OPEN_RESOURCE_SHORTAGE;\n                        listen_state->state = libssh2_NB_state_sent;\n                        break;\n                    }\n                    memcpy(channel->channel_type, \"forwarded-tcpip\",\n                           channel->channel_type_len + 1);\n\n                    channel->remote.id = listen_state->sender_channel;\n                    channel->remote.window_size_initial =\n                        LIBSSH2_CHANNEL_WINDOW_DEFAULT;\n                    channel->remote.window_size =\n                        LIBSSH2_CHANNEL_WINDOW_DEFAULT;\n                    channel->remote.packet_size =\n                        LIBSSH2_CHANNEL_PACKET_DEFAULT;\n\n                    channel->local.id = _libssh2_channel_nextid(session);\n                    channel->local.window_size_initial =\n                        listen_state->initial_window_size;\n                    channel->local.window_size =\n                        listen_state->initial_window_size;\n                    channel->local.packet_size = listen_state->packet_size;\n\n                    _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                                   \"Connection queued: channel %lu/%lu \"\n                                   \"win %lu/%lu packet %lu/%lu\",\n                                   channel->local.id, channel->remote.id,\n                                   channel->local.window_size,\n                                   channel->remote.window_size,\n                                   channel->local.packet_size,\n                                   channel->remote.packet_size);\n\n                    p = listen_state->packet;\n                    *(p++) = SSH_MSG_CHANNEL_OPEN_CONFIRMATION;\n                    _libssh2_store_u32(&p, channel->remote.id);\n                    _libssh2_store_u32(&p, channel->local.id);\n                    _libssh2_store_u32(&p,\n                                       channel->remote.window_size_initial);\n                    _libssh2_store_u32(&p, channel->remote.packet_size);\n\n                    listen_state->state = libssh2_NB_state_created;\n                }\n\n                if(listen_state->state == libssh2_NB_state_created) {\n                    rc = _libssh2_transport_send(session, listen_state->packet,\n                                                 17, NULL, 0);\n                    if(rc == LIBSSH2_ERROR_EAGAIN)\n                        return rc;\n                    else if(rc) {\n                        listen_state->state = libssh2_NB_state_idle;\n                        return _libssh2_error(session, rc,\n                                              \"Unable to send channel \"\n                                              \"open confirmation\");\n                    }\n\n                    /* Link the channel into the end of the queue list */\n                    if(listen_state->channel) {\n                        _libssh2_list_add(&listn->queue,\n                                          &listen_state->channel->node);\n                        listn->queue_size++;\n                    }\n\n                    listen_state->state = libssh2_NB_state_idle;\n                    return 0;\n                }\n            }\n\n            listn = _libssh2_list_next(&listn->node);\n        }\n\n        listen_state->state = libssh2_NB_state_sent;\n    }\n\n    /* We're not listening to you */\n    p = listen_state->packet;\n    *(p++) = SSH_MSG_CHANNEL_OPEN_FAILURE;\n    _libssh2_store_u32(&p, listen_state->sender_channel);\n    _libssh2_store_u32(&p, failure_code);\n    _libssh2_store_str(&p, FwdNotReq, sizeof(FwdNotReq) - 1);\n    _libssh2_htonu32(p, 0);\n\n    rc = _libssh2_transport_send(session, listen_state->packet,\n                                 packet_len, NULL, 0);\n    if(rc == LIBSSH2_ERROR_EAGAIN) {\n        return rc;\n    }\n    else if(rc) {\n        listen_state->state = libssh2_NB_state_idle;\n        return _libssh2_error(session, rc, \"Unable to send open failure\");\n\n    }\n    listen_state->state = libssh2_NB_state_idle;\n    return 0;\n}\n\n/*\n * packet_x11_open\n *\n * Accept a forwarded X11 connection\n */\nstatic inline int\npacket_x11_open(LIBSSH2_SESSION * session, unsigned char *data,\n                unsigned long datalen,\n                packet_x11_open_state_t *x11open_state)\n{\n    int failure_code = SSH_OPEN_CONNECT_FAILED;\n    /* 17 = packet_type(1) + channel(4) + reason(4) + descr(4) + lang(4) */\n    unsigned long packet_len = 17 + (sizeof(X11FwdUnAvil) - 1);\n    unsigned char *p;\n    LIBSSH2_CHANNEL *channel = x11open_state->channel;\n    int rc;\n\n    (void) datalen;\n\n    if(x11open_state->state == libssh2_NB_state_idle) {\n        unsigned char *s = data + (sizeof(\"x11\") - 1) + 5;\n        x11open_state->sender_channel = _libssh2_ntohu32(s);\n        s += 4;\n        x11open_state->initial_window_size = _libssh2_ntohu32(s);\n        s += 4;\n        x11open_state->packet_size = _libssh2_ntohu32(s);\n        s += 4;\n        x11open_state->shost_len = _libssh2_ntohu32(s);\n        s += 4;\n        x11open_state->shost = s;\n        s += x11open_state->shost_len;\n        x11open_state->sport = _libssh2_ntohu32(s);\n\n        _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                       \"X11 Connection Received from %s:%ld on channel %lu\",\n                       x11open_state->shost, x11open_state->sport,\n                       x11open_state->sender_channel);\n\n        x11open_state->state = libssh2_NB_state_allocated;\n    }\n\n    if(session->x11) {\n        if(x11open_state->state == libssh2_NB_state_allocated) {\n            channel = LIBSSH2_CALLOC(session, sizeof(LIBSSH2_CHANNEL));\n            if(!channel) {\n                _libssh2_error(session, LIBSSH2_ERROR_ALLOC,\n                               \"allocate a channel for new connection\");\n                failure_code = SSH_OPEN_RESOURCE_SHORTAGE;\n                goto x11_exit;\n            }\n\n            channel->session = session;\n            channel->channel_type_len = sizeof(\"x11\") - 1;\n            channel->channel_type = LIBSSH2_ALLOC(session,\n                                                  channel->channel_type_len +\n                                                  1);\n            if(!channel->channel_type) {\n                _libssh2_error(session, LIBSSH2_ERROR_ALLOC,\n                               \"allocate a channel for new connection\");\n                LIBSSH2_FREE(session, channel);\n                failure_code = SSH_OPEN_RESOURCE_SHORTAGE;\n                goto x11_exit;\n            }\n            memcpy(channel->channel_type, \"x11\",\n                   channel->channel_type_len + 1);\n\n            channel->remote.id = x11open_state->sender_channel;\n            channel->remote.window_size_initial =\n                LIBSSH2_CHANNEL_WINDOW_DEFAULT;\n            channel->remote.window_size = LIBSSH2_CHANNEL_WINDOW_DEFAULT;\n            channel->remote.packet_size = LIBSSH2_CHANNEL_PACKET_DEFAULT;\n\n            channel->local.id = _libssh2_channel_nextid(session);\n            channel->local.window_size_initial =\n                x11open_state->initial_window_size;\n            channel->local.window_size = x11open_state->initial_window_size;\n            channel->local.packet_size = x11open_state->packet_size;\n\n            _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                           \"X11 Connection established: channel %lu/%lu \"\n                           \"win %lu/%lu packet %lu/%lu\",\n                           channel->local.id, channel->remote.id,\n                           channel->local.window_size,\n                           channel->remote.window_size,\n                           channel->local.packet_size,\n                           channel->remote.packet_size);\n            p = x11open_state->packet;\n            *(p++) = SSH_MSG_CHANNEL_OPEN_CONFIRMATION;\n            _libssh2_store_u32(&p, channel->remote.id);\n            _libssh2_store_u32(&p, channel->local.id);\n            _libssh2_store_u32(&p, channel->remote.window_size_initial);\n            _libssh2_store_u32(&p, channel->remote.packet_size);\n\n            x11open_state->state = libssh2_NB_state_created;\n        }\n\n        if(x11open_state->state == libssh2_NB_state_created) {\n            rc = _libssh2_transport_send(session, x11open_state->packet, 17,\n                                         NULL, 0);\n            if(rc == LIBSSH2_ERROR_EAGAIN) {\n                return rc;\n            }\n            else if(rc) {\n                x11open_state->state = libssh2_NB_state_idle;\n                return _libssh2_error(session, LIBSSH2_ERROR_SOCKET_SEND,\n                                      \"Unable to send channel open \"\n                                      \"confirmation\");\n            }\n\n            /* Link the channel into the session */\n            _libssh2_list_add(&session->channels, &channel->node);\n\n            /*\n             * Pass control to the callback, they may turn right around and\n             * free the channel, or actually use it\n             */\n            LIBSSH2_X11_OPEN(channel, (char *)x11open_state->shost,\n                             x11open_state->sport);\n\n            x11open_state->state = libssh2_NB_state_idle;\n            return 0;\n        }\n    }\n    else\n        failure_code = SSH_OPEN_RESOURCE_SHORTAGE;\n    /* fall-trough */\n  x11_exit:\n    p = x11open_state->packet;\n    *(p++) = SSH_MSG_CHANNEL_OPEN_FAILURE;\n    _libssh2_store_u32(&p, x11open_state->sender_channel);\n    _libssh2_store_u32(&p, failure_code);\n    _libssh2_store_str(&p, X11FwdUnAvil, sizeof(X11FwdUnAvil) - 1);\n    _libssh2_htonu32(p, 0);\n\n    rc = _libssh2_transport_send(session, x11open_state->packet, packet_len,\n                                 NULL, 0);\n    if(rc == LIBSSH2_ERROR_EAGAIN) {\n        return rc;\n    }\n    else if(rc) {\n        x11open_state->state = libssh2_NB_state_idle;\n        return _libssh2_error(session, rc, \"Unable to send open failure\");\n    }\n    x11open_state->state = libssh2_NB_state_idle;\n    return 0;\n}\n\n/*\n * _libssh2_packet_add\n *\n * Create a new packet and attach it to the brigade. Called from the transport\n * layer when it has received a packet.\n *\n * The input pointer 'data' is pointing to allocated data that this function\n * is asked to deal with so on failure OR success, it must be freed fine.\n * The only exception is when the return code is LIBSSH2_ERROR_EAGAIN.\n *\n * This function will always be called with 'datalen' greater than zero.\n */\nint\n_libssh2_packet_add(LIBSSH2_SESSION * session, unsigned char *data,\n                    size_t datalen, int macstate)\n{\n    int rc = 0;\n    unsigned char *message = NULL;\n    unsigned char *language = NULL;\n    size_t message_len = 0;\n    size_t language_len = 0;\n    LIBSSH2_CHANNEL *channelp = NULL;\n    size_t data_head = 0;\n    unsigned char msg = data[0];\n\n    switch(session->packAdd_state) {\n    case libssh2_NB_state_idle:\n        _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                       \"Packet type %d received, length=%d\",\n                       (int) msg, (int) datalen);\n\n        if((macstate == LIBSSH2_MAC_INVALID) &&\n            (!session->macerror ||\n             LIBSSH2_MACERROR(session, (char *) data, datalen))) {\n            /* Bad MAC input, but no callback set or non-zero return from the\n               callback */\n\n            LIBSSH2_FREE(session, data);\n            return _libssh2_error(session, LIBSSH2_ERROR_INVALID_MAC,\n                                  \"Invalid MAC received\");\n        }\n        session->packAdd_state = libssh2_NB_state_allocated;\n        break;\n    case libssh2_NB_state_jump1:\n        goto libssh2_packet_add_jump_point1;\n    case libssh2_NB_state_jump2:\n        goto libssh2_packet_add_jump_point2;\n    case libssh2_NB_state_jump3:\n        goto libssh2_packet_add_jump_point3;\n    case libssh2_NB_state_jump4:\n        goto libssh2_packet_add_jump_point4;\n    case libssh2_NB_state_jump5:\n        goto libssh2_packet_add_jump_point5;\n    default: /* nothing to do */\n        break;\n    }\n\n    if(session->packAdd_state == libssh2_NB_state_allocated) {\n        /* A couple exceptions to the packet adding rule: */\n        switch(msg) {\n\n            /*\n              byte      SSH_MSG_DISCONNECT\n              uint32    reason code\n              string    description in ISO-10646 UTF-8 encoding [RFC3629]\n              string    language tag [RFC3066]\n            */\n\n        case SSH_MSG_DISCONNECT:\n            if(datalen >= 5) {\n                uint32_t reason = 0;\n                struct string_buf buf;\n                buf.data = (unsigned char *)data;\n                buf.dataptr = buf.data;\n                buf.len = datalen;\n                buf.dataptr++; /* advance past type */\n\n                _libssh2_get_u32(&buf, &reason);\n                _libssh2_get_string(&buf, &message, &message_len);\n                _libssh2_get_string(&buf, &language, &language_len);\n\n                if(session->ssh_msg_disconnect) {\n                    LIBSSH2_DISCONNECT(session, reason, (const char *)message,\n                                       message_len, (const char *)language,\n                                       language_len);\n                }\n\n                _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                               \"Disconnect(%d): %s(%s)\", reason,\n                               message, language);\n            }\n\n            LIBSSH2_FREE(session, data);\n            session->socket_state = LIBSSH2_SOCKET_DISCONNECTED;\n            session->packAdd_state = libssh2_NB_state_idle;\n            return _libssh2_error(session, LIBSSH2_ERROR_SOCKET_DISCONNECT,\n                                  \"socket disconnect\");\n            /*\n              byte      SSH_MSG_IGNORE\n              string    data\n            */\n\n        case SSH_MSG_IGNORE:\n            if(datalen >= 2) {\n                if(session->ssh_msg_ignore) {\n                    LIBSSH2_IGNORE(session, (char *) data + 1, datalen - 1);\n                }\n            }\n            else if(session->ssh_msg_ignore) {\n                LIBSSH2_IGNORE(session, \"\", 0);\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_DEBUG\n              boolean   always_display\n              string    message in ISO-10646 UTF-8 encoding [RFC3629]\n              string    language tag [RFC3066]\n            */\n\n        case SSH_MSG_DEBUG:\n            if(datalen >= 2) {\n                int always_display = data[1];\n\n                if(datalen >= 6) {\n                    struct string_buf buf;\n                    buf.data = (unsigned char *)data;\n                    buf.dataptr = buf.data;\n                    buf.len = datalen;\n                    buf.dataptr += 2; /* advance past type & always display */\n\n                    _libssh2_get_string(&buf, &message, &message_len);\n                    _libssh2_get_string(&buf, &language, &language_len);\n                }\n\n                if(session->ssh_msg_debug) {\n                    LIBSSH2_DEBUG(session, always_display,\n                                  (const char *)message,\n                                  message_len, (const char *)language,\n                                  language_len);\n                }\n            }\n\n            /*\n             * _libssh2_debug will actually truncate this for us so\n             * that it's not an inordinate about of data\n             */\n            _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                           \"Debug Packet: %s\", message);\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_GLOBAL_REQUEST\n              string    request name in US-ASCII only\n              boolean   want reply\n              ....      request-specific data follows\n            */\n\n        case SSH_MSG_GLOBAL_REQUEST:\n            if(datalen >= 5) {\n                uint32_t len = 0;\n                unsigned char want_reply = 0;\n                len = _libssh2_ntohu32(data + 1);\n                if((len <= (UINT_MAX - 6)) && (datalen >= (6 + len))) {\n                    want_reply = data[5 + len];\n                    _libssh2_debug(session,\n                                   LIBSSH2_TRACE_CONN,\n                                   \"Received global request type %.*s (wr %X)\",\n                                   len, data + 5, want_reply);\n                }\n\n\n                if(want_reply) {\n                    static const unsigned char packet =\n                        SSH_MSG_REQUEST_FAILURE;\n                  libssh2_packet_add_jump_point5:\n                    session->packAdd_state = libssh2_NB_state_jump5;\n                    rc = _libssh2_transport_send(session, &packet, 1, NULL, 0);\n                    if(rc == LIBSSH2_ERROR_EAGAIN)\n                        return rc;\n                }\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_CHANNEL_EXTENDED_DATA\n              uint32    recipient channel\n              uint32    data_type_code\n              string    data\n            */\n\n        case SSH_MSG_CHANNEL_EXTENDED_DATA:\n            /* streamid(4) */\n            data_head += 4;\n\n            /* fall-through */\n\n            /*\n              byte      SSH_MSG_CHANNEL_DATA\n              uint32    recipient channel\n              string    data\n            */\n\n        case SSH_MSG_CHANNEL_DATA:\n            /* packet_type(1) + channelno(4) + datalen(4) */\n            data_head += 9;\n\n            if(datalen >= data_head)\n                channelp =\n                    _libssh2_channel_locate(session,\n                                            _libssh2_ntohu32(data + 1));\n\n            if(!channelp) {\n                _libssh2_error(session, LIBSSH2_ERROR_CHANNEL_UNKNOWN,\n                               \"Packet received for unknown channel\");\n                LIBSSH2_FREE(session, data);\n                session->packAdd_state = libssh2_NB_state_idle;\n                return 0;\n            }\n#ifdef LIBSSH2DEBUG\n            {\n                uint32_t stream_id = 0;\n                if(msg == SSH_MSG_CHANNEL_EXTENDED_DATA)\n                    stream_id = _libssh2_ntohu32(data + 5);\n\n                _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                               \"%d bytes packet_add() for %lu/%lu/%lu\",\n                               (int) (datalen - data_head),\n                               channelp->local.id,\n                               channelp->remote.id,\n                               stream_id);\n            }\n#endif\n            if((channelp->remote.extended_data_ignore_mode ==\n                 LIBSSH2_CHANNEL_EXTENDED_DATA_IGNORE) &&\n                (msg == SSH_MSG_CHANNEL_EXTENDED_DATA)) {\n                /* Pretend we didn't receive this */\n                LIBSSH2_FREE(session, data);\n\n                _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                               \"Ignoring extended data and refunding %d bytes\",\n                               (int) (datalen - 13));\n                if(channelp->read_avail + datalen - data_head >=\n                    channelp->remote.window_size)\n                    datalen = channelp->remote.window_size -\n                        channelp->read_avail + data_head;\n\n                channelp->remote.window_size -= datalen - data_head;\n                _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                               \"shrinking window size by %lu bytes to %lu, \"\n                               \"read_avail %lu\",\n                               datalen - data_head,\n                               channelp->remote.window_size,\n                               channelp->read_avail);\n\n                session->packAdd_channelp = channelp;\n\n                /* Adjust the window based on the block we just freed */\n              libssh2_packet_add_jump_point1:\n                session->packAdd_state = libssh2_NB_state_jump1;\n                rc = _libssh2_channel_receive_window_adjust(session->\n                                                            packAdd_channelp,\n                                                            datalen - 13,\n                                                            1, NULL);\n                if(rc == LIBSSH2_ERROR_EAGAIN)\n                    return rc;\n\n                session->packAdd_state = libssh2_NB_state_idle;\n                return 0;\n            }\n\n            /*\n             * REMEMBER! remote means remote as source of data,\n             * NOT remote window!\n             */\n            if(channelp->remote.packet_size < (datalen - data_head)) {\n                /*\n                 * Spec says we MAY ignore bytes sent beyond\n                 * packet_size\n                 */\n                _libssh2_error(session,\n                               LIBSSH2_ERROR_CHANNEL_PACKET_EXCEEDED,\n                               \"Packet contains more data than we offered\"\n                               \" to receive, truncating\");\n                datalen = channelp->remote.packet_size + data_head;\n            }\n            if(channelp->remote.window_size <= channelp->read_avail) {\n                /*\n                 * Spec says we MAY ignore bytes sent beyond\n                 * window_size\n                 */\n                _libssh2_error(session,\n                               LIBSSH2_ERROR_CHANNEL_WINDOW_EXCEEDED,\n                               \"The current receive window is full,\"\n                               \" data ignored\");\n                LIBSSH2_FREE(session, data);\n                session->packAdd_state = libssh2_NB_state_idle;\n                return 0;\n            }\n            /* Reset EOF status */\n            channelp->remote.eof = 0;\n\n            if(channelp->read_avail + datalen - data_head >\n                channelp->remote.window_size) {\n                _libssh2_error(session,\n                               LIBSSH2_ERROR_CHANNEL_WINDOW_EXCEEDED,\n                               \"Remote sent more data than current \"\n                               \"window allows, truncating\");\n                datalen = channelp->remote.window_size -\n                    channelp->read_avail + data_head;\n            }\n\n            /* Update the read_avail counter. The window size will be\n             * updated once the data is actually read from the queue\n             * from an upper layer */\n            channelp->read_avail += datalen - data_head;\n\n            _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                           \"increasing read_avail by %lu bytes to %lu/%lu\",\n                           (long)(datalen - data_head),\n                           (long)channelp->read_avail,\n                           (long)channelp->remote.window_size);\n\n            break;\n\n            /*\n              byte      SSH_MSG_CHANNEL_EOF\n              uint32    recipient channel\n            */\n\n        case SSH_MSG_CHANNEL_EOF:\n            if(datalen >= 5)\n                channelp =\n                    _libssh2_channel_locate(session,\n                                            _libssh2_ntohu32(data + 1));\n            if(!channelp)\n                /* We may have freed already, just quietly ignore this... */\n                ;\n            else {\n                _libssh2_debug(session,\n                               LIBSSH2_TRACE_CONN,\n                               \"EOF received for channel %lu/%lu\",\n                               channelp->local.id,\n                               channelp->remote.id);\n                channelp->remote.eof = 1;\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_CHANNEL_REQUEST\n              uint32    recipient channel\n              string    request type in US-ASCII characters only\n              boolean   want reply\n              ....      type-specific data follows\n            */\n\n        case SSH_MSG_CHANNEL_REQUEST:\n            if(datalen >= 9) {\n                uint32_t channel = _libssh2_ntohu32(data + 1);\n                uint32_t len = _libssh2_ntohu32(data + 5);\n                unsigned char want_reply = 1;\n\n                if((len + 9) < datalen)\n                    want_reply = data[len + 9];\n\n                _libssh2_debug(session,\n                               LIBSSH2_TRACE_CONN,\n                               \"Channel %d received request type %.*s (wr %X)\",\n                               channel, len, data + 9, want_reply);\n\n                if(len == sizeof(\"exit-status\") - 1\n                    && (sizeof(\"exit-status\") - 1 + 9) <= datalen\n                    && !memcmp(\"exit-status\", data + 9,\n                               sizeof(\"exit-status\") - 1)) {\n\n                    /* we've got \"exit-status\" packet. Set the session value */\n                    if(datalen >= 20)\n                        channelp =\n                            _libssh2_channel_locate(session, channel);\n\n                    if(channelp && (sizeof(\"exit-status\") + 13) <= datalen) {\n                        channelp->exit_status =\n                            _libssh2_ntohu32(data + 9 + sizeof(\"exit-status\"));\n                        _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                                       \"Exit status %lu received for \"\n                                       \"channel %lu/%lu\",\n                                       channelp->exit_status,\n                                       channelp->local.id,\n                                       channelp->remote.id);\n                    }\n\n                }\n                else if(len == sizeof(\"exit-signal\") - 1\n                         && (sizeof(\"exit-signal\") - 1 + 9) <= datalen\n                         && !memcmp(\"exit-signal\", data + 9,\n                                    sizeof(\"exit-signal\") - 1)) {\n                    /* command terminated due to signal */\n                    if(datalen >= 20)\n                        channelp = _libssh2_channel_locate(session, channel);\n\n                    if(channelp && (sizeof(\"exit-signal\") + 13) <= datalen) {\n                        /* set signal name (without SIG prefix) */\n                        uint32_t namelen =\n                            _libssh2_ntohu32(data + 9 + sizeof(\"exit-signal\"));\n\n                        if(namelen <= UINT_MAX - 1) {\n                            channelp->exit_signal =\n                                LIBSSH2_ALLOC(session, namelen + 1);\n                        }\n                        else {\n                            channelp->exit_signal = NULL;\n                        }\n\n                        if(!channelp->exit_signal)\n                            rc = _libssh2_error(session, LIBSSH2_ERROR_ALLOC,\n                                                \"memory for signal name\");\n                        else if((sizeof(\"exit-signal\") + 13 + namelen <=\n                                 datalen)) {\n                            memcpy(channelp->exit_signal,\n                                   data + 13 + sizeof(\"exit-signal\"), namelen);\n                            channelp->exit_signal[namelen] = '\\0';\n                            /* TODO: save error message and language tag */\n                            _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                                           \"Exit signal %s received for \"\n                                           \"channel %lu/%lu\",\n                                           channelp->exit_signal,\n                                           channelp->local.id,\n                                           channelp->remote.id);\n                        }\n                    }\n                }\n\n\n                if(want_reply) {\n                    unsigned char packet[5];\n                  libssh2_packet_add_jump_point4:\n                    session->packAdd_state = libssh2_NB_state_jump4;\n                    packet[0] = SSH_MSG_CHANNEL_FAILURE;\n                    memcpy(&packet[1], data + 1, 4);\n                    rc = _libssh2_transport_send(session, packet, 5, NULL, 0);\n                    if(rc == LIBSSH2_ERROR_EAGAIN)\n                        return rc;\n                }\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return rc;\n\n            /*\n              byte      SSH_MSG_CHANNEL_CLOSE\n              uint32    recipient channel\n            */\n\n        case SSH_MSG_CHANNEL_CLOSE:\n            if(datalen >= 5)\n                channelp =\n                    _libssh2_channel_locate(session,\n                                            _libssh2_ntohu32(data + 1));\n            if(!channelp) {\n                /* We may have freed already, just quietly ignore this... */\n                LIBSSH2_FREE(session, data);\n                session->packAdd_state = libssh2_NB_state_idle;\n                return 0;\n            }\n            _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                           \"Close received for channel %lu/%lu\",\n                           channelp->local.id,\n                           channelp->remote.id);\n\n            channelp->remote.close = 1;\n            channelp->remote.eof = 1;\n\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_CHANNEL_OPEN\n              string    \"session\"\n              uint32    sender channel\n              uint32    initial window size\n              uint32    maximum packet size\n            */\n\n        case SSH_MSG_CHANNEL_OPEN:\n            if(datalen < 17)\n                ;\n            else if((datalen >= (sizeof(\"forwarded-tcpip\") + 4)) &&\n                     ((sizeof(\"forwarded-tcpip\") - 1) ==\n                      _libssh2_ntohu32(data + 1))\n                     &&\n                     (memcmp(data + 5, \"forwarded-tcpip\",\n                             sizeof(\"forwarded-tcpip\") - 1) == 0)) {\n\n                /* init the state struct */\n                memset(&session->packAdd_Qlstn_state, 0,\n                       sizeof(session->packAdd_Qlstn_state));\n\n              libssh2_packet_add_jump_point2:\n                session->packAdd_state = libssh2_NB_state_jump2;\n                rc = packet_queue_listener(session, data, datalen,\n                                           &session->packAdd_Qlstn_state);\n            }\n            else if((datalen >= (sizeof(\"x11\") + 4)) &&\n                     ((sizeof(\"x11\") - 1) == _libssh2_ntohu32(data + 1)) &&\n                     (memcmp(data + 5, \"x11\", sizeof(\"x11\") - 1) == 0)) {\n\n                /* init the state struct */\n                memset(&session->packAdd_x11open_state, 0,\n                       sizeof(session->packAdd_x11open_state));\n\n              libssh2_packet_add_jump_point3:\n                session->packAdd_state = libssh2_NB_state_jump3;\n                rc = packet_x11_open(session, data, datalen,\n                                     &session->packAdd_x11open_state);\n            }\n            if(rc == LIBSSH2_ERROR_EAGAIN)\n                return rc;\n\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return rc;\n\n            /*\n              byte      SSH_MSG_CHANNEL_WINDOW_ADJUST\n              uint32    recipient channel\n              uint32    bytes to add\n            */\n        case SSH_MSG_CHANNEL_WINDOW_ADJUST:\n            if(datalen < 9)\n                ;\n            else {\n                uint32_t bytestoadd = _libssh2_ntohu32(data + 5);\n                channelp =\n                    _libssh2_channel_locate(session,\n                                            _libssh2_ntohu32(data + 1));\n                if(channelp) {\n                    channelp->local.window_size += bytestoadd;\n\n                    _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                                   \"Window adjust for channel %lu/%lu, \"\n                                   \"adding %lu bytes, new window_size=%lu\",\n                                   channelp->local.id,\n                                   channelp->remote.id,\n                                   bytestoadd,\n                                   channelp->local.window_size);\n                }\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n        default:\n            break;\n        }\n\n        session->packAdd_state = libssh2_NB_state_sent;\n    }\n\n    if(session->packAdd_state == libssh2_NB_state_sent) {\n        LIBSSH2_PACKET *packetp =\n            LIBSSH2_ALLOC(session, sizeof(LIBSSH2_PACKET));\n        if(!packetp) {\n            _libssh2_debug(session, LIBSSH2_ERROR_ALLOC,\n                           \"memory for packet\");\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return LIBSSH2_ERROR_ALLOC;\n        }\n        packetp->data = data;\n        packetp->data_len = datalen;\n        packetp->data_head = data_head;\n\n        _libssh2_list_add(&session->packets, &packetp->node);\n\n        session->packAdd_state = libssh2_NB_state_sent1;\n    }\n\n    if((msg == SSH_MSG_KEXINIT &&\n         !(session->state & LIBSSH2_STATE_EXCHANGING_KEYS)) ||\n        (session->packAdd_state == libssh2_NB_state_sent2)) {\n        if(session->packAdd_state == libssh2_NB_state_sent1) {\n            /*\n             * Remote wants new keys\n             * Well, it's already in the brigade,\n             * let's just call back into ourselves\n             */\n            _libssh2_debug(session, LIBSSH2_TRACE_TRANS, \"Renegotiating Keys\");\n\n            session->packAdd_state = libssh2_NB_state_sent2;\n        }\n\n        /*\n         * The KEXINIT message has been added to the queue.  The packAdd and\n         * readPack states need to be reset because _libssh2_kex_exchange\n         * (eventually) calls upon _libssh2_transport_read to read the rest of\n         * the key exchange conversation.\n         */\n        session->readPack_state = libssh2_NB_state_idle;\n        session->packet.total_num = 0;\n        session->packAdd_state = libssh2_NB_state_idle;\n        session->fullpacket_state = libssh2_NB_state_idle;\n\n        memset(&session->startup_key_state, 0, sizeof(key_exchange_state_t));\n\n        /*\n         * If there was a key reexchange failure, let's just hope we didn't\n         * send NEWKEYS yet, otherwise remote will drop us like a rock\n         */\n        rc = _libssh2_kex_exchange(session, 1, &session->startup_key_state);\n        if(rc == LIBSSH2_ERROR_EAGAIN)\n            return rc;\n    }\n\n    session->packAdd_state = libssh2_NB_state_idle;\n    return 0;\n}\n\n/*\n * _libssh2_packet_ask\n *\n * Scan the brigade for a matching packet type, optionally poll the socket for\n * a packet first\n */\nint\n_libssh2_packet_ask(LIBSSH2_SESSION * session, unsigned char packet_type,\n                    unsigned char **data, size_t *data_len,\n                    int match_ofs, const unsigned char *match_buf,\n                    size_t match_len)\n{\n    LIBSSH2_PACKET *packet = _libssh2_list_first(&session->packets);\n\n    _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                   \"Looking for packet of type: %d\", (int) packet_type);\n\n    while(packet) {\n        if(packet->data[0] == packet_type\n            && (packet->data_len >= (match_ofs + match_len))\n            && (!match_buf ||\n                (memcmp(packet->data + match_ofs, match_buf,\n                        match_len) == 0))) {\n            *data = packet->data;\n            *data_len = packet->data_len;\n\n            /* unlink struct from session->packets */\n            _libssh2_list_remove(&packet->node);\n\n            LIBSSH2_FREE(session, packet);\n\n            return 0;\n        }\n        packet = _libssh2_list_next(&packet->node);\n    }\n    return -1;\n}\n\n/*\n * libssh2_packet_askv\n *\n * Scan for any of a list of packet types in the brigade, optionally poll the\n * socket for a packet first\n */\nint\n_libssh2_packet_askv(LIBSSH2_SESSION * session,\n                     const unsigned char *packet_types,\n                     unsigned char **data, size_t *data_len,\n                     int match_ofs,\n                     const unsigned char *match_buf,\n                     size_t match_len)\n{\n    int i, packet_types_len = strlen((char *) packet_types);\n\n    for(i = 0; i < packet_types_len; i++) {\n        if(0 == _libssh2_packet_ask(session, packet_types[i], data,\n                                     data_len, match_ofs,\n                                     match_buf, match_len)) {\n            return 0;\n        }\n    }\n\n    return -1;\n}\n\n/*\n * _libssh2_packet_require\n *\n * Loops _libssh2_transport_read() until the packet requested is available\n * SSH_DISCONNECT or a SOCKET_DISCONNECTED will cause a bailout\n *\n * Returns negative on error\n * Returns 0 when it has taken care of the requested packet.\n */\nint\n_libssh2_packet_require(LIBSSH2_SESSION * session, unsigned char packet_type,\n                        unsigned char **data, size_t *data_len,\n                        int match_ofs,\n                        const unsigned char *match_buf,\n                        size_t match_len,\n                        packet_require_state_t *state)\n{\n    if(state->start == 0) {\n        if(_libssh2_packet_ask(session, packet_type, data, data_len,\n                                match_ofs, match_buf,\n                                match_len) == 0) {\n            /* A packet was available in the packet brigade */\n            return 0;\n        }\n\n        state->start = time(NULL);\n    }\n\n    while(session->socket_state == LIBSSH2_SOCKET_CONNECTED) {\n        int ret = _libssh2_transport_read(session);\n        if(ret == LIBSSH2_ERROR_EAGAIN)\n            return ret;\n        else if(ret < 0) {\n            state->start = 0;\n            /* an error which is not just because of blocking */\n            return ret;\n        }\n        else if(ret == packet_type) {\n            /* Be lazy, let packet_ask pull it out of the brigade */\n            ret = _libssh2_packet_ask(session, packet_type, data, data_len,\n                                      match_ofs, match_buf, match_len);\n            state->start = 0;\n            return ret;\n        }\n        else if(ret == 0) {\n            /* nothing available, wait until data arrives or we time out */\n            long left = LIBSSH2_READ_TIMEOUT - (long)(time(NULL) -\n                                                      state->start);\n\n            if(left <= 0) {\n                state->start = 0;\n                return LIBSSH2_ERROR_TIMEOUT;\n            }\n            return -1; /* no packet available yet */\n        }\n    }\n\n    /* Only reached if the socket died */\n    return LIBSSH2_ERROR_SOCKET_DISCONNECT;\n}\n\n/*\n * _libssh2_packet_burn\n *\n * Loops _libssh2_transport_read() until any packet is available and promptly\n * discards it.\n * Used during KEX exchange to discard badly guessed KEX_INIT packets\n */\nint\n_libssh2_packet_burn(LIBSSH2_SESSION * session,\n                     libssh2_nonblocking_states * state)\n{\n    unsigned char *data;\n    size_t data_len;\n    unsigned char i, all_packets[255];\n    int ret;\n\n    if(*state == libssh2_NB_state_idle) {\n        for(i = 1; i < 255; i++) {\n            all_packets[i - 1] = i;\n        }\n        all_packets[254] = 0;\n\n        if(_libssh2_packet_askv(session, all_packets, &data, &data_len, 0,\n                                 NULL, 0) == 0) {\n            i = data[0];\n            /* A packet was available in the packet brigade, burn it */\n            LIBSSH2_FREE(session, data);\n            return i;\n        }\n\n        _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                       \"Blocking until packet becomes available to burn\");\n        *state = libssh2_NB_state_created;\n    }\n\n    while(session->socket_state == LIBSSH2_SOCKET_CONNECTED) {\n        ret = _libssh2_transport_read(session);\n        if(ret == LIBSSH2_ERROR_EAGAIN) {\n            return ret;\n        }\n        else if(ret < 0) {\n            *state = libssh2_NB_state_idle;\n            return ret;\n        }\n        else if(ret == 0) {\n            /* FIXME: this might busyloop */\n            continue;\n        }\n\n        /* Be lazy, let packet_ask pull it out of the brigade */\n        if(0 ==\n            _libssh2_packet_ask(session, (unsigned char)ret,\n                                         &data, &data_len, 0, NULL, 0)) {\n            /* Smoke 'em if you got 'em */\n            LIBSSH2_FREE(session, data);\n            *state = libssh2_NB_state_idle;\n            return ret;\n        }\n    }\n\n    /* Only reached if the socket died */\n    return LIBSSH2_ERROR_SOCKET_DISCONNECT;\n}\n\n/*\n * _libssh2_packet_requirev\n *\n * Loops _libssh2_transport_read() until one of a list of packet types\n * requested is available. SSH_DISCONNECT or a SOCKET_DISCONNECTED will cause\n * a bailout. packet_types is a null terminated list of packet_type numbers\n */\n\nint\n_libssh2_packet_requirev(LIBSSH2_SESSION *session,\n                         const unsigned char *packet_types,\n                         unsigned char **data, size_t *data_len,\n                         int match_ofs,\n                         const unsigned char *match_buf, size_t match_len,\n                         packet_requirev_state_t * state)\n{\n    if(_libssh2_packet_askv(session, packet_types, data, data_len, match_ofs,\n                             match_buf, match_len) == 0) {\n        /* One of the packets listed was available in the packet brigade */\n        state->start = 0;\n        return 0;\n    }\n\n    if(state->start == 0) {\n        state->start = time(NULL);\n    }\n\n    while(session->socket_state != LIBSSH2_SOCKET_DISCONNECTED) {\n        int ret = _libssh2_transport_read(session);\n        if((ret < 0) && (ret != LIBSSH2_ERROR_EAGAIN)) {\n            state->start = 0;\n            return ret;\n        }\n        if(ret <= 0) {\n            long left = LIBSSH2_READ_TIMEOUT -\n                (long)(time(NULL) - state->start);\n\n            if(left <= 0) {\n                state->start = 0;\n                return LIBSSH2_ERROR_TIMEOUT;\n            }\n            else if(ret == LIBSSH2_ERROR_EAGAIN) {\n                return ret;\n            }\n        }\n\n        if(strchr((char *) packet_types, ret)) {\n            /* Be lazy, let packet_ask pull it out of the brigade */\n            return _libssh2_packet_askv(session, packet_types, data,\n                                        data_len, match_ofs, match_buf,\n                                        match_len);\n        }\n    }\n\n    /* Only reached if the socket died */\n    state->start = 0;\n    return LIBSSH2_ERROR_SOCKET_DISCONNECT;\n}\n\n"], "filenames": ["src/packet.c"], "buggy_code_start_loc": [422], "buggy_code_end_loc": [583], "fixing_code_start_loc": [422], "fixing_code_end_loc": [573], "type": "CWE-190", "message": "In libssh2 v1.9.0 and earlier versions, the SSH_MSG_DISCONNECT logic in packet.c has an integer overflow in a bounds check, enabling an attacker to specify an arbitrary (out-of-bounds) offset for a subsequent memory read. A crafted SSH server may be able to disclose sensitive information or cause a denial of service condition on the client system when a user connects to the server.", "other": {"cve": {"id": "CVE-2019-17498", "sourceIdentifier": "cve@mitre.org", "published": "2019-10-21T22:15:10.523", "lastModified": "2023-06-12T07:15:12.123", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In libssh2 v1.9.0 and earlier versions, the SSH_MSG_DISCONNECT logic in packet.c has an integer overflow in a bounds check, enabling an attacker to specify an arbitrary (out-of-bounds) offset for a subsequent memory read. A crafted SSH server may be able to disclose sensitive information or cause a denial of service condition on the client system when a user connects to the server."}, {"lang": "es", "value": "En libssh2 versi\u00f3n v1.9.0 y anteriores, la l\u00f3gica de la funci\u00f3n SSH_MSG_DISCONNECT en el archivo packet.c presenta un desbordamiento de enteros en una comprobaci\u00f3n de l\u00edmites, lo que permite a un atacante especificar un desplazamiento arbitrario (fuera de l\u00edmites) para una lectura de memoria posterior. Un servidor SSH dise\u00f1ado puede ser capaz de revelar informaci\u00f3n confidencial o causar una condici\u00f3n de denegaci\u00f3n de servicio en el sistema del cliente cuando un usuario conecta con el servidor."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libssh2:libssh2:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.9.0", "matchCriteriaId": "D0F2D0AA-AFDD-41A2-8172-EEB203227E5D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:vmware_vsphere:*:*", "matchCriteriaId": "3A756737-1CC4-42C2-A4DF-E1C893B4E2D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:element_software:-:*:*:*:*:*:*:*", "matchCriteriaId": "85DF4B3F-4BBC-42B7-B729-096934523D63"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "A3C19813-E823-456A-B1CE-EC0684CE1953"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:ontap_select_deploy_administration_utility:-:*:*:*:*:*:*:*", "matchCriteriaId": "E7CF3019-975D-40BB-A8A4-894E62BD3797"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire:-:*:*:*:*:*:*:*", "matchCriteriaId": "A6E9EF0C-AFA8-4F7B-9FDC-1E0F7C26E737"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:bootstrap_os:-:*:*:*:*:*:*:*", "matchCriteriaId": "95BA156C-C977-4F0C-8DFB-3FAE9CC8C02D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:hci_compute_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "AD7447BC-F315-4298-A822-549942FC118B"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-11/msg00026.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://packetstormsecurity.com/files/172835/libssh2-1.9.0-Out-Of-Bounds-Read.html", "source": "cve@mitre.org"}, {"url": "https://blog.semmle.com/libssh2-integer-overflow-CVE-2019-17498/", "source": "cve@mitre.org", "tags": ["Broken Link"]}, {"url": "https://github.com/kevinbackhouse/SecurityExploits/tree/8cbdbbe6363510f7d9ceec685373da12e6fc752d/libssh2/out_of_bounds_read_disconnect_CVE-2019-17498", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/libssh2/libssh2/blob/42d37aa63129a1b2644bf6495198923534322d64/src/packet.c#L480", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/libssh2/libssh2/commit/dedcbd106f8e52d5586b0205bc7677e4c9868f9c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/11/msg00010.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/12/msg00013.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/22H4Q5XMGS3QNSA7OCL3U7UQZ4NXMR5O/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TY7EEE34RFKCTXTMBQQWWSLXZWSCXNDB/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20220909-0004/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libssh2/libssh2/commit/dedcbd106f8e52d5586b0205bc7677e4c9868f9c"}}