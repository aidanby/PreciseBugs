{"buggy_code": ["/*\n\n   Copyright 2018-2021 Charles Korn.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\npackage com.charleskorn.kaml\n\nimport kotlinx.serialization.DeserializationStrategy\nimport kotlinx.serialization.ExperimentalSerializationApi\nimport kotlinx.serialization.KSerializer\nimport kotlinx.serialization.SerializationException\nimport kotlinx.serialization.descriptors.PolymorphicKind\nimport kotlinx.serialization.descriptors.PrimitiveKind\nimport kotlinx.serialization.descriptors.SerialDescriptor\nimport kotlinx.serialization.descriptors.SerialKind\nimport kotlinx.serialization.descriptors.StructureKind\nimport kotlinx.serialization.descriptors.elementNames\nimport kotlinx.serialization.encoding.AbstractDecoder\nimport kotlinx.serialization.encoding.CompositeDecoder\nimport kotlinx.serialization.encoding.CompositeDecoder.Companion.UNKNOWN_NAME\nimport kotlinx.serialization.modules.SerializersModule\nimport kotlinx.serialization.modules.SerializersModuleCollector\nimport kotlin.reflect.KClass\n\n@OptIn(ExperimentalSerializationApi::class)\npublic sealed class YamlInput(\n    public val node: YamlNode,\n    override var serializersModule: SerializersModule,\n    public val configuration: YamlConfiguration\n) : AbstractDecoder() {\n    internal companion object {\n        private val missingFieldExceptionMessage: Regex = \"\"\"^Field '(.*)' is required for type with serial name '.*', but it was missing$\"\"\".toRegex()\n\n        internal fun createFor(node: YamlNode, context: SerializersModule, configuration: YamlConfiguration, descriptor: SerialDescriptor): YamlInput = when (node) {\n            is YamlNull -> when {\n                descriptor.kind is PolymorphicKind && !descriptor.isNullable -> throw MissingTypeTagException(node.path)\n                else -> YamlNullInput(node, context, configuration)\n            }\n\n            is YamlScalar -> when (descriptor.kind) {\n                is PrimitiveKind, SerialKind.ENUM -> YamlScalarInput(node, context, configuration)\n                is SerialKind.CONTEXTUAL -> YamlContextualInput(node, context, configuration)\n                is PolymorphicKind -> throw MissingTypeTagException(node.path)\n                else -> throw IncorrectTypeException(\"Expected ${descriptor.kind.friendlyDescription}, but got a scalar value\", node.path)\n            }\n\n            is YamlList -> when (descriptor.kind) {\n                is StructureKind.LIST -> YamlListInput(node, context, configuration)\n                is SerialKind.CONTEXTUAL -> YamlContextualInput(node, context, configuration)\n                else -> throw IncorrectTypeException(\"Expected ${descriptor.kind.friendlyDescription}, but got a list\", node.path)\n            }\n\n            is YamlMap -> when (descriptor.kind) {\n                is StructureKind.CLASS, StructureKind.OBJECT -> YamlObjectInput(node, context, configuration)\n                is StructureKind.MAP -> YamlMapInput(node, context, configuration)\n                is SerialKind.CONTEXTUAL -> YamlContextualInput(node, context, configuration)\n                is PolymorphicKind -> when (configuration.polymorphismStyle) {\n                    PolymorphismStyle.Tag -> throw MissingTypeTagException(node.path)\n                    PolymorphismStyle.Property -> createPolymorphicMapDeserializer(node, context, configuration)\n                }\n                else -> throw IncorrectTypeException(\"Expected ${descriptor.kind.friendlyDescription}, but got a map\", node.path)\n            }\n\n            is YamlTaggedNode -> when {\n                descriptor.kind is PolymorphicKind && configuration.polymorphismStyle == PolymorphismStyle.Tag -> YamlPolymorphicInput(node.tag, node.path, node.innerNode, context, configuration)\n                else -> createFor(node.innerNode, context, configuration, descriptor)\n            }\n        }\n\n        private fun createPolymorphicMapDeserializer(node: YamlMap, context: SerializersModule, configuration: YamlConfiguration): YamlPolymorphicInput {\n            val desiredKey = configuration.polymorphismPropertyName\n            when (val typeName = node.getValue(desiredKey)) {\n                is YamlList -> throw InvalidPropertyValueException(desiredKey, \"expected a string, but got a list\", typeName.path)\n                is YamlMap -> throw InvalidPropertyValueException(desiredKey, \"expected a string, but got a map\", typeName.path)\n                is YamlNull -> throw InvalidPropertyValueException(desiredKey, \"expected a string, but got a null value\", typeName.path)\n                is YamlTaggedNode -> throw InvalidPropertyValueException(desiredKey, \"expected a string, but got a tagged value\", typeName.path)\n                is YamlScalar -> {\n                    val remainingProperties = node.withoutKey(desiredKey)\n\n                    return YamlPolymorphicInput(typeName.content, typeName.path, remainingProperties, context, configuration)\n                }\n            }\n        }\n\n        private fun YamlMap.getValue(desiredKey: String): YamlNode {\n            return this.get(desiredKey) ?: throw MissingRequiredPropertyException(desiredKey, this.path)\n        }\n\n        private fun YamlMap.withoutKey(key: String): YamlMap {\n            return this.copy(entries = entries.filterKeys { it.content != key })\n        }\n    }\n\n    override fun <T> decodeSerializableValue(deserializer: DeserializationStrategy<T>): T {\n        try {\n            return super.decodeSerializableValue(deserializer)\n        } catch (e: SerializationException) {\n            throwIfMissingRequiredPropertyException(e)\n\n            throw e\n        }\n    }\n\n    private fun throwIfMissingRequiredPropertyException(e: SerializationException) {\n        val match = missingFieldExceptionMessage.matchEntire(e.message!!) ?: return\n\n        throw MissingRequiredPropertyException(match.groupValues[1], node.path, e)\n    }\n\n    public abstract fun getCurrentLocation(): Location\n    public abstract fun getCurrentPath(): YamlPath\n}\n\n@OptIn(ExperimentalSerializationApi::class)\nprivate class YamlScalarInput(val scalar: YamlScalar, context: SerializersModule, configuration: YamlConfiguration) : YamlInput(scalar, context, configuration) {\n    override fun decodeString(): String = scalar.content\n    override fun decodeInt(): Int = scalar.toInt()\n    override fun decodeLong(): Long = scalar.toLong()\n    override fun decodeShort(): Short = scalar.toShort()\n    override fun decodeByte(): Byte = scalar.toByte()\n    override fun decodeDouble(): Double = scalar.toDouble()\n    override fun decodeFloat(): Float = scalar.toFloat()\n    override fun decodeBoolean(): Boolean = scalar.toBoolean()\n    override fun decodeChar(): Char = scalar.toChar()\n\n    override fun decodeEnum(enumDescriptor: SerialDescriptor): Int {\n        val index = enumDescriptor.getElementIndex(scalar.content)\n\n        if (index != UNKNOWN_NAME) {\n            return index\n        }\n\n        val choices = (0..enumDescriptor.elementsCount - 1)\n            .map { enumDescriptor.getElementName(it) }\n            .sorted()\n            .joinToString(\", \")\n\n        throw YamlScalarFormatException(\"Value ${scalar.contentToString()} is not a valid option, permitted choices are: $choices\", scalar.path, scalar.content)\n    }\n\n    override fun getCurrentLocation(): Location = scalar.location\n    override fun getCurrentPath(): YamlPath = scalar.path\n\n    override fun decodeElementIndex(descriptor: SerialDescriptor): Int = 0\n}\n\n@OptIn(ExperimentalSerializationApi::class)\nprivate class YamlNullInput(val nullValue: YamlNode, context: SerializersModule, configuration: YamlConfiguration) : YamlInput(nullValue, context, configuration) {\n    override fun decodeNotNullMark(): Boolean = false\n\n    override fun decodeValue(): Any = throw UnexpectedNullValueException(nullValue.path)\n    override fun decodeCollectionSize(descriptor: SerialDescriptor): Int = throw UnexpectedNullValueException(nullValue.path)\n    override fun beginStructure(descriptor: SerialDescriptor): CompositeDecoder = throw UnexpectedNullValueException(nullValue.path)\n\n    override fun getCurrentLocation(): Location = nullValue.location\n    override fun getCurrentPath(): YamlPath = nullValue.path\n\n    override fun decodeElementIndex(descriptor: SerialDescriptor): Int = 0\n}\n\n@OptIn(ExperimentalSerializationApi::class)\nprivate class YamlListInput(val list: YamlList, context: SerializersModule, configuration: YamlConfiguration) : YamlInput(list, context, configuration) {\n    private var nextElementIndex = 0\n    private lateinit var currentElementDecoder: YamlInput\n\n    override fun decodeCollectionSize(descriptor: SerialDescriptor): Int = list.items.size\n\n    override fun decodeElementIndex(descriptor: SerialDescriptor): Int {\n        if (nextElementIndex == list.items.size) {\n            return CompositeDecoder.DECODE_DONE\n        }\n\n        currentElementDecoder = createFor(list.items[nextElementIndex], serializersModule, configuration, descriptor.getElementDescriptor(0))\n\n        return nextElementIndex++\n    }\n\n    override fun decodeNotNullMark(): Boolean {\n        if (!haveStartedReadingElements) {\n            return true\n        }\n\n        return currentElementDecoder.decodeNotNullMark()\n    }\n\n    override fun decodeString(): String = currentElementDecoder.decodeString()\n    override fun decodeInt(): Int = currentElementDecoder.decodeInt()\n    override fun decodeLong(): Long = currentElementDecoder.decodeLong()\n    override fun decodeShort(): Short = currentElementDecoder.decodeShort()\n    override fun decodeByte(): Byte = currentElementDecoder.decodeByte()\n    override fun decodeDouble(): Double = currentElementDecoder.decodeDouble()\n    override fun decodeFloat(): Float = currentElementDecoder.decodeFloat()\n    override fun decodeBoolean(): Boolean = currentElementDecoder.decodeBoolean()\n    override fun decodeChar(): Char = currentElementDecoder.decodeChar()\n    override fun decodeEnum(enumDescriptor: SerialDescriptor): Int = currentElementDecoder.decodeEnum(enumDescriptor)\n\n    private val haveStartedReadingElements: Boolean\n        get() = nextElementIndex > 0\n\n    override fun beginStructure(descriptor: SerialDescriptor): CompositeDecoder {\n        if (haveStartedReadingElements) {\n            return currentElementDecoder\n        }\n\n        return super.beginStructure(descriptor)\n    }\n\n    override fun getCurrentPath(): YamlPath {\n        return if (haveStartedReadingElements) {\n            currentElementDecoder.node.path\n        } else {\n            list.path\n        }\n    }\n\n    override fun getCurrentLocation(): Location = getCurrentPath().endLocation\n}\n\nprivate class YamlContextualInput(node: YamlNode, context: SerializersModule, configuration: YamlConfiguration) : YamlInput(node, context, configuration) {\n    override fun decodeElementIndex(descriptor: SerialDescriptor): Int = throw IllegalStateException(\"Must call beginStructure() and use returned Decoder\")\n    override fun decodeValue(): Any = throw IllegalStateException(\"Must call beginStructure() and use returned Decoder\")\n\n    override fun beginStructure(descriptor: SerialDescriptor): CompositeDecoder =\n        createFor(node, serializersModule, configuration, descriptor)\n\n    override fun getCurrentLocation(): Location = node.location\n    override fun getCurrentPath(): YamlPath = node.path\n}\n\nprivate sealed class YamlMapLikeInputBase(map: YamlMap, context: SerializersModule, configuration: YamlConfiguration) : YamlInput(map, context, configuration) {\n    protected lateinit var currentValueDecoder: YamlInput\n    protected lateinit var currentKey: YamlScalar\n    protected var currentlyReadingValue = false\n\n    override fun decodeNotNullMark(): Boolean {\n        if (!haveStartedReadingEntries) {\n            return true\n        }\n\n        return fromCurrentValue { decodeNotNullMark() }\n    }\n\n    override fun decodeString(): String = fromCurrentValue { decodeString() }\n    override fun decodeInt(): Int = fromCurrentValue { decodeInt() }\n    override fun decodeLong(): Long = fromCurrentValue { decodeLong() }\n    override fun decodeShort(): Short = fromCurrentValue { decodeShort() }\n    override fun decodeByte(): Byte = fromCurrentValue { decodeByte() }\n    override fun decodeDouble(): Double = fromCurrentValue { decodeDouble() }\n    override fun decodeFloat(): Float = fromCurrentValue { decodeFloat() }\n    override fun decodeBoolean(): Boolean = fromCurrentValue { decodeBoolean() }\n    override fun decodeChar(): Char = fromCurrentValue { decodeChar() }\n    override fun decodeEnum(enumDescriptor: SerialDescriptor): Int = fromCurrentValue { decodeEnum(enumDescriptor) }\n\n    protected fun <T> fromCurrentValue(action: YamlInput.() -> T): T {\n        try {\n            return action(currentValueDecoder)\n        } catch (e: YamlException) {\n            if (currentlyReadingValue) {\n                throw InvalidPropertyValueException(propertyName, e.message, e.path, e)\n            } else {\n                throw e\n            }\n        }\n    }\n\n    protected val haveStartedReadingEntries: Boolean\n        get() = this::currentValueDecoder.isInitialized\n\n    override fun getCurrentPath(): YamlPath {\n        return if (haveStartedReadingEntries) {\n            currentValueDecoder.node.path\n        } else {\n            node.path\n        }\n    }\n\n    override fun getCurrentLocation(): Location = getCurrentPath().endLocation\n\n    protected val propertyName: String\n        get() = currentKey.content\n}\n\n@OptIn(ExperimentalSerializationApi::class)\nprivate class YamlMapInput(map: YamlMap, context: SerializersModule, configuration: YamlConfiguration) : YamlMapLikeInputBase(map, context, configuration) {\n    private val entriesList = map.entries.entries.toList()\n    private var nextIndex = 0\n    private lateinit var currentEntry: Map.Entry<YamlScalar, YamlNode>\n\n    override fun decodeElementIndex(descriptor: SerialDescriptor): Int {\n        if (nextIndex == entriesList.size * 2) {\n            return CompositeDecoder.DECODE_DONE\n        }\n\n        val entryIndex = nextIndex / 2\n        currentEntry = entriesList[entryIndex]\n        currentKey = currentEntry.key\n        currentlyReadingValue = nextIndex % 2 != 0\n\n        currentValueDecoder = when (currentlyReadingValue) {\n            true ->\n                try {\n                    createFor(currentEntry.value, serializersModule, configuration, descriptor.getElementDescriptor(1))\n                } catch (e: IncorrectTypeException) {\n                    throw InvalidPropertyValueException(propertyName, e.message, e.path, e)\n                }\n\n            false -> createFor(currentKey, serializersModule, configuration, descriptor.getElementDescriptor(0))\n        }\n\n        return nextIndex++\n    }\n\n    override fun beginStructure(descriptor: SerialDescriptor): CompositeDecoder {\n        if (haveStartedReadingEntries) {\n            return fromCurrentValue { beginStructure(descriptor) }\n        }\n\n        return super.beginStructure(descriptor)\n    }\n}\n\n@OptIn(ExperimentalSerializationApi::class)\nprivate class YamlObjectInput(map: YamlMap, context: SerializersModule, configuration: YamlConfiguration) : YamlMapLikeInputBase(map, context, configuration) {\n    private val entriesList = map.entries.entries.toList()\n    private var nextIndex = 0\n\n    override fun decodeElementIndex(descriptor: SerialDescriptor): Int {\n        while (true) {\n            if (nextIndex == entriesList.size) {\n                return CompositeDecoder.DECODE_DONE\n            }\n\n            val currentEntry = entriesList[nextIndex]\n            currentKey = currentEntry.key\n            val fieldDescriptorIndex = descriptor.getElementIndex(propertyName)\n\n            if (fieldDescriptorIndex == UNKNOWN_NAME) {\n                if (configuration.strictMode) {\n                    throwUnknownProperty(propertyName, currentKey.path, descriptor)\n                } else {\n                    nextIndex++\n                    continue\n                }\n            }\n\n            try {\n                currentValueDecoder = createFor(entriesList[nextIndex].value, serializersModule, configuration, descriptor.getElementDescriptor(fieldDescriptorIndex))\n            } catch (e: IncorrectTypeException) {\n                throw InvalidPropertyValueException(propertyName, e.message, e.path, e)\n            }\n\n            currentlyReadingValue = true\n            nextIndex++\n\n            return fieldDescriptorIndex\n        }\n    }\n\n    private fun throwUnknownProperty(name: String, path: YamlPath, desc: SerialDescriptor): Nothing {\n        val knownPropertyNames = (0 until desc.elementsCount)\n            .map { desc.getElementName(it) }\n            .toSet()\n\n        throw UnknownPropertyException(name, knownPropertyNames, path)\n    }\n\n    override fun beginStructure(descriptor: SerialDescriptor): CompositeDecoder {\n        if (haveStartedReadingEntries) {\n            return fromCurrentValue { beginStructure(descriptor) }\n        }\n\n        return super.beginStructure(descriptor)\n    }\n}\n\n@OptIn(ExperimentalSerializationApi::class)\nprivate class YamlPolymorphicInput(private val typeName: String, private val typeNamePath: YamlPath, private val contentNode: YamlNode, context: SerializersModule, configuration: YamlConfiguration) : YamlInput(contentNode, context, configuration) {\n    private var currentField = CurrentField.NotStarted\n    private lateinit var contentDecoder: YamlInput\n\n    override fun getCurrentLocation(): Location = contentNode.location\n    override fun getCurrentPath(): YamlPath = contentNode.path\n\n    override fun decodeElementIndex(descriptor: SerialDescriptor): Int {\n        return when (currentField) {\n            CurrentField.NotStarted -> {\n                currentField = CurrentField.Type\n                0\n            }\n            CurrentField.Type -> {\n                when (contentNode) {\n                    is YamlScalar -> contentDecoder = YamlScalarInput(contentNode, serializersModule, configuration)\n                    is YamlNull -> contentDecoder = YamlNullInput(contentNode, serializersModule, configuration)\n                }\n\n                currentField = CurrentField.Content\n                1\n            }\n            CurrentField.Content -> CompositeDecoder.DECODE_DONE\n        }\n    }\n\n    override fun decodeNotNullMark(): Boolean = maybeCallOnContent(blockOnType = { true }, blockOnContent = YamlInput::decodeNotNullMark)\n    override fun decodeNull(): Nothing? = maybeCallOnContent(\"decodeNull\", blockOnContent = YamlInput::decodeNull)\n    override fun decodeBoolean(): Boolean = maybeCallOnContent(\"decodeBoolean\", blockOnContent = YamlInput::decodeBoolean)\n    override fun decodeByte(): Byte = maybeCallOnContent(\"decodeByte\", blockOnContent = YamlInput::decodeByte)\n    override fun decodeShort(): Short = maybeCallOnContent(\"decodeShort\", blockOnContent = YamlInput::decodeShort)\n    override fun decodeInt(): Int = maybeCallOnContent(\"decodeInt\", blockOnContent = YamlInput::decodeInt)\n    override fun decodeLong(): Long = maybeCallOnContent(\"decodeLong\", blockOnContent = YamlInput::decodeLong)\n    override fun decodeFloat(): Float = maybeCallOnContent(\"decodeFloat\", blockOnContent = YamlInput::decodeFloat)\n    override fun decodeDouble(): Double = maybeCallOnContent(\"decodeDouble\", blockOnContent = YamlInput::decodeDouble)\n    override fun decodeChar(): Char = maybeCallOnContent(\"decodeChar\", blockOnContent = YamlInput::decodeChar)\n    override fun decodeString(): String = maybeCallOnContent(blockOnType = { typeName }, blockOnContent = YamlInput::decodeString)\n    override fun decodeEnum(enumDescriptor: SerialDescriptor): Int = maybeCallOnContent(\"decodeEnum\") { decodeEnum(enumDescriptor) }\n\n    override fun beginStructure(descriptor: SerialDescriptor): CompositeDecoder {\n        return when (currentField) {\n            CurrentField.NotStarted, CurrentField.Type -> super.beginStructure(descriptor)\n            CurrentField.Content -> {\n                contentDecoder = createFor(contentNode, serializersModule, configuration, descriptor)\n\n                return contentDecoder\n            }\n        }\n    }\n\n    private inline fun <T> maybeCallOnContent(functionName: String, blockOnContent: YamlInput.() -> T): T =\n        maybeCallOnContent(blockOnType = { throw UnsupportedOperationException(\"Can't call $functionName() on type field\") }, blockOnContent = blockOnContent)\n\n    private inline fun <T> maybeCallOnContent(blockOnType: () -> T, blockOnContent: YamlInput.() -> T): T {\n        return when (currentField) {\n            CurrentField.NotStarted, CurrentField.Type -> blockOnType()\n            CurrentField.Content -> contentDecoder.blockOnContent()\n        }\n    }\n\n    override fun <T> decodeSerializableValue(deserializer: DeserializationStrategy<T>): T {\n        try {\n            return super.decodeSerializableValue(deserializer)\n        } catch (e: SerializationException) {\n            throwIfUnknownPolymorphicTypeException(e, deserializer)\n\n            throw e\n        }\n    }\n\n    private fun throwIfUnknownPolymorphicTypeException(e: Exception, deserializer: DeserializationStrategy<*>) {\n        val message = e.message ?: return\n        val match = unknownPolymorphicTypeExceptionMessage.matchEntire(message) ?: return\n        val unknownType = match.groupValues[1]\n        val className = match.groupValues[2]\n\n        val knownTypes = when (deserializer.descriptor.kind) {\n            PolymorphicKind.SEALED -> getKnownTypesForSealedType(deserializer)\n            PolymorphicKind.OPEN -> getKnownTypesForOpenType(className)\n            else -> throw IllegalArgumentException(\"Can't get known types for descriptor of kind ${deserializer.descriptor.kind}\")\n        }\n\n        throw UnknownPolymorphicTypeException(unknownType, knownTypes, typeNamePath, e)\n    }\n\n    private fun getKnownTypesForSealedType(deserializer: DeserializationStrategy<*>): Set<String> {\n        val typesDescriptor = deserializer.descriptor.getElementDescriptor(1)\n\n        return typesDescriptor.elementNames.toSet()\n    }\n\n    private fun getKnownTypesForOpenType(className: String): Set<String> {\n        val knownTypes = mutableSetOf<String>()\n\n        serializersModule.dumpTo(object : SerializersModuleCollector {\n            override fun <T : Any> contextual(kClass: KClass<T>, provider: (typeArgumentsSerializers: List<KSerializer<*>>) -> KSerializer<*>) {}\n\n            // FIXME: ideally we'd be able to get the name as used by the SerialModule (eg. the values in 'polyBase2NamedSerializers' in SerialModuleImpl, but these aren't exposed.\n            // The serializer's descriptor's name seems to be the same value.\n            override fun <Base : Any, Sub : Base> polymorphic(baseClass: KClass<Base>, actualClass: KClass<Sub>, actualSerializer: KSerializer<Sub>) {\n                if (baseClass.simpleName == className) {\n                    knownTypes.add(actualSerializer.descriptor.serialName)\n                }\n            }\n\n            override fun <Base : Any> polymorphicDefault(baseClass: KClass<Base>, defaultSerializerProvider: (className: String?) -> DeserializationStrategy<out Base>?) {\n                throw UnsupportedOperationException(\"This method should never be called.\")\n            }\n        })\n\n        return knownTypes\n    }\n\n    private enum class CurrentField {\n        NotStarted,\n        Type,\n        Content\n    }\n\n    companion object {\n        private val unknownPolymorphicTypeExceptionMessage: Regex = \"\"\"^Class '(.*)' is not registered for polymorphic serialization in the scope of '(.*)'.\\nMark the base class as 'sealed' or register the serializer explicitly.$\"\"\".toRegex()\n    }\n}\n\n@OptIn(ExperimentalSerializationApi::class)\nprivate val SerialKind.friendlyDescription: String\n    get() {\n        return when (this) {\n            is StructureKind.MAP -> \"a map\"\n            is StructureKind.CLASS -> \"an object\"\n            is StructureKind.OBJECT -> \"an object\"\n            is StructureKind.LIST -> \"a list\"\n            is PrimitiveKind.STRING -> \"a string\"\n            is PrimitiveKind.BOOLEAN -> \"a boolean\"\n            is PrimitiveKind.BYTE -> \"a byte\"\n            is PrimitiveKind.CHAR -> \"a character\"\n            is PrimitiveKind.DOUBLE -> \"a double\"\n            is PrimitiveKind.FLOAT -> \"a float\"\n            is PrimitiveKind.INT -> \"an integer\"\n            is PrimitiveKind.SHORT -> \"a short\"\n            is PrimitiveKind.LONG -> \"a long\"\n            is SerialKind.ENUM -> \"an enumeration value\"\n            else -> \"a $this value\"\n        }\n    }\n", "/*\n\n   Copyright 2018-2021 Charles Korn.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n@file:OptIn(InternalSerializationApi::class, ExperimentalSerializationApi::class)\n\npackage com.charleskorn.kaml\n\nimport ch.tutteli.atrium.api.fluent.en_GB.cause\nimport ch.tutteli.atrium.api.fluent.en_GB.message\nimport ch.tutteli.atrium.api.fluent.en_GB.toBe\nimport ch.tutteli.atrium.api.fluent.en_GB.toThrow\nimport ch.tutteli.atrium.api.verbs.expect\nimport com.charleskorn.kaml.testobjects.NestedObjects\nimport com.charleskorn.kaml.testobjects.PolymorphicWrapper\nimport com.charleskorn.kaml.testobjects.SealedWrapper\nimport com.charleskorn.kaml.testobjects.SimpleStructure\nimport com.charleskorn.kaml.testobjects.Team\nimport com.charleskorn.kaml.testobjects.TestEnum\nimport com.charleskorn.kaml.testobjects.TestSealedStructure\nimport com.charleskorn.kaml.testobjects.UnsealedClass\nimport com.charleskorn.kaml.testobjects.UnsealedString\nimport com.charleskorn.kaml.testobjects.UnwrappedInt\nimport com.charleskorn.kaml.testobjects.UnwrappedInterface\nimport com.charleskorn.kaml.testobjects.UnwrappedString\nimport com.charleskorn.kaml.testobjects.polymorphicModule\nimport kotlinx.serialization.Contextual\nimport kotlinx.serialization.ExperimentalSerializationApi\nimport kotlinx.serialization.InternalSerializationApi\nimport kotlinx.serialization.KSerializer\nimport kotlinx.serialization.PolymorphicSerializer\nimport kotlinx.serialization.Serializable\nimport kotlinx.serialization.builtins.ListSerializer\nimport kotlinx.serialization.builtins.MapSerializer\nimport kotlinx.serialization.builtins.nullable\nimport kotlinx.serialization.builtins.serializer\nimport kotlinx.serialization.descriptors.PrimitiveKind\nimport kotlinx.serialization.descriptors.PrimitiveSerialDescriptor\nimport kotlinx.serialization.descriptors.SerialDescriptor\nimport kotlinx.serialization.descriptors.SerialKind\nimport kotlinx.serialization.descriptors.StructureKind\nimport kotlinx.serialization.descriptors.buildClassSerialDescriptor\nimport kotlinx.serialization.descriptors.buildSerialDescriptor\nimport kotlinx.serialization.encoding.Decoder\nimport kotlinx.serialization.encoding.Encoder\nimport kotlinx.serialization.modules.serializersModuleOf\nimport org.spekframework.spek2.Spek\nimport org.spekframework.spek2.style.specification.describe\n\nobject YamlReadingTest : Spek({\n    describe(\"a YAML parser\") {\n        describe(\"parsing scalars\") {\n            context(\"given the input 'hello'\") {\n                val input = \"hello\"\n\n                context(\"parsing that input as a string\") {\n                    val result = Yaml.default.decodeFromString(String.serializer(), input)\n\n                    it(\"deserializes it to the expected string value\") {\n                        expect(result).toBe(\"hello\")\n                    }\n                }\n\n                context(\"parsing that input as a nullable string\") {\n                    val result = Yaml.default.decodeFromString(String.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected string value\") {\n                        expect(result).toBe(\"hello\")\n                    }\n                }\n\n                context(\"parsing that input with a serializer that uses YAML location information when throwing exceptions\") {\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(LocationThrowingSerializer, input) }).toThrow<LocationInformationException> {\n                            message { toBe(\"Serializer called with location (1, 1) and path: <root>\") }\n                        }\n                    }\n                }\n            }\n\n            context(\"given the input '123'\") {\n                val input = \"123\"\n\n                context(\"parsing that input as an integer\") {\n                    val result = Yaml.default.decodeFromString(Int.serializer(), input)\n\n                    it(\"deserializes it to the expected integer\") {\n                        expect(result).toBe(123)\n                    }\n                }\n\n                context(\"parsing that input as a long\") {\n                    val result = Yaml.default.decodeFromString(Long.serializer(), input)\n\n                    it(\"deserializes it to the expected long\") {\n                        expect(result).toBe(123)\n                    }\n                }\n\n                context(\"parsing that input as a short\") {\n                    val result = Yaml.default.decodeFromString(Short.serializer(), input)\n\n                    it(\"deserializes it to the expected short\") {\n                        expect(result).toBe(123)\n                    }\n                }\n\n                context(\"parsing that input as a byte\") {\n                    val result = Yaml.default.decodeFromString(Byte.serializer(), input)\n\n                    it(\"deserializes it to the expected byte\") {\n                        expect(result).toBe(123)\n                    }\n                }\n\n                context(\"parsing that input as a double\") {\n                    val result = Yaml.default.decodeFromString(Double.serializer(), input)\n\n                    it(\"deserializes it to the expected double\") {\n                        expect(result).toBe(123.0)\n                    }\n                }\n\n                context(\"parsing that input as a float\") {\n                    val result = Yaml.default.decodeFromString(Float.serializer(), input)\n\n                    it(\"deserializes it to the expected float\") {\n                        expect(result).toBe(123.0f)\n                    }\n                }\n\n                context(\"parsing that input as a nullable integer\") {\n                    val result = Yaml.default.decodeFromString(Int.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected integer\") {\n                        expect(result).toBe(123)\n                    }\n                }\n\n                context(\"parsing that input as a nullable long\") {\n                    val result = Yaml.default.decodeFromString(Long.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected long\") {\n                        expect(result).toBe(123)\n                    }\n                }\n\n                context(\"parsing that input as a nullable short\") {\n                    val result = Yaml.default.decodeFromString(Short.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected short\") {\n                        expect(result).toBe(123)\n                    }\n                }\n\n                context(\"parsing that input as a nullable byte\") {\n                    val result = Yaml.default.decodeFromString(Byte.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected byte\") {\n                        expect(result).toBe(123)\n                    }\n                }\n\n                context(\"parsing that input as a nullable double\") {\n                    val result = Yaml.default.decodeFromString(Double.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected double\") {\n                        expect(result).toBe(123.0)\n                    }\n                }\n\n                context(\"parsing that input as a nullable float\") {\n                    val result = Yaml.default.decodeFromString(Float.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected float\") {\n                        expect(result).toBe(123.0f)\n                    }\n                }\n            }\n\n            context(\"given the input 'true'\") {\n                val input = \"true\"\n\n                context(\"parsing that input as a boolean\") {\n                    val result = Yaml.default.decodeFromString(Boolean.serializer(), input)\n\n                    it(\"deserializes it to the expected boolean value\") {\n                        expect(result).toBe(true)\n                    }\n                }\n\n                context(\"parsing that input as a nullable boolean\") {\n                    val result = Yaml.default.decodeFromString(Boolean.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected boolean value\") {\n                        expect(result).toBe(true)\n                    }\n                }\n            }\n\n            context(\"given the input 'c'\") {\n                val input = \"c\"\n\n                context(\"parsing that input as a character\") {\n                    val result = Yaml.default.decodeFromString(Char.serializer(), input)\n\n                    it(\"deserializes it to the expected character value\") {\n                        expect(result).toBe('c')\n                    }\n                }\n\n                context(\"parsing that input as a nullable character\") {\n                    val result = Yaml.default.decodeFromString(Char.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected character value\") {\n                        expect(result).toBe('c')\n                    }\n                }\n            }\n\n            mapOf(\n                \"Value1\" to TestEnum.Value1,\n                \"Value2\" to TestEnum.Value2\n            ).forEach { (input, expectedValue) ->\n                context(\"given the input '$input'\") {\n                    context(\"parsing that input as an enumeration value\") {\n                        val result = Yaml.default.decodeFromString(TestEnum.serializer(), input)\n\n                        it(\"deserializes it to the expected enumeration value\") {\n                            expect(result).toBe(expectedValue)\n                        }\n                    }\n                }\n            }\n\n            context(\"parsing an invalid enumeration value\") {\n                it(\"throws an appropriate exception\") {\n                    expect({ Yaml.default.decodeFromString(TestEnum.serializer(), \"nonsense\") }).toThrow<YamlScalarFormatException> {\n                        message { toBe(\"Value 'nonsense' is not a valid option, permitted choices are: Value1, Value2\") }\n                        line { toBe(1) }\n                        column { toBe(1) }\n                        path { toBe(YamlPath.root) }\n                    }\n                }\n            }\n        }\n\n        describe(\"parsing null values\") {\n            val input = \"null\"\n\n            context(\"parsing a null value as a nullable string\") {\n                val result = Yaml.default.decodeFromString(String.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    expect(result).toBe(null)\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable string\") {\n                it(\"throws an appropriate exception\") {\n                    expect({ Yaml.default.decodeFromString(String.serializer(), input) }).toThrow<UnexpectedNullValueException> {\n                        message { toBe(\"Unexpected null or empty value for non-null field.\") }\n                        line { toBe(1) }\n                        column { toBe(1) }\n                        path { toBe(YamlPath.root) }\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable integer\") {\n                val result = Yaml.default.decodeFromString(Int.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    expect(result).toBe(null)\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable integer\") {\n                it(\"throws an appropriate exception\") {\n                    expect({ Yaml.default.decodeFromString(Int.serializer(), input) }).toThrow<UnexpectedNullValueException> {\n                        message { toBe(\"Unexpected null or empty value for non-null field.\") }\n                        line { toBe(1) }\n                        column { toBe(1) }\n                        path { toBe(YamlPath.root) }\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable long\") {\n                val result = Yaml.default.decodeFromString(Long.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    expect(result).toBe(null)\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable long\") {\n                it(\"throws an appropriate exception\") {\n                    expect({ Yaml.default.decodeFromString(Long.serializer(), input) }).toThrow<UnexpectedNullValueException> {\n                        message { toBe(\"Unexpected null or empty value for non-null field.\") }\n                        line { toBe(1) }\n                        column { toBe(1) }\n                        path { toBe(YamlPath.root) }\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable short\") {\n                val result = Yaml.default.decodeFromString(Short.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    expect(result).toBe(null)\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable short\") {\n                it(\"throws an appropriate exception\") {\n                    expect({ Yaml.default.decodeFromString(Short.serializer(), input) }).toThrow<UnexpectedNullValueException> {\n                        message { toBe(\"Unexpected null or empty value for non-null field.\") }\n                        line { toBe(1) }\n                        column { toBe(1) }\n                        path { toBe(YamlPath.root) }\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable byte\") {\n                val result = Yaml.default.decodeFromString(Byte.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    expect(result).toBe(null)\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable byte\") {\n                it(\"throws an appropriate exception\") {\n                    expect({ Yaml.default.decodeFromString(Byte.serializer(), input) }).toThrow<UnexpectedNullValueException> {\n                        message { toBe(\"Unexpected null or empty value for non-null field.\") }\n                        line { toBe(1) }\n                        column { toBe(1) }\n                        path { toBe(YamlPath.root) }\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable double\") {\n                val result = Yaml.default.decodeFromString(Double.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    expect(result).toBe(null)\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable double\") {\n                it(\"throws an appropriate exception\") {\n                    expect({ Yaml.default.decodeFromString(Double.serializer(), input) }).toThrow<UnexpectedNullValueException> {\n                        message { toBe(\"Unexpected null or empty value for non-null field.\") }\n                        line { toBe(1) }\n                        column { toBe(1) }\n                        path { toBe(YamlPath.root) }\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable float\") {\n                val result = Yaml.default.decodeFromString(Float.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    expect(result).toBe(null)\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable float\") {\n                it(\"throws an appropriate exception\") {\n                    expect({ Yaml.default.decodeFromString(Float.serializer(), input) }).toThrow<UnexpectedNullValueException> {\n                        message { toBe(\"Unexpected null or empty value for non-null field.\") }\n                        line { toBe(1) }\n                        column { toBe(1) }\n                        path { toBe(YamlPath.root) }\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable boolean\") {\n                val result = Yaml.default.decodeFromString(Boolean.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    expect(result).toBe(null)\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable boolean\") {\n                it(\"throws an appropriate exception\") {\n                    expect({ Yaml.default.decodeFromString(Boolean.serializer(), input) }).toThrow<UnexpectedNullValueException> {\n                        message { toBe(\"Unexpected null or empty value for non-null field.\") }\n                        line { toBe(1) }\n                        column { toBe(1) }\n                        path { toBe(YamlPath.root) }\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable character\") {\n                val result = Yaml.default.decodeFromString(Char.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    expect(result).toBe(null)\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable character\") {\n                it(\"throws an appropriate exception\") {\n                    expect({ Yaml.default.decodeFromString(Char.serializer(), input) }).toThrow<UnexpectedNullValueException> {\n                        message { toBe(\"Unexpected null or empty value for non-null field.\") }\n                        line { toBe(1) }\n                        column { toBe(1) }\n                        path { toBe(YamlPath.root) }\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable enum\") {\n                val result = Yaml.default.decodeFromString(TestEnum.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    expect(result).toBe(null)\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable enum\") {\n                it(\"throws an appropriate exception\") {\n                    expect({ Yaml.default.decodeFromString(TestEnum.serializer(), input) }).toThrow<UnexpectedNullValueException> {\n                        message { toBe(\"Unexpected null or empty value for non-null field.\") }\n                        line { toBe(1) }\n                        column { toBe(1) }\n                        path { toBe(YamlPath.root) }\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable list\") {\n                val result = Yaml.default.decodeFromString(ListSerializer(String.serializer()).nullable, input)\n\n                it(\"returns a null value\") {\n                    expect(result).toBe(null)\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable list\") {\n                it(\"throws an appropriate exception\") {\n                    expect({ Yaml.default.decodeFromString(ListSerializer(String.serializer()), input) }).toThrow<UnexpectedNullValueException> {\n                        message { toBe(\"Unexpected null or empty value for non-null field.\") }\n                        line { toBe(1) }\n                        column { toBe(1) }\n                        path { toBe(YamlPath.root) }\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable object\") {\n                val result = Yaml.default.decodeFromString(ComplexStructure.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    expect(result).toBe(null)\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable object\") {\n                it(\"throws an appropriate exception\") {\n                    expect({ Yaml.default.decodeFromString(ComplexStructure.serializer(), input) }).toThrow<UnexpectedNullValueException> {\n                        message { toBe(\"Unexpected null or empty value for non-null field.\") }\n                        line { toBe(1) }\n                        column { toBe(1) }\n                        path { toBe(YamlPath.root) }\n                    }\n                }\n            }\n\n            context(\"parsing a null value with a serializer that uses YAML location information when throwing exceptions\") {\n                it(\"throws an exception with the correct location information\") {\n                    expect({ Yaml.default.decodeFromString(LocationThrowingSerializer, input) }).toThrow<LocationInformationException> {\n                        message { toBe(\"Serializer called with location (1, 1) and path: <root>\") }\n                    }\n                }\n            }\n        }\n\n        describe(\"parsing lists\") {\n            context(\"given a list of strings\") {\n                val input = \"\"\"\n                    - thing1\n                    - thing2\n                    - thing3\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(String.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        expect(result).toBe(listOf(\"thing1\", \"thing2\", \"thing3\"))\n                    }\n                }\n\n                context(\"parsing that input as a nullable list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(String.serializer()).nullable, input)\n\n                    it(\"deserializes it to the expected value\") {\n                        expect(result).toBe(listOf(\"thing1\", \"thing2\", \"thing3\"))\n                    }\n                }\n\n                context(\"parsing that input with a serializer that uses YAML location information when throwing exceptions\") {\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(ListSerializer(LocationThrowingSerializer), input) }).toThrow<LocationInformationException> {\n                            message { toBe(\"Serializer called with location (1, 3) and path: [0]\") }\n                        }\n                    }\n                }\n            }\n\n            context(\"given a list of numbers\") {\n                val input = \"\"\"\n                    - 123\n                    - 45\n                    - 6\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list of integers\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Int.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        expect(result).toBe(listOf(123, 45, 6))\n                    }\n                }\n\n                context(\"parsing that input as a list of longs\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Long.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        expect(result).toBe(listOf(123L, 45, 6))\n                    }\n                }\n\n                context(\"parsing that input as a list of shorts\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Short.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        expect(result).toBe(listOf(123.toShort(), 45, 6))\n                    }\n                }\n\n                context(\"parsing that input as a list of bytes\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Byte.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        expect(result).toBe(listOf(123.toByte(), 45, 6))\n                    }\n                }\n\n                context(\"parsing that input as a list of doubles\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Double.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        expect(result).toBe(listOf(123.0, 45.0, 6.0))\n                    }\n                }\n\n                context(\"parsing that input as a list of floats\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Float.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        expect(result).toBe(listOf(123.0f, 45.0f, 6.0f))\n                    }\n                }\n            }\n\n            context(\"given a list of booleans\") {\n                val input = \"\"\"\n                    - true\n                    - false\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Boolean.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        expect(result).toBe(listOf(true, false))\n                    }\n                }\n            }\n\n            context(\"given a list of enum values\") {\n                val input = \"\"\"\n                    - Value1\n                    - Value2\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(TestEnum.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        expect(result).toBe(listOf(TestEnum.Value1, TestEnum.Value2))\n                    }\n                }\n            }\n\n            context(\"given a list of characters\") {\n                val input = \"\"\"\n                    - a\n                    - b\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Char.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        expect(result).toBe(listOf('a', 'b'))\n                    }\n                }\n            }\n\n            context(\"given a list of nullable strings\") {\n                val input = \"\"\"\n                    - thing1\n                    - null\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(String.serializer().nullable), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        expect(result).toBe(listOf(\"thing1\", null))\n                    }\n                }\n            }\n\n            context(\"given a list of lists\") {\n                val input = \"\"\"\n                    - [thing1, thing2]\n                    - [thing3]\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(ListSerializer(String.serializer())), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        expect(result).toBe(\n                            listOf(\n                                listOf(\"thing1\", \"thing2\"),\n                                listOf(\"thing3\")\n                            )\n                        )\n                    }\n                }\n            }\n\n            context(\"given a list of objects\") {\n                val input = \"\"\"\n                    - name: thing1\n                    - name: thing2\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(SimpleStructure.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        expect(result).toBe(\n                            listOf(\n                                SimpleStructure(\"thing1\"),\n                                SimpleStructure(\"thing2\")\n                            )\n                        )\n                    }\n                }\n            }\n        }\n\n        describe(\"parsing objects\") {\n            context(\"given some input representing an object with an optional value specified\") {\n                val input = \"\"\"\n                    string: Alex\n                    byte: 12\n                    short: 1234\n                    int: 123456\n                    long: 1234567\n                    float: 1.2\n                    double: 2.4\n                    enum: Value1\n                    boolean: true\n                    char: A\n                    nullable: present\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(ComplexStructure.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        expect(result).toBe(\n                            ComplexStructure(\n                                \"Alex\",\n                                12,\n                                1234,\n                                123456,\n                                1234567,\n                                1.2f,\n                                2.4,\n                                TestEnum.Value1,\n                                true,\n                                'A',\n                                \"present\"\n                            )\n                        )\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with an optional value specified as null\") {\n                val input = \"\"\"\n                    string: Alex\n                    byte: 12\n                    short: 1234\n                    int: 123456\n                    long: 1234567\n                    float: 1.2\n                    double: 2.4\n                    enum: Value1\n                    boolean: true\n                    char: A\n                    nullable: null\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(ComplexStructure.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        expect(result).toBe(\n                            ComplexStructure(\n                                \"Alex\",\n                                12,\n                                1234,\n                                123456,\n                                1234567,\n                                1.2f,\n                                2.4,\n                                TestEnum.Value1,\n                                true,\n                                'A',\n                                null\n                            )\n                        )\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with an optional value not specified\") {\n                val input = \"\"\"\n                    string: Alex\n                    byte: 12\n                    short: 1234\n                    int: 123456\n                    long: 1234567\n                    float: 1.2\n                    double: 2.4\n                    enum: Value1\n                    boolean: true\n                    char: A\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(ComplexStructure.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        expect(result).toBe(\n                            ComplexStructure(\n                                \"Alex\",\n                                12,\n                                1234,\n                                123456,\n                                1234567,\n                                1.2f,\n                                2.4,\n                                TestEnum.Value1,\n                                true,\n                                'A',\n                                null\n                            )\n                        )\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with an embedded list\") {\n                val input = \"\"\"\n                    members:\n                        - Alex\n                        - Jamie\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(Team.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        expect(result).toBe(Team(listOf(\"Alex\", \"Jamie\")))\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with an embedded object\") {\n                val input = \"\"\"\n                    firstPerson:\n                        name: Alex\n                    secondPerson:\n                        name: Jamie\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(NestedObjects.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        expect(result).toBe(NestedObjects(SimpleStructure(\"Alex\"), SimpleStructure(\"Jamie\")))\n                    }\n                }\n            }\n\n            context(\"given some input representing an object where the keys are in a different order to the object definition\") {\n                val input = \"\"\"\n                    secondPerson:\n                        name: Jamie\n                    firstPerson:\n                        name: Alex\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(NestedObjects.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        expect(result).toBe(NestedObjects(SimpleStructure(\"Alex\"), SimpleStructure(\"Jamie\")))\n                    }\n                }\n            }\n\n            context(\"given some tagged input representing an arbitrary list\") {\n                val input = \"\"\"\n                    !!list\n                        - 5\n                        - 3\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Int.serializer()), input)\n                    it(\"deserializes it to a list ignoring the tag\") {\n                        expect(result).toBe(listOf(5, 3))\n                    }\n                }\n\n                context(\"parsing that input with a serializer that uses YAML location information when throwing exceptions\") {\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(LocationThrowingSerializer, input) }).toThrow<LocationInformationException> {\n                            message { toBe(\"Serializer called with location (1, 1) and path: <root>\") }\n                        }\n                    }\n                }\n            }\n\n            context(\"given some tagged input representing an arbitrary map\") {\n                val input = \"\"\"\n                    !!map\n                    foo: bar\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as map\") {\n                    val result = Yaml.default.decodeFromString(\n                        MapSerializer(String.serializer(), String.serializer()),\n                        input\n                    )\n                    it(\"deserializes it to a Map ignoring the tag\") {\n                        expect(result).toBe(mapOf(\"foo\" to \"bar\"))\n                    }\n                }\n\n                context(\"parsing that input with a serializer that uses YAML location information when throwing exceptions\") {\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(LocationThrowingMapSerializer, input) }).toThrow<LocationInformationException> {\n                            message { toBe(\"Serializer called with location (1, 1) and path: <root>\") }\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with a missing key\") {\n                val input = \"\"\"\n                    byte: 12\n                    short: 1234\n                    int: 123456\n                    long: 1234567\n                    float: 1.2\n                    double: 2.4\n                    enum: Value1\n                    boolean: true\n                    char: A\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    it(\"throws an appropriate exception\") {\n                        expect({ Yaml.default.decodeFromString(ComplexStructure.serializer(), input) }).toThrow<MissingRequiredPropertyException> {\n                            message { toBe(\"Property 'string' is required but it is missing.\") }\n                            line { toBe(1) }\n                            column { toBe(1) }\n                            propertyName { toBe(\"string\") }\n                            path { toBe(YamlPath.root) }\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with an unknown key\") {\n                val input = \"\"\"\n                    abc123: something\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    it(\"throws an appropriate exception\") {\n                        expect({ Yaml.default.decodeFromString(ComplexStructure.serializer(), input) }).toThrow<UnknownPropertyException> {\n                            message { toBe(\"Unknown property 'abc123'. Known properties are: boolean, byte, char, double, enum, float, int, long, nullable, short, string\") }\n                            line { toBe(1) }\n                            column { toBe(1) }\n                            propertyName { toBe(\"abc123\") }\n                            validPropertyNames { toBe(setOf(\"boolean\", \"byte\", \"char\", \"double\", \"enum\", \"float\", \"int\", \"long\", \"nullable\", \"short\", \"string\")) }\n                            path { toBe(YamlPath.root.withMapElementKey(\"abc123\", Location(1, 1))) }\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with an invalid value for a field\") {\n                mapOf(\n                    \"byte\" to \"Value 'xxx' is not a valid byte value.\",\n                    \"short\" to \"Value 'xxx' is not a valid short value.\",\n                    \"int\" to \"Value 'xxx' is not a valid integer value.\",\n                    \"long\" to \"Value 'xxx' is not a valid long value.\",\n                    \"float\" to \"Value 'xxx' is not a valid floating point value.\",\n                    \"double\" to \"Value 'xxx' is not a valid floating point value.\",\n                    \"enum\" to \"Value 'xxx' is not a valid option, permitted choices are: Value1, Value2\",\n                    \"boolean\" to \"Value 'xxx' is not a valid boolean, permitted choices are: true or false\",\n                    \"char\" to \"Value 'xxx' is not a valid character value.\"\n                ).forEach { (fieldName, errorMessage) ->\n                    context(\"given the invalid field represents a $fieldName\") {\n                        val input = \"$fieldName: xxx\"\n\n                        context(\"parsing that input\") {\n                            it(\"throws an appropriate exception\") {\n                                expect({ Yaml.default.decodeFromString(ComplexStructure.serializer(), input) }).toThrow<InvalidPropertyValueException> {\n                                    message { toBe(\"Value for '$fieldName' is invalid: $errorMessage\") }\n                                    line { toBe(1) }\n                                    column { toBe(fieldName.length + 3) }\n                                    propertyName { toBe(fieldName) }\n                                    reason { toBe(errorMessage) }\n                                    path { toBe(YamlPath.root.withMapElementKey(fieldName, Location(1, 1)).withMapElementValue(Location(1, fieldName.length + 3))) }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with a null value for a non-nullable scalar field\") {\n                val input = \"name: null\"\n\n                context(\"parsing that input\") {\n                    it(\"throws an appropriate exception\") {\n                        expect({ Yaml.default.decodeFromString(SimpleStructure.serializer(), input) }).toThrow<InvalidPropertyValueException> {\n                            message { toBe(\"Value for 'name' is invalid: Unexpected null or empty value for non-null field.\") }\n                            line { toBe(1) }\n                            column { toBe(7) }\n                            propertyName { toBe(\"name\") }\n                            reason { toBe(\"Unexpected null or empty value for non-null field.\") }\n                            path { toBe(YamlPath.root.withMapElementKey(\"name\", Location(1, 1)).withMapElementValue(Location(1, 7))) }\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with a null value for a non-nullable nested object field\") {\n                val input = \"firstPerson: null\"\n\n                context(\"parsing that input\") {\n                    it(\"throws an appropriate exception\") {\n                        expect({ Yaml.default.decodeFromString(NestedObjects.serializer(), input) }).toThrow<InvalidPropertyValueException> {\n                            message { toBe(\"Value for 'firstPerson' is invalid: Unexpected null or empty value for non-null field.\") }\n                            line { toBe(1) }\n                            column { toBe(14) }\n                            propertyName { toBe(\"firstPerson\") }\n                            reason { toBe(\"Unexpected null or empty value for non-null field.\") }\n                            path { toBe(YamlPath.root.withMapElementKey(\"firstPerson\", Location(1, 1)).withMapElementValue(Location(1, 14))) }\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with a null value for a nullable nested object field\") {\n\n                val input = \"firstPerson: null\"\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(NullableNestedObject.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        expect(result).toBe(NullableNestedObject(null))\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with a null value for a non-nullable nested list field\") {\n                val input = \"members: null\"\n\n                context(\"parsing that input\") {\n                    it(\"throws an appropriate exception\") {\n                        expect({ Yaml.default.decodeFromString(Team.serializer(), input) }).toThrow<InvalidPropertyValueException> {\n                            message { toBe(\"Value for 'members' is invalid: Unexpected null or empty value for non-null field.\") }\n                            line { toBe(1) }\n                            column { toBe(10) }\n                            propertyName { toBe(\"members\") }\n                            reason { toBe(\"Unexpected null or empty value for non-null field.\") }\n                            path { toBe(YamlPath.root.withMapElementKey(\"members\", Location(1, 1)).withMapElementValue(Location(1, 10))) }\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with a null value for a nullable nested list field\") {\n                val input = \"members: null\"\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(NullableNestedList.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        expect(result).toBe(NullableNestedList(null))\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with a custom serializer for one of its values\") {\n                val input = \"value: something\"\n\n                context(\"parsing that input with a serializer that uses YAML location information when throwing exceptions\") {\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(StructureWithLocationThrowingSerializer.serializer(), input) }).toThrow<LocationInformationException> {\n                            message { toBe(\"Serializer called with location (1, 8) and path: value\") }\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing a generic map\") {\n                val input = \"\"\"\n                    SOME_ENV_VAR: somevalue\n                    SOME_OTHER_ENV_VAR: someothervalue\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input)\n\n                    it(\"deserializes it to a Kotlin map\") {\n                        expect(result).toBe(\n                            mapOf(\n                                \"SOME_ENV_VAR\" to \"somevalue\",\n                                \"SOME_OTHER_ENV_VAR\" to \"someothervalue\"\n                            )\n                        )\n                    }\n                }\n\n                context(\"parsing that input with a serializer for the key that uses YAML location information when throwing exceptions\") {\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(MapSerializer(LocationThrowingSerializer, String.serializer()), input) }).toThrow<LocationInformationException> {\n                            message { toBe(\"Serializer called with location (1, 1) and path: SOME_ENV_VAR\") }\n                        }\n                    }\n                }\n\n                context(\"parsing that input with a serializer for the value that uses YAML location information when throwing exceptions\") {\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(MapSerializer(String.serializer(), LocationThrowingSerializer), input) }).toThrow<LocationInformationException> {\n                            message { toBe(\"Serializer called with location (1, 15) and path: SOME_ENV_VAR\") }\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input with some extensions\") {\n                val input = \"\"\"\n                    .some-extension: &name Jamie\n\n                    name: *name\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    val configuration = YamlConfiguration(extensionDefinitionPrefix = \".\")\n                    val yaml = Yaml(configuration = configuration)\n                    val result = yaml.decodeFromString(SimpleStructure.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object, replacing the reference to the extension with the extension\") {\n                        expect(result).toBe(SimpleStructure(\"Jamie\"))\n                    }\n                }\n            }\n\n            context(\"given some input with an additional unknown field\") {\n                val input = \"\"\"\n                    name: Blah Blahson\n                    extra-field: Hello\n                \"\"\".trimIndent()\n\n                context(\"given strict mode is enabled\") {\n                    val configuration = YamlConfiguration(strictMode = true)\n                    val yaml = Yaml(configuration = configuration)\n\n                    context(\"parsing that input\") {\n                        it(\"throws an appropriate exception\") {\n                            expect({ yaml.decodeFromString(SimpleStructure.serializer(), input) }).toThrow<UnknownPropertyException> {\n                                message { toBe(\"Unknown property 'extra-field'. Known properties are: name\") }\n                                line { toBe(2) }\n                                column { toBe(1) }\n                                path { toBe(YamlPath.root.withMapElementKey(\"extra-field\", Location(2, 1))) }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given strict mode is disabled\") {\n                    val configuration = YamlConfiguration(strictMode = false)\n                    val yaml = Yaml(configuration = configuration)\n\n                    context(\"parsing that input\") {\n                        it(\"ignores the extra field and returns a deserialised object\") {\n                            expect(yaml.decodeFromString(SimpleStructure.serializer(), input)).toBe(SimpleStructure(\"Blah Blahson\"))\n                        }\n                    }\n                }\n            }\n\n            context(\"given a nullable object\") {\n                val input = \"\"\"\n                    host: \"db.test.com\"\n                \"\"\".trimIndent()\n\n                val result = Yaml.default.decodeFromString(Database.serializer().nullable, input)\n\n                it(\"deserializes it to the expected object\") {\n                    expect(result).toBe(Database(\"db.test.com\"))\n                }\n            }\n        }\n\n        describe(\"parsing polymorphic values\") {\n            describe(\"given tags are used to store the type information\") {\n                val polymorphicYaml = Yaml(serializersModule = polymorphicModule, configuration = YamlConfiguration(polymorphismStyle = PolymorphismStyle.Tag))\n\n                context(\"given some input where the value should be a sealed class\") {\n                    val input = \"\"\"\n                        !<sealedString>\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            expect(result).toBe(TestSealedStructure.SimpleSealedString(\"asdfg\"))\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input)\n\n                        it(\"deserializes it to a map ignoring the tag\") {\n                            expect(result).toBe(mapOf(\"value\" to \"asdfg\"))\n                        }\n                    }\n                }\n\n                context(\"given some input where the value is a literal\") {\n                    val input = \"\"\"\n                        !<simpleString> \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(PolymorphicSerializer(UnwrappedInterface::class), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            expect(result).toBe(UnwrappedString(\"asdfg\"))\n                        }\n                    }\n\n                    context(\"parsing that input as a string\") {\n                        val result = polymorphicYaml.decodeFromString(String.serializer(), input)\n\n                        it(\"deserializes it to a string ignoring the tag\") {\n                            expect(result).toBe(\"asdfg\")\n                        }\n                    }\n                }\n\n                context(\"given some input where the value should be an unsealed class\") {\n                    val input = \"\"\"\n                        !<unsealedString>\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(PolymorphicSerializer(UnsealedClass::class), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            expect(result).toBe(UnsealedString(\"asdfg\"))\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input)\n\n                        it(\"deserializes it to a map ignoring the tag\") {\n                            expect(result).toBe(mapOf(\"value\" to \"asdfg\"))\n                        }\n                    }\n                }\n\n                context(\"given some input for an object where the property value should be a sealed class\") {\n                    val input = \"\"\"\n                        element: !<sealedString>\n                            value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(SealedWrapper.serializer(), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            expect(result).toBe(SealedWrapper(TestSealedStructure.SimpleSealedString(\"asdfg\")))\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), MapSerializer(String.serializer(), String.serializer())), input)\n\n                        it(\"deserializes it to a map ignoring the tag\") {\n                            expect(result).toBe(mapOf(\"element\" to mapOf(\"value\" to \"asdfg\")))\n                        }\n                    }\n                }\n\n                context(\"given some input for an object where the property value is a literal\") {\n                    val input = \"\"\"\n                        test: !<simpleInt> 42\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(PolymorphicWrapper.serializer(), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            expect(result).toBe(PolymorphicWrapper(UnwrappedInt(42)))\n                        }\n                    }\n                }\n\n                context(\"given some tagged input representing a list of polymorphic objects\") {\n                    val input = \"\"\"\n                        - !<sealedString>\n                          value: null\n                        - !<sealedInt>\n                          value: -987\n                        - !<sealedInt>\n                          value: 654\n                        - !<sealedString>\n                          value: \"tests\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(ListSerializer(TestSealedStructure.serializer()), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            expect(result).toBe(\n                                listOf(\n                                    TestSealedStructure.SimpleSealedString(null),\n                                    TestSealedStructure.SimpleSealedInt(-987),\n                                    TestSealedStructure.SimpleSealedInt(654),\n                                    TestSealedStructure.SimpleSealedString(\"tests\")\n                                )\n                            )\n                        }\n                    }\n                }\n\n                context(\"given some untagged input for a polymorphic class\") {\n                    val input = \"\"\"\n                        element:\n                            value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            expect({ polymorphicYaml.decodeFromString(SealedWrapper.serializer(), input) }).toThrow<InvalidPropertyValueException> {\n                                message { toBe(\"Value for 'element' is invalid: Value is missing a type tag (eg. !<type>)\") }\n                                line { toBe(2) }\n                                column { toBe(5) }\n                                cause<MissingTypeTagException>()\n                                path { toBe(YamlPath.root.withMapElementKey(\"element\", Location(1, 1)).withMapElementValue(Location(2, 5))) }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given some untagged input for a polymorphic value\") {\n                    val input = \"\"\"\n                        test: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            expect({ polymorphicYaml.decodeFromString(PolymorphicWrapper.serializer(), input) }).toThrow<InvalidPropertyValueException> {\n                                message { toBe(\"Value for 'test' is invalid: Value is missing a type tag (eg. !<type>)\") }\n                                line { toBe(1) }\n                                column { toBe(7) }\n                                cause<MissingTypeTagException>()\n                                path { toBe(YamlPath.root.withMapElementKey(\"test\", Location(1, 1)).withMapElementValue(Location(1, 7))) }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given some untagged null input for a polymorphic value\") {\n                    val input = \"\"\"\n                        test: null\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            expect({ polymorphicYaml.decodeFromString(PolymorphicWrapper.serializer(), input) }).toThrow<InvalidPropertyValueException> {\n                                message { toBe(\"Value for 'test' is invalid: Value is missing a type tag (eg. !<type>)\") }\n                                line { toBe(1) }\n                                column { toBe(7) }\n                                cause<MissingTypeTagException>()\n                                path { toBe(YamlPath.root.withMapElementKey(\"test\", Location(1, 1)).withMapElementValue(Location(1, 7))) }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given a polymorphic value for a property from an unsealed type with an unknown type tag\") {\n                    val input = \"\"\"\n                        !<someOtherType> 42\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            expect({ polymorphicYaml.decodeFromString(PolymorphicSerializer(UnsealedClass::class), input) }).toThrow<UnknownPolymorphicTypeException> {\n                                message { toBe(\"Unknown type 'someOtherType'. Known types are: unsealedBoolean, unsealedString\") }\n                                line { toBe(1) }\n                                column { toBe(1) }\n                                typeName { toBe(\"someOtherType\") }\n                                validTypeNames { toBe(setOf(\"unsealedBoolean\", \"unsealedString\")) }\n                                path { toBe(YamlPath.root) }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given a polymorphic value for a property from a sealed type with an unknown type tag\") {\n                    val input = \"\"\"\n                        !<someOtherType> 42\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            expect({ polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }).toThrow<UnknownPolymorphicTypeException> {\n                                message { toBe(\"Unknown type 'someOtherType'. Known types are: sealedInt, sealedString\") }\n                                line { toBe(1) }\n                                column { toBe(1) }\n                                typeName { toBe(\"someOtherType\") }\n                                validTypeNames { toBe(setOf(\"sealedInt\", \"sealedString\")) }\n                                path { toBe(YamlPath.root) }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given a polymorphic value from a literal with an unknown type tag\") {\n                    val input = \"\"\"\n                        !<someOtherType> 42\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            expect({ polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }).toThrow<UnknownPolymorphicTypeException> {\n                                message { toBe(\"Unknown type 'someOtherType'. Known types are: sealedInt, sealedString\") }\n                                line { toBe(1) }\n                                column { toBe(1) }\n                                typeName { toBe(\"someOtherType\") }\n                                validTypeNames { toBe(setOf(\"sealedInt\", \"sealedString\")) }\n                                path { toBe(YamlPath.root) }\n                            }\n                        }\n                    }\n                }\n            }\n\n            describe(\"given a property is used to store the type information\") {\n                val polymorphicYaml = Yaml(serializersModule = polymorphicModule, configuration = YamlConfiguration(polymorphismStyle = PolymorphismStyle.Property))\n\n                context(\"given some input where the value should be a sealed class\") {\n                    val input = \"\"\"\n                        type: sealedString\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            expect(result).toBe(TestSealedStructure.SimpleSealedString(\"asdfg\"))\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input)\n\n                        it(\"deserializes it to a map including the type\") {\n                            expect(result).toBe(mapOf(\"type\" to \"sealedString\", \"value\" to \"asdfg\"))\n                        }\n                    }\n                }\n\n                context(\"given some input where the value should be an unsealed class\") {\n                    val input = \"\"\"\n                        type: unsealedString\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(PolymorphicSerializer(UnsealedClass::class), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            expect(result).toBe(UnsealedString(\"asdfg\"))\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input)\n\n                        it(\"deserializes it to a map ignoring the tag\") {\n                            expect(result).toBe(mapOf(\"type\" to \"unsealedString\", \"value\" to \"asdfg\"))\n                        }\n                    }\n                }\n\n                context(\"given some input for an object where the property value should be a sealed class\") {\n                    val input = \"\"\"\n                        element:\n                            type: sealedString\n                            value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(SealedWrapper.serializer(), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            expect(result).toBe(SealedWrapper(TestSealedStructure.SimpleSealedString(\"asdfg\")))\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), MapSerializer(String.serializer(), String.serializer())), input)\n\n                        it(\"deserializes it to a map ignoring the tag\") {\n                            expect(result).toBe(mapOf(\"element\" to mapOf(\"type\" to \"sealedString\", \"value\" to \"asdfg\")))\n                        }\n                    }\n                }\n\n                context(\"given some input missing a type property\") {\n                    val input = \"\"\"\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            expect({ polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }).toThrow<MissingRequiredPropertyException> {\n                                message { toBe(\"Property 'type' is required but it is missing.\") }\n                                line { toBe(1) }\n                                column { toBe(1) }\n                                propertyName { toBe(\"type\") }\n                                path { toBe(YamlPath.root) }\n                            }\n                        }\n                    }\n                }\n\n                mapOf(\n                    \"a list\" to \"[]\",\n                    \"a map\" to \"{}\",\n                    \"a null value\" to \"null\",\n                    \"a tagged value\" to \"!<tag> sealedString\"\n                ).forEach { description, value ->\n                    context(\"given some input with a type property that is $description\") {\n                        val input = \"\"\"\n                            type: $value\n                            value: \"asdfg\"\n                        \"\"\".trimIndent()\n\n                        context(\"parsing that input\") {\n                            it(\"throws an exception with the correct location information\") {\n                                expect({ polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }).toThrow<InvalidPropertyValueException> {\n                                    message { toBe(\"Value for 'type' is invalid: expected a string, but got $description\") }\n                                    line { toBe(1) }\n                                    column { toBe(7) }\n                                    propertyName { toBe(\"type\") }\n                                    reason { toBe(\"expected a string, but got $description\") }\n                                    path { toBe(YamlPath.root.withMapElementKey(\"type\", Location(1, 1)).withMapElementValue(Location(1, 7))) }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given some tagged input representing a list of polymorphic objects\") {\n                    val input = \"\"\"\n                        - type: sealedString\n                          value: null\n                        - type: sealedInt\n                          value: -987\n                        - type: sealedInt\n                          value: 654\n                        - type: sealedString\n                          value: \"tests\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(ListSerializer(TestSealedStructure.serializer()), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            expect(result).toBe(\n                                listOf(\n                                    TestSealedStructure.SimpleSealedString(null),\n                                    TestSealedStructure.SimpleSealedInt(-987),\n                                    TestSealedStructure.SimpleSealedInt(654),\n                                    TestSealedStructure.SimpleSealedString(\"tests\")\n                                )\n                            )\n                        }\n                    }\n                }\n\n                context(\"given a polymorphic value for a property from an unsealed type with an unknown type tag\") {\n                    val input = \"\"\"\n                        type: someOtherType\n                        value: 123\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            expect({ polymorphicYaml.decodeFromString(PolymorphicSerializer(UnsealedClass::class), input) }).toThrow<UnknownPolymorphicTypeException> {\n                                message { toBe(\"Unknown type 'someOtherType'. Known types are: unsealedBoolean, unsealedString\") }\n                                line { toBe(1) }\n                                column { toBe(7) }\n                                typeName { toBe(\"someOtherType\") }\n                                validTypeNames { toBe(setOf(\"unsealedBoolean\", \"unsealedString\")) }\n                                path { toBe(YamlPath.root.withMapElementKey(\"type\", Location(1, 1)).withMapElementValue(Location(1, 7))) }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given a polymorphic value for a property from a sealed type with an unknown type tag\") {\n                    val input = \"\"\"\n                        type: someOtherType\n                        value: 123\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            expect({ polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }).toThrow<UnknownPolymorphicTypeException> {\n                                message { toBe(\"Unknown type 'someOtherType'. Known types are: sealedInt, sealedString\") }\n                                line { toBe(1) }\n                                column { toBe(7) }\n                                typeName { toBe(\"someOtherType\") }\n                                validTypeNames { toBe(setOf(\"sealedInt\", \"sealedString\")) }\n                                path { toBe(YamlPath.root.withMapElementKey(\"type\", Location(1, 1)).withMapElementValue(Location(1, 7))) }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given some input with a tag and a type property\") {\n                    val input = \"\"\"\n                        !<sealedInt>\n                        type: sealedString\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input)\n\n                        it(\"uses the type from the property and ignores the tag\") {\n                            expect(result).toBe(TestSealedStructure.SimpleSealedString(\"asdfg\"))\n                        }\n                    }\n                }\n            }\n\n            describe(\"given a custom property name is used to store the type information\") {\n                val polymorphicYaml = Yaml(serializersModule = polymorphicModule, configuration = YamlConfiguration(polymorphismStyle = PolymorphismStyle.Property, polymorphismPropertyName = \"kind\"))\n\n                context(\"given some input where the value should be a sealed class\") {\n                    val input = \"\"\"\n                        kind: sealedString\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            expect(result).toBe(TestSealedStructure.SimpleSealedString(\"asdfg\"))\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input)\n\n                        it(\"deserializes it to a map including the type\") {\n                            expect(result).toBe(mapOf(\"kind\" to \"sealedString\", \"value\" to \"asdfg\"))\n                        }\n                    }\n                }\n\n                context(\"given some input where the value should be an unsealed class\") {\n                    val input = \"\"\"\n                        kind: unsealedString\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(PolymorphicSerializer(UnsealedClass::class), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            expect(result).toBe(UnsealedString(\"asdfg\"))\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input)\n\n                        it(\"deserializes it to a map ignoring the tag\") {\n                            expect(result).toBe(mapOf(\"kind\" to \"unsealedString\", \"value\" to \"asdfg\"))\n                        }\n                    }\n                }\n\n                context(\"given some input for an object where the property value should be a sealed class\") {\n                    val input = \"\"\"\n                        element:\n                            kind: sealedString\n                            value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(SealedWrapper.serializer(), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            expect(result).toBe(SealedWrapper(TestSealedStructure.SimpleSealedString(\"asdfg\")))\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), MapSerializer(String.serializer(), String.serializer())), input)\n\n                        it(\"deserializes it to a map ignoring the tag\") {\n                            expect(result).toBe(mapOf(\"element\" to mapOf(\"kind\" to \"sealedString\", \"value\" to \"asdfg\")))\n                        }\n                    }\n                }\n\n                context(\"given some input missing a type property\") {\n                    val input = \"\"\"\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            expect({ polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }).toThrow<MissingRequiredPropertyException> {\n                                message { toBe(\"Property 'kind' is required but it is missing.\") }\n                                line { toBe(1) }\n                                column { toBe(1) }\n                                propertyName { toBe(\"kind\") }\n                                path { toBe(YamlPath.root) }\n                            }\n                        }\n                    }\n                }\n\n                mapOf(\n                    \"a list\" to \"[]\",\n                    \"a map\" to \"{}\",\n                    \"a null value\" to \"null\",\n                    \"a tagged value\" to \"!<tag> sealedString\"\n                ).forEach { description, value ->\n                    context(\"given some input with a type property that is $description\") {\n                        val input = \"\"\"\n                            kind: $value\n                            value: \"asdfg\"\n                        \"\"\".trimIndent()\n\n                        context(\"parsing that input\") {\n                            it(\"throws an exception with the correct location information\") {\n                                expect({ polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }).toThrow<InvalidPropertyValueException> {\n                                    message { toBe(\"Value for 'kind' is invalid: expected a string, but got $description\") }\n                                    line { toBe(1) }\n                                    column { toBe(7) }\n                                    propertyName { toBe(\"kind\") }\n                                    reason { toBe(\"expected a string, but got $description\") }\n                                    path { toBe(YamlPath.root.withMapElementKey(\"kind\", Location(1, 1)).withMapElementValue(Location(1, 7))) }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given some tagged input representing a list of polymorphic objects\") {\n                    val input = \"\"\"\n                        - kind: sealedString\n                          value: null\n                        - kind: sealedInt\n                          value: -987\n                        - kind: sealedInt\n                          value: 654\n                        - kind: sealedString\n                          value: \"tests\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(ListSerializer(TestSealedStructure.serializer()), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            expect(result).toBe(\n                                listOf(\n                                    TestSealedStructure.SimpleSealedString(null),\n                                    TestSealedStructure.SimpleSealedInt(-987),\n                                    TestSealedStructure.SimpleSealedInt(654),\n                                    TestSealedStructure.SimpleSealedString(\"tests\")\n                                )\n                            )\n                        }\n                    }\n                }\n\n                context(\"given a polymorphic value for a property from an unsealed type with an unknown type tag\") {\n                    val input = \"\"\"\n                        kind: someOtherType\n                        value: 123\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            expect({ polymorphicYaml.decodeFromString(PolymorphicSerializer(UnsealedClass::class), input) }).toThrow<UnknownPolymorphicTypeException> {\n                                message { toBe(\"Unknown type 'someOtherType'. Known types are: unsealedBoolean, unsealedString\") }\n                                line { toBe(1) }\n                                column { toBe(7) }\n                                typeName { toBe(\"someOtherType\") }\n                                validTypeNames { toBe(setOf(\"unsealedBoolean\", \"unsealedString\")) }\n                                path { toBe(YamlPath.root.withMapElementKey(\"kind\", Location(1, 1)).withMapElementValue(Location(1, 7))) }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given a polymorphic value for a property from a sealed type with an unknown type tag\") {\n                    val input = \"\"\"\n                        kind: someOtherType\n                        value: 123\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            expect({ polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }).toThrow<UnknownPolymorphicTypeException> {\n                                message { toBe(\"Unknown type 'someOtherType'. Known types are: sealedInt, sealedString\") }\n                                line { toBe(1) }\n                                column { toBe(7) }\n                                typeName { toBe(\"someOtherType\") }\n                                validTypeNames { toBe(setOf(\"sealedInt\", \"sealedString\")) }\n                                path { toBe(YamlPath.root.withMapElementKey(\"kind\", Location(1, 1)).withMapElementValue(Location(1, 7))) }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given some input with a tag and a type property\") {\n                    val input = \"\"\"\n                        !<sealedInt>\n                        kind: sealedString\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input)\n\n                        it(\"uses the type from the property and ignores the tag\") {\n                            expect(result).toBe(TestSealedStructure.SimpleSealedString(\"asdfg\"))\n                        }\n                    }\n                }\n            }\n        }\n\n        describe(\"parsing values with a dynamically installed serializer\") {\n            describe(\"parsing a literal with a contextual serializer\") {\n                val contextSerializer = object : KSerializer<Inner> {\n                    override val descriptor: SerialDescriptor\n                        get() = String.serializer().descriptor\n\n                    override fun deserialize(decoder: Decoder): Inner = Inner(\"from context serializer\")\n                    override fun serialize(encoder: Encoder, value: Inner) = throw UnsupportedOperationException()\n                }\n\n                val module = serializersModuleOf(Inner::class, contextSerializer)\n                val parser = Yaml(serializersModule = module)\n\n                val input = \"\"\"\n                    inner: this is the input\n                \"\"\".trimIndent()\n\n                val result = parser.decodeFromString(Container.serializer(), input)\n\n                it(\"deserializes it using the dynamically installed serializer\") {\n                    expect(result).toBe(Container(Inner(\"from context serializer\")))\n                }\n            }\n\n            describe(\"parsing a class with a contextual serializer\") {\n                val contextSerializer = object : KSerializer<Inner> {\n                    override val descriptor = buildClassSerialDescriptor(\"Inner\") {\n                        element(\"thing\", String.serializer().descriptor)\n                    }\n\n                    override fun deserialize(decoder: Decoder): Inner {\n                        val objectDecoder = decoder.beginStructure(descriptor)\n                        val index = objectDecoder.decodeElementIndex(descriptor)\n                        val name = objectDecoder.decodeStringElement(descriptor, index)\n                        objectDecoder.endStructure(descriptor)\n\n                        return Inner(\"$name, from context serializer\")\n                    }\n\n                    override fun serialize(encoder: Encoder, value: Inner) = throw UnsupportedOperationException()\n                }\n\n                val module = serializersModuleOf(Inner::class, contextSerializer)\n                val parser = Yaml(serializersModule = module)\n\n                val input = \"\"\"\n                    inner:\n                        thing: this is the input\n                \"\"\".trimIndent()\n\n                val result = parser.decodeFromString(Container.serializer(), input)\n\n                it(\"deserializes it using the dynamically installed serializer\") {\n                    expect(result).toBe(Container(Inner(\"this is the input, from context serializer\")))\n                }\n            }\n\n            describe(\"parsing a map with a contextual serializer\") {\n                val contextSerializer = object : KSerializer<Inner> {\n                    override val descriptor = buildSerialDescriptor(\"Inner\", StructureKind.MAP) {\n                        element(\"key\", String.serializer().descriptor)\n                        element(\"value\", String.serializer().descriptor)\n                    }\n\n                    override fun deserialize(decoder: Decoder): Inner {\n                        val objectDecoder = decoder.beginStructure(descriptor)\n                        val keyIndex = objectDecoder.decodeElementIndex(descriptor)\n                        val key = objectDecoder.decodeStringElement(descriptor, keyIndex)\n                        val valueIndex = objectDecoder.decodeElementIndex(descriptor)\n                        val value = objectDecoder.decodeStringElement(descriptor, valueIndex)\n\n                        objectDecoder.endStructure(descriptor)\n\n                        return Inner(\"$key: $value, from context serializer\")\n                    }\n\n                    override fun serialize(encoder: Encoder, value: Inner) = throw UnsupportedOperationException()\n                }\n\n                val module = serializersModuleOf(Inner::class, contextSerializer)\n                val parser = Yaml(serializersModule = module)\n\n                val input = \"\"\"\n                    inner:\n                        thing: this is the input\n                \"\"\".trimIndent()\n\n                val result = parser.decodeFromString(Container.serializer(), input)\n\n                it(\"deserializes it using the dynamically installed serializer\") {\n                    expect(result).toBe(Container(Inner(\"thing: this is the input, from context serializer\")))\n                }\n            }\n        }\n\n        describe(\"parsing values with mismatched types\") {\n            context(\"given a list\") {\n                listOf(\n                    \"a string\" to String.serializer(),\n                    \"an integer\" to Int.serializer(),\n                    \"a long\" to Long.serializer(),\n                    \"a short\" to Short.serializer(),\n                    \"a byte\" to Byte.serializer(),\n                    \"a double\" to Double.serializer(),\n                    \"a float\" to Float.serializer(),\n                    \"a boolean\" to Boolean.serializer(),\n                    \"a character\" to Char.serializer(),\n                    \"an enumeration value\" to TestEnum.serializer(),\n                    \"a map\" to MapSerializer(String.serializer(), String.serializer()),\n                    \"an object\" to ComplexStructure.serializer(),\n                    \"a string\" to String.serializer().nullable\n                ).forEach { (description, serializer) ->\n                    val input = \"- thing\"\n\n                    context(\"parsing that input as $description\") {\n                        it(\"throws an exception with the correct location information\") {\n                            expect({ Yaml.default.decodeFromString(serializer, input) }).toThrow<IncorrectTypeException> {\n                                message { toBe(\"Expected $description, but got a list\") }\n                                line { toBe(1) }\n                                column { toBe(1) }\n                                path { toBe(YamlPath.root) }\n                            }\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in a map\") {\n                    val input = \"\"\"\n                        key:\n                            - some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input) }).toThrow<InvalidPropertyValueException> {\n                            message { toBe(\"Value for 'key' is invalid: Expected a string, but got a list\") }\n                            line { toBe(2) }\n                            column { toBe(5) }\n                            path { toBe(YamlPath.root.withMapElementKey(\"key\", Location(1, 1)).withMapElementValue(Location(2, 5))) }\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in an object\") {\n                    val input = \"\"\"\n                        string:\n                            - some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(ComplexStructure.serializer(), input) }).toThrow<InvalidPropertyValueException> {\n                            message { toBe(\"Value for 'string' is invalid: Expected a string, but got a list\") }\n                            line { toBe(2) }\n                            column { toBe(5) }\n                            path { toBe(YamlPath.root.withMapElementKey(\"string\", Location(1, 1)).withMapElementValue(Location(2, 5))) }\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in a list\") {\n                    val input = \"\"\"\n                        - [ some_value ]\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(ListSerializer(String.serializer()), input) }).toThrow<IncorrectTypeException> {\n                            message { toBe(\"Expected a string, but got a list\") }\n                            line { toBe(1) }\n                            column { toBe(3) }\n                            path { toBe(YamlPath.root.withListEntry(0, Location(1, 3))) }\n                        }\n                    }\n                }\n            }\n\n            context(\"given a map\") {\n                listOf(\n                    \"a string\" to String.serializer(),\n                    \"an integer\" to Int.serializer(),\n                    \"a long\" to Long.serializer(),\n                    \"a short\" to Short.serializer(),\n                    \"a byte\" to Byte.serializer(),\n                    \"a double\" to Double.serializer(),\n                    \"a float\" to Float.serializer(),\n                    \"a boolean\" to Boolean.serializer(),\n                    \"a character\" to Char.serializer(),\n                    \"an enumeration value\" to TestEnum.serializer(),\n                    \"a list\" to ListSerializer(String.serializer()),\n                    \"a string\" to String.serializer().nullable\n                ).forEach { (description, serializer) ->\n                    val input = \"key: value\"\n\n                    context(\"parsing that input as $description\") {\n                        it(\"throws an exception with the correct location information\") {\n                            expect({ Yaml.default.decodeFromString(serializer, input) }).toThrow<IncorrectTypeException> {\n                                message { toBe(\"Expected $description, but got a map\") }\n                                line { toBe(1) }\n                                column { toBe(1) }\n                                path { toBe(YamlPath.root) }\n                            }\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in a map\") {\n                    val input = \"\"\"\n                        key:\n                            some_key: some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input) }).toThrow<InvalidPropertyValueException> {\n                            message { toBe(\"Value for 'key' is invalid: Expected a string, but got a map\") }\n                            line { toBe(2) }\n                            column { toBe(5) }\n                            path { toBe(YamlPath.root.withMapElementKey(\"key\", Location(1, 1)).withMapElementValue(Location(2, 5))) }\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in an object\") {\n                    val input = \"\"\"\n                        string:\n                            some_key: some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(ComplexStructure.serializer(), input) }).toThrow<InvalidPropertyValueException> {\n                            message { toBe(\"Value for 'string' is invalid: Expected a string, but got a map\") }\n                            line { toBe(2) }\n                            column { toBe(5) }\n                            path { toBe(YamlPath.root.withMapElementKey(\"string\", Location(1, 1)).withMapElementValue(Location(2, 5))) }\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in a list\") {\n                    val input = \"\"\"\n                        - some_key: some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(ListSerializer(String.serializer()), input) }).toThrow<IncorrectTypeException> {\n                            message { toBe(\"Expected a string, but got a map\") }\n                            line { toBe(1) }\n                            column { toBe(3) }\n                            path { toBe(YamlPath.root.withListEntry(0, Location(1, 3))) }\n                        }\n                    }\n                }\n            }\n\n            context(\"given a scalar value\") {\n                mapOf(\n                    \"a list\" to ListSerializer(String.serializer()),\n                    \"a map\" to MapSerializer(String.serializer(), String.serializer()),\n                    \"an object\" to ComplexStructure.serializer()\n                ).forEach { (description, serializer) ->\n                    val input = \"blah\"\n\n                    context(\"parsing that input as $description\") {\n                        it(\"throws an exception with the correct location information\") {\n                            expect({ Yaml.default.decodeFromString(serializer, input) }).toThrow<IncorrectTypeException> {\n                                message { toBe(\"Expected $description, but got a scalar value\") }\n                                line { toBe(1) }\n                                column { toBe(1) }\n                                path { toBe(YamlPath.root) }\n                            }\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in a map\") {\n                    val input = \"\"\"\n                        key: some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(MapSerializer(String.serializer(), ListSerializer(String.serializer())), input) }).toThrow<InvalidPropertyValueException> {\n                            message { toBe(\"Value for 'key' is invalid: Expected a list, but got a scalar value\") }\n                            line { toBe(1) }\n                            column { toBe(6) }\n                            path { toBe(YamlPath.root.withMapElementKey(\"key\", Location(1, 1)).withMapElementValue(Location(1, 6))) }\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in an object\") {\n                    val input = \"\"\"\n                        members: some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(Team.serializer(), input) }).toThrow<InvalidPropertyValueException> {\n                            message { toBe(\"Value for 'members' is invalid: Expected a list, but got a scalar value\") }\n                            line { toBe(1) }\n                            column { toBe(10) }\n                            path { toBe(YamlPath.root.withMapElementKey(\"members\", Location(1, 1)).withMapElementValue(Location(1, 10))) }\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in a list\") {\n                    val input = \"\"\"\n                        - some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(ListSerializer((ListSerializer(String.serializer()))), input) }).toThrow<IncorrectTypeException> {\n                            message { toBe(\"Expected a list, but got a scalar value\") }\n                            line { toBe(1) }\n                            column { toBe(3) }\n                            path { toBe(YamlPath.root.withListEntry(0, Location(1, 3))) }\n                        }\n                    }\n                }\n            }\n        }\n\n        describe(\"parsing values with a contextual serializer\") {\n            mapOf(\n                \"scalar\" to \"2\",\n                \"list\" to \"[ thing ]\",\n                \"map\" to \"{ key: value }\"\n            ).forEach { (description, input) ->\n                context(\"given some input representing a $description\") {\n                    context(\"parsing that input using a contextual serializer at the top level\") {\n                        val result = Yaml.default.decodeFromString(ContextualSerializer, input)\n\n                        it(\"the serializer receives the top-level object\") {\n                            expect(result).toBe(description)\n                        }\n                    }\n\n                    context(\"parsing that input using a contextual serializer nested within an object\") {\n                        val result = Yaml.default.decodeFromString(ObjectWithNestedContextualSerializer.serializer(), \"thing: $input\")\n\n                        it(\"the serializer receives the correct object\") {\n                            expect(result).toBe(ObjectWithNestedContextualSerializer(description))\n                        }\n                    }\n                }\n            }\n\n            describe(\"given the contextual serializer attempts to begin a structure that does not match the input\") {\n                context(\"given the input is a map\") {\n                    val input = \"a: b\"\n\n                    mapOf(\n                        PrimitiveKind.STRING to \"a string\",\n                        StructureKind.LIST to \"a list\"\n                    ).forEach { (kind, description) ->\n                        context(\"attempting to begin $description\") {\n                            it(\"throws an exception with the correct location information\") {\n                                expect({ Yaml.default.decodeFromString(ContextualSerializerThatAttemptsToDeserializeIncorrectType(kind), input) }).toThrow<IncorrectTypeException> {\n                                    message { toBe(\"Expected $description, but got a map\") }\n                                    line { toBe(1) }\n                                    column { toBe(1) }\n                                    path { toBe(YamlPath.root) }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given the input is a list\") {\n                    val input = \"- a\"\n\n                    mapOf(\n                        StructureKind.OBJECT to \"an object\",\n                        StructureKind.CLASS to \"an object\",\n                        StructureKind.MAP to \"a map\",\n                        PrimitiveKind.STRING to \"a string\"\n                    ).forEach { (kind, description) ->\n                        context(\"attempting to begin $description\") {\n                            it(\"throws an exception with the correct location information\") {\n                                expect({ Yaml.default.decodeFromString(ContextualSerializerThatAttemptsToDeserializeIncorrectType(kind), input) }).toThrow<IncorrectTypeException> {\n                                    message { toBe(\"Expected $description, but got a list\") }\n                                    line { toBe(1) }\n                                    column { toBe(1) }\n                                    path { toBe(YamlPath.root) }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given the input is a scalar\") {\n                    val input = \"2\"\n\n                    mapOf(\n                        StructureKind.OBJECT to \"an object\",\n                        StructureKind.CLASS to \"an object\",\n                        StructureKind.MAP to \"a map\",\n                        StructureKind.LIST to \"a list\"\n                    ).forEach { (kind, description) ->\n                        context(\"attempting to begin $description\") {\n                            it(\"throws an exception with the correct location information\") {\n                                expect({ Yaml.default.decodeFromString(ContextualSerializerThatAttemptsToDeserializeIncorrectType(kind), input) }).toThrow<IncorrectTypeException> {\n                                    message { toBe(\"Expected $description, but got a scalar value\") }\n                                    line { toBe(1) }\n                                    column { toBe(1) }\n                                    path { toBe(YamlPath.root) }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n})\n\n@Serializable\nprivate data class ComplexStructure(\n    val string: String,\n    val byte: Byte,\n    val short: Short,\n    val int: Int,\n    val long: Long,\n    val float: Float,\n    val double: Double,\n    val enum: TestEnum,\n    val boolean: Boolean,\n    val char: Char,\n    val nullable: String? = null\n)\n\n@Serializable\nprivate data class StructureWithLocationThrowingSerializer(\n    @Serializable(with = LocationThrowingSerializer::class) val value: CustomSerializedValue\n)\n\nprivate data class CustomSerializedValue(val thing: String)\n\n@OptIn(InternalSerializationApi::class, ExperimentalSerializationApi::class)\nprivate object LocationThrowingSerializer : KSerializer<Any> {\n    override val descriptor = buildSerialDescriptor(LocationThrowingSerializer::class.qualifiedName!!, SerialKind.CONTEXTUAL)\n\n    override fun deserialize(decoder: Decoder): Any {\n        val location = (decoder as YamlInput).getCurrentLocation()\n        val path = decoder.getCurrentPath()\n\n        throw LocationInformationException(\"Serializer called with location (${location.line}, ${location.column}) and path: ${path.toHumanReadableString()}\")\n    }\n\n    override fun serialize(encoder: Encoder, value: Any) = throw UnsupportedOperationException()\n}\n\nprivate object LocationThrowingMapSerializer : KSerializer<Any> {\n    override val descriptor: SerialDescriptor = MapSerializer(String.serializer(), String.serializer()).descriptor\n\n    override fun deserialize(decoder: Decoder): Any {\n        val location = (decoder as YamlInput).getCurrentLocation()\n        val path = decoder.getCurrentPath()\n\n        throw LocationInformationException(\"Serializer called with location (${location.line}, ${location.column}) and path: ${path.toHumanReadableString()}\")\n    }\n\n    override fun serialize(encoder: Encoder, value: Any) = throw UnsupportedOperationException()\n}\n\nprivate class LocationInformationException(message: String) : RuntimeException(message)\n\n@OptIn(InternalSerializationApi::class, ExperimentalSerializationApi::class)\nobject ContextualSerializer : KSerializer<String> {\n    override val descriptor = buildSerialDescriptor(\"ContextualSerializer\", SerialKind.CONTEXTUAL) {\n        element(\"string\", PrimitiveSerialDescriptor(\"value\", PrimitiveKind.STRING))\n        element(\"object\", buildSerialDescriptor(\"thing\", StructureKind.OBJECT))\n    }\n\n    override fun deserialize(decoder: Decoder): String {\n        val input = decoder.beginStructure(descriptor) as YamlInput\n        val type = input.node::class.simpleName!!\n        input.endStructure(descriptor)\n\n        return type.removePrefix(\"Yaml\").lowercase()\n    }\n\n    override fun serialize(encoder: Encoder, value: String): Unit = throw UnsupportedOperationException()\n}\n\n@OptIn(InternalSerializationApi::class, ExperimentalSerializationApi::class)\nclass ContextualSerializerThatAttemptsToDeserializeIncorrectType(private val kind: SerialKind) : KSerializer<String> {\n    private val innerDescriptor = if (kind == StructureKind.CLASS) buildClassSerialDescriptor(\"thing\") else buildSerialDescriptor(\"thing\", kind)\n\n    override val descriptor = buildSerialDescriptor(\"ContextualSerializer\", SerialKind.CONTEXTUAL) {\n        element(\"string\", PrimitiveSerialDescriptor(\"value\", PrimitiveKind.STRING))\n        element(\"object\", innerDescriptor)\n    }\n\n    override fun deserialize(decoder: Decoder): String {\n        val input = decoder.beginStructure(descriptor) as YamlInput\n\n        input.beginStructure(innerDescriptor)\n\n        return \"Should never get to this point\"\n    }\n\n    override fun serialize(encoder: Encoder, value: String): Unit = throw UnsupportedOperationException()\n}\n\n// FIXME: ideally these would just be inline in the test cases that need them, but due to\n// https://github.com/Kotlin/kotlinx.serialization/issues/1427, this is no longer possible with\n// kotlinx.serialization 1.2 and above.\n// See also https://github.com/Kotlin/kotlinx.serialization/issues/1468.\n\n@Serializable\nprivate data class NullableNestedObject(val firstPerson: SimpleStructure?)\n\n@Serializable\ndata class NullableNestedList(val members: List<String>?)\n\n@Serializable\nprivate data class Database(val host: String)\n\nprivate data class Inner(val name: String)\n\n@Serializable\nprivate data class Container(@Contextual val inner: Inner)\n\n@Serializable\nprivate data class ObjectWithNestedContextualSerializer(@Serializable(with = ContextualSerializer::class) val thing: String)\n"], "fixing_code": ["/*\n\n   Copyright 2018-2021 Charles Korn.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\npackage com.charleskorn.kaml\n\nimport kotlinx.serialization.DeserializationStrategy\nimport kotlinx.serialization.ExperimentalSerializationApi\nimport kotlinx.serialization.KSerializer\nimport kotlinx.serialization.SerializationException\nimport kotlinx.serialization.descriptors.PolymorphicKind\nimport kotlinx.serialization.descriptors.PrimitiveKind\nimport kotlinx.serialization.descriptors.SerialDescriptor\nimport kotlinx.serialization.descriptors.SerialKind\nimport kotlinx.serialization.descriptors.StructureKind\nimport kotlinx.serialization.descriptors.elementNames\nimport kotlinx.serialization.encoding.AbstractDecoder\nimport kotlinx.serialization.encoding.CompositeDecoder\nimport kotlinx.serialization.encoding.CompositeDecoder.Companion.DECODE_DONE\nimport kotlinx.serialization.encoding.CompositeDecoder.Companion.UNKNOWN_NAME\nimport kotlinx.serialization.modules.SerializersModule\nimport kotlinx.serialization.modules.SerializersModuleCollector\nimport kotlin.reflect.KClass\n\n@OptIn(ExperimentalSerializationApi::class)\npublic sealed class YamlInput(\n    public val node: YamlNode,\n    override var serializersModule: SerializersModule,\n    public val configuration: YamlConfiguration\n) : AbstractDecoder() {\n    internal companion object {\n        private val missingFieldExceptionMessage: Regex = \"\"\"^Field '(.*)' is required for type with serial name '.*', but it was missing$\"\"\".toRegex()\n\n        internal fun createFor(node: YamlNode, context: SerializersModule, configuration: YamlConfiguration, descriptor: SerialDescriptor): YamlInput = when (node) {\n            is YamlNull -> when {\n                descriptor.kind is PolymorphicKind && !descriptor.isNullable -> throw MissingTypeTagException(node.path)\n                else -> YamlNullInput(node, context, configuration)\n            }\n\n            is YamlScalar -> when (descriptor.kind) {\n                is PrimitiveKind, SerialKind.ENUM -> YamlScalarInput(node, context, configuration)\n                is SerialKind.CONTEXTUAL -> YamlContextualInput(node, context, configuration)\n                is PolymorphicKind -> throw MissingTypeTagException(node.path)\n                else -> throw IncorrectTypeException(\"Expected ${descriptor.kind.friendlyDescription}, but got a scalar value\", node.path)\n            }\n\n            is YamlList -> when (descriptor.kind) {\n                is StructureKind.LIST -> YamlListInput(node, context, configuration)\n                is SerialKind.CONTEXTUAL -> YamlContextualInput(node, context, configuration)\n                else -> throw IncorrectTypeException(\"Expected ${descriptor.kind.friendlyDescription}, but got a list\", node.path)\n            }\n\n            is YamlMap -> when (descriptor.kind) {\n                is StructureKind.CLASS, StructureKind.OBJECT -> YamlObjectInput(node, context, configuration)\n                is StructureKind.MAP -> YamlMapInput(node, context, configuration)\n                is SerialKind.CONTEXTUAL -> YamlContextualInput(node, context, configuration)\n                is PolymorphicKind -> when (configuration.polymorphismStyle) {\n                    PolymorphismStyle.Tag -> throw MissingTypeTagException(node.path)\n                    PolymorphismStyle.Property -> createPolymorphicMapDeserializer(node, context, configuration)\n                }\n                else -> throw IncorrectTypeException(\"Expected ${descriptor.kind.friendlyDescription}, but got a map\", node.path)\n            }\n\n            is YamlTaggedNode -> when {\n                descriptor.kind is PolymorphicKind && configuration.polymorphismStyle == PolymorphismStyle.Tag -> YamlPolymorphicInput(node.tag, node.path, node.innerNode, context, configuration)\n                else -> createFor(node.innerNode, context, configuration, descriptor)\n            }\n        }\n\n        private fun createPolymorphicMapDeserializer(node: YamlMap, context: SerializersModule, configuration: YamlConfiguration): YamlPolymorphicInput {\n            val desiredKey = configuration.polymorphismPropertyName\n            when (val typeName = node.getValue(desiredKey)) {\n                is YamlList -> throw InvalidPropertyValueException(desiredKey, \"expected a string, but got a list\", typeName.path)\n                is YamlMap -> throw InvalidPropertyValueException(desiredKey, \"expected a string, but got a map\", typeName.path)\n                is YamlNull -> throw InvalidPropertyValueException(desiredKey, \"expected a string, but got a null value\", typeName.path)\n                is YamlTaggedNode -> throw InvalidPropertyValueException(desiredKey, \"expected a string, but got a tagged value\", typeName.path)\n                is YamlScalar -> {\n                    val remainingProperties = node.withoutKey(desiredKey)\n\n                    return YamlPolymorphicInput(typeName.content, typeName.path, remainingProperties, context, configuration)\n                }\n            }\n        }\n\n        private fun YamlMap.getValue(desiredKey: String): YamlNode {\n            return this.get(desiredKey) ?: throw MissingRequiredPropertyException(desiredKey, this.path)\n        }\n\n        private fun YamlMap.withoutKey(key: String): YamlMap {\n            return this.copy(entries = entries.filterKeys { it.content != key })\n        }\n    }\n\n    override fun <T> decodeSerializableValue(deserializer: DeserializationStrategy<T>): T {\n        try {\n            return super.decodeSerializableValue(deserializer)\n        } catch (e: SerializationException) {\n            throwIfMissingRequiredPropertyException(e)\n\n            throw e\n        }\n    }\n\n    private fun throwIfMissingRequiredPropertyException(e: SerializationException) {\n        val match = missingFieldExceptionMessage.matchEntire(e.message!!) ?: return\n\n        throw MissingRequiredPropertyException(match.groupValues[1], node.path, e)\n    }\n\n    public abstract fun getCurrentLocation(): Location\n    public abstract fun getCurrentPath(): YamlPath\n}\n\n@OptIn(ExperimentalSerializationApi::class)\nprivate class YamlScalarInput(val scalar: YamlScalar, context: SerializersModule, configuration: YamlConfiguration) : YamlInput(scalar, context, configuration) {\n    override fun decodeString(): String = scalar.content\n    override fun decodeInt(): Int = scalar.toInt()\n    override fun decodeLong(): Long = scalar.toLong()\n    override fun decodeShort(): Short = scalar.toShort()\n    override fun decodeByte(): Byte = scalar.toByte()\n    override fun decodeDouble(): Double = scalar.toDouble()\n    override fun decodeFloat(): Float = scalar.toFloat()\n    override fun decodeBoolean(): Boolean = scalar.toBoolean()\n    override fun decodeChar(): Char = scalar.toChar()\n\n    override fun decodeEnum(enumDescriptor: SerialDescriptor): Int {\n        val index = enumDescriptor.getElementIndex(scalar.content)\n\n        if (index != UNKNOWN_NAME) {\n            return index\n        }\n\n        val choices = (0..enumDescriptor.elementsCount - 1)\n            .map { enumDescriptor.getElementName(it) }\n            .sorted()\n            .joinToString(\", \")\n\n        throw YamlScalarFormatException(\"Value ${scalar.contentToString()} is not a valid option, permitted choices are: $choices\", scalar.path, scalar.content)\n    }\n\n    override fun getCurrentLocation(): Location = scalar.location\n    override fun getCurrentPath(): YamlPath = scalar.path\n\n    override fun decodeElementIndex(descriptor: SerialDescriptor): Int = 0\n}\n\n@OptIn(ExperimentalSerializationApi::class)\nprivate class YamlNullInput(val nullValue: YamlNode, context: SerializersModule, configuration: YamlConfiguration) : YamlInput(nullValue, context, configuration) {\n    override fun decodeNotNullMark(): Boolean = false\n\n    override fun decodeValue(): Any = throw UnexpectedNullValueException(nullValue.path)\n    override fun decodeCollectionSize(descriptor: SerialDescriptor): Int = throw UnexpectedNullValueException(nullValue.path)\n    override fun beginStructure(descriptor: SerialDescriptor): CompositeDecoder = throw UnexpectedNullValueException(nullValue.path)\n\n    override fun getCurrentLocation(): Location = nullValue.location\n    override fun getCurrentPath(): YamlPath = nullValue.path\n\n    override fun decodeElementIndex(descriptor: SerialDescriptor): Int = DECODE_DONE\n}\n\n@OptIn(ExperimentalSerializationApi::class)\nprivate class YamlListInput(val list: YamlList, context: SerializersModule, configuration: YamlConfiguration) : YamlInput(list, context, configuration) {\n    private var nextElementIndex = 0\n    private lateinit var currentElementDecoder: YamlInput\n\n    override fun decodeCollectionSize(descriptor: SerialDescriptor): Int = list.items.size\n\n    override fun decodeElementIndex(descriptor: SerialDescriptor): Int {\n        if (nextElementIndex == list.items.size) {\n            return CompositeDecoder.DECODE_DONE\n        }\n\n        currentElementDecoder = createFor(list.items[nextElementIndex], serializersModule, configuration, descriptor.getElementDescriptor(0))\n\n        return nextElementIndex++\n    }\n\n    override fun decodeNotNullMark(): Boolean {\n        if (!haveStartedReadingElements) {\n            return true\n        }\n\n        return currentElementDecoder.decodeNotNullMark()\n    }\n\n    override fun decodeString(): String = currentElementDecoder.decodeString()\n    override fun decodeInt(): Int = currentElementDecoder.decodeInt()\n    override fun decodeLong(): Long = currentElementDecoder.decodeLong()\n    override fun decodeShort(): Short = currentElementDecoder.decodeShort()\n    override fun decodeByte(): Byte = currentElementDecoder.decodeByte()\n    override fun decodeDouble(): Double = currentElementDecoder.decodeDouble()\n    override fun decodeFloat(): Float = currentElementDecoder.decodeFloat()\n    override fun decodeBoolean(): Boolean = currentElementDecoder.decodeBoolean()\n    override fun decodeChar(): Char = currentElementDecoder.decodeChar()\n    override fun decodeEnum(enumDescriptor: SerialDescriptor): Int = currentElementDecoder.decodeEnum(enumDescriptor)\n\n    private val haveStartedReadingElements: Boolean\n        get() = nextElementIndex > 0\n\n    override fun beginStructure(descriptor: SerialDescriptor): CompositeDecoder {\n        if (haveStartedReadingElements) {\n            return currentElementDecoder\n        }\n\n        return super.beginStructure(descriptor)\n    }\n\n    override fun getCurrentPath(): YamlPath {\n        return if (haveStartedReadingElements) {\n            currentElementDecoder.node.path\n        } else {\n            list.path\n        }\n    }\n\n    override fun getCurrentLocation(): Location = getCurrentPath().endLocation\n}\n\nprivate class YamlContextualInput(node: YamlNode, context: SerializersModule, configuration: YamlConfiguration) : YamlInput(node, context, configuration) {\n    override fun decodeElementIndex(descriptor: SerialDescriptor): Int = throw IllegalStateException(\"Must call beginStructure() and use returned Decoder\")\n    override fun decodeValue(): Any = throw IllegalStateException(\"Must call beginStructure() and use returned Decoder\")\n\n    override fun beginStructure(descriptor: SerialDescriptor): CompositeDecoder =\n        createFor(node, serializersModule, configuration, descriptor)\n\n    override fun getCurrentLocation(): Location = node.location\n    override fun getCurrentPath(): YamlPath = node.path\n}\n\nprivate sealed class YamlMapLikeInputBase(map: YamlMap, context: SerializersModule, configuration: YamlConfiguration) : YamlInput(map, context, configuration) {\n    protected lateinit var currentValueDecoder: YamlInput\n    protected lateinit var currentKey: YamlScalar\n    protected var currentlyReadingValue = false\n\n    override fun decodeNotNullMark(): Boolean {\n        if (!haveStartedReadingEntries) {\n            return true\n        }\n\n        return fromCurrentValue { decodeNotNullMark() }\n    }\n\n    override fun decodeString(): String = fromCurrentValue { decodeString() }\n    override fun decodeInt(): Int = fromCurrentValue { decodeInt() }\n    override fun decodeLong(): Long = fromCurrentValue { decodeLong() }\n    override fun decodeShort(): Short = fromCurrentValue { decodeShort() }\n    override fun decodeByte(): Byte = fromCurrentValue { decodeByte() }\n    override fun decodeDouble(): Double = fromCurrentValue { decodeDouble() }\n    override fun decodeFloat(): Float = fromCurrentValue { decodeFloat() }\n    override fun decodeBoolean(): Boolean = fromCurrentValue { decodeBoolean() }\n    override fun decodeChar(): Char = fromCurrentValue { decodeChar() }\n    override fun decodeEnum(enumDescriptor: SerialDescriptor): Int = fromCurrentValue { decodeEnum(enumDescriptor) }\n\n    protected fun <T> fromCurrentValue(action: YamlInput.() -> T): T {\n        try {\n            return action(currentValueDecoder)\n        } catch (e: YamlException) {\n            if (currentlyReadingValue) {\n                throw InvalidPropertyValueException(propertyName, e.message, e.path, e)\n            } else {\n                throw e\n            }\n        }\n    }\n\n    protected val haveStartedReadingEntries: Boolean\n        get() = this::currentValueDecoder.isInitialized\n\n    override fun getCurrentPath(): YamlPath {\n        return if (haveStartedReadingEntries) {\n            currentValueDecoder.node.path\n        } else {\n            node.path\n        }\n    }\n\n    override fun getCurrentLocation(): Location = getCurrentPath().endLocation\n\n    protected val propertyName: String\n        get() = currentKey.content\n}\n\n@OptIn(ExperimentalSerializationApi::class)\nprivate class YamlMapInput(map: YamlMap, context: SerializersModule, configuration: YamlConfiguration) : YamlMapLikeInputBase(map, context, configuration) {\n    private val entriesList = map.entries.entries.toList()\n    private var nextIndex = 0\n    private lateinit var currentEntry: Map.Entry<YamlScalar, YamlNode>\n\n    override fun decodeElementIndex(descriptor: SerialDescriptor): Int {\n        if (nextIndex == entriesList.size * 2) {\n            return CompositeDecoder.DECODE_DONE\n        }\n\n        val entryIndex = nextIndex / 2\n        currentEntry = entriesList[entryIndex]\n        currentKey = currentEntry.key\n        currentlyReadingValue = nextIndex % 2 != 0\n\n        currentValueDecoder = when (currentlyReadingValue) {\n            true ->\n                try {\n                    createFor(currentEntry.value, serializersModule, configuration, descriptor.getElementDescriptor(1))\n                } catch (e: IncorrectTypeException) {\n                    throw InvalidPropertyValueException(propertyName, e.message, e.path, e)\n                }\n\n            false -> createFor(currentKey, serializersModule, configuration, descriptor.getElementDescriptor(0))\n        }\n\n        return nextIndex++\n    }\n\n    override fun beginStructure(descriptor: SerialDescriptor): CompositeDecoder {\n        if (haveStartedReadingEntries) {\n            return fromCurrentValue { beginStructure(descriptor) }\n        }\n\n        return super.beginStructure(descriptor)\n    }\n}\n\n@OptIn(ExperimentalSerializationApi::class)\nprivate class YamlObjectInput(map: YamlMap, context: SerializersModule, configuration: YamlConfiguration) : YamlMapLikeInputBase(map, context, configuration) {\n    private val entriesList = map.entries.entries.toList()\n    private var nextIndex = 0\n\n    override fun decodeElementIndex(descriptor: SerialDescriptor): Int {\n        while (true) {\n            if (nextIndex == entriesList.size) {\n                return CompositeDecoder.DECODE_DONE\n            }\n\n            val currentEntry = entriesList[nextIndex]\n            currentKey = currentEntry.key\n            val fieldDescriptorIndex = descriptor.getElementIndex(propertyName)\n\n            if (fieldDescriptorIndex == UNKNOWN_NAME) {\n                if (configuration.strictMode) {\n                    throwUnknownProperty(propertyName, currentKey.path, descriptor)\n                } else {\n                    nextIndex++\n                    continue\n                }\n            }\n\n            try {\n                currentValueDecoder = createFor(entriesList[nextIndex].value, serializersModule, configuration, descriptor.getElementDescriptor(fieldDescriptorIndex))\n            } catch (e: IncorrectTypeException) {\n                throw InvalidPropertyValueException(propertyName, e.message, e.path, e)\n            }\n\n            currentlyReadingValue = true\n            nextIndex++\n\n            return fieldDescriptorIndex\n        }\n    }\n\n    private fun throwUnknownProperty(name: String, path: YamlPath, desc: SerialDescriptor): Nothing {\n        val knownPropertyNames = (0 until desc.elementsCount)\n            .map { desc.getElementName(it) }\n            .toSet()\n\n        throw UnknownPropertyException(name, knownPropertyNames, path)\n    }\n\n    override fun beginStructure(descriptor: SerialDescriptor): CompositeDecoder {\n        if (haveStartedReadingEntries) {\n            return fromCurrentValue { beginStructure(descriptor) }\n        }\n\n        return super.beginStructure(descriptor)\n    }\n}\n\n@OptIn(ExperimentalSerializationApi::class)\nprivate class YamlPolymorphicInput(private val typeName: String, private val typeNamePath: YamlPath, private val contentNode: YamlNode, context: SerializersModule, configuration: YamlConfiguration) : YamlInput(contentNode, context, configuration) {\n    private var currentField = CurrentField.NotStarted\n    private lateinit var contentDecoder: YamlInput\n\n    override fun getCurrentLocation(): Location = contentNode.location\n    override fun getCurrentPath(): YamlPath = contentNode.path\n\n    override fun decodeElementIndex(descriptor: SerialDescriptor): Int {\n        return when (currentField) {\n            CurrentField.NotStarted -> {\n                currentField = CurrentField.Type\n                0\n            }\n            CurrentField.Type -> {\n                when (contentNode) {\n                    is YamlScalar -> contentDecoder = YamlScalarInput(contentNode, serializersModule, configuration)\n                    is YamlNull -> contentDecoder = YamlNullInput(contentNode, serializersModule, configuration)\n                }\n\n                currentField = CurrentField.Content\n                1\n            }\n            CurrentField.Content -> CompositeDecoder.DECODE_DONE\n        }\n    }\n\n    override fun decodeNotNullMark(): Boolean = maybeCallOnContent(blockOnType = { true }, blockOnContent = YamlInput::decodeNotNullMark)\n    override fun decodeNull(): Nothing? = maybeCallOnContent(\"decodeNull\", blockOnContent = YamlInput::decodeNull)\n    override fun decodeBoolean(): Boolean = maybeCallOnContent(\"decodeBoolean\", blockOnContent = YamlInput::decodeBoolean)\n    override fun decodeByte(): Byte = maybeCallOnContent(\"decodeByte\", blockOnContent = YamlInput::decodeByte)\n    override fun decodeShort(): Short = maybeCallOnContent(\"decodeShort\", blockOnContent = YamlInput::decodeShort)\n    override fun decodeInt(): Int = maybeCallOnContent(\"decodeInt\", blockOnContent = YamlInput::decodeInt)\n    override fun decodeLong(): Long = maybeCallOnContent(\"decodeLong\", blockOnContent = YamlInput::decodeLong)\n    override fun decodeFloat(): Float = maybeCallOnContent(\"decodeFloat\", blockOnContent = YamlInput::decodeFloat)\n    override fun decodeDouble(): Double = maybeCallOnContent(\"decodeDouble\", blockOnContent = YamlInput::decodeDouble)\n    override fun decodeChar(): Char = maybeCallOnContent(\"decodeChar\", blockOnContent = YamlInput::decodeChar)\n    override fun decodeString(): String = maybeCallOnContent(blockOnType = { typeName }, blockOnContent = YamlInput::decodeString)\n    override fun decodeEnum(enumDescriptor: SerialDescriptor): Int = maybeCallOnContent(\"decodeEnum\") { decodeEnum(enumDescriptor) }\n\n    override fun beginStructure(descriptor: SerialDescriptor): CompositeDecoder {\n        return when (currentField) {\n            CurrentField.NotStarted, CurrentField.Type -> super.beginStructure(descriptor)\n            CurrentField.Content -> {\n                contentDecoder = createFor(contentNode, serializersModule, configuration, descriptor)\n\n                return contentDecoder\n            }\n        }\n    }\n\n    private inline fun <T> maybeCallOnContent(functionName: String, blockOnContent: YamlInput.() -> T): T =\n        maybeCallOnContent(blockOnType = { throw UnsupportedOperationException(\"Can't call $functionName() on type field\") }, blockOnContent = blockOnContent)\n\n    private inline fun <T> maybeCallOnContent(blockOnType: () -> T, blockOnContent: YamlInput.() -> T): T {\n        return when (currentField) {\n            CurrentField.NotStarted, CurrentField.Type -> blockOnType()\n            CurrentField.Content -> contentDecoder.blockOnContent()\n        }\n    }\n\n    override fun <T> decodeSerializableValue(deserializer: DeserializationStrategy<T>): T {\n        try {\n            return super.decodeSerializableValue(deserializer)\n        } catch (e: SerializationException) {\n            throwIfUnknownPolymorphicTypeException(e, deserializer)\n\n            throw e\n        }\n    }\n\n    private fun throwIfUnknownPolymorphicTypeException(e: Exception, deserializer: DeserializationStrategy<*>) {\n        val message = e.message ?: return\n        val match = unknownPolymorphicTypeExceptionMessage.matchEntire(message) ?: return\n        val unknownType = match.groupValues[1]\n        val className = match.groupValues[2]\n\n        val knownTypes = when (deserializer.descriptor.kind) {\n            PolymorphicKind.SEALED -> getKnownTypesForSealedType(deserializer)\n            PolymorphicKind.OPEN -> getKnownTypesForOpenType(className)\n            else -> throw IllegalArgumentException(\"Can't get known types for descriptor of kind ${deserializer.descriptor.kind}\")\n        }\n\n        throw UnknownPolymorphicTypeException(unknownType, knownTypes, typeNamePath, e)\n    }\n\n    private fun getKnownTypesForSealedType(deserializer: DeserializationStrategy<*>): Set<String> {\n        val typesDescriptor = deserializer.descriptor.getElementDescriptor(1)\n\n        return typesDescriptor.elementNames.toSet()\n    }\n\n    private fun getKnownTypesForOpenType(className: String): Set<String> {\n        val knownTypes = mutableSetOf<String>()\n\n        serializersModule.dumpTo(object : SerializersModuleCollector {\n            override fun <T : Any> contextual(kClass: KClass<T>, provider: (typeArgumentsSerializers: List<KSerializer<*>>) -> KSerializer<*>) {}\n\n            // FIXME: ideally we'd be able to get the name as used by the SerialModule (eg. the values in 'polyBase2NamedSerializers' in SerialModuleImpl, but these aren't exposed.\n            // The serializer's descriptor's name seems to be the same value.\n            override fun <Base : Any, Sub : Base> polymorphic(baseClass: KClass<Base>, actualClass: KClass<Sub>, actualSerializer: KSerializer<Sub>) {\n                if (baseClass.simpleName == className) {\n                    knownTypes.add(actualSerializer.descriptor.serialName)\n                }\n            }\n\n            override fun <Base : Any> polymorphicDefault(baseClass: KClass<Base>, defaultSerializerProvider: (className: String?) -> DeserializationStrategy<out Base>?) {\n                throw UnsupportedOperationException(\"This method should never be called.\")\n            }\n        })\n\n        return knownTypes\n    }\n\n    private enum class CurrentField {\n        NotStarted,\n        Type,\n        Content\n    }\n\n    companion object {\n        private val unknownPolymorphicTypeExceptionMessage: Regex = \"\"\"^Class '(.*)' is not registered for polymorphic serialization in the scope of '(.*)'.\\nMark the base class as 'sealed' or register the serializer explicitly.$\"\"\".toRegex()\n    }\n}\n\n@OptIn(ExperimentalSerializationApi::class)\nprivate val SerialKind.friendlyDescription: String\n    get() {\n        return when (this) {\n            is StructureKind.MAP -> \"a map\"\n            is StructureKind.CLASS -> \"an object\"\n            is StructureKind.OBJECT -> \"an object\"\n            is StructureKind.LIST -> \"a list\"\n            is PrimitiveKind.STRING -> \"a string\"\n            is PrimitiveKind.BOOLEAN -> \"a boolean\"\n            is PrimitiveKind.BYTE -> \"a byte\"\n            is PrimitiveKind.CHAR -> \"a character\"\n            is PrimitiveKind.DOUBLE -> \"a double\"\n            is PrimitiveKind.FLOAT -> \"a float\"\n            is PrimitiveKind.INT -> \"an integer\"\n            is PrimitiveKind.SHORT -> \"a short\"\n            is PrimitiveKind.LONG -> \"a long\"\n            is SerialKind.ENUM -> \"an enumeration value\"\n            else -> \"a $this value\"\n        }\n    }\n", "/*\n\n   Copyright 2018-2021 Charles Korn.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n@file:OptIn(InternalSerializationApi::class, ExperimentalSerializationApi::class)\n\npackage com.charleskorn.kaml\n\nimport ch.tutteli.atrium.api.fluent.en_GB.cause\nimport ch.tutteli.atrium.api.fluent.en_GB.message\nimport ch.tutteli.atrium.api.fluent.en_GB.toBe\nimport ch.tutteli.atrium.api.fluent.en_GB.toThrow\nimport ch.tutteli.atrium.api.verbs.expect\nimport com.charleskorn.kaml.testobjects.NestedObjects\nimport com.charleskorn.kaml.testobjects.PolymorphicWrapper\nimport com.charleskorn.kaml.testobjects.SealedWrapper\nimport com.charleskorn.kaml.testobjects.SimpleStructure\nimport com.charleskorn.kaml.testobjects.Team\nimport com.charleskorn.kaml.testobjects.TestEnum\nimport com.charleskorn.kaml.testobjects.TestSealedStructure\nimport com.charleskorn.kaml.testobjects.UnsealedClass\nimport com.charleskorn.kaml.testobjects.UnsealedString\nimport com.charleskorn.kaml.testobjects.UnwrappedInt\nimport com.charleskorn.kaml.testobjects.UnwrappedInterface\nimport com.charleskorn.kaml.testobjects.UnwrappedString\nimport com.charleskorn.kaml.testobjects.polymorphicModule\nimport kotlinx.serialization.Contextual\nimport kotlinx.serialization.ExperimentalSerializationApi\nimport kotlinx.serialization.InternalSerializationApi\nimport kotlinx.serialization.KSerializer\nimport kotlinx.serialization.PolymorphicSerializer\nimport kotlinx.serialization.Serializable\nimport kotlinx.serialization.builtins.ListSerializer\nimport kotlinx.serialization.builtins.MapSerializer\nimport kotlinx.serialization.builtins.nullable\nimport kotlinx.serialization.builtins.serializer\nimport kotlinx.serialization.descriptors.PrimitiveKind\nimport kotlinx.serialization.descriptors.PrimitiveSerialDescriptor\nimport kotlinx.serialization.descriptors.SerialDescriptor\nimport kotlinx.serialization.descriptors.SerialKind\nimport kotlinx.serialization.descriptors.StructureKind\nimport kotlinx.serialization.descriptors.buildClassSerialDescriptor\nimport kotlinx.serialization.descriptors.buildSerialDescriptor\nimport kotlinx.serialization.encoding.Decoder\nimport kotlinx.serialization.encoding.Encoder\nimport kotlinx.serialization.modules.serializersModuleOf\nimport org.spekframework.spek2.Spek\nimport org.spekframework.spek2.style.specification.describe\n\nobject YamlReadingTest : Spek({\n    describe(\"a YAML parser\") {\n        describe(\"parsing scalars\") {\n            context(\"given the input 'hello'\") {\n                val input = \"hello\"\n\n                context(\"parsing that input as a string\") {\n                    val result = Yaml.default.decodeFromString(String.serializer(), input)\n\n                    it(\"deserializes it to the expected string value\") {\n                        expect(result).toBe(\"hello\")\n                    }\n                }\n\n                context(\"parsing that input as a nullable string\") {\n                    val result = Yaml.default.decodeFromString(String.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected string value\") {\n                        expect(result).toBe(\"hello\")\n                    }\n                }\n\n                context(\"parsing that input with a serializer that uses YAML location information when throwing exceptions\") {\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(LocationThrowingSerializer, input) }).toThrow<LocationInformationException> {\n                            message { toBe(\"Serializer called with location (1, 1) and path: <root>\") }\n                        }\n                    }\n                }\n            }\n\n            context(\"given the input '123'\") {\n                val input = \"123\"\n\n                context(\"parsing that input as an integer\") {\n                    val result = Yaml.default.decodeFromString(Int.serializer(), input)\n\n                    it(\"deserializes it to the expected integer\") {\n                        expect(result).toBe(123)\n                    }\n                }\n\n                context(\"parsing that input as a long\") {\n                    val result = Yaml.default.decodeFromString(Long.serializer(), input)\n\n                    it(\"deserializes it to the expected long\") {\n                        expect(result).toBe(123)\n                    }\n                }\n\n                context(\"parsing that input as a short\") {\n                    val result = Yaml.default.decodeFromString(Short.serializer(), input)\n\n                    it(\"deserializes it to the expected short\") {\n                        expect(result).toBe(123)\n                    }\n                }\n\n                context(\"parsing that input as a byte\") {\n                    val result = Yaml.default.decodeFromString(Byte.serializer(), input)\n\n                    it(\"deserializes it to the expected byte\") {\n                        expect(result).toBe(123)\n                    }\n                }\n\n                context(\"parsing that input as a double\") {\n                    val result = Yaml.default.decodeFromString(Double.serializer(), input)\n\n                    it(\"deserializes it to the expected double\") {\n                        expect(result).toBe(123.0)\n                    }\n                }\n\n                context(\"parsing that input as a float\") {\n                    val result = Yaml.default.decodeFromString(Float.serializer(), input)\n\n                    it(\"deserializes it to the expected float\") {\n                        expect(result).toBe(123.0f)\n                    }\n                }\n\n                context(\"parsing that input as a nullable integer\") {\n                    val result = Yaml.default.decodeFromString(Int.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected integer\") {\n                        expect(result).toBe(123)\n                    }\n                }\n\n                context(\"parsing that input as a nullable long\") {\n                    val result = Yaml.default.decodeFromString(Long.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected long\") {\n                        expect(result).toBe(123)\n                    }\n                }\n\n                context(\"parsing that input as a nullable short\") {\n                    val result = Yaml.default.decodeFromString(Short.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected short\") {\n                        expect(result).toBe(123)\n                    }\n                }\n\n                context(\"parsing that input as a nullable byte\") {\n                    val result = Yaml.default.decodeFromString(Byte.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected byte\") {\n                        expect(result).toBe(123)\n                    }\n                }\n\n                context(\"parsing that input as a nullable double\") {\n                    val result = Yaml.default.decodeFromString(Double.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected double\") {\n                        expect(result).toBe(123.0)\n                    }\n                }\n\n                context(\"parsing that input as a nullable float\") {\n                    val result = Yaml.default.decodeFromString(Float.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected float\") {\n                        expect(result).toBe(123.0f)\n                    }\n                }\n            }\n\n            context(\"given the input 'true'\") {\n                val input = \"true\"\n\n                context(\"parsing that input as a boolean\") {\n                    val result = Yaml.default.decodeFromString(Boolean.serializer(), input)\n\n                    it(\"deserializes it to the expected boolean value\") {\n                        expect(result).toBe(true)\n                    }\n                }\n\n                context(\"parsing that input as a nullable boolean\") {\n                    val result = Yaml.default.decodeFromString(Boolean.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected boolean value\") {\n                        expect(result).toBe(true)\n                    }\n                }\n            }\n\n            context(\"given the input 'c'\") {\n                val input = \"c\"\n\n                context(\"parsing that input as a character\") {\n                    val result = Yaml.default.decodeFromString(Char.serializer(), input)\n\n                    it(\"deserializes it to the expected character value\") {\n                        expect(result).toBe('c')\n                    }\n                }\n\n                context(\"parsing that input as a nullable character\") {\n                    val result = Yaml.default.decodeFromString(Char.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected character value\") {\n                        expect(result).toBe('c')\n                    }\n                }\n            }\n\n            mapOf(\n                \"Value1\" to TestEnum.Value1,\n                \"Value2\" to TestEnum.Value2\n            ).forEach { (input, expectedValue) ->\n                context(\"given the input '$input'\") {\n                    context(\"parsing that input as an enumeration value\") {\n                        val result = Yaml.default.decodeFromString(TestEnum.serializer(), input)\n\n                        it(\"deserializes it to the expected enumeration value\") {\n                            expect(result).toBe(expectedValue)\n                        }\n                    }\n                }\n            }\n\n            context(\"parsing an invalid enumeration value\") {\n                it(\"throws an appropriate exception\") {\n                    expect({ Yaml.default.decodeFromString(TestEnum.serializer(), \"nonsense\") }).toThrow<YamlScalarFormatException> {\n                        message { toBe(\"Value 'nonsense' is not a valid option, permitted choices are: Value1, Value2\") }\n                        line { toBe(1) }\n                        column { toBe(1) }\n                        path { toBe(YamlPath.root) }\n                    }\n                }\n            }\n        }\n\n        describe(\"parsing null values\") {\n            val input = \"null\"\n\n            context(\"parsing a null value as a nullable string\") {\n                val result = Yaml.default.decodeFromString(String.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    expect(result).toBe(null)\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable string\") {\n                it(\"throws an appropriate exception\") {\n                    expect({ Yaml.default.decodeFromString(String.serializer(), input) }).toThrow<UnexpectedNullValueException> {\n                        message { toBe(\"Unexpected null or empty value for non-null field.\") }\n                        line { toBe(1) }\n                        column { toBe(1) }\n                        path { toBe(YamlPath.root) }\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable integer\") {\n                val result = Yaml.default.decodeFromString(Int.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    expect(result).toBe(null)\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable integer\") {\n                it(\"throws an appropriate exception\") {\n                    expect({ Yaml.default.decodeFromString(Int.serializer(), input) }).toThrow<UnexpectedNullValueException> {\n                        message { toBe(\"Unexpected null or empty value for non-null field.\") }\n                        line { toBe(1) }\n                        column { toBe(1) }\n                        path { toBe(YamlPath.root) }\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable long\") {\n                val result = Yaml.default.decodeFromString(Long.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    expect(result).toBe(null)\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable long\") {\n                it(\"throws an appropriate exception\") {\n                    expect({ Yaml.default.decodeFromString(Long.serializer(), input) }).toThrow<UnexpectedNullValueException> {\n                        message { toBe(\"Unexpected null or empty value for non-null field.\") }\n                        line { toBe(1) }\n                        column { toBe(1) }\n                        path { toBe(YamlPath.root) }\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable short\") {\n                val result = Yaml.default.decodeFromString(Short.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    expect(result).toBe(null)\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable short\") {\n                it(\"throws an appropriate exception\") {\n                    expect({ Yaml.default.decodeFromString(Short.serializer(), input) }).toThrow<UnexpectedNullValueException> {\n                        message { toBe(\"Unexpected null or empty value for non-null field.\") }\n                        line { toBe(1) }\n                        column { toBe(1) }\n                        path { toBe(YamlPath.root) }\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable byte\") {\n                val result = Yaml.default.decodeFromString(Byte.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    expect(result).toBe(null)\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable byte\") {\n                it(\"throws an appropriate exception\") {\n                    expect({ Yaml.default.decodeFromString(Byte.serializer(), input) }).toThrow<UnexpectedNullValueException> {\n                        message { toBe(\"Unexpected null or empty value for non-null field.\") }\n                        line { toBe(1) }\n                        column { toBe(1) }\n                        path { toBe(YamlPath.root) }\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable double\") {\n                val result = Yaml.default.decodeFromString(Double.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    expect(result).toBe(null)\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable double\") {\n                it(\"throws an appropriate exception\") {\n                    expect({ Yaml.default.decodeFromString(Double.serializer(), input) }).toThrow<UnexpectedNullValueException> {\n                        message { toBe(\"Unexpected null or empty value for non-null field.\") }\n                        line { toBe(1) }\n                        column { toBe(1) }\n                        path { toBe(YamlPath.root) }\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable float\") {\n                val result = Yaml.default.decodeFromString(Float.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    expect(result).toBe(null)\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable float\") {\n                it(\"throws an appropriate exception\") {\n                    expect({ Yaml.default.decodeFromString(Float.serializer(), input) }).toThrow<UnexpectedNullValueException> {\n                        message { toBe(\"Unexpected null or empty value for non-null field.\") }\n                        line { toBe(1) }\n                        column { toBe(1) }\n                        path { toBe(YamlPath.root) }\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable boolean\") {\n                val result = Yaml.default.decodeFromString(Boolean.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    expect(result).toBe(null)\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable boolean\") {\n                it(\"throws an appropriate exception\") {\n                    expect({ Yaml.default.decodeFromString(Boolean.serializer(), input) }).toThrow<UnexpectedNullValueException> {\n                        message { toBe(\"Unexpected null or empty value for non-null field.\") }\n                        line { toBe(1) }\n                        column { toBe(1) }\n                        path { toBe(YamlPath.root) }\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable character\") {\n                val result = Yaml.default.decodeFromString(Char.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    expect(result).toBe(null)\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable character\") {\n                it(\"throws an appropriate exception\") {\n                    expect({ Yaml.default.decodeFromString(Char.serializer(), input) }).toThrow<UnexpectedNullValueException> {\n                        message { toBe(\"Unexpected null or empty value for non-null field.\") }\n                        line { toBe(1) }\n                        column { toBe(1) }\n                        path { toBe(YamlPath.root) }\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable enum\") {\n                val result = Yaml.default.decodeFromString(TestEnum.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    expect(result).toBe(null)\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable enum\") {\n                it(\"throws an appropriate exception\") {\n                    expect({ Yaml.default.decodeFromString(TestEnum.serializer(), input) }).toThrow<UnexpectedNullValueException> {\n                        message { toBe(\"Unexpected null or empty value for non-null field.\") }\n                        line { toBe(1) }\n                        column { toBe(1) }\n                        path { toBe(YamlPath.root) }\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable list\") {\n                val result = Yaml.default.decodeFromString(ListSerializer(String.serializer()).nullable, input)\n\n                it(\"returns a null value\") {\n                    expect(result).toBe(null)\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable list\") {\n                it(\"throws an appropriate exception\") {\n                    expect({ Yaml.default.decodeFromString(ListSerializer(String.serializer()), input) }).toThrow<UnexpectedNullValueException> {\n                        message { toBe(\"Unexpected null or empty value for non-null field.\") }\n                        line { toBe(1) }\n                        column { toBe(1) }\n                        path { toBe(YamlPath.root) }\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable object\") {\n                val result = Yaml.default.decodeFromString(ComplexStructure.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    expect(result).toBe(null)\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable object\") {\n                it(\"throws an appropriate exception\") {\n                    expect({ Yaml.default.decodeFromString(ComplexStructure.serializer(), input) }).toThrow<UnexpectedNullValueException> {\n                        message { toBe(\"Unexpected null or empty value for non-null field.\") }\n                        line { toBe(1) }\n                        column { toBe(1) }\n                        path { toBe(YamlPath.root) }\n                    }\n                }\n            }\n\n            context(\"parsing a null value with a serializer that uses YAML location information when throwing exceptions\") {\n                it(\"throws an exception with the correct location information\") {\n                    expect({ Yaml.default.decodeFromString(LocationThrowingSerializer, input) }).toThrow<LocationInformationException> {\n                        message { toBe(\"Serializer called with location (1, 1) and path: <root>\") }\n                    }\n                }\n            }\n        }\n\n        describe(\"parsing lists\") {\n            context(\"given a list of strings\") {\n                val input = \"\"\"\n                    - thing1\n                    - thing2\n                    - thing3\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(String.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        expect(result).toBe(listOf(\"thing1\", \"thing2\", \"thing3\"))\n                    }\n                }\n\n                context(\"parsing that input as a nullable list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(String.serializer()).nullable, input)\n\n                    it(\"deserializes it to the expected value\") {\n                        expect(result).toBe(listOf(\"thing1\", \"thing2\", \"thing3\"))\n                    }\n                }\n\n                context(\"parsing that input with a serializer that uses YAML location information when throwing exceptions\") {\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(ListSerializer(LocationThrowingSerializer), input) }).toThrow<LocationInformationException> {\n                            message { toBe(\"Serializer called with location (1, 3) and path: [0]\") }\n                        }\n                    }\n                }\n            }\n\n            context(\"given a list of numbers\") {\n                val input = \"\"\"\n                    - 123\n                    - 45\n                    - 6\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list of integers\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Int.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        expect(result).toBe(listOf(123, 45, 6))\n                    }\n                }\n\n                context(\"parsing that input as a list of longs\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Long.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        expect(result).toBe(listOf(123L, 45, 6))\n                    }\n                }\n\n                context(\"parsing that input as a list of shorts\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Short.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        expect(result).toBe(listOf(123.toShort(), 45, 6))\n                    }\n                }\n\n                context(\"parsing that input as a list of bytes\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Byte.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        expect(result).toBe(listOf(123.toByte(), 45, 6))\n                    }\n                }\n\n                context(\"parsing that input as a list of doubles\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Double.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        expect(result).toBe(listOf(123.0, 45.0, 6.0))\n                    }\n                }\n\n                context(\"parsing that input as a list of floats\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Float.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        expect(result).toBe(listOf(123.0f, 45.0f, 6.0f))\n                    }\n                }\n            }\n\n            context(\"given a list of booleans\") {\n                val input = \"\"\"\n                    - true\n                    - false\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Boolean.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        expect(result).toBe(listOf(true, false))\n                    }\n                }\n            }\n\n            context(\"given a list of enum values\") {\n                val input = \"\"\"\n                    - Value1\n                    - Value2\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(TestEnum.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        expect(result).toBe(listOf(TestEnum.Value1, TestEnum.Value2))\n                    }\n                }\n            }\n\n            context(\"given a list of characters\") {\n                val input = \"\"\"\n                    - a\n                    - b\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Char.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        expect(result).toBe(listOf('a', 'b'))\n                    }\n                }\n            }\n\n            context(\"given a list of nullable strings\") {\n                val input = \"\"\"\n                    - thing1\n                    - null\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(String.serializer().nullable), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        expect(result).toBe(listOf(\"thing1\", null))\n                    }\n                }\n            }\n\n            context(\"given a list of lists\") {\n                val input = \"\"\"\n                    - [thing1, thing2]\n                    - [thing3]\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(ListSerializer(String.serializer())), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        expect(result).toBe(\n                            listOf(\n                                listOf(\"thing1\", \"thing2\"),\n                                listOf(\"thing3\")\n                            )\n                        )\n                    }\n                }\n            }\n\n            context(\"given a list of objects\") {\n                val input = \"\"\"\n                    - name: thing1\n                    - name: thing2\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(SimpleStructure.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        expect(result).toBe(\n                            listOf(\n                                SimpleStructure(\"thing1\"),\n                                SimpleStructure(\"thing2\")\n                            )\n                        )\n                    }\n                }\n            }\n        }\n\n        describe(\"parsing objects\") {\n            context(\"given some input representing an object with an optional value specified\") {\n                val input = \"\"\"\n                    string: Alex\n                    byte: 12\n                    short: 1234\n                    int: 123456\n                    long: 1234567\n                    float: 1.2\n                    double: 2.4\n                    enum: Value1\n                    boolean: true\n                    char: A\n                    nullable: present\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(ComplexStructure.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        expect(result).toBe(\n                            ComplexStructure(\n                                \"Alex\",\n                                12,\n                                1234,\n                                123456,\n                                1234567,\n                                1.2f,\n                                2.4,\n                                TestEnum.Value1,\n                                true,\n                                'A',\n                                \"present\"\n                            )\n                        )\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with an optional value specified as null\") {\n                val input = \"\"\"\n                    string: Alex\n                    byte: 12\n                    short: 1234\n                    int: 123456\n                    long: 1234567\n                    float: 1.2\n                    double: 2.4\n                    enum: Value1\n                    boolean: true\n                    char: A\n                    nullable: null\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(ComplexStructure.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        expect(result).toBe(\n                            ComplexStructure(\n                                \"Alex\",\n                                12,\n                                1234,\n                                123456,\n                                1234567,\n                                1.2f,\n                                2.4,\n                                TestEnum.Value1,\n                                true,\n                                'A',\n                                null\n                            )\n                        )\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with an optional value not specified\") {\n                val input = \"\"\"\n                    string: Alex\n                    byte: 12\n                    short: 1234\n                    int: 123456\n                    long: 1234567\n                    float: 1.2\n                    double: 2.4\n                    enum: Value1\n                    boolean: true\n                    char: A\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(ComplexStructure.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        expect(result).toBe(\n                            ComplexStructure(\n                                \"Alex\",\n                                12,\n                                1234,\n                                123456,\n                                1234567,\n                                1.2f,\n                                2.4,\n                                TestEnum.Value1,\n                                true,\n                                'A',\n                                null\n                            )\n                        )\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with an embedded list\") {\n                val input = \"\"\"\n                    members:\n                        - Alex\n                        - Jamie\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(Team.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        expect(result).toBe(Team(listOf(\"Alex\", \"Jamie\")))\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with an embedded object\") {\n                val input = \"\"\"\n                    firstPerson:\n                        name: Alex\n                    secondPerson:\n                        name: Jamie\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(NestedObjects.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        expect(result).toBe(NestedObjects(SimpleStructure(\"Alex\"), SimpleStructure(\"Jamie\")))\n                    }\n                }\n            }\n\n            context(\"given some input representing an object where the keys are in a different order to the object definition\") {\n                val input = \"\"\"\n                    secondPerson:\n                        name: Jamie\n                    firstPerson:\n                        name: Alex\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(NestedObjects.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        expect(result).toBe(NestedObjects(SimpleStructure(\"Alex\"), SimpleStructure(\"Jamie\")))\n                    }\n                }\n            }\n\n            context(\"given some tagged input representing an arbitrary list\") {\n                val input = \"\"\"\n                    !!list\n                        - 5\n                        - 3\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Int.serializer()), input)\n                    it(\"deserializes it to a list ignoring the tag\") {\n                        expect(result).toBe(listOf(5, 3))\n                    }\n                }\n\n                context(\"parsing that input with a serializer that uses YAML location information when throwing exceptions\") {\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(LocationThrowingSerializer, input) }).toThrow<LocationInformationException> {\n                            message { toBe(\"Serializer called with location (1, 1) and path: <root>\") }\n                        }\n                    }\n                }\n            }\n\n            context(\"given some tagged input representing an arbitrary map\") {\n                val input = \"\"\"\n                    !!map\n                    foo: bar\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as map\") {\n                    val result = Yaml.default.decodeFromString(\n                        MapSerializer(String.serializer(), String.serializer()),\n                        input\n                    )\n                    it(\"deserializes it to a Map ignoring the tag\") {\n                        expect(result).toBe(mapOf(\"foo\" to \"bar\"))\n                    }\n                }\n\n                context(\"parsing that input with a serializer that uses YAML location information when throwing exceptions\") {\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(LocationThrowingMapSerializer, input) }).toThrow<LocationInformationException> {\n                            message { toBe(\"Serializer called with location (1, 1) and path: <root>\") }\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with a missing key\") {\n                val input = \"\"\"\n                    byte: 12\n                    short: 1234\n                    int: 123456\n                    long: 1234567\n                    float: 1.2\n                    double: 2.4\n                    enum: Value1\n                    boolean: true\n                    char: A\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    it(\"throws an appropriate exception\") {\n                        expect({ Yaml.default.decodeFromString(ComplexStructure.serializer(), input) }).toThrow<MissingRequiredPropertyException> {\n                            message { toBe(\"Property 'string' is required but it is missing.\") }\n                            line { toBe(1) }\n                            column { toBe(1) }\n                            propertyName { toBe(\"string\") }\n                            path { toBe(YamlPath.root) }\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with an unknown key\") {\n                val input = \"\"\"\n                    abc123: something\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    it(\"throws an appropriate exception\") {\n                        expect({ Yaml.default.decodeFromString(ComplexStructure.serializer(), input) }).toThrow<UnknownPropertyException> {\n                            message { toBe(\"Unknown property 'abc123'. Known properties are: boolean, byte, char, double, enum, float, int, long, nullable, short, string\") }\n                            line { toBe(1) }\n                            column { toBe(1) }\n                            propertyName { toBe(\"abc123\") }\n                            validPropertyNames { toBe(setOf(\"boolean\", \"byte\", \"char\", \"double\", \"enum\", \"float\", \"int\", \"long\", \"nullable\", \"short\", \"string\")) }\n                            path { toBe(YamlPath.root.withMapElementKey(\"abc123\", Location(1, 1))) }\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with an invalid value for a field\") {\n                mapOf(\n                    \"byte\" to \"Value 'xxx' is not a valid byte value.\",\n                    \"short\" to \"Value 'xxx' is not a valid short value.\",\n                    \"int\" to \"Value 'xxx' is not a valid integer value.\",\n                    \"long\" to \"Value 'xxx' is not a valid long value.\",\n                    \"float\" to \"Value 'xxx' is not a valid floating point value.\",\n                    \"double\" to \"Value 'xxx' is not a valid floating point value.\",\n                    \"enum\" to \"Value 'xxx' is not a valid option, permitted choices are: Value1, Value2\",\n                    \"boolean\" to \"Value 'xxx' is not a valid boolean, permitted choices are: true or false\",\n                    \"char\" to \"Value 'xxx' is not a valid character value.\"\n                ).forEach { (fieldName, errorMessage) ->\n                    context(\"given the invalid field represents a $fieldName\") {\n                        val input = \"$fieldName: xxx\"\n\n                        context(\"parsing that input\") {\n                            it(\"throws an appropriate exception\") {\n                                expect({ Yaml.default.decodeFromString(ComplexStructure.serializer(), input) }).toThrow<InvalidPropertyValueException> {\n                                    message { toBe(\"Value for '$fieldName' is invalid: $errorMessage\") }\n                                    line { toBe(1) }\n                                    column { toBe(fieldName.length + 3) }\n                                    propertyName { toBe(fieldName) }\n                                    reason { toBe(errorMessage) }\n                                    path { toBe(YamlPath.root.withMapElementKey(fieldName, Location(1, 1)).withMapElementValue(Location(1, fieldName.length + 3))) }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with a null value for a non-nullable scalar field\") {\n                val input = \"name: null\"\n\n                context(\"parsing that input\") {\n                    it(\"throws an appropriate exception\") {\n                        expect({ Yaml.default.decodeFromString(SimpleStructure.serializer(), input) }).toThrow<InvalidPropertyValueException> {\n                            message { toBe(\"Value for 'name' is invalid: Unexpected null or empty value for non-null field.\") }\n                            line { toBe(1) }\n                            column { toBe(7) }\n                            propertyName { toBe(\"name\") }\n                            reason { toBe(\"Unexpected null or empty value for non-null field.\") }\n                            path { toBe(YamlPath.root.withMapElementKey(\"name\", Location(1, 1)).withMapElementValue(Location(1, 7))) }\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with a null value for a non-nullable nested object field\") {\n                val input = \"firstPerson: null\"\n\n                context(\"parsing that input\") {\n                    it(\"throws an appropriate exception\") {\n                        expect({ Yaml.default.decodeFromString(NestedObjects.serializer(), input) }).toThrow<InvalidPropertyValueException> {\n                            message { toBe(\"Value for 'firstPerson' is invalid: Unexpected null or empty value for non-null field.\") }\n                            line { toBe(1) }\n                            column { toBe(14) }\n                            propertyName { toBe(\"firstPerson\") }\n                            reason { toBe(\"Unexpected null or empty value for non-null field.\") }\n                            path { toBe(YamlPath.root.withMapElementKey(\"firstPerson\", Location(1, 1)).withMapElementValue(Location(1, 14))) }\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with a null value for a nullable nested object field\") {\n\n                val input = \"firstPerson: null\"\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(NullableNestedObject.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        expect(result).toBe(NullableNestedObject(null))\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with a null value for a non-nullable nested list field\") {\n                val input = \"members: null\"\n\n                context(\"parsing that input\") {\n                    it(\"throws an appropriate exception\") {\n                        expect({ Yaml.default.decodeFromString(Team.serializer(), input) }).toThrow<InvalidPropertyValueException> {\n                            message { toBe(\"Value for 'members' is invalid: Unexpected null or empty value for non-null field.\") }\n                            line { toBe(1) }\n                            column { toBe(10) }\n                            propertyName { toBe(\"members\") }\n                            reason { toBe(\"Unexpected null or empty value for non-null field.\") }\n                            path { toBe(YamlPath.root.withMapElementKey(\"members\", Location(1, 1)).withMapElementValue(Location(1, 10))) }\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with a null value for a nullable nested list field\") {\n                val input = \"members: null\"\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(NullableNestedList.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        expect(result).toBe(NullableNestedList(null))\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with a custom serializer for one of its values\") {\n                val input = \"value: something\"\n\n                context(\"parsing that input with a serializer that uses YAML location information when throwing exceptions\") {\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(StructureWithLocationThrowingSerializer.serializer(), input) }).toThrow<LocationInformationException> {\n                            message { toBe(\"Serializer called with location (1, 8) and path: value\") }\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing a generic map\") {\n                val input = \"\"\"\n                    SOME_ENV_VAR: somevalue\n                    SOME_OTHER_ENV_VAR: someothervalue\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input)\n\n                    it(\"deserializes it to a Kotlin map\") {\n                        expect(result).toBe(\n                            mapOf(\n                                \"SOME_ENV_VAR\" to \"somevalue\",\n                                \"SOME_OTHER_ENV_VAR\" to \"someothervalue\"\n                            )\n                        )\n                    }\n                }\n\n                context(\"parsing that input with a serializer for the key that uses YAML location information when throwing exceptions\") {\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(MapSerializer(LocationThrowingSerializer, String.serializer()), input) }).toThrow<LocationInformationException> {\n                            message { toBe(\"Serializer called with location (1, 1) and path: SOME_ENV_VAR\") }\n                        }\n                    }\n                }\n\n                context(\"parsing that input with a serializer for the value that uses YAML location information when throwing exceptions\") {\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(MapSerializer(String.serializer(), LocationThrowingSerializer), input) }).toThrow<LocationInformationException> {\n                            message { toBe(\"Serializer called with location (1, 15) and path: SOME_ENV_VAR\") }\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input with some extensions\") {\n                val input = \"\"\"\n                    .some-extension: &name Jamie\n\n                    name: *name\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    val configuration = YamlConfiguration(extensionDefinitionPrefix = \".\")\n                    val yaml = Yaml(configuration = configuration)\n                    val result = yaml.decodeFromString(SimpleStructure.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object, replacing the reference to the extension with the extension\") {\n                        expect(result).toBe(SimpleStructure(\"Jamie\"))\n                    }\n                }\n            }\n\n            context(\"given some input with an additional unknown field\") {\n                val input = \"\"\"\n                    name: Blah Blahson\n                    extra-field: Hello\n                \"\"\".trimIndent()\n\n                context(\"given strict mode is enabled\") {\n                    val configuration = YamlConfiguration(strictMode = true)\n                    val yaml = Yaml(configuration = configuration)\n\n                    context(\"parsing that input\") {\n                        it(\"throws an appropriate exception\") {\n                            expect({ yaml.decodeFromString(SimpleStructure.serializer(), input) }).toThrow<UnknownPropertyException> {\n                                message { toBe(\"Unknown property 'extra-field'. Known properties are: name\") }\n                                line { toBe(2) }\n                                column { toBe(1) }\n                                path { toBe(YamlPath.root.withMapElementKey(\"extra-field\", Location(2, 1))) }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given strict mode is disabled\") {\n                    val configuration = YamlConfiguration(strictMode = false)\n                    val yaml = Yaml(configuration = configuration)\n\n                    context(\"parsing that input\") {\n                        it(\"ignores the extra field and returns a deserialised object\") {\n                            expect(yaml.decodeFromString(SimpleStructure.serializer(), input)).toBe(SimpleStructure(\"Blah Blahson\"))\n                        }\n                    }\n                }\n            }\n\n            context(\"given a nullable object\") {\n                val input = \"\"\"\n                    host: \"db.test.com\"\n                \"\"\".trimIndent()\n\n                val result = Yaml.default.decodeFromString(Database.serializer().nullable, input)\n\n                it(\"deserializes it to the expected object\") {\n                    expect(result).toBe(Database(\"db.test.com\"))\n                }\n            }\n        }\n\n        describe(\"parsing polymorphic values\") {\n            describe(\"given tags are used to store the type information\") {\n                val polymorphicYaml = Yaml(serializersModule = polymorphicModule, configuration = YamlConfiguration(polymorphismStyle = PolymorphismStyle.Tag))\n\n                context(\"given some input where the value should be a sealed class\") {\n                    val input = \"\"\"\n                        !<sealedString>\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            expect(result).toBe(TestSealedStructure.SimpleSealedString(\"asdfg\"))\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input)\n\n                        it(\"deserializes it to a map ignoring the tag\") {\n                            expect(result).toBe(mapOf(\"value\" to \"asdfg\"))\n                        }\n                    }\n                }\n\n                // See https://github.com/charleskorn/kaml/issues/179.\n                context(\"given some input where a tag is provided but no value is provided\") {\n                    val input = \"\"\"\n                        !<sealedString>\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an appropriate exception\") {\n                            expect({ polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }).toThrow<MissingRequiredPropertyException> {\n                                message { toBe(\"Property 'value' is required but it is missing.\") }\n                                line { toBe(1) }\n                                column { toBe(1) }\n                                propertyName { toBe(\"value\") }\n                                path { toBe(YamlPath.root) }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given some input where the value is a literal\") {\n                    val input = \"\"\"\n                        !<simpleString> \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(PolymorphicSerializer(UnwrappedInterface::class), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            expect(result).toBe(UnwrappedString(\"asdfg\"))\n                        }\n                    }\n\n                    context(\"parsing that input as a string\") {\n                        val result = polymorphicYaml.decodeFromString(String.serializer(), input)\n\n                        it(\"deserializes it to a string ignoring the tag\") {\n                            expect(result).toBe(\"asdfg\")\n                        }\n                    }\n                }\n\n                context(\"given some input where the value should be an unsealed class\") {\n                    val input = \"\"\"\n                        !<unsealedString>\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(PolymorphicSerializer(UnsealedClass::class), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            expect(result).toBe(UnsealedString(\"asdfg\"))\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input)\n\n                        it(\"deserializes it to a map ignoring the tag\") {\n                            expect(result).toBe(mapOf(\"value\" to \"asdfg\"))\n                        }\n                    }\n                }\n\n                context(\"given some input for an object where the property value should be a sealed class\") {\n                    val input = \"\"\"\n                        element: !<sealedString>\n                            value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(SealedWrapper.serializer(), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            expect(result).toBe(SealedWrapper(TestSealedStructure.SimpleSealedString(\"asdfg\")))\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), MapSerializer(String.serializer(), String.serializer())), input)\n\n                        it(\"deserializes it to a map ignoring the tag\") {\n                            expect(result).toBe(mapOf(\"element\" to mapOf(\"value\" to \"asdfg\")))\n                        }\n                    }\n                }\n\n                context(\"given some input for an object where the property value is a literal\") {\n                    val input = \"\"\"\n                        test: !<simpleInt> 42\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(PolymorphicWrapper.serializer(), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            expect(result).toBe(PolymorphicWrapper(UnwrappedInt(42)))\n                        }\n                    }\n                }\n\n                context(\"given some tagged input representing a list of polymorphic objects\") {\n                    val input = \"\"\"\n                        - !<sealedString>\n                          value: null\n                        - !<sealedInt>\n                          value: -987\n                        - !<sealedInt>\n                          value: 654\n                        - !<sealedString>\n                          value: \"tests\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(ListSerializer(TestSealedStructure.serializer()), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            expect(result).toBe(\n                                listOf(\n                                    TestSealedStructure.SimpleSealedString(null),\n                                    TestSealedStructure.SimpleSealedInt(-987),\n                                    TestSealedStructure.SimpleSealedInt(654),\n                                    TestSealedStructure.SimpleSealedString(\"tests\")\n                                )\n                            )\n                        }\n                    }\n                }\n\n                context(\"given some untagged input for a polymorphic class\") {\n                    val input = \"\"\"\n                        element:\n                            value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            expect({ polymorphicYaml.decodeFromString(SealedWrapper.serializer(), input) }).toThrow<InvalidPropertyValueException> {\n                                message { toBe(\"Value for 'element' is invalid: Value is missing a type tag (eg. !<type>)\") }\n                                line { toBe(2) }\n                                column { toBe(5) }\n                                cause<MissingTypeTagException>()\n                                path { toBe(YamlPath.root.withMapElementKey(\"element\", Location(1, 1)).withMapElementValue(Location(2, 5))) }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given some untagged input for a polymorphic value\") {\n                    val input = \"\"\"\n                        test: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            expect({ polymorphicYaml.decodeFromString(PolymorphicWrapper.serializer(), input) }).toThrow<InvalidPropertyValueException> {\n                                message { toBe(\"Value for 'test' is invalid: Value is missing a type tag (eg. !<type>)\") }\n                                line { toBe(1) }\n                                column { toBe(7) }\n                                cause<MissingTypeTagException>()\n                                path { toBe(YamlPath.root.withMapElementKey(\"test\", Location(1, 1)).withMapElementValue(Location(1, 7))) }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given some untagged null input for a polymorphic value\") {\n                    val input = \"\"\"\n                        test: null\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            expect({ polymorphicYaml.decodeFromString(PolymorphicWrapper.serializer(), input) }).toThrow<InvalidPropertyValueException> {\n                                message { toBe(\"Value for 'test' is invalid: Value is missing a type tag (eg. !<type>)\") }\n                                line { toBe(1) }\n                                column { toBe(7) }\n                                cause<MissingTypeTagException>()\n                                path { toBe(YamlPath.root.withMapElementKey(\"test\", Location(1, 1)).withMapElementValue(Location(1, 7))) }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given a polymorphic value for a property from an unsealed type with an unknown type tag\") {\n                    val input = \"\"\"\n                        !<someOtherType> 42\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            expect({ polymorphicYaml.decodeFromString(PolymorphicSerializer(UnsealedClass::class), input) }).toThrow<UnknownPolymorphicTypeException> {\n                                message { toBe(\"Unknown type 'someOtherType'. Known types are: unsealedBoolean, unsealedString\") }\n                                line { toBe(1) }\n                                column { toBe(1) }\n                                typeName { toBe(\"someOtherType\") }\n                                validTypeNames { toBe(setOf(\"unsealedBoolean\", \"unsealedString\")) }\n                                path { toBe(YamlPath.root) }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given a polymorphic value for a property from a sealed type with an unknown type tag\") {\n                    val input = \"\"\"\n                        !<someOtherType> 42\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            expect({ polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }).toThrow<UnknownPolymorphicTypeException> {\n                                message { toBe(\"Unknown type 'someOtherType'. Known types are: sealedInt, sealedString\") }\n                                line { toBe(1) }\n                                column { toBe(1) }\n                                typeName { toBe(\"someOtherType\") }\n                                validTypeNames { toBe(setOf(\"sealedInt\", \"sealedString\")) }\n                                path { toBe(YamlPath.root) }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given a polymorphic value from a literal with an unknown type tag\") {\n                    val input = \"\"\"\n                        !<someOtherType> 42\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            expect({ polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }).toThrow<UnknownPolymorphicTypeException> {\n                                message { toBe(\"Unknown type 'someOtherType'. Known types are: sealedInt, sealedString\") }\n                                line { toBe(1) }\n                                column { toBe(1) }\n                                typeName { toBe(\"someOtherType\") }\n                                validTypeNames { toBe(setOf(\"sealedInt\", \"sealedString\")) }\n                                path { toBe(YamlPath.root) }\n                            }\n                        }\n                    }\n                }\n            }\n\n            describe(\"given a property is used to store the type information\") {\n                val polymorphicYaml = Yaml(serializersModule = polymorphicModule, configuration = YamlConfiguration(polymorphismStyle = PolymorphismStyle.Property))\n\n                context(\"given some input where the value should be a sealed class\") {\n                    val input = \"\"\"\n                        type: sealedString\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            expect(result).toBe(TestSealedStructure.SimpleSealedString(\"asdfg\"))\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input)\n\n                        it(\"deserializes it to a map including the type\") {\n                            expect(result).toBe(mapOf(\"type\" to \"sealedString\", \"value\" to \"asdfg\"))\n                        }\n                    }\n                }\n\n                context(\"given some input where the value should be an unsealed class\") {\n                    val input = \"\"\"\n                        type: unsealedString\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(PolymorphicSerializer(UnsealedClass::class), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            expect(result).toBe(UnsealedString(\"asdfg\"))\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input)\n\n                        it(\"deserializes it to a map ignoring the tag\") {\n                            expect(result).toBe(mapOf(\"type\" to \"unsealedString\", \"value\" to \"asdfg\"))\n                        }\n                    }\n                }\n\n                context(\"given some input for an object where the property value should be a sealed class\") {\n                    val input = \"\"\"\n                        element:\n                            type: sealedString\n                            value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(SealedWrapper.serializer(), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            expect(result).toBe(SealedWrapper(TestSealedStructure.SimpleSealedString(\"asdfg\")))\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), MapSerializer(String.serializer(), String.serializer())), input)\n\n                        it(\"deserializes it to a map ignoring the tag\") {\n                            expect(result).toBe(mapOf(\"element\" to mapOf(\"type\" to \"sealedString\", \"value\" to \"asdfg\")))\n                        }\n                    }\n                }\n\n                context(\"given some input missing a type property\") {\n                    val input = \"\"\"\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            expect({ polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }).toThrow<MissingRequiredPropertyException> {\n                                message { toBe(\"Property 'type' is required but it is missing.\") }\n                                line { toBe(1) }\n                                column { toBe(1) }\n                                propertyName { toBe(\"type\") }\n                                path { toBe(YamlPath.root) }\n                            }\n                        }\n                    }\n                }\n\n                mapOf(\n                    \"a list\" to \"[]\",\n                    \"a map\" to \"{}\",\n                    \"a null value\" to \"null\",\n                    \"a tagged value\" to \"!<tag> sealedString\"\n                ).forEach { description, value ->\n                    context(\"given some input with a type property that is $description\") {\n                        val input = \"\"\"\n                            type: $value\n                            value: \"asdfg\"\n                        \"\"\".trimIndent()\n\n                        context(\"parsing that input\") {\n                            it(\"throws an exception with the correct location information\") {\n                                expect({ polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }).toThrow<InvalidPropertyValueException> {\n                                    message { toBe(\"Value for 'type' is invalid: expected a string, but got $description\") }\n                                    line { toBe(1) }\n                                    column { toBe(7) }\n                                    propertyName { toBe(\"type\") }\n                                    reason { toBe(\"expected a string, but got $description\") }\n                                    path { toBe(YamlPath.root.withMapElementKey(\"type\", Location(1, 1)).withMapElementValue(Location(1, 7))) }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given some tagged input representing a list of polymorphic objects\") {\n                    val input = \"\"\"\n                        - type: sealedString\n                          value: null\n                        - type: sealedInt\n                          value: -987\n                        - type: sealedInt\n                          value: 654\n                        - type: sealedString\n                          value: \"tests\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(ListSerializer(TestSealedStructure.serializer()), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            expect(result).toBe(\n                                listOf(\n                                    TestSealedStructure.SimpleSealedString(null),\n                                    TestSealedStructure.SimpleSealedInt(-987),\n                                    TestSealedStructure.SimpleSealedInt(654),\n                                    TestSealedStructure.SimpleSealedString(\"tests\")\n                                )\n                            )\n                        }\n                    }\n                }\n\n                context(\"given a polymorphic value for a property from an unsealed type with an unknown type tag\") {\n                    val input = \"\"\"\n                        type: someOtherType\n                        value: 123\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            expect({ polymorphicYaml.decodeFromString(PolymorphicSerializer(UnsealedClass::class), input) }).toThrow<UnknownPolymorphicTypeException> {\n                                message { toBe(\"Unknown type 'someOtherType'. Known types are: unsealedBoolean, unsealedString\") }\n                                line { toBe(1) }\n                                column { toBe(7) }\n                                typeName { toBe(\"someOtherType\") }\n                                validTypeNames { toBe(setOf(\"unsealedBoolean\", \"unsealedString\")) }\n                                path { toBe(YamlPath.root.withMapElementKey(\"type\", Location(1, 1)).withMapElementValue(Location(1, 7))) }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given a polymorphic value for a property from a sealed type with an unknown type tag\") {\n                    val input = \"\"\"\n                        type: someOtherType\n                        value: 123\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            expect({ polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }).toThrow<UnknownPolymorphicTypeException> {\n                                message { toBe(\"Unknown type 'someOtherType'. Known types are: sealedInt, sealedString\") }\n                                line { toBe(1) }\n                                column { toBe(7) }\n                                typeName { toBe(\"someOtherType\") }\n                                validTypeNames { toBe(setOf(\"sealedInt\", \"sealedString\")) }\n                                path { toBe(YamlPath.root.withMapElementKey(\"type\", Location(1, 1)).withMapElementValue(Location(1, 7))) }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given some input with a tag and a type property\") {\n                    val input = \"\"\"\n                        !<sealedInt>\n                        type: sealedString\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input)\n\n                        it(\"uses the type from the property and ignores the tag\") {\n                            expect(result).toBe(TestSealedStructure.SimpleSealedString(\"asdfg\"))\n                        }\n                    }\n                }\n            }\n\n            describe(\"given a custom property name is used to store the type information\") {\n                val polymorphicYaml = Yaml(serializersModule = polymorphicModule, configuration = YamlConfiguration(polymorphismStyle = PolymorphismStyle.Property, polymorphismPropertyName = \"kind\"))\n\n                context(\"given some input where the value should be a sealed class\") {\n                    val input = \"\"\"\n                        kind: sealedString\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            expect(result).toBe(TestSealedStructure.SimpleSealedString(\"asdfg\"))\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input)\n\n                        it(\"deserializes it to a map including the type\") {\n                            expect(result).toBe(mapOf(\"kind\" to \"sealedString\", \"value\" to \"asdfg\"))\n                        }\n                    }\n                }\n\n                context(\"given some input where the value should be an unsealed class\") {\n                    val input = \"\"\"\n                        kind: unsealedString\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(PolymorphicSerializer(UnsealedClass::class), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            expect(result).toBe(UnsealedString(\"asdfg\"))\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input)\n\n                        it(\"deserializes it to a map ignoring the tag\") {\n                            expect(result).toBe(mapOf(\"kind\" to \"unsealedString\", \"value\" to \"asdfg\"))\n                        }\n                    }\n                }\n\n                context(\"given some input for an object where the property value should be a sealed class\") {\n                    val input = \"\"\"\n                        element:\n                            kind: sealedString\n                            value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(SealedWrapper.serializer(), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            expect(result).toBe(SealedWrapper(TestSealedStructure.SimpleSealedString(\"asdfg\")))\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), MapSerializer(String.serializer(), String.serializer())), input)\n\n                        it(\"deserializes it to a map ignoring the tag\") {\n                            expect(result).toBe(mapOf(\"element\" to mapOf(\"kind\" to \"sealedString\", \"value\" to \"asdfg\")))\n                        }\n                    }\n                }\n\n                context(\"given some input missing a type property\") {\n                    val input = \"\"\"\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            expect({ polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }).toThrow<MissingRequiredPropertyException> {\n                                message { toBe(\"Property 'kind' is required but it is missing.\") }\n                                line { toBe(1) }\n                                column { toBe(1) }\n                                propertyName { toBe(\"kind\") }\n                                path { toBe(YamlPath.root) }\n                            }\n                        }\n                    }\n                }\n\n                mapOf(\n                    \"a list\" to \"[]\",\n                    \"a map\" to \"{}\",\n                    \"a null value\" to \"null\",\n                    \"a tagged value\" to \"!<tag> sealedString\"\n                ).forEach { description, value ->\n                    context(\"given some input with a type property that is $description\") {\n                        val input = \"\"\"\n                            kind: $value\n                            value: \"asdfg\"\n                        \"\"\".trimIndent()\n\n                        context(\"parsing that input\") {\n                            it(\"throws an exception with the correct location information\") {\n                                expect({ polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }).toThrow<InvalidPropertyValueException> {\n                                    message { toBe(\"Value for 'kind' is invalid: expected a string, but got $description\") }\n                                    line { toBe(1) }\n                                    column { toBe(7) }\n                                    propertyName { toBe(\"kind\") }\n                                    reason { toBe(\"expected a string, but got $description\") }\n                                    path { toBe(YamlPath.root.withMapElementKey(\"kind\", Location(1, 1)).withMapElementValue(Location(1, 7))) }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given some tagged input representing a list of polymorphic objects\") {\n                    val input = \"\"\"\n                        - kind: sealedString\n                          value: null\n                        - kind: sealedInt\n                          value: -987\n                        - kind: sealedInt\n                          value: 654\n                        - kind: sealedString\n                          value: \"tests\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(ListSerializer(TestSealedStructure.serializer()), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            expect(result).toBe(\n                                listOf(\n                                    TestSealedStructure.SimpleSealedString(null),\n                                    TestSealedStructure.SimpleSealedInt(-987),\n                                    TestSealedStructure.SimpleSealedInt(654),\n                                    TestSealedStructure.SimpleSealedString(\"tests\")\n                                )\n                            )\n                        }\n                    }\n                }\n\n                context(\"given a polymorphic value for a property from an unsealed type with an unknown type tag\") {\n                    val input = \"\"\"\n                        kind: someOtherType\n                        value: 123\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            expect({ polymorphicYaml.decodeFromString(PolymorphicSerializer(UnsealedClass::class), input) }).toThrow<UnknownPolymorphicTypeException> {\n                                message { toBe(\"Unknown type 'someOtherType'. Known types are: unsealedBoolean, unsealedString\") }\n                                line { toBe(1) }\n                                column { toBe(7) }\n                                typeName { toBe(\"someOtherType\") }\n                                validTypeNames { toBe(setOf(\"unsealedBoolean\", \"unsealedString\")) }\n                                path { toBe(YamlPath.root.withMapElementKey(\"kind\", Location(1, 1)).withMapElementValue(Location(1, 7))) }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given a polymorphic value for a property from a sealed type with an unknown type tag\") {\n                    val input = \"\"\"\n                        kind: someOtherType\n                        value: 123\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            expect({ polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }).toThrow<UnknownPolymorphicTypeException> {\n                                message { toBe(\"Unknown type 'someOtherType'. Known types are: sealedInt, sealedString\") }\n                                line { toBe(1) }\n                                column { toBe(7) }\n                                typeName { toBe(\"someOtherType\") }\n                                validTypeNames { toBe(setOf(\"sealedInt\", \"sealedString\")) }\n                                path { toBe(YamlPath.root.withMapElementKey(\"kind\", Location(1, 1)).withMapElementValue(Location(1, 7))) }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given some input with a tag and a type property\") {\n                    val input = \"\"\"\n                        !<sealedInt>\n                        kind: sealedString\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input)\n\n                        it(\"uses the type from the property and ignores the tag\") {\n                            expect(result).toBe(TestSealedStructure.SimpleSealedString(\"asdfg\"))\n                        }\n                    }\n                }\n            }\n        }\n\n        describe(\"parsing values with a dynamically installed serializer\") {\n            describe(\"parsing a literal with a contextual serializer\") {\n                val contextSerializer = object : KSerializer<Inner> {\n                    override val descriptor: SerialDescriptor\n                        get() = String.serializer().descriptor\n\n                    override fun deserialize(decoder: Decoder): Inner = Inner(\"from context serializer\")\n                    override fun serialize(encoder: Encoder, value: Inner) = throw UnsupportedOperationException()\n                }\n\n                val module = serializersModuleOf(Inner::class, contextSerializer)\n                val parser = Yaml(serializersModule = module)\n\n                val input = \"\"\"\n                    inner: this is the input\n                \"\"\".trimIndent()\n\n                val result = parser.decodeFromString(Container.serializer(), input)\n\n                it(\"deserializes it using the dynamically installed serializer\") {\n                    expect(result).toBe(Container(Inner(\"from context serializer\")))\n                }\n            }\n\n            describe(\"parsing a class with a contextual serializer\") {\n                val contextSerializer = object : KSerializer<Inner> {\n                    override val descriptor = buildClassSerialDescriptor(\"Inner\") {\n                        element(\"thing\", String.serializer().descriptor)\n                    }\n\n                    override fun deserialize(decoder: Decoder): Inner {\n                        val objectDecoder = decoder.beginStructure(descriptor)\n                        val index = objectDecoder.decodeElementIndex(descriptor)\n                        val name = objectDecoder.decodeStringElement(descriptor, index)\n                        objectDecoder.endStructure(descriptor)\n\n                        return Inner(\"$name, from context serializer\")\n                    }\n\n                    override fun serialize(encoder: Encoder, value: Inner) = throw UnsupportedOperationException()\n                }\n\n                val module = serializersModuleOf(Inner::class, contextSerializer)\n                val parser = Yaml(serializersModule = module)\n\n                val input = \"\"\"\n                    inner:\n                        thing: this is the input\n                \"\"\".trimIndent()\n\n                val result = parser.decodeFromString(Container.serializer(), input)\n\n                it(\"deserializes it using the dynamically installed serializer\") {\n                    expect(result).toBe(Container(Inner(\"this is the input, from context serializer\")))\n                }\n            }\n\n            describe(\"parsing a map with a contextual serializer\") {\n                val contextSerializer = object : KSerializer<Inner> {\n                    override val descriptor = buildSerialDescriptor(\"Inner\", StructureKind.MAP) {\n                        element(\"key\", String.serializer().descriptor)\n                        element(\"value\", String.serializer().descriptor)\n                    }\n\n                    override fun deserialize(decoder: Decoder): Inner {\n                        val objectDecoder = decoder.beginStructure(descriptor)\n                        val keyIndex = objectDecoder.decodeElementIndex(descriptor)\n                        val key = objectDecoder.decodeStringElement(descriptor, keyIndex)\n                        val valueIndex = objectDecoder.decodeElementIndex(descriptor)\n                        val value = objectDecoder.decodeStringElement(descriptor, valueIndex)\n\n                        objectDecoder.endStructure(descriptor)\n\n                        return Inner(\"$key: $value, from context serializer\")\n                    }\n\n                    override fun serialize(encoder: Encoder, value: Inner) = throw UnsupportedOperationException()\n                }\n\n                val module = serializersModuleOf(Inner::class, contextSerializer)\n                val parser = Yaml(serializersModule = module)\n\n                val input = \"\"\"\n                    inner:\n                        thing: this is the input\n                \"\"\".trimIndent()\n\n                val result = parser.decodeFromString(Container.serializer(), input)\n\n                it(\"deserializes it using the dynamically installed serializer\") {\n                    expect(result).toBe(Container(Inner(\"thing: this is the input, from context serializer\")))\n                }\n            }\n        }\n\n        describe(\"parsing values with mismatched types\") {\n            context(\"given a list\") {\n                listOf(\n                    \"a string\" to String.serializer(),\n                    \"an integer\" to Int.serializer(),\n                    \"a long\" to Long.serializer(),\n                    \"a short\" to Short.serializer(),\n                    \"a byte\" to Byte.serializer(),\n                    \"a double\" to Double.serializer(),\n                    \"a float\" to Float.serializer(),\n                    \"a boolean\" to Boolean.serializer(),\n                    \"a character\" to Char.serializer(),\n                    \"an enumeration value\" to TestEnum.serializer(),\n                    \"a map\" to MapSerializer(String.serializer(), String.serializer()),\n                    \"an object\" to ComplexStructure.serializer(),\n                    \"a string\" to String.serializer().nullable\n                ).forEach { (description, serializer) ->\n                    val input = \"- thing\"\n\n                    context(\"parsing that input as $description\") {\n                        it(\"throws an exception with the correct location information\") {\n                            expect({ Yaml.default.decodeFromString(serializer, input) }).toThrow<IncorrectTypeException> {\n                                message { toBe(\"Expected $description, but got a list\") }\n                                line { toBe(1) }\n                                column { toBe(1) }\n                                path { toBe(YamlPath.root) }\n                            }\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in a map\") {\n                    val input = \"\"\"\n                        key:\n                            - some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input) }).toThrow<InvalidPropertyValueException> {\n                            message { toBe(\"Value for 'key' is invalid: Expected a string, but got a list\") }\n                            line { toBe(2) }\n                            column { toBe(5) }\n                            path { toBe(YamlPath.root.withMapElementKey(\"key\", Location(1, 1)).withMapElementValue(Location(2, 5))) }\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in an object\") {\n                    val input = \"\"\"\n                        string:\n                            - some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(ComplexStructure.serializer(), input) }).toThrow<InvalidPropertyValueException> {\n                            message { toBe(\"Value for 'string' is invalid: Expected a string, but got a list\") }\n                            line { toBe(2) }\n                            column { toBe(5) }\n                            path { toBe(YamlPath.root.withMapElementKey(\"string\", Location(1, 1)).withMapElementValue(Location(2, 5))) }\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in a list\") {\n                    val input = \"\"\"\n                        - [ some_value ]\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(ListSerializer(String.serializer()), input) }).toThrow<IncorrectTypeException> {\n                            message { toBe(\"Expected a string, but got a list\") }\n                            line { toBe(1) }\n                            column { toBe(3) }\n                            path { toBe(YamlPath.root.withListEntry(0, Location(1, 3))) }\n                        }\n                    }\n                }\n            }\n\n            context(\"given a map\") {\n                listOf(\n                    \"a string\" to String.serializer(),\n                    \"an integer\" to Int.serializer(),\n                    \"a long\" to Long.serializer(),\n                    \"a short\" to Short.serializer(),\n                    \"a byte\" to Byte.serializer(),\n                    \"a double\" to Double.serializer(),\n                    \"a float\" to Float.serializer(),\n                    \"a boolean\" to Boolean.serializer(),\n                    \"a character\" to Char.serializer(),\n                    \"an enumeration value\" to TestEnum.serializer(),\n                    \"a list\" to ListSerializer(String.serializer()),\n                    \"a string\" to String.serializer().nullable\n                ).forEach { (description, serializer) ->\n                    val input = \"key: value\"\n\n                    context(\"parsing that input as $description\") {\n                        it(\"throws an exception with the correct location information\") {\n                            expect({ Yaml.default.decodeFromString(serializer, input) }).toThrow<IncorrectTypeException> {\n                                message { toBe(\"Expected $description, but got a map\") }\n                                line { toBe(1) }\n                                column { toBe(1) }\n                                path { toBe(YamlPath.root) }\n                            }\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in a map\") {\n                    val input = \"\"\"\n                        key:\n                            some_key: some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input) }).toThrow<InvalidPropertyValueException> {\n                            message { toBe(\"Value for 'key' is invalid: Expected a string, but got a map\") }\n                            line { toBe(2) }\n                            column { toBe(5) }\n                            path { toBe(YamlPath.root.withMapElementKey(\"key\", Location(1, 1)).withMapElementValue(Location(2, 5))) }\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in an object\") {\n                    val input = \"\"\"\n                        string:\n                            some_key: some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(ComplexStructure.serializer(), input) }).toThrow<InvalidPropertyValueException> {\n                            message { toBe(\"Value for 'string' is invalid: Expected a string, but got a map\") }\n                            line { toBe(2) }\n                            column { toBe(5) }\n                            path { toBe(YamlPath.root.withMapElementKey(\"string\", Location(1, 1)).withMapElementValue(Location(2, 5))) }\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in a list\") {\n                    val input = \"\"\"\n                        - some_key: some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(ListSerializer(String.serializer()), input) }).toThrow<IncorrectTypeException> {\n                            message { toBe(\"Expected a string, but got a map\") }\n                            line { toBe(1) }\n                            column { toBe(3) }\n                            path { toBe(YamlPath.root.withListEntry(0, Location(1, 3))) }\n                        }\n                    }\n                }\n            }\n\n            context(\"given a scalar value\") {\n                mapOf(\n                    \"a list\" to ListSerializer(String.serializer()),\n                    \"a map\" to MapSerializer(String.serializer(), String.serializer()),\n                    \"an object\" to ComplexStructure.serializer()\n                ).forEach { (description, serializer) ->\n                    val input = \"blah\"\n\n                    context(\"parsing that input as $description\") {\n                        it(\"throws an exception with the correct location information\") {\n                            expect({ Yaml.default.decodeFromString(serializer, input) }).toThrow<IncorrectTypeException> {\n                                message { toBe(\"Expected $description, but got a scalar value\") }\n                                line { toBe(1) }\n                                column { toBe(1) }\n                                path { toBe(YamlPath.root) }\n                            }\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in a map\") {\n                    val input = \"\"\"\n                        key: some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(MapSerializer(String.serializer(), ListSerializer(String.serializer())), input) }).toThrow<InvalidPropertyValueException> {\n                            message { toBe(\"Value for 'key' is invalid: Expected a list, but got a scalar value\") }\n                            line { toBe(1) }\n                            column { toBe(6) }\n                            path { toBe(YamlPath.root.withMapElementKey(\"key\", Location(1, 1)).withMapElementValue(Location(1, 6))) }\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in an object\") {\n                    val input = \"\"\"\n                        members: some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(Team.serializer(), input) }).toThrow<InvalidPropertyValueException> {\n                            message { toBe(\"Value for 'members' is invalid: Expected a list, but got a scalar value\") }\n                            line { toBe(1) }\n                            column { toBe(10) }\n                            path { toBe(YamlPath.root.withMapElementKey(\"members\", Location(1, 1)).withMapElementValue(Location(1, 10))) }\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in a list\") {\n                    val input = \"\"\"\n                        - some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        expect({ Yaml.default.decodeFromString(ListSerializer((ListSerializer(String.serializer()))), input) }).toThrow<IncorrectTypeException> {\n                            message { toBe(\"Expected a list, but got a scalar value\") }\n                            line { toBe(1) }\n                            column { toBe(3) }\n                            path { toBe(YamlPath.root.withListEntry(0, Location(1, 3))) }\n                        }\n                    }\n                }\n            }\n        }\n\n        describe(\"parsing values with a contextual serializer\") {\n            mapOf(\n                \"scalar\" to \"2\",\n                \"list\" to \"[ thing ]\",\n                \"map\" to \"{ key: value }\"\n            ).forEach { (description, input) ->\n                context(\"given some input representing a $description\") {\n                    context(\"parsing that input using a contextual serializer at the top level\") {\n                        val result = Yaml.default.decodeFromString(ContextualSerializer, input)\n\n                        it(\"the serializer receives the top-level object\") {\n                            expect(result).toBe(description)\n                        }\n                    }\n\n                    context(\"parsing that input using a contextual serializer nested within an object\") {\n                        val result = Yaml.default.decodeFromString(ObjectWithNestedContextualSerializer.serializer(), \"thing: $input\")\n\n                        it(\"the serializer receives the correct object\") {\n                            expect(result).toBe(ObjectWithNestedContextualSerializer(description))\n                        }\n                    }\n                }\n            }\n\n            describe(\"given the contextual serializer attempts to begin a structure that does not match the input\") {\n                context(\"given the input is a map\") {\n                    val input = \"a: b\"\n\n                    mapOf(\n                        PrimitiveKind.STRING to \"a string\",\n                        StructureKind.LIST to \"a list\"\n                    ).forEach { (kind, description) ->\n                        context(\"attempting to begin $description\") {\n                            it(\"throws an exception with the correct location information\") {\n                                expect({ Yaml.default.decodeFromString(ContextualSerializerThatAttemptsToDeserializeIncorrectType(kind), input) }).toThrow<IncorrectTypeException> {\n                                    message { toBe(\"Expected $description, but got a map\") }\n                                    line { toBe(1) }\n                                    column { toBe(1) }\n                                    path { toBe(YamlPath.root) }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given the input is a list\") {\n                    val input = \"- a\"\n\n                    mapOf(\n                        StructureKind.OBJECT to \"an object\",\n                        StructureKind.CLASS to \"an object\",\n                        StructureKind.MAP to \"a map\",\n                        PrimitiveKind.STRING to \"a string\"\n                    ).forEach { (kind, description) ->\n                        context(\"attempting to begin $description\") {\n                            it(\"throws an exception with the correct location information\") {\n                                expect({ Yaml.default.decodeFromString(ContextualSerializerThatAttemptsToDeserializeIncorrectType(kind), input) }).toThrow<IncorrectTypeException> {\n                                    message { toBe(\"Expected $description, but got a list\") }\n                                    line { toBe(1) }\n                                    column { toBe(1) }\n                                    path { toBe(YamlPath.root) }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given the input is a scalar\") {\n                    val input = \"2\"\n\n                    mapOf(\n                        StructureKind.OBJECT to \"an object\",\n                        StructureKind.CLASS to \"an object\",\n                        StructureKind.MAP to \"a map\",\n                        StructureKind.LIST to \"a list\"\n                    ).forEach { (kind, description) ->\n                        context(\"attempting to begin $description\") {\n                            it(\"throws an exception with the correct location information\") {\n                                expect({ Yaml.default.decodeFromString(ContextualSerializerThatAttemptsToDeserializeIncorrectType(kind), input) }).toThrow<IncorrectTypeException> {\n                                    message { toBe(\"Expected $description, but got a scalar value\") }\n                                    line { toBe(1) }\n                                    column { toBe(1) }\n                                    path { toBe(YamlPath.root) }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n})\n\n@Serializable\nprivate data class ComplexStructure(\n    val string: String,\n    val byte: Byte,\n    val short: Short,\n    val int: Int,\n    val long: Long,\n    val float: Float,\n    val double: Double,\n    val enum: TestEnum,\n    val boolean: Boolean,\n    val char: Char,\n    val nullable: String? = null\n)\n\n@Serializable\nprivate data class StructureWithLocationThrowingSerializer(\n    @Serializable(with = LocationThrowingSerializer::class) val value: CustomSerializedValue\n)\n\nprivate data class CustomSerializedValue(val thing: String)\n\n@OptIn(InternalSerializationApi::class, ExperimentalSerializationApi::class)\nprivate object LocationThrowingSerializer : KSerializer<Any> {\n    override val descriptor = buildSerialDescriptor(LocationThrowingSerializer::class.qualifiedName!!, SerialKind.CONTEXTUAL)\n\n    override fun deserialize(decoder: Decoder): Any {\n        val location = (decoder as YamlInput).getCurrentLocation()\n        val path = decoder.getCurrentPath()\n\n        throw LocationInformationException(\"Serializer called with location (${location.line}, ${location.column}) and path: ${path.toHumanReadableString()}\")\n    }\n\n    override fun serialize(encoder: Encoder, value: Any) = throw UnsupportedOperationException()\n}\n\nprivate object LocationThrowingMapSerializer : KSerializer<Any> {\n    override val descriptor: SerialDescriptor = MapSerializer(String.serializer(), String.serializer()).descriptor\n\n    override fun deserialize(decoder: Decoder): Any {\n        val location = (decoder as YamlInput).getCurrentLocation()\n        val path = decoder.getCurrentPath()\n\n        throw LocationInformationException(\"Serializer called with location (${location.line}, ${location.column}) and path: ${path.toHumanReadableString()}\")\n    }\n\n    override fun serialize(encoder: Encoder, value: Any) = throw UnsupportedOperationException()\n}\n\nprivate class LocationInformationException(message: String) : RuntimeException(message)\n\n@OptIn(InternalSerializationApi::class, ExperimentalSerializationApi::class)\nobject ContextualSerializer : KSerializer<String> {\n    override val descriptor = buildSerialDescriptor(\"ContextualSerializer\", SerialKind.CONTEXTUAL) {\n        element(\"string\", PrimitiveSerialDescriptor(\"value\", PrimitiveKind.STRING))\n        element(\"object\", buildSerialDescriptor(\"thing\", StructureKind.OBJECT))\n    }\n\n    override fun deserialize(decoder: Decoder): String {\n        val input = decoder.beginStructure(descriptor) as YamlInput\n        val type = input.node::class.simpleName!!\n        input.endStructure(descriptor)\n\n        return type.removePrefix(\"Yaml\").lowercase()\n    }\n\n    override fun serialize(encoder: Encoder, value: String): Unit = throw UnsupportedOperationException()\n}\n\n@OptIn(InternalSerializationApi::class, ExperimentalSerializationApi::class)\nclass ContextualSerializerThatAttemptsToDeserializeIncorrectType(private val kind: SerialKind) : KSerializer<String> {\n    private val innerDescriptor = if (kind == StructureKind.CLASS) buildClassSerialDescriptor(\"thing\") else buildSerialDescriptor(\"thing\", kind)\n\n    override val descriptor = buildSerialDescriptor(\"ContextualSerializer\", SerialKind.CONTEXTUAL) {\n        element(\"string\", PrimitiveSerialDescriptor(\"value\", PrimitiveKind.STRING))\n        element(\"object\", innerDescriptor)\n    }\n\n    override fun deserialize(decoder: Decoder): String {\n        val input = decoder.beginStructure(descriptor) as YamlInput\n\n        input.beginStructure(innerDescriptor)\n\n        return \"Should never get to this point\"\n    }\n\n    override fun serialize(encoder: Encoder, value: String): Unit = throw UnsupportedOperationException()\n}\n\n// FIXME: ideally these would just be inline in the test cases that need them, but due to\n// https://github.com/Kotlin/kotlinx.serialization/issues/1427, this is no longer possible with\n// kotlinx.serialization 1.2 and above.\n// See also https://github.com/Kotlin/kotlinx.serialization/issues/1468.\n\n@Serializable\nprivate data class NullableNestedObject(val firstPerson: SimpleStructure?)\n\n@Serializable\ndata class NullableNestedList(val members: List<String>?)\n\n@Serializable\nprivate data class Database(val host: String)\n\nprivate data class Inner(val name: String)\n\n@Serializable\nprivate data class Container(@Contextual val inner: Inner)\n\n@Serializable\nprivate data class ObjectWithNestedContextualSerializer(@Serializable(with = ContextualSerializer::class) val thing: String)\n"], "filenames": ["src/commonMain/kotlin/com/charleskorn/kaml/YamlInput.kt", "src/commonTest/kotlin/com/charleskorn/kaml/YamlReadingTest.kt"], "buggy_code_start_loc": [32, 1195], "buggy_code_end_loc": [172, 1195], "fixing_code_start_loc": [33, 1196], "fixing_code_end_loc": [173, 1215], "type": "CWE-835", "message": "kaml is an open source implementation of the YAML format with support for kotlinx.serialization. In affected versions attackers that could provide arbitrary YAML input to an application that uses kaml could cause the application to endlessly loop while parsing the input. This could result in resource starvation and denial of service. This only affects applications that use polymorphic serialization with the default tagged polymorphism style. Applications using the property polymorphism style are not affected. YAML input for a polymorphic type that provided a tag but no value for the object would trigger the issue. Version 0.35.3 or later contain the fix for this issue.", "other": {"cve": {"id": "CVE-2021-39194", "sourceIdentifier": "security-advisories@github.com", "published": "2021-09-07T20:15:08.193", "lastModified": "2021-09-14T17:06:55.753", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "kaml is an open source implementation of the YAML format with support for kotlinx.serialization. In affected versions attackers that could provide arbitrary YAML input to an application that uses kaml could cause the application to endlessly loop while parsing the input. This could result in resource starvation and denial of service. This only affects applications that use polymorphic serialization with the default tagged polymorphism style. Applications using the property polymorphism style are not affected. YAML input for a polymorphic type that provided a tag but no value for the object would trigger the issue. Version 0.35.3 or later contain the fix for this issue."}, {"lang": "es", "value": "kaml es una implementaci\u00f3n de c\u00f3digo abierto del formato YAML con soporte para kotlinx.serialization. En las versiones afectadas, unos atacantes que pudieran proporcionar una entrada YAML arbitraria a una aplicaci\u00f3n que usa kaml podr\u00eda causar que la aplicaci\u00f3n realice un bucle interminable mientras analiza la entrada. Esto podr\u00eda resultar en una inanici\u00f3n de recursos y una denegaci\u00f3n de servicio. Esto s\u00f3lo afecta a las aplicaciones que usan una serializaci\u00f3n polim\u00f3rfica con el estilo de polimorfismo etiquetado predeterminado. Las aplicaciones que usan el estilo de polimorfismo de propiedades no est\u00e1n afectadas. La entrada de YAML para un tipo polim\u00f3rfico que proporciona una etiqueta pero no un valor para el objeto desencadenar\u00eda el problema. La versi\u00f3n 0.35.3 o posterior contiene la correcci\u00f3n de este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:kaml_project:kaml:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.35.3", "matchCriteriaId": "2769145F-32AC-4947-BD37-87EF18153497"}]}]}], "references": [{"url": "https://github.com/charleskorn/kaml/commit/e18785d043fc6324c81e968aae9764b4b060bc6a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/charleskorn/kaml/issues/179", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/charleskorn/kaml/security/advisories/GHSA-fmm9-3gv8-58f4", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/charleskorn/kaml/commit/e18785d043fc6324c81e968aae9764b4b060bc6a"}}