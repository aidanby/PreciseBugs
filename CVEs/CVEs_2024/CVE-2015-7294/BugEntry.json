{"buggy_code": ["# node-ldapauth-fork Changelog\n\n## 2.3.2\n\n- [issue #19] Added messages to options asserts\n\n## 2.3.1\n\n- [issue #14] Use bcryptjs instead of the C++ version.\n\n## 2.3.0\n\n- [passport-ldapauth issue #10] Added support for fetching user groups. If `groupSearchBase` and `groupSearchFilter` are defined, a group search is conducted after the user has succesfully authenticated. The found groups are stored to `user._groups`:\n\n```javascript\nnew LdapAuth({\n  \"url\": \"ldaps://ldap.example.com:636\",\n  \"adminDn\": \"cn=LdapAdmin,dc=local\",\n  \"adminPassword\": \"LdapAdminPassword\",\n  \"searchBase\": \"dc=users,dc=local\",\n  \"searchFilter\": \"(&(objectClass=person)(sAMAccountName={{username}}))\",\n  \"searchAttributes\": [\n    \"dn\", \"cn\", \"givenName\", \"name\", \"memberOf\", \"sAMAccountName\"\n  ],\n  \"groupSearchBase\": \"dc=groups,dc=local\",\n  \"groupSearchFilter\": \"(member={{dn}})\",\n  \"groupSearchAttributes\": [\"dn\", \"cn\", \"sAMAccountName\"]\n});\n```\n\n## 2.2.19\n\n- [issue #9] Configurable bind parameter. Thanks to @oanuna\n\n## 2.2.18\n\n- [issue #8] Fix options to actually work as documented\n\n## 2.2.17\n\n- Added `bindCredentials` option. Now defaulting to same names as ldapjs.\n\n## 2.2.16\n\n- Added option `includeRaw` for including `entry.raw` to the returned object (relates to ldapjs issue #238)\n\n## 2.2.15\n\n- [issue #5] Handle missing bcrypt and throw a explanatory exception instead\n\n## 2.2.14\n\n- [issue #4] Log error properties code, name, and message instead of the object\n\n## 2.2.12\n\n- [issue #1] Add more ldapjs options\n\n## 2.2.11\n\n- [passport-ldapauth issue #3] Update to ldapjs 0.7.0 fixes unhandled errors when using anonymous binding\n\n## 2.2.10\n\n- Try to bind with empty `adminDn` string (undefined/null equals no admin bind)\n\n## 2.2.9\n\n- [ldapauth issue #13] bcrypt as an optional dependency\n\n## 2.2.8\n\n- [ldapauth issue #2] support anonymous binding\n- [ldapauth issue #3] unbind clients in `close()`\n- Added option `searchScope`, default to `sub`\n\n## 2.2.7\n\n- Renamed to node-ldapauth-fork\n\n## 2.2.6\n\n- Another readme fix\n\n## 2.2.5\n\n- Readme updated\n\n## 2.2.4\n\n- [ldapauth issues #11, #12] update to ldapjs 0.6.3\n- [ldapauth issue #10] use global search/replace for {{username}}\n- [ldapauth issue #8] enable defining attributes to fetch from LDAP server\n\n# node-ldapauth Changelog\n\n## 2.2.3 (not yet released)\n\n(nothing yet)\n\n\n## 2.2.2\n\n- [issue #5] update to bcrypt 0.7.5 (0.7.3 fixes potential mem issues)\n\n\n## 2.2.1\n\n- Fix a bug where ldapauth `authenticate()` would raise an example on an empty\n  username.\n\n\n## 2.2.0\n\n- Update to latest ldapjs (0.5.6) and other deps.\n  Note: This makes ldapauth only work with node >=0.8 (because of internal dep\n  in ldapjs 0.5).\n\n\n## 2.1.0\n\n- Update to ldapjs 0.4 (from 0.3). Crossing fingers that this doesn't cause breakage.\n\n\n## 2.0.0\n\n- Add `make check` for checking jsstyle.\n- [issue #1] Update to bcrypt 0.5. This means increasing the base node from 0.4\n  to 0.6, hence the major version bump.\n\n\n## 1.0.2\n\nFirst working version.\n\n\n", "/**\n * Copyright 2011 (c) Trent Mick.\n *\n * LDAP auth.\n *\n * Usage:\n *    var LdapAuth = require('ldapauth');\n *    var auth = new LdapAuth({url: 'ldaps://ldap.example.com:636', ...});\n *    ...\n *    auth.authenticate(username, password, function (err, user) { ... });\n *    ...\n *    auth.close(function (err) { ... })\n */\n\nvar assert = require('assert');\nvar ldap = require('ldapjs');\nvar debug = console.warn;\nvar format = require('util').format;\nvar bcrypt = require('bcryptjs');\n\n\n/**\n * Create an LDAP auth class. Primary usage is the `.authenticate` method.\n *\n * @param opts {Object} Config options. Keys (required, unless says\n *      otherwise) are:\n *    url {String}\n *        E.g. 'ldaps://ldap.example.com:663'\n *    bindDn {String}\n *        Optional, e.g. 'uid=myapp,ou=users,o=example.com'. Alias: adminDn\n *    bindCredentials {String}\n *        Password for bindDn. Aliases: Credentials, adminPassword\n *    bindProperty {String}\n *        Optional, default 'dn'. Property of user to bind against client\n *        e.g. 'name', 'email'\n *    searchBase {String}\n *        The base DN from which to search for users by username.\n *         E.g. 'ou=users,o=example.com'\n *    searchScope {String}\n *        Optional, default 'sub'. Scope of the search, one of 'base',\n *        'one', or 'sub'.\n *    searchFilter {String}\n *        LDAP search filter with which to find a user by username, e.g.\n *        '(uid={{username}})'. Use the literal '{{username}}' to have the\n *        given username be interpolated in for the LDAP search.\n *    searchAttributes {Array}\n *        Optional, default all. Array of attributes to fetch from LDAP server.\n *    groupDnProperty {String}\n *        Optional, default 'dn'. The property of user object to use in\n *        '{{dn}}' interpolation of groupSearchFilter.\n *    groupSearchBase {String}\n *        Optional. The base DN from which to search for groups. If defined,\n *        also groupSearchFilter must be defined for the search to work.\n *    groupSearchScope {String}\n *        Optional, default 'sub'.\n *    groupSearchFilter {String}\n *        Optional. LDAP search filter for groups. The following literals are\n *        interpolated from the found user object: '{{dn}}' the property\n *        configured with groupDnProperty.\n *    groupSearchAttributes {Array}\n *        Optional, default all. Array of attributes to fetch from LDAP server.\n *    log4js {Module}\n *        Optional. The require'd log4js module to use for logging. If given\n *        this will result in TRACE-level logging for ldapauth.\n *    verbose {Boolean}\n *        Optional, default false. If `log4js` is also given, this will add\n *        TRACE-level logging for ldapjs (quite verbose).\n *    cache {Boolean}\n *        Optional, default false. If true, then up to 100 credentials at a\n *        time will be cached for 5 minutes.\n *    timeout {Integer}\n *        Optional, default Infinity. How long the client should let\n *        operations live for before timing out.\n *    connectTimeout {Integer}\n *        Optional, default is up to the OS. How long the client should wait\n *        before timing out on TCP connections.\n *    tlsOptions {Object}\n *        Additional options passed to the TLS connection layer when\n *        connecting via ldaps://. See\n *        http://nodejs.org/api/tls.html#tls_tls_connect_options_callback\n *        for available options\n *    maxConnections {Integer}\n *        Whether or not to enable connection pooling, and if so, how many to\n *        maintain.\n *    checkInterval {Integer}\n *        How often to schedule health checks for the connection pool.\n *    maxIdleTime {Integer}\n *        How long a client can be idle before health-checking the connection\n *        (subject to the checkInterval frequency)\n *    includeRaw {boolean}\n *        Optional, default false. Set to true to add property '_raw'\n *        containing the original buffers to the returned user object.\n *        Useful when you need to handle binary attributes.\n */\nfunction LdapAuth(opts) {\n  this.opts = opts;\n  assert.ok(opts.url, 'LDAP server URL not defined (opts.url)');\n  assert.ok(opts.searchBase, 'Search base not defined (opts.searchBase)');\n  assert.ok(opts.searchFilter, 'Search filter not defined (opts.searchFilter)');\n\n  this.log = opts.log4js && opts.log4js.getLogger('ldapauth');\n\n  this.opts.searchScope || (this.opts.searchScope = 'sub');\n  this.opts.bindProperty || (this.opts.bindProperty = 'dn');\n  this.opts.groupSearchScope || (this.opts.groupSearchScope = 'sub');\n  this.opts.groupDnProperty || (this.opts.groupDnProperty = 'dn');\n\n  if (opts.cache) {\n    var Cache = require('./cache');\n    this.userCache = new Cache(100, 300, this.log, 'user');\n  }\n\n  this.clientOpts = {\n    url: opts.url,\n    connectTimeout: opts.connectTimeout,\n    timeout: opts.timeout,\n    tlsOptions: opts.tlsOptions,\n    maxConnections: opts.maxConnections,\n    bindDn: opts.bindDn || opts.adminDn,\n    bindCredentials: opts.bindCredentials || opts.Credentials || opts.adminPassword,\n    checkInterval: opts.checkInterval,\n    maxIdleTime: opts.maxIdleTime\n  };\n\n  if (opts.log4js && opts.verbose) {\n    this.clientOpts.log4js = opts.log4js;\n  }\n\n  this._adminClient = ldap.createClient(this.clientOpts);\n  this._adminBound = false;\n  this._userClient = ldap.createClient(this.clientOpts);\n\n  if (opts.cache) {\n    this._salt = bcrypt.genSaltSync();\n  }\n\n  if (opts.groupSearchBase && opts.groupSearchFilter) {\n    this._getGroups = this._findGroups;\n  } else {\n    // Assign an async identity function so there is no need to branch\n    // the authenticate function to have cache set up.\n    this._getGroups = function (user, callback) {\n      return callback(null, user);\n    }\n  }\n};\n\n\nLdapAuth.prototype.close = function (callback) {\n  var self = this;\n  // It seems to be OK just to call unbind regardless of if the\n  // client has been bound (e.g. how ldapjs pool destroy does)\n  self._adminClient.unbind(function(err) {\n    self._userClient.unbind(callback);\n  });\n};\n\n\n/**\n * Ensure that `this._adminClient` is bound.\n */\nLdapAuth.prototype._adminBind = function (callback) {\n  // Anonymous binding\n  if (typeof this.clientOpts.bindDn === 'undefined' || this.clientOpts.bindDn === null) {\n    return callback();\n  }\n  if (this._adminBound) {\n    return callback();\n  }\n  var self = this;\n  this._adminClient.bind(this.clientOpts.bindDn, this.clientOpts.bindCredentials,\n                         function (err) {\n    if (err) {\n      self.log && self.log.trace('ldap authenticate: bind error: %s', err);\n      return callback(err);\n    }\n    self._adminBound = true;\n    return callback();\n  });\n};\n\n/**\n * Conduct a search using the admin client. Used for fetching both\n * user and group information.\n *\n * @param searchBase {String} LDAP search base\n * @param options {Object} LDAP search options\n * @param {Function} `function (err, result)`.\n */\nLdapAuth.prototype._search = function (searchBase, options, callback) {\n  var self = this;\n\n  self._adminBind(function (err) {\n    if (err)\n      return callback(err);\n\n    self._adminClient.search(searchBase, options, function (err, result) {\n      if (err)\n        return callback(err);\n\n      var items = [];\n      result.on('searchEntry', function (entry) {\n        items.push(entry.object);\n        if (self.opts.includeRaw === true) {\n          items[items.length - 1]._raw = entry.raw;\n        }\n      });\n\n      result.on('error', callback);\n\n      result.on('end', function (result) {\n        if (result.status !== 0) {\n          var err = 'non-zero status from LDAP search: ' + result.status;\n          return callback(err);\n        }\n        return callback(null, items);\n      });\n    });\n  });\n};\n\n/**\n * Find the user record for the given username.\n *\n * @param username {String}\n * @param callback {Function} `function (err, user)`. If no such user is\n *    found but no error processing, then `user` is undefined.\n *\n */\nLdapAuth.prototype._findUser = function (username, callback) {\n  var self = this;\n  if (!username) {\n    return callback(\"empty username\");\n  }\n\n  var searchFilter = self.opts.searchFilter.replace(/{{username}}/g, username);\n  var opts = {filter: searchFilter, scope: self.opts.searchScope};\n  if (self.opts.searchAttributes) {\n    opts.attributes = self.opts.searchAttributes;\n  }\n\n  self._search(self.opts.searchBase, opts, function (err, result) {\n    if (err) {\n      self.log && self.log.trace('ldap authenticate: user search error: %s %s %s', err.code, err.name, err.message);\n      return callback(err);\n    }\n\n    switch (result.length) {\n    case 0:\n      return callback();\n    case 1:\n      return callback(null, result[0])\n    default:\n      return callback(format(\n        'unexpected number of matches (%s) for \"%s\" username',\n        result.length, username));\n    }\n  });\n};\n\nLdapAuth.prototype._findGroups = function(user, callback) {\n  var self = this;\n  if (!user) {\n    return callback(\"no user\");\n  }\n\n  var searchFilter = self.opts.groupSearchFilter.replace(/{{dn}}/g, user[self.opts.groupDnProperty]);\n  var opts = {filter: searchFilter, scope: self.opts.groupSearchScope};\n  if (self.opts.groupSearchAttributes) {\n    opts.attributes = self.opts.groupSearchAttributes;\n  }\n  self._search(self.opts.groupSearchBase, opts, function (err, result) {\n    if (err) {\n      self.log && self.log.trace('ldap authenticate: group search error: %s %s %s', err.code, err.name, err.message);\n      return callback(err);\n    }\n\n    user._groups = result;\n    callback(null, user);\n  });\n};\n\n/**\n *\n */\nLdapAuth.prototype.authenticate = function (username, password, callback) {\n  var self = this;\n\n  if (self.opts.cache) {\n    // Check cache. 'cached' is `{password: <hashed-password>, user: <user>}`.\n    var cached = self.userCache.get(username);\n    if (cached && bcrypt.compareSync(password, cached.password)) {\n      return callback(null, cached.user)\n    }\n  }\n\n  // 1. Find the user DN in question.\n  self._findUser(username, function (err, user) {\n    if (err)\n      return callback(err);\n    if (!user)\n      return callback(format('no such user: \"%s\"', username));\n\n    // 2. Attempt to bind as that user to check password.\n    self._userClient.bind(user[self.opts.bindProperty], password, function (err) {\n      if (err) {\n        self.log && self.log.trace('ldap authenticate: bind error: %s', err);\n        return callback(err);\n      }\n      // 3. If requested, fetch user groups\n      self._getGroups(user, function(err, user) {\n        if (err) {\n          self.log && self.log.trace('ldap authenticate: group search error %s', err);\n          return callback(err);\n        }\n        if (self.opts.cache) {\n          bcrypt.hash(password, self._salt, function (err, hash) {\n            self.userCache.set(username, {password: hash, user: user});\n            return callback(null, user);\n          });\n        } else {\n          return callback(null, user);\n        }\n      })\n    });\n  });\n};\n\n\n\nmodule.exports = LdapAuth;\n"], "fixing_code": ["# node-ldapauth-fork Changelog\n\n## 2.3.3\n\n- [issue #20] Sanitize user input\n\n## 2.3.2\n\n- [issue #19] Added messages to options asserts\n\n## 2.3.1\n\n- [issue #14] Use bcryptjs instead of the C++ version.\n\n## 2.3.0\n\n- [passport-ldapauth issue #10] Added support for fetching user groups. If `groupSearchBase` and `groupSearchFilter` are defined, a group search is conducted after the user has succesfully authenticated. The found groups are stored to `user._groups`:\n\n```javascript\nnew LdapAuth({\n  \"url\": \"ldaps://ldap.example.com:636\",\n  \"adminDn\": \"cn=LdapAdmin,dc=local\",\n  \"adminPassword\": \"LdapAdminPassword\",\n  \"searchBase\": \"dc=users,dc=local\",\n  \"searchFilter\": \"(&(objectClass=person)(sAMAccountName={{username}}))\",\n  \"searchAttributes\": [\n    \"dn\", \"cn\", \"givenName\", \"name\", \"memberOf\", \"sAMAccountName\"\n  ],\n  \"groupSearchBase\": \"dc=groups,dc=local\",\n  \"groupSearchFilter\": \"(member={{dn}})\",\n  \"groupSearchAttributes\": [\"dn\", \"cn\", \"sAMAccountName\"]\n});\n```\n\n## 2.2.19\n\n- [issue #9] Configurable bind parameter. Thanks to @oanuna\n\n## 2.2.18\n\n- [issue #8] Fix options to actually work as documented\n\n## 2.2.17\n\n- Added `bindCredentials` option. Now defaulting to same names as ldapjs.\n\n## 2.2.16\n\n- Added option `includeRaw` for including `entry.raw` to the returned object (relates to ldapjs issue #238)\n\n## 2.2.15\n\n- [issue #5] Handle missing bcrypt and throw a explanatory exception instead\n\n## 2.2.14\n\n- [issue #4] Log error properties code, name, and message instead of the object\n\n## 2.2.12\n\n- [issue #1] Add more ldapjs options\n\n## 2.2.11\n\n- [passport-ldapauth issue #3] Update to ldapjs 0.7.0 fixes unhandled errors when using anonymous binding\n\n## 2.2.10\n\n- Try to bind with empty `adminDn` string (undefined/null equals no admin bind)\n\n## 2.2.9\n\n- [ldapauth issue #13] bcrypt as an optional dependency\n\n## 2.2.8\n\n- [ldapauth issue #2] support anonymous binding\n- [ldapauth issue #3] unbind clients in `close()`\n- Added option `searchScope`, default to `sub`\n\n## 2.2.7\n\n- Renamed to node-ldapauth-fork\n\n## 2.2.6\n\n- Another readme fix\n\n## 2.2.5\n\n- Readme updated\n\n## 2.2.4\n\n- [ldapauth issues #11, #12] update to ldapjs 0.6.3\n- [ldapauth issue #10] use global search/replace for {{username}}\n- [ldapauth issue #8] enable defining attributes to fetch from LDAP server\n\n# node-ldapauth Changelog\n\n## 2.2.3 (not yet released)\n\n(nothing yet)\n\n\n## 2.2.2\n\n- [issue #5] update to bcrypt 0.7.5 (0.7.3 fixes potential mem issues)\n\n\n## 2.2.1\n\n- Fix a bug where ldapauth `authenticate()` would raise an example on an empty\n  username.\n\n\n## 2.2.0\n\n- Update to latest ldapjs (0.5.6) and other deps.\n  Note: This makes ldapauth only work with node >=0.8 (because of internal dep\n  in ldapjs 0.5).\n\n\n## 2.1.0\n\n- Update to ldapjs 0.4 (from 0.3). Crossing fingers that this doesn't cause breakage.\n\n\n## 2.0.0\n\n- Add `make check` for checking jsstyle.\n- [issue #1] Update to bcrypt 0.5. This means increasing the base node from 0.4\n  to 0.6, hence the major version bump.\n\n\n## 1.0.2\n\nFirst working version.\n\n\n", "/**\n * Copyright 2011 (c) Trent Mick.\n *\n * LDAP auth.\n *\n * Usage:\n *    var LdapAuth = require('ldapauth');\n *    var auth = new LdapAuth({url: 'ldaps://ldap.example.com:636', ...});\n *    ...\n *    auth.authenticate(username, password, function (err, user) { ... });\n *    ...\n *    auth.close(function (err) { ... })\n */\n\nvar assert = require('assert');\nvar ldap = require('ldapjs');\nvar debug = console.warn;\nvar format = require('util').format;\nvar bcrypt = require('bcryptjs');\n\n\n/**\n * Create an LDAP auth class. Primary usage is the `.authenticate` method.\n *\n * @param opts {Object} Config options. Keys (required, unless says\n *      otherwise) are:\n *    url {String}\n *        E.g. 'ldaps://ldap.example.com:663'\n *    bindDn {String}\n *        Optional, e.g. 'uid=myapp,ou=users,o=example.com'. Alias: adminDn\n *    bindCredentials {String}\n *        Password for bindDn. Aliases: Credentials, adminPassword\n *    bindProperty {String}\n *        Optional, default 'dn'. Property of user to bind against client\n *        e.g. 'name', 'email'\n *    searchBase {String}\n *        The base DN from which to search for users by username.\n *         E.g. 'ou=users,o=example.com'\n *    searchScope {String}\n *        Optional, default 'sub'. Scope of the search, one of 'base',\n *        'one', or 'sub'.\n *    searchFilter {String}\n *        LDAP search filter with which to find a user by username, e.g.\n *        '(uid={{username}})'. Use the literal '{{username}}' to have the\n *        given username be interpolated in for the LDAP search.\n *    searchAttributes {Array}\n *        Optional, default all. Array of attributes to fetch from LDAP server.\n *    groupDnProperty {String}\n *        Optional, default 'dn'. The property of user object to use in\n *        '{{dn}}' interpolation of groupSearchFilter.\n *    groupSearchBase {String}\n *        Optional. The base DN from which to search for groups. If defined,\n *        also groupSearchFilter must be defined for the search to work.\n *    groupSearchScope {String}\n *        Optional, default 'sub'.\n *    groupSearchFilter {String}\n *        Optional. LDAP search filter for groups. The following literals are\n *        interpolated from the found user object: '{{dn}}' the property\n *        configured with groupDnProperty.\n *    groupSearchAttributes {Array}\n *        Optional, default all. Array of attributes to fetch from LDAP server.\n *    log4js {Module}\n *        Optional. The require'd log4js module to use for logging. If given\n *        this will result in TRACE-level logging for ldapauth.\n *    verbose {Boolean}\n *        Optional, default false. If `log4js` is also given, this will add\n *        TRACE-level logging for ldapjs (quite verbose).\n *    cache {Boolean}\n *        Optional, default false. If true, then up to 100 credentials at a\n *        time will be cached for 5 minutes.\n *    timeout {Integer}\n *        Optional, default Infinity. How long the client should let\n *        operations live for before timing out.\n *    connectTimeout {Integer}\n *        Optional, default is up to the OS. How long the client should wait\n *        before timing out on TCP connections.\n *    tlsOptions {Object}\n *        Additional options passed to the TLS connection layer when\n *        connecting via ldaps://. See\n *        http://nodejs.org/api/tls.html#tls_tls_connect_options_callback\n *        for available options\n *    maxConnections {Integer}\n *        Whether or not to enable connection pooling, and if so, how many to\n *        maintain.\n *    checkInterval {Integer}\n *        How often to schedule health checks for the connection pool.\n *    maxIdleTime {Integer}\n *        How long a client can be idle before health-checking the connection\n *        (subject to the checkInterval frequency)\n *    includeRaw {boolean}\n *        Optional, default false. Set to true to add property '_raw'\n *        containing the original buffers to the returned user object.\n *        Useful when you need to handle binary attributes.\n */\nfunction LdapAuth(opts) {\n  this.opts = opts;\n  assert.ok(opts.url, 'LDAP server URL not defined (opts.url)');\n  assert.ok(opts.searchBase, 'Search base not defined (opts.searchBase)');\n  assert.ok(opts.searchFilter, 'Search filter not defined (opts.searchFilter)');\n\n  this.log = opts.log4js && opts.log4js.getLogger('ldapauth');\n\n  this.opts.searchScope || (this.opts.searchScope = 'sub');\n  this.opts.bindProperty || (this.opts.bindProperty = 'dn');\n  this.opts.groupSearchScope || (this.opts.groupSearchScope = 'sub');\n  this.opts.groupDnProperty || (this.opts.groupDnProperty = 'dn');\n\n  if (opts.cache) {\n    var Cache = require('./cache');\n    this.userCache = new Cache(100, 300, this.log, 'user');\n  }\n\n  this.clientOpts = {\n    url: opts.url,\n    connectTimeout: opts.connectTimeout,\n    timeout: opts.timeout,\n    tlsOptions: opts.tlsOptions,\n    maxConnections: opts.maxConnections,\n    bindDn: opts.bindDn || opts.adminDn,\n    bindCredentials: opts.bindCredentials || opts.Credentials || opts.adminPassword,\n    checkInterval: opts.checkInterval,\n    maxIdleTime: opts.maxIdleTime\n  };\n\n  if (opts.log4js && opts.verbose) {\n    this.clientOpts.log4js = opts.log4js;\n  }\n\n  this._adminClient = ldap.createClient(this.clientOpts);\n  this._adminBound = false;\n  this._userClient = ldap.createClient(this.clientOpts);\n\n  if (opts.cache) {\n    this._salt = bcrypt.genSaltSync();\n  }\n\n  if (opts.groupSearchBase && opts.groupSearchFilter) {\n    this._getGroups = this._findGroups;\n  } else {\n    // Assign an async identity function so there is no need to branch\n    // the authenticate function to have cache set up.\n    this._getGroups = function (user, callback) {\n      return callback(null, user);\n    }\n  }\n};\n\n\nLdapAuth.prototype.close = function (callback) {\n  var self = this;\n  // It seems to be OK just to call unbind regardless of if the\n  // client has been bound (e.g. how ldapjs pool destroy does)\n  self._adminClient.unbind(function(err) {\n    self._userClient.unbind(callback);\n  });\n};\n\n\n/**\n * Ensure that `this._adminClient` is bound.\n */\nLdapAuth.prototype._adminBind = function (callback) {\n  // Anonymous binding\n  if (typeof this.clientOpts.bindDn === 'undefined' || this.clientOpts.bindDn === null) {\n    return callback();\n  }\n  if (this._adminBound) {\n    return callback();\n  }\n  var self = this;\n  this._adminClient.bind(this.clientOpts.bindDn, this.clientOpts.bindCredentials,\n                         function (err) {\n    if (err) {\n      self.log && self.log.trace('ldap authenticate: bind error: %s', err);\n      return callback(err);\n    }\n    self._adminBound = true;\n    return callback();\n  });\n};\n\n/**\n * Conduct a search using the admin client. Used for fetching both\n * user and group information.\n *\n * @param searchBase {String} LDAP search base\n * @param options {Object} LDAP search options\n * @param {Function} `function (err, result)`.\n */\nLdapAuth.prototype._search = function (searchBase, options, callback) {\n  var self = this;\n\n  self._adminBind(function (err) {\n    if (err)\n      return callback(err);\n\n    self._adminClient.search(searchBase, options, function (err, result) {\n      if (err)\n        return callback(err);\n\n      var items = [];\n      result.on('searchEntry', function (entry) {\n        items.push(entry.object);\n        if (self.opts.includeRaw === true) {\n          items[items.length - 1]._raw = entry.raw;\n        }\n      });\n\n      result.on('error', callback);\n\n      result.on('end', function (result) {\n        if (result.status !== 0) {\n          var err = 'non-zero status from LDAP search: ' + result.status;\n          return callback(err);\n        }\n        return callback(null, items);\n      });\n    });\n  });\n};\n\n// https://tools.ietf.org/search/rfc4515#section-3\nvar sanitizeInput = function (username) {\n  return username\n    .replace(/\\*/g, '\\\\2a')\n    .replace(/\\(/g, '\\\\28')\n    .replace(/\\)/g, '\\\\29')\n    .replace(/\\\\/g, '\\\\5c')\n    .replace(/\\0/g, '\\\\00')\n    .replace(/\\//g, '\\\\2f');\n};\n\n/**\n * Find the user record for the given username.\n *\n * @param username {String}\n * @param callback {Function} `function (err, user)`. If no such user is\n *    found but no error processing, then `user` is undefined.\n *\n */\nLdapAuth.prototype._findUser = function (username, callback) {\n  var self = this;\n  if (!username) {\n    return callback(\"empty username\");\n  }\n\n  var searchFilter = self.opts.searchFilter.replace(/{{username}}/g, sanitizeInput(username));\n  var opts = {filter: searchFilter, scope: self.opts.searchScope};\n  if (self.opts.searchAttributes) {\n    opts.attributes = self.opts.searchAttributes;\n  }\n\n  self._search(self.opts.searchBase, opts, function (err, result) {\n    if (err) {\n      self.log && self.log.trace('ldap authenticate: user search error: %s %s %s', err.code, err.name, err.message);\n      return callback(err);\n    }\n\n    switch (result.length) {\n    case 0:\n      return callback();\n    case 1:\n      return callback(null, result[0])\n    default:\n      return callback(format(\n        'unexpected number of matches (%s) for \"%s\" username',\n        result.length, username));\n    }\n  });\n};\n\nLdapAuth.prototype._findGroups = function(user, callback) {\n  var self = this;\n  if (!user) {\n    return callback(\"no user\");\n  }\n\n  var searchFilter = self.opts.groupSearchFilter.replace(/{{dn}}/g, user[self.opts.groupDnProperty]);\n  var opts = {filter: searchFilter, scope: self.opts.groupSearchScope};\n  if (self.opts.groupSearchAttributes) {\n    opts.attributes = self.opts.groupSearchAttributes;\n  }\n  self._search(self.opts.groupSearchBase, opts, function (err, result) {\n    if (err) {\n      self.log && self.log.trace('ldap authenticate: group search error: %s %s %s', err.code, err.name, err.message);\n      return callback(err);\n    }\n\n    user._groups = result;\n    callback(null, user);\n  });\n};\n\n/**\n *\n */\nLdapAuth.prototype.authenticate = function (username, password, callback) {\n  var self = this;\n\n  if (self.opts.cache) {\n    // Check cache. 'cached' is `{password: <hashed-password>, user: <user>}`.\n    var cached = self.userCache.get(username);\n    if (cached && bcrypt.compareSync(password, cached.password)) {\n      return callback(null, cached.user)\n    }\n  }\n\n  // 1. Find the user DN in question.\n  self._findUser(username, function (err, user) {\n    if (err)\n      return callback(err);\n    if (!user)\n      return callback(format('no such user: \"%s\"', username));\n\n    // 2. Attempt to bind as that user to check password.\n    self._userClient.bind(user[self.opts.bindProperty], password, function (err) {\n      if (err) {\n        self.log && self.log.trace('ldap authenticate: bind error: %s', err);\n        return callback(err);\n      }\n      // 3. If requested, fetch user groups\n      self._getGroups(user, function(err, user) {\n        if (err) {\n          self.log && self.log.trace('ldap authenticate: group search error %s', err);\n          return callback(err);\n        }\n        if (self.opts.cache) {\n          bcrypt.hash(password, self._salt, function (err, hash) {\n            self.userCache.set(username, {password: hash, user: user});\n            return callback(null, user);\n          });\n        } else {\n          return callback(null, user);\n        }\n      })\n    });\n  });\n};\n\n\n\nmodule.exports = LdapAuth;\n"], "filenames": ["CHANGES.md", "lib/ldapauth.js"], "buggy_code_start_loc": [1, 221], "buggy_code_end_loc": [1, 237], "fixing_code_start_loc": [2, 222], "fixing_code_end_loc": [6, 248], "type": "CWE-90", "message": "ldapauth-fork before 2.3.3 allows remote attackers to perform LDAP injection attacks via a crafted username.", "other": {"cve": {"id": "CVE-2015-7294", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-06T21:29:01.037", "lastModified": "2020-03-09T18:39:43.000", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ldapauth-fork before 2.3.3 allows remote attackers to perform LDAP injection attacks via a crafted username."}, {"lang": "es", "value": "ldapauth-fork en versiones anteriores a la 2.3.3 permite que atacantes remotos realicen ataques de inyecci\u00f3n LDAP utilizando un nombre de usuario manipulado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-90"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ldapauth-fork_project:ldapauth-fork:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "2.3.3", "matchCriteriaId": "ED0696C2-E544-4808-A58D-FB5C582C6F5B"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2015/09/18/8", "source": "cve@mitre.org", "tags": ["Mailing List", "VDB Entry"]}, {"url": "http://www.openwall.com/lists/oss-security/2015/09/21/2", "source": "cve@mitre.org", "tags": ["Mailing List", "VDB Entry"]}, {"url": "https://github.com/vesse/node-ldapauth-fork/commit/3feea43e243698bcaeffa904a7324f4d96df60e4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/vesse/node-ldapauth-fork/issues/21", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vesse/node-ldapauth-fork/commit/3feea43e243698bcaeffa904a7324f4d96df60e4"}}