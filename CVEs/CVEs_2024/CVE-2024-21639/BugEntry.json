{"buggy_code": ["// Copyright 2019 The Chromium Embedded Framework Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"libcef/browser/osr/host_display_client_osr.h\"\n\n#include <utility>\n\n#include \"libcef/browser/osr/render_widget_host_view_osr.h\"\n\n#include \"base/memory/shared_memory_mapping.h\"\n#include \"components/viz/common/resources/resource_sizes.h\"\n#include \"mojo/public/cpp/system/platform_handle.h\"\n#include \"services/viz/privileged/mojom/compositing/layered_window_updater.mojom.h\"\n#include \"skia/ext/platform_canvas.h\"\n#include \"third_party/skia/include/core/SkColor.h\"\n#include \"third_party/skia/include/core/SkRect.h\"\n#include \"third_party/skia/src/core/SkDevice.h\"\n#include \"ui/gfx/skia_util.h\"\n\n#if BUILDFLAG(IS_WIN)\n#include \"skia/ext/skia_utils_win.h\"\n#endif\n\nclass CefLayeredWindowUpdaterOSR : public viz::mojom::LayeredWindowUpdater {\n public:\n  CefLayeredWindowUpdaterOSR(\n      CefRenderWidgetHostViewOSR* const view,\n      mojo::PendingReceiver<viz::mojom::LayeredWindowUpdater> receiver);\n\n  CefLayeredWindowUpdaterOSR(const CefLayeredWindowUpdaterOSR&) = delete;\n  CefLayeredWindowUpdaterOSR& operator=(const CefLayeredWindowUpdaterOSR&) =\n      delete;\n\n  ~CefLayeredWindowUpdaterOSR() override;\n\n  void SetActive(bool active);\n  const void* GetPixelMemory() const;\n  gfx::Size GetPixelSize() const;\n\n  // viz::mojom::LayeredWindowUpdater implementation.\n  void OnAllocatedSharedMemory(const gfx::Size& pixel_size,\n                               base::UnsafeSharedMemoryRegion region) override;\n  void Draw(const gfx::Rect& damage_rect, DrawCallback draw_callback) override;\n\n private:\n  CefRenderWidgetHostViewOSR* const view_;\n  mojo::Receiver<viz::mojom::LayeredWindowUpdater> receiver_;\n  bool active_ = false;\n  base::WritableSharedMemoryMapping shared_memory_;\n  gfx::Size pixel_size_;\n};\n\nCefLayeredWindowUpdaterOSR::CefLayeredWindowUpdaterOSR(\n    CefRenderWidgetHostViewOSR* const view,\n    mojo::PendingReceiver<viz::mojom::LayeredWindowUpdater> receiver)\n    : view_(view), receiver_(this, std::move(receiver)) {}\n\nCefLayeredWindowUpdaterOSR::~CefLayeredWindowUpdaterOSR() = default;\n\nvoid CefLayeredWindowUpdaterOSR::SetActive(bool active) {\n  active_ = active;\n}\n\nconst void* CefLayeredWindowUpdaterOSR::GetPixelMemory() const {\n  return shared_memory_.memory();\n}\n\ngfx::Size CefLayeredWindowUpdaterOSR::GetPixelSize() const {\n  return pixel_size_;\n}\n\nvoid CefLayeredWindowUpdaterOSR::OnAllocatedSharedMemory(\n    const gfx::Size& pixel_size,\n    base::UnsafeSharedMemoryRegion region) {\n  // Make sure |pixel_size| is sane.\n  size_t expected_bytes;\n  bool size_result = viz::ResourceSizes::MaybeSizeInBytes(\n      pixel_size, viz::SinglePlaneFormat::kRGBA_8888, &expected_bytes);\n  if (!size_result) {\n    return;\n  }\n\n  pixel_size_ = pixel_size;\n  shared_memory_ = region.Map();\n  DCHECK(shared_memory_.IsValid());\n}\n\nvoid CefLayeredWindowUpdaterOSR::Draw(const gfx::Rect& damage_rect,\n                                      DrawCallback draw_callback) {\n  if (active_) {\n    const void* memory = GetPixelMemory();\n    if (memory) {\n      view_->OnPaint(damage_rect, pixel_size_, memory);\n    } else {\n      LOG(WARNING) << \"Failed to read pixels\";\n    }\n  }\n\n  std::move(draw_callback).Run();\n}\n\nCefHostDisplayClientOSR::CefHostDisplayClientOSR(\n    CefRenderWidgetHostViewOSR* const view,\n    gfx::AcceleratedWidget widget)\n    : viz::HostDisplayClient(widget), view_(view) {}\n\nCefHostDisplayClientOSR::~CefHostDisplayClientOSR() {}\n\nvoid CefHostDisplayClientOSR::SetActive(bool active) {\n  active_ = active;\n  if (layered_window_updater_) {\n    layered_window_updater_->SetActive(active_);\n  }\n}\n\nconst void* CefHostDisplayClientOSR::GetPixelMemory() const {\n  return layered_window_updater_ ? layered_window_updater_->GetPixelMemory()\n                                 : nullptr;\n}\n\ngfx::Size CefHostDisplayClientOSR::GetPixelSize() const {\n  return layered_window_updater_ ? layered_window_updater_->GetPixelSize()\n                                 : gfx::Size{};\n}\n\nvoid CefHostDisplayClientOSR::UseProxyOutputDevice(\n    UseProxyOutputDeviceCallback callback) {\n  std::move(callback).Run(true);\n}\n\nvoid CefHostDisplayClientOSR::CreateLayeredWindowUpdater(\n    mojo::PendingReceiver<viz::mojom::LayeredWindowUpdater> receiver) {\n  layered_window_updater_ =\n      std::make_unique<CefLayeredWindowUpdaterOSR>(view_, std::move(receiver));\n  layered_window_updater_->SetActive(active_);\n}\n\n#if BUILDFLAG(IS_LINUX)\nvoid CefHostDisplayClientOSR::DidCompleteSwapWithNewSize(\n    const gfx::Size& size) {}\n#endif\n", "// Copyright (c) 2015 GitHub, Inc.\n// Use of this source code is governed by the MIT license that can be\n// found in the LICENSE file.\n\n#include \"libcef/browser/osr/video_consumer_osr.h\"\n\n#include \"libcef/browser/osr/render_widget_host_view_osr.h\"\n\n#include \"media/base/video_frame_metadata.h\"\n#include \"media/capture/mojom/video_capture_buffer.mojom.h\"\n#include \"media/capture/mojom/video_capture_types.mojom.h\"\n#include \"ui/gfx/skbitmap_operations.h\"\n\nnamespace {\n\n// Helper to always call Done() at the end of OnFrameCaptured().\nclass ScopedVideoFrameDone {\n public:\n  explicit ScopedVideoFrameDone(\n      mojo::PendingRemote<viz::mojom::FrameSinkVideoConsumerFrameCallbacks>\n          callbacks)\n      : callbacks_(std::move(callbacks)) {}\n  ~ScopedVideoFrameDone() { callbacks_->Done(); }\n\n private:\n  mojo::Remote<viz::mojom::FrameSinkVideoConsumerFrameCallbacks> callbacks_;\n};\n\n}  // namespace\n\nCefVideoConsumerOSR::CefVideoConsumerOSR(CefRenderWidgetHostViewOSR* view)\n    : view_(view), video_capturer_(view->CreateVideoCapturer()) {\n  video_capturer_->SetFormat(media::PIXEL_FORMAT_ARGB);\n\n  // Always use the highest resolution within constraints that doesn't exceed\n  // the source size.\n  video_capturer_->SetAutoThrottlingEnabled(false);\n  video_capturer_->SetMinSizeChangePeriod(base::TimeDelta());\n\n  SizeChanged(view_->SizeInPixels());\n  SetActive(true);\n}\n\nCefVideoConsumerOSR::~CefVideoConsumerOSR() = default;\n\nvoid CefVideoConsumerOSR::SetActive(bool active) {\n  if (active) {\n    video_capturer_->Start(this, viz::mojom::BufferFormatPreference::kDefault);\n  } else {\n    video_capturer_->Stop();\n  }\n}\n\nvoid CefVideoConsumerOSR::SetFrameRate(base::TimeDelta frame_rate) {\n  video_capturer_->SetMinCapturePeriod(frame_rate);\n}\n\nvoid CefVideoConsumerOSR::SizeChanged(const gfx::Size& size_in_pixels) {\n  if (size_in_pixels_ == size_in_pixels) {\n    return;\n  }\n  size_in_pixels_ = size_in_pixels;\n\n  // Capture resolution will be held constant.\n  video_capturer_->SetResolutionConstraints(size_in_pixels, size_in_pixels,\n                                            true /* use_fixed_aspect_ratio */);\n}\n\nvoid CefVideoConsumerOSR::RequestRefreshFrame(\n    const absl::optional<gfx::Rect>& bounds_in_pixels) {\n  bounds_in_pixels_ = bounds_in_pixels;\n  video_capturer_->RequestRefreshFrame();\n}\n\n// Frame size values are as follows:\n//   info->coded_size = Width and height of the video frame. Not all pixels in\n//   this region are valid.\n//   info->visible_rect = Region of coded_size that contains image data, also\n//   known as the clean aperture.\n//   content_rect = Region of the frame that contains the captured content, with\n//   the rest of the frame having been letterboxed to adhere to resolution\n//   constraints.\nvoid CefVideoConsumerOSR::OnFrameCaptured(\n    media::mojom::VideoBufferHandlePtr data,\n    media::mojom::VideoFrameInfoPtr info,\n    const gfx::Rect& content_rect,\n    mojo::PendingRemote<viz::mojom::FrameSinkVideoConsumerFrameCallbacks>\n        callbacks) {\n  ScopedVideoFrameDone scoped_done(std::move(callbacks));\n\n  CHECK(data->is_read_only_shmem_region());\n  base::ReadOnlySharedMemoryRegion& shmem_region =\n      data->get_read_only_shmem_region();\n\n  // The |data| parameter is not nullable and mojo type mapping for\n  // `base::ReadOnlySharedMemoryRegion` defines that nullable version of it is\n  // the same type, with null check being equivalent to IsValid() check. Given\n  // the above, we should never be able to receive a read only shmem region that\n  // is not valid - mojo will enforce it for us.\n  DCHECK(shmem_region.IsValid());\n\n  base::ReadOnlySharedMemoryMapping mapping = shmem_region.Map();\n  if (!mapping.IsValid()) {\n    DLOG(ERROR) << \"Shared memory mapping failed.\";\n    return;\n  }\n  if (mapping.size() <\n      media::VideoFrame::AllocationSize(info->pixel_format, info->coded_size)) {\n    DLOG(ERROR) << \"Shared memory size was less than expected.\";\n    return;\n  }\n\n  // The SkBitmap's pixels will be marked as immutable, but the installPixels()\n  // API requires a non-const pointer. So, cast away the const.\n  void* const pixels = const_cast<void*>(mapping.memory());\n\n  media::VideoFrameMetadata metadata = info->metadata;\n  gfx::Rect damage_rect;\n\n  if (bounds_in_pixels_) {\n    // Use the bounds passed to RequestRefreshFrame().\n    damage_rect = gfx::Rect(info->coded_size);\n    damage_rect.Intersect(*bounds_in_pixels_);\n    bounds_in_pixels_ = absl::nullopt;\n  } else {\n    // Retrieve the rectangular region of the frame that has changed since the\n    // frame with the directly preceding CAPTURE_COUNTER. If that frame was not\n    // received, typically because it was dropped during transport from the\n    // producer, clients must assume that the entire frame has changed.\n    // This rectangle is relative to the full frame data, i.e. [0, 0,\n    // coded_size.width(), coded_size.height()]. It does not have to be\n    // fully contained within visible_rect.\n    if (metadata.capture_update_rect) {\n      damage_rect = *metadata.capture_update_rect;\n    }\n    if (damage_rect.IsEmpty()) {\n      damage_rect = gfx::Rect(info->coded_size);\n    }\n  }\n\n  view_->OnPaint(damage_rect, info->coded_size, pixels);\n}\n"], "fixing_code": ["// Copyright 2019 The Chromium Embedded Framework Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"libcef/browser/osr/host_display_client_osr.h\"\n\n#include <utility>\n\n#include \"libcef/browser/osr/render_widget_host_view_osr.h\"\n\n#include \"base/memory/shared_memory_mapping.h\"\n#include \"components/viz/common/resources/resource_sizes.h\"\n#include \"mojo/public/cpp/system/platform_handle.h\"\n#include \"services/viz/privileged/mojom/compositing/layered_window_updater.mojom.h\"\n#include \"skia/ext/platform_canvas.h\"\n#include \"third_party/skia/include/core/SkColor.h\"\n#include \"third_party/skia/include/core/SkRect.h\"\n#include \"third_party/skia/src/core/SkDevice.h\"\n#include \"ui/gfx/skia_util.h\"\n\n#if BUILDFLAG(IS_WIN)\n#include \"skia/ext/skia_utils_win.h\"\n#endif\n\nclass CefLayeredWindowUpdaterOSR : public viz::mojom::LayeredWindowUpdater {\n public:\n  CefLayeredWindowUpdaterOSR(\n      CefRenderWidgetHostViewOSR* const view,\n      mojo::PendingReceiver<viz::mojom::LayeredWindowUpdater> receiver);\n\n  CefLayeredWindowUpdaterOSR(const CefLayeredWindowUpdaterOSR&) = delete;\n  CefLayeredWindowUpdaterOSR& operator=(const CefLayeredWindowUpdaterOSR&) =\n      delete;\n\n  ~CefLayeredWindowUpdaterOSR() override;\n\n  void SetActive(bool active);\n  const void* GetPixelMemory() const;\n  gfx::Size GetPixelSize() const;\n\n  // viz::mojom::LayeredWindowUpdater implementation.\n  void OnAllocatedSharedMemory(const gfx::Size& pixel_size,\n                               base::UnsafeSharedMemoryRegion region) override;\n  void Draw(const gfx::Rect& damage_rect, DrawCallback draw_callback) override;\n\n private:\n  CefRenderWidgetHostViewOSR* const view_;\n  mojo::Receiver<viz::mojom::LayeredWindowUpdater> receiver_;\n  bool active_ = false;\n  base::WritableSharedMemoryMapping shared_memory_;\n  gfx::Size pixel_size_;\n};\n\nCefLayeredWindowUpdaterOSR::CefLayeredWindowUpdaterOSR(\n    CefRenderWidgetHostViewOSR* const view,\n    mojo::PendingReceiver<viz::mojom::LayeredWindowUpdater> receiver)\n    : view_(view), receiver_(this, std::move(receiver)) {}\n\nCefLayeredWindowUpdaterOSR::~CefLayeredWindowUpdaterOSR() = default;\n\nvoid CefLayeredWindowUpdaterOSR::SetActive(bool active) {\n  active_ = active;\n}\n\nconst void* CefLayeredWindowUpdaterOSR::GetPixelMemory() const {\n  return shared_memory_.memory();\n}\n\ngfx::Size CefLayeredWindowUpdaterOSR::GetPixelSize() const {\n  return pixel_size_;\n}\n\nvoid CefLayeredWindowUpdaterOSR::OnAllocatedSharedMemory(\n    const gfx::Size& pixel_size,\n    base::UnsafeSharedMemoryRegion region) {\n  // Make sure |pixel_size| is sane.\n  size_t expected_bytes;\n  if (!viz::ResourceSizes::MaybeSizeInBytes(\n          pixel_size, viz::SinglePlaneFormat::kRGBA_8888, &expected_bytes)) {\n    DLOG(ERROR) << \"OnAllocatedSharedMemory with size that overflows\";\n    return;\n  }\n\n  auto mapping = region.Map();\n  if (!mapping.IsValid()) {\n    DLOG(ERROR) << \"Shared memory mapping failed.\";\n    return;\n  }\n  if (mapping.size() < expected_bytes) {\n    DLOG(ERROR) << \"Shared memory size was less than expected.\";\n    return;\n  }\n\n  pixel_size_ = pixel_size;\n  shared_memory_ = std::move(mapping);\n}\n\nvoid CefLayeredWindowUpdaterOSR::Draw(const gfx::Rect& damage_rect,\n                                      DrawCallback draw_callback) {\n  if (active_) {\n    const void* memory = GetPixelMemory();\n    if (memory) {\n      view_->OnPaint(damage_rect, pixel_size_, memory);\n    } else {\n      LOG(WARNING) << \"Failed to read pixels\";\n    }\n  }\n\n  std::move(draw_callback).Run();\n}\n\nCefHostDisplayClientOSR::CefHostDisplayClientOSR(\n    CefRenderWidgetHostViewOSR* const view,\n    gfx::AcceleratedWidget widget)\n    : viz::HostDisplayClient(widget), view_(view) {}\n\nCefHostDisplayClientOSR::~CefHostDisplayClientOSR() {}\n\nvoid CefHostDisplayClientOSR::SetActive(bool active) {\n  active_ = active;\n  if (layered_window_updater_) {\n    layered_window_updater_->SetActive(active_);\n  }\n}\n\nconst void* CefHostDisplayClientOSR::GetPixelMemory() const {\n  return layered_window_updater_ ? layered_window_updater_->GetPixelMemory()\n                                 : nullptr;\n}\n\ngfx::Size CefHostDisplayClientOSR::GetPixelSize() const {\n  return layered_window_updater_ ? layered_window_updater_->GetPixelSize()\n                                 : gfx::Size{};\n}\n\nvoid CefHostDisplayClientOSR::UseProxyOutputDevice(\n    UseProxyOutputDeviceCallback callback) {\n  std::move(callback).Run(true);\n}\n\nvoid CefHostDisplayClientOSR::CreateLayeredWindowUpdater(\n    mojo::PendingReceiver<viz::mojom::LayeredWindowUpdater> receiver) {\n  layered_window_updater_ =\n      std::make_unique<CefLayeredWindowUpdaterOSR>(view_, std::move(receiver));\n  layered_window_updater_->SetActive(active_);\n}\n\n#if BUILDFLAG(IS_LINUX)\nvoid CefHostDisplayClientOSR::DidCompleteSwapWithNewSize(\n    const gfx::Size& size) {}\n#endif\n", "// Copyright (c) 2015 GitHub, Inc.\n// Use of this source code is governed by the MIT license that can be\n// found in the LICENSE file.\n\n#include \"libcef/browser/osr/video_consumer_osr.h\"\n\n#include \"libcef/browser/osr/render_widget_host_view_osr.h\"\n\n#include \"media/base/video_frame_metadata.h\"\n#include \"media/capture/mojom/video_capture_buffer.mojom.h\"\n#include \"media/capture/mojom/video_capture_types.mojom.h\"\n#include \"ui/gfx/skbitmap_operations.h\"\n\nnamespace {\n\n// Helper to always call Done() at the end of OnFrameCaptured().\nclass ScopedVideoFrameDone {\n public:\n  explicit ScopedVideoFrameDone(\n      mojo::PendingRemote<viz::mojom::FrameSinkVideoConsumerFrameCallbacks>\n          callbacks)\n      : callbacks_(std::move(callbacks)) {}\n  ~ScopedVideoFrameDone() { callbacks_->Done(); }\n\n private:\n  mojo::Remote<viz::mojom::FrameSinkVideoConsumerFrameCallbacks> callbacks_;\n};\n\n}  // namespace\n\nCefVideoConsumerOSR::CefVideoConsumerOSR(CefRenderWidgetHostViewOSR* view)\n    : view_(view), video_capturer_(view->CreateVideoCapturer()) {\n  video_capturer_->SetFormat(media::PIXEL_FORMAT_ARGB);\n\n  // Always use the highest resolution within constraints that doesn't exceed\n  // the source size.\n  video_capturer_->SetAutoThrottlingEnabled(false);\n  video_capturer_->SetMinSizeChangePeriod(base::TimeDelta());\n\n  SizeChanged(view_->SizeInPixels());\n  SetActive(true);\n}\n\nCefVideoConsumerOSR::~CefVideoConsumerOSR() = default;\n\nvoid CefVideoConsumerOSR::SetActive(bool active) {\n  if (active) {\n    video_capturer_->Start(this, viz::mojom::BufferFormatPreference::kDefault);\n  } else {\n    video_capturer_->Stop();\n  }\n}\n\nvoid CefVideoConsumerOSR::SetFrameRate(base::TimeDelta frame_rate) {\n  video_capturer_->SetMinCapturePeriod(frame_rate);\n}\n\nvoid CefVideoConsumerOSR::SizeChanged(const gfx::Size& size_in_pixels) {\n  if (size_in_pixels_ == size_in_pixels) {\n    return;\n  }\n  size_in_pixels_ = size_in_pixels;\n\n  // Capture resolution will be held constant.\n  video_capturer_->SetResolutionConstraints(size_in_pixels, size_in_pixels,\n                                            true /* use_fixed_aspect_ratio */);\n}\n\nvoid CefVideoConsumerOSR::RequestRefreshFrame(\n    const absl::optional<gfx::Rect>& bounds_in_pixels) {\n  bounds_in_pixels_ = bounds_in_pixels;\n  video_capturer_->RequestRefreshFrame();\n}\n\n// Frame size values are as follows:\n//   info->coded_size = Width and height of the video frame. Not all pixels in\n//   this region are valid.\n//   info->visible_rect = Region of coded_size that contains image data, also\n//   known as the clean aperture.\n//   content_rect = Region of the frame that contains the captured content, with\n//   the rest of the frame having been letterboxed to adhere to resolution\n//   constraints.\nvoid CefVideoConsumerOSR::OnFrameCaptured(\n    media::mojom::VideoBufferHandlePtr data,\n    media::mojom::VideoFrameInfoPtr info,\n    const gfx::Rect& content_rect,\n    mojo::PendingRemote<viz::mojom::FrameSinkVideoConsumerFrameCallbacks>\n        callbacks) {\n  ScopedVideoFrameDone scoped_done(std::move(callbacks));\n\n  if (info->pixel_format != media::PIXEL_FORMAT_ARGB) {\n    DLOG(ERROR) << \"Unsupported pixel format \" << info->pixel_format;\n    return;\n  }\n\n  CHECK(data->is_read_only_shmem_region());\n  base::ReadOnlySharedMemoryRegion& shmem_region =\n      data->get_read_only_shmem_region();\n\n  // The |data| parameter is not nullable and mojo type mapping for\n  // `base::ReadOnlySharedMemoryRegion` defines that nullable version of it is\n  // the same type, with null check being equivalent to IsValid() check. Given\n  // the above, we should never be able to receive a read only shmem region that\n  // is not valid - mojo will enforce it for us.\n  DCHECK(shmem_region.IsValid());\n\n  base::ReadOnlySharedMemoryMapping mapping = shmem_region.Map();\n  if (!mapping.IsValid()) {\n    DLOG(ERROR) << \"Shared memory mapping failed.\";\n    return;\n  }\n  if (mapping.size() <\n      media::VideoFrame::AllocationSize(info->pixel_format, info->coded_size)) {\n    DLOG(ERROR) << \"Shared memory size was less than expected.\";\n    return;\n  }\n\n  // The SkBitmap's pixels will be marked as immutable, but the installPixels()\n  // API requires a non-const pointer. So, cast away the const.\n  void* const pixels = const_cast<void*>(mapping.memory());\n\n  media::VideoFrameMetadata metadata = info->metadata;\n  gfx::Rect damage_rect;\n\n  if (bounds_in_pixels_) {\n    // Use the bounds passed to RequestRefreshFrame().\n    damage_rect = gfx::Rect(info->coded_size);\n    damage_rect.Intersect(*bounds_in_pixels_);\n    bounds_in_pixels_ = absl::nullopt;\n  } else {\n    // Retrieve the rectangular region of the frame that has changed since the\n    // frame with the directly preceding CAPTURE_COUNTER. If that frame was not\n    // received, typically because it was dropped during transport from the\n    // producer, clients must assume that the entire frame has changed.\n    // This rectangle is relative to the full frame data, i.e. [0, 0,\n    // coded_size.width(), coded_size.height()]. It does not have to be\n    // fully contained within visible_rect.\n    if (metadata.capture_update_rect) {\n      damage_rect = *metadata.capture_update_rect;\n    }\n    if (damage_rect.IsEmpty()) {\n      damage_rect = gfx::Rect(info->coded_size);\n    }\n  }\n\n  view_->OnPaint(damage_rect, info->coded_size, pixels);\n}\n"], "filenames": ["libcef/browser/osr/host_display_client_osr.cc", "libcef/browser/osr/video_consumer_osr.cc"], "buggy_code_start_loc": [78, 90], "buggy_code_end_loc": [87, 90], "fixing_code_start_loc": [78, 91], "fixing_code_end_loc": [96, 96], "type": "CWE-125", "message": "CEF (Chromium Embedded Framework ) is a simple framework for embedding Chromium-based browsers in other applications. `CefLayeredWindowUpdaterOSR::OnAllocatedSharedMemory` does not check the size of the shared memory, which leads to out-of-bounds read outside the sandbox. This vulnerability was patched in commit 1f55d2e.", "other": {"cve": {"id": "CVE-2024-21639", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-12T22:15:45.750", "lastModified": "2024-01-22T19:23:11.360", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "CEF (Chromium Embedded Framework ) is a simple framework for embedding Chromium-based browsers in other applications. `CefLayeredWindowUpdaterOSR::OnAllocatedSharedMemory` does not check the size of the shared memory, which leads to out-of-bounds read outside the sandbox. This vulnerability was patched in commit 1f55d2e."}, {"lang": "es", "value": "CEF (Chromium Embedded Framework) es un framework simple para integrar navegadores basados en Chromium en otras aplicaciones. `CefLayeredWindowUpdaterOSR::OnAllocatedSharedMemory` no verifica el tama\u00f1o de la memoria compartida, lo que genera lecturas fuera de los l\u00edmites fuera de la sandbox. Esta vulnerabilidad fue parcheada en el commit 1f55d2e."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.6, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 5.8}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:chromiumembedded:chromium_embedded_framework:*:*:*:*:*:*:*:*", "versionEndExcluding": "2024-01-05", "matchCriteriaId": "3DDE5170-AEB5-4EB6-B436-9634C0190E6A"}]}]}], "references": [{"url": "https://github.com/chromiumembedded/cef/commit/1f55d2e12f62cfdfbf9da6968fde2f928982670b", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/chromiumembedded/cef/security/advisories/GHSA-m375-jw5x-x8mg", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/chromiumembedded/cef/commit/1f55d2e12f62cfdfbf9da6968fde2f928982670b"}}