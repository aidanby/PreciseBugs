{"buggy_code": ["/* tjws - WarRoller.java\r\n * Copyright (C) 2004-2010 Dmitriy Rogatkin.  All rights reserved.\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions\r\n * are met:\r\n * 1. Redistributions of source code must retain the above copyright\r\n *    notice, this list of conditions and the following disclaimer.\r\n * 2. Redistributions in binary form must reproduce the above copyright\r\n *    notice, this list of conditions and the following disclaimer in the\r\n *    documentation and/or other materials provided with the distribution.\r\n *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\r\n *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n *  ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR\r\n *  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n *  $Id: WarRoller.java,v 1.30 2013/07/02 07:11:28 cvs Exp $\r\n * Created on Dec 13, 2004\r\n */\r\npackage rogatkin.web;\r\n\r\nimport java.io.File;\r\nimport java.io.FileFilter;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.OutputStream;\r\nimport java.util.zip.ZipEntry;\r\nimport java.util.zip.ZipException;\r\nimport java.util.zip.ZipFile;\r\nimport java.util.ArrayList;\r\nimport java.util.Enumeration;\r\nimport java.util.HashSet;\r\n\r\nimport javax.servlet.ServletException;\r\n\r\nimport Acme.Utils;\r\nimport Acme.Serve.Serve;\r\nimport Acme.Serve.WarDeployer;\r\n\r\npublic class WarRoller implements WarDeployer {\r\n\r\n    public static final String DEPLOY_ARCH_EXT = \".war\";\r\n\r\n    public static final String DEPLOYMENT_DIR_TARGET = \".web-apps-target\";\r\n\r\n    public static final String DEF_DEPLOY_DYNAMICALLY = \"tjws.wardeploy.dynamically\";\r\n\r\n    public static final String DEF_DEPLOY_NOINCREMENTAL = \"tjws.wardeploy.noincremental\";\r\n\r\n    public static final String DEF_VIRTUAL = \"tjws.virtual\";\r\n\r\n    public static final String DEPLOY_FAILED_EXT = \".failed\";\r\n\r\n    /**\r\n     * in deploy mode scans for all wars in war directory (app deployment dir)\r\n     * for each war looks in corresponding place of deploy directory and figures\r\n     * a difference, like any file in war exists and no corresponding file in\r\n     * deploy directory or it's older if difference positive, then delete target\r\n     * deploy directory unpack war if run mode process all WEB-INF/web.xml and\r\n     * build app descriptor, including context name, servlet names, servlet\r\n     * urls, class parameters process every app descriptor as standard servlet\r\n     * connection proc dispatch for every context name assigned an app\r\n     * dispatcher, it uses the rest to find servlet and do resource mapping\r\n     * \r\n     */\r\n\r\n    public void deploy(File warDir, final File deployTarDir, final String virtualHost) {\r\n\t// by list\r\n\tif (warDir.listFiles(new FileFilter() {\r\n\t    public boolean accept(File pathname) {\r\n\t\tif (pathname.isFile() && pathname.getName().toLowerCase().endsWith(DEPLOY_ARCH_EXT)) {\r\n\t\t    deployWar(pathname, deployTarDir);\r\n\t\t    return true;\r\n\t\t}\r\n\t\treturn false;\r\n\t    }\r\n\t}).length == 0)\r\n\t    server.log(\"No .war packaged web apps found in \" + (virtualHost == null ? \"default\" : virtualHost));\r\n\tif (deployTarDir.listFiles(new FileFilter() {\r\n\t    public boolean accept(File file) {\r\n\t\tif (file.isDirectory())\r\n\t\t    try {\r\n\t\t\tattachApp(WebAppServlet.create(file, file.getName(), server, virtualHost), virtualHost);\r\n\t\t\tmarkSucceeded(file.getParentFile(), file.getName()); // assumes that parent always exists\r\n\t\t\treturn true;\r\n\t\t    } catch (ServletException se) {\r\n\t\t\tserver.log(\r\n\t\t\t\t\"Deployment of aplication \" + file.getName() + \" failed, reason: \" + se.getRootCause(),\r\n\t\t\t\tse.getRootCause());\r\n\t\t    } catch (Throwable t) {\r\n\t\t\tif (t instanceof ThreadDeath)\r\n\t\t\t    throw (ThreadDeath) t;\r\n\t\t\tserver.log(\"Unexpected problem in deployment of application  \" + file.getName(), t);\r\n\t\t    }\r\n\t\treturn false;\r\n\t    }\r\n\t}).length == 0)\r\n\t    server.log(\"No web apps have been deployed in \" + (virtualHost == null ? \"default\" : virtualHost));\r\n    }\r\n\r\n    public boolean deployWar(File warFile, File deployTarDir) {\r\n\tString context = warFile.getName();\r\n\tassert context.toLowerCase().endsWith(DEPLOY_ARCH_EXT);\r\n\tcontext = context.substring(0, context.length() - DEPLOY_ARCH_EXT.length());\r\n\tFile failedMark = new File(deployTarDir, context + DEPLOY_FAILED_EXT); \r\n\tif (failedMark.exists() && failedMark.lastModified() > warFile.lastModified())\r\n\t    return false; // skipping deploy failed\r\n\r\n\tserver.log(\"Deploying \" + context);\r\n\tZipFile zipFile = null;\r\n\tFile deployDir = new File(deployTarDir, context);\r\n\tboolean noincremental = System.getProperty(DEF_DEPLOY_NOINCREMENTAL) != null;\r\n\tif (assureDir(deployDir) == false) {\r\n\t    server.log(\"Can't reach deployment dir \" + deployDir);\r\n\t    return false;\r\n\t}\r\n\tException lastException = null;\r\n\tdeploy: do {\r\n\t    try {\r\n\t\t// some overhead didn't check that doesn't exist\r\n\t\tzipFile = new ZipFile(warFile);\r\n\t\tEnumeration<? extends ZipEntry> entries = zipFile.entries();\r\n\t\twhile (entries.hasMoreElements()) {\r\n\t\t    ZipEntry ze = entries.nextElement();\r\n\t\t    String en = ze.getName();\r\n\t\t    if (File.separatorChar == '/')\r\n\t\t\ten = en.replace('\\\\', File.separatorChar);\r\n\t\t    File outFile = new File(deployDir, en);\r\n\t\t    if (ze.isDirectory()) {\r\n\t\t\toutFile.mkdirs();\r\n\t\t    } else {\r\n\t\t\tOutputStream os = null;\r\n\t\t\tInputStream is = null;\r\n\t\t\tFile parentFile = outFile.getParentFile();\r\n\t\t\tif (parentFile.exists() == false)\r\n\t\t\t    parentFile.mkdirs();\r\n\t\t\tif (outFile.exists() && outFile.lastModified() >= ze.getTime()) {\r\n\t\t\t    continue;\r\n\t\t\t}\r\n\t\t\tif (noincremental) {\r\n\t\t\t    deleteFiles(deployDir, deployDir.list());\r\n\t\t\t    noincremental = false;\r\n\t\t\t    continue deploy;\r\n\t\t\t}\r\n\t\t\ttry {\r\n\t\t\t    os = new FileOutputStream(outFile);\r\n\t\t\t    is = zipFile.getInputStream(ze);\r\n\t\t\t    copyStream(is, os);\r\n\t\t\t} catch (IOException ioe2) {\r\n\t\t\t    server.log(\"Problem in extracting \" + en + \" \" + ioe2);\t\t\t    \r\n\t\t\t    // TODO decide to propagate the exception up and stop deployment?\r\n\t\t\t    lastException = ioe2;\r\n\t\t\t} finally {\r\n\t\t\t    try {\r\n\t\t\t\tos.close();\r\n\t\t\t    } catch (Exception e2) {\r\n\r\n\t\t\t    }\r\n\t\t\t    try {\r\n\t\t\t\tis.close();\r\n\t\t\t    } catch (Exception e2) {\r\n\r\n\t\t\t    }\r\n\t\t\t}\r\n\t\t\toutFile.setLastModified(ze.getTime());\r\n\t\t    }\r\n\t\t}\r\n\t    } catch (ZipException ze) {\r\n\t\tserver.log(\"Invalid .war format\");\r\n\t\tlastException = ze;\r\n\t    } catch (IOException ioe) {\r\n\t\tserver.log(\"Can't read \" + warFile + \"/ \" + ioe);\r\n\t\tlastException = ioe;\r\n\t    } finally {\r\n\t\ttry {\r\n\t\t    zipFile.close();\r\n\t\t} catch (Exception e) {\r\n\r\n\t\t}\r\n\t\tzipFile = null;\r\n\t    }\r\n\t} while (false);\r\n\tif (lastException == null) {\r\n\t\tdeployDir.setLastModified(warFile.lastModified());\r\n\t\treturn true;\r\n\t} \r\n\tdeployDir.setLastModified(0);\r\n\treturn false;\r\n    }\r\n\r\n    protected void attachApp(WebAppServlet appServlet, String virtualHost) {\r\n\tserver.addServlet(appServlet.contextPath + \"/*\", appServlet, virtualHost);\r\n    }\r\n\r\n    /** Returns auto deployment directory\r\n     * <p>\r\n     * The method can be overriden to give more control of choosing the directory\r\n     * @return autodeployment directory location as local file system string\r\n     */\r\n    protected String getDeployDirectory() {\r\n    \tString webapp_dir = System.getProperty(WebApp.DEF_WEBAPP_AUTODEPLOY_DIR);\r\n    \tif (webapp_dir == null)\r\n    \t    webapp_dir = System.getProperty(\"user.dir\") + File.separator + \"webapps\";\r\n    \treturn webapp_dir;\r\n    }\r\n    \r\n    public void deploy(Serve server) {\r\n\tthis.server = server;\r\n\tfinal File file_webapp = new File(getDeployDirectory());\r\n\tif (assureDir(file_webapp) == false) {\r\n\t    server.log(\"Deployment source location \" + file_webapp + \" isn't a directory, deployment is impossible.\");\r\n\t    return;\r\n\t}\r\n\tfinal File file_deployDir = new File(file_webapp, DEPLOYMENT_DIR_TARGET);\r\n\tif (assureDir(file_deployDir) == false) {\r\n\t    server.log(\"Target deployment location \" + file_deployDir + \" isn't a directory, deployment is impossible.\");\r\n\t    return;\r\n\t}\r\n\tdeploy(file_webapp, file_deployDir, null);\r\n\r\n\tint td = 0;\r\n\tif (System.getProperty(DEF_DEPLOY_DYNAMICALLY) != null) {\r\n\t    td = 20;\r\n\t    try {\r\n\t\ttd = Integer.parseInt(System.getProperty(DEF_DEPLOY_DYNAMICALLY));\r\n\t    } catch (NumberFormatException nfe) {\r\n\t\tserver.log(\"Default redeployment check interval: \" + td + \" is used\");\r\n\t    }\r\n\t}\r\n\tfinal int interval = td * 1000;\r\n\tcreateWatcherThread(file_webapp, file_deployDir, interval, null);\r\n\tif (null != System.getProperty(DEF_VIRTUAL)) {\r\n\t    file_webapp.listFiles(new FileFilter() {\r\n\t\t@Override\r\n\t\tpublic boolean accept(File pathname) {\r\n\t\t    String virtualHost;\r\n\t\t    if (pathname.isDirectory()\r\n\t\t\t    && (virtualHost = pathname.getName()).equals(DEPLOYMENT_DIR_TARGET) == false) {\r\n\r\n\t\t\tfinal File file_deployDir = new File(pathname, DEPLOYMENT_DIR_TARGET);\r\n\t\t\tif (assureDir(file_deployDir) == false) {\r\n\t\t\t    WarRoller.this.server.log(\"Target deployment location \" + file_deployDir\r\n\t\t\t\t    + \" isn't a directory, deployment is impossible.\");\r\n\t\t\t} else {\r\n\t\t\t    deploy(pathname, file_deployDir, virtualHost);\r\n\t\t\t    createWatcherThread(pathname, file_deployDir, interval, virtualHost);\r\n\t\t\t    return true;\r\n\t\t\t}\r\n\t\t    }\r\n\t\t    return false;\r\n\t\t}\r\n\t    });\r\n\t}\r\n    }\r\n\r\n    protected void createWatcherThread(final File file_webapp, final File file_deployDir, final int interval,\r\n\t    final String virtualHost) {\r\n\tif (interval <= 0)\r\n\t    return;\r\n\tThread watcher = new Thread(\"Deploy update watcher for \" + (virtualHost == null ? \"main\" : virtualHost)) {\r\n\t    public void run() {\r\n\t\tfor (;;)\r\n\t\t    try {\r\n\t\t\tdeployWatch(file_webapp, file_deployDir, virtualHost);\r\n\t\t    } catch (Throwable t) {\r\n\t\t\tif (t instanceof ThreadDeath)\r\n\t\t\t    throw (ThreadDeath) t;\r\n\t\t\tWarRoller.this.server.log(\"Unhandled \" + t, t);\r\n\t\t    } finally {\r\n\t\t\ttry {\r\n\t\t\t    Thread.sleep(interval);\r\n\t\t\t} catch (InterruptedException e) {\r\n\t\t\t    break;\r\n\t\t\t}\r\n\t\t    }\r\n\t    }\r\n\t};\r\n\twatcher.setDaemon(true);\r\n\twatcher.start();\r\n    }\r\n\r\n    protected boolean assureDir(File fileDir) {\r\n\tif (fileDir.exists() == false)\r\n\t    fileDir.mkdirs();\r\n\treturn fileDir.isDirectory();\r\n    }\r\n\r\n    protected synchronized void deployWatch(File warDir, final File deployTarDir, String virtualHost) {\r\n\tserver.setHost(virtualHost);\r\n\tfinal HashSet<String> apps = new HashSet<String>();\r\n\twarDir.listFiles(new FileFilter() {\r\n\t    public boolean accept(File file) {\r\n\t\tif (file.isDirectory() == false) {\r\n\t\t    String name = file.getName();\r\n\t\t    if (name.endsWith(DEPLOY_ARCH_EXT))\r\n\t\t\tapps.add(name.substring(0, name.length() - DEPLOY_ARCH_EXT.length()));\r\n\t\t}\r\n\t\treturn false;\r\n\t    }\r\n\t});\r\n\tEnumeration se = server.getServlets();\r\n\tArrayList<WebAppServlet> markedServlets = new ArrayList<WebAppServlet>(10);\r\n\twhile (se.hasMoreElements()) {\r\n\t    Object servlet = se.nextElement();\r\n\t    if (servlet instanceof WebAppServlet) {\r\n\t\tWebAppServlet was = (WebAppServlet) servlet;\r\n\t\tString name = was.deployDir.getName();\r\n\t\tFile war = new File(warDir, name + DEPLOY_ARCH_EXT);\r\n\t\tapps.remove(name);\r\n\t\tif (war.exists() && war.lastModified() > was.deployDir.lastModified()) {\r\n\t\t    // deployWar(new File(warDir, was.deployDir.getName() +\r\n\t\t    // DEPLOY_ARCH_EXT), deployTarDir);\r\n\t\t    markedServlets.add(was);\r\n\t\t}\r\n\t    }\r\n\t}\r\n\tfor (WebAppServlet was : markedServlets) {\r\n\t    redeploy(warDir, deployTarDir, was, virtualHost);\r\n\t}\r\n\tfor (String name : apps) {\r\n\t    // remaining not deployed yet apps\r\n\t    try {\r\n\t\tif (deployWar(new File(warDir, name + DEPLOY_ARCH_EXT), deployTarDir)) {\r\n\t\t    WebAppServlet was = WebAppServlet.create(new File(deployTarDir, name), name, server, virtualHost);\t\t    \r\n\t\t    attachApp(was, virtualHost);\r\n\t\t}\r\n\t    } catch (Throwable t) {\r\n\t\tif (t instanceof ThreadDeath)\r\n\t\t    throw (ThreadDeath) t;\r\n\t\tmarkFailed(deployTarDir, name);\r\n\t\tserver.log(\"Unexpected problem in deployment of aplication  \" + name, t);\r\n\t    }\r\n\t}\r\n    }\r\n\r\n    public void redeploy(File warDir, File deployTarDir, WebAppServlet was, String virtualHost) {\r\n\twas = (WebAppServlet) server.unloadServlet(was);\r\n\tif (was == null)\r\n\t    return;\r\n\tserver.unloadSessions(was.getServletContext());\r\n\twas.destroy();\r\n\r\n\t// TODO use pre-saved war name\r\n\tif (deployWar(new File(warDir, was.deployDir.getName() + DEPLOY_ARCH_EXT), deployTarDir))\r\n\ttry {\r\n\t    was = WebAppServlet.create(was.deployDir, was.deployDir.getName(), server, virtualHost);\r\n\t    attachApp(was, virtualHost);\r\n\t    server.restoreSessions(was.getServletContext());\r\n\t    markSucceeded(deployTarDir, was.deployDir.getName());\r\n\t} catch (ServletException sex) {\r\n\t    markFailed(deployTarDir, was.deployDir.getName());\r\n\t    server.log(\"Deployment of a web app \" + was.contextName + \" failed due \" + sex.getRootCause(),\r\n\t\t    sex.getRootCause());\r\n\t} catch (Throwable t) {\r\n\t    if (t instanceof ThreadDeath)\r\n\t\tthrow (ThreadDeath) t;\r\n\t    markFailed(deployTarDir, was.deployDir.getName());\r\n\t    server.log(\"Unexpected problem in deployment of aplication  \" + was.contextName, t);\r\n\t}\r\n    }\r\n\r\n    static private boolean markFailed(File deployTarDir, String appName) {\r\n    \tFile markFile = new File(deployTarDir, appName + DEPLOY_FAILED_EXT);\r\n    \r\n\tif (markFile.exists()) {\r\n\t\tFile appDeployDir = new File(deployTarDir, appName);\r\n\t\tif (appDeployDir.exists())\r\n\t\tmarkFile.setLastModified(appDeployDir.lastModified()+1);\r\n\t    return true;\r\n\t}\r\n\ttry {\r\n\t    return markFile.createNewFile();\r\n\t} catch (IOException e) {\r\n\t    return false;\r\n\t}\r\n    }\r\n\r\n    static private boolean markSucceeded(File deployTarDir, String appName) {\r\n\tif (new File(deployTarDir, appName + DEPLOY_FAILED_EXT).exists())\r\n\t    return new File(deployTarDir, appName+DEPLOY_FAILED_EXT).delete();\r\n\treturn true;\r\n    }\r\n\r\n    static void copyStream(InputStream is, OutputStream os) throws IOException {\r\n\tUtils.copyStream(is, os, -1);\r\n    }\r\n\r\n    static void deleteFiles(File folder, String[] files) throws IOException {\r\n\tfor (String fn : files) {\r\n\t    File f = new File(folder, fn);\r\n\t    if (f.isDirectory()) {\r\n\t\tdeleteFiles(f, f.list());\r\n\t\tif (f.delete() == false)\r\n\t\t    throw new IOException(\"Can't delete :\" + f);\r\n\t    } else {\r\n\t\tif (f.delete() == false)\r\n\t\t    throw new IOException(\"Can't delete :\" + f);\r\n\t    }\r\n\t}\r\n    }\r\n\r\n    protected Serve server;\r\n}"], "fixing_code": ["/* tjws - WarRoller.java\r\n * Copyright (C) 2004-2010 Dmitriy Rogatkin.  All rights reserved.\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions\r\n * are met:\r\n * 1. Redistributions of source code must retain the above copyright\r\n *    notice, this list of conditions and the following disclaimer.\r\n * 2. Redistributions in binary form must reproduce the above copyright\r\n *    notice, this list of conditions and the following disclaimer in the\r\n *    documentation and/or other materials provided with the distribution.\r\n *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\r\n *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n *  ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR\r\n *  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n *  $Id: WarRoller.java,v 1.30 2013/07/02 07:11:28 cvs Exp $\r\n * Created on Dec 13, 2004\r\n */\r\npackage rogatkin.web;\r\n\r\nimport java.io.File;\r\nimport java.io.FileFilter;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.OutputStream;\r\nimport java.util.zip.ZipEntry;\r\nimport java.util.zip.ZipException;\r\nimport java.util.zip.ZipFile;\r\nimport java.util.ArrayList;\r\nimport java.util.Enumeration;\r\nimport java.util.HashSet;\r\n\r\nimport javax.servlet.ServletException;\r\n\r\nimport Acme.Utils;\r\nimport Acme.Serve.Serve;\r\nimport Acme.Serve.WarDeployer;\r\n\r\npublic class WarRoller implements WarDeployer {\r\n\r\n    public static final String DEPLOY_ARCH_EXT = \".war\";\r\n\r\n    public static final String DEPLOYMENT_DIR_TARGET = \".web-apps-target\";\r\n\r\n    public static final String DEF_DEPLOY_DYNAMICALLY = \"tjws.wardeploy.dynamically\";\r\n\r\n    public static final String DEF_DEPLOY_NOINCREMENTAL = \"tjws.wardeploy.noincremental\";\r\n\r\n    public static final String DEF_VIRTUAL = \"tjws.virtual\";\r\n\r\n    public static final String DEPLOY_FAILED_EXT = \".failed\";\r\n\r\n    /**\r\n     * in deploy mode scans for all wars in war directory (app deployment dir)\r\n     * for each war looks in corresponding place of deploy directory and figures\r\n     * a difference, like any file in war exists and no corresponding file in\r\n     * deploy directory or it's older if difference positive, then delete target\r\n     * deploy directory unpack war if run mode process all WEB-INF/web.xml and\r\n     * build app descriptor, including context name, servlet names, servlet\r\n     * urls, class parameters process every app descriptor as standard servlet\r\n     * connection proc dispatch for every context name assigned an app\r\n     * dispatcher, it uses the rest to find servlet and do resource mapping\r\n     * \r\n     */\r\n\r\n    public void deploy(File warDir, final File deployTarDir, final String virtualHost) {\r\n\t// by list\r\n\tif (warDir.listFiles(new FileFilter() {\r\n\t    public boolean accept(File pathname) {\r\n\t\tif (pathname.isFile() && pathname.getName().toLowerCase().endsWith(DEPLOY_ARCH_EXT)) {\r\n\t\t    deployWar(pathname, deployTarDir);\r\n\t\t    return true;\r\n\t\t}\r\n\t\treturn false;\r\n\t    }\r\n\t}).length == 0)\r\n\t    server.log(\"No .war packaged web apps found in \" + (virtualHost == null ? \"default\" : virtualHost));\r\n\tif (deployTarDir.listFiles(new FileFilter() {\r\n\t    public boolean accept(File file) {\r\n\t\tif (file.isDirectory())\r\n\t\t    try {\r\n\t\t\tattachApp(WebAppServlet.create(file, file.getName(), server, virtualHost), virtualHost);\r\n\t\t\tmarkSucceeded(file.getParentFile(), file.getName()); // assumes that parent always exists\r\n\t\t\treturn true;\r\n\t\t    } catch (ServletException se) {\r\n\t\t\tserver.log(\r\n\t\t\t\t\"Deployment of aplication \" + file.getName() + \" failed, reason: \" + se.getRootCause(),\r\n\t\t\t\tse.getRootCause());\r\n\t\t    } catch (Throwable t) {\r\n\t\t\tif (t instanceof ThreadDeath)\r\n\t\t\t    throw (ThreadDeath) t;\r\n\t\t\tserver.log(\"Unexpected problem in deployment of application  \" + file.getName(), t);\r\n\t\t    }\r\n\t\treturn false;\r\n\t    }\r\n\t}).length == 0)\r\n\t    server.log(\"No web apps have been deployed in \" + (virtualHost == null ? \"default\" : virtualHost));\r\n    }\r\n\r\n    public boolean deployWar(File warFile, File deployTarDir) {\r\n\tString context = warFile.getName();\r\n\tassert context.toLowerCase().endsWith(DEPLOY_ARCH_EXT);\r\n\tcontext = context.substring(0, context.length() - DEPLOY_ARCH_EXT.length());\r\n\tFile failedMark = new File(deployTarDir, context + DEPLOY_FAILED_EXT); \r\n\tif (failedMark.exists() && failedMark.lastModified() > warFile.lastModified())\r\n\t    return false; // skipping deploy failed\r\n\r\n\tserver.log(\"Deploying \" + context);\r\n\tZipFile zipFile = null;\r\n\tFile deployDir = new File(deployTarDir, context);\r\n\tboolean noincremental = System.getProperty(DEF_DEPLOY_NOINCREMENTAL) != null;\r\n\tif (assureDir(deployDir) == false) {\r\n\t    server.log(\"Can't reach deployment dir \" + deployDir);\r\n\t    return false;\r\n\t}\r\n\tException lastException = null;\r\n\tdeploy: do {\r\n\t    try {\r\n\t\t// some overhead didn't check that doesn't exist\r\n\t\tzipFile = new ZipFile(warFile);\r\n\t\tEnumeration<? extends ZipEntry> entries = zipFile.entries();\r\n\t\twhile (entries.hasMoreElements()) {\r\n\t\t    ZipEntry ze = entries.nextElement();\r\n\t\t    String en = ze.getName();\r\n\t\t    if (File.separatorChar == '/')\r\n\t\t\ten = en.replace('\\\\', File.separatorChar);\r\n\t\t    if (en.contains(\"../\") || en.contains(\"/..\")) \r\n\t\t    \tthrow new IOException(\"The file name \" + en + \" contains .. which can lead to a Path Traversal vulnerability\");\r\n\t\t    File outFile = new File(deployDir, en);\r\n\t\t    if (ze.isDirectory()) {\r\n\t\t\toutFile.mkdirs();\r\n\t\t    } else {\r\n\t\t\tOutputStream os = null;\r\n\t\t\tInputStream is = null;\r\n\t\t\tFile parentFile = outFile.getParentFile();\r\n\t\t\tif (parentFile.exists() == false)\r\n\t\t\t    parentFile.mkdirs();\r\n\t\t\tif (outFile.exists() && outFile.lastModified() >= ze.getTime()) {\r\n\t\t\t    continue;\r\n\t\t\t}\r\n\t\t\tif (noincremental) {\r\n\t\t\t    deleteFiles(deployDir, deployDir.list());\r\n\t\t\t    noincremental = false;\r\n\t\t\t    continue deploy;\r\n\t\t\t}\r\n\t\t\ttry {\r\n\t\t\t    os = new FileOutputStream(outFile);\r\n\t\t\t    is = zipFile.getInputStream(ze);\r\n\t\t\t    copyStream(is, os);\r\n\t\t\t} catch (IOException ioe2) {\r\n\t\t\t    server.log(\"Problem in extracting \" + en + \" \" + ioe2);\t\t\t    \r\n\t\t\t    // TODO decide to propagate the exception up and stop deployment?\r\n\t\t\t    lastException = ioe2;\r\n\t\t\t} finally {\r\n\t\t\t    try {\r\n\t\t\t\tos.close();\r\n\t\t\t    } catch (Exception e2) {\r\n\r\n\t\t\t    }\r\n\t\t\t    try {\r\n\t\t\t\tis.close();\r\n\t\t\t    } catch (Exception e2) {\r\n\r\n\t\t\t    }\r\n\t\t\t}\r\n\t\t\toutFile.setLastModified(ze.getTime());\r\n\t\t    }\r\n\t\t}\r\n\t    } catch (ZipException ze) {\r\n\t\tserver.log(\"Invalid .war format\");\r\n\t\tlastException = ze;\r\n\t    } catch (IOException ioe) {\r\n\t\tserver.log(\"Can't read \" + warFile + \"/ \" + ioe);\r\n\t\tlastException = ioe;\r\n\t    } finally {\r\n\t\ttry {\r\n\t\t    zipFile.close();\r\n\t\t} catch (Exception e) {\r\n\r\n\t\t}\r\n\t\tzipFile = null;\r\n\t    }\r\n\t} while (false);\r\n\tif (lastException == null) {\r\n\t\tdeployDir.setLastModified(warFile.lastModified());\r\n\t\treturn true;\r\n\t} \r\n\tdeployDir.setLastModified(0);\r\n\treturn false;\r\n    }\r\n\r\n    protected void attachApp(WebAppServlet appServlet, String virtualHost) {\r\n\tserver.addServlet(appServlet.contextPath + \"/*\", appServlet, virtualHost);\r\n    }\r\n\r\n    /** Returns auto deployment directory\r\n     * <p>\r\n     * The method can be overriden to give more control of choosing the directory\r\n     * @return autodeployment directory location as local file system string\r\n     */\r\n    protected String getDeployDirectory() {\r\n    \tString webapp_dir = System.getProperty(WebApp.DEF_WEBAPP_AUTODEPLOY_DIR);\r\n    \tif (webapp_dir == null)\r\n    \t    webapp_dir = System.getProperty(\"user.dir\") + File.separator + \"webapps\";\r\n    \treturn webapp_dir;\r\n    }\r\n    \r\n    public void deploy(Serve server) {\r\n\tthis.server = server;\r\n\tfinal File file_webapp = new File(getDeployDirectory());\r\n\tif (assureDir(file_webapp) == false) {\r\n\t    server.log(\"Deployment source location \" + file_webapp + \" isn't a directory, deployment is impossible.\");\r\n\t    return;\r\n\t}\r\n\tfinal File file_deployDir = new File(file_webapp, DEPLOYMENT_DIR_TARGET);\r\n\tif (assureDir(file_deployDir) == false) {\r\n\t    server.log(\"Target deployment location \" + file_deployDir + \" isn't a directory, deployment is impossible.\");\r\n\t    return;\r\n\t}\r\n\tdeploy(file_webapp, file_deployDir, null);\r\n\r\n\tint td = 0;\r\n\tif (System.getProperty(DEF_DEPLOY_DYNAMICALLY) != null) {\r\n\t    td = 20;\r\n\t    try {\r\n\t\ttd = Integer.parseInt(System.getProperty(DEF_DEPLOY_DYNAMICALLY));\r\n\t    } catch (NumberFormatException nfe) {\r\n\t\tserver.log(\"Default redeployment check interval: \" + td + \" is used\");\r\n\t    }\r\n\t}\r\n\tfinal int interval = td * 1000;\r\n\tcreateWatcherThread(file_webapp, file_deployDir, interval, null);\r\n\tif (null != System.getProperty(DEF_VIRTUAL)) {\r\n\t    file_webapp.listFiles(new FileFilter() {\r\n\t\t@Override\r\n\t\tpublic boolean accept(File pathname) {\r\n\t\t    String virtualHost;\r\n\t\t    if (pathname.isDirectory()\r\n\t\t\t    && (virtualHost = pathname.getName()).equals(DEPLOYMENT_DIR_TARGET) == false) {\r\n\r\n\t\t\tfinal File file_deployDir = new File(pathname, DEPLOYMENT_DIR_TARGET);\r\n\t\t\tif (assureDir(file_deployDir) == false) {\r\n\t\t\t    WarRoller.this.server.log(\"Target deployment location \" + file_deployDir\r\n\t\t\t\t    + \" isn't a directory, deployment is impossible.\");\r\n\t\t\t} else {\r\n\t\t\t    deploy(pathname, file_deployDir, virtualHost);\r\n\t\t\t    createWatcherThread(pathname, file_deployDir, interval, virtualHost);\r\n\t\t\t    return true;\r\n\t\t\t}\r\n\t\t    }\r\n\t\t    return false;\r\n\t\t}\r\n\t    });\r\n\t}\r\n    }\r\n\r\n    protected void createWatcherThread(final File file_webapp, final File file_deployDir, final int interval,\r\n\t    final String virtualHost) {\r\n\tif (interval <= 0)\r\n\t    return;\r\n\tThread watcher = new Thread(\"Deploy update watcher for \" + (virtualHost == null ? \"main\" : virtualHost)) {\r\n\t    public void run() {\r\n\t\tfor (;;)\r\n\t\t    try {\r\n\t\t\tdeployWatch(file_webapp, file_deployDir, virtualHost);\r\n\t\t    } catch (Throwable t) {\r\n\t\t\tif (t instanceof ThreadDeath)\r\n\t\t\t    throw (ThreadDeath) t;\r\n\t\t\tWarRoller.this.server.log(\"Unhandled \" + t, t);\r\n\t\t    } finally {\r\n\t\t\ttry {\r\n\t\t\t    Thread.sleep(interval);\r\n\t\t\t} catch (InterruptedException e) {\r\n\t\t\t    break;\r\n\t\t\t}\r\n\t\t    }\r\n\t    }\r\n\t};\r\n\twatcher.setDaemon(true);\r\n\twatcher.start();\r\n    }\r\n\r\n    protected boolean assureDir(File fileDir) {\r\n\tif (fileDir.exists() == false)\r\n\t    fileDir.mkdirs();\r\n\treturn fileDir.isDirectory();\r\n    }\r\n\r\n    protected synchronized void deployWatch(File warDir, final File deployTarDir, String virtualHost) {\r\n\tserver.setHost(virtualHost);\r\n\tfinal HashSet<String> apps = new HashSet<String>();\r\n\twarDir.listFiles(new FileFilter() {\r\n\t    public boolean accept(File file) {\r\n\t\tif (file.isDirectory() == false) {\r\n\t\t    String name = file.getName();\r\n\t\t    if (name.endsWith(DEPLOY_ARCH_EXT))\r\n\t\t\tapps.add(name.substring(0, name.length() - DEPLOY_ARCH_EXT.length()));\r\n\t\t}\r\n\t\treturn false;\r\n\t    }\r\n\t});\r\n\tEnumeration se = server.getServlets();\r\n\tArrayList<WebAppServlet> markedServlets = new ArrayList<WebAppServlet>(10);\r\n\twhile (se.hasMoreElements()) {\r\n\t    Object servlet = se.nextElement();\r\n\t    if (servlet instanceof WebAppServlet) {\r\n\t\tWebAppServlet was = (WebAppServlet) servlet;\r\n\t\tString name = was.deployDir.getName();\r\n\t\tFile war = new File(warDir, name + DEPLOY_ARCH_EXT);\r\n\t\tapps.remove(name);\r\n\t\tif (war.exists() && war.lastModified() > was.deployDir.lastModified()) {\r\n\t\t    // deployWar(new File(warDir, was.deployDir.getName() +\r\n\t\t    // DEPLOY_ARCH_EXT), deployTarDir);\r\n\t\t    markedServlets.add(was);\r\n\t\t}\r\n\t    }\r\n\t}\r\n\tfor (WebAppServlet was : markedServlets) {\r\n\t    redeploy(warDir, deployTarDir, was, virtualHost);\r\n\t}\r\n\tfor (String name : apps) {\r\n\t    // remaining not deployed yet apps\r\n\t    try {\r\n\t\tif (deployWar(new File(warDir, name + DEPLOY_ARCH_EXT), deployTarDir)) {\r\n\t\t    WebAppServlet was = WebAppServlet.create(new File(deployTarDir, name), name, server, virtualHost);\t\t    \r\n\t\t    attachApp(was, virtualHost);\r\n\t\t}\r\n\t    } catch (Throwable t) {\r\n\t\tif (t instanceof ThreadDeath)\r\n\t\t    throw (ThreadDeath) t;\r\n\t\tmarkFailed(deployTarDir, name);\r\n\t\tserver.log(\"Unexpected problem in deployment of aplication  \" + name, t);\r\n\t    }\r\n\t}\r\n    }\r\n\r\n    public void redeploy(File warDir, File deployTarDir, WebAppServlet was, String virtualHost) {\r\n\twas = (WebAppServlet) server.unloadServlet(was);\r\n\tif (was == null)\r\n\t    return;\r\n\tserver.unloadSessions(was.getServletContext());\r\n\twas.destroy();\r\n\r\n\t// TODO use pre-saved war name\r\n\tif (deployWar(new File(warDir, was.deployDir.getName() + DEPLOY_ARCH_EXT), deployTarDir))\r\n\ttry {\r\n\t    was = WebAppServlet.create(was.deployDir, was.deployDir.getName(), server, virtualHost);\r\n\t    attachApp(was, virtualHost);\r\n\t    server.restoreSessions(was.getServletContext());\r\n\t    markSucceeded(deployTarDir, was.deployDir.getName());\r\n\t} catch (ServletException sex) {\r\n\t    markFailed(deployTarDir, was.deployDir.getName());\r\n\t    server.log(\"Deployment of a web app \" + was.contextName + \" failed due \" + sex.getRootCause(),\r\n\t\t    sex.getRootCause());\r\n\t} catch (Throwable t) {\r\n\t    if (t instanceof ThreadDeath)\r\n\t\tthrow (ThreadDeath) t;\r\n\t    markFailed(deployTarDir, was.deployDir.getName());\r\n\t    server.log(\"Unexpected problem in deployment of aplication  \" + was.contextName, t);\r\n\t}\r\n    }\r\n\r\n    static private boolean markFailed(File deployTarDir, String appName) {\r\n    \tFile markFile = new File(deployTarDir, appName + DEPLOY_FAILED_EXT);\r\n    \r\n\tif (markFile.exists()) {\r\n\t\tFile appDeployDir = new File(deployTarDir, appName);\r\n\t\tif (appDeployDir.exists())\r\n\t\tmarkFile.setLastModified(appDeployDir.lastModified()+1);\r\n\t    return true;\r\n\t}\r\n\ttry {\r\n\t    return markFile.createNewFile();\r\n\t} catch (IOException e) {\r\n\t    return false;\r\n\t}\r\n    }\r\n\r\n    static private boolean markSucceeded(File deployTarDir, String appName) {\r\n\tif (new File(deployTarDir, appName + DEPLOY_FAILED_EXT).exists())\r\n\t    return new File(deployTarDir, appName+DEPLOY_FAILED_EXT).delete();\r\n\treturn true;\r\n    }\r\n\r\n    static void copyStream(InputStream is, OutputStream os) throws IOException {\r\n\tUtils.copyStream(is, os, -1);\r\n    }\r\n\r\n    static void deleteFiles(File folder, String[] files) throws IOException {\r\n\tfor (String fn : files) {\r\n\t    File f = new File(folder, fn);\r\n\t    if (f.isDirectory()) {\r\n\t\tdeleteFiles(f, f.list());\r\n\t\tif (f.delete() == false)\r\n\t\t    throw new IOException(\"Can't delete :\" + f);\r\n\t    } else {\r\n\t\tif (f.delete() == false)\r\n\t\t    throw new IOException(\"Can't delete :\" + f);\r\n\t    }\r\n\t}\r\n    }\r\n\r\n    protected Serve server;\r\n}"], "filenames": ["1.x/src/rogatkin/web/WarRoller.java"], "buggy_code_start_loc": [133], "buggy_code_end_loc": [133], "fixing_code_start_loc": [134], "fixing_code_end_loc": [136], "type": "CWE-22", "message": "A vulnerability was found in drogatkin TJWS2. It has been declared as critical. Affected by this vulnerability is the function deployWar of the file 1.x/src/rogatkin/web/WarRoller.java. The manipulation leads to path traversal. The attack can be launched remotely. The name of the patch is 1bac15c496ec54efe21ad7fab4e17633778582fc. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-216187.", "other": {"cve": {"id": "CVE-2022-4594", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-18T08:15:09.777", "lastModified": "2022-12-22T18:20:01.357", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in drogatkin TJWS2. It has been declared as critical. Affected by this vulnerability is the function deployWar of the file 1.x/src/rogatkin/web/WarRoller.java. The manipulation leads to path traversal. The attack can be launched remotely. The name of the patch is 1bac15c496ec54efe21ad7fab4e17633778582fc. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-216187."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tjws2_project:tjws2:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022-05-24", "matchCriteriaId": "F21FEF50-B7F1-473A-85FA-4BDEBB2E55B8"}]}]}], "references": [{"url": "https://github.com/drogatkin/TJWS2/commit/1bac15c496ec54efe21ad7fab4e17633778582fc", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216187", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/drogatkin/TJWS2/commit/1bac15c496ec54efe21ad7fab4e17633778582fc"}}