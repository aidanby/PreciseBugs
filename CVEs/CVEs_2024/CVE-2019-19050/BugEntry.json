{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * Crypto user configuration API.\n *\n * Copyright (C) 2017-2018 Corentin Labbe <clabbe@baylibre.com>\n *\n */\n\n#include <linux/crypto.h>\n#include <linux/cryptouser.h>\n#include <linux/sched.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <crypto/internal/skcipher.h>\n#include <crypto/internal/rng.h>\n#include <crypto/akcipher.h>\n#include <crypto/kpp.h>\n#include <crypto/internal/cryptouser.h>\n\n#include \"internal.h\"\n\n#define null_terminated(x)\t(strnlen(x, sizeof(x)) < sizeof(x))\n\nstruct crypto_dump_info {\n\tstruct sk_buff *in_skb;\n\tstruct sk_buff *out_skb;\n\tu32 nlmsg_seq;\n\tu16 nlmsg_flags;\n};\n\nstatic int crypto_report_aead(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_stat_aead raead;\n\n\tmemset(&raead, 0, sizeof(raead));\n\n\tstrscpy(raead.type, \"aead\", sizeof(raead.type));\n\n\traead.stat_encrypt_cnt = atomic64_read(&alg->stats.aead.encrypt_cnt);\n\traead.stat_encrypt_tlen = atomic64_read(&alg->stats.aead.encrypt_tlen);\n\traead.stat_decrypt_cnt = atomic64_read(&alg->stats.aead.decrypt_cnt);\n\traead.stat_decrypt_tlen = atomic64_read(&alg->stats.aead.decrypt_tlen);\n\traead.stat_err_cnt = atomic64_read(&alg->stats.aead.err_cnt);\n\n\treturn nla_put(skb, CRYPTOCFGA_STAT_AEAD, sizeof(raead), &raead);\n}\n\nstatic int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_stat_cipher rcipher;\n\n\tmemset(&rcipher, 0, sizeof(rcipher));\n\n\tstrscpy(rcipher.type, \"cipher\", sizeof(rcipher.type));\n\n\trcipher.stat_encrypt_cnt = atomic64_read(&alg->stats.cipher.encrypt_cnt);\n\trcipher.stat_encrypt_tlen = atomic64_read(&alg->stats.cipher.encrypt_tlen);\n\trcipher.stat_decrypt_cnt =  atomic64_read(&alg->stats.cipher.decrypt_cnt);\n\trcipher.stat_decrypt_tlen = atomic64_read(&alg->stats.cipher.decrypt_tlen);\n\trcipher.stat_err_cnt =  atomic64_read(&alg->stats.cipher.err_cnt);\n\n\treturn nla_put(skb, CRYPTOCFGA_STAT_CIPHER, sizeof(rcipher), &rcipher);\n}\n\nstatic int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_stat_compress rcomp;\n\n\tmemset(&rcomp, 0, sizeof(rcomp));\n\n\tstrscpy(rcomp.type, \"compression\", sizeof(rcomp.type));\n\trcomp.stat_compress_cnt = atomic64_read(&alg->stats.compress.compress_cnt);\n\trcomp.stat_compress_tlen = atomic64_read(&alg->stats.compress.compress_tlen);\n\trcomp.stat_decompress_cnt = atomic64_read(&alg->stats.compress.decompress_cnt);\n\trcomp.stat_decompress_tlen = atomic64_read(&alg->stats.compress.decompress_tlen);\n\trcomp.stat_err_cnt = atomic64_read(&alg->stats.compress.err_cnt);\n\n\treturn nla_put(skb, CRYPTOCFGA_STAT_COMPRESS, sizeof(rcomp), &rcomp);\n}\n\nstatic int crypto_report_acomp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_stat_compress racomp;\n\n\tmemset(&racomp, 0, sizeof(racomp));\n\n\tstrscpy(racomp.type, \"acomp\", sizeof(racomp.type));\n\tracomp.stat_compress_cnt = atomic64_read(&alg->stats.compress.compress_cnt);\n\tracomp.stat_compress_tlen = atomic64_read(&alg->stats.compress.compress_tlen);\n\tracomp.stat_decompress_cnt =  atomic64_read(&alg->stats.compress.decompress_cnt);\n\tracomp.stat_decompress_tlen = atomic64_read(&alg->stats.compress.decompress_tlen);\n\tracomp.stat_err_cnt = atomic64_read(&alg->stats.compress.err_cnt);\n\n\treturn nla_put(skb, CRYPTOCFGA_STAT_ACOMP, sizeof(racomp), &racomp);\n}\n\nstatic int crypto_report_akcipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_stat_akcipher rakcipher;\n\n\tmemset(&rakcipher, 0, sizeof(rakcipher));\n\n\tstrscpy(rakcipher.type, \"akcipher\", sizeof(rakcipher.type));\n\trakcipher.stat_encrypt_cnt = atomic64_read(&alg->stats.akcipher.encrypt_cnt);\n\trakcipher.stat_encrypt_tlen = atomic64_read(&alg->stats.akcipher.encrypt_tlen);\n\trakcipher.stat_decrypt_cnt = atomic64_read(&alg->stats.akcipher.decrypt_cnt);\n\trakcipher.stat_decrypt_tlen = atomic64_read(&alg->stats.akcipher.decrypt_tlen);\n\trakcipher.stat_sign_cnt = atomic64_read(&alg->stats.akcipher.sign_cnt);\n\trakcipher.stat_verify_cnt = atomic64_read(&alg->stats.akcipher.verify_cnt);\n\trakcipher.stat_err_cnt = atomic64_read(&alg->stats.akcipher.err_cnt);\n\n\treturn nla_put(skb, CRYPTOCFGA_STAT_AKCIPHER,\n\t\t       sizeof(rakcipher), &rakcipher);\n}\n\nstatic int crypto_report_kpp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_stat_kpp rkpp;\n\n\tmemset(&rkpp, 0, sizeof(rkpp));\n\n\tstrscpy(rkpp.type, \"kpp\", sizeof(rkpp.type));\n\n\trkpp.stat_setsecret_cnt = atomic64_read(&alg->stats.kpp.setsecret_cnt);\n\trkpp.stat_generate_public_key_cnt = atomic64_read(&alg->stats.kpp.generate_public_key_cnt);\n\trkpp.stat_compute_shared_secret_cnt = atomic64_read(&alg->stats.kpp.compute_shared_secret_cnt);\n\trkpp.stat_err_cnt = atomic64_read(&alg->stats.kpp.err_cnt);\n\n\treturn nla_put(skb, CRYPTOCFGA_STAT_KPP, sizeof(rkpp), &rkpp);\n}\n\nstatic int crypto_report_ahash(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_stat_hash rhash;\n\n\tmemset(&rhash, 0, sizeof(rhash));\n\n\tstrscpy(rhash.type, \"ahash\", sizeof(rhash.type));\n\n\trhash.stat_hash_cnt = atomic64_read(&alg->stats.hash.hash_cnt);\n\trhash.stat_hash_tlen = atomic64_read(&alg->stats.hash.hash_tlen);\n\trhash.stat_err_cnt = atomic64_read(&alg->stats.hash.err_cnt);\n\n\treturn nla_put(skb, CRYPTOCFGA_STAT_HASH, sizeof(rhash), &rhash);\n}\n\nstatic int crypto_report_shash(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_stat_hash rhash;\n\n\tmemset(&rhash, 0, sizeof(rhash));\n\n\tstrscpy(rhash.type, \"shash\", sizeof(rhash.type));\n\n\trhash.stat_hash_cnt =  atomic64_read(&alg->stats.hash.hash_cnt);\n\trhash.stat_hash_tlen = atomic64_read(&alg->stats.hash.hash_tlen);\n\trhash.stat_err_cnt = atomic64_read(&alg->stats.hash.err_cnt);\n\n\treturn nla_put(skb, CRYPTOCFGA_STAT_HASH, sizeof(rhash), &rhash);\n}\n\nstatic int crypto_report_rng(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_stat_rng rrng;\n\n\tmemset(&rrng, 0, sizeof(rrng));\n\n\tstrscpy(rrng.type, \"rng\", sizeof(rrng.type));\n\n\trrng.stat_generate_cnt = atomic64_read(&alg->stats.rng.generate_cnt);\n\trrng.stat_generate_tlen = atomic64_read(&alg->stats.rng.generate_tlen);\n\trrng.stat_seed_cnt = atomic64_read(&alg->stats.rng.seed_cnt);\n\trrng.stat_err_cnt = atomic64_read(&alg->stats.rng.err_cnt);\n\n\treturn nla_put(skb, CRYPTOCFGA_STAT_RNG, sizeof(rrng), &rrng);\n}\n\nstatic int crypto_reportstat_one(struct crypto_alg *alg,\n\t\t\t\t struct crypto_user_alg *ualg,\n\t\t\t\t struct sk_buff *skb)\n{\n\tmemset(ualg, 0, sizeof(*ualg));\n\n\tstrscpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n\tstrscpy(ualg->cru_driver_name, alg->cra_driver_name,\n\t\tsizeof(ualg->cru_driver_name));\n\tstrscpy(ualg->cru_module_name, module_name(alg->cra_module),\n\t\tsizeof(ualg->cru_module_name));\n\n\tualg->cru_type = 0;\n\tualg->cru_mask = 0;\n\tualg->cru_flags = alg->cra_flags;\n\tualg->cru_refcnt = refcount_read(&alg->cra_refcnt);\n\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n\tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n\t\tstruct crypto_stat_larval rl;\n\n\t\tmemset(&rl, 0, sizeof(rl));\n\t\tstrscpy(rl.type, \"larval\", sizeof(rl.type));\n\t\tif (nla_put(skb, CRYPTOCFGA_STAT_LARVAL, sizeof(rl), &rl))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\n\tswitch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {\n\tcase CRYPTO_ALG_TYPE_AEAD:\n\t\tif (crypto_report_aead(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_SKCIPHER:\n\t\tif (crypto_report_cipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_BLKCIPHER:\n\t\tif (crypto_report_cipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_CIPHER:\n\t\tif (crypto_report_cipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_COMPRESS:\n\t\tif (crypto_report_comp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_ACOMPRESS:\n\t\tif (crypto_report_acomp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_SCOMPRESS:\n\t\tif (crypto_report_acomp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_AKCIPHER:\n\t\tif (crypto_report_akcipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_KPP:\n\t\tif (crypto_report_kpp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_AHASH:\n\t\tif (crypto_report_ahash(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_HASH:\n\t\tif (crypto_report_shash(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_RNG:\n\t\tif (crypto_report_rng(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"ERROR: Unhandled alg %d in %s\\n\",\n\t\t       alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL),\n\t\t       __func__);\n\t}\n\nout:\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int crypto_reportstat_alg(struct crypto_alg *alg,\n\t\t\t\t struct crypto_dump_info *info)\n{\n\tstruct sk_buff *in_skb = info->in_skb;\n\tstruct sk_buff *skb = info->out_skb;\n\tstruct nlmsghdr *nlh;\n\tstruct crypto_user_alg *ualg;\n\tint err = 0;\n\n\tnlh = nlmsg_put(skb, NETLINK_CB(in_skb).portid, info->nlmsg_seq,\n\t\t\tCRYPTO_MSG_GETSTAT, sizeof(*ualg), info->nlmsg_flags);\n\tif (!nlh) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\tualg = nlmsg_data(nlh);\n\n\terr = crypto_reportstat_one(alg, ualg, skb);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\tgoto out;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\nout:\n\treturn err;\n}\n\nint crypto_reportstat(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t      struct nlattr **attrs)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct crypto_user_alg *p = nlmsg_data(in_nlh);\n\tstruct crypto_alg *alg;\n\tstruct sk_buff *skb;\n\tstruct crypto_dump_info info;\n\tint err;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, 0);\n\tif (!alg)\n\t\treturn -ENOENT;\n\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto drop_alg;\n\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = in_nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = 0;\n\n\terr = crypto_reportstat_alg(alg, &info);\n\ndrop_alg:\n\tcrypto_mod_put(alg);\n\n\tif (err)\n\t\treturn err;\n\n\treturn nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n}\n\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * Crypto user configuration API.\n *\n * Copyright (C) 2017-2018 Corentin Labbe <clabbe@baylibre.com>\n *\n */\n\n#include <linux/crypto.h>\n#include <linux/cryptouser.h>\n#include <linux/sched.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <crypto/internal/skcipher.h>\n#include <crypto/internal/rng.h>\n#include <crypto/akcipher.h>\n#include <crypto/kpp.h>\n#include <crypto/internal/cryptouser.h>\n\n#include \"internal.h\"\n\n#define null_terminated(x)\t(strnlen(x, sizeof(x)) < sizeof(x))\n\nstruct crypto_dump_info {\n\tstruct sk_buff *in_skb;\n\tstruct sk_buff *out_skb;\n\tu32 nlmsg_seq;\n\tu16 nlmsg_flags;\n};\n\nstatic int crypto_report_aead(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_stat_aead raead;\n\n\tmemset(&raead, 0, sizeof(raead));\n\n\tstrscpy(raead.type, \"aead\", sizeof(raead.type));\n\n\traead.stat_encrypt_cnt = atomic64_read(&alg->stats.aead.encrypt_cnt);\n\traead.stat_encrypt_tlen = atomic64_read(&alg->stats.aead.encrypt_tlen);\n\traead.stat_decrypt_cnt = atomic64_read(&alg->stats.aead.decrypt_cnt);\n\traead.stat_decrypt_tlen = atomic64_read(&alg->stats.aead.decrypt_tlen);\n\traead.stat_err_cnt = atomic64_read(&alg->stats.aead.err_cnt);\n\n\treturn nla_put(skb, CRYPTOCFGA_STAT_AEAD, sizeof(raead), &raead);\n}\n\nstatic int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_stat_cipher rcipher;\n\n\tmemset(&rcipher, 0, sizeof(rcipher));\n\n\tstrscpy(rcipher.type, \"cipher\", sizeof(rcipher.type));\n\n\trcipher.stat_encrypt_cnt = atomic64_read(&alg->stats.cipher.encrypt_cnt);\n\trcipher.stat_encrypt_tlen = atomic64_read(&alg->stats.cipher.encrypt_tlen);\n\trcipher.stat_decrypt_cnt =  atomic64_read(&alg->stats.cipher.decrypt_cnt);\n\trcipher.stat_decrypt_tlen = atomic64_read(&alg->stats.cipher.decrypt_tlen);\n\trcipher.stat_err_cnt =  atomic64_read(&alg->stats.cipher.err_cnt);\n\n\treturn nla_put(skb, CRYPTOCFGA_STAT_CIPHER, sizeof(rcipher), &rcipher);\n}\n\nstatic int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_stat_compress rcomp;\n\n\tmemset(&rcomp, 0, sizeof(rcomp));\n\n\tstrscpy(rcomp.type, \"compression\", sizeof(rcomp.type));\n\trcomp.stat_compress_cnt = atomic64_read(&alg->stats.compress.compress_cnt);\n\trcomp.stat_compress_tlen = atomic64_read(&alg->stats.compress.compress_tlen);\n\trcomp.stat_decompress_cnt = atomic64_read(&alg->stats.compress.decompress_cnt);\n\trcomp.stat_decompress_tlen = atomic64_read(&alg->stats.compress.decompress_tlen);\n\trcomp.stat_err_cnt = atomic64_read(&alg->stats.compress.err_cnt);\n\n\treturn nla_put(skb, CRYPTOCFGA_STAT_COMPRESS, sizeof(rcomp), &rcomp);\n}\n\nstatic int crypto_report_acomp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_stat_compress racomp;\n\n\tmemset(&racomp, 0, sizeof(racomp));\n\n\tstrscpy(racomp.type, \"acomp\", sizeof(racomp.type));\n\tracomp.stat_compress_cnt = atomic64_read(&alg->stats.compress.compress_cnt);\n\tracomp.stat_compress_tlen = atomic64_read(&alg->stats.compress.compress_tlen);\n\tracomp.stat_decompress_cnt =  atomic64_read(&alg->stats.compress.decompress_cnt);\n\tracomp.stat_decompress_tlen = atomic64_read(&alg->stats.compress.decompress_tlen);\n\tracomp.stat_err_cnt = atomic64_read(&alg->stats.compress.err_cnt);\n\n\treturn nla_put(skb, CRYPTOCFGA_STAT_ACOMP, sizeof(racomp), &racomp);\n}\n\nstatic int crypto_report_akcipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_stat_akcipher rakcipher;\n\n\tmemset(&rakcipher, 0, sizeof(rakcipher));\n\n\tstrscpy(rakcipher.type, \"akcipher\", sizeof(rakcipher.type));\n\trakcipher.stat_encrypt_cnt = atomic64_read(&alg->stats.akcipher.encrypt_cnt);\n\trakcipher.stat_encrypt_tlen = atomic64_read(&alg->stats.akcipher.encrypt_tlen);\n\trakcipher.stat_decrypt_cnt = atomic64_read(&alg->stats.akcipher.decrypt_cnt);\n\trakcipher.stat_decrypt_tlen = atomic64_read(&alg->stats.akcipher.decrypt_tlen);\n\trakcipher.stat_sign_cnt = atomic64_read(&alg->stats.akcipher.sign_cnt);\n\trakcipher.stat_verify_cnt = atomic64_read(&alg->stats.akcipher.verify_cnt);\n\trakcipher.stat_err_cnt = atomic64_read(&alg->stats.akcipher.err_cnt);\n\n\treturn nla_put(skb, CRYPTOCFGA_STAT_AKCIPHER,\n\t\t       sizeof(rakcipher), &rakcipher);\n}\n\nstatic int crypto_report_kpp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_stat_kpp rkpp;\n\n\tmemset(&rkpp, 0, sizeof(rkpp));\n\n\tstrscpy(rkpp.type, \"kpp\", sizeof(rkpp.type));\n\n\trkpp.stat_setsecret_cnt = atomic64_read(&alg->stats.kpp.setsecret_cnt);\n\trkpp.stat_generate_public_key_cnt = atomic64_read(&alg->stats.kpp.generate_public_key_cnt);\n\trkpp.stat_compute_shared_secret_cnt = atomic64_read(&alg->stats.kpp.compute_shared_secret_cnt);\n\trkpp.stat_err_cnt = atomic64_read(&alg->stats.kpp.err_cnt);\n\n\treturn nla_put(skb, CRYPTOCFGA_STAT_KPP, sizeof(rkpp), &rkpp);\n}\n\nstatic int crypto_report_ahash(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_stat_hash rhash;\n\n\tmemset(&rhash, 0, sizeof(rhash));\n\n\tstrscpy(rhash.type, \"ahash\", sizeof(rhash.type));\n\n\trhash.stat_hash_cnt = atomic64_read(&alg->stats.hash.hash_cnt);\n\trhash.stat_hash_tlen = atomic64_read(&alg->stats.hash.hash_tlen);\n\trhash.stat_err_cnt = atomic64_read(&alg->stats.hash.err_cnt);\n\n\treturn nla_put(skb, CRYPTOCFGA_STAT_HASH, sizeof(rhash), &rhash);\n}\n\nstatic int crypto_report_shash(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_stat_hash rhash;\n\n\tmemset(&rhash, 0, sizeof(rhash));\n\n\tstrscpy(rhash.type, \"shash\", sizeof(rhash.type));\n\n\trhash.stat_hash_cnt =  atomic64_read(&alg->stats.hash.hash_cnt);\n\trhash.stat_hash_tlen = atomic64_read(&alg->stats.hash.hash_tlen);\n\trhash.stat_err_cnt = atomic64_read(&alg->stats.hash.err_cnt);\n\n\treturn nla_put(skb, CRYPTOCFGA_STAT_HASH, sizeof(rhash), &rhash);\n}\n\nstatic int crypto_report_rng(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_stat_rng rrng;\n\n\tmemset(&rrng, 0, sizeof(rrng));\n\n\tstrscpy(rrng.type, \"rng\", sizeof(rrng.type));\n\n\trrng.stat_generate_cnt = atomic64_read(&alg->stats.rng.generate_cnt);\n\trrng.stat_generate_tlen = atomic64_read(&alg->stats.rng.generate_tlen);\n\trrng.stat_seed_cnt = atomic64_read(&alg->stats.rng.seed_cnt);\n\trrng.stat_err_cnt = atomic64_read(&alg->stats.rng.err_cnt);\n\n\treturn nla_put(skb, CRYPTOCFGA_STAT_RNG, sizeof(rrng), &rrng);\n}\n\nstatic int crypto_reportstat_one(struct crypto_alg *alg,\n\t\t\t\t struct crypto_user_alg *ualg,\n\t\t\t\t struct sk_buff *skb)\n{\n\tmemset(ualg, 0, sizeof(*ualg));\n\n\tstrscpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n\tstrscpy(ualg->cru_driver_name, alg->cra_driver_name,\n\t\tsizeof(ualg->cru_driver_name));\n\tstrscpy(ualg->cru_module_name, module_name(alg->cra_module),\n\t\tsizeof(ualg->cru_module_name));\n\n\tualg->cru_type = 0;\n\tualg->cru_mask = 0;\n\tualg->cru_flags = alg->cra_flags;\n\tualg->cru_refcnt = refcount_read(&alg->cra_refcnt);\n\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n\tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n\t\tstruct crypto_stat_larval rl;\n\n\t\tmemset(&rl, 0, sizeof(rl));\n\t\tstrscpy(rl.type, \"larval\", sizeof(rl.type));\n\t\tif (nla_put(skb, CRYPTOCFGA_STAT_LARVAL, sizeof(rl), &rl))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\n\tswitch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {\n\tcase CRYPTO_ALG_TYPE_AEAD:\n\t\tif (crypto_report_aead(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_SKCIPHER:\n\t\tif (crypto_report_cipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_BLKCIPHER:\n\t\tif (crypto_report_cipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_CIPHER:\n\t\tif (crypto_report_cipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_COMPRESS:\n\t\tif (crypto_report_comp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_ACOMPRESS:\n\t\tif (crypto_report_acomp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_SCOMPRESS:\n\t\tif (crypto_report_acomp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_AKCIPHER:\n\t\tif (crypto_report_akcipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_KPP:\n\t\tif (crypto_report_kpp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_AHASH:\n\t\tif (crypto_report_ahash(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_HASH:\n\t\tif (crypto_report_shash(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_RNG:\n\t\tif (crypto_report_rng(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"ERROR: Unhandled alg %d in %s\\n\",\n\t\t       alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL),\n\t\t       __func__);\n\t}\n\nout:\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int crypto_reportstat_alg(struct crypto_alg *alg,\n\t\t\t\t struct crypto_dump_info *info)\n{\n\tstruct sk_buff *in_skb = info->in_skb;\n\tstruct sk_buff *skb = info->out_skb;\n\tstruct nlmsghdr *nlh;\n\tstruct crypto_user_alg *ualg;\n\tint err = 0;\n\n\tnlh = nlmsg_put(skb, NETLINK_CB(in_skb).portid, info->nlmsg_seq,\n\t\t\tCRYPTO_MSG_GETSTAT, sizeof(*ualg), info->nlmsg_flags);\n\tif (!nlh) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\tualg = nlmsg_data(nlh);\n\n\terr = crypto_reportstat_one(alg, ualg, skb);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\tgoto out;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\nout:\n\treturn err;\n}\n\nint crypto_reportstat(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t      struct nlattr **attrs)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct crypto_user_alg *p = nlmsg_data(in_nlh);\n\tstruct crypto_alg *alg;\n\tstruct sk_buff *skb;\n\tstruct crypto_dump_info info;\n\tint err;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, 0);\n\tif (!alg)\n\t\treturn -ENOENT;\n\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto drop_alg;\n\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = in_nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = 0;\n\n\terr = crypto_reportstat_alg(alg, &info);\n\ndrop_alg:\n\tcrypto_mod_put(alg);\n\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\treturn nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n}\n\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["crypto/crypto_user_stat.c"], "buggy_code_start_loc": [331], "buggy_code_end_loc": [332], "fixing_code_start_loc": [331], "fixing_code_end_loc": [335], "type": "CWE-401", "message": "A memory leak in the crypto_reportstat() function in crypto/crypto_user_stat.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering crypto_reportstat_alg() failures, aka CID-c03b04dcdba1.", "other": {"cve": {"id": "CVE-2019-19050", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-18T06:15:11.700", "lastModified": "2021-06-22T14:47:56.090", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A memory leak in the crypto_reportstat() function in crypto/crypto_user_stat.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering crypto_reportstat_alg() failures, aka CID-c03b04dcdba1."}, {"lang": "es", "value": "Una p\u00e9rdida de memoria en la funci\u00f3n crypto_reportstat() en el archivo crypto/crypto_user_stat.c en el kernel de Linux versiones hasta  5.3.11, permite a atacantes causar una denegaci\u00f3n de servicio (consumo de memoria) al desencadenar fallos de la funci\u00f3n crypto_reportstat_alg(), tambi\u00e9n se conoce como CID-c03b04dcdba1."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.20", "versionEndExcluding": "5.3.16", "matchCriteriaId": "22BF102C-6F4F-4F6F-BDC4-CA17FDC10DF5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.4", "versionEndExcluding": "5.4.3", "matchCriteriaId": "989D0C5E-C0BF-49D8-86E2-91A93238FD1E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.5:rc1:*:*:*:*:*:*", "matchCriteriaId": "17CCD88F-373D-4BB5-B62E-8B55B05E2C31"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:vmware_vsphere:*:*", "matchCriteriaId": "3A756737-1CC4-42C2-A4DF-E1C893B4E2D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:data_availability_services:-:*:*:*:*:*:*:*", "matchCriteriaId": "0EF46487-B64A-454E-AECC-D74B83170ACD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.0.0", "versionEndIncluding": "11.60.3", "matchCriteriaId": "BD1E9594-C46F-40D1-8BC2-6B16635B55C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "A3C19813-E823-456A-B1CE-EC0684CE1953"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire:-:*:*:*:*:*:*:*", "matchCriteriaId": "A6E9EF0C-AFA8-4F7B-9FDC-1E0F7C26E737"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:steelstore_cloud_integrated_storage:-:*:*:*:*:*:*:*", "matchCriteriaId": "E94F7F59-1785-493F-91A7-5F5EA5E87E4D"}, {"vulnerable": true, "criteria": "cpe:2.3:h:netapp:hci_compute_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "AD7447BC-F315-4298-A822-549942FC118B"}, {"vulnerable": true, "criteria": "cpe:2.3:h:netapp:hci_storage_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "02DEB4FB-A21D-4CB1-B522-EEE5093E8521"}, {"vulnerable": true, "criteria": "cpe:2.3:o:broadcom:fabric_operating_system:-:*:*:*:*:*:*:*", "matchCriteriaId": "046FB51E-B768-44D3-AEB5-D857145CA840"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:aff_a700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "952F55C9-7E7C-4539-9D08-E736B3488569"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:aff_a700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9FED1B0D-F901-413A-85D9-05D4C427570D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:fas8300_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "89706810-031B-49F0-B353-FD27FD7B2776"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:fas8300:-:*:*:*:*:*:*:*", "matchCriteriaId": "03BCC59D-C782-4149-B6DC-5DDAFAB48F2D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:fas8700_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "FDD1E822-1EA6-4E62-A58B-2378149D20DC"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:fas8700:-:*:*:*:*:*:*:*", "matchCriteriaId": "E07EAE5F-B1B5-4FDA-9B50-8CB1D2AFC5A0"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:aff_a400_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56FD9B9A-BBE5-4CA5-B9F9-B16E1FE738C8"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:aff_a400:-:*:*:*:*:*:*:*", "matchCriteriaId": "F3E70A56-DBA8-45C7-8C49-1A036501156F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h610s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "FD7CFE0E-9D1E-4495-B302-89C3096FC0DF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h610s:-:*:*:*:*:*:*:*", "matchCriteriaId": "F63A3FA7-AAED-4A9D-9FDE-6195302DA0F6"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/156455/Kernel-Live-Patch-Security-Notice-LSN-0063-1.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/c03b04dcdba1da39903e23cc4d072abf8f68f2dd", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/O3PSDE6PTOTVBK2YTKB2TFQP2SUBVSNF/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PY7LJMSPAGRIKABJPDKQDTXYW3L5RX2T/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191205-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4258-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4284-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/c03b04dcdba1da39903e23cc4d072abf8f68f2dd"}}