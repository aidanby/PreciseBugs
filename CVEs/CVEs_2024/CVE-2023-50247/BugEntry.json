{"buggy_code": ["/*\n * Copyright (c) 2017 Fastly, Kazuho Oku\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n#include <assert.h>\n#include <inttypes.h>\n#include <netinet/in.h>\n#include <netinet/ip.h>\n#include <pthread.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include \"khash.h\"\n#include \"quicly.h\"\n#include \"quicly/defaults.h\"\n#include \"quicly/sentmap.h\"\n#include \"quicly/frame.h\"\n#include \"quicly/streambuf.h\"\n#include \"quicly/cc.h\"\n#if QUICLY_USE_DTRACE\n#include \"quicly-probes.h\"\n#endif\n#include \"quicly/retire_cid.h\"\n\n#define QUICLY_TLS_EXTENSION_TYPE_TRANSPORT_PARAMETERS_FINAL 0x39\n#define QUICLY_TLS_EXTENSION_TYPE_TRANSPORT_PARAMETERS_DRAFT 0xffa5\n#define QUICLY_TRANSPORT_PARAMETER_ID_ORIGINAL_CONNECTION_ID 0\n#define QUICLY_TRANSPORT_PARAMETER_ID_MAX_IDLE_TIMEOUT 1\n#define QUICLY_TRANSPORT_PARAMETER_ID_STATELESS_RESET_TOKEN 2\n#define QUICLY_TRANSPORT_PARAMETER_ID_MAX_UDP_PAYLOAD_SIZE 3\n#define QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_DATA 4\n#define QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_BIDI_LOCAL 5\n#define QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_BIDI_REMOTE 6\n#define QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_UNI 7\n#define QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAMS_BIDI 8\n#define QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAMS_UNI 9\n#define QUICLY_TRANSPORT_PARAMETER_ID_ACK_DELAY_EXPONENT 10\n#define QUICLY_TRANSPORT_PARAMETER_ID_MAX_ACK_DELAY 11\n#define QUICLY_TRANSPORT_PARAMETER_ID_DISABLE_ACTIVE_MIGRATION 12\n#define QUICLY_TRANSPORT_PARAMETER_ID_PREFERRED_ADDRESS 13\n#define QUICLY_TRANSPORT_PARAMETER_ID_ACTIVE_CONNECTION_ID_LIMIT 14\n#define QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_SOURCE_CONNECTION_ID 15\n#define QUICLY_TRANSPORT_PARAMETER_ID_RETRY_SOURCE_CONNECTION_ID 16\n#define QUICLY_TRANSPORT_PARAMETER_ID_MAX_DATAGRAM_FRAME_SIZE 0x20\n#define QUICLY_TRANSPORT_PARAMETER_ID_MIN_ACK_DELAY 0xff03de1a\n\n/**\n * maximum size of token that quicly accepts\n */\n#define QUICLY_MAX_TOKEN_LEN 512\n/**\n * sends ACK bundled with PING, when number of gaps in the ack queue reaches or exceeds this threshold. This value should be much\n * smaller than QUICLY_MAX_RANGES.\n */\n#define QUICLY_NUM_ACK_BLOCKS_TO_INDUCE_ACKACK 8\n\nKHASH_MAP_INIT_INT64(quicly_stream_t, quicly_stream_t *)\n\n#if QUICLY_USE_TRACER\n#define QUICLY_TRACER(label, conn, ...) QUICLY_TRACER_##label(conn, __VA_ARGS__)\n#else\n#define QUICLY_TRACER(...)\n#endif\n\n#if QUICLY_USE_DTRACE\n#define QUICLY_PROBE(label, conn, ...)                                                                                             \\\n    do {                                                                                                                           \\\n        quicly_conn_t *_conn = (conn);                                                                                             \\\n        if (PTLS_UNLIKELY(QUICLY_##label##_ENABLED()) && !ptls_skip_tracing(_conn->crypto.tls))                                    \\\n            QUICLY_##label(_conn, __VA_ARGS__);                                                                                    \\\n        QUICLY_TRACER(label, _conn, __VA_ARGS__);                                                                                  \\\n    } while (0)\n#else\n#define QUICLY_PROBE(label, conn, ...) QUICLY_TRACER(label, conn, __VA_ARGS__)\n#endif\n#define QUICLY_PROBE_HEXDUMP(s, l)                                                                                                 \\\n    ({                                                                                                                             \\\n        size_t _l = (l);                                                                                                           \\\n        ptls_hexdump(alloca(_l * 2 + 1), (s), _l);                                                                                 \\\n    })\n#define QUICLY_PROBE_ESCAPE_UNSAFE_STRING(s, l)                                                                                    \\\n    ({                                                                                                                             \\\n        size_t _l = (l);                                                                                                           \\\n        quicly_escape_unsafe_string(alloca(_l * 4 + 1), (s), _l);                                                                  \\\n    })\n\nstruct st_quicly_cipher_context_t {\n    ptls_aead_context_t *aead;\n    ptls_cipher_context_t *header_protection;\n};\n\nstruct st_quicly_pending_path_challenge_t {\n    struct st_quicly_pending_path_challenge_t *next;\n    uint8_t is_response;\n    uint8_t data[QUICLY_PATH_CHALLENGE_DATA_LEN];\n};\n\nstruct st_quicly_pn_space_t {\n    /**\n     * acks to be sent to remote peer\n     */\n    quicly_ranges_t ack_queue;\n    /**\n     * time at when the largest pn in the ack_queue has been received (or INT64_MAX if none)\n     */\n    int64_t largest_pn_received_at;\n    /**\n     *\n     */\n    uint64_t next_expected_packet_number;\n    /**\n     * number of ACK-eliciting packets that have not been ACKed yet\n     */\n    uint32_t unacked_count;\n    /**\n     * ECN in the order of ECT(0), ECT(1), CE\n     */\n    uint64_t ecn_counts[3];\n    /**\n     * maximum number of ACK-eliciting packets to be queued before sending an ACK\n     */\n    uint32_t packet_tolerance;\n    /**\n     * boolean indicating if reorder should NOT trigger an immediate ack\n     */\n    uint8_t ignore_order;\n};\n\nstruct st_quicly_handshake_space_t {\n    struct st_quicly_pn_space_t super;\n    struct {\n        struct st_quicly_cipher_context_t ingress;\n        struct st_quicly_cipher_context_t egress;\n    } cipher;\n    uint16_t largest_ingress_udp_payload_size;\n};\n\nstruct st_quicly_application_space_t {\n    struct st_quicly_pn_space_t super;\n    struct {\n        struct {\n            struct {\n                ptls_cipher_context_t *zero_rtt, *one_rtt;\n            } header_protection;\n            ptls_aead_context_t *aead[2]; /* 0-RTT uses aead[1], 1-RTT uses aead[key_phase] */\n            uint8_t secret[PTLS_MAX_DIGEST_SIZE];\n            struct {\n                uint64_t prepared;\n                uint64_t decrypted;\n            } key_phase;\n        } ingress;\n        struct {\n            struct st_quicly_cipher_context_t key;\n            uint8_t secret[PTLS_MAX_DIGEST_SIZE];\n            uint64_t key_phase;\n            struct {\n                /**\n                 * PN at which key update was initiated. Set to UINT64_MAX once key update is acked.\n                 */\n                uint64_t last;\n                /**\n                 * PN at which key update should be initiated. Set to UINT64_MAX when key update cannot be initiated.\n                 */\n                uint64_t next;\n            } key_update_pn;\n        } egress;\n    } cipher;\n    int one_rtt_writable;\n};\n\nstruct st_quicly_conn_t {\n    struct _st_quicly_conn_public_t super;\n    /**\n     * the initial context\n     */\n    struct st_quicly_handshake_space_t *initial;\n    /**\n     * the handshake context\n     */\n    struct st_quicly_handshake_space_t *handshake;\n    /**\n     * 0-RTT and 1-RTT context\n     */\n    struct st_quicly_application_space_t *application;\n    /**\n     * hashtable of streams\n     */\n    khash_t(quicly_stream_t) * streams;\n    /**\n     *\n     */\n    struct {\n        /**\n         *\n         */\n        struct {\n            uint64_t bytes_consumed;\n            quicly_maxsender_t sender;\n        } max_data;\n        /**\n         *\n         */\n        struct {\n            quicly_maxsender_t uni, bidi;\n        } max_streams;\n        /**\n         *\n         */\n        struct {\n            uint64_t next_sequence;\n        } ack_frequency;\n    } ingress;\n    /**\n     *\n     */\n    struct {\n        /**\n         * loss recovery\n         */\n        quicly_loss_t loss;\n        /**\n         * next or the currently encoding packet number\n         */\n        uint64_t packet_number;\n        /**\n         * next PN to be skipped\n         */\n        uint64_t next_pn_to_skip;\n        /**\n         *\n         */\n        uint16_t max_udp_payload_size;\n        /**\n         * valid if state is CLOSING\n         */\n        struct {\n            uint16_t error_code;\n            uint64_t frame_type; /* UINT64_MAX if application close */\n            const char *reason_phrase;\n            unsigned long num_packets_received;\n        } connection_close;\n        /**\n         *\n         */\n        struct {\n            uint64_t permitted;\n            uint64_t sent;\n        } max_data;\n        /**\n         *\n         */\n        struct {\n            struct st_quicly_max_streams_t {\n                uint64_t count;\n                quicly_maxsender_t blocked_sender;\n            } uni, bidi;\n        } max_streams;\n        /**\n         *\n         */\n        struct {\n            struct st_quicly_pending_path_challenge_t *head, **tail_ref;\n        } path_challenge;\n        /**\n         *\n         */\n        struct {\n            uint64_t generation;\n            uint64_t max_acked;\n            uint32_t num_inflight;\n        } new_token;\n        /**\n         *\n         */\n        struct {\n            int64_t update_at;\n            uint64_t sequence;\n        } ack_frequency;\n        /**\n         *\n         */\n        int64_t last_retransmittable_sent_at;\n        /**\n         * when to send an ACK, or other frames used for managing the connection\n         */\n        int64_t send_ack_at;\n        /**\n         * congestion control\n         */\n        quicly_cc_t cc;\n        /**\n         * ECN\n         */\n        struct {\n            enum en_quicly_ecn_state { QUICLY_ECN_OFF, QUICLY_ECN_ON, QUICLY_ECN_PROBING } state;\n            uint64_t counts[QUICLY_NUM_EPOCHS][3];\n        } ecn;\n        /**\n         * things to be sent at the stream-level, that are not governed by the stream scheduler\n         */\n        struct {\n            /**\n             * list of blocked streams (sorted in ascending order of stream_ids)\n             */\n            struct {\n                quicly_linklist_t uni;\n                quicly_linklist_t bidi;\n            } blocked;\n            /**\n             * list of streams with pending control data (e.g., RESET_STREAM)\n             */\n            quicly_linklist_t control;\n        } pending_streams;\n        /**\n         * send state for DATA_BLOCKED frame that corresponds to the current value of `conn->egress.max_data.permitted`\n         */\n        quicly_sender_state_t data_blocked;\n        /**\n         * bit vector indicating if there's any pending crypto data (the insignificant 4 bits), or other non-stream data\n         */\n        uint8_t pending_flows;\n/* The flags below indicate if the respective frames have to be sent or not. There are no false positives. */\n#define QUICLY_PENDING_FLOW_NEW_TOKEN_BIT (1 << 4)\n#define QUICLY_PENDING_FLOW_HANDSHAKE_DONE_BIT (1 << 5)\n/* Indicates that PATH_CHALLENGE, PATH_RESPONSE, MAX_STREAMS, MAX_DATA, DATA_BLOCKED, STREAMS_BLOCKED, NEW_CONNECTION_ID _might_\n * have to be sent. There could be false positives; logic for sending each of these frames have the capability of detecting such\n * false positives. The purpose of this bit is to consolidate information as an optimization. */\n#define QUICLY_PENDING_FLOW_OTHERS_BIT (1 << 6)\n        /**\n         * pending RETIRE_CONNECTION_ID frames to be sent\n         */\n        quicly_retire_cid_set_t retire_cid;\n        /**\n         * payload of DATAGRAM frames to be sent\n         */\n        struct {\n            ptls_iovec_t payloads[10];\n            size_t count;\n        } datagram_frame_payloads;\n        /**\n         * delivery rate estimator\n         */\n        quicly_ratemeter_t ratemeter;\n    } egress;\n    /**\n     * crypto data\n     */\n    struct {\n        ptls_t *tls;\n        ptls_handshake_properties_t handshake_properties;\n        struct {\n            ptls_raw_extension_t ext[3];\n            ptls_buffer_t buf;\n        } transport_params;\n        unsigned async_in_progress : 1;\n    } crypto;\n    /**\n     * token (if the token is a Retry token can be determined by consulting the length of retry_scid)\n     */\n    ptls_iovec_t token;\n    /**\n     * len=UINT8_MAX if Retry was not used, use client_received_retry() to check\n     */\n    quicly_cid_t retry_scid;\n    /**\n     *\n     */\n    struct {\n        /**\n         * The moment when the idle timeout fires (including the additional 3 PTO). The value is set to INT64_MAX while the\n         * handshake is in progress.\n         */\n        int64_t at;\n        /**\n         * idle timeout\n         */\n        uint8_t should_rearm_on_send : 1;\n    } idle_timeout;\n    /**\n     * records the time when this connection was created\n     */\n    int64_t created_at;\n    /**\n     * structure to hold various data used internally\n     */\n    struct {\n        /**\n         * This value holds current time that remains constant while quicly functions that deal with time are running. Only\n         * available when the lock is held using `lock_now`.\n         */\n        int64_t now;\n        /**\n         *\n         */\n        uint8_t lock_count;\n        struct {\n            /**\n             * This cache is used to concatenate acked ranges of streams before processing them, reducing the frequency of function\n             * calls to `quicly_sendstate_t` and to the application-level send window management callbacks. This approach works,\n             * because in most cases acks will contain contiguous ranges of a single stream.\n             */\n            struct {\n                /**\n                 * set to INT64_MIN when the cache is invalid\n                 */\n                quicly_stream_id_t stream_id;\n                quicly_sendstate_sent_t args;\n            } active_acked_cache;\n        } on_ack_stream;\n    } stash;\n};\n\n#if QUICLY_USE_TRACER\n#include \"quicly-tracer.h\"\n#endif\n\nstruct st_quicly_handle_payload_state_t {\n    const uint8_t *src, *const end;\n    size_t epoch;\n    uint64_t frame_type;\n};\n\nstruct st_ptls_salt_t {\n    uint8_t initial[20];\n    struct {\n        uint8_t key[PTLS_AES128_KEY_SIZE];\n        uint8_t iv[PTLS_AESGCM_IV_SIZE];\n    } retry;\n};\n\nstatic void crypto_stream_receive(quicly_stream_t *stream, size_t off, const void *src, size_t len);\n\nstatic const quicly_stream_callbacks_t crypto_stream_callbacks = {quicly_streambuf_destroy, quicly_streambuf_egress_shift,\n                                                                  quicly_streambuf_egress_emit, NULL, crypto_stream_receive};\n\nstatic int update_traffic_key_cb(ptls_update_traffic_key_t *self, ptls_t *tls, int is_enc, size_t epoch, const void *secret);\nstatic int initiate_close(quicly_conn_t *conn, int err, uint64_t frame_type, const char *reason_phrase);\nstatic int handle_close(quicly_conn_t *conn, int err, uint64_t frame_type, ptls_iovec_t reason_phrase);\nstatic int discard_sentmap_by_epoch(quicly_conn_t *conn, unsigned ack_epochs);\n\nquicly_cid_plaintext_t quicly_cid_plaintext_invalid = {.node_id = UINT64_MAX, .thread_id = 0xffffff};\n\nstatic const quicly_transport_parameters_t default_transport_params = {.max_udp_payload_size = QUICLY_DEFAULT_MAX_UDP_PAYLOAD_SIZE,\n                                                                       .ack_delay_exponent = QUICLY_DEFAULT_ACK_DELAY_EXPONENT,\n                                                                       .max_ack_delay = QUICLY_DEFAULT_MAX_ACK_DELAY,\n                                                                       .min_ack_delay_usec = UINT64_MAX,\n                                                                       .active_connection_id_limit =\n                                                                           QUICLY_DEFAULT_ACTIVE_CONNECTION_ID_LIMIT};\n\nstatic const struct st_ptls_salt_t *get_salt(uint32_t protocol_version)\n{\n    static const struct st_ptls_salt_t\n        v1 = {.initial = {0x38, 0x76, 0x2c, 0xf7, 0xf5, 0x59, 0x34, 0xb3, 0x4d, 0x17,\n                          0x9a, 0xe6, 0xa4, 0xc8, 0x0c, 0xad, 0xcc, 0xbb, 0x7f, 0x0a},\n              .retry = {.key = {0xbe, 0x0c, 0x69, 0x0b, 0x9f, 0x66, 0x57, 0x5a, 0x1d, 0x76, 0x6b, 0x54, 0xe3, 0x68, 0xc8, 0x4e},\n                        .iv = {0x46, 0x15, 0x99, 0xd3, 0x5d, 0x63, 0x2b, 0xf2, 0x23, 0x98, 0x25, 0xbb}}},\n        draft29 = {.initial = {0xaf, 0xbf, 0xec, 0x28, 0x99, 0x93, 0xd2, 0x4c, 0x9e, 0x97,\n                               0x86, 0xf1, 0x9c, 0x61, 0x11, 0xe0, 0x43, 0x90, 0xa8, 0x99},\n                   .retry = {.key = {0xcc, 0xce, 0x18, 0x7e, 0xd0, 0x9a, 0x09, 0xd0, 0x57, 0x28, 0x15, 0x5a, 0x6c, 0xb9, 0x6b,\n                                     0xe1},\n                             .iv = {0xe5, 0x49, 0x30, 0xf9, 0x7f, 0x21, 0x36, 0xf0, 0x53, 0x0a, 0x8c, 0x1c}}},\n        draft27 = {\n            .initial = {0xc3, 0xee, 0xf7, 0x12, 0xc7, 0x2e, 0xbb, 0x5a, 0x11, 0xa7,\n                        0xd2, 0x43, 0x2b, 0xb4, 0x63, 0x65, 0xbe, 0xf9, 0xf5, 0x02},\n            .retry = {.key = {0x4d, 0x32, 0xec, 0xdb, 0x2a, 0x21, 0x33, 0xc8, 0x41, 0xe4, 0x04, 0x3d, 0xf2, 0x7d, 0x44, 0x30},\n                      .iv = {0x4d, 0x16, 0x11, 0xd0, 0x55, 0x13, 0xa5, 0x52, 0xc5, 0x87, 0xd5, 0x75}}};\n\n    switch (protocol_version) {\n    case QUICLY_PROTOCOL_VERSION_1:\n        return &v1;\n    case QUICLY_PROTOCOL_VERSION_DRAFT29:\n        return &draft29;\n    case QUICLY_PROTOCOL_VERSION_DRAFT27:\n        return &draft27;\n        break;\n    default:\n        return NULL;\n    }\n}\n\nstatic void lock_now(quicly_conn_t *conn, int is_reentrant)\n{\n    if (conn->stash.now == 0) {\n        assert(conn->stash.lock_count == 0);\n        conn->stash.now = conn->super.ctx->now->cb(conn->super.ctx->now);\n    } else {\n        assert(is_reentrant && \"caller must be reentrant\");\n        assert(conn->stash.lock_count != 0);\n    }\n\n    ++conn->stash.lock_count;\n}\n\nstatic void unlock_now(quicly_conn_t *conn)\n{\n    assert(conn->stash.now != 0);\n\n    if (--conn->stash.lock_count == 0)\n        conn->stash.now = 0;\n}\n\nstatic void set_address(quicly_address_t *addr, struct sockaddr *sa)\n{\n    if (sa == NULL) {\n        addr->sa.sa_family = AF_UNSPEC;\n        return;\n    }\n\n    switch (sa->sa_family) {\n    case AF_UNSPEC:\n        addr->sa.sa_family = AF_UNSPEC;\n        break;\n    case AF_INET:\n        addr->sin = *(struct sockaddr_in *)sa;\n        break;\n    case AF_INET6:\n        addr->sin6 = *(struct sockaddr_in6 *)sa;\n        break;\n    default:\n        memset(addr, 0xff, sizeof(*addr));\n        assert(!\"unexpected address type\");\n        break;\n    }\n}\n\nstatic ptls_cipher_suite_t *get_aes128gcmsha256(quicly_context_t *ctx)\n{\n    ptls_cipher_suite_t **cs;\n\n    for (cs = ctx->tls->cipher_suites;; ++cs) {\n        assert(cs != NULL);\n        if ((*cs)->id == PTLS_CIPHER_SUITE_AES_128_GCM_SHA256)\n            break;\n    }\n    return *cs;\n}\n\nstatic inline uint8_t get_epoch(uint8_t first_byte)\n{\n    if (!QUICLY_PACKET_IS_LONG_HEADER(first_byte))\n        return QUICLY_EPOCH_1RTT;\n\n    switch (first_byte & QUICLY_PACKET_TYPE_BITMASK) {\n    case QUICLY_PACKET_TYPE_INITIAL:\n        return QUICLY_EPOCH_INITIAL;\n    case QUICLY_PACKET_TYPE_HANDSHAKE:\n        return QUICLY_EPOCH_HANDSHAKE;\n    case QUICLY_PACKET_TYPE_0RTT:\n        return QUICLY_EPOCH_0RTT;\n    default:\n        assert(!\"FIXME\");\n    }\n}\n\nstatic ptls_aead_context_t *create_retry_aead(quicly_context_t *ctx, uint32_t protocol_version, int is_enc)\n{\n    const struct st_ptls_salt_t *salt = get_salt(protocol_version);\n    assert(salt != NULL);\n\n    ptls_cipher_suite_t *algo = get_aes128gcmsha256(ctx);\n    ptls_aead_context_t *aead = ptls_aead_new_direct(algo->aead, is_enc, salt->retry.key, salt->retry.iv);\n    assert(aead != NULL);\n    return aead;\n}\n\nstatic void dispose_cipher(struct st_quicly_cipher_context_t *ctx)\n{\n    ptls_aead_free(ctx->aead);\n    ptls_cipher_free(ctx->header_protection);\n}\n\nstatic void clear_datagram_frame_payloads(quicly_conn_t *conn)\n{\n    for (size_t i = 0; i != conn->egress.datagram_frame_payloads.count; ++i) {\n        free(conn->egress.datagram_frame_payloads.payloads[i].base);\n        conn->egress.datagram_frame_payloads.payloads[i] = ptls_iovec_init(NULL, 0);\n    }\n    conn->egress.datagram_frame_payloads.count = 0;\n}\n\nstatic int is_retry(quicly_conn_t *conn)\n{\n    return conn->retry_scid.len != UINT8_MAX;\n}\n\nstatic int needs_cid_auth(quicly_conn_t *conn)\n{\n    switch (conn->super.version) {\n    case QUICLY_PROTOCOL_VERSION_1:\n    case QUICLY_PROTOCOL_VERSION_DRAFT29:\n        return 1;\n    default:\n        return 0;\n    }\n}\n\nstatic int64_t get_sentmap_expiration_time(quicly_conn_t *conn)\n{\n    return quicly_loss_get_sentmap_expiration_time(&conn->egress.loss, conn->super.remote.transport_params.max_ack_delay);\n}\n\n/**\n * converts ECN bits to index in the order of ACK-ECN field (i.e., ECT(0) -> 0, ECT(1) -> 1, CE -> 2)\n */\nstatic size_t get_ecn_index_from_bits(uint8_t bits)\n{\n    assert(1 <= bits && bits <= 3);\n    return (18 >> bits) & 3;\n}\n\nstatic void update_ecn_state(quicly_conn_t *conn, enum en_quicly_ecn_state new_state)\n{\n    assert(new_state == QUICLY_ECN_ON || new_state == QUICLY_ECN_OFF);\n\n    conn->egress.ecn.state = new_state;\n    if (new_state == QUICLY_ECN_ON) {\n        ++conn->super.stats.num_paths.ecn_validated;\n    } else {\n        ++conn->super.stats.num_paths.ecn_failed;\n    }\n\n    QUICLY_PROBE(ECN_VALIDATION, conn, conn->stash.now, (int)new_state);\n    QUICLY_LOG_CONN(ecn_validation, conn, { PTLS_LOG_ELEMENT_SIGNED(state, (int)new_state); });\n}\n\nstatic void ack_frequency_set_next_update_at(quicly_conn_t *conn)\n{\n    if (conn->super.remote.transport_params.min_ack_delay_usec != UINT64_MAX)\n        conn->egress.ack_frequency.update_at = conn->stash.now + get_sentmap_expiration_time(conn);\n}\n\nsize_t quicly_decode_packet(quicly_context_t *ctx, quicly_decoded_packet_t *packet, const uint8_t *datagram, size_t datagram_size,\n                            size_t *off)\n{\n    const uint8_t *src = datagram, *src_end = datagram + datagram_size;\n\n    assert(*off <= datagram_size);\n\n    packet->octets = ptls_iovec_init(src + *off, datagram_size - *off);\n    if (packet->octets.len < 2)\n        goto Error;\n    packet->datagram_size = *off == 0 ? datagram_size : 0;\n    packet->token = ptls_iovec_init(NULL, 0);\n    packet->decrypted.pn = UINT64_MAX;\n    packet->ecn = 0; /* non-ECT */\n\n    /* move the cursor to the second byte */\n    src += *off + 1;\n\n    if (QUICLY_PACKET_IS_LONG_HEADER(packet->octets.base[0])) {\n        /* long header */\n        uint64_t rest_length;\n        if (src_end - src < 5)\n            goto Error;\n        packet->version = quicly_decode32(&src);\n        packet->cid.dest.encrypted.len = *src++;\n        if (src_end - src < packet->cid.dest.encrypted.len + 1)\n            goto Error;\n        packet->cid.dest.encrypted.base = (uint8_t *)src;\n        src += packet->cid.dest.encrypted.len;\n        packet->cid.src.len = *src++;\n        if (src_end - src < packet->cid.src.len)\n            goto Error;\n        packet->cid.src.base = (uint8_t *)src;\n        src += packet->cid.src.len;\n        switch (packet->octets.base[0] & QUICLY_PACKET_TYPE_BITMASK) {\n        case QUICLY_PACKET_TYPE_INITIAL:\n        case QUICLY_PACKET_TYPE_0RTT:\n            if (ctx->cid_encryptor == NULL || packet->cid.dest.encrypted.len == 0 ||\n                ctx->cid_encryptor->decrypt_cid(ctx->cid_encryptor, &packet->cid.dest.plaintext, packet->cid.dest.encrypted.base,\n                                                packet->cid.dest.encrypted.len) == SIZE_MAX)\n                packet->cid.dest.plaintext = quicly_cid_plaintext_invalid;\n            packet->cid.dest.might_be_client_generated = 1;\n            break;\n        default:\n            if (ctx->cid_encryptor != NULL) {\n                if (packet->cid.dest.encrypted.len == 0)\n                    goto Error;\n                if (ctx->cid_encryptor->decrypt_cid(ctx->cid_encryptor, &packet->cid.dest.plaintext,\n                                                    packet->cid.dest.encrypted.base, packet->cid.dest.encrypted.len) == SIZE_MAX)\n                    goto Error;\n            } else {\n                packet->cid.dest.plaintext = quicly_cid_plaintext_invalid;\n            }\n            packet->cid.dest.might_be_client_generated = 0;\n            break;\n        }\n        switch (packet->version) {\n        case QUICLY_PROTOCOL_VERSION_1:\n        case QUICLY_PROTOCOL_VERSION_DRAFT29:\n        case QUICLY_PROTOCOL_VERSION_DRAFT27:\n            /* these are the recognized versions, and they share the same packet header format */\n            if ((packet->octets.base[0] & QUICLY_PACKET_TYPE_BITMASK) == QUICLY_PACKET_TYPE_RETRY) {\n                /* retry */\n                if (src_end - src <= PTLS_AESGCM_TAG_SIZE)\n                    goto Error;\n                packet->token = ptls_iovec_init(src, src_end - src - PTLS_AESGCM_TAG_SIZE);\n                src += packet->token.len;\n                packet->encrypted_off = src - packet->octets.base;\n            } else {\n                /* coalescible long header packet */\n                if ((packet->octets.base[0] & QUICLY_PACKET_TYPE_BITMASK) == QUICLY_PACKET_TYPE_INITIAL) {\n                    /* initial has a token */\n                    uint64_t token_len;\n                    if ((token_len = quicly_decodev(&src, src_end)) == UINT64_MAX)\n                        goto Error;\n                    if (src_end - src < token_len)\n                        goto Error;\n                    packet->token = ptls_iovec_init(src, token_len);\n                    src += token_len;\n                }\n                if ((rest_length = quicly_decodev(&src, src_end)) == UINT64_MAX)\n                    goto Error;\n                if (rest_length < 1)\n                    goto Error;\n                if (src_end - src < rest_length)\n                    goto Error;\n                packet->encrypted_off = src - packet->octets.base;\n                packet->octets.len = packet->encrypted_off + rest_length;\n            }\n            break;\n        default:\n            /* VN packet or packets of unknown version cannot be parsed. `encrypted_off` is set to the first byte after SCID. */\n            packet->encrypted_off = src - packet->octets.base;\n        }\n        packet->_is_stateless_reset_cached = QUICLY__DECODED_PACKET_CACHED_NOT_STATELESS_RESET;\n    } else {\n        /* short header */\n        if (ctx->cid_encryptor != NULL) {\n            if (src_end - src < QUICLY_MAX_CID_LEN_V1)\n                goto Error;\n            size_t local_cidl = ctx->cid_encryptor->decrypt_cid(ctx->cid_encryptor, &packet->cid.dest.plaintext, src, 0);\n            if (local_cidl == SIZE_MAX)\n                goto Error;\n            packet->cid.dest.encrypted = ptls_iovec_init(src, local_cidl);\n            src += local_cidl;\n        } else {\n            packet->cid.dest.encrypted = ptls_iovec_init(NULL, 0);\n            packet->cid.dest.plaintext = quicly_cid_plaintext_invalid;\n        }\n        packet->cid.dest.might_be_client_generated = 0;\n        packet->cid.src = ptls_iovec_init(NULL, 0);\n        packet->version = 0;\n        packet->encrypted_off = src - packet->octets.base;\n        packet->_is_stateless_reset_cached = QUICLY__DECODED_PACKET_CACHED_MAYBE_STATELESS_RESET;\n    }\n\n    *off += packet->octets.len;\n    return packet->octets.len;\n\nError:\n    return SIZE_MAX;\n}\n\nuint64_t quicly_determine_packet_number(uint32_t truncated, size_t num_bits, uint64_t expected)\n{\n    uint64_t win = (uint64_t)1 << num_bits, candidate = (expected & ~(win - 1)) | truncated;\n\n    if (candidate + win / 2 <= expected)\n        return candidate + win;\n    if (candidate > expected + win / 2 && candidate >= win)\n        return candidate - win;\n    return candidate;\n}\n\nstatic void assert_consistency(quicly_conn_t *conn, int timer_must_be_in_future)\n{\n    if (conn->super.state >= QUICLY_STATE_CLOSING) {\n        assert(!timer_must_be_in_future || conn->stash.now < conn->egress.send_ack_at);\n        return;\n    }\n\n    if (conn->egress.loss.sentmap.bytes_in_flight != 0 || conn->super.remote.address_validation.send_probe) {\n        assert(conn->egress.loss.alarm_at != INT64_MAX);\n    } else {\n        assert(conn->egress.loss.loss_time == INT64_MAX);\n    }\n    /* Allow timers not in the future when the remote peer is not yet validated, since we may not be able to send packets even when\n     * timers fire. */\n    if (timer_must_be_in_future && conn->super.remote.address_validation.validated)\n        assert(conn->stash.now < conn->egress.loss.alarm_at);\n}\n\nstatic int on_invalid_ack(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    if (acked)\n        return QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;\n    return 0;\n}\n\nstatic uint64_t calc_next_pn_to_skip(ptls_context_t *tlsctx, uint64_t next_pn, uint32_t cwnd, uint64_t mtu)\n{\n    static __thread struct {\n        uint32_t values[8];\n        size_t off;\n    } cached_rand;\n\n    if (cached_rand.off == 0) {\n        tlsctx->random_bytes(cached_rand.values, sizeof(cached_rand.values));\n        cached_rand.off = PTLS_ELEMENTSOF(cached_rand.values);\n    }\n\n    /* on average, skip one PN per every min(256 packets, 8 * CWND) */\n    uint32_t packet_cwnd = cwnd / mtu;\n    if (packet_cwnd < 32)\n        packet_cwnd = 32;\n    uint64_t skip_after = cached_rand.values[--cached_rand.off] % (16 * packet_cwnd);\n    return next_pn + 1 + skip_after;\n}\n\nstatic void init_max_streams(struct st_quicly_max_streams_t *m)\n{\n    m->count = 0;\n    quicly_maxsender_init(&m->blocked_sender, -1);\n}\n\nstatic int update_max_streams(struct st_quicly_max_streams_t *m, uint64_t count)\n{\n    if (count > (uint64_t)1 << 60)\n        return QUICLY_TRANSPORT_ERROR_STREAM_LIMIT;\n\n    if (m->count < count) {\n        m->count = count;\n        if (m->blocked_sender.max_acked < count)\n            m->blocked_sender.max_acked = count;\n    }\n\n    return 0;\n}\n\nint quicly_connection_is_ready(quicly_conn_t *conn)\n{\n    return conn->application != NULL;\n}\n\nstatic int stream_is_destroyable(quicly_stream_t *stream)\n{\n    if (!quicly_recvstate_transfer_complete(&stream->recvstate))\n        return 0;\n    if (!quicly_sendstate_transfer_complete(&stream->sendstate))\n        return 0;\n    switch (stream->_send_aux.reset_stream.sender_state) {\n    case QUICLY_SENDER_STATE_NONE:\n    case QUICLY_SENDER_STATE_ACKED:\n        break;\n    default:\n        return 0;\n    }\n    return 1;\n}\n\nstatic void sched_stream_control(quicly_stream_t *stream)\n{\n    assert(stream->stream_id >= 0);\n\n    if (!quicly_linklist_is_linked(&stream->_send_aux.pending_link.control))\n        quicly_linklist_insert(stream->conn->egress.pending_streams.control.prev, &stream->_send_aux.pending_link.control);\n}\n\nstatic void resched_stream_data(quicly_stream_t *stream)\n{\n    if (stream->stream_id < 0) {\n        assert(-4 <= stream->stream_id);\n        uint8_t mask = 1 << -(1 + stream->stream_id);\n        assert((mask & (QUICLY_PENDING_FLOW_NEW_TOKEN_BIT | QUICLY_PENDING_FLOW_HANDSHAKE_DONE_BIT |\n                        QUICLY_PENDING_FLOW_OTHERS_BIT)) == 0);\n        if (stream->sendstate.pending.num_ranges != 0) {\n            stream->conn->egress.pending_flows |= mask;\n        } else {\n            stream->conn->egress.pending_flows &= ~mask;\n        }\n        return;\n    }\n\n    /* do nothing if blocked */\n    if (stream->streams_blocked)\n        return;\n\n    quicly_stream_scheduler_t *scheduler = stream->conn->super.ctx->stream_scheduler;\n    scheduler->update_state(scheduler, stream);\n}\n\nstatic int should_send_max_data(quicly_conn_t *conn)\n{\n    return quicly_maxsender_should_send_max(&conn->ingress.max_data.sender, conn->ingress.max_data.bytes_consumed,\n                                            (uint32_t)conn->super.ctx->transport_params.max_data, 512);\n}\n\nstatic int should_send_max_stream_data(quicly_stream_t *stream)\n{\n    if (stream->recvstate.eos != UINT64_MAX)\n        return 0;\n    return quicly_maxsender_should_send_max(&stream->_send_aux.max_stream_data_sender, stream->recvstate.data_off,\n                                            stream->_recv_aux.window, 512);\n}\n\nint quicly_stream_sync_sendbuf(quicly_stream_t *stream, int activate)\n{\n    int ret;\n\n    if (activate) {\n        if ((ret = quicly_sendstate_activate(&stream->sendstate)) != 0)\n            return ret;\n    }\n\n    resched_stream_data(stream);\n    return 0;\n}\n\nvoid quicly_stream_sync_recvbuf(quicly_stream_t *stream, size_t shift_amount)\n{\n    stream->recvstate.data_off += shift_amount;\n    if (stream->stream_id >= 0) {\n        if (should_send_max_stream_data(stream))\n            sched_stream_control(stream);\n    }\n}\n\nstatic int schedule_path_challenge_frame(quicly_conn_t *conn, int is_response, const uint8_t *data)\n{\n    struct st_quicly_pending_path_challenge_t *pending;\n\n    if ((pending = malloc(sizeof(struct st_quicly_pending_path_challenge_t))) == NULL)\n        return PTLS_ERROR_NO_MEMORY;\n\n    pending->next = NULL;\n    pending->is_response = is_response;\n    memcpy(pending->data, data, QUICLY_PATH_CHALLENGE_DATA_LEN);\n\n    *conn->egress.path_challenge.tail_ref = pending;\n    conn->egress.path_challenge.tail_ref = &pending->next;\n\n    conn->egress.pending_flows |= QUICLY_PENDING_FLOW_OTHERS_BIT;\n\n    return 0;\n}\n\n/**\n * calculate how many CIDs we provide to the remote peer\n */\nstatic size_t local_cid_size(const quicly_conn_t *conn)\n{\n    PTLS_BUILD_ASSERT(QUICLY_LOCAL_ACTIVE_CONNECTION_ID_LIMIT < SIZE_MAX / sizeof(uint64_t));\n\n    /* if we don't have an encryptor, the only CID we issue is the one we send during handshake */\n    if (conn->super.ctx->cid_encryptor == NULL)\n        return 1;\n\n    uint64_t capacity = conn->super.remote.transport_params.active_connection_id_limit;\n    if (capacity > QUICLY_LOCAL_ACTIVE_CONNECTION_ID_LIMIT)\n        capacity = QUICLY_LOCAL_ACTIVE_CONNECTION_ID_LIMIT;\n    return capacity;\n}\n\n/**\n * set up an internal record to send RETIRE_CONNECTION_ID frame later\n */\nstatic void schedule_retire_connection_id_frame(quicly_conn_t *conn, uint64_t sequence)\n{\n    quicly_retire_cid_push(&conn->egress.retire_cid, sequence);\n    conn->egress.pending_flows |= QUICLY_PENDING_FLOW_OTHERS_BIT;\n}\n\nstatic int write_crypto_data(quicly_conn_t *conn, ptls_buffer_t *tlsbuf, size_t epoch_offsets[5])\n{\n    size_t epoch;\n    int ret;\n\n    if (tlsbuf->off == 0)\n        return 0;\n\n    for (epoch = 0; epoch < 4; ++epoch) {\n        size_t len = epoch_offsets[epoch + 1] - epoch_offsets[epoch];\n        if (len == 0)\n            continue;\n        quicly_stream_t *stream = quicly_get_stream(conn, -(quicly_stream_id_t)(1 + epoch));\n        assert(stream != NULL);\n        if ((ret = quicly_streambuf_egress_write(stream, tlsbuf->base + epoch_offsets[epoch], len)) != 0)\n            return ret;\n    }\n\n    return 0;\n}\n\nstatic void crypto_handshake(quicly_conn_t *conn, size_t in_epoch, ptls_iovec_t input)\n{\n    ptls_buffer_t output;\n    size_t epoch_offsets[5] = {0};\n\n    assert(!conn->crypto.async_in_progress);\n\n    ptls_buffer_init(&output, \"\", 0);\n\n    int handshake_result = ptls_handle_message(conn->crypto.tls, &output, epoch_offsets, in_epoch, input.base, input.len,\n                                               &conn->crypto.handshake_properties);\n    QUICLY_PROBE(CRYPTO_HANDSHAKE, conn, conn->stash.now, handshake_result);\n    QUICLY_LOG_CONN(crypto_handshake, conn, { PTLS_LOG_ELEMENT_SIGNED(ret, handshake_result); });\n    switch (handshake_result) {\n    case 0:\n    case PTLS_ERROR_IN_PROGRESS:\n        break;\n    case PTLS_ERROR_ASYNC_OPERATION:\n        assert(conn->super.ctx->async_handshake != NULL &&\n               \"async handshake is used but the quicly_context_t::async_handshake is NULL\");\n        conn->crypto.async_in_progress = 1;\n        conn->super.ctx->async_handshake->cb(conn->super.ctx->async_handshake, conn->crypto.tls);\n        break;\n    default:\n        initiate_close(conn,\n                       PTLS_ERROR_GET_CLASS(handshake_result) == PTLS_ERROR_CLASS_SELF_ALERT ? handshake_result\n                                                                                             : QUICLY_TRANSPORT_ERROR_INTERNAL,\n                       QUICLY_FRAME_TYPE_CRYPTO, NULL);\n        goto Exit;\n    }\n    /* drop 0-RTT write key if 0-RTT is rejected by remote peer */\n    if (conn->application != NULL && !conn->application->one_rtt_writable && conn->application->cipher.egress.key.aead != NULL) {\n        assert(quicly_is_client(conn));\n        if (conn->crypto.handshake_properties.client.early_data_acceptance == PTLS_EARLY_DATA_REJECTED) {\n            dispose_cipher(&conn->application->cipher.egress.key);\n            conn->application->cipher.egress.key = (struct st_quicly_cipher_context_t){NULL};\n            /* retire all packets with ack_epoch == 3; they are all 0-RTT packets */\n            int ret;\n            if ((ret = discard_sentmap_by_epoch(conn, 1u << QUICLY_EPOCH_1RTT)) != 0) {\n                initiate_close(conn, ret, QUICLY_FRAME_TYPE_CRYPTO, NULL);\n                goto Exit;\n            }\n        }\n    }\n\n    write_crypto_data(conn, &output, epoch_offsets);\n\nExit:\n    ptls_buffer_dispose(&output);\n}\n\nvoid crypto_stream_receive(quicly_stream_t *stream, size_t off, const void *src, size_t len)\n{\n    quicly_conn_t *conn = stream->conn;\n    ptls_iovec_t input;\n\n    /* store input */\n    if (quicly_streambuf_ingress_receive(stream, off, src, len) != 0)\n        return;\n\n    /* While the server generates the handshake signature asynchronously, clients would not send additional messages. They cannot\n     * generate Finished. They would not send Certificate / CertificateVerify before authenticating the server identity. */\n    if (conn->crypto.async_in_progress) {\n        initiate_close(conn, PTLS_ALERT_UNEXPECTED_MESSAGE, QUICLY_FRAME_TYPE_CRYPTO, NULL);\n        return;\n    }\n\n    /* feed the input into TLS, send result */\n    if ((input = quicly_streambuf_ingress_get(stream)).len != 0) {\n        size_t in_epoch = -(1 + stream->stream_id);\n        crypto_handshake(conn, in_epoch, input);\n        quicly_streambuf_ingress_shift(stream, input.len);\n    }\n}\n\nquicly_conn_t *quicly_resume_handshake(ptls_t *tls)\n{\n    quicly_conn_t *conn;\n\n    if ((conn = *ptls_get_data_ptr(tls)) == NULL) {\n        /* QUIC connection has been closed while TLS async operation was inflight. */\n        ptls_free(tls);\n        return NULL;\n    }\n\n    assert(conn->crypto.async_in_progress);\n    conn->crypto.async_in_progress = 0;\n\n    if (conn->super.state >= QUICLY_STATE_CLOSING)\n        return conn;\n\n    crypto_handshake(conn, 0, ptls_iovec_init(NULL, 0));\n    return conn;\n}\n\nstatic void init_stream_properties(quicly_stream_t *stream, uint32_t initial_max_stream_data_local,\n                                   uint64_t initial_max_stream_data_remote)\n{\n    int is_client = quicly_is_client(stream->conn);\n\n    if (quicly_stream_has_send_side(is_client, stream->stream_id)) {\n        quicly_sendstate_init(&stream->sendstate);\n    } else {\n        quicly_sendstate_init_closed(&stream->sendstate);\n    }\n    if (quicly_stream_has_receive_side(is_client, stream->stream_id)) {\n        quicly_recvstate_init(&stream->recvstate);\n    } else {\n        quicly_recvstate_init_closed(&stream->recvstate);\n    }\n    stream->streams_blocked = 0;\n\n    stream->_send_aux.max_stream_data = initial_max_stream_data_remote;\n    stream->_send_aux.stop_sending.sender_state = QUICLY_SENDER_STATE_NONE;\n    stream->_send_aux.stop_sending.error_code = 0;\n    stream->_send_aux.reset_stream.sender_state = QUICLY_SENDER_STATE_NONE;\n    stream->_send_aux.reset_stream.error_code = 0;\n    quicly_maxsender_init(&stream->_send_aux.max_stream_data_sender, initial_max_stream_data_local);\n    stream->_send_aux.blocked = QUICLY_SENDER_STATE_NONE;\n    quicly_linklist_init(&stream->_send_aux.pending_link.control);\n    quicly_linklist_init(&stream->_send_aux.pending_link.default_scheduler);\n\n    stream->_recv_aux.window = initial_max_stream_data_local;\n\n    /* Set the number of max ranges to be capable of handling following case:\n     * * every one of the two packets being sent are lost\n     * * average size of a STREAM frame found in a packet is >= ~512 bytes, or small STREAM frame is sent for every other stream\n     *   being opened (e.g., sending QPACK encoder/decoder stream frame for each HTTP/3 request)\n     * See also: the doc-comment on `_recv_aux.max_ranges`.\n     */\n    uint32_t fragments_minmax = (uint32_t)(stream->conn->super.ctx->transport_params.max_streams_uni +\n                                           stream->conn->super.ctx->transport_params.max_streams_bidi);\n    if (fragments_minmax < 63)\n        fragments_minmax = 63;\n    if ((stream->_recv_aux.max_ranges = initial_max_stream_data_local / 1024) < fragments_minmax)\n        stream->_recv_aux.max_ranges = fragments_minmax;\n}\n\nstatic void dispose_stream_properties(quicly_stream_t *stream)\n{\n    quicly_sendstate_dispose(&stream->sendstate);\n    quicly_recvstate_dispose(&stream->recvstate);\n    quicly_maxsender_dispose(&stream->_send_aux.max_stream_data_sender);\n    quicly_linklist_unlink(&stream->_send_aux.pending_link.control);\n    quicly_linklist_unlink(&stream->_send_aux.pending_link.default_scheduler);\n}\n\nstatic quicly_stream_t *open_stream(quicly_conn_t *conn, uint64_t stream_id, uint32_t initial_max_stream_data_local,\n                                    uint64_t initial_max_stream_data_remote)\n{\n    quicly_stream_t *stream;\n\n    if ((stream = malloc(sizeof(*stream))) == NULL)\n        return NULL;\n    stream->conn = conn;\n    stream->stream_id = stream_id;\n    stream->callbacks = NULL;\n    stream->data = NULL;\n\n    int r;\n    khiter_t iter = kh_put(quicly_stream_t, conn->streams, stream_id, &r);\n    assert(iter != kh_end(conn->streams));\n    kh_val(conn->streams, iter) = stream;\n\n    init_stream_properties(stream, initial_max_stream_data_local, initial_max_stream_data_remote);\n\n    return stream;\n}\n\nstatic struct st_quicly_conn_streamgroup_state_t *get_streamgroup_state(quicly_conn_t *conn, quicly_stream_id_t stream_id)\n{\n    if (quicly_is_client(conn) == quicly_stream_is_client_initiated(stream_id)) {\n        return quicly_stream_is_unidirectional(stream_id) ? &conn->super.local.uni : &conn->super.local.bidi;\n    } else {\n        return quicly_stream_is_unidirectional(stream_id) ? &conn->super.remote.uni : &conn->super.remote.bidi;\n    }\n}\n\nstatic int should_send_max_streams(quicly_conn_t *conn, int uni)\n{\n    uint64_t concurrency;\n    quicly_maxsender_t *maxsender;\n    struct st_quicly_conn_streamgroup_state_t *group;\n\n#define INIT_VARS(type)                                                                                                            \\\n    do {                                                                                                                           \\\n        concurrency = conn->super.ctx->transport_params.max_streams_##type;                                                        \\\n        maxsender = &conn->ingress.max_streams.type;                                                                               \\\n        group = &conn->super.remote.type;                                                                                          \\\n    } while (0)\n    if (uni) {\n        INIT_VARS(uni);\n    } else {\n        INIT_VARS(bidi);\n    }\n#undef INIT_VARS\n\n    if (concurrency == 0)\n        return 0;\n\n    if (!quicly_maxsender_should_send_max(maxsender, group->next_stream_id / 4, group->num_streams, 768))\n        return 0;\n\n    return 1;\n}\n\nstatic void destroy_stream(quicly_stream_t *stream, int err)\n{\n    quicly_conn_t *conn = stream->conn;\n\n    QUICLY_PROBE(STREAM_ON_DESTROY, conn, conn->stash.now, stream, err);\n    QUICLY_LOG_CONN(stream_on_destroy, conn, {\n        PTLS_LOG_ELEMENT_SIGNED(stream_id, stream->stream_id);\n        PTLS_LOG_ELEMENT_SIGNED(err, err);\n    });\n\n    if (stream->callbacks != NULL)\n        stream->callbacks->on_destroy(stream, err);\n\n    khiter_t iter = kh_get(quicly_stream_t, conn->streams, stream->stream_id);\n    assert(iter != kh_end(conn->streams));\n    kh_del(quicly_stream_t, conn->streams, iter);\n\n    if (stream->stream_id < 0) {\n        size_t epoch = -(1 + stream->stream_id);\n        stream->conn->egress.pending_flows &= ~(uint8_t)(1 << epoch);\n    } else {\n        struct st_quicly_conn_streamgroup_state_t *group = get_streamgroup_state(conn, stream->stream_id);\n        --group->num_streams;\n    }\n\n    dispose_stream_properties(stream);\n\n    if (conn->application != NULL && should_send_max_streams(conn, quicly_stream_is_unidirectional(stream->stream_id)))\n        conn->egress.pending_flows |= QUICLY_PENDING_FLOW_OTHERS_BIT;\n\n    free(stream);\n}\n\nstatic void destroy_all_streams(quicly_conn_t *conn, int err, int including_crypto_streams)\n{\n    quicly_stream_t *stream;\n    kh_foreach_value(conn->streams, stream, {\n        /* TODO do we need to send reset signals to open streams? */\n        if (including_crypto_streams || stream->stream_id >= 0)\n            destroy_stream(stream, err);\n    });\n    assert(quicly_num_streams(conn) == 0);\n}\n\nint quicly_foreach_stream(quicly_conn_t *conn, void *thunk, int (*cb)(void *thunk, quicly_stream_t *stream))\n{\n    quicly_stream_t *stream;\n    kh_foreach_value(conn->streams, stream, {\n        if (stream->stream_id >= 0) {\n            int ret = cb(thunk, stream);\n            if (ret != 0)\n                return ret;\n        }\n    });\n    return 0;\n}\n\nquicly_stream_t *quicly_get_stream(quicly_conn_t *conn, quicly_stream_id_t stream_id)\n{\n    khiter_t iter = kh_get(quicly_stream_t, conn->streams, stream_id);\n    if (iter != kh_end(conn->streams))\n        return kh_val(conn->streams, iter);\n    return NULL;\n}\n\nptls_t *quicly_get_tls(quicly_conn_t *conn)\n{\n    return conn->crypto.tls;\n}\n\nuint32_t quicly_num_streams_by_group(quicly_conn_t *conn, int uni, int locally_initiated)\n{\n    int server_initiated = quicly_is_client(conn) != locally_initiated;\n    struct st_quicly_conn_streamgroup_state_t *state = get_streamgroup_state(conn, uni * 2 + server_initiated);\n    return state->num_streams;\n}\n\nint quicly_get_stats(quicly_conn_t *conn, quicly_stats_t *stats)\n{\n    /* copy the pre-built stats fields */\n    memcpy(stats, &conn->super.stats, sizeof(conn->super.stats));\n\n    /* set or generate the non-pre-built stats fields here */\n    stats->rtt = conn->egress.loss.rtt;\n    stats->loss_thresholds = conn->egress.loss.thresholds;\n    stats->cc = conn->egress.cc;\n    quicly_ratemeter_report(&conn->egress.ratemeter, &stats->delivery_rate);\n    stats->num_sentmap_packets_largest = conn->egress.loss.sentmap.num_packets_largest;\n    stats->handshake_confirmed_msec = conn->super.stats.handshake_confirmed_msec;\n\n    return 0;\n}\n\nint quicly_get_delivery_rate(quicly_conn_t *conn, quicly_rate_t *delivery_rate)\n{\n    quicly_ratemeter_report(&conn->egress.ratemeter, delivery_rate);\n    return 0;\n}\n\nquicly_stream_id_t quicly_get_ingress_max_streams(quicly_conn_t *conn, int uni)\n{\n    quicly_maxsender_t *maxsender = uni ? &conn->ingress.max_streams.uni : &conn->ingress.max_streams.bidi;\n    return maxsender->max_committed;\n}\n\nvoid quicly_get_max_data(quicly_conn_t *conn, uint64_t *send_permitted, uint64_t *sent, uint64_t *consumed)\n{\n    if (send_permitted != NULL)\n        *send_permitted = conn->egress.max_data.permitted;\n    if (sent != NULL)\n        *sent = conn->egress.max_data.sent;\n    if (consumed != NULL)\n        *consumed = conn->ingress.max_data.bytes_consumed;\n}\n\nstatic void update_idle_timeout(quicly_conn_t *conn, int is_in_receive)\n{\n    if (!is_in_receive && !conn->idle_timeout.should_rearm_on_send)\n        return;\n\n    /* calculate the minimum of the two max_idle_timeout */\n    int64_t idle_msec = INT64_MAX;\n    if (conn->initial == NULL && conn->handshake == NULL && conn->super.remote.transport_params.max_idle_timeout != 0)\n        idle_msec = conn->super.remote.transport_params.max_idle_timeout;\n    if (conn->super.ctx->transport_params.max_idle_timeout != 0 && conn->super.ctx->transport_params.max_idle_timeout < idle_msec)\n        idle_msec = conn->super.ctx->transport_params.max_idle_timeout;\n\n    if (idle_msec == INT64_MAX)\n        return;\n\n    uint32_t three_pto = 3 * quicly_rtt_get_pto(&conn->egress.loss.rtt, conn->super.ctx->transport_params.max_ack_delay,\n                                                conn->egress.loss.conf->min_pto);\n    conn->idle_timeout.at = conn->stash.now + (idle_msec > three_pto ? idle_msec : three_pto);\n    conn->idle_timeout.should_rearm_on_send = is_in_receive;\n}\n\nstatic int scheduler_can_send(quicly_conn_t *conn)\n{\n    /* invoke the scheduler only when we are able to send stream data; skipping STATE_ACCEPTING is important as the application\n     * would not have setup data pointer. */\n    switch (conn->super.state) {\n    case QUICLY_STATE_FIRSTFLIGHT:\n    case QUICLY_STATE_CONNECTED:\n        break;\n    default:\n        return 0;\n    }\n\n    /* scheduler would never have data to send, until application keys become available */\n    if (conn->application == NULL)\n        return 0;\n\n    int conn_is_saturated = !(conn->egress.max_data.sent < conn->egress.max_data.permitted);\n    return conn->super.ctx->stream_scheduler->can_send(conn->super.ctx->stream_scheduler, conn, conn_is_saturated);\n}\n\nstatic void update_send_alarm(quicly_conn_t *conn, int can_send_stream_data, int is_after_send)\n{\n    int has_outstanding = conn->egress.loss.sentmap.bytes_in_flight != 0 || conn->super.remote.address_validation.send_probe,\n        handshake_is_in_progress = conn->initial != NULL || conn->handshake != NULL;\n    quicly_loss_update_alarm(&conn->egress.loss, conn->stash.now, conn->egress.last_retransmittable_sent_at, has_outstanding,\n                             can_send_stream_data, handshake_is_in_progress, conn->egress.max_data.sent, is_after_send);\n}\n\n/**\n * Updates the send alarm and adjusts the delivery rate estimator. This function is called from the receive path. From the sendp\n * path, `update_send_alarm` is called directly.\n */\nstatic void setup_next_send(quicly_conn_t *conn)\n{\n    int can_send_stream_data = scheduler_can_send(conn);\n\n    update_send_alarm(conn, can_send_stream_data, 0);\n\n    /* When the flow becomes application-limited due to receiving some information, stop collecting delivery rate samples. */\n    if (!can_send_stream_data)\n        quicly_ratemeter_not_cwnd_limited(&conn->egress.ratemeter, conn->egress.packet_number);\n}\n\nstatic int create_handshake_flow(quicly_conn_t *conn, size_t epoch)\n{\n    quicly_stream_t *stream;\n    int ret;\n\n    if ((stream = open_stream(conn, -(quicly_stream_id_t)(1 + epoch), 65536, 65536)) == NULL)\n        return PTLS_ERROR_NO_MEMORY;\n    if ((ret = quicly_streambuf_create(stream, sizeof(quicly_streambuf_t))) != 0) {\n        destroy_stream(stream, ret);\n        return ret;\n    }\n    stream->callbacks = &crypto_stream_callbacks;\n\n    return 0;\n}\n\nstatic void destroy_handshake_flow(quicly_conn_t *conn, size_t epoch)\n{\n    quicly_stream_t *stream = quicly_get_stream(conn, -(quicly_stream_id_t)(1 + epoch));\n    if (stream != NULL)\n        destroy_stream(stream, 0);\n}\n\nstatic struct st_quicly_pn_space_t *alloc_pn_space(size_t sz, uint32_t packet_tolerance)\n{\n    struct st_quicly_pn_space_t *space;\n\n    if ((space = malloc(sz)) == NULL)\n        return NULL;\n\n    quicly_ranges_init(&space->ack_queue);\n    space->largest_pn_received_at = INT64_MAX;\n    space->next_expected_packet_number = 0;\n    space->unacked_count = 0;\n    for (size_t i = 0; i < PTLS_ELEMENTSOF(space->ecn_counts); ++i)\n        space->ecn_counts[i] = 0;\n    space->packet_tolerance = packet_tolerance;\n    space->ignore_order = 0;\n    if (sz != sizeof(*space))\n        memset((uint8_t *)space + sizeof(*space), 0, sz - sizeof(*space));\n\n    return space;\n}\n\nstatic void do_free_pn_space(struct st_quicly_pn_space_t *space)\n{\n    quicly_ranges_clear(&space->ack_queue);\n    free(space);\n}\n\nstatic int record_pn(quicly_ranges_t *ranges, uint64_t pn, int *is_out_of_order)\n{\n    int ret;\n\n    *is_out_of_order = 0;\n\n    if (ranges->num_ranges != 0) {\n        /* fast path that is taken when we receive a packet in-order */\n        if (ranges->ranges[ranges->num_ranges - 1].end == pn) {\n            ranges->ranges[ranges->num_ranges - 1].end = pn + 1;\n            return 0;\n        }\n        *is_out_of_order = 1;\n    }\n\n    /* slow path; we add, then remove the oldest ranges when the number of ranges exceed the maximum */\n    if ((ret = quicly_ranges_add(ranges, pn, pn + 1)) != 0)\n        return ret;\n    if (ranges->num_ranges > QUICLY_MAX_ACK_BLOCKS)\n        quicly_ranges_drop_by_range_indices(ranges, ranges->num_ranges - QUICLY_MAX_ACK_BLOCKS, ranges->num_ranges);\n\n    return 0;\n}\n\nstatic int record_receipt(struct st_quicly_pn_space_t *space, uint64_t pn, uint8_t ecn, int is_ack_only, int64_t now,\n                          int64_t *send_ack_at, uint64_t *received_out_of_order)\n{\n    int ret, ack_now, is_out_of_order;\n\n    if ((ret = record_pn(&space->ack_queue, pn, &is_out_of_order)) != 0)\n        goto Exit;\n    if (is_out_of_order)\n        *received_out_of_order += 1;\n\n    ack_now = !is_ack_only && ((is_out_of_order && !space->ignore_order) || ecn == IPTOS_ECN_CE);\n\n    /* update largest_pn_received_at (TODO implement deduplication at an earlier moment?) */\n    if (space->ack_queue.ranges[space->ack_queue.num_ranges - 1].end == pn + 1)\n        space->largest_pn_received_at = now;\n\n    /* increment ecn counters */\n    if (ecn != 0)\n        space->ecn_counts[get_ecn_index_from_bits(ecn)] += 1;\n\n    /* if the received packet is ack-eliciting, update / schedule transmission of ACK */\n    if (!is_ack_only) {\n        space->unacked_count++;\n        if (space->unacked_count >= space->packet_tolerance)\n            ack_now = 1;\n    }\n\n    if (ack_now) {\n        *send_ack_at = now;\n    } else if (*send_ack_at == INT64_MAX && space->unacked_count != 0) {\n        *send_ack_at = now + QUICLY_DELAYED_ACK_TIMEOUT;\n    }\n\n    ret = 0;\nExit:\n    return ret;\n}\n\nstatic void free_handshake_space(struct st_quicly_handshake_space_t **space)\n{\n    if (*space != NULL) {\n        if ((*space)->cipher.ingress.aead != NULL)\n            dispose_cipher(&(*space)->cipher.ingress);\n        if ((*space)->cipher.egress.aead != NULL)\n            dispose_cipher(&(*space)->cipher.egress);\n        do_free_pn_space(&(*space)->super);\n        *space = NULL;\n    }\n}\n\nstatic int setup_cipher(quicly_conn_t *conn, size_t epoch, int is_enc, ptls_cipher_context_t **hp_ctx,\n                        ptls_aead_context_t **aead_ctx, ptls_aead_algorithm_t *aead, ptls_hash_algorithm_t *hash,\n                        const void *secret)\n{\n    /* quicly_accept builds cipher before instantiating a connection. In such case, we use the default crypto engine */\n    quicly_crypto_engine_t *engine = conn != NULL ? conn->super.ctx->crypto_engine : &quicly_default_crypto_engine;\n\n    return engine->setup_cipher(engine, conn, epoch, is_enc, hp_ctx, aead_ctx, aead, hash, secret);\n}\n\nstatic int setup_handshake_space_and_flow(quicly_conn_t *conn, size_t epoch)\n{\n    struct st_quicly_handshake_space_t **space = epoch == QUICLY_EPOCH_INITIAL ? &conn->initial : &conn->handshake;\n    if ((*space = (void *)alloc_pn_space(sizeof(struct st_quicly_handshake_space_t), 1)) == NULL)\n        return PTLS_ERROR_NO_MEMORY;\n    return create_handshake_flow(conn, epoch);\n}\n\nstatic void free_application_space(struct st_quicly_application_space_t **space)\n{\n    if (*space != NULL) {\n#define DISPOSE_INGRESS(label, func)                                                                                               \\\n    if ((*space)->cipher.ingress.label != NULL)                                                                                    \\\n    func((*space)->cipher.ingress.label)\n        DISPOSE_INGRESS(header_protection.zero_rtt, ptls_cipher_free);\n        DISPOSE_INGRESS(header_protection.one_rtt, ptls_cipher_free);\n        DISPOSE_INGRESS(aead[0], ptls_aead_free);\n        DISPOSE_INGRESS(aead[1], ptls_aead_free);\n#undef DISPOSE_INGRESS\n        if ((*space)->cipher.egress.key.aead != NULL)\n            dispose_cipher(&(*space)->cipher.egress.key);\n        ptls_clear_memory((*space)->cipher.egress.secret, sizeof((*space)->cipher.egress.secret));\n        do_free_pn_space(&(*space)->super);\n        *space = NULL;\n    }\n}\n\nstatic int setup_application_space(quicly_conn_t *conn)\n{\n    if ((conn->application =\n             (void *)alloc_pn_space(sizeof(struct st_quicly_application_space_t), QUICLY_DEFAULT_PACKET_TOLERANCE)) == NULL)\n        return PTLS_ERROR_NO_MEMORY;\n\n    /* prohibit key-update until receiving an ACK for an 1-RTT packet */\n    conn->application->cipher.egress.key_update_pn.last = 0;\n    conn->application->cipher.egress.key_update_pn.next = UINT64_MAX;\n\n    return create_handshake_flow(conn, QUICLY_EPOCH_1RTT);\n}\n\nstatic int discard_handshake_context(quicly_conn_t *conn, size_t epoch)\n{\n    int ret;\n\n    assert(epoch == QUICLY_EPOCH_INITIAL || epoch == QUICLY_EPOCH_HANDSHAKE);\n\n    if ((ret = discard_sentmap_by_epoch(conn, 1u << epoch)) != 0)\n        return ret;\n    destroy_handshake_flow(conn, epoch);\n    if (epoch == QUICLY_EPOCH_HANDSHAKE) {\n        assert(conn->stash.now != 0);\n        conn->super.stats.handshake_confirmed_msec = conn->stash.now - conn->created_at;\n    }\n    free_handshake_space(epoch == QUICLY_EPOCH_INITIAL ? &conn->initial : &conn->handshake);\n\n    return 0;\n}\n\nstatic int apply_remote_transport_params(quicly_conn_t *conn)\n{\n    int ret;\n\n    conn->egress.max_data.permitted = conn->super.remote.transport_params.max_data;\n    if ((ret = update_max_streams(&conn->egress.max_streams.uni, conn->super.remote.transport_params.max_streams_uni)) != 0)\n        return ret;\n    if ((ret = update_max_streams(&conn->egress.max_streams.bidi, conn->super.remote.transport_params.max_streams_bidi)) != 0)\n        return ret;\n\n    return 0;\n}\n\nstatic int update_1rtt_key(quicly_conn_t *conn, ptls_cipher_suite_t *cipher, int is_enc, ptls_aead_context_t **aead,\n                           uint8_t *secret)\n{\n    uint8_t new_secret[PTLS_MAX_DIGEST_SIZE];\n    ptls_aead_context_t *new_aead = NULL;\n    int ret;\n\n    /* generate next AEAD key */\n    if ((ret = ptls_hkdf_expand_label(cipher->hash, new_secret, cipher->hash->digest_size,\n                                      ptls_iovec_init(secret, cipher->hash->digest_size), \"quic ku\", ptls_iovec_init(NULL, 0),\n                                      NULL)) != 0)\n        goto Exit;\n    if ((ret = setup_cipher(conn, QUICLY_EPOCH_1RTT, is_enc, NULL, &new_aead, cipher->aead, cipher->hash, new_secret)) != 0)\n        goto Exit;\n\n    /* success! update AEAD and secret */\n    if (*aead != NULL)\n        ptls_aead_free(*aead);\n    *aead = new_aead;\n    new_aead = NULL;\n    memcpy(secret, new_secret, cipher->hash->digest_size);\n\n    ret = 0;\nExit:\n    if (new_aead != NULL)\n        ptls_aead_free(new_aead);\n    ptls_clear_memory(new_secret, cipher->hash->digest_size);\n    return ret;\n}\n\nstatic int update_1rtt_egress_key(quicly_conn_t *conn)\n{\n    struct st_quicly_application_space_t *space = conn->application;\n    ptls_cipher_suite_t *cipher = ptls_get_cipher(conn->crypto.tls);\n    int ret;\n\n    /* generate next AEAD key, and increment key phase if it succeeds */\n    if ((ret = update_1rtt_key(conn, cipher, 1, &space->cipher.egress.key.aead, space->cipher.egress.secret)) != 0)\n        return ret;\n    ++space->cipher.egress.key_phase;\n\n    /* signal that we are waiting for an ACK */\n    space->cipher.egress.key_update_pn.last = conn->egress.packet_number;\n    space->cipher.egress.key_update_pn.next = UINT64_MAX;\n\n    QUICLY_PROBE(CRYPTO_SEND_KEY_UPDATE, conn, conn->stash.now, space->cipher.egress.key_phase,\n                 QUICLY_PROBE_HEXDUMP(space->cipher.egress.secret, cipher->hash->digest_size));\n    QUICLY_LOG_CONN(crypto_send_key_update, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(phase, space->cipher.egress.key_phase);\n        PTLS_LOG_APPDATA_ELEMENT_HEXDUMP(secret, space->cipher.egress.secret, cipher->hash->digest_size);\n    });\n\n    return 0;\n}\n\nstatic int received_key_update(quicly_conn_t *conn, uint64_t newly_decrypted_key_phase)\n{\n    struct st_quicly_application_space_t *space = conn->application;\n\n    assert(space->cipher.ingress.key_phase.decrypted < newly_decrypted_key_phase);\n    assert(newly_decrypted_key_phase <= space->cipher.ingress.key_phase.prepared);\n\n    space->cipher.ingress.key_phase.decrypted = newly_decrypted_key_phase;\n\n    QUICLY_PROBE(CRYPTO_RECEIVE_KEY_UPDATE, conn, conn->stash.now, space->cipher.ingress.key_phase.decrypted,\n                 QUICLY_PROBE_HEXDUMP(space->cipher.ingress.secret, ptls_get_cipher(conn->crypto.tls)->hash->digest_size));\n    QUICLY_LOG_CONN(crypto_receive_key_update, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(phase, space->cipher.ingress.key_phase.decrypted);\n        PTLS_LOG_APPDATA_ELEMENT_HEXDUMP(secret, space->cipher.ingress.secret,\n                                         ptls_get_cipher(conn->crypto.tls)->hash->digest_size);\n    });\n\n    if (space->cipher.egress.key_phase < space->cipher.ingress.key_phase.decrypted) {\n        return update_1rtt_egress_key(conn);\n    } else {\n        return 0;\n    }\n}\n\nstatic inline void update_open_count(quicly_context_t *ctx, ssize_t delta)\n{\n    if (ctx->update_open_count != NULL)\n        ctx->update_open_count->cb(ctx->update_open_count, delta);\n}\n\nvoid quicly_free(quicly_conn_t *conn)\n{\n    lock_now(conn, 0);\n\n    QUICLY_PROBE(FREE, conn, conn->stash.now);\n    QUICLY_LOG_CONN(free, conn, {});\n\n#if QUICLY_USE_DTRACE\n    if (QUICLY_CONN_STATS_ENABLED()) {\n        quicly_stats_t stats;\n        quicly_get_stats(conn, &stats);\n        QUICLY_PROBE(CONN_STATS, conn, conn->stash.now, &stats, sizeof(stats));\n        // TODO: emit stats with QUICLY_LOG_CONN()\n    }\n#endif\n    destroy_all_streams(conn, 0, 1);\n    update_open_count(conn->super.ctx, -1);\n    clear_datagram_frame_payloads(conn);\n\n    quicly_maxsender_dispose(&conn->ingress.max_data.sender);\n    quicly_maxsender_dispose(&conn->ingress.max_streams.uni);\n    quicly_maxsender_dispose(&conn->ingress.max_streams.bidi);\n    while (conn->egress.path_challenge.head != NULL) {\n        struct st_quicly_pending_path_challenge_t *pending = conn->egress.path_challenge.head;\n        conn->egress.path_challenge.head = pending->next;\n        free(pending);\n    }\n    quicly_loss_dispose(&conn->egress.loss);\n\n    kh_destroy(quicly_stream_t, conn->streams);\n\n    assert(!quicly_linklist_is_linked(&conn->egress.pending_streams.blocked.uni));\n    assert(!quicly_linklist_is_linked(&conn->egress.pending_streams.blocked.bidi));\n    assert(!quicly_linklist_is_linked(&conn->egress.pending_streams.control));\n    assert(!quicly_linklist_is_linked(&conn->super._default_scheduler.active));\n    assert(!quicly_linklist_is_linked(&conn->super._default_scheduler.blocked));\n\n    free_handshake_space(&conn->initial);\n    free_handshake_space(&conn->handshake);\n    free_application_space(&conn->application);\n\n    ptls_buffer_dispose(&conn->crypto.transport_params.buf);\n    if (conn->crypto.async_in_progress) {\n        /* When async signature generation is inflight, `ptls_free` will be called from `quicly_resume_handshake` laterwards. */\n        *ptls_get_data_ptr(conn->crypto.tls) = NULL;\n    } else {\n        ptls_free(conn->crypto.tls);\n    }\n\n    unlock_now(conn);\n\n    free(conn->token.base);\n    free(conn);\n}\n\nstatic int setup_initial_key(struct st_quicly_cipher_context_t *ctx, ptls_cipher_suite_t *cs, const void *master_secret,\n                             const char *label, int is_enc, quicly_conn_t *conn)\n{\n    uint8_t aead_secret[PTLS_MAX_DIGEST_SIZE];\n    int ret;\n\n    if ((ret = ptls_hkdf_expand_label(cs->hash, aead_secret, cs->hash->digest_size,\n                                      ptls_iovec_init(master_secret, cs->hash->digest_size), label, ptls_iovec_init(NULL, 0),\n                                      NULL)) != 0)\n        goto Exit;\n    if ((ret = setup_cipher(conn, QUICLY_EPOCH_INITIAL, is_enc, &ctx->header_protection, &ctx->aead, cs->aead, cs->hash,\n                            aead_secret)) != 0)\n        goto Exit;\n\nExit:\n    ptls_clear_memory(aead_secret, sizeof(aead_secret));\n    return ret;\n}\n\n/**\n * @param conn maybe NULL when called by quicly_accept\n */\nstatic int setup_initial_encryption(ptls_cipher_suite_t *cs, struct st_quicly_cipher_context_t *ingress,\n                                    struct st_quicly_cipher_context_t *egress, ptls_iovec_t cid, int is_client, ptls_iovec_t salt,\n                                    quicly_conn_t *conn)\n{\n    static const char *labels[2] = {\"client in\", \"server in\"};\n    uint8_t secret[PTLS_MAX_DIGEST_SIZE];\n    int ret;\n\n    /* extract master secret */\n    if ((ret = ptls_hkdf_extract(cs->hash, secret, salt, cid)) != 0)\n        goto Exit;\n\n    /* create aead contexts */\n    if (ingress != NULL && (ret = setup_initial_key(ingress, cs, secret, labels[is_client], 0, conn)) != 0)\n        goto Exit;\n    if (egress != NULL && (ret = setup_initial_key(egress, cs, secret, labels[!is_client], 1, conn)) != 0) {\n        if (ingress != NULL)\n            dispose_cipher(ingress);\n        goto Exit;\n    }\n\nExit:\n    ptls_clear_memory(secret, sizeof(secret));\n    return ret;\n}\n\nstatic int reinstall_initial_encryption(quicly_conn_t *conn, int err_code_if_unknown_version)\n{\n    const struct st_ptls_salt_t *salt;\n\n    /* get salt */\n    if ((salt = get_salt(conn->super.version)) == NULL)\n        return err_code_if_unknown_version;\n\n    /* dispose existing context */\n    dispose_cipher(&conn->initial->cipher.ingress);\n    dispose_cipher(&conn->initial->cipher.egress);\n\n    /* setup encryption context */\n    return setup_initial_encryption(\n        get_aes128gcmsha256(conn->super.ctx), &conn->initial->cipher.ingress, &conn->initial->cipher.egress,\n        ptls_iovec_init(conn->super.remote.cid_set.cids[0].cid.cid, conn->super.remote.cid_set.cids[0].cid.len), 1,\n        ptls_iovec_init(salt->initial, sizeof(salt->initial)), NULL);\n}\n\nstatic int apply_stream_frame(quicly_stream_t *stream, quicly_stream_frame_t *frame)\n{\n    int ret;\n\n    QUICLY_PROBE(STREAM_RECEIVE, stream->conn, stream->conn->stash.now, stream, frame->offset, frame->data.len);\n    QUICLY_LOG_CONN(stream_receive, stream->conn, {\n        PTLS_LOG_ELEMENT_SIGNED(stream_id, stream->stream_id);\n        PTLS_LOG_ELEMENT_UNSIGNED(off, frame->offset);\n        PTLS_LOG_ELEMENT_UNSIGNED(len, frame->data.len);\n    });\n\n    if (quicly_recvstate_transfer_complete(&stream->recvstate))\n        return 0;\n\n    /* flow control */\n    if (stream->stream_id >= 0) {\n        /* STREAMs */\n        uint64_t max_stream_data = frame->offset + frame->data.len;\n        if ((int64_t)stream->_recv_aux.window < (int64_t)max_stream_data - (int64_t)stream->recvstate.data_off)\n            return QUICLY_TRANSPORT_ERROR_FLOW_CONTROL;\n        if (stream->recvstate.received.ranges[stream->recvstate.received.num_ranges - 1].end < max_stream_data) {\n            uint64_t newly_received =\n                max_stream_data - stream->recvstate.received.ranges[stream->recvstate.received.num_ranges - 1].end;\n            if (stream->conn->ingress.max_data.bytes_consumed + newly_received >\n                stream->conn->ingress.max_data.sender.max_committed)\n                return QUICLY_TRANSPORT_ERROR_FLOW_CONTROL;\n            stream->conn->ingress.max_data.bytes_consumed += newly_received;\n            /* FIXME send MAX_DATA if necessary */\n        }\n    } else {\n        /* CRYPTO streams; maybe add different limit for 1-RTT CRYPTO? */\n        if (frame->offset + frame->data.len > stream->conn->super.ctx->max_crypto_bytes)\n            return QUICLY_TRANSPORT_ERROR_CRYPTO_BUFFER_EXCEEDED;\n    }\n\n    /* update recvbuf */\n    size_t apply_len = frame->data.len;\n    if ((ret = quicly_recvstate_update(&stream->recvstate, frame->offset, &apply_len, frame->is_fin,\n                                       stream->_recv_aux.max_ranges)) != 0)\n        return ret;\n\n    if (apply_len != 0 || quicly_recvstate_transfer_complete(&stream->recvstate)) {\n        uint64_t buf_offset = frame->offset + frame->data.len - apply_len - stream->recvstate.data_off;\n        const void *apply_src = frame->data.base + frame->data.len - apply_len;\n        QUICLY_PROBE(STREAM_ON_RECEIVE, stream->conn, stream->conn->stash.now, stream, (size_t)buf_offset, apply_src, apply_len);\n        QUICLY_LOG_CONN(stream_on_receive, stream->conn, {\n            PTLS_LOG_ELEMENT_SIGNED(stream_id, stream->stream_id);\n            PTLS_LOG_ELEMENT_UNSIGNED(off, buf_offset);\n            PTLS_LOG_APPDATA_ELEMENT_HEXDUMP(src, apply_src, apply_len);\n        });\n        stream->callbacks->on_receive(stream, (size_t)buf_offset, apply_src, apply_len);\n        if (stream->conn->super.state >= QUICLY_STATE_CLOSING)\n            return QUICLY_ERROR_IS_CLOSING;\n    }\n\n    if (should_send_max_stream_data(stream))\n        sched_stream_control(stream);\n\n    if (stream_is_destroyable(stream))\n        destroy_stream(stream, 0);\n\n    return 0;\n}\n\nint quicly_encode_transport_parameter_list(ptls_buffer_t *buf, const quicly_transport_parameters_t *params,\n                                           const quicly_cid_t *original_dcid, const quicly_cid_t *initial_scid,\n                                           const quicly_cid_t *retry_scid, const void *stateless_reset_token, size_t expand_by)\n{\n    int ret;\n\n#define PUSH_TP(buf, id, block)                                                                                                    \\\n    do {                                                                                                                           \\\n        ptls_buffer_push_quicint((buf), (id));                                                                                     \\\n        ptls_buffer_push_block((buf), -1, block);                                                                                  \\\n    } while (0)\n\n    PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_MAX_UDP_PAYLOAD_SIZE,\n            { ptls_buffer_push_quicint(buf, params->max_udp_payload_size); });\n    if (params->max_stream_data.bidi_local != 0)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_BIDI_LOCAL,\n                { ptls_buffer_push_quicint(buf, params->max_stream_data.bidi_local); });\n    if (params->max_stream_data.bidi_remote != 0)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_BIDI_REMOTE,\n                { ptls_buffer_push_quicint(buf, params->max_stream_data.bidi_remote); });\n    if (params->max_stream_data.uni != 0)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_UNI,\n                { ptls_buffer_push_quicint(buf, params->max_stream_data.uni); });\n    if (params->max_data != 0)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_DATA, { ptls_buffer_push_quicint(buf, params->max_data); });\n    if (params->max_idle_timeout != 0)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_MAX_IDLE_TIMEOUT, { ptls_buffer_push_quicint(buf, params->max_idle_timeout); });\n    if (original_dcid != NULL)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_ORIGINAL_CONNECTION_ID,\n                { ptls_buffer_pushv(buf, original_dcid->cid, original_dcid->len); });\n    if (initial_scid != NULL)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_SOURCE_CONNECTION_ID,\n                { ptls_buffer_pushv(buf, initial_scid->cid, initial_scid->len); });\n    if (retry_scid != NULL)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_RETRY_SOURCE_CONNECTION_ID,\n                { ptls_buffer_pushv(buf, retry_scid->cid, retry_scid->len); });\n    if (stateless_reset_token != NULL)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_STATELESS_RESET_TOKEN,\n                { ptls_buffer_pushv(buf, stateless_reset_token, QUICLY_STATELESS_RESET_TOKEN_LEN); });\n    if (params->max_streams_bidi != 0)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAMS_BIDI,\n                { ptls_buffer_push_quicint(buf, params->max_streams_bidi); });\n    if (params->max_streams_uni != 0)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAMS_UNI,\n                { ptls_buffer_push_quicint(buf, params->max_streams_uni); });\n    if (QUICLY_LOCAL_ACK_DELAY_EXPONENT != QUICLY_DEFAULT_ACK_DELAY_EXPONENT)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_ACK_DELAY_EXPONENT,\n                { ptls_buffer_push_quicint(buf, QUICLY_LOCAL_ACK_DELAY_EXPONENT); });\n    if (QUICLY_LOCAL_MAX_ACK_DELAY != QUICLY_DEFAULT_MAX_ACK_DELAY)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_MAX_ACK_DELAY, { ptls_buffer_push_quicint(buf, QUICLY_LOCAL_MAX_ACK_DELAY); });\n    if (params->min_ack_delay_usec != UINT64_MAX) {\n        /* TODO consider the value we should advertise. */\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_MIN_ACK_DELAY,\n                { ptls_buffer_push_quicint(buf, QUICLY_LOCAL_MAX_ACK_DELAY * 1000 /* in microseconds */); });\n    }\n    if (params->disable_active_migration)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_DISABLE_ACTIVE_MIGRATION, {});\n    if (QUICLY_LOCAL_ACTIVE_CONNECTION_ID_LIMIT != QUICLY_DEFAULT_ACTIVE_CONNECTION_ID_LIMIT)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_ACTIVE_CONNECTION_ID_LIMIT,\n                { ptls_buffer_push_quicint(buf, QUICLY_LOCAL_ACTIVE_CONNECTION_ID_LIMIT); });\n    if (params->max_datagram_frame_size != 0)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_MAX_DATAGRAM_FRAME_SIZE,\n                { ptls_buffer_push_quicint(buf, params->max_datagram_frame_size); });\n    /* if requested, add a greasing TP of 1 MTU size so that CH spans across multiple packets */\n    if (expand_by != 0) {\n        PUSH_TP(buf, 31 * 100 + 27, {\n            if ((ret = ptls_buffer_reserve(buf, expand_by)) != 0)\n                goto Exit;\n            memset(buf->base + buf->off, 0, expand_by);\n            buf->off += expand_by;\n        });\n    }\n\n#undef PUSH_TP\n\n    ret = 0;\nExit:\n    return ret;\n}\n\n/**\n * sentinel used for indicating that the corresponding TP should be ignored\n */\nstatic const quicly_cid_t _tp_cid_ignore;\n#define tp_cid_ignore (*(quicly_cid_t *)&_tp_cid_ignore)\n\nint quicly_decode_transport_parameter_list(quicly_transport_parameters_t *params, quicly_cid_t *original_dcid,\n                                           quicly_cid_t *initial_scid, quicly_cid_t *retry_scid, void *stateless_reset_token,\n                                           const uint8_t *src, const uint8_t *end)\n{\n/* When non-negative, tp_index contains the literal position within the list of transport parameters recognized by this function.\n * That index is being used to find duplicates using a 64-bit bitmap (found_bits). When the transport parameter is being processed,\n * tp_index is set to -1. */\n#define DECODE_TP(_id, block)                                                                                                      \\\n    do {                                                                                                                           \\\n        if (tp_index >= 0) {                                                                                                       \\\n            if (id == (_id)) {                                                                                                     \\\n                if ((found_bits & ((uint64_t)1 << tp_index)) != 0) {                                                               \\\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;                                                              \\\n                    goto Exit;                                                                                                     \\\n                }                                                                                                                  \\\n                found_bits |= (uint64_t)1 << tp_index;                                                                             \\\n                {block} tp_index = -1;                                                                                             \\\n            } else {                                                                                                               \\\n                ++tp_index;                                                                                                        \\\n            }                                                                                                                      \\\n        }                                                                                                                          \\\n    } while (0)\n#define DECODE_CID_TP(_id, dest)                                                                                                   \\\n    DECODE_TP(_id, {                                                                                                               \\\n        size_t cidl = end - src;                                                                                                   \\\n        if (cidl > QUICLY_MAX_CID_LEN_V1) {                                                                                        \\\n            ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;                                                                      \\\n            goto Exit;                                                                                                             \\\n        }                                                                                                                          \\\n        if (dest == NULL) {                                                                                                        \\\n            ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;                                                                      \\\n            goto Exit;                                                                                                             \\\n        } else if (dest != &tp_cid_ignore) {                                                                                       \\\n            quicly_set_cid(dest, ptls_iovec_init(src, cidl));                                                                      \\\n        }                                                                                                                          \\\n        src = end;                                                                                                                 \\\n    });\n\n    uint64_t found_bits = 0;\n    int ret;\n\n    /* set parameters to their default values */\n    *params = default_transport_params;\n\n    /* Set optional parameters to UINT8_MAX. It is used to as a sentinel for detecting missing TPs. */\n    if (original_dcid != NULL && original_dcid != &tp_cid_ignore)\n        original_dcid->len = UINT8_MAX;\n    if (initial_scid != NULL && initial_scid != &tp_cid_ignore)\n        initial_scid->len = UINT8_MAX;\n    if (retry_scid != NULL && retry_scid != &tp_cid_ignore)\n        retry_scid->len = UINT8_MAX;\n\n    /* decode the parameters block */\n    while (src != end) {\n        uint64_t id;\n        if ((id = quicly_decodev(&src, end)) == UINT64_MAX) {\n            ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n            goto Exit;\n        }\n        int tp_index = 0;\n        ptls_decode_open_block(src, end, -1, {\n            DECODE_CID_TP(QUICLY_TRANSPORT_PARAMETER_ID_ORIGINAL_CONNECTION_ID, original_dcid);\n            DECODE_CID_TP(QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_SOURCE_CONNECTION_ID, initial_scid);\n            DECODE_CID_TP(QUICLY_TRANSPORT_PARAMETER_ID_RETRY_SOURCE_CONNECTION_ID, retry_scid);\n            DECODE_TP(QUICLY_TRANSPORT_PARAMETER_ID_MAX_UDP_PAYLOAD_SIZE, {\n                uint64_t v;\n                if ((v = ptls_decode_quicint(&src, end)) == UINT64_MAX) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n                if (v < 1200) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n                if (v > UINT16_MAX)\n                    v = UINT16_MAX;\n                params->max_udp_payload_size = (uint16_t)v;\n            });\n            DECODE_TP(QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_BIDI_LOCAL, {\n                if ((params->max_stream_data.bidi_local = ptls_decode_quicint(&src, end)) == UINT64_MAX) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n            });\n            DECODE_TP(QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_BIDI_REMOTE, {\n                if ((params->max_stream_data.bidi_remote = ptls_decode_quicint(&src, end)) == UINT64_MAX) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n            });\n            DECODE_TP(QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_UNI, {\n                if ((params->max_stream_data.uni = ptls_decode_quicint(&src, end)) == UINT64_MAX) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n            });\n            DECODE_TP(QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_DATA, {\n                if ((params->max_data = ptls_decode_quicint(&src, end)) == UINT64_MAX) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n            });\n            DECODE_TP(QUICLY_TRANSPORT_PARAMETER_ID_STATELESS_RESET_TOKEN, {\n                if (!(stateless_reset_token != NULL && end - src == QUICLY_STATELESS_RESET_TOKEN_LEN)) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n                memcpy(stateless_reset_token, src, QUICLY_STATELESS_RESET_TOKEN_LEN);\n                src = end;\n            });\n            DECODE_TP(QUICLY_TRANSPORT_PARAMETER_ID_MAX_IDLE_TIMEOUT, {\n                if ((params->max_idle_timeout = ptls_decode_quicint(&src, end)) == UINT64_MAX) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n            });\n            DECODE_TP(QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAMS_BIDI, {\n                if ((params->max_streams_bidi = ptls_decode_quicint(&src, end)) == UINT64_MAX) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n            });\n            DECODE_TP(QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAMS_UNI, {\n                if ((params->max_streams_uni = ptls_decode_quicint(&src, end)) == UINT64_MAX) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n            });\n            DECODE_TP(QUICLY_TRANSPORT_PARAMETER_ID_ACK_DELAY_EXPONENT, {\n                uint64_t v;\n                if ((v = ptls_decode_quicint(&src, end)) == UINT64_MAX) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n                if (v > 20) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n                params->ack_delay_exponent = (uint8_t)v;\n            });\n            DECODE_TP(QUICLY_TRANSPORT_PARAMETER_ID_MAX_ACK_DELAY, {\n                uint64_t v;\n                if ((v = ptls_decode_quicint(&src, end)) == UINT64_MAX) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n                if (v >= 16384) { /* \"values of 2^14 or greater are invalid\" */\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n                params->max_ack_delay = (uint16_t)v;\n            });\n            DECODE_TP(QUICLY_TRANSPORT_PARAMETER_ID_MIN_ACK_DELAY, {\n                if ((params->min_ack_delay_usec = ptls_decode_quicint(&src, end)) == UINT64_MAX) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n                if (params->min_ack_delay_usec >= 16777216) { /* \"values of 2^24 or greater are invalid\" */\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n            });\n            DECODE_TP(QUICLY_TRANSPORT_PARAMETER_ID_ACTIVE_CONNECTION_ID_LIMIT, {\n                uint64_t v;\n                if ((v = ptls_decode_quicint(&src, end)) == UINT64_MAX) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n                if (v < QUICLY_MIN_ACTIVE_CONNECTION_ID_LIMIT) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n                params->active_connection_id_limit = v;\n            });\n            DECODE_TP(QUICLY_TRANSPORT_PARAMETER_ID_DISABLE_ACTIVE_MIGRATION, { params->disable_active_migration = 1; });\n            DECODE_TP(QUICLY_TRANSPORT_PARAMETER_ID_MAX_DATAGRAM_FRAME_SIZE, {\n                uint64_t v;\n                if ((v = ptls_decode_quicint(&src, end)) == UINT64_MAX) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n                if (v > UINT16_MAX)\n                    v = UINT16_MAX;\n                params->max_datagram_frame_size = (uint16_t)v;\n            });\n            /* skip unknown extension */\n            if (tp_index >= 0)\n                src = end;\n        });\n    }\n\n    /* check consistency between the transport parameters */\n    if (params->min_ack_delay_usec != UINT64_MAX) {\n        if (params->min_ack_delay_usec > params->max_ack_delay * 1000) {\n            ret = QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;\n            goto Exit;\n        }\n    }\n\n    /* check the absence of CIDs */\n    if ((original_dcid != NULL && original_dcid->len == UINT8_MAX) || (initial_scid != NULL && initial_scid->len == UINT8_MAX) ||\n        (retry_scid != NULL && retry_scid->len == UINT8_MAX)) {\n        ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n        goto Exit;\n    }\n\n    ret = 0;\nExit:\n    if (ret == PTLS_ALERT_DECODE_ERROR)\n        ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n    return ret;\n\n#undef DECODE_TP\n#undef DECODE_CID_TP\n}\n\nstatic uint16_t get_transport_parameters_extension_id(uint32_t quic_version)\n{\n    switch (quic_version) {\n    case QUICLY_PROTOCOL_VERSION_DRAFT27:\n    case QUICLY_PROTOCOL_VERSION_DRAFT29:\n        return QUICLY_TLS_EXTENSION_TYPE_TRANSPORT_PARAMETERS_DRAFT;\n    default:\n        return QUICLY_TLS_EXTENSION_TYPE_TRANSPORT_PARAMETERS_FINAL;\n    }\n}\n\nstatic int collect_transport_parameters(ptls_t *tls, struct st_ptls_handshake_properties_t *properties, uint16_t type)\n{\n    quicly_conn_t *conn = (void *)((char *)properties - offsetof(quicly_conn_t, crypto.handshake_properties));\n    return type == get_transport_parameters_extension_id(conn->super.version);\n}\n\nstatic quicly_conn_t *create_connection(quicly_context_t *ctx, uint32_t protocol_version, const char *server_name,\n                                        struct sockaddr *remote_addr, struct sockaddr *local_addr, ptls_iovec_t *remote_cid,\n                                        const quicly_cid_plaintext_t *local_cid, ptls_handshake_properties_t *handshake_properties,\n                                        void *appdata, uint32_t initcwnd)\n{\n    ptls_t *tls = NULL;\n    quicly_conn_t *conn;\n\n    /* consistency checks */\n    assert(remote_addr != NULL && remote_addr->sa_family != AF_UNSPEC);\n    if (ctx->transport_params.max_datagram_frame_size != 0)\n        assert(ctx->receive_datagram_frame != NULL);\n\n    /* create TLS context */\n    if ((tls = ptls_new(ctx->tls, server_name == NULL)) == NULL)\n        return NULL;\n    if (server_name != NULL && ptls_set_server_name(tls, server_name, strlen(server_name)) != 0) {\n        ptls_free(tls);\n        return NULL;\n    }\n\n    /* allocate memory and start creating QUIC context */\n    if ((conn = malloc(sizeof(*conn))) == NULL) {\n        ptls_free(tls);\n        return NULL;\n    }\n    memset(conn, 0, sizeof(*conn));\n    conn->super.ctx = ctx;\n    conn->super.data = appdata;\n    lock_now(conn, 0);\n    conn->created_at = conn->stash.now;\n    conn->super.stats.handshake_confirmed_msec = UINT64_MAX;\n    set_address(&conn->super.local.address, local_addr);\n    set_address(&conn->super.remote.address, remote_addr);\n    quicly_local_cid_init_set(&conn->super.local.cid_set, ctx->cid_encryptor, local_cid);\n    conn->super.local.long_header_src_cid = conn->super.local.cid_set.cids[0].cid;\n    quicly_remote_cid_init_set(&conn->super.remote.cid_set, remote_cid, ctx->tls->random_bytes);\n    conn->super.state = QUICLY_STATE_FIRSTFLIGHT;\n    if (server_name != NULL) {\n        conn->super.local.bidi.next_stream_id = 0;\n        conn->super.local.uni.next_stream_id = 2;\n        conn->super.remote.bidi.next_stream_id = 1;\n        conn->super.remote.uni.next_stream_id = 3;\n    } else {\n        conn->super.local.bidi.next_stream_id = 1;\n        conn->super.local.uni.next_stream_id = 3;\n        conn->super.remote.bidi.next_stream_id = 0;\n        conn->super.remote.uni.next_stream_id = 2;\n    }\n    conn->super.remote.transport_params = default_transport_params;\n    conn->super.version = protocol_version;\n    conn->super.remote.largest_retire_prior_to = 0;\n    quicly_linklist_init(&conn->super._default_scheduler.active);\n    quicly_linklist_init(&conn->super._default_scheduler.blocked);\n    conn->streams = kh_init(quicly_stream_t);\n    quicly_maxsender_init(&conn->ingress.max_data.sender, conn->super.ctx->transport_params.max_data);\n    quicly_maxsender_init(&conn->ingress.max_streams.uni, conn->super.ctx->transport_params.max_streams_uni);\n    quicly_maxsender_init(&conn->ingress.max_streams.bidi, conn->super.ctx->transport_params.max_streams_bidi);\n    quicly_loss_init(&conn->egress.loss, &conn->super.ctx->loss,\n                     conn->super.ctx->loss.default_initial_rtt /* FIXME remember initial_rtt in session ticket */,\n                     &conn->super.remote.transport_params.max_ack_delay, &conn->super.remote.transport_params.ack_delay_exponent);\n    conn->egress.next_pn_to_skip =\n        calc_next_pn_to_skip(conn->super.ctx->tls, 0, initcwnd, conn->super.ctx->initial_egress_max_udp_payload_size);\n    conn->egress.max_udp_payload_size = conn->super.ctx->initial_egress_max_udp_payload_size;\n    init_max_streams(&conn->egress.max_streams.uni);\n    init_max_streams(&conn->egress.max_streams.bidi);\n    conn->egress.path_challenge.tail_ref = &conn->egress.path_challenge.head;\n    conn->egress.ack_frequency.update_at = INT64_MAX;\n    conn->egress.send_ack_at = INT64_MAX;\n    conn->super.ctx->init_cc->cb(conn->super.ctx->init_cc, &conn->egress.cc, initcwnd, conn->stash.now);\n    conn->egress.ecn.state = conn->super.ctx->enable_ecn ? QUICLY_ECN_PROBING : QUICLY_ECN_OFF;\n    quicly_retire_cid_init(&conn->egress.retire_cid);\n    quicly_linklist_init(&conn->egress.pending_streams.blocked.uni);\n    quicly_linklist_init(&conn->egress.pending_streams.blocked.bidi);\n    quicly_linklist_init(&conn->egress.pending_streams.control);\n    quicly_ratemeter_init(&conn->egress.ratemeter);\n    conn->crypto.tls = tls;\n    if (handshake_properties != NULL) {\n        assert(handshake_properties->additional_extensions == NULL);\n        assert(handshake_properties->collect_extension == NULL);\n        assert(handshake_properties->collected_extensions == NULL);\n        conn->crypto.handshake_properties = *handshake_properties;\n    } else {\n        conn->crypto.handshake_properties = (ptls_handshake_properties_t){{{{NULL}}}};\n    }\n    conn->crypto.handshake_properties.collect_extension = collect_transport_parameters;\n    conn->retry_scid.len = UINT8_MAX;\n    conn->idle_timeout.at = INT64_MAX;\n    conn->idle_timeout.should_rearm_on_send = 1;\n    conn->stash.on_ack_stream.active_acked_cache.stream_id = INT64_MIN;\n\n    *ptls_get_data_ptr(tls) = conn;\n\n    update_open_count(conn->super.ctx, 1);\n\n    return conn;\n}\n\nstatic int client_collected_extensions(ptls_t *tls, ptls_handshake_properties_t *properties, ptls_raw_extension_t *slots)\n{\n    quicly_conn_t *conn = (void *)((char *)properties - offsetof(quicly_conn_t, crypto.handshake_properties));\n    int ret;\n\n    assert(properties->client.early_data_acceptance != PTLS_EARLY_DATA_ACCEPTANCE_UNKNOWN);\n\n    if (slots[0].type == UINT16_MAX) {\n        ret = PTLS_ALERT_MISSING_EXTENSION;\n        goto Exit;\n    }\n    assert(slots[0].type == get_transport_parameters_extension_id(conn->super.version));\n    assert(slots[1].type == UINT16_MAX);\n\n    const uint8_t *src = slots[0].data.base, *end = src + slots[0].data.len;\n    quicly_transport_parameters_t params;\n    quicly_cid_t original_dcid, initial_scid, retry_scid = {};\n\n    /* obtain pointer to initial CID of the peer. It is guaranteed to exist in the first slot, as TP is received before any frame\n     * that updates the CID set. */\n    quicly_remote_cid_t *remote_cid = &conn->super.remote.cid_set.cids[0];\n    assert(remote_cid->sequence == 0);\n\n    /* decode */\n    if ((ret = quicly_decode_transport_parameter_list(&params, needs_cid_auth(conn) || is_retry(conn) ? &original_dcid : NULL,\n                                                      needs_cid_auth(conn) ? &initial_scid : &tp_cid_ignore,\n                                                      needs_cid_auth(conn) ? is_retry(conn) ? &retry_scid : NULL : &tp_cid_ignore,\n                                                      remote_cid->stateless_reset_token, src, end)) != 0)\n        goto Exit;\n\n    /* validate CIDs */\n    if (needs_cid_auth(conn) || is_retry(conn)) {\n        if (!quicly_cid_is_equal(&conn->super.original_dcid, ptls_iovec_init(original_dcid.cid, original_dcid.len))) {\n            ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n            goto Exit;\n        }\n    }\n    if (needs_cid_auth(conn)) {\n        if (!quicly_cid_is_equal(&remote_cid->cid, ptls_iovec_init(initial_scid.cid, initial_scid.len))) {\n            ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n            goto Exit;\n        }\n        if (is_retry(conn)) {\n            if (!quicly_cid_is_equal(&conn->retry_scid, ptls_iovec_init(retry_scid.cid, retry_scid.len))) {\n                ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                goto Exit;\n            }\n        }\n    }\n\n    if (properties->client.early_data_acceptance == PTLS_EARLY_DATA_ACCEPTED) {\n#define ZERORTT_VALIDATE(x)                                                                                                        \\\n    if (params.x < conn->super.remote.transport_params.x) {                                                                        \\\n        ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;                                                                          \\\n        goto Exit;                                                                                                                 \\\n    }\n        ZERORTT_VALIDATE(max_data);\n        ZERORTT_VALIDATE(max_stream_data.bidi_local);\n        ZERORTT_VALIDATE(max_stream_data.bidi_remote);\n        ZERORTT_VALIDATE(max_stream_data.uni);\n        ZERORTT_VALIDATE(max_streams_bidi);\n        ZERORTT_VALIDATE(max_streams_uni);\n#undef ZERORTT_VALIDATE\n    }\n\n    /* store the results */\n    conn->super.remote.transport_params = params;\n    ack_frequency_set_next_update_at(conn);\n\nExit:\n    return ret; /* negative error codes used to transmit QUIC errors through picotls */\n}\n\nint quicly_connect(quicly_conn_t **_conn, quicly_context_t *ctx, const char *server_name, struct sockaddr *dest_addr,\n                   struct sockaddr *src_addr, const quicly_cid_plaintext_t *new_cid, ptls_iovec_t address_token,\n                   ptls_handshake_properties_t *handshake_properties, const quicly_transport_parameters_t *resumed_transport_params,\n                   void *appdata)\n{\n    const struct st_ptls_salt_t *salt;\n    quicly_conn_t *conn = NULL;\n    const quicly_cid_t *server_cid;\n    ptls_buffer_t buf;\n    size_t epoch_offsets[5] = {0};\n    size_t max_early_data_size = 0;\n    int ret;\n\n    if ((salt = get_salt(ctx->initial_version)) == NULL) {\n        if ((ctx->initial_version & 0x0f0f0f0f) == 0x0a0a0a0a) {\n            /* greasing version, use our own greasing salt */\n            static const struct st_ptls_salt_t grease_salt = {.initial = {0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe,\n                                                                          0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad,\n                                                                          0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef}};\n            salt = &grease_salt;\n        } else {\n            ret = QUICLY_ERROR_INVALID_INITIAL_VERSION;\n            goto Exit;\n        }\n    }\n\n    if ((conn = create_connection(\n             ctx, ctx->initial_version, server_name, dest_addr, src_addr, NULL, new_cid, handshake_properties, appdata,\n             quicly_cc_calc_initial_cwnd(ctx->initcwnd_packets, ctx->transport_params.max_udp_payload_size))) == NULL) {\n        ret = PTLS_ERROR_NO_MEMORY;\n        goto Exit;\n    }\n    conn->super.remote.address_validation.validated = 1;\n    conn->super.remote.address_validation.send_probe = 1;\n    if (address_token.len != 0) {\n        if ((conn->token.base = malloc(address_token.len)) == NULL) {\n            ret = PTLS_ERROR_NO_MEMORY;\n            goto Exit;\n        }\n        memcpy(conn->token.base, address_token.base, address_token.len);\n        conn->token.len = address_token.len;\n    }\n    server_cid = quicly_get_remote_cid(conn);\n    conn->super.original_dcid = *server_cid;\n\n    QUICLY_PROBE(CONNECT, conn, conn->stash.now, conn->super.version);\n    QUICLY_LOG_CONN(connect, conn, { PTLS_LOG_ELEMENT_UNSIGNED(version, conn->super.version); });\n\n    if ((ret = setup_handshake_space_and_flow(conn, QUICLY_EPOCH_INITIAL)) != 0)\n        goto Exit;\n    if ((ret = setup_initial_encryption(get_aes128gcmsha256(ctx), &conn->initial->cipher.ingress, &conn->initial->cipher.egress,\n                                        ptls_iovec_init(server_cid->cid, server_cid->len), 1,\n                                        ptls_iovec_init(salt->initial, sizeof(salt->initial)), conn)) != 0)\n        goto Exit;\n\n    /* handshake (we always encode authentication CIDs, as we do not (yet) regenerate ClientHello when receiving Retry) */\n    ptls_buffer_init(&conn->crypto.transport_params.buf, \"\", 0);\n    if ((ret = quicly_encode_transport_parameter_list(\n             &conn->crypto.transport_params.buf, &conn->super.ctx->transport_params, NULL, &conn->super.local.cid_set.cids[0].cid,\n             NULL, NULL, conn->super.ctx->expand_client_hello ? conn->super.ctx->initial_egress_max_udp_payload_size : 0)) != 0)\n        goto Exit;\n    conn->crypto.transport_params.ext[0] =\n        (ptls_raw_extension_t){QUICLY_TLS_EXTENSION_TYPE_TRANSPORT_PARAMETERS_FINAL,\n                               {conn->crypto.transport_params.buf.base, conn->crypto.transport_params.buf.off}};\n    conn->crypto.transport_params.ext[1] =\n        (ptls_raw_extension_t){QUICLY_TLS_EXTENSION_TYPE_TRANSPORT_PARAMETERS_DRAFT,\n                               {conn->crypto.transport_params.buf.base, conn->crypto.transport_params.buf.off}};\n    conn->crypto.transport_params.ext[2] = (ptls_raw_extension_t){UINT16_MAX};\n    conn->crypto.handshake_properties.additional_extensions = conn->crypto.transport_params.ext;\n    conn->crypto.handshake_properties.collected_extensions = client_collected_extensions;\n\n    ptls_buffer_init(&buf, \"\", 0);\n    if (resumed_transport_params != NULL)\n        conn->crypto.handshake_properties.client.max_early_data_size = &max_early_data_size;\n    ret = ptls_handle_message(conn->crypto.tls, &buf, epoch_offsets, 0, NULL, 0, &conn->crypto.handshake_properties);\n    conn->crypto.handshake_properties.client.max_early_data_size = NULL;\n    if (ret != PTLS_ERROR_IN_PROGRESS) {\n        assert(ret > 0); /* no QUIC errors */\n        goto Exit;\n    }\n    write_crypto_data(conn, &buf, epoch_offsets);\n    ptls_buffer_dispose(&buf);\n\n    if (max_early_data_size != 0) {\n        /* when attempting 0-RTT, apply the remembered transport parameters */\n#define APPLY(n) conn->super.remote.transport_params.n = resumed_transport_params->n\n        APPLY(active_connection_id_limit);\n        APPLY(max_data);\n        APPLY(max_stream_data.bidi_local);\n        APPLY(max_stream_data.bidi_remote);\n        APPLY(max_stream_data.uni);\n        APPLY(max_streams_bidi);\n        APPLY(max_streams_uni);\n#undef APPLY\n        if ((ret = apply_remote_transport_params(conn)) != 0)\n            goto Exit;\n    }\n\n    *_conn = conn;\n    ret = 0;\n\nExit:\n    if (conn != NULL)\n        unlock_now(conn);\n    if (ret != 0) {\n        if (conn != NULL)\n            quicly_free(conn);\n    }\n    return ret;\n}\n\nstatic int server_collected_extensions(ptls_t *tls, ptls_handshake_properties_t *properties, ptls_raw_extension_t *slots)\n{\n    quicly_conn_t *conn = (void *)((char *)properties - offsetof(quicly_conn_t, crypto.handshake_properties));\n    quicly_cid_t initial_scid;\n    int ret;\n\n    if (slots[0].type == UINT16_MAX) {\n        ret = PTLS_ALERT_MISSING_EXTENSION;\n        goto Exit;\n    }\n    assert(slots[0].type == get_transport_parameters_extension_id(conn->super.version));\n    assert(slots[1].type == UINT16_MAX);\n\n    { /* decode transport_parameters extension */\n        const uint8_t *src = slots[0].data.base, *end = src + slots[0].data.len;\n        if ((ret = quicly_decode_transport_parameter_list(&conn->super.remote.transport_params,\n                                                          needs_cid_auth(conn) ? NULL : &tp_cid_ignore,\n                                                          needs_cid_auth(conn) ? &initial_scid : &tp_cid_ignore,\n                                                          needs_cid_auth(conn) ? NULL : &tp_cid_ignore, NULL, src, end)) != 0)\n            goto Exit;\n        if (needs_cid_auth(conn) &&\n            !quicly_cid_is_equal(&conn->super.remote.cid_set.cids[0].cid, ptls_iovec_init(initial_scid.cid, initial_scid.len))) {\n            ret = QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;\n            goto Exit;\n        }\n    }\n\n    /* setup ack frequency */\n    ack_frequency_set_next_update_at(conn);\n\n    /* update UDP max payload size to:\n     * max(current, min(max_the_remote_sent, remote.tp.max_udp_payload_size, local.tp.max_udp_payload_size)) */\n    assert(conn->initial != NULL);\n    if (conn->egress.max_udp_payload_size < conn->initial->largest_ingress_udp_payload_size) {\n        uint16_t size = conn->initial->largest_ingress_udp_payload_size;\n        if (size > conn->super.remote.transport_params.max_udp_payload_size)\n            size = conn->super.remote.transport_params.max_udp_payload_size;\n        if (size > conn->super.ctx->transport_params.max_udp_payload_size)\n            size = conn->super.ctx->transport_params.max_udp_payload_size;\n        conn->egress.max_udp_payload_size = size;\n    }\n\n    /* set transport_parameters extension to be sent in EE */\n    assert(properties->additional_extensions == NULL);\n    ptls_buffer_init(&conn->crypto.transport_params.buf, \"\", 0);\n    assert(conn->super.local.cid_set.cids[0].sequence == 0 && \"make sure that local_cid is in expected state before sending SRT\");\n    if ((ret = quicly_encode_transport_parameter_list(\n             &conn->crypto.transport_params.buf, &conn->super.ctx->transport_params,\n             needs_cid_auth(conn) || is_retry(conn) ? &conn->super.original_dcid : NULL,\n             needs_cid_auth(conn) ? &conn->super.local.cid_set.cids[0].cid : NULL,\n             needs_cid_auth(conn) && is_retry(conn) ? &conn->retry_scid : NULL,\n             conn->super.ctx->cid_encryptor != NULL ? conn->super.local.cid_set.cids[0].stateless_reset_token : NULL, 0)) != 0)\n        goto Exit;\n    properties->additional_extensions = conn->crypto.transport_params.ext;\n    conn->crypto.transport_params.ext[0] =\n        (ptls_raw_extension_t){get_transport_parameters_extension_id(conn->super.version),\n                               {conn->crypto.transport_params.buf.base, conn->crypto.transport_params.buf.off}};\n    conn->crypto.transport_params.ext[1] = (ptls_raw_extension_t){UINT16_MAX};\n    conn->crypto.handshake_properties.additional_extensions = conn->crypto.transport_params.ext;\n\n    ret = 0;\n\nExit:\n    return ret;\n}\n\nstatic size_t aead_decrypt_core(ptls_aead_context_t *aead, uint64_t pn, quicly_decoded_packet_t *packet, size_t aead_off)\n{\n    return ptls_aead_decrypt(aead, packet->octets.base + aead_off, packet->octets.base + aead_off, packet->octets.len - aead_off,\n                             pn, packet->octets.base, aead_off);\n}\n\nstatic int aead_decrypt_fixed_key(void *ctx, uint64_t pn, quicly_decoded_packet_t *packet, size_t aead_off, size_t *ptlen)\n{\n    ptls_aead_context_t *aead = ctx;\n\n    if ((*ptlen = aead_decrypt_core(aead, pn, packet, aead_off)) == SIZE_MAX)\n        return QUICLY_ERROR_PACKET_IGNORED;\n    return 0;\n}\n\nstatic int aead_decrypt_1rtt(void *ctx, uint64_t pn, quicly_decoded_packet_t *packet, size_t aead_off, size_t *ptlen)\n{\n    quicly_conn_t *conn = ctx;\n    struct st_quicly_application_space_t *space = conn->application;\n    size_t aead_index = (packet->octets.base[0] & QUICLY_KEY_PHASE_BIT) != 0;\n    int ret;\n\n    /* prepare key, when not available (yet) */\n    if (space->cipher.ingress.aead[aead_index] == NULL) {\n    Retry_1RTT : {\n        /* Replace the AEAD key at the alternative slot (note: decryption key slots are shared by 0-RTT and 1-RTT), at the same time\n         * dropping 0-RTT header protection key. */\n        if (conn->application->cipher.ingress.header_protection.zero_rtt != NULL) {\n            ptls_cipher_free(conn->application->cipher.ingress.header_protection.zero_rtt);\n            conn->application->cipher.ingress.header_protection.zero_rtt = NULL;\n        }\n        ptls_cipher_suite_t *cipher = ptls_get_cipher(conn->crypto.tls);\n        if ((ret = update_1rtt_key(conn, cipher, 0, &space->cipher.ingress.aead[aead_index], space->cipher.ingress.secret)) != 0)\n            return ret;\n        ++space->cipher.ingress.key_phase.prepared;\n        QUICLY_PROBE(CRYPTO_RECEIVE_KEY_UPDATE_PREPARE, conn, conn->stash.now, space->cipher.ingress.key_phase.prepared,\n                     QUICLY_PROBE_HEXDUMP(space->cipher.ingress.secret, cipher->hash->digest_size));\n        QUICLY_LOG_CONN(crypto_receive_key_update_prepare, conn, {\n            PTLS_LOG_ELEMENT_UNSIGNED(phase, space->cipher.ingress.key_phase.prepared);\n            PTLS_LOG_APPDATA_ELEMENT_HEXDUMP(secret, space->cipher.ingress.secret, cipher->hash->digest_size);\n        });\n    }\n    }\n\n    /* decrypt */\n    ptls_aead_context_t *aead = space->cipher.ingress.aead[aead_index];\n    if ((*ptlen = aead_decrypt_core(aead, pn, packet, aead_off)) == SIZE_MAX) {\n        /* retry with a new key, if possible */\n        if (space->cipher.ingress.key_phase.decrypted == space->cipher.ingress.key_phase.prepared &&\n            space->cipher.ingress.key_phase.decrypted % 2 != aead_index) {\n            /* reapply AEAD to revert payload to the encrypted form. This assumes that the cipher used in AEAD is CTR. */\n            aead_decrypt_core(aead, pn, packet, aead_off);\n            goto Retry_1RTT;\n        }\n        /* otherwise return failure */\n        return QUICLY_ERROR_PACKET_IGNORED;\n    }\n\n    /* update the confirmed key phase and also the egress key phase, if necessary */\n    if (space->cipher.ingress.key_phase.prepared != space->cipher.ingress.key_phase.decrypted &&\n        space->cipher.ingress.key_phase.prepared % 2 == aead_index) {\n        if ((ret = received_key_update(conn, space->cipher.ingress.key_phase.prepared)) != 0)\n            return ret;\n    }\n\n    return 0;\n}\n\nstatic int do_decrypt_packet(ptls_cipher_context_t *header_protection,\n                             int (*aead_cb)(void *, uint64_t, quicly_decoded_packet_t *, size_t, size_t *), void *aead_ctx,\n                             uint64_t *next_expected_pn, quicly_decoded_packet_t *packet, uint64_t *pn, ptls_iovec_t *payload)\n{\n    size_t encrypted_len = packet->octets.len - packet->encrypted_off;\n    uint8_t hpmask[5] = {0};\n    uint32_t pnbits = 0;\n    size_t pnlen, ptlen, i;\n    int ret;\n\n    /* decipher the header protection, as well as obtaining pnbits, pnlen */\n    if (encrypted_len < header_protection->algo->iv_size + QUICLY_MAX_PN_SIZE) {\n        *pn = UINT64_MAX;\n        return QUICLY_ERROR_PACKET_IGNORED;\n    }\n    ptls_cipher_init(header_protection, packet->octets.base + packet->encrypted_off + QUICLY_MAX_PN_SIZE);\n    ptls_cipher_encrypt(header_protection, hpmask, hpmask, sizeof(hpmask));\n    packet->octets.base[0] ^= hpmask[0] & (QUICLY_PACKET_IS_LONG_HEADER(packet->octets.base[0]) ? 0xf : 0x1f);\n    pnlen = (packet->octets.base[0] & 0x3) + 1;\n    for (i = 0; i != pnlen; ++i) {\n        packet->octets.base[packet->encrypted_off + i] ^= hpmask[i + 1];\n        pnbits = (pnbits << 8) | packet->octets.base[packet->encrypted_off + i];\n    }\n\n    size_t aead_off = packet->encrypted_off + pnlen;\n    *pn = quicly_determine_packet_number(pnbits, pnlen * 8, *next_expected_pn);\n\n    /* AEAD decryption */\n    if ((ret = (*aead_cb)(aead_ctx, *pn, packet, aead_off, &ptlen)) != 0) {\n        return ret;\n    }\n    if (*next_expected_pn <= *pn)\n        *next_expected_pn = *pn + 1;\n\n    *payload = ptls_iovec_init(packet->octets.base + aead_off, ptlen);\n    return 0;\n}\n\nstatic int decrypt_packet(ptls_cipher_context_t *header_protection,\n                          int (*aead_cb)(void *, uint64_t, quicly_decoded_packet_t *, size_t, size_t *), void *aead_ctx,\n                          uint64_t *next_expected_pn, quicly_decoded_packet_t *packet, uint64_t *pn, ptls_iovec_t *payload)\n{\n    int ret;\n\n    /* decrypt ourselves, or use the pre-decrypted input */\n    if (packet->decrypted.pn == UINT64_MAX) {\n        if ((ret = do_decrypt_packet(header_protection, aead_cb, aead_ctx, next_expected_pn, packet, pn, payload)) != 0)\n            return ret;\n    } else {\n        *payload = ptls_iovec_init(packet->octets.base + packet->encrypted_off, packet->octets.len - packet->encrypted_off);\n        *pn = packet->decrypted.pn;\n        if (aead_cb == aead_decrypt_1rtt) {\n            quicly_conn_t *conn = aead_ctx;\n            if (conn->application->cipher.ingress.key_phase.decrypted < packet->decrypted.key_phase) {\n                if ((ret = received_key_update(conn, packet->decrypted.key_phase)) != 0)\n                    return ret;\n            }\n        }\n        if (*next_expected_pn < *pn)\n            *next_expected_pn = *pn + 1;\n    }\n\n    /* check reserved bits after AEAD decryption */\n    if ((packet->octets.base[0] & (QUICLY_PACKET_IS_LONG_HEADER(packet->octets.base[0]) ? QUICLY_LONG_HEADER_RESERVED_BITS\n                                                                                        : QUICLY_SHORT_HEADER_RESERVED_BITS)) !=\n        0) {\n        return QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;\n    }\n    if (payload->len == 0) {\n        return QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;\n    }\n\n    return 0;\n}\n\nstatic int do_on_ack_ack(quicly_conn_t *conn, const quicly_sent_packet_t *packet, uint64_t start, uint64_t start_length,\n                         struct st_quicly_sent_ack_additional_t *additional, size_t additional_capacity)\n{\n    /* find the pn space */\n    struct st_quicly_pn_space_t *space;\n    switch (packet->ack_epoch) {\n    case QUICLY_EPOCH_INITIAL:\n        space = &conn->initial->super;\n        break;\n    case QUICLY_EPOCH_HANDSHAKE:\n        space = &conn->handshake->super;\n        break;\n    case QUICLY_EPOCH_1RTT:\n        space = &conn->application->super;\n        break;\n    default:\n        assert(!\"FIXME\");\n        return QUICLY_TRANSPORT_ERROR_INTERNAL;\n    }\n\n    /* subtract given ACK ranges */\n    int ret;\n    uint64_t end = start + start_length;\n    if ((ret = quicly_ranges_subtract(&space->ack_queue, start, end)) != 0)\n        return ret;\n    for (size_t i = 0; i < additional_capacity && additional[i].gap != 0; ++i) {\n        start = end + additional[i].gap;\n        end = start + additional[i].length;\n        if ((ret = quicly_ranges_subtract(&space->ack_queue, start, end)) != 0)\n            return ret;\n    }\n\n    /* make adjustments */\n    if (space->ack_queue.num_ranges == 0) {\n        space->largest_pn_received_at = INT64_MAX;\n        space->unacked_count = 0;\n    } else if (space->ack_queue.num_ranges > QUICLY_MAX_ACK_BLOCKS) {\n        quicly_ranges_drop_by_range_indices(&space->ack_queue, space->ack_queue.num_ranges - QUICLY_MAX_ACK_BLOCKS,\n                                            space->ack_queue.num_ranges);\n    }\n\n    return 0;\n}\n\nstatic int on_ack_ack_ranges64(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    quicly_conn_t *conn = (quicly_conn_t *)((char *)map - offsetof(quicly_conn_t, egress.loss.sentmap));\n\n    /* TODO log */\n\n    return acked ? do_on_ack_ack(conn, packet, sent->data.ack.start, sent->data.ack.ranges64.start_length,\n                                 sent->data.ack.ranges64.additional, PTLS_ELEMENTSOF(sent->data.ack.ranges64.additional))\n                 : 0;\n}\n\nstatic int on_ack_ack_ranges8(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    quicly_conn_t *conn = (quicly_conn_t *)((char *)map - offsetof(quicly_conn_t, egress.loss.sentmap));\n\n    /* TODO log */\n\n    return acked ? do_on_ack_ack(conn, packet, sent->data.ack.start, sent->data.ack.ranges8.start_length,\n                                 sent->data.ack.ranges8.additional, PTLS_ELEMENTSOF(sent->data.ack.ranges8.additional))\n                 : 0;\n}\n\nstatic int on_ack_stream_ack_one(quicly_conn_t *conn, quicly_stream_id_t stream_id, quicly_sendstate_sent_t *sent)\n{\n    quicly_stream_t *stream;\n    int ret;\n\n    if ((stream = quicly_get_stream(conn, stream_id)) == NULL)\n        return 0;\n\n    size_t bytes_to_shift;\n    if ((ret = quicly_sendstate_acked(&stream->sendstate, sent, &bytes_to_shift)) != 0)\n        return ret;\n    if (bytes_to_shift != 0) {\n        QUICLY_PROBE(STREAM_ON_SEND_SHIFT, stream->conn, stream->conn->stash.now, stream, bytes_to_shift);\n        stream->callbacks->on_send_shift(stream, bytes_to_shift);\n        QUICLY_LOG_CONN(stream_on_send_shift, stream->conn, {\n            PTLS_LOG_ELEMENT_SIGNED(stream_id, stream->stream_id);\n            PTLS_LOG_ELEMENT_UNSIGNED(delta, bytes_to_shift);\n        });\n    }\n    if (stream_is_destroyable(stream)) {\n        destroy_stream(stream, 0);\n    } else if (stream->_send_aux.reset_stream.sender_state == QUICLY_SENDER_STATE_NONE) {\n        resched_stream_data(stream);\n    }\n\n    return 0;\n}\n\nstatic int on_ack_stream_ack_cached(quicly_conn_t *conn)\n{\n    int ret;\n\n    if (conn->stash.on_ack_stream.active_acked_cache.stream_id == INT64_MIN)\n        return 0;\n    ret = on_ack_stream_ack_one(conn, conn->stash.on_ack_stream.active_acked_cache.stream_id,\n                                &conn->stash.on_ack_stream.active_acked_cache.args);\n    conn->stash.on_ack_stream.active_acked_cache.stream_id = INT64_MIN;\n    return ret;\n}\n\nstatic int on_ack_stream(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    quicly_conn_t *conn = (quicly_conn_t *)((char *)map - offsetof(quicly_conn_t, egress.loss.sentmap));\n    int ret;\n\n    if (acked) {\n\n        QUICLY_PROBE(STREAM_ACKED, conn, conn->stash.now, sent->data.stream.stream_id, sent->data.stream.args.start,\n                     sent->data.stream.args.end - sent->data.stream.args.start);\n        QUICLY_LOG_CONN(stream_acked, conn, {\n            PTLS_LOG_ELEMENT_SIGNED(stream_id, sent->data.stream.stream_id);\n            PTLS_LOG_ELEMENT_UNSIGNED(off, sent->data.stream.args.start);\n            PTLS_LOG_ELEMENT_UNSIGNED(len, sent->data.stream.args.end - sent->data.stream.args.start);\n        });\n\n        if (packet->frames_in_flight && conn->stash.on_ack_stream.active_acked_cache.stream_id == sent->data.stream.stream_id &&\n            conn->stash.on_ack_stream.active_acked_cache.args.end == sent->data.stream.args.start) {\n            /* Fast path: append the newly supplied range to the existing cached range. */\n            conn->stash.on_ack_stream.active_acked_cache.args.end = sent->data.stream.args.end;\n        } else {\n            /* Slow path: submit the cached range, and if possible, cache the newly supplied range. Else submit the newly supplied\n             * range directly. */\n            if ((ret = on_ack_stream_ack_cached(conn)) != 0)\n                return ret;\n            if (packet->frames_in_flight) {\n                conn->stash.on_ack_stream.active_acked_cache.stream_id = sent->data.stream.stream_id;\n                conn->stash.on_ack_stream.active_acked_cache.args = sent->data.stream.args;\n            } else {\n                if ((ret = on_ack_stream_ack_one(conn, sent->data.stream.stream_id, &sent->data.stream.args)) != 0)\n                    return ret;\n            }\n        }\n\n    } else {\n\n        QUICLY_PROBE(STREAM_LOST, conn, conn->stash.now, sent->data.stream.stream_id, sent->data.stream.args.start,\n                     sent->data.stream.args.end - sent->data.stream.args.start);\n        QUICLY_LOG_CONN(stream_lost, conn, {\n            PTLS_LOG_ELEMENT_SIGNED(stream_id, sent->data.stream.stream_id);\n            PTLS_LOG_ELEMENT_UNSIGNED(off, sent->data.stream.args.start);\n            PTLS_LOG_ELEMENT_UNSIGNED(len, sent->data.stream.args.end - sent->data.stream.args.start);\n        });\n\n        quicly_stream_t *stream;\n        if ((stream = quicly_get_stream(conn, sent->data.stream.stream_id)) == NULL)\n            return 0;\n        /* FIXME handle rto error */\n        if ((ret = quicly_sendstate_lost(&stream->sendstate, &sent->data.stream.args)) != 0)\n            return ret;\n        if (stream->_send_aux.reset_stream.sender_state == QUICLY_SENDER_STATE_NONE)\n            resched_stream_data(stream);\n    }\n\n    return 0;\n}\n\nstatic int on_ack_max_stream_data(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    quicly_conn_t *conn = (quicly_conn_t *)((char *)map - offsetof(quicly_conn_t, egress.loss.sentmap));\n    quicly_stream_t *stream;\n\n    if ((stream = quicly_get_stream(conn, sent->data.stream.stream_id)) != NULL) {\n        if (acked) {\n            quicly_maxsender_acked(&stream->_send_aux.max_stream_data_sender, &sent->data.max_stream_data.args);\n        } else {\n            quicly_maxsender_lost(&stream->_send_aux.max_stream_data_sender, &sent->data.max_stream_data.args);\n            if (should_send_max_stream_data(stream))\n                sched_stream_control(stream);\n        }\n    }\n\n    return 0;\n}\n\nstatic int on_ack_max_data(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    quicly_conn_t *conn = (quicly_conn_t *)((char *)map - offsetof(quicly_conn_t, egress.loss.sentmap));\n\n    if (acked) {\n        quicly_maxsender_acked(&conn->ingress.max_data.sender, &sent->data.max_data.args);\n    } else {\n        quicly_maxsender_lost(&conn->ingress.max_data.sender, &sent->data.max_data.args);\n    }\n\n    return 0;\n}\n\nstatic int on_ack_max_streams(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    quicly_conn_t *conn = (quicly_conn_t *)((char *)map - offsetof(quicly_conn_t, egress.loss.sentmap));\n    quicly_maxsender_t *maxsender = sent->data.max_streams.uni ? &conn->ingress.max_streams.uni : &conn->ingress.max_streams.bidi;\n    assert(maxsender != NULL); /* we would only receive an ACK if we have sent the frame */\n\n    if (acked) {\n        quicly_maxsender_acked(maxsender, &sent->data.max_streams.args);\n    } else {\n        quicly_maxsender_lost(maxsender, &sent->data.max_streams.args);\n    }\n\n    return 0;\n}\n\nstatic void on_ack_stream_state_sender(quicly_sender_state_t *sender_state, int acked)\n{\n    *sender_state = acked ? QUICLY_SENDER_STATE_ACKED : QUICLY_SENDER_STATE_SEND;\n}\n\nstatic int on_ack_reset_stream(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    quicly_conn_t *conn = (quicly_conn_t *)((char *)map - offsetof(quicly_conn_t, egress.loss.sentmap));\n    quicly_stream_t *stream;\n\n    if ((stream = quicly_get_stream(conn, sent->data.stream_state_sender.stream_id)) != NULL) {\n        on_ack_stream_state_sender(&stream->_send_aux.reset_stream.sender_state, acked);\n        if (stream_is_destroyable(stream))\n            destroy_stream(stream, 0);\n    }\n\n    return 0;\n}\n\nstatic int on_ack_stop_sending(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    quicly_conn_t *conn = (quicly_conn_t *)((char *)map - offsetof(quicly_conn_t, egress.loss.sentmap));\n    quicly_stream_t *stream;\n\n    if ((stream = quicly_get_stream(conn, sent->data.stream_state_sender.stream_id)) != NULL) {\n        on_ack_stream_state_sender(&stream->_send_aux.stop_sending.sender_state, acked);\n        if (stream->_send_aux.stop_sending.sender_state != QUICLY_SENDER_STATE_ACKED)\n            sched_stream_control(stream);\n    }\n\n    return 0;\n}\n\nstatic int on_ack_streams_blocked(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    quicly_conn_t *conn = (quicly_conn_t *)((char *)map - offsetof(quicly_conn_t, egress.loss.sentmap));\n    struct st_quicly_max_streams_t *m =\n        sent->data.streams_blocked.uni ? &conn->egress.max_streams.uni : &conn->egress.max_streams.bidi;\n\n    if (acked) {\n        quicly_maxsender_acked(&m->blocked_sender, &sent->data.streams_blocked.args);\n    } else {\n        quicly_maxsender_lost(&m->blocked_sender, &sent->data.streams_blocked.args);\n    }\n\n    return 0;\n}\n\nstatic int on_ack_handshake_done(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    quicly_conn_t *conn = (quicly_conn_t *)((char *)map - offsetof(quicly_conn_t, egress.loss.sentmap));\n\n    /* When lost, reschedule for transmission. When acked, suppress retransmission if scheduled. */\n    if (acked) {\n        conn->egress.pending_flows &= ~QUICLY_PENDING_FLOW_HANDSHAKE_DONE_BIT;\n    } else {\n        conn->egress.pending_flows |= QUICLY_PENDING_FLOW_HANDSHAKE_DONE_BIT;\n    }\n    return 0;\n}\n\nstatic int on_ack_data_blocked(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    quicly_conn_t *conn = (quicly_conn_t *)((char *)map - offsetof(quicly_conn_t, egress.loss.sentmap));\n\n    if (conn->egress.max_data.permitted == sent->data.data_blocked.offset) {\n        if (acked) {\n            conn->egress.data_blocked = QUICLY_SENDER_STATE_ACKED;\n        } else if (packet->frames_in_flight && conn->egress.data_blocked == QUICLY_SENDER_STATE_UNACKED) {\n            conn->egress.data_blocked = QUICLY_SENDER_STATE_SEND;\n            conn->egress.pending_flows |= QUICLY_PENDING_FLOW_OTHERS_BIT;\n        }\n    }\n\n    return 0;\n}\n\nstatic int on_ack_stream_data_blocked_frame(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked,\n                                            quicly_sent_t *sent)\n{\n    quicly_conn_t *conn = (quicly_conn_t *)((char *)map - offsetof(quicly_conn_t, egress.loss.sentmap));\n    quicly_stream_t *stream;\n\n    if ((stream = quicly_get_stream(conn, sent->data.stream_data_blocked.stream_id)) == NULL)\n        return 0;\n\n    if (stream->_send_aux.max_stream_data == sent->data.stream_data_blocked.offset) {\n        if (acked) {\n            stream->_send_aux.blocked = QUICLY_SENDER_STATE_ACKED;\n        } else if (packet->frames_in_flight && stream->_send_aux.blocked == QUICLY_SENDER_STATE_UNACKED) {\n            stream->_send_aux.blocked = QUICLY_SENDER_STATE_SEND;\n            sched_stream_control(stream);\n        }\n    }\n\n    return 0;\n}\n\nstatic int on_ack_new_token(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    quicly_conn_t *conn = (quicly_conn_t *)((char *)map - offsetof(quicly_conn_t, egress.loss.sentmap));\n\n    if (sent->data.new_token.is_inflight) {\n        --conn->egress.new_token.num_inflight;\n        sent->data.new_token.is_inflight = 0;\n    }\n    if (acked) {\n        QUICLY_PROBE(NEW_TOKEN_ACKED, conn, conn->stash.now, sent->data.new_token.generation);\n        QUICLY_LOG_CONN(new_token_acked, conn, { PTLS_LOG_ELEMENT_UNSIGNED(generation, sent->data.new_token.generation); });\n        if (conn->egress.new_token.max_acked < sent->data.new_token.generation)\n            conn->egress.new_token.max_acked = sent->data.new_token.generation;\n    }\n\n    if (conn->egress.new_token.num_inflight == 0 && conn->egress.new_token.max_acked < conn->egress.new_token.generation)\n        conn->egress.pending_flows |= QUICLY_PENDING_FLOW_OTHERS_BIT;\n\n    return 0;\n}\n\nstatic int on_ack_new_connection_id(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    quicly_conn_t *conn = (quicly_conn_t *)((char *)map - offsetof(quicly_conn_t, egress.loss.sentmap));\n    uint64_t sequence = sent->data.new_connection_id.sequence;\n\n    if (acked) {\n        quicly_local_cid_on_acked(&conn->super.local.cid_set, sequence);\n    } else {\n        if (quicly_local_cid_on_lost(&conn->super.local.cid_set, sequence))\n            conn->egress.pending_flows |= QUICLY_PENDING_FLOW_OTHERS_BIT;\n    }\n\n    return 0;\n}\n\nstatic int on_ack_retire_connection_id(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    quicly_conn_t *conn = (quicly_conn_t *)((char *)map - offsetof(quicly_conn_t, egress.loss.sentmap));\n    uint64_t sequence = sent->data.retire_connection_id.sequence;\n\n    if (!acked)\n        schedule_retire_connection_id_frame(conn, sequence);\n\n    return 0;\n}\n\nstatic int should_send_datagram_frame(quicly_conn_t *conn)\n{\n    if (conn->egress.datagram_frame_payloads.count == 0)\n        return 0;\n    if (conn->application == NULL)\n        return 0;\n    if (conn->application->cipher.egress.key.aead == NULL)\n        return 0;\n    return 1;\n}\n\nstatic inline uint64_t calc_amplification_limit_allowance(quicly_conn_t *conn)\n{\n    if (conn->super.remote.address_validation.validated)\n        return UINT64_MAX;\n    uint64_t budget = conn->super.stats.num_bytes.received * conn->super.ctx->pre_validation_amplification_limit;\n    if (budget <= conn->super.stats.num_bytes.sent)\n        return 0;\n    return budget - conn->super.stats.num_bytes.sent;\n}\n\n/* Helper function to compute send window based on:\n * * state of peer validation,\n * * current cwnd,\n * * minimum send requirements in |min_bytes_to_send|, and\n * * if sending is to be restricted to the minimum, indicated in |restrict_sending|\n */\nstatic size_t calc_send_window(quicly_conn_t *conn, size_t min_bytes_to_send, uint64_t amp_window, int restrict_sending)\n{\n    uint64_t window = 0;\n    if (restrict_sending) {\n        /* Send min_bytes_to_send on PTO */\n        window = min_bytes_to_send;\n    } else {\n        /* Limit to cwnd */\n        if (conn->egress.cc.cwnd > conn->egress.loss.sentmap.bytes_in_flight)\n            window = conn->egress.cc.cwnd - conn->egress.loss.sentmap.bytes_in_flight;\n        /* Allow at least one packet on time-threshold loss detection */\n        window = window > min_bytes_to_send ? window : min_bytes_to_send;\n    }\n    /* Cap the window by the amount allowed by address validation */\n    if (amp_window < window)\n        window = amp_window;\n\n    return window;\n}\n\n/**\n * Checks if the server is waiting for ClientFinished. When that is the case, the loss timer is deactivated, to avoid repeatedly\n * sending 1-RTT packets while the client spends time verifying the certificate chain at the same time buffering 1-RTT packets.\n */\nstatic int is_point5rtt_with_no_handshake_data_to_send(quicly_conn_t *conn)\n{\n    /* bail out unless this is a server-side connection waiting for ClientFinished */\n    if (!(conn->handshake != NULL && conn->application != NULL && !quicly_is_client(conn)))\n        return 0;\n    quicly_stream_t *stream = quicly_get_stream(conn, (quicly_stream_id_t)-1 - QUICLY_EPOCH_HANDSHAKE);\n    assert(stream != NULL);\n    return stream->sendstate.pending.num_ranges == 0 && stream->sendstate.acked.ranges[0].end == stream->sendstate.size_inflight;\n}\n\nint64_t quicly_get_first_timeout(quicly_conn_t *conn)\n{\n    if (conn->super.state >= QUICLY_STATE_CLOSING)\n        return conn->egress.send_ack_at;\n\n    if (should_send_datagram_frame(conn))\n        return 0;\n\n    uint64_t amp_window = calc_amplification_limit_allowance(conn);\n\n    if (calc_send_window(conn, 0, amp_window, 0) > 0) {\n        if (conn->egress.pending_flows != 0) {\n            /* crypto streams (as indicated by lower 4 bits) can be sent whenever CWND is available; other flows need application\n             * packet number space */\n            if (conn->application != NULL && conn->application->cipher.egress.key.header_protection != NULL)\n                return 0;\n            if ((conn->egress.pending_flows & 0xf) != 0)\n                return 0;\n        }\n        if (quicly_linklist_is_linked(&conn->egress.pending_streams.control))\n            return 0;\n        if (scheduler_can_send(conn))\n            return 0;\n    }\n\n    /* if something can be sent, return the earliest timeout. Otherwise return the idle timeout. */\n    int64_t at = conn->idle_timeout.at;\n    if (amp_window > 0) {\n        if (conn->egress.loss.alarm_at < at && !is_point5rtt_with_no_handshake_data_to_send(conn))\n            at = conn->egress.loss.alarm_at;\n        if (conn->egress.send_ack_at < at)\n            at = conn->egress.send_ack_at;\n    }\n\n    return at;\n}\n\nuint64_t quicly_get_next_expected_packet_number(quicly_conn_t *conn)\n{\n    if (!conn->application)\n        return UINT64_MAX;\n\n    return conn->application->super.next_expected_packet_number;\n}\n\n/**\n * data structure that is used during one call through quicly_send()\n */\nstruct st_quicly_send_context_t {\n    /**\n     * current encryption context\n     */\n    struct {\n        struct st_quicly_cipher_context_t *cipher;\n        uint8_t first_byte;\n    } current;\n    /**\n     * packet under construction\n     */\n    struct {\n        struct st_quicly_cipher_context_t *cipher;\n        /**\n         * points to the first byte of the target QUIC packet. It will not point to packet->octets.base[0] when the datagram\n         * contains multiple QUIC packet.\n         */\n        uint8_t *first_byte_at;\n        /**\n         * if the target QUIC packet contains an ack-eliciting frame\n         */\n        uint8_t ack_eliciting : 1;\n        /**\n         * if the target datagram should be padded to full size\n         */\n        uint8_t full_size : 1;\n    } target;\n    /**\n     * output buffer into which list of datagrams is written\n     */\n    struct iovec *datagrams;\n    /**\n     * max number of datagrams that can be stored in |packets|\n     */\n    size_t max_datagrams;\n    /**\n     * number of datagrams currently stored in |packets|\n     */\n    size_t num_datagrams;\n    /**\n     * buffer in which packets are built\n     */\n    struct {\n        /**\n         * starting position of the current (or next) datagram\n         */\n        uint8_t *datagram;\n        /**\n         * end position of the payload buffer\n         */\n        uint8_t *end;\n    } payload_buf;\n    /**\n     * Currently available window for sending (in bytes); the value becomes negative when the sender uses more space than permitted.\n     * That happens because the sender operates at packet-level rather than byte-level.\n     */\n    ssize_t send_window;\n    /**\n     * location where next frame should be written\n     */\n    uint8_t *dst;\n    /**\n     * end of the payload area, beyond which frames cannot be written\n     */\n    uint8_t *dst_end;\n    /**\n     * address at which payload starts\n     */\n    uint8_t *dst_payload_from;\n    /**\n     * first packet number to be used within the lifetime of this send context\n     */\n    uint64_t first_packet_number;\n};\n\nstatic int commit_send_packet(quicly_conn_t *conn, quicly_send_context_t *s, int coalesced)\n{\n    size_t datagram_size, packet_bytes_in_flight;\n\n    assert(s->target.cipher->aead != NULL);\n\n    assert(s->dst != s->dst_payload_from);\n\n    /* pad so that the pn + payload would be at least 4 bytes */\n    while (s->dst - s->dst_payload_from < QUICLY_MAX_PN_SIZE - QUICLY_SEND_PN_SIZE)\n        *s->dst++ = QUICLY_FRAME_TYPE_PADDING;\n\n    if (!coalesced && s->target.full_size) {\n        assert(s->num_datagrams == 0 || s->datagrams[s->num_datagrams - 1].iov_len == conn->egress.max_udp_payload_size);\n        const size_t max_size = conn->egress.max_udp_payload_size - QUICLY_AEAD_TAG_SIZE;\n        assert(s->dst - s->payload_buf.datagram <= max_size);\n        memset(s->dst, QUICLY_FRAME_TYPE_PADDING, s->payload_buf.datagram + max_size - s->dst);\n        s->dst = s->payload_buf.datagram + max_size;\n    }\n\n    /* encode packet size, packet number, key-phase */\n    if (QUICLY_PACKET_IS_LONG_HEADER(*s->target.first_byte_at)) {\n        uint16_t length = s->dst - s->dst_payload_from + s->target.cipher->aead->algo->tag_size + QUICLY_SEND_PN_SIZE;\n        /* length is always 2 bytes, see _do_prepare_packet */\n        length |= 0x4000;\n        quicly_encode16(s->dst_payload_from - QUICLY_SEND_PN_SIZE - 2, length);\n        switch (*s->target.first_byte_at & QUICLY_PACKET_TYPE_BITMASK) {\n        case QUICLY_PACKET_TYPE_INITIAL:\n        case QUICLY_PACKET_TYPE_HANDSHAKE:\n            conn->super.stats.num_packets.initial_handshake_sent++;\n            break;\n        }\n    } else {\n        if (conn->egress.packet_number >= conn->application->cipher.egress.key_update_pn.next) {\n            int ret;\n            if ((ret = update_1rtt_egress_key(conn)) != 0)\n                return ret;\n        }\n        if ((conn->application->cipher.egress.key_phase & 1) != 0)\n            *s->target.first_byte_at |= QUICLY_KEY_PHASE_BIT;\n    }\n    quicly_encode16(s->dst_payload_from - QUICLY_SEND_PN_SIZE, (uint16_t)conn->egress.packet_number);\n\n    /* encrypt the packet */\n    s->dst += s->target.cipher->aead->algo->tag_size;\n    datagram_size = s->dst - s->payload_buf.datagram;\n    assert(datagram_size <= conn->egress.max_udp_payload_size);\n\n    conn->super.ctx->crypto_engine->encrypt_packet(\n        conn->super.ctx->crypto_engine, conn, s->target.cipher->header_protection, s->target.cipher->aead,\n        ptls_iovec_init(s->payload_buf.datagram, datagram_size), s->target.first_byte_at - s->payload_buf.datagram,\n        s->dst_payload_from - s->payload_buf.datagram, conn->egress.packet_number, coalesced);\n\n    /* update CC, commit sentmap */\n    if (s->target.ack_eliciting) {\n        packet_bytes_in_flight = s->dst - s->target.first_byte_at;\n        s->send_window -= packet_bytes_in_flight;\n    } else {\n        packet_bytes_in_flight = 0;\n    }\n    if (quicly_sentmap_is_open(&conn->egress.loss.sentmap))\n        quicly_sentmap_commit(&conn->egress.loss.sentmap, (uint16_t)packet_bytes_in_flight);\n\n    conn->egress.cc.type->cc_on_sent(&conn->egress.cc, &conn->egress.loss, (uint32_t)packet_bytes_in_flight, conn->stash.now);\n    QUICLY_PROBE(PACKET_SENT, conn, conn->stash.now, conn->egress.packet_number, s->dst - s->target.first_byte_at,\n                 get_epoch(*s->target.first_byte_at), !s->target.ack_eliciting);\n    QUICLY_LOG_CONN(packet_sent, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(pn, conn->egress.packet_number);\n        PTLS_LOG_ELEMENT_UNSIGNED(len, s->dst - s->target.first_byte_at);\n        PTLS_LOG_ELEMENT_UNSIGNED(packet_type, get_epoch(*s->target.first_byte_at));\n        PTLS_LOG_ELEMENT_BOOL(ack_only, !s->target.ack_eliciting);\n    });\n\n    ++conn->egress.packet_number;\n    ++conn->super.stats.num_packets.sent;\n\n    if (!coalesced) {\n        conn->super.stats.num_bytes.sent += datagram_size;\n        s->datagrams[s->num_datagrams++] = (struct iovec){.iov_base = s->payload_buf.datagram, .iov_len = datagram_size};\n        s->payload_buf.datagram += datagram_size;\n        s->target.cipher = NULL;\n        s->target.first_byte_at = NULL;\n    }\n\n    /* insert PN gap if necessary, registering the PN to the ack queue so that we'd close the connection in the event of receiving\n     * an ACK for that gap. */\n    if (conn->egress.packet_number >= conn->egress.next_pn_to_skip && !QUICLY_PACKET_IS_LONG_HEADER(s->current.first_byte) &&\n        conn->super.state < QUICLY_STATE_CLOSING) {\n        int ret;\n        if ((ret = quicly_sentmap_prepare(&conn->egress.loss.sentmap, conn->egress.packet_number, conn->stash.now,\n                                          QUICLY_EPOCH_1RTT)) != 0)\n            return ret;\n        if (quicly_sentmap_allocate(&conn->egress.loss.sentmap, on_invalid_ack) == NULL)\n            return PTLS_ERROR_NO_MEMORY;\n        quicly_sentmap_commit(&conn->egress.loss.sentmap, 0);\n        ++conn->egress.packet_number;\n        conn->egress.next_pn_to_skip = calc_next_pn_to_skip(conn->super.ctx->tls, conn->egress.packet_number, conn->egress.cc.cwnd,\n                                                            conn->egress.max_udp_payload_size);\n    }\n\n    return 0;\n}\n\nstatic inline uint8_t *emit_cid(uint8_t *dst, const quicly_cid_t *cid)\n{\n    if (cid->len != 0) {\n        memcpy(dst, cid->cid, cid->len);\n        dst += cid->len;\n    }\n    return dst;\n}\n\nenum allocate_frame_type {\n    ALLOCATE_FRAME_TYPE_NON_ACK_ELICITING,\n    ALLOCATE_FRAME_TYPE_ACK_ELICITING,\n    ALLOCATE_FRAME_TYPE_ACK_ELICITING_NO_CC,\n};\n\nstatic int do_allocate_frame(quicly_conn_t *conn, quicly_send_context_t *s, size_t min_space, enum allocate_frame_type frame_type)\n{\n    int coalescible, ret;\n\n    assert((s->current.first_byte & QUICLY_QUIC_BIT) != 0);\n\n    /* allocate and setup the new packet if necessary */\n    if (s->dst_end - s->dst < min_space || s->target.first_byte_at == NULL) {\n        coalescible = 0;\n    } else if (((*s->target.first_byte_at ^ s->current.first_byte) & QUICLY_PACKET_TYPE_BITMASK) != 0) {\n        coalescible = QUICLY_PACKET_IS_LONG_HEADER(*s->target.first_byte_at);\n    } else if (s->dst_end - s->dst < min_space) {\n        coalescible = 0;\n    } else {\n        /* use the existing packet */\n        goto TargetReady;\n    }\n\n    /* commit at the same time determining if we will coalesce the packets */\n    if (s->target.first_byte_at != NULL) {\n        if (coalescible) {\n            size_t overhead = 1 /* type */ + conn->super.remote.cid_set.cids[0].cid.len + QUICLY_SEND_PN_SIZE +\n                              s->current.cipher->aead->algo->tag_size;\n            if (QUICLY_PACKET_IS_LONG_HEADER(s->current.first_byte))\n                overhead += 4 /* version */ + 1 /* cidl */ + conn->super.remote.cid_set.cids[0].cid.len +\n                            conn->super.local.long_header_src_cid.len +\n                            (s->current.first_byte == QUICLY_PACKET_TYPE_INITIAL) /* token_length == 0 */ + 2 /* length */;\n            size_t packet_min_space = QUICLY_MAX_PN_SIZE - QUICLY_SEND_PN_SIZE;\n            if (packet_min_space < min_space)\n                packet_min_space = min_space;\n            if (overhead + packet_min_space > s->dst_end - s->dst)\n                coalescible = 0;\n        }\n        /* Close the packet under construction. Datagrams being returned by `quicly_send` are padded to full-size (except for the\n         * last one datagram) so that they can be sent at once using GSO. */\n        if (!coalescible)\n            s->target.full_size = 1;\n        if ((ret = commit_send_packet(conn, s, coalescible)) != 0)\n            return ret;\n    } else {\n        coalescible = 0;\n    }\n\n    /* allocate packet */\n    if (coalescible) {\n        s->dst_end += s->target.cipher->aead->algo->tag_size; /* restore the AEAD tag size (tag size can differ bet. epochs) */\n        s->target.cipher = s->current.cipher;\n    } else {\n        if (s->num_datagrams >= s->max_datagrams)\n            return QUICLY_ERROR_SENDBUF_FULL;\n        /* note: send_window (ssize_t) can become negative; see doc-comment */\n        if (frame_type == ALLOCATE_FRAME_TYPE_ACK_ELICITING && s->send_window <= 0)\n            return QUICLY_ERROR_SENDBUF_FULL;\n        if (s->payload_buf.end - s->payload_buf.datagram < conn->egress.max_udp_payload_size)\n            return QUICLY_ERROR_SENDBUF_FULL;\n        s->target.cipher = s->current.cipher;\n        s->target.full_size = 0;\n        s->dst = s->payload_buf.datagram;\n        s->dst_end = s->dst + conn->egress.max_udp_payload_size;\n    }\n    s->target.ack_eliciting = 0;\n\n    QUICLY_PROBE(PACKET_PREPARE, conn, conn->stash.now, s->current.first_byte,\n                 QUICLY_PROBE_HEXDUMP(conn->super.remote.cid_set.cids[0].cid.cid, conn->super.remote.cid_set.cids[0].cid.len));\n    QUICLY_LOG_CONN(packet_prepare, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(first_octet, s->current.first_byte);\n        PTLS_LOG_ELEMENT_HEXDUMP(dcid, conn->super.remote.cid_set.cids[0].cid.cid, conn->super.remote.cid_set.cids[0].cid.len);\n    });\n\n    /* emit header */\n    s->target.first_byte_at = s->dst;\n    *s->dst++ = s->current.first_byte | 0x1 /* pnlen == 2 */;\n    if (QUICLY_PACKET_IS_LONG_HEADER(s->current.first_byte)) {\n        s->dst = quicly_encode32(s->dst, conn->super.version);\n        *s->dst++ = conn->super.remote.cid_set.cids[0].cid.len;\n        s->dst = emit_cid(s->dst, &conn->super.remote.cid_set.cids[0].cid);\n        *s->dst++ = conn->super.local.long_header_src_cid.len;\n        s->dst = emit_cid(s->dst, &conn->super.local.long_header_src_cid);\n        /* token */\n        if (s->current.first_byte == QUICLY_PACKET_TYPE_INITIAL) {\n            s->dst = quicly_encodev(s->dst, conn->token.len);\n            if (conn->token.len != 0) {\n                assert(s->dst_end - s->dst > conn->token.len);\n                memcpy(s->dst, conn->token.base, conn->token.len);\n                s->dst += conn->token.len;\n            }\n        }\n        /* payload length is filled laterwards (see commit_send_packet) */\n        *s->dst++ = 0;\n        *s->dst++ = 0;\n    } else {\n        s->dst = emit_cid(s->dst, &conn->super.remote.cid_set.cids[0].cid);\n    }\n    s->dst += QUICLY_SEND_PN_SIZE; /* space for PN bits, filled in at commit time */\n    s->dst_payload_from = s->dst;\n    assert(s->target.cipher->aead != NULL);\n    s->dst_end -= s->target.cipher->aead->algo->tag_size;\n    assert(s->dst_end - s->dst >= QUICLY_MAX_PN_SIZE - QUICLY_SEND_PN_SIZE);\n\n    if (conn->super.state < QUICLY_STATE_CLOSING) {\n        /* register to sentmap */\n        uint8_t ack_epoch = get_epoch(s->current.first_byte);\n        if (ack_epoch == QUICLY_EPOCH_0RTT)\n            ack_epoch = QUICLY_EPOCH_1RTT;\n        if ((ret = quicly_sentmap_prepare(&conn->egress.loss.sentmap, conn->egress.packet_number, conn->stash.now, ack_epoch)) != 0)\n            return ret;\n        /* adjust ack-frequency */\n        if (conn->stash.now >= conn->egress.ack_frequency.update_at) {\n            assert(conn->super.remote.transport_params.min_ack_delay_usec != UINT64_MAX);\n            if (conn->egress.cc.num_loss_episodes >= QUICLY_FIRST_ACK_FREQUENCY_LOSS_EPISODE && conn->initial == NULL &&\n                conn->handshake == NULL) {\n                uint32_t fraction_of_cwnd = (uint32_t)((uint64_t)conn->egress.cc.cwnd * conn->super.ctx->ack_frequency / 1024);\n                if (fraction_of_cwnd >= conn->egress.max_udp_payload_size * 3) {\n                    uint32_t packet_tolerance = fraction_of_cwnd / conn->egress.max_udp_payload_size;\n                    if (packet_tolerance > QUICLY_MAX_PACKET_TOLERANCE)\n                        packet_tolerance = QUICLY_MAX_PACKET_TOLERANCE;\n                    s->dst = quicly_encode_ack_frequency_frame(s->dst, conn->egress.ack_frequency.sequence++, packet_tolerance,\n                                                               conn->super.remote.transport_params.max_ack_delay * 1000, 0);\n                    ++conn->super.stats.num_frames_sent.ack_frequency;\n                }\n            }\n            ack_frequency_set_next_update_at(conn);\n        }\n    }\n\nTargetReady:\n    if (frame_type != ALLOCATE_FRAME_TYPE_NON_ACK_ELICITING) {\n        s->target.ack_eliciting = 1;\n        conn->egress.last_retransmittable_sent_at = conn->stash.now;\n    }\n    return 0;\n}\n\nstatic int allocate_ack_eliciting_frame(quicly_conn_t *conn, quicly_send_context_t *s, size_t min_space, quicly_sent_t **sent,\n                                        quicly_sent_acked_cb acked)\n{\n    int ret;\n\n    if ((ret = do_allocate_frame(conn, s, min_space, ALLOCATE_FRAME_TYPE_ACK_ELICITING)) != 0)\n        return ret;\n    if ((*sent = quicly_sentmap_allocate(&conn->egress.loss.sentmap, acked)) == NULL)\n        return PTLS_ERROR_NO_MEMORY;\n\n    return ret;\n}\n\nstatic int send_ack(quicly_conn_t *conn, struct st_quicly_pn_space_t *space, quicly_send_context_t *s)\n{\n    uint64_t ack_delay;\n    int ret;\n\n    if (space->ack_queue.num_ranges == 0)\n        return 0;\n\n    /* calc ack_delay */\n    if (space->largest_pn_received_at < conn->stash.now) {\n        /* We underreport ack_delay up to 1 milliseconds assuming that QUICLY_LOCAL_ACK_DELAY_EXPONENT is 10. It's considered a\n         * non-issue because our time measurement is at millisecond granularity anyways. */\n        ack_delay = ((conn->stash.now - space->largest_pn_received_at) * 1000) >> QUICLY_LOCAL_ACK_DELAY_EXPONENT;\n    } else {\n        ack_delay = 0;\n    }\n\nEmit: /* emit an ACK frame */\n    if ((ret = do_allocate_frame(conn, s, QUICLY_ACK_FRAME_CAPACITY, ALLOCATE_FRAME_TYPE_NON_ACK_ELICITING)) != 0)\n        return ret;\n    uint8_t *dst = s->dst;\n    dst = quicly_encode_ack_frame(dst, s->dst_end, &space->ack_queue, space->ecn_counts, ack_delay);\n\n    /* when there's no space, retry with a new MTU-sized packet */\n    if (dst == NULL) {\n        /* [rare case] A coalesced packet might not have enough space to hold only an ACK. If so, pad it, as that's easier than\n         * rolling back. */\n        if (s->dst == s->dst_payload_from) {\n            assert(s->target.first_byte_at != s->payload_buf.datagram);\n            *s->dst++ = QUICLY_FRAME_TYPE_PADDING;\n        }\n        s->target.full_size = 1;\n        if ((ret = commit_send_packet(conn, s, 0)) != 0)\n            return ret;\n        goto Emit;\n    }\n\n    ++conn->super.stats.num_frames_sent.ack;\n    QUICLY_PROBE(ACK_SEND, conn, conn->stash.now, space->ack_queue.ranges[space->ack_queue.num_ranges - 1].end - 1, ack_delay);\n    QUICLY_LOG_CONN(ack_send, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(largest_acked, space->ack_queue.ranges[space->ack_queue.num_ranges - 1].end - 1);\n        PTLS_LOG_ELEMENT_UNSIGNED(ack_delay, ack_delay);\n    });\n\n    /* when there are no less than QUICLY_NUM_ACK_BLOCKS_TO_INDUCE_ACKACK (8) gaps, bundle PING once every 4 packets being sent */\n    if (space->ack_queue.num_ranges >= QUICLY_NUM_ACK_BLOCKS_TO_INDUCE_ACKACK && conn->egress.packet_number % 4 == 0 &&\n        dst < s->dst_end) {\n        *dst++ = QUICLY_FRAME_TYPE_PING;\n        ++conn->super.stats.num_frames_sent.ping;\n        QUICLY_PROBE(PING_SEND, conn, conn->stash.now);\n        QUICLY_LOG_CONN(ping_send, conn, {});\n    }\n\n    s->dst = dst;\n\n    { /* save what's inflight */\n        size_t range_index = 0;\n        while (range_index < space->ack_queue.num_ranges) {\n            quicly_sent_t *sent;\n            struct st_quicly_sent_ack_additional_t *additional, *additional_end;\n            /* allocate */\n            if ((sent = quicly_sentmap_allocate(&conn->egress.loss.sentmap, on_ack_ack_ranges8)) == NULL)\n                return PTLS_ERROR_NO_MEMORY;\n            /* store the first range, as well as preparing references to the additional slots */\n            sent->data.ack.start = space->ack_queue.ranges[range_index].start;\n            uint64_t length = space->ack_queue.ranges[range_index].end - space->ack_queue.ranges[range_index].start;\n            if (length <= UINT8_MAX) {\n                sent->data.ack.ranges8.start_length = length;\n                additional = sent->data.ack.ranges8.additional;\n                additional_end = additional + PTLS_ELEMENTSOF(sent->data.ack.ranges8.additional);\n            } else {\n                sent->acked = on_ack_ack_ranges64;\n                sent->data.ack.ranges64.start_length = length;\n                additional = sent->data.ack.ranges64.additional;\n                additional_end = additional + PTLS_ELEMENTSOF(sent->data.ack.ranges64.additional);\n            }\n            /* store additional ranges, if possible */\n            for (++range_index; range_index < space->ack_queue.num_ranges && additional < additional_end;\n                 ++range_index, ++additional) {\n                uint64_t gap = space->ack_queue.ranges[range_index].start - space->ack_queue.ranges[range_index - 1].end;\n                uint64_t length = space->ack_queue.ranges[range_index].end - space->ack_queue.ranges[range_index].start;\n                if (gap > UINT8_MAX || length > UINT8_MAX)\n                    break;\n                additional->gap = gap;\n                additional->length = length;\n            }\n            /* additional list is zero-terminated, if not full */\n            if (additional < additional_end)\n                additional->gap = 0;\n        }\n    }\n\n    space->unacked_count = 0;\n\n    return ret;\n}\n\nstatic int prepare_stream_state_sender(quicly_stream_t *stream, quicly_sender_state_t *sender, quicly_send_context_t *s,\n                                       size_t min_space, quicly_sent_acked_cb ack_cb)\n{\n    quicly_sent_t *sent;\n    int ret;\n\n    if ((ret = allocate_ack_eliciting_frame(stream->conn, s, min_space, &sent, ack_cb)) != 0)\n        return ret;\n    sent->data.stream_state_sender.stream_id = stream->stream_id;\n    *sender = QUICLY_SENDER_STATE_UNACKED;\n\n    return 0;\n}\n\nstatic int send_control_frames_of_stream(quicly_stream_t *stream, quicly_send_context_t *s)\n{\n    int ret;\n\n    /* send STOP_SENDING if necessary */\n    if (stream->_send_aux.stop_sending.sender_state == QUICLY_SENDER_STATE_SEND) {\n        /* FIXME also send an empty STREAM frame */\n        if ((ret = prepare_stream_state_sender(stream, &stream->_send_aux.stop_sending.sender_state, s,\n                                               QUICLY_STOP_SENDING_FRAME_CAPACITY, on_ack_stop_sending)) != 0)\n            return ret;\n        s->dst = quicly_encode_stop_sending_frame(s->dst, stream->stream_id, stream->_send_aux.stop_sending.error_code);\n        ++stream->conn->super.stats.num_frames_sent.stop_sending;\n        QUICLY_PROBE(STOP_SENDING_SEND, stream->conn, stream->conn->stash.now, stream->stream_id,\n                     stream->_send_aux.stop_sending.error_code);\n        QUICLY_LOG_CONN(stop_sending_send, stream->conn, {\n            PTLS_LOG_ELEMENT_SIGNED(stream_id, stream->stream_id);\n            PTLS_LOG_ELEMENT_UNSIGNED(error_code, stream->_send_aux.stop_sending.error_code);\n        });\n    }\n\n    /* send MAX_STREAM_DATA if necessary */\n    if (should_send_max_stream_data(stream)) {\n        uint64_t new_value = stream->recvstate.data_off + stream->_recv_aux.window;\n        quicly_sent_t *sent;\n        /* prepare */\n        if ((ret = allocate_ack_eliciting_frame(stream->conn, s, QUICLY_MAX_STREAM_DATA_FRAME_CAPACITY, &sent,\n                                                on_ack_max_stream_data)) != 0)\n            return ret;\n        /* send */\n        s->dst = quicly_encode_max_stream_data_frame(s->dst, stream->stream_id, new_value);\n        /* register ack */\n        sent->data.max_stream_data.stream_id = stream->stream_id;\n        quicly_maxsender_record(&stream->_send_aux.max_stream_data_sender, new_value, &sent->data.max_stream_data.args);\n        /* update stats */\n        ++stream->conn->super.stats.num_frames_sent.max_stream_data;\n        QUICLY_PROBE(MAX_STREAM_DATA_SEND, stream->conn, stream->conn->stash.now, stream, new_value);\n        QUICLY_LOG_CONN(max_stream_data_send, stream->conn, {\n            PTLS_LOG_ELEMENT_SIGNED(stream_id, stream->stream_id);\n            PTLS_LOG_ELEMENT_UNSIGNED(maximum, new_value);\n        });\n    }\n\n    /* send RESET_STREAM if necessary */\n    if (stream->_send_aux.reset_stream.sender_state == QUICLY_SENDER_STATE_SEND) {\n        if ((ret = prepare_stream_state_sender(stream, &stream->_send_aux.reset_stream.sender_state, s, QUICLY_RST_FRAME_CAPACITY,\n                                               on_ack_reset_stream)) != 0)\n            return ret;\n        s->dst = quicly_encode_reset_stream_frame(s->dst, stream->stream_id, stream->_send_aux.reset_stream.error_code,\n                                                  stream->sendstate.size_inflight);\n        ++stream->conn->super.stats.num_frames_sent.reset_stream;\n        QUICLY_PROBE(RESET_STREAM_SEND, stream->conn, stream->conn->stash.now, stream->stream_id,\n                     stream->_send_aux.reset_stream.error_code, stream->sendstate.size_inflight);\n        QUICLY_LOG_CONN(reset_stream_send, stream->conn, {\n            PTLS_LOG_ELEMENT_SIGNED(stream_id, stream->stream_id);\n            PTLS_LOG_ELEMENT_UNSIGNED(error_code, stream->_send_aux.reset_stream.error_code);\n            PTLS_LOG_ELEMENT_UNSIGNED(final_size, stream->sendstate.size_inflight);\n        });\n    }\n\n    /* send STREAM_DATA_BLOCKED if necessary */\n    if (stream->_send_aux.blocked == QUICLY_SENDER_STATE_SEND) {\n        quicly_sent_t *sent;\n        if ((ret = allocate_ack_eliciting_frame(stream->conn, s, QUICLY_STREAM_DATA_BLOCKED_FRAME_CAPACITY, &sent,\n                                                on_ack_stream_data_blocked_frame)) != 0)\n            return ret;\n        uint64_t offset = stream->_send_aux.max_stream_data;\n        sent->data.stream_data_blocked.stream_id = stream->stream_id;\n        sent->data.stream_data_blocked.offset = offset;\n        s->dst = quicly_encode_stream_data_blocked_frame(s->dst, stream->stream_id, offset);\n        stream->_send_aux.blocked = QUICLY_SENDER_STATE_UNACKED;\n        ++stream->conn->super.stats.num_frames_sent.stream_data_blocked;\n        QUICLY_PROBE(STREAM_DATA_BLOCKED_SEND, stream->conn, stream->conn->stash.now, stream->stream_id, offset);\n        QUICLY_LOG_CONN(stream_data_blocked_send, stream->conn, {\n            PTLS_LOG_ELEMENT_SIGNED(stream_id, stream->stream_id);\n            PTLS_LOG_ELEMENT_UNSIGNED(maximum, offset);\n        });\n    }\n\n    return 0;\n}\n\nstatic int send_stream_control_frames(quicly_conn_t *conn, quicly_send_context_t *s)\n{\n    int ret = 0;\n\n    while (s->num_datagrams != s->max_datagrams && quicly_linklist_is_linked(&conn->egress.pending_streams.control)) {\n        quicly_stream_t *stream =\n            (void *)((char *)conn->egress.pending_streams.control.next - offsetof(quicly_stream_t, _send_aux.pending_link.control));\n        if ((ret = send_control_frames_of_stream(stream, s)) != 0)\n            goto Exit;\n        quicly_linklist_unlink(&stream->_send_aux.pending_link.control);\n    }\n\nExit:\n    return ret;\n}\n\nint quicly_is_blocked(quicly_conn_t *conn)\n{\n    if (conn->egress.max_data.sent < conn->egress.max_data.permitted)\n        return 0;\n\n    /* schedule the transmission of DATA_BLOCKED frame, if it's new information */\n    if (conn->egress.data_blocked == QUICLY_SENDER_STATE_NONE) {\n        conn->egress.data_blocked = QUICLY_SENDER_STATE_SEND;\n        conn->egress.pending_flows = QUICLY_PENDING_FLOW_OTHERS_BIT;\n    }\n\n    return 1;\n}\n\nint quicly_stream_can_send(quicly_stream_t *stream, int at_stream_level)\n{\n    /* return if there is nothing to be sent */\n    if (stream->sendstate.pending.num_ranges == 0)\n        return 0;\n\n    /* return if flow is capped neither by MAX_STREAM_DATA nor (in case we are hitting connection-level flow control) by the number\n     * of bytes we've already sent */\n    uint64_t blocked_at = at_stream_level ? stream->_send_aux.max_stream_data : stream->sendstate.size_inflight;\n    if (stream->sendstate.pending.ranges[0].start < blocked_at)\n        return 1;\n    /* we can always send EOS, if that is the only thing to be sent */\n    if (stream->sendstate.pending.ranges[0].start >= stream->sendstate.final_size) {\n        assert(stream->sendstate.pending.ranges[0].start == stream->sendstate.final_size);\n        return 1;\n    }\n\n    /* if known to be blocked at stream-level, schedule the emission of STREAM_DATA_BLOCKED frame */\n    if (at_stream_level && stream->_send_aux.blocked == QUICLY_SENDER_STATE_NONE) {\n        stream->_send_aux.blocked = QUICLY_SENDER_STATE_SEND;\n        sched_stream_control(stream);\n    }\n\n    return 0;\n}\n\nint quicly_can_send_data(quicly_conn_t *conn, quicly_send_context_t *s)\n{\n    return s->num_datagrams < s->max_datagrams;\n}\n\n/**\n * If necessary, changes the frame representation from one without length field to one that has if necessary. Or, as an alternative,\n * prepends PADDING frames. Upon return, `dst` points to the end of the frame being built. `*len`, `*wrote_all`, `*frame_type_at`\n * are also updated reflecting their values post-adjustment.\n */\nstatic inline void adjust_stream_frame_layout(uint8_t **dst, uint8_t *const dst_end, size_t *len, int *wrote_all,\n                                              uint8_t **frame_at)\n{\n    size_t space_left = (dst_end - *dst) - *len, len_of_len = quicly_encodev_capacity(*len);\n\n    if (**frame_at == QUICLY_FRAME_TYPE_CRYPTO) {\n        /* CRYPTO frame: adjust payload length to make space for the length field, if necessary. */\n        if (space_left < len_of_len) {\n            *len = dst_end - *dst - len_of_len;\n            *wrote_all = 0;\n        }\n    } else {\n        /* STREAM frame: insert length if space can be left for more frames. Otherwise, retain STREAM frame header omitting the\n         * length field, prepending PADDING if necessary. */\n        if (space_left <= len_of_len) {\n            if (space_left != 0) {\n                memmove(*frame_at + space_left, *frame_at, *dst + *len - *frame_at);\n                memset(*frame_at, QUICLY_FRAME_TYPE_PADDING, space_left);\n                *dst += space_left;\n                *frame_at += space_left;\n            }\n            *dst += *len;\n            return;\n        }\n        **frame_at |= QUICLY_FRAME_TYPE_STREAM_BIT_LEN;\n    }\n\n    /* insert length before payload of `*len` bytes */\n    memmove(*dst + len_of_len, *dst, *len);\n    *dst = quicly_encodev(*dst, *len);\n    *dst += *len;\n}\n\nint quicly_send_stream(quicly_stream_t *stream, quicly_send_context_t *s)\n{\n    uint64_t off = stream->sendstate.pending.ranges[0].start;\n    quicly_sent_t *sent;\n    uint8_t *dst; /* this pointer points to the current write position within the frame being built, while `s->dst` points to the\n                   * beginning of the frame. */\n    size_t len;\n    int ret, wrote_all, is_fin;\n\n    /* write frame type, stream_id and offset, calculate capacity (and store that in `len`) */\n    if (stream->stream_id < 0) {\n        if ((ret = allocate_ack_eliciting_frame(stream->conn, s,\n                                                1 + quicly_encodev_capacity(off) + 2 /* type + offset + len + 1-byte payload */,\n                                                &sent, on_ack_stream)) != 0)\n            return ret;\n        dst = s->dst;\n        *dst++ = QUICLY_FRAME_TYPE_CRYPTO;\n        dst = quicly_encodev(dst, off);\n        len = s->dst_end - dst;\n    } else {\n        uint8_t header[18], *hp = header + 1;\n        hp = quicly_encodev(hp, stream->stream_id);\n        if (off != 0) {\n            header[0] = QUICLY_FRAME_TYPE_STREAM_BASE | QUICLY_FRAME_TYPE_STREAM_BIT_OFF;\n            hp = quicly_encodev(hp, off);\n        } else {\n            header[0] = QUICLY_FRAME_TYPE_STREAM_BASE;\n        }\n        if (off == stream->sendstate.final_size) {\n            assert(!quicly_sendstate_is_open(&stream->sendstate));\n            /* special case for emitting FIN only */\n            header[0] |= QUICLY_FRAME_TYPE_STREAM_BIT_FIN;\n            if ((ret = allocate_ack_eliciting_frame(stream->conn, s, hp - header, &sent, on_ack_stream)) != 0)\n                return ret;\n            if (hp - header != s->dst_end - s->dst) {\n                header[0] |= QUICLY_FRAME_TYPE_STREAM_BIT_LEN;\n                *hp++ = 0; /* empty length */\n            }\n            memcpy(s->dst, header, hp - header);\n            s->dst += hp - header;\n            len = 0;\n            wrote_all = 1;\n            is_fin = 1;\n            goto UpdateState;\n        }\n        if ((ret = allocate_ack_eliciting_frame(stream->conn, s, hp - header + 1, &sent, on_ack_stream)) != 0)\n            return ret;\n        dst = s->dst;\n        memcpy(dst, header, hp - header);\n        dst += hp - header;\n        len = s->dst_end - dst;\n        /* cap by max_stream_data */\n        if (off + len > stream->_send_aux.max_stream_data)\n            len = stream->_send_aux.max_stream_data - off;\n        /* cap by max_data */\n        if (off + len > stream->sendstate.size_inflight) {\n            uint64_t new_bytes = off + len - stream->sendstate.size_inflight;\n            if (new_bytes > stream->conn->egress.max_data.permitted - stream->conn->egress.max_data.sent) {\n                size_t max_stream_data =\n                    stream->sendstate.size_inflight + stream->conn->egress.max_data.permitted - stream->conn->egress.max_data.sent;\n                len = max_stream_data - off;\n            }\n        }\n    }\n    { /* cap len to the current range */\n        uint64_t range_capacity = stream->sendstate.pending.ranges[0].end - off;\n        if (off + range_capacity > stream->sendstate.final_size) {\n            assert(!quicly_sendstate_is_open(&stream->sendstate));\n            assert(range_capacity > 1); /* see the special case above */\n            range_capacity -= 1;\n        }\n        if (len > range_capacity)\n            len = range_capacity;\n    }\n\n    /* Write payload, adjusting len to actual size. Note that `on_send_emit` might fail (e.g., when underlying pread(2) fails), in\n     * which case the application will either close the connection immediately or reset the stream. If that happens, we return\n     * immediately without updating state. */\n    assert(len != 0);\n    size_t emit_off = (size_t)(off - stream->sendstate.acked.ranges[0].end);\n    QUICLY_PROBE(STREAM_ON_SEND_EMIT, stream->conn, stream->conn->stash.now, stream, emit_off, len);\n    QUICLY_LOG_CONN(stream_on_send_emit, stream->conn, {\n        PTLS_LOG_ELEMENT_SIGNED(stream_id, stream->stream_id);\n        PTLS_LOG_ELEMENT_UNSIGNED(off, off);\n        PTLS_LOG_ELEMENT_UNSIGNED(capacity, len);\n    });\n    stream->callbacks->on_send_emit(stream, emit_off, dst, &len, &wrote_all);\n    if (stream->conn->super.state >= QUICLY_STATE_CLOSING) {\n        return QUICLY_ERROR_IS_CLOSING;\n    } else if (stream->_send_aux.reset_stream.sender_state != QUICLY_SENDER_STATE_NONE) {\n        return 0;\n    }\n    assert(len != 0);\n\n    adjust_stream_frame_layout(&dst, s->dst_end, &len, &wrote_all, &s->dst);\n\n    /* determine if the frame incorporates FIN */\n    if (off + len == stream->sendstate.final_size) {\n        assert(!quicly_sendstate_is_open(&stream->sendstate));\n        assert(s->dst != NULL);\n        is_fin = 1;\n        *s->dst |= QUICLY_FRAME_TYPE_STREAM_BIT_FIN;\n    } else {\n        is_fin = 0;\n    }\n\n    /* update s->dst now that frame construction is complete */\n    s->dst = dst;\n\nUpdateState:\n    if (stream->stream_id < 0) {\n        ++stream->conn->super.stats.num_frames_sent.crypto;\n    } else {\n        ++stream->conn->super.stats.num_frames_sent.stream;\n    }\n    stream->conn->super.stats.num_bytes.stream_data_sent += len;\n    if (off < stream->sendstate.size_inflight)\n        stream->conn->super.stats.num_bytes.stream_data_resent +=\n            (stream->sendstate.size_inflight < off + len ? stream->sendstate.size_inflight : off + len) - off;\n    QUICLY_PROBE(STREAM_SEND, stream->conn, stream->conn->stash.now, stream, off, len, is_fin);\n    QUICLY_LOG_CONN(stream_send, stream->conn, {\n        PTLS_LOG_ELEMENT_SIGNED(stream_id, stream->stream_id);\n        PTLS_LOG_ELEMENT_UNSIGNED(off, off);\n        PTLS_LOG_ELEMENT_UNSIGNED(len, len);\n        PTLS_LOG_ELEMENT_BOOL(is_fin, is_fin);\n    });\n\n    QUICLY_PROBE(QUICTRACE_SEND_STREAM, stream->conn, stream->conn->stash.now, stream, off, len, is_fin);\n    /* update sendstate (and also MAX_DATA counter) */\n    if (stream->sendstate.size_inflight < off + len) {\n        if (stream->stream_id >= 0)\n            stream->conn->egress.max_data.sent += off + len - stream->sendstate.size_inflight;\n        stream->sendstate.size_inflight = off + len;\n    }\n    if ((ret = quicly_ranges_subtract(&stream->sendstate.pending, off, off + len + is_fin)) != 0)\n        return ret;\n    if (wrote_all) {\n        if ((ret = quicly_ranges_subtract(&stream->sendstate.pending, stream->sendstate.size_inflight, UINT64_MAX)) != 0)\n            return ret;\n    }\n\n    /* setup sentmap */\n    sent->data.stream.stream_id = stream->stream_id;\n    sent->data.stream.args.start = off;\n    sent->data.stream.args.end = off + len + is_fin;\n\n    return 0;\n}\n\nstatic inline int init_acks_iter(quicly_conn_t *conn, quicly_sentmap_iter_t *iter)\n{\n    return quicly_loss_init_sentmap_iter(&conn->egress.loss, iter, conn->stash.now,\n                                         conn->super.remote.transport_params.max_ack_delay,\n                                         conn->super.state >= QUICLY_STATE_CLOSING);\n}\n\nint discard_sentmap_by_epoch(quicly_conn_t *conn, unsigned ack_epochs)\n{\n    quicly_sentmap_iter_t iter;\n    const quicly_sent_packet_t *sent;\n    int ret;\n\n    if ((ret = init_acks_iter(conn, &iter)) != 0)\n        return ret;\n\n    while ((sent = quicly_sentmap_get(&iter))->packet_number != UINT64_MAX) {\n        if ((ack_epochs & (1u << sent->ack_epoch)) != 0) {\n            if ((ret = quicly_sentmap_update(&conn->egress.loss.sentmap, &iter, QUICLY_SENTMAP_EVENT_EXPIRED)) != 0)\n                return ret;\n        } else {\n            quicly_sentmap_skip(&iter);\n        }\n    }\n\n    return ret;\n}\n\n/**\n * Mark frames of given epoch as pending, until `*bytes_to_mark` becomes zero.\n */\nstatic int mark_frames_on_pto(quicly_conn_t *conn, uint8_t ack_epoch, size_t *bytes_to_mark)\n{\n    quicly_sentmap_iter_t iter;\n    const quicly_sent_packet_t *sent;\n    int ret;\n\n    if ((ret = init_acks_iter(conn, &iter)) != 0)\n        return ret;\n\n    while ((sent = quicly_sentmap_get(&iter))->packet_number != UINT64_MAX) {\n        if (sent->ack_epoch == ack_epoch && sent->frames_in_flight) {\n            *bytes_to_mark = *bytes_to_mark > sent->cc_bytes_in_flight ? *bytes_to_mark - sent->cc_bytes_in_flight : 0;\n            if ((ret = quicly_sentmap_update(&conn->egress.loss.sentmap, &iter, QUICLY_SENTMAP_EVENT_PTO)) != 0)\n                return ret;\n            assert(!sent->frames_in_flight);\n            if (*bytes_to_mark == 0)\n                break;\n        } else {\n            quicly_sentmap_skip(&iter);\n        }\n    }\n\n    return 0;\n}\n\nstatic void notify_congestion_to_cc(quicly_conn_t *conn, uint16_t lost_bytes, uint64_t lost_pn)\n{\n    conn->egress.cc.type->cc_on_lost(&conn->egress.cc, &conn->egress.loss, lost_bytes, lost_pn, conn->egress.packet_number,\n                                     conn->stash.now, conn->egress.max_udp_payload_size);\n    QUICLY_PROBE(CC_CONGESTION, conn, conn->stash.now, lost_pn + 1, conn->egress.loss.sentmap.bytes_in_flight,\n                 conn->egress.cc.cwnd);\n    QUICLY_LOG_CONN(cc_congestion, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(max_lost_pn, lost_pn + 1);\n        PTLS_LOG_ELEMENT_UNSIGNED(flight, conn->egress.loss.sentmap.bytes_in_flight);\n        PTLS_LOG_ELEMENT_UNSIGNED(cwnd, conn->egress.cc.cwnd);\n    });\n}\n\nstatic void on_loss_detected(quicly_loss_t *loss, const quicly_sent_packet_t *lost_packet, int is_time_threshold)\n{\n    quicly_conn_t *conn = (void *)((char *)loss - offsetof(quicly_conn_t, egress.loss));\n\n    assert(lost_packet->cc_bytes_in_flight != 0);\n\n    ++conn->super.stats.num_packets.lost;\n    if (is_time_threshold)\n        ++conn->super.stats.num_packets.lost_time_threshold;\n    conn->super.stats.num_bytes.lost += lost_packet->cc_bytes_in_flight;\n    QUICLY_PROBE(PACKET_LOST, conn, conn->stash.now, lost_packet->packet_number, lost_packet->ack_epoch);\n    QUICLY_LOG_CONN(packet_lost, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(pn, lost_packet->packet_number);\n        PTLS_LOG_ELEMENT_UNSIGNED(packet_type, lost_packet->ack_epoch);\n    });\n    notify_congestion_to_cc(conn, lost_packet->cc_bytes_in_flight, lost_packet->packet_number);\n    QUICLY_PROBE(QUICTRACE_CC_LOST, conn, conn->stash.now, &conn->egress.loss.rtt, conn->egress.cc.cwnd,\n                 conn->egress.loss.sentmap.bytes_in_flight);\n}\n\nstatic int send_max_streams(quicly_conn_t *conn, int uni, quicly_send_context_t *s)\n{\n    if (!should_send_max_streams(conn, uni))\n        return 0;\n\n    quicly_maxsender_t *maxsender = uni ? &conn->ingress.max_streams.uni : &conn->ingress.max_streams.bidi;\n    struct st_quicly_conn_streamgroup_state_t *group = uni ? &conn->super.remote.uni : &conn->super.remote.bidi;\n    int ret;\n\n    uint64_t new_count =\n        group->next_stream_id / 4 +\n        (uni ? conn->super.ctx->transport_params.max_streams_uni : conn->super.ctx->transport_params.max_streams_bidi) -\n        group->num_streams;\n\n    quicly_sent_t *sent;\n    if ((ret = allocate_ack_eliciting_frame(conn, s, QUICLY_MAX_STREAMS_FRAME_CAPACITY, &sent, on_ack_max_streams)) != 0)\n        return ret;\n    s->dst = quicly_encode_max_streams_frame(s->dst, uni, new_count);\n    sent->data.max_streams.uni = uni;\n    quicly_maxsender_record(maxsender, new_count, &sent->data.max_streams.args);\n\n    if (uni) {\n        ++conn->super.stats.num_frames_sent.max_streams_uni;\n    } else {\n        ++conn->super.stats.num_frames_sent.max_streams_bidi;\n    }\n    QUICLY_PROBE(MAX_STREAMS_SEND, conn, conn->stash.now, new_count, uni);\n    QUICLY_LOG_CONN(max_streams_send, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(maximum, new_count);\n        PTLS_LOG_ELEMENT_BOOL(is_unidirectional, uni);\n    });\n\n    return 0;\n}\n\nstatic int send_streams_blocked(quicly_conn_t *conn, int uni, quicly_send_context_t *s)\n{\n    quicly_linklist_t *blocked_list = uni ? &conn->egress.pending_streams.blocked.uni : &conn->egress.pending_streams.blocked.bidi;\n    int ret;\n\n    if (!quicly_linklist_is_linked(blocked_list))\n        return 0;\n\n    struct st_quicly_max_streams_t *max_streams = uni ? &conn->egress.max_streams.uni : &conn->egress.max_streams.bidi;\n    quicly_stream_t *oldest_blocked_stream =\n        (void *)((char *)blocked_list->next - offsetof(quicly_stream_t, _send_aux.pending_link.control));\n    assert(max_streams->count == oldest_blocked_stream->stream_id / 4);\n\n    if (!quicly_maxsender_should_send_blocked(&max_streams->blocked_sender, max_streams->count))\n        return 0;\n\n    quicly_sent_t *sent;\n    if ((ret = allocate_ack_eliciting_frame(conn, s, QUICLY_STREAMS_BLOCKED_FRAME_CAPACITY, &sent, on_ack_streams_blocked)) != 0)\n        return ret;\n    s->dst = quicly_encode_streams_blocked_frame(s->dst, uni, max_streams->count);\n    sent->data.streams_blocked.uni = uni;\n    quicly_maxsender_record(&max_streams->blocked_sender, max_streams->count, &sent->data.streams_blocked.args);\n\n    ++conn->super.stats.num_frames_sent.streams_blocked;\n    QUICLY_PROBE(STREAMS_BLOCKED_SEND, conn, conn->stash.now, max_streams->count, uni);\n    QUICLY_LOG_CONN(streams_blocked_send, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(maximum, max_streams->count);\n        PTLS_LOG_ELEMENT_BOOL(is_unidirectional, uni);\n    });\n\n    return 0;\n}\n\nstatic void open_blocked_streams(quicly_conn_t *conn, int uni)\n{\n    uint64_t count;\n    quicly_linklist_t *anchor;\n\n    if (uni) {\n        count = conn->egress.max_streams.uni.count;\n        anchor = &conn->egress.pending_streams.blocked.uni;\n    } else {\n        count = conn->egress.max_streams.bidi.count;\n        anchor = &conn->egress.pending_streams.blocked.bidi;\n    }\n\n    while (quicly_linklist_is_linked(anchor)) {\n        quicly_stream_t *stream = (void *)((char *)anchor->next - offsetof(quicly_stream_t, _send_aux.pending_link.control));\n        if (stream->stream_id / 4 >= count)\n            break;\n        assert(stream->streams_blocked);\n        quicly_linklist_unlink(&stream->_send_aux.pending_link.control);\n        stream->streams_blocked = 0;\n        stream->_send_aux.max_stream_data = quicly_stream_is_unidirectional(stream->stream_id)\n                                                ? conn->super.remote.transport_params.max_stream_data.uni\n                                                : conn->super.remote.transport_params.max_stream_data.bidi_remote;\n        /* TODO retain separate flags for stream states so that we do not always need to sched for both control and data */\n        sched_stream_control(stream);\n        resched_stream_data(stream);\n    }\n}\n\nstatic int send_handshake_done(quicly_conn_t *conn, quicly_send_context_t *s)\n{\n    quicly_sent_t *sent;\n    int ret;\n\n    if ((ret = allocate_ack_eliciting_frame(conn, s, 1, &sent, on_ack_handshake_done)) != 0)\n        goto Exit;\n    *s->dst++ = QUICLY_FRAME_TYPE_HANDSHAKE_DONE;\n    conn->egress.pending_flows &= ~QUICLY_PENDING_FLOW_HANDSHAKE_DONE_BIT;\n    ++conn->super.stats.num_frames_sent.handshake_done;\n    QUICLY_PROBE(HANDSHAKE_DONE_SEND, conn, conn->stash.now);\n    QUICLY_LOG_CONN(handshake_done_send, conn, {});\n\n    ret = 0;\nExit:\n    return ret;\n}\n\nstatic int send_data_blocked(quicly_conn_t *conn, quicly_send_context_t *s)\n{\n    quicly_sent_t *sent;\n    int ret;\n\n    uint64_t offset = conn->egress.max_data.permitted;\n    if ((ret = allocate_ack_eliciting_frame(conn, s, QUICLY_DATA_BLOCKED_FRAME_CAPACITY, &sent, on_ack_data_blocked)) != 0)\n        goto Exit;\n    sent->data.data_blocked.offset = offset;\n    s->dst = quicly_encode_data_blocked_frame(s->dst, offset);\n    conn->egress.data_blocked = QUICLY_SENDER_STATE_UNACKED;\n\n    ++conn->super.stats.num_frames_sent.data_blocked;\n    QUICLY_PROBE(DATA_BLOCKED_SEND, conn, conn->stash.now, offset);\n    QUICLY_LOG_CONN(data_blocked_send, conn, { PTLS_LOG_ELEMENT_UNSIGNED(off, offset); });\n\n    ret = 0;\nExit:\n    return ret;\n}\n\nstatic int send_resumption_token(quicly_conn_t *conn, quicly_send_context_t *s)\n{\n    quicly_address_token_plaintext_t token;\n    ptls_buffer_t tokenbuf;\n    uint8_t tokenbuf_small[128];\n    quicly_sent_t *sent;\n    int ret;\n\n    ptls_buffer_init(&tokenbuf, tokenbuf_small, sizeof(tokenbuf_small));\n\n    /* build token */\n    token =\n        (quicly_address_token_plaintext_t){QUICLY_ADDRESS_TOKEN_TYPE_RESUMPTION, conn->super.ctx->now->cb(conn->super.ctx->now)};\n    token.remote = conn->super.remote.address;\n    /* TODO fill token.resumption */\n\n    /* encrypt */\n    if ((ret = conn->super.ctx->generate_resumption_token->cb(conn->super.ctx->generate_resumption_token, conn, &tokenbuf,\n                                                              &token)) != 0)\n        goto Exit;\n    assert(tokenbuf.off < QUICLY_MIN_CLIENT_INITIAL_SIZE / 2 && \"this is a ballpark figure, but tokens ought to be small\");\n\n    /* emit frame */\n    if ((ret = allocate_ack_eliciting_frame(conn, s, quicly_new_token_frame_capacity(ptls_iovec_init(tokenbuf.base, tokenbuf.off)),\n                                            &sent, on_ack_new_token)) != 0)\n        goto Exit;\n    ++conn->egress.new_token.num_inflight;\n    sent->data.new_token.is_inflight = 1;\n    sent->data.new_token.generation = conn->egress.new_token.generation;\n    s->dst = quicly_encode_new_token_frame(s->dst, ptls_iovec_init(tokenbuf.base, tokenbuf.off));\n    conn->egress.pending_flows &= ~QUICLY_PENDING_FLOW_NEW_TOKEN_BIT;\n\n    ++conn->super.stats.num_frames_sent.new_token;\n    QUICLY_PROBE(NEW_TOKEN_SEND, conn, conn->stash.now, tokenbuf.base, tokenbuf.off, sent->data.new_token.generation);\n    QUICLY_LOG_CONN(new_token_send, conn, {\n        PTLS_LOG_ELEMENT_HEXDUMP(token, tokenbuf.base, tokenbuf.off);\n        PTLS_LOG_ELEMENT_UNSIGNED(generation, sent->data.new_token.generation);\n    });\n    ret = 0;\nExit:\n    ptls_buffer_dispose(&tokenbuf);\n    return ret;\n}\n\nsize_t quicly_send_version_negotiation(quicly_context_t *ctx, ptls_iovec_t dest_cid, ptls_iovec_t src_cid, const uint32_t *versions,\n                                       void *payload)\n{\n    uint8_t *dst = payload;\n\n    /* type_flags */\n    ctx->tls->random_bytes(dst, 1);\n    *dst |= QUICLY_LONG_HEADER_BIT;\n    ++dst;\n    /* version */\n    dst = quicly_encode32(dst, 0);\n    /* connection-id */\n    *dst++ = dest_cid.len;\n    if (dest_cid.len != 0) {\n        memcpy(dst, dest_cid.base, dest_cid.len);\n        dst += dest_cid.len;\n    }\n    *dst++ = src_cid.len;\n    if (src_cid.len != 0) {\n        memcpy(dst, src_cid.base, src_cid.len);\n        dst += src_cid.len;\n    }\n    /* supported_versions */\n    for (const uint32_t *v = versions; *v != 0; ++v)\n        dst = quicly_encode32(dst, *v);\n    /* add a greasing version. This also covers the case where an empty list is specified by the caller to indicate rejection. */\n    uint32_t grease_version = 0;\n    if (src_cid.len >= sizeof(grease_version))\n        memcpy(&grease_version, src_cid.base, sizeof(grease_version));\n    grease_version = (grease_version & 0xf0f0f0f0) | 0x0a0a0a0a;\n    dst = quicly_encode32(dst, grease_version);\n\n    return dst - (uint8_t *)payload;\n}\n\nint quicly_retry_calc_cidpair_hash(ptls_hash_algorithm_t *sha256, ptls_iovec_t client_cid, ptls_iovec_t server_cid, uint64_t *value)\n{\n    uint8_t digest[PTLS_SHA256_DIGEST_SIZE], buf[(QUICLY_MAX_CID_LEN_V1 + 1) * 2], *p = buf;\n    int ret;\n\n    *p++ = (uint8_t)client_cid.len;\n    memcpy(p, client_cid.base, client_cid.len);\n    p += client_cid.len;\n    *p++ = (uint8_t)server_cid.len;\n    memcpy(p, server_cid.base, server_cid.len);\n    p += server_cid.len;\n\n    if ((ret = ptls_calc_hash(sha256, digest, buf, p - buf)) != 0)\n        return ret;\n    p = digest;\n    *value = quicly_decode64((void *)&p);\n\n    return 0;\n}\n\nsize_t quicly_send_retry(quicly_context_t *ctx, ptls_aead_context_t *token_encrypt_ctx, uint32_t protocol_version,\n                         struct sockaddr *dest_addr, ptls_iovec_t dest_cid, struct sockaddr *src_addr, ptls_iovec_t src_cid,\n                         ptls_iovec_t odcid, ptls_iovec_t token_prefix, ptls_iovec_t appdata,\n                         ptls_aead_context_t **retry_aead_cache, uint8_t *datagram)\n{\n    quicly_address_token_plaintext_t token;\n    ptls_buffer_t buf;\n    int ret;\n\n    assert(!(src_cid.len == odcid.len && memcmp(src_cid.base, odcid.base, src_cid.len) == 0));\n\n    /* build token as plaintext */\n    token = (quicly_address_token_plaintext_t){QUICLY_ADDRESS_TOKEN_TYPE_RETRY, ctx->now->cb(ctx->now)};\n    set_address(&token.remote, dest_addr);\n    set_address(&token.local, src_addr);\n\n    quicly_set_cid(&token.retry.original_dcid, odcid);\n    quicly_set_cid(&token.retry.client_cid, dest_cid);\n    quicly_set_cid(&token.retry.server_cid, src_cid);\n    if (appdata.len != 0) {\n        assert(appdata.len <= sizeof(token.appdata.bytes));\n        memcpy(token.appdata.bytes, appdata.base, appdata.len);\n        token.appdata.len = appdata.len;\n    }\n\n    /* start building the packet */\n    ptls_buffer_init(&buf, datagram, QUICLY_MIN_CLIENT_INITIAL_SIZE);\n\n    /* first generate a pseudo packet */\n    ptls_buffer_push_block(&buf, 1, { ptls_buffer_pushv(&buf, odcid.base, odcid.len); });\n    ctx->tls->random_bytes(buf.base + buf.off, 1);\n    buf.base[buf.off] = QUICLY_PACKET_TYPE_RETRY | (buf.base[buf.off] & 0x0f);\n    ++buf.off;\n    ptls_buffer_push32(&buf, protocol_version);\n    ptls_buffer_push_block(&buf, 1, { ptls_buffer_pushv(&buf, dest_cid.base, dest_cid.len); });\n    ptls_buffer_push_block(&buf, 1, { ptls_buffer_pushv(&buf, src_cid.base, src_cid.len); });\n    if (token_prefix.len != 0) {\n        assert(token_prefix.len <= buf.capacity - buf.off);\n        memcpy(buf.base + buf.off, token_prefix.base, token_prefix.len);\n        buf.off += token_prefix.len;\n    }\n    if ((ret = quicly_encrypt_address_token(ctx->tls->random_bytes, token_encrypt_ctx, &buf, buf.off - token_prefix.len, &token)) !=\n        0)\n        goto Exit;\n\n    /* append AEAD tag */\n    ret = ptls_buffer_reserve(&buf, PTLS_AESGCM_TAG_SIZE);\n    assert(ret == 0);\n    assert(!buf.is_allocated && \"retry packet is too large\");\n    {\n        ptls_aead_context_t *aead =\n            retry_aead_cache != NULL && *retry_aead_cache != NULL ? *retry_aead_cache : create_retry_aead(ctx, protocol_version, 1);\n        ptls_aead_encrypt(aead, buf.base + buf.off, \"\", 0, 0, buf.base, buf.off);\n        if (retry_aead_cache != NULL) {\n            *retry_aead_cache = aead;\n        } else {\n            ptls_aead_free(aead);\n        }\n    }\n    buf.off += PTLS_AESGCM_TAG_SIZE;\n\n    /* convert the image to a Retry packet, by stripping the ODCID field */\n    memmove(buf.base, buf.base + odcid.len + 1, buf.off - (odcid.len + 1));\n    buf.off -= odcid.len + 1;\n\n    ret = 0;\n\nExit:\n    return ret == 0 ? buf.off : SIZE_MAX;\n}\n\nstatic struct st_quicly_pn_space_t *setup_send_space(quicly_conn_t *conn, size_t epoch, quicly_send_context_t *s)\n{\n    struct st_quicly_pn_space_t *space = NULL;\n\n    switch (epoch) {\n    case QUICLY_EPOCH_INITIAL:\n        if (conn->initial == NULL || (s->current.cipher = &conn->initial->cipher.egress)->aead == NULL)\n            return NULL;\n        s->current.first_byte = QUICLY_PACKET_TYPE_INITIAL;\n        space = &conn->initial->super;\n        break;\n    case QUICLY_EPOCH_HANDSHAKE:\n        if (conn->handshake == NULL || (s->current.cipher = &conn->handshake->cipher.egress)->aead == NULL)\n            return NULL;\n        s->current.first_byte = QUICLY_PACKET_TYPE_HANDSHAKE;\n        space = &conn->handshake->super;\n        break;\n    case QUICLY_EPOCH_0RTT:\n    case QUICLY_EPOCH_1RTT:\n        if (conn->application == NULL || conn->application->cipher.egress.key.header_protection == NULL)\n            return NULL;\n        if ((epoch == QUICLY_EPOCH_0RTT) == conn->application->one_rtt_writable)\n            return NULL;\n        s->current.cipher = &conn->application->cipher.egress.key;\n        s->current.first_byte = epoch == QUICLY_EPOCH_0RTT ? QUICLY_PACKET_TYPE_0RTT : QUICLY_QUIC_BIT;\n        space = &conn->application->super;\n        break;\n    default:\n        assert(!\"logic flaw\");\n        break;\n    }\n\n    return space;\n}\n\nstatic int send_handshake_flow(quicly_conn_t *conn, size_t epoch, quicly_send_context_t *s, int ack_only, int send_probe)\n{\n    struct st_quicly_pn_space_t *space;\n    int ret = 0;\n\n    /* setup send epoch, or return if it's impossible to send in this epoch */\n    if ((space = setup_send_space(conn, epoch, s)) == NULL)\n        return 0;\n\n    /* send ACK */\n    if (space != NULL && (space->unacked_count != 0 || send_probe))\n        if ((ret = send_ack(conn, space, s)) != 0)\n            goto Exit;\n\n    if (!ack_only) {\n        /* send data */\n        while ((conn->egress.pending_flows & (uint8_t)(1 << epoch)) != 0) {\n            quicly_stream_t *stream = quicly_get_stream(conn, -(quicly_stream_id_t)(1 + epoch));\n            assert(stream != NULL);\n            if ((ret = quicly_send_stream(stream, s)) != 0)\n                goto Exit;\n            resched_stream_data(stream);\n            send_probe = 0;\n        }\n\n        /* send probe if requested */\n        if (send_probe) {\n            if ((ret = do_allocate_frame(conn, s, 1, ALLOCATE_FRAME_TYPE_ACK_ELICITING)) != 0)\n                goto Exit;\n            *s->dst++ = QUICLY_FRAME_TYPE_PING;\n            conn->egress.last_retransmittable_sent_at = conn->stash.now;\n            ++conn->super.stats.num_frames_sent.ping;\n            QUICLY_PROBE(PING_SEND, conn, conn->stash.now);\n            QUICLY_LOG_CONN(ping_send, conn, {});\n        }\n    }\n\nExit:\n    return ret;\n}\n\nstatic int send_connection_close(quicly_conn_t *conn, size_t epoch, quicly_send_context_t *s)\n{\n    uint64_t error_code, offending_frame_type;\n    const char *reason_phrase;\n    int ret;\n\n    /* setup send epoch, or return if it's impossible to send in this epoch */\n    if (setup_send_space(conn, epoch, s) == NULL)\n        return 0;\n\n    /* determine the payload, masking the application error when sending the frame using an unauthenticated epoch */\n    error_code = conn->egress.connection_close.error_code;\n    offending_frame_type = conn->egress.connection_close.frame_type;\n    reason_phrase = conn->egress.connection_close.reason_phrase;\n    if (offending_frame_type == UINT64_MAX) {\n        switch (get_epoch(s->current.first_byte)) {\n        case QUICLY_EPOCH_INITIAL:\n        case QUICLY_EPOCH_HANDSHAKE:\n            error_code = QUICLY_TRANSPORT_ERROR_APPLICATION;\n            offending_frame_type = QUICLY_FRAME_TYPE_PADDING;\n            reason_phrase = \"\";\n            break;\n        }\n    }\n\n    /* write frame */\n    if ((ret = do_allocate_frame(conn, s, quicly_close_frame_capacity(error_code, offending_frame_type, reason_phrase),\n                                 ALLOCATE_FRAME_TYPE_NON_ACK_ELICITING)) != 0)\n        return ret;\n    s->dst = quicly_encode_close_frame(s->dst, error_code, offending_frame_type, reason_phrase);\n\n    /* update counter, probe */\n    if (offending_frame_type != UINT64_MAX) {\n        ++conn->super.stats.num_frames_sent.transport_close;\n        QUICLY_PROBE(TRANSPORT_CLOSE_SEND, conn, conn->stash.now, error_code, offending_frame_type, reason_phrase);\n        QUICLY_LOG_CONN(transport_close_send, conn, {\n            PTLS_LOG_ELEMENT_UNSIGNED(error_code, error_code);\n            PTLS_LOG_ELEMENT_UNSIGNED(frame_type, offending_frame_type);\n            PTLS_LOG_ELEMENT_UNSAFESTR(reason_phrase, reason_phrase, strlen(reason_phrase));\n        });\n    } else {\n        ++conn->super.stats.num_frames_sent.application_close;\n        QUICLY_PROBE(APPLICATION_CLOSE_SEND, conn, conn->stash.now, error_code, reason_phrase);\n        QUICLY_LOG_CONN(application_close_send, conn, {\n            PTLS_LOG_ELEMENT_UNSIGNED(error_code, error_code);\n            PTLS_LOG_ELEMENT_UNSAFESTR(reason_phrase, reason_phrase, strlen(reason_phrase));\n        });\n    }\n\n    return 0;\n}\n\nstatic int send_new_connection_id(quicly_conn_t *conn, quicly_send_context_t *s, struct st_quicly_local_cid_t *new_cid)\n{\n    int ret;\n    quicly_sent_t *sent;\n    uint64_t retire_prior_to = 0; /* TODO */\n\n    ret = allocate_ack_eliciting_frame(\n        conn, s, quicly_new_connection_id_frame_capacity(new_cid->sequence, retire_prior_to, new_cid->cid.len), &sent,\n        on_ack_new_connection_id);\n    if (ret != 0)\n        return ret;\n    sent->data.new_connection_id.sequence = new_cid->sequence;\n\n    s->dst = quicly_encode_new_connection_id_frame(s->dst, new_cid->sequence, retire_prior_to, new_cid->cid.cid, new_cid->cid.len,\n                                                   new_cid->stateless_reset_token);\n\n    ++conn->super.stats.num_frames_sent.new_connection_id;\n    QUICLY_PROBE(NEW_CONNECTION_ID_SEND, conn, conn->stash.now, new_cid->sequence, retire_prior_to,\n                 QUICLY_PROBE_HEXDUMP(new_cid->cid.cid, new_cid->cid.len),\n                 QUICLY_PROBE_HEXDUMP(new_cid->stateless_reset_token, QUICLY_STATELESS_RESET_TOKEN_LEN));\n    QUICLY_LOG_CONN(new_connection_id_send, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(sequence, new_cid->sequence);\n        PTLS_LOG_ELEMENT_UNSIGNED(retire_prior_to, retire_prior_to);\n        PTLS_LOG_ELEMENT_HEXDUMP(cid, new_cid->cid.cid, new_cid->cid.len);\n        PTLS_LOG_ELEMENT_HEXDUMP(stateless_reset_token, new_cid->stateless_reset_token, QUICLY_STATELESS_RESET_TOKEN_LEN);\n    });\n\n    return 0;\n}\n\nstatic int send_retire_connection_id(quicly_conn_t *conn, quicly_send_context_t *s, uint64_t sequence)\n{\n    int ret;\n    quicly_sent_t *sent;\n\n    ret = allocate_ack_eliciting_frame(conn, s, quicly_retire_connection_id_frame_capacity(sequence), &sent,\n                                       on_ack_retire_connection_id);\n    if (ret != 0)\n        return ret;\n    sent->data.retire_connection_id.sequence = sequence;\n\n    s->dst = quicly_encode_retire_connection_id_frame(s->dst, sequence);\n\n    ++conn->super.stats.num_frames_sent.retire_connection_id;\n    QUICLY_PROBE(RETIRE_CONNECTION_ID_SEND, conn, conn->stash.now, sequence);\n    QUICLY_LOG_CONN(retire_connection_id_send, conn, { PTLS_LOG_ELEMENT_UNSIGNED(sequence, sequence); });\n\n    return 0;\n}\n\nstatic int update_traffic_key_cb(ptls_update_traffic_key_t *self, ptls_t *tls, int is_enc, size_t epoch, const void *secret)\n{\n    quicly_conn_t *conn = *ptls_get_data_ptr(tls);\n    ptls_context_t *tlsctx = ptls_get_context(tls);\n    ptls_cipher_suite_t *cipher = ptls_get_cipher(tls);\n    ptls_cipher_context_t **hp_slot;\n    ptls_aead_context_t **aead_slot;\n    int ret;\n    static const char *log_labels[2][4] = {\n        {NULL, \"CLIENT_EARLY_TRAFFIC_SECRET\", \"CLIENT_HANDSHAKE_TRAFFIC_SECRET\", \"CLIENT_TRAFFIC_SECRET_0\"},\n        {NULL, NULL, \"SERVER_HANDSHAKE_TRAFFIC_SECRET\", \"SERVER_TRAFFIC_SECRET_0\"}};\n    const char *log_label = log_labels[ptls_is_server(tls) == is_enc][epoch];\n\n    QUICLY_PROBE(CRYPTO_UPDATE_SECRET, conn, conn->stash.now, is_enc, epoch, log_label,\n                 QUICLY_PROBE_HEXDUMP(secret, cipher->hash->digest_size));\n    QUICLY_LOG_CONN(crypto_update_secret, conn, {\n        PTLS_LOG_ELEMENT_BOOL(is_enc, is_enc);\n        PTLS_LOG_ELEMENT_UNSIGNED(epoch, epoch);\n        PTLS_LOG_ELEMENT_SAFESTR(label, log_label);\n        PTLS_LOG_APPDATA_ELEMENT_HEXDUMP(secret, secret, cipher->hash->digest_size);\n    });\n\n    if (tlsctx->log_event != NULL) {\n        char hexbuf[PTLS_MAX_DIGEST_SIZE * 2 + 1];\n        ptls_hexdump(hexbuf, secret, cipher->hash->digest_size);\n        tlsctx->log_event->cb(tlsctx->log_event, tls, log_label, \"%s\", hexbuf);\n    }\n\n#define SELECT_CIPHER_CONTEXT(p)                                                                                                   \\\n    do {                                                                                                                           \\\n        hp_slot = &(p)->header_protection;                                                                                         \\\n        aead_slot = &(p)->aead;                                                                                                    \\\n    } while (0)\n\n    switch (epoch) {\n    case QUICLY_EPOCH_0RTT:\n        assert(is_enc == quicly_is_client(conn));\n        if (conn->application == NULL && (ret = setup_application_space(conn)) != 0)\n            return ret;\n        if (is_enc) {\n            SELECT_CIPHER_CONTEXT(&conn->application->cipher.egress.key);\n        } else {\n            hp_slot = &conn->application->cipher.ingress.header_protection.zero_rtt;\n            aead_slot = &conn->application->cipher.ingress.aead[1];\n        }\n        break;\n    case QUICLY_EPOCH_HANDSHAKE:\n        if (conn->handshake == NULL && (ret = setup_handshake_space_and_flow(conn, QUICLY_EPOCH_HANDSHAKE)) != 0)\n            return ret;\n        SELECT_CIPHER_CONTEXT(is_enc ? &conn->handshake->cipher.egress : &conn->handshake->cipher.ingress);\n        break;\n    case QUICLY_EPOCH_1RTT: {\n        if (is_enc)\n            if ((ret = apply_remote_transport_params(conn)) != 0)\n                return ret;\n        if (conn->application == NULL && (ret = setup_application_space(conn)) != 0)\n            return ret;\n        uint8_t *secret_store;\n        if (is_enc) {\n            if (conn->application->cipher.egress.key.aead != NULL)\n                dispose_cipher(&conn->application->cipher.egress.key);\n            SELECT_CIPHER_CONTEXT(&conn->application->cipher.egress.key);\n            secret_store = conn->application->cipher.egress.secret;\n        } else {\n            hp_slot = &conn->application->cipher.ingress.header_protection.one_rtt;\n            aead_slot = &conn->application->cipher.ingress.aead[0];\n            secret_store = conn->application->cipher.ingress.secret;\n        }\n        memcpy(secret_store, secret, cipher->hash->digest_size);\n    } break;\n    default:\n        assert(!\"logic flaw\");\n        break;\n    }\n\n#undef SELECT_CIPHER_CONTEXT\n\n    if ((ret = setup_cipher(conn, epoch, is_enc, hp_slot, aead_slot, cipher->aead, cipher->hash, secret)) != 0)\n        return ret;\n\n    if (epoch == QUICLY_EPOCH_1RTT && is_enc) {\n        /* update states now that we have 1-RTT write key */\n        conn->application->one_rtt_writable = 1;\n        open_blocked_streams(conn, 1);\n        open_blocked_streams(conn, 0);\n        /* send the first resumption token using the 0.5 RTT window */\n        if (!quicly_is_client(conn) && conn->super.ctx->generate_resumption_token != NULL) {\n            ret = quicly_send_resumption_token(conn);\n            assert(ret == 0);\n        }\n\n        /* schedule NEW_CONNECTION_IDs */\n        size_t size = local_cid_size(conn);\n        if (quicly_local_cid_set_size(&conn->super.local.cid_set, size))\n            conn->egress.pending_flows |= QUICLY_PENDING_FLOW_OTHERS_BIT;\n    }\n\n    return 0;\n}\n\nstatic int send_other_control_frames(quicly_conn_t *conn, quicly_send_context_t *s)\n{\n    int ret;\n\n    /* respond to all pending received PATH_CHALLENGE frames */\n    if (conn->egress.path_challenge.head != NULL) {\n        do {\n            struct st_quicly_pending_path_challenge_t *c = conn->egress.path_challenge.head;\n            if ((ret = do_allocate_frame(conn, s, QUICLY_PATH_CHALLENGE_FRAME_CAPACITY, ALLOCATE_FRAME_TYPE_NON_ACK_ELICITING)) !=\n                0)\n                return ret;\n            s->dst = quicly_encode_path_challenge_frame(s->dst, c->is_response, c->data);\n            if (c->is_response) {\n                ++conn->super.stats.num_frames_sent.path_response;\n            } else {\n                ++conn->super.stats.num_frames_sent.path_challenge;\n            }\n            conn->egress.path_challenge.head = c->next;\n            free(c);\n        } while (conn->egress.path_challenge.head != NULL);\n        conn->egress.path_challenge.tail_ref = &conn->egress.path_challenge.head;\n        s->target.full_size = 1; /* datagrams carrying PATH_CHALLENGE / PATH_RESPONSE have to be full-sized */\n    }\n\n    /* MAX_STREAMS */\n    if ((ret = send_max_streams(conn, 1, s)) != 0)\n        return ret;\n    if ((ret = send_max_streams(conn, 0, s)) != 0)\n        return ret;\n\n    /* MAX_DATA */\n    if (should_send_max_data(conn)) {\n        quicly_sent_t *sent;\n        if ((ret = allocate_ack_eliciting_frame(conn, s, QUICLY_MAX_DATA_FRAME_CAPACITY, &sent, on_ack_max_data)) != 0)\n            return ret;\n        uint64_t new_value = conn->ingress.max_data.bytes_consumed + conn->super.ctx->transport_params.max_data;\n        s->dst = quicly_encode_max_data_frame(s->dst, new_value);\n        quicly_maxsender_record(&conn->ingress.max_data.sender, new_value, &sent->data.max_data.args);\n        ++conn->super.stats.num_frames_sent.max_data;\n        QUICLY_PROBE(MAX_DATA_SEND, conn, conn->stash.now, new_value);\n        QUICLY_LOG_CONN(max_data_send, conn, { PTLS_LOG_ELEMENT_UNSIGNED(maximum, new_value); });\n    }\n\n    /* DATA_BLOCKED */\n    if (conn->egress.data_blocked == QUICLY_SENDER_STATE_SEND && (ret = send_data_blocked(conn, s)) != 0)\n        return ret;\n\n    /* STREAMS_BLOCKED */\n    if ((ret = send_streams_blocked(conn, 1, s)) != 0)\n        return ret;\n    if ((ret = send_streams_blocked(conn, 0, s)) != 0)\n        return ret;\n\n    { /* NEW_CONNECTION_ID */\n        size_t i, size = quicly_local_cid_get_size(&conn->super.local.cid_set);\n        for (i = 0; i < size; i++) {\n            /* PENDING CIDs are located at the front */\n            struct st_quicly_local_cid_t *c = &conn->super.local.cid_set.cids[i];\n            if (c->state != QUICLY_LOCAL_CID_STATE_PENDING)\n                break;\n            if ((ret = send_new_connection_id(conn, s, c)) != 0)\n                break;\n        }\n        quicly_local_cid_on_sent(&conn->super.local.cid_set, i);\n        if (ret != 0)\n            return ret;\n    }\n\n    { /* RETIRE_CONNECTION_ID */\n        size_t i, size = quicly_retire_cid_get_num_pending(&conn->egress.retire_cid);\n        for (i = 0; i < size; i++) {\n            uint64_t sequence = conn->egress.retire_cid.sequences[i];\n            if ((ret = send_retire_connection_id(conn, s, sequence)) != 0)\n                break;\n        }\n        quicly_retire_cid_shift(&conn->egress.retire_cid, i);\n        if (ret != 0)\n            return ret;\n    }\n\n    return 0;\n}\n\nstatic int do_send(quicly_conn_t *conn, quicly_send_context_t *s)\n{\n    int restrict_sending = 0, ack_only = 0, ret;\n    size_t min_packets_to_send = 0;\n\n    /* handle timeouts */\n    if (conn->idle_timeout.at <= conn->stash.now) {\n        QUICLY_PROBE(IDLE_TIMEOUT, conn, conn->stash.now);\n        QUICLY_LOG_CONN(idle_timeout, conn, {});\n        goto CloseNow;\n    }\n    /* handle handshake timeouts */\n    if ((conn->initial != NULL || conn->handshake != NULL) &&\n        conn->created_at + (uint64_t)conn->super.ctx->handshake_timeout_rtt_multiplier * conn->egress.loss.rtt.smoothed <=\n            conn->stash.now) {\n        QUICLY_PROBE(HANDSHAKE_TIMEOUT, conn, conn->stash.now, conn->stash.now - conn->created_at, conn->egress.loss.rtt.smoothed);\n        QUICLY_LOG_CONN(handshake_timeout, conn, {\n            PTLS_LOG_ELEMENT_SIGNED(elapsed, conn->stash.now - conn->created_at);\n            PTLS_LOG_ELEMENT_UNSIGNED(rtt_smoothed, conn->egress.loss.rtt.smoothed);\n        });\n        conn->super.stats.num_handshake_timeouts++;\n        goto CloseNow;\n    }\n    if (conn->super.stats.num_packets.initial_handshake_sent > conn->super.ctx->max_initial_handshake_packets) {\n        QUICLY_PROBE(INITIAL_HANDSHAKE_PACKET_EXCEED, conn, conn->stash.now, conn->super.stats.num_packets.initial_handshake_sent);\n        QUICLY_LOG_CONN(initial_handshake_packet_exceed, conn,\n                        { PTLS_LOG_ELEMENT_UNSIGNED(num_packets, conn->super.stats.num_packets.initial_handshake_sent); });\n        conn->super.stats.num_initial_handshake_exceeded++;\n        goto CloseNow;\n    }\n    if (conn->egress.loss.alarm_at <= conn->stash.now) {\n        if ((ret = quicly_loss_on_alarm(&conn->egress.loss, conn->stash.now, conn->super.remote.transport_params.max_ack_delay,\n                                        conn->initial == NULL && conn->handshake == NULL, &min_packets_to_send, &restrict_sending,\n                                        on_loss_detected)) != 0)\n            goto Exit;\n        assert(min_packets_to_send > 0);\n        assert(min_packets_to_send <= s->max_datagrams);\n\n        if (restrict_sending) {\n            /* PTO: when handshake is in progress, send from the very first unacknowledged byte so as to maximize the chance of\n             * making progress. When handshake is complete, transmit new data if any, else retransmit the oldest unacknowledged data\n             * that is considered inflight. */\n            QUICLY_PROBE(PTO, conn, conn->stash.now, conn->egress.loss.sentmap.bytes_in_flight, conn->egress.cc.cwnd,\n                         conn->egress.loss.pto_count);\n            QUICLY_LOG_CONN(pto, conn, {\n                PTLS_LOG_ELEMENT_SIGNED(inflight, conn->egress.loss.sentmap.bytes_in_flight);\n                PTLS_LOG_ELEMENT_UNSIGNED(cwnd, conn->egress.cc.cwnd);\n                PTLS_LOG_ELEMENT_SIGNED(pto_count, conn->egress.loss.pto_count);\n            });\n            ++conn->super.stats.num_ptos;\n            size_t bytes_to_mark = min_packets_to_send * conn->egress.max_udp_payload_size;\n            if (conn->initial != NULL && (ret = mark_frames_on_pto(conn, QUICLY_EPOCH_INITIAL, &bytes_to_mark)) != 0)\n                goto Exit;\n            if (bytes_to_mark != 0 && conn->handshake != NULL &&\n                (ret = mark_frames_on_pto(conn, QUICLY_EPOCH_HANDSHAKE, &bytes_to_mark)) != 0)\n                goto Exit;\n            /* Mark already sent 1-RTT data for PTO only if there's no new data, i.e., when scheduler_can_send() return false. */\n            if (bytes_to_mark != 0 && !scheduler_can_send(conn) &&\n                (ret = mark_frames_on_pto(conn, QUICLY_EPOCH_1RTT, &bytes_to_mark)) != 0)\n                goto Exit;\n        }\n    }\n\n    /* disable ECN if zero packets where acked in the first 3 PTO of the connection during which all sent packets are ECT(0) */\n    if (conn->egress.ecn.state == QUICLY_ECN_PROBING && conn->created_at + conn->egress.loss.rtt.smoothed * 3 < conn->stash.now) {\n        update_ecn_state(conn, QUICLY_ECN_OFF);\n        /* TODO reset CC? */\n    }\n\n    s->send_window = calc_send_window(conn, min_packets_to_send * conn->egress.max_udp_payload_size,\n                                      calc_amplification_limit_allowance(conn), restrict_sending);\n    if (s->send_window == 0)\n        ack_only = 1;\n\n    /* send handshake flows; when PTO fires...\n     *  * quicly running as a client sends either a Handshake probe (or data) if the handshake keys are available, or else an\n     *    Initial probe (or data).\n     *  * quicly running as a server sends both Initial and Handshake probes (or data) if the corresponding keys are available. */\n    if ((ret = send_handshake_flow(conn, QUICLY_EPOCH_INITIAL, s, ack_only,\n                                   min_packets_to_send != 0 && (!quicly_is_client(conn) || conn->handshake == NULL))) != 0)\n        goto Exit;\n    if ((ret = send_handshake_flow(conn, QUICLY_EPOCH_HANDSHAKE, s, ack_only, min_packets_to_send != 0)) != 0)\n        goto Exit;\n\n    /* setup 0-RTT or 1-RTT send context (as the availability of the two epochs are mutually exclusive, we can try 1-RTT first as an\n     * optimization), then send application data if that succeeds */\n    if (setup_send_space(conn, QUICLY_EPOCH_1RTT, s) != NULL || setup_send_space(conn, QUICLY_EPOCH_0RTT, s) != NULL) {\n        /* acks */\n        if (conn->application->one_rtt_writable && conn->egress.send_ack_at <= conn->stash.now &&\n            conn->application->super.unacked_count != 0) {\n            if ((ret = send_ack(conn, &conn->application->super, s)) != 0)\n                goto Exit;\n        }\n        /* DATAGRAM frame. Notes regarding current implementation:\n         * * Not limited by CC, nor the bytes counted by CC.\n         * * When given payload is too large and does not fit into a QUIC packet, a packet containing only PADDING frames is sent.\n         *   This is because we do not have a way to retract the generation of a QUIC packet.\n         * * Does not notify the application that the frame was dropped internally. */\n        if (should_send_datagram_frame(conn)) {\n            for (size_t i = 0; i != conn->egress.datagram_frame_payloads.count; ++i) {\n                ptls_iovec_t *payload = conn->egress.datagram_frame_payloads.payloads + i;\n                size_t required_space = quicly_datagram_frame_capacity(*payload);\n                if ((ret = do_allocate_frame(conn, s, required_space, ALLOCATE_FRAME_TYPE_ACK_ELICITING_NO_CC)) != 0)\n                    goto Exit;\n                if (s->dst_end - s->dst >= required_space) {\n                    s->dst = quicly_encode_datagram_frame(s->dst, *payload);\n                    QUICLY_PROBE(DATAGRAM_SEND, conn, conn->stash.now, payload->base, payload->len);\n                    QUICLY_LOG_CONN(datagram_send, conn,\n                                    { PTLS_LOG_APPDATA_ELEMENT_HEXDUMP(payload, payload->base, payload->len); });\n                } else {\n                    /* FIXME: At the moment, we add a padding because we do not have a way to reclaim allocated space, and because\n                     * it is forbidden to send an empty QUIC packet. */\n                    *s->dst++ = QUICLY_FRAME_TYPE_PADDING;\n                }\n            }\n        }\n        if (!ack_only) {\n            /* PTO or loss detection timeout, always send PING. This is the easiest thing to do in terms of timer control. */\n            if (min_packets_to_send != 0) {\n                if ((ret = do_allocate_frame(conn, s, 1, ALLOCATE_FRAME_TYPE_ACK_ELICITING)) != 0)\n                    goto Exit;\n                *s->dst++ = QUICLY_FRAME_TYPE_PING;\n                ++conn->super.stats.num_frames_sent.ping;\n                QUICLY_PROBE(PING_SEND, conn, conn->stash.now);\n                QUICLY_LOG_CONN(ping_send, conn, {});\n            }\n            /* take actions only permitted for short header packets */\n            if (conn->application->one_rtt_writable) {\n                /* send HANDSHAKE_DONE */\n                if ((conn->egress.pending_flows & QUICLY_PENDING_FLOW_HANDSHAKE_DONE_BIT) != 0 &&\n                    (ret = send_handshake_done(conn, s)) != 0)\n                    goto Exit;\n                /* post-handshake messages */\n                if ((conn->egress.pending_flows & (uint8_t)(1 << QUICLY_EPOCH_1RTT)) != 0) {\n                    quicly_stream_t *stream = quicly_get_stream(conn, -(1 + QUICLY_EPOCH_1RTT));\n                    assert(stream != NULL);\n                    if ((ret = quicly_send_stream(stream, s)) != 0)\n                        goto Exit;\n                    resched_stream_data(stream);\n                }\n                /* send other connection-level control frames, and iff we succeed in sending all of them, clear OTHERS_BIT to\n                 * disable `quicly_send` being called right again to send more control frames */\n                if ((ret = send_other_control_frames(conn, s)) != 0)\n                    goto Exit;\n                conn->egress.pending_flows &= ~QUICLY_PENDING_FLOW_OTHERS_BIT;\n                /* send NEW_TOKEN */\n                if ((conn->egress.pending_flows & QUICLY_PENDING_FLOW_NEW_TOKEN_BIT) != 0 &&\n                    (ret = send_resumption_token(conn, s)) != 0)\n                    goto Exit;\n            }\n            /* send stream-level control frames */\n            if ((ret = send_stream_control_frames(conn, s)) != 0)\n                goto Exit;\n            /* send STREAM frames */\n            if ((ret = conn->super.ctx->stream_scheduler->do_send(conn->super.ctx->stream_scheduler, conn, s)) != 0)\n                goto Exit;\n            /* once more, send control frames related to streams, as the state might have changed */\n            if ((ret = send_stream_control_frames(conn, s)) != 0)\n                goto Exit;\n            if ((conn->egress.pending_flows & QUICLY_PENDING_FLOW_OTHERS_BIT) != 0) {\n                if ((ret = send_other_control_frames(conn, s)) != 0)\n                    goto Exit;\n                conn->egress.pending_flows &= ~QUICLY_PENDING_FLOW_OTHERS_BIT;\n            }\n        }\n    }\n\nExit:\n    if (ret == QUICLY_ERROR_SENDBUF_FULL)\n        ret = 0;\n    if (ret == 0 && s->target.first_byte_at != NULL) {\n        /* last packet can be small-sized, unless it is the first flight sent from the client */\n        if ((s->payload_buf.datagram[0] & QUICLY_PACKET_TYPE_BITMASK) == QUICLY_PACKET_TYPE_INITIAL &&\n            (quicly_is_client(conn) || !ack_only))\n            s->target.full_size = 1;\n        commit_send_packet(conn, s, 0);\n    }\n    if (ret == 0) {\n        /* update timers, start / stop delivery rate estimator */\n        if (conn->application == NULL || conn->application->super.unacked_count == 0)\n            conn->egress.send_ack_at = INT64_MAX; /* we have sent ACKs for every epoch (or before address validation) */\n        int can_send_stream_data = scheduler_can_send(conn);\n        update_send_alarm(conn, can_send_stream_data, 1);\n        if (can_send_stream_data &&\n            (s->num_datagrams == s->max_datagrams || conn->egress.loss.sentmap.bytes_in_flight >= conn->egress.cc.cwnd)) {\n            /* as the flow is CWND-limited, start delivery rate estimator */\n            quicly_ratemeter_in_cwnd_limited(&conn->egress.ratemeter, s->first_packet_number);\n        } else {\n            quicly_ratemeter_not_cwnd_limited(&conn->egress.ratemeter, conn->egress.packet_number);\n        }\n        if (s->num_datagrams != 0)\n            update_idle_timeout(conn, 0);\n    }\n    return ret;\n\nCloseNow:\n    conn->super.state = QUICLY_STATE_DRAINING;\n    destroy_all_streams(conn, 0, 0);\n    return QUICLY_ERROR_FREE_CONNECTION;\n}\n\nvoid quicly_send_datagram_frames(quicly_conn_t *conn, ptls_iovec_t *datagrams, size_t num_datagrams)\n{\n    for (size_t i = 0; i != num_datagrams; ++i) {\n        if (conn->egress.datagram_frame_payloads.count == PTLS_ELEMENTSOF(conn->egress.datagram_frame_payloads.payloads))\n            break;\n        void *copied;\n        if ((copied = malloc(datagrams[i].len)) == NULL)\n            break;\n        memcpy(copied, datagrams[i].base, datagrams[i].len);\n        conn->egress.datagram_frame_payloads.payloads[conn->egress.datagram_frame_payloads.count++] =\n            ptls_iovec_init(copied, datagrams[i].len);\n    }\n}\n\nint quicly_set_cc(quicly_conn_t *conn, quicly_cc_type_t *cc)\n{\n    return cc->cc_switch(&conn->egress.cc);\n}\n\nint quicly_send(quicly_conn_t *conn, quicly_address_t *dest, quicly_address_t *src, struct iovec *datagrams, size_t *num_datagrams,\n                void *buf, size_t bufsize)\n{\n    quicly_send_context_t s = {.current = {.first_byte = -1},\n                               .datagrams = datagrams,\n                               .max_datagrams = *num_datagrams,\n                               .payload_buf = {.datagram = buf, .end = (uint8_t *)buf + bufsize},\n                               .first_packet_number = conn->egress.packet_number};\n    int ret;\n\n    lock_now(conn, 0);\n\n    /* bail out if there's nothing is scheduled to be sent */\n    if (conn->stash.now < quicly_get_first_timeout(conn)) {\n        ret = 0;\n        goto Exit;\n    }\n\n    QUICLY_PROBE(SEND, conn, conn->stash.now, conn->super.state,\n                 QUICLY_PROBE_HEXDUMP(conn->super.remote.cid_set.cids[0].cid.cid, conn->super.remote.cid_set.cids[0].cid.len));\n    QUICLY_LOG_CONN(send, conn, {\n        PTLS_LOG_ELEMENT_SIGNED(state, conn->super.state);\n        PTLS_LOG_ELEMENT_HEXDUMP(dcid, conn->super.remote.cid_set.cids[0].cid.cid, conn->super.remote.cid_set.cids[0].cid.len);\n    });\n\n    if (conn->super.state >= QUICLY_STATE_CLOSING) {\n        quicly_sentmap_iter_t iter;\n        if ((ret = init_acks_iter(conn, &iter)) != 0)\n            goto Exit;\n        /* check if the connection can be closed now (after 3 pto) */\n        if (conn->super.state == QUICLY_STATE_DRAINING ||\n            conn->super.stats.num_frames_sent.transport_close + conn->super.stats.num_frames_sent.application_close != 0) {\n            if (quicly_sentmap_get(&iter)->packet_number == UINT64_MAX) {\n                assert(quicly_num_streams(conn) == 0);\n                ret = QUICLY_ERROR_FREE_CONNECTION;\n                goto Exit;\n            }\n        }\n        if (conn->super.state == QUICLY_STATE_CLOSING && conn->egress.send_ack_at <= conn->stash.now) {\n            /* destroy all streams; doing so is delayed until the emission of CONNECTION_CLOSE frame to allow quicly_close to be\n             * called from a stream handler */\n            destroy_all_streams(conn, 0, 0);\n            /* send CONNECTION_CLOSE in all possible epochs */\n            for (size_t epoch = 0; epoch < QUICLY_NUM_EPOCHS; ++epoch) {\n                if ((ret = send_connection_close(conn, epoch, &s)) != 0)\n                    goto Exit;\n            }\n            if ((ret = commit_send_packet(conn, &s, 0)) != 0)\n                goto Exit;\n        }\n        /* wait at least 1ms */\n        if ((conn->egress.send_ack_at = quicly_sentmap_get(&iter)->sent_at + get_sentmap_expiration_time(conn)) <= conn->stash.now)\n            conn->egress.send_ack_at = conn->stash.now + 1;\n        ret = 0;\n        goto Exit;\n    }\n\n    /* emit packets */\n    if ((ret = do_send(conn, &s)) != 0)\n        goto Exit;\n\n    assert_consistency(conn, 1);\n\nExit:\n    clear_datagram_frame_payloads(conn);\n    if (s.num_datagrams != 0) {\n        *dest = conn->super.remote.address;\n        *src = conn->super.local.address;\n    }\n    *num_datagrams = s.num_datagrams;\n    unlock_now(conn);\n    return ret;\n}\n\nuint8_t quicly_send_get_ecn_bits(quicly_conn_t *conn)\n{\n    return conn->egress.ecn.state == QUICLY_ECN_OFF ? 0 : 2; /* NON-ECT or ECT(0) */\n}\n\nsize_t quicly_send_close_invalid_token(quicly_context_t *ctx, uint32_t protocol_version, ptls_iovec_t dest_cid,\n                                       ptls_iovec_t src_cid, const char *err_desc, void *datagram)\n{\n    struct st_quicly_cipher_context_t egress = {};\n    const struct st_ptls_salt_t *salt;\n\n    /* setup keys */\n    if ((salt = get_salt(protocol_version)) == NULL)\n        return SIZE_MAX;\n    if (setup_initial_encryption(get_aes128gcmsha256(ctx), NULL, &egress, src_cid, 0,\n                                 ptls_iovec_init(salt->initial, sizeof(salt->initial)), NULL) != 0)\n        return SIZE_MAX;\n\n    uint8_t *dst = datagram, *length_at;\n\n    /* build packet */\n    PTLS_BUILD_ASSERT(QUICLY_SEND_PN_SIZE == 2);\n    *dst++ = QUICLY_PACKET_TYPE_INITIAL | 0x1 /* 2-byte PN */;\n    dst = quicly_encode32(dst, protocol_version);\n    *dst++ = dest_cid.len;\n    memcpy(dst, dest_cid.base, dest_cid.len);\n    dst += dest_cid.len;\n    *dst++ = src_cid.len;\n    memcpy(dst, src_cid.base, src_cid.len);\n    dst += src_cid.len;\n    *dst++ = 0;        /* token_length = 0 */\n    length_at = dst++; /* length_at to be filled in later as 1-byte varint */\n    *dst++ = 0;        /* PN = 0 */\n    *dst++ = 0;        /* ditto */\n    uint8_t *payload_from = dst;\n    dst = quicly_encode_close_frame(dst, QUICLY_ERROR_GET_ERROR_CODE(QUICLY_TRANSPORT_ERROR_INVALID_TOKEN),\n                                    QUICLY_FRAME_TYPE_PADDING, err_desc);\n\n    /* determine the size of the packet, make adjustments */\n    dst += egress.aead->algo->tag_size;\n    assert(dst - (uint8_t *)datagram <= QUICLY_MIN_CLIENT_INITIAL_SIZE);\n    assert(dst - length_at - 1 < 64);\n    *length_at = dst - length_at - 1;\n    size_t datagram_len = dst - (uint8_t *)datagram;\n\n    /* encrypt packet */\n    quicly_default_crypto_engine.encrypt_packet(&quicly_default_crypto_engine, NULL, egress.header_protection, egress.aead,\n                                                ptls_iovec_init(datagram, datagram_len), 0, payload_from - (uint8_t *)datagram, 0,\n                                                0);\n\n    dispose_cipher(&egress);\n    return datagram_len;\n}\n\nsize_t quicly_send_stateless_reset(quicly_context_t *ctx, const void *src_cid, void *payload)\n{\n    uint8_t *base = payload;\n\n    /* build stateless reset packet */\n    ctx->tls->random_bytes(base, QUICLY_STATELESS_RESET_PACKET_MIN_LEN - QUICLY_STATELESS_RESET_TOKEN_LEN);\n    base[0] = (base[0] & ~QUICLY_LONG_HEADER_BIT) | QUICLY_QUIC_BIT;\n    if (!ctx->cid_encryptor->generate_stateless_reset_token(\n            ctx->cid_encryptor, base + QUICLY_STATELESS_RESET_PACKET_MIN_LEN - QUICLY_STATELESS_RESET_TOKEN_LEN, src_cid))\n        return SIZE_MAX;\n\n    return QUICLY_STATELESS_RESET_PACKET_MIN_LEN;\n}\n\nint quicly_send_resumption_token(quicly_conn_t *conn)\n{\n    if (conn->super.state <= QUICLY_STATE_CONNECTED) {\n        ++conn->egress.new_token.generation;\n        conn->egress.pending_flows |= QUICLY_PENDING_FLOW_NEW_TOKEN_BIT;\n    }\n    return 0;\n}\n\nstatic int on_end_closing(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    /* we stop accepting frames by the time this ack callback is being registered */\n    assert(!acked);\n    return 0;\n}\n\nstatic int enter_close(quicly_conn_t *conn, int local_is_initiating, int wait_draining)\n{\n    int ret;\n\n    assert(conn->super.state < QUICLY_STATE_CLOSING);\n\n    /* release all inflight info, register a close timeout */\n    if ((ret = discard_sentmap_by_epoch(conn, ~0u)) != 0)\n        return ret;\n    if ((ret = quicly_sentmap_prepare(&conn->egress.loss.sentmap, conn->egress.packet_number, conn->stash.now,\n                                      QUICLY_EPOCH_INITIAL)) != 0)\n        return ret;\n    if (quicly_sentmap_allocate(&conn->egress.loss.sentmap, on_end_closing) == NULL)\n        return PTLS_ERROR_NO_MEMORY;\n    quicly_sentmap_commit(&conn->egress.loss.sentmap, 0);\n    ++conn->egress.packet_number;\n\n    if (local_is_initiating) {\n        conn->super.state = QUICLY_STATE_CLOSING;\n        conn->egress.send_ack_at = 0;\n    } else {\n        conn->super.state = QUICLY_STATE_DRAINING;\n        conn->egress.send_ack_at = wait_draining ? conn->stash.now + get_sentmap_expiration_time(conn) : 0;\n    }\n\n    setup_next_send(conn);\n\n    return 0;\n}\n\nint initiate_close(quicly_conn_t *conn, int err, uint64_t frame_type, const char *reason_phrase)\n{\n    uint16_t quic_error_code;\n\n    if (conn->super.state >= QUICLY_STATE_CLOSING)\n        return 0;\n\n    if (reason_phrase == NULL)\n        reason_phrase = \"\";\n\n    /* convert error code to QUIC error codes */\n    if (err == 0) {\n        quic_error_code = 0;\n        frame_type = QUICLY_FRAME_TYPE_PADDING;\n    } else if (QUICLY_ERROR_IS_QUIC_TRANSPORT(err)) {\n        quic_error_code = QUICLY_ERROR_GET_ERROR_CODE(err);\n    } else if (QUICLY_ERROR_IS_QUIC_APPLICATION(err)) {\n        quic_error_code = QUICLY_ERROR_GET_ERROR_CODE(err);\n        frame_type = UINT64_MAX;\n    } else if (PTLS_ERROR_GET_CLASS(err) == PTLS_ERROR_CLASS_SELF_ALERT) {\n        quic_error_code = QUICLY_TRANSPORT_ERROR_TLS_ALERT_BASE + PTLS_ERROR_TO_ALERT(err);\n    } else {\n        quic_error_code = QUICLY_ERROR_GET_ERROR_CODE(QUICLY_TRANSPORT_ERROR_INTERNAL);\n    }\n\n    conn->egress.connection_close.error_code = quic_error_code;\n    conn->egress.connection_close.frame_type = frame_type;\n    conn->egress.connection_close.reason_phrase = reason_phrase;\n    return enter_close(conn, 1, 0);\n}\n\nint quicly_close(quicly_conn_t *conn, int err, const char *reason_phrase)\n{\n    int ret;\n\n    assert(err == 0 || QUICLY_ERROR_IS_QUIC_APPLICATION(err) || QUICLY_ERROR_IS_CONCEALED(err));\n\n    lock_now(conn, 1);\n    ret = initiate_close(conn, err, QUICLY_FRAME_TYPE_PADDING /* used when err == 0 */, reason_phrase);\n    unlock_now(conn);\n\n    return ret;\n}\n\nint quicly_get_or_open_stream(quicly_conn_t *conn, uint64_t stream_id, quicly_stream_t **stream)\n{\n    int ret = 0;\n\n    if ((*stream = quicly_get_stream(conn, stream_id)) != NULL)\n        goto Exit;\n\n    if (quicly_stream_is_client_initiated(stream_id) != quicly_is_client(conn)) {\n        /* check if stream id is within the bounds */\n        if (stream_id / 4 >= quicly_get_ingress_max_streams(conn, quicly_stream_is_unidirectional(stream_id))) {\n            ret = QUICLY_TRANSPORT_ERROR_STREAM_LIMIT;\n            goto Exit;\n        }\n        /* open new streams upto given id */\n        struct st_quicly_conn_streamgroup_state_t *group = get_streamgroup_state(conn, stream_id);\n        if (group->next_stream_id <= stream_id) {\n            uint64_t max_stream_data_local, max_stream_data_remote;\n            if (quicly_stream_is_unidirectional(stream_id)) {\n                max_stream_data_local = conn->super.ctx->transport_params.max_stream_data.uni;\n                max_stream_data_remote = 0;\n            } else {\n                max_stream_data_local = conn->super.ctx->transport_params.max_stream_data.bidi_remote;\n                max_stream_data_remote = conn->super.remote.transport_params.max_stream_data.bidi_local;\n            }\n            do {\n                if ((*stream = open_stream(conn, group->next_stream_id, (uint32_t)max_stream_data_local, max_stream_data_remote)) ==\n                    NULL) {\n                    ret = PTLS_ERROR_NO_MEMORY;\n                    goto Exit;\n                }\n                QUICLY_PROBE(STREAM_ON_OPEN, conn, conn->stash.now, *stream);\n                QUICLY_LOG_CONN(stream_on_open, conn, { PTLS_LOG_ELEMENT_SIGNED(stream_id, (*stream)->stream_id); });\n                if ((ret = conn->super.ctx->stream_open->cb(conn->super.ctx->stream_open, *stream)) != 0) {\n                    *stream = NULL;\n                    goto Exit;\n                }\n                ++group->num_streams;\n                group->next_stream_id += 4;\n            } while (stream_id != (*stream)->stream_id);\n        }\n    }\n\nExit:\n    return ret;\n}\n\nstatic int handle_crypto_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_stream_frame_t frame;\n    quicly_stream_t *stream;\n    int ret;\n\n    if ((ret = quicly_decode_crypto_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n    stream = quicly_get_stream(conn, -(quicly_stream_id_t)(1 + state->epoch));\n    assert(stream != NULL);\n    return apply_stream_frame(stream, &frame);\n}\n\nstatic int handle_stream_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_stream_frame_t frame;\n    quicly_stream_t *stream;\n    int ret;\n\n    if ((ret = quicly_decode_stream_frame(state->frame_type, &state->src, state->end, &frame)) != 0)\n        return ret;\n    QUICLY_PROBE(QUICTRACE_RECV_STREAM, conn, conn->stash.now, frame.stream_id, frame.offset, frame.data.len, (int)frame.is_fin);\n    if ((ret = quicly_get_or_open_stream(conn, frame.stream_id, &stream)) != 0 || stream == NULL)\n        return ret;\n    return apply_stream_frame(stream, &frame);\n}\n\nstatic int handle_reset_stream_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_reset_stream_frame_t frame;\n    quicly_stream_t *stream;\n    int ret;\n\n    if ((ret = quicly_decode_reset_stream_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n    QUICLY_PROBE(RESET_STREAM_RECEIVE, conn, conn->stash.now, frame.stream_id, frame.app_error_code, frame.final_size);\n    QUICLY_LOG_CONN(reset_stream_receive, conn, {\n        PTLS_LOG_ELEMENT_SIGNED(stream_id, (quicly_stream_id_t)frame.stream_id);\n        PTLS_LOG_ELEMENT_UNSIGNED(app_error_code, frame.app_error_code);\n        PTLS_LOG_ELEMENT_UNSIGNED(final_size, frame.final_size);\n    });\n\n    if ((ret = quicly_get_or_open_stream(conn, frame.stream_id, &stream)) != 0 || stream == NULL)\n        return ret;\n\n    if (!quicly_recvstate_transfer_complete(&stream->recvstate)) {\n        uint64_t bytes_missing;\n        if ((ret = quicly_recvstate_reset(&stream->recvstate, frame.final_size, &bytes_missing)) != 0)\n            return ret;\n        stream->conn->ingress.max_data.bytes_consumed += bytes_missing;\n        int err = QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE(frame.app_error_code);\n        QUICLY_PROBE(STREAM_ON_RECEIVE_RESET, stream->conn, stream->conn->stash.now, stream, err);\n        QUICLY_LOG_CONN(stream_on_receive_reset, stream->conn, {\n            PTLS_LOG_ELEMENT_SIGNED(stream_id, stream->stream_id);\n            PTLS_LOG_ELEMENT_SIGNED(err, err);\n        });\n        stream->callbacks->on_receive_reset(stream, err);\n        if (stream->conn->super.state >= QUICLY_STATE_CLOSING)\n            return QUICLY_ERROR_IS_CLOSING;\n        if (stream_is_destroyable(stream))\n            destroy_stream(stream, 0);\n    }\n\n    return 0;\n}\n\nstatic int handle_ack_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_ack_frame_t frame;\n    quicly_sentmap_iter_t iter;\n    struct {\n        uint64_t pn;\n        int64_t sent_at;\n    } largest_newly_acked = {UINT64_MAX, INT64_MAX};\n    size_t bytes_acked = 0;\n    int includes_ack_eliciting = 0, includes_late_ack = 0, ret;\n\n    if ((ret = quicly_decode_ack_frame(&state->src, state->end, &frame, state->frame_type == QUICLY_FRAME_TYPE_ACK_ECN)) != 0)\n        return ret;\n\n    uint64_t pn_acked = frame.smallest_acknowledged;\n\n    switch (state->epoch) {\n    case QUICLY_EPOCH_0RTT:\n        return QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;\n    case QUICLY_EPOCH_HANDSHAKE:\n        conn->super.remote.address_validation.send_probe = 0;\n        break;\n    default:\n        break;\n    }\n\n    if ((ret = init_acks_iter(conn, &iter)) != 0)\n        return ret;\n\n    /* TODO log PNs being ACKed too late */\n\n    size_t gap_index = frame.num_gaps;\n    while (1) {\n        assert(frame.ack_block_lengths[gap_index] != 0);\n        /* Ack blocks are organized in the ACK frame and consequently in the ack_block_lengths array from the largest acked down.\n         * Processing acks in packet number order requires processing the ack blocks in reverse order. */\n        uint64_t pn_block_max = pn_acked + frame.ack_block_lengths[gap_index] - 1;\n        QUICLY_PROBE(ACK_BLOCK_RECEIVED, conn, conn->stash.now, pn_acked, pn_block_max);\n        QUICLY_LOG_CONN(ack_block_received, conn, {\n            PTLS_LOG_ELEMENT_UNSIGNED(ack_block_begin, pn_acked);\n            PTLS_LOG_ELEMENT_UNSIGNED(ack_block_end, pn_block_max);\n        });\n        while (quicly_sentmap_get(&iter)->packet_number < pn_acked)\n            quicly_sentmap_skip(&iter);\n        do {\n            const quicly_sent_packet_t *sent = quicly_sentmap_get(&iter);\n            uint64_t pn_sent = sent->packet_number;\n            assert(pn_acked <= pn_sent);\n            if (pn_acked < pn_sent) {\n                /* set pn_acked to pn_sent; or past the end of the ack block, for use with the next ack block */\n                if (pn_sent <= pn_block_max) {\n                    pn_acked = pn_sent;\n                } else {\n                    pn_acked = pn_block_max + 1;\n                    break;\n                }\n            }\n            /* process newly acked packet */\n            if (state->epoch != sent->ack_epoch)\n                return QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;\n            int is_late_ack = 0;\n            if (sent->ack_eliciting) {\n                includes_ack_eliciting = 1;\n                if (sent->cc_bytes_in_flight == 0) {\n                    is_late_ack = 1;\n                    includes_late_ack = 1;\n                    ++conn->super.stats.num_packets.late_acked;\n                }\n            }\n            ++conn->super.stats.num_packets.ack_received;\n            largest_newly_acked.pn = pn_acked;\n            largest_newly_acked.sent_at = sent->sent_at;\n            QUICLY_PROBE(PACKET_ACKED, conn, conn->stash.now, pn_acked, is_late_ack);\n            QUICLY_LOG_CONN(packet_acked, conn, {\n                PTLS_LOG_ELEMENT_UNSIGNED(pn, pn_acked);\n                PTLS_LOG_ELEMENT_BOOL(is_late_ack, is_late_ack);\n            });\n            if (sent->cc_bytes_in_flight != 0) {\n                bytes_acked += sent->cc_bytes_in_flight;\n                conn->super.stats.num_bytes.ack_received += sent->cc_bytes_in_flight;\n            }\n            if ((ret = quicly_sentmap_update(&conn->egress.loss.sentmap, &iter, QUICLY_SENTMAP_EVENT_ACKED)) != 0)\n                return ret;\n            if (state->epoch == QUICLY_EPOCH_1RTT) {\n                struct st_quicly_application_space_t *space = conn->application;\n                if (space->cipher.egress.key_update_pn.last <= pn_acked) {\n                    space->cipher.egress.key_update_pn.last = UINT64_MAX;\n                    space->cipher.egress.key_update_pn.next = conn->egress.packet_number + conn->super.ctx->max_packets_per_key;\n                    QUICLY_PROBE(CRYPTO_SEND_KEY_UPDATE_CONFIRMED, conn, conn->stash.now, space->cipher.egress.key_update_pn.next);\n                    QUICLY_LOG_CONN(crypto_send_key_update_confirmed, conn,\n                                    { PTLS_LOG_ELEMENT_UNSIGNED(next_pn, space->cipher.egress.key_update_pn.next); });\n                }\n            }\n            ++pn_acked;\n        } while (pn_acked <= pn_block_max);\n        assert(pn_acked == pn_block_max + 1);\n        if (gap_index-- == 0)\n            break;\n        pn_acked += frame.gaps[gap_index];\n    }\n\n    if ((ret = on_ack_stream_ack_cached(conn)) != 0)\n        return ret;\n\n    QUICLY_PROBE(ACK_DELAY_RECEIVED, conn, conn->stash.now, frame.ack_delay);\n    QUICLY_LOG_CONN(ack_delay_received, conn, { PTLS_LOG_ELEMENT_UNSIGNED(ack_delay, frame.ack_delay); });\n\n    quicly_ratemeter_on_ack(&conn->egress.ratemeter, conn->stash.now, conn->super.stats.num_bytes.ack_received,\n                            largest_newly_acked.pn);\n\n    /* Update loss detection engine on ack. The function uses ack_delay only when the largest_newly_acked is also the largest acked\n     * so far. So, it does not matter if the ack_delay being passed in does not apply to the largest_newly_acked. */\n    quicly_loss_on_ack_received(&conn->egress.loss, largest_newly_acked.pn, state->epoch, conn->stash.now,\n                                largest_newly_acked.sent_at, frame.ack_delay,\n                                includes_ack_eliciting ? includes_late_ack ? QUICLY_LOSS_ACK_RECEIVED_KIND_ACK_ELICITING_LATE_ACK\n                                                                           : QUICLY_LOSS_ACK_RECEIVED_KIND_ACK_ELICITING\n                                                       : QUICLY_LOSS_ACK_RECEIVED_KIND_NON_ACK_ELICITING);\n\n    /* OnPacketAcked and OnPacketAckedCC */\n    if (bytes_acked > 0) {\n        conn->egress.cc.type->cc_on_acked(&conn->egress.cc, &conn->egress.loss, (uint32_t)bytes_acked, frame.largest_acknowledged,\n                                          (uint32_t)(conn->egress.loss.sentmap.bytes_in_flight + bytes_acked),\n                                          conn->egress.packet_number, conn->stash.now, conn->egress.max_udp_payload_size);\n        QUICLY_PROBE(QUICTRACE_CC_ACK, conn, conn->stash.now, &conn->egress.loss.rtt, conn->egress.cc.cwnd,\n                     conn->egress.loss.sentmap.bytes_in_flight);\n    }\n\n    QUICLY_PROBE(CC_ACK_RECEIVED, conn, conn->stash.now, frame.largest_acknowledged, bytes_acked, conn->egress.cc.cwnd,\n                 conn->egress.loss.sentmap.bytes_in_flight);\n    QUICLY_LOG_CONN(cc_ack_received, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(largest_acked, frame.largest_acknowledged);\n        PTLS_LOG_ELEMENT_UNSIGNED(bytes_acked, bytes_acked);\n        PTLS_LOG_ELEMENT_UNSIGNED(cwnd, conn->egress.cc.cwnd);\n        PTLS_LOG_ELEMENT_UNSIGNED(inflight, conn->egress.loss.sentmap.bytes_in_flight);\n    });\n\n    /* loss-detection  */\n    if ((ret = quicly_loss_detect_loss(&conn->egress.loss, conn->stash.now, conn->super.remote.transport_params.max_ack_delay,\n                                       conn->initial == NULL && conn->handshake == NULL, on_loss_detected)) != 0)\n        return ret;\n\n    /* ECN */\n    if (conn->egress.ecn.state != QUICLY_ECN_OFF && largest_newly_acked.pn != UINT64_MAX) {\n        /* if things look suspicious (ECT(1) count becoming non-zero), turn ECN off */\n        if (frame.ecn_counts[1] != 0)\n            update_ecn_state(conn, QUICLY_ECN_OFF);\n        /* TODO: maybe compare num_packets.acked vs. sum(ecn_counts) to see if any packet has been received as NON-ECT? */\n\n        /* ECN validation succeeds if at least one packet is acked using one of the expected marks during the probing period */\n        if (conn->egress.ecn.state == QUICLY_ECN_PROBING && frame.ecn_counts[0] + frame.ecn_counts[2] > 0)\n            update_ecn_state(conn, QUICLY_ECN_ON);\n\n        /* check if congestion should be reported */\n        int report_congestion =\n            conn->egress.ecn.state != QUICLY_ECN_OFF && frame.ecn_counts[2] > conn->egress.ecn.counts[state->epoch][2];\n\n        /* update counters */\n        for (size_t i = 0; i < PTLS_ELEMENTSOF(frame.ecn_counts); ++i) {\n            if (frame.ecn_counts[i] > conn->egress.ecn.counts[state->epoch][i]) {\n                conn->super.stats.num_packets.acked_ecn_counts[i] += frame.ecn_counts[i] - conn->egress.ecn.counts[state->epoch][i];\n                conn->egress.ecn.counts[state->epoch][i] = frame.ecn_counts[i];\n            }\n        }\n\n        /* report congestion */\n        if (report_congestion) {\n            QUICLY_PROBE(ECN_CONGESTION, conn, conn->stash.now, conn->super.stats.num_packets.acked_ecn_counts[2]);\n            QUICLY_LOG_CONN(ecn_congestion, conn,\n                            { PTLS_LOG_ELEMENT_UNSIGNED(ce_count, conn->super.stats.num_packets.acked_ecn_counts[2]); });\n            notify_congestion_to_cc(conn, 0, largest_newly_acked.pn);\n        }\n    }\n\n    setup_next_send(conn);\n\n    return 0;\n}\n\nstatic int handle_max_stream_data_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_max_stream_data_frame_t frame;\n    quicly_stream_t *stream;\n    int ret;\n\n    if ((ret = quicly_decode_max_stream_data_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n\n    QUICLY_PROBE(MAX_STREAM_DATA_RECEIVE, conn, conn->stash.now, frame.stream_id, frame.max_stream_data);\n    QUICLY_LOG_CONN(max_stream_data_receive, conn, {\n        PTLS_LOG_ELEMENT_SIGNED(stream_id, (quicly_stream_id_t)frame.stream_id);\n        PTLS_LOG_ELEMENT_UNSIGNED(max_stream_data, frame.max_stream_data);\n    });\n\n    if (!quicly_stream_has_send_side(quicly_is_client(conn), frame.stream_id))\n        return QUICLY_TRANSPORT_ERROR_FRAME_ENCODING;\n\n    if ((stream = quicly_get_stream(conn, frame.stream_id)) == NULL)\n        return 0;\n\n    if (frame.max_stream_data <= stream->_send_aux.max_stream_data)\n        return 0;\n    stream->_send_aux.max_stream_data = frame.max_stream_data;\n    stream->_send_aux.blocked = QUICLY_SENDER_STATE_NONE;\n\n    if (stream->_send_aux.reset_stream.sender_state == QUICLY_SENDER_STATE_NONE)\n        resched_stream_data(stream);\n\n    return 0;\n}\n\nstatic int handle_data_blocked_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_data_blocked_frame_t frame;\n    int ret;\n\n    if ((ret = quicly_decode_data_blocked_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n\n    QUICLY_PROBE(DATA_BLOCKED_RECEIVE, conn, conn->stash.now, frame.offset);\n    QUICLY_LOG_CONN(data_blocked_receive, conn, { PTLS_LOG_ELEMENT_UNSIGNED(off, frame.offset); });\n\n    quicly_maxsender_request_transmit(&conn->ingress.max_data.sender);\n    if (should_send_max_data(conn))\n        conn->egress.pending_flows |= QUICLY_PENDING_FLOW_OTHERS_BIT;\n\n    return 0;\n}\n\nstatic int handle_stream_data_blocked_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_stream_data_blocked_frame_t frame;\n    quicly_stream_t *stream;\n    int ret;\n\n    if ((ret = quicly_decode_stream_data_blocked_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n\n    QUICLY_PROBE(STREAM_DATA_BLOCKED_RECEIVE, conn, conn->stash.now, frame.stream_id, frame.offset);\n    QUICLY_LOG_CONN(stream_data_blocked_receive, conn, {\n        PTLS_LOG_ELEMENT_SIGNED(stream_id, frame.stream_id);\n        PTLS_LOG_ELEMENT_UNSIGNED(maximum, frame.offset);\n    });\n\n    if (!quicly_stream_has_receive_side(quicly_is_client(conn), frame.stream_id))\n        return QUICLY_TRANSPORT_ERROR_FRAME_ENCODING;\n\n    if ((stream = quicly_get_stream(conn, frame.stream_id)) != NULL) {\n        quicly_maxsender_request_transmit(&stream->_send_aux.max_stream_data_sender);\n        if (should_send_max_stream_data(stream))\n            sched_stream_control(stream);\n    }\n\n    return 0;\n}\n\nstatic int handle_streams_blocked_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_streams_blocked_frame_t frame;\n    int uni = state->frame_type == QUICLY_FRAME_TYPE_STREAMS_BLOCKED_UNI, ret;\n\n    if ((ret = quicly_decode_streams_blocked_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n\n    QUICLY_PROBE(STREAMS_BLOCKED_RECEIVE, conn, conn->stash.now, frame.count, uni);\n    QUICLY_LOG_CONN(streams_blocked_receive, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(maximum, frame.count);\n        PTLS_LOG_ELEMENT_BOOL(is_unidirectional, uni);\n    });\n\n    if (should_send_max_streams(conn, uni)) {\n        quicly_maxsender_t *maxsender = uni ? &conn->ingress.max_streams.uni : &conn->ingress.max_streams.bidi;\n        quicly_maxsender_request_transmit(maxsender);\n        conn->egress.pending_flows |= QUICLY_PENDING_FLOW_OTHERS_BIT;\n    }\n\n    return 0;\n}\n\nstatic int handle_max_streams_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state, int uni)\n{\n    quicly_max_streams_frame_t frame;\n    int ret;\n\n    if ((ret = quicly_decode_max_streams_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n\n    QUICLY_PROBE(MAX_STREAMS_RECEIVE, conn, conn->stash.now, frame.count, uni);\n    QUICLY_LOG_CONN(max_streams_receive, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(maximum, frame.count);\n        PTLS_LOG_ELEMENT_BOOL(is_unidirectional, uni);\n    });\n\n    if ((ret = update_max_streams(uni ? &conn->egress.max_streams.uni : &conn->egress.max_streams.bidi, frame.count)) != 0)\n        return ret;\n\n    open_blocked_streams(conn, uni);\n\n    return 0;\n}\n\nstatic int handle_max_streams_bidi_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    return handle_max_streams_frame(conn, state, 0);\n}\n\nstatic int handle_max_streams_uni_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    return handle_max_streams_frame(conn, state, 1);\n}\n\nstatic int handle_path_challenge_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_path_challenge_frame_t frame;\n    int ret;\n\n    if ((ret = quicly_decode_path_challenge_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n    return schedule_path_challenge_frame(conn, 1, frame.data);\n}\n\nstatic int handle_path_response_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    return QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;\n}\n\nstatic int handle_new_token_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_new_token_frame_t frame;\n    int ret;\n\n    if (!quicly_is_client(conn))\n        return QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;\n    if ((ret = quicly_decode_new_token_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n    QUICLY_PROBE(NEW_TOKEN_RECEIVE, conn, conn->stash.now, frame.token.base, frame.token.len);\n    QUICLY_LOG_CONN(new_token_receive, conn, { PTLS_LOG_ELEMENT_HEXDUMP(token, frame.token.base, frame.token.len); });\n    if (conn->super.ctx->save_resumption_token == NULL)\n        return 0;\n    return conn->super.ctx->save_resumption_token->cb(conn->super.ctx->save_resumption_token, conn, frame.token);\n}\n\nstatic int handle_stop_sending_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_stop_sending_frame_t frame;\n    quicly_stream_t *stream;\n    int ret;\n\n    if ((ret = quicly_decode_stop_sending_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n    QUICLY_PROBE(STOP_SENDING_RECEIVE, conn, conn->stash.now, frame.stream_id, frame.app_error_code);\n    QUICLY_LOG_CONN(stop_sending_receive, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(stream_id, (quicly_stream_id_t)frame.stream_id);\n        PTLS_LOG_ELEMENT_UNSIGNED(error_code, frame.app_error_code);\n    });\n\n    if ((ret = quicly_get_or_open_stream(conn, frame.stream_id, &stream)) != 0 || stream == NULL)\n        return ret;\n\n    if (quicly_sendstate_is_open(&stream->sendstate)) {\n        /* reset the stream, then notify the application */\n        int err = QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE(frame.app_error_code);\n        quicly_reset_stream(stream, err);\n        QUICLY_PROBE(STREAM_ON_SEND_STOP, stream->conn, stream->conn->stash.now, stream, err);\n        QUICLY_LOG_CONN(stream_on_send_stop, stream->conn, {\n            PTLS_LOG_ELEMENT_SIGNED(stream_id, stream->stream_id);\n            PTLS_LOG_ELEMENT_SIGNED(err, err);\n        });\n        stream->callbacks->on_send_stop(stream, err);\n        if (stream->conn->super.state >= QUICLY_STATE_CLOSING)\n            return QUICLY_ERROR_IS_CLOSING;\n    }\n\n    return 0;\n}\n\nstatic int handle_max_data_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_max_data_frame_t frame;\n    int ret;\n\n    if ((ret = quicly_decode_max_data_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n\n    QUICLY_PROBE(MAX_DATA_RECEIVE, conn, conn->stash.now, frame.max_data);\n    QUICLY_LOG_CONN(max_data_receive, conn, { PTLS_LOG_ELEMENT_UNSIGNED(maximum, frame.max_data); });\n\n    if (frame.max_data <= conn->egress.max_data.permitted)\n        return 0;\n    conn->egress.max_data.permitted = frame.max_data;\n    conn->egress.data_blocked = QUICLY_SENDER_STATE_NONE; /* DATA_BLOCKED has not been sent for the new limit */\n\n    return 0;\n}\n\nstatic int negotiate_using_version(quicly_conn_t *conn, uint32_t version)\n{\n    int ret;\n\n    /* set selected version, update transport parameters extension ID */\n    conn->super.version = version;\n    QUICLY_PROBE(VERSION_SWITCH, conn, conn->stash.now, version);\n    QUICLY_LOG_CONN(version_switch, conn, { PTLS_LOG_ELEMENT_UNSIGNED(new_version, version); });\n\n    /* replace initial keys */\n    if ((ret = reinstall_initial_encryption(conn, PTLS_ERROR_LIBRARY)) != 0)\n        return ret;\n\n    /* reschedule all the packets that have been sent for immediate resend */\n    if ((ret = discard_sentmap_by_epoch(conn, ~0u)) != 0)\n        return ret;\n\n    return 0;\n}\n\nstatic int handle_version_negotiation_packet(quicly_conn_t *conn, quicly_decoded_packet_t *packet)\n{\n    const uint8_t *src = packet->octets.base + packet->encrypted_off, *end = packet->octets.base + packet->octets.len;\n    uint32_t selected_version = 0;\n\n    if (src == end || (end - src) % 4 != 0)\n        return QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;\n\n    /* select in the precedence of V1 -> draft29 -> draft27 -> fail */\n    while (src != end) {\n        uint32_t supported_version = quicly_decode32(&src);\n        switch (supported_version) {\n        case QUICLY_PROTOCOL_VERSION_1:\n            selected_version = QUICLY_PROTOCOL_VERSION_1;\n            break;\n        case QUICLY_PROTOCOL_VERSION_DRAFT29:\n            if (selected_version == 0 || selected_version == QUICLY_PROTOCOL_VERSION_DRAFT27)\n                selected_version = QUICLY_PROTOCOL_VERSION_DRAFT29;\n            break;\n        case QUICLY_PROTOCOL_VERSION_DRAFT27:\n            if (selected_version == 0)\n                selected_version = QUICLY_PROTOCOL_VERSION_DRAFT27;\n            break;\n        }\n    }\n    if (selected_version == 0)\n        return handle_close(conn, QUICLY_ERROR_NO_COMPATIBLE_VERSION, UINT64_MAX, ptls_iovec_init(\"\", 0));\n\n    return negotiate_using_version(conn, selected_version);\n}\n\nstatic int compare_socket_address(struct sockaddr *x, struct sockaddr *y)\n{\n#define CMP(a, b)                                                                                                                  \\\n    if (a != b)                                                                                                                    \\\n    return a < b ? -1 : 1\n\n    CMP(x->sa_family, y->sa_family);\n\n    if (x->sa_family == AF_INET) {\n        struct sockaddr_in *xin = (void *)x, *yin = (void *)y;\n        CMP(ntohl(xin->sin_addr.s_addr), ntohl(yin->sin_addr.s_addr));\n        CMP(ntohs(xin->sin_port), ntohs(yin->sin_port));\n    } else if (x->sa_family == AF_INET6) {\n        struct sockaddr_in6 *xin6 = (void *)x, *yin6 = (void *)y;\n        int r = memcmp(xin6->sin6_addr.s6_addr, yin6->sin6_addr.s6_addr, sizeof(xin6->sin6_addr.s6_addr));\n        if (r != 0)\n            return r;\n        CMP(ntohs(xin6->sin6_port), ntohs(yin6->sin6_port));\n        CMP(xin6->sin6_scope_id, yin6->sin6_scope_id);\n    } else if (x->sa_family == AF_UNSPEC) {\n        return 1;\n    } else {\n        assert(!\"unknown sa_family\");\n    }\n\n#undef CMP\n    return 0;\n}\n\nstatic int is_stateless_reset(quicly_conn_t *conn, quicly_decoded_packet_t *decoded)\n{\n    switch (decoded->_is_stateless_reset_cached) {\n    case QUICLY__DECODED_PACKET_CACHED_IS_STATELESS_RESET:\n        return 1;\n    case QUICLY__DECODED_PACKET_CACHED_NOT_STATELESS_RESET:\n        return 0;\n    default:\n        break;\n    }\n\n    if (!conn->super.remote.cid_set.cids[0].is_active)\n        return 0;\n    if (decoded->octets.len < QUICLY_STATELESS_RESET_PACKET_MIN_LEN)\n        return 0;\n    if (memcmp(decoded->octets.base + decoded->octets.len - QUICLY_STATELESS_RESET_TOKEN_LEN,\n               conn->super.remote.cid_set.cids[0].stateless_reset_token, QUICLY_STATELESS_RESET_TOKEN_LEN) != 0)\n        return 0;\n\n    return 1;\n}\n\nint quicly_is_destination(quicly_conn_t *conn, struct sockaddr *dest_addr, struct sockaddr *src_addr,\n                          quicly_decoded_packet_t *decoded)\n{\n    if (QUICLY_PACKET_IS_LONG_HEADER(decoded->octets.base[0])) {\n        /* long header: validate address, then consult the CID */\n        if (compare_socket_address(&conn->super.remote.address.sa, src_addr) != 0)\n            return 0;\n        if (conn->super.local.address.sa.sa_family != AF_UNSPEC &&\n            compare_socket_address(&conn->super.local.address.sa, dest_addr) != 0)\n            return 0;\n        /* server may see the CID generated by the client for Initial and 0-RTT packets */\n        if (!quicly_is_client(conn) && decoded->cid.dest.might_be_client_generated) {\n            const quicly_cid_t *odcid = is_retry(conn) ? &conn->retry_scid : &conn->super.original_dcid;\n            if (quicly_cid_is_equal(odcid, decoded->cid.dest.encrypted))\n                goto Found;\n        }\n    }\n\n    if (conn->super.ctx->cid_encryptor != NULL) {\n        /* Note on multiple CIDs\n         * Multiple CIDs issued by this host are always based on the same 3-tuple (master_id, thread_id, node_id)\n         * and the only difference is path_id. Therefore comparing the 3-tuple is enough to cover all CIDs issued by\n         * this host.\n         */\n        if (conn->super.local.cid_set.plaintext.master_id == decoded->cid.dest.plaintext.master_id &&\n            conn->super.local.cid_set.plaintext.thread_id == decoded->cid.dest.plaintext.thread_id &&\n            conn->super.local.cid_set.plaintext.node_id == decoded->cid.dest.plaintext.node_id)\n            goto Found;\n        if (is_stateless_reset(conn, decoded))\n            goto Found_StatelessReset;\n    } else {\n        if (compare_socket_address(&conn->super.remote.address.sa, src_addr) == 0)\n            goto Found;\n        if (conn->super.local.address.sa.sa_family != AF_UNSPEC &&\n            compare_socket_address(&conn->super.local.address.sa, dest_addr) != 0)\n            return 0;\n    }\n\n    /* not found */\n    return 0;\n\nFound:\n    decoded->_is_stateless_reset_cached = QUICLY__DECODED_PACKET_CACHED_NOT_STATELESS_RESET;\n    return 1;\n\nFound_StatelessReset:\n    decoded->_is_stateless_reset_cached = QUICLY__DECODED_PACKET_CACHED_IS_STATELESS_RESET;\n    return 1;\n}\n\nint handle_close(quicly_conn_t *conn, int err, uint64_t frame_type, ptls_iovec_t reason_phrase)\n{\n    int ret;\n\n    if (conn->super.state >= QUICLY_STATE_CLOSING)\n        return 0;\n\n    /* switch to closing state, notify the app (at this moment the streams are accessible), then destroy the streams */\n    if ((ret = enter_close(conn, 0,\n                           !(err == QUICLY_ERROR_RECEIVED_STATELESS_RESET || err == QUICLY_ERROR_NO_COMPATIBLE_VERSION))) != 0)\n        return ret;\n    if (conn->super.ctx->closed_by_remote != NULL)\n        conn->super.ctx->closed_by_remote->cb(conn->super.ctx->closed_by_remote, conn, err, frame_type,\n                                              (const char *)reason_phrase.base, reason_phrase.len);\n    destroy_all_streams(conn, err, 0);\n\n    return 0;\n}\n\nstatic int handle_transport_close_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_transport_close_frame_t frame;\n    int ret;\n\n    if ((ret = quicly_decode_transport_close_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n\n    QUICLY_PROBE(TRANSPORT_CLOSE_RECEIVE, conn, conn->stash.now, frame.error_code, frame.frame_type,\n                 QUICLY_PROBE_ESCAPE_UNSAFE_STRING(frame.reason_phrase.base, frame.reason_phrase.len));\n    QUICLY_LOG_CONN(transport_close_receive, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(error_code, frame.error_code);\n        PTLS_LOG_ELEMENT_UNSIGNED(frame_type, frame.frame_type);\n        PTLS_LOG_ELEMENT_UNSAFESTR(reason_phrase, (const char *)frame.reason_phrase.base, frame.reason_phrase.len);\n    });\n    return handle_close(conn, QUICLY_ERROR_FROM_TRANSPORT_ERROR_CODE(frame.error_code), frame.frame_type, frame.reason_phrase);\n}\n\nstatic int handle_application_close_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_application_close_frame_t frame;\n    int ret;\n\n    if ((ret = quicly_decode_application_close_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n\n    QUICLY_PROBE(APPLICATION_CLOSE_RECEIVE, conn, conn->stash.now, frame.error_code,\n                 QUICLY_PROBE_ESCAPE_UNSAFE_STRING(frame.reason_phrase.base, frame.reason_phrase.len));\n    QUICLY_LOG_CONN(application_close_receive, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(error_code, frame.error_code);\n        PTLS_LOG_ELEMENT_UNSAFESTR(reason_phrase, (const char *)frame.reason_phrase.base, frame.reason_phrase.len);\n    });\n    return handle_close(conn, QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE(frame.error_code), UINT64_MAX, frame.reason_phrase);\n}\n\nstatic int handle_padding_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    return 0;\n}\n\nstatic int handle_ping_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    QUICLY_PROBE(PING_RECEIVE, conn, conn->stash.now);\n    QUICLY_LOG_CONN(ping_receive, conn, {});\n\n    return 0;\n}\n\nstatic int handle_new_connection_id_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    int ret;\n    quicly_new_connection_id_frame_t frame;\n\n    /* TODO: return error when using zero-length CID */\n\n    if ((ret = quicly_decode_new_connection_id_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n\n    QUICLY_PROBE(NEW_CONNECTION_ID_RECEIVE, conn, conn->stash.now, frame.sequence, frame.retire_prior_to,\n                 QUICLY_PROBE_HEXDUMP(frame.cid.base, frame.cid.len),\n                 QUICLY_PROBE_HEXDUMP(frame.stateless_reset_token, QUICLY_STATELESS_RESET_TOKEN_LEN));\n    QUICLY_LOG_CONN(new_connection_id_receive, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(sequence, frame.sequence);\n        PTLS_LOG_ELEMENT_UNSIGNED(retire_prior_to, frame.retire_prior_to);\n        PTLS_LOG_ELEMENT_HEXDUMP(cid, frame.cid.base, frame.cid.len);\n        PTLS_LOG_ELEMENT_HEXDUMP(stateless_reset_token, frame.stateless_reset_token, QUICLY_STATELESS_RESET_TOKEN_LEN);\n    });\n\n    if (frame.sequence < conn->super.remote.largest_retire_prior_to) {\n        /* An endpoint that receives a NEW_CONNECTION_ID frame with a sequence number smaller than the Retire Prior To\n         * field of a previously received NEW_CONNECTION_ID frame MUST send a corresponding RETIRE_CONNECTION_ID frame\n         * that retires the newly received connection ID, unless it has already done so for that sequence number. (19.15)\n         * TODO: \"unless ...\" part may not be properly addressed here (we may already have sent the RCID frame for this\n         * sequence) */\n        schedule_retire_connection_id_frame(conn, frame.sequence);\n        /* do not install this CID */\n        return 0;\n    }\n\n    uint64_t unregistered_seqs[QUICLY_LOCAL_ACTIVE_CONNECTION_ID_LIMIT];\n    size_t num_unregistered_seqs;\n    if ((ret = quicly_remote_cid_register(&conn->super.remote.cid_set, frame.sequence, frame.cid.base, frame.cid.len,\n                                          frame.stateless_reset_token, frame.retire_prior_to, unregistered_seqs,\n                                          &num_unregistered_seqs)) != 0)\n        return ret;\n\n    for (size_t i = 0; i < num_unregistered_seqs; i++)\n        schedule_retire_connection_id_frame(conn, unregistered_seqs[i]);\n\n    if (frame.retire_prior_to > conn->super.remote.largest_retire_prior_to)\n        conn->super.remote.largest_retire_prior_to = frame.retire_prior_to;\n\n    return 0;\n}\n\nstatic int handle_retire_connection_id_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    int ret, has_pending;\n    quicly_retire_connection_id_frame_t frame;\n\n    if ((ret = quicly_decode_retire_connection_id_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n\n    QUICLY_PROBE(RETIRE_CONNECTION_ID_RECEIVE, conn, conn->stash.now, frame.sequence);\n    QUICLY_LOG_CONN(retire_connection_id_receive, conn, { PTLS_LOG_ELEMENT_UNSIGNED(sequence, frame.sequence); });\n\n    if (frame.sequence >= conn->super.local.cid_set.plaintext.path_id) {\n        /* Receipt of a RETIRE_CONNECTION_ID frame containing a sequence number greater than any previously sent to the remote peer\n         * MUST be treated as a connection error of type PROTOCOL_VIOLATION. (19.16) */\n        return QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;\n    }\n\n    if ((ret = quicly_local_cid_retire(&conn->super.local.cid_set, frame.sequence, &has_pending)) != 0)\n        return ret;\n    if (has_pending)\n        conn->egress.pending_flows |= QUICLY_PENDING_FLOW_OTHERS_BIT;\n\n    return 0;\n}\n\nstatic int handle_handshake_done_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    int ret;\n\n    QUICLY_PROBE(HANDSHAKE_DONE_RECEIVE, conn, conn->stash.now);\n    QUICLY_LOG_CONN(handshake_done_receive, conn, {});\n\n    if (!quicly_is_client(conn))\n        return QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;\n\n    assert(conn->initial == NULL);\n    if (conn->handshake == NULL)\n        return 0;\n\n    conn->super.remote.address_validation.send_probe = 0;\n    if ((ret = discard_handshake_context(conn, QUICLY_EPOCH_HANDSHAKE)) != 0)\n        return ret;\n    setup_next_send(conn);\n    return 0;\n}\n\nstatic int handle_datagram_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_datagram_frame_t frame;\n    int ret;\n\n    /* check if we advertised support for DATAGRAM frames on this connection */\n    if (conn->super.ctx->transport_params.max_datagram_frame_size == 0)\n        return QUICLY_TRANSPORT_ERROR_FRAME_ENCODING;\n\n    /* decode the frame */\n    if ((ret = quicly_decode_datagram_frame(state->frame_type, &state->src, state->end, &frame)) != 0)\n        return ret;\n    QUICLY_PROBE(DATAGRAM_RECEIVE, conn, conn->stash.now, frame.payload.base, frame.payload.len);\n    QUICLY_LOG_CONN(datagram_receive, conn, { PTLS_LOG_ELEMENT_UNSIGNED(payload_len, frame.payload.len); });\n\n    /* handle the frame. Applications might call quicly_close or other functions that modify the connection state. */\n    conn->super.ctx->receive_datagram_frame->cb(conn->super.ctx->receive_datagram_frame, conn, frame.payload);\n\n    return 0;\n}\n\nstatic int handle_ack_frequency_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_ack_frequency_frame_t frame;\n    int ret;\n\n    /* recognize the frame only when the support has been advertised */\n    if (conn->super.ctx->transport_params.min_ack_delay_usec == UINT64_MAX)\n        return QUICLY_TRANSPORT_ERROR_FRAME_ENCODING;\n\n    if ((ret = quicly_decode_ack_frequency_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n\n    QUICLY_PROBE(ACK_FREQUENCY_RECEIVE, conn, conn->stash.now, frame.sequence, frame.packet_tolerance, frame.max_ack_delay,\n                 (int)frame.ignore_order, (int)frame.ignore_ce);\n    QUICLY_LOG_CONN(ack_frequency_receive, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(sequence, frame.sequence);\n        PTLS_LOG_ELEMENT_UNSIGNED(packet_tolerance, frame.packet_tolerance);\n        PTLS_LOG_ELEMENT_UNSIGNED(max_ack_delay, frame.max_ack_delay);\n        PTLS_LOG_ELEMENT_SIGNED(ignore_order, (int)frame.ignore_order);\n        PTLS_LOG_ELEMENT_SIGNED(ignore_ce, (int)frame.ignore_ce);\n    });\n\n    /* Reject Request Max Ack Delay below our TP.min_ack_delay (which is at the moment equal to LOCAL_MAX_ACK_DELAY). */\n    if (frame.max_ack_delay < QUICLY_LOCAL_MAX_ACK_DELAY * 1000)\n        return QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;\n\n    if (frame.sequence >= conn->ingress.ack_frequency.next_sequence) {\n        conn->ingress.ack_frequency.next_sequence = frame.sequence + 1;\n        conn->application->super.packet_tolerance =\n            (uint32_t)(frame.packet_tolerance < QUICLY_MAX_PACKET_TOLERANCE ? frame.packet_tolerance : QUICLY_MAX_PACKET_TOLERANCE);\n        conn->application->super.ignore_order = frame.ignore_order;\n    }\n\n    return 0;\n}\n\nstatic int handle_payload(quicly_conn_t *conn, size_t epoch, const uint8_t *_src, size_t _len, uint64_t *offending_frame_type,\n                          int *is_ack_only)\n{\n    /* clang-format off */\n\n    /* `frame_handlers` is an array of frame handlers and the properties of the frames, indexed by the ID of the frame. */\n    static const struct st_quicly_frame_handler_t {\n        int (*cb)(quicly_conn_t *, struct st_quicly_handle_payload_state_t *); /* callback function that handles the frame */\n        uint8_t permitted_epochs;  /* the epochs the frame can appear, calculated as bitwise-or of `1 << epoch` */\n        uint8_t ack_eliciting;     /* boolean indicating if the frame is ack-eliciting */\n        size_t counter_offset;     /* offset of corresponding `conn->super.stats.num_frames_received.type` within quicly_conn_t */\n    } frame_handlers[] = {\n#define FRAME(n, i, z, h, o, ae)                                                                                                   \\\n    {                                                                                                                              \\\n        handle_##n##_frame,                                                                                                        \\\n        (i << QUICLY_EPOCH_INITIAL) | (z << QUICLY_EPOCH_0RTT) | (h << QUICLY_EPOCH_HANDSHAKE) | (o << QUICLY_EPOCH_1RTT),         \\\n        ae,                                                                                                                        \\\n        offsetof(quicly_conn_t, super.stats.num_frames_received.n)                                                                 \\\n    }\n        /*   +----------------------+-------------------+---------------+\n         *   |                      |  permitted epochs |               |\n         *   |        frame         +----+----+----+----+ ack-eliciting |\n         *   |                      | IN | 0R | HS | 1R |               |\n         *   +----------------------+----+----+----+----+---------------+ */\n        FRAME( padding              ,  1 ,  1 ,  1 ,  1 ,             0 ), /* 0 */\n        FRAME( ping                 ,  1 ,  1 ,  1 ,  1 ,             1 ),\n        FRAME( ack                  ,  1 ,  0 ,  1 ,  1 ,             0 ),\n        FRAME( ack                  ,  1 ,  0 ,  1 ,  1 ,             0 ),\n        FRAME( reset_stream         ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( stop_sending         ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( crypto               ,  1 ,  0 ,  1 ,  1 ,             1 ),\n        FRAME( new_token            ,  0 ,  0 ,  0 ,  1 ,             1 ),\n        FRAME( stream               ,  0 ,  1 ,  0 ,  1 ,             1 ), /* 8 */\n        FRAME( stream               ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( stream               ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( stream               ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( stream               ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( stream               ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( stream               ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( stream               ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( max_data             ,  0 ,  1 ,  0 ,  1 ,             1 ), /* 16 */\n        FRAME( max_stream_data      ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( max_streams_bidi     ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( max_streams_uni      ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( data_blocked         ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( stream_data_blocked  ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( streams_blocked      ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( streams_blocked      ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( new_connection_id    ,  0 ,  1 ,  0 ,  1 ,             1 ), /* 24 */\n        FRAME( retire_connection_id ,  0 ,  0 ,  0 ,  1 ,             1 ),\n        FRAME( path_challenge       ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( path_response        ,  0 ,  0 ,  0 ,  1 ,             1 ),\n        FRAME( transport_close      ,  1 ,  1 ,  1 ,  1 ,             0 ),\n        FRAME( application_close    ,  0 ,  1 ,  0 ,  1 ,             0 ),\n        FRAME( handshake_done       ,  0,   0 ,  0 ,  1 ,             1 ),\n        /*   +----------------------+----+----+----+----+---------------+ */\n#undef FRAME\n    };\n    static const struct {\n        uint64_t type;\n        struct st_quicly_frame_handler_t _;\n    } ex_frame_handlers[] = {\n#define FRAME(uc, lc, i, z, h, o, ae)                                                                                              \\\n    {                                                                                                                              \\\n        QUICLY_FRAME_TYPE_##uc,                                                                                                    \\\n        {                                                                                                                          \\\n            handle_##lc##_frame,                                                                                                   \\\n            (i << QUICLY_EPOCH_INITIAL) | (z << QUICLY_EPOCH_0RTT) | (h << QUICLY_EPOCH_HANDSHAKE) | (o << QUICLY_EPOCH_1RTT),     \\\n            ae,                                                                                                                    \\\n            offsetof(quicly_conn_t, super.stats.num_frames_received.lc) \\\n        },                                                                                                                         \\\n    }\n        /*   +----------------------------------+-------------------+---------------+\n         *   |               frame              |  permitted epochs |               |\n         *   |------------------+---------------+----+----+----+----+ ack-eliciting |\n         *   |    upper-case    |  lower-case   | IN | 0R | HS | 1R |               |\n         *   +------------------+---------------+----+----+----+----+---------------+ */\n        FRAME( DATAGRAM_NOLEN   , datagram      ,  0 ,  1,   0,   1 ,             1 ),\n        FRAME( DATAGRAM_WITHLEN , datagram      ,  0 ,  1,   0,   1 ,             1 ),\n        FRAME( ACK_FREQUENCY    , ack_frequency ,  0 ,  0 ,  0 ,  1 ,             1 ),\n        /*   +------------------+---------------+-------------------+---------------+ */\n#undef FRAME\n        {UINT64_MAX},\n    };\n    /* clang-format on */\n\n    struct st_quicly_handle_payload_state_t state = {_src, _src + _len, epoch};\n    size_t num_frames_ack_eliciting = 0;\n    int ret;\n\n    do {\n        /* determine the frame type; fast path is available for frame types below 64 */\n        const struct st_quicly_frame_handler_t *frame_handler;\n        state.frame_type = *state.src++;\n        if (state.frame_type < PTLS_ELEMENTSOF(frame_handlers)) {\n            frame_handler = frame_handlers + state.frame_type;\n        } else {\n            /* slow path */\n            --state.src;\n            if ((state.frame_type = quicly_decodev(&state.src, state.end)) == UINT64_MAX) {\n                state.frame_type =\n                    QUICLY_FRAME_TYPE_PADDING; /* we cannot signal the offending frame type when failing to decode the frame type */\n                ret = QUICLY_TRANSPORT_ERROR_FRAME_ENCODING;\n                break;\n            }\n            size_t i;\n            for (i = 0; ex_frame_handlers[i].type < state.frame_type; ++i)\n                ;\n            if (ex_frame_handlers[i].type != state.frame_type) {\n                ret = QUICLY_TRANSPORT_ERROR_FRAME_ENCODING; /* not found */\n                break;\n            }\n            frame_handler = &ex_frame_handlers[i]._;\n        }\n        /* check if frame is allowed, then process */\n        if ((frame_handler->permitted_epochs & (1 << epoch)) == 0) {\n            ret = QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;\n            break;\n        }\n        ++*(uint64_t *)((uint8_t *)conn + frame_handler->counter_offset);\n        num_frames_ack_eliciting += frame_handler->ack_eliciting;\n        if ((ret = frame_handler->cb(conn, &state)) != 0)\n            break;\n    } while (state.src != state.end);\n\n    *is_ack_only = num_frames_ack_eliciting == 0;\n    if (ret != 0)\n        *offending_frame_type = state.frame_type;\n    return ret;\n}\n\nstatic int handle_stateless_reset(quicly_conn_t *conn)\n{\n    QUICLY_PROBE(STATELESS_RESET_RECEIVE, conn, conn->stash.now);\n    QUICLY_LOG_CONN(stateless_reset_receive, conn, {});\n    return handle_close(conn, QUICLY_ERROR_RECEIVED_STATELESS_RESET, UINT64_MAX, ptls_iovec_init(\"\", 0));\n}\n\nstatic int validate_retry_tag(quicly_decoded_packet_t *packet, quicly_cid_t *odcid, ptls_aead_context_t *retry_aead)\n{\n    size_t pseudo_packet_len = 1 + odcid->len + packet->encrypted_off;\n    uint8_t pseudo_packet[pseudo_packet_len];\n    pseudo_packet[0] = odcid->len;\n    memcpy(pseudo_packet + 1, odcid->cid, odcid->len);\n    memcpy(pseudo_packet + 1 + odcid->len, packet->octets.base, packet->encrypted_off);\n    return ptls_aead_decrypt(retry_aead, packet->octets.base + packet->encrypted_off, packet->octets.base + packet->encrypted_off,\n                             PTLS_AESGCM_TAG_SIZE, 0, pseudo_packet, pseudo_packet_len) == 0;\n}\n\nint quicly_accept(quicly_conn_t **conn, quicly_context_t *ctx, struct sockaddr *dest_addr, struct sockaddr *src_addr,\n                  quicly_decoded_packet_t *packet, quicly_address_token_plaintext_t *address_token,\n                  const quicly_cid_plaintext_t *new_cid, ptls_handshake_properties_t *handshake_properties, void *appdata)\n{\n    const struct st_ptls_salt_t *salt;\n    struct {\n        struct st_quicly_cipher_context_t ingress, egress;\n        int alive;\n    } cipher = {};\n    ptls_iovec_t payload;\n    uint64_t next_expected_pn, pn, offending_frame_type = QUICLY_FRAME_TYPE_PADDING;\n    int is_ack_only, ret;\n\n    *conn = NULL;\n\n    /* process initials only */\n    if ((packet->octets.base[0] & QUICLY_PACKET_TYPE_BITMASK) != QUICLY_PACKET_TYPE_INITIAL) {\n        ret = QUICLY_ERROR_PACKET_IGNORED;\n        goto Exit;\n    }\n    if ((salt = get_salt(packet->version)) == NULL) {\n        ret = QUICLY_ERROR_PACKET_IGNORED;\n        goto Exit;\n    }\n    if (packet->datagram_size < QUICLY_MIN_CLIENT_INITIAL_SIZE) {\n        ret = QUICLY_ERROR_PACKET_IGNORED;\n        goto Exit;\n    }\n    if (packet->cid.dest.encrypted.len < 8) {\n        ret = QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;\n        goto Exit;\n    }\n    if ((ret = setup_initial_encryption(get_aes128gcmsha256(ctx), &cipher.ingress, &cipher.egress, packet->cid.dest.encrypted, 0,\n                                        ptls_iovec_init(salt->initial, sizeof(salt->initial)), NULL)) != 0)\n        goto Exit;\n    cipher.alive = 1;\n    next_expected_pn = 0; /* is this correct? do we need to take care of underflow? */\n    if ((ret = decrypt_packet(cipher.ingress.header_protection, aead_decrypt_fixed_key, cipher.ingress.aead, &next_expected_pn,\n                              packet, &pn, &payload)) != 0) {\n        ret = QUICLY_ERROR_DECRYPTION_FAILED;\n        goto Exit;\n    }\n\n    /* create connection */\n    if ((*conn = create_connection(\n             ctx, packet->version, NULL, src_addr, dest_addr, &packet->cid.src, new_cid, handshake_properties, appdata,\n             quicly_cc_calc_initial_cwnd(ctx->initcwnd_packets, ctx->transport_params.max_udp_payload_size))) == NULL) {\n        ret = PTLS_ERROR_NO_MEMORY;\n        goto Exit;\n    }\n    (*conn)->super.state = QUICLY_STATE_ACCEPTING;\n    quicly_set_cid(&(*conn)->super.original_dcid, packet->cid.dest.encrypted);\n    if (address_token != NULL) {\n        (*conn)->super.remote.address_validation.validated = 1;\n        if (address_token->type == QUICLY_ADDRESS_TOKEN_TYPE_RETRY) {\n            (*conn)->retry_scid = (*conn)->super.original_dcid;\n            (*conn)->super.original_dcid = address_token->retry.original_dcid;\n        }\n    }\n    if ((ret = setup_handshake_space_and_flow(*conn, QUICLY_EPOCH_INITIAL)) != 0)\n        goto Exit;\n    (*conn)->initial->super.next_expected_packet_number = next_expected_pn;\n    (*conn)->initial->cipher.ingress = cipher.ingress;\n    (*conn)->initial->cipher.egress = cipher.egress;\n    cipher.alive = 0;\n    (*conn)->crypto.handshake_properties.collected_extensions = server_collected_extensions;\n    (*conn)->initial->largest_ingress_udp_payload_size = packet->datagram_size;\n\n    QUICLY_PROBE(ACCEPT, *conn, (*conn)->stash.now,\n                 QUICLY_PROBE_HEXDUMP(packet->cid.dest.encrypted.base, packet->cid.dest.encrypted.len), address_token);\n    QUICLY_LOG_CONN(accept, *conn, {\n        PTLS_LOG_ELEMENT_HEXDUMP(dcid, packet->cid.dest.encrypted.base, packet->cid.dest.encrypted.len);\n        PTLS_LOG_ELEMENT_PTR(address_token, address_token);\n    });\n    QUICLY_PROBE(PACKET_RECEIVED, *conn, (*conn)->stash.now, pn, payload.base, payload.len, get_epoch(packet->octets.base[0]));\n    QUICLY_LOG_CONN(packet_received, *conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(pn, pn);\n        PTLS_LOG_APPDATA_ELEMENT_HEXDUMP(decrypted, payload.base, payload.len);\n        PTLS_LOG_ELEMENT_UNSIGNED(packet_type, get_epoch(packet->octets.base[0]));\n    });\n\n    /* handle the input; we ignore is_ack_only, we consult if there's any output from TLS in response to CH anyways */\n    (*conn)->super.stats.num_packets.received += 1;\n    if (packet->ecn != 0)\n        (*conn)->super.stats.num_packets.received_ecn_counts[get_ecn_index_from_bits(packet->ecn)] += 1;\n    (*conn)->super.stats.num_bytes.received += packet->datagram_size;\n    if ((ret = handle_payload(*conn, QUICLY_EPOCH_INITIAL, payload.base, payload.len, &offending_frame_type, &is_ack_only)) != 0)\n        goto Exit;\n    if ((ret = record_receipt(&(*conn)->initial->super, pn, packet->ecn, 0, (*conn)->stash.now, &(*conn)->egress.send_ack_at,\n                              &(*conn)->super.stats.num_packets.received_out_of_order)) != 0)\n        goto Exit;\n\nExit:\n    if (*conn != NULL) {\n        if (ret == 0) {\n            (*conn)->super.state = QUICLY_STATE_CONNECTED;\n        } else {\n            initiate_close(*conn, ret, offending_frame_type, \"\");\n            ret = 0;\n        }\n        unlock_now(*conn);\n    }\n    if (cipher.alive) {\n        dispose_cipher(&cipher.ingress);\n        dispose_cipher(&cipher.egress);\n    }\n    return ret;\n}\n\nint quicly_receive(quicly_conn_t *conn, struct sockaddr *dest_addr, struct sockaddr *src_addr, quicly_decoded_packet_t *packet)\n{\n    ptls_cipher_context_t *header_protection;\n    struct {\n        int (*cb)(void *, uint64_t, quicly_decoded_packet_t *, size_t, size_t *);\n        void *ctx;\n    } aead;\n    struct st_quicly_pn_space_t **space;\n    size_t epoch;\n    ptls_iovec_t payload;\n    uint64_t pn, offending_frame_type = QUICLY_FRAME_TYPE_PADDING;\n    int is_ack_only, ret;\n\n    assert(src_addr->sa_family == AF_INET || src_addr->sa_family == AF_INET6);\n\n    lock_now(conn, 0);\n\n    QUICLY_PROBE(RECEIVE, conn, conn->stash.now,\n                 QUICLY_PROBE_HEXDUMP(packet->cid.dest.encrypted.base, packet->cid.dest.encrypted.len), packet->octets.base,\n                 packet->octets.len);\n    QUICLY_LOG_CONN(receive, conn, {\n        PTLS_LOG_ELEMENT_HEXDUMP(dcid, packet->cid.dest.encrypted.base, packet->cid.dest.encrypted.len);\n        PTLS_LOG_ELEMENT_HEXDUMP(bytes, packet->octets.base, packet->octets.len);\n    });\n\n    if (is_stateless_reset(conn, packet)) {\n        ret = handle_stateless_reset(conn);\n        goto Exit;\n    }\n\n    /* FIXME check peer address */\n\n    /* add unconditionally, as packet->datagram_size is set only for the first packet within the UDP datagram */\n    conn->super.stats.num_bytes.received += packet->datagram_size;\n\n    switch (conn->super.state) {\n    case QUICLY_STATE_CLOSING:\n        ++conn->egress.connection_close.num_packets_received;\n        /* respond with a CONNECTION_CLOSE frame using exponential back-off */\n        if (__builtin_popcountl(conn->egress.connection_close.num_packets_received) == 1)\n            conn->egress.send_ack_at = 0;\n        ret = 0;\n        goto Exit;\n    case QUICLY_STATE_DRAINING:\n        ret = 0;\n        goto Exit;\n    default:\n        break;\n    }\n\n    if (QUICLY_PACKET_IS_LONG_HEADER(packet->octets.base[0])) {\n        if (conn->super.state == QUICLY_STATE_FIRSTFLIGHT) {\n            if (packet->version == 0) {\n                ret = handle_version_negotiation_packet(conn, packet);\n                goto Exit;\n            }\n        }\n        if (packet->version != conn->super.version) {\n            ret = QUICLY_ERROR_PACKET_IGNORED;\n            goto Exit;\n        }\n        switch (packet->octets.base[0] & QUICLY_PACKET_TYPE_BITMASK) {\n        case QUICLY_PACKET_TYPE_RETRY: {\n            assert(packet->encrypted_off + PTLS_AESGCM_TAG_SIZE == packet->octets.len);\n            /* handle only if the connection is the client */\n            if (!quicly_is_client(conn)) {\n                ret = QUICLY_ERROR_PACKET_IGNORED;\n                goto Exit;\n            }\n            /* server CID has to change */\n            if (quicly_cid_is_equal(&conn->super.remote.cid_set.cids[0].cid, packet->cid.src)) {\n                ret = QUICLY_ERROR_PACKET_IGNORED;\n                goto Exit;\n            }\n            /* do not accept a second Retry */\n            if (is_retry(conn)) {\n                ret = QUICLY_ERROR_PACKET_IGNORED;\n                goto Exit;\n            }\n            ptls_aead_context_t *retry_aead = create_retry_aead(conn->super.ctx, conn->super.version, 0);\n            int retry_ok = validate_retry_tag(packet, &conn->super.remote.cid_set.cids[0].cid, retry_aead);\n            ptls_aead_free(retry_aead);\n            if (!retry_ok) {\n                ret = QUICLY_ERROR_PACKET_IGNORED;\n                goto Exit;\n            }\n            /* check size of the Retry packet */\n            if (packet->token.len > QUICLY_MAX_TOKEN_LEN) {\n                ret = QUICLY_ERROR_PACKET_IGNORED; /* TODO this is a immediate fatal error, chose a better error code */\n                goto Exit;\n            }\n            /* store token and ODCID */\n            free(conn->token.base);\n            if ((conn->token.base = malloc(packet->token.len)) == NULL) {\n                ret = PTLS_ERROR_NO_MEMORY;\n                goto Exit;\n            }\n            memcpy(conn->token.base, packet->token.base, packet->token.len);\n            conn->token.len = packet->token.len;\n            /* update DCID */\n            quicly_set_cid(&conn->super.remote.cid_set.cids[0].cid, packet->cid.src);\n            conn->retry_scid = conn->super.remote.cid_set.cids[0].cid;\n            /* replace initial keys, or drop the keys if this is a response packet to a greased version */\n            if ((ret = reinstall_initial_encryption(conn, QUICLY_ERROR_PACKET_IGNORED)) != 0)\n                goto Exit;\n            /* schedule retransmit */\n            ret = discard_sentmap_by_epoch(conn, ~0u);\n            goto Exit;\n        } break;\n        case QUICLY_PACKET_TYPE_INITIAL:\n            if (conn->initial == NULL || (header_protection = conn->initial->cipher.ingress.header_protection) == NULL) {\n                ret = QUICLY_ERROR_PACKET_IGNORED;\n                goto Exit;\n            }\n            if (quicly_is_client(conn)) {\n                /* client: update cid if this is the first Initial packet that's being received */\n                if (conn->super.state == QUICLY_STATE_FIRSTFLIGHT)\n                    quicly_set_cid(&conn->super.remote.cid_set.cids[0].cid, packet->cid.src);\n            } else {\n                /* server: ignore packets that are too small */\n                if (packet->datagram_size < QUICLY_MIN_CLIENT_INITIAL_SIZE) {\n                    ret = QUICLY_ERROR_PACKET_IGNORED;\n                    goto Exit;\n                }\n            }\n            aead.cb = aead_decrypt_fixed_key;\n            aead.ctx = conn->initial->cipher.ingress.aead;\n            space = (void *)&conn->initial;\n            epoch = QUICLY_EPOCH_INITIAL;\n            break;\n        case QUICLY_PACKET_TYPE_HANDSHAKE:\n            if (conn->handshake == NULL || (header_protection = conn->handshake->cipher.ingress.header_protection) == NULL) {\n                ret = QUICLY_ERROR_PACKET_IGNORED;\n                goto Exit;\n            }\n            aead.cb = aead_decrypt_fixed_key;\n            aead.ctx = conn->handshake->cipher.ingress.aead;\n            space = (void *)&conn->handshake;\n            epoch = QUICLY_EPOCH_HANDSHAKE;\n            break;\n        case QUICLY_PACKET_TYPE_0RTT:\n            if (quicly_is_client(conn)) {\n                ret = QUICLY_ERROR_PACKET_IGNORED;\n                goto Exit;\n            }\n            if (conn->application == NULL ||\n                (header_protection = conn->application->cipher.ingress.header_protection.zero_rtt) == NULL) {\n                ret = QUICLY_ERROR_PACKET_IGNORED;\n                goto Exit;\n            }\n            aead.cb = aead_decrypt_fixed_key;\n            aead.ctx = conn->application->cipher.ingress.aead[1];\n            space = (void *)&conn->application;\n            epoch = QUICLY_EPOCH_0RTT;\n            break;\n        default:\n            ret = QUICLY_ERROR_PACKET_IGNORED;\n            goto Exit;\n        }\n    } else {\n        /* short header packet */\n        if (conn->application == NULL ||\n            (header_protection = conn->application->cipher.ingress.header_protection.one_rtt) == NULL) {\n            ret = QUICLY_ERROR_PACKET_IGNORED;\n            goto Exit;\n        }\n        aead.cb = aead_decrypt_1rtt;\n        aead.ctx = conn;\n        space = (void *)&conn->application;\n        epoch = QUICLY_EPOCH_1RTT;\n    }\n\n    /* decrypt */\n    if ((ret = decrypt_packet(header_protection, aead.cb, aead.ctx, &(*space)->next_expected_packet_number, packet, &pn,\n                              &payload)) != 0) {\n        ++conn->super.stats.num_packets.decryption_failed;\n        QUICLY_PROBE(PACKET_DECRYPTION_FAILED, conn, conn->stash.now, pn);\n        goto Exit;\n    }\n\n    QUICLY_PROBE(PACKET_RECEIVED, conn, conn->stash.now, pn, payload.base, payload.len, get_epoch(packet->octets.base[0]));\n    QUICLY_LOG_CONN(packet_received, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(pn, pn);\n        PTLS_LOG_ELEMENT_UNSIGNED(decrypted_len, payload.len);\n        PTLS_LOG_ELEMENT_UNSIGNED(packet_type, get_epoch(packet->octets.base[0]));\n    });\n\n    /* update states */\n    if (conn->super.state == QUICLY_STATE_FIRSTFLIGHT)\n        conn->super.state = QUICLY_STATE_CONNECTED;\n    conn->super.stats.num_packets.received += 1;\n    if (packet->ecn != 0)\n        conn->super.stats.num_packets.received_ecn_counts[get_ecn_index_from_bits(packet->ecn)] += 1;\n\n    /* state updates, that are triggered by the receipt of a packet */\n    switch (epoch) {\n    case QUICLY_EPOCH_INITIAL:\n        /* update max_ingress_udp_payload_size if necessary */\n        if (conn->initial->largest_ingress_udp_payload_size < packet->datagram_size)\n            conn->initial->largest_ingress_udp_payload_size = packet->datagram_size;\n        break;\n    case QUICLY_EPOCH_HANDSHAKE:\n        /* Discard Initial space before processing the payload of the Handshake packet to avoid the chance of an ACK frame included\n         * in the Handshake packet setting a loss timer for the Initial packet. */\n        if (conn->initial != NULL) {\n            if ((ret = discard_handshake_context(conn, QUICLY_EPOCH_INITIAL)) != 0)\n                goto Exit;\n            setup_next_send(conn);\n            conn->super.remote.address_validation.validated = 1;\n        }\n        break;\n    default:\n        break;\n    }\n\n    /* handle the payload */\n    if ((ret = handle_payload(conn, epoch, payload.base, payload.len, &offending_frame_type, &is_ack_only)) != 0)\n        goto Exit;\n    if (*space != NULL && conn->super.state < QUICLY_STATE_CLOSING) {\n        if ((ret = record_receipt(*space, pn, packet->ecn, is_ack_only, conn->stash.now, &conn->egress.send_ack_at,\n                                  &conn->super.stats.num_packets.received_out_of_order)) != 0)\n            goto Exit;\n    }\n\n    /* state updates post payload processing */\n    switch (epoch) {\n    case QUICLY_EPOCH_INITIAL:\n        assert(conn->initial != NULL);\n        if (quicly_is_client(conn) && conn->handshake != NULL && conn->handshake->cipher.egress.aead != NULL) {\n            if ((ret = discard_handshake_context(conn, QUICLY_EPOCH_INITIAL)) != 0)\n                goto Exit;\n            setup_next_send(conn);\n        }\n        break;\n    case QUICLY_EPOCH_HANDSHAKE:\n        if (quicly_is_client(conn)) {\n            /* Running as a client.\n             * Respect \"disable_migration\" TP sent by the remote peer at the end of the TLS handshake. */\n            if (conn->super.local.address.sa.sa_family == AF_UNSPEC && dest_addr != NULL && dest_addr->sa_family != AF_UNSPEC &&\n                ptls_handshake_is_complete(conn->crypto.tls) && conn->super.remote.transport_params.disable_active_migration)\n                set_address(&conn->super.local.address, dest_addr);\n        } else {\n            /* Running as a server.\n             * If handshake was just completed, drop handshake context, schedule the first emission of HANDSHAKE_DONE frame. */\n            if (ptls_handshake_is_complete(conn->crypto.tls)) {\n                if ((ret = discard_handshake_context(conn, QUICLY_EPOCH_HANDSHAKE)) != 0)\n                    goto Exit;\n                assert(conn->handshake == NULL);\n                conn->egress.pending_flows |= QUICLY_PENDING_FLOW_HANDSHAKE_DONE_BIT;\n                setup_next_send(conn);\n            }\n        }\n        break;\n    case QUICLY_EPOCH_1RTT:\n        if (!is_ack_only && should_send_max_data(conn))\n            conn->egress.pending_flows |= QUICLY_PENDING_FLOW_OTHERS_BIT;\n        break;\n    default:\n        break;\n    }\n\n    update_idle_timeout(conn, 1);\n\nExit:\n    switch (ret) {\n    case 0:\n        /* Avoid time in the past being emitted by quicly_get_first_timeout. We hit the condition below when retransmission is\n         * suspended by the 3x limit (in which case we have loss.alarm_at set but return INT64_MAX from quicly_get_first_timeout\n         * until we receive something from the client).\n         */\n        if (conn->egress.loss.alarm_at < conn->stash.now)\n            conn->egress.loss.alarm_at = conn->stash.now;\n        assert_consistency(conn, 0);\n        break;\n    case PTLS_ERROR_NO_MEMORY:\n    case QUICLY_ERROR_STATE_EXHAUSTION:\n    case QUICLY_ERROR_PACKET_IGNORED:\n        break;\n    default: /* close connection */\n        initiate_close(conn, ret, offending_frame_type, \"\");\n        ret = 0;\n        break;\n    }\n    unlock_now(conn);\n    return ret;\n}\n\nint quicly_open_stream(quicly_conn_t *conn, quicly_stream_t **_stream, int uni)\n{\n    quicly_stream_t *stream;\n    struct st_quicly_conn_streamgroup_state_t *group;\n    uint64_t *max_stream_count;\n    uint32_t max_stream_data_local;\n    uint64_t max_stream_data_remote;\n    int ret;\n\n    /* determine the states */\n    if (uni) {\n        group = &conn->super.local.uni;\n        max_stream_count = &conn->egress.max_streams.uni.count;\n        max_stream_data_local = 0;\n        max_stream_data_remote = conn->super.remote.transport_params.max_stream_data.uni;\n    } else {\n        group = &conn->super.local.bidi;\n        max_stream_count = &conn->egress.max_streams.bidi.count;\n        max_stream_data_local = (uint32_t)conn->super.ctx->transport_params.max_stream_data.bidi_local;\n        max_stream_data_remote = conn->super.remote.transport_params.max_stream_data.bidi_remote;\n    }\n\n    /* open */\n    if ((stream = open_stream(conn, group->next_stream_id, max_stream_data_local, max_stream_data_remote)) == NULL)\n        return PTLS_ERROR_NO_MEMORY;\n    ++group->num_streams;\n    group->next_stream_id += 4;\n\n    /* adjust blocked */\n    if (stream->stream_id / 4 >= *max_stream_count) {\n        stream->streams_blocked = 1;\n        quicly_linklist_insert((uni ? &conn->egress.pending_streams.blocked.uni : &conn->egress.pending_streams.blocked.bidi)->prev,\n                               &stream->_send_aux.pending_link.control);\n        conn->egress.pending_flows |= QUICLY_PENDING_FLOW_OTHERS_BIT;\n    }\n\n    /* application-layer initialization */\n    QUICLY_PROBE(STREAM_ON_OPEN, conn, conn->stash.now, stream);\n    QUICLY_LOG_CONN(stream_on_open, conn, {});\n\n    if ((ret = conn->super.ctx->stream_open->cb(conn->super.ctx->stream_open, stream)) != 0)\n        return ret;\n\n    *_stream = stream;\n    return 0;\n}\n\nvoid quicly_reset_stream(quicly_stream_t *stream, int err)\n{\n    assert(quicly_stream_has_send_side(quicly_is_client(stream->conn), stream->stream_id));\n    assert(QUICLY_ERROR_IS_QUIC_APPLICATION(err));\n    assert(stream->_send_aux.reset_stream.sender_state == QUICLY_SENDER_STATE_NONE);\n    assert(!quicly_sendstate_transfer_complete(&stream->sendstate));\n\n    /* dispose sendbuf state */\n    quicly_sendstate_reset(&stream->sendstate);\n\n    /* setup RESET_STREAM */\n    stream->_send_aux.reset_stream.sender_state = QUICLY_SENDER_STATE_SEND;\n    stream->_send_aux.reset_stream.error_code = QUICLY_ERROR_GET_ERROR_CODE(err);\n\n    /* schedule for delivery */\n    sched_stream_control(stream);\n    resched_stream_data(stream);\n}\n\nvoid quicly_request_stop(quicly_stream_t *stream, int err)\n{\n    assert(quicly_stream_has_receive_side(quicly_is_client(stream->conn), stream->stream_id));\n    assert(QUICLY_ERROR_IS_QUIC_APPLICATION(err));\n\n    /* send STOP_SENDING if the incoming side of the stream is still open */\n    if (stream->recvstate.eos == UINT64_MAX && stream->_send_aux.stop_sending.sender_state == QUICLY_SENDER_STATE_NONE) {\n        stream->_send_aux.stop_sending.sender_state = QUICLY_SENDER_STATE_SEND;\n        stream->_send_aux.stop_sending.error_code = QUICLY_ERROR_GET_ERROR_CODE(err);\n        sched_stream_control(stream);\n    }\n}\n\nsocklen_t quicly_get_socklen(struct sockaddr *sa)\n{\n    switch (sa->sa_family) {\n    case AF_INET:\n        return sizeof(struct sockaddr_in);\n    case AF_INET6:\n        return sizeof(struct sockaddr_in6);\n    default:\n        assert(!\"unexpected socket type\");\n        return 0;\n    }\n}\n\nchar *quicly_escape_unsafe_string(char *buf, const void *bytes, size_t len)\n{\n    char *dst = buf;\n    const char *src = bytes, *end = src + len;\n\n    for (; src != end; ++src) {\n        if ((0x20 <= *src && *src <= 0x7e) && !(*src == '\"' || *src == '\\'' || *src == '\\\\')) {\n            *dst++ = *src;\n        } else {\n            *dst++ = '\\\\';\n            *dst++ = 'x';\n            quicly_byte_to_hex(dst, (uint8_t)*src);\n            dst += 2;\n        }\n    }\n    *dst = '\\0';\n\n    return buf;\n}\n\nchar *quicly_hexdump(const uint8_t *bytes, size_t len, size_t indent)\n{\n    size_t i, line, row, bufsize = indent == SIZE_MAX ? len * 2 + 1 : (indent + 5 + 3 * 16 + 2 + 16 + 1) * ((len + 15) / 16) + 1;\n    char *buf, *p;\n\n    if ((buf = malloc(bufsize)) == NULL)\n        return NULL;\n    p = buf;\n    if (indent == SIZE_MAX) {\n        for (i = 0; i != len; ++i) {\n            quicly_byte_to_hex(p, bytes[i]);\n            p += 2;\n        }\n    } else {\n        for (line = 0; line * 16 < len; ++line) {\n            for (i = 0; i < indent; ++i)\n                *p++ = ' ';\n            quicly_byte_to_hex(p, (line >> 4) & 0xff);\n            p += 2;\n            quicly_byte_to_hex(p, (line << 4) & 0xff);\n            p += 2;\n            *p++ = ' ';\n            for (row = 0; row < 16; ++row) {\n                *p++ = row == 8 ? '-' : ' ';\n                if (line * 16 + row < len) {\n                    quicly_byte_to_hex(p, bytes[line * 16 + row]);\n                    p += 2;\n                } else {\n                    *p++ = ' ';\n                    *p++ = ' ';\n                }\n            }\n            *p++ = ' ';\n            *p++ = ' ';\n            for (row = 0; row < 16; ++row) {\n                if (line * 16 + row < len) {\n                    int ch = bytes[line * 16 + row];\n                    *p++ = 0x20 <= ch && ch < 0x7f ? ch : '.';\n                } else {\n                    *p++ = ' ';\n                }\n            }\n            *p++ = '\\n';\n        }\n    }\n    *p++ = '\\0';\n\n    assert(p - buf <= bufsize);\n\n    return buf;\n}\n\nvoid quicly_amend_ptls_context(ptls_context_t *ptls)\n{\n    static ptls_update_traffic_key_t update_traffic_key = {update_traffic_key_cb};\n\n    ptls->omit_end_of_early_data = 1;\n    ptls->update_traffic_key = &update_traffic_key;\n\n    /* if TLS 1.3 config permits use of early data, convert the value to 0xffffffff in accordance with QUIC-TLS */\n    if (ptls->max_early_data_size != 0)\n        ptls->max_early_data_size = UINT32_MAX;\n}\n\nint quicly_encrypt_address_token(void (*random_bytes)(void *, size_t), ptls_aead_context_t *aead, ptls_buffer_t *buf,\n                                 size_t start_off, const quicly_address_token_plaintext_t *plaintext)\n{\n    int ret;\n\n    /* type and IV */\n    if ((ret = ptls_buffer_reserve(buf, 1 + aead->algo->iv_size)) != 0)\n        goto Exit;\n    buf->base[buf->off++] = plaintext->type;\n    random_bytes(buf->base + buf->off, aead->algo->iv_size);\n    buf->off += aead->algo->iv_size;\n\n    size_t enc_start = buf->off;\n\n    /* data */\n    ptls_buffer_push64(buf, plaintext->issued_at);\n    {\n        uint16_t port;\n        ptls_buffer_push_block(buf, 1, {\n            switch (plaintext->remote.sa.sa_family) {\n            case AF_INET:\n                ptls_buffer_pushv(buf, &plaintext->remote.sin.sin_addr.s_addr, 4);\n                port = ntohs(plaintext->remote.sin.sin_port);\n                break;\n            case AF_INET6:\n                ptls_buffer_pushv(buf, &plaintext->remote.sin6.sin6_addr, 16);\n                ptls_buffer_push32(buf, plaintext->remote.sin6.sin6_scope_id);\n                port = ntohs(plaintext->remote.sin6.sin6_port);\n                break;\n            default:\n                assert(!\"unsupported address type\");\n                break;\n            }\n        });\n        ptls_buffer_push16(buf, port);\n    }\n    switch (plaintext->type) {\n    case QUICLY_ADDRESS_TOKEN_TYPE_RETRY:\n        ptls_buffer_push_block(buf, 1,\n                               { ptls_buffer_pushv(buf, plaintext->retry.original_dcid.cid, plaintext->retry.original_dcid.len); });\n        ptls_buffer_push_block(buf, 1,\n                               { ptls_buffer_pushv(buf, plaintext->retry.client_cid.cid, plaintext->retry.client_cid.len); });\n        ptls_buffer_push_block(buf, 1,\n                               { ptls_buffer_pushv(buf, plaintext->retry.server_cid.cid, plaintext->retry.server_cid.len); });\n        break;\n    case QUICLY_ADDRESS_TOKEN_TYPE_RESUMPTION:\n        ptls_buffer_push_block(buf, 1, { ptls_buffer_pushv(buf, plaintext->resumption.bytes, plaintext->resumption.len); });\n        break;\n    default:\n        assert(!\"unexpected token type\");\n        abort();\n    }\n    ptls_buffer_push_block(buf, 1, { ptls_buffer_pushv(buf, plaintext->appdata.bytes, plaintext->appdata.len); });\n\n    /* encrypt, supplying full IV */\n    if ((ret = ptls_buffer_reserve(buf, aead->algo->tag_size)) != 0)\n        goto Exit;\n    ptls_aead_set_iv(aead, buf->base + enc_start - aead->algo->iv_size);\n    ptls_aead_encrypt(aead, buf->base + enc_start, buf->base + enc_start, buf->off - enc_start, 0, buf->base + start_off,\n                      enc_start - start_off);\n    buf->off += aead->algo->tag_size;\n\nExit:\n    return ret;\n}\n\nint quicly_decrypt_address_token(ptls_aead_context_t *aead, quicly_address_token_plaintext_t *plaintext, const void *_token,\n                                 size_t len, size_t prefix_len, const char **err_desc)\n{\n    const uint8_t *const token = _token;\n    uint8_t ptbuf[QUICLY_MIN_CLIENT_INITIAL_SIZE];\n    size_t ptlen;\n\n    *err_desc = NULL;\n\n    /* check if we can get type and decrypt */\n    if (len < prefix_len + 1 + aead->algo->iv_size + aead->algo->tag_size) {\n        *err_desc = \"token too small\";\n        return PTLS_ALERT_DECODE_ERROR;\n    }\n    if (prefix_len + 1 + aead->algo->iv_size + sizeof(ptbuf) + aead->algo->tag_size < len) {\n        *err_desc = \"token too large\";\n        return PTLS_ALERT_DECODE_ERROR;\n    }\n\n    /* check type */\n    switch (token[prefix_len]) {\n    case QUICLY_ADDRESS_TOKEN_TYPE_RETRY:\n        plaintext->type = QUICLY_ADDRESS_TOKEN_TYPE_RETRY;\n        break;\n    case QUICLY_ADDRESS_TOKEN_TYPE_RESUMPTION:\n        plaintext->type = QUICLY_ADDRESS_TOKEN_TYPE_RESUMPTION;\n        break;\n    default:\n        *err_desc = \"unknown token type\";\n        return PTLS_ALERT_DECODE_ERROR;\n    }\n\n    /* `goto Exit` can only happen below this line, and that is guaranteed by declaring `ret` here */\n    int ret;\n\n    /* decrypt */\n    ptls_aead_set_iv(aead, token + prefix_len + 1);\n    if ((ptlen = ptls_aead_decrypt(aead, ptbuf, token + prefix_len + 1 + aead->algo->iv_size,\n                                   len - (prefix_len + 1 + aead->algo->iv_size), 0, token, prefix_len + 1 + aead->algo->iv_size)) ==\n        SIZE_MAX) {\n        ret = PTLS_ALERT_DECRYPT_ERROR;\n        *err_desc = \"token decryption failure\";\n        goto Exit;\n    }\n\n    /* parse */\n    const uint8_t *src = ptbuf, *end = src + ptlen;\n    if ((ret = ptls_decode64(&plaintext->issued_at, &src, end)) != 0)\n        goto Exit;\n    {\n        in_port_t *portaddr;\n        ptls_decode_open_block(src, end, 1, {\n            switch (end - src) {\n            case 4: /* ipv4 */\n                plaintext->remote.sin.sin_family = AF_INET;\n                memcpy(&plaintext->remote.sin.sin_addr.s_addr, src, 4);\n                portaddr = &plaintext->remote.sin.sin_port;\n                break;\n            case 20: /* ipv6 */\n                plaintext->remote.sin6 = (struct sockaddr_in6){.sin6_family = AF_INET6};\n                memcpy(&plaintext->remote.sin6.sin6_addr, src, 16);\n                if ((ret = ptls_decode32(&plaintext->remote.sin6.sin6_scope_id, &src, end)) != 0)\n                    goto Exit;\n                portaddr = &plaintext->remote.sin6.sin6_port;\n                break;\n            default:\n                ret = PTLS_ALERT_DECODE_ERROR;\n                goto Exit;\n            }\n            src = end;\n        });\n        uint16_t port;\n        if ((ret = ptls_decode16(&port, &src, end)) != 0)\n            goto Exit;\n        *portaddr = htons(port);\n    }\n    switch (plaintext->type) {\n    case QUICLY_ADDRESS_TOKEN_TYPE_RETRY:\n#define DECODE_CID(field)                                                                                                          \\\n    do {                                                                                                                           \\\n        ptls_decode_open_block(src, end, 1, {                                                                                      \\\n            if (end - src > sizeof(plaintext->retry.field.cid)) {                                                                  \\\n                ret = PTLS_ALERT_DECODE_ERROR;                                                                                     \\\n                goto Exit;                                                                                                         \\\n            }                                                                                                                      \\\n            quicly_set_cid(&plaintext->retry.field, ptls_iovec_init(src, end - src));                                              \\\n            src = end;                                                                                                             \\\n        });                                                                                                                        \\\n    } while (0)\n        DECODE_CID(original_dcid);\n        DECODE_CID(client_cid);\n        DECODE_CID(server_cid);\n#undef DECODE_CID\n        break;\n    case QUICLY_ADDRESS_TOKEN_TYPE_RESUMPTION:\n        ptls_decode_open_block(src, end, 1, {\n            PTLS_BUILD_ASSERT(sizeof(plaintext->resumption.bytes) >= 256);\n            plaintext->resumption.len = end - src;\n            memcpy(plaintext->resumption.bytes, src, plaintext->resumption.len);\n            src = end;\n        });\n        break;\n    default:\n        assert(!\"unexpected token type\");\n        abort();\n    }\n    ptls_decode_block(src, end, 1, {\n        PTLS_BUILD_ASSERT(sizeof(plaintext->appdata.bytes) >= 256);\n        plaintext->appdata.len = end - src;\n        memcpy(plaintext->appdata.bytes, src, plaintext->appdata.len);\n        src = end;\n    });\n    ret = 0;\n\nExit:\n    if (ret != 0) {\n        if (*err_desc == NULL)\n            *err_desc = \"token decode error\";\n        /* promote the error to one that triggers the emission of INVALID_TOKEN_ERROR, if the token looked like a retry */\n        if (plaintext->type == QUICLY_ADDRESS_TOKEN_TYPE_RETRY)\n            ret = QUICLY_TRANSPORT_ERROR_INVALID_TOKEN;\n    }\n    return ret;\n}\n\nint quicly_build_session_ticket_auth_data(ptls_buffer_t *auth_data, const quicly_context_t *ctx)\n{\n    int ret;\n\n#define PUSH_TP(id, block)                                                                                                         \\\n    do {                                                                                                                           \\\n        ptls_buffer_push_quicint(auth_data, id);                                                                                   \\\n        ptls_buffer_push_block(auth_data, -1, block);                                                                              \\\n    } while (0)\n\n    ptls_buffer_push_block(auth_data, -1, {\n        PUSH_TP(QUICLY_TRANSPORT_PARAMETER_ID_ACTIVE_CONNECTION_ID_LIMIT,\n                { ptls_buffer_push_quicint(auth_data, ctx->transport_params.active_connection_id_limit); });\n        PUSH_TP(QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_DATA,\n                { ptls_buffer_push_quicint(auth_data, ctx->transport_params.max_data); });\n        PUSH_TP(QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_BIDI_LOCAL,\n                { ptls_buffer_push_quicint(auth_data, ctx->transport_params.max_stream_data.bidi_local); });\n        PUSH_TP(QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_BIDI_REMOTE,\n                { ptls_buffer_push_quicint(auth_data, ctx->transport_params.max_stream_data.bidi_remote); });\n        PUSH_TP(QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_UNI,\n                { ptls_buffer_push_quicint(auth_data, ctx->transport_params.max_stream_data.uni); });\n        PUSH_TP(QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAMS_BIDI,\n                { ptls_buffer_push_quicint(auth_data, ctx->transport_params.max_streams_bidi); });\n        PUSH_TP(QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAMS_UNI,\n                { ptls_buffer_push_quicint(auth_data, ctx->transport_params.max_streams_uni); });\n    });\n\n#undef PUSH_TP\n\n    ret = 0;\nExit:\n    return ret;\n}\n\nvoid quicly_stream_noop_on_destroy(quicly_stream_t *stream, int err)\n{\n}\n\nvoid quicly_stream_noop_on_send_shift(quicly_stream_t *stream, size_t delta)\n{\n}\n\nvoid quicly_stream_noop_on_send_emit(quicly_stream_t *stream, size_t off, void *dst, size_t *len, int *wrote_all)\n{\n}\n\nvoid quicly_stream_noop_on_send_stop(quicly_stream_t *stream, int err)\n{\n}\n\nvoid quicly_stream_noop_on_receive(quicly_stream_t *stream, size_t off, const void *src, size_t len)\n{\n}\n\nvoid quicly_stream_noop_on_receive_reset(quicly_stream_t *stream, int err)\n{\n}\n\nconst quicly_stream_callbacks_t quicly_stream_noop_callbacks = {\n    quicly_stream_noop_on_destroy,   quicly_stream_noop_on_send_shift, quicly_stream_noop_on_send_emit,\n    quicly_stream_noop_on_send_stop, quicly_stream_noop_on_receive,    quicly_stream_noop_on_receive_reset};\n\nvoid quicly__debug_printf(quicly_conn_t *conn, const char *function, int line, const char *fmt, ...)\n{\n#if QUICLY_USE_DTRACE\n    char buf[1024];\n    va_list args;\n\n    if (!QUICLY_DEBUG_MESSAGE_ENABLED())\n        return;\n\n    va_start(args, fmt);\n    vsnprintf(buf, sizeof(buf), fmt, args);\n    va_end(args);\n\n    QUICLY_DEBUG_MESSAGE(conn, function, line, buf);\n#endif\n}\n\nconst uint32_t quicly_supported_versions[] = {QUICLY_PROTOCOL_VERSION_1, QUICLY_PROTOCOL_VERSION_DRAFT29,\n                                              QUICLY_PROTOCOL_VERSION_DRAFT27, 0};\n"], "fixing_code": ["/*\n * Copyright (c) 2017 Fastly, Kazuho Oku\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n#include <assert.h>\n#include <inttypes.h>\n#include <netinet/in.h>\n#include <netinet/ip.h>\n#include <pthread.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include \"khash.h\"\n#include \"quicly.h\"\n#include \"quicly/defaults.h\"\n#include \"quicly/sentmap.h\"\n#include \"quicly/frame.h\"\n#include \"quicly/streambuf.h\"\n#include \"quicly/cc.h\"\n#if QUICLY_USE_DTRACE\n#include \"quicly-probes.h\"\n#endif\n#include \"quicly/retire_cid.h\"\n\n#define QUICLY_TLS_EXTENSION_TYPE_TRANSPORT_PARAMETERS_FINAL 0x39\n#define QUICLY_TLS_EXTENSION_TYPE_TRANSPORT_PARAMETERS_DRAFT 0xffa5\n#define QUICLY_TRANSPORT_PARAMETER_ID_ORIGINAL_CONNECTION_ID 0\n#define QUICLY_TRANSPORT_PARAMETER_ID_MAX_IDLE_TIMEOUT 1\n#define QUICLY_TRANSPORT_PARAMETER_ID_STATELESS_RESET_TOKEN 2\n#define QUICLY_TRANSPORT_PARAMETER_ID_MAX_UDP_PAYLOAD_SIZE 3\n#define QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_DATA 4\n#define QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_BIDI_LOCAL 5\n#define QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_BIDI_REMOTE 6\n#define QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_UNI 7\n#define QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAMS_BIDI 8\n#define QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAMS_UNI 9\n#define QUICLY_TRANSPORT_PARAMETER_ID_ACK_DELAY_EXPONENT 10\n#define QUICLY_TRANSPORT_PARAMETER_ID_MAX_ACK_DELAY 11\n#define QUICLY_TRANSPORT_PARAMETER_ID_DISABLE_ACTIVE_MIGRATION 12\n#define QUICLY_TRANSPORT_PARAMETER_ID_PREFERRED_ADDRESS 13\n#define QUICLY_TRANSPORT_PARAMETER_ID_ACTIVE_CONNECTION_ID_LIMIT 14\n#define QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_SOURCE_CONNECTION_ID 15\n#define QUICLY_TRANSPORT_PARAMETER_ID_RETRY_SOURCE_CONNECTION_ID 16\n#define QUICLY_TRANSPORT_PARAMETER_ID_MAX_DATAGRAM_FRAME_SIZE 0x20\n#define QUICLY_TRANSPORT_PARAMETER_ID_MIN_ACK_DELAY 0xff03de1a\n\n/**\n * maximum size of token that quicly accepts\n */\n#define QUICLY_MAX_TOKEN_LEN 512\n/**\n * sends ACK bundled with PING, when number of gaps in the ack queue reaches or exceeds this threshold. This value should be much\n * smaller than QUICLY_MAX_RANGES.\n */\n#define QUICLY_NUM_ACK_BLOCKS_TO_INDUCE_ACKACK 8\n\nKHASH_MAP_INIT_INT64(quicly_stream_t, quicly_stream_t *)\n\n#if QUICLY_USE_TRACER\n#define QUICLY_TRACER(label, conn, ...) QUICLY_TRACER_##label(conn, __VA_ARGS__)\n#else\n#define QUICLY_TRACER(...)\n#endif\n\n#if QUICLY_USE_DTRACE\n#define QUICLY_PROBE(label, conn, ...)                                                                                             \\\n    do {                                                                                                                           \\\n        quicly_conn_t *_conn = (conn);                                                                                             \\\n        if (PTLS_UNLIKELY(QUICLY_##label##_ENABLED()) && !ptls_skip_tracing(_conn->crypto.tls))                                    \\\n            QUICLY_##label(_conn, __VA_ARGS__);                                                                                    \\\n        QUICLY_TRACER(label, _conn, __VA_ARGS__);                                                                                  \\\n    } while (0)\n#else\n#define QUICLY_PROBE(label, conn, ...) QUICLY_TRACER(label, conn, __VA_ARGS__)\n#endif\n#define QUICLY_PROBE_HEXDUMP(s, l)                                                                                                 \\\n    ({                                                                                                                             \\\n        size_t _l = (l);                                                                                                           \\\n        ptls_hexdump(alloca(_l * 2 + 1), (s), _l);                                                                                 \\\n    })\n#define QUICLY_PROBE_ESCAPE_UNSAFE_STRING(s, l)                                                                                    \\\n    ({                                                                                                                             \\\n        size_t _l = (l);                                                                                                           \\\n        quicly_escape_unsafe_string(alloca(_l * 4 + 1), (s), _l);                                                                  \\\n    })\n\nstruct st_quicly_cipher_context_t {\n    ptls_aead_context_t *aead;\n    ptls_cipher_context_t *header_protection;\n};\n\nstruct st_quicly_pn_space_t {\n    /**\n     * acks to be sent to remote peer\n     */\n    quicly_ranges_t ack_queue;\n    /**\n     * time at when the largest pn in the ack_queue has been received (or INT64_MAX if none)\n     */\n    int64_t largest_pn_received_at;\n    /**\n     *\n     */\n    uint64_t next_expected_packet_number;\n    /**\n     * number of ACK-eliciting packets that have not been ACKed yet\n     */\n    uint32_t unacked_count;\n    /**\n     * ECN in the order of ECT(0), ECT(1), CE\n     */\n    uint64_t ecn_counts[3];\n    /**\n     * maximum number of ACK-eliciting packets to be queued before sending an ACK\n     */\n    uint32_t packet_tolerance;\n    /**\n     * boolean indicating if reorder should NOT trigger an immediate ack\n     */\n    uint8_t ignore_order;\n};\n\nstruct st_quicly_handshake_space_t {\n    struct st_quicly_pn_space_t super;\n    struct {\n        struct st_quicly_cipher_context_t ingress;\n        struct st_quicly_cipher_context_t egress;\n    } cipher;\n    uint16_t largest_ingress_udp_payload_size;\n};\n\nstruct st_quicly_application_space_t {\n    struct st_quicly_pn_space_t super;\n    struct {\n        struct {\n            struct {\n                ptls_cipher_context_t *zero_rtt, *one_rtt;\n            } header_protection;\n            ptls_aead_context_t *aead[2]; /* 0-RTT uses aead[1], 1-RTT uses aead[key_phase] */\n            uint8_t secret[PTLS_MAX_DIGEST_SIZE];\n            struct {\n                uint64_t prepared;\n                uint64_t decrypted;\n            } key_phase;\n        } ingress;\n        struct {\n            struct st_quicly_cipher_context_t key;\n            uint8_t secret[PTLS_MAX_DIGEST_SIZE];\n            uint64_t key_phase;\n            struct {\n                /**\n                 * PN at which key update was initiated. Set to UINT64_MAX once key update is acked.\n                 */\n                uint64_t last;\n                /**\n                 * PN at which key update should be initiated. Set to UINT64_MAX when key update cannot be initiated.\n                 */\n                uint64_t next;\n            } key_update_pn;\n        } egress;\n    } cipher;\n    int one_rtt_writable;\n};\n\nstruct st_quicly_conn_t {\n    struct _st_quicly_conn_public_t super;\n    /**\n     * the initial context\n     */\n    struct st_quicly_handshake_space_t *initial;\n    /**\n     * the handshake context\n     */\n    struct st_quicly_handshake_space_t *handshake;\n    /**\n     * 0-RTT and 1-RTT context\n     */\n    struct st_quicly_application_space_t *application;\n    /**\n     * hashtable of streams\n     */\n    khash_t(quicly_stream_t) * streams;\n    /**\n     *\n     */\n    struct {\n        /**\n         *\n         */\n        struct {\n            uint64_t bytes_consumed;\n            quicly_maxsender_t sender;\n        } max_data;\n        /**\n         *\n         */\n        struct {\n            quicly_maxsender_t uni, bidi;\n        } max_streams;\n        /**\n         *\n         */\n        struct {\n            uint64_t next_sequence;\n        } ack_frequency;\n    } ingress;\n    /**\n     *\n     */\n    struct {\n        /**\n         * loss recovery\n         */\n        quicly_loss_t loss;\n        /**\n         * next or the currently encoding packet number\n         */\n        uint64_t packet_number;\n        /**\n         * next PN to be skipped\n         */\n        uint64_t next_pn_to_skip;\n        /**\n         *\n         */\n        uint16_t max_udp_payload_size;\n        /**\n         * valid if state is CLOSING\n         */\n        struct {\n            uint16_t error_code;\n            uint64_t frame_type; /* UINT64_MAX if application close */\n            const char *reason_phrase;\n            unsigned long num_packets_received;\n        } connection_close;\n        /**\n         *\n         */\n        struct {\n            uint64_t permitted;\n            uint64_t sent;\n        } max_data;\n        /**\n         *\n         */\n        struct {\n            struct st_quicly_max_streams_t {\n                uint64_t count;\n                quicly_maxsender_t blocked_sender;\n            } uni, bidi;\n        } max_streams;\n        /**\n         *\n         */\n        struct {\n            uint8_t send_;\n            uint8_t data[QUICLY_PATH_CHALLENGE_DATA_LEN];\n        } path_response;\n        /**\n         *\n         */\n        struct {\n            uint64_t generation;\n            uint64_t max_acked;\n            uint32_t num_inflight;\n        } new_token;\n        /**\n         *\n         */\n        struct {\n            int64_t update_at;\n            uint64_t sequence;\n        } ack_frequency;\n        /**\n         *\n         */\n        int64_t last_retransmittable_sent_at;\n        /**\n         * when to send an ACK, or other frames used for managing the connection\n         */\n        int64_t send_ack_at;\n        /**\n         * congestion control\n         */\n        quicly_cc_t cc;\n        /**\n         * ECN\n         */\n        struct {\n            enum en_quicly_ecn_state { QUICLY_ECN_OFF, QUICLY_ECN_ON, QUICLY_ECN_PROBING } state;\n            uint64_t counts[QUICLY_NUM_EPOCHS][3];\n        } ecn;\n        /**\n         * things to be sent at the stream-level, that are not governed by the stream scheduler\n         */\n        struct {\n            /**\n             * list of blocked streams (sorted in ascending order of stream_ids)\n             */\n            struct {\n                quicly_linklist_t uni;\n                quicly_linklist_t bidi;\n            } blocked;\n            /**\n             * list of streams with pending control data (e.g., RESET_STREAM)\n             */\n            quicly_linklist_t control;\n        } pending_streams;\n        /**\n         * send state for DATA_BLOCKED frame that corresponds to the current value of `conn->egress.max_data.permitted`\n         */\n        quicly_sender_state_t data_blocked;\n        /**\n         * bit vector indicating if there's any pending crypto data (the insignificant 4 bits), or other non-stream data\n         */\n        uint8_t pending_flows;\n/* The flags below indicate if the respective frames have to be sent or not. There are no false positives. */\n#define QUICLY_PENDING_FLOW_NEW_TOKEN_BIT (1 << 4)\n#define QUICLY_PENDING_FLOW_HANDSHAKE_DONE_BIT (1 << 5)\n/* Indicates that PATH_CHALLENGE, PATH_RESPONSE, MAX_STREAMS, MAX_DATA, DATA_BLOCKED, STREAMS_BLOCKED, NEW_CONNECTION_ID _might_\n * have to be sent. There could be false positives; logic for sending each of these frames have the capability of detecting such\n * false positives. The purpose of this bit is to consolidate information as an optimization. */\n#define QUICLY_PENDING_FLOW_OTHERS_BIT (1 << 6)\n        /**\n         * pending RETIRE_CONNECTION_ID frames to be sent\n         */\n        quicly_retire_cid_set_t retire_cid;\n        /**\n         * payload of DATAGRAM frames to be sent\n         */\n        struct {\n            ptls_iovec_t payloads[10];\n            size_t count;\n        } datagram_frame_payloads;\n        /**\n         * delivery rate estimator\n         */\n        quicly_ratemeter_t ratemeter;\n    } egress;\n    /**\n     * crypto data\n     */\n    struct {\n        ptls_t *tls;\n        ptls_handshake_properties_t handshake_properties;\n        struct {\n            ptls_raw_extension_t ext[3];\n            ptls_buffer_t buf;\n        } transport_params;\n        unsigned async_in_progress : 1;\n    } crypto;\n    /**\n     * token (if the token is a Retry token can be determined by consulting the length of retry_scid)\n     */\n    ptls_iovec_t token;\n    /**\n     * len=UINT8_MAX if Retry was not used, use client_received_retry() to check\n     */\n    quicly_cid_t retry_scid;\n    /**\n     *\n     */\n    struct {\n        /**\n         * The moment when the idle timeout fires (including the additional 3 PTO). The value is set to INT64_MAX while the\n         * handshake is in progress.\n         */\n        int64_t at;\n        /**\n         * idle timeout\n         */\n        uint8_t should_rearm_on_send : 1;\n    } idle_timeout;\n    /**\n     * records the time when this connection was created\n     */\n    int64_t created_at;\n    /**\n     * structure to hold various data used internally\n     */\n    struct {\n        /**\n         * This value holds current time that remains constant while quicly functions that deal with time are running. Only\n         * available when the lock is held using `lock_now`.\n         */\n        int64_t now;\n        /**\n         *\n         */\n        uint8_t lock_count;\n        struct {\n            /**\n             * This cache is used to concatenate acked ranges of streams before processing them, reducing the frequency of function\n             * calls to `quicly_sendstate_t` and to the application-level send window management callbacks. This approach works,\n             * because in most cases acks will contain contiguous ranges of a single stream.\n             */\n            struct {\n                /**\n                 * set to INT64_MIN when the cache is invalid\n                 */\n                quicly_stream_id_t stream_id;\n                quicly_sendstate_sent_t args;\n            } active_acked_cache;\n        } on_ack_stream;\n    } stash;\n};\n\n#if QUICLY_USE_TRACER\n#include \"quicly-tracer.h\"\n#endif\n\nstruct st_quicly_handle_payload_state_t {\n    const uint8_t *src, *const end;\n    size_t epoch;\n    uint64_t frame_type;\n};\n\nstruct st_ptls_salt_t {\n    uint8_t initial[20];\n    struct {\n        uint8_t key[PTLS_AES128_KEY_SIZE];\n        uint8_t iv[PTLS_AESGCM_IV_SIZE];\n    } retry;\n};\n\nstatic void crypto_stream_receive(quicly_stream_t *stream, size_t off, const void *src, size_t len);\n\nstatic const quicly_stream_callbacks_t crypto_stream_callbacks = {quicly_streambuf_destroy, quicly_streambuf_egress_shift,\n                                                                  quicly_streambuf_egress_emit, NULL, crypto_stream_receive};\n\nstatic int update_traffic_key_cb(ptls_update_traffic_key_t *self, ptls_t *tls, int is_enc, size_t epoch, const void *secret);\nstatic int initiate_close(quicly_conn_t *conn, int err, uint64_t frame_type, const char *reason_phrase);\nstatic int handle_close(quicly_conn_t *conn, int err, uint64_t frame_type, ptls_iovec_t reason_phrase);\nstatic int discard_sentmap_by_epoch(quicly_conn_t *conn, unsigned ack_epochs);\n\nquicly_cid_plaintext_t quicly_cid_plaintext_invalid = {.node_id = UINT64_MAX, .thread_id = 0xffffff};\n\nstatic const quicly_transport_parameters_t default_transport_params = {.max_udp_payload_size = QUICLY_DEFAULT_MAX_UDP_PAYLOAD_SIZE,\n                                                                       .ack_delay_exponent = QUICLY_DEFAULT_ACK_DELAY_EXPONENT,\n                                                                       .max_ack_delay = QUICLY_DEFAULT_MAX_ACK_DELAY,\n                                                                       .min_ack_delay_usec = UINT64_MAX,\n                                                                       .active_connection_id_limit =\n                                                                           QUICLY_DEFAULT_ACTIVE_CONNECTION_ID_LIMIT};\n\nstatic const struct st_ptls_salt_t *get_salt(uint32_t protocol_version)\n{\n    static const struct st_ptls_salt_t\n        v1 = {.initial = {0x38, 0x76, 0x2c, 0xf7, 0xf5, 0x59, 0x34, 0xb3, 0x4d, 0x17,\n                          0x9a, 0xe6, 0xa4, 0xc8, 0x0c, 0xad, 0xcc, 0xbb, 0x7f, 0x0a},\n              .retry = {.key = {0xbe, 0x0c, 0x69, 0x0b, 0x9f, 0x66, 0x57, 0x5a, 0x1d, 0x76, 0x6b, 0x54, 0xe3, 0x68, 0xc8, 0x4e},\n                        .iv = {0x46, 0x15, 0x99, 0xd3, 0x5d, 0x63, 0x2b, 0xf2, 0x23, 0x98, 0x25, 0xbb}}},\n        draft29 = {.initial = {0xaf, 0xbf, 0xec, 0x28, 0x99, 0x93, 0xd2, 0x4c, 0x9e, 0x97,\n                               0x86, 0xf1, 0x9c, 0x61, 0x11, 0xe0, 0x43, 0x90, 0xa8, 0x99},\n                   .retry = {.key = {0xcc, 0xce, 0x18, 0x7e, 0xd0, 0x9a, 0x09, 0xd0, 0x57, 0x28, 0x15, 0x5a, 0x6c, 0xb9, 0x6b,\n                                     0xe1},\n                             .iv = {0xe5, 0x49, 0x30, 0xf9, 0x7f, 0x21, 0x36, 0xf0, 0x53, 0x0a, 0x8c, 0x1c}}},\n        draft27 = {\n            .initial = {0xc3, 0xee, 0xf7, 0x12, 0xc7, 0x2e, 0xbb, 0x5a, 0x11, 0xa7,\n                        0xd2, 0x43, 0x2b, 0xb4, 0x63, 0x65, 0xbe, 0xf9, 0xf5, 0x02},\n            .retry = {.key = {0x4d, 0x32, 0xec, 0xdb, 0x2a, 0x21, 0x33, 0xc8, 0x41, 0xe4, 0x04, 0x3d, 0xf2, 0x7d, 0x44, 0x30},\n                      .iv = {0x4d, 0x16, 0x11, 0xd0, 0x55, 0x13, 0xa5, 0x52, 0xc5, 0x87, 0xd5, 0x75}}};\n\n    switch (protocol_version) {\n    case QUICLY_PROTOCOL_VERSION_1:\n        return &v1;\n    case QUICLY_PROTOCOL_VERSION_DRAFT29:\n        return &draft29;\n    case QUICLY_PROTOCOL_VERSION_DRAFT27:\n        return &draft27;\n        break;\n    default:\n        return NULL;\n    }\n}\n\nstatic void lock_now(quicly_conn_t *conn, int is_reentrant)\n{\n    if (conn->stash.now == 0) {\n        assert(conn->stash.lock_count == 0);\n        conn->stash.now = conn->super.ctx->now->cb(conn->super.ctx->now);\n    } else {\n        assert(is_reentrant && \"caller must be reentrant\");\n        assert(conn->stash.lock_count != 0);\n    }\n\n    ++conn->stash.lock_count;\n}\n\nstatic void unlock_now(quicly_conn_t *conn)\n{\n    assert(conn->stash.now != 0);\n\n    if (--conn->stash.lock_count == 0)\n        conn->stash.now = 0;\n}\n\nstatic void set_address(quicly_address_t *addr, struct sockaddr *sa)\n{\n    if (sa == NULL) {\n        addr->sa.sa_family = AF_UNSPEC;\n        return;\n    }\n\n    switch (sa->sa_family) {\n    case AF_UNSPEC:\n        addr->sa.sa_family = AF_UNSPEC;\n        break;\n    case AF_INET:\n        addr->sin = *(struct sockaddr_in *)sa;\n        break;\n    case AF_INET6:\n        addr->sin6 = *(struct sockaddr_in6 *)sa;\n        break;\n    default:\n        memset(addr, 0xff, sizeof(*addr));\n        assert(!\"unexpected address type\");\n        break;\n    }\n}\n\nstatic ptls_cipher_suite_t *get_aes128gcmsha256(quicly_context_t *ctx)\n{\n    ptls_cipher_suite_t **cs;\n\n    for (cs = ctx->tls->cipher_suites;; ++cs) {\n        assert(cs != NULL);\n        if ((*cs)->id == PTLS_CIPHER_SUITE_AES_128_GCM_SHA256)\n            break;\n    }\n    return *cs;\n}\n\nstatic inline uint8_t get_epoch(uint8_t first_byte)\n{\n    if (!QUICLY_PACKET_IS_LONG_HEADER(first_byte))\n        return QUICLY_EPOCH_1RTT;\n\n    switch (first_byte & QUICLY_PACKET_TYPE_BITMASK) {\n    case QUICLY_PACKET_TYPE_INITIAL:\n        return QUICLY_EPOCH_INITIAL;\n    case QUICLY_PACKET_TYPE_HANDSHAKE:\n        return QUICLY_EPOCH_HANDSHAKE;\n    case QUICLY_PACKET_TYPE_0RTT:\n        return QUICLY_EPOCH_0RTT;\n    default:\n        assert(!\"FIXME\");\n    }\n}\n\nstatic ptls_aead_context_t *create_retry_aead(quicly_context_t *ctx, uint32_t protocol_version, int is_enc)\n{\n    const struct st_ptls_salt_t *salt = get_salt(protocol_version);\n    assert(salt != NULL);\n\n    ptls_cipher_suite_t *algo = get_aes128gcmsha256(ctx);\n    ptls_aead_context_t *aead = ptls_aead_new_direct(algo->aead, is_enc, salt->retry.key, salt->retry.iv);\n    assert(aead != NULL);\n    return aead;\n}\n\nstatic void dispose_cipher(struct st_quicly_cipher_context_t *ctx)\n{\n    ptls_aead_free(ctx->aead);\n    ptls_cipher_free(ctx->header_protection);\n}\n\nstatic void clear_datagram_frame_payloads(quicly_conn_t *conn)\n{\n    for (size_t i = 0; i != conn->egress.datagram_frame_payloads.count; ++i) {\n        free(conn->egress.datagram_frame_payloads.payloads[i].base);\n        conn->egress.datagram_frame_payloads.payloads[i] = ptls_iovec_init(NULL, 0);\n    }\n    conn->egress.datagram_frame_payloads.count = 0;\n}\n\nstatic int is_retry(quicly_conn_t *conn)\n{\n    return conn->retry_scid.len != UINT8_MAX;\n}\n\nstatic int needs_cid_auth(quicly_conn_t *conn)\n{\n    switch (conn->super.version) {\n    case QUICLY_PROTOCOL_VERSION_1:\n    case QUICLY_PROTOCOL_VERSION_DRAFT29:\n        return 1;\n    default:\n        return 0;\n    }\n}\n\nstatic int64_t get_sentmap_expiration_time(quicly_conn_t *conn)\n{\n    return quicly_loss_get_sentmap_expiration_time(&conn->egress.loss, conn->super.remote.transport_params.max_ack_delay);\n}\n\n/**\n * converts ECN bits to index in the order of ACK-ECN field (i.e., ECT(0) -> 0, ECT(1) -> 1, CE -> 2)\n */\nstatic size_t get_ecn_index_from_bits(uint8_t bits)\n{\n    assert(1 <= bits && bits <= 3);\n    return (18 >> bits) & 3;\n}\n\nstatic void update_ecn_state(quicly_conn_t *conn, enum en_quicly_ecn_state new_state)\n{\n    assert(new_state == QUICLY_ECN_ON || new_state == QUICLY_ECN_OFF);\n\n    conn->egress.ecn.state = new_state;\n    if (new_state == QUICLY_ECN_ON) {\n        ++conn->super.stats.num_paths.ecn_validated;\n    } else {\n        ++conn->super.stats.num_paths.ecn_failed;\n    }\n\n    QUICLY_PROBE(ECN_VALIDATION, conn, conn->stash.now, (int)new_state);\n    QUICLY_LOG_CONN(ecn_validation, conn, { PTLS_LOG_ELEMENT_SIGNED(state, (int)new_state); });\n}\n\nstatic void ack_frequency_set_next_update_at(quicly_conn_t *conn)\n{\n    if (conn->super.remote.transport_params.min_ack_delay_usec != UINT64_MAX)\n        conn->egress.ack_frequency.update_at = conn->stash.now + get_sentmap_expiration_time(conn);\n}\n\nsize_t quicly_decode_packet(quicly_context_t *ctx, quicly_decoded_packet_t *packet, const uint8_t *datagram, size_t datagram_size,\n                            size_t *off)\n{\n    const uint8_t *src = datagram, *src_end = datagram + datagram_size;\n\n    assert(*off <= datagram_size);\n\n    packet->octets = ptls_iovec_init(src + *off, datagram_size - *off);\n    if (packet->octets.len < 2)\n        goto Error;\n    packet->datagram_size = *off == 0 ? datagram_size : 0;\n    packet->token = ptls_iovec_init(NULL, 0);\n    packet->decrypted.pn = UINT64_MAX;\n    packet->ecn = 0; /* non-ECT */\n\n    /* move the cursor to the second byte */\n    src += *off + 1;\n\n    if (QUICLY_PACKET_IS_LONG_HEADER(packet->octets.base[0])) {\n        /* long header */\n        uint64_t rest_length;\n        if (src_end - src < 5)\n            goto Error;\n        packet->version = quicly_decode32(&src);\n        packet->cid.dest.encrypted.len = *src++;\n        if (src_end - src < packet->cid.dest.encrypted.len + 1)\n            goto Error;\n        packet->cid.dest.encrypted.base = (uint8_t *)src;\n        src += packet->cid.dest.encrypted.len;\n        packet->cid.src.len = *src++;\n        if (src_end - src < packet->cid.src.len)\n            goto Error;\n        packet->cid.src.base = (uint8_t *)src;\n        src += packet->cid.src.len;\n        switch (packet->octets.base[0] & QUICLY_PACKET_TYPE_BITMASK) {\n        case QUICLY_PACKET_TYPE_INITIAL:\n        case QUICLY_PACKET_TYPE_0RTT:\n            if (ctx->cid_encryptor == NULL || packet->cid.dest.encrypted.len == 0 ||\n                ctx->cid_encryptor->decrypt_cid(ctx->cid_encryptor, &packet->cid.dest.plaintext, packet->cid.dest.encrypted.base,\n                                                packet->cid.dest.encrypted.len) == SIZE_MAX)\n                packet->cid.dest.plaintext = quicly_cid_plaintext_invalid;\n            packet->cid.dest.might_be_client_generated = 1;\n            break;\n        default:\n            if (ctx->cid_encryptor != NULL) {\n                if (packet->cid.dest.encrypted.len == 0)\n                    goto Error;\n                if (ctx->cid_encryptor->decrypt_cid(ctx->cid_encryptor, &packet->cid.dest.plaintext,\n                                                    packet->cid.dest.encrypted.base, packet->cid.dest.encrypted.len) == SIZE_MAX)\n                    goto Error;\n            } else {\n                packet->cid.dest.plaintext = quicly_cid_plaintext_invalid;\n            }\n            packet->cid.dest.might_be_client_generated = 0;\n            break;\n        }\n        switch (packet->version) {\n        case QUICLY_PROTOCOL_VERSION_1:\n        case QUICLY_PROTOCOL_VERSION_DRAFT29:\n        case QUICLY_PROTOCOL_VERSION_DRAFT27:\n            /* these are the recognized versions, and they share the same packet header format */\n            if ((packet->octets.base[0] & QUICLY_PACKET_TYPE_BITMASK) == QUICLY_PACKET_TYPE_RETRY) {\n                /* retry */\n                if (src_end - src <= PTLS_AESGCM_TAG_SIZE)\n                    goto Error;\n                packet->token = ptls_iovec_init(src, src_end - src - PTLS_AESGCM_TAG_SIZE);\n                src += packet->token.len;\n                packet->encrypted_off = src - packet->octets.base;\n            } else {\n                /* coalescible long header packet */\n                if ((packet->octets.base[0] & QUICLY_PACKET_TYPE_BITMASK) == QUICLY_PACKET_TYPE_INITIAL) {\n                    /* initial has a token */\n                    uint64_t token_len;\n                    if ((token_len = quicly_decodev(&src, src_end)) == UINT64_MAX)\n                        goto Error;\n                    if (src_end - src < token_len)\n                        goto Error;\n                    packet->token = ptls_iovec_init(src, token_len);\n                    src += token_len;\n                }\n                if ((rest_length = quicly_decodev(&src, src_end)) == UINT64_MAX)\n                    goto Error;\n                if (rest_length < 1)\n                    goto Error;\n                if (src_end - src < rest_length)\n                    goto Error;\n                packet->encrypted_off = src - packet->octets.base;\n                packet->octets.len = packet->encrypted_off + rest_length;\n            }\n            break;\n        default:\n            /* VN packet or packets of unknown version cannot be parsed. `encrypted_off` is set to the first byte after SCID. */\n            packet->encrypted_off = src - packet->octets.base;\n        }\n        packet->_is_stateless_reset_cached = QUICLY__DECODED_PACKET_CACHED_NOT_STATELESS_RESET;\n    } else {\n        /* short header */\n        if (ctx->cid_encryptor != NULL) {\n            if (src_end - src < QUICLY_MAX_CID_LEN_V1)\n                goto Error;\n            size_t local_cidl = ctx->cid_encryptor->decrypt_cid(ctx->cid_encryptor, &packet->cid.dest.plaintext, src, 0);\n            if (local_cidl == SIZE_MAX)\n                goto Error;\n            packet->cid.dest.encrypted = ptls_iovec_init(src, local_cidl);\n            src += local_cidl;\n        } else {\n            packet->cid.dest.encrypted = ptls_iovec_init(NULL, 0);\n            packet->cid.dest.plaintext = quicly_cid_plaintext_invalid;\n        }\n        packet->cid.dest.might_be_client_generated = 0;\n        packet->cid.src = ptls_iovec_init(NULL, 0);\n        packet->version = 0;\n        packet->encrypted_off = src - packet->octets.base;\n        packet->_is_stateless_reset_cached = QUICLY__DECODED_PACKET_CACHED_MAYBE_STATELESS_RESET;\n    }\n\n    *off += packet->octets.len;\n    return packet->octets.len;\n\nError:\n    return SIZE_MAX;\n}\n\nuint64_t quicly_determine_packet_number(uint32_t truncated, size_t num_bits, uint64_t expected)\n{\n    uint64_t win = (uint64_t)1 << num_bits, candidate = (expected & ~(win - 1)) | truncated;\n\n    if (candidate + win / 2 <= expected)\n        return candidate + win;\n    if (candidate > expected + win / 2 && candidate >= win)\n        return candidate - win;\n    return candidate;\n}\n\nstatic void assert_consistency(quicly_conn_t *conn, int timer_must_be_in_future)\n{\n    if (conn->super.state >= QUICLY_STATE_CLOSING) {\n        assert(!timer_must_be_in_future || conn->stash.now < conn->egress.send_ack_at);\n        return;\n    }\n\n    if (conn->egress.loss.sentmap.bytes_in_flight != 0 || conn->super.remote.address_validation.send_probe) {\n        assert(conn->egress.loss.alarm_at != INT64_MAX);\n    } else {\n        assert(conn->egress.loss.loss_time == INT64_MAX);\n    }\n    /* Allow timers not in the future when the remote peer is not yet validated, since we may not be able to send packets even when\n     * timers fire. */\n    if (timer_must_be_in_future && conn->super.remote.address_validation.validated)\n        assert(conn->stash.now < conn->egress.loss.alarm_at);\n}\n\nstatic int on_invalid_ack(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    if (acked)\n        return QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;\n    return 0;\n}\n\nstatic uint64_t calc_next_pn_to_skip(ptls_context_t *tlsctx, uint64_t next_pn, uint32_t cwnd, uint64_t mtu)\n{\n    static __thread struct {\n        uint32_t values[8];\n        size_t off;\n    } cached_rand;\n\n    if (cached_rand.off == 0) {\n        tlsctx->random_bytes(cached_rand.values, sizeof(cached_rand.values));\n        cached_rand.off = PTLS_ELEMENTSOF(cached_rand.values);\n    }\n\n    /* on average, skip one PN per every min(256 packets, 8 * CWND) */\n    uint32_t packet_cwnd = cwnd / mtu;\n    if (packet_cwnd < 32)\n        packet_cwnd = 32;\n    uint64_t skip_after = cached_rand.values[--cached_rand.off] % (16 * packet_cwnd);\n    return next_pn + 1 + skip_after;\n}\n\nstatic void init_max_streams(struct st_quicly_max_streams_t *m)\n{\n    m->count = 0;\n    quicly_maxsender_init(&m->blocked_sender, -1);\n}\n\nstatic int update_max_streams(struct st_quicly_max_streams_t *m, uint64_t count)\n{\n    if (count > (uint64_t)1 << 60)\n        return QUICLY_TRANSPORT_ERROR_STREAM_LIMIT;\n\n    if (m->count < count) {\n        m->count = count;\n        if (m->blocked_sender.max_acked < count)\n            m->blocked_sender.max_acked = count;\n    }\n\n    return 0;\n}\n\nint quicly_connection_is_ready(quicly_conn_t *conn)\n{\n    return conn->application != NULL;\n}\n\nstatic int stream_is_destroyable(quicly_stream_t *stream)\n{\n    if (!quicly_recvstate_transfer_complete(&stream->recvstate))\n        return 0;\n    if (!quicly_sendstate_transfer_complete(&stream->sendstate))\n        return 0;\n    switch (stream->_send_aux.reset_stream.sender_state) {\n    case QUICLY_SENDER_STATE_NONE:\n    case QUICLY_SENDER_STATE_ACKED:\n        break;\n    default:\n        return 0;\n    }\n    return 1;\n}\n\nstatic void sched_stream_control(quicly_stream_t *stream)\n{\n    assert(stream->stream_id >= 0);\n\n    if (!quicly_linklist_is_linked(&stream->_send_aux.pending_link.control))\n        quicly_linklist_insert(stream->conn->egress.pending_streams.control.prev, &stream->_send_aux.pending_link.control);\n}\n\nstatic void resched_stream_data(quicly_stream_t *stream)\n{\n    if (stream->stream_id < 0) {\n        assert(-4 <= stream->stream_id);\n        uint8_t mask = 1 << -(1 + stream->stream_id);\n        assert((mask & (QUICLY_PENDING_FLOW_NEW_TOKEN_BIT | QUICLY_PENDING_FLOW_HANDSHAKE_DONE_BIT |\n                        QUICLY_PENDING_FLOW_OTHERS_BIT)) == 0);\n        if (stream->sendstate.pending.num_ranges != 0) {\n            stream->conn->egress.pending_flows |= mask;\n        } else {\n            stream->conn->egress.pending_flows &= ~mask;\n        }\n        return;\n    }\n\n    /* do nothing if blocked */\n    if (stream->streams_blocked)\n        return;\n\n    quicly_stream_scheduler_t *scheduler = stream->conn->super.ctx->stream_scheduler;\n    scheduler->update_state(scheduler, stream);\n}\n\nstatic int should_send_max_data(quicly_conn_t *conn)\n{\n    return quicly_maxsender_should_send_max(&conn->ingress.max_data.sender, conn->ingress.max_data.bytes_consumed,\n                                            (uint32_t)conn->super.ctx->transport_params.max_data, 512);\n}\n\nstatic int should_send_max_stream_data(quicly_stream_t *stream)\n{\n    if (stream->recvstate.eos != UINT64_MAX)\n        return 0;\n    return quicly_maxsender_should_send_max(&stream->_send_aux.max_stream_data_sender, stream->recvstate.data_off,\n                                            stream->_recv_aux.window, 512);\n}\n\nint quicly_stream_sync_sendbuf(quicly_stream_t *stream, int activate)\n{\n    int ret;\n\n    if (activate) {\n        if ((ret = quicly_sendstate_activate(&stream->sendstate)) != 0)\n            return ret;\n    }\n\n    resched_stream_data(stream);\n    return 0;\n}\n\nvoid quicly_stream_sync_recvbuf(quicly_stream_t *stream, size_t shift_amount)\n{\n    stream->recvstate.data_off += shift_amount;\n    if (stream->stream_id >= 0) {\n        if (should_send_max_stream_data(stream))\n            sched_stream_control(stream);\n    }\n}\n\n/**\n * calculate how many CIDs we provide to the remote peer\n */\nstatic size_t local_cid_size(const quicly_conn_t *conn)\n{\n    PTLS_BUILD_ASSERT(QUICLY_LOCAL_ACTIVE_CONNECTION_ID_LIMIT < SIZE_MAX / sizeof(uint64_t));\n\n    /* if we don't have an encryptor, the only CID we issue is the one we send during handshake */\n    if (conn->super.ctx->cid_encryptor == NULL)\n        return 1;\n\n    uint64_t capacity = conn->super.remote.transport_params.active_connection_id_limit;\n    if (capacity > QUICLY_LOCAL_ACTIVE_CONNECTION_ID_LIMIT)\n        capacity = QUICLY_LOCAL_ACTIVE_CONNECTION_ID_LIMIT;\n    return capacity;\n}\n\n/**\n * set up an internal record to send RETIRE_CONNECTION_ID frame later\n */\nstatic void schedule_retire_connection_id_frame(quicly_conn_t *conn, uint64_t sequence)\n{\n    quicly_retire_cid_push(&conn->egress.retire_cid, sequence);\n    conn->egress.pending_flows |= QUICLY_PENDING_FLOW_OTHERS_BIT;\n}\n\nstatic int write_crypto_data(quicly_conn_t *conn, ptls_buffer_t *tlsbuf, size_t epoch_offsets[5])\n{\n    size_t epoch;\n    int ret;\n\n    if (tlsbuf->off == 0)\n        return 0;\n\n    for (epoch = 0; epoch < 4; ++epoch) {\n        size_t len = epoch_offsets[epoch + 1] - epoch_offsets[epoch];\n        if (len == 0)\n            continue;\n        quicly_stream_t *stream = quicly_get_stream(conn, -(quicly_stream_id_t)(1 + epoch));\n        assert(stream != NULL);\n        if ((ret = quicly_streambuf_egress_write(stream, tlsbuf->base + epoch_offsets[epoch], len)) != 0)\n            return ret;\n    }\n\n    return 0;\n}\n\nstatic void crypto_handshake(quicly_conn_t *conn, size_t in_epoch, ptls_iovec_t input)\n{\n    ptls_buffer_t output;\n    size_t epoch_offsets[5] = {0};\n\n    assert(!conn->crypto.async_in_progress);\n\n    ptls_buffer_init(&output, \"\", 0);\n\n    int handshake_result = ptls_handle_message(conn->crypto.tls, &output, epoch_offsets, in_epoch, input.base, input.len,\n                                               &conn->crypto.handshake_properties);\n    QUICLY_PROBE(CRYPTO_HANDSHAKE, conn, conn->stash.now, handshake_result);\n    QUICLY_LOG_CONN(crypto_handshake, conn, { PTLS_LOG_ELEMENT_SIGNED(ret, handshake_result); });\n    switch (handshake_result) {\n    case 0:\n    case PTLS_ERROR_IN_PROGRESS:\n        break;\n    case PTLS_ERROR_ASYNC_OPERATION:\n        assert(conn->super.ctx->async_handshake != NULL &&\n               \"async handshake is used but the quicly_context_t::async_handshake is NULL\");\n        conn->crypto.async_in_progress = 1;\n        conn->super.ctx->async_handshake->cb(conn->super.ctx->async_handshake, conn->crypto.tls);\n        break;\n    default:\n        initiate_close(conn,\n                       PTLS_ERROR_GET_CLASS(handshake_result) == PTLS_ERROR_CLASS_SELF_ALERT ? handshake_result\n                                                                                             : QUICLY_TRANSPORT_ERROR_INTERNAL,\n                       QUICLY_FRAME_TYPE_CRYPTO, NULL);\n        goto Exit;\n    }\n    /* drop 0-RTT write key if 0-RTT is rejected by remote peer */\n    if (conn->application != NULL && !conn->application->one_rtt_writable && conn->application->cipher.egress.key.aead != NULL) {\n        assert(quicly_is_client(conn));\n        if (conn->crypto.handshake_properties.client.early_data_acceptance == PTLS_EARLY_DATA_REJECTED) {\n            dispose_cipher(&conn->application->cipher.egress.key);\n            conn->application->cipher.egress.key = (struct st_quicly_cipher_context_t){NULL};\n            /* retire all packets with ack_epoch == 3; they are all 0-RTT packets */\n            int ret;\n            if ((ret = discard_sentmap_by_epoch(conn, 1u << QUICLY_EPOCH_1RTT)) != 0) {\n                initiate_close(conn, ret, QUICLY_FRAME_TYPE_CRYPTO, NULL);\n                goto Exit;\n            }\n        }\n    }\n\n    write_crypto_data(conn, &output, epoch_offsets);\n\nExit:\n    ptls_buffer_dispose(&output);\n}\n\nvoid crypto_stream_receive(quicly_stream_t *stream, size_t off, const void *src, size_t len)\n{\n    quicly_conn_t *conn = stream->conn;\n    ptls_iovec_t input;\n\n    /* store input */\n    if (quicly_streambuf_ingress_receive(stream, off, src, len) != 0)\n        return;\n\n    /* While the server generates the handshake signature asynchronously, clients would not send additional messages. They cannot\n     * generate Finished. They would not send Certificate / CertificateVerify before authenticating the server identity. */\n    if (conn->crypto.async_in_progress) {\n        initiate_close(conn, PTLS_ALERT_UNEXPECTED_MESSAGE, QUICLY_FRAME_TYPE_CRYPTO, NULL);\n        return;\n    }\n\n    /* feed the input into TLS, send result */\n    if ((input = quicly_streambuf_ingress_get(stream)).len != 0) {\n        size_t in_epoch = -(1 + stream->stream_id);\n        crypto_handshake(conn, in_epoch, input);\n        quicly_streambuf_ingress_shift(stream, input.len);\n    }\n}\n\nquicly_conn_t *quicly_resume_handshake(ptls_t *tls)\n{\n    quicly_conn_t *conn;\n\n    if ((conn = *ptls_get_data_ptr(tls)) == NULL) {\n        /* QUIC connection has been closed while TLS async operation was inflight. */\n        ptls_free(tls);\n        return NULL;\n    }\n\n    assert(conn->crypto.async_in_progress);\n    conn->crypto.async_in_progress = 0;\n\n    if (conn->super.state >= QUICLY_STATE_CLOSING)\n        return conn;\n\n    crypto_handshake(conn, 0, ptls_iovec_init(NULL, 0));\n    return conn;\n}\n\nstatic void init_stream_properties(quicly_stream_t *stream, uint32_t initial_max_stream_data_local,\n                                   uint64_t initial_max_stream_data_remote)\n{\n    int is_client = quicly_is_client(stream->conn);\n\n    if (quicly_stream_has_send_side(is_client, stream->stream_id)) {\n        quicly_sendstate_init(&stream->sendstate);\n    } else {\n        quicly_sendstate_init_closed(&stream->sendstate);\n    }\n    if (quicly_stream_has_receive_side(is_client, stream->stream_id)) {\n        quicly_recvstate_init(&stream->recvstate);\n    } else {\n        quicly_recvstate_init_closed(&stream->recvstate);\n    }\n    stream->streams_blocked = 0;\n\n    stream->_send_aux.max_stream_data = initial_max_stream_data_remote;\n    stream->_send_aux.stop_sending.sender_state = QUICLY_SENDER_STATE_NONE;\n    stream->_send_aux.stop_sending.error_code = 0;\n    stream->_send_aux.reset_stream.sender_state = QUICLY_SENDER_STATE_NONE;\n    stream->_send_aux.reset_stream.error_code = 0;\n    quicly_maxsender_init(&stream->_send_aux.max_stream_data_sender, initial_max_stream_data_local);\n    stream->_send_aux.blocked = QUICLY_SENDER_STATE_NONE;\n    quicly_linklist_init(&stream->_send_aux.pending_link.control);\n    quicly_linklist_init(&stream->_send_aux.pending_link.default_scheduler);\n\n    stream->_recv_aux.window = initial_max_stream_data_local;\n\n    /* Set the number of max ranges to be capable of handling following case:\n     * * every one of the two packets being sent are lost\n     * * average size of a STREAM frame found in a packet is >= ~512 bytes, or small STREAM frame is sent for every other stream\n     *   being opened (e.g., sending QPACK encoder/decoder stream frame for each HTTP/3 request)\n     * See also: the doc-comment on `_recv_aux.max_ranges`.\n     */\n    uint32_t fragments_minmax = (uint32_t)(stream->conn->super.ctx->transport_params.max_streams_uni +\n                                           stream->conn->super.ctx->transport_params.max_streams_bidi);\n    if (fragments_minmax < 63)\n        fragments_minmax = 63;\n    if ((stream->_recv_aux.max_ranges = initial_max_stream_data_local / 1024) < fragments_minmax)\n        stream->_recv_aux.max_ranges = fragments_minmax;\n}\n\nstatic void dispose_stream_properties(quicly_stream_t *stream)\n{\n    quicly_sendstate_dispose(&stream->sendstate);\n    quicly_recvstate_dispose(&stream->recvstate);\n    quicly_maxsender_dispose(&stream->_send_aux.max_stream_data_sender);\n    quicly_linklist_unlink(&stream->_send_aux.pending_link.control);\n    quicly_linklist_unlink(&stream->_send_aux.pending_link.default_scheduler);\n}\n\nstatic quicly_stream_t *open_stream(quicly_conn_t *conn, uint64_t stream_id, uint32_t initial_max_stream_data_local,\n                                    uint64_t initial_max_stream_data_remote)\n{\n    quicly_stream_t *stream;\n\n    if ((stream = malloc(sizeof(*stream))) == NULL)\n        return NULL;\n    stream->conn = conn;\n    stream->stream_id = stream_id;\n    stream->callbacks = NULL;\n    stream->data = NULL;\n\n    int r;\n    khiter_t iter = kh_put(quicly_stream_t, conn->streams, stream_id, &r);\n    assert(iter != kh_end(conn->streams));\n    kh_val(conn->streams, iter) = stream;\n\n    init_stream_properties(stream, initial_max_stream_data_local, initial_max_stream_data_remote);\n\n    return stream;\n}\n\nstatic struct st_quicly_conn_streamgroup_state_t *get_streamgroup_state(quicly_conn_t *conn, quicly_stream_id_t stream_id)\n{\n    if (quicly_is_client(conn) == quicly_stream_is_client_initiated(stream_id)) {\n        return quicly_stream_is_unidirectional(stream_id) ? &conn->super.local.uni : &conn->super.local.bidi;\n    } else {\n        return quicly_stream_is_unidirectional(stream_id) ? &conn->super.remote.uni : &conn->super.remote.bidi;\n    }\n}\n\nstatic int should_send_max_streams(quicly_conn_t *conn, int uni)\n{\n    uint64_t concurrency;\n    quicly_maxsender_t *maxsender;\n    struct st_quicly_conn_streamgroup_state_t *group;\n\n#define INIT_VARS(type)                                                                                                            \\\n    do {                                                                                                                           \\\n        concurrency = conn->super.ctx->transport_params.max_streams_##type;                                                        \\\n        maxsender = &conn->ingress.max_streams.type;                                                                               \\\n        group = &conn->super.remote.type;                                                                                          \\\n    } while (0)\n    if (uni) {\n        INIT_VARS(uni);\n    } else {\n        INIT_VARS(bidi);\n    }\n#undef INIT_VARS\n\n    if (concurrency == 0)\n        return 0;\n\n    if (!quicly_maxsender_should_send_max(maxsender, group->next_stream_id / 4, group->num_streams, 768))\n        return 0;\n\n    return 1;\n}\n\nstatic void destroy_stream(quicly_stream_t *stream, int err)\n{\n    quicly_conn_t *conn = stream->conn;\n\n    QUICLY_PROBE(STREAM_ON_DESTROY, conn, conn->stash.now, stream, err);\n    QUICLY_LOG_CONN(stream_on_destroy, conn, {\n        PTLS_LOG_ELEMENT_SIGNED(stream_id, stream->stream_id);\n        PTLS_LOG_ELEMENT_SIGNED(err, err);\n    });\n\n    if (stream->callbacks != NULL)\n        stream->callbacks->on_destroy(stream, err);\n\n    khiter_t iter = kh_get(quicly_stream_t, conn->streams, stream->stream_id);\n    assert(iter != kh_end(conn->streams));\n    kh_del(quicly_stream_t, conn->streams, iter);\n\n    if (stream->stream_id < 0) {\n        size_t epoch = -(1 + stream->stream_id);\n        stream->conn->egress.pending_flows &= ~(uint8_t)(1 << epoch);\n    } else {\n        struct st_quicly_conn_streamgroup_state_t *group = get_streamgroup_state(conn, stream->stream_id);\n        --group->num_streams;\n    }\n\n    dispose_stream_properties(stream);\n\n    if (conn->application != NULL && should_send_max_streams(conn, quicly_stream_is_unidirectional(stream->stream_id)))\n        conn->egress.pending_flows |= QUICLY_PENDING_FLOW_OTHERS_BIT;\n\n    free(stream);\n}\n\nstatic void destroy_all_streams(quicly_conn_t *conn, int err, int including_crypto_streams)\n{\n    quicly_stream_t *stream;\n    kh_foreach_value(conn->streams, stream, {\n        /* TODO do we need to send reset signals to open streams? */\n        if (including_crypto_streams || stream->stream_id >= 0)\n            destroy_stream(stream, err);\n    });\n    assert(quicly_num_streams(conn) == 0);\n}\n\nint quicly_foreach_stream(quicly_conn_t *conn, void *thunk, int (*cb)(void *thunk, quicly_stream_t *stream))\n{\n    quicly_stream_t *stream;\n    kh_foreach_value(conn->streams, stream, {\n        if (stream->stream_id >= 0) {\n            int ret = cb(thunk, stream);\n            if (ret != 0)\n                return ret;\n        }\n    });\n    return 0;\n}\n\nquicly_stream_t *quicly_get_stream(quicly_conn_t *conn, quicly_stream_id_t stream_id)\n{\n    khiter_t iter = kh_get(quicly_stream_t, conn->streams, stream_id);\n    if (iter != kh_end(conn->streams))\n        return kh_val(conn->streams, iter);\n    return NULL;\n}\n\nptls_t *quicly_get_tls(quicly_conn_t *conn)\n{\n    return conn->crypto.tls;\n}\n\nuint32_t quicly_num_streams_by_group(quicly_conn_t *conn, int uni, int locally_initiated)\n{\n    int server_initiated = quicly_is_client(conn) != locally_initiated;\n    struct st_quicly_conn_streamgroup_state_t *state = get_streamgroup_state(conn, uni * 2 + server_initiated);\n    return state->num_streams;\n}\n\nint quicly_get_stats(quicly_conn_t *conn, quicly_stats_t *stats)\n{\n    /* copy the pre-built stats fields */\n    memcpy(stats, &conn->super.stats, sizeof(conn->super.stats));\n\n    /* set or generate the non-pre-built stats fields here */\n    stats->rtt = conn->egress.loss.rtt;\n    stats->loss_thresholds = conn->egress.loss.thresholds;\n    stats->cc = conn->egress.cc;\n    quicly_ratemeter_report(&conn->egress.ratemeter, &stats->delivery_rate);\n    stats->num_sentmap_packets_largest = conn->egress.loss.sentmap.num_packets_largest;\n    stats->handshake_confirmed_msec = conn->super.stats.handshake_confirmed_msec;\n\n    return 0;\n}\n\nint quicly_get_delivery_rate(quicly_conn_t *conn, quicly_rate_t *delivery_rate)\n{\n    quicly_ratemeter_report(&conn->egress.ratemeter, delivery_rate);\n    return 0;\n}\n\nquicly_stream_id_t quicly_get_ingress_max_streams(quicly_conn_t *conn, int uni)\n{\n    quicly_maxsender_t *maxsender = uni ? &conn->ingress.max_streams.uni : &conn->ingress.max_streams.bidi;\n    return maxsender->max_committed;\n}\n\nvoid quicly_get_max_data(quicly_conn_t *conn, uint64_t *send_permitted, uint64_t *sent, uint64_t *consumed)\n{\n    if (send_permitted != NULL)\n        *send_permitted = conn->egress.max_data.permitted;\n    if (sent != NULL)\n        *sent = conn->egress.max_data.sent;\n    if (consumed != NULL)\n        *consumed = conn->ingress.max_data.bytes_consumed;\n}\n\nstatic void update_idle_timeout(quicly_conn_t *conn, int is_in_receive)\n{\n    if (!is_in_receive && !conn->idle_timeout.should_rearm_on_send)\n        return;\n\n    /* calculate the minimum of the two max_idle_timeout */\n    int64_t idle_msec = INT64_MAX;\n    if (conn->initial == NULL && conn->handshake == NULL && conn->super.remote.transport_params.max_idle_timeout != 0)\n        idle_msec = conn->super.remote.transport_params.max_idle_timeout;\n    if (conn->super.ctx->transport_params.max_idle_timeout != 0 && conn->super.ctx->transport_params.max_idle_timeout < idle_msec)\n        idle_msec = conn->super.ctx->transport_params.max_idle_timeout;\n\n    if (idle_msec == INT64_MAX)\n        return;\n\n    uint32_t three_pto = 3 * quicly_rtt_get_pto(&conn->egress.loss.rtt, conn->super.ctx->transport_params.max_ack_delay,\n                                                conn->egress.loss.conf->min_pto);\n    conn->idle_timeout.at = conn->stash.now + (idle_msec > three_pto ? idle_msec : three_pto);\n    conn->idle_timeout.should_rearm_on_send = is_in_receive;\n}\n\nstatic int scheduler_can_send(quicly_conn_t *conn)\n{\n    /* invoke the scheduler only when we are able to send stream data; skipping STATE_ACCEPTING is important as the application\n     * would not have setup data pointer. */\n    switch (conn->super.state) {\n    case QUICLY_STATE_FIRSTFLIGHT:\n    case QUICLY_STATE_CONNECTED:\n        break;\n    default:\n        return 0;\n    }\n\n    /* scheduler would never have data to send, until application keys become available */\n    if (conn->application == NULL)\n        return 0;\n\n    int conn_is_saturated = !(conn->egress.max_data.sent < conn->egress.max_data.permitted);\n    return conn->super.ctx->stream_scheduler->can_send(conn->super.ctx->stream_scheduler, conn, conn_is_saturated);\n}\n\nstatic void update_send_alarm(quicly_conn_t *conn, int can_send_stream_data, int is_after_send)\n{\n    int has_outstanding = conn->egress.loss.sentmap.bytes_in_flight != 0 || conn->super.remote.address_validation.send_probe,\n        handshake_is_in_progress = conn->initial != NULL || conn->handshake != NULL;\n    quicly_loss_update_alarm(&conn->egress.loss, conn->stash.now, conn->egress.last_retransmittable_sent_at, has_outstanding,\n                             can_send_stream_data, handshake_is_in_progress, conn->egress.max_data.sent, is_after_send);\n}\n\n/**\n * Updates the send alarm and adjusts the delivery rate estimator. This function is called from the receive path. From the sendp\n * path, `update_send_alarm` is called directly.\n */\nstatic void setup_next_send(quicly_conn_t *conn)\n{\n    int can_send_stream_data = scheduler_can_send(conn);\n\n    update_send_alarm(conn, can_send_stream_data, 0);\n\n    /* When the flow becomes application-limited due to receiving some information, stop collecting delivery rate samples. */\n    if (!can_send_stream_data)\n        quicly_ratemeter_not_cwnd_limited(&conn->egress.ratemeter, conn->egress.packet_number);\n}\n\nstatic int create_handshake_flow(quicly_conn_t *conn, size_t epoch)\n{\n    quicly_stream_t *stream;\n    int ret;\n\n    if ((stream = open_stream(conn, -(quicly_stream_id_t)(1 + epoch), 65536, 65536)) == NULL)\n        return PTLS_ERROR_NO_MEMORY;\n    if ((ret = quicly_streambuf_create(stream, sizeof(quicly_streambuf_t))) != 0) {\n        destroy_stream(stream, ret);\n        return ret;\n    }\n    stream->callbacks = &crypto_stream_callbacks;\n\n    return 0;\n}\n\nstatic void destroy_handshake_flow(quicly_conn_t *conn, size_t epoch)\n{\n    quicly_stream_t *stream = quicly_get_stream(conn, -(quicly_stream_id_t)(1 + epoch));\n    if (stream != NULL)\n        destroy_stream(stream, 0);\n}\n\nstatic struct st_quicly_pn_space_t *alloc_pn_space(size_t sz, uint32_t packet_tolerance)\n{\n    struct st_quicly_pn_space_t *space;\n\n    if ((space = malloc(sz)) == NULL)\n        return NULL;\n\n    quicly_ranges_init(&space->ack_queue);\n    space->largest_pn_received_at = INT64_MAX;\n    space->next_expected_packet_number = 0;\n    space->unacked_count = 0;\n    for (size_t i = 0; i < PTLS_ELEMENTSOF(space->ecn_counts); ++i)\n        space->ecn_counts[i] = 0;\n    space->packet_tolerance = packet_tolerance;\n    space->ignore_order = 0;\n    if (sz != sizeof(*space))\n        memset((uint8_t *)space + sizeof(*space), 0, sz - sizeof(*space));\n\n    return space;\n}\n\nstatic void do_free_pn_space(struct st_quicly_pn_space_t *space)\n{\n    quicly_ranges_clear(&space->ack_queue);\n    free(space);\n}\n\nstatic int record_pn(quicly_ranges_t *ranges, uint64_t pn, int *is_out_of_order)\n{\n    int ret;\n\n    *is_out_of_order = 0;\n\n    if (ranges->num_ranges != 0) {\n        /* fast path that is taken when we receive a packet in-order */\n        if (ranges->ranges[ranges->num_ranges - 1].end == pn) {\n            ranges->ranges[ranges->num_ranges - 1].end = pn + 1;\n            return 0;\n        }\n        *is_out_of_order = 1;\n    }\n\n    /* slow path; we add, then remove the oldest ranges when the number of ranges exceed the maximum */\n    if ((ret = quicly_ranges_add(ranges, pn, pn + 1)) != 0)\n        return ret;\n    if (ranges->num_ranges > QUICLY_MAX_ACK_BLOCKS)\n        quicly_ranges_drop_by_range_indices(ranges, ranges->num_ranges - QUICLY_MAX_ACK_BLOCKS, ranges->num_ranges);\n\n    return 0;\n}\n\nstatic int record_receipt(struct st_quicly_pn_space_t *space, uint64_t pn, uint8_t ecn, int is_ack_only, int64_t now,\n                          int64_t *send_ack_at, uint64_t *received_out_of_order)\n{\n    int ret, ack_now, is_out_of_order;\n\n    if ((ret = record_pn(&space->ack_queue, pn, &is_out_of_order)) != 0)\n        goto Exit;\n    if (is_out_of_order)\n        *received_out_of_order += 1;\n\n    ack_now = !is_ack_only && ((is_out_of_order && !space->ignore_order) || ecn == IPTOS_ECN_CE);\n\n    /* update largest_pn_received_at (TODO implement deduplication at an earlier moment?) */\n    if (space->ack_queue.ranges[space->ack_queue.num_ranges - 1].end == pn + 1)\n        space->largest_pn_received_at = now;\n\n    /* increment ecn counters */\n    if (ecn != 0)\n        space->ecn_counts[get_ecn_index_from_bits(ecn)] += 1;\n\n    /* if the received packet is ack-eliciting, update / schedule transmission of ACK */\n    if (!is_ack_only) {\n        space->unacked_count++;\n        if (space->unacked_count >= space->packet_tolerance)\n            ack_now = 1;\n    }\n\n    if (ack_now) {\n        *send_ack_at = now;\n    } else if (*send_ack_at == INT64_MAX && space->unacked_count != 0) {\n        *send_ack_at = now + QUICLY_DELAYED_ACK_TIMEOUT;\n    }\n\n    ret = 0;\nExit:\n    return ret;\n}\n\nstatic void free_handshake_space(struct st_quicly_handshake_space_t **space)\n{\n    if (*space != NULL) {\n        if ((*space)->cipher.ingress.aead != NULL)\n            dispose_cipher(&(*space)->cipher.ingress);\n        if ((*space)->cipher.egress.aead != NULL)\n            dispose_cipher(&(*space)->cipher.egress);\n        do_free_pn_space(&(*space)->super);\n        *space = NULL;\n    }\n}\n\nstatic int setup_cipher(quicly_conn_t *conn, size_t epoch, int is_enc, ptls_cipher_context_t **hp_ctx,\n                        ptls_aead_context_t **aead_ctx, ptls_aead_algorithm_t *aead, ptls_hash_algorithm_t *hash,\n                        const void *secret)\n{\n    /* quicly_accept builds cipher before instantiating a connection. In such case, we use the default crypto engine */\n    quicly_crypto_engine_t *engine = conn != NULL ? conn->super.ctx->crypto_engine : &quicly_default_crypto_engine;\n\n    return engine->setup_cipher(engine, conn, epoch, is_enc, hp_ctx, aead_ctx, aead, hash, secret);\n}\n\nstatic int setup_handshake_space_and_flow(quicly_conn_t *conn, size_t epoch)\n{\n    struct st_quicly_handshake_space_t **space = epoch == QUICLY_EPOCH_INITIAL ? &conn->initial : &conn->handshake;\n    if ((*space = (void *)alloc_pn_space(sizeof(struct st_quicly_handshake_space_t), 1)) == NULL)\n        return PTLS_ERROR_NO_MEMORY;\n    return create_handshake_flow(conn, epoch);\n}\n\nstatic void free_application_space(struct st_quicly_application_space_t **space)\n{\n    if (*space != NULL) {\n#define DISPOSE_INGRESS(label, func)                                                                                               \\\n    if ((*space)->cipher.ingress.label != NULL)                                                                                    \\\n    func((*space)->cipher.ingress.label)\n        DISPOSE_INGRESS(header_protection.zero_rtt, ptls_cipher_free);\n        DISPOSE_INGRESS(header_protection.one_rtt, ptls_cipher_free);\n        DISPOSE_INGRESS(aead[0], ptls_aead_free);\n        DISPOSE_INGRESS(aead[1], ptls_aead_free);\n#undef DISPOSE_INGRESS\n        if ((*space)->cipher.egress.key.aead != NULL)\n            dispose_cipher(&(*space)->cipher.egress.key);\n        ptls_clear_memory((*space)->cipher.egress.secret, sizeof((*space)->cipher.egress.secret));\n        do_free_pn_space(&(*space)->super);\n        *space = NULL;\n    }\n}\n\nstatic int setup_application_space(quicly_conn_t *conn)\n{\n    if ((conn->application =\n             (void *)alloc_pn_space(sizeof(struct st_quicly_application_space_t), QUICLY_DEFAULT_PACKET_TOLERANCE)) == NULL)\n        return PTLS_ERROR_NO_MEMORY;\n\n    /* prohibit key-update until receiving an ACK for an 1-RTT packet */\n    conn->application->cipher.egress.key_update_pn.last = 0;\n    conn->application->cipher.egress.key_update_pn.next = UINT64_MAX;\n\n    return create_handshake_flow(conn, QUICLY_EPOCH_1RTT);\n}\n\nstatic int discard_handshake_context(quicly_conn_t *conn, size_t epoch)\n{\n    int ret;\n\n    assert(epoch == QUICLY_EPOCH_INITIAL || epoch == QUICLY_EPOCH_HANDSHAKE);\n\n    if ((ret = discard_sentmap_by_epoch(conn, 1u << epoch)) != 0)\n        return ret;\n    destroy_handshake_flow(conn, epoch);\n    if (epoch == QUICLY_EPOCH_HANDSHAKE) {\n        assert(conn->stash.now != 0);\n        conn->super.stats.handshake_confirmed_msec = conn->stash.now - conn->created_at;\n    }\n    free_handshake_space(epoch == QUICLY_EPOCH_INITIAL ? &conn->initial : &conn->handshake);\n\n    return 0;\n}\n\nstatic int apply_remote_transport_params(quicly_conn_t *conn)\n{\n    int ret;\n\n    conn->egress.max_data.permitted = conn->super.remote.transport_params.max_data;\n    if ((ret = update_max_streams(&conn->egress.max_streams.uni, conn->super.remote.transport_params.max_streams_uni)) != 0)\n        return ret;\n    if ((ret = update_max_streams(&conn->egress.max_streams.bidi, conn->super.remote.transport_params.max_streams_bidi)) != 0)\n        return ret;\n\n    return 0;\n}\n\nstatic int update_1rtt_key(quicly_conn_t *conn, ptls_cipher_suite_t *cipher, int is_enc, ptls_aead_context_t **aead,\n                           uint8_t *secret)\n{\n    uint8_t new_secret[PTLS_MAX_DIGEST_SIZE];\n    ptls_aead_context_t *new_aead = NULL;\n    int ret;\n\n    /* generate next AEAD key */\n    if ((ret = ptls_hkdf_expand_label(cipher->hash, new_secret, cipher->hash->digest_size,\n                                      ptls_iovec_init(secret, cipher->hash->digest_size), \"quic ku\", ptls_iovec_init(NULL, 0),\n                                      NULL)) != 0)\n        goto Exit;\n    if ((ret = setup_cipher(conn, QUICLY_EPOCH_1RTT, is_enc, NULL, &new_aead, cipher->aead, cipher->hash, new_secret)) != 0)\n        goto Exit;\n\n    /* success! update AEAD and secret */\n    if (*aead != NULL)\n        ptls_aead_free(*aead);\n    *aead = new_aead;\n    new_aead = NULL;\n    memcpy(secret, new_secret, cipher->hash->digest_size);\n\n    ret = 0;\nExit:\n    if (new_aead != NULL)\n        ptls_aead_free(new_aead);\n    ptls_clear_memory(new_secret, cipher->hash->digest_size);\n    return ret;\n}\n\nstatic int update_1rtt_egress_key(quicly_conn_t *conn)\n{\n    struct st_quicly_application_space_t *space = conn->application;\n    ptls_cipher_suite_t *cipher = ptls_get_cipher(conn->crypto.tls);\n    int ret;\n\n    /* generate next AEAD key, and increment key phase if it succeeds */\n    if ((ret = update_1rtt_key(conn, cipher, 1, &space->cipher.egress.key.aead, space->cipher.egress.secret)) != 0)\n        return ret;\n    ++space->cipher.egress.key_phase;\n\n    /* signal that we are waiting for an ACK */\n    space->cipher.egress.key_update_pn.last = conn->egress.packet_number;\n    space->cipher.egress.key_update_pn.next = UINT64_MAX;\n\n    QUICLY_PROBE(CRYPTO_SEND_KEY_UPDATE, conn, conn->stash.now, space->cipher.egress.key_phase,\n                 QUICLY_PROBE_HEXDUMP(space->cipher.egress.secret, cipher->hash->digest_size));\n    QUICLY_LOG_CONN(crypto_send_key_update, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(phase, space->cipher.egress.key_phase);\n        PTLS_LOG_APPDATA_ELEMENT_HEXDUMP(secret, space->cipher.egress.secret, cipher->hash->digest_size);\n    });\n\n    return 0;\n}\n\nstatic int received_key_update(quicly_conn_t *conn, uint64_t newly_decrypted_key_phase)\n{\n    struct st_quicly_application_space_t *space = conn->application;\n\n    assert(space->cipher.ingress.key_phase.decrypted < newly_decrypted_key_phase);\n    assert(newly_decrypted_key_phase <= space->cipher.ingress.key_phase.prepared);\n\n    space->cipher.ingress.key_phase.decrypted = newly_decrypted_key_phase;\n\n    QUICLY_PROBE(CRYPTO_RECEIVE_KEY_UPDATE, conn, conn->stash.now, space->cipher.ingress.key_phase.decrypted,\n                 QUICLY_PROBE_HEXDUMP(space->cipher.ingress.secret, ptls_get_cipher(conn->crypto.tls)->hash->digest_size));\n    QUICLY_LOG_CONN(crypto_receive_key_update, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(phase, space->cipher.ingress.key_phase.decrypted);\n        PTLS_LOG_APPDATA_ELEMENT_HEXDUMP(secret, space->cipher.ingress.secret,\n                                         ptls_get_cipher(conn->crypto.tls)->hash->digest_size);\n    });\n\n    if (space->cipher.egress.key_phase < space->cipher.ingress.key_phase.decrypted) {\n        return update_1rtt_egress_key(conn);\n    } else {\n        return 0;\n    }\n}\n\nstatic inline void update_open_count(quicly_context_t *ctx, ssize_t delta)\n{\n    if (ctx->update_open_count != NULL)\n        ctx->update_open_count->cb(ctx->update_open_count, delta);\n}\n\nvoid quicly_free(quicly_conn_t *conn)\n{\n    lock_now(conn, 0);\n\n    QUICLY_PROBE(FREE, conn, conn->stash.now);\n    QUICLY_LOG_CONN(free, conn, {});\n\n#if QUICLY_USE_DTRACE\n    if (QUICLY_CONN_STATS_ENABLED()) {\n        quicly_stats_t stats;\n        quicly_get_stats(conn, &stats);\n        QUICLY_PROBE(CONN_STATS, conn, conn->stash.now, &stats, sizeof(stats));\n        // TODO: emit stats with QUICLY_LOG_CONN()\n    }\n#endif\n    destroy_all_streams(conn, 0, 1);\n    update_open_count(conn->super.ctx, -1);\n    clear_datagram_frame_payloads(conn);\n\n    quicly_maxsender_dispose(&conn->ingress.max_data.sender);\n    quicly_maxsender_dispose(&conn->ingress.max_streams.uni);\n    quicly_maxsender_dispose(&conn->ingress.max_streams.bidi);\n    quicly_loss_dispose(&conn->egress.loss);\n\n    kh_destroy(quicly_stream_t, conn->streams);\n\n    assert(!quicly_linklist_is_linked(&conn->egress.pending_streams.blocked.uni));\n    assert(!quicly_linklist_is_linked(&conn->egress.pending_streams.blocked.bidi));\n    assert(!quicly_linklist_is_linked(&conn->egress.pending_streams.control));\n    assert(!quicly_linklist_is_linked(&conn->super._default_scheduler.active));\n    assert(!quicly_linklist_is_linked(&conn->super._default_scheduler.blocked));\n\n    free_handshake_space(&conn->initial);\n    free_handshake_space(&conn->handshake);\n    free_application_space(&conn->application);\n\n    ptls_buffer_dispose(&conn->crypto.transport_params.buf);\n    if (conn->crypto.async_in_progress) {\n        /* When async signature generation is inflight, `ptls_free` will be called from `quicly_resume_handshake` laterwards. */\n        *ptls_get_data_ptr(conn->crypto.tls) = NULL;\n    } else {\n        ptls_free(conn->crypto.tls);\n    }\n\n    unlock_now(conn);\n\n    free(conn->token.base);\n    free(conn);\n}\n\nstatic int setup_initial_key(struct st_quicly_cipher_context_t *ctx, ptls_cipher_suite_t *cs, const void *master_secret,\n                             const char *label, int is_enc, quicly_conn_t *conn)\n{\n    uint8_t aead_secret[PTLS_MAX_DIGEST_SIZE];\n    int ret;\n\n    if ((ret = ptls_hkdf_expand_label(cs->hash, aead_secret, cs->hash->digest_size,\n                                      ptls_iovec_init(master_secret, cs->hash->digest_size), label, ptls_iovec_init(NULL, 0),\n                                      NULL)) != 0)\n        goto Exit;\n    if ((ret = setup_cipher(conn, QUICLY_EPOCH_INITIAL, is_enc, &ctx->header_protection, &ctx->aead, cs->aead, cs->hash,\n                            aead_secret)) != 0)\n        goto Exit;\n\nExit:\n    ptls_clear_memory(aead_secret, sizeof(aead_secret));\n    return ret;\n}\n\n/**\n * @param conn maybe NULL when called by quicly_accept\n */\nstatic int setup_initial_encryption(ptls_cipher_suite_t *cs, struct st_quicly_cipher_context_t *ingress,\n                                    struct st_quicly_cipher_context_t *egress, ptls_iovec_t cid, int is_client, ptls_iovec_t salt,\n                                    quicly_conn_t *conn)\n{\n    static const char *labels[2] = {\"client in\", \"server in\"};\n    uint8_t secret[PTLS_MAX_DIGEST_SIZE];\n    int ret;\n\n    /* extract master secret */\n    if ((ret = ptls_hkdf_extract(cs->hash, secret, salt, cid)) != 0)\n        goto Exit;\n\n    /* create aead contexts */\n    if (ingress != NULL && (ret = setup_initial_key(ingress, cs, secret, labels[is_client], 0, conn)) != 0)\n        goto Exit;\n    if (egress != NULL && (ret = setup_initial_key(egress, cs, secret, labels[!is_client], 1, conn)) != 0) {\n        if (ingress != NULL)\n            dispose_cipher(ingress);\n        goto Exit;\n    }\n\nExit:\n    ptls_clear_memory(secret, sizeof(secret));\n    return ret;\n}\n\nstatic int reinstall_initial_encryption(quicly_conn_t *conn, int err_code_if_unknown_version)\n{\n    const struct st_ptls_salt_t *salt;\n\n    /* get salt */\n    if ((salt = get_salt(conn->super.version)) == NULL)\n        return err_code_if_unknown_version;\n\n    /* dispose existing context */\n    dispose_cipher(&conn->initial->cipher.ingress);\n    dispose_cipher(&conn->initial->cipher.egress);\n\n    /* setup encryption context */\n    return setup_initial_encryption(\n        get_aes128gcmsha256(conn->super.ctx), &conn->initial->cipher.ingress, &conn->initial->cipher.egress,\n        ptls_iovec_init(conn->super.remote.cid_set.cids[0].cid.cid, conn->super.remote.cid_set.cids[0].cid.len), 1,\n        ptls_iovec_init(salt->initial, sizeof(salt->initial)), NULL);\n}\n\nstatic int apply_stream_frame(quicly_stream_t *stream, quicly_stream_frame_t *frame)\n{\n    int ret;\n\n    QUICLY_PROBE(STREAM_RECEIVE, stream->conn, stream->conn->stash.now, stream, frame->offset, frame->data.len);\n    QUICLY_LOG_CONN(stream_receive, stream->conn, {\n        PTLS_LOG_ELEMENT_SIGNED(stream_id, stream->stream_id);\n        PTLS_LOG_ELEMENT_UNSIGNED(off, frame->offset);\n        PTLS_LOG_ELEMENT_UNSIGNED(len, frame->data.len);\n    });\n\n    if (quicly_recvstate_transfer_complete(&stream->recvstate))\n        return 0;\n\n    /* flow control */\n    if (stream->stream_id >= 0) {\n        /* STREAMs */\n        uint64_t max_stream_data = frame->offset + frame->data.len;\n        if ((int64_t)stream->_recv_aux.window < (int64_t)max_stream_data - (int64_t)stream->recvstate.data_off)\n            return QUICLY_TRANSPORT_ERROR_FLOW_CONTROL;\n        if (stream->recvstate.received.ranges[stream->recvstate.received.num_ranges - 1].end < max_stream_data) {\n            uint64_t newly_received =\n                max_stream_data - stream->recvstate.received.ranges[stream->recvstate.received.num_ranges - 1].end;\n            if (stream->conn->ingress.max_data.bytes_consumed + newly_received >\n                stream->conn->ingress.max_data.sender.max_committed)\n                return QUICLY_TRANSPORT_ERROR_FLOW_CONTROL;\n            stream->conn->ingress.max_data.bytes_consumed += newly_received;\n            /* FIXME send MAX_DATA if necessary */\n        }\n    } else {\n        /* CRYPTO streams; maybe add different limit for 1-RTT CRYPTO? */\n        if (frame->offset + frame->data.len > stream->conn->super.ctx->max_crypto_bytes)\n            return QUICLY_TRANSPORT_ERROR_CRYPTO_BUFFER_EXCEEDED;\n    }\n\n    /* update recvbuf */\n    size_t apply_len = frame->data.len;\n    if ((ret = quicly_recvstate_update(&stream->recvstate, frame->offset, &apply_len, frame->is_fin,\n                                       stream->_recv_aux.max_ranges)) != 0)\n        return ret;\n\n    if (apply_len != 0 || quicly_recvstate_transfer_complete(&stream->recvstate)) {\n        uint64_t buf_offset = frame->offset + frame->data.len - apply_len - stream->recvstate.data_off;\n        const void *apply_src = frame->data.base + frame->data.len - apply_len;\n        QUICLY_PROBE(STREAM_ON_RECEIVE, stream->conn, stream->conn->stash.now, stream, (size_t)buf_offset, apply_src, apply_len);\n        QUICLY_LOG_CONN(stream_on_receive, stream->conn, {\n            PTLS_LOG_ELEMENT_SIGNED(stream_id, stream->stream_id);\n            PTLS_LOG_ELEMENT_UNSIGNED(off, buf_offset);\n            PTLS_LOG_APPDATA_ELEMENT_HEXDUMP(src, apply_src, apply_len);\n        });\n        stream->callbacks->on_receive(stream, (size_t)buf_offset, apply_src, apply_len);\n        if (stream->conn->super.state >= QUICLY_STATE_CLOSING)\n            return QUICLY_ERROR_IS_CLOSING;\n    }\n\n    if (should_send_max_stream_data(stream))\n        sched_stream_control(stream);\n\n    if (stream_is_destroyable(stream))\n        destroy_stream(stream, 0);\n\n    return 0;\n}\n\nint quicly_encode_transport_parameter_list(ptls_buffer_t *buf, const quicly_transport_parameters_t *params,\n                                           const quicly_cid_t *original_dcid, const quicly_cid_t *initial_scid,\n                                           const quicly_cid_t *retry_scid, const void *stateless_reset_token, size_t expand_by)\n{\n    int ret;\n\n#define PUSH_TP(buf, id, block)                                                                                                    \\\n    do {                                                                                                                           \\\n        ptls_buffer_push_quicint((buf), (id));                                                                                     \\\n        ptls_buffer_push_block((buf), -1, block);                                                                                  \\\n    } while (0)\n\n    PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_MAX_UDP_PAYLOAD_SIZE,\n            { ptls_buffer_push_quicint(buf, params->max_udp_payload_size); });\n    if (params->max_stream_data.bidi_local != 0)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_BIDI_LOCAL,\n                { ptls_buffer_push_quicint(buf, params->max_stream_data.bidi_local); });\n    if (params->max_stream_data.bidi_remote != 0)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_BIDI_REMOTE,\n                { ptls_buffer_push_quicint(buf, params->max_stream_data.bidi_remote); });\n    if (params->max_stream_data.uni != 0)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_UNI,\n                { ptls_buffer_push_quicint(buf, params->max_stream_data.uni); });\n    if (params->max_data != 0)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_DATA, { ptls_buffer_push_quicint(buf, params->max_data); });\n    if (params->max_idle_timeout != 0)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_MAX_IDLE_TIMEOUT, { ptls_buffer_push_quicint(buf, params->max_idle_timeout); });\n    if (original_dcid != NULL)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_ORIGINAL_CONNECTION_ID,\n                { ptls_buffer_pushv(buf, original_dcid->cid, original_dcid->len); });\n    if (initial_scid != NULL)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_SOURCE_CONNECTION_ID,\n                { ptls_buffer_pushv(buf, initial_scid->cid, initial_scid->len); });\n    if (retry_scid != NULL)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_RETRY_SOURCE_CONNECTION_ID,\n                { ptls_buffer_pushv(buf, retry_scid->cid, retry_scid->len); });\n    if (stateless_reset_token != NULL)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_STATELESS_RESET_TOKEN,\n                { ptls_buffer_pushv(buf, stateless_reset_token, QUICLY_STATELESS_RESET_TOKEN_LEN); });\n    if (params->max_streams_bidi != 0)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAMS_BIDI,\n                { ptls_buffer_push_quicint(buf, params->max_streams_bidi); });\n    if (params->max_streams_uni != 0)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAMS_UNI,\n                { ptls_buffer_push_quicint(buf, params->max_streams_uni); });\n    if (QUICLY_LOCAL_ACK_DELAY_EXPONENT != QUICLY_DEFAULT_ACK_DELAY_EXPONENT)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_ACK_DELAY_EXPONENT,\n                { ptls_buffer_push_quicint(buf, QUICLY_LOCAL_ACK_DELAY_EXPONENT); });\n    if (QUICLY_LOCAL_MAX_ACK_DELAY != QUICLY_DEFAULT_MAX_ACK_DELAY)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_MAX_ACK_DELAY, { ptls_buffer_push_quicint(buf, QUICLY_LOCAL_MAX_ACK_DELAY); });\n    if (params->min_ack_delay_usec != UINT64_MAX) {\n        /* TODO consider the value we should advertise. */\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_MIN_ACK_DELAY,\n                { ptls_buffer_push_quicint(buf, QUICLY_LOCAL_MAX_ACK_DELAY * 1000 /* in microseconds */); });\n    }\n    if (params->disable_active_migration)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_DISABLE_ACTIVE_MIGRATION, {});\n    if (QUICLY_LOCAL_ACTIVE_CONNECTION_ID_LIMIT != QUICLY_DEFAULT_ACTIVE_CONNECTION_ID_LIMIT)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_ACTIVE_CONNECTION_ID_LIMIT,\n                { ptls_buffer_push_quicint(buf, QUICLY_LOCAL_ACTIVE_CONNECTION_ID_LIMIT); });\n    if (params->max_datagram_frame_size != 0)\n        PUSH_TP(buf, QUICLY_TRANSPORT_PARAMETER_ID_MAX_DATAGRAM_FRAME_SIZE,\n                { ptls_buffer_push_quicint(buf, params->max_datagram_frame_size); });\n    /* if requested, add a greasing TP of 1 MTU size so that CH spans across multiple packets */\n    if (expand_by != 0) {\n        PUSH_TP(buf, 31 * 100 + 27, {\n            if ((ret = ptls_buffer_reserve(buf, expand_by)) != 0)\n                goto Exit;\n            memset(buf->base + buf->off, 0, expand_by);\n            buf->off += expand_by;\n        });\n    }\n\n#undef PUSH_TP\n\n    ret = 0;\nExit:\n    return ret;\n}\n\n/**\n * sentinel used for indicating that the corresponding TP should be ignored\n */\nstatic const quicly_cid_t _tp_cid_ignore;\n#define tp_cid_ignore (*(quicly_cid_t *)&_tp_cid_ignore)\n\nint quicly_decode_transport_parameter_list(quicly_transport_parameters_t *params, quicly_cid_t *original_dcid,\n                                           quicly_cid_t *initial_scid, quicly_cid_t *retry_scid, void *stateless_reset_token,\n                                           const uint8_t *src, const uint8_t *end)\n{\n/* When non-negative, tp_index contains the literal position within the list of transport parameters recognized by this function.\n * That index is being used to find duplicates using a 64-bit bitmap (found_bits). When the transport parameter is being processed,\n * tp_index is set to -1. */\n#define DECODE_TP(_id, block)                                                                                                      \\\n    do {                                                                                                                           \\\n        if (tp_index >= 0) {                                                                                                       \\\n            if (id == (_id)) {                                                                                                     \\\n                if ((found_bits & ((uint64_t)1 << tp_index)) != 0) {                                                               \\\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;                                                              \\\n                    goto Exit;                                                                                                     \\\n                }                                                                                                                  \\\n                found_bits |= (uint64_t)1 << tp_index;                                                                             \\\n                {block} tp_index = -1;                                                                                             \\\n            } else {                                                                                                               \\\n                ++tp_index;                                                                                                        \\\n            }                                                                                                                      \\\n        }                                                                                                                          \\\n    } while (0)\n#define DECODE_CID_TP(_id, dest)                                                                                                   \\\n    DECODE_TP(_id, {                                                                                                               \\\n        size_t cidl = end - src;                                                                                                   \\\n        if (cidl > QUICLY_MAX_CID_LEN_V1) {                                                                                        \\\n            ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;                                                                      \\\n            goto Exit;                                                                                                             \\\n        }                                                                                                                          \\\n        if (dest == NULL) {                                                                                                        \\\n            ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;                                                                      \\\n            goto Exit;                                                                                                             \\\n        } else if (dest != &tp_cid_ignore) {                                                                                       \\\n            quicly_set_cid(dest, ptls_iovec_init(src, cidl));                                                                      \\\n        }                                                                                                                          \\\n        src = end;                                                                                                                 \\\n    });\n\n    uint64_t found_bits = 0;\n    int ret;\n\n    /* set parameters to their default values */\n    *params = default_transport_params;\n\n    /* Set optional parameters to UINT8_MAX. It is used to as a sentinel for detecting missing TPs. */\n    if (original_dcid != NULL && original_dcid != &tp_cid_ignore)\n        original_dcid->len = UINT8_MAX;\n    if (initial_scid != NULL && initial_scid != &tp_cid_ignore)\n        initial_scid->len = UINT8_MAX;\n    if (retry_scid != NULL && retry_scid != &tp_cid_ignore)\n        retry_scid->len = UINT8_MAX;\n\n    /* decode the parameters block */\n    while (src != end) {\n        uint64_t id;\n        if ((id = quicly_decodev(&src, end)) == UINT64_MAX) {\n            ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n            goto Exit;\n        }\n        int tp_index = 0;\n        ptls_decode_open_block(src, end, -1, {\n            DECODE_CID_TP(QUICLY_TRANSPORT_PARAMETER_ID_ORIGINAL_CONNECTION_ID, original_dcid);\n            DECODE_CID_TP(QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_SOURCE_CONNECTION_ID, initial_scid);\n            DECODE_CID_TP(QUICLY_TRANSPORT_PARAMETER_ID_RETRY_SOURCE_CONNECTION_ID, retry_scid);\n            DECODE_TP(QUICLY_TRANSPORT_PARAMETER_ID_MAX_UDP_PAYLOAD_SIZE, {\n                uint64_t v;\n                if ((v = ptls_decode_quicint(&src, end)) == UINT64_MAX) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n                if (v < 1200) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n                if (v > UINT16_MAX)\n                    v = UINT16_MAX;\n                params->max_udp_payload_size = (uint16_t)v;\n            });\n            DECODE_TP(QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_BIDI_LOCAL, {\n                if ((params->max_stream_data.bidi_local = ptls_decode_quicint(&src, end)) == UINT64_MAX) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n            });\n            DECODE_TP(QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_BIDI_REMOTE, {\n                if ((params->max_stream_data.bidi_remote = ptls_decode_quicint(&src, end)) == UINT64_MAX) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n            });\n            DECODE_TP(QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_UNI, {\n                if ((params->max_stream_data.uni = ptls_decode_quicint(&src, end)) == UINT64_MAX) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n            });\n            DECODE_TP(QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_DATA, {\n                if ((params->max_data = ptls_decode_quicint(&src, end)) == UINT64_MAX) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n            });\n            DECODE_TP(QUICLY_TRANSPORT_PARAMETER_ID_STATELESS_RESET_TOKEN, {\n                if (!(stateless_reset_token != NULL && end - src == QUICLY_STATELESS_RESET_TOKEN_LEN)) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n                memcpy(stateless_reset_token, src, QUICLY_STATELESS_RESET_TOKEN_LEN);\n                src = end;\n            });\n            DECODE_TP(QUICLY_TRANSPORT_PARAMETER_ID_MAX_IDLE_TIMEOUT, {\n                if ((params->max_idle_timeout = ptls_decode_quicint(&src, end)) == UINT64_MAX) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n            });\n            DECODE_TP(QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAMS_BIDI, {\n                if ((params->max_streams_bidi = ptls_decode_quicint(&src, end)) == UINT64_MAX) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n            });\n            DECODE_TP(QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAMS_UNI, {\n                if ((params->max_streams_uni = ptls_decode_quicint(&src, end)) == UINT64_MAX) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n            });\n            DECODE_TP(QUICLY_TRANSPORT_PARAMETER_ID_ACK_DELAY_EXPONENT, {\n                uint64_t v;\n                if ((v = ptls_decode_quicint(&src, end)) == UINT64_MAX) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n                if (v > 20) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n                params->ack_delay_exponent = (uint8_t)v;\n            });\n            DECODE_TP(QUICLY_TRANSPORT_PARAMETER_ID_MAX_ACK_DELAY, {\n                uint64_t v;\n                if ((v = ptls_decode_quicint(&src, end)) == UINT64_MAX) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n                if (v >= 16384) { /* \"values of 2^14 or greater are invalid\" */\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n                params->max_ack_delay = (uint16_t)v;\n            });\n            DECODE_TP(QUICLY_TRANSPORT_PARAMETER_ID_MIN_ACK_DELAY, {\n                if ((params->min_ack_delay_usec = ptls_decode_quicint(&src, end)) == UINT64_MAX) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n                if (params->min_ack_delay_usec >= 16777216) { /* \"values of 2^24 or greater are invalid\" */\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n            });\n            DECODE_TP(QUICLY_TRANSPORT_PARAMETER_ID_ACTIVE_CONNECTION_ID_LIMIT, {\n                uint64_t v;\n                if ((v = ptls_decode_quicint(&src, end)) == UINT64_MAX) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n                if (v < QUICLY_MIN_ACTIVE_CONNECTION_ID_LIMIT) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n                params->active_connection_id_limit = v;\n            });\n            DECODE_TP(QUICLY_TRANSPORT_PARAMETER_ID_DISABLE_ACTIVE_MIGRATION, { params->disable_active_migration = 1; });\n            DECODE_TP(QUICLY_TRANSPORT_PARAMETER_ID_MAX_DATAGRAM_FRAME_SIZE, {\n                uint64_t v;\n                if ((v = ptls_decode_quicint(&src, end)) == UINT64_MAX) {\n                    ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                    goto Exit;\n                }\n                if (v > UINT16_MAX)\n                    v = UINT16_MAX;\n                params->max_datagram_frame_size = (uint16_t)v;\n            });\n            /* skip unknown extension */\n            if (tp_index >= 0)\n                src = end;\n        });\n    }\n\n    /* check consistency between the transport parameters */\n    if (params->min_ack_delay_usec != UINT64_MAX) {\n        if (params->min_ack_delay_usec > params->max_ack_delay * 1000) {\n            ret = QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;\n            goto Exit;\n        }\n    }\n\n    /* check the absence of CIDs */\n    if ((original_dcid != NULL && original_dcid->len == UINT8_MAX) || (initial_scid != NULL && initial_scid->len == UINT8_MAX) ||\n        (retry_scid != NULL && retry_scid->len == UINT8_MAX)) {\n        ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n        goto Exit;\n    }\n\n    ret = 0;\nExit:\n    if (ret == PTLS_ALERT_DECODE_ERROR)\n        ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n    return ret;\n\n#undef DECODE_TP\n#undef DECODE_CID_TP\n}\n\nstatic uint16_t get_transport_parameters_extension_id(uint32_t quic_version)\n{\n    switch (quic_version) {\n    case QUICLY_PROTOCOL_VERSION_DRAFT27:\n    case QUICLY_PROTOCOL_VERSION_DRAFT29:\n        return QUICLY_TLS_EXTENSION_TYPE_TRANSPORT_PARAMETERS_DRAFT;\n    default:\n        return QUICLY_TLS_EXTENSION_TYPE_TRANSPORT_PARAMETERS_FINAL;\n    }\n}\n\nstatic int collect_transport_parameters(ptls_t *tls, struct st_ptls_handshake_properties_t *properties, uint16_t type)\n{\n    quicly_conn_t *conn = (void *)((char *)properties - offsetof(quicly_conn_t, crypto.handshake_properties));\n    return type == get_transport_parameters_extension_id(conn->super.version);\n}\n\nstatic quicly_conn_t *create_connection(quicly_context_t *ctx, uint32_t protocol_version, const char *server_name,\n                                        struct sockaddr *remote_addr, struct sockaddr *local_addr, ptls_iovec_t *remote_cid,\n                                        const quicly_cid_plaintext_t *local_cid, ptls_handshake_properties_t *handshake_properties,\n                                        void *appdata, uint32_t initcwnd)\n{\n    ptls_t *tls = NULL;\n    quicly_conn_t *conn;\n\n    /* consistency checks */\n    assert(remote_addr != NULL && remote_addr->sa_family != AF_UNSPEC);\n    if (ctx->transport_params.max_datagram_frame_size != 0)\n        assert(ctx->receive_datagram_frame != NULL);\n\n    /* create TLS context */\n    if ((tls = ptls_new(ctx->tls, server_name == NULL)) == NULL)\n        return NULL;\n    if (server_name != NULL && ptls_set_server_name(tls, server_name, strlen(server_name)) != 0) {\n        ptls_free(tls);\n        return NULL;\n    }\n\n    /* allocate memory and start creating QUIC context */\n    if ((conn = malloc(sizeof(*conn))) == NULL) {\n        ptls_free(tls);\n        return NULL;\n    }\n    memset(conn, 0, sizeof(*conn));\n    conn->super.ctx = ctx;\n    conn->super.data = appdata;\n    lock_now(conn, 0);\n    conn->created_at = conn->stash.now;\n    conn->super.stats.handshake_confirmed_msec = UINT64_MAX;\n    set_address(&conn->super.local.address, local_addr);\n    set_address(&conn->super.remote.address, remote_addr);\n    quicly_local_cid_init_set(&conn->super.local.cid_set, ctx->cid_encryptor, local_cid);\n    conn->super.local.long_header_src_cid = conn->super.local.cid_set.cids[0].cid;\n    quicly_remote_cid_init_set(&conn->super.remote.cid_set, remote_cid, ctx->tls->random_bytes);\n    conn->super.state = QUICLY_STATE_FIRSTFLIGHT;\n    if (server_name != NULL) {\n        conn->super.local.bidi.next_stream_id = 0;\n        conn->super.local.uni.next_stream_id = 2;\n        conn->super.remote.bidi.next_stream_id = 1;\n        conn->super.remote.uni.next_stream_id = 3;\n    } else {\n        conn->super.local.bidi.next_stream_id = 1;\n        conn->super.local.uni.next_stream_id = 3;\n        conn->super.remote.bidi.next_stream_id = 0;\n        conn->super.remote.uni.next_stream_id = 2;\n    }\n    conn->super.remote.transport_params = default_transport_params;\n    conn->super.version = protocol_version;\n    conn->super.remote.largest_retire_prior_to = 0;\n    quicly_linklist_init(&conn->super._default_scheduler.active);\n    quicly_linklist_init(&conn->super._default_scheduler.blocked);\n    conn->streams = kh_init(quicly_stream_t);\n    quicly_maxsender_init(&conn->ingress.max_data.sender, conn->super.ctx->transport_params.max_data);\n    quicly_maxsender_init(&conn->ingress.max_streams.uni, conn->super.ctx->transport_params.max_streams_uni);\n    quicly_maxsender_init(&conn->ingress.max_streams.bidi, conn->super.ctx->transport_params.max_streams_bidi);\n    quicly_loss_init(&conn->egress.loss, &conn->super.ctx->loss,\n                     conn->super.ctx->loss.default_initial_rtt /* FIXME remember initial_rtt in session ticket */,\n                     &conn->super.remote.transport_params.max_ack_delay, &conn->super.remote.transport_params.ack_delay_exponent);\n    conn->egress.next_pn_to_skip =\n        calc_next_pn_to_skip(conn->super.ctx->tls, 0, initcwnd, conn->super.ctx->initial_egress_max_udp_payload_size);\n    conn->egress.max_udp_payload_size = conn->super.ctx->initial_egress_max_udp_payload_size;\n    init_max_streams(&conn->egress.max_streams.uni);\n    init_max_streams(&conn->egress.max_streams.bidi);\n    conn->egress.ack_frequency.update_at = INT64_MAX;\n    conn->egress.send_ack_at = INT64_MAX;\n    conn->super.ctx->init_cc->cb(conn->super.ctx->init_cc, &conn->egress.cc, initcwnd, conn->stash.now);\n    conn->egress.ecn.state = conn->super.ctx->enable_ecn ? QUICLY_ECN_PROBING : QUICLY_ECN_OFF;\n    quicly_retire_cid_init(&conn->egress.retire_cid);\n    quicly_linklist_init(&conn->egress.pending_streams.blocked.uni);\n    quicly_linklist_init(&conn->egress.pending_streams.blocked.bidi);\n    quicly_linklist_init(&conn->egress.pending_streams.control);\n    quicly_ratemeter_init(&conn->egress.ratemeter);\n    conn->crypto.tls = tls;\n    if (handshake_properties != NULL) {\n        assert(handshake_properties->additional_extensions == NULL);\n        assert(handshake_properties->collect_extension == NULL);\n        assert(handshake_properties->collected_extensions == NULL);\n        conn->crypto.handshake_properties = *handshake_properties;\n    } else {\n        conn->crypto.handshake_properties = (ptls_handshake_properties_t){{{{NULL}}}};\n    }\n    conn->crypto.handshake_properties.collect_extension = collect_transport_parameters;\n    conn->retry_scid.len = UINT8_MAX;\n    conn->idle_timeout.at = INT64_MAX;\n    conn->idle_timeout.should_rearm_on_send = 1;\n    conn->stash.on_ack_stream.active_acked_cache.stream_id = INT64_MIN;\n\n    *ptls_get_data_ptr(tls) = conn;\n\n    update_open_count(conn->super.ctx, 1);\n\n    return conn;\n}\n\nstatic int client_collected_extensions(ptls_t *tls, ptls_handshake_properties_t *properties, ptls_raw_extension_t *slots)\n{\n    quicly_conn_t *conn = (void *)((char *)properties - offsetof(quicly_conn_t, crypto.handshake_properties));\n    int ret;\n\n    assert(properties->client.early_data_acceptance != PTLS_EARLY_DATA_ACCEPTANCE_UNKNOWN);\n\n    if (slots[0].type == UINT16_MAX) {\n        ret = PTLS_ALERT_MISSING_EXTENSION;\n        goto Exit;\n    }\n    assert(slots[0].type == get_transport_parameters_extension_id(conn->super.version));\n    assert(slots[1].type == UINT16_MAX);\n\n    const uint8_t *src = slots[0].data.base, *end = src + slots[0].data.len;\n    quicly_transport_parameters_t params;\n    quicly_cid_t original_dcid, initial_scid, retry_scid = {};\n\n    /* obtain pointer to initial CID of the peer. It is guaranteed to exist in the first slot, as TP is received before any frame\n     * that updates the CID set. */\n    quicly_remote_cid_t *remote_cid = &conn->super.remote.cid_set.cids[0];\n    assert(remote_cid->sequence == 0);\n\n    /* decode */\n    if ((ret = quicly_decode_transport_parameter_list(&params, needs_cid_auth(conn) || is_retry(conn) ? &original_dcid : NULL,\n                                                      needs_cid_auth(conn) ? &initial_scid : &tp_cid_ignore,\n                                                      needs_cid_auth(conn) ? is_retry(conn) ? &retry_scid : NULL : &tp_cid_ignore,\n                                                      remote_cid->stateless_reset_token, src, end)) != 0)\n        goto Exit;\n\n    /* validate CIDs */\n    if (needs_cid_auth(conn) || is_retry(conn)) {\n        if (!quicly_cid_is_equal(&conn->super.original_dcid, ptls_iovec_init(original_dcid.cid, original_dcid.len))) {\n            ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n            goto Exit;\n        }\n    }\n    if (needs_cid_auth(conn)) {\n        if (!quicly_cid_is_equal(&remote_cid->cid, ptls_iovec_init(initial_scid.cid, initial_scid.len))) {\n            ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n            goto Exit;\n        }\n        if (is_retry(conn)) {\n            if (!quicly_cid_is_equal(&conn->retry_scid, ptls_iovec_init(retry_scid.cid, retry_scid.len))) {\n                ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;\n                goto Exit;\n            }\n        }\n    }\n\n    if (properties->client.early_data_acceptance == PTLS_EARLY_DATA_ACCEPTED) {\n#define ZERORTT_VALIDATE(x)                                                                                                        \\\n    if (params.x < conn->super.remote.transport_params.x) {                                                                        \\\n        ret = QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER;                                                                          \\\n        goto Exit;                                                                                                                 \\\n    }\n        ZERORTT_VALIDATE(max_data);\n        ZERORTT_VALIDATE(max_stream_data.bidi_local);\n        ZERORTT_VALIDATE(max_stream_data.bidi_remote);\n        ZERORTT_VALIDATE(max_stream_data.uni);\n        ZERORTT_VALIDATE(max_streams_bidi);\n        ZERORTT_VALIDATE(max_streams_uni);\n#undef ZERORTT_VALIDATE\n    }\n\n    /* store the results */\n    conn->super.remote.transport_params = params;\n    ack_frequency_set_next_update_at(conn);\n\nExit:\n    return ret; /* negative error codes used to transmit QUIC errors through picotls */\n}\n\nint quicly_connect(quicly_conn_t **_conn, quicly_context_t *ctx, const char *server_name, struct sockaddr *dest_addr,\n                   struct sockaddr *src_addr, const quicly_cid_plaintext_t *new_cid, ptls_iovec_t address_token,\n                   ptls_handshake_properties_t *handshake_properties, const quicly_transport_parameters_t *resumed_transport_params,\n                   void *appdata)\n{\n    const struct st_ptls_salt_t *salt;\n    quicly_conn_t *conn = NULL;\n    const quicly_cid_t *server_cid;\n    ptls_buffer_t buf;\n    size_t epoch_offsets[5] = {0};\n    size_t max_early_data_size = 0;\n    int ret;\n\n    if ((salt = get_salt(ctx->initial_version)) == NULL) {\n        if ((ctx->initial_version & 0x0f0f0f0f) == 0x0a0a0a0a) {\n            /* greasing version, use our own greasing salt */\n            static const struct st_ptls_salt_t grease_salt = {.initial = {0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe,\n                                                                          0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad,\n                                                                          0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef}};\n            salt = &grease_salt;\n        } else {\n            ret = QUICLY_ERROR_INVALID_INITIAL_VERSION;\n            goto Exit;\n        }\n    }\n\n    if ((conn = create_connection(\n             ctx, ctx->initial_version, server_name, dest_addr, src_addr, NULL, new_cid, handshake_properties, appdata,\n             quicly_cc_calc_initial_cwnd(ctx->initcwnd_packets, ctx->transport_params.max_udp_payload_size))) == NULL) {\n        ret = PTLS_ERROR_NO_MEMORY;\n        goto Exit;\n    }\n    conn->super.remote.address_validation.validated = 1;\n    conn->super.remote.address_validation.send_probe = 1;\n    if (address_token.len != 0) {\n        if ((conn->token.base = malloc(address_token.len)) == NULL) {\n            ret = PTLS_ERROR_NO_MEMORY;\n            goto Exit;\n        }\n        memcpy(conn->token.base, address_token.base, address_token.len);\n        conn->token.len = address_token.len;\n    }\n    server_cid = quicly_get_remote_cid(conn);\n    conn->super.original_dcid = *server_cid;\n\n    QUICLY_PROBE(CONNECT, conn, conn->stash.now, conn->super.version);\n    QUICLY_LOG_CONN(connect, conn, { PTLS_LOG_ELEMENT_UNSIGNED(version, conn->super.version); });\n\n    if ((ret = setup_handshake_space_and_flow(conn, QUICLY_EPOCH_INITIAL)) != 0)\n        goto Exit;\n    if ((ret = setup_initial_encryption(get_aes128gcmsha256(ctx), &conn->initial->cipher.ingress, &conn->initial->cipher.egress,\n                                        ptls_iovec_init(server_cid->cid, server_cid->len), 1,\n                                        ptls_iovec_init(salt->initial, sizeof(salt->initial)), conn)) != 0)\n        goto Exit;\n\n    /* handshake (we always encode authentication CIDs, as we do not (yet) regenerate ClientHello when receiving Retry) */\n    ptls_buffer_init(&conn->crypto.transport_params.buf, \"\", 0);\n    if ((ret = quicly_encode_transport_parameter_list(\n             &conn->crypto.transport_params.buf, &conn->super.ctx->transport_params, NULL, &conn->super.local.cid_set.cids[0].cid,\n             NULL, NULL, conn->super.ctx->expand_client_hello ? conn->super.ctx->initial_egress_max_udp_payload_size : 0)) != 0)\n        goto Exit;\n    conn->crypto.transport_params.ext[0] =\n        (ptls_raw_extension_t){QUICLY_TLS_EXTENSION_TYPE_TRANSPORT_PARAMETERS_FINAL,\n                               {conn->crypto.transport_params.buf.base, conn->crypto.transport_params.buf.off}};\n    conn->crypto.transport_params.ext[1] =\n        (ptls_raw_extension_t){QUICLY_TLS_EXTENSION_TYPE_TRANSPORT_PARAMETERS_DRAFT,\n                               {conn->crypto.transport_params.buf.base, conn->crypto.transport_params.buf.off}};\n    conn->crypto.transport_params.ext[2] = (ptls_raw_extension_t){UINT16_MAX};\n    conn->crypto.handshake_properties.additional_extensions = conn->crypto.transport_params.ext;\n    conn->crypto.handshake_properties.collected_extensions = client_collected_extensions;\n\n    ptls_buffer_init(&buf, \"\", 0);\n    if (resumed_transport_params != NULL)\n        conn->crypto.handshake_properties.client.max_early_data_size = &max_early_data_size;\n    ret = ptls_handle_message(conn->crypto.tls, &buf, epoch_offsets, 0, NULL, 0, &conn->crypto.handshake_properties);\n    conn->crypto.handshake_properties.client.max_early_data_size = NULL;\n    if (ret != PTLS_ERROR_IN_PROGRESS) {\n        assert(ret > 0); /* no QUIC errors */\n        goto Exit;\n    }\n    write_crypto_data(conn, &buf, epoch_offsets);\n    ptls_buffer_dispose(&buf);\n\n    if (max_early_data_size != 0) {\n        /* when attempting 0-RTT, apply the remembered transport parameters */\n#define APPLY(n) conn->super.remote.transport_params.n = resumed_transport_params->n\n        APPLY(active_connection_id_limit);\n        APPLY(max_data);\n        APPLY(max_stream_data.bidi_local);\n        APPLY(max_stream_data.bidi_remote);\n        APPLY(max_stream_data.uni);\n        APPLY(max_streams_bidi);\n        APPLY(max_streams_uni);\n#undef APPLY\n        if ((ret = apply_remote_transport_params(conn)) != 0)\n            goto Exit;\n    }\n\n    *_conn = conn;\n    ret = 0;\n\nExit:\n    if (conn != NULL)\n        unlock_now(conn);\n    if (ret != 0) {\n        if (conn != NULL)\n            quicly_free(conn);\n    }\n    return ret;\n}\n\nstatic int server_collected_extensions(ptls_t *tls, ptls_handshake_properties_t *properties, ptls_raw_extension_t *slots)\n{\n    quicly_conn_t *conn = (void *)((char *)properties - offsetof(quicly_conn_t, crypto.handshake_properties));\n    quicly_cid_t initial_scid;\n    int ret;\n\n    if (slots[0].type == UINT16_MAX) {\n        ret = PTLS_ALERT_MISSING_EXTENSION;\n        goto Exit;\n    }\n    assert(slots[0].type == get_transport_parameters_extension_id(conn->super.version));\n    assert(slots[1].type == UINT16_MAX);\n\n    { /* decode transport_parameters extension */\n        const uint8_t *src = slots[0].data.base, *end = src + slots[0].data.len;\n        if ((ret = quicly_decode_transport_parameter_list(&conn->super.remote.transport_params,\n                                                          needs_cid_auth(conn) ? NULL : &tp_cid_ignore,\n                                                          needs_cid_auth(conn) ? &initial_scid : &tp_cid_ignore,\n                                                          needs_cid_auth(conn) ? NULL : &tp_cid_ignore, NULL, src, end)) != 0)\n            goto Exit;\n        if (needs_cid_auth(conn) &&\n            !quicly_cid_is_equal(&conn->super.remote.cid_set.cids[0].cid, ptls_iovec_init(initial_scid.cid, initial_scid.len))) {\n            ret = QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;\n            goto Exit;\n        }\n    }\n\n    /* setup ack frequency */\n    ack_frequency_set_next_update_at(conn);\n\n    /* update UDP max payload size to:\n     * max(current, min(max_the_remote_sent, remote.tp.max_udp_payload_size, local.tp.max_udp_payload_size)) */\n    assert(conn->initial != NULL);\n    if (conn->egress.max_udp_payload_size < conn->initial->largest_ingress_udp_payload_size) {\n        uint16_t size = conn->initial->largest_ingress_udp_payload_size;\n        if (size > conn->super.remote.transport_params.max_udp_payload_size)\n            size = conn->super.remote.transport_params.max_udp_payload_size;\n        if (size > conn->super.ctx->transport_params.max_udp_payload_size)\n            size = conn->super.ctx->transport_params.max_udp_payload_size;\n        conn->egress.max_udp_payload_size = size;\n    }\n\n    /* set transport_parameters extension to be sent in EE */\n    assert(properties->additional_extensions == NULL);\n    ptls_buffer_init(&conn->crypto.transport_params.buf, \"\", 0);\n    assert(conn->super.local.cid_set.cids[0].sequence == 0 && \"make sure that local_cid is in expected state before sending SRT\");\n    if ((ret = quicly_encode_transport_parameter_list(\n             &conn->crypto.transport_params.buf, &conn->super.ctx->transport_params,\n             needs_cid_auth(conn) || is_retry(conn) ? &conn->super.original_dcid : NULL,\n             needs_cid_auth(conn) ? &conn->super.local.cid_set.cids[0].cid : NULL,\n             needs_cid_auth(conn) && is_retry(conn) ? &conn->retry_scid : NULL,\n             conn->super.ctx->cid_encryptor != NULL ? conn->super.local.cid_set.cids[0].stateless_reset_token : NULL, 0)) != 0)\n        goto Exit;\n    properties->additional_extensions = conn->crypto.transport_params.ext;\n    conn->crypto.transport_params.ext[0] =\n        (ptls_raw_extension_t){get_transport_parameters_extension_id(conn->super.version),\n                               {conn->crypto.transport_params.buf.base, conn->crypto.transport_params.buf.off}};\n    conn->crypto.transport_params.ext[1] = (ptls_raw_extension_t){UINT16_MAX};\n    conn->crypto.handshake_properties.additional_extensions = conn->crypto.transport_params.ext;\n\n    ret = 0;\n\nExit:\n    return ret;\n}\n\nstatic size_t aead_decrypt_core(ptls_aead_context_t *aead, uint64_t pn, quicly_decoded_packet_t *packet, size_t aead_off)\n{\n    return ptls_aead_decrypt(aead, packet->octets.base + aead_off, packet->octets.base + aead_off, packet->octets.len - aead_off,\n                             pn, packet->octets.base, aead_off);\n}\n\nstatic int aead_decrypt_fixed_key(void *ctx, uint64_t pn, quicly_decoded_packet_t *packet, size_t aead_off, size_t *ptlen)\n{\n    ptls_aead_context_t *aead = ctx;\n\n    if ((*ptlen = aead_decrypt_core(aead, pn, packet, aead_off)) == SIZE_MAX)\n        return QUICLY_ERROR_PACKET_IGNORED;\n    return 0;\n}\n\nstatic int aead_decrypt_1rtt(void *ctx, uint64_t pn, quicly_decoded_packet_t *packet, size_t aead_off, size_t *ptlen)\n{\n    quicly_conn_t *conn = ctx;\n    struct st_quicly_application_space_t *space = conn->application;\n    size_t aead_index = (packet->octets.base[0] & QUICLY_KEY_PHASE_BIT) != 0;\n    int ret;\n\n    /* prepare key, when not available (yet) */\n    if (space->cipher.ingress.aead[aead_index] == NULL) {\n    Retry_1RTT : {\n        /* Replace the AEAD key at the alternative slot (note: decryption key slots are shared by 0-RTT and 1-RTT), at the same time\n         * dropping 0-RTT header protection key. */\n        if (conn->application->cipher.ingress.header_protection.zero_rtt != NULL) {\n            ptls_cipher_free(conn->application->cipher.ingress.header_protection.zero_rtt);\n            conn->application->cipher.ingress.header_protection.zero_rtt = NULL;\n        }\n        ptls_cipher_suite_t *cipher = ptls_get_cipher(conn->crypto.tls);\n        if ((ret = update_1rtt_key(conn, cipher, 0, &space->cipher.ingress.aead[aead_index], space->cipher.ingress.secret)) != 0)\n            return ret;\n        ++space->cipher.ingress.key_phase.prepared;\n        QUICLY_PROBE(CRYPTO_RECEIVE_KEY_UPDATE_PREPARE, conn, conn->stash.now, space->cipher.ingress.key_phase.prepared,\n                     QUICLY_PROBE_HEXDUMP(space->cipher.ingress.secret, cipher->hash->digest_size));\n        QUICLY_LOG_CONN(crypto_receive_key_update_prepare, conn, {\n            PTLS_LOG_ELEMENT_UNSIGNED(phase, space->cipher.ingress.key_phase.prepared);\n            PTLS_LOG_APPDATA_ELEMENT_HEXDUMP(secret, space->cipher.ingress.secret, cipher->hash->digest_size);\n        });\n    }\n    }\n\n    /* decrypt */\n    ptls_aead_context_t *aead = space->cipher.ingress.aead[aead_index];\n    if ((*ptlen = aead_decrypt_core(aead, pn, packet, aead_off)) == SIZE_MAX) {\n        /* retry with a new key, if possible */\n        if (space->cipher.ingress.key_phase.decrypted == space->cipher.ingress.key_phase.prepared &&\n            space->cipher.ingress.key_phase.decrypted % 2 != aead_index) {\n            /* reapply AEAD to revert payload to the encrypted form. This assumes that the cipher used in AEAD is CTR. */\n            aead_decrypt_core(aead, pn, packet, aead_off);\n            goto Retry_1RTT;\n        }\n        /* otherwise return failure */\n        return QUICLY_ERROR_PACKET_IGNORED;\n    }\n\n    /* update the confirmed key phase and also the egress key phase, if necessary */\n    if (space->cipher.ingress.key_phase.prepared != space->cipher.ingress.key_phase.decrypted &&\n        space->cipher.ingress.key_phase.prepared % 2 == aead_index) {\n        if ((ret = received_key_update(conn, space->cipher.ingress.key_phase.prepared)) != 0)\n            return ret;\n    }\n\n    return 0;\n}\n\nstatic int do_decrypt_packet(ptls_cipher_context_t *header_protection,\n                             int (*aead_cb)(void *, uint64_t, quicly_decoded_packet_t *, size_t, size_t *), void *aead_ctx,\n                             uint64_t *next_expected_pn, quicly_decoded_packet_t *packet, uint64_t *pn, ptls_iovec_t *payload)\n{\n    size_t encrypted_len = packet->octets.len - packet->encrypted_off;\n    uint8_t hpmask[5] = {0};\n    uint32_t pnbits = 0;\n    size_t pnlen, ptlen, i;\n    int ret;\n\n    /* decipher the header protection, as well as obtaining pnbits, pnlen */\n    if (encrypted_len < header_protection->algo->iv_size + QUICLY_MAX_PN_SIZE) {\n        *pn = UINT64_MAX;\n        return QUICLY_ERROR_PACKET_IGNORED;\n    }\n    ptls_cipher_init(header_protection, packet->octets.base + packet->encrypted_off + QUICLY_MAX_PN_SIZE);\n    ptls_cipher_encrypt(header_protection, hpmask, hpmask, sizeof(hpmask));\n    packet->octets.base[0] ^= hpmask[0] & (QUICLY_PACKET_IS_LONG_HEADER(packet->octets.base[0]) ? 0xf : 0x1f);\n    pnlen = (packet->octets.base[0] & 0x3) + 1;\n    for (i = 0; i != pnlen; ++i) {\n        packet->octets.base[packet->encrypted_off + i] ^= hpmask[i + 1];\n        pnbits = (pnbits << 8) | packet->octets.base[packet->encrypted_off + i];\n    }\n\n    size_t aead_off = packet->encrypted_off + pnlen;\n    *pn = quicly_determine_packet_number(pnbits, pnlen * 8, *next_expected_pn);\n\n    /* AEAD decryption */\n    if ((ret = (*aead_cb)(aead_ctx, *pn, packet, aead_off, &ptlen)) != 0) {\n        return ret;\n    }\n    if (*next_expected_pn <= *pn)\n        *next_expected_pn = *pn + 1;\n\n    *payload = ptls_iovec_init(packet->octets.base + aead_off, ptlen);\n    return 0;\n}\n\nstatic int decrypt_packet(ptls_cipher_context_t *header_protection,\n                          int (*aead_cb)(void *, uint64_t, quicly_decoded_packet_t *, size_t, size_t *), void *aead_ctx,\n                          uint64_t *next_expected_pn, quicly_decoded_packet_t *packet, uint64_t *pn, ptls_iovec_t *payload)\n{\n    int ret;\n\n    /* decrypt ourselves, or use the pre-decrypted input */\n    if (packet->decrypted.pn == UINT64_MAX) {\n        if ((ret = do_decrypt_packet(header_protection, aead_cb, aead_ctx, next_expected_pn, packet, pn, payload)) != 0)\n            return ret;\n    } else {\n        *payload = ptls_iovec_init(packet->octets.base + packet->encrypted_off, packet->octets.len - packet->encrypted_off);\n        *pn = packet->decrypted.pn;\n        if (aead_cb == aead_decrypt_1rtt) {\n            quicly_conn_t *conn = aead_ctx;\n            if (conn->application->cipher.ingress.key_phase.decrypted < packet->decrypted.key_phase) {\n                if ((ret = received_key_update(conn, packet->decrypted.key_phase)) != 0)\n                    return ret;\n            }\n        }\n        if (*next_expected_pn < *pn)\n            *next_expected_pn = *pn + 1;\n    }\n\n    /* check reserved bits after AEAD decryption */\n    if ((packet->octets.base[0] & (QUICLY_PACKET_IS_LONG_HEADER(packet->octets.base[0]) ? QUICLY_LONG_HEADER_RESERVED_BITS\n                                                                                        : QUICLY_SHORT_HEADER_RESERVED_BITS)) !=\n        0) {\n        return QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;\n    }\n    if (payload->len == 0) {\n        return QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;\n    }\n\n    return 0;\n}\n\nstatic int do_on_ack_ack(quicly_conn_t *conn, const quicly_sent_packet_t *packet, uint64_t start, uint64_t start_length,\n                         struct st_quicly_sent_ack_additional_t *additional, size_t additional_capacity)\n{\n    /* find the pn space */\n    struct st_quicly_pn_space_t *space;\n    switch (packet->ack_epoch) {\n    case QUICLY_EPOCH_INITIAL:\n        space = &conn->initial->super;\n        break;\n    case QUICLY_EPOCH_HANDSHAKE:\n        space = &conn->handshake->super;\n        break;\n    case QUICLY_EPOCH_1RTT:\n        space = &conn->application->super;\n        break;\n    default:\n        assert(!\"FIXME\");\n        return QUICLY_TRANSPORT_ERROR_INTERNAL;\n    }\n\n    /* subtract given ACK ranges */\n    int ret;\n    uint64_t end = start + start_length;\n    if ((ret = quicly_ranges_subtract(&space->ack_queue, start, end)) != 0)\n        return ret;\n    for (size_t i = 0; i < additional_capacity && additional[i].gap != 0; ++i) {\n        start = end + additional[i].gap;\n        end = start + additional[i].length;\n        if ((ret = quicly_ranges_subtract(&space->ack_queue, start, end)) != 0)\n            return ret;\n    }\n\n    /* make adjustments */\n    if (space->ack_queue.num_ranges == 0) {\n        space->largest_pn_received_at = INT64_MAX;\n        space->unacked_count = 0;\n    } else if (space->ack_queue.num_ranges > QUICLY_MAX_ACK_BLOCKS) {\n        quicly_ranges_drop_by_range_indices(&space->ack_queue, space->ack_queue.num_ranges - QUICLY_MAX_ACK_BLOCKS,\n                                            space->ack_queue.num_ranges);\n    }\n\n    return 0;\n}\n\nstatic int on_ack_ack_ranges64(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    quicly_conn_t *conn = (quicly_conn_t *)((char *)map - offsetof(quicly_conn_t, egress.loss.sentmap));\n\n    /* TODO log */\n\n    return acked ? do_on_ack_ack(conn, packet, sent->data.ack.start, sent->data.ack.ranges64.start_length,\n                                 sent->data.ack.ranges64.additional, PTLS_ELEMENTSOF(sent->data.ack.ranges64.additional))\n                 : 0;\n}\n\nstatic int on_ack_ack_ranges8(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    quicly_conn_t *conn = (quicly_conn_t *)((char *)map - offsetof(quicly_conn_t, egress.loss.sentmap));\n\n    /* TODO log */\n\n    return acked ? do_on_ack_ack(conn, packet, sent->data.ack.start, sent->data.ack.ranges8.start_length,\n                                 sent->data.ack.ranges8.additional, PTLS_ELEMENTSOF(sent->data.ack.ranges8.additional))\n                 : 0;\n}\n\nstatic int on_ack_stream_ack_one(quicly_conn_t *conn, quicly_stream_id_t stream_id, quicly_sendstate_sent_t *sent)\n{\n    quicly_stream_t *stream;\n    int ret;\n\n    if ((stream = quicly_get_stream(conn, stream_id)) == NULL)\n        return 0;\n\n    size_t bytes_to_shift;\n    if ((ret = quicly_sendstate_acked(&stream->sendstate, sent, &bytes_to_shift)) != 0)\n        return ret;\n    if (bytes_to_shift != 0) {\n        QUICLY_PROBE(STREAM_ON_SEND_SHIFT, stream->conn, stream->conn->stash.now, stream, bytes_to_shift);\n        stream->callbacks->on_send_shift(stream, bytes_to_shift);\n        QUICLY_LOG_CONN(stream_on_send_shift, stream->conn, {\n            PTLS_LOG_ELEMENT_SIGNED(stream_id, stream->stream_id);\n            PTLS_LOG_ELEMENT_UNSIGNED(delta, bytes_to_shift);\n        });\n    }\n    if (stream_is_destroyable(stream)) {\n        destroy_stream(stream, 0);\n    } else if (stream->_send_aux.reset_stream.sender_state == QUICLY_SENDER_STATE_NONE) {\n        resched_stream_data(stream);\n    }\n\n    return 0;\n}\n\nstatic int on_ack_stream_ack_cached(quicly_conn_t *conn)\n{\n    int ret;\n\n    if (conn->stash.on_ack_stream.active_acked_cache.stream_id == INT64_MIN)\n        return 0;\n    ret = on_ack_stream_ack_one(conn, conn->stash.on_ack_stream.active_acked_cache.stream_id,\n                                &conn->stash.on_ack_stream.active_acked_cache.args);\n    conn->stash.on_ack_stream.active_acked_cache.stream_id = INT64_MIN;\n    return ret;\n}\n\nstatic int on_ack_stream(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    quicly_conn_t *conn = (quicly_conn_t *)((char *)map - offsetof(quicly_conn_t, egress.loss.sentmap));\n    int ret;\n\n    if (acked) {\n\n        QUICLY_PROBE(STREAM_ACKED, conn, conn->stash.now, sent->data.stream.stream_id, sent->data.stream.args.start,\n                     sent->data.stream.args.end - sent->data.stream.args.start);\n        QUICLY_LOG_CONN(stream_acked, conn, {\n            PTLS_LOG_ELEMENT_SIGNED(stream_id, sent->data.stream.stream_id);\n            PTLS_LOG_ELEMENT_UNSIGNED(off, sent->data.stream.args.start);\n            PTLS_LOG_ELEMENT_UNSIGNED(len, sent->data.stream.args.end - sent->data.stream.args.start);\n        });\n\n        if (packet->frames_in_flight && conn->stash.on_ack_stream.active_acked_cache.stream_id == sent->data.stream.stream_id &&\n            conn->stash.on_ack_stream.active_acked_cache.args.end == sent->data.stream.args.start) {\n            /* Fast path: append the newly supplied range to the existing cached range. */\n            conn->stash.on_ack_stream.active_acked_cache.args.end = sent->data.stream.args.end;\n        } else {\n            /* Slow path: submit the cached range, and if possible, cache the newly supplied range. Else submit the newly supplied\n             * range directly. */\n            if ((ret = on_ack_stream_ack_cached(conn)) != 0)\n                return ret;\n            if (packet->frames_in_flight) {\n                conn->stash.on_ack_stream.active_acked_cache.stream_id = sent->data.stream.stream_id;\n                conn->stash.on_ack_stream.active_acked_cache.args = sent->data.stream.args;\n            } else {\n                if ((ret = on_ack_stream_ack_one(conn, sent->data.stream.stream_id, &sent->data.stream.args)) != 0)\n                    return ret;\n            }\n        }\n\n    } else {\n\n        QUICLY_PROBE(STREAM_LOST, conn, conn->stash.now, sent->data.stream.stream_id, sent->data.stream.args.start,\n                     sent->data.stream.args.end - sent->data.stream.args.start);\n        QUICLY_LOG_CONN(stream_lost, conn, {\n            PTLS_LOG_ELEMENT_SIGNED(stream_id, sent->data.stream.stream_id);\n            PTLS_LOG_ELEMENT_UNSIGNED(off, sent->data.stream.args.start);\n            PTLS_LOG_ELEMENT_UNSIGNED(len, sent->data.stream.args.end - sent->data.stream.args.start);\n        });\n\n        quicly_stream_t *stream;\n        if ((stream = quicly_get_stream(conn, sent->data.stream.stream_id)) == NULL)\n            return 0;\n        /* FIXME handle rto error */\n        if ((ret = quicly_sendstate_lost(&stream->sendstate, &sent->data.stream.args)) != 0)\n            return ret;\n        if (stream->_send_aux.reset_stream.sender_state == QUICLY_SENDER_STATE_NONE)\n            resched_stream_data(stream);\n    }\n\n    return 0;\n}\n\nstatic int on_ack_max_stream_data(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    quicly_conn_t *conn = (quicly_conn_t *)((char *)map - offsetof(quicly_conn_t, egress.loss.sentmap));\n    quicly_stream_t *stream;\n\n    if ((stream = quicly_get_stream(conn, sent->data.stream.stream_id)) != NULL) {\n        if (acked) {\n            quicly_maxsender_acked(&stream->_send_aux.max_stream_data_sender, &sent->data.max_stream_data.args);\n        } else {\n            quicly_maxsender_lost(&stream->_send_aux.max_stream_data_sender, &sent->data.max_stream_data.args);\n            if (should_send_max_stream_data(stream))\n                sched_stream_control(stream);\n        }\n    }\n\n    return 0;\n}\n\nstatic int on_ack_max_data(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    quicly_conn_t *conn = (quicly_conn_t *)((char *)map - offsetof(quicly_conn_t, egress.loss.sentmap));\n\n    if (acked) {\n        quicly_maxsender_acked(&conn->ingress.max_data.sender, &sent->data.max_data.args);\n    } else {\n        quicly_maxsender_lost(&conn->ingress.max_data.sender, &sent->data.max_data.args);\n    }\n\n    return 0;\n}\n\nstatic int on_ack_max_streams(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    quicly_conn_t *conn = (quicly_conn_t *)((char *)map - offsetof(quicly_conn_t, egress.loss.sentmap));\n    quicly_maxsender_t *maxsender = sent->data.max_streams.uni ? &conn->ingress.max_streams.uni : &conn->ingress.max_streams.bidi;\n    assert(maxsender != NULL); /* we would only receive an ACK if we have sent the frame */\n\n    if (acked) {\n        quicly_maxsender_acked(maxsender, &sent->data.max_streams.args);\n    } else {\n        quicly_maxsender_lost(maxsender, &sent->data.max_streams.args);\n    }\n\n    return 0;\n}\n\nstatic void on_ack_stream_state_sender(quicly_sender_state_t *sender_state, int acked)\n{\n    *sender_state = acked ? QUICLY_SENDER_STATE_ACKED : QUICLY_SENDER_STATE_SEND;\n}\n\nstatic int on_ack_reset_stream(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    quicly_conn_t *conn = (quicly_conn_t *)((char *)map - offsetof(quicly_conn_t, egress.loss.sentmap));\n    quicly_stream_t *stream;\n\n    if ((stream = quicly_get_stream(conn, sent->data.stream_state_sender.stream_id)) != NULL) {\n        on_ack_stream_state_sender(&stream->_send_aux.reset_stream.sender_state, acked);\n        if (stream_is_destroyable(stream))\n            destroy_stream(stream, 0);\n    }\n\n    return 0;\n}\n\nstatic int on_ack_stop_sending(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    quicly_conn_t *conn = (quicly_conn_t *)((char *)map - offsetof(quicly_conn_t, egress.loss.sentmap));\n    quicly_stream_t *stream;\n\n    if ((stream = quicly_get_stream(conn, sent->data.stream_state_sender.stream_id)) != NULL) {\n        on_ack_stream_state_sender(&stream->_send_aux.stop_sending.sender_state, acked);\n        if (stream->_send_aux.stop_sending.sender_state != QUICLY_SENDER_STATE_ACKED)\n            sched_stream_control(stream);\n    }\n\n    return 0;\n}\n\nstatic int on_ack_streams_blocked(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    quicly_conn_t *conn = (quicly_conn_t *)((char *)map - offsetof(quicly_conn_t, egress.loss.sentmap));\n    struct st_quicly_max_streams_t *m =\n        sent->data.streams_blocked.uni ? &conn->egress.max_streams.uni : &conn->egress.max_streams.bidi;\n\n    if (acked) {\n        quicly_maxsender_acked(&m->blocked_sender, &sent->data.streams_blocked.args);\n    } else {\n        quicly_maxsender_lost(&m->blocked_sender, &sent->data.streams_blocked.args);\n    }\n\n    return 0;\n}\n\nstatic int on_ack_handshake_done(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    quicly_conn_t *conn = (quicly_conn_t *)((char *)map - offsetof(quicly_conn_t, egress.loss.sentmap));\n\n    /* When lost, reschedule for transmission. When acked, suppress retransmission if scheduled. */\n    if (acked) {\n        conn->egress.pending_flows &= ~QUICLY_PENDING_FLOW_HANDSHAKE_DONE_BIT;\n    } else {\n        conn->egress.pending_flows |= QUICLY_PENDING_FLOW_HANDSHAKE_DONE_BIT;\n    }\n    return 0;\n}\n\nstatic int on_ack_data_blocked(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    quicly_conn_t *conn = (quicly_conn_t *)((char *)map - offsetof(quicly_conn_t, egress.loss.sentmap));\n\n    if (conn->egress.max_data.permitted == sent->data.data_blocked.offset) {\n        if (acked) {\n            conn->egress.data_blocked = QUICLY_SENDER_STATE_ACKED;\n        } else if (packet->frames_in_flight && conn->egress.data_blocked == QUICLY_SENDER_STATE_UNACKED) {\n            conn->egress.data_blocked = QUICLY_SENDER_STATE_SEND;\n            conn->egress.pending_flows |= QUICLY_PENDING_FLOW_OTHERS_BIT;\n        }\n    }\n\n    return 0;\n}\n\nstatic int on_ack_stream_data_blocked_frame(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked,\n                                            quicly_sent_t *sent)\n{\n    quicly_conn_t *conn = (quicly_conn_t *)((char *)map - offsetof(quicly_conn_t, egress.loss.sentmap));\n    quicly_stream_t *stream;\n\n    if ((stream = quicly_get_stream(conn, sent->data.stream_data_blocked.stream_id)) == NULL)\n        return 0;\n\n    if (stream->_send_aux.max_stream_data == sent->data.stream_data_blocked.offset) {\n        if (acked) {\n            stream->_send_aux.blocked = QUICLY_SENDER_STATE_ACKED;\n        } else if (packet->frames_in_flight && stream->_send_aux.blocked == QUICLY_SENDER_STATE_UNACKED) {\n            stream->_send_aux.blocked = QUICLY_SENDER_STATE_SEND;\n            sched_stream_control(stream);\n        }\n    }\n\n    return 0;\n}\n\nstatic int on_ack_new_token(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    quicly_conn_t *conn = (quicly_conn_t *)((char *)map - offsetof(quicly_conn_t, egress.loss.sentmap));\n\n    if (sent->data.new_token.is_inflight) {\n        --conn->egress.new_token.num_inflight;\n        sent->data.new_token.is_inflight = 0;\n    }\n    if (acked) {\n        QUICLY_PROBE(NEW_TOKEN_ACKED, conn, conn->stash.now, sent->data.new_token.generation);\n        QUICLY_LOG_CONN(new_token_acked, conn, { PTLS_LOG_ELEMENT_UNSIGNED(generation, sent->data.new_token.generation); });\n        if (conn->egress.new_token.max_acked < sent->data.new_token.generation)\n            conn->egress.new_token.max_acked = sent->data.new_token.generation;\n    }\n\n    if (conn->egress.new_token.num_inflight == 0 && conn->egress.new_token.max_acked < conn->egress.new_token.generation)\n        conn->egress.pending_flows |= QUICLY_PENDING_FLOW_OTHERS_BIT;\n\n    return 0;\n}\n\nstatic int on_ack_new_connection_id(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    quicly_conn_t *conn = (quicly_conn_t *)((char *)map - offsetof(quicly_conn_t, egress.loss.sentmap));\n    uint64_t sequence = sent->data.new_connection_id.sequence;\n\n    if (acked) {\n        quicly_local_cid_on_acked(&conn->super.local.cid_set, sequence);\n    } else {\n        if (quicly_local_cid_on_lost(&conn->super.local.cid_set, sequence))\n            conn->egress.pending_flows |= QUICLY_PENDING_FLOW_OTHERS_BIT;\n    }\n\n    return 0;\n}\n\nstatic int on_ack_retire_connection_id(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    quicly_conn_t *conn = (quicly_conn_t *)((char *)map - offsetof(quicly_conn_t, egress.loss.sentmap));\n    uint64_t sequence = sent->data.retire_connection_id.sequence;\n\n    if (!acked)\n        schedule_retire_connection_id_frame(conn, sequence);\n\n    return 0;\n}\n\nstatic int should_send_datagram_frame(quicly_conn_t *conn)\n{\n    if (conn->egress.datagram_frame_payloads.count == 0)\n        return 0;\n    if (conn->application == NULL)\n        return 0;\n    if (conn->application->cipher.egress.key.aead == NULL)\n        return 0;\n    return 1;\n}\n\nstatic inline uint64_t calc_amplification_limit_allowance(quicly_conn_t *conn)\n{\n    if (conn->super.remote.address_validation.validated)\n        return UINT64_MAX;\n    uint64_t budget = conn->super.stats.num_bytes.received * conn->super.ctx->pre_validation_amplification_limit;\n    if (budget <= conn->super.stats.num_bytes.sent)\n        return 0;\n    return budget - conn->super.stats.num_bytes.sent;\n}\n\n/* Helper function to compute send window based on:\n * * state of peer validation,\n * * current cwnd,\n * * minimum send requirements in |min_bytes_to_send|, and\n * * if sending is to be restricted to the minimum, indicated in |restrict_sending|\n */\nstatic size_t calc_send_window(quicly_conn_t *conn, size_t min_bytes_to_send, uint64_t amp_window, int restrict_sending)\n{\n    uint64_t window = 0;\n    if (restrict_sending) {\n        /* Send min_bytes_to_send on PTO */\n        window = min_bytes_to_send;\n    } else {\n        /* Limit to cwnd */\n        if (conn->egress.cc.cwnd > conn->egress.loss.sentmap.bytes_in_flight)\n            window = conn->egress.cc.cwnd - conn->egress.loss.sentmap.bytes_in_flight;\n        /* Allow at least one packet on time-threshold loss detection */\n        window = window > min_bytes_to_send ? window : min_bytes_to_send;\n    }\n    /* Cap the window by the amount allowed by address validation */\n    if (amp_window < window)\n        window = amp_window;\n\n    return window;\n}\n\n/**\n * Checks if the server is waiting for ClientFinished. When that is the case, the loss timer is deactivated, to avoid repeatedly\n * sending 1-RTT packets while the client spends time verifying the certificate chain at the same time buffering 1-RTT packets.\n */\nstatic int is_point5rtt_with_no_handshake_data_to_send(quicly_conn_t *conn)\n{\n    /* bail out unless this is a server-side connection waiting for ClientFinished */\n    if (!(conn->handshake != NULL && conn->application != NULL && !quicly_is_client(conn)))\n        return 0;\n    quicly_stream_t *stream = quicly_get_stream(conn, (quicly_stream_id_t)-1 - QUICLY_EPOCH_HANDSHAKE);\n    assert(stream != NULL);\n    return stream->sendstate.pending.num_ranges == 0 && stream->sendstate.acked.ranges[0].end == stream->sendstate.size_inflight;\n}\n\nint64_t quicly_get_first_timeout(quicly_conn_t *conn)\n{\n    if (conn->super.state >= QUICLY_STATE_CLOSING)\n        return conn->egress.send_ack_at;\n\n    if (should_send_datagram_frame(conn))\n        return 0;\n\n    uint64_t amp_window = calc_amplification_limit_allowance(conn);\n\n    if (calc_send_window(conn, 0, amp_window, 0) > 0) {\n        if (conn->egress.pending_flows != 0) {\n            /* crypto streams (as indicated by lower 4 bits) can be sent whenever CWND is available; other flows need application\n             * packet number space */\n            if (conn->application != NULL && conn->application->cipher.egress.key.header_protection != NULL)\n                return 0;\n            if ((conn->egress.pending_flows & 0xf) != 0)\n                return 0;\n        }\n        if (quicly_linklist_is_linked(&conn->egress.pending_streams.control))\n            return 0;\n        if (scheduler_can_send(conn))\n            return 0;\n    }\n\n    /* if something can be sent, return the earliest timeout. Otherwise return the idle timeout. */\n    int64_t at = conn->idle_timeout.at;\n    if (amp_window > 0) {\n        if (conn->egress.loss.alarm_at < at && !is_point5rtt_with_no_handshake_data_to_send(conn))\n            at = conn->egress.loss.alarm_at;\n        if (conn->egress.send_ack_at < at)\n            at = conn->egress.send_ack_at;\n    }\n\n    return at;\n}\n\nuint64_t quicly_get_next_expected_packet_number(quicly_conn_t *conn)\n{\n    if (!conn->application)\n        return UINT64_MAX;\n\n    return conn->application->super.next_expected_packet_number;\n}\n\n/**\n * data structure that is used during one call through quicly_send()\n */\nstruct st_quicly_send_context_t {\n    /**\n     * current encryption context\n     */\n    struct {\n        struct st_quicly_cipher_context_t *cipher;\n        uint8_t first_byte;\n    } current;\n    /**\n     * packet under construction\n     */\n    struct {\n        struct st_quicly_cipher_context_t *cipher;\n        /**\n         * points to the first byte of the target QUIC packet. It will not point to packet->octets.base[0] when the datagram\n         * contains multiple QUIC packet.\n         */\n        uint8_t *first_byte_at;\n        /**\n         * if the target QUIC packet contains an ack-eliciting frame\n         */\n        uint8_t ack_eliciting : 1;\n        /**\n         * if the target datagram should be padded to full size\n         */\n        uint8_t full_size : 1;\n    } target;\n    /**\n     * output buffer into which list of datagrams is written\n     */\n    struct iovec *datagrams;\n    /**\n     * max number of datagrams that can be stored in |packets|\n     */\n    size_t max_datagrams;\n    /**\n     * number of datagrams currently stored in |packets|\n     */\n    size_t num_datagrams;\n    /**\n     * buffer in which packets are built\n     */\n    struct {\n        /**\n         * starting position of the current (or next) datagram\n         */\n        uint8_t *datagram;\n        /**\n         * end position of the payload buffer\n         */\n        uint8_t *end;\n    } payload_buf;\n    /**\n     * Currently available window for sending (in bytes); the value becomes negative when the sender uses more space than permitted.\n     * That happens because the sender operates at packet-level rather than byte-level.\n     */\n    ssize_t send_window;\n    /**\n     * location where next frame should be written\n     */\n    uint8_t *dst;\n    /**\n     * end of the payload area, beyond which frames cannot be written\n     */\n    uint8_t *dst_end;\n    /**\n     * address at which payload starts\n     */\n    uint8_t *dst_payload_from;\n    /**\n     * first packet number to be used within the lifetime of this send context\n     */\n    uint64_t first_packet_number;\n};\n\nstatic int commit_send_packet(quicly_conn_t *conn, quicly_send_context_t *s, int coalesced)\n{\n    size_t datagram_size, packet_bytes_in_flight;\n\n    assert(s->target.cipher->aead != NULL);\n\n    assert(s->dst != s->dst_payload_from);\n\n    /* pad so that the pn + payload would be at least 4 bytes */\n    while (s->dst - s->dst_payload_from < QUICLY_MAX_PN_SIZE - QUICLY_SEND_PN_SIZE)\n        *s->dst++ = QUICLY_FRAME_TYPE_PADDING;\n\n    if (!coalesced && s->target.full_size) {\n        assert(s->num_datagrams == 0 || s->datagrams[s->num_datagrams - 1].iov_len == conn->egress.max_udp_payload_size);\n        const size_t max_size = conn->egress.max_udp_payload_size - QUICLY_AEAD_TAG_SIZE;\n        assert(s->dst - s->payload_buf.datagram <= max_size);\n        memset(s->dst, QUICLY_FRAME_TYPE_PADDING, s->payload_buf.datagram + max_size - s->dst);\n        s->dst = s->payload_buf.datagram + max_size;\n    }\n\n    /* encode packet size, packet number, key-phase */\n    if (QUICLY_PACKET_IS_LONG_HEADER(*s->target.first_byte_at)) {\n        uint16_t length = s->dst - s->dst_payload_from + s->target.cipher->aead->algo->tag_size + QUICLY_SEND_PN_SIZE;\n        /* length is always 2 bytes, see _do_prepare_packet */\n        length |= 0x4000;\n        quicly_encode16(s->dst_payload_from - QUICLY_SEND_PN_SIZE - 2, length);\n        switch (*s->target.first_byte_at & QUICLY_PACKET_TYPE_BITMASK) {\n        case QUICLY_PACKET_TYPE_INITIAL:\n        case QUICLY_PACKET_TYPE_HANDSHAKE:\n            conn->super.stats.num_packets.initial_handshake_sent++;\n            break;\n        }\n    } else {\n        if (conn->egress.packet_number >= conn->application->cipher.egress.key_update_pn.next) {\n            int ret;\n            if ((ret = update_1rtt_egress_key(conn)) != 0)\n                return ret;\n        }\n        if ((conn->application->cipher.egress.key_phase & 1) != 0)\n            *s->target.first_byte_at |= QUICLY_KEY_PHASE_BIT;\n    }\n    quicly_encode16(s->dst_payload_from - QUICLY_SEND_PN_SIZE, (uint16_t)conn->egress.packet_number);\n\n    /* encrypt the packet */\n    s->dst += s->target.cipher->aead->algo->tag_size;\n    datagram_size = s->dst - s->payload_buf.datagram;\n    assert(datagram_size <= conn->egress.max_udp_payload_size);\n\n    conn->super.ctx->crypto_engine->encrypt_packet(\n        conn->super.ctx->crypto_engine, conn, s->target.cipher->header_protection, s->target.cipher->aead,\n        ptls_iovec_init(s->payload_buf.datagram, datagram_size), s->target.first_byte_at - s->payload_buf.datagram,\n        s->dst_payload_from - s->payload_buf.datagram, conn->egress.packet_number, coalesced);\n\n    /* update CC, commit sentmap */\n    if (s->target.ack_eliciting) {\n        packet_bytes_in_flight = s->dst - s->target.first_byte_at;\n        s->send_window -= packet_bytes_in_flight;\n    } else {\n        packet_bytes_in_flight = 0;\n    }\n    if (quicly_sentmap_is_open(&conn->egress.loss.sentmap))\n        quicly_sentmap_commit(&conn->egress.loss.sentmap, (uint16_t)packet_bytes_in_flight);\n\n    conn->egress.cc.type->cc_on_sent(&conn->egress.cc, &conn->egress.loss, (uint32_t)packet_bytes_in_flight, conn->stash.now);\n    QUICLY_PROBE(PACKET_SENT, conn, conn->stash.now, conn->egress.packet_number, s->dst - s->target.first_byte_at,\n                 get_epoch(*s->target.first_byte_at), !s->target.ack_eliciting);\n    QUICLY_LOG_CONN(packet_sent, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(pn, conn->egress.packet_number);\n        PTLS_LOG_ELEMENT_UNSIGNED(len, s->dst - s->target.first_byte_at);\n        PTLS_LOG_ELEMENT_UNSIGNED(packet_type, get_epoch(*s->target.first_byte_at));\n        PTLS_LOG_ELEMENT_BOOL(ack_only, !s->target.ack_eliciting);\n    });\n\n    ++conn->egress.packet_number;\n    ++conn->super.stats.num_packets.sent;\n\n    if (!coalesced) {\n        conn->super.stats.num_bytes.sent += datagram_size;\n        s->datagrams[s->num_datagrams++] = (struct iovec){.iov_base = s->payload_buf.datagram, .iov_len = datagram_size};\n        s->payload_buf.datagram += datagram_size;\n        s->target.cipher = NULL;\n        s->target.first_byte_at = NULL;\n    }\n\n    /* insert PN gap if necessary, registering the PN to the ack queue so that we'd close the connection in the event of receiving\n     * an ACK for that gap. */\n    if (conn->egress.packet_number >= conn->egress.next_pn_to_skip && !QUICLY_PACKET_IS_LONG_HEADER(s->current.first_byte) &&\n        conn->super.state < QUICLY_STATE_CLOSING) {\n        int ret;\n        if ((ret = quicly_sentmap_prepare(&conn->egress.loss.sentmap, conn->egress.packet_number, conn->stash.now,\n                                          QUICLY_EPOCH_1RTT)) != 0)\n            return ret;\n        if (quicly_sentmap_allocate(&conn->egress.loss.sentmap, on_invalid_ack) == NULL)\n            return PTLS_ERROR_NO_MEMORY;\n        quicly_sentmap_commit(&conn->egress.loss.sentmap, 0);\n        ++conn->egress.packet_number;\n        conn->egress.next_pn_to_skip = calc_next_pn_to_skip(conn->super.ctx->tls, conn->egress.packet_number, conn->egress.cc.cwnd,\n                                                            conn->egress.max_udp_payload_size);\n    }\n\n    return 0;\n}\n\nstatic inline uint8_t *emit_cid(uint8_t *dst, const quicly_cid_t *cid)\n{\n    if (cid->len != 0) {\n        memcpy(dst, cid->cid, cid->len);\n        dst += cid->len;\n    }\n    return dst;\n}\n\nenum allocate_frame_type {\n    ALLOCATE_FRAME_TYPE_NON_ACK_ELICITING,\n    ALLOCATE_FRAME_TYPE_ACK_ELICITING,\n    ALLOCATE_FRAME_TYPE_ACK_ELICITING_NO_CC,\n};\n\nstatic int do_allocate_frame(quicly_conn_t *conn, quicly_send_context_t *s, size_t min_space, enum allocate_frame_type frame_type)\n{\n    int coalescible, ret;\n\n    assert((s->current.first_byte & QUICLY_QUIC_BIT) != 0);\n\n    /* allocate and setup the new packet if necessary */\n    if (s->dst_end - s->dst < min_space || s->target.first_byte_at == NULL) {\n        coalescible = 0;\n    } else if (((*s->target.first_byte_at ^ s->current.first_byte) & QUICLY_PACKET_TYPE_BITMASK) != 0) {\n        coalescible = QUICLY_PACKET_IS_LONG_HEADER(*s->target.first_byte_at);\n    } else if (s->dst_end - s->dst < min_space) {\n        coalescible = 0;\n    } else {\n        /* use the existing packet */\n        goto TargetReady;\n    }\n\n    /* commit at the same time determining if we will coalesce the packets */\n    if (s->target.first_byte_at != NULL) {\n        if (coalescible) {\n            size_t overhead = 1 /* type */ + conn->super.remote.cid_set.cids[0].cid.len + QUICLY_SEND_PN_SIZE +\n                              s->current.cipher->aead->algo->tag_size;\n            if (QUICLY_PACKET_IS_LONG_HEADER(s->current.first_byte))\n                overhead += 4 /* version */ + 1 /* cidl */ + conn->super.remote.cid_set.cids[0].cid.len +\n                            conn->super.local.long_header_src_cid.len +\n                            (s->current.first_byte == QUICLY_PACKET_TYPE_INITIAL) /* token_length == 0 */ + 2 /* length */;\n            size_t packet_min_space = QUICLY_MAX_PN_SIZE - QUICLY_SEND_PN_SIZE;\n            if (packet_min_space < min_space)\n                packet_min_space = min_space;\n            if (overhead + packet_min_space > s->dst_end - s->dst)\n                coalescible = 0;\n        }\n        /* Close the packet under construction. Datagrams being returned by `quicly_send` are padded to full-size (except for the\n         * last one datagram) so that they can be sent at once using GSO. */\n        if (!coalescible)\n            s->target.full_size = 1;\n        if ((ret = commit_send_packet(conn, s, coalescible)) != 0)\n            return ret;\n    } else {\n        coalescible = 0;\n    }\n\n    /* allocate packet */\n    if (coalescible) {\n        s->dst_end += s->target.cipher->aead->algo->tag_size; /* restore the AEAD tag size (tag size can differ bet. epochs) */\n        s->target.cipher = s->current.cipher;\n    } else {\n        if (s->num_datagrams >= s->max_datagrams)\n            return QUICLY_ERROR_SENDBUF_FULL;\n        /* note: send_window (ssize_t) can become negative; see doc-comment */\n        if (frame_type == ALLOCATE_FRAME_TYPE_ACK_ELICITING && s->send_window <= 0)\n            return QUICLY_ERROR_SENDBUF_FULL;\n        if (s->payload_buf.end - s->payload_buf.datagram < conn->egress.max_udp_payload_size)\n            return QUICLY_ERROR_SENDBUF_FULL;\n        s->target.cipher = s->current.cipher;\n        s->target.full_size = 0;\n        s->dst = s->payload_buf.datagram;\n        s->dst_end = s->dst + conn->egress.max_udp_payload_size;\n    }\n    s->target.ack_eliciting = 0;\n\n    QUICLY_PROBE(PACKET_PREPARE, conn, conn->stash.now, s->current.first_byte,\n                 QUICLY_PROBE_HEXDUMP(conn->super.remote.cid_set.cids[0].cid.cid, conn->super.remote.cid_set.cids[0].cid.len));\n    QUICLY_LOG_CONN(packet_prepare, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(first_octet, s->current.first_byte);\n        PTLS_LOG_ELEMENT_HEXDUMP(dcid, conn->super.remote.cid_set.cids[0].cid.cid, conn->super.remote.cid_set.cids[0].cid.len);\n    });\n\n    /* emit header */\n    s->target.first_byte_at = s->dst;\n    *s->dst++ = s->current.first_byte | 0x1 /* pnlen == 2 */;\n    if (QUICLY_PACKET_IS_LONG_HEADER(s->current.first_byte)) {\n        s->dst = quicly_encode32(s->dst, conn->super.version);\n        *s->dst++ = conn->super.remote.cid_set.cids[0].cid.len;\n        s->dst = emit_cid(s->dst, &conn->super.remote.cid_set.cids[0].cid);\n        *s->dst++ = conn->super.local.long_header_src_cid.len;\n        s->dst = emit_cid(s->dst, &conn->super.local.long_header_src_cid);\n        /* token */\n        if (s->current.first_byte == QUICLY_PACKET_TYPE_INITIAL) {\n            s->dst = quicly_encodev(s->dst, conn->token.len);\n            if (conn->token.len != 0) {\n                assert(s->dst_end - s->dst > conn->token.len);\n                memcpy(s->dst, conn->token.base, conn->token.len);\n                s->dst += conn->token.len;\n            }\n        }\n        /* payload length is filled laterwards (see commit_send_packet) */\n        *s->dst++ = 0;\n        *s->dst++ = 0;\n    } else {\n        s->dst = emit_cid(s->dst, &conn->super.remote.cid_set.cids[0].cid);\n    }\n    s->dst += QUICLY_SEND_PN_SIZE; /* space for PN bits, filled in at commit time */\n    s->dst_payload_from = s->dst;\n    assert(s->target.cipher->aead != NULL);\n    s->dst_end -= s->target.cipher->aead->algo->tag_size;\n    assert(s->dst_end - s->dst >= QUICLY_MAX_PN_SIZE - QUICLY_SEND_PN_SIZE);\n\n    if (conn->super.state < QUICLY_STATE_CLOSING) {\n        /* register to sentmap */\n        uint8_t ack_epoch = get_epoch(s->current.first_byte);\n        if (ack_epoch == QUICLY_EPOCH_0RTT)\n            ack_epoch = QUICLY_EPOCH_1RTT;\n        if ((ret = quicly_sentmap_prepare(&conn->egress.loss.sentmap, conn->egress.packet_number, conn->stash.now, ack_epoch)) != 0)\n            return ret;\n        /* adjust ack-frequency */\n        if (conn->stash.now >= conn->egress.ack_frequency.update_at) {\n            assert(conn->super.remote.transport_params.min_ack_delay_usec != UINT64_MAX);\n            if (conn->egress.cc.num_loss_episodes >= QUICLY_FIRST_ACK_FREQUENCY_LOSS_EPISODE && conn->initial == NULL &&\n                conn->handshake == NULL) {\n                uint32_t fraction_of_cwnd = (uint32_t)((uint64_t)conn->egress.cc.cwnd * conn->super.ctx->ack_frequency / 1024);\n                if (fraction_of_cwnd >= conn->egress.max_udp_payload_size * 3) {\n                    uint32_t packet_tolerance = fraction_of_cwnd / conn->egress.max_udp_payload_size;\n                    if (packet_tolerance > QUICLY_MAX_PACKET_TOLERANCE)\n                        packet_tolerance = QUICLY_MAX_PACKET_TOLERANCE;\n                    s->dst = quicly_encode_ack_frequency_frame(s->dst, conn->egress.ack_frequency.sequence++, packet_tolerance,\n                                                               conn->super.remote.transport_params.max_ack_delay * 1000, 0);\n                    ++conn->super.stats.num_frames_sent.ack_frequency;\n                }\n            }\n            ack_frequency_set_next_update_at(conn);\n        }\n    }\n\nTargetReady:\n    if (frame_type != ALLOCATE_FRAME_TYPE_NON_ACK_ELICITING) {\n        s->target.ack_eliciting = 1;\n        conn->egress.last_retransmittable_sent_at = conn->stash.now;\n    }\n    return 0;\n}\n\nstatic int allocate_ack_eliciting_frame(quicly_conn_t *conn, quicly_send_context_t *s, size_t min_space, quicly_sent_t **sent,\n                                        quicly_sent_acked_cb acked)\n{\n    int ret;\n\n    if ((ret = do_allocate_frame(conn, s, min_space, ALLOCATE_FRAME_TYPE_ACK_ELICITING)) != 0)\n        return ret;\n    if ((*sent = quicly_sentmap_allocate(&conn->egress.loss.sentmap, acked)) == NULL)\n        return PTLS_ERROR_NO_MEMORY;\n\n    return ret;\n}\n\nstatic int send_ack(quicly_conn_t *conn, struct st_quicly_pn_space_t *space, quicly_send_context_t *s)\n{\n    uint64_t ack_delay;\n    int ret;\n\n    if (space->ack_queue.num_ranges == 0)\n        return 0;\n\n    /* calc ack_delay */\n    if (space->largest_pn_received_at < conn->stash.now) {\n        /* We underreport ack_delay up to 1 milliseconds assuming that QUICLY_LOCAL_ACK_DELAY_EXPONENT is 10. It's considered a\n         * non-issue because our time measurement is at millisecond granularity anyways. */\n        ack_delay = ((conn->stash.now - space->largest_pn_received_at) * 1000) >> QUICLY_LOCAL_ACK_DELAY_EXPONENT;\n    } else {\n        ack_delay = 0;\n    }\n\nEmit: /* emit an ACK frame */\n    if ((ret = do_allocate_frame(conn, s, QUICLY_ACK_FRAME_CAPACITY, ALLOCATE_FRAME_TYPE_NON_ACK_ELICITING)) != 0)\n        return ret;\n    uint8_t *dst = s->dst;\n    dst = quicly_encode_ack_frame(dst, s->dst_end, &space->ack_queue, space->ecn_counts, ack_delay);\n\n    /* when there's no space, retry with a new MTU-sized packet */\n    if (dst == NULL) {\n        /* [rare case] A coalesced packet might not have enough space to hold only an ACK. If so, pad it, as that's easier than\n         * rolling back. */\n        if (s->dst == s->dst_payload_from) {\n            assert(s->target.first_byte_at != s->payload_buf.datagram);\n            *s->dst++ = QUICLY_FRAME_TYPE_PADDING;\n        }\n        s->target.full_size = 1;\n        if ((ret = commit_send_packet(conn, s, 0)) != 0)\n            return ret;\n        goto Emit;\n    }\n\n    ++conn->super.stats.num_frames_sent.ack;\n    QUICLY_PROBE(ACK_SEND, conn, conn->stash.now, space->ack_queue.ranges[space->ack_queue.num_ranges - 1].end - 1, ack_delay);\n    QUICLY_LOG_CONN(ack_send, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(largest_acked, space->ack_queue.ranges[space->ack_queue.num_ranges - 1].end - 1);\n        PTLS_LOG_ELEMENT_UNSIGNED(ack_delay, ack_delay);\n    });\n\n    /* when there are no less than QUICLY_NUM_ACK_BLOCKS_TO_INDUCE_ACKACK (8) gaps, bundle PING once every 4 packets being sent */\n    if (space->ack_queue.num_ranges >= QUICLY_NUM_ACK_BLOCKS_TO_INDUCE_ACKACK && conn->egress.packet_number % 4 == 0 &&\n        dst < s->dst_end) {\n        *dst++ = QUICLY_FRAME_TYPE_PING;\n        ++conn->super.stats.num_frames_sent.ping;\n        QUICLY_PROBE(PING_SEND, conn, conn->stash.now);\n        QUICLY_LOG_CONN(ping_send, conn, {});\n    }\n\n    s->dst = dst;\n\n    { /* save what's inflight */\n        size_t range_index = 0;\n        while (range_index < space->ack_queue.num_ranges) {\n            quicly_sent_t *sent;\n            struct st_quicly_sent_ack_additional_t *additional, *additional_end;\n            /* allocate */\n            if ((sent = quicly_sentmap_allocate(&conn->egress.loss.sentmap, on_ack_ack_ranges8)) == NULL)\n                return PTLS_ERROR_NO_MEMORY;\n            /* store the first range, as well as preparing references to the additional slots */\n            sent->data.ack.start = space->ack_queue.ranges[range_index].start;\n            uint64_t length = space->ack_queue.ranges[range_index].end - space->ack_queue.ranges[range_index].start;\n            if (length <= UINT8_MAX) {\n                sent->data.ack.ranges8.start_length = length;\n                additional = sent->data.ack.ranges8.additional;\n                additional_end = additional + PTLS_ELEMENTSOF(sent->data.ack.ranges8.additional);\n            } else {\n                sent->acked = on_ack_ack_ranges64;\n                sent->data.ack.ranges64.start_length = length;\n                additional = sent->data.ack.ranges64.additional;\n                additional_end = additional + PTLS_ELEMENTSOF(sent->data.ack.ranges64.additional);\n            }\n            /* store additional ranges, if possible */\n            for (++range_index; range_index < space->ack_queue.num_ranges && additional < additional_end;\n                 ++range_index, ++additional) {\n                uint64_t gap = space->ack_queue.ranges[range_index].start - space->ack_queue.ranges[range_index - 1].end;\n                uint64_t length = space->ack_queue.ranges[range_index].end - space->ack_queue.ranges[range_index].start;\n                if (gap > UINT8_MAX || length > UINT8_MAX)\n                    break;\n                additional->gap = gap;\n                additional->length = length;\n            }\n            /* additional list is zero-terminated, if not full */\n            if (additional < additional_end)\n                additional->gap = 0;\n        }\n    }\n\n    space->unacked_count = 0;\n\n    return ret;\n}\n\nstatic int prepare_stream_state_sender(quicly_stream_t *stream, quicly_sender_state_t *sender, quicly_send_context_t *s,\n                                       size_t min_space, quicly_sent_acked_cb ack_cb)\n{\n    quicly_sent_t *sent;\n    int ret;\n\n    if ((ret = allocate_ack_eliciting_frame(stream->conn, s, min_space, &sent, ack_cb)) != 0)\n        return ret;\n    sent->data.stream_state_sender.stream_id = stream->stream_id;\n    *sender = QUICLY_SENDER_STATE_UNACKED;\n\n    return 0;\n}\n\nstatic int send_control_frames_of_stream(quicly_stream_t *stream, quicly_send_context_t *s)\n{\n    int ret;\n\n    /* send STOP_SENDING if necessary */\n    if (stream->_send_aux.stop_sending.sender_state == QUICLY_SENDER_STATE_SEND) {\n        /* FIXME also send an empty STREAM frame */\n        if ((ret = prepare_stream_state_sender(stream, &stream->_send_aux.stop_sending.sender_state, s,\n                                               QUICLY_STOP_SENDING_FRAME_CAPACITY, on_ack_stop_sending)) != 0)\n            return ret;\n        s->dst = quicly_encode_stop_sending_frame(s->dst, stream->stream_id, stream->_send_aux.stop_sending.error_code);\n        ++stream->conn->super.stats.num_frames_sent.stop_sending;\n        QUICLY_PROBE(STOP_SENDING_SEND, stream->conn, stream->conn->stash.now, stream->stream_id,\n                     stream->_send_aux.stop_sending.error_code);\n        QUICLY_LOG_CONN(stop_sending_send, stream->conn, {\n            PTLS_LOG_ELEMENT_SIGNED(stream_id, stream->stream_id);\n            PTLS_LOG_ELEMENT_UNSIGNED(error_code, stream->_send_aux.stop_sending.error_code);\n        });\n    }\n\n    /* send MAX_STREAM_DATA if necessary */\n    if (should_send_max_stream_data(stream)) {\n        uint64_t new_value = stream->recvstate.data_off + stream->_recv_aux.window;\n        quicly_sent_t *sent;\n        /* prepare */\n        if ((ret = allocate_ack_eliciting_frame(stream->conn, s, QUICLY_MAX_STREAM_DATA_FRAME_CAPACITY, &sent,\n                                                on_ack_max_stream_data)) != 0)\n            return ret;\n        /* send */\n        s->dst = quicly_encode_max_stream_data_frame(s->dst, stream->stream_id, new_value);\n        /* register ack */\n        sent->data.max_stream_data.stream_id = stream->stream_id;\n        quicly_maxsender_record(&stream->_send_aux.max_stream_data_sender, new_value, &sent->data.max_stream_data.args);\n        /* update stats */\n        ++stream->conn->super.stats.num_frames_sent.max_stream_data;\n        QUICLY_PROBE(MAX_STREAM_DATA_SEND, stream->conn, stream->conn->stash.now, stream, new_value);\n        QUICLY_LOG_CONN(max_stream_data_send, stream->conn, {\n            PTLS_LOG_ELEMENT_SIGNED(stream_id, stream->stream_id);\n            PTLS_LOG_ELEMENT_UNSIGNED(maximum, new_value);\n        });\n    }\n\n    /* send RESET_STREAM if necessary */\n    if (stream->_send_aux.reset_stream.sender_state == QUICLY_SENDER_STATE_SEND) {\n        if ((ret = prepare_stream_state_sender(stream, &stream->_send_aux.reset_stream.sender_state, s, QUICLY_RST_FRAME_CAPACITY,\n                                               on_ack_reset_stream)) != 0)\n            return ret;\n        s->dst = quicly_encode_reset_stream_frame(s->dst, stream->stream_id, stream->_send_aux.reset_stream.error_code,\n                                                  stream->sendstate.size_inflight);\n        ++stream->conn->super.stats.num_frames_sent.reset_stream;\n        QUICLY_PROBE(RESET_STREAM_SEND, stream->conn, stream->conn->stash.now, stream->stream_id,\n                     stream->_send_aux.reset_stream.error_code, stream->sendstate.size_inflight);\n        QUICLY_LOG_CONN(reset_stream_send, stream->conn, {\n            PTLS_LOG_ELEMENT_SIGNED(stream_id, stream->stream_id);\n            PTLS_LOG_ELEMENT_UNSIGNED(error_code, stream->_send_aux.reset_stream.error_code);\n            PTLS_LOG_ELEMENT_UNSIGNED(final_size, stream->sendstate.size_inflight);\n        });\n    }\n\n    /* send STREAM_DATA_BLOCKED if necessary */\n    if (stream->_send_aux.blocked == QUICLY_SENDER_STATE_SEND) {\n        quicly_sent_t *sent;\n        if ((ret = allocate_ack_eliciting_frame(stream->conn, s, QUICLY_STREAM_DATA_BLOCKED_FRAME_CAPACITY, &sent,\n                                                on_ack_stream_data_blocked_frame)) != 0)\n            return ret;\n        uint64_t offset = stream->_send_aux.max_stream_data;\n        sent->data.stream_data_blocked.stream_id = stream->stream_id;\n        sent->data.stream_data_blocked.offset = offset;\n        s->dst = quicly_encode_stream_data_blocked_frame(s->dst, stream->stream_id, offset);\n        stream->_send_aux.blocked = QUICLY_SENDER_STATE_UNACKED;\n        ++stream->conn->super.stats.num_frames_sent.stream_data_blocked;\n        QUICLY_PROBE(STREAM_DATA_BLOCKED_SEND, stream->conn, stream->conn->stash.now, stream->stream_id, offset);\n        QUICLY_LOG_CONN(stream_data_blocked_send, stream->conn, {\n            PTLS_LOG_ELEMENT_SIGNED(stream_id, stream->stream_id);\n            PTLS_LOG_ELEMENT_UNSIGNED(maximum, offset);\n        });\n    }\n\n    return 0;\n}\n\nstatic int send_stream_control_frames(quicly_conn_t *conn, quicly_send_context_t *s)\n{\n    int ret = 0;\n\n    while (s->num_datagrams != s->max_datagrams && quicly_linklist_is_linked(&conn->egress.pending_streams.control)) {\n        quicly_stream_t *stream =\n            (void *)((char *)conn->egress.pending_streams.control.next - offsetof(quicly_stream_t, _send_aux.pending_link.control));\n        if ((ret = send_control_frames_of_stream(stream, s)) != 0)\n            goto Exit;\n        quicly_linklist_unlink(&stream->_send_aux.pending_link.control);\n    }\n\nExit:\n    return ret;\n}\n\nint quicly_is_blocked(quicly_conn_t *conn)\n{\n    if (conn->egress.max_data.sent < conn->egress.max_data.permitted)\n        return 0;\n\n    /* schedule the transmission of DATA_BLOCKED frame, if it's new information */\n    if (conn->egress.data_blocked == QUICLY_SENDER_STATE_NONE) {\n        conn->egress.data_blocked = QUICLY_SENDER_STATE_SEND;\n        conn->egress.pending_flows = QUICLY_PENDING_FLOW_OTHERS_BIT;\n    }\n\n    return 1;\n}\n\nint quicly_stream_can_send(quicly_stream_t *stream, int at_stream_level)\n{\n    /* return if there is nothing to be sent */\n    if (stream->sendstate.pending.num_ranges == 0)\n        return 0;\n\n    /* return if flow is capped neither by MAX_STREAM_DATA nor (in case we are hitting connection-level flow control) by the number\n     * of bytes we've already sent */\n    uint64_t blocked_at = at_stream_level ? stream->_send_aux.max_stream_data : stream->sendstate.size_inflight;\n    if (stream->sendstate.pending.ranges[0].start < blocked_at)\n        return 1;\n    /* we can always send EOS, if that is the only thing to be sent */\n    if (stream->sendstate.pending.ranges[0].start >= stream->sendstate.final_size) {\n        assert(stream->sendstate.pending.ranges[0].start == stream->sendstate.final_size);\n        return 1;\n    }\n\n    /* if known to be blocked at stream-level, schedule the emission of STREAM_DATA_BLOCKED frame */\n    if (at_stream_level && stream->_send_aux.blocked == QUICLY_SENDER_STATE_NONE) {\n        stream->_send_aux.blocked = QUICLY_SENDER_STATE_SEND;\n        sched_stream_control(stream);\n    }\n\n    return 0;\n}\n\nint quicly_can_send_data(quicly_conn_t *conn, quicly_send_context_t *s)\n{\n    return s->num_datagrams < s->max_datagrams;\n}\n\n/**\n * If necessary, changes the frame representation from one without length field to one that has if necessary. Or, as an alternative,\n * prepends PADDING frames. Upon return, `dst` points to the end of the frame being built. `*len`, `*wrote_all`, `*frame_type_at`\n * are also updated reflecting their values post-adjustment.\n */\nstatic inline void adjust_stream_frame_layout(uint8_t **dst, uint8_t *const dst_end, size_t *len, int *wrote_all,\n                                              uint8_t **frame_at)\n{\n    size_t space_left = (dst_end - *dst) - *len, len_of_len = quicly_encodev_capacity(*len);\n\n    if (**frame_at == QUICLY_FRAME_TYPE_CRYPTO) {\n        /* CRYPTO frame: adjust payload length to make space for the length field, if necessary. */\n        if (space_left < len_of_len) {\n            *len = dst_end - *dst - len_of_len;\n            *wrote_all = 0;\n        }\n    } else {\n        /* STREAM frame: insert length if space can be left for more frames. Otherwise, retain STREAM frame header omitting the\n         * length field, prepending PADDING if necessary. */\n        if (space_left <= len_of_len) {\n            if (space_left != 0) {\n                memmove(*frame_at + space_left, *frame_at, *dst + *len - *frame_at);\n                memset(*frame_at, QUICLY_FRAME_TYPE_PADDING, space_left);\n                *dst += space_left;\n                *frame_at += space_left;\n            }\n            *dst += *len;\n            return;\n        }\n        **frame_at |= QUICLY_FRAME_TYPE_STREAM_BIT_LEN;\n    }\n\n    /* insert length before payload of `*len` bytes */\n    memmove(*dst + len_of_len, *dst, *len);\n    *dst = quicly_encodev(*dst, *len);\n    *dst += *len;\n}\n\nint quicly_send_stream(quicly_stream_t *stream, quicly_send_context_t *s)\n{\n    uint64_t off = stream->sendstate.pending.ranges[0].start;\n    quicly_sent_t *sent;\n    uint8_t *dst; /* this pointer points to the current write position within the frame being built, while `s->dst` points to the\n                   * beginning of the frame. */\n    size_t len;\n    int ret, wrote_all, is_fin;\n\n    /* write frame type, stream_id and offset, calculate capacity (and store that in `len`) */\n    if (stream->stream_id < 0) {\n        if ((ret = allocate_ack_eliciting_frame(stream->conn, s,\n                                                1 + quicly_encodev_capacity(off) + 2 /* type + offset + len + 1-byte payload */,\n                                                &sent, on_ack_stream)) != 0)\n            return ret;\n        dst = s->dst;\n        *dst++ = QUICLY_FRAME_TYPE_CRYPTO;\n        dst = quicly_encodev(dst, off);\n        len = s->dst_end - dst;\n    } else {\n        uint8_t header[18], *hp = header + 1;\n        hp = quicly_encodev(hp, stream->stream_id);\n        if (off != 0) {\n            header[0] = QUICLY_FRAME_TYPE_STREAM_BASE | QUICLY_FRAME_TYPE_STREAM_BIT_OFF;\n            hp = quicly_encodev(hp, off);\n        } else {\n            header[0] = QUICLY_FRAME_TYPE_STREAM_BASE;\n        }\n        if (off == stream->sendstate.final_size) {\n            assert(!quicly_sendstate_is_open(&stream->sendstate));\n            /* special case for emitting FIN only */\n            header[0] |= QUICLY_FRAME_TYPE_STREAM_BIT_FIN;\n            if ((ret = allocate_ack_eliciting_frame(stream->conn, s, hp - header, &sent, on_ack_stream)) != 0)\n                return ret;\n            if (hp - header != s->dst_end - s->dst) {\n                header[0] |= QUICLY_FRAME_TYPE_STREAM_BIT_LEN;\n                *hp++ = 0; /* empty length */\n            }\n            memcpy(s->dst, header, hp - header);\n            s->dst += hp - header;\n            len = 0;\n            wrote_all = 1;\n            is_fin = 1;\n            goto UpdateState;\n        }\n        if ((ret = allocate_ack_eliciting_frame(stream->conn, s, hp - header + 1, &sent, on_ack_stream)) != 0)\n            return ret;\n        dst = s->dst;\n        memcpy(dst, header, hp - header);\n        dst += hp - header;\n        len = s->dst_end - dst;\n        /* cap by max_stream_data */\n        if (off + len > stream->_send_aux.max_stream_data)\n            len = stream->_send_aux.max_stream_data - off;\n        /* cap by max_data */\n        if (off + len > stream->sendstate.size_inflight) {\n            uint64_t new_bytes = off + len - stream->sendstate.size_inflight;\n            if (new_bytes > stream->conn->egress.max_data.permitted - stream->conn->egress.max_data.sent) {\n                size_t max_stream_data =\n                    stream->sendstate.size_inflight + stream->conn->egress.max_data.permitted - stream->conn->egress.max_data.sent;\n                len = max_stream_data - off;\n            }\n        }\n    }\n    { /* cap len to the current range */\n        uint64_t range_capacity = stream->sendstate.pending.ranges[0].end - off;\n        if (off + range_capacity > stream->sendstate.final_size) {\n            assert(!quicly_sendstate_is_open(&stream->sendstate));\n            assert(range_capacity > 1); /* see the special case above */\n            range_capacity -= 1;\n        }\n        if (len > range_capacity)\n            len = range_capacity;\n    }\n\n    /* Write payload, adjusting len to actual size. Note that `on_send_emit` might fail (e.g., when underlying pread(2) fails), in\n     * which case the application will either close the connection immediately or reset the stream. If that happens, we return\n     * immediately without updating state. */\n    assert(len != 0);\n    size_t emit_off = (size_t)(off - stream->sendstate.acked.ranges[0].end);\n    QUICLY_PROBE(STREAM_ON_SEND_EMIT, stream->conn, stream->conn->stash.now, stream, emit_off, len);\n    QUICLY_LOG_CONN(stream_on_send_emit, stream->conn, {\n        PTLS_LOG_ELEMENT_SIGNED(stream_id, stream->stream_id);\n        PTLS_LOG_ELEMENT_UNSIGNED(off, off);\n        PTLS_LOG_ELEMENT_UNSIGNED(capacity, len);\n    });\n    stream->callbacks->on_send_emit(stream, emit_off, dst, &len, &wrote_all);\n    if (stream->conn->super.state >= QUICLY_STATE_CLOSING) {\n        return QUICLY_ERROR_IS_CLOSING;\n    } else if (stream->_send_aux.reset_stream.sender_state != QUICLY_SENDER_STATE_NONE) {\n        return 0;\n    }\n    assert(len != 0);\n\n    adjust_stream_frame_layout(&dst, s->dst_end, &len, &wrote_all, &s->dst);\n\n    /* determine if the frame incorporates FIN */\n    if (off + len == stream->sendstate.final_size) {\n        assert(!quicly_sendstate_is_open(&stream->sendstate));\n        assert(s->dst != NULL);\n        is_fin = 1;\n        *s->dst |= QUICLY_FRAME_TYPE_STREAM_BIT_FIN;\n    } else {\n        is_fin = 0;\n    }\n\n    /* update s->dst now that frame construction is complete */\n    s->dst = dst;\n\nUpdateState:\n    if (stream->stream_id < 0) {\n        ++stream->conn->super.stats.num_frames_sent.crypto;\n    } else {\n        ++stream->conn->super.stats.num_frames_sent.stream;\n    }\n    stream->conn->super.stats.num_bytes.stream_data_sent += len;\n    if (off < stream->sendstate.size_inflight)\n        stream->conn->super.stats.num_bytes.stream_data_resent +=\n            (stream->sendstate.size_inflight < off + len ? stream->sendstate.size_inflight : off + len) - off;\n    QUICLY_PROBE(STREAM_SEND, stream->conn, stream->conn->stash.now, stream, off, len, is_fin);\n    QUICLY_LOG_CONN(stream_send, stream->conn, {\n        PTLS_LOG_ELEMENT_SIGNED(stream_id, stream->stream_id);\n        PTLS_LOG_ELEMENT_UNSIGNED(off, off);\n        PTLS_LOG_ELEMENT_UNSIGNED(len, len);\n        PTLS_LOG_ELEMENT_BOOL(is_fin, is_fin);\n    });\n\n    QUICLY_PROBE(QUICTRACE_SEND_STREAM, stream->conn, stream->conn->stash.now, stream, off, len, is_fin);\n    /* update sendstate (and also MAX_DATA counter) */\n    if (stream->sendstate.size_inflight < off + len) {\n        if (stream->stream_id >= 0)\n            stream->conn->egress.max_data.sent += off + len - stream->sendstate.size_inflight;\n        stream->sendstate.size_inflight = off + len;\n    }\n    if ((ret = quicly_ranges_subtract(&stream->sendstate.pending, off, off + len + is_fin)) != 0)\n        return ret;\n    if (wrote_all) {\n        if ((ret = quicly_ranges_subtract(&stream->sendstate.pending, stream->sendstate.size_inflight, UINT64_MAX)) != 0)\n            return ret;\n    }\n\n    /* setup sentmap */\n    sent->data.stream.stream_id = stream->stream_id;\n    sent->data.stream.args.start = off;\n    sent->data.stream.args.end = off + len + is_fin;\n\n    return 0;\n}\n\nstatic inline int init_acks_iter(quicly_conn_t *conn, quicly_sentmap_iter_t *iter)\n{\n    return quicly_loss_init_sentmap_iter(&conn->egress.loss, iter, conn->stash.now,\n                                         conn->super.remote.transport_params.max_ack_delay,\n                                         conn->super.state >= QUICLY_STATE_CLOSING);\n}\n\nint discard_sentmap_by_epoch(quicly_conn_t *conn, unsigned ack_epochs)\n{\n    quicly_sentmap_iter_t iter;\n    const quicly_sent_packet_t *sent;\n    int ret;\n\n    if ((ret = init_acks_iter(conn, &iter)) != 0)\n        return ret;\n\n    while ((sent = quicly_sentmap_get(&iter))->packet_number != UINT64_MAX) {\n        if ((ack_epochs & (1u << sent->ack_epoch)) != 0) {\n            if ((ret = quicly_sentmap_update(&conn->egress.loss.sentmap, &iter, QUICLY_SENTMAP_EVENT_EXPIRED)) != 0)\n                return ret;\n        } else {\n            quicly_sentmap_skip(&iter);\n        }\n    }\n\n    return ret;\n}\n\n/**\n * Mark frames of given epoch as pending, until `*bytes_to_mark` becomes zero.\n */\nstatic int mark_frames_on_pto(quicly_conn_t *conn, uint8_t ack_epoch, size_t *bytes_to_mark)\n{\n    quicly_sentmap_iter_t iter;\n    const quicly_sent_packet_t *sent;\n    int ret;\n\n    if ((ret = init_acks_iter(conn, &iter)) != 0)\n        return ret;\n\n    while ((sent = quicly_sentmap_get(&iter))->packet_number != UINT64_MAX) {\n        if (sent->ack_epoch == ack_epoch && sent->frames_in_flight) {\n            *bytes_to_mark = *bytes_to_mark > sent->cc_bytes_in_flight ? *bytes_to_mark - sent->cc_bytes_in_flight : 0;\n            if ((ret = quicly_sentmap_update(&conn->egress.loss.sentmap, &iter, QUICLY_SENTMAP_EVENT_PTO)) != 0)\n                return ret;\n            assert(!sent->frames_in_flight);\n            if (*bytes_to_mark == 0)\n                break;\n        } else {\n            quicly_sentmap_skip(&iter);\n        }\n    }\n\n    return 0;\n}\n\nstatic void notify_congestion_to_cc(quicly_conn_t *conn, uint16_t lost_bytes, uint64_t lost_pn)\n{\n    conn->egress.cc.type->cc_on_lost(&conn->egress.cc, &conn->egress.loss, lost_bytes, lost_pn, conn->egress.packet_number,\n                                     conn->stash.now, conn->egress.max_udp_payload_size);\n    QUICLY_PROBE(CC_CONGESTION, conn, conn->stash.now, lost_pn + 1, conn->egress.loss.sentmap.bytes_in_flight,\n                 conn->egress.cc.cwnd);\n    QUICLY_LOG_CONN(cc_congestion, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(max_lost_pn, lost_pn + 1);\n        PTLS_LOG_ELEMENT_UNSIGNED(flight, conn->egress.loss.sentmap.bytes_in_flight);\n        PTLS_LOG_ELEMENT_UNSIGNED(cwnd, conn->egress.cc.cwnd);\n    });\n}\n\nstatic void on_loss_detected(quicly_loss_t *loss, const quicly_sent_packet_t *lost_packet, int is_time_threshold)\n{\n    quicly_conn_t *conn = (void *)((char *)loss - offsetof(quicly_conn_t, egress.loss));\n\n    assert(lost_packet->cc_bytes_in_flight != 0);\n\n    ++conn->super.stats.num_packets.lost;\n    if (is_time_threshold)\n        ++conn->super.stats.num_packets.lost_time_threshold;\n    conn->super.stats.num_bytes.lost += lost_packet->cc_bytes_in_flight;\n    QUICLY_PROBE(PACKET_LOST, conn, conn->stash.now, lost_packet->packet_number, lost_packet->ack_epoch);\n    QUICLY_LOG_CONN(packet_lost, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(pn, lost_packet->packet_number);\n        PTLS_LOG_ELEMENT_UNSIGNED(packet_type, lost_packet->ack_epoch);\n    });\n    notify_congestion_to_cc(conn, lost_packet->cc_bytes_in_flight, lost_packet->packet_number);\n    QUICLY_PROBE(QUICTRACE_CC_LOST, conn, conn->stash.now, &conn->egress.loss.rtt, conn->egress.cc.cwnd,\n                 conn->egress.loss.sentmap.bytes_in_flight);\n}\n\nstatic int send_max_streams(quicly_conn_t *conn, int uni, quicly_send_context_t *s)\n{\n    if (!should_send_max_streams(conn, uni))\n        return 0;\n\n    quicly_maxsender_t *maxsender = uni ? &conn->ingress.max_streams.uni : &conn->ingress.max_streams.bidi;\n    struct st_quicly_conn_streamgroup_state_t *group = uni ? &conn->super.remote.uni : &conn->super.remote.bidi;\n    int ret;\n\n    uint64_t new_count =\n        group->next_stream_id / 4 +\n        (uni ? conn->super.ctx->transport_params.max_streams_uni : conn->super.ctx->transport_params.max_streams_bidi) -\n        group->num_streams;\n\n    quicly_sent_t *sent;\n    if ((ret = allocate_ack_eliciting_frame(conn, s, QUICLY_MAX_STREAMS_FRAME_CAPACITY, &sent, on_ack_max_streams)) != 0)\n        return ret;\n    s->dst = quicly_encode_max_streams_frame(s->dst, uni, new_count);\n    sent->data.max_streams.uni = uni;\n    quicly_maxsender_record(maxsender, new_count, &sent->data.max_streams.args);\n\n    if (uni) {\n        ++conn->super.stats.num_frames_sent.max_streams_uni;\n    } else {\n        ++conn->super.stats.num_frames_sent.max_streams_bidi;\n    }\n    QUICLY_PROBE(MAX_STREAMS_SEND, conn, conn->stash.now, new_count, uni);\n    QUICLY_LOG_CONN(max_streams_send, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(maximum, new_count);\n        PTLS_LOG_ELEMENT_BOOL(is_unidirectional, uni);\n    });\n\n    return 0;\n}\n\nstatic int send_streams_blocked(quicly_conn_t *conn, int uni, quicly_send_context_t *s)\n{\n    quicly_linklist_t *blocked_list = uni ? &conn->egress.pending_streams.blocked.uni : &conn->egress.pending_streams.blocked.bidi;\n    int ret;\n\n    if (!quicly_linklist_is_linked(blocked_list))\n        return 0;\n\n    struct st_quicly_max_streams_t *max_streams = uni ? &conn->egress.max_streams.uni : &conn->egress.max_streams.bidi;\n    quicly_stream_t *oldest_blocked_stream =\n        (void *)((char *)blocked_list->next - offsetof(quicly_stream_t, _send_aux.pending_link.control));\n    assert(max_streams->count == oldest_blocked_stream->stream_id / 4);\n\n    if (!quicly_maxsender_should_send_blocked(&max_streams->blocked_sender, max_streams->count))\n        return 0;\n\n    quicly_sent_t *sent;\n    if ((ret = allocate_ack_eliciting_frame(conn, s, QUICLY_STREAMS_BLOCKED_FRAME_CAPACITY, &sent, on_ack_streams_blocked)) != 0)\n        return ret;\n    s->dst = quicly_encode_streams_blocked_frame(s->dst, uni, max_streams->count);\n    sent->data.streams_blocked.uni = uni;\n    quicly_maxsender_record(&max_streams->blocked_sender, max_streams->count, &sent->data.streams_blocked.args);\n\n    ++conn->super.stats.num_frames_sent.streams_blocked;\n    QUICLY_PROBE(STREAMS_BLOCKED_SEND, conn, conn->stash.now, max_streams->count, uni);\n    QUICLY_LOG_CONN(streams_blocked_send, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(maximum, max_streams->count);\n        PTLS_LOG_ELEMENT_BOOL(is_unidirectional, uni);\n    });\n\n    return 0;\n}\n\nstatic void open_blocked_streams(quicly_conn_t *conn, int uni)\n{\n    uint64_t count;\n    quicly_linklist_t *anchor;\n\n    if (uni) {\n        count = conn->egress.max_streams.uni.count;\n        anchor = &conn->egress.pending_streams.blocked.uni;\n    } else {\n        count = conn->egress.max_streams.bidi.count;\n        anchor = &conn->egress.pending_streams.blocked.bidi;\n    }\n\n    while (quicly_linklist_is_linked(anchor)) {\n        quicly_stream_t *stream = (void *)((char *)anchor->next - offsetof(quicly_stream_t, _send_aux.pending_link.control));\n        if (stream->stream_id / 4 >= count)\n            break;\n        assert(stream->streams_blocked);\n        quicly_linklist_unlink(&stream->_send_aux.pending_link.control);\n        stream->streams_blocked = 0;\n        stream->_send_aux.max_stream_data = quicly_stream_is_unidirectional(stream->stream_id)\n                                                ? conn->super.remote.transport_params.max_stream_data.uni\n                                                : conn->super.remote.transport_params.max_stream_data.bidi_remote;\n        /* TODO retain separate flags for stream states so that we do not always need to sched for both control and data */\n        sched_stream_control(stream);\n        resched_stream_data(stream);\n    }\n}\n\nstatic int send_handshake_done(quicly_conn_t *conn, quicly_send_context_t *s)\n{\n    quicly_sent_t *sent;\n    int ret;\n\n    if ((ret = allocate_ack_eliciting_frame(conn, s, 1, &sent, on_ack_handshake_done)) != 0)\n        goto Exit;\n    *s->dst++ = QUICLY_FRAME_TYPE_HANDSHAKE_DONE;\n    conn->egress.pending_flows &= ~QUICLY_PENDING_FLOW_HANDSHAKE_DONE_BIT;\n    ++conn->super.stats.num_frames_sent.handshake_done;\n    QUICLY_PROBE(HANDSHAKE_DONE_SEND, conn, conn->stash.now);\n    QUICLY_LOG_CONN(handshake_done_send, conn, {});\n\n    ret = 0;\nExit:\n    return ret;\n}\n\nstatic int send_data_blocked(quicly_conn_t *conn, quicly_send_context_t *s)\n{\n    quicly_sent_t *sent;\n    int ret;\n\n    uint64_t offset = conn->egress.max_data.permitted;\n    if ((ret = allocate_ack_eliciting_frame(conn, s, QUICLY_DATA_BLOCKED_FRAME_CAPACITY, &sent, on_ack_data_blocked)) != 0)\n        goto Exit;\n    sent->data.data_blocked.offset = offset;\n    s->dst = quicly_encode_data_blocked_frame(s->dst, offset);\n    conn->egress.data_blocked = QUICLY_SENDER_STATE_UNACKED;\n\n    ++conn->super.stats.num_frames_sent.data_blocked;\n    QUICLY_PROBE(DATA_BLOCKED_SEND, conn, conn->stash.now, offset);\n    QUICLY_LOG_CONN(data_blocked_send, conn, { PTLS_LOG_ELEMENT_UNSIGNED(off, offset); });\n\n    ret = 0;\nExit:\n    return ret;\n}\n\nstatic int send_resumption_token(quicly_conn_t *conn, quicly_send_context_t *s)\n{\n    quicly_address_token_plaintext_t token;\n    ptls_buffer_t tokenbuf;\n    uint8_t tokenbuf_small[128];\n    quicly_sent_t *sent;\n    int ret;\n\n    ptls_buffer_init(&tokenbuf, tokenbuf_small, sizeof(tokenbuf_small));\n\n    /* build token */\n    token =\n        (quicly_address_token_plaintext_t){QUICLY_ADDRESS_TOKEN_TYPE_RESUMPTION, conn->super.ctx->now->cb(conn->super.ctx->now)};\n    token.remote = conn->super.remote.address;\n    /* TODO fill token.resumption */\n\n    /* encrypt */\n    if ((ret = conn->super.ctx->generate_resumption_token->cb(conn->super.ctx->generate_resumption_token, conn, &tokenbuf,\n                                                              &token)) != 0)\n        goto Exit;\n    assert(tokenbuf.off < QUICLY_MIN_CLIENT_INITIAL_SIZE / 2 && \"this is a ballpark figure, but tokens ought to be small\");\n\n    /* emit frame */\n    if ((ret = allocate_ack_eliciting_frame(conn, s, quicly_new_token_frame_capacity(ptls_iovec_init(tokenbuf.base, tokenbuf.off)),\n                                            &sent, on_ack_new_token)) != 0)\n        goto Exit;\n    ++conn->egress.new_token.num_inflight;\n    sent->data.new_token.is_inflight = 1;\n    sent->data.new_token.generation = conn->egress.new_token.generation;\n    s->dst = quicly_encode_new_token_frame(s->dst, ptls_iovec_init(tokenbuf.base, tokenbuf.off));\n    conn->egress.pending_flows &= ~QUICLY_PENDING_FLOW_NEW_TOKEN_BIT;\n\n    ++conn->super.stats.num_frames_sent.new_token;\n    QUICLY_PROBE(NEW_TOKEN_SEND, conn, conn->stash.now, tokenbuf.base, tokenbuf.off, sent->data.new_token.generation);\n    QUICLY_LOG_CONN(new_token_send, conn, {\n        PTLS_LOG_ELEMENT_HEXDUMP(token, tokenbuf.base, tokenbuf.off);\n        PTLS_LOG_ELEMENT_UNSIGNED(generation, sent->data.new_token.generation);\n    });\n    ret = 0;\nExit:\n    ptls_buffer_dispose(&tokenbuf);\n    return ret;\n}\n\nsize_t quicly_send_version_negotiation(quicly_context_t *ctx, ptls_iovec_t dest_cid, ptls_iovec_t src_cid, const uint32_t *versions,\n                                       void *payload)\n{\n    uint8_t *dst = payload;\n\n    /* type_flags */\n    ctx->tls->random_bytes(dst, 1);\n    *dst |= QUICLY_LONG_HEADER_BIT;\n    ++dst;\n    /* version */\n    dst = quicly_encode32(dst, 0);\n    /* connection-id */\n    *dst++ = dest_cid.len;\n    if (dest_cid.len != 0) {\n        memcpy(dst, dest_cid.base, dest_cid.len);\n        dst += dest_cid.len;\n    }\n    *dst++ = src_cid.len;\n    if (src_cid.len != 0) {\n        memcpy(dst, src_cid.base, src_cid.len);\n        dst += src_cid.len;\n    }\n    /* supported_versions */\n    for (const uint32_t *v = versions; *v != 0; ++v)\n        dst = quicly_encode32(dst, *v);\n    /* add a greasing version. This also covers the case where an empty list is specified by the caller to indicate rejection. */\n    uint32_t grease_version = 0;\n    if (src_cid.len >= sizeof(grease_version))\n        memcpy(&grease_version, src_cid.base, sizeof(grease_version));\n    grease_version = (grease_version & 0xf0f0f0f0) | 0x0a0a0a0a;\n    dst = quicly_encode32(dst, grease_version);\n\n    return dst - (uint8_t *)payload;\n}\n\nint quicly_retry_calc_cidpair_hash(ptls_hash_algorithm_t *sha256, ptls_iovec_t client_cid, ptls_iovec_t server_cid, uint64_t *value)\n{\n    uint8_t digest[PTLS_SHA256_DIGEST_SIZE], buf[(QUICLY_MAX_CID_LEN_V1 + 1) * 2], *p = buf;\n    int ret;\n\n    *p++ = (uint8_t)client_cid.len;\n    memcpy(p, client_cid.base, client_cid.len);\n    p += client_cid.len;\n    *p++ = (uint8_t)server_cid.len;\n    memcpy(p, server_cid.base, server_cid.len);\n    p += server_cid.len;\n\n    if ((ret = ptls_calc_hash(sha256, digest, buf, p - buf)) != 0)\n        return ret;\n    p = digest;\n    *value = quicly_decode64((void *)&p);\n\n    return 0;\n}\n\nsize_t quicly_send_retry(quicly_context_t *ctx, ptls_aead_context_t *token_encrypt_ctx, uint32_t protocol_version,\n                         struct sockaddr *dest_addr, ptls_iovec_t dest_cid, struct sockaddr *src_addr, ptls_iovec_t src_cid,\n                         ptls_iovec_t odcid, ptls_iovec_t token_prefix, ptls_iovec_t appdata,\n                         ptls_aead_context_t **retry_aead_cache, uint8_t *datagram)\n{\n    quicly_address_token_plaintext_t token;\n    ptls_buffer_t buf;\n    int ret;\n\n    assert(!(src_cid.len == odcid.len && memcmp(src_cid.base, odcid.base, src_cid.len) == 0));\n\n    /* build token as plaintext */\n    token = (quicly_address_token_plaintext_t){QUICLY_ADDRESS_TOKEN_TYPE_RETRY, ctx->now->cb(ctx->now)};\n    set_address(&token.remote, dest_addr);\n    set_address(&token.local, src_addr);\n\n    quicly_set_cid(&token.retry.original_dcid, odcid);\n    quicly_set_cid(&token.retry.client_cid, dest_cid);\n    quicly_set_cid(&token.retry.server_cid, src_cid);\n    if (appdata.len != 0) {\n        assert(appdata.len <= sizeof(token.appdata.bytes));\n        memcpy(token.appdata.bytes, appdata.base, appdata.len);\n        token.appdata.len = appdata.len;\n    }\n\n    /* start building the packet */\n    ptls_buffer_init(&buf, datagram, QUICLY_MIN_CLIENT_INITIAL_SIZE);\n\n    /* first generate a pseudo packet */\n    ptls_buffer_push_block(&buf, 1, { ptls_buffer_pushv(&buf, odcid.base, odcid.len); });\n    ctx->tls->random_bytes(buf.base + buf.off, 1);\n    buf.base[buf.off] = QUICLY_PACKET_TYPE_RETRY | (buf.base[buf.off] & 0x0f);\n    ++buf.off;\n    ptls_buffer_push32(&buf, protocol_version);\n    ptls_buffer_push_block(&buf, 1, { ptls_buffer_pushv(&buf, dest_cid.base, dest_cid.len); });\n    ptls_buffer_push_block(&buf, 1, { ptls_buffer_pushv(&buf, src_cid.base, src_cid.len); });\n    if (token_prefix.len != 0) {\n        assert(token_prefix.len <= buf.capacity - buf.off);\n        memcpy(buf.base + buf.off, token_prefix.base, token_prefix.len);\n        buf.off += token_prefix.len;\n    }\n    if ((ret = quicly_encrypt_address_token(ctx->tls->random_bytes, token_encrypt_ctx, &buf, buf.off - token_prefix.len, &token)) !=\n        0)\n        goto Exit;\n\n    /* append AEAD tag */\n    ret = ptls_buffer_reserve(&buf, PTLS_AESGCM_TAG_SIZE);\n    assert(ret == 0);\n    assert(!buf.is_allocated && \"retry packet is too large\");\n    {\n        ptls_aead_context_t *aead =\n            retry_aead_cache != NULL && *retry_aead_cache != NULL ? *retry_aead_cache : create_retry_aead(ctx, protocol_version, 1);\n        ptls_aead_encrypt(aead, buf.base + buf.off, \"\", 0, 0, buf.base, buf.off);\n        if (retry_aead_cache != NULL) {\n            *retry_aead_cache = aead;\n        } else {\n            ptls_aead_free(aead);\n        }\n    }\n    buf.off += PTLS_AESGCM_TAG_SIZE;\n\n    /* convert the image to a Retry packet, by stripping the ODCID field */\n    memmove(buf.base, buf.base + odcid.len + 1, buf.off - (odcid.len + 1));\n    buf.off -= odcid.len + 1;\n\n    ret = 0;\n\nExit:\n    return ret == 0 ? buf.off : SIZE_MAX;\n}\n\nstatic struct st_quicly_pn_space_t *setup_send_space(quicly_conn_t *conn, size_t epoch, quicly_send_context_t *s)\n{\n    struct st_quicly_pn_space_t *space = NULL;\n\n    switch (epoch) {\n    case QUICLY_EPOCH_INITIAL:\n        if (conn->initial == NULL || (s->current.cipher = &conn->initial->cipher.egress)->aead == NULL)\n            return NULL;\n        s->current.first_byte = QUICLY_PACKET_TYPE_INITIAL;\n        space = &conn->initial->super;\n        break;\n    case QUICLY_EPOCH_HANDSHAKE:\n        if (conn->handshake == NULL || (s->current.cipher = &conn->handshake->cipher.egress)->aead == NULL)\n            return NULL;\n        s->current.first_byte = QUICLY_PACKET_TYPE_HANDSHAKE;\n        space = &conn->handshake->super;\n        break;\n    case QUICLY_EPOCH_0RTT:\n    case QUICLY_EPOCH_1RTT:\n        if (conn->application == NULL || conn->application->cipher.egress.key.header_protection == NULL)\n            return NULL;\n        if ((epoch == QUICLY_EPOCH_0RTT) == conn->application->one_rtt_writable)\n            return NULL;\n        s->current.cipher = &conn->application->cipher.egress.key;\n        s->current.first_byte = epoch == QUICLY_EPOCH_0RTT ? QUICLY_PACKET_TYPE_0RTT : QUICLY_QUIC_BIT;\n        space = &conn->application->super;\n        break;\n    default:\n        assert(!\"logic flaw\");\n        break;\n    }\n\n    return space;\n}\n\nstatic int send_handshake_flow(quicly_conn_t *conn, size_t epoch, quicly_send_context_t *s, int ack_only, int send_probe)\n{\n    struct st_quicly_pn_space_t *space;\n    int ret = 0;\n\n    /* setup send epoch, or return if it's impossible to send in this epoch */\n    if ((space = setup_send_space(conn, epoch, s)) == NULL)\n        return 0;\n\n    /* send ACK */\n    if (space != NULL && (space->unacked_count != 0 || send_probe))\n        if ((ret = send_ack(conn, space, s)) != 0)\n            goto Exit;\n\n    if (!ack_only) {\n        /* send data */\n        while ((conn->egress.pending_flows & (uint8_t)(1 << epoch)) != 0) {\n            quicly_stream_t *stream = quicly_get_stream(conn, -(quicly_stream_id_t)(1 + epoch));\n            assert(stream != NULL);\n            if ((ret = quicly_send_stream(stream, s)) != 0)\n                goto Exit;\n            resched_stream_data(stream);\n            send_probe = 0;\n        }\n\n        /* send probe if requested */\n        if (send_probe) {\n            if ((ret = do_allocate_frame(conn, s, 1, ALLOCATE_FRAME_TYPE_ACK_ELICITING)) != 0)\n                goto Exit;\n            *s->dst++ = QUICLY_FRAME_TYPE_PING;\n            conn->egress.last_retransmittable_sent_at = conn->stash.now;\n            ++conn->super.stats.num_frames_sent.ping;\n            QUICLY_PROBE(PING_SEND, conn, conn->stash.now);\n            QUICLY_LOG_CONN(ping_send, conn, {});\n        }\n    }\n\nExit:\n    return ret;\n}\n\nstatic int send_connection_close(quicly_conn_t *conn, size_t epoch, quicly_send_context_t *s)\n{\n    uint64_t error_code, offending_frame_type;\n    const char *reason_phrase;\n    int ret;\n\n    /* setup send epoch, or return if it's impossible to send in this epoch */\n    if (setup_send_space(conn, epoch, s) == NULL)\n        return 0;\n\n    /* determine the payload, masking the application error when sending the frame using an unauthenticated epoch */\n    error_code = conn->egress.connection_close.error_code;\n    offending_frame_type = conn->egress.connection_close.frame_type;\n    reason_phrase = conn->egress.connection_close.reason_phrase;\n    if (offending_frame_type == UINT64_MAX) {\n        switch (get_epoch(s->current.first_byte)) {\n        case QUICLY_EPOCH_INITIAL:\n        case QUICLY_EPOCH_HANDSHAKE:\n            error_code = QUICLY_TRANSPORT_ERROR_APPLICATION;\n            offending_frame_type = QUICLY_FRAME_TYPE_PADDING;\n            reason_phrase = \"\";\n            break;\n        }\n    }\n\n    /* write frame */\n    if ((ret = do_allocate_frame(conn, s, quicly_close_frame_capacity(error_code, offending_frame_type, reason_phrase),\n                                 ALLOCATE_FRAME_TYPE_NON_ACK_ELICITING)) != 0)\n        return ret;\n    s->dst = quicly_encode_close_frame(s->dst, error_code, offending_frame_type, reason_phrase);\n\n    /* update counter, probe */\n    if (offending_frame_type != UINT64_MAX) {\n        ++conn->super.stats.num_frames_sent.transport_close;\n        QUICLY_PROBE(TRANSPORT_CLOSE_SEND, conn, conn->stash.now, error_code, offending_frame_type, reason_phrase);\n        QUICLY_LOG_CONN(transport_close_send, conn, {\n            PTLS_LOG_ELEMENT_UNSIGNED(error_code, error_code);\n            PTLS_LOG_ELEMENT_UNSIGNED(frame_type, offending_frame_type);\n            PTLS_LOG_ELEMENT_UNSAFESTR(reason_phrase, reason_phrase, strlen(reason_phrase));\n        });\n    } else {\n        ++conn->super.stats.num_frames_sent.application_close;\n        QUICLY_PROBE(APPLICATION_CLOSE_SEND, conn, conn->stash.now, error_code, reason_phrase);\n        QUICLY_LOG_CONN(application_close_send, conn, {\n            PTLS_LOG_ELEMENT_UNSIGNED(error_code, error_code);\n            PTLS_LOG_ELEMENT_UNSAFESTR(reason_phrase, reason_phrase, strlen(reason_phrase));\n        });\n    }\n\n    return 0;\n}\n\nstatic int send_new_connection_id(quicly_conn_t *conn, quicly_send_context_t *s, struct st_quicly_local_cid_t *new_cid)\n{\n    int ret;\n    quicly_sent_t *sent;\n    uint64_t retire_prior_to = 0; /* TODO */\n\n    ret = allocate_ack_eliciting_frame(\n        conn, s, quicly_new_connection_id_frame_capacity(new_cid->sequence, retire_prior_to, new_cid->cid.len), &sent,\n        on_ack_new_connection_id);\n    if (ret != 0)\n        return ret;\n    sent->data.new_connection_id.sequence = new_cid->sequence;\n\n    s->dst = quicly_encode_new_connection_id_frame(s->dst, new_cid->sequence, retire_prior_to, new_cid->cid.cid, new_cid->cid.len,\n                                                   new_cid->stateless_reset_token);\n\n    ++conn->super.stats.num_frames_sent.new_connection_id;\n    QUICLY_PROBE(NEW_CONNECTION_ID_SEND, conn, conn->stash.now, new_cid->sequence, retire_prior_to,\n                 QUICLY_PROBE_HEXDUMP(new_cid->cid.cid, new_cid->cid.len),\n                 QUICLY_PROBE_HEXDUMP(new_cid->stateless_reset_token, QUICLY_STATELESS_RESET_TOKEN_LEN));\n    QUICLY_LOG_CONN(new_connection_id_send, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(sequence, new_cid->sequence);\n        PTLS_LOG_ELEMENT_UNSIGNED(retire_prior_to, retire_prior_to);\n        PTLS_LOG_ELEMENT_HEXDUMP(cid, new_cid->cid.cid, new_cid->cid.len);\n        PTLS_LOG_ELEMENT_HEXDUMP(stateless_reset_token, new_cid->stateless_reset_token, QUICLY_STATELESS_RESET_TOKEN_LEN);\n    });\n\n    return 0;\n}\n\nstatic int send_retire_connection_id(quicly_conn_t *conn, quicly_send_context_t *s, uint64_t sequence)\n{\n    int ret;\n    quicly_sent_t *sent;\n\n    ret = allocate_ack_eliciting_frame(conn, s, quicly_retire_connection_id_frame_capacity(sequence), &sent,\n                                       on_ack_retire_connection_id);\n    if (ret != 0)\n        return ret;\n    sent->data.retire_connection_id.sequence = sequence;\n\n    s->dst = quicly_encode_retire_connection_id_frame(s->dst, sequence);\n\n    ++conn->super.stats.num_frames_sent.retire_connection_id;\n    QUICLY_PROBE(RETIRE_CONNECTION_ID_SEND, conn, conn->stash.now, sequence);\n    QUICLY_LOG_CONN(retire_connection_id_send, conn, { PTLS_LOG_ELEMENT_UNSIGNED(sequence, sequence); });\n\n    return 0;\n}\n\nstatic int send_path_challenge(quicly_conn_t *conn, quicly_send_context_t *s, int is_response, const uint8_t *data)\n{\n    int ret;\n\n    if ((ret = do_allocate_frame(conn, s, QUICLY_PATH_CHALLENGE_FRAME_CAPACITY, ALLOCATE_FRAME_TYPE_ACK_ELICITING_NO_CC)) != 0)\n        return ret;\n\n    s->dst = quicly_encode_path_challenge_frame(s->dst, is_response, data);\n    s->target.full_size = 1; /* ensure that the path can transfer full-size packets */\n\n    if (!is_response) {\n        ++conn->super.stats.num_frames_sent.path_challenge;\n    } else {\n        ++conn->super.stats.num_frames_sent.path_response;\n    }\n\n    return 0;\n}\n\nstatic int update_traffic_key_cb(ptls_update_traffic_key_t *self, ptls_t *tls, int is_enc, size_t epoch, const void *secret)\n{\n    quicly_conn_t *conn = *ptls_get_data_ptr(tls);\n    ptls_context_t *tlsctx = ptls_get_context(tls);\n    ptls_cipher_suite_t *cipher = ptls_get_cipher(tls);\n    ptls_cipher_context_t **hp_slot;\n    ptls_aead_context_t **aead_slot;\n    int ret;\n    static const char *log_labels[2][4] = {\n        {NULL, \"CLIENT_EARLY_TRAFFIC_SECRET\", \"CLIENT_HANDSHAKE_TRAFFIC_SECRET\", \"CLIENT_TRAFFIC_SECRET_0\"},\n        {NULL, NULL, \"SERVER_HANDSHAKE_TRAFFIC_SECRET\", \"SERVER_TRAFFIC_SECRET_0\"}};\n    const char *log_label = log_labels[ptls_is_server(tls) == is_enc][epoch];\n\n    QUICLY_PROBE(CRYPTO_UPDATE_SECRET, conn, conn->stash.now, is_enc, epoch, log_label,\n                 QUICLY_PROBE_HEXDUMP(secret, cipher->hash->digest_size));\n    QUICLY_LOG_CONN(crypto_update_secret, conn, {\n        PTLS_LOG_ELEMENT_BOOL(is_enc, is_enc);\n        PTLS_LOG_ELEMENT_UNSIGNED(epoch, epoch);\n        PTLS_LOG_ELEMENT_SAFESTR(label, log_label);\n        PTLS_LOG_APPDATA_ELEMENT_HEXDUMP(secret, secret, cipher->hash->digest_size);\n    });\n\n    if (tlsctx->log_event != NULL) {\n        char hexbuf[PTLS_MAX_DIGEST_SIZE * 2 + 1];\n        ptls_hexdump(hexbuf, secret, cipher->hash->digest_size);\n        tlsctx->log_event->cb(tlsctx->log_event, tls, log_label, \"%s\", hexbuf);\n    }\n\n#define SELECT_CIPHER_CONTEXT(p)                                                                                                   \\\n    do {                                                                                                                           \\\n        hp_slot = &(p)->header_protection;                                                                                         \\\n        aead_slot = &(p)->aead;                                                                                                    \\\n    } while (0)\n\n    switch (epoch) {\n    case QUICLY_EPOCH_0RTT:\n        assert(is_enc == quicly_is_client(conn));\n        if (conn->application == NULL && (ret = setup_application_space(conn)) != 0)\n            return ret;\n        if (is_enc) {\n            SELECT_CIPHER_CONTEXT(&conn->application->cipher.egress.key);\n        } else {\n            hp_slot = &conn->application->cipher.ingress.header_protection.zero_rtt;\n            aead_slot = &conn->application->cipher.ingress.aead[1];\n        }\n        break;\n    case QUICLY_EPOCH_HANDSHAKE:\n        if (conn->handshake == NULL && (ret = setup_handshake_space_and_flow(conn, QUICLY_EPOCH_HANDSHAKE)) != 0)\n            return ret;\n        SELECT_CIPHER_CONTEXT(is_enc ? &conn->handshake->cipher.egress : &conn->handshake->cipher.ingress);\n        break;\n    case QUICLY_EPOCH_1RTT: {\n        if (is_enc)\n            if ((ret = apply_remote_transport_params(conn)) != 0)\n                return ret;\n        if (conn->application == NULL && (ret = setup_application_space(conn)) != 0)\n            return ret;\n        uint8_t *secret_store;\n        if (is_enc) {\n            if (conn->application->cipher.egress.key.aead != NULL)\n                dispose_cipher(&conn->application->cipher.egress.key);\n            SELECT_CIPHER_CONTEXT(&conn->application->cipher.egress.key);\n            secret_store = conn->application->cipher.egress.secret;\n        } else {\n            hp_slot = &conn->application->cipher.ingress.header_protection.one_rtt;\n            aead_slot = &conn->application->cipher.ingress.aead[0];\n            secret_store = conn->application->cipher.ingress.secret;\n        }\n        memcpy(secret_store, secret, cipher->hash->digest_size);\n    } break;\n    default:\n        assert(!\"logic flaw\");\n        break;\n    }\n\n#undef SELECT_CIPHER_CONTEXT\n\n    if ((ret = setup_cipher(conn, epoch, is_enc, hp_slot, aead_slot, cipher->aead, cipher->hash, secret)) != 0)\n        return ret;\n\n    if (epoch == QUICLY_EPOCH_1RTT && is_enc) {\n        /* update states now that we have 1-RTT write key */\n        conn->application->one_rtt_writable = 1;\n        open_blocked_streams(conn, 1);\n        open_blocked_streams(conn, 0);\n        /* send the first resumption token using the 0.5 RTT window */\n        if (!quicly_is_client(conn) && conn->super.ctx->generate_resumption_token != NULL) {\n            ret = quicly_send_resumption_token(conn);\n            assert(ret == 0);\n        }\n\n        /* schedule NEW_CONNECTION_IDs */\n        size_t size = local_cid_size(conn);\n        if (quicly_local_cid_set_size(&conn->super.local.cid_set, size))\n            conn->egress.pending_flows |= QUICLY_PENDING_FLOW_OTHERS_BIT;\n    }\n\n    return 0;\n}\n\nstatic int send_other_control_frames(quicly_conn_t *conn, quicly_send_context_t *s)\n{\n    int ret;\n\n    /* respond to all pending received PATH_CHALLENGE frames */\n    if (conn->egress.path_response.send_) {\n        if ((ret = send_path_challenge(conn, s, 1, conn->egress.path_response.data)) != 0)\n            return ret;\n        conn->egress.path_response.send_ = 0;\n    }\n\n    /* MAX_STREAMS */\n    if ((ret = send_max_streams(conn, 1, s)) != 0)\n        return ret;\n    if ((ret = send_max_streams(conn, 0, s)) != 0)\n        return ret;\n\n    /* MAX_DATA */\n    if (should_send_max_data(conn)) {\n        quicly_sent_t *sent;\n        if ((ret = allocate_ack_eliciting_frame(conn, s, QUICLY_MAX_DATA_FRAME_CAPACITY, &sent, on_ack_max_data)) != 0)\n            return ret;\n        uint64_t new_value = conn->ingress.max_data.bytes_consumed + conn->super.ctx->transport_params.max_data;\n        s->dst = quicly_encode_max_data_frame(s->dst, new_value);\n        quicly_maxsender_record(&conn->ingress.max_data.sender, new_value, &sent->data.max_data.args);\n        ++conn->super.stats.num_frames_sent.max_data;\n        QUICLY_PROBE(MAX_DATA_SEND, conn, conn->stash.now, new_value);\n        QUICLY_LOG_CONN(max_data_send, conn, { PTLS_LOG_ELEMENT_UNSIGNED(maximum, new_value); });\n    }\n\n    /* DATA_BLOCKED */\n    if (conn->egress.data_blocked == QUICLY_SENDER_STATE_SEND && (ret = send_data_blocked(conn, s)) != 0)\n        return ret;\n\n    /* STREAMS_BLOCKED */\n    if ((ret = send_streams_blocked(conn, 1, s)) != 0)\n        return ret;\n    if ((ret = send_streams_blocked(conn, 0, s)) != 0)\n        return ret;\n\n    { /* NEW_CONNECTION_ID */\n        size_t i, size = quicly_local_cid_get_size(&conn->super.local.cid_set);\n        for (i = 0; i < size; i++) {\n            /* PENDING CIDs are located at the front */\n            struct st_quicly_local_cid_t *c = &conn->super.local.cid_set.cids[i];\n            if (c->state != QUICLY_LOCAL_CID_STATE_PENDING)\n                break;\n            if ((ret = send_new_connection_id(conn, s, c)) != 0)\n                break;\n        }\n        quicly_local_cid_on_sent(&conn->super.local.cid_set, i);\n        if (ret != 0)\n            return ret;\n    }\n\n    { /* RETIRE_CONNECTION_ID */\n        size_t i, size = quicly_retire_cid_get_num_pending(&conn->egress.retire_cid);\n        for (i = 0; i < size; i++) {\n            uint64_t sequence = conn->egress.retire_cid.sequences[i];\n            if ((ret = send_retire_connection_id(conn, s, sequence)) != 0)\n                break;\n        }\n        quicly_retire_cid_shift(&conn->egress.retire_cid, i);\n        if (ret != 0)\n            return ret;\n    }\n\n    return 0;\n}\n\nstatic int do_send(quicly_conn_t *conn, quicly_send_context_t *s)\n{\n    int restrict_sending = 0, ack_only = 0, ret;\n    size_t min_packets_to_send = 0;\n\n    /* handle timeouts */\n    if (conn->idle_timeout.at <= conn->stash.now) {\n        QUICLY_PROBE(IDLE_TIMEOUT, conn, conn->stash.now);\n        QUICLY_LOG_CONN(idle_timeout, conn, {});\n        goto CloseNow;\n    }\n    /* handle handshake timeouts */\n    if ((conn->initial != NULL || conn->handshake != NULL) &&\n        conn->created_at + (uint64_t)conn->super.ctx->handshake_timeout_rtt_multiplier * conn->egress.loss.rtt.smoothed <=\n            conn->stash.now) {\n        QUICLY_PROBE(HANDSHAKE_TIMEOUT, conn, conn->stash.now, conn->stash.now - conn->created_at, conn->egress.loss.rtt.smoothed);\n        QUICLY_LOG_CONN(handshake_timeout, conn, {\n            PTLS_LOG_ELEMENT_SIGNED(elapsed, conn->stash.now - conn->created_at);\n            PTLS_LOG_ELEMENT_UNSIGNED(rtt_smoothed, conn->egress.loss.rtt.smoothed);\n        });\n        conn->super.stats.num_handshake_timeouts++;\n        goto CloseNow;\n    }\n    if (conn->super.stats.num_packets.initial_handshake_sent > conn->super.ctx->max_initial_handshake_packets) {\n        QUICLY_PROBE(INITIAL_HANDSHAKE_PACKET_EXCEED, conn, conn->stash.now, conn->super.stats.num_packets.initial_handshake_sent);\n        QUICLY_LOG_CONN(initial_handshake_packet_exceed, conn,\n                        { PTLS_LOG_ELEMENT_UNSIGNED(num_packets, conn->super.stats.num_packets.initial_handshake_sent); });\n        conn->super.stats.num_initial_handshake_exceeded++;\n        goto CloseNow;\n    }\n    if (conn->egress.loss.alarm_at <= conn->stash.now) {\n        if ((ret = quicly_loss_on_alarm(&conn->egress.loss, conn->stash.now, conn->super.remote.transport_params.max_ack_delay,\n                                        conn->initial == NULL && conn->handshake == NULL, &min_packets_to_send, &restrict_sending,\n                                        on_loss_detected)) != 0)\n            goto Exit;\n        assert(min_packets_to_send > 0);\n        assert(min_packets_to_send <= s->max_datagrams);\n\n        if (restrict_sending) {\n            /* PTO: when handshake is in progress, send from the very first unacknowledged byte so as to maximize the chance of\n             * making progress. When handshake is complete, transmit new data if any, else retransmit the oldest unacknowledged data\n             * that is considered inflight. */\n            QUICLY_PROBE(PTO, conn, conn->stash.now, conn->egress.loss.sentmap.bytes_in_flight, conn->egress.cc.cwnd,\n                         conn->egress.loss.pto_count);\n            QUICLY_LOG_CONN(pto, conn, {\n                PTLS_LOG_ELEMENT_SIGNED(inflight, conn->egress.loss.sentmap.bytes_in_flight);\n                PTLS_LOG_ELEMENT_UNSIGNED(cwnd, conn->egress.cc.cwnd);\n                PTLS_LOG_ELEMENT_SIGNED(pto_count, conn->egress.loss.pto_count);\n            });\n            ++conn->super.stats.num_ptos;\n            size_t bytes_to_mark = min_packets_to_send * conn->egress.max_udp_payload_size;\n            if (conn->initial != NULL && (ret = mark_frames_on_pto(conn, QUICLY_EPOCH_INITIAL, &bytes_to_mark)) != 0)\n                goto Exit;\n            if (bytes_to_mark != 0 && conn->handshake != NULL &&\n                (ret = mark_frames_on_pto(conn, QUICLY_EPOCH_HANDSHAKE, &bytes_to_mark)) != 0)\n                goto Exit;\n            /* Mark already sent 1-RTT data for PTO only if there's no new data, i.e., when scheduler_can_send() return false. */\n            if (bytes_to_mark != 0 && !scheduler_can_send(conn) &&\n                (ret = mark_frames_on_pto(conn, QUICLY_EPOCH_1RTT, &bytes_to_mark)) != 0)\n                goto Exit;\n        }\n    }\n\n    /* disable ECN if zero packets where acked in the first 3 PTO of the connection during which all sent packets are ECT(0) */\n    if (conn->egress.ecn.state == QUICLY_ECN_PROBING && conn->created_at + conn->egress.loss.rtt.smoothed * 3 < conn->stash.now) {\n        update_ecn_state(conn, QUICLY_ECN_OFF);\n        /* TODO reset CC? */\n    }\n\n    s->send_window = calc_send_window(conn, min_packets_to_send * conn->egress.max_udp_payload_size,\n                                      calc_amplification_limit_allowance(conn), restrict_sending);\n    if (s->send_window == 0)\n        ack_only = 1;\n\n    /* send handshake flows; when PTO fires...\n     *  * quicly running as a client sends either a Handshake probe (or data) if the handshake keys are available, or else an\n     *    Initial probe (or data).\n     *  * quicly running as a server sends both Initial and Handshake probes (or data) if the corresponding keys are available. */\n    if ((ret = send_handshake_flow(conn, QUICLY_EPOCH_INITIAL, s, ack_only,\n                                   min_packets_to_send != 0 && (!quicly_is_client(conn) || conn->handshake == NULL))) != 0)\n        goto Exit;\n    if ((ret = send_handshake_flow(conn, QUICLY_EPOCH_HANDSHAKE, s, ack_only, min_packets_to_send != 0)) != 0)\n        goto Exit;\n\n    /* setup 0-RTT or 1-RTT send context (as the availability of the two epochs are mutually exclusive, we can try 1-RTT first as an\n     * optimization), then send application data if that succeeds */\n    if (setup_send_space(conn, QUICLY_EPOCH_1RTT, s) != NULL || setup_send_space(conn, QUICLY_EPOCH_0RTT, s) != NULL) {\n        /* acks */\n        if (conn->application->one_rtt_writable && conn->egress.send_ack_at <= conn->stash.now &&\n            conn->application->super.unacked_count != 0) {\n            if ((ret = send_ack(conn, &conn->application->super, s)) != 0)\n                goto Exit;\n        }\n        /* DATAGRAM frame. Notes regarding current implementation:\n         * * Not limited by CC, nor the bytes counted by CC.\n         * * When given payload is too large and does not fit into a QUIC packet, a packet containing only PADDING frames is sent.\n         *   This is because we do not have a way to retract the generation of a QUIC packet.\n         * * Does not notify the application that the frame was dropped internally. */\n        if (should_send_datagram_frame(conn)) {\n            for (size_t i = 0; i != conn->egress.datagram_frame_payloads.count; ++i) {\n                ptls_iovec_t *payload = conn->egress.datagram_frame_payloads.payloads + i;\n                size_t required_space = quicly_datagram_frame_capacity(*payload);\n                if ((ret = do_allocate_frame(conn, s, required_space, ALLOCATE_FRAME_TYPE_ACK_ELICITING_NO_CC)) != 0)\n                    goto Exit;\n                if (s->dst_end - s->dst >= required_space) {\n                    s->dst = quicly_encode_datagram_frame(s->dst, *payload);\n                    QUICLY_PROBE(DATAGRAM_SEND, conn, conn->stash.now, payload->base, payload->len);\n                    QUICLY_LOG_CONN(datagram_send, conn,\n                                    { PTLS_LOG_APPDATA_ELEMENT_HEXDUMP(payload, payload->base, payload->len); });\n                } else {\n                    /* FIXME: At the moment, we add a padding because we do not have a way to reclaim allocated space, and because\n                     * it is forbidden to send an empty QUIC packet. */\n                    *s->dst++ = QUICLY_FRAME_TYPE_PADDING;\n                }\n            }\n        }\n        if (!ack_only) {\n            /* PTO or loss detection timeout, always send PING. This is the easiest thing to do in terms of timer control. */\n            if (min_packets_to_send != 0) {\n                if ((ret = do_allocate_frame(conn, s, 1, ALLOCATE_FRAME_TYPE_ACK_ELICITING)) != 0)\n                    goto Exit;\n                *s->dst++ = QUICLY_FRAME_TYPE_PING;\n                ++conn->super.stats.num_frames_sent.ping;\n                QUICLY_PROBE(PING_SEND, conn, conn->stash.now);\n                QUICLY_LOG_CONN(ping_send, conn, {});\n            }\n            /* take actions only permitted for short header packets */\n            if (conn->application->one_rtt_writable) {\n                /* send HANDSHAKE_DONE */\n                if ((conn->egress.pending_flows & QUICLY_PENDING_FLOW_HANDSHAKE_DONE_BIT) != 0 &&\n                    (ret = send_handshake_done(conn, s)) != 0)\n                    goto Exit;\n                /* post-handshake messages */\n                if ((conn->egress.pending_flows & (uint8_t)(1 << QUICLY_EPOCH_1RTT)) != 0) {\n                    quicly_stream_t *stream = quicly_get_stream(conn, -(1 + QUICLY_EPOCH_1RTT));\n                    assert(stream != NULL);\n                    if ((ret = quicly_send_stream(stream, s)) != 0)\n                        goto Exit;\n                    resched_stream_data(stream);\n                }\n                /* send other connection-level control frames, and iff we succeed in sending all of them, clear OTHERS_BIT to\n                 * disable `quicly_send` being called right again to send more control frames */\n                if ((ret = send_other_control_frames(conn, s)) != 0)\n                    goto Exit;\n                conn->egress.pending_flows &= ~QUICLY_PENDING_FLOW_OTHERS_BIT;\n                /* send NEW_TOKEN */\n                if ((conn->egress.pending_flows & QUICLY_PENDING_FLOW_NEW_TOKEN_BIT) != 0 &&\n                    (ret = send_resumption_token(conn, s)) != 0)\n                    goto Exit;\n            }\n            /* send stream-level control frames */\n            if ((ret = send_stream_control_frames(conn, s)) != 0)\n                goto Exit;\n            /* send STREAM frames */\n            if ((ret = conn->super.ctx->stream_scheduler->do_send(conn->super.ctx->stream_scheduler, conn, s)) != 0)\n                goto Exit;\n            /* once more, send control frames related to streams, as the state might have changed */\n            if ((ret = send_stream_control_frames(conn, s)) != 0)\n                goto Exit;\n            if ((conn->egress.pending_flows & QUICLY_PENDING_FLOW_OTHERS_BIT) != 0) {\n                if ((ret = send_other_control_frames(conn, s)) != 0)\n                    goto Exit;\n                conn->egress.pending_flows &= ~QUICLY_PENDING_FLOW_OTHERS_BIT;\n            }\n        }\n    }\n\nExit:\n    if (ret == QUICLY_ERROR_SENDBUF_FULL)\n        ret = 0;\n    if (ret == 0 && s->target.first_byte_at != NULL) {\n        /* last packet can be small-sized, unless it is the first flight sent from the client */\n        if ((s->payload_buf.datagram[0] & QUICLY_PACKET_TYPE_BITMASK) == QUICLY_PACKET_TYPE_INITIAL &&\n            (quicly_is_client(conn) || !ack_only))\n            s->target.full_size = 1;\n        commit_send_packet(conn, s, 0);\n    }\n    if (ret == 0) {\n        /* update timers, start / stop delivery rate estimator */\n        if (conn->application == NULL || conn->application->super.unacked_count == 0)\n            conn->egress.send_ack_at = INT64_MAX; /* we have sent ACKs for every epoch (or before address validation) */\n        int can_send_stream_data = scheduler_can_send(conn);\n        update_send_alarm(conn, can_send_stream_data, 1);\n        if (can_send_stream_data &&\n            (s->num_datagrams == s->max_datagrams || conn->egress.loss.sentmap.bytes_in_flight >= conn->egress.cc.cwnd)) {\n            /* as the flow is CWND-limited, start delivery rate estimator */\n            quicly_ratemeter_in_cwnd_limited(&conn->egress.ratemeter, s->first_packet_number);\n        } else {\n            quicly_ratemeter_not_cwnd_limited(&conn->egress.ratemeter, conn->egress.packet_number);\n        }\n        if (s->num_datagrams != 0)\n            update_idle_timeout(conn, 0);\n    }\n    return ret;\n\nCloseNow:\n    conn->super.state = QUICLY_STATE_DRAINING;\n    destroy_all_streams(conn, 0, 0);\n    return QUICLY_ERROR_FREE_CONNECTION;\n}\n\nvoid quicly_send_datagram_frames(quicly_conn_t *conn, ptls_iovec_t *datagrams, size_t num_datagrams)\n{\n    for (size_t i = 0; i != num_datagrams; ++i) {\n        if (conn->egress.datagram_frame_payloads.count == PTLS_ELEMENTSOF(conn->egress.datagram_frame_payloads.payloads))\n            break;\n        void *copied;\n        if ((copied = malloc(datagrams[i].len)) == NULL)\n            break;\n        memcpy(copied, datagrams[i].base, datagrams[i].len);\n        conn->egress.datagram_frame_payloads.payloads[conn->egress.datagram_frame_payloads.count++] =\n            ptls_iovec_init(copied, datagrams[i].len);\n    }\n}\n\nint quicly_set_cc(quicly_conn_t *conn, quicly_cc_type_t *cc)\n{\n    return cc->cc_switch(&conn->egress.cc);\n}\n\nint quicly_send(quicly_conn_t *conn, quicly_address_t *dest, quicly_address_t *src, struct iovec *datagrams, size_t *num_datagrams,\n                void *buf, size_t bufsize)\n{\n    quicly_send_context_t s = {.current = {.first_byte = -1},\n                               .datagrams = datagrams,\n                               .max_datagrams = *num_datagrams,\n                               .payload_buf = {.datagram = buf, .end = (uint8_t *)buf + bufsize},\n                               .first_packet_number = conn->egress.packet_number};\n    int ret;\n\n    lock_now(conn, 0);\n\n    /* bail out if there's nothing is scheduled to be sent */\n    if (conn->stash.now < quicly_get_first_timeout(conn)) {\n        ret = 0;\n        goto Exit;\n    }\n\n    QUICLY_PROBE(SEND, conn, conn->stash.now, conn->super.state,\n                 QUICLY_PROBE_HEXDUMP(conn->super.remote.cid_set.cids[0].cid.cid, conn->super.remote.cid_set.cids[0].cid.len));\n    QUICLY_LOG_CONN(send, conn, {\n        PTLS_LOG_ELEMENT_SIGNED(state, conn->super.state);\n        PTLS_LOG_ELEMENT_HEXDUMP(dcid, conn->super.remote.cid_set.cids[0].cid.cid, conn->super.remote.cid_set.cids[0].cid.len);\n    });\n\n    if (conn->super.state >= QUICLY_STATE_CLOSING) {\n        quicly_sentmap_iter_t iter;\n        if ((ret = init_acks_iter(conn, &iter)) != 0)\n            goto Exit;\n        /* check if the connection can be closed now (after 3 pto) */\n        if (conn->super.state == QUICLY_STATE_DRAINING ||\n            conn->super.stats.num_frames_sent.transport_close + conn->super.stats.num_frames_sent.application_close != 0) {\n            if (quicly_sentmap_get(&iter)->packet_number == UINT64_MAX) {\n                assert(quicly_num_streams(conn) == 0);\n                ret = QUICLY_ERROR_FREE_CONNECTION;\n                goto Exit;\n            }\n        }\n        if (conn->super.state == QUICLY_STATE_CLOSING && conn->egress.send_ack_at <= conn->stash.now) {\n            /* destroy all streams; doing so is delayed until the emission of CONNECTION_CLOSE frame to allow quicly_close to be\n             * called from a stream handler */\n            destroy_all_streams(conn, 0, 0);\n            /* send CONNECTION_CLOSE in all possible epochs */\n            for (size_t epoch = 0; epoch < QUICLY_NUM_EPOCHS; ++epoch) {\n                if ((ret = send_connection_close(conn, epoch, &s)) != 0)\n                    goto Exit;\n            }\n            if ((ret = commit_send_packet(conn, &s, 0)) != 0)\n                goto Exit;\n        }\n        /* wait at least 1ms */\n        if ((conn->egress.send_ack_at = quicly_sentmap_get(&iter)->sent_at + get_sentmap_expiration_time(conn)) <= conn->stash.now)\n            conn->egress.send_ack_at = conn->stash.now + 1;\n        ret = 0;\n        goto Exit;\n    }\n\n    /* emit packets */\n    if ((ret = do_send(conn, &s)) != 0)\n        goto Exit;\n\n    assert_consistency(conn, 1);\n\nExit:\n    clear_datagram_frame_payloads(conn);\n    if (s.num_datagrams != 0) {\n        *dest = conn->super.remote.address;\n        *src = conn->super.local.address;\n    }\n    *num_datagrams = s.num_datagrams;\n    unlock_now(conn);\n    return ret;\n}\n\nuint8_t quicly_send_get_ecn_bits(quicly_conn_t *conn)\n{\n    return conn->egress.ecn.state == QUICLY_ECN_OFF ? 0 : 2; /* NON-ECT or ECT(0) */\n}\n\nsize_t quicly_send_close_invalid_token(quicly_context_t *ctx, uint32_t protocol_version, ptls_iovec_t dest_cid,\n                                       ptls_iovec_t src_cid, const char *err_desc, void *datagram)\n{\n    struct st_quicly_cipher_context_t egress = {};\n    const struct st_ptls_salt_t *salt;\n\n    /* setup keys */\n    if ((salt = get_salt(protocol_version)) == NULL)\n        return SIZE_MAX;\n    if (setup_initial_encryption(get_aes128gcmsha256(ctx), NULL, &egress, src_cid, 0,\n                                 ptls_iovec_init(salt->initial, sizeof(salt->initial)), NULL) != 0)\n        return SIZE_MAX;\n\n    uint8_t *dst = datagram, *length_at;\n\n    /* build packet */\n    PTLS_BUILD_ASSERT(QUICLY_SEND_PN_SIZE == 2);\n    *dst++ = QUICLY_PACKET_TYPE_INITIAL | 0x1 /* 2-byte PN */;\n    dst = quicly_encode32(dst, protocol_version);\n    *dst++ = dest_cid.len;\n    memcpy(dst, dest_cid.base, dest_cid.len);\n    dst += dest_cid.len;\n    *dst++ = src_cid.len;\n    memcpy(dst, src_cid.base, src_cid.len);\n    dst += src_cid.len;\n    *dst++ = 0;        /* token_length = 0 */\n    length_at = dst++; /* length_at to be filled in later as 1-byte varint */\n    *dst++ = 0;        /* PN = 0 */\n    *dst++ = 0;        /* ditto */\n    uint8_t *payload_from = dst;\n    dst = quicly_encode_close_frame(dst, QUICLY_ERROR_GET_ERROR_CODE(QUICLY_TRANSPORT_ERROR_INVALID_TOKEN),\n                                    QUICLY_FRAME_TYPE_PADDING, err_desc);\n\n    /* determine the size of the packet, make adjustments */\n    dst += egress.aead->algo->tag_size;\n    assert(dst - (uint8_t *)datagram <= QUICLY_MIN_CLIENT_INITIAL_SIZE);\n    assert(dst - length_at - 1 < 64);\n    *length_at = dst - length_at - 1;\n    size_t datagram_len = dst - (uint8_t *)datagram;\n\n    /* encrypt packet */\n    quicly_default_crypto_engine.encrypt_packet(&quicly_default_crypto_engine, NULL, egress.header_protection, egress.aead,\n                                                ptls_iovec_init(datagram, datagram_len), 0, payload_from - (uint8_t *)datagram, 0,\n                                                0);\n\n    dispose_cipher(&egress);\n    return datagram_len;\n}\n\nsize_t quicly_send_stateless_reset(quicly_context_t *ctx, const void *src_cid, void *payload)\n{\n    uint8_t *base = payload;\n\n    /* build stateless reset packet */\n    ctx->tls->random_bytes(base, QUICLY_STATELESS_RESET_PACKET_MIN_LEN - QUICLY_STATELESS_RESET_TOKEN_LEN);\n    base[0] = (base[0] & ~QUICLY_LONG_HEADER_BIT) | QUICLY_QUIC_BIT;\n    if (!ctx->cid_encryptor->generate_stateless_reset_token(\n            ctx->cid_encryptor, base + QUICLY_STATELESS_RESET_PACKET_MIN_LEN - QUICLY_STATELESS_RESET_TOKEN_LEN, src_cid))\n        return SIZE_MAX;\n\n    return QUICLY_STATELESS_RESET_PACKET_MIN_LEN;\n}\n\nint quicly_send_resumption_token(quicly_conn_t *conn)\n{\n    if (conn->super.state <= QUICLY_STATE_CONNECTED) {\n        ++conn->egress.new_token.generation;\n        conn->egress.pending_flows |= QUICLY_PENDING_FLOW_NEW_TOKEN_BIT;\n    }\n    return 0;\n}\n\nstatic int on_end_closing(quicly_sentmap_t *map, const quicly_sent_packet_t *packet, int acked, quicly_sent_t *sent)\n{\n    /* we stop accepting frames by the time this ack callback is being registered */\n    assert(!acked);\n    return 0;\n}\n\nstatic int enter_close(quicly_conn_t *conn, int local_is_initiating, int wait_draining)\n{\n    int ret;\n\n    assert(conn->super.state < QUICLY_STATE_CLOSING);\n\n    /* release all inflight info, register a close timeout */\n    if ((ret = discard_sentmap_by_epoch(conn, ~0u)) != 0)\n        return ret;\n    if ((ret = quicly_sentmap_prepare(&conn->egress.loss.sentmap, conn->egress.packet_number, conn->stash.now,\n                                      QUICLY_EPOCH_INITIAL)) != 0)\n        return ret;\n    if (quicly_sentmap_allocate(&conn->egress.loss.sentmap, on_end_closing) == NULL)\n        return PTLS_ERROR_NO_MEMORY;\n    quicly_sentmap_commit(&conn->egress.loss.sentmap, 0);\n    ++conn->egress.packet_number;\n\n    if (local_is_initiating) {\n        conn->super.state = QUICLY_STATE_CLOSING;\n        conn->egress.send_ack_at = 0;\n    } else {\n        conn->super.state = QUICLY_STATE_DRAINING;\n        conn->egress.send_ack_at = wait_draining ? conn->stash.now + get_sentmap_expiration_time(conn) : 0;\n    }\n\n    setup_next_send(conn);\n\n    return 0;\n}\n\nint initiate_close(quicly_conn_t *conn, int err, uint64_t frame_type, const char *reason_phrase)\n{\n    uint16_t quic_error_code;\n\n    if (conn->super.state >= QUICLY_STATE_CLOSING)\n        return 0;\n\n    if (reason_phrase == NULL)\n        reason_phrase = \"\";\n\n    /* convert error code to QUIC error codes */\n    if (err == 0) {\n        quic_error_code = 0;\n        frame_type = QUICLY_FRAME_TYPE_PADDING;\n    } else if (QUICLY_ERROR_IS_QUIC_TRANSPORT(err)) {\n        quic_error_code = QUICLY_ERROR_GET_ERROR_CODE(err);\n    } else if (QUICLY_ERROR_IS_QUIC_APPLICATION(err)) {\n        quic_error_code = QUICLY_ERROR_GET_ERROR_CODE(err);\n        frame_type = UINT64_MAX;\n    } else if (PTLS_ERROR_GET_CLASS(err) == PTLS_ERROR_CLASS_SELF_ALERT) {\n        quic_error_code = QUICLY_TRANSPORT_ERROR_TLS_ALERT_BASE + PTLS_ERROR_TO_ALERT(err);\n    } else {\n        quic_error_code = QUICLY_ERROR_GET_ERROR_CODE(QUICLY_TRANSPORT_ERROR_INTERNAL);\n    }\n\n    conn->egress.connection_close.error_code = quic_error_code;\n    conn->egress.connection_close.frame_type = frame_type;\n    conn->egress.connection_close.reason_phrase = reason_phrase;\n    return enter_close(conn, 1, 0);\n}\n\nint quicly_close(quicly_conn_t *conn, int err, const char *reason_phrase)\n{\n    int ret;\n\n    assert(err == 0 || QUICLY_ERROR_IS_QUIC_APPLICATION(err) || QUICLY_ERROR_IS_CONCEALED(err));\n\n    lock_now(conn, 1);\n    ret = initiate_close(conn, err, QUICLY_FRAME_TYPE_PADDING /* used when err == 0 */, reason_phrase);\n    unlock_now(conn);\n\n    return ret;\n}\n\nint quicly_get_or_open_stream(quicly_conn_t *conn, uint64_t stream_id, quicly_stream_t **stream)\n{\n    int ret = 0;\n\n    if ((*stream = quicly_get_stream(conn, stream_id)) != NULL)\n        goto Exit;\n\n    if (quicly_stream_is_client_initiated(stream_id) != quicly_is_client(conn)) {\n        /* check if stream id is within the bounds */\n        if (stream_id / 4 >= quicly_get_ingress_max_streams(conn, quicly_stream_is_unidirectional(stream_id))) {\n            ret = QUICLY_TRANSPORT_ERROR_STREAM_LIMIT;\n            goto Exit;\n        }\n        /* open new streams upto given id */\n        struct st_quicly_conn_streamgroup_state_t *group = get_streamgroup_state(conn, stream_id);\n        if (group->next_stream_id <= stream_id) {\n            uint64_t max_stream_data_local, max_stream_data_remote;\n            if (quicly_stream_is_unidirectional(stream_id)) {\n                max_stream_data_local = conn->super.ctx->transport_params.max_stream_data.uni;\n                max_stream_data_remote = 0;\n            } else {\n                max_stream_data_local = conn->super.ctx->transport_params.max_stream_data.bidi_remote;\n                max_stream_data_remote = conn->super.remote.transport_params.max_stream_data.bidi_local;\n            }\n            do {\n                if ((*stream = open_stream(conn, group->next_stream_id, (uint32_t)max_stream_data_local, max_stream_data_remote)) ==\n                    NULL) {\n                    ret = PTLS_ERROR_NO_MEMORY;\n                    goto Exit;\n                }\n                QUICLY_PROBE(STREAM_ON_OPEN, conn, conn->stash.now, *stream);\n                QUICLY_LOG_CONN(stream_on_open, conn, { PTLS_LOG_ELEMENT_SIGNED(stream_id, (*stream)->stream_id); });\n                if ((ret = conn->super.ctx->stream_open->cb(conn->super.ctx->stream_open, *stream)) != 0) {\n                    *stream = NULL;\n                    goto Exit;\n                }\n                ++group->num_streams;\n                group->next_stream_id += 4;\n            } while (stream_id != (*stream)->stream_id);\n        }\n    }\n\nExit:\n    return ret;\n}\n\nstatic int handle_crypto_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_stream_frame_t frame;\n    quicly_stream_t *stream;\n    int ret;\n\n    if ((ret = quicly_decode_crypto_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n    stream = quicly_get_stream(conn, -(quicly_stream_id_t)(1 + state->epoch));\n    assert(stream != NULL);\n    return apply_stream_frame(stream, &frame);\n}\n\nstatic int handle_stream_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_stream_frame_t frame;\n    quicly_stream_t *stream;\n    int ret;\n\n    if ((ret = quicly_decode_stream_frame(state->frame_type, &state->src, state->end, &frame)) != 0)\n        return ret;\n    QUICLY_PROBE(QUICTRACE_RECV_STREAM, conn, conn->stash.now, frame.stream_id, frame.offset, frame.data.len, (int)frame.is_fin);\n    if ((ret = quicly_get_or_open_stream(conn, frame.stream_id, &stream)) != 0 || stream == NULL)\n        return ret;\n    return apply_stream_frame(stream, &frame);\n}\n\nstatic int handle_reset_stream_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_reset_stream_frame_t frame;\n    quicly_stream_t *stream;\n    int ret;\n\n    if ((ret = quicly_decode_reset_stream_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n    QUICLY_PROBE(RESET_STREAM_RECEIVE, conn, conn->stash.now, frame.stream_id, frame.app_error_code, frame.final_size);\n    QUICLY_LOG_CONN(reset_stream_receive, conn, {\n        PTLS_LOG_ELEMENT_SIGNED(stream_id, (quicly_stream_id_t)frame.stream_id);\n        PTLS_LOG_ELEMENT_UNSIGNED(app_error_code, frame.app_error_code);\n        PTLS_LOG_ELEMENT_UNSIGNED(final_size, frame.final_size);\n    });\n\n    if ((ret = quicly_get_or_open_stream(conn, frame.stream_id, &stream)) != 0 || stream == NULL)\n        return ret;\n\n    if (!quicly_recvstate_transfer_complete(&stream->recvstate)) {\n        uint64_t bytes_missing;\n        if ((ret = quicly_recvstate_reset(&stream->recvstate, frame.final_size, &bytes_missing)) != 0)\n            return ret;\n        stream->conn->ingress.max_data.bytes_consumed += bytes_missing;\n        int err = QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE(frame.app_error_code);\n        QUICLY_PROBE(STREAM_ON_RECEIVE_RESET, stream->conn, stream->conn->stash.now, stream, err);\n        QUICLY_LOG_CONN(stream_on_receive_reset, stream->conn, {\n            PTLS_LOG_ELEMENT_SIGNED(stream_id, stream->stream_id);\n            PTLS_LOG_ELEMENT_SIGNED(err, err);\n        });\n        stream->callbacks->on_receive_reset(stream, err);\n        if (stream->conn->super.state >= QUICLY_STATE_CLOSING)\n            return QUICLY_ERROR_IS_CLOSING;\n        if (stream_is_destroyable(stream))\n            destroy_stream(stream, 0);\n    }\n\n    return 0;\n}\n\nstatic int handle_ack_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_ack_frame_t frame;\n    quicly_sentmap_iter_t iter;\n    struct {\n        uint64_t pn;\n        int64_t sent_at;\n    } largest_newly_acked = {UINT64_MAX, INT64_MAX};\n    size_t bytes_acked = 0;\n    int includes_ack_eliciting = 0, includes_late_ack = 0, ret;\n\n    if ((ret = quicly_decode_ack_frame(&state->src, state->end, &frame, state->frame_type == QUICLY_FRAME_TYPE_ACK_ECN)) != 0)\n        return ret;\n\n    uint64_t pn_acked = frame.smallest_acknowledged;\n\n    switch (state->epoch) {\n    case QUICLY_EPOCH_0RTT:\n        return QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;\n    case QUICLY_EPOCH_HANDSHAKE:\n        conn->super.remote.address_validation.send_probe = 0;\n        break;\n    default:\n        break;\n    }\n\n    if ((ret = init_acks_iter(conn, &iter)) != 0)\n        return ret;\n\n    /* TODO log PNs being ACKed too late */\n\n    size_t gap_index = frame.num_gaps;\n    while (1) {\n        assert(frame.ack_block_lengths[gap_index] != 0);\n        /* Ack blocks are organized in the ACK frame and consequently in the ack_block_lengths array from the largest acked down.\n         * Processing acks in packet number order requires processing the ack blocks in reverse order. */\n        uint64_t pn_block_max = pn_acked + frame.ack_block_lengths[gap_index] - 1;\n        QUICLY_PROBE(ACK_BLOCK_RECEIVED, conn, conn->stash.now, pn_acked, pn_block_max);\n        QUICLY_LOG_CONN(ack_block_received, conn, {\n            PTLS_LOG_ELEMENT_UNSIGNED(ack_block_begin, pn_acked);\n            PTLS_LOG_ELEMENT_UNSIGNED(ack_block_end, pn_block_max);\n        });\n        while (quicly_sentmap_get(&iter)->packet_number < pn_acked)\n            quicly_sentmap_skip(&iter);\n        do {\n            const quicly_sent_packet_t *sent = quicly_sentmap_get(&iter);\n            uint64_t pn_sent = sent->packet_number;\n            assert(pn_acked <= pn_sent);\n            if (pn_acked < pn_sent) {\n                /* set pn_acked to pn_sent; or past the end of the ack block, for use with the next ack block */\n                if (pn_sent <= pn_block_max) {\n                    pn_acked = pn_sent;\n                } else {\n                    pn_acked = pn_block_max + 1;\n                    break;\n                }\n            }\n            /* process newly acked packet */\n            if (state->epoch != sent->ack_epoch)\n                return QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;\n            int is_late_ack = 0;\n            if (sent->ack_eliciting) {\n                includes_ack_eliciting = 1;\n                if (sent->cc_bytes_in_flight == 0) {\n                    is_late_ack = 1;\n                    includes_late_ack = 1;\n                    ++conn->super.stats.num_packets.late_acked;\n                }\n            }\n            ++conn->super.stats.num_packets.ack_received;\n            largest_newly_acked.pn = pn_acked;\n            largest_newly_acked.sent_at = sent->sent_at;\n            QUICLY_PROBE(PACKET_ACKED, conn, conn->stash.now, pn_acked, is_late_ack);\n            QUICLY_LOG_CONN(packet_acked, conn, {\n                PTLS_LOG_ELEMENT_UNSIGNED(pn, pn_acked);\n                PTLS_LOG_ELEMENT_BOOL(is_late_ack, is_late_ack);\n            });\n            if (sent->cc_bytes_in_flight != 0) {\n                bytes_acked += sent->cc_bytes_in_flight;\n                conn->super.stats.num_bytes.ack_received += sent->cc_bytes_in_flight;\n            }\n            if ((ret = quicly_sentmap_update(&conn->egress.loss.sentmap, &iter, QUICLY_SENTMAP_EVENT_ACKED)) != 0)\n                return ret;\n            if (state->epoch == QUICLY_EPOCH_1RTT) {\n                struct st_quicly_application_space_t *space = conn->application;\n                if (space->cipher.egress.key_update_pn.last <= pn_acked) {\n                    space->cipher.egress.key_update_pn.last = UINT64_MAX;\n                    space->cipher.egress.key_update_pn.next = conn->egress.packet_number + conn->super.ctx->max_packets_per_key;\n                    QUICLY_PROBE(CRYPTO_SEND_KEY_UPDATE_CONFIRMED, conn, conn->stash.now, space->cipher.egress.key_update_pn.next);\n                    QUICLY_LOG_CONN(crypto_send_key_update_confirmed, conn,\n                                    { PTLS_LOG_ELEMENT_UNSIGNED(next_pn, space->cipher.egress.key_update_pn.next); });\n                }\n            }\n            ++pn_acked;\n        } while (pn_acked <= pn_block_max);\n        assert(pn_acked == pn_block_max + 1);\n        if (gap_index-- == 0)\n            break;\n        pn_acked += frame.gaps[gap_index];\n    }\n\n    if ((ret = on_ack_stream_ack_cached(conn)) != 0)\n        return ret;\n\n    QUICLY_PROBE(ACK_DELAY_RECEIVED, conn, conn->stash.now, frame.ack_delay);\n    QUICLY_LOG_CONN(ack_delay_received, conn, { PTLS_LOG_ELEMENT_UNSIGNED(ack_delay, frame.ack_delay); });\n\n    quicly_ratemeter_on_ack(&conn->egress.ratemeter, conn->stash.now, conn->super.stats.num_bytes.ack_received,\n                            largest_newly_acked.pn);\n\n    /* Update loss detection engine on ack. The function uses ack_delay only when the largest_newly_acked is also the largest acked\n     * so far. So, it does not matter if the ack_delay being passed in does not apply to the largest_newly_acked. */\n    quicly_loss_on_ack_received(&conn->egress.loss, largest_newly_acked.pn, state->epoch, conn->stash.now,\n                                largest_newly_acked.sent_at, frame.ack_delay,\n                                includes_ack_eliciting ? includes_late_ack ? QUICLY_LOSS_ACK_RECEIVED_KIND_ACK_ELICITING_LATE_ACK\n                                                                           : QUICLY_LOSS_ACK_RECEIVED_KIND_ACK_ELICITING\n                                                       : QUICLY_LOSS_ACK_RECEIVED_KIND_NON_ACK_ELICITING);\n\n    /* OnPacketAcked and OnPacketAckedCC */\n    if (bytes_acked > 0) {\n        conn->egress.cc.type->cc_on_acked(&conn->egress.cc, &conn->egress.loss, (uint32_t)bytes_acked, frame.largest_acknowledged,\n                                          (uint32_t)(conn->egress.loss.sentmap.bytes_in_flight + bytes_acked),\n                                          conn->egress.packet_number, conn->stash.now, conn->egress.max_udp_payload_size);\n        QUICLY_PROBE(QUICTRACE_CC_ACK, conn, conn->stash.now, &conn->egress.loss.rtt, conn->egress.cc.cwnd,\n                     conn->egress.loss.sentmap.bytes_in_flight);\n    }\n\n    QUICLY_PROBE(CC_ACK_RECEIVED, conn, conn->stash.now, frame.largest_acknowledged, bytes_acked, conn->egress.cc.cwnd,\n                 conn->egress.loss.sentmap.bytes_in_flight);\n    QUICLY_LOG_CONN(cc_ack_received, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(largest_acked, frame.largest_acknowledged);\n        PTLS_LOG_ELEMENT_UNSIGNED(bytes_acked, bytes_acked);\n        PTLS_LOG_ELEMENT_UNSIGNED(cwnd, conn->egress.cc.cwnd);\n        PTLS_LOG_ELEMENT_UNSIGNED(inflight, conn->egress.loss.sentmap.bytes_in_flight);\n    });\n\n    /* loss-detection  */\n    if ((ret = quicly_loss_detect_loss(&conn->egress.loss, conn->stash.now, conn->super.remote.transport_params.max_ack_delay,\n                                       conn->initial == NULL && conn->handshake == NULL, on_loss_detected)) != 0)\n        return ret;\n\n    /* ECN */\n    if (conn->egress.ecn.state != QUICLY_ECN_OFF && largest_newly_acked.pn != UINT64_MAX) {\n        /* if things look suspicious (ECT(1) count becoming non-zero), turn ECN off */\n        if (frame.ecn_counts[1] != 0)\n            update_ecn_state(conn, QUICLY_ECN_OFF);\n        /* TODO: maybe compare num_packets.acked vs. sum(ecn_counts) to see if any packet has been received as NON-ECT? */\n\n        /* ECN validation succeeds if at least one packet is acked using one of the expected marks during the probing period */\n        if (conn->egress.ecn.state == QUICLY_ECN_PROBING && frame.ecn_counts[0] + frame.ecn_counts[2] > 0)\n            update_ecn_state(conn, QUICLY_ECN_ON);\n\n        /* check if congestion should be reported */\n        int report_congestion =\n            conn->egress.ecn.state != QUICLY_ECN_OFF && frame.ecn_counts[2] > conn->egress.ecn.counts[state->epoch][2];\n\n        /* update counters */\n        for (size_t i = 0; i < PTLS_ELEMENTSOF(frame.ecn_counts); ++i) {\n            if (frame.ecn_counts[i] > conn->egress.ecn.counts[state->epoch][i]) {\n                conn->super.stats.num_packets.acked_ecn_counts[i] += frame.ecn_counts[i] - conn->egress.ecn.counts[state->epoch][i];\n                conn->egress.ecn.counts[state->epoch][i] = frame.ecn_counts[i];\n            }\n        }\n\n        /* report congestion */\n        if (report_congestion) {\n            QUICLY_PROBE(ECN_CONGESTION, conn, conn->stash.now, conn->super.stats.num_packets.acked_ecn_counts[2]);\n            QUICLY_LOG_CONN(ecn_congestion, conn,\n                            { PTLS_LOG_ELEMENT_UNSIGNED(ce_count, conn->super.stats.num_packets.acked_ecn_counts[2]); });\n            notify_congestion_to_cc(conn, 0, largest_newly_acked.pn);\n        }\n    }\n\n    setup_next_send(conn);\n\n    return 0;\n}\n\nstatic int handle_max_stream_data_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_max_stream_data_frame_t frame;\n    quicly_stream_t *stream;\n    int ret;\n\n    if ((ret = quicly_decode_max_stream_data_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n\n    QUICLY_PROBE(MAX_STREAM_DATA_RECEIVE, conn, conn->stash.now, frame.stream_id, frame.max_stream_data);\n    QUICLY_LOG_CONN(max_stream_data_receive, conn, {\n        PTLS_LOG_ELEMENT_SIGNED(stream_id, (quicly_stream_id_t)frame.stream_id);\n        PTLS_LOG_ELEMENT_UNSIGNED(max_stream_data, frame.max_stream_data);\n    });\n\n    if (!quicly_stream_has_send_side(quicly_is_client(conn), frame.stream_id))\n        return QUICLY_TRANSPORT_ERROR_FRAME_ENCODING;\n\n    if ((stream = quicly_get_stream(conn, frame.stream_id)) == NULL)\n        return 0;\n\n    if (frame.max_stream_data <= stream->_send_aux.max_stream_data)\n        return 0;\n    stream->_send_aux.max_stream_data = frame.max_stream_data;\n    stream->_send_aux.blocked = QUICLY_SENDER_STATE_NONE;\n\n    if (stream->_send_aux.reset_stream.sender_state == QUICLY_SENDER_STATE_NONE)\n        resched_stream_data(stream);\n\n    return 0;\n}\n\nstatic int handle_data_blocked_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_data_blocked_frame_t frame;\n    int ret;\n\n    if ((ret = quicly_decode_data_blocked_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n\n    QUICLY_PROBE(DATA_BLOCKED_RECEIVE, conn, conn->stash.now, frame.offset);\n    QUICLY_LOG_CONN(data_blocked_receive, conn, { PTLS_LOG_ELEMENT_UNSIGNED(off, frame.offset); });\n\n    quicly_maxsender_request_transmit(&conn->ingress.max_data.sender);\n    if (should_send_max_data(conn))\n        conn->egress.pending_flows |= QUICLY_PENDING_FLOW_OTHERS_BIT;\n\n    return 0;\n}\n\nstatic int handle_stream_data_blocked_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_stream_data_blocked_frame_t frame;\n    quicly_stream_t *stream;\n    int ret;\n\n    if ((ret = quicly_decode_stream_data_blocked_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n\n    QUICLY_PROBE(STREAM_DATA_BLOCKED_RECEIVE, conn, conn->stash.now, frame.stream_id, frame.offset);\n    QUICLY_LOG_CONN(stream_data_blocked_receive, conn, {\n        PTLS_LOG_ELEMENT_SIGNED(stream_id, frame.stream_id);\n        PTLS_LOG_ELEMENT_UNSIGNED(maximum, frame.offset);\n    });\n\n    if (!quicly_stream_has_receive_side(quicly_is_client(conn), frame.stream_id))\n        return QUICLY_TRANSPORT_ERROR_FRAME_ENCODING;\n\n    if ((stream = quicly_get_stream(conn, frame.stream_id)) != NULL) {\n        quicly_maxsender_request_transmit(&stream->_send_aux.max_stream_data_sender);\n        if (should_send_max_stream_data(stream))\n            sched_stream_control(stream);\n    }\n\n    return 0;\n}\n\nstatic int handle_streams_blocked_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_streams_blocked_frame_t frame;\n    int uni = state->frame_type == QUICLY_FRAME_TYPE_STREAMS_BLOCKED_UNI, ret;\n\n    if ((ret = quicly_decode_streams_blocked_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n\n    QUICLY_PROBE(STREAMS_BLOCKED_RECEIVE, conn, conn->stash.now, frame.count, uni);\n    QUICLY_LOG_CONN(streams_blocked_receive, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(maximum, frame.count);\n        PTLS_LOG_ELEMENT_BOOL(is_unidirectional, uni);\n    });\n\n    if (should_send_max_streams(conn, uni)) {\n        quicly_maxsender_t *maxsender = uni ? &conn->ingress.max_streams.uni : &conn->ingress.max_streams.bidi;\n        quicly_maxsender_request_transmit(maxsender);\n        conn->egress.pending_flows |= QUICLY_PENDING_FLOW_OTHERS_BIT;\n    }\n\n    return 0;\n}\n\nstatic int handle_max_streams_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state, int uni)\n{\n    quicly_max_streams_frame_t frame;\n    int ret;\n\n    if ((ret = quicly_decode_max_streams_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n\n    QUICLY_PROBE(MAX_STREAMS_RECEIVE, conn, conn->stash.now, frame.count, uni);\n    QUICLY_LOG_CONN(max_streams_receive, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(maximum, frame.count);\n        PTLS_LOG_ELEMENT_BOOL(is_unidirectional, uni);\n    });\n\n    if ((ret = update_max_streams(uni ? &conn->egress.max_streams.uni : &conn->egress.max_streams.bidi, frame.count)) != 0)\n        return ret;\n\n    open_blocked_streams(conn, uni);\n\n    return 0;\n}\n\nstatic int handle_max_streams_bidi_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    return handle_max_streams_frame(conn, state, 0);\n}\n\nstatic int handle_max_streams_uni_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    return handle_max_streams_frame(conn, state, 1);\n}\n\nstatic int handle_path_challenge_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_path_challenge_frame_t frame;\n    int ret;\n\n    if ((ret = quicly_decode_path_challenge_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n\n    /* schedule the emission of PATH_RESPONSE frame */\n    memcpy(conn->egress.path_response.data, frame.data, QUICLY_PATH_CHALLENGE_DATA_LEN);\n    conn->egress.path_response.send_ = 1;\n    conn->egress.pending_flows |= QUICLY_PENDING_FLOW_OTHERS_BIT;\n\n    return 0;\n}\n\nstatic int handle_path_response_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    return QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;\n}\n\nstatic int handle_new_token_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_new_token_frame_t frame;\n    int ret;\n\n    if (!quicly_is_client(conn))\n        return QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;\n    if ((ret = quicly_decode_new_token_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n    QUICLY_PROBE(NEW_TOKEN_RECEIVE, conn, conn->stash.now, frame.token.base, frame.token.len);\n    QUICLY_LOG_CONN(new_token_receive, conn, { PTLS_LOG_ELEMENT_HEXDUMP(token, frame.token.base, frame.token.len); });\n    if (conn->super.ctx->save_resumption_token == NULL)\n        return 0;\n    return conn->super.ctx->save_resumption_token->cb(conn->super.ctx->save_resumption_token, conn, frame.token);\n}\n\nstatic int handle_stop_sending_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_stop_sending_frame_t frame;\n    quicly_stream_t *stream;\n    int ret;\n\n    if ((ret = quicly_decode_stop_sending_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n    QUICLY_PROBE(STOP_SENDING_RECEIVE, conn, conn->stash.now, frame.stream_id, frame.app_error_code);\n    QUICLY_LOG_CONN(stop_sending_receive, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(stream_id, (quicly_stream_id_t)frame.stream_id);\n        PTLS_LOG_ELEMENT_UNSIGNED(error_code, frame.app_error_code);\n    });\n\n    if ((ret = quicly_get_or_open_stream(conn, frame.stream_id, &stream)) != 0 || stream == NULL)\n        return ret;\n\n    if (quicly_sendstate_is_open(&stream->sendstate)) {\n        /* reset the stream, then notify the application */\n        int err = QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE(frame.app_error_code);\n        quicly_reset_stream(stream, err);\n        QUICLY_PROBE(STREAM_ON_SEND_STOP, stream->conn, stream->conn->stash.now, stream, err);\n        QUICLY_LOG_CONN(stream_on_send_stop, stream->conn, {\n            PTLS_LOG_ELEMENT_SIGNED(stream_id, stream->stream_id);\n            PTLS_LOG_ELEMENT_SIGNED(err, err);\n        });\n        stream->callbacks->on_send_stop(stream, err);\n        if (stream->conn->super.state >= QUICLY_STATE_CLOSING)\n            return QUICLY_ERROR_IS_CLOSING;\n    }\n\n    return 0;\n}\n\nstatic int handle_max_data_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_max_data_frame_t frame;\n    int ret;\n\n    if ((ret = quicly_decode_max_data_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n\n    QUICLY_PROBE(MAX_DATA_RECEIVE, conn, conn->stash.now, frame.max_data);\n    QUICLY_LOG_CONN(max_data_receive, conn, { PTLS_LOG_ELEMENT_UNSIGNED(maximum, frame.max_data); });\n\n    if (frame.max_data <= conn->egress.max_data.permitted)\n        return 0;\n    conn->egress.max_data.permitted = frame.max_data;\n    conn->egress.data_blocked = QUICLY_SENDER_STATE_NONE; /* DATA_BLOCKED has not been sent for the new limit */\n\n    return 0;\n}\n\nstatic int negotiate_using_version(quicly_conn_t *conn, uint32_t version)\n{\n    int ret;\n\n    /* set selected version, update transport parameters extension ID */\n    conn->super.version = version;\n    QUICLY_PROBE(VERSION_SWITCH, conn, conn->stash.now, version);\n    QUICLY_LOG_CONN(version_switch, conn, { PTLS_LOG_ELEMENT_UNSIGNED(new_version, version); });\n\n    /* replace initial keys */\n    if ((ret = reinstall_initial_encryption(conn, PTLS_ERROR_LIBRARY)) != 0)\n        return ret;\n\n    /* reschedule all the packets that have been sent for immediate resend */\n    if ((ret = discard_sentmap_by_epoch(conn, ~0u)) != 0)\n        return ret;\n\n    return 0;\n}\n\nstatic int handle_version_negotiation_packet(quicly_conn_t *conn, quicly_decoded_packet_t *packet)\n{\n    const uint8_t *src = packet->octets.base + packet->encrypted_off, *end = packet->octets.base + packet->octets.len;\n    uint32_t selected_version = 0;\n\n    if (src == end || (end - src) % 4 != 0)\n        return QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;\n\n    /* select in the precedence of V1 -> draft29 -> draft27 -> fail */\n    while (src != end) {\n        uint32_t supported_version = quicly_decode32(&src);\n        switch (supported_version) {\n        case QUICLY_PROTOCOL_VERSION_1:\n            selected_version = QUICLY_PROTOCOL_VERSION_1;\n            break;\n        case QUICLY_PROTOCOL_VERSION_DRAFT29:\n            if (selected_version == 0 || selected_version == QUICLY_PROTOCOL_VERSION_DRAFT27)\n                selected_version = QUICLY_PROTOCOL_VERSION_DRAFT29;\n            break;\n        case QUICLY_PROTOCOL_VERSION_DRAFT27:\n            if (selected_version == 0)\n                selected_version = QUICLY_PROTOCOL_VERSION_DRAFT27;\n            break;\n        }\n    }\n    if (selected_version == 0)\n        return handle_close(conn, QUICLY_ERROR_NO_COMPATIBLE_VERSION, UINT64_MAX, ptls_iovec_init(\"\", 0));\n\n    return negotiate_using_version(conn, selected_version);\n}\n\nstatic int compare_socket_address(struct sockaddr *x, struct sockaddr *y)\n{\n#define CMP(a, b)                                                                                                                  \\\n    if (a != b)                                                                                                                    \\\n    return a < b ? -1 : 1\n\n    CMP(x->sa_family, y->sa_family);\n\n    if (x->sa_family == AF_INET) {\n        struct sockaddr_in *xin = (void *)x, *yin = (void *)y;\n        CMP(ntohl(xin->sin_addr.s_addr), ntohl(yin->sin_addr.s_addr));\n        CMP(ntohs(xin->sin_port), ntohs(yin->sin_port));\n    } else if (x->sa_family == AF_INET6) {\n        struct sockaddr_in6 *xin6 = (void *)x, *yin6 = (void *)y;\n        int r = memcmp(xin6->sin6_addr.s6_addr, yin6->sin6_addr.s6_addr, sizeof(xin6->sin6_addr.s6_addr));\n        if (r != 0)\n            return r;\n        CMP(ntohs(xin6->sin6_port), ntohs(yin6->sin6_port));\n        CMP(xin6->sin6_scope_id, yin6->sin6_scope_id);\n    } else if (x->sa_family == AF_UNSPEC) {\n        return 1;\n    } else {\n        assert(!\"unknown sa_family\");\n    }\n\n#undef CMP\n    return 0;\n}\n\nstatic int is_stateless_reset(quicly_conn_t *conn, quicly_decoded_packet_t *decoded)\n{\n    switch (decoded->_is_stateless_reset_cached) {\n    case QUICLY__DECODED_PACKET_CACHED_IS_STATELESS_RESET:\n        return 1;\n    case QUICLY__DECODED_PACKET_CACHED_NOT_STATELESS_RESET:\n        return 0;\n    default:\n        break;\n    }\n\n    if (!conn->super.remote.cid_set.cids[0].is_active)\n        return 0;\n    if (decoded->octets.len < QUICLY_STATELESS_RESET_PACKET_MIN_LEN)\n        return 0;\n    if (memcmp(decoded->octets.base + decoded->octets.len - QUICLY_STATELESS_RESET_TOKEN_LEN,\n               conn->super.remote.cid_set.cids[0].stateless_reset_token, QUICLY_STATELESS_RESET_TOKEN_LEN) != 0)\n        return 0;\n\n    return 1;\n}\n\nint quicly_is_destination(quicly_conn_t *conn, struct sockaddr *dest_addr, struct sockaddr *src_addr,\n                          quicly_decoded_packet_t *decoded)\n{\n    if (QUICLY_PACKET_IS_LONG_HEADER(decoded->octets.base[0])) {\n        /* long header: validate address, then consult the CID */\n        if (compare_socket_address(&conn->super.remote.address.sa, src_addr) != 0)\n            return 0;\n        if (conn->super.local.address.sa.sa_family != AF_UNSPEC &&\n            compare_socket_address(&conn->super.local.address.sa, dest_addr) != 0)\n            return 0;\n        /* server may see the CID generated by the client for Initial and 0-RTT packets */\n        if (!quicly_is_client(conn) && decoded->cid.dest.might_be_client_generated) {\n            const quicly_cid_t *odcid = is_retry(conn) ? &conn->retry_scid : &conn->super.original_dcid;\n            if (quicly_cid_is_equal(odcid, decoded->cid.dest.encrypted))\n                goto Found;\n        }\n    }\n\n    if (conn->super.ctx->cid_encryptor != NULL) {\n        /* Note on multiple CIDs\n         * Multiple CIDs issued by this host are always based on the same 3-tuple (master_id, thread_id, node_id)\n         * and the only difference is path_id. Therefore comparing the 3-tuple is enough to cover all CIDs issued by\n         * this host.\n         */\n        if (conn->super.local.cid_set.plaintext.master_id == decoded->cid.dest.plaintext.master_id &&\n            conn->super.local.cid_set.plaintext.thread_id == decoded->cid.dest.plaintext.thread_id &&\n            conn->super.local.cid_set.plaintext.node_id == decoded->cid.dest.plaintext.node_id)\n            goto Found;\n        if (is_stateless_reset(conn, decoded))\n            goto Found_StatelessReset;\n    } else {\n        if (compare_socket_address(&conn->super.remote.address.sa, src_addr) == 0)\n            goto Found;\n        if (conn->super.local.address.sa.sa_family != AF_UNSPEC &&\n            compare_socket_address(&conn->super.local.address.sa, dest_addr) != 0)\n            return 0;\n    }\n\n    /* not found */\n    return 0;\n\nFound:\n    decoded->_is_stateless_reset_cached = QUICLY__DECODED_PACKET_CACHED_NOT_STATELESS_RESET;\n    return 1;\n\nFound_StatelessReset:\n    decoded->_is_stateless_reset_cached = QUICLY__DECODED_PACKET_CACHED_IS_STATELESS_RESET;\n    return 1;\n}\n\nint handle_close(quicly_conn_t *conn, int err, uint64_t frame_type, ptls_iovec_t reason_phrase)\n{\n    int ret;\n\n    if (conn->super.state >= QUICLY_STATE_CLOSING)\n        return 0;\n\n    /* switch to closing state, notify the app (at this moment the streams are accessible), then destroy the streams */\n    if ((ret = enter_close(conn, 0,\n                           !(err == QUICLY_ERROR_RECEIVED_STATELESS_RESET || err == QUICLY_ERROR_NO_COMPATIBLE_VERSION))) != 0)\n        return ret;\n    if (conn->super.ctx->closed_by_remote != NULL)\n        conn->super.ctx->closed_by_remote->cb(conn->super.ctx->closed_by_remote, conn, err, frame_type,\n                                              (const char *)reason_phrase.base, reason_phrase.len);\n    destroy_all_streams(conn, err, 0);\n\n    return 0;\n}\n\nstatic int handle_transport_close_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_transport_close_frame_t frame;\n    int ret;\n\n    if ((ret = quicly_decode_transport_close_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n\n    QUICLY_PROBE(TRANSPORT_CLOSE_RECEIVE, conn, conn->stash.now, frame.error_code, frame.frame_type,\n                 QUICLY_PROBE_ESCAPE_UNSAFE_STRING(frame.reason_phrase.base, frame.reason_phrase.len));\n    QUICLY_LOG_CONN(transport_close_receive, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(error_code, frame.error_code);\n        PTLS_LOG_ELEMENT_UNSIGNED(frame_type, frame.frame_type);\n        PTLS_LOG_ELEMENT_UNSAFESTR(reason_phrase, (const char *)frame.reason_phrase.base, frame.reason_phrase.len);\n    });\n    return handle_close(conn, QUICLY_ERROR_FROM_TRANSPORT_ERROR_CODE(frame.error_code), frame.frame_type, frame.reason_phrase);\n}\n\nstatic int handle_application_close_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_application_close_frame_t frame;\n    int ret;\n\n    if ((ret = quicly_decode_application_close_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n\n    QUICLY_PROBE(APPLICATION_CLOSE_RECEIVE, conn, conn->stash.now, frame.error_code,\n                 QUICLY_PROBE_ESCAPE_UNSAFE_STRING(frame.reason_phrase.base, frame.reason_phrase.len));\n    QUICLY_LOG_CONN(application_close_receive, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(error_code, frame.error_code);\n        PTLS_LOG_ELEMENT_UNSAFESTR(reason_phrase, (const char *)frame.reason_phrase.base, frame.reason_phrase.len);\n    });\n    return handle_close(conn, QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE(frame.error_code), UINT64_MAX, frame.reason_phrase);\n}\n\nstatic int handle_padding_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    return 0;\n}\n\nstatic int handle_ping_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    QUICLY_PROBE(PING_RECEIVE, conn, conn->stash.now);\n    QUICLY_LOG_CONN(ping_receive, conn, {});\n\n    return 0;\n}\n\nstatic int handle_new_connection_id_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    int ret;\n    quicly_new_connection_id_frame_t frame;\n\n    /* TODO: return error when using zero-length CID */\n\n    if ((ret = quicly_decode_new_connection_id_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n\n    QUICLY_PROBE(NEW_CONNECTION_ID_RECEIVE, conn, conn->stash.now, frame.sequence, frame.retire_prior_to,\n                 QUICLY_PROBE_HEXDUMP(frame.cid.base, frame.cid.len),\n                 QUICLY_PROBE_HEXDUMP(frame.stateless_reset_token, QUICLY_STATELESS_RESET_TOKEN_LEN));\n    QUICLY_LOG_CONN(new_connection_id_receive, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(sequence, frame.sequence);\n        PTLS_LOG_ELEMENT_UNSIGNED(retire_prior_to, frame.retire_prior_to);\n        PTLS_LOG_ELEMENT_HEXDUMP(cid, frame.cid.base, frame.cid.len);\n        PTLS_LOG_ELEMENT_HEXDUMP(stateless_reset_token, frame.stateless_reset_token, QUICLY_STATELESS_RESET_TOKEN_LEN);\n    });\n\n    if (frame.sequence < conn->super.remote.largest_retire_prior_to) {\n        /* An endpoint that receives a NEW_CONNECTION_ID frame with a sequence number smaller than the Retire Prior To\n         * field of a previously received NEW_CONNECTION_ID frame MUST send a corresponding RETIRE_CONNECTION_ID frame\n         * that retires the newly received connection ID, unless it has already done so for that sequence number. (19.15)\n         * TODO: \"unless ...\" part may not be properly addressed here (we may already have sent the RCID frame for this\n         * sequence) */\n        schedule_retire_connection_id_frame(conn, frame.sequence);\n        /* do not install this CID */\n        return 0;\n    }\n\n    uint64_t unregistered_seqs[QUICLY_LOCAL_ACTIVE_CONNECTION_ID_LIMIT];\n    size_t num_unregistered_seqs;\n    if ((ret = quicly_remote_cid_register(&conn->super.remote.cid_set, frame.sequence, frame.cid.base, frame.cid.len,\n                                          frame.stateless_reset_token, frame.retire_prior_to, unregistered_seqs,\n                                          &num_unregistered_seqs)) != 0)\n        return ret;\n\n    for (size_t i = 0; i < num_unregistered_seqs; i++)\n        schedule_retire_connection_id_frame(conn, unregistered_seqs[i]);\n\n    if (frame.retire_prior_to > conn->super.remote.largest_retire_prior_to)\n        conn->super.remote.largest_retire_prior_to = frame.retire_prior_to;\n\n    return 0;\n}\n\nstatic int handle_retire_connection_id_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    int ret, has_pending;\n    quicly_retire_connection_id_frame_t frame;\n\n    if ((ret = quicly_decode_retire_connection_id_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n\n    QUICLY_PROBE(RETIRE_CONNECTION_ID_RECEIVE, conn, conn->stash.now, frame.sequence);\n    QUICLY_LOG_CONN(retire_connection_id_receive, conn, { PTLS_LOG_ELEMENT_UNSIGNED(sequence, frame.sequence); });\n\n    if (frame.sequence >= conn->super.local.cid_set.plaintext.path_id) {\n        /* Receipt of a RETIRE_CONNECTION_ID frame containing a sequence number greater than any previously sent to the remote peer\n         * MUST be treated as a connection error of type PROTOCOL_VIOLATION. (19.16) */\n        return QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;\n    }\n\n    if ((ret = quicly_local_cid_retire(&conn->super.local.cid_set, frame.sequence, &has_pending)) != 0)\n        return ret;\n    if (has_pending)\n        conn->egress.pending_flows |= QUICLY_PENDING_FLOW_OTHERS_BIT;\n\n    return 0;\n}\n\nstatic int handle_handshake_done_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    int ret;\n\n    QUICLY_PROBE(HANDSHAKE_DONE_RECEIVE, conn, conn->stash.now);\n    QUICLY_LOG_CONN(handshake_done_receive, conn, {});\n\n    if (!quicly_is_client(conn))\n        return QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;\n\n    assert(conn->initial == NULL);\n    if (conn->handshake == NULL)\n        return 0;\n\n    conn->super.remote.address_validation.send_probe = 0;\n    if ((ret = discard_handshake_context(conn, QUICLY_EPOCH_HANDSHAKE)) != 0)\n        return ret;\n    setup_next_send(conn);\n    return 0;\n}\n\nstatic int handle_datagram_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_datagram_frame_t frame;\n    int ret;\n\n    /* check if we advertised support for DATAGRAM frames on this connection */\n    if (conn->super.ctx->transport_params.max_datagram_frame_size == 0)\n        return QUICLY_TRANSPORT_ERROR_FRAME_ENCODING;\n\n    /* decode the frame */\n    if ((ret = quicly_decode_datagram_frame(state->frame_type, &state->src, state->end, &frame)) != 0)\n        return ret;\n    QUICLY_PROBE(DATAGRAM_RECEIVE, conn, conn->stash.now, frame.payload.base, frame.payload.len);\n    QUICLY_LOG_CONN(datagram_receive, conn, { PTLS_LOG_ELEMENT_UNSIGNED(payload_len, frame.payload.len); });\n\n    /* handle the frame. Applications might call quicly_close or other functions that modify the connection state. */\n    conn->super.ctx->receive_datagram_frame->cb(conn->super.ctx->receive_datagram_frame, conn, frame.payload);\n\n    return 0;\n}\n\nstatic int handle_ack_frequency_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)\n{\n    quicly_ack_frequency_frame_t frame;\n    int ret;\n\n    /* recognize the frame only when the support has been advertised */\n    if (conn->super.ctx->transport_params.min_ack_delay_usec == UINT64_MAX)\n        return QUICLY_TRANSPORT_ERROR_FRAME_ENCODING;\n\n    if ((ret = quicly_decode_ack_frequency_frame(&state->src, state->end, &frame)) != 0)\n        return ret;\n\n    QUICLY_PROBE(ACK_FREQUENCY_RECEIVE, conn, conn->stash.now, frame.sequence, frame.packet_tolerance, frame.max_ack_delay,\n                 (int)frame.ignore_order, (int)frame.ignore_ce);\n    QUICLY_LOG_CONN(ack_frequency_receive, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(sequence, frame.sequence);\n        PTLS_LOG_ELEMENT_UNSIGNED(packet_tolerance, frame.packet_tolerance);\n        PTLS_LOG_ELEMENT_UNSIGNED(max_ack_delay, frame.max_ack_delay);\n        PTLS_LOG_ELEMENT_SIGNED(ignore_order, (int)frame.ignore_order);\n        PTLS_LOG_ELEMENT_SIGNED(ignore_ce, (int)frame.ignore_ce);\n    });\n\n    /* Reject Request Max Ack Delay below our TP.min_ack_delay (which is at the moment equal to LOCAL_MAX_ACK_DELAY). */\n    if (frame.max_ack_delay < QUICLY_LOCAL_MAX_ACK_DELAY * 1000)\n        return QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;\n\n    if (frame.sequence >= conn->ingress.ack_frequency.next_sequence) {\n        conn->ingress.ack_frequency.next_sequence = frame.sequence + 1;\n        conn->application->super.packet_tolerance =\n            (uint32_t)(frame.packet_tolerance < QUICLY_MAX_PACKET_TOLERANCE ? frame.packet_tolerance : QUICLY_MAX_PACKET_TOLERANCE);\n        conn->application->super.ignore_order = frame.ignore_order;\n    }\n\n    return 0;\n}\n\nstatic int handle_payload(quicly_conn_t *conn, size_t epoch, const uint8_t *_src, size_t _len, uint64_t *offending_frame_type,\n                          int *is_ack_only)\n{\n    /* clang-format off */\n\n    /* `frame_handlers` is an array of frame handlers and the properties of the frames, indexed by the ID of the frame. */\n    static const struct st_quicly_frame_handler_t {\n        int (*cb)(quicly_conn_t *, struct st_quicly_handle_payload_state_t *); /* callback function that handles the frame */\n        uint8_t permitted_epochs;  /* the epochs the frame can appear, calculated as bitwise-or of `1 << epoch` */\n        uint8_t ack_eliciting;     /* boolean indicating if the frame is ack-eliciting */\n        size_t counter_offset;     /* offset of corresponding `conn->super.stats.num_frames_received.type` within quicly_conn_t */\n    } frame_handlers[] = {\n#define FRAME(n, i, z, h, o, ae)                                                                                                   \\\n    {                                                                                                                              \\\n        handle_##n##_frame,                                                                                                        \\\n        (i << QUICLY_EPOCH_INITIAL) | (z << QUICLY_EPOCH_0RTT) | (h << QUICLY_EPOCH_HANDSHAKE) | (o << QUICLY_EPOCH_1RTT),         \\\n        ae,                                                                                                                        \\\n        offsetof(quicly_conn_t, super.stats.num_frames_received.n)                                                                 \\\n    }\n        /*   +----------------------+-------------------+---------------+\n         *   |                      |  permitted epochs |               |\n         *   |        frame         +----+----+----+----+ ack-eliciting |\n         *   |                      | IN | 0R | HS | 1R |               |\n         *   +----------------------+----+----+----+----+---------------+ */\n        FRAME( padding              ,  1 ,  1 ,  1 ,  1 ,             0 ), /* 0 */\n        FRAME( ping                 ,  1 ,  1 ,  1 ,  1 ,             1 ),\n        FRAME( ack                  ,  1 ,  0 ,  1 ,  1 ,             0 ),\n        FRAME( ack                  ,  1 ,  0 ,  1 ,  1 ,             0 ),\n        FRAME( reset_stream         ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( stop_sending         ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( crypto               ,  1 ,  0 ,  1 ,  1 ,             1 ),\n        FRAME( new_token            ,  0 ,  0 ,  0 ,  1 ,             1 ),\n        FRAME( stream               ,  0 ,  1 ,  0 ,  1 ,             1 ), /* 8 */\n        FRAME( stream               ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( stream               ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( stream               ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( stream               ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( stream               ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( stream               ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( stream               ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( max_data             ,  0 ,  1 ,  0 ,  1 ,             1 ), /* 16 */\n        FRAME( max_stream_data      ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( max_streams_bidi     ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( max_streams_uni      ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( data_blocked         ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( stream_data_blocked  ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( streams_blocked      ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( streams_blocked      ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( new_connection_id    ,  0 ,  1 ,  0 ,  1 ,             1 ), /* 24 */\n        FRAME( retire_connection_id ,  0 ,  0 ,  0 ,  1 ,             1 ),\n        FRAME( path_challenge       ,  0 ,  1 ,  0 ,  1 ,             1 ),\n        FRAME( path_response        ,  0 ,  0 ,  0 ,  1 ,             1 ),\n        FRAME( transport_close      ,  1 ,  1 ,  1 ,  1 ,             0 ),\n        FRAME( application_close    ,  0 ,  1 ,  0 ,  1 ,             0 ),\n        FRAME( handshake_done       ,  0,   0 ,  0 ,  1 ,             1 ),\n        /*   +----------------------+----+----+----+----+---------------+ */\n#undef FRAME\n    };\n    static const struct {\n        uint64_t type;\n        struct st_quicly_frame_handler_t _;\n    } ex_frame_handlers[] = {\n#define FRAME(uc, lc, i, z, h, o, ae)                                                                                              \\\n    {                                                                                                                              \\\n        QUICLY_FRAME_TYPE_##uc,                                                                                                    \\\n        {                                                                                                                          \\\n            handle_##lc##_frame,                                                                                                   \\\n            (i << QUICLY_EPOCH_INITIAL) | (z << QUICLY_EPOCH_0RTT) | (h << QUICLY_EPOCH_HANDSHAKE) | (o << QUICLY_EPOCH_1RTT),     \\\n            ae,                                                                                                                    \\\n            offsetof(quicly_conn_t, super.stats.num_frames_received.lc) \\\n        },                                                                                                                         \\\n    }\n        /*   +----------------------------------+-------------------+---------------+\n         *   |               frame              |  permitted epochs |               |\n         *   |------------------+---------------+----+----+----+----+ ack-eliciting |\n         *   |    upper-case    |  lower-case   | IN | 0R | HS | 1R |               |\n         *   +------------------+---------------+----+----+----+----+---------------+ */\n        FRAME( DATAGRAM_NOLEN   , datagram      ,  0 ,  1,   0,   1 ,             1 ),\n        FRAME( DATAGRAM_WITHLEN , datagram      ,  0 ,  1,   0,   1 ,             1 ),\n        FRAME( ACK_FREQUENCY    , ack_frequency ,  0 ,  0 ,  0 ,  1 ,             1 ),\n        /*   +------------------+---------------+-------------------+---------------+ */\n#undef FRAME\n        {UINT64_MAX},\n    };\n    /* clang-format on */\n\n    struct st_quicly_handle_payload_state_t state = {_src, _src + _len, epoch};\n    size_t num_frames_ack_eliciting = 0;\n    int ret;\n\n    do {\n        /* determine the frame type; fast path is available for frame types below 64 */\n        const struct st_quicly_frame_handler_t *frame_handler;\n        state.frame_type = *state.src++;\n        if (state.frame_type < PTLS_ELEMENTSOF(frame_handlers)) {\n            frame_handler = frame_handlers + state.frame_type;\n        } else {\n            /* slow path */\n            --state.src;\n            if ((state.frame_type = quicly_decodev(&state.src, state.end)) == UINT64_MAX) {\n                state.frame_type =\n                    QUICLY_FRAME_TYPE_PADDING; /* we cannot signal the offending frame type when failing to decode the frame type */\n                ret = QUICLY_TRANSPORT_ERROR_FRAME_ENCODING;\n                break;\n            }\n            size_t i;\n            for (i = 0; ex_frame_handlers[i].type < state.frame_type; ++i)\n                ;\n            if (ex_frame_handlers[i].type != state.frame_type) {\n                ret = QUICLY_TRANSPORT_ERROR_FRAME_ENCODING; /* not found */\n                break;\n            }\n            frame_handler = &ex_frame_handlers[i]._;\n        }\n        /* check if frame is allowed, then process */\n        if ((frame_handler->permitted_epochs & (1 << epoch)) == 0) {\n            ret = QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;\n            break;\n        }\n        ++*(uint64_t *)((uint8_t *)conn + frame_handler->counter_offset);\n        num_frames_ack_eliciting += frame_handler->ack_eliciting;\n        if ((ret = frame_handler->cb(conn, &state)) != 0)\n            break;\n    } while (state.src != state.end);\n\n    *is_ack_only = num_frames_ack_eliciting == 0;\n    if (ret != 0)\n        *offending_frame_type = state.frame_type;\n    return ret;\n}\n\nstatic int handle_stateless_reset(quicly_conn_t *conn)\n{\n    QUICLY_PROBE(STATELESS_RESET_RECEIVE, conn, conn->stash.now);\n    QUICLY_LOG_CONN(stateless_reset_receive, conn, {});\n    return handle_close(conn, QUICLY_ERROR_RECEIVED_STATELESS_RESET, UINT64_MAX, ptls_iovec_init(\"\", 0));\n}\n\nstatic int validate_retry_tag(quicly_decoded_packet_t *packet, quicly_cid_t *odcid, ptls_aead_context_t *retry_aead)\n{\n    size_t pseudo_packet_len = 1 + odcid->len + packet->encrypted_off;\n    uint8_t pseudo_packet[pseudo_packet_len];\n    pseudo_packet[0] = odcid->len;\n    memcpy(pseudo_packet + 1, odcid->cid, odcid->len);\n    memcpy(pseudo_packet + 1 + odcid->len, packet->octets.base, packet->encrypted_off);\n    return ptls_aead_decrypt(retry_aead, packet->octets.base + packet->encrypted_off, packet->octets.base + packet->encrypted_off,\n                             PTLS_AESGCM_TAG_SIZE, 0, pseudo_packet, pseudo_packet_len) == 0;\n}\n\nint quicly_accept(quicly_conn_t **conn, quicly_context_t *ctx, struct sockaddr *dest_addr, struct sockaddr *src_addr,\n                  quicly_decoded_packet_t *packet, quicly_address_token_plaintext_t *address_token,\n                  const quicly_cid_plaintext_t *new_cid, ptls_handshake_properties_t *handshake_properties, void *appdata)\n{\n    const struct st_ptls_salt_t *salt;\n    struct {\n        struct st_quicly_cipher_context_t ingress, egress;\n        int alive;\n    } cipher = {};\n    ptls_iovec_t payload;\n    uint64_t next_expected_pn, pn, offending_frame_type = QUICLY_FRAME_TYPE_PADDING;\n    int is_ack_only, ret;\n\n    *conn = NULL;\n\n    /* process initials only */\n    if ((packet->octets.base[0] & QUICLY_PACKET_TYPE_BITMASK) != QUICLY_PACKET_TYPE_INITIAL) {\n        ret = QUICLY_ERROR_PACKET_IGNORED;\n        goto Exit;\n    }\n    if ((salt = get_salt(packet->version)) == NULL) {\n        ret = QUICLY_ERROR_PACKET_IGNORED;\n        goto Exit;\n    }\n    if (packet->datagram_size < QUICLY_MIN_CLIENT_INITIAL_SIZE) {\n        ret = QUICLY_ERROR_PACKET_IGNORED;\n        goto Exit;\n    }\n    if (packet->cid.dest.encrypted.len < 8) {\n        ret = QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;\n        goto Exit;\n    }\n    if ((ret = setup_initial_encryption(get_aes128gcmsha256(ctx), &cipher.ingress, &cipher.egress, packet->cid.dest.encrypted, 0,\n                                        ptls_iovec_init(salt->initial, sizeof(salt->initial)), NULL)) != 0)\n        goto Exit;\n    cipher.alive = 1;\n    next_expected_pn = 0; /* is this correct? do we need to take care of underflow? */\n    if ((ret = decrypt_packet(cipher.ingress.header_protection, aead_decrypt_fixed_key, cipher.ingress.aead, &next_expected_pn,\n                              packet, &pn, &payload)) != 0) {\n        ret = QUICLY_ERROR_DECRYPTION_FAILED;\n        goto Exit;\n    }\n\n    /* create connection */\n    if ((*conn = create_connection(\n             ctx, packet->version, NULL, src_addr, dest_addr, &packet->cid.src, new_cid, handshake_properties, appdata,\n             quicly_cc_calc_initial_cwnd(ctx->initcwnd_packets, ctx->transport_params.max_udp_payload_size))) == NULL) {\n        ret = PTLS_ERROR_NO_MEMORY;\n        goto Exit;\n    }\n    (*conn)->super.state = QUICLY_STATE_ACCEPTING;\n    quicly_set_cid(&(*conn)->super.original_dcid, packet->cid.dest.encrypted);\n    if (address_token != NULL) {\n        (*conn)->super.remote.address_validation.validated = 1;\n        if (address_token->type == QUICLY_ADDRESS_TOKEN_TYPE_RETRY) {\n            (*conn)->retry_scid = (*conn)->super.original_dcid;\n            (*conn)->super.original_dcid = address_token->retry.original_dcid;\n        }\n    }\n    if ((ret = setup_handshake_space_and_flow(*conn, QUICLY_EPOCH_INITIAL)) != 0)\n        goto Exit;\n    (*conn)->initial->super.next_expected_packet_number = next_expected_pn;\n    (*conn)->initial->cipher.ingress = cipher.ingress;\n    (*conn)->initial->cipher.egress = cipher.egress;\n    cipher.alive = 0;\n    (*conn)->crypto.handshake_properties.collected_extensions = server_collected_extensions;\n    (*conn)->initial->largest_ingress_udp_payload_size = packet->datagram_size;\n\n    QUICLY_PROBE(ACCEPT, *conn, (*conn)->stash.now,\n                 QUICLY_PROBE_HEXDUMP(packet->cid.dest.encrypted.base, packet->cid.dest.encrypted.len), address_token);\n    QUICLY_LOG_CONN(accept, *conn, {\n        PTLS_LOG_ELEMENT_HEXDUMP(dcid, packet->cid.dest.encrypted.base, packet->cid.dest.encrypted.len);\n        PTLS_LOG_ELEMENT_PTR(address_token, address_token);\n    });\n    QUICLY_PROBE(PACKET_RECEIVED, *conn, (*conn)->stash.now, pn, payload.base, payload.len, get_epoch(packet->octets.base[0]));\n    QUICLY_LOG_CONN(packet_received, *conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(pn, pn);\n        PTLS_LOG_APPDATA_ELEMENT_HEXDUMP(decrypted, payload.base, payload.len);\n        PTLS_LOG_ELEMENT_UNSIGNED(packet_type, get_epoch(packet->octets.base[0]));\n    });\n\n    /* handle the input; we ignore is_ack_only, we consult if there's any output from TLS in response to CH anyways */\n    (*conn)->super.stats.num_packets.received += 1;\n    if (packet->ecn != 0)\n        (*conn)->super.stats.num_packets.received_ecn_counts[get_ecn_index_from_bits(packet->ecn)] += 1;\n    (*conn)->super.stats.num_bytes.received += packet->datagram_size;\n    if ((ret = handle_payload(*conn, QUICLY_EPOCH_INITIAL, payload.base, payload.len, &offending_frame_type, &is_ack_only)) != 0)\n        goto Exit;\n    if ((ret = record_receipt(&(*conn)->initial->super, pn, packet->ecn, 0, (*conn)->stash.now, &(*conn)->egress.send_ack_at,\n                              &(*conn)->super.stats.num_packets.received_out_of_order)) != 0)\n        goto Exit;\n\nExit:\n    if (*conn != NULL) {\n        if (ret == 0) {\n            (*conn)->super.state = QUICLY_STATE_CONNECTED;\n        } else {\n            initiate_close(*conn, ret, offending_frame_type, \"\");\n            ret = 0;\n        }\n        unlock_now(*conn);\n    }\n    if (cipher.alive) {\n        dispose_cipher(&cipher.ingress);\n        dispose_cipher(&cipher.egress);\n    }\n    return ret;\n}\n\nint quicly_receive(quicly_conn_t *conn, struct sockaddr *dest_addr, struct sockaddr *src_addr, quicly_decoded_packet_t *packet)\n{\n    ptls_cipher_context_t *header_protection;\n    struct {\n        int (*cb)(void *, uint64_t, quicly_decoded_packet_t *, size_t, size_t *);\n        void *ctx;\n    } aead;\n    struct st_quicly_pn_space_t **space;\n    size_t epoch;\n    ptls_iovec_t payload;\n    uint64_t pn, offending_frame_type = QUICLY_FRAME_TYPE_PADDING;\n    int is_ack_only, ret;\n\n    assert(src_addr->sa_family == AF_INET || src_addr->sa_family == AF_INET6);\n\n    lock_now(conn, 0);\n\n    QUICLY_PROBE(RECEIVE, conn, conn->stash.now,\n                 QUICLY_PROBE_HEXDUMP(packet->cid.dest.encrypted.base, packet->cid.dest.encrypted.len), packet->octets.base,\n                 packet->octets.len);\n    QUICLY_LOG_CONN(receive, conn, {\n        PTLS_LOG_ELEMENT_HEXDUMP(dcid, packet->cid.dest.encrypted.base, packet->cid.dest.encrypted.len);\n        PTLS_LOG_ELEMENT_HEXDUMP(bytes, packet->octets.base, packet->octets.len);\n    });\n\n    if (is_stateless_reset(conn, packet)) {\n        ret = handle_stateless_reset(conn);\n        goto Exit;\n    }\n\n    /* FIXME check peer address */\n\n    /* add unconditionally, as packet->datagram_size is set only for the first packet within the UDP datagram */\n    conn->super.stats.num_bytes.received += packet->datagram_size;\n\n    switch (conn->super.state) {\n    case QUICLY_STATE_CLOSING:\n        ++conn->egress.connection_close.num_packets_received;\n        /* respond with a CONNECTION_CLOSE frame using exponential back-off */\n        if (__builtin_popcountl(conn->egress.connection_close.num_packets_received) == 1)\n            conn->egress.send_ack_at = 0;\n        ret = 0;\n        goto Exit;\n    case QUICLY_STATE_DRAINING:\n        ret = 0;\n        goto Exit;\n    default:\n        break;\n    }\n\n    if (QUICLY_PACKET_IS_LONG_HEADER(packet->octets.base[0])) {\n        if (conn->super.state == QUICLY_STATE_FIRSTFLIGHT) {\n            if (packet->version == 0) {\n                ret = handle_version_negotiation_packet(conn, packet);\n                goto Exit;\n            }\n        }\n        if (packet->version != conn->super.version) {\n            ret = QUICLY_ERROR_PACKET_IGNORED;\n            goto Exit;\n        }\n        switch (packet->octets.base[0] & QUICLY_PACKET_TYPE_BITMASK) {\n        case QUICLY_PACKET_TYPE_RETRY: {\n            assert(packet->encrypted_off + PTLS_AESGCM_TAG_SIZE == packet->octets.len);\n            /* handle only if the connection is the client */\n            if (!quicly_is_client(conn)) {\n                ret = QUICLY_ERROR_PACKET_IGNORED;\n                goto Exit;\n            }\n            /* server CID has to change */\n            if (quicly_cid_is_equal(&conn->super.remote.cid_set.cids[0].cid, packet->cid.src)) {\n                ret = QUICLY_ERROR_PACKET_IGNORED;\n                goto Exit;\n            }\n            /* do not accept a second Retry */\n            if (is_retry(conn)) {\n                ret = QUICLY_ERROR_PACKET_IGNORED;\n                goto Exit;\n            }\n            ptls_aead_context_t *retry_aead = create_retry_aead(conn->super.ctx, conn->super.version, 0);\n            int retry_ok = validate_retry_tag(packet, &conn->super.remote.cid_set.cids[0].cid, retry_aead);\n            ptls_aead_free(retry_aead);\n            if (!retry_ok) {\n                ret = QUICLY_ERROR_PACKET_IGNORED;\n                goto Exit;\n            }\n            /* check size of the Retry packet */\n            if (packet->token.len > QUICLY_MAX_TOKEN_LEN) {\n                ret = QUICLY_ERROR_PACKET_IGNORED; /* TODO this is a immediate fatal error, chose a better error code */\n                goto Exit;\n            }\n            /* store token and ODCID */\n            free(conn->token.base);\n            if ((conn->token.base = malloc(packet->token.len)) == NULL) {\n                ret = PTLS_ERROR_NO_MEMORY;\n                goto Exit;\n            }\n            memcpy(conn->token.base, packet->token.base, packet->token.len);\n            conn->token.len = packet->token.len;\n            /* update DCID */\n            quicly_set_cid(&conn->super.remote.cid_set.cids[0].cid, packet->cid.src);\n            conn->retry_scid = conn->super.remote.cid_set.cids[0].cid;\n            /* replace initial keys, or drop the keys if this is a response packet to a greased version */\n            if ((ret = reinstall_initial_encryption(conn, QUICLY_ERROR_PACKET_IGNORED)) != 0)\n                goto Exit;\n            /* schedule retransmit */\n            ret = discard_sentmap_by_epoch(conn, ~0u);\n            goto Exit;\n        } break;\n        case QUICLY_PACKET_TYPE_INITIAL:\n            if (conn->initial == NULL || (header_protection = conn->initial->cipher.ingress.header_protection) == NULL) {\n                ret = QUICLY_ERROR_PACKET_IGNORED;\n                goto Exit;\n            }\n            if (quicly_is_client(conn)) {\n                /* client: update cid if this is the first Initial packet that's being received */\n                if (conn->super.state == QUICLY_STATE_FIRSTFLIGHT)\n                    quicly_set_cid(&conn->super.remote.cid_set.cids[0].cid, packet->cid.src);\n            } else {\n                /* server: ignore packets that are too small */\n                if (packet->datagram_size < QUICLY_MIN_CLIENT_INITIAL_SIZE) {\n                    ret = QUICLY_ERROR_PACKET_IGNORED;\n                    goto Exit;\n                }\n            }\n            aead.cb = aead_decrypt_fixed_key;\n            aead.ctx = conn->initial->cipher.ingress.aead;\n            space = (void *)&conn->initial;\n            epoch = QUICLY_EPOCH_INITIAL;\n            break;\n        case QUICLY_PACKET_TYPE_HANDSHAKE:\n            if (conn->handshake == NULL || (header_protection = conn->handshake->cipher.ingress.header_protection) == NULL) {\n                ret = QUICLY_ERROR_PACKET_IGNORED;\n                goto Exit;\n            }\n            aead.cb = aead_decrypt_fixed_key;\n            aead.ctx = conn->handshake->cipher.ingress.aead;\n            space = (void *)&conn->handshake;\n            epoch = QUICLY_EPOCH_HANDSHAKE;\n            break;\n        case QUICLY_PACKET_TYPE_0RTT:\n            if (quicly_is_client(conn)) {\n                ret = QUICLY_ERROR_PACKET_IGNORED;\n                goto Exit;\n            }\n            if (conn->application == NULL ||\n                (header_protection = conn->application->cipher.ingress.header_protection.zero_rtt) == NULL) {\n                ret = QUICLY_ERROR_PACKET_IGNORED;\n                goto Exit;\n            }\n            aead.cb = aead_decrypt_fixed_key;\n            aead.ctx = conn->application->cipher.ingress.aead[1];\n            space = (void *)&conn->application;\n            epoch = QUICLY_EPOCH_0RTT;\n            break;\n        default:\n            ret = QUICLY_ERROR_PACKET_IGNORED;\n            goto Exit;\n        }\n    } else {\n        /* short header packet */\n        if (conn->application == NULL ||\n            (header_protection = conn->application->cipher.ingress.header_protection.one_rtt) == NULL) {\n            ret = QUICLY_ERROR_PACKET_IGNORED;\n            goto Exit;\n        }\n        aead.cb = aead_decrypt_1rtt;\n        aead.ctx = conn;\n        space = (void *)&conn->application;\n        epoch = QUICLY_EPOCH_1RTT;\n    }\n\n    /* decrypt */\n    if ((ret = decrypt_packet(header_protection, aead.cb, aead.ctx, &(*space)->next_expected_packet_number, packet, &pn,\n                              &payload)) != 0) {\n        ++conn->super.stats.num_packets.decryption_failed;\n        QUICLY_PROBE(PACKET_DECRYPTION_FAILED, conn, conn->stash.now, pn);\n        goto Exit;\n    }\n\n    QUICLY_PROBE(PACKET_RECEIVED, conn, conn->stash.now, pn, payload.base, payload.len, get_epoch(packet->octets.base[0]));\n    QUICLY_LOG_CONN(packet_received, conn, {\n        PTLS_LOG_ELEMENT_UNSIGNED(pn, pn);\n        PTLS_LOG_ELEMENT_UNSIGNED(decrypted_len, payload.len);\n        PTLS_LOG_ELEMENT_UNSIGNED(packet_type, get_epoch(packet->octets.base[0]));\n    });\n\n    /* update states */\n    if (conn->super.state == QUICLY_STATE_FIRSTFLIGHT)\n        conn->super.state = QUICLY_STATE_CONNECTED;\n    conn->super.stats.num_packets.received += 1;\n    if (packet->ecn != 0)\n        conn->super.stats.num_packets.received_ecn_counts[get_ecn_index_from_bits(packet->ecn)] += 1;\n\n    /* state updates, that are triggered by the receipt of a packet */\n    switch (epoch) {\n    case QUICLY_EPOCH_INITIAL:\n        /* update max_ingress_udp_payload_size if necessary */\n        if (conn->initial->largest_ingress_udp_payload_size < packet->datagram_size)\n            conn->initial->largest_ingress_udp_payload_size = packet->datagram_size;\n        break;\n    case QUICLY_EPOCH_HANDSHAKE:\n        /* Discard Initial space before processing the payload of the Handshake packet to avoid the chance of an ACK frame included\n         * in the Handshake packet setting a loss timer for the Initial packet. */\n        if (conn->initial != NULL) {\n            if ((ret = discard_handshake_context(conn, QUICLY_EPOCH_INITIAL)) != 0)\n                goto Exit;\n            setup_next_send(conn);\n            conn->super.remote.address_validation.validated = 1;\n        }\n        break;\n    default:\n        break;\n    }\n\n    /* handle the payload */\n    if ((ret = handle_payload(conn, epoch, payload.base, payload.len, &offending_frame_type, &is_ack_only)) != 0)\n        goto Exit;\n    if (*space != NULL && conn->super.state < QUICLY_STATE_CLOSING) {\n        if ((ret = record_receipt(*space, pn, packet->ecn, is_ack_only, conn->stash.now, &conn->egress.send_ack_at,\n                                  &conn->super.stats.num_packets.received_out_of_order)) != 0)\n            goto Exit;\n    }\n\n    /* state updates post payload processing */\n    switch (epoch) {\n    case QUICLY_EPOCH_INITIAL:\n        assert(conn->initial != NULL);\n        if (quicly_is_client(conn) && conn->handshake != NULL && conn->handshake->cipher.egress.aead != NULL) {\n            if ((ret = discard_handshake_context(conn, QUICLY_EPOCH_INITIAL)) != 0)\n                goto Exit;\n            setup_next_send(conn);\n        }\n        break;\n    case QUICLY_EPOCH_HANDSHAKE:\n        if (quicly_is_client(conn)) {\n            /* Running as a client.\n             * Respect \"disable_migration\" TP sent by the remote peer at the end of the TLS handshake. */\n            if (conn->super.local.address.sa.sa_family == AF_UNSPEC && dest_addr != NULL && dest_addr->sa_family != AF_UNSPEC &&\n                ptls_handshake_is_complete(conn->crypto.tls) && conn->super.remote.transport_params.disable_active_migration)\n                set_address(&conn->super.local.address, dest_addr);\n        } else {\n            /* Running as a server.\n             * If handshake was just completed, drop handshake context, schedule the first emission of HANDSHAKE_DONE frame. */\n            if (ptls_handshake_is_complete(conn->crypto.tls)) {\n                if ((ret = discard_handshake_context(conn, QUICLY_EPOCH_HANDSHAKE)) != 0)\n                    goto Exit;\n                assert(conn->handshake == NULL);\n                conn->egress.pending_flows |= QUICLY_PENDING_FLOW_HANDSHAKE_DONE_BIT;\n                setup_next_send(conn);\n            }\n        }\n        break;\n    case QUICLY_EPOCH_1RTT:\n        if (!is_ack_only && should_send_max_data(conn))\n            conn->egress.pending_flows |= QUICLY_PENDING_FLOW_OTHERS_BIT;\n        break;\n    default:\n        break;\n    }\n\n    update_idle_timeout(conn, 1);\n\nExit:\n    switch (ret) {\n    case 0:\n        /* Avoid time in the past being emitted by quicly_get_first_timeout. We hit the condition below when retransmission is\n         * suspended by the 3x limit (in which case we have loss.alarm_at set but return INT64_MAX from quicly_get_first_timeout\n         * until we receive something from the client).\n         */\n        if (conn->egress.loss.alarm_at < conn->stash.now)\n            conn->egress.loss.alarm_at = conn->stash.now;\n        assert_consistency(conn, 0);\n        break;\n    case PTLS_ERROR_NO_MEMORY:\n    case QUICLY_ERROR_STATE_EXHAUSTION:\n    case QUICLY_ERROR_PACKET_IGNORED:\n        break;\n    default: /* close connection */\n        initiate_close(conn, ret, offending_frame_type, \"\");\n        ret = 0;\n        break;\n    }\n    unlock_now(conn);\n    return ret;\n}\n\nint quicly_open_stream(quicly_conn_t *conn, quicly_stream_t **_stream, int uni)\n{\n    quicly_stream_t *stream;\n    struct st_quicly_conn_streamgroup_state_t *group;\n    uint64_t *max_stream_count;\n    uint32_t max_stream_data_local;\n    uint64_t max_stream_data_remote;\n    int ret;\n\n    /* determine the states */\n    if (uni) {\n        group = &conn->super.local.uni;\n        max_stream_count = &conn->egress.max_streams.uni.count;\n        max_stream_data_local = 0;\n        max_stream_data_remote = conn->super.remote.transport_params.max_stream_data.uni;\n    } else {\n        group = &conn->super.local.bidi;\n        max_stream_count = &conn->egress.max_streams.bidi.count;\n        max_stream_data_local = (uint32_t)conn->super.ctx->transport_params.max_stream_data.bidi_local;\n        max_stream_data_remote = conn->super.remote.transport_params.max_stream_data.bidi_remote;\n    }\n\n    /* open */\n    if ((stream = open_stream(conn, group->next_stream_id, max_stream_data_local, max_stream_data_remote)) == NULL)\n        return PTLS_ERROR_NO_MEMORY;\n    ++group->num_streams;\n    group->next_stream_id += 4;\n\n    /* adjust blocked */\n    if (stream->stream_id / 4 >= *max_stream_count) {\n        stream->streams_blocked = 1;\n        quicly_linklist_insert((uni ? &conn->egress.pending_streams.blocked.uni : &conn->egress.pending_streams.blocked.bidi)->prev,\n                               &stream->_send_aux.pending_link.control);\n        conn->egress.pending_flows |= QUICLY_PENDING_FLOW_OTHERS_BIT;\n    }\n\n    /* application-layer initialization */\n    QUICLY_PROBE(STREAM_ON_OPEN, conn, conn->stash.now, stream);\n    QUICLY_LOG_CONN(stream_on_open, conn, {});\n\n    if ((ret = conn->super.ctx->stream_open->cb(conn->super.ctx->stream_open, stream)) != 0)\n        return ret;\n\n    *_stream = stream;\n    return 0;\n}\n\nvoid quicly_reset_stream(quicly_stream_t *stream, int err)\n{\n    assert(quicly_stream_has_send_side(quicly_is_client(stream->conn), stream->stream_id));\n    assert(QUICLY_ERROR_IS_QUIC_APPLICATION(err));\n    assert(stream->_send_aux.reset_stream.sender_state == QUICLY_SENDER_STATE_NONE);\n    assert(!quicly_sendstate_transfer_complete(&stream->sendstate));\n\n    /* dispose sendbuf state */\n    quicly_sendstate_reset(&stream->sendstate);\n\n    /* setup RESET_STREAM */\n    stream->_send_aux.reset_stream.sender_state = QUICLY_SENDER_STATE_SEND;\n    stream->_send_aux.reset_stream.error_code = QUICLY_ERROR_GET_ERROR_CODE(err);\n\n    /* schedule for delivery */\n    sched_stream_control(stream);\n    resched_stream_data(stream);\n}\n\nvoid quicly_request_stop(quicly_stream_t *stream, int err)\n{\n    assert(quicly_stream_has_receive_side(quicly_is_client(stream->conn), stream->stream_id));\n    assert(QUICLY_ERROR_IS_QUIC_APPLICATION(err));\n\n    /* send STOP_SENDING if the incoming side of the stream is still open */\n    if (stream->recvstate.eos == UINT64_MAX && stream->_send_aux.stop_sending.sender_state == QUICLY_SENDER_STATE_NONE) {\n        stream->_send_aux.stop_sending.sender_state = QUICLY_SENDER_STATE_SEND;\n        stream->_send_aux.stop_sending.error_code = QUICLY_ERROR_GET_ERROR_CODE(err);\n        sched_stream_control(stream);\n    }\n}\n\nsocklen_t quicly_get_socklen(struct sockaddr *sa)\n{\n    switch (sa->sa_family) {\n    case AF_INET:\n        return sizeof(struct sockaddr_in);\n    case AF_INET6:\n        return sizeof(struct sockaddr_in6);\n    default:\n        assert(!\"unexpected socket type\");\n        return 0;\n    }\n}\n\nchar *quicly_escape_unsafe_string(char *buf, const void *bytes, size_t len)\n{\n    char *dst = buf;\n    const char *src = bytes, *end = src + len;\n\n    for (; src != end; ++src) {\n        if ((0x20 <= *src && *src <= 0x7e) && !(*src == '\"' || *src == '\\'' || *src == '\\\\')) {\n            *dst++ = *src;\n        } else {\n            *dst++ = '\\\\';\n            *dst++ = 'x';\n            quicly_byte_to_hex(dst, (uint8_t)*src);\n            dst += 2;\n        }\n    }\n    *dst = '\\0';\n\n    return buf;\n}\n\nchar *quicly_hexdump(const uint8_t *bytes, size_t len, size_t indent)\n{\n    size_t i, line, row, bufsize = indent == SIZE_MAX ? len * 2 + 1 : (indent + 5 + 3 * 16 + 2 + 16 + 1) * ((len + 15) / 16) + 1;\n    char *buf, *p;\n\n    if ((buf = malloc(bufsize)) == NULL)\n        return NULL;\n    p = buf;\n    if (indent == SIZE_MAX) {\n        for (i = 0; i != len; ++i) {\n            quicly_byte_to_hex(p, bytes[i]);\n            p += 2;\n        }\n    } else {\n        for (line = 0; line * 16 < len; ++line) {\n            for (i = 0; i < indent; ++i)\n                *p++ = ' ';\n            quicly_byte_to_hex(p, (line >> 4) & 0xff);\n            p += 2;\n            quicly_byte_to_hex(p, (line << 4) & 0xff);\n            p += 2;\n            *p++ = ' ';\n            for (row = 0; row < 16; ++row) {\n                *p++ = row == 8 ? '-' : ' ';\n                if (line * 16 + row < len) {\n                    quicly_byte_to_hex(p, bytes[line * 16 + row]);\n                    p += 2;\n                } else {\n                    *p++ = ' ';\n                    *p++ = ' ';\n                }\n            }\n            *p++ = ' ';\n            *p++ = ' ';\n            for (row = 0; row < 16; ++row) {\n                if (line * 16 + row < len) {\n                    int ch = bytes[line * 16 + row];\n                    *p++ = 0x20 <= ch && ch < 0x7f ? ch : '.';\n                } else {\n                    *p++ = ' ';\n                }\n            }\n            *p++ = '\\n';\n        }\n    }\n    *p++ = '\\0';\n\n    assert(p - buf <= bufsize);\n\n    return buf;\n}\n\nvoid quicly_amend_ptls_context(ptls_context_t *ptls)\n{\n    static ptls_update_traffic_key_t update_traffic_key = {update_traffic_key_cb};\n\n    ptls->omit_end_of_early_data = 1;\n    ptls->update_traffic_key = &update_traffic_key;\n\n    /* if TLS 1.3 config permits use of early data, convert the value to 0xffffffff in accordance with QUIC-TLS */\n    if (ptls->max_early_data_size != 0)\n        ptls->max_early_data_size = UINT32_MAX;\n}\n\nint quicly_encrypt_address_token(void (*random_bytes)(void *, size_t), ptls_aead_context_t *aead, ptls_buffer_t *buf,\n                                 size_t start_off, const quicly_address_token_plaintext_t *plaintext)\n{\n    int ret;\n\n    /* type and IV */\n    if ((ret = ptls_buffer_reserve(buf, 1 + aead->algo->iv_size)) != 0)\n        goto Exit;\n    buf->base[buf->off++] = plaintext->type;\n    random_bytes(buf->base + buf->off, aead->algo->iv_size);\n    buf->off += aead->algo->iv_size;\n\n    size_t enc_start = buf->off;\n\n    /* data */\n    ptls_buffer_push64(buf, plaintext->issued_at);\n    {\n        uint16_t port;\n        ptls_buffer_push_block(buf, 1, {\n            switch (plaintext->remote.sa.sa_family) {\n            case AF_INET:\n                ptls_buffer_pushv(buf, &plaintext->remote.sin.sin_addr.s_addr, 4);\n                port = ntohs(plaintext->remote.sin.sin_port);\n                break;\n            case AF_INET6:\n                ptls_buffer_pushv(buf, &plaintext->remote.sin6.sin6_addr, 16);\n                ptls_buffer_push32(buf, plaintext->remote.sin6.sin6_scope_id);\n                port = ntohs(plaintext->remote.sin6.sin6_port);\n                break;\n            default:\n                assert(!\"unsupported address type\");\n                break;\n            }\n        });\n        ptls_buffer_push16(buf, port);\n    }\n    switch (plaintext->type) {\n    case QUICLY_ADDRESS_TOKEN_TYPE_RETRY:\n        ptls_buffer_push_block(buf, 1,\n                               { ptls_buffer_pushv(buf, plaintext->retry.original_dcid.cid, plaintext->retry.original_dcid.len); });\n        ptls_buffer_push_block(buf, 1,\n                               { ptls_buffer_pushv(buf, plaintext->retry.client_cid.cid, plaintext->retry.client_cid.len); });\n        ptls_buffer_push_block(buf, 1,\n                               { ptls_buffer_pushv(buf, plaintext->retry.server_cid.cid, plaintext->retry.server_cid.len); });\n        break;\n    case QUICLY_ADDRESS_TOKEN_TYPE_RESUMPTION:\n        ptls_buffer_push_block(buf, 1, { ptls_buffer_pushv(buf, plaintext->resumption.bytes, plaintext->resumption.len); });\n        break;\n    default:\n        assert(!\"unexpected token type\");\n        abort();\n    }\n    ptls_buffer_push_block(buf, 1, { ptls_buffer_pushv(buf, plaintext->appdata.bytes, plaintext->appdata.len); });\n\n    /* encrypt, supplying full IV */\n    if ((ret = ptls_buffer_reserve(buf, aead->algo->tag_size)) != 0)\n        goto Exit;\n    ptls_aead_set_iv(aead, buf->base + enc_start - aead->algo->iv_size);\n    ptls_aead_encrypt(aead, buf->base + enc_start, buf->base + enc_start, buf->off - enc_start, 0, buf->base + start_off,\n                      enc_start - start_off);\n    buf->off += aead->algo->tag_size;\n\nExit:\n    return ret;\n}\n\nint quicly_decrypt_address_token(ptls_aead_context_t *aead, quicly_address_token_plaintext_t *plaintext, const void *_token,\n                                 size_t len, size_t prefix_len, const char **err_desc)\n{\n    const uint8_t *const token = _token;\n    uint8_t ptbuf[QUICLY_MIN_CLIENT_INITIAL_SIZE];\n    size_t ptlen;\n\n    *err_desc = NULL;\n\n    /* check if we can get type and decrypt */\n    if (len < prefix_len + 1 + aead->algo->iv_size + aead->algo->tag_size) {\n        *err_desc = \"token too small\";\n        return PTLS_ALERT_DECODE_ERROR;\n    }\n    if (prefix_len + 1 + aead->algo->iv_size + sizeof(ptbuf) + aead->algo->tag_size < len) {\n        *err_desc = \"token too large\";\n        return PTLS_ALERT_DECODE_ERROR;\n    }\n\n    /* check type */\n    switch (token[prefix_len]) {\n    case QUICLY_ADDRESS_TOKEN_TYPE_RETRY:\n        plaintext->type = QUICLY_ADDRESS_TOKEN_TYPE_RETRY;\n        break;\n    case QUICLY_ADDRESS_TOKEN_TYPE_RESUMPTION:\n        plaintext->type = QUICLY_ADDRESS_TOKEN_TYPE_RESUMPTION;\n        break;\n    default:\n        *err_desc = \"unknown token type\";\n        return PTLS_ALERT_DECODE_ERROR;\n    }\n\n    /* `goto Exit` can only happen below this line, and that is guaranteed by declaring `ret` here */\n    int ret;\n\n    /* decrypt */\n    ptls_aead_set_iv(aead, token + prefix_len + 1);\n    if ((ptlen = ptls_aead_decrypt(aead, ptbuf, token + prefix_len + 1 + aead->algo->iv_size,\n                                   len - (prefix_len + 1 + aead->algo->iv_size), 0, token, prefix_len + 1 + aead->algo->iv_size)) ==\n        SIZE_MAX) {\n        ret = PTLS_ALERT_DECRYPT_ERROR;\n        *err_desc = \"token decryption failure\";\n        goto Exit;\n    }\n\n    /* parse */\n    const uint8_t *src = ptbuf, *end = src + ptlen;\n    if ((ret = ptls_decode64(&plaintext->issued_at, &src, end)) != 0)\n        goto Exit;\n    {\n        in_port_t *portaddr;\n        ptls_decode_open_block(src, end, 1, {\n            switch (end - src) {\n            case 4: /* ipv4 */\n                plaintext->remote.sin.sin_family = AF_INET;\n                memcpy(&plaintext->remote.sin.sin_addr.s_addr, src, 4);\n                portaddr = &plaintext->remote.sin.sin_port;\n                break;\n            case 20: /* ipv6 */\n                plaintext->remote.sin6 = (struct sockaddr_in6){.sin6_family = AF_INET6};\n                memcpy(&plaintext->remote.sin6.sin6_addr, src, 16);\n                if ((ret = ptls_decode32(&plaintext->remote.sin6.sin6_scope_id, &src, end)) != 0)\n                    goto Exit;\n                portaddr = &plaintext->remote.sin6.sin6_port;\n                break;\n            default:\n                ret = PTLS_ALERT_DECODE_ERROR;\n                goto Exit;\n            }\n            src = end;\n        });\n        uint16_t port;\n        if ((ret = ptls_decode16(&port, &src, end)) != 0)\n            goto Exit;\n        *portaddr = htons(port);\n    }\n    switch (plaintext->type) {\n    case QUICLY_ADDRESS_TOKEN_TYPE_RETRY:\n#define DECODE_CID(field)                                                                                                          \\\n    do {                                                                                                                           \\\n        ptls_decode_open_block(src, end, 1, {                                                                                      \\\n            if (end - src > sizeof(plaintext->retry.field.cid)) {                                                                  \\\n                ret = PTLS_ALERT_DECODE_ERROR;                                                                                     \\\n                goto Exit;                                                                                                         \\\n            }                                                                                                                      \\\n            quicly_set_cid(&plaintext->retry.field, ptls_iovec_init(src, end - src));                                              \\\n            src = end;                                                                                                             \\\n        });                                                                                                                        \\\n    } while (0)\n        DECODE_CID(original_dcid);\n        DECODE_CID(client_cid);\n        DECODE_CID(server_cid);\n#undef DECODE_CID\n        break;\n    case QUICLY_ADDRESS_TOKEN_TYPE_RESUMPTION:\n        ptls_decode_open_block(src, end, 1, {\n            PTLS_BUILD_ASSERT(sizeof(plaintext->resumption.bytes) >= 256);\n            plaintext->resumption.len = end - src;\n            memcpy(plaintext->resumption.bytes, src, plaintext->resumption.len);\n            src = end;\n        });\n        break;\n    default:\n        assert(!\"unexpected token type\");\n        abort();\n    }\n    ptls_decode_block(src, end, 1, {\n        PTLS_BUILD_ASSERT(sizeof(plaintext->appdata.bytes) >= 256);\n        plaintext->appdata.len = end - src;\n        memcpy(plaintext->appdata.bytes, src, plaintext->appdata.len);\n        src = end;\n    });\n    ret = 0;\n\nExit:\n    if (ret != 0) {\n        if (*err_desc == NULL)\n            *err_desc = \"token decode error\";\n        /* promote the error to one that triggers the emission of INVALID_TOKEN_ERROR, if the token looked like a retry */\n        if (plaintext->type == QUICLY_ADDRESS_TOKEN_TYPE_RETRY)\n            ret = QUICLY_TRANSPORT_ERROR_INVALID_TOKEN;\n    }\n    return ret;\n}\n\nint quicly_build_session_ticket_auth_data(ptls_buffer_t *auth_data, const quicly_context_t *ctx)\n{\n    int ret;\n\n#define PUSH_TP(id, block)                                                                                                         \\\n    do {                                                                                                                           \\\n        ptls_buffer_push_quicint(auth_data, id);                                                                                   \\\n        ptls_buffer_push_block(auth_data, -1, block);                                                                              \\\n    } while (0)\n\n    ptls_buffer_push_block(auth_data, -1, {\n        PUSH_TP(QUICLY_TRANSPORT_PARAMETER_ID_ACTIVE_CONNECTION_ID_LIMIT,\n                { ptls_buffer_push_quicint(auth_data, ctx->transport_params.active_connection_id_limit); });\n        PUSH_TP(QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_DATA,\n                { ptls_buffer_push_quicint(auth_data, ctx->transport_params.max_data); });\n        PUSH_TP(QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_BIDI_LOCAL,\n                { ptls_buffer_push_quicint(auth_data, ctx->transport_params.max_stream_data.bidi_local); });\n        PUSH_TP(QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_BIDI_REMOTE,\n                { ptls_buffer_push_quicint(auth_data, ctx->transport_params.max_stream_data.bidi_remote); });\n        PUSH_TP(QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_UNI,\n                { ptls_buffer_push_quicint(auth_data, ctx->transport_params.max_stream_data.uni); });\n        PUSH_TP(QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAMS_BIDI,\n                { ptls_buffer_push_quicint(auth_data, ctx->transport_params.max_streams_bidi); });\n        PUSH_TP(QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAMS_UNI,\n                { ptls_buffer_push_quicint(auth_data, ctx->transport_params.max_streams_uni); });\n    });\n\n#undef PUSH_TP\n\n    ret = 0;\nExit:\n    return ret;\n}\n\nvoid quicly_stream_noop_on_destroy(quicly_stream_t *stream, int err)\n{\n}\n\nvoid quicly_stream_noop_on_send_shift(quicly_stream_t *stream, size_t delta)\n{\n}\n\nvoid quicly_stream_noop_on_send_emit(quicly_stream_t *stream, size_t off, void *dst, size_t *len, int *wrote_all)\n{\n}\n\nvoid quicly_stream_noop_on_send_stop(quicly_stream_t *stream, int err)\n{\n}\n\nvoid quicly_stream_noop_on_receive(quicly_stream_t *stream, size_t off, const void *src, size_t len)\n{\n}\n\nvoid quicly_stream_noop_on_receive_reset(quicly_stream_t *stream, int err)\n{\n}\n\nconst quicly_stream_callbacks_t quicly_stream_noop_callbacks = {\n    quicly_stream_noop_on_destroy,   quicly_stream_noop_on_send_shift, quicly_stream_noop_on_send_emit,\n    quicly_stream_noop_on_send_stop, quicly_stream_noop_on_receive,    quicly_stream_noop_on_receive_reset};\n\nvoid quicly__debug_printf(quicly_conn_t *conn, const char *function, int line, const char *fmt, ...)\n{\n#if QUICLY_USE_DTRACE\n    char buf[1024];\n    va_list args;\n\n    if (!QUICLY_DEBUG_MESSAGE_ENABLED())\n        return;\n\n    va_start(args, fmt);\n    vsnprintf(buf, sizeof(buf), fmt, args);\n    va_end(args);\n\n    QUICLY_DEBUG_MESSAGE(conn, function, line, buf);\n#endif\n}\n\nconst uint32_t quicly_supported_versions[] = {QUICLY_PROTOCOL_VERSION_1, QUICLY_PROTOCOL_VERSION_DRAFT29,\n                                              QUICLY_PROTOCOL_VERSION_DRAFT27, 0};\n"], "filenames": ["deps/quicly/lib/quicly.c"], "buggy_code_start_loc": [109], "buggy_code_end_loc": [5554], "fixing_code_start_loc": [108], "fixing_code_end_loc": [5536], "type": "CWE-770", "message": "h2o is an HTTP server with support for HTTP/1.x, HTTP/2 and HTTP/3. The QUIC stack (quicly), as used by H2O up to commit 43f86e5 (in version 2.3.0-beta and prior), is susceptible to a state exhaustion attack. When H2O is serving HTTP/3, a remote attacker can exploit this vulnerability to progressively increase the memory retained by the QUIC stack. This can eventually cause H2O to abort due to memory exhaustion. The vulnerability has been resolved in commit d67e81d03be12a9d53dc8271af6530f40164cd35. HTTP/1 and HTTP/2 are not affected by this vulnerability as they do not use QUIC. Administrators looking to mitigate this issue without upgrading can disable HTTP/3 support.", "other": {"cve": {"id": "CVE-2023-50247", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-12T20:15:08.580", "lastModified": "2023-12-19T18:56:13.660", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "h2o is an HTTP server with support for HTTP/1.x, HTTP/2 and HTTP/3. The QUIC stack (quicly), as used by H2O up to commit 43f86e5 (in version 2.3.0-beta and prior), is susceptible to a state exhaustion attack. When H2O is serving HTTP/3, a remote attacker can exploit this vulnerability to progressively increase the memory retained by the QUIC stack. This can eventually cause H2O to abort due to memory exhaustion. The vulnerability has been resolved in commit d67e81d03be12a9d53dc8271af6530f40164cd35. HTTP/1 and HTTP/2 are not affected by this vulnerability as they do not use QUIC. Administrators looking to mitigate this issue without upgrading can disable HTTP/3 support."}, {"lang": "es", "value": "h2o es un servidor HTTP compatible con HTTP/1.x, HTTP/2 y HTTP/3. La pila QUIC (r\u00e1pidamente), tal como la utiliza H2O hasta el commit 43f86e5 (en la versi\u00f3n 2.3.0-beta y anteriores), es susceptible a un ataque de agotamiento de estado. Cuando H2O sirve HTTP/3, un atacante remoto puede aprovechar esta vulnerabilidad para aumentar progresivamente la memoria retenida por la pila QUIC. Esto eventualmente puede causar que H2O cancele debido al agotamiento de la memoria. La vulnerabilidad se resolvi\u00f3 en el commit d67e81d03be12a9d53dc8271af6530f40164cd35. HTTP/1 y HTTP/2 no se ven afectados por esta vulnerabilidad ya que no utilizan QUIC. Los administradores que quieran mitigar este problema sin realizar una actualizaci\u00f3n pueden desactivar la compatibilidad con HTTP/3."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.7, "baseSeverity": "LOW"}, "exploitabilityScore": 2.2, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dena:h2o:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.2.6", "matchCriteriaId": "3C540EDB-1F68-47E9-A457-B6BC1EB805D7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:dena:h2o:2.3.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "128D1D5E-4E71-4ABB-B580-F17E2B74B5F3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:dena:h2o:2.3.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "E69DE676-300A-4A95-A04D-7463CA372799"}]}]}], "references": [{"url": "https://github.com/h2o/h2o/commit/d67e81d03be12a9d53dc8271af6530f40164cd35", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/h2o/h2o/security/advisories/GHSA-2ch5-p59c-7mv6", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/h2o/h2o/commit/d67e81d03be12a9d53dc8271af6530f40164cd35"}}