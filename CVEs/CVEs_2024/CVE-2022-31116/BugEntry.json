{"buggy_code": ["/*\nDeveloped by ESN, an Electronic Arts Inc. studio.\nCopyright (c) 2014, Electronic Arts Inc.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n* Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n* Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in the\ndocumentation and/or other materials provided with the distribution.\n* Neither the name of ESN, Electronic Arts Inc. nor the\nnames of its contributors may be used to endorse or promote products\nderived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL ELECTRONIC ARTS INC. BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\nPortions of code from MODP_ASCII - Ascii transformations (upper/lower, etc)\nhttps://github.com/client9/stringencoders\nCopyright (c) 2007  Nick Galbreath -- nickg [at] modp [dot] com. All rights reserved.\n\nNumeric decoder derived from from TCL library\nhttps://opensource.apple.com/source/tcl/tcl-14/tcl/license.terms\n * Copyright (c) 1988-1993 The Regents of the University of California.\n * Copyright (c) 1994 Sun Microsystems, Inc.\n*/\n\n/*\nUltra fast JSON encoder and decoder\nDeveloped by Jonas Tarnstrom (jonas@esn.me).\n\nEncoder notes:\n------------------\n\n:: Cyclic references ::\nCyclic referenced objects are not detected.\nSet JSONObjectEncoder.recursionMax to suitable value or make sure input object\ntree doesn't have cyclic references.\n\n*/\n\n#ifndef __ULTRAJSON_H__\n#define __ULTRAJSON_H__\n\n#include <stdio.h>\n#include <wchar.h>\n\n// Max decimals to encode double floating point numbers with\n#ifndef JSON_DOUBLE_MAX_DECIMALS\n    #define JSON_DOUBLE_MAX_DECIMALS 15\n#endif\n\n// Max recursion depth, default for encoder\n#ifndef JSON_MAX_RECURSION_DEPTH\n    #define JSON_MAX_RECURSION_DEPTH 1024\n#endif\n\n// Max recursion depth, default for decoder\n#ifndef JSON_MAX_OBJECT_DEPTH\n    #define JSON_MAX_OBJECT_DEPTH 1024\n#endif\n\n/*\nDictates and limits how much stack space for buffers UltraJSON will use before resorting to provided heap functions */\n#ifndef JSON_MAX_STACK_BUFFER_SIZE\n    #define JSON_MAX_STACK_BUFFER_SIZE 1024\n#endif\n\n#ifdef _WIN32\n\n    typedef __int64 JSINT64;\n    typedef unsigned __int64 JSUINT64;\n\n    typedef __int32 JSINT32;\n    typedef unsigned __int32 JSUINT32;\n    typedef unsigned __int8 JSUINT8;\n    typedef unsigned __int16 JSUTF16;\n    typedef unsigned __int32 JSUTF32;\n    typedef __int64 JSLONG;\n\n    #define EXPORTFUNCTION __declspec(dllexport)\n\n    #define FASTCALL_MSVC __fastcall\n    #define FASTCALL_ATTR\n    #define INLINE_PREFIX __inline\n\n#else\n\n    #include <stdint.h>\n    typedef int64_t JSINT64;\n    typedef uint64_t JSUINT64;\n\n    typedef int32_t JSINT32;\n    typedef uint32_t JSUINT32;\n\n    #define FASTCALL_MSVC\n\n    #if !defined __x86_64__\n        #define FASTCALL_ATTR __attribute__((fastcall))\n    #else\n        #define FASTCALL_ATTR\n    #endif\n\n    #define INLINE_PREFIX inline\n\n    typedef uint8_t JSUINT8;\n    typedef uint16_t JSUTF16;\n    typedef uint32_t JSUTF32;\n\n    typedef int64_t JSLONG;\n\n    #define EXPORTFUNCTION\n#endif\n\n#ifdef __GNUC__\n    #define LIKELY(x)       __builtin_expect(!!(x), 1)\n    #define UNLIKELY(x)     __builtin_expect(!!(x), 0)\n#else\n    #define LIKELY(x)       (x)\n    #define UNLIKELY(x)     (x)\n#endif\n\n#if !(defined(__LITTLE_ENDIAN__) || defined(__BIG_ENDIAN__))\n\n    #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n        #define __LITTLE_ENDIAN__\n    #else\n\n    #if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n        #define __BIG_ENDIAN__\n    #endif\n\n#endif\n\n#endif\n\n#if !defined(__LITTLE_ENDIAN__) && !defined(__BIG_ENDIAN__)\n    #error \"Endianness not supported\"\n#endif\n\nenum JSTYPES\n{\n  JT_NULL,      // NULL\n  JT_TRUE,      // boolean true\n  JT_FALSE,     // boolean false\n  JT_INT,       // (JSINT32 (signed 32-bit))\n  JT_LONG,      // (JSINT64 (signed 64-bit))\n  JT_ULONG,     // (JSUINT64 (unsigned 64-bit))\n  JT_DOUBLE,    // (double)\n  JT_UTF8,      // (char 8-bit)\n  JT_RAW,       // (raw char 8-bit)\n  JT_ARRAY,     // Array structure\n  JT_OBJECT,    // Key/Value structure\n  JT_INVALID,   // Internal, do not return nor expect\n  JT_NAN,       // Not A Number\n  JT_POS_INF,   // Positive infinity\n  JT_NEG_INF,   // Negative infinity\n};\n\ntypedef void * JSOBJ;\ntypedef void * JSITER;\n\ntypedef struct __JSONTypeContext\n{\n  int type;\n  void *prv;\n  void *encoder_prv;\n} JSONTypeContext;\n\n/*\nFunction pointer declarations, suitable for implementing UltraJSON */\ntypedef int (*JSPFN_ITERNEXT)(JSOBJ obj, JSONTypeContext *tc);\ntypedef void (*JSPFN_ITEREND)(JSOBJ obj, JSONTypeContext *tc);\ntypedef JSOBJ (*JSPFN_ITERGETVALUE)(JSOBJ obj, JSONTypeContext *tc);\ntypedef char *(*JSPFN_ITERGETNAME)(JSOBJ obj, JSONTypeContext *tc, size_t *outLen);\ntypedef void *(*JSPFN_MALLOC)(size_t size);\ntypedef void (*JSPFN_FREE)(void *pptr);\ntypedef void *(*JSPFN_REALLOC)(void *base, size_t size);\n\n\nstruct __JSONObjectEncoder;\n\ntypedef struct __JSONObjectEncoder\n{\n  void (*beginTypeContext)(JSOBJ obj, JSONTypeContext *tc, struct __JSONObjectEncoder *enc);\n  void (*endTypeContext)(JSOBJ obj, JSONTypeContext *tc);\n  const char *(*getStringValue)(JSOBJ obj, JSONTypeContext *tc, size_t *_outLen);\n  JSINT64 (*getLongValue)(JSOBJ obj, JSONTypeContext *tc);\n  JSUINT64 (*getUnsignedLongValue)(JSOBJ obj, JSONTypeContext *tc);\n  double (*getDoubleValue)(JSOBJ obj, JSONTypeContext *tc);\n\n  /*\n  Retrieve next object in an iteration. Should return 0 to indicate iteration has reached end or 1 if there are more items.\n  Implementor is responsible for keeping state of the iteration. Use ti->prv fields for this\n  */\n  JSPFN_ITERNEXT iterNext;\n\n  /*\n  Ends the iteration of an iteratable object.\n  Any iteration state stored in ti->prv can be freed here\n  */\n  JSPFN_ITEREND iterEnd;\n\n  /*\n  Returns a reference to the value object of an iterator\n  The is responsible for the life-cycle of the returned string. Use iterNext/iterEnd and ti->prv to keep track of current object\n  */\n  JSPFN_ITERGETVALUE iterGetValue;\n\n  /*\n  Return name of iterator.\n  The is responsible for the life-cycle of the returned string. Use iterNext/iterEnd and ti->prv to keep track of current object\n  */\n  JSPFN_ITERGETNAME iterGetName;\n\n  /*\n  Release a value as indicated by setting ti->release = 1 in the previous getValue call.\n  The ti->prv array should contain the necessary context to release the value\n  */\n  void (*releaseObject)(JSOBJ obj);\n\n  /* Library functions\n  Set to NULL to use STDLIB malloc,realloc,free */\n  JSPFN_MALLOC malloc;\n  JSPFN_REALLOC realloc;\n  JSPFN_FREE free;\n\n  /*\n  Configuration for max recursion, set to 0 to use default (see JSON_MAX_RECURSION_DEPTH)*/\n  int recursionMax;\n\n  /*\n  If true output will be ASCII with all characters above 127 encoded as \\uXXXX. If false output will be UTF-8 or what ever charset strings are brought as */\n  int forceASCII;\n\n  /*\n  If true, '<', '>', and '&' characters will be encoded as \\u003c, \\u003e, and \\u0026, respectively. If false, no special encoding will be used. */\n  int encodeHTMLChars;\n\n  /*\n  If true, '/' will be encoded as \\/. If false, no escaping. */\n  int escapeForwardSlashes;\n\n  /*\n  If true, dictionaries are iterated through in sorted key order. */\n  int sortKeys;\n\n  /*\n  Configuration for spaces of indent */\n  int indent;\n\n  /*\n  If true, NaN will be encoded as a string matching the Python standard library's JSON behavior.\n  This is not valid JSON. */\n  int allowNan;\n\n  /*\n  If true, bytes are rejected. */\n  int rejectBytes;\n\n  /*\n  Private pointer to be used by the caller. Passed as encoder_prv in JSONTypeContext */\n  void *prv;\n\n  /*\n  Pointer to the DoubleToStringConverter instance */\n  void *d2s;\n\n  /*\n  Set to an error message if error occured */\n  const char *errorMsg;\n  JSOBJ errorObj;\n\n  /* Buffer stuff */\n  char *start;\n  char *offset;\n  char *end;\n  int heap;\n  int level;\n\n} JSONObjectEncoder;\n\n\n/*\nEncode an object structure into JSON.\n\nArguments:\nobj - An anonymous type representing the object\nenc - Function definitions for querying JSOBJ type\nbuffer - Preallocated buffer to store result in. If NULL function allocates own buffer\ncbBuffer - Length of buffer (ignored if buffer is NULL)\noutLen - Will store the length of the encoded string\n\nReturns:\nEncoded JSON object as a char string.\n\nNOTE:\nIf the supplied buffer wasn't enough to hold the result the function will allocate a new buffer.\nLife cycle of the provided buffer must still be handled by caller.\n\nIf the return value doesn't equal the specified buffer caller must release the memory using\nJSONObjectEncoder.free or free() as specified when calling this function.\n\nIf an error occurs during encoding, NULL is returned and no outLen is stored.\n*/\nEXPORTFUNCTION char *JSON_EncodeObject(JSOBJ obj, JSONObjectEncoder *enc, char *buffer, size_t cbBuffer, size_t *outLen);\n\ntypedef struct __JSONObjectDecoder\n{\n  JSOBJ (*newString)(void *prv, wchar_t *start, wchar_t *end);\n  void (*objectAddKey)(void *prv, JSOBJ obj, JSOBJ name, JSOBJ value);\n  void (*arrayAddItem)(void *prv, JSOBJ obj, JSOBJ value);\n  JSOBJ (*newTrue)(void *prv);\n  JSOBJ (*newFalse)(void *prv);\n  JSOBJ (*newNull)(void *prv);\n  JSOBJ (*newNaN)(void *prv);\n  JSOBJ (*newPosInf)(void *prv);\n  JSOBJ (*newNegInf)(void *prv);\n  JSOBJ (*newObject)(void *prv);\n  JSOBJ (*newArray)(void *prv);\n  JSOBJ (*newInt)(void *prv, JSINT32 value);\n  JSOBJ (*newLong)(void *prv, JSINT64 value);\n  JSOBJ (*newUnsignedLong)(void *prv, JSUINT64 value);\n  JSOBJ (*newIntegerFromString)(void *prv, char *value, size_t length);\n  JSOBJ (*newDouble)(void *prv, double value);\n  void (*releaseObject)(void *prv, JSOBJ obj);\n  JSPFN_MALLOC malloc;\n  JSPFN_FREE free;\n  JSPFN_REALLOC realloc;\n  char *errorStr;\n  char *errorOffset;\n  void *prv;\n  void *s2d;\n} JSONObjectDecoder;\n\nEXPORTFUNCTION JSOBJ JSON_DecodeObject(JSONObjectDecoder *dec, const char *buffer, size_t cbBuffer);\n\n#define DCONV_DECIMAL_IN_SHORTEST_LOW -4\n#define DCONV_DECIMAL_IN_SHORTEST_HIGH 16\n\nenum dconv_d2s_flags {\n  DCONV_D2S_NO_FLAGS = 0,\n  DCONV_D2S_EMIT_POSITIVE_EXPONENT_SIGN = 1,\n  DCONV_D2S_EMIT_TRAILING_DECIMAL_POINT = 2,\n  DCONV_D2S_EMIT_TRAILING_ZERO_AFTER_POINT = 4,\n  DCONV_D2S_UNIQUE_ZERO = 8\n};\n\nenum dconv_s2d_flags\n{\n  DCONV_S2D_NO_FLAGS = 0,\n  DCONV_S2D_ALLOW_HEX = 1,\n  DCONV_S2D_ALLOW_OCTALS = 2,\n  DCONV_S2D_ALLOW_TRAILING_JUNK = 4,\n  DCONV_S2D_ALLOW_LEADING_SPACES = 8,\n  DCONV_S2D_ALLOW_TRAILING_SPACES = 16,\n  DCONV_S2D_ALLOW_SPACES_AFTER_SIGN = 32\n};\n\nvoid dconv_d2s_init(void **d2s,\n                    int flags,\n                    const char* infinity_symbol,\n                    const char* nan_symbol,\n                    char exponent_character,\n                    int decimal_in_shortest_low,\n                    int decimal_in_shortest_high,\n                    int max_leading_padding_zeroes_in_precision_mode,\n                    int max_trailing_padding_zeroes_in_precision_mode);\nint dconv_d2s(void *d2s, double value, char* buf, int buflen, int* strlength);\nvoid dconv_d2s_free(void **d2s);\n\nvoid dconv_s2d_init(void **s2d, int flags, double empty_string_value,\n                    double junk_string_value, const char* infinity_symbol,\n                    const char* nan_symbol);\ndouble dconv_s2d(void *s2d, const char* buffer, int length, int* processed_characters_count);\nvoid dconv_s2d_free(void **s2d);\n\n#endif\n", "/*\nDeveloped by ESN, an Electronic Arts Inc. studio.\nCopyright (c) 2014, Electronic Arts Inc.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n* Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n* Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in the\ndocumentation and/or other materials provided with the distribution.\n* Neither the name of ESN, Electronic Arts Inc. nor the\nnames of its contributors may be used to endorse or promote products\nderived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL ELECTRONIC ARTS INC. BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\nPortions of code from MODP_ASCII - Ascii transformations (upper/lower, etc)\nhttps://github.com/client9/stringencoders\nCopyright (c) 2007  Nick Galbreath -- nickg [at] modp [dot] com. All rights reserved.\n\nNumeric decoder derived from from TCL library\nhttps://opensource.apple.com/source/tcl/tcl-14/tcl/license.terms\n* Copyright (c) 1988-1993 The Regents of the University of California.\n* Copyright (c) 1994 Sun Microsystems, Inc.\n*/\n\n#include \"ultrajson.h\"\n#include <math.h>\n#include <assert.h>\n#include <string.h>\n#include <limits.h>\n#include <wchar.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <stdint.h>\n\n#ifndef TRUE\n#define TRUE 1\n#define FALSE 0\n#endif\n#ifndef NULL\n#define NULL 0\n#endif\n\nstruct DecoderState\n{\n  char *start;\n  char *end;\n  wchar_t *escStart;\n  wchar_t *escEnd;\n  int escHeap;\n  int lastType;\n  JSUINT32 objDepth;\n  void *prv;\n  JSONObjectDecoder *dec;\n};\n\nstatic JSOBJ FASTCALL_MSVC decode_any( struct DecoderState *ds) FASTCALL_ATTR;\ntypedef JSOBJ (*PFN_DECODER)( struct DecoderState *ds);\n\nstatic JSOBJ SetError( struct DecoderState *ds, int offset, const char *message)\n{\n  ds->dec->errorOffset = ds->start + offset;\n  ds->dec->errorStr = (char *) message;\n  return NULL;\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decodeDouble(struct DecoderState *ds)\n{\n  int processed_characters_count;\n  int len = (int)(ds->end - ds->start);\n  double value = dconv_s2d(ds->dec->s2d, ds->start, len, &processed_characters_count);\n  ds->lastType = JT_DOUBLE;\n  ds->start += processed_characters_count;\n  return ds->dec->newDouble(ds->prv, value);\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_numeric (struct DecoderState *ds)\n{\n  int intNeg = 1;\n  int hasError = 0;\n  JSUINT64 intValue;\n  JSUINT64 addIntValue;\n  int chr;\n  char *offset = ds->start;\n\n  JSUINT64 maxIntValue = ULLONG_MAX;\n  JSUINT64 overflowLimit = maxIntValue / 10LLU;\n\n  if (*(offset) == 'I')\n  {\n    goto DECODE_INF;\n  }\n  else if (*(offset) == 'N')\n  {\n    goto DECODE_NAN;\n  }\n  else if (*(offset) == '-')\n  {\n    offset++;\n    intNeg = -1;\n    if (*(offset) == 'I')\n    {\n      goto DECODE_INF;\n    }\n    maxIntValue = -(JSUINT64) LLONG_MIN;\n    overflowLimit = maxIntValue / 10LL;\n  }\n\n  // Scan integer part\n  intValue = 0;\n\n  while (1)\n  {\n    chr = (int) (unsigned char) *(offset);\n\n    switch (chr)\n    {\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      {\n        // check whether multiplication would be out of bounds\n        if (intValue > overflowLimit)\n        {\n          hasError = 1;\n        }\n        intValue *= 10ULL;\n        addIntValue = (JSUINT64) (chr - 48);\n\n        // check whether addition would be out of bounds\n        if (maxIntValue - intValue < addIntValue)\n        {\n          hasError = 1;\n        }\n\n        intValue += addIntValue;\n        offset ++;\n        break;\n      }\n      case '.':\n      {\n        offset ++;\n        return decodeDouble(ds);\n      }\n      case 'e':\n      case 'E':\n      {\n        offset ++;\n        return decodeDouble(ds);\n      }\n\n      default:\n      {\n        if (hasError)\n        {\n          char *strStart = ds->start;\n          ds->lastType = JT_INT;\n          ds->start = offset;\n          return ds->dec->newIntegerFromString(ds->prv, strStart, offset - strStart);\n        }\n        goto BREAK_INT_LOOP;\n        break;\n      }\n    }\n  }\n\nBREAK_INT_LOOP:\n\n  ds->lastType = JT_INT;\n  ds->start = offset;\n\n  if (intNeg == 1 && (intValue & 0x8000000000000000ULL) != 0)\n  {\n    return ds->dec->newUnsignedLong(ds->prv, intValue);\n  }\n  else if ((intValue >> 31))\n  {\n    return ds->dec->newLong(ds->prv, (JSINT64) (intValue * (JSINT64) intNeg));\n  }\n  else\n  {\n    return ds->dec->newInt(ds->prv, (JSINT32) (intValue * intNeg));\n  }\n\nDECODE_NAN:\n    offset++;\n    if (*(offset++) != 'a') goto SET_NAN_ERROR;\n    if (*(offset++) != 'N') goto SET_NAN_ERROR;\n\n    ds->lastType = JT_NAN;\n    ds->start = offset;\n    return ds->dec->newNaN(ds->prv);\n\nSET_NAN_ERROR:\n    return SetError(ds, -1, \"Unexpected character found when decoding 'NaN'\");\n\nDECODE_INF:\n    offset++;\n    if (*(offset++) != 'n') goto SET_INF_ERROR;\n    if (*(offset++) != 'f') goto SET_INF_ERROR;\n    if (*(offset++) != 'i') goto SET_INF_ERROR;\n    if (*(offset++) != 'n') goto SET_INF_ERROR;\n    if (*(offset++) != 'i') goto SET_INF_ERROR;\n    if (*(offset++) != 't') goto SET_INF_ERROR;\n    if (*(offset++) != 'y') goto SET_INF_ERROR;\n\n    ds->start = offset;\n\n    if (intNeg == 1) {\n      ds->lastType = JT_POS_INF;\n      return ds->dec->newPosInf(ds->prv);\n    } else {\n      ds->lastType = JT_NEG_INF;\n      return ds->dec->newNegInf(ds->prv);\n    }\n\nSET_INF_ERROR:\n    if (intNeg == 1) {\n      const char *msg = \"Unexpected character found when decoding 'Infinity'\";\n      return SetError(ds, -1, msg);\n    } else {\n      const char *msg = \"Unexpected character found when decoding '-Infinity'\";\n      return SetError(ds, -1, msg);\n    }\n\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_true ( struct DecoderState *ds)\n{\n  char *offset = ds->start;\n  offset ++;\n\n  if (*(offset++) != 'r')\n    goto SETERROR;\n  if (*(offset++) != 'u')\n    goto SETERROR;\n  if (*(offset++) != 'e')\n    goto SETERROR;\n\n  ds->lastType = JT_TRUE;\n  ds->start = offset;\n  return ds->dec->newTrue(ds->prv);\n\nSETERROR:\n  return SetError(ds, -1, \"Unexpected character found when decoding 'true'\");\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_false ( struct DecoderState *ds)\n{\n  char *offset = ds->start;\n  offset ++;\n\n  if (*(offset++) != 'a')\n    goto SETERROR;\n  if (*(offset++) != 'l')\n    goto SETERROR;\n  if (*(offset++) != 's')\n    goto SETERROR;\n  if (*(offset++) != 'e')\n    goto SETERROR;\n\n  ds->lastType = JT_FALSE;\n  ds->start = offset;\n  return ds->dec->newFalse(ds->prv);\n\nSETERROR:\n  return SetError(ds, -1, \"Unexpected character found when decoding 'false'\");\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_null ( struct DecoderState *ds)\n{\n  char *offset = ds->start;\n  offset ++;\n\n  if (*(offset++) != 'u')\n    goto SETERROR;\n  if (*(offset++) != 'l')\n    goto SETERROR;\n  if (*(offset++) != 'l')\n    goto SETERROR;\n\n  ds->lastType = JT_NULL;\n  ds->start = offset;\n  return ds->dec->newNull(ds->prv);\n\nSETERROR:\n  return SetError(ds, -1, \"Unexpected character found when decoding 'null'\");\n}\n\nstatic FASTCALL_ATTR void FASTCALL_MSVC SkipWhitespace(struct DecoderState *ds)\n{\n  char *offset = ds->start;\n\n  for (;;)\n  {\n    switch (*offset)\n    {\n      case ' ':\n      case '\\t':\n      case '\\r':\n      case '\\n':\n        offset ++;\n        break;\n\n      default:\n        ds->start = offset;\n        return;\n    }\n  }\n}\n\nenum DECODESTRINGSTATE\n{\n  DS_ISNULL = 0x32,\n  DS_ISQUOTE,\n  DS_ISESCAPE,\n  DS_UTFLENERROR,\n\n};\n\nstatic const JSUINT8 g_decoderLookup[256] =\n{\n  /* 0x00 */ DS_ISNULL, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x10 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x20 */ 1, 1, DS_ISQUOTE, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x30 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x40 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x50 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, DS_ISESCAPE, 1, 1, 1,\n  /* 0x60 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x70 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x80 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x90 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0xa0 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0xb0 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0xc0 */ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n  /* 0xd0 */ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n  /* 0xe0 */ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  /* 0xf0 */ 4, 4, 4, 4, 4, 4, 4, 4, DS_UTFLENERROR, DS_UTFLENERROR, DS_UTFLENERROR, DS_UTFLENERROR, DS_UTFLENERROR, DS_UTFLENERROR, DS_UTFLENERROR, DS_UTFLENERROR,\n};\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_string ( struct DecoderState *ds)\n{\n  int index;\n  wchar_t *escOffset;\n  wchar_t *escStart;\n  size_t escLen = (ds->escEnd - ds->escStart);\n  JSUINT8 *inputOffset;\n  JSUTF16 ch = 0;\n#if WCHAR_MAX >= 0x10FFFF\n  JSUINT8 *lastHighSurrogate = NULL;\n#endif\n  JSUINT8 oct;\n  JSUTF32 ucs;\n  ds->lastType = JT_INVALID;\n  ds->start ++;\n\n  if ( (size_t) (ds->end - ds->start) > escLen)\n  {\n    size_t newSize = (ds->end - ds->start);\n\n    if (ds->escHeap)\n    {\n      if (newSize > (SIZE_MAX / sizeof(wchar_t)))\n      {\n        return SetError(ds, -1, \"Could not reserve memory block\");\n      }\n      escStart = (wchar_t *)ds->dec->realloc(ds->escStart, newSize * sizeof(wchar_t));\n      if (!escStart)\n      {\n        ds->dec->free(ds->escStart);\n        return SetError(ds, -1, \"Could not reserve memory block\");\n      }\n      ds->escStart = escStart;\n    }\n    else\n    {\n      wchar_t *oldStart = ds->escStart;\n      if (newSize > (SIZE_MAX / sizeof(wchar_t)))\n      {\n        return SetError(ds, -1, \"Could not reserve memory block\");\n      }\n      ds->escStart = (wchar_t *) ds->dec->malloc(newSize * sizeof(wchar_t));\n      if (!ds->escStart)\n      {\n        return SetError(ds, -1, \"Could not reserve memory block\");\n      }\n      ds->escHeap = 1;\n      memcpy(ds->escStart, oldStart, escLen * sizeof(wchar_t));\n    }\n\n    ds->escEnd = ds->escStart + newSize;\n  }\n\n  escOffset = ds->escStart;\n  inputOffset = (JSUINT8 *) ds->start;\n\n  for (;;)\n  {\n    switch (g_decoderLookup[(JSUINT8)(*inputOffset)])\n    {\n      case DS_ISNULL:\n      {\n        return SetError(ds, -1, \"Unmatched '\\\"' when decoding 'string'\");\n      }\n      case DS_ISQUOTE:\n      {\n        ds->lastType = JT_UTF8;\n        inputOffset ++;\n        ds->start += ( (char *) inputOffset - (ds->start));\n        return ds->dec->newString(ds->prv, ds->escStart, escOffset);\n      }\n      case DS_UTFLENERROR:\n      {\n        return SetError (ds, -1, \"Invalid UTF-8 sequence length when decoding 'string'\");\n      }\n      case DS_ISESCAPE:\n      {\n        inputOffset ++;\n        switch (*inputOffset)\n        {\n          case '\\\\': *(escOffset++) = L'\\\\'; inputOffset++; continue;\n          case '\\\"': *(escOffset++) = L'\\\"'; inputOffset++; continue;\n          case '/':  *(escOffset++) = L'/';  inputOffset++; continue;\n          case 'b':  *(escOffset++) = L'\\b'; inputOffset++; continue;\n          case 'f':  *(escOffset++) = L'\\f'; inputOffset++; continue;\n          case 'n':  *(escOffset++) = L'\\n'; inputOffset++; continue;\n          case 'r':  *(escOffset++) = L'\\r'; inputOffset++; continue;\n          case 't':  *(escOffset++) = L'\\t'; inputOffset++; continue;\n\n          case 'u':\n          {\n            int index;\n            inputOffset ++;\n\n            for (index = 0; index < 4; index ++)\n            {\n              switch (*inputOffset)\n              {\n                case '\\0': return SetError (ds, -1, \"Unterminated unicode escape sequence when decoding 'string'\");\n                default: return SetError (ds, -1, \"Unexpected character in unicode escape sequence when decoding 'string'\");\n\n                case '0':\n                case '1':\n                case '2':\n                case '3':\n                case '4':\n                case '5':\n                case '6':\n                case '7':\n                case '8':\n                case '9':\n                  ch = (ch << 4) + (JSUTF16) (*inputOffset - '0');\n                  break;\n\n                case 'a':\n                case 'b':\n                case 'c':\n                case 'd':\n                case 'e':\n                case 'f':\n                  ch = (ch << 4) + 10 + (JSUTF16) (*inputOffset - 'a');\n                  break;\n\n                case 'A':\n                case 'B':\n                case 'C':\n                case 'D':\n                case 'E':\n                case 'F':\n                  ch = (ch << 4) + 10 + (JSUTF16) (*inputOffset - 'A');\n                  break;\n              }\n\n              inputOffset ++;\n            }\n\n#if WCHAR_MAX >= 0x10FFFF\n            if ((ch & 0xfc00) == 0xdc00 && lastHighSurrogate == inputOffset - 6 * sizeof(*inputOffset))\n            {\n              // Low surrogate immediately following a high surrogate\n              // Overwrite existing high surrogate with combined character\n              *(escOffset-1) = (((*(escOffset-1) - 0xd800) <<10) | (ch - 0xdc00)) + 0x10000;\n            }\n            else\n#endif\n            {\n              *(escOffset++) = (wchar_t) ch;\n            }\n#if WCHAR_MAX >= 0x10FFFF\n            if ((ch & 0xfc00) == 0xd800)\n            {\n              lastHighSurrogate = inputOffset;\n            }\n#endif\n            break;\n          }\n\n          case '\\0': return SetError(ds, -1, \"Unterminated escape sequence when decoding 'string'\");\n          default: return SetError(ds, -1, \"Unrecognized escape sequence when decoding 'string'\");\n        }\n        break;\n      }\n\n      case 1:\n      {\n        *(escOffset++) = (wchar_t) (*inputOffset++);\n        break;\n      }\n\n      case 2:\n      {\n        ucs = (*inputOffset++) & 0x1f;\n        ucs <<= 6;\n        if (((*inputOffset) & 0x80) != 0x80)\n        {\n          return SetError(ds, -1, \"Invalid octet in UTF-8 sequence when decoding 'string'\");\n        }\n        ucs |= (*inputOffset++) & 0x3f;\n        if (ucs < 0x80) return SetError (ds, -1, \"Overlong 2 byte UTF-8 sequence detected when decoding 'string'\");\n        *(escOffset++) = (wchar_t) ucs;\n        break;\n      }\n\n      case 3:\n      {\n        JSUTF32 ucs = 0;\n        ucs |= (*inputOffset++) & 0x0f;\n\n        for (index = 0; index < 2; index ++)\n        {\n          ucs <<= 6;\n          oct = (*inputOffset++);\n\n          if ((oct & 0x80) != 0x80)\n          {\n            return SetError(ds, -1, \"Invalid octet in UTF-8 sequence when decoding 'string'\");\n          }\n\n          ucs |= oct & 0x3f;\n        }\n\n        if (ucs < 0x800) return SetError (ds, -1, \"Overlong 3 byte UTF-8 sequence detected when encoding string\");\n        *(escOffset++) = (wchar_t) ucs;\n        break;\n      }\n\n      case 4:\n      {\n        JSUTF32 ucs = 0;\n        ucs |= (*inputOffset++) & 0x07;\n\n        for (index = 0; index < 3; index ++)\n        {\n          ucs <<= 6;\n          oct = (*inputOffset++);\n\n          if ((oct & 0x80) != 0x80)\n          {\n            return SetError(ds, -1, \"Invalid octet in UTF-8 sequence when decoding 'string'\");\n          }\n\n          ucs |= oct & 0x3f;\n        }\n\n        if (ucs < 0x10000) return SetError (ds, -1, \"Overlong 4 byte UTF-8 sequence detected when decoding 'string'\");\n\n#if WCHAR_MAX == 0xffff\n        if (ucs >= 0x10000)\n        {\n          ucs -= 0x10000;\n          *(escOffset++) = (wchar_t) (ucs >> 10) + 0xd800;\n          *(escOffset++) = (wchar_t) (ucs & 0x3ff) + 0xdc00;\n        }\n        else\n        {\n          *(escOffset++) = (wchar_t) ucs;\n        }\n#else\n        *(escOffset++) = (wchar_t) ucs;\n#endif\n        break;\n      }\n    }\n  }\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_array(struct DecoderState *ds)\n{\n  JSOBJ itemValue;\n  JSOBJ newObj;\n  int len;\n  ds->objDepth++;\n  if (ds->objDepth > JSON_MAX_OBJECT_DEPTH) {\n    return SetError(ds, -1, \"Reached object decoding depth limit\");\n  }\n\n  newObj = ds->dec->newArray(ds->prv);\n  len = 0;\n\n  ds->lastType = JT_INVALID;\n  ds->start ++;\n\n  for (;;)\n  {\n    SkipWhitespace(ds);\n\n    if ((*ds->start) == ']')\n    {\n      ds->objDepth--;\n      if (len == 0)\n      {\n        ds->start ++;\n        return newObj;\n      }\n\n      ds->dec->releaseObject(ds->prv, newObj);\n      return SetError(ds, -1, \"Unexpected character found when decoding array value (1)\");\n    }\n\n    itemValue = decode_any(ds);\n\n    if (itemValue == NULL)\n    {\n      ds->dec->releaseObject(ds->prv, newObj);\n      return NULL;\n    }\n\n    ds->dec->arrayAddItem (ds->prv, newObj, itemValue);\n\n    SkipWhitespace(ds);\n\n    switch (*(ds->start++))\n    {\n    case ']':\n    {\n      ds->objDepth--;\n      return newObj;\n    }\n    case ',':\n      break;\n\n    default:\n      ds->dec->releaseObject(ds->prv, newObj);\n      return SetError(ds, -1, \"Unexpected character found when decoding array value (2)\");\n    }\n\n    len++;\n  }\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_object( struct DecoderState *ds)\n{\n  JSOBJ itemName;\n  JSOBJ itemValue;\n  JSOBJ newObj;\n  int len;\n\n  ds->objDepth++;\n  if (ds->objDepth > JSON_MAX_OBJECT_DEPTH)\n  {\n    return SetError(ds, -1, \"Reached object decoding depth limit\");\n  }\n\n  newObj = ds->dec->newObject(ds->prv);\n  len = 0;\n\n  ds->start ++;\n\n  for (;;)\n  {\n    SkipWhitespace(ds);\n\n    if ((*ds->start) == '}')\n    {\n      ds->objDepth--;\n      if (len == 0)\n      {\n        ds->start ++;\n        return newObj;\n      }\n\n      ds->dec->releaseObject(ds->prv, newObj);\n      return SetError(ds, -1, \"Unexpected character in found when decoding object value\");\n    }\n\n    ds->lastType = JT_INVALID;\n    itemName = decode_any(ds);\n\n    if (itemName == NULL)\n    {\n      ds->dec->releaseObject(ds->prv, newObj);\n      return NULL;\n    }\n\n    if (ds->lastType != JT_UTF8)\n    {\n      ds->dec->releaseObject(ds->prv, newObj);\n      ds->dec->releaseObject(ds->prv, itemName);\n      return SetError(ds, -1, \"Key name of object must be 'string' when decoding 'object'\");\n    }\n\n    SkipWhitespace(ds);\n\n    if (*(ds->start++) != ':')\n    {\n      ds->dec->releaseObject(ds->prv, newObj);\n      ds->dec->releaseObject(ds->prv, itemName);\n      return SetError(ds, -1, \"No ':' found when decoding object value\");\n    }\n\n    SkipWhitespace(ds);\n\n    itemValue = decode_any(ds);\n\n    if (itemValue == NULL)\n    {\n      ds->dec->releaseObject(ds->prv, newObj);\n      ds->dec->releaseObject(ds->prv, itemName);\n      return NULL;\n    }\n\n    ds->dec->objectAddKey (ds->prv, newObj, itemName, itemValue);\n\n    SkipWhitespace(ds);\n\n    switch (*(ds->start++))\n    {\n      case '}':\n      {\n        ds->objDepth--;\n        return newObj;\n      }\n      case ',':\n        break;\n\n      default:\n        ds->dec->releaseObject(ds->prv, newObj);\n        return SetError(ds, -1, \"Unexpected character in found when decoding object value\");\n    }\n\n    len++;\n  }\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_any(struct DecoderState *ds)\n{\n  for (;;)\n  {\n    switch (*ds->start)\n    {\n      case '\\\"':\n        return decode_string (ds);\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      case 'I':\n      case 'N':\n      case '-':\n        return decode_numeric (ds);\n\n      case '[': return decode_array (ds);\n      case '{': return decode_object (ds);\n      case 't': return decode_true (ds);\n      case 'f': return decode_false (ds);\n      case 'n': return decode_null (ds);\n\n      case ' ':\n      case '\\t':\n      case '\\r':\n      case '\\n':\n        // White space\n        ds->start ++;\n        break;\n\n      default:\n        return SetError(ds, -1, \"Expected object or value\");\n    }\n  }\n}\n\nJSOBJ JSON_DecodeObject(JSONObjectDecoder *dec, const char *buffer, size_t cbBuffer)\n{\n  /*\n  FIXME: Base the size of escBuffer of that of cbBuffer so that the unicode escaping doesn't run into the wall each time */\n  struct DecoderState ds;\n  wchar_t escBuffer[(JSON_MAX_STACK_BUFFER_SIZE / sizeof(wchar_t))];\n  JSOBJ ret;\n\n  ds.start = (char *) buffer;\n  ds.end = ds.start + cbBuffer;\n\n  ds.escStart = escBuffer;\n  ds.escEnd = ds.escStart + (JSON_MAX_STACK_BUFFER_SIZE / sizeof(wchar_t));\n  ds.escHeap = 0;\n  ds.prv = dec->prv;\n  ds.dec = dec;\n  ds.dec->errorStr = NULL;\n  ds.dec->errorOffset = NULL;\n  ds.objDepth = 0;\n\n  ds.dec = dec;\n\n  ret = decode_any (&ds);\n\n  if (ds.escHeap)\n  {\n    dec->free(ds.escStart);\n  }\n\n  if (!(dec->errorStr))\n  {\n    if ((ds.end - ds.start) > 0)\n    {\n      SkipWhitespace(&ds);\n    }\n\n    if (ds.start != ds.end && ret)\n    {\n      dec->releaseObject(ds.prv, ret);\n      return SetError(&ds, -1, \"Trailing data\");\n    }\n  }\n\n  return ret;\n}\n", "/*\nDeveloped by ESN, an Electronic Arts Inc. studio.\nCopyright (c) 2014, Electronic Arts Inc.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n* Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n* Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in the\ndocumentation and/or other materials provided with the distribution.\n* Neither the name of ESN, Electronic Arts Inc. nor the\nnames of its contributors may be used to endorse or promote products\nderived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL ELECTRONIC ARTS INC. BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\nPortions of code from MODP_ASCII - Ascii transformations (upper/lower, etc)\nhttp://code.google.com/p/stringencoders/\nCopyright (c) 2007  Nick Galbreath -- nickg [at] modp [dot] com. All rights reserved.\n\nNumeric decoder derived from from TCL library\nhttp://www.opensource.apple.com/source/tcl/tcl-14/tcl/license.terms\n * Copyright (c) 1988-1993 The Regents of the University of California.\n * Copyright (c) 1994 Sun Microsystems, Inc.\n*/\n\n#include <Python.h>\n#include <ultrajson.h>\n#include \"ujson.h\"\n\n\n//#define PRINTMARK() fprintf(stderr, \"%s: MARK(%d)\\n\", __FILE__, __LINE__)\n#define PRINTMARK()\n\nstatic void Object_objectAddKey(void *prv, JSOBJ obj, JSOBJ name, JSOBJ value)\n{\n  PyDict_SetItem (obj, name, value);\n  Py_DECREF( (PyObject *) name);\n  Py_DECREF( (PyObject *) value);\n  return;\n}\n\nstatic void Object_arrayAddItem(void *prv, JSOBJ obj, JSOBJ value)\n{\n  PyList_Append(obj, value);\n  Py_DECREF( (PyObject *) value);\n  return;\n}\n\nstatic JSOBJ Object_newString(void *prv, wchar_t *start, wchar_t *end)\n{\n  return PyUnicode_FromWideChar (start, (end - start));\n}\n\nstatic JSOBJ Object_newTrue(void *prv)\n{\n  Py_RETURN_TRUE;\n}\n\nstatic JSOBJ Object_newFalse(void *prv)\n{\n  Py_RETURN_FALSE;\n}\n\nstatic JSOBJ Object_newNull(void *prv)\n{\n  Py_RETURN_NONE;\n}\n\nstatic JSOBJ Object_newNaN(void *prv)\n{\n    return PyFloat_FromDouble(Py_NAN);\n}\n\nstatic JSOBJ Object_newPosInf(void *prv)\n{\n    return PyFloat_FromDouble(Py_HUGE_VAL);\n}\n\nstatic JSOBJ Object_newNegInf(void *prv)\n{\n    return PyFloat_FromDouble(-Py_HUGE_VAL);\n}\n\nstatic JSOBJ Object_newObject(void *prv)\n{\n  return PyDict_New();\n}\n\nstatic JSOBJ Object_newArray(void *prv)\n{\n  return PyList_New(0);\n}\n\nstatic JSOBJ Object_newInteger(void *prv, JSINT32 value)\n{\n  return PyLong_FromLong( (long) value);\n}\n\nstatic JSOBJ Object_newLong(void *prv, JSINT64 value)\n{\n  return PyLong_FromLongLong (value);\n}\n\nstatic JSOBJ Object_newUnsignedLong(void *prv, JSUINT64 value)\n{\n  return PyLong_FromUnsignedLongLong (value);\n}\n\nstatic JSOBJ Object_newIntegerFromString(void *prv, char *value, size_t length)\n{\n  // PyLong_FromString requires a NUL-terminated string in CPython, contrary to the documentation: https://github.com/python/cpython/issues/59200\n  char *buf = PyObject_Malloc(length + 1);\n  memcpy(buf, value, length);\n  buf[length] = '\\0';\n  return PyLong_FromString(buf, NULL, 10);\n}\n\nstatic JSOBJ Object_newDouble(void *prv, double value)\n{\n  return PyFloat_FromDouble(value);\n}\n\nstatic void Object_releaseObject(void *prv, JSOBJ obj)\n{\n  Py_DECREF( ((PyObject *)obj));\n}\n\nstatic char *g_kwlist[] = {\"obj\", NULL};\n\nPyObject* JSONToObj(PyObject* self, PyObject *args, PyObject *kwargs)\n{\n  PyObject *ret;\n  PyObject *sarg;\n  PyObject *arg;\n  JSONObjectDecoder decoder =\n  {\n    Object_newString,\n    Object_objectAddKey,\n    Object_arrayAddItem,\n    Object_newTrue,\n    Object_newFalse,\n    Object_newNull,\n    Object_newNaN,\n    Object_newPosInf,\n    Object_newNegInf,\n    Object_newObject,\n    Object_newArray,\n    Object_newInteger,\n    Object_newLong,\n    Object_newUnsignedLong,\n    Object_newIntegerFromString,\n    Object_newDouble,\n    Object_releaseObject,\n    PyObject_Malloc,\n    PyObject_Free,\n    PyObject_Realloc\n  };\n\n  decoder.prv = NULL;\n\n  if (!PyArg_ParseTupleAndKeywords(args, kwargs, \"O\", g_kwlist, &arg))\n  {\n      return NULL;\n  }\n\n  if (PyBytes_Check(arg))\n  {\n      sarg = arg;\n  }\n  else\n  if (PyUnicode_Check(arg))\n  {\n    sarg = PyUnicode_AsEncodedString(arg, NULL, \"surrogatepass\");\n    if (sarg == NULL)\n    {\n      //Exception raised above us by codec according to docs\n      return NULL;\n    }\n  }\n  else\n  {\n    PyErr_Format(PyExc_TypeError, \"Expected String or Unicode\");\n    return NULL;\n  }\n\n  decoder.errorStr = NULL;\n  decoder.errorOffset = NULL;\n\n  decoder.s2d = NULL;\n  dconv_s2d_init(&decoder.s2d, DCONV_S2D_ALLOW_TRAILING_JUNK, 0.0, 0.0, \"Infinity\", \"NaN\");\n\n  ret = JSON_DecodeObject(&decoder, PyBytes_AsString(sarg), PyBytes_Size(sarg));\n\n  dconv_s2d_free(&decoder.s2d);\n\n  if (sarg != arg)\n  {\n    Py_DECREF(sarg);\n  }\n\n  if (decoder.errorStr)\n  {\n    /*\n    FIXME: It's possible to give a much nicer error message here with actual failing element in input etc*/\n\n    PyErr_Format (JSONDecodeError, \"%s\", decoder.errorStr);\n\n    if (ret)\n    {\n        Py_DECREF( (PyObject *) ret);\n    }\n\n    return NULL;\n  }\n\n  return ret;\n}\n\nPyObject* JSONFileToObj(PyObject* self, PyObject *args, PyObject *kwargs)\n{\n  PyObject *read;\n  PyObject *string;\n  PyObject *result;\n  PyObject *file = NULL;\n  PyObject *argtuple;\n\n  if (!PyArg_ParseTuple (args, \"O\", &file))\n  {\n    return NULL;\n  }\n\n  if (!PyObject_HasAttrString (file, \"read\"))\n  {\n    PyErr_Format (PyExc_TypeError, \"expected file\");\n    return NULL;\n  }\n\n  read = PyObject_GetAttrString (file, \"read\");\n\n  if (!PyCallable_Check (read)) {\n    Py_XDECREF(read);\n    PyErr_Format (PyExc_TypeError, \"expected file\");\n    return NULL;\n  }\n\n  string = PyObject_CallObject (read, NULL);\n  Py_XDECREF(read);\n\n  if (string == NULL)\n  {\n    return NULL;\n  }\n\n  argtuple = PyTuple_Pack(1, string);\n\n  result = JSONToObj (self, argtuple, kwargs);\n\n  Py_XDECREF(argtuple);\n  Py_XDECREF(string);\n\n  if (result == NULL) {\n    return NULL;\n  }\n\n  return result;\n}\n", "import ctypes\nimport datetime as dt\nimport decimal\nimport io\nimport json\nimport math\nimport os.path\nimport re\nimport subprocess\nimport sys\nimport uuid\nfrom collections import OrderedDict\nfrom pathlib import Path\n\nimport pytest\nimport ujson\n\n\ndef assert_almost_equal(a, b):\n    assert round(abs(a - b), 7) == 0\n\n\ndef test_encode_decimal():\n    sut = decimal.Decimal(\"1337.1337\")\n    encoded = ujson.encode(sut)\n    decoded = ujson.decode(encoded)\n    assert decoded == 1337.1337\n\n\ndef test_encode_string_conversion():\n    test_input = \"A string \\\\ / \\b \\f \\n \\r \\t </script> &\"\n    not_html_encoded = '\"A string \\\\\\\\ \\\\/ \\\\b \\\\f \\\\n \\\\r \\\\t <\\\\/script> &\"'\n    html_encoded = (\n        '\"A string \\\\\\\\ \\\\/ \\\\b \\\\f \\\\n \\\\r \\\\t \\\\u003c\\\\/script\\\\u003e \\\\u0026\"'\n    )\n    not_slashes_escaped = '\"A string \\\\\\\\ / \\\\b \\\\f \\\\n \\\\r \\\\t </script> &\"'\n\n    def helper(expected_output, **encode_kwargs):\n        output = ujson.encode(test_input, **encode_kwargs)\n        assert output == expected_output\n        if encode_kwargs.get(\"escape_forward_slashes\", True):\n            assert test_input == json.loads(output)\n            assert test_input == ujson.decode(output)\n\n    # Default behavior assumes encode_html_chars=False.\n    helper(not_html_encoded, ensure_ascii=True)\n    helper(not_html_encoded, ensure_ascii=False)\n\n    # Make sure explicit encode_html_chars=False works.\n    helper(not_html_encoded, ensure_ascii=True, encode_html_chars=False)\n    helper(not_html_encoded, ensure_ascii=False, encode_html_chars=False)\n\n    # Make sure explicit encode_html_chars=True does the encoding.\n    helper(html_encoded, ensure_ascii=True, encode_html_chars=True)\n    helper(html_encoded, ensure_ascii=False, encode_html_chars=True)\n\n    # Do escape forward slashes if disabled.\n    helper(not_slashes_escaped, escape_forward_slashes=False)\n\n\ndef test_write_escaped_string():\n    assert \"\\\"\\\\u003cimg src='\\\\u0026amp;'\\\\/\\\\u003e\\\"\" == ujson.dumps(\n        \"<img src='&amp;'/>\", encode_html_chars=True\n    )\n\n\ndef test_double_long_issue():\n    sut = {\"a\": -4342969734183514}\n    encoded = json.dumps(sut)\n    decoded = json.loads(encoded)\n    assert sut == decoded\n    encoded = ujson.encode(sut)\n    decoded = ujson.decode(encoded)\n    assert sut == decoded\n\n\ndef test_double_long_decimal_issue():\n    sut = {\"a\": -12345678901234.56789012}\n    encoded = json.dumps(sut)\n    decoded = json.loads(encoded)\n    assert sut == decoded\n    encoded = ujson.encode(sut)\n    decoded = ujson.decode(encoded)\n    assert sut == decoded\n\n\n# NOTE: can't match exponents -9 to -5; Python 0-pads\n@pytest.mark.parametrize(\"val\", [1e-10, 1e-4, 1e10, 1e15, 1e16, 1e30])\ndef test_encode_float_string_rep(val):\n    assert ujson.dumps(val) == json.dumps(val)\n\n\ndef test_encode_decode_long_decimal():\n    sut = {\"a\": -528656961.4399388}\n    encoded = ujson.dumps(sut)\n    ujson.decode(encoded)\n\n\ndef test_decimal_decode_test():\n    sut = {\"a\": 4.56}\n    encoded = ujson.encode(sut)\n    decoded = ujson.decode(encoded)\n    assert_almost_equal(sut[\"a\"], decoded[\"a\"])\n\n\ndef test_encode_double_conversion():\n    test_input = math.pi\n    output = ujson.encode(test_input)\n    assert round(test_input, 5) == round(json.loads(output), 5)\n    assert round(test_input, 5) == round(ujson.decode(output), 5)\n\n\ndef test_encode_double_neg_conversion():\n    test_input = -math.pi\n    output = ujson.encode(test_input)\n\n    assert round(test_input, 5) == round(json.loads(output), 5)\n    assert round(test_input, 5) == round(ujson.decode(output), 5)\n\n\ndef test_encode_array_of_nested_arrays():\n    test_input = [[[[]]]] * 20\n    output = ujson.encode(test_input)\n    assert test_input == json.loads(output)\n    # assert output == json.dumps(test_input)\n    assert test_input == ujson.decode(output)\n\n\ndef test_encode_array_of_doubles():\n    test_input = [31337.31337, 31337.31337, 31337.31337, 31337.31337] * 10\n    output = ujson.encode(test_input)\n    assert test_input == json.loads(output)\n    # assert output == json.dumps(test_input)\n    assert test_input == ujson.decode(output)\n\n\ndef test_encode_string_conversion2():\n    test_input = \"A string \\\\ / \\b \\f \\n \\r \\t\"\n    output = ujson.encode(test_input)\n    assert test_input == json.loads(output)\n    assert output == '\"A string \\\\\\\\ \\\\/ \\\\b \\\\f \\\\n \\\\r \\\\t\"'\n    assert test_input == ujson.decode(output)\n\n\ndef test_encode_control_escaping():\n    test_input = \"\\x19\"\n    enc = ujson.encode(test_input)\n    dec = ujson.decode(enc)\n    assert test_input == dec\n    assert enc == json.dumps(test_input)\n\n\n# Characters outside of Basic Multilingual Plane(larger than\n# 16 bits) are represented as \\UXXXXXXXX in python but should be encoded\n# as \\uXXXX\\uXXXX in json.\ndef test_encode_unicode_bmp():\n    s = \"\\U0001f42e\\U0001f42e\\U0001F42D\\U0001F42D\"  # \ud83d\udc2e\ud83d\udc2e\ud83d\udc2d\ud83d\udc2d\n    encoded = ujson.dumps(s)\n    encoded_json = json.dumps(s)\n\n    if len(s) == 4:\n        assert len(encoded) == len(s) * 12 + 2\n    else:\n        assert len(encoded) == len(s) * 6 + 2\n\n    assert encoded == encoded_json\n    decoded = ujson.loads(encoded)\n    assert s == decoded\n\n    # ujson outputs a UTF-8 encoded str object\n    encoded = ujson.dumps(s, ensure_ascii=False)\n\n    # json outputs an unicode object\n    encoded_json = json.dumps(s, ensure_ascii=False)\n    assert len(encoded) == len(s) + 2  # original length + quotes\n    assert encoded == encoded_json\n    decoded = ujson.loads(encoded)\n    assert s == decoded\n\n\ndef test_encode_symbols():\n    s = \"\\u273f\\u2661\\u273f\"  # \u273f\u2661\u273f\n    encoded = ujson.dumps(s)\n    encoded_json = json.dumps(s)\n    assert len(encoded) == len(s) * 6 + 2  # 6 characters + quotes\n    assert encoded == encoded_json\n    decoded = ujson.loads(encoded)\n    assert s == decoded\n\n    # ujson outputs a UTF-8 encoded str object\n    encoded = ujson.dumps(s, ensure_ascii=False)\n\n    # json outputs an unicode object\n    encoded_json = json.dumps(s, ensure_ascii=False)\n    assert len(encoded) == len(s) + 2  # original length + quotes\n    assert encoded == encoded_json\n    decoded = ujson.loads(encoded)\n    assert s == decoded\n\n\ndef test_encode_long_neg_conversion():\n    test_input = -9223372036854775808\n    output = ujson.encode(test_input)\n\n    json.loads(output)\n    ujson.decode(output)\n\n    assert test_input == json.loads(output)\n    assert output == json.dumps(test_input)\n    assert test_input == ujson.decode(output)\n\n\ndef test_encode_list_conversion():\n    test_input = [1, 2, 3, 4]\n    output = ujson.encode(test_input)\n    assert test_input == json.loads(output)\n    assert test_input == ujson.decode(output)\n\n\ndef test_encode_dict_conversion():\n    test_input = {\"k1\": 1, \"k2\": 2, \"k3\": 3, \"k4\": 4}\n    output = ujson.encode(test_input)\n    assert test_input == json.loads(output)\n    assert test_input == ujson.decode(output)\n    assert test_input == ujson.decode(output)\n\n\n@pytest.mark.skipif(\n    hasattr(sys, \"pypy_version_info\"), reason=\"PyPy uses incompatible GC\"\n)\ndef test_encode_dict_values_ref_counting():\n    import gc\n\n    gc.collect()\n    value = [\"abc\"]\n    data = {\"1\": value}\n    ref_count = sys.getrefcount(value)\n    ujson.dumps(data)\n    assert ref_count == sys.getrefcount(value)\n\n\n@pytest.mark.skipif(\n    hasattr(sys, \"pypy_version_info\"), reason=\"PyPy uses incompatible GC\"\n)\n@pytest.mark.parametrize(\"key\", [\"key\", b\"key\", 1, True, None])\n@pytest.mark.parametrize(\"sort_keys\", [False, True])\ndef test_encode_dict_key_ref_counting(key, sort_keys):\n    import gc\n\n    gc.collect()\n    data = {key: \"abc\"}\n    ref_count = sys.getrefcount(key)\n    ujson.dumps(data, sort_keys=sort_keys)\n    assert ref_count == sys.getrefcount(key)\n\n\ndef test_encode_to_utf8():\n    test_input = b\"\\xe6\\x97\\xa5\\xd1\\x88\".decode(\"utf-8\")\n    enc = ujson.encode(test_input, ensure_ascii=False)\n    dec = ujson.decode(enc)\n    assert enc == json.dumps(test_input, ensure_ascii=False)\n    assert dec == json.loads(enc)\n\n\n@pytest.mark.parametrize(\n    \"test_input\",\n    [\n        '{\\n    \"obj\": 31337\\n}',\n        \"{}\",\n        \"[]\",\n        '{\\n    \"a\": {}\\n}',\n        \"[\\n    []\\n]\",\n    ],\n)\ndef test_encode_indent(test_input):\n    obj = ujson.decode(test_input)\n    output = ujson.encode(obj, indent=4)\n    assert test_input == output\n    assert output == json.dumps(obj, indent=4)\n\n\ndef test_decode_from_unicode():\n    test_input = '{\"obj\": 31337}'\n    dec1 = ujson.decode(test_input)\n    dec2 = ujson.decode(str(test_input))\n    assert dec1 == dec2\n\n\ndef test_encode_recursion_max():\n    # 8 is the max recursion depth\n    class O2:\n        member = 0\n\n        def toDict(self):\n            return {\"member\": self.member}\n\n    class O1:\n        member = 0\n\n        def toDict(self):\n            return {\"member\": self.member}\n\n    test_input = O1()\n    test_input.member = O2()\n    test_input.member.member = test_input\n    with pytest.raises(OverflowError):\n        ujson.encode(test_input)\n\n\ndef test_decode_dict():\n    test_input = \"{}\"\n    obj = ujson.decode(test_input)\n    assert {} == obj\n    test_input = '{\"one\": 1, \"two\": 2, \"three\": 3}'\n    obj = ujson.decode(test_input)\n    assert {\"one\": 1, \"two\": 2, \"three\": 3} == obj\n\n\ndef test_encode_unicode_4_bytes_utf8_fail():\n    test_input = b\"\\xfd\\xbf\\xbf\\xbf\\xbf\\xbf\"\n    with pytest.raises(OverflowError):\n        ujson.encode(test_input, reject_bytes=False)\n\n\ndef test_encode_null_character():\n    test_input = \"31337 \\x00 1337\"\n    output = ujson.encode(test_input)\n    assert test_input == json.loads(output)\n    assert output == json.dumps(test_input)\n    assert test_input == ujson.decode(output)\n\n    test_input = \"\\x00\"\n    output = ujson.encode(test_input)\n    assert test_input == json.loads(output)\n    assert output == json.dumps(test_input)\n    assert test_input == ujson.decode(output)\n\n    assert '\"  \\\\u0000\\\\r\\\\n \"' == ujson.dumps(\"  \\u0000\\r\\n \")\n\n\ndef test_decode_null_character():\n    test_input = '\"31337 \\\\u0000 31337\"'\n    assert ujson.decode(test_input) == json.loads(test_input)\n\n\ndef test_dump_to_file():\n    f = io.StringIO()\n    ujson.dump([1, 2, 3], f)\n    assert \"[1,2,3]\" == f.getvalue()\n\n\ndef test_dump_to_file_like_object():\n    class FileLike:\n        def __init__(self):\n            self.bytes = \"\"\n\n        def write(self, bytes):\n            self.bytes += bytes\n\n    f = FileLike()\n    ujson.dump([1, 2, 3], f)\n    assert \"[1,2,3]\" == f.bytes\n\n\ndef test_dump_file_args_error():\n    with pytest.raises(TypeError):\n        ujson.dump([], \"\")\n\n\ndef test_load_file():\n    f = io.StringIO(\"[1,2,3,4]\")\n    assert [1, 2, 3, 4] == ujson.load(f)\n\n\ndef test_load_file_like_object():\n    class FileLike:\n        def read(self):\n            try:\n                self.end\n            except AttributeError:\n                self.end = True\n                return \"[1,2,3,4]\"\n\n    f = FileLike()\n    assert [1, 2, 3, 4] == ujson.load(f)\n\n\ndef test_load_file_args_error():\n    with pytest.raises(TypeError):\n        ujson.load(\"[]\")\n\n\ndef test_version():\n    assert re.search(\n        r\"^\\d+\\.\\d+(\\.\\d+)?\", ujson.__version__\n    ), \"ujson.__version__ must be a string like '1.4.0'\"\n\n\ndef test_decode_number_with32bit_sign_bit():\n    # Test that numbers that fit within 32 bits but would have the\n    # sign bit set (2**31 <= x < 2**32) are decoded properly.\n    docs = (\n        '{\"id\": 3590016419}',\n        '{\"id\": %s}' % 2**31,\n        '{\"id\": %s}' % 2**32,\n        '{\"id\": %s}' % ((2**32) - 1),\n    )\n    results = (3590016419, 2**31, 2**32, 2**32 - 1)\n    for doc, result in zip(docs, results):\n        assert ujson.decode(doc)[\"id\"] == result\n\n\ndef test_encode_big_escape():\n    for x in range(10):\n        base = \"\\u00e5\".encode()\n        test_input = base * 1024 * 1024 * 2\n        ujson.encode(test_input, reject_bytes=False)\n\n\ndef test_decode_big_escape():\n    for x in range(10):\n        base = \"\\u00e5\".encode()\n        quote = b'\"'\n        test_input = quote + (base * 1024 * 1024 * 2) + quote\n        ujson.decode(test_input)\n\n\ndef test_to_dict():\n    d = {\"key\": 31337}\n\n    class DictTest:\n        def toDict(self):\n            return d\n\n        def __json__(self):\n            return '\"json defined\"'  # Fallback and shouldn't be called.\n\n    o = DictTest()\n    output = ujson.encode(o)\n    dec = ujson.decode(output)\n    assert dec == d\n\n\ndef test_object_with_json():\n    # If __json__ returns a string, then that string\n    # will be used as a raw JSON snippet in the object.\n    output_text = \"this is the correct output\"\n\n    class JSONTest:\n        def __json__(self):\n            return '\"' + output_text + '\"'\n\n    d = {\"key\": JSONTest()}\n    output = ujson.encode(d)\n    dec = ujson.decode(output)\n    assert dec == {\"key\": output_text}\n\n\ndef test_object_with_complex_json():\n    # If __json__ returns a string, then that string\n    # will be used as a raw JSON snippet in the object.\n    obj = {\"foo\": [\"bar\", \"baz\"]}\n\n    class JSONTest:\n        def __json__(self):\n            return ujson.encode(obj)\n\n    d = {\"key\": JSONTest()}\n    output = ujson.encode(d)\n    dec = ujson.decode(output)\n    assert dec == {\"key\": obj}\n\n\ndef test_object_with_json_type_error():\n    # __json__ must return a string, otherwise it should raise an error.\n    for return_value in (None, 1234, 12.34, True, {}):\n\n        class JSONTest:\n            def __json__(self):\n                return return_value\n\n        d = {\"key\": JSONTest()}\n        with pytest.raises(TypeError):\n            ujson.encode(d)\n\n\ndef test_object_with_json_attribute_error():\n    # If __json__ raises an error, make sure python actually raises it.\n    class JSONTest:\n        def __json__(self):\n            raise AttributeError\n\n    d = {\"key\": JSONTest()}\n    with pytest.raises(AttributeError):\n        ujson.encode(d)\n\n\ndef test_decode_array_empty():\n    test_input = \"[]\"\n    obj = ujson.decode(test_input)\n    assert [] == obj\n\n\ndef test_encode_surrogate_characters():\n    assert ujson.dumps(\"\\udc7f\") == r'\"\\udc7f\"'\n    out = r'{\"\\ud800\":\"\\udfff\"}'\n    assert ujson.dumps({\"\\ud800\": \"\\udfff\"}) == out\n    assert ujson.dumps({\"\\ud800\": \"\\udfff\"}, sort_keys=True) == out\n    o = {b\"\\xed\\xa0\\x80\": b\"\\xed\\xbf\\xbf\"}\n    assert ujson.dumps(o, reject_bytes=False) == out\n    assert ujson.dumps(o, reject_bytes=False, sort_keys=True) == out\n\n    out2 = '{\"\\ud800\":\"\\udfff\"}'\n    assert ujson.dumps({\"\\ud800\": \"\\udfff\"}, ensure_ascii=False) == out2\n    assert ujson.dumps({\"\\ud800\": \"\\udfff\"}, ensure_ascii=False, sort_keys=True) == out2\n\n\n@pytest.mark.xfail(\n    hasattr(sys, \"pypy_version_info\") and os.name == \"nt\",\n    reason=\"This feature needs fixing! See #552\",\n)\n@pytest.mark.parametrize(\n    \"test_input, expected\",\n    [\n        # Normal cases\n        (r'\"\\uD83D\\uDCA9\"', \"\\U0001F4A9\"),\n        (r'\"a\\uD83D\\uDCA9b\"', \"a\\U0001F4A9b\"),\n        # Unpaired surrogates\n        (r'\"\\uD800\"', \"\\uD800\"),\n        (r'\"a\\uD800b\"', \"a\\uD800b\"),\n        (r'\"\\uDEAD\"', \"\\uDEAD\"),\n        (r'\"a\\uDEADb\"', \"a\\uDEADb\"),\n        (r'\"\\uD83D\\uD83D\\uDCA9\"', \"\\uD83D\\U0001F4A9\"),\n        (r'\"\\uDCA9\\uD83D\\uDCA9\"', \"\\uDCA9\\U0001F4A9\"),\n        (r'\"\\uD83D\\uDCA9\\uD83D\"', \"\\U0001F4A9\\uD83D\"),\n        (r'\"\\uD83D\\uDCA9\\uDCA9\"', \"\\U0001F4A9\\uDCA9\"),\n        (r'\"\\uD83D \\uDCA9\"', \"\\uD83D \\uDCA9\"),\n        # No decoding of actual surrogate characters (rather than escaped ones)\n        ('\"\\uD800\"', \"\\uD800\"),\n        ('\"\\uDEAD\"', \"\\uDEAD\"),\n        ('\"\\uD800a\\uDEAD\"', \"\\uD800a\\uDEAD\"),\n        ('\"\\uD83D\\uDCA9\"', \"\\uD83D\\uDCA9\"),\n    ],\n)\ndef test_decode_surrogate_characters(test_input, expected):\n    # FIXME Wrong output (combined char) on platforms with 16-bit wchar_t\n    if test_input == '\"\\uD83D\\uDCA9\"' and ctypes.sizeof(ctypes.c_wchar) == 2:\n        pytest.skip(\"Raw surrogate pairs are not supported with 16-bit wchar_t\")\n\n    assert ujson.loads(test_input) == expected\n    assert ujson.loads(test_input.encode(\"utf-8\", \"surrogatepass\")) == expected\n\n    # Ensure that this matches stdlib's behaviour\n    assert json.loads(test_input) == expected\n\n\ndef test_sort_keys():\n    data = {\"a\": 1, \"c\": 1, \"b\": 1, \"e\": 1, \"f\": 1, \"d\": 1}\n    sorted_keys = ujson.dumps(data, sort_keys=True)\n    assert sorted_keys == '{\"a\":1,\"b\":1,\"c\":1,\"d\":1,\"e\":1,\"f\":1}'\n\n\n@pytest.mark.parametrize(\n    \"test_input\",\n    [\n        \"[31337]\",  # array one item\n        \"18446744073709551615\",  # long unsigned value\n        \"9223372036854775807\",  # big value\n        \"-9223372036854775808\",  # small value\n        \"{}\\n\\t \",  # trailing whitespaces\n    ],\n)\ndef test_decode_no_assert(test_input):\n    ujson.decode(test_input)\n\n\n@pytest.mark.parametrize(\n    \"test_input, expected\",\n    [\n        (\"31337\", 31337),\n        (\"-31337\", -31337),\n        (\"100000000000000000000.0\", 1e20),\n    ],\n)\ndef test_decode(test_input, expected):\n    assert ujson.decode(test_input) == expected\n\n\n@pytest.mark.parametrize(\n    \"test_input\",\n    [\n        \"1337E40\",\n        \"1.337E40\",\n        \"1337E+9\",\n        \"1.337e+40\",\n        \"1337E40\",\n        \"1337e40\",\n        \"1.337E-4\",\n        \"1.337e-4\",\n    ],\n)\ndef test_decode_numeric_int_exp(test_input):\n    output = ujson.decode(test_input)\n    assert output == json.loads(test_input)\n\n\n@pytest.mark.parametrize(\n    \"i\",\n    [\n        -(10**25),  # very negative\n        -(2**64),  # too large in magnitude for a uint64\n        -(2**63) - 1,  # too small for a int64\n        2**64,  # too large for a uint64\n        10**25,  # very positive\n    ],\n)\n@pytest.mark.parametrize(\"mode\", [\"encode\", \"decode\"])\ndef test_encode_decode_big_int(i, mode):\n    # Test ints that are too large to be represented by a C integer type\n    for python_object in (i, [i], {\"i\": i}):\n        json_string = json.dumps(python_object, separators=(\",\", \":\"))\n        if mode == \"encode\":\n            if hasattr(sys, \"pypy_version_info\"):\n                # https://foss.heptapod.net/pypy/pypy/-/issues/3765\n                pytest.skip(\"PyPy can't serialise big ints\")\n            assert ujson.encode(python_object) == json_string\n            if isinstance(python_object, dict):\n                assert ujson.encode(python_object, sort_keys=True) == json_string\n        else:\n            assert ujson.decode(json_string) == python_object\n\n\n@pytest.mark.parametrize(\n    \"test_input, expected\",\n    [\n        ('{{1337:\"\"}}', ujson.JSONDecodeError),  # broken dict key type leak test\n        ('{{\"key\":\"}', ujson.JSONDecodeError),  # broken dict leak test\n        ('{{\"key\":\"}', ujson.JSONDecodeError),  # broken dict leak test\n        (\"[[[true\", ujson.JSONDecodeError),  # broken list leak test\n    ],\n)\ndef test_decode_range_raises(test_input, expected):\n    for x in range(1000):\n        with pytest.raises(expected):\n            ujson.decode(test_input)\n\n\n@pytest.mark.parametrize(\n    \"test_input, expected\",\n    [\n        (\"fdsa sda v9sa fdsa\", ujson.JSONDecodeError),  # jibberish\n        (\"[\", ujson.JSONDecodeError),  # broken array start\n        (\"{\", ujson.JSONDecodeError),  # broken object start\n        (\"]\", ujson.JSONDecodeError),  # broken array end\n        (\"}\", ujson.JSONDecodeError),  # broken object end\n        ('{\"one\":1,}', ujson.JSONDecodeError),  # object trailing comma fail\n        ('\"TESTING', ujson.JSONDecodeError),  # string unterminated\n        ('\"TESTING\\\\\"', ujson.JSONDecodeError),  # string bad escape\n        (\"tru\", ujson.JSONDecodeError),  # true broken\n        (\"fa\", ujson.JSONDecodeError),  # false broken\n        (\"n\", ujson.JSONDecodeError),  # null broken\n        (\"{{{{31337}}}}\", ujson.JSONDecodeError),  # dict with no key\n        ('{{{{\"key\"}}}}', ujson.JSONDecodeError),  # dict with no colon or value\n        ('{{{{\"key\":}}}}', ujson.JSONDecodeError),  # dict with no value\n        (\"[31337,]\", ujson.JSONDecodeError),  # array trailing comma fail\n        (\"[,31337]\", ujson.JSONDecodeError),  # array leading comma fail\n        (\"[,]\", ujson.JSONDecodeError),  # array only comma fail\n        (\"[]]\", ujson.JSONDecodeError),  # array unmatched bracket fail\n        (\"{}\\n\\t a\", ujson.JSONDecodeError),  # with trailing non whitespaces\n        ('{\"age\", 44}', ujson.JSONDecodeError),  # read bad object syntax\n    ],\n)\ndef test_decode_raises(test_input, expected):\n    with pytest.raises(expected):\n        ujson.decode(test_input)\n\n\n@pytest.mark.parametrize(\n    \"test_input, expected\",\n    [\n        (\"[\", ujson.JSONDecodeError),  # array depth too big\n        (\"{\", ujson.JSONDecodeError),  # object depth too big\n    ],\n)\ndef test_decode_raises_for_long_input(test_input, expected):\n    with pytest.raises(expected):\n        ujson.decode(test_input * (1024 * 1024))\n\n\ndef test_decode_exception_is_value_error():\n    assert issubclass(ujson.JSONDecodeError, ValueError)\n    assert ujson.JSONDecodeError is not ValueError\n\n\n@pytest.mark.parametrize(\n    \"test_input, expected\",\n    [\n        (True, \"true\"),\n        (False, \"false\"),\n        (None, \"null\"),\n        ([True, False, None], \"[true,false,null]\"),\n        ((True, False, None), \"[true,false,null]\"),\n    ],\n)\ndef test_dumps(test_input, expected):\n    assert ujson.dumps(test_input) == expected\n\n\nclass SomeObject:\n    def __init__(self, message, exception=None):\n        self._message = message\n        self._exception = exception\n\n    def __repr__(self):\n        if self._exception:\n            raise self._exception\n        return self._message\n\n\n@pytest.mark.parametrize(\n    \"test_input, expected_exception, expected_message\",\n    [\n        (set(), TypeError, \"set() is not JSON serializable\"),\n        ({1, 2, 3}, TypeError, \"{1, 2, 3} is not JSON serializable\"),\n        (SomeObject(\"Some Object\"), TypeError, \"Some Object is not JSON serializable\"),\n        (SomeObject(\"\\ud800\"), UnicodeEncodeError, None),\n        (SomeObject(None, KeyboardInterrupt), KeyboardInterrupt, None),\n    ],\n)\ndef test_dumps_raises(test_input, expected_exception, expected_message):\n    with pytest.raises(expected_exception) as e:\n        ujson.dumps(test_input)\n    if expected_message:\n        assert str(e.value) == expected_message\n\n\n@pytest.mark.parametrize(\n    \"test_input, expected_exception\",\n    [\n        (float(\"nan\"), OverflowError),\n        (float(\"inf\"), OverflowError),\n        (-float(\"inf\"), OverflowError),\n    ],\n)\ndef test_encode_raises_allow_nan(test_input, expected_exception):\n    with pytest.raises(expected_exception):\n        ujson.dumps(test_input, allow_nan=False)\n\n\ndef test_nan_inf_support():\n    # Test ported from pandas\n    text = '[\"a\", NaN, \"NaN\", Infinity, \"Infinity\", -Infinity, \"-Infinity\"]'\n    data = ujson.loads(text)\n    expected = [\n        \"a\",\n        float(\"nan\"),\n        \"NaN\",\n        float(\"inf\"),\n        \"Infinity\",\n        -float(\"inf\"),\n        \"-Infinity\",\n    ]\n    for a, b in zip(data, expected):\n        assert a == b or math.isnan(a) and math.isnan(b)\n\n\ndef test_special_singletons():\n    pos_inf = ujson.loads(\"Infinity\")\n    neg_inf = ujson.loads(\"-Infinity\")\n    nan = ujson.loads(\"NaN\")\n    null = ujson.loads(\"null\")\n    assert math.isinf(pos_inf) and pos_inf > 0\n    assert math.isinf(neg_inf) and neg_inf < 0\n    assert math.isnan(nan)\n    assert null is None\n\n\n@pytest.mark.parametrize(\n    \"test_input, expected_message\",\n    [\n        (\"n\", \"Unexpected character .* 'null'\"),\n        (\"N\", \"Unexpected character .*'NaN'\"),\n        (\"NA\", \"Unexpected character .* 'NaN'\"),\n        (\"Na N\", \"Unexpected character .* 'NaN'\"),\n        (\"nan\", \"Unexpected character .* 'null'\"),\n        (\"none\", \"Unexpected character .* 'null'\"),\n        (\"i\", \"Expected object or value\"),\n        (\"I\", \"Unexpected character .* 'Infinity'\"),\n        (\"Inf\", \"Unexpected character .* 'Infinity'\"),\n        (\"InfinitY\", \"Unexpected character .* 'Infinity'\"),\n        (\"-i\", \"Trailing data\"),\n        (\"-I\", \"Unexpected character .* '-Infinity'\"),\n        (\"-Inf\", \"Unexpected character .* '-Infinity'\"),\n        (\"-InfinitY\", \"Unexpected character .* '-Infinity'\"),\n        (\"- i\", \"Trailing data\"),\n        (\"- I\", \"Trailing data\"),\n        (\"- Inf\", \"Trailing data\"),\n        (\"- InfinitY\", \"Trailing data\"),\n    ],\n)\ndef test_incomplete_special_inputs(test_input, expected_message):\n    with pytest.raises(ujson.JSONDecodeError, match=expected_message):\n        ujson.loads(test_input)\n\n\n@pytest.mark.parametrize(\n    \"test_input, expected_message\",\n    [\n        (\"NaNaNaN\", \"Trailing data\"),\n        (\"Infinity and Beyond\", \"Trailing data\"),\n        (\"-Infinity-and-Beyond\", \"Trailing data\"),\n        (\"NaN!\", \"Trailing data\"),\n        (\"Infinity!\", \"Trailing data\"),\n        (\"-Infinity!\", \"Trailing data\"),\n    ],\n)\ndef test_overcomplete_special_inputs(test_input, expected_message):\n    with pytest.raises(ujson.JSONDecodeError, match=expected_message):\n        ujson.loads(test_input)\n\n\n@pytest.mark.parametrize(\n    \"test_input\",\n    [\n        {\n            \"key1\": \"value1\",\n            \"key1\": \"value1\",\n            \"key1\": \"value1\",\n            \"key1\": \"value1\",\n            \"key1\": \"value1\",\n            \"key1\": \"value1\",\n        },\n        {\n            \"\u0628\u0646\": \"value1\",\n            \"\u0628\u0646\": \"value1\",\n            \"\u0628\u0646\": \"value1\",\n            \"\u0628\u0646\": \"value1\",\n            \"\u0628\u0646\": \"value1\",\n            \"\u0628\u0646\": \"value1\",\n            \"\u0628\u0646\": \"value1\",\n        },\n    ],\n)\ndef test_encode_no_assert(test_input):\n    ujson.encode(test_input)\n\n\n@pytest.mark.parametrize(\n    \"test_input, expected\",\n    [\n        (1.0, \"1.0\"),\n        (OrderedDict([(1, 1), (0, 0), (8, 8), (2, 2)]), '{\"1\":1,\"0\":0,\"8\":8,\"2\":2}'),\n        ({\"a\": float(\"NaN\")}, '{\"a\":NaN}'),\n        ({\"a\": float(\"inf\")}, '{\"a\":Inf}'),\n        ({\"a\": -float(\"inf\")}, '{\"a\":-Inf}'),\n    ],\n)\ndef test_encode(test_input, expected):\n    assert ujson.encode(test_input) == expected\n\n\n@pytest.mark.parametrize(\n    \"test_input\",\n    [\n        [\n            9223372036854775807,\n            9223372036854775807,\n            9223372036854775807,\n            9223372036854775807,\n            9223372036854775807,\n            9223372036854775807,\n        ],\n        [\n            18446744073709551615,\n            18446744073709551615,\n            18446744073709551615,\n        ],\n    ],\n)\ndef test_encode_list_long_conversion(test_input):\n    output = ujson.encode(test_input)\n    assert test_input == json.loads(output)\n    assert test_input == ujson.decode(output)\n\n\n@pytest.mark.parametrize(\n    \"test_input\",\n    [\n        9223372036854775807,\n        18446744073709551615,\n    ],\n)\ndef test_encode_long_conversion(test_input):\n    output = ujson.encode(test_input)\n\n    assert test_input == json.loads(output)\n    assert output == json.dumps(test_input)\n    assert test_input == ujson.decode(output)\n\n\n@pytest.mark.parametrize(\n    \"test_input\",\n    [\n        [[[[]]]],\n        31337,\n        -31337,\n        None,\n        True,\n        False,\n    ],\n)\ndef test_encode_decode(test_input):\n    output = ujson.encode(test_input)\n\n    assert test_input == json.loads(output)\n    assert output == json.dumps(test_input)\n    assert test_input == ujson.decode(output)\n\n\n@pytest.mark.parametrize(\n    \"test_input\",\n    [\n        \"R\u00e4ksm\u00f6rg\u00e5s \u0627\u0633\u0627\u0645\u0629 \u0628\u0646 \u0645\u062d\u0645\u062f \u0628\u0646 \u0639\u0648\u0636 \u0628\u0646 \u0644\u0627\u062f\u0646\",\n        \"\\xe6\\x97\\xa5\\xd1\\x88\",\n        \"\\xf0\\x90\\x8d\\x86\",  # surrogate pair\n        \"\\xf0\\x91\\x80\\xb0TRAILINGNORMAL\",  # 4 bytes UTF8\n        \"\\xf3\\xbf\\xbf\\xbfTRAILINGNORMAL\",  # 4 bytes UTF8 highest\n    ],\n)\ndef test_encode_unicode(test_input):\n    enc = ujson.encode(test_input)\n    dec = ujson.decode(enc)\n\n    assert enc == json.dumps(test_input)\n    assert dec == json.loads(enc)\n\n\n@pytest.mark.parametrize(\n    \"test_input, expected\",\n    [\n        (\"-1.1234567893\", -1.1234567893),\n        (\"-1.234567893\", -1.234567893),\n        (\"-1.34567893\", -1.34567893),\n        (\"-1.4567893\", -1.4567893),\n        (\"-1.567893\", -1.567893),\n        (\"-1.67893\", -1.67893),\n        (\"-1.7893\", -1.7893),\n        (\"-1.893\", -1.893),\n        (\"-1.3\", -1.3),\n        (\"1.1234567893\", 1.1234567893),\n        (\"1.234567893\", 1.234567893),\n        (\"1.34567893\", 1.34567893),\n        (\"1.4567893\", 1.4567893),\n        (\"1.567893\", 1.567893),\n        (\"1.67893\", 1.67893),\n        (\"1.7893\", 1.7893),\n        (\"1.893\", 1.893),\n        (\"1.3\", 1.3),\n        (\"true\", True),\n        (\"false\", False),\n        (\"null\", None),\n        (\" [ true, false,null] \", [True, False, None]),\n    ],\n)\ndef test_loads(test_input, expected):\n    assert ujson.loads(test_input) == expected\n\n\ndef test_reject_bytes_default():\n    data = {\"a\": b\"b\"}\n    with pytest.raises(TypeError):\n        ujson.dumps(data)\n\n\ndef test_reject_bytes_true():\n    data = {\"a\": b\"b\"}\n    with pytest.raises(TypeError):\n        ujson.dumps(data, reject_bytes=True)\n\n\ndef test_reject_bytes_false():\n    data = {\"a\": b\"b\"}\n    assert ujson.dumps(data, reject_bytes=False) == '{\"a\":\"b\"}'\n\n\ndef test_encode_none_key():\n    data = {None: None}\n    assert ujson.dumps(data) == '{\"null\":null}'\n\n\ndef test_default_function():\n    iso8601_time_format = \"%Y-%m-%dT%H:%M:%S.%f\"\n\n    class CustomObject:\n        pass\n\n    class UnjsonableObject:\n        pass\n\n    def default(value):\n        if isinstance(value, dt.datetime):\n            return value.strftime(iso8601_time_format)\n        elif isinstance(value, uuid.UUID):\n            return value.hex\n        elif isinstance(value, CustomObject):\n            raise ValueError(\"invalid value\")\n        return value\n\n    now = dt.datetime.now()\n    expected_output = '\"%s\"' % now.strftime(iso8601_time_format)\n    assert ujson.dumps(now, default=default) == expected_output\n\n    uuid4 = uuid.uuid4()\n    expected_output = '\"%s\"' % uuid4.hex\n    assert ujson.dumps(uuid4, default=default) == expected_output\n\n    custom_obj = CustomObject()\n    with pytest.raises(ValueError, match=\"invalid value\"):\n        ujson.dumps(custom_obj, default=default)\n\n    unjsonable_obj = UnjsonableObject()\n    with pytest.raises(TypeError, match=\"maximum recursion depth exceeded\"):\n        ujson.dumps(unjsonable_obj, default=default)\n\n\n@pytest.mark.parametrize(\"indent\", list(range(65537, 65542)))\ndef test_dump_huge_indent(indent):\n    ujson.encode({\"a\": True}, indent=indent)\n\n\n@pytest.mark.parametrize(\"first_length\", list(range(2, 7)))\n@pytest.mark.parametrize(\"second_length\", list(range(10919, 10924)))\ndef test_dump_long_string(first_length, second_length):\n    ujson.dumps([\"a\" * first_length, \"\\x00\" * second_length])\n\n\ndef test_dump_indented_nested_list():\n    a = _a = []\n    for i in range(20):\n        _a.append(list(range(i)))\n        _a = _a[-1]\n        ujson.dumps(a, indent=i)\n\n\n@pytest.mark.parametrize(\"indent\", [0, 1, 2, 4, 5, 8, 49])\ndef test_issue_334(indent):\n    path = Path(__file__).with_name(\"334-reproducer.json\")\n    a = ujson.loads(path.read_bytes())\n    ujson.dumps(a, indent=indent)\n\n\n@pytest.mark.skipif(\n    hasattr(sys, \"pypy_version_info\"), reason=\"PyPy uses incompatible GC\"\n)\ndef test_default_ref_counting():\n    class DefaultRefCountingClass:\n        def __init__(self, value):\n            self._value = value\n\n        def convert(self):\n            if self._value > 1:\n                return type(self)(self._value - 1)\n            return 0\n\n    import gc\n\n    gc.collect()\n    ujson.dumps(DefaultRefCountingClass(3), default=lambda x: x.convert())\n    assert not any(\n        type(o).__name__ == \"DefaultRefCountingClass\" for o in gc.get_objects()\n    )\n\n\n@pytest.mark.parametrize(\"sort_keys\", [False, True])\ndef test_obj_str_exception(sort_keys):\n    class Obj:\n        def __str__(self):\n            raise NotImplementedError\n\n    with pytest.raises(NotImplementedError):\n        ujson.dumps({Obj(): 1}, sort_keys=sort_keys)\n\n\ndef no_memory_leak(func_code, n=None):\n    code = f\"import functools, ujson; func = {func_code}\"\n    path = os.path.join(os.path.dirname(__file__), \"memory.py\")\n    n = [str(n)] if n is not None else []\n    p = subprocess.run([sys.executable, path, code] + n)\n    assert p.returncode == 0\n\n\n@pytest.mark.skipif(\n    hasattr(sys, \"pypy_version_info\"), reason=\"PyPy uses incompatible GC\"\n)\n@pytest.mark.parametrize(\"input\", ['[\"a\" * 11000, b\"\"]'])\ndef test_no_memory_leak_encoding_errors(input):\n    no_memory_leak(f\"functools.partial(ujson.dumps, {input})\")\n\n\n\"\"\"\ndef test_decode_numeric_int_frc_overflow():\ninput = \"X.Y\"\nraise NotImplementedError(\"Implement this test!\")\n\n\ndef test_decode_string_unicode_escape():\ninput = \"\\u3131\"\nraise NotImplementedError(\"Implement this test!\")\n\ndef test_decode_string_unicode_broken_escape():\ninput = \"\\u3131\"\nraise NotImplementedError(\"Implement this test!\")\n\ndef test_decode_string_unicode_invalid_escape():\ninput = \"\\u3131\"\nraise NotImplementedError(\"Implement this test!\")\n\ndef test_decode_string_utf8():\ninput = \"someutfcharacters\"\nraise NotImplementedError(\"Implement this test!\")\n\n\"\"\"\n\n\"\"\"\n# Use this to look for memory leaks\nif __name__ == '__main__':\n    import unittest\n    from guppy import hpy\n    hp = hpy()\n    hp.setrelheap()\n    while True:\n        try:\n            unittest.main()\n        except SystemExit:\n            pass\n        heap = hp.heapu()\n        print(heap)\n\"\"\"\n"], "fixing_code": ["/*\nDeveloped by ESN, an Electronic Arts Inc. studio.\nCopyright (c) 2014, Electronic Arts Inc.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n* Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n* Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in the\ndocumentation and/or other materials provided with the distribution.\n* Neither the name of ESN, Electronic Arts Inc. nor the\nnames of its contributors may be used to endorse or promote products\nderived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL ELECTRONIC ARTS INC. BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\nPortions of code from MODP_ASCII - Ascii transformations (upper/lower, etc)\nhttps://github.com/client9/stringencoders\nCopyright (c) 2007  Nick Galbreath -- nickg [at] modp [dot] com. All rights reserved.\n\nNumeric decoder derived from from TCL library\nhttps://opensource.apple.com/source/tcl/tcl-14/tcl/license.terms\n * Copyright (c) 1988-1993 The Regents of the University of California.\n * Copyright (c) 1994 Sun Microsystems, Inc.\n*/\n\n/*\nUltra fast JSON encoder and decoder\nDeveloped by Jonas Tarnstrom (jonas@esn.me).\n\nEncoder notes:\n------------------\n\n:: Cyclic references ::\nCyclic referenced objects are not detected.\nSet JSONObjectEncoder.recursionMax to suitable value or make sure input object\ntree doesn't have cyclic references.\n\n*/\n\n#ifndef __ULTRAJSON_H__\n#define __ULTRAJSON_H__\n\n#include <stdio.h>\n\n// Max decimals to encode double floating point numbers with\n#ifndef JSON_DOUBLE_MAX_DECIMALS\n    #define JSON_DOUBLE_MAX_DECIMALS 15\n#endif\n\n// Max recursion depth, default for encoder\n#ifndef JSON_MAX_RECURSION_DEPTH\n    #define JSON_MAX_RECURSION_DEPTH 1024\n#endif\n\n// Max recursion depth, default for decoder\n#ifndef JSON_MAX_OBJECT_DEPTH\n    #define JSON_MAX_OBJECT_DEPTH 1024\n#endif\n\n/*\nDictates and limits how much stack space for buffers UltraJSON will use before resorting to provided heap functions */\n#ifndef JSON_MAX_STACK_BUFFER_SIZE\n    #define JSON_MAX_STACK_BUFFER_SIZE 1024\n#endif\n\n#ifdef _WIN32\n\n    typedef __int64 JSINT64;\n    typedef unsigned __int64 JSUINT64;\n\n    typedef __int32 JSINT32;\n    typedef unsigned __int32 JSUINT32;\n    typedef unsigned __int8 JSUINT8;\n    typedef unsigned __int16 JSUTF16;\n    typedef unsigned __int32 JSUTF32;\n    typedef __int64 JSLONG;\n\n    #define EXPORTFUNCTION __declspec(dllexport)\n\n    #define FASTCALL_MSVC __fastcall\n    #define FASTCALL_ATTR\n    #define INLINE_PREFIX __inline\n\n#else\n\n    #include <stdint.h>\n    typedef int64_t JSINT64;\n    typedef uint64_t JSUINT64;\n\n    typedef int32_t JSINT32;\n    typedef uint32_t JSUINT32;\n\n    #define FASTCALL_MSVC\n\n    #if !defined __x86_64__\n        #define FASTCALL_ATTR __attribute__((fastcall))\n    #else\n        #define FASTCALL_ATTR\n    #endif\n\n    #define INLINE_PREFIX inline\n\n    typedef uint8_t JSUINT8;\n    typedef uint16_t JSUTF16;\n    typedef uint32_t JSUTF32;\n\n    typedef int64_t JSLONG;\n\n    #define EXPORTFUNCTION\n#endif\n\n#ifdef __GNUC__\n    #define LIKELY(x)       __builtin_expect(!!(x), 1)\n    #define UNLIKELY(x)     __builtin_expect(!!(x), 0)\n#else\n    #define LIKELY(x)       (x)\n    #define UNLIKELY(x)     (x)\n#endif\n\n#if !(defined(__LITTLE_ENDIAN__) || defined(__BIG_ENDIAN__))\n\n    #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n        #define __LITTLE_ENDIAN__\n    #else\n\n    #if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n        #define __BIG_ENDIAN__\n    #endif\n\n#endif\n\n#endif\n\n#if !defined(__LITTLE_ENDIAN__) && !defined(__BIG_ENDIAN__)\n    #error \"Endianness not supported\"\n#endif\n\nenum JSTYPES\n{\n  JT_NULL,      // NULL\n  JT_TRUE,      // boolean true\n  JT_FALSE,     // boolean false\n  JT_INT,       // (JSINT32 (signed 32-bit))\n  JT_LONG,      // (JSINT64 (signed 64-bit))\n  JT_ULONG,     // (JSUINT64 (unsigned 64-bit))\n  JT_DOUBLE,    // (double)\n  JT_UTF8,      // (char 8-bit)\n  JT_RAW,       // (raw char 8-bit)\n  JT_ARRAY,     // Array structure\n  JT_OBJECT,    // Key/Value structure\n  JT_INVALID,   // Internal, do not return nor expect\n  JT_NAN,       // Not A Number\n  JT_POS_INF,   // Positive infinity\n  JT_NEG_INF,   // Negative infinity\n};\n\ntypedef void * JSOBJ;\ntypedef void * JSITER;\n\ntypedef struct __JSONTypeContext\n{\n  int type;\n  void *prv;\n  void *encoder_prv;\n} JSONTypeContext;\n\n/*\nFunction pointer declarations, suitable for implementing UltraJSON */\ntypedef int (*JSPFN_ITERNEXT)(JSOBJ obj, JSONTypeContext *tc);\ntypedef void (*JSPFN_ITEREND)(JSOBJ obj, JSONTypeContext *tc);\ntypedef JSOBJ (*JSPFN_ITERGETVALUE)(JSOBJ obj, JSONTypeContext *tc);\ntypedef char *(*JSPFN_ITERGETNAME)(JSOBJ obj, JSONTypeContext *tc, size_t *outLen);\ntypedef void *(*JSPFN_MALLOC)(size_t size);\ntypedef void (*JSPFN_FREE)(void *pptr);\ntypedef void *(*JSPFN_REALLOC)(void *base, size_t size);\n\n\nstruct __JSONObjectEncoder;\n\ntypedef struct __JSONObjectEncoder\n{\n  void (*beginTypeContext)(JSOBJ obj, JSONTypeContext *tc, struct __JSONObjectEncoder *enc);\n  void (*endTypeContext)(JSOBJ obj, JSONTypeContext *tc);\n  const char *(*getStringValue)(JSOBJ obj, JSONTypeContext *tc, size_t *_outLen);\n  JSINT64 (*getLongValue)(JSOBJ obj, JSONTypeContext *tc);\n  JSUINT64 (*getUnsignedLongValue)(JSOBJ obj, JSONTypeContext *tc);\n  double (*getDoubleValue)(JSOBJ obj, JSONTypeContext *tc);\n\n  /*\n  Retrieve next object in an iteration. Should return 0 to indicate iteration has reached end or 1 if there are more items.\n  Implementor is responsible for keeping state of the iteration. Use ti->prv fields for this\n  */\n  JSPFN_ITERNEXT iterNext;\n\n  /*\n  Ends the iteration of an iteratable object.\n  Any iteration state stored in ti->prv can be freed here\n  */\n  JSPFN_ITEREND iterEnd;\n\n  /*\n  Returns a reference to the value object of an iterator\n  The is responsible for the life-cycle of the returned string. Use iterNext/iterEnd and ti->prv to keep track of current object\n  */\n  JSPFN_ITERGETVALUE iterGetValue;\n\n  /*\n  Return name of iterator.\n  The is responsible for the life-cycle of the returned string. Use iterNext/iterEnd and ti->prv to keep track of current object\n  */\n  JSPFN_ITERGETNAME iterGetName;\n\n  /*\n  Release a value as indicated by setting ti->release = 1 in the previous getValue call.\n  The ti->prv array should contain the necessary context to release the value\n  */\n  void (*releaseObject)(JSOBJ obj);\n\n  /* Library functions\n  Set to NULL to use STDLIB malloc,realloc,free */\n  JSPFN_MALLOC malloc;\n  JSPFN_REALLOC realloc;\n  JSPFN_FREE free;\n\n  /*\n  Configuration for max recursion, set to 0 to use default (see JSON_MAX_RECURSION_DEPTH)*/\n  int recursionMax;\n\n  /*\n  If true output will be ASCII with all characters above 127 encoded as \\uXXXX. If false output will be UTF-8 or what ever charset strings are brought as */\n  int forceASCII;\n\n  /*\n  If true, '<', '>', and '&' characters will be encoded as \\u003c, \\u003e, and \\u0026, respectively. If false, no special encoding will be used. */\n  int encodeHTMLChars;\n\n  /*\n  If true, '/' will be encoded as \\/. If false, no escaping. */\n  int escapeForwardSlashes;\n\n  /*\n  If true, dictionaries are iterated through in sorted key order. */\n  int sortKeys;\n\n  /*\n  Configuration for spaces of indent */\n  int indent;\n\n  /*\n  If true, NaN will be encoded as a string matching the Python standard library's JSON behavior.\n  This is not valid JSON. */\n  int allowNan;\n\n  /*\n  If true, bytes are rejected. */\n  int rejectBytes;\n\n  /*\n  Private pointer to be used by the caller. Passed as encoder_prv in JSONTypeContext */\n  void *prv;\n\n  /*\n  Pointer to the DoubleToStringConverter instance */\n  void *d2s;\n\n  /*\n  Set to an error message if error occured */\n  const char *errorMsg;\n  JSOBJ errorObj;\n\n  /* Buffer stuff */\n  char *start;\n  char *offset;\n  char *end;\n  int heap;\n  int level;\n\n} JSONObjectEncoder;\n\n\n/*\nEncode an object structure into JSON.\n\nArguments:\nobj - An anonymous type representing the object\nenc - Function definitions for querying JSOBJ type\nbuffer - Preallocated buffer to store result in. If NULL function allocates own buffer\ncbBuffer - Length of buffer (ignored if buffer is NULL)\noutLen - Will store the length of the encoded string\n\nReturns:\nEncoded JSON object as a char string.\n\nNOTE:\nIf the supplied buffer wasn't enough to hold the result the function will allocate a new buffer.\nLife cycle of the provided buffer must still be handled by caller.\n\nIf the return value doesn't equal the specified buffer caller must release the memory using\nJSONObjectEncoder.free or free() as specified when calling this function.\n\nIf an error occurs during encoding, NULL is returned and no outLen is stored.\n*/\nEXPORTFUNCTION char *JSON_EncodeObject(JSOBJ obj, JSONObjectEncoder *enc, char *buffer, size_t cbBuffer, size_t *outLen);\n\ntypedef struct __JSONObjectDecoder\n{\n  JSOBJ (*newString)(void *prv, JSUINT32 *start, JSUINT32 *end);\n  void (*objectAddKey)(void *prv, JSOBJ obj, JSOBJ name, JSOBJ value);\n  void (*arrayAddItem)(void *prv, JSOBJ obj, JSOBJ value);\n  JSOBJ (*newTrue)(void *prv);\n  JSOBJ (*newFalse)(void *prv);\n  JSOBJ (*newNull)(void *prv);\n  JSOBJ (*newNaN)(void *prv);\n  JSOBJ (*newPosInf)(void *prv);\n  JSOBJ (*newNegInf)(void *prv);\n  JSOBJ (*newObject)(void *prv);\n  JSOBJ (*newArray)(void *prv);\n  JSOBJ (*newInt)(void *prv, JSINT32 value);\n  JSOBJ (*newLong)(void *prv, JSINT64 value);\n  JSOBJ (*newUnsignedLong)(void *prv, JSUINT64 value);\n  JSOBJ (*newIntegerFromString)(void *prv, char *value, size_t length);\n  JSOBJ (*newDouble)(void *prv, double value);\n  void (*releaseObject)(void *prv, JSOBJ obj);\n  JSPFN_MALLOC malloc;\n  JSPFN_FREE free;\n  JSPFN_REALLOC realloc;\n  char *errorStr;\n  char *errorOffset;\n  void *prv;\n  void *s2d;\n} JSONObjectDecoder;\n\nEXPORTFUNCTION JSOBJ JSON_DecodeObject(JSONObjectDecoder *dec, const char *buffer, size_t cbBuffer);\n\n#define DCONV_DECIMAL_IN_SHORTEST_LOW -4\n#define DCONV_DECIMAL_IN_SHORTEST_HIGH 16\n\nenum dconv_d2s_flags {\n  DCONV_D2S_NO_FLAGS = 0,\n  DCONV_D2S_EMIT_POSITIVE_EXPONENT_SIGN = 1,\n  DCONV_D2S_EMIT_TRAILING_DECIMAL_POINT = 2,\n  DCONV_D2S_EMIT_TRAILING_ZERO_AFTER_POINT = 4,\n  DCONV_D2S_UNIQUE_ZERO = 8\n};\n\nenum dconv_s2d_flags\n{\n  DCONV_S2D_NO_FLAGS = 0,\n  DCONV_S2D_ALLOW_HEX = 1,\n  DCONV_S2D_ALLOW_OCTALS = 2,\n  DCONV_S2D_ALLOW_TRAILING_JUNK = 4,\n  DCONV_S2D_ALLOW_LEADING_SPACES = 8,\n  DCONV_S2D_ALLOW_TRAILING_SPACES = 16,\n  DCONV_S2D_ALLOW_SPACES_AFTER_SIGN = 32\n};\n\nvoid dconv_d2s_init(void **d2s,\n                    int flags,\n                    const char* infinity_symbol,\n                    const char* nan_symbol,\n                    char exponent_character,\n                    int decimal_in_shortest_low,\n                    int decimal_in_shortest_high,\n                    int max_leading_padding_zeroes_in_precision_mode,\n                    int max_trailing_padding_zeroes_in_precision_mode);\nint dconv_d2s(void *d2s, double value, char* buf, int buflen, int* strlength);\nvoid dconv_d2s_free(void **d2s);\n\nvoid dconv_s2d_init(void **s2d, int flags, double empty_string_value,\n                    double junk_string_value, const char* infinity_symbol,\n                    const char* nan_symbol);\ndouble dconv_s2d(void *s2d, const char* buffer, int length, int* processed_characters_count);\nvoid dconv_s2d_free(void **s2d);\n\n#endif\n", "/*\nDeveloped by ESN, an Electronic Arts Inc. studio.\nCopyright (c) 2014, Electronic Arts Inc.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n* Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n* Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in the\ndocumentation and/or other materials provided with the distribution.\n* Neither the name of ESN, Electronic Arts Inc. nor the\nnames of its contributors may be used to endorse or promote products\nderived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL ELECTRONIC ARTS INC. BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\nPortions of code from MODP_ASCII - Ascii transformations (upper/lower, etc)\nhttps://github.com/client9/stringencoders\nCopyright (c) 2007  Nick Galbreath -- nickg [at] modp [dot] com. All rights reserved.\n\nNumeric decoder derived from from TCL library\nhttps://opensource.apple.com/source/tcl/tcl-14/tcl/license.terms\n* Copyright (c) 1988-1993 The Regents of the University of California.\n* Copyright (c) 1994 Sun Microsystems, Inc.\n*/\n\n#include \"ultrajson.h\"\n#include <math.h>\n#include <assert.h>\n#include <string.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <stdint.h>\n\n#ifndef TRUE\n#define TRUE 1\n#define FALSE 0\n#endif\n#ifndef NULL\n#define NULL 0\n#endif\n\nstruct DecoderState\n{\n  char *start;\n  char *end;\n  JSUINT32 *escStart;\n  JSUINT32 *escEnd;\n  int escHeap;\n  int lastType;\n  JSUINT32 objDepth;\n  void *prv;\n  JSONObjectDecoder *dec;\n};\n\nstatic JSOBJ FASTCALL_MSVC decode_any( struct DecoderState *ds) FASTCALL_ATTR;\ntypedef JSOBJ (*PFN_DECODER)( struct DecoderState *ds);\n\nstatic JSOBJ SetError( struct DecoderState *ds, int offset, const char *message)\n{\n  ds->dec->errorOffset = ds->start + offset;\n  ds->dec->errorStr = (char *) message;\n  return NULL;\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decodeDouble(struct DecoderState *ds)\n{\n  int processed_characters_count;\n  int len = (int)(ds->end - ds->start);\n  double value = dconv_s2d(ds->dec->s2d, ds->start, len, &processed_characters_count);\n  ds->lastType = JT_DOUBLE;\n  ds->start += processed_characters_count;\n  return ds->dec->newDouble(ds->prv, value);\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_numeric (struct DecoderState *ds)\n{\n  int intNeg = 1;\n  int hasError = 0;\n  JSUINT64 intValue;\n  JSUINT64 addIntValue;\n  int chr;\n  char *offset = ds->start;\n\n  JSUINT64 maxIntValue = ULLONG_MAX;\n  JSUINT64 overflowLimit = maxIntValue / 10LLU;\n\n  if (*(offset) == 'I')\n  {\n    goto DECODE_INF;\n  }\n  else if (*(offset) == 'N')\n  {\n    goto DECODE_NAN;\n  }\n  else if (*(offset) == '-')\n  {\n    offset++;\n    intNeg = -1;\n    if (*(offset) == 'I')\n    {\n      goto DECODE_INF;\n    }\n    maxIntValue = -(JSUINT64) LLONG_MIN;\n    overflowLimit = maxIntValue / 10LL;\n  }\n\n  // Scan integer part\n  intValue = 0;\n\n  while (1)\n  {\n    chr = (int) (unsigned char) *(offset);\n\n    switch (chr)\n    {\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      {\n        // check whether multiplication would be out of bounds\n        if (intValue > overflowLimit)\n        {\n          hasError = 1;\n        }\n        intValue *= 10ULL;\n        addIntValue = (JSUINT64) (chr - 48);\n\n        // check whether addition would be out of bounds\n        if (maxIntValue - intValue < addIntValue)\n        {\n          hasError = 1;\n        }\n\n        intValue += addIntValue;\n        offset ++;\n        break;\n      }\n      case '.':\n      {\n        offset ++;\n        return decodeDouble(ds);\n      }\n      case 'e':\n      case 'E':\n      {\n        offset ++;\n        return decodeDouble(ds);\n      }\n\n      default:\n      {\n        if (hasError)\n        {\n          char *strStart = ds->start;\n          ds->lastType = JT_INT;\n          ds->start = offset;\n          return ds->dec->newIntegerFromString(ds->prv, strStart, offset - strStart);\n        }\n        goto BREAK_INT_LOOP;\n        break;\n      }\n    }\n  }\n\nBREAK_INT_LOOP:\n\n  ds->lastType = JT_INT;\n  ds->start = offset;\n\n  if (intNeg == 1 && (intValue & 0x8000000000000000ULL) != 0)\n  {\n    return ds->dec->newUnsignedLong(ds->prv, intValue);\n  }\n  else if ((intValue >> 31))\n  {\n    return ds->dec->newLong(ds->prv, (JSINT64) (intValue * (JSINT64) intNeg));\n  }\n  else\n  {\n    return ds->dec->newInt(ds->prv, (JSINT32) (intValue * intNeg));\n  }\n\nDECODE_NAN:\n    offset++;\n    if (*(offset++) != 'a') goto SET_NAN_ERROR;\n    if (*(offset++) != 'N') goto SET_NAN_ERROR;\n\n    ds->lastType = JT_NAN;\n    ds->start = offset;\n    return ds->dec->newNaN(ds->prv);\n\nSET_NAN_ERROR:\n    return SetError(ds, -1, \"Unexpected character found when decoding 'NaN'\");\n\nDECODE_INF:\n    offset++;\n    if (*(offset++) != 'n') goto SET_INF_ERROR;\n    if (*(offset++) != 'f') goto SET_INF_ERROR;\n    if (*(offset++) != 'i') goto SET_INF_ERROR;\n    if (*(offset++) != 'n') goto SET_INF_ERROR;\n    if (*(offset++) != 'i') goto SET_INF_ERROR;\n    if (*(offset++) != 't') goto SET_INF_ERROR;\n    if (*(offset++) != 'y') goto SET_INF_ERROR;\n\n    ds->start = offset;\n\n    if (intNeg == 1) {\n      ds->lastType = JT_POS_INF;\n      return ds->dec->newPosInf(ds->prv);\n    } else {\n      ds->lastType = JT_NEG_INF;\n      return ds->dec->newNegInf(ds->prv);\n    }\n\nSET_INF_ERROR:\n    if (intNeg == 1) {\n      const char *msg = \"Unexpected character found when decoding 'Infinity'\";\n      return SetError(ds, -1, msg);\n    } else {\n      const char *msg = \"Unexpected character found when decoding '-Infinity'\";\n      return SetError(ds, -1, msg);\n    }\n\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_true ( struct DecoderState *ds)\n{\n  char *offset = ds->start;\n  offset ++;\n\n  if (*(offset++) != 'r')\n    goto SETERROR;\n  if (*(offset++) != 'u')\n    goto SETERROR;\n  if (*(offset++) != 'e')\n    goto SETERROR;\n\n  ds->lastType = JT_TRUE;\n  ds->start = offset;\n  return ds->dec->newTrue(ds->prv);\n\nSETERROR:\n  return SetError(ds, -1, \"Unexpected character found when decoding 'true'\");\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_false ( struct DecoderState *ds)\n{\n  char *offset = ds->start;\n  offset ++;\n\n  if (*(offset++) != 'a')\n    goto SETERROR;\n  if (*(offset++) != 'l')\n    goto SETERROR;\n  if (*(offset++) != 's')\n    goto SETERROR;\n  if (*(offset++) != 'e')\n    goto SETERROR;\n\n  ds->lastType = JT_FALSE;\n  ds->start = offset;\n  return ds->dec->newFalse(ds->prv);\n\nSETERROR:\n  return SetError(ds, -1, \"Unexpected character found when decoding 'false'\");\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_null ( struct DecoderState *ds)\n{\n  char *offset = ds->start;\n  offset ++;\n\n  if (*(offset++) != 'u')\n    goto SETERROR;\n  if (*(offset++) != 'l')\n    goto SETERROR;\n  if (*(offset++) != 'l')\n    goto SETERROR;\n\n  ds->lastType = JT_NULL;\n  ds->start = offset;\n  return ds->dec->newNull(ds->prv);\n\nSETERROR:\n  return SetError(ds, -1, \"Unexpected character found when decoding 'null'\");\n}\n\nstatic FASTCALL_ATTR void FASTCALL_MSVC SkipWhitespace(struct DecoderState *ds)\n{\n  char *offset = ds->start;\n\n  for (;;)\n  {\n    switch (*offset)\n    {\n      case ' ':\n      case '\\t':\n      case '\\r':\n      case '\\n':\n        offset ++;\n        break;\n\n      default:\n        ds->start = offset;\n        return;\n    }\n  }\n}\n\nenum DECODESTRINGSTATE\n{\n  DS_ISNULL = 0x32,\n  DS_ISQUOTE,\n  DS_ISESCAPE,\n  DS_UTFLENERROR,\n\n};\n\nstatic const JSUINT8 g_decoderLookup[256] =\n{\n  /* 0x00 */ DS_ISNULL, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x10 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x20 */ 1, 1, DS_ISQUOTE, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x30 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x40 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x50 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, DS_ISESCAPE, 1, 1, 1,\n  /* 0x60 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x70 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x80 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0x90 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0xa0 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0xb0 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  /* 0xc0 */ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n  /* 0xd0 */ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n  /* 0xe0 */ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  /* 0xf0 */ 4, 4, 4, 4, 4, 4, 4, 4, DS_UTFLENERROR, DS_UTFLENERROR, DS_UTFLENERROR, DS_UTFLENERROR, DS_UTFLENERROR, DS_UTFLENERROR, DS_UTFLENERROR, DS_UTFLENERROR,\n};\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_string ( struct DecoderState *ds)\n{\n  int index;\n  JSUINT32 *escOffset;\n  JSUINT32 *escStart;\n  size_t escLen = (ds->escEnd - ds->escStart);\n  JSUINT8 *inputOffset;\n  JSUTF16 ch = 0;\n  JSUINT8 *lastHighSurrogate = NULL;\n  JSUINT8 oct;\n  JSUTF32 ucs;\n  ds->lastType = JT_INVALID;\n  ds->start ++;\n\n  if ( (size_t) (ds->end - ds->start) > escLen)\n  {\n    size_t newSize = (ds->end - ds->start);\n\n    if (ds->escHeap)\n    {\n      if (newSize > (SIZE_MAX / sizeof(JSUINT32)))\n      {\n        return SetError(ds, -1, \"Could not reserve memory block\");\n      }\n      escStart = (JSUINT32 *)ds->dec->realloc(ds->escStart, newSize * sizeof(JSUINT32));\n      if (!escStart)\n      {\n        ds->dec->free(ds->escStart);\n        return SetError(ds, -1, \"Could not reserve memory block\");\n      }\n      ds->escStart = escStart;\n    }\n    else\n    {\n      JSUINT32 *oldStart = ds->escStart;\n      if (newSize > (SIZE_MAX / sizeof(JSUINT32)))\n      {\n        return SetError(ds, -1, \"Could not reserve memory block\");\n      }\n      ds->escStart = (JSUINT32 *) ds->dec->malloc(newSize * sizeof(JSUINT32));\n      if (!ds->escStart)\n      {\n        return SetError(ds, -1, \"Could not reserve memory block\");\n      }\n      ds->escHeap = 1;\n      memcpy(ds->escStart, oldStart, escLen * sizeof(JSUINT32));\n    }\n\n    ds->escEnd = ds->escStart + newSize;\n  }\n\n  escOffset = ds->escStart;\n  inputOffset = (JSUINT8 *) ds->start;\n\n  for (;;)\n  {\n    switch (g_decoderLookup[(JSUINT8)(*inputOffset)])\n    {\n      case DS_ISNULL:\n      {\n        return SetError(ds, -1, \"Unmatched '\\\"' when decoding 'string'\");\n      }\n      case DS_ISQUOTE:\n      {\n        ds->lastType = JT_UTF8;\n        inputOffset ++;\n        ds->start += ( (char *) inputOffset - (ds->start));\n        return ds->dec->newString(ds->prv, ds->escStart, escOffset);\n      }\n      case DS_UTFLENERROR:\n      {\n        return SetError (ds, -1, \"Invalid UTF-8 sequence length when decoding 'string'\");\n      }\n      case DS_ISESCAPE:\n      {\n        inputOffset ++;\n        switch (*inputOffset)\n        {\n          case '\\\\': *(escOffset++) = '\\\\'; inputOffset++; continue;\n          case '\\\"': *(escOffset++) = '\\\"'; inputOffset++; continue;\n          case '/':  *(escOffset++) = '/';  inputOffset++; continue;\n          case 'b':  *(escOffset++) = '\\b'; inputOffset++; continue;\n          case 'f':  *(escOffset++) = '\\f'; inputOffset++; continue;\n          case 'n':  *(escOffset++) = '\\n'; inputOffset++; continue;\n          case 'r':  *(escOffset++) = '\\r'; inputOffset++; continue;\n          case 't':  *(escOffset++) = '\\t'; inputOffset++; continue;\n\n          case 'u':\n          {\n            int index;\n            inputOffset ++;\n\n            for (index = 0; index < 4; index ++)\n            {\n              switch (*inputOffset)\n              {\n                case '\\0': return SetError (ds, -1, \"Unterminated unicode escape sequence when decoding 'string'\");\n                default: return SetError (ds, -1, \"Unexpected character in unicode escape sequence when decoding 'string'\");\n\n                case '0':\n                case '1':\n                case '2':\n                case '3':\n                case '4':\n                case '5':\n                case '6':\n                case '7':\n                case '8':\n                case '9':\n                  ch = (ch << 4) + (JSUTF16) (*inputOffset - '0');\n                  break;\n\n                case 'a':\n                case 'b':\n                case 'c':\n                case 'd':\n                case 'e':\n                case 'f':\n                  ch = (ch << 4) + 10 + (JSUTF16) (*inputOffset - 'a');\n                  break;\n\n                case 'A':\n                case 'B':\n                case 'C':\n                case 'D':\n                case 'E':\n                case 'F':\n                  ch = (ch << 4) + 10 + (JSUTF16) (*inputOffset - 'A');\n                  break;\n              }\n\n              inputOffset ++;\n            }\n\n            if ((ch & 0xfc00) == 0xdc00 && lastHighSurrogate == inputOffset - 6 * sizeof(*inputOffset))\n            {\n              // Low surrogate immediately following a high surrogate\n              // Overwrite existing high surrogate with combined character\n              *(escOffset-1) = (((*(escOffset-1) - 0xd800) <<10) | (ch - 0xdc00)) + 0x10000;\n            }\n            else\n            {\n              *(escOffset++) = (JSUINT32) ch;\n            }\n            if ((ch & 0xfc00) == 0xd800)\n            {\n              lastHighSurrogate = inputOffset;\n            }\n            break;\n          }\n\n          case '\\0': return SetError(ds, -1, \"Unterminated escape sequence when decoding 'string'\");\n          default: return SetError(ds, -1, \"Unrecognized escape sequence when decoding 'string'\");\n        }\n        break;\n      }\n\n      case 1:\n      {\n        *(escOffset++) = (JSUINT32) (*inputOffset++);\n        break;\n      }\n\n      case 2:\n      {\n        ucs = (*inputOffset++) & 0x1f;\n        ucs <<= 6;\n        if (((*inputOffset) & 0x80) != 0x80)\n        {\n          return SetError(ds, -1, \"Invalid octet in UTF-8 sequence when decoding 'string'\");\n        }\n        ucs |= (*inputOffset++) & 0x3f;\n        if (ucs < 0x80) return SetError (ds, -1, \"Overlong 2 byte UTF-8 sequence detected when decoding 'string'\");\n        *(escOffset++) = (JSUINT32) ucs;\n        break;\n      }\n\n      case 3:\n      {\n        JSUTF32 ucs = 0;\n        ucs |= (*inputOffset++) & 0x0f;\n\n        for (index = 0; index < 2; index ++)\n        {\n          ucs <<= 6;\n          oct = (*inputOffset++);\n\n          if ((oct & 0x80) != 0x80)\n          {\n            return SetError(ds, -1, \"Invalid octet in UTF-8 sequence when decoding 'string'\");\n          }\n\n          ucs |= oct & 0x3f;\n        }\n\n        if (ucs < 0x800) return SetError (ds, -1, \"Overlong 3 byte UTF-8 sequence detected when encoding string\");\n        *(escOffset++) = (JSUINT32) ucs;\n        break;\n      }\n\n      case 4:\n      {\n        JSUTF32 ucs = 0;\n        ucs |= (*inputOffset++) & 0x07;\n\n        for (index = 0; index < 3; index ++)\n        {\n          ucs <<= 6;\n          oct = (*inputOffset++);\n\n          if ((oct & 0x80) != 0x80)\n          {\n            return SetError(ds, -1, \"Invalid octet in UTF-8 sequence when decoding 'string'\");\n          }\n\n          ucs |= oct & 0x3f;\n        }\n\n        if (ucs < 0x10000) return SetError (ds, -1, \"Overlong 4 byte UTF-8 sequence detected when decoding 'string'\");\n\n        *(escOffset++) = (JSUINT32) ucs;\n        break;\n      }\n    }\n  }\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_array(struct DecoderState *ds)\n{\n  JSOBJ itemValue;\n  JSOBJ newObj;\n  int len;\n  ds->objDepth++;\n  if (ds->objDepth > JSON_MAX_OBJECT_DEPTH) {\n    return SetError(ds, -1, \"Reached object decoding depth limit\");\n  }\n\n  newObj = ds->dec->newArray(ds->prv);\n  len = 0;\n\n  ds->lastType = JT_INVALID;\n  ds->start ++;\n\n  for (;;)\n  {\n    SkipWhitespace(ds);\n\n    if ((*ds->start) == ']')\n    {\n      ds->objDepth--;\n      if (len == 0)\n      {\n        ds->start ++;\n        return newObj;\n      }\n\n      ds->dec->releaseObject(ds->prv, newObj);\n      return SetError(ds, -1, \"Unexpected character found when decoding array value (1)\");\n    }\n\n    itemValue = decode_any(ds);\n\n    if (itemValue == NULL)\n    {\n      ds->dec->releaseObject(ds->prv, newObj);\n      return NULL;\n    }\n\n    ds->dec->arrayAddItem (ds->prv, newObj, itemValue);\n\n    SkipWhitespace(ds);\n\n    switch (*(ds->start++))\n    {\n    case ']':\n    {\n      ds->objDepth--;\n      return newObj;\n    }\n    case ',':\n      break;\n\n    default:\n      ds->dec->releaseObject(ds->prv, newObj);\n      return SetError(ds, -1, \"Unexpected character found when decoding array value (2)\");\n    }\n\n    len++;\n  }\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_object( struct DecoderState *ds)\n{\n  JSOBJ itemName;\n  JSOBJ itemValue;\n  JSOBJ newObj;\n  int len;\n\n  ds->objDepth++;\n  if (ds->objDepth > JSON_MAX_OBJECT_DEPTH)\n  {\n    return SetError(ds, -1, \"Reached object decoding depth limit\");\n  }\n\n  newObj = ds->dec->newObject(ds->prv);\n  len = 0;\n\n  ds->start ++;\n\n  for (;;)\n  {\n    SkipWhitespace(ds);\n\n    if ((*ds->start) == '}')\n    {\n      ds->objDepth--;\n      if (len == 0)\n      {\n        ds->start ++;\n        return newObj;\n      }\n\n      ds->dec->releaseObject(ds->prv, newObj);\n      return SetError(ds, -1, \"Unexpected character in found when decoding object value\");\n    }\n\n    ds->lastType = JT_INVALID;\n    itemName = decode_any(ds);\n\n    if (itemName == NULL)\n    {\n      ds->dec->releaseObject(ds->prv, newObj);\n      return NULL;\n    }\n\n    if (ds->lastType != JT_UTF8)\n    {\n      ds->dec->releaseObject(ds->prv, newObj);\n      ds->dec->releaseObject(ds->prv, itemName);\n      return SetError(ds, -1, \"Key name of object must be 'string' when decoding 'object'\");\n    }\n\n    SkipWhitespace(ds);\n\n    if (*(ds->start++) != ':')\n    {\n      ds->dec->releaseObject(ds->prv, newObj);\n      ds->dec->releaseObject(ds->prv, itemName);\n      return SetError(ds, -1, \"No ':' found when decoding object value\");\n    }\n\n    SkipWhitespace(ds);\n\n    itemValue = decode_any(ds);\n\n    if (itemValue == NULL)\n    {\n      ds->dec->releaseObject(ds->prv, newObj);\n      ds->dec->releaseObject(ds->prv, itemName);\n      return NULL;\n    }\n\n    ds->dec->objectAddKey (ds->prv, newObj, itemName, itemValue);\n\n    SkipWhitespace(ds);\n\n    switch (*(ds->start++))\n    {\n      case '}':\n      {\n        ds->objDepth--;\n        return newObj;\n      }\n      case ',':\n        break;\n\n      default:\n        ds->dec->releaseObject(ds->prv, newObj);\n        return SetError(ds, -1, \"Unexpected character in found when decoding object value\");\n    }\n\n    len++;\n  }\n}\n\nstatic FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_any(struct DecoderState *ds)\n{\n  for (;;)\n  {\n    switch (*ds->start)\n    {\n      case '\\\"':\n        return decode_string (ds);\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      case 'I':\n      case 'N':\n      case '-':\n        return decode_numeric (ds);\n\n      case '[': return decode_array (ds);\n      case '{': return decode_object (ds);\n      case 't': return decode_true (ds);\n      case 'f': return decode_false (ds);\n      case 'n': return decode_null (ds);\n\n      case ' ':\n      case '\\t':\n      case '\\r':\n      case '\\n':\n        // White space\n        ds->start ++;\n        break;\n\n      default:\n        return SetError(ds, -1, \"Expected object or value\");\n    }\n  }\n}\n\nJSOBJ JSON_DecodeObject(JSONObjectDecoder *dec, const char *buffer, size_t cbBuffer)\n{\n  /*\n  FIXME: Base the size of escBuffer of that of cbBuffer so that the unicode escaping doesn't run into the wall each time */\n  struct DecoderState ds;\n  JSUINT32 escBuffer[(JSON_MAX_STACK_BUFFER_SIZE / sizeof(JSUINT32))];\n  JSOBJ ret;\n\n  ds.start = (char *) buffer;\n  ds.end = ds.start + cbBuffer;\n\n  ds.escStart = escBuffer;\n  ds.escEnd = ds.escStart + (JSON_MAX_STACK_BUFFER_SIZE / sizeof(JSUINT32));\n  ds.escHeap = 0;\n  ds.prv = dec->prv;\n  ds.dec = dec;\n  ds.dec->errorStr = NULL;\n  ds.dec->errorOffset = NULL;\n  ds.objDepth = 0;\n\n  ds.dec = dec;\n\n  ret = decode_any (&ds);\n\n  if (ds.escHeap)\n  {\n    dec->free(ds.escStart);\n  }\n\n  if (!(dec->errorStr))\n  {\n    if ((ds.end - ds.start) > 0)\n    {\n      SkipWhitespace(&ds);\n    }\n\n    if (ds.start != ds.end && ret)\n    {\n      dec->releaseObject(ds.prv, ret);\n      return SetError(&ds, -1, \"Trailing data\");\n    }\n  }\n\n  return ret;\n}\n", "/*\nDeveloped by ESN, an Electronic Arts Inc. studio.\nCopyright (c) 2014, Electronic Arts Inc.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n* Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n* Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in the\ndocumentation and/or other materials provided with the distribution.\n* Neither the name of ESN, Electronic Arts Inc. nor the\nnames of its contributors may be used to endorse or promote products\nderived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL ELECTRONIC ARTS INC. BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\nPortions of code from MODP_ASCII - Ascii transformations (upper/lower, etc)\nhttp://code.google.com/p/stringencoders/\nCopyright (c) 2007  Nick Galbreath -- nickg [at] modp [dot] com. All rights reserved.\n\nNumeric decoder derived from from TCL library\nhttp://www.opensource.apple.com/source/tcl/tcl-14/tcl/license.terms\n * Copyright (c) 1988-1993 The Regents of the University of California.\n * Copyright (c) 1994 Sun Microsystems, Inc.\n*/\n\n#include <Python.h>\n#include <ultrajson.h>\n#include \"ujson.h\"\n\n\n//#define PRINTMARK() fprintf(stderr, \"%s: MARK(%d)\\n\", __FILE__, __LINE__)\n#define PRINTMARK()\n\nstatic void Object_objectAddKey(void *prv, JSOBJ obj, JSOBJ name, JSOBJ value)\n{\n  PyDict_SetItem (obj, name, value);\n  Py_DECREF( (PyObject *) name);\n  Py_DECREF( (PyObject *) value);\n  return;\n}\n\nstatic void Object_arrayAddItem(void *prv, JSOBJ obj, JSOBJ value)\n{\n  PyList_Append(obj, value);\n  Py_DECREF( (PyObject *) value);\n  return;\n}\n\n/*\nCheck that Py_UCS4 is the same as JSUINT32, else Object_newString will fail.\nBased on Linux's check in vbox_vmmdev_types.h.\nThis should be replaced with\n  _Static_assert(sizeof(Py_UCS4) == sizeof(JSUINT32));\nwhen C11 is made mandatory (CPython 3.11+, PyPy ?).\n*/\ntypedef char assert_py_ucs4_is_jsuint32[1 - 2*!(sizeof(Py_UCS4) == sizeof(JSUINT32))];\n\nstatic JSOBJ Object_newString(void *prv, JSUINT32 *start, JSUINT32 *end)\n{\n  return PyUnicode_FromKindAndData (PyUnicode_4BYTE_KIND, (Py_UCS4 *) start, (end - start));\n}\n\nstatic JSOBJ Object_newTrue(void *prv)\n{\n  Py_RETURN_TRUE;\n}\n\nstatic JSOBJ Object_newFalse(void *prv)\n{\n  Py_RETURN_FALSE;\n}\n\nstatic JSOBJ Object_newNull(void *prv)\n{\n  Py_RETURN_NONE;\n}\n\nstatic JSOBJ Object_newNaN(void *prv)\n{\n    return PyFloat_FromDouble(Py_NAN);\n}\n\nstatic JSOBJ Object_newPosInf(void *prv)\n{\n    return PyFloat_FromDouble(Py_HUGE_VAL);\n}\n\nstatic JSOBJ Object_newNegInf(void *prv)\n{\n    return PyFloat_FromDouble(-Py_HUGE_VAL);\n}\n\nstatic JSOBJ Object_newObject(void *prv)\n{\n  return PyDict_New();\n}\n\nstatic JSOBJ Object_newArray(void *prv)\n{\n  return PyList_New(0);\n}\n\nstatic JSOBJ Object_newInteger(void *prv, JSINT32 value)\n{\n  return PyLong_FromLong( (long) value);\n}\n\nstatic JSOBJ Object_newLong(void *prv, JSINT64 value)\n{\n  return PyLong_FromLongLong (value);\n}\n\nstatic JSOBJ Object_newUnsignedLong(void *prv, JSUINT64 value)\n{\n  return PyLong_FromUnsignedLongLong (value);\n}\n\nstatic JSOBJ Object_newIntegerFromString(void *prv, char *value, size_t length)\n{\n  // PyLong_FromString requires a NUL-terminated string in CPython, contrary to the documentation: https://github.com/python/cpython/issues/59200\n  char *buf = PyObject_Malloc(length + 1);\n  memcpy(buf, value, length);\n  buf[length] = '\\0';\n  return PyLong_FromString(buf, NULL, 10);\n}\n\nstatic JSOBJ Object_newDouble(void *prv, double value)\n{\n  return PyFloat_FromDouble(value);\n}\n\nstatic void Object_releaseObject(void *prv, JSOBJ obj)\n{\n  Py_DECREF( ((PyObject *)obj));\n}\n\nstatic char *g_kwlist[] = {\"obj\", NULL};\n\nPyObject* JSONToObj(PyObject* self, PyObject *args, PyObject *kwargs)\n{\n  PyObject *ret;\n  PyObject *sarg;\n  PyObject *arg;\n  JSONObjectDecoder decoder =\n  {\n    Object_newString,\n    Object_objectAddKey,\n    Object_arrayAddItem,\n    Object_newTrue,\n    Object_newFalse,\n    Object_newNull,\n    Object_newNaN,\n    Object_newPosInf,\n    Object_newNegInf,\n    Object_newObject,\n    Object_newArray,\n    Object_newInteger,\n    Object_newLong,\n    Object_newUnsignedLong,\n    Object_newIntegerFromString,\n    Object_newDouble,\n    Object_releaseObject,\n    PyObject_Malloc,\n    PyObject_Free,\n    PyObject_Realloc\n  };\n\n  decoder.prv = NULL;\n\n  if (!PyArg_ParseTupleAndKeywords(args, kwargs, \"O\", g_kwlist, &arg))\n  {\n      return NULL;\n  }\n\n  if (PyBytes_Check(arg))\n  {\n      sarg = arg;\n  }\n  else\n  if (PyUnicode_Check(arg))\n  {\n    sarg = PyUnicode_AsEncodedString(arg, NULL, \"surrogatepass\");\n    if (sarg == NULL)\n    {\n      //Exception raised above us by codec according to docs\n      return NULL;\n    }\n  }\n  else\n  {\n    PyErr_Format(PyExc_TypeError, \"Expected String or Unicode\");\n    return NULL;\n  }\n\n  decoder.errorStr = NULL;\n  decoder.errorOffset = NULL;\n\n  decoder.s2d = NULL;\n  dconv_s2d_init(&decoder.s2d, DCONV_S2D_ALLOW_TRAILING_JUNK, 0.0, 0.0, \"Infinity\", \"NaN\");\n\n  ret = JSON_DecodeObject(&decoder, PyBytes_AsString(sarg), PyBytes_Size(sarg));\n\n  dconv_s2d_free(&decoder.s2d);\n\n  if (sarg != arg)\n  {\n    Py_DECREF(sarg);\n  }\n\n  if (decoder.errorStr)\n  {\n    /*\n    FIXME: It's possible to give a much nicer error message here with actual failing element in input etc*/\n\n    PyErr_Format (JSONDecodeError, \"%s\", decoder.errorStr);\n\n    if (ret)\n    {\n        Py_DECREF( (PyObject *) ret);\n    }\n\n    return NULL;\n  }\n\n  return ret;\n}\n\nPyObject* JSONFileToObj(PyObject* self, PyObject *args, PyObject *kwargs)\n{\n  PyObject *read;\n  PyObject *string;\n  PyObject *result;\n  PyObject *file = NULL;\n  PyObject *argtuple;\n\n  if (!PyArg_ParseTuple (args, \"O\", &file))\n  {\n    return NULL;\n  }\n\n  if (!PyObject_HasAttrString (file, \"read\"))\n  {\n    PyErr_Format (PyExc_TypeError, \"expected file\");\n    return NULL;\n  }\n\n  read = PyObject_GetAttrString (file, \"read\");\n\n  if (!PyCallable_Check (read)) {\n    Py_XDECREF(read);\n    PyErr_Format (PyExc_TypeError, \"expected file\");\n    return NULL;\n  }\n\n  string = PyObject_CallObject (read, NULL);\n  Py_XDECREF(read);\n\n  if (string == NULL)\n  {\n    return NULL;\n  }\n\n  argtuple = PyTuple_Pack(1, string);\n\n  result = JSONToObj (self, argtuple, kwargs);\n\n  Py_XDECREF(argtuple);\n  Py_XDECREF(string);\n\n  if (result == NULL) {\n    return NULL;\n  }\n\n  return result;\n}\n", "import datetime as dt\nimport decimal\nimport io\nimport json\nimport math\nimport os.path\nimport re\nimport subprocess\nimport sys\nimport uuid\nfrom collections import OrderedDict\nfrom pathlib import Path\n\nimport pytest\nimport ujson\n\n\ndef assert_almost_equal(a, b):\n    assert round(abs(a - b), 7) == 0\n\n\ndef test_encode_decimal():\n    sut = decimal.Decimal(\"1337.1337\")\n    encoded = ujson.encode(sut)\n    decoded = ujson.decode(encoded)\n    assert decoded == 1337.1337\n\n\ndef test_encode_string_conversion():\n    test_input = \"A string \\\\ / \\b \\f \\n \\r \\t </script> &\"\n    not_html_encoded = '\"A string \\\\\\\\ \\\\/ \\\\b \\\\f \\\\n \\\\r \\\\t <\\\\/script> &\"'\n    html_encoded = (\n        '\"A string \\\\\\\\ \\\\/ \\\\b \\\\f \\\\n \\\\r \\\\t \\\\u003c\\\\/script\\\\u003e \\\\u0026\"'\n    )\n    not_slashes_escaped = '\"A string \\\\\\\\ / \\\\b \\\\f \\\\n \\\\r \\\\t </script> &\"'\n\n    def helper(expected_output, **encode_kwargs):\n        output = ujson.encode(test_input, **encode_kwargs)\n        assert output == expected_output\n        if encode_kwargs.get(\"escape_forward_slashes\", True):\n            assert test_input == json.loads(output)\n            assert test_input == ujson.decode(output)\n\n    # Default behavior assumes encode_html_chars=False.\n    helper(not_html_encoded, ensure_ascii=True)\n    helper(not_html_encoded, ensure_ascii=False)\n\n    # Make sure explicit encode_html_chars=False works.\n    helper(not_html_encoded, ensure_ascii=True, encode_html_chars=False)\n    helper(not_html_encoded, ensure_ascii=False, encode_html_chars=False)\n\n    # Make sure explicit encode_html_chars=True does the encoding.\n    helper(html_encoded, ensure_ascii=True, encode_html_chars=True)\n    helper(html_encoded, ensure_ascii=False, encode_html_chars=True)\n\n    # Do escape forward slashes if disabled.\n    helper(not_slashes_escaped, escape_forward_slashes=False)\n\n\ndef test_write_escaped_string():\n    assert \"\\\"\\\\u003cimg src='\\\\u0026amp;'\\\\/\\\\u003e\\\"\" == ujson.dumps(\n        \"<img src='&amp;'/>\", encode_html_chars=True\n    )\n\n\ndef test_double_long_issue():\n    sut = {\"a\": -4342969734183514}\n    encoded = json.dumps(sut)\n    decoded = json.loads(encoded)\n    assert sut == decoded\n    encoded = ujson.encode(sut)\n    decoded = ujson.decode(encoded)\n    assert sut == decoded\n\n\ndef test_double_long_decimal_issue():\n    sut = {\"a\": -12345678901234.56789012}\n    encoded = json.dumps(sut)\n    decoded = json.loads(encoded)\n    assert sut == decoded\n    encoded = ujson.encode(sut)\n    decoded = ujson.decode(encoded)\n    assert sut == decoded\n\n\n# NOTE: can't match exponents -9 to -5; Python 0-pads\n@pytest.mark.parametrize(\"val\", [1e-10, 1e-4, 1e10, 1e15, 1e16, 1e30])\ndef test_encode_float_string_rep(val):\n    assert ujson.dumps(val) == json.dumps(val)\n\n\ndef test_encode_decode_long_decimal():\n    sut = {\"a\": -528656961.4399388}\n    encoded = ujson.dumps(sut)\n    ujson.decode(encoded)\n\n\ndef test_decimal_decode_test():\n    sut = {\"a\": 4.56}\n    encoded = ujson.encode(sut)\n    decoded = ujson.decode(encoded)\n    assert_almost_equal(sut[\"a\"], decoded[\"a\"])\n\n\ndef test_encode_double_conversion():\n    test_input = math.pi\n    output = ujson.encode(test_input)\n    assert round(test_input, 5) == round(json.loads(output), 5)\n    assert round(test_input, 5) == round(ujson.decode(output), 5)\n\n\ndef test_encode_double_neg_conversion():\n    test_input = -math.pi\n    output = ujson.encode(test_input)\n\n    assert round(test_input, 5) == round(json.loads(output), 5)\n    assert round(test_input, 5) == round(ujson.decode(output), 5)\n\n\ndef test_encode_array_of_nested_arrays():\n    test_input = [[[[]]]] * 20\n    output = ujson.encode(test_input)\n    assert test_input == json.loads(output)\n    # assert output == json.dumps(test_input)\n    assert test_input == ujson.decode(output)\n\n\ndef test_encode_array_of_doubles():\n    test_input = [31337.31337, 31337.31337, 31337.31337, 31337.31337] * 10\n    output = ujson.encode(test_input)\n    assert test_input == json.loads(output)\n    # assert output == json.dumps(test_input)\n    assert test_input == ujson.decode(output)\n\n\ndef test_encode_string_conversion2():\n    test_input = \"A string \\\\ / \\b \\f \\n \\r \\t\"\n    output = ujson.encode(test_input)\n    assert test_input == json.loads(output)\n    assert output == '\"A string \\\\\\\\ \\\\/ \\\\b \\\\f \\\\n \\\\r \\\\t\"'\n    assert test_input == ujson.decode(output)\n\n\ndef test_encode_control_escaping():\n    test_input = \"\\x19\"\n    enc = ujson.encode(test_input)\n    dec = ujson.decode(enc)\n    assert test_input == dec\n    assert enc == json.dumps(test_input)\n\n\n# Characters outside of Basic Multilingual Plane(larger than\n# 16 bits) are represented as \\UXXXXXXXX in python but should be encoded\n# as \\uXXXX\\uXXXX in json.\ndef test_encode_unicode_bmp():\n    s = \"\\U0001f42e\\U0001f42e\\U0001F42D\\U0001F42D\"  # \ud83d\udc2e\ud83d\udc2e\ud83d\udc2d\ud83d\udc2d\n    encoded = ujson.dumps(s)\n    encoded_json = json.dumps(s)\n\n    if len(s) == 4:\n        assert len(encoded) == len(s) * 12 + 2\n    else:\n        assert len(encoded) == len(s) * 6 + 2\n\n    assert encoded == encoded_json\n    decoded = ujson.loads(encoded)\n    assert s == decoded\n\n    # ujson outputs a UTF-8 encoded str object\n    encoded = ujson.dumps(s, ensure_ascii=False)\n\n    # json outputs an unicode object\n    encoded_json = json.dumps(s, ensure_ascii=False)\n    assert len(encoded) == len(s) + 2  # original length + quotes\n    assert encoded == encoded_json\n    decoded = ujson.loads(encoded)\n    assert s == decoded\n\n\ndef test_encode_symbols():\n    s = \"\\u273f\\u2661\\u273f\"  # \u273f\u2661\u273f\n    encoded = ujson.dumps(s)\n    encoded_json = json.dumps(s)\n    assert len(encoded) == len(s) * 6 + 2  # 6 characters + quotes\n    assert encoded == encoded_json\n    decoded = ujson.loads(encoded)\n    assert s == decoded\n\n    # ujson outputs a UTF-8 encoded str object\n    encoded = ujson.dumps(s, ensure_ascii=False)\n\n    # json outputs an unicode object\n    encoded_json = json.dumps(s, ensure_ascii=False)\n    assert len(encoded) == len(s) + 2  # original length + quotes\n    assert encoded == encoded_json\n    decoded = ujson.loads(encoded)\n    assert s == decoded\n\n\ndef test_encode_long_neg_conversion():\n    test_input = -9223372036854775808\n    output = ujson.encode(test_input)\n\n    json.loads(output)\n    ujson.decode(output)\n\n    assert test_input == json.loads(output)\n    assert output == json.dumps(test_input)\n    assert test_input == ujson.decode(output)\n\n\ndef test_encode_list_conversion():\n    test_input = [1, 2, 3, 4]\n    output = ujson.encode(test_input)\n    assert test_input == json.loads(output)\n    assert test_input == ujson.decode(output)\n\n\ndef test_encode_dict_conversion():\n    test_input = {\"k1\": 1, \"k2\": 2, \"k3\": 3, \"k4\": 4}\n    output = ujson.encode(test_input)\n    assert test_input == json.loads(output)\n    assert test_input == ujson.decode(output)\n    assert test_input == ujson.decode(output)\n\n\n@pytest.mark.skipif(\n    hasattr(sys, \"pypy_version_info\"), reason=\"PyPy uses incompatible GC\"\n)\ndef test_encode_dict_values_ref_counting():\n    import gc\n\n    gc.collect()\n    value = [\"abc\"]\n    data = {\"1\": value}\n    ref_count = sys.getrefcount(value)\n    ujson.dumps(data)\n    assert ref_count == sys.getrefcount(value)\n\n\n@pytest.mark.skipif(\n    hasattr(sys, \"pypy_version_info\"), reason=\"PyPy uses incompatible GC\"\n)\n@pytest.mark.parametrize(\"key\", [\"key\", b\"key\", 1, True, None])\n@pytest.mark.parametrize(\"sort_keys\", [False, True])\ndef test_encode_dict_key_ref_counting(key, sort_keys):\n    import gc\n\n    gc.collect()\n    data = {key: \"abc\"}\n    ref_count = sys.getrefcount(key)\n    ujson.dumps(data, sort_keys=sort_keys)\n    assert ref_count == sys.getrefcount(key)\n\n\ndef test_encode_to_utf8():\n    test_input = b\"\\xe6\\x97\\xa5\\xd1\\x88\".decode(\"utf-8\")\n    enc = ujson.encode(test_input, ensure_ascii=False)\n    dec = ujson.decode(enc)\n    assert enc == json.dumps(test_input, ensure_ascii=False)\n    assert dec == json.loads(enc)\n\n\n@pytest.mark.parametrize(\n    \"test_input\",\n    [\n        '{\\n    \"obj\": 31337\\n}',\n        \"{}\",\n        \"[]\",\n        '{\\n    \"a\": {}\\n}',\n        \"[\\n    []\\n]\",\n    ],\n)\ndef test_encode_indent(test_input):\n    obj = ujson.decode(test_input)\n    output = ujson.encode(obj, indent=4)\n    assert test_input == output\n    assert output == json.dumps(obj, indent=4)\n\n\ndef test_decode_from_unicode():\n    test_input = '{\"obj\": 31337}'\n    dec1 = ujson.decode(test_input)\n    dec2 = ujson.decode(str(test_input))\n    assert dec1 == dec2\n\n\ndef test_encode_recursion_max():\n    # 8 is the max recursion depth\n    class O2:\n        member = 0\n\n        def toDict(self):\n            return {\"member\": self.member}\n\n    class O1:\n        member = 0\n\n        def toDict(self):\n            return {\"member\": self.member}\n\n    test_input = O1()\n    test_input.member = O2()\n    test_input.member.member = test_input\n    with pytest.raises(OverflowError):\n        ujson.encode(test_input)\n\n\ndef test_decode_dict():\n    test_input = \"{}\"\n    obj = ujson.decode(test_input)\n    assert {} == obj\n    test_input = '{\"one\": 1, \"two\": 2, \"three\": 3}'\n    obj = ujson.decode(test_input)\n    assert {\"one\": 1, \"two\": 2, \"three\": 3} == obj\n\n\ndef test_encode_unicode_4_bytes_utf8_fail():\n    test_input = b\"\\xfd\\xbf\\xbf\\xbf\\xbf\\xbf\"\n    with pytest.raises(OverflowError):\n        ujson.encode(test_input, reject_bytes=False)\n\n\ndef test_encode_null_character():\n    test_input = \"31337 \\x00 1337\"\n    output = ujson.encode(test_input)\n    assert test_input == json.loads(output)\n    assert output == json.dumps(test_input)\n    assert test_input == ujson.decode(output)\n\n    test_input = \"\\x00\"\n    output = ujson.encode(test_input)\n    assert test_input == json.loads(output)\n    assert output == json.dumps(test_input)\n    assert test_input == ujson.decode(output)\n\n    assert '\"  \\\\u0000\\\\r\\\\n \"' == ujson.dumps(\"  \\u0000\\r\\n \")\n\n\ndef test_decode_null_character():\n    test_input = '\"31337 \\\\u0000 31337\"'\n    assert ujson.decode(test_input) == json.loads(test_input)\n\n\ndef test_dump_to_file():\n    f = io.StringIO()\n    ujson.dump([1, 2, 3], f)\n    assert \"[1,2,3]\" == f.getvalue()\n\n\ndef test_dump_to_file_like_object():\n    class FileLike:\n        def __init__(self):\n            self.bytes = \"\"\n\n        def write(self, bytes):\n            self.bytes += bytes\n\n    f = FileLike()\n    ujson.dump([1, 2, 3], f)\n    assert \"[1,2,3]\" == f.bytes\n\n\ndef test_dump_file_args_error():\n    with pytest.raises(TypeError):\n        ujson.dump([], \"\")\n\n\ndef test_load_file():\n    f = io.StringIO(\"[1,2,3,4]\")\n    assert [1, 2, 3, 4] == ujson.load(f)\n\n\ndef test_load_file_like_object():\n    class FileLike:\n        def read(self):\n            try:\n                self.end\n            except AttributeError:\n                self.end = True\n                return \"[1,2,3,4]\"\n\n    f = FileLike()\n    assert [1, 2, 3, 4] == ujson.load(f)\n\n\ndef test_load_file_args_error():\n    with pytest.raises(TypeError):\n        ujson.load(\"[]\")\n\n\ndef test_version():\n    assert re.search(\n        r\"^\\d+\\.\\d+(\\.\\d+)?\", ujson.__version__\n    ), \"ujson.__version__ must be a string like '1.4.0'\"\n\n\ndef test_decode_number_with32bit_sign_bit():\n    # Test that numbers that fit within 32 bits but would have the\n    # sign bit set (2**31 <= x < 2**32) are decoded properly.\n    docs = (\n        '{\"id\": 3590016419}',\n        '{\"id\": %s}' % 2**31,\n        '{\"id\": %s}' % 2**32,\n        '{\"id\": %s}' % ((2**32) - 1),\n    )\n    results = (3590016419, 2**31, 2**32, 2**32 - 1)\n    for doc, result in zip(docs, results):\n        assert ujson.decode(doc)[\"id\"] == result\n\n\ndef test_encode_big_escape():\n    for x in range(10):\n        base = \"\\u00e5\".encode()\n        test_input = base * 1024 * 1024 * 2\n        ujson.encode(test_input, reject_bytes=False)\n\n\ndef test_decode_big_escape():\n    for x in range(10):\n        base = \"\\u00e5\".encode()\n        quote = b'\"'\n        test_input = quote + (base * 1024 * 1024 * 2) + quote\n        ujson.decode(test_input)\n\n\ndef test_to_dict():\n    d = {\"key\": 31337}\n\n    class DictTest:\n        def toDict(self):\n            return d\n\n        def __json__(self):\n            return '\"json defined\"'  # Fallback and shouldn't be called.\n\n    o = DictTest()\n    output = ujson.encode(o)\n    dec = ujson.decode(output)\n    assert dec == d\n\n\ndef test_object_with_json():\n    # If __json__ returns a string, then that string\n    # will be used as a raw JSON snippet in the object.\n    output_text = \"this is the correct output\"\n\n    class JSONTest:\n        def __json__(self):\n            return '\"' + output_text + '\"'\n\n    d = {\"key\": JSONTest()}\n    output = ujson.encode(d)\n    dec = ujson.decode(output)\n    assert dec == {\"key\": output_text}\n\n\ndef test_object_with_complex_json():\n    # If __json__ returns a string, then that string\n    # will be used as a raw JSON snippet in the object.\n    obj = {\"foo\": [\"bar\", \"baz\"]}\n\n    class JSONTest:\n        def __json__(self):\n            return ujson.encode(obj)\n\n    d = {\"key\": JSONTest()}\n    output = ujson.encode(d)\n    dec = ujson.decode(output)\n    assert dec == {\"key\": obj}\n\n\ndef test_object_with_json_type_error():\n    # __json__ must return a string, otherwise it should raise an error.\n    for return_value in (None, 1234, 12.34, True, {}):\n\n        class JSONTest:\n            def __json__(self):\n                return return_value\n\n        d = {\"key\": JSONTest()}\n        with pytest.raises(TypeError):\n            ujson.encode(d)\n\n\ndef test_object_with_json_attribute_error():\n    # If __json__ raises an error, make sure python actually raises it.\n    class JSONTest:\n        def __json__(self):\n            raise AttributeError\n\n    d = {\"key\": JSONTest()}\n    with pytest.raises(AttributeError):\n        ujson.encode(d)\n\n\ndef test_decode_array_empty():\n    test_input = \"[]\"\n    obj = ujson.decode(test_input)\n    assert [] == obj\n\n\ndef test_encode_surrogate_characters():\n    assert ujson.dumps(\"\\udc7f\") == r'\"\\udc7f\"'\n    out = r'{\"\\ud800\":\"\\udfff\"}'\n    assert ujson.dumps({\"\\ud800\": \"\\udfff\"}) == out\n    assert ujson.dumps({\"\\ud800\": \"\\udfff\"}, sort_keys=True) == out\n    o = {b\"\\xed\\xa0\\x80\": b\"\\xed\\xbf\\xbf\"}\n    assert ujson.dumps(o, reject_bytes=False) == out\n    assert ujson.dumps(o, reject_bytes=False, sort_keys=True) == out\n\n    out2 = '{\"\\ud800\":\"\\udfff\"}'\n    assert ujson.dumps({\"\\ud800\": \"\\udfff\"}, ensure_ascii=False) == out2\n    assert ujson.dumps({\"\\ud800\": \"\\udfff\"}, ensure_ascii=False, sort_keys=True) == out2\n\n\n@pytest.mark.parametrize(\n    \"test_input, expected\",\n    [\n        # Normal cases\n        (r'\"\\uD83D\\uDCA9\"', \"\\U0001F4A9\"),\n        (r'\"a\\uD83D\\uDCA9b\"', \"a\\U0001F4A9b\"),\n        # Unpaired surrogates\n        (r'\"\\uD800\"', \"\\uD800\"),\n        (r'\"a\\uD800b\"', \"a\\uD800b\"),\n        (r'\"\\uDEAD\"', \"\\uDEAD\"),\n        (r'\"a\\uDEADb\"', \"a\\uDEADb\"),\n        (r'\"\\uD83D\\uD83D\\uDCA9\"', \"\\uD83D\\U0001F4A9\"),\n        (r'\"\\uDCA9\\uD83D\\uDCA9\"', \"\\uDCA9\\U0001F4A9\"),\n        (r'\"\\uD83D\\uDCA9\\uD83D\"', \"\\U0001F4A9\\uD83D\"),\n        (r'\"\\uD83D\\uDCA9\\uDCA9\"', \"\\U0001F4A9\\uDCA9\"),\n        (r'\"\\uD83D \\uDCA9\"', \"\\uD83D \\uDCA9\"),\n        # No decoding of actual surrogate characters (rather than escaped ones)\n        ('\"\\uD800\"', \"\\uD800\"),\n        ('\"\\uDEAD\"', \"\\uDEAD\"),\n        ('\"\\uD800a\\uDEAD\"', \"\\uD800a\\uDEAD\"),\n        ('\"\\uD83D\\uDCA9\"', \"\\uD83D\\uDCA9\"),\n    ],\n)\ndef test_decode_surrogate_characters(test_input, expected):\n    assert ujson.loads(test_input) == expected\n    assert ujson.loads(test_input.encode(\"utf-8\", \"surrogatepass\")) == expected\n\n    # Ensure that this matches stdlib's behaviour\n    assert json.loads(test_input) == expected\n\n\ndef test_sort_keys():\n    data = {\"a\": 1, \"c\": 1, \"b\": 1, \"e\": 1, \"f\": 1, \"d\": 1}\n    sorted_keys = ujson.dumps(data, sort_keys=True)\n    assert sorted_keys == '{\"a\":1,\"b\":1,\"c\":1,\"d\":1,\"e\":1,\"f\":1}'\n\n\n@pytest.mark.parametrize(\n    \"test_input\",\n    [\n        \"[31337]\",  # array one item\n        \"18446744073709551615\",  # long unsigned value\n        \"9223372036854775807\",  # big value\n        \"-9223372036854775808\",  # small value\n        \"{}\\n\\t \",  # trailing whitespaces\n    ],\n)\ndef test_decode_no_assert(test_input):\n    ujson.decode(test_input)\n\n\n@pytest.mark.parametrize(\n    \"test_input, expected\",\n    [\n        (\"31337\", 31337),\n        (\"-31337\", -31337),\n        (\"100000000000000000000.0\", 1e20),\n    ],\n)\ndef test_decode(test_input, expected):\n    assert ujson.decode(test_input) == expected\n\n\n@pytest.mark.parametrize(\n    \"test_input\",\n    [\n        \"1337E40\",\n        \"1.337E40\",\n        \"1337E+9\",\n        \"1.337e+40\",\n        \"1337E40\",\n        \"1337e40\",\n        \"1.337E-4\",\n        \"1.337e-4\",\n    ],\n)\ndef test_decode_numeric_int_exp(test_input):\n    output = ujson.decode(test_input)\n    assert output == json.loads(test_input)\n\n\n@pytest.mark.parametrize(\n    \"i\",\n    [\n        -(10**25),  # very negative\n        -(2**64),  # too large in magnitude for a uint64\n        -(2**63) - 1,  # too small for a int64\n        2**64,  # too large for a uint64\n        10**25,  # very positive\n    ],\n)\n@pytest.mark.parametrize(\"mode\", [\"encode\", \"decode\"])\ndef test_encode_decode_big_int(i, mode):\n    # Test ints that are too large to be represented by a C integer type\n    for python_object in (i, [i], {\"i\": i}):\n        json_string = json.dumps(python_object, separators=(\",\", \":\"))\n        if mode == \"encode\":\n            if hasattr(sys, \"pypy_version_info\"):\n                # https://foss.heptapod.net/pypy/pypy/-/issues/3765\n                pytest.skip(\"PyPy can't serialise big ints\")\n            assert ujson.encode(python_object) == json_string\n            if isinstance(python_object, dict):\n                assert ujson.encode(python_object, sort_keys=True) == json_string\n        else:\n            assert ujson.decode(json_string) == python_object\n\n\n@pytest.mark.parametrize(\n    \"test_input, expected\",\n    [\n        ('{{1337:\"\"}}', ujson.JSONDecodeError),  # broken dict key type leak test\n        ('{{\"key\":\"}', ujson.JSONDecodeError),  # broken dict leak test\n        ('{{\"key\":\"}', ujson.JSONDecodeError),  # broken dict leak test\n        (\"[[[true\", ujson.JSONDecodeError),  # broken list leak test\n    ],\n)\ndef test_decode_range_raises(test_input, expected):\n    for x in range(1000):\n        with pytest.raises(expected):\n            ujson.decode(test_input)\n\n\n@pytest.mark.parametrize(\n    \"test_input, expected\",\n    [\n        (\"fdsa sda v9sa fdsa\", ujson.JSONDecodeError),  # jibberish\n        (\"[\", ujson.JSONDecodeError),  # broken array start\n        (\"{\", ujson.JSONDecodeError),  # broken object start\n        (\"]\", ujson.JSONDecodeError),  # broken array end\n        (\"}\", ujson.JSONDecodeError),  # broken object end\n        ('{\"one\":1,}', ujson.JSONDecodeError),  # object trailing comma fail\n        ('\"TESTING', ujson.JSONDecodeError),  # string unterminated\n        ('\"TESTING\\\\\"', ujson.JSONDecodeError),  # string bad escape\n        (\"tru\", ujson.JSONDecodeError),  # true broken\n        (\"fa\", ujson.JSONDecodeError),  # false broken\n        (\"n\", ujson.JSONDecodeError),  # null broken\n        (\"{{{{31337}}}}\", ujson.JSONDecodeError),  # dict with no key\n        ('{{{{\"key\"}}}}', ujson.JSONDecodeError),  # dict with no colon or value\n        ('{{{{\"key\":}}}}', ujson.JSONDecodeError),  # dict with no value\n        (\"[31337,]\", ujson.JSONDecodeError),  # array trailing comma fail\n        (\"[,31337]\", ujson.JSONDecodeError),  # array leading comma fail\n        (\"[,]\", ujson.JSONDecodeError),  # array only comma fail\n        (\"[]]\", ujson.JSONDecodeError),  # array unmatched bracket fail\n        (\"{}\\n\\t a\", ujson.JSONDecodeError),  # with trailing non whitespaces\n        ('{\"age\", 44}', ujson.JSONDecodeError),  # read bad object syntax\n    ],\n)\ndef test_decode_raises(test_input, expected):\n    with pytest.raises(expected):\n        ujson.decode(test_input)\n\n\n@pytest.mark.parametrize(\n    \"test_input, expected\",\n    [\n        (\"[\", ujson.JSONDecodeError),  # array depth too big\n        (\"{\", ujson.JSONDecodeError),  # object depth too big\n    ],\n)\ndef test_decode_raises_for_long_input(test_input, expected):\n    with pytest.raises(expected):\n        ujson.decode(test_input * (1024 * 1024))\n\n\ndef test_decode_exception_is_value_error():\n    assert issubclass(ujson.JSONDecodeError, ValueError)\n    assert ujson.JSONDecodeError is not ValueError\n\n\n@pytest.mark.parametrize(\n    \"test_input, expected\",\n    [\n        (True, \"true\"),\n        (False, \"false\"),\n        (None, \"null\"),\n        ([True, False, None], \"[true,false,null]\"),\n        ((True, False, None), \"[true,false,null]\"),\n    ],\n)\ndef test_dumps(test_input, expected):\n    assert ujson.dumps(test_input) == expected\n\n\nclass SomeObject:\n    def __init__(self, message, exception=None):\n        self._message = message\n        self._exception = exception\n\n    def __repr__(self):\n        if self._exception:\n            raise self._exception\n        return self._message\n\n\n@pytest.mark.parametrize(\n    \"test_input, expected_exception, expected_message\",\n    [\n        (set(), TypeError, \"set() is not JSON serializable\"),\n        ({1, 2, 3}, TypeError, \"{1, 2, 3} is not JSON serializable\"),\n        (SomeObject(\"Some Object\"), TypeError, \"Some Object is not JSON serializable\"),\n        (SomeObject(\"\\ud800\"), UnicodeEncodeError, None),\n        (SomeObject(None, KeyboardInterrupt), KeyboardInterrupt, None),\n    ],\n)\ndef test_dumps_raises(test_input, expected_exception, expected_message):\n    with pytest.raises(expected_exception) as e:\n        ujson.dumps(test_input)\n    if expected_message:\n        assert str(e.value) == expected_message\n\n\n@pytest.mark.parametrize(\n    \"test_input, expected_exception\",\n    [\n        (float(\"nan\"), OverflowError),\n        (float(\"inf\"), OverflowError),\n        (-float(\"inf\"), OverflowError),\n    ],\n)\ndef test_encode_raises_allow_nan(test_input, expected_exception):\n    with pytest.raises(expected_exception):\n        ujson.dumps(test_input, allow_nan=False)\n\n\ndef test_nan_inf_support():\n    # Test ported from pandas\n    text = '[\"a\", NaN, \"NaN\", Infinity, \"Infinity\", -Infinity, \"-Infinity\"]'\n    data = ujson.loads(text)\n    expected = [\n        \"a\",\n        float(\"nan\"),\n        \"NaN\",\n        float(\"inf\"),\n        \"Infinity\",\n        -float(\"inf\"),\n        \"-Infinity\",\n    ]\n    for a, b in zip(data, expected):\n        assert a == b or math.isnan(a) and math.isnan(b)\n\n\ndef test_special_singletons():\n    pos_inf = ujson.loads(\"Infinity\")\n    neg_inf = ujson.loads(\"-Infinity\")\n    nan = ujson.loads(\"NaN\")\n    null = ujson.loads(\"null\")\n    assert math.isinf(pos_inf) and pos_inf > 0\n    assert math.isinf(neg_inf) and neg_inf < 0\n    assert math.isnan(nan)\n    assert null is None\n\n\n@pytest.mark.parametrize(\n    \"test_input, expected_message\",\n    [\n        (\"n\", \"Unexpected character .* 'null'\"),\n        (\"N\", \"Unexpected character .*'NaN'\"),\n        (\"NA\", \"Unexpected character .* 'NaN'\"),\n        (\"Na N\", \"Unexpected character .* 'NaN'\"),\n        (\"nan\", \"Unexpected character .* 'null'\"),\n        (\"none\", \"Unexpected character .* 'null'\"),\n        (\"i\", \"Expected object or value\"),\n        (\"I\", \"Unexpected character .* 'Infinity'\"),\n        (\"Inf\", \"Unexpected character .* 'Infinity'\"),\n        (\"InfinitY\", \"Unexpected character .* 'Infinity'\"),\n        (\"-i\", \"Trailing data\"),\n        (\"-I\", \"Unexpected character .* '-Infinity'\"),\n        (\"-Inf\", \"Unexpected character .* '-Infinity'\"),\n        (\"-InfinitY\", \"Unexpected character .* '-Infinity'\"),\n        (\"- i\", \"Trailing data\"),\n        (\"- I\", \"Trailing data\"),\n        (\"- Inf\", \"Trailing data\"),\n        (\"- InfinitY\", \"Trailing data\"),\n    ],\n)\ndef test_incomplete_special_inputs(test_input, expected_message):\n    with pytest.raises(ujson.JSONDecodeError, match=expected_message):\n        ujson.loads(test_input)\n\n\n@pytest.mark.parametrize(\n    \"test_input, expected_message\",\n    [\n        (\"NaNaNaN\", \"Trailing data\"),\n        (\"Infinity and Beyond\", \"Trailing data\"),\n        (\"-Infinity-and-Beyond\", \"Trailing data\"),\n        (\"NaN!\", \"Trailing data\"),\n        (\"Infinity!\", \"Trailing data\"),\n        (\"-Infinity!\", \"Trailing data\"),\n    ],\n)\ndef test_overcomplete_special_inputs(test_input, expected_message):\n    with pytest.raises(ujson.JSONDecodeError, match=expected_message):\n        ujson.loads(test_input)\n\n\n@pytest.mark.parametrize(\n    \"test_input\",\n    [\n        {\n            \"key1\": \"value1\",\n            \"key1\": \"value1\",\n            \"key1\": \"value1\",\n            \"key1\": \"value1\",\n            \"key1\": \"value1\",\n            \"key1\": \"value1\",\n        },\n        {\n            \"\u0628\u0646\": \"value1\",\n            \"\u0628\u0646\": \"value1\",\n            \"\u0628\u0646\": \"value1\",\n            \"\u0628\u0646\": \"value1\",\n            \"\u0628\u0646\": \"value1\",\n            \"\u0628\u0646\": \"value1\",\n            \"\u0628\u0646\": \"value1\",\n        },\n    ],\n)\ndef test_encode_no_assert(test_input):\n    ujson.encode(test_input)\n\n\n@pytest.mark.parametrize(\n    \"test_input, expected\",\n    [\n        (1.0, \"1.0\"),\n        (OrderedDict([(1, 1), (0, 0), (8, 8), (2, 2)]), '{\"1\":1,\"0\":0,\"8\":8,\"2\":2}'),\n        ({\"a\": float(\"NaN\")}, '{\"a\":NaN}'),\n        ({\"a\": float(\"inf\")}, '{\"a\":Inf}'),\n        ({\"a\": -float(\"inf\")}, '{\"a\":-Inf}'),\n    ],\n)\ndef test_encode(test_input, expected):\n    assert ujson.encode(test_input) == expected\n\n\n@pytest.mark.parametrize(\n    \"test_input\",\n    [\n        [\n            9223372036854775807,\n            9223372036854775807,\n            9223372036854775807,\n            9223372036854775807,\n            9223372036854775807,\n            9223372036854775807,\n        ],\n        [\n            18446744073709551615,\n            18446744073709551615,\n            18446744073709551615,\n        ],\n    ],\n)\ndef test_encode_list_long_conversion(test_input):\n    output = ujson.encode(test_input)\n    assert test_input == json.loads(output)\n    assert test_input == ujson.decode(output)\n\n\n@pytest.mark.parametrize(\n    \"test_input\",\n    [\n        9223372036854775807,\n        18446744073709551615,\n    ],\n)\ndef test_encode_long_conversion(test_input):\n    output = ujson.encode(test_input)\n\n    assert test_input == json.loads(output)\n    assert output == json.dumps(test_input)\n    assert test_input == ujson.decode(output)\n\n\n@pytest.mark.parametrize(\n    \"test_input\",\n    [\n        [[[[]]]],\n        31337,\n        -31337,\n        None,\n        True,\n        False,\n    ],\n)\ndef test_encode_decode(test_input):\n    output = ujson.encode(test_input)\n\n    assert test_input == json.loads(output)\n    assert output == json.dumps(test_input)\n    assert test_input == ujson.decode(output)\n\n\n@pytest.mark.parametrize(\n    \"test_input\",\n    [\n        \"R\u00e4ksm\u00f6rg\u00e5s \u0627\u0633\u0627\u0645\u0629 \u0628\u0646 \u0645\u062d\u0645\u062f \u0628\u0646 \u0639\u0648\u0636 \u0628\u0646 \u0644\u0627\u062f\u0646\",\n        \"\\xe6\\x97\\xa5\\xd1\\x88\",\n        \"\\xf0\\x90\\x8d\\x86\",  # surrogate pair\n        \"\\xf0\\x91\\x80\\xb0TRAILINGNORMAL\",  # 4 bytes UTF8\n        \"\\xf3\\xbf\\xbf\\xbfTRAILINGNORMAL\",  # 4 bytes UTF8 highest\n    ],\n)\ndef test_encode_unicode(test_input):\n    enc = ujson.encode(test_input)\n    dec = ujson.decode(enc)\n\n    assert enc == json.dumps(test_input)\n    assert dec == json.loads(enc)\n\n\n@pytest.mark.parametrize(\n    \"test_input, expected\",\n    [\n        (\"-1.1234567893\", -1.1234567893),\n        (\"-1.234567893\", -1.234567893),\n        (\"-1.34567893\", -1.34567893),\n        (\"-1.4567893\", -1.4567893),\n        (\"-1.567893\", -1.567893),\n        (\"-1.67893\", -1.67893),\n        (\"-1.7893\", -1.7893),\n        (\"-1.893\", -1.893),\n        (\"-1.3\", -1.3),\n        (\"1.1234567893\", 1.1234567893),\n        (\"1.234567893\", 1.234567893),\n        (\"1.34567893\", 1.34567893),\n        (\"1.4567893\", 1.4567893),\n        (\"1.567893\", 1.567893),\n        (\"1.67893\", 1.67893),\n        (\"1.7893\", 1.7893),\n        (\"1.893\", 1.893),\n        (\"1.3\", 1.3),\n        (\"true\", True),\n        (\"false\", False),\n        (\"null\", None),\n        (\" [ true, false,null] \", [True, False, None]),\n    ],\n)\ndef test_loads(test_input, expected):\n    assert ujson.loads(test_input) == expected\n\n\ndef test_reject_bytes_default():\n    data = {\"a\": b\"b\"}\n    with pytest.raises(TypeError):\n        ujson.dumps(data)\n\n\ndef test_reject_bytes_true():\n    data = {\"a\": b\"b\"}\n    with pytest.raises(TypeError):\n        ujson.dumps(data, reject_bytes=True)\n\n\ndef test_reject_bytes_false():\n    data = {\"a\": b\"b\"}\n    assert ujson.dumps(data, reject_bytes=False) == '{\"a\":\"b\"}'\n\n\ndef test_encode_none_key():\n    data = {None: None}\n    assert ujson.dumps(data) == '{\"null\":null}'\n\n\ndef test_default_function():\n    iso8601_time_format = \"%Y-%m-%dT%H:%M:%S.%f\"\n\n    class CustomObject:\n        pass\n\n    class UnjsonableObject:\n        pass\n\n    def default(value):\n        if isinstance(value, dt.datetime):\n            return value.strftime(iso8601_time_format)\n        elif isinstance(value, uuid.UUID):\n            return value.hex\n        elif isinstance(value, CustomObject):\n            raise ValueError(\"invalid value\")\n        return value\n\n    now = dt.datetime.now()\n    expected_output = '\"%s\"' % now.strftime(iso8601_time_format)\n    assert ujson.dumps(now, default=default) == expected_output\n\n    uuid4 = uuid.uuid4()\n    expected_output = '\"%s\"' % uuid4.hex\n    assert ujson.dumps(uuid4, default=default) == expected_output\n\n    custom_obj = CustomObject()\n    with pytest.raises(ValueError, match=\"invalid value\"):\n        ujson.dumps(custom_obj, default=default)\n\n    unjsonable_obj = UnjsonableObject()\n    with pytest.raises(TypeError, match=\"maximum recursion depth exceeded\"):\n        ujson.dumps(unjsonable_obj, default=default)\n\n\n@pytest.mark.parametrize(\"indent\", list(range(65537, 65542)))\ndef test_dump_huge_indent(indent):\n    ujson.encode({\"a\": True}, indent=indent)\n\n\n@pytest.mark.parametrize(\"first_length\", list(range(2, 7)))\n@pytest.mark.parametrize(\"second_length\", list(range(10919, 10924)))\ndef test_dump_long_string(first_length, second_length):\n    ujson.dumps([\"a\" * first_length, \"\\x00\" * second_length])\n\n\ndef test_dump_indented_nested_list():\n    a = _a = []\n    for i in range(20):\n        _a.append(list(range(i)))\n        _a = _a[-1]\n        ujson.dumps(a, indent=i)\n\n\n@pytest.mark.parametrize(\"indent\", [0, 1, 2, 4, 5, 8, 49])\ndef test_issue_334(indent):\n    path = Path(__file__).with_name(\"334-reproducer.json\")\n    a = ujson.loads(path.read_bytes())\n    ujson.dumps(a, indent=indent)\n\n\n@pytest.mark.skipif(\n    hasattr(sys, \"pypy_version_info\"), reason=\"PyPy uses incompatible GC\"\n)\ndef test_default_ref_counting():\n    class DefaultRefCountingClass:\n        def __init__(self, value):\n            self._value = value\n\n        def convert(self):\n            if self._value > 1:\n                return type(self)(self._value - 1)\n            return 0\n\n    import gc\n\n    gc.collect()\n    ujson.dumps(DefaultRefCountingClass(3), default=lambda x: x.convert())\n    assert not any(\n        type(o).__name__ == \"DefaultRefCountingClass\" for o in gc.get_objects()\n    )\n\n\n@pytest.mark.parametrize(\"sort_keys\", [False, True])\ndef test_obj_str_exception(sort_keys):\n    class Obj:\n        def __str__(self):\n            raise NotImplementedError\n\n    with pytest.raises(NotImplementedError):\n        ujson.dumps({Obj(): 1}, sort_keys=sort_keys)\n\n\ndef no_memory_leak(func_code, n=None):\n    code = f\"import functools, ujson; func = {func_code}\"\n    path = os.path.join(os.path.dirname(__file__), \"memory.py\")\n    n = [str(n)] if n is not None else []\n    p = subprocess.run([sys.executable, path, code] + n)\n    assert p.returncode == 0\n\n\n@pytest.mark.skipif(\n    hasattr(sys, \"pypy_version_info\"), reason=\"PyPy uses incompatible GC\"\n)\n@pytest.mark.parametrize(\"input\", ['[\"a\" * 11000, b\"\"]'])\ndef test_no_memory_leak_encoding_errors(input):\n    no_memory_leak(f\"functools.partial(ujson.dumps, {input})\")\n\n\n\"\"\"\ndef test_decode_numeric_int_frc_overflow():\ninput = \"X.Y\"\nraise NotImplementedError(\"Implement this test!\")\n\n\ndef test_decode_string_unicode_escape():\ninput = \"\\u3131\"\nraise NotImplementedError(\"Implement this test!\")\n\ndef test_decode_string_unicode_broken_escape():\ninput = \"\\u3131\"\nraise NotImplementedError(\"Implement this test!\")\n\ndef test_decode_string_unicode_invalid_escape():\ninput = \"\\u3131\"\nraise NotImplementedError(\"Implement this test!\")\n\ndef test_decode_string_utf8():\ninput = \"someutfcharacters\"\nraise NotImplementedError(\"Implement this test!\")\n\n\"\"\"\n\n\"\"\"\n# Use this to look for memory leaks\nif __name__ == '__main__':\n    import unittest\n    from guppy import hpy\n    hp = hpy()\n    hp.setrelheap()\n    while True:\n        try:\n            unittest.main()\n        except SystemExit:\n            pass\n        heap = hp.heapu()\n        print(heap)\n\"\"\"\n"], "filenames": ["lib/ultrajson.h", "lib/ultrajsondec.c", "python/JSONtoObj.c", "tests/test_ujson.py"], "buggy_code_start_loc": [57, 44, 62, 1], "buggy_code_end_loc": [322, 821, 65, 550], "fixing_code_start_loc": [56, 43, 62, 0], "fixing_code_end_loc": [321, 801, 74, 540], "type": "CWE-670", "message": "UltraJSON is a fast JSON encoder and decoder written in pure C with bindings for Python 3.7+. Affected versions were found to improperly decode certain characters. JSON strings that contain escaped surrogate characters not part of a proper surrogate pair were decoded incorrectly. Besides corrupting strings, this allowed for potential key confusion and value overwriting in dictionaries. All users parsing JSON from untrusted sources are vulnerable. From version 5.4.0, UltraJSON decodes lone surrogates in the same way as the standard library's `json` module does, preserving them in the parsed output. Users are advised to upgrade. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-31116", "sourceIdentifier": "security-advisories@github.com", "published": "2022-07-05T18:15:08.023", "lastModified": "2022-11-05T03:08:19.590", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "UltraJSON is a fast JSON encoder and decoder written in pure C with bindings for Python 3.7+. Affected versions were found to improperly decode certain characters. JSON strings that contain escaped surrogate characters not part of a proper surrogate pair were decoded incorrectly. Besides corrupting strings, this allowed for potential key confusion and value overwriting in dictionaries. All users parsing JSON from untrusted sources are vulnerable. From version 5.4.0, UltraJSON decodes lone surrogates in the same way as the standard library's `json` module does, preserving them in the parsed output. Users are advised to upgrade. There are no known workarounds for this issue."}, {"lang": "es", "value": "UltraJSON es un codificador y decodificador JSON r\u00e1pido escrito en C puro con enlaces para Python versiones 3.7+.&#xa0;Se encontr\u00f3 que las versiones afectadas descodificaban incorrectamente determinados caracteres.&#xa0;Las cadenas JSON que contienen caracteres suplentes escapados que no forman parte de un par suplente adecuado se decodificaron incorrectamente.&#xa0;Adem\u00e1s de corromper las cadenas, esto permiti\u00f3 una posible confusi\u00f3n de claves y sobrescritura de valores en los diccionarios.&#xa0;Todos los usuarios que analizan JSON de fuentes que no son de confianza son vulnerables.&#xa0;A partir de la versi\u00f3n 5.4.0, UltraJSON decodifica sustitutos solitarios de la misma manera que lo hace el m\u00f3dulo \"json\" de la biblioteca est\u00e1ndar, conserv\u00e1ndolos en la salida analizada.&#xa0;Se recomienda a los usuarios que actualicen.&#xa0;No se conocen mitigaciones adicionales para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-670"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ultrajson_project:ultrajson:*:*:*:*:*:python:*:*", "versionEndExcluding": "5.4.0", "matchCriteriaId": "85A0E25D-E50B-4669-A1F2-1BAAEC9DFE16"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/ultrajson/ultrajson/commit/67ec07183342589d602e0fcf7bb1ff3e19272687", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ultrajson/ultrajson/security/advisories/GHSA-wpqr-jcpx-745r", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/NAU5N4A7EUK2AMUCOLYDD5ARXAJYZBD2/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/OPPU5FZP3LCTXYORFH7NHUMYA5X66IA7/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ultrajson/ultrajson/commit/67ec07183342589d602e0fcf7bb1ff3e19272687"}}