{"buggy_code": ["# -*- Autoconf -*-\n#\n# Top-level configure.ac file for libupnp\n#\n# Process this file with autoconf to produce a configure script.\n#\n# (C) Copyright 2005-2007 R\u00e9mi Turboult <r3mi@users.sourceforge.net>\n#\n\nAC_PREREQ(2.60)\n\nAC_INIT([libupnp], [1.8.0], [mroberto@users.sourceforge.net])\ndnl ############################################################################\ndnl # *Independently* of the above libupnp package version, the libtool version\ndnl # of the 3 libraries need to be updated whenever there is a change released:\ndnl # \"current:revision:age\" (this is NOT the same as the package version),\ndnl # where:\ndnl # \t- library code modified:\t\trevision++\ndnl # \t- interfaces changed/added/removed:\tcurrent++ and revision=0\ndnl # \t- interfaces added: \t\t\tage++\ndnl # \t- interfaces removed:\t\t\tage=0\ndnl # *please update only once, before a formal release, not for each change*\ndnl #\ndnl ############################################################################\ndnl # Release 1.4.1:\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:2:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [2:2:0])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [2:2:0])\ndnl #\ndnl ############################################################################\ndnl # Release 1.4.6:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in ixml\ndnl #\trevision: 2 -> 3\ndnl # - Code has changed in threadutil\ndnl #\trevision: 2 -> 3\ndnl # - Interface added in threadutil\ndnl #\tcurrent: 2 -> 3\ndnl #\trevisiion: 3 -> 0\ndnl #\tage: 0 -> 1\ndnl # - Code has changed in upnp\ndnl #\trevision: 2 -> 3\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:3:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [3:0:1])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [2:3:0])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.0:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in ixml\ndnl #\trevision: 3 -> 4\ndnl # - Code has changed in threadutil\ndnl #\trevision: 0 -> 1\ndnl # - Code has changed in upnp\ndnl #\trevision: 3 -> 4\ndnl # - Interface changed in upnp\ndnl #\tcurrent: 2 -> 3\ndnl #\trevision: 4 -> 0\ndnl # - Interface removed in upnp\ndnl #\tage: 0 -> 0\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:4:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [3:1:1])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [3:0:0])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.1:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in threadutil\ndnl #\trevision: 1 -> 2\ndnl # - Interface added in threadutil\ndnl #\tcurrent: 3 -> 4\ndnl #\trevision: 2 -> 0\ndnl # - Interface added in threadutil\ndnl #\tage: 1 -> 2\ndnl # - Code has changed in upnp\ndnl #\trevision: 0 -> 1\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:4:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [4:0:2])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [3:1:0])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.2:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in upnp\ndnl #\trevision: 1 -> 2\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:4:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [4:0:2])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [3:2:0])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.3:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in threadutil\ndnl #\trevision: 0 -> 1\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:4:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [4:1:2])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [3:2:0])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.4:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in threadutil\ndnl #\trevision: 1 -> 2\ndnl # - Code has changed in upnp\ndnl #\trevision: 2 -> 3\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:4:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [4:2:2])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [3:3:0])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.5:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in upnp\ndnl #\trevision: 3 -> 4\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:4:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [4:2:2])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [3:4:0])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.6:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in threadutil\ndnl #\trevision: 2 -> 3\ndnl # - Code has changed in upnp\ndnl #\trevision: 4 -> 5\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:4:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [4:3:2])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [3:5:0])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.7:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in threadutil\ndnl #\trevision: 3 -> 4\ndnl # - Code has changed in upnp\ndnl #\trevision: 5 -> 6\ndnl # - Interfaces have been changed, added and removed in upnp\ndnl #\tcurrent: 3 -> 4\ndnl #   revision: 6 -> 0\ndnl # - Interfaces removed in upnp:\ndnl #   age: -> 0\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:4:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [5:0:2])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [3:5:0])\ndnl #\ndnl # Obs.: 1.6.7 was released with a version error, the correct nubers should\ndnl # have been:\ndnl #AC_SUBST([LT_VERSION_UPNP],       [4:0:0])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.8:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in ixml\ndnl #\trevision: 4 -> 5\ndnl # - Code has changed in threadutil\ndnl #\trevision: 0 -> 1\ndnl # - Code has changed in upnp\ndnl #\trevision: 0 -> 1\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:5:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [5:1:2])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [4:1:0])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.9:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in threadutil\ndnl #\trevision: 1 -> 2\ndnl # - Code has changed in upnp\ndnl #\trevision: 1 -> 2\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:5:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [5:2:2])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [4:2:0])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.10:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in ixml \ndnl #\trevision: 5 -> 6\ndnl # - Code has changed in threadutil\ndnl #\trevision: 2 -> 3\ndnl # - Code has changed in upnp\ndnl #\trevision: 2 -> 3\ndnl # - interface has changed in upnp\ndnl #   current: 4 -> 5\ndnl #   revision: 3 -> 0\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:6:0])\ndnl ############################################################################\ndnl # Release 1.6.11:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in threadutil\ndnl #\trevision: 3 -> 4\ndnl # - Code has changed in upnp\ndnl #\trevision: 3 -> 4\ndnl # - interface has changed in upnp\ndnl #   current: 5 -> 6\ndnl #   revision: 4 -> 0\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:6:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [5:4:2])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [6:0:0])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.12:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - interface added in threadutil\ndnl #   current: 5 -> 6\ndnl #   revision: 4 - > 0\ndnl #   age: 2 -> 3\ndnl # - interfaces removed in threadutil\ndnl #   age: 3 -> 0\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:6:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [6:0:0])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [6:0:0])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.13:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in upnp\ndnl #\trevision: 0 -> 1\ndnl # - interface added in upnp\ndnl #   current: 6 -> 7\ndnl #   revision: 1 - > 0\ndnl #   age: 0 -> 1\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:6:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [6:0:0])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [7:0:1])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.14:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in upnp\ndnl #\trevision: 0 -> 1\ndnl # - interface added in upnp\ndnl #   current: 7 -> 8\ndnl #   revision: 1 - > 0\ndnl #   age: 1 -> 2\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:6:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [6:0:0])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [8:0:2])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.15:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in upnp\ndnl #\trevision: 0 -> 1\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:6:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [6:0:0])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [8:1:2])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.16:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in ixml\ndnl #\trevision: 6 -> 7\ndnl # - Code has changed in threadutil\ndnl #   revision: 0 -> 1\ndnl # - Code has changed in upnp\ndnl #\trevision: 1 -> 2\ndnl # - interface changed/added/removed in upnp\ndnl #   current++(9); revision = 0\ndnl # - interface added in upnp\ndnl #   age++(3)\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:7:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [6:1:0])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [9:0:3])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.17:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in threadutil\ndnl #   revision: 1 -> 2\ndnl # - Code has changed in upnp\ndnl #   revision: 0 -> 1\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:7:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [6:2:0])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [9:1:3])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.18:\ndnl # \"current:revision:age\"\ndnl #\ndnl # -\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [::])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [::])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [::])\ndnl #\ndnl ############################################################################\ndnl # Release 1.8.0:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Start from a new ground.\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [10:0:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [10:0:0])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [10:0:0])\ndnl #\ndnl ############################################################################\nAC_SUBST([LT_VERSION_IXML],       [10:0:0])\nAC_SUBST([LT_VERSION_THREADUTIL], [10:0:0])\nAC_SUBST([LT_VERSION_UPNP],       [10:0:0])\ndnl ############################################################################\ndnl # Repeating the algorithm to place it closer to the modificatin place:\ndnl # \t- library code modified:\t\trevision++\ndnl # \t- interfaces changed/added/removed:\tcurrent++ and revision=0\ndnl # \t- interfaces added: \t\t\tage++\ndnl # \t- interfaces removed:\t\t\tage=0\ndnl # *please update only once, before a formal release, not for each change*\ndnl ############################################################################\n\n\nAC_CONFIG_AUX_DIR([build-aux])\nAC_CONFIG_MACRO_DIR([m4])\nAC_CONFIG_SRCDIR([upnp/inc/upnp.h])\n\n\nAM_INIT_AUTOMAKE([1.8 -Wall foreign subdir-objects dist-bzip2])\n\n\n#\n# Get canonical host names in host and host_os\n#\nAC_CANONICAL_HOST\n\n#\n# There are 3 configuration files :\n# 1) \"./autoconfig.h\" is auto-generated and used only internally during build\n#    (usually named \"config.h\" but conflicts with the file below)\n# 2) \"./upnp/src/inc/config.h\" is static and contains some compile-time \n#    parameters. This file was previously in \"./upnp/inc\" but is no longer \n#    installed (contains internal definitions only).\n# 3) \"./upnp/inc/upnpconfig.h\" is auto-generated and installed with the \n#    libraries : it contains information on the configuration of the\n#    installed libraries.\n#\nAC_CONFIG_HEADERS([autoconfig.h upnp/inc/upnpconfig.h])\n#AC_SYS_LARGEFILE_SENSITIVE\n\nAC_REVISION([$Revision: 1.11 $])\n\nupnpmaj=`echo \"$PACKAGE_VERSION\" | sed 's/\\..*//' `\nupnpmin=[`echo \"$PACKAGE_VERSION\" | sed 's/^[^.]\\.// ; s/[^0-9].*$//' `]\nupnppatch=[`echo \"$PACKAGE_VERSION\" | sed 's/^[^.]\\.[^.]\\.// ; s/[^0-9].*$//' `]\nAC_DEFINE_UNQUOTED([UPNP_VERSION_STRING], \"$PACKAGE_VERSION\", [see upnpconfig.h])\nAC_DEFINE_UNQUOTED([UPNP_VERSION_MAJOR], $upnpmaj, [see upnpconfig.h])\nAC_DEFINE_UNQUOTED([UPNP_VERSION_MINOR], $upnpmin, [see upnpconfig.h])\nAC_DEFINE_UNQUOTED([UPNP_VERSION_PATCH], $upnppatch, [see upnpconfig.h])\n\n\n#\n# Check for DEBUG flag\n#\nRT_BOOL_ARG_ENABLE([debug], [no], [extra debugging code])\nif test \"x$enable_debug\" = xyes ; then\n\tAC_DEFINE(UPNP_HAVE_DEBUG, 1, [see upnpconfig.h])\n\tAC_DEFINE(DEBUG, 1, [Define to 1 to compile debug code])\nelse\n\tAC_DEFINE(NO_DEBUG, 1, [Define to 1 to prevent some debug code])\n\tAC_DEFINE(NDEBUG, 1, [Define to 1 to prevent compilation of assert()])\nfi\n\n\n#\n# Check for libupnp subsets\n#\nRT_BOOL_ARG_ENABLE([client], [yes], [control point code (client)])\nif test \"x$enable_client\" = xyes ; then\n\tAC_DEFINE(UPNP_HAVE_CLIENT, 1, [see upnpconfig.h])\nfi\n\n\nRT_BOOL_ARG_ENABLE([device], [yes],\n     [device specific code (implies --disable-webserver if disabled)])\nif test \"x$enable_device\" = xyes ; then\n\tAC_DEFINE(UPNP_HAVE_DEVICE, 1, [see upnpconfig.h])\nfi\n\n\nif test \"x$enable_device\" = xno ; then \n\tenable_webserver=no\nelse \n\tRT_BOOL_ARG_ENABLE([webserver], [yes], [integrated web server])\nfi\nAM_CONDITIONAL(ENABLE_WEBSERVER, test x\"$enable_webserver\" = xyes)\nif test \"x$enable_webserver\" = xyes ; then\n\tAC_DEFINE(UPNP_HAVE_WEBSERVER, 1, [see upnpconfig.h])\nfi\n\nRT_BOOL_ARG_ENABLE([ssdp], [yes], [SSDP part])\nif test \"x$enable_ssdp\" = xyes ; then\n        AC_DEFINE(UPNP_HAVE_SSDP, 1, [see upnpconfig.h])\nfi\n\nRT_BOOL_ARG_ENABLE([optssdp], [yes], [optionnal SSDP headers support)])\nif test \"x$enable_optssdp\" = xyes ; then\n        AC_DEFINE(UPNP_HAVE_OPTSSDP, 1, [see upnpconfig.h])\n\tenable_uuid=yes\nfi\n\nRT_BOOL_ARG_ENABLE([soap], [yes], [SOAP part])\nif test \"x$enable_soap\" = xyes ; then\n        AC_DEFINE(UPNP_HAVE_SOAP, 1, [see upnpconfig.h])\nfi\n\nRT_BOOL_ARG_ENABLE([gena], [yes], [GENA part])\nif test \"x$enable_gena\" = xyes ; then\n        AC_DEFINE(UPNP_HAVE_GENA, 1, [see upnpconfig.h])\n\tenable_uuid=yes\nfi\n\nAM_CONDITIONAL(ENABLE_UUID, test x\"$enable_uuid\" = xyes)\n\nRT_BOOL_ARG_ENABLE([tools], [yes], [helper APIs in upnptools.h])\nif test \"x$enable_tools\" = xyes ; then\n\tAC_DEFINE(UPNP_HAVE_TOOLS, 1, [see upnpconfig.h])\nfi\n\nRT_BOOL_ARG_ENABLE([ipv6], [no], [ipv6 support])\nif test \"x$enable_ipv6\" = xyes ; then\n        AC_DEFINE(UPNP_ENABLE_IPV6, 1, [see upnpconfig.h])\nfi\n\nRT_BOOL_ARG_ENABLE([unspecified_server], [no], [unspecified SERVER header])\nif test \"x$enable_unspecified_server\" = xyes ; then\n        AC_DEFINE(UPNP_ENABLE_UNSPECIFIED_SERVER, 1, [see upnpconfig.h])\nfi\n\nRT_BOOL_ARG_ENABLE([open_ssl], [no], [open-ssl support])\nif test \"x$enable_open_ssl\" = xyes ; then\n        AC_DEFINE(UPNP_ENABLE_OPEN_SSL, 1, [see upnpconfig.h])\nfi\n\nRT_BOOL_ARG_ENABLE([notification_reordering], [yes], [GENA notification reordering in gena_device.c])\nif test \"x$enable_notification_reordering\" = xyes ; then\n        AC_DEFINE(UPNP_ENABLE_NOTIFICATION_REORDERING, 1, [see upnpconfig.h])\nfi\n\nRT_BOOL_ARG_ENABLE([blocking_tcp_connections], [yes], [blocking TCP connections])\nif test \"x$enable_blocking_tcp_connections\" = xyes ; then\n        AC_DEFINE(UPNP_ENABLE_BLOCKING_TCP_CONNECTIONS, 1, [see upnpconfig.h])\nfi\n\nRT_BOOL_ARG_ENABLE([scriptsupport], [yes], [script support for IXML document tree, see ixml.h])\nif test \"x$enable_scriptsupport\" = xyes ; then\n        AC_DEFINE(IXML_HAVE_SCRIPTSUPPORT, 1, [see upnpconfig.h])\nfi\n\n\nRT_BOOL_ARG_ENABLE([samples], [yes], [compilation of upnp/sample/ code])\n\n\n#\n# doc installation\n# autoconf >= 2.60 already defines ${docdir}, but we will not use its \n# default value, which is ${datarootdir}/doc/${PACKAGE_TARNAME}.\n# That would give us ${datarootdir}/doc/libupnp, and we want the package\n# version on that.\n#\ndocdir=\"${datadir}/doc/${PACKAGE_NAME}-${PACKAGE_VERSION}\"\nAC_MSG_CHECKING([for documentation directory])\nAC_ARG_WITH(\n\t[documentation], \n\tAS_HELP_STRING(\n\t\t[--with-documentation=directory_name],\n\t\t[where documentation is installed \n\t\t @<:@[DATADIR/doc/]AC_PACKAGE_NAME[-]AC_PACKAGE_VERSION@:>@])\nAS_HELP_STRING(\n\t\t[--without-documentation],\n\t\t[do not install the documentation]),\n\t[],\n\t[with_documentation=no])\n\n#\n# If something has been entered after an equal sign, assume it is the directory\n#\nif test x\"$with_documentation\" != xyes -a x\"$with_documentation\" != xno; then\n\tdocdir=\"$with_documentation\"\nfi\nAM_CONDITIONAL(WITH_DOCUMENTATION, test x\"$with_documentation\" != xno)\nAC_SUBST(docdir)\nAC_MSG_RESULT($docdir)\n\n\n#\n# Checks for programs\n#\nAC_PROG_CC\nAM_PROG_CC_C_O\nm4_ifdef([AM_PROG_AR], [AM_PROG_AR])\nAC_PROG_LIBTOOL\nAC_PROG_INSTALL\nAC_PROG_MAKE_SET\nAC_PROG_EGREP\n\n#\n# Default compilation flags\n#\necho \"--------------------- Default compilation flags -------------------------------\"\necho host is $host\necho host_os is $host_os\ncase $host_os in\nfreebsd*)\n\techo \"Using FreeBSD specific compiler settings\"\n\t# Put FreeBSD specific compiler flags here\n\t;;\n*)\n\techo \"Using non-specific system compiler settings\"\n\tif test x\"$enable_debug\" = xyes; then\n\t\t# AC_PROG_CC already sets CFLAGS to \"-g -O2\" by default,\n\t\t# but only if CFLAGS was not previously set.\n\t\t#:\n\t\t# Use -O0 in debug so that variables do not get optimized out\n\t\tAX_CFLAGS_GCC_OPTION([-O0, -g])\n\telse\n\t\t# add optimise for size\n\t\tAX_CFLAGS_GCC_OPTION([-Os])\n\tfi\n\t;;\nesac\n\nAX_CFLAGS_WARN_ALL\necho \"-------------------------------------------------------------------------------\"\n\n\n#\n# Lot's of stuff to ensure large file support\n#\nAC_TYPE_SIZE_T\nAC_TYPE_OFF_T\nAC_DEFINE([_LARGE_FILE_SOURCE], [], [Large files support])\nAC_DEFINE([_FILE_OFFSET_BITS], [64], [File Offset size])\n\n\n#\n# Are we targetting Win32?\n#\nAC_MSG_CHECKING([for Win32])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([\n#ifdef WIN32\n\t#error Yup\n#endif\n],[])], [ac_cv_win32=\"no\"], [ac_cv_win32=\"yes\"])\nif test \"$ac_cv_win32\" = \"yes\"; then\n\tAC_MSG_RESULT([yes])\nelse\n\tAC_MSG_RESULT([no])\nfi\n\n\n#\n# Checks for header files (which aren't needed on Win32)\n#\nAC_HEADER_STDC\nif test \"$ac_cv_win32\" = \"no\"; then\n# libupnp code doesn't use autoconf variables yet,\n# so just abort if a header file is not found.\nAC_CHECK_HEADERS(\n\t[ \\\n\tarpa/inet.h \\\n\tfcntl.h \\\n\tinttypes.h \\\n\tlimits.h \\\n\tnetdb.h \\\n\tnetinet/in.h \\\n\tstdlib.h \\\n\tstring.h \\\n\tsys/ioctl.h \\\n\tsys/socket.h \\\n\tsys/time.h \\\n\tsyslog.h \\\n\tunistd.h \\\n\t],\n\t[],\n\t[AC_MSG_ERROR([required header file missing])])\nfi\n\n\n#\n# Checks for typedefs, structures, and compiler characteristics\n#\t\nAC_C_CONST\n\n# The test for socklen_t was getting it wrong when it exists but is in ws2tcpip.h,\n# so we use a new test.\n#TYPE_SOCKLEN_T\n\nAC_CHECK_HEADERS([sys/types.h sys/socket.h ws2tcpip.h])\nAC_MSG_CHECKING(for socklen_t)\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([\n#ifdef HAVE_SYS_TYPES_H\n\t#include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_SOCKET_H\n\t#include <sys/socket.h>\n#endif\n#ifdef HAVE_WS2TCPIP_H\n\t#include <ws2tcpip.h>\n#endif\n],[ socklen_t t = 0; return t; ])\n],[ac_cv_socklen_t=\"yes\"],[ac_cv_socklen_t=\"no\"])\nif test \"$ac_cv_socklen_t\" = \"yes\"; then\n\tAC_MSG_RESULT([yes])\nelse\n\tAC_MSG_RESULT([no, using int])\n\tAC_DEFINE(socklen_t, int, [Type for storing the length of struct sockaddr])\nfi\n\n\n#\n# Checks for library functions\n#\nAC_FUNC_VPRINTF\nAC_FUNC_FSEEKO\nAC_CHECK_FUNC(strnlen,\n\tAC_DEFINE(HAVE_STRNLEN, 1, [Defines if strnlen is available on your system]))\nAC_CHECK_FUNC(strndup,\n\tAC_DEFINE(HAVE_STRNDUP, 1, [Defines if strndup is available on your system]))\n#\n# Solaris needs -lsocket -lnsl -lrt\nAC_SEARCH_LIBS([bind],           [socket])\nAC_SEARCH_LIBS([gethostbyname],  [nsl])\nAC_SEARCH_LIBS([sched_getparam], [rt])\n\n\n#\n# Checks for POSIX Threads\n#\necho \"--------------------------- pthread stuff -------------------------------------\"\nACX_PTHREAD(\n\t[],\n\t[AC_MSG_ERROR([POSIX threads are required to build this program])])\n#\n# Update environment variables for pthreads\n#\nCC=\"$PTHREAD_CC\"\nCFLAGS=\"$PTHREAD_CFLAGS $CFLAGS\"\nLIBS=\"$PTHREAD_LIBS $LIBS\"\n#\n# Determine if pthread_rwlock_t is available\n#\necho \"----------------------- pthread_rwlock_t stuff --------------------------------\"\nAC_MSG_CHECKING([if pthread_rwlock_t is available])\nAC_LANG([C])\nAC_COMPILE_IFELSE(\n\t[AC_LANG_PROGRAM(\n\t\t[#include <pthread.h>],\n\t\t[pthread_rwlock_t *x;])],\n\t[AC_DEFINE([UPNP_USE_RWLOCK], [1], [Use pthread_rwlock_t])\n\t\tAC_MSG_RESULT([yes, supported without any options])],\n\t[AC_COMPILE_IFELSE(\n\t\t[AC_LANG_PROGRAM(\n\t\t\t[#define _GNU_SOURCE\n\t\t\t#include <pthread.h>],\n\t\t\t[pthread_rwlock_t *x;])],\n\t\t[AC_DEFINE([UPNP_USE_RWLOCK], [1], [Use pthread_rwlock_t])\n\t\t\tCPPFLAGS=\"$CPPFLAGS -D_GNU_SOURCE\"\n\t\t\tAC_MSG_RESULT([yes, definition of _GNU_SOURCE required])],\n\t\t[AC_DEFINE([UPNP_USE_RWLOCK], [0], [Do not use pthread_rwlock_t])\n\t\t\tAC_MSG_RESULT([no, needs to fallback to pthread_mutex])\n\t\t\tAC_MSG_ERROR([pthread_rwlock_t not available])])])\necho \"-------------------------------------------------------------------------------\"\n\n\nAC_CONFIG_FILES([\n\tMakefile\n\tixml/Makefile\n\tixml/doc/Makefile\n\tthreadutil/Makefile\n\tupnp/Makefile\n\tupnp/doc/Makefile\n\tupnp/sample/Makefile\n\tupnp/unittest/Makefile\n\tdocs/dist/Makefile\n\tlibupnp.pc\n\t])\n\n\nAC_OUTPUT\n\n#\n# Files copied for windows compilation.\n#\necho \"configure: copying \\\"autoconfig.h\\\"          to \\\"build/inc/autoconfig.h\\\"\"\ntest -d build/inc || mkdir -p build/inc\ncp autoconfig.h build/inc/autoconfig.h\necho \"configure: copying \\\"upnp/inc/upnpconfig.h\\\" to \\\"build/inc/upnpconfig.h\\\"\"\ncp upnp/inc/upnpconfig.h build/inc/upnpconfig.h\n\n", "/* -*- C -*- */\n/*******************************************************************************\n *\n * Copyright (c) 2006 R\u00e9mi Turboult <r3mi@users.sourceforge.net>\n * All rights reserved. \n *\n * Redistribution and use in source and binary forms, with or without \n * modification, are permitted provided that the following conditions are met: \n *\n * * Redistributions of source code must retain the above copyright notice, \n * this list of conditions and the following disclaimer. \n * * Redistributions in binary form must reproduce the above copyright notice, \n * this list of conditions and the following disclaimer in the documentation \n * and/or other materials provided with the distribution. \n * * Neither name of Intel Corporation nor the names of its contributors \n * may be used to endorse or promote products derived from this software \n * without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR \n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR \n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, \n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, \n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR \n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY \n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS \n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n ******************************************************************************/\n\n#ifndef UPNP_CONFIG_H\n#define UPNP_CONFIG_H \n\n\n/***************************************************************************\n * Library version \n ***************************************************************************/ \n\n/** The library version (string) e.g. \"1.3.0\" */\n#undef UPNP_VERSION_STRING\n\n/** Major version of the library */\n#undef UPNP_VERSION_MAJOR\n\n/** Minor version of the library */\n#undef UPNP_VERSION_MINOR\n\n/** Patch version of the library */\n#undef UPNP_VERSION_PATCH\n\n/** The library version (numeric) e.g. 10300 means version 1.3.0 */\n#define UPNP_VERSION\t\\\n  ((UPNP_VERSION_MAJOR * 100 + UPNP_VERSION_MINOR) * 100 + UPNP_VERSION_PATCH)\n\n\n\n/***************************************************************************\n * Large file support\n ***************************************************************************/\n\n/** File Offset size */\n#undef _FILE_OFFSET_BITS\n\n/** Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */\n#undef _LARGEFILE_SOURCE\n\n/** Large files support */\n#undef _LARGE_FILE_SOURCE\n\n/***************************************************************************\n * Library optional features\n ***************************************************************************/\n\n/*\n * The following defines can be tested in order to know which \n * optional features have been included in the installed library.\n */\n\n\n/** Defined to 1 if the library has been compiled with DEBUG enabled \n *  (i.e. configure --enable-debug) : <upnp/upnpdebug.h> file is available */\n#undef UPNP_HAVE_DEBUG\n\n\n/** Defined to 1 if the library has been compiled with client API enabled \n *  (i.e. configure --enable-client) */\n#undef UPNP_HAVE_CLIENT\n\n\n/** Defined to 1 if the library has been compiled with device API enabled \n *  (i.e. configure --enable-device) */\n#undef UPNP_HAVE_DEVICE\n\n\n/** Defined to 1 if the library has been compiled with integrated web server\n *  (i.e. configure --enable-webserver --enable-device) */\n#undef UPNP_HAVE_WEBSERVER\n\n\n/** Defined to 1 if the library has been compiled with the SSDP part enabled\n *  (i.e. configure --enable-ssdp) */\n#undef UPNP_HAVE_SSDP\n\n\n/** Defined to 1 if the library has been compiled with optional SSDP headers\n *  support (i.e. configure --enable-optssdp) */\n#undef UPNP_HAVE_OPTSSDP\n\n\n/** Defined to 1 if the library has been compiled with the SOAP part enabled\n *  (i.e. configure --enable-soap) */\n#undef UPNP_HAVE_SOAP\n\n\n/** Defined to 1 if the library has been compiled with the GENA part enabled\n *  (i.e. configure --enable-gena) */\n#undef UPNP_HAVE_GENA\n\n\n/** Defined to 1 if the library has been compiled with helper API\n *  (i.e. configure --enable-tools) : <upnp/upnptools.h> file is available */\n#undef UPNP_HAVE_TOOLS\n\n/** Defined to 1 if the library has been compiled with ipv6 support\n *  (i.e. configure --enable-ipv6) */\n#undef UPNP_ENABLE_IPV6\n\n/** Defined to 1 if the library has been compiled with unspecified SERVER\n * header (i.e. configure --enable-unspecified_server) */\n#undef UPNP_ENABLE_UNSPECIFIED_SERVER\n\n/** Defined to 1 if the library has been compiled with OpenSSL support\n *  (i.e. configure --enable-open_ssl) */\n#undef UPNP_ENABLE_OPEN_SSL\n\n#endif /* UPNP_CONFIG_H */\n\n", "/**************************************************************************\n *\n * Copyright (c) 2000-2003 Intel Corporation \n * All rights reserved. \n * Copyright (c) 2012 France Telecom All rights reserved. \n *\n * Redistribution and use in source and binary forms, with or without \n * modification, are permitted provided that the following conditions are met: \n *\n * - Redistributions of source code must retain the above copyright notice, \n * this list of conditions and the following disclaimer. \n * - Redistributions in binary form must reproduce the above copyright notice, \n * this list of conditions and the following disclaimer in the documentation \n * and/or other materials provided with the distribution. \n * - Neither name of Intel Corporation nor the names of its contributors \n * may be used to endorse or promote products derived from this software \n * without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR \n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR \n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, \n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, \n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR \n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY \n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS \n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n **************************************************************************/\n\n/*!\n * \\file\n *\n * \\brief Defines the Web Server and has functions to carry out\n * operations of the Web Server.\n */\n\n#include \"config.h\"\n\n#if EXCLUDE_WEB_SERVER == 0\n\n#include \"webserver.h\"\n\n\n#include \"FileInfo.h\"\n#include \"httpparser.h\"\n#include \"httpreadwrite.h\"\n#include \"ithread.h\"\n#include \"membuffer.h\"\n#include \"ssdplib.h\"\n#include \"statcodes.h\"\n#include \"strintmap.h\"\n#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"upnpapi.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpStdInt.h\"\n#include \"upnputil.h\"\n#include \"VirtualDir.h\"\n\n#include <assert.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n\n#ifdef WIN32\n\t #define snprintf _snprintf\n#endif\n\n/*!\n * Response Types.\n */\nenum resp_type {\n\tRESP_FILEDOC,\n\tRESP_XMLDOC,\n\tRESP_HEADERS,\n\tRESP_WEBDOC,\n\tRESP_POST\n};\n\n/* mapping of file extension to content-type of document */\nstruct document_type_t {\n\t/*! . */\n\tconst char *file_ext;\n\t/*! . */\n\tconst char *content_type;\n\t/*! . */\n\tconst char *content_subtype;\n};\n\nstruct xml_alias_t {\n\t/*! name of DOC from root; e.g.: /foo/bar/mydesc.xml */\n\tmembuffer name;\n\t/*! the XML document contents */\n\tmembuffer doc;\n\t/*! . */\n\ttime_t last_modified;\n\t/*! . */\n\tint *ct;\n};\n\nstatic const char *gMediaTypes[] = {\n\t/*! 0. */\n\tNULL,\n\t/*! 1. */\n\t\"audio\",\n\t/*! 2. */\n\t\"video\",\n\t/*! 3. */\n\t\"image\",\n\t/*! 4. */\n\t\"application\",\n\t/*! 5. */\n\t\"text\"\n};\n\n/*\n * Defines.\n */\n\n/* index into 'gMediaTypes' */\n#define AUDIO_STR        \"\\1\"\n#define VIDEO_STR        \"\\2\"\n#define IMAGE_STR        \"\\3\"\n#define APPLICATION_STR  \"\\4\"\n#define TEXT_STR         \"\\5\"\n\n/* int index */\n#define APPLICATION_INDEX 4\n#define TEXT_INDEX        5\n\n/* general */\n#define NUM_MEDIA_TYPES       70\n#define NUM_HTTP_HEADER_NAMES 33\n\n#define ASCTIME_R_BUFFER_SIZE 26\n#ifdef WIN32\nstatic char *web_server_asctime_r(const struct tm *tm, char *buf)\n{\n\tif (tm == NULL || buf == NULL)\n\t\treturn NULL;\n\n\tasctime_s(buf, ASCTIME_R_BUFFER_SIZE, tm);\n\treturn buf;\n}\n#else\n#define web_server_asctime_r asctime_r\n#endif\n\n/* sorted by file extension; must have 'NUM_MEDIA_TYPES' extensions */\nstatic const char *gEncodedMediaTypes =\n\t\"aif\\0\" AUDIO_STR \"aiff\\0\"\n\t\"aifc\\0\" AUDIO_STR \"aiff\\0\"\n\t\"aiff\\0\" AUDIO_STR \"aiff\\0\"\n\t\"asf\\0\" VIDEO_STR \"x-ms-asf\\0\"\n\t\"asx\\0\" VIDEO_STR \"x-ms-asf\\0\"\n\t\"au\\0\" AUDIO_STR \"basic\\0\"\n\t\"avi\\0\" VIDEO_STR \"msvideo\\0\"\n\t\"bmp\\0\" IMAGE_STR \"bmp\\0\"\n\t\"css\\0\" TEXT_STR \"css\\0\"\n\t\"dcr\\0\" APPLICATION_STR \"x-director\\0\"\n\t\"dib\\0\" IMAGE_STR \"bmp\\0\"\n\t\"dir\\0\" APPLICATION_STR \"x-director\\0\"\n\t\"dxr\\0\" APPLICATION_STR \"x-director\\0\"\n\t\"gif\\0\" IMAGE_STR \"gif\\0\"\n\t\"hta\\0\" TEXT_STR \"hta\\0\"\n\t\"htm\\0\" TEXT_STR \"html\\0\"\n\t\"html\\0\" TEXT_STR \"html\\0\"\n\t\"jar\\0\" APPLICATION_STR \"java-archive\\0\"\n\t\"jfif\\0\" IMAGE_STR \"pjpeg\\0\"\n\t\"jpe\\0\" IMAGE_STR \"jpeg\\0\"\n\t\"jpeg\\0\" IMAGE_STR \"jpeg\\0\"\n\t\"jpg\\0\" IMAGE_STR \"jpeg\\0\"\n\t\"js\\0\" APPLICATION_STR \"x-javascript\\0\"\n\t\"kar\\0\" AUDIO_STR \"midi\\0\"\n\t\"m3u\\0\" AUDIO_STR \"mpegurl\\0\"\n\t\"mid\\0\" AUDIO_STR \"midi\\0\"\n\t\"midi\\0\" AUDIO_STR \"midi\\0\"\n\t\"mov\\0\" VIDEO_STR \"quicktime\\0\"\n\t\"mp2v\\0\" VIDEO_STR \"x-mpeg2\\0\"\n\t\"mp3\\0\" AUDIO_STR \"mpeg\\0\"\n\t\"mpe\\0\" VIDEO_STR \"mpeg\\0\"\n\t\"mpeg\\0\" VIDEO_STR \"mpeg\\0\"\n\t\"mpg\\0\" VIDEO_STR \"mpeg\\0\"\n\t\"mpv\\0\" VIDEO_STR \"mpeg\\0\"\n\t\"mpv2\\0\" VIDEO_STR \"x-mpeg2\\0\"\n\t\"pdf\\0\" APPLICATION_STR \"pdf\\0\"\n\t\"pjp\\0\" IMAGE_STR \"jpeg\\0\"\n\t\"pjpeg\\0\" IMAGE_STR \"jpeg\\0\"\n\t\"plg\\0\" TEXT_STR \"html\\0\"\n\t\"pls\\0\" AUDIO_STR \"scpls\\0\"\n\t\"png\\0\" IMAGE_STR \"png\\0\"\n\t\"qt\\0\" VIDEO_STR \"quicktime\\0\"\n\t\"ram\\0\" AUDIO_STR \"x-pn-realaudio\\0\"\n\t\"rmi\\0\" AUDIO_STR \"mid\\0\"\n\t\"rmm\\0\" AUDIO_STR \"x-pn-realaudio\\0\"\n\t\"rtf\\0\" APPLICATION_STR \"rtf\\0\"\n\t\"shtml\\0\" TEXT_STR \"html\\0\"\n\t\"smf\\0\" AUDIO_STR \"midi\\0\"\n\t\"snd\\0\" AUDIO_STR \"basic\\0\"\n\t\"spl\\0\" APPLICATION_STR \"futuresplash\\0\"\n\t\"ssm\\0\" APPLICATION_STR \"streamingmedia\\0\"\n\t\"swf\\0\" APPLICATION_STR \"x-shockwave-flash\\0\"\n\t\"tar\\0\" APPLICATION_STR \"tar\\0\"\n\t\"tcl\\0\" APPLICATION_STR \"x-tcl\\0\"\n\t\"text\\0\" TEXT_STR \"plain\\0\"\n\t\"tif\\0\" IMAGE_STR \"tiff\\0\"\n\t\"tiff\\0\" IMAGE_STR \"tiff\\0\"\n\t\"txt\\0\" TEXT_STR \"plain\\0\"\n\t\"ulw\\0\" AUDIO_STR \"basic\\0\"\n\t\"wav\\0\" AUDIO_STR \"wav\\0\"\n\t\"wax\\0\" AUDIO_STR \"x-ms-wax\\0\"\n\t\"wm\\0\" VIDEO_STR \"x-ms-wm\\0\"\n\t\"wma\\0\" AUDIO_STR \"x-ms-wma\\0\"\n\t\"wmv\\0\" VIDEO_STR \"x-ms-wmv\\0\"\n\t\"wvx\\0\" VIDEO_STR \"x-ms-wvx\\0\"\n\t\"xbm\\0\" IMAGE_STR \"x-xbitmap\\0\"\n\t\"xml\\0\" TEXT_STR \"xml\\0\"\n\t\"xsl\\0\" TEXT_STR \"xml\\0\"\n\t\"z\\0\" APPLICATION_STR \"x-compress\\0\"\n\t\"zip\\0\" APPLICATION_STR \"zip\\0\" \"\\0\";\n/* *** end *** */\n\n/*!\n * module variables - Globals, static and externs.\n */\n\nstatic struct document_type_t gMediaTypeList[NUM_MEDIA_TYPES];\n\n/*! Global variable. A local dir which serves as webserver root. */\nmembuffer gDocumentRootDir;\n\n/*! XML document. */\nstatic struct xml_alias_t gAliasDoc;\nstatic ithread_mutex_t gWebMutex;\nextern str_int_entry Http_Header_Names[NUM_HTTP_HEADER_NAMES];\n\n/*!\n * \\brief Decodes list and stores it in gMediaTypeList.\n */\nstatic UPNP_INLINE void media_list_init(void)\n{\n\tint i;\n\tconst char *s = gEncodedMediaTypes;\n\tstruct document_type_t *doc_type;\n\n\tfor (i = 0; *s != '\\0'; i++) {\n\t\tdoc_type = &gMediaTypeList[i];\n\t\tdoc_type->file_ext = s;\n\t\t/* point to type. */\n\t\ts += strlen(s) + 1;\n\t\tdoc_type->content_type = gMediaTypes[(int)*s];\n\t\t/* point to subtype. */\n\t\ts++;\n\t\tdoc_type->content_subtype = s;\n\t\t/* next entry. */\n\t\ts += strlen(s) + 1;\n\t}\n\tassert(i == NUM_MEDIA_TYPES);\n}\n\n/*!\n * \\brief Based on the extension, returns the content type and content\n * subtype.\n *\n * \\return\n * \\li \\c 0 on success\n * \\li \\c -1 on error\n */\nstatic UPNP_INLINE int search_extension(\n\t/*! [in] . */\n\tconst char *extension,\n\t/*! [out] . */\n\tconst char **con_type,\n\t/*! [out] . */\n\tconst char **con_subtype)\n{\n\tint top, mid, bot;\n\tint cmp;\n\n\ttop = 0;\n\tbot = NUM_MEDIA_TYPES - 1;\n\n\twhile (top <= bot) {\n\t\tmid = (top + bot) / 2;\n\t\tcmp = strcasecmp(extension, gMediaTypeList[mid].file_ext);\n\t\tif (cmp > 0) {\n\t\t\t/* look below mid. */\n\t\t\ttop = mid + 1;\n\t\t} else if (cmp < 0) {\n\t\t\t/* look above mid. */\n\t\t\tbot = mid - 1;\n\t\t} else {\n\t\t\t/* cmp == 0 */\n\t\t\t*con_type = gMediaTypeList[mid].content_type;\n\t\t\t*con_subtype = gMediaTypeList[mid].content_subtype;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/*!\n * \\brief Based on the extension, clones an XML string based on type and\n * content subtype. If content type and sub type are not found, unknown\n * types are used.\n *\n * \\return\n * \\li \\c 0 on success.\n * \\li \\c UPNP_E_OUTOF_MEMORY - on memory allocation failures.\n */\nstatic UPNP_INLINE int get_content_type(\n\t/*! [in] . */\n\tconst char *filename,\n\t/*! [out] . */\n\tOUT UpnpFileInfo *fileInfo)\n{\n\tconst char *extension;\n\tconst char *type;\n\tconst char *subtype;\n\tint ctype_found = FALSE;\n\tchar *temp = NULL;\n\tsize_t length = 0;\n\tint rc = 0;\n\n\tUpnpFileInfo_set_ContentType(fileInfo, NULL);\n\t/* get ext */\n\textension = strrchr(filename, '.');\n\tif (extension != NULL)\n\t\tif (search_extension(extension + 1, &type, &subtype) == 0)\n\t\t\tctype_found = TRUE;\n\tif (!ctype_found) {\n\t\t/* unknown content type */\n\t\ttype = gMediaTypes[APPLICATION_INDEX];\n\t\tsubtype = \"octet-stream\";\n\t}\n\tlength = strlen(type) + strlen(\"/\") + strlen(subtype) + 1;\n\ttemp = malloc(length);\n\tif (!temp)\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\trc = snprintf(temp, length, \"%s/%s\", type, subtype);\n\tif (rc < 0 || (unsigned int) rc >= length) {\n\t\tfree(temp);\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\tUpnpFileInfo_set_ContentType(fileInfo, temp);\n\tfree(temp);\n\tif (!UpnpFileInfo_get_ContentType(fileInfo))\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\n\treturn 0;\n}\n\n/*!\n * \\brief Initialize the global XML document. Allocate buffers for the XML\n * document.\n */\nstatic UPNP_INLINE void glob_alias_init(void)\n{\n\tstruct xml_alias_t *alias = &gAliasDoc;\n\n\tmembuffer_init(&alias->doc);\n\tmembuffer_init(&alias->name);\n\talias->ct = NULL;\n\talias->last_modified = 0;\n}\n\n/*!\n * \\brief Check for the validity of the XML object buffer.\n *\n * \\return BOOLEAN.\n */\nstatic UPNP_INLINE int is_valid_alias(\n\t/*! [in] XML alias object. */\n\tconst struct xml_alias_t *alias)\n{\n\treturn alias->doc.buf != NULL;\n}\n\n/*!\n * \\brief Copy the contents of the global XML document into the local output\n * parameter.\n */\nstatic void alias_grab(\n\t/*! [out] XML alias object. */\n\tstruct xml_alias_t *alias)\n{\n\tithread_mutex_lock(&gWebMutex);\n\tassert(is_valid_alias(&gAliasDoc));\n\tmemcpy(alias, &gAliasDoc, sizeof(struct xml_alias_t));\n\t*alias->ct = *alias->ct + 1;\n\tithread_mutex_unlock(&gWebMutex);\n}\n\n/*!\n * \\brief Release the XML document referred to by the input parameter. Free\n * the allocated buffers associated with this object.\n */\nstatic void alias_release(\n\t/*! [in] XML alias object. */\n\tstruct xml_alias_t *alias)\n{\n\tithread_mutex_lock(&gWebMutex);\n\t/* ignore invalid alias */\n\tif (!is_valid_alias(alias)) {\n\t\tithread_mutex_unlock(&gWebMutex);\n\t\treturn;\n\t}\n\tassert(*alias->ct > 0);\n\t*alias->ct -= 1;\n\tif (*alias->ct <= 0) {\n\t\tmembuffer_destroy(&alias->doc);\n\t\tmembuffer_destroy(&alias->name);\n\t\tfree(alias->ct);\n\t}\n\tithread_mutex_unlock(&gWebMutex);\n}\n\nint web_server_set_alias(const char *alias_name, \n\tconst char *alias_content, size_t alias_content_length,\n\ttime_t last_modified)\n{\n\tint ret_code;\n\tstruct xml_alias_t alias;\n\n\talias_release(&gAliasDoc);\n\tif (alias_name == NULL) {\n\t\t/* don't serve aliased doc anymore */\n\t\treturn 0;\n\t}\n\tassert(alias_content != NULL);\n\tmembuffer_init(&alias.doc);\n\tmembuffer_init(&alias.name);\n\talias.ct = NULL;\n\tdo {\n\t\t/* insert leading /, if missing */\n\t\tif (*alias_name != '/')\n\t\t\tif (membuffer_assign_str(&alias.name, \"/\") != 0)\n\t\t\t\tbreak;\t/* error; out of mem */\n\t\tret_code = membuffer_append_str(&alias.name, alias_name);\n\t\tif (ret_code != 0)\n\t\t\tbreak;\t/* error */\n\t\tif ((alias.ct = (int *)malloc(sizeof(int))) == NULL)\n\t\t\tbreak;\t/* error */\n\t\t*alias.ct = 1;\n\t\tmembuffer_attach(&alias.doc, (char *)alias_content,\n\t\t\t\t alias_content_length);\n\t\talias.last_modified = last_modified;\n\t\t/* save in module var */\n\t\tithread_mutex_lock(&gWebMutex);\n\t\tgAliasDoc = alias;\n\t\tithread_mutex_unlock(&gWebMutex);\n\n\t\treturn 0;\n\t} while (FALSE);\n\t/* error handler */\n\t/* free temp alias */\n\tmembuffer_destroy(&alias.name);\n\tmembuffer_destroy(&alias.doc);\n\tfree(alias.ct);\n\n\treturn UPNP_E_OUTOF_MEMORY;\n}\n\nint web_server_init()\n{\n\tint ret = 0;\n\n\tif (bWebServerState == WEB_SERVER_DISABLED) {\n\t\t/* decode media list */\n\t\tmedia_list_init();\n\t\tmembuffer_init(&gDocumentRootDir);\n\t\tglob_alias_init();\n\t\tpVirtualDirList = NULL;\n\n\t\t/* Initialize callbacks */\n\t\tvirtualDirCallback.get_info = NULL;\n\t\tvirtualDirCallback.open = NULL;\n\t\tvirtualDirCallback.read = NULL;\n\t\tvirtualDirCallback.write = NULL;\n\t\tvirtualDirCallback.seek = NULL;\n\t\tvirtualDirCallback.close = NULL;\n\n\t\tif (ithread_mutex_init(&gWebMutex, NULL) == -1)\n\t\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\telse\n\t\t\tbWebServerState = WEB_SERVER_ENABLED;\n\t}\n\n\treturn ret;\n}\n\nvoid web_server_destroy(void)\n{\n\tif (bWebServerState == WEB_SERVER_ENABLED) {\n\t\tmembuffer_destroy(&gDocumentRootDir);\n\t\talias_release(&gAliasDoc);\n\n\t\tithread_mutex_lock(&gWebMutex);\n\t\tmemset(&gAliasDoc, 0, sizeof(struct xml_alias_t));\n\t\tithread_mutex_unlock(&gWebMutex);\n\n\t\tithread_mutex_destroy(&gWebMutex);\n\t\tbWebServerState = WEB_SERVER_DISABLED;\n\t}\n}\n\n/*!\n * \\brief Release memory allocated for the global web server root directory\n * and the global XML document. Resets the flag bWebServerState to\n * WEB_SERVER_DISABLED.\n *\n * \\return Integer.\n */\nstatic int get_file_info(\n\t/*! [in] Filename having the description document. */\n\tconst char *filename,\n\t/*! [out] File information object having file attributes such as filelength,\n\t * when was the file last modified, whether a file or a directory and\n\t * whether the file or directory is readable. */\n\tOUT UpnpFileInfo *info)\n{\n\tint code;\n\tstruct stat s;\n\tFILE *fp;\n\tint rc = 0;\n\ttime_t aux_LastModified;\n\tstruct tm date;\n\tchar buffer[ASCTIME_R_BUFFER_SIZE];\n\n\tUpnpFileInfo_set_ContentType(info, NULL);\n\tcode = stat(filename, &s);\n\tif (code == -1)\n\t\treturn -1;\n\tif (S_ISDIR(s.st_mode))\n\t\tUpnpFileInfo_set_IsDirectory(info, TRUE);\n\telse if (S_ISREG(s.st_mode))\n\t\tUpnpFileInfo_set_IsDirectory(info, FALSE);\n\telse\n\t\treturn -1;\n\t/* check readable */\n\tfp = fopen(filename, \"r\");\n\tUpnpFileInfo_set_IsReadable(info, fp != NULL);\n\tif (fp)\n\t\tfclose(fp);\n\tUpnpFileInfo_set_FileLength(info, s.st_size);\n\tUpnpFileInfo_set_LastModified(info, s.st_mtime);\n\trc = get_content_type(filename, info);\n\taux_LastModified = UpnpFileInfo_get_LastModified(info);\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\"file info: %s, length: %lld, last_mod=%s readable=%d\\n\",\n\t\tfilename,\n\t\t(long long)UpnpFileInfo_get_FileLength(info),\n\t\tweb_server_asctime_r(http_gmtime_r(&aux_LastModified, &date), buffer),\n\t\tUpnpFileInfo_get_IsReadable(info));\n\n\treturn rc;\n}\n\nint web_server_set_root_dir(const char *root_dir)\n{\n\tsize_t index;\n\tint ret;\n\n\tret = membuffer_assign_str(&gDocumentRootDir, root_dir);\n\tif (ret != 0)\n\t\treturn ret;\n\t/* remove trailing '/', if any */\n\tif (gDocumentRootDir.length > 0) {\n\t\tindex = gDocumentRootDir.length - 1;\t/* last char */\n\t\tif (gDocumentRootDir.buf[index] == '/')\n\t\t\tmembuffer_delete(&gDocumentRootDir, index, 1);\n\t}\n\n\treturn 0;\n}\n\n/*!\n * \\brief Compare the files names between the one on the XML alias the one\n * passed in as the input parameter. If equal extract file information.\n *\n * \\return\n * \\li \\c TRUE - On Success\n * \\li \\c FALSE if request is not an alias\n */\nstatic UPNP_INLINE int get_alias(\n\t/*! [in] request file passed in to be compared with. */\n\tconst char *request_file,\n\t/*! [out] xml alias object which has a file name stored. */\n\tstruct xml_alias_t *alias,\n\t/*! [out] File information object which will be filled up if the file\n\t * comparison succeeds. */\n\tUpnpFileInfo *info)\n{\n\tint cmp = strcmp(alias->name.buf, request_file);\n\tif (cmp == 0) {\n\t\tUpnpFileInfo_set_FileLength(info, (off_t)alias->doc.length);\n\t\tUpnpFileInfo_set_IsDirectory(info, FALSE);\n\t\tUpnpFileInfo_set_IsReadable(info, TRUE);\n\t\tUpnpFileInfo_set_LastModified(info, alias->last_modified);\n\t}\n\n\treturn cmp == 0;\n}\n\n/*!\n * \\brief Compares filePath with paths from the list of virtual directory\n * lists.\n *\n * \\return BOOLEAN.\n */\nstatic int isFileInVirtualDir(\n\t/*! [in] Directory path to be tested for virtual directory. */\n\tchar *filePath)\n{\n\tvirtualDirList *pCurVirtualDir;\n\tsize_t webDirLen;\n\n\tpCurVirtualDir = pVirtualDirList;\n\twhile (pCurVirtualDir != NULL) {\n\t\twebDirLen = strlen(pCurVirtualDir->dirName);\n\t\tif (webDirLen) {\n\t\t\tif (pCurVirtualDir->dirName[webDirLen - 1] == '/') {\n\t\t\t\tif (strncmp(pCurVirtualDir->dirName, filePath,\n\t\t\t\t\t\twebDirLen) == 0)\n\t\t\t\t\treturn !0;\n\t\t\t} else {\n\t\t\t\tif (strncmp(pCurVirtualDir->dirName, filePath,\n\t\t\t\t\t\twebDirLen) == 0 &&\n\t\t\t\t    (filePath[webDirLen] == '/' ||\n\t\t\t\t     filePath[webDirLen] == '\\0' ||\n\t\t\t\t     filePath[webDirLen] == '?'))\n\t\t\t\t\treturn !0;\n\t\t\t}\n\t\t}\n\t\tpCurVirtualDir = pCurVirtualDir->next;\n\t}\n\n\treturn 0;\n}\n\n/*!\n * \\brief Converts input string to upper case.\n */\nstatic void ToUpperCase(\n\t/*! Input string to be converted. */\n\tchar *s)\n{\n\twhile (*s) {\n\t\t*s = (char)toupper(*s);\n\t\t++s;\n\t}\n}\n\n/*!\n * \\brief Finds a substring from a string in a case insensitive way.\n *\n * \\return A pointer to the first occurence of s2 in s1.\n */\nstatic char *StrStr(\n\t/*! Input string. */\n\tchar *s1,\n\t/*! Input sub-string. */\n\tconst char *s2)\n{\n\tchar *Str1;\n\tchar *Str2;\n\tconst char *Ptr;\n\tchar *ret = NULL;\n\n\tStr1 = strdup(s1);\n\tif (!Str1)\n\t\tgoto error1;\n\tStr2 = strdup(s2);\n\tif (!Str2)\n\t\tgoto error2;\n\tToUpperCase(Str1);\n\tToUpperCase(Str2);\n\tPtr = strstr(Str1, Str2);\n\tif (!Ptr)\n\t\tret = NULL;\n\telse\n\t\tret = s1 + (Ptr - Str1);\n\n\tfree(Str2);\nerror2:\n\tfree(Str1);\nerror1:\n\treturn ret;\n}\n\n/*!\n * \\brief Finds next token in a string.\n *\n * \\return Pointer to the next token.\n */\nstatic char *StrTok(\n\t/*! String containing the token. */\n\tchar **Src,\n\t/*! Set of delimiter characters. */\n\tconst char *Del)\n{\n\tchar *TmpPtr;\n\tchar *RetPtr;\n\n\tif (*Src != NULL) {\n\t\tRetPtr = *Src;\n\t\tTmpPtr = strstr(*Src, Del);\n\t\tif (TmpPtr != NULL) {\n\t\t\t*TmpPtr = '\\0';\n\t\t\t*Src = TmpPtr + strlen(Del);\n\t\t} else\n\t\t\t*Src = NULL;\n\n\t\treturn RetPtr;\n\t}\n\n\treturn NULL;\n}\n\n/*!\n * \\brief Returns a range of integers from a string.\n *\n * \\return Always returns 1.\n */\nstatic int GetNextRange(\n\t/*! string containing the token / range. */\n\tchar **SrcRangeStr,\n\t/*! gets the first byte of the token. */\n\toff_t *FirstByte,\n\t/*! gets the last byte of the token. */\n\toff_t *LastByte)\n{\n\tchar *Ptr;\n\tchar *Tok;\n\tint i;\n\tint64_t F = -1;\n\tint64_t L = -1;\n\tint Is_Suffix_byte_Range = 1;\n\n\tif (*SrcRangeStr == NULL)\n\t\treturn -1;\n\tTok = StrTok(SrcRangeStr, \",\");\n\tif ((Ptr = strstr(Tok, \"-\")) == NULL)\n\t\treturn -1;\n\t*Ptr = ' ';\n\tsscanf(Tok, \"%\" SCNd64 \"%\" SCNd64, &F, &L);\n\tif (F == -1 || L == -1) {\n\t\t*Ptr = '-';\n\t\tfor (i = 0; i < (int)strlen(Tok); i++) {\n\t\t\tif (Tok[i] == '-') {\n\t\t\t\tbreak;\n\t\t\t} else if (isdigit(Tok[i])) {\n\t\t\t\tIs_Suffix_byte_Range = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (Is_Suffix_byte_Range) {\n\t\t\t*FirstByte = (off_t) L;\n\t\t\t*LastByte = (off_t) F;\n\t\t\treturn 1;\n\t\t}\n\t}\n\t*FirstByte = (off_t) F;\n\t*LastByte = (off_t) L;\n\n\treturn 1;\n}\n\n/*!\n * \\brief Fills in the Offset, read size and contents to send out as an HTTP\n * Range Response.\n *\n * \\return\n * \\li \\c HTTP_BAD_REQUEST\n * \\li \\c HTTP_INTERNAL_SERVER_ERROR\n * \\li \\c HTTP_REQUEST_RANGE_NOT_SATISFIABLE\n * \\li \\c HTTP_OK\n */\nstatic int CreateHTTPRangeResponseHeader(\n\t/*! String containing the range. */\n\tchar *ByteRangeSpecifier,\n\t/*! Length of the file. */\n\toff_t FileLength,\n\t/*! [out] SendInstruction object where the range operations will be stored. */\n\tstruct SendInstruction *Instr)\n{\n\toff_t FirstByte, LastByte;\n\tchar *RangeInput;\n\tchar *Ptr;\n\tint rc = 0;\n\n\tInstr->IsRangeActive = 1;\n\tInstr->ReadSendSize = FileLength;\n\tif (!ByteRangeSpecifier)\n\t\treturn HTTP_BAD_REQUEST;\n\tRangeInput = strdup(ByteRangeSpecifier);\n\tif (!RangeInput)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t/* CONTENT-RANGE: bytes 222-3333/4000  HTTP_PARTIAL_CONTENT */\n\tif (StrStr(RangeInput, \"bytes\") == NULL ||\n\t    (Ptr = StrStr(RangeInput, \"=\")) == NULL) {\n\t\tfree(RangeInput);\n\t\tInstr->IsRangeActive = 0;\n\t\treturn HTTP_BAD_REQUEST;\n\t}\n\t/* Jump = */\n\tPtr = Ptr + 1;\n\tif (FileLength < 0) {\n\t\tfree(RangeInput);\n\t\treturn HTTP_REQUEST_RANGE_NOT_SATISFIABLE;\n\t}\n\tif (GetNextRange(&Ptr, &FirstByte, &LastByte) != -1) {\n\t\tif (FileLength < FirstByte) {\n\t\t\tfree(RangeInput);\n\t\t\treturn HTTP_REQUEST_RANGE_NOT_SATISFIABLE;\n\t\t}\n\t\tif (FirstByte >= 0 && LastByte >= 0 && LastByte >= FirstByte) {\n\t\t\tif (LastByte >= FileLength)\n\t\t\t\tLastByte = FileLength - 1;\n\t\t\tInstr->RangeOffset = FirstByte;\n\t\t\tInstr->ReadSendSize = LastByte - FirstByte + 1;\n\t\t\t/* Data between two range. */\n\t\t\trc = snprintf(Instr->RangeHeader,\n\t\t\t\tsizeof(Instr->RangeHeader),\n\t\t\t\t\"CONTENT-RANGE: bytes %\" PRId64\n\t\t\t\t\"-%\" PRId64 \"/%\" PRId64 \"\\r\\n\",\n\t\t\t\t(int64_t)FirstByte,\n\t\t\t\t(int64_t)LastByte,\n\t\t\t\t(int64_t)FileLength);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Instr->RangeHeader)) {\n\t\t\t\tfree(RangeInput);\n\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t} else if (FirstByte >= 0 && LastByte == -1\n\t\t\t   && FirstByte < FileLength) {\n\t\t\tInstr->RangeOffset = FirstByte;\n\t\t\tInstr->ReadSendSize = FileLength - FirstByte;\n\t\t\trc = snprintf(Instr->RangeHeader,\n\t\t\t\tsizeof(Instr->RangeHeader),\n\t\t\t\t\"CONTENT-RANGE: bytes %\" PRId64\n\t\t\t\t\"-%\" PRId64 \"/%\" PRId64 \"\\r\\n\",\n\t\t\t\t(int64_t)FirstByte,\n\t\t\t\t(int64_t)(FileLength - 1),\n\t\t\t\t(int64_t)FileLength);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Instr->RangeHeader)) {\n\t\t\t\tfree(RangeInput);\n\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t} else if (FirstByte == -1 && LastByte > 0) {\n\t\t\tif (LastByte >= FileLength) {\n\t\t\t\tInstr->RangeOffset = 0;\n\t\t\t\tInstr->ReadSendSize = FileLength;\n\t\t\t\trc = snprintf(Instr->RangeHeader,\n\t\t\t\t\tsizeof(Instr->RangeHeader),\n\t\t\t\t\t\"CONTENT-RANGE: bytes 0-%\" PRId64\n\t\t\t\t\t\"/%\" PRId64 \"\\r\\n\",\n\t\t\t\t\t(int64_t)(FileLength - 1),\n\t\t\t\t\t(int64_t)FileLength);\n\t\t\t} else {\n\t\t\t\tInstr->RangeOffset = FileLength - LastByte;\n\t\t\t\tInstr->ReadSendSize = LastByte;\n\t\t\t\trc = snprintf(Instr->RangeHeader,\n\t\t\t\t\tsizeof(Instr->RangeHeader),\n\t\t\t\t\t\"CONTENT-RANGE: bytes %\" PRId64\n\t\t\t\t\t\"-%\" PRId64 \"/%\" PRId64 \"\\r\\n\",\n\t\t\t\t\t(int64_t)(FileLength - LastByte),\n\t\t\t\t\t(int64_t)FileLength - 1,\n\t\t\t\t\t(int64_t)FileLength);\n\t\t\t}\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Instr->RangeHeader)) {\n\t\t\t\tfree(RangeInput);\n\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t} else {\n\t\t\tfree(RangeInput);\n\t\t\treturn HTTP_REQUEST_RANGE_NOT_SATISFIABLE;\n\t\t}\n\t} else {\n\t\tfree(RangeInput);\n\t\treturn HTTP_REQUEST_RANGE_NOT_SATISFIABLE;\n\t}\n\n\tfree(RangeInput);\n\treturn HTTP_OK;\n}\n\n/*!\n * \\brief Get header id from the request parameter and take appropriate\n * action based on the ids as an HTTP Range Response.\n *\n * \\return\n * \\li \\c HTTP_BAD_REQUEST\n * \\li \\c HTTP_INTERNAL_SERVER_ERROR\n * \\li \\c HTTP_REQUEST_RANGE_NOT_SATISFIABLE\n * \\li \\c HTTP_OK\n */\nstatic int CheckOtherHTTPHeaders(\n\t/*! [in] HTTP Request message. */\n\thttp_message_t *Req,\n\t/*! [out] Send Instruction object to data for the response. */\n\tstruct SendInstruction *RespInstr,\n\t/*! Size of the file containing the request document. */\n\toff_t FileSize)\n{\n\thttp_header_t *header;\n\tListNode *node;\n\t/*NNS: dlist_node* node; */\n\tint index, RetCode = HTTP_OK;\n\tchar *TmpBuf;\n\tsize_t TmpBufSize = LINE_SIZE;\n\n\tTmpBuf = (char *)malloc(TmpBufSize);\n\tif (!TmpBuf)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\tnode = ListHead(&Req->headers);\n\twhile (node != NULL) {\n\t\theader = (http_header_t *) node->item;\n\t\t/* find header type. */\n\t\tindex = map_str_to_int((const char *)header->name.buf,\n\t\t\t\theader->name.length, Http_Header_Names,\n\t\t\t\tNUM_HTTP_HEADER_NAMES, FALSE);\n\t\tif (header->value.length >= TmpBufSize) {\n\t\t\tfree(TmpBuf);\n\t\t\tTmpBufSize = header->value.length + 1;\n\t\t\tTmpBuf = (char *)malloc(TmpBufSize);\n\t\t\tif (!TmpBuf)\n\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t}\n\t\tmemcpy(TmpBuf, header->value.buf, header->value.length);\n\t\tTmpBuf[header->value.length] = '\\0';\n\t\tif (index >= 0) {\n\t\t\tswitch (Http_Header_Names[index].id) {\n\t\t\tcase HDR_TE: {\n\t\t\t\t/* Request */\n\t\t\t\tRespInstr->IsChunkActive = 1;\n\n\t\t\t\tif (strlen(TmpBuf) > strlen(\"gzip\")) {\n\t\t\t\t\t/* means client will accept trailer. */\n\t\t\t\t\tif (StrStr(TmpBuf, \"trailers\") != NULL) {\n\t\t\t\t\t\tRespInstr->IsTrailers = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase HDR_CONTENT_LENGTH:\n\t\t\t\tRespInstr->RecvWriteSize = atoi(TmpBuf);\n\t\t\t\tbreak;\n\t\t\tcase HDR_RANGE:\n\t\t\t\tRetCode = CreateHTTPRangeResponseHeader(TmpBuf,\n\t\t\t\t\tFileSize, RespInstr);\n\t\t\t\tif (RetCode != HTTP_OK) {\n\t\t\t\t\tfree(TmpBuf);\n\t\t\t\t\treturn RetCode;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase HDR_ACCEPT_LANGUAGE:\n\t\t\t\tif (header->value.length + 1 > sizeof(RespInstr->AcceptLanguageHeader)) {\n\t\t\t\t\tsize_t length = sizeof(RespInstr->AcceptLanguageHeader) - 1;\n\t\t\t\t\tmemcpy(RespInstr->AcceptLanguageHeader, TmpBuf, length);\n\t\t\t\t\tRespInstr->AcceptLanguageHeader[length] = '\\0';\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(RespInstr->AcceptLanguageHeader, TmpBuf,\n\t\t\t\t\t\theader->value.length + 1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t   TODO\n\t\t\t\t */\n\t\t\t\t/*\n\t\t\t\t   header.value is the value.\n\t\t\t\t */\n\t\t\t\t/*\n\t\t\t\t   case HDR_CONTENT_TYPE: return 1;\n\t\t\t\t   case HDR_CONTENT_LANGUAGE:return 1;\n\t\t\t\t   case HDR_LOCATION: return 1;\n\t\t\t\t   case HDR_CONTENT_LOCATION:return 1;\n\t\t\t\t   case HDR_ACCEPT: return 1;\n\t\t\t\t   case HDR_ACCEPT_CHARSET: return 1;\n\t\t\t\t   case HDR_USER_AGENT: return 1;\n\t\t\t\t */\n\n\t\t\t\t/*Header check for encoding */\n\t\t\t\t/*\n\t\t\t\t   case HDR_ACCEPT_RANGE:\n\t\t\t\t   case HDR_CONTENT_RANGE:\n\t\t\t\t   case HDR_IF_RANGE:\n\t\t\t\t */\n\n\t\t\t\t/*Header check for encoding */\n\t\t\t\t/*\n\t\t\t\t   case HDR_ACCEPT_ENCODING:\n\t\t\t\t   if(StrStr(TmpBuf, \"identity\"))\n\t\t\t\t   {\n\t\t\t\t   break;\n\t\t\t\t   }\n\t\t\t\t   else return -1;\n\t\t\t\t   case HDR_CONTENT_ENCODING:\n\t\t\t\t   case HDR_TRANSFER_ENCODING:\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnode = ListNext(&Req->headers, node);\n\t}\n\tfree(TmpBuf);\n\n\treturn RetCode;\n}\n\n/*!\n * \\brief Processes the request and returns the result in the output parameters.\n *\n * \\return\n * \\li \\c HTTP_BAD_REQUEST\n * \\li \\c HTTP_INTERNAL_SERVER_ERROR\n * \\li \\c HTTP_REQUEST_RANGE_NOT_SATISFIABLE\n * \\li \\c HTTP_FORBIDDEN\n * \\li \\c HTTP_NOT_FOUND\n * \\li \\c HTTP_NOT_ACCEPTABLE\n * \\li \\c HTTP_OK\n */\nstatic int process_request(\n\t/*! [in] HTTP Request message. */\n\thttp_message_t *req,\n\t/*! [out] Tpye of response. */\n\tenum resp_type *rtype,\n\t/*! [out] Headers. */\n\tmembuffer *headers,\n\t/*! [out] Get filename from request document. */\n\tmembuffer *filename,\n\t/*! [out] Xml alias document from the request document. */\n\tstruct xml_alias_t *alias,\n\t/*! [out] Send Instruction object where the response is set up. */\n\tstruct SendInstruction *RespInstr)\n{\n\tint code;\n\tint err_code;\n\n\tchar *request_doc;\n\tUpnpFileInfo *finfo;\n\ttime_t aux_LastModified;\n\tint using_alias;\n\tint using_virtual_dir;\n\turi_type *url;\n\tconst char *temp_str;\n\tint resp_major;\n\tint resp_minor;\n\tint alias_grabbed;\n\tsize_t dummy;\n\tconst char *extra_headers = NULL;\n\n\tprint_http_headers(req);\n\turl = &req->uri;\n\tassert(req->method == HTTPMETHOD_GET ||\n\t       req->method == HTTPMETHOD_HEAD ||\n\t       req->method == HTTPMETHOD_POST ||\n\t       req->method == HTTPMETHOD_SIMPLEGET);\n\t/* init */\n\tmemset(&finfo, 0, sizeof(finfo));\n\trequest_doc = NULL;\n\tfinfo = UpnpFileInfo_new();\n\talias_grabbed = FALSE;\n\terr_code = HTTP_INTERNAL_SERVER_ERROR;\t/* default error */\n\tusing_virtual_dir = FALSE;\n\tusing_alias = FALSE;\n\n\thttp_CalcResponseVersion(req->major_version, req->minor_version,\n\t\t\t\t &resp_major, &resp_minor);\n\t/* */\n\t/* remove dots */\n\t/* */\n\trequest_doc = malloc(url->pathquery.size + 1);\n\tif (request_doc == NULL) {\n\t\tgoto error_handler;\t/* out of mem */\n\t}\n\tmemcpy(request_doc, url->pathquery.buff, url->pathquery.size);\n\trequest_doc[url->pathquery.size] = '\\0';\n\tdummy = url->pathquery.size;\n\tremove_escaped_chars(request_doc, &dummy);\n\tcode = remove_dots(request_doc, url->pathquery.size);\n\tif (code != 0) {\n\t\terr_code = HTTP_FORBIDDEN;\n\t\tgoto error_handler;\n\t}\n\tif (*request_doc != '/') {\n\t\t/* no slash */\n\t\terr_code = HTTP_BAD_REQUEST;\n\t\tgoto error_handler;\n\t}\n\tif (isFileInVirtualDir(request_doc)) {\n\t\tusing_virtual_dir = TRUE;\n\t\tRespInstr->IsVirtualFile = 1;\n\t\tif (membuffer_assign_str(filename, request_doc) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t} else {\n\t\t/* try using alias */\n\t\tif (is_valid_alias(&gAliasDoc)) {\n\t\t\talias_grab(alias);\n\t\t\talias_grabbed = TRUE;\n\t\t\tusing_alias = get_alias(request_doc, alias, finfo);\n\t\t\tif (using_alias == TRUE) {\n\t\t\t\tUpnpFileInfo_set_ContentType(finfo,\n\t\t\t\t\t\"text/xml; charset=\\\"utf-8\\\"\");\n\t\t\t\tif (UpnpFileInfo_get_ContentType(finfo) == NULL) {\n\t\t\t\t\tgoto error_handler;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (using_virtual_dir) {\n\t\tif (req->method != HTTPMETHOD_POST) {\n\t\t\t/* get file info */\n\t\t\tif (virtualDirCallback.\n\t\t\t    get_info(filename->buf, finfo) != 0) {\n\t\t\t\terr_code = HTTP_NOT_FOUND;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\t/* try index.html if req is a dir */\n\t\t\tif (UpnpFileInfo_get_IsDirectory(finfo)) {\n\t\t\t\tif (filename->buf[filename->length - 1] == '/') {\n\t\t\t\t\ttemp_str = \"index.html\";\n\t\t\t\t} else {\n\t\t\t\t\ttemp_str = \"/index.html\";\n\t\t\t\t}\n\t\t\t\tif (membuffer_append_str(filename, temp_str) !=\n\t\t\t\t    0) {\n\t\t\t\t\tgoto error_handler;\n\t\t\t\t}\n\t\t\t\t/* get info */\n\t\t\t\tif (virtualDirCallback.get_info(filename->buf, finfo) != UPNP_E_SUCCESS ||\n\t\t\t\t    UpnpFileInfo_get_IsDirectory(finfo)) {\n\t\t\t\t\terr_code = HTTP_NOT_FOUND;\n\t\t\t\t\tgoto error_handler;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* not readable */\n\t\t\tif (!UpnpFileInfo_get_IsReadable(finfo)) {\n\t\t\t\terr_code = HTTP_FORBIDDEN;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\t/* finally, get content type */\n\t\t\t/* if ( get_content_type(filename->buf, &content_type) != 0 ) */\n\t\t\t/*{ */\n\t\t\t/*  goto error_handler; */\n\t\t\t/* } */\n\t\t}\n\t} else if (!using_alias) {\n\t\tif (gDocumentRootDir.length == 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\t/* */\n\t\t/* get file name */\n\t\t/* */\n\n\t\t/* filename str */\n\t\tif (membuffer_assign_str(filename, gDocumentRootDir.buf) != 0 ||\n\t\t    membuffer_append_str(filename, request_doc) != 0) {\n\t\t\tgoto error_handler;\t/* out of mem */\n\t\t}\n\t\t/* remove trailing slashes */\n\t\twhile (filename->length > 0 &&\n\t\t       filename->buf[filename->length - 1] == '/') {\n\t\t\tmembuffer_delete(filename, filename->length - 1, 1);\n\t\t}\n\t\tif (req->method != HTTPMETHOD_POST) {\n\t\t\t/* get info on file */\n\t\t\tif (get_file_info(filename->buf, finfo) != 0) {\n\t\t\t\terr_code = HTTP_NOT_FOUND;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\t/* try index.html if req is a dir */\n\t\t\tif (UpnpFileInfo_get_IsDirectory(finfo)) {\n\t\t\t\tif (filename->buf[filename->length - 1] == '/') {\n\t\t\t\t\ttemp_str = \"index.html\";\n\t\t\t\t} else {\n\t\t\t\t\ttemp_str = \"/index.html\";\n\t\t\t\t}\n\t\t\t\tif (membuffer_append_str(filename, temp_str) !=\n\t\t\t\t    0) {\n\t\t\t\t\tgoto error_handler;\n\t\t\t\t}\n\t\t\t\t/* get info */\n\t\t\t\tif (get_file_info(filename->buf, finfo) != 0 ||\n\t\t\t\t    UpnpFileInfo_get_IsDirectory(finfo)) {\n\t\t\t\t\terr_code = HTTP_NOT_FOUND;\n\t\t\t\t\tgoto error_handler;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* not readable */\n\t\t\tif (!UpnpFileInfo_get_IsReadable(finfo)) {\n\t\t\t\terr_code = HTTP_FORBIDDEN;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t}\n\t\t/* finally, get content type */\n\t\t/*      if ( get_content_type(filename->buf, &content_type) != 0 ) */\n\t\t/*      { */\n\t\t/*          goto error_handler; */\n\t\t/*      } */\n\t}\n\tRespInstr->ReadSendSize = UpnpFileInfo_get_FileLength(finfo);\n\t/* Check other header field. */\n\tcode = CheckOtherHTTPHeaders(req, RespInstr,\n\t\tUpnpFileInfo_get_FileLength(finfo));\n\tif (code != HTTP_OK) {\n\t\terr_code = code;\n\t\tgoto error_handler;\n\t}\n\tif (req->method == HTTPMETHOD_POST) {\n\t\t*rtype = RESP_POST;\n\t\terr_code = HTTP_OK;\n\t\tgoto error_handler;\n\t}\n\textra_headers = UpnpFileInfo_get_ExtraHeaders(finfo);\n\tif (!extra_headers) {\n\t\textra_headers = \"\";\n\t}\n\n\t/* Check if chunked encoding should be used. */\n\tif (using_virtual_dir && UpnpFileInfo_get_FileLength(finfo) == UPNP_USING_CHUNKED) {\n\t\t/* Chunked encoding is only supported by HTTP 1.1 clients */\n\t\tif (resp_major == 1 && resp_minor == 1) {\n\t\t\tRespInstr->IsChunkActive = 1;\n\t\t} else {\n\t\t\t/* The virtual callback indicates that we should use\n\t\t\t * chunked encoding however the client doesn't support\n\t\t\t * it. Return with an internal server error. */\n\t\t\terr_code = HTTP_NOT_ACCEPTABLE;\n\t\t\tgoto error_handler;\n\t\t}\n\t}\n\n\taux_LastModified = UpnpFileInfo_get_LastModified(finfo);\n\tif (RespInstr->IsRangeActive && RespInstr->IsChunkActive) {\n\t\t/* Content-Range: bytes 222-3333/4000  HTTP_PARTIAL_CONTENT */\n\t\t/* Transfer-Encoding: chunked */\n\t\tif (http_MakeMessage(headers, resp_major, resp_minor,\n\t\t    \"R\" \"T\" \"GKLD\" \"s\" \"tcS\" \"Xc\" \"sCc\",\n\t\t    HTTP_PARTIAL_CONTENT,\t/* status code */\n\t\t    UpnpFileInfo_get_ContentType(finfo), /* content type */\n\t\t    RespInstr,\t/* range info */\n\t\t    RespInstr,\t/* language info */\n\t\t    \"LAST-MODIFIED: \",\n\t\t    &aux_LastModified,\n\t\t    X_USER_AGENT, extra_headers) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t} else if (RespInstr->IsRangeActive && !RespInstr->IsChunkActive) {\n\t\t/* Content-Range: bytes 222-3333/4000  HTTP_PARTIAL_CONTENT */\n\t\tif (http_MakeMessage(headers, resp_major, resp_minor,\n\t\t    \"R\" \"N\" \"T\" \"GLD\" \"s\" \"tcS\" \"Xc\" \"sCc\",\n\t\t    HTTP_PARTIAL_CONTENT,\t/* status code */\n\t\t    RespInstr->ReadSendSize,\t/* content length */\n\t\t    UpnpFileInfo_get_ContentType(finfo), /* content type */\n\t\t    RespInstr,\t/* range info */\n\t\t    RespInstr,\t/* language info */\n\t\t    \"LAST-MODIFIED: \",\n\t\t    &aux_LastModified,\n\t\t    X_USER_AGENT, extra_headers) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t} else if (!RespInstr->IsRangeActive && RespInstr->IsChunkActive) {\n\t\t/* Transfer-Encoding: chunked */\n\t\tif (http_MakeMessage(headers, resp_major, resp_minor,\n\t\t    \"RK\" \"TLD\" \"s\" \"tcS\" \"Xc\" \"sCc\",\n\t\t    HTTP_OK,\t/* status code */\n\t\t    UpnpFileInfo_get_ContentType(finfo), /* content type */\n\t\t    RespInstr,\t/* language info */\n\t\t    \"LAST-MODIFIED: \",\n\t\t    &aux_LastModified,\n\t\t    X_USER_AGENT, extra_headers) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t} else {\n\t\t/* !RespInstr->IsRangeActive && !RespInstr->IsChunkActive */\n\t\tif (RespInstr->ReadSendSize >= 0) {\n\t\t\tif (http_MakeMessage(headers, resp_major, resp_minor,\n\t\t\t    \"R\" \"N\" \"TLD\" \"s\" \"tcS\" \"Xc\" \"sCc\",\n\t\t\t    HTTP_OK,\t/* status code */\n\t\t\t    RespInstr->ReadSendSize,\t/* content length */\n\t\t\t    UpnpFileInfo_get_ContentType(finfo), /* content type */\n\t\t\t    RespInstr,\t/* language info */\n\t\t\t    \"LAST-MODIFIED: \",\n\t\t\t    &aux_LastModified,\n\t\t\t    X_USER_AGENT,\n\t\t\t    extra_headers) != 0) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else {\n\t\t\tif (http_MakeMessage(headers, resp_major, resp_minor,\n\t\t\t    \"R\" \"TLD\" \"s\" \"tcS\" \"Xc\" \"sCc\",\n\t\t\t    HTTP_OK,\t/* status code */\n\t\t\t    UpnpFileInfo_get_ContentType(finfo), /* content type */\n\t\t\t    RespInstr,\t/* language info */\n\t\t\t    \"LAST-MODIFIED: \",\n\t\t\t    &aux_LastModified,\n\t\t\t    X_USER_AGENT,\n\t\t\t    extra_headers) != 0) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t}\n\t}\n\tif (req->method == HTTPMETHOD_HEAD) {\n\t\t*rtype = RESP_HEADERS;\n\t} else if (using_alias) {\n\t\t/* GET xml */\n\t\t*rtype = RESP_XMLDOC;\n\t} else if (using_virtual_dir) {\n\t\t*rtype = RESP_WEBDOC;\n\t} else {\n\t\t/* GET filename */\n\t\t*rtype = RESP_FILEDOC;\n\t}\n\t/* simple get http 0.9 as specified in http 1.0 */\n\t/* don't send headers */\n\tif (req->method == HTTPMETHOD_SIMPLEGET) {\n\t\tmembuffer_destroy(headers);\n\t}\n\terr_code = HTTP_OK;\n\n error_handler:\n\tfree(request_doc);\n\tUpnpFileInfo_delete(finfo);\n\tif (err_code != HTTP_OK && alias_grabbed) {\n\t\talias_release(alias);\n\t}\n\n\treturn err_code;\n}\n\n/*!\n * \\brief Receives the HTTP post message.\n *\n * \\return\n * \\li \\c HTTP_INTERNAL_SERVER_ERROR\n * \\li \\c HTTP_UNAUTHORIZED\n * \\li \\c HTTP_BAD_REQUEST\n * \\li \\c HTTP_SERVICE_UNAVAILABLE\n * \\li \\c HTTP_OK\n */\nstatic int http_RecvPostMessage(\n\t/*! HTTP Parser object. */\n\thttp_parser_t *parser,\n\t/*! [in] Socket Information object. */\n\tSOCKINFO *info,\n\t/*! File where received data is copied to. */\n\tchar *filename,\n\t/*! Send Instruction object which gives information whether the file\n\t * is a virtual file or not. */\n\tstruct SendInstruction *Instr)\n{\n\tsize_t Data_Buf_Size = 1024;\n\tchar Buf[1024];\n\tint Timeout = -1;\n\tFILE *Fp;\n\tparse_status_t status = PARSE_OK;\n\tint ok_on_close = FALSE;\n\tsize_t entity_offset = 0;\n\tint num_read = 0;\n\tint ret_code = HTTP_OK;\n\n\tif (Instr && Instr->IsVirtualFile) {\n\t\tFp = (virtualDirCallback.open) (filename, UPNP_WRITE);\n\t\tif (Fp == NULL)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t} else {\n\t\tFp = fopen(filename, \"wb\");\n\t\tif (Fp == NULL)\n\t\t\treturn HTTP_UNAUTHORIZED;\n\t}\n\tparser->position = POS_ENTITY;\n\tdo {\n\t\t/* first parse what has already been gotten */\n\t\tif (parser->position != POS_COMPLETE)\n\t\t\tstatus = parser_parse_entity(parser);\n\t\tif (status == PARSE_INCOMPLETE_ENTITY) {\n\t\t\t/* read until close */\n\t\t\tok_on_close = TRUE;\n\t\t} else if ((status != PARSE_SUCCESS)\n\t\t\t   && (status != PARSE_CONTINUE_1)\n\t\t\t   && (status != PARSE_INCOMPLETE)) {\n\t\t\t/* error */\n\t\t\tret_code = HTTP_BAD_REQUEST;\n\t\t\tgoto ExitFunction;\n\t\t}\n\t\t/* read more if necessary entity */\n\t\twhile (entity_offset + Data_Buf_Size > parser->msg.entity.length &&\n\t\t       parser->position != POS_COMPLETE) {\n\t\t\tnum_read = sock_read(info, Buf, sizeof(Buf), &Timeout);\n\t\t\tif (num_read > 0) {\n\t\t\t\t/* append data to buffer */\n\t\t\t\tif (membuffer_append(&parser->msg.msg,\n\t\t\t\t\tBuf, (size_t)num_read) != 0) {\n\t\t\t\t\t/* set failure status */\n\t\t\t\t\tparser->http_error_code =\n\t\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\t\tret_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t\tstatus = parser_parse_entity(parser);\n\t\t\t\tif (status == PARSE_INCOMPLETE_ENTITY) {\n\t\t\t\t\t/* read until close */\n\t\t\t\t\tok_on_close = TRUE;\n\t\t\t\t} else if ((status != PARSE_SUCCESS)\n\t\t\t\t\t   && (status != PARSE_CONTINUE_1)\n\t\t\t\t\t   && (status != PARSE_INCOMPLETE)) {\n\t\t\t\t\tret_code = HTTP_BAD_REQUEST;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t} else if (num_read == 0) {\n\t\t\t\tif (ok_on_close) {\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t\"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\t\tparser->msg.msg.buf);\n\t\t\t\t\tprint_http_headers(&parser->msg);\n\t\t\t\t\tparser->position = POS_COMPLETE;\n\t\t\t\t} else {\n\t\t\t\t\t/* partial msg or response */\n\t\t\t\t\tparser->http_error_code = HTTP_BAD_REQUEST;\n\t\t\t\t\tret_code = HTTP_BAD_REQUEST;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tret_code = HTTP_SERVICE_UNAVAILABLE;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t}\n\t\tif ((entity_offset + Data_Buf_Size) > parser->msg.entity.length) {\n\t\t\tData_Buf_Size =\n\t\t\t    parser->msg.entity.length - entity_offset;\n\t\t}\n\t\tmemcpy(Buf,\n\t\t       &parser->msg.msg.buf[parser->entity_start_position + entity_offset],\n\t\t       Data_Buf_Size);\n\t\tentity_offset += Data_Buf_Size;\n\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\tint n = virtualDirCallback.write(Fp, Buf, Data_Buf_Size);\n\t\t\tif (n < 0) {\n\t\t\t\tret_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t} else {\n\t\t\tsize_t n = fwrite(Buf, 1, Data_Buf_Size, Fp);\n\t\t\tif (n != Data_Buf_Size) {\n\t\t\t\tret_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t}\n\t} while (parser->position != POS_COMPLETE ||\n\t\t entity_offset != parser->msg.entity.length);\nExitFunction:\n\tif (Instr && Instr->IsVirtualFile) {\n\t\tvirtualDirCallback.close(Fp);\n\t} else {\n\t\tfclose(Fp);\n\t}\n\n\treturn ret_code;\n}\n\nvoid web_server_callback(http_parser_t *parser, INOUT http_message_t *req,\n\tSOCKINFO *info)\n{\n\tint ret;\n\tint timeout = -1;\n\tenum resp_type rtype = 0;\n\tmembuffer headers;\n\tmembuffer filename;\n\tstruct xml_alias_t xmldoc;\n\tstruct SendInstruction RespInstr;\n\n\t/*Initialize instruction header. */\n\tRespInstr.IsVirtualFile = 0;\n\tRespInstr.IsChunkActive = 0;\n\tRespInstr.IsRangeActive = 0;\n\tRespInstr.IsTrailers = 0;\n\tmemset(RespInstr.AcceptLanguageHeader, 0,\n\t       sizeof(RespInstr.AcceptLanguageHeader));\n\t/* init */\n\tmembuffer_init(&headers);\n\tmembuffer_init(&filename);\n\n\t/*Process request should create the different kind of header depending on the */\n\t/*the type of request. */\n\tret = process_request(req, &rtype, &headers, &filename, &xmldoc,\n\t\t&RespInstr);\n\tif (ret != HTTP_OK) {\n\t\t/* send error code */\n\t\thttp_SendStatusResponse(info, ret, req->major_version,\n\t\t\treq->minor_version);\n\t} else {\n\t\t/* send response */\n\t\tswitch (rtype) {\n\t\tcase RESP_FILEDOC:\n\t\t\thttp_SendMessage(info, &timeout, \"Ibf\",\n\t\t\t\t\t &RespInstr,\n\t\t\t\t\t headers.buf, headers.length,\n\t\t\t\t\t filename.buf);\n\t\t\tbreak;\n\t\tcase RESP_XMLDOC:\n\t\t\thttp_SendMessage(info, &timeout, \"Ibb\",\n\t\t\t\t&RespInstr,\n\t\t\t\theaders.buf, headers.length,\n\t\t\t\txmldoc.doc.buf, xmldoc.doc.length);\n\t\t\talias_release(&xmldoc);\n\t\t\tbreak;\n\t\tcase RESP_WEBDOC:\n\t\t\t/*http_SendVirtualDirDoc(info, &timeout, \"Ibf\",\n\t\t\t\t&RespInstr,\n\t\t\t\theaders.buf, headers.length,\n\t\t\t\tfilename.buf);*/\n\t\t\thttp_SendMessage(info, &timeout, \"Ibf\",\n\t\t\t\t&RespInstr,\n\t\t\t\theaders.buf, headers.length,\n\t\t\t\tfilename.buf);\n\t\t\tbreak;\n\t\tcase RESP_HEADERS:\n\t\t\t/* headers only */\n\t\t\thttp_SendMessage(info, &timeout, \"b\",\n\t\t\t\theaders.buf, headers.length);\n\t\t\tbreak;\n\t\tcase RESP_POST:\n\t\t\t/* headers only */\n\t\t\tret = http_RecvPostMessage(parser, info, filename.buf,\n\t\t\t\t&RespInstr);\n\t\t\t/* Send response. */\n\t\t\thttp_MakeMessage(&headers, 1, 1,\n\t\t\t\t\"RTLSXcCc\",\n\t\t\t\tret, \"text/html\", &RespInstr, X_USER_AGENT);\n\t\t\thttp_SendMessage(info, &timeout, \"b\",\n\t\t\t\theaders.buf, headers.length);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"webserver: Invalid response type received.\\n\");\n\t\t\tassert(0);\n\t\t}\n\t}\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t   \"webserver: request processed...\\n\");\n\tmembuffer_destroy(&headers);\n\tmembuffer_destroy(&filename);\n}\n#endif /* EXCLUDE_WEB_SERVER */\n\n"], "fixing_code": ["# -*- Autoconf -*-\n#\n# Top-level configure.ac file for libupnp\n#\n# Process this file with autoconf to produce a configure script.\n#\n# (C) Copyright 2005-2007 R\u00e9mi Turboult <r3mi@users.sourceforge.net>\n#\n\nAC_PREREQ(2.60)\n\nAC_INIT([libupnp], [1.8.0], [mroberto@users.sourceforge.net])\ndnl ############################################################################\ndnl # *Independently* of the above libupnp package version, the libtool version\ndnl # of the 3 libraries need to be updated whenever there is a change released:\ndnl # \"current:revision:age\" (this is NOT the same as the package version),\ndnl # where:\ndnl # \t- library code modified:\t\trevision++\ndnl # \t- interfaces changed/added/removed:\tcurrent++ and revision=0\ndnl # \t- interfaces added: \t\t\tage++\ndnl # \t- interfaces removed:\t\t\tage=0\ndnl # *please update only once, before a formal release, not for each change*\ndnl #\ndnl ############################################################################\ndnl # Release 1.4.1:\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:2:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [2:2:0])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [2:2:0])\ndnl #\ndnl ############################################################################\ndnl # Release 1.4.6:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in ixml\ndnl #\trevision: 2 -> 3\ndnl # - Code has changed in threadutil\ndnl #\trevision: 2 -> 3\ndnl # - Interface added in threadutil\ndnl #\tcurrent: 2 -> 3\ndnl #\trevisiion: 3 -> 0\ndnl #\tage: 0 -> 1\ndnl # - Code has changed in upnp\ndnl #\trevision: 2 -> 3\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:3:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [3:0:1])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [2:3:0])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.0:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in ixml\ndnl #\trevision: 3 -> 4\ndnl # - Code has changed in threadutil\ndnl #\trevision: 0 -> 1\ndnl # - Code has changed in upnp\ndnl #\trevision: 3 -> 4\ndnl # - Interface changed in upnp\ndnl #\tcurrent: 2 -> 3\ndnl #\trevision: 4 -> 0\ndnl # - Interface removed in upnp\ndnl #\tage: 0 -> 0\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:4:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [3:1:1])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [3:0:0])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.1:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in threadutil\ndnl #\trevision: 1 -> 2\ndnl # - Interface added in threadutil\ndnl #\tcurrent: 3 -> 4\ndnl #\trevision: 2 -> 0\ndnl # - Interface added in threadutil\ndnl #\tage: 1 -> 2\ndnl # - Code has changed in upnp\ndnl #\trevision: 0 -> 1\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:4:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [4:0:2])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [3:1:0])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.2:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in upnp\ndnl #\trevision: 1 -> 2\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:4:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [4:0:2])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [3:2:0])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.3:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in threadutil\ndnl #\trevision: 0 -> 1\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:4:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [4:1:2])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [3:2:0])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.4:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in threadutil\ndnl #\trevision: 1 -> 2\ndnl # - Code has changed in upnp\ndnl #\trevision: 2 -> 3\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:4:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [4:2:2])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [3:3:0])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.5:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in upnp\ndnl #\trevision: 3 -> 4\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:4:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [4:2:2])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [3:4:0])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.6:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in threadutil\ndnl #\trevision: 2 -> 3\ndnl # - Code has changed in upnp\ndnl #\trevision: 4 -> 5\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:4:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [4:3:2])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [3:5:0])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.7:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in threadutil\ndnl #\trevision: 3 -> 4\ndnl # - Code has changed in upnp\ndnl #\trevision: 5 -> 6\ndnl # - Interfaces have been changed, added and removed in upnp\ndnl #\tcurrent: 3 -> 4\ndnl #   revision: 6 -> 0\ndnl # - Interfaces removed in upnp:\ndnl #   age: -> 0\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:4:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [5:0:2])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [3:5:0])\ndnl #\ndnl # Obs.: 1.6.7 was released with a version error, the correct nubers should\ndnl # have been:\ndnl #AC_SUBST([LT_VERSION_UPNP],       [4:0:0])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.8:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in ixml\ndnl #\trevision: 4 -> 5\ndnl # - Code has changed in threadutil\ndnl #\trevision: 0 -> 1\ndnl # - Code has changed in upnp\ndnl #\trevision: 0 -> 1\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:5:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [5:1:2])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [4:1:0])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.9:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in threadutil\ndnl #\trevision: 1 -> 2\ndnl # - Code has changed in upnp\ndnl #\trevision: 1 -> 2\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:5:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [5:2:2])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [4:2:0])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.10:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in ixml \ndnl #\trevision: 5 -> 6\ndnl # - Code has changed in threadutil\ndnl #\trevision: 2 -> 3\ndnl # - Code has changed in upnp\ndnl #\trevision: 2 -> 3\ndnl # - interface has changed in upnp\ndnl #   current: 4 -> 5\ndnl #   revision: 3 -> 0\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:6:0])\ndnl ############################################################################\ndnl # Release 1.6.11:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in threadutil\ndnl #\trevision: 3 -> 4\ndnl # - Code has changed in upnp\ndnl #\trevision: 3 -> 4\ndnl # - interface has changed in upnp\ndnl #   current: 5 -> 6\ndnl #   revision: 4 -> 0\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:6:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [5:4:2])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [6:0:0])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.12:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - interface added in threadutil\ndnl #   current: 5 -> 6\ndnl #   revision: 4 - > 0\ndnl #   age: 2 -> 3\ndnl # - interfaces removed in threadutil\ndnl #   age: 3 -> 0\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:6:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [6:0:0])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [6:0:0])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.13:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in upnp\ndnl #\trevision: 0 -> 1\ndnl # - interface added in upnp\ndnl #   current: 6 -> 7\ndnl #   revision: 1 - > 0\ndnl #   age: 0 -> 1\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:6:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [6:0:0])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [7:0:1])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.14:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in upnp\ndnl #\trevision: 0 -> 1\ndnl # - interface added in upnp\ndnl #   current: 7 -> 8\ndnl #   revision: 1 - > 0\ndnl #   age: 1 -> 2\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:6:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [6:0:0])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [8:0:2])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.15:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in upnp\ndnl #\trevision: 0 -> 1\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:6:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [6:0:0])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [8:1:2])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.16:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in ixml\ndnl #\trevision: 6 -> 7\ndnl # - Code has changed in threadutil\ndnl #   revision: 0 -> 1\ndnl # - Code has changed in upnp\ndnl #\trevision: 1 -> 2\ndnl # - interface changed/added/removed in upnp\ndnl #   current++(9); revision = 0\ndnl # - interface added in upnp\ndnl #   age++(3)\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:7:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [6:1:0])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [9:0:3])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.17:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Code has changed in threadutil\ndnl #   revision: 1 -> 2\ndnl # - Code has changed in upnp\ndnl #   revision: 0 -> 1\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [2:7:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [6:2:0])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [9:1:3])\ndnl #\ndnl ############################################################################\ndnl # Release 1.6.18:\ndnl # \"current:revision:age\"\ndnl #\ndnl # -\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [::])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [::])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [::])\ndnl #\ndnl ############################################################################\ndnl # Release 1.8.0:\ndnl # \"current:revision:age\"\ndnl #\ndnl # - Start from a new ground.\ndnl #\ndnl #AC_SUBST([LT_VERSION_IXML],       [10:0:0])\ndnl #AC_SUBST([LT_VERSION_THREADUTIL], [10:0:0])\ndnl #AC_SUBST([LT_VERSION_UPNP],       [10:0:0])\ndnl #\ndnl ############################################################################\nAC_SUBST([LT_VERSION_IXML],       [10:0:0])\nAC_SUBST([LT_VERSION_THREADUTIL], [10:0:0])\nAC_SUBST([LT_VERSION_UPNP],       [10:0:0])\ndnl ############################################################################\ndnl # Repeating the algorithm to place it closer to the modificatin place:\ndnl # \t- library code modified:\t\trevision++\ndnl # \t- interfaces changed/added/removed:\tcurrent++ and revision=0\ndnl # \t- interfaces added: \t\t\tage++\ndnl # \t- interfaces removed:\t\t\tage=0\ndnl # *please update only once, before a formal release, not for each change*\ndnl ############################################################################\n\n\nAC_CONFIG_AUX_DIR([build-aux])\nAC_CONFIG_MACRO_DIR([m4])\nAC_CONFIG_SRCDIR([upnp/inc/upnp.h])\n\n\nAM_INIT_AUTOMAKE([1.8 -Wall foreign subdir-objects dist-bzip2])\n\n\n#\n# Get canonical host names in host and host_os\n#\nAC_CANONICAL_HOST\n\n#\n# There are 3 configuration files :\n# 1) \"./autoconfig.h\" is auto-generated and used only internally during build\n#    (usually named \"config.h\" but conflicts with the file below)\n# 2) \"./upnp/src/inc/config.h\" is static and contains some compile-time \n#    parameters. This file was previously in \"./upnp/inc\" but is no longer \n#    installed (contains internal definitions only).\n# 3) \"./upnp/inc/upnpconfig.h\" is auto-generated and installed with the \n#    libraries : it contains information on the configuration of the\n#    installed libraries.\n#\nAC_CONFIG_HEADERS([autoconfig.h upnp/inc/upnpconfig.h])\n#AC_SYS_LARGEFILE_SENSITIVE\n\nAC_REVISION([$Revision: 1.11 $])\n\nupnpmaj=`echo \"$PACKAGE_VERSION\" | sed 's/\\..*//' `\nupnpmin=[`echo \"$PACKAGE_VERSION\" | sed 's/^[^.]\\.// ; s/[^0-9].*$//' `]\nupnppatch=[`echo \"$PACKAGE_VERSION\" | sed 's/^[^.]\\.[^.]\\.// ; s/[^0-9].*$//' `]\nAC_DEFINE_UNQUOTED([UPNP_VERSION_STRING], \"$PACKAGE_VERSION\", [see upnpconfig.h])\nAC_DEFINE_UNQUOTED([UPNP_VERSION_MAJOR], $upnpmaj, [see upnpconfig.h])\nAC_DEFINE_UNQUOTED([UPNP_VERSION_MINOR], $upnpmin, [see upnpconfig.h])\nAC_DEFINE_UNQUOTED([UPNP_VERSION_PATCH], $upnppatch, [see upnpconfig.h])\n\n\n#\n# Check for DEBUG flag\n#\nRT_BOOL_ARG_ENABLE([debug], [no], [extra debugging code])\nif test \"x$enable_debug\" = xyes ; then\n\tAC_DEFINE(UPNP_HAVE_DEBUG, 1, [see upnpconfig.h])\n\tAC_DEFINE(DEBUG, 1, [Define to 1 to compile debug code])\nelse\n\tAC_DEFINE(NO_DEBUG, 1, [Define to 1 to prevent some debug code])\n\tAC_DEFINE(NDEBUG, 1, [Define to 1 to prevent compilation of assert()])\nfi\n\n\n#\n# Check for libupnp subsets\n#\nRT_BOOL_ARG_ENABLE([client], [yes], [control point code (client)])\nif test \"x$enable_client\" = xyes ; then\n\tAC_DEFINE(UPNP_HAVE_CLIENT, 1, [see upnpconfig.h])\nfi\n\n\nRT_BOOL_ARG_ENABLE([device], [yes],\n     [device specific code (implies --disable-webserver if disabled)])\nif test \"x$enable_device\" = xyes ; then\n\tAC_DEFINE(UPNP_HAVE_DEVICE, 1, [see upnpconfig.h])\nfi\n\n\nif test \"x$enable_device\" = xno ; then \n\tenable_webserver=no\nelse \n\tRT_BOOL_ARG_ENABLE([webserver], [yes], [integrated web server])\nfi\nAM_CONDITIONAL(ENABLE_WEBSERVER, test x\"$enable_webserver\" = xyes)\nif test \"x$enable_webserver\" = xyes ; then\n\tAC_DEFINE(UPNP_HAVE_WEBSERVER, 1, [see upnpconfig.h])\nfi\n\nRT_BOOL_ARG_ENABLE([ssdp], [yes], [SSDP part])\nif test \"x$enable_ssdp\" = xyes ; then\n        AC_DEFINE(UPNP_HAVE_SSDP, 1, [see upnpconfig.h])\nfi\n\nRT_BOOL_ARG_ENABLE([optssdp], [yes], [optionnal SSDP headers support)])\nif test \"x$enable_optssdp\" = xyes ; then\n        AC_DEFINE(UPNP_HAVE_OPTSSDP, 1, [see upnpconfig.h])\n\tenable_uuid=yes\nfi\n\nRT_BOOL_ARG_ENABLE([soap], [yes], [SOAP part])\nif test \"x$enable_soap\" = xyes ; then\n        AC_DEFINE(UPNP_HAVE_SOAP, 1, [see upnpconfig.h])\nfi\n\nRT_BOOL_ARG_ENABLE([gena], [yes], [GENA part])\nif test \"x$enable_gena\" = xyes ; then\n        AC_DEFINE(UPNP_HAVE_GENA, 1, [see upnpconfig.h])\n\tenable_uuid=yes\nfi\n\nAM_CONDITIONAL(ENABLE_UUID, test x\"$enable_uuid\" = xyes)\n\nRT_BOOL_ARG_ENABLE([tools], [yes], [helper APIs in upnptools.h])\nif test \"x$enable_tools\" = xyes ; then\n\tAC_DEFINE(UPNP_HAVE_TOOLS, 1, [see upnpconfig.h])\nfi\n\nRT_BOOL_ARG_ENABLE([ipv6], [no], [ipv6 support])\nif test \"x$enable_ipv6\" = xyes ; then\n        AC_DEFINE(UPNP_ENABLE_IPV6, 1, [see upnpconfig.h])\nfi\n\nRT_BOOL_ARG_ENABLE([unspecified_server], [no], [unspecified SERVER header])\nif test \"x$enable_unspecified_server\" = xyes ; then\n        AC_DEFINE(UPNP_ENABLE_UNSPECIFIED_SERVER, 1, [see upnpconfig.h])\nfi\n\nRT_BOOL_ARG_ENABLE([open_ssl], [no], [open-ssl support])\nif test \"x$enable_open_ssl\" = xyes ; then\n        AC_DEFINE(UPNP_ENABLE_OPEN_SSL, 1, [see upnpconfig.h])\nfi\n\nRT_BOOL_ARG_ENABLE([notification_reordering], [yes], [GENA notification reordering in gena_device.c])\nif test \"x$enable_notification_reordering\" = xyes ; then\n        AC_DEFINE(UPNP_ENABLE_NOTIFICATION_REORDERING, 1, [see upnpconfig.h])\nfi\n\nRT_BOOL_ARG_ENABLE([blocking_tcp_connections], [yes], [blocking TCP connections])\nif test \"x$enable_blocking_tcp_connections\" = xyes ; then\n        AC_DEFINE(UPNP_ENABLE_BLOCKING_TCP_CONNECTIONS, 1, [see upnpconfig.h])\nfi\n\nRT_BOOL_ARG_ENABLE([scriptsupport], [yes], [script support for IXML document tree, see ixml.h])\nif test \"x$enable_scriptsupport\" = xyes ; then\n        AC_DEFINE(IXML_HAVE_SCRIPTSUPPORT, 1, [see upnpconfig.h])\nfi\n\nRT_BOOL_ARG_ENABLE([postwrite], [no], [write to the filesystem on otherwise unhandled POST requests])\nif test \"x$enable_postwrite\" = xyes ; then\n        AC_DEFINE(UPNP_ENABLE_POST_WRITE, 1, [see upnpconfig.h])\nfi\n\nRT_BOOL_ARG_ENABLE([samples], [yes], [compilation of upnp/sample/ code])\n\n\n#\n# doc installation\n# autoconf >= 2.60 already defines ${docdir}, but we will not use its \n# default value, which is ${datarootdir}/doc/${PACKAGE_TARNAME}.\n# That would give us ${datarootdir}/doc/libupnp, and we want the package\n# version on that.\n#\ndocdir=\"${datadir}/doc/${PACKAGE_NAME}-${PACKAGE_VERSION}\"\nAC_MSG_CHECKING([for documentation directory])\nAC_ARG_WITH(\n\t[documentation], \n\tAS_HELP_STRING(\n\t\t[--with-documentation=directory_name],\n\t\t[where documentation is installed \n\t\t @<:@[DATADIR/doc/]AC_PACKAGE_NAME[-]AC_PACKAGE_VERSION@:>@])\nAS_HELP_STRING(\n\t\t[--without-documentation],\n\t\t[do not install the documentation]),\n\t[],\n\t[with_documentation=no])\n\n#\n# If something has been entered after an equal sign, assume it is the directory\n#\nif test x\"$with_documentation\" != xyes -a x\"$with_documentation\" != xno; then\n\tdocdir=\"$with_documentation\"\nfi\nAM_CONDITIONAL(WITH_DOCUMENTATION, test x\"$with_documentation\" != xno)\nAC_SUBST(docdir)\nAC_MSG_RESULT($docdir)\n\n\n#\n# Checks for programs\n#\nAC_PROG_CC\nAM_PROG_CC_C_O\nm4_ifdef([AM_PROG_AR], [AM_PROG_AR])\nAC_PROG_LIBTOOL\nAC_PROG_INSTALL\nAC_PROG_MAKE_SET\nAC_PROG_EGREP\n\n#\n# Default compilation flags\n#\necho \"--------------------- Default compilation flags -------------------------------\"\necho host is $host\necho host_os is $host_os\ncase $host_os in\nfreebsd*)\n\techo \"Using FreeBSD specific compiler settings\"\n\t# Put FreeBSD specific compiler flags here\n\t;;\n*)\n\techo \"Using non-specific system compiler settings\"\n\tif test x\"$enable_debug\" = xyes; then\n\t\t# AC_PROG_CC already sets CFLAGS to \"-g -O2\" by default,\n\t\t# but only if CFLAGS was not previously set.\n\t\t#:\n\t\t# Use -O0 in debug so that variables do not get optimized out\n\t\tAX_CFLAGS_GCC_OPTION([-O0, -g])\n\telse\n\t\t# add optimise for size\n\t\tAX_CFLAGS_GCC_OPTION([-Os])\n\tfi\n\t;;\nesac\n\nAX_CFLAGS_WARN_ALL\necho \"-------------------------------------------------------------------------------\"\n\n\n#\n# Lot's of stuff to ensure large file support\n#\nAC_TYPE_SIZE_T\nAC_TYPE_OFF_T\nAC_DEFINE([_LARGE_FILE_SOURCE], [], [Large files support])\nAC_DEFINE([_FILE_OFFSET_BITS], [64], [File Offset size])\n\n\n#\n# Are we targetting Win32?\n#\nAC_MSG_CHECKING([for Win32])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([\n#ifdef WIN32\n\t#error Yup\n#endif\n],[])], [ac_cv_win32=\"no\"], [ac_cv_win32=\"yes\"])\nif test \"$ac_cv_win32\" = \"yes\"; then\n\tAC_MSG_RESULT([yes])\nelse\n\tAC_MSG_RESULT([no])\nfi\n\n\n#\n# Checks for header files (which aren't needed on Win32)\n#\nAC_HEADER_STDC\nif test \"$ac_cv_win32\" = \"no\"; then\n# libupnp code doesn't use autoconf variables yet,\n# so just abort if a header file is not found.\nAC_CHECK_HEADERS(\n\t[ \\\n\tarpa/inet.h \\\n\tfcntl.h \\\n\tinttypes.h \\\n\tlimits.h \\\n\tnetdb.h \\\n\tnetinet/in.h \\\n\tstdlib.h \\\n\tstring.h \\\n\tsys/ioctl.h \\\n\tsys/socket.h \\\n\tsys/time.h \\\n\tsyslog.h \\\n\tunistd.h \\\n\t],\n\t[],\n\t[AC_MSG_ERROR([required header file missing])])\nfi\n\n\n#\n# Checks for typedefs, structures, and compiler characteristics\n#\t\nAC_C_CONST\n\n# The test for socklen_t was getting it wrong when it exists but is in ws2tcpip.h,\n# so we use a new test.\n#TYPE_SOCKLEN_T\n\nAC_CHECK_HEADERS([sys/types.h sys/socket.h ws2tcpip.h])\nAC_MSG_CHECKING(for socklen_t)\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([\n#ifdef HAVE_SYS_TYPES_H\n\t#include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_SOCKET_H\n\t#include <sys/socket.h>\n#endif\n#ifdef HAVE_WS2TCPIP_H\n\t#include <ws2tcpip.h>\n#endif\n],[ socklen_t t = 0; return t; ])\n],[ac_cv_socklen_t=\"yes\"],[ac_cv_socklen_t=\"no\"])\nif test \"$ac_cv_socklen_t\" = \"yes\"; then\n\tAC_MSG_RESULT([yes])\nelse\n\tAC_MSG_RESULT([no, using int])\n\tAC_DEFINE(socklen_t, int, [Type for storing the length of struct sockaddr])\nfi\n\n\n#\n# Checks for library functions\n#\nAC_FUNC_VPRINTF\nAC_FUNC_FSEEKO\nAC_CHECK_FUNC(strnlen,\n\tAC_DEFINE(HAVE_STRNLEN, 1, [Defines if strnlen is available on your system]))\nAC_CHECK_FUNC(strndup,\n\tAC_DEFINE(HAVE_STRNDUP, 1, [Defines if strndup is available on your system]))\n#\n# Solaris needs -lsocket -lnsl -lrt\nAC_SEARCH_LIBS([bind],           [socket])\nAC_SEARCH_LIBS([gethostbyname],  [nsl])\nAC_SEARCH_LIBS([sched_getparam], [rt])\n\n\n#\n# Checks for POSIX Threads\n#\necho \"--------------------------- pthread stuff -------------------------------------\"\nACX_PTHREAD(\n\t[],\n\t[AC_MSG_ERROR([POSIX threads are required to build this program])])\n#\n# Update environment variables for pthreads\n#\nCC=\"$PTHREAD_CC\"\nCFLAGS=\"$PTHREAD_CFLAGS $CFLAGS\"\nLIBS=\"$PTHREAD_LIBS $LIBS\"\n#\n# Determine if pthread_rwlock_t is available\n#\necho \"----------------------- pthread_rwlock_t stuff --------------------------------\"\nAC_MSG_CHECKING([if pthread_rwlock_t is available])\nAC_LANG([C])\nAC_COMPILE_IFELSE(\n\t[AC_LANG_PROGRAM(\n\t\t[#include <pthread.h>],\n\t\t[pthread_rwlock_t *x;])],\n\t[AC_DEFINE([UPNP_USE_RWLOCK], [1], [Use pthread_rwlock_t])\n\t\tAC_MSG_RESULT([yes, supported without any options])],\n\t[AC_COMPILE_IFELSE(\n\t\t[AC_LANG_PROGRAM(\n\t\t\t[#define _GNU_SOURCE\n\t\t\t#include <pthread.h>],\n\t\t\t[pthread_rwlock_t *x;])],\n\t\t[AC_DEFINE([UPNP_USE_RWLOCK], [1], [Use pthread_rwlock_t])\n\t\t\tCPPFLAGS=\"$CPPFLAGS -D_GNU_SOURCE\"\n\t\t\tAC_MSG_RESULT([yes, definition of _GNU_SOURCE required])],\n\t\t[AC_DEFINE([UPNP_USE_RWLOCK], [0], [Do not use pthread_rwlock_t])\n\t\t\tAC_MSG_RESULT([no, needs to fallback to pthread_mutex])\n\t\t\tAC_MSG_ERROR([pthread_rwlock_t not available])])])\necho \"-------------------------------------------------------------------------------\"\n\n\nAC_CONFIG_FILES([\n\tMakefile\n\tixml/Makefile\n\tixml/doc/Makefile\n\tthreadutil/Makefile\n\tupnp/Makefile\n\tupnp/doc/Makefile\n\tupnp/sample/Makefile\n\tupnp/unittest/Makefile\n\tdocs/dist/Makefile\n\tlibupnp.pc\n\t])\n\n\nAC_OUTPUT\n\n#\n# Files copied for windows compilation.\n#\necho \"configure: copying \\\"autoconfig.h\\\"          to \\\"build/inc/autoconfig.h\\\"\"\ntest -d build/inc || mkdir -p build/inc\ncp autoconfig.h build/inc/autoconfig.h\necho \"configure: copying \\\"upnp/inc/upnpconfig.h\\\" to \\\"build/inc/upnpconfig.h\\\"\"\ncp upnp/inc/upnpconfig.h build/inc/upnpconfig.h\n\n", "/* -*- C -*- */\n/*******************************************************************************\n *\n * Copyright (c) 2006 R\u00e9mi Turboult <r3mi@users.sourceforge.net>\n * All rights reserved. \n *\n * Redistribution and use in source and binary forms, with or without \n * modification, are permitted provided that the following conditions are met: \n *\n * * Redistributions of source code must retain the above copyright notice, \n * this list of conditions and the following disclaimer. \n * * Redistributions in binary form must reproduce the above copyright notice, \n * this list of conditions and the following disclaimer in the documentation \n * and/or other materials provided with the distribution. \n * * Neither name of Intel Corporation nor the names of its contributors \n * may be used to endorse or promote products derived from this software \n * without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR \n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR \n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, \n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, \n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR \n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY \n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS \n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n ******************************************************************************/\n\n#ifndef UPNP_CONFIG_H\n#define UPNP_CONFIG_H \n\n\n/***************************************************************************\n * Library version \n ***************************************************************************/ \n\n/** The library version (string) e.g. \"1.3.0\" */\n#undef UPNP_VERSION_STRING\n\n/** Major version of the library */\n#undef UPNP_VERSION_MAJOR\n\n/** Minor version of the library */\n#undef UPNP_VERSION_MINOR\n\n/** Patch version of the library */\n#undef UPNP_VERSION_PATCH\n\n/** The library version (numeric) e.g. 10300 means version 1.3.0 */\n#define UPNP_VERSION\t\\\n  ((UPNP_VERSION_MAJOR * 100 + UPNP_VERSION_MINOR) * 100 + UPNP_VERSION_PATCH)\n\n\n\n/***************************************************************************\n * Large file support\n ***************************************************************************/\n\n/** File Offset size */\n#undef _FILE_OFFSET_BITS\n\n/** Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */\n#undef _LARGEFILE_SOURCE\n\n/** Large files support */\n#undef _LARGE_FILE_SOURCE\n\n/***************************************************************************\n * Library optional features\n ***************************************************************************/\n\n/*\n * The following defines can be tested in order to know which \n * optional features have been included in the installed library.\n */\n\n\n/** Defined to 1 if the library has been compiled with DEBUG enabled \n *  (i.e. configure --enable-debug) : <upnp/upnpdebug.h> file is available */\n#undef UPNP_HAVE_DEBUG\n\n\n/** Defined to 1 if the library has been compiled with client API enabled \n *  (i.e. configure --enable-client) */\n#undef UPNP_HAVE_CLIENT\n\n\n/** Defined to 1 if the library has been compiled with device API enabled \n *  (i.e. configure --enable-device) */\n#undef UPNP_HAVE_DEVICE\n\n\n/** Defined to 1 if the library has been compiled with integrated web server\n *  (i.e. configure --enable-webserver --enable-device) */\n#undef UPNP_HAVE_WEBSERVER\n\n\n/** Defined to 1 if the library has been compiled with the SSDP part enabled\n *  (i.e. configure --enable-ssdp) */\n#undef UPNP_HAVE_SSDP\n\n\n/** Defined to 1 if the library has been compiled with optional SSDP headers\n *  support (i.e. configure --enable-optssdp) */\n#undef UPNP_HAVE_OPTSSDP\n\n\n/** Defined to 1 if the library has been compiled with the SOAP part enabled\n *  (i.e. configure --enable-soap) */\n#undef UPNP_HAVE_SOAP\n\n\n/** Defined to 1 if the library has been compiled with the GENA part enabled\n *  (i.e. configure --enable-gena) */\n#undef UPNP_HAVE_GENA\n\n\n/** Defined to 1 if the library has been compiled with helper API\n *  (i.e. configure --enable-tools) : <upnp/upnptools.h> file is available */\n#undef UPNP_HAVE_TOOLS\n\n/** Defined to 1 if the library has been compiled with ipv6 support\n *  (i.e. configure --enable-ipv6) */\n#undef UPNP_ENABLE_IPV6\n\n/** Defined to 1 if the library has been compiled with unspecified SERVER\n * header (i.e. configure --enable-unspecified_server) */\n#undef UPNP_ENABLE_UNSPECIFIED_SERVER\n\n/** Defined to 1 if the library has been compiled with OpenSSL support\n *  (i.e. configure --enable-open_ssl) */\n#undef UPNP_ENABLE_OPEN_SSL\n\n/** Defined to 1 if the library has been compiled to support filesystem writes on POST\n *  (i.e. configure --enable-postwrite) */\n#undef UPNP_ENABLE_POST_WRITE\n\n\n#endif /* UPNP_CONFIG_H */\n\n", "/**************************************************************************\n *\n * Copyright (c) 2000-2003 Intel Corporation \n * All rights reserved. \n * Copyright (c) 2012 France Telecom All rights reserved. \n *\n * Redistribution and use in source and binary forms, with or without \n * modification, are permitted provided that the following conditions are met: \n *\n * - Redistributions of source code must retain the above copyright notice, \n * this list of conditions and the following disclaimer. \n * - Redistributions in binary form must reproduce the above copyright notice, \n * this list of conditions and the following disclaimer in the documentation \n * and/or other materials provided with the distribution. \n * - Neither name of Intel Corporation nor the names of its contributors \n * may be used to endorse or promote products derived from this software \n * without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR \n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR \n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, \n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, \n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR \n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY \n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS \n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n **************************************************************************/\n\n/*!\n * \\file\n *\n * \\brief Defines the Web Server and has functions to carry out\n * operations of the Web Server.\n */\n\n#include \"config.h\"\n\n#if EXCLUDE_WEB_SERVER == 0\n\n#include \"webserver.h\"\n\n\n#include \"FileInfo.h\"\n#include \"httpparser.h\"\n#include \"httpreadwrite.h\"\n#include \"ithread.h\"\n#include \"membuffer.h\"\n#include \"ssdplib.h\"\n#include \"statcodes.h\"\n#include \"strintmap.h\"\n#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"upnpapi.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpStdInt.h\"\n#include \"upnputil.h\"\n#include \"VirtualDir.h\"\n\n#include <assert.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n\n#ifdef WIN32\n\t #define snprintf _snprintf\n#endif\n\n/*!\n * Response Types.\n */\nenum resp_type {\n\tRESP_FILEDOC,\n\tRESP_XMLDOC,\n\tRESP_HEADERS,\n\tRESP_WEBDOC,\n\tRESP_POST\n};\n\n/* mapping of file extension to content-type of document */\nstruct document_type_t {\n\t/*! . */\n\tconst char *file_ext;\n\t/*! . */\n\tconst char *content_type;\n\t/*! . */\n\tconst char *content_subtype;\n};\n\nstruct xml_alias_t {\n\t/*! name of DOC from root; e.g.: /foo/bar/mydesc.xml */\n\tmembuffer name;\n\t/*! the XML document contents */\n\tmembuffer doc;\n\t/*! . */\n\ttime_t last_modified;\n\t/*! . */\n\tint *ct;\n};\n\nstatic const char *gMediaTypes[] = {\n\t/*! 0. */\n\tNULL,\n\t/*! 1. */\n\t\"audio\",\n\t/*! 2. */\n\t\"video\",\n\t/*! 3. */\n\t\"image\",\n\t/*! 4. */\n\t\"application\",\n\t/*! 5. */\n\t\"text\"\n};\n\n/*\n * Defines.\n */\n\n/* index into 'gMediaTypes' */\n#define AUDIO_STR        \"\\1\"\n#define VIDEO_STR        \"\\2\"\n#define IMAGE_STR        \"\\3\"\n#define APPLICATION_STR  \"\\4\"\n#define TEXT_STR         \"\\5\"\n\n/* int index */\n#define APPLICATION_INDEX 4\n#define TEXT_INDEX        5\n\n/* general */\n#define NUM_MEDIA_TYPES       70\n#define NUM_HTTP_HEADER_NAMES 33\n\n#define ASCTIME_R_BUFFER_SIZE 26\n#ifdef WIN32\nstatic char *web_server_asctime_r(const struct tm *tm, char *buf)\n{\n\tif (tm == NULL || buf == NULL)\n\t\treturn NULL;\n\n\tasctime_s(buf, ASCTIME_R_BUFFER_SIZE, tm);\n\treturn buf;\n}\n#else\n#define web_server_asctime_r asctime_r\n#endif\n\n/* sorted by file extension; must have 'NUM_MEDIA_TYPES' extensions */\nstatic const char *gEncodedMediaTypes =\n\t\"aif\\0\" AUDIO_STR \"aiff\\0\"\n\t\"aifc\\0\" AUDIO_STR \"aiff\\0\"\n\t\"aiff\\0\" AUDIO_STR \"aiff\\0\"\n\t\"asf\\0\" VIDEO_STR \"x-ms-asf\\0\"\n\t\"asx\\0\" VIDEO_STR \"x-ms-asf\\0\"\n\t\"au\\0\" AUDIO_STR \"basic\\0\"\n\t\"avi\\0\" VIDEO_STR \"msvideo\\0\"\n\t\"bmp\\0\" IMAGE_STR \"bmp\\0\"\n\t\"css\\0\" TEXT_STR \"css\\0\"\n\t\"dcr\\0\" APPLICATION_STR \"x-director\\0\"\n\t\"dib\\0\" IMAGE_STR \"bmp\\0\"\n\t\"dir\\0\" APPLICATION_STR \"x-director\\0\"\n\t\"dxr\\0\" APPLICATION_STR \"x-director\\0\"\n\t\"gif\\0\" IMAGE_STR \"gif\\0\"\n\t\"hta\\0\" TEXT_STR \"hta\\0\"\n\t\"htm\\0\" TEXT_STR \"html\\0\"\n\t\"html\\0\" TEXT_STR \"html\\0\"\n\t\"jar\\0\" APPLICATION_STR \"java-archive\\0\"\n\t\"jfif\\0\" IMAGE_STR \"pjpeg\\0\"\n\t\"jpe\\0\" IMAGE_STR \"jpeg\\0\"\n\t\"jpeg\\0\" IMAGE_STR \"jpeg\\0\"\n\t\"jpg\\0\" IMAGE_STR \"jpeg\\0\"\n\t\"js\\0\" APPLICATION_STR \"x-javascript\\0\"\n\t\"kar\\0\" AUDIO_STR \"midi\\0\"\n\t\"m3u\\0\" AUDIO_STR \"mpegurl\\0\"\n\t\"mid\\0\" AUDIO_STR \"midi\\0\"\n\t\"midi\\0\" AUDIO_STR \"midi\\0\"\n\t\"mov\\0\" VIDEO_STR \"quicktime\\0\"\n\t\"mp2v\\0\" VIDEO_STR \"x-mpeg2\\0\"\n\t\"mp3\\0\" AUDIO_STR \"mpeg\\0\"\n\t\"mpe\\0\" VIDEO_STR \"mpeg\\0\"\n\t\"mpeg\\0\" VIDEO_STR \"mpeg\\0\"\n\t\"mpg\\0\" VIDEO_STR \"mpeg\\0\"\n\t\"mpv\\0\" VIDEO_STR \"mpeg\\0\"\n\t\"mpv2\\0\" VIDEO_STR \"x-mpeg2\\0\"\n\t\"pdf\\0\" APPLICATION_STR \"pdf\\0\"\n\t\"pjp\\0\" IMAGE_STR \"jpeg\\0\"\n\t\"pjpeg\\0\" IMAGE_STR \"jpeg\\0\"\n\t\"plg\\0\" TEXT_STR \"html\\0\"\n\t\"pls\\0\" AUDIO_STR \"scpls\\0\"\n\t\"png\\0\" IMAGE_STR \"png\\0\"\n\t\"qt\\0\" VIDEO_STR \"quicktime\\0\"\n\t\"ram\\0\" AUDIO_STR \"x-pn-realaudio\\0\"\n\t\"rmi\\0\" AUDIO_STR \"mid\\0\"\n\t\"rmm\\0\" AUDIO_STR \"x-pn-realaudio\\0\"\n\t\"rtf\\0\" APPLICATION_STR \"rtf\\0\"\n\t\"shtml\\0\" TEXT_STR \"html\\0\"\n\t\"smf\\0\" AUDIO_STR \"midi\\0\"\n\t\"snd\\0\" AUDIO_STR \"basic\\0\"\n\t\"spl\\0\" APPLICATION_STR \"futuresplash\\0\"\n\t\"ssm\\0\" APPLICATION_STR \"streamingmedia\\0\"\n\t\"swf\\0\" APPLICATION_STR \"x-shockwave-flash\\0\"\n\t\"tar\\0\" APPLICATION_STR \"tar\\0\"\n\t\"tcl\\0\" APPLICATION_STR \"x-tcl\\0\"\n\t\"text\\0\" TEXT_STR \"plain\\0\"\n\t\"tif\\0\" IMAGE_STR \"tiff\\0\"\n\t\"tiff\\0\" IMAGE_STR \"tiff\\0\"\n\t\"txt\\0\" TEXT_STR \"plain\\0\"\n\t\"ulw\\0\" AUDIO_STR \"basic\\0\"\n\t\"wav\\0\" AUDIO_STR \"wav\\0\"\n\t\"wax\\0\" AUDIO_STR \"x-ms-wax\\0\"\n\t\"wm\\0\" VIDEO_STR \"x-ms-wm\\0\"\n\t\"wma\\0\" AUDIO_STR \"x-ms-wma\\0\"\n\t\"wmv\\0\" VIDEO_STR \"x-ms-wmv\\0\"\n\t\"wvx\\0\" VIDEO_STR \"x-ms-wvx\\0\"\n\t\"xbm\\0\" IMAGE_STR \"x-xbitmap\\0\"\n\t\"xml\\0\" TEXT_STR \"xml\\0\"\n\t\"xsl\\0\" TEXT_STR \"xml\\0\"\n\t\"z\\0\" APPLICATION_STR \"x-compress\\0\"\n\t\"zip\\0\" APPLICATION_STR \"zip\\0\" \"\\0\";\n/* *** end *** */\n\n/*!\n * module variables - Globals, static and externs.\n */\n\nstatic struct document_type_t gMediaTypeList[NUM_MEDIA_TYPES];\n\n/*! Global variable. A local dir which serves as webserver root. */\nmembuffer gDocumentRootDir;\n\n/*! XML document. */\nstatic struct xml_alias_t gAliasDoc;\nstatic ithread_mutex_t gWebMutex;\nextern str_int_entry Http_Header_Names[NUM_HTTP_HEADER_NAMES];\n\n/*!\n * \\brief Decodes list and stores it in gMediaTypeList.\n */\nstatic UPNP_INLINE void media_list_init(void)\n{\n\tint i;\n\tconst char *s = gEncodedMediaTypes;\n\tstruct document_type_t *doc_type;\n\n\tfor (i = 0; *s != '\\0'; i++) {\n\t\tdoc_type = &gMediaTypeList[i];\n\t\tdoc_type->file_ext = s;\n\t\t/* point to type. */\n\t\ts += strlen(s) + 1;\n\t\tdoc_type->content_type = gMediaTypes[(int)*s];\n\t\t/* point to subtype. */\n\t\ts++;\n\t\tdoc_type->content_subtype = s;\n\t\t/* next entry. */\n\t\ts += strlen(s) + 1;\n\t}\n\tassert(i == NUM_MEDIA_TYPES);\n}\n\n/*!\n * \\brief Based on the extension, returns the content type and content\n * subtype.\n *\n * \\return\n * \\li \\c 0 on success\n * \\li \\c -1 on error\n */\nstatic UPNP_INLINE int search_extension(\n\t/*! [in] . */\n\tconst char *extension,\n\t/*! [out] . */\n\tconst char **con_type,\n\t/*! [out] . */\n\tconst char **con_subtype)\n{\n\tint top, mid, bot;\n\tint cmp;\n\n\ttop = 0;\n\tbot = NUM_MEDIA_TYPES - 1;\n\n\twhile (top <= bot) {\n\t\tmid = (top + bot) / 2;\n\t\tcmp = strcasecmp(extension, gMediaTypeList[mid].file_ext);\n\t\tif (cmp > 0) {\n\t\t\t/* look below mid. */\n\t\t\ttop = mid + 1;\n\t\t} else if (cmp < 0) {\n\t\t\t/* look above mid. */\n\t\t\tbot = mid - 1;\n\t\t} else {\n\t\t\t/* cmp == 0 */\n\t\t\t*con_type = gMediaTypeList[mid].content_type;\n\t\t\t*con_subtype = gMediaTypeList[mid].content_subtype;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/*!\n * \\brief Based on the extension, clones an XML string based on type and\n * content subtype. If content type and sub type are not found, unknown\n * types are used.\n *\n * \\return\n * \\li \\c 0 on success.\n * \\li \\c UPNP_E_OUTOF_MEMORY - on memory allocation failures.\n */\nstatic UPNP_INLINE int get_content_type(\n\t/*! [in] . */\n\tconst char *filename,\n\t/*! [out] . */\n\tOUT UpnpFileInfo *fileInfo)\n{\n\tconst char *extension;\n\tconst char *type;\n\tconst char *subtype;\n\tint ctype_found = FALSE;\n\tchar *temp = NULL;\n\tsize_t length = 0;\n\tint rc = 0;\n\n\tUpnpFileInfo_set_ContentType(fileInfo, NULL);\n\t/* get ext */\n\textension = strrchr(filename, '.');\n\tif (extension != NULL)\n\t\tif (search_extension(extension + 1, &type, &subtype) == 0)\n\t\t\tctype_found = TRUE;\n\tif (!ctype_found) {\n\t\t/* unknown content type */\n\t\ttype = gMediaTypes[APPLICATION_INDEX];\n\t\tsubtype = \"octet-stream\";\n\t}\n\tlength = strlen(type) + strlen(\"/\") + strlen(subtype) + 1;\n\ttemp = malloc(length);\n\tif (!temp)\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\trc = snprintf(temp, length, \"%s/%s\", type, subtype);\n\tif (rc < 0 || (unsigned int) rc >= length) {\n\t\tfree(temp);\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\tUpnpFileInfo_set_ContentType(fileInfo, temp);\n\tfree(temp);\n\tif (!UpnpFileInfo_get_ContentType(fileInfo))\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\n\treturn 0;\n}\n\n/*!\n * \\brief Initialize the global XML document. Allocate buffers for the XML\n * document.\n */\nstatic UPNP_INLINE void glob_alias_init(void)\n{\n\tstruct xml_alias_t *alias = &gAliasDoc;\n\n\tmembuffer_init(&alias->doc);\n\tmembuffer_init(&alias->name);\n\talias->ct = NULL;\n\talias->last_modified = 0;\n}\n\n/*!\n * \\brief Check for the validity of the XML object buffer.\n *\n * \\return BOOLEAN.\n */\nstatic UPNP_INLINE int is_valid_alias(\n\t/*! [in] XML alias object. */\n\tconst struct xml_alias_t *alias)\n{\n\treturn alias->doc.buf != NULL;\n}\n\n/*!\n * \\brief Copy the contents of the global XML document into the local output\n * parameter.\n */\nstatic void alias_grab(\n\t/*! [out] XML alias object. */\n\tstruct xml_alias_t *alias)\n{\n\tithread_mutex_lock(&gWebMutex);\n\tassert(is_valid_alias(&gAliasDoc));\n\tmemcpy(alias, &gAliasDoc, sizeof(struct xml_alias_t));\n\t*alias->ct = *alias->ct + 1;\n\tithread_mutex_unlock(&gWebMutex);\n}\n\n/*!\n * \\brief Release the XML document referred to by the input parameter. Free\n * the allocated buffers associated with this object.\n */\nstatic void alias_release(\n\t/*! [in] XML alias object. */\n\tstruct xml_alias_t *alias)\n{\n\tithread_mutex_lock(&gWebMutex);\n\t/* ignore invalid alias */\n\tif (!is_valid_alias(alias)) {\n\t\tithread_mutex_unlock(&gWebMutex);\n\t\treturn;\n\t}\n\tassert(*alias->ct > 0);\n\t*alias->ct -= 1;\n\tif (*alias->ct <= 0) {\n\t\tmembuffer_destroy(&alias->doc);\n\t\tmembuffer_destroy(&alias->name);\n\t\tfree(alias->ct);\n\t}\n\tithread_mutex_unlock(&gWebMutex);\n}\n\nint web_server_set_alias(const char *alias_name, \n\tconst char *alias_content, size_t alias_content_length,\n\ttime_t last_modified)\n{\n\tint ret_code;\n\tstruct xml_alias_t alias;\n\n\talias_release(&gAliasDoc);\n\tif (alias_name == NULL) {\n\t\t/* don't serve aliased doc anymore */\n\t\treturn 0;\n\t}\n\tassert(alias_content != NULL);\n\tmembuffer_init(&alias.doc);\n\tmembuffer_init(&alias.name);\n\talias.ct = NULL;\n\tdo {\n\t\t/* insert leading /, if missing */\n\t\tif (*alias_name != '/')\n\t\t\tif (membuffer_assign_str(&alias.name, \"/\") != 0)\n\t\t\t\tbreak;\t/* error; out of mem */\n\t\tret_code = membuffer_append_str(&alias.name, alias_name);\n\t\tif (ret_code != 0)\n\t\t\tbreak;\t/* error */\n\t\tif ((alias.ct = (int *)malloc(sizeof(int))) == NULL)\n\t\t\tbreak;\t/* error */\n\t\t*alias.ct = 1;\n\t\tmembuffer_attach(&alias.doc, (char *)alias_content,\n\t\t\t\t alias_content_length);\n\t\talias.last_modified = last_modified;\n\t\t/* save in module var */\n\t\tithread_mutex_lock(&gWebMutex);\n\t\tgAliasDoc = alias;\n\t\tithread_mutex_unlock(&gWebMutex);\n\n\t\treturn 0;\n\t} while (FALSE);\n\t/* error handler */\n\t/* free temp alias */\n\tmembuffer_destroy(&alias.name);\n\tmembuffer_destroy(&alias.doc);\n\tfree(alias.ct);\n\n\treturn UPNP_E_OUTOF_MEMORY;\n}\n\nint web_server_init()\n{\n\tint ret = 0;\n\n\tif (bWebServerState == WEB_SERVER_DISABLED) {\n\t\t/* decode media list */\n\t\tmedia_list_init();\n\t\tmembuffer_init(&gDocumentRootDir);\n\t\tglob_alias_init();\n\t\tpVirtualDirList = NULL;\n\n\t\t/* Initialize callbacks */\n\t\tvirtualDirCallback.get_info = NULL;\n\t\tvirtualDirCallback.open = NULL;\n\t\tvirtualDirCallback.read = NULL;\n\t\tvirtualDirCallback.write = NULL;\n\t\tvirtualDirCallback.seek = NULL;\n\t\tvirtualDirCallback.close = NULL;\n\n\t\tif (ithread_mutex_init(&gWebMutex, NULL) == -1)\n\t\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\telse\n\t\t\tbWebServerState = WEB_SERVER_ENABLED;\n\t}\n\n\treturn ret;\n}\n\nvoid web_server_destroy(void)\n{\n\tif (bWebServerState == WEB_SERVER_ENABLED) {\n\t\tmembuffer_destroy(&gDocumentRootDir);\n\t\talias_release(&gAliasDoc);\n\n\t\tithread_mutex_lock(&gWebMutex);\n\t\tmemset(&gAliasDoc, 0, sizeof(struct xml_alias_t));\n\t\tithread_mutex_unlock(&gWebMutex);\n\n\t\tithread_mutex_destroy(&gWebMutex);\n\t\tbWebServerState = WEB_SERVER_DISABLED;\n\t}\n}\n\n/*!\n * \\brief Release memory allocated for the global web server root directory\n * and the global XML document. Resets the flag bWebServerState to\n * WEB_SERVER_DISABLED.\n *\n * \\return Integer.\n */\nstatic int get_file_info(\n\t/*! [in] Filename having the description document. */\n\tconst char *filename,\n\t/*! [out] File information object having file attributes such as filelength,\n\t * when was the file last modified, whether a file or a directory and\n\t * whether the file or directory is readable. */\n\tOUT UpnpFileInfo *info)\n{\n\tint code;\n\tstruct stat s;\n\tFILE *fp;\n\tint rc = 0;\n\ttime_t aux_LastModified;\n\tstruct tm date;\n\tchar buffer[ASCTIME_R_BUFFER_SIZE];\n\n\tUpnpFileInfo_set_ContentType(info, NULL);\n\tcode = stat(filename, &s);\n\tif (code == -1)\n\t\treturn -1;\n\tif (S_ISDIR(s.st_mode))\n\t\tUpnpFileInfo_set_IsDirectory(info, TRUE);\n\telse if (S_ISREG(s.st_mode))\n\t\tUpnpFileInfo_set_IsDirectory(info, FALSE);\n\telse\n\t\treturn -1;\n\t/* check readable */\n\tfp = fopen(filename, \"r\");\n\tUpnpFileInfo_set_IsReadable(info, fp != NULL);\n\tif (fp)\n\t\tfclose(fp);\n\tUpnpFileInfo_set_FileLength(info, s.st_size);\n\tUpnpFileInfo_set_LastModified(info, s.st_mtime);\n\trc = get_content_type(filename, info);\n\taux_LastModified = UpnpFileInfo_get_LastModified(info);\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\"file info: %s, length: %lld, last_mod=%s readable=%d\\n\",\n\t\tfilename,\n\t\t(long long)UpnpFileInfo_get_FileLength(info),\n\t\tweb_server_asctime_r(http_gmtime_r(&aux_LastModified, &date), buffer),\n\t\tUpnpFileInfo_get_IsReadable(info));\n\n\treturn rc;\n}\n\nint web_server_set_root_dir(const char *root_dir)\n{\n\tsize_t index;\n\tint ret;\n\n\tret = membuffer_assign_str(&gDocumentRootDir, root_dir);\n\tif (ret != 0)\n\t\treturn ret;\n\t/* remove trailing '/', if any */\n\tif (gDocumentRootDir.length > 0) {\n\t\tindex = gDocumentRootDir.length - 1;\t/* last char */\n\t\tif (gDocumentRootDir.buf[index] == '/')\n\t\t\tmembuffer_delete(&gDocumentRootDir, index, 1);\n\t}\n\n\treturn 0;\n}\n\n/*!\n * \\brief Compare the files names between the one on the XML alias the one\n * passed in as the input parameter. If equal extract file information.\n *\n * \\return\n * \\li \\c TRUE - On Success\n * \\li \\c FALSE if request is not an alias\n */\nstatic UPNP_INLINE int get_alias(\n\t/*! [in] request file passed in to be compared with. */\n\tconst char *request_file,\n\t/*! [out] xml alias object which has a file name stored. */\n\tstruct xml_alias_t *alias,\n\t/*! [out] File information object which will be filled up if the file\n\t * comparison succeeds. */\n\tUpnpFileInfo *info)\n{\n\tint cmp = strcmp(alias->name.buf, request_file);\n\tif (cmp == 0) {\n\t\tUpnpFileInfo_set_FileLength(info, (off_t)alias->doc.length);\n\t\tUpnpFileInfo_set_IsDirectory(info, FALSE);\n\t\tUpnpFileInfo_set_IsReadable(info, TRUE);\n\t\tUpnpFileInfo_set_LastModified(info, alias->last_modified);\n\t}\n\n\treturn cmp == 0;\n}\n\n/*!\n * \\brief Compares filePath with paths from the list of virtual directory\n * lists.\n *\n * \\return BOOLEAN.\n */\nstatic int isFileInVirtualDir(\n\t/*! [in] Directory path to be tested for virtual directory. */\n\tchar *filePath)\n{\n\tvirtualDirList *pCurVirtualDir;\n\tsize_t webDirLen;\n\n\tpCurVirtualDir = pVirtualDirList;\n\twhile (pCurVirtualDir != NULL) {\n\t\twebDirLen = strlen(pCurVirtualDir->dirName);\n\t\tif (webDirLen) {\n\t\t\tif (pCurVirtualDir->dirName[webDirLen - 1] == '/') {\n\t\t\t\tif (strncmp(pCurVirtualDir->dirName, filePath,\n\t\t\t\t\t\twebDirLen) == 0)\n\t\t\t\t\treturn !0;\n\t\t\t} else {\n\t\t\t\tif (strncmp(pCurVirtualDir->dirName, filePath,\n\t\t\t\t\t\twebDirLen) == 0 &&\n\t\t\t\t    (filePath[webDirLen] == '/' ||\n\t\t\t\t     filePath[webDirLen] == '\\0' ||\n\t\t\t\t     filePath[webDirLen] == '?'))\n\t\t\t\t\treturn !0;\n\t\t\t}\n\t\t}\n\t\tpCurVirtualDir = pCurVirtualDir->next;\n\t}\n\n\treturn 0;\n}\n\n/*!\n * \\brief Converts input string to upper case.\n */\nstatic void ToUpperCase(\n\t/*! Input string to be converted. */\n\tchar *s)\n{\n\twhile (*s) {\n\t\t*s = (char)toupper(*s);\n\t\t++s;\n\t}\n}\n\n/*!\n * \\brief Finds a substring from a string in a case insensitive way.\n *\n * \\return A pointer to the first occurence of s2 in s1.\n */\nstatic char *StrStr(\n\t/*! Input string. */\n\tchar *s1,\n\t/*! Input sub-string. */\n\tconst char *s2)\n{\n\tchar *Str1;\n\tchar *Str2;\n\tconst char *Ptr;\n\tchar *ret = NULL;\n\n\tStr1 = strdup(s1);\n\tif (!Str1)\n\t\tgoto error1;\n\tStr2 = strdup(s2);\n\tif (!Str2)\n\t\tgoto error2;\n\tToUpperCase(Str1);\n\tToUpperCase(Str2);\n\tPtr = strstr(Str1, Str2);\n\tif (!Ptr)\n\t\tret = NULL;\n\telse\n\t\tret = s1 + (Ptr - Str1);\n\n\tfree(Str2);\nerror2:\n\tfree(Str1);\nerror1:\n\treturn ret;\n}\n\n/*!\n * \\brief Finds next token in a string.\n *\n * \\return Pointer to the next token.\n */\nstatic char *StrTok(\n\t/*! String containing the token. */\n\tchar **Src,\n\t/*! Set of delimiter characters. */\n\tconst char *Del)\n{\n\tchar *TmpPtr;\n\tchar *RetPtr;\n\n\tif (*Src != NULL) {\n\t\tRetPtr = *Src;\n\t\tTmpPtr = strstr(*Src, Del);\n\t\tif (TmpPtr != NULL) {\n\t\t\t*TmpPtr = '\\0';\n\t\t\t*Src = TmpPtr + strlen(Del);\n\t\t} else\n\t\t\t*Src = NULL;\n\n\t\treturn RetPtr;\n\t}\n\n\treturn NULL;\n}\n\n/*!\n * \\brief Returns a range of integers from a string.\n *\n * \\return Always returns 1.\n */\nstatic int GetNextRange(\n\t/*! string containing the token / range. */\n\tchar **SrcRangeStr,\n\t/*! gets the first byte of the token. */\n\toff_t *FirstByte,\n\t/*! gets the last byte of the token. */\n\toff_t *LastByte)\n{\n\tchar *Ptr;\n\tchar *Tok;\n\tint i;\n\tint64_t F = -1;\n\tint64_t L = -1;\n\tint Is_Suffix_byte_Range = 1;\n\n\tif (*SrcRangeStr == NULL)\n\t\treturn -1;\n\tTok = StrTok(SrcRangeStr, \",\");\n\tif ((Ptr = strstr(Tok, \"-\")) == NULL)\n\t\treturn -1;\n\t*Ptr = ' ';\n\tsscanf(Tok, \"%\" SCNd64 \"%\" SCNd64, &F, &L);\n\tif (F == -1 || L == -1) {\n\t\t*Ptr = '-';\n\t\tfor (i = 0; i < (int)strlen(Tok); i++) {\n\t\t\tif (Tok[i] == '-') {\n\t\t\t\tbreak;\n\t\t\t} else if (isdigit(Tok[i])) {\n\t\t\t\tIs_Suffix_byte_Range = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (Is_Suffix_byte_Range) {\n\t\t\t*FirstByte = (off_t) L;\n\t\t\t*LastByte = (off_t) F;\n\t\t\treturn 1;\n\t\t}\n\t}\n\t*FirstByte = (off_t) F;\n\t*LastByte = (off_t) L;\n\n\treturn 1;\n}\n\n/*!\n * \\brief Fills in the Offset, read size and contents to send out as an HTTP\n * Range Response.\n *\n * \\return\n * \\li \\c HTTP_BAD_REQUEST\n * \\li \\c HTTP_INTERNAL_SERVER_ERROR\n * \\li \\c HTTP_REQUEST_RANGE_NOT_SATISFIABLE\n * \\li \\c HTTP_OK\n */\nstatic int CreateHTTPRangeResponseHeader(\n\t/*! String containing the range. */\n\tchar *ByteRangeSpecifier,\n\t/*! Length of the file. */\n\toff_t FileLength,\n\t/*! [out] SendInstruction object where the range operations will be stored. */\n\tstruct SendInstruction *Instr)\n{\n\toff_t FirstByte, LastByte;\n\tchar *RangeInput;\n\tchar *Ptr;\n\tint rc = 0;\n\n\tInstr->IsRangeActive = 1;\n\tInstr->ReadSendSize = FileLength;\n\tif (!ByteRangeSpecifier)\n\t\treturn HTTP_BAD_REQUEST;\n\tRangeInput = strdup(ByteRangeSpecifier);\n\tif (!RangeInput)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t/* CONTENT-RANGE: bytes 222-3333/4000  HTTP_PARTIAL_CONTENT */\n\tif (StrStr(RangeInput, \"bytes\") == NULL ||\n\t    (Ptr = StrStr(RangeInput, \"=\")) == NULL) {\n\t\tfree(RangeInput);\n\t\tInstr->IsRangeActive = 0;\n\t\treturn HTTP_BAD_REQUEST;\n\t}\n\t/* Jump = */\n\tPtr = Ptr + 1;\n\tif (FileLength < 0) {\n\t\tfree(RangeInput);\n\t\treturn HTTP_REQUEST_RANGE_NOT_SATISFIABLE;\n\t}\n\tif (GetNextRange(&Ptr, &FirstByte, &LastByte) != -1) {\n\t\tif (FileLength < FirstByte) {\n\t\t\tfree(RangeInput);\n\t\t\treturn HTTP_REQUEST_RANGE_NOT_SATISFIABLE;\n\t\t}\n\t\tif (FirstByte >= 0 && LastByte >= 0 && LastByte >= FirstByte) {\n\t\t\tif (LastByte >= FileLength)\n\t\t\t\tLastByte = FileLength - 1;\n\t\t\tInstr->RangeOffset = FirstByte;\n\t\t\tInstr->ReadSendSize = LastByte - FirstByte + 1;\n\t\t\t/* Data between two range. */\n\t\t\trc = snprintf(Instr->RangeHeader,\n\t\t\t\tsizeof(Instr->RangeHeader),\n\t\t\t\t\"CONTENT-RANGE: bytes %\" PRId64\n\t\t\t\t\"-%\" PRId64 \"/%\" PRId64 \"\\r\\n\",\n\t\t\t\t(int64_t)FirstByte,\n\t\t\t\t(int64_t)LastByte,\n\t\t\t\t(int64_t)FileLength);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Instr->RangeHeader)) {\n\t\t\t\tfree(RangeInput);\n\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t} else if (FirstByte >= 0 && LastByte == -1\n\t\t\t   && FirstByte < FileLength) {\n\t\t\tInstr->RangeOffset = FirstByte;\n\t\t\tInstr->ReadSendSize = FileLength - FirstByte;\n\t\t\trc = snprintf(Instr->RangeHeader,\n\t\t\t\tsizeof(Instr->RangeHeader),\n\t\t\t\t\"CONTENT-RANGE: bytes %\" PRId64\n\t\t\t\t\"-%\" PRId64 \"/%\" PRId64 \"\\r\\n\",\n\t\t\t\t(int64_t)FirstByte,\n\t\t\t\t(int64_t)(FileLength - 1),\n\t\t\t\t(int64_t)FileLength);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Instr->RangeHeader)) {\n\t\t\t\tfree(RangeInput);\n\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t} else if (FirstByte == -1 && LastByte > 0) {\n\t\t\tif (LastByte >= FileLength) {\n\t\t\t\tInstr->RangeOffset = 0;\n\t\t\t\tInstr->ReadSendSize = FileLength;\n\t\t\t\trc = snprintf(Instr->RangeHeader,\n\t\t\t\t\tsizeof(Instr->RangeHeader),\n\t\t\t\t\t\"CONTENT-RANGE: bytes 0-%\" PRId64\n\t\t\t\t\t\"/%\" PRId64 \"\\r\\n\",\n\t\t\t\t\t(int64_t)(FileLength - 1),\n\t\t\t\t\t(int64_t)FileLength);\n\t\t\t} else {\n\t\t\t\tInstr->RangeOffset = FileLength - LastByte;\n\t\t\t\tInstr->ReadSendSize = LastByte;\n\t\t\t\trc = snprintf(Instr->RangeHeader,\n\t\t\t\t\tsizeof(Instr->RangeHeader),\n\t\t\t\t\t\"CONTENT-RANGE: bytes %\" PRId64\n\t\t\t\t\t\"-%\" PRId64 \"/%\" PRId64 \"\\r\\n\",\n\t\t\t\t\t(int64_t)(FileLength - LastByte),\n\t\t\t\t\t(int64_t)FileLength - 1,\n\t\t\t\t\t(int64_t)FileLength);\n\t\t\t}\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Instr->RangeHeader)) {\n\t\t\t\tfree(RangeInput);\n\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t} else {\n\t\t\tfree(RangeInput);\n\t\t\treturn HTTP_REQUEST_RANGE_NOT_SATISFIABLE;\n\t\t}\n\t} else {\n\t\tfree(RangeInput);\n\t\treturn HTTP_REQUEST_RANGE_NOT_SATISFIABLE;\n\t}\n\n\tfree(RangeInput);\n\treturn HTTP_OK;\n}\n\n/*!\n * \\brief Get header id from the request parameter and take appropriate\n * action based on the ids as an HTTP Range Response.\n *\n * \\return\n * \\li \\c HTTP_BAD_REQUEST\n * \\li \\c HTTP_INTERNAL_SERVER_ERROR\n * \\li \\c HTTP_REQUEST_RANGE_NOT_SATISFIABLE\n * \\li \\c HTTP_OK\n */\nstatic int CheckOtherHTTPHeaders(\n\t/*! [in] HTTP Request message. */\n\thttp_message_t *Req,\n\t/*! [out] Send Instruction object to data for the response. */\n\tstruct SendInstruction *RespInstr,\n\t/*! Size of the file containing the request document. */\n\toff_t FileSize)\n{\n\thttp_header_t *header;\n\tListNode *node;\n\t/*NNS: dlist_node* node; */\n\tint index, RetCode = HTTP_OK;\n\tchar *TmpBuf;\n\tsize_t TmpBufSize = LINE_SIZE;\n\n\tTmpBuf = (char *)malloc(TmpBufSize);\n\tif (!TmpBuf)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\tnode = ListHead(&Req->headers);\n\twhile (node != NULL) {\n\t\theader = (http_header_t *) node->item;\n\t\t/* find header type. */\n\t\tindex = map_str_to_int((const char *)header->name.buf,\n\t\t\t\theader->name.length, Http_Header_Names,\n\t\t\t\tNUM_HTTP_HEADER_NAMES, FALSE);\n\t\tif (header->value.length >= TmpBufSize) {\n\t\t\tfree(TmpBuf);\n\t\t\tTmpBufSize = header->value.length + 1;\n\t\t\tTmpBuf = (char *)malloc(TmpBufSize);\n\t\t\tif (!TmpBuf)\n\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t}\n\t\tmemcpy(TmpBuf, header->value.buf, header->value.length);\n\t\tTmpBuf[header->value.length] = '\\0';\n\t\tif (index >= 0) {\n\t\t\tswitch (Http_Header_Names[index].id) {\n\t\t\tcase HDR_TE: {\n\t\t\t\t/* Request */\n\t\t\t\tRespInstr->IsChunkActive = 1;\n\n\t\t\t\tif (strlen(TmpBuf) > strlen(\"gzip\")) {\n\t\t\t\t\t/* means client will accept trailer. */\n\t\t\t\t\tif (StrStr(TmpBuf, \"trailers\") != NULL) {\n\t\t\t\t\t\tRespInstr->IsTrailers = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase HDR_CONTENT_LENGTH:\n\t\t\t\tRespInstr->RecvWriteSize = atoi(TmpBuf);\n\t\t\t\tbreak;\n\t\t\tcase HDR_RANGE:\n\t\t\t\tRetCode = CreateHTTPRangeResponseHeader(TmpBuf,\n\t\t\t\t\tFileSize, RespInstr);\n\t\t\t\tif (RetCode != HTTP_OK) {\n\t\t\t\t\tfree(TmpBuf);\n\t\t\t\t\treturn RetCode;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase HDR_ACCEPT_LANGUAGE:\n\t\t\t\tif (header->value.length + 1 > sizeof(RespInstr->AcceptLanguageHeader)) {\n\t\t\t\t\tsize_t length = sizeof(RespInstr->AcceptLanguageHeader) - 1;\n\t\t\t\t\tmemcpy(RespInstr->AcceptLanguageHeader, TmpBuf, length);\n\t\t\t\t\tRespInstr->AcceptLanguageHeader[length] = '\\0';\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(RespInstr->AcceptLanguageHeader, TmpBuf,\n\t\t\t\t\t\theader->value.length + 1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t   TODO\n\t\t\t\t */\n\t\t\t\t/*\n\t\t\t\t   header.value is the value.\n\t\t\t\t */\n\t\t\t\t/*\n\t\t\t\t   case HDR_CONTENT_TYPE: return 1;\n\t\t\t\t   case HDR_CONTENT_LANGUAGE:return 1;\n\t\t\t\t   case HDR_LOCATION: return 1;\n\t\t\t\t   case HDR_CONTENT_LOCATION:return 1;\n\t\t\t\t   case HDR_ACCEPT: return 1;\n\t\t\t\t   case HDR_ACCEPT_CHARSET: return 1;\n\t\t\t\t   case HDR_USER_AGENT: return 1;\n\t\t\t\t */\n\n\t\t\t\t/*Header check for encoding */\n\t\t\t\t/*\n\t\t\t\t   case HDR_ACCEPT_RANGE:\n\t\t\t\t   case HDR_CONTENT_RANGE:\n\t\t\t\t   case HDR_IF_RANGE:\n\t\t\t\t */\n\n\t\t\t\t/*Header check for encoding */\n\t\t\t\t/*\n\t\t\t\t   case HDR_ACCEPT_ENCODING:\n\t\t\t\t   if(StrStr(TmpBuf, \"identity\"))\n\t\t\t\t   {\n\t\t\t\t   break;\n\t\t\t\t   }\n\t\t\t\t   else return -1;\n\t\t\t\t   case HDR_CONTENT_ENCODING:\n\t\t\t\t   case HDR_TRANSFER_ENCODING:\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnode = ListNext(&Req->headers, node);\n\t}\n\tfree(TmpBuf);\n\n\treturn RetCode;\n}\n\n/*!\n * \\brief Processes the request and returns the result in the output parameters.\n *\n * \\return\n * \\li \\c HTTP_BAD_REQUEST\n * \\li \\c HTTP_INTERNAL_SERVER_ERROR\n * \\li \\c HTTP_REQUEST_RANGE_NOT_SATISFIABLE\n * \\li \\c HTTP_FORBIDDEN\n * \\li \\c HTTP_NOT_FOUND\n * \\li \\c HTTP_NOT_ACCEPTABLE\n * \\li \\c HTTP_OK\n */\nstatic int process_request(\n\t/*! [in] HTTP Request message. */\n\thttp_message_t *req,\n\t/*! [out] Tpye of response. */\n\tenum resp_type *rtype,\n\t/*! [out] Headers. */\n\tmembuffer *headers,\n\t/*! [out] Get filename from request document. */\n\tmembuffer *filename,\n\t/*! [out] Xml alias document from the request document. */\n\tstruct xml_alias_t *alias,\n\t/*! [out] Send Instruction object where the response is set up. */\n\tstruct SendInstruction *RespInstr)\n{\n\tint code;\n\tint err_code;\n\n\tchar *request_doc;\n\tUpnpFileInfo *finfo;\n\ttime_t aux_LastModified;\n\tint using_alias;\n\tint using_virtual_dir;\n\turi_type *url;\n\tconst char *temp_str;\n\tint resp_major;\n\tint resp_minor;\n\tint alias_grabbed;\n\tsize_t dummy;\n\tconst char *extra_headers = NULL;\n\n\tprint_http_headers(req);\n\turl = &req->uri;\n\tassert(req->method == HTTPMETHOD_GET ||\n\t       req->method == HTTPMETHOD_HEAD ||\n\t       req->method == HTTPMETHOD_POST ||\n\t       req->method == HTTPMETHOD_SIMPLEGET);\n\t/* init */\n\tmemset(&finfo, 0, sizeof(finfo));\n\trequest_doc = NULL;\n\tfinfo = UpnpFileInfo_new();\n\talias_grabbed = FALSE;\n\terr_code = HTTP_INTERNAL_SERVER_ERROR;\t/* default error */\n\tusing_virtual_dir = FALSE;\n\tusing_alias = FALSE;\n\n\thttp_CalcResponseVersion(req->major_version, req->minor_version,\n\t\t\t\t &resp_major, &resp_minor);\n\t/* */\n\t/* remove dots */\n\t/* */\n\trequest_doc = malloc(url->pathquery.size + 1);\n\tif (request_doc == NULL) {\n\t\tgoto error_handler;\t/* out of mem */\n\t}\n\tmemcpy(request_doc, url->pathquery.buff, url->pathquery.size);\n\trequest_doc[url->pathquery.size] = '\\0';\n\tdummy = url->pathquery.size;\n\tremove_escaped_chars(request_doc, &dummy);\n\tcode = remove_dots(request_doc, url->pathquery.size);\n\tif (code != 0) {\n\t\terr_code = HTTP_FORBIDDEN;\n\t\tgoto error_handler;\n\t}\n\tif (*request_doc != '/') {\n\t\t/* no slash */\n\t\terr_code = HTTP_BAD_REQUEST;\n\t\tgoto error_handler;\n\t}\n\tif (isFileInVirtualDir(request_doc)) {\n\t\tusing_virtual_dir = TRUE;\n\t\tRespInstr->IsVirtualFile = 1;\n\t\tif (membuffer_assign_str(filename, request_doc) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t} else {\n\t\t/* try using alias */\n\t\tif (is_valid_alias(&gAliasDoc)) {\n\t\t\talias_grab(alias);\n\t\t\talias_grabbed = TRUE;\n\t\t\tusing_alias = get_alias(request_doc, alias, finfo);\n\t\t\tif (using_alias == TRUE) {\n\t\t\t\tUpnpFileInfo_set_ContentType(finfo,\n\t\t\t\t\t\"text/xml; charset=\\\"utf-8\\\"\");\n\t\t\t\tif (UpnpFileInfo_get_ContentType(finfo) == NULL) {\n\t\t\t\t\tgoto error_handler;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (using_virtual_dir) {\n\t\tif (req->method != HTTPMETHOD_POST) {\n\t\t\t/* get file info */\n\t\t\tif (virtualDirCallback.\n\t\t\t    get_info(filename->buf, finfo) != 0) {\n\t\t\t\terr_code = HTTP_NOT_FOUND;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\t/* try index.html if req is a dir */\n\t\t\tif (UpnpFileInfo_get_IsDirectory(finfo)) {\n\t\t\t\tif (filename->buf[filename->length - 1] == '/') {\n\t\t\t\t\ttemp_str = \"index.html\";\n\t\t\t\t} else {\n\t\t\t\t\ttemp_str = \"/index.html\";\n\t\t\t\t}\n\t\t\t\tif (membuffer_append_str(filename, temp_str) !=\n\t\t\t\t    0) {\n\t\t\t\t\tgoto error_handler;\n\t\t\t\t}\n\t\t\t\t/* get info */\n\t\t\t\tif (virtualDirCallback.get_info(filename->buf, finfo) != UPNP_E_SUCCESS ||\n\t\t\t\t    UpnpFileInfo_get_IsDirectory(finfo)) {\n\t\t\t\t\terr_code = HTTP_NOT_FOUND;\n\t\t\t\t\tgoto error_handler;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* not readable */\n\t\t\tif (!UpnpFileInfo_get_IsReadable(finfo)) {\n\t\t\t\terr_code = HTTP_FORBIDDEN;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\t/* finally, get content type */\n\t\t\t/* if ( get_content_type(filename->buf, &content_type) != 0 ) */\n\t\t\t/*{ */\n\t\t\t/*  goto error_handler; */\n\t\t\t/* } */\n\t\t}\n\t} else if (!using_alias) {\n\t\tif (gDocumentRootDir.length == 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\t/* */\n\t\t/* get file name */\n\t\t/* */\n\n\t\t/* filename str */\n\t\tif (membuffer_assign_str(filename, gDocumentRootDir.buf) != 0 ||\n\t\t    membuffer_append_str(filename, request_doc) != 0) {\n\t\t\tgoto error_handler;\t/* out of mem */\n\t\t}\n\t\t/* remove trailing slashes */\n\t\twhile (filename->length > 0 &&\n\t\t       filename->buf[filename->length - 1] == '/') {\n\t\t\tmembuffer_delete(filename, filename->length - 1, 1);\n\t\t}\n\t\tif (req->method != HTTPMETHOD_POST) {\n\t\t\t/* get info on file */\n\t\t\tif (get_file_info(filename->buf, finfo) != 0) {\n\t\t\t\terr_code = HTTP_NOT_FOUND;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\t/* try index.html if req is a dir */\n\t\t\tif (UpnpFileInfo_get_IsDirectory(finfo)) {\n\t\t\t\tif (filename->buf[filename->length - 1] == '/') {\n\t\t\t\t\ttemp_str = \"index.html\";\n\t\t\t\t} else {\n\t\t\t\t\ttemp_str = \"/index.html\";\n\t\t\t\t}\n\t\t\t\tif (membuffer_append_str(filename, temp_str) !=\n\t\t\t\t    0) {\n\t\t\t\t\tgoto error_handler;\n\t\t\t\t}\n\t\t\t\t/* get info */\n\t\t\t\tif (get_file_info(filename->buf, finfo) != 0 ||\n\t\t\t\t    UpnpFileInfo_get_IsDirectory(finfo)) {\n\t\t\t\t\terr_code = HTTP_NOT_FOUND;\n\t\t\t\t\tgoto error_handler;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* not readable */\n\t\t\tif (!UpnpFileInfo_get_IsReadable(finfo)) {\n\t\t\t\terr_code = HTTP_FORBIDDEN;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t}\n\t\t/* finally, get content type */\n\t\t/*      if ( get_content_type(filename->buf, &content_type) != 0 ) */\n\t\t/*      { */\n\t\t/*          goto error_handler; */\n\t\t/*      } */\n\t}\n\tRespInstr->ReadSendSize = UpnpFileInfo_get_FileLength(finfo);\n\t/* Check other header field. */\n\tcode = CheckOtherHTTPHeaders(req, RespInstr,\n\t\tUpnpFileInfo_get_FileLength(finfo));\n\tif (code != HTTP_OK) {\n\t\terr_code = code;\n\t\tgoto error_handler;\n\t}\n\tif (req->method == HTTPMETHOD_POST) {\n\t\t*rtype = RESP_POST;\n\t\terr_code = HTTP_OK;\n\t\tgoto error_handler;\n\t}\n\textra_headers = UpnpFileInfo_get_ExtraHeaders(finfo);\n\tif (!extra_headers) {\n\t\textra_headers = \"\";\n\t}\n\n\t/* Check if chunked encoding should be used. */\n\tif (using_virtual_dir && UpnpFileInfo_get_FileLength(finfo) == UPNP_USING_CHUNKED) {\n\t\t/* Chunked encoding is only supported by HTTP 1.1 clients */\n\t\tif (resp_major == 1 && resp_minor == 1) {\n\t\t\tRespInstr->IsChunkActive = 1;\n\t\t} else {\n\t\t\t/* The virtual callback indicates that we should use\n\t\t\t * chunked encoding however the client doesn't support\n\t\t\t * it. Return with an internal server error. */\n\t\t\terr_code = HTTP_NOT_ACCEPTABLE;\n\t\t\tgoto error_handler;\n\t\t}\n\t}\n\n\taux_LastModified = UpnpFileInfo_get_LastModified(finfo);\n\tif (RespInstr->IsRangeActive && RespInstr->IsChunkActive) {\n\t\t/* Content-Range: bytes 222-3333/4000  HTTP_PARTIAL_CONTENT */\n\t\t/* Transfer-Encoding: chunked */\n\t\tif (http_MakeMessage(headers, resp_major, resp_minor,\n\t\t    \"R\" \"T\" \"GKLD\" \"s\" \"tcS\" \"Xc\" \"sCc\",\n\t\t    HTTP_PARTIAL_CONTENT,\t/* status code */\n\t\t    UpnpFileInfo_get_ContentType(finfo), /* content type */\n\t\t    RespInstr,\t/* range info */\n\t\t    RespInstr,\t/* language info */\n\t\t    \"LAST-MODIFIED: \",\n\t\t    &aux_LastModified,\n\t\t    X_USER_AGENT, extra_headers) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t} else if (RespInstr->IsRangeActive && !RespInstr->IsChunkActive) {\n\t\t/* Content-Range: bytes 222-3333/4000  HTTP_PARTIAL_CONTENT */\n\t\tif (http_MakeMessage(headers, resp_major, resp_minor,\n\t\t    \"R\" \"N\" \"T\" \"GLD\" \"s\" \"tcS\" \"Xc\" \"sCc\",\n\t\t    HTTP_PARTIAL_CONTENT,\t/* status code */\n\t\t    RespInstr->ReadSendSize,\t/* content length */\n\t\t    UpnpFileInfo_get_ContentType(finfo), /* content type */\n\t\t    RespInstr,\t/* range info */\n\t\t    RespInstr,\t/* language info */\n\t\t    \"LAST-MODIFIED: \",\n\t\t    &aux_LastModified,\n\t\t    X_USER_AGENT, extra_headers) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t} else if (!RespInstr->IsRangeActive && RespInstr->IsChunkActive) {\n\t\t/* Transfer-Encoding: chunked */\n\t\tif (http_MakeMessage(headers, resp_major, resp_minor,\n\t\t    \"RK\" \"TLD\" \"s\" \"tcS\" \"Xc\" \"sCc\",\n\t\t    HTTP_OK,\t/* status code */\n\t\t    UpnpFileInfo_get_ContentType(finfo), /* content type */\n\t\t    RespInstr,\t/* language info */\n\t\t    \"LAST-MODIFIED: \",\n\t\t    &aux_LastModified,\n\t\t    X_USER_AGENT, extra_headers) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t} else {\n\t\t/* !RespInstr->IsRangeActive && !RespInstr->IsChunkActive */\n\t\tif (RespInstr->ReadSendSize >= 0) {\n\t\t\tif (http_MakeMessage(headers, resp_major, resp_minor,\n\t\t\t    \"R\" \"N\" \"TLD\" \"s\" \"tcS\" \"Xc\" \"sCc\",\n\t\t\t    HTTP_OK,\t/* status code */\n\t\t\t    RespInstr->ReadSendSize,\t/* content length */\n\t\t\t    UpnpFileInfo_get_ContentType(finfo), /* content type */\n\t\t\t    RespInstr,\t/* language info */\n\t\t\t    \"LAST-MODIFIED: \",\n\t\t\t    &aux_LastModified,\n\t\t\t    X_USER_AGENT,\n\t\t\t    extra_headers) != 0) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else {\n\t\t\tif (http_MakeMessage(headers, resp_major, resp_minor,\n\t\t\t    \"R\" \"TLD\" \"s\" \"tcS\" \"Xc\" \"sCc\",\n\t\t\t    HTTP_OK,\t/* status code */\n\t\t\t    UpnpFileInfo_get_ContentType(finfo), /* content type */\n\t\t\t    RespInstr,\t/* language info */\n\t\t\t    \"LAST-MODIFIED: \",\n\t\t\t    &aux_LastModified,\n\t\t\t    X_USER_AGENT,\n\t\t\t    extra_headers) != 0) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t}\n\t}\n\tif (req->method == HTTPMETHOD_HEAD) {\n\t\t*rtype = RESP_HEADERS;\n\t} else if (using_alias) {\n\t\t/* GET xml */\n\t\t*rtype = RESP_XMLDOC;\n\t} else if (using_virtual_dir) {\n\t\t*rtype = RESP_WEBDOC;\n\t} else {\n\t\t/* GET filename */\n\t\t*rtype = RESP_FILEDOC;\n\t}\n\t/* simple get http 0.9 as specified in http 1.0 */\n\t/* don't send headers */\n\tif (req->method == HTTPMETHOD_SIMPLEGET) {\n\t\tmembuffer_destroy(headers);\n\t}\n\terr_code = HTTP_OK;\n\n error_handler:\n\tfree(request_doc);\n\tUpnpFileInfo_delete(finfo);\n\tif (err_code != HTTP_OK && alias_grabbed) {\n\t\talias_release(alias);\n\t}\n\n\treturn err_code;\n}\n\n/*!\n * \\brief Receives the HTTP post message.\n *\n * \\return\n * \\li \\c HTTP_INTERNAL_SERVER_ERROR\n * \\li \\c HTTP_UNAUTHORIZED\n * \\li \\c HTTP_BAD_REQUEST\n * \\li \\c HTTP_SERVICE_UNAVAILABLE\n * \\li \\c HTTP_OK\n */\nstatic int http_RecvPostMessage(\n\t/*! HTTP Parser object. */\n\thttp_parser_t *parser,\n\t/*! [in] Socket Information object. */\n\tSOCKINFO *info,\n\t/*! File where received data is copied to. */\n\tchar *filename,\n\t/*! Send Instruction object which gives information whether the file\n\t * is a virtual file or not. */\n\tstruct SendInstruction *Instr)\n{\n\tsize_t Data_Buf_Size = 1024;\n\tchar Buf[1024];\n\tint Timeout = -1;\n\tFILE *Fp;\n\tparse_status_t status = PARSE_OK;\n\tint ok_on_close = FALSE;\n\tsize_t entity_offset = 0;\n\tint num_read = 0;\n\tint ret_code = HTTP_OK;\n\n\tif (Instr && Instr->IsVirtualFile) {\n\t\tFp = (virtualDirCallback.open) (filename, UPNP_WRITE);\n\t\tif (Fp == NULL)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t} else {\n#ifdef UPNP_ENABLE_POST_WRITE\n\t\tFp = fopen(filename, \"wb\");\n\t\tif (Fp == NULL)\n\t\t\treturn HTTP_UNAUTHORIZED;\n#else\n\t\treturn HTTP_NOT_FOUND;\n#endif\n\t}\n\tparser->position = POS_ENTITY;\n\tdo {\n\t\t/* first parse what has already been gotten */\n\t\tif (parser->position != POS_COMPLETE)\n\t\t\tstatus = parser_parse_entity(parser);\n\t\tif (status == PARSE_INCOMPLETE_ENTITY) {\n\t\t\t/* read until close */\n\t\t\tok_on_close = TRUE;\n\t\t} else if ((status != PARSE_SUCCESS)\n\t\t\t   && (status != PARSE_CONTINUE_1)\n\t\t\t   && (status != PARSE_INCOMPLETE)) {\n\t\t\t/* error */\n\t\t\tret_code = HTTP_BAD_REQUEST;\n\t\t\tgoto ExitFunction;\n\t\t}\n\t\t/* read more if necessary entity */\n\t\twhile (entity_offset + Data_Buf_Size > parser->msg.entity.length &&\n\t\t       parser->position != POS_COMPLETE) {\n\t\t\tnum_read = sock_read(info, Buf, sizeof(Buf), &Timeout);\n\t\t\tif (num_read > 0) {\n\t\t\t\t/* append data to buffer */\n\t\t\t\tif (membuffer_append(&parser->msg.msg,\n\t\t\t\t\tBuf, (size_t)num_read) != 0) {\n\t\t\t\t\t/* set failure status */\n\t\t\t\t\tparser->http_error_code =\n\t\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\t\tret_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t\tstatus = parser_parse_entity(parser);\n\t\t\t\tif (status == PARSE_INCOMPLETE_ENTITY) {\n\t\t\t\t\t/* read until close */\n\t\t\t\t\tok_on_close = TRUE;\n\t\t\t\t} else if ((status != PARSE_SUCCESS)\n\t\t\t\t\t   && (status != PARSE_CONTINUE_1)\n\t\t\t\t\t   && (status != PARSE_INCOMPLETE)) {\n\t\t\t\t\tret_code = HTTP_BAD_REQUEST;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t} else if (num_read == 0) {\n\t\t\t\tif (ok_on_close) {\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t\"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\t\tparser->msg.msg.buf);\n\t\t\t\t\tprint_http_headers(&parser->msg);\n\t\t\t\t\tparser->position = POS_COMPLETE;\n\t\t\t\t} else {\n\t\t\t\t\t/* partial msg or response */\n\t\t\t\t\tparser->http_error_code = HTTP_BAD_REQUEST;\n\t\t\t\t\tret_code = HTTP_BAD_REQUEST;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tret_code = HTTP_SERVICE_UNAVAILABLE;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t}\n\t\tif ((entity_offset + Data_Buf_Size) > parser->msg.entity.length) {\n\t\t\tData_Buf_Size =\n\t\t\t    parser->msg.entity.length - entity_offset;\n\t\t}\n\t\tmemcpy(Buf,\n\t\t       &parser->msg.msg.buf[parser->entity_start_position + entity_offset],\n\t\t       Data_Buf_Size);\n\t\tentity_offset += Data_Buf_Size;\n\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\tint n = virtualDirCallback.write(Fp, Buf, Data_Buf_Size);\n\t\t\tif (n < 0) {\n\t\t\t\tret_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t} else {\n\t\t\tsize_t n = fwrite(Buf, 1, Data_Buf_Size, Fp);\n\t\t\tif (n != Data_Buf_Size) {\n\t\t\t\tret_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t}\n\t} while (parser->position != POS_COMPLETE ||\n\t\t entity_offset != parser->msg.entity.length);\nExitFunction:\n\tif (Instr && Instr->IsVirtualFile) {\n\t\tvirtualDirCallback.close(Fp);\n\t} else {\n\t\tfclose(Fp);\n\t}\n\n\treturn ret_code;\n}\n\nvoid web_server_callback(http_parser_t *parser, INOUT http_message_t *req,\n\tSOCKINFO *info)\n{\n\tint ret;\n\tint timeout = -1;\n\tenum resp_type rtype = 0;\n\tmembuffer headers;\n\tmembuffer filename;\n\tstruct xml_alias_t xmldoc;\n\tstruct SendInstruction RespInstr;\n\n\t/*Initialize instruction header. */\n\tRespInstr.IsVirtualFile = 0;\n\tRespInstr.IsChunkActive = 0;\n\tRespInstr.IsRangeActive = 0;\n\tRespInstr.IsTrailers = 0;\n\tmemset(RespInstr.AcceptLanguageHeader, 0,\n\t       sizeof(RespInstr.AcceptLanguageHeader));\n\t/* init */\n\tmembuffer_init(&headers);\n\tmembuffer_init(&filename);\n\n\t/*Process request should create the different kind of header depending on the */\n\t/*the type of request. */\n\tret = process_request(req, &rtype, &headers, &filename, &xmldoc,\n\t\t&RespInstr);\n\tif (ret != HTTP_OK) {\n\t\t/* send error code */\n\t\thttp_SendStatusResponse(info, ret, req->major_version,\n\t\t\treq->minor_version);\n\t} else {\n\t\t/* send response */\n\t\tswitch (rtype) {\n\t\tcase RESP_FILEDOC:\n\t\t\thttp_SendMessage(info, &timeout, \"Ibf\",\n\t\t\t\t\t &RespInstr,\n\t\t\t\t\t headers.buf, headers.length,\n\t\t\t\t\t filename.buf);\n\t\t\tbreak;\n\t\tcase RESP_XMLDOC:\n\t\t\thttp_SendMessage(info, &timeout, \"Ibb\",\n\t\t\t\t&RespInstr,\n\t\t\t\theaders.buf, headers.length,\n\t\t\t\txmldoc.doc.buf, xmldoc.doc.length);\n\t\t\talias_release(&xmldoc);\n\t\t\tbreak;\n\t\tcase RESP_WEBDOC:\n\t\t\t/*http_SendVirtualDirDoc(info, &timeout, \"Ibf\",\n\t\t\t\t&RespInstr,\n\t\t\t\theaders.buf, headers.length,\n\t\t\t\tfilename.buf);*/\n\t\t\thttp_SendMessage(info, &timeout, \"Ibf\",\n\t\t\t\t&RespInstr,\n\t\t\t\theaders.buf, headers.length,\n\t\t\t\tfilename.buf);\n\t\t\tbreak;\n\t\tcase RESP_HEADERS:\n\t\t\t/* headers only */\n\t\t\thttp_SendMessage(info, &timeout, \"b\",\n\t\t\t\theaders.buf, headers.length);\n\t\t\tbreak;\n\t\tcase RESP_POST:\n\t\t\t/* headers only */\n\t\t\tret = http_RecvPostMessage(parser, info, filename.buf,\n\t\t\t\t&RespInstr);\n\t\t\t/* Send response. */\n\t\t\thttp_MakeMessage(&headers, 1, 1,\n\t\t\t\t\"RTLSXcCc\",\n\t\t\t\tret, \"text/html\", &RespInstr, X_USER_AGENT);\n\t\t\thttp_SendMessage(info, &timeout, \"b\",\n\t\t\t\theaders.buf, headers.length);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"webserver: Invalid response type received.\\n\");\n\t\t\tassert(0);\n\t\t}\n\t}\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t   \"webserver: request processed...\\n\");\n\tmembuffer_destroy(&headers);\n\tmembuffer_destroy(&filename);\n}\n#endif /* EXCLUDE_WEB_SERVER */\n\n"], "filenames": ["configure.ac", "upnp/inc/upnpconfig.h.in", "upnp/src/genlib/net/http/webserver.c"], "buggy_code_start_loc": [484, 137, 1371], "buggy_code_end_loc": [484, 137, 1374], "fixing_code_start_loc": [485, 138, 1372], "fixing_code_end_loc": [489, 143, 1379], "type": "CWE-284", "message": "Portable UPnP SDK (aka libupnp) before 1.6.21 allows remote attackers to write to arbitrary files in the webroot via a POST request without a registered handler.", "other": {"cve": {"id": "CVE-2016-6255", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-07T16:59:00.743", "lastModified": "2017-11-03T01:29:03.297", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Portable UPnP SDK (aka libupnp) before 1.6.21 allows remote attackers to write to arbitrary files in the webroot via a POST request without a registered handler."}, {"lang": "es", "value": "Portable UPnP SDK (tambi\u00e9n conocido como libupnp) en versiones anteriores a 1.6.21 permite a atacantes remotos escribir a archivos arbitrarios en el webroot a trav\u00e9s de una petici\u00f3n POST sin un contralodor registrado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libupnp_project:libupnp:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.6.20", "matchCriteriaId": "29A492AC-F144-4DBB-ABA1-FC075D81856F"}]}]}], "references": [{"url": "http://www.debian.org/security/2016/dsa-3736", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/07/18/13", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/07/20/5", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/92050", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/mjg59/pupnp-code/commit/be0a01bdb83395d9f3a5ea09c1308a4f1a972cbd", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201701-52", "source": "cve@mitre.org"}, {"url": "https://sourceforge.net/p/pupnp/code/ci/master/tree/ChangeLog", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://twitter.com/mjg59/status/755062278513319936", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/40589/", "source": "cve@mitre.org"}, {"url": "https://www.tenable.com/security/research/tra-2017-10", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/mjg59/pupnp-code/commit/be0a01bdb83395d9f3a5ea09c1308a4f1a972cbd"}}