{"buggy_code": ["/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../../SDL_internal.h\"\n\n#if SDL_VIDEO_RENDER_OGL_ES && !SDL_RENDER_DISABLED\n\n#include \"SDL_hints.h\"\n#include \"../../video/SDL_sysvideo.h\" /* For SDL_GL_SwapWindowWithResult */\n#include \"SDL_opengles.h\"\n#include \"../SDL_sysrender.h\"\n#include \"../../SDL_utils_c.h\"\n\n/* To prevent unnecessary window recreation,\n * these should match the defaults selected in SDL_GL_ResetAttributes\n */\n\n#define RENDERER_CONTEXT_MAJOR 1\n#define RENDERER_CONTEXT_MINOR 1\n\n#if defined(SDL_VIDEO_DRIVER_PANDORA)\n\n/* Empty function stub to get OpenGL ES 1.x support without  */\n/* OpenGL ES extension GL_OES_draw_texture supported         */\nGL_API void GL_APIENTRY\nglDrawTexiOES(GLint x, GLint y, GLint z, GLint width, GLint height)\n{\n    return;\n}\n\n#endif /* SDL_VIDEO_DRIVER_PANDORA */\n\n/* OpenGL ES 1.1 renderer implementation, based on the OpenGL renderer */\n\n/* Used to re-create the window with OpenGL ES capability */\nextern int SDL_RecreateWindow(SDL_Window * window, Uint32 flags);\n\nstatic const float inv255f = 1.0f / 255.0f;\n\ntypedef struct GLES_FBOList GLES_FBOList;\n\nstruct GLES_FBOList\n{\n   Uint32 w, h;\n   GLuint FBO;\n   GLES_FBOList *next;\n};\n\ntypedef struct\n{\n    SDL_Rect viewport;\n    SDL_bool viewport_dirty;\n    SDL_Texture *texture;\n    SDL_Texture *target;\n    int drawablew;\n    int drawableh;\n    SDL_BlendMode blend;\n    SDL_bool cliprect_enabled_dirty;\n    SDL_bool cliprect_enabled;\n    SDL_bool cliprect_dirty;\n    SDL_Rect cliprect;\n    SDL_bool texturing;\n    Uint32 color;\n    Uint32 clear_color;\n} GLES_DrawStateCache;\n\ntypedef struct\n{\n    SDL_GLContext context;\n\n#define SDL_PROC(ret,func,params) ret (APIENTRY *func) params;\n#define SDL_PROC_OES SDL_PROC\n#include \"SDL_glesfuncs.h\"\n#undef SDL_PROC\n#undef SDL_PROC_OES\n    SDL_bool GL_OES_framebuffer_object_supported;\n    GLES_FBOList *framebuffers;\n    GLuint window_framebuffer;\n\n    SDL_bool GL_OES_blend_func_separate_supported;\n    SDL_bool GL_OES_blend_equation_separate_supported;\n    SDL_bool GL_OES_blend_subtract_supported;\n\n    GLES_DrawStateCache drawstate;\n} GLES_RenderData;\n\ntypedef struct\n{\n    GLuint texture;\n    GLenum type;\n    GLfloat texw;\n    GLfloat texh;\n    GLenum format;\n    GLenum formattype;\n    void *pixels;\n    int pitch;\n    GLES_FBOList *fbo;\n} GLES_TextureData;\n\nstatic int\nGLES_SetError(const char *prefix, GLenum result)\n{\n    const char *error;\n\n    switch (result) {\n    case GL_NO_ERROR:\n        error = \"GL_NO_ERROR\";\n        break;\n    case GL_INVALID_ENUM:\n        error = \"GL_INVALID_ENUM\";\n        break;\n    case GL_INVALID_VALUE:\n        error = \"GL_INVALID_VALUE\";\n        break;\n    case GL_INVALID_OPERATION:\n        error = \"GL_INVALID_OPERATION\";\n        break;\n    case GL_STACK_OVERFLOW:\n        error = \"GL_STACK_OVERFLOW\";\n        break;\n    case GL_STACK_UNDERFLOW:\n        error = \"GL_STACK_UNDERFLOW\";\n        break;\n    case GL_OUT_OF_MEMORY:\n        error = \"GL_OUT_OF_MEMORY\";\n        break;\n    default:\n        error = \"UNKNOWN\";\n        break;\n    }\n    return SDL_SetError(\"%s: %s\", prefix, error);\n}\n\nstatic int GLES_LoadFunctions(GLES_RenderData * data)\n{\n#if SDL_VIDEO_DRIVER_UIKIT\n#define __SDL_NOGETPROCADDR__\n#elif SDL_VIDEO_DRIVER_ANDROID\n#define __SDL_NOGETPROCADDR__\n#elif SDL_VIDEO_DRIVER_PANDORA\n#define __SDL_NOGETPROCADDR__\n#endif\n\n#ifdef __SDL_NOGETPROCADDR__\n#define SDL_PROC(ret,func,params) data->func=func;\n#define SDL_PROC_OES(ret,func,params) data->func=func;\n#else\n#define SDL_PROC(ret,func,params) \\\n    do { \\\n        data->func = SDL_GL_GetProcAddress(#func); \\\n        if ( ! data->func ) { \\\n            return SDL_SetError(\"Couldn't load GLES function %s: %s\", #func, SDL_GetError()); \\\n        } \\\n    } while ( 0 );\n#define SDL_PROC_OES(ret,func,params) \\\n    do { \\\n        data->func = SDL_GL_GetProcAddress(#func); \\\n    } while ( 0 );\n#endif /* __SDL_NOGETPROCADDR__ */\n\n#include \"SDL_glesfuncs.h\"\n#undef SDL_PROC\n#undef SDL_PROC_OES\n    return 0;\n}\n\nstatic GLES_FBOList *\nGLES_GetFBO(GLES_RenderData *data, Uint32 w, Uint32 h)\n{\n   GLES_FBOList *result = data->framebuffers;\n   while ((result) && ((result->w != w) || (result->h != h)) ) {\n       result = result->next;\n   }\n   if (result == NULL) {\n       result = SDL_malloc(sizeof(GLES_FBOList));\n       result->w = w;\n       result->h = h;\n       data->glGenFramebuffersOES(1, &result->FBO);\n       result->next = data->framebuffers;\n       data->framebuffers = result;\n   }\n   return result;\n}\n\n\nstatic int\nGLES_ActivateRenderer(SDL_Renderer * renderer)\n{\n    GLES_RenderData *data = (GLES_RenderData *) renderer->driverdata;\n\n    if (SDL_GL_GetCurrentContext() != data->context) {\n        if (SDL_GL_MakeCurrent(renderer->window, data->context) < 0) {\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\nstatic void\nGLES_WindowEvent(SDL_Renderer * renderer, const SDL_WindowEvent *event)\n{\n    GLES_RenderData *data = (GLES_RenderData *) renderer->driverdata;\n\n    if (event->event == SDL_WINDOWEVENT_MINIMIZED) {\n        /* According to Apple documentation, we need to finish drawing NOW! */\n        data->glFinish();\n    }\n}\n\nstatic int\nGLES_GetOutputSize(SDL_Renderer * renderer, int *w, int *h)\n{\n    SDL_GL_GetDrawableSize(renderer->window, w, h);\n    return 0;\n}\n\nstatic GLenum GetBlendFunc(SDL_BlendFactor factor)\n{\n    switch (factor) {\n    case SDL_BLENDFACTOR_ZERO:\n        return GL_ZERO;\n    case SDL_BLENDFACTOR_ONE:\n        return GL_ONE;\n    case SDL_BLENDFACTOR_SRC_COLOR:\n        return GL_SRC_COLOR;\n    case SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR:\n        return GL_ONE_MINUS_SRC_COLOR;\n    case SDL_BLENDFACTOR_SRC_ALPHA:\n        return GL_SRC_ALPHA;\n    case SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA:\n        return GL_ONE_MINUS_SRC_ALPHA;\n    case SDL_BLENDFACTOR_DST_COLOR:\n        return GL_DST_COLOR;\n    case SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR:\n        return GL_ONE_MINUS_DST_COLOR;\n    case SDL_BLENDFACTOR_DST_ALPHA:\n        return GL_DST_ALPHA;\n    case SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA:\n        return GL_ONE_MINUS_DST_ALPHA;\n    default:\n        return GL_INVALID_ENUM;\n    }\n}\n\nstatic GLenum GetBlendEquation(SDL_BlendOperation operation)\n{\n    switch (operation) {\n    case SDL_BLENDOPERATION_ADD:\n        return GL_FUNC_ADD_OES;\n    case SDL_BLENDOPERATION_SUBTRACT:\n        return GL_FUNC_SUBTRACT_OES;\n    case SDL_BLENDOPERATION_REV_SUBTRACT:\n        return GL_FUNC_REVERSE_SUBTRACT_OES;\n    default:\n        return GL_INVALID_ENUM;\n    }\n}\n\nstatic SDL_bool\nGLES_SupportsBlendMode(SDL_Renderer * renderer, SDL_BlendMode blendMode)\n{\n    GLES_RenderData *data = (GLES_RenderData *) renderer->driverdata;\n    SDL_BlendFactor srcColorFactor = SDL_GetBlendModeSrcColorFactor(blendMode);\n    SDL_BlendFactor srcAlphaFactor = SDL_GetBlendModeSrcAlphaFactor(blendMode);\n    SDL_BlendOperation colorOperation = SDL_GetBlendModeColorOperation(blendMode);\n    SDL_BlendFactor dstColorFactor = SDL_GetBlendModeDstColorFactor(blendMode);\n    SDL_BlendFactor dstAlphaFactor = SDL_GetBlendModeDstAlphaFactor(blendMode);\n    SDL_BlendOperation alphaOperation = SDL_GetBlendModeAlphaOperation(blendMode);\n\n    if (GetBlendFunc(srcColorFactor) == GL_INVALID_ENUM ||\n        GetBlendFunc(srcAlphaFactor) == GL_INVALID_ENUM ||\n        GetBlendEquation(colorOperation) == GL_INVALID_ENUM ||\n        GetBlendFunc(dstColorFactor) == GL_INVALID_ENUM ||\n        GetBlendFunc(dstAlphaFactor) == GL_INVALID_ENUM ||\n        GetBlendEquation(alphaOperation) == GL_INVALID_ENUM) {\n        return SDL_FALSE;\n    }\n    if ((srcColorFactor != srcAlphaFactor || dstColorFactor != dstAlphaFactor) && !data->GL_OES_blend_func_separate_supported) {\n        return SDL_FALSE;\n    }\n    if (colorOperation != alphaOperation && !data->GL_OES_blend_equation_separate_supported) {\n        return SDL_FALSE;\n    }\n    if (colorOperation != SDL_BLENDOPERATION_ADD && !data->GL_OES_blend_subtract_supported) {\n        return SDL_FALSE;\n    }\n    return SDL_TRUE;\n}\n\nstatic int\nGLES_CreateTexture(SDL_Renderer * renderer, SDL_Texture * texture)\n{\n    GLES_RenderData *renderdata = (GLES_RenderData *) renderer->driverdata;\n    GLES_TextureData *data;\n    GLint internalFormat;\n    GLenum format, type;\n    int texture_w, texture_h;\n    GLenum scaleMode;\n    GLenum result;\n\n    GLES_ActivateRenderer(renderer);\n\n    switch (texture->format) {\n    case SDL_PIXELFORMAT_ABGR8888:\n        internalFormat = GL_RGBA;\n        format = GL_RGBA;\n        type = GL_UNSIGNED_BYTE;\n        break;\n    default:\n        return SDL_SetError(\"Texture format not supported\");\n    }\n\n    data = (GLES_TextureData *) SDL_calloc(1, sizeof(*data));\n    if (!data) {\n        return SDL_OutOfMemory();\n    }\n\n    if (texture->access == SDL_TEXTUREACCESS_STREAMING) {\n        data->pitch = texture->w * SDL_BYTESPERPIXEL(texture->format);\n        data->pixels = SDL_calloc(1, texture->h * data->pitch);\n        if (!data->pixels) {\n            SDL_free(data);\n            return SDL_OutOfMemory();\n        }\n    }\n\n\n    if (texture->access == SDL_TEXTUREACCESS_TARGET) {\n        if (!renderdata->GL_OES_framebuffer_object_supported) {\n            SDL_free(data);\n            return SDL_SetError(\"GL_OES_framebuffer_object not supported\");\n        }\n        data->fbo = GLES_GetFBO(renderer->driverdata, texture->w, texture->h);\n    } else {\n        data->fbo = NULL;\n    }\n\n\n    renderdata->glGetError();\n    renderdata->glEnable(GL_TEXTURE_2D);\n    renderdata->glGenTextures(1, &data->texture);\n    result = renderdata->glGetError();\n    if (result != GL_NO_ERROR) {\n        SDL_free(data);\n        return GLES_SetError(\"glGenTextures()\", result);\n    }\n\n    data->type = GL_TEXTURE_2D;\n    /* no NPOV textures allowed in OpenGL ES (yet) */\n    texture_w = SDL_powerof2(texture->w);\n    texture_h = SDL_powerof2(texture->h);\n    data->texw = (GLfloat) texture->w / texture_w;\n    data->texh = (GLfloat) texture->h / texture_h;\n\n    data->format = format;\n    data->formattype = type;\n    scaleMode = (texture->scaleMode == SDL_ScaleModeNearest) ? GL_NEAREST : GL_LINEAR;\n    renderdata->glBindTexture(data->type, data->texture);\n    renderdata->glTexParameteri(data->type, GL_TEXTURE_MIN_FILTER, scaleMode);\n    renderdata->glTexParameteri(data->type, GL_TEXTURE_MAG_FILTER, scaleMode);\n    renderdata->glTexParameteri(data->type, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n    renderdata->glTexParameteri(data->type, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n\n    renderdata->glTexImage2D(data->type, 0, internalFormat, texture_w,\n                             texture_h, 0, format, type, NULL);\n    renderdata->glDisable(GL_TEXTURE_2D);\n    renderdata->drawstate.texture = texture;\n    renderdata->drawstate.texturing = SDL_FALSE;\n\n    result = renderdata->glGetError();\n    if (result != GL_NO_ERROR) {\n        SDL_free(data);\n        return GLES_SetError(\"glTexImage2D()\", result);\n    }\n\n    texture->driverdata = data;\n    return 0;\n}\n\nstatic int\nGLES_UpdateTexture(SDL_Renderer * renderer, SDL_Texture * texture,\n                   const SDL_Rect * rect, const void *pixels, int pitch)\n{\n    GLES_RenderData *renderdata = (GLES_RenderData *) renderer->driverdata;\n    GLES_TextureData *data = (GLES_TextureData *) texture->driverdata;\n    Uint8 *blob = NULL;\n    Uint8 *src;\n    int srcPitch;\n    int y;\n\n    GLES_ActivateRenderer(renderer);\n\n    /* Bail out if we're supposed to update an empty rectangle */\n    if (rect->w <= 0 || rect->h <= 0) {\n        return 0;\n    }\n\n    /* Reformat the texture data into a tightly packed array */\n    srcPitch = rect->w * SDL_BYTESPERPIXEL(texture->format);\n    src = (Uint8 *)pixels;\n    if (pitch != srcPitch) {\n        blob = (Uint8 *)SDL_malloc(srcPitch * rect->h);\n        if (!blob) {\n            return SDL_OutOfMemory();\n        }\n        src = blob;\n        for (y = 0; y < rect->h; ++y) {\n            SDL_memcpy(src, pixels, srcPitch);\n            src += srcPitch;\n            pixels = (Uint8 *)pixels + pitch;\n        }\n        src = blob;\n    }\n\n    /* Create a texture subimage with the supplied data */\n    renderdata->glGetError();\n    renderdata->glEnable(data->type);\n    renderdata->glBindTexture(data->type, data->texture);\n    renderdata->glPixelStorei(GL_UNPACK_ALIGNMENT, 1);\n    renderdata->glTexSubImage2D(data->type,\n                    0,\n                    rect->x,\n                    rect->y,\n                    rect->w,\n                    rect->h,\n                    data->format,\n                    data->formattype,\n                    src);\n    renderdata->glDisable(data->type);\n    SDL_free(blob);\n\n    renderdata->drawstate.texture = texture;\n    renderdata->drawstate.texturing = SDL_FALSE;\n\n    if (renderdata->glGetError() != GL_NO_ERROR) {\n        return SDL_SetError(\"Failed to update texture\");\n    }\n    return 0;\n}\n\nstatic int\nGLES_LockTexture(SDL_Renderer * renderer, SDL_Texture * texture,\n                 const SDL_Rect * rect, void **pixels, int *pitch)\n{\n    GLES_TextureData *data = (GLES_TextureData *) texture->driverdata;\n\n    *pixels =\n        (void *) ((Uint8 *) data->pixels + rect->y * data->pitch +\n                  rect->x * SDL_BYTESPERPIXEL(texture->format));\n    *pitch = data->pitch;\n    return 0;\n}\n\nstatic void\nGLES_UnlockTexture(SDL_Renderer * renderer, SDL_Texture * texture)\n{\n    GLES_TextureData *data = (GLES_TextureData *) texture->driverdata;\n    SDL_Rect rect;\n\n    /* We do whole texture updates, at least for now */\n    rect.x = 0;\n    rect.y = 0;\n    rect.w = texture->w;\n    rect.h = texture->h;\n    GLES_UpdateTexture(renderer, texture, &rect, data->pixels, data->pitch);\n}\n\nstatic void\nGLES_SetTextureScaleMode(SDL_Renderer * renderer, SDL_Texture * texture, SDL_ScaleMode scaleMode)\n{\n    GLES_RenderData *renderdata = (GLES_RenderData *) renderer->driverdata;\n    GLES_TextureData *data = (GLES_TextureData *) texture->driverdata;\n    GLenum glScaleMode = (scaleMode == SDL_ScaleModeNearest) ? GL_NEAREST : GL_LINEAR;\n\n    renderdata->glBindTexture(data->type, data->texture);\n    renderdata->glTexParameteri(data->type, GL_TEXTURE_MIN_FILTER, glScaleMode);\n    renderdata->glTexParameteri(data->type, GL_TEXTURE_MAG_FILTER, glScaleMode);\n}\n\nstatic int\nGLES_SetRenderTarget(SDL_Renderer * renderer, SDL_Texture * texture)\n{\n    GLES_RenderData *data = (GLES_RenderData *) renderer->driverdata;\n    GLES_TextureData *texturedata = NULL;\n    GLenum status;\n\n    if (!data->GL_OES_framebuffer_object_supported) {\n        return SDL_SetError(\"Can't enable render target support in this renderer\");\n    }\n\n    data->drawstate.viewport_dirty = SDL_TRUE;\n\n    if (texture == NULL) {\n        data->glBindFramebufferOES(GL_FRAMEBUFFER_OES, data->window_framebuffer);\n        return 0;\n    }\n\n    texturedata = (GLES_TextureData *) texture->driverdata;\n    data->glBindFramebufferOES(GL_FRAMEBUFFER_OES, texturedata->fbo->FBO);\n    /* TODO: check if texture pixel format allows this operation */\n    data->glFramebufferTexture2DOES(GL_FRAMEBUFFER_OES, GL_COLOR_ATTACHMENT0_OES, texturedata->type, texturedata->texture, 0);\n    /* Check FBO status */\n    status = data->glCheckFramebufferStatusOES(GL_FRAMEBUFFER_OES);\n    if (status != GL_FRAMEBUFFER_COMPLETE_OES) {\n        return SDL_SetError(\"glFramebufferTexture2DOES() failed\");\n    }\n    return 0;\n}\n\n\nstatic int\nGLES_QueueSetViewport(SDL_Renderer * renderer, SDL_RenderCommand *cmd)\n{\n    return 0;  /* nothing to do in this backend. */\n}\n\nstatic int\nGLES_QueueDrawPoints(SDL_Renderer * renderer, SDL_RenderCommand *cmd, const SDL_FPoint * points, int count)\n{\n    GLfloat *verts = (GLfloat *) SDL_AllocateRenderVertices(renderer, count * 2 * sizeof (GLfloat), 0, &cmd->data.draw.first);\n    int i;\n\n    if (!verts) {\n        return -1;\n    }\n\n    cmd->data.draw.count = count;\n    for (i = 0; i < count; i++) {\n        *(verts++) = 0.5f + points[i].x;\n        *(verts++) = 0.5f + points[i].y;\n    }\n\n    return 0;\n}\n\nstatic int\nGLES_QueueDrawLines(SDL_Renderer * renderer, SDL_RenderCommand *cmd, const SDL_FPoint * points, int count)\n{\n    int i;\n    GLfloat prevx, prevy;\n    const size_t vertlen = (sizeof (GLfloat) * 2) * count;\n    GLfloat *verts = (GLfloat *) SDL_AllocateRenderVertices(renderer, vertlen, 0, &cmd->data.draw.first);\n\n    if (!verts) {\n        return -1;\n    }\n    cmd->data.draw.count = count;\n\n    /* 0.5f offset to hit the center of the pixel. */\n    prevx = 0.5f + points->x;\n    prevy = 0.5f + points->y;\n    *(verts++) = prevx;\n    *(verts++) = prevy;\n\n    /* bump the end of each line segment out a quarter of a pixel, to provoke\n       the diamond-exit rule. Without this, you won't just drop the last\n       pixel of the last line segment, but you might also drop pixels at the\n       edge of any given line segment along the way too. */\n    for (i = 1; i < count; i++) {\n        const GLfloat xstart = prevx;\n        const GLfloat ystart = prevy;\n        const GLfloat xend = points[i].x + 0.5f;  /* 0.5f to hit pixel center. */\n        const GLfloat yend = points[i].y + 0.5f;\n        /* bump a little in the direction we are moving in. */\n        const GLfloat deltax = xend - xstart;\n        const GLfloat deltay = yend - ystart;\n        const GLfloat angle = SDL_atan2f(deltay, deltax);\n        prevx = xend + (SDL_cosf(angle) * 0.25f);\n        prevy = yend + (SDL_sinf(angle) * 0.25f);\n        *(verts++) = prevx;\n        *(verts++) = prevy;\n    }\n\n    return 0;\n}\n\nstatic int\nGLES_QueueGeometry(SDL_Renderer *renderer, SDL_RenderCommand *cmd, SDL_Texture *texture,\n        const float *xy, int xy_stride, const SDL_Color *color, int color_stride, const float *uv, int uv_stride,\n        int num_vertices, const void *indices, int num_indices, int size_indices,\n        float scale_x, float scale_y)\n{\n    GLES_TextureData *texturedata = NULL;\n    int i;\n    int count = indices ? num_indices : num_vertices;\n    GLfloat *verts;\n    int sz = 2 + 4 + (texture ? 2 : 0);\n\n    verts = (GLfloat *) SDL_AllocateRenderVertices(renderer, count * sz * sizeof (GLfloat), 0, &cmd->data.draw.first);\n    if (!verts) {\n        return -1;\n    }\n\n    if (texture) {\n        texturedata = (GLES_TextureData *) texture->driverdata;\n    }\n\n    cmd->data.draw.count = count;\n    size_indices = indices ? size_indices : 0;\n\n    for (i = 0; i < count; i++) {\n        int j;\n        float *xy_;\n        SDL_Color col_;\n        if (size_indices == 4) {\n            j = ((const Uint32 *)indices)[i];\n        } else if (size_indices == 2) {\n            j = ((const Uint16 *)indices)[i];\n        } else if (size_indices == 1) {\n            j = ((const Uint8 *)indices)[i];\n        } else {\n            j = i;\n        }\n\n        xy_ = (float *)((char*)xy + j * xy_stride);\n        col_ = *(SDL_Color *)((char*)color + j * color_stride);\n\n        *(verts++) = xy_[0] * scale_x;\n        *(verts++) = xy_[1] * scale_y;\n\n        *(verts++) = col_.r * inv255f;\n        *(verts++) = col_.g * inv255f;\n        *(verts++) = col_.b * inv255f;\n        *(verts++) = col_.a * inv255f;\n\n        if (texture) {\n            float *uv_ = (float *)((char*)uv + j * uv_stride);\n            *(verts++) = uv_[0] * texturedata->texw;\n            *(verts++) = uv_[1] * texturedata->texh;\n        }\n    }\n    return 0;\n}\n\nstatic void\nSetDrawState(GLES_RenderData *data, const SDL_RenderCommand *cmd)\n{\n    const SDL_BlendMode blend = cmd->data.draw.blend;\n    const Uint8 r = cmd->data.draw.r;\n    const Uint8 g = cmd->data.draw.g;\n    const Uint8 b = cmd->data.draw.b;\n    const Uint8 a = cmd->data.draw.a;\n    const Uint32 color = (((Uint32)a << 24) | (r << 16) | (g << 8) | b);\n\n    if (color != data->drawstate.color) {\n        const GLfloat fr = ((GLfloat) r) * inv255f;\n        const GLfloat fg = ((GLfloat) g) * inv255f;\n        const GLfloat fb = ((GLfloat) b) * inv255f;\n        const GLfloat fa = ((GLfloat) a) * inv255f;\n        data->glColor4f(fr, fg, fb, fa);\n        data->drawstate.color = color;\n    }\n\n    if (data->drawstate.viewport_dirty) {\n        const SDL_Rect *viewport = &data->drawstate.viewport;\n        const SDL_bool istarget = (data->drawstate.target != NULL);\n        data->glMatrixMode(GL_PROJECTION);\n        data->glLoadIdentity();\n        data->glViewport(viewport->x,\n                         istarget ? viewport->y : (data->drawstate.drawableh - viewport->y - viewport->h),\n                         viewport->w, viewport->h);\n        if (viewport->w && viewport->h) {\n            data->glOrthof((GLfloat) 0, (GLfloat) viewport->w,\n                           (GLfloat) (istarget ? 0 : viewport->h),\n                           (GLfloat) (istarget ? viewport->h : 0),\n                           0.0, 1.0);\n        }\n        data->glMatrixMode(GL_MODELVIEW);\n        data->drawstate.viewport_dirty = SDL_FALSE;\n    }\n\n    if (data->drawstate.cliprect_enabled_dirty) {\n        if (data->drawstate.cliprect_enabled) {\n            data->glEnable(GL_SCISSOR_TEST);\n        } else {\n            data->glDisable(GL_SCISSOR_TEST);\n        }\n        data->drawstate.cliprect_enabled_dirty = SDL_FALSE;\n    }\n\n    if (data->drawstate.cliprect_enabled && data->drawstate.cliprect_dirty) {\n        const SDL_Rect *viewport = &data->drawstate.viewport;\n        const SDL_Rect *rect = &data->drawstate.cliprect;\n        const SDL_bool istarget = (data->drawstate.target != NULL);\n        data->glScissor(viewport->x + rect->x,\n                        istarget ? viewport->y + rect->y : data->drawstate.drawableh - viewport->y - rect->y - rect->h,\n                        rect->w, rect->h);\n        data->drawstate.cliprect_dirty = SDL_FALSE;\n    }\n\n    if (blend != data->drawstate.blend) {\n        if (blend == SDL_BLENDMODE_NONE) {\n            data->glDisable(GL_BLEND);\n        } else {\n            data->glEnable(GL_BLEND);\n            if (data->GL_OES_blend_func_separate_supported) {\n                data->glBlendFuncSeparateOES(GetBlendFunc(SDL_GetBlendModeSrcColorFactor(blend)),\n                                             GetBlendFunc(SDL_GetBlendModeDstColorFactor(blend)),\n                                             GetBlendFunc(SDL_GetBlendModeSrcAlphaFactor(blend)),\n                                             GetBlendFunc(SDL_GetBlendModeDstAlphaFactor(blend)));\n            } else {\n                data->glBlendFunc(GetBlendFunc(SDL_GetBlendModeSrcColorFactor(blend)),\n                                  GetBlendFunc(SDL_GetBlendModeDstColorFactor(blend)));\n            }\n            if (data->GL_OES_blend_equation_separate_supported) {\n                data->glBlendEquationSeparateOES(GetBlendEquation(SDL_GetBlendModeColorOperation(blend)),\n                                                 GetBlendEquation(SDL_GetBlendModeAlphaOperation(blend)));\n            } else if (data->GL_OES_blend_subtract_supported) {\n                data->glBlendEquationOES(GetBlendEquation(SDL_GetBlendModeColorOperation(blend)));\n            }\n        }\n        data->drawstate.blend = blend;\n    }\n\n    if ((cmd->data.draw.texture != NULL) != data->drawstate.texturing) {\n        if (cmd->data.draw.texture == NULL) {\n            data->glDisable(GL_TEXTURE_2D);\n            data->glDisableClientState(GL_TEXTURE_COORD_ARRAY);\n            data->drawstate.texturing = SDL_FALSE;\n        } else {\n            data->glEnable(GL_TEXTURE_2D);\n            data->glEnableClientState(GL_TEXTURE_COORD_ARRAY);\n            data->drawstate.texturing = SDL_TRUE;\n        }\n    }\n}\n\nstatic void\nSetCopyState(GLES_RenderData *data, const SDL_RenderCommand *cmd)\n{\n    SDL_Texture *texture = cmd->data.draw.texture;\n    SetDrawState(data, cmd);\n\n    if (texture != data->drawstate.texture) {\n        GLES_TextureData *texturedata = (GLES_TextureData *) texture->driverdata;\n        data->glBindTexture(GL_TEXTURE_2D, texturedata->texture);\n        data->drawstate.texture = texture;\n    }\n}\n\nstatic int\nGLES_RunCommandQueue(SDL_Renderer * renderer, SDL_RenderCommand *cmd, void *vertices, size_t vertsize)\n{\n    GLES_RenderData *data = (GLES_RenderData *) renderer->driverdata;\n\n    if (GLES_ActivateRenderer(renderer) < 0) {\n        return -1;\n    }\n\n    data->drawstate.target = renderer->target;\n\n    if (!renderer->target) {\n        int w, h;\n        SDL_GL_GetDrawableSize(renderer->window, &w, &h);\n        if ((w != data->drawstate.drawablew) || (h != data->drawstate.drawableh)) {\n            data->drawstate.viewport_dirty = SDL_TRUE;  // if the window dimensions changed, invalidate the current viewport, etc.\n            data->drawstate.cliprect_dirty = SDL_TRUE;\n            data->drawstate.drawablew = w;\n            data->drawstate.drawableh = h;\n        }\n\n    }\n\n    while (cmd) {\n        switch (cmd->command) {\n            case SDL_RENDERCMD_SETDRAWCOLOR: {\n                break;  /* not used in this render backend. */\n            }\n\n            case SDL_RENDERCMD_SETVIEWPORT: {\n                SDL_Rect *viewport = &data->drawstate.viewport;\n                if (SDL_memcmp(viewport, &cmd->data.viewport.rect, sizeof(cmd->data.viewport.rect)) != 0) {\n                    SDL_copyp(viewport, &cmd->data.viewport.rect);\n                    data->drawstate.viewport_dirty = SDL_TRUE;\n                }\n                break;\n            }\n\n            case SDL_RENDERCMD_SETCLIPRECT: {\n                const SDL_Rect *rect = &cmd->data.cliprect.rect;\n                if (data->drawstate.cliprect_enabled != cmd->data.cliprect.enabled) {\n                    data->drawstate.cliprect_enabled = cmd->data.cliprect.enabled;\n                    data->drawstate.cliprect_enabled_dirty = SDL_TRUE;\n                }\n                if (SDL_memcmp(&data->drawstate.cliprect, rect, sizeof(*rect)) != 0) {\n                    SDL_copyp(&data->drawstate.cliprect, rect);\n                    data->drawstate.cliprect_dirty = SDL_TRUE;\n                }\n                break;\n            }\n\n            case SDL_RENDERCMD_CLEAR: {\n                const Uint8 r = cmd->data.color.r;\n                const Uint8 g = cmd->data.color.g;\n                const Uint8 b = cmd->data.color.b;\n                const Uint8 a = cmd->data.color.a;\n                const Uint32 color = (((Uint32)a << 24) | (r << 16) | (g << 8) | b);\n                if (color != data->drawstate.clear_color) {\n                    const GLfloat fr = ((GLfloat) r) * inv255f;\n                    const GLfloat fg = ((GLfloat) g) * inv255f;\n                    const GLfloat fb = ((GLfloat) b) * inv255f;\n                    const GLfloat fa = ((GLfloat) a) * inv255f;\n                    data->glClearColor(fr, fg, fb, fa);\n                    data->drawstate.clear_color = color;\n                }\n\n                if (data->drawstate.cliprect_enabled || data->drawstate.cliprect_enabled_dirty) {\n                    data->glDisable(GL_SCISSOR_TEST);\n                    data->drawstate.cliprect_enabled_dirty = data->drawstate.cliprect_enabled;\n                }\n\n                data->glClear(GL_COLOR_BUFFER_BIT);\n\n                break;\n            }\n\n            case SDL_RENDERCMD_DRAW_POINTS: {\n                const size_t count = cmd->data.draw.count;\n                const GLfloat *verts = (GLfloat *) (((Uint8 *) vertices) + cmd->data.draw.first);\n                SetDrawState(data, cmd);\n                data->glVertexPointer(2, GL_FLOAT, 0, verts);\n                data->glDrawArrays(GL_POINTS, 0, (GLsizei) count);\n                break;\n            }\n\n            case SDL_RENDERCMD_DRAW_LINES: {\n                const GLfloat *verts = (GLfloat *) (((Uint8 *) vertices) + cmd->data.draw.first);\n                const size_t count = cmd->data.draw.count;\n                SDL_assert(count >= 2);\n                SetDrawState(data, cmd);\n                data->glVertexPointer(2, GL_FLOAT, 0, verts);\n                data->glDrawArrays(GL_LINE_STRIP, 0, (GLsizei) count);\n                break;\n            }\n\n            case SDL_RENDERCMD_FILL_RECTS: /* unused */\n                break;\n\n            case SDL_RENDERCMD_COPY: /* unused */\n                break;\n\n            case SDL_RENDERCMD_COPY_EX: /* unused */\n                break;\n\n            case SDL_RENDERCMD_GEOMETRY: {\n                const GLfloat *verts = (GLfloat *) (((Uint8 *) vertices) + cmd->data.draw.first);\n                SDL_Texture *texture = cmd->data.draw.texture;\n                const size_t count = cmd->data.draw.count;\n                int stride = (2 + 4 + (texture ? 2 : 0)) * sizeof (float);\n\n                if (texture) {\n                    SetCopyState(data, cmd);\n                } else {\n                    SetDrawState(data, cmd);\n                }\n\n                data->glEnableClientState(GL_COLOR_ARRAY);\n\n                data->glVertexPointer(2, GL_FLOAT, stride, verts);\n                data->glColorPointer(4, GL_FLOAT, stride, verts + 2);\n                if (texture) {\n                    data->glTexCoordPointer(2, GL_FLOAT, stride, verts + 2 + 4);\n                }\n\n                data->glDrawArrays(GL_TRIANGLES, 0, (GLsizei) count);\n\n                data->glDisableClientState(GL_COLOR_ARRAY);\n                break;\n            }\n\n            case SDL_RENDERCMD_NO_OP:\n                break;\n        }\n\n        cmd = cmd->next;\n    }\n\n    return 0;\n}\n\nstatic int\nGLES_RenderReadPixels(SDL_Renderer * renderer, const SDL_Rect * rect,\n                      Uint32 pixel_format, void * pixels, int pitch)\n{\n    GLES_RenderData *data = (GLES_RenderData *) renderer->driverdata;\n    Uint32 temp_format = renderer->target ? renderer->target->format : SDL_PIXELFORMAT_ABGR8888;\n    void *temp_pixels;\n    int temp_pitch;\n    Uint8 *src, *dst, *tmp;\n    int w, h, length, rows;\n    int status;\n\n    GLES_ActivateRenderer(renderer);\n\n    temp_pitch = rect->w * SDL_BYTESPERPIXEL(temp_format);\n    temp_pixels = SDL_malloc(rect->h * temp_pitch);\n    if (!temp_pixels) {\n        return SDL_OutOfMemory();\n    }\n\n    SDL_GetRendererOutputSize(renderer, &w, &h);\n\n    data->glPixelStorei(GL_PACK_ALIGNMENT, 1);\n\n    data->glReadPixels(rect->x, renderer->target ? rect->y : (h-rect->y)-rect->h,\n                       rect->w, rect->h, GL_RGBA, GL_UNSIGNED_BYTE, temp_pixels);\n\n    /* Flip the rows to be top-down if necessary */\n    if (!renderer->target) {\n        SDL_bool isstack;\n        length = rect->w * SDL_BYTESPERPIXEL(temp_format);\n        src = (Uint8*)temp_pixels + (rect->h-1)*temp_pitch;\n        dst = (Uint8*)temp_pixels;\n        tmp = SDL_small_alloc(Uint8, length, &isstack);\n        rows = rect->h / 2;\n        while (rows--) {\n            SDL_memcpy(tmp, dst, length);\n            SDL_memcpy(dst, src, length);\n            SDL_memcpy(src, tmp, length);\n            dst += temp_pitch;\n            src -= temp_pitch;\n        }\n        SDL_small_free(tmp, isstack);\n    }\n\n    status = SDL_ConvertPixels(rect->w, rect->h,\n                               temp_format, temp_pixels, temp_pitch,\n                               pixel_format, pixels, pitch);\n    SDL_free(temp_pixels);\n\n    return status;\n}\n\nstatic int\nGLES_RenderPresent(SDL_Renderer * renderer)\n{\n    GLES_ActivateRenderer(renderer);\n\n    return SDL_GL_SwapWindowWithResult(renderer->window);\n}\n\nstatic void\nGLES_DestroyTexture(SDL_Renderer * renderer, SDL_Texture * texture)\n{\n    GLES_RenderData *renderdata = (GLES_RenderData *) renderer->driverdata;\n\n    GLES_TextureData *data = (GLES_TextureData *) texture->driverdata;\n\n    GLES_ActivateRenderer(renderer);\n\n    if (renderdata->drawstate.texture == texture) {\n        renderdata->drawstate.texture = NULL;\n    }\n    if (renderdata->drawstate.target == texture) {\n        renderdata->drawstate.target = NULL;\n    }\n\n    if (!data) {\n        return;\n    }\n    if (data->texture) {\n        renderdata->glDeleteTextures(1, &data->texture);\n    }\n    SDL_free(data->pixels);\n    SDL_free(data);\n    texture->driverdata = NULL;\n}\n\nstatic void\nGLES_DestroyRenderer(SDL_Renderer * renderer)\n{\n    GLES_RenderData *data = (GLES_RenderData *) renderer->driverdata;\n\n    if (data) {\n        if (data->context) {\n            while (data->framebuffers) {\n               GLES_FBOList *nextnode = data->framebuffers->next;\n               data->glDeleteFramebuffersOES(1, &data->framebuffers->FBO);\n               SDL_free(data->framebuffers);\n               data->framebuffers = nextnode;\n            }\n            SDL_GL_DeleteContext(data->context);\n        }\n        SDL_free(data);\n    }\n    SDL_free(renderer);\n}\n\nstatic int GLES_BindTexture (SDL_Renderer * renderer, SDL_Texture *texture, float *texw, float *texh)\n{\n    GLES_RenderData *data = (GLES_RenderData *) renderer->driverdata;\n    GLES_TextureData *texturedata = (GLES_TextureData *) texture->driverdata;\n    GLES_ActivateRenderer(renderer);\n\n    data->glEnable(GL_TEXTURE_2D);\n    data->glBindTexture(texturedata->type, texturedata->texture);\n\n    data->drawstate.texture = texture;\n    data->drawstate.texturing = SDL_TRUE;\n\n    if (texw) {\n        *texw = (float)texturedata->texw;\n    }\n    if (texh) {\n        *texh = (float)texturedata->texh;\n    }\n\n    return 0;\n}\n\nstatic int GLES_UnbindTexture (SDL_Renderer * renderer, SDL_Texture *texture)\n{\n    GLES_RenderData *data = (GLES_RenderData *) renderer->driverdata;\n    GLES_TextureData *texturedata = (GLES_TextureData *) texture->driverdata;\n    GLES_ActivateRenderer(renderer);\n    data->glDisable(texturedata->type);\n\n    data->drawstate.texture = NULL;\n    data->drawstate.texturing = SDL_FALSE;\n\n    return 0;\n}\n\nstatic int\nGLES_SetVSync(SDL_Renderer * renderer, const int vsync)\n{\n    int retval;\n    if (vsync) {\n        retval = SDL_GL_SetSwapInterval(1);\n    } else {\n        retval = SDL_GL_SetSwapInterval(0);\n    }\n    if (retval != 0) {\n        return retval;\n    }\n    if (SDL_GL_GetSwapInterval() > 0) {\n        renderer->info.flags |= SDL_RENDERER_PRESENTVSYNC;\n    } else {\n        renderer->info.flags &= ~SDL_RENDERER_PRESENTVSYNC;\n    }\n    return retval;\n}\n\n\nstatic SDL_Renderer *\nGLES_CreateRenderer(SDL_Window * window, Uint32 flags)\n{\n    SDL_Renderer *renderer;\n    GLES_RenderData *data;\n    GLint value;\n    Uint32 window_flags;\n    int profile_mask = 0, major = 0, minor = 0;\n    SDL_bool changed_window = SDL_FALSE;\n\n    SDL_GL_GetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, &profile_mask);\n    SDL_GL_GetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, &major);\n    SDL_GL_GetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, &minor);\n\n    window_flags = SDL_GetWindowFlags(window);\n    if (!(window_flags & SDL_WINDOW_OPENGL) ||\n        profile_mask != SDL_GL_CONTEXT_PROFILE_ES || major != RENDERER_CONTEXT_MAJOR || minor != RENDERER_CONTEXT_MINOR) {\n\n        changed_window = SDL_TRUE;\n        SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_ES);\n        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, RENDERER_CONTEXT_MAJOR);\n        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, RENDERER_CONTEXT_MINOR);\n\n        if (SDL_RecreateWindow(window, (window_flags & ~(SDL_WINDOW_VULKAN | SDL_WINDOW_METAL)) | SDL_WINDOW_OPENGL) < 0) {\n            goto error;\n        }\n    }\n\n    renderer = (SDL_Renderer *) SDL_calloc(1, sizeof(*renderer));\n    if (!renderer) {\n        SDL_OutOfMemory();\n        goto error;\n    }\n\n    data = (GLES_RenderData *) SDL_calloc(1, sizeof(*data));\n    if (!data) {\n        GLES_DestroyRenderer(renderer);\n        SDL_OutOfMemory();\n        goto error;\n    }\n\n    renderer->WindowEvent = GLES_WindowEvent;\n    renderer->GetOutputSize = GLES_GetOutputSize;\n    renderer->SupportsBlendMode = GLES_SupportsBlendMode;\n    renderer->CreateTexture = GLES_CreateTexture;\n    renderer->UpdateTexture = GLES_UpdateTexture;\n    renderer->LockTexture = GLES_LockTexture;\n    renderer->UnlockTexture = GLES_UnlockTexture;\n    renderer->SetTextureScaleMode = GLES_SetTextureScaleMode;\n    renderer->SetRenderTarget = GLES_SetRenderTarget;\n    renderer->QueueSetViewport = GLES_QueueSetViewport;\n    renderer->QueueSetDrawColor = GLES_QueueSetViewport;  /* SetViewport and SetDrawColor are (currently) no-ops. */\n    renderer->QueueDrawPoints = GLES_QueueDrawPoints;\n    renderer->QueueDrawLines = GLES_QueueDrawLines;\n    renderer->QueueGeometry = GLES_QueueGeometry;\n    renderer->RunCommandQueue = GLES_RunCommandQueue;\n    renderer->RenderReadPixels = GLES_RenderReadPixels;\n    renderer->RenderPresent = GLES_RenderPresent;\n    renderer->DestroyTexture = GLES_DestroyTexture;\n    renderer->DestroyRenderer = GLES_DestroyRenderer;\n    renderer->SetVSync = GLES_SetVSync;\n    renderer->GL_BindTexture = GLES_BindTexture;\n    renderer->GL_UnbindTexture = GLES_UnbindTexture;\n    renderer->info = GLES_RenderDriver.info;\n    renderer->info.flags = SDL_RENDERER_ACCELERATED;\n    renderer->driverdata = data;\n    renderer->window = window;\n\n    data->context = SDL_GL_CreateContext(window);\n    if (!data->context) {\n        GLES_DestroyRenderer(renderer);\n        goto error;\n    }\n    if (SDL_GL_MakeCurrent(window, data->context) < 0) {\n        GLES_DestroyRenderer(renderer);\n        goto error;\n    }\n\n    if (GLES_LoadFunctions(data) < 0) {\n        GLES_DestroyRenderer(renderer);\n        goto error;\n    }\n\n    if (flags & SDL_RENDERER_PRESENTVSYNC) {\n        SDL_GL_SetSwapInterval(1);\n    } else {\n        SDL_GL_SetSwapInterval(0);\n    }\n    if (SDL_GL_GetSwapInterval() > 0) {\n        renderer->info.flags |= SDL_RENDERER_PRESENTVSYNC;\n    }\n\n    value = 0;\n    data->glGetIntegerv(GL_MAX_TEXTURE_SIZE, &value);\n    renderer->info.max_texture_width = value;\n    value = 0;\n    data->glGetIntegerv(GL_MAX_TEXTURE_SIZE, &value);\n    renderer->info.max_texture_height = value;\n\n    /* Android does not report GL_OES_framebuffer_object but the functionality seems to be there anyway */\n    if (SDL_GL_ExtensionSupported(\"GL_OES_framebuffer_object\") || data->glGenFramebuffersOES) {\n        data->GL_OES_framebuffer_object_supported = SDL_TRUE;\n        renderer->info.flags |= SDL_RENDERER_TARGETTEXTURE;\n\n        value = 0;\n        data->glGetIntegerv(GL_FRAMEBUFFER_BINDING_OES, &value);\n        data->window_framebuffer = (GLuint)value;\n    }\n    data->framebuffers = NULL;\n\n    if (SDL_GL_ExtensionSupported(\"GL_OES_blend_func_separate\")) {\n        data->GL_OES_blend_func_separate_supported = SDL_TRUE;\n    }\n    if (SDL_GL_ExtensionSupported(\"GL_OES_blend_equation_separate\")) {\n        data->GL_OES_blend_equation_separate_supported = SDL_TRUE;\n    }\n    if (SDL_GL_ExtensionSupported(\"GL_OES_blend_subtract\")) {\n        data->GL_OES_blend_subtract_supported = SDL_TRUE;\n    }\n\n    /* Set up parameters for rendering */\n    data->glDisable(GL_DEPTH_TEST);\n    data->glDisable(GL_CULL_FACE);\n\n    data->glMatrixMode(GL_MODELVIEW);\n    data->glLoadIdentity();\n\n    data->glEnableClientState(GL_VERTEX_ARRAY);\n    data->glDisableClientState(GL_TEXTURE_COORD_ARRAY);\n\n    data->glClearColor(1.0f, 1.0f, 1.0f, 1.0f);\n\n    data->drawstate.blend = SDL_BLENDMODE_INVALID;\n    data->drawstate.color = 0xFFFFFFFF;\n    data->drawstate.clear_color = 0xFFFFFFFF;\n\n    return renderer;\n\nerror:\n    if (changed_window) {\n        /* Uh oh, better try to put it back... */\n        SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, profile_mask);\n        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, major);\n        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, minor);\n        SDL_RecreateWindow(window, window_flags);\n    }\n    return NULL;\n}\n\nSDL_RenderDriver GLES_RenderDriver = {\n    GLES_CreateRenderer,\n    {\n     \"opengles\",\n     (SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC),\n     1,\n     {SDL_PIXELFORMAT_ABGR8888},\n     0,\n     0\n    }\n};\n\n#endif /* SDL_VIDEO_RENDER_OGL_ES && !SDL_RENDER_DISABLED */\n\n/* vi: set ts=4 sw=4 expandtab: */\n"], "fixing_code": ["/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../../SDL_internal.h\"\n\n#if SDL_VIDEO_RENDER_OGL_ES && !SDL_RENDER_DISABLED\n\n#include \"SDL_hints.h\"\n#include \"../../video/SDL_sysvideo.h\" /* For SDL_GL_SwapWindowWithResult */\n#include \"SDL_opengles.h\"\n#include \"../SDL_sysrender.h\"\n#include \"../../SDL_utils_c.h\"\n\n/* To prevent unnecessary window recreation,\n * these should match the defaults selected in SDL_GL_ResetAttributes\n */\n\n#define RENDERER_CONTEXT_MAJOR 1\n#define RENDERER_CONTEXT_MINOR 1\n\n#if defined(SDL_VIDEO_DRIVER_PANDORA)\n\n/* Empty function stub to get OpenGL ES 1.x support without  */\n/* OpenGL ES extension GL_OES_draw_texture supported         */\nGL_API void GL_APIENTRY\nglDrawTexiOES(GLint x, GLint y, GLint z, GLint width, GLint height)\n{\n    return;\n}\n\n#endif /* SDL_VIDEO_DRIVER_PANDORA */\n\n/* OpenGL ES 1.1 renderer implementation, based on the OpenGL renderer */\n\n/* Used to re-create the window with OpenGL ES capability */\nextern int SDL_RecreateWindow(SDL_Window * window, Uint32 flags);\n\nstatic const float inv255f = 1.0f / 255.0f;\n\ntypedef struct GLES_FBOList GLES_FBOList;\n\nstruct GLES_FBOList\n{\n   Uint32 w, h;\n   GLuint FBO;\n   GLES_FBOList *next;\n};\n\ntypedef struct\n{\n    SDL_Rect viewport;\n    SDL_bool viewport_dirty;\n    SDL_Texture *texture;\n    SDL_Texture *target;\n    int drawablew;\n    int drawableh;\n    SDL_BlendMode blend;\n    SDL_bool cliprect_enabled_dirty;\n    SDL_bool cliprect_enabled;\n    SDL_bool cliprect_dirty;\n    SDL_Rect cliprect;\n    SDL_bool texturing;\n    Uint32 color;\n    Uint32 clear_color;\n} GLES_DrawStateCache;\n\ntypedef struct\n{\n    SDL_GLContext context;\n\n#define SDL_PROC(ret,func,params) ret (APIENTRY *func) params;\n#define SDL_PROC_OES SDL_PROC\n#include \"SDL_glesfuncs.h\"\n#undef SDL_PROC\n#undef SDL_PROC_OES\n    SDL_bool GL_OES_framebuffer_object_supported;\n    GLES_FBOList *framebuffers;\n    GLuint window_framebuffer;\n\n    SDL_bool GL_OES_blend_func_separate_supported;\n    SDL_bool GL_OES_blend_equation_separate_supported;\n    SDL_bool GL_OES_blend_subtract_supported;\n\n    GLES_DrawStateCache drawstate;\n} GLES_RenderData;\n\ntypedef struct\n{\n    GLuint texture;\n    GLenum type;\n    GLfloat texw;\n    GLfloat texh;\n    GLenum format;\n    GLenum formattype;\n    void *pixels;\n    int pitch;\n    GLES_FBOList *fbo;\n} GLES_TextureData;\n\nstatic int\nGLES_SetError(const char *prefix, GLenum result)\n{\n    const char *error;\n\n    switch (result) {\n    case GL_NO_ERROR:\n        error = \"GL_NO_ERROR\";\n        break;\n    case GL_INVALID_ENUM:\n        error = \"GL_INVALID_ENUM\";\n        break;\n    case GL_INVALID_VALUE:\n        error = \"GL_INVALID_VALUE\";\n        break;\n    case GL_INVALID_OPERATION:\n        error = \"GL_INVALID_OPERATION\";\n        break;\n    case GL_STACK_OVERFLOW:\n        error = \"GL_STACK_OVERFLOW\";\n        break;\n    case GL_STACK_UNDERFLOW:\n        error = \"GL_STACK_UNDERFLOW\";\n        break;\n    case GL_OUT_OF_MEMORY:\n        error = \"GL_OUT_OF_MEMORY\";\n        break;\n    default:\n        error = \"UNKNOWN\";\n        break;\n    }\n    return SDL_SetError(\"%s: %s\", prefix, error);\n}\n\nstatic int GLES_LoadFunctions(GLES_RenderData * data)\n{\n#if SDL_VIDEO_DRIVER_UIKIT\n#define __SDL_NOGETPROCADDR__\n#elif SDL_VIDEO_DRIVER_ANDROID\n#define __SDL_NOGETPROCADDR__\n#elif SDL_VIDEO_DRIVER_PANDORA\n#define __SDL_NOGETPROCADDR__\n#endif\n\n#ifdef __SDL_NOGETPROCADDR__\n#define SDL_PROC(ret,func,params) data->func=func;\n#define SDL_PROC_OES(ret,func,params) data->func=func;\n#else\n#define SDL_PROC(ret,func,params) \\\n    do { \\\n        data->func = SDL_GL_GetProcAddress(#func); \\\n        if ( ! data->func ) { \\\n            return SDL_SetError(\"Couldn't load GLES function %s: %s\", #func, SDL_GetError()); \\\n        } \\\n    } while ( 0 );\n#define SDL_PROC_OES(ret,func,params) \\\n    do { \\\n        data->func = SDL_GL_GetProcAddress(#func); \\\n    } while ( 0 );\n#endif /* __SDL_NOGETPROCADDR__ */\n\n#include \"SDL_glesfuncs.h\"\n#undef SDL_PROC\n#undef SDL_PROC_OES\n    return 0;\n}\n\nstatic GLES_FBOList *\nGLES_GetFBO(GLES_RenderData *data, Uint32 w, Uint32 h)\n{\n   GLES_FBOList *result = data->framebuffers;\n   while ((result) && ((result->w != w) || (result->h != h)) ) {\n       result = result->next;\n   }\n   if (result == NULL) {\n       result = SDL_malloc(sizeof(GLES_FBOList));\n       result->w = w;\n       result->h = h;\n       data->glGenFramebuffersOES(1, &result->FBO);\n       result->next = data->framebuffers;\n       data->framebuffers = result;\n   }\n   return result;\n}\n\n\nstatic int\nGLES_ActivateRenderer(SDL_Renderer * renderer)\n{\n    GLES_RenderData *data = (GLES_RenderData *) renderer->driverdata;\n\n    if (SDL_GL_GetCurrentContext() != data->context) {\n        if (SDL_GL_MakeCurrent(renderer->window, data->context) < 0) {\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\nstatic void\nGLES_WindowEvent(SDL_Renderer * renderer, const SDL_WindowEvent *event)\n{\n    GLES_RenderData *data = (GLES_RenderData *) renderer->driverdata;\n\n    if (event->event == SDL_WINDOWEVENT_MINIMIZED) {\n        /* According to Apple documentation, we need to finish drawing NOW! */\n        data->glFinish();\n    }\n}\n\nstatic int\nGLES_GetOutputSize(SDL_Renderer * renderer, int *w, int *h)\n{\n    SDL_GL_GetDrawableSize(renderer->window, w, h);\n    return 0;\n}\n\nstatic GLenum GetBlendFunc(SDL_BlendFactor factor)\n{\n    switch (factor) {\n    case SDL_BLENDFACTOR_ZERO:\n        return GL_ZERO;\n    case SDL_BLENDFACTOR_ONE:\n        return GL_ONE;\n    case SDL_BLENDFACTOR_SRC_COLOR:\n        return GL_SRC_COLOR;\n    case SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR:\n        return GL_ONE_MINUS_SRC_COLOR;\n    case SDL_BLENDFACTOR_SRC_ALPHA:\n        return GL_SRC_ALPHA;\n    case SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA:\n        return GL_ONE_MINUS_SRC_ALPHA;\n    case SDL_BLENDFACTOR_DST_COLOR:\n        return GL_DST_COLOR;\n    case SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR:\n        return GL_ONE_MINUS_DST_COLOR;\n    case SDL_BLENDFACTOR_DST_ALPHA:\n        return GL_DST_ALPHA;\n    case SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA:\n        return GL_ONE_MINUS_DST_ALPHA;\n    default:\n        return GL_INVALID_ENUM;\n    }\n}\n\nstatic GLenum GetBlendEquation(SDL_BlendOperation operation)\n{\n    switch (operation) {\n    case SDL_BLENDOPERATION_ADD:\n        return GL_FUNC_ADD_OES;\n    case SDL_BLENDOPERATION_SUBTRACT:\n        return GL_FUNC_SUBTRACT_OES;\n    case SDL_BLENDOPERATION_REV_SUBTRACT:\n        return GL_FUNC_REVERSE_SUBTRACT_OES;\n    default:\n        return GL_INVALID_ENUM;\n    }\n}\n\nstatic SDL_bool\nGLES_SupportsBlendMode(SDL_Renderer * renderer, SDL_BlendMode blendMode)\n{\n    GLES_RenderData *data = (GLES_RenderData *) renderer->driverdata;\n    SDL_BlendFactor srcColorFactor = SDL_GetBlendModeSrcColorFactor(blendMode);\n    SDL_BlendFactor srcAlphaFactor = SDL_GetBlendModeSrcAlphaFactor(blendMode);\n    SDL_BlendOperation colorOperation = SDL_GetBlendModeColorOperation(blendMode);\n    SDL_BlendFactor dstColorFactor = SDL_GetBlendModeDstColorFactor(blendMode);\n    SDL_BlendFactor dstAlphaFactor = SDL_GetBlendModeDstAlphaFactor(blendMode);\n    SDL_BlendOperation alphaOperation = SDL_GetBlendModeAlphaOperation(blendMode);\n\n    if (GetBlendFunc(srcColorFactor) == GL_INVALID_ENUM ||\n        GetBlendFunc(srcAlphaFactor) == GL_INVALID_ENUM ||\n        GetBlendEquation(colorOperation) == GL_INVALID_ENUM ||\n        GetBlendFunc(dstColorFactor) == GL_INVALID_ENUM ||\n        GetBlendFunc(dstAlphaFactor) == GL_INVALID_ENUM ||\n        GetBlendEquation(alphaOperation) == GL_INVALID_ENUM) {\n        return SDL_FALSE;\n    }\n    if ((srcColorFactor != srcAlphaFactor || dstColorFactor != dstAlphaFactor) && !data->GL_OES_blend_func_separate_supported) {\n        return SDL_FALSE;\n    }\n    if (colorOperation != alphaOperation && !data->GL_OES_blend_equation_separate_supported) {\n        return SDL_FALSE;\n    }\n    if (colorOperation != SDL_BLENDOPERATION_ADD && !data->GL_OES_blend_subtract_supported) {\n        return SDL_FALSE;\n    }\n    return SDL_TRUE;\n}\n\nstatic int\nGLES_CreateTexture(SDL_Renderer * renderer, SDL_Texture * texture)\n{\n    GLES_RenderData *renderdata = (GLES_RenderData *) renderer->driverdata;\n    GLES_TextureData *data;\n    GLint internalFormat;\n    GLenum format, type;\n    int texture_w, texture_h;\n    GLenum scaleMode;\n    GLenum result;\n\n    GLES_ActivateRenderer(renderer);\n\n    switch (texture->format) {\n    case SDL_PIXELFORMAT_ABGR8888:\n        internalFormat = GL_RGBA;\n        format = GL_RGBA;\n        type = GL_UNSIGNED_BYTE;\n        break;\n    default:\n        return SDL_SetError(\"Texture format not supported\");\n    }\n\n    data = (GLES_TextureData *) SDL_calloc(1, sizeof(*data));\n    if (!data) {\n        return SDL_OutOfMemory();\n    }\n\n    if (texture->access == SDL_TEXTUREACCESS_STREAMING) {\n        data->pitch = texture->w * SDL_BYTESPERPIXEL(texture->format);\n        data->pixels = SDL_calloc(1, texture->h * data->pitch);\n        if (!data->pixels) {\n            SDL_free(data);\n            return SDL_OutOfMemory();\n        }\n    }\n\n\n    if (texture->access == SDL_TEXTUREACCESS_TARGET) {\n        if (!renderdata->GL_OES_framebuffer_object_supported) {\n            SDL_free(data);\n            return SDL_SetError(\"GL_OES_framebuffer_object not supported\");\n        }\n        data->fbo = GLES_GetFBO(renderer->driverdata, texture->w, texture->h);\n    } else {\n        data->fbo = NULL;\n    }\n\n\n    renderdata->glGetError();\n    renderdata->glEnable(GL_TEXTURE_2D);\n    renderdata->glGenTextures(1, &data->texture);\n    result = renderdata->glGetError();\n    if (result != GL_NO_ERROR) {\n        if (texture->access == SDL_TEXTUREACCESS_STREAMING) {\n            SDL_free(data->pixels);\n        }\n        SDL_free(data);\n        return GLES_SetError(\"glGenTextures()\", result);\n    }\n\n    data->type = GL_TEXTURE_2D;\n    /* no NPOV textures allowed in OpenGL ES (yet) */\n    texture_w = SDL_powerof2(texture->w);\n    texture_h = SDL_powerof2(texture->h);\n    data->texw = (GLfloat) texture->w / texture_w;\n    data->texh = (GLfloat) texture->h / texture_h;\n\n    data->format = format;\n    data->formattype = type;\n    scaleMode = (texture->scaleMode == SDL_ScaleModeNearest) ? GL_NEAREST : GL_LINEAR;\n    renderdata->glBindTexture(data->type, data->texture);\n    renderdata->glTexParameteri(data->type, GL_TEXTURE_MIN_FILTER, scaleMode);\n    renderdata->glTexParameteri(data->type, GL_TEXTURE_MAG_FILTER, scaleMode);\n    renderdata->glTexParameteri(data->type, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n    renderdata->glTexParameteri(data->type, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n\n    renderdata->glTexImage2D(data->type, 0, internalFormat, texture_w,\n                             texture_h, 0, format, type, NULL);\n    renderdata->glDisable(GL_TEXTURE_2D);\n    renderdata->drawstate.texture = texture;\n    renderdata->drawstate.texturing = SDL_FALSE;\n\n    result = renderdata->glGetError();\n    if (result != GL_NO_ERROR) {\n        if (texture->access == SDL_TEXTUREACCESS_STREAMING) {\n            SDL_free(data->pixels);\n        }\n        SDL_free(data);\n        return GLES_SetError(\"glTexImage2D()\", result);\n    }\n\n    texture->driverdata = data;\n    return 0;\n}\n\nstatic int\nGLES_UpdateTexture(SDL_Renderer * renderer, SDL_Texture * texture,\n                   const SDL_Rect * rect, const void *pixels, int pitch)\n{\n    GLES_RenderData *renderdata = (GLES_RenderData *) renderer->driverdata;\n    GLES_TextureData *data = (GLES_TextureData *) texture->driverdata;\n    Uint8 *blob = NULL;\n    Uint8 *src;\n    int srcPitch;\n    int y;\n\n    GLES_ActivateRenderer(renderer);\n\n    /* Bail out if we're supposed to update an empty rectangle */\n    if (rect->w <= 0 || rect->h <= 0) {\n        return 0;\n    }\n\n    /* Reformat the texture data into a tightly packed array */\n    srcPitch = rect->w * SDL_BYTESPERPIXEL(texture->format);\n    src = (Uint8 *)pixels;\n    if (pitch != srcPitch) {\n        blob = (Uint8 *)SDL_malloc(srcPitch * rect->h);\n        if (!blob) {\n            return SDL_OutOfMemory();\n        }\n        src = blob;\n        for (y = 0; y < rect->h; ++y) {\n            SDL_memcpy(src, pixels, srcPitch);\n            src += srcPitch;\n            pixels = (Uint8 *)pixels + pitch;\n        }\n        src = blob;\n    }\n\n    /* Create a texture subimage with the supplied data */\n    renderdata->glGetError();\n    renderdata->glEnable(data->type);\n    renderdata->glBindTexture(data->type, data->texture);\n    renderdata->glPixelStorei(GL_UNPACK_ALIGNMENT, 1);\n    renderdata->glTexSubImage2D(data->type,\n                    0,\n                    rect->x,\n                    rect->y,\n                    rect->w,\n                    rect->h,\n                    data->format,\n                    data->formattype,\n                    src);\n    renderdata->glDisable(data->type);\n    SDL_free(blob);\n\n    renderdata->drawstate.texture = texture;\n    renderdata->drawstate.texturing = SDL_FALSE;\n\n    if (renderdata->glGetError() != GL_NO_ERROR) {\n        return SDL_SetError(\"Failed to update texture\");\n    }\n    return 0;\n}\n\nstatic int\nGLES_LockTexture(SDL_Renderer * renderer, SDL_Texture * texture,\n                 const SDL_Rect * rect, void **pixels, int *pitch)\n{\n    GLES_TextureData *data = (GLES_TextureData *) texture->driverdata;\n\n    *pixels =\n        (void *) ((Uint8 *) data->pixels + rect->y * data->pitch +\n                  rect->x * SDL_BYTESPERPIXEL(texture->format));\n    *pitch = data->pitch;\n    return 0;\n}\n\nstatic void\nGLES_UnlockTexture(SDL_Renderer * renderer, SDL_Texture * texture)\n{\n    GLES_TextureData *data = (GLES_TextureData *) texture->driverdata;\n    SDL_Rect rect;\n\n    /* We do whole texture updates, at least for now */\n    rect.x = 0;\n    rect.y = 0;\n    rect.w = texture->w;\n    rect.h = texture->h;\n    GLES_UpdateTexture(renderer, texture, &rect, data->pixels, data->pitch);\n}\n\nstatic void\nGLES_SetTextureScaleMode(SDL_Renderer * renderer, SDL_Texture * texture, SDL_ScaleMode scaleMode)\n{\n    GLES_RenderData *renderdata = (GLES_RenderData *) renderer->driverdata;\n    GLES_TextureData *data = (GLES_TextureData *) texture->driverdata;\n    GLenum glScaleMode = (scaleMode == SDL_ScaleModeNearest) ? GL_NEAREST : GL_LINEAR;\n\n    renderdata->glBindTexture(data->type, data->texture);\n    renderdata->glTexParameteri(data->type, GL_TEXTURE_MIN_FILTER, glScaleMode);\n    renderdata->glTexParameteri(data->type, GL_TEXTURE_MAG_FILTER, glScaleMode);\n}\n\nstatic int\nGLES_SetRenderTarget(SDL_Renderer * renderer, SDL_Texture * texture)\n{\n    GLES_RenderData *data = (GLES_RenderData *) renderer->driverdata;\n    GLES_TextureData *texturedata = NULL;\n    GLenum status;\n\n    if (!data->GL_OES_framebuffer_object_supported) {\n        return SDL_SetError(\"Can't enable render target support in this renderer\");\n    }\n\n    data->drawstate.viewport_dirty = SDL_TRUE;\n\n    if (texture == NULL) {\n        data->glBindFramebufferOES(GL_FRAMEBUFFER_OES, data->window_framebuffer);\n        return 0;\n    }\n\n    texturedata = (GLES_TextureData *) texture->driverdata;\n    data->glBindFramebufferOES(GL_FRAMEBUFFER_OES, texturedata->fbo->FBO);\n    /* TODO: check if texture pixel format allows this operation */\n    data->glFramebufferTexture2DOES(GL_FRAMEBUFFER_OES, GL_COLOR_ATTACHMENT0_OES, texturedata->type, texturedata->texture, 0);\n    /* Check FBO status */\n    status = data->glCheckFramebufferStatusOES(GL_FRAMEBUFFER_OES);\n    if (status != GL_FRAMEBUFFER_COMPLETE_OES) {\n        return SDL_SetError(\"glFramebufferTexture2DOES() failed\");\n    }\n    return 0;\n}\n\n\nstatic int\nGLES_QueueSetViewport(SDL_Renderer * renderer, SDL_RenderCommand *cmd)\n{\n    return 0;  /* nothing to do in this backend. */\n}\n\nstatic int\nGLES_QueueDrawPoints(SDL_Renderer * renderer, SDL_RenderCommand *cmd, const SDL_FPoint * points, int count)\n{\n    GLfloat *verts = (GLfloat *) SDL_AllocateRenderVertices(renderer, count * 2 * sizeof (GLfloat), 0, &cmd->data.draw.first);\n    int i;\n\n    if (!verts) {\n        return -1;\n    }\n\n    cmd->data.draw.count = count;\n    for (i = 0; i < count; i++) {\n        *(verts++) = 0.5f + points[i].x;\n        *(verts++) = 0.5f + points[i].y;\n    }\n\n    return 0;\n}\n\nstatic int\nGLES_QueueDrawLines(SDL_Renderer * renderer, SDL_RenderCommand *cmd, const SDL_FPoint * points, int count)\n{\n    int i;\n    GLfloat prevx, prevy;\n    const size_t vertlen = (sizeof (GLfloat) * 2) * count;\n    GLfloat *verts = (GLfloat *) SDL_AllocateRenderVertices(renderer, vertlen, 0, &cmd->data.draw.first);\n\n    if (!verts) {\n        return -1;\n    }\n    cmd->data.draw.count = count;\n\n    /* 0.5f offset to hit the center of the pixel. */\n    prevx = 0.5f + points->x;\n    prevy = 0.5f + points->y;\n    *(verts++) = prevx;\n    *(verts++) = prevy;\n\n    /* bump the end of each line segment out a quarter of a pixel, to provoke\n       the diamond-exit rule. Without this, you won't just drop the last\n       pixel of the last line segment, but you might also drop pixels at the\n       edge of any given line segment along the way too. */\n    for (i = 1; i < count; i++) {\n        const GLfloat xstart = prevx;\n        const GLfloat ystart = prevy;\n        const GLfloat xend = points[i].x + 0.5f;  /* 0.5f to hit pixel center. */\n        const GLfloat yend = points[i].y + 0.5f;\n        /* bump a little in the direction we are moving in. */\n        const GLfloat deltax = xend - xstart;\n        const GLfloat deltay = yend - ystart;\n        const GLfloat angle = SDL_atan2f(deltay, deltax);\n        prevx = xend + (SDL_cosf(angle) * 0.25f);\n        prevy = yend + (SDL_sinf(angle) * 0.25f);\n        *(verts++) = prevx;\n        *(verts++) = prevy;\n    }\n\n    return 0;\n}\n\nstatic int\nGLES_QueueGeometry(SDL_Renderer *renderer, SDL_RenderCommand *cmd, SDL_Texture *texture,\n        const float *xy, int xy_stride, const SDL_Color *color, int color_stride, const float *uv, int uv_stride,\n        int num_vertices, const void *indices, int num_indices, int size_indices,\n        float scale_x, float scale_y)\n{\n    GLES_TextureData *texturedata = NULL;\n    int i;\n    int count = indices ? num_indices : num_vertices;\n    GLfloat *verts;\n    int sz = 2 + 4 + (texture ? 2 : 0);\n\n    verts = (GLfloat *) SDL_AllocateRenderVertices(renderer, count * sz * sizeof (GLfloat), 0, &cmd->data.draw.first);\n    if (!verts) {\n        return -1;\n    }\n\n    if (texture) {\n        texturedata = (GLES_TextureData *) texture->driverdata;\n    }\n\n    cmd->data.draw.count = count;\n    size_indices = indices ? size_indices : 0;\n\n    for (i = 0; i < count; i++) {\n        int j;\n        float *xy_;\n        SDL_Color col_;\n        if (size_indices == 4) {\n            j = ((const Uint32 *)indices)[i];\n        } else if (size_indices == 2) {\n            j = ((const Uint16 *)indices)[i];\n        } else if (size_indices == 1) {\n            j = ((const Uint8 *)indices)[i];\n        } else {\n            j = i;\n        }\n\n        xy_ = (float *)((char*)xy + j * xy_stride);\n        col_ = *(SDL_Color *)((char*)color + j * color_stride);\n\n        *(verts++) = xy_[0] * scale_x;\n        *(verts++) = xy_[1] * scale_y;\n\n        *(verts++) = col_.r * inv255f;\n        *(verts++) = col_.g * inv255f;\n        *(verts++) = col_.b * inv255f;\n        *(verts++) = col_.a * inv255f;\n\n        if (texture) {\n            float *uv_ = (float *)((char*)uv + j * uv_stride);\n            *(verts++) = uv_[0] * texturedata->texw;\n            *(verts++) = uv_[1] * texturedata->texh;\n        }\n    }\n    return 0;\n}\n\nstatic void\nSetDrawState(GLES_RenderData *data, const SDL_RenderCommand *cmd)\n{\n    const SDL_BlendMode blend = cmd->data.draw.blend;\n    const Uint8 r = cmd->data.draw.r;\n    const Uint8 g = cmd->data.draw.g;\n    const Uint8 b = cmd->data.draw.b;\n    const Uint8 a = cmd->data.draw.a;\n    const Uint32 color = (((Uint32)a << 24) | (r << 16) | (g << 8) | b);\n\n    if (color != data->drawstate.color) {\n        const GLfloat fr = ((GLfloat) r) * inv255f;\n        const GLfloat fg = ((GLfloat) g) * inv255f;\n        const GLfloat fb = ((GLfloat) b) * inv255f;\n        const GLfloat fa = ((GLfloat) a) * inv255f;\n        data->glColor4f(fr, fg, fb, fa);\n        data->drawstate.color = color;\n    }\n\n    if (data->drawstate.viewport_dirty) {\n        const SDL_Rect *viewport = &data->drawstate.viewport;\n        const SDL_bool istarget = (data->drawstate.target != NULL);\n        data->glMatrixMode(GL_PROJECTION);\n        data->glLoadIdentity();\n        data->glViewport(viewport->x,\n                         istarget ? viewport->y : (data->drawstate.drawableh - viewport->y - viewport->h),\n                         viewport->w, viewport->h);\n        if (viewport->w && viewport->h) {\n            data->glOrthof((GLfloat) 0, (GLfloat) viewport->w,\n                           (GLfloat) (istarget ? 0 : viewport->h),\n                           (GLfloat) (istarget ? viewport->h : 0),\n                           0.0, 1.0);\n        }\n        data->glMatrixMode(GL_MODELVIEW);\n        data->drawstate.viewport_dirty = SDL_FALSE;\n    }\n\n    if (data->drawstate.cliprect_enabled_dirty) {\n        if (data->drawstate.cliprect_enabled) {\n            data->glEnable(GL_SCISSOR_TEST);\n        } else {\n            data->glDisable(GL_SCISSOR_TEST);\n        }\n        data->drawstate.cliprect_enabled_dirty = SDL_FALSE;\n    }\n\n    if (data->drawstate.cliprect_enabled && data->drawstate.cliprect_dirty) {\n        const SDL_Rect *viewport = &data->drawstate.viewport;\n        const SDL_Rect *rect = &data->drawstate.cliprect;\n        const SDL_bool istarget = (data->drawstate.target != NULL);\n        data->glScissor(viewport->x + rect->x,\n                        istarget ? viewport->y + rect->y : data->drawstate.drawableh - viewport->y - rect->y - rect->h,\n                        rect->w, rect->h);\n        data->drawstate.cliprect_dirty = SDL_FALSE;\n    }\n\n    if (blend != data->drawstate.blend) {\n        if (blend == SDL_BLENDMODE_NONE) {\n            data->glDisable(GL_BLEND);\n        } else {\n            data->glEnable(GL_BLEND);\n            if (data->GL_OES_blend_func_separate_supported) {\n                data->glBlendFuncSeparateOES(GetBlendFunc(SDL_GetBlendModeSrcColorFactor(blend)),\n                                             GetBlendFunc(SDL_GetBlendModeDstColorFactor(blend)),\n                                             GetBlendFunc(SDL_GetBlendModeSrcAlphaFactor(blend)),\n                                             GetBlendFunc(SDL_GetBlendModeDstAlphaFactor(blend)));\n            } else {\n                data->glBlendFunc(GetBlendFunc(SDL_GetBlendModeSrcColorFactor(blend)),\n                                  GetBlendFunc(SDL_GetBlendModeDstColorFactor(blend)));\n            }\n            if (data->GL_OES_blend_equation_separate_supported) {\n                data->glBlendEquationSeparateOES(GetBlendEquation(SDL_GetBlendModeColorOperation(blend)),\n                                                 GetBlendEquation(SDL_GetBlendModeAlphaOperation(blend)));\n            } else if (data->GL_OES_blend_subtract_supported) {\n                data->glBlendEquationOES(GetBlendEquation(SDL_GetBlendModeColorOperation(blend)));\n            }\n        }\n        data->drawstate.blend = blend;\n    }\n\n    if ((cmd->data.draw.texture != NULL) != data->drawstate.texturing) {\n        if (cmd->data.draw.texture == NULL) {\n            data->glDisable(GL_TEXTURE_2D);\n            data->glDisableClientState(GL_TEXTURE_COORD_ARRAY);\n            data->drawstate.texturing = SDL_FALSE;\n        } else {\n            data->glEnable(GL_TEXTURE_2D);\n            data->glEnableClientState(GL_TEXTURE_COORD_ARRAY);\n            data->drawstate.texturing = SDL_TRUE;\n        }\n    }\n}\n\nstatic void\nSetCopyState(GLES_RenderData *data, const SDL_RenderCommand *cmd)\n{\n    SDL_Texture *texture = cmd->data.draw.texture;\n    SetDrawState(data, cmd);\n\n    if (texture != data->drawstate.texture) {\n        GLES_TextureData *texturedata = (GLES_TextureData *) texture->driverdata;\n        data->glBindTexture(GL_TEXTURE_2D, texturedata->texture);\n        data->drawstate.texture = texture;\n    }\n}\n\nstatic int\nGLES_RunCommandQueue(SDL_Renderer * renderer, SDL_RenderCommand *cmd, void *vertices, size_t vertsize)\n{\n    GLES_RenderData *data = (GLES_RenderData *) renderer->driverdata;\n\n    if (GLES_ActivateRenderer(renderer) < 0) {\n        return -1;\n    }\n\n    data->drawstate.target = renderer->target;\n\n    if (!renderer->target) {\n        int w, h;\n        SDL_GL_GetDrawableSize(renderer->window, &w, &h);\n        if ((w != data->drawstate.drawablew) || (h != data->drawstate.drawableh)) {\n            data->drawstate.viewport_dirty = SDL_TRUE;  // if the window dimensions changed, invalidate the current viewport, etc.\n            data->drawstate.cliprect_dirty = SDL_TRUE;\n            data->drawstate.drawablew = w;\n            data->drawstate.drawableh = h;\n        }\n\n    }\n\n    while (cmd) {\n        switch (cmd->command) {\n            case SDL_RENDERCMD_SETDRAWCOLOR: {\n                break;  /* not used in this render backend. */\n            }\n\n            case SDL_RENDERCMD_SETVIEWPORT: {\n                SDL_Rect *viewport = &data->drawstate.viewport;\n                if (SDL_memcmp(viewport, &cmd->data.viewport.rect, sizeof(cmd->data.viewport.rect)) != 0) {\n                    SDL_copyp(viewport, &cmd->data.viewport.rect);\n                    data->drawstate.viewport_dirty = SDL_TRUE;\n                }\n                break;\n            }\n\n            case SDL_RENDERCMD_SETCLIPRECT: {\n                const SDL_Rect *rect = &cmd->data.cliprect.rect;\n                if (data->drawstate.cliprect_enabled != cmd->data.cliprect.enabled) {\n                    data->drawstate.cliprect_enabled = cmd->data.cliprect.enabled;\n                    data->drawstate.cliprect_enabled_dirty = SDL_TRUE;\n                }\n                if (SDL_memcmp(&data->drawstate.cliprect, rect, sizeof(*rect)) != 0) {\n                    SDL_copyp(&data->drawstate.cliprect, rect);\n                    data->drawstate.cliprect_dirty = SDL_TRUE;\n                }\n                break;\n            }\n\n            case SDL_RENDERCMD_CLEAR: {\n                const Uint8 r = cmd->data.color.r;\n                const Uint8 g = cmd->data.color.g;\n                const Uint8 b = cmd->data.color.b;\n                const Uint8 a = cmd->data.color.a;\n                const Uint32 color = (((Uint32)a << 24) | (r << 16) | (g << 8) | b);\n                if (color != data->drawstate.clear_color) {\n                    const GLfloat fr = ((GLfloat) r) * inv255f;\n                    const GLfloat fg = ((GLfloat) g) * inv255f;\n                    const GLfloat fb = ((GLfloat) b) * inv255f;\n                    const GLfloat fa = ((GLfloat) a) * inv255f;\n                    data->glClearColor(fr, fg, fb, fa);\n                    data->drawstate.clear_color = color;\n                }\n\n                if (data->drawstate.cliprect_enabled || data->drawstate.cliprect_enabled_dirty) {\n                    data->glDisable(GL_SCISSOR_TEST);\n                    data->drawstate.cliprect_enabled_dirty = data->drawstate.cliprect_enabled;\n                }\n\n                data->glClear(GL_COLOR_BUFFER_BIT);\n\n                break;\n            }\n\n            case SDL_RENDERCMD_DRAW_POINTS: {\n                const size_t count = cmd->data.draw.count;\n                const GLfloat *verts = (GLfloat *) (((Uint8 *) vertices) + cmd->data.draw.first);\n                SetDrawState(data, cmd);\n                data->glVertexPointer(2, GL_FLOAT, 0, verts);\n                data->glDrawArrays(GL_POINTS, 0, (GLsizei) count);\n                break;\n            }\n\n            case SDL_RENDERCMD_DRAW_LINES: {\n                const GLfloat *verts = (GLfloat *) (((Uint8 *) vertices) + cmd->data.draw.first);\n                const size_t count = cmd->data.draw.count;\n                SDL_assert(count >= 2);\n                SetDrawState(data, cmd);\n                data->glVertexPointer(2, GL_FLOAT, 0, verts);\n                data->glDrawArrays(GL_LINE_STRIP, 0, (GLsizei) count);\n                break;\n            }\n\n            case SDL_RENDERCMD_FILL_RECTS: /* unused */\n                break;\n\n            case SDL_RENDERCMD_COPY: /* unused */\n                break;\n\n            case SDL_RENDERCMD_COPY_EX: /* unused */\n                break;\n\n            case SDL_RENDERCMD_GEOMETRY: {\n                const GLfloat *verts = (GLfloat *) (((Uint8 *) vertices) + cmd->data.draw.first);\n                SDL_Texture *texture = cmd->data.draw.texture;\n                const size_t count = cmd->data.draw.count;\n                int stride = (2 + 4 + (texture ? 2 : 0)) * sizeof (float);\n\n                if (texture) {\n                    SetCopyState(data, cmd);\n                } else {\n                    SetDrawState(data, cmd);\n                }\n\n                data->glEnableClientState(GL_COLOR_ARRAY);\n\n                data->glVertexPointer(2, GL_FLOAT, stride, verts);\n                data->glColorPointer(4, GL_FLOAT, stride, verts + 2);\n                if (texture) {\n                    data->glTexCoordPointer(2, GL_FLOAT, stride, verts + 2 + 4);\n                }\n\n                data->glDrawArrays(GL_TRIANGLES, 0, (GLsizei) count);\n\n                data->glDisableClientState(GL_COLOR_ARRAY);\n                break;\n            }\n\n            case SDL_RENDERCMD_NO_OP:\n                break;\n        }\n\n        cmd = cmd->next;\n    }\n\n    return 0;\n}\n\nstatic int\nGLES_RenderReadPixels(SDL_Renderer * renderer, const SDL_Rect * rect,\n                      Uint32 pixel_format, void * pixels, int pitch)\n{\n    GLES_RenderData *data = (GLES_RenderData *) renderer->driverdata;\n    Uint32 temp_format = renderer->target ? renderer->target->format : SDL_PIXELFORMAT_ABGR8888;\n    void *temp_pixels;\n    int temp_pitch;\n    Uint8 *src, *dst, *tmp;\n    int w, h, length, rows;\n    int status;\n\n    GLES_ActivateRenderer(renderer);\n\n    temp_pitch = rect->w * SDL_BYTESPERPIXEL(temp_format);\n    temp_pixels = SDL_malloc(rect->h * temp_pitch);\n    if (!temp_pixels) {\n        return SDL_OutOfMemory();\n    }\n\n    SDL_GetRendererOutputSize(renderer, &w, &h);\n\n    data->glPixelStorei(GL_PACK_ALIGNMENT, 1);\n\n    data->glReadPixels(rect->x, renderer->target ? rect->y : (h-rect->y)-rect->h,\n                       rect->w, rect->h, GL_RGBA, GL_UNSIGNED_BYTE, temp_pixels);\n\n    /* Flip the rows to be top-down if necessary */\n    if (!renderer->target) {\n        SDL_bool isstack;\n        length = rect->w * SDL_BYTESPERPIXEL(temp_format);\n        src = (Uint8*)temp_pixels + (rect->h-1)*temp_pitch;\n        dst = (Uint8*)temp_pixels;\n        tmp = SDL_small_alloc(Uint8, length, &isstack);\n        rows = rect->h / 2;\n        while (rows--) {\n            SDL_memcpy(tmp, dst, length);\n            SDL_memcpy(dst, src, length);\n            SDL_memcpy(src, tmp, length);\n            dst += temp_pitch;\n            src -= temp_pitch;\n        }\n        SDL_small_free(tmp, isstack);\n    }\n\n    status = SDL_ConvertPixels(rect->w, rect->h,\n                               temp_format, temp_pixels, temp_pitch,\n                               pixel_format, pixels, pitch);\n    SDL_free(temp_pixels);\n\n    return status;\n}\n\nstatic int\nGLES_RenderPresent(SDL_Renderer * renderer)\n{\n    GLES_ActivateRenderer(renderer);\n\n    return SDL_GL_SwapWindowWithResult(renderer->window);\n}\n\nstatic void\nGLES_DestroyTexture(SDL_Renderer * renderer, SDL_Texture * texture)\n{\n    GLES_RenderData *renderdata = (GLES_RenderData *) renderer->driverdata;\n\n    GLES_TextureData *data = (GLES_TextureData *) texture->driverdata;\n\n    GLES_ActivateRenderer(renderer);\n\n    if (renderdata->drawstate.texture == texture) {\n        renderdata->drawstate.texture = NULL;\n    }\n    if (renderdata->drawstate.target == texture) {\n        renderdata->drawstate.target = NULL;\n    }\n\n    if (!data) {\n        return;\n    }\n    if (data->texture) {\n        renderdata->glDeleteTextures(1, &data->texture);\n    }\n    SDL_free(data->pixels);\n    SDL_free(data);\n    texture->driverdata = NULL;\n}\n\nstatic void\nGLES_DestroyRenderer(SDL_Renderer * renderer)\n{\n    GLES_RenderData *data = (GLES_RenderData *) renderer->driverdata;\n\n    if (data) {\n        if (data->context) {\n            while (data->framebuffers) {\n               GLES_FBOList *nextnode = data->framebuffers->next;\n               data->glDeleteFramebuffersOES(1, &data->framebuffers->FBO);\n               SDL_free(data->framebuffers);\n               data->framebuffers = nextnode;\n            }\n            SDL_GL_DeleteContext(data->context);\n        }\n        SDL_free(data);\n    }\n    SDL_free(renderer);\n}\n\nstatic int GLES_BindTexture (SDL_Renderer * renderer, SDL_Texture *texture, float *texw, float *texh)\n{\n    GLES_RenderData *data = (GLES_RenderData *) renderer->driverdata;\n    GLES_TextureData *texturedata = (GLES_TextureData *) texture->driverdata;\n    GLES_ActivateRenderer(renderer);\n\n    data->glEnable(GL_TEXTURE_2D);\n    data->glBindTexture(texturedata->type, texturedata->texture);\n\n    data->drawstate.texture = texture;\n    data->drawstate.texturing = SDL_TRUE;\n\n    if (texw) {\n        *texw = (float)texturedata->texw;\n    }\n    if (texh) {\n        *texh = (float)texturedata->texh;\n    }\n\n    return 0;\n}\n\nstatic int GLES_UnbindTexture (SDL_Renderer * renderer, SDL_Texture *texture)\n{\n    GLES_RenderData *data = (GLES_RenderData *) renderer->driverdata;\n    GLES_TextureData *texturedata = (GLES_TextureData *) texture->driverdata;\n    GLES_ActivateRenderer(renderer);\n    data->glDisable(texturedata->type);\n\n    data->drawstate.texture = NULL;\n    data->drawstate.texturing = SDL_FALSE;\n\n    return 0;\n}\n\nstatic int\nGLES_SetVSync(SDL_Renderer * renderer, const int vsync)\n{\n    int retval;\n    if (vsync) {\n        retval = SDL_GL_SetSwapInterval(1);\n    } else {\n        retval = SDL_GL_SetSwapInterval(0);\n    }\n    if (retval != 0) {\n        return retval;\n    }\n    if (SDL_GL_GetSwapInterval() > 0) {\n        renderer->info.flags |= SDL_RENDERER_PRESENTVSYNC;\n    } else {\n        renderer->info.flags &= ~SDL_RENDERER_PRESENTVSYNC;\n    }\n    return retval;\n}\n\n\nstatic SDL_Renderer *\nGLES_CreateRenderer(SDL_Window * window, Uint32 flags)\n{\n    SDL_Renderer *renderer;\n    GLES_RenderData *data;\n    GLint value;\n    Uint32 window_flags;\n    int profile_mask = 0, major = 0, minor = 0;\n    SDL_bool changed_window = SDL_FALSE;\n\n    SDL_GL_GetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, &profile_mask);\n    SDL_GL_GetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, &major);\n    SDL_GL_GetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, &minor);\n\n    window_flags = SDL_GetWindowFlags(window);\n    if (!(window_flags & SDL_WINDOW_OPENGL) ||\n        profile_mask != SDL_GL_CONTEXT_PROFILE_ES || major != RENDERER_CONTEXT_MAJOR || minor != RENDERER_CONTEXT_MINOR) {\n\n        changed_window = SDL_TRUE;\n        SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_ES);\n        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, RENDERER_CONTEXT_MAJOR);\n        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, RENDERER_CONTEXT_MINOR);\n\n        if (SDL_RecreateWindow(window, (window_flags & ~(SDL_WINDOW_VULKAN | SDL_WINDOW_METAL)) | SDL_WINDOW_OPENGL) < 0) {\n            goto error;\n        }\n    }\n\n    renderer = (SDL_Renderer *) SDL_calloc(1, sizeof(*renderer));\n    if (!renderer) {\n        SDL_OutOfMemory();\n        goto error;\n    }\n\n    data = (GLES_RenderData *) SDL_calloc(1, sizeof(*data));\n    if (!data) {\n        GLES_DestroyRenderer(renderer);\n        SDL_OutOfMemory();\n        goto error;\n    }\n\n    renderer->WindowEvent = GLES_WindowEvent;\n    renderer->GetOutputSize = GLES_GetOutputSize;\n    renderer->SupportsBlendMode = GLES_SupportsBlendMode;\n    renderer->CreateTexture = GLES_CreateTexture;\n    renderer->UpdateTexture = GLES_UpdateTexture;\n    renderer->LockTexture = GLES_LockTexture;\n    renderer->UnlockTexture = GLES_UnlockTexture;\n    renderer->SetTextureScaleMode = GLES_SetTextureScaleMode;\n    renderer->SetRenderTarget = GLES_SetRenderTarget;\n    renderer->QueueSetViewport = GLES_QueueSetViewport;\n    renderer->QueueSetDrawColor = GLES_QueueSetViewport;  /* SetViewport and SetDrawColor are (currently) no-ops. */\n    renderer->QueueDrawPoints = GLES_QueueDrawPoints;\n    renderer->QueueDrawLines = GLES_QueueDrawLines;\n    renderer->QueueGeometry = GLES_QueueGeometry;\n    renderer->RunCommandQueue = GLES_RunCommandQueue;\n    renderer->RenderReadPixels = GLES_RenderReadPixels;\n    renderer->RenderPresent = GLES_RenderPresent;\n    renderer->DestroyTexture = GLES_DestroyTexture;\n    renderer->DestroyRenderer = GLES_DestroyRenderer;\n    renderer->SetVSync = GLES_SetVSync;\n    renderer->GL_BindTexture = GLES_BindTexture;\n    renderer->GL_UnbindTexture = GLES_UnbindTexture;\n    renderer->info = GLES_RenderDriver.info;\n    renderer->info.flags = SDL_RENDERER_ACCELERATED;\n    renderer->driverdata = data;\n    renderer->window = window;\n\n    data->context = SDL_GL_CreateContext(window);\n    if (!data->context) {\n        GLES_DestroyRenderer(renderer);\n        goto error;\n    }\n    if (SDL_GL_MakeCurrent(window, data->context) < 0) {\n        GLES_DestroyRenderer(renderer);\n        goto error;\n    }\n\n    if (GLES_LoadFunctions(data) < 0) {\n        GLES_DestroyRenderer(renderer);\n        goto error;\n    }\n\n    if (flags & SDL_RENDERER_PRESENTVSYNC) {\n        SDL_GL_SetSwapInterval(1);\n    } else {\n        SDL_GL_SetSwapInterval(0);\n    }\n    if (SDL_GL_GetSwapInterval() > 0) {\n        renderer->info.flags |= SDL_RENDERER_PRESENTVSYNC;\n    }\n\n    value = 0;\n    data->glGetIntegerv(GL_MAX_TEXTURE_SIZE, &value);\n    renderer->info.max_texture_width = value;\n    value = 0;\n    data->glGetIntegerv(GL_MAX_TEXTURE_SIZE, &value);\n    renderer->info.max_texture_height = value;\n\n    /* Android does not report GL_OES_framebuffer_object but the functionality seems to be there anyway */\n    if (SDL_GL_ExtensionSupported(\"GL_OES_framebuffer_object\") || data->glGenFramebuffersOES) {\n        data->GL_OES_framebuffer_object_supported = SDL_TRUE;\n        renderer->info.flags |= SDL_RENDERER_TARGETTEXTURE;\n\n        value = 0;\n        data->glGetIntegerv(GL_FRAMEBUFFER_BINDING_OES, &value);\n        data->window_framebuffer = (GLuint)value;\n    }\n    data->framebuffers = NULL;\n\n    if (SDL_GL_ExtensionSupported(\"GL_OES_blend_func_separate\")) {\n        data->GL_OES_blend_func_separate_supported = SDL_TRUE;\n    }\n    if (SDL_GL_ExtensionSupported(\"GL_OES_blend_equation_separate\")) {\n        data->GL_OES_blend_equation_separate_supported = SDL_TRUE;\n    }\n    if (SDL_GL_ExtensionSupported(\"GL_OES_blend_subtract\")) {\n        data->GL_OES_blend_subtract_supported = SDL_TRUE;\n    }\n\n    /* Set up parameters for rendering */\n    data->glDisable(GL_DEPTH_TEST);\n    data->glDisable(GL_CULL_FACE);\n\n    data->glMatrixMode(GL_MODELVIEW);\n    data->glLoadIdentity();\n\n    data->glEnableClientState(GL_VERTEX_ARRAY);\n    data->glDisableClientState(GL_TEXTURE_COORD_ARRAY);\n\n    data->glClearColor(1.0f, 1.0f, 1.0f, 1.0f);\n\n    data->drawstate.blend = SDL_BLENDMODE_INVALID;\n    data->drawstate.color = 0xFFFFFFFF;\n    data->drawstate.clear_color = 0xFFFFFFFF;\n\n    return renderer;\n\nerror:\n    if (changed_window) {\n        /* Uh oh, better try to put it back... */\n        SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, profile_mask);\n        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, major);\n        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, minor);\n        SDL_RecreateWindow(window, window_flags);\n    }\n    return NULL;\n}\n\nSDL_RenderDriver GLES_RenderDriver = {\n    GLES_CreateRenderer,\n    {\n     \"opengles\",\n     (SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC),\n     1,\n     {SDL_PIXELFORMAT_ABGR8888},\n     0,\n     0\n    }\n};\n\n#endif /* SDL_VIDEO_RENDER_OGL_ES && !SDL_RENDER_DISABLED */\n\n/* vi: set ts=4 sw=4 expandtab: */\n"], "filenames": ["src/render/opengles/SDL_render_gles.c"], "buggy_code_start_loc": [361], "buggy_code_end_loc": [389], "fixing_code_start_loc": [362], "fixing_code_end_loc": [396], "type": "CWE-401", "message": "A potential memory leak issue was discovered in SDL2 in GLES_CreateTexture() function in SDL_render_gles.c. The vulnerability allows an attacker to cause a denial of service attack. The vulnerability affects SDL2 v2.0.4 and above. SDL-1.x are not affected.", "other": {"cve": {"id": "CVE-2022-4743", "sourceIdentifier": "secalert@redhat.com", "published": "2023-01-12T19:15:24.457", "lastModified": "2023-05-03T12:16:43.400", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A potential memory leak issue was discovered in SDL2 in GLES_CreateTexture() function in SDL_render_gles.c. The vulnerability allows an attacker to cause a denial of service attack. The vulnerability affects SDL2 v2.0.4 and above. SDL-1.x are not affected."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libsdl:simple_directmedia_layer:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.4", "versionEndExcluding": "2.26.0", "matchCriteriaId": "DC731AEE-6D02-42D4-9F58-468E2749FDE7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "7F6FB57C-2BC7-487C-96DD-132683AEB35D"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2022-4743", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2156290", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/libsdl-org/SDL/commit/00b67f55727bc0944c3266e2b875440da132ce4b", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/libsdl-org/SDL/pull/6269", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/02/msg00008.html", "source": "secalert@redhat.com"}, {"url": "https://security.gentoo.org/glsa/202305-18", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/libsdl-org/SDL/commit/00b67f55727bc0944c3266e2b875440da132ce4b"}}