{"buggy_code": ["# Copyright (c) 2008-2013 Michael Dvorkin and contributors.\n#\n# Fat Free CRM is freely distributable under the terms of MIT license.\n# See MIT-LICENSE file or http://www.opensource.org/licenses/mit-license.php\n#------------------------------------------------------------------------------\nclass HomeController < ApplicationController\n  before_filter :require_user, :except => [ :toggle, :timezone ]\n  before_filter :set_current_tab, :only => :index\n  before_filter \"hook(:home_before_filter, self, :amazing => true)\"\n\n  #----------------------------------------------------------------------------\n  def index\n    @hello = \"Hello world\" # The hook below can access controller's instance variables.\n    hook(:home_controller, self, :params => \"it works!\")\n\n    @activities = get_activities\n    @my_tasks = Task.visible_on_dashboard(current_user).by_due_at\n    @my_opportunities = Opportunity.visible_on_dashboard(current_user).by_closes_on.by_amount\n    @my_accounts = Account.visible_on_dashboard(current_user).by_name\n    respond_with(@activities)\n  end\n\n  # GET /home/options                                                      AJAX\n  #----------------------------------------------------------------------------\n  def options\n    unless params[:cancel].true?\n      @asset = current_user.pref[:activity_asset] || \"all\"\n      @action = current_user.pref[:activity_event] || \"all_events\"\n      @user = current_user.pref[:activity_user] || \"all_users\"\n      @duration = current_user.pref[:activity_duration] || \"two_days\"\n      @all_users = User.order(\"first_name, last_name\")\n    end\n  end\n\n  # POST /home/redraw                                                      AJAX\n  #----------------------------------------------------------------------------\n  def redraw\n    current_user.pref[:activity_asset] = params[:asset] if params[:asset]\n    current_user.pref[:activity_event] = params[:event] if params[:event]\n    current_user.pref[:activity_user] = params[:user] if params[:user]\n    current_user.pref[:activity_duration] = params[:duration] if params[:duration]\n\n    render :index\n  end\n\n  # GET /home/toggle                                                       AJAX\n  #----------------------------------------------------------------------------\n  def toggle\n    if session[params[:id].to_sym]\n      session.delete(params[:id].to_sym)\n    else\n      session[params[:id].to_sym] = true\n    end\n    render :nothing => true\n  end\n\n  # GET /home/timeline                                                     AJAX\n  #----------------------------------------------------------------------------\n  def timeline\n    unless params[:type].empty?\n      model = params[:type].camelize.constantize\n      item = model.find(params[:id])\n      item.update_attribute(:state, params[:state])\n    else\n      comments, emails = params[:id].split(\"+\")\n      Comment.update_all(\"state = '#{params[:state]}'\", \"id IN (#{comments})\") unless comments.blank?\n      Email.update_all(\"state = '#{params[:state]}'\", \"id IN (#{emails})\") unless emails.blank?\n    end\n\n    render :nothing => true\n  end\n\n  # GET /home/timezone                                                     AJAX\n  #----------------------------------------------------------------------------\n  def timezone\n    #\n    # (new Date()).getTimezoneOffset() in JavaScript returns (UTC - localtime) in\n    # minutes, while ActiveSupport::TimeZone expects (localtime - UTC) in seconds.\n    #\n    if params[:offset]\n      session[:timezone_offset] = params[:offset].to_i * -60\n      ActiveSupport::TimeZone[session[:timezone_offset]]\n    end\n    render :nothing => true\n  end\n\n  private\n  #----------------------------------------------------------------------------\n  def get_activities(options = {})\n    options[:asset]    ||= activity_asset\n    options[:event]    ||= activity_event\n    options[:user]     ||= activity_user\n    options[:duration] ||= activity_duration\n    options[:max]      ||= 500\n\n    Version.latest(options).visible_to(current_user)\n  end\n\n  #----------------------------------------------------------------------------\n  def activity_asset\n    asset = current_user.pref[:activity_asset]\n    if asset.nil? || asset == \"all\"\n      nil\n    else\n      asset.singularize.capitalize\n    end\n  end\n\n  #----------------------------------------------------------------------------\n  def activity_event\n    event = current_user.pref[:activity_event]\n    if event == \"all_events\"\n      %w(create update destroy)\n    else\n      event\n    end\n  end\n\n  #----------------------------------------------------------------------------\n  def activity_user\n    user = current_user.pref[:activity_user]\n    if user && user != \"all_users\"\n      user = if user =~ /@/ # email\n          User.where(:email => user).first\n        else # first_name middle_name last_name any_name\n          name_query = if user.include?(\" \")\n            user.name_permutations.map{ |first, last|\n              \"(upper(first_name) LIKE upper('%#{first}%') AND upper(last_name) LIKE upper('%#{last}%'))\"\n            }.join(\" OR \")\n          else\n            \"upper(first_name) LIKE upper('%#{user}%') OR upper(last_name) LIKE upper('%#{user}%')\"\n          end\n          User.where(name_query).first\n        end\n    end\n    user.is_a?(User) ? user.id : nil\n  end\n\n  #----------------------------------------------------------------------------\n  def activity_duration\n    duration = current_user.pref[:activity_duration]\n    if duration\n      words = duration.split(\"_\") # \"two_weeks\" => 2.weeks\n      if %w(one two).include?(words.first)\n        %w(zero one two).index(words.first).send(words.last)\n      end\n    end\n  end\n\nend\n", "# Copyright (c) 2008-2013 Michael Dvorkin and contributors.\n#\n# Fat Free CRM is freely distributable under the terms of MIT license.\n# See MIT-LICENSE file or http://www.opensource.org/licenses/mit-license.php\n#------------------------------------------------------------------------------\nrequire File.expand_path(File.dirname(__FILE__) + '/../spec_helper')\n\ndescribe HomeController do\n\n  # GET /\n  #----------------------------------------------------------------------------\n  describe \"responding to GET /\" do\n    before(:each) do\n      require_user\n    end\n\n    it \"should get a list of activities\" do\n      activity = FactoryGirl.create(:version, :item => FactoryGirl.create(:account, :user => current_user))\n      controller.should_receive(:get_activities).once.and_return([ activity ])\n      get :index\n      assigns[:activities].should == [ activity ]\n    end\n\n    it \"should not include views in the list of activities\" do\n      activity = FactoryGirl.create(:version, :item => FactoryGirl.create(:account, :user => @current_user), :event => \"view\")\n      controller.should_receive(:get_activities).once.and_return([])\n\n      get :index\n      assigns[:activities].should == []\n    end\n\n    it \"should get a list of my tasks ordered by due_at\" do\n      task_1 = FactoryGirl.create(:task, :name => \"Your first task\", :bucket => \"due_asap\", :assigned_to => current_user.id)\n      task_2 = FactoryGirl.create(:task, :name => \"Another task for you\", :bucket => \"specific_time\", :calendar => 5.days.from_now.to_s, :assigned_to => current_user.id)\n      task_3 = FactoryGirl.create(:task, :name => \"Third Task\", :bucket => \"due_next_week\", :assigned_to => current_user.id)\n      task_4 = FactoryGirl.create(:task, :name => \"i've assigned it to myself\", :user => current_user, :calendar => 20.days.from_now.to_s, :assigned_to => nil, :bucket => \"specific_time\")\n\n      FactoryGirl.create(:task, :name => \"Someone else's Task\", :user_id => current_user.id, :bucket => \"due_asap\", :assigned_to => FactoryGirl.create(:user).id)\n      FactoryGirl.create(:task, :name => \"Not my task\", :bucket => \"due_asap\", :assigned_to => FactoryGirl.create(:user).id)\n\n      get :index\n      assigns[:my_tasks].should == [task_1, task_2, task_3, task_4]\n    end\n\n\t\tit \"should not display completed tasks\" do\n\t\t\ttask_1 = FactoryGirl.create(:task, :user_id => current_user.id, :name => \"Your first task\", :bucket => \"due_asap\", :assigned_to => current_user.id)\n\t\t\ttask_2 = FactoryGirl.create(:task, :user_id => current_user.id, :name => \"Completed task\", :bucket => \"due_asap\", :completed_at => 1.days.ago, :completed_by => current_user.id, :assigned_to => current_user.id)\n\n\t\t\tget :index\n\t\t\tassigns[:my_tasks].should == [task_1]\n\t\tend\n\n    it \"should get a list of my opportunities ordered by closes_on\" do\n      opportunity_1 = FactoryGirl.create(:opportunity, :name => \"Your first opportunity\", :closes_on => 15.days.from_now, :assigned_to => current_user.id, :stage => 'proposal')\n      opportunity_2 = FactoryGirl.create(:opportunity, :name => \"Another opportunity for you\", :closes_on => 10.days.from_now, :assigned_to => current_user.id, :stage => 'proposal')\n      opportunity_3 = FactoryGirl.create(:opportunity, :name => \"Third Opportunity\", :closes_on => 5.days.from_now, :assigned_to => current_user.id, :stage => 'proposal')\n      opportunity_4 = FactoryGirl.create(:opportunity, :name => \"Fourth Opportunity\", :closes_on => 50.days.from_now, :assigned_to => nil, :user_id => current_user.id, :stage => 'proposal')\n\n      FactoryGirl.create(:opportunity_in_pipeline, :name => \"Someone else's Opportunity\", :assigned_to => FactoryGirl.create(:user).id, :stage => 'proposal')\n      FactoryGirl.create(:opportunity_in_pipeline, :name => \"Not my opportunity\", :assigned_to => FactoryGirl.create(:user).id, :stage => 'proposal')\n\n      get :index\n      assigns[:my_opportunities].should == [opportunity_3, opportunity_2, opportunity_1, opportunity_4]\n    end\n\n    it \"should get a list of my accounts ordered by name\" do\n      account_1 = FactoryGirl.create(:account, :name => \"Anderson\", :assigned_to => current_user.id)\n      account_2 = FactoryGirl.create(:account, :name => \"Wilson\", :assigned_to => current_user.id)\n      account_3 = FactoryGirl.create(:account, :name => \"Triple\", :assigned_to => current_user.id)\n      account_4 = FactoryGirl.create(:account, :name => \"Double\", :assigned_to => nil, :user_id => current_user.id)\n\n      FactoryGirl.create(:account, :name => \"Someone else's Account\", :assigned_to => FactoryGirl.create(:user).id)\n      FactoryGirl.create(:account, :name => \"Not my account\", :assigned_to => FactoryGirl.create(:user).id)\n\n      get :index\n      assigns[:my_accounts].should == [account_1, account_4, account_3, account_2]\n    end\n\n    it \"should assign @hello and call hook\" do\n      require_user\n      controller.should_receive(:hook).at_least(:once)\n\n      get :index\n      assigns[:hello].should == \"Hello world\"\n    end\n  end\n\n  # GET /home/options                                                      AJAX\n  #----------------------------------------------------------------------------\n  describe \"responding to GET options\" do\n    before(:each) do\n      require_user\n    end\n\n    it \"should assign instance variables for user preferences\" do\n      @asset = FactoryGirl.create(:preference, :user => current_user, :name => \"activity_asset\", :value => Base64.encode64(Marshal.dump(\"tasks\")))\n      @user = FactoryGirl.create(:preference, :user => current_user, :name => \"activity_user\", :value => Base64.encode64(Marshal.dump(\"Billy Bones\")))\n      @duration = FactoryGirl.create(:preference, :user => current_user, :name => \"activity_duration\", :value => Base64.encode64(Marshal.dump(\"two days\")))\n\n      xhr :get, :options\n      assigns[:asset].should == \"tasks\"\n      assigns[:user].should == \"Billy Bones\"\n      assigns[:duration].should == \"two days\"\n      assigns[:all_users].should == User.order(\"first_name, last_name\").all\n    end\n\n    it \"should not assign instance variables when hiding options\" do\n      xhr :get, :options, :cancel => \"true\"\n      assigns[:asset].should == nil\n      assigns[:user].should == nil\n      assigns[:duration].should == nil\n      assigns[:all_users].should == nil\n    end\n  end\n\n  # POST /home/redraw                                                      AJAX\n  #----------------------------------------------------------------------------\n  describe \"responding to POST redraw\" do\n    before(:each) do\n      require_user\n    end\n\n    it \"should save user selected options\" do\n      xhr :post, :redraw, :asset => \"tasks\", :user => \"Billy Bones\", :duration => \"two days\"\n      current_user.pref[:activity_asset].should == \"tasks\"\n      current_user.pref[:activity_user].should == \"Billy Bones\"\n      current_user.pref[:activity_duration].should == \"two days\"\n    end\n\n    it \"should get a list of activities\" do\n      @activity = FactoryGirl.create(:version, :item => FactoryGirl.create(:account, :user => current_user))\n      controller.should_receive(:get_activities).once.and_return([ @activity ])\n\n      get :index\n      assigns[:activities].should == [ @activity ]\n    end\n  end\n\n  # GET /home/toggle                                                       AJAX\n  #----------------------------------------------------------------------------\n  describe \"responding to GET toggle\" do\n    it \"should toggle expand/collapse state of form section in the session (delete existing session key)\" do\n      session[:hello] = \"world\"\n\n      xhr :get, :toggle, :id => \"hello\"\n      session.keys.should_not include(:hello)\n    end\n\n    it \"should toggle expand/collapse state of form section in the session (save new session key)\" do\n      session.delete(:hello)\n\n      xhr :get, :toggle, :id => \"hello\"\n      session[:hello].should == true\n    end\n  end\n  \n  describe \"activity_user\" do\n  \n    before(:each) do\n      @user = double(User, :id => 1, :is_a? => true)\n      @cur_user = double(User)\n    end\n  \n    it \"should find a user by email\" do\n      @cur_user.stub(:pref).and_return(:activity_user => 'billy@example.com')\n      controller.instance_variable_set(:@current_user, @cur_user)\n      User.should_receive(:where).with(:email => 'billy@example.com').and_return([@user])\n      controller.send(:activity_user).should == 1\n    end\n    \n    it \"should find a user by first name or last name\" do\n      @cur_user.stub(:pref).and_return(:activity_user => 'Billy')\n      controller.instance_variable_set(:@current_user, @cur_user)\n      User.should_receive(:where).with(\"upper(first_name) LIKE upper('%Billy%') OR upper(last_name) LIKE upper('%Billy%')\").and_return([@user])\n      controller.send(:activity_user).should == 1\n    end\n    \n    it \"should find a user by first name and last name\" do\n      @cur_user.stub(:pref).and_return(:activity_user => 'Billy Elliot')\n      controller.instance_variable_set(:@current_user, @cur_user)\n      User.should_receive(:where).with(\"(upper(first_name) LIKE upper('%Billy%') AND upper(last_name) LIKE upper('%Elliot%')) OR (upper(first_name) LIKE upper('%Elliot%') AND upper(last_name) LIKE upper('%Billy%'))\").and_return([@user])\n      controller.send(:activity_user).should == 1\n    end\n    \n    it \"should return nil when 'all_users' is specified\" do\n      @cur_user.stub(:pref).and_return(:activity_user => 'all_users')\n      controller.instance_variable_set(:@current_user, @cur_user)\n      User.should_not_receive(:where)\n      controller.send(:activity_user).should == nil\n    end\n    \n  end\n\nend\n"], "fixing_code": ["# Copyright (c) 2008-2013 Michael Dvorkin and contributors.\n#\n# Fat Free CRM is freely distributable under the terms of MIT license.\n# See MIT-LICENSE file or http://www.opensource.org/licenses/mit-license.php\n#------------------------------------------------------------------------------\nclass HomeController < ApplicationController\n  before_filter :require_user, :except => [ :toggle, :timezone ]\n  before_filter :set_current_tab, :only => :index\n  before_filter \"hook(:home_before_filter, self, :amazing => true)\"\n\n  #----------------------------------------------------------------------------\n  def index\n    @hello = \"Hello world\" # The hook below can access controller's instance variables.\n    hook(:home_controller, self, :params => \"it works!\")\n\n    @activities = get_activities\n    @my_tasks = Task.visible_on_dashboard(current_user).by_due_at\n    @my_opportunities = Opportunity.visible_on_dashboard(current_user).by_closes_on.by_amount\n    @my_accounts = Account.visible_on_dashboard(current_user).by_name\n    respond_with(@activities)\n  end\n\n  # GET /home/options                                                      AJAX\n  #----------------------------------------------------------------------------\n  def options\n    unless params[:cancel].true?\n      @asset = current_user.pref[:activity_asset] || \"all\"\n      @action = current_user.pref[:activity_event] || \"all_events\"\n      @user = current_user.pref[:activity_user] || \"all_users\"\n      @duration = current_user.pref[:activity_duration] || \"two_days\"\n      @all_users = User.order(\"first_name, last_name\")\n    end\n  end\n\n  # POST /home/redraw                                                      AJAX\n  #----------------------------------------------------------------------------\n  def redraw\n    current_user.pref[:activity_asset] = params[:asset] if params[:asset]\n    current_user.pref[:activity_event] = params[:event] if params[:event]\n    current_user.pref[:activity_user] = params[:user] if params[:user]\n    current_user.pref[:activity_duration] = params[:duration] if params[:duration]\n\n    render :index\n  end\n\n  # GET /home/toggle                                                       AJAX\n  #----------------------------------------------------------------------------\n  def toggle\n    if session[params[:id].to_sym]\n      session.delete(params[:id].to_sym)\n    else\n      session[params[:id].to_sym] = true\n    end\n    render :nothing => true\n  end\n\n  # GET /home/timeline                                                     AJAX\n  #----------------------------------------------------------------------------\n  def timeline\n    state = params[:state].to_s\n    if %w(Collapsed Expanded).include?(state)\n      if (model_type = params[:type].to_s).present?\n        if %w(comment email).include?(model_type)\n          model = model_type.camelize.constantize\n          item = model.find(params[:id])\n          item.update_attribute(:state, state)\n        end\n      else\n        comments, emails = params[:id].split(\"+\")\n        Comment.where(:id => comments.split(',')).update_all(:state => state) unless comments.blank?\n        Email.where(:id => emails.split(',')).update_all(:state => state) unless emails.blank?\n      end\n    end\n\n    render :nothing => true\n  end\n\n  # GET /home/timezone                                                     AJAX\n  #----------------------------------------------------------------------------\n  def timezone\n    #\n    # (new Date()).getTimezoneOffset() in JavaScript returns (UTC - localtime) in\n    # minutes, while ActiveSupport::TimeZone expects (localtime - UTC) in seconds.\n    #\n    if params[:offset]\n      session[:timezone_offset] = params[:offset].to_i * -60\n      ActiveSupport::TimeZone[session[:timezone_offset]]\n    end\n    render :nothing => true\n  end\n\n  private\n  #----------------------------------------------------------------------------\n  def get_activities(options = {})\n    options[:asset]    ||= activity_asset\n    options[:event]    ||= activity_event\n    options[:user]     ||= activity_user\n    options[:duration] ||= activity_duration\n    options[:max]      ||= 500\n\n    Version.latest(options).visible_to(current_user)\n  end\n\n  #----------------------------------------------------------------------------\n  def activity_asset\n    asset = current_user.pref[:activity_asset]\n    if asset.nil? || asset == \"all\"\n      nil\n    else\n      asset.singularize.capitalize\n    end\n  end\n\n  #----------------------------------------------------------------------------\n  def activity_event\n    event = current_user.pref[:activity_event]\n    if event == \"all_events\"\n      %w(create update destroy)\n    else\n      event\n    end\n  end\n\n  #----------------------------------------------------------------------------\n  def activity_user\n    user = current_user.pref[:activity_user]\n    if user && user != \"all_users\"\n      user = if user =~ /@/ # email\n          User.where(:email => user).first\n        else # first_name middle_name last_name any_name\n          name_query = if user.include?(\" \")\n            user.name_permutations.map{ |first, last|\n              \"(upper(first_name) LIKE upper('%#{first}%') AND upper(last_name) LIKE upper('%#{last}%'))\"\n            }.join(\" OR \")\n          else\n            \"upper(first_name) LIKE upper('%#{user}%') OR upper(last_name) LIKE upper('%#{user}%')\"\n          end\n          User.where(name_query).first\n        end\n    end\n    user.is_a?(User) ? user.id : nil\n  end\n\n  #----------------------------------------------------------------------------\n  def activity_duration\n    duration = current_user.pref[:activity_duration]\n    if duration\n      words = duration.split(\"_\") # \"two_weeks\" => 2.weeks\n      if %w(one two).include?(words.first)\n        %w(zero one two).index(words.first).send(words.last)\n      end\n    end\n  end\n\nend\n", "# Copyright (c) 2008-2013 Michael Dvorkin and contributors.\n#\n# Fat Free CRM is freely distributable under the terms of MIT license.\n# See MIT-LICENSE file or http://www.opensource.org/licenses/mit-license.php\n#------------------------------------------------------------------------------\nrequire File.expand_path(File.dirname(__FILE__) + '/../spec_helper')\n\ndescribe HomeController do\n\n  # GET /\n  #----------------------------------------------------------------------------\n  describe \"responding to GET /\" do\n    before(:each) do\n      require_user\n    end\n\n    it \"should get a list of activities\" do\n      activity = FactoryGirl.create(:version, :item => FactoryGirl.create(:account, :user => current_user))\n      controller.should_receive(:get_activities).once.and_return([ activity ])\n      get :index\n      assigns[:activities].should == [ activity ]\n    end\n\n    it \"should not include views in the list of activities\" do\n      activity = FactoryGirl.create(:version, :item => FactoryGirl.create(:account, :user => @current_user), :event => \"view\")\n      controller.should_receive(:get_activities).once.and_return([])\n\n      get :index\n      assigns[:activities].should == []\n    end\n\n    it \"should get a list of my tasks ordered by due_at\" do\n      task_1 = FactoryGirl.create(:task, :name => \"Your first task\", :bucket => \"due_asap\", :assigned_to => current_user.id)\n      task_2 = FactoryGirl.create(:task, :name => \"Another task for you\", :bucket => \"specific_time\", :calendar => 5.days.from_now.to_s, :assigned_to => current_user.id)\n      task_3 = FactoryGirl.create(:task, :name => \"Third Task\", :bucket => \"due_next_week\", :assigned_to => current_user.id)\n      task_4 = FactoryGirl.create(:task, :name => \"i've assigned it to myself\", :user => current_user, :calendar => 20.days.from_now.to_s, :assigned_to => nil, :bucket => \"specific_time\")\n\n      FactoryGirl.create(:task, :name => \"Someone else's Task\", :user_id => current_user.id, :bucket => \"due_asap\", :assigned_to => FactoryGirl.create(:user).id)\n      FactoryGirl.create(:task, :name => \"Not my task\", :bucket => \"due_asap\", :assigned_to => FactoryGirl.create(:user).id)\n\n      get :index\n      assigns[:my_tasks].should == [task_1, task_2, task_3, task_4]\n    end\n\n    it \"should not display completed tasks\" do\n      task_1 = FactoryGirl.create(:task, :user_id => current_user.id, :name => \"Your first task\", :bucket => \"due_asap\", :assigned_to => current_user.id)\n      task_2 = FactoryGirl.create(:task, :user_id => current_user.id, :name => \"Completed task\", :bucket => \"due_asap\", :completed_at => 1.days.ago, :completed_by => current_user.id, :assigned_to => current_user.id)\n\n      get :index\n      assigns[:my_tasks].should == [task_1]\n    end\n\n    it \"should get a list of my opportunities ordered by closes_on\" do\n      opportunity_1 = FactoryGirl.create(:opportunity, :name => \"Your first opportunity\", :closes_on => 15.days.from_now, :assigned_to => current_user.id, :stage => 'proposal')\n      opportunity_2 = FactoryGirl.create(:opportunity, :name => \"Another opportunity for you\", :closes_on => 10.days.from_now, :assigned_to => current_user.id, :stage => 'proposal')\n      opportunity_3 = FactoryGirl.create(:opportunity, :name => \"Third Opportunity\", :closes_on => 5.days.from_now, :assigned_to => current_user.id, :stage => 'proposal')\n      opportunity_4 = FactoryGirl.create(:opportunity, :name => \"Fourth Opportunity\", :closes_on => 50.days.from_now, :assigned_to => nil, :user_id => current_user.id, :stage => 'proposal')\n\n      FactoryGirl.create(:opportunity_in_pipeline, :name => \"Someone else's Opportunity\", :assigned_to => FactoryGirl.create(:user).id, :stage => 'proposal')\n      FactoryGirl.create(:opportunity_in_pipeline, :name => \"Not my opportunity\", :assigned_to => FactoryGirl.create(:user).id, :stage => 'proposal')\n\n      get :index\n      assigns[:my_opportunities].should == [opportunity_3, opportunity_2, opportunity_1, opportunity_4]\n    end\n\n    it \"should get a list of my accounts ordered by name\" do\n      account_1 = FactoryGirl.create(:account, :name => \"Anderson\", :assigned_to => current_user.id)\n      account_2 = FactoryGirl.create(:account, :name => \"Wilson\", :assigned_to => current_user.id)\n      account_3 = FactoryGirl.create(:account, :name => \"Triple\", :assigned_to => current_user.id)\n      account_4 = FactoryGirl.create(:account, :name => \"Double\", :assigned_to => nil, :user_id => current_user.id)\n\n      FactoryGirl.create(:account, :name => \"Someone else's Account\", :assigned_to => FactoryGirl.create(:user).id)\n      FactoryGirl.create(:account, :name => \"Not my account\", :assigned_to => FactoryGirl.create(:user).id)\n\n      get :index\n      assigns[:my_accounts].should == [account_1, account_4, account_3, account_2]\n    end\n\n    it \"should assign @hello and call hook\" do\n      require_user\n      controller.should_receive(:hook).at_least(:once)\n\n      get :index\n      assigns[:hello].should == \"Hello world\"\n    end\n  end\n\n  # GET /home/options                                                      AJAX\n  #----------------------------------------------------------------------------\n  describe \"responding to GET options\" do\n    before(:each) do\n      require_user\n    end\n\n    it \"should assign instance variables for user preferences\" do\n      @asset = FactoryGirl.create(:preference, :user => current_user, :name => \"activity_asset\", :value => Base64.encode64(Marshal.dump(\"tasks\")))\n      @user = FactoryGirl.create(:preference, :user => current_user, :name => \"activity_user\", :value => Base64.encode64(Marshal.dump(\"Billy Bones\")))\n      @duration = FactoryGirl.create(:preference, :user => current_user, :name => \"activity_duration\", :value => Base64.encode64(Marshal.dump(\"two days\")))\n\n      xhr :get, :options\n      assigns[:asset].should == \"tasks\"\n      assigns[:user].should == \"Billy Bones\"\n      assigns[:duration].should == \"two days\"\n      assigns[:all_users].should == User.order(\"first_name, last_name\").all\n    end\n\n    it \"should not assign instance variables when hiding options\" do\n      xhr :get, :options, :cancel => \"true\"\n      assigns[:asset].should == nil\n      assigns[:user].should == nil\n      assigns[:duration].should == nil\n      assigns[:all_users].should == nil\n    end\n  end\n\n  # POST /home/redraw                                                      AJAX\n  #----------------------------------------------------------------------------\n  describe \"responding to POST redraw\" do\n    before(:each) do\n      require_user\n    end\n\n    it \"should save user selected options\" do\n      xhr :post, :redraw, :asset => \"tasks\", :user => \"Billy Bones\", :duration => \"two days\"\n      current_user.pref[:activity_asset].should == \"tasks\"\n      current_user.pref[:activity_user].should == \"Billy Bones\"\n      current_user.pref[:activity_duration].should == \"two days\"\n    end\n\n    it \"should get a list of activities\" do\n      @activity = FactoryGirl.create(:version, :item => FactoryGirl.create(:account, :user => current_user))\n      controller.should_receive(:get_activities).once.and_return([ @activity ])\n\n      get :index\n      assigns[:activities].should == [ @activity ]\n    end\n  end\n\n  # GET /home/toggle                                                       AJAX\n  #----------------------------------------------------------------------------\n  describe \"responding to GET toggle\" do\n    it \"should toggle expand/collapse state of form section in the session (delete existing session key)\" do\n      session[:hello] = \"world\"\n\n      xhr :get, :toggle, :id => \"hello\"\n      session.keys.should_not include(:hello)\n    end\n\n    it \"should toggle expand/collapse state of form section in the session (save new session key)\" do\n      session.delete(:hello)\n\n      xhr :get, :toggle, :id => \"hello\"\n      session[:hello].should == true\n    end\n  end\n\n  describe \"activity_user\" do\n\n    before(:each) do\n      @user = double(User, :id => 1, :is_a? => true)\n      @cur_user = double(User)\n    end\n\n    it \"should find a user by email\" do\n      @cur_user.stub(:pref).and_return(:activity_user => 'billy@example.com')\n      controller.instance_variable_set(:@current_user, @cur_user)\n      User.should_receive(:where).with(:email => 'billy@example.com').and_return([@user])\n      controller.send(:activity_user).should == 1\n    end\n\n    it \"should find a user by first name or last name\" do\n      @cur_user.stub(:pref).and_return(:activity_user => 'Billy')\n      controller.instance_variable_set(:@current_user, @cur_user)\n      User.should_receive(:where).with(\"upper(first_name) LIKE upper('%Billy%') OR upper(last_name) LIKE upper('%Billy%')\").and_return([@user])\n      controller.send(:activity_user).should == 1\n    end\n\n    it \"should find a user by first name and last name\" do\n      @cur_user.stub(:pref).and_return(:activity_user => 'Billy Elliot')\n      controller.instance_variable_set(:@current_user, @cur_user)\n      User.should_receive(:where).with(\"(upper(first_name) LIKE upper('%Billy%') AND upper(last_name) LIKE upper('%Elliot%')) OR (upper(first_name) LIKE upper('%Elliot%') AND upper(last_name) LIKE upper('%Billy%'))\").and_return([@user])\n      controller.send(:activity_user).should == 1\n    end\n\n    it \"should return nil when 'all_users' is specified\" do\n      @cur_user.stub(:pref).and_return(:activity_user => 'all_users')\n      controller.instance_variable_set(:@current_user, @cur_user)\n      User.should_not_receive(:where)\n      controller.send(:activity_user).should == nil\n    end\n\n  end\n\n  describe \"timeline\" do\n\n    before(:each) do\n      require_user\n    end\n\n    it \"should collapse all comments and emails on a specific contact\" do\n      comment = double(Comment)\n      Comment.should_receive(:find).with(\"1\").and_return(comment)\n      comment.should_receive(:update_attribute).with(:state, 'Collapsed')\n      xhr :get, :timeline, :type => \"comment\", :id => \"1\", :state => \"Collapsed\"\n    end\n\n    it \"should expand all comments and emails on a specific contact\" do\n      comment = double(Comment)\n      Comment.should_receive(:find).with(\"1\").and_return(comment)\n      comment.should_receive(:update_attribute).with(:state, 'Expanded')\n      xhr :get, :timeline, :type => \"comment\", :id => \"1\", :state => \"Expanded\"\n    end\n\n    it \"should not do anything when state neither Expanded nor Collapsed\" do\n      comment = double(Comment)\n      Comment.should_not_receive(:find).with(\"1\")\n      xhr :get, :timeline, :type => \"comment\", :id => \"1\", :state => \"Explode\"\n    end\n\n    it \"should collapse all comments and emails on Contact\" do\n      where_stub = double\n      where_stub.should_receive(:update_all).with(:state => \"Collapsed\")\n      Comment.should_receive(:where).and_return(where_stub)\n      xhr :get, :timeline, :id => \"1,2,3,4+\", :state => \"Collapsed\"\n    end\n\n    it \"should not allow an arbitary state (sanitizes input)\" do\n      where_stub = double\n      where_stub.should_receive(:update_all).with(:state => \"Expanded\")\n      Comment.should_receive(:where).and_return(where_stub)\n      xhr :get, :timeline, :id => \"1,2,3,4+\", :state => \"Expanded\"\n    end\n\n    it \"should not update an arbitary model (sanitizes input)\" do\n      where_stub = double\n      where_stub.should_receive(:update_all).with(:state => \"Expanded\")\n      Comment.should_receive(:where).and_return(where_stub)\n      xhr :get, :timeline, :id => \"1,2,3,4+\", :state => \"Expanded\"\n    end\n\n  end\n\nend\n"], "filenames": ["app/controllers/home_controller.rb", "spec/controllers/home_controller_spec.rb"], "buggy_code_start_loc": [60, 45], "buggy_code_end_loc": [68, 192], "fixing_code_start_loc": [60, 45], "fixing_code_end_loc": [73, 241], "type": "CWE-89", "message": "Multiple SQL injection vulnerabilities in app/controllers/home_controller.rb in Fat Free CRM before 0.12.1 allow remote authenticated users to execute arbitrary SQL commands via (1) the homepage timeline feature or (2) the activity feature.", "other": {"cve": {"id": "CVE-2013-7225", "sourceIdentifier": "cve@mitre.org", "published": "2014-01-02T14:59:04.157", "lastModified": "2014-01-03T17:04:34.597", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Multiple SQL injection vulnerabilities in app/controllers/home_controller.rb in Fat Free CRM before 0.12.1 allow remote authenticated users to execute arbitrary SQL commands via (1) the homepage timeline feature or (2) the activity feature."}, {"lang": "es", "value": "M\u00faltiples vulnerabilidades de inyecci\u00f3n SQL en pp/controllers/home_controller.rb en Fat Free CRM anterior a 0.12.1 permite a usuarios remotos autenticados ejecutar comandos SQL a trav\u00e9s de (1) la funci\u00f3n timeline homepage o (2) la funci\u00f3n de  actividad."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fatfreecrm:fat_free_crm:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.12.0", "matchCriteriaId": "437226C5-1A19-4BFE-9177-603284DAEADA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fatfreecrm:fat_free_crm:0.9.6:*:*:*:*:*:*:*", "matchCriteriaId": "ADF154CE-04ED-446E-B2F4-483D7D356975"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fatfreecrm:fat_free_crm:0.9.7:*:*:*:*:*:*:*", "matchCriteriaId": "34CFB3C8-9C3B-43D8-B946-0EB2FAFD3BF3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fatfreecrm:fat_free_crm:0.9.8:*:*:*:*:*:*:*", "matchCriteriaId": "8C2B22FC-6FA2-4365-BC71-ED79D914B781"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fatfreecrm:fat_free_crm:0.9.9:*:*:*:*:*:*:*", "matchCriteriaId": "0108A4ED-2D1F-49C8-88C7-7A074767CFE5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fatfreecrm:fat_free_crm:0.9.10:*:*:*:*:*:*:*", "matchCriteriaId": "0A5888F1-1D68-4131-ADDC-BBEDB62E74ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fatfreecrm:fat_free_crm:0.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "0F5CBECE-E4A4-48A7-8880-D9562378FE22"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fatfreecrm:fat_free_crm:0.11.0:*:*:*:*:*:*:*", "matchCriteriaId": "33170E54-4CF5-42B2-9F9A-269C26C9FB70"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fatfreecrm:fat_free_crm:0.11.1:*:*:*:*:*:*:*", "matchCriteriaId": "890482B9-D9AC-4D10-9764-4E23A112070F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fatfreecrm:fat_free_crm:0.11.2:*:*:*:*:*:*:*", "matchCriteriaId": "3C652479-AE15-4BAC-AE75-9018FE71AABA"}]}]}], "references": [{"url": "http://openwall.com/lists/oss-security/2013/12/28/2", "source": "cve@mitre.org"}, {"url": "http://seclists.org/fulldisclosure/2013/Dec/199", "source": "cve@mitre.org"}, {"url": "http://www.phenoelit.org/stuff/ffcrm.txt", "source": "cve@mitre.org", "tags": ["Exploit"]}, {"url": "https://github.com/fatfreecrm/fat_free_crm/commit/078035f1ef73ed85285ac9d128c3c5f670cef066", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}, {"url": "https://github.com/fatfreecrm/fat_free_crm/commit/d4b2de81a4d8c1b201482edcb2488ed9280a65fd", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}, {"url": "https://github.com/fatfreecrm/fat_free_crm/issues/300", "source": "cve@mitre.org"}, {"url": "https://github.com/fatfreecrm/fat_free_crm/wiki/Fixing-security-vulnerabilities-%2827th-Dec-2013%29", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/fatfreecrm/fat_free_crm/commit/078035f1ef73ed85285ac9d128c3c5f670cef066"}}