{"buggy_code": ["\"use strict\";\n\n/**\n * Various utility functions.\n * @namespace\n */\nvar util = module.exports = require(\"./util/minimal\");\n\nvar roots = require(\"./roots\");\n\nvar Type, // cyclic\n    Enum;\n\nutil.codegen = require(\"@protobufjs/codegen\");\nutil.fetch   = require(\"@protobufjs/fetch\");\nutil.path    = require(\"@protobufjs/path\");\n\n/**\n * Node's fs module if available.\n * @type {Object.<string,*>}\n */\nutil.fs = util.inquire(\"fs\");\n\n/**\n * Converts an object's values to an array.\n * @param {Object.<string,*>} object Object to convert\n * @returns {Array.<*>} Converted array\n */\nutil.toArray = function toArray(object) {\n    if (object) {\n        var keys  = Object.keys(object),\n            array = new Array(keys.length),\n            index = 0;\n        while (index < keys.length)\n            array[index] = object[keys[index++]];\n        return array;\n    }\n    return [];\n};\n\n/**\n * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.\n * @param {Array.<*>} array Array to convert\n * @returns {Object.<string,*>} Converted object\n */\nutil.toObject = function toObject(array) {\n    var object = {},\n        index  = 0;\n    while (index < array.length) {\n        var key = array[index++],\n            val = array[index++];\n        if (val !== undefined)\n            object[key] = val;\n    }\n    return object;\n};\n\nvar safePropBackslashRe = /\\\\/g,\n    safePropQuoteRe     = /\"/g;\n\n/**\n * Tests whether the specified name is a reserved word in JS.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nutil.isReserved = function isReserved(name) {\n    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);\n};\n\n/**\n * Returns a safe property accessor for the specified property name.\n * @param {string} prop Property name\n * @returns {string} Safe accessor\n */\nutil.safeProp = function safeProp(prop) {\n    if (!/^[$\\w_]+$/.test(prop) || util.isReserved(prop))\n        return \"[\\\"\" + prop.replace(safePropBackslashRe, \"\\\\\\\\\").replace(safePropQuoteRe, \"\\\\\\\"\") + \"\\\"]\";\n    return \".\" + prop;\n};\n\n/**\n * Converts the first character of a string to upper case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.ucFirst = function ucFirst(str) {\n    return str.charAt(0).toUpperCase() + str.substring(1);\n};\n\nvar camelCaseRe = /_([a-z])/g;\n\n/**\n * Converts a string to camel case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.camelCase = function camelCase(str) {\n    return str.substring(0, 1)\n         + str.substring(1)\n               .replace(camelCaseRe, function($0, $1) { return $1.toUpperCase(); });\n};\n\n/**\n * Compares reflected fields by id.\n * @param {Field} a First field\n * @param {Field} b Second field\n * @returns {number} Comparison value\n */\nutil.compareFieldsById = function compareFieldsById(a, b) {\n    return a.id - b.id;\n};\n\n/**\n * Decorator helper for types (TypeScript).\n * @param {Constructor<T>} ctor Constructor function\n * @param {string} [typeName] Type name, defaults to the constructor's name\n * @returns {Type} Reflected type\n * @template T extends Message<T>\n * @property {Root} root Decorators root\n */\nutil.decorateType = function decorateType(ctor, typeName) {\n\n    /* istanbul ignore if */\n    if (ctor.$type) {\n        if (typeName && ctor.$type.name !== typeName) {\n            util.decorateRoot.remove(ctor.$type);\n            ctor.$type.name = typeName;\n            util.decorateRoot.add(ctor.$type);\n        }\n        return ctor.$type;\n    }\n\n    /* istanbul ignore next */\n    if (!Type)\n        Type = require(\"./type\");\n\n    var type = new Type(typeName || ctor.name);\n    util.decorateRoot.add(type);\n    type.ctor = ctor; // sets up .encode, .decode etc.\n    Object.defineProperty(ctor, \"$type\", { value: type, enumerable: false });\n    Object.defineProperty(ctor.prototype, \"$type\", { value: type, enumerable: false });\n    return type;\n};\n\nvar decorateEnumIndex = 0;\n\n/**\n * Decorator helper for enums (TypeScript).\n * @param {Object} object Enum object\n * @returns {Enum} Reflected enum\n */\nutil.decorateEnum = function decorateEnum(object) {\n\n    /* istanbul ignore if */\n    if (object.$type)\n        return object.$type;\n\n    /* istanbul ignore next */\n    if (!Enum)\n        Enum = require(\"./enum\");\n\n    var enm = new Enum(\"Enum\" + decorateEnumIndex++, object);\n    util.decorateRoot.add(enm);\n    Object.defineProperty(object, \"$type\", { value: enm, enumerable: false });\n    return enm;\n};\n\n\n/**\n * Sets the value of a property by property path. If a value already exists, it is turned to an array\n * @param {Object.<string,*>} dst Destination object\n * @param {string} path dot '.' delimited path of the property to set\n * @param {Object} value the value to set\n * @returns {Object.<string,*>} Destination object\n */\nutil.setProperty = function setProperty(dst, path, value) {\n    function setProp(dst, path, value) {\n        var part = path.shift();\n        if (part === \"__proto__\") {\n          return dst;\n        }\n        if (path.length > 0) {\n            dst[part] = setProp(dst[part] || {}, path, value);\n        } else {\n            var prevValue = dst[part];\n            if (prevValue)\n                value = [].concat(prevValue).concat(value);\n            dst[part] = value;\n        }\n        return dst;\n    }\n\n    if (typeof dst !== \"object\")\n        throw TypeError(\"dst must be an object\");\n    if (!path)\n        throw TypeError(\"path must be specified\");\n\n    path = path.split(\".\");\n    return setProp(dst, path, value);\n};\n\n/**\n * Decorator root (TypeScript).\n * @name util.decorateRoot\n * @type {Root}\n * @readonly\n */\nObject.defineProperty(util, \"decorateRoot\", {\n    get: function() {\n        return roots[\"decorated\"] || (roots[\"decorated\"] = new (require(\"./root\"))());\n    }\n});\n", "var tape = require(\"tape\");\n\nvar protobuf = require(\"..\");\n\nvar util = protobuf.util;\n\ntape.test(\"util\", function(test) {\n\n    test.test(test.name + \" - merge\", function(test) {\n        var o = {};\n        util.merge(o, {});\n        test.same(o, {}, \"should do nothing if both objects are empty\");\n        util.merge(o, { a: 1 });\n        test.same(o, { a: 1 }, \"should merge non-existing keys\");\n        util.merge(o, { a: 2 });\n        test.same(o, { a: 2 }, \"should merge existing keys\");\n        util.merge(o, { a: 3 }, true);\n        test.same(o, { a: 2 }, \"should not merge existing keys\");\n        test.end();\n    });\n\n    test.test(test.name + \" - lcFirst\", function(test) {\n        test.equal(util.lcFirst(\"ABC\"), \"aBC\", \"should convert the first character to lower case\");\n        test.end();\n    });\n\n    test.test(test.name + \" - ucFirst\", function(test) {\n        test.equal(util.ucFirst(\"abc\"), \"Abc\", \"should convert the first character to upper case\");\n        test.end();\n    });\n\n    test.test(test.name + \" - isSet\", function(test) {\n        // note that encoders don't check for default values either\n        var neverPresent = [\n            [],\n            {},\n            undefined,\n            null\n        ];\n        neverPresent.forEach(function(value) {\n            var proto = {};\n            var instance = Object.create(proto);\n            proto.p = value;\n            instance.i = value;\n            test.notOk(util.isSet(proto, \"p\"), \"should return that \" + JSON.stringify(value) + \" on the prototype is not present\");\n            test.notOk(util.isSet(instance, \"i\"), \"should return that \" + JSON.stringify(value) + \" on the instance is not present\");\n        });\n        var cases = {\n            \"arrays\": [ [], [0] ],\n            \"objects\": [ {}, {a:1} ],\n            \"strings\": [ undefined, \"\" ],\n            \"numbers\": [ undefined, 0 ],\n            \"booleans\": [ undefined, false ]\n        };\n        Object.keys(cases).forEach(function(name) {\n            var empty = cases[name][0],\n                value = cases[name][1];\n            var proto = {};\n            var instance = Object.create(proto);\n            proto.pe = instance.ie = empty;\n            proto.p = instance.i = value;\n            if (empty !== undefined) { // not present anyway\n                test.notOk(util.isSet(instance, \"pe\"), \"should return that empty \" + name + \" on the prototype are not present\");\n                test.notOk(util.isSet(instance, \"ie\"), \"should return that empty \" + name + \" on the instance are not present\");\n            }\n            test.notOk(util.isSet(instance, \"p\"), \"should return that \" + name + \" on the prototype are not present\");\n            test.ok(util.isSet(instance, \"i\"), \"should return that \" + name + \" on the instance ARE present\");\n        });\n\n         test.end();\n    });\n\n    test.test(test.name + \" - setProperty\", function(test) {\n        var o = {};\n\n        test.throws(function() {\n            util.setProperty(5, 'prop1', 5);\n        }, TypeError, \"dst must be an object\");\n\n        test.throws(function () {\n            util.setProperty(o, '', 5);\n        }, TypeError, \"path must be specified\");\n\n        util.setProperty(o, 'prop1', 5);\n        test.same(o, {prop1: 5}, \"should set single property value\");\n\n        util.setProperty(o, 'prop1', 6);\n        test.same(o, {prop1: [5, 6]}, \"should convert to array if same property is set\");\n\n        util.setProperty(o, 'prop.subprop', { subsub: 5});\n        test.same(o, {prop1: [5, 6], prop: {subprop: {subsub: 5}}}, \"should handle nested properties properly\");\n\n        util.setProperty(o, 'prop.subprop.subsub', 6);\n        test.same(o, {prop1: [5, 6], prop: {subprop: {subsub: [5, 6]}}}, \"should convert to array nested property\");\n\n        util.setProperty(o, 'prop.subprop', { subsub2: 7});\n        test.same(o, {prop1: [5, 6], prop: {subprop: [{subsub: [5,6]}, {subsub2: 7}]}}, \"should convert nested properties to array\");\n\n        test.end();\n    });\n\n    test.end();\n});"], "fixing_code": ["\"use strict\";\n\n/**\n * Various utility functions.\n * @namespace\n */\nvar util = module.exports = require(\"./util/minimal\");\n\nvar roots = require(\"./roots\");\n\nvar Type, // cyclic\n    Enum;\n\nutil.codegen = require(\"@protobufjs/codegen\");\nutil.fetch   = require(\"@protobufjs/fetch\");\nutil.path    = require(\"@protobufjs/path\");\n\n/**\n * Node's fs module if available.\n * @type {Object.<string,*>}\n */\nutil.fs = util.inquire(\"fs\");\n\n/**\n * Converts an object's values to an array.\n * @param {Object.<string,*>} object Object to convert\n * @returns {Array.<*>} Converted array\n */\nutil.toArray = function toArray(object) {\n    if (object) {\n        var keys  = Object.keys(object),\n            array = new Array(keys.length),\n            index = 0;\n        while (index < keys.length)\n            array[index] = object[keys[index++]];\n        return array;\n    }\n    return [];\n};\n\n/**\n * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.\n * @param {Array.<*>} array Array to convert\n * @returns {Object.<string,*>} Converted object\n */\nutil.toObject = function toObject(array) {\n    var object = {},\n        index  = 0;\n    while (index < array.length) {\n        var key = array[index++],\n            val = array[index++];\n        if (val !== undefined)\n            object[key] = val;\n    }\n    return object;\n};\n\nvar safePropBackslashRe = /\\\\/g,\n    safePropQuoteRe     = /\"/g;\n\n/**\n * Tests whether the specified name is a reserved word in JS.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nutil.isReserved = function isReserved(name) {\n    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);\n};\n\n/**\n * Returns a safe property accessor for the specified property name.\n * @param {string} prop Property name\n * @returns {string} Safe accessor\n */\nutil.safeProp = function safeProp(prop) {\n    if (!/^[$\\w_]+$/.test(prop) || util.isReserved(prop))\n        return \"[\\\"\" + prop.replace(safePropBackslashRe, \"\\\\\\\\\").replace(safePropQuoteRe, \"\\\\\\\"\") + \"\\\"]\";\n    return \".\" + prop;\n};\n\n/**\n * Converts the first character of a string to upper case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.ucFirst = function ucFirst(str) {\n    return str.charAt(0).toUpperCase() + str.substring(1);\n};\n\nvar camelCaseRe = /_([a-z])/g;\n\n/**\n * Converts a string to camel case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.camelCase = function camelCase(str) {\n    return str.substring(0, 1)\n         + str.substring(1)\n               .replace(camelCaseRe, function($0, $1) { return $1.toUpperCase(); });\n};\n\n/**\n * Compares reflected fields by id.\n * @param {Field} a First field\n * @param {Field} b Second field\n * @returns {number} Comparison value\n */\nutil.compareFieldsById = function compareFieldsById(a, b) {\n    return a.id - b.id;\n};\n\n/**\n * Decorator helper for types (TypeScript).\n * @param {Constructor<T>} ctor Constructor function\n * @param {string} [typeName] Type name, defaults to the constructor's name\n * @returns {Type} Reflected type\n * @template T extends Message<T>\n * @property {Root} root Decorators root\n */\nutil.decorateType = function decorateType(ctor, typeName) {\n\n    /* istanbul ignore if */\n    if (ctor.$type) {\n        if (typeName && ctor.$type.name !== typeName) {\n            util.decorateRoot.remove(ctor.$type);\n            ctor.$type.name = typeName;\n            util.decorateRoot.add(ctor.$type);\n        }\n        return ctor.$type;\n    }\n\n    /* istanbul ignore next */\n    if (!Type)\n        Type = require(\"./type\");\n\n    var type = new Type(typeName || ctor.name);\n    util.decorateRoot.add(type);\n    type.ctor = ctor; // sets up .encode, .decode etc.\n    Object.defineProperty(ctor, \"$type\", { value: type, enumerable: false });\n    Object.defineProperty(ctor.prototype, \"$type\", { value: type, enumerable: false });\n    return type;\n};\n\nvar decorateEnumIndex = 0;\n\n/**\n * Decorator helper for enums (TypeScript).\n * @param {Object} object Enum object\n * @returns {Enum} Reflected enum\n */\nutil.decorateEnum = function decorateEnum(object) {\n\n    /* istanbul ignore if */\n    if (object.$type)\n        return object.$type;\n\n    /* istanbul ignore next */\n    if (!Enum)\n        Enum = require(\"./enum\");\n\n    var enm = new Enum(\"Enum\" + decorateEnumIndex++, object);\n    util.decorateRoot.add(enm);\n    Object.defineProperty(object, \"$type\", { value: enm, enumerable: false });\n    return enm;\n};\n\n\n/**\n * Sets the value of a property by property path. If a value already exists, it is turned to an array\n * @param {Object.<string,*>} dst Destination object\n * @param {string} path dot '.' delimited path of the property to set\n * @param {Object} value the value to set\n * @returns {Object.<string,*>} Destination object\n */\nutil.setProperty = function setProperty(dst, path, value) {\n    function setProp(dst, path, value) {\n        var part = path.shift();\n        if (part === \"__proto__\" || part === \"prototype\") {\n          return dst;\n        }\n        if (path.length > 0) {\n            dst[part] = setProp(dst[part] || {}, path, value);\n        } else {\n            var prevValue = dst[part];\n            if (prevValue)\n                value = [].concat(prevValue).concat(value);\n            dst[part] = value;\n        }\n        return dst;\n    }\n\n    if (typeof dst !== \"object\")\n        throw TypeError(\"dst must be an object\");\n    if (!path)\n        throw TypeError(\"path must be specified\");\n\n    path = path.split(\".\");\n    return setProp(dst, path, value);\n};\n\n/**\n * Decorator root (TypeScript).\n * @name util.decorateRoot\n * @type {Root}\n * @readonly\n */\nObject.defineProperty(util, \"decorateRoot\", {\n    get: function() {\n        return roots[\"decorated\"] || (roots[\"decorated\"] = new (require(\"./root\"))());\n    }\n});\n", "var tape = require(\"tape\");\n\nvar protobuf = require(\"..\");\n\nvar util = protobuf.util;\n\ntape.test(\"util\", function(test) {\n\n    test.test(test.name + \" - merge\", function(test) {\n        var o = {};\n        util.merge(o, {});\n        test.same(o, {}, \"should do nothing if both objects are empty\");\n        util.merge(o, { a: 1 });\n        test.same(o, { a: 1 }, \"should merge non-existing keys\");\n        util.merge(o, { a: 2 });\n        test.same(o, { a: 2 }, \"should merge existing keys\");\n        util.merge(o, { a: 3 }, true);\n        test.same(o, { a: 2 }, \"should not merge existing keys\");\n        test.end();\n    });\n\n    test.test(test.name + \" - lcFirst\", function(test) {\n        test.equal(util.lcFirst(\"ABC\"), \"aBC\", \"should convert the first character to lower case\");\n        test.end();\n    });\n\n    test.test(test.name + \" - ucFirst\", function(test) {\n        test.equal(util.ucFirst(\"abc\"), \"Abc\", \"should convert the first character to upper case\");\n        test.end();\n    });\n\n    test.test(test.name + \" - isSet\", function(test) {\n        // note that encoders don't check for default values either\n        var neverPresent = [\n            [],\n            {},\n            undefined,\n            null\n        ];\n        neverPresent.forEach(function(value) {\n            var proto = {};\n            var instance = Object.create(proto);\n            proto.p = value;\n            instance.i = value;\n            test.notOk(util.isSet(proto, \"p\"), \"should return that \" + JSON.stringify(value) + \" on the prototype is not present\");\n            test.notOk(util.isSet(instance, \"i\"), \"should return that \" + JSON.stringify(value) + \" on the instance is not present\");\n        });\n        var cases = {\n            \"arrays\": [ [], [0] ],\n            \"objects\": [ {}, {a:1} ],\n            \"strings\": [ undefined, \"\" ],\n            \"numbers\": [ undefined, 0 ],\n            \"booleans\": [ undefined, false ]\n        };\n        Object.keys(cases).forEach(function(name) {\n            var empty = cases[name][0],\n                value = cases[name][1];\n            var proto = {};\n            var instance = Object.create(proto);\n            proto.pe = instance.ie = empty;\n            proto.p = instance.i = value;\n            if (empty !== undefined) { // not present anyway\n                test.notOk(util.isSet(instance, \"pe\"), \"should return that empty \" + name + \" on the prototype are not present\");\n                test.notOk(util.isSet(instance, \"ie\"), \"should return that empty \" + name + \" on the instance are not present\");\n            }\n            test.notOk(util.isSet(instance, \"p\"), \"should return that \" + name + \" on the prototype are not present\");\n            test.ok(util.isSet(instance, \"i\"), \"should return that \" + name + \" on the instance ARE present\");\n        });\n\n         test.end();\n    });\n\n    test.test(test.name + \" - setProperty\", function(test) {\n        var o = {};\n\n        test.throws(function() {\n            util.setProperty(5, 'prop1', 5);\n        }, TypeError, \"dst must be an object\");\n\n        test.throws(function () {\n            util.setProperty(o, '', 5);\n        }, TypeError, \"path must be specified\");\n\n        util.setProperty(o, 'prop1', 5);\n        test.same(o, {prop1: 5}, \"should set single property value\");\n\n        util.setProperty(o, 'prop1', 6);\n        test.same(o, {prop1: [5, 6]}, \"should convert to array if same property is set\");\n\n        util.setProperty(o, 'prop.subprop', { subsub: 5});\n        test.same(o, {prop1: [5, 6], prop: {subprop: {subsub: 5}}}, \"should handle nested properties properly\");\n\n        util.setProperty(o, 'prop.subprop.subsub', 6);\n        test.same(o, {prop1: [5, 6], prop: {subprop: {subsub: [5, 6]}}}, \"should convert to array nested property\");\n\n        util.setProperty(o, 'prop.subprop', { subsub2: 7});\n        test.same(o, {prop1: [5, 6], prop: {subprop: [{subsub: [5,6]}, {subsub2: 7}]}}, \"should convert nested properties to array\");\n        \n        util.setProperty({}, \"__proto__.test\", \"value\");\n        test.is({}.test, undefined);\n\n        util.setProperty({}, \"prototype.test\", \"value\");\n        test.is({}.test, undefined);\n\n        util.setProperty({}, \"constructor.prototype.test\", \"value\");\n        test.is({}.test, undefined);\n\n        test.end();\n    });\n\n    test.end();\n});"], "filenames": ["src/util.js", "tests/api_util.js"], "buggy_code_start_loc": [179, 97], "buggy_code_end_loc": [180, 97], "fixing_code_start_loc": [179, 98], "fixing_code_end_loc": [180, 107], "type": "CWE-1321", "message": "\"protobuf.js (aka protobufjs) 6.10.0 through 7.x before 7.2.5 allows Prototype Pollution, a different vulnerability than CVE-2022-25878. A user-controlled protobuf message can be used by an attacker to pollute the prototype of Object.prototype by adding and overwriting its data and functions. Exploitation can involve: (1) using the function parse to parse protobuf messages on the fly, (2) loading .proto files by using load/loadSync functions, or (3) providing untrusted input to the functions ReflectionObject.setParsedOption and util.setProperty.", "other": {"cve": {"id": "CVE-2023-36665", "sourceIdentifier": "cve@mitre.org", "published": "2023-07-05T14:15:09.410", "lastModified": "2023-09-07T22:15:07.643", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "\"protobuf.js (aka protobufjs) 6.10.0 through 7.x before 7.2.5 allows Prototype Pollution, a different vulnerability than CVE-2022-25878. A user-controlled protobuf message can be used by an attacker to pollute the prototype of Object.prototype by adding and overwriting its data and functions. Exploitation can involve: (1) using the function parse to parse protobuf messages on the fly, (2) loading .proto files by using load/loadSync functions, or (3) providing untrusted input to the functions ReflectionObject.setParsedOption and util.setProperty."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:protobufjs_project:protobufjs:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "6.10.0", "versionEndExcluding": "7.2.4", "matchCriteriaId": "FE3B68EA-A175-44B3-AE3C-FCA6A0C0DD10"}]}]}], "references": [{"url": "https://github.com/protobufjs/protobuf.js/commit/e66379f451b0393c27d87b37fa7d271619e16b0d", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/protobufjs/protobuf.js/compare/protobufjs-v7.2.3...protobufjs-v7.2.4", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/protobufjs/protobuf.js/pull/1899", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/protobufjs/protobuf.js/releases/tag/protobufjs-v7.2.4", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://www.code-intelligence.com/blog/cve-protobufjs-prototype-pollution-cve-2023-36665", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/protobufjs/protobuf.js/commit/e66379f451b0393c27d87b37fa7d271619e16b0d"}}