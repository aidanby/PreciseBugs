{"buggy_code": ["<?php\n/**\n * kses 0.2.2 - HTML/XHTML filter that only allows some elements and attributes\n * Copyright (C) 2002, 2003, 2005  Ulf Harnhammar\n *\n * This program is free software and open source software; you can redistribute\n * it and/or modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the License,\n * or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA\n * http://www.gnu.org/licenses/gpl.html\n *\n * [kses strips evil scripts!]\n *\n * Added wp_ prefix to avoid conflicts with existing kses users\n *\n * @version 0.2.2\n * @copyright (C) 2002, 2003, 2005\n * @author Ulf Harnhammar <http://advogato.org/person/metaur/>\n *\n * @package External\n * @subpackage KSES\n *\n */\n\n/**\n * You can override this in a plugin.\n *\n * The {@see 'wp_kses_allowed_html'} filter is more powerful and supplies context.\n *\n * `CUSTOM_TAGS` is not recommended and should be considered deprecated.\n *\n * @see wp_kses_allowed_html()\n *\n * @since 1.2.0\n */\nif ( ! defined( 'CUSTOM_TAGS' ) )\n\tdefine( 'CUSTOM_TAGS', false );\n\n// Ensure that these variables are added to the global namespace\n// (e.g. if using namespaces / autoload in the current PHP environment).\nglobal $allowedposttags, $allowedtags, $allowedentitynames;\n\nif ( ! CUSTOM_TAGS ) {\n\t/**\n\t * Kses global for default allowable HTML tags.\n\t *\n\t * Can be override by using CUSTOM_TAGS constant.\n\t *\n\t * @global array $allowedposttags\n\t * @since 2.0.0\n\t */\n\t$allowedposttags = array(\n\t\t'address' => array(),\n\t\t'a' => array(\n\t\t\t'href' => true,\n\t\t\t'rel' => true,\n\t\t\t'rev' => true,\n\t\t\t'name' => true,\n\t\t\t'target' => true,\n\t\t\t'download' => array(\n\t\t\t\t'valueless' => 'y',\n\t\t\t),\n\t\t),\n\t\t'abbr' => array(),\n\t\t'acronym' => array(),\n\t\t'area' => array(\n\t\t\t'alt' => true,\n\t\t\t'coords' => true,\n\t\t\t'href' => true,\n\t\t\t'nohref' => true,\n\t\t\t'shape' => true,\n\t\t\t'target' => true,\n\t\t),\n\t\t'article' => array(\n\t\t\t'align' => true,\n\t\t\t'dir' => true,\n\t\t\t'lang' => true,\n\t\t\t'xml:lang' => true,\n\t\t),\n\t\t'aside' => array(\n\t\t\t'align' => true,\n\t\t\t'dir' => true,\n\t\t\t'lang' => true,\n\t\t\t'xml:lang' => true,\n\t\t),\n\t\t'audio' => array(\n\t\t\t'autoplay' => true,\n\t\t\t'controls' => true,\n\t\t\t'loop' => true,\n\t\t\t'muted' => true,\n\t\t\t'preload' => true,\n\t\t\t'src' => true,\n\t\t),\n\t\t'b' => array(),\n\t\t'bdo' => array(\n\t\t\t'dir' => true,\n\t\t),\n\t\t'big' => array(),\n\t\t'blockquote' => array(\n\t\t\t'cite' => true,\n\t\t\t'lang' => true,\n\t\t\t'xml:lang' => true,\n\t\t),\n\t\t'br' => array(),\n\t\t'button' => array(\n\t\t\t'disabled' => true,\n\t\t\t'name' => true,\n\t\t\t'type' => true,\n\t\t\t'value' => true,\n\t\t),\n\t\t'caption' => array(\n\t\t\t'align' => true,\n\t\t),\n\t\t'cite' => array(\n\t\t\t'dir' => true,\n\t\t\t'lang' => true,\n\t\t),\n\t\t'code' => array(),\n\t\t'col' => array(\n\t\t\t'align' => true,\n\t\t\t'char' => true,\n\t\t\t'charoff' => true,\n\t\t\t'span' => true,\n\t\t\t'dir' => true,\n\t\t\t'valign' => true,\n\t\t\t'width' => true,\n\t\t),\n\t\t'colgroup' => array(\n\t\t\t'align' => true,\n\t\t\t'char' => true,\n\t\t\t'charoff' => true,\n\t\t\t'span' => true,\n\t\t\t'valign' => true,\n\t\t\t'width' => true,\n\t\t),\n\t\t'del' => array(\n\t\t\t'datetime' => true,\n\t\t),\n\t\t'dd' => array(),\n\t\t'dfn' => array(),\n\t\t'details' => array(\n\t\t\t'align' => true,\n\t\t\t'dir' => true,\n\t\t\t'lang' => true,\n\t\t\t'open' => true,\n\t\t\t'xml:lang' => true,\n\t\t),\n\t\t'div' => array(\n\t\t\t'align' => true,\n\t\t\t'dir' => true,\n\t\t\t'lang' => true,\n\t\t\t'xml:lang' => true,\n\t\t),\n\t\t'dl' => array(),\n\t\t'dt' => array(),\n\t\t'em' => array(),\n\t\t'fieldset' => array(),\n\t\t'figure' => array(\n\t\t\t'align' => true,\n\t\t\t'dir' => true,\n\t\t\t'lang' => true,\n\t\t\t'xml:lang' => true,\n\t\t),\n\t\t'figcaption' => array(\n\t\t\t'align' => true,\n\t\t\t'dir' => true,\n\t\t\t'lang' => true,\n\t\t\t'xml:lang' => true,\n\t\t),\n\t\t'font' => array(\n\t\t\t'color' => true,\n\t\t\t'face' => true,\n\t\t\t'size' => true,\n\t\t),\n\t\t'footer' => array(\n\t\t\t'align' => true,\n\t\t\t'dir' => true,\n\t\t\t'lang' => true,\n\t\t\t'xml:lang' => true,\n\t\t),\n\t\t'h1' => array(\n\t\t\t'align' => true,\n\t\t),\n\t\t'h2' => array(\n\t\t\t'align' => true,\n\t\t),\n\t\t'h3' => array(\n\t\t\t'align' => true,\n\t\t),\n\t\t'h4' => array(\n\t\t\t'align' => true,\n\t\t),\n\t\t'h5' => array(\n\t\t\t'align' => true,\n\t\t),\n\t\t'h6' => array(\n\t\t\t'align' => true,\n\t\t),\n\t\t'header' => array(\n\t\t\t'align' => true,\n\t\t\t'dir' => true,\n\t\t\t'lang' => true,\n\t\t\t'xml:lang' => true,\n\t\t),\n\t\t'hgroup' => array(\n\t\t\t'align' => true,\n\t\t\t'dir' => true,\n\t\t\t'lang' => true,\n\t\t\t'xml:lang' => true,\n\t\t),\n\t\t'hr' => array(\n\t\t\t'align' => true,\n\t\t\t'noshade' => true,\n\t\t\t'size' => true,\n\t\t\t'width' => true,\n\t\t),\n\t\t'i' => array(),\n\t\t'img' => array(\n\t\t\t'alt' => true,\n\t\t\t'align' => true,\n\t\t\t'border' => true,\n\t\t\t'height' => true,\n\t\t\t'hspace' => true,\n\t\t\t'longdesc' => true,\n\t\t\t'vspace' => true,\n\t\t\t'src' => true,\n\t\t\t'usemap' => true,\n\t\t\t'width' => true,\n\t\t),\n\t\t'ins' => array(\n\t\t\t'datetime' => true,\n\t\t\t'cite' => true,\n\t\t),\n\t\t'kbd' => array(),\n\t\t'label' => array(\n\t\t\t'for' => true,\n\t\t),\n\t\t'legend' => array(\n\t\t\t'align' => true,\n\t\t),\n\t\t'li' => array(\n\t\t\t'align' => true,\n\t\t\t'value' => true,\n\t\t),\n\t\t'map' => array(\n\t\t\t'name' => true,\n\t\t),\n\t\t'mark' => array(),\n\t\t'menu' => array(\n\t\t\t'type' => true,\n\t\t),\n\t\t'nav' => array(\n\t\t\t'align' => true,\n\t\t\t'dir' => true,\n\t\t\t'lang' => true,\n\t\t\t'xml:lang' => true,\n\t\t),\n\t\t'p' => array(\n\t\t\t'align' => true,\n\t\t\t'dir' => true,\n\t\t\t'lang' => true,\n\t\t\t'xml:lang' => true,\n\t\t),\n\t\t'pre' => array(\n\t\t\t'width' => true,\n\t\t),\n\t\t'q' => array(\n\t\t\t'cite' => true,\n\t\t),\n\t\t's' => array(),\n\t\t'samp' => array(),\n\t\t'span' => array(\n\t\t\t'dir' => true,\n\t\t\t'align' => true,\n\t\t\t'lang' => true,\n\t\t\t'xml:lang' => true,\n\t\t),\n\t\t'section' => array(\n\t\t\t'align' => true,\n\t\t\t'dir' => true,\n\t\t\t'lang' => true,\n\t\t\t'xml:lang' => true,\n\t\t),\n\t\t'small' => array(),\n\t\t'strike' => array(),\n\t\t'strong' => array(),\n\t\t'sub' => array(),\n\t\t'summary' => array(\n\t\t\t'align' => true,\n\t\t\t'dir' => true,\n\t\t\t'lang' => true,\n\t\t\t'xml:lang' => true,\n\t\t),\n\t\t'sup' => array(),\n\t\t'table' => array(\n\t\t\t'align' => true,\n\t\t\t'bgcolor' => true,\n\t\t\t'border' => true,\n\t\t\t'cellpadding' => true,\n\t\t\t'cellspacing' => true,\n\t\t\t'dir' => true,\n\t\t\t'rules' => true,\n\t\t\t'summary' => true,\n\t\t\t'width' => true,\n\t\t),\n\t\t'tbody' => array(\n\t\t\t'align' => true,\n\t\t\t'char' => true,\n\t\t\t'charoff' => true,\n\t\t\t'valign' => true,\n\t\t),\n\t\t'td' => array(\n\t\t\t'abbr' => true,\n\t\t\t'align' => true,\n\t\t\t'axis' => true,\n\t\t\t'bgcolor' => true,\n\t\t\t'char' => true,\n\t\t\t'charoff' => true,\n\t\t\t'colspan' => true,\n\t\t\t'dir' => true,\n\t\t\t'headers' => true,\n\t\t\t'height' => true,\n\t\t\t'nowrap' => true,\n\t\t\t'rowspan' => true,\n\t\t\t'scope' => true,\n\t\t\t'valign' => true,\n\t\t\t'width' => true,\n\t\t),\n\t\t'textarea' => array(\n\t\t\t'cols' => true,\n\t\t\t'rows' => true,\n\t\t\t'disabled' => true,\n\t\t\t'name' => true,\n\t\t\t'readonly' => true,\n\t\t),\n\t\t'tfoot' => array(\n\t\t\t'align' => true,\n\t\t\t'char' => true,\n\t\t\t'charoff' => true,\n\t\t\t'valign' => true,\n\t\t),\n\t\t'th' => array(\n\t\t\t'abbr' => true,\n\t\t\t'align' => true,\n\t\t\t'axis' => true,\n\t\t\t'bgcolor' => true,\n\t\t\t'char' => true,\n\t\t\t'charoff' => true,\n\t\t\t'colspan' => true,\n\t\t\t'headers' => true,\n\t\t\t'height' => true,\n\t\t\t'nowrap' => true,\n\t\t\t'rowspan' => true,\n\t\t\t'scope' => true,\n\t\t\t'valign' => true,\n\t\t\t'width' => true,\n\t\t),\n\t\t'thead' => array(\n\t\t\t'align' => true,\n\t\t\t'char' => true,\n\t\t\t'charoff' => true,\n\t\t\t'valign' => true,\n\t\t),\n\t\t'title' => array(),\n\t\t'tr' => array(\n\t\t\t'align' => true,\n\t\t\t'bgcolor' => true,\n\t\t\t'char' => true,\n\t\t\t'charoff' => true,\n\t\t\t'valign' => true,\n\t\t),\n\t\t'track' => array(\n\t\t\t'default' => true,\n\t\t\t'kind' => true,\n\t\t\t'label' => true,\n\t\t\t'src' => true,\n\t\t\t'srclang' => true,\n\t\t),\n\t\t'tt' => array(),\n\t\t'u' => array(),\n\t\t'ul' => array(\n\t\t\t'type' => true,\n\t\t),\n\t\t'ol' => array(\n\t\t\t'start' => true,\n\t\t\t'type' => true,\n\t\t\t'reversed' => true,\n\t\t),\n\t\t'var' => array(),\n\t\t'video' => array(\n\t\t\t'autoplay' => true,\n\t\t\t'controls' => true,\n\t\t\t'height' => true,\n\t\t\t'loop' => true,\n\t\t\t'muted' => true,\n\t\t\t'poster' => true,\n\t\t\t'preload' => true,\n\t\t\t'src' => true,\n\t\t\t'width' => true,\n\t\t),\n\t);\n\n\t/**\n\t * Kses allowed HTML elements.\n\t *\n\t * @global array $allowedtags\n\t * @since 1.0.0\n\t */\n\t$allowedtags = array(\n\t\t'a' => array(\n\t\t\t'href' => true,\n\t\t\t'title' => true,\n\t\t),\n\t\t'abbr' => array(\n\t\t\t'title' => true,\n\t\t),\n\t\t'acronym' => array(\n\t\t\t'title' => true,\n\t\t),\n\t\t'b' => array(),\n\t\t'blockquote' => array(\n\t\t\t'cite' => true,\n\t\t),\n\t\t'cite' => array(),\n\t\t'code' => array(),\n\t\t'del' => array(\n\t\t\t'datetime' => true,\n\t\t),\n\t\t'em' => array(),\n\t\t'i' => array(),\n\t\t'q' => array(\n\t\t\t'cite' => true,\n\t\t),\n\t\t's' => array(),\n\t\t'strike' => array(),\n\t\t'strong' => array(),\n\t);\n\n\t$allowedentitynames = array(\n\t\t'nbsp',    'iexcl',  'cent',    'pound',  'curren', 'yen',\n\t\t'brvbar',  'sect',   'uml',     'copy',   'ordf',   'laquo',\n\t\t'not',     'shy',    'reg',     'macr',   'deg',    'plusmn',\n\t\t'acute',   'micro',  'para',    'middot', 'cedil',  'ordm',\n\t\t'raquo',   'iquest', 'Agrave',  'Aacute', 'Acirc',  'Atilde',\n\t\t'Auml',    'Aring',  'AElig',   'Ccedil', 'Egrave', 'Eacute',\n\t\t'Ecirc',   'Euml',   'Igrave',  'Iacute', 'Icirc',  'Iuml',\n\t\t'ETH',     'Ntilde', 'Ograve',  'Oacute', 'Ocirc',  'Otilde',\n\t\t'Ouml',    'times',  'Oslash',  'Ugrave', 'Uacute', 'Ucirc',\n\t\t'Uuml',    'Yacute', 'THORN',   'szlig',  'agrave', 'aacute',\n\t\t'acirc',   'atilde', 'auml',    'aring',  'aelig',  'ccedil',\n\t\t'egrave',  'eacute', 'ecirc',   'euml',   'igrave', 'iacute',\n\t\t'icirc',   'iuml',   'eth',     'ntilde', 'ograve', 'oacute',\n\t\t'ocirc',   'otilde', 'ouml',    'divide', 'oslash', 'ugrave',\n\t\t'uacute',  'ucirc',  'uuml',    'yacute', 'thorn',  'yuml',\n\t\t'quot',    'amp',    'lt',      'gt',     'apos',   'OElig',\n\t\t'oelig',   'Scaron', 'scaron',  'Yuml',   'circ',   'tilde',\n\t\t'ensp',    'emsp',   'thinsp',  'zwnj',   'zwj',    'lrm',\n\t\t'rlm',     'ndash',  'mdash',   'lsquo',  'rsquo',  'sbquo',\n\t\t'ldquo',   'rdquo',  'bdquo',   'dagger', 'Dagger', 'permil',\n\t\t'lsaquo',  'rsaquo', 'euro',    'fnof',   'Alpha',  'Beta',\n\t\t'Gamma',   'Delta',  'Epsilon', 'Zeta',   'Eta',    'Theta',\n\t\t'Iota',    'Kappa',  'Lambda',  'Mu',     'Nu',     'Xi',\n\t\t'Omicron', 'Pi',     'Rho',     'Sigma',  'Tau',    'Upsilon',\n\t\t'Phi',     'Chi',    'Psi',     'Omega',  'alpha',  'beta',\n\t\t'gamma',   'delta',  'epsilon', 'zeta',   'eta',    'theta',\n\t\t'iota',    'kappa',  'lambda',  'mu',     'nu',     'xi',\n\t\t'omicron', 'pi',     'rho',     'sigmaf', 'sigma',  'tau',\n\t\t'upsilon', 'phi',    'chi',     'psi',    'omega',  'thetasym',\n\t\t'upsih',   'piv',    'bull',    'hellip', 'prime',  'Prime',\n\t\t'oline',   'frasl',  'weierp',  'image',  'real',   'trade',\n\t\t'alefsym', 'larr',   'uarr',    'rarr',   'darr',   'harr',\n\t\t'crarr',   'lArr',   'uArr',    'rArr',   'dArr',   'hArr',\n\t\t'forall',  'part',   'exist',   'empty',  'nabla',  'isin',\n\t\t'notin',   'ni',     'prod',    'sum',    'minus',  'lowast',\n\t\t'radic',   'prop',   'infin',   'ang',    'and',    'or',\n\t\t'cap',     'cup',    'int',     'sim',    'cong',   'asymp',\n\t\t'ne',      'equiv',  'le',      'ge',     'sub',    'sup',\n\t\t'nsub',    'sube',   'supe',    'oplus',  'otimes', 'perp',\n\t\t'sdot',    'lceil',  'rceil',   'lfloor', 'rfloor', 'lang',\n\t\t'rang',    'loz',    'spades',  'clubs',  'hearts', 'diams',\n\t\t'sup1',    'sup2',   'sup3',    'frac14', 'frac12', 'frac34',\n\t\t'there4',\n\t);\n\n\t$allowedposttags = array_map( '_wp_add_global_attributes', $allowedposttags );\n} else {\n\t$allowedtags = wp_kses_array_lc( $allowedtags );\n\t$allowedposttags = wp_kses_array_lc( $allowedposttags );\n}\n\n/**\n * Filters content and keeps only allowable HTML elements.\n *\n * This function makes sure that only the allowed HTML element names, attribute\n * names and attribute values plus only sane HTML entities will occur in\n * $string. You have to remove any slashes from PHP's magic quotes before you\n * call this function.\n *\n * The default allowed protocols are 'http', 'https', 'ftp', 'mailto', 'news',\n * 'irc', 'gopher', 'nntp', 'feed', 'telnet, 'mms', 'rtsp' and 'svn'. This\n * covers all common link protocols, except for 'javascript' which should not\n * be allowed for untrusted users.\n *\n * @since 1.0.0\n *\n * @param string $string            Content to filter through kses\n * @param array  $allowed_html      List of allowed HTML elements\n * @param array  $allowed_protocols Optional. Allowed protocol in links.\n * @return string Filtered content with only allowed HTML elements\n */\nfunction wp_kses( $string, $allowed_html, $allowed_protocols = array() ) {\n\tif ( empty( $allowed_protocols ) )\n\t\t$allowed_protocols = wp_allowed_protocols();\n\t$string = wp_kses_no_null( $string, array( 'slash_zero' => 'keep' ) );\n\t$string = wp_kses_normalize_entities($string);\n\t$string = wp_kses_hook($string, $allowed_html, $allowed_protocols); // WP changed the order of these funcs and added args to wp_kses_hook\n\treturn wp_kses_split($string, $allowed_html, $allowed_protocols);\n}\n\n/**\n * Filters one attribute only and ensures its value is allowed.\n *\n * This function has the advantage of being more secure than esc_attr() and can\n * escape data in some situations where wp_kses() must strip the whole attribute.\n *\n * @since 4.2.3\n *\n * @param string $string The 'whole' attribute, including name and value.\n * @param string $element The element name to which the attribute belongs.\n * @return string Filtered attribute.\n */\nfunction wp_kses_one_attr( $string, $element ) {\n\t$uris = array('xmlns', 'profile', 'href', 'src', 'cite', 'classid', 'codebase', 'data', 'usemap', 'longdesc', 'action');\n\t$allowed_html = wp_kses_allowed_html( 'post' );\n\t$allowed_protocols = wp_allowed_protocols();\n\t$string = wp_kses_no_null( $string, array( 'slash_zero' => 'keep' ) );\n\t\n\t// Preserve leading and trailing whitespace.\n\t$matches = array();\n\tpreg_match('/^\\s*/', $string, $matches);\n\t$lead = $matches[0];\n\tpreg_match('/\\s*$/', $string, $matches);\n\t$trail = $matches[0];\n\tif ( empty( $trail ) ) {\n\t\t$string = substr( $string, strlen( $lead ) );\n\t} else {\n\t\t$string = substr( $string, strlen( $lead ), -strlen( $trail ) );\n\t}\n\t\n\t// Parse attribute name and value from input.\n\t$split = preg_split( '/\\s*=\\s*/', $string, 2 );\n\t$name = $split[0];\n\tif ( count( $split ) == 2 ) {\n\t\t$value = $split[1];\n\n\t\t// Remove quotes surrounding $value.\n\t\t// Also guarantee correct quoting in $string for this one attribute.\n\t\tif ( '' == $value ) {\n\t\t\t$quote = '';\n\t\t} else {\n\t\t\t$quote = $value[0];\n\t\t}\n\t\tif ( '\"' == $quote || \"'\" == $quote ) {\n\t\t\tif ( substr( $value, -1 ) != $quote ) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\t$value = substr( $value, 1, -1 );\n\t\t} else {\n\t\t\t$quote = '\"';\n\t\t}\n\n\t\t// Sanitize quotes, angle braces, and entities.\n\t\t$value = esc_attr( $value );\n\n\t\t// Sanitize URI values.\n\t\tif ( in_array( strtolower( $name ), $uris ) ) {\n\t\t\t$value = wp_kses_bad_protocol( $value, $allowed_protocols );\n\t\t}\n\n\t\t$string = \"$name=$quote$value$quote\";\n\t\t$vless = 'n';\n\t} else {\n\t\t$value = '';\n\t\t$vless = 'y';\n\t}\n\t\n\t// Sanitize attribute by name.\n\twp_kses_attr_check( $name, $value, $string, $vless, $element, $allowed_html );\n\n\t// Restore whitespace.\n\treturn $lead . $string . $trail;\n}\n\n/**\n * Return a list of allowed tags and attributes for a given context.\n *\n * @since 3.5.0\n * @since 5.0.1 `form` removed as allowable HTML tag.\n *\n * @global array $allowedposttags\n * @global array $allowedtags\n * @global array $allowedentitynames\n *\n * @param string|array $context The context for which to retrieve tags.\n *                              Allowed values are post, strip, data, entities, or\n *                              the name of a field filter such as pre_user_description.\n * @return array List of allowed tags and their allowed attributes.\n */\nfunction wp_kses_allowed_html( $context = '' ) {\n\tglobal $allowedposttags, $allowedtags, $allowedentitynames;\n\n\tif ( is_array( $context ) ) {\n\t\t/**\n\t\t * Filters HTML elements allowed for a given context.\n\t\t *\n\t\t * @since 3.5.0\n\t\t *\n\t\t * @param array  $context      Context to judge allowed tags by.\n\t\t * @param string $context_type Context type (explicit).\n\t\t */\n\t\treturn apply_filters( 'wp_kses_allowed_html', $context, 'explicit' );\n\t}\n\n\tswitch ( $context ) {\n\t\tcase 'post':\n\t\t\t/** This filter is documented in wp-includes/kses.php */\n\t\t\t$tags = apply_filters( 'wp_kses_allowed_html', $allowedposttags, $context );\n\n\t\t\t// 5.0.1 removed the `<form>` tag, allow it if a filter is allowing it's sub-elements `<input>` or `<select>`.\n\t\t\tif ( ! CUSTOM_TAGS && ! isset( $tags['form'] ) && ( isset( $tags['input'] ) || isset( $tags['select'] ) ) ) {\n\t\t\t\t$tags = $allowedposttags;\n\n\t\t\t\t$tags['form'] = array(\n\t\t\t\t\t'action' => true,\n\t\t\t\t\t'accept' => true,\n\t\t\t\t\t'accept-charset' => true,\n\t\t\t\t\t'enctype' => true,\n\t\t\t\t\t'method' => true,\n\t\t\t\t\t'name' => true,\n\t\t\t\t\t'target' => true,\n\t\t\t\t);\n\n\t\t\t\t/** This filter is documented in wp-includes/kses.php */\n\t\t\t\t$tags = apply_filters( 'wp_kses_allowed_html', $tags, $context );\n\t\t\t}\n\n\t\t\treturn $tags;\n\n\t\tcase 'user_description':\n\t\tcase 'pre_user_description':\n\t\t\t$tags = $allowedtags;\n\t\t\t$tags['a']['rel'] = true;\n\t\t\t/** This filter is documented in wp-includes/kses.php */\n\t\t\treturn apply_filters( 'wp_kses_allowed_html', $tags, $context );\n\n\t\tcase 'strip':\n\t\t\t/** This filter is documented in wp-includes/kses.php */\n\t\t\treturn apply_filters( 'wp_kses_allowed_html', array(), $context );\n\n\t\tcase 'entities':\n\t\t\t/** This filter is documented in wp-includes/kses.php */\n\t\t\treturn apply_filters( 'wp_kses_allowed_html', $allowedentitynames, $context);\n\n\t\tcase 'data':\n\t\tdefault:\n\t\t\t/** This filter is documented in wp-includes/kses.php */\n\t\t\treturn apply_filters( 'wp_kses_allowed_html', $allowedtags, $context );\n\t}\n}\n\n/**\n * You add any kses hooks here.\n *\n * There is currently only one kses WordPress hook, {@see 'pre_kses'}, and it is called here.\n * All parameters are passed to the hooks and expected to receive a string.\n *\n * @since 1.0.0\n *\n * @param string $string            Content to filter through kses\n * @param array  $allowed_html      List of allowed HTML elements\n * @param array  $allowed_protocols Allowed protocol in links\n * @return string Filtered content through {@see 'pre_kses'} hook.\n */\nfunction wp_kses_hook( $string, $allowed_html, $allowed_protocols ) {\n\t/**\n\t * Filters content to be run through kses.\n\t *\n\t * @since 2.3.0\n\t *\n\t * @param string $string            Content to run through kses.\n\t * @param array  $allowed_html      Allowed HTML elements.\n\t * @param array  $allowed_protocols Allowed protocol in links.\n\t */\n\treturn apply_filters( 'pre_kses', $string, $allowed_html, $allowed_protocols );\n}\n\n/**\n * This function returns kses' version number.\n *\n * @since 1.0.0\n *\n * @return string KSES Version Number\n */\nfunction wp_kses_version() {\n\treturn '0.2.2';\n}\n\n/**\n * Searches for HTML tags, no matter how malformed.\n *\n * It also matches stray \">\" characters.\n *\n * @since 1.0.0\n *\n * @global array $pass_allowed_html\n * @global array $pass_allowed_protocols\n *\n * @param string $string            Content to filter\n * @param array  $allowed_html      Allowed HTML elements\n * @param array  $allowed_protocols Allowed protocols to keep\n * @return string Content with fixed HTML tags\n */\nfunction wp_kses_split( $string, $allowed_html, $allowed_protocols ) {\n\tglobal $pass_allowed_html, $pass_allowed_protocols;\n\t$pass_allowed_html = $allowed_html;\n\t$pass_allowed_protocols = $allowed_protocols;\n\treturn preg_replace_callback( '%(<!--.*?(-->|$))|(<[^>]*(>|$)|>)%', '_wp_kses_split_callback', $string );\n}\n\n/**\n * Callback for wp_kses_split.\n *\n * @since 3.1.0\n * @access private\n *\n * @global array $pass_allowed_html\n * @global array $pass_allowed_protocols\n *\n * @return string\n */\nfunction _wp_kses_split_callback( $match ) {\n\tglobal $pass_allowed_html, $pass_allowed_protocols;\n\treturn wp_kses_split2( $match[0], $pass_allowed_html, $pass_allowed_protocols );\n}\n\n/**\n * Callback for wp_kses_split for fixing malformed HTML tags.\n *\n * This function does a lot of work. It rejects some very malformed things like\n * <:::>. It returns an empty string, if the element isn't allowed (look ma, no\n * strip_tags()!). Otherwise it splits the tag into an element and an attribute\n * list.\n *\n * After the tag is split into an element and an attribute list, it is run\n * through another filter which will remove illegal attributes and once that is\n * completed, will be returned.\n *\n * @access private\n * @since 1.0.0\n *\n * @param string $string            Content to filter\n * @param array  $allowed_html      Allowed HTML elements\n * @param array  $allowed_protocols Allowed protocols to keep\n * @return string Fixed HTML element\n */\nfunction wp_kses_split2($string, $allowed_html, $allowed_protocols) {\n\t$string = wp_kses_stripslashes($string);\n\n\tif (substr($string, 0, 1) != '<')\n\t\treturn '&gt;';\n\t// It matched a \">\" character\n\n\tif ( '<!--' == substr( $string, 0, 4 ) ) {\n\t\t$string = str_replace( array('<!--', '-->'), '', $string );\n\t\twhile ( $string != ($newstring = wp_kses($string, $allowed_html, $allowed_protocols)) )\n\t\t\t$string = $newstring;\n\t\tif ( $string == '' )\n\t\t\treturn '';\n\t\t// prevent multiple dashes in comments\n\t\t$string = preg_replace('/--+/', '-', $string);\n\t\t// prevent three dashes closing a comment\n\t\t$string = preg_replace('/-$/', '', $string);\n\t\treturn \"<!--{$string}-->\";\n\t}\n\t// Allow HTML comments\n\n\tif (!preg_match('%^<\\s*(/\\s*)?([a-zA-Z0-9-]+)([^>]*)>?$%', $string, $matches))\n\t\treturn '';\n\t// It's seriously malformed\n\n\t$slash = trim($matches[1]);\n\t$elem = $matches[2];\n\t$attrlist = $matches[3];\n\n\tif ( ! is_array( $allowed_html ) )\n\t\t$allowed_html = wp_kses_allowed_html( $allowed_html );\n\n\tif ( ! isset($allowed_html[strtolower($elem)]) )\n\t\treturn '';\n\t// They are using a not allowed HTML element\n\n\tif ($slash != '')\n\t\treturn \"</$elem>\";\n\t// No attributes are allowed for closing elements\n\n\treturn wp_kses_attr( $elem, $attrlist, $allowed_html, $allowed_protocols );\n}\n\n/**\n * Removes all attributes, if none are allowed for this element.\n *\n * If some are allowed it calls wp_kses_hair() to split them further, and then\n * it builds up new HTML code from the data that kses_hair() returns. It also\n * removes \"<\" and \">\" characters, if there are any left. One more thing it does\n * is to check if the tag has a closing XHTML slash, and if it does, it puts one\n * in the returned code as well.\n *\n * @since 1.0.0\n *\n * @param string $element           HTML element/tag\n * @param string $attr              HTML attributes from HTML element to closing HTML element tag\n * @param array  $allowed_html      Allowed HTML elements\n * @param array  $allowed_protocols Allowed protocols to keep\n * @return string Sanitized HTML element\n */\nfunction wp_kses_attr($element, $attr, $allowed_html, $allowed_protocols) {\n\tif ( ! is_array( $allowed_html ) )\n\t\t$allowed_html = wp_kses_allowed_html( $allowed_html );\n\n\t// Is there a closing XHTML slash at the end of the attributes?\n\t$xhtml_slash = '';\n\tif (preg_match('%\\s*/\\s*$%', $attr))\n\t\t$xhtml_slash = ' /';\n\n\t// Are any attributes allowed at all for this element?\n\t$element_low = strtolower( $element );\n\tif ( empty( $allowed_html[ $element_low ] ) || true === $allowed_html[ $element_low ] ) {\n\t\treturn \"<$element$xhtml_slash>\";\n\t}\n\n\t// Split it\n\t$attrarr = wp_kses_hair($attr, $allowed_protocols);\n\n\t// Go through $attrarr, and save the allowed attributes for this element\n\t// in $attr2\n\t$attr2 = '';\n\tforeach ( $attrarr as $arreach ) {\n\t\tif ( wp_kses_attr_check( $arreach['name'], $arreach['value'], $arreach['whole'], $arreach['vless'], $element, $allowed_html ) ) {\n\t\t\t$attr2 .= ' '.$arreach['whole'];\n\t\t}\n\t}\n\n\t// Remove any \"<\" or \">\" characters\n\t$attr2 = preg_replace('/[<>]/', '', $attr2);\n\n\treturn \"<$element$attr2$xhtml_slash>\";\n}\n\n/**\n * Determine whether an attribute is allowed.\n *\n * @since 4.2.3\n * @since 5.0.0 Add support for `data-*` wildcard attributes.\n *\n * @param string $name The attribute name. Returns empty string when not allowed.\n * @param string $value The attribute value. Returns a filtered value.\n * @param string $whole The name=value input. Returns filtered input.\n * @param string $vless 'y' when attribute like \"enabled\", otherwise 'n'.\n * @param string $element The name of the element to which this attribute belongs.\n * @param array $allowed_html The full list of allowed elements and attributes.\n * @return bool Is the attribute allowed?\n */\nfunction wp_kses_attr_check( &$name, &$value, &$whole, $vless, $element, $allowed_html ) {\n\t$allowed_attr = $allowed_html[ strtolower( $element ) ];\n\n\t$name_low = strtolower( $name );\n\n\tif ( ! isset( $allowed_attr[$name_low] ) || '' == $allowed_attr[$name_low] ) {\n\t\t/*\n\t\t * Allow `data-*` attributes.\n\t\t *\n\t\t * When specifying `$allowed_html`, the attribute name should be set as\n\t\t * `data-*` (not to be mixed with the HTML 4.0 `data` attribute, see\n\t\t * https://www.w3.org/TR/html40/struct/objects.html#adef-data).\n\t\t *\n\t\t * Note: the attribute name should only contain `A-Za-z0-9_-` chars,\n\t\t * double hyphens `--` are not accepted by WordPress.\n\t\t */\n\t\tif ( strpos( $name_low, 'data-' ) === 0 && ! empty( $allowed_attr['data-*'] ) && preg_match( '/^data(?:-[a-z0-9_]+)+$/', $name_low, $match ) ) {\n\t\t\t/*\n\t\t\t * Add the whole attribute name to the allowed attributes and set any restrictions\n\t\t\t * for the `data-*` attribute values for the current element.\n\t\t\t */\n\t\t\t$allowed_attr[ $match[0] ] = $allowed_attr['data-*'];\n\t\t} else {\n\t\t\t$name = $value = $whole = '';\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif ( 'style' == $name_low ) {\n\t\t$new_value = safecss_filter_attr( $value );\n\n\t\tif ( empty( $new_value ) ) {\n\t\t\t$name = $value = $whole = '';\n\t\t\treturn false;\n\t\t}\n\n\t\t$whole = str_replace( $value, $new_value, $whole );\n\t\t$value = $new_value;\n\t}\n\n\tif ( is_array( $allowed_attr[ $name_low ] ) ) {\n\t\t// there are some checks\n\t\tforeach ( $allowed_attr[$name_low] as $currkey => $currval ) {\n\t\t\tif ( ! wp_kses_check_attr_val( $value, $vless, $currkey, $currval ) ) {\n\t\t\t\t$name = $value = $whole = '';\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * Builds an attribute list from string containing attributes.\n *\n * This function does a lot of work. It parses an attribute list into an array\n * with attribute data, and tries to do the right thing even if it gets weird\n * input. It will add quotes around attribute values that don't have any quotes\n * or apostrophes around them, to make it easier to produce HTML code that will\n * conform to W3C's HTML specification. It will also remove bad URL protocols\n * from attribute values. It also reduces duplicate attributes by using the\n * attribute defined first (foo='bar' foo='baz' will result in foo='bar').\n *\n * @since 1.0.0\n *\n * @param string $attr              Attribute list from HTML element to closing HTML element tag\n * @param array  $allowed_protocols Allowed protocols to keep\n * @return array List of attributes after parsing\n */\nfunction wp_kses_hair($attr, $allowed_protocols) {\n\t$attrarr = array();\n\t$mode = 0;\n\t$attrname = '';\n\t$uris = array('xmlns', 'profile', 'href', 'src', 'cite', 'classid', 'codebase', 'data', 'usemap', 'longdesc', 'action');\n\n\t// Loop through the whole attribute list\n\n\twhile (strlen($attr) != 0) {\n\t\t$working = 0; // Was the last operation successful?\n\n\t\tswitch ($mode) {\n\t\t\tcase 0 : // attribute name, href for instance\n\n\t\t\t\tif ( preg_match('/^([-a-zA-Z:]+)/', $attr, $match ) ) {\n\t\t\t\t\t$attrname = $match[1];\n\t\t\t\t\t$working = $mode = 1;\n\t\t\t\t\t$attr = preg_replace( '/^[-a-zA-Z:]+/', '', $attr );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 1 : // equals sign or valueless (\"selected\")\n\n\t\t\t\tif (preg_match('/^\\s*=\\s*/', $attr)) // equals sign\n\t\t\t\t\t{\n\t\t\t\t\t$working = 1;\n\t\t\t\t\t$mode = 2;\n\t\t\t\t\t$attr = preg_replace('/^\\s*=\\s*/', '', $attr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (preg_match('/^\\s+/', $attr)) // valueless\n\t\t\t\t\t{\n\t\t\t\t\t$working = 1;\n\t\t\t\t\t$mode = 0;\n\t\t\t\t\tif(false === array_key_exists($attrname, $attrarr)) {\n\t\t\t\t\t\t$attrarr[$attrname] = array ('name' => $attrname, 'value' => '', 'whole' => $attrname, 'vless' => 'y');\n\t\t\t\t\t}\n\t\t\t\t\t$attr = preg_replace('/^\\s+/', '', $attr);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 2 : // attribute value, a URL after href= for instance\n\n\t\t\t\tif (preg_match('%^\"([^\"]*)\"(\\s+|/?$)%', $attr, $match))\n\t\t\t\t\t// \"value\"\n\t\t\t\t\t{\n\t\t\t\t\t$thisval = $match[1];\n\t\t\t\t\tif ( in_array(strtolower($attrname), $uris) )\n\t\t\t\t\t\t$thisval = wp_kses_bad_protocol($thisval, $allowed_protocols);\n\n\t\t\t\t\tif(false === array_key_exists($attrname, $attrarr)) {\n\t\t\t\t\t\t$attrarr[$attrname] = array ('name' => $attrname, 'value' => $thisval, 'whole' => \"$attrname=\\\"$thisval\\\"\", 'vless' => 'n');\n\t\t\t\t\t}\n\t\t\t\t\t$working = 1;\n\t\t\t\t\t$mode = 0;\n\t\t\t\t\t$attr = preg_replace('/^\"[^\"]*\"(\\s+|$)/', '', $attr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (preg_match(\"%^'([^']*)'(\\s+|/?$)%\", $attr, $match))\n\t\t\t\t\t// 'value'\n\t\t\t\t\t{\n\t\t\t\t\t$thisval = $match[1];\n\t\t\t\t\tif ( in_array(strtolower($attrname), $uris) )\n\t\t\t\t\t\t$thisval = wp_kses_bad_protocol($thisval, $allowed_protocols);\n\n\t\t\t\t\tif(false === array_key_exists($attrname, $attrarr)) {\n\t\t\t\t\t\t$attrarr[$attrname] = array ('name' => $attrname, 'value' => $thisval, 'whole' => \"$attrname='$thisval'\", 'vless' => 'n');\n\t\t\t\t\t}\n\t\t\t\t\t$working = 1;\n\t\t\t\t\t$mode = 0;\n\t\t\t\t\t$attr = preg_replace(\"/^'[^']*'(\\s+|$)/\", '', $attr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (preg_match(\"%^([^\\s\\\"']+)(\\s+|/?$)%\", $attr, $match))\n\t\t\t\t\t// value\n\t\t\t\t\t{\n\t\t\t\t\t$thisval = $match[1];\n\t\t\t\t\tif ( in_array(strtolower($attrname), $uris) )\n\t\t\t\t\t\t$thisval = wp_kses_bad_protocol($thisval, $allowed_protocols);\n\n\t\t\t\t\tif(false === array_key_exists($attrname, $attrarr)) {\n\t\t\t\t\t\t$attrarr[$attrname] = array ('name' => $attrname, 'value' => $thisval, 'whole' => \"$attrname=\\\"$thisval\\\"\", 'vless' => 'n');\n\t\t\t\t\t}\n\t\t\t\t\t// We add quotes to conform to W3C's HTML spec.\n\t\t\t\t\t$working = 1;\n\t\t\t\t\t$mode = 0;\n\t\t\t\t\t$attr = preg_replace(\"%^[^\\s\\\"']+(\\s+|$)%\", '', $attr);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t} // switch\n\n\t\tif ($working == 0) // not well formed, remove and try again\n\t\t{\n\t\t\t$attr = wp_kses_html_error($attr);\n\t\t\t$mode = 0;\n\t\t}\n\t} // while\n\n\tif ($mode == 1 && false === array_key_exists($attrname, $attrarr))\n\t\t// special case, for when the attribute list ends with a valueless\n\t\t// attribute like \"selected\"\n\t\t$attrarr[$attrname] = array ('name' => $attrname, 'value' => '', 'whole' => $attrname, 'vless' => 'y');\n\n\treturn $attrarr;\n}\n\n/**\n * Finds all attributes of an HTML element.\n *\n * Does not modify input.  May return \"evil\" output.\n *\n * Based on wp_kses_split2() and wp_kses_attr()\n *\n * @since 4.2.3\n *\n * @param string $element HTML element/tag\n * @return array|bool List of attributes found in $element. Returns false on failure.\n */\nfunction wp_kses_attr_parse( $element ) {\n\t$valid = preg_match('%^(<\\s*)(/\\s*)?([a-zA-Z0-9]+\\s*)([^>]*)(>?)$%', $element, $matches);\n\tif ( 1 !== $valid ) {\n\t\treturn false;\n\t}\n\n\t$begin =  $matches[1];\n\t$slash =  $matches[2];\n\t$elname = $matches[3];\n\t$attr =   $matches[4];\n\t$end =    $matches[5];\n\n\tif ( '' !== $slash ) {\n\t\t// Closing elements do not get parsed.\n\t\treturn false;\n\t}\n\n\t// Is there a closing XHTML slash at the end of the attributes?\n\tif ( 1 === preg_match( '%\\s*/\\s*$%', $attr, $matches ) ) {\n\t\t$xhtml_slash = $matches[0];\n\t\t$attr = substr( $attr, 0, -strlen( $xhtml_slash ) );\n\t} else {\n\t\t$xhtml_slash = '';\n\t}\n\t\n\t// Split it\n\t$attrarr = wp_kses_hair_parse( $attr );\n\tif ( false === $attrarr ) {\n\t\treturn false;\n\t}\n\n\t// Make sure all input is returned by adding front and back matter.\n\tarray_unshift( $attrarr, $begin . $slash . $elname );\n\tarray_push( $attrarr, $xhtml_slash . $end );\n\t\n\treturn $attrarr;\n}\n\n/**\n * Builds an attribute list from string containing attributes.\n *\n * Does not modify input.  May return \"evil\" output.\n * In case of unexpected input, returns false instead of stripping things.\n *\n * Based on wp_kses_hair() but does not return a multi-dimensional array.\n *\n * @since 4.2.3\n *\n * @param string $attr Attribute list from HTML element to closing HTML element tag\n * @return array|bool List of attributes found in $attr. Returns false on failure.\n */\nfunction wp_kses_hair_parse( $attr ) {\n\tif ( '' === $attr ) {\n\t\treturn array();\n\t}\n\n\t$regex =\n\t  '(?:'\n\t.     '[-a-zA-Z:]+'   // Attribute name.\n\t. '|'\n\t.     '\\[\\[?[^\\[\\]]+\\]\\]?' // Shortcode in the name position implies unfiltered_html.\n\t. ')'\n\t. '(?:'               // Attribute value.\n\t.     '\\s*=\\s*'       // All values begin with '='\n\t.     '(?:'\n\t.         '\"[^\"]*\"'   // Double-quoted\n\t.     '|'\n\t.         \"'[^']*'\"   // Single-quoted\n\t.     '|'\n\t.         '[^\\s\"\\']+' // Non-quoted\n\t.         '(?:\\s|$)'  // Must have a space\n\t.     ')'\n\t. '|'\n\t.     '(?:\\s|$)'      // If attribute has no value, space is required.\n\t. ')'\n\t. '\\s*';              // Trailing space is optional except as mentioned above.\n\n\t// Although it is possible to reduce this procedure to a single regexp,\n\t// we must run that regexp twice to get exactly the expected result.\n\n\t$validation = \"%^($regex)+$%\";\n\t$extraction = \"%$regex%\";\n\n\tif ( 1 === preg_match( $validation, $attr ) ) {\n\t\tpreg_match_all( $extraction, $attr, $attrarr );\n\t\treturn $attrarr[0];\n\t} else {\n\t\treturn false;\n\t}\n}\n\n/**\n * Performs different checks for attribute values.\n *\n * The currently implemented checks are \"maxlen\", \"minlen\", \"maxval\", \"minval\"\n * and \"valueless\".\n *\n * @since 1.0.0\n *\n * @param string $value      Attribute value\n * @param string $vless      Whether the value is valueless. Use 'y' or 'n'\n * @param string $checkname  What $checkvalue is checking for.\n * @param mixed  $checkvalue What constraint the value should pass\n * @return bool Whether check passes\n */\nfunction wp_kses_check_attr_val($value, $vless, $checkname, $checkvalue) {\n\t$ok = true;\n\n\tswitch (strtolower($checkname)) {\n\t\tcase 'maxlen' :\n\t\t\t// The maxlen check makes sure that the attribute value has a length not\n\t\t\t// greater than the given value. This can be used to avoid Buffer Overflows\n\t\t\t// in WWW clients and various Internet servers.\n\n\t\t\tif (strlen($value) > $checkvalue)\n\t\t\t\t$ok = false;\n\t\t\tbreak;\n\n\t\tcase 'minlen' :\n\t\t\t// The minlen check makes sure that the attribute value has a length not\n\t\t\t// smaller than the given value.\n\n\t\t\tif (strlen($value) < $checkvalue)\n\t\t\t\t$ok = false;\n\t\t\tbreak;\n\n\t\tcase 'maxval' :\n\t\t\t// The maxval check does two things: it checks that the attribute value is\n\t\t\t// an integer from 0 and up, without an excessive amount of zeroes or\n\t\t\t// whitespace (to avoid Buffer Overflows). It also checks that the attribute\n\t\t\t// value is not greater than the given value.\n\t\t\t// This check can be used to avoid Denial of Service attacks.\n\n\t\t\tif (!preg_match('/^\\s{0,6}[0-9]{1,6}\\s{0,6}$/', $value))\n\t\t\t\t$ok = false;\n\t\t\tif ($value > $checkvalue)\n\t\t\t\t$ok = false;\n\t\t\tbreak;\n\n\t\tcase 'minval' :\n\t\t\t// The minval check makes sure that the attribute value is a positive integer,\n\t\t\t// and that it is not smaller than the given value.\n\n\t\t\tif (!preg_match('/^\\s{0,6}[0-9]{1,6}\\s{0,6}$/', $value))\n\t\t\t\t$ok = false;\n\t\t\tif ($value < $checkvalue)\n\t\t\t\t$ok = false;\n\t\t\tbreak;\n\n\t\tcase 'valueless' :\n\t\t\t// The valueless check makes sure if the attribute has a value\n\t\t\t// (like <a href=\"blah\">) or not (<option selected>). If the given value\n\t\t\t// is a \"y\" or a \"Y\", the attribute must not have a value.\n\t\t\t// If the given value is an \"n\" or an \"N\", the attribute must have one.\n\n\t\t\tif (strtolower($checkvalue) != $vless)\n\t\t\t\t$ok = false;\n\t\t\tbreak;\n\t} // switch\n\n\treturn $ok;\n}\n\n/**\n * Sanitize string from bad protocols.\n *\n * This function removes all non-allowed protocols from the beginning of\n * $string. It ignores whitespace and the case of the letters, and it does\n * understand HTML entities. It does its work in a while loop, so it won't be\n * fooled by a string like \"javascript:javascript:alert(57)\".\n *\n * @since 1.0.0\n *\n * @param string $string            Content to filter bad protocols from\n * @param array  $allowed_protocols Allowed protocols to keep\n * @return string Filtered content\n */\nfunction wp_kses_bad_protocol($string, $allowed_protocols) {\n\t$string = wp_kses_no_null($string);\n\t$iterations = 0;\n\n\tdo {\n\t\t$original_string = $string;\n\t\t$string = wp_kses_bad_protocol_once($string, $allowed_protocols);\n\t} while ( $original_string != $string && ++$iterations < 6 );\n\n\tif ( $original_string != $string )\n\t\treturn '';\n\n\treturn $string;\n}\n\n/**\n * Removes any invalid control characters in $string.\n *\n * Also removes any instance of the '\\0' string.\n *\n * @since 1.0.0\n *\n * @param string $string\n * @param array $options Set 'slash_zero' => 'keep' when '\\0' is allowed. Default is 'remove'.\n * @return string\n */\nfunction wp_kses_no_null( $string, $options = null ) {\n\tif ( ! isset( $options['slash_zero'] ) ) {\n\t\t$options = array( 'slash_zero' => 'remove' );\n\t}\n\n\t$string = preg_replace( '/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F]/', '', $string );\n\tif ( 'remove' == $options['slash_zero'] ) {\n\t\t$string = preg_replace( '/\\\\\\\\+0+/', '', $string );\n\t}\n\n\treturn $string;\n}\n\n/**\n * Strips slashes from in front of quotes.\n *\n * This function changes the character sequence \\\" to just \". It leaves all\n * other slashes alone. It's really weird, but the quoting from\n * preg_replace(//e) seems to require this.\n *\n * @since 1.0.0\n *\n * @param string $string String to strip slashes\n * @return string Fixed string with quoted slashes\n */\nfunction wp_kses_stripslashes($string) {\n\treturn preg_replace('%\\\\\\\\\"%', '\"', $string);\n}\n\n/**\n * Goes through an array and changes the keys to all lower case.\n *\n * @since 1.0.0\n *\n * @param array $inarray Unfiltered array\n * @return array Fixed array with all lowercase keys\n */\nfunction wp_kses_array_lc($inarray) {\n\t$outarray = array ();\n\n\tforeach ( (array) $inarray as $inkey => $inval) {\n\t\t$outkey = strtolower($inkey);\n\t\t$outarray[$outkey] = array ();\n\n\t\tforeach ( (array) $inval as $inkey2 => $inval2) {\n\t\t\t$outkey2 = strtolower($inkey2);\n\t\t\t$outarray[$outkey][$outkey2] = $inval2;\n\t\t} // foreach $inval\n\t} // foreach $inarray\n\n\treturn $outarray;\n}\n\n/**\n * Handles parsing errors in wp_kses_hair().\n *\n * The general plan is to remove everything to and including some whitespace,\n * but it deals with quotes and apostrophes as well.\n *\n * @since 1.0.0\n *\n * @param string $string\n * @return string\n */\nfunction wp_kses_html_error($string) {\n\treturn preg_replace('/^(\"[^\"]*(\"|$)|\\'[^\\']*(\\'|$)|\\S)*\\s*/', '', $string);\n}\n\n/**\n * Sanitizes content from bad protocols and other characters.\n *\n * This function searches for URL protocols at the beginning of $string, while\n * handling whitespace and HTML entities.\n *\n * @since 1.0.0\n *\n * @param string $string            Content to check for bad protocols\n * @param string $allowed_protocols Allowed protocols\n * @return string Sanitized content\n */\nfunction wp_kses_bad_protocol_once($string, $allowed_protocols, $count = 1 ) {\n\t$string2 = preg_split( '/:|&#0*58;|&#x0*3a;/i', $string, 2 );\n\tif ( isset($string2[1]) && ! preg_match('%/\\?%', $string2[0]) ) {\n\t\t$string = trim( $string2[1] );\n\t\t$protocol = wp_kses_bad_protocol_once2( $string2[0], $allowed_protocols );\n\t\tif ( 'feed:' == $protocol ) {\n\t\t\tif ( $count > 2 )\n\t\t\t\treturn '';\n\t\t\t$string = wp_kses_bad_protocol_once( $string, $allowed_protocols, ++$count );\n\t\t\tif ( empty( $string ) )\n\t\t\t\treturn $string;\n\t\t}\n\t\t$string = $protocol . $string;\n\t}\n\n\treturn $string;\n}\n\n/**\n * Callback for wp_kses_bad_protocol_once() regular expression.\n *\n * This function processes URL protocols, checks to see if they're in the\n * whitelist or not, and returns different data depending on the answer.\n *\n * @access private\n * @since 1.0.0\n *\n * @param string $string            URI scheme to check against the whitelist\n * @param string $allowed_protocols Allowed protocols\n * @return string Sanitized content\n */\nfunction wp_kses_bad_protocol_once2( $string, $allowed_protocols ) {\n\t$string2 = wp_kses_decode_entities($string);\n\t$string2 = preg_replace('/\\s/', '', $string2);\n\t$string2 = wp_kses_no_null($string2);\n\t$string2 = strtolower($string2);\n\n\t$allowed = false;\n\tforeach ( (array) $allowed_protocols as $one_protocol )\n\t\tif ( strtolower($one_protocol) == $string2 ) {\n\t\t\t$allowed = true;\n\t\t\tbreak;\n\t\t}\n\n\tif ($allowed)\n\t\treturn \"$string2:\";\n\telse\n\t\treturn '';\n}\n\n/**\n * Converts and fixes HTML entities.\n *\n * This function normalizes HTML entities. It will convert `AT&T` to the correct\n * `AT&amp;T`, `&#00058;` to `&#58;`, `&#XYZZY;` to `&amp;#XYZZY;` and so on.\n *\n * @since 1.0.0\n *\n * @param string $string Content to normalize entities\n * @return string Content with normalized entities\n */\nfunction wp_kses_normalize_entities($string) {\n\t// Disarm all entities by converting & to &amp;\n\t$string = str_replace('&', '&amp;', $string);\n\n\t// Change back the allowed entities in our entity whitelist\n\t$string = preg_replace_callback('/&amp;([A-Za-z]{2,8}[0-9]{0,2});/', 'wp_kses_named_entities', $string);\n\t$string = preg_replace_callback('/&amp;#(0*[0-9]{1,7});/', 'wp_kses_normalize_entities2', $string);\n\t$string = preg_replace_callback('/&amp;#[Xx](0*[0-9A-Fa-f]{1,6});/', 'wp_kses_normalize_entities3', $string);\n\n\treturn $string;\n}\n\n/**\n * Callback for wp_kses_normalize_entities() regular expression.\n *\n * This function only accepts valid named entity references, which are finite,\n * case-sensitive, and highly scrutinized by HTML and XML validators.\n *\n * @since 3.0.0\n *\n * @global array $allowedentitynames\n *\n * @param array $matches preg_replace_callback() matches array\n * @return string Correctly encoded entity\n */\nfunction wp_kses_named_entities($matches) {\n\tglobal $allowedentitynames;\n\n\tif ( empty($matches[1]) )\n\t\treturn '';\n\n\t$i = $matches[1];\n\treturn ( ! in_array( $i, $allowedentitynames ) ) ? \"&amp;$i;\" : \"&$i;\";\n}\n\n/**\n * Callback for wp_kses_normalize_entities() regular expression.\n *\n * This function helps wp_kses_normalize_entities() to only accept 16-bit\n * values and nothing more for `&#number;` entities.\n *\n * @access private\n * @since 1.0.0\n *\n * @param array $matches preg_replace_callback() matches array\n * @return string Correctly encoded entity\n */\nfunction wp_kses_normalize_entities2($matches) {\n\tif ( empty($matches[1]) )\n\t\treturn '';\n\n\t$i = $matches[1];\n\tif (valid_unicode($i)) {\n\t\t$i = str_pad(ltrim($i,'0'), 3, '0', STR_PAD_LEFT);\n\t\t$i = \"&#$i;\";\n\t} else {\n\t\t$i = \"&amp;#$i;\";\n\t}\n\n\treturn $i;\n}\n\n/**\n * Callback for wp_kses_normalize_entities() for regular expression.\n *\n * This function helps wp_kses_normalize_entities() to only accept valid Unicode\n * numeric entities in hex form.\n *\n * @since 2.7.0\n * @access private\n *\n * @param array $matches preg_replace_callback() matches array\n * @return string Correctly encoded entity\n */\nfunction wp_kses_normalize_entities3($matches) {\n\tif ( empty($matches[1]) )\n\t\treturn '';\n\n\t$hexchars = $matches[1];\n\treturn ( ! valid_unicode( hexdec( $hexchars ) ) ) ? \"&amp;#x$hexchars;\" : '&#x'.ltrim($hexchars,'0').';';\n}\n\n/**\n * Helper function to determine if a Unicode value is valid.\n *\n * @since 2.7.0\n *\n * @param int $i Unicode value\n * @return bool True if the value was a valid Unicode number\n */\nfunction valid_unicode($i) {\n\treturn ( $i == 0x9 || $i == 0xa || $i == 0xd ||\n\t\t\t($i >= 0x20 && $i <= 0xd7ff) ||\n\t\t\t($i >= 0xe000 && $i <= 0xfffd) ||\n\t\t\t($i >= 0x10000 && $i <= 0x10ffff) );\n}\n\n/**\n * Convert all entities to their character counterparts.\n *\n * This function decodes numeric HTML entities (`&#65;` and `&#x41;`).\n * It doesn't do anything with other entities like &auml;, but we don't\n * need them in the URL protocol whitelisting system anyway.\n *\n * @since 1.0.0\n *\n * @param string $string Content to change entities\n * @return string Content after decoded entities\n */\nfunction wp_kses_decode_entities($string) {\n\t$string = preg_replace_callback('/&#([0-9]+);/', '_wp_kses_decode_entities_chr', $string);\n\t$string = preg_replace_callback('/&#[Xx]([0-9A-Fa-f]+);/', '_wp_kses_decode_entities_chr_hexdec', $string);\n\n\treturn $string;\n}\n\n/**\n * Regex callback for wp_kses_decode_entities()\n *\n * @since 2.9.0\n *\n * @param array $match preg match\n * @return string\n */\nfunction _wp_kses_decode_entities_chr( $match ) {\n\treturn chr( $match[1] );\n}\n\n/**\n * Regex callback for wp_kses_decode_entities()\n *\n * @since 2.9.0\n *\n * @param array $match preg match\n * @return string\n */\nfunction _wp_kses_decode_entities_chr_hexdec( $match ) {\n\treturn chr( hexdec( $match[1] ) );\n}\n\n/**\n * Sanitize content with allowed HTML Kses rules.\n *\n * @since 1.0.0\n *\n * @param string $data Content to filter, expected to be escaped with slashes\n * @return string Filtered content\n */\nfunction wp_filter_kses( $data ) {\n\treturn addslashes( wp_kses( stripslashes( $data ), current_filter() ) );\n}\n\n/**\n * Sanitize content with allowed HTML Kses rules.\n *\n * @since 2.9.0\n *\n * @param string $data Content to filter, expected to not be escaped\n * @return string Filtered content\n */\nfunction wp_kses_data( $data ) {\n\treturn wp_kses( $data, current_filter() );\n}\n\n/**\n * Sanitize content for allowed HTML tags for post content.\n *\n * Post content refers to the page contents of the 'post' type and not $_POST\n * data from forms.\n *\n * @since 2.0.0\n *\n * @param string $data Post content to filter, expected to be escaped with slashes\n * @return string Filtered post content with allowed HTML tags and attributes intact.\n */\nfunction wp_filter_post_kses( $data ) {\n\treturn addslashes( wp_kses( stripslashes( $data ), 'post' ) );\n}\n\n/**\n * Sanitize content for allowed HTML tags for post content.\n *\n * Post content refers to the page contents of the 'post' type and not $_POST\n * data from forms.\n *\n * @since 2.9.0\n *\n * @param string $data Post content to filter\n * @return string Filtered post content with allowed HTML tags and attributes intact.\n */\nfunction wp_kses_post( $data ) {\n\treturn wp_kses( $data, 'post' );\n}\n\n/**\n * Navigates through an array, object, or scalar, and sanitizes content for\n * allowed HTML tags for post content.\n *\n * @since 4.4.2\n *\n * @see map_deep()\n *\n * @param mixed $data The array, object, or scalar value to inspect.\n * @return mixed The filtered content.\n */\nfunction wp_kses_post_deep( $data ) {\n\treturn map_deep( $data, 'wp_kses_post' );\n}\n\n/**\n * Strips all of the HTML in the content.\n *\n * @since 2.1.0\n *\n * @param string $data Content to strip all HTML from\n * @return string Filtered content without any HTML\n */\nfunction wp_filter_nohtml_kses( $data ) {\n\treturn addslashes( wp_kses( stripslashes( $data ), 'strip' ) );\n}\n\n/**\n * Adds all Kses input form content filters.\n *\n * All hooks have default priority. The wp_filter_kses() function is added to\n * the 'pre_comment_content' and 'title_save_pre' hooks.\n *\n * The wp_filter_post_kses() function is added to the 'content_save_pre',\n * 'excerpt_save_pre', and 'content_filtered_save_pre' hooks.\n *\n * @since 2.0.0\n */\nfunction kses_init_filters() {\n\t// Normal filtering\n\tadd_filter('title_save_pre', 'wp_filter_kses');\n\n\t// Comment filtering\n\tif ( current_user_can( 'unfiltered_html' ) )\n\t\tadd_filter( 'pre_comment_content', 'wp_filter_post_kses' );\n\telse\n\t\tadd_filter( 'pre_comment_content', 'wp_filter_kses' );\n\n\t// Post filtering\n\tadd_filter('content_save_pre', 'wp_filter_post_kses');\n\tadd_filter('excerpt_save_pre', 'wp_filter_post_kses');\n\tadd_filter('content_filtered_save_pre', 'wp_filter_post_kses');\n}\n\n/**\n * Removes all Kses input form content filters.\n *\n * A quick procedural method to removing all of the filters that kses uses for\n * content in WordPress Loop.\n *\n * Does not remove the kses_init() function from {@see 'init'} hook (priority is\n * default). Also does not remove kses_init() function from {@see 'set_current_user'}\n * hook (priority is also default).\n *\n * @since 2.0.6\n */\nfunction kses_remove_filters() {\n\t// Normal filtering\n\tremove_filter('title_save_pre', 'wp_filter_kses');\n\n\t// Comment filtering\n\tremove_filter( 'pre_comment_content', 'wp_filter_post_kses' );\n\tremove_filter( 'pre_comment_content', 'wp_filter_kses' );\n\n\t// Post filtering\n\tremove_filter('content_save_pre', 'wp_filter_post_kses');\n\tremove_filter('excerpt_save_pre', 'wp_filter_post_kses');\n\tremove_filter('content_filtered_save_pre', 'wp_filter_post_kses');\n}\n\n/**\n * Sets up most of the Kses filters for input form content.\n *\n * If you remove the kses_init() function from {@see 'init'} hook and\n * {@see 'set_current_user'} (priority is default), then none of the Kses filter hooks\n * will be added.\n *\n * First removes all of the Kses filters in case the current user does not need\n * to have Kses filter the content. If the user does not have unfiltered_html\n * capability, then Kses filters are added.\n *\n * @since 2.0.0\n */\nfunction kses_init() {\n\tkses_remove_filters();\n\n\tif ( ! current_user_can( 'unfiltered_html' ) ) {\n\t\tkses_init_filters();\n\t}\n}\n\n/**\n * Inline CSS filter\n *\n * @since 2.8.1\n *\n * @param string $css        A string of CSS rules.\n * @param string $deprecated Not used.\n * @return string            Filtered string of CSS rules.\n */\nfunction safecss_filter_attr( $css, $deprecated = '' ) {\n\tif ( ! empty( $deprecated ) ) {\n\t\t_deprecated_argument( __FUNCTION__, '2.8.1' ); // Never implemented\n\t}\n\n\t$css = wp_kses_no_null( $css );\n\t$css = str_replace( array( \"\\n\", \"\\r\", \"\\t\" ), '', $css );\n\n\t$allowed_protocols = wp_allowed_protocols();\n\n\t$css_array = explode( ';', trim( $css ) );\n\n\t/**\n\t * Filters list of allowed CSS attributes.\n\t *\n\t * @since 2.8.1\n\t * @since 4.4.0 Added support for `min-height`, `max-height`, `min-width`, and `max-width`.\n\t * @since 4.6.0 Added support for `list-style-type`.\n\t * @since 5.0.0 Added support for `background-image`.\n\t *\n\t * @param array $attr List of allowed CSS attributes.\n\t */\n\t$allowed_attr = apply_filters( 'safe_style_css', array(\n\t\t'background',\n\t\t'background-color',\n\t\t'background-image',\n\n\t\t'border',\n\t\t'border-width',\n\t\t'border-color',\n\t\t'border-style',\n\t\t'border-right',\n\t\t'border-right-color',\n\t\t'border-right-style',\n\t\t'border-right-width',\n\t\t'border-bottom',\n\t\t'border-bottom-color',\n\t\t'border-bottom-style',\n\t\t'border-bottom-width',\n\t\t'border-left',\n\t\t'border-left-color',\n\t\t'border-left-style',\n\t\t'border-left-width',\n\t\t'border-top',\n\t\t'border-top-color',\n\t\t'border-top-style',\n\t\t'border-top-width',\n\n\t\t'border-spacing',\n\t\t'border-collapse',\n\t\t'caption-side',\n\n\t\t'color',\n\t\t'font',\n\t\t'font-family',\n\t\t'font-size',\n\t\t'font-style',\n\t\t'font-variant',\n\t\t'font-weight',\n\t\t'letter-spacing',\n\t\t'line-height',\n\t\t'text-decoration',\n\t\t'text-indent',\n\t\t'text-align',\n\n\t\t'height',\n\t\t'min-height',\n\t\t'max-height',\n\n\t\t'width',\n\t\t'min-width',\n\t\t'max-width',\n\n\t\t'margin',\n\t\t'margin-right',\n\t\t'margin-bottom',\n\t\t'margin-left',\n\t\t'margin-top',\n\n\t\t'padding',\n\t\t'padding-right',\n\t\t'padding-bottom',\n\t\t'padding-left',\n\t\t'padding-top',\n\n\t\t'clear',\n\t\t'cursor',\n\t\t'direction',\n\t\t'float',\n\t\t'overflow',\n\t\t'vertical-align',\n\t\t'list-style-type',\n\t) );\n\n\n\t/*\n\t * CSS attributes that accept URL data types.\n\t *\n\t * This is in accordance to the CSS spec and unrelated to\n\t * the sub-set of supported attributes above.\n\t *\n\t * See: https://developer.mozilla.org/en-US/docs/Web/CSS/url\n\t */\n\t$css_url_data_types = array(\n\t\t'background',\n\t\t'background-image',\n\n\t\t'cursor',\n\n\t\t'list-style',\n\t\t'list-style-image',\n\t);\n\n\tif ( empty( $allowed_attr ) ) {\n\t\treturn $css;\n\t}\n\n\t$css = '';\n\tforeach ( $css_array as $css_item ) {\n\t\tif ( $css_item == '' ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t$css_item        = trim( $css_item );\n\t\t$css_test_string = $css_item;\n\t\t$found           = false;\n\t\t$url_attr        = false;\n\n\t\tif ( strpos( $css_item, ':' ) === false ) {\n\t\t\t$found = true;\n\t\t} else {\n\t\t\t$parts = explode( ':', $css_item, 2 );\n\t\t\t$css_selector = trim( $parts[0] );\n\n\t\t\tif ( in_array( $css_selector, $allowed_attr, true ) ) {\n\t\t\t\t$found = true;\n\t\t\t\t$url_attr = in_array( $css_selector, $css_url_data_types, true );\n\t\t\t}\n\t\t}\n\n\t\tif ( $found && $url_attr ) {\n\t\t\t// Simplified: matches the sequence `url(*)`.\n\t\t\tpreg_match_all( '/url\\([^)]+\\)/', $parts[1], $url_matches );\n\n\t\t\tforeach ( $url_matches[0] as $url_match ) {\n\t\t\t\t// Clean up the URL from each of the matches above.\n\t\t\t\tpreg_match( '/^url\\(\\s*([\\'\\\"]?)(.*)(\\g1)\\s*\\)$/', $url_match, $url_pieces );\n\n\t\t\t\tif ( empty( $url_pieces[2] ) ) {\n\t\t\t\t\t$found = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t$url = trim( $url_pieces[2] );\n\n\t\t\t\tif ( empty( $url ) || $url !== wp_kses_bad_protocol( $url, $allowed_protocols ) ) {\n\t\t\t\t\t$found = false;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t// Remove the whole `url(*)` bit that was matched above from the CSS.\n\t\t\t\t\t$css_test_string = str_replace( $url_match, '', $css_test_string );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Remove any CSS containing containing \\ ( & } = or comments, except for url() useage checked above.\n\t\tif ( $found && ! preg_match( '%[\\\\\\(&=}]|/\\*%', $css_test_string ) ) {\n\t\t\tif ( $css != '' ) {\n\t\t\t\t$css .= ';';\n\t\t\t}\n\n\t\t\t$css .= $css_item;\n\t\t}\n\t}\n\n\treturn $css;\n}\n\n/**\n * Helper function to add global attributes to a tag in the allowed html list.\n *\n * @since 3.5.0\n * @since 5.0.0 Add support for `data-*` wildcard attributes.\n * @access private\n *\n * @param array $value An array of attributes.\n * @return array The array of attributes with global attributes added.\n */\nfunction _wp_add_global_attributes( $value ) {\n\t$global_attributes = array(\n\t\t'aria-describedby' => true,\n\t\t'aria-details' => true,\n\t\t'aria-label' => true,\n\t\t'aria-labelledby' => true,\n\t\t'aria-hidden' => true,\n\t\t'class' => true,\n\t\t'id' => true,\n\t\t'style' => true,\n\t\t'title' => true,\n\t\t'role' => true,\n\t\t'data-*' => true,\n\t);\n\n\tif ( true === $value )\n\t\t$value = array();\n\n\tif ( is_array( $value ) )\n\t\treturn array_merge( $value, $global_attributes );\n\n\treturn $value;\n}\n", "<?php\n/**\n * The WordPress version string\n *\n * @global string $wp_version\n */\n$wp_version = '5.0.1-alpha-43994';\n\n/**\n * Holds the WordPress DB revision, increments when changes are made to the WordPress DB schema.\n *\n * @global int $wp_db_version\n */\n$wp_db_version = 43764;\n\n/**\n * Holds the TinyMCE version\n *\n * @global string $tinymce_version\n */\n$tinymce_version = '4800-20180716';\n\n/**\n * Holds the required PHP version\n *\n * @global string $required_php_version\n */\n$required_php_version = '5.2.4';\n\n/**\n * Holds the required MySQL version\n *\n * @global string $required_mysql_version\n */\n$required_mysql_version = '5.0';\n"], "fixing_code": ["<?php\n/**\n * kses 0.2.2 - HTML/XHTML filter that only allows some elements and attributes\n * Copyright (C) 2002, 2003, 2005  Ulf Harnhammar\n *\n * This program is free software and open source software; you can redistribute\n * it and/or modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the License,\n * or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA\n * http://www.gnu.org/licenses/gpl.html\n *\n * [kses strips evil scripts!]\n *\n * Added wp_ prefix to avoid conflicts with existing kses users\n *\n * @version 0.2.2\n * @copyright (C) 2002, 2003, 2005\n * @author Ulf Harnhammar <http://advogato.org/person/metaur/>\n *\n * @package External\n * @subpackage KSES\n *\n */\n\n/**\n * You can override this in a plugin.\n *\n * The {@see 'wp_kses_allowed_html'} filter is more powerful and supplies context.\n *\n * `CUSTOM_TAGS` is not recommended and should be considered deprecated.\n *\n * @see wp_kses_allowed_html()\n *\n * @since 1.2.0\n */\nif ( ! defined( 'CUSTOM_TAGS' ) )\n\tdefine( 'CUSTOM_TAGS', false );\n\n// Ensure that these variables are added to the global namespace\n// (e.g. if using namespaces / autoload in the current PHP environment).\nglobal $allowedposttags, $allowedtags, $allowedentitynames;\n\nif ( ! CUSTOM_TAGS ) {\n\t/**\n\t * Kses global for default allowable HTML tags.\n\t *\n\t * Can be override by using CUSTOM_TAGS constant.\n\t *\n\t * @global array $allowedposttags\n\t * @since 2.0.0\n\t */\n\t$allowedposttags = array(\n\t\t'address' => array(),\n\t\t'a' => array(\n\t\t\t'href' => true,\n\t\t\t'rel' => true,\n\t\t\t'rev' => true,\n\t\t\t'name' => true,\n\t\t\t'target' => true,\n\t\t\t'download' => array(\n\t\t\t\t'valueless' => 'y',\n\t\t\t),\n\t\t),\n\t\t'abbr' => array(),\n\t\t'acronym' => array(),\n\t\t'area' => array(\n\t\t\t'alt' => true,\n\t\t\t'coords' => true,\n\t\t\t'href' => true,\n\t\t\t'nohref' => true,\n\t\t\t'shape' => true,\n\t\t\t'target' => true,\n\t\t),\n\t\t'article' => array(\n\t\t\t'align' => true,\n\t\t\t'dir' => true,\n\t\t\t'lang' => true,\n\t\t\t'xml:lang' => true,\n\t\t),\n\t\t'aside' => array(\n\t\t\t'align' => true,\n\t\t\t'dir' => true,\n\t\t\t'lang' => true,\n\t\t\t'xml:lang' => true,\n\t\t),\n\t\t'audio' => array(\n\t\t\t'autoplay' => true,\n\t\t\t'controls' => true,\n\t\t\t'loop' => true,\n\t\t\t'muted' => true,\n\t\t\t'preload' => true,\n\t\t\t'src' => true,\n\t\t),\n\t\t'b' => array(),\n\t\t'bdo' => array(\n\t\t\t'dir' => true,\n\t\t),\n\t\t'big' => array(),\n\t\t'blockquote' => array(\n\t\t\t'cite' => true,\n\t\t\t'lang' => true,\n\t\t\t'xml:lang' => true,\n\t\t),\n\t\t'br' => array(),\n\t\t'button' => array(\n\t\t\t'disabled' => true,\n\t\t\t'name' => true,\n\t\t\t'type' => true,\n\t\t\t'value' => true,\n\t\t),\n\t\t'caption' => array(\n\t\t\t'align' => true,\n\t\t),\n\t\t'cite' => array(\n\t\t\t'dir' => true,\n\t\t\t'lang' => true,\n\t\t),\n\t\t'code' => array(),\n\t\t'col' => array(\n\t\t\t'align' => true,\n\t\t\t'char' => true,\n\t\t\t'charoff' => true,\n\t\t\t'span' => true,\n\t\t\t'dir' => true,\n\t\t\t'valign' => true,\n\t\t\t'width' => true,\n\t\t),\n\t\t'colgroup' => array(\n\t\t\t'align' => true,\n\t\t\t'char' => true,\n\t\t\t'charoff' => true,\n\t\t\t'span' => true,\n\t\t\t'valign' => true,\n\t\t\t'width' => true,\n\t\t),\n\t\t'del' => array(\n\t\t\t'datetime' => true,\n\t\t),\n\t\t'dd' => array(),\n\t\t'dfn' => array(),\n\t\t'details' => array(\n\t\t\t'align' => true,\n\t\t\t'dir' => true,\n\t\t\t'lang' => true,\n\t\t\t'open' => true,\n\t\t\t'xml:lang' => true,\n\t\t),\n\t\t'div' => array(\n\t\t\t'align' => true,\n\t\t\t'dir' => true,\n\t\t\t'lang' => true,\n\t\t\t'xml:lang' => true,\n\t\t),\n\t\t'dl' => array(),\n\t\t'dt' => array(),\n\t\t'em' => array(),\n\t\t'fieldset' => array(),\n\t\t'figure' => array(\n\t\t\t'align' => true,\n\t\t\t'dir' => true,\n\t\t\t'lang' => true,\n\t\t\t'xml:lang' => true,\n\t\t),\n\t\t'figcaption' => array(\n\t\t\t'align' => true,\n\t\t\t'dir' => true,\n\t\t\t'lang' => true,\n\t\t\t'xml:lang' => true,\n\t\t),\n\t\t'font' => array(\n\t\t\t'color' => true,\n\t\t\t'face' => true,\n\t\t\t'size' => true,\n\t\t),\n\t\t'footer' => array(\n\t\t\t'align' => true,\n\t\t\t'dir' => true,\n\t\t\t'lang' => true,\n\t\t\t'xml:lang' => true,\n\t\t),\n\t\t'h1' => array(\n\t\t\t'align' => true,\n\t\t),\n\t\t'h2' => array(\n\t\t\t'align' => true,\n\t\t),\n\t\t'h3' => array(\n\t\t\t'align' => true,\n\t\t),\n\t\t'h4' => array(\n\t\t\t'align' => true,\n\t\t),\n\t\t'h5' => array(\n\t\t\t'align' => true,\n\t\t),\n\t\t'h6' => array(\n\t\t\t'align' => true,\n\t\t),\n\t\t'header' => array(\n\t\t\t'align' => true,\n\t\t\t'dir' => true,\n\t\t\t'lang' => true,\n\t\t\t'xml:lang' => true,\n\t\t),\n\t\t'hgroup' => array(\n\t\t\t'align' => true,\n\t\t\t'dir' => true,\n\t\t\t'lang' => true,\n\t\t\t'xml:lang' => true,\n\t\t),\n\t\t'hr' => array(\n\t\t\t'align' => true,\n\t\t\t'noshade' => true,\n\t\t\t'size' => true,\n\t\t\t'width' => true,\n\t\t),\n\t\t'i' => array(),\n\t\t'img' => array(\n\t\t\t'alt' => true,\n\t\t\t'align' => true,\n\t\t\t'border' => true,\n\t\t\t'height' => true,\n\t\t\t'hspace' => true,\n\t\t\t'longdesc' => true,\n\t\t\t'vspace' => true,\n\t\t\t'src' => true,\n\t\t\t'usemap' => true,\n\t\t\t'width' => true,\n\t\t),\n\t\t'ins' => array(\n\t\t\t'datetime' => true,\n\t\t\t'cite' => true,\n\t\t),\n\t\t'kbd' => array(),\n\t\t'label' => array(\n\t\t\t'for' => true,\n\t\t),\n\t\t'legend' => array(\n\t\t\t'align' => true,\n\t\t),\n\t\t'li' => array(\n\t\t\t'align' => true,\n\t\t\t'value' => true,\n\t\t),\n\t\t'map' => array(\n\t\t\t'name' => true,\n\t\t),\n\t\t'mark' => array(),\n\t\t'menu' => array(\n\t\t\t'type' => true,\n\t\t),\n\t\t'nav' => array(\n\t\t\t'align' => true,\n\t\t\t'dir' => true,\n\t\t\t'lang' => true,\n\t\t\t'xml:lang' => true,\n\t\t),\n\t\t'p' => array(\n\t\t\t'align' => true,\n\t\t\t'dir' => true,\n\t\t\t'lang' => true,\n\t\t\t'xml:lang' => true,\n\t\t),\n\t\t'pre' => array(\n\t\t\t'width' => true,\n\t\t),\n\t\t'q' => array(\n\t\t\t'cite' => true,\n\t\t),\n\t\t's' => array(),\n\t\t'samp' => array(),\n\t\t'span' => array(\n\t\t\t'dir' => true,\n\t\t\t'align' => true,\n\t\t\t'lang' => true,\n\t\t\t'xml:lang' => true,\n\t\t),\n\t\t'section' => array(\n\t\t\t'align' => true,\n\t\t\t'dir' => true,\n\t\t\t'lang' => true,\n\t\t\t'xml:lang' => true,\n\t\t),\n\t\t'small' => array(),\n\t\t'strike' => array(),\n\t\t'strong' => array(),\n\t\t'sub' => array(),\n\t\t'summary' => array(\n\t\t\t'align' => true,\n\t\t\t'dir' => true,\n\t\t\t'lang' => true,\n\t\t\t'xml:lang' => true,\n\t\t),\n\t\t'sup' => array(),\n\t\t'table' => array(\n\t\t\t'align' => true,\n\t\t\t'bgcolor' => true,\n\t\t\t'border' => true,\n\t\t\t'cellpadding' => true,\n\t\t\t'cellspacing' => true,\n\t\t\t'dir' => true,\n\t\t\t'rules' => true,\n\t\t\t'summary' => true,\n\t\t\t'width' => true,\n\t\t),\n\t\t'tbody' => array(\n\t\t\t'align' => true,\n\t\t\t'char' => true,\n\t\t\t'charoff' => true,\n\t\t\t'valign' => true,\n\t\t),\n\t\t'td' => array(\n\t\t\t'abbr' => true,\n\t\t\t'align' => true,\n\t\t\t'axis' => true,\n\t\t\t'bgcolor' => true,\n\t\t\t'char' => true,\n\t\t\t'charoff' => true,\n\t\t\t'colspan' => true,\n\t\t\t'dir' => true,\n\t\t\t'headers' => true,\n\t\t\t'height' => true,\n\t\t\t'nowrap' => true,\n\t\t\t'rowspan' => true,\n\t\t\t'scope' => true,\n\t\t\t'valign' => true,\n\t\t\t'width' => true,\n\t\t),\n\t\t'textarea' => array(\n\t\t\t'cols' => true,\n\t\t\t'rows' => true,\n\t\t\t'disabled' => true,\n\t\t\t'name' => true,\n\t\t\t'readonly' => true,\n\t\t),\n\t\t'tfoot' => array(\n\t\t\t'align' => true,\n\t\t\t'char' => true,\n\t\t\t'charoff' => true,\n\t\t\t'valign' => true,\n\t\t),\n\t\t'th' => array(\n\t\t\t'abbr' => true,\n\t\t\t'align' => true,\n\t\t\t'axis' => true,\n\t\t\t'bgcolor' => true,\n\t\t\t'char' => true,\n\t\t\t'charoff' => true,\n\t\t\t'colspan' => true,\n\t\t\t'headers' => true,\n\t\t\t'height' => true,\n\t\t\t'nowrap' => true,\n\t\t\t'rowspan' => true,\n\t\t\t'scope' => true,\n\t\t\t'valign' => true,\n\t\t\t'width' => true,\n\t\t),\n\t\t'thead' => array(\n\t\t\t'align' => true,\n\t\t\t'char' => true,\n\t\t\t'charoff' => true,\n\t\t\t'valign' => true,\n\t\t),\n\t\t'title' => array(),\n\t\t'tr' => array(\n\t\t\t'align' => true,\n\t\t\t'bgcolor' => true,\n\t\t\t'char' => true,\n\t\t\t'charoff' => true,\n\t\t\t'valign' => true,\n\t\t),\n\t\t'track' => array(\n\t\t\t'default' => true,\n\t\t\t'kind' => true,\n\t\t\t'label' => true,\n\t\t\t'src' => true,\n\t\t\t'srclang' => true,\n\t\t),\n\t\t'tt' => array(),\n\t\t'u' => array(),\n\t\t'ul' => array(\n\t\t\t'type' => true,\n\t\t),\n\t\t'ol' => array(\n\t\t\t'start' => true,\n\t\t\t'type' => true,\n\t\t\t'reversed' => true,\n\t\t),\n\t\t'var' => array(),\n\t\t'video' => array(\n\t\t\t'autoplay' => true,\n\t\t\t'controls' => true,\n\t\t\t'height' => true,\n\t\t\t'loop' => true,\n\t\t\t'muted' => true,\n\t\t\t'poster' => true,\n\t\t\t'preload' => true,\n\t\t\t'src' => true,\n\t\t\t'width' => true,\n\t\t),\n\t);\n\n\t/**\n\t * Kses allowed HTML elements.\n\t *\n\t * @global array $allowedtags\n\t * @since 1.0.0\n\t */\n\t$allowedtags = array(\n\t\t'a' => array(\n\t\t\t'href' => true,\n\t\t\t'title' => true,\n\t\t),\n\t\t'abbr' => array(\n\t\t\t'title' => true,\n\t\t),\n\t\t'acronym' => array(\n\t\t\t'title' => true,\n\t\t),\n\t\t'b' => array(),\n\t\t'blockquote' => array(\n\t\t\t'cite' => true,\n\t\t),\n\t\t'cite' => array(),\n\t\t'code' => array(),\n\t\t'del' => array(\n\t\t\t'datetime' => true,\n\t\t),\n\t\t'em' => array(),\n\t\t'i' => array(),\n\t\t'q' => array(\n\t\t\t'cite' => true,\n\t\t),\n\t\t's' => array(),\n\t\t'strike' => array(),\n\t\t'strong' => array(),\n\t);\n\n\t$allowedentitynames = array(\n\t\t'nbsp',    'iexcl',  'cent',    'pound',  'curren', 'yen',\n\t\t'brvbar',  'sect',   'uml',     'copy',   'ordf',   'laquo',\n\t\t'not',     'shy',    'reg',     'macr',   'deg',    'plusmn',\n\t\t'acute',   'micro',  'para',    'middot', 'cedil',  'ordm',\n\t\t'raquo',   'iquest', 'Agrave',  'Aacute', 'Acirc',  'Atilde',\n\t\t'Auml',    'Aring',  'AElig',   'Ccedil', 'Egrave', 'Eacute',\n\t\t'Ecirc',   'Euml',   'Igrave',  'Iacute', 'Icirc',  'Iuml',\n\t\t'ETH',     'Ntilde', 'Ograve',  'Oacute', 'Ocirc',  'Otilde',\n\t\t'Ouml',    'times',  'Oslash',  'Ugrave', 'Uacute', 'Ucirc',\n\t\t'Uuml',    'Yacute', 'THORN',   'szlig',  'agrave', 'aacute',\n\t\t'acirc',   'atilde', 'auml',    'aring',  'aelig',  'ccedil',\n\t\t'egrave',  'eacute', 'ecirc',   'euml',   'igrave', 'iacute',\n\t\t'icirc',   'iuml',   'eth',     'ntilde', 'ograve', 'oacute',\n\t\t'ocirc',   'otilde', 'ouml',    'divide', 'oslash', 'ugrave',\n\t\t'uacute',  'ucirc',  'uuml',    'yacute', 'thorn',  'yuml',\n\t\t'quot',    'amp',    'lt',      'gt',     'apos',   'OElig',\n\t\t'oelig',   'Scaron', 'scaron',  'Yuml',   'circ',   'tilde',\n\t\t'ensp',    'emsp',   'thinsp',  'zwnj',   'zwj',    'lrm',\n\t\t'rlm',     'ndash',  'mdash',   'lsquo',  'rsquo',  'sbquo',\n\t\t'ldquo',   'rdquo',  'bdquo',   'dagger', 'Dagger', 'permil',\n\t\t'lsaquo',  'rsaquo', 'euro',    'fnof',   'Alpha',  'Beta',\n\t\t'Gamma',   'Delta',  'Epsilon', 'Zeta',   'Eta',    'Theta',\n\t\t'Iota',    'Kappa',  'Lambda',  'Mu',     'Nu',     'Xi',\n\t\t'Omicron', 'Pi',     'Rho',     'Sigma',  'Tau',    'Upsilon',\n\t\t'Phi',     'Chi',    'Psi',     'Omega',  'alpha',  'beta',\n\t\t'gamma',   'delta',  'epsilon', 'zeta',   'eta',    'theta',\n\t\t'iota',    'kappa',  'lambda',  'mu',     'nu',     'xi',\n\t\t'omicron', 'pi',     'rho',     'sigmaf', 'sigma',  'tau',\n\t\t'upsilon', 'phi',    'chi',     'psi',    'omega',  'thetasym',\n\t\t'upsih',   'piv',    'bull',    'hellip', 'prime',  'Prime',\n\t\t'oline',   'frasl',  'weierp',  'image',  'real',   'trade',\n\t\t'alefsym', 'larr',   'uarr',    'rarr',   'darr',   'harr',\n\t\t'crarr',   'lArr',   'uArr',    'rArr',   'dArr',   'hArr',\n\t\t'forall',  'part',   'exist',   'empty',  'nabla',  'isin',\n\t\t'notin',   'ni',     'prod',    'sum',    'minus',  'lowast',\n\t\t'radic',   'prop',   'infin',   'ang',    'and',    'or',\n\t\t'cap',     'cup',    'int',     'sim',    'cong',   'asymp',\n\t\t'ne',      'equiv',  'le',      'ge',     'sub',    'sup',\n\t\t'nsub',    'sube',   'supe',    'oplus',  'otimes', 'perp',\n\t\t'sdot',    'lceil',  'rceil',   'lfloor', 'rfloor', 'lang',\n\t\t'rang',    'loz',    'spades',  'clubs',  'hearts', 'diams',\n\t\t'sup1',    'sup2',   'sup3',    'frac14', 'frac12', 'frac34',\n\t\t'there4',\n\t);\n\n\t$allowedposttags = array_map( '_wp_add_global_attributes', $allowedposttags );\n} else {\n\t$allowedtags = wp_kses_array_lc( $allowedtags );\n\t$allowedposttags = wp_kses_array_lc( $allowedposttags );\n}\n\n/**\n * Filters content and keeps only allowable HTML elements.\n *\n * This function makes sure that only the allowed HTML element names, attribute\n * names and attribute values plus only sane HTML entities will occur in\n * $string. You have to remove any slashes from PHP's magic quotes before you\n * call this function.\n *\n * The default allowed protocols are 'http', 'https', 'ftp', 'mailto', 'news',\n * 'irc', 'gopher', 'nntp', 'feed', 'telnet, 'mms', 'rtsp' and 'svn'. This\n * covers all common link protocols, except for 'javascript' which should not\n * be allowed for untrusted users.\n *\n * @since 1.0.0\n *\n * @param string $string            Content to filter through kses\n * @param array  $allowed_html      List of allowed HTML elements\n * @param array  $allowed_protocols Optional. Allowed protocol in links.\n * @return string Filtered content with only allowed HTML elements\n */\nfunction wp_kses( $string, $allowed_html, $allowed_protocols = array() ) {\n\tif ( empty( $allowed_protocols ) )\n\t\t$allowed_protocols = wp_allowed_protocols();\n\t$string = wp_kses_no_null( $string, array( 'slash_zero' => 'keep' ) );\n\t$string = wp_kses_normalize_entities($string);\n\t$string = wp_kses_hook($string, $allowed_html, $allowed_protocols); // WP changed the order of these funcs and added args to wp_kses_hook\n\treturn wp_kses_split($string, $allowed_html, $allowed_protocols);\n}\n\n/**\n * Filters one attribute only and ensures its value is allowed.\n *\n * This function has the advantage of being more secure than esc_attr() and can\n * escape data in some situations where wp_kses() must strip the whole attribute.\n *\n * @since 4.2.3\n *\n * @param string $string The 'whole' attribute, including name and value.\n * @param string $element The element name to which the attribute belongs.\n * @return string Filtered attribute.\n */\nfunction wp_kses_one_attr( $string, $element ) {\n\t$uris = wp_kses_uri_attributes();\n\t$allowed_html = wp_kses_allowed_html( 'post' );\n\t$allowed_protocols = wp_allowed_protocols();\n\t$string = wp_kses_no_null( $string, array( 'slash_zero' => 'keep' ) );\n\t\n\t// Preserve leading and trailing whitespace.\n\t$matches = array();\n\tpreg_match('/^\\s*/', $string, $matches);\n\t$lead = $matches[0];\n\tpreg_match('/\\s*$/', $string, $matches);\n\t$trail = $matches[0];\n\tif ( empty( $trail ) ) {\n\t\t$string = substr( $string, strlen( $lead ) );\n\t} else {\n\t\t$string = substr( $string, strlen( $lead ), -strlen( $trail ) );\n\t}\n\t\n\t// Parse attribute name and value from input.\n\t$split = preg_split( '/\\s*=\\s*/', $string, 2 );\n\t$name = $split[0];\n\tif ( count( $split ) == 2 ) {\n\t\t$value = $split[1];\n\n\t\t// Remove quotes surrounding $value.\n\t\t// Also guarantee correct quoting in $string for this one attribute.\n\t\tif ( '' == $value ) {\n\t\t\t$quote = '';\n\t\t} else {\n\t\t\t$quote = $value[0];\n\t\t}\n\t\tif ( '\"' == $quote || \"'\" == $quote ) {\n\t\t\tif ( substr( $value, -1 ) != $quote ) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\t$value = substr( $value, 1, -1 );\n\t\t} else {\n\t\t\t$quote = '\"';\n\t\t}\n\n\t\t// Sanitize quotes, angle braces, and entities.\n\t\t$value = esc_attr( $value );\n\n\t\t// Sanitize URI values.\n\t\tif ( in_array( strtolower( $name ), $uris ) ) {\n\t\t\t$value = wp_kses_bad_protocol( $value, $allowed_protocols );\n\t\t}\n\n\t\t$string = \"$name=$quote$value$quote\";\n\t\t$vless = 'n';\n\t} else {\n\t\t$value = '';\n\t\t$vless = 'y';\n\t}\n\t\n\t// Sanitize attribute by name.\n\twp_kses_attr_check( $name, $value, $string, $vless, $element, $allowed_html );\n\n\t// Restore whitespace.\n\treturn $lead . $string . $trail;\n}\n\n/**\n * Return a list of allowed tags and attributes for a given context.\n *\n * @since 3.5.0\n * @since 5.0.1 `form` removed as allowable HTML tag.\n *\n * @global array $allowedposttags\n * @global array $allowedtags\n * @global array $allowedentitynames\n *\n * @param string|array $context The context for which to retrieve tags.\n *                              Allowed values are post, strip, data, entities, or\n *                              the name of a field filter such as pre_user_description.\n * @return array List of allowed tags and their allowed attributes.\n */\nfunction wp_kses_allowed_html( $context = '' ) {\n\tglobal $allowedposttags, $allowedtags, $allowedentitynames;\n\n\tif ( is_array( $context ) ) {\n\t\t/**\n\t\t * Filters HTML elements allowed for a given context.\n\t\t *\n\t\t * @since 3.5.0\n\t\t *\n\t\t * @param array  $context      Context to judge allowed tags by.\n\t\t * @param string $context_type Context type (explicit).\n\t\t */\n\t\treturn apply_filters( 'wp_kses_allowed_html', $context, 'explicit' );\n\t}\n\n\tswitch ( $context ) {\n\t\tcase 'post':\n\t\t\t/** This filter is documented in wp-includes/kses.php */\n\t\t\t$tags = apply_filters( 'wp_kses_allowed_html', $allowedposttags, $context );\n\n\t\t\t// 5.0.1 removed the `<form>` tag, allow it if a filter is allowing it's sub-elements `<input>` or `<select>`.\n\t\t\tif ( ! CUSTOM_TAGS && ! isset( $tags['form'] ) && ( isset( $tags['input'] ) || isset( $tags['select'] ) ) ) {\n\t\t\t\t$tags = $allowedposttags;\n\n\t\t\t\t$tags['form'] = array(\n\t\t\t\t\t'action' => true,\n\t\t\t\t\t'accept' => true,\n\t\t\t\t\t'accept-charset' => true,\n\t\t\t\t\t'enctype' => true,\n\t\t\t\t\t'method' => true,\n\t\t\t\t\t'name' => true,\n\t\t\t\t\t'target' => true,\n\t\t\t\t);\n\n\t\t\t\t/** This filter is documented in wp-includes/kses.php */\n\t\t\t\t$tags = apply_filters( 'wp_kses_allowed_html', $tags, $context );\n\t\t\t}\n\n\t\t\treturn $tags;\n\n\t\tcase 'user_description':\n\t\tcase 'pre_user_description':\n\t\t\t$tags = $allowedtags;\n\t\t\t$tags['a']['rel'] = true;\n\t\t\t/** This filter is documented in wp-includes/kses.php */\n\t\t\treturn apply_filters( 'wp_kses_allowed_html', $tags, $context );\n\n\t\tcase 'strip':\n\t\t\t/** This filter is documented in wp-includes/kses.php */\n\t\t\treturn apply_filters( 'wp_kses_allowed_html', array(), $context );\n\n\t\tcase 'entities':\n\t\t\t/** This filter is documented in wp-includes/kses.php */\n\t\t\treturn apply_filters( 'wp_kses_allowed_html', $allowedentitynames, $context);\n\n\t\tcase 'data':\n\t\tdefault:\n\t\t\t/** This filter is documented in wp-includes/kses.php */\n\t\t\treturn apply_filters( 'wp_kses_allowed_html', $allowedtags, $context );\n\t}\n}\n\n/**\n * You add any kses hooks here.\n *\n * There is currently only one kses WordPress hook, {@see 'pre_kses'}, and it is called here.\n * All parameters are passed to the hooks and expected to receive a string.\n *\n * @since 1.0.0\n *\n * @param string $string            Content to filter through kses\n * @param array  $allowed_html      List of allowed HTML elements\n * @param array  $allowed_protocols Allowed protocol in links\n * @return string Filtered content through {@see 'pre_kses'} hook.\n */\nfunction wp_kses_hook( $string, $allowed_html, $allowed_protocols ) {\n\t/**\n\t * Filters content to be run through kses.\n\t *\n\t * @since 2.3.0\n\t *\n\t * @param string $string            Content to run through kses.\n\t * @param array  $allowed_html      Allowed HTML elements.\n\t * @param array  $allowed_protocols Allowed protocol in links.\n\t */\n\treturn apply_filters( 'pre_kses', $string, $allowed_html, $allowed_protocols );\n}\n\n/**\n * This function returns kses' version number.\n *\n * @since 1.0.0\n *\n * @return string KSES Version Number\n */\nfunction wp_kses_version() {\n\treturn '0.2.2';\n}\n\n/**\n * Searches for HTML tags, no matter how malformed.\n *\n * It also matches stray \">\" characters.\n *\n * @since 1.0.0\n *\n * @global array $pass_allowed_html\n * @global array $pass_allowed_protocols\n *\n * @param string $string            Content to filter\n * @param array  $allowed_html      Allowed HTML elements\n * @param array  $allowed_protocols Allowed protocols to keep\n * @return string Content with fixed HTML tags\n */\nfunction wp_kses_split( $string, $allowed_html, $allowed_protocols ) {\n\tglobal $pass_allowed_html, $pass_allowed_protocols;\n\t$pass_allowed_html = $allowed_html;\n\t$pass_allowed_protocols = $allowed_protocols;\n\treturn preg_replace_callback( '%(<!--.*?(-->|$))|(<[^>]*(>|$)|>)%', '_wp_kses_split_callback', $string );\n}\n\n/**\n * Helper function listing HTML attributes containing a URL.\n *\n * This function returns a list of all HTML attributes that must contain\n * a URL according to the HTML specification.\n *\n * This list includes URI attributes both allowed and disallowed by KSES.\n *\n * @link https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\n *\n * @since 4.9.9\n *\n * @return array HTML attributes that must include a URL.\n */\nfunction wp_kses_uri_attributes() {\n\t$uri_attributes = array(\n\t\t'action',\n\t\t'archive',\n\t\t'background',\n\t\t'cite',\n\t\t'classid',\n\t\t'codebase',\n\t\t'data',\n\t\t'formaction',\n\t\t'href',\n\t\t'icon',\n\t\t'longdesc',\n\t\t'manifest',\n\t\t'poster',\n\t\t'profile',\n\t\t'src',\n\t\t'usemap',\n\t\t'xmlns',\n\t);\n\n\t/**\n\t * Filters the list of attributes that are required to contain a URL.\n\t *\n\t * Use this filter to add any `data-` attributes that are required to be\n\t * validated as a URL.\n\t *\n\t * @since 4.9.9\n\t *\n\t * @param array $uri_attributes HTML attributes requiring validation as a URL.\n\t */\n\t$uri_attributes = apply_filters( 'wp_kses_uri_attributes', $uri_attributes );\n\n\treturn $uri_attributes;\n}\n\n/**\n * Callback for wp_kses_split.\n *\n * @since 3.1.0\n * @access private\n *\n * @global array $pass_allowed_html\n * @global array $pass_allowed_protocols\n *\n * @return string\n */\nfunction _wp_kses_split_callback( $match ) {\n\tglobal $pass_allowed_html, $pass_allowed_protocols;\n\treturn wp_kses_split2( $match[0], $pass_allowed_html, $pass_allowed_protocols );\n}\n\n/**\n * Callback for wp_kses_split for fixing malformed HTML tags.\n *\n * This function does a lot of work. It rejects some very malformed things like\n * <:::>. It returns an empty string, if the element isn't allowed (look ma, no\n * strip_tags()!). Otherwise it splits the tag into an element and an attribute\n * list.\n *\n * After the tag is split into an element and an attribute list, it is run\n * through another filter which will remove illegal attributes and once that is\n * completed, will be returned.\n *\n * @access private\n * @since 1.0.0\n *\n * @param string $string            Content to filter\n * @param array  $allowed_html      Allowed HTML elements\n * @param array  $allowed_protocols Allowed protocols to keep\n * @return string Fixed HTML element\n */\nfunction wp_kses_split2($string, $allowed_html, $allowed_protocols) {\n\t$string = wp_kses_stripslashes($string);\n\n\tif (substr($string, 0, 1) != '<')\n\t\treturn '&gt;';\n\t// It matched a \">\" character\n\n\tif ( '<!--' == substr( $string, 0, 4 ) ) {\n\t\t$string = str_replace( array('<!--', '-->'), '', $string );\n\t\twhile ( $string != ($newstring = wp_kses($string, $allowed_html, $allowed_protocols)) )\n\t\t\t$string = $newstring;\n\t\tif ( $string == '' )\n\t\t\treturn '';\n\t\t// prevent multiple dashes in comments\n\t\t$string = preg_replace('/--+/', '-', $string);\n\t\t// prevent three dashes closing a comment\n\t\t$string = preg_replace('/-$/', '', $string);\n\t\treturn \"<!--{$string}-->\";\n\t}\n\t// Allow HTML comments\n\n\tif (!preg_match('%^<\\s*(/\\s*)?([a-zA-Z0-9-]+)([^>]*)>?$%', $string, $matches))\n\t\treturn '';\n\t// It's seriously malformed\n\n\t$slash = trim($matches[1]);\n\t$elem = $matches[2];\n\t$attrlist = $matches[3];\n\n\tif ( ! is_array( $allowed_html ) )\n\t\t$allowed_html = wp_kses_allowed_html( $allowed_html );\n\n\tif ( ! isset($allowed_html[strtolower($elem)]) )\n\t\treturn '';\n\t// They are using a not allowed HTML element\n\n\tif ($slash != '')\n\t\treturn \"</$elem>\";\n\t// No attributes are allowed for closing elements\n\n\treturn wp_kses_attr( $elem, $attrlist, $allowed_html, $allowed_protocols );\n}\n\n/**\n * Removes all attributes, if none are allowed for this element.\n *\n * If some are allowed it calls wp_kses_hair() to split them further, and then\n * it builds up new HTML code from the data that kses_hair() returns. It also\n * removes \"<\" and \">\" characters, if there are any left. One more thing it does\n * is to check if the tag has a closing XHTML slash, and if it does, it puts one\n * in the returned code as well.\n *\n * @since 1.0.0\n *\n * @param string $element           HTML element/tag\n * @param string $attr              HTML attributes from HTML element to closing HTML element tag\n * @param array  $allowed_html      Allowed HTML elements\n * @param array  $allowed_protocols Allowed protocols to keep\n * @return string Sanitized HTML element\n */\nfunction wp_kses_attr($element, $attr, $allowed_html, $allowed_protocols) {\n\tif ( ! is_array( $allowed_html ) )\n\t\t$allowed_html = wp_kses_allowed_html( $allowed_html );\n\n\t// Is there a closing XHTML slash at the end of the attributes?\n\t$xhtml_slash = '';\n\tif (preg_match('%\\s*/\\s*$%', $attr))\n\t\t$xhtml_slash = ' /';\n\n\t// Are any attributes allowed at all for this element?\n\t$element_low = strtolower( $element );\n\tif ( empty( $allowed_html[ $element_low ] ) || true === $allowed_html[ $element_low ] ) {\n\t\treturn \"<$element$xhtml_slash>\";\n\t}\n\n\t// Split it\n\t$attrarr = wp_kses_hair($attr, $allowed_protocols);\n\n\t// Go through $attrarr, and save the allowed attributes for this element\n\t// in $attr2\n\t$attr2 = '';\n\tforeach ( $attrarr as $arreach ) {\n\t\tif ( wp_kses_attr_check( $arreach['name'], $arreach['value'], $arreach['whole'], $arreach['vless'], $element, $allowed_html ) ) {\n\t\t\t$attr2 .= ' '.$arreach['whole'];\n\t\t}\n\t}\n\n\t// Remove any \"<\" or \">\" characters\n\t$attr2 = preg_replace('/[<>]/', '', $attr2);\n\n\treturn \"<$element$attr2$xhtml_slash>\";\n}\n\n/**\n * Determine whether an attribute is allowed.\n *\n * @since 4.2.3\n * @since 5.0.0 Add support for `data-*` wildcard attributes.\n *\n * @param string $name The attribute name. Returns empty string when not allowed.\n * @param string $value The attribute value. Returns a filtered value.\n * @param string $whole The name=value input. Returns filtered input.\n * @param string $vless 'y' when attribute like \"enabled\", otherwise 'n'.\n * @param string $element The name of the element to which this attribute belongs.\n * @param array $allowed_html The full list of allowed elements and attributes.\n * @return bool Is the attribute allowed?\n */\nfunction wp_kses_attr_check( &$name, &$value, &$whole, $vless, $element, $allowed_html ) {\n\t$allowed_attr = $allowed_html[ strtolower( $element ) ];\n\n\t$name_low = strtolower( $name );\n\n\tif ( ! isset( $allowed_attr[$name_low] ) || '' == $allowed_attr[$name_low] ) {\n\t\t/*\n\t\t * Allow `data-*` attributes.\n\t\t *\n\t\t * When specifying `$allowed_html`, the attribute name should be set as\n\t\t * `data-*` (not to be mixed with the HTML 4.0 `data` attribute, see\n\t\t * https://www.w3.org/TR/html40/struct/objects.html#adef-data).\n\t\t *\n\t\t * Note: the attribute name should only contain `A-Za-z0-9_-` chars,\n\t\t * double hyphens `--` are not accepted by WordPress.\n\t\t */\n\t\tif ( strpos( $name_low, 'data-' ) === 0 && ! empty( $allowed_attr['data-*'] ) && preg_match( '/^data(?:-[a-z0-9_]+)+$/', $name_low, $match ) ) {\n\t\t\t/*\n\t\t\t * Add the whole attribute name to the allowed attributes and set any restrictions\n\t\t\t * for the `data-*` attribute values for the current element.\n\t\t\t */\n\t\t\t$allowed_attr[ $match[0] ] = $allowed_attr['data-*'];\n\t\t} else {\n\t\t\t$name = $value = $whole = '';\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif ( 'style' == $name_low ) {\n\t\t$new_value = safecss_filter_attr( $value );\n\n\t\tif ( empty( $new_value ) ) {\n\t\t\t$name = $value = $whole = '';\n\t\t\treturn false;\n\t\t}\n\n\t\t$whole = str_replace( $value, $new_value, $whole );\n\t\t$value = $new_value;\n\t}\n\n\tif ( is_array( $allowed_attr[ $name_low ] ) ) {\n\t\t// there are some checks\n\t\tforeach ( $allowed_attr[$name_low] as $currkey => $currval ) {\n\t\t\tif ( ! wp_kses_check_attr_val( $value, $vless, $currkey, $currval ) ) {\n\t\t\t\t$name = $value = $whole = '';\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * Builds an attribute list from string containing attributes.\n *\n * This function does a lot of work. It parses an attribute list into an array\n * with attribute data, and tries to do the right thing even if it gets weird\n * input. It will add quotes around attribute values that don't have any quotes\n * or apostrophes around them, to make it easier to produce HTML code that will\n * conform to W3C's HTML specification. It will also remove bad URL protocols\n * from attribute values. It also reduces duplicate attributes by using the\n * attribute defined first (foo='bar' foo='baz' will result in foo='bar').\n *\n * @since 1.0.0\n *\n * @param string $attr              Attribute list from HTML element to closing HTML element tag\n * @param array  $allowed_protocols Allowed protocols to keep\n * @return array List of attributes after parsing\n */\nfunction wp_kses_hair($attr, $allowed_protocols) {\n\t$attrarr = array();\n\t$mode = 0;\n\t$attrname = '';\n\t$uris = wp_kses_uri_attributes();\n\n\t// Loop through the whole attribute list\n\n\twhile (strlen($attr) != 0) {\n\t\t$working = 0; // Was the last operation successful?\n\n\t\tswitch ($mode) {\n\t\t\tcase 0 : // attribute name, href for instance\n\n\t\t\t\tif ( preg_match('/^([-a-zA-Z:]+)/', $attr, $match ) ) {\n\t\t\t\t\t$attrname = $match[1];\n\t\t\t\t\t$working = $mode = 1;\n\t\t\t\t\t$attr = preg_replace( '/^[-a-zA-Z:]+/', '', $attr );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 1 : // equals sign or valueless (\"selected\")\n\n\t\t\t\tif (preg_match('/^\\s*=\\s*/', $attr)) // equals sign\n\t\t\t\t\t{\n\t\t\t\t\t$working = 1;\n\t\t\t\t\t$mode = 2;\n\t\t\t\t\t$attr = preg_replace('/^\\s*=\\s*/', '', $attr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (preg_match('/^\\s+/', $attr)) // valueless\n\t\t\t\t\t{\n\t\t\t\t\t$working = 1;\n\t\t\t\t\t$mode = 0;\n\t\t\t\t\tif(false === array_key_exists($attrname, $attrarr)) {\n\t\t\t\t\t\t$attrarr[$attrname] = array ('name' => $attrname, 'value' => '', 'whole' => $attrname, 'vless' => 'y');\n\t\t\t\t\t}\n\t\t\t\t\t$attr = preg_replace('/^\\s+/', '', $attr);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 2 : // attribute value, a URL after href= for instance\n\n\t\t\t\tif (preg_match('%^\"([^\"]*)\"(\\s+|/?$)%', $attr, $match))\n\t\t\t\t\t// \"value\"\n\t\t\t\t\t{\n\t\t\t\t\t$thisval = $match[1];\n\t\t\t\t\tif ( in_array(strtolower($attrname), $uris) )\n\t\t\t\t\t\t$thisval = wp_kses_bad_protocol($thisval, $allowed_protocols);\n\n\t\t\t\t\tif(false === array_key_exists($attrname, $attrarr)) {\n\t\t\t\t\t\t$attrarr[$attrname] = array ('name' => $attrname, 'value' => $thisval, 'whole' => \"$attrname=\\\"$thisval\\\"\", 'vless' => 'n');\n\t\t\t\t\t}\n\t\t\t\t\t$working = 1;\n\t\t\t\t\t$mode = 0;\n\t\t\t\t\t$attr = preg_replace('/^\"[^\"]*\"(\\s+|$)/', '', $attr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (preg_match(\"%^'([^']*)'(\\s+|/?$)%\", $attr, $match))\n\t\t\t\t\t// 'value'\n\t\t\t\t\t{\n\t\t\t\t\t$thisval = $match[1];\n\t\t\t\t\tif ( in_array(strtolower($attrname), $uris) )\n\t\t\t\t\t\t$thisval = wp_kses_bad_protocol($thisval, $allowed_protocols);\n\n\t\t\t\t\tif(false === array_key_exists($attrname, $attrarr)) {\n\t\t\t\t\t\t$attrarr[$attrname] = array ('name' => $attrname, 'value' => $thisval, 'whole' => \"$attrname='$thisval'\", 'vless' => 'n');\n\t\t\t\t\t}\n\t\t\t\t\t$working = 1;\n\t\t\t\t\t$mode = 0;\n\t\t\t\t\t$attr = preg_replace(\"/^'[^']*'(\\s+|$)/\", '', $attr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (preg_match(\"%^([^\\s\\\"']+)(\\s+|/?$)%\", $attr, $match))\n\t\t\t\t\t// value\n\t\t\t\t\t{\n\t\t\t\t\t$thisval = $match[1];\n\t\t\t\t\tif ( in_array(strtolower($attrname), $uris) )\n\t\t\t\t\t\t$thisval = wp_kses_bad_protocol($thisval, $allowed_protocols);\n\n\t\t\t\t\tif(false === array_key_exists($attrname, $attrarr)) {\n\t\t\t\t\t\t$attrarr[$attrname] = array ('name' => $attrname, 'value' => $thisval, 'whole' => \"$attrname=\\\"$thisval\\\"\", 'vless' => 'n');\n\t\t\t\t\t}\n\t\t\t\t\t// We add quotes to conform to W3C's HTML spec.\n\t\t\t\t\t$working = 1;\n\t\t\t\t\t$mode = 0;\n\t\t\t\t\t$attr = preg_replace(\"%^[^\\s\\\"']+(\\s+|$)%\", '', $attr);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t} // switch\n\n\t\tif ($working == 0) // not well formed, remove and try again\n\t\t{\n\t\t\t$attr = wp_kses_html_error($attr);\n\t\t\t$mode = 0;\n\t\t}\n\t} // while\n\n\tif ($mode == 1 && false === array_key_exists($attrname, $attrarr))\n\t\t// special case, for when the attribute list ends with a valueless\n\t\t// attribute like \"selected\"\n\t\t$attrarr[$attrname] = array ('name' => $attrname, 'value' => '', 'whole' => $attrname, 'vless' => 'y');\n\n\treturn $attrarr;\n}\n\n/**\n * Finds all attributes of an HTML element.\n *\n * Does not modify input.  May return \"evil\" output.\n *\n * Based on wp_kses_split2() and wp_kses_attr()\n *\n * @since 4.2.3\n *\n * @param string $element HTML element/tag\n * @return array|bool List of attributes found in $element. Returns false on failure.\n */\nfunction wp_kses_attr_parse( $element ) {\n\t$valid = preg_match('%^(<\\s*)(/\\s*)?([a-zA-Z0-9]+\\s*)([^>]*)(>?)$%', $element, $matches);\n\tif ( 1 !== $valid ) {\n\t\treturn false;\n\t}\n\n\t$begin =  $matches[1];\n\t$slash =  $matches[2];\n\t$elname = $matches[3];\n\t$attr =   $matches[4];\n\t$end =    $matches[5];\n\n\tif ( '' !== $slash ) {\n\t\t// Closing elements do not get parsed.\n\t\treturn false;\n\t}\n\n\t// Is there a closing XHTML slash at the end of the attributes?\n\tif ( 1 === preg_match( '%\\s*/\\s*$%', $attr, $matches ) ) {\n\t\t$xhtml_slash = $matches[0];\n\t\t$attr = substr( $attr, 0, -strlen( $xhtml_slash ) );\n\t} else {\n\t\t$xhtml_slash = '';\n\t}\n\t\n\t// Split it\n\t$attrarr = wp_kses_hair_parse( $attr );\n\tif ( false === $attrarr ) {\n\t\treturn false;\n\t}\n\n\t// Make sure all input is returned by adding front and back matter.\n\tarray_unshift( $attrarr, $begin . $slash . $elname );\n\tarray_push( $attrarr, $xhtml_slash . $end );\n\t\n\treturn $attrarr;\n}\n\n/**\n * Builds an attribute list from string containing attributes.\n *\n * Does not modify input.  May return \"evil\" output.\n * In case of unexpected input, returns false instead of stripping things.\n *\n * Based on wp_kses_hair() but does not return a multi-dimensional array.\n *\n * @since 4.2.3\n *\n * @param string $attr Attribute list from HTML element to closing HTML element tag\n * @return array|bool List of attributes found in $attr. Returns false on failure.\n */\nfunction wp_kses_hair_parse( $attr ) {\n\tif ( '' === $attr ) {\n\t\treturn array();\n\t}\n\n\t$regex =\n\t  '(?:'\n\t.     '[-a-zA-Z:]+'   // Attribute name.\n\t. '|'\n\t.     '\\[\\[?[^\\[\\]]+\\]\\]?' // Shortcode in the name position implies unfiltered_html.\n\t. ')'\n\t. '(?:'               // Attribute value.\n\t.     '\\s*=\\s*'       // All values begin with '='\n\t.     '(?:'\n\t.         '\"[^\"]*\"'   // Double-quoted\n\t.     '|'\n\t.         \"'[^']*'\"   // Single-quoted\n\t.     '|'\n\t.         '[^\\s\"\\']+' // Non-quoted\n\t.         '(?:\\s|$)'  // Must have a space\n\t.     ')'\n\t. '|'\n\t.     '(?:\\s|$)'      // If attribute has no value, space is required.\n\t. ')'\n\t. '\\s*';              // Trailing space is optional except as mentioned above.\n\n\t// Although it is possible to reduce this procedure to a single regexp,\n\t// we must run that regexp twice to get exactly the expected result.\n\n\t$validation = \"%^($regex)+$%\";\n\t$extraction = \"%$regex%\";\n\n\tif ( 1 === preg_match( $validation, $attr ) ) {\n\t\tpreg_match_all( $extraction, $attr, $attrarr );\n\t\treturn $attrarr[0];\n\t} else {\n\t\treturn false;\n\t}\n}\n\n/**\n * Performs different checks for attribute values.\n *\n * The currently implemented checks are \"maxlen\", \"minlen\", \"maxval\", \"minval\"\n * and \"valueless\".\n *\n * @since 1.0.0\n *\n * @param string $value      Attribute value\n * @param string $vless      Whether the value is valueless. Use 'y' or 'n'\n * @param string $checkname  What $checkvalue is checking for.\n * @param mixed  $checkvalue What constraint the value should pass\n * @return bool Whether check passes\n */\nfunction wp_kses_check_attr_val($value, $vless, $checkname, $checkvalue) {\n\t$ok = true;\n\n\tswitch (strtolower($checkname)) {\n\t\tcase 'maxlen' :\n\t\t\t// The maxlen check makes sure that the attribute value has a length not\n\t\t\t// greater than the given value. This can be used to avoid Buffer Overflows\n\t\t\t// in WWW clients and various Internet servers.\n\n\t\t\tif (strlen($value) > $checkvalue)\n\t\t\t\t$ok = false;\n\t\t\tbreak;\n\n\t\tcase 'minlen' :\n\t\t\t// The minlen check makes sure that the attribute value has a length not\n\t\t\t// smaller than the given value.\n\n\t\t\tif (strlen($value) < $checkvalue)\n\t\t\t\t$ok = false;\n\t\t\tbreak;\n\n\t\tcase 'maxval' :\n\t\t\t// The maxval check does two things: it checks that the attribute value is\n\t\t\t// an integer from 0 and up, without an excessive amount of zeroes or\n\t\t\t// whitespace (to avoid Buffer Overflows). It also checks that the attribute\n\t\t\t// value is not greater than the given value.\n\t\t\t// This check can be used to avoid Denial of Service attacks.\n\n\t\t\tif (!preg_match('/^\\s{0,6}[0-9]{1,6}\\s{0,6}$/', $value))\n\t\t\t\t$ok = false;\n\t\t\tif ($value > $checkvalue)\n\t\t\t\t$ok = false;\n\t\t\tbreak;\n\n\t\tcase 'minval' :\n\t\t\t// The minval check makes sure that the attribute value is a positive integer,\n\t\t\t// and that it is not smaller than the given value.\n\n\t\t\tif (!preg_match('/^\\s{0,6}[0-9]{1,6}\\s{0,6}$/', $value))\n\t\t\t\t$ok = false;\n\t\t\tif ($value < $checkvalue)\n\t\t\t\t$ok = false;\n\t\t\tbreak;\n\n\t\tcase 'valueless' :\n\t\t\t// The valueless check makes sure if the attribute has a value\n\t\t\t// (like <a href=\"blah\">) or not (<option selected>). If the given value\n\t\t\t// is a \"y\" or a \"Y\", the attribute must not have a value.\n\t\t\t// If the given value is an \"n\" or an \"N\", the attribute must have one.\n\n\t\t\tif (strtolower($checkvalue) != $vless)\n\t\t\t\t$ok = false;\n\t\t\tbreak;\n\t} // switch\n\n\treturn $ok;\n}\n\n/**\n * Sanitize string from bad protocols.\n *\n * This function removes all non-allowed protocols from the beginning of\n * $string. It ignores whitespace and the case of the letters, and it does\n * understand HTML entities. It does its work in a while loop, so it won't be\n * fooled by a string like \"javascript:javascript:alert(57)\".\n *\n * @since 1.0.0\n *\n * @param string $string            Content to filter bad protocols from\n * @param array  $allowed_protocols Allowed protocols to keep\n * @return string Filtered content\n */\nfunction wp_kses_bad_protocol($string, $allowed_protocols) {\n\t$string = wp_kses_no_null($string);\n\t$iterations = 0;\n\n\tdo {\n\t\t$original_string = $string;\n\t\t$string = wp_kses_bad_protocol_once($string, $allowed_protocols);\n\t} while ( $original_string != $string && ++$iterations < 6 );\n\n\tif ( $original_string != $string )\n\t\treturn '';\n\n\treturn $string;\n}\n\n/**\n * Removes any invalid control characters in $string.\n *\n * Also removes any instance of the '\\0' string.\n *\n * @since 1.0.0\n *\n * @param string $string\n * @param array $options Set 'slash_zero' => 'keep' when '\\0' is allowed. Default is 'remove'.\n * @return string\n */\nfunction wp_kses_no_null( $string, $options = null ) {\n\tif ( ! isset( $options['slash_zero'] ) ) {\n\t\t$options = array( 'slash_zero' => 'remove' );\n\t}\n\n\t$string = preg_replace( '/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F]/', '', $string );\n\tif ( 'remove' == $options['slash_zero'] ) {\n\t\t$string = preg_replace( '/\\\\\\\\+0+/', '', $string );\n\t}\n\n\treturn $string;\n}\n\n/**\n * Strips slashes from in front of quotes.\n *\n * This function changes the character sequence \\\" to just \". It leaves all\n * other slashes alone. It's really weird, but the quoting from\n * preg_replace(//e) seems to require this.\n *\n * @since 1.0.0\n *\n * @param string $string String to strip slashes\n * @return string Fixed string with quoted slashes\n */\nfunction wp_kses_stripslashes($string) {\n\treturn preg_replace('%\\\\\\\\\"%', '\"', $string);\n}\n\n/**\n * Goes through an array and changes the keys to all lower case.\n *\n * @since 1.0.0\n *\n * @param array $inarray Unfiltered array\n * @return array Fixed array with all lowercase keys\n */\nfunction wp_kses_array_lc($inarray) {\n\t$outarray = array ();\n\n\tforeach ( (array) $inarray as $inkey => $inval) {\n\t\t$outkey = strtolower($inkey);\n\t\t$outarray[$outkey] = array ();\n\n\t\tforeach ( (array) $inval as $inkey2 => $inval2) {\n\t\t\t$outkey2 = strtolower($inkey2);\n\t\t\t$outarray[$outkey][$outkey2] = $inval2;\n\t\t} // foreach $inval\n\t} // foreach $inarray\n\n\treturn $outarray;\n}\n\n/**\n * Handles parsing errors in wp_kses_hair().\n *\n * The general plan is to remove everything to and including some whitespace,\n * but it deals with quotes and apostrophes as well.\n *\n * @since 1.0.0\n *\n * @param string $string\n * @return string\n */\nfunction wp_kses_html_error($string) {\n\treturn preg_replace('/^(\"[^\"]*(\"|$)|\\'[^\\']*(\\'|$)|\\S)*\\s*/', '', $string);\n}\n\n/**\n * Sanitizes content from bad protocols and other characters.\n *\n * This function searches for URL protocols at the beginning of $string, while\n * handling whitespace and HTML entities.\n *\n * @since 1.0.0\n *\n * @param string $string            Content to check for bad protocols\n * @param string $allowed_protocols Allowed protocols\n * @return string Sanitized content\n */\nfunction wp_kses_bad_protocol_once($string, $allowed_protocols, $count = 1 ) {\n\t$string2 = preg_split( '/:|&#0*58;|&#x0*3a;/i', $string, 2 );\n\tif ( isset($string2[1]) && ! preg_match('%/\\?%', $string2[0]) ) {\n\t\t$string = trim( $string2[1] );\n\t\t$protocol = wp_kses_bad_protocol_once2( $string2[0], $allowed_protocols );\n\t\tif ( 'feed:' == $protocol ) {\n\t\t\tif ( $count > 2 )\n\t\t\t\treturn '';\n\t\t\t$string = wp_kses_bad_protocol_once( $string, $allowed_protocols, ++$count );\n\t\t\tif ( empty( $string ) )\n\t\t\t\treturn $string;\n\t\t}\n\t\t$string = $protocol . $string;\n\t}\n\n\treturn $string;\n}\n\n/**\n * Callback for wp_kses_bad_protocol_once() regular expression.\n *\n * This function processes URL protocols, checks to see if they're in the\n * whitelist or not, and returns different data depending on the answer.\n *\n * @access private\n * @since 1.0.0\n *\n * @param string $string            URI scheme to check against the whitelist\n * @param string $allowed_protocols Allowed protocols\n * @return string Sanitized content\n */\nfunction wp_kses_bad_protocol_once2( $string, $allowed_protocols ) {\n\t$string2 = wp_kses_decode_entities($string);\n\t$string2 = preg_replace('/\\s/', '', $string2);\n\t$string2 = wp_kses_no_null($string2);\n\t$string2 = strtolower($string2);\n\n\t$allowed = false;\n\tforeach ( (array) $allowed_protocols as $one_protocol )\n\t\tif ( strtolower($one_protocol) == $string2 ) {\n\t\t\t$allowed = true;\n\t\t\tbreak;\n\t\t}\n\n\tif ($allowed)\n\t\treturn \"$string2:\";\n\telse\n\t\treturn '';\n}\n\n/**\n * Converts and fixes HTML entities.\n *\n * This function normalizes HTML entities. It will convert `AT&T` to the correct\n * `AT&amp;T`, `&#00058;` to `&#58;`, `&#XYZZY;` to `&amp;#XYZZY;` and so on.\n *\n * @since 1.0.0\n *\n * @param string $string Content to normalize entities\n * @return string Content with normalized entities\n */\nfunction wp_kses_normalize_entities($string) {\n\t// Disarm all entities by converting & to &amp;\n\t$string = str_replace('&', '&amp;', $string);\n\n\t// Change back the allowed entities in our entity whitelist\n\t$string = preg_replace_callback('/&amp;([A-Za-z]{2,8}[0-9]{0,2});/', 'wp_kses_named_entities', $string);\n\t$string = preg_replace_callback('/&amp;#(0*[0-9]{1,7});/', 'wp_kses_normalize_entities2', $string);\n\t$string = preg_replace_callback('/&amp;#[Xx](0*[0-9A-Fa-f]{1,6});/', 'wp_kses_normalize_entities3', $string);\n\n\treturn $string;\n}\n\n/**\n * Callback for wp_kses_normalize_entities() regular expression.\n *\n * This function only accepts valid named entity references, which are finite,\n * case-sensitive, and highly scrutinized by HTML and XML validators.\n *\n * @since 3.0.0\n *\n * @global array $allowedentitynames\n *\n * @param array $matches preg_replace_callback() matches array\n * @return string Correctly encoded entity\n */\nfunction wp_kses_named_entities($matches) {\n\tglobal $allowedentitynames;\n\n\tif ( empty($matches[1]) )\n\t\treturn '';\n\n\t$i = $matches[1];\n\treturn ( ! in_array( $i, $allowedentitynames ) ) ? \"&amp;$i;\" : \"&$i;\";\n}\n\n/**\n * Callback for wp_kses_normalize_entities() regular expression.\n *\n * This function helps wp_kses_normalize_entities() to only accept 16-bit\n * values and nothing more for `&#number;` entities.\n *\n * @access private\n * @since 1.0.0\n *\n * @param array $matches preg_replace_callback() matches array\n * @return string Correctly encoded entity\n */\nfunction wp_kses_normalize_entities2($matches) {\n\tif ( empty($matches[1]) )\n\t\treturn '';\n\n\t$i = $matches[1];\n\tif (valid_unicode($i)) {\n\t\t$i = str_pad(ltrim($i,'0'), 3, '0', STR_PAD_LEFT);\n\t\t$i = \"&#$i;\";\n\t} else {\n\t\t$i = \"&amp;#$i;\";\n\t}\n\n\treturn $i;\n}\n\n/**\n * Callback for wp_kses_normalize_entities() for regular expression.\n *\n * This function helps wp_kses_normalize_entities() to only accept valid Unicode\n * numeric entities in hex form.\n *\n * @since 2.7.0\n * @access private\n *\n * @param array $matches preg_replace_callback() matches array\n * @return string Correctly encoded entity\n */\nfunction wp_kses_normalize_entities3($matches) {\n\tif ( empty($matches[1]) )\n\t\treturn '';\n\n\t$hexchars = $matches[1];\n\treturn ( ! valid_unicode( hexdec( $hexchars ) ) ) ? \"&amp;#x$hexchars;\" : '&#x'.ltrim($hexchars,'0').';';\n}\n\n/**\n * Helper function to determine if a Unicode value is valid.\n *\n * @since 2.7.0\n *\n * @param int $i Unicode value\n * @return bool True if the value was a valid Unicode number\n */\nfunction valid_unicode($i) {\n\treturn ( $i == 0x9 || $i == 0xa || $i == 0xd ||\n\t\t\t($i >= 0x20 && $i <= 0xd7ff) ||\n\t\t\t($i >= 0xe000 && $i <= 0xfffd) ||\n\t\t\t($i >= 0x10000 && $i <= 0x10ffff) );\n}\n\n/**\n * Convert all entities to their character counterparts.\n *\n * This function decodes numeric HTML entities (`&#65;` and `&#x41;`).\n * It doesn't do anything with other entities like &auml;, but we don't\n * need them in the URL protocol whitelisting system anyway.\n *\n * @since 1.0.0\n *\n * @param string $string Content to change entities\n * @return string Content after decoded entities\n */\nfunction wp_kses_decode_entities($string) {\n\t$string = preg_replace_callback('/&#([0-9]+);/', '_wp_kses_decode_entities_chr', $string);\n\t$string = preg_replace_callback('/&#[Xx]([0-9A-Fa-f]+);/', '_wp_kses_decode_entities_chr_hexdec', $string);\n\n\treturn $string;\n}\n\n/**\n * Regex callback for wp_kses_decode_entities()\n *\n * @since 2.9.0\n *\n * @param array $match preg match\n * @return string\n */\nfunction _wp_kses_decode_entities_chr( $match ) {\n\treturn chr( $match[1] );\n}\n\n/**\n * Regex callback for wp_kses_decode_entities()\n *\n * @since 2.9.0\n *\n * @param array $match preg match\n * @return string\n */\nfunction _wp_kses_decode_entities_chr_hexdec( $match ) {\n\treturn chr( hexdec( $match[1] ) );\n}\n\n/**\n * Sanitize content with allowed HTML Kses rules.\n *\n * @since 1.0.0\n *\n * @param string $data Content to filter, expected to be escaped with slashes\n * @return string Filtered content\n */\nfunction wp_filter_kses( $data ) {\n\treturn addslashes( wp_kses( stripslashes( $data ), current_filter() ) );\n}\n\n/**\n * Sanitize content with allowed HTML Kses rules.\n *\n * @since 2.9.0\n *\n * @param string $data Content to filter, expected to not be escaped\n * @return string Filtered content\n */\nfunction wp_kses_data( $data ) {\n\treturn wp_kses( $data, current_filter() );\n}\n\n/**\n * Sanitize content for allowed HTML tags for post content.\n *\n * Post content refers to the page contents of the 'post' type and not $_POST\n * data from forms.\n *\n * @since 2.0.0\n *\n * @param string $data Post content to filter, expected to be escaped with slashes\n * @return string Filtered post content with allowed HTML tags and attributes intact.\n */\nfunction wp_filter_post_kses( $data ) {\n\treturn addslashes( wp_kses( stripslashes( $data ), 'post' ) );\n}\n\n/**\n * Sanitize content for allowed HTML tags for post content.\n *\n * Post content refers to the page contents of the 'post' type and not $_POST\n * data from forms.\n *\n * @since 2.9.0\n *\n * @param string $data Post content to filter\n * @return string Filtered post content with allowed HTML tags and attributes intact.\n */\nfunction wp_kses_post( $data ) {\n\treturn wp_kses( $data, 'post' );\n}\n\n/**\n * Navigates through an array, object, or scalar, and sanitizes content for\n * allowed HTML tags for post content.\n *\n * @since 4.4.2\n *\n * @see map_deep()\n *\n * @param mixed $data The array, object, or scalar value to inspect.\n * @return mixed The filtered content.\n */\nfunction wp_kses_post_deep( $data ) {\n\treturn map_deep( $data, 'wp_kses_post' );\n}\n\n/**\n * Strips all of the HTML in the content.\n *\n * @since 2.1.0\n *\n * @param string $data Content to strip all HTML from\n * @return string Filtered content without any HTML\n */\nfunction wp_filter_nohtml_kses( $data ) {\n\treturn addslashes( wp_kses( stripslashes( $data ), 'strip' ) );\n}\n\n/**\n * Adds all Kses input form content filters.\n *\n * All hooks have default priority. The wp_filter_kses() function is added to\n * the 'pre_comment_content' and 'title_save_pre' hooks.\n *\n * The wp_filter_post_kses() function is added to the 'content_save_pre',\n * 'excerpt_save_pre', and 'content_filtered_save_pre' hooks.\n *\n * @since 2.0.0\n */\nfunction kses_init_filters() {\n\t// Normal filtering\n\tadd_filter('title_save_pre', 'wp_filter_kses');\n\n\t// Comment filtering\n\tif ( current_user_can( 'unfiltered_html' ) )\n\t\tadd_filter( 'pre_comment_content', 'wp_filter_post_kses' );\n\telse\n\t\tadd_filter( 'pre_comment_content', 'wp_filter_kses' );\n\n\t// Post filtering\n\tadd_filter('content_save_pre', 'wp_filter_post_kses');\n\tadd_filter('excerpt_save_pre', 'wp_filter_post_kses');\n\tadd_filter('content_filtered_save_pre', 'wp_filter_post_kses');\n}\n\n/**\n * Removes all Kses input form content filters.\n *\n * A quick procedural method to removing all of the filters that kses uses for\n * content in WordPress Loop.\n *\n * Does not remove the kses_init() function from {@see 'init'} hook (priority is\n * default). Also does not remove kses_init() function from {@see 'set_current_user'}\n * hook (priority is also default).\n *\n * @since 2.0.6\n */\nfunction kses_remove_filters() {\n\t// Normal filtering\n\tremove_filter('title_save_pre', 'wp_filter_kses');\n\n\t// Comment filtering\n\tremove_filter( 'pre_comment_content', 'wp_filter_post_kses' );\n\tremove_filter( 'pre_comment_content', 'wp_filter_kses' );\n\n\t// Post filtering\n\tremove_filter('content_save_pre', 'wp_filter_post_kses');\n\tremove_filter('excerpt_save_pre', 'wp_filter_post_kses');\n\tremove_filter('content_filtered_save_pre', 'wp_filter_post_kses');\n}\n\n/**\n * Sets up most of the Kses filters for input form content.\n *\n * If you remove the kses_init() function from {@see 'init'} hook and\n * {@see 'set_current_user'} (priority is default), then none of the Kses filter hooks\n * will be added.\n *\n * First removes all of the Kses filters in case the current user does not need\n * to have Kses filter the content. If the user does not have unfiltered_html\n * capability, then Kses filters are added.\n *\n * @since 2.0.0\n */\nfunction kses_init() {\n\tkses_remove_filters();\n\n\tif ( ! current_user_can( 'unfiltered_html' ) ) {\n\t\tkses_init_filters();\n\t}\n}\n\n/**\n * Inline CSS filter\n *\n * @since 2.8.1\n *\n * @param string $css        A string of CSS rules.\n * @param string $deprecated Not used.\n * @return string            Filtered string of CSS rules.\n */\nfunction safecss_filter_attr( $css, $deprecated = '' ) {\n\tif ( ! empty( $deprecated ) ) {\n\t\t_deprecated_argument( __FUNCTION__, '2.8.1' ); // Never implemented\n\t}\n\n\t$css = wp_kses_no_null( $css );\n\t$css = str_replace( array( \"\\n\", \"\\r\", \"\\t\" ), '', $css );\n\n\t$allowed_protocols = wp_allowed_protocols();\n\n\t$css_array = explode( ';', trim( $css ) );\n\n\t/**\n\t * Filters list of allowed CSS attributes.\n\t *\n\t * @since 2.8.1\n\t * @since 4.4.0 Added support for `min-height`, `max-height`, `min-width`, and `max-width`.\n\t * @since 4.6.0 Added support for `list-style-type`.\n\t * @since 5.0.0 Added support for `background-image`.\n\t *\n\t * @param array $attr List of allowed CSS attributes.\n\t */\n\t$allowed_attr = apply_filters( 'safe_style_css', array(\n\t\t'background',\n\t\t'background-color',\n\t\t'background-image',\n\n\t\t'border',\n\t\t'border-width',\n\t\t'border-color',\n\t\t'border-style',\n\t\t'border-right',\n\t\t'border-right-color',\n\t\t'border-right-style',\n\t\t'border-right-width',\n\t\t'border-bottom',\n\t\t'border-bottom-color',\n\t\t'border-bottom-style',\n\t\t'border-bottom-width',\n\t\t'border-left',\n\t\t'border-left-color',\n\t\t'border-left-style',\n\t\t'border-left-width',\n\t\t'border-top',\n\t\t'border-top-color',\n\t\t'border-top-style',\n\t\t'border-top-width',\n\n\t\t'border-spacing',\n\t\t'border-collapse',\n\t\t'caption-side',\n\n\t\t'color',\n\t\t'font',\n\t\t'font-family',\n\t\t'font-size',\n\t\t'font-style',\n\t\t'font-variant',\n\t\t'font-weight',\n\t\t'letter-spacing',\n\t\t'line-height',\n\t\t'text-decoration',\n\t\t'text-indent',\n\t\t'text-align',\n\n\t\t'height',\n\t\t'min-height',\n\t\t'max-height',\n\n\t\t'width',\n\t\t'min-width',\n\t\t'max-width',\n\n\t\t'margin',\n\t\t'margin-right',\n\t\t'margin-bottom',\n\t\t'margin-left',\n\t\t'margin-top',\n\n\t\t'padding',\n\t\t'padding-right',\n\t\t'padding-bottom',\n\t\t'padding-left',\n\t\t'padding-top',\n\n\t\t'clear',\n\t\t'cursor',\n\t\t'direction',\n\t\t'float',\n\t\t'overflow',\n\t\t'vertical-align',\n\t\t'list-style-type',\n\t) );\n\n\n\t/*\n\t * CSS attributes that accept URL data types.\n\t *\n\t * This is in accordance to the CSS spec and unrelated to\n\t * the sub-set of supported attributes above.\n\t *\n\t * See: https://developer.mozilla.org/en-US/docs/Web/CSS/url\n\t */\n\t$css_url_data_types = array(\n\t\t'background',\n\t\t'background-image',\n\n\t\t'cursor',\n\n\t\t'list-style',\n\t\t'list-style-image',\n\t);\n\n\tif ( empty( $allowed_attr ) ) {\n\t\treturn $css;\n\t}\n\n\t$css = '';\n\tforeach ( $css_array as $css_item ) {\n\t\tif ( $css_item == '' ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t$css_item        = trim( $css_item );\n\t\t$css_test_string = $css_item;\n\t\t$found           = false;\n\t\t$url_attr        = false;\n\n\t\tif ( strpos( $css_item, ':' ) === false ) {\n\t\t\t$found = true;\n\t\t} else {\n\t\t\t$parts = explode( ':', $css_item, 2 );\n\t\t\t$css_selector = trim( $parts[0] );\n\n\t\t\tif ( in_array( $css_selector, $allowed_attr, true ) ) {\n\t\t\t\t$found = true;\n\t\t\t\t$url_attr = in_array( $css_selector, $css_url_data_types, true );\n\t\t\t}\n\t\t}\n\n\t\tif ( $found && $url_attr ) {\n\t\t\t// Simplified: matches the sequence `url(*)`.\n\t\t\tpreg_match_all( '/url\\([^)]+\\)/', $parts[1], $url_matches );\n\n\t\t\tforeach ( $url_matches[0] as $url_match ) {\n\t\t\t\t// Clean up the URL from each of the matches above.\n\t\t\t\tpreg_match( '/^url\\(\\s*([\\'\\\"]?)(.*)(\\g1)\\s*\\)$/', $url_match, $url_pieces );\n\n\t\t\t\tif ( empty( $url_pieces[2] ) ) {\n\t\t\t\t\t$found = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t$url = trim( $url_pieces[2] );\n\n\t\t\t\tif ( empty( $url ) || $url !== wp_kses_bad_protocol( $url, $allowed_protocols ) ) {\n\t\t\t\t\t$found = false;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t// Remove the whole `url(*)` bit that was matched above from the CSS.\n\t\t\t\t\t$css_test_string = str_replace( $url_match, '', $css_test_string );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Remove any CSS containing containing \\ ( & } = or comments, except for url() useage checked above.\n\t\tif ( $found && ! preg_match( '%[\\\\\\(&=}]|/\\*%', $css_test_string ) ) {\n\t\t\tif ( $css != '' ) {\n\t\t\t\t$css .= ';';\n\t\t\t}\n\n\t\t\t$css .= $css_item;\n\t\t}\n\t}\n\n\treturn $css;\n}\n\n/**\n * Helper function to add global attributes to a tag in the allowed html list.\n *\n * @since 3.5.0\n * @since 5.0.0 Add support for `data-*` wildcard attributes.\n * @access private\n *\n * @param array $value An array of attributes.\n * @return array The array of attributes with global attributes added.\n */\nfunction _wp_add_global_attributes( $value ) {\n\t$global_attributes = array(\n\t\t'aria-describedby' => true,\n\t\t'aria-details' => true,\n\t\t'aria-label' => true,\n\t\t'aria-labelledby' => true,\n\t\t'aria-hidden' => true,\n\t\t'class' => true,\n\t\t'id' => true,\n\t\t'style' => true,\n\t\t'title' => true,\n\t\t'role' => true,\n\t\t'data-*' => true,\n\t);\n\n\tif ( true === $value )\n\t\t$value = array();\n\n\tif ( is_array( $value ) )\n\t\treturn array_merge( $value, $global_attributes );\n\n\treturn $value;\n}\n", "<?php\n/**\n * The WordPress version string\n *\n * @global string $wp_version\n */\n$wp_version = '5.0.1-alpha-44014';\n\n/**\n * Holds the WordPress DB revision, increments when changes are made to the WordPress DB schema.\n *\n * @global int $wp_db_version\n */\n$wp_db_version = 43764;\n\n/**\n * Holds the TinyMCE version\n *\n * @global string $tinymce_version\n */\n$tinymce_version = '4800-20180716';\n\n/**\n * Holds the required PHP version\n *\n * @global string $required_php_version\n */\n$required_php_version = '5.2.4';\n\n/**\n * Holds the required MySQL version\n *\n * @global string $required_mysql_version\n */\n$required_mysql_version = '5.0';\n"], "filenames": ["wp-includes/kses.php", "wp-includes/version.php"], "buggy_code_start_loc": [542, 7], "buggy_code_end_loc": [957, 8], "fixing_code_start_loc": [542, 7], "fixing_code_end_loc": [1007, 8], "type": "CWE-79", "message": "In WordPress before 4.9.9 and 5.x before 5.0.1, crafted URLs could trigger XSS for certain use cases involving plugins.", "other": {"cve": {"id": "CVE-2018-20150", "sourceIdentifier": "cve@mitre.org", "published": "2018-12-14T20:29:00.470", "lastModified": "2019-03-04T14:21:00.720", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In WordPress before 4.9.9 and 5.x before 5.0.1, crafted URLs could trigger XSS for certain use cases involving plugins."}, {"lang": "es", "value": "En WordPress, en versiones anteriores a la 4.9.9 y versiones 5.x anteriores a la 5.0.1, las URL manipuladas podr\u00edan desencadenar Cross-Site Scripting (XSS) para ciertos casos de uso relacionados con los plugins."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wordpress:wordpress:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.9.9", "matchCriteriaId": "CEEA870E-2BB4-4720-A3D9-1FFBA5596D94"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wordpress:wordpress:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0", "versionEndExcluding": "5.0.1", "matchCriteriaId": "5CCEB112-4070-4BB4-8974-C289FAF79E79"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/106220", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://codex.wordpress.org/Version_4.9.9", "source": "cve@mitre.org", "tags": ["Product", "Vendor Advisory"]}, {"url": "https://github.com/WordPress/WordPress/commit/fb3c6ea0618fcb9a51d4f2c1940e9efcd4a2d460", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/02/msg00019.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://wordpress.org/news/2018/12/wordpress-5-0-1-security-release/", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://wordpress.org/support/wordpress-version/version-5-0-1/", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://wpvulndb.com/vulnerabilities/9173", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://www.debian.org/security/2019/dsa-4401", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.zdnet.com/article/wordpress-plugs-bug-that-led-to-google-indexing-some-user-passwords/", "source": "cve@mitre.org", "tags": ["Press/Media Coverage", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/WordPress/WordPress/commit/fb3c6ea0618fcb9a51d4f2c1940e9efcd4a2d460"}}