{"buggy_code": ["/* hivex - Windows Registry \"hive\" extraction library.\n * Copyright (C) 2009-2011 Red Hat Inc.\n * Derived from code by Petter Nordahl-Hagen under a compatible license:\n *   Copyright (c) 1997-2007 Petter Nordahl-Hagen.\n * Derived from code by Markus Stephany under a compatible license:\n *   Copyright (c) 2000-2004, Markus Stephany.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation;\n * version 2.1 of the License.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * See file LICENSE for the full license.\n */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <inttypes.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <assert.h>\n\n#include \"c-ctype.h\"\n\n#include \"hivex.h\"\n#include \"hivex-internal.h\"\n\nhive_node_h\nhivex_root (hive_h *h)\n{\n  hive_node_h ret = h->rootoffs;\n  if (!IS_VALID_BLOCK (h, ret)) {\n    SET_ERRNO (HIVEX_NO_KEY, \"no root key\");\n    return 0;\n  }\n  return ret;\n}\n\nsize_t\nhivex_node_struct_length (hive_h *h, hive_node_h node)\n{\n  if (!IS_VALID_BLOCK (h, node) || !block_id_eq (h, node, \"nk\")) {\n    SET_ERRNO (EINVAL, \"invalid block or not an 'nk' block\");\n    return 0;\n  }\n\n  struct ntreg_nk_record *nk =\n    (struct ntreg_nk_record *) ((char *) h->addr + node);\n  size_t name_len = le16toh (nk->name_len);\n  /* -1 to avoid double-counting the first name character */\n  size_t ret = name_len + sizeof (struct ntreg_nk_record) - 1;\n  int used;\n  size_t seg_len = block_len (h, node, &used);\n  if (ret > seg_len) {\n    SET_ERRNO (EFAULT, \"node name is too long (%zu, %zu)\", name_len, seg_len);\n    return 0;\n  }\n  return ret;\n}\n\nchar *\nhivex_node_name (hive_h *h, hive_node_h node)\n{\n  if (!IS_VALID_BLOCK (h, node) || !block_id_eq (h, node, \"nk\")) {\n    SET_ERRNO (EINVAL, \"invalid block or not an 'nk' block\");\n    return NULL;\n  }\n\n  struct ntreg_nk_record *nk =\n    (struct ntreg_nk_record *) ((char *) h->addr + node);\n\n  /* nk->name_len is unsigned, 16 bit, so this is safe ...  However\n   * we have to make sure the length doesn't exceed the block length.\n   */\n  size_t len = le16toh (nk->name_len);\n  size_t seg_len = block_len (h, node, NULL);\n  if (sizeof (struct ntreg_nk_record) + len - 1 > seg_len) {\n    SET_ERRNO (EFAULT, \"node name is too long (%zu, %zu)\", len, seg_len);\n    return NULL;\n  }\n  size_t flags = le16toh (nk->flags);\n  if (flags & 0x20) {\n    return _hivex_recode (h, latin1_to_utf8, nk->name, len, NULL);\n  } else {\n    return _hivex_recode (h, utf16le_to_utf8, nk->name, len, NULL);\n  }\n}\n\nsize_t\nhivex_node_name_len (hive_h *h, hive_node_h node)\n{\n  if (!IS_VALID_BLOCK (h, node) || !block_id_eq (h, node, \"nk\")) {\n    SET_ERRNO (EINVAL, \"invalid block or not an 'nk' block\");\n    return 0;\n  }\n  struct ntreg_nk_record *nk =\n    (struct ntreg_nk_record *) ((char *) h->addr + node);\n\n  /* nk->name_len is unsigned, 16 bit, so this is safe ...  However\n   * we have to make sure the length doesn't exceed the block length.\n   */\n  size_t len = le16toh (nk->name_len);\n  size_t seg_len = block_len (h, node, NULL);\n  if (sizeof (struct ntreg_nk_record) + len - 1 > seg_len) {\n    SET_ERRNO (EFAULT, \"node name is too long (%zu, %zu)\", len, seg_len);\n    return 0;\n  }\n\n  return _hivex_utf8_strlen (h, nk->name, len, ! (le16toh (nk->flags) & 0x20));\n}\n\n\nstatic int64_t\ntimestamp_check (hive_h *h, hive_node_h node, int64_t timestamp)\n{\n  if (timestamp < 0) {\n    SET_ERRNO (EINVAL,\n               \"negative time reported at %zu: %\" PRIi64, node, timestamp);\n    return -1;\n  }\n\n  return timestamp;\n}\n\nint64_t\nhivex_last_modified (hive_h *h)\n{\n  return timestamp_check (h, 0, h->last_modified);\n}\n\nint64_t\nhivex_node_timestamp (hive_h *h, hive_node_h node)\n{\n  int64_t ret;\n\n  if (!IS_VALID_BLOCK (h, node) || !block_id_eq (h, node, \"nk\")) {\n    SET_ERRNO (EINVAL, \"invalid block or not an 'nk' block\");\n    return -1;\n  }\n\n  struct ntreg_nk_record *nk =\n    (struct ntreg_nk_record *) ((char *) h->addr + node);\n\n  ret = le64toh (nk->timestamp);\n  return timestamp_check (h, node, ret);\n}\n\n#if 0\n/* I think the documentation for the sk and classname fields in the nk\n * record is wrong, or else the offset field is in the wrong place.\n * Otherwise this makes no sense.  Disabled this for now -- it's not\n * useful for reading the registry anyway.\n */\n\nhive_security_h\nhivex_node_security (hive_h *h, hive_node_h node)\n{\n  if (!IS_VALID_BLOCK (h, node) || !block_id_eq (h, node, \"nk\")) {\n    SET_ERRNO (EINVAL, \"invalid block or not an 'nk' block\");\n    return 0;\n  }\n\n  struct ntreg_nk_record *nk = (struct ntreg_nk_record *) (h->addr + node);\n\n  hive_node_h ret = le32toh (nk->sk);\n  ret += 0x1000;\n  if (!IS_VALID_BLOCK (h, ret)) {\n    SET_ERRNO (EFAULT, \"invalid block\");\n    return 0;\n  }\n  return ret;\n}\n\nhive_classname_h\nhivex_node_classname (hive_h *h, hive_node_h node)\n{\n  if (!IS_VALID_BLOCK (h, node) || !block_id_eq (h, node, \"nk\")) {\n    SET_ERRNO (EINVAL, \"invalid block or not an 'nk' block\");\n    return 0;\n  }\n\n  struct ntreg_nk_record *nk = (struct ntreg_nk_record *) (h->addr + node);\n\n  hive_node_h ret = le32toh (nk->classname);\n  ret += 0x1000;\n  if (!IS_VALID_BLOCK (h, ret)) {\n    SET_ERRNO (EFAULT, \"invalid block\");\n    return 0;\n  }\n  return ret;\n}\n#endif\n\nstatic int _get_children (hive_h *h, hive_node_h blkoff,\n                          offset_list *children, offset_list *blocks,\n                          int flags);\nstatic int check_child_is_nk_block (hive_h *h, hive_node_h child, int flags);\n\n/* Iterate over children (ie. subkeys of a node), returning child\n * nodes and intermediate blocks.\n *\n * 'node' is the nk block.\n *\n * 'flags' can be 0, or GET_CHILDREN_NO_CHECK_NK which bypasses a\n * check that each child is a valid block.\n *\n * The list of child nodes (all nk blocks) is returned in\n * 'children_ret'.\n *\n * The list of intermediate nodes (a mix of lf/lh/ri/li blocks) is\n * returned in 'blocks_ret'.\n *\n * ----------------------------------------\n *\n * The format of the intermediate blocks is not documented, but\n * appears to be this:\n *\n * +-------------+  This is the parent registry key.\n * | nk          |\n * |-------------|\n * | subkey_lf  ---->  Points to either lf/lh, li or ri\n * |             |     (all 3 cases have to be dealt with\n * |             |     separately, see below)\n * +-------------+\n *\n * The subkey_lf field can point to one of three things, which are\n * all subtly different:\n *\n * (1) lf/lh record.  (It's not clear what the precise difference\n * is but we treat them as the same thing)\n *\n * +-------------+\n * | lf/lh       |\n * |-------------|\n * | nr_keys     |\n * |   keys[0].offset ------>  points to nk blocks (the children)\n * |   keys[1].offset ------>\n * |   keys[2].offset ------>\n * +-------------+\n *\n * (2) li record.\n *\n * Although the format of an li-record is the same as the format of an\n * ri-record, the difference is that the offsets point directly to the\n * nk blocks (children).\n *\n * +-------------+\n * | li          |\n * |-------------|\n * | nr_offsets  |\n * |   offset[0] ------>  points to nk blocks (the children)\n * |   offset[1] ------>\n * |   offset[2] ------>\n * +-------------+\n *\n * (3) ri record.\n *\n * The format of the block is the same as the li-record, BUT ri-record\n * offsets *never* point directly to nk blocks.  They only point to\n * other lf/lh/li/ri-records, thus forming a tree of arbitrary depth.\n *\n * +-------------+\n * | ri          |\n * |-------------|\n * | nr_offsets  |\n * |   offset[0] ------>  points to another lf/lh/li/ri block\n * |   offset[1] ------>\n * |   offset[2] ------>\n * +-------------+\n */\nint\n_hivex_get_children (hive_h *h, hive_node_h node,\n                     hive_node_h **children_ret, size_t **blocks_ret,\n                     int flags)\n{\n  if (!IS_VALID_BLOCK (h, node) || !block_id_eq (h, node, \"nk\")) {\n    SET_ERRNO (EINVAL, \"invalid block or not an 'nk' block\");\n    return -1;\n  }\n\n  struct ntreg_nk_record *nk =\n    (struct ntreg_nk_record *) ((char *) h->addr + node);\n\n  size_t nr_subkeys_in_nk = le32toh (nk->nr_subkeys);\n\n  offset_list children, blocks;\n  _hivex_init_offset_list (h, &children);\n  _hivex_init_offset_list (h, &blocks);\n\n  /* Deal with the common \"no subkeys\" case quickly. */\n  if (nr_subkeys_in_nk == 0)\n    goto out;\n\n  /* Arbitrarily limit the number of subkeys we will ever deal with. */\n  if (nr_subkeys_in_nk > HIVEX_MAX_SUBKEYS) {\n    SET_ERRNO (ERANGE,\n               \"nr_subkeys_in_nk > HIVEX_MAX_SUBKEYS (%zu > %d)\",\n               nr_subkeys_in_nk, HIVEX_MAX_SUBKEYS);\n    goto error;\n  }\n\n  /* Don't read more child nodes than the declared number of subkeys. */\n  _hivex_set_offset_list_limit (&children, nr_subkeys_in_nk);\n\n  /* Pre-1.3.8 hivex did not limit the number of intermediate blocks\n   * it would return, and there is no obvious limit to use.  However\n   * if we ever exceeded HIVEX_MAX_SUBKEYS then there's something\n   * fishy going on.\n   */\n  _hivex_set_offset_list_limit (&blocks, HIVEX_MAX_SUBKEYS);\n\n  /* Preallocate space for the children. */\n  if (_hivex_grow_offset_list (&children, nr_subkeys_in_nk) == -1)\n    goto error;\n\n  /* The subkey_lf field can point either to an lf-record, which is\n   * the common case, or if there are lots of subkeys, to an\n   * ri-record.\n   */\n  size_t subkey_lf = le32toh (nk->subkey_lf);\n  subkey_lf += 0x1000;\n  if (!IS_VALID_BLOCK (h, subkey_lf)) {\n    SET_ERRNO (EFAULT,\n               \"subkey_lf is not a valid block (0x%zx)\", subkey_lf);\n    goto error;\n  }\n\n  if (_get_children (h, subkey_lf, &children, &blocks, flags) == -1)\n    goto error;\n\n  /* Check the number of children we ended up reading matches\n   * nr_subkeys_in_nk.\n   */\n  size_t nr_children = _hivex_get_offset_list_length (&children);\n  if (nr_subkeys_in_nk != nr_children) {\n    if (!h->unsafe) {\n      SET_ERRNO (ENOTSUP,\n                 \"nr_subkeys_in_nk = %zu \"\n                 \"is not equal to number of children read %zu\",\n                 nr_subkeys_in_nk, nr_children);\n      goto error;\n    } else {\n      DEBUG (2,\n             \"nr_subkeys_in_nk = %zu \"\n             \"is not equal to number of children read %zu\",\n             nr_subkeys_in_nk, nr_children);\n    }\n  }\n\n out:\n#if 0\n  if (h->msglvl >= 2) {\n    fprintf (stderr, \"%s: %s: children = \", \"hivex\", __func__);\n    _hivex_print_offset_list (&children, stderr);\n    fprintf (stderr, \"\\n%s: %s: blocks = \", \"hivex\", __func__);\n    _hivex_print_offset_list (&blocks, stderr);\n    fprintf (stderr, \"\\n\");\n  }\n#endif\n\n  *children_ret = _hivex_return_offset_list (&children);\n  *blocks_ret = _hivex_return_offset_list (&blocks);\n  if (!*children_ret || !*blocks_ret)\n    goto error;\n  return 0;\n\n error:\n  _hivex_free_offset_list (&children);\n  _hivex_free_offset_list (&blocks);\n  return -1;\n}\n\nstatic int\n_get_children (hive_h *h, hive_node_h blkoff,\n               offset_list *children, offset_list *blocks,\n               int flags)\n{\n  /* Add this intermediate block. */\n  if (_hivex_add_to_offset_list (blocks, blkoff) == -1)\n    return -1;\n\n  struct ntreg_hbin_block *block =\n    (struct ntreg_hbin_block *) ((char *) h->addr + blkoff);\n\n  size_t len = block_len (h, blkoff, NULL);\n\n  /* Points to lf-record?  (Note, also \"lh\" but that is basically the\n   * same as \"lf\" as far as we are concerned here).\n   */\n  if (block->id[0] == 'l' && (block->id[1] == 'f' || block->id[1] == 'h')) {\n    struct ntreg_lf_record *lf = (struct ntreg_lf_record *) block;\n\n    /* Check number of subkeys in the nk-record matches number of subkeys\n     * in the lf-record.\n     */\n    size_t nr_subkeys_in_lf = le16toh (lf->nr_keys);\n\n    if (8 + nr_subkeys_in_lf * 8 > len) {\n      SET_ERRNO (EFAULT, \"too many subkeys (%zu, %zu)\", nr_subkeys_in_lf, len);\n      return -1;\n    }\n\n    size_t i;\n    for (i = 0; i < nr_subkeys_in_lf; ++i) {\n      hive_node_h subkey = le32toh (lf->keys[i].offset);\n      subkey += 0x1000;\n      if (check_child_is_nk_block (h, subkey, flags) == -1) {\n        if (h->unsafe) {\n          DEBUG (2, \"subkey at 0x%zx is not an NK block, skipping\", subkey);\n          continue;\n        } else {\n          return -1;\n        }\n      }\n      if (_hivex_add_to_offset_list (children, subkey) == -1)\n        return -1;\n    }\n  }\n  /* Points to li-record? */\n  else if (block->id[0] == 'l' && block->id[1] == 'i') {\n    /* li-records are formatted the same as ri-records, but they\n     * contain direct links to child records (same as lf/lh), so\n     * we treat them the same way as lf/lh.\n     */\n    struct ntreg_ri_record *ri = (struct ntreg_ri_record *) block;\n\n    /* Check number of subkeys in the nk-record matches number of subkeys\n     * in the li-record.\n     */\n    size_t nr_offsets = le16toh (ri->nr_offsets);\n\n    if (8 + nr_offsets * 4 > len) {\n      SET_ERRNO (EFAULT, \"too many offsets (%zu, %zu)\", nr_offsets, len);\n      return -1;\n    }\n\n    size_t i;\n    for (i = 0; i < nr_offsets; ++i) {\n      hive_node_h subkey = le32toh (ri->offset[i]);\n      subkey += 0x1000;\n      if (check_child_is_nk_block (h, subkey, flags) == -1) {\n        if (h->unsafe) {\n          DEBUG (2, \"subkey at 0x%zx is not an NK block, skipping\", subkey);\n          continue;\n        } else {\n          return -1;\n        }\n      }\n      if (_hivex_add_to_offset_list (children, subkey) == -1)\n        return -1;\n    }\n  }\n  /* Points to ri-record? */\n  else if (block->id[0] == 'r' && block->id[1] == 'i') {\n    struct ntreg_ri_record *ri = (struct ntreg_ri_record *) block;\n\n    size_t nr_offsets = le16toh (ri->nr_offsets);\n\n    if (8 + nr_offsets * 4 > len) {\n      SET_ERRNO (EFAULT, \"too many offsets (%zu, %zu)\", nr_offsets, len);\n      return -1;\n    }\n\n    /* Copy list of children. */\n    size_t i;\n    for (i = 0; i < nr_offsets; ++i) {\n      hive_node_h offset = le32toh (ri->offset[i]);\n      offset += 0x1000;\n      if (!IS_VALID_BLOCK (h, offset)) {\n        if (h->unsafe) {\n          DEBUG (2, \"ri-offset is not a valid block (0x%zx), skipping\", offset);\n          continue;\n        } else {\n          SET_ERRNO (EFAULT, \"ri-offset is not a valid block (0x%zx)\", offset);\n          return -1;\n        }\n      }\n\n      if (_get_children (h, offset, children, blocks, flags) == -1)\n        return -1;\n    }\n  }\n  else {\n    SET_ERRNO (ENOTSUP,\n               \"subkey block is not lf/lh/li/ri (0x%zx, %d, %d)\",\n               blkoff, block->id[0], block->id[1]);\n    return -1;\n  }\n\n  return 0;\n}\n\nstatic int\ncheck_child_is_nk_block (hive_h *h, hive_node_h child, int flags)\n{\n  /* Bypass the check if flag set. */\n  if (flags & GET_CHILDREN_NO_CHECK_NK)\n    return 0;\n\n  if (!IS_VALID_BLOCK (h, child)) {\n    SET_ERRNO (EFAULT, \"subkey is not a valid block (0x%zx)\", child);\n    return -1;\n  }\n\n  struct ntreg_hbin_block *block =\n    (struct ntreg_hbin_block *) ((char *) h->addr + child);\n\n  if (!block_id_eq (h, child, \"nk\")) {\n    SET_ERRNO (EFAULT, \"subkey is not an 'nk' block (0x%zx, %d, %d)\",\n               child, block->id[0], block->id[1]);\n    return -1;\n  }\n\n  return 0;\n}\n\nhive_node_h *\nhivex_node_children (hive_h *h, hive_node_h node)\n{\n  hive_node_h *children;\n  size_t *blocks;\n\n  if (_hivex_get_children (h, node, &children, &blocks, 0) == -1)\n    return NULL;\n\n  free (blocks);\n  return children;\n}\n\nsize_t\nhivex_node_nr_children (hive_h *h, hive_node_h node)\n{\n  if (!IS_VALID_BLOCK (h, node) || !block_id_eq (h, node, \"nk\")) {\n    SET_ERRNO( EINVAL, \"invalid block or not an 'nk' block\");\n    return 0;\n  }\n\n  struct ntreg_nk_record *nk =\n    (struct ntreg_nk_record *) ((char *) h->addr + node);\n\n  size_t nr_subkeys_in_nk = le32toh (nk->nr_subkeys);\n\n  return nr_subkeys_in_nk;\n}\n\n/* Very inefficient, but at least having a separate API call\n * allows us to make it more efficient in future.\n */\nhive_node_h\nhivex_node_get_child (hive_h *h, hive_node_h node, const char *nname)\n{\n  hive_node_h *children = NULL;\n  char *name = NULL;\n  hive_node_h ret = 0;\n\n  children = hivex_node_children (h, node);\n  if (!children) goto error;\n\n  size_t i;\n  for (i = 0; children[i] != 0; ++i) {\n    name = hivex_node_name (h, children[i]);\n    if (!name) goto error;\n    if (STRCASEEQ (name, nname)) {\n      ret = children[i];\n      break;\n    }\n    free (name); name = NULL;\n  }\n\n error:\n  free (children);\n  free (name);\n  return ret;\n}\n\nhive_node_h\nhivex_node_parent (hive_h *h, hive_node_h node)\n{\n  if (!IS_VALID_BLOCK (h, node) || !block_id_eq (h, node, \"nk\")) {\n    SET_ERRNO (EINVAL, \"invalid block or not an 'nk' block\");\n    return 0;\n  }\n\n  struct ntreg_nk_record *nk =\n    (struct ntreg_nk_record *) ((char *) h->addr + node);\n\n  hive_node_h ret = le32toh (nk->parent);\n  ret += 0x1000;\n  if (!IS_VALID_BLOCK (h, ret)) {\n    SET_ERRNO (EFAULT, \"parent is not a valid block (0x%zx)\", ret);\n    return 0;\n  }\n  return ret;\n}\n"], "fixing_code": ["/* hivex - Windows Registry \"hive\" extraction library.\n * Copyright (C) 2009-2011 Red Hat Inc.\n * Derived from code by Petter Nordahl-Hagen under a compatible license:\n *   Copyright (c) 1997-2007 Petter Nordahl-Hagen.\n * Derived from code by Markus Stephany under a compatible license:\n *   Copyright (c) 2000-2004, Markus Stephany.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation;\n * version 2.1 of the License.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * See file LICENSE for the full license.\n */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <inttypes.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <assert.h>\n\n#include \"c-ctype.h\"\n\n#include \"hivex.h\"\n#include \"hivex-internal.h\"\n\nhive_node_h\nhivex_root (hive_h *h)\n{\n  hive_node_h ret = h->rootoffs;\n  if (!IS_VALID_BLOCK (h, ret)) {\n    SET_ERRNO (HIVEX_NO_KEY, \"no root key\");\n    return 0;\n  }\n  return ret;\n}\n\nsize_t\nhivex_node_struct_length (hive_h *h, hive_node_h node)\n{\n  if (!IS_VALID_BLOCK (h, node) || !block_id_eq (h, node, \"nk\")) {\n    SET_ERRNO (EINVAL, \"invalid block or not an 'nk' block\");\n    return 0;\n  }\n\n  struct ntreg_nk_record *nk =\n    (struct ntreg_nk_record *) ((char *) h->addr + node);\n  size_t name_len = le16toh (nk->name_len);\n  /* -1 to avoid double-counting the first name character */\n  size_t ret = name_len + sizeof (struct ntreg_nk_record) - 1;\n  int used;\n  size_t seg_len = block_len (h, node, &used);\n  if (ret > seg_len) {\n    SET_ERRNO (EFAULT, \"node name is too long (%zu, %zu)\", name_len, seg_len);\n    return 0;\n  }\n  return ret;\n}\n\nchar *\nhivex_node_name (hive_h *h, hive_node_h node)\n{\n  if (!IS_VALID_BLOCK (h, node) || !block_id_eq (h, node, \"nk\")) {\n    SET_ERRNO (EINVAL, \"invalid block or not an 'nk' block\");\n    return NULL;\n  }\n\n  struct ntreg_nk_record *nk =\n    (struct ntreg_nk_record *) ((char *) h->addr + node);\n\n  /* nk->name_len is unsigned, 16 bit, so this is safe ...  However\n   * we have to make sure the length doesn't exceed the block length.\n   */\n  size_t len = le16toh (nk->name_len);\n  size_t seg_len = block_len (h, node, NULL);\n  if (sizeof (struct ntreg_nk_record) + len - 1 > seg_len) {\n    SET_ERRNO (EFAULT, \"node name is too long (%zu, %zu)\", len, seg_len);\n    return NULL;\n  }\n  size_t flags = le16toh (nk->flags);\n  if (flags & 0x20) {\n    return _hivex_recode (h, latin1_to_utf8, nk->name, len, NULL);\n  } else {\n    return _hivex_recode (h, utf16le_to_utf8, nk->name, len, NULL);\n  }\n}\n\nsize_t\nhivex_node_name_len (hive_h *h, hive_node_h node)\n{\n  if (!IS_VALID_BLOCK (h, node) || !block_id_eq (h, node, \"nk\")) {\n    SET_ERRNO (EINVAL, \"invalid block or not an 'nk' block\");\n    return 0;\n  }\n  struct ntreg_nk_record *nk =\n    (struct ntreg_nk_record *) ((char *) h->addr + node);\n\n  /* nk->name_len is unsigned, 16 bit, so this is safe ...  However\n   * we have to make sure the length doesn't exceed the block length.\n   */\n  size_t len = le16toh (nk->name_len);\n  size_t seg_len = block_len (h, node, NULL);\n  if (sizeof (struct ntreg_nk_record) + len - 1 > seg_len) {\n    SET_ERRNO (EFAULT, \"node name is too long (%zu, %zu)\", len, seg_len);\n    return 0;\n  }\n\n  return _hivex_utf8_strlen (h, nk->name, len, ! (le16toh (nk->flags) & 0x20));\n}\n\n\nstatic int64_t\ntimestamp_check (hive_h *h, hive_node_h node, int64_t timestamp)\n{\n  if (timestamp < 0) {\n    SET_ERRNO (EINVAL,\n               \"negative time reported at %zu: %\" PRIi64, node, timestamp);\n    return -1;\n  }\n\n  return timestamp;\n}\n\nint64_t\nhivex_last_modified (hive_h *h)\n{\n  return timestamp_check (h, 0, h->last_modified);\n}\n\nint64_t\nhivex_node_timestamp (hive_h *h, hive_node_h node)\n{\n  int64_t ret;\n\n  if (!IS_VALID_BLOCK (h, node) || !block_id_eq (h, node, \"nk\")) {\n    SET_ERRNO (EINVAL, \"invalid block or not an 'nk' block\");\n    return -1;\n  }\n\n  struct ntreg_nk_record *nk =\n    (struct ntreg_nk_record *) ((char *) h->addr + node);\n\n  ret = le64toh (nk->timestamp);\n  return timestamp_check (h, node, ret);\n}\n\n#if 0\n/* I think the documentation for the sk and classname fields in the nk\n * record is wrong, or else the offset field is in the wrong place.\n * Otherwise this makes no sense.  Disabled this for now -- it's not\n * useful for reading the registry anyway.\n */\n\nhive_security_h\nhivex_node_security (hive_h *h, hive_node_h node)\n{\n  if (!IS_VALID_BLOCK (h, node) || !block_id_eq (h, node, \"nk\")) {\n    SET_ERRNO (EINVAL, \"invalid block or not an 'nk' block\");\n    return 0;\n  }\n\n  struct ntreg_nk_record *nk = (struct ntreg_nk_record *) (h->addr + node);\n\n  hive_node_h ret = le32toh (nk->sk);\n  ret += 0x1000;\n  if (!IS_VALID_BLOCK (h, ret)) {\n    SET_ERRNO (EFAULT, \"invalid block\");\n    return 0;\n  }\n  return ret;\n}\n\nhive_classname_h\nhivex_node_classname (hive_h *h, hive_node_h node)\n{\n  if (!IS_VALID_BLOCK (h, node) || !block_id_eq (h, node, \"nk\")) {\n    SET_ERRNO (EINVAL, \"invalid block or not an 'nk' block\");\n    return 0;\n  }\n\n  struct ntreg_nk_record *nk = (struct ntreg_nk_record *) (h->addr + node);\n\n  hive_node_h ret = le32toh (nk->classname);\n  ret += 0x1000;\n  if (!IS_VALID_BLOCK (h, ret)) {\n    SET_ERRNO (EFAULT, \"invalid block\");\n    return 0;\n  }\n  return ret;\n}\n#endif\n\nstatic int _get_children (hive_h *h, hive_node_h blkoff,\n                          offset_list *children, offset_list *blocks,\n                          int flags, unsigned depth);\nstatic int check_child_is_nk_block (hive_h *h, hive_node_h child, int flags);\n\n/* Iterate over children (ie. subkeys of a node), returning child\n * nodes and intermediate blocks.\n *\n * 'node' is the nk block.\n *\n * 'flags' can be 0, or GET_CHILDREN_NO_CHECK_NK which bypasses a\n * check that each child is a valid block.\n *\n * The list of child nodes (all nk blocks) is returned in\n * 'children_ret'.\n *\n * The list of intermediate nodes (a mix of lf/lh/ri/li blocks) is\n * returned in 'blocks_ret'.\n *\n * ----------------------------------------\n *\n * The format of the intermediate blocks is not documented, but\n * appears to be this:\n *\n * +-------------+  This is the parent registry key.\n * | nk          |\n * |-------------|\n * | subkey_lf  ---->  Points to either lf/lh, li or ri\n * |             |     (all 3 cases have to be dealt with\n * |             |     separately, see below)\n * +-------------+\n *\n * The subkey_lf field can point to one of three things, which are\n * all subtly different:\n *\n * (1) lf/lh record.  (It's not clear what the precise difference\n * is but we treat them as the same thing)\n *\n * +-------------+\n * | lf/lh       |\n * |-------------|\n * | nr_keys     |\n * |   keys[0].offset ------>  points to nk blocks (the children)\n * |   keys[1].offset ------>\n * |   keys[2].offset ------>\n * +-------------+\n *\n * (2) li record.\n *\n * Although the format of an li-record is the same as the format of an\n * ri-record, the difference is that the offsets point directly to the\n * nk blocks (children).\n *\n * +-------------+\n * | li          |\n * |-------------|\n * | nr_offsets  |\n * |   offset[0] ------>  points to nk blocks (the children)\n * |   offset[1] ------>\n * |   offset[2] ------>\n * +-------------+\n *\n * (3) ri record.\n *\n * The format of the block is the same as the li-record, BUT ri-record\n * offsets *never* point directly to nk blocks.  They only point to\n * other lf/lh/li/ri-records, thus forming a tree of arbitrary depth.\n *\n * +-------------+\n * | ri          |\n * |-------------|\n * | nr_offsets  |\n * |   offset[0] ------>  points to another lf/lh/li/ri block\n * |   offset[1] ------>\n * |   offset[2] ------>\n * +-------------+\n */\nint\n_hivex_get_children (hive_h *h, hive_node_h node,\n                     hive_node_h **children_ret, size_t **blocks_ret,\n                     int flags)\n{\n  if (!IS_VALID_BLOCK (h, node) || !block_id_eq (h, node, \"nk\")) {\n    SET_ERRNO (EINVAL, \"invalid block or not an 'nk' block\");\n    return -1;\n  }\n\n  struct ntreg_nk_record *nk =\n    (struct ntreg_nk_record *) ((char *) h->addr + node);\n\n  size_t nr_subkeys_in_nk = le32toh (nk->nr_subkeys);\n\n  offset_list children, blocks;\n  _hivex_init_offset_list (h, &children);\n  _hivex_init_offset_list (h, &blocks);\n\n  /* Deal with the common \"no subkeys\" case quickly. */\n  if (nr_subkeys_in_nk == 0)\n    goto out;\n\n  /* Arbitrarily limit the number of subkeys we will ever deal with. */\n  if (nr_subkeys_in_nk > HIVEX_MAX_SUBKEYS) {\n    SET_ERRNO (ERANGE,\n               \"nr_subkeys_in_nk > HIVEX_MAX_SUBKEYS (%zu > %d)\",\n               nr_subkeys_in_nk, HIVEX_MAX_SUBKEYS);\n    goto error;\n  }\n\n  /* Don't read more child nodes than the declared number of subkeys. */\n  _hivex_set_offset_list_limit (&children, nr_subkeys_in_nk);\n\n  /* Pre-1.3.8 hivex did not limit the number of intermediate blocks\n   * it would return, and there is no obvious limit to use.  However\n   * if we ever exceeded HIVEX_MAX_SUBKEYS then there's something\n   * fishy going on.\n   */\n  _hivex_set_offset_list_limit (&blocks, HIVEX_MAX_SUBKEYS);\n\n  /* Preallocate space for the children. */\n  if (_hivex_grow_offset_list (&children, nr_subkeys_in_nk) == -1)\n    goto error;\n\n  /* The subkey_lf field can point either to an lf-record, which is\n   * the common case, or if there are lots of subkeys, to an\n   * ri-record.\n   */\n  size_t subkey_lf = le32toh (nk->subkey_lf);\n  subkey_lf += 0x1000;\n  if (!IS_VALID_BLOCK (h, subkey_lf)) {\n    SET_ERRNO (EFAULT,\n               \"subkey_lf is not a valid block (0x%zx)\", subkey_lf);\n    goto error;\n  }\n\n  if (_get_children (h, subkey_lf, &children, &blocks, flags, 0) == -1)\n    goto error;\n\n  /* Check the number of children we ended up reading matches\n   * nr_subkeys_in_nk.\n   */\n  size_t nr_children = _hivex_get_offset_list_length (&children);\n  if (nr_subkeys_in_nk != nr_children) {\n    if (!h->unsafe) {\n      SET_ERRNO (ENOTSUP,\n                 \"nr_subkeys_in_nk = %zu \"\n                 \"is not equal to number of children read %zu\",\n                 nr_subkeys_in_nk, nr_children);\n      goto error;\n    } else {\n      DEBUG (2,\n             \"nr_subkeys_in_nk = %zu \"\n             \"is not equal to number of children read %zu\",\n             nr_subkeys_in_nk, nr_children);\n    }\n  }\n\n out:\n#if 0\n  if (h->msglvl >= 2) {\n    fprintf (stderr, \"%s: %s: children = \", \"hivex\", __func__);\n    _hivex_print_offset_list (&children, stderr);\n    fprintf (stderr, \"\\n%s: %s: blocks = \", \"hivex\", __func__);\n    _hivex_print_offset_list (&blocks, stderr);\n    fprintf (stderr, \"\\n\");\n  }\n#endif\n\n  *children_ret = _hivex_return_offset_list (&children);\n  *blocks_ret = _hivex_return_offset_list (&blocks);\n  if (!*children_ret || !*blocks_ret)\n    goto error;\n  return 0;\n\n error:\n  _hivex_free_offset_list (&children);\n  _hivex_free_offset_list (&blocks);\n  return -1;\n}\n\nstatic int\n_get_children (hive_h *h, hive_node_h blkoff,\n               offset_list *children, offset_list *blocks,\n               int flags, unsigned depth)\n{\n  /* Add this intermediate block. */\n  if (_hivex_add_to_offset_list (blocks, blkoff) == -1)\n    return -1;\n\n  struct ntreg_hbin_block *block =\n    (struct ntreg_hbin_block *) ((char *) h->addr + blkoff);\n\n  size_t len = block_len (h, blkoff, NULL);\n\n  /* Points to lf-record?  (Note, also \"lh\" but that is basically the\n   * same as \"lf\" as far as we are concerned here).\n   */\n  if (block->id[0] == 'l' && (block->id[1] == 'f' || block->id[1] == 'h')) {\n    struct ntreg_lf_record *lf = (struct ntreg_lf_record *) block;\n\n    /* Check number of subkeys in the nk-record matches number of subkeys\n     * in the lf-record.\n     */\n    size_t nr_subkeys_in_lf = le16toh (lf->nr_keys);\n\n    if (8 + nr_subkeys_in_lf * 8 > len) {\n      SET_ERRNO (EFAULT, \"too many subkeys (%zu, %zu)\", nr_subkeys_in_lf, len);\n      return -1;\n    }\n\n    size_t i;\n    for (i = 0; i < nr_subkeys_in_lf; ++i) {\n      hive_node_h subkey = le32toh (lf->keys[i].offset);\n      subkey += 0x1000;\n      if (check_child_is_nk_block (h, subkey, flags) == -1) {\n        if (h->unsafe) {\n          DEBUG (2, \"subkey at 0x%zx is not an NK block, skipping\", subkey);\n          continue;\n        } else {\n          return -1;\n        }\n      }\n      if (_hivex_add_to_offset_list (children, subkey) == -1)\n        return -1;\n    }\n  }\n  /* Points to li-record? */\n  else if (block->id[0] == 'l' && block->id[1] == 'i') {\n    /* li-records are formatted the same as ri-records, but they\n     * contain direct links to child records (same as lf/lh), so\n     * we treat them the same way as lf/lh.\n     */\n    struct ntreg_ri_record *ri = (struct ntreg_ri_record *) block;\n\n    /* Check number of subkeys in the nk-record matches number of subkeys\n     * in the li-record.\n     */\n    size_t nr_offsets = le16toh (ri->nr_offsets);\n\n    if (8 + nr_offsets * 4 > len) {\n      SET_ERRNO (EFAULT, \"too many offsets (%zu, %zu)\", nr_offsets, len);\n      return -1;\n    }\n\n    size_t i;\n    for (i = 0; i < nr_offsets; ++i) {\n      hive_node_h subkey = le32toh (ri->offset[i]);\n      subkey += 0x1000;\n      if (check_child_is_nk_block (h, subkey, flags) == -1) {\n        if (h->unsafe) {\n          DEBUG (2, \"subkey at 0x%zx is not an NK block, skipping\", subkey);\n          continue;\n        } else {\n          return -1;\n        }\n      }\n      if (_hivex_add_to_offset_list (children, subkey) == -1)\n        return -1;\n    }\n  }\n  /* Points to ri-record? */\n  else if (block->id[0] == 'r' && block->id[1] == 'i') {\n    struct ntreg_ri_record *ri = (struct ntreg_ri_record *) block;\n\n    size_t nr_offsets = le16toh (ri->nr_offsets);\n\n    if (8 + nr_offsets * 4 > len) {\n      SET_ERRNO (EFAULT, \"too many offsets (%zu, %zu)\", nr_offsets, len);\n      return -1;\n    }\n\n    /* Copy list of children. */\n    size_t i;\n    for (i = 0; i < nr_offsets; ++i) {\n      hive_node_h offset = le32toh (ri->offset[i]);\n      offset += 0x1000;\n      if (!IS_VALID_BLOCK (h, offset)) {\n        if (h->unsafe) {\n          DEBUG (2, \"ri-offset is not a valid block (0x%zx), skipping\", offset);\n          continue;\n        } else {\n          SET_ERRNO (EFAULT, \"ri-offset is not a valid block (0x%zx)\", offset);\n          return -1;\n        }\n      }\n\n      /* Although in theory hive ri records might be nested to any\n       * depth, in practice this is unlikely.  Recursing here caused\n       * CVE-2021-3622.  Thus limit the depth we will recurse to\n       * something small.\n       */\n      if (depth >= 32) {\n        SET_ERRNO (EINVAL, \"ri-record nested to depth >= %u\", depth);\n        return -1;\n      }\n\n      if (_get_children (h, offset, children, blocks, flags, depth+1) == -1)\n        return -1;\n    }\n  }\n  else {\n    SET_ERRNO (ENOTSUP,\n               \"subkey block is not lf/lh/li/ri (0x%zx, %d, %d)\",\n               blkoff, block->id[0], block->id[1]);\n    return -1;\n  }\n\n  return 0;\n}\n\nstatic int\ncheck_child_is_nk_block (hive_h *h, hive_node_h child, int flags)\n{\n  /* Bypass the check if flag set. */\n  if (flags & GET_CHILDREN_NO_CHECK_NK)\n    return 0;\n\n  if (!IS_VALID_BLOCK (h, child)) {\n    SET_ERRNO (EFAULT, \"subkey is not a valid block (0x%zx)\", child);\n    return -1;\n  }\n\n  struct ntreg_hbin_block *block =\n    (struct ntreg_hbin_block *) ((char *) h->addr + child);\n\n  if (!block_id_eq (h, child, \"nk\")) {\n    SET_ERRNO (EFAULT, \"subkey is not an 'nk' block (0x%zx, %d, %d)\",\n               child, block->id[0], block->id[1]);\n    return -1;\n  }\n\n  return 0;\n}\n\nhive_node_h *\nhivex_node_children (hive_h *h, hive_node_h node)\n{\n  hive_node_h *children;\n  size_t *blocks;\n\n  if (_hivex_get_children (h, node, &children, &blocks, 0) == -1)\n    return NULL;\n\n  free (blocks);\n  return children;\n}\n\nsize_t\nhivex_node_nr_children (hive_h *h, hive_node_h node)\n{\n  if (!IS_VALID_BLOCK (h, node) || !block_id_eq (h, node, \"nk\")) {\n    SET_ERRNO( EINVAL, \"invalid block or not an 'nk' block\");\n    return 0;\n  }\n\n  struct ntreg_nk_record *nk =\n    (struct ntreg_nk_record *) ((char *) h->addr + node);\n\n  size_t nr_subkeys_in_nk = le32toh (nk->nr_subkeys);\n\n  return nr_subkeys_in_nk;\n}\n\n/* Very inefficient, but at least having a separate API call\n * allows us to make it more efficient in future.\n */\nhive_node_h\nhivex_node_get_child (hive_h *h, hive_node_h node, const char *nname)\n{\n  hive_node_h *children = NULL;\n  char *name = NULL;\n  hive_node_h ret = 0;\n\n  children = hivex_node_children (h, node);\n  if (!children) goto error;\n\n  size_t i;\n  for (i = 0; children[i] != 0; ++i) {\n    name = hivex_node_name (h, children[i]);\n    if (!name) goto error;\n    if (STRCASEEQ (name, nname)) {\n      ret = children[i];\n      break;\n    }\n    free (name); name = NULL;\n  }\n\n error:\n  free (children);\n  free (name);\n  return ret;\n}\n\nhive_node_h\nhivex_node_parent (hive_h *h, hive_node_h node)\n{\n  if (!IS_VALID_BLOCK (h, node) || !block_id_eq (h, node, \"nk\")) {\n    SET_ERRNO (EINVAL, \"invalid block or not an 'nk' block\");\n    return 0;\n  }\n\n  struct ntreg_nk_record *nk =\n    (struct ntreg_nk_record *) ((char *) h->addr + node);\n\n  hive_node_h ret = le32toh (nk->parent);\n  ret += 0x1000;\n  if (!IS_VALID_BLOCK (h, ret)) {\n    SET_ERRNO (EFAULT, \"parent is not a valid block (0x%zx)\", ret);\n    return 0;\n  }\n  return ret;\n}\n"], "filenames": ["lib/node.c"], "buggy_code_start_loc": [206], "buggy_code_end_loc": [490], "fixing_code_start_loc": [206], "fixing_code_end_loc": [500], "type": "CWE-400", "message": "A flaw was found in the hivex library. This flaw allows an attacker to input a specially crafted Windows Registry (hive) file, which would cause hivex to recursively call the _get_children() function, leading to a stack overflow. The highest threat from this vulnerability is to system availability.", "other": {"cve": {"id": "CVE-2021-3622", "sourceIdentifier": "secalert@redhat.com", "published": "2021-12-23T21:15:08.970", "lastModified": "2022-01-10T13:37:40.983", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A flaw was found in the hivex library. This flaw allows an attacker to input a specially crafted Windows Registry (hive) file, which would cause hivex to recursively call the _get_children() function, leading to a stack overflow. The highest threat from this vulnerability is to system availability."}, {"lang": "es", "value": "Se ha encontrado un fallo en hivex library. Este fallo permite a un atacante introducir un archivo del Registro de Windows (hive) especialmente dise\u00f1ado, lo que causar\u00eda que hivex llamara recursivamente a la funci\u00f3n _get_children(), conllevando a un desbordamiento de pila. La mayor amenaza de esta vulnerabilidad es la disponibilidad del sistema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:hivex:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.3.21", "matchCriteriaId": "531F2416-1F30-40A2-81EA-13A0A07BD8D5"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "2F6AB192-9D7D-4A9A-8995-E53A9DE9EAFC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:-:*:*:*", "matchCriteriaId": "053C1B35-3869-41C2-9551-044182DE0A64"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:advanced_virtualization:*:*:*", "matchCriteriaId": "3AA08768-75AF-4791-B229-AE938C780959"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1975489", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/libguestfs/hivex/commit/771728218dac2fbf6997a7e53225e75a4c6b7255", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://listman.redhat.com/archives/libguestfs/2021-August/msg00002.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/S35TVTAPHORSUIFYNFBHKLQRPVFUPXBE/", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/USD4OEV6L3RPHE32V2MJ4JPFBODINWSU/", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libguestfs/hivex/commit/771728218dac2fbf6997a7e53225e75a4c6b7255"}}