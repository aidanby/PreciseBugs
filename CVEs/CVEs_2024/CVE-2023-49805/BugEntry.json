{"buggy_code": ["/*\n * Uptime Kuma Server\n * node \"server/server.js\"\n * DO NOT require(\"./server\") in other modules, it likely creates circular dependency!\n */\nconsole.log(\"Welcome to Uptime Kuma\");\n\n// As the log function need to use dayjs, it should be very top\nconst dayjs = require(\"dayjs\");\ndayjs.extend(require(\"dayjs/plugin/utc\"));\ndayjs.extend(require(\"./modules/dayjs/plugin/timezone\"));\ndayjs.extend(require(\"dayjs/plugin/customParseFormat\"));\n\n// Load environment variables from `.env`\nrequire(\"dotenv\").config();\n\n// Check Node.js Version\nconst nodeVersion = process.versions.node;\n\n// Get the required Node.js version from package.json\nconst requiredNodeVersions = require(\"../package.json\").engines.node;\nconst bannedNodeVersions = \" < 14 || 20.0.* || 20.1.* || 20.2.* || 20.3.* \";\nconsole.log(`Your Node.js version: ${nodeVersion}`);\n\nconst semver = require(\"semver\");\nconst requiredNodeVersionsComma = requiredNodeVersions.split(\"||\").map((version) => version.trim()).join(\", \");\n\n// Exit Uptime Kuma immediately if the Node.js version is banned\nif (semver.satisfies(nodeVersion, bannedNodeVersions)) {\n    console.error(\"\\x1b[31m%s\\x1b[0m\", `Error: Your Node.js version: ${nodeVersion} is not supported, please upgrade your Node.js to ${requiredNodeVersionsComma}.`);\n    process.exit(-1);\n}\n\n// Warning if the Node.js version is not in the support list, but it maybe still works\nif (!semver.satisfies(nodeVersion, requiredNodeVersions)) {\n    console.warn(\"\\x1b[31m%s\\x1b[0m\", `Warning: Your Node.js version: ${nodeVersion} is not officially supported, please upgrade your Node.js to ${requiredNodeVersionsComma}.`);\n}\n\nconst args = require(\"args-parser\")(process.argv);\nconst { sleep, log, getRandomInt, genSecret, isDev } = require(\"../src/util\");\nconst config = require(\"./config\");\n\nlog.info(\"server\", \"Welcome to Uptime Kuma\");\nlog.debug(\"server\", \"Arguments\");\nlog.debug(\"server\", args);\n\nif (! process.env.NODE_ENV) {\n    process.env.NODE_ENV = \"production\";\n}\n\nlog.info(\"server\", \"Node Env: \" + process.env.NODE_ENV);\nlog.info(\"server\", \"Inside Container: \" + (process.env.UPTIME_KUMA_IS_CONTAINER === \"1\"));\n\nlog.info(\"server\", \"Importing Node libraries\");\nconst fs = require(\"fs\");\n\nlog.info(\"server\", \"Importing 3rd-party libraries\");\n\nlog.debug(\"server\", \"Importing express\");\nconst express = require(\"express\");\nconst expressStaticGzip = require(\"express-static-gzip\");\nlog.debug(\"server\", \"Importing redbean-node\");\nconst { R } = require(\"redbean-node\");\nlog.debug(\"server\", \"Importing jsonwebtoken\");\nconst jwt = require(\"jsonwebtoken\");\nlog.debug(\"server\", \"Importing http-graceful-shutdown\");\nconst gracefulShutdown = require(\"http-graceful-shutdown\");\nlog.debug(\"server\", \"Importing prometheus-api-metrics\");\nconst prometheusAPIMetrics = require(\"prometheus-api-metrics\");\nlog.debug(\"server\", \"Importing compare-versions\");\nconst compareVersions = require(\"compare-versions\");\nconst { passwordStrength } = require(\"check-password-strength\");\n\nlog.debug(\"server\", \"Importing 2FA Modules\");\nconst notp = require(\"notp\");\nconst base32 = require(\"thirty-two\");\n\nconst { UptimeKumaServer } = require(\"./uptime-kuma-server\");\nconst server = UptimeKumaServer.getInstance(args);\nconst io = module.exports.io = server.io;\nconst app = server.app;\n\nlog.info(\"server\", \"Importing this project modules\");\nlog.debug(\"server\", \"Importing Monitor\");\nconst Monitor = require(\"./model/monitor\");\nconst User = require(\"./model/user\");\n\nlog.debug(\"server\", \"Importing Settings\");\nconst { getSettings, setSettings, setting, initJWTSecret, checkLogin, startUnitTest, FBSD, doubleCheckPassword, startE2eTests, shake256, SHAKE256_LENGTH\n} = require(\"./util-server\");\n\nlog.debug(\"server\", \"Importing Notification\");\nconst { Notification } = require(\"./notification\");\nNotification.init();\n\nlog.debug(\"server\", \"Importing Proxy\");\nconst { Proxy } = require(\"./proxy\");\n\nlog.debug(\"server\", \"Importing Database\");\nconst Database = require(\"./database\");\n\nlog.debug(\"server\", \"Importing Background Jobs\");\nconst { initBackgroundJobs, stopBackgroundJobs } = require(\"./jobs\");\nconst { loginRateLimiter, twoFaRateLimiter } = require(\"./rate-limiter\");\n\nconst { apiAuth } = require(\"./auth\");\nconst { login } = require(\"./auth\");\nconst passwordHash = require(\"./password-hash\");\n\nconst checkVersion = require(\"./check-version\");\nlog.info(\"server\", \"Version: \" + checkVersion.version);\n\n// If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available and the unspecified IPv4 address (0.0.0.0) otherwise.\n// Dual-stack support for (::)\n// Also read HOST if not FreeBSD, as HOST is a system environment variable in FreeBSD\nlet hostEnv = FBSD ? null : process.env.HOST;\nlet hostname = args.host || process.env.UPTIME_KUMA_HOST || hostEnv;\n\nif (hostname) {\n    log.info(\"server\", \"Custom hostname: \" + hostname);\n}\n\nconst port = [ args.port, process.env.UPTIME_KUMA_PORT, process.env.PORT, 3001 ]\n    .map(portValue => parseInt(portValue))\n    .find(portValue => !isNaN(portValue));\n\nconst disableFrameSameOrigin = !!process.env.UPTIME_KUMA_DISABLE_FRAME_SAMEORIGIN || args[\"disable-frame-sameorigin\"] || false;\nconst cloudflaredToken = args[\"cloudflared-token\"] || process.env.UPTIME_KUMA_CLOUDFLARED_TOKEN || undefined;\n\n// 2FA / notp verification defaults\nconst twoFAVerifyOptions = {\n    \"window\": 1,\n    \"time\": 30\n};\n\n/**\n * Run unit test after the server is ready\n * @type {boolean}\n */\nconst testMode = !!args[\"test\"] || false;\nconst e2eTestMode = !!args[\"e2e\"] || false;\n\nif (config.demoMode) {\n    log.info(\"server\", \"==== Demo Mode ====\");\n}\n\n// Must be after io instantiation\nconst { sendNotificationList, sendHeartbeatList, sendImportantHeartbeatList, sendInfo, sendProxyList, sendDockerHostList, sendAPIKeyList } = require(\"./client\");\nconst { statusPageSocketHandler } = require(\"./socket-handlers/status-page-socket-handler\");\nconst databaseSocketHandler = require(\"./socket-handlers/database-socket-handler\");\nconst TwoFA = require(\"./2fa\");\nconst StatusPage = require(\"./model/status_page\");\nconst { cloudflaredSocketHandler, autoStart: cloudflaredAutoStart, stop: cloudflaredStop } = require(\"./socket-handlers/cloudflared-socket-handler\");\nconst { proxySocketHandler } = require(\"./socket-handlers/proxy-socket-handler\");\nconst { dockerSocketHandler } = require(\"./socket-handlers/docker-socket-handler\");\nconst { maintenanceSocketHandler } = require(\"./socket-handlers/maintenance-socket-handler\");\nconst { apiKeySocketHandler } = require(\"./socket-handlers/api-key-socket-handler\");\nconst { generalSocketHandler } = require(\"./socket-handlers/general-socket-handler\");\nconst { Settings } = require(\"./settings\");\nconst { CacheableDnsHttpAgent } = require(\"./cacheable-dns-http-agent\");\nconst apicache = require(\"./modules/apicache\");\nconst { resetChrome } = require(\"./monitor-types/real-browser-monitor-type\");\n\napp.use(express.json());\n\n// Global Middleware\napp.use(function (req, res, next) {\n    if (!disableFrameSameOrigin) {\n        res.setHeader(\"X-Frame-Options\", \"SAMEORIGIN\");\n    }\n    res.removeHeader(\"X-Powered-By\");\n    next();\n});\n\n/**\n * Show Setup Page\n * @type {boolean}\n */\nlet needSetup = false;\n\n(async () => {\n    Database.init(args);\n    await initDatabase(testMode);\n    await server.initAfterDatabaseReady();\n    server.entryPage = await Settings.get(\"entryPage\");\n    await StatusPage.loadDomainMappingList();\n\n    log.info(\"server\", \"Adding route\");\n\n    // ***************************\n    // Normal Router here\n    // ***************************\n\n    // Entry Page\n    app.get(\"/\", async (request, response) => {\n        let hostname = request.hostname;\n        if (await setting(\"trustProxy\")) {\n            const proxy = request.headers[\"x-forwarded-host\"];\n            if (proxy) {\n                hostname = proxy;\n            }\n        }\n\n        log.debug(\"entry\", `Request Domain: ${hostname}`);\n\n        const uptimeKumaEntryPage = server.entryPage;\n        if (hostname in StatusPage.domainMappingList) {\n            log.debug(\"entry\", \"This is a status page domain\");\n\n            let slug = StatusPage.domainMappingList[hostname];\n            await StatusPage.handleStatusPageResponse(response, server.indexHTML, slug);\n\n        } else if (uptimeKumaEntryPage && uptimeKumaEntryPage.startsWith(\"statusPage-\")) {\n            response.redirect(\"/status/\" + uptimeKumaEntryPage.replace(\"statusPage-\", \"\"));\n\n        } else {\n            response.redirect(\"/dashboard\");\n        }\n    });\n\n    if (isDev) {\n        app.use(express.urlencoded({ extended: true }));\n        app.post(\"/test-webhook\", async (request, response) => {\n            log.debug(\"test\", request.headers);\n            log.debug(\"test\", request.body);\n            response.send(\"OK\");\n        });\n    }\n\n    // Robots.txt\n    app.get(\"/robots.txt\", async (_request, response) => {\n        let txt = \"User-agent: *\\nDisallow:\";\n        if (!await setting(\"searchEngineIndex\")) {\n            txt += \" /\";\n        }\n        response.setHeader(\"Content-Type\", \"text/plain\");\n        response.send(txt);\n    });\n\n    // Basic Auth Router here\n\n    // Prometheus API metrics  /metrics\n    // With Basic Auth using the first user's username/password\n    app.get(\"/metrics\", apiAuth, prometheusAPIMetrics());\n\n    app.use(\"/\", expressStaticGzip(\"dist\", {\n        enableBrotli: true,\n    }));\n\n    // ./data/upload\n    app.use(\"/upload\", express.static(Database.uploadDir));\n\n    app.get(\"/.well-known/change-password\", async (_, response) => {\n        response.redirect(\"https://github.com/louislam/uptime-kuma/wiki/Reset-Password-via-CLI\");\n    });\n\n    // API Router\n    const apiRouter = require(\"./routers/api-router\");\n    app.use(apiRouter);\n\n    // Status Page Router\n    const statusPageRouter = require(\"./routers/status-page-router\");\n    app.use(statusPageRouter);\n\n    // Universal Route Handler, must be at the end of all express routes.\n    app.get(\"*\", async (_request, response) => {\n        if (_request.originalUrl.startsWith(\"/upload/\")) {\n            response.status(404).send(\"File not found.\");\n        } else {\n            response.send(server.indexHTML);\n        }\n    });\n\n    log.info(\"server\", \"Adding socket handler\");\n    io.on(\"connection\", async (socket) => {\n\n        sendInfo(socket, true);\n\n        if (needSetup) {\n            log.info(\"server\", \"Redirect to setup page\");\n            socket.emit(\"setup\");\n        }\n\n        // ***************************\n        // Public Socket API\n        // ***************************\n\n        socket.on(\"loginByToken\", async (token, callback) => {\n            const clientIP = await server.getClientIP(socket);\n\n            log.info(\"auth\", `Login by token. IP=${clientIP}`);\n\n            try {\n                let decoded = jwt.verify(token, server.jwtSecret);\n\n                log.info(\"auth\", \"Username from JWT: \" + decoded.username);\n\n                let user = await R.findOne(\"user\", \" username = ? AND active = 1 \", [\n                    decoded.username,\n                ]);\n\n                if (user) {\n                    // Check if the password changed\n                    if (decoded.h !== shake256(user.password, SHAKE256_LENGTH)) {\n                        throw new Error(\"The token is invalid due to password change or old token\");\n                    }\n\n                    log.debug(\"auth\", \"afterLogin\");\n                    afterLogin(socket, user);\n                    log.debug(\"auth\", \"afterLogin ok\");\n\n                    log.info(\"auth\", `Successfully logged in user ${decoded.username}. IP=${clientIP}`);\n\n                    callback({\n                        ok: true,\n                    });\n                } else {\n\n                    log.info(\"auth\", `Inactive or deleted user ${decoded.username}. IP=${clientIP}`);\n\n                    callback({\n                        ok: false,\n                        msg: \"The user is inactive or deleted.\",\n                    });\n                }\n            } catch (error) {\n                log.error(\"auth\", `Invalid token. IP=${clientIP}`);\n                if (error.message) {\n                    log.error(\"auth\", error.message, `IP=${clientIP}`);\n                }\n                callback({\n                    ok: false,\n                    msg: \"Invalid token.\",\n                });\n            }\n\n        });\n\n        socket.on(\"login\", async (data, callback) => {\n            const clientIP = await server.getClientIP(socket);\n\n            log.info(\"auth\", `Login by username + password. IP=${clientIP}`);\n\n            // Checking\n            if (typeof callback !== \"function\") {\n                return;\n            }\n\n            if (!data) {\n                return;\n            }\n\n            // Login Rate Limit\n            if (! await loginRateLimiter.pass(callback)) {\n                log.info(\"auth\", `Too many failed requests for user ${data.username}. IP=${clientIP}`);\n                return;\n            }\n\n            let user = await login(data.username, data.password);\n\n            if (user) {\n                if (user.twofa_status === 0) {\n                    afterLogin(socket, user);\n\n                    log.info(\"auth\", `Successfully logged in user ${data.username}. IP=${clientIP}`);\n\n                    callback({\n                        ok: true,\n                        token: User.createJWT(user, server.jwtSecret),\n                    });\n                }\n\n                if (user.twofa_status === 1 && !data.token) {\n\n                    log.info(\"auth\", `2FA token required for user ${data.username}. IP=${clientIP}`);\n\n                    callback({\n                        tokenRequired: true,\n                    });\n                }\n\n                if (data.token) {\n                    let verify = notp.totp.verify(data.token, user.twofa_secret, twoFAVerifyOptions);\n\n                    if (user.twofa_last_token !== data.token && verify) {\n                        afterLogin(socket, user);\n\n                        await R.exec(\"UPDATE `user` SET twofa_last_token = ? WHERE id = ? \", [\n                            data.token,\n                            socket.userID,\n                        ]);\n\n                        log.info(\"auth\", `Successfully logged in user ${data.username}. IP=${clientIP}`);\n\n                        callback({\n                            ok: true,\n                            token: User.createJWT(user, server.jwtSecret),\n                        });\n                    } else {\n\n                        log.warn(\"auth\", `Invalid token provided for user ${data.username}. IP=${clientIP}`);\n\n                        callback({\n                            ok: false,\n                            msg: \"Invalid Token!\",\n                        });\n                    }\n                }\n            } else {\n\n                log.warn(\"auth\", `Incorrect username or password for user ${data.username}. IP=${clientIP}`);\n\n                callback({\n                    ok: false,\n                    msg: \"Incorrect username or password.\",\n                });\n            }\n\n        });\n\n        socket.on(\"logout\", async (callback) => {\n            // Rate Limit\n            if (! await loginRateLimiter.pass(callback)) {\n                return;\n            }\n\n            socket.leave(socket.userID);\n            socket.userID = null;\n\n            if (typeof callback === \"function\") {\n                callback();\n            }\n        });\n\n        socket.on(\"prepare2FA\", async (currentPassword, callback) => {\n            try {\n                if (! await twoFaRateLimiter.pass(callback)) {\n                    return;\n                }\n\n                checkLogin(socket);\n                await doubleCheckPassword(socket, currentPassword);\n\n                let user = await R.findOne(\"user\", \" id = ? AND active = 1 \", [\n                    socket.userID,\n                ]);\n\n                if (user.twofa_status === 0) {\n                    let newSecret = genSecret();\n                    let encodedSecret = base32.encode(newSecret);\n\n                    // Google authenticator doesn't like equal signs\n                    // The fix is found at https://github.com/guyht/notp\n                    // Related issue: https://github.com/louislam/uptime-kuma/issues/486\n                    encodedSecret = encodedSecret.toString().replace(/=/g, \"\");\n\n                    let uri = `otpauth://totp/Uptime%20Kuma:${user.username}?secret=${encodedSecret}`;\n\n                    await R.exec(\"UPDATE `user` SET twofa_secret = ? WHERE id = ? \", [\n                        newSecret,\n                        socket.userID,\n                    ]);\n\n                    callback({\n                        ok: true,\n                        uri: uri,\n                    });\n                } else {\n                    callback({\n                        ok: false,\n                        msg: \"2FA is already enabled.\",\n                    });\n                }\n            } catch (error) {\n                callback({\n                    ok: false,\n                    msg: error.message,\n                });\n            }\n        });\n\n        socket.on(\"save2FA\", async (currentPassword, callback) => {\n            const clientIP = await server.getClientIP(socket);\n\n            try {\n                if (! await twoFaRateLimiter.pass(callback)) {\n                    return;\n                }\n\n                checkLogin(socket);\n                await doubleCheckPassword(socket, currentPassword);\n\n                await R.exec(\"UPDATE `user` SET twofa_status = 1 WHERE id = ? \", [\n                    socket.userID,\n                ]);\n\n                log.info(\"auth\", `Saved 2FA token. IP=${clientIP}`);\n\n                callback({\n                    ok: true,\n                    msg: \"2FA Enabled.\",\n                });\n            } catch (error) {\n\n                log.error(\"auth\", `Error changing 2FA token. IP=${clientIP}`);\n\n                callback({\n                    ok: false,\n                    msg: error.message,\n                });\n            }\n        });\n\n        socket.on(\"disable2FA\", async (currentPassword, callback) => {\n            const clientIP = await server.getClientIP(socket);\n\n            try {\n                if (! await twoFaRateLimiter.pass(callback)) {\n                    return;\n                }\n\n                checkLogin(socket);\n                await doubleCheckPassword(socket, currentPassword);\n                await TwoFA.disable2FA(socket.userID);\n\n                log.info(\"auth\", `Disabled 2FA token. IP=${clientIP}`);\n\n                callback({\n                    ok: true,\n                    msg: \"2FA Disabled.\",\n                });\n            } catch (error) {\n\n                log.error(\"auth\", `Error disabling 2FA token. IP=${clientIP}`);\n\n                callback({\n                    ok: false,\n                    msg: error.message,\n                });\n            }\n        });\n\n        socket.on(\"verifyToken\", async (token, currentPassword, callback) => {\n            try {\n                checkLogin(socket);\n                await doubleCheckPassword(socket, currentPassword);\n\n                let user = await R.findOne(\"user\", \" id = ? AND active = 1 \", [\n                    socket.userID,\n                ]);\n\n                let verify = notp.totp.verify(token, user.twofa_secret, twoFAVerifyOptions);\n\n                if (user.twofa_last_token !== token && verify) {\n                    callback({\n                        ok: true,\n                        valid: true,\n                    });\n                } else {\n                    callback({\n                        ok: false,\n                        msg: \"Invalid Token.\",\n                        valid: false,\n                    });\n                }\n\n            } catch (error) {\n                callback({\n                    ok: false,\n                    msg: error.message,\n                });\n            }\n        });\n\n        socket.on(\"twoFAStatus\", async (callback) => {\n            try {\n                checkLogin(socket);\n\n                let user = await R.findOne(\"user\", \" id = ? AND active = 1 \", [\n                    socket.userID,\n                ]);\n\n                if (user.twofa_status === 1) {\n                    callback({\n                        ok: true,\n                        status: true,\n                    });\n                } else {\n                    callback({\n                        ok: true,\n                        status: false,\n                    });\n                }\n            } catch (error) {\n                callback({\n                    ok: false,\n                    msg: error.message,\n                });\n            }\n        });\n\n        socket.on(\"needSetup\", async (callback) => {\n            callback(needSetup);\n        });\n\n        socket.on(\"setup\", async (username, password, callback) => {\n            try {\n                if (passwordStrength(password).value === \"Too weak\") {\n                    throw new Error(\"Password is too weak. It should contain alphabetic and numeric characters. It must be at least 6 characters in length.\");\n                }\n\n                if ((await R.count(\"user\")) !== 0) {\n                    throw new Error(\"Uptime Kuma has been initialized. If you want to run setup again, please delete the database.\");\n                }\n\n                let user = R.dispense(\"user\");\n                user.username = username;\n                user.password = passwordHash.generate(password);\n                await R.store(user);\n\n                needSetup = false;\n\n                callback({\n                    ok: true,\n                    msg: \"Added Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        // ***************************\n        // Auth Only API\n        // ***************************\n\n        // Add a new monitor\n        socket.on(\"add\", async (monitor, callback) => {\n            try {\n                checkLogin(socket);\n                let bean = R.dispense(\"monitor\");\n\n                let notificationIDList = monitor.notificationIDList;\n                delete monitor.notificationIDList;\n\n                // Ensure status code ranges are strings\n                if (!monitor.accepted_statuscodes.every((code) => typeof code === \"string\")) {\n                    throw new Error(\"Accepted status codes are not all strings\");\n                }\n                monitor.accepted_statuscodes_json = JSON.stringify(monitor.accepted_statuscodes);\n                delete monitor.accepted_statuscodes;\n\n                monitor.kafkaProducerBrokers = JSON.stringify(monitor.kafkaProducerBrokers);\n                monitor.kafkaProducerSaslOptions = JSON.stringify(monitor.kafkaProducerSaslOptions);\n\n                bean.import(monitor);\n                bean.user_id = socket.userID;\n\n                bean.validate();\n\n                await R.store(bean);\n\n                await updateMonitorNotification(bean.id, notificationIDList);\n\n                await server.sendMonitorList(socket);\n\n                if (monitor.active !== false) {\n                    await startMonitor(socket.userID, bean.id);\n                }\n\n                log.info(\"monitor\", `Added Monitor: ${monitor.id} User ID: ${socket.userID}`);\n\n                callback({\n                    ok: true,\n                    msg: \"Added Successfully.\",\n                    monitorID: bean.id,\n                });\n\n            } catch (e) {\n\n                log.error(\"monitor\", `Error adding Monitor: ${monitor.id} User ID: ${socket.userID}`);\n\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        // Edit a monitor\n        socket.on(\"editMonitor\", async (monitor, callback) => {\n            try {\n                let removeGroupChildren = false;\n                checkLogin(socket);\n\n                let bean = await R.findOne(\"monitor\", \" id = ? \", [ monitor.id ]);\n\n                if (bean.user_id !== socket.userID) {\n                    throw new Error(\"Permission denied.\");\n                }\n\n                // Check if Parent is Descendant (would cause endless loop)\n                if (monitor.parent !== null) {\n                    const childIDs = await Monitor.getAllChildrenIDs(monitor.id);\n                    if (childIDs.includes(monitor.parent)) {\n                        throw new Error(\"Invalid Monitor Group\");\n                    }\n                }\n\n                // Remove children if monitor type has changed (from group to non-group)\n                if (bean.type === \"group\" && monitor.type !== bean.type) {\n                    removeGroupChildren = true;\n                }\n\n                // Ensure status code ranges are strings\n                if (!monitor.accepted_statuscodes.every((code) => typeof code === \"string\")) {\n                    throw new Error(\"Accepted status codes are not all strings\");\n                }\n\n                bean.name = monitor.name;\n                bean.description = monitor.description;\n                bean.parent = monitor.parent;\n                bean.type = monitor.type;\n                bean.url = monitor.url;\n                bean.method = monitor.method;\n                bean.body = monitor.body;\n                bean.headers = monitor.headers;\n                bean.basic_auth_user = monitor.basic_auth_user;\n                bean.basic_auth_pass = monitor.basic_auth_pass;\n                bean.timeout = monitor.timeout;\n                bean.oauth_client_id = monitor.oauth_client_id;\n                bean.oauth_client_secret = monitor.oauth_client_secret;\n                bean.oauth_auth_method = monitor.oauth_auth_method;\n                bean.oauth_token_url = monitor.oauth_token_url;\n                bean.oauth_scopes = monitor.oauth_scopes;\n                bean.tlsCa = monitor.tlsCa;\n                bean.tlsCert = monitor.tlsCert;\n                bean.tlsKey = monitor.tlsKey;\n                bean.interval = monitor.interval;\n                bean.retryInterval = monitor.retryInterval;\n                bean.resendInterval = monitor.resendInterval;\n                bean.hostname = monitor.hostname;\n                bean.game = monitor.game;\n                bean.maxretries = monitor.maxretries;\n                bean.port = parseInt(monitor.port);\n                bean.keyword = monitor.keyword;\n                bean.invertKeyword = monitor.invertKeyword;\n                bean.ignoreTls = monitor.ignoreTls;\n                bean.expiryNotification = monitor.expiryNotification;\n                bean.upsideDown = monitor.upsideDown;\n                bean.packetSize = monitor.packetSize;\n                bean.maxredirects = monitor.maxredirects;\n                bean.accepted_statuscodes_json = JSON.stringify(monitor.accepted_statuscodes);\n                bean.dns_resolve_type = monitor.dns_resolve_type;\n                bean.dns_resolve_server = monitor.dns_resolve_server;\n                bean.pushToken = monitor.pushToken;\n                bean.docker_container = monitor.docker_container;\n                bean.docker_host = monitor.docker_host;\n                bean.proxyId = Number.isInteger(monitor.proxyId) ? monitor.proxyId : null;\n                bean.mqttUsername = monitor.mqttUsername;\n                bean.mqttPassword = monitor.mqttPassword;\n                bean.mqttTopic = monitor.mqttTopic;\n                bean.mqttSuccessMessage = monitor.mqttSuccessMessage;\n                bean.databaseConnectionString = monitor.databaseConnectionString;\n                bean.databaseQuery = monitor.databaseQuery;\n                bean.authMethod = monitor.authMethod;\n                bean.authWorkstation = monitor.authWorkstation;\n                bean.authDomain = monitor.authDomain;\n                bean.grpcUrl = monitor.grpcUrl;\n                bean.grpcProtobuf = monitor.grpcProtobuf;\n                bean.grpcServiceName = monitor.grpcServiceName;\n                bean.grpcMethod = monitor.grpcMethod;\n                bean.grpcBody = monitor.grpcBody;\n                bean.grpcMetadata = monitor.grpcMetadata;\n                bean.grpcEnableTls = monitor.grpcEnableTls;\n                bean.radiusUsername = monitor.radiusUsername;\n                bean.radiusPassword = monitor.radiusPassword;\n                bean.radiusCalledStationId = monitor.radiusCalledStationId;\n                bean.radiusCallingStationId = monitor.radiusCallingStationId;\n                bean.radiusSecret = monitor.radiusSecret;\n                bean.httpBodyEncoding = monitor.httpBodyEncoding;\n                bean.expectedValue = monitor.expectedValue;\n                bean.jsonPath = monitor.jsonPath;\n                bean.kafkaProducerTopic = monitor.kafkaProducerTopic;\n                bean.kafkaProducerBrokers = JSON.stringify(monitor.kafkaProducerBrokers);\n                bean.kafkaProducerAllowAutoTopicCreation = monitor.kafkaProducerAllowAutoTopicCreation;\n                bean.kafkaProducerSaslOptions = JSON.stringify(monitor.kafkaProducerSaslOptions);\n                bean.kafkaProducerMessage = monitor.kafkaProducerMessage;\n                bean.kafkaProducerSsl = monitor.kafkaProducerSsl;\n                bean.kafkaProducerAllowAutoTopicCreation =\n                    monitor.kafkaProducerAllowAutoTopicCreation;\n                bean.gamedigGivenPortOnly = monitor.gamedigGivenPortOnly;\n\n                bean.validate();\n\n                await R.store(bean);\n\n                if (removeGroupChildren) {\n                    await Monitor.unlinkAllChildren(monitor.id);\n                }\n\n                await updateMonitorNotification(bean.id, monitor.notificationIDList);\n\n                if (await bean.isActive()) {\n                    await restartMonitor(socket.userID, bean.id);\n                }\n\n                await server.sendMonitorList(socket);\n\n                callback({\n                    ok: true,\n                    msg: \"Saved.\",\n                    monitorID: bean.id,\n                });\n\n            } catch (e) {\n                log.error(\"monitor\", e);\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"getMonitorList\", async (callback) => {\n            try {\n                checkLogin(socket);\n                await server.sendMonitorList(socket);\n                callback({\n                    ok: true,\n                });\n            } catch (e) {\n                log.error(\"monitor\", e);\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"getMonitor\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"monitor\", `Get Monitor: ${monitorID} User ID: ${socket.userID}`);\n\n                let bean = await R.findOne(\"monitor\", \" id = ? AND user_id = ? \", [\n                    monitorID,\n                    socket.userID,\n                ]);\n\n                callback({\n                    ok: true,\n                    monitor: await bean.toJSON(),\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"getMonitorBeats\", async (monitorID, period, callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"monitor\", `Get Monitor Beats: ${monitorID} User ID: ${socket.userID}`);\n\n                if (period == null) {\n                    throw new Error(\"Invalid period.\");\n                }\n\n                let list = await R.getAll(`\n                    SELECT * FROM heartbeat\n                    WHERE monitor_id = ? AND\n                    time > DATETIME('now', '-' || ? || ' hours')\n                    ORDER BY time ASC\n                `, [\n                    monitorID,\n                    period,\n                ]);\n\n                callback({\n                    ok: true,\n                    data: list,\n                });\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        // Start or Resume the monitor\n        socket.on(\"resumeMonitor\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n                await startMonitor(socket.userID, monitorID);\n                await server.sendMonitorList(socket);\n\n                callback({\n                    ok: true,\n                    msg: \"Resumed Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"pauseMonitor\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n                await pauseMonitor(socket.userID, monitorID);\n                await server.sendMonitorList(socket);\n\n                callback({\n                    ok: true,\n                    msg: \"Paused Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"deleteMonitor\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"manage\", `Delete Monitor: ${monitorID} User ID: ${socket.userID}`);\n\n                if (monitorID in server.monitorList) {\n                    server.monitorList[monitorID].stop();\n                    delete server.monitorList[monitorID];\n                }\n\n                const startTime = Date.now();\n\n                await R.exec(\"DELETE FROM monitor WHERE id = ? AND user_id = ? \", [\n                    monitorID,\n                    socket.userID,\n                ]);\n\n                // Fix #2880\n                apicache.clear();\n\n                const endTime = Date.now();\n\n                log.info(\"DB\", `Delete Monitor completed in : ${endTime - startTime} ms`);\n\n                callback({\n                    ok: true,\n                    msg: \"Deleted Successfully.\",\n                });\n\n                await server.sendMonitorList(socket);\n                // Clear heartbeat list on client\n                await sendImportantHeartbeatList(socket, monitorID, true, true);\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"getTags\", async (callback) => {\n            try {\n                checkLogin(socket);\n\n                const list = await R.findAll(\"tag\");\n\n                callback({\n                    ok: true,\n                    tags: list.map(bean => bean.toJSON()),\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"addTag\", async (tag, callback) => {\n            try {\n                checkLogin(socket);\n\n                let bean = R.dispense(\"tag\");\n                bean.name = tag.name;\n                bean.color = tag.color;\n                await R.store(bean);\n\n                callback({\n                    ok: true,\n                    tag: await bean.toJSON(),\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"editTag\", async (tag, callback) => {\n            try {\n                checkLogin(socket);\n\n                let bean = await R.findOne(\"tag\", \" id = ? \", [ tag.id ]);\n                if (bean == null) {\n                    callback({\n                        ok: false,\n                        msg: \"Tag not found\",\n                    });\n                    return;\n                }\n                bean.name = tag.name;\n                bean.color = tag.color;\n                await R.store(bean);\n\n                callback({\n                    ok: true,\n                    msg: \"Saved\",\n                    tag: await bean.toJSON(),\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"deleteTag\", async (tagID, callback) => {\n            try {\n                checkLogin(socket);\n\n                await R.exec(\"DELETE FROM tag WHERE id = ? \", [ tagID ]);\n\n                callback({\n                    ok: true,\n                    msg: \"Deleted Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"addMonitorTag\", async (tagID, monitorID, value, callback) => {\n            try {\n                checkLogin(socket);\n\n                await R.exec(\"INSERT INTO monitor_tag (tag_id, monitor_id, value) VALUES (?, ?, ?)\", [\n                    tagID,\n                    monitorID,\n                    value,\n                ]);\n\n                callback({\n                    ok: true,\n                    msg: \"Added Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"editMonitorTag\", async (tagID, monitorID, value, callback) => {\n            try {\n                checkLogin(socket);\n\n                await R.exec(\"UPDATE monitor_tag SET value = ? WHERE tag_id = ? AND monitor_id = ?\", [\n                    value,\n                    tagID,\n                    monitorID,\n                ]);\n\n                callback({\n                    ok: true,\n                    msg: \"Edited Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"deleteMonitorTag\", async (tagID, monitorID, value, callback) => {\n            try {\n                checkLogin(socket);\n\n                await R.exec(\"DELETE FROM monitor_tag WHERE tag_id = ? AND monitor_id = ? AND value = ?\", [\n                    tagID,\n                    monitorID,\n                    value,\n                ]);\n\n                callback({\n                    ok: true,\n                    msg: \"Deleted Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"changePassword\", async (password, callback) => {\n            try {\n                checkLogin(socket);\n\n                if (! password.newPassword) {\n                    throw new Error(\"Invalid new password\");\n                }\n\n                if (passwordStrength(password.newPassword).value === \"Too weak\") {\n                    throw new Error(\"Password is too weak. It should contain alphabetic and numeric characters. It must be at least 6 characters in length.\");\n                }\n\n                let user = await doubleCheckPassword(socket, password.currentPassword);\n                await user.resetPassword(password.newPassword);\n\n                callback({\n                    ok: true,\n                    msg: \"Password has been updated successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"getSettings\", async (callback) => {\n            try {\n                checkLogin(socket);\n                const data = await getSettings(\"general\");\n\n                if (!data.serverTimezone) {\n                    data.serverTimezone = await server.getTimezone();\n                }\n\n                callback({\n                    ok: true,\n                    data: data,\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"setSettings\", async (data, currentPassword, callback) => {\n            try {\n                checkLogin(socket);\n\n                // If currently is disabled auth, don't need to check\n                // Disabled Auth + Want to Disable Auth => No Check\n                // Disabled Auth + Want to Enable Auth => No Check\n                // Enabled Auth + Want to Disable Auth => Check!!\n                // Enabled Auth + Want to Enable Auth => No Check\n                const currentDisabledAuth = await setting(\"disableAuth\");\n                if (!currentDisabledAuth && data.disableAuth) {\n                    await doubleCheckPassword(socket, currentPassword);\n                }\n\n                const previousChromeExecutable = await Settings.get(\"chromeExecutable\");\n                const previousNSCDStatus = await Settings.get(\"nscd\");\n\n                await setSettings(\"general\", data);\n                server.entryPage = data.entryPage;\n\n                await CacheableDnsHttpAgent.update();\n\n                // Also need to apply timezone globally\n                if (data.serverTimezone) {\n                    await server.setTimezone(data.serverTimezone);\n                }\n\n                // If Chrome Executable is changed, need to reset the browser\n                if (previousChromeExecutable !== data.chromeExecutable) {\n                    log.info(\"settings\", \"Chrome executable is changed. Resetting Chrome...\");\n                    await resetChrome();\n                }\n\n                // Update nscd status\n                if (previousNSCDStatus !== data.nscd) {\n                    if (data.nscd) {\n                        await server.startNSCDServices();\n                    } else {\n                        await server.stopNSCDServices();\n                    }\n                }\n\n                callback({\n                    ok: true,\n                    msg: \"Saved\"\n                });\n\n                sendInfo(socket);\n                server.sendMaintenanceList(socket);\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        // Add or Edit\n        socket.on(\"addNotification\", async (notification, notificationID, callback) => {\n            try {\n                checkLogin(socket);\n\n                let notificationBean = await Notification.save(notification, notificationID, socket.userID);\n                await sendNotificationList(socket);\n\n                callback({\n                    ok: true,\n                    msg: \"Saved\",\n                    id: notificationBean.id,\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"deleteNotification\", async (notificationID, callback) => {\n            try {\n                checkLogin(socket);\n\n                await Notification.delete(notificationID, socket.userID);\n                await sendNotificationList(socket);\n\n                callback({\n                    ok: true,\n                    msg: \"Deleted\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"testNotification\", async (notification, callback) => {\n            try {\n                checkLogin(socket);\n\n                let msg = await Notification.send(notification, notification.name + \" Testing\");\n\n                callback({\n                    ok: true,\n                    msg,\n                });\n\n            } catch (e) {\n                console.error(e);\n\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"checkApprise\", async (callback) => {\n            try {\n                checkLogin(socket);\n                callback(Notification.checkApprise());\n            } catch (e) {\n                callback(false);\n            }\n        });\n\n        socket.on(\"uploadBackup\", async (uploadedJSON, importHandle, callback) => {\n            try {\n                checkLogin(socket);\n\n                let backupData = JSON.parse(uploadedJSON);\n\n                log.info(\"manage\", `Importing Backup, User ID: ${socket.userID}, Version: ${backupData.version}`);\n\n                let notificationListData = backupData.notificationList;\n                let proxyListData = backupData.proxyList;\n                let monitorListData = backupData.monitorList;\n\n                let version17x = compareVersions.compare(backupData.version, \"1.7.0\", \">=\");\n\n                // If the import option is \"overwrite\" it'll clear most of the tables, except \"settings\" and \"user\"\n                if (importHandle === \"overwrite\") {\n                    // Stops every monitor first, so it doesn't execute any heartbeat while importing\n                    for (let id in server.monitorList) {\n                        let monitor = server.monitorList[id];\n                        await monitor.stop();\n                    }\n                    await R.exec(\"DELETE FROM heartbeat\");\n                    await R.exec(\"DELETE FROM monitor_notification\");\n                    await R.exec(\"DELETE FROM monitor_tls_info\");\n                    await R.exec(\"DELETE FROM notification\");\n                    await R.exec(\"DELETE FROM monitor_tag\");\n                    await R.exec(\"DELETE FROM tag\");\n                    await R.exec(\"DELETE FROM monitor\");\n                    await R.exec(\"DELETE FROM proxy\");\n                }\n\n                // Only starts importing if the backup file contains at least one notification\n                if (notificationListData.length >= 1) {\n                    // Get every existing notification name and puts them in one simple string\n                    let notificationNameList = await R.getAll(\"SELECT name FROM notification\");\n                    let notificationNameListString = JSON.stringify(notificationNameList);\n\n                    for (let i = 0; i < notificationListData.length; i++) {\n                        // Only starts importing the notification if the import option is \"overwrite\", \"keep\" or \"skip\" but the notification doesn't exists\n                        if ((importHandle === \"skip\" && notificationNameListString.includes(notificationListData[i].name) === false) || importHandle === \"keep\" || importHandle === \"overwrite\") {\n\n                            let notification = JSON.parse(notificationListData[i].config);\n                            await Notification.save(notification, null, socket.userID);\n\n                        }\n                    }\n                }\n\n                // Only starts importing if the backup file contains at least one proxy\n                if (proxyListData && proxyListData.length >= 1) {\n                    const proxies = await R.findAll(\"proxy\");\n\n                    // Loop over proxy list and save proxies\n                    for (const proxy of proxyListData) {\n                        const exists = proxies.find(item => item.id === proxy.id);\n\n                        // Do not process when proxy already exists in import handle is skip and keep\n                        if ([ \"skip\", \"keep\" ].includes(importHandle) && !exists) {\n                            return;\n                        }\n\n                        // Save proxy as new entry if exists update exists one\n                        await Proxy.save(proxy, exists ? proxy.id : undefined, proxy.userId);\n                    }\n                }\n\n                // Only starts importing if the backup file contains at least one monitor\n                if (monitorListData.length >= 1) {\n                    // Get every existing monitor name and puts them in one simple string\n                    let monitorNameList = await R.getAll(\"SELECT name FROM monitor\");\n                    let monitorNameListString = JSON.stringify(monitorNameList);\n\n                    for (let i = 0; i < monitorListData.length; i++) {\n                        // Only starts importing the monitor if the import option is \"overwrite\", \"keep\" or \"skip\" but the notification doesn't exists\n                        if ((importHandle === \"skip\" && monitorNameListString.includes(monitorListData[i].name) === false) || importHandle === \"keep\" || importHandle === \"overwrite\") {\n\n                            // Define in here every new variable for monitors which where implemented after the first version of the Import/Export function (1.6.0)\n                            // --- Start ---\n\n                            // Define default values\n                            let retryInterval = 0;\n                            let timeout = monitorListData[i].timeout || (monitorListData[i].interval * 0.8); // fallback to old value\n\n                            /*\n                            Only replace the default value with the backup file data for the specific version, where it appears the first time\n                            More information about that where \"let version\" will be defined\n                            */\n                            if (version17x) {\n                                retryInterval = monitorListData[i].retryInterval;\n                            }\n\n                            // --- End ---\n\n                            let monitor = {\n                                // Define the new variable from earlier here\n                                name: monitorListData[i].name,\n                                description: monitorListData[i].description,\n                                type: monitorListData[i].type,\n                                url: monitorListData[i].url,\n                                method: monitorListData[i].method || \"GET\",\n                                body: monitorListData[i].body,\n                                headers: monitorListData[i].headers,\n                                authMethod: monitorListData[i].authMethod,\n                                basic_auth_user: monitorListData[i].basic_auth_user,\n                                basic_auth_pass: monitorListData[i].basic_auth_pass,\n                                authWorkstation: monitorListData[i].authWorkstation,\n                                authDomain: monitorListData[i].authDomain,\n                                timeout,\n                                interval: monitorListData[i].interval,\n                                retryInterval: retryInterval,\n                                resendInterval: monitorListData[i].resendInterval || 0,\n                                hostname: monitorListData[i].hostname,\n                                maxretries: monitorListData[i].maxretries,\n                                port: monitorListData[i].port,\n                                keyword: monitorListData[i].keyword,\n                                invertKeyword: monitorListData[i].invertKeyword,\n                                ignoreTls: monitorListData[i].ignoreTls,\n                                upsideDown: monitorListData[i].upsideDown,\n                                maxredirects: monitorListData[i].maxredirects,\n                                accepted_statuscodes: monitorListData[i].accepted_statuscodes,\n                                dns_resolve_type: monitorListData[i].dns_resolve_type,\n                                dns_resolve_server: monitorListData[i].dns_resolve_server,\n                                notificationIDList: monitorListData[i].notificationIDList,\n                                proxy_id: monitorListData[i].proxy_id || null,\n                            };\n\n                            if (monitorListData[i].pushToken) {\n                                monitor.pushToken = monitorListData[i].pushToken;\n                            }\n\n                            let bean = R.dispense(\"monitor\");\n\n                            let notificationIDList = monitor.notificationIDList;\n                            delete monitor.notificationIDList;\n\n                            monitor.accepted_statuscodes_json = JSON.stringify(monitor.accepted_statuscodes);\n                            delete monitor.accepted_statuscodes;\n\n                            bean.import(monitor);\n                            bean.user_id = socket.userID;\n                            await R.store(bean);\n\n                            // Only for backup files with the version 1.7.0 or higher, since there was the tag feature implemented\n                            if (version17x) {\n                                // Only import if the specific monitor has tags assigned\n                                for (const oldTag of monitorListData[i].tags) {\n\n                                    // Check if tag already exists and get data ->\n                                    let tag = await R.findOne(\"tag\", \" name = ?\", [\n                                        oldTag.name,\n                                    ]);\n\n                                    let tagId;\n                                    if (! tag) {\n                                        // -> If it doesn't exist, create new tag from backup file\n                                        let beanTag = R.dispense(\"tag\");\n                                        beanTag.name = oldTag.name;\n                                        beanTag.color = oldTag.color;\n                                        await R.store(beanTag);\n\n                                        tagId = beanTag.id;\n                                    } else {\n                                        // -> If it already exist, set tagId to value from database\n                                        tagId = tag.id;\n                                    }\n\n                                    // Assign the new created tag to the monitor\n                                    await R.exec(\"INSERT INTO monitor_tag (tag_id, monitor_id, value) VALUES (?, ?, ?)\", [\n                                        tagId,\n                                        bean.id,\n                                        oldTag.value,\n                                    ]);\n\n                                }\n                            }\n\n                            await updateMonitorNotification(bean.id, notificationIDList);\n\n                            // If monitor was active start it immediately, otherwise pause it\n                            if (monitorListData[i].active === 1) {\n                                await startMonitor(socket.userID, bean.id);\n                            } else {\n                                await pauseMonitor(socket.userID, bean.id);\n                            }\n\n                        }\n                    }\n\n                    await sendNotificationList(socket);\n                    await server.sendMonitorList(socket);\n                }\n\n                callback({\n                    ok: true,\n                    msg: \"Backup successfully restored.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"clearEvents\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"manage\", `Clear Events Monitor: ${monitorID} User ID: ${socket.userID}`);\n\n                await R.exec(\"UPDATE heartbeat SET msg = ?, important = ? WHERE monitor_id = ? \", [\n                    \"\",\n                    \"0\",\n                    monitorID,\n                ]);\n\n                await sendImportantHeartbeatList(socket, monitorID, true, true);\n\n                callback({\n                    ok: true,\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"clearHeartbeats\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"manage\", `Clear Heartbeats Monitor: ${monitorID} User ID: ${socket.userID}`);\n\n                await R.exec(\"DELETE FROM heartbeat WHERE monitor_id = ?\", [\n                    monitorID\n                ]);\n\n                await sendHeartbeatList(socket, monitorID, true, true);\n\n                callback({\n                    ok: true,\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"clearStatistics\", async (callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"manage\", `Clear Statistics User ID: ${socket.userID}`);\n\n                await R.exec(\"DELETE FROM heartbeat\");\n\n                callback({\n                    ok: true,\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        // Status Page Socket Handler for admin only\n        statusPageSocketHandler(socket);\n        cloudflaredSocketHandler(socket);\n        databaseSocketHandler(socket);\n        proxySocketHandler(socket);\n        dockerSocketHandler(socket);\n        maintenanceSocketHandler(socket);\n        apiKeySocketHandler(socket);\n        generalSocketHandler(socket, server);\n\n        log.debug(\"server\", \"added all socket handlers\");\n\n        // ***************************\n        // Better do anything after added all socket handlers here\n        // ***************************\n\n        log.debug(\"auth\", \"check auto login\");\n        if (await setting(\"disableAuth\")) {\n            log.info(\"auth\", \"Disabled Auth: auto login to admin\");\n            afterLogin(socket, await R.findOne(\"user\"));\n            socket.emit(\"autoLogin\");\n        } else {\n            log.debug(\"auth\", \"need auth\");\n        }\n\n    });\n\n    log.info(\"server\", \"Init the server\");\n\n    server.httpServer.once(\"error\", async (err) => {\n        console.error(\"Cannot listen: \" + err.message);\n        await shutdownFunction();\n    });\n\n    server.start();\n\n    server.httpServer.listen(port, hostname, () => {\n        if (hostname) {\n            log.info(\"server\", `Listening on ${hostname}:${port}`);\n        } else {\n            log.info(\"server\", `Listening on ${port}`);\n        }\n        startMonitors();\n        checkVersion.startInterval();\n\n        if (testMode) {\n            startUnitTest();\n        }\n\n        if (e2eTestMode) {\n            startE2eTests();\n        }\n    });\n\n    await initBackgroundJobs();\n\n    // Start cloudflared at the end if configured\n    await cloudflaredAutoStart(cloudflaredToken);\n\n})();\n\n/**\n * Update notifications for a given monitor\n * @param {number} monitorID ID of monitor to update\n * @param {number[]} notificationIDList List of new notification\n * providers to add\n * @returns {Promise<void>}\n */\nasync function updateMonitorNotification(monitorID, notificationIDList) {\n    await R.exec(\"DELETE FROM monitor_notification WHERE monitor_id = ? \", [\n        monitorID,\n    ]);\n\n    for (let notificationID in notificationIDList) {\n        if (notificationIDList[notificationID]) {\n            let relation = R.dispense(\"monitor_notification\");\n            relation.monitor_id = monitorID;\n            relation.notification_id = notificationID;\n            await R.store(relation);\n        }\n    }\n}\n\n/**\n * Check if a given user owns a specific monitor\n * @param {number} userID\n * @param {number} monitorID\n * @returns {Promise<void>}\n * @throws {Error} The specified user does not own the monitor\n */\nasync function checkOwner(userID, monitorID) {\n    let row = await R.getRow(\"SELECT id FROM monitor WHERE id = ? AND user_id = ? \", [\n        monitorID,\n        userID,\n    ]);\n\n    if (! row) {\n        throw new Error(\"You do not own this monitor.\");\n    }\n}\n\n/**\n * Function called after user login\n * This function is used to send the heartbeat list of a monitor.\n * @param {Socket} socket Socket.io instance\n * @param {Object} user User object\n * @returns {Promise<void>}\n */\nasync function afterLogin(socket, user) {\n    socket.userID = user.id;\n    socket.join(user.id);\n\n    let monitorList = await server.sendMonitorList(socket);\n    sendInfo(socket);\n    server.sendMaintenanceList(socket);\n    sendNotificationList(socket);\n    sendProxyList(socket);\n    sendDockerHostList(socket);\n    sendAPIKeyList(socket);\n\n    await sleep(500);\n\n    await StatusPage.sendStatusPageList(io, socket);\n\n    for (let monitorID in monitorList) {\n        await sendHeartbeatList(socket, monitorID);\n    }\n\n    for (let monitorID in monitorList) {\n        await sendImportantHeartbeatList(socket, monitorID);\n    }\n\n    for (let monitorID in monitorList) {\n        await Monitor.sendStats(io, monitorID, user.id);\n    }\n\n    // Set server timezone from client browser if not set\n    // It should be run once only\n    if (! await Settings.get(\"initServerTimezone\")) {\n        log.debug(\"server\", \"emit initServerTimezone\");\n        socket.emit(\"initServerTimezone\");\n    }\n}\n\n/**\n * Initialize the database\n * @param {boolean} [testMode=false] Should the connection be\n * started in test mode?\n * @returns {Promise<void>}\n */\nasync function initDatabase(testMode = false) {\n    if (! fs.existsSync(Database.path)) {\n        log.info(\"server\", \"Copying Database\");\n        fs.copyFileSync(Database.templatePath, Database.path);\n    }\n\n    log.info(\"server\", \"Connecting to the Database\");\n    await Database.connect(testMode);\n    log.info(\"server\", \"Connected\");\n\n    // Patch the database\n    await Database.patch();\n\n    let jwtSecretBean = await R.findOne(\"setting\", \" `key` = ? \", [\n        \"jwtSecret\",\n    ]);\n\n    if (! jwtSecretBean) {\n        log.info(\"server\", \"JWT secret is not found, generate one.\");\n        jwtSecretBean = await initJWTSecret();\n        log.info(\"server\", \"Stored JWT secret into database\");\n    } else {\n        log.info(\"server\", \"Load JWT secret from database.\");\n    }\n\n    // If there is no record in user table, it is a new Uptime Kuma instance, need to setup\n    if ((await R.count(\"user\")) === 0) {\n        log.info(\"server\", \"No user, need setup\");\n        needSetup = true;\n    }\n\n    server.jwtSecret = jwtSecretBean.value;\n}\n\n/**\n * Start the specified monitor\n * @param {number} userID ID of user who owns monitor\n * @param {number} monitorID ID of monitor to start\n * @returns {Promise<void>}\n */\nasync function startMonitor(userID, monitorID) {\n    await checkOwner(userID, monitorID);\n\n    log.info(\"manage\", `Resume Monitor: ${monitorID} User ID: ${userID}`);\n\n    await R.exec(\"UPDATE monitor SET active = 1 WHERE id = ? AND user_id = ? \", [\n        monitorID,\n        userID,\n    ]);\n\n    let monitor = await R.findOne(\"monitor\", \" id = ? \", [\n        monitorID,\n    ]);\n\n    if (monitor.id in server.monitorList) {\n        server.monitorList[monitor.id].stop();\n    }\n\n    server.monitorList[monitor.id] = monitor;\n    monitor.start(io);\n}\n\n/**\n * Restart a given monitor\n * @param {number} userID ID of user who owns monitor\n * @param {number} monitorID ID of monitor to start\n * @returns {Promise<void>}\n */\nasync function restartMonitor(userID, monitorID) {\n    return await startMonitor(userID, monitorID);\n}\n\n/**\n * Pause a given monitor\n * @param {number} userID ID of user who owns monitor\n * @param {number} monitorID ID of monitor to start\n * @returns {Promise<void>}\n */\nasync function pauseMonitor(userID, monitorID) {\n    await checkOwner(userID, monitorID);\n\n    log.info(\"manage\", `Pause Monitor: ${monitorID} User ID: ${userID}`);\n\n    await R.exec(\"UPDATE monitor SET active = 0 WHERE id = ? AND user_id = ? \", [\n        monitorID,\n        userID,\n    ]);\n\n    if (monitorID in server.monitorList) {\n        server.monitorList[monitorID].stop();\n        server.monitorList[monitorID].active = 0;\n    }\n}\n\n/** Resume active monitors */\nasync function startMonitors() {\n    let list = await R.find(\"monitor\", \" active = 1 \");\n\n    for (let monitor of list) {\n        server.monitorList[monitor.id] = monitor;\n    }\n\n    for (let monitor of list) {\n        monitor.start(io);\n        // Give some delays, so all monitors won't make request at the same moment when just start the server.\n        await sleep(getRandomInt(300, 1000));\n    }\n}\n\n/**\n * Shutdown the application\n * Stops all monitors and closes the database connection.\n * @param {string} signal The signal that triggered this function to be called.\n * @returns {Promise<void>}\n */\nasync function shutdownFunction(signal) {\n    log.info(\"server\", \"Shutdown requested\");\n    log.info(\"server\", \"Called signal: \" + signal);\n\n    await server.stop();\n\n    log.info(\"server\", \"Stopping all monitors\");\n    for (let id in server.monitorList) {\n        let monitor = server.monitorList[id];\n        monitor.stop();\n    }\n    await sleep(2000);\n    await Database.close();\n\n    stopBackgroundJobs();\n    await cloudflaredStop();\n    Settings.stopCacheCleaner();\n}\n\n/** Final function called before application exits */\nfunction finalFunction() {\n    log.info(\"server\", \"Graceful shutdown successful!\");\n}\n\ngracefulShutdown(server.httpServer, {\n    signals: \"SIGINT SIGTERM\",\n    timeout: 30000,                   // timeout: 30 secs\n    development: false,               // not in dev mode\n    forceExit: true,                  // triggers process.exit() at the end of shutdown process\n    onShutdown: shutdownFunction,     // shutdown function (async) - e.g. for cleanup DB, ...\n    finally: finalFunction,            // finally function (sync) - e.g. for logging\n});\n\n// Catch unexpected errors here\nlet unexpectedErrorHandler = (error, promise) => {\n    console.trace(error);\n    UptimeKumaServer.errorLog(error, false);\n    console.error(\"If you keep encountering errors, please report to https://github.com/louislam/uptime-kuma/issues\");\n};\nprocess.addListener(\"unhandledRejection\", unexpectedErrorHandler);\nprocess.addListener(\"uncaughtException\", unexpectedErrorHandler);\n", "const express = require(\"express\");\nconst https = require(\"https\");\nconst fs = require(\"fs\");\nconst http = require(\"http\");\nconst { Server } = require(\"socket.io\");\nconst { R } = require(\"redbean-node\");\nconst { log } = require(\"../src/util\");\nconst Database = require(\"./database\");\nconst util = require(\"util\");\nconst { CacheableDnsHttpAgent } = require(\"./cacheable-dns-http-agent\");\nconst { Settings } = require(\"./settings\");\nconst dayjs = require(\"dayjs\");\nconst childProcessAsync = require(\"promisify-child-process\");\nconst path = require(\"path\");\n// DO NOT IMPORT HERE IF THE MODULES USED `UptimeKumaServer.getInstance()`, put at the bottom of this file instead.\n\n/**\n * `module.exports` (alias: `server`) should be inside this class, in order to avoid circular dependency issue.\n * @type {UptimeKumaServer}\n */\nclass UptimeKumaServer {\n    /**\n     *\n     * @type {UptimeKumaServer}\n     */\n    static instance = null;\n\n    /**\n     * Main monitor list\n     * @type {{}}\n     */\n    monitorList = {};\n\n    /**\n     * Main maintenance list\n     * @type {{}}\n     */\n    maintenanceList = {};\n\n    entryPage = \"dashboard\";\n    app = undefined;\n    httpServer = undefined;\n    io = undefined;\n\n    /**\n     * Cache Index HTML\n     * @type {string}\n     */\n    indexHTML = \"\";\n\n    /**\n     *\n     * @type {{}}\n     */\n    static monitorTypeList = {\n\n    };\n\n    /**\n     * Use for decode the auth object\n     * @type {null}\n     */\n    jwtSecret = null;\n\n    static getInstance(args) {\n        if (UptimeKumaServer.instance == null) {\n            UptimeKumaServer.instance = new UptimeKumaServer(args);\n        }\n        return UptimeKumaServer.instance;\n    }\n\n    constructor(args) {\n        // SSL\n        const sslKey = args[\"ssl-key\"] || process.env.UPTIME_KUMA_SSL_KEY || process.env.SSL_KEY || undefined;\n        const sslCert = args[\"ssl-cert\"] || process.env.UPTIME_KUMA_SSL_CERT || process.env.SSL_CERT || undefined;\n        const sslKeyPassphrase = args[\"ssl-key-passphrase\"] || process.env.UPTIME_KUMA_SSL_KEY_PASSPHRASE || process.env.SSL_KEY_PASSPHRASE || undefined;\n\n        log.info(\"server\", \"Creating express and socket.io instance\");\n        this.app = express();\n        if (sslKey && sslCert) {\n            log.info(\"server\", \"Server Type: HTTPS\");\n            this.httpServer = https.createServer({\n                key: fs.readFileSync(sslKey),\n                cert: fs.readFileSync(sslCert),\n                passphrase: sslKeyPassphrase,\n            }, this.app);\n        } else {\n            log.info(\"server\", \"Server Type: HTTP\");\n            this.httpServer = http.createServer(this.app);\n        }\n\n        try {\n            this.indexHTML = fs.readFileSync(\"./dist/index.html\").toString();\n        } catch (e) {\n            // \"dist/index.html\" is not necessary for development\n            if (process.env.NODE_ENV !== \"development\") {\n                log.error(\"server\", \"Error: Cannot find 'dist/index.html', did you install correctly?\");\n                process.exit(1);\n            }\n        }\n\n        // Set Monitor Types\n        UptimeKumaServer.monitorTypeList[\"real-browser\"] = new RealBrowserMonitorType();\n        UptimeKumaServer.monitorTypeList[\"tailscale-ping\"] = new TailscalePing();\n\n        this.io = new Server(this.httpServer);\n    }\n\n    /** Initialise app after the database has been set up */\n    async initAfterDatabaseReady() {\n        // Static\n        this.app.use(\"/screenshots\", express.static(Database.screenshotDir));\n\n        await CacheableDnsHttpAgent.update();\n\n        process.env.TZ = await this.getTimezone();\n        dayjs.tz.setDefault(process.env.TZ);\n        log.debug(\"DEBUG\", \"Timezone: \" + process.env.TZ);\n        log.debug(\"DEBUG\", \"Current Time: \" + dayjs.tz().format());\n\n        await this.loadMaintenanceList();\n    }\n\n    /**\n     * Send list of monitors to client\n     * @param {Socket} socket\n     * @returns {Object} List of monitors\n     */\n    async sendMonitorList(socket) {\n        let list = await this.getMonitorJSONList(socket.userID);\n        this.io.to(socket.userID).emit(\"monitorList\", list);\n        return list;\n    }\n\n    /**\n     * Get a list of monitors for the given user.\n     * @param {string} userID - The ID of the user to get monitors for.\n     * @returns {Promise<Object>} A promise that resolves to an object with monitor IDs as keys and monitor objects as values.\n     *\n     * Generated by Trelent\n     */\n    async getMonitorJSONList(userID) {\n        let result = {};\n\n        let monitorList = await R.find(\"monitor\", \" user_id = ? ORDER BY weight DESC, name\", [\n            userID,\n        ]);\n\n        for (let monitor of monitorList) {\n            result[monitor.id] = await monitor.toJSON();\n        }\n\n        return result;\n    }\n\n    /**\n     * Send maintenance list to client\n     * @param {Socket} socket Socket.io instance to send to\n     * @returns {Object}\n     */\n    async sendMaintenanceList(socket) {\n        return await this.sendMaintenanceListByUserID(socket.userID);\n    }\n\n    /**\n     * Send list of maintenances to user\n     * @param {number} userID\n     * @returns {Object}\n     */\n    async sendMaintenanceListByUserID(userID) {\n        let list = await this.getMaintenanceJSONList(userID);\n        this.io.to(userID).emit(\"maintenanceList\", list);\n        return list;\n    }\n\n    /**\n     * Get a list of maintenances for the given user.\n     * @param {string} userID - The ID of the user to get maintenances for.\n     * @returns {Promise<Object>} A promise that resolves to an object with maintenance IDs as keys and maintenances objects as values.\n     */\n    async getMaintenanceJSONList(userID) {\n        let result = {};\n        for (let maintenanceID in this.maintenanceList) {\n            result[maintenanceID] = await this.maintenanceList[maintenanceID].toJSON();\n        }\n        return result;\n    }\n\n    /**\n     * Load maintenance list and run\n     * @param userID\n     * @returns {Promise<void>}\n     */\n    async loadMaintenanceList(userID) {\n        let maintenanceList = await R.findAll(\"maintenance\", \" ORDER BY end_date DESC, title\", [\n\n        ]);\n\n        for (let maintenance of maintenanceList) {\n            this.maintenanceList[maintenance.id] = maintenance;\n            maintenance.run(this);\n        }\n    }\n\n    getMaintenance(maintenanceID) {\n        if (this.maintenanceList[maintenanceID]) {\n            return this.maintenanceList[maintenanceID];\n        }\n        return null;\n    }\n\n    /**\n     * Write error to log file\n     * @param {any} error The error to write\n     * @param {boolean} outputToConsole Should the error also be output to console?\n     */\n    static errorLog(error, outputToConsole = true) {\n        const errorLogStream = fs.createWriteStream(path.join(Database.dataDir, \"/error.log\"), {\n            flags: \"a\"\n        });\n\n        errorLogStream.on(\"error\", () => {\n            log.info(\"\", \"Cannot write to error.log\");\n        });\n\n        if (errorLogStream) {\n            const dateTime = R.isoDateTime();\n            errorLogStream.write(`[${dateTime}] ` + util.format(error) + \"\\n\");\n\n            if (outputToConsole) {\n                console.error(error);\n            }\n        }\n\n        errorLogStream.end();\n    }\n\n    /**\n     * Get the IP of the client connected to the socket\n     * @param {Socket} socket\n     * @returns {string}\n     */\n    async getClientIP(socket) {\n        let clientIP = socket.client.conn.remoteAddress;\n\n        if (clientIP === undefined) {\n            clientIP = \"\";\n        }\n\n        if (await Settings.get(\"trustProxy\")) {\n            const forwardedFor = socket.client.conn.request.headers[\"x-forwarded-for\"];\n\n            return (typeof forwardedFor === \"string\" ? forwardedFor.split(\",\")[0].trim() : null)\n                || socket.client.conn.request.headers[\"x-real-ip\"]\n                || clientIP.replace(/^::ffff:/, \"\");\n        } else {\n            return clientIP.replace(/^::ffff:/, \"\");\n        }\n    }\n\n    /**\n     * Attempt to get the current server timezone\n     * If this fails, fall back to environment variables and then make a\n     * guess.\n     * @returns {Promise<string>}\n     */\n    async getTimezone() {\n        // From process.env.TZ\n        try {\n            if (process.env.TZ) {\n                this.checkTimezone(process.env.TZ);\n                return process.env.TZ;\n            }\n        } catch (e) {\n            log.warn(\"timezone\", e.message + \" in process.env.TZ\");\n        }\n\n        let timezone = await Settings.get(\"serverTimezone\");\n\n        // From Settings\n        try {\n            log.debug(\"timezone\", \"Using timezone from settings: \" + timezone);\n            if (timezone) {\n                this.checkTimezone(timezone);\n                return timezone;\n            }\n        } catch (e) {\n            log.warn(\"timezone\", e.message + \" in settings\");\n        }\n\n        // Guess\n        try {\n            let guess = dayjs.tz.guess();\n            log.debug(\"timezone\", \"Guessing timezone: \" + guess);\n            if (guess) {\n                this.checkTimezone(guess);\n                return guess;\n            } else {\n                return \"UTC\";\n            }\n        } catch (e) {\n            // Guess failed, fall back to UTC\n            log.debug(\"timezone\", \"Guessed an invalid timezone. Use UTC as fallback\");\n            return \"UTC\";\n        }\n    }\n\n    /**\n     * Get the current offset\n     * @returns {string}\n     */\n    getTimezoneOffset() {\n        return dayjs().format(\"Z\");\n    }\n\n    /**\n     * Throw an error if the timezone is invalid\n     * @param timezone\n     */\n    checkTimezone(timezone) {\n        try {\n            dayjs.utc(\"2013-11-18 11:55\").tz(timezone).format();\n        } catch (e) {\n            throw new Error(\"Invalid timezone:\" + timezone);\n        }\n    }\n\n    /**\n     * Set the current server timezone and environment variables\n     * @param {string} timezone\n     */\n    async setTimezone(timezone) {\n        this.checkTimezone(timezone);\n        await Settings.set(\"serverTimezone\", timezone, \"general\");\n        process.env.TZ = timezone;\n        dayjs.tz.setDefault(timezone);\n    }\n\n    /**\n     * TODO: Listen logic should be moved to here\n     * @returns {Promise<void>}\n     */\n    async start() {\n        let enable = await Settings.get(\"nscd\");\n\n        if (enable || enable === null) {\n            await this.startNSCDServices();\n        }\n    }\n\n    /**\n     * Stop the server\n     * @returns {Promise<void>}\n     */\n    async stop() {\n        let enable = await Settings.get(\"nscd\");\n\n        if (enable || enable === null) {\n            await this.stopNSCDServices();\n        }\n    }\n\n    /**\n     * Start all system services (e.g. nscd)\n     * For now, only used in Docker\n     */\n    async startNSCDServices() {\n        if (process.env.UPTIME_KUMA_IS_CONTAINER) {\n            try {\n                log.info(\"services\", \"Starting nscd\");\n                await childProcessAsync.exec(\"sudo service nscd start\");\n            } catch (e) {\n                log.info(\"services\", \"Failed to start nscd\");\n            }\n        }\n    }\n\n    /**\n     * Stop all system services\n     */\n    async stopNSCDServices() {\n        if (process.env.UPTIME_KUMA_IS_CONTAINER) {\n            try {\n                log.info(\"services\", \"Stopping nscd\");\n                await childProcessAsync.exec(\"sudo service nscd stop\");\n            } catch (e) {\n                log.info(\"services\", \"Failed to stop nscd\");\n            }\n        }\n    }\n}\n\nmodule.exports = {\n    UptimeKumaServer\n};\n\n// Must be at the end to avoid circular dependencies\nconst { RealBrowserMonitorType } = require(\"./monitor-types/real-browser-monitor-type\");\nconst { TailscalePing } = require(\"./monitor-types/tailscale-ping\");\n"], "fixing_code": ["/*\n * Uptime Kuma Server\n * node \"server/server.js\"\n * DO NOT require(\"./server\") in other modules, it likely creates circular dependency!\n */\nconsole.log(\"Welcome to Uptime Kuma\");\n\n// As the log function need to use dayjs, it should be very top\nconst dayjs = require(\"dayjs\");\ndayjs.extend(require(\"dayjs/plugin/utc\"));\ndayjs.extend(require(\"./modules/dayjs/plugin/timezone\"));\ndayjs.extend(require(\"dayjs/plugin/customParseFormat\"));\n\n// Load environment variables from `.env`\nrequire(\"dotenv\").config();\n\n// Check Node.js Version\nconst nodeVersion = process.versions.node;\n\n// Get the required Node.js version from package.json\nconst requiredNodeVersions = require(\"../package.json\").engines.node;\nconst bannedNodeVersions = \" < 14 || 20.0.* || 20.1.* || 20.2.* || 20.3.* \";\nconsole.log(`Your Node.js version: ${nodeVersion}`);\n\nconst semver = require(\"semver\");\nconst requiredNodeVersionsComma = requiredNodeVersions.split(\"||\").map((version) => version.trim()).join(\", \");\n\n// Exit Uptime Kuma immediately if the Node.js version is banned\nif (semver.satisfies(nodeVersion, bannedNodeVersions)) {\n    console.error(\"\\x1b[31m%s\\x1b[0m\", `Error: Your Node.js version: ${nodeVersion} is not supported, please upgrade your Node.js to ${requiredNodeVersionsComma}.`);\n    process.exit(-1);\n}\n\n// Warning if the Node.js version is not in the support list, but it maybe still works\nif (!semver.satisfies(nodeVersion, requiredNodeVersions)) {\n    console.warn(\"\\x1b[31m%s\\x1b[0m\", `Warning: Your Node.js version: ${nodeVersion} is not officially supported, please upgrade your Node.js to ${requiredNodeVersionsComma}.`);\n}\n\nconst args = require(\"args-parser\")(process.argv);\nconst { sleep, log, getRandomInt, genSecret, isDev } = require(\"../src/util\");\nconst config = require(\"./config\");\n\nlog.info(\"server\", \"Welcome to Uptime Kuma\");\nlog.debug(\"server\", \"Arguments\");\nlog.debug(\"server\", args);\n\nif (! process.env.NODE_ENV) {\n    process.env.NODE_ENV = \"production\";\n}\n\nif (!process.env.UPTIME_KUMA_WS_ORIGIN_CHECK) {\n    process.env.UPTIME_KUMA_WS_ORIGIN_CHECK = \"cors-like\";\n}\n\nlog.info(\"server\", \"Node Env: \" + process.env.NODE_ENV);\nlog.info(\"server\", \"Inside Container: \" + (process.env.UPTIME_KUMA_IS_CONTAINER === \"1\"));\nlog.info(\"server\", \"WebSocket Origin Check: \" + process.env.UPTIME_KUMA_WS_ORIGIN_CHECK);\n\nlog.info(\"server\", \"Importing Node libraries\");\nconst fs = require(\"fs\");\n\nlog.info(\"server\", \"Importing 3rd-party libraries\");\n\nlog.debug(\"server\", \"Importing express\");\nconst express = require(\"express\");\nconst expressStaticGzip = require(\"express-static-gzip\");\nlog.debug(\"server\", \"Importing redbean-node\");\nconst { R } = require(\"redbean-node\");\nlog.debug(\"server\", \"Importing jsonwebtoken\");\nconst jwt = require(\"jsonwebtoken\");\nlog.debug(\"server\", \"Importing http-graceful-shutdown\");\nconst gracefulShutdown = require(\"http-graceful-shutdown\");\nlog.debug(\"server\", \"Importing prometheus-api-metrics\");\nconst prometheusAPIMetrics = require(\"prometheus-api-metrics\");\nlog.debug(\"server\", \"Importing compare-versions\");\nconst compareVersions = require(\"compare-versions\");\nconst { passwordStrength } = require(\"check-password-strength\");\n\nlog.debug(\"server\", \"Importing 2FA Modules\");\nconst notp = require(\"notp\");\nconst base32 = require(\"thirty-two\");\n\nconst { UptimeKumaServer } = require(\"./uptime-kuma-server\");\nconst server = UptimeKumaServer.getInstance(args);\nconst io = module.exports.io = server.io;\nconst app = server.app;\n\nlog.info(\"server\", \"Importing this project modules\");\nlog.debug(\"server\", \"Importing Monitor\");\nconst Monitor = require(\"./model/monitor\");\nconst User = require(\"./model/user\");\n\nlog.debug(\"server\", \"Importing Settings\");\nconst { getSettings, setSettings, setting, initJWTSecret, checkLogin, startUnitTest, FBSD, doubleCheckPassword, startE2eTests, shake256, SHAKE256_LENGTH\n} = require(\"./util-server\");\n\nlog.debug(\"server\", \"Importing Notification\");\nconst { Notification } = require(\"./notification\");\nNotification.init();\n\nlog.debug(\"server\", \"Importing Proxy\");\nconst { Proxy } = require(\"./proxy\");\n\nlog.debug(\"server\", \"Importing Database\");\nconst Database = require(\"./database\");\n\nlog.debug(\"server\", \"Importing Background Jobs\");\nconst { initBackgroundJobs, stopBackgroundJobs } = require(\"./jobs\");\nconst { loginRateLimiter, twoFaRateLimiter } = require(\"./rate-limiter\");\n\nconst { apiAuth } = require(\"./auth\");\nconst { login } = require(\"./auth\");\nconst passwordHash = require(\"./password-hash\");\n\nconst checkVersion = require(\"./check-version\");\nlog.info(\"server\", \"Version: \" + checkVersion.version);\n\n// If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available and the unspecified IPv4 address (0.0.0.0) otherwise.\n// Dual-stack support for (::)\n// Also read HOST if not FreeBSD, as HOST is a system environment variable in FreeBSD\nlet hostEnv = FBSD ? null : process.env.HOST;\nlet hostname = args.host || process.env.UPTIME_KUMA_HOST || hostEnv;\n\nif (hostname) {\n    log.info(\"server\", \"Custom hostname: \" + hostname);\n}\n\nconst port = [ args.port, process.env.UPTIME_KUMA_PORT, process.env.PORT, 3001 ]\n    .map(portValue => parseInt(portValue))\n    .find(portValue => !isNaN(portValue));\n\nconst disableFrameSameOrigin = !!process.env.UPTIME_KUMA_DISABLE_FRAME_SAMEORIGIN || args[\"disable-frame-sameorigin\"] || false;\nconst cloudflaredToken = args[\"cloudflared-token\"] || process.env.UPTIME_KUMA_CLOUDFLARED_TOKEN || undefined;\n\n// 2FA / notp verification defaults\nconst twoFAVerifyOptions = {\n    \"window\": 1,\n    \"time\": 30\n};\n\n/**\n * Run unit test after the server is ready\n * @type {boolean}\n */\nconst testMode = !!args[\"test\"] || false;\nconst e2eTestMode = !!args[\"e2e\"] || false;\n\nif (config.demoMode) {\n    log.info(\"server\", \"==== Demo Mode ====\");\n}\n\n// Must be after io instantiation\nconst { sendNotificationList, sendHeartbeatList, sendImportantHeartbeatList, sendInfo, sendProxyList, sendDockerHostList, sendAPIKeyList } = require(\"./client\");\nconst { statusPageSocketHandler } = require(\"./socket-handlers/status-page-socket-handler\");\nconst databaseSocketHandler = require(\"./socket-handlers/database-socket-handler\");\nconst TwoFA = require(\"./2fa\");\nconst StatusPage = require(\"./model/status_page\");\nconst { cloudflaredSocketHandler, autoStart: cloudflaredAutoStart, stop: cloudflaredStop } = require(\"./socket-handlers/cloudflared-socket-handler\");\nconst { proxySocketHandler } = require(\"./socket-handlers/proxy-socket-handler\");\nconst { dockerSocketHandler } = require(\"./socket-handlers/docker-socket-handler\");\nconst { maintenanceSocketHandler } = require(\"./socket-handlers/maintenance-socket-handler\");\nconst { apiKeySocketHandler } = require(\"./socket-handlers/api-key-socket-handler\");\nconst { generalSocketHandler } = require(\"./socket-handlers/general-socket-handler\");\nconst { Settings } = require(\"./settings\");\nconst { CacheableDnsHttpAgent } = require(\"./cacheable-dns-http-agent\");\nconst apicache = require(\"./modules/apicache\");\nconst { resetChrome } = require(\"./monitor-types/real-browser-monitor-type\");\n\napp.use(express.json());\n\n// Global Middleware\napp.use(function (req, res, next) {\n    if (!disableFrameSameOrigin) {\n        res.setHeader(\"X-Frame-Options\", \"SAMEORIGIN\");\n    }\n    res.removeHeader(\"X-Powered-By\");\n    next();\n});\n\n/**\n * Show Setup Page\n * @type {boolean}\n */\nlet needSetup = false;\n\n(async () => {\n    Database.init(args);\n    await initDatabase(testMode);\n    await server.initAfterDatabaseReady();\n    server.entryPage = await Settings.get(\"entryPage\");\n    await StatusPage.loadDomainMappingList();\n\n    log.info(\"server\", \"Adding route\");\n\n    // ***************************\n    // Normal Router here\n    // ***************************\n\n    // Entry Page\n    app.get(\"/\", async (request, response) => {\n        let hostname = request.hostname;\n        if (await setting(\"trustProxy\")) {\n            const proxy = request.headers[\"x-forwarded-host\"];\n            if (proxy) {\n                hostname = proxy;\n            }\n        }\n\n        log.debug(\"entry\", `Request Domain: ${hostname}`);\n\n        const uptimeKumaEntryPage = server.entryPage;\n        if (hostname in StatusPage.domainMappingList) {\n            log.debug(\"entry\", \"This is a status page domain\");\n\n            let slug = StatusPage.domainMappingList[hostname];\n            await StatusPage.handleStatusPageResponse(response, server.indexHTML, slug);\n\n        } else if (uptimeKumaEntryPage && uptimeKumaEntryPage.startsWith(\"statusPage-\")) {\n            response.redirect(\"/status/\" + uptimeKumaEntryPage.replace(\"statusPage-\", \"\"));\n\n        } else {\n            response.redirect(\"/dashboard\");\n        }\n    });\n\n    if (isDev) {\n        app.use(express.urlencoded({ extended: true }));\n        app.post(\"/test-webhook\", async (request, response) => {\n            log.debug(\"test\", request.headers);\n            log.debug(\"test\", request.body);\n            response.send(\"OK\");\n        });\n    }\n\n    // Robots.txt\n    app.get(\"/robots.txt\", async (_request, response) => {\n        let txt = \"User-agent: *\\nDisallow:\";\n        if (!await setting(\"searchEngineIndex\")) {\n            txt += \" /\";\n        }\n        response.setHeader(\"Content-Type\", \"text/plain\");\n        response.send(txt);\n    });\n\n    // Basic Auth Router here\n\n    // Prometheus API metrics  /metrics\n    // With Basic Auth using the first user's username/password\n    app.get(\"/metrics\", apiAuth, prometheusAPIMetrics());\n\n    app.use(\"/\", expressStaticGzip(\"dist\", {\n        enableBrotli: true,\n    }));\n\n    // ./data/upload\n    app.use(\"/upload\", express.static(Database.uploadDir));\n\n    app.get(\"/.well-known/change-password\", async (_, response) => {\n        response.redirect(\"https://github.com/louislam/uptime-kuma/wiki/Reset-Password-via-CLI\");\n    });\n\n    // API Router\n    const apiRouter = require(\"./routers/api-router\");\n    app.use(apiRouter);\n\n    // Status Page Router\n    const statusPageRouter = require(\"./routers/status-page-router\");\n    app.use(statusPageRouter);\n\n    // Universal Route Handler, must be at the end of all express routes.\n    app.get(\"*\", async (_request, response) => {\n        if (_request.originalUrl.startsWith(\"/upload/\")) {\n            response.status(404).send(\"File not found.\");\n        } else {\n            response.send(server.indexHTML);\n        }\n    });\n\n    log.info(\"server\", \"Adding socket handler\");\n    io.on(\"connection\", async (socket) => {\n\n        sendInfo(socket, true);\n\n        if (needSetup) {\n            log.info(\"server\", \"Redirect to setup page\");\n            socket.emit(\"setup\");\n        }\n\n        // ***************************\n        // Public Socket API\n        // ***************************\n\n        socket.on(\"loginByToken\", async (token, callback) => {\n            const clientIP = await server.getClientIP(socket);\n\n            log.info(\"auth\", `Login by token. IP=${clientIP}`);\n\n            try {\n                let decoded = jwt.verify(token, server.jwtSecret);\n\n                log.info(\"auth\", \"Username from JWT: \" + decoded.username);\n\n                let user = await R.findOne(\"user\", \" username = ? AND active = 1 \", [\n                    decoded.username,\n                ]);\n\n                if (user) {\n                    // Check if the password changed\n                    if (decoded.h !== shake256(user.password, SHAKE256_LENGTH)) {\n                        throw new Error(\"The token is invalid due to password change or old token\");\n                    }\n\n                    log.debug(\"auth\", \"afterLogin\");\n                    afterLogin(socket, user);\n                    log.debug(\"auth\", \"afterLogin ok\");\n\n                    log.info(\"auth\", `Successfully logged in user ${decoded.username}. IP=${clientIP}`);\n\n                    callback({\n                        ok: true,\n                    });\n                } else {\n\n                    log.info(\"auth\", `Inactive or deleted user ${decoded.username}. IP=${clientIP}`);\n\n                    callback({\n                        ok: false,\n                        msg: \"The user is inactive or deleted.\",\n                    });\n                }\n            } catch (error) {\n                log.error(\"auth\", `Invalid token. IP=${clientIP}`);\n                if (error.message) {\n                    log.error(\"auth\", error.message, `IP=${clientIP}`);\n                }\n                callback({\n                    ok: false,\n                    msg: \"Invalid token.\",\n                });\n            }\n\n        });\n\n        socket.on(\"login\", async (data, callback) => {\n            const clientIP = await server.getClientIP(socket);\n\n            log.info(\"auth\", `Login by username + password. IP=${clientIP}`);\n\n            // Checking\n            if (typeof callback !== \"function\") {\n                return;\n            }\n\n            if (!data) {\n                return;\n            }\n\n            // Login Rate Limit\n            if (! await loginRateLimiter.pass(callback)) {\n                log.info(\"auth\", `Too many failed requests for user ${data.username}. IP=${clientIP}`);\n                return;\n            }\n\n            let user = await login(data.username, data.password);\n\n            if (user) {\n                if (user.twofa_status === 0) {\n                    afterLogin(socket, user);\n\n                    log.info(\"auth\", `Successfully logged in user ${data.username}. IP=${clientIP}`);\n\n                    callback({\n                        ok: true,\n                        token: User.createJWT(user, server.jwtSecret),\n                    });\n                }\n\n                if (user.twofa_status === 1 && !data.token) {\n\n                    log.info(\"auth\", `2FA token required for user ${data.username}. IP=${clientIP}`);\n\n                    callback({\n                        tokenRequired: true,\n                    });\n                }\n\n                if (data.token) {\n                    let verify = notp.totp.verify(data.token, user.twofa_secret, twoFAVerifyOptions);\n\n                    if (user.twofa_last_token !== data.token && verify) {\n                        afterLogin(socket, user);\n\n                        await R.exec(\"UPDATE `user` SET twofa_last_token = ? WHERE id = ? \", [\n                            data.token,\n                            socket.userID,\n                        ]);\n\n                        log.info(\"auth\", `Successfully logged in user ${data.username}. IP=${clientIP}`);\n\n                        callback({\n                            ok: true,\n                            token: User.createJWT(user, server.jwtSecret),\n                        });\n                    } else {\n\n                        log.warn(\"auth\", `Invalid token provided for user ${data.username}. IP=${clientIP}`);\n\n                        callback({\n                            ok: false,\n                            msg: \"Invalid Token!\",\n                        });\n                    }\n                }\n            } else {\n\n                log.warn(\"auth\", `Incorrect username or password for user ${data.username}. IP=${clientIP}`);\n\n                callback({\n                    ok: false,\n                    msg: \"Incorrect username or password.\",\n                });\n            }\n\n        });\n\n        socket.on(\"logout\", async (callback) => {\n            // Rate Limit\n            if (! await loginRateLimiter.pass(callback)) {\n                return;\n            }\n\n            socket.leave(socket.userID);\n            socket.userID = null;\n\n            if (typeof callback === \"function\") {\n                callback();\n            }\n        });\n\n        socket.on(\"prepare2FA\", async (currentPassword, callback) => {\n            try {\n                if (! await twoFaRateLimiter.pass(callback)) {\n                    return;\n                }\n\n                checkLogin(socket);\n                await doubleCheckPassword(socket, currentPassword);\n\n                let user = await R.findOne(\"user\", \" id = ? AND active = 1 \", [\n                    socket.userID,\n                ]);\n\n                if (user.twofa_status === 0) {\n                    let newSecret = genSecret();\n                    let encodedSecret = base32.encode(newSecret);\n\n                    // Google authenticator doesn't like equal signs\n                    // The fix is found at https://github.com/guyht/notp\n                    // Related issue: https://github.com/louislam/uptime-kuma/issues/486\n                    encodedSecret = encodedSecret.toString().replace(/=/g, \"\");\n\n                    let uri = `otpauth://totp/Uptime%20Kuma:${user.username}?secret=${encodedSecret}`;\n\n                    await R.exec(\"UPDATE `user` SET twofa_secret = ? WHERE id = ? \", [\n                        newSecret,\n                        socket.userID,\n                    ]);\n\n                    callback({\n                        ok: true,\n                        uri: uri,\n                    });\n                } else {\n                    callback({\n                        ok: false,\n                        msg: \"2FA is already enabled.\",\n                    });\n                }\n            } catch (error) {\n                callback({\n                    ok: false,\n                    msg: error.message,\n                });\n            }\n        });\n\n        socket.on(\"save2FA\", async (currentPassword, callback) => {\n            const clientIP = await server.getClientIP(socket);\n\n            try {\n                if (! await twoFaRateLimiter.pass(callback)) {\n                    return;\n                }\n\n                checkLogin(socket);\n                await doubleCheckPassword(socket, currentPassword);\n\n                await R.exec(\"UPDATE `user` SET twofa_status = 1 WHERE id = ? \", [\n                    socket.userID,\n                ]);\n\n                log.info(\"auth\", `Saved 2FA token. IP=${clientIP}`);\n\n                callback({\n                    ok: true,\n                    msg: \"2FA Enabled.\",\n                });\n            } catch (error) {\n\n                log.error(\"auth\", `Error changing 2FA token. IP=${clientIP}`);\n\n                callback({\n                    ok: false,\n                    msg: error.message,\n                });\n            }\n        });\n\n        socket.on(\"disable2FA\", async (currentPassword, callback) => {\n            const clientIP = await server.getClientIP(socket);\n\n            try {\n                if (! await twoFaRateLimiter.pass(callback)) {\n                    return;\n                }\n\n                checkLogin(socket);\n                await doubleCheckPassword(socket, currentPassword);\n                await TwoFA.disable2FA(socket.userID);\n\n                log.info(\"auth\", `Disabled 2FA token. IP=${clientIP}`);\n\n                callback({\n                    ok: true,\n                    msg: \"2FA Disabled.\",\n                });\n            } catch (error) {\n\n                log.error(\"auth\", `Error disabling 2FA token. IP=${clientIP}`);\n\n                callback({\n                    ok: false,\n                    msg: error.message,\n                });\n            }\n        });\n\n        socket.on(\"verifyToken\", async (token, currentPassword, callback) => {\n            try {\n                checkLogin(socket);\n                await doubleCheckPassword(socket, currentPassword);\n\n                let user = await R.findOne(\"user\", \" id = ? AND active = 1 \", [\n                    socket.userID,\n                ]);\n\n                let verify = notp.totp.verify(token, user.twofa_secret, twoFAVerifyOptions);\n\n                if (user.twofa_last_token !== token && verify) {\n                    callback({\n                        ok: true,\n                        valid: true,\n                    });\n                } else {\n                    callback({\n                        ok: false,\n                        msg: \"Invalid Token.\",\n                        valid: false,\n                    });\n                }\n\n            } catch (error) {\n                callback({\n                    ok: false,\n                    msg: error.message,\n                });\n            }\n        });\n\n        socket.on(\"twoFAStatus\", async (callback) => {\n            try {\n                checkLogin(socket);\n\n                let user = await R.findOne(\"user\", \" id = ? AND active = 1 \", [\n                    socket.userID,\n                ]);\n\n                if (user.twofa_status === 1) {\n                    callback({\n                        ok: true,\n                        status: true,\n                    });\n                } else {\n                    callback({\n                        ok: true,\n                        status: false,\n                    });\n                }\n            } catch (error) {\n                callback({\n                    ok: false,\n                    msg: error.message,\n                });\n            }\n        });\n\n        socket.on(\"needSetup\", async (callback) => {\n            callback(needSetup);\n        });\n\n        socket.on(\"setup\", async (username, password, callback) => {\n            try {\n                if (passwordStrength(password).value === \"Too weak\") {\n                    throw new Error(\"Password is too weak. It should contain alphabetic and numeric characters. It must be at least 6 characters in length.\");\n                }\n\n                if ((await R.count(\"user\")) !== 0) {\n                    throw new Error(\"Uptime Kuma has been initialized. If you want to run setup again, please delete the database.\");\n                }\n\n                let user = R.dispense(\"user\");\n                user.username = username;\n                user.password = passwordHash.generate(password);\n                await R.store(user);\n\n                needSetup = false;\n\n                callback({\n                    ok: true,\n                    msg: \"Added Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        // ***************************\n        // Auth Only API\n        // ***************************\n\n        // Add a new monitor\n        socket.on(\"add\", async (monitor, callback) => {\n            try {\n                checkLogin(socket);\n                let bean = R.dispense(\"monitor\");\n\n                let notificationIDList = monitor.notificationIDList;\n                delete monitor.notificationIDList;\n\n                // Ensure status code ranges are strings\n                if (!monitor.accepted_statuscodes.every((code) => typeof code === \"string\")) {\n                    throw new Error(\"Accepted status codes are not all strings\");\n                }\n                monitor.accepted_statuscodes_json = JSON.stringify(monitor.accepted_statuscodes);\n                delete monitor.accepted_statuscodes;\n\n                monitor.kafkaProducerBrokers = JSON.stringify(monitor.kafkaProducerBrokers);\n                monitor.kafkaProducerSaslOptions = JSON.stringify(monitor.kafkaProducerSaslOptions);\n\n                bean.import(monitor);\n                bean.user_id = socket.userID;\n\n                bean.validate();\n\n                await R.store(bean);\n\n                await updateMonitorNotification(bean.id, notificationIDList);\n\n                await server.sendMonitorList(socket);\n\n                if (monitor.active !== false) {\n                    await startMonitor(socket.userID, bean.id);\n                }\n\n                log.info(\"monitor\", `Added Monitor: ${monitor.id} User ID: ${socket.userID}`);\n\n                callback({\n                    ok: true,\n                    msg: \"Added Successfully.\",\n                    monitorID: bean.id,\n                });\n\n            } catch (e) {\n\n                log.error(\"monitor\", `Error adding Monitor: ${monitor.id} User ID: ${socket.userID}`);\n\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        // Edit a monitor\n        socket.on(\"editMonitor\", async (monitor, callback) => {\n            try {\n                let removeGroupChildren = false;\n                checkLogin(socket);\n\n                let bean = await R.findOne(\"monitor\", \" id = ? \", [ monitor.id ]);\n\n                if (bean.user_id !== socket.userID) {\n                    throw new Error(\"Permission denied.\");\n                }\n\n                // Check if Parent is Descendant (would cause endless loop)\n                if (monitor.parent !== null) {\n                    const childIDs = await Monitor.getAllChildrenIDs(monitor.id);\n                    if (childIDs.includes(monitor.parent)) {\n                        throw new Error(\"Invalid Monitor Group\");\n                    }\n                }\n\n                // Remove children if monitor type has changed (from group to non-group)\n                if (bean.type === \"group\" && monitor.type !== bean.type) {\n                    removeGroupChildren = true;\n                }\n\n                // Ensure status code ranges are strings\n                if (!monitor.accepted_statuscodes.every((code) => typeof code === \"string\")) {\n                    throw new Error(\"Accepted status codes are not all strings\");\n                }\n\n                bean.name = monitor.name;\n                bean.description = monitor.description;\n                bean.parent = monitor.parent;\n                bean.type = monitor.type;\n                bean.url = monitor.url;\n                bean.method = monitor.method;\n                bean.body = monitor.body;\n                bean.headers = monitor.headers;\n                bean.basic_auth_user = monitor.basic_auth_user;\n                bean.basic_auth_pass = monitor.basic_auth_pass;\n                bean.timeout = monitor.timeout;\n                bean.oauth_client_id = monitor.oauth_client_id;\n                bean.oauth_client_secret = monitor.oauth_client_secret;\n                bean.oauth_auth_method = monitor.oauth_auth_method;\n                bean.oauth_token_url = monitor.oauth_token_url;\n                bean.oauth_scopes = monitor.oauth_scopes;\n                bean.tlsCa = monitor.tlsCa;\n                bean.tlsCert = monitor.tlsCert;\n                bean.tlsKey = monitor.tlsKey;\n                bean.interval = monitor.interval;\n                bean.retryInterval = monitor.retryInterval;\n                bean.resendInterval = monitor.resendInterval;\n                bean.hostname = monitor.hostname;\n                bean.game = monitor.game;\n                bean.maxretries = monitor.maxretries;\n                bean.port = parseInt(monitor.port);\n                bean.keyword = monitor.keyword;\n                bean.invertKeyword = monitor.invertKeyword;\n                bean.ignoreTls = monitor.ignoreTls;\n                bean.expiryNotification = monitor.expiryNotification;\n                bean.upsideDown = monitor.upsideDown;\n                bean.packetSize = monitor.packetSize;\n                bean.maxredirects = monitor.maxredirects;\n                bean.accepted_statuscodes_json = JSON.stringify(monitor.accepted_statuscodes);\n                bean.dns_resolve_type = monitor.dns_resolve_type;\n                bean.dns_resolve_server = monitor.dns_resolve_server;\n                bean.pushToken = monitor.pushToken;\n                bean.docker_container = monitor.docker_container;\n                bean.docker_host = monitor.docker_host;\n                bean.proxyId = Number.isInteger(monitor.proxyId) ? monitor.proxyId : null;\n                bean.mqttUsername = monitor.mqttUsername;\n                bean.mqttPassword = monitor.mqttPassword;\n                bean.mqttTopic = monitor.mqttTopic;\n                bean.mqttSuccessMessage = monitor.mqttSuccessMessage;\n                bean.databaseConnectionString = monitor.databaseConnectionString;\n                bean.databaseQuery = monitor.databaseQuery;\n                bean.authMethod = monitor.authMethod;\n                bean.authWorkstation = monitor.authWorkstation;\n                bean.authDomain = monitor.authDomain;\n                bean.grpcUrl = monitor.grpcUrl;\n                bean.grpcProtobuf = monitor.grpcProtobuf;\n                bean.grpcServiceName = monitor.grpcServiceName;\n                bean.grpcMethod = monitor.grpcMethod;\n                bean.grpcBody = monitor.grpcBody;\n                bean.grpcMetadata = monitor.grpcMetadata;\n                bean.grpcEnableTls = monitor.grpcEnableTls;\n                bean.radiusUsername = monitor.radiusUsername;\n                bean.radiusPassword = monitor.radiusPassword;\n                bean.radiusCalledStationId = monitor.radiusCalledStationId;\n                bean.radiusCallingStationId = monitor.radiusCallingStationId;\n                bean.radiusSecret = monitor.radiusSecret;\n                bean.httpBodyEncoding = monitor.httpBodyEncoding;\n                bean.expectedValue = monitor.expectedValue;\n                bean.jsonPath = monitor.jsonPath;\n                bean.kafkaProducerTopic = monitor.kafkaProducerTopic;\n                bean.kafkaProducerBrokers = JSON.stringify(monitor.kafkaProducerBrokers);\n                bean.kafkaProducerAllowAutoTopicCreation = monitor.kafkaProducerAllowAutoTopicCreation;\n                bean.kafkaProducerSaslOptions = JSON.stringify(monitor.kafkaProducerSaslOptions);\n                bean.kafkaProducerMessage = monitor.kafkaProducerMessage;\n                bean.kafkaProducerSsl = monitor.kafkaProducerSsl;\n                bean.kafkaProducerAllowAutoTopicCreation =\n                    monitor.kafkaProducerAllowAutoTopicCreation;\n                bean.gamedigGivenPortOnly = monitor.gamedigGivenPortOnly;\n\n                bean.validate();\n\n                await R.store(bean);\n\n                if (removeGroupChildren) {\n                    await Monitor.unlinkAllChildren(monitor.id);\n                }\n\n                await updateMonitorNotification(bean.id, monitor.notificationIDList);\n\n                if (await bean.isActive()) {\n                    await restartMonitor(socket.userID, bean.id);\n                }\n\n                await server.sendMonitorList(socket);\n\n                callback({\n                    ok: true,\n                    msg: \"Saved.\",\n                    monitorID: bean.id,\n                });\n\n            } catch (e) {\n                log.error(\"monitor\", e);\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"getMonitorList\", async (callback) => {\n            try {\n                checkLogin(socket);\n                await server.sendMonitorList(socket);\n                callback({\n                    ok: true,\n                });\n            } catch (e) {\n                log.error(\"monitor\", e);\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"getMonitor\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"monitor\", `Get Monitor: ${monitorID} User ID: ${socket.userID}`);\n\n                let bean = await R.findOne(\"monitor\", \" id = ? AND user_id = ? \", [\n                    monitorID,\n                    socket.userID,\n                ]);\n\n                callback({\n                    ok: true,\n                    monitor: await bean.toJSON(),\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"getMonitorBeats\", async (monitorID, period, callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"monitor\", `Get Monitor Beats: ${monitorID} User ID: ${socket.userID}`);\n\n                if (period == null) {\n                    throw new Error(\"Invalid period.\");\n                }\n\n                let list = await R.getAll(`\n                    SELECT * FROM heartbeat\n                    WHERE monitor_id = ? AND\n                    time > DATETIME('now', '-' || ? || ' hours')\n                    ORDER BY time ASC\n                `, [\n                    monitorID,\n                    period,\n                ]);\n\n                callback({\n                    ok: true,\n                    data: list,\n                });\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        // Start or Resume the monitor\n        socket.on(\"resumeMonitor\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n                await startMonitor(socket.userID, monitorID);\n                await server.sendMonitorList(socket);\n\n                callback({\n                    ok: true,\n                    msg: \"Resumed Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"pauseMonitor\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n                await pauseMonitor(socket.userID, monitorID);\n                await server.sendMonitorList(socket);\n\n                callback({\n                    ok: true,\n                    msg: \"Paused Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"deleteMonitor\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"manage\", `Delete Monitor: ${monitorID} User ID: ${socket.userID}`);\n\n                if (monitorID in server.monitorList) {\n                    server.monitorList[monitorID].stop();\n                    delete server.monitorList[monitorID];\n                }\n\n                const startTime = Date.now();\n\n                await R.exec(\"DELETE FROM monitor WHERE id = ? AND user_id = ? \", [\n                    monitorID,\n                    socket.userID,\n                ]);\n\n                // Fix #2880\n                apicache.clear();\n\n                const endTime = Date.now();\n\n                log.info(\"DB\", `Delete Monitor completed in : ${endTime - startTime} ms`);\n\n                callback({\n                    ok: true,\n                    msg: \"Deleted Successfully.\",\n                });\n\n                await server.sendMonitorList(socket);\n                // Clear heartbeat list on client\n                await sendImportantHeartbeatList(socket, monitorID, true, true);\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"getTags\", async (callback) => {\n            try {\n                checkLogin(socket);\n\n                const list = await R.findAll(\"tag\");\n\n                callback({\n                    ok: true,\n                    tags: list.map(bean => bean.toJSON()),\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"addTag\", async (tag, callback) => {\n            try {\n                checkLogin(socket);\n\n                let bean = R.dispense(\"tag\");\n                bean.name = tag.name;\n                bean.color = tag.color;\n                await R.store(bean);\n\n                callback({\n                    ok: true,\n                    tag: await bean.toJSON(),\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"editTag\", async (tag, callback) => {\n            try {\n                checkLogin(socket);\n\n                let bean = await R.findOne(\"tag\", \" id = ? \", [ tag.id ]);\n                if (bean == null) {\n                    callback({\n                        ok: false,\n                        msg: \"Tag not found\",\n                    });\n                    return;\n                }\n                bean.name = tag.name;\n                bean.color = tag.color;\n                await R.store(bean);\n\n                callback({\n                    ok: true,\n                    msg: \"Saved\",\n                    tag: await bean.toJSON(),\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"deleteTag\", async (tagID, callback) => {\n            try {\n                checkLogin(socket);\n\n                await R.exec(\"DELETE FROM tag WHERE id = ? \", [ tagID ]);\n\n                callback({\n                    ok: true,\n                    msg: \"Deleted Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"addMonitorTag\", async (tagID, monitorID, value, callback) => {\n            try {\n                checkLogin(socket);\n\n                await R.exec(\"INSERT INTO monitor_tag (tag_id, monitor_id, value) VALUES (?, ?, ?)\", [\n                    tagID,\n                    monitorID,\n                    value,\n                ]);\n\n                callback({\n                    ok: true,\n                    msg: \"Added Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"editMonitorTag\", async (tagID, monitorID, value, callback) => {\n            try {\n                checkLogin(socket);\n\n                await R.exec(\"UPDATE monitor_tag SET value = ? WHERE tag_id = ? AND monitor_id = ?\", [\n                    value,\n                    tagID,\n                    monitorID,\n                ]);\n\n                callback({\n                    ok: true,\n                    msg: \"Edited Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"deleteMonitorTag\", async (tagID, monitorID, value, callback) => {\n            try {\n                checkLogin(socket);\n\n                await R.exec(\"DELETE FROM monitor_tag WHERE tag_id = ? AND monitor_id = ? AND value = ?\", [\n                    tagID,\n                    monitorID,\n                    value,\n                ]);\n\n                callback({\n                    ok: true,\n                    msg: \"Deleted Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"changePassword\", async (password, callback) => {\n            try {\n                checkLogin(socket);\n\n                if (! password.newPassword) {\n                    throw new Error(\"Invalid new password\");\n                }\n\n                if (passwordStrength(password.newPassword).value === \"Too weak\") {\n                    throw new Error(\"Password is too weak. It should contain alphabetic and numeric characters. It must be at least 6 characters in length.\");\n                }\n\n                let user = await doubleCheckPassword(socket, password.currentPassword);\n                await user.resetPassword(password.newPassword);\n\n                callback({\n                    ok: true,\n                    msg: \"Password has been updated successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"getSettings\", async (callback) => {\n            try {\n                checkLogin(socket);\n                const data = await getSettings(\"general\");\n\n                if (!data.serverTimezone) {\n                    data.serverTimezone = await server.getTimezone();\n                }\n\n                callback({\n                    ok: true,\n                    data: data,\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"setSettings\", async (data, currentPassword, callback) => {\n            try {\n                checkLogin(socket);\n\n                // If currently is disabled auth, don't need to check\n                // Disabled Auth + Want to Disable Auth => No Check\n                // Disabled Auth + Want to Enable Auth => No Check\n                // Enabled Auth + Want to Disable Auth => Check!!\n                // Enabled Auth + Want to Enable Auth => No Check\n                const currentDisabledAuth = await setting(\"disableAuth\");\n                if (!currentDisabledAuth && data.disableAuth) {\n                    await doubleCheckPassword(socket, currentPassword);\n                }\n\n                const previousChromeExecutable = await Settings.get(\"chromeExecutable\");\n                const previousNSCDStatus = await Settings.get(\"nscd\");\n\n                await setSettings(\"general\", data);\n                server.entryPage = data.entryPage;\n\n                await CacheableDnsHttpAgent.update();\n\n                // Also need to apply timezone globally\n                if (data.serverTimezone) {\n                    await server.setTimezone(data.serverTimezone);\n                }\n\n                // If Chrome Executable is changed, need to reset the browser\n                if (previousChromeExecutable !== data.chromeExecutable) {\n                    log.info(\"settings\", \"Chrome executable is changed. Resetting Chrome...\");\n                    await resetChrome();\n                }\n\n                // Update nscd status\n                if (previousNSCDStatus !== data.nscd) {\n                    if (data.nscd) {\n                        await server.startNSCDServices();\n                    } else {\n                        await server.stopNSCDServices();\n                    }\n                }\n\n                callback({\n                    ok: true,\n                    msg: \"Saved\"\n                });\n\n                sendInfo(socket);\n                server.sendMaintenanceList(socket);\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        // Add or Edit\n        socket.on(\"addNotification\", async (notification, notificationID, callback) => {\n            try {\n                checkLogin(socket);\n\n                let notificationBean = await Notification.save(notification, notificationID, socket.userID);\n                await sendNotificationList(socket);\n\n                callback({\n                    ok: true,\n                    msg: \"Saved\",\n                    id: notificationBean.id,\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"deleteNotification\", async (notificationID, callback) => {\n            try {\n                checkLogin(socket);\n\n                await Notification.delete(notificationID, socket.userID);\n                await sendNotificationList(socket);\n\n                callback({\n                    ok: true,\n                    msg: \"Deleted\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"testNotification\", async (notification, callback) => {\n            try {\n                checkLogin(socket);\n\n                let msg = await Notification.send(notification, notification.name + \" Testing\");\n\n                callback({\n                    ok: true,\n                    msg,\n                });\n\n            } catch (e) {\n                console.error(e);\n\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"checkApprise\", async (callback) => {\n            try {\n                checkLogin(socket);\n                callback(Notification.checkApprise());\n            } catch (e) {\n                callback(false);\n            }\n        });\n\n        socket.on(\"uploadBackup\", async (uploadedJSON, importHandle, callback) => {\n            try {\n                checkLogin(socket);\n\n                let backupData = JSON.parse(uploadedJSON);\n\n                log.info(\"manage\", `Importing Backup, User ID: ${socket.userID}, Version: ${backupData.version}`);\n\n                let notificationListData = backupData.notificationList;\n                let proxyListData = backupData.proxyList;\n                let monitorListData = backupData.monitorList;\n\n                let version17x = compareVersions.compare(backupData.version, \"1.7.0\", \">=\");\n\n                // If the import option is \"overwrite\" it'll clear most of the tables, except \"settings\" and \"user\"\n                if (importHandle === \"overwrite\") {\n                    // Stops every monitor first, so it doesn't execute any heartbeat while importing\n                    for (let id in server.monitorList) {\n                        let monitor = server.monitorList[id];\n                        await monitor.stop();\n                    }\n                    await R.exec(\"DELETE FROM heartbeat\");\n                    await R.exec(\"DELETE FROM monitor_notification\");\n                    await R.exec(\"DELETE FROM monitor_tls_info\");\n                    await R.exec(\"DELETE FROM notification\");\n                    await R.exec(\"DELETE FROM monitor_tag\");\n                    await R.exec(\"DELETE FROM tag\");\n                    await R.exec(\"DELETE FROM monitor\");\n                    await R.exec(\"DELETE FROM proxy\");\n                }\n\n                // Only starts importing if the backup file contains at least one notification\n                if (notificationListData.length >= 1) {\n                    // Get every existing notification name and puts them in one simple string\n                    let notificationNameList = await R.getAll(\"SELECT name FROM notification\");\n                    let notificationNameListString = JSON.stringify(notificationNameList);\n\n                    for (let i = 0; i < notificationListData.length; i++) {\n                        // Only starts importing the notification if the import option is \"overwrite\", \"keep\" or \"skip\" but the notification doesn't exists\n                        if ((importHandle === \"skip\" && notificationNameListString.includes(notificationListData[i].name) === false) || importHandle === \"keep\" || importHandle === \"overwrite\") {\n\n                            let notification = JSON.parse(notificationListData[i].config);\n                            await Notification.save(notification, null, socket.userID);\n\n                        }\n                    }\n                }\n\n                // Only starts importing if the backup file contains at least one proxy\n                if (proxyListData && proxyListData.length >= 1) {\n                    const proxies = await R.findAll(\"proxy\");\n\n                    // Loop over proxy list and save proxies\n                    for (const proxy of proxyListData) {\n                        const exists = proxies.find(item => item.id === proxy.id);\n\n                        // Do not process when proxy already exists in import handle is skip and keep\n                        if ([ \"skip\", \"keep\" ].includes(importHandle) && !exists) {\n                            return;\n                        }\n\n                        // Save proxy as new entry if exists update exists one\n                        await Proxy.save(proxy, exists ? proxy.id : undefined, proxy.userId);\n                    }\n                }\n\n                // Only starts importing if the backup file contains at least one monitor\n                if (monitorListData.length >= 1) {\n                    // Get every existing monitor name and puts them in one simple string\n                    let monitorNameList = await R.getAll(\"SELECT name FROM monitor\");\n                    let monitorNameListString = JSON.stringify(monitorNameList);\n\n                    for (let i = 0; i < monitorListData.length; i++) {\n                        // Only starts importing the monitor if the import option is \"overwrite\", \"keep\" or \"skip\" but the notification doesn't exists\n                        if ((importHandle === \"skip\" && monitorNameListString.includes(monitorListData[i].name) === false) || importHandle === \"keep\" || importHandle === \"overwrite\") {\n\n                            // Define in here every new variable for monitors which where implemented after the first version of the Import/Export function (1.6.0)\n                            // --- Start ---\n\n                            // Define default values\n                            let retryInterval = 0;\n                            let timeout = monitorListData[i].timeout || (monitorListData[i].interval * 0.8); // fallback to old value\n\n                            /*\n                            Only replace the default value with the backup file data for the specific version, where it appears the first time\n                            More information about that where \"let version\" will be defined\n                            */\n                            if (version17x) {\n                                retryInterval = monitorListData[i].retryInterval;\n                            }\n\n                            // --- End ---\n\n                            let monitor = {\n                                // Define the new variable from earlier here\n                                name: monitorListData[i].name,\n                                description: monitorListData[i].description,\n                                type: monitorListData[i].type,\n                                url: monitorListData[i].url,\n                                method: monitorListData[i].method || \"GET\",\n                                body: monitorListData[i].body,\n                                headers: monitorListData[i].headers,\n                                authMethod: monitorListData[i].authMethod,\n                                basic_auth_user: monitorListData[i].basic_auth_user,\n                                basic_auth_pass: monitorListData[i].basic_auth_pass,\n                                authWorkstation: monitorListData[i].authWorkstation,\n                                authDomain: monitorListData[i].authDomain,\n                                timeout,\n                                interval: monitorListData[i].interval,\n                                retryInterval: retryInterval,\n                                resendInterval: monitorListData[i].resendInterval || 0,\n                                hostname: monitorListData[i].hostname,\n                                maxretries: monitorListData[i].maxretries,\n                                port: monitorListData[i].port,\n                                keyword: monitorListData[i].keyword,\n                                invertKeyword: monitorListData[i].invertKeyword,\n                                ignoreTls: monitorListData[i].ignoreTls,\n                                upsideDown: monitorListData[i].upsideDown,\n                                maxredirects: monitorListData[i].maxredirects,\n                                accepted_statuscodes: monitorListData[i].accepted_statuscodes,\n                                dns_resolve_type: monitorListData[i].dns_resolve_type,\n                                dns_resolve_server: monitorListData[i].dns_resolve_server,\n                                notificationIDList: monitorListData[i].notificationIDList,\n                                proxy_id: monitorListData[i].proxy_id || null,\n                            };\n\n                            if (monitorListData[i].pushToken) {\n                                monitor.pushToken = monitorListData[i].pushToken;\n                            }\n\n                            let bean = R.dispense(\"monitor\");\n\n                            let notificationIDList = monitor.notificationIDList;\n                            delete monitor.notificationIDList;\n\n                            monitor.accepted_statuscodes_json = JSON.stringify(monitor.accepted_statuscodes);\n                            delete monitor.accepted_statuscodes;\n\n                            bean.import(monitor);\n                            bean.user_id = socket.userID;\n                            await R.store(bean);\n\n                            // Only for backup files with the version 1.7.0 or higher, since there was the tag feature implemented\n                            if (version17x) {\n                                // Only import if the specific monitor has tags assigned\n                                for (const oldTag of monitorListData[i].tags) {\n\n                                    // Check if tag already exists and get data ->\n                                    let tag = await R.findOne(\"tag\", \" name = ?\", [\n                                        oldTag.name,\n                                    ]);\n\n                                    let tagId;\n                                    if (! tag) {\n                                        // -> If it doesn't exist, create new tag from backup file\n                                        let beanTag = R.dispense(\"tag\");\n                                        beanTag.name = oldTag.name;\n                                        beanTag.color = oldTag.color;\n                                        await R.store(beanTag);\n\n                                        tagId = beanTag.id;\n                                    } else {\n                                        // -> If it already exist, set tagId to value from database\n                                        tagId = tag.id;\n                                    }\n\n                                    // Assign the new created tag to the monitor\n                                    await R.exec(\"INSERT INTO monitor_tag (tag_id, monitor_id, value) VALUES (?, ?, ?)\", [\n                                        tagId,\n                                        bean.id,\n                                        oldTag.value,\n                                    ]);\n\n                                }\n                            }\n\n                            await updateMonitorNotification(bean.id, notificationIDList);\n\n                            // If monitor was active start it immediately, otherwise pause it\n                            if (monitorListData[i].active === 1) {\n                                await startMonitor(socket.userID, bean.id);\n                            } else {\n                                await pauseMonitor(socket.userID, bean.id);\n                            }\n\n                        }\n                    }\n\n                    await sendNotificationList(socket);\n                    await server.sendMonitorList(socket);\n                }\n\n                callback({\n                    ok: true,\n                    msg: \"Backup successfully restored.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"clearEvents\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"manage\", `Clear Events Monitor: ${monitorID} User ID: ${socket.userID}`);\n\n                await R.exec(\"UPDATE heartbeat SET msg = ?, important = ? WHERE monitor_id = ? \", [\n                    \"\",\n                    \"0\",\n                    monitorID,\n                ]);\n\n                await sendImportantHeartbeatList(socket, monitorID, true, true);\n\n                callback({\n                    ok: true,\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"clearHeartbeats\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"manage\", `Clear Heartbeats Monitor: ${monitorID} User ID: ${socket.userID}`);\n\n                await R.exec(\"DELETE FROM heartbeat WHERE monitor_id = ?\", [\n                    monitorID\n                ]);\n\n                await sendHeartbeatList(socket, monitorID, true, true);\n\n                callback({\n                    ok: true,\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"clearStatistics\", async (callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"manage\", `Clear Statistics User ID: ${socket.userID}`);\n\n                await R.exec(\"DELETE FROM heartbeat\");\n\n                callback({\n                    ok: true,\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        // Status Page Socket Handler for admin only\n        statusPageSocketHandler(socket);\n        cloudflaredSocketHandler(socket);\n        databaseSocketHandler(socket);\n        proxySocketHandler(socket);\n        dockerSocketHandler(socket);\n        maintenanceSocketHandler(socket);\n        apiKeySocketHandler(socket);\n        generalSocketHandler(socket, server);\n\n        log.debug(\"server\", \"added all socket handlers\");\n\n        // ***************************\n        // Better do anything after added all socket handlers here\n        // ***************************\n\n        log.debug(\"auth\", \"check auto login\");\n        if (await setting(\"disableAuth\")) {\n            log.info(\"auth\", \"Disabled Auth: auto login to admin\");\n            afterLogin(socket, await R.findOne(\"user\"));\n            socket.emit(\"autoLogin\");\n        } else {\n            log.debug(\"auth\", \"need auth\");\n        }\n\n    });\n\n    log.info(\"server\", \"Init the server\");\n\n    server.httpServer.once(\"error\", async (err) => {\n        console.error(\"Cannot listen: \" + err.message);\n        await shutdownFunction();\n    });\n\n    server.start();\n\n    server.httpServer.listen(port, hostname, () => {\n        if (hostname) {\n            log.info(\"server\", `Listening on ${hostname}:${port}`);\n        } else {\n            log.info(\"server\", `Listening on ${port}`);\n        }\n        startMonitors();\n        checkVersion.startInterval();\n\n        if (testMode) {\n            startUnitTest();\n        }\n\n        if (e2eTestMode) {\n            startE2eTests();\n        }\n    });\n\n    await initBackgroundJobs();\n\n    // Start cloudflared at the end if configured\n    await cloudflaredAutoStart(cloudflaredToken);\n\n})();\n\n/**\n * Update notifications for a given monitor\n * @param {number} monitorID ID of monitor to update\n * @param {number[]} notificationIDList List of new notification\n * providers to add\n * @returns {Promise<void>}\n */\nasync function updateMonitorNotification(monitorID, notificationIDList) {\n    await R.exec(\"DELETE FROM monitor_notification WHERE monitor_id = ? \", [\n        monitorID,\n    ]);\n\n    for (let notificationID in notificationIDList) {\n        if (notificationIDList[notificationID]) {\n            let relation = R.dispense(\"monitor_notification\");\n            relation.monitor_id = monitorID;\n            relation.notification_id = notificationID;\n            await R.store(relation);\n        }\n    }\n}\n\n/**\n * Check if a given user owns a specific monitor\n * @param {number} userID\n * @param {number} monitorID\n * @returns {Promise<void>}\n * @throws {Error} The specified user does not own the monitor\n */\nasync function checkOwner(userID, monitorID) {\n    let row = await R.getRow(\"SELECT id FROM monitor WHERE id = ? AND user_id = ? \", [\n        monitorID,\n        userID,\n    ]);\n\n    if (! row) {\n        throw new Error(\"You do not own this monitor.\");\n    }\n}\n\n/**\n * Function called after user login\n * This function is used to send the heartbeat list of a monitor.\n * @param {Socket} socket Socket.io instance\n * @param {Object} user User object\n * @returns {Promise<void>}\n */\nasync function afterLogin(socket, user) {\n    socket.userID = user.id;\n    socket.join(user.id);\n\n    let monitorList = await server.sendMonitorList(socket);\n    sendInfo(socket);\n    server.sendMaintenanceList(socket);\n    sendNotificationList(socket);\n    sendProxyList(socket);\n    sendDockerHostList(socket);\n    sendAPIKeyList(socket);\n\n    await sleep(500);\n\n    await StatusPage.sendStatusPageList(io, socket);\n\n    for (let monitorID in monitorList) {\n        await sendHeartbeatList(socket, monitorID);\n    }\n\n    for (let monitorID in monitorList) {\n        await sendImportantHeartbeatList(socket, monitorID);\n    }\n\n    for (let monitorID in monitorList) {\n        await Monitor.sendStats(io, monitorID, user.id);\n    }\n\n    // Set server timezone from client browser if not set\n    // It should be run once only\n    if (! await Settings.get(\"initServerTimezone\")) {\n        log.debug(\"server\", \"emit initServerTimezone\");\n        socket.emit(\"initServerTimezone\");\n    }\n}\n\n/**\n * Initialize the database\n * @param {boolean} [testMode=false] Should the connection be\n * started in test mode?\n * @returns {Promise<void>}\n */\nasync function initDatabase(testMode = false) {\n    if (! fs.existsSync(Database.path)) {\n        log.info(\"server\", \"Copying Database\");\n        fs.copyFileSync(Database.templatePath, Database.path);\n    }\n\n    log.info(\"server\", \"Connecting to the Database\");\n    await Database.connect(testMode);\n    log.info(\"server\", \"Connected\");\n\n    // Patch the database\n    await Database.patch();\n\n    let jwtSecretBean = await R.findOne(\"setting\", \" `key` = ? \", [\n        \"jwtSecret\",\n    ]);\n\n    if (! jwtSecretBean) {\n        log.info(\"server\", \"JWT secret is not found, generate one.\");\n        jwtSecretBean = await initJWTSecret();\n        log.info(\"server\", \"Stored JWT secret into database\");\n    } else {\n        log.info(\"server\", \"Load JWT secret from database.\");\n    }\n\n    // If there is no record in user table, it is a new Uptime Kuma instance, need to setup\n    if ((await R.count(\"user\")) === 0) {\n        log.info(\"server\", \"No user, need setup\");\n        needSetup = true;\n    }\n\n    server.jwtSecret = jwtSecretBean.value;\n}\n\n/**\n * Start the specified monitor\n * @param {number} userID ID of user who owns monitor\n * @param {number} monitorID ID of monitor to start\n * @returns {Promise<void>}\n */\nasync function startMonitor(userID, monitorID) {\n    await checkOwner(userID, monitorID);\n\n    log.info(\"manage\", `Resume Monitor: ${monitorID} User ID: ${userID}`);\n\n    await R.exec(\"UPDATE monitor SET active = 1 WHERE id = ? AND user_id = ? \", [\n        monitorID,\n        userID,\n    ]);\n\n    let monitor = await R.findOne(\"monitor\", \" id = ? \", [\n        monitorID,\n    ]);\n\n    if (monitor.id in server.monitorList) {\n        server.monitorList[monitor.id].stop();\n    }\n\n    server.monitorList[monitor.id] = monitor;\n    monitor.start(io);\n}\n\n/**\n * Restart a given monitor\n * @param {number} userID ID of user who owns monitor\n * @param {number} monitorID ID of monitor to start\n * @returns {Promise<void>}\n */\nasync function restartMonitor(userID, monitorID) {\n    return await startMonitor(userID, monitorID);\n}\n\n/**\n * Pause a given monitor\n * @param {number} userID ID of user who owns monitor\n * @param {number} monitorID ID of monitor to start\n * @returns {Promise<void>}\n */\nasync function pauseMonitor(userID, monitorID) {\n    await checkOwner(userID, monitorID);\n\n    log.info(\"manage\", `Pause Monitor: ${monitorID} User ID: ${userID}`);\n\n    await R.exec(\"UPDATE monitor SET active = 0 WHERE id = ? AND user_id = ? \", [\n        monitorID,\n        userID,\n    ]);\n\n    if (monitorID in server.monitorList) {\n        server.monitorList[monitorID].stop();\n        server.monitorList[monitorID].active = 0;\n    }\n}\n\n/** Resume active monitors */\nasync function startMonitors() {\n    let list = await R.find(\"monitor\", \" active = 1 \");\n\n    for (let monitor of list) {\n        server.monitorList[monitor.id] = monitor;\n    }\n\n    for (let monitor of list) {\n        monitor.start(io);\n        // Give some delays, so all monitors won't make request at the same moment when just start the server.\n        await sleep(getRandomInt(300, 1000));\n    }\n}\n\n/**\n * Shutdown the application\n * Stops all monitors and closes the database connection.\n * @param {string} signal The signal that triggered this function to be called.\n * @returns {Promise<void>}\n */\nasync function shutdownFunction(signal) {\n    log.info(\"server\", \"Shutdown requested\");\n    log.info(\"server\", \"Called signal: \" + signal);\n\n    await server.stop();\n\n    log.info(\"server\", \"Stopping all monitors\");\n    for (let id in server.monitorList) {\n        let monitor = server.monitorList[id];\n        monitor.stop();\n    }\n    await sleep(2000);\n    await Database.close();\n\n    stopBackgroundJobs();\n    await cloudflaredStop();\n    Settings.stopCacheCleaner();\n}\n\n/** Final function called before application exits */\nfunction finalFunction() {\n    log.info(\"server\", \"Graceful shutdown successful!\");\n}\n\ngracefulShutdown(server.httpServer, {\n    signals: \"SIGINT SIGTERM\",\n    timeout: 30000,                   // timeout: 30 secs\n    development: false,               // not in dev mode\n    forceExit: true,                  // triggers process.exit() at the end of shutdown process\n    onShutdown: shutdownFunction,     // shutdown function (async) - e.g. for cleanup DB, ...\n    finally: finalFunction,            // finally function (sync) - e.g. for logging\n});\n\n// Catch unexpected errors here\nlet unexpectedErrorHandler = (error, promise) => {\n    console.trace(error);\n    UptimeKumaServer.errorLog(error, false);\n    console.error(\"If you keep encountering errors, please report to https://github.com/louislam/uptime-kuma/issues\");\n};\nprocess.addListener(\"unhandledRejection\", unexpectedErrorHandler);\nprocess.addListener(\"uncaughtException\", unexpectedErrorHandler);\n", "const express = require(\"express\");\nconst https = require(\"https\");\nconst fs = require(\"fs\");\nconst http = require(\"http\");\nconst { Server } = require(\"socket.io\");\nconst { R } = require(\"redbean-node\");\nconst { log, isDev } = require(\"../src/util\");\nconst Database = require(\"./database\");\nconst util = require(\"util\");\nconst { CacheableDnsHttpAgent } = require(\"./cacheable-dns-http-agent\");\nconst { Settings } = require(\"./settings\");\nconst dayjs = require(\"dayjs\");\nconst childProcessAsync = require(\"promisify-child-process\");\nconst path = require(\"path\");\n// DO NOT IMPORT HERE IF THE MODULES USED `UptimeKumaServer.getInstance()`, put at the bottom of this file instead.\n\n/**\n * `module.exports` (alias: `server`) should be inside this class, in order to avoid circular dependency issue.\n * @type {UptimeKumaServer}\n */\nclass UptimeKumaServer {\n    /**\n     *\n     * @type {UptimeKumaServer}\n     */\n    static instance = null;\n\n    /**\n     * Main monitor list\n     * @type {{}}\n     */\n    monitorList = {};\n\n    /**\n     * Main maintenance list\n     * @type {{}}\n     */\n    maintenanceList = {};\n\n    entryPage = \"dashboard\";\n    app = undefined;\n    httpServer = undefined;\n    io = undefined;\n\n    /**\n     * Cache Index HTML\n     * @type {string}\n     */\n    indexHTML = \"\";\n\n    /**\n     *\n     * @type {{}}\n     */\n    static monitorTypeList = {\n\n    };\n\n    /**\n     * Use for decode the auth object\n     * @type {null}\n     */\n    jwtSecret = null;\n\n    static getInstance(args) {\n        if (UptimeKumaServer.instance == null) {\n            UptimeKumaServer.instance = new UptimeKumaServer(args);\n        }\n        return UptimeKumaServer.instance;\n    }\n\n    constructor(args) {\n        // SSL\n        const sslKey = args[\"ssl-key\"] || process.env.UPTIME_KUMA_SSL_KEY || process.env.SSL_KEY || undefined;\n        const sslCert = args[\"ssl-cert\"] || process.env.UPTIME_KUMA_SSL_CERT || process.env.SSL_CERT || undefined;\n        const sslKeyPassphrase = args[\"ssl-key-passphrase\"] || process.env.UPTIME_KUMA_SSL_KEY_PASSPHRASE || process.env.SSL_KEY_PASSPHRASE || undefined;\n\n        log.info(\"server\", \"Creating express and socket.io instance\");\n        this.app = express();\n        if (sslKey && sslCert) {\n            log.info(\"server\", \"Server Type: HTTPS\");\n            this.httpServer = https.createServer({\n                key: fs.readFileSync(sslKey),\n                cert: fs.readFileSync(sslCert),\n                passphrase: sslKeyPassphrase,\n            }, this.app);\n        } else {\n            log.info(\"server\", \"Server Type: HTTP\");\n            this.httpServer = http.createServer(this.app);\n        }\n\n        try {\n            this.indexHTML = fs.readFileSync(\"./dist/index.html\").toString();\n        } catch (e) {\n            // \"dist/index.html\" is not necessary for development\n            if (process.env.NODE_ENV !== \"development\") {\n                log.error(\"server\", \"Error: Cannot find 'dist/index.html', did you install correctly?\");\n                process.exit(1);\n            }\n        }\n\n        // Set Monitor Types\n        UptimeKumaServer.monitorTypeList[\"real-browser\"] = new RealBrowserMonitorType();\n        UptimeKumaServer.monitorTypeList[\"tailscale-ping\"] = new TailscalePing();\n\n        this.io = new Server(this.httpServer, {\n            allowRequest: (req, callback) => {\n                let isOriginValid = true;\n                const bypass = isDev || process.env.UPTIME_KUMA_WS_ORIGIN_CHECK === \"bypass\";\n\n                if (!bypass) {\n                    let host = req.headers.host;\n\n                    // If this is set, it means the request is from the browser\n                    let origin = req.headers.origin;\n\n                    // If this is from the browser, check if the origin is allowed\n                    if (origin) {\n                        try {\n                            let originURL = new URL(origin);\n\n                            if (host !== originURL.host) {\n                                isOriginValid = false;\n                                log.error(\"auth\", `Origin (${origin}) does not match host (${host}), IP: ${req.socket.remoteAddress}`);\n                            }\n                        } catch (e) {\n                            // Invalid origin url, probably not from browser\n                            isOriginValid = false;\n                            log.error(\"auth\", `Invalid origin url (${origin}), IP: ${req.socket.remoteAddress}`);\n                        }\n                    } else {\n                        log.info(\"auth\", `Origin is not set, IP: ${req.socket.remoteAddress}`);\n                    }\n                } else {\n                    log.debug(\"auth\", \"Origin check is bypassed\");\n                }\n\n                callback(null, isOriginValid);\n            }\n        });\n    }\n\n    /** Initialise app after the database has been set up */\n    async initAfterDatabaseReady() {\n        // Static\n        this.app.use(\"/screenshots\", express.static(Database.screenshotDir));\n\n        await CacheableDnsHttpAgent.update();\n\n        process.env.TZ = await this.getTimezone();\n        dayjs.tz.setDefault(process.env.TZ);\n        log.debug(\"DEBUG\", \"Timezone: \" + process.env.TZ);\n        log.debug(\"DEBUG\", \"Current Time: \" + dayjs.tz().format());\n\n        await this.loadMaintenanceList();\n    }\n\n    /**\n     * Send list of monitors to client\n     * @param {Socket} socket\n     * @returns {Object} List of monitors\n     */\n    async sendMonitorList(socket) {\n        let list = await this.getMonitorJSONList(socket.userID);\n        this.io.to(socket.userID).emit(\"monitorList\", list);\n        return list;\n    }\n\n    /**\n     * Get a list of monitors for the given user.\n     * @param {string} userID - The ID of the user to get monitors for.\n     * @returns {Promise<Object>} A promise that resolves to an object with monitor IDs as keys and monitor objects as values.\n     *\n     * Generated by Trelent\n     */\n    async getMonitorJSONList(userID) {\n        let result = {};\n\n        let monitorList = await R.find(\"monitor\", \" user_id = ? ORDER BY weight DESC, name\", [\n            userID,\n        ]);\n\n        for (let monitor of monitorList) {\n            result[monitor.id] = await monitor.toJSON();\n        }\n\n        return result;\n    }\n\n    /**\n     * Send maintenance list to client\n     * @param {Socket} socket Socket.io instance to send to\n     * @returns {Object}\n     */\n    async sendMaintenanceList(socket) {\n        return await this.sendMaintenanceListByUserID(socket.userID);\n    }\n\n    /**\n     * Send list of maintenances to user\n     * @param {number} userID\n     * @returns {Object}\n     */\n    async sendMaintenanceListByUserID(userID) {\n        let list = await this.getMaintenanceJSONList(userID);\n        this.io.to(userID).emit(\"maintenanceList\", list);\n        return list;\n    }\n\n    /**\n     * Get a list of maintenances for the given user.\n     * @param {string} userID - The ID of the user to get maintenances for.\n     * @returns {Promise<Object>} A promise that resolves to an object with maintenance IDs as keys and maintenances objects as values.\n     */\n    async getMaintenanceJSONList(userID) {\n        let result = {};\n        for (let maintenanceID in this.maintenanceList) {\n            result[maintenanceID] = await this.maintenanceList[maintenanceID].toJSON();\n        }\n        return result;\n    }\n\n    /**\n     * Load maintenance list and run\n     * @param userID\n     * @returns {Promise<void>}\n     */\n    async loadMaintenanceList(userID) {\n        let maintenanceList = await R.findAll(\"maintenance\", \" ORDER BY end_date DESC, title\", [\n\n        ]);\n\n        for (let maintenance of maintenanceList) {\n            this.maintenanceList[maintenance.id] = maintenance;\n            maintenance.run(this);\n        }\n    }\n\n    getMaintenance(maintenanceID) {\n        if (this.maintenanceList[maintenanceID]) {\n            return this.maintenanceList[maintenanceID];\n        }\n        return null;\n    }\n\n    /**\n     * Write error to log file\n     * @param {any} error The error to write\n     * @param {boolean} outputToConsole Should the error also be output to console?\n     */\n    static errorLog(error, outputToConsole = true) {\n        const errorLogStream = fs.createWriteStream(path.join(Database.dataDir, \"/error.log\"), {\n            flags: \"a\"\n        });\n\n        errorLogStream.on(\"error\", () => {\n            log.info(\"\", \"Cannot write to error.log\");\n        });\n\n        if (errorLogStream) {\n            const dateTime = R.isoDateTime();\n            errorLogStream.write(`[${dateTime}] ` + util.format(error) + \"\\n\");\n\n            if (outputToConsole) {\n                console.error(error);\n            }\n        }\n\n        errorLogStream.end();\n    }\n\n    /**\n     * Get the IP of the client connected to the socket\n     * @param {Socket} socket\n     * @returns {string}\n     */\n    async getClientIP(socket) {\n        let clientIP = socket.client.conn.remoteAddress;\n\n        if (clientIP === undefined) {\n            clientIP = \"\";\n        }\n\n        if (await Settings.get(\"trustProxy\")) {\n            const forwardedFor = socket.client.conn.request.headers[\"x-forwarded-for\"];\n\n            return (typeof forwardedFor === \"string\" ? forwardedFor.split(\",\")[0].trim() : null)\n                || socket.client.conn.request.headers[\"x-real-ip\"]\n                || clientIP.replace(/^::ffff:/, \"\");\n        } else {\n            return clientIP.replace(/^::ffff:/, \"\");\n        }\n    }\n\n    /**\n     * Attempt to get the current server timezone\n     * If this fails, fall back to environment variables and then make a\n     * guess.\n     * @returns {Promise<string>}\n     */\n    async getTimezone() {\n        // From process.env.TZ\n        try {\n            if (process.env.TZ) {\n                this.checkTimezone(process.env.TZ);\n                return process.env.TZ;\n            }\n        } catch (e) {\n            log.warn(\"timezone\", e.message + \" in process.env.TZ\");\n        }\n\n        let timezone = await Settings.get(\"serverTimezone\");\n\n        // From Settings\n        try {\n            log.debug(\"timezone\", \"Using timezone from settings: \" + timezone);\n            if (timezone) {\n                this.checkTimezone(timezone);\n                return timezone;\n            }\n        } catch (e) {\n            log.warn(\"timezone\", e.message + \" in settings\");\n        }\n\n        // Guess\n        try {\n            let guess = dayjs.tz.guess();\n            log.debug(\"timezone\", \"Guessing timezone: \" + guess);\n            if (guess) {\n                this.checkTimezone(guess);\n                return guess;\n            } else {\n                return \"UTC\";\n            }\n        } catch (e) {\n            // Guess failed, fall back to UTC\n            log.debug(\"timezone\", \"Guessed an invalid timezone. Use UTC as fallback\");\n            return \"UTC\";\n        }\n    }\n\n    /**\n     * Get the current offset\n     * @returns {string}\n     */\n    getTimezoneOffset() {\n        return dayjs().format(\"Z\");\n    }\n\n    /**\n     * Throw an error if the timezone is invalid\n     * @param timezone\n     */\n    checkTimezone(timezone) {\n        try {\n            dayjs.utc(\"2013-11-18 11:55\").tz(timezone).format();\n        } catch (e) {\n            throw new Error(\"Invalid timezone:\" + timezone);\n        }\n    }\n\n    /**\n     * Set the current server timezone and environment variables\n     * @param {string} timezone\n     */\n    async setTimezone(timezone) {\n        this.checkTimezone(timezone);\n        await Settings.set(\"serverTimezone\", timezone, \"general\");\n        process.env.TZ = timezone;\n        dayjs.tz.setDefault(timezone);\n    }\n\n    /**\n     * TODO: Listen logic should be moved to here\n     * @returns {Promise<void>}\n     */\n    async start() {\n        let enable = await Settings.get(\"nscd\");\n\n        if (enable || enable === null) {\n            await this.startNSCDServices();\n        }\n    }\n\n    /**\n     * Stop the server\n     * @returns {Promise<void>}\n     */\n    async stop() {\n        let enable = await Settings.get(\"nscd\");\n\n        if (enable || enable === null) {\n            await this.stopNSCDServices();\n        }\n    }\n\n    /**\n     * Start all system services (e.g. nscd)\n     * For now, only used in Docker\n     */\n    async startNSCDServices() {\n        if (process.env.UPTIME_KUMA_IS_CONTAINER) {\n            try {\n                log.info(\"services\", \"Starting nscd\");\n                await childProcessAsync.exec(\"sudo service nscd start\");\n            } catch (e) {\n                log.info(\"services\", \"Failed to start nscd\");\n            }\n        }\n    }\n\n    /**\n     * Stop all system services\n     */\n    async stopNSCDServices() {\n        if (process.env.UPTIME_KUMA_IS_CONTAINER) {\n            try {\n                log.info(\"services\", \"Stopping nscd\");\n                await childProcessAsync.exec(\"sudo service nscd stop\");\n            } catch (e) {\n                log.info(\"services\", \"Failed to stop nscd\");\n            }\n        }\n    }\n}\n\nmodule.exports = {\n    UptimeKumaServer\n};\n\n// Must be at the end to avoid circular dependencies\nconst { RealBrowserMonitorType } = require(\"./monitor-types/real-browser-monitor-type\");\nconst { TailscalePing } = require(\"./monitor-types/tailscale-ping\");\n"], "filenames": ["server/server.js", "server/uptime-kuma-server.js"], "buggy_code_start_loc": [50, 7], "buggy_code_end_loc": [52, 107], "fixing_code_start_loc": [51, 7], "fixing_code_end_loc": [58, 141], "type": "CWE-346", "message": "Uptime Kuma is an easy-to-use self-hosted monitoring tool. Prior to version 1.23.9, the application uses WebSocket (with Socket.io), but it does not verify that the source of communication is valid. This allows third-party website to access the application on behalf of their client. When connecting to the server using Socket.IO, the server does not validate the `Origin` header leading to other site being able to open connections to the server and communicate with it. Other websites still need to authenticate to access most features, however this can be used to circumvent firewall protections made in place by people deploying the application.\n\nWithout origin validation, Javascript executed from another origin would be allowed to connect to the application without any user interaction. Without login credentials, such a connection is unable to access protected endpoints containing sensitive data of the application. However, such a connection may allow attacker to further exploit unseen vulnerabilities of the application. Users with \"No-auth\" mode configured who are relying on a reverse proxy or firewall to provide protection to the application would be especially vulnerable as it would grant the attacker full access to the application.\n\nIn version 1.23.9, additional verification of the HTTP Origin header has been added to the socket.io connection handler. By default, if the `Origin` header is present, it would be checked against the Host header. Connection would be denied if the hostnames do not match, which would indicate that the request is cross-origin. Connection would be allowed if the `Origin` header is not present. Users can override this behavior by setting environment variable `UPTIME_KUMA_WS_ORIGIN_CHECK=bypass`.", "other": {"cve": {"id": "CVE-2023-49805", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-11T23:15:08.057", "lastModified": "2023-12-14T19:48:34.987", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Uptime Kuma is an easy-to-use self-hosted monitoring tool. Prior to version 1.23.9, the application uses WebSocket (with Socket.io), but it does not verify that the source of communication is valid. This allows third-party website to access the application on behalf of their client. When connecting to the server using Socket.IO, the server does not validate the `Origin` header leading to other site being able to open connections to the server and communicate with it. Other websites still need to authenticate to access most features, however this can be used to circumvent firewall protections made in place by people deploying the application.\n\nWithout origin validation, Javascript executed from another origin would be allowed to connect to the application without any user interaction. Without login credentials, such a connection is unable to access protected endpoints containing sensitive data of the application. However, such a connection may allow attacker to further exploit unseen vulnerabilities of the application. Users with \"No-auth\" mode configured who are relying on a reverse proxy or firewall to provide protection to the application would be especially vulnerable as it would grant the attacker full access to the application.\n\nIn version 1.23.9, additional verification of the HTTP Origin header has been added to the socket.io connection handler. By default, if the `Origin` header is present, it would be checked against the Host header. Connection would be denied if the hostnames do not match, which would indicate that the request is cross-origin. Connection would be allowed if the `Origin` header is not present. Users can override this behavior by setting environment variable `UPTIME_KUMA_WS_ORIGIN_CHECK=bypass`."}, {"lang": "es", "value": "Uptime Kuma es una herramienta de monitorizaci\u00f3n autohospedada y f\u00e1cil de usar. Antes de la versi\u00f3n 1.23.9, la aplicaci\u00f3n utiliza WebSocket (con Socket.io), pero no verifica que la fuente de comunicaci\u00f3n sea v\u00e1lida. Esto permite que el sitio web de terceros acceda a la aplicaci\u00f3n en nombre de su cliente. Al conectarse al servidor usando Socket.IO, el servidor no valida el encabezado \"Origin\", lo que hace que otro sitio pueda abrir conexiones al servidor y comunicarse con \u00e9l. Otros sitios web a\u00fan necesitan autenticarse para acceder a la mayor\u00eda de las funciones; sin embargo, esto se puede usar para eludir las protecciones de firewall implementadas por las personas que implementan la aplicaci\u00f3n. Sin la validaci\u00f3n del origen, el Javascript ejecutado desde otro origen podr\u00eda conectarse a la aplicaci\u00f3n sin ninguna interacci\u00f3n del usuario. Sin credenciales de inicio de sesi\u00f3n, dicha conexi\u00f3n no puede acceder a endpoints protegidos que contengan datos confidenciales de la aplicaci\u00f3n. Sin embargo, dicha conexi\u00f3n puede permitir al atacante explotar a\u00fan m\u00e1s vulnerabilidades invisibles de la aplicaci\u00f3n. Los usuarios con el modo \"Sin autenticaci\u00f3n\" configurado que dependen de un proxy inverso o un firewall para brindar protecci\u00f3n a la aplicaci\u00f3n ser\u00edan especialmente vulnerables ya que otorgar\u00edan al atacante acceso completo a la aplicaci\u00f3n. En la versi\u00f3n 1.23.9, se agreg\u00f3 verificaci\u00f3n adicional del encabezado de origen HTTP al controlador de conexi\u00f3n socket.io. De forma predeterminada, si el encabezado \"Origin\" est\u00e1 presente, se comparar\u00e1 con el encabezado Host. Se denegar\u00eda la conexi\u00f3n si los nombres de host no coinciden, lo que indicar\u00eda que la solicitud es de origen cruzado. Se permitir\u00e1 la conexi\u00f3n si el encabezado \"Origin\" no est\u00e1 presente. Los usuarios pueden anular este comportamiento configurando la variable de entorno `UPTIME_KUMA_WS_ORIGIN_CHECK=bypass`."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 4.7}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-346"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-1385"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dockge.kuma:dockge:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.3.3", "matchCriteriaId": "9AD32927-6407-4711-8521-81C662CD7041"}, {"vulnerable": true, "criteria": "cpe:2.3:a:uptime.kuma:uptime_kuma:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.23.9", "matchCriteriaId": "04F74E4F-6339-4155-BE6A-B10151B8E18D"}]}]}], "references": [{"url": "https://github.com/louislam/uptime-kuma/commit/2815cc73cfd9d8ced889e00e72899708220d184f", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/louislam/uptime-kuma/security/advisories/GHSA-mj22-23ff-2hrr", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/louislam/uptime-kuma/commit/2815cc73cfd9d8ced889e00e72899708220d184f"}}