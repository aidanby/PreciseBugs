{"buggy_code": ["/*\n *  arch/arm/kernel/sys_oabi-compat.c\n *\n *  Compatibility wrappers for syscalls that are used from\n *  old ABI user space binaries with an EABI kernel.\n *\n *  Author:\tNicolas Pitre\n *  Created:\tOct 7, 2005\n *  Copyright:\tMontaVista Software, Inc.\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License version 2 as\n *  published by the Free Software Foundation.\n */\n\n/*\n * The legacy ABI and the new ARM EABI have different rules making some\n * syscalls incompatible especially with structure arguments.\n * Most notably, Eabi says 64-bit members should be 64-bit aligned instead of\n * simply word aligned.  EABI also pads structures to the size of the largest\n * member it contains instead of the invariant 32-bit.\n *\n * The following syscalls are affected:\n *\n * sys_stat64:\n * sys_lstat64:\n * sys_fstat64:\n * sys_fstatat64:\n *\n *   struct stat64 has different sizes and some members are shifted\n *   Compatibility wrappers are needed for them and provided below.\n *\n * sys_fcntl64:\n *\n *   struct flock64 has different sizes and some members are shifted\n *   A compatibility wrapper is needed and provided below.\n *\n * sys_statfs64:\n * sys_fstatfs64:\n *\n *   struct statfs64 has extra padding with EABI growing its size from\n *   84 to 88.  This struct is now __attribute__((packed,aligned(4)))\n *   with a small assembly wrapper to force the sz argument to 84 if it is 88\n *   to avoid copying the extra padding over user space unexpecting it.\n *\n * sys_newuname:\n *\n *   struct new_utsname has no padding with EABI.  No problem there.\n *\n * sys_epoll_ctl:\n * sys_epoll_wait:\n *\n *   struct epoll_event has its second member shifted also affecting the\n *   structure size. Compatibility wrappers are needed and provided below.\n *\n * sys_ipc:\n * sys_semop:\n * sys_semtimedop:\n *\n *   struct sembuf loses its padding with EABI.  Since arrays of them are\n *   used they have to be copyed to remove the padding. Compatibility wrappers\n *   provided below.\n *\n * sys_bind:\n * sys_connect:\n * sys_sendmsg:\n * sys_sendto:\n * sys_socketcall:\n *\n *   struct sockaddr_un loses its padding with EABI.  Since the size of the\n *   structure is used as a validation test in unix_mkname(), we need to\n *   change the length argument to 110 whenever it is 112.  Compatibility\n *   wrappers provided below.\n */\n\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/fcntl.h>\n#include <linux/eventpoll.h>\n#include <linux/sem.h>\n#include <linux/socket.h>\n#include <linux/net.h>\n#include <linux/ipc.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\nstruct oldabi_stat64 {\n\tunsigned long long st_dev;\n\tunsigned int\t__pad1;\n\tunsigned long\t__st_ino;\n\tunsigned int\tst_mode;\n\tunsigned int\tst_nlink;\n\n\tunsigned long\tst_uid;\n\tunsigned long\tst_gid;\n\n\tunsigned long long st_rdev;\n\tunsigned int\t__pad2;\n\n\tlong long\tst_size;\n\tunsigned long\tst_blksize;\n\tunsigned long long st_blocks;\n\n\tunsigned long\tst_atime;\n\tunsigned long\tst_atime_nsec;\n\n\tunsigned long\tst_mtime;\n\tunsigned long\tst_mtime_nsec;\n\n\tunsigned long\tst_ctime;\n\tunsigned long\tst_ctime_nsec;\n\n\tunsigned long long st_ino;\n} __attribute__ ((packed,aligned(4)));\n\nstatic long cp_oldabi_stat64(struct kstat *stat,\n\t\t\t     struct oldabi_stat64 __user *statbuf)\n{\n\tstruct oldabi_stat64 tmp;\n\n\ttmp.st_dev = huge_encode_dev(stat->dev);\n\ttmp.__pad1 = 0;\n\ttmp.__st_ino = stat->ino;\n\ttmp.st_mode = stat->mode;\n\ttmp.st_nlink = stat->nlink;\n\ttmp.st_uid = stat->uid;\n\ttmp.st_gid = stat->gid;\n\ttmp.st_rdev = huge_encode_dev(stat->rdev);\n\ttmp.st_size = stat->size;\n\ttmp.st_blocks = stat->blocks;\n\ttmp.__pad2 = 0;\n\ttmp.st_blksize = stat->blksize;\n\ttmp.st_atime = stat->atime.tv_sec;\n\ttmp.st_atime_nsec = stat->atime.tv_nsec;\n\ttmp.st_mtime = stat->mtime.tv_sec;\n\ttmp.st_mtime_nsec = stat->mtime.tv_nsec;\n\ttmp.st_ctime = stat->ctime.tv_sec;\n\ttmp.st_ctime_nsec = stat->ctime.tv_nsec;\n\ttmp.st_ino = stat->ino;\n\treturn copy_to_user(statbuf,&tmp,sizeof(tmp)) ? -EFAULT : 0;\n}\n\nasmlinkage long sys_oabi_stat64(const char __user * filename,\n\t\t\t\tstruct oldabi_stat64 __user * statbuf)\n{\n\tstruct kstat stat;\n\tint error = vfs_stat(filename, &stat);\n\tif (!error)\n\t\terror = cp_oldabi_stat64(&stat, statbuf);\n\treturn error;\n}\n\nasmlinkage long sys_oabi_lstat64(const char __user * filename,\n\t\t\t\t struct oldabi_stat64 __user * statbuf)\n{\n\tstruct kstat stat;\n\tint error = vfs_lstat(filename, &stat);\n\tif (!error)\n\t\terror = cp_oldabi_stat64(&stat, statbuf);\n\treturn error;\n}\n\nasmlinkage long sys_oabi_fstat64(unsigned long fd,\n\t\t\t\t struct oldabi_stat64 __user * statbuf)\n{\n\tstruct kstat stat;\n\tint error = vfs_fstat(fd, &stat);\n\tif (!error)\n\t\terror = cp_oldabi_stat64(&stat, statbuf);\n\treturn error;\n}\n\nasmlinkage long sys_oabi_fstatat64(int dfd,\n\t\t\t\t   const char __user *filename,\n\t\t\t\t   struct oldabi_stat64  __user *statbuf,\n\t\t\t\t   int flag)\n{\n\tstruct kstat stat;\n\tint error;\n\n\terror = vfs_fstatat(dfd, filename, &stat, flag);\n\tif (error)\n\t\treturn error;\n\treturn cp_oldabi_stat64(&stat, statbuf);\n}\n\nstruct oabi_flock64 {\n\tshort\tl_type;\n\tshort\tl_whence;\n\tloff_t\tl_start;\n\tloff_t\tl_len;\n\tpid_t\tl_pid;\n} __attribute__ ((packed,aligned(4)));\n\nasmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct oabi_flock64 user;\n\tstruct flock64 kernel;\n\tmm_segment_t fs = USER_DS; /* initialized to kill a warning */\n\tunsigned long local_arg = arg;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase F_GETLK64:\n\tcase F_SETLK64:\n\tcase F_SETLKW64:\n\t\tif (copy_from_user(&user, (struct oabi_flock64 __user *)arg,\n\t\t\t\t   sizeof(user)))\n\t\t\treturn -EFAULT;\n\t\tkernel.l_type\t= user.l_type;\n\t\tkernel.l_whence\t= user.l_whence;\n\t\tkernel.l_start\t= user.l_start;\n\t\tkernel.l_len\t= user.l_len;\n\t\tkernel.l_pid\t= user.l_pid;\n\t\tlocal_arg = (unsigned long)&kernel;\n\t\tfs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t}\n\n\tret = sys_fcntl64(fd, cmd, local_arg);\n\n\tswitch (cmd) {\n\tcase F_GETLK64:\n\t\tif (!ret) {\n\t\t\tuser.l_type\t= kernel.l_type;\n\t\t\tuser.l_whence\t= kernel.l_whence;\n\t\t\tuser.l_start\t= kernel.l_start;\n\t\t\tuser.l_len\t= kernel.l_len;\n\t\t\tuser.l_pid\t= kernel.l_pid;\n\t\t\tif (copy_to_user((struct oabi_flock64 __user *)arg,\n\t\t\t\t\t &user, sizeof(user)))\n\t\t\t\tret = -EFAULT;\n\t\t}\n\tcase F_SETLK64:\n\tcase F_SETLKW64:\n\t\tset_fs(fs);\n\t}\n\n\treturn ret;\n}\n\nstruct oabi_epoll_event {\n\t__u32 events;\n\t__u64 data;\n} __attribute__ ((packed,aligned(4)));\n\nasmlinkage long sys_oabi_epoll_ctl(int epfd, int op, int fd,\n\t\t\t\t   struct oabi_epoll_event __user *event)\n{\n\tstruct oabi_epoll_event user;\n\tstruct epoll_event kernel;\n\tmm_segment_t fs;\n\tlong ret;\n\n\tif (op == EPOLL_CTL_DEL)\n\t\treturn sys_epoll_ctl(epfd, op, fd, NULL);\n\tif (copy_from_user(&user, event, sizeof(user)))\n\t\treturn -EFAULT;\n\tkernel.events = user.events;\n\tkernel.data   = user.data;\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\tret = sys_epoll_ctl(epfd, op, fd, &kernel);\n\tset_fs(fs);\n\treturn ret;\n}\n\nasmlinkage long sys_oabi_epoll_wait(int epfd,\n\t\t\t\t    struct oabi_epoll_event __user *events,\n\t\t\t\t    int maxevents, int timeout)\n{\n\tstruct epoll_event *kbuf;\n\tmm_segment_t fs;\n\tlong ret, err, i;\n\n\tif (maxevents <= 0 || maxevents > (INT_MAX/sizeof(struct epoll_event)))\n\t\treturn -EINVAL;\n\tkbuf = kmalloc(sizeof(*kbuf) * maxevents, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\tret = sys_epoll_wait(epfd, kbuf, maxevents, timeout);\n\tset_fs(fs);\n\terr = 0;\n\tfor (i = 0; i < ret; i++) {\n\t\t__put_user_error(kbuf[i].events, &events->events, err);\n\t\t__put_user_error(kbuf[i].data,   &events->data,   err);\n\t\tevents++;\n\t}\n\tkfree(kbuf);\n\treturn err ? -EFAULT : ret;\n}\n\nstruct oabi_sembuf {\n\tunsigned short\tsem_num;\n\tshort\t\tsem_op;\n\tshort\t\tsem_flg;\n\tunsigned short\t__pad;\n};\n\nasmlinkage long sys_oabi_semtimedop(int semid,\n\t\t\t\t    struct oabi_sembuf __user *tsops,\n\t\t\t\t    unsigned nsops,\n\t\t\t\t    const struct timespec __user *timeout)\n{\n\tstruct sembuf *sops;\n\tstruct timespec local_timeout;\n\tlong err;\n\tint i;\n\n\tif (nsops < 1)\n\t\treturn -EINVAL;\n\tsops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);\n\tif (!sops)\n\t\treturn -ENOMEM;\n\terr = 0;\n\tfor (i = 0; i < nsops; i++) {\n\t\t__get_user_error(sops[i].sem_num, &tsops->sem_num, err);\n\t\t__get_user_error(sops[i].sem_op,  &tsops->sem_op,  err);\n\t\t__get_user_error(sops[i].sem_flg, &tsops->sem_flg, err);\n\t\ttsops++;\n\t}\n\tif (timeout) {\n\t\t/* copy this as well before changing domain protection */\n\t\terr |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));\n\t\ttimeout = &local_timeout;\n\t}\n\tif (err) {\n\t\terr = -EFAULT;\n\t} else {\n\t\tmm_segment_t fs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t\terr = sys_semtimedop(semid, sops, nsops, timeout);\n\t\tset_fs(fs);\n\t}\n\tkfree(sops);\n\treturn err;\n}\n\nasmlinkage long sys_oabi_semop(int semid, struct oabi_sembuf __user *tsops,\n\t\t\t       unsigned nsops)\n{\n\treturn sys_oabi_semtimedop(semid, tsops, nsops, NULL);\n}\n\nasmlinkage int sys_oabi_ipc(uint call, int first, int second, int third,\n\t\t\t    void __user *ptr, long fifth)\n{\n\tswitch (call & 0xffff) {\n\tcase SEMOP:\n\t\treturn  sys_oabi_semtimedop(first,\n\t\t\t\t\t    (struct oabi_sembuf __user *)ptr,\n\t\t\t\t\t    second, NULL);\n\tcase SEMTIMEDOP:\n\t\treturn  sys_oabi_semtimedop(first,\n\t\t\t\t\t    (struct oabi_sembuf __user *)ptr,\n\t\t\t\t\t    second,\n\t\t\t\t\t    (const struct timespec __user *)fifth);\n\tdefault:\n\t\treturn sys_ipc(call, first, second, third, ptr, fifth);\n\t}\n}\n\nasmlinkage long sys_oabi_bind(int fd, struct sockaddr __user *addr, int addrlen)\n{\n\tsa_family_t sa_family;\n\tif (addrlen == 112 &&\n\t    get_user(sa_family, &addr->sa_family) == 0 &&\n\t    sa_family == AF_UNIX)\n\t\t\taddrlen = 110;\n\treturn sys_bind(fd, addr, addrlen);\n}\n\nasmlinkage long sys_oabi_connect(int fd, struct sockaddr __user *addr, int addrlen)\n{\n\tsa_family_t sa_family;\n\tif (addrlen == 112 &&\n\t    get_user(sa_family, &addr->sa_family) == 0 &&\n\t    sa_family == AF_UNIX)\n\t\t\taddrlen = 110;\n\treturn sys_connect(fd, addr, addrlen);\n}\n\nasmlinkage long sys_oabi_sendto(int fd, void __user *buff,\n\t\t\t\tsize_t len, unsigned flags,\n\t\t\t\tstruct sockaddr __user *addr,\n\t\t\t\tint addrlen)\n{\n\tsa_family_t sa_family;\n\tif (addrlen == 112 &&\n\t    get_user(sa_family, &addr->sa_family) == 0 &&\n\t    sa_family == AF_UNIX)\n\t\t\taddrlen = 110;\n\treturn sys_sendto(fd, buff, len, flags, addr, addrlen);\n}\n\nasmlinkage long sys_oabi_sendmsg(int fd, struct msghdr __user *msg, unsigned flags)\n{\n\tstruct sockaddr __user *addr;\n\tint msg_namelen;\n\tsa_family_t sa_family;\n\tif (msg &&\n\t    get_user(msg_namelen, &msg->msg_namelen) == 0 &&\n\t    msg_namelen == 112 &&\n\t    get_user(addr, &msg->msg_name) == 0 &&\n\t    get_user(sa_family, &addr->sa_family) == 0 &&\n\t    sa_family == AF_UNIX)\n\t{\n\t\t/*\n\t\t * HACK ALERT: there is a limit to how much backward bending\n\t\t * we should do for what is actually a transitional\n\t\t * compatibility layer.  This already has known flaws with\n\t\t * a few ioctls that we don't intend to fix.  Therefore\n\t\t * consider this blatent hack as another one... and take care\n\t\t * to run for cover.  In most cases it will \"just work fine\".\n\t\t * If it doesn't, well, tough.\n\t\t */\n\t\tput_user(110, &msg->msg_namelen);\n\t}\n\treturn sys_sendmsg(fd, msg, flags);\n}\n\nasmlinkage long sys_oabi_socketcall(int call, unsigned long __user *args)\n{\n\tunsigned long r = -EFAULT, a[6];\n\n\tswitch (call) {\n\tcase SYS_BIND:\n\t\tif (copy_from_user(a, args, 3 * sizeof(long)) == 0)\n\t\t\tr = sys_oabi_bind(a[0], (struct sockaddr __user *)a[1], a[2]);\n\t\tbreak;\n\tcase SYS_CONNECT:\n\t\tif (copy_from_user(a, args, 3 * sizeof(long)) == 0)\n\t\t\tr = sys_oabi_connect(a[0], (struct sockaddr __user *)a[1], a[2]);\n\t\tbreak;\n\tcase SYS_SENDTO:\n\t\tif (copy_from_user(a, args, 6 * sizeof(long)) == 0)\n\t\t\tr = sys_oabi_sendto(a[0], (void __user *)a[1], a[2], a[3],\n\t\t\t\t\t    (struct sockaddr __user *)a[4], a[5]);\n\t\tbreak;\n\tcase SYS_SENDMSG:\n\t\tif (copy_from_user(a, args, 3 * sizeof(long)) == 0)\n\t\t\tr = sys_oabi_sendmsg(a[0], (struct msghdr __user *)a[1], a[2]);\n\t\tbreak;\n\tdefault:\n\t\tr = sys_socketcall(call, args);\n\t}\n\n\treturn r;\n}\n"], "fixing_code": ["/*\n *  arch/arm/kernel/sys_oabi-compat.c\n *\n *  Compatibility wrappers for syscalls that are used from\n *  old ABI user space binaries with an EABI kernel.\n *\n *  Author:\tNicolas Pitre\n *  Created:\tOct 7, 2005\n *  Copyright:\tMontaVista Software, Inc.\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License version 2 as\n *  published by the Free Software Foundation.\n */\n\n/*\n * The legacy ABI and the new ARM EABI have different rules making some\n * syscalls incompatible especially with structure arguments.\n * Most notably, Eabi says 64-bit members should be 64-bit aligned instead of\n * simply word aligned.  EABI also pads structures to the size of the largest\n * member it contains instead of the invariant 32-bit.\n *\n * The following syscalls are affected:\n *\n * sys_stat64:\n * sys_lstat64:\n * sys_fstat64:\n * sys_fstatat64:\n *\n *   struct stat64 has different sizes and some members are shifted\n *   Compatibility wrappers are needed for them and provided below.\n *\n * sys_fcntl64:\n *\n *   struct flock64 has different sizes and some members are shifted\n *   A compatibility wrapper is needed and provided below.\n *\n * sys_statfs64:\n * sys_fstatfs64:\n *\n *   struct statfs64 has extra padding with EABI growing its size from\n *   84 to 88.  This struct is now __attribute__((packed,aligned(4)))\n *   with a small assembly wrapper to force the sz argument to 84 if it is 88\n *   to avoid copying the extra padding over user space unexpecting it.\n *\n * sys_newuname:\n *\n *   struct new_utsname has no padding with EABI.  No problem there.\n *\n * sys_epoll_ctl:\n * sys_epoll_wait:\n *\n *   struct epoll_event has its second member shifted also affecting the\n *   structure size. Compatibility wrappers are needed and provided below.\n *\n * sys_ipc:\n * sys_semop:\n * sys_semtimedop:\n *\n *   struct sembuf loses its padding with EABI.  Since arrays of them are\n *   used they have to be copyed to remove the padding. Compatibility wrappers\n *   provided below.\n *\n * sys_bind:\n * sys_connect:\n * sys_sendmsg:\n * sys_sendto:\n * sys_socketcall:\n *\n *   struct sockaddr_un loses its padding with EABI.  Since the size of the\n *   structure is used as a validation test in unix_mkname(), we need to\n *   change the length argument to 110 whenever it is 112.  Compatibility\n *   wrappers provided below.\n */\n\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/fcntl.h>\n#include <linux/eventpoll.h>\n#include <linux/sem.h>\n#include <linux/socket.h>\n#include <linux/net.h>\n#include <linux/ipc.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\nstruct oldabi_stat64 {\n\tunsigned long long st_dev;\n\tunsigned int\t__pad1;\n\tunsigned long\t__st_ino;\n\tunsigned int\tst_mode;\n\tunsigned int\tst_nlink;\n\n\tunsigned long\tst_uid;\n\tunsigned long\tst_gid;\n\n\tunsigned long long st_rdev;\n\tunsigned int\t__pad2;\n\n\tlong long\tst_size;\n\tunsigned long\tst_blksize;\n\tunsigned long long st_blocks;\n\n\tunsigned long\tst_atime;\n\tunsigned long\tst_atime_nsec;\n\n\tunsigned long\tst_mtime;\n\tunsigned long\tst_mtime_nsec;\n\n\tunsigned long\tst_ctime;\n\tunsigned long\tst_ctime_nsec;\n\n\tunsigned long long st_ino;\n} __attribute__ ((packed,aligned(4)));\n\nstatic long cp_oldabi_stat64(struct kstat *stat,\n\t\t\t     struct oldabi_stat64 __user *statbuf)\n{\n\tstruct oldabi_stat64 tmp;\n\n\ttmp.st_dev = huge_encode_dev(stat->dev);\n\ttmp.__pad1 = 0;\n\ttmp.__st_ino = stat->ino;\n\ttmp.st_mode = stat->mode;\n\ttmp.st_nlink = stat->nlink;\n\ttmp.st_uid = stat->uid;\n\ttmp.st_gid = stat->gid;\n\ttmp.st_rdev = huge_encode_dev(stat->rdev);\n\ttmp.st_size = stat->size;\n\ttmp.st_blocks = stat->blocks;\n\ttmp.__pad2 = 0;\n\ttmp.st_blksize = stat->blksize;\n\ttmp.st_atime = stat->atime.tv_sec;\n\ttmp.st_atime_nsec = stat->atime.tv_nsec;\n\ttmp.st_mtime = stat->mtime.tv_sec;\n\ttmp.st_mtime_nsec = stat->mtime.tv_nsec;\n\ttmp.st_ctime = stat->ctime.tv_sec;\n\ttmp.st_ctime_nsec = stat->ctime.tv_nsec;\n\ttmp.st_ino = stat->ino;\n\treturn copy_to_user(statbuf,&tmp,sizeof(tmp)) ? -EFAULT : 0;\n}\n\nasmlinkage long sys_oabi_stat64(const char __user * filename,\n\t\t\t\tstruct oldabi_stat64 __user * statbuf)\n{\n\tstruct kstat stat;\n\tint error = vfs_stat(filename, &stat);\n\tif (!error)\n\t\terror = cp_oldabi_stat64(&stat, statbuf);\n\treturn error;\n}\n\nasmlinkage long sys_oabi_lstat64(const char __user * filename,\n\t\t\t\t struct oldabi_stat64 __user * statbuf)\n{\n\tstruct kstat stat;\n\tint error = vfs_lstat(filename, &stat);\n\tif (!error)\n\t\terror = cp_oldabi_stat64(&stat, statbuf);\n\treturn error;\n}\n\nasmlinkage long sys_oabi_fstat64(unsigned long fd,\n\t\t\t\t struct oldabi_stat64 __user * statbuf)\n{\n\tstruct kstat stat;\n\tint error = vfs_fstat(fd, &stat);\n\tif (!error)\n\t\terror = cp_oldabi_stat64(&stat, statbuf);\n\treturn error;\n}\n\nasmlinkage long sys_oabi_fstatat64(int dfd,\n\t\t\t\t   const char __user *filename,\n\t\t\t\t   struct oldabi_stat64  __user *statbuf,\n\t\t\t\t   int flag)\n{\n\tstruct kstat stat;\n\tint error;\n\n\terror = vfs_fstatat(dfd, filename, &stat, flag);\n\tif (error)\n\t\treturn error;\n\treturn cp_oldabi_stat64(&stat, statbuf);\n}\n\nstruct oabi_flock64 {\n\tshort\tl_type;\n\tshort\tl_whence;\n\tloff_t\tl_start;\n\tloff_t\tl_len;\n\tpid_t\tl_pid;\n} __attribute__ ((packed,aligned(4)));\n\nasmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct oabi_flock64 user;\n\tstruct flock64 kernel;\n\tmm_segment_t fs = USER_DS; /* initialized to kill a warning */\n\tunsigned long local_arg = arg;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase F_GETLK64:\n\tcase F_SETLK64:\n\tcase F_SETLKW64:\n\t\tif (copy_from_user(&user, (struct oabi_flock64 __user *)arg,\n\t\t\t\t   sizeof(user)))\n\t\t\treturn -EFAULT;\n\t\tkernel.l_type\t= user.l_type;\n\t\tkernel.l_whence\t= user.l_whence;\n\t\tkernel.l_start\t= user.l_start;\n\t\tkernel.l_len\t= user.l_len;\n\t\tkernel.l_pid\t= user.l_pid;\n\t\tlocal_arg = (unsigned long)&kernel;\n\t\tfs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t}\n\n\tret = sys_fcntl64(fd, cmd, local_arg);\n\n\tswitch (cmd) {\n\tcase F_GETLK64:\n\t\tif (!ret) {\n\t\t\tuser.l_type\t= kernel.l_type;\n\t\t\tuser.l_whence\t= kernel.l_whence;\n\t\t\tuser.l_start\t= kernel.l_start;\n\t\t\tuser.l_len\t= kernel.l_len;\n\t\t\tuser.l_pid\t= kernel.l_pid;\n\t\t\tif (copy_to_user((struct oabi_flock64 __user *)arg,\n\t\t\t\t\t &user, sizeof(user)))\n\t\t\t\tret = -EFAULT;\n\t\t}\n\tcase F_SETLK64:\n\tcase F_SETLKW64:\n\t\tset_fs(fs);\n\t}\n\n\treturn ret;\n}\n\nstruct oabi_epoll_event {\n\t__u32 events;\n\t__u64 data;\n} __attribute__ ((packed,aligned(4)));\n\nasmlinkage long sys_oabi_epoll_ctl(int epfd, int op, int fd,\n\t\t\t\t   struct oabi_epoll_event __user *event)\n{\n\tstruct oabi_epoll_event user;\n\tstruct epoll_event kernel;\n\tmm_segment_t fs;\n\tlong ret;\n\n\tif (op == EPOLL_CTL_DEL)\n\t\treturn sys_epoll_ctl(epfd, op, fd, NULL);\n\tif (copy_from_user(&user, event, sizeof(user)))\n\t\treturn -EFAULT;\n\tkernel.events = user.events;\n\tkernel.data   = user.data;\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\tret = sys_epoll_ctl(epfd, op, fd, &kernel);\n\tset_fs(fs);\n\treturn ret;\n}\n\nasmlinkage long sys_oabi_epoll_wait(int epfd,\n\t\t\t\t    struct oabi_epoll_event __user *events,\n\t\t\t\t    int maxevents, int timeout)\n{\n\tstruct epoll_event *kbuf;\n\tmm_segment_t fs;\n\tlong ret, err, i;\n\n\tif (maxevents <= 0 || maxevents > (INT_MAX/sizeof(struct epoll_event)))\n\t\treturn -EINVAL;\n\tkbuf = kmalloc(sizeof(*kbuf) * maxevents, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\tret = sys_epoll_wait(epfd, kbuf, maxevents, timeout);\n\tset_fs(fs);\n\terr = 0;\n\tfor (i = 0; i < ret; i++) {\n\t\t__put_user_error(kbuf[i].events, &events->events, err);\n\t\t__put_user_error(kbuf[i].data,   &events->data,   err);\n\t\tevents++;\n\t}\n\tkfree(kbuf);\n\treturn err ? -EFAULT : ret;\n}\n\nstruct oabi_sembuf {\n\tunsigned short\tsem_num;\n\tshort\t\tsem_op;\n\tshort\t\tsem_flg;\n\tunsigned short\t__pad;\n};\n\nasmlinkage long sys_oabi_semtimedop(int semid,\n\t\t\t\t    struct oabi_sembuf __user *tsops,\n\t\t\t\t    unsigned nsops,\n\t\t\t\t    const struct timespec __user *timeout)\n{\n\tstruct sembuf *sops;\n\tstruct timespec local_timeout;\n\tlong err;\n\tint i;\n\n\tif (nsops < 1 || nsops > SEMOPM)\n\t\treturn -EINVAL;\n\tsops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);\n\tif (!sops)\n\t\treturn -ENOMEM;\n\terr = 0;\n\tfor (i = 0; i < nsops; i++) {\n\t\t__get_user_error(sops[i].sem_num, &tsops->sem_num, err);\n\t\t__get_user_error(sops[i].sem_op,  &tsops->sem_op,  err);\n\t\t__get_user_error(sops[i].sem_flg, &tsops->sem_flg, err);\n\t\ttsops++;\n\t}\n\tif (timeout) {\n\t\t/* copy this as well before changing domain protection */\n\t\terr |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));\n\t\ttimeout = &local_timeout;\n\t}\n\tif (err) {\n\t\terr = -EFAULT;\n\t} else {\n\t\tmm_segment_t fs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t\terr = sys_semtimedop(semid, sops, nsops, timeout);\n\t\tset_fs(fs);\n\t}\n\tkfree(sops);\n\treturn err;\n}\n\nasmlinkage long sys_oabi_semop(int semid, struct oabi_sembuf __user *tsops,\n\t\t\t       unsigned nsops)\n{\n\treturn sys_oabi_semtimedop(semid, tsops, nsops, NULL);\n}\n\nasmlinkage int sys_oabi_ipc(uint call, int first, int second, int third,\n\t\t\t    void __user *ptr, long fifth)\n{\n\tswitch (call & 0xffff) {\n\tcase SEMOP:\n\t\treturn  sys_oabi_semtimedop(first,\n\t\t\t\t\t    (struct oabi_sembuf __user *)ptr,\n\t\t\t\t\t    second, NULL);\n\tcase SEMTIMEDOP:\n\t\treturn  sys_oabi_semtimedop(first,\n\t\t\t\t\t    (struct oabi_sembuf __user *)ptr,\n\t\t\t\t\t    second,\n\t\t\t\t\t    (const struct timespec __user *)fifth);\n\tdefault:\n\t\treturn sys_ipc(call, first, second, third, ptr, fifth);\n\t}\n}\n\nasmlinkage long sys_oabi_bind(int fd, struct sockaddr __user *addr, int addrlen)\n{\n\tsa_family_t sa_family;\n\tif (addrlen == 112 &&\n\t    get_user(sa_family, &addr->sa_family) == 0 &&\n\t    sa_family == AF_UNIX)\n\t\t\taddrlen = 110;\n\treturn sys_bind(fd, addr, addrlen);\n}\n\nasmlinkage long sys_oabi_connect(int fd, struct sockaddr __user *addr, int addrlen)\n{\n\tsa_family_t sa_family;\n\tif (addrlen == 112 &&\n\t    get_user(sa_family, &addr->sa_family) == 0 &&\n\t    sa_family == AF_UNIX)\n\t\t\taddrlen = 110;\n\treturn sys_connect(fd, addr, addrlen);\n}\n\nasmlinkage long sys_oabi_sendto(int fd, void __user *buff,\n\t\t\t\tsize_t len, unsigned flags,\n\t\t\t\tstruct sockaddr __user *addr,\n\t\t\t\tint addrlen)\n{\n\tsa_family_t sa_family;\n\tif (addrlen == 112 &&\n\t    get_user(sa_family, &addr->sa_family) == 0 &&\n\t    sa_family == AF_UNIX)\n\t\t\taddrlen = 110;\n\treturn sys_sendto(fd, buff, len, flags, addr, addrlen);\n}\n\nasmlinkage long sys_oabi_sendmsg(int fd, struct msghdr __user *msg, unsigned flags)\n{\n\tstruct sockaddr __user *addr;\n\tint msg_namelen;\n\tsa_family_t sa_family;\n\tif (msg &&\n\t    get_user(msg_namelen, &msg->msg_namelen) == 0 &&\n\t    msg_namelen == 112 &&\n\t    get_user(addr, &msg->msg_name) == 0 &&\n\t    get_user(sa_family, &addr->sa_family) == 0 &&\n\t    sa_family == AF_UNIX)\n\t{\n\t\t/*\n\t\t * HACK ALERT: there is a limit to how much backward bending\n\t\t * we should do for what is actually a transitional\n\t\t * compatibility layer.  This already has known flaws with\n\t\t * a few ioctls that we don't intend to fix.  Therefore\n\t\t * consider this blatent hack as another one... and take care\n\t\t * to run for cover.  In most cases it will \"just work fine\".\n\t\t * If it doesn't, well, tough.\n\t\t */\n\t\tput_user(110, &msg->msg_namelen);\n\t}\n\treturn sys_sendmsg(fd, msg, flags);\n}\n\nasmlinkage long sys_oabi_socketcall(int call, unsigned long __user *args)\n{\n\tunsigned long r = -EFAULT, a[6];\n\n\tswitch (call) {\n\tcase SYS_BIND:\n\t\tif (copy_from_user(a, args, 3 * sizeof(long)) == 0)\n\t\t\tr = sys_oabi_bind(a[0], (struct sockaddr __user *)a[1], a[2]);\n\t\tbreak;\n\tcase SYS_CONNECT:\n\t\tif (copy_from_user(a, args, 3 * sizeof(long)) == 0)\n\t\t\tr = sys_oabi_connect(a[0], (struct sockaddr __user *)a[1], a[2]);\n\t\tbreak;\n\tcase SYS_SENDTO:\n\t\tif (copy_from_user(a, args, 6 * sizeof(long)) == 0)\n\t\t\tr = sys_oabi_sendto(a[0], (void __user *)a[1], a[2], a[3],\n\t\t\t\t\t    (struct sockaddr __user *)a[4], a[5]);\n\t\tbreak;\n\tcase SYS_SENDMSG:\n\t\tif (copy_from_user(a, args, 3 * sizeof(long)) == 0)\n\t\t\tr = sys_oabi_sendmsg(a[0], (struct msghdr __user *)a[1], a[2]);\n\t\tbreak;\n\tdefault:\n\t\tr = sys_socketcall(call, args);\n\t}\n\n\treturn r;\n}\n"], "filenames": ["arch/arm/kernel/sys_oabi-compat.c"], "buggy_code_start_loc": [314], "buggy_code_end_loc": [315], "fixing_code_start_loc": [314], "fixing_code_end_loc": [315], "type": "CWE-189", "message": "Integer overflow in the sys_oabi_semtimedop function in arch/arm/kernel/sys_oabi-compat.c in the Linux kernel before 2.6.39 on the ARM platform, when CONFIG_OABI_COMPAT is enabled, allows local users to gain privileges or cause a denial of service (heap memory corruption) by providing a crafted argument and leveraging a race condition.", "other": {"cve": {"id": "CVE-2011-1759", "sourceIdentifier": "secalert@redhat.com", "published": "2012-06-13T10:24:53.997", "lastModified": "2023-02-13T04:30:50.177", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Integer overflow in the sys_oabi_semtimedop function in arch/arm/kernel/sys_oabi-compat.c in the Linux kernel before 2.6.39 on the ARM platform, when CONFIG_OABI_COMPAT is enabled, allows local users to gain privileges or cause a denial of service (heap memory corruption) by providing a crafted argument and leveraging a race condition."}, {"lang": "es", "value": "Desbordamiento de entero en la funci\u00f3n sys_oabi_semtimedop en arch/arm/kernel/sys_oabi-compat.c en el Kernel de Linux anterior a v2.6.39 en la plataforma ARM, cuando CONFIG_OABI_COMPAT es habilitada, permite a usuarios locales obtener privilegios o causar una denegaci\u00f3n de servicio (da\u00f1os en la pila de memoria) mediante la utilizaci\u00f3n de un argumento manipulado y una condici\u00f3n condici\u00f3n de carrera."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:H/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 1.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-189"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.6.38.8", "matchCriteriaId": "57A0A2B0-3B9F-40C2-8C7A-CD9590B51315"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:*:*:*:*:*:*:*", "matchCriteriaId": "7462DB6D-E0A6-4DBB-8E21-66B875184FFC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc1:*:*:*:*:*:*", "matchCriteriaId": "2DDCB342-4F5F-4BF1-9624-882BBC57330D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc2:*:*:*:*:*:*", "matchCriteriaId": "C3AB4113-BF83-4587-8A85-0E4FECEE7D9B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc3:*:*:*:*:*:*", "matchCriteriaId": "4B57F5AD-A697-4090-89B9-81BC12993A1A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc4:*:*:*:*:*:*", "matchCriteriaId": "CA141BCB-A705-4DF5-9EED-746B62C86111"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc5:*:*:*:*:*:*", "matchCriteriaId": "E9ECE134-58A3-4B9D-B9B3-F836C0EDD64C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc6:*:*:*:*:*:*", "matchCriteriaId": "56186720-6B4C-4D71-85C5-7EAC5C5D84A1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc7:*:*:*:*:*:*", "matchCriteriaId": "9BBB4630-CBED-43B9-B203-BE65BBF011AA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc8:*:*:*:*:*:*", "matchCriteriaId": "FD375A78-63D7-441A-9FB0-7BC878AB4EDD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.1:*:*:*:*:*:*:*", "matchCriteriaId": "A5BEFFDD-02BB-4A05-8372-891DBDB9AC5A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.2:*:*:*:*:*:*:*", "matchCriteriaId": "766E193D-819C-42EA-8411-AE0013AC15FA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.3:*:*:*:*:*:*:*", "matchCriteriaId": "3B39B6AF-6A83-48C2-BED2-79228F8513A6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.4:*:*:*:*:*:*:*", "matchCriteriaId": "CD8A68D1-DFE9-4ADB-9FB8-4D69AB4CAFF8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.5:*:*:*:*:*:*:*", "matchCriteriaId": "0D6EF951-AF15-4C30-A3A5-3392AA61813C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.6:*:*:*:*:*:*:*", "matchCriteriaId": "15154FA0-65DC-4855-AC70-3ACF92313F49"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.7:*:*:*:*:*:*:*", "matchCriteriaId": "F4B3A9F4-A61F-4919-A173-3E459F0C5AF8"}]}]}], "references": [{"url": "http://ftp.osuosl.org/pub/linux/kernel/v2.6/ChangeLog-2.6.39", "source": "secalert@redhat.com"}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=0f22072ab50cac7983f9660d33974b45184da4f9", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2011/05/02/16", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/0f22072ab50cac7983f9660d33974b45184da4f9", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/0f22072ab50cac7983f9660d33974b45184da4f9"}}