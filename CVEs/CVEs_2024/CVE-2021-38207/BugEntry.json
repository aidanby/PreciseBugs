{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Driver for Xilinx TEMAC Ethernet device\n *\n * Copyright (c) 2008 Nissin Systems Co., Ltd.,  Yoshio Kashiwagi\n * Copyright (c) 2005-2008 DLA Systems,  David H. Lynch Jr. <dhlii@dlasys.net>\n * Copyright (c) 2008-2009 Secret Lab Technologies Ltd.\n *\n * This is a driver for the Xilinx ll_temac ipcore which is often used\n * in the Virtex and Spartan series of chips.\n *\n * Notes:\n * - The ll_temac hardware uses indirect access for many of the TEMAC\n *   registers, include the MDIO bus.  However, indirect access to MDIO\n *   registers take considerably more clock cycles than to TEMAC registers.\n *   MDIO accesses are long, so threads doing them should probably sleep\n *   rather than busywait.  However, since only one indirect access can be\n *   in progress at any given time, that means that *all* indirect accesses\n *   could end up sleeping (to wait for an MDIO access to complete).\n *   Fortunately none of the indirect accesses are on the 'hot' path for tx\n *   or rx, so this should be okay.\n *\n * TODO:\n * - Factor out locallink DMA code into separate driver\n * - Fix support for hardware checksumming.\n * - Testing.  Lots and lots of testing.\n *\n */\n\n#include <linux/delay.h>\n#include <linux/etherdevice.h>\n#include <linux/mii.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/netdevice.h>\n#include <linux/if_ether.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_irq.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/of_platform.h>\n#include <linux/of_address.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/tcp.h>      /* needed for sizeof(tcphdr) */\n#include <linux/udp.h>      /* needed for sizeof(udphdr) */\n#include <linux/phy.h>\n#include <linux/in.h>\n#include <linux/io.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/workqueue.h>\n#include <linux/dma-mapping.h>\n#include <linux/processor.h>\n#include <linux/platform_data/xilinx-ll-temac.h>\n\n#include \"ll_temac.h\"\n\n/* Descriptors defines for Tx and Rx DMA */\n#define TX_BD_NUM_DEFAULT\t\t64\n#define RX_BD_NUM_DEFAULT\t\t1024\n#define TX_BD_NUM_MAX\t\t\t4096\n#define RX_BD_NUM_MAX\t\t\t4096\n\n/* ---------------------------------------------------------------------\n * Low level register access functions\n */\n\nstatic u32 _temac_ior_be(struct temac_local *lp, int offset)\n{\n\treturn ioread32be(lp->regs + offset);\n}\n\nstatic void _temac_iow_be(struct temac_local *lp, int offset, u32 value)\n{\n\treturn iowrite32be(value, lp->regs + offset);\n}\n\nstatic u32 _temac_ior_le(struct temac_local *lp, int offset)\n{\n\treturn ioread32(lp->regs + offset);\n}\n\nstatic void _temac_iow_le(struct temac_local *lp, int offset, u32 value)\n{\n\treturn iowrite32(value, lp->regs + offset);\n}\n\nstatic bool hard_acs_rdy(struct temac_local *lp)\n{\n\treturn temac_ior(lp, XTE_RDY0_OFFSET) & XTE_RDY0_HARD_ACS_RDY_MASK;\n}\n\nstatic bool hard_acs_rdy_or_timeout(struct temac_local *lp, ktime_t timeout)\n{\n\tktime_t cur = ktime_get();\n\n\treturn hard_acs_rdy(lp) || ktime_after(cur, timeout);\n}\n\n/* Poll for maximum 20 ms.  This is similar to the 2 jiffies @ 100 Hz\n * that was used before, and should cover MDIO bus speed down to 3200\n * Hz.\n */\n#define HARD_ACS_RDY_POLL_NS (20 * NSEC_PER_MSEC)\n\n/*\n * temac_indirect_busywait - Wait for current indirect register access\n * to complete.\n */\nint temac_indirect_busywait(struct temac_local *lp)\n{\n\tktime_t timeout = ktime_add_ns(ktime_get(), HARD_ACS_RDY_POLL_NS);\n\n\tspin_until_cond(hard_acs_rdy_or_timeout(lp, timeout));\n\tif (WARN_ON(!hard_acs_rdy(lp)))\n\t\treturn -ETIMEDOUT;\n\telse\n\t\treturn 0;\n}\n\n/*\n * temac_indirect_in32 - Indirect register read access.  This function\n * must be called without lp->indirect_lock being held.\n */\nu32 temac_indirect_in32(struct temac_local *lp, int reg)\n{\n\tunsigned long flags;\n\tint val;\n\n\tspin_lock_irqsave(lp->indirect_lock, flags);\n\tval = temac_indirect_in32_locked(lp, reg);\n\tspin_unlock_irqrestore(lp->indirect_lock, flags);\n\treturn val;\n}\n\n/*\n * temac_indirect_in32_locked - Indirect register read access.  This\n * function must be called with lp->indirect_lock being held.  Use\n * this together with spin_lock_irqsave/spin_lock_irqrestore to avoid\n * repeated lock/unlock and to ensure uninterrupted access to indirect\n * registers.\n */\nu32 temac_indirect_in32_locked(struct temac_local *lp, int reg)\n{\n\t/* This initial wait should normally not spin, as we always\n\t * try to wait for indirect access to complete before\n\t * releasing the indirect_lock.\n\t */\n\tif (WARN_ON(temac_indirect_busywait(lp)))\n\t\treturn -ETIMEDOUT;\n\t/* Initiate read from indirect register */\n\ttemac_iow(lp, XTE_CTL0_OFFSET, reg);\n\t/* Wait for indirect register access to complete.  We really\n\t * should not see timeouts, and could even end up causing\n\t * problem for following indirect access, so let's make a bit\n\t * of WARN noise.\n\t */\n\tif (WARN_ON(temac_indirect_busywait(lp)))\n\t\treturn -ETIMEDOUT;\n\t/* Value is ready now */\n\treturn temac_ior(lp, XTE_LSW0_OFFSET);\n}\n\n/*\n * temac_indirect_out32 - Indirect register write access.  This function\n * must be called without lp->indirect_lock being held.\n */\nvoid temac_indirect_out32(struct temac_local *lp, int reg, u32 value)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(lp->indirect_lock, flags);\n\ttemac_indirect_out32_locked(lp, reg, value);\n\tspin_unlock_irqrestore(lp->indirect_lock, flags);\n}\n\n/*\n * temac_indirect_out32_locked - Indirect register write access.  This\n * function must be called with lp->indirect_lock being held.  Use\n * this together with spin_lock_irqsave/spin_lock_irqrestore to avoid\n * repeated lock/unlock and to ensure uninterrupted access to indirect\n * registers.\n */\nvoid temac_indirect_out32_locked(struct temac_local *lp, int reg, u32 value)\n{\n\t/* As in temac_indirect_in32_locked(), we should normally not\n\t * spin here.  And if it happens, we actually end up silently\n\t * ignoring the write request.  Ouch.\n\t */\n\tif (WARN_ON(temac_indirect_busywait(lp)))\n\t\treturn;\n\t/* Initiate write to indirect register */\n\ttemac_iow(lp, XTE_LSW0_OFFSET, value);\n\ttemac_iow(lp, XTE_CTL0_OFFSET, CNTLREG_WRITE_ENABLE_MASK | reg);\n\t/* As in temac_indirect_in32_locked(), we should not see timeouts\n\t * here.  And if it happens, we continue before the write has\n\t * completed.  Not good.\n\t */\n\tWARN_ON(temac_indirect_busywait(lp));\n}\n\n/*\n * temac_dma_in32_* - Memory mapped DMA read, these function expects a\n * register input that is based on DCR word addresses which are then\n * converted to memory mapped byte addresses.  To be assigned to\n * lp->dma_in32.\n */\nstatic u32 temac_dma_in32_be(struct temac_local *lp, int reg)\n{\n\treturn ioread32be(lp->sdma_regs + (reg << 2));\n}\n\nstatic u32 temac_dma_in32_le(struct temac_local *lp, int reg)\n{\n\treturn ioread32(lp->sdma_regs + (reg << 2));\n}\n\n/*\n * temac_dma_out32_* - Memory mapped DMA read, these function expects\n * a register input that is based on DCR word addresses which are then\n * converted to memory mapped byte addresses.  To be assigned to\n * lp->dma_out32.\n */\nstatic void temac_dma_out32_be(struct temac_local *lp, int reg, u32 value)\n{\n\tiowrite32be(value, lp->sdma_regs + (reg << 2));\n}\n\nstatic void temac_dma_out32_le(struct temac_local *lp, int reg, u32 value)\n{\n\tiowrite32(value, lp->sdma_regs + (reg << 2));\n}\n\n/* DMA register access functions can be DCR based or memory mapped.\n * The PowerPC 440 is DCR based, the PowerPC 405 and MicroBlaze are both\n * memory mapped.\n */\n#ifdef CONFIG_PPC_DCR\n\n/*\n * temac_dma_dcr_in32 - DCR based DMA read\n */\nstatic u32 temac_dma_dcr_in(struct temac_local *lp, int reg)\n{\n\treturn dcr_read(lp->sdma_dcrs, reg);\n}\n\n/*\n * temac_dma_dcr_out32 - DCR based DMA write\n */\nstatic void temac_dma_dcr_out(struct temac_local *lp, int reg, u32 value)\n{\n\tdcr_write(lp->sdma_dcrs, reg, value);\n}\n\n/*\n * temac_dcr_setup - If the DMA is DCR based, then setup the address and\n * I/O  functions\n */\nstatic int temac_dcr_setup(struct temac_local *lp, struct platform_device *op,\n\t\t\t\tstruct device_node *np)\n{\n\tunsigned int dcrs;\n\n\t/* setup the dcr address mapping if it's in the device tree */\n\n\tdcrs = dcr_resource_start(np, 0);\n\tif (dcrs != 0) {\n\t\tlp->sdma_dcrs = dcr_map(np, dcrs, dcr_resource_len(np, 0));\n\t\tlp->dma_in = temac_dma_dcr_in;\n\t\tlp->dma_out = temac_dma_dcr_out;\n\t\tdev_dbg(&op->dev, \"DCR base: %x\\n\", dcrs);\n\t\treturn 0;\n\t}\n\t/* no DCR in the device tree, indicate a failure */\n\treturn -1;\n}\n\n#else\n\n/*\n * temac_dcr_setup - This is a stub for when DCR is not supported,\n * such as with MicroBlaze and x86\n */\nstatic int temac_dcr_setup(struct temac_local *lp, struct platform_device *op,\n\t\t\t\tstruct device_node *np)\n{\n\treturn -1;\n}\n\n#endif\n\n/*\n * temac_dma_bd_release - Release buffer descriptor rings\n */\nstatic void temac_dma_bd_release(struct net_device *ndev)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tint i;\n\n\t/* Reset Local Link (DMA) */\n\tlp->dma_out(lp, DMA_CONTROL_REG, DMA_CONTROL_RST);\n\n\tfor (i = 0; i < lp->rx_bd_num; i++) {\n\t\tif (!lp->rx_skb[i])\n\t\t\tbreak;\n\t\telse {\n\t\t\tdma_unmap_single(ndev->dev.parent, lp->rx_bd_v[i].phys,\n\t\t\t\t\tXTE_MAX_JUMBO_FRAME_SIZE, DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb(lp->rx_skb[i]);\n\t\t}\n\t}\n\tif (lp->rx_bd_v)\n\t\tdma_free_coherent(ndev->dev.parent,\n\t\t\t\t  sizeof(*lp->rx_bd_v) * lp->rx_bd_num,\n\t\t\t\t  lp->rx_bd_v, lp->rx_bd_p);\n\tif (lp->tx_bd_v)\n\t\tdma_free_coherent(ndev->dev.parent,\n\t\t\t\t  sizeof(*lp->tx_bd_v) * lp->tx_bd_num,\n\t\t\t\t  lp->tx_bd_v, lp->tx_bd_p);\n}\n\n/*\n * temac_dma_bd_init - Setup buffer descriptor rings\n */\nstatic int temac_dma_bd_init(struct net_device *ndev)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tstruct sk_buff *skb;\n\tdma_addr_t skb_dma_addr;\n\tint i;\n\n\tlp->rx_skb = devm_kcalloc(&ndev->dev, lp->rx_bd_num,\n\t\t\t\t  sizeof(*lp->rx_skb), GFP_KERNEL);\n\tif (!lp->rx_skb)\n\t\tgoto out;\n\n\t/* allocate the tx and rx ring buffer descriptors. */\n\t/* returns a virtual address and a physical address. */\n\tlp->tx_bd_v = dma_alloc_coherent(ndev->dev.parent,\n\t\t\t\t\t sizeof(*lp->tx_bd_v) * lp->tx_bd_num,\n\t\t\t\t\t &lp->tx_bd_p, GFP_KERNEL);\n\tif (!lp->tx_bd_v)\n\t\tgoto out;\n\n\tlp->rx_bd_v = dma_alloc_coherent(ndev->dev.parent,\n\t\t\t\t\t sizeof(*lp->rx_bd_v) * lp->rx_bd_num,\n\t\t\t\t\t &lp->rx_bd_p, GFP_KERNEL);\n\tif (!lp->rx_bd_v)\n\t\tgoto out;\n\n\tfor (i = 0; i < lp->tx_bd_num; i++) {\n\t\tlp->tx_bd_v[i].next = cpu_to_be32(lp->tx_bd_p\n\t\t\t+ sizeof(*lp->tx_bd_v) * ((i + 1) % lp->tx_bd_num));\n\t}\n\n\tfor (i = 0; i < lp->rx_bd_num; i++) {\n\t\tlp->rx_bd_v[i].next = cpu_to_be32(lp->rx_bd_p\n\t\t\t+ sizeof(*lp->rx_bd_v) * ((i + 1) % lp->rx_bd_num));\n\n\t\tskb = netdev_alloc_skb_ip_align(ndev,\n\t\t\t\t\t\tXTE_MAX_JUMBO_FRAME_SIZE);\n\t\tif (!skb)\n\t\t\tgoto out;\n\n\t\tlp->rx_skb[i] = skb;\n\t\t/* returns physical address of skb->data */\n\t\tskb_dma_addr = dma_map_single(ndev->dev.parent, skb->data,\n\t\t\t\t\t      XTE_MAX_JUMBO_FRAME_SIZE,\n\t\t\t\t\t      DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(ndev->dev.parent, skb_dma_addr))\n\t\t\tgoto out;\n\t\tlp->rx_bd_v[i].phys = cpu_to_be32(skb_dma_addr);\n\t\tlp->rx_bd_v[i].len = cpu_to_be32(XTE_MAX_JUMBO_FRAME_SIZE);\n\t\tlp->rx_bd_v[i].app0 = cpu_to_be32(STS_CTRL_APP0_IRQONEND);\n\t}\n\n\t/* Configure DMA channel (irq setup) */\n\tlp->dma_out(lp, TX_CHNL_CTRL,\n\t\t    lp->coalesce_delay_tx << 24 | lp->coalesce_count_tx << 16 |\n\t\t    0x00000400 | // Use 1 Bit Wide Counters. Currently Not Used!\n\t\t    CHNL_CTRL_IRQ_EN | CHNL_CTRL_IRQ_ERR_EN |\n\t\t    CHNL_CTRL_IRQ_DLY_EN | CHNL_CTRL_IRQ_COAL_EN);\n\tlp->dma_out(lp, RX_CHNL_CTRL,\n\t\t    lp->coalesce_delay_rx << 24 | lp->coalesce_count_rx << 16 |\n\t\t    CHNL_CTRL_IRQ_IOE |\n\t\t    CHNL_CTRL_IRQ_EN | CHNL_CTRL_IRQ_ERR_EN |\n\t\t    CHNL_CTRL_IRQ_DLY_EN | CHNL_CTRL_IRQ_COAL_EN);\n\n\t/* Init descriptor indexes */\n\tlp->tx_bd_ci = 0;\n\tlp->tx_bd_tail = 0;\n\tlp->rx_bd_ci = 0;\n\tlp->rx_bd_tail = lp->rx_bd_num - 1;\n\n\t/* Enable RX DMA transfers */\n\twmb();\n\tlp->dma_out(lp, RX_CURDESC_PTR,  lp->rx_bd_p);\n\tlp->dma_out(lp, RX_TAILDESC_PTR,\n\t\t       lp->rx_bd_p + (sizeof(*lp->rx_bd_v) * lp->rx_bd_tail));\n\n\t/* Prepare for TX DMA transfer */\n\tlp->dma_out(lp, TX_CURDESC_PTR, lp->tx_bd_p);\n\n\treturn 0;\n\nout:\n\ttemac_dma_bd_release(ndev);\n\treturn -ENOMEM;\n}\n\n/* ---------------------------------------------------------------------\n * net_device_ops\n */\n\nstatic void temac_do_set_mac_address(struct net_device *ndev)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tunsigned long flags;\n\n\t/* set up unicast MAC address filter set its mac address */\n\tspin_lock_irqsave(lp->indirect_lock, flags);\n\ttemac_indirect_out32_locked(lp, XTE_UAW0_OFFSET,\n\t\t\t\t    (ndev->dev_addr[0]) |\n\t\t\t\t    (ndev->dev_addr[1] << 8) |\n\t\t\t\t    (ndev->dev_addr[2] << 16) |\n\t\t\t\t    (ndev->dev_addr[3] << 24));\n\t/* There are reserved bits in EUAW1\n\t * so don't affect them Set MAC bits [47:32] in EUAW1 */\n\ttemac_indirect_out32_locked(lp, XTE_UAW1_OFFSET,\n\t\t\t\t    (ndev->dev_addr[4] & 0x000000ff) |\n\t\t\t\t    (ndev->dev_addr[5] << 8));\n\tspin_unlock_irqrestore(lp->indirect_lock, flags);\n}\n\nstatic int temac_init_mac_address(struct net_device *ndev, const void *address)\n{\n\tmemcpy(ndev->dev_addr, address, ETH_ALEN);\n\tif (!is_valid_ether_addr(ndev->dev_addr))\n\t\teth_hw_addr_random(ndev);\n\ttemac_do_set_mac_address(ndev);\n\treturn 0;\n}\n\nstatic int temac_set_mac_address(struct net_device *ndev, void *p)\n{\n\tstruct sockaddr *addr = p;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\tmemcpy(ndev->dev_addr, addr->sa_data, ETH_ALEN);\n\ttemac_do_set_mac_address(ndev);\n\treturn 0;\n}\n\nstatic void temac_set_multicast_list(struct net_device *ndev)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tu32 multi_addr_msw, multi_addr_lsw;\n\tint i = 0;\n\tunsigned long flags;\n\tbool promisc_mode_disabled = false;\n\n\tif (ndev->flags & (IFF_PROMISC | IFF_ALLMULTI) ||\n\t    (netdev_mc_count(ndev) > MULTICAST_CAM_TABLE_NUM)) {\n\t\ttemac_indirect_out32(lp, XTE_AFM_OFFSET, XTE_AFM_EPPRM_MASK);\n\t\tdev_info(&ndev->dev, \"Promiscuous mode enabled.\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(lp->indirect_lock, flags);\n\n\tif (!netdev_mc_empty(ndev)) {\n\t\tstruct netdev_hw_addr *ha;\n\n\t\tnetdev_for_each_mc_addr(ha, ndev) {\n\t\t\tif (WARN_ON(i >= MULTICAST_CAM_TABLE_NUM))\n\t\t\t\tbreak;\n\t\t\tmulti_addr_msw = ((ha->addr[3] << 24) |\n\t\t\t\t\t  (ha->addr[2] << 16) |\n\t\t\t\t\t  (ha->addr[1] << 8) |\n\t\t\t\t\t  (ha->addr[0]));\n\t\t\ttemac_indirect_out32_locked(lp, XTE_MAW0_OFFSET,\n\t\t\t\t\t\t    multi_addr_msw);\n\t\t\tmulti_addr_lsw = ((ha->addr[5] << 8) |\n\t\t\t\t\t  (ha->addr[4]) | (i << 16));\n\t\t\ttemac_indirect_out32_locked(lp, XTE_MAW1_OFFSET,\n\t\t\t\t\t\t    multi_addr_lsw);\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/* Clear all or remaining/unused address table entries */\n\twhile (i < MULTICAST_CAM_TABLE_NUM) {\n\t\ttemac_indirect_out32_locked(lp, XTE_MAW0_OFFSET, 0);\n\t\ttemac_indirect_out32_locked(lp, XTE_MAW1_OFFSET, i << 16);\n\t\ti++;\n\t}\n\n\t/* Enable address filter block if currently disabled */\n\tif (temac_indirect_in32_locked(lp, XTE_AFM_OFFSET)\n\t    & XTE_AFM_EPPRM_MASK) {\n\t\ttemac_indirect_out32_locked(lp, XTE_AFM_OFFSET, 0);\n\t\tpromisc_mode_disabled = true;\n\t}\n\n\tspin_unlock_irqrestore(lp->indirect_lock, flags);\n\n\tif (promisc_mode_disabled)\n\t\tdev_info(&ndev->dev, \"Promiscuous mode disabled.\\n\");\n}\n\nstatic struct temac_option {\n\tint flg;\n\tu32 opt;\n\tu32 reg;\n\tu32 m_or;\n\tu32 m_and;\n} temac_options[] = {\n\t/* Turn on jumbo packet support for both Rx and Tx */\n\t{\n\t\t.opt = XTE_OPTION_JUMBO,\n\t\t.reg = XTE_TXC_OFFSET,\n\t\t.m_or = XTE_TXC_TXJMBO_MASK,\n\t},\n\t{\n\t\t.opt = XTE_OPTION_JUMBO,\n\t\t.reg = XTE_RXC1_OFFSET,\n\t\t.m_or =XTE_RXC1_RXJMBO_MASK,\n\t},\n\t/* Turn on VLAN packet support for both Rx and Tx */\n\t{\n\t\t.opt = XTE_OPTION_VLAN,\n\t\t.reg = XTE_TXC_OFFSET,\n\t\t.m_or =XTE_TXC_TXVLAN_MASK,\n\t},\n\t{\n\t\t.opt = XTE_OPTION_VLAN,\n\t\t.reg = XTE_RXC1_OFFSET,\n\t\t.m_or =XTE_RXC1_RXVLAN_MASK,\n\t},\n\t/* Turn on FCS stripping on receive packets */\n\t{\n\t\t.opt = XTE_OPTION_FCS_STRIP,\n\t\t.reg = XTE_RXC1_OFFSET,\n\t\t.m_or =XTE_RXC1_RXFCS_MASK,\n\t},\n\t/* Turn on FCS insertion on transmit packets */\n\t{\n\t\t.opt = XTE_OPTION_FCS_INSERT,\n\t\t.reg = XTE_TXC_OFFSET,\n\t\t.m_or =XTE_TXC_TXFCS_MASK,\n\t},\n\t/* Turn on length/type field checking on receive packets */\n\t{\n\t\t.opt = XTE_OPTION_LENTYPE_ERR,\n\t\t.reg = XTE_RXC1_OFFSET,\n\t\t.m_or =XTE_RXC1_RXLT_MASK,\n\t},\n\t/* Turn on flow control */\n\t{\n\t\t.opt = XTE_OPTION_FLOW_CONTROL,\n\t\t.reg = XTE_FCC_OFFSET,\n\t\t.m_or =XTE_FCC_RXFLO_MASK,\n\t},\n\t/* Turn on flow control */\n\t{\n\t\t.opt = XTE_OPTION_FLOW_CONTROL,\n\t\t.reg = XTE_FCC_OFFSET,\n\t\t.m_or =XTE_FCC_TXFLO_MASK,\n\t},\n\t/* Turn on promiscuous frame filtering (all frames are received ) */\n\t{\n\t\t.opt = XTE_OPTION_PROMISC,\n\t\t.reg = XTE_AFM_OFFSET,\n\t\t.m_or =XTE_AFM_EPPRM_MASK,\n\t},\n\t/* Enable transmitter if not already enabled */\n\t{\n\t\t.opt = XTE_OPTION_TXEN,\n\t\t.reg = XTE_TXC_OFFSET,\n\t\t.m_or =XTE_TXC_TXEN_MASK,\n\t},\n\t/* Enable receiver? */\n\t{\n\t\t.opt = XTE_OPTION_RXEN,\n\t\t.reg = XTE_RXC1_OFFSET,\n\t\t.m_or =XTE_RXC1_RXEN_MASK,\n\t},\n\t{}\n};\n\n/*\n * temac_setoptions\n */\nstatic u32 temac_setoptions(struct net_device *ndev, u32 options)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tstruct temac_option *tp = &temac_options[0];\n\tint reg;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(lp->indirect_lock, flags);\n\twhile (tp->opt) {\n\t\treg = temac_indirect_in32_locked(lp, tp->reg) & ~tp->m_or;\n\t\tif (options & tp->opt) {\n\t\t\treg |= tp->m_or;\n\t\t\ttemac_indirect_out32_locked(lp, tp->reg, reg);\n\t\t}\n\t\ttp++;\n\t}\n\tspin_unlock_irqrestore(lp->indirect_lock, flags);\n\tlp->options |= options;\n\n\treturn 0;\n}\n\n/* Initialize temac */\nstatic void temac_device_reset(struct net_device *ndev)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tu32 timeout;\n\tu32 val;\n\tunsigned long flags;\n\n\t/* Perform a software reset */\n\n\t/* 0x300 host enable bit ? */\n\t/* reset PHY through control register ?:1 */\n\n\tdev_dbg(&ndev->dev, \"%s()\\n\", __func__);\n\n\t/* Reset the receiver and wait for it to finish reset */\n\ttemac_indirect_out32(lp, XTE_RXC1_OFFSET, XTE_RXC1_RXRST_MASK);\n\ttimeout = 1000;\n\twhile (temac_indirect_in32(lp, XTE_RXC1_OFFSET) & XTE_RXC1_RXRST_MASK) {\n\t\tudelay(1);\n\t\tif (--timeout == 0) {\n\t\t\tdev_err(&ndev->dev,\n\t\t\t\t\"temac_device_reset RX reset timeout!!\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Reset the transmitter and wait for it to finish reset */\n\ttemac_indirect_out32(lp, XTE_TXC_OFFSET, XTE_TXC_TXRST_MASK);\n\ttimeout = 1000;\n\twhile (temac_indirect_in32(lp, XTE_TXC_OFFSET) & XTE_TXC_TXRST_MASK) {\n\t\tudelay(1);\n\t\tif (--timeout == 0) {\n\t\t\tdev_err(&ndev->dev,\n\t\t\t\t\"temac_device_reset TX reset timeout!!\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Disable the receiver */\n\tspin_lock_irqsave(lp->indirect_lock, flags);\n\tval = temac_indirect_in32_locked(lp, XTE_RXC1_OFFSET);\n\ttemac_indirect_out32_locked(lp, XTE_RXC1_OFFSET,\n\t\t\t\t    val & ~XTE_RXC1_RXEN_MASK);\n\tspin_unlock_irqrestore(lp->indirect_lock, flags);\n\n\t/* Reset Local Link (DMA) */\n\tlp->dma_out(lp, DMA_CONTROL_REG, DMA_CONTROL_RST);\n\ttimeout = 1000;\n\twhile (lp->dma_in(lp, DMA_CONTROL_REG) & DMA_CONTROL_RST) {\n\t\tudelay(1);\n\t\tif (--timeout == 0) {\n\t\t\tdev_err(&ndev->dev,\n\t\t\t\t\"temac_device_reset DMA reset timeout!!\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tlp->dma_out(lp, DMA_CONTROL_REG, DMA_TAIL_ENABLE);\n\n\tif (temac_dma_bd_init(ndev)) {\n\t\tdev_err(&ndev->dev,\n\t\t\t\t\"temac_device_reset descriptor allocation failed\\n\");\n\t}\n\n\tspin_lock_irqsave(lp->indirect_lock, flags);\n\ttemac_indirect_out32_locked(lp, XTE_RXC0_OFFSET, 0);\n\ttemac_indirect_out32_locked(lp, XTE_RXC1_OFFSET, 0);\n\ttemac_indirect_out32_locked(lp, XTE_TXC_OFFSET, 0);\n\ttemac_indirect_out32_locked(lp, XTE_FCC_OFFSET, XTE_FCC_RXFLO_MASK);\n\tspin_unlock_irqrestore(lp->indirect_lock, flags);\n\n\t/* Sync default options with HW\n\t * but leave receiver and transmitter disabled.  */\n\ttemac_setoptions(ndev,\n\t\t\t lp->options & ~(XTE_OPTION_TXEN | XTE_OPTION_RXEN));\n\n\ttemac_do_set_mac_address(ndev);\n\n\t/* Set address filter table */\n\ttemac_set_multicast_list(ndev);\n\tif (temac_setoptions(ndev, lp->options))\n\t\tdev_err(&ndev->dev, \"Error setting TEMAC options\\n\");\n\n\t/* Init Driver variable */\n\tnetif_trans_update(ndev); /* prevent tx timeout */\n}\n\nstatic void temac_adjust_link(struct net_device *ndev)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tstruct phy_device *phy = ndev->phydev;\n\tu32 mii_speed;\n\tint link_state;\n\tunsigned long flags;\n\n\t/* hash together the state values to decide if something has changed */\n\tlink_state = phy->speed | (phy->duplex << 1) | phy->link;\n\n\tif (lp->last_link != link_state) {\n\t\tspin_lock_irqsave(lp->indirect_lock, flags);\n\t\tmii_speed = temac_indirect_in32_locked(lp, XTE_EMCFG_OFFSET);\n\t\tmii_speed &= ~XTE_EMCFG_LINKSPD_MASK;\n\n\t\tswitch (phy->speed) {\n\t\tcase SPEED_1000: mii_speed |= XTE_EMCFG_LINKSPD_1000; break;\n\t\tcase SPEED_100: mii_speed |= XTE_EMCFG_LINKSPD_100; break;\n\t\tcase SPEED_10: mii_speed |= XTE_EMCFG_LINKSPD_10; break;\n\t\t}\n\n\t\t/* Write new speed setting out to TEMAC */\n\t\ttemac_indirect_out32_locked(lp, XTE_EMCFG_OFFSET, mii_speed);\n\t\tspin_unlock_irqrestore(lp->indirect_lock, flags);\n\n\t\tlp->last_link = link_state;\n\t\tphy_print_status(phy);\n\t}\n}\n\n#ifdef CONFIG_64BIT\n\nstatic void ptr_to_txbd(void *p, struct cdmac_bd *bd)\n{\n\tbd->app3 = (u32)(((u64)p) >> 32);\n\tbd->app4 = (u32)((u64)p & 0xFFFFFFFF);\n}\n\nstatic void *ptr_from_txbd(struct cdmac_bd *bd)\n{\n\treturn (void *)(((u64)(bd->app3) << 32) | bd->app4);\n}\n\n#else\n\nstatic void ptr_to_txbd(void *p, struct cdmac_bd *bd)\n{\n\tbd->app4 = (u32)p;\n}\n\nstatic void *ptr_from_txbd(struct cdmac_bd *bd)\n{\n\treturn (void *)(bd->app4);\n}\n\n#endif\n\nstatic void temac_start_xmit_done(struct net_device *ndev)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tstruct cdmac_bd *cur_p;\n\tunsigned int stat = 0;\n\tstruct sk_buff *skb;\n\n\tcur_p = &lp->tx_bd_v[lp->tx_bd_ci];\n\tstat = be32_to_cpu(cur_p->app0);\n\n\twhile (stat & STS_CTRL_APP0_CMPLT) {\n\t\t/* Make sure that the other fields are read after bd is\n\t\t * released by dma\n\t\t */\n\t\trmb();\n\t\tdma_unmap_single(ndev->dev.parent, be32_to_cpu(cur_p->phys),\n\t\t\t\t be32_to_cpu(cur_p->len), DMA_TO_DEVICE);\n\t\tskb = (struct sk_buff *)ptr_from_txbd(cur_p);\n\t\tif (skb)\n\t\t\tdev_consume_skb_irq(skb);\n\t\tcur_p->app1 = 0;\n\t\tcur_p->app2 = 0;\n\t\tcur_p->app3 = 0;\n\t\tcur_p->app4 = 0;\n\n\t\tndev->stats.tx_packets++;\n\t\tndev->stats.tx_bytes += be32_to_cpu(cur_p->len);\n\n\t\t/* app0 must be visible last, as it is used to flag\n\t\t * availability of the bd\n\t\t */\n\t\tsmp_mb();\n\t\tcur_p->app0 = 0;\n\n\t\tlp->tx_bd_ci++;\n\t\tif (lp->tx_bd_ci >= lp->tx_bd_num)\n\t\t\tlp->tx_bd_ci = 0;\n\n\t\tcur_p = &lp->tx_bd_v[lp->tx_bd_ci];\n\t\tstat = be32_to_cpu(cur_p->app0);\n\t}\n\n\t/* Matches barrier in temac_start_xmit */\n\tsmp_mb();\n\n\tnetif_wake_queue(ndev);\n}\n\nstatic inline int temac_check_tx_bd_space(struct temac_local *lp, int num_frag)\n{\n\tstruct cdmac_bd *cur_p;\n\tint tail;\n\n\ttail = lp->tx_bd_tail;\n\tcur_p = &lp->tx_bd_v[tail];\n\n\tdo {\n\t\tif (cur_p->app0)\n\t\t\treturn NETDEV_TX_BUSY;\n\n\t\t/* Make sure to read next bd app0 after this one */\n\t\trmb();\n\n\t\ttail++;\n\t\tif (tail >= lp->tx_bd_num)\n\t\t\ttail = 0;\n\n\t\tcur_p = &lp->tx_bd_v[tail];\n\t\tnum_frag--;\n\t} while (num_frag >= 0);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t\ntemac_start_xmit(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tstruct cdmac_bd *cur_p;\n\tdma_addr_t tail_p, skb_dma_addr;\n\tint ii;\n\tunsigned long num_frag;\n\tskb_frag_t *frag;\n\n\tnum_frag = skb_shinfo(skb)->nr_frags;\n\tfrag = &skb_shinfo(skb)->frags[0];\n\tcur_p = &lp->tx_bd_v[lp->tx_bd_tail];\n\n\tif (temac_check_tx_bd_space(lp, num_frag + 1)) {\n\t\tif (netif_queue_stopped(ndev))\n\t\t\treturn NETDEV_TX_BUSY;\n\n\t\tnetif_stop_queue(ndev);\n\n\t\t/* Matches barrier in temac_start_xmit_done */\n\t\tsmp_mb();\n\n\t\t/* Space might have just been freed - check again */\n\t\tif (temac_check_tx_bd_space(lp, num_frag))\n\t\t\treturn NETDEV_TX_BUSY;\n\n\t\tnetif_wake_queue(ndev);\n\t}\n\n\tcur_p->app0 = 0;\n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\tunsigned int csum_start_off = skb_checksum_start_offset(skb);\n\t\tunsigned int csum_index_off = csum_start_off + skb->csum_offset;\n\n\t\tcur_p->app0 |= cpu_to_be32(0x000001); /* TX Checksum Enabled */\n\t\tcur_p->app1 = cpu_to_be32((csum_start_off << 16)\n\t\t\t\t\t  | csum_index_off);\n\t\tcur_p->app2 = 0;  /* initial checksum seed */\n\t}\n\n\tcur_p->app0 |= cpu_to_be32(STS_CTRL_APP0_SOP);\n\tskb_dma_addr = dma_map_single(ndev->dev.parent, skb->data,\n\t\t\t\t      skb_headlen(skb), DMA_TO_DEVICE);\n\tcur_p->len = cpu_to_be32(skb_headlen(skb));\n\tif (WARN_ON_ONCE(dma_mapping_error(ndev->dev.parent, skb_dma_addr))) {\n\t\tdev_kfree_skb_any(skb);\n\t\tndev->stats.tx_dropped++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\tcur_p->phys = cpu_to_be32(skb_dma_addr);\n\n\tfor (ii = 0; ii < num_frag; ii++) {\n\t\tif (++lp->tx_bd_tail >= lp->tx_bd_num)\n\t\t\tlp->tx_bd_tail = 0;\n\n\t\tcur_p = &lp->tx_bd_v[lp->tx_bd_tail];\n\t\tskb_dma_addr = dma_map_single(ndev->dev.parent,\n\t\t\t\t\t      skb_frag_address(frag),\n\t\t\t\t\t      skb_frag_size(frag),\n\t\t\t\t\t      DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(ndev->dev.parent, skb_dma_addr)) {\n\t\t\tif (--lp->tx_bd_tail < 0)\n\t\t\t\tlp->tx_bd_tail = lp->tx_bd_num - 1;\n\t\t\tcur_p = &lp->tx_bd_v[lp->tx_bd_tail];\n\t\t\twhile (--ii >= 0) {\n\t\t\t\t--frag;\n\t\t\t\tdma_unmap_single(ndev->dev.parent,\n\t\t\t\t\t\t be32_to_cpu(cur_p->phys),\n\t\t\t\t\t\t skb_frag_size(frag),\n\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\t\tif (--lp->tx_bd_tail < 0)\n\t\t\t\t\tlp->tx_bd_tail = lp->tx_bd_num - 1;\n\t\t\t\tcur_p = &lp->tx_bd_v[lp->tx_bd_tail];\n\t\t\t}\n\t\t\tdma_unmap_single(ndev->dev.parent,\n\t\t\t\t\t be32_to_cpu(cur_p->phys),\n\t\t\t\t\t skb_headlen(skb), DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tndev->stats.tx_dropped++;\n\t\t\treturn NETDEV_TX_OK;\n\t\t}\n\t\tcur_p->phys = cpu_to_be32(skb_dma_addr);\n\t\tcur_p->len = cpu_to_be32(skb_frag_size(frag));\n\t\tcur_p->app0 = 0;\n\t\tfrag++;\n\t}\n\tcur_p->app0 |= cpu_to_be32(STS_CTRL_APP0_EOP);\n\n\t/* Mark last fragment with skb address, so it can be consumed\n\t * in temac_start_xmit_done()\n\t */\n\tptr_to_txbd((void *)skb, cur_p);\n\n\ttail_p = lp->tx_bd_p + sizeof(*lp->tx_bd_v) * lp->tx_bd_tail;\n\tlp->tx_bd_tail++;\n\tif (lp->tx_bd_tail >= lp->tx_bd_num)\n\t\tlp->tx_bd_tail = 0;\n\n\tskb_tx_timestamp(skb);\n\n\t/* Kick off the transfer */\n\twmb();\n\tlp->dma_out(lp, TX_TAILDESC_PTR, tail_p); /* DMA start */\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int ll_temac_recv_buffers_available(struct temac_local *lp)\n{\n\tint available;\n\n\tif (!lp->rx_skb[lp->rx_bd_ci])\n\t\treturn 0;\n\tavailable = 1 + lp->rx_bd_tail - lp->rx_bd_ci;\n\tif (available <= 0)\n\t\tavailable += lp->rx_bd_num;\n\treturn available;\n}\n\nstatic void ll_temac_recv(struct net_device *ndev)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tunsigned long flags;\n\tint rx_bd;\n\tbool update_tail = false;\n\n\tspin_lock_irqsave(&lp->rx_lock, flags);\n\n\t/* Process all received buffers, passing them on network\n\t * stack.  After this, the buffer descriptors will be in an\n\t * un-allocated stage, where no skb is allocated for it, and\n\t * they are therefore not available for TEMAC/DMA.\n\t */\n\tdo {\n\t\tstruct cdmac_bd *bd = &lp->rx_bd_v[lp->rx_bd_ci];\n\t\tstruct sk_buff *skb = lp->rx_skb[lp->rx_bd_ci];\n\t\tunsigned int bdstat = be32_to_cpu(bd->app0);\n\t\tint length;\n\n\t\t/* While this should not normally happen, we can end\n\t\t * here when GFP_ATOMIC allocations fail, and we\n\t\t * therefore have un-allocated buffers.\n\t\t */\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\t/* Loop over all completed buffer descriptors */\n\t\tif (!(bdstat & STS_CTRL_APP0_CMPLT))\n\t\t\tbreak;\n\n\t\tdma_unmap_single(ndev->dev.parent, be32_to_cpu(bd->phys),\n\t\t\t\t XTE_MAX_JUMBO_FRAME_SIZE, DMA_FROM_DEVICE);\n\t\t/* The buffer is not valid for DMA anymore */\n\t\tbd->phys = 0;\n\t\tbd->len = 0;\n\n\t\tlength = be32_to_cpu(bd->app4) & 0x3FFF;\n\t\tskb_put(skb, length);\n\t\tskb->protocol = eth_type_trans(skb, ndev);\n\t\tskb_checksum_none_assert(skb);\n\n\t\t/* if we're doing rx csum offload, set it up */\n\t\tif (((lp->temac_features & TEMAC_FEATURE_RX_CSUM) != 0) &&\n\t\t    (skb->protocol == htons(ETH_P_IP)) &&\n\t\t    (skb->len > 64)) {\n\n\t\t\t/* Convert from device endianness (be32) to cpu\n\t\t\t * endiannes, and if necessary swap the bytes\n\t\t\t * (back) for proper IP checksum byte order\n\t\t\t * (be16).\n\t\t\t */\n\t\t\tskb->csum = htons(be32_to_cpu(bd->app3) & 0xFFFF);\n\t\t\tskb->ip_summed = CHECKSUM_COMPLETE;\n\t\t}\n\n\t\tif (!skb_defer_rx_timestamp(skb))\n\t\t\tnetif_rx(skb);\n\t\t/* The skb buffer is now owned by network stack above */\n\t\tlp->rx_skb[lp->rx_bd_ci] = NULL;\n\n\t\tndev->stats.rx_packets++;\n\t\tndev->stats.rx_bytes += length;\n\n\t\trx_bd = lp->rx_bd_ci;\n\t\tif (++lp->rx_bd_ci >= lp->rx_bd_num)\n\t\t\tlp->rx_bd_ci = 0;\n\t} while (rx_bd != lp->rx_bd_tail);\n\n\t/* DMA operations will halt when the last buffer descriptor is\n\t * processed (ie. the one pointed to by RX_TAILDESC_PTR).\n\t * When that happens, no more interrupt events will be\n\t * generated.  No IRQ_COAL or IRQ_DLY, and not even an\n\t * IRQ_ERR.  To avoid stalling, we schedule a delayed work\n\t * when there is a potential risk of that happening.  The work\n\t * will call this function, and thus re-schedule itself until\n\t * enough buffers are available again.\n\t */\n\tif (ll_temac_recv_buffers_available(lp) < lp->coalesce_count_rx)\n\t\tschedule_delayed_work(&lp->restart_work, HZ / 1000);\n\n\t/* Allocate new buffers for those buffer descriptors that were\n\t * passed to network stack.  Note that GFP_ATOMIC allocations\n\t * can fail (e.g. when a larger burst of GFP_ATOMIC\n\t * allocations occurs), so while we try to allocate all\n\t * buffers in the same interrupt where they were processed, we\n\t * continue with what we could get in case of allocation\n\t * failure.  Allocation of remaining buffers will be retried\n\t * in following calls.\n\t */\n\twhile (1) {\n\t\tstruct sk_buff *skb;\n\t\tstruct cdmac_bd *bd;\n\t\tdma_addr_t skb_dma_addr;\n\n\t\trx_bd = lp->rx_bd_tail + 1;\n\t\tif (rx_bd >= lp->rx_bd_num)\n\t\t\trx_bd = 0;\n\t\tbd = &lp->rx_bd_v[rx_bd];\n\n\t\tif (bd->phys)\n\t\t\tbreak;\t/* All skb's allocated */\n\n\t\tskb = netdev_alloc_skb_ip_align(ndev, XTE_MAX_JUMBO_FRAME_SIZE);\n\t\tif (!skb) {\n\t\t\tdev_warn(&ndev->dev, \"skb alloc failed\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tskb_dma_addr = dma_map_single(ndev->dev.parent, skb->data,\n\t\t\t\t\t      XTE_MAX_JUMBO_FRAME_SIZE,\n\t\t\t\t\t      DMA_FROM_DEVICE);\n\t\tif (WARN_ON_ONCE(dma_mapping_error(ndev->dev.parent,\n\t\t\t\t\t\t   skb_dma_addr))) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tbreak;\n\t\t}\n\n\t\tbd->phys = cpu_to_be32(skb_dma_addr);\n\t\tbd->len = cpu_to_be32(XTE_MAX_JUMBO_FRAME_SIZE);\n\t\tbd->app0 = cpu_to_be32(STS_CTRL_APP0_IRQONEND);\n\t\tlp->rx_skb[rx_bd] = skb;\n\n\t\tlp->rx_bd_tail = rx_bd;\n\t\tupdate_tail = true;\n\t}\n\n\t/* Move tail pointer when buffers have been allocated */\n\tif (update_tail) {\n\t\tlp->dma_out(lp, RX_TAILDESC_PTR,\n\t\t\tlp->rx_bd_p + sizeof(*lp->rx_bd_v) * lp->rx_bd_tail);\n\t}\n\n\tspin_unlock_irqrestore(&lp->rx_lock, flags);\n}\n\n/* Function scheduled to ensure a restart in case of DMA halt\n * condition caused by running out of buffer descriptors.\n */\nstatic void ll_temac_restart_work_func(struct work_struct *work)\n{\n\tstruct temac_local *lp = container_of(work, struct temac_local,\n\t\t\t\t\t      restart_work.work);\n\tstruct net_device *ndev = lp->ndev;\n\n\tll_temac_recv(ndev);\n}\n\nstatic irqreturn_t ll_temac_tx_irq(int irq, void *_ndev)\n{\n\tstruct net_device *ndev = _ndev;\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tunsigned int status;\n\n\tstatus = lp->dma_in(lp, TX_IRQ_REG);\n\tlp->dma_out(lp, TX_IRQ_REG, status);\n\n\tif (status & (IRQ_COAL | IRQ_DLY))\n\t\ttemac_start_xmit_done(lp->ndev);\n\tif (status & (IRQ_ERR | IRQ_DMAERR))\n\t\tdev_err_ratelimited(&ndev->dev,\n\t\t\t\t    \"TX error 0x%x TX_CHNL_STS=0x%08x\\n\",\n\t\t\t\t    status, lp->dma_in(lp, TX_CHNL_STS));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t ll_temac_rx_irq(int irq, void *_ndev)\n{\n\tstruct net_device *ndev = _ndev;\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tunsigned int status;\n\n\t/* Read and clear the status registers */\n\tstatus = lp->dma_in(lp, RX_IRQ_REG);\n\tlp->dma_out(lp, RX_IRQ_REG, status);\n\n\tif (status & (IRQ_COAL | IRQ_DLY))\n\t\tll_temac_recv(lp->ndev);\n\tif (status & (IRQ_ERR | IRQ_DMAERR))\n\t\tdev_err_ratelimited(&ndev->dev,\n\t\t\t\t    \"RX error 0x%x RX_CHNL_STS=0x%08x\\n\",\n\t\t\t\t    status, lp->dma_in(lp, RX_CHNL_STS));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int temac_open(struct net_device *ndev)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tstruct phy_device *phydev = NULL;\n\tint rc;\n\n\tdev_dbg(&ndev->dev, \"temac_open()\\n\");\n\n\tif (lp->phy_node) {\n\t\tphydev = of_phy_connect(lp->ndev, lp->phy_node,\n\t\t\t\t\ttemac_adjust_link, 0, 0);\n\t\tif (!phydev) {\n\t\t\tdev_err(lp->dev, \"of_phy_connect() failed\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tphy_start(phydev);\n\t} else if (strlen(lp->phy_name) > 0) {\n\t\tphydev = phy_connect(lp->ndev, lp->phy_name, temac_adjust_link,\n\t\t\t\t     lp->phy_interface);\n\t\tif (IS_ERR(phydev)) {\n\t\t\tdev_err(lp->dev, \"phy_connect() failed\\n\");\n\t\t\treturn PTR_ERR(phydev);\n\t\t}\n\t\tphy_start(phydev);\n\t}\n\n\ttemac_device_reset(ndev);\n\n\trc = request_irq(lp->tx_irq, ll_temac_tx_irq, 0, ndev->name, ndev);\n\tif (rc)\n\t\tgoto err_tx_irq;\n\trc = request_irq(lp->rx_irq, ll_temac_rx_irq, 0, ndev->name, ndev);\n\tif (rc)\n\t\tgoto err_rx_irq;\n\n\treturn 0;\n\n err_rx_irq:\n\tfree_irq(lp->tx_irq, ndev);\n err_tx_irq:\n\tif (phydev)\n\t\tphy_disconnect(phydev);\n\tdev_err(lp->dev, \"request_irq() failed\\n\");\n\treturn rc;\n}\n\nstatic int temac_stop(struct net_device *ndev)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tstruct phy_device *phydev = ndev->phydev;\n\n\tdev_dbg(&ndev->dev, \"temac_close()\\n\");\n\n\tcancel_delayed_work_sync(&lp->restart_work);\n\n\tfree_irq(lp->tx_irq, ndev);\n\tfree_irq(lp->rx_irq, ndev);\n\n\tif (phydev)\n\t\tphy_disconnect(phydev);\n\n\ttemac_dma_bd_release(ndev);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void\ntemac_poll_controller(struct net_device *ndev)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\n\tdisable_irq(lp->tx_irq);\n\tdisable_irq(lp->rx_irq);\n\n\tll_temac_rx_irq(lp->tx_irq, ndev);\n\tll_temac_tx_irq(lp->rx_irq, ndev);\n\n\tenable_irq(lp->tx_irq);\n\tenable_irq(lp->rx_irq);\n}\n#endif\n\nstatic const struct net_device_ops temac_netdev_ops = {\n\t.ndo_open = temac_open,\n\t.ndo_stop = temac_stop,\n\t.ndo_start_xmit = temac_start_xmit,\n\t.ndo_set_rx_mode = temac_set_multicast_list,\n\t.ndo_set_mac_address = temac_set_mac_address,\n\t.ndo_validate_addr = eth_validate_addr,\n\t.ndo_do_ioctl = phy_do_ioctl_running,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller = temac_poll_controller,\n#endif\n};\n\n/* ---------------------------------------------------------------------\n * SYSFS device attributes\n */\nstatic ssize_t temac_show_llink_regs(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tint i, len = 0;\n\n\tfor (i = 0; i < 0x11; i++)\n\t\tlen += sprintf(buf + len, \"%.8x%s\", lp->dma_in(lp, i),\n\t\t\t       (i % 8) == 7 ? \"\\n\" : \" \");\n\tlen += sprintf(buf + len, \"\\n\");\n\n\treturn len;\n}\n\nstatic DEVICE_ATTR(llink_regs, 0440, temac_show_llink_regs, NULL);\n\nstatic struct attribute *temac_device_attrs[] = {\n\t&dev_attr_llink_regs.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group temac_attr_group = {\n\t.attrs = temac_device_attrs,\n};\n\n/* ---------------------------------------------------------------------\n * ethtool support\n */\n\nstatic void ll_temac_ethtools_get_ringparam(struct net_device *ndev,\n\t\t\t\t\t    struct ethtool_ringparam *ering)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\n\tering->rx_max_pending = RX_BD_NUM_MAX;\n\tering->rx_mini_max_pending = 0;\n\tering->rx_jumbo_max_pending = 0;\n\tering->tx_max_pending = TX_BD_NUM_MAX;\n\tering->rx_pending = lp->rx_bd_num;\n\tering->rx_mini_pending = 0;\n\tering->rx_jumbo_pending = 0;\n\tering->tx_pending = lp->tx_bd_num;\n}\n\nstatic int ll_temac_ethtools_set_ringparam(struct net_device *ndev,\n\t\t\t\t\t   struct ethtool_ringparam *ering)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\n\tif (ering->rx_pending > RX_BD_NUM_MAX ||\n\t    ering->rx_mini_pending ||\n\t    ering->rx_jumbo_pending ||\n\t    ering->rx_pending > TX_BD_NUM_MAX)\n\t\treturn -EINVAL;\n\n\tif (netif_running(ndev))\n\t\treturn -EBUSY;\n\n\tlp->rx_bd_num = ering->rx_pending;\n\tlp->tx_bd_num = ering->tx_pending;\n\treturn 0;\n}\n\nstatic int ll_temac_ethtools_get_coalesce(struct net_device *ndev,\n\t\t\t\t\t  struct ethtool_coalesce *ec)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\n\tec->rx_max_coalesced_frames = lp->coalesce_count_rx;\n\tec->tx_max_coalesced_frames = lp->coalesce_count_tx;\n\tec->rx_coalesce_usecs = (lp->coalesce_delay_rx * 512) / 100;\n\tec->tx_coalesce_usecs = (lp->coalesce_delay_tx * 512) / 100;\n\treturn 0;\n}\n\nstatic int ll_temac_ethtools_set_coalesce(struct net_device *ndev,\n\t\t\t\t\t  struct ethtool_coalesce *ec)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\n\tif (netif_running(ndev)) {\n\t\tnetdev_err(ndev,\n\t\t\t   \"Please stop netif before applying configuration\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (ec->rx_max_coalesced_frames)\n\t\tlp->coalesce_count_rx = ec->rx_max_coalesced_frames;\n\tif (ec->tx_max_coalesced_frames)\n\t\tlp->coalesce_count_tx = ec->tx_max_coalesced_frames;\n\t/* With typical LocalLink clock speed of 200 MHz and\n\t * C_PRESCALAR=1023, each delay count corresponds to 5.12 us.\n\t */\n\tif (ec->rx_coalesce_usecs)\n\t\tlp->coalesce_delay_rx =\n\t\t\tmin(255U, (ec->rx_coalesce_usecs * 100) / 512);\n\tif (ec->tx_coalesce_usecs)\n\t\tlp->coalesce_delay_tx =\n\t\t\tmin(255U, (ec->tx_coalesce_usecs * 100) / 512);\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops temac_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES,\n\t.nway_reset = phy_ethtool_nway_reset,\n\t.get_link = ethtool_op_get_link,\n\t.get_ts_info = ethtool_op_get_ts_info,\n\t.get_link_ksettings = phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings = phy_ethtool_set_link_ksettings,\n\t.get_ringparam\t= ll_temac_ethtools_get_ringparam,\n\t.set_ringparam\t= ll_temac_ethtools_set_ringparam,\n\t.get_coalesce\t= ll_temac_ethtools_get_coalesce,\n\t.set_coalesce\t= ll_temac_ethtools_set_coalesce,\n};\n\nstatic int temac_probe(struct platform_device *pdev)\n{\n\tstruct ll_temac_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct device_node *temac_np = dev_of_node(&pdev->dev), *dma_np;\n\tstruct temac_local *lp;\n\tstruct net_device *ndev;\n\tu8 addr[ETH_ALEN];\n\t__be32 *p;\n\tbool little_endian;\n\tint rc = 0;\n\n\t/* Init network device structure */\n\tndev = devm_alloc_etherdev(&pdev->dev, sizeof(*lp));\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, ndev);\n\tSET_NETDEV_DEV(ndev, &pdev->dev);\n\tndev->features = NETIF_F_SG;\n\tndev->netdev_ops = &temac_netdev_ops;\n\tndev->ethtool_ops = &temac_ethtool_ops;\n#if 0\n\tndev->features |= NETIF_F_IP_CSUM; /* Can checksum TCP/UDP over IPv4. */\n\tndev->features |= NETIF_F_HW_CSUM; /* Can checksum all the packets. */\n\tndev->features |= NETIF_F_IPV6_CSUM; /* Can checksum IPV6 TCP/UDP */\n\tndev->features |= NETIF_F_HIGHDMA; /* Can DMA to high memory. */\n\tndev->features |= NETIF_F_HW_VLAN_CTAG_TX; /* Transmit VLAN hw accel */\n\tndev->features |= NETIF_F_HW_VLAN_CTAG_RX; /* Receive VLAN hw acceleration */\n\tndev->features |= NETIF_F_HW_VLAN_CTAG_FILTER; /* Receive VLAN filtering */\n\tndev->features |= NETIF_F_VLAN_CHALLENGED; /* cannot handle VLAN pkts */\n\tndev->features |= NETIF_F_GSO; /* Enable software GSO. */\n\tndev->features |= NETIF_F_MULTI_QUEUE; /* Has multiple TX/RX queues */\n\tndev->features |= NETIF_F_LRO; /* large receive offload */\n#endif\n\n\t/* setup temac private info structure */\n\tlp = netdev_priv(ndev);\n\tlp->ndev = ndev;\n\tlp->dev = &pdev->dev;\n\tlp->options = XTE_OPTION_DEFAULTS;\n\tlp->rx_bd_num = RX_BD_NUM_DEFAULT;\n\tlp->tx_bd_num = TX_BD_NUM_DEFAULT;\n\tspin_lock_init(&lp->rx_lock);\n\tINIT_DELAYED_WORK(&lp->restart_work, ll_temac_restart_work_func);\n\n\t/* Setup mutex for synchronization of indirect register access */\n\tif (pdata) {\n\t\tif (!pdata->indirect_lock) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"indirect_lock missing in platform_data\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlp->indirect_lock = pdata->indirect_lock;\n\t} else {\n\t\tlp->indirect_lock = devm_kmalloc(&pdev->dev,\n\t\t\t\t\t\t sizeof(*lp->indirect_lock),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tspin_lock_init(lp->indirect_lock);\n\t}\n\n\t/* map device registers */\n\tlp->regs = devm_platform_ioremap_resource_byname(pdev, 0);\n\tif (IS_ERR(lp->regs)) {\n\t\tdev_err(&pdev->dev, \"could not map TEMAC registers\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Select register access functions with the specified\n\t * endianness mode.  Default for OF devices is big-endian.\n\t */\n\tlittle_endian = false;\n\tif (temac_np) {\n\t\tif (of_get_property(temac_np, \"little-endian\", NULL))\n\t\t\tlittle_endian = true;\n\t} else if (pdata) {\n\t\tlittle_endian = pdata->reg_little_endian;\n\t}\n\tif (little_endian) {\n\t\tlp->temac_ior = _temac_ior_le;\n\t\tlp->temac_iow = _temac_iow_le;\n\t} else {\n\t\tlp->temac_ior = _temac_ior_be;\n\t\tlp->temac_iow = _temac_iow_be;\n\t}\n\n\t/* Setup checksum offload, but default to off if not specified */\n\tlp->temac_features = 0;\n\tif (temac_np) {\n\t\tp = (__be32 *)of_get_property(temac_np, \"xlnx,txcsum\", NULL);\n\t\tif (p && be32_to_cpu(*p))\n\t\t\tlp->temac_features |= TEMAC_FEATURE_TX_CSUM;\n\t\tp = (__be32 *)of_get_property(temac_np, \"xlnx,rxcsum\", NULL);\n\t\tif (p && be32_to_cpu(*p))\n\t\t\tlp->temac_features |= TEMAC_FEATURE_RX_CSUM;\n\t} else if (pdata) {\n\t\tif (pdata->txcsum)\n\t\t\tlp->temac_features |= TEMAC_FEATURE_TX_CSUM;\n\t\tif (pdata->rxcsum)\n\t\t\tlp->temac_features |= TEMAC_FEATURE_RX_CSUM;\n\t}\n\tif (lp->temac_features & TEMAC_FEATURE_TX_CSUM)\n\t\t/* Can checksum TCP/UDP over IPv4. */\n\t\tndev->features |= NETIF_F_IP_CSUM;\n\n\t/* Defaults for IRQ delay/coalescing setup.  These are\n\t * configuration values, so does not belong in device-tree.\n\t */\n\tlp->coalesce_delay_tx = 0x10;\n\tlp->coalesce_count_tx = 0x22;\n\tlp->coalesce_delay_rx = 0xff;\n\tlp->coalesce_count_rx = 0x07;\n\n\t/* Setup LocalLink DMA */\n\tif (temac_np) {\n\t\t/* Find the DMA node, map the DMA registers, and\n\t\t * decode the DMA IRQs.\n\t\t */\n\t\tdma_np = of_parse_phandle(temac_np, \"llink-connected\", 0);\n\t\tif (!dma_np) {\n\t\t\tdev_err(&pdev->dev, \"could not find DMA node\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t/* Setup the DMA register accesses, could be DCR or\n\t\t * memory mapped.\n\t\t */\n\t\tif (temac_dcr_setup(lp, pdev, dma_np)) {\n\t\t\t/* no DCR in the device tree, try non-DCR */\n\t\t\tlp->sdma_regs = devm_of_iomap(&pdev->dev, dma_np, 0,\n\t\t\t\t\t\t      NULL);\n\t\t\tif (IS_ERR(lp->sdma_regs)) {\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"unable to map DMA registers\\n\");\n\t\t\t\tof_node_put(dma_np);\n\t\t\t\treturn PTR_ERR(lp->sdma_regs);\n\t\t\t}\n\t\t\tif (of_get_property(dma_np, \"little-endian\", NULL)) {\n\t\t\t\tlp->dma_in = temac_dma_in32_le;\n\t\t\t\tlp->dma_out = temac_dma_out32_le;\n\t\t\t} else {\n\t\t\t\tlp->dma_in = temac_dma_in32_be;\n\t\t\t\tlp->dma_out = temac_dma_out32_be;\n\t\t\t}\n\t\t\tdev_dbg(&pdev->dev, \"MEM base: %p\\n\", lp->sdma_regs);\n\t\t}\n\n\t\t/* Get DMA RX and TX interrupts */\n\t\tlp->rx_irq = irq_of_parse_and_map(dma_np, 0);\n\t\tlp->tx_irq = irq_of_parse_and_map(dma_np, 1);\n\n\t\t/* Finished with the DMA node; drop the reference */\n\t\tof_node_put(dma_np);\n\t} else if (pdata) {\n\t\t/* 2nd memory resource specifies DMA registers */\n\t\tlp->sdma_regs = devm_platform_ioremap_resource(pdev, 1);\n\t\tif (IS_ERR(lp->sdma_regs)) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"could not map DMA registers\\n\");\n\t\t\treturn PTR_ERR(lp->sdma_regs);\n\t\t}\n\t\tif (pdata->dma_little_endian) {\n\t\t\tlp->dma_in = temac_dma_in32_le;\n\t\t\tlp->dma_out = temac_dma_out32_le;\n\t\t} else {\n\t\t\tlp->dma_in = temac_dma_in32_be;\n\t\t\tlp->dma_out = temac_dma_out32_be;\n\t\t}\n\n\t\t/* Get DMA RX and TX interrupts */\n\t\tlp->rx_irq = platform_get_irq(pdev, 0);\n\t\tlp->tx_irq = platform_get_irq(pdev, 1);\n\n\t\t/* IRQ delay/coalescing setup */\n\t\tif (pdata->tx_irq_timeout || pdata->tx_irq_count) {\n\t\t\tlp->coalesce_delay_tx = pdata->tx_irq_timeout;\n\t\t\tlp->coalesce_count_tx = pdata->tx_irq_count;\n\t\t}\n\t\tif (pdata->rx_irq_timeout || pdata->rx_irq_count) {\n\t\t\tlp->coalesce_delay_rx = pdata->rx_irq_timeout;\n\t\t\tlp->coalesce_count_rx = pdata->rx_irq_count;\n\t\t}\n\t}\n\n\t/* Error handle returned DMA RX and TX interrupts */\n\tif (lp->rx_irq < 0) {\n\t\tif (lp->rx_irq != -EPROBE_DEFER)\n\t\t\tdev_err(&pdev->dev, \"could not get DMA RX irq\\n\");\n\t\treturn lp->rx_irq;\n\t}\n\tif (lp->tx_irq < 0) {\n\t\tif (lp->tx_irq != -EPROBE_DEFER)\n\t\t\tdev_err(&pdev->dev, \"could not get DMA TX irq\\n\");\n\t\treturn lp->tx_irq;\n\t}\n\n\tif (temac_np) {\n\t\t/* Retrieve the MAC address */\n\t\trc = of_get_mac_address(temac_np, addr);\n\t\tif (rc) {\n\t\t\tdev_err(&pdev->dev, \"could not find MAC address\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\ttemac_init_mac_address(ndev, addr);\n\t} else if (pdata) {\n\t\ttemac_init_mac_address(ndev, pdata->mac_addr);\n\t}\n\n\trc = temac_mdio_setup(lp, pdev);\n\tif (rc)\n\t\tdev_warn(&pdev->dev, \"error registering MDIO bus\\n\");\n\n\tif (temac_np) {\n\t\tlp->phy_node = of_parse_phandle(temac_np, \"phy-handle\", 0);\n\t\tif (lp->phy_node)\n\t\t\tdev_dbg(lp->dev, \"using PHY node %pOF\\n\", temac_np);\n\t} else if (pdata) {\n\t\tsnprintf(lp->phy_name, sizeof(lp->phy_name),\n\t\t\t PHY_ID_FMT, lp->mii_bus->id, pdata->phy_addr);\n\t\tlp->phy_interface = pdata->phy_interface;\n\t}\n\n\t/* Add the device attributes */\n\trc = sysfs_create_group(&lp->dev->kobj, &temac_attr_group);\n\tif (rc) {\n\t\tdev_err(lp->dev, \"Error creating sysfs files\\n\");\n\t\tgoto err_sysfs_create;\n\t}\n\n\trc = register_netdev(lp->ndev);\n\tif (rc) {\n\t\tdev_err(lp->dev, \"register_netdev() error (%i)\\n\", rc);\n\t\tgoto err_register_ndev;\n\t}\n\n\treturn 0;\n\nerr_register_ndev:\n\tsysfs_remove_group(&lp->dev->kobj, &temac_attr_group);\nerr_sysfs_create:\n\tif (lp->phy_node)\n\t\tof_node_put(lp->phy_node);\n\ttemac_mdio_teardown(lp);\n\treturn rc;\n}\n\nstatic int temac_remove(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct temac_local *lp = netdev_priv(ndev);\n\n\tunregister_netdev(ndev);\n\tsysfs_remove_group(&lp->dev->kobj, &temac_attr_group);\n\tif (lp->phy_node)\n\t\tof_node_put(lp->phy_node);\n\ttemac_mdio_teardown(lp);\n\treturn 0;\n}\n\nstatic const struct of_device_id temac_of_match[] = {\n\t{ .compatible = \"xlnx,xps-ll-temac-1.01.b\", },\n\t{ .compatible = \"xlnx,xps-ll-temac-2.00.a\", },\n\t{ .compatible = \"xlnx,xps-ll-temac-2.02.a\", },\n\t{ .compatible = \"xlnx,xps-ll-temac-2.03.a\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, temac_of_match);\n\nstatic struct platform_driver temac_driver = {\n\t.probe = temac_probe,\n\t.remove = temac_remove,\n\t.driver = {\n\t\t.name = \"xilinx_temac\",\n\t\t.of_match_table = temac_of_match,\n\t},\n};\n\nmodule_platform_driver(temac_driver);\n\nMODULE_DESCRIPTION(\"Xilinx LL_TEMAC Ethernet driver\");\nMODULE_AUTHOR(\"Yoshio Kashiwagi\");\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Driver for Xilinx TEMAC Ethernet device\n *\n * Copyright (c) 2008 Nissin Systems Co., Ltd.,  Yoshio Kashiwagi\n * Copyright (c) 2005-2008 DLA Systems,  David H. Lynch Jr. <dhlii@dlasys.net>\n * Copyright (c) 2008-2009 Secret Lab Technologies Ltd.\n *\n * This is a driver for the Xilinx ll_temac ipcore which is often used\n * in the Virtex and Spartan series of chips.\n *\n * Notes:\n * - The ll_temac hardware uses indirect access for many of the TEMAC\n *   registers, include the MDIO bus.  However, indirect access to MDIO\n *   registers take considerably more clock cycles than to TEMAC registers.\n *   MDIO accesses are long, so threads doing them should probably sleep\n *   rather than busywait.  However, since only one indirect access can be\n *   in progress at any given time, that means that *all* indirect accesses\n *   could end up sleeping (to wait for an MDIO access to complete).\n *   Fortunately none of the indirect accesses are on the 'hot' path for tx\n *   or rx, so this should be okay.\n *\n * TODO:\n * - Factor out locallink DMA code into separate driver\n * - Fix support for hardware checksumming.\n * - Testing.  Lots and lots of testing.\n *\n */\n\n#include <linux/delay.h>\n#include <linux/etherdevice.h>\n#include <linux/mii.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/netdevice.h>\n#include <linux/if_ether.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_irq.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/of_platform.h>\n#include <linux/of_address.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/tcp.h>      /* needed for sizeof(tcphdr) */\n#include <linux/udp.h>      /* needed for sizeof(udphdr) */\n#include <linux/phy.h>\n#include <linux/in.h>\n#include <linux/io.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/workqueue.h>\n#include <linux/dma-mapping.h>\n#include <linux/processor.h>\n#include <linux/platform_data/xilinx-ll-temac.h>\n\n#include \"ll_temac.h\"\n\n/* Descriptors defines for Tx and Rx DMA */\n#define TX_BD_NUM_DEFAULT\t\t64\n#define RX_BD_NUM_DEFAULT\t\t1024\n#define TX_BD_NUM_MAX\t\t\t4096\n#define RX_BD_NUM_MAX\t\t\t4096\n\n/* ---------------------------------------------------------------------\n * Low level register access functions\n */\n\nstatic u32 _temac_ior_be(struct temac_local *lp, int offset)\n{\n\treturn ioread32be(lp->regs + offset);\n}\n\nstatic void _temac_iow_be(struct temac_local *lp, int offset, u32 value)\n{\n\treturn iowrite32be(value, lp->regs + offset);\n}\n\nstatic u32 _temac_ior_le(struct temac_local *lp, int offset)\n{\n\treturn ioread32(lp->regs + offset);\n}\n\nstatic void _temac_iow_le(struct temac_local *lp, int offset, u32 value)\n{\n\treturn iowrite32(value, lp->regs + offset);\n}\n\nstatic bool hard_acs_rdy(struct temac_local *lp)\n{\n\treturn temac_ior(lp, XTE_RDY0_OFFSET) & XTE_RDY0_HARD_ACS_RDY_MASK;\n}\n\nstatic bool hard_acs_rdy_or_timeout(struct temac_local *lp, ktime_t timeout)\n{\n\tktime_t cur = ktime_get();\n\n\treturn hard_acs_rdy(lp) || ktime_after(cur, timeout);\n}\n\n/* Poll for maximum 20 ms.  This is similar to the 2 jiffies @ 100 Hz\n * that was used before, and should cover MDIO bus speed down to 3200\n * Hz.\n */\n#define HARD_ACS_RDY_POLL_NS (20 * NSEC_PER_MSEC)\n\n/*\n * temac_indirect_busywait - Wait for current indirect register access\n * to complete.\n */\nint temac_indirect_busywait(struct temac_local *lp)\n{\n\tktime_t timeout = ktime_add_ns(ktime_get(), HARD_ACS_RDY_POLL_NS);\n\n\tspin_until_cond(hard_acs_rdy_or_timeout(lp, timeout));\n\tif (WARN_ON(!hard_acs_rdy(lp)))\n\t\treturn -ETIMEDOUT;\n\telse\n\t\treturn 0;\n}\n\n/*\n * temac_indirect_in32 - Indirect register read access.  This function\n * must be called without lp->indirect_lock being held.\n */\nu32 temac_indirect_in32(struct temac_local *lp, int reg)\n{\n\tunsigned long flags;\n\tint val;\n\n\tspin_lock_irqsave(lp->indirect_lock, flags);\n\tval = temac_indirect_in32_locked(lp, reg);\n\tspin_unlock_irqrestore(lp->indirect_lock, flags);\n\treturn val;\n}\n\n/*\n * temac_indirect_in32_locked - Indirect register read access.  This\n * function must be called with lp->indirect_lock being held.  Use\n * this together with spin_lock_irqsave/spin_lock_irqrestore to avoid\n * repeated lock/unlock and to ensure uninterrupted access to indirect\n * registers.\n */\nu32 temac_indirect_in32_locked(struct temac_local *lp, int reg)\n{\n\t/* This initial wait should normally not spin, as we always\n\t * try to wait for indirect access to complete before\n\t * releasing the indirect_lock.\n\t */\n\tif (WARN_ON(temac_indirect_busywait(lp)))\n\t\treturn -ETIMEDOUT;\n\t/* Initiate read from indirect register */\n\ttemac_iow(lp, XTE_CTL0_OFFSET, reg);\n\t/* Wait for indirect register access to complete.  We really\n\t * should not see timeouts, and could even end up causing\n\t * problem for following indirect access, so let's make a bit\n\t * of WARN noise.\n\t */\n\tif (WARN_ON(temac_indirect_busywait(lp)))\n\t\treturn -ETIMEDOUT;\n\t/* Value is ready now */\n\treturn temac_ior(lp, XTE_LSW0_OFFSET);\n}\n\n/*\n * temac_indirect_out32 - Indirect register write access.  This function\n * must be called without lp->indirect_lock being held.\n */\nvoid temac_indirect_out32(struct temac_local *lp, int reg, u32 value)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(lp->indirect_lock, flags);\n\ttemac_indirect_out32_locked(lp, reg, value);\n\tspin_unlock_irqrestore(lp->indirect_lock, flags);\n}\n\n/*\n * temac_indirect_out32_locked - Indirect register write access.  This\n * function must be called with lp->indirect_lock being held.  Use\n * this together with spin_lock_irqsave/spin_lock_irqrestore to avoid\n * repeated lock/unlock and to ensure uninterrupted access to indirect\n * registers.\n */\nvoid temac_indirect_out32_locked(struct temac_local *lp, int reg, u32 value)\n{\n\t/* As in temac_indirect_in32_locked(), we should normally not\n\t * spin here.  And if it happens, we actually end up silently\n\t * ignoring the write request.  Ouch.\n\t */\n\tif (WARN_ON(temac_indirect_busywait(lp)))\n\t\treturn;\n\t/* Initiate write to indirect register */\n\ttemac_iow(lp, XTE_LSW0_OFFSET, value);\n\ttemac_iow(lp, XTE_CTL0_OFFSET, CNTLREG_WRITE_ENABLE_MASK | reg);\n\t/* As in temac_indirect_in32_locked(), we should not see timeouts\n\t * here.  And if it happens, we continue before the write has\n\t * completed.  Not good.\n\t */\n\tWARN_ON(temac_indirect_busywait(lp));\n}\n\n/*\n * temac_dma_in32_* - Memory mapped DMA read, these function expects a\n * register input that is based on DCR word addresses which are then\n * converted to memory mapped byte addresses.  To be assigned to\n * lp->dma_in32.\n */\nstatic u32 temac_dma_in32_be(struct temac_local *lp, int reg)\n{\n\treturn ioread32be(lp->sdma_regs + (reg << 2));\n}\n\nstatic u32 temac_dma_in32_le(struct temac_local *lp, int reg)\n{\n\treturn ioread32(lp->sdma_regs + (reg << 2));\n}\n\n/*\n * temac_dma_out32_* - Memory mapped DMA read, these function expects\n * a register input that is based on DCR word addresses which are then\n * converted to memory mapped byte addresses.  To be assigned to\n * lp->dma_out32.\n */\nstatic void temac_dma_out32_be(struct temac_local *lp, int reg, u32 value)\n{\n\tiowrite32be(value, lp->sdma_regs + (reg << 2));\n}\n\nstatic void temac_dma_out32_le(struct temac_local *lp, int reg, u32 value)\n{\n\tiowrite32(value, lp->sdma_regs + (reg << 2));\n}\n\n/* DMA register access functions can be DCR based or memory mapped.\n * The PowerPC 440 is DCR based, the PowerPC 405 and MicroBlaze are both\n * memory mapped.\n */\n#ifdef CONFIG_PPC_DCR\n\n/*\n * temac_dma_dcr_in32 - DCR based DMA read\n */\nstatic u32 temac_dma_dcr_in(struct temac_local *lp, int reg)\n{\n\treturn dcr_read(lp->sdma_dcrs, reg);\n}\n\n/*\n * temac_dma_dcr_out32 - DCR based DMA write\n */\nstatic void temac_dma_dcr_out(struct temac_local *lp, int reg, u32 value)\n{\n\tdcr_write(lp->sdma_dcrs, reg, value);\n}\n\n/*\n * temac_dcr_setup - If the DMA is DCR based, then setup the address and\n * I/O  functions\n */\nstatic int temac_dcr_setup(struct temac_local *lp, struct platform_device *op,\n\t\t\t\tstruct device_node *np)\n{\n\tunsigned int dcrs;\n\n\t/* setup the dcr address mapping if it's in the device tree */\n\n\tdcrs = dcr_resource_start(np, 0);\n\tif (dcrs != 0) {\n\t\tlp->sdma_dcrs = dcr_map(np, dcrs, dcr_resource_len(np, 0));\n\t\tlp->dma_in = temac_dma_dcr_in;\n\t\tlp->dma_out = temac_dma_dcr_out;\n\t\tdev_dbg(&op->dev, \"DCR base: %x\\n\", dcrs);\n\t\treturn 0;\n\t}\n\t/* no DCR in the device tree, indicate a failure */\n\treturn -1;\n}\n\n#else\n\n/*\n * temac_dcr_setup - This is a stub for when DCR is not supported,\n * such as with MicroBlaze and x86\n */\nstatic int temac_dcr_setup(struct temac_local *lp, struct platform_device *op,\n\t\t\t\tstruct device_node *np)\n{\n\treturn -1;\n}\n\n#endif\n\n/*\n * temac_dma_bd_release - Release buffer descriptor rings\n */\nstatic void temac_dma_bd_release(struct net_device *ndev)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tint i;\n\n\t/* Reset Local Link (DMA) */\n\tlp->dma_out(lp, DMA_CONTROL_REG, DMA_CONTROL_RST);\n\n\tfor (i = 0; i < lp->rx_bd_num; i++) {\n\t\tif (!lp->rx_skb[i])\n\t\t\tbreak;\n\t\telse {\n\t\t\tdma_unmap_single(ndev->dev.parent, lp->rx_bd_v[i].phys,\n\t\t\t\t\tXTE_MAX_JUMBO_FRAME_SIZE, DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb(lp->rx_skb[i]);\n\t\t}\n\t}\n\tif (lp->rx_bd_v)\n\t\tdma_free_coherent(ndev->dev.parent,\n\t\t\t\t  sizeof(*lp->rx_bd_v) * lp->rx_bd_num,\n\t\t\t\t  lp->rx_bd_v, lp->rx_bd_p);\n\tif (lp->tx_bd_v)\n\t\tdma_free_coherent(ndev->dev.parent,\n\t\t\t\t  sizeof(*lp->tx_bd_v) * lp->tx_bd_num,\n\t\t\t\t  lp->tx_bd_v, lp->tx_bd_p);\n}\n\n/*\n * temac_dma_bd_init - Setup buffer descriptor rings\n */\nstatic int temac_dma_bd_init(struct net_device *ndev)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tstruct sk_buff *skb;\n\tdma_addr_t skb_dma_addr;\n\tint i;\n\n\tlp->rx_skb = devm_kcalloc(&ndev->dev, lp->rx_bd_num,\n\t\t\t\t  sizeof(*lp->rx_skb), GFP_KERNEL);\n\tif (!lp->rx_skb)\n\t\tgoto out;\n\n\t/* allocate the tx and rx ring buffer descriptors. */\n\t/* returns a virtual address and a physical address. */\n\tlp->tx_bd_v = dma_alloc_coherent(ndev->dev.parent,\n\t\t\t\t\t sizeof(*lp->tx_bd_v) * lp->tx_bd_num,\n\t\t\t\t\t &lp->tx_bd_p, GFP_KERNEL);\n\tif (!lp->tx_bd_v)\n\t\tgoto out;\n\n\tlp->rx_bd_v = dma_alloc_coherent(ndev->dev.parent,\n\t\t\t\t\t sizeof(*lp->rx_bd_v) * lp->rx_bd_num,\n\t\t\t\t\t &lp->rx_bd_p, GFP_KERNEL);\n\tif (!lp->rx_bd_v)\n\t\tgoto out;\n\n\tfor (i = 0; i < lp->tx_bd_num; i++) {\n\t\tlp->tx_bd_v[i].next = cpu_to_be32(lp->tx_bd_p\n\t\t\t+ sizeof(*lp->tx_bd_v) * ((i + 1) % lp->tx_bd_num));\n\t}\n\n\tfor (i = 0; i < lp->rx_bd_num; i++) {\n\t\tlp->rx_bd_v[i].next = cpu_to_be32(lp->rx_bd_p\n\t\t\t+ sizeof(*lp->rx_bd_v) * ((i + 1) % lp->rx_bd_num));\n\n\t\tskb = netdev_alloc_skb_ip_align(ndev,\n\t\t\t\t\t\tXTE_MAX_JUMBO_FRAME_SIZE);\n\t\tif (!skb)\n\t\t\tgoto out;\n\n\t\tlp->rx_skb[i] = skb;\n\t\t/* returns physical address of skb->data */\n\t\tskb_dma_addr = dma_map_single(ndev->dev.parent, skb->data,\n\t\t\t\t\t      XTE_MAX_JUMBO_FRAME_SIZE,\n\t\t\t\t\t      DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(ndev->dev.parent, skb_dma_addr))\n\t\t\tgoto out;\n\t\tlp->rx_bd_v[i].phys = cpu_to_be32(skb_dma_addr);\n\t\tlp->rx_bd_v[i].len = cpu_to_be32(XTE_MAX_JUMBO_FRAME_SIZE);\n\t\tlp->rx_bd_v[i].app0 = cpu_to_be32(STS_CTRL_APP0_IRQONEND);\n\t}\n\n\t/* Configure DMA channel (irq setup) */\n\tlp->dma_out(lp, TX_CHNL_CTRL,\n\t\t    lp->coalesce_delay_tx << 24 | lp->coalesce_count_tx << 16 |\n\t\t    0x00000400 | // Use 1 Bit Wide Counters. Currently Not Used!\n\t\t    CHNL_CTRL_IRQ_EN | CHNL_CTRL_IRQ_ERR_EN |\n\t\t    CHNL_CTRL_IRQ_DLY_EN | CHNL_CTRL_IRQ_COAL_EN);\n\tlp->dma_out(lp, RX_CHNL_CTRL,\n\t\t    lp->coalesce_delay_rx << 24 | lp->coalesce_count_rx << 16 |\n\t\t    CHNL_CTRL_IRQ_IOE |\n\t\t    CHNL_CTRL_IRQ_EN | CHNL_CTRL_IRQ_ERR_EN |\n\t\t    CHNL_CTRL_IRQ_DLY_EN | CHNL_CTRL_IRQ_COAL_EN);\n\n\t/* Init descriptor indexes */\n\tlp->tx_bd_ci = 0;\n\tlp->tx_bd_tail = 0;\n\tlp->rx_bd_ci = 0;\n\tlp->rx_bd_tail = lp->rx_bd_num - 1;\n\n\t/* Enable RX DMA transfers */\n\twmb();\n\tlp->dma_out(lp, RX_CURDESC_PTR,  lp->rx_bd_p);\n\tlp->dma_out(lp, RX_TAILDESC_PTR,\n\t\t       lp->rx_bd_p + (sizeof(*lp->rx_bd_v) * lp->rx_bd_tail));\n\n\t/* Prepare for TX DMA transfer */\n\tlp->dma_out(lp, TX_CURDESC_PTR, lp->tx_bd_p);\n\n\treturn 0;\n\nout:\n\ttemac_dma_bd_release(ndev);\n\treturn -ENOMEM;\n}\n\n/* ---------------------------------------------------------------------\n * net_device_ops\n */\n\nstatic void temac_do_set_mac_address(struct net_device *ndev)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tunsigned long flags;\n\n\t/* set up unicast MAC address filter set its mac address */\n\tspin_lock_irqsave(lp->indirect_lock, flags);\n\ttemac_indirect_out32_locked(lp, XTE_UAW0_OFFSET,\n\t\t\t\t    (ndev->dev_addr[0]) |\n\t\t\t\t    (ndev->dev_addr[1] << 8) |\n\t\t\t\t    (ndev->dev_addr[2] << 16) |\n\t\t\t\t    (ndev->dev_addr[3] << 24));\n\t/* There are reserved bits in EUAW1\n\t * so don't affect them Set MAC bits [47:32] in EUAW1 */\n\ttemac_indirect_out32_locked(lp, XTE_UAW1_OFFSET,\n\t\t\t\t    (ndev->dev_addr[4] & 0x000000ff) |\n\t\t\t\t    (ndev->dev_addr[5] << 8));\n\tspin_unlock_irqrestore(lp->indirect_lock, flags);\n}\n\nstatic int temac_init_mac_address(struct net_device *ndev, const void *address)\n{\n\tmemcpy(ndev->dev_addr, address, ETH_ALEN);\n\tif (!is_valid_ether_addr(ndev->dev_addr))\n\t\teth_hw_addr_random(ndev);\n\ttemac_do_set_mac_address(ndev);\n\treturn 0;\n}\n\nstatic int temac_set_mac_address(struct net_device *ndev, void *p)\n{\n\tstruct sockaddr *addr = p;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\tmemcpy(ndev->dev_addr, addr->sa_data, ETH_ALEN);\n\ttemac_do_set_mac_address(ndev);\n\treturn 0;\n}\n\nstatic void temac_set_multicast_list(struct net_device *ndev)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tu32 multi_addr_msw, multi_addr_lsw;\n\tint i = 0;\n\tunsigned long flags;\n\tbool promisc_mode_disabled = false;\n\n\tif (ndev->flags & (IFF_PROMISC | IFF_ALLMULTI) ||\n\t    (netdev_mc_count(ndev) > MULTICAST_CAM_TABLE_NUM)) {\n\t\ttemac_indirect_out32(lp, XTE_AFM_OFFSET, XTE_AFM_EPPRM_MASK);\n\t\tdev_info(&ndev->dev, \"Promiscuous mode enabled.\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(lp->indirect_lock, flags);\n\n\tif (!netdev_mc_empty(ndev)) {\n\t\tstruct netdev_hw_addr *ha;\n\n\t\tnetdev_for_each_mc_addr(ha, ndev) {\n\t\t\tif (WARN_ON(i >= MULTICAST_CAM_TABLE_NUM))\n\t\t\t\tbreak;\n\t\t\tmulti_addr_msw = ((ha->addr[3] << 24) |\n\t\t\t\t\t  (ha->addr[2] << 16) |\n\t\t\t\t\t  (ha->addr[1] << 8) |\n\t\t\t\t\t  (ha->addr[0]));\n\t\t\ttemac_indirect_out32_locked(lp, XTE_MAW0_OFFSET,\n\t\t\t\t\t\t    multi_addr_msw);\n\t\t\tmulti_addr_lsw = ((ha->addr[5] << 8) |\n\t\t\t\t\t  (ha->addr[4]) | (i << 16));\n\t\t\ttemac_indirect_out32_locked(lp, XTE_MAW1_OFFSET,\n\t\t\t\t\t\t    multi_addr_lsw);\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/* Clear all or remaining/unused address table entries */\n\twhile (i < MULTICAST_CAM_TABLE_NUM) {\n\t\ttemac_indirect_out32_locked(lp, XTE_MAW0_OFFSET, 0);\n\t\ttemac_indirect_out32_locked(lp, XTE_MAW1_OFFSET, i << 16);\n\t\ti++;\n\t}\n\n\t/* Enable address filter block if currently disabled */\n\tif (temac_indirect_in32_locked(lp, XTE_AFM_OFFSET)\n\t    & XTE_AFM_EPPRM_MASK) {\n\t\ttemac_indirect_out32_locked(lp, XTE_AFM_OFFSET, 0);\n\t\tpromisc_mode_disabled = true;\n\t}\n\n\tspin_unlock_irqrestore(lp->indirect_lock, flags);\n\n\tif (promisc_mode_disabled)\n\t\tdev_info(&ndev->dev, \"Promiscuous mode disabled.\\n\");\n}\n\nstatic struct temac_option {\n\tint flg;\n\tu32 opt;\n\tu32 reg;\n\tu32 m_or;\n\tu32 m_and;\n} temac_options[] = {\n\t/* Turn on jumbo packet support for both Rx and Tx */\n\t{\n\t\t.opt = XTE_OPTION_JUMBO,\n\t\t.reg = XTE_TXC_OFFSET,\n\t\t.m_or = XTE_TXC_TXJMBO_MASK,\n\t},\n\t{\n\t\t.opt = XTE_OPTION_JUMBO,\n\t\t.reg = XTE_RXC1_OFFSET,\n\t\t.m_or =XTE_RXC1_RXJMBO_MASK,\n\t},\n\t/* Turn on VLAN packet support for both Rx and Tx */\n\t{\n\t\t.opt = XTE_OPTION_VLAN,\n\t\t.reg = XTE_TXC_OFFSET,\n\t\t.m_or =XTE_TXC_TXVLAN_MASK,\n\t},\n\t{\n\t\t.opt = XTE_OPTION_VLAN,\n\t\t.reg = XTE_RXC1_OFFSET,\n\t\t.m_or =XTE_RXC1_RXVLAN_MASK,\n\t},\n\t/* Turn on FCS stripping on receive packets */\n\t{\n\t\t.opt = XTE_OPTION_FCS_STRIP,\n\t\t.reg = XTE_RXC1_OFFSET,\n\t\t.m_or =XTE_RXC1_RXFCS_MASK,\n\t},\n\t/* Turn on FCS insertion on transmit packets */\n\t{\n\t\t.opt = XTE_OPTION_FCS_INSERT,\n\t\t.reg = XTE_TXC_OFFSET,\n\t\t.m_or =XTE_TXC_TXFCS_MASK,\n\t},\n\t/* Turn on length/type field checking on receive packets */\n\t{\n\t\t.opt = XTE_OPTION_LENTYPE_ERR,\n\t\t.reg = XTE_RXC1_OFFSET,\n\t\t.m_or =XTE_RXC1_RXLT_MASK,\n\t},\n\t/* Turn on flow control */\n\t{\n\t\t.opt = XTE_OPTION_FLOW_CONTROL,\n\t\t.reg = XTE_FCC_OFFSET,\n\t\t.m_or =XTE_FCC_RXFLO_MASK,\n\t},\n\t/* Turn on flow control */\n\t{\n\t\t.opt = XTE_OPTION_FLOW_CONTROL,\n\t\t.reg = XTE_FCC_OFFSET,\n\t\t.m_or =XTE_FCC_TXFLO_MASK,\n\t},\n\t/* Turn on promiscuous frame filtering (all frames are received ) */\n\t{\n\t\t.opt = XTE_OPTION_PROMISC,\n\t\t.reg = XTE_AFM_OFFSET,\n\t\t.m_or =XTE_AFM_EPPRM_MASK,\n\t},\n\t/* Enable transmitter if not already enabled */\n\t{\n\t\t.opt = XTE_OPTION_TXEN,\n\t\t.reg = XTE_TXC_OFFSET,\n\t\t.m_or =XTE_TXC_TXEN_MASK,\n\t},\n\t/* Enable receiver? */\n\t{\n\t\t.opt = XTE_OPTION_RXEN,\n\t\t.reg = XTE_RXC1_OFFSET,\n\t\t.m_or =XTE_RXC1_RXEN_MASK,\n\t},\n\t{}\n};\n\n/*\n * temac_setoptions\n */\nstatic u32 temac_setoptions(struct net_device *ndev, u32 options)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tstruct temac_option *tp = &temac_options[0];\n\tint reg;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(lp->indirect_lock, flags);\n\twhile (tp->opt) {\n\t\treg = temac_indirect_in32_locked(lp, tp->reg) & ~tp->m_or;\n\t\tif (options & tp->opt) {\n\t\t\treg |= tp->m_or;\n\t\t\ttemac_indirect_out32_locked(lp, tp->reg, reg);\n\t\t}\n\t\ttp++;\n\t}\n\tspin_unlock_irqrestore(lp->indirect_lock, flags);\n\tlp->options |= options;\n\n\treturn 0;\n}\n\n/* Initialize temac */\nstatic void temac_device_reset(struct net_device *ndev)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tu32 timeout;\n\tu32 val;\n\tunsigned long flags;\n\n\t/* Perform a software reset */\n\n\t/* 0x300 host enable bit ? */\n\t/* reset PHY through control register ?:1 */\n\n\tdev_dbg(&ndev->dev, \"%s()\\n\", __func__);\n\n\t/* Reset the receiver and wait for it to finish reset */\n\ttemac_indirect_out32(lp, XTE_RXC1_OFFSET, XTE_RXC1_RXRST_MASK);\n\ttimeout = 1000;\n\twhile (temac_indirect_in32(lp, XTE_RXC1_OFFSET) & XTE_RXC1_RXRST_MASK) {\n\t\tudelay(1);\n\t\tif (--timeout == 0) {\n\t\t\tdev_err(&ndev->dev,\n\t\t\t\t\"temac_device_reset RX reset timeout!!\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Reset the transmitter and wait for it to finish reset */\n\ttemac_indirect_out32(lp, XTE_TXC_OFFSET, XTE_TXC_TXRST_MASK);\n\ttimeout = 1000;\n\twhile (temac_indirect_in32(lp, XTE_TXC_OFFSET) & XTE_TXC_TXRST_MASK) {\n\t\tudelay(1);\n\t\tif (--timeout == 0) {\n\t\t\tdev_err(&ndev->dev,\n\t\t\t\t\"temac_device_reset TX reset timeout!!\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Disable the receiver */\n\tspin_lock_irqsave(lp->indirect_lock, flags);\n\tval = temac_indirect_in32_locked(lp, XTE_RXC1_OFFSET);\n\ttemac_indirect_out32_locked(lp, XTE_RXC1_OFFSET,\n\t\t\t\t    val & ~XTE_RXC1_RXEN_MASK);\n\tspin_unlock_irqrestore(lp->indirect_lock, flags);\n\n\t/* Reset Local Link (DMA) */\n\tlp->dma_out(lp, DMA_CONTROL_REG, DMA_CONTROL_RST);\n\ttimeout = 1000;\n\twhile (lp->dma_in(lp, DMA_CONTROL_REG) & DMA_CONTROL_RST) {\n\t\tudelay(1);\n\t\tif (--timeout == 0) {\n\t\t\tdev_err(&ndev->dev,\n\t\t\t\t\"temac_device_reset DMA reset timeout!!\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tlp->dma_out(lp, DMA_CONTROL_REG, DMA_TAIL_ENABLE);\n\n\tif (temac_dma_bd_init(ndev)) {\n\t\tdev_err(&ndev->dev,\n\t\t\t\t\"temac_device_reset descriptor allocation failed\\n\");\n\t}\n\n\tspin_lock_irqsave(lp->indirect_lock, flags);\n\ttemac_indirect_out32_locked(lp, XTE_RXC0_OFFSET, 0);\n\ttemac_indirect_out32_locked(lp, XTE_RXC1_OFFSET, 0);\n\ttemac_indirect_out32_locked(lp, XTE_TXC_OFFSET, 0);\n\ttemac_indirect_out32_locked(lp, XTE_FCC_OFFSET, XTE_FCC_RXFLO_MASK);\n\tspin_unlock_irqrestore(lp->indirect_lock, flags);\n\n\t/* Sync default options with HW\n\t * but leave receiver and transmitter disabled.  */\n\ttemac_setoptions(ndev,\n\t\t\t lp->options & ~(XTE_OPTION_TXEN | XTE_OPTION_RXEN));\n\n\ttemac_do_set_mac_address(ndev);\n\n\t/* Set address filter table */\n\ttemac_set_multicast_list(ndev);\n\tif (temac_setoptions(ndev, lp->options))\n\t\tdev_err(&ndev->dev, \"Error setting TEMAC options\\n\");\n\n\t/* Init Driver variable */\n\tnetif_trans_update(ndev); /* prevent tx timeout */\n}\n\nstatic void temac_adjust_link(struct net_device *ndev)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tstruct phy_device *phy = ndev->phydev;\n\tu32 mii_speed;\n\tint link_state;\n\tunsigned long flags;\n\n\t/* hash together the state values to decide if something has changed */\n\tlink_state = phy->speed | (phy->duplex << 1) | phy->link;\n\n\tif (lp->last_link != link_state) {\n\t\tspin_lock_irqsave(lp->indirect_lock, flags);\n\t\tmii_speed = temac_indirect_in32_locked(lp, XTE_EMCFG_OFFSET);\n\t\tmii_speed &= ~XTE_EMCFG_LINKSPD_MASK;\n\n\t\tswitch (phy->speed) {\n\t\tcase SPEED_1000: mii_speed |= XTE_EMCFG_LINKSPD_1000; break;\n\t\tcase SPEED_100: mii_speed |= XTE_EMCFG_LINKSPD_100; break;\n\t\tcase SPEED_10: mii_speed |= XTE_EMCFG_LINKSPD_10; break;\n\t\t}\n\n\t\t/* Write new speed setting out to TEMAC */\n\t\ttemac_indirect_out32_locked(lp, XTE_EMCFG_OFFSET, mii_speed);\n\t\tspin_unlock_irqrestore(lp->indirect_lock, flags);\n\n\t\tlp->last_link = link_state;\n\t\tphy_print_status(phy);\n\t}\n}\n\n#ifdef CONFIG_64BIT\n\nstatic void ptr_to_txbd(void *p, struct cdmac_bd *bd)\n{\n\tbd->app3 = (u32)(((u64)p) >> 32);\n\tbd->app4 = (u32)((u64)p & 0xFFFFFFFF);\n}\n\nstatic void *ptr_from_txbd(struct cdmac_bd *bd)\n{\n\treturn (void *)(((u64)(bd->app3) << 32) | bd->app4);\n}\n\n#else\n\nstatic void ptr_to_txbd(void *p, struct cdmac_bd *bd)\n{\n\tbd->app4 = (u32)p;\n}\n\nstatic void *ptr_from_txbd(struct cdmac_bd *bd)\n{\n\treturn (void *)(bd->app4);\n}\n\n#endif\n\nstatic void temac_start_xmit_done(struct net_device *ndev)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tstruct cdmac_bd *cur_p;\n\tunsigned int stat = 0;\n\tstruct sk_buff *skb;\n\n\tcur_p = &lp->tx_bd_v[lp->tx_bd_ci];\n\tstat = be32_to_cpu(cur_p->app0);\n\n\twhile (stat & STS_CTRL_APP0_CMPLT) {\n\t\t/* Make sure that the other fields are read after bd is\n\t\t * released by dma\n\t\t */\n\t\trmb();\n\t\tdma_unmap_single(ndev->dev.parent, be32_to_cpu(cur_p->phys),\n\t\t\t\t be32_to_cpu(cur_p->len), DMA_TO_DEVICE);\n\t\tskb = (struct sk_buff *)ptr_from_txbd(cur_p);\n\t\tif (skb)\n\t\t\tdev_consume_skb_irq(skb);\n\t\tcur_p->app1 = 0;\n\t\tcur_p->app2 = 0;\n\t\tcur_p->app3 = 0;\n\t\tcur_p->app4 = 0;\n\n\t\tndev->stats.tx_packets++;\n\t\tndev->stats.tx_bytes += be32_to_cpu(cur_p->len);\n\n\t\t/* app0 must be visible last, as it is used to flag\n\t\t * availability of the bd\n\t\t */\n\t\tsmp_mb();\n\t\tcur_p->app0 = 0;\n\n\t\tlp->tx_bd_ci++;\n\t\tif (lp->tx_bd_ci >= lp->tx_bd_num)\n\t\t\tlp->tx_bd_ci = 0;\n\n\t\tcur_p = &lp->tx_bd_v[lp->tx_bd_ci];\n\t\tstat = be32_to_cpu(cur_p->app0);\n\t}\n\n\t/* Matches barrier in temac_start_xmit */\n\tsmp_mb();\n\n\tnetif_wake_queue(ndev);\n}\n\nstatic inline int temac_check_tx_bd_space(struct temac_local *lp, int num_frag)\n{\n\tstruct cdmac_bd *cur_p;\n\tint tail;\n\n\ttail = lp->tx_bd_tail;\n\tcur_p = &lp->tx_bd_v[tail];\n\n\tdo {\n\t\tif (cur_p->app0)\n\t\t\treturn NETDEV_TX_BUSY;\n\n\t\t/* Make sure to read next bd app0 after this one */\n\t\trmb();\n\n\t\ttail++;\n\t\tif (tail >= lp->tx_bd_num)\n\t\t\ttail = 0;\n\n\t\tcur_p = &lp->tx_bd_v[tail];\n\t\tnum_frag--;\n\t} while (num_frag >= 0);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t\ntemac_start_xmit(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tstruct cdmac_bd *cur_p;\n\tdma_addr_t tail_p, skb_dma_addr;\n\tint ii;\n\tunsigned long num_frag;\n\tskb_frag_t *frag;\n\n\tnum_frag = skb_shinfo(skb)->nr_frags;\n\tfrag = &skb_shinfo(skb)->frags[0];\n\tcur_p = &lp->tx_bd_v[lp->tx_bd_tail];\n\n\tif (temac_check_tx_bd_space(lp, num_frag + 1)) {\n\t\tif (netif_queue_stopped(ndev))\n\t\t\treturn NETDEV_TX_BUSY;\n\n\t\tnetif_stop_queue(ndev);\n\n\t\t/* Matches barrier in temac_start_xmit_done */\n\t\tsmp_mb();\n\n\t\t/* Space might have just been freed - check again */\n\t\tif (temac_check_tx_bd_space(lp, num_frag + 1))\n\t\t\treturn NETDEV_TX_BUSY;\n\n\t\tnetif_wake_queue(ndev);\n\t}\n\n\tcur_p->app0 = 0;\n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\tunsigned int csum_start_off = skb_checksum_start_offset(skb);\n\t\tunsigned int csum_index_off = csum_start_off + skb->csum_offset;\n\n\t\tcur_p->app0 |= cpu_to_be32(0x000001); /* TX Checksum Enabled */\n\t\tcur_p->app1 = cpu_to_be32((csum_start_off << 16)\n\t\t\t\t\t  | csum_index_off);\n\t\tcur_p->app2 = 0;  /* initial checksum seed */\n\t}\n\n\tcur_p->app0 |= cpu_to_be32(STS_CTRL_APP0_SOP);\n\tskb_dma_addr = dma_map_single(ndev->dev.parent, skb->data,\n\t\t\t\t      skb_headlen(skb), DMA_TO_DEVICE);\n\tcur_p->len = cpu_to_be32(skb_headlen(skb));\n\tif (WARN_ON_ONCE(dma_mapping_error(ndev->dev.parent, skb_dma_addr))) {\n\t\tdev_kfree_skb_any(skb);\n\t\tndev->stats.tx_dropped++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\tcur_p->phys = cpu_to_be32(skb_dma_addr);\n\n\tfor (ii = 0; ii < num_frag; ii++) {\n\t\tif (++lp->tx_bd_tail >= lp->tx_bd_num)\n\t\t\tlp->tx_bd_tail = 0;\n\n\t\tcur_p = &lp->tx_bd_v[lp->tx_bd_tail];\n\t\tskb_dma_addr = dma_map_single(ndev->dev.parent,\n\t\t\t\t\t      skb_frag_address(frag),\n\t\t\t\t\t      skb_frag_size(frag),\n\t\t\t\t\t      DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(ndev->dev.parent, skb_dma_addr)) {\n\t\t\tif (--lp->tx_bd_tail < 0)\n\t\t\t\tlp->tx_bd_tail = lp->tx_bd_num - 1;\n\t\t\tcur_p = &lp->tx_bd_v[lp->tx_bd_tail];\n\t\t\twhile (--ii >= 0) {\n\t\t\t\t--frag;\n\t\t\t\tdma_unmap_single(ndev->dev.parent,\n\t\t\t\t\t\t be32_to_cpu(cur_p->phys),\n\t\t\t\t\t\t skb_frag_size(frag),\n\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\t\tif (--lp->tx_bd_tail < 0)\n\t\t\t\t\tlp->tx_bd_tail = lp->tx_bd_num - 1;\n\t\t\t\tcur_p = &lp->tx_bd_v[lp->tx_bd_tail];\n\t\t\t}\n\t\t\tdma_unmap_single(ndev->dev.parent,\n\t\t\t\t\t be32_to_cpu(cur_p->phys),\n\t\t\t\t\t skb_headlen(skb), DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tndev->stats.tx_dropped++;\n\t\t\treturn NETDEV_TX_OK;\n\t\t}\n\t\tcur_p->phys = cpu_to_be32(skb_dma_addr);\n\t\tcur_p->len = cpu_to_be32(skb_frag_size(frag));\n\t\tcur_p->app0 = 0;\n\t\tfrag++;\n\t}\n\tcur_p->app0 |= cpu_to_be32(STS_CTRL_APP0_EOP);\n\n\t/* Mark last fragment with skb address, so it can be consumed\n\t * in temac_start_xmit_done()\n\t */\n\tptr_to_txbd((void *)skb, cur_p);\n\n\ttail_p = lp->tx_bd_p + sizeof(*lp->tx_bd_v) * lp->tx_bd_tail;\n\tlp->tx_bd_tail++;\n\tif (lp->tx_bd_tail >= lp->tx_bd_num)\n\t\tlp->tx_bd_tail = 0;\n\n\tskb_tx_timestamp(skb);\n\n\t/* Kick off the transfer */\n\twmb();\n\tlp->dma_out(lp, TX_TAILDESC_PTR, tail_p); /* DMA start */\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int ll_temac_recv_buffers_available(struct temac_local *lp)\n{\n\tint available;\n\n\tif (!lp->rx_skb[lp->rx_bd_ci])\n\t\treturn 0;\n\tavailable = 1 + lp->rx_bd_tail - lp->rx_bd_ci;\n\tif (available <= 0)\n\t\tavailable += lp->rx_bd_num;\n\treturn available;\n}\n\nstatic void ll_temac_recv(struct net_device *ndev)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tunsigned long flags;\n\tint rx_bd;\n\tbool update_tail = false;\n\n\tspin_lock_irqsave(&lp->rx_lock, flags);\n\n\t/* Process all received buffers, passing them on network\n\t * stack.  After this, the buffer descriptors will be in an\n\t * un-allocated stage, where no skb is allocated for it, and\n\t * they are therefore not available for TEMAC/DMA.\n\t */\n\tdo {\n\t\tstruct cdmac_bd *bd = &lp->rx_bd_v[lp->rx_bd_ci];\n\t\tstruct sk_buff *skb = lp->rx_skb[lp->rx_bd_ci];\n\t\tunsigned int bdstat = be32_to_cpu(bd->app0);\n\t\tint length;\n\n\t\t/* While this should not normally happen, we can end\n\t\t * here when GFP_ATOMIC allocations fail, and we\n\t\t * therefore have un-allocated buffers.\n\t\t */\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\t/* Loop over all completed buffer descriptors */\n\t\tif (!(bdstat & STS_CTRL_APP0_CMPLT))\n\t\t\tbreak;\n\n\t\tdma_unmap_single(ndev->dev.parent, be32_to_cpu(bd->phys),\n\t\t\t\t XTE_MAX_JUMBO_FRAME_SIZE, DMA_FROM_DEVICE);\n\t\t/* The buffer is not valid for DMA anymore */\n\t\tbd->phys = 0;\n\t\tbd->len = 0;\n\n\t\tlength = be32_to_cpu(bd->app4) & 0x3FFF;\n\t\tskb_put(skb, length);\n\t\tskb->protocol = eth_type_trans(skb, ndev);\n\t\tskb_checksum_none_assert(skb);\n\n\t\t/* if we're doing rx csum offload, set it up */\n\t\tif (((lp->temac_features & TEMAC_FEATURE_RX_CSUM) != 0) &&\n\t\t    (skb->protocol == htons(ETH_P_IP)) &&\n\t\t    (skb->len > 64)) {\n\n\t\t\t/* Convert from device endianness (be32) to cpu\n\t\t\t * endiannes, and if necessary swap the bytes\n\t\t\t * (back) for proper IP checksum byte order\n\t\t\t * (be16).\n\t\t\t */\n\t\t\tskb->csum = htons(be32_to_cpu(bd->app3) & 0xFFFF);\n\t\t\tskb->ip_summed = CHECKSUM_COMPLETE;\n\t\t}\n\n\t\tif (!skb_defer_rx_timestamp(skb))\n\t\t\tnetif_rx(skb);\n\t\t/* The skb buffer is now owned by network stack above */\n\t\tlp->rx_skb[lp->rx_bd_ci] = NULL;\n\n\t\tndev->stats.rx_packets++;\n\t\tndev->stats.rx_bytes += length;\n\n\t\trx_bd = lp->rx_bd_ci;\n\t\tif (++lp->rx_bd_ci >= lp->rx_bd_num)\n\t\t\tlp->rx_bd_ci = 0;\n\t} while (rx_bd != lp->rx_bd_tail);\n\n\t/* DMA operations will halt when the last buffer descriptor is\n\t * processed (ie. the one pointed to by RX_TAILDESC_PTR).\n\t * When that happens, no more interrupt events will be\n\t * generated.  No IRQ_COAL or IRQ_DLY, and not even an\n\t * IRQ_ERR.  To avoid stalling, we schedule a delayed work\n\t * when there is a potential risk of that happening.  The work\n\t * will call this function, and thus re-schedule itself until\n\t * enough buffers are available again.\n\t */\n\tif (ll_temac_recv_buffers_available(lp) < lp->coalesce_count_rx)\n\t\tschedule_delayed_work(&lp->restart_work, HZ / 1000);\n\n\t/* Allocate new buffers for those buffer descriptors that were\n\t * passed to network stack.  Note that GFP_ATOMIC allocations\n\t * can fail (e.g. when a larger burst of GFP_ATOMIC\n\t * allocations occurs), so while we try to allocate all\n\t * buffers in the same interrupt where they were processed, we\n\t * continue with what we could get in case of allocation\n\t * failure.  Allocation of remaining buffers will be retried\n\t * in following calls.\n\t */\n\twhile (1) {\n\t\tstruct sk_buff *skb;\n\t\tstruct cdmac_bd *bd;\n\t\tdma_addr_t skb_dma_addr;\n\n\t\trx_bd = lp->rx_bd_tail + 1;\n\t\tif (rx_bd >= lp->rx_bd_num)\n\t\t\trx_bd = 0;\n\t\tbd = &lp->rx_bd_v[rx_bd];\n\n\t\tif (bd->phys)\n\t\t\tbreak;\t/* All skb's allocated */\n\n\t\tskb = netdev_alloc_skb_ip_align(ndev, XTE_MAX_JUMBO_FRAME_SIZE);\n\t\tif (!skb) {\n\t\t\tdev_warn(&ndev->dev, \"skb alloc failed\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tskb_dma_addr = dma_map_single(ndev->dev.parent, skb->data,\n\t\t\t\t\t      XTE_MAX_JUMBO_FRAME_SIZE,\n\t\t\t\t\t      DMA_FROM_DEVICE);\n\t\tif (WARN_ON_ONCE(dma_mapping_error(ndev->dev.parent,\n\t\t\t\t\t\t   skb_dma_addr))) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tbreak;\n\t\t}\n\n\t\tbd->phys = cpu_to_be32(skb_dma_addr);\n\t\tbd->len = cpu_to_be32(XTE_MAX_JUMBO_FRAME_SIZE);\n\t\tbd->app0 = cpu_to_be32(STS_CTRL_APP0_IRQONEND);\n\t\tlp->rx_skb[rx_bd] = skb;\n\n\t\tlp->rx_bd_tail = rx_bd;\n\t\tupdate_tail = true;\n\t}\n\n\t/* Move tail pointer when buffers have been allocated */\n\tif (update_tail) {\n\t\tlp->dma_out(lp, RX_TAILDESC_PTR,\n\t\t\tlp->rx_bd_p + sizeof(*lp->rx_bd_v) * lp->rx_bd_tail);\n\t}\n\n\tspin_unlock_irqrestore(&lp->rx_lock, flags);\n}\n\n/* Function scheduled to ensure a restart in case of DMA halt\n * condition caused by running out of buffer descriptors.\n */\nstatic void ll_temac_restart_work_func(struct work_struct *work)\n{\n\tstruct temac_local *lp = container_of(work, struct temac_local,\n\t\t\t\t\t      restart_work.work);\n\tstruct net_device *ndev = lp->ndev;\n\n\tll_temac_recv(ndev);\n}\n\nstatic irqreturn_t ll_temac_tx_irq(int irq, void *_ndev)\n{\n\tstruct net_device *ndev = _ndev;\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tunsigned int status;\n\n\tstatus = lp->dma_in(lp, TX_IRQ_REG);\n\tlp->dma_out(lp, TX_IRQ_REG, status);\n\n\tif (status & (IRQ_COAL | IRQ_DLY))\n\t\ttemac_start_xmit_done(lp->ndev);\n\tif (status & (IRQ_ERR | IRQ_DMAERR))\n\t\tdev_err_ratelimited(&ndev->dev,\n\t\t\t\t    \"TX error 0x%x TX_CHNL_STS=0x%08x\\n\",\n\t\t\t\t    status, lp->dma_in(lp, TX_CHNL_STS));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t ll_temac_rx_irq(int irq, void *_ndev)\n{\n\tstruct net_device *ndev = _ndev;\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tunsigned int status;\n\n\t/* Read and clear the status registers */\n\tstatus = lp->dma_in(lp, RX_IRQ_REG);\n\tlp->dma_out(lp, RX_IRQ_REG, status);\n\n\tif (status & (IRQ_COAL | IRQ_DLY))\n\t\tll_temac_recv(lp->ndev);\n\tif (status & (IRQ_ERR | IRQ_DMAERR))\n\t\tdev_err_ratelimited(&ndev->dev,\n\t\t\t\t    \"RX error 0x%x RX_CHNL_STS=0x%08x\\n\",\n\t\t\t\t    status, lp->dma_in(lp, RX_CHNL_STS));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int temac_open(struct net_device *ndev)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tstruct phy_device *phydev = NULL;\n\tint rc;\n\n\tdev_dbg(&ndev->dev, \"temac_open()\\n\");\n\n\tif (lp->phy_node) {\n\t\tphydev = of_phy_connect(lp->ndev, lp->phy_node,\n\t\t\t\t\ttemac_adjust_link, 0, 0);\n\t\tif (!phydev) {\n\t\t\tdev_err(lp->dev, \"of_phy_connect() failed\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tphy_start(phydev);\n\t} else if (strlen(lp->phy_name) > 0) {\n\t\tphydev = phy_connect(lp->ndev, lp->phy_name, temac_adjust_link,\n\t\t\t\t     lp->phy_interface);\n\t\tif (IS_ERR(phydev)) {\n\t\t\tdev_err(lp->dev, \"phy_connect() failed\\n\");\n\t\t\treturn PTR_ERR(phydev);\n\t\t}\n\t\tphy_start(phydev);\n\t}\n\n\ttemac_device_reset(ndev);\n\n\trc = request_irq(lp->tx_irq, ll_temac_tx_irq, 0, ndev->name, ndev);\n\tif (rc)\n\t\tgoto err_tx_irq;\n\trc = request_irq(lp->rx_irq, ll_temac_rx_irq, 0, ndev->name, ndev);\n\tif (rc)\n\t\tgoto err_rx_irq;\n\n\treturn 0;\n\n err_rx_irq:\n\tfree_irq(lp->tx_irq, ndev);\n err_tx_irq:\n\tif (phydev)\n\t\tphy_disconnect(phydev);\n\tdev_err(lp->dev, \"request_irq() failed\\n\");\n\treturn rc;\n}\n\nstatic int temac_stop(struct net_device *ndev)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tstruct phy_device *phydev = ndev->phydev;\n\n\tdev_dbg(&ndev->dev, \"temac_close()\\n\");\n\n\tcancel_delayed_work_sync(&lp->restart_work);\n\n\tfree_irq(lp->tx_irq, ndev);\n\tfree_irq(lp->rx_irq, ndev);\n\n\tif (phydev)\n\t\tphy_disconnect(phydev);\n\n\ttemac_dma_bd_release(ndev);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void\ntemac_poll_controller(struct net_device *ndev)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\n\tdisable_irq(lp->tx_irq);\n\tdisable_irq(lp->rx_irq);\n\n\tll_temac_rx_irq(lp->tx_irq, ndev);\n\tll_temac_tx_irq(lp->rx_irq, ndev);\n\n\tenable_irq(lp->tx_irq);\n\tenable_irq(lp->rx_irq);\n}\n#endif\n\nstatic const struct net_device_ops temac_netdev_ops = {\n\t.ndo_open = temac_open,\n\t.ndo_stop = temac_stop,\n\t.ndo_start_xmit = temac_start_xmit,\n\t.ndo_set_rx_mode = temac_set_multicast_list,\n\t.ndo_set_mac_address = temac_set_mac_address,\n\t.ndo_validate_addr = eth_validate_addr,\n\t.ndo_do_ioctl = phy_do_ioctl_running,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller = temac_poll_controller,\n#endif\n};\n\n/* ---------------------------------------------------------------------\n * SYSFS device attributes\n */\nstatic ssize_t temac_show_llink_regs(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tint i, len = 0;\n\n\tfor (i = 0; i < 0x11; i++)\n\t\tlen += sprintf(buf + len, \"%.8x%s\", lp->dma_in(lp, i),\n\t\t\t       (i % 8) == 7 ? \"\\n\" : \" \");\n\tlen += sprintf(buf + len, \"\\n\");\n\n\treturn len;\n}\n\nstatic DEVICE_ATTR(llink_regs, 0440, temac_show_llink_regs, NULL);\n\nstatic struct attribute *temac_device_attrs[] = {\n\t&dev_attr_llink_regs.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group temac_attr_group = {\n\t.attrs = temac_device_attrs,\n};\n\n/* ---------------------------------------------------------------------\n * ethtool support\n */\n\nstatic void ll_temac_ethtools_get_ringparam(struct net_device *ndev,\n\t\t\t\t\t    struct ethtool_ringparam *ering)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\n\tering->rx_max_pending = RX_BD_NUM_MAX;\n\tering->rx_mini_max_pending = 0;\n\tering->rx_jumbo_max_pending = 0;\n\tering->tx_max_pending = TX_BD_NUM_MAX;\n\tering->rx_pending = lp->rx_bd_num;\n\tering->rx_mini_pending = 0;\n\tering->rx_jumbo_pending = 0;\n\tering->tx_pending = lp->tx_bd_num;\n}\n\nstatic int ll_temac_ethtools_set_ringparam(struct net_device *ndev,\n\t\t\t\t\t   struct ethtool_ringparam *ering)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\n\tif (ering->rx_pending > RX_BD_NUM_MAX ||\n\t    ering->rx_mini_pending ||\n\t    ering->rx_jumbo_pending ||\n\t    ering->rx_pending > TX_BD_NUM_MAX)\n\t\treturn -EINVAL;\n\n\tif (netif_running(ndev))\n\t\treturn -EBUSY;\n\n\tlp->rx_bd_num = ering->rx_pending;\n\tlp->tx_bd_num = ering->tx_pending;\n\treturn 0;\n}\n\nstatic int ll_temac_ethtools_get_coalesce(struct net_device *ndev,\n\t\t\t\t\t  struct ethtool_coalesce *ec)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\n\tec->rx_max_coalesced_frames = lp->coalesce_count_rx;\n\tec->tx_max_coalesced_frames = lp->coalesce_count_tx;\n\tec->rx_coalesce_usecs = (lp->coalesce_delay_rx * 512) / 100;\n\tec->tx_coalesce_usecs = (lp->coalesce_delay_tx * 512) / 100;\n\treturn 0;\n}\n\nstatic int ll_temac_ethtools_set_coalesce(struct net_device *ndev,\n\t\t\t\t\t  struct ethtool_coalesce *ec)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\n\tif (netif_running(ndev)) {\n\t\tnetdev_err(ndev,\n\t\t\t   \"Please stop netif before applying configuration\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (ec->rx_max_coalesced_frames)\n\t\tlp->coalesce_count_rx = ec->rx_max_coalesced_frames;\n\tif (ec->tx_max_coalesced_frames)\n\t\tlp->coalesce_count_tx = ec->tx_max_coalesced_frames;\n\t/* With typical LocalLink clock speed of 200 MHz and\n\t * C_PRESCALAR=1023, each delay count corresponds to 5.12 us.\n\t */\n\tif (ec->rx_coalesce_usecs)\n\t\tlp->coalesce_delay_rx =\n\t\t\tmin(255U, (ec->rx_coalesce_usecs * 100) / 512);\n\tif (ec->tx_coalesce_usecs)\n\t\tlp->coalesce_delay_tx =\n\t\t\tmin(255U, (ec->tx_coalesce_usecs * 100) / 512);\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops temac_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES,\n\t.nway_reset = phy_ethtool_nway_reset,\n\t.get_link = ethtool_op_get_link,\n\t.get_ts_info = ethtool_op_get_ts_info,\n\t.get_link_ksettings = phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings = phy_ethtool_set_link_ksettings,\n\t.get_ringparam\t= ll_temac_ethtools_get_ringparam,\n\t.set_ringparam\t= ll_temac_ethtools_set_ringparam,\n\t.get_coalesce\t= ll_temac_ethtools_get_coalesce,\n\t.set_coalesce\t= ll_temac_ethtools_set_coalesce,\n};\n\nstatic int temac_probe(struct platform_device *pdev)\n{\n\tstruct ll_temac_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct device_node *temac_np = dev_of_node(&pdev->dev), *dma_np;\n\tstruct temac_local *lp;\n\tstruct net_device *ndev;\n\tu8 addr[ETH_ALEN];\n\t__be32 *p;\n\tbool little_endian;\n\tint rc = 0;\n\n\t/* Init network device structure */\n\tndev = devm_alloc_etherdev(&pdev->dev, sizeof(*lp));\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, ndev);\n\tSET_NETDEV_DEV(ndev, &pdev->dev);\n\tndev->features = NETIF_F_SG;\n\tndev->netdev_ops = &temac_netdev_ops;\n\tndev->ethtool_ops = &temac_ethtool_ops;\n#if 0\n\tndev->features |= NETIF_F_IP_CSUM; /* Can checksum TCP/UDP over IPv4. */\n\tndev->features |= NETIF_F_HW_CSUM; /* Can checksum all the packets. */\n\tndev->features |= NETIF_F_IPV6_CSUM; /* Can checksum IPV6 TCP/UDP */\n\tndev->features |= NETIF_F_HIGHDMA; /* Can DMA to high memory. */\n\tndev->features |= NETIF_F_HW_VLAN_CTAG_TX; /* Transmit VLAN hw accel */\n\tndev->features |= NETIF_F_HW_VLAN_CTAG_RX; /* Receive VLAN hw acceleration */\n\tndev->features |= NETIF_F_HW_VLAN_CTAG_FILTER; /* Receive VLAN filtering */\n\tndev->features |= NETIF_F_VLAN_CHALLENGED; /* cannot handle VLAN pkts */\n\tndev->features |= NETIF_F_GSO; /* Enable software GSO. */\n\tndev->features |= NETIF_F_MULTI_QUEUE; /* Has multiple TX/RX queues */\n\tndev->features |= NETIF_F_LRO; /* large receive offload */\n#endif\n\n\t/* setup temac private info structure */\n\tlp = netdev_priv(ndev);\n\tlp->ndev = ndev;\n\tlp->dev = &pdev->dev;\n\tlp->options = XTE_OPTION_DEFAULTS;\n\tlp->rx_bd_num = RX_BD_NUM_DEFAULT;\n\tlp->tx_bd_num = TX_BD_NUM_DEFAULT;\n\tspin_lock_init(&lp->rx_lock);\n\tINIT_DELAYED_WORK(&lp->restart_work, ll_temac_restart_work_func);\n\n\t/* Setup mutex for synchronization of indirect register access */\n\tif (pdata) {\n\t\tif (!pdata->indirect_lock) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"indirect_lock missing in platform_data\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlp->indirect_lock = pdata->indirect_lock;\n\t} else {\n\t\tlp->indirect_lock = devm_kmalloc(&pdev->dev,\n\t\t\t\t\t\t sizeof(*lp->indirect_lock),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tspin_lock_init(lp->indirect_lock);\n\t}\n\n\t/* map device registers */\n\tlp->regs = devm_platform_ioremap_resource_byname(pdev, 0);\n\tif (IS_ERR(lp->regs)) {\n\t\tdev_err(&pdev->dev, \"could not map TEMAC registers\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Select register access functions with the specified\n\t * endianness mode.  Default for OF devices is big-endian.\n\t */\n\tlittle_endian = false;\n\tif (temac_np) {\n\t\tif (of_get_property(temac_np, \"little-endian\", NULL))\n\t\t\tlittle_endian = true;\n\t} else if (pdata) {\n\t\tlittle_endian = pdata->reg_little_endian;\n\t}\n\tif (little_endian) {\n\t\tlp->temac_ior = _temac_ior_le;\n\t\tlp->temac_iow = _temac_iow_le;\n\t} else {\n\t\tlp->temac_ior = _temac_ior_be;\n\t\tlp->temac_iow = _temac_iow_be;\n\t}\n\n\t/* Setup checksum offload, but default to off if not specified */\n\tlp->temac_features = 0;\n\tif (temac_np) {\n\t\tp = (__be32 *)of_get_property(temac_np, \"xlnx,txcsum\", NULL);\n\t\tif (p && be32_to_cpu(*p))\n\t\t\tlp->temac_features |= TEMAC_FEATURE_TX_CSUM;\n\t\tp = (__be32 *)of_get_property(temac_np, \"xlnx,rxcsum\", NULL);\n\t\tif (p && be32_to_cpu(*p))\n\t\t\tlp->temac_features |= TEMAC_FEATURE_RX_CSUM;\n\t} else if (pdata) {\n\t\tif (pdata->txcsum)\n\t\t\tlp->temac_features |= TEMAC_FEATURE_TX_CSUM;\n\t\tif (pdata->rxcsum)\n\t\t\tlp->temac_features |= TEMAC_FEATURE_RX_CSUM;\n\t}\n\tif (lp->temac_features & TEMAC_FEATURE_TX_CSUM)\n\t\t/* Can checksum TCP/UDP over IPv4. */\n\t\tndev->features |= NETIF_F_IP_CSUM;\n\n\t/* Defaults for IRQ delay/coalescing setup.  These are\n\t * configuration values, so does not belong in device-tree.\n\t */\n\tlp->coalesce_delay_tx = 0x10;\n\tlp->coalesce_count_tx = 0x22;\n\tlp->coalesce_delay_rx = 0xff;\n\tlp->coalesce_count_rx = 0x07;\n\n\t/* Setup LocalLink DMA */\n\tif (temac_np) {\n\t\t/* Find the DMA node, map the DMA registers, and\n\t\t * decode the DMA IRQs.\n\t\t */\n\t\tdma_np = of_parse_phandle(temac_np, \"llink-connected\", 0);\n\t\tif (!dma_np) {\n\t\t\tdev_err(&pdev->dev, \"could not find DMA node\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t/* Setup the DMA register accesses, could be DCR or\n\t\t * memory mapped.\n\t\t */\n\t\tif (temac_dcr_setup(lp, pdev, dma_np)) {\n\t\t\t/* no DCR in the device tree, try non-DCR */\n\t\t\tlp->sdma_regs = devm_of_iomap(&pdev->dev, dma_np, 0,\n\t\t\t\t\t\t      NULL);\n\t\t\tif (IS_ERR(lp->sdma_regs)) {\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"unable to map DMA registers\\n\");\n\t\t\t\tof_node_put(dma_np);\n\t\t\t\treturn PTR_ERR(lp->sdma_regs);\n\t\t\t}\n\t\t\tif (of_get_property(dma_np, \"little-endian\", NULL)) {\n\t\t\t\tlp->dma_in = temac_dma_in32_le;\n\t\t\t\tlp->dma_out = temac_dma_out32_le;\n\t\t\t} else {\n\t\t\t\tlp->dma_in = temac_dma_in32_be;\n\t\t\t\tlp->dma_out = temac_dma_out32_be;\n\t\t\t}\n\t\t\tdev_dbg(&pdev->dev, \"MEM base: %p\\n\", lp->sdma_regs);\n\t\t}\n\n\t\t/* Get DMA RX and TX interrupts */\n\t\tlp->rx_irq = irq_of_parse_and_map(dma_np, 0);\n\t\tlp->tx_irq = irq_of_parse_and_map(dma_np, 1);\n\n\t\t/* Finished with the DMA node; drop the reference */\n\t\tof_node_put(dma_np);\n\t} else if (pdata) {\n\t\t/* 2nd memory resource specifies DMA registers */\n\t\tlp->sdma_regs = devm_platform_ioremap_resource(pdev, 1);\n\t\tif (IS_ERR(lp->sdma_regs)) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"could not map DMA registers\\n\");\n\t\t\treturn PTR_ERR(lp->sdma_regs);\n\t\t}\n\t\tif (pdata->dma_little_endian) {\n\t\t\tlp->dma_in = temac_dma_in32_le;\n\t\t\tlp->dma_out = temac_dma_out32_le;\n\t\t} else {\n\t\t\tlp->dma_in = temac_dma_in32_be;\n\t\t\tlp->dma_out = temac_dma_out32_be;\n\t\t}\n\n\t\t/* Get DMA RX and TX interrupts */\n\t\tlp->rx_irq = platform_get_irq(pdev, 0);\n\t\tlp->tx_irq = platform_get_irq(pdev, 1);\n\n\t\t/* IRQ delay/coalescing setup */\n\t\tif (pdata->tx_irq_timeout || pdata->tx_irq_count) {\n\t\t\tlp->coalesce_delay_tx = pdata->tx_irq_timeout;\n\t\t\tlp->coalesce_count_tx = pdata->tx_irq_count;\n\t\t}\n\t\tif (pdata->rx_irq_timeout || pdata->rx_irq_count) {\n\t\t\tlp->coalesce_delay_rx = pdata->rx_irq_timeout;\n\t\t\tlp->coalesce_count_rx = pdata->rx_irq_count;\n\t\t}\n\t}\n\n\t/* Error handle returned DMA RX and TX interrupts */\n\tif (lp->rx_irq < 0) {\n\t\tif (lp->rx_irq != -EPROBE_DEFER)\n\t\t\tdev_err(&pdev->dev, \"could not get DMA RX irq\\n\");\n\t\treturn lp->rx_irq;\n\t}\n\tif (lp->tx_irq < 0) {\n\t\tif (lp->tx_irq != -EPROBE_DEFER)\n\t\t\tdev_err(&pdev->dev, \"could not get DMA TX irq\\n\");\n\t\treturn lp->tx_irq;\n\t}\n\n\tif (temac_np) {\n\t\t/* Retrieve the MAC address */\n\t\trc = of_get_mac_address(temac_np, addr);\n\t\tif (rc) {\n\t\t\tdev_err(&pdev->dev, \"could not find MAC address\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\ttemac_init_mac_address(ndev, addr);\n\t} else if (pdata) {\n\t\ttemac_init_mac_address(ndev, pdata->mac_addr);\n\t}\n\n\trc = temac_mdio_setup(lp, pdev);\n\tif (rc)\n\t\tdev_warn(&pdev->dev, \"error registering MDIO bus\\n\");\n\n\tif (temac_np) {\n\t\tlp->phy_node = of_parse_phandle(temac_np, \"phy-handle\", 0);\n\t\tif (lp->phy_node)\n\t\t\tdev_dbg(lp->dev, \"using PHY node %pOF\\n\", temac_np);\n\t} else if (pdata) {\n\t\tsnprintf(lp->phy_name, sizeof(lp->phy_name),\n\t\t\t PHY_ID_FMT, lp->mii_bus->id, pdata->phy_addr);\n\t\tlp->phy_interface = pdata->phy_interface;\n\t}\n\n\t/* Add the device attributes */\n\trc = sysfs_create_group(&lp->dev->kobj, &temac_attr_group);\n\tif (rc) {\n\t\tdev_err(lp->dev, \"Error creating sysfs files\\n\");\n\t\tgoto err_sysfs_create;\n\t}\n\n\trc = register_netdev(lp->ndev);\n\tif (rc) {\n\t\tdev_err(lp->dev, \"register_netdev() error (%i)\\n\", rc);\n\t\tgoto err_register_ndev;\n\t}\n\n\treturn 0;\n\nerr_register_ndev:\n\tsysfs_remove_group(&lp->dev->kobj, &temac_attr_group);\nerr_sysfs_create:\n\tif (lp->phy_node)\n\t\tof_node_put(lp->phy_node);\n\ttemac_mdio_teardown(lp);\n\treturn rc;\n}\n\nstatic int temac_remove(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct temac_local *lp = netdev_priv(ndev);\n\n\tunregister_netdev(ndev);\n\tsysfs_remove_group(&lp->dev->kobj, &temac_attr_group);\n\tif (lp->phy_node)\n\t\tof_node_put(lp->phy_node);\n\ttemac_mdio_teardown(lp);\n\treturn 0;\n}\n\nstatic const struct of_device_id temac_of_match[] = {\n\t{ .compatible = \"xlnx,xps-ll-temac-1.01.b\", },\n\t{ .compatible = \"xlnx,xps-ll-temac-2.00.a\", },\n\t{ .compatible = \"xlnx,xps-ll-temac-2.02.a\", },\n\t{ .compatible = \"xlnx,xps-ll-temac-2.03.a\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, temac_of_match);\n\nstatic struct platform_driver temac_driver = {\n\t.probe = temac_probe,\n\t.remove = temac_remove,\n\t.driver = {\n\t\t.name = \"xilinx_temac\",\n\t\t.of_match_table = temac_of_match,\n\t},\n};\n\nmodule_platform_driver(temac_driver);\n\nMODULE_DESCRIPTION(\"Xilinx LL_TEMAC Ethernet driver\");\nMODULE_AUTHOR(\"Yoshio Kashiwagi\");\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["drivers/net/ethernet/xilinx/ll_temac_main.c"], "buggy_code_start_loc": [864], "buggy_code_end_loc": [865], "fixing_code_start_loc": [864], "fixing_code_end_loc": [865], "type": "CWE-120", "message": "drivers/net/ethernet/xilinx/ll_temac_main.c in the Linux kernel before 5.12.13 allows remote attackers to cause a denial of service (buffer overflow and lockup) by sending heavy network traffic for about ten minutes.", "other": {"cve": {"id": "CVE-2021-38207", "sourceIdentifier": "cve@mitre.org", "published": "2021-08-08T20:15:07.353", "lastModified": "2021-10-18T12:23:03.460", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "drivers/net/ethernet/xilinx/ll_temac_main.c in the Linux kernel before 5.12.13 allows remote attackers to cause a denial of service (buffer overflow and lockup) by sending heavy network traffic for about ten minutes."}, {"lang": "es", "value": "El archivo drivers/net/ethernet/xilinx/ll_temac_main.c en el kernel de Linux versiones anteriores a 5.12.13, permite a atacantes remotos causar una denegaci\u00f3n de servicio (desbordamiento del b\u00fafer y bloqueo) mediante el env\u00edo de un tr\u00e1fico de red intenso durante unos diez minutos"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.12.13", "matchCriteriaId": "4C096241-6457-4DB4-80C3-DD650F628184"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.12.13", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/c364df2489b8ef2f5e3159b1dff1ff1fdb16040d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210902-0007/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/c364df2489b8ef2f5e3159b1dff1ff1fdb16040d"}}