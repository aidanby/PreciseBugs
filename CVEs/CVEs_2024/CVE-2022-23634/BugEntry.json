{"buggy_code": ["# frozen_string_literal: true\n\nmodule Puma\n\n  # The methods here are included in Server, but are separated into this file.\n  # All the methods here pertain to passing the request to the app, then\n  # writing the response back to the client.\n  #\n  # None of the methods here are called externally, with the exception of\n  # #handle_request, which is called in Server#process_client.\n  # @version 5.0.3\n  #\n  module Request\n\n    include Puma::Const\n\n    # Takes the request contained in +client+, invokes the Rack application to construct\n    # the response and writes it back to +client.io+.\n    #\n    # It'll return +false+ when the connection is closed, this doesn't mean\n    # that the response wasn't successful.\n    #\n    # It'll return +:async+ if the connection remains open but will be handled\n    # elsewhere, i.e. the connection has been hijacked by the Rack application.\n    #\n    # Finally, it'll return +true+ on keep-alive connections.\n    # @param client [Puma::Client]\n    # @param lines [Puma::IOBuffer]\n    # @param requests [Integer]\n    # @return [Boolean,:async]\n    #\n    def handle_request(client, lines, requests)\n      env = client.env\n      io  = client.io   # io may be a MiniSSL::Socket\n\n      return false if closed_socket?(io)\n\n      normalize_env env, client\n\n      env[PUMA_SOCKET] = io\n\n      if env[HTTPS_KEY] && io.peercert\n        env[PUMA_PEERCERT] = io.peercert\n      end\n\n      env[HIJACK_P] = true\n      env[HIJACK] = client\n\n      body = client.body\n\n      head = env[REQUEST_METHOD] == HEAD\n\n      env[RACK_INPUT] = body\n      env[RACK_URL_SCHEME] ||= default_server_port(env) == PORT_443 ? HTTPS : HTTP\n\n      if @early_hints\n        env[EARLY_HINTS] = lambda { |headers|\n          begin\n            fast_write io, str_early_hints(headers)\n          rescue ConnectionError => e\n            @log_writer.debug_error e\n            # noop, if we lost the socket we just won't send the early hints\n          end\n        }\n      end\n\n      req_env_post_parse env\n\n      # A rack extension. If the app writes #call'ables to this\n      # array, we will invoke them when the request is done.\n      #\n      after_reply = env[RACK_AFTER_REPLY] = []\n\n      begin\n        begin\n          status, headers, res_body = @thread_pool.with_force_shutdown do\n            @app.call(env)\n          end\n\n          return :async if client.hijacked\n\n          status = status.to_i\n\n          if status == -1\n            unless headers.empty? and res_body == []\n              raise \"async response must have empty headers and body\"\n            end\n\n            return :async\n          end\n        rescue ThreadPool::ForceShutdown => e\n          @log_writer.unknown_error e, client, \"Rack app\"\n          @log_writer.log \"Detected force shutdown of a thread\"\n\n          status, headers, res_body = lowlevel_error(e, env, 503)\n        rescue Exception => e\n          @log_writer.unknown_error e, client, \"Rack app\"\n\n          status, headers, res_body = lowlevel_error(e, env, 500)\n        end\n\n        res_info = {}\n        res_info[:content_length] = nil\n        res_info[:no_body] = head\n\n        res_info[:content_length] = if res_body.kind_of? Array and res_body.size == 1\n          res_body[0].bytesize\n        else\n          nil\n        end\n\n        cork_socket io\n\n        str_headers(env, status, headers, res_info, lines, requests, client)\n\n        line_ending = LINE_END\n\n        content_length  = res_info[:content_length]\n        if res_body && !res_body.respond_to?(:each)\n          response_hijack = res_body\n        else\n          response_hijack = res_info[:response_hijack]\n        end\n\n        if res_info[:no_body]\n          if content_length and status != 204\n            lines.append CONTENT_LENGTH_S, content_length.to_s, line_ending\n          end\n\n          lines << LINE_END\n          fast_write io, lines.to_s\n          return res_info[:keep_alive]\n        end\n\n        if content_length\n          lines.append CONTENT_LENGTH_S, content_length.to_s, line_ending\n          chunked = false\n        elsif !response_hijack and res_info[:allow_chunked]\n          lines << TRANSFER_ENCODING_CHUNKED\n          chunked = true\n        end\n\n        lines << line_ending\n\n        fast_write io, lines.to_s\n\n        if response_hijack\n          response_hijack.call io\n          return :async\n        end\n\n        begin\n          res_body.each do |part|\n            next if part.bytesize.zero?\n            if chunked\n               fast_write io, (part.bytesize.to_s(16) << line_ending)\n               fast_write io, part            # part may have different encoding\n               fast_write io, line_ending\n            else\n              fast_write io, part\n            end\n            io.flush\n          end\n\n          if chunked\n            fast_write io, CLOSE_CHUNKED\n            io.flush\n          end\n        rescue SystemCallError, IOError\n          raise ConnectionError, \"Connection error detected during write\"\n        end\n\n      ensure\n        uncork_socket io\n\n        body.close\n        client.tempfile.unlink if client.tempfile\n        res_body.close if res_body.respond_to? :close\n\n        after_reply.each { |o| o.call }\n      end\n\n      res_info[:keep_alive]\n    end\n\n    # @param env [Hash] see Puma::Client#env, from request\n    # @return [Puma::Const::PORT_443,Puma::Const::PORT_80]\n    #\n    def default_server_port(env)\n      if ['on', HTTPS].include?(env[HTTPS_KEY]) || env[HTTP_X_FORWARDED_PROTO].to_s[0...5] == HTTPS || env[HTTP_X_FORWARDED_SCHEME] == HTTPS || env[HTTP_X_FORWARDED_SSL] == \"on\"\n        PORT_443\n      else\n        PORT_80\n      end\n    end\n\n    # Writes to an io (normally Client#io) using #syswrite\n    # @param io [#syswrite] the io to write to\n    # @param str [String] the string written to the io\n    # @raise [ConnectionError]\n    #\n    def fast_write(io, str)\n      n = 0\n      while true\n        begin\n          n = io.syswrite str\n        rescue Errno::EAGAIN, Errno::EWOULDBLOCK\n          unless io.wait_writable WRITE_TIMEOUT\n            raise ConnectionError, \"Socket timeout writing data\"\n          end\n\n          retry\n        rescue  Errno::EPIPE, SystemCallError, IOError\n          raise ConnectionError, \"Socket timeout writing data\"\n        end\n\n        return if n == str.bytesize\n        str = str.byteslice(n..-1)\n      end\n    end\n    private :fast_write\n\n    # @param status [Integer] status from the app\n    # @return [String] the text description from Puma::HTTP_STATUS_CODES\n    #\n    def fetch_status_code(status)\n      HTTP_STATUS_CODES.fetch(status) { 'CUSTOM' }\n    end\n    private :fetch_status_code\n\n    # Given a Hash +env+ for the request read from +client+, add\n    # and fixup keys to comply with Rack's env guidelines.\n    # @param env [Hash] see Puma::Client#env, from request\n    # @param client [Puma::Client] only needed for Client#peerip\n    # @todo make private in 6.0.0\n    #\n    def normalize_env(env, client)\n      if host = env[HTTP_HOST]\n        # host can be a hostname, ipv4 or bracketed ipv6. Followed by an optional port.\n        if colon = host.rindex(\"]:\") # IPV6 with port\n          env[SERVER_NAME] = host[0, colon+1]\n          env[SERVER_PORT] = host[colon+2, host.bytesize]\n        elsif !host.start_with?(\"[\") && colon = host.index(\":\") # not hostname or IPV4 with port\n          env[SERVER_NAME] = host[0, colon]\n          env[SERVER_PORT] = host[colon+1, host.bytesize]\n        else\n          env[SERVER_NAME] = host\n          env[SERVER_PORT] = default_server_port(env)\n        end\n      else\n        env[SERVER_NAME] = LOCALHOST\n        env[SERVER_PORT] = default_server_port(env)\n      end\n\n      unless env[REQUEST_PATH]\n        # it might be a dumbass full host request header\n        uri = URI.parse(env[REQUEST_URI])\n        env[REQUEST_PATH] = uri.path\n\n        raise \"No REQUEST PATH\" unless env[REQUEST_PATH]\n\n        # A nil env value will cause a LintError (and fatal errors elsewhere),\n        # so only set the env value if there actually is a value.\n        env[QUERY_STRING] = uri.query if uri.query\n      end\n\n      env[PATH_INFO] = env[REQUEST_PATH]\n\n      # From https://www.ietf.org/rfc/rfc3875 :\n      # \"Script authors should be aware that the REMOTE_ADDR and\n      # REMOTE_HOST meta-variables (see sections 4.1.8 and 4.1.9)\n      # may not identify the ultimate source of the request.\n      # They identify the client for the immediate request to the\n      # server; that client may be a proxy, gateway, or other\n      # intermediary acting on behalf of the actual source client.\"\n      #\n\n      unless env.key?(REMOTE_ADDR)\n        begin\n          addr = client.peerip\n        rescue Errno::ENOTCONN\n          # Client disconnects can result in an inability to get the\n          # peeraddr from the socket; default to localhost.\n          addr = LOCALHOST_IP\n        end\n\n        # Set unix socket addrs to localhost\n        addr = LOCALHOST_IP if addr.empty?\n\n        env[REMOTE_ADDR] = addr\n      end\n    end\n    # private :normalize_env\n\n    # @param header_key [#to_s]\n    # @return [Boolean]\n    #\n    def illegal_header_key?(header_key)\n      !!(ILLEGAL_HEADER_KEY_REGEX =~ header_key.to_s)\n    end\n\n    # @param header_value [#to_s]\n    # @return [Boolean]\n    #\n    def illegal_header_value?(header_value)\n      !!(ILLEGAL_HEADER_VALUE_REGEX =~ header_value.to_s)\n    end\n    private :illegal_header_key?, :illegal_header_value?\n\n    # Fixup any headers with `,` in the name to have `_` now. We emit\n    # headers with `,` in them during the parse phase to avoid ambiguity\n    # with the `-` to `_` conversion for critical headers. But here for\n    # compatibility, we'll convert them back. This code is written to\n    # avoid allocation in the common case (ie there are no headers\n    # with `,` in their names), that's why it has the extra conditionals.\n    # @param env [Hash] see Puma::Client#env, from request, modifies in place\n    # @version 5.0.3\n    #\n    def req_env_post_parse(env)\n      to_delete = nil\n      to_add = nil\n\n      env.each do |k,v|\n        if k.start_with?(\"HTTP_\") and k.include?(\",\") and k != \"HTTP_TRANSFER,ENCODING\"\n          if to_delete\n            to_delete << k\n          else\n            to_delete = [k]\n          end\n\n          unless to_add\n            to_add = {}\n          end\n\n          to_add[k.tr(\",\", \"_\")] = v\n        end\n      end\n\n      if to_delete\n        to_delete.each { |k| env.delete(k) }\n        env.merge! to_add\n      end\n    end\n    private :req_env_post_parse\n\n    # Used in the lambda for env[ `Puma::Const::EARLY_HINTS` ]\n    # @param headers [Hash] the headers returned by the Rack application\n    # @return [String]\n    # @version 5.0.3\n    #\n    def str_early_hints(headers)\n      eh_str = \"HTTP/1.1 103 Early Hints\\r\\n\".dup\n      headers.each_pair do |k, vs|\n        next if illegal_header_key?(k)\n\n        if vs.respond_to?(:to_s) && !vs.to_s.empty?\n          vs.to_s.split(NEWLINE).each do |v|\n            next if illegal_header_value?(v)\n            eh_str << \"#{k}: #{v}\\r\\n\"\n          end\n        else\n          eh_str << \"#{k}: #{vs}\\r\\n\"\n        end\n      end\n      \"#{eh_str}\\r\\n\".freeze\n    end\n    private :str_early_hints\n\n    # Processes and write headers to the IOBuffer.\n    # @param env [Hash] see Puma::Client#env, from request\n    # @param status [Integer] the status returned by the Rack application\n    # @param headers [Hash] the headers returned by the Rack application\n    # @param res_info [Hash] used to pass info between this method and #handle_request\n    # @param lines [Puma::IOBuffer] modified inn place\n    # @param requests [Integer] number of inline requests handled\n    # @param client [Puma::Client]\n    # @version 5.0.3\n    #\n    def str_headers(env, status, headers, res_info, lines, requests, client)\n      line_ending = LINE_END\n      colon = COLON\n\n      http_11 = env[HTTP_VERSION] == HTTP_11\n      if http_11\n        res_info[:allow_chunked] = true\n        res_info[:keep_alive] = env.fetch(HTTP_CONNECTION, \"\").downcase != CLOSE\n\n        # An optimization. The most common response is 200, so we can\n        # reply with the proper 200 status without having to compute\n        # the response header.\n        #\n        if status == 200\n          lines << HTTP_11_200\n        else\n          lines.append \"HTTP/1.1 \", status.to_s, \" \",\n                       fetch_status_code(status), line_ending\n\n          res_info[:no_body] ||= status < 200 || STATUS_WITH_NO_ENTITY_BODY[status]\n        end\n      else\n        res_info[:allow_chunked] = false\n        res_info[:keep_alive] = env.fetch(HTTP_CONNECTION, \"\").downcase == KEEP_ALIVE\n\n        # Same optimization as above for HTTP/1.1\n        #\n        if status == 200\n          lines << HTTP_10_200\n        else\n          lines.append \"HTTP/1.0 \", status.to_s, \" \",\n                       fetch_status_code(status), line_ending\n\n          res_info[:no_body] ||= status < 200 || STATUS_WITH_NO_ENTITY_BODY[status]\n        end\n      end\n\n      # regardless of what the client wants, we always close the connection\n      # if running without request queueing\n      res_info[:keep_alive] &&= @queue_requests\n\n      # Close the connection after a reasonable number of inline requests\n      # if the server is at capacity and the listener has a new connection ready.\n      # This allows Puma to service connections fairly when the number\n      # of concurrent connections exceeds the size of the threadpool.\n      res_info[:keep_alive] &&= requests < @max_fast_inline ||\n        @thread_pool.busy_threads < @max_threads ||\n        !client.listener.to_io.wait_readable(0)\n\n      res_info[:response_hijack] = nil\n\n      headers.each do |k, vs|\n        next if illegal_header_key?(k)\n\n        case k.downcase\n        when CONTENT_LENGTH2\n          next if illegal_header_value?(vs)\n          res_info[:content_length] = vs\n          next\n        when TRANSFER_ENCODING\n          res_info[:allow_chunked] = false\n          res_info[:content_length] = nil\n        when HIJACK\n          res_info[:response_hijack] = vs\n          next\n        when BANNED_HEADER_KEY\n          next\n        end\n\n        if vs.respond_to?(:to_s) && !vs.to_s.empty?\n          vs.to_s.split(NEWLINE).each do |v|\n            next if illegal_header_value?(v)\n            lines.append k, colon, v, line_ending\n          end\n        else\n          lines.append k, colon, line_ending\n        end\n      end\n\n      # HTTP/1.1 & 1.0 assume different defaults:\n      # - HTTP 1.0 assumes the connection will be closed if not specified\n      # - HTTP 1.1 assumes the connection will be kept alive if not specified.\n      # Only set the header if we're doing something which is not the default\n      # for this protocol version\n      if http_11\n        lines << CONNECTION_CLOSE if !res_info[:keep_alive]\n      else\n        lines << CONNECTION_KEEP_ALIVE if res_info[:keep_alive]\n      end\n    end\n    private :str_headers\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nmodule Puma\n\n  # The methods here are included in Server, but are separated into this file.\n  # All the methods here pertain to passing the request to the app, then\n  # writing the response back to the client.\n  #\n  # None of the methods here are called externally, with the exception of\n  # #handle_request, which is called in Server#process_client.\n  # @version 5.0.3\n  #\n  module Request\n\n    include Puma::Const\n\n    # Takes the request contained in +client+, invokes the Rack application to construct\n    # the response and writes it back to +client.io+.\n    #\n    # It'll return +false+ when the connection is closed, this doesn't mean\n    # that the response wasn't successful.\n    #\n    # It'll return +:async+ if the connection remains open but will be handled\n    # elsewhere, i.e. the connection has been hijacked by the Rack application.\n    #\n    # Finally, it'll return +true+ on keep-alive connections.\n    # @param client [Puma::Client]\n    # @param lines [Puma::IOBuffer]\n    # @param requests [Integer]\n    # @return [Boolean,:async]\n    #\n    def handle_request(client, lines, requests)\n      env = client.env\n      io  = client.io   # io may be a MiniSSL::Socket\n\n      return false if closed_socket?(io)\n\n      normalize_env env, client\n\n      env[PUMA_SOCKET] = io\n\n      if env[HTTPS_KEY] && io.peercert\n        env[PUMA_PEERCERT] = io.peercert\n      end\n\n      env[HIJACK_P] = true\n      env[HIJACK] = client\n\n      body = client.body\n\n      head = env[REQUEST_METHOD] == HEAD\n\n      env[RACK_INPUT] = body\n      env[RACK_URL_SCHEME] ||= default_server_port(env) == PORT_443 ? HTTPS : HTTP\n\n      if @early_hints\n        env[EARLY_HINTS] = lambda { |headers|\n          begin\n            fast_write io, str_early_hints(headers)\n          rescue ConnectionError => e\n            @log_writer.debug_error e\n            # noop, if we lost the socket we just won't send the early hints\n          end\n        }\n      end\n\n      req_env_post_parse env\n\n      # A rack extension. If the app writes #call'ables to this\n      # array, we will invoke them when the request is done.\n      #\n      after_reply = env[RACK_AFTER_REPLY] = []\n\n      begin\n        begin\n          status, headers, res_body = @thread_pool.with_force_shutdown do\n            @app.call(env)\n          end\n\n          return :async if client.hijacked\n\n          status = status.to_i\n\n          if status == -1\n            unless headers.empty? and res_body == []\n              raise \"async response must have empty headers and body\"\n            end\n\n            return :async\n          end\n        rescue ThreadPool::ForceShutdown => e\n          @log_writer.unknown_error e, client, \"Rack app\"\n          @log_writer.log \"Detected force shutdown of a thread\"\n\n          status, headers, res_body = lowlevel_error(e, env, 503)\n        rescue Exception => e\n          @log_writer.unknown_error e, client, \"Rack app\"\n\n          status, headers, res_body = lowlevel_error(e, env, 500)\n        end\n\n        res_info = {}\n        res_info[:content_length] = nil\n        res_info[:no_body] = head\n\n        res_info[:content_length] = if res_body.kind_of? Array and res_body.size == 1\n          res_body[0].bytesize\n        else\n          nil\n        end\n\n        cork_socket io\n\n        str_headers(env, status, headers, res_info, lines, requests, client)\n\n        line_ending = LINE_END\n\n        content_length  = res_info[:content_length]\n        if res_body && !res_body.respond_to?(:each)\n          response_hijack = res_body\n        else\n          response_hijack = res_info[:response_hijack]\n        end\n\n        if res_info[:no_body]\n          if content_length and status != 204\n            lines.append CONTENT_LENGTH_S, content_length.to_s, line_ending\n          end\n\n          lines << LINE_END\n          fast_write io, lines.to_s\n          return res_info[:keep_alive]\n        end\n\n        if content_length\n          lines.append CONTENT_LENGTH_S, content_length.to_s, line_ending\n          chunked = false\n        elsif !response_hijack and res_info[:allow_chunked]\n          lines << TRANSFER_ENCODING_CHUNKED\n          chunked = true\n        end\n\n        lines << line_ending\n\n        fast_write io, lines.to_s\n\n        if response_hijack\n          response_hijack.call io\n          return :async\n        end\n\n        begin\n          res_body.each do |part|\n            next if part.bytesize.zero?\n            if chunked\n               fast_write io, (part.bytesize.to_s(16) << line_ending)\n               fast_write io, part            # part may have different encoding\n               fast_write io, line_ending\n            else\n              fast_write io, part\n            end\n            io.flush\n          end\n\n          if chunked\n            fast_write io, CLOSE_CHUNKED\n            io.flush\n          end\n        rescue SystemCallError, IOError\n          raise ConnectionError, \"Connection error detected during write\"\n        end\n\n      ensure\n        begin\n          uncork_socket io\n\n          body.close\n          client.tempfile.unlink if client.tempfile\n        ensure\n          # Whatever happens, we MUST call `close` on the response body.\n          # Otherwise Rack::BodyProxy callbacks may not fire and lead to various state leaks\n          res_body.close if res_body.respond_to? :close\n        end\n\n        after_reply.each { |o| o.call }\n      end\n\n      res_info[:keep_alive]\n    end\n\n    # @param env [Hash] see Puma::Client#env, from request\n    # @return [Puma::Const::PORT_443,Puma::Const::PORT_80]\n    #\n    def default_server_port(env)\n      if ['on', HTTPS].include?(env[HTTPS_KEY]) || env[HTTP_X_FORWARDED_PROTO].to_s[0...5] == HTTPS || env[HTTP_X_FORWARDED_SCHEME] == HTTPS || env[HTTP_X_FORWARDED_SSL] == \"on\"\n        PORT_443\n      else\n        PORT_80\n      end\n    end\n\n    # Writes to an io (normally Client#io) using #syswrite\n    # @param io [#syswrite] the io to write to\n    # @param str [String] the string written to the io\n    # @raise [ConnectionError]\n    #\n    def fast_write(io, str)\n      n = 0\n      while true\n        begin\n          n = io.syswrite str\n        rescue Errno::EAGAIN, Errno::EWOULDBLOCK\n          unless io.wait_writable WRITE_TIMEOUT\n            raise ConnectionError, \"Socket timeout writing data\"\n          end\n\n          retry\n        rescue  Errno::EPIPE, SystemCallError, IOError\n          raise ConnectionError, \"Socket timeout writing data\"\n        end\n\n        return if n == str.bytesize\n        str = str.byteslice(n..-1)\n      end\n    end\n    private :fast_write\n\n    # @param status [Integer] status from the app\n    # @return [String] the text description from Puma::HTTP_STATUS_CODES\n    #\n    def fetch_status_code(status)\n      HTTP_STATUS_CODES.fetch(status) { 'CUSTOM' }\n    end\n    private :fetch_status_code\n\n    # Given a Hash +env+ for the request read from +client+, add\n    # and fixup keys to comply with Rack's env guidelines.\n    # @param env [Hash] see Puma::Client#env, from request\n    # @param client [Puma::Client] only needed for Client#peerip\n    # @todo make private in 6.0.0\n    #\n    def normalize_env(env, client)\n      if host = env[HTTP_HOST]\n        # host can be a hostname, ipv4 or bracketed ipv6. Followed by an optional port.\n        if colon = host.rindex(\"]:\") # IPV6 with port\n          env[SERVER_NAME] = host[0, colon+1]\n          env[SERVER_PORT] = host[colon+2, host.bytesize]\n        elsif !host.start_with?(\"[\") && colon = host.index(\":\") # not hostname or IPV4 with port\n          env[SERVER_NAME] = host[0, colon]\n          env[SERVER_PORT] = host[colon+1, host.bytesize]\n        else\n          env[SERVER_NAME] = host\n          env[SERVER_PORT] = default_server_port(env)\n        end\n      else\n        env[SERVER_NAME] = LOCALHOST\n        env[SERVER_PORT] = default_server_port(env)\n      end\n\n      unless env[REQUEST_PATH]\n        # it might be a dumbass full host request header\n        uri = URI.parse(env[REQUEST_URI])\n        env[REQUEST_PATH] = uri.path\n\n        raise \"No REQUEST PATH\" unless env[REQUEST_PATH]\n\n        # A nil env value will cause a LintError (and fatal errors elsewhere),\n        # so only set the env value if there actually is a value.\n        env[QUERY_STRING] = uri.query if uri.query\n      end\n\n      env[PATH_INFO] = env[REQUEST_PATH]\n\n      # From https://www.ietf.org/rfc/rfc3875 :\n      # \"Script authors should be aware that the REMOTE_ADDR and\n      # REMOTE_HOST meta-variables (see sections 4.1.8 and 4.1.9)\n      # may not identify the ultimate source of the request.\n      # They identify the client for the immediate request to the\n      # server; that client may be a proxy, gateway, or other\n      # intermediary acting on behalf of the actual source client.\"\n      #\n\n      unless env.key?(REMOTE_ADDR)\n        begin\n          addr = client.peerip\n        rescue Errno::ENOTCONN\n          # Client disconnects can result in an inability to get the\n          # peeraddr from the socket; default to localhost.\n          addr = LOCALHOST_IP\n        end\n\n        # Set unix socket addrs to localhost\n        addr = LOCALHOST_IP if addr.empty?\n\n        env[REMOTE_ADDR] = addr\n      end\n    end\n    # private :normalize_env\n\n    # @param header_key [#to_s]\n    # @return [Boolean]\n    #\n    def illegal_header_key?(header_key)\n      !!(ILLEGAL_HEADER_KEY_REGEX =~ header_key.to_s)\n    end\n\n    # @param header_value [#to_s]\n    # @return [Boolean]\n    #\n    def illegal_header_value?(header_value)\n      !!(ILLEGAL_HEADER_VALUE_REGEX =~ header_value.to_s)\n    end\n    private :illegal_header_key?, :illegal_header_value?\n\n    # Fixup any headers with `,` in the name to have `_` now. We emit\n    # headers with `,` in them during the parse phase to avoid ambiguity\n    # with the `-` to `_` conversion for critical headers. But here for\n    # compatibility, we'll convert them back. This code is written to\n    # avoid allocation in the common case (ie there are no headers\n    # with `,` in their names), that's why it has the extra conditionals.\n    # @param env [Hash] see Puma::Client#env, from request, modifies in place\n    # @version 5.0.3\n    #\n    def req_env_post_parse(env)\n      to_delete = nil\n      to_add = nil\n\n      env.each do |k,v|\n        if k.start_with?(\"HTTP_\") and k.include?(\",\") and k != \"HTTP_TRANSFER,ENCODING\"\n          if to_delete\n            to_delete << k\n          else\n            to_delete = [k]\n          end\n\n          unless to_add\n            to_add = {}\n          end\n\n          to_add[k.tr(\",\", \"_\")] = v\n        end\n      end\n\n      if to_delete\n        to_delete.each { |k| env.delete(k) }\n        env.merge! to_add\n      end\n    end\n    private :req_env_post_parse\n\n    # Used in the lambda for env[ `Puma::Const::EARLY_HINTS` ]\n    # @param headers [Hash] the headers returned by the Rack application\n    # @return [String]\n    # @version 5.0.3\n    #\n    def str_early_hints(headers)\n      eh_str = \"HTTP/1.1 103 Early Hints\\r\\n\".dup\n      headers.each_pair do |k, vs|\n        next if illegal_header_key?(k)\n\n        if vs.respond_to?(:to_s) && !vs.to_s.empty?\n          vs.to_s.split(NEWLINE).each do |v|\n            next if illegal_header_value?(v)\n            eh_str << \"#{k}: #{v}\\r\\n\"\n          end\n        else\n          eh_str << \"#{k}: #{vs}\\r\\n\"\n        end\n      end\n      \"#{eh_str}\\r\\n\".freeze\n    end\n    private :str_early_hints\n\n    # Processes and write headers to the IOBuffer.\n    # @param env [Hash] see Puma::Client#env, from request\n    # @param status [Integer] the status returned by the Rack application\n    # @param headers [Hash] the headers returned by the Rack application\n    # @param res_info [Hash] used to pass info between this method and #handle_request\n    # @param lines [Puma::IOBuffer] modified inn place\n    # @param requests [Integer] number of inline requests handled\n    # @param client [Puma::Client]\n    # @version 5.0.3\n    #\n    def str_headers(env, status, headers, res_info, lines, requests, client)\n      line_ending = LINE_END\n      colon = COLON\n\n      http_11 = env[HTTP_VERSION] == HTTP_11\n      if http_11\n        res_info[:allow_chunked] = true\n        res_info[:keep_alive] = env.fetch(HTTP_CONNECTION, \"\").downcase != CLOSE\n\n        # An optimization. The most common response is 200, so we can\n        # reply with the proper 200 status without having to compute\n        # the response header.\n        #\n        if status == 200\n          lines << HTTP_11_200\n        else\n          lines.append \"HTTP/1.1 \", status.to_s, \" \",\n                       fetch_status_code(status), line_ending\n\n          res_info[:no_body] ||= status < 200 || STATUS_WITH_NO_ENTITY_BODY[status]\n        end\n      else\n        res_info[:allow_chunked] = false\n        res_info[:keep_alive] = env.fetch(HTTP_CONNECTION, \"\").downcase == KEEP_ALIVE\n\n        # Same optimization as above for HTTP/1.1\n        #\n        if status == 200\n          lines << HTTP_10_200\n        else\n          lines.append \"HTTP/1.0 \", status.to_s, \" \",\n                       fetch_status_code(status), line_ending\n\n          res_info[:no_body] ||= status < 200 || STATUS_WITH_NO_ENTITY_BODY[status]\n        end\n      end\n\n      # regardless of what the client wants, we always close the connection\n      # if running without request queueing\n      res_info[:keep_alive] &&= @queue_requests\n\n      # Close the connection after a reasonable number of inline requests\n      # if the server is at capacity and the listener has a new connection ready.\n      # This allows Puma to service connections fairly when the number\n      # of concurrent connections exceeds the size of the threadpool.\n      res_info[:keep_alive] &&= requests < @max_fast_inline ||\n        @thread_pool.busy_threads < @max_threads ||\n        !client.listener.to_io.wait_readable(0)\n\n      res_info[:response_hijack] = nil\n\n      headers.each do |k, vs|\n        next if illegal_header_key?(k)\n\n        case k.downcase\n        when CONTENT_LENGTH2\n          next if illegal_header_value?(vs)\n          res_info[:content_length] = vs\n          next\n        when TRANSFER_ENCODING\n          res_info[:allow_chunked] = false\n          res_info[:content_length] = nil\n        when HIJACK\n          res_info[:response_hijack] = vs\n          next\n        when BANNED_HEADER_KEY\n          next\n        end\n\n        if vs.respond_to?(:to_s) && !vs.to_s.empty?\n          vs.to_s.split(NEWLINE).each do |v|\n            next if illegal_header_value?(v)\n            lines.append k, colon, v, line_ending\n          end\n        else\n          lines.append k, colon, line_ending\n        end\n      end\n\n      # HTTP/1.1 & 1.0 assume different defaults:\n      # - HTTP 1.0 assumes the connection will be closed if not specified\n      # - HTTP 1.1 assumes the connection will be kept alive if not specified.\n      # Only set the header if we're doing something which is not the default\n      # for this protocol version\n      if http_11\n        lines << CONNECTION_CLOSE if !res_info[:keep_alive]\n      else\n        lines << CONNECTION_KEEP_ALIVE if res_info[:keep_alive]\n      end\n    end\n    private :str_headers\n  end\nend\n"], "filenames": ["lib/puma/request.rb"], "buggy_code_start_loc": [174], "buggy_code_end_loc": [179], "fixing_code_start_loc": [174], "fixing_code_end_loc": [184], "type": "CWE-200", "message": "Puma is a Ruby/Rack web server built for parallelism. Prior to `puma` version `5.6.2`, `puma` may not always call `close` on the response body. Rails, prior to version `7.0.2.2`, depended on the response body being closed in order for its `CurrentAttributes` implementation to work correctly. The combination of these two behaviors (Puma not closing the body + Rails' Executor implementation) causes information leakage. This problem is fixed in Puma versions 5.6.2 and 4.3.11. This problem is fixed in Rails versions 7.02.2, 6.1.4.6, 6.0.4.6, and 5.2.6.2. Upgrading to a patched Rails _or_ Puma version fixes the vulnerability.", "other": {"cve": {"id": "CVE-2022-23634", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-11T22:15:07.817", "lastModified": "2022-10-12T13:17:39.330", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Puma is a Ruby/Rack web server built for parallelism. Prior to `puma` version `5.6.2`, `puma` may not always call `close` on the response body. Rails, prior to version `7.0.2.2`, depended on the response body being closed in order for its `CurrentAttributes` implementation to work correctly. The combination of these two behaviors (Puma not closing the body + Rails' Executor implementation) causes information leakage. This problem is fixed in Puma versions 5.6.2 and 4.3.11. This problem is fixed in Rails versions 7.02.2, 6.1.4.6, 6.0.4.6, and 5.2.6.2. Upgrading to a patched Rails _or_ Puma version fixes the vulnerability."}, {"lang": "es", "value": "Puma es un servidor web Ruby/Rack construido para el paralelismo. versiones anteriores a \"puma\" \"5.6.2\", \"puma\" no siempre llamaba a \"close\" en el cuerpo de la respuesta. Rails, versiones anteriores a \"7.0.2.2\", depend\u00eda de que el cuerpo de la respuesta estuviera cerrado para que su implementaci\u00f3n de \"CurrentAttributes\" funcionara correctamente. La combinaci\u00f3n de estos dos comportamientos (que Puma no cierre el cuerpo + la implementaci\u00f3n del ejecutor de Rails) causa un filtrado de informaci\u00f3n. Este problema ha sido solucionado en Puma versiones 5.6.2 y 4.3.11. Este problema se ha solucionado en las versiones de Rails versiones 7.02.2, 6.1.4.6, 6.0.4.6 y 5.2.6.2. La actualizaci\u00f3n a una versi\u00f3n parcheada de Rails _o_ de Puma corrige esta vulnerabilidad"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.8}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:puma:puma:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "4.3.11", "matchCriteriaId": "F662913A-D835-400A-BE47-112269F1A880"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puma:puma:*:*:*:*:*:ruby:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.6.2", "matchCriteriaId": "3221F00A-D4F8-43C2-90D0-98D38E5294B8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.2.6.2", "matchCriteriaId": "799C8F9A-10DD-4840-AAB5-F444DDA46FE2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0.0", "versionEndExcluding": "6.0.4.6", "matchCriteriaId": "CB7B860B-0F93-4C93-8C95-29D259A38C43"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.1.0", "versionEndExcluding": "6.1.4.6", "matchCriteriaId": "A8FC3F82-3521-470B-910E-395895BAB248"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0", "versionEndExcluding": "7.0.2.2", "matchCriteriaId": "AC6C96FF-285D-4378-86FF-AFB70FC339A3"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}], "references": [{"url": "https://github.com/advisories/GHSA-rmj8-8hhh-gv5h", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/advisories/GHSA-wh98-p28r-vrc9", "source": "security-advisories@github.com", "tags": ["Mitigation", "Not Applicable", "Third Party Advisory"]}, {"url": "https://github.com/puma/puma/commit/b70f451fe8abc0cff192c065d549778452e155bb", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/puma/puma/security/advisories/GHSA-rmj8-8hhh-gv5h", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://groups.google.com/g/ruby-security-ann/c/FkTM-_7zSNA/m/K2RiMJBlBAAJ?utm_medium=email&utm_source=footer&pli=1", "source": "security-advisories@github.com", "tags": ["Mailing List", "Mitigation", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/05/msg00034.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/08/msg00015.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/F6YWGIIKL7KKTS3ZOAYMYPC7D6WQ5OA5/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/L7NESIBFCNSR3XH7LXDPKVMSUBNUB43G/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TUBFJ44NCKJ34LECZRAP4N5VL6USJSIB/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-28", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5146", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/puma/puma/commit/b70f451fe8abc0cff192c065d549778452e155bb"}}