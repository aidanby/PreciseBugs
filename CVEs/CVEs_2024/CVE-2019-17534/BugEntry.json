{"buggy_code": ["/* load a GIF with giflib\n *\n * 10/2/16\n * \t- from svgload.c\n * 25/4/16\n * \t- add giflib5 support\n * 26/7/16\n * \t- transparency was wrong if there was no EXTENSION_RECORD\n * \t- write 1, 2, 3, or 4 bands depending on file contents\n * 17/8/16\n * \t- support unicode on win\n * 19/8/16\n * \t- better transparency detection, thanks diegocsandrim\n * 25/11/16\n * \t- support @n, page-height\n * 5/10/17\n * \t- colormap can be missing thanks Kleis\n * 21/11/17\n * \t- add \"gif-delay\", \"gif-loop\", \"gif-comment\" metadata\n * \t- add dispose handling\n * 13/8/18\n * \t- init pages to 0 before load\n * 14/2/19\n * \t- rework as a sequential loader ... simpler, much lower mem use\n * 23/8/18\n * \t- allow GIF read errors during header scan\n * \t- better feof() handling\n */\n\n/*\n\n    This file is part of VIPS.\n    \n    VIPS is free software; you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n    02110-1301  USA\n\n */\n\n/*\n\n    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk\n\n */\n\n/*\n#define DEBUG_VERBOSE\n#define VIPS_DEBUG\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif /*HAVE_CONFIG_H*/\n#include <vips/intl.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <ctype.h>\n\n#include <vips/vips.h>\n#include <vips/buf.h>\n#include <vips/internal.h>\n#include <vips/debug.h>\n\n#ifdef HAVE_GIFLIB\n\n#include <gif_lib.h>\n\n/* giflib 5 is rather different :-( functions have error returns and there's\n * no LastError().\n *\n * GIFLIB_MAJOR was introduced in 4.1.6. Use it to test for giflib 5.x.\n */\n#ifdef GIFLIB_MAJOR\n#  if GIFLIB_MAJOR > 4\n#    define HAVE_GIFLIB_5\n#  endif\n#endif\n\n/* Added in giflib5.\n */\n#ifndef HAVE_GIFLIB_5\n#define DISPOSAL_UNSPECIFIED      0       \n#define DISPOSE_DO_NOT            1      \n#define DISPOSE_BACKGROUND        2     \n#define DISPOSE_PREVIOUS          3    \n#endif\n\n#define VIPS_TYPE_FOREIGN_LOAD_GIF (vips_foreign_load_gif_get_type())\n#define VIPS_FOREIGN_LOAD_GIF( obj ) \\\n\t(G_TYPE_CHECK_INSTANCE_CAST( (obj), \\\n\tVIPS_TYPE_FOREIGN_LOAD_GIF, VipsForeignLoadGif ))\n#define VIPS_FOREIGN_LOAD_GIF_CLASS( klass ) \\\n\t(G_TYPE_CHECK_CLASS_CAST( (klass), \\\n\tVIPS_TYPE_FOREIGN_LOAD_GIF, VipsForeignLoadGifClass))\n#define VIPS_IS_FOREIGN_LOAD_GIF( obj ) \\\n\t(G_TYPE_CHECK_INSTANCE_TYPE( (obj), VIPS_TYPE_FOREIGN_LOAD_GIF ))\n#define VIPS_IS_FOREIGN_LOAD_GIF_CLASS( klass ) \\\n\t(G_TYPE_CHECK_CLASS_TYPE( (klass), VIPS_TYPE_FOREIGN_LOAD_GIF ))\n#define VIPS_FOREIGN_LOAD_GIF_GET_CLASS( obj ) \\\n\t(G_TYPE_INSTANCE_GET_CLASS( (obj), \\\n\tVIPS_TYPE_FOREIGN_LOAD_GIF, VipsForeignLoadGifClass ))\n\ntypedef struct _VipsForeignLoadGif {\n\tVipsForeignLoad parent_object;\n\n\t/* Load from this page (frame number).\n\t */\n\tint page;\n\n\t/* Load this many pages.\n\t */\n\tint n;\n\n\tGifFileType *file;\n\n\t/* We decompress the whole thing to a huge RGBA memory image, and\n\t * as we render, watch for bands and transparency. At the end of\n\t * loading, we copy 1 or 3 bands, with or without transparency to\n\t * output.\n\t */\n\tgboolean has_transparency;\n\tgboolean has_colour;\n\n\t/* Delay in 1/100ths of a second. We only track a single delay \n\t * value for the whole file, and we report the first delay we see. Some\n\t * GIFs have a long delay on the final frame.\n\t */\n\tgboolean has_delay;\n\tint delay;\n\n\t/* Number of times to loop the animation.\n\t */\n\tint loop;\n\n\t/* The GIF comment, if any.\n\t */\n\tchar *comment; \n\n\t/* The number of pages (frame) in the image.\n\t */\n\tint n_pages;\n\n\t/* A memory image the sized of one frame ... we accumulate to this as\n\t * we scan the image, and copy lines to the output on generate.\n\t */\n\tVipsImage *frame;\n\n\t/* A copy of the previous frame, in case we need a DISPOSE_PREVIOUS.\n\t */\n\tVipsImage *previous;\n\n\t/* The position of @frame, in pages.\n\t */\n\tint current_page;\n\n\t/* Decompress lines of the gif file to here.\n\t */\n\tGifPixelType *line;\n\n\t/* The current dispose method.\n\t */\n\tint dispose;\n\n\t/* Set for EOF detected.\n\t */\n\tgboolean eof;\n\n\t/* The current cmap unpacked to a simple LUT. Each uint32 is really an\n\t * RGBA pixel ready to be blasted into @frame.\n\t */\n\tguint32 cmap[256];\n\n\t/* As we scan the file, the index of the transparent pixel for this\n\t * frame.\n\t */\n\tint transparency;\n\n\t/* Params for DGifOpen(). Set by subclasses, called by base class in\n\t * _open().\n\t */\n\tInputFunc read_func;\n\n} VipsForeignLoadGif;\n\ntypedef struct _VipsForeignLoadGifClass {\n\tVipsForeignLoadClass parent_class;\n\n\t/* Close and reopen gif->file.\n\t */\n\tint (*open)( VipsForeignLoadGif *gif );\n} VipsForeignLoadGifClass;\n\nG_DEFINE_ABSTRACT_TYPE( VipsForeignLoadGif, vips_foreign_load_gif, \n\tVIPS_TYPE_FOREIGN_LOAD );\n\n/* From gif2rgb.c ... offsets and jumps for interlaced GIF images.\n */\nstatic int \n\tInterlacedOffset[] = { 0, 4, 2, 1 },\n\tInterlacedJumps[] = { 8, 8, 4, 2 };\n\n/* giflib4 was missing this.\n */\nstatic const char *\nvips_foreign_load_gif_errstr( int error_code )\n{\n#ifdef HAVE_GIFLIB_5\n\treturn( GifErrorString( error_code ) ); \n#else /*!HAVE_GIFLIB_5*/\n\tswitch( error_code ) {\n\tcase D_GIF_ERR_OPEN_FAILED:\n\t\treturn( _( \"Failed to open given file\" ) ); \n\n\tcase D_GIF_ERR_READ_FAILED:\n\t\treturn( _( \"Failed to read from given file\" ) ); \n\n\tcase D_GIF_ERR_NOT_GIF_FILE:\n\t\treturn( _( \"Data is not a GIF file\" ) ); \n\n\tcase D_GIF_ERR_NO_SCRN_DSCR:\n\t\treturn( _( \"No screen descriptor detected\" ) ); \n\n\tcase D_GIF_ERR_NO_IMAG_DSCR:\n\t\treturn( _( \"No image descriptor detected\" ) ); \n\n\tcase D_GIF_ERR_NO_COLOR_MAP:\n\t\treturn( _( \"Neither global nor local color map\" ) ); \n\n\tcase D_GIF_ERR_WRONG_RECORD:\n\t\treturn( _( \"Wrong record type detected\" ) ); \n\n\tcase D_GIF_ERR_DATA_TOO_BIG:\n\t\treturn( _( \"Number of pixels bigger than width * height\" ) ); \n\n\tcase D_GIF_ERR_NOT_ENOUGH_MEM:\n\t\treturn( _( \"Failed to allocate required memory\" ) ); \n\n\tcase D_GIF_ERR_CLOSE_FAILED:\n\t\treturn( _( \"Failed to close given file\" ) ); \n\n\tcase D_GIF_ERR_NOT_READABLE:\n\t\treturn( _( \"Given file was not opened for read\" ) ); \n\n\tcase D_GIF_ERR_IMAGE_DEFECT:\n\t\treturn( _( \"Image is defective, decoding aborted\" ) ); \n\n\tcase D_GIF_ERR_EOF_TOO_SOON:\n\t\treturn( _( \"Image EOF detected, before image complete\" ) ); \n\n\tdefault:\n\t\treturn( _( \"Unknown error\" ) ); \n\t}\n#endif /*HAVE_GIFLIB_5*/\n}\n\nstatic void\nvips_foreign_load_gif_error_vips( VipsForeignLoadGif *gif, int error )\n{\n\tVipsObjectClass *class = VIPS_OBJECT_GET_CLASS( gif );\n\n\tconst char *message;\n\n\tif( (message = vips_foreign_load_gif_errstr( error )) )\n\t\tvips_error( class->nickname, \"%s\", message ); \n}\n\nstatic void\nvips_foreign_load_gif_error( VipsForeignLoadGif *gif )\n{\n\tint error;\n\n\terror = 0;\n\n#ifdef HAVE_GIFLIB_5\n\tif( gif->file ) \n\t\terror = gif->file->Error;\n#else \n\terror = GifLastError(); \n#endif\n\n\tif( error ) \n\t\tvips_foreign_load_gif_error_vips( gif, error ); \n}\n\nstatic void\nvips_foreign_load_gif_close( VipsForeignLoadGif *gif )\n{\n#ifdef HAVE_GIFLIB_5\n\tif( gif->file ) {\n\t\tint error; \n\n\t\tif( DGifCloseFile( gif->file, &error ) == GIF_ERROR ) \n\t\t\tvips_foreign_load_gif_error_vips( gif, error );\n\t\tgif->file = NULL;\n\t}\n#else \n\tif( gif->file ) {\n\t\tif( DGifCloseFile( gif->file ) == GIF_ERROR ) \n\t\t\tvips_foreign_load_gif_error_vips( gif, GifLastError() ); \n\t\tgif->file = NULL;\n\t}\n#endif\n}\n\nstatic void\nvips_foreign_load_gif_dispose( GObject *gobject )\n{\n\tVipsForeignLoadGif *gif = (VipsForeignLoadGif *) gobject;\n\n\tvips_foreign_load_gif_close( gif ); \n\n\tVIPS_UNREF( gif->frame ); \n\tVIPS_UNREF( gif->previous ); \n\tVIPS_FREE( gif->comment ); \n\tVIPS_FREE( gif->line ) \n\n\tG_OBJECT_CLASS( vips_foreign_load_gif_parent_class )->\n\t\tdispose( gobject );\n}\n\nstatic VipsForeignFlags\nvips_foreign_load_gif_get_flags_filename( const char *filename )\n{\n\treturn( VIPS_FOREIGN_SEQUENTIAL );\n}\n\nstatic VipsForeignFlags\nvips_foreign_load_gif_get_flags( VipsForeignLoad *load )\n{\n\treturn( VIPS_FOREIGN_SEQUENTIAL );\n}\n\nstatic gboolean\nvips_foreign_load_gif_is_a_buffer( const void *buf, size_t len )\n{\n\tconst guchar *str = (const guchar *) buf;\n\n\tif( len >= 4 &&\n\t\tstr[0] == 'G' && \n\t\tstr[1] == 'I' &&\n\t\tstr[2] == 'F' &&\n\t\tstr[3] == '8' )\n\t\treturn( 1 );\n\n\treturn( 0 );\n}\n\nstatic gboolean\nvips_foreign_load_gif_is_a( const char *filename )\n{\n\tunsigned char buf[4];\n\n\tif( vips__get_bytes( filename, buf, 4 ) == 4 &&\n\t\tvips_foreign_load_gif_is_a_buffer( buf, 4 ) )\n\t\treturn( 1 );\n\n\treturn( 0 );\n}\n\nstatic int\nvips_foreign_load_gif_ext_next( VipsForeignLoadGif *gif, \n\tGifByteType **extension )\n{\n\tif( DGifGetExtensionNext( gif->file, extension ) == GIF_ERROR ) {\n\t\tvips_foreign_load_gif_error( gif ); \n\t\treturn( -1 ); \n\t}\n\n\tif( *extension ) \n\t\tVIPS_DEBUG_MSG( \"gifload: EXTENSION_NEXT\\n\" ); \n\n\treturn( 0 );\n}\n\nstatic int\nvips_foreign_load_gif_code_next( VipsForeignLoadGif *gif, \n\tGifByteType **extension )\n{\n\tif( DGifGetCodeNext( gif->file, extension ) == GIF_ERROR ) {\n\t\tvips_foreign_load_gif_error( gif ); \n\t\treturn( -1 ); \n\t}\n\n\tif( *extension ) \n\t\tVIPS_DEBUG_MSG( \"gifload: CODE_NEXT\\n\" ); \n\n\treturn( 0 );\n}\n\n/* Quickly scan an image record.\n */\nstatic int\nvips_foreign_load_gif_scan_image( VipsForeignLoadGif *gif ) \n{\n\tVipsObjectClass *class = VIPS_OBJECT_GET_CLASS( gif );\n\tGifFileType *file = gif->file;\n\tColorMapObject *map = file->Image.ColorMap ?\n\t\tfile->Image.ColorMap : file->SColorMap;\n\n\tGifByteType *extension;\n\n\tif( DGifGetImageDesc( gif->file ) == GIF_ERROR ) {\n\t\tvips_foreign_load_gif_error( gif ); \n\t\treturn( -1 );\n\t}\n\n\t/* Check that the frame looks sane. Perhaps giflib checks\n\t * this for us.\n\t */\n\tif( file->Image.Left < 0 ||\n\t\tfile->Image.Width < 1 ||\n\t\tfile->Image.Width > 10000 ||\n\t\tfile->Image.Left + file->Image.Width > file->SWidth ||\n\t\tfile->Image.Top < 0 ||\n\t\tfile->Image.Height < 1 ||\n\t\tfile->Image.Height > 10000 ||\n\t\tfile->Image.Top + file->Image.Height > file->SHeight ) {\n\t\tvips_error( class->nickname, \"%s\", _( \"bad frame size\" ) ); \n\t\treturn( -1 ); \n\t}\n\n\t/* Test for a non-greyscale colourmap for this frame.\n\t */\n\tif( !gif->has_colour &&\n\t\tmap ) {\n\t\tint i;\n\n\t\tfor( i = 0; i < map->ColorCount; i++ ) \n\t\t\tif( map->Colors[i].Red != map->Colors[i].Green ||\n\t\t\t\tmap->Colors[i].Green != map->Colors[i].Blue ) {\n\t\t\t\tgif->has_colour = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t/* Step over compressed image data.\n\t */\n\tdo {\n\t\tif( vips_foreign_load_gif_code_next( gif, &extension ) ) \n\t\t\treturn( -1 );\n\t} while( extension != NULL );\n\n\treturn( 0 );\n}\n\nstatic int\nvips_foreign_load_gif_scan_application_ext( VipsForeignLoadGif *gif,\n\tGifByteType *extension )\n{\n\tgboolean have_netscape;\n\n\t/* The 11-byte NETSCAPE extension.\n\t */\n\thave_netscape = FALSE;\n\tif( extension[0] == 11 &&\n\t\tvips_isprefix( \"NETSCAPE2.0\", (const char*) (extension + 1) ) ) \n\t\thave_netscape = TRUE;\n\n\twhile( extension != NULL ) {\n\t\tif( vips_foreign_load_gif_ext_next( gif, &extension ) )\n\t\t\treturn( -1 ); \n\n\t\tif( have_netscape &&\n\t\t\textension &&\n\t\t\textension[0] == 3 &&\n\t\t\textension[1] == 1 ) \n\t\t\tgif->loop = extension[2] | (extension[3] << 8);\n\t}\n\n\treturn( 0 );\n}\n\nstatic int\nvips_foreign_load_gif_scan_comment_ext( VipsForeignLoadGif *gif,\n\tGifByteType *extension )\n{\n\tVIPS_DEBUG_MSG( \"gifload: type: comment\\n\" ); \n\n\tif( !gif->comment ) { \n\t\t/* Up to 257 with a NULL terminator.\n\t\t */\n\t\tchar comment[257];\n\n\t\tvips_strncpy( comment, (char *) (extension + 1), 256 );\n\t\tcomment[extension[0]] = '\\0';\n\t\tgif->comment = g_strdup( comment ); \n\t}\n\n\twhile( extension != NULL ) \n\t\tif( vips_foreign_load_gif_ext_next( gif, &extension ) )\n\t\t\treturn( -1 ); \n\n\treturn( 0 );\n}\n\nstatic int\nvips_foreign_load_gif_scan_extension( VipsForeignLoadGif *gif )\n{\n\tGifByteType *extension;\n\tint ext_code;\n\n\tif( DGifGetExtension( gif->file, &ext_code, &extension ) == \n\t\tGIF_ERROR ) {\n\t\tvips_foreign_load_gif_error( gif ); \n\t\treturn( -1 ); \n\t}\n\n\tif( extension ) \n\t\tswitch( ext_code ) { \n\t\tcase GRAPHICS_EXT_FUNC_CODE: \n\t\t\tif( extension[0] == 4 &&\n\t\t\t\textension[1] & 0x1 ) {\n\t\t\t\tVIPS_DEBUG_MSG( \"gifload: has transp.\\n\" ); \n\t\t\t\tgif->has_transparency = TRUE;\n\t\t\t}\n\n\t\t\tif( !gif->has_delay ) { \n\t\t\t\tVIPS_DEBUG_MSG( \"gifload: has delay\\n\" ); \n\t\t\t\tgif->has_delay = TRUE;\n\t\t\t\tgif->delay = extension[2] | (extension[3] << 8);\n\t\t\t}\n\n\t\t\twhile( extension != NULL ) \n\t\t\t\tif( vips_foreign_load_gif_ext_next( gif, \n\t\t\t\t\t&extension ) )\n\t\t\t\t\treturn( -1 ); \n\n\t\t\tbreak;\n\n\t\tcase APPLICATION_EXT_FUNC_CODE: \n\t\t\tif( vips_foreign_load_gif_scan_application_ext( gif, \n\t\t\t\textension ) )\n\t\t\t\treturn( -1 ); \n\t\t\tbreak;\n\n\t\tcase COMMENT_EXT_FUNC_CODE:\n\t\t\tif( vips_foreign_load_gif_scan_comment_ext( gif, \n\t\t\t\textension ) )\n\t\t\t\treturn( -1 ); \n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Step over any NEXT blocks for unknown extensions.\n\t\t\t */\n\t\t\twhile( extension != NULL ) \n\t\t\t\tif( vips_foreign_load_gif_ext_next( gif, \n\t\t\t\t\t&extension ) )\n\t\t\t\t\treturn( -1 ); \n\t\t\tbreak;\n\t\t}\n\n\treturn( 0 );\n}\n\nstatic int\nvips_foreign_load_gif_set_header( VipsForeignLoadGif *gif, VipsImage *image )\n{\n\tvips_image_init_fields( image,\n\t\tgif->file->SWidth, gif->file->SHeight * gif->n, \n\t\t(gif->has_colour ? 3 : 1) + (gif->has_transparency ? 1 : 0),\n\t\tVIPS_FORMAT_UCHAR, VIPS_CODING_NONE,\n\t\tgif->has_colour ? \n\t\t \tVIPS_INTERPRETATION_sRGB : VIPS_INTERPRETATION_B_W,\n\t\t1.0, 1.0 );\n\tvips_image_pipelinev( image, VIPS_DEMAND_STYLE_FATSTRIP, NULL );\n\n\tif( vips_object_argument_isset( VIPS_OBJECT( gif ), \"n\" ) )\n\t\tvips_image_set_int( image, \n\t\t\tVIPS_META_PAGE_HEIGHT, gif->file->SHeight );\n\tvips_image_set_int( image, VIPS_META_N_PAGES, gif->n_pages );\n\tvips_image_set_int( image, \"gif-delay\", gif->delay );\n\tvips_image_set_int( image, \"gif-loop\", gif->loop );\n\tif( gif->comment ) \n\t\tvips_image_set_string( image, \"gif-comment\", gif->comment );\n\n\treturn( 0 );\n}\n\n/* Attempt to quickly scan a GIF and discover what we need for our header. We\n * need to scan the whole file to get n_pages, transparency and colour. \n *\n * Don't flag errors during header scan. Many GIFs do not follow spec.\n */\nstatic int\nvips_foreign_load_gif_header( VipsForeignLoad *load )\n{\n\tVipsObjectClass *class = VIPS_OBJECT_GET_CLASS( load );\n\tVipsForeignLoadGifClass *gif_class = \n\t\t(VipsForeignLoadGifClass *) VIPS_OBJECT_GET_CLASS( load );\n\tVipsForeignLoadGif *gif = (VipsForeignLoadGif *) load;\n\n\tGifRecordType record;\n\n\tif( gif_class->open( gif ) )\n\t\treturn( -1 );\n\n\tgif->n_pages = 0;\n\n\tdo {\n\t\tif( DGifGetRecordType( gif->file, &record ) == GIF_ERROR ) \n\t\t\tcontinue;\n\n\t\tswitch( record ) {\n\t\tcase IMAGE_DESC_RECORD_TYPE:\n\t\t\t(void) vips_foreign_load_gif_scan_image( gif );\n\n\t\t\tgif->n_pages += 1;\n\n\t\t\tbreak;\n\n\t\tcase EXTENSION_RECORD_TYPE:\n\t\t\t/* We will need to fetch the extensions to check for\n\t\t\t * cmaps and transparency.\n\t\t\t */\n\t\t\t(void) vips_foreign_load_gif_scan_extension( gif );\n\t\t\tbreak;\n\n\t\tcase TERMINATE_RECORD_TYPE:\n\t\t\tgif->eof = TRUE;\n\t\t\tbreak;\n\n\t\tcase SCREEN_DESC_RECORD_TYPE:\n\t\tcase UNDEFINED_RECORD_TYPE:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} while( !gif->eof );\n\n\tif( gif->n == -1 )\n\t\tgif->n = gif->n_pages - gif->page;\n\n\tif( gif->page < 0 ||\n\t\tgif->n <= 0 ||\n\t\tgif->page + gif->n > gif->n_pages ) {\n\t\tvips_error( class->nickname, \"%s\", _( \"bad page number\" ) ); \n\t\treturn( -1 ); \n\t}\n\n\t/* And set the output vips header from what we've learned.\n\t */\n\tif( vips_foreign_load_gif_set_header( gif, load->out ) )\n\t\treturn( -1 );\n\n\treturn( 0 );\n}\n\nstatic void\nvips_foreign_load_gif_build_cmap( VipsForeignLoadGif *gif )\n{\n\tColorMapObject *map = gif->file->Image.ColorMap ?\n\t\tgif->file->Image.ColorMap : gif->file->SColorMap;\n\n\tint v;\n\n\tfor( v = 0; v < 256; v++ ) {\n\t\tVipsPel *q = (VipsPel *) &gif->cmap[v];\n\n\t\tif( map &&\n\t\t\tv < map->ColorCount ) {\n\t\t\tq[0] = map->Colors[v].Red;\n\t\t\tq[1] = map->Colors[v].Green;\n\t\t\tq[2] = map->Colors[v].Blue;\n\t\t\tq[3] = 255;\n\t\t}\n\t\telse {\n\t\t\t/* If there's no map, just save the index.\n\t\t\t */\n\t\t\tq[0] = v;\n\t\t\tq[1] = v;\n\t\t\tq[2] = v;\n\t\t\tq[3] = 255;\n\t\t}\n\t}\n}\n\nstatic void\nvips_foreign_load_gif_render_line( VipsForeignLoadGif *gif,\n\tint width, VipsPel * restrict q, VipsPel * restrict p )\n{\n\tguint32 *iq;\n\tint x;\n\n\tiq = (guint32 *) q;\n\tfor( x = 0; x < width; x++ ) {\n\t\tVipsPel v = p[x];\n\t\t\n\t\tif( v == gif->transparency ) {\n\t\t\t/* In DISPOSE_DO_NOT mode, the previous frame shows\n\t\t\t * through (ie. we do nothing). In all other modes, \n\t\t\t * it's just transparent.\n\t\t\t */\n\t\t\tif( gif->dispose != DISPOSE_DO_NOT ) \n\t\t\t\tiq[x] = 0;\n\t\t}\n\t\telse\n\t\t\t/* Blast in the RGBA for this value.\n\t\t\t */\n\t\t\tiq[x] = gif->cmap[v];\n\t}\n}\n\n/* Render the current gif frame into an RGBA buffer. GIFs can accumulate, \n * depending on the current dispose mode.\n */\nstatic int\nvips_foreign_load_gif_render( VipsForeignLoadGif *gif ) \n{\n\tGifFileType *file = gif->file;\n\n\t/* Update the colour map for this frame.\n\t */\n\tvips_foreign_load_gif_build_cmap( gif );\n\n\t/* BACKGROUND means we reset the frame to 0 (transparent) before we \n\t * render the next set of pixels.\n\t */\n\tif( gif->dispose == DISPOSE_BACKGROUND ) \n\t\tmemset( VIPS_IMAGE_ADDR( gif->frame, 0, 0 ), 0, \n\t\t\tVIPS_IMAGE_SIZEOF_IMAGE( gif->frame ) );\n\n\t/* PREVIOUS means we init the frame with the frame before last, ie. we\n\t * undo the last render.\n\t *\n\t * Anything other than PREVIOUS, we must update the previous buffer,\n\t */\n\tif( gif->dispose == DISPOSE_PREVIOUS ) \n\t\tmemcpy( VIPS_IMAGE_ADDR( gif->frame, 0, 0 ),\n\t\t\tVIPS_IMAGE_ADDR( gif->previous, 0, 0 ),\n\t\t\tVIPS_IMAGE_SIZEOF_IMAGE( gif->frame ) );\n\telse \n\t\tmemcpy( VIPS_IMAGE_ADDR( gif->previous, 0, 0 ),\n\t\t\tVIPS_IMAGE_ADDR( gif->frame, 0, 0 ),\n\t\t\tVIPS_IMAGE_SIZEOF_IMAGE( gif->frame ) );\n\n\tif( file->Image.Interlace ) {\n\t\tint i;\n\n\t\tVIPS_DEBUG_MSG( \"vips_foreign_load_gif_render: \"\n\t\t\t\"interlaced frame of %d x %d pixels at %d x %d\\n\",\n\t\t\tfile->Image.Width, file->Image.Height,\n\t\t\tfile->Image.Left, file->Image.Top ); \n\n\t\tfor( i = 0; i < 4; i++ ) {\n\t\t\tint y;\n\n\t\t\tfor( y = InterlacedOffset[i]; \n\t\t\t\ty < file->Image.Height;\n\t\t\t  \ty += InterlacedJumps[i] ) {\n\t\t\t\tVipsPel *q = VIPS_IMAGE_ADDR( gif->frame, \n\t\t\t\t\tfile->Image.Left, file->Image.Top + y );\n\n\t\t\t\tif( DGifGetLine( gif->file, gif->line, \n\t\t\t\t\tfile->Image.Width ) == GIF_ERROR ) {\n\t\t\t\t\tvips_foreign_load_gif_error( gif ); \n\t\t\t\t\treturn( -1 ); \n\t\t\t\t}\n\n\t\t\t\tvips_foreign_load_gif_render_line( gif, \n\t\t\t\t\tfile->Image.Width, q, gif->line ); \n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tint y;\n\n\t\tVIPS_DEBUG_MSG( \"vips_foreign_load_gif_render: \"\n\t\t\t\"non-interlaced frame of %d x %d pixels at %d x %d\\n\",\n\t\t\tfile->Image.Width, file->Image.Height,\n\t\t\tfile->Image.Left, file->Image.Top ); \n\n\t\tfor( y = 0; y < file->Image.Height; y++ ) {\n\t\t\tVipsPel *q = VIPS_IMAGE_ADDR( gif->frame, \n\t\t\t\tfile->Image.Left, file->Image.Top + y );\n\n\t\t\tif( DGifGetLine( gif->file, gif->line, \n\t\t\t\tfile->Image.Width ) == GIF_ERROR ) {\n\t\t\t\tvips_foreign_load_gif_error( gif ); \n\t\t\t\treturn( -1 ); \n\t\t\t}\n\n\t\t\tvips_foreign_load_gif_render_line( gif, \n\t\t\t\tfile->Image.Width, q, gif->line ); \n\t\t}\n\t}\n\n\treturn( 0 );\n}\n\nstatic int\nvips_foreign_load_gif_extension( VipsForeignLoadGif *gif )\n{\n\tGifByteType *extension;\n\tint ext_code;\n\n\tVIPS_DEBUG_MSG( \"vips_foreign_load_gif_extension:\\n\" ); \n\n\tif( DGifGetExtension( gif->file, &ext_code, &extension ) == \n\t\tGIF_ERROR ) {\n\t\tvips_foreign_load_gif_error( gif ); \n\t\treturn( -1 ); \n\t}\n\n\tif( extension &&\n\t\text_code == GRAPHICS_EXT_FUNC_CODE &&\n\t\textension[0] == 4 ) { \n\t\t/* Bytes are flags, delay low, delay high,\n\t\t * transparency. Flag bit 1 means transparency\n\t\t * is being set.\n\t\t */\n\t\tgif->transparency = -1;\n\t\tif( extension[1] & 0x1 ) \n\t\t\tgif->transparency = extension[4];\n\n\t\t/* Set the current dispose mode. This is read during frame load\n\t\t * to set the meaning of background and transparent pixels.\n\t\t */\n\t\tgif->dispose = (extension[1] >> 2) & 0x7;\n\t\tVIPS_DEBUG_MSG( \"vips_foreign_load_gif_extension: \"\n\t\t\t\"dispose = %d\\n\", gif->dispose ); \n\t}\n\n\twhile( extension != NULL ) \n\t\tif( vips_foreign_load_gif_ext_next( gif, &extension ) )\n\t\t\treturn( -1 ); \n\n\treturn( 0 );\n}\n\n/* Read the next page from the file into @frame.\n */\nstatic int\nvips_foreign_load_gif_next_page( VipsForeignLoadGif *gif )\n{\n\tGifRecordType record;\n\tgboolean have_read_frame;\n\n\thave_read_frame = FALSE;\n\tdo { \n\t\tif( DGifGetRecordType( gif->file, &record ) == GIF_ERROR ) {\n\t\t\tvips_foreign_load_gif_error( gif ); \n\t\t\treturn( -1 ); \n\t\t}\n\n\t\tswitch( record ) {\n\t\tcase IMAGE_DESC_RECORD_TYPE:\n\t\t\tVIPS_DEBUG_MSG( \"vips_foreign_load_gif_next_page: \"\n\t\t\t\t\"IMAGE_DESC_RECORD_TYPE\\n\" ); \n\n\t\t\tif( DGifGetImageDesc( gif->file ) == GIF_ERROR ) {\n\t\t\t\tvips_foreign_load_gif_error( gif ); \n\t\t\t\treturn( -1 ); \n\t\t\t}\n\n\t\t\tif( vips_foreign_load_gif_render( gif ) )\n\t\t\t\treturn( -1 ); \n\n\t\t\thave_read_frame = TRUE;\n\n\t\t\tbreak;\n\n\t\tcase EXTENSION_RECORD_TYPE:\n\t\t\tif( vips_foreign_load_gif_extension( gif ) )\n\t\t\t\treturn( -1 );\n\t\t\tbreak;\n\n\t\tcase TERMINATE_RECORD_TYPE:\n\t\t\tVIPS_DEBUG_MSG( \"vips_foreign_load_gif_next_page: \"\n\t\t\t\t\"TERMINATE_RECORD_TYPE\\n\" ); \n\t\t\tgif->eof = TRUE;\n\t\t\tbreak;\n\n\t\tcase SCREEN_DESC_RECORD_TYPE:\n\t\t\tVIPS_DEBUG_MSG( \"vips_foreign_load_gif_next_page: \"\n\t\t\t\t\"SCREEN_DESC_RECORD_TYPE\\n\" );\n\t\t\tbreak;\n\n\t\tcase UNDEFINED_RECORD_TYPE:\n\t\t\tVIPS_DEBUG_MSG( \"vips_foreign_load_gif_next_page: \"\n\t\t\t\t\"UNDEFINED_RECORD_TYPE\\n\" );\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} while( !have_read_frame &&\n\t\t!gif->eof );\n\n\treturn( 0 );\n}\n\nstatic int\nvips_foreign_load_gif_generate( VipsRegion *or, \n\tvoid *seq, void *a, void *b, gboolean *stop )\n{\n        VipsRect *r = &or->valid;\n\tVipsForeignLoadGif *gif = (VipsForeignLoadGif *) a;\n\n\tint y;\n\n\tfor( y = 0; y < r->height; y++ ) {\n\t\t/* The page for this output line, and the line number in page.\n\t\t */\n\t\tint page = (r->top + y) / gif->file->SHeight + gif->page;\n\t\tint line = (r->top + y) % gif->file->SHeight;\n\n\t\tVipsPel *p, *q;\n\t\tint x;\n\n\t\tg_assert( line >= 0 && line < gif->frame->Ysize );\n\t\tg_assert( page >= 0 && page < gif->n_pages );\n\n\t\t/* current_page == 0 means we've not loaded any pages yet. So \n\t\t * we need to have loaded the page beyond the page we want.\n\t\t */\n\t\twhile( gif->current_page <= page ) {\n\t\t\tif( vips_foreign_load_gif_next_page( gif ) )\n\t\t\t\treturn( -1 );\n\n\t\t\tgif->current_page += 1; \n\t\t}\n\n\t\t/* @frame is always RGBA, but or may be G, GA, RGB or RGBA. \n\t\t * We have to pick out the values we want.\n\t\t */\n\t\tp = VIPS_IMAGE_ADDR( gif->frame, 0, line );\n\t\tq = VIPS_REGION_ADDR( or, 0, r->top + y );\n\t\tswitch( or->im->Bands ) {\n\t\tcase 1:\n\t\t\tfor( x = 0; x < gif->frame->Xsize; x++ ) {\n\t\t\t\tq[0] = p[1];\n\n\t\t\t\tq += 1;\n\t\t\t\tp += 4;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tfor( x = 0; x < gif->frame->Xsize; x++ ) {\n\t\t\t\tq[0] = p[1];\n\t\t\t\tq[1] = p[3];\n\n\t\t\t\tq += 2;\n\t\t\t\tp += 4;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\tfor( x = 0; x < gif->frame->Xsize; x++ ) {\n\t\t\t\tq[0] = p[0];\n\t\t\t\tq[1] = p[1];\n\t\t\t\tq[2] = p[2];\n\n\t\t\t\tq += 3;\n\t\t\t\tp += 4;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\tmemcpy( q, p, VIPS_IMAGE_SIZEOF_LINE( gif->frame ) );\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tg_assert_not_reached();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn( 0 );\n}\n\nstatic int\nvips_foreign_load_gif_load( VipsForeignLoad *load )\n{\n\tVipsForeignLoadGifClass *class = \n\t\t(VipsForeignLoadGifClass *) VIPS_OBJECT_GET_CLASS( load );\n\tVipsForeignLoadGif *gif = (VipsForeignLoadGif *) load;\n\tVipsImage **t = (VipsImage **) \n\t\tvips_object_local_array( VIPS_OBJECT( load ), 4 );\n\n\t/* Rewind.\n\t */\n\tif( class->open( gif ) )\n\t\treturn( -1 );\n\n\tVIPS_DEBUG_MSG( \"vips_foreign_load_gif_load:\\n\" ); \n\n\t/* Make the memory image we accumulate pixels in. We always accumulate\n\t * to RGBA, then trim down to whatever the output image needs on\n\t * _generate.\n\t */\n\tgif->frame = vips_image_new_memory();\n\tvips_image_init_fields( gif->frame, \n\t\tgif->file->SWidth, gif->file->SHeight, 4, VIPS_FORMAT_UCHAR,\n\t\tVIPS_CODING_NONE, VIPS_INTERPRETATION_sRGB, 1.0, 1.0 );\n\tif( vips_image_write_prepare( gif->frame ) ) \n\t\treturn( -1 );\n\n\t/* A copy of the previous state of the frame, in case we have to\n\t * process a DISPOSE_PREVIOUS.\n\t */\n\tgif->previous = vips_image_new_memory();\n\tvips_image_init_fields( gif->previous, \n\t\tgif->file->SWidth, gif->file->SHeight, 4, VIPS_FORMAT_UCHAR,\n\t\tVIPS_CODING_NONE, VIPS_INTERPRETATION_sRGB, 1.0, 1.0 );\n\tif( vips_image_write_prepare( gif->previous ) ) \n\t\treturn( -1 );\n\n\t/* Make the output pipeline.\n\t */\n\tt[0] = vips_image_new();\n\tif( vips_foreign_load_gif_set_header( gif, t[0] ) )\n\t\treturn( -1 );\n\n\t/* Strips 8 pixels high to avoid too many tiny regions.\n\t */\n\tif( vips_image_generate( t[0], \n\t\tNULL, vips_foreign_load_gif_generate, NULL, gif, NULL ) ||\n\t\tvips_sequential( t[0], &t[1], \n\t\t\t\"tile_height\", VIPS__FATSTRIP_HEIGHT, \n\t\t\tNULL ) ||\n\t\tvips_image_write( t[1], load->real ) )\n\t\treturn( -1 );\n\n\treturn( 0 );\n}\n\nstatic int\nvips_foreign_load_gif_open( VipsForeignLoadGif *gif )\n{\n#ifdef HAVE_GIFLIB_5\n{\n\tint error;\n\n\tif( !(gif->file = DGifOpen( gif, gif->read_func, &error )) ) {\n\t\tvips_foreign_load_gif_error_vips( gif, error );\n\t\treturn( -1 ); \n\t}\n}\n#else \n\tif( !(gif->file = DGifOpen( gif, gif->read_func )) ) { \n\t\tvips_foreign_load_gif_error_vips( gif, GifLastError() ); \n\t\treturn( -1 ); \n\t}\n#endif\n\n\tgif->eof = FALSE;\n\tgif->current_page = 0;\n\n\t/* Allocate a line buffer now that we have the GIF width.\n\t */\n\tVIPS_FREE( gif->line ) \n\tif( !(gif->line = VIPS_ARRAY( NULL, gif->file->SWidth, GifPixelType )) )\n\t\treturn( -1 ); \n\n\treturn( 0 );\n}\n\nstatic void\nvips_foreign_load_gif_class_init( VipsForeignLoadGifClass *class )\n{\n\tGObjectClass *gobject_class = G_OBJECT_CLASS( class );\n\tVipsObjectClass *object_class = (VipsObjectClass *) class;\n\tVipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;\n\tVipsForeignLoadGifClass *gif_class = (VipsForeignLoadGifClass *) class;\n\n\tgobject_class->dispose = vips_foreign_load_gif_dispose;\n\tgobject_class->set_property = vips_object_set_property;\n\tgobject_class->get_property = vips_object_get_property;\n\n\tgif_class->open = vips_foreign_load_gif_open;\n\tload_class->header = vips_foreign_load_gif_header;\n\tload_class->load = vips_foreign_load_gif_load;\n\n\tobject_class->nickname = \"gifload_base\";\n\tobject_class->description = _( \"load GIF with giflib\" );\n\n\tload_class->get_flags_filename = \n\t\tvips_foreign_load_gif_get_flags_filename;\n\tload_class->get_flags = vips_foreign_load_gif_get_flags;\n\n\tVIPS_ARG_INT( class, \"page\", 20,\n\t\t_( \"Page\" ),\n\t\t_( \"Load this page from the file\" ),\n\t\tVIPS_ARGUMENT_OPTIONAL_INPUT,\n\t\tG_STRUCT_OFFSET( VipsForeignLoadGif, page ),\n\t\t0, 100000, 0 );\n\n\tVIPS_ARG_INT( class, \"n\", 21,\n\t\t_( \"n\" ),\n\t\t_( \"Load this many pages\" ),\n\t\tVIPS_ARGUMENT_OPTIONAL_INPUT,\n\t\tG_STRUCT_OFFSET( VipsForeignLoadGif, n ),\n\t\t-1, 100000, 1 );\n\n}\n\nstatic void\nvips_foreign_load_gif_init( VipsForeignLoadGif *gif )\n{\n\tgif->n = 1;\n\tgif->transparency = -1;\n\tgif->delay = 4;\n\tgif->loop = 0;\n\tgif->comment = NULL;\n\tgif->dispose = 0;\n}\n\ntypedef struct _VipsForeignLoadGifFile {\n\tVipsForeignLoadGif parent_object;\n\n\t/* Filename for load.\n\t */\n\tchar *filename; \n\n\t/* The FILE* we read from.\n\t */\n\tFILE *fp;\n\n} VipsForeignLoadGifFile;\n\ntypedef VipsForeignLoadGifClass VipsForeignLoadGifFileClass;\n\nG_DEFINE_TYPE( VipsForeignLoadGifFile, vips_foreign_load_gif_file, \n\tvips_foreign_load_gif_get_type() );\n\nstatic void\nvips_foreign_load_gif_file_dispose( GObject *gobject )\n{\n\tVipsForeignLoadGifFile *file = (VipsForeignLoadGifFile *) gobject;\n\n\tVIPS_FREEF( fclose, file->fp ); \n\n\tG_OBJECT_CLASS( vips_foreign_load_gif_file_parent_class )->\n\t\tdispose( gobject );\n}\n\n/* Our input function for file open. We can't use DGifOpenFileName(), since\n * that just calls open() and won't work with unicode on win32. We can't use\n * DGifOpenFileHandle() since that's an fd from open() and you can't pass those\n * across DLL boundaries on Windows. \n */\nstatic int \nvips_giflib_file_read( GifFileType *gfile, GifByteType *buffer, int n )\n{\n\tVipsForeignLoadGif *gif = (VipsForeignLoadGif *) gfile->UserData;\n\tVipsForeignLoadGifFile *file = (VipsForeignLoadGifFile *) gif;\n\n\tif( feof( file->fp ) )\n\t\tgif->eof = TRUE;\n\n\treturn( (int) fread( (void *) buffer, 1, n, file->fp ) );\n}\n\nstatic int\nvips_foreign_load_gif_file_open( VipsForeignLoadGif *gif )\n{\n\tVipsForeignLoad *load = (VipsForeignLoad *) gif;\n\tVipsForeignLoadGifFile *file = (VipsForeignLoadGifFile *) gif;\n\n\tif( !file->fp ) {\n\t\tif( !(file->fp = \n\t\t\tvips__file_open_read( file->filename, NULL, FALSE )) ) \n\t\t\treturn( -1 ); \n\n\t\tVIPS_SETSTR( load->out->filename, file->filename );\n\t}\n\telse \n\t\trewind( file->fp );\n\n\tvips_foreign_load_gif_close( gif );\n\tgif->read_func = vips_giflib_file_read;\n\n\treturn( VIPS_FOREIGN_LOAD_GIF_CLASS( \n\t\tvips_foreign_load_gif_file_parent_class )->open( gif ) );\n}\n\nstatic const char *vips_foreign_gif_suffs[] = {\n\t\".gif\",\n\tNULL\n};\n\nstatic void\nvips_foreign_load_gif_file_class_init( \n\tVipsForeignLoadGifFileClass *class )\n{\n\tGObjectClass *gobject_class = G_OBJECT_CLASS( class );\n\tVipsObjectClass *object_class = (VipsObjectClass *) class;\n\tVipsForeignClass *foreign_class = (VipsForeignClass *) class;\n\tVipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;\n\tVipsForeignLoadGifClass *gif_class = (VipsForeignLoadGifClass *) class;\n\n\tgobject_class->dispose = vips_foreign_load_gif_file_dispose;\n\tgobject_class->set_property = vips_object_set_property;\n\tgobject_class->get_property = vips_object_get_property;\n\n\tobject_class->nickname = \"gifload\";\n\tobject_class->description = _( \"load GIF with giflib\" );\n\n\tforeign_class->suffs = vips_foreign_gif_suffs;\n\n\tload_class->is_a = vips_foreign_load_gif_is_a;\n\n\tgif_class->open = vips_foreign_load_gif_file_open;\n\n\tVIPS_ARG_STRING( class, \"filename\", 1, \n\t\t_( \"Filename\" ),\n\t\t_( \"Filename to load from\" ),\n\t\tVIPS_ARGUMENT_REQUIRED_INPUT, \n\t\tG_STRUCT_OFFSET( VipsForeignLoadGifFile, filename ),\n\t\tNULL );\n\n}\n\nstatic void\nvips_foreign_load_gif_file_init( VipsForeignLoadGifFile *file )\n{\n}\n\ntypedef struct _VipsForeignLoadGifBuffer {\n\tVipsForeignLoadGif parent_object;\n\n\t/* Load from a buffer.\n\t */\n\tVipsArea *buf;\n\n\t/* Current read point, bytes left in buffer.\n\t */\n\tVipsPel *p;\n\tsize_t bytes_to_go;\n\n} VipsForeignLoadGifBuffer;\n\ntypedef VipsForeignLoadGifClass VipsForeignLoadGifBufferClass;\n\nG_DEFINE_TYPE( VipsForeignLoadGifBuffer, vips_foreign_load_gif_buffer, \n\tvips_foreign_load_gif_get_type() );\n\n/* Callback from the gif loader.\n *\n * Read up to len bytes into buffer, return number of bytes read, 0 for EOF.\n */\nstatic int\nvips_giflib_buffer_read( GifFileType *file, GifByteType *buf, int n )\n{\n\tVipsForeignLoadGif *gif = (VipsForeignLoadGif *) file->UserData;\n\tVipsForeignLoadGifBuffer *buffer = (VipsForeignLoadGifBuffer *) gif;\n\tsize_t will_read = VIPS_MIN( n, buffer->bytes_to_go );\n\n\tmemcpy( buf, buffer->p, will_read );\n\tbuffer->p += will_read;\n\tbuffer->bytes_to_go -= will_read;\n\n\tif( will_read == 0 )\n\t\tgif->eof = TRUE;\n\n\treturn( will_read ); \n}\n\nstatic int\nvips_foreign_load_gif_buffer_open( VipsForeignLoadGif *gif )\n{\n\tVipsForeignLoadGifBuffer *buffer = (VipsForeignLoadGifBuffer *) gif;\n\n\tvips_foreign_load_gif_close( gif );\n\tbuffer->p = buffer->buf->data;\n\tbuffer->bytes_to_go = buffer->buf->length;\n\tgif->read_func = vips_giflib_buffer_read;;\n\n\treturn( VIPS_FOREIGN_LOAD_GIF_CLASS( \n\t\tvips_foreign_load_gif_file_parent_class )->open( gif ) );\n}\n\nstatic void\nvips_foreign_load_gif_buffer_class_init( \n\tVipsForeignLoadGifBufferClass *class )\n{\n\tGObjectClass *gobject_class = G_OBJECT_CLASS( class );\n\tVipsObjectClass *object_class = (VipsObjectClass *) class;\n\tVipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;\n\tVipsForeignLoadGifClass *gif_class = (VipsForeignLoadGifClass *) class;\n\n\tgobject_class->set_property = vips_object_set_property;\n\tgobject_class->get_property = vips_object_get_property;\n\n\tobject_class->nickname = \"gifload_buffer\";\n\tobject_class->description = _( \"load GIF with giflib\" );\n\n\tload_class->is_a_buffer = vips_foreign_load_gif_is_a_buffer;\n\n\tgif_class->open = vips_foreign_load_gif_buffer_open;\n\n\tVIPS_ARG_BOXED( class, \"buffer\", 1, \n\t\t_( \"Buffer\" ),\n\t\t_( \"Buffer to load from\" ),\n\t\tVIPS_ARGUMENT_REQUIRED_INPUT, \n\t\tG_STRUCT_OFFSET( VipsForeignLoadGifBuffer, buf ),\n\t\tVIPS_TYPE_BLOB );\n\n}\n\nstatic void\nvips_foreign_load_gif_buffer_init( VipsForeignLoadGifBuffer *buffer )\n{\n}\n\n#endif /*HAVE_GIFLIB*/\n\n/**\n * vips_gifload:\n * @filename: file to load\n * @out: (out): output image\n * @...: %NULL-terminated list of optional named arguments\n *\n * Optional arguments:\n *\n * * @page: %gint, page (frame) to read\n * * @n: %gint, load this many pages\n *\n * Read a GIF file into a VIPS image.\n *\n * Use @page to select a page to render, numbering from zero.\n *\n * Use @n to select the number of pages to render. The default is 1. Pages are\n * rendered in a vertical column, with each individual page aligned to the\n * left. Set to -1 to mean \"until the end of the document\". Use vips_grid() \n * to change page layout.\n *\n * The whole GIF is rendered into memory on header access. The output image\n * will be 1, 2, 3 or 4 bands depending on what the reader finds in the file. \n *\n * See also: vips_image_new_from_file().\n *\n * Returns: 0 on success, -1 on error.\n */\nint\nvips_gifload( const char *filename, VipsImage **out, ... )\n{\n\tva_list ap;\n\tint result;\n\n\tva_start( ap, out );\n\tresult = vips_call_split( \"gifload\", ap, filename, out );\n\tva_end( ap );\n\n\treturn( result );\n}\n\n/**\n * vips_gifload_buffer:\n * @buf: (array length=len) (element-type guint8): memory area to load\n * @len: (type gsize): size of memory area\n * @out: (out): image to write\n * @...: %NULL-terminated list of optional named arguments\n *\n * Optional arguments:\n *\n * * @page: %gint, page (frame) to read\n * * @n: %gint, load this many pages\n *\n * Read a GIF-formatted memory block into a VIPS image. Exactly as\n * vips_gifload(), but read from a memory buffer. \n *\n * You must not free the buffer while @out is active. The \n * #VipsObject::postclose signal on @out is a good place to free. \n *\n * See also: vips_gifload().\n *\n * Returns: 0 on success, -1 on error.\n */\nint\nvips_gifload_buffer( void *buf, size_t len, VipsImage **out, ... )\n{\n\tva_list ap;\n\tVipsBlob *blob;\n\tint result;\n\n\t/* We don't take a copy of the data or free it.\n\t */\n\tblob = vips_blob_new( NULL, buf, len );\n\n\tva_start( ap, out );\n\tresult = vips_call_split( \"gifload_buffer\", ap, blob, out );\n\tva_end( ap );\n\n\tvips_area_unref( VIPS_AREA( blob ) );\n\n\treturn( result );\n}\n\n"], "fixing_code": ["/* load a GIF with giflib\n *\n * 10/2/16\n * \t- from svgload.c\n * 25/4/16\n * \t- add giflib5 support\n * 26/7/16\n * \t- transparency was wrong if there was no EXTENSION_RECORD\n * \t- write 1, 2, 3, or 4 bands depending on file contents\n * 17/8/16\n * \t- support unicode on win\n * 19/8/16\n * \t- better transparency detection, thanks diegocsandrim\n * 25/11/16\n * \t- support @n, page-height\n * 5/10/17\n * \t- colormap can be missing thanks Kleis\n * 21/11/17\n * \t- add \"gif-delay\", \"gif-loop\", \"gif-comment\" metadata\n * \t- add dispose handling\n * 13/8/18\n * \t- init pages to 0 before load\n * 14/2/19\n * \t- rework as a sequential loader ... simpler, much lower mem use\n * 23/8/18\n * \t- allow GIF read errors during header scan\n * \t- better feof() handling\n */\n\n/*\n\n    This file is part of VIPS.\n    \n    VIPS is free software; you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n    02110-1301  USA\n\n */\n\n/*\n\n    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk\n\n */\n\n/*\n#define DEBUG_VERBOSE\n#define VIPS_DEBUG\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif /*HAVE_CONFIG_H*/\n#include <vips/intl.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <ctype.h>\n\n#include <vips/vips.h>\n#include <vips/buf.h>\n#include <vips/internal.h>\n#include <vips/debug.h>\n\n#ifdef HAVE_GIFLIB\n\n#include <gif_lib.h>\n\n/* giflib 5 is rather different :-( functions have error returns and there's\n * no LastError().\n *\n * GIFLIB_MAJOR was introduced in 4.1.6. Use it to test for giflib 5.x.\n */\n#ifdef GIFLIB_MAJOR\n#  if GIFLIB_MAJOR > 4\n#    define HAVE_GIFLIB_5\n#  endif\n#endif\n\n/* Added in giflib5.\n */\n#ifndef HAVE_GIFLIB_5\n#define DISPOSAL_UNSPECIFIED      0       \n#define DISPOSE_DO_NOT            1      \n#define DISPOSE_BACKGROUND        2     \n#define DISPOSE_PREVIOUS          3    \n#endif\n\n#define VIPS_TYPE_FOREIGN_LOAD_GIF (vips_foreign_load_gif_get_type())\n#define VIPS_FOREIGN_LOAD_GIF( obj ) \\\n\t(G_TYPE_CHECK_INSTANCE_CAST( (obj), \\\n\tVIPS_TYPE_FOREIGN_LOAD_GIF, VipsForeignLoadGif ))\n#define VIPS_FOREIGN_LOAD_GIF_CLASS( klass ) \\\n\t(G_TYPE_CHECK_CLASS_CAST( (klass), \\\n\tVIPS_TYPE_FOREIGN_LOAD_GIF, VipsForeignLoadGifClass))\n#define VIPS_IS_FOREIGN_LOAD_GIF( obj ) \\\n\t(G_TYPE_CHECK_INSTANCE_TYPE( (obj), VIPS_TYPE_FOREIGN_LOAD_GIF ))\n#define VIPS_IS_FOREIGN_LOAD_GIF_CLASS( klass ) \\\n\t(G_TYPE_CHECK_CLASS_TYPE( (klass), VIPS_TYPE_FOREIGN_LOAD_GIF ))\n#define VIPS_FOREIGN_LOAD_GIF_GET_CLASS( obj ) \\\n\t(G_TYPE_INSTANCE_GET_CLASS( (obj), \\\n\tVIPS_TYPE_FOREIGN_LOAD_GIF, VipsForeignLoadGifClass ))\n\ntypedef struct _VipsForeignLoadGif {\n\tVipsForeignLoad parent_object;\n\n\t/* Load from this page (frame number).\n\t */\n\tint page;\n\n\t/* Load this many pages.\n\t */\n\tint n;\n\n\tGifFileType *file;\n\n\t/* We decompress the whole thing to a huge RGBA memory image, and\n\t * as we render, watch for bands and transparency. At the end of\n\t * loading, we copy 1 or 3 bands, with or without transparency to\n\t * output.\n\t */\n\tgboolean has_transparency;\n\tgboolean has_colour;\n\n\t/* Delay in 1/100ths of a second. We only track a single delay \n\t * value for the whole file, and we report the first delay we see. Some\n\t * GIFs have a long delay on the final frame.\n\t */\n\tgboolean has_delay;\n\tint delay;\n\n\t/* Number of times to loop the animation.\n\t */\n\tint loop;\n\n\t/* The GIF comment, if any.\n\t */\n\tchar *comment; \n\n\t/* The number of pages (frame) in the image.\n\t */\n\tint n_pages;\n\n\t/* A memory image the sized of one frame ... we accumulate to this as\n\t * we scan the image, and copy lines to the output on generate.\n\t */\n\tVipsImage *frame;\n\n\t/* A copy of the previous frame, in case we need a DISPOSE_PREVIOUS.\n\t */\n\tVipsImage *previous;\n\n\t/* The position of @frame, in pages.\n\t */\n\tint current_page;\n\n\t/* Decompress lines of the gif file to here.\n\t */\n\tGifPixelType *line;\n\n\t/* The current dispose method.\n\t */\n\tint dispose;\n\n\t/* Set for EOF detected.\n\t */\n\tgboolean eof;\n\n\t/* The current cmap unpacked to a simple LUT. Each uint32 is really an\n\t * RGBA pixel ready to be blasted into @frame.\n\t */\n\tguint32 cmap[256];\n\n\t/* As we scan the file, the index of the transparent pixel for this\n\t * frame.\n\t */\n\tint transparency;\n\n\t/* Params for DGifOpen(). Set by subclasses, called by base class in\n\t * _open().\n\t */\n\tInputFunc read_func;\n\n} VipsForeignLoadGif;\n\ntypedef struct _VipsForeignLoadGifClass {\n\tVipsForeignLoadClass parent_class;\n\n\t/* Close and reopen gif->file.\n\t */\n\tint (*open)( VipsForeignLoadGif *gif );\n} VipsForeignLoadGifClass;\n\nG_DEFINE_ABSTRACT_TYPE( VipsForeignLoadGif, vips_foreign_load_gif, \n\tVIPS_TYPE_FOREIGN_LOAD );\n\n/* From gif2rgb.c ... offsets and jumps for interlaced GIF images.\n */\nstatic int \n\tInterlacedOffset[] = { 0, 4, 2, 1 },\n\tInterlacedJumps[] = { 8, 8, 4, 2 };\n\n/* giflib4 was missing this.\n */\nstatic const char *\nvips_foreign_load_gif_errstr( int error_code )\n{\n#ifdef HAVE_GIFLIB_5\n\treturn( GifErrorString( error_code ) ); \n#else /*!HAVE_GIFLIB_5*/\n\tswitch( error_code ) {\n\tcase D_GIF_ERR_OPEN_FAILED:\n\t\treturn( _( \"Failed to open given file\" ) ); \n\n\tcase D_GIF_ERR_READ_FAILED:\n\t\treturn( _( \"Failed to read from given file\" ) ); \n\n\tcase D_GIF_ERR_NOT_GIF_FILE:\n\t\treturn( _( \"Data is not a GIF file\" ) ); \n\n\tcase D_GIF_ERR_NO_SCRN_DSCR:\n\t\treturn( _( \"No screen descriptor detected\" ) ); \n\n\tcase D_GIF_ERR_NO_IMAG_DSCR:\n\t\treturn( _( \"No image descriptor detected\" ) ); \n\n\tcase D_GIF_ERR_NO_COLOR_MAP:\n\t\treturn( _( \"Neither global nor local color map\" ) ); \n\n\tcase D_GIF_ERR_WRONG_RECORD:\n\t\treturn( _( \"Wrong record type detected\" ) ); \n\n\tcase D_GIF_ERR_DATA_TOO_BIG:\n\t\treturn( _( \"Number of pixels bigger than width * height\" ) ); \n\n\tcase D_GIF_ERR_NOT_ENOUGH_MEM:\n\t\treturn( _( \"Failed to allocate required memory\" ) ); \n\n\tcase D_GIF_ERR_CLOSE_FAILED:\n\t\treturn( _( \"Failed to close given file\" ) ); \n\n\tcase D_GIF_ERR_NOT_READABLE:\n\t\treturn( _( \"Given file was not opened for read\" ) ); \n\n\tcase D_GIF_ERR_IMAGE_DEFECT:\n\t\treturn( _( \"Image is defective, decoding aborted\" ) ); \n\n\tcase D_GIF_ERR_EOF_TOO_SOON:\n\t\treturn( _( \"Image EOF detected, before image complete\" ) ); \n\n\tdefault:\n\t\treturn( _( \"Unknown error\" ) ); \n\t}\n#endif /*HAVE_GIFLIB_5*/\n}\n\nstatic void\nvips_foreign_load_gif_error_vips( VipsForeignLoadGif *gif, int error )\n{\n\tVipsObjectClass *class = VIPS_OBJECT_GET_CLASS( gif );\n\n\tconst char *message;\n\n\tif( (message = vips_foreign_load_gif_errstr( error )) )\n\t\tvips_error( class->nickname, \"%s\", message ); \n}\n\nstatic void\nvips_foreign_load_gif_error( VipsForeignLoadGif *gif )\n{\n\tint error;\n\n\terror = 0;\n\n#ifdef HAVE_GIFLIB_5\n\tif( gif->file ) \n\t\terror = gif->file->Error;\n#else \n\terror = GifLastError(); \n#endif\n\n\tif( error ) \n\t\tvips_foreign_load_gif_error_vips( gif, error ); \n}\n\nstatic void\nvips_foreign_load_gif_close( VipsForeignLoadGif *gif )\n{\n#ifdef HAVE_GIFLIB_5\n\tif( gif->file ) {\n\t\tint error; \n\n\t\tif( DGifCloseFile( gif->file, &error ) == GIF_ERROR ) \n\t\t\tvips_foreign_load_gif_error_vips( gif, error );\n\t\tgif->file = NULL;\n\t}\n#else \n\tif( gif->file ) {\n\t\tif( DGifCloseFile( gif->file ) == GIF_ERROR ) \n\t\t\tvips_foreign_load_gif_error_vips( gif, GifLastError() ); \n\t\tgif->file = NULL;\n\t}\n#endif\n}\n\nstatic void\nvips_foreign_load_gif_dispose( GObject *gobject )\n{\n\tVipsForeignLoadGif *gif = (VipsForeignLoadGif *) gobject;\n\n\tvips_foreign_load_gif_close( gif ); \n\n\tVIPS_UNREF( gif->frame ); \n\tVIPS_UNREF( gif->previous ); \n\tVIPS_FREE( gif->comment ); \n\tVIPS_FREE( gif->line ) \n\n\tG_OBJECT_CLASS( vips_foreign_load_gif_parent_class )->\n\t\tdispose( gobject );\n}\n\nstatic VipsForeignFlags\nvips_foreign_load_gif_get_flags_filename( const char *filename )\n{\n\treturn( VIPS_FOREIGN_SEQUENTIAL );\n}\n\nstatic VipsForeignFlags\nvips_foreign_load_gif_get_flags( VipsForeignLoad *load )\n{\n\treturn( VIPS_FOREIGN_SEQUENTIAL );\n}\n\nstatic gboolean\nvips_foreign_load_gif_is_a_buffer( const void *buf, size_t len )\n{\n\tconst guchar *str = (const guchar *) buf;\n\n\tif( len >= 4 &&\n\t\tstr[0] == 'G' && \n\t\tstr[1] == 'I' &&\n\t\tstr[2] == 'F' &&\n\t\tstr[3] == '8' )\n\t\treturn( 1 );\n\n\treturn( 0 );\n}\n\nstatic gboolean\nvips_foreign_load_gif_is_a( const char *filename )\n{\n\tunsigned char buf[4];\n\n\tif( vips__get_bytes( filename, buf, 4 ) == 4 &&\n\t\tvips_foreign_load_gif_is_a_buffer( buf, 4 ) )\n\t\treturn( 1 );\n\n\treturn( 0 );\n}\n\nstatic int\nvips_foreign_load_gif_ext_next( VipsForeignLoadGif *gif, \n\tGifByteType **extension )\n{\n\tif( DGifGetExtensionNext( gif->file, extension ) == GIF_ERROR ) {\n\t\tvips_foreign_load_gif_error( gif ); \n\t\treturn( -1 ); \n\t}\n\n\tif( *extension ) \n\t\tVIPS_DEBUG_MSG( \"gifload: EXTENSION_NEXT\\n\" ); \n\n\treturn( 0 );\n}\n\nstatic int\nvips_foreign_load_gif_code_next( VipsForeignLoadGif *gif, \n\tGifByteType **extension )\n{\n\tif( DGifGetCodeNext( gif->file, extension ) == GIF_ERROR ) {\n\t\tvips_foreign_load_gif_error( gif ); \n\t\treturn( -1 ); \n\t}\n\n\tif( *extension ) \n\t\tVIPS_DEBUG_MSG( \"gifload: CODE_NEXT\\n\" ); \n\n\treturn( 0 );\n}\n\n/* Quickly scan an image record.\n */\nstatic int\nvips_foreign_load_gif_scan_image( VipsForeignLoadGif *gif ) \n{\n\tVipsObjectClass *class = VIPS_OBJECT_GET_CLASS( gif );\n\tGifFileType *file = gif->file;\n\n\tColorMapObject *map;\n\tGifByteType *extension;\n\n\tif( DGifGetImageDesc( gif->file ) == GIF_ERROR ) {\n\t\tvips_foreign_load_gif_error( gif ); \n\t\treturn( -1 );\n\t}\n\n\t/* Check that the frame looks sane. Perhaps giflib checks\n\t * this for us.\n\t */\n\tif( file->Image.Left < 0 ||\n\t\tfile->Image.Width < 1 ||\n\t\tfile->Image.Width > 10000 ||\n\t\tfile->Image.Left + file->Image.Width > file->SWidth ||\n\t\tfile->Image.Top < 0 ||\n\t\tfile->Image.Height < 1 ||\n\t\tfile->Image.Height > 10000 ||\n\t\tfile->Image.Top + file->Image.Height > file->SHeight ) {\n\t\tvips_error( class->nickname, \"%s\", _( \"bad frame size\" ) ); \n\t\treturn( -1 ); \n\t}\n\n\t/* Test for a non-greyscale colourmap for this frame.\n\t */\n\tmap = file->Image.ColorMap ? file->Image.ColorMap : file->SColorMap;\n\tif( !gif->has_colour &&\n\t\tmap ) {\n\t\tint i;\n\n\t\tfor( i = 0; i < map->ColorCount; i++ ) \n\t\t\tif( map->Colors[i].Red != map->Colors[i].Green ||\n\t\t\t\tmap->Colors[i].Green != map->Colors[i].Blue ) {\n\t\t\t\tgif->has_colour = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t/* Step over compressed image data.\n\t */\n\tdo {\n\t\tif( vips_foreign_load_gif_code_next( gif, &extension ) ) \n\t\t\treturn( -1 );\n\t} while( extension != NULL );\n\n\treturn( 0 );\n}\n\nstatic int\nvips_foreign_load_gif_scan_application_ext( VipsForeignLoadGif *gif,\n\tGifByteType *extension )\n{\n\tgboolean have_netscape;\n\n\t/* The 11-byte NETSCAPE extension.\n\t */\n\thave_netscape = FALSE;\n\tif( extension[0] == 11 &&\n\t\tvips_isprefix( \"NETSCAPE2.0\", (const char*) (extension + 1) ) ) \n\t\thave_netscape = TRUE;\n\n\twhile( extension != NULL ) {\n\t\tif( vips_foreign_load_gif_ext_next( gif, &extension ) )\n\t\t\treturn( -1 ); \n\n\t\tif( have_netscape &&\n\t\t\textension &&\n\t\t\textension[0] == 3 &&\n\t\t\textension[1] == 1 ) \n\t\t\tgif->loop = extension[2] | (extension[3] << 8);\n\t}\n\n\treturn( 0 );\n}\n\nstatic int\nvips_foreign_load_gif_scan_comment_ext( VipsForeignLoadGif *gif,\n\tGifByteType *extension )\n{\n\tVIPS_DEBUG_MSG( \"gifload: type: comment\\n\" ); \n\n\tif( !gif->comment ) { \n\t\t/* Up to 257 with a NULL terminator.\n\t\t */\n\t\tchar comment[257];\n\n\t\tvips_strncpy( comment, (char *) (extension + 1), 256 );\n\t\tcomment[extension[0]] = '\\0';\n\t\tgif->comment = g_strdup( comment ); \n\t}\n\n\twhile( extension != NULL ) \n\t\tif( vips_foreign_load_gif_ext_next( gif, &extension ) )\n\t\t\treturn( -1 ); \n\n\treturn( 0 );\n}\n\nstatic int\nvips_foreign_load_gif_scan_extension( VipsForeignLoadGif *gif )\n{\n\tGifByteType *extension;\n\tint ext_code;\n\n\tif( DGifGetExtension( gif->file, &ext_code, &extension ) == \n\t\tGIF_ERROR ) {\n\t\tvips_foreign_load_gif_error( gif ); \n\t\treturn( -1 ); \n\t}\n\n\tif( extension ) \n\t\tswitch( ext_code ) { \n\t\tcase GRAPHICS_EXT_FUNC_CODE: \n\t\t\tif( extension[0] == 4 &&\n\t\t\t\textension[1] & 0x1 ) {\n\t\t\t\tVIPS_DEBUG_MSG( \"gifload: has transp.\\n\" ); \n\t\t\t\tgif->has_transparency = TRUE;\n\t\t\t}\n\n\t\t\tif( !gif->has_delay ) { \n\t\t\t\tVIPS_DEBUG_MSG( \"gifload: has delay\\n\" ); \n\t\t\t\tgif->has_delay = TRUE;\n\t\t\t\tgif->delay = extension[2] | (extension[3] << 8);\n\t\t\t}\n\n\t\t\twhile( extension != NULL ) \n\t\t\t\tif( vips_foreign_load_gif_ext_next( gif, \n\t\t\t\t\t&extension ) )\n\t\t\t\t\treturn( -1 ); \n\n\t\t\tbreak;\n\n\t\tcase APPLICATION_EXT_FUNC_CODE: \n\t\t\tif( vips_foreign_load_gif_scan_application_ext( gif, \n\t\t\t\textension ) )\n\t\t\t\treturn( -1 ); \n\t\t\tbreak;\n\n\t\tcase COMMENT_EXT_FUNC_CODE:\n\t\t\tif( vips_foreign_load_gif_scan_comment_ext( gif, \n\t\t\t\textension ) )\n\t\t\t\treturn( -1 ); \n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Step over any NEXT blocks for unknown extensions.\n\t\t\t */\n\t\t\twhile( extension != NULL ) \n\t\t\t\tif( vips_foreign_load_gif_ext_next( gif, \n\t\t\t\t\t&extension ) )\n\t\t\t\t\treturn( -1 ); \n\t\t\tbreak;\n\t\t}\n\n\treturn( 0 );\n}\n\nstatic int\nvips_foreign_load_gif_set_header( VipsForeignLoadGif *gif, VipsImage *image )\n{\n\tvips_image_init_fields( image,\n\t\tgif->file->SWidth, gif->file->SHeight * gif->n, \n\t\t(gif->has_colour ? 3 : 1) + (gif->has_transparency ? 1 : 0),\n\t\tVIPS_FORMAT_UCHAR, VIPS_CODING_NONE,\n\t\tgif->has_colour ? \n\t\t \tVIPS_INTERPRETATION_sRGB : VIPS_INTERPRETATION_B_W,\n\t\t1.0, 1.0 );\n\tvips_image_pipelinev( image, VIPS_DEMAND_STYLE_FATSTRIP, NULL );\n\n\tif( vips_object_argument_isset( VIPS_OBJECT( gif ), \"n\" ) )\n\t\tvips_image_set_int( image, \n\t\t\tVIPS_META_PAGE_HEIGHT, gif->file->SHeight );\n\tvips_image_set_int( image, VIPS_META_N_PAGES, gif->n_pages );\n\tvips_image_set_int( image, \"gif-delay\", gif->delay );\n\tvips_image_set_int( image, \"gif-loop\", gif->loop );\n\tif( gif->comment ) \n\t\tvips_image_set_string( image, \"gif-comment\", gif->comment );\n\n\treturn( 0 );\n}\n\n/* Attempt to quickly scan a GIF and discover what we need for our header. We\n * need to scan the whole file to get n_pages, transparency and colour. \n *\n * Don't flag errors during header scan. Many GIFs do not follow spec.\n */\nstatic int\nvips_foreign_load_gif_header( VipsForeignLoad *load )\n{\n\tVipsObjectClass *class = VIPS_OBJECT_GET_CLASS( load );\n\tVipsForeignLoadGifClass *gif_class = \n\t\t(VipsForeignLoadGifClass *) VIPS_OBJECT_GET_CLASS( load );\n\tVipsForeignLoadGif *gif = (VipsForeignLoadGif *) load;\n\n\tGifRecordType record;\n\n\tif( gif_class->open( gif ) )\n\t\treturn( -1 );\n\n\tgif->n_pages = 0;\n\n\tdo {\n\t\tif( DGifGetRecordType( gif->file, &record ) == GIF_ERROR ) \n\t\t\tcontinue;\n\n\t\tswitch( record ) {\n\t\tcase IMAGE_DESC_RECORD_TYPE:\n\t\t\t(void) vips_foreign_load_gif_scan_image( gif );\n\n\t\t\tgif->n_pages += 1;\n\n\t\t\tbreak;\n\n\t\tcase EXTENSION_RECORD_TYPE:\n\t\t\t/* We will need to fetch the extensions to check for\n\t\t\t * cmaps and transparency.\n\t\t\t */\n\t\t\t(void) vips_foreign_load_gif_scan_extension( gif );\n\t\t\tbreak;\n\n\t\tcase TERMINATE_RECORD_TYPE:\n\t\t\tgif->eof = TRUE;\n\t\t\tbreak;\n\n\t\tcase SCREEN_DESC_RECORD_TYPE:\n\t\tcase UNDEFINED_RECORD_TYPE:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} while( !gif->eof );\n\n\tif( gif->n == -1 )\n\t\tgif->n = gif->n_pages - gif->page;\n\n\tif( gif->page < 0 ||\n\t\tgif->n <= 0 ||\n\t\tgif->page + gif->n > gif->n_pages ) {\n\t\tvips_error( class->nickname, \"%s\", _( \"bad page number\" ) ); \n\t\treturn( -1 ); \n\t}\n\n\t/* And set the output vips header from what we've learned.\n\t */\n\tif( vips_foreign_load_gif_set_header( gif, load->out ) )\n\t\treturn( -1 );\n\n\treturn( 0 );\n}\n\nstatic void\nvips_foreign_load_gif_build_cmap( VipsForeignLoadGif *gif )\n{\n\tColorMapObject *map = gif->file->Image.ColorMap ?\n\t\tgif->file->Image.ColorMap : gif->file->SColorMap;\n\n\tint v;\n\n\tfor( v = 0; v < 256; v++ ) {\n\t\tVipsPel *q = (VipsPel *) &gif->cmap[v];\n\n\t\tif( map &&\n\t\t\tv < map->ColorCount ) {\n\t\t\tq[0] = map->Colors[v].Red;\n\t\t\tq[1] = map->Colors[v].Green;\n\t\t\tq[2] = map->Colors[v].Blue;\n\t\t\tq[3] = 255;\n\t\t}\n\t\telse {\n\t\t\t/* If there's no map, just save the index.\n\t\t\t */\n\t\t\tq[0] = v;\n\t\t\tq[1] = v;\n\t\t\tq[2] = v;\n\t\t\tq[3] = 255;\n\t\t}\n\t}\n}\n\nstatic void\nvips_foreign_load_gif_render_line( VipsForeignLoadGif *gif,\n\tint width, VipsPel * restrict q, VipsPel * restrict p )\n{\n\tguint32 *iq;\n\tint x;\n\n\tiq = (guint32 *) q;\n\tfor( x = 0; x < width; x++ ) {\n\t\tVipsPel v = p[x];\n\t\t\n\t\tif( v == gif->transparency ) {\n\t\t\t/* In DISPOSE_DO_NOT mode, the previous frame shows\n\t\t\t * through (ie. we do nothing). In all other modes, \n\t\t\t * it's just transparent.\n\t\t\t */\n\t\t\tif( gif->dispose != DISPOSE_DO_NOT ) \n\t\t\t\tiq[x] = 0;\n\t\t}\n\t\telse\n\t\t\t/* Blast in the RGBA for this value.\n\t\t\t */\n\t\t\tiq[x] = gif->cmap[v];\n\t}\n}\n\n/* Render the current gif frame into an RGBA buffer. GIFs can accumulate, \n * depending on the current dispose mode.\n */\nstatic int\nvips_foreign_load_gif_render( VipsForeignLoadGif *gif ) \n{\n\tGifFileType *file = gif->file;\n\n\t/* Update the colour map for this frame.\n\t */\n\tvips_foreign_load_gif_build_cmap( gif );\n\n\t/* BACKGROUND means we reset the frame to 0 (transparent) before we \n\t * render the next set of pixels.\n\t */\n\tif( gif->dispose == DISPOSE_BACKGROUND ) \n\t\tmemset( VIPS_IMAGE_ADDR( gif->frame, 0, 0 ), 0, \n\t\t\tVIPS_IMAGE_SIZEOF_IMAGE( gif->frame ) );\n\n\t/* PREVIOUS means we init the frame with the frame before last, ie. we\n\t * undo the last render.\n\t *\n\t * Anything other than PREVIOUS, we must update the previous buffer,\n\t */\n\tif( gif->dispose == DISPOSE_PREVIOUS ) \n\t\tmemcpy( VIPS_IMAGE_ADDR( gif->frame, 0, 0 ),\n\t\t\tVIPS_IMAGE_ADDR( gif->previous, 0, 0 ),\n\t\t\tVIPS_IMAGE_SIZEOF_IMAGE( gif->frame ) );\n\telse \n\t\tmemcpy( VIPS_IMAGE_ADDR( gif->previous, 0, 0 ),\n\t\t\tVIPS_IMAGE_ADDR( gif->frame, 0, 0 ),\n\t\t\tVIPS_IMAGE_SIZEOF_IMAGE( gif->frame ) );\n\n\tif( file->Image.Interlace ) {\n\t\tint i;\n\n\t\tVIPS_DEBUG_MSG( \"vips_foreign_load_gif_render: \"\n\t\t\t\"interlaced frame of %d x %d pixels at %d x %d\\n\",\n\t\t\tfile->Image.Width, file->Image.Height,\n\t\t\tfile->Image.Left, file->Image.Top ); \n\n\t\tfor( i = 0; i < 4; i++ ) {\n\t\t\tint y;\n\n\t\t\tfor( y = InterlacedOffset[i]; \n\t\t\t\ty < file->Image.Height;\n\t\t\t  \ty += InterlacedJumps[i] ) {\n\t\t\t\tVipsPel *q = VIPS_IMAGE_ADDR( gif->frame, \n\t\t\t\t\tfile->Image.Left, file->Image.Top + y );\n\n\t\t\t\tif( DGifGetLine( gif->file, gif->line, \n\t\t\t\t\tfile->Image.Width ) == GIF_ERROR ) {\n\t\t\t\t\tvips_foreign_load_gif_error( gif ); \n\t\t\t\t\treturn( -1 ); \n\t\t\t\t}\n\n\t\t\t\tvips_foreign_load_gif_render_line( gif, \n\t\t\t\t\tfile->Image.Width, q, gif->line ); \n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tint y;\n\n\t\tVIPS_DEBUG_MSG( \"vips_foreign_load_gif_render: \"\n\t\t\t\"non-interlaced frame of %d x %d pixels at %d x %d\\n\",\n\t\t\tfile->Image.Width, file->Image.Height,\n\t\t\tfile->Image.Left, file->Image.Top ); \n\n\t\tfor( y = 0; y < file->Image.Height; y++ ) {\n\t\t\tVipsPel *q = VIPS_IMAGE_ADDR( gif->frame, \n\t\t\t\tfile->Image.Left, file->Image.Top + y );\n\n\t\t\tif( DGifGetLine( gif->file, gif->line, \n\t\t\t\tfile->Image.Width ) == GIF_ERROR ) {\n\t\t\t\tvips_foreign_load_gif_error( gif ); \n\t\t\t\treturn( -1 ); \n\t\t\t}\n\n\t\t\tvips_foreign_load_gif_render_line( gif, \n\t\t\t\tfile->Image.Width, q, gif->line ); \n\t\t}\n\t}\n\n\treturn( 0 );\n}\n\nstatic int\nvips_foreign_load_gif_extension( VipsForeignLoadGif *gif )\n{\n\tGifByteType *extension;\n\tint ext_code;\n\n\tVIPS_DEBUG_MSG( \"vips_foreign_load_gif_extension:\\n\" ); \n\n\tif( DGifGetExtension( gif->file, &ext_code, &extension ) == \n\t\tGIF_ERROR ) {\n\t\tvips_foreign_load_gif_error( gif ); \n\t\treturn( -1 ); \n\t}\n\n\tif( extension &&\n\t\text_code == GRAPHICS_EXT_FUNC_CODE &&\n\t\textension[0] == 4 ) { \n\t\t/* Bytes are flags, delay low, delay high,\n\t\t * transparency. Flag bit 1 means transparency\n\t\t * is being set.\n\t\t */\n\t\tgif->transparency = -1;\n\t\tif( extension[1] & 0x1 ) \n\t\t\tgif->transparency = extension[4];\n\n\t\t/* Set the current dispose mode. This is read during frame load\n\t\t * to set the meaning of background and transparent pixels.\n\t\t */\n\t\tgif->dispose = (extension[1] >> 2) & 0x7;\n\t\tVIPS_DEBUG_MSG( \"vips_foreign_load_gif_extension: \"\n\t\t\t\"dispose = %d\\n\", gif->dispose ); \n\t}\n\n\twhile( extension != NULL ) \n\t\tif( vips_foreign_load_gif_ext_next( gif, &extension ) )\n\t\t\treturn( -1 ); \n\n\treturn( 0 );\n}\n\n/* Read the next page from the file into @frame.\n */\nstatic int\nvips_foreign_load_gif_next_page( VipsForeignLoadGif *gif )\n{\n\tGifRecordType record;\n\tgboolean have_read_frame;\n\n\thave_read_frame = FALSE;\n\tdo { \n\t\tif( DGifGetRecordType( gif->file, &record ) == GIF_ERROR ) {\n\t\t\tvips_foreign_load_gif_error( gif ); \n\t\t\treturn( -1 ); \n\t\t}\n\n\t\tswitch( record ) {\n\t\tcase IMAGE_DESC_RECORD_TYPE:\n\t\t\tVIPS_DEBUG_MSG( \"vips_foreign_load_gif_next_page: \"\n\t\t\t\t\"IMAGE_DESC_RECORD_TYPE\\n\" ); \n\n\t\t\tif( DGifGetImageDesc( gif->file ) == GIF_ERROR ) {\n\t\t\t\tvips_foreign_load_gif_error( gif ); \n\t\t\t\treturn( -1 ); \n\t\t\t}\n\n\t\t\tif( vips_foreign_load_gif_render( gif ) )\n\t\t\t\treturn( -1 ); \n\n\t\t\thave_read_frame = TRUE;\n\n\t\t\tbreak;\n\n\t\tcase EXTENSION_RECORD_TYPE:\n\t\t\tif( vips_foreign_load_gif_extension( gif ) )\n\t\t\t\treturn( -1 );\n\t\t\tbreak;\n\n\t\tcase TERMINATE_RECORD_TYPE:\n\t\t\tVIPS_DEBUG_MSG( \"vips_foreign_load_gif_next_page: \"\n\t\t\t\t\"TERMINATE_RECORD_TYPE\\n\" ); \n\t\t\tgif->eof = TRUE;\n\t\t\tbreak;\n\n\t\tcase SCREEN_DESC_RECORD_TYPE:\n\t\t\tVIPS_DEBUG_MSG( \"vips_foreign_load_gif_next_page: \"\n\t\t\t\t\"SCREEN_DESC_RECORD_TYPE\\n\" );\n\t\t\tbreak;\n\n\t\tcase UNDEFINED_RECORD_TYPE:\n\t\t\tVIPS_DEBUG_MSG( \"vips_foreign_load_gif_next_page: \"\n\t\t\t\t\"UNDEFINED_RECORD_TYPE\\n\" );\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} while( !have_read_frame &&\n\t\t!gif->eof );\n\n\treturn( 0 );\n}\n\nstatic int\nvips_foreign_load_gif_generate( VipsRegion *or, \n\tvoid *seq, void *a, void *b, gboolean *stop )\n{\n        VipsRect *r = &or->valid;\n\tVipsForeignLoadGif *gif = (VipsForeignLoadGif *) a;\n\n\tint y;\n\n\tfor( y = 0; y < r->height; y++ ) {\n\t\t/* The page for this output line, and the line number in page.\n\t\t */\n\t\tint page = (r->top + y) / gif->file->SHeight + gif->page;\n\t\tint line = (r->top + y) % gif->file->SHeight;\n\n\t\tVipsPel *p, *q;\n\t\tint x;\n\n\t\tg_assert( line >= 0 && line < gif->frame->Ysize );\n\t\tg_assert( page >= 0 && page < gif->n_pages );\n\n\t\t/* current_page == 0 means we've not loaded any pages yet. So \n\t\t * we need to have loaded the page beyond the page we want.\n\t\t */\n\t\twhile( gif->current_page <= page ) {\n\t\t\tif( vips_foreign_load_gif_next_page( gif ) )\n\t\t\t\treturn( -1 );\n\n\t\t\tgif->current_page += 1; \n\t\t}\n\n\t\t/* @frame is always RGBA, but or may be G, GA, RGB or RGBA. \n\t\t * We have to pick out the values we want.\n\t\t */\n\t\tp = VIPS_IMAGE_ADDR( gif->frame, 0, line );\n\t\tq = VIPS_REGION_ADDR( or, 0, r->top + y );\n\t\tswitch( or->im->Bands ) {\n\t\tcase 1:\n\t\t\tfor( x = 0; x < gif->frame->Xsize; x++ ) {\n\t\t\t\tq[0] = p[1];\n\n\t\t\t\tq += 1;\n\t\t\t\tp += 4;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tfor( x = 0; x < gif->frame->Xsize; x++ ) {\n\t\t\t\tq[0] = p[1];\n\t\t\t\tq[1] = p[3];\n\n\t\t\t\tq += 2;\n\t\t\t\tp += 4;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\tfor( x = 0; x < gif->frame->Xsize; x++ ) {\n\t\t\t\tq[0] = p[0];\n\t\t\t\tq[1] = p[1];\n\t\t\t\tq[2] = p[2];\n\n\t\t\t\tq += 3;\n\t\t\t\tp += 4;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\tmemcpy( q, p, VIPS_IMAGE_SIZEOF_LINE( gif->frame ) );\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tg_assert_not_reached();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn( 0 );\n}\n\nstatic int\nvips_foreign_load_gif_load( VipsForeignLoad *load )\n{\n\tVipsForeignLoadGifClass *class = \n\t\t(VipsForeignLoadGifClass *) VIPS_OBJECT_GET_CLASS( load );\n\tVipsForeignLoadGif *gif = (VipsForeignLoadGif *) load;\n\tVipsImage **t = (VipsImage **) \n\t\tvips_object_local_array( VIPS_OBJECT( load ), 4 );\n\n\t/* Rewind.\n\t */\n\tif( class->open( gif ) )\n\t\treturn( -1 );\n\n\tVIPS_DEBUG_MSG( \"vips_foreign_load_gif_load:\\n\" ); \n\n\t/* Make the memory image we accumulate pixels in. We always accumulate\n\t * to RGBA, then trim down to whatever the output image needs on\n\t * _generate.\n\t */\n\tgif->frame = vips_image_new_memory();\n\tvips_image_init_fields( gif->frame, \n\t\tgif->file->SWidth, gif->file->SHeight, 4, VIPS_FORMAT_UCHAR,\n\t\tVIPS_CODING_NONE, VIPS_INTERPRETATION_sRGB, 1.0, 1.0 );\n\tif( vips_image_write_prepare( gif->frame ) ) \n\t\treturn( -1 );\n\n\t/* A copy of the previous state of the frame, in case we have to\n\t * process a DISPOSE_PREVIOUS.\n\t */\n\tgif->previous = vips_image_new_memory();\n\tvips_image_init_fields( gif->previous, \n\t\tgif->file->SWidth, gif->file->SHeight, 4, VIPS_FORMAT_UCHAR,\n\t\tVIPS_CODING_NONE, VIPS_INTERPRETATION_sRGB, 1.0, 1.0 );\n\tif( vips_image_write_prepare( gif->previous ) ) \n\t\treturn( -1 );\n\n\t/* Make the output pipeline.\n\t */\n\tt[0] = vips_image_new();\n\tif( vips_foreign_load_gif_set_header( gif, t[0] ) )\n\t\treturn( -1 );\n\n\t/* Strips 8 pixels high to avoid too many tiny regions.\n\t */\n\tif( vips_image_generate( t[0], \n\t\tNULL, vips_foreign_load_gif_generate, NULL, gif, NULL ) ||\n\t\tvips_sequential( t[0], &t[1], \n\t\t\t\"tile_height\", VIPS__FATSTRIP_HEIGHT, \n\t\t\tNULL ) ||\n\t\tvips_image_write( t[1], load->real ) )\n\t\treturn( -1 );\n\n\treturn( 0 );\n}\n\nstatic int\nvips_foreign_load_gif_open( VipsForeignLoadGif *gif )\n{\n#ifdef HAVE_GIFLIB_5\n{\n\tint error;\n\n\tif( !(gif->file = DGifOpen( gif, gif->read_func, &error )) ) {\n\t\tvips_foreign_load_gif_error_vips( gif, error );\n\t\treturn( -1 ); \n\t}\n}\n#else \n\tif( !(gif->file = DGifOpen( gif, gif->read_func )) ) { \n\t\tvips_foreign_load_gif_error_vips( gif, GifLastError() ); \n\t\treturn( -1 ); \n\t}\n#endif\n\n\tgif->eof = FALSE;\n\tgif->current_page = 0;\n\n\t/* Allocate a line buffer now that we have the GIF width.\n\t */\n\tVIPS_FREE( gif->line ) \n\tif( !(gif->line = VIPS_ARRAY( NULL, gif->file->SWidth, GifPixelType )) )\n\t\treturn( -1 ); \n\n\treturn( 0 );\n}\n\nstatic void\nvips_foreign_load_gif_class_init( VipsForeignLoadGifClass *class )\n{\n\tGObjectClass *gobject_class = G_OBJECT_CLASS( class );\n\tVipsObjectClass *object_class = (VipsObjectClass *) class;\n\tVipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;\n\tVipsForeignLoadGifClass *gif_class = (VipsForeignLoadGifClass *) class;\n\n\tgobject_class->dispose = vips_foreign_load_gif_dispose;\n\tgobject_class->set_property = vips_object_set_property;\n\tgobject_class->get_property = vips_object_get_property;\n\n\tgif_class->open = vips_foreign_load_gif_open;\n\tload_class->header = vips_foreign_load_gif_header;\n\tload_class->load = vips_foreign_load_gif_load;\n\n\tobject_class->nickname = \"gifload_base\";\n\tobject_class->description = _( \"load GIF with giflib\" );\n\n\tload_class->get_flags_filename = \n\t\tvips_foreign_load_gif_get_flags_filename;\n\tload_class->get_flags = vips_foreign_load_gif_get_flags;\n\n\tVIPS_ARG_INT( class, \"page\", 20,\n\t\t_( \"Page\" ),\n\t\t_( \"Load this page from the file\" ),\n\t\tVIPS_ARGUMENT_OPTIONAL_INPUT,\n\t\tG_STRUCT_OFFSET( VipsForeignLoadGif, page ),\n\t\t0, 100000, 0 );\n\n\tVIPS_ARG_INT( class, \"n\", 21,\n\t\t_( \"n\" ),\n\t\t_( \"Load this many pages\" ),\n\t\tVIPS_ARGUMENT_OPTIONAL_INPUT,\n\t\tG_STRUCT_OFFSET( VipsForeignLoadGif, n ),\n\t\t-1, 100000, 1 );\n\n}\n\nstatic void\nvips_foreign_load_gif_init( VipsForeignLoadGif *gif )\n{\n\tgif->n = 1;\n\tgif->transparency = -1;\n\tgif->delay = 4;\n\tgif->loop = 0;\n\tgif->comment = NULL;\n\tgif->dispose = 0;\n}\n\ntypedef struct _VipsForeignLoadGifFile {\n\tVipsForeignLoadGif parent_object;\n\n\t/* Filename for load.\n\t */\n\tchar *filename; \n\n\t/* The FILE* we read from.\n\t */\n\tFILE *fp;\n\n} VipsForeignLoadGifFile;\n\ntypedef VipsForeignLoadGifClass VipsForeignLoadGifFileClass;\n\nG_DEFINE_TYPE( VipsForeignLoadGifFile, vips_foreign_load_gif_file, \n\tvips_foreign_load_gif_get_type() );\n\nstatic void\nvips_foreign_load_gif_file_dispose( GObject *gobject )\n{\n\tVipsForeignLoadGifFile *file = (VipsForeignLoadGifFile *) gobject;\n\n\tVIPS_FREEF( fclose, file->fp ); \n\n\tG_OBJECT_CLASS( vips_foreign_load_gif_file_parent_class )->\n\t\tdispose( gobject );\n}\n\n/* Our input function for file open. We can't use DGifOpenFileName(), since\n * that just calls open() and won't work with unicode on win32. We can't use\n * DGifOpenFileHandle() since that's an fd from open() and you can't pass those\n * across DLL boundaries on Windows. \n */\nstatic int \nvips_giflib_file_read( GifFileType *gfile, GifByteType *buffer, int n )\n{\n\tVipsForeignLoadGif *gif = (VipsForeignLoadGif *) gfile->UserData;\n\tVipsForeignLoadGifFile *file = (VipsForeignLoadGifFile *) gif;\n\n\tif( feof( file->fp ) )\n\t\tgif->eof = TRUE;\n\n\treturn( (int) fread( (void *) buffer, 1, n, file->fp ) );\n}\n\nstatic int\nvips_foreign_load_gif_file_open( VipsForeignLoadGif *gif )\n{\n\tVipsForeignLoad *load = (VipsForeignLoad *) gif;\n\tVipsForeignLoadGifFile *file = (VipsForeignLoadGifFile *) gif;\n\n\tif( !file->fp ) {\n\t\tif( !(file->fp = \n\t\t\tvips__file_open_read( file->filename, NULL, FALSE )) ) \n\t\t\treturn( -1 ); \n\n\t\tVIPS_SETSTR( load->out->filename, file->filename );\n\t}\n\telse \n\t\trewind( file->fp );\n\n\tvips_foreign_load_gif_close( gif );\n\tgif->read_func = vips_giflib_file_read;\n\n\treturn( VIPS_FOREIGN_LOAD_GIF_CLASS( \n\t\tvips_foreign_load_gif_file_parent_class )->open( gif ) );\n}\n\nstatic const char *vips_foreign_gif_suffs[] = {\n\t\".gif\",\n\tNULL\n};\n\nstatic void\nvips_foreign_load_gif_file_class_init( \n\tVipsForeignLoadGifFileClass *class )\n{\n\tGObjectClass *gobject_class = G_OBJECT_CLASS( class );\n\tVipsObjectClass *object_class = (VipsObjectClass *) class;\n\tVipsForeignClass *foreign_class = (VipsForeignClass *) class;\n\tVipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;\n\tVipsForeignLoadGifClass *gif_class = (VipsForeignLoadGifClass *) class;\n\n\tgobject_class->dispose = vips_foreign_load_gif_file_dispose;\n\tgobject_class->set_property = vips_object_set_property;\n\tgobject_class->get_property = vips_object_get_property;\n\n\tobject_class->nickname = \"gifload\";\n\tobject_class->description = _( \"load GIF with giflib\" );\n\n\tforeign_class->suffs = vips_foreign_gif_suffs;\n\n\tload_class->is_a = vips_foreign_load_gif_is_a;\n\n\tgif_class->open = vips_foreign_load_gif_file_open;\n\n\tVIPS_ARG_STRING( class, \"filename\", 1, \n\t\t_( \"Filename\" ),\n\t\t_( \"Filename to load from\" ),\n\t\tVIPS_ARGUMENT_REQUIRED_INPUT, \n\t\tG_STRUCT_OFFSET( VipsForeignLoadGifFile, filename ),\n\t\tNULL );\n\n}\n\nstatic void\nvips_foreign_load_gif_file_init( VipsForeignLoadGifFile *file )\n{\n}\n\ntypedef struct _VipsForeignLoadGifBuffer {\n\tVipsForeignLoadGif parent_object;\n\n\t/* Load from a buffer.\n\t */\n\tVipsArea *buf;\n\n\t/* Current read point, bytes left in buffer.\n\t */\n\tVipsPel *p;\n\tsize_t bytes_to_go;\n\n} VipsForeignLoadGifBuffer;\n\ntypedef VipsForeignLoadGifClass VipsForeignLoadGifBufferClass;\n\nG_DEFINE_TYPE( VipsForeignLoadGifBuffer, vips_foreign_load_gif_buffer, \n\tvips_foreign_load_gif_get_type() );\n\n/* Callback from the gif loader.\n *\n * Read up to len bytes into buffer, return number of bytes read, 0 for EOF.\n */\nstatic int\nvips_giflib_buffer_read( GifFileType *file, GifByteType *buf, int n )\n{\n\tVipsForeignLoadGif *gif = (VipsForeignLoadGif *) file->UserData;\n\tVipsForeignLoadGifBuffer *buffer = (VipsForeignLoadGifBuffer *) gif;\n\tsize_t will_read = VIPS_MIN( n, buffer->bytes_to_go );\n\n\tmemcpy( buf, buffer->p, will_read );\n\tbuffer->p += will_read;\n\tbuffer->bytes_to_go -= will_read;\n\n\tif( will_read == 0 )\n\t\tgif->eof = TRUE;\n\n\treturn( will_read ); \n}\n\nstatic int\nvips_foreign_load_gif_buffer_open( VipsForeignLoadGif *gif )\n{\n\tVipsForeignLoadGifBuffer *buffer = (VipsForeignLoadGifBuffer *) gif;\n\n\tvips_foreign_load_gif_close( gif );\n\tbuffer->p = buffer->buf->data;\n\tbuffer->bytes_to_go = buffer->buf->length;\n\tgif->read_func = vips_giflib_buffer_read;;\n\n\treturn( VIPS_FOREIGN_LOAD_GIF_CLASS( \n\t\tvips_foreign_load_gif_file_parent_class )->open( gif ) );\n}\n\nstatic void\nvips_foreign_load_gif_buffer_class_init( \n\tVipsForeignLoadGifBufferClass *class )\n{\n\tGObjectClass *gobject_class = G_OBJECT_CLASS( class );\n\tVipsObjectClass *object_class = (VipsObjectClass *) class;\n\tVipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;\n\tVipsForeignLoadGifClass *gif_class = (VipsForeignLoadGifClass *) class;\n\n\tgobject_class->set_property = vips_object_set_property;\n\tgobject_class->get_property = vips_object_get_property;\n\n\tobject_class->nickname = \"gifload_buffer\";\n\tobject_class->description = _( \"load GIF with giflib\" );\n\n\tload_class->is_a_buffer = vips_foreign_load_gif_is_a_buffer;\n\n\tgif_class->open = vips_foreign_load_gif_buffer_open;\n\n\tVIPS_ARG_BOXED( class, \"buffer\", 1, \n\t\t_( \"Buffer\" ),\n\t\t_( \"Buffer to load from\" ),\n\t\tVIPS_ARGUMENT_REQUIRED_INPUT, \n\t\tG_STRUCT_OFFSET( VipsForeignLoadGifBuffer, buf ),\n\t\tVIPS_TYPE_BLOB );\n\n}\n\nstatic void\nvips_foreign_load_gif_buffer_init( VipsForeignLoadGifBuffer *buffer )\n{\n}\n\n#endif /*HAVE_GIFLIB*/\n\n/**\n * vips_gifload:\n * @filename: file to load\n * @out: (out): output image\n * @...: %NULL-terminated list of optional named arguments\n *\n * Optional arguments:\n *\n * * @page: %gint, page (frame) to read\n * * @n: %gint, load this many pages\n *\n * Read a GIF file into a VIPS image.\n *\n * Use @page to select a page to render, numbering from zero.\n *\n * Use @n to select the number of pages to render. The default is 1. Pages are\n * rendered in a vertical column, with each individual page aligned to the\n * left. Set to -1 to mean \"until the end of the document\". Use vips_grid() \n * to change page layout.\n *\n * The whole GIF is rendered into memory on header access. The output image\n * will be 1, 2, 3 or 4 bands depending on what the reader finds in the file. \n *\n * See also: vips_image_new_from_file().\n *\n * Returns: 0 on success, -1 on error.\n */\nint\nvips_gifload( const char *filename, VipsImage **out, ... )\n{\n\tva_list ap;\n\tint result;\n\n\tva_start( ap, out );\n\tresult = vips_call_split( \"gifload\", ap, filename, out );\n\tva_end( ap );\n\n\treturn( result );\n}\n\n/**\n * vips_gifload_buffer:\n * @buf: (array length=len) (element-type guint8): memory area to load\n * @len: (type gsize): size of memory area\n * @out: (out): image to write\n * @...: %NULL-terminated list of optional named arguments\n *\n * Optional arguments:\n *\n * * @page: %gint, page (frame) to read\n * * @n: %gint, load this many pages\n *\n * Read a GIF-formatted memory block into a VIPS image. Exactly as\n * vips_gifload(), but read from a memory buffer. \n *\n * You must not free the buffer while @out is active. The \n * #VipsObject::postclose signal on @out is a good place to free. \n *\n * See also: vips_gifload().\n *\n * Returns: 0 on success, -1 on error.\n */\nint\nvips_gifload_buffer( void *buf, size_t len, VipsImage **out, ... )\n{\n\tva_list ap;\n\tVipsBlob *blob;\n\tint result;\n\n\t/* We don't take a copy of the data or free it.\n\t */\n\tblob = vips_blob_new( NULL, buf, len );\n\n\tva_start( ap, out );\n\tresult = vips_call_split( \"gifload_buffer\", ap, blob, out );\n\tva_end( ap );\n\n\tvips_area_unref( VIPS_AREA( blob ) );\n\n\treturn( result );\n}\n\n"], "filenames": ["libvips/foreign/gifload.c"], "buggy_code_start_loc": [411], "buggy_code_end_loc": [437], "fixing_code_start_loc": [411], "fixing_code_end_loc": [438], "type": "CWE-416", "message": "vips_foreign_load_gif_scan_image in foreign/gifload.c in libvips before 8.8.2 tries to access a color map before a DGifGetImageDesc call, leading to a use-after-free.", "other": {"cve": {"id": "CVE-2019-17534", "sourceIdentifier": "cve@mitre.org", "published": "2019-10-13T02:15:12.317", "lastModified": "2019-10-17T16:10:28.807", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "vips_foreign_load_gif_scan_image in foreign/gifload.c in libvips before 8.8.2 tries to access a color map before a DGifGetImageDesc call, leading to a use-after-free."}, {"lang": "es", "value": "La funci\u00f3n vips_foreign_load_gif_scan_image en el archivo foreign/gifload.c en libvips versiones anteriores a que 8.8.2 intenta acceder a un mapa de colores antes de una llamada a DGifGetImageDesc, lo que conlleva a un uso de la memoria previamente liberada."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libvips_project:libvips:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.8.2", "matchCriteriaId": "AB92353C-1E56-4BAA-9898-5FBC3AB81B0F"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=16796", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/libvips/libvips/commit/ce684dd008532ea0bf9d4a1d89bacb35f4a83f4d", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/libvips/libvips/compare/v8.8.1...v8.8.2", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/libvips/libvips/commit/ce684dd008532ea0bf9d4a1d89bacb35f4a83f4d"}}